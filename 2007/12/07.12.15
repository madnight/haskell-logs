00:00:12 <MaxRabkin> sorear: but sometimes you ask yourself what the problem is, and you come to the answer: my problem is the management of state; I know there is a state monad which assists in said management, but I don't know how to use it
00:03:05 <shachaf> Or: You don't have any particular problem, but you want to understand how the State monad works.
00:03:43 <shachaf> (In which case @source Control.Monad.State may well be the best resource.)
00:04:23 <zou> sorear: the problem that i tried to solve is that i have a list of words and a data structure,  i want to walk through the list of words and fill the data for that data structure by looking up some dictionary that might contains these words
00:04:38 <zou> thank you MaxRabkin and shachaf
00:05:05 <zou> and i was thinking that the data structure is the kind of state that i'd need to maintain while walking the list
00:05:17 <glguy> :t mapAccumL
00:05:18 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
00:05:19 <glguy> :t foldl
00:05:20 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
00:05:50 <shachaf> zou: What glguy said, maybe -- are you sure you need State?
00:06:49 <zou> i'm not sure, as i'm new, but i thought that to maintain/share any kind of info, you need to use monad
00:07:02 <zou> thus the question on monad.state
00:07:28 <glguy> which question?
00:09:58 <zou> glguy: i asked for pointers on state monad before
00:10:13 <shachaf> > sum [1..5] -- sum maintains/shares the information as it sums the list.
00:10:15 <lambdabot>  15
00:10:26 <glguy> zou, It's just that that is so vague that it's nearly impossible to help you
00:10:43 <shachaf> zou: The State monad doesn't do anything you couldn't do by hand -- it's not magical.
00:11:07 <zou> glguy, ok, here is a bit more info
00:11:09 <glguy> foldl (\ my_data_structure word -> f lookup_external_dictionary word my_data_structure) words_list
00:11:22 <glguy> and insert "initial_data_structure"
00:11:23 <MaxRabkin> Is anyone here doing the SACO?
00:11:27 <glguy> before words_list *
00:11:31 <OceanSpray> It finally compiled!
00:11:33 <OceanSpray> WHOO
00:15:07 <zou> glguy: i thought that you can't update my_data_structure inside f
00:15:16 <zou> in your foldl example
00:15:22 <shachaf> zou: There is no updating.
00:16:10 <shachaf> zou: foldl is calling itself with a new and improved version of the data structure.
00:16:19 <shachaf> zou: And eventually returning that.
00:17:12 <shachaf> > sum [1..5] -- It's a lot like this. Do you "update" an accumulator?
00:17:14 <lambdabot>  15
00:19:03 <zou> let's say that the data Record = Record {name: String, age: Integer}
00:19:27 <zou> and i'd want to fill the name and age based on the list of words by looking up the words in a dictionary
00:19:46 <zou> wouldn't the f have to update the initial_reord?
00:23:01 <shachaf> zou: There's no such thing as updating.
00:23:14 <OceanSpray> :t runStateT
00:23:16 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
00:23:20 <OceanSpray> :t evalStateT
00:23:25 <lambdabot> forall s (m :: * -> *) a. (Monad m) => StateT s m a -> s -> m a
00:23:53 <shachaf> @ty execStateT -- While you're at it. :-)
00:23:54 <lambdabot> forall s (m :: * -> *) a. (Monad m) => StateT s m a -> s -> m s
00:24:12 <OceanSpray> but they're the same!
00:24:23 <shachaf> zou: Can you give a bit more context?
00:24:29 <shachaf> OceanSpray: What's the same?
00:24:33 <allbery_b> look more closely, OceanSpray
00:24:56 <OceanSpray> oh
00:25:05 <OceanSpray> m s instead of m a
00:25:29 <OceanSpray> :t runWriterT
00:25:30 <lambdabot> forall w (m :: * -> *) a. WriterT w m a -> m (a, w)
00:25:39 <OceanSpray> :t evalWriterT
00:25:39 <lambdabot> Not in scope: `evalWriterT'
00:25:56 <OceanSpray> :t execWriterT
00:25:57 <lambdabot> forall w (m :: * -> *) a. (Monad m) => WriterT w m a -> m w
00:26:53 <zou> shachaf, i'd like to extract some relevant info out of a set of words, for example, "toyota 1999 corolla LE great condition"
00:27:27 <zou> i'd like to extract year, model, make, and let's say i have a AutoInfo data type
00:27:56 <zou> i'd like to produce an autoInfo instance after i walk through the list of words
00:28:23 <zou> let's say that i have a predefined dictionary for auto makers, etc
00:29:15 <MaxRabkin> Is nobody going to give Haskell a showing at the SACO?
00:29:27 <OceanSpray> :t runReaderT
00:29:27 <MaxRabkin> It doesn't look like anybody responded
00:29:28 <lambdabot> forall r (m :: * -> *) a. ReaderT r m a -> r -> m a
00:32:23 <tetha> zou: so, basically, you want to partition a given list according to a set of given classifiers?
00:33:08 <zou> tetha, not just partition, but also produce a record that contains the extracted words
00:33:18 <OceanSpray> :t runContT
00:33:20 <lambdabot> forall r (m :: * -> *) a. ContT r m a -> (a -> m r) -> m r
00:34:11 <tetha> zou: creating that record is easy once you have that partition, I guess, because you just have another function that turns such apartition into that record
00:35:35 <zou> tetha: how?
00:39:48 <tetha> assuming the partition-function returns a list of those partitions, you could simply define something like part2Record [[manu],[type],...] = Car{manufacturer=manu, type=type}
00:43:40 <zou> tetha, how do you get the partitioned list? do you have to walk through the list multiple times?
00:44:56 <tetha> zou: I think of something like [a] -> [(a->Bool)]->[[a]], and thus, yes, you either have to walk over the predicate-list  or the source-list several times
00:51:53 <dmwit> :t let label xs ls = [(x, l) | x <- xs, (p, l) <- ls, p x] in label
00:51:54 <lambdabot> forall t t1. [t] -> [(t -> Bool, t1)] -> [(t, t1)]
00:53:41 <dmwit> :t let partition xs ls = map (flip filter xs) ls in partition
00:53:41 <lambdabot> forall a. [a] -> [a -> Bool] -> [[a]]
00:54:15 <tetha> dmwit: thats what I had in mind :)
00:54:28 <dmwit> :t map . flip filter
00:54:29 <lambdabot> forall a. [a] -> [a -> Bool] -> [[a]]
00:54:48 <dmwit> tetha: Yeah. =)  The first one was what I had in mind. =)
00:54:49 <dons> ?users
00:54:49 <lambdabot> Maximum users seen in #haskell: 440, currently: 375 (85.2%), active: 8 (2.1%)
00:55:05 <dmwit> The number of active users at any given time is pathetic.
00:56:10 <dmwit> Well, I guess what I really mean is that the percentage is always depressingly low.
00:56:46 <MaxRabkin> dmwit: it's hard for more than a dozen people to have a conversation or keep track of multiple conversations
00:57:28 <dmwit> Well, that's fair enough, but I thought \bot's "active" filter went back for two hours...?
00:57:45 <MaxRabkin> ah, that's a little different
01:01:10 <zou> glguy/shachaf, foldl works, thanks
01:04:18 <zou> another newbie question, how to test if a string can be converted into a number? using read?
01:04:32 <sjanssen> zou: use reads
01:04:47 <sjanssen> > reads "not a number" :: [(Int, String)]
01:04:49 <lambdabot>  []
01:04:56 <sjanssen> > reads "123" :: [(Int, String)]
01:04:56 <lambdabot>  [(123,"")]
01:05:05 <sjanssen> > reads "123 followed by garbage" :: [(Int, String)]
01:05:06 <lambdabot>  [(123," followed by garbage")]
01:05:57 <zou> reads "garbage 123 garbage"
01:06:21 <glguy> []
01:06:23 <sjanssen> zou: that will return []
01:07:25 <OceanSpray> Huzzah, I'm done
01:08:51 <zou> glguy/sjanssen, so is there an easy way to filter out 123  and 45 out of "garbage 123 garbage 45"
01:09:08 <sjanssen> zou: first step, use 'words'
01:09:26 <sjanssen> > words "garbage 123 garbage 45"
01:09:27 <lambdabot>  ["garbage","123","garbage","45"]
01:09:44 <dmwit> There needs to be a library function for (not . null).
01:09:47 <sjanssen> zou: then, use filter or concatMap to extract all the number-looking strings
01:10:30 <zou> sjanssen, how do you check for "number-looking"strings?
01:10:53 <sjanssen> zou: with reads, as I've demonstrated above
01:11:11 <dmwit> > filter (not . null) . map reads . words $ "garbage 123 garbage 45"
01:11:12 <lambdabot>  [[(123,"")],[(45,"")]]
01:11:38 <dmwit> > groupBy ((==) `on` isDigit) "garbage 123 garbage 45"
01:11:39 <lambdabot>  ["garbage ","123"," garbage ","45"]
01:12:16 <sjanssen> dmwit: the first won't work in for all instances of Read, but it's fine in this case
01:13:01 <sjanssen> @let maybeRead x = case reads x of [(x, "")] -> Just x; _ -> Nothing
01:13:02 <dmwit> Oh, yes, words would kill any derived Show instance, huh?
01:13:03 <lambdabot> Defined.
01:13:34 <sjanssen> dmwit: and you should also check that the parses are unique and there's no garbage at the end
01:13:55 <dmwit> A non-unique parse seems okay; keep them all.
01:14:15 <dmwit> But checking for garbage is a good idea.
01:14:48 <sjanssen> @let readm x = case reads x of [(x, "")] -> return x; _ -> fail "no parse"
01:14:50 <lambdabot> Defined.
01:15:07 <zou> dmwit, can you explain the groupby example
01:15:16 <sjanssen> > readm =<< words "garbage 123 garbage 45"
01:15:17 <lambdabot>  [123,45]
01:15:20 <dmwit> zou: Do you know how groupBy works?
01:16:39 <dmwit> (back in a minute or two)
01:18:21 <zou> sjanssen, why do  you use reads instead of read?
01:18:32 <sjanssen> > read "123"
01:18:33 <lambdabot>  123
01:18:40 <sjanssen> > read "adsf" :: Int
01:18:41 <lambdabot>  Exception: Prelude.read: no parse
01:18:53 <sjanssen> zou: because 'read' throws an exception, which is no good
01:20:10 <zou> sjanssen, cool
01:20:37 <zou> and is there a way to turn integer to string? i.e. the reverse of read/reads?
01:20:55 <sjanssen> show
01:25:39 <zou> :t groupBy
01:25:41 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
01:28:47 <zou> sjanssen/dwit: groupBy ((==) `on` isDigit) "garbage 123 garbage 45"
01:29:01 <idnar_> > groupBy ((==) `on` isDigit) "garbage 123 garbage 45"
01:29:08 <lambdabot>  ["garbage ","123"," garbage ","45"]
01:29:21 <idnar> nice
01:29:25 <zou> can you explain the predicate  ((==) `on` isDigit)?
01:29:59 <MaxRabkin> :t on
01:30:00 <lambdabot> Not in scope: `on'
01:30:09 <MaxRabkin> @index on
01:30:11 <lambdabot> bzzt
01:32:01 <dons> ?src on
01:32:02 <lambdabot> (*) `on` f = \x y -> f x * f y
01:32:30 <MaxRabkin> as I thought
01:32:33 <dons> (==) `on` isDigit ==> \x y -> isDigit x == isDigit y
01:34:58 <zou> thanks MaxRabkin/dons, cool stuff
01:46:01 <qweqwe> how i say != in haskell ?
01:46:17 <Korollary>  /=
01:47:29 <Korollary> @hoogle a -> a -> Bool
01:47:29 <lambdabot> Prelude.(==) :: Eq a => a -> a -> Bool
01:47:29 <lambdabot> Prelude.(/=) :: Eq a => a -> a -> Bool
01:47:29 <lambdabot> Prelude.(<) :: Ord a => a -> a -> Bool
01:47:46 <scook0> @pl (.)(.)(.) not (==)
01:47:46 <lambdabot> (/=)
01:48:02 <sjanssen> nice :) pl++
02:14:17 <mwc> heh, nice use for the mpd package
02:14:22 <mwc> withMPD $ next
02:14:25 <mwc> withMPD $ toggle
02:14:27 <mwc> etc.
02:14:39 <mwc> (from within GHCi)
02:14:57 <mwc> Would have veen even nicer before I had a multimedia keyboard with buttons to do all that
02:15:03 <Zao> The worlds most advanced remote control :)
02:15:10 <Zao> For the truly lazy.
02:18:46 <Gyde> If I want to map a "functions which takes 2 arguments a element from the list and coordinate tuble in that order" so I need to map the function with a fixed value onto the list, but the fixed value is the last argument in the function
02:19:22 <dmwit> :t flip
02:19:24 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
02:19:54 <jsnx> i'm using hGetLine to feed a parser, line by line. it works, but i get an exception at the end ("end of file"). what's the "right way" to read till end of file?
02:20:56 <dmwit> ?hoogle eof
02:20:57 <lambdabot> Text.ParserCombinators.Parsec.Combinator.eof :: Show tok => GenParser tok st ()
02:20:57 <lambdabot> Text.Read.EOF :: Lexeme
02:20:57 <lambdabot> Text.Read.Lex.EOF :: Lexeme
02:21:17 <dmwit> :t hiseof
02:21:21 <lambdabot> Not in scope: `hiseof'
02:21:29 <dmwit> bah
02:21:37 <dmwit> I'm sure it's something like that.
02:21:41 <dmwit> ?hoogle hiseof
02:21:41 <lambdabot> System.IO.hIsEOF :: Handle -> IO Bool
02:21:48 <Gyde> I thought of flip, but where to place it .. my call looks like this: map (ReadArray [List should be here] (Coordiate,Tuble)) [The list]
02:22:45 <dmwit> \xs -> map (readArray xs tuple) xs -- Just put it in both places, then.  Right?
02:24:02 <Gyde> this it sais that xs is a list, and readArray dosen't work on list, but on the elements in the list
02:24:36 <dmwit> It is not clear to me what you want.
02:24:43 <dmwit> What is the type of readArray?
02:25:01 <Gyde> readArray2D :: Array2D -> Index2D -> Tile
02:25:23 <dmwit> And you have [Array2D], is that correct?
02:25:30 <Gyde> yes
02:25:52 <dmwit> So what's the type of "flip readArray2D"? ;-)
02:25:58 <qweqwe> i can"t understand what is the problem ther http://hpaste.org/4486
02:26:33 <dmwit> qweqwe: Typo in the second function definition.
02:26:43 <dmwit> qweqwe: Case is significant. =)
02:27:23 <qweqwe> thanks
02:27:59 <Gyde> ahh.. so I just map (flip readArray2D (Coordinatetuble)) x
02:28:05 <dmwit> right
02:28:07 <Gyde> thx .. ;)
02:28:29 <Gyde> didn't know flip would flip the arguments in a function .. nice
02:29:08 <idnar> :t flip
02:29:10 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
02:29:35 <quicksilver> I don't really like flip, for readability
02:29:37 <quicksilver> I'd rather write
02:29:56 <quicksilver> map (\arr -> readArray2D arr coordinateTuple) x
02:30:04 <quicksilver> but it's a matter of taste
02:30:16 <Gyde> didn't know flip would flip the arguments in a function.. nice --
02:30:24 <Gyde> hmm thx for that quicksilver
02:31:00 <Gyde> so \arr tells map where the array should be placed?
02:31:04 <jsnx> dmwit: thank you
02:31:54 <Zao> Gyde: \ defines a lambda function, taking one argument named arr.
02:32:05 <Gyde> ahh yeah, dooh
02:32:25 <Zao> map f x  where  f arr = readArray2D arr coordinateTuple
02:32:43 <Zao> Same thing, but here we make a real named function.
02:33:22 <Gyde> just im not used to lambda functions yet, only seen them In theory, so didn't imidiately notice that \ was the syntax for lambda.. my fault ;)
02:36:42 <Gyde> Thx, Zao, Quicksilver and dmwit
02:40:37 <laziest> hello, I am trying to understand 'seq'. Am I right if I say that any expression of the form "seq ..." will never become a "thunk", but will immediately be converted into a head-normal form?
02:41:01 <dmwit> No.
02:41:43 <laziest> dmwit: so exactly when is an 'seq ...' expression converted to a head-normal form?
02:41:49 <dmwit> I think what's more true is that in any expression of the form "seq a b", "a" is guaranteed not to be a thunk by the time "b" is evaluated.
02:42:41 <quicksilver> when the expression "seq a b" is evaluated, it will eventually reduce b to WHNF, and that will be the value of the expression, but it will reduce a to WHNF first.
02:43:35 <laziest> What's "W" in WHNF?
02:44:02 <jsnx> laziest: whitehead?
02:44:13 <jsnx> whitehead normal formal
02:44:16 <jsnx> whitehead normal form
02:44:26 <quicksilver> weak
02:45:31 <laziest> so 'seq a b' can be stored as a thunk unless I require it's value (or atleast I am not to assume that it's not a thunk), am I right?
02:45:41 <quicksilver> absolutely
02:46:05 <laziest> Thanks quicksilver, dmwit.
02:46:08 <quicksilver> and of course it can also be part of a larger thunk
02:46:23 <laziest> quicksilver: oh, yes.
02:46:30 <quicksilver> let thunk = 3 + 4 * ( seq 5 6 )
02:46:59 <quicksilver> "weak" means you don't reduce inner lambdas
02:47:01 <quicksilver> basicall
02:47:13 <laziest> quicksilver: and one more question; what is "weak HNF" as against .... oh you answered
02:47:40 <quicksilver> \x -> ((\y -> y + 1) $ 2)
02:47:44 <quicksilver> is not in HNF
02:47:50 <quicksilver> because you can reduce the inner lambda
02:47:56 <quicksilver> btu it's in WHNF.
02:48:06 <laziest> I see!
02:48:35 <laziest> So do you mean haskell implementations store WHNF whenever possible?
02:48:52 <laziest> I mean in 'seq' context?
02:49:18 <sjanssen> does anybody else find it ironic that laziest is asking questions about seq? :P
02:49:25 <quicksilver> irrespective of seq, laziest
02:49:41 <quicksilver> WHNF is the cornerstone of the "most obvious" haskell evaluation model
02:49:53 <laziest> quicksilver: oh, without seq, ofcourse! more important was seq...
02:49:59 <laziest> sjanssen: nice one!
02:50:14 <laziest> sjanssen: make things as lazy as possible, but not lazier?
02:50:29 <quicksilver> of course in practice haskell implementations have some choice aout their evaluation strategy
02:50:34 <quicksilver> not much choice, but a little :)
02:51:07 <laziest> :)
02:51:30 <laziest> Thanks all again!
03:13:35 <MaxRabkin> I have a string containing four space-separated integers; I want to read them into a Rect, but let [a, b, c, d] = map read $ words string in Rect { left=a, top=b, right=c, bottom=d } takes forever
03:13:57 <Lemmih> Takes forever?
03:15:26 <MaxRabkin> Lemmih: to do it 10000 times
03:15:56 <Lemmih> MaxRabkin: Try Data.ByteString.
03:17:36 <quicksilver> MaxRabkin: is this compiled code? are you using -O2 ?
03:18:08 <MaxRabkin> oh, looks like I wasn't using -O2
03:18:52 <quicksilver> read/words isn't blindly fast but it shouldn't be too bad for 10000 items
03:19:29 <MaxRabkin> quicksilver: well, it isn't particularly slow (maybe 0.5 seconds), it's just 82% of my runtime
03:19:32 <quicksilver> I have some OBJ files I parse with a really naive read-based parser, some of them are 3000-6000 lines long
03:19:43 <quicksilver> and the startup delay on those isn't noticeable
03:20:03 <quicksilver> ah well, try with -O2
03:20:06 <MaxRabkin> quicksilver: this is for a contest, so I have 2 seconds to do quite significant computation
03:20:11 <quicksilver> then the next step is bytestrings
03:20:43 <quicksilver> making 'Rect' type strict is probably a good idea, too
03:20:52 <MaxRabkin> quicksilver: how?
03:21:10 <quicksilver> data Rect = Rect { !top :: Int, !left :: Int, ... }
03:21:15 <quicksilver> add "!" before the field names
03:21:27 <MaxRabkin> kk
03:21:59 <quicksilver> not going to be a massive speed increase, but it might help with your profiling. And it should be a small speed improvement.
03:22:04 <scook0> before the types, isn't it?
03:22:14 <scook0> (i.e. top :: !Int)
03:22:25 <MaxRabkin> yes, scook0
03:23:20 <quicksilver> sorry :)
03:59:41 <ugu> how do I comment multiple lines?
04:00:38 <Lemmih> ugu: {- -}
04:01:03 <ugu> Lemmih: thank you
04:06:06 <qweqwe> http://hpaste.org/4487 what the problem there ?
04:06:39 <MaxRabkin> Can I get the GHC RTS to show what proportion of thunks are evaluated?
04:06:45 <Zao> qweqwe: :: Int -> IO (Int,Int) -- shouldn't it be?
04:06:46 <Lemmih> qweqwe: Your indentation looks off.
04:06:50 <quicksilver> qweqwe: alightnment again
04:06:56 <Lemmih> qweqwe: And the types are wrong.
04:07:03 <quicksilver> qweqwe: "getnumbers" has to start in the same column as "xs <-"
04:07:22 <MaxRabkin> I have a program that might be the perfect justification of laziness to my friends
04:07:27 <Zao> I'm guessing some tab abuse.
04:07:54 <qweqwe> yep i always have tab problems
04:09:25 <qweqwe> can i somehow get from the IO ?
04:09:38 <qweqwe> IO Int make it Int
04:11:38 <Lemmih> qweqwe: The questions you ask are answered by most tutorials.
04:11:48 <qweqwe> ok i will check
04:13:08 <visof> is programming language Design difficult??
04:13:24 <Zao> Somewhat.
04:13:26 <integral> can you juggle while doing maths?
04:13:31 <mauke> only if you want to do it right
04:17:46 <Orphi> hello #haskell
04:18:09 <Orphi> anybody here know how to use the new GHC debugger?
04:18:25 <Lemmih> Orphi: Got a question about it?
04:18:28 <MaxRabkin> qweqwe: are you the anti-Haskell qwe from Reddit?
04:18:50 <mauke> I'm reading http://haskell.org/ghc/docs/latest/html/users_guide/ghci-debugger.html
04:18:57 <lambdabot> http://tinyurl.com/2zhb6v
04:19:03 <Orphi> Lemmih: how do I make it so that when an exception happens, it tells me WHERE the problem is?
04:19:44 <mauke> http://haskell.org/ghc/docs/latest/html/users_guide/ghci-debugger.html#ghci-debugger-exceptions
04:19:45 <lambdabot> http://tinyurl.com/2zhb6v
04:20:39 <Orphi> I did try single-stepping a program, but the result was incomprehensible
04:20:51 <Orphi> and besides, I'd have to step it for a very long time to reach the actual error
04:21:35 <Orphi> eventually I found the bug by hand, but the debugger is supposed to help with this...
04:21:42 <scook0> iirc, the idea is to run normally until you hit an error
04:21:47 <scook0> and then go back in time
04:21:52 <qweqwe> http://hpaste.org/4488 what is wrong with it now ? i can"t see the problem
04:21:54 <scook0> (though I've not actually used it)
04:22:16 <scook0> qweqwe: (Just (a, b))
04:22:26 <scook0> you need to parenthesise the pattern
04:22:30 <Lemmih> qweqwe: "IO Int -> (Int,Int)" doesn't make sense.
04:23:02 <Orphi> scook0: I can't figure out how to do that.
04:23:03 <Lemmih> qweqwe: It's important to understand why "Int -> IO (Int,Int)" is different.
04:23:32 <hpaste>  scook0 annotated "(no title)" with "put () around the Just pattern" at http://hpaste.org/4488#a1
04:24:04 <Zao> f :: IO Int -> (Int,Int) would be a function taking an IO action as an argument, and returning a 2-tuple of Int.
04:24:14 <Zao> It wouldn't be able to execute the action.
04:24:36 <Lemmih> qweqwe: You really need to follow a tutorial.
04:25:21 <MaxRabkin> :t f a::(IO Int) = (1, 1)
04:25:22 <lambdabot> parse error on input `='
04:25:46 <mauke> :t \a -> const (1, 1) (a :: IO Int)
04:25:47 <lambdabot> forall t t1. (Num t, Num t1) => IO Int -> (t, t1)
04:26:01 <MaxRabkin> :t let {f :: IO Int -> (Int,Int); f _ = (1, 1)} in f
04:26:01 <lambdabot> IO Int -> (Int, Int)
04:26:43 <MaxRabkin> you *can* create functions with that type, but they're constant functions
04:27:07 <Zao> MaxRabkin: Unless you're insane and use unsafePerformIO :P
04:27:50 <MaxRabkin> Zao: don't feed the newbies. unsafePerformIO does not exist.
04:27:55 <MaxRabkin> :P
04:28:23 <jre2> the hOpenGl displayCallback takes a function of type IO(). how could I use a function of type MM() instead (where type MM = StateT MMGame IO)?
04:29:00 <desegnis> jre2: If you use StateT, you need runStateT.
04:29:52 <scook0> I'm not sure that will have the desired effect
04:31:09 <desegnis> If MM manages some global/per-game state: indeed, it may not work out.
04:33:40 <jre2> essentially I'm trying to give the opengl displayCallback a function that pulls a display function (based on global state) and runs that. so it usings 1 function for the title screen, another for credits, another for the actual game, etc
04:34:23 <jre2> shu-thing accomplishes this by giving displayCallback a closure with an IORef to the function, but I'm trying to get something more elegant
04:55:45 <Gyde> just had a powershortage in the basement, internet offline. don't know if anybody saw my last message.. so here I go again
04:56:34 <Gyde> im trying to make lists from a list like this: [1,2,3] -> [2,3] [1,3] [1,2]
04:56:57 <Gyde> I was thinking about using map and fliter with the /= option, but I can't seem to put it right
04:58:12 <syntaxfree> [a]->([a],[a],[a])  or [a]->[[a]]?
04:58:48 <Gyde> last one
04:58:53 <syntaxfree> @let test x = "A Constant"
04:58:55 <lambdabot> Defined.
04:58:59 <syntaxfree> > L.x
04:58:59 <lambdabot>   Not in scope: `L.x'
04:59:05 <mauke> > L.test
04:59:05 <lambdabot>  Add a type signature
04:59:14 <syntaxfree> > L.test 2
04:59:15 <lambdabot>  "A Constant"
04:59:18 <syntaxfree> ok.
04:59:42 <Gyde> was that for me?
05:00:31 <desegnis> Gyde, do you have more examples of your function?
05:00:36 <MaxRabkin> Gyde: what exactly do you want? all sublists of length two?
05:00:46 <syntaxfree> Gyde: let's see again, you want all the sublists of length two?
05:00:54 <syntaxfree> GMTA.
05:01:21 <Gyde> no, if I have a list I want like when it map it to make all the list with the mapped item removed
05:01:51 <syntaxfree> > let heh = do { x<-[1,2,3]; y<-[1,2,3]; return (x,y)} in filter (\(a,b)->a/=b) heh
05:01:52 <lambdabot>  [(1,2),(1,3),(2,1),(2,3),(3,1),(3,2)]
05:02:46 <mauke> hah
05:02:47 <MaxRabkin> syntaxfree: that gives all pairs of non-equal items... I don't think that's what Gyde wants
05:02:55 <syntaxfree> Gyde: start writing a "remove" function.
05:03:02 <Gyde> [1,2,3,4] -> [2,3,4] [1,3,4] [1,2,4],[1,2,3]
05:03:05 <syntaxfree> if later you find out Haskell has the facility you want, then you substitute it.
05:03:23 <syntaxfree> work bottom up, man. don't expect the language to have all the lego pieces.
05:03:42 <desegnis> > let f [] = []; f (x:xs) = xs : map (x:) (f xs) in f [1,2,3]  -- primitive recursive method
05:03:44 <lambdabot>  [[2,3],[1,3],[1,2]]
05:03:55 <mauke> Gyde: you could use http://mauke.ath.cx/stuff/haskell/Permu.hs
05:04:02 <mauke> then your function is just execPermu draw
05:04:43 <syntaxfree> desegnis: whoa.
05:05:08 <Gyde> I mean, if I do like this "filter (/=1) [1,2,3]" then I get "[2,3]"
05:05:18 <syntaxfree> remove needle hay = filter (/= needle) hay
05:05:23 <mauke> you don't want filter
05:05:24 <desegnis> Gyde, this raises one question:
05:05:40 <mauke> it'll break if your list elements can't be compared or if there are repetitions
05:05:48 <desegnis> if you filter 1 out of [1,2,3,1,1,2], you get [2,3,2]
05:06:04 <Gyde> your right..
05:06:16 * syntaxfree feels dumb.
05:06:20 <hpaste>  dmhouse pasted "Natural sort algorithm -- anyone shorten this?" at http://hpaste.org/4489
05:06:55 <desegnis> Gyde, furthermore filtering would have the disadvantage that it traverses the whole list for the computation of each of the result lists.
05:06:57 <syntaxfree> starting from lists is weird since the semantics seem to suppose sets.
05:07:01 <dmhouse> Hey guys. Anyone come up with a shorter natural sort algorithm than that?
05:07:10 <syntaxfree> I think I'd nub at the beginning of the whole process.
05:07:32 <Toxaris> syntaxfree: why does the semantics suppose sets?
05:07:36 <opqdonut> dmhouse: why not use digitToInt?
05:07:42 <Toxaris> syntaxfree: not that I know the semantics...
05:07:49 <desegnis> syntaxfree: Never nub if there may be the option that you don't need to ;)
05:07:52 <opqdonut> ah nvm, you're taking the whole number at once
05:08:01 <syntaxfree> because repetated elements == breakage.
05:08:13 <Toxaris> but foo [1, 1, 1] -> [[1, 1], [1, 1], [1, 1]] seems to be reasonable to me
05:08:14 <syntaxfree> desegnis: actually, I think I'd use Data.Set from the outSet.
05:08:19 <syntaxfree> * rimshot *
05:08:29 <Toxaris> (depends on what desegnis wants of course)
05:08:50 <desegnis> Toxaris, s/desegnis/Gyde, I suppose
05:09:10 <Toxaris> aehm yes may be who ever it is who wants something
05:09:24 <Toxaris> desegnis: sorry :)
05:09:35 <desegnis> heh
05:09:40 <syntaxfree> specification from example is a brain bug.
05:09:49 <syntaxfree> we're evolved to overinduce.
05:10:09 <Toxaris> <Gyde> no, if I have a list I want like when it map it to make all the list with the mapped item removed
05:10:10 <syntaxfree> and what's worse, now we're trying to get computers to do the same!
05:10:34 <syntaxfree> Toxaris: maybe it's my nonnative english, but I can't even parse that sentence.
05:10:54 <syntaxfree> Toxaris: it's still example-based, not a specification.
05:11:07 <Gyde> ehh, ? I might be better of explaining me a bit more: I have a function with uses map to use every object in a list in a puzzle, I need to make a list for each puzzle containing all the tiles except the one used
05:11:16 <syntaxfree> being a simple list problem, implementation would probably derive naturally from specification.
05:11:38 <Gyde> in several puzzles (One tile per puzzel to make all combinations)
05:11:42 <syntaxfree> Gyde: start from the bottom up.
05:11:57 <desegnis> The only single bug in the specification is Gyde's use of “map”, where we think of Prelude.map (which isn't really suitable here)
05:12:11 <syntaxfree> write a function that makes the tile, then one that makes the list., If you can later simplify/refactor, that's cool.
05:12:35 <desegnis> Gyde, I think my f above matches your problem.
05:13:18 <syntaxfree> if you are like Djisktra, you can write your entire program at once, perfectly. If you are like syntaxfree, you first work on the small problems and get things working and gradually make them elegant and efficient.
05:13:28 <sebas_> hello guys. A haskell newbie here. I have got a question about the Show class that you might be able to answer. Why does the String instance of the Show class surround the result with quotes?
05:13:40 <syntaxfree> whether you are like Djikstra or like syntaxfree, I cannot comment.
05:13:50 <dmhouse> sebas_: Show is used for serialisation.
05:14:01 <Gyde> think I will look some more at it, then I might have a more precise question ;)
05:14:07 <dmhouse> sebas_: the output of Show should be machine parseable.
05:14:17 <sebas_> Only serialization, not for pretty printing?
05:14:17 <syntaxfree> dmhouse: I was about to answer "because it was so written!"
05:14:33 <desegnis> sebas_, because people like seeing quites around strings. “show” is for a visual representation of your data, suitable for the programmer inspecting the result of a program.
05:14:40 <syntaxfree> dmhouse: there's an entire philosophical discussion to be had here on the difference between "final cause" and "material cause".
05:14:47 <dmhouse> sebas_: well, it works fairly well for pretty printing, but that's not what it's designed for, AFAIR.
05:15:32 <sebas_> I am trying to show my polymorphic HTTP_Message data-type which is parametrized with a body type.
05:15:51 <syntaxfree> whose stuff is this Permu.hs?
05:15:55 <desegnis> syntaxfree: It's more about the difference between causa finalis and causa formalis, isn't it?
05:16:19 <syntaxfree> I'm kinda looking for something to work on to get my skills back to shape again. I haven't wrote a line of code in more than a year now.
05:16:45 <mauke> syntaxfree: mine
05:17:47 <syntaxfree> mauke: how open-to-review is it?
05:17:55 <syntaxfree> mauke: more importantly, how perfect is it? :)
05:17:57 <mauke> huh?
05:18:00 <Gyde> (map (\arr -> filter \=arr) xs) <- can't I do something like this?
05:18:37 <mauke> > (\xs -> map (\arr -> filter (/= arr) xs) xs) [1,2,1]
05:18:38 <lambdabot>  [[2],[1,1],[2]]
05:18:39 <chessguy> @type map (\arr -> filter \=arr) ?xs
05:18:40 <syntaxfree> oh. it's really short.
05:18:40 <lambdabot> Not in scope: `\='
05:18:47 <Zao> :t (/=)
05:18:48 <lambdabot> forall a. (Eq a) => a -> a -> Bool
05:19:03 <chessguy> @type map (\arr -> filter /=arr) ?xs
05:19:04 <lambdabot>     No instance for (Eq ((a -> Bool) -> [a] -> [a]))
05:19:04 <lambdabot>       arising from use of `/=' at <interactive>:1:13-24
05:19:04 <lambdabot>     Possible fix:
05:19:27 <desegnis> Gyde, that addresses the issues about equality testing, multiple occurences of the same element, and about filtering. It depends on what you want.
05:20:28 <Gyde> yes, I know, im just interrested if I can do like that, I know im not really able to use it if I have multible equal objects ;)
05:20:39 <mauke> > execPermu draw [1,2,1]
05:20:39 <lambdabot>  [[2,1],[1,1],[1,2]]
05:21:07 <Toxaris> > let oneOf [] = []; oneOf (x:xs) = (x, xs) : ((<$>). (<$>)) (x :) (oneOf xs) in oneOf "abcd" -- I would use this one. it's a stingy monster eating the recursive call
05:21:08 <lambdabot>  [('a',"bcd"),('b',"acd"),('c',"abd"),('d',"abc")]
05:22:37 <chessguy> nice one Toxaris
05:23:06 <chessguy> though i have no idea how it works
05:23:13 <mauke> > evalPermu (do x <- draw; y <- draw; return (x,y)) [1 .. 10]
05:23:14 <lambdabot>  [(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(2,1),(2,3),(2,4),(2...
05:23:24 <syntaxfree> this channel is  HORRIBLE for my self-esteem.
05:23:43 <roconnor> @yow
05:23:43 <lambdabot> Did YOU find a DIGITAL WATCH in YOUR box of VELVEETA?
05:23:51 <Toxaris> chessguy: shall I explain?
05:24:14 <chessguy> syntaxfree, so go somewhere else, you loser
05:24:29 <chessguy> Toxaris, that's ok, my brain's not really awake yet anyway
05:24:52 <mauke> > join (liftM evalPermu (mapM (return draw))) "abc"
05:24:52 <lambdabot>  ["abc","acb","bac","bca","cab","cba"]
05:25:25 <chessguy> @type liftM . liftM
05:25:26 <lambdabot> forall (m :: * -> *) a1 r (m1 :: * -> *). (Monad m, Monad m1) => (a1 -> r) -> m (m1 a1) -> m (m1 r)
05:25:29 <roconnor> Toxaris: I've written that function a few times.  I ought to be in the standard libs.
05:26:01 <hashendgame> yes, let's put roconnor in the standard libs. Util.Roconnor?
05:26:12 <chessguy> haha
05:26:17 <roconnor> oops
05:26:17 <mauke> > runPermu draw "abcd"
05:26:18 <lambdabot>  [('a',"bcd"),('b',"acd"),('c',"abd"),('d',"abc")]
05:26:19 <roconnor> *L*
05:26:27 <syntaxfree> @remember 	<hashendgame>	yes, let's put roconnor in the standard libs. Util.Roconnor?
05:26:27 <roconnor> It ought ...
05:26:27 <lambdabot> I will remember.
05:26:43 <chessguy> hashendgame, you a chess programmer?
05:26:44 <tetha> we could create a distributed util-part of the standardlib. everyone can create his Util.name there, and then, we will have some ultimate bloat. :)
05:26:48 <desegnis> > let xs = [1,2,3] in map (\x -> filter (/=x) xs) xs  -- If you *insist* on map and filter.
05:26:48 <lambdabot>  [[2,3],[1,3],[1,2]]
05:27:45 <hashendgame> chessguy: afraid not, why? Your nick suggests that you are, am I right?
05:28:18 <chessguy> hashendgame, indeed. and yours suggested to me that you are, but i guess i was wrong
05:28:28 <chessguy> hash tables are commonly used in chess engines
05:28:50 <hashendgame> chessguy: ex-zzt programmer. #endgame was a command in zzt's built in programming language.
05:29:10 <tetha> haha, zzt. good old days
05:29:36 <chessguy> hm, zzt was that 2d text-based action game?
05:29:41 <hashendgame> yep
05:29:44 <tetha> yes
05:29:51 <chessguy> wow, that's going back a few years :)
05:29:58 <hashendgame> I remember being a bit too fond of #throwstar seek
05:30:30 <Toxaris> > let oneOf [] = empty; oneOf (x:xs) = Control.Applicative.pure (x, xs) <|> ((<$>) . (<$>)) (x :) (oneOf xs) in oneOf "abc" :: [(Char, [Char])] -- you never know what functor you're in
05:30:32 <lambdabot> Terminated
05:30:43 <Toxaris> :(
05:30:54 <tetha> stars are evil
05:30:57 <Toxaris> :t (<|>)
05:30:58 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f a -> f a
05:30:59 <syntaxfree> i need to get a shirt made
05:30:59 <chessguy> we need a zzt clone in haskell :)
05:31:23 <syntaxfree> "you never know what functor you're in"
05:32:05 <Toxaris> whats wrong with my code? it works perfectly at home :(
05:32:33 <Toxaris> :t let oneOf [] = empty; oneOf (x:xs) = Control.Applicative.pure (x, xs) <|> ((<$>) . (<$>)) (x :) (oneOf xs) in oneOf
05:32:33 <lambdabot>     Ambiguous occurrence `empty'
05:32:33 <lambdabot>     It could refer to either `empty', imported from Control.Applicative
05:32:33 <lambdabot>                           or `empty', imported from Text.PrettyPrint.HughesPJ
05:32:52 <Toxaris> lamdabot has PrettyPrinting in scope? cool!
05:33:34 <Toxaris> > let oneOf [] = Control.Applicative.empty; oneOf (x:xs) = Control.Applicative.pure (x, xs) <|> ((<$>) . (<$>)) (x :) (oneOf xs) in oneOf "abc" :: [(Char, [Char])] -- you never know what's in scope either
05:33:35 <lambdabot>  [('a',"bc"),('b',"ac"),('c',"ab")]
05:34:07 <hashendgame> zzt in haskell would be nuts
05:34:10 <dmhouse> :t (<$>)
05:34:10 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:34:31 <dmhouse> :t (<|>)
05:34:32 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f a -> f a
05:35:00 <mauke> > "foo" <|> "bar"
05:35:00 <lambdabot>  "foobar"
05:35:14 <chessguy> hashendgame, why's that
05:35:22 <dmhouse> ?unpl (fmap . fmap)
05:35:22 <lambdabot> (\ c -> fmap (fmap c))
05:35:53 <mauke> map . second
05:36:10 <chessguy> @type map . second
05:36:10 <lambdabot> forall b c d. (b -> c) -> [(d, b)] -> [(d, c)]
05:36:48 <mauke> :t ((<$>) . (<$>)) `asTypeOf` (map . second)
05:36:49 <lambdabot> forall b c d. (b -> c) -> [(d, b)] -> [(d, c)]
05:36:51 <hashendgame> chessguy: it'd be neat but I wouldn't know where to begin
05:37:16 <hashendgame> I'm still trying to get from the "hey that's cool"-type demonstrations to building real programs in haskell
05:37:45 <mauke> > runPermu draw [1 ..]
05:37:48 <lambdabot> Terminated
05:38:13 <Toxaris> > map fst $ runPermu draw [1..]
05:38:15 <lambdabot> Terminated
05:38:20 <mauke> it's not lazy
05:38:25 <chessguy> hashendgame, that's about where i'm at
05:38:27 <dmhouse> > let oneOf [] = []; oneOf (x:xs) = (x, xs) : map (fmap (x:)) (oneOf xs) in oneOf "abc"
05:38:27 <lambdabot>  [('a',"bc"),('b',"ac"),('c',"ab")]
05:38:47 <dmhouse> > fmap (+1) (1, 2)
05:38:48 <Toxaris> mauke: why not?
05:38:48 <lambdabot>  (1,3)
05:38:51 <dmhouse> Ah.
05:39:10 <dmhouse> > let oneOf [] = []; oneOf (x:xs) = (x, xs) : map (second (x:)) (oneOf xs) in oneOf "abc"
05:39:11 <lambdabot>  [('a',"bc"),('b',"ac"),('c',"ab")]
05:39:23 <desegnis> Ah, it was Control.Monad.Instances again!
05:39:27 <mauke> Toxaris: it identifies each list element by its position, using a map
05:39:48 <mauke> infinite maps don't work
05:40:28 <Toxaris> mauke: oh ok and this is needed for more complex operations then runPermu draw I assume?
05:40:32 <chessguy> hashendgame, i'd offer to partner with you to take it on, but that wouldn't be very wise with a wedding and a move coming up :)
05:41:00 <mauke> Toxaris: it simplifies the implementation of draw IIRC
05:41:00 <hashendgame> chessguy: it wouldn't be wise with exams and an intercontinental move coming up on my end either :)
05:41:03 <dmhouse> > (zip [1..] $ cycle "ab") !! 4 -- they work fine.
05:41:04 <lambdabot>  (5,'a')
05:41:29 <dmhouse> (But I presume you're talking about Data.Map.)
05:41:30 <chessguy> real life just sucks, doesn't it? :)
05:41:52 <Toxaris> dmhouse: yes that's the same as my first version. my second version abstracts the outermost list to any Control.Applicative.Alternative
05:42:09 <syntaxfree> what _is_ Control.Applicative?
05:42:20 <dmhouse> Applicative functors, a generalisation of monads.
05:42:22 <Toxaris> syntaxfree: you know Functor and Monad?
05:42:27 <mauke> syntaxfree: something between Functor and Monad
05:42:34 <syntaxfree> sure. and Arrows.
05:42:35 <dmhouse> They sit between monads and arrows in general-ness.
05:42:40 <Toxaris> syntaxfree: Applicative is something in between Functor and Monad
05:42:44 <byorgey> :type (<*>)
05:42:54 <Toxaris> syntaxfree: and Alternative is to Applicative what MonadPlus is to Monad
05:42:57 <byorgey> :t (<*>)
05:42:59 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
05:43:05 <syntaxfree> hmm.
05:43:06 <mauke> basically, instead of return and (>>=) you get return and ap
05:43:10 <dmhouse> class Functor f => Applicative f where
05:43:10 <dmhouse> pure :: a -> f a
05:43:10 <dmhouse> (<*>) :: f (a -> b) -> f a -> f b
05:43:26 <MaxRabkin> I've got 200/300 in the SACO using haskell... my programs are too slow
05:43:53 <mauke> :t (<*>) . Control.Applicative.pure
05:43:53 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => (a -> b) -> f a -> f b
05:44:23 <scook0> the Control.Applicative docs link to a paper that has some more details
05:46:46 * syntaxfree is resisting the urge to go into major offtopicness.
05:47:43 <dmhouse> Hmm, could oneOf be defined using Traversable as well? I.e. oneOf :: Traversable t => t a -> t (a, t a)
05:48:07 <hashendgame> I'm looking to get some global mutable state shared across multiple threads, but I'm not really sure where to start
05:48:38 <ricky_clarkson> @where awkward squad
05:48:38 <lambdabot> I know nothing about awkward.
05:48:42 <Toxaris> dmhouse: I don't think so. You can't "delete" an element out of an traversable
05:48:51 <ricky_clarkson> hashendgame: Rad the Awkward Squad, by SPJ.
05:48:55 <ricky_clarkson> read, even.
05:49:07 <hashendgame> ricky_clarkson: thanks, I'll go look it up
05:49:16 <Gyde> I made a listmaker fuction doing this -> xs a = (take (a-1) xs) ++ (drop (a) xs) that works ;) thx for those pointing me in the right direction
05:49:16 <ricky_clarkson> Then decipher it for me. ;)
05:49:44 <scook0> hashendgame: you may want to read about STM as well
05:49:47 <Toxaris> dmhouse: but I've never used them so I maybe wrong
05:49:50 <scook0> if you're doing multithreaded state
05:49:57 <dmhouse> ?src delete
05:49:57 <lambdabot> delete = deleteBy (==)
05:50:02 <dmhouse> > src deleteBy
05:50:03 <lambdabot>   Not in scope: `src'
05:50:08 <dmhouse> ?src deleteBy
05:50:08 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
05:50:49 <oerjan> deleteBy _  _ []        = []
05:50:49 <oerjan> deleteBy eq x (y:ys)    = if x `eq` y then ys else y : deleteBy eq x ys
05:51:00 <oerjan> strange omission
05:51:40 <dmhouse> > foldr (\x xs -> if x == 5 then xs else x:xs) [] [1..10]
05:51:41 <lambdabot>  [1,2,3,4,6,7,8,9,10]
05:51:54 <dmhouse> delete is a fold, and Traversable is a subclass of Foldable, so shouldn't it work?
05:52:21 <oerjan> dmhouse: you cannot fold the result into a Traversable
05:53:05 <Toxaris> oerjan: you cannot change the structure of Foldables or Traversables, only their contents
05:53:19 <Toxaris> oh sorry, was for dmhouse not oerjan ...
05:53:27 * Toxaris looks around and wonders who's who
05:53:39 <oerjan> a Traversable might not even _have_ a single element deletion .. e.g. that tree variant which can only have an odd number of values...
05:53:56 <dmhouse> Right, because if we tried to generalise that we'd run in to trouble because of the call to (:).
05:54:45 <oerjan> data Tree a = Leaf a | Tree (Tree a) a (Tree a)
05:55:16 <oerjan> (someone mentioned it the other day)
05:56:12 <Toxaris> dmouse: you want "1" < "a" for your natcomp?
05:56:26 <dmhouse> Toxaris: yep.
05:57:30 <dmhouse>   convert = lambda text: int(text) if text.isdigit() else text
05:57:31 <dmhouse>   alphanum_key = lambda key: [ convert(c) for c in re.split('([0-9]+)', key) ]
05:57:31 <dmhouse>   l.sort( key=alphanum_key )
05:57:48 <dmhouse> That was the Python version, which is only three lines, but it uses some funky dynamic typing by the looks of things.
05:58:13 <Toxaris> dmhouse: Haskell can do it in one line, I'm just not sure wich :)
05:59:31 <oerjan> > Left 10 < Right "a"
05:59:32 <lambdabot>  True
06:00:40 <Toxaris> oerjan: that's the way I'm going too
06:00:57 <byorgey> > digitToInt "a"
06:00:57 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
06:01:02 <Toxaris> oerjan: my prob is how to know wether the string begins with a digit or a alphanum
06:01:02 <byorgey> > digitToInt 'a'
06:01:02 <lambdabot>  10
06:01:45 <oerjan> is "12".isdigit() true?
06:01:51 <Botje> @hoogle Char -> Bool
06:01:52 <lambdabot> Data.Char.isControl :: Char -> Bool
06:01:52 <lambdabot> Data.Char.isSpace :: Char -> Bool
06:01:52 <lambdabot> Data.Char.isLower :: Char -> Bool
06:01:53 <dmhouse> oerjan: must be, I guess.
06:02:06 <Botje> > isDigit 'a'
06:02:07 <lambdabot>  False
06:02:13 <Botje> > isAlpha 'a'
06:02:13 <lambdabot>  True
06:02:20 <desegnis> Now, if digitToInt was of type Char -> Maybe Integer...
06:02:21 <Botje> does that help? :)
06:02:32 <desegnis> (or rather, Char -> Maybe Int)
06:02:44 <Orphi> OK, I'm back.
06:02:56 <hpaste>  Orphi pasted "Test program" at http://hpaste.org/4490
06:03:19 <Orphi> when I do "foo 20", I get an exception.
06:03:29 <Orphi> how do I make GHC tell me which line is causing the error?
06:03:48 <Heffalump> Orphi: try using ghci's debugger
06:04:01 <Orphi> yes... that's what I want to know how to do ;)
06:04:38 <Heffalump> ghci -fbreak-on-exception
06:04:42 <Heffalump> :trace foo 20
06:05:41 <oerjan> > sortBy (compare `on` map (\k -> case reads k of (n,"") -> Left n; _ -> Right k) . groupBy ((==) `on` isDigit)) $ "test 123 4")
06:05:41 <lambdabot> Unbalanced parentheses
06:06:01 <dmhouse> ?hoogle comparing
06:06:01 <lambdabot> Data.Ord.comparing :: Ord a => (b -> a) -> b -> b -> Ordering
06:06:13 <oerjan> > sortBy (compare `on` map (\k -> case reads k of (n,"") -> Left n; _ -> Right k) . groupBy ((==) `on` isDigit)) $ "test 123 4"
06:06:14 <lambdabot>   Not in scope: `on'
06:06:16 <dmhouse> ?hoogle equating
06:06:16 <Orphi> ah-HAH. so I need that switch to turn on the behaviour I want...
06:06:17 <lambdabot> No matches found
06:06:23 <Orphi> that's better.
06:06:28 <oerjan> @let on (*) f x y = f x * f y
06:06:30 <lambdabot> Defined.
06:06:32 <oerjan> > sortBy (compare `on` map (\k -> case reads k of (n,"") -> Left n; _ -> Right k) . groupBy ((==) `on` isDigit)) $ "test 123 4"
06:06:32 <lambdabot>      precedence parsing error
06:06:32 <lambdabot>         cannot mix `on' [infixl 9] and `(.)' [i...
06:06:58 <oerjan> :t (0$0 `on`)
06:06:59 <lambdabot>     The operator `on' [infixl 9] of a section
06:06:59 <lambdabot>         must have lower precedence than the operand `($)' [infixr 0]
06:06:59 <lambdabot>         in the section: `((0 $ 0) `on`)'
06:07:17 <oerjan> :t (0$0 `Data.Function.on`)
06:07:17 <lambdabot> Couldn't find qualified module.
06:07:30 <oerjan> #%&/!
06:07:53 <oerjan> > sortBy (compare `on` (map (\k -> case reads k of (n,"") -> Left n; _ -> Right k) . groupBy ((==) `on` isDigit))) $ "test 123 4"
06:07:54 <lambdabot>  Couldn't match expected type `[(a, String)]'
06:08:15 <oerjan> > sortBy (compare `on` (map (\k -> case reads k of [(n,"")] -> Left (n::Integer); _ -> Right k) . groupBy ((==) `on` isDigit))) $ "test 123 4"
06:08:16 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
06:08:40 <dmhouse> > groupBy ((==) `on` isDigit) "test 123 4"
06:08:41 <lambdabot>  ["test ","123"," ","4"]
06:09:57 <Saizan_>  > sortBy (compare `on` (map (\k -> case reads k of [(n,"")] -> Left (n::Integer); _ -> Right k) . groupBy ((==) `on` isDigit))) $ "test
06:10:41 <oerjan> > sortBy (compare `on` (map (\k -> case reads k of [(n,"")] -> Left (n::Integer); _ -> Right k)) . groupBy ((==) `on` isDigit)) $ "test 123 4"
06:10:42 <lambdabot>      precedence parsing error
06:10:42 <lambdabot>         cannot mix `on' [infixl 9] and `(.)' [i...
06:11:07 <oerjan> > sortBy (compare `on` (map (\k -> case reads k of [(n,"")] -> Left (n::Integer); _ -> Right k))) . groupBy ((==) `on` isDigit) $ "test 123 4"
06:11:08 <lambdabot>  Couldn't match expected type `String' against inferred type `Char'
06:11:11 <dmhouse> > sort . map (\chunk -> case reads chunk of [(n, "")] -> Left (n::Integer); _ -> Right chunk) . groupBy ((==) `on` isDigit) $ "test 123 4"
06:11:11 <lambdabot>  [Left 4,Left 123,Right " ",Right "test "]
06:11:20 <Saizan_> > sortBy (compare `on` (\k -> case reads k of [(n,"")] -> Left (n::Integer); _ -> Right k)) . groupBy ((==) `on` isDigit) $ "test 123 4"
06:11:21 <lambdabot>  ["4","123"," ","test "]
06:11:51 <Saizan_> oerjan: you were grouping inside the comparison function
06:11:51 <dmhouse> > map (either show id) . sort . map (\chunk -> case reads chunk of [(n, "")] -> Left (n::Integer); _ -> Right chunk) . words $ "test 123 4"
06:11:52 <lambdabot>  ["4","123","test"]
06:12:12 <dmhouse> (Or with groupBy if you prefer.)
06:12:20 <oerjan> grouping, mapping, everything possible in the wrong place
06:12:35 <dmhouse> > map (either show id) . sort . map (\chunk -> case reads chunk of [(n, "")] -> Left (n::Integer); _ -> Right chunk) $ ["test2", "test100"]
06:12:36 <lambdabot>  ["test100","test2"]
06:12:44 <dmhouse> So that's not correct.
06:13:38 <dmhouse> Err, hang on
06:14:01 <Toxaris> > map (either show id) . sort . map (\chunk -> case reads chunk of [(n, "")] -> Left (n::Integer); _ -> Right chunk) $ ["test100", "test2", "test100x"]
06:14:03 <lambdabot>  ["test100","test100x","test2"]
06:14:05 <oerjan> that either show id will fail for things with leading zeros
06:14:09 <Saizan_> is thre a statement of the problem?
06:14:19 <dmhouse> oerjan: yeah, so does my original one.
06:14:26 <Toxaris> Saizan_: http://hpaste.org/4489
06:14:29 <oerjan> > reads "007" :: [(Integer,String)]
06:14:30 <lambdabot>  [(7,"")]
06:14:58 <oerjan> > reads "-007" :: [(Integer,String)]
06:14:59 <lambdabot>  [(-7,"")]
06:15:13 <oerjan> and all will fail with minus...
06:15:22 <oerjan> er no
06:16:17 <dmhouse> We're aiming for a function String -> String -> Ordering or [String] -> [String] anyway, so this isn't really in the right direction.
06:17:31 <oerjan> oh right... the splitting _should_ be in the comparing
06:17:42 <oerjan> looking back at the python
06:20:35 <oerjan> > map (\chunk -> case reads chunk of [(n, "")] -> Left (n::Integer); _ -> Right chunk) . groupBy ((==) `on` isDigit) $ "test 123 4"
06:20:35 <lambdabot>  [Right "test ",Left 123,Right " ",Left 4]
06:20:37 <dmhouse> > let prep = map (\chunk -> case reads chunk of [(n, "")] -> Left (n::Integer); _ -> Right chunk) . groupBy ((==) `on` isDigit) in sortBy (\xs ys -> mconcat $ zipWith compare (prep xs) (prep ys)) ["test2", "test100"]
06:20:37 <lambdabot>  ["test2","test100"]
06:21:31 <oerjan> > sortBy (compare `on` (map (\chunk -> case reads chunk of [(n, "")] -> Left (n::Integer); _ -> Right chunk) . groupBy ((==) `on` isDigit) $ "test 123 4"))) $ ["test2", "test100"]
06:21:32 <lambdabot> Unbalanced parentheses
06:21:56 <oerjan> > sortBy (compare `on` (map (\chunk -> case reads chunk of [(n, "")] -> Left (n::Integer); _ -> Right chunk) . groupBy ((==) `on` isDigit) $ "test 123 4")) $ ["test2", "test100"]
06:21:56 <lambdabot>  Couldn't match expected type `a -> t1'
06:22:17 <dmhouse> oerjan: use /msg
06:23:02 <oerjan> oh this isn't worth it
06:24:46 <dmhouse> > let prep = map (\chunk -> case reads chunk of [(n, "")] -> Left (n::Integer); _ -> Right chunk) . groupBy ((==) `on` isDigit) in sortBy (\xs ys -> mconcat $ zipWith compare (prep xs) (prep ys)) ["test100", "test1", "test2", "test20", "test10"]
06:24:47 <lambdabot>  ["test1","test2","test10","test20","test100"]
06:25:57 <dmhouse> > let prep = map (\chunk -> case reads chunk of [(n, "")] -> Left (n::Integer); _ -> Right chunk) . groupBy ((==) `on` isDigit) in sortBy (\xs ys -> mconcat $ zipWith compare (prep xs) (prep ys)) ["x2-g8", "x2-y7", "x2-y08", "x8-y8"]
06:25:59 <lambdabot>  ["x2-g8","x2-y7","x2-y08","x8-y8"]
06:26:10 <dmhouse> Cool, that looks like it works.
06:26:25 <opqdonut> prove it!
06:26:47 <oerjan> @check \xs ys -> length xs == length ys ==> (mconcat $ zipWith compare xs ys) == compare (xs::[Int]) (ys::[Int])
06:26:50 <lambdabot>  Arguments exhausted after 139 tests.
06:27:29 <oerjan> and i think you want direct compare when the lengths are unequal too?
06:28:19 <oerjan> > let prep = map (\chunk -> case reads chunk of [(n, "")] -> Left (n::Integer); _ -> Right chunk) . groupBy ((==) `on` isDigit) in sortBy (compare `on` prep) ["x2-g8", "x2-y7", "x2-y08", "x8-y8"]
06:28:20 <lambdabot>  ["x2-g8","x2-y7","x2-y08","x8-y8"]
06:28:48 <dmhouse> (By the way, (compare `on`) = comparing.)
06:29:14 <vininim> @type on
06:29:20 <lambdabot> Not in scope: `on'
06:29:40 <dmhouse> > let prep = map (\chunk -> case reads chunk of [(n, "")] -> Left (n::Integer); _ -> Right chunk) . groupBy ((==) `on` isDigit) in sortBy (\xs ys -> mconcat $ zipWith compare (prep xs) (prep ys)) ["a", "a0", "a1", "a1a", "a1b", "a2", "a10", "a20"]
06:29:42 <lambdabot>  ["a","a0","a1","a1a","a1b","a2","a10","a20"]
06:29:44 <opqdonut> :t Data.Funcion.on
06:29:44 <lambdabot> Couldn't find qualified module.
06:29:47 <oerjan> vininim: not builtin in lambdabot's version of ghc
06:29:49 <opqdonut> :t Data.Function.on
06:29:50 <lambdabot> Couldn't find qualified module.
06:29:55 <opqdonut> ah
06:30:03 <dmhouse> > let prep = map (\chunk -> case reads chunk of [(n, "")] -> Left (n::Integer); _ -> Right chunk) . groupBy ((==) `on` isDigit) in sortBy (comparing prep) ["a", "a0", "a1", "a1a", "a1b", "a2", "a10", "a20"]
06:30:10 <lambdabot>  ["a","a0","a1","a1a","a1b","a2","a10","a20"]
06:30:13 <benny99> > let test = do x <- [1..20] return (x*x)
06:30:14 <lambdabot>  Parse error at end of input
06:30:19 <dmhouse> Looks good.
06:33:04 --- mode: irc.freenode.net set +o Igloo
06:33:05 --- mode: irc.freenode.net set +o ChanServ
06:33:19 <Toxaris> let natComp = comparing $ (head . (\x -> Left . fst <$> (reads x :: [(Integer, String)]) <|> Right <$> x) <$>) .  groupBy ((&&) `on` isDigit) in sortBy natComp ["test100", "test1", "test2", "test20", "test10"]
06:33:20 <Toxaris> > let natComp = comparing $ (head . (\x -> Left . fst <$> (reads x :: [(Integer, String)]) <|> Right <$> x) <$>) .  groupBy ((&&) `on` isDigit) in sortBy natComp ["test100", "test1", "test2", "test20", "test10"]
06:33:20 <lambdabot>  ["test1","test2","test10","test20","test100"]
06:33:20 <oerjan> @check \xs ys -> (mconcat $ zipWith compare xs ys) == compare (xs::[Int]) (ys::[Int])
06:33:20 <lambdabot>  Falsifiable, after 5 tests: [3,3,-3], [3]
06:34:10 <oerjan> @check \xs ys -> (or $ zipWith (/=) xs ys) ==> (mconcat $ zipWith compare xs ys) == compare (xs::[Int]) (ys::[Int])
06:34:14 <lambdabot>  OK, passed 500 tests.
06:37:17 <oerjan> @check \xs ys -> (or $ zipWith (/=) xs ys) == (EQ /= (mconcat $ zipWith compare (xs::[Int]) (ys::[Int]))
06:37:18 <lambdabot> Unbalanced parentheses
06:37:19 <benny99> > let bla = [1..20] >>= (\x -> return (x*x))
06:37:19 <lambdabot>  Parse error at end of input
06:37:26 <oerjan> @check \xs ys -> (or $ zipWith (/=) xs ys) == (EQ /= (mconcat $ zipWith compare (xs::[Int]) (ys::[Int])))
06:37:39 <lambdabot>  OK, passed 500 tests.
06:38:22 <benny99> > let bla = [1..20] >>= (\x -> return (x * x))
06:38:22 <lambdabot>  Parse error at end of input
06:38:27 <benny99> what's wrong :( ?
06:38:37 <oerjan> benny99: you need in ... at the end
06:38:53 <Toxaris> > let bla = [1..20] >>= (\x -> return (x * x)) in bla
06:38:59 <lambdabot>  [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400]
06:39:05 <oerjan> or just drop the let in that case
06:39:19 <oerjan> *let bla =
06:39:20 <benny99> > bla = [1..20] >>= (\x -> return x)
06:39:20 <lambdabot>  Parse error at "=" (column 5)
06:39:35 <benny99> > bla = [1..20] >>= (\x -> return x) in bla
06:39:35 <lambdabot>  Parse error at "=" (column 5)
06:39:41 <oerjan> > [1..20] >>= (\x -> return x)
06:39:45 <oerjan> is what i meant
06:39:47 <benny99> ah :-[
06:39:52 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
06:39:55 <benny99> I'm sorry
06:40:27 <benny99> is there  a way to write for example "do \n x <- [1..20] \n return (x * x)" in one line btw. ?
06:41:01 <oerjan> > do x <- [1..20] ; return (x * x)
06:41:03 <lambdabot>  [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400]
06:41:09 <benny99> ah, yeah
06:41:38 <oerjan> with nested blocks you sometimes need {} brackets too
06:41:59 <benny99> hm, did some haskell months ago -- looked at even more other languages and I'm back again, but I rather lost some knowledge I guess :|
06:42:11 <benny99> thanks :)
06:42:21 <benny99> is there a "quick refreshment course" ?
06:42:50 <hashendgame> if I'm building a world from zones(labelled by strings) and rooms(labelled by strings within zones), I come up with the following: data Room = ...; type Zone = Data.Map String Room; type World = Data.Map String Zone . Does that look right?
06:42:51 <MyCatVerbs> benny99: good question. I think the "Gentle Introduction" (which isn't actually all that gentle, but oh well) is probably your best bet.
06:43:02 <benny99> MyCatVerbs: thanks :)
06:43:43 <oerjan> hashendgame: seems fine
06:43:55 <benny99> hashendgame: what are you going to do?
06:44:06 <MyCatVerbs> benny99: no problem. It's really written for people already familiar with some other lazy functional language (say, Miranda or one of the many other academic languages that Haskell was originally designed for the purpose of replacing).
06:44:43 <oerjan> well if he is refreshing then he sort of is familiar - with the same language :)
06:44:49 <MyCatVerbs> benny99: so I guess it'll be fine for you, since you already are familiar with some other lazy functional language... it's just a slightly unusual edge case that the language you're already familiar with is Haskell. :)
06:44:53 <benny99> MyCatVerbs: I'm reading it right now :) (did Haskell not replace them?)
06:45:23 <oerjan> MyCatVerbs: that does sound like a rather narrow group nowadays :D
06:46:09 <MyCatVerbs> benny99: Indeed it did. Haskell was originally designed because there were a whole load of not-usefully-different lazy functional languages - the idea was to have one open, free, standard language that everybody could pool their efforts towards making better, rather than working on isolated, fragmented projects.
06:46:33 <MyCatVerbs> benny99: And, heck, now we have GHC. So on some level it must've worked, no? :)
06:46:42 <benny99> MyCatVerbs: and it worked I guess ;) ?
06:46:59 <benny99> yeah :-[
06:47:08 <hashendgame> oerjan, benny99: build a MUD. I'm trying to work out how to handle concurrency: one way would be to have a thread that does all the mutation of the world, but that seems not too good for scaling. So my problem is deciding what to wrap in TVars.
06:47:14 <MyCatVerbs> oerjan: I suppose so. Does anyone still use Miranda?
06:47:17 <benny99> hashendgame: you stole my idea :p
06:47:41 <hashendgame> benny99: have any code so far? I don't.
06:47:48 <oerjan> i don't know.  people do use clean, i think.
06:49:16 <roger`> hashendgame: does a mud need concurrency?
06:49:23 <benny99> MyCatVerbs: in the past year I tried to look at as many languages as possible -- for some reason -- and I think that Haskell is the functional language that is worth lots of hours of learning - apart from Scheme
06:49:32 <benny99> hashendgame: no, I also don't
06:50:21 <benny99> hashendgame: look at my message to mycatverbs ;) -- and I also need to "refresh" my Haskell Knowledge (and learn lots of new stuff...)
06:50:42 <MyCatVerbs> oerjan: oh, you're right. I'd completely forgotten CleanD'oh.
06:50:53 <benny99> Clean is commercial :(
06:51:36 <hashendgame> roger`: well, as I understand it, you're going to have to forkIO to handle each client. Then I see two options: 1. have each client thread just spit things down a TChan and have a thread that multiplexes them and mutates the game as things arrive. The other is to have each client thread mutate bits of the world. Depends on how big it gets, I suppose
06:52:19 <roger`> hashendgame: well, thinking imperatively, a specific example would be CircleMUD handles 1000+ clients and does everything in a linear manner quite well.
06:52:30 <benny99> and my English is bad :(...
06:52:56 <MyCatVerbs> benny99: Not particularly worse than any given British teenager.
06:53:45 <roger`> hashendgame: good luck :)
06:53:59 <hashendgame> roger`: I guess I'll just call proper concurrency 'premature optimisation' then. I guess I'll wind up doing something in the style of http://sequence.complete.org/node/258
06:54:00 <benny99> ^^
06:54:00 <lambdabot> Title: A simple TCP server | The Haskell Sequence
06:54:21 <oerjan> benny99: commercial but with open source
06:54:22 <benny99> roger`: does CircleMUD also work great on multicore cpus etc. ?
06:54:22 <MaxRabkin> come on guys... give Haskell a chance: I'm sure at least one of you can get some points in the next 1h20 <http://olympiad.cs.uct.ac.za/contest.html>
06:54:55 <benny99> oerjan: yeah - though the language shootout "says" it was great - I prefer Haskell :-[
06:55:27 <roger`> benny99: how many cores a machine has is of no consequence to circlemud.
06:55:58 <MaxRabkin> roger`: because it uses all of them or because it only uses one of them?
06:56:35 <hashendgame> MaxRabkin: I believe it just uses select(2) to handle all the clients. I'm taking a pick at the source now
06:56:39 <hashendgame> so only one
06:56:42 <resiak> So I believe that in theory it's possible to write a library in Haskell and then use it from C.  Does anyone actually do this in practice?
06:56:43 <roger`> to the best of my recollection, it only needs to use one
06:57:30 <hashendgame> yeah it uses select
06:58:31 <hashendgame> and no pthreads/fork so I'm going to go with one process/thread
06:58:57 <MyCatVerbs> Murrr. But MUDs aren't particularly CPU-intensive anyway, surely?
06:59:07 <benny99> hashendgame: or use threads later
06:59:08 <quicksilver> some of them are, actually.
06:59:13 <hashendgame> benny99: true
06:59:24 <quicksilver> depends how many users you have and how active the AI is
06:59:46 <MyCatVerbs> quicksilver: what do they ever do that's more than, say, ten to fifteen decibels more expensive than IRCDs?
06:59:47 <benny99> and features like those maps
07:00:19 <quicksilver> MyCatVerbs: AI. Monsters chasing players across the map.
07:00:42 <benny99> MyCatVerbs: recieving crazy scripts?
07:00:55 <MyCatVerbs> quicksilver: But the map is just a connected digraph. Not something expensive to traverse, surely?
07:00:58 <quicksilver> no
07:01:03 <quicksilver> the expense is in the volume, really
07:01:11 <quicksilver> 15 monsters would be no struggle
07:01:19 <quicksilver> but if your game world has 400 players and 40,000 monsters
07:01:22 <MyCatVerbs> benny99: Admittedly, you should punch users in the face if they want to run their own code on your server, because that's suicidal. x_x
07:01:57 <quicksilver> I agree that most MUDs don't do much which is inherently expensive.
07:02:10 <quicksilver> Funnily enough, on the profiles I've seen, it's actually text formatting which is the most expensive part :)
07:02:26 <MyCatVerbs> quicksilver: Ah, huh. I was thinking that a digraph would be much cheaper to traverse than, say, a grid or anything based on cartesian geometry. Of course that breaks at that scale.
07:02:35 <quicksilver> event happens, 50 users are in a position to observe that event.
07:02:44 <mux> wow, these wild-card patterns for records they are working on in GHC HEAD are *great*
07:02:45 <quicksilver> each user gets (potentially) a customised description of the event
07:02:52 <Saizan_> ?seen malcomw
07:02:52 <lambdabot> I haven't seen malcomw.
07:02:57 <quicksilver> it might be in different colours depending on their settings and so on
07:03:08 <quicksilver> so MUDs invent their own printf-like formatting DSLs
07:03:11 <benny99> MyCatVerbs: I don't have a server :p -- but there are muds that send that map on every move -- and if you do like 100 moves in a row and 20 players are following it might cost some cpu power like... :/ nothing
07:03:45 <MyCatVerbs> quicksilver: that sounds crazy, surely that should be clientside. But then, you usually want to let people use just a plain ol' telnet client, rather than anything fancy.
07:04:06 <quicksilver> MyCatVerbs: it's not just that, it's information hiding.
07:04:18 <MyCatVerbs> benny99: that'd be suicidal from the point of view of network expenses moreso than CPU time.
07:04:18 * benny99 reads the gentle intro to haskell --- later
07:04:27 <quicksilver> If "MyCatVerbs" is my friends, I see "MyCatVerbs (healthy) hits the orc"
07:04:44 <quicksilver> if "MyCatVerbs" is an enemy, I just see "A graceful elf hits the orc"
07:04:48 <roger`> MyCatVerbs: though, large muds use compression to reduce the network expenses
07:04:55 <quicksilver> so each message (in principle) is customised per-recipient
07:04:58 <MyCatVerbs> quicksilver: except without the "graceful" part. :)
07:05:11 <benny99> compression --> cpu time
07:05:24 <quicksilver> hashendgame: I'm not sure if that got lost in the noise, but was it made clear that cheap threads are the haskell idiom for select() ?
07:05:40 <quicksilver> hashendgame: they're not necessarily real threads. It's just a more convenient abstraction.
07:05:43 <MyCatVerbs> benny99: bandwidth is expensive, CPUs are cheap. And even if they aren't, CPUs get cheaper faster than bandwidth does, so it soon shifts that way.
07:06:03 <MyCatVerbs> roger`: that sounds saner.
07:06:12 <hashendgame> quicksilver: yeah. I think I'm good with that.
07:06:16 <benny99> it did already :p
07:06:35 * benny99 is really away now :-[
07:06:50 <hashendgame> MyCatVerbs: there's the mud compression protocol negotiated as a telnet option that basically says 'from here on, gzip all output. I can handle it'
07:07:45 <MyCatVerbs> hashendgame: that sounds like a damn good use of telnet's extensibility. ^_^
07:07:45 <Saizan_> quicksilver: it's even less deterministic than a select loop though
07:07:53 <Gyde> why can't I do this in a guard: | (b == (0,0,0,0)) and (c == (0,0,0,0)) = 1
07:08:08 <quicksilver> Gyde: you mean &&
07:08:12 <quicksilver> Gyde: not "and"
07:08:13 <Saizan_> ?type and
07:08:14 <lambdabot> [Bool] -> Bool
07:08:20 <Zao> and ands everything in a list.
07:08:33 <Gyde> yes ..
07:08:35 <Gyde> right dooh
07:12:05 <MaxRabkin> byorgey: good luck
07:12:05 <hpaste>  Toxaris annotated "Natural sort algorithm -- anyone shorten this?" with "using ReadP" at http://hpaste.org/4489#a1
07:12:40 <Gyde> proberly some kind of error here: | (b == (0,0,0,0)) && ((!!) 2 c == (!!) 1 a) = 1
07:12:43 <Toxaris> (somewhat crazy idea to use parser combinators to write parsers, though)
07:12:51 <Gyde> same kind*
07:12:55 <byorgey> MaxRabkin: heh, thanks.  I don't know how much time I have to actually work on it but I was curious to see what the problems are =)
07:13:08 <oerjan> Gyde: c !! 2 == a !! 1
07:13:38 <Toxaris> Gyde: (!!) 1 a == 1 !! a /= a !! 1 == (!!) a 1
07:15:06 <Nafai> byorgey: Whatcha working on?
07:16:13 <hashendgame> the last hurdle I've got is this: if I were doing it in C I'd have a struct player with a struct room *, and struct room would have a struct player ** to get all the players in the room. I'm thinking record types for each, with player storing the current room as a (String,String) and room storing the player by name. Anyone have a better idea?
07:16:42 <MaxRabkin> Nafai: http://olympiad.cs.uct.ac.za/contest.html -- if you want to start now, you've got an hour, as we started 20 minutes late
07:16:42 <lambdabot> Title: SACO: Competition Page
07:16:47 <quicksilver> Saizan_: If you are dealing with such a high volume that determinism and fairness actually matters, you are going to have to think much harder about things
07:17:05 <quicksilver> Saizan_: for the majority of cases where incoming data sockets are mostly empty most of the time, it's fine :)
07:17:24 <Nafai> MaxRabkin: Oh!  I saw that on reddit
07:17:26 * Nafai looks
07:18:03 <quicksilver> hashendgame: strings or int (being ID numbers) yes
07:18:17 <quicksilver> hashendgame: I'd got for strings unless you're convinced that's too slow, it will be easier to debug :)
07:18:43 <Nafai> Wish I had time to focus, this could be fun.
07:19:10 <oerjan> hashendgame: make type synonyms
07:19:26 <mdmkolbe|work> Data.Map says it uses the "hedge-union" algorithm for unions.  Where can I find some documentation on that algorithm?  (Only web references I find are to data.map documentation.)
07:19:35 <MaxRabkin> Nafai: do the next one
07:19:46 <MaxRabkin> it'll be in February-ish
07:20:05 <Gyde> ehh oerjan that didn't help, still not work, says the types dosen't match
07:20:18 <hashendgame> quicksilver: Strings are better on the users, too. If an admin wants to do something like warp to a room, 'warp zonename roomname' is much better than 'warp 3001'. Ints just look like premature optimisation again
07:20:18 <oerjan> Gyde: paste your code
07:20:23 <oerjan> !paste
07:20:23 <hpaste> Haskell paste bin: http://hpaste.org/
07:20:26 <quicksilver> hashendgame: agreed 100%
07:20:26 <Gyde> will do
07:20:27 <Nafai> MaxRabkin: Cool, I definitely will.
07:20:50 <quicksilver> hashendgame: that's rather what I was getting at with 'easier to debug'
07:20:56 <quicksilver> hashendgame: easier on the admins and stuf
07:21:09 <hpaste>  gyde pasted "tileChecker" at http://hpaste.org/4497
07:22:03 <oerjan> Gyde: oh they are tuples, you cannot use !! then
07:22:07 <hashendgame> oerjan: things like type Location = (String, String) ; zone = fst ; room = snd
07:22:29 <Gyde> hmm, it works if I do it manually in hugs
07:22:35 <oerjan> hashendgame: _that_ definitely should be data :)
07:22:44 <Gyde> no it dosen't
07:22:45 <Gyde> lol
07:22:53 <Gyde> ehh then what can I do?
07:23:58 <oerjan> Gyde: probably define Tile as a data type
07:24:41 <Gyde> it has to be (Int,Int,Int,Int)
07:24:44 <hashendgame> oerjan: Data Location = Location { zone :: String , room :: String } then?
07:25:12 <oerjan> Gyde: you must use tuples?
07:25:23 <oerjan> hashendgame: nice
07:25:42 <Gyde> yes
07:26:11 <oerjan> oh right, you can use pattern matching
07:27:31 <oerjan> let me annotate
07:28:23 <roconnor> @quote roconnor
07:28:23 <lambdabot> roconnor says: Haskell caused the credit crunch!
07:29:30 <hashendgame> Gyde: how are you using (!!) on tuples?
07:30:28 <Saizan_> hashendgame: you could have richer type safety with newtype Zone = Zone String , newtype Room = Room String, data Location = Location { zone :: Zone, room :: Room } so you won't use a zone name as a room one etc.. at the price of having to wrap/unwrap the newtype constructors in some places
07:30:43 <Gyde> im not ..
07:30:53 <Gyde> because I can't appently ;)
07:31:04 <mdmkolbe|work> Is there any documentation on the "hedge-union" algorithm used by Data.Map?
07:31:26 <MaxRabkin> mdmkolbe|work: I was wondering that myself the other day
07:31:40 <davidL> In the expression "liftM5 Foo a b (\x -> c x) d e" does 'c' get passed the value that is returned by 'b'?
07:31:55 <integral> @src Data.Map
07:31:55 <lambdabot> Source not found. My pet ferret can type better than you!
07:31:59 <integral> @libsrc Data.Map
07:31:59 <lambdabot> Unknown command, try @list
07:32:21 <mauke> @source Data.Map
07:32:21 <lambdabot> http://darcs.haskell.org/packages/base/Data/Map.hs
07:32:36 <Gyde> can I do something like this (_,_,x,_) = (1,2,3,4)
07:32:45 <quicksilver> yes
07:32:53 <mdmkolbe|work>  mauke: heh, that's a 404
07:32:55 <hpaste>  oerjan annotated "tileChecker" with "with pattern matching" at http://hpaste.org/4497#a1
07:32:55 <MyCatVerbs> Sisal seems interesting. It seems like we could do with stealing a few ideas from it.
07:33:00 <mauke> http://haskell.org/ghc/docs/latest/html/libraries/containers/src/Data-Map.html
07:33:01 <lambdabot> http://tinyurl.com/2bjwxd
07:33:01 <quicksilver> > let (_,_,x,_) = (1,2,3,4) in "x is " ++ show x
07:33:03 <lambdabot>  "x is 3"
07:33:09 <quicksilver> Gyde: just like that :)
07:33:23 <hashendgame> Saizan_: how is newtype different to data? Is it just that you can only have a single thing on the RHS? What makes newtype Zone = Zone String different to data Zone = Zone String?
07:33:25 <Saizan_> davidL: not in general
07:33:51 <Saizan_> hashendgame: newtypes have no runtime overhead
07:33:52 <oerjan> Gyde: see paste
07:33:56 <Gyde> thx ..
07:33:56 <Gyde> ;)
07:34:06 <Gyde> thx everybody .. wuhu
07:34:07 <quicksilver> davidL: no, but 'c' does feel the effect of any effects which a and b have caused
07:34:19 <hashendgame> Saizan_: but lets the typechecker trip you up if you're doing something stupid?
07:34:20 <davidL> Saizan_: how can I make it do that? (preferably without using do syntax)
07:34:24 <quicksilver> davidL: so it has some connection with b, depending on the monad.
07:34:34 <Saizan_> hashendgame: exactly
07:35:02 <MyCatVerbs> Why bother with newtype at all, anyway? Why not just have the compiler automatically optimize all single-constructor data types into newtypes? Have I missed some subtlety there?
07:35:24 <quicksilver> MyCatVerbs: yes, slightly different semantics
07:35:40 <quicksilver> MyCatVerbs: consider the effect of (case foo of A _ -> )
07:35:47 <quicksilver> MyCatVerbs: where A is newtype, resp. data
07:36:26 <MyCatVerbs> quicksilver: that'll surely be identical in the single-constructor case to (const) ?
07:36:28 <quicksilver> for most practical purposes this slight difference doesn't matter.
07:36:41 <quicksilver> MyCatVerbs: the point is if foo diverges
07:36:54 <quicksilver> MyCatVerbs: if foo diverges and A is a newtype, you can still case it
07:37:02 <quicksilver> because the newtype constructor is erased
07:37:13 <quicksilver> if foo diverges and A is data, then the case would diverge
07:38:41 <MyCatVerbs> quicksilver: you mean if foo is _|_, rather than Constructor _|_, then the case fails?
07:38:48 <quicksilver> right
07:38:59 <MyCatVerbs> Whereas with newtypes...?
07:39:03 <mdmkolbe|work> quicksilver: so "case undefined of NewType _ -> ..." does not diverge but "case undefined of MyData _ -> ..." will?
07:39:10 <quicksilver> mdmkolbe|work: right.
07:39:20 <quicksilver> because, operationally, casing a NewType means nothing
07:39:29 <quicksilver> it vanishes at compile time
07:39:37 <MyCatVerbs> quicksilver: except that divergence isn't actually a desirable property of progra>_>
07:39:44 <quicksilver> whereas casing a data means 'reduce to WHNF and check constructor'
07:39:55 <Saizan_> davidL: liftM4 (\a (b,c) -> Foo a (b,c)) a (b >>= \x -> (x,c x)) d e -- maybe?
07:39:57 <quicksilver> MyCatVerbs: no it's not, so therefore this different is not really very interesting to most practical programs.
07:40:05 <quicksilver> MyCatVerbs: but, you did ask if there was a difference, and this is it :)
07:40:16 <MyCatVerbs> quicksilver: Hell, let-floating alone will (occasionally) totally destroy the semantics of `seq` w.r.t _|_
07:40:42 <MyCatVerbs> quicksilver: and yet it's turned on by default, since nobody cares about their deliberate CPU-time-wasters getting broken.
07:41:51 <MyCatVerbs> quicksilver: that is a pretty cool difference, I admit, but it still seems that making the optimization from single-constructor datatypes to newtypes automatically doesn't have any negative side effects for programs... at least, none that GHC's maintainers aren't already happy to let happen anyway.
07:42:17 <mdmkolbe|work> Ah, Haskell.  It runs infinite loops faster than any other language I know.
07:42:56 <mdmkolbe|work> MyCatVerbs: It may matter if you're trying to prove something about the semantics of haskell, but then again they could make it a flag/language option.
07:42:58 <MyCatVerbs> Well, there's the possibility that a program might suddenly stop working when a datatype was extended from one to two constructors, because of such a case expression, but that doesn't seem like it'd be too common, surely. Confusing, yes, but rare and, crucially, hilarious when it does happen.
07:43:05 <Saizan_> well, you could have lazy pattern matching on product types by default like miranda
07:43:06 <davidL> Saizan_: interesting, I guess there's no easy way beside using do syntax, thanks
07:43:25 <hashendgame>  Confusing, yes, but rare and, crucially, hilarious when
07:43:27 <hashendgame>                     it does happen.
07:43:37 <MyCatVerbs> mdmkolbe|work: right, exactly the same as let-floating (which has similar side effects).
07:43:41 <hashendgame> someone needs to stick that in the lambdabot's quotedb
07:44:02 <qweqwe> http://hpaste.org/4501 any idea why limit not in scope ?
07:44:19 <MyCatVerbs> hashendgame: :)
07:44:39 <mauke> qweqwe: why would it be?
07:44:41 <mauke> er, wait
07:44:47 <mauke> there it is
07:44:54 <qweqwe> i mean http://hpaste.org/4503
07:45:41 <mdmkolbe|work> quicksilver: which use of "limit" is the problem?  (I see two)
07:45:59 <mdmkolbe|work> s/quicksilver/qweqwe/
07:46:06 <mauke> qweqwe: works if you add the missing }
07:46:55 <qweqwe> i didn"t make good copy paste so
07:47:00 <oerjan> @remember mdmkolbe|work Ah, Haskell.  It runs infinite loops faster than any other language I know.
07:47:00 <lambdabot> It is forever etched in my memory.
07:47:23 <mdmkolbe|work> :-)
07:47:25 <hpaste>  gyde pasted "tileFinder" at http://hpaste.org/4505
07:47:36 <ricky_clarkson> > fix (True ||)
07:47:38 <lambdabot>  True
07:47:39 <augustss> @seen heffalump
07:47:40 <lambdabot> heffalump is in #haskell and #darcs. I don't know when heffalump last spoke.
07:47:43 <qweqwe> http://hpaste.org/4504
07:47:44 <ricky_clarkson> Look, an optimised infinite loop!
07:48:10 <mdmkolbe|work> @type fix (True ||)
07:48:11 <lambdabot> Bool
07:48:11 <Gyde> I wanna return nothing or a empty list of some sort, but I can't due to the type .. look at http://hpaste.org/4505
07:48:17 <qweqwe> you see there is the } and i get the message on line with the Nothing
07:48:33 <mdmkolbe|work> > fix (True ||)
07:48:34 <lambdabot>  True
07:48:40 <mauke> Gyde: change the return type
07:48:45 <oerjan> hashendgame: heh, i didn't even see your comment before i did it
07:48:45 <ricky_clarkson> > fix (False ||)
07:48:46 <lambdabot>  Exception: <<loop>>
07:48:56 <oerjan> oh wait
07:49:04 <mauke> qweqwe: no errors
07:49:05 <Gyde> but the function I call from expects a type like that
07:49:16 <mauke> Gyde: then change the calling function
07:49:20 <oerjan> that wasn't the quote i @remembered
07:49:24 <mdmkolbe|work> Yep, I'd say both those infinite loops went pretty fast
07:49:34 <qweqwe> mauke:Undefined variable "limit" that what i get
07:49:44 <mauke> qweqwe: I don't care
07:49:48 <Gyde> no I mean, then when I hit the other guard then the return type dosen't match
07:50:12 <mauke> Gyde: change the return type
07:50:26 <MyCatVerbs> @src fix
07:50:27 <lambdabot> fix f = let x = f x in x
07:50:39 <Gyde> I can change it so it matches one but not the other
07:50:53 <mauke> Gyde: change it so both sides match
07:50:54 <MyCatVerbs> > fix (False &&)
07:50:55 <lambdabot>  False
07:51:49 <Gyde> donnu how
07:52:04 <mauke> :: ... -> Maybe PartSol
07:52:10 <mauke> ... = Just c
07:52:15 <mauke> | otherwise = Nothing
07:52:40 <Gyde> can I write Nothing?
07:52:58 <oerjan> Gyde: precisely
07:53:08 <Gyde> woot, nice... hate that I don't know that stuff
07:54:17 <Gyde> still says the types are wrong
07:55:21 <oerjan> Gyde: you need to change the caller too
07:55:40 <Gyde> *** Term           : Nothing
07:55:41 <Gyde> *** Type           : Maybe a
07:55:41 <Gyde> *** Does not match : (Array2D,[(Int,Int,Int,Int)])
07:56:08 <Gyde> but what is nothing?
07:56:12 <oerjan> is the latter the same as PartSol?
07:56:46 <Gyde> the caller uses map and makes [PartSol]
07:56:50 <MaxRabkin> @let loop = loop
07:56:51 <lambdabot> <local>:9:7:     Ambiguous occurrence `loop'     It could refer to either `lo...
07:56:59 <oerjan> Gyde: did you do all the changes mauke showed?
07:56:59 <MaxRabkin> :t loop
07:57:00 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowLoop a) => a (b, d) (c, d) -> a b c
07:57:06 <oerjan> there were three of them
07:57:14 <MaxRabkin> > 0 * undefined
07:57:15 <lambdabot>  Undefined
07:57:25 <MaxRabkin> > True || undefined
07:57:26 <lambdabot>  True
07:58:55 <oerjan> Gyde: when you use Nothing, you need to add Just to all the other values, and Maybe to the type, like mauke showed
08:00:37 <oerjan> @src Maybe
08:00:37 <lambdabot> data Maybe a = Nothing | Just a
08:01:55 <Gyde> what dose Map add to the list when it get nothing?
08:02:16 <ricky_clarkson> > map (*2) []
08:02:18 <lambdabot>  []
08:02:50 <ricky_clarkson> > map isJust [Nothing,Nothing,Just 5,Just 10]
08:02:51 <lambdabot>  [False,False,True,True]
08:03:28 <davidL> > catMaybes [Nothing,Nothing,Just 5,Just 10]
08:03:29 <lambdabot>  [5,10]
08:04:37 <oerjan> > map (\x -> if x == 0 then Nothing else Just x) [-3..3]
08:04:38 <lambdabot>  [Just (-3),Just (-2),Just (-1),Nothing,Just 1,Just 2,Just 3]
08:06:16 <ricky_clarkson> @pl \x -> if (x :: Integer)==0 then Nothing else Just x
08:06:16 <lambdabot> ap (flip if' Nothing . (0 ==) . (:: Integer)) Just
08:06:36 <ricky_clarkson> @pl \x -> if x==0 then Nothing else Just x
08:06:36 <lambdabot> ap (flip if' Nothing . (0 ==)) Just
08:07:03 <Gyde> dose it Have to write just infront of it?
08:07:23 <Gyde> It would be nice just to get rid of all the Nothings with filter
08:07:40 <oerjan> Gyde: actually there is catMaybes for just that
08:07:40 <Gyde> or do I have to extract from the list in another way?
08:07:45 <oerjan> :t catMaybes
08:07:46 <lambdabot> forall a. [Maybe a] -> [a]
08:07:52 <oerjan> @index catMaybes
08:07:52 <lambdabot> Data.Maybe
08:08:11 <davidL> @src catMaybes
08:08:12 <lambdabot> catMaybes ls = [x | Just x <- ls]
08:08:25 <oerjan> > catMaybes [Just 1, Just 2, Nothing, Just 3, Nothing]
08:08:33 <lambdabot>  [1,2,3]
08:09:56 <oerjan> it also gets rid of the Justs as you see
08:10:34 <davidL> > catMaybes [Just 3, Just 8, Just Nothing]
08:10:35 <lambdabot>   add an instance declaration for (Num (Maybe a))
08:10:41 <MaxRabkin> :t catMaybes
08:10:42 <lambdabot> forall a. [Maybe a] -> [a]
08:10:55 <oerjan> > catMaybes [Just 3, Just 8, Nothing]
08:10:56 <lambdabot>  [3,8]
08:11:04 <hashendgame> :t Just Nothing
08:11:05 <lambdabot> forall a. Maybe (Maybe a)
08:11:24 <davidL> > catMaybes [Just (Just 3), Just (Just 8), Just Nothing]
08:11:25 <lambdabot>  [Just 3,Just 8,Nothing]
08:11:41 <benny99> hashendgame: maybe a stupid question -- but how advanced are you using haskell?
08:12:33 <hashendgame> benny99: good question. I understand a decent amount of what's going on, but I can't get beyond nifty tricks into the realm of real programs
08:13:31 <Spark> have you tried writing a real program?
08:13:45 <benny99> hashendgame: hm, sounds as if you are already much more advanced than I am -- and I guess I'm just a parasite at projects, but if there's anything to discuss --- could you maybe ask me?
08:14:11 <benny99> hashendgame: I could learn a bit more that way I guess
08:14:14 <hashendgame> benny99: regarding the haskell mud idea?
08:14:23 <benny99> hashendgame: always :)
08:14:31 <benny99> hashendgame: and especially about that idea
08:14:37 <benny99> *to
08:14:59 <benny99> hashendgame: *especiall regarding to that game idea
08:15:40 <benny99> hashendgame: but if there are any other problems that should be solvable without asking a "pro", you could ask me first as well :-[
08:16:12 <hashendgame> I just drop in here and ask everyone atm
08:17:42 <hashendgame> benny99: I'm not quite understanding what you're getting at
08:18:10 <benny99> hashendgame: what I meant was: I want to help writing that thingy, but I'm no pro at haskell (I don't even got the basics yet) and also not a great teammate I guess -- but if it doesn't bother you too much, I might could take a look at your project :-[
08:18:39 <mauke> why the sad face?
08:18:51 <hashendgame> I've got no code yet, but if I had access somewhere I'd not mind sticking up a darcs repo or something
08:18:54 <benny99> mauke: it's an embarrassed face :p
08:19:41 <hashendgame> Ideally I'd like to see something like NakedMud (http://homepages.uc.edu/~hollisgf/nakedmud.html), but done in haskell
08:19:46 <benny99> hashendgame: since we are just 2 people --> a repos at our desktop is enough I guess
08:20:54 <benny99> hm, I don't know anything about NakedMud -- is there anything special about it?
08:21:46 <hashendgame> it's got no game mechanics or anything, just a simple test zone and some OLC features. It's there as a base for people to build on
08:22:14 <benny99> an engine ^^?
08:23:01 <hashendgame> yeah, basically, but all in C/Python (built on a even more baseline starting point called socketmud (which is basically just all the socket handling stuff))
08:23:37 <benny99> does that require much technical knowledge?
08:24:07 <hashendgame> I've not dug into the depths too much, but the python interface isn't bad
08:24:24 <MaxRabkin> byorgey, Toxaris: want to join #saco for the discussion?
08:25:34 <SamB> freaky... I just searched for "Parsec haddock" (without the quotes) using the search box in firefox 1.5.x... and got misdetected as a bot...
08:26:54 <shachaf> @go Parsec haddock
08:26:55 <lambdabot> http://packages.debian.org/sid/ghc-cvs-doc/all/filelist
08:26:55 <lambdabot> Title: Debian -- Filelist of package ghc-cvs-doc/sid/all
08:27:01 <shachaf> And lambdabot doesn't? :-)
08:35:33 <SamB> oh, no wonder, I had accidentally turned on tor...
08:46:43 <tphyahoo-haskell>  :pl id
08:46:53 <tphyahoo-haskell> how do I use the pointsfree bot?
08:46:59 <oerjan> @pl id
08:46:59 <lambdabot> id
08:47:03 <tphyahoo-haskell> @pl id
08:47:03 <lambdabot> id
08:47:56 <resiak> @pl \ x y -> f (x y) y
08:47:56 <lambdabot> (f =<<)
08:48:28 <shachaf> @src (->) (>>=)
08:48:28 <lambdabot> f >>= k = \ r -> k (f r) r
08:48:55 <resiak> i wish there were a way to tell @pl not to use the (->) Monad instance
08:49:06 <shachaf> resiak: What should it use?
08:49:11 <Saizan_> @pl \ x y -> f y (x y)
08:49:11 <lambdabot> ap f
08:49:19 <shachaf> resiak: It needs at least ap.
08:50:29 <resiak> shachaf: well, in that example using the (->) instance is the clearest way; but it pops up everywhere, and I'm not convinced it's always particularly clear
08:50:45 <resiak> (but then I'm asking for @pl to produce readable code, which is a tad perverse I suppose :))
08:52:13 <tphyahoo-haskell> @pl \f xs -> zip (f xs) xs
08:52:14 <lambdabot> (zip =<<)
08:52:36 <tphyahoo-haskell> that's kinda weird.
08:52:57 <oerjan> potentially useful even
08:53:24 <qweqwe> http://hpaste.org/4508?lines=true when i run there line 2 the line 6 performed before line 5  can anyone explain me why it so ? but when i run that func alone all is ok
08:53:46 <oerjan> > (zip =<< tail) [1..]
08:53:48 <lambdabot>  [(2,1),(3,2),(4,3),(5,4),(6,5),(7,6),(8,7),(9,8),(10,9),(11,10),(12,11),(13,...
08:54:51 <vininim> @type (=<<)
08:54:51 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
08:55:08 <qweqwe> any ideas ?
08:55:24 <mauke> qweqwe: it isn't
08:55:25 <oerjan> qweqwe: seems like a flushing problem
08:55:33 <mauke> line 17 is performed first
08:55:52 <oerjan> oh right
08:56:26 <qweqwe> getShips  first than the boardSize
08:57:07 <qweqwe> that what you say?
08:57:31 <oerjan> qweqwe: switch the first two statements in getShips
08:57:41 <mauke> no, I'm saying the getline in line 17 is run first, then the limit command on line 18
08:57:54 <allbery_b> you request a line of input,m then call boardSize which asks for the board size
08:58:15 <allbery_b> it's doing exactly what you told it to
08:58:38 <allbery_b> seems to me it will ask for the size again on the recursive call, soo --- is that what you want?
08:58:43 <allbery_b> s/soo/too/
09:01:10 <qweqwe> i need in the battleships =  getShips boardSize .boardSize  will run first then the getShips with the output of the 1 function
09:01:35 <oerjan> qweqwe: haskell is lazy.
09:02:11 <oerjan> boardSize is not run directly before calling getShips.  it is run by the lim <- limit statement in getShips.
09:02:13 <allbery_b> seems to me that battleships should be boardSize >>= getShips, and then use the simple Int lim in getShips
09:02:33 <oerjan> yeah
09:03:24 <qweqwe> ok now i got why mauke said to me change the lines
09:06:23 <allbery_b> qweqwe: the other problem is that you pass boardSize in as an I/O action, so it will be run each time lim <- limit is evaluated
09:06:31 <qweqwe> how i can make the limit be simpale int there and not be evaluated again each time the getShips runs
09:06:42 <qweqwe> yes it is problem
09:06:53 <mauke> change IO Int to Int
09:06:58 <mauke> then fix the resulting type errors
09:07:24 <shachaf> I wish you could use _|_ as a variable name in Haskell. :-(
09:07:46 <idnar> _|_ always looks like a raised middle finger to me
09:07:58 <sorear> I think you can use (⊥)
09:08:06 <oerjan> you can use _I_
09:08:18 <oerjan> > let _I_ = undefined in _I_
09:08:19 <lambdabot>  Undefined
09:08:42 * shachaf has recently been misreading _I_ as _|_ a lot.
09:09:00 <qweqwe> boardSize returns IO Int how i can make return Int instead ?
09:09:04 <MaxRabkin> idnar: divergence is how programs say f*ck you
09:09:14 <sorear> you can also use lhs2TeX to map undefined => ⊥ after-the-fact
09:09:14 <MaxRabkin> qweqwe: you can't
09:09:33 <idnar> MaxRabkin: hee hee
09:09:48 <qweqwe> ok i know how to do it
09:09:53 <qweqwe> i think so
09:13:28 <allbery_b> <allbery_b> seems to me that battleships should be boardSize >>= getShips, and then use the simple Int lim in getShips
09:14:24 <allbery_b> the (>>=) runs the I/O action, "unwraps" the resulting Int, and passes it on to getShips (which must also be an I/O action; luckily, it already is)
09:15:24 <allbery_b> then just use the argument directly instead of running it as an I/O action (the "lim <- limit")
09:15:52 <allbery_b> @redo boardSize >>= getShips
09:15:52 <lambdabot> do { a <- boardSize; getShips a}
09:17:00 <Baughn> Is hs-plugins broken in 6.8.2, or is it me?
09:17:24 <Baughn> @version
09:17:24 <lambdabot> lambdabot 4p581, GHC 6.6 (Linux i686 2.40GHz)
09:17:24 <lambdabot> darcs get http://code.haskell.org/lambdabot
09:17:41 <allbery_b> hs-plugins depends on the binary format of .hi files, which changes in every GHC release; it hasn't been ported to 6.8.x yet
09:18:12 <Baughn> I see. Wouldn't it make sense to fold it into GHC proper, then?
09:18:52 <allbery_b> IIRC there's some missing functionality in ghc-api that makes it not useful to replace all of hs-plugins
09:19:12 <dcoutts> @tell ndm tagsoup-0.1 haddock docs fail to parse
09:19:12 <lambdabot> Consider it noted.
09:19:26 <allbery_b> somewhere on hackage is another plugin package which uses ghc-api and so doesn't break with every new ghc release, but it lacks some functionality (plugin unloading, IIRC)
09:20:31 <allbery_b> (hs-plugins predates a documented, externally visible ghc-api)
09:22:00 <quicksilver> s/documented/"documented"/
09:22:12 <Gyde> can you trace your code in hugs? to find infinte loops?
09:22:21 <Gyde> or other errors like that?
09:22:33 <allbery_b> well, yes, but it's better than pre-ghc-6.6
09:22:34 <Gyde> garbage collection errors
09:22:44 <SamB> hmm... so, they say parsec is prematurely optimized...
09:22:56 <allbery_b> Gyde: you don't.  code that works in hugs might be traceable with Hat, though.
09:23:01 <allbery_b> @where hat
09:23:01 <lambdabot> http://www.haskell.org/hat/
09:23:07 <Baughn> allbery_b: Wait, the plugins package? I thought that was the same as hs-plugins
09:23:10 <SamB> what would be an example of a nice parsing library that isn't?
09:23:12 <quicksilver> allbery_b: I think "metaplug" is the other plugin package you refer to.
09:23:17 <Baughn> allbery_b: ..still doesn't compile with 6.8.2, though
09:24:44 <allbery_b> quicksilver is correct, it's metaplug.  will probably need some .cabal file hacking to make it work with the 6.8 libs
09:27:30 <baobab> Do (unlines . map show $ list)   and (unlines $ map show list)    compile to the same term?
09:28:11 <dmhouse> baobab: yep.
09:28:29 <vininim> > f 1 where f = (+1)
09:28:29 <lambdabot>  Parse error at "where" (column 5)
09:28:32 <baobab> dmhouse: thank you (why?)
09:28:38 <vininim> ?
09:29:01 <dmhouse> vininim: you can only use where in certain contexts, that isn't one of them.
09:29:38 <dmhouse> vininim: http://en.wikibooks.org/wiki/Haskell/More_on_functions#Private_Functions
09:29:39 <lambdabot> http://tinyurl.com/yxvt8f
09:29:53 <quicksilver> (unlines . map show $ list) -~~-> (unlines . map show) list -~~-> unlines (map show (list))
09:30:09 <quicksilver> baobab: definition of ($), definition of (.), respectively
09:30:17 <dmhouse> baobab: f . g creates a function which computes its result by doing g first then f. ($) applies a function to a value.
09:30:19 <baobab> yes, i mean, does ghc infer it on its own
09:30:37 <quicksilver> baobab: it doesn't infer, really. It just uses definitions.
09:30:47 <SamB> @pl (\x y -> char x >> return y)
09:30:47 <lambdabot> (. return) . (>>) . char
09:30:48 <quicksilver> but it will inline small functions like (.) and ($)
09:30:56 <quicksilver> so those two realy will generate the same term.
09:31:11 <bench> how do you get a segment of a list starting with a certain element of position
09:31:15 <baobab> i see
09:31:26 <baobab> thx quicksilver and dmhouse
09:31:38 <mauke> drop/dropWhile
09:31:47 <dmhouse> bench: take and drop
09:32:05 <dmhouse> > take 2 . drop 4 $ [1..10]
09:32:06 <lambdabot>  [5,6]
09:33:31 <bench> ok, is there a way to do a !! then get 2
09:33:44 <dmhouse> !! always gets you a single element..
09:33:57 <bench> take/drop would have to walk through the list
09:34:04 <dmhouse> So does !!.
09:34:06 <dmhouse> ?src (!!)
09:34:07 <lambdabot> xs     !! n | n < 0 = undefined
09:34:07 <lambdabot> []     !! _         = undefined
09:34:07 <lambdabot> (x:_)  !! 0         = x
09:34:07 <lambdabot> (_:xs) !! n         = xs !! (n-1)
09:34:44 <bench> ah, ok, thanks
09:35:24 <dmhouse> You can define (!!) as xs !! n = head (drop n xs).
09:36:14 <kaol> @src head
09:36:14 <lambdabot> head (x:_) = x
09:36:14 <lambdabot> head []    = undefined
09:36:20 <kaol> @src drop
09:36:21 <lambdabot> drop n xs     | n <= 0 =  xs
09:36:21 <lambdabot> drop _ []              =  []
09:36:21 <lambdabot> drop n (_:xs)          =  drop (n-1) xs
09:37:01 <dbueno> dmhouse: That specification will differ from !! when n < 0
09:37:48 <dmhouse> dbueno: ah, true.
09:40:44 <bench> dmhous/kaol, thanks
09:44:06 <bench> is there a isNumber primitive similar to isDigit, so that isNumber("12.3") reaturns true?
09:45:54 <Baughn> @hoogle String -> [Word8]
09:45:55 <lambdabot> No matches, try a more general search
09:46:46 <dbueno> bench: isNumber _ = True -- almost everything can be interpreted as a number ... =]
09:47:54 <bench> dbueno:?
09:48:06 <dbueno> bench: (I don't know the answer to your question, but, I am merely observing that if such a function really existed, it woul have to deal with bases and all sorts of other nonsense to reasonably answer the question of whether a string contains a number.)
09:48:34 <dbueno> bench: There might be a predicate that tells you if a string contains a-bunch-of-digits or a float, or something.
09:48:39 <tetha> two dimensional number representation with varying bases :)
09:49:30 <bench> dbueno/tetha: let's restrict this to integer and decimal then
09:49:31 <dbueno> bench: And what-do-you-know, there is Data.Char.isNumber
09:49:41 <dbueno> bench: http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Char.html#v%3AisNumber
09:49:42 <lambdabot> http://tinyurl.com/2vh4p7
09:49:56 <dbueno> bench: Hoogle is your friend (http://haskell.org/hoogle/)
09:50:34 <dbueno> isNumber is defined on characters, though, not Strings.
09:50:46 <bench> dbueno, thanks, yes, it's only on characters
09:52:03 <bench> dbueno, i was looking for one that works on strings
09:53:08 <dbueno> bench: Probably the path of least resistance is using a regexp, then, if you truly need just isDecimalNumber.
09:53:36 <dbueno> bench: although presumably someone has solved this problem in the past; so you might be able to find a ready-made regexp.
09:54:10 <Gyde> ehh just installed hat, how do I use it on a call?
09:54:16 <Gyde> from hugs or?
09:55:45 <MyCatVerbs> > let { s1 (s:ss) = if isDigit s then s1 ss else if s=='.' then s2 ss else False; s1 [] = True; s2 = all isDigit  } in s1 "4.3"
09:55:47 <lambdabot>  True
09:55:51 <MyCatVerbs> > let { s1 (s:ss) = if isDigit s then s1 ss else if s=='.' then s2 ss else False; s1 [] = True; s2 = all isDigit  } in s1 "4.foobie3"
09:55:52 <lambdabot>  False
09:56:09 <MyCatVerbs> > let { s1 (s:ss) = if isDigit s then s1 ss else if s=='.' then s2 ss else False; s1 [] = True; s2 = all isDigit  } in s1 "40." -- Bug here. Damn.
09:56:10 <lambdabot>  True
09:56:15 <allbery_b> hat is a preprocessor.  you run it on your source, it creates a version that "traces" evaluation.
09:56:24 <allbery_b> read the documentation.
09:56:25 <bench> dbueno: will read work?
09:56:43 <allbery_b> be aware that hat only supports a (large) subset of haskell98, though
09:56:56 <MyCatVerbs> > let { s1 (s:ss) = if isDigit s then s1 ss else if s=='.' then s2 ss else False; s1 [] = True; s2 yar@(s:ss) = all isDigit yar; s2 [] = False; } in s1 "40." -- Bug here. Damn.
09:56:57 <lambdabot>  False
09:57:07 <MyCatVerbs> Fugly! But that works.
09:57:52 <MaxRabkin> @go "content-aware resizing"
09:57:53 <lambdabot> http://www.youtube.com/watch?v=vIFCV2spKtg
09:57:53 <lambdabot> Title: YouTube - Image resize
10:00:00 <dbueno> bench: if the test fails, read will fail and catching the error won't be clean; whereas a regular expression failing to match is easy to deal with.
10:00:35 <dbueno> bench: You'll have to catch an exception (I think, I've never done exceptions in Haskell) to deal with a failing read.  But with regexps, failure is built in to the return value of the "does this match" call.
10:00:51 <dbueno> bench: See http://haskell.org/ghc/docs/latest/html/libraries/regex-compat/Text-Regex.html
10:00:52 <lambdabot> http://tinyurl.com/2nww8c
10:01:09 <MaxRabkin> @src [] fail
10:01:09 <lambdabot> fail _      = []
10:01:21 <MaxRabkin> @src Either fail
10:01:21 <lambdabot> fail msg      = Left (strMsg msg)
10:01:31 <MaxRabkin> @src strMsg
10:01:32 <lambdabot> Source not found. You type like i drive.
10:01:45 <shachaf> dbueno: What about reads?
10:02:07 <dbueno> shachaf: I've never used reads. =]
10:02:09 <shachaf> > (reads "1", reads "one")
10:02:10 <lambdabot>  ([(1,"")],[])
10:03:01 <dmhouse> > reads "123hello"
10:03:02 <lambdabot>  [(123,"hello")]
10:03:19 <dmhouse> It's a list because it allows for ambiguous parsing.
10:05:37 <dbueno> > reads "123.4"
10:05:38 <lambdabot>  []
10:05:58 <dbueno> > reads "123.4" :: (Double, String)
10:05:59 <lambdabot>  Couldn't match expected type `(Double, String)'
10:06:22 <dbueno> > reads "123.4" :: [(Double, String)]
10:06:22 <lambdabot>  [(123.4,"")]
10:13:16 <bench>  reads "1"
10:14:04 <bench> how come under ghci: it complains about reads being ambiguous, do i have to type it like dbueno did above?
10:14:22 <dmhouse> bench: yep.
10:14:25 <dmhouse> ?type reads
10:14:26 <lambdabot> forall a. (Read a) => String -> [(a, String)]
10:14:38 <shachaf> bench: If you use it in a bigger context, its type can be inferred.
10:14:52 <osfameron> (paul johnson)++ # "Success can visit, but make sure he wipes his feet
10:14:52 <osfameron> properly and doesn't steal the silver"
10:15:14 <dmhouse> So you have to specify the type of what you're parsing into, because otherwise the Show function that GHCi uses to print the result out might not be determined.
10:16:40 <b_jonas> tell me, is the haskell FFI easy to use in practice?
10:16:51 <bench> shachaf: how do you specify the larger context?
10:16:54 <b_jonas> for iterfacing with C or C++
10:17:19 <dbueno> bench: Wrap more code around the reads call.
10:17:20 <Zao> b_jonas: It's reasonably sane.
10:17:54 <shachaf> I mean, if you use it as a Double, it'll be inferred that it's a Double.
10:18:01 <DRMacIver> I was under the impression that you basically had to go via C to interface with C++
10:18:14 <DRMacIver> But I could be wrong. I've not used the FFI
10:18:18 <b_jonas> DRMacIver: oh ok, that's no problem
10:18:34 <b_jonas> I've written C wrappers for a C++ class once already
10:18:39 <bench> shachaf, you meant using the parsed result as a double or int?
10:18:41 <Zao> DRMacIver: Unless you want to unmangle C++ mangling yourself, and suffer a world of marshalling, aye :)
10:18:48 <DRMacIver> Heh
10:19:02 <b_jonas> for interfacing with lua
10:19:12 <DRMacIver> There's already hslua you know. :)
10:19:40 <Cale> I've also tested wrapping fortran calls and that seems to work fine too.
10:20:09 <b_jonas> DRMacIver: I know
10:20:18 <b_jonas> but I wanted a custom lua interface anyway
10:20:28 <b_jonas> not a straightforward one
10:20:29 <Cale> Er, I mean, using the FFI directly works fine with Fortran.
10:20:50 <b_jonas> Cale: I've never worked with fortran
10:21:09 <DRMacIver> b_jonas: Fair enough. :)
10:21:13 <Cale> But yeah, C libraries are pretty easy.
10:21:17 <b_jonas> maybe I'm too young
10:21:54 <Cale> I've never really worked with Fortran either, but there are a bunch of libraries in Fortran which one might conceivably want to wrap.
10:22:02 <b_jonas> but LAPACK already has a haskell wrapper written
10:22:16 <b_jonas> (at least parts of it)
10:22:37 <b_jonas> (for reference, it's "http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hmatrix-0.1.0.0")
10:22:37 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hmatrix-0.1.0.0"
10:24:53 <bench> shachaf: and what if the numbers could be integer and decimal?
10:25:05 <SamB> huh, scheme has an actual semantics?
10:25:33 <bench> so "12 4.4"
10:25:51 <bench> how do you read it with reads, give that you have to type it differently
10:25:55 <b_jonas> SamB: what do you mean?
10:26:02 <b_jonas> of course it does
10:26:10 <b_jonas> it's a programming language
10:26:17 <SamB> http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-10.html#%_sec_7.2
10:26:17 <lambdabot> http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-10.html#%_sec_7.2
10:26:27 <dons> ?users #xmonad
10:26:28 <lambdabot> Maximum users seen in #xmonad: 99, currently: 99 (100.0%), active: 8 (8.1%)
10:26:29 <SamB> lambdabot: why you just repeat what I say?
10:26:31 <dons> come on someone!
10:26:41 <dons> ?users #perl6
10:26:41 <lambdabot> Maximum users seen in #perl6: 147, currently: 138 (93.9%), active: 3 (2.2%)
10:27:02 <b_jonas> oh yeah, I've never actually read that formal thingy
10:27:07 <dons> ?users
10:27:07 <lambdabot> Maximum users seen in #haskell: 440, currently: 424 (96.4%), active: 19 (4.5%)
10:27:11 <dons> ?users #xmonad
10:27:11 <lambdabot> Maximum users seen in #xmonad: 100, currently: 100 (100.0%), active: 10 (10.0%)
10:27:12 <dons> yaya
10:27:46 <dbueno> bench: If all you have is integers and decimal, you can treat them all uniformly -- that is, expressing integers as decimals.
10:29:27 <hpaste>  (anonymous) annotated "Nicer xmonad.hs template?" with "(no title)" at http://hpaste.org/4511#a1
10:29:30 <bench> dbueno: i don't want the 1.0 but 1 if it is an integer
10:30:57 <dbueno> bench: Fair enough.  I'm not sure you'll easily be able to both use reads and deal with Integer and Floats, without adding an annotation.
10:31:25 * SamB wonders how a book on denotational semantics can be completely out of date
10:32:02 <dbueno> > reads "123.4" :: [(Integer, String)]
10:32:03 <lambdabot>  []
10:32:15 <b_jonas> dbueno: I have written a custom reader and formatter for numbers in haskell
10:32:21 <bench> dbueno: that's disappointing, how do you add annotation?
10:32:27 <b_jonas> because the ones available weren't exactly like I wanted
10:32:48 <dbueno> b_jonas: Is it available?  bench may like to see it.
10:32:59 <b_jonas> yes, I'll paste it
10:33:16 <bench> b_jonas/dbueno, yes, i'd like to see it
10:33:34 <dbueno> That's weird, why shouldn't reads "123.4" :: [(Integer, String)] give [(123, ".4")]?
10:34:08 <hpaste>  b_jonas pasted "formatter and writer for the J interpreter I started to write" at http://hpaste.org/4512
10:34:34 <dons> http://marco-za.blogspot.com/2007/12/saco-online-camp.html
10:34:35 <lambdabot> Title: Marco's Blog: SACO Online Camp
10:34:39 <b_jonas> hmm wait, that's wrong
10:34:42 <b_jonas> it's not the whole code
10:34:52 <dons> saco competition accepting haskell now.
10:35:37 <b_jonas> got truncated somehow
10:36:17 <bench> b_jonas, which part of the code were you doing the reads?
10:36:43 <b_jonas> here: http://erxz.com/pb/5774
10:36:43 <lambdabot> Title: freenode_web paste from "b_jonas" at 71.6.194.243...
10:37:16 <b_jonas> jLex is doing the reading, but it's quite ugly
10:37:27 <b_jonas> the formatter is saner
10:38:16 <b_jonas> lexNum7 is the specific function reading a number
10:38:45 <b_jonas> though it calls back the main lexer for the rest of the string
10:40:17 <b_jonas> you'd have to work a bit to separate it to a real number reader, because it's mixed with the lexer
10:40:28 * dcoutts adds four more haskell package to gentoo
10:40:31 <Dybber> how do I mark a subexpression to be of a special type? E.g. in ML you can do (exp : real)
10:40:37 <mauke> ::
10:40:40 <dbueno> Dybber: ::
10:40:41 <b_jonas> also note that it wants an underscore instead of a minus for negative sign
10:40:44 <Dybber> do I need to give it a name?
10:40:53 <dcoutts> Dybber: (exp :: Float)
10:40:55 <Dybber> ok :: can appear inside expressions too?
10:41:13 <bench> b_jonas, thanks
10:41:25 <b_jonas> Dybber: yes
10:41:37 <dbueno> > 3.5 + (4 :: Double)
10:41:38 <Dybber> ok thanks, i didn't know :)
10:41:42 <lambdabot>  7.5
10:42:31 <b_jonas> so basically (4 :: Double) as an expression is like (let { x :: Double; x = 4 } in x)
10:42:58 <shachaf> > 3.5 + 4 -- This would work anyway. :-)
10:42:59 <lambdabot>  7.5
10:43:00 <dons> "Haskell - language of the so-called. "clean" functional programming with the very strict static typification"
10:43:01 <Heffalump> dcoutts: not going to jump ship to NixOS then? :-)
10:43:18 <dcoutts> Heffalump: not yet
10:43:21 <monochrom> typification!
10:43:23 <dbueno> shachaf: It wouldn't illustrate that :: is allowed in subexpressions, though. =]
10:43:41 <Dybber> b_jonas, which was the way I did it before, but it looked too verbose to be true :)
10:43:45 <shachaf> dcoutts: Oh, you're planning to switch to NixOS?
10:43:56 <dcoutts> shachaf: no :-)
10:44:00 <SamB> is there a nicer way to say this:
10:44:05 <SamB> (chainl1 digit' (return $ \x y -> x * base + y))
10:44:26 <b_jonas> though I guess it isn't exactly the same
10:44:28 <dcoutts> shachaf: not unless I can run a standard desktop with all the stuff I need
10:44:40 <b_jonas> or it might not for polymorphic types
10:44:42 <b_jonas> I don't know
10:45:07 <b_jonas> I don't really understand how all that polymorphism works
10:45:13 <dcoutts> shachaf: I'm happy to admit Nix is technically superior to portage but portage has an army of packagers so loads of stuff is available with a reasonable level of QA
10:45:22 <monochrom> @pl \x y -> x * base + y
10:45:23 <lambdabot> (+) . (base *)
10:45:26 <bench> dbueno/b_jonas, would it be easier for my case to just do "elem '.' number" to decide if i should do reads::[Doublbe or Int]?
10:45:41 <dons> dcoutts: though the release cycles and rules of debian and say, gentoo, seem to slow them down.
10:45:51 <dons> xmonad 0.5 is in arch, minutes after release :)
10:45:55 <shachaf> dcoutts: Only one way to get NixOS there. :-)
10:46:06 <monochrom> SamB: either (+) . (base *), or IMO actually the original is best.
10:46:10 <dbueno> bench: If you know that there will be exactly 0 or 1 '.' in the number, that should work, and that the number will be otherwise correctly formatted, that should work.
10:46:13 <b_jonas> bench: no, because not (elem '.' "1e10")
10:46:22 <b_jonas> also
10:46:44 <dbueno> bench: It depends on whether you trust the data, and (as b_jonas says) in which formats you wish to parse the numbers.
10:46:45 <dcoutts> dons: gentoo has no release cycles
10:46:46 <b_jonas> "Infinity" and "NaN" or however it's spelt so haskell read accepts it
10:46:46 <SamB> was hoping for something more appropriate than chainl1
10:46:51 <shachaf> > read "Infinity" :: Double
10:46:52 <lambdabot>  Infinity
10:47:01 <shachaf> > read "NaN" :: Double
10:47:01 <lambdabot>  NaN
10:47:15 <b_jonas> > read "Inf" :: Double
10:47:16 <lambdabot>  Exception: Prelude.read: no parse
10:47:22 <dbueno> b_jonas: Right. Hadn't thought about Infinite/NaN.
10:47:23 <dcoutts> dons: arch is binary only which makes thing easier and they don't have many packages to keep working
10:47:26 <b_jonas> much more picky than the c double reader functions
10:48:00 <b_jonas> also, the lexer I pasted would be much more cleaner if it used some more monads
10:48:37 <dons> dcoutts: yep
10:48:38 <dcoutts> dons: a distro has to worry about the whole haskell platform and make sure the whole thing builds with a consistent set of software
10:48:49 <b_jonas> perhaps a Writer
10:48:57 <dcoutts> dons: and that's not possible at the moment, not without patching everything yourself, which is what we are doing
10:49:15 <b_jonas> and maybe a monad for consuming chars off the input too
10:49:30 <b_jonas> is there such a monad in mtl or somewhere btw?
10:49:37 <dcoutts> dons: simple example, try building haddock with ghc-6.8 which is necessary to bootstrap the haskell platform on a fresh system
10:50:07 <b_jonas> one where I can consume elements sequentially from a list state
10:50:11 <dons> yeah, i've heard complaints.
10:50:11 <b_jonas> and peek too
10:50:15 <dcoutts> dons: we do not have anyone or any group managing the haskell platform, making sure it all works
10:50:21 <dcoutts> except the distros
10:50:36 <dons> dcoutts: right. that's critical. and a mechanism for getting patches back upstream
10:50:36 <dcoutts> and it should not really be their job
10:51:03 <dcoutts> we need infrastructure to manage it centrally via hackage
10:51:09 <ddarius> There's a "Haskell platform"?
10:51:27 <bench> in my case, there are these possibilities: int, decimal, and int with ',' in the middle such as 14,000 or 14K
10:52:02 <ddarius> @users
10:52:02 <lambdabot> Maximum users seen in #haskell: 440, currently: 427 (97.0%), active: 26 (6.1%)
10:52:06 <bench> i was hoping that there is something like isNumber to handle the first 3 cases, where i would only need to handle the last one i.e. 14K
10:52:57 <dcoutts> ddarius: by the haskell platform, I mean the set of tools and libs you need to do any haskell development work, ie ghc, cabal, alex, happy, haddock, all the standard libs
10:53:31 <ddarius> You need alex and happy to do development work?
10:53:37 <hpaste>  dbueno pasted "Integer/Double parsing with reads" at http://hpaste.org/4513
10:54:11 <SamB> ddarius: in general yes
10:54:16 <dbueno> bench: The code I pasted may help re: annotations and such, but it looks like you need more than it (for comma parsing and such?)
10:55:12 <ddarius> SamB: "In general" I need c2hs, lhs2tex and many other tools.
10:55:19 <monochrom> SamB: Oh, I would use (many1 digit'), then the very flexible Numeric.readInt. This requires rewriting digit' to give a character.
10:55:25 * ddarius has never used alex or happy.
10:55:26 <dcoutts> ddarius: you need them to build many other haskell tools & libs
10:55:40 <SamB> ddarius: lhs2tex isn't necessary to executables
10:55:41 <bench> dbueno: yes
10:55:56 <ddarius> SamB: Neither is haddock.
10:56:13 <dcoutts> SamB: that doesn't mean it's not part of the platform, you don't need haddock to run xmonad but it's still part of the platform
10:56:28 <SamB> ddarius: true, but would you go without it?
10:56:38 <byorgey> GAH.  Word to the wise:  when defining an Ord instance, don't just define <. =P
10:56:49 <dcoutts> haddock is clearly part of the haskell platform
10:56:56 <ddarius> SamB: For the most part I have, though mostly because I'm lazy.
10:57:05 <b_jonas> byorgey: define compare instead?
10:57:08 <b_jonas> or define every method?
10:57:13 <byorgey> b_jonas: indeed, or <=.
10:57:13 <b_jonas> or which ones exactly?
10:57:14 <SamB> personally I *like* to use alex.
10:57:25 <byorgey> it says so in the docs, I was just dumb.
10:57:47 <SamB> unfortunately, happy tends to make me sad :-(
10:57:50 <byorgey> result: no warnings, and weird stack blowups due to infinite recursion in the default method implementations =(
10:58:00 <ddarius> SamB: Perhaps use frown.
10:58:19 <ddarius> byorgey: It should give you a warning, perhaps with -Wall
10:58:27 <bench> dbueno: i assume that i don't need the (Integer -> a) -> (Double -> a) as part of the testParse declaration if i just want to return the nmuber?
10:58:35 <byorgey> ddarius: I bet it would, I should really start using -Wall.
10:58:40 <monochrom> @remember SamB happy tends to make me sad :-(
10:58:40 <lambdabot> It is forever etched in my memory.
10:58:57 <b_jonas> bench: yes, but you have to convert the integer to a double in that case
10:59:01 <monochrom> I do disbelieve in these parser generators.
10:59:07 <b_jonas> with fromIntegral
10:59:21 <dbueno> bench: You have to come up with a return type for the function that subsumes Doubles and Integers.
10:59:40 <monochrom> @quote fromIntegral
10:59:40 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
10:59:41 <dbueno> bench: You said you don't want to convert Integer to Double, so, the functions let you do some processing on the numbers and return something uniform.
10:59:46 <b_jonas> monochrom: I mostly disbelive in them too
11:00:07 <SamB> monochrom: which ones?
11:00:18 <monochrom> Almost all of them.
11:00:31 <monochrom> All the existing ones.
11:01:00 <ddarius> monochrom believes in the ones that don't exist.
11:01:04 <bench> dbueno/b_jonas, ok, got it, thanks
11:02:16 <benny99> hm, sorry, is somebody able to explain what "kinds" are? (I just read http://www.haskell.org/tutorial/classes.html)
11:02:17 <lambdabot> Title: A Gentle Introduction to Haskell: Classes
11:02:26 <mauke> benny99: type types
11:02:35 <benny99> mauke: <_<?
11:02:45 <mauke> @kind Int
11:02:47 <lambdabot> *
11:02:50 <mauke> @kind Maybe
11:02:51 <lambdabot> * -> *
11:02:52 <benny99> @kind Char
11:02:54 <mauke> @kind Maybe Int
11:02:55 <lambdabot> *
11:02:55 <lambdabot> *
11:03:01 <benny99> ._.
11:03:04 <mauke> that is all
11:03:18 <monochrom> I don't find parser generators' input language any more readable than parser combinators. If I stick with parser combinators, I don't have to learn yet another arcane language. That's my consideration.
11:03:20 <benny99> Maybe is a type that is a type to a type constructor?
11:03:33 <Baughn> @djinn a -> (a,a)
11:03:34 <lambdabot> f a = (a, a)
11:03:36 <mauke> er. yes?
11:03:41 <Baughn> @. pl djinn a -> (a,a)
11:03:41 <lambdabot> f = join (,)
11:03:54 <benny99> :kind map
11:04:05 <benny99> @kind map
11:04:06 <lambdabot> Not in scope: type variable `map'
11:04:06 <davidL> how do I convert from ByteString.Lazy to ByteString?
11:04:15 <benny99> @kind Tree
11:04:15 <lambdabot> * -> *
11:04:31 <mauke> @kind Reader
11:04:32 <lambdabot> * -> * -> *
11:04:36 <dcoutts> davidL: avoid doing so if possible but if you must, use toChunks and then concat them
11:04:37 <benny99> does that mean "This is a type that expects another type to create a new type of kind "*"" ?
11:04:44 <mauke> benny99: yes
11:04:50 <mauke> and Reader takes two arguments
11:04:55 <benny99> ok :)
11:04:59 <benny99> thanks
11:05:05 <dcoutts> davidL: it's expensive, it forces the whole thing into memory and then copies the whole thing
11:05:14 <mauke> now if you want to get confused, try @kind (->)
11:05:20 <benny99> (it's a bit confusing :-[)
11:05:24 <benny99> @kind (->)
11:05:24 <lambdabot> ?? -> ? -> *
11:05:33 <ddarius> benny99: It's exactly like types.
11:05:35 <b_jonas> wow
11:05:36 <ddarius> :t (+)
11:05:37 <lambdabot> forall a. (Num a) => a -> a -> a
11:05:38 <benny99> lol :-o?
11:05:48 <benny99> ?? -> ? -> * ?
11:05:48 <lambdabot> Plugin `compose' failed with: Unknown command: ""
11:06:00 <mauke> benny99: it is evil hax
11:06:06 <davidL> dcoutts: how come there isn't a getRemainingByteString in Binary?
11:06:15 <b_jonas> I thought (->) has kind * -> * -> *
11:06:15 <benny99> mauke: what does that actually mean :-[ ?
11:06:39 <mauke> benny99: ?? and ? are ghc extensions. the official kind of (->) is * -> * -> *
11:06:39 <benny99> @kind (+)
11:06:40 <lambdabot> Not in scope: type variable `+'
11:06:51 <mauke> because it takes two type arguments and returns a complete type
11:06:52 <benny99> ah :o)
11:07:00 <SamB> frown has strange notation
11:07:26 <benny99> hm, I wonder why GHC 6.8.2 is still not in the fedora repos .(
11:07:31 <SamB> I mean, having part of a production before the : or | is odd
11:07:38 <dcoutts> davidL: because the underlying representation is a lazy bytestring, so that's why there is http://hackage.haskell.org/packages/archive/binary/0.4.1/doc/html/Data-Binary-Get.html#v%3AgetRemainingLazyByteString and not getRemainingByteString
11:07:40 <lambdabot> http://tinyurl.com/27z765
11:07:57 <ddarius> SamB: Doesn't frown support GLR parsing...
11:08:01 <mauke> @kind ContT
11:08:02 <lambdabot> * -> (* -> *) -> * -> *
11:08:02 <dcoutts> oops, I didn't mean to paste that url
11:08:07 <b_jonas> > let { a :: (->) Int Int; a x = 2 * x } in a 5
11:08:07 <lambdabot>  10
11:08:18 <davidL> dcoutts: should I do "fmap getByteString (fromIntegral remaining)" or should I just leave it a lazy bytestring?
11:08:22 <SamB> mostly because the | and : are not the same thing
11:08:23 <monochrom> Here is an extra benefit of some parser combinator libraries that is not matched by any existing parser generators. Control inversion, the Oleg delimited continuation way. Some parser combinator library can accept (or be modified to accept) an abstract stream as the thing to be parsed. Now give it some reset-shift trick as your stream, you get a suspendable parser. Yes exactly like generic zipper. No existing parser combinato
11:08:23 <monochrom> r does that, except for Grammatical Framework, which again has its own learning curve.
11:08:29 <b_jonas> > let { a :: (-> :: * -> * -> *) Int Int; a x = 2 * x } in a 5
11:08:29 <lambdabot>  Parse error at "::" (column 16)
11:08:35 <b_jonas> > let { a :: ((->) :: * -> * -> *) Int Int; a x = 2 * x } in a 5
11:08:35 <lambdabot>  Parse error at "::" (column 18)
11:08:45 <b_jonas> > let { a :: (((->) :: (* -> * -> *))) Int Int; a x = 2 * x } in a 5
11:08:45 <lambdabot>  Parse error at "::" (column 19)
11:08:49 <dcoutts> davidL: if you care about performance keep it as a lazy bytestring
11:08:50 <OceanSpray> :t putStr
11:08:51 <lambdabot> String -> IO ()
11:08:54 <mauke> aren't kind signatures a ghc extension?
11:09:01 <dcoutts> davidL: if you don't, then it's easy to convert it
11:09:04 <b_jonas> mauke: yes, they are
11:09:09 <b_jonas> but they're a useful one
11:09:37 <b_jonas> or, you mean, > doesn't parse ghc extensions?
11:09:44 <davidL> dcoutts: thanks, I'll just keep it lazy then
11:10:09 <mauke> > id :: forall a. a -> a
11:10:09 <lambdabot>  Parse error at "." (column 15)
11:10:57 <b_jonas> I see
11:11:18 <SamB> so it seems that frown supports something a bit like parser combinators?
11:12:29 <b_jonas> ghci -fglasgow-exts accepts 'let { a :: ((->) :: * -> * -> *) Int Int; a x = 2 * x } in a 5'
11:12:53 <b_jonas> so I can at least think it has kind * -> * -> *
11:13:00 <b_jonas> and use it like that
11:19:43 <byorgey> ddarius: interestingly enough, even -Wall is not smart enough to figure out the problem.  defining only < compiles just fine but sends the code into infinite recursion as soon as you try comparing two things that aren't equal.
11:20:22 <loupgaroublond> bos: ping
11:25:30 <qweqwe> -> do {can be here if else statment } ?
11:26:00 <shachaf> qweqwe: Yes.
11:26:01 <roconnor> qweqwe: yes
11:26:04 <byorgey> qweqwe: there are no if else statements, only if else expressions =)
11:26:16 <shachaf> qweqwe: But the then and else need to be indented more than the if.
11:26:16 <roconnor> qweqwe: in a couple of ways
11:26:37 <b_jonas> shachaf: what?
11:26:43 <roconnor> do { if x then do {foo;bar} else do {baz;buz}}
11:26:54 * shachaf just guessed that that might've been the problem.
11:26:55 <roconnor> do { when x do {foo;bar}}
11:27:03 <roconnor> do { unless x do {foo;bar}}
11:27:09 <shachaf> roconnor: Don't you need a $?
11:27:23 <roconnor> shachaf: hmm, perhaps
11:27:30 <b_jonas> I guess you do
11:27:35 <roconnor> shachaf: do is a keyword, so I'm not sure
11:27:43 <shachaf> > runWriter $ do { when True do { tell [1]; tell [2] } }
11:27:43 <lambdabot>  Parse error at "do" (column 28)
11:27:44 <b_jonas> > do { when True do { 1 } }
11:27:44 <lambdabot>  Parse error at "do" (column 16)
11:27:46 <shachaf> > runWriter $ do { when True $ do { tell [1]; tell [2] } }
11:27:47 <lambdabot>  ((),[1,2])
11:27:50 <b_jonas> > do { when True $ do { 1 } }
11:27:50 <lambdabot>   add an instance declaration for (Num (m ()))
11:27:50 <lambdabot>     In the expression: 1
11:28:00 <b_jonas> you need one
11:28:03 <roconnor> okay, $ iti s
11:28:48 <quicksilver> although do is a keyword, keywords don't get special precedence rules
11:28:55 <quicksilver> I guess in the end that would be more confusion
11:29:03 <quicksilver> foo if True then 3 else 4
11:29:07 <quicksilver> ^^ this is not "foo 3"
11:29:12 <quicksilver> rather, it's a syntax error
11:29:15 <b_jonas> what?
11:29:28 <b_jonas> > negate if True then 3 else 4
11:29:29 <lambdabot>  Parse error at "if" (column 8)
11:29:35 <b_jonas> > negate (if True then 3 else 4)
11:29:36 <lambdabot>  -3
11:29:39 <quicksilver> right
11:29:41 <b_jonas> hmm you're right
11:29:43 <dmhouse> > negate $ if True then 3 else 4
11:29:43 <lambdabot>  -3
11:29:46 <quicksilver> that's why you needed a $ with the do
11:29:47 <b_jonas> > if True then 3 else negate 4
11:29:47 <lambdabot>  3
11:30:22 <b_jonas> > if False then 1 else negate 10 + 100
11:30:23 <lambdabot>  90
11:30:29 <shachaf> > (negate if) True (then 3 else) negate 4
11:30:30 <lambdabot>  Parse error at "if)" (column 9)
11:30:38 <b_jonas> > if True then 1 else negate 10 + 100
11:30:39 <lambdabot>  1
11:30:56 <b_jonas> so if else has a lower precedence than infix ops
11:31:19 <quicksilver> actualy then and else are slightly special
11:31:28 <quicksilver> but if is parsed as if it were a function
11:31:34 <quicksilver> (from the point of view of precedence)
11:31:51 <quicksilver> > 5 + if True then 5 else 4
11:31:53 <lambdabot>  10
11:32:17 <b_jonas> yes
11:33:03 <b_jonas> anyway, 'if x then y else z ^ w' parses as 'if x then y else (z ^ w)' not as '(if x then y else z) ^ w'
11:34:52 <qweqwe> http://hpaste.org/4515 i get there Illegal type "IO RedBlackTree a b" in constructor application
11:35:05 <qweqwe> what is the problem with that there ?
11:35:08 <b_jonas> qweqwe: try parenthesis
11:35:14 <b_jonas> IO (RedBlackTree a b)
11:43:01 <qweqwe> http://hpaste.org/4516 is there a vay to get the RBTree as virable and not starting with constructor cases ?
11:43:43 <quicksilver> qweqwe: sure, just don't start with a capital letter
11:43:54 <quicksilver> qweqwe: initial capital --> constructor or type
11:44:00 <quicksilver> initial lowercase --> variable
11:44:05 <qweqwe> ok
11:44:10 <qweqwe> thanks
11:44:31 <quicksilver> It's not common to take IO foo parameters
11:44:37 <quicksilver> the normal patter for IO actions is
11:44:42 <quicksilver> a -> b -> c -> d -> IO e
11:44:49 <quicksilver> that is, only the "return type" has IO
11:45:04 <shachaf> @ty liftM2
11:45:05 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
11:45:16 <quicksilver> I think you might find it easier if getShips :: Int -> RedBlackTree v k -> IO (RedBlackTree v k)
11:48:01 <qweqwe> it recoursive function as you seen
11:48:13 <quicksilver> yup
11:48:16 <quicksilver> that's, OK, though
11:48:24 <qweqwe> ok i will change
11:48:32 <qweqwe> i have another question
11:48:40 <qweqwe> Ambiguous variable occurrence "insert"
11:48:41 <qweqwe> *** Could refer to: RedBlackTree.insert Data.List.insert
11:48:48 * quicksilver nods
11:48:56 <quicksilver> you can hide teh Data.List one
11:48:59 <quicksilver> to get rid of the error
11:49:06 <quicksilver> intstead of "import Data.List"
11:49:07 <qweqwe> how ?
11:49:14 <quicksilver> do "import Data.List hiding (insert)"
11:49:41 <qweqwe> i don"
11:49:52 <qweqwe> ok
11:51:39 <b_jonas> or you could import qualified RedBlackTree as RBT
11:51:48 <b_jonas> and then refer to all functions in it as RBT.foo
11:52:33 <b_jonas> that's how you normally use Data.Map and things like that
11:53:58 <qweqwe> i have another problem with constructors there http://hpaste.org/4517
11:55:45 <b_jonas> parenthisize that too
11:56:01 <b_jonas> um no sorry
11:57:22 <qweqwe> any ideas ?
11:57:24 <b_jonas> I don't know then
11:57:35 <b_jonas> is that youre exact code?
11:57:43 <qweqwe> yes
11:57:46 <allbery_b> where is that constructor defined?
11:58:00 <qweqwe> another file
11:58:05 <zxczxc> http://wolfgang-city.myminicity.com/ind
11:58:06 <lambdabot> Title: MyMiniCity
11:58:12 <allbery_b> how are you importing it?
11:58:56 <b_jonas> qweqwe: have you exported the constructors in that other module? just exporting the type doesn't export the constructors
11:59:49 <qweqwe> http://hpaste.org/4518
12:00:27 <b_jonas> yes, you're not exporting the constructors there
12:00:40 <b_jonas> the syntax is like
12:01:03 <b_jonas> module RedBlackTree(RedBlackTree(Leaf, Node), isempty, ...
12:01:04 <hpaste>  allbery_b annotated "(no title)" with "export constructors" at http://hpaste.org/4518#a1
12:01:04 <b_jonas> iirc
12:02:33 <qweqwe> worked thanks
12:04:11 <dons> ?users
12:04:11 <lambdabot> Maximum users seen in #haskell: 440, currently: 434 (98.6%), active: 20 (4.6%)
12:04:44 <ddarius> 434?
12:07:10 <oal``> i see 429
12:07:19 <dons> 10.
12:07:19 <dons> 	
12:07:26 <dons> 10. irc:// #haskell  -- 10th largest channel :)
12:07:29 <pejo> dons, how is that blogging about QC going? :-)
12:07:31 <dons> http://searchirc.com/search.php?SCHANS=1&SSORT=SIZE&N=freenode
12:07:32 <elad`> ERROR - Cannot find "show" function for:
12:07:32 <elad`> *** Expression : t1
12:07:32 <elad`> *** Of type    : Tree Char Integer
12:07:32 <lambdabot> Title: Search IRC, displaying all channels on freenode
12:07:36 <dons> pejo: in the back of my mind.
12:07:49 <dons> elad`: your Tree type doesn't have a show instance.
12:08:09 <pejo> dons, just gently prodding you in case you'd forgotten.
12:08:17 <dons> cheers
12:09:30 <ddarius> dons: That looks like it's sorting by current users.
12:09:46 <dons> right.
12:10:08 <dons> ddarius: http://technologyupdating.blogspot.com/2007/12/haskell-language.html :)
12:10:09 <lambdabot> Title: Technology Updating: Haskell Language, http://tinyurl.com/2k8vuz
12:10:14 <dons> slogans do have some effect
12:11:36 <elad`> What exactly does "instance" do, and can I mix it with "deriving"?
12:11:41 <ddarius> I'm not sure what effect it's having there...
12:12:16 <qweqwe> http://hpaste.org/4521 how i ccan deal with that ?
12:12:27 <shachaf> elad`: It declares a manual instance of a type class.
12:12:30 <b_jonas> elad`: instance makes a type become a member of a class, and define the meaning of all the methods of that class when applied to that particular type
12:12:45 <shachaf> elad`: deriving can make some instances automatically.
12:13:06 <b_jonas> (simply speaking)
12:13:09 <shachaf> elad`: Recent GHCs allow standalone deriving, I think, but in general, they don't mix.
12:13:29 <quicksilver> qweqwe: well, you are matching with "Ship x y" in the defn of intersected
12:13:45 <b_jonas> you can mix them in that a type can have explicit instances to some class, but be a derived instance of other classes
12:13:48 <quicksilver> qweqwe: so, the compiler is able to infer it must be a RedBlackTree Battleship a
12:14:10 <quicksilver> qweqwe: but you have claimed it works for *all* RedBlackTrees not just those containing Battleships
12:14:31 <elad`> data Tree a b = Empty | Branch Colour (a,b) (Tree a b) (Tree a b)
12:14:31 <elad`>    deriving (Eq)
12:14:31 <elad`> instance Show Tree where
12:14:34 <elad`> What's wrong here?
12:14:45 <shachaf> elad`: You have to give the show instance.
12:14:54 <fadec> old topic: color inversion - xcompmgr is one 2190 line c.file with comments. Very optimistic.
12:14:56 <shachaf> elad`: If you want, you can say "deriving (Eq,Show)".
12:15:10 <shachaf> elad`:  Otherwise, you have to say "instance Show Tree where show x = ..."
12:15:32 <elad`> data Tree a b = Empty | Branch Colour (a,b) (Tree a b) (Tree a b)
12:15:33 <elad`>    deriving (Eq)
12:15:33 <elad`> instance Show Tree where
12:15:33 <elad`>    show Empty = "3"
12:15:36 <elad`> Doesn't work.
12:15:48 <elad`> "Illegal type in class constraint
12:16:03 <tetha> hm. it is possible to define a function in a where-clause or a let-clause. is it possible to define its type in this clause, as well? if it is, how?
12:16:04 <shachaf> elad`: Oh, instance Show (Tree a b), maybe?
12:16:12 <shachaf> tetha: Yes.
12:16:16 <mrd> tetha: same way as at toplevel
12:16:24 <shachaf> > let f :: Int -> Int; f = (+1)
12:16:24 <lambdabot>  Parse error at end of input
12:16:26 <elad`> Thanks, that's it.
12:16:27 <shachaf> > let f :: Int -> Int; f = (+1) in f 5
12:16:29 <lambdabot>  6
12:16:43 <quicksilver> tetha: in a real program, probably with a newline instead of a ;
12:16:44 <shachaf> tetha: This is optionally on separate lines.
12:17:28 <tetha> ah :) thanks
12:18:09 <bos> loupgaroublond: pong
12:18:17 <qweqwe> quicksilver : so how i make it work i couldn"t understand that
12:18:23 <shachaf> @let 2 + 2 = 5
12:18:23 <lambdabot> Defined.
12:18:25 <shachaf> > 2 + 2
12:18:26 <lambdabot> Terminated
12:19:04 <SamB> whoa, + and - are special-cased identifiers in scheme?
12:20:25 <olsner> they are? I though they were simply functions called + and - respectively?
12:21:09 <ddarius> SamB: R5RS or R6RS?
12:21:26 <quicksilver> qweqwe: you could just get rid of the type signature
12:21:36 <quicksilver> qweqwe: you could replace the type signature with that hugs things the type is
12:22:18 <allbery_b> Hugs told you how to fix it:  instead of RedBlackTree a b, declare it to expect RedBlackTree Battleship b
12:22:59 <qweqwe> yes that what i did and it worked
12:24:20 <b_jonas> SamB: + is special-cased for +n patterns
12:24:25 <loupgaroublond> bos: i'm applying for being a reviewer now, so i might be able to do something with haskell packages
12:24:52 <b_jonas> so you can say like, let fact n + 1 = (n + 1) * fact n; fact 0 = 1;
12:24:56 <b_jonas> or something like that
12:25:00 <quicksilver> dons: hmm. Bulat's "single loop" version is four loops :P
12:25:09 <allbery_b> yet another reason n+k-patterns are eeeevil
12:25:11 <b_jonas> - is special because it's also a prefix op
12:25:18 <b_jonas> allbery_b: yep
12:25:18 <ddarius> b_jonas: Haskell isn't Scheme.
12:25:44 <b_jonas> ddarius: sorry?
12:25:58 <ddarius> [14:19] <SamB> whoa, + and - are special-cased identifiers in scheme?
12:26:13 <b_jonas> meh, + and - are special in scheme too
12:26:14 <dons> quicksilver: yeah, though it looks like a good target to aim at :)
12:26:49 <b_jonas> (the lexer treats them as a word specially while most words starting with - or + or . are numbers)
12:28:08 <dons> quicksilver: its not the same program either.
12:28:13 <dons> the job was to find the longest word.
12:28:16 <b_jonas> s/word specially/identifier specially/
12:28:24 <dons> it was a maximumBy . map . words problem
12:30:21 <quicksilver> heh
12:30:46 <quicksilver> I didn't even notice that :)
12:31:01 <quicksilver> bulat's wrong, isn't he, to say GHC doesn't unroll loops?
12:31:06 <quicksilver> I thought it did if you asked it to...
12:31:41 <dons> i don't think i've ever checked that.
12:31:46 <pejo> How often is loop unrolling beneficial on todays processors?
12:31:49 <b_jonas> you mean it should try to inline a recursive function to itself?
12:32:02 <b_jonas> pejo: it depends
12:32:05 <b_jonas> for short loops, it can be
12:32:19 <qweqwe> how i can deal with that ?
12:32:22 <qweqwe> http://hpaste.org/4522
12:32:24 <quicksilver> pejo: always :)
12:32:34 <quicksilver> pejo: although the benefits are marginal for long loops
12:32:38 <qweqwe> some problem with map function here
12:32:46 <b_jonas> the authentic source is the optimization guide the cpu vendor puts on the net
12:32:49 <pejo> quicksilver, if it's always beneficial even infinite loops would be completely unrolled.
12:33:26 <quicksilver> pejo: well it's a space tradeoff, isn't it?
12:33:31 <b_jonas> yes, it's called like that, Software Optimization Guide
12:33:43 <Korollary> It depends on the pipeline length of the processor
12:33:49 <b_jonas> Korollary: not only that
12:34:08 <b_jonas> it can also depend on the memory references the loop body uses
12:34:09 <quicksilver> qweqwe: I'm not really sure you want map at all
12:34:12 <Lemmih> qweqwe: I'm not sure what your code should do.
12:34:21 <quicksilver> qweqwe: map is for applying functions to lists
12:34:25 <allbery_b> qweqwe: (bfs a), not bfs(a)
12:34:34 <quicksilver> qweqwe: (x,y) doesn't look like a list, it looks like a single thing...
12:34:50 <quicksilver> allbery_b: yeah, but intersected is binary, so it looks more like zipWith than map...
12:35:03 <quicksilver> allbery_b: and (x,y) isn't a list, so I'mt not sure what it looks like :)
12:35:11 <b_jonas> but if you compile through C, then it's the task of the c compiler to unroll suitable tight loops
12:35:12 <allbery_b> yeh
12:35:25 <allbery_b> I just noted the incorrect function application syntax
12:35:33 <qweqwe> bfs returns a list
12:35:52 <quicksilver> possibly map (\tr -> intersected tr (x,y)) (bfs a)
12:35:52 <quicksilver> ?
12:36:17 <b_jonas> the amd64 optimization guide has a page about unrolling loops, and elsewhere it mentions the specific case of memcpy
12:36:23 <dons> the other issue is that fusion combines loop bodies
12:36:31 <quicksilver> b_jonas: however, compilation through C is on the way out :)
12:36:32 <dons> so rather than unrolling them, you make the single loop bigger
12:36:37 <dons> so it does more work each time.
12:36:44 <dons> f = map (+1) (enumFromTo 0 4) -- for example
12:36:54 <b_jonas> quicksilver: why? the ghc manual says that's how you get the best optimizations
12:37:06 <b_jonas> (for current versions of ghc, and a good c compiler at least)
12:37:31 <b_jonas> actually it has more than one page
12:37:44 <b_jonas> five pages or something
12:38:01 <dons> that little loop, turns into:
12:38:02 <dons> wunfold_unstream (x :: Int#) = case ># x 4 of  False -> I# (+# x 1) : wunfold_unstream (x +# 1) True  -> []
12:38:03 <pejo> dons, normally you would fuse prior to loop unrolling though
12:38:13 <dons> yeah, you should then unroll that
12:38:13 <quicksilver> b_jonas: because compilation through C is fragile and misconceived :)
12:38:25 <quicksilver> b_jonas: C is a poor intermediate languge.
12:38:36 <b_jonas> quicksilver: why does ghc recommend it then?
12:38:36 <quicksilver> b_jonas: in 6.8 C is no longer the default backend for -O2
12:38:46 <b_jonas> sure, it might be a poor intermediate language
12:38:46 <quicksilver> b_jonas: because their native codegen wasn't very godo
12:38:50 <quicksilver> good
12:38:54 <b_jonas> but there are good C compiler availabe
12:39:09 <quicksilver> in 6.10 or 6.12 the C backend may be deprecated completely
12:39:14 <b_jonas> which lets you spare some of the work
12:39:16 <quicksilver> or left in only for bootstrapping
12:39:40 <quicksilver> b_jonas: it does, but it doesn't work as well as you might hope.
12:39:46 <quicksilver> for example, C doesn't support tail calls.
12:39:50 <elad`> bfs :: Tree a b -> [(a,b)]
12:39:50 <elad`>  bfs x = bfsq [x] where
12:39:50 <elad`> ..
12:39:54 <tetha> lets compile haskell into c++-templates. *ducks+hides*
12:39:54 <b_jonas> I see
12:39:56 <elad`> ERROR file:.\e.hs:151 - Syntax error in input (unexpected `=')
12:40:14 <quicksilver> there are various ways in which haskell compilation doesn't map very well onto C
12:40:35 <quicksilver> C-- -> native is a much nicer path, in principle
12:40:36 <allbery_b> indentation?
12:40:47 <quicksilver> elad`: extra space befre the second bfs
12:41:07 <b_jonas> like lazyness, yes
12:41:13 <elad`> Thanks!
12:41:40 <ddarius> tetha: Been (partially) done.
12:42:03 <b_jonas> well, if the native code generator is in a good state, that's a good nwes
12:42:08 <hpaste>  gyde pasted "displaying a type" at http://hpaste.org/4523
12:42:44 <Gyde> can somebody explain or give a give to making a show function/display for the type partsol
12:42:57 <Gyde> or give a guide*
12:43:00 <Cale> Simply add  deriving Show  to the end of the data decl.
12:43:19 * shachaf doesn't like the "order by"/"group by" in list comprehensions.
12:43:34 <Cale> Or you can explicitly write your own instance if you don't like the implementation that provides
12:43:39 <ddarius> shachaf: Are they there now?
12:43:43 <Cale> instance Show Array2D where
12:43:47 * ddarius thinks it's a horrible idea.
12:43:54 <Cale>   show (Leaf i t) = ...
12:44:05 <Cale>   show (Node l i t r) = ...
12:44:11 <shachaf> ddarius: I don't know, I just came across them again.
12:44:17 * shachaf likes monad comprehensions.
12:44:21 <pejo> ddarius, what do you suggest instead?
12:44:29 <ddarius> pejo: Nothing.
12:45:34 <Gyde> or give a guide*
12:45:36 <Gyde> dooh
12:45:48 <b_jonas> list comprehensions are starting to grow to a mini-language in haskell
12:46:17 <Cale> shachaf: Me too.
12:47:09 <Cale> The whole order-by/group-by thing doesn't seem nearly general enough.
12:47:25 <ddarius> b_jonas: Not really.  Most of the extensions don't seem popular.
12:47:43 <b_jonas> so?
12:47:54 <b_jonas> just because it's not popular, it is growing
12:48:00 <b_jonas> there's already a zip extension
12:48:06 <ddarius> It may well shrink again.
12:48:30 <shachaf> The parallel comprehensions extension is sort of nice, but it should be more general.
12:48:47 * ddarius doesn't care for parallel list comprehensions either.
12:48:59 <davidL> if I run getRemainingLazyByteString twice, shouldn't the second time return empty?
12:49:18 <ddarius> I guess I should just say that I'm not a big fan of list comprehensions period, though they can occasionally be just the right thing.
12:50:12 <shachaf> ddarius: It sort of corresponds to ZipList, maybe? I guess Applicative comprehensions don't make a lot of sense.
12:51:40 <Saizan_> davidL: no, it's a sort of lookahead, it's not consumed
12:52:40 <davidL> Is "fmap getByteString (fromIntegral remaining)" the correct way to consume it?
12:53:21 <dons> well, that's one way
12:53:54 <davidL> what's another way?
12:55:25 <dcoutts> dons: apparently hs-plugins-1.0 on hackage compiles with ghc-6.6.1, do you know if it actually works?
12:56:02 <dons> i don't think it works. can we remove it from hackage?
12:56:18 <dcoutts> dons: not easily
12:56:40 <dcoutts> Lemmih: do you happen to know if hs-plugins-1.0 on hackage works with ghc-6.6.1 ?
12:56:41 <dons> we need: Broken: True fields :)
12:56:54 <dcoutts> we need a testing system
12:57:08 <dons> yeah. we've a bit of funding to work on this next year in galois, fwiw
12:57:20 <dcoutts> would anyone like to try my cabal + cabal-install patches
12:57:26 <dcoutts> they need some testing and feedback
12:57:31 <Saizan_> davidL: you could get the remaining input outside of the monad with runGetState
12:57:53 <Lemmih> dcoutts: I do not.
12:58:23 <dcoutts> Lemmih: ok. btw, would you like to do some cabal-install testing ? :-)
12:58:25 <quicksilver> Ah. Chilli con carne, tabasco sauce, and an unread Monad.Reader. This is the life.
12:58:26 <dcoutts> dons: you too :-)
12:59:18 <davidL> Saizan_: thanks
12:59:20 <Lemmih> dcoutts: Where's the repo?
13:00:04 <dcoutts> Lemmih: darcs.haskell.org/cabal and darcs.haskell.org/cabal-install with an addition patch I'm sending right now...
13:00:08 <dons> dcoutts: sure.
13:00:20 <dons> i just built a 6.8.2 and only 30 mins built cabal-install for it..
13:00:20 <pippijn> haskell likes darcs.. why?
13:00:24 <dons> dcoutts: in darcs?
13:00:34 <Lemmih> pippijn: Darcs is written in Haskell.
13:00:35 <dcoutts> ok, thanks, grab the latest cabal and cabal-install from darcs and I'll send the extra patches in a sec
13:00:36 <dons> pippijn: historically, we quickly standardised on a dvcs
13:00:39 <pippijn> ah
13:00:42 <dons> pippijn: and darcs was the first one that worked well
13:01:35 * shachaf once wanted the darcs repository of darcs, and almost looked for "darcs darcs". :-)
13:01:49 <pippijn> ;-)
13:02:09 <quicksilver> I thought darcs was stored as an SCCS repo.
13:02:59 <allbery_b> ewwww
13:03:58 <b_jonas> lol
13:04:10 <elad`> http://pastebin.com/d39d4e31e
13:04:18 <elad`> ERROR file:.\e.hs:19 - Cannot justify constraints in explicitly typed binding
13:04:18 <elad`> *** Expression    : hlpr
13:04:18 <elad`> *** Type          : [Tree a b] -> String
13:04:18 <elad`> *** Given context : ()
13:04:18 <elad`> *** Constraints   : (Show a, Show b)
13:04:53 <b_jonas> there's less of an excuse for storing a versioning system under a different one than for implementing a language in another one
13:04:55 <quicksilver> elad`: your derived Show instance can only show a tree if it can show the keys and values
13:05:13 <bringert> hi dcoutts
13:05:13 <elad`> I don't think I understand, quicksilver.
13:05:21 <b_jonas> because it's easier to convert a repo to the repo of another system than to translate a program to another language
13:05:26 <quicksilver> elad`: in the defintion of hlpr, you call 'show key'
13:05:35 <quicksilver> elad`: that means the key has to be showable :)
13:05:36 <allbery_b> elad`: your Tree has to be composed of things that can themselves be show-ed
13:05:44 <gwern> @hoogle chr
13:05:45 <lambdabot> Data.Char.chr :: Int -> Char
13:05:45 <lambdabot> Data.ByteString.Internal.memchr :: Ptr Word8 -> Word8 -> CSize -> IO (Ptr Word8)
13:05:48 <elad`> How do I encode that in Haskell?
13:05:50 <shachaf> elad`: hlpr :: (Show a, Show b) => [Tree a b] -> String?
13:05:57 <allbery_b> it can't magically show something that isn't show-able
13:06:02 <quicksilver> as shachaf says :)
13:06:11 <elad`> Thanks. Works.
13:06:11 <b_jonas> derive a Show instance for the key too
13:06:31 <quicksilver> b_jonas: the key is a type variable :)
13:06:39 <bringert> dcoutts: how's your cabal-install hacking going?
13:06:45 <b_jonas> oh sorry
13:06:49 <dcoutts> bringert: can you test please? :-)
13:06:54 <gwern> @hoogle showIntAtBase
13:06:54 <lambdabot> Numeric.showIntAtBase :: Integral a => a -> (Int -> Char) -> a -> ShowS
13:06:55 <bringert> dcoutts: yep
13:06:58 <b_jonas> then yes, what shachaf said
13:06:59 <dcoutts> bringert: I just sent patches to the cabal-devel list
13:07:03 <OceanSpray> for some reason, the REPL I wrote doesn't let the user use the <- button.
13:07:14 <OceanSpray> Instead, it inserts some weird \ESC characters
13:07:18 * bringert looks
13:07:31 <hpaste>  BMeph annotated "(no title)" with "Looking for this?" at http://hpaste.org/4522#a1
13:07:58 <OceanSpray> what's a function that I can use in place of getLine that will allow people to do that?
13:08:04 <dcoutts> bringert: may not have arrived yet, I just sent it and it's not in the mailman archive yet...
13:08:11 <davidL> > showIntAtBase 2 intToDigit 255
13:08:12 <lambdabot>  <[Char] -> [Char]>
13:08:20 <b_jonas> OceanSpray: run your program with the :main command
13:08:28 <dcoutts> bringert: and it's 200k worth of patches
13:08:31 <bringert> dcoutts: put a copy of your repo somewhere?
13:08:35 <quicksilver> OceanSpray: those \ESC characters are what the <- button is!
13:08:37 <dcoutts> ok
13:08:37 <elad`> How do I end a line?
13:08:44 <OceanSpray> yes, I know
13:08:45 <quicksilver> OceanSpray: tehre isn't an ascii code for 'arrow left'
13:08:47 <b_jonas> it seems to me that ghci doesn't restore the stty when you just perform an IO function from the ghci prompt
13:08:52 <OceanSpray> well, dang
13:08:57 <b_jonas> backspace
13:09:09 <OceanSpray> backspace works fine, why can't arrow left?
13:09:15 <b_jonas> oh
13:09:16 <OceanSpray> urgh
13:09:22 <quicksilver> it may be that we're talking at cross purposes here
13:09:24 <b_jonas> you mean you want a readline-like library?
13:09:30 <OceanSpray> yes
13:09:34 <quicksilver> ghc comes with a readline binding
13:09:36 <b_jonas> I misidentified your problem then, sorry
13:09:38 <elad`> I'm trying to have a string that spans more than one line. Using "\n" doesn't work.
13:09:44 <quicksilver> System.Console.Readline?
13:09:47 <quicksilver> or something
13:09:51 <OceanSpray> lemme try that
13:09:55 <davidL> > showIntAtBase 2 intToDigit 255 ""
13:09:56 <lambdabot>  "11111111"
13:09:58 <shachaf> ←
13:10:02 <bringert> @seen Igloo
13:10:02 <lambdabot> Igloo is in #ghc, #haskell and #darcs. I last heard Igloo speak 1d 1h 29m 21s ago.
13:10:14 <Igloo> Hey bringert
13:10:17 <dcoutts> Lemmih, dons, bringert: http://haskell.org/~duncan/cabal/  you want the cabal-(install-)command-line.dpatch
13:10:49 <allbery_b> elad`: spans more thn one source line?  use \ \
13:11:04 <allbery_b> (baskslash, any kind of whitespace including newlines, another backslash)
13:12:48 <dons> dcoutts: what's the change?
13:12:59 <dons> i can install a .tar.gz passed on the command line? :)
13:13:08 <dcoutts> dons: not yet
13:13:24 <dcoutts> dons: it now uses more sane command line handling
13:13:48 <filcab42> hi all
13:14:01 <shachaf> filcab42: Hello.
13:14:07 <dcoutts> dons: so it's like Setup.hs command line: cabal subcommand [flags] rather than cabal [global-flags] subcommand
13:14:18 <gwern> OceanSpray: a repl eh? did you look at shellac?
13:14:31 <dcoutts> dons: it should accept exactly the same command line as Setup.hs, see --help
13:14:42 <filcab42> @type [(a,b,c) | a <- [1..], b <- [1..a], c <- [1..b], a**2 == b**2 + c**2]
13:14:44 <lambdabot> forall t. (Enum t, Floating t) => [(t, t, t)]
13:14:49 <dcoutts> well, except for being able to specify package names as extra args
13:14:57 <filcab42> should the (a,b,c) be of type Int?
13:15:09 <filcab42> I mean
13:15:22 <filcab42> shouldn't they come out as: (5,4,3), etc?
13:15:22 <mauke> Int isn't Floating
13:15:27 <OceanSpray> no
13:15:34 <OceanSpray> what's shellac?
13:15:37 <filcab42> it isn't?
13:15:37 <filcab42> :s
13:15:48 <dcoutts> dons: especially -v to see that it's passing the right args on to Setup.hs
13:15:50 <monochrom> a**2 is not Int. try a^2
13:16:01 <filcab42> thanks
13:16:05 <gwern> OceanSpray: a somewhat hard to use shell/repl framework; once you whip it into shape it gives nice results especially with the readline backend
13:16:13 <monochrom> a^2 actually isn't Int either. Int or Integer or any Integral type.
13:16:15 <gwern> you kin find it on hackage obviously
13:16:16 <dons> dcoutts: ok. awesome. testing..
13:16:17 <monochrom> :t 1
13:16:18 <lambdabot> forall t. (Num t) => t
13:16:22 <monochrom> :t 1^2
13:16:23 <lambdabot> forall t. (Num t) => t
13:16:26 <monochrom> See?
13:16:28 <dcoutts> dons: thanks :-)
13:16:35 <benny99> :t 1**2
13:16:35 <lambdabot> forall t. (Floating t) => t
13:16:41 <dons> dcoutts: so i should pull these to the cabal repo, then rebuild cabal-install?
13:16:45 <benny99> > 2^100
13:16:46 <lambdabot>  1267650600228229401496703205376
13:16:47 <dcoutts> dons: yes
13:16:49 <filcab42> oh
13:16:53 <filcab42> thanks
13:17:03 <dcoutts> dons: next step is to add the other Setup.hs commands like configure, build etc. then add upload command too and you can add .tar.gz targets :-)
13:17:06 <hpaste>  Cale annotated "displaying a type" with "like this, but this is still a type error, because those aren't strings." at http://hpaste.org/4523#a4
13:17:24 <monochrom> But at least if you just get Num, you can still specialize it to Int. If you get Floating, you can't go back.
13:17:34 <dons> dcoutts: what's the url? http://haskell.org/~duncan/cabal/ doesn't work.
13:17:41 <dons> ah ,: )
13:17:42 <b_jonas> um,
13:17:47 <b_jonas> I think ^ can return any Num
13:17:57 <b_jonas> it's the power that has to be Integral
13:18:00 <b_jonas> :t ^
13:18:01 <lambdabot> parse error on input `^'
13:18:04 <b_jonas> :t (^)
13:18:05 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
13:18:12 <dcoutts> dons: the two cabal-(install)-command-line.dpatch files
13:18:13 <b_jonas> yep
13:20:04 <elad`> http://pastebin.com/d5f40ffda
13:20:09 <elad`> ERROR file:.\e.hs:23 - Ambiguous variable occurrence "show"
13:20:09 <elad`> *** Could refer to: Main.show Hugs.Prelude.show
13:20:29 <quicksilver> Does anyone have a copy of "Why It's Nice to be Quoted: Quasiquoting for Haskell", Geoffrey Mainland. Haskell Workshop 2007
13:20:30 <dons> dcoutts: ok. built and installed :)
13:20:42 <dcoutts> @arr
13:20:43 <lambdabot> Yeh scurvy dog...
13:20:46 <dons> quicksilver: yes. hardcopy?
13:20:50 <Heffalump> quicksilver: isn't it on his webpage?
13:20:54 <augustss> @seen heffalump
13:20:54 <lambdabot> heffalump is in #haskell and #darcs. I last heard heffalump speak 4s ago.
13:21:02 <Heffalump> augustss: nice timing :-)
13:21:07 <tphyahoo-haskell> @pl \f g xs -> map id (tail xs)
13:21:07 <lambdabot> const (const tail)
13:21:08 <augustss> yep
13:21:10 <quicksilver> Heffalump: google didn't find it if it is
13:21:21 <dons> augustss: how did jobs-in-fp go?
13:21:37 <augustss> Pretty good.  lots of people
13:21:38 <mauke> elad`: you redefined show
13:21:40 <Heffalump> quicksilver: you are exceptionally poor at using google ;-) http://www.eecs.harvard.edu/~mainland/publications/
13:21:42 <lambdabot> Title: Geoffrey Mainland: Publications
13:21:42 <quicksilver> dons: well I was after an electronic copy :) your hardcopy is a fair few miles from me
13:21:46 <dons> cool. i see 111 registered
13:21:52 <elad`> I menat to do that, mauke. Why doesn't that work?
13:21:55 <quicksilver> Heffalump: yay :)
13:21:59 <augustss> Yeah, it was packed
13:22:02 <mauke> elad`: you can't redefine things
13:22:16 <dons> augustss: awesome. we just need another 30 or so companies next time :)
13:22:34 <dons> a summary for the CUFP mailing list would be useful
13:22:51 <elad`> mauke, I was told to.
13:23:03 <mauke> by whom?
13:23:14 <elad`> Instructor.
13:23:25 <elad`> Can't show take either a Tree, a Colour or an Int?
13:23:25 <mauke> I think he wants you to define your own Show instance
13:23:29 * BMeph also does what the voices in his head tell him...
13:23:37 <dons> anyone looked at Sun's open source pdf renderer ?
13:23:51 <mauke> which show do you mean? the one in the Prelude takes any type that's an instance of Show
13:23:55 <elad`> mauke, possibly, but how do I do that? Could you refactor the appropriate line in my code? Shouldn't be much more than one line.
13:23:57 <mauke> the show in your source file takes a Tree
13:24:15 <mauke> elad`: instance (Show a, Show b) => Show (Tree a b) where show = ...
13:25:24 <pejo> augustss, CS still hiring?
13:25:52 <elad`> http://pastebin.com/d45f046c2
13:25:53 <elad`> Like so?
13:26:11 <augustss> pejo: yes
13:26:19 <BMeph> dons: Have you tweaked plugins for the 6.8.x base change?
13:26:25 <elad`> mauke?
13:26:37 <mauke> elad`: you need to indent the body more
13:26:43 <mauke> the stuff after "where"
13:26:53 <elad`> Thanks!
13:26:56 <benny99> got anybody a good idea for a "beginner-project" ?
13:27:07 <elad`> It works all the way now! Thanks a lot!
13:27:17 <tphyahoo-haskell> @pl  \f g xs -> map f ( g xs)
13:27:18 <lambdabot> (.) . map
13:27:18 <tphyahoo-haskell>   
13:27:18 <tphyahoo-haskell>    
13:27:20 <mauke> yay!
13:27:32 <benny99> is something like tetris actually very hard to do?
13:27:36 <quicksilver> Heffalump: hmm. This is a really good paper. Thanks for finding it for me :)
13:27:46 <benny99> quicksilver: what paper?
13:28:05 <benny99> got it, thanks :-[
13:28:06 <quicksilver> benny99: not at all, no, but you might spend some time wrestling with learning enough GUI + threads to make the general mechanics work.
13:28:13 <noj>  /j #ocaml
13:28:21 <quicksilver> depending on your previous expertise with that kind of stuff.
13:28:24 <noj> oops
13:28:34 <benny99> noj: heretic :O
13:28:39 <noj> sorry :/
13:28:58 <benny99> ;)
13:29:13 <benny99> quicksilver: well, I wanted to use something like SDL
13:29:21 <dons> noj: we're watching you!
13:29:41 <benny99> dons: are you canadian btw. :-[ ?
13:29:56 <dons> benny99: nope. why do you ask?
13:30:00 <noj> :)
13:30:06 <benny99> Cale: are you :-[ ?
13:30:14 <dons> Cale is. :-]
13:30:25 <dons> :E
13:30:31 <Cale> I'm Canadian
13:30:40 <benny99> Ah :o), you taught me how to use Monads once ago :)
13:30:48 <Cale> What's with the sad faces?
13:30:51 <benny99> eh, thanks again :-p
13:30:51 <Heffalump> aren't they nearly the same thing?
13:31:02 <benny99> it's an embarrassed face
13:31:05 <Cale> oh
13:31:06 <shachaf> Cale: ":-[" is an embarrased face, according to benny99.
13:31:08 * dons slaps Heffalump 
13:31:44 <benny99> shachaf: thanks :-]
13:31:46 <BMeph> dons: Have you tweaked plugins for the 6.8.x base change?
13:32:04 <dons> BMeph: nope. but i'd be happy for someone to send me the patches :)
13:32:18 <shachaf> dons: Hey, now, that's what we have the bot for. :-)
13:34:27 <dons> ?users #xmonad
13:34:27 <lambdabot> Maximum users seen in #xmonad: 103, currently: 101 (98.1%), active: 16 (15.8%)
13:34:34 * dons just likes to point this out ^ :D
13:34:49 <Heffalump> ?users
13:34:49 <lambdabot> Maximum users seen in #haskell: 441, currently: 436 (98.9%), active: 35 (8.0%)
13:35:09 <dons> oh, new high score.
13:35:26 * Cale is still waiting on an updated hs-plugins so he can recompile his lambdabot.
13:35:37 <dons> Cale, maybe just patch hs-plugins then?
13:35:44 <benny99> :)
13:35:52 <Cale> I have no idea what would be required or what's broken.
13:35:57 <dons> i'm not in a position to do the patches atm. there's nothing i need that requires it
13:36:05 <dons> its only slightly broken, wrt. imports
13:36:07 <dons> afaik
13:36:22 <Cale> ah, so it's not like the 6.4 -> 6.6 transition?
13:36:38 <dons> nope. much easier
13:36:43 <dons> no new .hi file, I think
13:36:56 <benny99> what did you do after you learned "the basics" ?
13:37:06 <Cale> benny99: Read papers :)
13:37:25 <tetha> REad papers and buil those things that are tagged with "mad project" in your head
13:37:29 <benny99> that is what I'm doing for years now (on many different programming languages)
13:37:47 <benny99> well, ok, I should specialize on haskell from now on :o
13:38:05 <tetha> languages are less important
13:38:10 <tetha> concepts are
13:38:26 <quicksilver> I used to think that, until I got the hang of haskell
13:38:29 <benny99> tetha: a map-compiler for quake3 levels ._.?
13:38:36 <quicksilver> now I believe languages are more important than I used to thnk :)
13:39:00 <tetha> quicksilver: well, languages are important because they ease the pain to create a certain concept, yes :)
13:39:04 <benny99> :-[ I looked at ~10 languages I guess
13:39:09 <tetha> benny99: why not? :)
13:39:09 <dons> and wrote code.
13:39:12 <dons> writing code is good!
13:39:15 <benny99> tetha: it takes time
13:39:29 <benny99> and I want something fancy and colorful now =D
13:39:33 <benny99> in a way ;)
13:39:36 <tetha> benny99: chatting here and searching for a project takes time, too :P
13:39:42 <Cale> Constructor `STArray' should have 4 arguments, but has been given 3
13:39:50 <benny99> tetha: yeah :|
13:40:02 <benny99> tetha: if you'd just tell me a perfect project, I wasn't :p
13:40:07 <hpaste>  Cale pasted "error building hs-plugins" at http://hpaste.org/4527
13:40:27 <tetha> benny99: create a thing that creates quake3-levels from an svg-like language
13:40:57 <Cale> Why is this code using the STArray constructor directly?
13:41:04 <hpaste>  BMeph annotated "error building hs-plugins" with "This works." at http://hpaste.org/4527#a1
13:41:21 <benny99> that sounds rather like nearly I/O stuff only -- I thought about a MUD
13:41:38 <benny99> but I really don't know where to start and why and stuff :(
13:41:42 <tetha> benny99: add comprehensions then
13:42:02 <Cale> Right, I remember getting to this point now...
13:42:12 <dons> Cale: right, so the FastString.hs changes need to be imported from ghc
13:42:16 <tetha> benny99: and variables. and functions. and... something fancy no one needs
13:42:19 <dons> the constructor has changes slightly
13:42:32 <Cale> dons: Ah, so just copy the file wholesale?
13:42:43 <codemac> Nah, do it for a bargain price!
13:42:44 <benny99> tetha: yeah , something nobody needs would be great :p
13:43:10 <tetha> benny99: or create some prolog-style-mapgeneration
13:43:26 <benny99> ok, Prolog and Mozart are those languages I skipped :(
13:43:36 <benny99> basically
13:43:36 <BMeph> Cale: They added a new argument to STArray construction, to specify the space to ask for, I think.
13:44:16 <dons> just check what FastString.hs in ghc does, on that code, and copy it :)
13:45:09 <benny99> well, I wonder whether I should try to do a plain simple generic raytracer
13:45:16 <benny99> does somebody know a good math lib?
13:45:41 <dons> Prelude ?
13:45:52 <dons> :)
13:45:59 <benny99> :o matrices etc. are buildin?
13:46:01 <dons> http://haskell.org/haskellwiki/Applications_and_libraries/Graphics#Ray_tracing
13:46:02 <lambdabot> http://tinyurl.com/3axmhe
13:46:11 <dons> no, you'd use hmatrix for that
13:46:28 <dons> http://hackage.haskell.org/packages/archive/pkg-list.html#cat:Math
13:46:29 <lambdabot> http://tinyurl.com/yqov7f
13:46:35 <benny99> oh... 1 million ray tracers
13:46:53 <dons> :)
13:46:58 <dons> what we need is more!
13:46:59 <dons> no.
13:47:04 <dons> what we need is more numerical libs
13:48:08 <benny99> I wonder whether I should really do that quake-map generator ._.
13:48:15 <benny99> is there no HBoost or HBlaise ?
13:48:26 <dons> boost is C++, so hard to bind to.
13:48:35 <dons> the abi is a bit under specified
13:48:43 <dons> you can bind to it via C though
13:48:57 <benny99> yeah, hm
13:49:10 <dons> same reason we don't have a Qt binding
13:49:21 <benny99> there are certainly many great C Math Libs too
13:49:35 <pippijn> you can do it.. but it's a lot of tedious trivial but hard to automatise work
13:49:37 <benny99> Qt is evil anyway :-[
13:49:43 <dons> if there's some area you're a domain expert in, wrapping up the best lib in your area is a great way to contribute
13:49:50 <BCoppens> benny99: why would Qt be evil
13:49:57 <benny99> I'm not an expert
13:50:21 <benny99> BCoppens: it feels strange :-[
13:50:29 <pejo> dons, is the C++-abi underspecified?
13:50:30 <benny99> BCoppens: no, my personal subjective opinion
13:51:00 <BCoppens> benny99: it's GPL, which is fine for me (the only problem is that it's GPLv2 only instead of +)
13:51:03 <pippijn> pejo: the symbol name translation is not defined
13:51:12 <BCoppens> benny99: yeah, evil usually is subjective :P
13:51:17 <pippijn> pejo: mangling
13:51:32 <dons> pejo: it would make a *great* project
13:51:38 <dons> improving the FFI to C++
13:51:50 <pippijn> dons: it would be trivial to do
13:52:06 <pejo> pippijn, wasn't the name mangling the main reason they broke ABI compatibility with gcc 3.0?
13:52:08 <dons> well, if its trivial, i'm waiting to see the code! :)
13:52:13 <pippijn> pejo: yep
13:52:24 <pippijn> dons: I am no haskell coder
13:52:38 <pippijn> dons: I am here to learn about functional languages
13:52:43 <pejo> pippijn, why did they change it then, if it's not specified?
13:52:50 <benny99> damn... I really can't find a C Math library :|
13:53:07 <pippijn> pejo: I don't remember the reason, but it was stupid and not necessary
13:53:18 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/4526#a1
13:53:33 <dons> pippijn: but if you're very familiar with low level C++ details, even an attempt at using the haskell C FFI to get to C++ would be useful!
13:53:46 <shachaf> "Use -XViewPatterns to enalbe view patterns" -- this has been in GHC for some time.
13:54:19 <benny99> ah, GSL, of course :)
13:54:19 <pippijn> dons: it would be supporting compilers instead of languages, though
13:54:25 <pippijn> dons: unless you have a c++ compiler on the system
13:54:35 <pippijn> dons: then we would just ask that compiler to mangle the names for us
13:54:47 <benny99> HGSL .... hm.. google.. Humble Girls Softball League (HGSL) ... hm :/
13:56:59 <shachaf> let v 0 = True; v _ = False; f (v -> True) = 'a'; f _ = 'b' -- Seems to work, but says that the pattern matches are overlapped. What should I do about that?
13:57:53 <benny99> http://perception.inf.um.es/~aruiz/darcs/hmatrix/hmatrix.pdf <-?
13:58:50 <dfranke> hmm...
13:58:53 <hashendgame> I've read that using lists for the monoid in a Writer monad is a bad idea because mappend is linear on lists. What's a better suggestion?
13:58:55 <dfranke> ?type show . read
13:58:56 <lambdabot> String -> String
13:59:08 <dfranke> How is GHC deciding what intermediate is used for reading and then showing?
13:59:14 <ddarius> hashendgame: Endo String
13:59:14 <dfranke> intermediate type*
13:59:21 <ddarius> dfranke: It doesn't.
13:59:39 <dfranke> ddarius: so what is it doing then?
13:59:46 <dons> dfranke: thats -fextended-defaulting at work, too
13:59:52 <dons> > show . read $ 1
13:59:52 <lambdabot>   add an instance declaration for (Num String)
14:00:02 <dons> > show . read $ "2"
14:00:03 <lambdabot>  "2"
14:00:17 <dons> ah no. just normal type system :)
14:00:23 <dons> sans magic defaulting
14:00:51 <dfranke> ?type read "2"
14:00:51 <lambdabot> forall a. (Read a) => a
14:02:23 <dfranke> I don't understand.  What instance's read method is getting invoked in show . read $ "2"?
14:03:22 <hashendgame> ddarius: so instead of type Logger = WriterT [LogEntry] IO (), I use Logger = WriterT (Endo [LogEntry]) IO () ?
14:03:38 <quicksilver> dfranke: whatever default you have set
14:03:40 <quicksilver> dfranke: typically, Integer
14:03:43 <mokus> > (show.read) "1000000000000000000000"
14:03:44 <lambdabot>  "1000000000000000000000"
14:04:52 <dfranke> so default actually has an effect at runtime, and not just on treatment of literals?
14:05:14 <augustss> it has nothing to do with literals
14:06:29 <augustss> But the defaulting you see above is not H98
14:07:01 <dons> yes, lambdabot uses -fextended-defaulting, which is also what ghci uses
14:07:33 <quicksilver> however, show . read $ "2" --~~-> "2" is h98, I believe?
14:07:35 <Cale> Heh, this would be a whole lot easier if they hadn't completely overhauled the FastString library :)
14:07:45 <dons> Cale: hmm
14:07:54 <Cale> It's coming along slowly
14:08:03 <quicksilver> the h98 defaulting rule is 'try a default type given any ambiguous type which only mentions Prelude type classes"
14:08:06 <quicksilver> I think?
14:08:28 <quicksilver> so since (Show a, Read a) are Prelude, it's OK to default?
14:09:15 <mokus> I thought the h98 rule was Num only?
14:09:20 <augustss> quicksilver: There's no mention of any numeric class so H98 defaulting does not apply
14:09:24 <Wild_Cat> newbie-ish question: does a "Tour of the Haskell standard library" kind of tutorial exist?
14:10:06 * Cale considers just copying the entire library from the GHC codebase and seeing what breaks from there...
14:10:31 <Cale> The FastString datatype has changed in structure, which means most of the code is very different.
14:10:44 <dfranke> an ambiguous type variable, v, is defaultable if:
14:10:46 <dfranke> * v appears only in constraints of the form C v, where C is a class, and * at least one of these classes is a numeric class, (that is, Num or a subclass of Num), and * all of these classes are defined in the Prelude or a standard library (Figures 6.2--6.3, pages -- show the numeric classes, and Figure 6.1, page , shows the classes defined in the Prelude.)
14:11:19 <davidL> How do I do runGet on a strict ByteString? Do I have to make it lazy first, using fromChunks?
14:11:35 <dons> davidL: yeah.
14:11:38 <dons> (its O(1) :)
14:12:19 <davidL> Why's it say O(c) in the haddock?
14:12:33 <dfranke> I thought it was a lot stricter than that.
14:12:46 <dfranke> i.e., only for interpretations of numeric literals and nothing else.
14:13:04 <Cale> davidL: c is a constant, isn't it?
14:13:37 <davidL> Cale: I guess, but I thought that always becomes O(1)
14:14:04 <Cale> davidL: Well, O(1) and O(c) where c is an arbitrary constant are equal classes of functions.
14:14:38 <ddarius> hashendgame: Yes.
14:14:56 <davidL> Cale: ah that makes sense
14:15:15 <Cale> davidL: But I suppose they wanted to indicate the dependence on the chunk size.
14:15:59 <Cale> If the chunk size was to change, then the runtime of the function would change in proportion to it (at least asymptotically)
14:16:25 <RayNbow> @src genericLength
14:16:25 <lambdabot> genericLength []    = 0
14:16:25 <lambdabot> genericLength (_:l) = 1 + genericLength l
14:16:34 <RayNbow> @src length
14:16:34 <lambdabot> Source not found. Maybe if you used more than just two fingers...
14:16:42 <shachaf> RayNbow: The dfference is in the type.
14:17:04 <RayNbow> I just wanted to confirm it :p
14:17:05 <shachaf> RayNbow: length returns an Int, so it won't work for long enough lists, or return lazy enough numbers, in some cases.
14:19:02 <quicksilver> mind you, if your list is longer than fits into an Int, something strange is happening :)
14:19:18 <shachaf> quicksilver: Well, the laziness can be an advantage too.
14:19:26 <benny99> quicksilver: it works anyway ._.! ?
14:19:49 <quicksilver> well the point is that ghc uses the native pointer type for Int
14:20:00 <quicksilver> so if you have a list longer than that, then it probably doesn't fit into memory..
14:20:11 <quicksilver> (not quite, though, because GHC does waste a bit or two)
14:20:33 <benny99> who wants a list longer than his memory anyway
14:21:10 <quicksilver> well you don't want to process one "all at once"
14:21:21 <quicksilver> but you might process one lazily over the course of a long running program...
14:21:38 <monochrom> I define my memory to be unbounded. Then no list is longer than my memory. :)
14:21:38 <quicksilver> however, you probably wouldn't call genericLenth on it :)
14:21:46 <quicksilver> because would rather defeat laziness
14:22:19 <shachaf> quicksilver: length l > 5 is nice.
14:22:23 <Saizan_> peano naturals ftw
14:22:25 <RayNbow> monochrom: like a Turing Machine's tape? :p
14:22:30 <monochrom> Yeah!
14:22:44 <shachaf> (Of course, you could just instance Num [a], probably.)
14:22:54 * RayNbow hasn't found a nice Turing Machine on eBay yet :/
14:22:57 <dons> the regex libs are in a bad way
14:22:58 <RayNbow> :p
14:23:07 <dons> they're what, unbuildable on 6.8?
14:23:13 <dons> too big, too soon :(
14:23:23 <monochrom> A Turing machine costs next to nothing. You don't find peanuts on ebay either. :)
14:23:30 * dons wants a single, strict bytestring / string-only, pcre regex lib. in a single module
14:23:55 <shachaf> dons: Text.Regex.Posix seems to work on 6.9.20071213.
14:23:59 <dcoutts> dons: as opposed to regex-base + regex-pcre?
14:24:16 <dons> yeah, and all the compat/posix gunk as well.
14:24:30 <dons> well, that's weird, i changed the build order, and the regex stuff went thought :(
14:24:48 <dons> ah, i know why:
14:24:48 <dons> $ cabal install regex-compat-0.71 --user
14:24:49 <dons> 'regex-base-0.92' is cached.
14:24:54 <dons> and then base-0.92 won't build
14:25:00 <dons> so i build base-0.7x.
14:25:04 <dons> then it goes though
14:25:25 <dons> i'd be wary adding a regex dep to a new project. :(
14:26:03 <Saizan_> does nhc support MPTCs?
14:26:42 <quicksilver> Saizan_: I believe not
14:27:58 <RayNbow> monochrom: do you know an address where I can buy a TM?
14:28:05 <RayNbow> preferably a multitape version :p
14:29:13 <elad`> I remember seeing an implementation of red black trees on the net, but I can't find it again. It was of that thingie by the famous guy with the Japanese last name, but American first name. Maybe Chris. Help?
14:29:23 <quicksilver> Okasaki
14:29:26 <dbueno> elad`: Okasaki.
14:29:54 <Cale> Okay, now I'm considering the possibility of making hs-plugins depend directly on ghc-as-a-library.
14:30:15 <elad`> Thanks. Anyhow, the implementation wasn't on his site. Any ideas?
14:30:16 <Cale> It's just way too annoying to copy these modules over with all their dependencies.
14:31:06 <Cale> Of course, that will mean it will depend on a particular minor version of GHC, but that's not *so* bad.
14:34:31 <Cale> I wonder how hard that's going to be...
14:35:59 <elad`> Found it! http://www.cs.kent.ac.uk/people/staff/smk/redblack/
14:37:55 <diltsman> Is there a way to replace the version of GHC that Visual Haskell uses?
14:39:26 <SamB> Cale: what do you mean it will depend on the particular minor version of GHC?
14:39:43 <Cale> er, oh, maybe not
14:40:06 <Cale> (I just noticed that the version was not actually part of the package name)
14:40:20 <SamB> heh
14:41:46 <Heffalump> diltsman: not easily, since it would need rebuilding, and some internal GHC data structures it uses have changed
14:42:16 <dcoutts> dons: do you know about xmobar? do you know if it has to use -threaded? That option is not available on all arches, like sparc.
14:42:19 <Cale> (well, it was complaining that certain modules existed in the package ghc-6.8.2 which was hidden -- the hyphenation being what tricked me :)
14:45:02 <hashendgame> I have a WriterT (Endo [Foo]) IO () that does some computation and generates a bit of a log. I'd like the log to appear as it is generated. if I get the output and try to mapM_ print aLog, it all comes out after the computation finishes. if I stick unsafeInterleaveIO in front of it, it never shows up because nothing seems to demand it. Any ideas?
14:45:38 <diltsman> Well, darn.  Does anybody actually maintain Visual Haskell?
14:46:17 <diltsman> Well, darn.  Does anybody actually maintain Visual Haskell?
14:46:53 <dons> dcoutts: i'm not sure if it requries -threaded. arossato is the author
14:46:55 <diltsman> Am I posting?
14:47:02 <pippijn> does anyone here know what rewriting logic is about?
14:47:17 <SamB> diltsman: if you were, you would be double-posting
14:47:28 <diltsman> Does anybody actually maintain Visual Haskell?
14:47:34 <dcoutts> arossato: ping
14:47:34 <SamB> triple!
14:47:39 <dcoutts> dons: thanks
14:48:07 <diltsman> Sorry, was having trouble with my IRC client.
14:48:59 <Cale> Is there a good portable way to check the machine word size?
14:49:10 <SamB> Cale: in what respect?
14:49:38 <SamB> i.e. why do you care?
14:49:56 <Cale> There's a CPP constant WORD_SIZE_IN_BITS in GHC which determines the binaryInterfaceMagic constant.
14:50:18 <diltsman> Ok, now that things seem to be working, would anybody mind telling me if Visual Haskell is actually maintained?
14:50:18 <mauke> sizeof (void *) * CHAR_BIT?
14:50:40 <SamB> Cale: and you can't use that?
14:50:58 <Cale> No, because I'm not actually hacking on GHC, but on hs-plugins.
14:52:07 <waern> Cale: try Bits.bitSize
14:52:35 <waern> on some type that represents a machine word :)
14:52:51 <dons> let always = flip finally -- :-)
14:53:10 <dons> diltsman: you'll need to check with the maintainers. i think it is only lightly maintained.
14:53:26 <Cale> aha, that seems to be defined directly as WORD_SIZE_IN_BITS, perfect :)
14:53:47 <Alneyan`> Cale: Thanks for working on hs-plugins! I'm pretty much in the same boat, except, well, I didn't dare to fiddle with the code.
14:53:55 <diltsman> dons: Thanks.  I'll do that.
14:54:28 <Gyde> doing a run of my program, I ran into this: Program error: pattern match failure: takeWhile1 (flip
14:54:44 <Gyde> and then it just spits out garbage for several lines
14:54:56 <Gyde> how can I figure out where things go wrong?
14:56:09 <dons> in hugs or ghc?
14:56:24 <dons> (i'd compile with ghc, since it will give you a line / column for the pattern failure)
14:58:20 <benny99> @t _|_
14:58:20 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
14:58:27 <benny99> @thanks
14:58:28 <lambdabot> you are welcome
14:58:40 <benny99> @time
14:59:15 <shachaf> @let _I_ = error "_|_"
14:59:17 <tphyahoo-haskell> @pl \f g xs -> map f ( g xs)
14:59:18 <lambdabot> Defined.
14:59:18 <lambdabot> (.) . map
15:00:23 <tphyahoo-haskell> @pl \f g xs -> map f ( g xs )
15:00:23 <lambdabot> (.) . map
15:00:48 <mauke> tphyahoo-haskell: what
15:03:07 <Cale> woot, it builds!
15:03:25 <Cale> I have no freaking clue as to whether it *works* :)
15:03:51 <jom> @pl f a b = b a
15:03:51 <lambdabot> f = flip id
15:04:28 <jom> @djinn q -> (q->r) -> r
15:04:28 <lambdabot> f a b = b a
15:09:02 <Cale> oy, Error in array index :(
15:09:32 <pippijn> can haskell apps crash?
15:09:38 <Cale> pippijn: sure.
15:09:43 <pippijn> segfault?
15:09:49 <roconnor> when you make an improper instance if Ix
15:09:51 <Cale> pippijn: Not without a compiler bug
15:09:53 <pippijn> undefined behaviour?
15:10:01 <roconnor> which is arguably a compiler bug
15:10:04 <Cale> There shouldn't be undefined behaviour.
15:10:15 <pippijn> in C and C++ it's easy to induce undefined behavior
15:10:21 <pippijn> in haskell I don't know of a way
15:10:27 <Cale> Yes, it's not easy in Haskell.
15:10:28 <DRMacIver> Cale: Or explicitly using unsafe operations?
15:10:52 <Cale> Well, yes, but that's in a similar realm as making modifications to the compiler.
15:10:54 <DRMacIver> unsafeCoerce could quite handily cause a segfault couldn't it?
15:10:58 <Cale> yes
15:11:09 <pippijn> coerce
15:11:12 <DRMacIver> So it's more of a feature than a bug. :)
15:11:13 <roconnor> bad instances if Ix is probably the best way to get GHC to segfault
15:11:27 <pippijn> roconnor: ghc?
15:11:41 <pippijn> roconnor: or the code generated by ghc?
15:11:47 <benny99> >  take (head (tail [1..])) [1..]
15:11:48 <lambdabot>  [1,2]
15:11:59 <roconnor> code generated by GHC
15:12:14 <pippijn> right
15:13:15 <Cale> If we're talking about GHC specific bugs, there are things like types which cause GHC not to terminate.
15:13:34 <Cale> (or at least there were, I haven't checked in a while)
15:13:38 <pippijn> hmm
15:13:47 <pippijn> endless loops
15:14:16 <Cale> Haskell programs can fail to terminate, and they can make calls to error and undefined, which cause the program to die.
15:14:29 <Cale> (but it dies relatively cleanly)
15:14:43 <pippijn> right
15:14:51 <mokus> there are various ways a haskell program can fail to do what it's supposed to - making the RTS crash is a bit rarer
15:18:02 <todizz> im making a function that takes a list of prime numbers and determines the next prime and returns a list with it included
15:18:12 <todizz> it returns a parse error in ghci
15:18:22 <todizz> include List
15:18:22 <todizz> findNextPrime :: [Integer] -> [Integer]
15:18:22 <todizz> findNextPrime [] = [2]
15:18:22 <todizz> findNextPrime [2] = [2,3]
15:18:22 <todizz> findNextPrime known = (until (\y -> all (\x -> (mod y x) /= 0)) (+1) (last (sort known))) : known
15:18:32 <BMeph> Cale: Doesn't just putting the extra "_" in the pattern for FastString work for you? In hs-plugins, I mean.
15:18:33 <dibblego> ?where primes
15:18:33 <lambdabot> I know nothing about primes.
15:18:38 <benny99> might me a stupid question
15:18:44 <shachaf> todizz: You can't type functions into ghci like that.
15:18:47 <benny99> but how does "curry" work again?
15:18:55 <dibblego> ?where+ primes http://haskell.org/haskellwiki/Prime_numbers
15:18:55 <shachaf> todizz: You have to load a file or use let.
15:18:55 <lambdabot> I will remember.
15:18:57 <todizz> shachaf: i didnt
15:19:04 <todizz> its from a .hs file
15:19:04 <benny99> > curry (\x y -> x / y) 1 2   <-- does not work :-[
15:19:05 <lambdabot>  Parse error at end of input
15:19:11 <dibblego> ?type curry
15:19:12 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
15:19:17 <shachaf> todizz: Oh, import, not include.
15:19:27 <shachaf> todizz: (And that should probably be Data.List.)
15:19:37 <dibblego> ?djinn ((a, b) -> c) -> a -> b -> c
15:19:38 <lambdabot> f a b c = a (b, c)
15:19:49 <byorgey> > curry (\(x,y) -> x / y) 1 2
15:19:49 <todizz> shachaf: thanks
15:19:51 <lambdabot>  0.5
15:20:00 <byorgey> > uncurry (\x y -> x / y) (1,2)
15:20:01 <lambdabot>  0.5
15:20:11 <Cale> BMeph: I didn't try that exactly, but enough of the FastString interface and implementation had changed that it seemed not worthwhile to proceed in that fashion. Instead, I added a dependency on ghc-as-a-library and imported its FastString. I've finally gotten all that to compile, but now I'm getting the infamous Array index out of bounds error.
15:20:21 <dibblego> > curry (uncurry (/)) 1 2
15:20:22 <lambdabot>  0.5
15:20:22 <benny99> ah, thanks :)
15:20:39 <benny99> and how to read those types again :-[ ?
15:20:43 <benny99> @type curry
15:20:44 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
15:20:52 <dibblego> benny, what language are you used to?
15:20:52 <benny99> I guess I just understood, that I didn't understood them
15:21:01 <dibblego> benny99, *
15:21:05 <benny99> C++ for example
15:21:11 <benny99> and scheme
15:21:16 <benny99> a bi
15:21:17 <benny99> t
15:21:21 <dibblego> a, b and c are just type arguments
15:21:24 <BMeph> Cale: When using hs-plugin by itself, when compiling it, or when compiling something else to use plugins?
15:21:27 <shachaf> @ty curry (flip uncurry)
15:21:27 <lambdabot> forall a b c. a -> b -> (a -> b -> c) -> c
15:21:56 <dibblego> you might read it as "given a function that takes a pair of a and b and returns a c, return a function that takes an a and returns a function that takes a b and returns a c"
15:21:59 <Cale> BMeph: using the testsuite/eval/eval1 example
15:22:17 <Cale> (when running that)
15:22:37 <BMeph> Cale: Ah, I'll try that myself...
15:22:54 <benny99> dibblego: ok, thanks :)
15:23:04 <Cale> BMeph: If you want, I can give you my copy of hs-plugins as presently modified.
15:23:15 <benny99> it's the "lambda-application-way" then
15:23:28 <BMeph> That works - then I can compare hacks. ;)
15:25:28 <Cale> http://cale.yi.org/autoshare/hs-plugins.tar.bz2
15:25:57 <ac> In building a Scheme evaluator, if I do away with "set!" from my primitives I can get away without storing variables in the environment, right?
15:26:45 <Cale> ac: I think so, you should just be able to use the substitution model.
15:27:01 * ac is tempted. Dealing with frames is a pain
15:27:59 <Cale> ac: then you can implement monadic IO :)
15:28:13 <ac> Cale: heh. Not exactly what I had in mind
15:28:39 <Cale> Just record IO actions as pure data structures, and have a runtime system which evaluates one of them and then carries out the instructions it describes.
15:28:51 <ac> Cale: I already have that
15:28:58 <ac> Cale: stdin and stdout are part of the environment
15:29:22 <Cale> Well, that's essentially the idea of monadic IO -- apart from the actual "being a monad" bit.
15:29:31 <ac> Cale: and all primitives take an environment and return them. They're of type: [Expr] -> Env -> (Expr, Env)
15:29:49 <ac> Cale: ah. I thought you meant do something fancy within the evaluated language
15:30:03 <Cale> Ah, that's a little different.
15:30:14 <Cale> Here, you'd hide the environment.
15:31:04 <Cale> and just have your IO primitives be essentially inert (under evaluation) values which represent actions like "get a character from input" and so on.
15:31:25 <ac> I don't really have anything against storing variables in the environment, it just seems terrible to me to copy ALL variables for every lambda (I know that it's not necessary, but it's the easiest to implement)
15:33:00 <Cale> Well, with Haskell datastructures, you likely won't make copies of things except where there's modification, because datastructures naturally share parts.
15:33:38 <Cale> For example, if your environment is a Data.Map, then you only end up copying logarithmically many nodes when you make a change.
15:34:14 <Dr_Foo> I'm having trouble with my linker. Whenever I try to compile a program that depends on 3rd party libraries, I get messages like this: (.text+0x7bb): undefined reference to `csvzm0zi1zi1_TextziCSV_printCSV_closure'. Is there some magic environment variable I need to set to get the linker to look in the right place?
15:34:22 <Dr_Foo> Hi, by the way :)
15:34:30 <mauke> have you tried ghc --make?
15:34:41 <Cale> Dr_Foo: yeah, probably you just need --make
15:34:48 <Cale> Or an explicit -package parameter
15:35:08 <Dr_Foo> Yes that worked, thanks.
15:36:02 <benny99> I never saw somebody that had serious problems with ghc :o
15:36:09 <ac> Cale: so even if my environment (which is a Data.Map as it happens) is in many Exprs, only the parts that are different are copied?
15:36:39 <mauke> having no mutable objects means zero copying
15:37:13 <ac> right. I guess if insert is going to happen in any reasonable amount of time, there can't be too much work there either
15:37:32 <ac> my environment is actually a list of maps
15:37:49 <ac> with the closest scope being the head of the list of course
15:38:08 <ddarius> mauke: For a misleading definition of copying.
15:38:17 <Cale> ac: Right, only the path up to the root gets "copied"
15:38:18 <mauke> yes!
15:39:11 <ac> But still, this "set!" is offensive to me. That one primitive adds a lot of complexity to the evaluator
15:39:42 <shachaf> ac: "lambda" also adds quite a bit of complexity. :-)
15:40:10 <ac> shachaf: that is necessary complexity. I hardly use set!
15:40:23 <Korollary> ac: You can also go directly to machine code if you don't mind: http://scheme2006.cs.uchicago.edu/11-ghuloum.pdf
15:40:33 <shachaf> ac: Not necessary as such. :-)
15:40:48 <ddarius> ac: If you use a monadic style for your interpreter you should be able to make such changes relatively locally.
15:41:21 <ac> ddarius: you mean to have variables in the environment and to not have them?
15:41:27 * dons pronounces the storage manager as pretty good :) 
15:41:37 <dons> mmap 6523641 files, but don't use them. constant space. :)
15:41:38 <SamB> shachaf: you could just use define, sure
15:41:58 <SamB> shachaf: but isn't let defined in terms of lambda or something?
15:42:05 <ddarius> Why are you mmapping 6523641 files?
15:42:08 <dons> so guys. i'm packaging up the mmap bindings for bytestrings
15:42:15 <dons> i'm looking for interesting tests of the behaviour we can expect
15:42:29 <ddarius> ac: Huh?
15:42:30 <shachaf> SamB: I was thinking of s and k.
15:42:39 <SamB> shachaf: um...
15:42:42 <dons> any suggestions of other runtime properties i should expect of an mmap binding?
15:42:54 <ac> ddarius: I was asking wath you meant by "such changes"
15:43:21 <ddarius> ac: Oh.  Then yes.  Adding mutable state will be a relatively local change etc.
15:45:20 <ac> ddarius: I suppose. When I add mutable state then I need to add support for closures in lambda expressions. That's mainly what I'm complaining about
15:45:42 <ac> AFAIU, by adding mutable state you then need two representations of lambdas
15:45:55 <ddarius> Huh?
15:46:03 <augustss> huh, indeed
15:46:05 <ac> My understanding is probably wrong
15:46:25 <Cale> dons: So, after finally getting hs-plugins to compile, I'm stuck with an Array index out of bounds error :)
15:46:38 <dons> Cale: ok, so that could be an .hi file format change
15:47:02 <augustss> mutable state is not that hard.  variables no longer refer to values but to references; references are looked up in the state before use
15:47:05 <Cale> I've replaced most of Language.Hi with ghc-as-a-library stuff.
15:47:32 <Cale> But I'm not sure if there are corresponding pieces for the rest.
15:47:47 <Cale> (as I don't really know what I'm doing :)
15:47:58 <ac> what I mean is that a lambda expression needs to contain the variables that were used in it. With mutable state you have to have a copy of your environment there, but without it, the lambda can just be reduced to another expression
15:48:31 <ac> that was poorly described, because either way it's reduced to an expression
15:48:36 <augustss> sure, state adds complexity
15:48:47 <augustss> i totally agree with that
15:49:03 <ddarius> Of course it does.  It is a definite increase in expressiveness.
15:49:37 <benny99> bye :)
15:49:56 <ac> ddarius: and what does it allow me to express easily (in the domain of my toy language here)
15:50:11 <ddarius> ac: State?
15:51:36 <augustss> ac: if you have a strict language you can show that certain algorithms run faster with mutable state than without.  (I don't know if it has been shown for lazy languages too).
15:51:38 <Cale> hmm, I wonder if Parser can directly be replaced with BinIface
15:52:49 <ac> augustss: Ah. What I meant by needing two representations of lambdas is that I have a primitive Expr type for things like "+" and "define", and "lambda". With mutable state I need to store the environment in a lambda expression, so I need to add a new Expr type for just lambda
15:53:34 <augustss> ac: you'll need closures to represent values of function type, yes
15:53:46 <ac> but I shouldn't have said "two representations"
15:54:12 <ac> because a lambda expression can originally be simply one with an empty closure
15:55:21 <ac> having two was an artifact of my implementation
15:57:17 <dcoutts> dons: did kolmodin say? xmonad +contrib +xmobar is in portage, now all you have to do is emerge xmonad
15:58:07 <dons> dcoutts: yes, i have the news! i'll put an announce out :)
15:58:11 <shachaf> dcoutts: You don't need xmobar for xmonad. :-)
15:58:13 <dons> yaya :)
15:58:44 <dcoutts> shachaf: I know, but it's a handy extra
15:59:18 <shachaf> dcoutts: No more than dzen, I think. It's not really related, except for by name.
16:01:00 <dcoutts> and it also being in haskell and commonly used together
16:02:08 <Feuerbach> How can I use infinite-precisiob Integer-s? GHC complains that Integer does not match Int (numeric literals)
16:02:28 <shachaf> Feuerbach: Which functions are you using?
16:02:30 <dcoutts> Feuerbach: numeric literals can be of any Num type
16:02:45 <shachaf> Feuerbach: Some functions (like length) always use Ints, and have generic versions in Data.List.
16:03:52 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/bytestring-mmap-0.1.1
16:03:53 <lambdabot> http://tinyurl.com/26xdk4
16:05:10 <Feuerbach> here is it: http://hpaste.org/4529
16:06:21 <Feuerbach> so, I need Int to be the index of the list, right?..
16:06:34 <ac> there's no such thing as a "closure" in Haskell, is there?
16:07:04 <ddarius> "closure" is an implementation term.
16:07:51 <ac> well, the concept or term never occurs to me when writing Haskell, and I use them frequently in JavaScript and Scheme
16:08:22 <BMeph> Feuerbach: If you used "`genericIndex`" instead of "!!", you'll be fine. :)
16:08:56 <ac> you could even say "let (!!) = genericIndex ..." right?
16:09:53 <dcoutts> dons: yay, for mkcabal 0.3
16:10:10 <dcoutts> dons: any trouble so far with cabal-install?
16:10:16 <MyCatVerbs> :t genericIndex
16:10:16 <Gyde> if I use instance show to show how a structure of (tubles) in a binary tree, can I then sort the output in anyway?
16:10:17 <lambdabot> forall b a. (Integral a) => [b] -> a -> b
16:10:18 <dcoutts> Lemmih: did you try it?
16:10:19 <Cale> any ghc hacker who would happen to know what the relevant "empty" value for ModIface would be?
16:10:21 <dons> dcoutts: nothing yet.
16:10:34 <dcoutts> good good
16:10:35 <Cale> (I'm in a little over my head here ;)
16:10:40 <MyCatVerbs> > (repeat 1) !! 500
16:10:41 <lambdabot>  1
16:10:44 <MyCatVerbs> > (repeat 1) !! 5000
16:10:44 <lambdabot>  1
16:10:49 <BMeph> ac: Yeah, that's legal. :)
16:10:54 * MyCatVerbs wonders how long \bot will evaluate something for.
16:10:57 <MyCatVerbs> > (repeat 1) !! 500000
16:10:57 <lambdabot>  1
16:11:04 <MyCatVerbs> > (repeat 1) !! 50000000
16:11:05 <lambdabot>  1
16:11:17 <ac> BMeph: cool
16:11:18 <MyCatVerbs> ...tell me that's not O(1). oO
16:11:21 <MyCatVerbs> > (repeat 1) !! 5000000000
16:11:24 <lambdabot>  1
16:11:30 <SamB> ac: closures are things that combine a piece of code with the variables that are free in it...
16:11:31 <MyCatVerbs> > (repeat 1) `genericIndex` 5000000000
16:11:38 <lambdabot> Terminated
16:11:42 <MyCatVerbs> > (repeat 1) `genericIndex` 500000
16:11:43 <lambdabot>  1
16:12:07 <shachaf> > repeat 1 !! 500000 -- :-)
16:12:08 <lambdabot>  1
16:12:10 <EvilTerran> @help @run
16:12:11 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:12:15 <EvilTerran> @help run
16:12:15 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
16:12:17 <Cale> er... maybe that's impossible...
16:12:21 <EvilTerran> there we go. that's how long.
16:12:30 <Dr_Foo> @quote qwe1234
16:12:30 <lambdabot> qwe1234 says: never heard of malbolge before, but i'd think that writing a simple source-to-source translator from some sort of minimal vm assembly to malbolge shouldn't be too difficult.
16:12:37 <SamB> every non-toplevel function, every partially applied function, every postponed expression...
16:13:25 <olsner> "shouldn't be too difficult", heh... wasn't malbolge the language that required cryptoanalysis to even make a hello world program?
16:13:46 <SamB> actually I think GHC considers every heap object to be a closure ;-)
16:13:48 <ac> SamB: but if no variable ever changes, you don't need to bother to attach variables to a piece of code
16:14:06 <SamB> ac: well, in Haskell we just pass the values
16:14:16 <ddarius> ac: You don't necessarily, but it's usually more efficient to.
16:14:30 <ac> right. I'm not even going to think about what happens under the hood
16:14:41 <hpaste>  BMeph annotated "integer" with "Thanks to ac..." at http://hpaste.org/4529#a1
16:14:45 <MyCatVerbs> olsner: not quite, I think the cryptanalysis was needed for the language's first while loop, rather than the "Hello World" algorithm. :)
16:15:26 <olsner> hmm, perhaps it was just "bloody hard" and not really cryptanalysis then :)
16:16:01 <SamB> noteventime: if a non-toplevel function doesn't have any non-toplevel free variables, it may get floated out, etc.
16:16:05 <SamB> erg.
16:16:17 <SamB> that was supposed to say "note:"
16:16:24 <noteventime> :-)
16:16:45 <MyCatVerbs> olsner: no, it was cryptanalysis. :)
16:16:47 <SamB> you may wish to change your nickname before I do it again
16:17:26 <ac> SamB: you must be using irssi, or some other irc client with tab completion
16:17:39 <SamB> I'm pretty sure I didn't actually hit tab
16:17:52 <SamB> noteventime: testing
16:17:52 <MyCatVerbs> olsner: but IIRC it was required to work out how to implement loops and conditionals, rather than to get "Hello world" going. (Hello world was also, of course, near-infinitely difficult.)
16:18:03 <SamB> yeah, x-chat automatically replaced it when I hit enter...
16:18:14 <ac> hah. lame
16:18:23 <MyCatVerbs> Wow. Did qwe1234 actually say that?
16:18:24 <noteventime> note: Testing as well
16:18:26 <ddarius> Sa: really
16:18:32 <SamB> hmm.
16:18:38 * ddarius thinks SamB is crazy.
16:18:40 <SamB> I changed something...
16:18:42 <noteventime> SamB: Not here :-S, anyway, doesn't matter
16:18:43 <SamB> note: testing
16:18:48 <SamB> okay, I fixed it
16:18:49 <noteventime> I think I can survive :-)
16:18:51 <noteventime> ok
16:18:52 <MyCatVerbs> EvilTerran: ah, thanks. My curiosity sated. :)
16:18:58 <SamB> I had checked that automatic nick completion box...
16:19:01 <EvilTerran> :)
16:19:05 <allbery_b> yeh, xchat has interesting completion behavior, thankfully disableable
16:19:19 <olsner> malbolge is quite possibly the most evil language I've seen thus far
16:19:31 <ac> olsner: have you seen PHP?
16:19:35 <allbery_b> heh
16:19:55 <noteventime> olsner: Haha :-D
16:20:23 <noteventime> ac: ;) It's even worse
16:20:28 <ac> how could it possibly be evil? What bad does it bring upon the world? PHP on the other hand...
16:20:52 <todizz> brainf*ck is worse
16:20:54 <SamB> okay, x-chat mysteriously disappeared. I guess it probably crashed...
16:20:57 <MyCatVerbs> todizz: no it isn't.
16:21:00 <SamB> note: testing again
16:21:03 <ac> todizz: brainfuck is easy
16:21:05 <noteventime> todizz: Malbolge is worse than brainf*ck :-)
16:21:06 <SamB> okay, still set. good...
16:21:18 <MyCatVerbs> todizz: brainfuck doesn't work in trinary, for one thing. :)
16:21:22 <BMeph> @remember evil <olsner>  malbolge is quite possibly the most evil language I've seen thus far <ac> olsner: have you seen PHP?
16:21:22 <lambdabot> Okay.
16:21:33 <todizz> i stand corrected
16:21:34 <SamB> MyCatVerbs: HOW do you know that?
16:21:53 <ac> yay, I got quoted
16:21:59 <olsner> ac: if malbolge was as ubiquitous as PHP, how damaged wouldn't the world be?
16:22:05 <MyCatVerbs> todizz: you can write a compiler targetting brainfuck with only finite quantities of effort. Unlike malbolge, which required cryptanalysis to even work out how to implement a while loop.
16:22:18 <ac> olsner: that's the thing it's not. PHP is actually useful, which causes people to use it, and hence evil is done
16:22:19 <ddarius> olsner: Very since software would still not get written in it.
16:22:20 <MyCatVerbs> SamB: I read the language description ages ago.
16:22:22 <SamB> MyCatVerbs: brainfuck doesn't use any particular representation of numbers
16:22:43 <SamB> it COULD have been using ternary all these years without you knowing
16:22:58 <noteventime> ac: It's like Chaotic evil (malbolge) vs. Lawful evil (PHP)
16:23:11 <ac> SamB: that doesn't make sense. Brainfuck is a language, not an implementation
16:23:26 <SamB> ac: yeah, yeah...
16:23:29 <ac> SamB: ;-)
16:23:52 <SamB> but if I wrote a brainfuck spec that specified ternary, it would still work...
16:23:55 <ac> just had to say that, as people have said that to me, with s/Brainfuck/Haskell/
16:24:27 <olsner> intercal actually defines operations in terms of trinary arithmetic and trits ;-)
16:24:28 <mokus> brainfuck increments and decrements numbers - that works in pretty much any baso
16:24:41 <SamB> worse, is malbolge even known turing complete yet?
16:25:06 <SamB> I guess what I meant was "what difference would it make if it did?"
16:25:30 <ac> todizz: just the other day we were discussing how brainfuck is more understandable than turing machines, which are far from elegant
16:25:47 <MyCatVerbs> SamB: yes, but it doesn't force you to write your programs out in ternary. :)
16:25:59 <SamB> true
16:26:10 <MyCatVerbs> SamB: it also doesn't decode instructions based on their addresses mod 94. oO
16:26:20 <todizz> ac: ive never actually used brainfuck it just seemed hard
16:26:30 <ac> todizz: give it a shot. It's a blast
16:26:30 <SamB> it doesn't even instruction addresses
16:26:38 <ddarius> brainfuck is simple but tedious.
16:26:38 <mokus> brainfuck is easy, it's just hard to do anything useful with it
16:26:39 <SamB> I don't actually use it either
16:26:41 <todizz> ac: would i need to know assembly
16:26:46 <SamB> because it looks kind of boring
16:26:46 <ac> todizz: not at all
16:27:13 <ddarius> todizz: Learning assembly instead would probably be more enjoyable, more useful and more interesting though.
16:27:25 <ac> todizz: I agree with ddarius
16:27:40 <olsner> ditto
16:27:51 <todizz> ddarius: would it be more difficult to learn on amd64 processor?
16:27:52 <ac> todizz: but learning brainfuck would be a hell of a lot easier (it would consume all of about 5 minutes)
16:28:15 <dfranke> There's something very Heisenbergesque about doing random number generation inside unsafeInterleaveIO.
16:28:30 <ddarius> todizz: More difficult than?
16:28:38 <todizz> 32 bit
16:28:52 <ddarius> They should be about comparable.
16:28:55 <Nafai> DRMacIver: Around?
16:28:56 <SamB> dfranke: using the non-threadsafe routines?
16:28:59 <DRMacIver> Yes
16:29:05 <ddarius> Other than available educational resources.
16:29:06 <todizz> i guess ill need to take another look at it
16:29:29 <ac> todizz: at brainfuck or assembly? I have a few brainfuck programs on hand if you're curious
16:29:34 <DRMacIver> Nafai: What's up?
16:29:36 <todizz> yeah the lack of resources is what has stopped me in the past
16:29:41 <Nafai> DRMacIver: I liked your latest blog post.  I was the one who just quoted you relative to "I've written too much Java to not like static typing." on reddit
16:29:41 <ddarius> @quote bf
16:29:41 <lambdabot> erg0t says: <erg0t> @bf  ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.   <lambdabot>  Hello World!
16:29:43 <olsner> dfranke: sounds like C programming...
16:29:43 <SamB> todizz: especially if you are learning only the stuff that is actually USED ...
16:29:45 <dfranke> SamB: this is a single-threaded program so it doesn't really matter, but is System.Random.randomIO non-threadsafe?
16:29:48 <DRMacIver> Ah, so I see.
16:29:53 <DRMacIver> Hi
16:29:54 <noteventime> Does brainfuck have a FFI? :-D
16:29:57 <ddarius> Isn't AMD64 just x86 with some 64-bit registers and such.
16:29:58 <ddarius> ?
16:30:03 <SamB> ddarius: it's a bit less
16:30:11 <SamB> and possibly also a bit more
16:30:18 <SamB> I'm not sure about the "more" part
16:30:34 <SamB> but anyway, the segmentation is virtually gone
16:30:36 <DRMacIver> (Sorry, didn't connect the nick)
16:30:45 <Nafai> DRMacIver: That's okay. :)
16:30:50 <ddarius> todizz: You should be able to use any x86 resource as a start.
16:31:06 <SamB> dfranke: well, unless it uses an MVar...
16:31:38 <dfranke> SamB: I'm just using the system standard generator.  I'll check out the source and see how it works.
16:31:45 <SamB> todizz: anyway, learn i386 first since there's more resources for that...
16:31:48 <Nafai> DRMacIver: I'm glad I'm not the only one who feels the same way about Java's type system.  I was used to dynamic programming languages like Python before I had to use Java and I just didn't understand what it bought me, other than some nice tools.
16:32:04 <ddarius> I like the old 16-bit Art of Assembly.
16:32:10 <Nafai> DRMacIver: Learning Haskell is teaching me the value of static typing, and making me wish I didn't see NullPointerExceptions
16:32:18 <ac> todizz: I would point you to my own page on brainfuck, but Wikipedia's is much better now. There're a ton of resources on brainfuck ;)
16:32:24 <dfranke> SamB: but even if this program is multithreaded in the future, it's not going to use randomness in any other place.  I'm just generating an infinite stream of UUIDs and sticking them in a reader monad.
16:32:36 <todizz> ac: i was just looking at wikipedia
16:32:38 <DRMacIver> Nafai: Java's type system is basically universally reviled by people who know what they're doing. (And I'm perfectly willing to "no true scotstman" that statement into a tautology if I have to!) :)
16:32:48 <SamB> dfranke: reader?
16:33:13 <mokus> DRMacIver: hear, hear!
16:33:27 <SamB> yeah, DRMacIver is right.
16:33:33 <SamB> (Java has a typesystem?)
16:33:33 <Nafai> DRMacIver: My boss was advocating it as giving you so much more safety and such versus a language like Python.
16:33:44 <Nafai> DRMacIver: But heck, I kept seeing so many holes I didn't understand
16:34:00 <DRMacIver> Despite my little bit of static typing advocacy I'm actually ok with dynamically typed languages.
16:34:16 <DRMacIver> I prefer statically typed ones, but I really hate *bad* statically typed ones. :)
16:34:20 <MyCatVerbs> ddarius: I'm informed that AMD64 is rather RISC-ish.
16:34:22 <SamB> yeah.
16:34:27 <dfranke> SamB: yeah.  I generate the stream in IO, then I'm going to use it as state for a Reader.
16:34:34 <SamB> at least use monotypes if you are going to use puny types!
16:34:35 <MyCatVerbs> ddarius: (in addition to having twice as many registers, and so on)
16:34:42 * mokus likes dynamically typed languages, and statically typed languages - it's the in-betweeners that freak me out
16:34:44 <Nafai> DRMacIver: Yes, I agree.
16:34:45 <SamB> dfranke: reader doesn't have state
16:34:47 <SamB> maybe you want State
16:34:59 <davidL> What's the difference between newtype and data? From what I've read, newtype does not have the "overhead" that data does (no idea what this means). Also when do I use newtype instead of data?
16:35:35 <SamB> davidL: newtype makes a new type with the same representation as an old one
16:35:41 <ddarius> davidL: Read the page in the Gentle Introduction.
16:35:47 <dfranke> SamB: I'm pretty sure Reader will do what I need.  State would work too.
16:35:54 <SamB> davidL: so... you can only have one constructor with one field in a newtype
16:36:06 <SamB> dfranke: it doesn't have anything resembling state
16:36:12 <davidL> ddarius: I did, that's where I got the "overhead" thing from, but what overhead is it talking about?
16:36:53 <dfranke> SamB: the stream is the environment, and when I want to get a UUID, I take the head of the stream, then execute the rest of my computation with the tail as its environment.
16:37:32 <SamB> that sounds a bit inflexible
16:38:43 <ac> is there anything interesting you could do by storing more than just variable bindings in a closure?
16:38:56 <DRMacIver> ac: How do you mean?
16:39:15 <ac> DRMacIver: like other parts of my environment (currently that would be just stdin and stdout). I can't think of any reason to
16:39:39 <DRMacIver> Aren't stdin and stdout still just variable bindings?
16:39:48 <ac> DRMacIver: no, they're the actual streams
16:39:50 <Korollary> davidL: http://www.haskell.org/haskellwiki/Newtype
16:39:51 <lambdabot> Title: Newtype - HaskellWiki
16:40:52 <DRMacIver> ok. But what does it mean to store an "actual stream" in a closure? And how is it different from how you'd normally refer to stdin and stdout in the language?
16:40:54 <SamB> ac: are you thinking along the lines of dynamic variables?
16:41:08 <ac> DRMacIver: they could be simply variable bindings, but then I'd have to be able to represent a stream in an expression, which I can't do. I only have integers and bools so far
16:41:25 <DRMacIver> Oh, I see.
16:41:29 <davidL> is -XGeneralizedNewtypeDeriving new to GHC 6.8?
16:41:36 <ac> DRMacIver: so stdin and stdout are special
16:41:51 <mrd> davidL: i think it was just in glasgow-exts before
16:41:51 <ac> SamB: what's a dynamic variable?
16:41:58 <DRMacIver> Ok. So this is for some specific language you're creating rather than a general purpose question?
16:42:07 <atp> hey, is withFile a recent addition to GHC?
16:42:17 <davidL> thanks mrd and Korollary
16:42:18 <ac> DRMacIver: yeah
16:42:24 <DRMacIver> Ok. Makes sense now. :-)
16:42:26 <atp> i see it in the documentation but when i import System.IO ghci complains that the function isn't exported
16:42:27 <shachaf> davidL: Yes, but 6.6 had it, just under a different name.
16:42:30 <SamB> atp: never heard of it before
16:42:41 <ac> DRMacIver: I've been talking about it for the last two days
16:42:42 <shachaf> (Or no name, as mrd says.)
16:42:46 <atp> SamB: it just opens a file, does something with it, and closes it
16:42:49 <SamB> that is, not in the context of things that exist
16:42:50 <atp> :t withFile
16:42:51 <lambdabot> Not in scope: `withFile'
16:42:55 <atp> hm
16:43:04 <atp> :t System.IO.withFile
16:43:04 <lambdabot> Not in scope: `System.IO.withFile'
16:43:09 <atp> how strange
16:43:14 <DRMacIver> ac: I don't think I've been paying much attention to IRC over the last few days. :)
16:43:33 <SamB> atp: lambdabot doesn't have the latest GHC either
16:44:10 <atp> http://haskell.org/ghc/docs/latest/html/libraries/base/src/System-IO.html#withFile
16:44:10 <lambdabot> http://tinyurl.com/2wxtb3
16:44:18 <atp> it's a trivial function
16:44:24 <atp> i guess maybe it's not in my version of GHC...
16:44:42 <atp> i'll just copy it into my module for now then i guess
16:46:57 <SamB> yeah, it is pretty short
16:53:01 <todizz> anybody do project euler here?
16:53:15 <Nafai> Yeah
16:53:25 <todizz> what language do you use
16:53:31 <Nafai> Haskell
16:54:25 <todizz> Is it a good language for most of the problems?
16:54:31 <todizz> I just started yesterday
16:55:05 <todizz> And I still have a bit of haskell to learn
16:55:46 <Nafai> I think so
16:55:53 <Nafai> I'm using Project Euler to learn Haskell myself.
16:55:57 <dons> dcoutts: any thoughts on how we can clean up the crazy categorisation/typo issue on hackage?
16:56:11 <dcoutts> dons: make an alias map
16:56:21 <dons> yeah.
16:56:25 <dcoutts> dons: and stop using that as the front page, use hoogle
16:56:27 <Nafai> I'm finding that it is very easy and succinctly to express some of the algorithms needed in Haskell
16:56:52 <dcoutts> dons: search should be the primary interface, to search in package names, descriptions, function names, documentation etc etc
16:56:59 <dons> todizz: there's quite a lot of haskell entries in euler, people seem to enjoy it
16:57:38 <dcoutts> Lemmih: seems includes/HsSDLConfig.h.in is missing from the SDL-0.5.1 tarball
16:57:44 <dcoutts> @Seen Lemmih
16:57:44 <lambdabot> Lemmih is in #haskell. I last heard Lemmih speak 3h 57m 10s ago.
16:58:36 <dcoutts> @tell Lemmih seems includes/HsSDLConfig.h.in is missing from the SDL-0.5.1 tarball
16:58:36 <lambdabot> Consider it noted.
17:11:28 <Cale> *grumble*
17:12:27 <Sizur> I'm on 6.8.1 and a th generated instance looks like this:
17:12:27 <Sizur>         instance Projection [(a, b)] [a] where
17:12:27 <Sizur>             []
17:12:27 <Sizur>             []
17:12:27 <Sizur>             { project = map (\ (a, _) -> a) }
17:12:27 <Sizur> what's up with the [] [], is this a known issue?
17:12:28 <Cale> readBinIface_ isn't exported from BinIface.hs, so how do I run the TcRnIf a b ModIface computation such that the right NameCache is supplied?
17:13:13 <Cale> (I think I'm okay with constructing a NameCache in the first place)
17:16:02 <Sizur> how can one even get these empty lists in there?
17:17:00 <Sizur> it did not look like that on 6.8.2
17:17:25 <Igloo> Sizur: It's a recently fixed issue
17:17:47 <Sizur> Igloo: thanks! :) so upgrading will fix it
17:17:50 <davidL> Do networks generally use big-endian ordering?
17:18:09 <SamB> Sizur: see "simon cat"
17:19:45 <Sizur> SamB: what's that?
17:19:49 <SamB> http://arcanux.org/lambdacats_2.html#entry8
17:19:50 <lambdabot> Title: Lambdacats
17:20:05 <ac> is there a function like listArray that only takes a list?
17:20:38 <Sizur> SamB: lol
17:20:45 <dons> :t array
17:20:46 <lambdabot> forall i e. (Ix i) => (i, i) -> [(i, e)] -> Array i e
17:21:20 <Toxaris> ac: I don't think so. You have to provide the size of the array yourself
17:21:42 <idnar> :t listArray
17:21:43 <lambdabot> forall i e. (Ix i) => (i, i) -> [e] -> Array i e
17:21:45 <ac> that's annoying when you have arrays that you edit in source
17:21:47 <Toxaris> ac: you can write your own simpleListArray xs = listArray (0, length xs - 1) xs
17:21:53 <ac> right
17:22:10 <ac> SamB: why is it an "oleg cat"?
17:22:58 <ddarius> ac: You'll figure it out before long.
17:23:19 <ac> ddarius: I saw that one a long time ago and I still don't get it
17:23:50 <ddarius> It's only been there for < 3 months.
17:24:03 <Toxaris> ac: do you know oleg? (it's a person)
17:24:47 <EvilTerran> @where oleg
17:24:47 <lambdabot> http://okmij.org/ftp/
17:25:11 <EvilTerran> he's on the first page of google results for "oleg". that's cool.
17:25:54 <Cale> It works!
17:26:12 <Cale> (my ghc-as-a-library hack for hs-plugins)
17:26:52 <Cale> It's probably the most kludgy possible way to do everything, since there's probably lots of code duplication still, but the first eval test works now at least :)
17:28:40 <Cale> dons: Is there a script to auto-run the testsuite and check that everything is okay, or do I just do that by hand?
17:29:05 <EvilTerran> ac, in short, oleg is a theorist who is known for, amoungst other things, doing weird and wonderful things with the haskell type system
17:29:36 <Kirakishou> How do I determine whether two objects are one and the same?
17:29:39 <Cale> ah, 'make check'
17:29:41 <EvilTerran> for example,
17:29:45 <Cale> Kirakishou: ==
17:29:45 <EvilTerran> @wiki NumberParamTypes
17:29:45 <lambdabot> http://www.haskell.org/haskellwiki/NumberParamTypes
17:29:52 <Kirakishou> ok
17:30:17 <Toxaris> EvilTerran: (There is currently no text in this page)
17:30:35 <Cale> Kirakishou: Value equality is the only really meaningful kind of equality we deal with in Haskell.
17:30:42 <EvilTerran> http://www.haskell.org/tmrwiki/NumberParamTypes
17:30:43 <lambdabot> Title: NumberParamTypes - TmrWiki
17:30:46 <EvilTerran> there we go
17:31:53 <Kirakishou> Cale, that's not what I'm looking for, though
17:32:08 <Kirakishou> I mean, for two things to reside in the same place in memory
17:32:09 <Cale> Kirakishou: what are you looking for?
17:32:21 <Kirakishou> one and the same
17:32:24 <Kirakishou> compare pointers
17:32:28 <EvilTerran> you don't
17:32:30 <Cale> Kirakishou: that's not meaningful really -- the garbage collector might copy or move things at any time
17:32:34 <Kirakishou> dang.
17:32:46 <ddarius> Pointers?  What are pointers?
17:33:02 <Cale> If you want to compare pointers for FFI reasons, then just use ==
17:33:05 <EvilTerran> how (or even *if*) things are arranged in memory is a detail that's left up to the individual implementations
17:33:07 <Cale> (on values of type Ptr a)
17:33:09 <mrd> ddarius: i think they're sharp little objects used to torture newbies in #C
17:33:28 <idnar> Kirakishou: that's only really a useful thing if you're dealing with mutable state, and you have very little of that going around in Haskell
17:33:39 <idnar> unless you have some use case in mind that I'm not thinking of
17:33:50 <Cale> If you want to test if two IORefs are equal, that's easy too.
17:34:40 <Sizur> I want a JS embedded into haskell as a DSL
17:34:44 <Cale> dons: Are all the testsuite tests supposed to pass? (Did they all pass with 6.6?)
17:34:50 <dfranke> SamB: meh, you're right about Reader.  It works but it's a pain.
17:34:50 <mrd> does anyone know if oleg has a day job? or does he just sit and muse upon the great wonders of type theory?
17:34:53 <ddarius> Sizur: Why?
17:35:02 <Sizur> woops, worg channel
17:35:03 <Cale> Most of them pass, anyway
17:35:13 <ddarius> mrd: He also muses about continuations, particularly delimited ones.
17:35:16 <Cale> I'm happy enough to try compiling lambdabot now :)
17:35:53 <Sizur> ddarius: xhtml, css, js, db, i18n, the whole stack from one source
17:36:38 <ddarius> Sizur: You mean something like Links or what I think Volta is supposed be and some others?
17:37:10 <Sizur> yep, Links is that. but with happs it's getting close too
17:37:38 <ddarius> I say we make browsers that run Haskell natively.
17:37:51 <EvilTerran> written in haskell, of course
17:37:57 <Sizur> well, we have  haskell os and fs already
17:38:04 <dons> dcoutts: around?
17:38:09 <dfranke> SamB: but actually, conceptually what I'm doing here is comparing two complex data structures, generating a diff, and assigning UUIDs to hunks.  So I'm thinking that the Right Thing is actually to wrap RWS in a newtype.  r is the structures I'm comparing, w is the diff, and s is the stream of UUIDs.
17:38:23 <dons> did you see this first lazy bytestring program doesn't use constant overhead?
17:39:39 <Cale> dons: I have hs-plugins working on 6.8.2 :)
17:39:44 <dons> yay!
17:39:45 <dons> Cale++
17:39:52 <Nafai> Woot!
17:40:00 <Cale> dons: and it only required replacing half of it with ghc-as-a-library
17:40:20 <Cale> :)
17:40:20 <mrd> good stuff. now i can upgrade.
17:40:50 <dons> Cale, oh, using ghc-api ?
17:40:53 <Cale> yeah
17:40:55 <dons> yay!
17:40:56 <dons> even better
17:41:04 <dons> tear out all the .hi file stuff and reuse ghc-api
17:41:05 <Cale> Probably in a very horribly kludgey way though
17:41:16 <Cale> But yeah, Language.Hi is totally gone
17:41:18 <Toxaris> dons: where does ByteString live these days? http://www.cse.unsw.edu.au/~dons/fps.html seems a bit rusty.
17:41:19 <lambdabot> Title: Data.ByteString
17:41:59 <dons> darcs.haskell.org/bytestring
17:42:40 <dfranke> y'know, for the past year, I've been subconsciously associating Haskell with procrastination.  I wonder how long it's going to take for the guilt reflex to go away now that I'm doing it for a living.
17:43:25 <Nafai> dfranke: Why procrastination?
17:43:39 <Nafai> dfranke: And, btw, congrats on doing Haskell for a living.  Jealous.
17:44:10 <Toxaris> dons: thanks. maybe this should be reachable from http://hackage.haskell.org/cgi-bin/hackage-scripts/package/bytestring-0.9.0.1 ?
17:44:11 <lambdabot> http://tinyurl.com/yw6tlk
17:44:40 <dfranke> Nafai: because up until now, I've only been writing in Haskell for the sake de-numbing my brain after whatever it was that I was supposed to be doing at the time.
17:45:46 <Nafai> dfranke: Heh.  I would also associate it with procrastination because I've been putting off learning Haskell until recently.
17:45:50 <dons> good idea, Toxaris
17:47:03 <dfranke> Nafai: and you might be less jealous if I told you that I'm not getting paid yet :-).  I'm just writing software that I'm hoping will sell once it's released, and I quit my job in order to do so.
17:47:42 <Nafai> dfranke: Okay, less jealous.  But good luck!
17:48:39 <Cale> dons: What's Data.ByteString.Base.packAddress moved to?
17:49:06 <dons> .Internal or .Unsafe I think
17:49:34 <Cale> hmm, apparently not
17:49:56 <Cale> There's unsafePackAddress, but that needs a length
17:50:48 <Cale> (Just having trouble compiling Plugin/Dummy/DocAssocs.hs)
17:51:06 <Cale> I suppose I can just do a search and replace and pack the strings normally.
17:51:39 * EvilTerran notes that it's possible to translate a yacc-style parser into a parsec parser fairly directly
17:52:03 <EvilTerran> ... also, it seems that, if your original parser had no shift/reduce conflicts, you won't need try in the parsec version
17:53:17 <dfranke> EvilTerran: no, that's not necessarily true.
17:53:26 <SamB> EvilTerran: why the heck would you want to do that?
17:53:48 <EvilTerran> to see if i can :P
17:53:59 <dfranke> EvilTerran: no shift/reduce conflicts means that your original grammar is LALR(1).  You can write a parsec parser without try if your grammar is LL(1).  LALR(1) is a bigger class than LL(1).
17:54:25 <BMeph> dfanke: It's not that kind of lazy. ;p
17:54:28 <EvilTerran> because I've been presented with an excercise that involves faffing with a lex/yacc-esque setup, and i wanted to see if i could re-implement in parsec
17:54:38 <EvilTerran> and if it would be nicer done in parsec
17:54:52 <SamB> EvilTerran: I would just make a happy grammar of it...
17:55:34 <EvilTerran> that's exactly the sort of thing i mean by "yacc-esque", tho
17:55:35 <dfranke> BMeph: :-)
17:56:17 <EvilTerran> dfranke, that LL/LALR thing's interesting. maybe i should wait 'til my "compilers" course next term, wherein i'll hopefully learn about that sort of thing...
17:56:55 <dfranke> EvilTerran: depends what Uni you're at.  I had the good fortune to learn about this stuff from Manuel Bermudez.
17:58:21 <EvilTerran> it's a good uni :) -- http://web.comlab.ox.ac.uk/oucl/courses/topics07-08/compilers/synopsis.html
17:58:22 <lambdabot> Title: Compilers: Synopsis, http://tinyurl.com/yw45cn
17:58:51 <Toxaris> dons: how are the Haskell snippets in "Rewriting Haskell Strings" related to the current ByteString code? is the current ByteString library based on Stream fusion?
17:58:59 <BMeph> Oxford? Naugh, that's a third-rate uni, for sure... 8D
18:00:29 <gwern> @hoogle Int32
18:00:29 <lambdabot> Data.Int.Int32 :: data Int32
18:01:12 <dfranke> EvilTerran: ok, looks like you'll learn enough to probably sate your curiousity.  But the final the exam in my compilers course was basically, "here's a big grammar.  Hand-compile it into a LALR(1) automaton."
18:01:34 <mrd> ugh
18:02:03 <mrd> people are still teaching like that?
18:02:23 <EvilTerran> yucky
18:02:31 <monochrom> people are still examining like that.
18:02:49 <dfranke> mrd: if by "people" you mean Manual Bermudez and maybe Al Aho, then yes.
18:03:01 <mrd> ah yea, he devoted most of his book to parsing
18:03:05 <mrd> the least interesting part of compilers
18:03:52 <dfranke> mrd: well, the Dragon Book was a godsend for me when I was writing TIARA.
18:03:53 <monochrom> Be glad they are not into functional programming. "Here is a large functional program. Hand compile it to GHC core!"
18:04:40 <mrd> sure, in the 70s it was still kinda new stuff
18:09:30 <Cale> runplugs: /tmp/MFEqE27464.o: unknown symbol `__stginit_haskell98_Char_'
18:09:34 <Cale> dons: any ideas?
18:12:12 <Cale> hmm, problem with eval_ apparently...
18:12:21 <Cale> (but not with eval)
18:15:51 <dons> Cale: haskell98 package?
18:16:29 <Cale> dons: yeah
18:17:10 <Cale> oh, I probably have to specify that explicitly in RunPlugs?
18:18:37 <Cale> yay, working now :)
18:19:03 <Cale> okay... so, now just a great big darcs record and then I should be able to push some patches :)
18:19:41 <Cale> Oh, is the cse repo still the source for hs-plugins?
18:20:03 <Cale> Or is there a new repository?
18:20:16 <Cale> (Heh, I probably should have checked this before starting :)
18:45:18 <Gyde> anyway I can measure the time/cpu/flops of a function?
18:45:22 <bench> is there a way to automatically serialize a record with xml
18:46:02 <Choko_> Gyde: do some profiling
18:46:18 <Gyde> ?
18:46:37 <bench> for example, if i have data D = D {name::String, age::int}, i want to generate something like <D> <name> jon </name> <age>25</age></D>.
18:47:27 <bench> i know that i can write my own 'Show', but i'm wondering if there is a package/util like that already so that i can do D ... deriving Show_XML
18:47:35 <ivanm> Gyde: http://www.haskell.org/haskellwiki/How_to_profile_a_Haskell_program
18:47:36 <lambdabot> Title: How to profile a Haskell program - HaskellWiki, http://tinyurl.com/yq6bzf
18:48:19 <sjanssen> bench: HAppS has a library for this
18:50:44 <bench> sjanssen: do i need whole happs or the one package/lib?
18:50:58 <sjanssen> bench: I'm not sure, maybe #happs can help you?
18:51:32 <bench> ok, thanks
18:52:00 <Cale> dons: How do I get the patch to you?
18:54:25 <Kirakishou> :t Cont
18:54:26 <lambdabot> forall a r. ((a -> r) -> r) -> Cont r a
19:00:29 <BMeph> bench: You might also check out HaXML.
19:05:00 <BMeph> Specifically, the Haskell2Xml module - check out: http://www.haskell.org/haxml/
19:05:01 <lambdabot> Title: HaXml: Haskell and XML
19:05:32 <BMeph> (To: bench, that is)
19:07:50 <dons> Cale: email dons <> galois.com
19:08:48 <shachaf> dons <$> galois <*> com? :-)
19:20:21 <Kirakishou> can I use == to compare strings?
19:22:02 <mrd> yup
19:22:05 <shachaf> > "Yes" == "Yes"
19:22:06 <lambdabot>  True
19:22:59 <ac> what are the mechanics behind "deriving"?
19:23:03 <loupgaroublond> > "Yes" == "Prog Rock Band" where "Prog Rock Band" == "Yes"
19:23:03 <lambdabot>  Parse error at "where" (column 27)
19:23:11 <ac> (if there is anything to speak about there)
19:23:15 <loupgaroublond> > "Yes" == "Prog Rock Band" where "Prog Rock Band" = "Yes"
19:23:15 <lambdabot>  Parse error at "where" (column 27)
19:23:23 <shachaf> loupgaroublond: You can't do that.
19:23:27 <mrd> ac: examining the structure of the algebraic datatype and generating some code
19:23:30 <loupgaroublond> damn :P
19:23:31 <shachaf> loupgaroublond: Strings are literals.
19:23:40 <shachaf> > let 2 + 2 = 5 in 2 + 2 -- Happier?
19:23:41 <lambdabot>  5
19:23:57 <shachaf> Besides, where doen't work in that context anyway.
19:24:03 <ac> mrd: is it possible to write my own type classes that things can derive?
19:24:13 <mrd> ac: not in h'98
19:24:21 <ac> mrd: GHC?
19:24:21 <mrd> but there are other libraries which attempt to offer similar functionality
19:24:31 <mrd> check out Data.Derive, Drift
19:24:38 <mrd> and Generic Programming
19:24:39 <loupgaroublond> shachaf: i still haven't really figured out the distinction between where and let :/
19:24:53 <Kirakishou> :t (&&)
19:24:54 <lambdabot> Bool -> Bool -> Bool
19:24:56 <Kirakishou> ah
19:24:57 <ac> mrd: so that's what generic programming is
19:25:19 <mrd> sorta
19:25:20 <ac> loupgaroublond: there isn't any
19:25:40 <shachaf> loupgaroublond: where is like let, but it goes after rather than before, and it can only be used when binding something ("f x y = ... where ...", "let x = y + y where y = 5", etc.)
19:25:46 <Kirakishou> :t (&)
19:25:47 <lambdabot> Not in scope: `&'
19:25:51 <shachaf> loupgaroublond: It's just syntactical.
19:26:22 <oerjan> > let "Prog Rock Band" == "Yes" in "Yes" == "Prog Rock Band"
19:26:22 <lambdabot>  Parse error at "in" (column 31)
19:26:32 <oerjan> > let "Prog Rock Band" = "Yes" in "Yes" == "Prog Rock Band"
19:26:32 <lambdabot>  False
19:26:43 <Kirakishou> :t True
19:26:43 <lambdabot> Bool
19:26:46 <shachaf> > let "a" = "b" in "a"
19:26:47 <lambdabot>  "a"
19:26:52 <Kirakishou> well, damn
19:27:13 <ricky_clarkson> > let (==) "Shit" "Yes"=true in "Yes"=="Shit"
19:27:13 <lambdabot>   Not in scope: `true'
19:27:19 <Kirakishou> I guess I can't use True as a data constructor then
19:27:22 <ricky_clarkson> > let (==) "Shit" "Yes"=True in "Yes"=="Shit"
19:27:23 <lambdabot>   Non-exhaustive patterns in function ==
19:27:35 <mrd> flip
19:27:39 <Kirakishou> :t String
19:27:39 <lambdabot> Not in scope: data constructor `String'
19:27:47 <ricky_clarkson> > let (==) "Shit" "Yes"=True in "Shit"=="Yes"
19:27:48 <lambdabot>  True
19:27:51 <Kirakishou> :t ("")
19:27:51 <shachaf> :k String
19:27:51 <lambdabot> [Char]
19:27:52 <lambdabot> *
19:27:56 <loupgaroublond> > let Yes == "Shitty Prog Rock Band" in "Shitty Prog Rock Band" == Yes
19:27:56 <lambdabot>  Parse error at "in" (column 36)
19:28:17 <Kirakishou> :t T
19:28:17 <lambdabot> Not in scope: data constructor `T'
19:28:18 <ricky_clarkson> loupgaroublond: s/==/=/
19:28:19 <Kirakishou> :t F
19:28:19 <lambdabot> Not in scope: data constructor `F'
19:28:27 <Kirakishou> goody
19:28:32 <shachaf> Kirakishou: True/False.
19:28:40 <loupgaroublond> > let Yes = "Shitty Prog Rock Band" in "Shitty Prog Rock Band" == Yes
19:28:40 <lambdabot>   Not in scope: data constructor `Yes'
19:28:43 <shachaf> Kirakishou: (You can /msg lambdabot, by the way.)
19:31:20 <oerjan> Kirakishou: technically you can define your own data constructor True and hide the usual one (with import Prelude hiding True, i think)
19:31:34 <oerjan> *hiding (True)
19:32:06 <Kirakishou> what should I do about comparing procedures?
19:32:28 <oerjan> although the usual True will still be used for anything builtin
19:32:41 <Kirakishou> I mean, you're not supposed to compare them, but my representation of them allows for comparison
19:32:45 <shachaf> oerjan: hiding (Bool(..)), no?
19:33:01 <oerjan> shachaf: isn't it possible to hide only True?
19:33:04 <shachaf> Kirakishou: How do you represent them?
19:33:20 <shachaf> oerjan: Probably, but Kirakishou was also talking about F.
19:33:36 <Kirakishou> A Pair and a list of LispVals
19:33:47 <Kirakishou> also, an environment
19:34:06 <Kirakishou> which is also comparable, since Data.Map is, I think
19:37:06 <oerjan> > M.fromList [(i,i^2) | i <- [1..10]] < M.fromList [(i,i) | i <- [1..10]]
19:37:08 <lambdabot>  False
19:43:14 <Cale> dons: should be sent :)
19:44:01 <Cale> http://cale.yi.org/hs-plugins/ should also work
19:44:01 <lambdabot> Title: Index of /hs-plugins
19:44:45 <oerjan> Cale: updated hs-plugins for 6.8? :)
19:44:49 <Cale> yes
19:44:59 <mrd> really beta?
19:45:00 <ikegami--> great
19:45:44 <Cale> Yeah, it's pretty beta. Most of the testsuite passes though, and lambdabot works.
19:46:14 <Cale> (with a few mostly-obvious tweaks)
19:46:50 <Kirakishou> so, should I allow the comparison of functions?
19:47:00 <Cale> My main concern is really that I had no idea what I was doing most of the time.
19:47:07 <mrd> comparison of functions? how?
19:47:42 <OceanSpray> let's just say that, with the way functions are represented internally right now, it's possible
19:47:48 <Cale> So there are some pretty sketchy things in it, and I'm certain that someone who knows the ghc-api could probably make it *much* more concise.
19:48:13 <mrd> OceanSpray: in some kind of normal form?
19:48:24 <OceanSpray> what do you mean, normal form?
19:48:46 <Korollary> You can compare module alpha renaming.
19:48:49 <Korollary> modulo
19:48:58 <Korollary> but not beta equivalence
19:49:04 <oerjan> Cale: oh, converted to ghc-api too?
19:49:10 <Cale> oerjan: yes
19:49:15 <oerjan> Cale++
19:49:23 <Cale> oerjan: that's how I got it to work with 6.8
19:49:35 <mrd> (\ x -> x) == (\ x -> head [x])  ?
19:50:16 <Cale> oerjan: the FastString stuff changed enough that I just wasn't up for copying half of GHC into hs-plugins and tweaking it until it worked, so I just completely threw out Language.Hi altogether and used ghc-api.
19:50:52 <Nafai> Cale: Isn't that a more sustainable approach anyway?
19:50:55 <Cale> yes
19:52:04 <OceanSpray> mrd, I still don't get what you mean
19:52:09 <Nafai> When my Haskell skills have improved, I want to look closer at ghc-api and possibly shim to help make an awesome Haskell IDE
19:52:19 <Cale> There are some pretty sketchy things in there now though. Some places where I just used "undefined" since the value being provided seemed unimportant and I couldn't work out how to get a proper value to plug in, for instance.
19:52:25 <mrd> OceanSpray: would those be equal?
19:52:26 <OceanSpray> though yes, that would be true
19:52:30 <Cale> (but it works all right, so maybe that's okay)
19:52:40 <OceanSpray> wait
19:52:47 <Korollary> Nafai: There's an ide project like that already iirc
19:52:47 <OceanSpray> Oh, I see what you mean now
19:52:52 <oerjan> OceanSpray: basically any comparison of functions is going to hit undecidability issues
19:53:03 <OceanSpray> so no, I shouldn't do that
19:53:04 <OceanSpray> got it
19:53:08 <OceanSpray> what about environments, though?
19:53:08 <Nafai> kolmodin: URL?
19:55:37 <oerjan> OceanSpray: i suppose the thing you can hope for is a comparison that at least (1) compares semantically unequal things unequel (2) compares each function equal to itself
19:55:47 <oerjan> *unequal
19:55:54 <OceanSpray> eh.
19:56:09 <wy> What's the difference between Haskell and ocaml's type system? I noticed that if I define a function add x y = x+y; then add 1 is of type (Num t) => t -> t, but OCaml gives int->int. It seems OCaml determined types earlier.
19:56:17 <oerjan> i guess that's a minimum, and can be useful too...
19:56:24 <Korollary> wy: Ocaml doesn't have typeclasses
19:56:33 <oerjan> wy: ocaml has no type classes
19:56:35 <SamB> wy: what he said
19:56:51 <wy> This is quite interesting
19:57:09 <oerjan> wy: ocaml uses +. for floating point, i believe
19:57:13 <wy> So type class is unique to haskell. I didn't noticed that.
19:57:15 <SamB> @google making ad-hoc overloading less ad-hoc
19:57:16 <lambdabot> http://homepages.inf.ed.ac.uk/wadler/topics/type-classes.html
19:57:17 <lambdabot> Title: Website Maintenance
19:57:32 <wy> Right that "+" determined the type of the function in ocaml
19:57:39 <SamB> @google making ad-hoc overloading less ad-hoc citeseer
19:57:40 <lambdabot> http://citeseer.ist.psu.edu/85097.html
19:57:40 <lambdabot> Title: How to Make Ad-Hoc Polymorphism Less Ad Hoc - Wadler, Blott (ResearchIndex)
19:57:48 <oerjan> wy: haskell invented it.  it may be spreading.
19:57:49 <wy>  Website Maintenance :-)
19:57:59 <oerjan> clean has it and C++ seems to be getting something similar
19:58:06 <SamB> wy: the citeseer has it
19:58:12 <wy> oerjan: It looks like a very neat theory. Thanks
19:58:13 <OceanSpray> oh boy
19:58:37 <OceanSpray> I implemented true and false as functions that evaluate either the first or the second of their arguments
19:58:46 <monochrom> Congrats!
19:59:01 <SamB> OceanSpray: you've figured out how to church-convert sum types ;-)
19:59:01 <OceanSpray> but this causes them to be displayed as #<primitive procedure> when printed.
19:59:21 <SamB> wait, you are doing this in scheme?
19:59:30 <OceanSpray> I'm writing a sort of scheme, yes
19:59:49 <monochrom> You can't even get it displayed as anything in Haskell. :)
19:59:56 <SamB> indeed ;-)
20:00:01 <SamB> well, not without haxz
20:00:10 <wy> SamB: thanks! I'll keep reading
20:00:26 <SamB> you are welcome
20:00:34 <OceanSpray> It seems that I'll have to make a special case for show (Procedure T) and show (Procedure F)
20:00:44 <oerjan> wy: i believe type classes were _the_ main invention of the first version of haskell (monads came later).  it was supposed to be a conservating consolidation of other lazy functional languages but when they got the idea it was too good to leave out. :)
20:00:57 * SamB wonders if he should prepare a bibliography of papers he enjoyed
20:01:10 <oerjan> *conservative
20:01:26 <SamB> oerjan: well, it makes so many things easier, you know ;-)
20:01:35 <monochrom> I prepare a bibliography of papers I download. (I don't even read all of them, nevermind enjoy.)
20:01:44 <SamB> why would you do that?
20:01:48 <SamB> so you can find them?
20:01:51 <hpaste>  jre2 pasted "opengl glut callbacks and stateT" at http://hpaste.org/4531
20:01:53 <jre2> is there a correct way to get opengl+glut's displayCallback to accept a function on StateT MyState IO ()?
20:02:02 <monochrom> You should too. You won't regret it. Some day someone will ask for paper pointers, then you will be able to give one.
20:02:17 <wy> oerjan: What's the next invention from haskell?
20:02:46 <monochrom> The next invention is multiple parameter type class. :)
20:03:08 <allbery_b> jre2: it can be done, but it'll get an outdated state.  I use a ReaderT with the mutable state in IORefs
20:03:08 <wy> I wonder if type classes can eliminate the need for class inheritance?
20:03:28 <oerjan> OceanSpray: maybe you can add an optional representation field to functions?
20:03:44 <monochrom> I say 90% of inheritance is just type class.
20:03:51 <conal> i like citeulike for personal bibliographies.  especially via citeseer.
20:03:54 <jre2> allbery_b: how do you go about that?
20:04:01 <allbery_b> jre2: then see http://hpaste.org/3137
20:04:06 <monochrom> But there is 10% genuine inheritance.
20:04:32 <allbery_b> (also includes accessors that indirect through IORefs)
20:04:41 <jre2> thanks
20:04:52 <wy> It seems to be a different way of thinking. I'm really hamper by Java this semester. This winter is the time to regain my acquaintance with the functional languages
20:05:16 <mrd> there is no need for class inheritance
20:05:48 <dons> Cale: great!
20:05:48 <ricky_clarkson> The winter of discontent.
20:05:51 <allbery_b> you might also want to do like e.g. HOpenGL does, and define (:=) to be setr
20:05:57 <dons> Cale: so your lambdabot works?
20:06:02 <Cale> dons: yep :)
20:06:05 <dons> awesome
20:06:16 <wy> It seems that most of the tutorials don't cover this topic. Do I just need to read that paper?
20:06:18 <allbery_b> (infix, so you get ref := value)
20:06:46 <monochrom> Observe that 90% of the time you use inheritance, you only have one abstract base and lots of child classes direct from that base, all siblings, no grandchild. For example you just do "interface" then many implementations. That's just type class.
20:07:22 <jre2> allbery_b: cool, I'll try that out real quick
20:08:21 <monochrom> For example you make many classes as "implements Comparable". Well that's our Ord, and the Haskell story is cleaner too. No need to "instanceOf" and then downcast in your comparison code.
20:08:40 <wy> monochrom: I see.
20:08:57 * SamB wonders since when x-chat has a treeview on the left...
20:09:31 <monochrom> I admit there is about 10% of the time you really have a class hierarchy, like grandchildren and grandgrandchildren etc. Haskell doesn't have a nice story for that.
20:09:42 <Nafai> Is shim being mantained?  The trac instance for it at http://shim.haskellco.de/trac/ seems to be down
20:10:49 <wy> monochrom: So it's better to learn both ideas.
20:11:07 <wy> monochrom: Is it possible that Haskell has class inheritance in the future?
20:11:11 <vininim> monochrom: composition over inheritance
20:11:34 <mrd> wy: i sure hope not
20:11:40 <monochrom> What is composition over inheritance?
20:12:28 <ricky_clarkson> Something to favour.
20:13:14 <wy> mrd: Why do you think so? It seems to be useful sometimes
20:13:53 <mrd> it "seems" to be useful, but ends up being incorrectly used or destroys modularity.  plus it plays havok with type inference.
20:14:58 <mrd> oleg has a nice discussion on some problems with subclassing and OOP: http://okmij.org/ftp/Computation/Subtyping/
20:14:59 <lambdabot> Title: Subtyping, Subclassing, and Trouble with OOP
20:15:28 <wy> mrd: I meant by "seems" :-) In fact I'm confused by it for a whole semester, but I can't be sure it's not needed until I rewrite the ray tracer of my course using a functional language
20:15:45 <mrd> it's definitely not needed.  Turing Machines don't have it.
20:16:22 <monochrom> Turing Machine definitely inherited from Finite State Automaton itself! :)
20:16:33 <wy> mrd: That's not true. No one likes programming in Turing machines
20:16:38 <mrd> ok ok =)
20:16:42 * SamB sighs after discovering that he can put the tabs back where they belong, tries to figure out how to get xchat to stop checking the spelling of words before he finishes typing them
20:16:56 <mrd> but computer programming has existed prior, and will exist after, all the OOP hype has died out
20:17:27 <SamB> yes, the hype will die
20:17:33 <SamB> but will OOP live on?
20:17:39 <mrd> also i might point out that "raytracer" is the classic exercise for Scheme
20:18:01 <mrd> which is sort of a functional language
20:18:12 <vininim> you don't need referencial transparency, lazy evaluation too
20:18:12 <SamB> oh, is THAT where that ICFP contest came from?
20:18:58 <OceanSpray> One day, keyboards will have a lambda key.
20:19:00 <SamB> though that doesn't explain why the language looks like postscript...
20:19:12 <SamB> you mean like \?
20:19:42 <OceanSpray> that's just a vague approximation.
20:19:49 <mrd> that's a lambda missing its most important part!
20:20:00 <conal> SamB: "* SamB wonders if he should prepare a bibliography of papers he enjoyed": do you know about citeulike.org?
20:20:04 <monochrom> One day, you won't use a keyboard.
20:20:07 <SamB> maybe with an extra shift key for greek letters?
20:20:10 <vininim> λ
20:20:18 <SamB> monochrom: that sucks cause my handwriting is terrible
20:20:28 <vininim> wich looks ugly with my current terminal font
20:20:29 <monochrom> Don't worry, not handwriting either.
20:20:34 <SamB> conal: I've heard about it
20:20:42 <wy> My handwritting used to be good
20:20:49 <SamB> monochrom: and I don't think straight either
20:20:59 <SamB> I'd probably end up deleting stuff by mistake
20:21:11 <monochrom> Perhaps you can speak.
20:21:19 <conal> SamB: check out http://www.citeulike.org/user/conal as an example.
20:21:20 <SamB> I trip over my lips
20:21:20 <lambdabot> Title: CiteULike: conal's library [50 articles]
20:21:39 <SamB> conal: I suppose it wouldn't be too hard...
20:22:16 <conal> SamB: it's especially convenient from citeseer, which now has a "Bookmark in CiteULike" link on each page.  E.g., http://citeseer.ist.psu.edu/hickey99interval.html
20:22:16 <lambdabot> Title: Interval Constraint Plotting for Interactive Visual Exploration of Implicitly De ...
20:22:21 <vininim> more like "one day your > replicate 20 "grand"; child will not use a keyboard"
20:22:26 <SamB> conal: so I noticed
20:22:48 <SamB> that was why I said "I suppose it wouldn't be too hard"
20:24:36 <mrd> did you "trip over your lips" while accidentally putting your foot in your mouth?
20:25:12 <monochrom> haha
20:25:17 <SamB> mrd: no, it's my tongue that trips over my lips
20:25:44 <loupgaroublond> how come i'm getting this error trying to install zlib with cabal with ghc 6.8.1 ?
20:25:51 <loupgaroublond> Setup.hs: The program hsc2hs is required but it could not be found
20:26:16 <monochrom> Does it refuse to build?
20:26:40 <loupgaroublond> monochrom: yeah
20:27:10 <monochrom> zlib is a binding to C routines IIRC. Perhaps it really uses hsc2hs.
20:27:29 <loupgaroublond> i have a binary called hsc2hs-ghc though
20:27:44 <wy> Does anybody know who's the owner of this blog?
20:27:53 <wy> http://sigfpe.blogspot.com/
20:27:54 <lambdabot> Title: A Neighborhood of Infinity
20:27:56 <bench`> how do you break a string separated by ',' and '.' into words w/o breaking various numbers such as 13,600 or 5.55
20:27:59 <mrd> dpiponi
20:28:00 <monochrom> It probably wants the exact name "hsc2hs". Try symlinking or copying.
20:29:13 <oerjan> bench`: will breaking on , and . followed by space do?
20:29:21 <loupgaroublond> monochrom: symlinking still spits out the same error
20:29:32 <monochrom> Ouch. Then I don't know what to try.
20:29:46 <wy> mrd: Is that the nick of him on this channel?
20:29:56 <mrd> yes
20:30:02 <bench`> operjan: there might not be a space
20:30:24 <bench`> "abc,5.5" for example
20:30:28 <wy> I had been curious about what's he doing because he attends SIGGRAPH
20:30:40 <loupgaroublond> monochrom: ack, should have cleaned before that, i guess configure caches these things ahead of time
20:30:46 <wy> and he does Haskell
20:30:50 <monochrom> Oh! hehe.
20:31:26 <wy> It seems that he works for ILM?
20:31:53 <oerjan> bench`: sounds like a lousy syntax.  what if you really _do_ want two numbers to follow each other?
20:32:01 <wy> So I deduced that ILM might be using Haskell?
20:32:07 <monochrom> ILM = infinite-level marketing, the ultimate evil of multi-level marketing? :)
20:32:35 <wy> ILM = Industrial Light and Magic :-)
20:33:50 <bench`> oerjan, unfortunately i don't define the syntax, but let's assume that there is no two numbers together
20:34:34 <oerjan> bench`: perhaps Parsec is the thing
20:34:58 <monochrom> It is possible to conjure a regex.
20:35:09 <oerjan> hm, that too...
20:35:28 <monochrom> [^0-9](,|\.)[^0-9]
20:35:50 <oerjan> monochrom: [,.]
20:36:25 <monochrom> Mine has a problem with . and , with no character before and after, e.g., "hello."
20:36:54 <oerjan> maybe a straight recursion.
20:37:03 <monochrom> [^0-9][,.][^0-9] | ^[,.] | [,.]$
20:37:14 <Korollary> wy: ILM definitely are not.
20:37:47 <monochrom> Once you decide on a regex, you can apply Text.Regex.splitRegex or similar.
20:37:48 <Korollary> From what sigfpe has written I believe they use python for wrapper scripts
20:38:48 <wy> Korollary: I'm thinking about writing a full renderer with some FP. I'm still considering Haskell or OCaml
20:39:20 <wy> FP seems to be a very natural way to write raytracers
20:40:11 <wy> Oh, I need to refresh my haskell mode also. What's the state of the art of the developing environment now?
20:40:18 <shachaf> monochrom: Isn't the whole problem with MLM-ish things that the levels run out eventually?
20:40:50 <monochrom> Yeah! With Haskell, you can haz infinite levels, everyone is happy, Hilbert's hotel etc.!
20:40:59 <Korollary> wy: Many toy renderers have been written in fp languages, including for a recent pissing match between ocaml vs haskell.
20:41:36 <Korollary> my sentences are getting weird.
20:42:03 <wy> Korollary: I've tried a toy in Ocaml. not sure if it's the one you mentioned
20:42:57 <wy> This one: http://www.ffconsultancy.com/ocaml/ray_tracer/index.html
20:42:59 <lambdabot> Title: OCaml tutorials and examples
20:43:31 <Korollary> yeppers
20:45:22 <wy> I haven't found the corresponding Haskell one though
20:45:37 <bench`> :t Text.Regex.splitRegex
20:45:38 <lambdabot> Text.Regex.Posix.Wrap.Regex -> String -> [String]
20:46:10 <Brian`> hi, i have a question
20:46:18 <Brian`> const 3 _ always returns 3
20:46:20 <SamB> conal: okay so I made one
20:46:37 <Brian`> but how come const (+1) 3 7 returns (7+1)? as opposed to 3+1?
20:46:41 <SamB> it's short now, only 4 articles, but it was the only four I could think of off the top of my head ;-)
20:47:00 <oerjan> Brian`: const (+1) 3 7 = (const (+1) 3) 7 = (+1) 7
20:47:06 <SamB> at least, that I was sure I wanted to list...
20:47:57 <monochrom> It will grow. Don't hurry.
20:48:00 <oerjan> function application associates to the left in haskell
20:48:01 <allbery_b> heheh.  unexpected to hear on TV: "Haskell is so dangerous!"  (rugby game, one of the players is named John Haskell...)
20:48:13 <Nafai> Heh
20:48:17 <monochrom> haha
20:48:19 <allbery_b> now they're talking about "Haskell's power".  head-twisty
20:48:21 <Brian`> oerjan, but wouldn't it be a type mismatch?
20:48:29 <Brian`> oerjan, because (+1) :: a -> a
20:48:37 <oerjan> :t (+1)
20:48:38 <lambdabot> forall a. (Num a) => a -> a
20:48:40 <Brian`> oerjan, and const accepts a -> b -> a
20:48:54 <oerjan> Brian`: they are not the same a
20:48:59 <allbery_b> :t const (+1) 7
20:48:59 <lambdabot> forall a. (Num a) => a -> a
20:49:08 <Nafai> allbery_b: This morning I got very confused because my wife all the sudden exclaimed "Haskell?" very confusedly out of the blue while at the computer.
20:49:15 <monochrom> const (+1) :: (Num x) => b -> (x -> x)
20:49:33 <Nafai> allbery_b: Google Reader now automatically subscribes you to your gtalk friends shared items feeds
20:49:40 <allbery_b> heh
20:49:47 <ricky_clarkson> allbery_b: John Haskell twists heads? ;)
20:49:53 <Nafai> allbery_b: So she got my shared items feed which contains a bunch of entries on Haskell.
20:49:55 <ricky_clarkson> Nafai: How long ago?
20:50:01 <Brian`> @src const
20:50:01 <lambdabot> const x _ = x
20:50:09 <allbery_b> hearing someone on TV talking about "Haskell" all the time does
20:50:17 <Nafai> ricky_clarkson: This happened this morning.
20:50:36 <allbery_b> (although he apparently does too, commentators seem to think he's the heart of the London Wasps)
20:50:45 <monochrom> const ::  a -> b -> a.  (+1) :: Num x => x->x.  Unify a with x->x.
20:51:50 <Brian`> monochrom, aha!
20:51:52 <ricky_clarkson> Nafai: I've noticed that for a while, but never realised it wasn't me forgetting what feeds I'd added.
20:52:03 <Brian`> monochrom, that makes sense
20:52:21 <wy> How is lists represented in Haskell? Will it be compiled into arrays if it's an integer list?
20:52:32 <monochrom> No. Cons list.
20:52:37 <Nafai> ricky_clarkson: http://googlereader.blogspot.com/2007/12/reader-and-talk-are-friends.html
20:52:38 <lambdabot> Title: Official Google Reader Blog: Reader and Talk are Friends!, http://tinyurl.com/23v8p8
20:52:41 <ricky_clarkson> wy: How would you compile this into an array?
20:52:43 <ricky_clarkson> [1..]
20:52:49 <ricky_clarkson> > [1..]
20:52:50 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
20:52:58 <Brian`> monochrom, so since const :: a -> b -> a (whereas, a could be of any type, in this case a is of type (x -> x) ?)
20:53:03 <monochrom> Yes.
20:53:12 <wy> ricky_clarkson: Then I put some restriction to my question... bounded lists ;-)
20:53:20 * Nafai builds yhc
20:53:20 <Brian`> monochrom, perfect :) that was very clear. thanks
20:53:31 <oerjan> wy: it will be a cons list unless it is optimized away completely (as ghc tries to do with intermediate lists)
20:53:31 <bench`> [^0-9]
20:53:43 <allbery_b> haskell doesn't (and can't) distinguish between bounded and unbounded lists
20:53:46 <ricky_clarkson> > head [1,2,1/0]
20:53:46 <lambdabot>  1.0
20:53:58 <ricky_clarkson> > [1,2,1/0]
20:53:58 <lambdabot>  [1.0,2.0,Infinity]
20:54:10 <ricky_clarkson> > [1,2,0/0]
20:54:10 <lambdabot>  [1.0,2.0,NaN]
20:54:11 <wy> oerjan: That's a concern because lists are often slow when we don't need the power of it
20:54:11 <Nafai> allbery_b: That's because of laziness, right?
20:54:46 <allbery_b> laziness plays into it, but I think it has more to do with the type system
20:55:47 <allbery_b> if you can't *guarantee* in the type system that a list is fixed length, haskell can't be 100% certain that a set of list operations will always be constant length and could be replaced by an array
20:56:03 <monochrom> I'm going to do a simple experiment of ghc -O2 over a program that uses a list. See if the list is optimized away altogether.
20:56:06 <oerjan> wy: they are fast _if_ they are optimized way though :)  if you want something else you need to choose the data structure yourself.
20:57:11 <wy> oerjan: The problem is that arrays are not so pure?
20:57:18 <oerjan> haskell has several types of Arrays, and ByteStrings.
20:57:31 <shteou> Hey lads
20:57:32 <oerjan> wy: the mutable ones need a monad, yes
20:57:40 <allbery_b> arrays can be pure
20:57:40 <shteou> How does lambdabot perform code execution? Is it something ghc specific or provided by some library or what? :o
20:57:46 <oerjan> and the immutable ones are slow to update
20:58:10 <oerjan> (even DiffArray which was supposed to cheat around it)
20:58:19 <Nafai> Darn, the build didn't work :(
20:58:22 <Saizan_> shteou: it calls ghc to compile the code
20:58:26 <allbery_b> shteou: it compiles a program (expecting ghc with various extensions) and runs it under control of a supervisory program that kills it if it runs for too long
20:58:32 <shachaf> shteou: She uses hs-plugins.
20:58:34 <oerjan> shteou: it uses the hs-plugins library
20:58:34 <shachaf> @version
20:58:34 <lambdabot> lambdabot 4p581, GHC 6.6 (Linux i686 2.40GHz)
20:58:35 <lambdabot> darcs get http://code.haskell.org/lambdabot
20:58:39 <shteou> Ah okay
20:58:41 <shteou> Cheers :)
20:58:51 <shachaf> shteou: (That doesn't work with 6.8 at the moment.)
20:59:07 <shachaf> shteou: See runplugins in that repository for the exact code.
20:59:15 <shteou> Well I'm using Hugs anyway, just messing around with the networks lib hehe
20:59:20 <shachaf> shteou: If you did it today, you might use the ghc-api.
20:59:20 <oerjan> shachaf: except for Cale :)
20:59:37 <shachaf> oerjan: Oh, he got it to work while I was gone?
20:59:45 <oerjan> shachaf: yep
20:59:46 * shachaf only saw attempts.
20:59:55 <shachaf> Will we have a 6.8 lambdabot soon?
21:00:00 <shachaf> (-ish?)
21:00:21 <shachaf> What do you know, mbot uses 6.8.2.
21:00:22 <oerjan> well he said it was beta
21:00:26 <shachaf> Cale++ . :-)
21:01:27 <dons> we will soon.
21:01:31 <ricky_clarkson> I've started to read ++ as 'concatenate' now, regardless of context.
21:01:33 <shteou> Thanks lads! Goodnight!"
21:01:35 <dons> i'll have a go after dessert :)
21:01:37 <dons> ?users
21:01:37 <lambdabot> Maximum users seen in #haskell: 441, currently: 401 (90.9%), active: 14 (3.5%)
21:02:38 <BMeph> Yeah, I can't seem to get Cale's edit out of the repo. :(
21:03:01 <Cale> BMeph: oh?
21:03:05 <Cale> Which repo?
21:03:59 <BMeph> I tried http://cale.yi.org/hs-plugins/, but the last patch won't apply.
21:03:59 <lambdabot> Title: Index of /hs-plugins
21:04:17 <Cale> oh, huh
21:05:05 <Cale> hmm, that's interesting
21:05:45 * SamB wonders why this one isn't on citeseer yet: http://portal.acm.org/citation.cfm?id=1291220.1291194
21:05:47 <lambdabot> Title: Faster laziness using dynamic pointer tagging
21:06:48 <Cale> ah, something in pristine got messed up
21:06:53 <Cale> One sec.
21:08:16 <SamB> btw, the url of my bibliography is http://www.citeulike.org/user/SamB
21:08:17 <lambdabot> Title: CiteULike: SamB's library [5 articles]
21:11:09 * SamB wonders how hard it would be to get a program to search his home directory for papers and tell him what all they are
21:11:35 <ricky_clarkson> I want one that reads them to me while I sleep.
21:12:07 <SamB> I'd be plenty happy with one that could find the bibliographic information somehow
21:12:39 <SamB> perhaps by comparing the first page with first pages of articles in citeseer?
21:13:20 <monochrom> I can't get ghc -O2 to eliminate intermediate lists. I tried: sum [1..n], foldl' (+) 0 [1..n], foldl' (+) 0 (unfoldr h n) for a suitable h.
21:13:21 <wy> mrd: You seem to be right. I can't see why we need more than two levels of "inheritance"
21:14:02 <Cale> er, hmm
21:14:21 <SamB> Cale: darcs repair isn't working?
21:14:50 <Cale> It "worked", and it claimed to fix something, but apparently didn't fix the problem.
21:15:22 <Cale> Darcs is failing to apply a hunk to a file which is being deleted.
21:15:43 <SamB> eeek
21:15:51 <SamB> repository corruption?
21:15:57 <Cale> I don't know, maybe
21:17:31 <Cale> I'll just darcs get the original repo, then copy over the changes by hand and rerecord.
21:22:47 <SamB> yeah, I've had to do that before
21:23:32 <Cale> another thing which I find really annoying is the lack of an 'undo' option to undo your last keypress when confirming/denying changes.
21:23:45 <monochrom> hahahaha
21:25:06 <Cale> I'm just running the testsuite to make sure that everything's as okay as before.
21:26:13 <wy> It seems the haskell-mode still doesn't have some interactive mode that can evaluate a region
21:30:38 <Cale> okay, try now
21:31:54 <BMeph> Got it! :)
21:33:57 <Cale> great
21:37:20 <dons> Cale: ok, i'll update and put hs-plugins 1.1 on hackage
21:37:23 <dons> then we can move lambdabot over.
21:38:10 <Cale> dons: Did all the tests in the testsuite pass in 6.6?
21:38:16 <dons> not all, afaik
21:38:28 <dons> but we only really care about basic loading, not the fancy type checking stuff
21:38:42 <Cale> Okay. There are a few which are failing, and I wasn't sure whether any of that was my fault :)
21:38:50 <dons> ok. i'll look
21:38:56 <wy> Learned a little OCaml. It's true that its type system is not as neat as Haskell's :-)
21:40:08 <Cale> In particular, thiemann0 sounds like a problem which either already existed, or possibly a bug which I reintroduced?
21:46:10 <dons> Cale: i get
21:46:12 <dons> src/System/Plugins/PackageAPI.hs:64:20: Not in scope: data constructor `InstalledPackageInfo'
21:47:00 <dons> could be my newer cabal. hmm
21:47:13 <Cale> hmm
21:47:48 <Cale> I have 6.8.2 with Cabal 1.2.3.0
21:48:13 <Cale> I actually didn't make any changes to that file.
21:48:22 <dons> same.
21:48:35 <dons> and you used the plugins found at unsw?
21:49:24 <Cale> yeah
21:51:30 <dons> what was the url for your repo with its patch?
21:53:08 <Cale> http://cale.yi.org/hs-plugins/
21:53:08 <lambdabot> Title: Index of /hs-plugins
21:53:49 <Cale> I just added another patch to correct some warnings.
21:54:01 <Cale> But it shouldn't have anything to do with the problem you're having
21:54:47 <dons> ok. yeah, i'm thinking my repo was out of date
21:55:04 <dons> hmm, nope, still fails.
21:55:16 <Cale> On a darcs get from there?
21:55:25 <dons> oh, i bet its this, Cabal-1.3.1, Cabal-1.3.2
21:55:44 <dons> yep.
21:55:53 <dons> ==Cabal 1.2.3.0
21:55:57 <dons> built.
21:56:28 <Cale> Okay, so perhaps it'd be a good idea to find out what's going on there with the newer Cabal :)
21:56:44 <dons> yep. but for now this appears to be working enough for lambdabot
21:59:31 <Cale> I'm pretty sure all I had to do for lambdabot was the usual iteration of adding the extra needed packages, and then modifying the RunPlugs.hs to not use haskell98 stuff.
22:00:02 <bos> has anyone used the ghci debugger yet?
22:00:55 <bos> i'm just curious. it's been sitting there for weeks, and i still do all of my debugging with trace or traceM.
22:01:09 <Cale> It looks cool
22:01:21 <dons> just a little, bos. http://cgi.cse.unsw.edu.au/~dons/blog/2007/11/14#no-exceptions
22:01:22 <lambdabot> Title: Haskell hacking
22:01:33 <bos> dons: yeah, saw that.
22:01:33 <dons> but its a fair bit more powerful than that.
22:01:39 <dons> andy should really blog about this stuff more..
22:01:49 <bos> andy should really blog more. period :-)
22:01:55 <dons> right!
22:02:26 <bos> there are so many debuggers for the different languages and platforms that i use that the only one that's baked into my fingers is gdb.
22:02:42 <dons> write a lot of bugs, eh?
22:02:44 <bos> most of the time, i use printf or its local equivalent. c'est dommage.
22:02:56 <bos> dons: neener neener.
22:03:18 <dons> yeah, i'm still mostly ghci + trace, QC, and gdb for the C stuff
22:03:29 <bos> yep.
22:03:44 <bos> debugging via ghci encourages wonderful code decomposition, though.
22:04:07 <bos> it really penalises writing functions that are more than a few lines long.
22:04:12 <bos> likewise QC.
22:04:44 <dons> yeah. my talk at pdxfunc was an exploratory journey into program composition in ghci
22:04:49 <bos> ooh, cute.
22:04:50 <dons> and it had a lot of that feeling
22:05:05 <dons> little experiments, that you then start to glue together
22:05:42 <dons> got some good feedback from the ruby guys, they were quite impressed how "fluid" the process was. (that was the term used)
22:06:18 <dons> good thing forkIO and MVars worked as well in ghci as I hoped :)
22:06:29 <bos> that's cool.
22:07:14 <ddarius> What?!  Statically typed languages are supposed to be batch compiled and only take file IO.  They're starting to get uppity...
22:08:13 <dons> i think they liked the `templating' of code by checking its type first
22:08:16 <dons> ie.
22:08:17 <dons> :t foldl
22:08:19 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
22:08:31 <dons> then stubbing out: foldl (\a b -> ..) 0 [1..10] -- from that
22:08:40 <dons> then gluing things with (.)
22:08:52 <dons> comments like "oh, its like documentation!"
22:09:03 <dons> :)
22:09:07 <ddarius> The types?
22:09:18 <dons> yeah hehe
22:10:19 <monochrom> Type-Oriented Programming.
22:10:31 <ddarius> Once again programmer's disinclinement to write documentation is revealed; we add static type systems and then remove the need to add type annotations via type inference.
22:10:38 <ddarius> @google Cardelli Typeful Programming
22:10:39 <monochrom> Or maybe Type-Driven Programming is more catchy as a name. :)
22:10:39 <lambdabot> http://citeseer.ist.psu.edu/243526.html
22:10:40 <lambdabot> Title: Typeful Programming - Cardelli (ResearchIndex)
22:10:56 <dons> monochrom: yes, the style is really type-driven
22:11:09 <dons> you start with the type, template it, then use (.) to glue types that fit.
22:11:17 <dons> the first step is always to specify the type
22:12:42 <monochrom> I discovered type-driven programming myself. I was doing Lisp homework. I spontaneously decided to write down "the parameter has to be a list, the return value is such-and-such" in the comment before I thought about how to implement it.
22:12:52 <dons> scary
22:13:04 <ddarius> HtDP uses a similar approach despite using the Scheme language
22:14:08 <monochrom> If I didn't write that comment first, I couldn't organize my thoughts. If I wrote that comment first, the code wrote itself, I didn't even have to think.
22:14:49 <ddarius> The type already leads to a canonical form that the code can be written in (at least for pure languages) though there is often a better way to write it.
22:15:47 <monochrom> Subsequently I learned category theory and found out why my brain was doing that to me. :)
22:15:59 <dons> dcoutts:
22:16:00 <dons> Downloading 'hxt-7.4'...
22:16:00 <dons> cabal: /tmp/TMPhxt-7.4TMP/hxt-7.4/doc/hvalidator/thesis/x1577.html: openBinaryFile: resource busy (file is locked)
22:16:19 <ddarius> monochrom: Indeed.
22:16:49 <ddarius> Type theory would also work.
22:29:24 <dons> Cale: did you manage to build lambdabot with 6.8?
22:29:32 <Cale> yep
22:29:40 <dons> 6.8.1 or 2
22:29:45 <Cale> .2
22:29:53 <dons> hmm
22:29:54 <Cale> mbot: @version
22:29:54 <mbot> lambdabot 4p575, GHC 6.8.2 (Linux i686 2.40GHz)
22:29:54 <mbot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
22:29:55 <lambdabot> mbot: You have 1 new message. '/msg lambdabot @messages' to read it.
22:30:00 <dons> i get,
22:30:00 <lambdabot> Title: Index of /~dons/lambdabot
22:30:01 <dons>     No instance for (MonadError IRCError m)
22:30:01 <dons>       arising from the 'deriving' clause of a data type declaration
22:30:05 <Cale> oh
22:30:09 <Cale> Generalise that
22:30:14 <Cale> MonadError e m
22:30:21 <Cale> I forgot about that change.
22:30:22 <dons> ah!
22:30:28 <dons> i wonder why that fails now
22:30:34 <Cale> I have no idea.
22:30:55 <dons> silly type system
22:31:21 <Cale> Some new newtype-deriving strangeness :)
22:31:40 <dons> building now
22:35:07 <glguy> ?seen dons
22:35:07 <mbot> Unknown command, try @list
22:35:08 <lambdabot> dons is in #haskell and #xmonad. I last heard dons speak 3m 27s ago.
22:35:28 <glguy> dons, They weren't kidding when they said to worry about the snow in St. Louis
22:36:11 <dons> glguy: bit snowy? :)
22:36:30 <dons> wow. yes, by the looks of it
22:36:45 <glguy> The taxi starter told us that only 10 taxis were still running, and our taxi driver told us they had decided not to come back
22:36:50 <bench`> if i have ["a", "b", "c"], how i do i generate a list that combines every two or three elements of the list sequencially?
22:36:53 <glguy> my parents couldn't get their cars to the airport
22:37:16 <bench`> so to have ["ab", "bc", "abc"]
22:38:01 <bench`> glguy: i was stuck in St. Louis in 2002 for 3 days
22:38:13 <dons> > replicateM 2 ["a", "b", "c"]
22:38:15 <lambdabot>  [["a","a"],["a","b"],["a","c"],["b","a"],["b","b"],["b","c"],["c","a"],["c",...
22:38:17 <mbot>  [["a","a"],["a","b"],["a","c"],["b","a"],["b","b"],["b","c"],["c","a"],["c",...
22:38:22 <dons> hey mbot
22:38:25 <glguy> dons, he wants a combinations generator, I think
22:38:33 <glguy> or permutations rather
22:39:07 <bench`> not replicateM, but rather combines every 2 or 3 words sequencially
22:39:46 <glguy> > filterM (\_->[False..]) "abc"
22:39:46 <mbot>  Parse error at "False..." (column 15)
22:39:46 <lambdabot>  Parse error at "False..." (column 15)
22:39:51 <glguy> > filterM (\_->[False ..]) "abc"
22:39:52 <mbot>  ["","c","b","bc","a","ac","ab","abc"]
22:39:53 <lambdabot>  ["","c","b","bc","a","ac","ab","abc"]
22:41:04 <dons> > filter (\s -> length s >= 2) $ filterM (\_->[False ..]) "abc"
22:41:04 <lambdabot>  ["bc","ac","ab","abc"]
22:41:06 <mbot>  ["bc","ac","ab","abc"]
22:41:12 <dons> mbot: @part #haskell
22:41:19 <glguy> > let pairs xs = do (y:ys) <- tails xs; (z:_) <- ys; return [y,z] in pairs "abc"
22:41:19 <lambdabot>      Occurs check: cannot construct the infinite type: t = [t]
22:41:20 <lambdabot>       Expected...
22:41:28 <glguy> > let pairs xs = do (y:ys) <- tails xs; (z:_) <- tails ys; return [y,z] in pairs "abc"
22:41:28 <lambdabot>  ["ab","ac","bc"]
22:42:08 <glguy> You can generalize that from 2 to 'n'
22:42:30 <bench`> glguy: what does (\_->[False ..]) do?
22:42:51 <glguy> > ( \ _ -> [False ..] ) ()
22:42:54 <lambdabot>  [False,True]
22:43:01 <glguy> it save keystrokes ;)
22:43:04 <glguy> saves*
22:43:30 <glguy> the real question is, what does filterM do ;)
22:44:56 <dons> i never know what anything does when M == List and >>= == concatMap
22:45:20 <dons> but somehow magically, you can always find the one line solution to your little search problem
22:46:12 <oerjan> > filterM (sequence [isDigit, const True]) "123 testing"
22:46:13 <lambdabot>  ["123","123g","123n","123ng","123i","123ig","123in","123ing","123t","123tg",...
22:46:33 <oerjan> > filterM (sequence [isAlpha, const True]) "123 testing"
22:46:33 <lambdabot>  ["testing","testing","testing","testing","testing","testing","testing","test...
22:46:52 <oerjan> oops
22:47:25 <bench`> filterM is filter applied to a monad? based on the M in the name
22:47:35 <dons> that's right.
22:47:38 <dons> ?src filterM
22:47:38 <lambdabot> Source not found. stty: unknown mode: doofus
22:47:48 <dons> lifted to a monad, we would say
22:48:23 <oerjan> > filterM (sequence [isAlpha, not . isAlpha]) "123 testing"
22:48:24 <lambdabot>  ["testing","testin","testig","testi","testng","testn","testg","test","tesing...
22:48:24 <bench`> but glguy, your one liner is still magic to me
22:49:05 <Cale> > filterM (const [True,False]) [1,2,3]
22:49:06 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
22:49:14 <Cale> bench`: that one?
22:49:30 <bench`> yes, similar
22:49:38 <Cale> bench`: In the list monad, "running" a list is picking an element from it
22:49:57 <vininim> > filterM (const [True,False]) "test"
22:49:58 <lambdabot>  ["test","tes","tet","te","tst","ts","tt","t","est","es","et","e","st","s","t...
22:50:01 <Cale> filterM is like filter, but it runs the condition in whatever monad you're using
22:50:24 <bench`> i don't understand the filter i guess
22:50:33 <Cale> So for each element, regardless of what that element is, the condition is [True, False]
22:50:44 <Cale> and it'll try all possibilities
22:51:01 <oerjan> @src filterM
22:51:02 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
22:51:03 <Cale> So it's like saying "for each element of the list, regardless of what it is, keep it, or don't"
22:51:30 <vininim> > join replicateM 2 ["a","b","c"]
22:51:32 <lambdabot>  Couldn't match expected type `Int' against inferred type `m a'
22:51:39 <vininim> > join (replicateM 2 ["a","b","c"])
22:51:41 <lambdabot>  ["a","a","a","b","a","c","b","a","b","b","b","c","c","a","c","b","c","c"]
22:51:53 <vininim> lol wut
22:51:58 <oerjan> > mapM (\t -> [[t],[]]) "test"
22:51:59 <lambdabot>  [["t","e","s","t"],["t","e","s",""],["t","e","","t"],["t","e","",""],["t",""...
22:52:19 <bench`> ok, then why is it even a filter?
22:53:05 <Cale> Well, you know ordinary filter, right?
22:53:21 <Cale> > filter even [1..10]
22:53:22 <bench`> yes
22:53:23 <lambdabot>  [2,4,6,8,10]
22:53:38 <Cale> It keeps/throws away elements of a list according to a predicate
22:53:57 <Cale> Of course, passing a constant predicate to the ordinary filter function is not so interesting:
22:54:00 <vininim> @src filter
22:54:00 <lambdabot> filter _ []     = []
22:54:00 <lambdabot> filter p (x:xs)
22:54:00 <lambdabot>     | p x       = x : filter p xs
22:54:00 <lambdabot>     | otherwise = filter p xs
22:54:03 <Cale> > filter (const True) [1..10]
22:54:04 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
22:54:07 <Cale> > filter (const False) [1..10]
22:54:08 <lambdabot>  []
22:54:37 <bench`> all make sense to me, but i don't understand the [True, False] filter
22:54:49 <bench`> or the pair filter that oerjan had
22:54:53 <Cale> Now, filterM is a little different, rather than a Boolean result, the condition is allowed to produce a monadic computation which results in a Boolean
22:55:10 <Cale> In the case of the list monad, that's a list of booleans
22:56:02 <Cale> If it was the IO monad instead, the condition would describe some IO to be done in order to obtain a boolean value.
22:56:41 <Cale> (for example, you could filterM a list of filenames based on whether they exist on the disk)
22:56:41 * ddarius poos on the list monad.
22:57:04 * ddarius feels things would be a lot clearer if an abstract type were used rather than lists.
22:57:07 <Cale> In the list monad, "running" the list just means picking an element from it in all possible ways.
22:57:29 <Cale> ddarius: Nah, I think it's much clearer without additional wrapping :)
22:57:49 <wy> Is that a kind of continuation programming?
22:58:03 <Cale> wy: What, using monads?
22:58:22 <wy> I mean picking elements in all possible ways
22:58:31 <bench`> Cale, running the list? i thought filter (non-monadic version) just walk through the list once
22:58:33 <ddarius> Cale: For experienced users, using [] directly is more convenient (though still has issues), but for people just starting to understand it I think it lends itself to an overly concrete view that makes examples seem much more complicated than they are.
22:59:20 <Cale> bench`: The monadic version runs the computation produced by applying the "predicate" to each element.
23:00:00 <Cale> bench`: In the list monad, the "predicate" is then allowed to produce a list of Boolean results. Each one will be used in turn to build up a list of possible filterings.
23:00:42 <Cale> > filterM (\x -> if x `elem` "aeiou" then [False, True] else [True]) "Hello, World!"
23:00:45 <lambdabot>  ["Hll, Wrld!","Hll, World!","Hllo, Wrld!","Hllo, World!","Hell, Wrld!","Hell...
23:00:58 * ddarius would say it non-deterministically picks True or False each time and then collects all solutions.
23:01:30 <hpaste>  glguy pasted "using filterM with a limit to the number of chosen elements" at http://hpaste.org/4532
23:01:46 <Cale> If the element is a vowel, that says to throw it away or keep it, and otherwise, keep the element.
23:01:49 <vininim> what about the Maybe monad?
23:01:57 <oerjan> > flip evalStateT 0 $ filterM (\n -> do m <- get; t <- [True,False]; if n >= m && t then do put n; return True else return False) [1,5,2,3]
23:02:04 <lambdabot>  Couldn't match expected type `StateT s m a'
23:02:32 <Cale> Well, the Maybe monad works. It's a little boring with filterM -- if the predicate ever gives Nothing, then the result is Nothing
23:03:25 <Cale> Just True means keep the element, and Just False means throw it out
23:03:27 <glguy> oerjan, did you look at the paste?
23:04:34 <bench`> Cale, can you show me how 'Hll' was produced?
23:04:38 <glguy> oerjan, you'd need : lift [True,False]   to start
23:04:39 <bench`> in your example above?
23:04:40 <Cale> bench`: sure
23:04:45 <Cale> > filterM (\x -> if x `elem` "aeiou" then [False, True] else [True]) "Hello"
23:04:47 <lambdabot>  ["Hll","Hllo","Hell","Hello"]
23:04:48 <Cale> okay
23:05:06 <Cale> So first the function was applied to 'H'
23:05:07 <oerjan> glguy: not in advance
23:05:10 <oerjan> oh right
23:05:13 <Cale> which is not in "aeiou"
23:05:18 <Cale> so the result was [True]
23:05:22 <oerjan> > flip evalStateT 0 $ filterM (\n -> do m <- get; t <- lift [True,False]; if n >= m && t then do put n; return True else return False) [1,5,2,3]
23:05:23 <lambdabot>  [[1,5],[1,5],[1,5],[1,5],[1,2,3],[1,2],[1,3],[1],[5],[5],[5],[5],[2,3],[2],[...
23:05:27 <Cale> which means the only option is to keep the 'H'
23:05:37 <oerjan> bah, something duplicated too much
23:05:50 <Cale> Then it was applied to 'e', which is in "aeiou", so the result was [False, True]
23:05:54 <vininim> > filterM (Just.even) [1..10]
23:05:55 <lambdabot>   Not in scope: `Just.even'
23:06:06 <vininim> > filterM ( Just . even) [1..10]
23:06:09 <lambdabot>  Just [2,4,6,8,10]
23:06:17 <vininim> boring :/
23:06:35 <Cale> and so what it does is take all the results from using False, and all the results from using True, and concatenate those
23:06:38 <ddarius> filterM (return . p) = return . filter p I suspect
23:06:51 <kikaerter>   Hi! Does anyone have any idea why ghc might say this: (.text+0x46): undefined reference to `gtkzm0zi9zi12_GraphicsziUIziGtkziAbstractziWidget_widgetShowAll_closure' ?
23:06:55 <Cale> bench`: are you already somewhat familiar with the list monad?
23:07:02 <shachaf> kikaerter: Use --make?
23:07:05 <Cale> kikaerter: are you compiling with --make?
23:07:31 <ddarius> Ooo, another question lambdabot could be programmed to automatically answer.
23:07:36 <Cale> bench`: It's rather like list comprehensions
23:07:40 <vininim> > filterM ( \ x -> if (even x) then Just x else Nothing) [1..10]
23:07:40 <lambdabot>   add an instance declaration for (Integral Bool)
23:07:41 <lambdabot>     In the predicate expres...
23:07:42 <kikaerter> shachaf & Cale: Thanks! It worked!
23:07:51 <oerjan> > flip evalStateT 0 $ filterM (\n -> do m <- get; if n >= m then do t <- lift [True,False]; if t then do put n; return True else return False else return False) [1,5,2,3]
23:07:52 <lambdabot>  [[1,5],[1,2,3],[1,2],[1,3],[1],[5],[2,3],[2],[3],[]]
23:08:04 <vininim> > filterM ( \ x -> if (even x) then True else False) [1..10]
23:08:05 <lambdabot>  Couldn't match expected type `m Bool' against inferred type `Bool'
23:08:29 <Cale> > filterM ( \ x -> if (even x) then Just True else Just False) [1..10]
23:08:30 <lambdabot>  Just [2,4,6,8,10]
23:08:32 <ddarius> > filterM (\x -> guard (even x) >> return True) [1..10]
23:08:33 <lambdabot>   add an instance declaration for (Show (m [a]))
23:08:43 <ddarius> > filterM (\x -> guard (even x) >> Just True) [1..10]
23:08:43 <lambdabot>  Nothing
23:09:09 <Cale> bench`: So anyway, the first thing it tries is the False branch, rejecting the 'e'
23:09:12 <glguy> ugh, the pointy hair boss types are making their way onto reddit
23:09:34 <bench`> Cale, so i'm starting to get it, so it essentially does a combinator operation based on all possibilities resulted in the applying the filer to each element?
23:09:38 <Cale> then it proceeds through the two 'l's, each time, it is only given the list of one option which is True
23:09:47 <glguy> people who aren't interested in language advanced for their own sake, just buzzwords and bottom lines :(
23:09:53 <glguy> advances*
23:10:20 <Cale> glguy: yeah, I think there's going to have to be a mass exodus from programming reddit to somewhere new
23:10:31 <ac> simple question: how to turn "Just foo" to "foo"?
23:10:42 <ddarius> glguy: Example?
23:10:42 <Cale> ac: pattern matching with case, usually
23:10:43 <ac> (without a pattern match)
23:10:55 <Cale> fromJust, if you're *really* sure it'll be Just
23:10:57 <glguy> http://programming.reddit.com/info/632u8/comments/c02oc24
23:10:59 <ddarius> ac: There's fromJust, but that just uses pattern matching.
23:11:10 <glguy> this sort of unrelated question keeps popping up
23:11:30 <ac> ok, I guess I actually want a pattern match because obviously there's a possibility it will be Nothing
23:11:41 <glguy> hmm, cars are nice, but where can I fin dpeople to drive them?
23:12:12 <bench`> Cale, was my understanding close?
23:12:14 <ac> glguy: do you not have a license?
23:12:19 <oerjan> ac: there's also fromMaybe
23:12:30 <glguy> ac, the point is that if you build it they will come :)
23:12:47 <Cale> bench`: Uh, it was a little hard to understand what you were saying but the key words "all possibilities" were there :)
23:12:53 <vininim> I thought you could "get out" of a Maybe monad as well
23:13:01 <oerjan> > map (fromMaybe 5) [Nothing, Just 3, Just 2]
23:13:01 <lambdabot>  [5,3,2]
23:13:09 <Cale> @src filterM
23:13:09 <lambdabot> Source not found. You untyped fool!
23:13:16 <ac> glguy: I figured you were making an analogy, just wanted to make sure
23:13:18 <Cale> huh
23:13:43 <ac> glguy: thing is, some new languages just... die
23:13:44 <Cale> filterM _ []     =  return []
23:13:44 <Cale> filterM p (x:xs) =  do
23:13:44 <Cale>    flg <- p x
23:13:44 <Cale>    ys  <- filterM p xs
23:13:44 <Cale>    return (if flg then x:ys else ys)
23:14:24 <Cale> So when it comes to  flg <- p x  what happens is that flg is bound to each of the elements of p x in turn
23:14:48 <Cale> and then ys is bound to each of the elements of filterM p xs, that is, the results of filterM'ing the rest of the list
23:15:15 <Cale> and then if flg happened to be True, you put x:ys into the list of results, otherwise, ys
23:15:19 <bench`> Cale, I get it, thank you very much
23:15:30 <bench`> the source code helped
23:15:34 <Cale> yes :)
23:16:24 <ac> @search fromJust
23:16:24 <lambdabot> Unknown command, try @list
23:16:30 <ac> @where fromJust
23:16:30 <lambdabot> I know nothing about fromjust.
23:16:39 <Cale> > replicateM 3 [1,2,3]
23:16:39 <lambdabot>  [[1,1,1],[1,1,2],[1,1,3],[1,2,1],[1,2,2],[1,2,3],[1,3,1],[1,3,2],[1,3,3],[2,...
23:16:48 <Cale> > replicateM 2 [1,2,3]
23:16:49 <lambdabot>  [[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]
23:16:54 <oerjan> @index fromJust
23:16:55 <lambdabot> Data.Maybe
23:17:04 <bench`> glguy/Cale, ok, this isn't quite what i wanted originally, as i want the combinations only for sequencial elements
23:17:20 <Cale> bench`: Oh, what was it that you originally wanted? :)
23:17:26 <Cale> bench`: I think I missed that.
23:17:33 <glguy> > map (take 2) $ tails "abcd"
23:17:34 <lambdabot>  ["ab","bc","cd","d",""]
23:17:41 <glguy> > map (take 3) $ tails "abcd"
23:17:41 <lambdabot>  ["abc","bcd","cd","d",""]
23:18:13 <Cale> ah
23:18:16 <bench`> i wanted a sequential combination of 2 or 3 elements in a list of words
23:18:22 <Cale> okay
23:18:27 <vininim> @type const [True,False]
23:18:28 <lambdabot> forall b. b -> [Bool]
23:18:39 <vininim> also helps
23:18:49 <Cale> glguy has the right idea, but you still need to be careful nearing the end of the list there.
23:19:26 <Cale> There's a neat trick you can use to avoid that problem
23:19:41 <Cale> (without going through and filtering for elements which are the right length)
23:20:00 <glguy> zipWith const
23:20:05 <glguy> + drop n
23:20:09 <Cale> right
23:20:24 <glguy> combining those is left as an exercise for the reader
23:20:26 <glguy> (or Cale ;) )
23:20:33 <glguy> (who already knows the answer)
23:22:20 <Cale> > let adj n xs = map (take n) $ zipWith const (tails xs) (drop (n-1) xs) in adj 2 "abcde"
23:22:20 <lambdabot>  ["ab","bc","cd","de"]
23:22:25 <Cale> > let adj n xs = map (take n) $ zipWith const (tails xs) (drop (n-1) xs) in adj 3 "abcde"
23:22:25 <lambdabot>  ["abc","bcd","cde"]
23:22:33 <Cale> > let adj n xs = map (take n) $ zipWith const (tails xs) (drop (n-1) xs) in adj 4 "abcde"
23:22:34 <lambdabot>  ["abcd","bcde"]
23:23:21 <Cale> The important thing there is that you're not computing the length of the list
23:23:30 <Cale> > let adj n xs = map (take n) $ zipWith const (tails xs) (drop (n-1) xs) in adj 3 [1..]
23:23:31 <lambdabot>  [[1,2,3],[2,3,4],[3,4,5],[4,5,6],[5,6,7],[6,7,8],[7,8,9],[8,9,10],[9,10,11],...
23:23:42 <Cale> So it'll still work on infinite lists, for instance.
23:23:43 <glguy> > let adj n xs = map (take n) $ zipWith const (tails xs) (drop (n-1) xs) in [id,tail] `ap` adj 3 "abcde"
23:23:44 <lambdabot>  ["abc","bcd","cde","bc","cd","de"]
23:24:14 <glguy> (misses the ab though)
23:24:24 <shachaf> Cale: Well, even if you were computing the length of the list, you'd only do it up to n elements, no?
23:24:46 <bench`> glguy, what is 'ap'?
23:24:48 <glguy> yeha, but you'd be computing lots of lengths
23:24:54 <Cale> shachaf: Well, ideally yes. But not if you stuck a call to 'length' in there
23:25:00 <ac> hmmm. where is my type error: frameLookup :: Symbol -> Frames -> Expr
23:25:08 <ac> frameLookup sym fs = case filter (not.(==) Nothing) $ map (M.lookup sym) fs of { Just x : xs -> x; [] -> error "undefined variable: " ++ sym; } -- ?
23:25:41 <glguy> bench`, given a monadic value that produces a function, and one that produces a value, return a monadic value that produces the value applied to the function
23:25:46 <shachaf> Cale: genericLength + lazy Integral. :-)
23:25:50 <ac> It says I'm returning [Char] instead of Expr
23:25:57 <Cale> shachaf: yeah :)
23:26:08 <oerjan> ac: filter returns a list
23:26:21 <glguy> [<functions>] `ap` [<values>] = [<functions applied to values>]
23:26:35 <glguy> :t ap
23:26:36 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
23:26:38 <oerjan> oh wait
23:26:41 <ac> Frames is: [M.Map Symbol Expr] and Symobl is String
23:26:48 <ac> oerjan: I'm matching a list in my case
23:26:55 <Cale> > [(+2),(*2),(^2),(2^)] `ap` [5,6]
23:26:56 <lambdabot>  [7,8,10,12,25,36,32,64]
23:28:09 <Cale> That's [5+2,6+2,5*2,6*2,5^2,6^2,2^5,2^6]
23:28:19 <bench`> glguy: so in your code above, [id, tail] are the functions?
23:28:19 <oerjan> :t Data.Map.lookup
23:28:20 <lambdabot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> Data.Map.Map k a -> m a
23:28:27 <glguy> bench`, yeah
23:28:48 <Cale> bench`: yeah, so it just takes each element of the list and either leaves it alone, or drops the first element
23:28:54 <ac> oerjan: see, it returns m a not m k
23:29:00 <Cale> But that's not really what you want
23:29:34 <shachaf> > getZipList $ ZipList [(+2),(*2),(^2),(2^)] <*> ZipList [5,6,7,8]
23:29:35 <lambdabot>  [7,12,49,256]
23:29:44 <Cale> > let adj n xs = map (take n) $ zipWith const (tails xs) (drop (n-1) xs) in do n <- [2,3]; adj n "abcdefg"
23:29:46 <lambdabot>  ["ab","bc","cd","de","ef","fg","abc","bcd","cde","def","efg"]
23:29:46 <oerjan> ac: oh wait, you need $ after error
23:30:10 <ac> oerjan: ahah! I knew it was something like that
23:30:24 <ac> damn syntax keeps getting in the way of the semantics
23:31:02 <shachaf> ac: (not . (==) Nothing) === isJust.
23:31:25 <shachaf> (Except more general.)
23:31:27 <oerjan> ac: also, you might want catMaybes instead of filter (not.(==) Nothing
23:31:31 <ac> shachaf: I don't have that imported
23:31:49 <shachaf> ac: And what oerjan says.
23:31:50 <oerjan> they're both in Data.Maybe i think
23:31:57 <shachaf> ac: So import it. :-)
23:32:04 <ac> ok ok!
23:32:52 <ac> I've noticed that whenever my code looks ugly and I paste it on this channel it... gets fixed
23:33:17 <oerjan> :)
23:33:18 <newsham> sometimes they fix spelling too
23:34:47 <bench`>  let adj n xs = map (take n) $ zipWith const (tail xs) (drop (n-1) xs) in do n <- [2,3]; adj n "abcdefg"
23:34:48 <bench`>  
23:35:29 <oerjan> bench`: >
23:35:53 <Cale> http://www.boasas.com/?c=890
23:35:53 <lambdabot> Title: Boy on a Stick and Slither
23:36:05 <ac> "filter (not.(==) Nothing ..." isn't _terribly_ ugly, but "catMaybes" beats it by a lot
23:36:20 <bench`> Cale, was it tails or tail?
23:36:30 <Cale> tails
23:36:34 <oerjan> ac: also need to remove the Just in the match
23:36:38 <Cale> > tails "abcde"
23:36:39 <lambdabot>  ["abcde","bcde","cde","de","e",""]
23:36:57 <Cale> > zip (tails "abcde") (drop 2 "abcde")
23:36:57 <lambdabot>  [("abcde",'c'),("bcde",'d'),("cde",'e')]
23:37:07 <ac> oerjan: yeah I discovered that ;-). Just how much time does it take to become comfortable with Haskell's prelude and standard library?
23:37:10 <Cale> > zipWith const (tails "abcde") (drop 2 "abcde")
23:37:10 <lambdabot>  ["abcde","bcde","cde"]
23:37:18 <Cale> > map (take 3) $ zipWith const (tails "abcde") (drop 2 "abcde")
23:37:18 <lambdabot>  ["abc","bcd","cde"]
23:37:51 <ac> I feel like I'm fairly comfortable with almost all of the language fundementals, but there's a lot to learn in the standard library
23:38:38 <bench`> tais "bac"
23:38:46 <bench`> tails "abcd"
23:38:53 <Cale> ac: yeah
23:39:02 <Cale> ac: There are lots of minilanguages hiding in there :)
23:39:09 <bench`> tails not in scope
23:39:15 <Cale> bench`: It's in Data.List
23:39:25 <Cale> > tails "abcd"
23:39:26 <lambdabot>  ["abcd","bcd","cd","d",""]
23:40:18 <bench`> Cale/glguy, you guys are great, thanks for the help
23:40:30 <newsham> ?karma+ #haskell
23:40:30 <lambdabot> #haskell's karma raised to 7.
23:40:46 <bench`> ac, i'm with you, this is certainly the best place to get help
23:41:27 <wy> What's the common editor for haskell? I found some people using kate for it: http://alberrto.googlepages.com/rectify7.jpg/rectify7-full.jpg
23:41:33 <Cale> ac: It takes quite a while. I think it was about a year for me until I really started feeling comfortable with the library.
23:41:50 <ac> Cale: oo. I have some time then.
23:41:52 <Cale> wy: vim/emacs
23:42:30 <ac> I have a fairly large project in mind that I'm hoping will get me at least half way there
23:42:40 <Cale> wy: But any editor with syntax colouring and the ability to convert tabs into spaces will do.
23:42:53 <newsham> if you keep getting half way closer....
23:43:05 <ac> Cale: or even an editor that doesn't screw with your tabs, and shows tham as 8 characters always, right? ;)
23:43:14 <wy> Cale: But that wouldn't be convenient. You have to switch to command window
23:43:26 <Cale> ac: That would work, but people will still hate you for including tabs in your source files :)
23:43:39 <ac> and possibly kill you in your sleep
23:43:58 <zan> newbie question: I'm making a data declaration with this kind of form: data MyData = Cons1 Bool | Cons2 a    ... and I want 'a' to mean "something of type class X" ... what's the syntax to use?
23:44:28 <newsham> data MyData a = Cons1 Bool | Cons2 a ...
23:44:39 <Cale> zan: It's not as easy to get the effect that you *really* want as it should be, but take newsham's suggestion.
23:44:42 <Cale> You can write:
23:44:56 <Cale> data (X a) => MyData a = Cons1 Bool | Cons2 a ...
23:44:59 <zan> but I want 'a' to be restricted to X s
23:45:08 <zan> ah, I see
23:45:08 <Cale> But it doesn't really do what you want it to do.
23:45:29 <ac> Cale: what does that do in fact?
23:45:30 <Cale> In particular, you'll still have to add (X a) to the type signatures of functions which use these data structures.
23:45:42 <Cale> It just restricts the type of the data constructor.
23:46:10 <Cale> So that Cons2 will give you a type error if you try to apply it to something which doesn't have an instance of the class X
23:46:24 <bench`> is there a mod_haskell or something similar?
23:46:38 <bench`> for web integration with haskell
23:46:40 <zan> so if I use newsham's suggestion, won't I be able to use Cons2 with any type?
23:46:53 <roger`> bench`: Network.CGI works for me
23:46:53 <ac> bench`: not that I know of, but it would be nice. There're Haskell web servers though, and you can use mod_proxy
23:47:05 <Cale> Yes, but you can still restrict the type of a in the functions which work with values of your type.
23:47:13 <newsham> zan: my decl was overly broad -- it would allow any type "a"
23:47:18 <Cale> f :: (X a) => MyData a -> ...
23:47:30 <Cale> That's what's more common.
23:47:57 <ac> one thing that bugs me about writing a bunch of Haskell CGI programs is that even the simplest programs end up bing a couple megs. Also, I've found that template application is not a natural thing for Haskell (the most common thing to do with cgi scripts)
23:47:58 <Cale> Now, if you're using a newish GHC (6.8.x), you can do this:
23:48:04 <Cale> data MyData a where
23:48:14 <roger`> ac, I have a simple one that's about 640k from recollection
23:48:18 <zan> ok, I think I understand... thanks for the help
23:48:19 <Cale> err...
23:48:35 <Cale>    Cons1 :: Bool -> MyData a
23:48:47 <Cale>    Cons2 :: (X a) => a -> MyData a
23:48:50 <roger`> ac, my mistake, 212K
23:49:04 <Cale> and what that will do is to store a typeclass dictionary in with the data
23:49:14 <wy> I'm a little confused the nature of exceptions. What they really are?
23:49:26 <ac> roger`: huh. even my hello world programs are over a meg unless I strip and gzexe them
23:49:40 <bench`> ac/roger, any links that i can check or any code that you can paste?
23:49:41 <Cale> Which means that when you pattern match against Cons2, you don't generate an (X a) constraint for your function
23:49:56 <Cale> ac: yeah, that's the Haskell runtime system
23:49:56 <ac> bench`: no
23:50:00 <bench`> is the size really because that haskell's compiled code is just big?
23:50:04 <roger`> ac, ah, yes I remember now, that's after upx and strip :P 948K just after a strip, but that's still ok with me.
23:50:13 <Cale> No, it's just a big constant term
23:50:31 <roger`> bench`: http://www.cs.chalmers.se/~bringert/darcs/hs-web-tut/
23:50:33 <Cale> They won't grow at that rate :)
23:51:09 <zan> Cale: so that will disallow using Cons2 with non-X a's, and prevent me from needing to include the (X a) => qualifier on my function types?
23:51:17 <zan> because that's pretty much what I'm looking for :)
23:51:18 <Cale> zan: yeah
23:51:26 <Cale> zan: But that's a really new feature.
23:51:43 <zan> I see
23:51:51 <Cale> (It should have been in Haskell 98, but it's taken them a long while to get the type system to the point where it'll manage it)
23:52:12 <zan> well, I'll play around with it... thanks for the help
23:52:14 <zan> Cale++
23:52:42 * Cale wonders if zan will accidentally discover existential types now.
23:52:48 <Cale> oh well :)
23:52:53 <roger`> bench`: I may end up looking into fastcgi soon, but to date Network.CGI has been suitable for low traffic.
23:53:05 <dons> Cale, http://code.haskell.org/~dons/code/hs-plugins/
23:53:06 <lambdabot> Title: Index of /~dons/code/hs-plugins
23:53:18 <Cale> dons: cool :)
23:53:19 <dons> i've updated a few things. not working on openbsd yet
23:53:20 <bench`> roger, thanks, have you done any performance measurement?
23:53:28 <dons> however, i'm happy if it just works on linux atm.
23:53:45 <ac> roger`: I was considering the idea of running all of my cgi through one fastcgi script for convenience
23:53:52 <dons> the lambdabot .cabal file cleans up a *lot* too
23:53:56 <roger`> bench`: no, I only get at most 2-3 hits an hour.
23:54:35 <ac> roger`: how do you do basic text substitution with your cgi programs? For example, how would you write a 404 page?
23:54:48 <roger`> ac, I don't serve pages directly.
23:55:02 <dons> dcoutts: looking over these little bytestring benchmarks i think we can only conclude the old fusion mechanism is messing things up somewhat
23:55:12 <dons> and some of the nice rules (e.g. filter => filterByte) are failing
23:55:29 <ac> I tried to write a 404 page using Haskell and basically concluded it just wasn't the right tool for the job :-P
23:55:36 <dons> dcoutts: i'll set aside some time for a bytestring perf. revsision
23:55:53 <dons> ac, what, using xhtml + cgi?
23:56:02 <dons> it should be a 10 line program...
23:56:09 <Sizur> 2 line
23:56:09 <Cale> dons: I have a feeling that if we use the ghc api better, we can shrink the stuff in Load.hs quite a bit and make it a whole lot saner. Is there a Haddock anywhere that I should know about? :)
23:56:12 <Sizur> :P
23:56:14 <dons> :)
23:56:18 <roger`> ac, a lot of page content, ie. html, css and javascript often doesn't actually need to be part of the output of a haskell program I decided, it keeps things simple.
23:56:27 <dons> Cale: quite probably. i don't think there's any haddocks though
23:56:49 <dons> there's quite a few new web-ish libs appearing.
23:56:52 <Sizur> we need a i18n module
23:56:55 * ac does not like XHTML. I just wanted a simple template. The thing is, Haskell doesn't have heredoc style strings, so it's very awkward to write HTML pages in source. Also, because of monads I couldn't think of a simple source level transformation that would work
23:56:58 <dons> rss, xml, fastcgi, json, ...
23:57:03 <Cale> It feels like we're duplicating functionality.
23:57:08 <dons> and glguy has a lovely templating library
23:57:43 <davidL> dons: Is a Data.Binary.Get.skip'ed byte considered consumed? I want to know if runGetState will return bytes that have been skipped in the middle of a stream.
23:58:16 <ac> dons: which do you recommend?
23:58:17 <dons> skip consume them
23:58:25 <ac> dons: (web-ish libs that is)
23:58:29 <davidL> thanks
23:58:43 <ac> dons: my only requirment is for them not to depend on XML transformations
23:59:07 <dons> my apps have typically been xhtml combinators, or fastcgi + json + js
23:59:19 <dons> glguy is a better person to ask. he's been thinking a lot about templates recently
23:59:33 <dons> oh, i've had fun with rss and xml recently
23:59:47 <dons> just querying, filtering and producing feeds
