00:45:35 <roconnor> @go 165 AUD in USD
00:45:36 <lambdabot> 165 Australian dollars = 142.7085 U.S. dollars
00:55:18 <jsnx> oh no, someone is monetizing lambdabot!
00:56:15 <b_jonas> monetizing?
00:56:18 <b_jonas> how?
01:04:21 <jsnx> by using it to calculate exchange rates!
01:05:08 <oerjan> @go 1 lightyear in furlongs per fortnight
01:05:23 <lambdabot> Plugin `search' failed with: getHostByName: does not exist (no such host entry)
01:05:58 <oerjan> oh wait
01:06:06 <oerjan> @go 1 lightyear in furlongs
01:06:12 <lambdabot> 1 lightyear = 4.70279985 x 10^13 furlongs
01:22:46 <ddarius> > let clamp x | x > 1 = 1 | x < -1 = -1 | otherwise = 1.1*x in iterate clamp 0.1
01:22:51 <lambdabot>  [0.1,0.11000000000000001,0.12100000000000002,0.13310000000000002,0.146410000...
01:23:02 <ddarius> > let clamp x | x > 1 = 1 | x < -1 = -1 | otherwise = 1.1*x in iterate clamp 0.5
01:23:03 <lambdabot>  [0.5,0.55,0.6050000000000001,0.6655000000000002,0.7320500000000003,0.8052550...
01:23:11 <ddarius> > let clamp x | x > 1 = 1 | x < -1 = -1 | otherwise = 1.3*x in iterate clamp 0.5
01:23:12 <lambdabot>  [0.5,0.65,0.8450000000000001,1.0985000000000003,1.0,1.3,1.0,1.3,1.0,1.3,1.0,...
01:24:02 <ddarius> > let clamp x | x >= 1 = 1 | x <= -1 = -1 | otherwise = 1.3*x in iterate clamp 0.5
01:24:03 <lambdabot>  [0.5,0.65,0.8450000000000001,1.0985000000000003,1.0,1.0,1.0,1.0,1.0,1.0,1.0,...
01:26:50 <yitz> > let clamp x | y >= 1 = 1 | y <= -1 = -1 | otherwise = y where {y = 1.3*x} in iterate clamp 0.5
01:26:51 <lambdabot>  [0.5,0.65,0.8450000000000001,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0...
01:29:35 <ddarius> > let clamp x | x >= 1 = 1 | x <= -1 = -1 | otherwise = 1.3*x; dcBlocker (old,new) = (new,new-old) in iterate (second clamp . dcBlocker) (0.0,0.5)
01:29:36 <lambdabot>  [(0.0,0.5),(0.5,0.65),(0.65,0.19500000000000003),(0.19500000000000003,-0.591...
01:30:04 <ddarius> > let clamp x | x >= 1 = 1 | x <= -1 = -1 | otherwise = 1.3*x; dcBlocker (old,new) = (new,new-old) in map snd $ iterate (second clamp . dcBlocker) (0.0,0.5)
01:30:05 <lambdabot>  [0.5,0.65,0.19500000000000003,-0.5914999999999999,-1.02245,-0.56023500000000...
01:30:13 <b_jonas> @type second
01:30:14 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
01:30:24 <b_jonas> eww, I didn't want to know that
01:31:34 <oerjan> hint, set a = (->)
01:31:56 <b_jonas> yep, but I don't know what Arrows are and I think I don't want to know
01:32:00 <ddarius> > let clamp x | x >= 100 = 100 | x <= -100 = -100 | otherwise = 130*x; dcBlocker (old,new) = (new,new-old) in map snd $ iterate (second clamp . dcBlocker) (0,50)
01:32:01 <lambdabot>  [50,6500,100,-100,-100,0,100,100,0,-100,-100,0,100,100,0,-100,-100,0,100,100...
01:32:23 <b_jonas> too many abstractions
01:33:10 <b_jonas> > let clamp x | x >= 1 = 1 | x <= -1 = -1 | otherwise = 1.3*x; dcBlocker (old,new) = (new,new-old) in map snd $ iterate ((clamp `on` snd) . dcBlocker) (0.0,0.5)
01:33:12 <lambdabot>      Occurs check: cannot construct the infinite type: t1 = t1 -> t2
01:33:12 <lambdabot>     Prob...
01:33:40 <oerjan> no, second is not `on` snd
01:33:56 <b_jonas> > let clamp x | x >= 1 = 1 | x <= -1 = -1 | otherwise = 1.3*x; dcBlocker (old,new) = (new,new-old) in map snd $ iterate ((clamp . snd) . dcBlocker) (0.0,0.5)
01:33:56 <lambdabot>      Occurs check: cannot construct the infinite type: a = (a, a)
01:33:56 <lambdabot>       Expec...
01:34:15 <b_jonas> oh, I see
01:34:32 <ddarius> second f (x,y) = (x,f y)
01:34:34 <b_jonas> > let clamp x | x >= 1 = 1 | x <= -1 = -1 | otherwise = 1.3*x; dcBlocker (old,new) = (new,new-old) in map snd $ iterate ((\(x, y) -> (x, clamp y)) . dcBlocker) (0.0,0.5)
01:34:35 <lambdabot>  [0.5,0.65,0.19500000000000003,-0.5914999999999999,-1.02245,-0.56023500000000...
01:34:57 <oerjan> @pl second f (x,y) = (x,f y)
01:34:58 <lambdabot> second = (`ap` snd) . (. fst) . flip ((.) . (,))
01:35:17 <ddarius> > let clamp x | x >= 100 = 100 | x <= -100 = -100 | otherwise = x+x`div`3; dcBlocker (old,new) = (new,new-old) in map snd $ iterate (second clamp . dcBlocker) (0,50)
01:35:18 <lambdabot>  [50,66,21,-60,-108,-64,58,100,56,-59,-100,-55,60,100,53,-63,-100,-50,66,100,...
01:40:00 <oerjan> :t uncurry . (. (,)) . (.)
01:40:01 <lambdabot> forall a b c. ((a, b) -> c) -> (a, b) -> c
01:40:44 <ddarius> That's a roundabout way of writing id
01:41:33 <oerjan> i messed up somewhere
01:41:38 <oerjan> @bot
01:41:38 <lambdabot> :)
01:42:45 <oerjan> what the? :t doesn't work in private message
01:42:58 <oerjan> have to write @type
01:43:06 <b_jonas> yeah
01:43:11 <b_jonas> it did that to me too
01:44:16 <gour> hi, anyone tried qthaskell? it looks cool...just wonder how complete it is
01:44:29 <oerjan> @type uncurry . (. (,)) . flip (.)
01:44:30 <lambdabot> forall a b a1. (a1 -> b) -> (a, a1) -> (a, b)
01:44:35 <oerjan> is what i wanted
01:45:15 <xerox> ?type second
01:45:16 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
01:45:23 <b_jonas> I wrote that too with a fork
01:45:30 <b_jonas> I'd write
01:47:02 <b_jonas> @type let fork f g h x = f (g x) (h x) in \f fork (,) fst (f . snd)
01:47:03 <lambdabot> parse error (possibly incorrect indentation)
01:47:10 <b_jonas> @type let fork f g h x = f (g x) (h x) in \f -> fork (,) fst (f . snd)
01:47:11 <lambdabot> forall a b c. (b -> c) -> (a, b) -> (a, c)
01:47:36 <oerjan> fork = liftM2
01:47:48 <b_jonas> ah, that's useful to know
01:47:55 <b_jonas> what about fork2?
01:48:06 <oerjan> what's that?
01:48:18 <b_jonas> @type fork2 = f g h x y = f (g x y) (h x y)
01:48:19 <lambdabot> parse error on input `='
01:48:25 <b_jonas> @type fork2 f g h x y = f (g x y) (h x y)
01:48:26 <lambdabot> parse error on input `='
01:48:37 <b_jonas> @type \f g h x y - f (g x y) (h x y)
01:48:37 <lambdabot> parse error on input `-'
01:48:39 <b_jonas> @type \f g h x y -> f (g x y) (h x y)
01:48:40 <lambdabot> forall t t1 t2 t3 t4. (t2 -> t3 -> t4) -> (t -> t1 -> t2) -> (t -> t1 -> t3) -> t -> t1 -> t4
01:48:42 <b_jonas> meh
01:48:50 <b_jonas> also there's binary compose
01:48:57 <oerjan> liftM2 . liftM2, i think
01:49:23 <b_jonas> but that's called Something.Something.on as I found out
01:49:56 <b_jonas> Data.Function.on
01:50:00 <oerjan> > (liftM2 . liftM2) (*) (+) (-) 1 2
01:50:02 <lambdabot>  -3
01:50:17 <b_jonas> appears to work
01:50:19 <b_jonas> thanks
01:54:24 <oerjan> :t uncurry . ((,) .)
01:54:26 <lambdabot> forall b b1 a. (a -> b) -> (a, b1) -> (b, b1)
01:57:00 <yitz> gour: looks brand new. first announced on haskell mailing list a few hours ago. sf project basically empty still. in short - sounds exciting!
02:00:22 <gour> yitz: i built it and tried examples. everything works, but not being too familiar with QT I do not have idea how complete it is
02:02:35 <yitz> my main experience with qt is that my desktop machine has been kde for a few years. so I know what it feels like to use it.
02:03:50 <gour> i'm running xfce+xmonad ;)
02:24:38 <yitz> gour: said desktop machine is for use of the whole family. my kids like kde. perhaps i would be a better parent if i got them used to xmonad instead...
02:33:45 <gour> yitz: he he, xfce is also nice
02:36:38 <yitz> you mean with its default window manager, i suppose. even so, i would have a lot of explaining to do if i all of a sudden dump them into yet another new environment. when the dust settles, i'd probably find Windows installed on the machine.
02:37:03 <gour> with default as wel lwith xmonad
02:37:26 <gour> then better stay with kde :-)
02:39:36 <yitz> if i had the time, i could probably convince kdm to launch xfce when i log in and kde for everyone else. i would also need to find time to learn xfce/xmonad. then, after looking over my shoulder for a while, the kids would start to get jealous and start switching over. dastardly plan, eh? someday, i hope.
02:40:30 <gour> xmonad with xfce is easy, kill xfwm4 & run xmonad. that's all
02:43:14 * osfameron is considering xubuntu for next install, but not sure -- I already know the ways gnome sucks, so the hate is fairly comfortable now
02:44:03 <gour> osfameron: try Arch Linux with xfce
02:44:27 <osfameron> gour: Arch?
02:44:59 <gour> osfameron: http://wiki.archlinux.org/index.php/Arch_vs_Others
02:44:59 <lambdabot> Title: ArchWiki :: Arch Compared To Other Distros - ArchWiki
02:45:16 <gour> osfameron: http://wiki.archlinux.org/index.php/The_Arch_Way
02:45:16 <lambdabot> Title: ArchWiki :: The Arch Way - ArchWiki
02:45:28 <osfameron> no
02:45:38 <osfameron> in the Arch vs Ubuntu section, I clearly don't want to be using Arch
02:45:43 <osfameron> I don't want to compile my own kernel
02:45:58 <osfameron> I don't want bleeding edge projects, and I don't want to have to tinker to get things to work
02:46:10 <gour> osfameron: where did yo uread that? i use stock kernel. never compiled my own on Arch
02:46:27 <kalven> from the link you posted
02:46:28 <osfameron> gour: on the Arch_vs_Others page
02:46:57 <osfameron> I want to install on my laptop and not have to faff about to get hardware recognised, power management working, or network connections accepted
02:47:15 <osfameron> (and tbh, even ubuntu is too much faffing on the last 2 fronts, though it gets better with every release)
02:47:25 <gour> osfameron: it says "If you like..", not that you "must"
02:48:03 <osfameron> gour: fair enough.  But if that's the mindset, then it leads me to believe other things may not be as smooth as with ubuntu
02:48:10 <gour> anyway, if you like to run bunch of extra services you don't need, your choice ;)
02:48:47 <osfameron> like the fact that with recent network manager (which almost always works :-) I don't even have to type sudo ifup eth1 and set keys etc. to get connected to wireless.  woot!
02:49:02 <gour> osfameron: same here
02:49:32 * gour uses gnome front-end for NM
02:49:37 <osfameron> fair enough
03:39:12 <hpaste>  Odissey pasted "parsing" at http://hpaste.org/4662
04:28:05 <EvilTerran> remind me; for yacc-esque grammars do you write "foos ::= foos SEP foo {...} | {...}" or foos ::= foo SEP foos {...} | {...}"?
04:28:43 <EvilTerran> s/::=/:/, but anyway
04:29:23 <opqdonut> the latter
04:29:28 <opqdonut> otherwise you're left-recursive
04:29:42 <oerjan> either, yacc/LALR(1) generators can handle both kinds
04:29:52 <EvilTerran> ah, okay
04:30:22 <opqdonut> oerjan: does yacc do transformations that take care of the left-recursiveness?
04:30:26 <oerjan> i may vaguely recall that they prefer left recursion
04:30:33 <opqdonut> oh, okay
04:30:45 <opqdonut> ah yes LR grammars, nvm
04:32:07 <EvilTerran> thanks
04:51:02 * EvilTerran wants first-class patterns
04:51:33 <EvilTerran> i can't fathom how they'd work, but i still want 'em
04:52:55 <EvilTerran> or at least a [p|...|] construct in TH
04:53:05 <opqdonut> what would that do?
04:54:13 <opqdonut> > let pat = (\x@(a:as) -> x) in pat [1,2,3] -- isn't this first-class enough?
04:54:17 <lambdabot>  [1,2,3]
04:55:16 <EvilTerran> [p| Left (0,x) |] = ConP 'Left (TupP [LitP (IntegerL 0), VarP 'x]) :: Pat
04:55:33 <EvilTerran> well, with that approach, you've got exceptions to worry about
04:56:07 <opqdonut> well yeah, but that's the way it is with patterns
04:56:09 <EvilTerran> something using case/return/fail would be an improvement, but horribly verbose
04:57:50 <EvilTerran> lambda-match is probably what i really want (http://hackage.haskell.org/trac/haskell-prime/ticket/114)
04:57:50 <desegnis> Lambdas with multiple branches could be fun... sum = \[] -> 0; \(x:xs) -> 1 + sum xs
04:57:52 <lambdabot> Title: #114 (introduce lambda-match (explicit match failure and fall-through)) - Haskel ...
04:58:38 <desegnis> (or rather, without the second \, but then the syntax would be ambiguous, I guess)
04:59:44 <EvilTerran> either way, the syntax would be rather awkward
05:00:00 <opqdonut> yeh
05:00:13 <EvilTerran> i believe the haskell' proposal for multi-way lambda is "sum = case of [] -> 0; x:xs -> x + sum xs"
05:00:39 <EvilTerran> "case of {...}" desugaring to "\x -> case x of {...}"
05:00:53 <opqdonut> yeah that'd be simple
05:00:55 <desegnis> right, that's cleaner.
05:01:48 <desegnis> And I may find that even cleaner than the usual sum [] = 0; etc.
05:02:08 <EvilTerran> it wouldn't work with multiple parameters, mind
05:02:30 <oerjan> hm, why not actually
05:02:51 <EvilTerran> the desugaring doesn't make sense with multiple parameters
05:02:58 <EvilTerran> you can only case/of on one value
05:03:14 <EvilTerran> and implicit tupling would be very dubious
05:03:33 <desegnis> Hm right, case x y of ... means something else
05:04:43 <desegnis> So I like multiple equations better again ;)
05:04:56 <stevan> is it possible to pattern match on functions? say something like: let apa f = case f of show -> 1; fst -> 2?
05:05:10 <oerjan> stevan: no
05:05:21 <desegnis> stevan, no, because you cannot compare functions via (==) either
05:05:34 <EvilTerran> desegnis, well, that's not exactly why
05:05:39 <EvilTerran> but it's because functions are abstract
05:05:56 <desegnis> EvilTerran: well, both inpossibilities have the same reason
05:06:24 <EvilTerran> i guess so. it's more that the inability to pattern-match => the lack of (==), tho, rather than vice-versa
05:06:54 <desegnis> alright
05:06:55 <oerjan> functions are usually thought of as determined by their values on arguments - and finding out whether two functions are equal in that way is at best hideously expensive
05:07:36 <desegnis> stevan, also note that (case f of pi -> ...) would not compare f and pi, but rather bind pi to f in (...)
05:07:57 <desegnis> stevan, but you know that probably
05:08:44 <oerjan> and in principle undecidable
05:43:58 <kolmodin>  mmapped bytestrings? neat!
06:05:05 <hotgklub> http://www.hotgirlclub.net.ms check out hot girl movies
06:05:06 <lambdabot> Title: hotgirlsclub
06:11:17 <opqdonut> spam :(
06:15:14 <MikeLowrey_14046> someone can help me pls? i got a problem. here is a screen http://www.pennergame.de/ref.php?refid=9250149
06:15:15 <lambdabot> Title: Pennergame
06:16:58 <roconnor> what happens when I click on that link?
06:17:10 <Saizan> he gets some points
06:17:18 <oerjan> aha
06:17:30 <roconnor> does lambdabot clicking count?
06:17:32 * oerjan won't be trying with wget anyhow
06:17:47 <Saizan> but you can also report him as spammer, if you know enough german :)
06:18:02 <roconnor> @bab en de spammer
06:18:03 <lambdabot>   Spammer
06:18:04 <Saizan> i think so
06:24:42 * EvilTerran 's brain explodes at the HList paper
06:25:20 <oerjan> CLEANUP IN LIBRARY AISLE 2
06:25:39 * EvilTerran blinks, pokes his brain
06:25:50 <pejo> roconnor, how's your dutch?
06:25:57 <roconnor> pejo: poor
06:28:10 <pejo> Makes the spam-reporting tricky, I guess.
06:35:23 <oerjan> @users
06:35:24 <lambdabot> Maximum users seen in #haskell: 434, currently: 352 (81.1%), active: 8 (2.3%)
07:13:06 * oal` builds ghc 6.8.2
07:25:00 <MyCatVerbs> Does it matter at all which version you bootstrapped ghc with?
07:37:52 <Zao> MyCatVerbs: Version of what? ghc, gcc?
07:38:25 <Zao> MyCatVerbs: The current GHC can be built with fairly old GHCs.
07:46:14 <MyCatVerbs> Zao: ghc, I mean. I know you *can* build with, oh, anything newer than 5.0.something, but does it make any difference to the speed of the compiler at the end which version you use?
07:46:49 <ndm> MyCatVerbs: no, it doesn't
07:47:10 <ndm> MyCatVerbs: stage 1 builds GHC <new> with GHC <old>, stage 2 builds GHC <new> with GHC <new>
07:47:33 <ndm> you should end up with a binary identical version in all cases
07:49:26 <Zao> MyCatVerbs: A good trick for getting it up and running on a platform without any GHC on is to bootstrap an older GHC onto the target system, and use that one to build a new one natively.
07:49:49 <Zao> Mostly because the porting guide is a bit inaccurate for the recent GHCs in my experience.
07:51:03 <oal`> porting aside
07:51:22 <oal`> anyone builds debian packages of fresh ghc?
07:51:32 <oal`> and, more accurate, does anybody need them?
07:51:45 <oal`> 'cause I'm currently building it in $HOME
07:52:07 <oal`> but with a bit more pain I could also produce a valid .deb for debian etch
07:53:33 <ndm> is there not already a .deb?
07:53:43 <ndm> if there isn't, i'm sure GHC would be grateful of a contributed one
07:54:56 <oal`> i all repositories i've seen, it's only 6.6.1
07:55:12 <oal`> okay, I'll give it a try then
07:55:23 <nomeata> Igloo: Hi. Have you considered uploadeing libghc6-x11-dev 1.4.1, even before ghc6.8 packages are ready?
08:02:45 <MyCatVerbs> Zao, ndm: ah, cool, thanks. I was mainly wondering since ghc stores, in addition to its own version, the version of the installation of ghc that was used to build it.
08:03:50 <MyCatVerbs> oal`: building 6.8.2 when you already have a 6.6.1 installation is *trivial*. Just download the two tarballs, tar xzvf, cd ghc-^I, ./configure, make, go eat dinner, make a sandwich or something, make install, done. ^_^
08:04:10 <oal`> that's what I am doing
08:04:13 * MyCatVerbs nods.
08:04:30 <MyCatVerbs> But, resultingly, I don't really care that $DISTRO (in my case Ubuntu) doesn't have 6.8 yet.
08:04:41 <oal`> but I mean, not everybody has to go though it, if he just wants a fresh ghc
08:04:45 <MyCatVerbs> Having .debs would be nice, though.
08:04:52 <oal`> oh, ubuntu doesn't have it either?
08:04:56 <MyCatVerbs> True. Plus apt-get can uninstall things much more cleanly.
08:04:58 <pejo> Why the rush for the new version? Lots of stuff on hackage is still not building cleanly with 6.8.
08:05:18 <MyCatVerbs> pejo: shiny. Faster. Also shiny. Did I mention shiny?
08:05:20 <Valodim_> would it help the new version if they did?
08:05:21 <hpaste>  (anonymous) annotated "parsing" with "(no title)" at http://hpaste.org/4662#a1
08:05:32 <oal`> okay, just after I've build it, I'll take the old .deb apart and try to build a new one
08:05:34 <oal`> meh
08:05:37 <MyCatVerbs> oal`: it didn't last week, which is the last time I checked. (Running 7.10)
08:05:48 <pejo> MyCatVerbs, just set your prefix to /wherever/ghc682, and rm -rf will clean equally well compared with dpkg.
08:05:59 <nomeata> I have a 6.8 debian package floating around, but no extra-libs yet
08:06:08 <oal`> MyCatVerbs, okay. I have Debian Etch, so it's worse for me
08:06:12 <MyCatVerbs> pejo: this is true. Mental note that I shouldn't leave prefix on /usr/local when I build things. >_>
08:06:13 <oal`> oh
08:06:18 <oal`> nomeata, url?
08:06:28 <pejo> MyCatVerbs, that way lies madness.
08:06:46 <oal`> that way lies gentoo
08:06:46 <MyCatVerbs> pejo: I don't really care... I have /home on a seperate partition to /.
08:07:17 <pejo> MyCatVerbs, so you wipe /usr/local on OS-upgrade?
08:07:21 <nomeata> oal`: only local. It‚Äôs a re-compilation of igloo‚Äôs package for amd64 that‚Äôs in the haskell-unsafe repository. Not sure if it‚Äôs really good at that state, though.
08:07:22 <MyCatVerbs> pejo: so it's pretty much trivial to nuke & pave the whole system.
08:07:30 <MyCatVerbs> pejo: no, I unmount /home and wipe /. ;)
08:07:39 <oal`> my initial problem was some troubles using HaXml. so, I thought to myself, first you get a fresh compiler
08:07:46 <oal`> nomeata, ok
08:07:50 * MyCatVerbs is too lazy to seperate /, /usr, /etc and so on into different mountpoints.
08:08:15 <oal`> it'll try to make a full-fledged .deb from my local build, but I don't know how good it'll be
08:08:19 <MyCatVerbs> Plus this way I don't get into problems wondering whether I gave enough space to /var or /usr or /usr/local or whatever.
08:08:24 <pejo> MyCatVerbs, for a single user machine there isn't much of a reason. But /usr/local might be shared between lots of machines, for example.
08:08:38 <MyCatVerbs> Doesn't Debian come with tools to automagically turn anything built with autotools into a .deb?
08:08:50 <MyCatVerbs> Arch Linux does, I seem to remember.
08:08:55 <oal`> oh, I just give 8-10 gigs to /usr, 2 gigs to /var, 1-1.5 gig to /
08:08:57 <oal`> meh
08:09:07 <oal`> if that, I haven't found them
08:09:12 * MyCatVerbs just gave 32 gigs to / and 260 to /home
08:09:17 <pejo> MyCatVerbs, there's plenty of ways to make software that abuses autotools and doesn't behave the way you'd expect it to.
08:09:19 <oal`> you *can* take a ready tree and package it to .deb
08:09:31 <MyCatVerbs> pejo: true. :/
08:09:45 <MyCatVerbs> pejo: I've never seen /usr shared.
08:10:18 <oal`> the thing, that actually belongs to a separate partition is /var
08:10:44 <pejo> MyCatVerbs, might be useful if you have diskless terminals or so.
08:10:44 <MyCatVerbs> pejo: more common, I think, is to mount /home via NFS or Coda or something, then leave everything else on ext3 on the local disk, cloned between all the machines.
08:11:01 <oal`> yeah
08:11:19 <MyCatVerbs> True, but I'm beginning to strongly doubt the utility of making the workstations diskless.
08:11:22 <oal`> you share /usr, if you are in a facility with 1024 similar computers
08:11:28 <oal`> like... university campus
08:11:30 <pejo> MyCatVerbs, what good will that do? The machine won't work anyways if your home directory is missing, so the local installation is of no use.
08:12:11 <MyCatVerbs> pejo: throughput. The network doesn't really need the extra load. Plus, disks aren't actually all that expensive.
08:12:41 <oal`> I think it's more the syncronisation problem
08:12:43 <MyCatVerbs> pejo: plus it comes out simpler that way, which is always nice. Aesthetically, and for reliability.
08:12:59 <oal`> "we want equal setup on all this machines and we want it now"
08:13:27 <Botje> giggle.
08:13:30 <MyCatVerbs> (When I say "reliability", I don't mean that the software is less likely to spontaneously break. I mean that you're less likely to accidentally screw something up yourself.)
08:13:48 <Botje> my toy haskell http server is beating a c++ implementation by a margin of 400% :)
08:14:06 <Botje> (c++ guy has been doing it for ~ 15 years now)
08:14:17 <oal`> oh
08:14:57 <MyCatVerbs> oal`: this is true. But on the flip side, you a) could just have disk'd machines self-upgrade over the network when they boot up, and b) it's rather handy (in a pinch) to have swap space on the local box. Remote swap is suicidal, and having the OOM killer murder your processes isn't fun.
08:15:15 <MyCatVerbs> Botje: ...sex! How finely tuned is your code?
08:15:33 <Botje> MyCatVerbs: "it compiles! let's test it!"
08:15:39 <MyCatVerbs> Botje: should we be thinking, "newbie Haskell", "idiomatic Haskell", "tuned Haskell"...
08:15:44 <oal`> MyCatVerbs, b) - true. swap should be local
08:15:54 <Botje> MyCatVerbs: hang on, i'll hpaste it
08:15:59 <pejo> MyCatVerbs, shrug, all the places I've worked at has had one or several network-shared volume for software for unix machines. Only things like ClearCase and parts of I-DEAS have been installed locally. And those local installations have been a pain to maintain, compared to fixing things in just one place (the shared volume).
08:16:16 <MyCatVerbs> ..."fucking C programmers, I'll fucking show them... IVOR! THROW THE SWITCH! UNBOXXOR TEH TUPLES!!!"?
08:16:33 <Botje> :)
08:16:51 <MyCatVerbs> Followed by, "It's alive. EEEET EEES AAAALLIIIIIIIIIIIIIVE! MWAHAHAHHAHAHAH!"
08:17:01 <oal`> MyCatVerbs, I think, that machines at my old uni had local drives for / and /boot and all that, I think /var was also local. /usr was remote and /home was naturally remote
08:17:08 <pejo> oal, the synchronization problem is very much real I'd say. Even with just 200 machines.
08:17:37 <Botje> Due to the ongoing War on Spam, pastes may not contain HTML links.
08:17:38 <Botje> grar :[
08:17:46 <MyCatVerbs> pejo: hee, my university upgrades the damn machines more often than they upgrade the software. CentOS 5. Bleh.
08:18:02 <Zao> MyCatVerbs: At least it's not Debian Ancient.
08:18:07 <Botje> MyCatVerbs: http://sial.org/pbot/29416
08:18:07 <lambdabot> Title: Paste #29416 from "Botje" at 84.198.74.149
08:18:09 <MyCatVerbs> pejo: AFAIK that's mainly because the vendors for various commercial bits of software don't support anything non-shite.
08:18:34 <pejo> MyCatVerbs, exactly. :-)
08:18:41 <MyCatVerbs> Zao: it's a clone of RHEL. Methinks Debian would be an upgrade. x_x
08:18:47 <oal`> pejo, do you mean remote /usr or replicated local /usr?
08:19:05 <MyCatVerbs> pejo: (since they have various simulation tools, Maya, other bits and pieces that I don't really know about...)
08:19:36 <Zao> Supporting Linux is a massive pain. As a vendor, you have to pick your set of supported platforms and stick to it.
08:20:10 <pejo> oal, replicating things gives a maintainance burden, but I was more talking about something roughly equivalent of /usr/local. I see no problem in having a local echo or du on the machine, that the OS vendor will support.
08:20:25 <MyCatVerbs> Bleh. Software written in the best way possible on Linux is perfectly fine.
08:20:30 <oal`> that goes in /bin, I think
08:20:41 <MyCatVerbs> Where, "the best way possible on Linux" is defined to be exactly equal to "the best way possible on Windows".
08:21:01 <oal`> oh
08:21:02 <MyCatVerbs> That is to say, you put the binaries in place, you run them, and they fucking work with no dicking around.
08:21:21 <oal`> MyCatVerbs, I think we are going strait into a flame war
08:21:43 <oerjan> @yow
08:21:44 <lambdabot> Gee, I feel kind of LIGHT in the head now, knowing I can't make my
08:21:44 <lambdabot> satellite dish PAYMENTS!
08:21:49 <oal`> because the "windows way" is to build a gui and let everything develop around it
08:22:02 <MyCatVerbs> oal`: only in that I'm strongly in favour of zero-installation software on Windows, and observe that writing software in that manner makes it trivial to support on other OSes, too.
08:22:05 <pejo> oal, what is put in /bin is OS dependent usually. And perhaps version dependent too.
08:22:32 <MyCatVerbs> oal`: oh, no, I don't mean that. I mean "the best way that you can do things on Windows", not "the way you do things on Windows". Subtle difference.
08:22:45 <oal`> and "unix way" is to build a shell nobody can use and a gui, that works with the previous version of the shell
08:22:46 <MyCatVerbs> oal`: compare and contrast, Foxit Reader 1.x and Adobe Acrobat 8.
08:23:04 <oal`> MyCatVerbs, ok, know I know what you mean
08:23:17 <MyCatVerbs> FR1.x was the absolutely perfect way to do it. You put the executable in any directory, run it and it just goddamn works.
08:23:29 <MyCatVerbs> Adobe 8 does all kinds of random shit.
08:23:36 <oal`> pejo, surely /bin is OS dependent. but most of the time you have the same OS everywhere you share you /usr
08:23:50 <MyCatVerbs> (Newer versions of Foxit are a disappointment. What the Hell happened to that wonderful zero-install legacy? Damn them!)
08:23:54 <oal`> MyCatVerbs, I use xpdf on my Linux box
08:24:03 <oal`> yes, yes, yes
08:24:20 <MyCatVerbs> oal`: icky, kill it. ghostview for the win! (Now that is worth a flamewar. ;)
08:24:46 <oal`> that's the fortune of windows software. it starts with a handy little thing, which does exactly what it needs to. and then it grows into a monster
08:25:04 <oal`> MyCatVerbs, xpdf > gv on pdflatex output. Yeah, war!
08:25:12 <pejo> oal, oh, yeah. I wasn't originally talking about sharing /usr though, since I don't really see a problem with letting the OS vendor deal with the stuff in /usr/bin, and most vendors supply some kind of net installation (jumpstart, kickstart, etc) for their OS.
08:25:16 <MyCatVerbs> Botje: what the fuck. How does a C++ programmer succeed in writing a program slower than that!?
08:25:22 <Botje> no idea :)
08:25:47 <MyCatVerbs> Maybe they use raw OS threads, and they spam the CPU scheduler into oblivion? (Green threads FTW.)
08:25:55 <Botje> yep
08:26:01 <Botje> the library he wrote uses pthreads
08:26:09 <MyCatVerbs> Oh.
08:26:12 <oal`> pejo, err... is not one of the purposes of sharing /usr - to share /usr/bin?
08:26:17 <MyCatVerbs> Tell him to recompile it on FreeBSD instead of Linux.
08:26:33 <oal`> MyCatVerbs, now that's cheating! ;)
08:26:42 <MyCatVerbs> Fiver says it'll get *way* faster. Linux is supposed to have absolutely dogshite performance for ridiculous numbers of OS threads.
08:26:47 <Botje> does their pthread implementation not suck as much? :)
08:26:53 <oal`> freebsd is considered to have a better networking stack that linux
08:27:18 <Botje> I'm running an openbsd router myself
08:27:43 <Botje> apart from the memory leaks I got with 4.1 and my 3com card crashing 4.2, it's nirvana :)
08:27:46 <MyCatVerbs> Botje: dunno, I suspect their pthread implementation might actually be worse. But their CPU & IO schedulers deal with masses of processes and/or threads much better than Linux did last time I checked.
08:27:55 <aes2> How can FreeBSD have a better networking stack when Linux could simply important FreeBSD's network stack?
08:28:16 <MyCatVerbs> aes2: license wars. 4-BSD versus GPL. :)
08:28:21 <aes2> s/important/import
08:28:34 <MyCatVerbs> oal`: no, that's... well, that's cheating, but what's wrong with cheating? That's what engineering is, dammit.
08:28:50 <Botje> :)
08:29:07 <MyCatVerbs> aes2: the 4-clause BSD license includes an attribution clause which makes it impossible (in theory, at least) to use BSD code in GPLed projects.
08:29:24 <MyCatVerbs> (I think the 3-clause and 2-clause versions of BSD are fine.)
08:29:32 <aes2> MyCatVerbs: do they still use that for new code?
08:29:41 <pejo> oal, sigh. We were originally talking about sharing 'software'. I interpreted 'software' as the maintainance heavy stuff, like ClearCase, I-DEAS, and CFX - not the small bits and pieces that come along with the OS like echo and df. You obviously interpreted it differently.
08:29:54 <oal`> MyCatVerbs, then we already have an improved version of cheating in form of lightweight thread in haskell RTS
08:30:27 <MyCatVerbs> oal`: e.g. got a program that stores its whole database in millions of tiny filesystem entries? Runs slow as dog ass? Switch filesystem to reiserfs and watch it fly (hopefully).
08:30:53 <oal`> pejo, oh. Okay. But wouldn't it be easier to share something like /opt, where all that heavy stuff goes?
08:31:28 <MyCatVerbs> oal`: yyyyyep, precisely. Using green threads instead of OS threads is a pretty cool cheat. But it's fine in a programming language that is, ah, memory-safe.
08:31:56 <oal`> MyCatVerbs, that makes me think about recent "use impicite parallelism and make it fly" ;)
08:32:05 <MyCatVerbs> aes2: I don't know, I have a vague feeling that it's completely impossible to switch - the new code is all derived from the old code, so probably they can't.
08:32:24 <oal`> MyCatVerbs, yes. And lazy evaluation may be another such cheat
08:32:24 <MyCatVerbs> oal`: *nodnod* same thing, yes.
08:33:08 <pejo> oal, that's one possible thing to share. /usr/local is another common one. Or make a /oal and share that one. :-)
08:33:54 <oal`> now define "cheat" as "recent break-through in computing" and other marketing hot air and we are done ;)
08:34:20 <MyCatVerbs> oal`: nononono, completely backwards.
08:34:31 <oal`> pejo, heh. actually /oal should be sustituted to /home
08:34:33 <oal`> MyCatVerbs, ?
08:34:52 <oal`> * substituted
08:34:52 <MyCatVerbs> oal`: I don't define the word cheat myself. What I do instead is define the word engineering to mean "cheating". And it all works from there on. :)
08:35:04 <oal`> oh, okay
08:46:30 <matthew-_> happy christmas #haskell
08:47:35 <r3m0t> merry christmas
08:47:44 <Valodim_> merry christmas
08:58:46 <conal> merry christmas
08:59:44 <wy> Merry christmas!
08:59:55 <wy> conal: You are a early bird
09:00:17 <conal> @localtime wy
09:00:18 <lambdabot> Local time for wy is Tue Dec 25 12:00:17
09:00:33 <conal> wy: where are you?
09:01:08 <wy> conal: Not really very early ;-) I'm here in NY
09:01:22 <conal> oh -- i remember: cornell
09:01:40 <conal> there are two deer walking outside our window
09:01:55 <conal> four
09:02:06 <roconnor> dinner!
09:02:17 <conal> roconnor: yum!  enjoy.
09:02:52 <conal> roconnor: xmas in holland?
09:02:52 <wy> Christmas present!
09:03:09 <conal> wy: tell more!
09:03:13 <roconnor> sure
09:04:41 <conal> roconnor: i have a completely new FRP implementation, based on threads.  the (non)caching issue that bit you also bit me.  the new system solves it very elegantly.
09:04:46 <conal> @wiki reactive
09:04:47 <lambdabot> http://www.haskell.org/haskellwiki/reactive
09:06:30 <wy> I'm trying to convert my program into tex literate style, but it seems to clutter the code somewhat. Is it normal to finish a project first, and then convert it into lhs?
09:20:15 <Heffalump> 'lo all
09:20:37 <noteventime> coi
09:25:13 <Philippa> afternoon
10:34:07 <wy> What's the nearest char to a circle?
10:35:21 <Spark> unicode
10:35:45 <Saizan> o?
10:35:46 <Cale> ‚àò
10:36:16 <wy> as long as it can be displayed in emacs
10:36:34 <Cale> ‚óã
10:36:41 <Cale> ‚óØ
10:36:53 <Cale> ‚óè
10:37:09 <wy> Nice!
10:37:59 <wy> But the inf-haskell doesn't display these correctly. They can be displayed in the haskell-mode buffer
10:40:05 <Spark> emacs huh?
10:40:07 <Spark> unicode is out then
10:40:22 <Spark> try \<ridiculouslylongwindedsymbolname>
10:40:28 <osfameron> new emacs has unicode doesn't it?
10:40:34 <Spark> should bloody hope so
10:40:38 <Spark> it's only about 14 years old
10:41:01 <osfameron> I think steve yegge blogged about it last year
10:41:16 <Spark> "the only editor that support psychiatry but not text"
10:41:30 <osfameron> there were patches for it earlier, but it wasn't in a released verson till then (But I could be wrong.  I'm a vim user, so largely don't care :-)
10:41:47 <Spark> indeed
10:41:54 <Spark> if proof general wasn't an emacs app i wouldn't care either
10:42:14 <pejo> osfameron, apparently the unicode stuff is .. not that robust. Menus and commands with edv are still messy to get to work properly, afaik.
10:42:20 <pejo> osfameron, Â‰ˆ, I mean.
10:42:25 <wy> Geometry.hs: UTF-8 Unicode Java program text
10:42:31 <osfameron> 19:41 <Spark> if proof general wasn't an emacs app i wouldn't care either
10:42:31 <osfameron> 19:42 <pejo> osfameron, apparently the unicode stuff is .. not that robust. Menus and commands with edv are still messy to
10:42:33 <wy> from file ;-)
10:42:34 <osfameron>              get to work properly, afaik.
10:42:35 <osfameron> oops, sorry
10:43:05 * osfameron really really dislikes unicode
10:43:26 <osfameron> or at least, I dislike the fact that the unicode codechain doesn't Just-Work
10:44:35 <wy> Geometry.hs: ASCII Java program text
10:46:02 <pejo> Spark, does proof-general work well?
10:48:07 <Spark> pejo: well enough given its limitations
10:48:09 <Spark> it's usable
10:48:16 <Spark> i just wish there was an alternative
10:48:26 <Spark> and that a damn student would accept it as a project
10:48:29 <Spark> dr who time
10:48:39 <osfameron> yay!
10:52:16 <Cale> Hey, new Catsters videos :)
10:52:20 <Cale> http://uk.youtube.com/watch?v=mw4IhOLhDwY
10:52:21 <lambdabot> Title: YouTube - Distributive laws 1
10:57:58 <Cale> http://programming.reddit.com/info/63ud0/comments/
10:59:12 <glen_quagmire> return $ case x of ...  is this ok?
10:59:16 <glen_quagmire> I get indentation error
10:59:45 <Cale> It should be fine.
10:59:55 <Cale> Check the whitespace after the of
11:00:03 <Cale> and make sure that the cases line up
11:00:34 <glen_quagmire> should there be a whitespace? i set up my texteditor to remove all trailing whitespaces at the end of a line
11:01:04 <Cale> glen_quagmire: I mean on the next line, potentially.
11:01:24 <Cale> glen_quagmire: The first non-whitespace character after the 'of' will set the indentation level for that block.
11:03:11 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/4663
11:03:32 <glen_quagmire> oh forgot to putin title and uncheck announce
11:03:59 <glen_quagmire> in vim, I don't see anything there when I do :set list
11:04:00 <qebab> import qualified Foo is the Right Way to do it, right? (alternatively as Bar)
11:04:22 <glen_quagmire> qebab: i do import qualified Foo as Bar  . but i'm a noob
11:04:30 <Cale> glen_quagmire: otherwise?
11:04:41 <Cale> glen_quagmire: that should probably be   _ -> Atom atom
11:05:02 <qebab> glen_quagmire: Yeah I prefer to keep the namespaces seperated as well but I don't know what's the norm
11:05:25 <glen_quagmire> oh darn. when I qualify Parsec, I have to do Parsec.<|>
11:05:44 <glen_quagmire> Cale: thank you!!
11:06:31 <Cale> glen_quagmire: hehe, help out my reddit submission :)
11:06:48 <Cale> (supposing that you have an account ;)
11:06:57 <glen_quagmire> i do. let me check
11:07:19 <glen_quagmire> you mean upmod your post? i don't see something posted by Cale
11:07:31 <Cale> http://programming.reddit.com/info/63ud0/details
11:08:08 <oklopol> "<glen_quagmire> oh darn. when I qualify Parsec, I have to do Parsec.<|>" <|>... so typical of you
11:09:46 <glen_quagmire> i like casters. the female teacher
11:09:59 <Cale> Eugenia Cheng is great, yeah
11:10:20 * glen_quagmire imports Text.ParserMonads.Parsec (<|>)
11:12:47 <glen_quagmire> no it should be import Text.ParserCombinators.Parsec ((<|>))
11:13:20 <glen_quagmire> I also do import qualified System.Environment as Sys;  import qualified System.IO as Sys   so that I can do python style: Sys.putStrLn "hello"
11:13:32 <glen_quagmire> no, it's not python style. sorry
11:14:54 <glen_quagmire> :i otherwise
11:15:04 <glen_quagmire> otherwise :: Bool       -- Defined in GHC.Base
11:15:17 <glen_quagmire> so,   _ ->  blah  is same as otherwise -> blah ?
11:15:34 <glen_quagmire> otherwise is True
11:16:31 <desegnis> otherwise is typically used for guards (what follows after a ‚Äú|‚Äù)
11:16:58 <desegnis> because that's where only booleans are valid
11:17:22 <desegnis> (except if you use avant-garde pattern guards)
11:17:28 <glen_quagmire> so, for case,  _ -> blah is more suitable
11:17:34 <desegnis> right
11:17:46 <glen_quagmire> great!
11:18:52 <desegnis> case x of otherwise -> ...   will just bind otherwise to x in (...), which impresses a little obscure
11:21:32 <glen_quagmire> oh this is weird. case x of othereise -> Atom x    but Atom is a constructor of type Atom String
11:22:01 <glen_quagmire> so, when othereise -> Atom x is evaluated, it's Atom Bool
11:22:14 <glen_quagmire> maybe it's runtime error, not compile itme
11:22:32 <glen_quagmire> i mean, i can compile this case expression without error
11:22:58 * desegnis came obviously too late to understand what it's all about.
11:23:17 <glen_quagmire> oh no, otherwise -> Atom x   will work fine as long as x is String
11:23:28 <glen_quagmire> otherwise -> Atom otherwise would be compiler error
12:21:01 <ketil> Any way to add a comment with XHtml?
12:21:37 <ketil> (I can add a string containing "<!-- ... -->", but it ends up quoted to &lt;!-- ... --&gt;")
12:21:51 <ketil> And, btw, merry Christmas.
12:23:30 <EvilTerran> ketil, on which website/whatever is this? that's the right syntax for xml comments...
12:23:38 <Saizan> ketil: tried primHtml?
12:23:51 <EvilTerran> oh, wait, XHtml the module . isee.
12:23:58 * EvilTerran stabs his space bar
12:24:08 <EvilTerran> never mind me :P
12:24:53 <Saizan> > Text.Xhtml.showHtml . Text.Xhtml.primHtml $  "<!-- ... -->" -- is it in scope?
12:24:55 <lambdabot>   Not in scope: `Text.Xhtml.primHtml'
12:25:43 <allbery_b> :t Text.XHtml.showHtml
12:25:45 <lambdabot> forall html. (Text.XHtml.Internals.HTML html) => html -> String
12:26:01 <allbery_b> > Text.XHtml.showHtml . Text.XHtml.primHtml $  "<!-- ... -->"
12:26:02 <lambdabot>   Not in scope: `Text.XHtml.primHtml'
12:26:31 <allbery_b> :t Text.XHtml.primHtml
12:26:31 <lambdabot> String -> Text.XHtml.Internals.Html
12:31:03 <zygen> So would anyone in here happen to have info about implementing evolutionary algorithms in haskell?
12:31:49 <Saizan> aka genetic algorithms?
12:32:05 <Botje> don't piss in the gene pool :)
12:32:06 <Associat0r> anyone tried this ? http://galois.com/~sof/hugs98.net/ and is it still developed?
12:32:07 <lambdabot> Title: Hugs98 for .NET
12:35:04 <ketil> zygen: or genetic programming?  (applying random transformations to the program itself)
12:37:55 <EspenG> can anyone help me out with this code? http://norskwebforum.no/pastebin/10227
12:38:15 <ketil> Saizan, thanks, primHtml did it nicely.
12:38:57 <allbery_b> EspenG: indentation is significant.  the second line of the "do" should line up with the "args" in the first
12:40:04 <EspenG> ok, it's just crazy in the pastebin.. it's looks perfectly fine in my emacs?
12:41:11 <EspenG> ok, it's my fonts that's not the same width then
12:41:41 <allbery_b> proportional fonts for code?  that's a recipe for insanity
12:41:58 <EspenG> yeah :P
12:44:59 <zygen> Saizan, ketil:  Yeah, I mean genetic algorithms (not changing the actual program)
12:52:46 <noteventime> zygen: Google seems to have quite a lot of interesting looking hits
12:54:29 <zygen> Ooh,  I guess I wasn't seeing them since I was searching for evolutionary algorithms
12:56:28 <jimstutt> @users
12:56:29 <lambdabot> Maximum users seen in #haskell: 434, currently: 369 (85.0%), active: 11 (3.0%)
12:57:09 <zygen> What's active, people that've talked in the last 5 minutes, or something like that?
12:58:04 <allbery_b> 15m, I think
13:04:00 <EvilTerran> @help users
13:04:00 <lambdabot> users [chan]. Report the maximum number of users seen in a channel, and active users in the last 30 minutes
13:06:18 <phlpp> users
13:06:20 <phlpp> @users
13:06:21 <lambdabot> Maximum users seen in #haskell: 434, currently: 367 (84.6%), active: 10 (2.7%)
13:06:21 <phlpp> :>
13:11:37 * EvilTerran is starting to think that all his olegian type-hackery is leading nowhere
13:11:53 <EvilTerran> well, i've got a big mess
13:12:29 <EvilTerran> that could be hugely tidied up with judicious application of SYB or TH; however, if i use either of those, i can do away with the type hackery altogether
13:16:12 <Saizan> EvilTerran: what are you hackering?
13:16:44 <EvilTerran> I'd rather not say, in case it doesn't work
13:17:02 <EvilTerran> don't want to hex it ;)
13:17:14 <Saizan> hex?
13:17:53 <Zao> Saizan: Quite similiar to jinxing, cursing something by talking about it.
13:18:40 <Saizan> ah, learned 2 new words today :)
13:19:29 <EvilTerran> (the scene: I'm working on a frobnitz. it seems to be going well.) <me> Hey guys, watch this, I'm building a frobnitz! <sod's law implies that the frobnitz shall, at this very moment, break beyond repair>
13:19:48 <Associat0r> allbery_b : isn't there a way to lift that do allignment restriction?
13:20:06 <Associat0r> I find it a very weird rule and is difficult to adhere to
13:20:36 <EvilTerran> > do { x <- [1,2,3]; y <- [4,5,6]; return (x*y) }
13:20:38 <lambdabot>  [4,5,6,8,10,12,12,15,18]
13:21:08 <EvilTerran> if a block (that would otherwise work by layout) is opened with a {, layout is switched off for that block
13:21:23 <EvilTerran> and lines are seperated by ;s and the block is closed with a }, in that case
13:21:33 <Saizan> just start a new line right after the do, so the new line detemine the indentation of the block
13:21:53 * EvilTerran tends to do as Saizan suggests, himself
13:23:08 <Associat0r> ok thanks
13:25:32 <Associat0r> btw does GHC have some OOP kinda extensions?
13:25:58 <EvilTerran> no need; our type system is better ;)
13:25:59 <sarehu> define OOP
13:26:36 <EvilTerran> @go o'haskell
13:26:39 <lambdabot> http://www.cs.chalmers.se/~nordland/ohaskell/
13:26:39 <lambdabot> Title: O'Haskell
13:27:00 <Valodim_> yeah but that one's been dead since 01
13:27:44 <mauke> @go oohaskell
13:27:54 <lambdabot> http://www.cwi.nl/~ralf/OOHaskell/
13:27:54 <lambdabot> Title: Haskell's overlooked object system
13:32:25 <Cheery> I have a graph with edges that have four vertices
13:33:04 <Cheery> I'd want to know how would I pattern-match efficiently on those edges
13:33:51 <Cheery> we're talking about billions of edges
13:34:44 <EvilTerran> er... edges with four vertices?
13:34:45 <Cheery> and I'd want to union those pattern matches so that I could find subgraphs that follow some pattern
13:35:12 <Cheery> *union and diff
13:35:55 <EvilTerran> pattern-matching per se would be impractical
13:36:43 <EvilTerran> ... but edges have two vertices...
13:37:04 <Cheery> I need edges with four vertices
13:37:25 <EvilTerran> that doesn't make sense
13:37:31 <EvilTerran> do you mean your set of "edges" is a subset of vertex^4?
13:39:14 <Saizan> i.e. your edge connects 4 vertices?
13:39:28 <Cheery> Saizan, yes. it's a peculiar structure I'm describing
13:39:52 <EvilTerran> well, you could represent each vertex with, say, an Integer
13:40:04 <EvilTerran> (or an Int or Word, if there's few enough vertices for that)
13:40:13 <EvilTerran> > maxBound :: Word -- no more than this many
13:40:14 <lambdabot>  4294967295
13:40:37 <EvilTerran> and then you could have a Set (Word,Word,Word,Word) to represent your graph
13:41:03 <EvilTerran> which'd allow you to check for the existence of any one edge in log(n) time
13:41:27 <Cheery> I'm representing each vertex with an Integer, but I'd need to find some solutions towards doing it efficient to find the subgraphs
13:41:30 <EvilTerran> @docs Data.Set
13:41:30 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Set.html
13:42:30 <Cheery> I'm particularly looking for algorithms that'd help me in that
13:42:58 <Associat0r> did anyone run into any organizational issues in wich traditional OOP would clearly be a better approach than the haskell approach?
13:43:18 <EvilTerran> i think we'd need to know more about which subgraphs in particular you're looking for before we could suggest a particular algorithm
13:44:04 <EvilTerran> however, a lot of graph-related problems are NP-hard or worse
13:44:19 <Cheery> I know.
13:45:07 <Cheery> what I'd need to achieve would be to locate edges and subgraphs, by pattern matching
13:46:00 <EvilTerran> this "by pattern matching" thing doesn't seem like a sensible requirement
13:46:12 <EvilTerran> at least not in the haskell sense of pattern matching
13:46:28 <Cheery> yes, not haskell sense of pattern matching
13:47:19 <Cheery> but it's foundation is in filtering those edges that fullfill some pattern,
13:48:51 <xerox> anybody got a subscription to nature? I need a pdf from the site.
13:48:55 <Cheery> for example. finding edges which have their first and second vertex connecting to same node
13:49:33 <Cheery> or third vertex connecting to node .3
13:51:19 <EvilTerran> xerox, i might have access by institution IP; URL?
13:52:16 <Cheery> and in similar way, locating subgraphs, which may fullfill the requirements in recursive manner, etc.
13:52:51 <Cheery> this is complex thing, wondering what sort of algorithms would pave the way for doing that in large graphs
14:03:21 <Cheery> EvilTerran: thought your in right, it starts from recognising the possible set of edges
14:03:32 <Cheery> which in my case is:
14:03:52 <Cheery> > (maxBound :: Word) ^ 4
14:03:54 <lambdabot>  1
14:04:00 <Cheery> ugh?
14:04:01 <EvilTerran> overflow
14:04:22 <Cheery> of course
14:04:27 <EvilTerran> > fromIntegral (maxBound :: Word) ^ 4
14:04:27 <lambdabot>  340282366604025813516997721482669850625
14:04:40 <EvilTerran> survey says: intractable
14:04:48 <EvilTerran> (jk ;] )
14:05:20 <EvilTerran> do you have billions of vertices, or just billions of edges?
14:05:32 <Cheery> billions of edges
14:05:39 <EvilTerran> that's not so bad, then
14:06:06 <EvilTerran> bit of careful algorithm design needed, is all
14:06:39 <Cheery> where should I start looking for the solution?
14:06:43 <opqdonut> Cheery: you're handling four-relations, not graphs (technically)
14:06:44 <EvilTerran> i'd be tempted to suggest storing the 4-edges in a database, actually
14:06:49 <opqdonut> so have a look at relation algebra
14:06:52 <opqdonut> and relation calculus
14:06:56 <opqdonut> EvilTerran: exactly
14:07:24 <EvilTerran> to save re-calculation, for one thing
14:07:37 <EvilTerran> also, those things're precisely designed for shoving around stupid amounts of data
14:07:52 <EvilTerran> create a table with a column for each vertex, bundle all the edges into it, index it to heck :)
14:08:09 <EvilTerran> s/for each vertex/for each vertex of each edge/
14:08:16 <EvilTerran> of course
14:08:53 <Cheery> opqdonut: I've been trying to find something I'd understand about the relation calculus and -algebra
14:09:12 <Cheery> but most stuff I hit is about SQL language syntax or other crap
14:09:19 <EvilTerran> SELECT (first, second, third, fourth) FROM Edges where first = second
14:09:21 <opqdonut> yeh that's the problem
14:10:01 <EvilTerran> should be O(n.log n), if my reckoning's right
14:10:09 <opqdonut> (an interesting note is that the way the database would be organised internally would be isomorphic to Map (Int,Int,Int,Int)
14:10:12 <EvilTerran> (on the number of edges)
14:10:20 <opqdonut> (EvilTerran: exactly)
14:10:23 <EvilTerran> opqdonut, you mean Set (Int,Int,Int,Int)?
14:10:28 <opqdonut> yeah set
14:11:03 <opqdonut> i was thinking map key value but in this case all the fields form the key
14:11:06 <opqdonut> so no value fields
14:12:28 <EvilTerran> ... might even be O((log n)^2) or sth. not sure of the details.
14:12:28 <Cheery> so I'd need to know about the internals of a database to implement it, if I'm not using SQL or other already existing database
14:12:34 <EvilTerran> O(fast enough) ;]
14:12:41 <MyCatVerbs> :t intersperse
14:12:42 <lambdabot> forall a. a -> [a] -> [a]
14:12:52 <EvilTerran> Cheery, why not use an existing database?
14:13:27 <EvilTerran> a lot of work has gone into making, say, PostgreSQL fast at this sort of thing. why re-invent the wheel?
14:14:20 <Cheery> I want to mostly learn, I think I could otherwise use just an existing database
14:16:06 <EvilTerran> i think, in pure haskell, it'd be fastest to do a linear sweep for the first example you gave, rather than building some fancy-schmancy data structure just to do a simple query
14:17:46 <EvilTerran> in terms of mimicking a database engine, a table could be an Array Integer (Col0...ColN)
14:18:14 <EvilTerran> and each index a Map ColI [Integer]
14:19:21 <EvilTerran> or Map (Col_I0...Col_IN) (Set Integer), even. replace Set with Maybe if there's a UNIQUE constraint on that column.
14:20:03 <EvilTerran> haskell is one of the easier languages to re-invent the database in ;)
14:21:07 * EvilTerran notes that the second of those is isomorphic to Set (Col_I0,...,Col_IN,Integer), which'd probably be at least as fast
14:21:50 <EvilTerran> (if i'm right in thinking that tuple-keyed Sets and Maps work through tuples left-to-right)
14:31:31 <OceanSpray> I'm going to name my kid 'Haskell'
14:31:52 <Cheery> so map is a set with values in the binary tree
14:31:58 <osfameron> at least haskell is an actual name...
14:32:10 <OceanSpray> seriously though,
14:32:14 <opqdonut> :D
14:32:20 <OceanSpray> who the hell names their kid 'Haskell'>
14:32:22 <vincenz> "Haskell, you lazy bastard, stop throwing monads at the neighbour's cat"
14:32:32 <Cheery> :D
14:32:37 <OceanSpray> :D
14:32:49 <Cheery> my name starts with 'H', and that corresponds to my behavior
14:33:12 <OceanSpray> What's with 'Curry', anyway?
14:33:39 <OceanSpray> Did his ancestors just really like Indian food?
14:34:14 <osfameron> http://en.wikipedia.org/wiki/Curry_%28surname%29
14:34:18 <osfameron> wikipedia knows all!
14:36:21 <Cheery> EvilTerran: how would you filter from such a database?
14:36:55 <OceanSpray> Haskell's logo is ugly.
14:37:18 <Cheery> ie. select (first, second, third, fourth) FROM Edges where first = 2
14:40:47 <allbery_b> OceanSpray: the name can also be derived from Hebrew (Anglicization of 'qeri').  probably lots of other ways to get it as well
14:45:06 <Cheery> oh well, that's maybe the most stupid question I've done this far
14:46:03 <Saizan> Cheery: have you found a good solution? Data.Map.filter is O(n) iirc
14:46:42 <vincenz> Saizan: /
14:46:43 <vincenz> Saizan: ?
14:47:05 <vincenz> Saizan: you need a tree type that allows you to select rnages
14:47:20 <vincenz> afaik, none of std containers in Data.XXX do that
14:48:12 <Saizan> yeah, that's why i think that's not a stupid question :)
14:49:01 <Cheery> I realised how my friend did an one really neat trick he were able to use to expose the whole contents of his system in efficient manner
14:50:30 <Saizan> however the general problem of an in-memory table with multiple indexes is interesting
14:51:50 <Cheery> Saizan: true
14:53:13 <Saizan> you could have an HList of Map index (Set value) (which is roughly IxSet in HAppS) but if the result of filtering is still a table you've to do a lot of work to update the indexes removing elements
14:55:11 <Cheery> I guess this what I'm going to do will be fun
14:55:24 <Cheery> at least it just started to be
14:56:22 <opqdonut> heh
14:58:47 <Saizan> and if it's just a list it's O(log n) to filter only if you've to check only one index :\
15:00:56 <Cheery> oh well, going to sleep
15:00:58 <Cheery> gn
15:06:48 <yesyes> hey, could anyone help me from going insane? I'm going through some exercises on the haskell wiki tutorial. One asks me to return the results from some [IO a]s as a list: http://en.wikibooks.org/wiki/Haskell/Solutions/Higher-order_functions_and_Currying (see the second exercise at the bottom of the page) Does anyone have any ideas on how to do this? It surpasses my current ability and understanding, for sure.
15:06:49 <lambdabot> http://tinyurl.com/24b39x
15:08:54 <dibblego> yesyes, you mean the one titled Part 1: 2. A for loop in Haskell?
15:09:07 <dibblego> oh, implement the for loop in Haskell?
15:09:10 <Saizan> the sequenceIO part i think
15:09:11 <mauke>  Implement a function sequenceIO :: [IO a] -> IO [a].
15:09:22 <dibblego> oh right :)
15:09:26 <yesyes> yup
15:09:31 <dibblego> sorry
15:09:43 <mauke> start with the simple stuff
15:09:48 <Saizan> yesyes: well you've a list of actions, so you have to consume it somehow.. collecting the results
15:09:50 <mauke> what if the argument list is empty?
15:10:19 <vincenz> mauke: you mean like
15:10:21 <vincenz> @type sequence
15:10:22 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
15:10:29 <dibblego> yesyes, follow what mauke is asking, since create the case for the empty list, then the head:tail list
15:10:32 <dibblego> vincenz, sssh!
15:11:29 <yesyes> i understand seqIO [] = return [] as the first case I assumed...
15:11:36 <mauke> right
15:11:46 <dibblego> yesyes, correct, now seqIO (a:as) = ...?
15:12:15 <vincenz> lol
15:12:18 <vincenz> "yesyes"
15:12:28 <yesyes> = a : seqIO as    ... but i've been down that route before as I recall.
15:13:03 <vincenz> yesyes: nope
15:13:11 <dibblego> yesyes, hint: you will need do-notation (or equivalent)
15:13:51 <yesyes> well, i even tried do {a : seqIO as} to no avail
15:13:57 <Saizan> yesyes: that way you'd get a [IO a] again, instead you want IO [a], so you've to extract the results of those IO actions
15:14:26 <Saizan> the keyword do alone doesn't help
15:14:49 <dibblego> yesyes, consider that you have a list in IO, therefore, you'll likely need the return keyword to put it in there
15:15:00 <yesyes> {v <- a ; return a : seqIO as}
15:15:05 <yesyes> i also tried...
15:15:13 <mauke> no
15:15:24 <mauke> you need to get your hands at the results of those IO actions
15:15:31 <mauke> er, on?
15:15:38 <Saizan> and form a list whit those
15:15:52 <mauke> that means using >>= (or <- in do)
15:15:55 <Saizan> so the "v <- a;" part is right
15:16:05 <yesyes> hmm
15:16:14 <yesyes> {v <- a ; a : seqIO as}
15:16:19 <yesyes> no...
15:16:21 <yesyes> {v <- a ; v : seqIO as}
15:16:30 <mauke> not quite right
15:16:34 <mauke> seqIO doesn't return a list
15:17:44 <yesyes> yeah, that's a part of my problem. i know IO [a] isn't a list, but then we have [a] there....
15:18:05 <mauke> IO [a] is an action that (when executed) results in a list
15:18:29 <yesyes> hah... hmmm...
15:18:46 <dibblego> seqIO as is a IO [a] and you want [a] (hint: <-)
15:18:53 <dibblego> (seqIO as)
15:19:04 <yesyes> that seems to have been my misunderstanding. thanks a lot... *thinks*
15:19:37 <mauke> this is my explanation of this whole IO thing: http://mauke.ath.cx/stuff/haskell/how-to-io.html
15:19:39 <lambdabot> Title: Haskell: How To IO
15:19:52 <dibblego> 'a' is a IO a and you wanted just a, so you did v <- a
15:21:36 <yesyes> yeah, now i'm think about how I represent the IO a. the only IO a function I know is getLine...
15:22:05 <dibblego> you can 'get the a out of IO a' when you're in do-notation by using <-
15:22:14 <yesyes> when i have that function I guess i'll use (++) to build the [a]
15:22:26 <dibblego> consider the types of your (a:as) in the pattern match
15:23:33 <dibblego> you won't be using ++
15:23:55 <yesyes> basically, now i'm thinking = do {v <- a ; somefunct v ++ seqIO as}
15:24:00 <yesyes> oh......
15:24:01 <dibblego> nope
15:24:08 <dibblego> look what you did to 'a'
15:24:09 <mauke> seqIO is still not a list
15:24:25 <dibblego> since 'a' is of type (IO a) and you wanted just (a), you used <-
15:24:37 <dibblego> since 'as' is of type (IO [a]) and you want just [a], ....
15:25:32 <dibblego> then take the (a) and [a] and cons them together, then plop them back in IO (return)
15:26:09 <dibblego> I am using (parentheses) there to prevent ambiguity in the English sentence
15:26:12 <yesyes> ah, okay... i think i see what you're saying...
15:27:10 <dibblego> cons is : by the way, not ++
15:27:25 <yesyes> yeah (thanks for all this, btw)
15:27:30 <dibblego> no problem
15:29:23 <yesyes> do {v <- a; seqIO (return v : as)} but there's still something wrong
15:29:35 <vincenz> close
15:29:37 <mauke> yeah, that would be infinite recursion
15:29:56 <mauke> you can't just go off into seqIO again
15:30:10 <dibblego> you'll need to get the [a] out of IO [a] the same way you got the (a) out of (IO a)
15:30:20 <vincenz> you need one more bind statement
15:30:25 <vincenz> hint hint
15:30:35 <dibblego> (seqIO as) is of type IO [a]
15:30:46 <dibblego> er, (as)
15:34:27 <dibblego> you need one more bind statement (you need one more <- statement)
15:34:55 <yesyes> yeah, but i'm trying to unretard myself atm
15:35:09 <dibblego> just accept you'll need two uses of <-
15:35:14 <dibblego> you've already done the first one
15:35:35 <dibblego> that was getting the (a) out of (IO a)
15:35:45 <dibblego> v <- a
15:36:07 <yesyes> and the second one on the rest of the list i would have thought
15:36:13 <dibblego> right
15:36:16 <dibblego> on the IO [a]
15:36:26 <dibblego> which is not a list it is an "IO list"
15:36:45 <dibblego> <- will get the list out of the IO list
15:37:01 <dibblego> so then you'll have an (a) and a list of a
15:37:08 <yesyes> hmm. i didn't realise that
15:37:10 <dibblego> so you can apply cons then
15:38:12 <dibblego> it's important to distinguish IO x and x for any value of x
15:41:15 <yesyes> and <- gets the x out of IO x, i understand that. so this function needs to get at every item in the list of [IO a]s, use <- to get each a, then use Cons to build up those `a's into a new IO. but still...
15:41:38 <vincenz> and then return the list
15:41:56 <dibblego> v <- a; vs <- as;
15:42:01 <mauke> it doesn't really need to get at every item
15:42:05 <mauke> well, not at the same time
15:42:13 <vincenz> seqIO (ma:mas) = do { a <- ma; as <- seqIO mas; return (a:as) }
15:42:14 <dibblego> v can then be consed to vs
15:42:24 <dibblego> oops
15:42:28 <dibblego> v <- a; vs <- seqIO as;
15:42:42 * vincenz uses the hungarian notation for monadic values :)
15:42:43 <vincenz> just add an 'm'
15:44:20 <yesyes> okay. thanks hugely. it all seems quite simple now.
15:44:34 <dibblego> ?type let seqIO [] = return []; seqIO (x:xs) = do x' <- x; xs' <- seqIO xs; return (x':xs') in seqIO -- foldr!
15:44:34 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
15:44:40 <yesyes> i'm going to have to work out what exactly i didn't understand. thanks again. i have it working.
15:45:16 <vincenz> @src sequence
15:45:17 <lambdabot> sequence ms = foldr k (return []) ms
15:45:17 <lambdabot>     where
15:45:17 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
15:45:20 * vincenz wrinkles his nose
15:45:26 <mauke> :t foldr (liftA2 (:)) (pure [])
15:45:27 <lambdabot>     Ambiguous occurrence `pure'
15:45:27 <lambdabot>     It could refer to either `pure', imported from Control.Applicative
15:45:27 <lambdabot>                           or `pure', imported from Control.Arrow
15:45:38 <mauke> :t foldr (liftA2 (:)) (Control.Applicative.pure [])
15:45:39 <lambdabot> forall (f :: * -> *) a. (Applicative f) => [f a] -> f [a]
15:45:56 <mauke> :t foldr (:) []
15:45:57 <lambdabot> forall a. [a] -> [a]
15:48:15 <Saizan> mmh, maybe learning applicative first would be easier, you've less ways to screw up
15:48:15 <wy> It seem my tutorial is a little outdated. Can I still define method "shows" to show a value?
15:48:28 <Saizan> ?src Show
15:48:29 <lambdabot> class  Show a  where
15:48:29 <lambdabot>     showsPrec :: Int -> a -> ShowS
15:48:29 <lambdabot>     show      :: a   -> String
15:48:29 <lambdabot>     showList  :: [a] -> ShowS
15:48:39 <mauke> @src shows
15:48:40 <lambdabot> Source not found. I am sorry.
15:48:42 <Saizan> showsPrec :)
15:49:00 <Saizan> ?type shows
15:49:01 <lambdabot> forall a. (Show a) => a -> String -> String
15:49:09 <Saizan> ?index shows
15:49:10 <lambdabot> Text.Show, Prelude
15:49:41 <wy> When is it changed? I remember I tried shows about a year ago
15:50:28 <mauke> wy: shows is a freestanding function, not a method
15:50:38 <mauke> http://haskell.org/onlinereport/standard-prelude.html
16:01:48 <augustss> wy: shows has never been a method, but showsPrec has always been a method
16:02:43 <wy> augustss: I see. I misunderstood the gentle introduction
16:03:10 <augustss> show didn't use to be a method, but it is now
16:06:59 <MyCatVerbs> Methods are the functions that make up a class, right?
16:07:09 <MyCatVerbs> As opposed to free-standing functions, I mean.
16:07:59 <mauke> yes
16:08:20 * MyCatVerbs wonders why Monoid doesn't have a return function?
16:08:34 <mauke> because it's not a container
16:08:37 <MyCatVerbs> Or are (practically) all Monoids also instances of Monad or something?
16:08:49 <MyCatVerbs> Oh, fair enough.
16:08:49 <Saizan> ?instances Monoid
16:08:50 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, Ordering, Product a, Sum a, [a]
16:09:51 <wy> Should I use shows or showsPrec to put in string functions I already have?
16:10:35 <augustss> "put in string functions"?
16:11:50 <wy> augustss: for example: Do I use (showString "Frame(").shows o.(showString ", [") when I define showsPrec?
16:12:06 * MyCatVerbs wonders why Integer isn't in the list of Monoid instances. ;)
16:12:18 <wy> "show o" or "showPrec p o" ?
16:12:25 <augustss> wy: depends if you need the precedence or not
16:12:39 <MyCatVerbs> (Oh wait, it is, under the wrappers "Sum" and "Product", huh.)
16:13:03 <Saizan> yeah, many types have many ways to be a monoid
16:13:10 <augustss> MyCatVerbs: yeah, because Integer can be a monoid in many ways
16:13:12 <wy> augustss: Got it. It's a little strange that shows is not a method, while it mostly depends on the instance
16:13:56 <vincenz> shows is a specialization of showsPrec
16:14:06 <vincenz> with just one specific precedence value
16:14:15 <vincenz> and show a = shows a ""
16:15:17 <qebab> @hoogle sendTo
16:15:18 <lambdabot> No matches found
16:15:32 <qebab> okay, that probably makes this a ghc thing?
16:16:23 <Saizan> ?index sendTo
16:16:24 <lambdabot> Network, Network.Socket
16:16:38 <Saizan> maybe hoogle doesn't index Network?
16:17:42 <qebab> oh, according to the topic it's a question for here: the documentation on Newtork says that sendTo and recvFrom are discouraged, "except for small test-applications or invocations from the command line", now I'm a bit curious if there's a better way to get the same functionality a socket would offer from ghc?
16:19:06 <Saizan> qebab: use connectTo and then write on the resulting Handle
16:19:22 <MyCatVerbs> augustss: cool.
16:19:34 <qebab> Saizan: ah, so just treat it like I would treat a file after it's been connected?
16:19:42 <allbery_b> right
16:19:47 <qebab> cool
16:19:52 <MyCatVerbs> Saizan: so newtype wrappers like that are the standard way of having one many instances of a particular class for a single type? Handy to know.
16:19:53 <qebab> that's quite neat
16:20:06 <allbery_b> (that is true in general for sockets, whether in haskell or in C or perl, etc.)
16:20:44 <qebab> allbery_b: well in C sockets are a bitch so the code I've seen on it has not been logical or pretty
16:20:45 <allbery_b> sendto/recvfrom are mainly intended for UDP services which do a single request/response
16:21:02 <qebab> allbery_b: could be that it has just been bad code, of course
16:21:59 <qebab> in Python I'd say sock.makefile() to give it a tmp file to use
16:22:30 <MyCatVerbs> qebab: if all you're doing is boring TCP, it's not actually neccessary in C to use anything other than read() and write(). Sockets can be used just like normal file descriptors, except more powerful. :)
16:22:39 <Saizan> MyCatVerbs: yes, even if the wrap/unwrap can be annoying sometimes
16:22:49 <qebab> MyCatVerbs: cool, I didn't know that
16:22:52 <MyCatVerbs> Saizan: wrap/unwrap?
16:23:12 <qebab> so basically they get filedescriptors and everything?
16:23:23 <MyCatVerbs> (Leaving aside for obvious reasons the fact that initialising them is a pain, unless you're using... pretty much any language that isn't C.)
16:23:31 <MyCatVerbs> qebab: they *are* file descriptors.
16:23:47 <qebab> right /o\
16:24:48 <Saizan> MyCatVerbs: of the newtype constructor
16:25:20 <Saizan> i think the pain in C with sockets is dealing with buffers
16:25:28 <Zao> MyCatVerbs: Provided you use a posixy environment, that is.
16:25:51 <MyCatVerbs> Saizan: ohhhh, I see. Yes.
16:25:59 <MyCatVerbs> Zao: ehhhhh...
16:26:33 <MyCatVerbs> Zao: I thought using sockets under Windows was virtually identical to under Unix?
16:26:58 <MyCatVerbs> Zao: and aside from Windows and Unix clones, there's precious few operating systems even available, let alone at production quality.
16:27:03 <Zao> MyCatVerbs: The winsock interface is rather similiar yes, but has to fake all the select and whatnot.
16:27:10 <Zao> Since it doesn't have fds.
16:27:26 <qebab> hrm, the normal way to have a program loop in haskell would be to write a function that calls itself until it's time to quit and invoke it from main? will that every exhaust the stack?
16:27:31 <qebab> s/every/ever
16:27:35 * MyCatVerbs prepared to be incinerated by (Open)?VMS fans. And the BeOS people (though that was POSIX-ish, wasn't it?)
16:27:50 <MyCatVerbs> qebab: not if it's tail-recursive, no.
16:28:01 <qebab> okay, shouldn't be a problem then
16:28:07 <qebab> but that is the usual way of doing it?
16:28:12 <MyCatVerbs> qebab: yep.
16:28:18 <qebab> cool, thanks
16:29:11 <MyCatVerbs> qebab: hell, this is one of the things I like about Scheme: the language spec says that you are absolutely damn well required under all circumstances to always have tail-call-optimization, no damn matter what. It means that sort of programming is guaranteed to work. ;)
16:30:13 <MyCatVerbs> (Over on *this* side of the fence, I don't know whether H98 requires that your compiler has TCO to be compliant, but every production-quality compiler does have it anyway. Otherwise it's useless and nobody uses it anyway. \o/)
16:32:34 <vincenz> TCO is the way to go
16:39:08 <wy> I want to hide my implementation while provide pattern matching at the same time, but the labeled pattern matching is a little unwieldy. I have something like Vector {vecX=x1, vecY=y1, vecZ=z1}, if I have two, the line width will exceed 80. Any better ideas?
16:40:20 <ndm> wy: its a known issue - not much you can do about it really - a few recent GHC extensions take brief stabs at it (view patterns, record punning) but there isn't really a good solution
16:42:53 <wy> ndm: It's only an aesthetic issue though
16:42:55 <qebab> MyCatVerbs: yeah, TCO is quite awesome
16:43:12 <MyCatVerbs> vincenz: ahhah.
16:43:12 <qebab> MyCatVerbs: recursion can express a lot of things cleaner than iteration can
16:43:24 <Saizan> btw, i think you still have to export the constructor to pattern match on records
16:43:27 <MyCatVerbs> vincenz: that's why microsoft employs people like SPJ.
16:43:40 <qebab> where iteration means "the normal looping constructs"
16:43:49 <MyCatVerbs> vincenz: by making Haskell awesome, they make TCO more awesome for pratical use.
16:44:17 <MyCatVerbs> vincenz: by making "TCO is awesome" true, it subconciously gives rise to the idea that maybe the *other* "TCO" is awesome, too.
16:44:47 <MyCatVerbs> vincenz: hence, when ghc 12.0.0 gets released, MS will re-start their TCO-focussed advertising schemes. :)
16:45:30 <Saizan> other TCO? total cost of ownership?
16:46:15 * MyCatVerbs nods.
16:47:18 <MyCatVerbs> Ballmer's actually a marketing genius. Next thing you know, we'll all be buying NT6 servers - even those of us who only *have* one computer, with no clients to serve - and we won't quite be able to figure out why.
16:48:01 <vincenz> Did I say all that with just 6 words?
16:48:10 <ndm> MyCatVerbs: are you suggesting something won't knock GHC off the top spot before v12?
16:48:56 <mauke> if you kill GHC, you become GHC
16:49:33 * MyCatVerbs glances at @haskell and @haskell-cafe
16:49:35 <vincenz> @quote ghc
16:49:36 <lambdabot> ghc says: magic number mismatch: old/corrupt interface file?
16:49:41 <Saizan> by that time haskell would be dependently typed probably :)
16:49:52 <ndm> GHC killed HBC
16:49:55 <ndm> HBC killed LML
16:50:05 <MyCatVerbs> Looking at most of the discussions about performance, by the time GHC hits, say, version 8, it will have been totally replaced.
16:50:14 <Philippa> wy: aesthetically speaking, learn to write patterns across multiple lines
16:50:30 <MyCatVerbs> However, the replacement will happen to be called "Glasgow Haskell Compiler" too.
16:51:05 <wy> Philippa: I'm trying to provide some short access operators for my vector now
16:51:20 <Philippa> yeah, that's also a good idea
16:51:35 <MyCatVerbs> For the best example in industry so far, see ethernet. It's been completely replaced at least twice, and every time the replacement has been given the name "ethernet", regardless of how much or little it has in common with the previous iteration.
16:52:09 <Saizan> wy: you know that vecX etc.. are also functions from Vector to the type of the respective field?
16:52:45 <MyCatVerbs> ndm: yes, well, in both cases there were standards groups involved.
16:52:51 <qebab> do I have to do anything special to tell ghc to import Network? I just tried import Network in the file, but ghc says it can't find it
16:52:53 <wy> Saizan: yes. They are a little long. So I used !
16:53:09 <MyCatVerbs> ndm: LML being quietly murdered by the transition from a fragmented lazy-language space to Haskell...
16:53:10 <mauke> qebab: try ghc --make
16:53:21 <qebab> mauke: that was with --make :(
16:53:22 <MyCatVerbs> ndm: and HBC being more or less quietly murdered by Haskell98.
16:53:29 <mauke> qebab: er, wait. if it tells you it can't find Network, you probably don't have it
16:53:36 <qebab> okay
16:53:37 <ndm> MyCatVerbs: HBC and LML were mainly the same people, so more a renaming than a murder
16:53:45 <qebab> where can I find it then?
16:53:54 <mauke> how did you install ghc?
16:53:59 <Saizan> ?hackage network
16:54:00 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/network
16:54:01 <qebab> apt-get ghc
16:54:08 <allbery_b> network was unbundled, if you installed from a distribution then look for a network library package, otherwise hackage
16:54:13 <qebab> ah
16:54:15 <allbery_b> libghc6-net-dev?
16:54:22 <qebab> there's a libgh6-network-dev
16:54:32 <allbery_b> that was the name back before the 6.8 upgrade at least
16:54:35 <wy> I want to give the operator a precedence higher than that of function application. I don't know if there will be problems
16:54:36 <allbery_b> that's probably it
16:54:43 <MyCatVerbs> ndm: what about HBC versus GHC?
16:54:46 <Saizan> it's probably safe to install libghc6-*
16:55:24 <Philippa> wy: there will be: you can't even get equal to it
16:55:26 <ndm> MyCatVerbs: well before my time :)
16:55:45 <ndm> MyCatVerbs: although i do know there were performance battles between them fora while
16:55:58 <qebab> Saizan: yeah I'm doing that now
16:56:03 <wy> Philippa: Is function application precedence 10?
16:56:33 <Philippa> wy: in effect, yes
16:57:02 <wy> Philippa: You mean I can't have precedence higher than 10?
16:57:06 <MyCatVerbs> ndm: that sounds like a more straightforward murder case, then.
16:57:09 <Philippa> 9, in fact
16:58:01 <MyCatVerbs> ndm: though I can't see any likelihood of that happening to GHC any time soon. From what I can see, what's happening most often is that new optimizations are getting prototyped in the smaller, competing compilers and then ported to GHC once proven useful (and usable).
16:58:13 <Philippa> suffice it to say that it was a very deliberate decision in the language's design?
16:59:02 <Philippa> MyCatVerbs: if JHC hit production quality that'd be interesting. But it wouldn't kill GHC because it's whole-program
16:59:10 <ndm> MyCatVerbs: i can't think of any optimisation that has gone in that way...
16:59:23 <wy> Philippa: I wonder why it's decided no operators have higher precedence than function application
16:59:29 <ndm> i am working on one, as is JHC, but neither of us are within a million miles of being GHC usable
16:59:53 <MyCatVerbs> ndm: automatic deforestation?
16:59:56 <Philippa> wy: 1) so that readers have something to rely on 2) it makes life somewhat easier for parsing
17:00:06 <ndm> MyCatVerbs: where did that get prototyped before GHC?
17:00:23 <wy> If I can have precedence 11 for my (!), I can save lots of parentheses
17:00:33 <Philippa> wy: you can't. No pony, either
17:01:02 <qebab> parentheses don't scare me anymore :)
17:01:09 <MyCatVerbs> Philippa: oooh, that sounds pretty cool.
17:01:21 <MyCatVerbs> ndm: I've seen blog posts from someone adding it to YHC.
17:01:23 <ndm> Philippa: its Christmas (or was an hour ago), be nice ;)
17:01:26 <ndm> MyCatVerbs: me :)
17:01:50 <ndm> MyCatVerbs: and adding it to Yhc is a massive overstatement, i take Yhc front end and use GHC back end - its much closer to adding to GHC than Yhc
17:02:07 <MyCatVerbs> ndm: haha, looks like I'm totally crazy and wrong. But rewrite rules, and the new Data.Blah.Fusion seem to be going that way, no?
17:02:16 * Philippa hands ndm a humbug
17:02:45 <ndm> MyCatVerbs: yes, all the rewrite stuff goes into GHC directly, since only GHC supports rewrites, and all as libary stuff
17:04:46 <MyCatVerbs> ndm: hrmn. I thought the implementations were related somehow, rather than just the end results.
17:05:15 <ndm> MyCatVerbs: you mean the rewrite stuff, the data.fusion or the Yhc work
17:05:39 <MyCatVerbs> ndm: doesn't data.fusion work via rewrite rules?
17:10:15 <MyCatVerbs> ndm: I thought the whole lot were at least vaguely connected in some way, given the similarity in their objectives. >_>
17:10:35 <ndm> MyCatVerbs: the data.blah.fusion stuff andthe whole program is completely unrelated
17:10:36 <MyCatVerbs> Philippa: JHC sounds pretty cool, looking at it now. I could see that being popular.
17:10:44 <MyCatVerbs> ndm: huh, k.
17:16:00 <wy> It seems that I can't use pattern matching at all if I want to hide the implementation. Because only types defined by "data" can have labeled fields. If I want to implement the vector as a list, there is no way to hide it if I'm going to use pattern matching
17:16:17 <qebab> openFile results in IO Handle, and hPutStr wants just a Handle, if I "openFile somewhere somemode" how can I then hPutStr to the result?
17:16:41 <yrlnry> wy: I read an interesting paper recently that tries to address that problem.
17:16:43 <mauke> qebab: do you know getLine?
17:17:04 <mattam> wy: it seems you want views
17:17:32 <qebab> mauke: mauke that depends on what you mean, but I know about it yes
17:17:46 <mauke> well, do you know how to use it? :-)
17:17:51 <mauke> because there you have the same problem
17:18:00 <mauke> getLine :: IO String, but you want a String
17:18:10 <qebab> oh right
17:18:16 <qebab> <- eh?
17:18:21 <mauke> yep
17:19:41 <qebab> thanks
17:20:17 <wy> mattam: Is it an extension?
17:21:41 <augustss> wy: views are an extension, but you can do something similar yourself with just a little work
17:21:51 <MyCatVerbs> @check (\order1 order2 -> order1 `mappend` order2 = order1) :: Ordering -> Ordering -> Bool
17:21:51 <lambdabot>  Parse error at "=" (column 44)
17:21:57 <MyCatVerbs> @check (\order1 order2 -> order1 `mappend` order2 == order1) :: Ordering -> Ordering -> Bool
17:21:58 <lambdabot>  Falsifiable, after 2 tests: EQ, GT
17:22:02 <EvilTerran> views are pretty cool
17:22:14 <EvilTerran> the big fanciness comes from the ability to nest them
17:22:27 <wy> It looks like Common Lisp. I found the default constructor is seldom useful if the implementation can be a built type
17:24:02 <araujo> hello!
17:24:30 <EvilTerran> words (span isSpace -> (_, break isSpace -> (w, words -> ws)) = w:ws; words _ = []
17:24:55 * EvilTerran notes that span could've been written better as a dropWhile. regardless.
17:25:41 <wy> augustss: any hints? Do I need to use some metaprogramming?
17:26:27 <augustss> wy: well, you can try ghc's view patterns, they are similar to views
17:27:52 <augustss> otherwise, what you can do is to define a data type that you want to pattern match on, but that is not the same as the representation type.  then before pattern matching you have to cann a conversion funcction.
17:28:01 <augustss> s/cann/call/
17:28:10 <augustss> That's how views work.
17:28:27 <augustss> The nice things about views is that they nest properly.
17:28:57 <augustss> real views, i mean
17:29:24 <Saizan> EvilTerran: i'm not sure if that defintion is very nice or ugly..
17:29:56 <radetsky> has anybody used the torrent package?
17:29:57 <augustss> I find view patterns ugly in general
17:30:03 <EvilTerran> nested views are great for eliminating what'd otherwise be single-use bindings
17:30:28 <EvilTerran> so get rid of extraneous variable names; kinda like pointless programming in that way, i guess
17:31:02 <jsnx> i have a chinese dictionary that i treat as a Map -- it's created from a list of tuples
17:31:05 <EvilTerran> also similar in that some people find 'em abhorrently ugly
17:31:30 <jsnx> is that Map created from the tuples every time i load the lib?
17:31:50 <puusorsa> ghc? views? sound guiy
17:31:53 <jsnx> probably, write, due to 'lazy evaluation'
17:32:15 <augustss> puusorsa: no gui
17:32:53 <puusorsa> no spoon either
17:32:58 <puusorsa> Maybe Just Nothing.
17:33:26 <Saizan> jsnx: define "load the lib", if you've dictionary = Map.fromList tuples it will be created once for every execution of your program
17:34:30 <jsnx> Saizan: well, i made the dictionary into a module -- (cedict, it's on hackage) -- and "load the lib" means `import Data.Char.CEDICT`
17:34:30 <gregm> i think once every time you enter the scope of "dictionary = ...", wherever that may be
17:35:25 <jsnx> then i might say, `Map.lookup Data.Char.CEDICT.singles <chinese character>`
17:36:06 <Saizan> yes, it will be recalculated, it's not "cached" at compile time
17:36:27 <jsnx> Saizan: but certain expressions are, right? like `1 + 2`
17:36:30 <wy> augustss: Will some form of views become standard? Without it the implementation is really exposed a lot.
17:36:43 <MyCatVerbs> Is there any particular advantage to using (sequence_ (map foo list)) over (mapM_ foo list)?
17:36:50 <Saizan> jsnx: GHC does very little of that, if any
17:36:57 <jsnx> Saizan: that sucks
17:37:05 * MyCatVerbs would assume not, aside from the lack of need to import Control.Monad, but would rather be certain.
17:37:06 <augustss> wy: I don't think views will become standard for quite a while
17:37:15 <jsnx> Saizan: is there no way around it?
17:37:17 <EvilTerran> jsnx, not really. we do many more interesting optimisations
17:37:25 <jsnx> EvilTerran: yeah?
17:37:29 <jsnx> EvilTerran: like?
17:37:32 <Saizan> ?src mapM_
17:37:33 <lambdabot> mapM_ f as = sequence_ (map f as)
17:37:52 <EvilTerran> we have call-by-need :)
17:38:35 <jsnx> EvilTerran: i thought you meant "we do many more optimizations that are relevant to loading compile time constants"
17:39:06 <Saizan> jsnx: in the case of Map no, since the constructors are not exposed, so you can't even run the computation with TH and splice the result back in the source
17:39:08 <radetsky> has anybody successfully built the torrent package (http://hackage.haskell.org/cgi-bin/hackage-scripts/package/torrent-2007.10.27)
17:39:09 <lambdabot> http://tinyurl.com/2hzref
17:39:10 <radetsky> ?
17:39:30 <jsnx> radetsky: not i
17:39:38 <radetsky> I can't, and I'd like to know if somebody else has solved this problem before I try
17:39:49 <EvilTerran> if you want something like evaluation at compile-time, ISTR ndm's worked on something kinda similar
17:40:04 <Saizan> radetsky: trying right now
17:40:11 <jsnx> EvilTerran: ISTR = undefined
17:40:16 <radetsky> I can't find anything on the haskell-cafe or libraries mailing lists. Is there anywhere else I should look?
17:40:17 <jsnx> EvilTerran: ndm = undefined
17:40:37 <radetsky> Saizan, thanks
17:40:42 <mauke> jsnx: I Seem To Recall, /whois ndm
17:40:48 <EvilTerran> "I seem to recall, Neil Mitchell"
17:41:07 <jsnx> mauke: ndm could be a bank, for all i know
17:41:10 <MyCatVerbs> wy: you could take the approach that Data.Sequence does.
17:41:12 <jsnx> EvilTerran: thank you
17:41:19 <wy> augustss: The one in ghc is a little too complex to use
17:41:35 <MyCatVerbs> wy: abstract data type, with a pair of view-constructing functions (viewl and viewr)
17:41:48 * ndm is ndm
17:41:49 <MyCatVerbs> > Seq.empty
17:41:50 <lambdabot>   Not in scope: `Seq.empty'
17:41:57 <Saizan> radetsky: which error do you get? i get one related to the splitting of base in 6.8
17:41:58 <jsnx> ndm: thank you
17:42:02 <MyCatVerbs> > Data.Sequence.empty
17:42:03 <lambdabot>  fromList []
17:42:03 <EvilTerran> @where supero
17:42:03 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/supero/
17:42:28 <jsnx> supero does compile time constants !!
17:42:41 <ndm> jsnx: not ready for general use yet
17:42:55 <jsnx> ndm: but it will do it when it comes out?
17:43:06 <radetsky> Saizan,     Could not find module `Data.ByteString.Base':
17:43:15 <MyCatVerbs> > case (viewl $ ((Data.Sequence.empty |> 5) |> 6)) of (x:xs) -> x
17:43:15 <lambdabot>   Not in scope: `|>'
17:43:17 <radetsky> I assume stuff has been moved around?
17:43:32 <MyCatVerbs> > case (viewl $ ((Data.Sequence.empty Data.Sequence.|> 5) Data.Sequence.|> 6)) of (x:xs) -> x
17:43:33 <lambdabot>   Not in scope: `viewl'
17:43:43 <MyCatVerbs> > case (Data.Sequence.viewl $ ((Data.Sequence.empty Data.Sequence.|> 5) Data.Sequence.|> 6)) of (x:xs) -> x
17:43:43 <lambdabot>  Couldn't match expected type `Data.Sequence.ViewL a'
17:43:44 * EvilTerran got the impression it did something similar, from ndm's AngloHaskell2007 talk
17:43:51 <MyCatVerbs> ...DAMN YOU, \BOT.
17:44:04 <ndm> jsnx: to a degree, it will calculate some constants
17:45:50 <jsnx> ndm: well, that makes me happy
17:46:15 <EvilTerran> jsnx, your concerns do sound like premature optimisation, mind
17:46:16 <MyCatVerbs> > case (Data.Sequence.viewl $ ((Data.Sequence.empty Data.Sequence.|> 5) Data.Sequence.|> 6)) of (x Data.Sequence.:< xs) -> x
17:46:17 <lambdabot>  5
17:46:24 * MyCatVerbs gasps.
17:46:31 <wy> MyCatVerbs: I haven't understood it yet. Do I need to use 'view' every time I do the match, or I can use pattern matching as usual?
17:46:38 <MyCatVerbs> wy: anyway. If Data.Sequence was in scope (grrrrr), that comes out as...
17:46:46 <radetsky> Saizan: I got other errors which I believe were due to the splitting of base (couldn't find Data.Map), which I fixed by explicitly depending on them in the .cabal
17:46:47 <Philippa> augustss: I can't help thinking actual views'll probably never be standardised in Haskell
17:46:49 <EvilTerran> jsnx, if your dictionary is so massive that reconstructing it every time causes a significant time penalty, consider using a database
17:46:53 <MyCatVerbs> wy: the viewl function there converts from the ADT into something you can match on.
17:47:17 <jsnx> EvilTerran: you mean, SQLite?
17:47:18 <Saizan> radetsky: yes, that module is now .Internal, but it seems the api has changed
17:47:18 <MyCatVerbs> wy: there's a second data type called ViewL, with constructors "Empty" and "a :< Seq a)
17:47:25 <EvilTerran> jsnx, that would do, yes.
17:47:33 <Saizan> ?hackage bytestring
17:47:34 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/bytestring
17:47:38 <jsnx> EvilTerran: maybe i'll do that
17:47:53 <jsnx> EvilTerran: though, maybe i should look at whatever HAPPS is using...
17:47:57 <MyCatVerbs> wy: so you would write: case (viewl sequence) of (x :< xs) -> -- moar code here
17:48:17 <EvilTerran> if you need to mung a lot of data, a database is usually a good idea
17:48:21 <jsnx> EvilTerran: as Alex seems to have some vision for persistent storage of Haskell muck
17:48:40 <wy> MyCatVerbs: So I have to use viewl each time I do the match
17:48:42 <MyCatVerbs> wy: the sequence implementation, Seq, can't be directly pattern matched on, as it's opaque (because it's damn complicated).
17:48:48 <jsnx> EvilTerran: yeah, you are right
17:48:58 <jsnx> EvilTerran: then i can have indexes and stuff
17:49:10 <MyCatVerbs> wy: yep. viewl converts from the opaque, complicated datatype to a trivial, transparent datatype on which you *can* pattern match.
17:49:11 <jsnx> EvilTerran: and generating the dictionary won't be such a hacky mess
17:49:14 <EvilTerran> indeed
17:49:18 <Valodim_> indices
17:49:50 <wy> MyCatVerbs: Can I do this with function definitions?
17:50:34 <jsnx> Valodim_: indices and indexes are different things, i think
17:50:35 <MyCatVerbs> wy: the proposed views feature for Haskell would literally just be abbreviating: "f sequ = case (viewl sequ) of (x :< xs) -> blah x xs" down to something more like "f (x :< xs) = blah x xs"
17:50:52 <jsnx> Valodim_: you can have an index into an index
17:50:55 <Valodim_> indices is plural of index
17:51:00 <jsnx> Valodim_: or indices into an index
17:51:08 <MyCatVerbs> wy: I'm not sure I understand your question. viewl and viewr are just a pair of ordinary functions provided by the person who wrote the Data.Sequence library.
17:51:09 <jsnx> Valodim_: or indices into indexes
17:51:43 <MyCatVerbs> wy: (that'd be a nice abbreviation, true, but it wouldn't change in any way what happens at run-time. I think. :)
17:51:50 <wy> MyCatVerbs: I see... So I don't need any extension for this. I just create another data type and convert to it for matching
17:51:50 <EvilTerran> "indexes" is a form of the noun "to index"; "indices" is the plural of the noun "index" (i think)
17:51:59 <MyCatVerbs> wy: precisely, yes.
17:52:17 <jsnx> EvilTerran: "to index" is a verb, not a noun
17:52:24 <EvilTerran> er, yes. brainfart.
17:52:29 <wy> MyCatVerbs: but I can't use it in function definitions
17:52:35 <MyCatVerbs> wy: think of ViewL and ViewR as "helper datatypes" and viewl and viewr as "helper functions". ;)
17:52:40 <EvilTerran> head going faster than fingers O.o
17:52:50 <MyCatVerbs> wy: no, but you can stick a case statement in and pattern match that way quite easily.
17:53:17 <EvilTerran> wy, or you could use pattern guards; they're a little more established than views
17:53:46 <wy> Let me count if I can save some cluttering...
17:53:48 <EvilTerran> foo s | x :< xs <- viewl s = ...
17:53:57 <jsnx> EvilTerran: anyways, a quick google search suggests "indexes" is a valid plural
17:54:24 <EvilTerran> jsnx, yes, they're probably both acceptable these days. sometimes i weep for the state of the modern english language. ;)
17:54:38 <ndm> if its a program variable, it should be indexs
17:54:46 <Valodim> indexs?
17:54:50 <jsnx> EvilTerran: do you weep for its inconsitencies? those are just a result of the norman invasions...
17:54:58 <ndm> there is no excuse for polutting a program because english sucks
17:55:04 <MyCatVerbs> EvilTerran: oooh, that's nice.
17:55:15 <Philippa> MyCatVerbs: I think you're confusing views and view patterns
17:55:38 <Philippa> there's a lengthy history here going back to when Haskell was first standardised
17:55:49 <jsnx> EvilTerran: english has the least consistent spelling of any european language...we might all be better off if we insisted on simpler rules
17:55:58 <EvilTerran> if this were lisp, we could have index*, or index+ if there's at least one ;)
17:55:59 <Valodim> haha
17:56:01 <Valodim> dude, no
17:56:11 <Valodim> german is way more inconsistent
17:56:14 <EvilTerran> I prefer to write haskell over english, anyway
17:56:17 <Valodim> you want consistent grammar, go japanese
17:56:25 <gregm> yeh, or lojban
17:56:32 <mauke> Valodim: I disagree
17:56:36 <EvilTerran> i have an idea:let's talk about haskell!
17:56:51 <Valodim> with what?
17:56:52 <jsnx> Valodim: grammar and spelling are not the same thing...
17:57:00 <mauke> in general!
17:57:06 <EvilTerran> MyCatVerbs, I hope you mean the pattern guard, not the weeping for the language...
17:57:32 <Valodim> duh
17:57:33 <jsnx> Valodim: german has much more consistent *spelling*
17:57:39 <Valodim> spelling then
17:57:44 <Valodim> you think so?
17:57:51 <mauke> yes
17:57:55 <jsnx> the correlation of sounds to letters is more consistent
17:57:55 <Valodim> index -> indices
17:58:00 <Valodim> in english, "indexes" is ok in the dictionary
17:58:02 <jsnx> Valodim: you can look it up
17:58:03 <Valodim> in german it's not
17:58:22 <MyCatVerbs> Philippa: I'm not sure whether I have anything confused here at all, since things seem to be working as I expect when I try them in ghci. ¨_¨
17:58:22 <Valodim> well sounds/letters
17:58:26 <mauke> irrelevant to spelling
17:58:28 <Valodim> but that's pronunciation, not spelling
17:58:30 <jsnx> Valodim: consistency must be determined by a weight of examples
17:58:57 <jsnx> Valodim: spelling is correlating a sound with letters...
17:59:09 <MyCatVerbs> EvilTerran: weeping for languages isn't much fun.
17:59:21 <MyCatVerbs> EvilTerran: pointing and laughing at languages is a much better hobby. Yes, I meant the patter guards.
17:59:23 <jsnx> Valodim: and german, italian, french, romanian, whatever -- all are more consistent than english
17:59:31 <Valodim> in pronunciation
17:59:34 <EvilTerran> hehe :)
17:59:38 <Valodim> I disagree that a language is defined by how it's spoken
17:59:43 <jsnx> Valodim: grammatically, german is much more complicated than english
18:00:17 <jsnx> Valodim: what does defined have to do with spelled?
18:00:32 <Valodim> what does pronunciation have to do with spelled?
18:00:43 <jsnx> Valodim: say you changed all the sounds in the same way, and left the spellings the same
18:00:53 <jsnx> Valodim: than the correlation would remain consistent
18:01:03 <Philippa> MyCatVerbs: are you aware that the new GHC feature is "view patterns", and that there are numerous proposals for different but related features generally known as "views"?
18:01:04 <jsnx> and that is what happened with german, french, italian
18:01:49 <jsnx> so, to learn to spell those languages, you need to learn relatively fewer combinations of letters (an order of magnituder or two, actually) than you need to learn to spell in english
18:02:24 <Valodim> that doesn't say anything about how regularly words are spelled
18:02:39 <mauke> I think English requires you to just memorize all the words
18:02:48 <jsnx> mauke: yes
18:03:04 <jsnx> mauke: there's about 50:1 spellings:phonemes
18:03:13 <Valodim> now you're exaggerating
18:03:18 <jsnx> Valodim: no
18:03:26 <mauke> you can't go from sound to spelling ("to", "two", "too") and you can't go from spelling to pronunciation ("worchester". hah.)
18:03:31 <jsnx> Valodim: it's about 1500 to 35
18:03:35 <mauke> er
18:03:40 <mauke> worcester
18:03:55 <MyCatVerbs> Philippa: I didn't see the second of those until you just mentioned it.
18:03:58 <allbery_b> you can in a large number of cases, but you have to know where the word came from to know which mapping to use
18:04:07 <MyCatVerbs> Philippa: I was talking about http://hackage.haskell.org/trac/haskell-prime/wiki/Views <-- thars.
18:04:08 <lambdabot> Title: Views - Haskell Prime - Trac
18:04:32 <jsnx> allbery_b: which underscores my point
18:04:34 <EvilTerran> milngavie!
18:04:37 <MyCatVerbs> Philippa: view patterns sound like they'd solve exactly the same problem, but with nicer syntax.
18:04:43 <allbery_b> anglic, saxon, norman french, or lifted from some other language later --- then you have to know the spelling changes that happened in the US
18:04:55 <EvilTerran> (that one's from auld scots, iirc)
18:04:58 <jsnx> allbery_b: english has relatively poor correlation between sound and spelling
18:05:17 <MyCatVerbs> Philippa: am I missing something here?
18:05:18 <jsnx> allbery_b: in fact, it has the most inconsistent spelling system of any european language
18:05:42 <jsnx> we would all be better off if more consistent spelling were encouraged
18:05:58 <Valodim> I don't think so
18:06:12 <EvilTerran> the problem with aiming for "consistent spelling" is what's consistent in one region will be desperately inconsistent in another
18:06:13 <mauke> it would certainly help me speak English
18:06:18 <Valodim> unlike programming languages, making it easier to learn and speak doesn't exclusively have positive effects
18:06:28 <Valodim> for spoken languages
18:06:28 <olsner> I think we're currently best off leaving the inconsistent spelling of english as is
18:06:38 <jsnx> Valodim: you have made a lot of bare assertions, which you are only able to back up with ignorance
18:06:50 <jsnx> olsner: it will self correct
18:06:50 <EvilTerran> jsnx, oy, we'll have none of that tone in here
18:07:00 <jsnx> EvilTerran: very well
18:07:04 <Valodim> hum
18:07:14 <Valodim> first one was more an opinion I didn't expect that much response to
18:07:18 <Philippa> EvilTerran: a lot of US english spellings are nonsensical to people in the UK. They only really make sense when you consider the accents involved
18:07:20 <EvilTerran> at least take it to #haskell-blah, I'm sure they could use the excitement
18:07:29 <allbery_b> (and then there's crap like aluminium <-> aluminum, which pronunciation changes rather more radically than you'd think between Commonwealth and US English)
18:07:29 <mauke> I often hit an English word that I just don't know how to pronounce because I've only ever seen it written on the internet :/
18:07:33 <jsnx> olsner: as more non-english speakers learn english, they will shy away from the rattier parts of the language
18:08:03 <jsnx> olsner: and start to use "ignorant" spellings
18:08:17 <jsnx> olsner: which native speakers should silently accept :)
18:08:24 <Philippa> MyCatVerbs: while you can achieve the same dynamic semantics with view patterns, they don't subsume views for reasoning purposes
18:08:51 <jsnx> mauke: yeah, even a native finds themself with that problem if they read a lot
18:09:18 <olsner> I'm kind of seeing the opposite though - foreigners trying to learn english right also learn the inconsistent spellings, while the natives get more and more sloppy with their spelling
18:09:20 <MyCatVerbs> Hrmn, hpaste.org seems unusually slow tonight.
18:09:36 <Valodim> I agree with olsner here
18:09:40 <mauke> olsner: yes! that's me!
18:10:00 <Valodim> most people who have really bad spelling on forums and refuse to improve are native english speakers
18:10:40 <Valodim> non-native speakers usually have more problems with grammar
18:10:58 <mauke> mentally translating from your native language to English helps you distinguish between there/their/they're, you're/your, etc :-)
18:11:20 <allbery_b> ...of course then there's the question of how much of that is because the US primary educational system is little more than institutionalized daycare...
18:11:37 <jsnx> Valodim: well, you have not dealt much with the poor english of chinese people :)
18:11:38 <Philippa> allbery_b: it's true outside the US
18:11:49 <Valodim> haha, that's right I've not spoken to chinese people much
18:12:06 <Valodim> but most roman languages
18:12:12 <jsnx> Valodim: and, there are *a lot* of chinese people who use bad english
18:12:24 <jsnx> Valodim: they may save us from our inconsistencies
18:12:46 <Valodim> I think it's part of our culture
18:12:53 <jsnx> Valodim: what is?
18:13:05 <wy> augustss: Can we just borrow from Common Lisp whose field accessor can be redefined?
18:13:09 <Valodim> spelling
18:13:11 <jsnx> Valodim: whose culture?
18:13:16 <Valodim> and its inconsistencies
18:13:19 <jsnx> Valodim: english speakers?
18:13:21 <Valodim> human's
18:13:43 <jsnx> Valodim: humans' ?
18:13:48 <gregm> not to mention apostrophization and it's inconsistencies :)
18:13:50 <Valodim> haha
18:13:51 <Valodim> argh
18:13:51 <Valodim> dang
18:13:54 <Valodim> yeah
18:13:55 <MyCatVerbs> Philippa: k, I can see both of those being useful and fun.
18:14:07 <Valodim> well in that case "human" could arguably be generic singular :P
18:14:12 <jsnx> gregm: yeah, we should have just left the 'e' in there like the other germanic languages do
18:14:12 <Philippa> wy: As a rule, Common Lisp generally does things in ways that Haskell really really shouldn't
18:14:49 <Philippa> you can do redefining field accessors in a haskell-friendly manner, but certainly not in a haskell98-friendly one
18:15:11 <Valodim> saying we should allow everyone to more or less write phonetically promotes learning laziness, which is undesirably in one of the first systematic things everyone learns in his life
18:15:18 <wy> for example: data Vector = Vector {vecX@x, vecY@y, vecZ@z :: Double, data:: RealData}
18:15:50 <jsnx> Valodim: well, it hasn't hurt germany
18:15:59 <jsnx> Valodim: didn't hurt the romans or greeks
18:16:06 <Valodim> we have complicated grammar :P
18:16:06 <jsnx> Valodim: the english language is the outlier here
18:16:08 <MyCatVerbs> Philippa: but to me it looks like pattern guards do solve most|all of the problems for which views (Wadler's proposed views, I mean)... albeit with the proviso that views seem rather more elegant, and nobody has ever implemented them.
18:16:11 <wy> The fields x, y and z are redirected to the functions vecX, vecY, vecZ and they must be of type RealData->Double
18:16:24 <jsnx> Valodim: we have much simpler grammar than german, greek or latin
18:16:35 <Philippa> jsnx: english is an outlier in terms of rabidly assimilating words from other languages, too
18:16:38 <Valodim> who, english or german?
18:16:43 <jsnx> Philippa: exactly
18:17:07 <Valodim> I was refering to German as "we" there, sorry that was ambiguous
18:17:12 <jsnx> Philippa: assimiliation, without a standards body
18:17:16 <Valodim> <- native german speaker
18:17:23 <wy> vecX, vecY, vecZ double as field accessors in labeled pattern matching and update.
18:17:31 * Philippa digs up the Nicoll quote
18:17:33 <Philippa> "The problem with defending the purity of the English language is that English is about as pure as a cribhouse whore. We don't just borrow words; on occasion, English has pursued other languages down alleyways to beat them unconscious and rifle their pockets for new vocabulary."
18:17:35 <jsnx> Valodim: i took you for an american
18:17:43 <MyCatVerbs> Philippa: we don't so much borrow words from other languages as mug them in dark alleyways and rifle through their pockets for vocablurary. ;)
18:17:49 <Valodim> uh... thank you? ;)
18:17:55 <jsnx> Valodim: no
18:18:01 <MyCatVerbs> Damn, I'm slow. >_>
18:18:10 <Philippa> Valodim: I think you're meant to spell that with a u instead of the a
18:18:21 <Philippa> amongst other adjustments :-)
18:18:25 <olsner> oh, stereo
18:18:36 <Valodim> what?
18:18:39 * olsner remembers the good old days of the stereo quote
18:18:41 <Valodim> thunk?
18:19:03 <jsnx> Philippa: english has a larger vocabulary than any natural language
18:19:09 <Philippa> Valodim: nearly there. Now phonetically you just need to tweak the n...
18:19:36 <jsnx> Philippa: but a lot of those words are technical
18:19:38 <Valodim> thunnk?
18:19:39 <Philippa> jsnx: are you suggesting that english is unnatural, as in acts?
18:19:52 <jsnx> Philippa: as in "acts" ?
18:19:54 <Philippa> Valodim: other way - try removing it
18:20:08 <Philippa> jsnx: ever heard the expression "unnatural acts"?
18:20:21 <jsnx> Philippa: i'm not sure what you are getting at
18:20:52 <Valodim> me neither... thuk?
18:21:11 <jsnx> Valodim: i think she is suggesting that you should curse me for calling you american
18:21:13 <wy> When the pattern matcher found that the field has an accessor, it passes the value to the accessor which will return the field value of correct type.
18:21:25 <Valodim> go thuk yourself :P
18:21:27 <jsnx> Valodim: but really, you should curse yourself :)
18:21:39 <Philippa> jsnx: yep. Unsubtle joke delivered with apparently far too much subtlety
18:21:52 <jsnx> i'm from the states, by the way
18:21:56 <ndm> does anyone know if anyone has investigated removing letrec from haskell,other than at teh top level?
18:22:20 <Philippa> ndm: what do you have in mind?
18:22:23 <wy> This way I don't even need to change other parts of the syntax such as case expressions
18:22:59 <jsnx> Philippa: unfortunately, i was able to capitalize on the delay
18:23:09 <Philippa> "what do you get semantically if you remove letrec and the usual ways of expressing it such as lazy patterns on tuples"?...
18:23:35 <Philippa> jsnx: I was asking if by saying "english has a larger vocabulary than any natural language" you were suggesting English is distinctly buggered up
18:24:02 <ndm> Philippa: not what to you get, but how do you do it, has anyone analysed it in detail etc
18:24:10 <ndm> i do it - what you get is a simpler core language
18:24:21 <jsnx> Philippa: i meant "any other natural language"
18:24:44 <ndm> i.e. what can i cite, or do i need to write it myself in my thesis
18:24:51 <jsnx> Philippa: it has a distinct problem it needs to solve, which is how to avoid respelling all those foriegn words
18:25:00 <ndm> in papers a hand wavey "we translate away letrec's is sufficient", in my thesis it isn't
18:25:31 <jsnx> Philippa: while at the same time, not allowing the core language to get all messed up
18:25:47 <Philippa> ndm: what do you want to translate it down to? SPJ's old book's got some stuff on it
18:25:52 <ndm> (i do know how to remove letrecs, and have implemented it, but if i don't have to prove it etc...)
18:26:00 <ndm> Philippa: specifically on removing letrecs?
18:26:12 <ndm> Philippa: standard Core without letrec
18:26:27 <Philippa> Core as in GHC Core?
18:26:35 <jsnx> Philippa: we don't have an academy de anglais, so there's no actually vehicle for changing the language in a structured way...instead we just have a "we've always spelled it this way" approach
18:26:38 <ndm> Philippa: close enough, yes
18:27:14 <Philippa> it might be worth poking over the definition of let in the Report first, then there's something along those lines in SPJ's book IIRC
18:27:20 <jsnx> s/actually//
18:27:36 <ndm> Philippa: in the report, letrec is primitive, and in the Core
18:27:46 <MyCatVerbs> jsnx: well, we do have the OED.
18:28:14 <allbery_b> the OED, especially of late, is more descriptive than prescriptive
18:28:44 <jsnx> MyCatVerbs: yeah, but they don't ever actually adjust anything
18:29:33 <MyCatVerbs> jsnx: they do track changes in what people actually write, though, don't they?
18:29:38 <jsnx> MyCatVerbs: yes
18:30:09 <Saizan> radetsky: still there? i've got it(torrent) compiling on 6.8.2 if you want it, even if the best thing would be mailing the maintainer for an update
18:30:11 <jsnx> MyCatVerbs: but that's a little different than what i was talking about
18:30:23 <radetsky> Saizan: yes
18:30:24 <Philippa> jsnx: they do describe usages as 'archaic'
18:30:37 <radetsky> what did you do?
18:31:11 <jsnx> Philippa: the academe de francais does a lot more than that -- they actually make rulings on the language
18:31:22 <Saizan> radetsky: changed some BS related stuff, making the interfaces match again
18:31:28 <Philippa> jsnx: I know
18:31:42 <jsnx> we may need that for english soon enough, since international commerce rides on it
18:31:50 <Philippa> ITYM "the OED is not authoritative"
18:31:59 <Philippa> there's some flavour of standard for "International English"
18:32:06 <Philippa> it tends towards US english
18:32:27 <ndm> i think England should just give up on English, and move to US English
18:33:02 <jsnx> ndm: yeah, and the Southern US should just give up on their english, and move to Midwestern ("American") English
18:33:24 <jsnx> ndm: &c.
18:33:56 <MyCatVerbs> Philippa: yes, it's called "the particular dialect that Indian and Chinese schools teach their children". ;)
18:34:18 <jsnx> MyCatVerbs: they often teach British English
18:34:19 <MyCatVerbs> Philippa: (the standard, I mean. Or at least, if it isn't the standard already, it soon will be the de-facto one.)
18:34:42 <MyCatVerbs> jsnx: which is then promptly mutated by the fact that it's a second tongue. :)
18:34:55 <jsnx> MyCatVerbs: right, but it's definitely British
18:35:09 <jsnx> MyCatVerbs: or "Queens's" -- not all Brits speak that way
18:35:41 <jsnx> it's the spelling that needs standardization though, not the speaking
18:35:48 <MyCatVerbs> s/all/many/
18:35:56 <MyCatVerbs> Nahhhhh.
18:35:58 <allbery_b> 'please do the needful'
18:36:06 <jsnx> ultimately, you want to simplify the language of commerce
18:36:08 <MyCatVerbs> Just stick something that looks vaguely like the word you're after into Google.
18:36:14 <jsnx> and that happens in writing
18:36:23 <jsnx> MyCatVerbs: that will standardize the spelling with time
18:36:35 <MyCatVerbs> If your spelling doesn't agree with the consensus spelling, Google will ask you, "Did you mean $foo?"
18:37:02 <jsnx> MyCatVerbs: right, but many more people will skip going to the effort, and just misspell the word
18:37:09 <MyCatVerbs> jsnx: sort of, yes. At least it means it *should* (hopefully) never be hard to work out exactly what the current consensus is.
18:37:16 <jsnx> MyCatVerbs: right
18:37:18 <MyCatVerbs> jsnx: yep. Is that a problem? :)
18:37:29 <jsnx> MyCatVerbs: and a way to track the consensus allows for language reform
18:37:34 <MyCatVerbs> jsnx: By doing so they'll be altering the average position of the current consensus. ;)
18:37:43 <jsnx> MyCatVerbs: it's iterative
18:38:25 <jsnx> anyway, the consensus suggests "indexes" is a perfectly legitimate plural for index
18:38:32 <jsnx> Valodim: so, i stand with it
18:38:45 <MyCatVerbs> jsnx: even though the *correct* word is indices? ;)
18:38:59 <jsnx> MyCatVerbs: we don't have any authority for that, do we?
18:39:04 <Valodim> most dictionaries were pressured into accepting it, too
18:39:09 <MyCatVerbs> Yes we do.
18:39:16 <MyCatVerbs> Not dictionaries.
18:39:22 <MyCatVerbs> onsensus or no consensus, mathematics textbooks always take priority ;)
18:39:47 <jsnx> MyCatVerbs: all of them?
18:39:47 <MyCatVerbs> *Consensus (how did that happen, I wonder?)
18:39:55 <MyCatVerbs> jsnx: no, only the good ones. :)
18:40:22 <Jangler> "index" in mathematics textbooks often refers to a subscript, like in a sequence {a_ij}, i and j are indices of the sequence
18:40:34 <jsnx> MyCatVerbs: that's cute, MyCatVerbs, but there's little reason to believe mathematicians even able to write
18:40:42 * EvilTerran ponders abandoning his type hackery and moving back to pushing around bits of TH
18:40:45 <jsnx> s/even/are able/
18:40:54 <MyCatVerbs> jsnx: uh, then what's Knuth, chopped liver? :)
18:41:25 <EvilTerran> well, TeX source has a remarkable simularity in appearance to chopped *something*, anyway
18:41:35 <jsnx> MyCatVerbs: i will not comment on that old goof
18:41:49 <Jangler> In Merriam-Webster, there is a specific note on that meaning of "index" saying that the plural is often "indices"
18:42:01 <jsnx> MyCatVerbs: he is exceptional, to say the least
18:42:20 <jsnx> MyCatVerbs: and his spelling is likely not his own, but rather that of his copy editor
18:42:32 <Jangler> Though for other meanings, like the list of names/topics in the back of the book, it gives both as variants of equal standing
18:42:32 <jsnx> MyCatVerbs: and that's not going to track consensus well
18:42:53 <glen_quagmire> hpaste.org is weird
18:42:59 <MyCatVerbs> jsnx: but he does publish errate for his books, including grammatical and spelling errors.
18:43:06 <glen_quagmire> I can't paste things
18:43:26 <MyCatVerbs> jsnx: so since he hasn't rescinded huge chunks of text, presumably he does at least on *some* level agree with his copy editor. That's enough for me. :)
18:43:34 <MyCatVerbs> glen_quagmire: it seems to be down for me.
18:44:02 * EvilTerran ponders an unholy combination of SYB and TH
18:44:05 <glen_quagmire> http://rafb.net/p/igarjz71.html   ok what do you prefer?
18:44:05 <lambdabot> Title: Nopaste - No description
18:44:26 <Jangler> In fact, there is a quote in Knuth's most recent online fascicle--"Indexes need not necessarily be dry" (Henry B. Wheatley, "How To Make An Index")
18:44:35 * EvilTerran prefers the latter
18:44:40 <glen_quagmire> I like the first version
18:44:41 <jsnx> Jangler: lolz!
18:44:58 <glen_quagmire> is there any performance penalty for using version 1) ?
18:44:59 <noblethrasher> RE: Knuth and writing -- http://scpd.stanford.edu/scpd/students/Dam_ui/pages/ArchivedVideoList56K.asp?Include=knuthMath
18:45:01 <lambdabot> http://tinyurl.com/2ovshw
18:45:20 <EvilTerran> very unlikely to be at all significant, if at all. it might take a little longer to compile.
18:45:23 <EvilTerran> unnecessary variable names bug me, is all
18:45:39 <glen_quagmire> oh i see
18:45:42 <jsnx> MyCatVerbs: why is Knuth a credible source for spelling english?
18:45:50 <jsnx> MyCatVerbs: but not for german?
18:46:18 <jsnx> MyCatVerbs: Whitehead wrote in English, too...how should we spell colour?
18:46:31 <MyCatVerbs> jsnx: dunno, does Knuth speak German natively?
18:46:59 <jsnx> MyCatVerbs: there is no way around the timeliness of language, and math books are apt to have the most conservative spellings
18:47:14 <MyCatVerbs> jsnx: is that a problem?
18:47:22 <jsnx> MyCatVerbs: also, Knuth got his spelling from somewhere...
18:47:27 <Jangler> As far as indexes/indices goes, note that here the source isn't Knuth, but someone who wrote a *book* on indexes. In *1902*. So this is not some indication of modern English falling into a shambles.
18:47:47 <jsnx> Jangler: aye?
18:48:03 <jsnx> Jangler: a book on indexes of books?
18:48:12 <MyCatVerbs> jsnx: of course! But he represents a decent arbitrary point to measure relative to.
18:48:16 <Jangler> By Henry B. Wheatley, apparently.
18:48:19 <jsnx> MyCatVerbs: not really
18:48:26 <jsnx> MyCatVerbs: he's a mathematician
18:48:33 <jsnx> MyCatVerbs: i don't go to them for spelling
18:48:34 <allbery_b> people were complaining about English falling apart in the mid-1800s....
18:48:51 <jsnx> MyCatVerbs: i think that mathematicians are people who focus on math, actually
18:48:57 <MyCatVerbs> jsnx: since whatever you attempt to standardize your language against will be at least somewhat arbitrary - pick a dictionary, for example. Why the OED over Merriam-Webster, or Webster over the Times Crossword Dictionary?
18:49:35 <jsnx> MyCatVerbs: at least the OED has all the words in it
18:49:37 <MyCatVerbs> jsnx: so you might as well pick a completely stupid point to fix against, since it's arbitrary anyway. Hence, Knuth. Because Knuth has less hair than most people, and is general-purpose awesome.
18:50:19 <MyCatVerbs> http://www.stanfordalumni.org/news/magazine/2006/mayjun/images/features/knuth_don.jpg <-- you can't argue with a dome as chrome as that.
18:50:28 <jsnx> MyCatVerbs: yeah, this could go on -- i say Chaucer, because he was baudy...
18:50:44 <MyCatVerbs> jsnx: oooh, good idea! I'd support it.
18:50:56 <Jangler> Chaucer? Does your keyboard have an edh?
18:51:02 * EvilTerran tends to use princeton wordnet for his spellinga/definitions needs
18:51:08 <jsnx> Jangler: use SCIM :)
18:51:12 <MyCatVerbs> jsnx: iff you actually got together a dictionary cribbed together from Chaucer's works.
18:51:29 <jsnx> MyCatVerbs: you can't get one from Knuth's, either
18:51:42 <jsnx> MyCatVerbs: where does he ever talk about sex and drugs?
18:52:06 <jsnx> MyCatVerbs: how would i sing about a bawdy nun in Knuthlish?
18:52:21 <MyCatVerbs> jsnx: for that, you have to go over to his house and spike his drink.
18:52:28 <MyCatVerbs> jsnx: but it's still humanly achievable.
18:52:34 <jsnx> MyCatVerbs: it is a crime
18:52:35 <MyCatVerbs> Anyway, sleep now.
18:52:40 <jsnx> MyCatVerbs: good night
18:53:23 <MyCatVerbs> jsnx: have a nice time. And don't bother to debate anything about natural languages with someone who militantly doesn't care in the least about the subject, they'll just act annoying and boring. ;)
18:53:32 <MyCatVerbs> (Not to mention stupid. ^_^)
18:53:46 <ndm> jsnx: he goes into haskell-blah to discuss sex and drug :)
18:54:01 <jsnx> MyCatVerbs: it takes a few years to have it's effect on their minds
18:54:34 <glen_quagmire> GenParser Char st [Char]    is this a monad (GenParser Char st) [Char] ??  I only saw Monad defined as m a. So, I think (GenParser Char st) is m, and [Char] is a ?
18:55:05 <jsnx> glen_quagmire: a monad needs some operations, too
18:55:48 <EvilTerran> glen_quagmire, yes, that's right
18:56:14 <jsnx> EvilTerran: eh? doesn't it need bind and return ?
18:56:16 <EvilTerran> type Parser a = GenParser Char () a  -- for example, if this makes it easier to think about
18:56:26 <EvilTerran> jsnx, it has 'em. he's talking about Parsec here.
18:56:32 <jsnx> EvilTerran: oh, i see
18:56:53 <glen_quagmire> hope it'll be clearer when i finish this tutorial
19:27:18 <wy> I came up with an alternative design to views. http://paste.lisp.org/display/53050 (hpaste is down?)
19:35:59 <sjanssen> wy: what about views that can view several datatypes?
19:37:18 <wy> sjanssen: Different (virual) data contructors has a corresponding encapsuler and accessors.
19:37:56 <sjanssen> wy: what if I want to use a single virtual constructor for several concrete types?
19:38:50 <sjanssen> eg. [a], Seq a, ByteString, Set a, all have a view similar to :
19:39:32 <wy> sjanssen: Ah I see what you mean
19:41:05 <wy> sjanssen: That's something more than what I've thought of, but there is a coupling between data types with constructors, much like that of types in a classes and methods
19:42:54 <wy> I just found Wadler's view paper... He used something called "abstype". That sounds like a better name than "absdata". They look similar
19:43:54 <wy> Actually I found they are identical!
19:50:02 <wy> I seems that he has a better idea... I'll read the paper carefully.
20:08:46 <wy> Ha! I like Wadler's paper a lot! They explain the things so well for understanding and have insights
20:21:16 <ac> I'm sure this has been asked before, but how do you restrict a peramater in a type signature to one type class?
20:22:00 <ac> For example, let's say you wrote a sort function of type "[a] -> [a]", how do you indicate a is an instance of Ord?
20:24:41 <ac> huh, guess there won't be a lot of help here this evening :-P
20:25:02 <ac> Merry Christmas to all!
20:25:33 <wy> ac: merry xmas!
20:25:59 <araujo> ac, f :: Ord a => [a] -> [a]
20:26:35 <wy> When you call compare, or any of "<",">","<=", ... it will be automatically restricted
20:27:56 <ac> wy: ok, I guess I have some other sort of type error
20:28:43 <ecksit> hello, do u guys know if haskell is good for game development?
20:29:17 <ecksit> im having trouble starting off with haskell and was hoping that to help me learn i could write a card game i always wanted to write in C++
20:29:25 <ac> araujo: cool. Wasn't sure if that was valid or not
20:29:37 <ecksit> i saw that they have the SDL binding but im not sure how stable they are
20:30:00 <ac> ecksit: HSOpenGL works great
20:31:32 <ecksit> k, ill try starting out, what i got stuck on before was the ai, hopefully in haskell itll be much easier
20:32:20 <ac> ecksit: good luck :)
20:32:44 <noecksit> <ac> haskell and was
20:32:44 <noecksit>           hoping that to help
20:32:44 <noecksit>           me learn i could
20:32:44 <noecksit>           write a card game i
20:32:44 <noecksit>           always wanted to
20:32:45 <noecksit>           write in C++
20:32:55 <ac> here's a new one for me: "can't justify consrtaints in explicitly typed binding"
20:33:08 <noecksit> sorry for the flood, ac: thanx
20:42:58 <ac> @search replicateM
20:42:58 <lambdabot> Unknown command, try @list
20:43:06 <ac> @whereis replicateM
20:43:07 <lambdabot> Maybe you meant: where where+
20:43:22 <ac> @where replicateM
20:43:22 <lambdabot> I know nothing about replicatem.
20:43:31 <ac> :'(
20:43:43 <ac> @hoogle replicateM
20:43:44 <lambdabot> Control.Monad.replicateM :: Monad m => Int -> m a -> m [a]
20:43:44 <lambdabot> Control.Monad.replicateM_ :: Monad m => Int -> m a -> m ()
21:04:47 <wy> augustss_: I looked at the view patterns in ghc and I don't like it. It seems that Wadler 1987's solution is much better.
21:06:49 <wy> @users
21:06:49 <lambdabot> Maximum users seen in #haskell: 434, currently: 338 (77.9%), active: 2 (0.6%)
21:06:58 <wy> all gone ;-)
21:12:06 <mxc> anyone familiar with HaXML, HXML, and HXT?
21:12:20 <mxc> i.e. which would be easiest for a newbie to use in a starter project?
21:13:12 <Cale> I've used HXT, and that was fun. The documentation is a little tricky to dig around in, but once you get the idea of the library, it's manageable.
21:14:11 <Cale> One caveat is that I was already pretty good with Haskell by the time I tried it. It may be slightly overwhelming for a beginner.
21:17:35 <mxc> i have to say, learning haskell is making ocaml look like a walk in the park
21:18:45 <noecksit> hello, how would i go about catching IO errors when a file doesn't exist
21:19:12 <noecksit> i know id have to use a try, and then return a IOError, which is boolean
21:19:57 <noecksit> but what if its not an error and just returns an IO
21:20:11 <dibblego> ?type catch
21:20:13 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
21:22:29 <Cale> mxc: Oh, if you're an o'caml user, you have quite an advantage though :)
21:22:45 <mxc> true
21:22:58 <oerjan> noecksit: try is not haskell (indeed it's ocaml)
21:23:01 <mxc> not including monads
21:23:12 <oerjan> (well it is something completely different in haskell)
21:23:13 <Cale> I've even seen monads in o'caml code.
21:23:22 <mxc> they do exist
21:23:29 <mxc> but they are much less frequently used
21:23:32 <Cale> (In particular, fftw uses monads)
21:23:34 <dibblego> I've seen monads in Java code
21:23:39 <mxc> and you do almost anything w/out them
21:23:47 <Cale> dibblego: In a real application?
21:23:58 <dibblego> Cale, they were just called something else
21:24:10 <dibblego> the (Either a) monad has a keyword in Java/C#
21:24:26 <Cale> Oh, well, I don't really consider it a use of monads until you've actually made the abstraction.
21:24:40 <dibblego> me neither really, but it's still a monad :)
21:24:46 <Cale> If you can't write code that operates polymorphically across monads, then you're not using monads.
21:24:54 <dibblego> agreed
21:25:47 <sjanssen> disagree
21:25:50 <mxc> also, anyone using GHC on osx 10.5?
21:26:00 <ecksit> oerjan: what do u mean? its in the IO library
21:26:04 <sjanssen> when I'm writing IO code, I'm not using monads?
21:26:06 <oerjan> it is?
21:26:13 * oerjan blushes
21:26:36 <Cale> sjanssen: No, you're using just one monad, and you don't actually have to be aware of the general abstraction to do so.
21:27:31 <Cale> :t try
21:27:32 <lambdabot> Not in scope: `try'
21:27:38 <Cale> :t Control.Exception.try
21:27:39 <lambdabot> forall a. IO a -> IO (Either GHC.IOBase.Exception a)
21:27:39 <noecksit> http://www.haskell.org/onlinelibrary/io.html
21:27:39 <lambdabot> Title: The Haskell 98 Library Report: Input/Output
21:27:50 <Cale> :t Control.Exception.catch
21:27:51 <lambdabot> forall a. IO a -> (GHC.IOBase.Exception -> IO a) -> IO a
21:28:04 <sjanssen> dibblego: I think it's a bit of a stretch to call try/catch monadic
21:28:18 <dibblego> sjanssen, throws is exactly the Either a monad
21:29:01 <dibblego> if the use of try/catch were mandated, then I'd agree, but since it's not mandated, then it is taking perfect advantage of being a monad
21:31:09 <Cale> Oh, very cool! A QT binding!
21:37:09 <wy> Cale: Where? where?
21:37:55 <Cale> http://qthaskell.sourceforge.net/
21:37:55 <lambdabot> Title: qtHaskell
21:50:20 <jsnx> so, say i have cabal package, and it has a database with it, and i write a few functions to query the database for stuff. how does the loaded module know where to find the database?
21:50:46 <jsnx> (the functions to query the database are in a module that's part of the cabal package)
21:51:42 <wy> I found that view patterns are going to turn Haskell into another Perl ;-)
21:52:31 * oerjan suddenly realizes @pl is an abbreviation for "perlify"
21:56:16 <Cale> wy: oh?
21:57:51 <wy> An objection to view patterns: we wanted to solve the data abstraction problem. But now we haven't abstract the implementation away (we have to know the pattern is for an abstract type and use an arrow before it!), and we now have more than one way to do the same thing, such as inserting into lists....
22:00:32 <Cale> wy: Of course we know which type the pattern is for
22:01:02 <wy> With Wadler's original design, we don't have any difference in the case expressions. If we desire, we could delete out abstract type and restore the data type as the view type.
22:02:29 <bos> @hoogle split
22:02:30 <lambdabot> Data.ByteString.split :: Word8 -> ByteString -> [ByteString]
22:02:30 <lambdabot> Data.Set.split :: Ord a => a -> Set a -> (Set a, Set a)
22:02:30 <lambdabot> Data.Map.split :: Ord k => k -> Map k a -> (Map k a, Map k a)
22:02:30 <wy> Cale: But you have to know it IS an abstract type. I don't like the idea what you know it is abstract.
22:02:56 <Cale> Well, it doesn't necessarily have to be abstract.
22:03:17 <Cale> You're just viewing it in a way which isn't via the constructors.
22:03:44 <wy> Cale: But after you add the arrows in front of your case patters, they look different from other patterns
22:04:05 <wy> so it's not completely transparent and natural
22:04:32 <jsnx> wy: what would be "transparent and natural"?
22:05:14 <Cale> wy: But without that arrow, you couldn't tell apart matching against the codomain of the view and using the view itself.
22:05:22 <wy> jsnx: By that I mean, if you delete your abstract type, and just implement the type as a normal data type, must the case patterns be change
22:05:37 <Cale> (I'm thinking that you're referring to the shorthand syntax for  view -> pat
22:05:40 <Cale> )
22:05:59 <jsnx> wy: if you always on insist on exporting a 'view' function and using it, they would stay the same...
22:06:01 <Cale> Of course you can implement the view function as id.
22:06:25 <wy> I'm referring to view-> or just ->. any way they are different from normal use
22:06:41 <Cale> Well, they're different because they do extra processing.
22:06:46 <jsnx> Cale: aye, but we can see where that leads -- boiler plate!
22:06:58 <wy> Cale: But ideally that must be abstracted away
22:07:54 <Cale> (-> 0) and 0 are very different patterns.
22:08:21 <wy> Cale: very different. Aren't they?
22:08:35 <wy> I think the point is in Wadler's paper: http://homepages.inf.ed.ac.uk/wadler/papers/view/view.ps
22:09:19 <wy> We only need a keyword "abstype" to define the views, and the case expressions don't need to be different at all
22:09:45 <jsnx> you know though, the idea of matching against the result of some function is kind of cool...
22:09:54 <wy> Think about it. How much more code is using case patterns than an abstype definition.
22:10:08 <wy> jsnx: That's Perl's thinking...
22:10:29 <jsnx> wy: right
22:10:42 <jsnx> wy: basically, this proposal allows for so much more than views...
22:10:51 <wy> jsnx: We don't need it. right?
22:11:04 <jsnx> wy: not like this
22:11:28 <jsnx> wy: if i want to do stuff like that, i use a where clause
22:11:29 <wy> We just want abstraction. That's what's really needed.
22:11:52 <jsnx> wy: and apply the function and do the match in the where clause
22:12:28 <jsnx> wy: do we need that? why isn't the "general transformer plus pattern match in a where clause" sufficient?
22:13:23 <wy> The point is: how much code is affected by a change in your basic data representation, and how much is affected by other aspects
22:14:31 <jsnx> well, now that i think about it, i can't pattern match in the where clause...
22:14:37 <Cale> A nice thing about view patterns is that they only change the pattern syntax and essentially make no other changes to the language.
22:14:38 <jsnx> i have to use a case
22:14:43 <wy> Once you add an arrow before your pattern, you will have hundreds of them there. And one day you will want to remove them all
22:15:06 <jsnx> what if the arrow is enforced, instead?
22:15:09 <Cale> wy: Why will you want to remove them all?
22:15:47 <jsnx> make everything be a member of the type class "PatternMatchables"
22:15:54 <Cale> That arrow changes the meaning of the pattern.
22:15:59 <jsnx> and use overlapping instances
22:15:59 <wy> Cale: I decided that data type is enough for my implementation. Or I could set the view function to id... That's ugly
22:16:15 <Cale> Why is that ugly?
22:16:31 <jsnx> wy: i agree that it's ugly
22:16:33 <Cale> Also, how is that not going to require a massive overhaul anyway?
22:17:16 <Cale> Quite often a view of a datatype won't be isomorphic to it.
22:17:24 <wy> Cale: If we have a keyword called "abstype" there, no one would notice a change in your code except at the definition.
22:18:32 <wy> If you don't use it, the language has essentially no change
22:18:56 <wy> and you can decide to use it any time without modifying you case patterns
22:18:57 <Cale> You mean abstype from Miranda?
22:19:36 <wy> maybe. I just read Wadler's 1987 paper about views: http://homepages.inf.ed.ac.uk/wadler/papers/view/view.ps
22:19:43 <Cale> http://www.freaknet.org/martin/libri/Miranda/Overview.html#Abstract -- like this one?
22:19:44 <lambdabot> Title: An Overview of Miranda, http://tinyurl.com/2n6c99
22:20:28 <jsnx> i'm reading the paper now, too
22:20:49 <Cale> The views paper is an argument against abstype, if I recall correctly.
22:21:26 <jsnx> wow, there has to be more than one view
22:21:28 <wy> It doesn't look the same as proposed by Wadler
22:21:50 <Cale> Wadler doesn't propose abstype in that paper.
22:22:01 <wy> Oh sorry... he compared with abstype ;-)
22:22:14 <wy> ok. The thing is called views
22:25:29 <Cale> Anyway, I'm not so convinced there's a really good argument for wanting to degeneralise code.
22:25:56 <Cale> Usually things go the other way, in fact.
22:26:11 <jsnx> Cale: although i agree, i think those (view ->) phrases will end up in all sorts of places where they don't belong
22:26:28 <Cale> hmm
22:26:31 <jsnx> Cale: why not just use them everywhere, so you can generalize the code later?
22:26:40 <jsnx> Cale: it will happen
22:27:30 <Cale> Maybe because you'd prefer to have functions with saner types?
22:27:41 <jsnx> Cale: what do you mean?
22:27:41 <Cale> consider the difference between:
22:27:51 <wy> But with the original views, you have the choice to stop generalize at anytime and back forth
22:28:06 <jsnx> Cale: i'd like to see your example
22:29:15 <Cale> length [] = 0; length (x:xs) = 1 + length xs   genLength (-> []) = 0; genLength (-> (x:xs)) = 1 + genLength xs
22:30:15 <jsnx> Cale: but why not just omit the (-> ) bit altogether?
22:30:23 <Cale> length :: (Num b) => [a] -> b  whereas  genLength :: (View a [b], Num c) => a -> c
22:30:24 <jsnx> Cale: just say *every* pattern has it
22:30:38 <Cale> Because it introduces lots of typeclass constraints.
22:31:08 <jsnx> Cale: why is that bad?
22:31:39 <jsnx> Cale: (i am a n00b, by the way)
22:32:02 <Cale> Well, apart from the expense, it will probably make it necessary to resolve ambiguities by hand a whole lot.
22:32:25 <Cale> Note that typeclass constraints are actually extra parameters which have to be passed to the function.
22:32:36 <Cale> (at least in the current implementation)
22:32:43 <jsnx> Cale: hmmmm
22:32:52 <jsnx> Cale: okay, so starting from scratch...
22:33:08 <jsnx> what if we just had some sort of coercion convention?
22:33:19 <Cale> But more than that, you end up with these ridiculously general functions which in order to apply them you'll have to state the type you want them to have half the time.
22:33:20 <wy> How much less code is used in your example after you used view patterns?
22:33:50 <Cale> huh?
22:34:00 <jsnx> Cale: well, that's what would happen if an engineer put (-> ) in every pattern, right?
22:34:01 <Cale> jsnx: That'll never happen. We like type errors.
22:34:31 <jsnx> Cale: if this language ever leaves the white room, it will happen
22:34:31 <Cale> Implicit coercion is bad.
22:34:39 <jsnx> Cale: yes, i agree
22:34:42 <wy> Cale: I mean the code can be done with normal syntax, and the change is too small
22:34:55 <Cale> What's too small?
22:35:05 <jsnx> Cale: the (-> ) will be in DailyWTF and all that
22:35:37 <wy> With view patterns, you put your patterns in the front, without it, you put it behind. That's the only difference?
22:35:50 <Cale> jsnx: Meh, I couldn't care less if Haskell actually becomes popular in the real world, so long as the community stays large enough for it to be practical for my own use.
22:36:11 <Cale> (and it's already much larger than necessary for me :)
22:36:31 <wy> I hope the large companies never interested in haskell
22:36:38 <jsnx> Cale: yeah, but you should *fear* it becoming popular
22:36:48 <Cale> jsnx: Yes, avoid success at all costs.
22:36:51 <bos> wy: the significance of views is that they let you hide your type's implementation
22:36:51 <lambdabot> bos: You have 1 new message. '/msg lambdabot @messages' to read it.
22:36:51 <wy> jsnx: true. That'll ruit haskell
22:36:57 <wy> ruin
22:37:06 <Cale> Of course, if it ever becomes too popular, everyone important will just move to a new language.
22:37:13 <Cale> So it won't be a big deal.
22:37:15 <jsnx> Cale: lolz
22:37:25 <wy> bos: I like views, as described in Wadler's paper, but I don't like the view patterns implemented in ghc
22:37:34 <dibblego> if it ever becomes popular, then this implies that a significantly better language exists
22:37:41 <jsnx> it's like a hip neighborhood or something, all the yuppies move in...and the musicians move out
22:37:50 * Tac-Tics contemplates Haskell for Dummies. "You'll be Mastering Monads in Minutes!"
22:38:09 <jsnx> lolz
22:38:41 <Cale> jsnx: Gentrification is petrification. Once the language starts getting used by lots of people, you can't just change it on them.
22:38:55 <Cale> Of course, you *can* just change it on them, but this will generally piss them off.
22:38:57 <Tac-Tics> someone should come out with an interesting book on Haskell that isn't a textbook and costs under $50
22:39:44 <Cale> Nah, there should be more books on Haskell which are like 70 pages and $150.
22:39:46 <jsnx> Cale: well, you could just make a language so idealized and arcane that no one can ever implement it
22:40:01 <Tac-Tics> programming and technology books are mostly garbage... I need something to blow my $50 giftcard to B&N.com
22:40:04 <jsnx> (like C__)
22:40:07 <Cale> ...and completely incoherent to outsiders.
22:40:12 <jsnx> s/C__/C++/
22:40:19 <bos> Tac-Tics: just wait a few months
22:40:36 <jsnx> Tac-Tics: get math books
22:40:53 <bos> Tac-Tics: there should be two "practical haskell" books, perhaps even three, published in 2008
22:41:00 <Cale> Price varies proportionally to the number of theorems, not to the number of pages ;)
22:41:22 <Tac-Tics> jsnx: I was looking at the math books, but I can't find any that either I could see myself ever reading or that I don't own already
22:41:40 <Cale> Tac-Tics: What's your background?
22:41:40 <jsnx> Cale: this 'views' proposal is a lot more general than views, though
22:42:01 <Tac-Tics> Math books accumulate exponentially faster than I can read them
22:42:04 <jsnx> it's basically, pump the value through this function before matching
22:42:20 <jsnx> it's a function annotation, really
22:42:37 <Tac-Tics> Cale: I can handle some heavy kinds of math
22:43:06 <Tac-Tics> I made it to about page 200 in my Real Analysis book
22:43:39 <Cale> Tac-Tics: there's a small book by Roman on the Umbral Calculus which I can heartily recommend, just as a beautiful piece of mathematics.
22:43:53 <Cale> It's a Dover book too, fairly cheap if I recall.
22:43:57 <Tac-Tics> can you debrief me on what Umbral Calc is?
22:45:17 <Cale> Well, you know the usual binomial theorem of course:
22:45:35 <Cale> (x + y)^n = sum over k = 0 to n of (n;k) x^(n-k) y^k
22:46:16 <Tac-Tics> yeah
22:46:37 <Cale> Well, back in the 19th century, people started to notice that various sequences of polynomials other than {1,x,x^2,...} also satisfied identities which looked just like this.
22:47:00 <wy> Cale: suppose you didn't know that the data type is too slow for you, and you wrote thousands of patterns which don't have the form of view patterns, and then you decided that you want to change your implementation into something more efficient...
22:47:36 <Cale> For example, the Bernoulli polynomials, the Abel polynomials, Bessel polynomials, and many others which show up in physics and applied mathematics.
22:48:07 <jsnx> wy: sshhh, wait
22:48:09 <Cale> In the case of the Bernoulli polynomials, it's:
22:48:24 <Cale> B_n(x+y) = sum over k = 0 to n of (n;k) B_(n-k)(x) y^k
22:48:34 <Tac-Tics> Math is cool, but it's so daunting when you think about how much of the stuff there is just hanging around in the dark corners of your university
22:49:11 <Cale> In the case of the Bessel polynomials p_n, it's p_n(x+y) = sum over k = 0 to n of (n;k) p_k(x) p_(n-k)(y)
22:49:14 <Tac-Tics> does the book give backgrounds on these similar classes of objects?
22:49:20 <Cale> (and for many of the other sequences)
22:49:33 <jsnx> "These similarities allow one to construct umbral proofs, which, on the surface cannot be correct, but seem to work anyway."
22:49:37 <Cale> So the Umbral calculus is the secret to these "coincidences".
22:49:45 <jsnx> http://en.wikipedia.org/wiki/Umbral_calculus
22:49:46 <lambdabot> Title: Umbral calculus - Wikipedia, the free encyclopedia
22:50:08 <Cale> It's a nice piece of linear algebra which perfectly formalises what used to be considered abuses of notation.
22:50:25 <Tac-Tics> I see I see
22:50:29 <Tac-Tics> heh $14
22:50:34 <Cale> (this is post Gian-Carlo Rota)
22:50:48 <Tac-Tics> And it will take me to my mid 20s to finish it
22:51:00 <Cale> (who, by the way, was an absolutely brilliant mathematician who only recently died)
22:51:03 <Tac-Tics> A much better deal than the average programming book: $50 and I already know most of it
22:51:25 <Tac-Tics> Cale, you studied math as your major, right?
22:51:27 <Cale> If you have a strong linear algebra background, and a basic idea of calculus, you'll be okay.
22:51:32 <Cale> Yes, pure mathematics.
22:51:40 <Cale> (as opposed to applied)
22:51:44 <Tac-Tics> yeah
22:52:08 <Tac-Tics> I wanted to do pure mathematics as well nearing my junior year of college
22:52:19 <Tac-Tics> but I had to settle for a minor instead
22:54:24 <sk_> Cale, you still in grad school?
22:54:42 <Cale> The Umbral calculus is actually startling to me in that I don't really completely "get" the applications to mathematics, aside from the fact that it generates identities like crazy, which is usually sort of off-putting for me, but the theory itself here is so beautifully polished that I don't mind.
22:54:49 <Cale> sk_: I'm not yet in grad school.
22:55:06 <sk_> Cale: sounds like you're going for it =)
22:55:17 <Cale> Well, of course :)
22:55:29 <Cale> I wouldn't make it in the real world ;)
22:55:56 <sk_> lolz... grad school is real too
22:56:12 <Cale> ... sort of.
22:56:29 <Cale> :)
22:56:47 <sk_> in the real world there are always a lot of tedious stuff to be done
22:57:02 <Cale> I'm far too impractically minded for that.
22:57:05 <sk_> in fact, it's hard to make those things interesting most of the time
22:57:06 <Tac-Tics> I've been in the real world for about 7 months now, and already looking for an out
22:57:59 <sk_> me 1 year ++
22:59:52 <Tac-Tics> gift cards are evil, and bookstores are boring!
23:00:40 <Cale> Tac-Tics: I asked for fiction books this year. Got Dune and Cryptonomicon.
23:01:46 <Tac-Tics> I don't read much (read: any) fiction. I get jittery when I read novels and get a feeling like I could be spending my time doing something better
23:02:02 <Tac-Tics> like utterly fail at trying to read through math books =-)
23:02:07 <Cale> hehe
23:02:14 <Cale> I waste a lot of time as it is.
23:03:00 <Cale> "Waste", as if there's really something more important for me to do :)
23:03:55 <Cale> I don't find myself particularly motivated by money unfortunately.
23:04:03 <jsnx> Cale: maybe your just saving it :)
23:04:10 <jsnx> (time)
23:05:28 <Tac-Tics> Money, tonight, has netted me little more than a wasted night of looking through Barnes and Nobles selection of books.
23:06:54 <Cale> If you want something really twisted, get "The Age of Wire and String", by Ben Marcus :)
23:07:51 <Cale> http://www.webdelsol.com/marcus/acct.htm -- here's an excerpt ;)
23:07:52 <lambdabot> Title: Ben Marcus, Accountant, Vessel of Notice
23:08:37 <Cale> It's like a dream in that it doesn't necessarily make sense, but it evokes imagery and emotion nonetheless.
23:11:12 <Tac-Tics> http://tinyurl.com/2vddhh
23:11:26 <Tac-Tics> I've considered this book for a while
23:11:46 <Tac-Tics> I have a very nasty blind spot for statistics
23:11:56 <Tac-Tics> I don't "get" stats
23:12:23 <Tac-Tics> but this book looks "sufficiently technical" to keep my interests
23:12:32 <Cale> That actually looks like a rather nice intro to probability theory.
23:13:15 <Tac-Tics> they need to write math books formatted for C.S. majors
23:13:42 <Tac-Tics> The core concepts in mathematics isn't usually the barrier, it's the (abuse of) notation
23:14:09 <Cale> http://www.indiana.edu/~mathwz/PRbook.pdf -- here's a rather nice book on real analysis and, in particular, measure theory
23:14:23 <Tac-Tics> cool
23:14:31 <Cale> Any *real* mathematics book won't abuse notation too much.
23:14:46 <Tac-Tics> I haven't been to this channel for a while, I forgot how you guys throw around interesting pdfs
23:15:06 <Tac-Tics> it's just the complete lack of consistency that gets hard to read
23:15:10 <Cale> It's only the junk which they use to teach science and engineering students which has most of the abuses of notation.
23:15:23 <Tac-Tics> like Calculus X-D
23:15:24 <jsnx> like physics books
23:15:36 <jsnx> math methods for physicists and so forth
23:15:44 <Cale> If you want a *good* Calculus book, I highly recommend Spivak.
23:15:58 <Tac-Tics> Why can't they just teach students that a derivative is a higher-order function and that an indefinite integral is a multi-valued function?
23:15:58 <jsnx> it's like the proofs are mnemonics
23:16:15 <Cale> "Calculus", there's also "Calculus on Manifolds" which is quite good, but quite different.
23:16:55 <Tac-Tics> It makes me sick thinking back to Calc in high school: INT of 3x^2 dx = x ^3 + C.... wtf is "C" anyway?
23:17:01 <Cale> An indefinite integral is a multivalued function? :)
23:17:16 <Tac-Tics> yeah
23:17:41 <Cale> It's an arbitrary constant. The whole statement is contained in a universal quantifier which binds C.
23:18:26 <Cale> (and restricts it to the reals, of course)
23:18:41 <Tac-Tics> that's another way you can think of it
23:19:23 <Cale> For any C in R, x^3 is an antiderivative of 3x^2.
23:19:28 <Cale> er
23:19:33 <Cale> For any C in R, x^3 + C is an antiderivative of 3x^2.
23:19:38 <Tac-Tics> yeah, the two are equivalent
23:20:09 <Tac-Tics> INT of 3x^2 = {x^3 + c | c `elem` R}
23:20:23 <Cale> ah, so multivalued in that sense.
23:20:48 <Tac-Tics> it's a higher order, nondeterministic function
23:20:52 <Cale> Of course, even speaking of 3x^2 as a function is an abuse to begin with.
23:21:06 <Tac-Tics> much easier to explain to bored high school students than the magic C... right? =-)
23:21:16 <Tac-Tics> yeah
23:21:16 <Cale> I prefer just to leave it out.
23:21:39 <Cale> At least, when it's unimportant, which is usually.
23:21:41 <Tac-Tics> INT Lx.3x^2 = {Lx.x^3 + c | c `elem` R}
23:21:41 <Tac-Tics> hehe
23:21:58 <Cale> Use the standard notation for a mapping, rather than lambdas :)
23:22:15 <Tac-Tics> which notation would that be? x -> x^3?
23:22:22 <Cale> x |--> x^3
23:22:29 <Cale> ‚Ü¶
23:22:32 <Tac-Tics> ah
23:23:11 <Cale> Category theory has made that one popular.
23:23:12 <Tac-Tics> The arrow is the politically correct term for lambda abstraction then?
23:23:34 <Cale> Yeah, the arrow with a little line at the tail of it like that.
23:23:59 <Tac-Tics> that's actually kind of cute notation
23:24:02 <Cale> It's usually used alongside the corresponding plain arrow indicating which sets are being mapped between.
23:24:02 <Tac-Tics> x -> x^2
23:24:10 <Tac-Tics> ah
23:24:13 <Cale> So you'll write something like:
23:24:18 <Cale> f : R --> R
23:24:25 <Cale>     x |-> x^2
23:24:59 <Cale> Usually mathematicians are *very* picky about domains and codomains.
23:25:08 <Tac-Tics> I've noticed
23:25:51 <Cale> I'd go so far as to say that you don't actually have a function unless you know both the domain and codomain.
23:25:57 <Tac-Tics> My texts may gloss over important things quickly, but never ever ever do they miss out on a "nonzero" or "nonempty"-style qualifier in their propositions
23:26:36 <Tac-Tics> Heh, what would a mathematician says to something like Haskell's const?
23:26:52 <Cale> Well, it's actually a natural transformation. ;)
23:27:14 <Cale> :t const
23:27:16 <lambdabot> forall a b. a -> b -> a
23:27:36 <Cale> (with two parameters)
23:27:51 <Tac-Tics> I will still never understand category theory
23:27:53 <Tac-Tics> or stats
23:28:20 <Tac-Tics> what's a good text intro to category theory?
23:28:23 <Cale> I suppose it's perfectly okay as a class function on the class of all sets, say.
23:28:32 <Tac-Tics> for human consumption?
23:29:12 <Cale> Well, there's MacLane's book, but it's maybe rough going for CS people...
23:29:59 <Cale> Eugenia Cheng has a decent intro. It's very brisk, but it doesn't have much in the way of prerequisites.
23:30:03 <Tac-Tics> heh, a book called "Naive Set Theory"
23:30:34 <jsnx> "Category Theory For Dummies -- Monads In Minutes!"
23:30:37 <Cale> http://www.math.uchicago.edu/~eugenia/winter06/ -- pdf linked from here
23:30:38 <lambdabot> Title: winter06
23:30:45 <Cale> Tac-Tics: by Halmos?
23:31:00 <Tac-Tics> yeah, just the name is funny
23:31:19 <Cale> Naive Set Theory by Halmos is really good. It's doubly funny once you actually examine the contents.
23:31:25 <Tac-Tics> a completely legitimate name, I'm sure, but not good advertising for your book
23:31:35 <Cale> The set theory he is presenting is not naive. :)
23:31:42 <Cale> (He's presenting ZFC.)
23:31:42 <jsnx> Cale: thanks for the link
23:32:12 <jsnx> Cale: the earlier link -- to the real analysis book -- seems to be everything i learned as a physics major
23:32:12 <oerjan> "naive set theory" is a technical term
23:32:44 <Cale> jsnx: If you learned all that as a physics major, I applaud your physics department for producing responsible physicists.
23:32:45 <jsnx> Cale: but probably more logically presented
23:32:59 <jsnx> Cale: well, everything touched on
23:33:06 <Cale> okay :)
23:33:13 <jsnx> Cale: of course i spent a lot of time being like, what the hell?
23:33:19 <Cale> jsnx: hehe
23:34:53 <jsnx> Cale: it's everything i *tried* to learn as a physics major
23:35:00 <jsnx> but then i left, for CS and C++
23:35:07 <Cale> The problem with teaching Category theory to CS people is that in order to understand the philosophical foundation for category theory, that is, exactly why we would be interested in a category in the first place, you kind of have to have an undergraduate degree in mathematics.
23:36:02 <jsnx> Cale: well, maybe we are interested because of all this Haskell stuff
23:36:03 <Cale> Of course, there are revisionist histories which can be written, but I'm not so sure a totally convincing one has been written for CS as of yet.
23:36:09 <Cale> Yes, of course :)
23:36:20 <Cale> There are good reasons for CS people to want to know category theory.
23:36:31 <jsnx> but now we have to back fill all of our ignorance, and it hurts our brains
23:36:38 <Cale> It's just hard to teach properly without all the examples.
23:36:51 <jsnx> Cale: aye, fair
23:37:00 <sk_> studying math hurts until i know haskell =)
23:37:48 <jsnx> "a natural transformation is an isomorphism to and isomporphism to an equivalence relation"
23:37:52 <jsnx> or something like that
23:38:18 <jsnx> and i barely remember, you know
23:38:34 <jsnx> because, i don't know what an equivalence relation is
23:38:40 <Tac-Tics> What is the role of Category Theory in mathematics?
23:38:46 <Cale> A natural transformation is essentially a map between two parallel functors.
23:39:07 <Tac-Tics> From what I can tell, it seems like a more powerful variant of Set Theory with harder vocab
23:39:09 <Cale> Tac-Tics: it's a general framework into which most everything else loosely fits.
23:39:48 <jsnx> *Sargun* is reborn
23:39:51 <jsnx> oops
23:39:56 <Cale> Some people like to think that it could replace set theory, and while, yes, you probably can make that work, it's unlikely to *really* happen like that. We still like sets for building many things.
23:40:26 <Tac-Tics> Us computer science majors like to live in a world with only Finite Set Theory
23:40:30 <Cale> However, Category theory provides a brilliant birds-eye view of the things that we've built.
23:40:39 <Tac-Tics> and even then, we like to keep our sets polynomially big at best
23:40:50 <Cale> Not true, you use countably infinite and uncountable sets all the time.
23:41:12 <jsnx> like rows in a database table?
23:41:17 <Cale> "The set of all infinite boolean sequences"
23:41:30 <Cale> That's just the real numbers in disguise :)
23:41:48 <Tac-Tics> The set of all computations not bound by CTRL-C
23:42:12 <jsnx> Tac-Tics: even the ones bound by it
23:42:42 <Cale> Of course, the set of all *computable* infinite boolean sequences is another beast altogether.
23:42:42 <Tac-Tics> I messed that up a bit, but oh well
23:43:10 <jsnx> but CS people almost never deal with computable things directly
23:43:11 <Tac-Tics> I had nightmares for a few days after reading Chatin's Metamath
23:43:21 <jsnx> we just hope the compiler deals with them
23:44:15 <Tac-Tics> Randomness is just as eerie as uncomputability
23:45:36 <Cale> Well, things get funny.
23:45:51 <Cale> There are more real numbers than there are descriptions of real numbers.
23:46:48 <Cale> (only countably many descriptions)
23:46:50 <Tac-Tics> yeah
23:46:56 <jsnx> Cale: why?
23:47:18 <Tac-Tics> A description is just another word for an encoding
23:47:33 <Tac-Tics> If you can type a description and save it as a txt file, you can encode it as a series of bytes
23:47:38 <Tac-Tics> and that series is just an integer in mathland
23:47:49 <Cale> Well, I'm using it to mean a statement which is provably satisfied by exactly one real number.
23:48:35 <jsnx> so these statements are countably infinite, whereas the reals are uncountably infinite
23:48:40 <Cale> and of course, there are only finitely many symbols in your alphabet, and proofs are finite.
23:48:47 <Cale> yeah
23:49:02 <Cale> (proofs are individually finitely many symbols)
23:50:05 <Cale> So it's rather funny. There are more reals which cannot be specifically discussed than there are those which can.
23:50:36 <Tac-Tics> The example I liked was that if you randomly chose bits at random and concatenated them to form a floating point number, the probability that you choose any particular real number is 0
23:50:42 <Tac-Tics> I really need to buy this probability book
23:51:11 <Cale> I'm not sure it's a great idea to say floating point there :)
23:51:49 <Cale> But maybe a number in the interval [0,1] in base 2
23:51:52 <Tac-Tics> Sorry, again I didn't use the P.C. term
23:52:14 <Cale> Floating point usually implies finite precision.
23:52:17 <jsnx> yeah, we are in #maskell!
23:52:20 <Tac-Tics> I said the point floats, but I didn't say it could only float so far!
23:52:27 <Cale> hehe
23:53:45 <Cale> Tac-Tics: well, just consider the probability of choosing a particular n-bit number with n random bits
23:53:54 <Cale> It's 1/2^n, right?
23:54:00 <Tac-Tics> yeah
23:54:08 <Cale> The limit as n -> infinity of 1/2^n is 0
23:54:16 <Tac-Tics> oh, I understand why
23:54:17 <Tac-Tics> it's just
23:54:19 <Tac-Tics> 0
23:54:43 <Cale> This happens quite often with infinite probability spaces.
23:54:53 <Cale> (the measure of single points is 0)
23:55:11 <Tac-Tics> I got about a page into measures in my book
23:55:25 <Tac-Tics> it didn't seem too terrible
23:55:39 <Cale> It's the *intervals* (and other sets) which is where everything happens.
23:55:47 <jsnx> i should go read some math books now, instead of fooling around on IRC
23:56:02 <jsnx> i've got the next ten years all mapped out now
23:56:08 <Cale> hehehe
23:56:23 <Tac-Tics> I'd go to bed, but once I do, I submit myself to the torture of PHP in the morning
23:56:24 <jsnx> Cale: so what is a natural transformation again?
23:56:34 <Cale> jsnx: Well, you know what a functor is?
23:56:51 <jsnx> Cale: an isomorphism between equivalence relations?
23:56:51 <Cale> If you have two parallel functors: F,G: C -> D
23:56:55 <Cale> nope
23:56:58 <jsnx> damn
23:57:07 <jsnx> so, what is a functor?
23:57:11 <Cale> Okay, do you know what a category is?
23:57:15 <jsnx> no
23:57:18 <Tac-Tics> heh
23:57:19 <Cale> all right
23:57:29 <jsnx> maybe i should come back later?
23:57:48 <Cale> So a category is a collection of "objects", and for each pair of objects, a set of "arrows"
23:57:52 <Tac-Tics> Someone needs to write the book "What the Fuck is Category Theory?"
23:57:58 <Cale> together with some extra properties:
23:58:05 <jsnx> Tac-Tics: he's writing it now
23:58:58 <Cale> Arrows which "line up" can be composed:  If A,B,C are objects, and f is an arrow A -> B, and g is an arrow B -> C, then g . f is an arrow A -> C
23:59:20 <Cale> (the intuition here is of course sets and functions, but there are other categories)
23:59:29 <jsnx> syck
23:59:53 <Cale> Composition is associative whenever the composites make sense: h . (g . f) = (h . g) . f
