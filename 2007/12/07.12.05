00:00:01 <patperry> 	arising from is bound by the instance declaration at /Users/patrick/Programming/Haskell/Copy.hs:47:0
00:00:03 <patperry> 	at /Users/patrick/Programming/Haskell/Copy.hs:47:0
00:00:05 <patperry>     When trying to generalise the type inferred for `copy'
00:00:07 <patperry>       Signature type:     forall (ma :: * -> *) (a :: * -> *).
00:00:09 <patperry> 			  (MutableValue ma a) =>
00:00:11 <patperry> 			  forall e. a e -> IO (ma e)
00:00:13 <patperry>       Type to generalise: forall e. a e -> IO (ma e)
00:01:10 <Lemmih> patperry: We have hpaste for that.
00:02:11 <patperry> sorry, I'm new to irc
00:02:35 <glguy> fail
00:03:18 <glguy> still paste it, it will be easier to read
00:04:02 <hpaste>  patperry pasted "ghc error" at http://hpaste.org/4281
00:04:13 * glguy grumbles about alex depending on itself
00:04:37 <atp> hey dons, did you write this Curses.hsc i found lying around?
00:05:01 <atp> http://www.cse.unsw.edu.au/~dons/code/hmp3/Curses.hsc
00:05:45 <atp> hm, looks like it's part of a bigger program...
00:06:08 <kfish> it's part of hmp3, a curses-based mp3 player
00:06:11 <mgsloan> http://www.cse.unsw.edu.au/~dons/hmp3.html
00:06:12 <lambdabot> Title: hmp3 - curses/ncurses mp3 player
00:06:17 <patperry> I don't really understantd what "-fallow-undecidable-instances" does or why it is necessary.  Anyone have any pointers?
00:06:32 <atp> kfish: hm, yeah, i see that now.  do you know if dons wrote it?
00:06:37 <kfish> atp, yes he did
00:06:47 <atp> yeah ,looks like it, hehe
00:06:55 <atp> i see the copyright now
00:07:19 <atp> he writes nice clean code
00:07:23 <atp> very legible, i like
00:08:22 <kfish> patperry, it allows general recursion at the type level
00:08:24 <atp> i guess i should have looked at the copyright before asking anyway
00:08:59 <kfish> patperry, ie. it allows you to send the compiler into an infinite loop, which is why it's not enabled by default
00:09:20 <kfish> patperry, but, for the same reason, it lets you do some fun type-level programming
00:09:55 <patperry> so why do i need it in the code at http://hpaste.org/4280 ?
00:11:56 <sjanssen> patperry: http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#instance-rules your code fails one of the Paterson conditions
00:11:57 <lambdabot> Title: 8.6. Class and instances declarations, http://tinyurl.com/245leb
00:12:44 <glguy> anyone know where to get a binary alex for os x ppc for bootstraping?
00:13:34 <sjanssen> glguy: the alex distribution doesn't come with the necessary post-processed source?
00:13:49 <patperry> sjanssen: thanks for the pointer.  looks like I've got some reading to do
00:14:30 <glguy> sjanssen: I'll try the package, that was probably my mistake
00:15:02 <sjanssen> glguy: you've got GHC already, right?
00:15:08 <glguy> yeah
00:15:11 <glguy> (binary install)
00:15:20 <glguy> trying to get haddock installed
00:17:05 <glguy> I'm on a PPC mac and Leopard :) so GHC + macports = fail
00:17:10 <glguy> so I have to do all this by hand
00:17:12 <glguy> is hassle
00:22:57 <glguy> @users
00:22:57 <lambdabot> Maximum users seen in #haskell: 420, currently: 380 (90.5%), active: 11 (2.9%)
00:25:17 <atp> a lot of lurkers in this channel, eh
00:25:46 <allbery_b> lots f people stay online even when asleep (parked sessions)
00:26:01 * allbery_b should technically be one of those, but slept most of the day instead
00:26:04 <allbery_b> @time
00:26:05 <lambdabot> Local time for allbery_b is Wed Dec  5 03:26:04
00:26:43 <mwc> indeed, I'm awake for the next 13 hours
00:26:50 <mwc> at which point I'll solidly sleep for another 13 hours
00:27:54 <davidL> I think tomorrow will be a snow day
00:28:19 <mwc> that would be nice
00:28:28 <mwc> I could do with another day of studying
00:29:21 <mwc> took longer to prepare my final presentaiton for a grad course, left me with today and tomorrow AM to store every theorem from metric to banch spaces in my brain
00:31:12 <davidL> I'm in highschool so I don't get to do cool stuff like that. Instead, we get to learn about integrals...and the civil war. :-(
00:31:31 <faxathisia> maybe you should quit highschool
00:31:40 <davidL> I should
00:31:43 <faxathisia> I wish I had
00:31:53 <mwc> become a grad student in math
00:32:04 <mwc> you too can look forward to marking freshman calc finals
00:32:08 <davidL> people always tell me I need to finish highschool to do that
00:32:20 <mwc> yeah, and having an undergrad helps too
00:32:28 <hpaste>  bos pasted "search puzzle" at http://hpaste.org/4282
00:33:03 <faxathisia> > sequence [[1,2,3],[66,88]]
00:33:04 <bos> i'm trying to think of a better way to solve the puzzle i just posted than brute-forcing all 34 million combinations
00:33:05 <lambdabot>  [[1,66],[1,88],[2,66],[2,88],[3,66],[3,88]]
00:33:26 <faxathisia> bos: What's wrong with generate and test?
00:33:29 <glguy> bos: puzzle link?
00:33:53 <bos> glguy: see the hpaste
00:34:15 <glguy> bos: that is, "puzzle solution" ;) but ok, fine, I'll refer to that exclusively
00:34:15 <faxathisia> there is no link in the hpaste
00:34:23 <bos> faxathisia: it's slow?
00:34:31 <faxathisia> bos: Decide, is it or not
00:35:00 <glguy> :-/
00:35:04 <bos> faxathisia: yes, brute-forcing it is slow, but i can't think of something smarter
00:35:44 <bos> it doesn't look amenable to dynamic programming, at least to my eyes
00:35:46 <davidL> > last [1..34000000]
00:35:48 <lambdabot>  34000000
00:35:52 <glguy> bos, you could avoid reversing the list by summing every other element along the way and then multiplying the one you end on by 3
00:36:17 <glguy> bos: dynamic programming wouldn't buy you anything, you are already doing it in one pass
00:36:40 <bos> glguy: sure, but checkDigit isn't the bottleneck, that's just the test to see whether the answer is correct
00:37:00 <glguy> Where does the "data" come from?
00:37:21 <glguy> OH
00:37:23 * glguy rereads
00:37:37 <bos> it's guesses at the digits of a barcode
00:37:39 <glguy> its one element from each
00:37:43 <glguy> *check*
00:37:44 <davidL> ddvlad: ce faci :)
00:38:13 <oerjan> bos: the multiplying by 3 or 1 doesn't need to be repeated, i think
00:38:54 <bos> oerjan: i'm sure, but the performance of checkDigit isn't important to this
00:38:57 <oerjan> it is always the same for a given sublist element
00:39:10 <oerjan> bos: it is however important to simplify the problem
00:39:24 <glguy> so you could track 10 subsets, one for each check digit
00:39:50 <glguy> for each new sublist, try adding it to each of the sublists to see what new check digits become available
00:40:05 <glguy> since you don't need to know two ways to get to the same place
00:40:15 <glguy> then when you get to the end, choose the list a key '9'
00:40:18 <glguy> at*
00:40:27 <oerjan> sum products `mod` 10 == 1, i take
00:40:45 <glguy> goal = 9 from the comment i believe
00:40:50 <glguy> -- such that checkDigit on the resulting list returns 9?
00:40:58 <oerjan> no, there is a 10 -
00:41:00 <bos> right
00:41:12 <glguy> bos, so I think you can do this in one pass
00:41:19 * glguy sets out ot write
00:41:49 <oerjan> i think you can modify it to a problem where you just pick elements that sum to 1 mod 10
00:42:36 <oerjan> and everything else is precomputed
00:44:14 <oerjan> bos: one thing you are not clear about is exactly what the important order is on the resulting _sequence_, you only say that some digits are better in certain positions
00:44:31 <oerjan> but not how to weigh choices from _different_ positions
00:45:10 <oerjan> for certain choices, i don't think this is a brute force problem at all, if done cleverly.
00:45:21 <glguy> like I said, its a one pass problem
00:46:01 <bos> oerjan: the ordering of the elements in the input sublist is what's important. in reality, each element has associated with it a score, and the overall goal is to find the result list with the lowest overall score
00:46:25 <oerjan> ok.  here's the deal:
00:46:54 * bos is not clever past midnight
00:47:36 <oerjan> write a function to find the best solution for _each_ possible product sum
00:48:08 <oerjan> not just 9
00:48:24 <oerjan> you can do that by recursing on the tail
00:51:32 <oerjan> i.e. if you know all the best solutions for [[6,8,2],[7,8,3],[7,3,8]] then you can quickly calculate them for [[4,5,2],[6,8,2],[7,8,3],[7,3,8]]
00:52:01 <bos> right
00:54:13 <oerjan> of course for short lists it is likely that some digit sums are impossible, but that's just a minor problem
00:55:09 <bos> ok, i'm going to go to bed and think about this in the morning, when i have some brain cells :-) thanks for the input
00:55:34 <oerjan> good night :)
00:57:16 <hpaste>  glguy annotated "search puzzle" with "preliminary untested solution" at http://hpaste.org/4282#a1
01:00:18 <glguy> [1,8,0,1,3,2,1,1,4,6,7,7]
01:00:20 <glguy> :)
01:01:25 <dmwit> map head input -- ?
01:02:12 <glguy> apparently
01:02:18 <glguy> your algorithm might be shorter ;)
01:02:22 <glguy> but mine works on other data
01:02:28 <dmwit> heh
01:02:36 <oerjan> not the best test case
01:03:07 <hpaste>  glguy annotated "search puzzle" with "revision (sloppy but returns complete result)" at http://hpaste.org/4282#a2
01:06:39 <atp> man comic sans seriously needs to die
01:07:32 <Korollary> I like Comic Sans
01:09:01 <Mitar> http://bancomicsans.com/home.html
01:09:02 <lambdabot> Title: ban comic sans :: Putting the Sans in Comic Sans
01:12:35 <atp> comic sans *might* be ok if you're writing a comic
01:12:53 <Korollary> That's a bit pedantic
01:13:00 <atp> if you use it anywhere else, you deserve to be ritually disemboweled by a pack of wild hyenas wielding sporks
01:13:44 <Korollary> I hope this doesn't affect Middle East peace process.
01:14:04 <davidL> lol
01:14:23 <oerjan> of course not.  i doubt that either hebrew or arabic use comic sans.
01:15:21 <Taejo> oerjan, I'm sure I could do a comic hebrew
01:15:28 <Taejo> arabic might be a bit tricky
01:15:48 <atp> for the love of god no
01:15:53 <atp> that's all we need
01:16:00 <atp> intl comic sans...
01:16:14 <Taejo> I wouldn't - it would be horrible - but I'm sure I could
01:16:39 <atp> there's a chinese font that's very like comic sans, but so far i haven't been exposed to a webpage typeset entirely in that font
01:16:42 <Korollary> What do arabic comics use?
01:16:57 <atp> they seem more reasonable than some annoying web authors
01:17:59 <Taejo> atp, Ubuntu's Thai font pack has a font called Purisa, which is kinda Comic-Sans-like
01:18:29 <lament> what's so bad about comic sans?
01:19:44 <Taejo> a) it's used for serious text, far from it's intended (and appropriate) use
01:20:01 <lament> that's not the fault of the typeface
01:20:04 <Korollary> It's just the bourgoise that doesn't like the common man's comic sans.
01:20:22 <Taejo> b) it's a bad approximation to what it's supposed to be: informal handwriting
01:20:24 <Mitar> Taejo: you are a typeset designer?
01:20:32 <Taejo> Mitar: amateur
01:20:39 <oerjan> Korollary: so it's really short for communist sans? :)
01:21:00 <lament> Taejo: people like it...
01:21:09 <Korollary> People like it. It doesn't matter how bad it is. Most text isn't even serious.
01:21:26 <Korollary> Ok, it'd look bad in obituaries.
01:21:44 <lament> it'd look bad with any remotely serious text
01:21:57 <therp> comic sans is a good predicate to test whether you want to read a text or not.
01:22:00 <Taejo> "No unathourized persons beyond this point" signs look pretty silly
01:22:03 <lament> but that's not a fault, it's doing what it's designed for
01:22:25 <lament> it was originally intended to be for microsoft bob
01:22:40 <Taejo> well, that's a good hint that it's awful
01:22:46 <lament> i like microsoft bob
01:22:49 <lament> <3
01:23:17 <Taejo> the problem is more with idiotic use than with the face itself
01:23:20 <therp> Also most papers that are obviously typeset with MS Word went straight into trash. I like bad typography for judging the content :)
01:23:24 <lament> regardless of your feelings about microsoft bob, the original intended usage was "speech bubbles for cartoonish characters like clippy"
01:23:38 <Taejo> lament: and that's fine
01:23:43 <lament> where it's clearly the most appropriate common font
01:24:50 <Taejo> lament: http://pointawayfromface.com/wp-content/uploads/wcg.jpg
01:25:16 <lament> that doesn't look so bad
01:25:22 <lament> apart from all being in one font
01:25:37 <lament> but for the actual text ("No doubt most people..."), seems fine
01:25:53 <allbery_b> my alarm clock is all comic sans or equivalent.
01:26:00 <lament> mind you, i'm not a designer, this is just my purely subjective and untrained opinion
01:28:40 <Sizur> can i use unicode chars as identifiers or operators?
01:29:16 <allbery_b> supposed to work since 6.6.1, IIRC
01:29:52 <allbery_b> (ghci may have problems in 6.6.1 though; I don't recall)
01:30:23 <Sizur> i have Invalid type signature where i use (Π)
01:30:38 <Sizur> 6.8.1
01:31:31 <Sizur> (Π) :: a -> b
01:32:26 <Taejo> Sizur: isn't that a capital letter?
01:32:44 <allbery_b> capital and alpha, so probably not a valid operator
01:33:05 <Sizur> ok, so haskell knows what type the unichar is
01:33:15 <skew> Sizur: I know that sort of thing works in Agda
01:34:53 <TSC> Unicode works ok in ghc, but it doesn't seem to work in ghci
01:34:59 <skew> Π seems to work as a constructor name
01:35:04 <Sizur> yes! it works, all i had to do is use a symbol ∏ instead of greek letter
01:35:29 <Sizur> for an operator
01:35:38 <Sizur> great! :D
01:35:39 <allbery_b> it needs to, since it has to distinguish between operator-identifiers and word-identifiers, and case for types
01:38:00 <allbery_b> interestingly, it's not working for me (ghc6.9.20071125, PPC); the error message suggests it somehow thinks it's in RTL
01:38:50 <allbery_b> "Illegal signature in pattern: (Num a) => a -> a # n" for "aΠ: (Num a) => a -> a"
01:39:05 <allbery_b> whoops
01:39:24 <allbery_b> "Illegal signature in pattern: (Num a) => a -> a a# n" for "aΠ: (Num a) => a -> a"
01:42:09 <mwc> TSC, does your terminal support unicode?
01:42:14 <mwc> that might be the problem
01:43:09 <allbery_b> hm, but π as the identifier works.
01:43:13 <Lemmih> mwc: The problem is with GHCi.
01:44:07 <mwc> ah, wondered if the terminal was just mangling the conversion somehow
01:45:11 <mux> http://www.cs.chalmers.se/~ulfn/darcs/Agda2/examples/ISWIM.agda
01:45:28 <allbery_b> no it doesn't after all.  weird
01:45:35 <mux> this is neat! it really looks just the same as you would write denotational semantics in a paper, with double brackets and all
01:47:17 <lament> looks kinda silly in the context of the stark ascii of the rest of it
01:47:24 <lament> especially haskell's -> sign
01:48:04 <lament> and ==, and \, and {-#  :)
01:48:19 <Taejo> @pl factorial n = foldr (*) 1 [2..n]
01:48:19 <lambdabot> factorial = foldr (*) 1 . enumFromTo 2
01:48:46 <lament> would be nice to have non-ascii replacements for those
01:50:46 <skew> lament: I think that's the sort of thing that's very easy to hack up, if you don't mind recompiling
01:50:59 <skew> lament: though I've only played around with the grammar myself
01:52:16 <Taejo> @let choose n r = (foldr1 (*) [r..n]) `div` (factorial $ n-r)
01:52:23 <lambdabot> <local>:6:40: Not in scope: `factorial'
01:52:37 <Taejo> @let factorial = foldr (*) 1 . enumFromTo 2
01:52:40 <lambdabot> Defined.
01:52:42 <Taejo> @let choose n r = (foldr1 (*) [r..n]) `div` (factorial $ n-r)
01:52:42 <lambdabot> Defined.
01:52:49 <Taejo> > 23 `choose` 10
01:52:59 <lambdabot>  11440660
01:54:27 <glguy> hmm, that's wrong
01:54:32 <skew> lament: http://darcs.haskell.org/ghc/compiler/parser/Lexer.x
01:54:37 <glguy> should be 1144066
01:54:42 <Taejo> glguy: I know
01:54:59 <Taejo> > factorial 5
01:55:08 <lambdabot>  120
01:55:25 <glguy> > let choose n r = product [n,n-r..r+1] `div` product [1..r] in 23 `choose` 10
01:55:27 <lambdabot>  0
01:55:31 <glguy> whoops :)
01:55:45 <glguy> > let choose n r = product [n,n-1..r+1] `div` product [1..r] in 23
01:55:46 <lambdabot>  23
01:56:04 <glguy> oh, you have to *use* the function
01:56:11 <Taejo> yep
01:56:14 <glguy> > let choose n r = product [n,n-r..r+1] `div` product [1..r] in 23 `choose` 10
01:56:14 <lambdabot>  0
01:56:22 <glguy> cut and paste is fail
01:56:31 <glguy> > let choose n r = product [n,n-1..r+1] `div` product [1..r] in 23 `choose` 10
01:56:31 <lambdabot>  1963217256
01:56:35 <glguy> oh well
01:57:00 <glguy> OH
01:57:06 <glguy> > let choose n r = product [n,n-1..n-r+1] `div` product [1..r] in 23 `choose` 10
01:57:06 <lambdabot>  1144066
01:57:09 <glguy> win
01:57:52 <Taejo> glguy: thanks
01:58:18 <glguy> fac n / (fac r * fac (n-r))   looks more like the "definition" though
01:58:31 <Taejo> @pl choose n r = product [n-r+1..n] `div` product [1..r
01:58:32 <lambdabot> (line 1, column 47):
01:58:32 <lambdabot> unexpected "." or "["
01:58:32 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
01:58:32 <glguy> but that isn't really the goal I imagine :)
01:58:37 <Taejo> @pl choose n r = product [n-r+1..n] `div` product [1..r]
01:58:38 <lambdabot> choose = (`ap` (product . enumFromTo 1)) . ((div . product) .) . (flip =<< (enumFromTo .) . flip flip 1 . ((+) .) . (-))
01:58:58 <glguy> In J, that function is just:   !
01:59:04 <glguy> but this version is good too ;)
01:59:04 <Taejo> glguy: that involves more calculation, doesn't it?
01:59:07 <glguy> yeah
01:59:26 <glguy> doing programming puzzles?
01:59:33 <Taejo> project euler
01:59:39 <glguy> :-D which #
01:59:50 <glguy> I just did one that uses that function
01:59:56 <Taejo> this is 53
02:00:05 <glguy> oh, I was doing a later one
02:00:05 <Taejo> I'm not doing them in order
02:00:35 <wli> > let n `choose` k | k == 0 = 1 | k == n = 1 | otherwise = let n' = n - 1 in (n' `choose` k) + (n' `choose` (k - 1)) in map (3 `choose`) [0 .. 3]
02:00:35 <lambdabot>  [1,3,3,1]
02:00:57 <wli> AIUI that's the definition.
02:01:01 <wli> I had:
02:01:07 <glguy> aiui?
02:01:14 <glguy> as i understand it
02:01:14 <glguy> ?
02:01:19 <skew> swiert: Hi, how's OTT?
02:01:53 <glguy> Taejo: I've got < 129 finished now (and then its unordered from there)
02:01:59 <wli> n `choose` k | k == 0 = 1 | k == n = 1 | 2 * k > n = n `choose` (n - k) | otherwise = (n * ((n - 1) `choose` (k - 1))) `div` k
02:02:02 <mux> anyone using Adga?  how am I supposed to compile / run a program?
02:02:14 <mux> agda -c doesn't seem to do anything, and agda -I is confusing me
02:02:17 <wli> Someone had a faster scheme based on Legendre symbols or some such.
02:02:40 <wli> (Basically factoring n!)
02:03:06 <glguy> Hmm, why the case for 2 * k > n ?
02:03:07 <Taejo> glguy: I've done 23
02:03:22 * mux is at 75 problems done
02:03:44 <glguy> all I have left are the ones I didn't want to do :)
02:03:49 <wli> glguy: Random speedup.
02:03:51 <glguy> so it is slower going
02:04:33 <glguy> wli: oh, right
02:04:40 <wli> I got bored with them at some point. I didn't have the fortitude to work through ones that gave me trouble.
02:04:41 <glguy> since the series repeats halfway through
02:05:38 <wli> glguy: Also the depth of the recursion is k.
02:07:10 * glguy now knows how many of the values of choose n r | n < 10^9 are not divisible by 7 :)
02:07:21 <glguy> well, for any prime, and for any n limit
02:07:40 <wli> I don't.
02:07:54 <glguy> with this knowledge in hand I intend to get rich
02:09:03 <mux> blah, now I tried agda --compile and the haskell file it generates doesn't build
02:09:07 <wli> I never figured out that problem.
02:11:32 <Taejo> does anybody else pronounce the .hs suffix "aitches" (analogously to xs)
02:12:40 <mwc> Taejo, in that "aitch ess" approaches aitches as the pause between them contracts to zero, yep
02:13:34 <Taejo> mwc: for me it's more than that: in a haskell context I pronounce <letter>s and <letter plural>
02:18:26 <Taejo> is there a more elegant definition for the continued fraction for e than 2:(foldr1 (++) [[1, k, 1] | k <- [2,4..]])
02:19:14 <wli> 2 : concat [[1, k, 1] | k <- [2, 4]]
02:19:50 <mux> you mean 2,4..
02:19:55 <Taejo> wli, thank you, I forgot concat
02:24:52 <quicksilver> isn't that 2 : [x | k <- [2,4..], x <- [1,k,1]]
02:24:52 <quicksilver> ?
02:25:02 <quicksilver> if you're using list comps, get the list comp to do the concat, too
02:25:07 <wli> quicksilver: nice
02:26:22 <Taejo> > 2 : [x | k <- [2,4..], x <- [1,k,1]]
02:26:24 <lambdabot>  [2,1,2,1,1,4,1,1,6,1,1,8,1,1,10,1,1,12,1,1,14,1,1,16,1,1,18,1,1,20,1,1,22,1,...
02:26:33 <Taejo> nice
02:29:25 <wli> I'm so burned out I can't eke out a BCD arithmetic module.
02:31:00 <Taejo> wli: that's pretty bad
02:32:28 <viklund> @pl \l -> rem x l == 0
02:32:28 <lambdabot> (0 ==) . rem x
02:32:41 <Svrog> 2 : (fix (\f x -> 1 : x : 1 : (f (x + 2))) 2)
02:35:49 <glguy> > 2 : concat (intersperse [1,1] [2,4..])
02:35:50 <lambdabot>   add an instance declaration for (Num [t])
02:35:50 <lambdabot>     In the expression: 4
02:36:02 <Taejo> @type intersperse
02:36:03 <lambdabot> forall a. a -> [a] -> [a]
02:36:04 <waern> dcoutts: what needs to be done to the make project next?
02:36:13 <glguy> oh yeah
02:36:18 <glguy> > 2 : concat (intersperse [1,1] $ map return [2,4..])
02:36:19 <lambdabot>  [2,2,1,1,4,1,1,6,1,1,8,1,1,10,1,1,12,1,1,14,1,1,16,1,1,18,1,1,20,1,1,22,1,1,...
02:36:22 <glguy> not as pretty now
02:36:51 <dcoutts> waern: I'm glad you asked :-)
02:37:08 <glguy> > 2 : concat (transpose [2,4..] [1,1..] [1,1..])
02:37:09 <lambdabot>  Couldn't match expected type `[t1] -> [t2] -> [[t]]'
02:37:26 <glguy> > 2 : concat (transpose [[2,4..],[1,1..],[1,1..]])
02:37:27 <lambdabot>  [2,2,1,1,4,1,1,6,1,1,8,1,1,10,1,1,12,1,1,14,1,1,16,1,1,18,1,1,20,1,1,22,1,1,...
02:37:29 <waern> dcoutts: hihi :)
02:37:30 * glguy is wearing down
02:37:33 <dcoutts> waern: hmm, I think the main thing is dynamic deps design and testing
02:37:56 <waern> dcoutts: aha
02:38:25 <dcoutts> waern: I'm not happy with the current design of dynamic deps, it's not got the right modularity I think
02:38:37 <dcoutts> waern: as in it'd make writing rules difficult
02:40:03 <waern> dcoutts: ok
02:41:03 <dcoutts> waern: will you be around this evening?
02:41:14 <waern> dcoutts: yup
02:41:15 <dcoutts> waern: I've also been hacking on cabal-install this week
02:41:33 <dcoutts> waern: ok, cool
02:44:54 <swiert> skew: Hi! Long time, no chat.
02:45:31 <swiert> skew: not much new on the OTT front atm... We had a paper at PLPV, and there's an actual implementation of the stuff slowly emerging in the next version of Epigram.
02:49:17 <skew> swiert: I've looked at the paper and the Agda code, but I'm still not entirely sure how it fits together.
02:49:43 <swiert> skew: Ok. The idea is actually super easy.
02:50:11 <swiert> skew: Usually people define equality in type theory inductively with a single "refl" constructor.
02:50:29 <swiert> skew: Then there's some debate about what axioms should be added (if any at all).
02:50:33 <skew> swiert: I have some specified ontological questions, I think I get the general idea
02:50:57 <swiert> skew: the one idea behind OTT is to define equality by induction over the types of your theory.
02:51:10 <swiert> skew: feel free to ask.
02:52:02 <skew> To begin with, it seems Prop is identified with a subset of the terms, with a simple syntactic mapping from the propositions into terms
02:52:12 <viklund> a perfomance question: I defined a strict version of sum, sum' with foldl'
02:52:17 <waern> swiert: hi, I think a module is missing from the IOSpec repository
02:52:45 <swiert> waern: yeah you mentioned that. Did you check out the version from darcs?
02:52:51 <viklund> and found that if the type for sum' was (Num a) => [a] -> a instead of  [Integer] -> Integer where a constant 2 seconds faster on two very long lists
02:53:02 <skew> The paper didn't make this explicit, but it seems that equality and coercion are defined in terms of existing constructs, but you have to do it semantically
02:53:04 <viklund> why that difference?
02:53:07 <waern> swiert: yup
02:53:51 <skew> they are defined by induction on the types, and you can only apply those reduction rules when things are sufficiently evaluated, so it's not just syntactic sugar like the earlier prop stuff
02:53:56 <quicksilver> viklund: which was faster?
02:54:04 <viklund> the general one with Num
02:54:09 <quicksilver> viklund: compiled or interpreted?
02:54:13 <viklund> compiled
02:54:16 <Taejo> viklund: because in the former, a is instantiated as Int, which is faster than Integer
02:54:36 <viklund> It's large numbers, so the return value is bigger that maxint
02:54:55 <Taejo> viklund: but Int + Int gives Int, even if it overflows
02:55:48 <viklund> yes, but the answer get incorrect. If I manually change the type to Int, the answer is -134.... (but it's wrong really fast;))
02:56:25 <quicksilver> well, that's it, then :)
02:56:27 <skew> swiert: I think that's right, but I was confused for a while because simple propositions seem to be pure sugar (a useful distinction later in proofs, but not a change to a logic), and equality at least reduces to the terms of the base type theory, so I was thinking [_=_] and [_=_> were supposed to be just syntactic sugar as well
02:56:27 <quicksilver> defaulting at work
02:57:12 <swiert> sorry phone.
02:57:33 <viklund> So of Num a inferred a into Int  the answer is negative, but when I run the program with Num, it's positive.
02:57:35 <skew> swiert: I just finished explaining one point anyay!
02:59:15 <viklund> so the optimization can't be that it turns Num into Int since that would break the program...
02:59:22 <viklund> I'm confused
02:59:51 <Taejo> viklund: the compiler doesn't know that Int is too big
02:59:56 <Taejo> I mean to small
03:00:14 <viklund> ok, but why do I get my bigNum answer?
03:00:49 <swiert> waern: ok. I just pushed a few patches I had lying about on my machine. It should compile now.
03:00:50 <viklund> when using Num but not when using Int.
03:00:56 <wli> > let ecf :: [Integer] = 2 : [x | k <- [2, 4 ..], x <- [1, k, 1]] ; evalcf (ns :: [Integer]) = snd $ mapAccumL (\((p', p''), (q', q'')) x -> let p = p'' + p'*x ; q = q'' + q' * x in (((p, p'), (q, q')), fromInteger p / fromInteger q)) ((1, 0), (0, 1)) ns :: [Rational] in map fromRational . take 30 $ evalcf ecf :: [Double]
03:00:56 <lambdabot> Unbalanced parentheses
03:00:59 <skew> swiert: another thing is switching out the definitional equality at the end of the paper, it seems like a big change for amount of argument that it doesn't spoil the other metatheory
03:01:29 <skew> swiert: but I suppose the eta-expasion part is probably completely convenional, and then just arguing about the stuck coercions is just right
03:01:58 <Taejo> viklund, are you saying it uses bignums if you give it the type Num *and* if you give it the Integer type, but Num is faster?
03:02:08 <viklund> Yes!
03:02:11 <swiert> skew: so conversion and coercion are just about definable. You need to assume refl - but that's ok because its propositional.
03:02:16 <waern> swiert: thanks!
03:02:22 <viklund> At least, that's the impression I get
03:02:32 <Taejo> viklund: sorry I misunderstood you... that seems very odd
03:02:35 <viklund> the result of the summing function is 27142867857145
03:02:44 <skew> swiert: definable in what sense, though? It seems like you need to know the types before you can unfold the definitions
03:02:47 <viklund> and when using Int it's -1325453575
03:02:53 <viklund> yes, very
03:02:58 <viklund> I can paste the code
03:03:04 <idnar> viklund: what list are you summing?
03:03:15 <skew> swiert: that is, they are actual extensions to the type theory rather than just syntactic preprocessing, right?
03:03:18 <OceanSpray> :t runErrorT
03:03:20 <lambdabot> forall e (m :: * -> *) a. ErrorT e m a -> m (Either e a)
03:03:24 <viklund> that's probably Ints
03:03:37 <idnar> that might make the difference
03:03:38 <swiert> skew: right. In the sense that you can build a universe, closed under Pi/W/Sigma with 0,1, and 2, in Intentional Type Theory and define coercion and coherence.
03:03:49 <hpaste>  viklund pasted "strange optimizations" at http://hpaste.org/4283
03:04:03 <swiert> skew: so you inherit most of the nice propertes from ITT for free.
03:04:10 <viklund> it's a generalized Project Euler prob 1.
03:04:42 <viklund> I'm also on ghc 6.6, I wonder what ghc 6.8 would do, haven't bothered compiling it yet.
03:04:55 <swiert> skew: what do you mean by "switching out the def. eq."?
03:05:09 * wli wonders if there's something nicer than the mapAccumL brewed up there.
03:05:26 <swiert> skew: the type directed quotation section?
03:05:55 <skew> swiert: yeah, it was described as an equivalence.
03:05:57 <quicksilver> viklund: have you tried plain "sum" ? you shouldn't need your own sum'
03:06:02 <quicksilver> viklund: there is supposed to rules for that
03:06:11 <viklund> sum overflowes...
03:06:31 <viklund> *overflows
03:06:42 <quicksilver> with ghc -O2 ?
03:06:44 <swiert> waern: thank you for haddock 2.
03:06:58 <viklund> haven't tried that...
03:07:08 <quicksilver> viklund: ah, unoptimised code isn't very interesting :)
03:07:22 <viklund> :p
03:07:22 <quicksilver> viklund: although, I still find your result surprising.
03:07:25 <swiert> skew: ah yes.
03:07:38 <viklund> yes, I thought it very strange
03:07:49 <skew> swiert: The first time or two I read it, it seemed like some totally ad-hoc postprocessing to remove coercions, but I see it's described as an upgrade to the definitional equality
03:07:56 <quicksilver> wli: the mapAccums are also mapM over State; it's a matter of taste which is nicer to look at I think.
03:09:02 <viklund> yep, works with -O2 and prelude sum
03:09:09 * quicksilver nods
03:09:25 <viklund> and that's faster than my sum'
03:09:44 <quicksilver> I think prelude sum is special-cased
03:09:48 <swiert> skew: exactly. it basically shows how to recover some of the things you lost from ITT.
03:10:10 <swiert> skew: although I must say - I'm not convinced I fully understand that section myself.
03:10:24 <viklund> you mean this: {-# SPECIALISE sum     :: [Integer] -> Integer #-}
03:11:18 <viklund> it's also tail-recursive in Data.List
03:12:24 <skew> swiert: I think what I don't understand is mostly how much this (fails to) interacts with things like proofs about your underlying ITT
03:12:35 <quicksilver> viklund: yes :)
03:12:38 <viklund> are tail-recursive functions stricter than foldls?
03:12:47 <Taejo> @where fromJust
03:12:47 <lambdabot> I know nothing about fromjust.
03:12:54 <Taejo> @index fromJust
03:12:54 <lambdabot> Data.Maybe
03:12:55 <quicksilver> viklund: I'm not really sure what 'stricter' means
03:12:56 <viklund> I've just discovered strictness...
03:13:14 <quicksilver> viklund: a function is either strict or not (in each particular argument)
03:13:36 <viklund> ok, let me rephrase. Are tailrecursive functions strict?
03:13:50 <Taejo> not necessarily
03:13:51 <mwc> viklund, in general no
03:14:22 <quicksilver> tail recursion is an important optimisation for not building up a huge stack
03:14:25 <swiert> skew: ok. the reason a lot of the proofs about ITT carry through is quite subtle.
03:14:29 <mwc> consider map. map (_|_) [] is perfectly well defined
03:14:30 <quicksilver> but it doesn't always matter in lazy languages
03:14:34 <mwc> > map undefined []
03:14:36 <lambdabot>  []
03:14:55 <mwc> or sorry, that's not tail recursive
03:14:57 <mwc> replace with fold
03:15:19 <quicksilver> in general in a lazy language if your function is productive it doesn't matter if it's not tail recursive
03:15:37 <swiert> skew: IIUC, it's because you can write everything in ITT (assuming refl) you know that your theory hasn't suddenly lost canonicity.
03:15:40 <quicksilver> since its stack will unroll from the top as it builds up on the bottom
03:16:03 <skew> swiert: by "write in" you mean something like write an interpreter for?
03:16:21 <viklund> using foldl' instead of foldl is that another way of not building up a huge stack?
03:16:29 <mwc> @src foldl
03:16:29 <lambdabot> foldl f z xs = lgo z xs
03:16:29 <lambdabot>     where lgo z []     =  z
03:16:29 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
03:16:38 <swiert> skew: provided you can justify the assumptions you make - but we show it is safe to make consistent assumptions in Prop.
03:16:39 <mwc> you can see foldl itself is tail recursive
03:16:46 <viklund> ahh
03:16:47 <mwc> the only difference is taht accumulating parameter
03:16:54 <mwc> @src foldl'
03:16:54 <lambdabot> foldl' f a []     = a
03:16:54 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
03:17:05 <swiert> skew: so what the Agda code in the paper is doing is making a "shallow embedding" of OTT in ITT.
03:17:18 <mwc> see, that forces the evaluation of a' before going to the next step
03:17:31 <mwc> but that evaluation doesn't change strictness in f
03:17:41 <mwc> > foldl' undefined 3 []
03:17:42 <lambdabot>  3
03:17:49 <mwc> > foldl' undefined 3 [3]
03:17:51 <lambdabot>  Undefined
03:18:17 <swiert> skew: which basically amounts to "writing the AST of" + definiting equality.
03:18:19 <skew> swiert: Ah, I think I see how it goes. It's an easier way to get a consistency proof
03:18:35 <swiert> skew: oh and "implementing" coercion and coherence.
03:18:35 <mwc> see, the definition of strictness is that f (_|_) = (_|_)
03:18:54 <swiert> skew: exactly. it's just freeloading on the work other people have done on ITT.
03:19:09 <skew> swiert: For a deep embedding, to show consistency relative to ITT you'd have to explicitly write a function (eval_ITT -> eval_OTT)
03:19:26 <viklund> mwc: thx for the explanation but there you lost me ;)
03:19:59 <mwc> _|_ represents a computation that diverges, (doesn't terminate, explodes the universe, causes demons to fly out your nose, etc.)
03:20:13 <viklund> ahh
03:20:23 <mwc> so if a function is strict in a value, it means taht that value is always required, so that trying to compute it diverges
03:20:46 <mwc> on the other hand, if it only sometimes needs the value, the computation may not diverge
03:20:49 <quicksilver> viklund: foldl' doesn't stop you building up a huge call stack
03:20:52 <swiert> skew: a shallow embedding uses Agdas function space to model OTT's. A deep one would really build everything up from scratch.
03:21:03 <quicksilver> viklund: rather, it stops you building up huge thunk in the accumulator
03:21:17 <quicksilver> viklund: then, when you came to evaluate that thunk you would *then* blow your stack
03:21:21 <quicksilver> but that's the subtle bit
03:21:28 <quicksilver> you don't blow your stack on the foldl call itself
03:21:45 <mwc> Seq basically forces the evaluation of the "outermost" constructor
03:21:46 <skew> swiert: I think that's what I'm saying - strong normalization and canonicity is consistency for the logical part of the type theory
03:21:52 <quicksilver> you blow the stack when you try to evaluate the huge thunk which looks like (1+(2+(3+(4+(5+.......))))))
03:22:22 <viklund> thanks, I think I'll ponder this over lunch
03:22:30 <mwc> > let y = const . Just 3 in y `seq` y
03:22:31 <lambdabot>  Couldn't match expected type `a -> b'
03:22:48 <mwc> > let y = const . Just 3 in let x = y () in x `seq` x
03:22:48 <lambdabot>  Couldn't match expected type `a -> b'
03:22:55 <Taejo> @src maximum
03:22:55 <lambdabot> maximum [] = undefined
03:22:55 <lambdabot> maximum xs = foldl1 max xs
03:22:55 <mwc> me stares
03:22:58 <quicksilver> mwc: const (Just 3) ?
03:23:08 <mwc> this lack of sleep doesn't bode well for my exam in 8 hours
03:23:11 <skew> swiert: If you can model your evaluation by shallow embedding you inherit that from the underlying functions
03:23:17 <mwc> quicksilver, indeed
03:23:24 <mwc> of course, I'm stupid
03:23:35 <mwc> const :: b -> a -> b
03:23:44 <swiert> skew: yes. I think that's right.
03:23:53 <mwc> > let y = const (Just 3) in let x = y () in x `seq` x
03:23:54 <lambdabot>  Just 3
03:23:56 <swiert> skew: yes. It's exactly right even.
03:24:16 <skew> swiert: if you do a deep embedding you have to define reduction and show it terminates, and I think the type-theory way of doing that would be to explicitly write an evaluator
03:24:35 <mwc> > let y = const (Just 3) in let x = y () in x `seq` case x of { Just _ -> True; Nothing -> False}
03:24:36 <lambdabot>  True
03:24:42 <mwc> > let y = const (Just undefined) in let x = y () in x `seq` case x of { Just _ -> True; Nothing -> False}
03:24:43 <lambdabot>  True
03:24:45 <mwc> there
03:24:54 <mwc> you see how it only tried to evaluate Just there?
03:25:03 <skew> swiert: and you'd have to get an ITT interpreter as input, like you can show ZF + Con(ZF) |- Con(ZFC), but not even ZF |- Con (ZF)
03:25:06 <mwc> in fact, my example is damaged because I spent too much time with Caml this summer
03:25:42 <mwc> > let  x = Just undefined in x `seq` case x of { Just _ -> True; Nothing -> False}
03:25:42 <lambdabot>  True
03:25:44 <mwc> there
03:26:06 <skew> swiert: I think I understand a bit more about how the theory is put together so it all works
03:26:11 <mwc> seq forces the evaluation of x just to the "Just"
03:26:54 <swiert> skew: yes. A deep embedding would require writing an evaluation function (and showing that it terminates!) and that is a lot of work.
03:27:50 <skew> swiert: I think writing the evalution function in a strongly-normalizing language would be enough (and you'd have to assume suitably powerful eval as an argument to do it)
03:28:47 <swiert> skew: sure - but even writing that is a lot of work. It isn't at all obvious that well-typed terms are guaranteed to terminate.
03:28:50 <skew> swiert: I'm fairly sure it's still consistent if you take any nice type theory you like and extend it with a standard representation of it's own terms and an eval function, provided eval evaluates terms in an environment without eval, and so on as far as you'd like to stratify
03:28:52 <jhtulb> @djinn ((a->b) -> (a->c)) -> (a -> b -> c)
03:28:53 <lambdabot> f a b c = a (\ _ -> c) b
03:29:51 <swiert> skew: you may want to have a look at http://www.cs.nott.ac.uk/~jmc/Publications_files/tait2.pdf
03:30:30 <skew> swiert: I have, thank you
03:31:00 <jhtulb> @pl f a b c = a (\ _ -> c) b
03:31:01 <lambdabot> f = flip . (. const)
03:31:22 <swiert> skew: and all that work is just to show that an eval function for the simply-typed lambda calculus terminated - let alone any serious type theory.
03:34:30 <skew> swiert: I'll have to look at that one again, I looked over a few pages and I was still thinking about the one on coinductive big-step semantics
03:36:50 <swiert> skew: which one is that?
03:39:41 <skew> swiert: Oh, seems that one was by Xavier Leroy: pauillac.inria.fr/~xleroy/coindsem/
03:40:33 <skew> swiert: also something by the title "Tait in one big step"
03:41:22 <skew> ok, so that was closely related
03:41:25 <swiert> swiert: right. Hadn't seen Xavier's paper; Tait in on big step is my office mate's :)
03:42:48 <ramki> kryptos23, ping
03:43:59 <skew> swiert: I think just now see how you get away with leaving coherence undefined, it's the *types* that make coercions compute, and they may be taking fst or snd of their equalites but never actually force them to values
03:44:27 <swiert> skew: exactly. coherence is lazy in its proof argument as it were.
03:45:07 <skew> swiert: which I suppose all follows from arguing that data can't depend on proofs, and prop just needs to be consistent.
03:45:21 <kryptos23> ramki : pong!
03:45:57 <ramki> kryptos23: ramkrsna
03:47:28 <skew> swiert: thanks for explaining all that. I'm looking forward to seeing it in a language.
03:51:14 <swiert> skew: no problem! thanks for the interesting questions.
04:24:22 <tom`> hi all
04:24:31 <tom`> quick question, is there a function in the standard library to remove all duplicates from a list?
04:24:48 <skew> Data.List.nub?
04:25:07 <tom`> Cheers!
04:25:16 <tom`> Was searching for a function named unique or something
04:25:32 <skew> Perhaps Set.toList . Set.fromList, if you also have Ord
04:26:35 <tom`> I do, it's a list of strings
04:26:41 <tom`> Will that be faster then?
04:27:36 <Lemmih> tom`: Yes but the list will be sorted.
04:27:41 <skew> probably not until you have enough strings you shouldn't be using a plain list anyway
04:28:28 <tom`> skew: I think I do, but this is only getting run a few times so to a certain extent I'm willing to trade execution speed in return for it being easier to understand
04:29:11 <skew> nub is O(|output|*|input|)
04:29:49 <tom`> gotta run, thanks for the help!
04:31:57 <SamB_XP> skew: RULES can improve matters to O(log(|output|)*|input|) for members of Ord
04:32:53 <mux> anybody knows how am I supposed to run/compile an agda program?
04:33:08 <SamB_XP> mux: they run?
04:33:16 <mux> what do you mean?
04:33:40 <SamB_XP> well, you can do something with them in emacs...
04:33:59 <Taejo> @src FilePath
04:33:59 <lambdabot> type FilePath = String
04:34:05 <mux> no thanks :-) I'm trying agda because I couldn't use epigram without xemacs
04:34:14 <skew> SamB_XP: I don't see this RULE
04:34:28 <luqui> backlogging through skew and swiert's conversation... what is OTT?
04:34:32 <SamB_XP> skew: I didn't say that any were included with the compiler
04:34:55 <skew> SamB_XP: I don't think you can even condition on instances being available
04:35:04 <SamB_XP> skew: oh.
04:35:09 <SamB_XP> well that would make it harder :-(
04:35:48 * SamB_XP wonders if it would be reasonable...
04:36:41 <Taejo> @index scanf
04:36:41 <lambdabot> bzzt
04:36:51 <skew> SamB_XP: well, that might fall under "when the types match"
04:38:40 <Meldon> p {superset symbol) q = (p -> q, T -> T)     Does this conditional expression imply the superset or material implication?
04:38:55 <Taejo> is there anything like scanf in haskell?
04:39:04 <mornfall> Taejo: What do you mean? : - ).
04:39:24 <swiert> mux: there's an experimental Agda-to-Haskell compiler. I've never used it though...
04:39:31 <mornfall> Taejo: Maybe try read...
04:39:48 <mornfall> > read "[1, 2]" :: [Int]
04:39:49 <Taejo> mornfall, I have multiple values in the string
04:39:49 <swiert> luqui: observational type theory.
04:39:49 <lambdabot>  [1,2]
04:40:11 <SamB_XP> Meldon: I have no clue what you've got there :-(
04:40:37 <Taejo> In C: scanf("%d,%d\n", &a, &b); in Haskell...?
04:40:58 <Meldon> http://www-formal.stanford.edu/jmc/recursive.pdf Page 6.
04:41:36 <mornfall> Taejo: were they whitespace-separated, you could use "words"
04:41:55 <Meldon> It is the last expression at the top of page 6.
04:42:41 <Meldon> http://en.wikipedia.org/wiki/Math_symbols has that symbol listed from propositional logic and Heyting algebra but it is also used as the superset symbol in set theoretic notions.
04:42:41 <lambdabot> Title: Table of mathematical symbols - Wikipedia, the free encyclopedia
04:47:15 <Meldon> There seems to be only three distinctive truth value pairs in the expression's truth table, viz. 1->0, 1->1, and 0->1 taking the form of p->q.
04:48:31 <Meldon> If p is true, then the result is q as true or false, otherwise (if p false) true.
04:48:44 <SamB_XP> so... on page 3, why don't they have a final "otherwise" clause? are you supposed to just fill in true before the last arrow?
04:49:19 <SamB_XP> oh, yeah, they do that don't they
04:49:49 <SamB_XP> well, that's how it works in Haskell too, so I guess I shouldn't be too surprised ;-)
04:50:00 <Meldon> SamB_XP I do not know what you meant by that.
04:50:20 <SamB_XP> that's where they defined what the arrows meant
04:50:42 <Meldon> What did McCarthy intend for the symbol in the last conditional expression at the top of page 6?
04:50:58 <SamB_XP> haven't figured that out yet
04:51:32 <Syzygy-> I want to tell the AMS-MAA national conference about Haskell. Any pointers for what to include in the first three sentences about the language?
04:51:33 <agemo> can anyone tell me why the Macports GHC complains about 'no: command not found' when i'm trying to install it?
04:51:45 <agemo> and more importantly, how to fix it?
04:52:41 <SamB_XP> agemo: not I!
04:53:11 <SamB_XP> it sounds as if there is some attempt being made to run a program called no, failing on account of some command not being found...
04:53:39 <SamB_XP> are there any other messages before that?
04:54:18 <Meldon> SamB ah, it is the notion of 'material conditional' as exemplified early in the Wikipedia article http://en.wikipedia.org/wiki/Material_implication.
04:54:19 <lambdabot> Title: Material conditional - Wikipedia, the free encyclopedia
04:54:23 <agemo> output from the Makefile
04:54:37 <Meldon> "The material conditional is false when X is true and Y is false - otherwise, it is true."
04:54:54 <SamB_XP> agemo: what were the last few lines?
04:55:00 <agemo> including as last line the command 'no -M *insert several other options and files*"
04:55:36 <agemo> pasting them would be afwully spam-like :)
04:56:04 <Taejo> agemo: that's what pastebins are for
04:56:10 <agemo> true dat
04:56:13 <SamB_XP> agemo: huh. well, that's enough anyway...
04:56:31 <SamB_XP> so apparantly there is supposed to be a program called no
04:56:41 <SamB_XP> ?
04:56:51 <SamB_XP> or maybe the configure step failed
04:57:32 <SamB_XP> and somehow configure took the no literally instead of realizing that it hadn't found that program?
04:57:34 <hpaste>  agemo pasted "macports 'port install ghc' output" at http://hpaste.org/4286
04:58:02 <agemo> there you go :)
04:58:27 <agemo> i'm thinking the latter :)
04:58:39 <agemo> i'm fairly certain there is no program 'no'
04:59:42 <SamB_XP> I'm fairly certain that there is, but admit that it seems unlikely to be involved. (no idea what it does, it just seems like it would be wierd for the name not to have been used sometime or other...)
05:00:05 <agemo> true... and after all, there is a 'yes'
05:00:14 <agemo> so it would only be logical to have a 'no'
05:00:18 <agemo> but i've never come acrss it
05:00:32 <roconnor> @pl (\x y -> imp (le x y) (g (plus y (opp x))))
05:00:32 <lambdabot> ap (ap . (imp .) . le) ((g .) . flip plus . opp)
05:00:33 <SamB_XP> well, if there was a no that worked like yes, it would just spew n everywhere
05:00:43 <agemo> uhu
05:01:06 <agemo> and it wouldn't take the whole lot of arguments the Makefile is giving here
05:01:39 <SamB_XP> quite so
05:02:04 <SamB_XP> anyway, what did configure say?
05:02:53 <SamB_XP> perhaps you don't have GHC installed?
05:03:01 <agemo> i don't
05:03:04 <agemo> that's the point
05:03:10 <agemo> i'm trying to install ghc
05:03:10 <SamB_XP> AHA!
05:03:21 <SamB_XP> well. you need GHC in order to build GHC...
05:03:42 <SamB_XP> you should probably report this as a bug, though, as the configure script should have caught it...
05:05:03 <agemo> it said that too, at first, but after kinda added the --without-ghc option in the configure script...
05:05:15 <SamB_XP> oh.
05:05:26 <agemo> i'm used to gentoo, and altering source to make it work :)
05:05:38 <SamB_XP> what did the help message say about it?
05:05:48 <agemo> so i'm kinda still adapting to the idea of 'there is open source, but lease don't touch it'
05:06:02 <agemo> help message about what?
05:06:06 <roconnor> @pl (\x y z -> le (abs (minus x z)) (plus (abs (minus x y)) (abs (minus y z))))
05:06:08 <SamB_XP> --without-ghc
05:06:11 <lambdabot> ap ((.) . ap . ((le . abs) .) . minus) ((`ap` ((abs .) . minus)) . (((.) . plus . abs) .) . minus)
05:06:17 <agemo> nothing really
05:06:40 <agemo> i actually only found out the option existed by looking at the configure script :)
05:06:55 <agemo> (i promise that's all i altered!)
05:07:07 <Taejo> @lolcattime Taejo
05:07:08 <lambdabot> Local time for Taejo is Wed Dec  5 15:07:08
05:07:22 <hpaste>  aragaer pasted "(no title)" at http://hpaste.org/4287
05:07:48 <SamB_XP> agemo: well, I suspect that this option is intended only for people who know what they are doing
05:07:58 <SamB_XP> in particular, for porting GHC to new platforms
05:08:12 <agemo> usually i'm that kind of person... since 2 weeks on mac however... ;)
05:08:53 <SamB_XP> who have already gotten at least halfway through a GHC build, even
05:10:06 <SamB_XP> that is, when they've gotten GHC to generate C code for all of the modules that go into GHC...
05:18:22 <quicksilver> agemo: ghc on mac? use macports or download a compiled binary.
05:19:05 <agemo> quicksilver: macports is what i'm trying to use :)
05:19:30 <SamB_XP> quicksilver: for some reason it doesn't seem to have downloaded a compiled binary automatically
05:20:01 <quicksilver> dat's odd
05:20:06 <quicksilver> macports worked fine for me...
05:20:08 <quicksilver> (6.6.1)
05:20:18 <quicksilver> without a previously installed GHC
05:20:23 <psi> yeah, same here
05:20:23 <SamB_XP> maybe you should say exactly what commands you used
05:20:34 <quicksilver> sudo port install ghc
05:20:40 <quicksilver> was all it took for me
05:20:42 <quicksilver> IIRC
05:20:44 <psi> but it's been a while since i tried it
05:20:45 <quicksilver> it was a few months back
05:21:08 <SamB_XP> agemo: is that what you did ?
05:22:02 <agemo> no, originally i wanted to install darcs
05:22:06 <agemo> (i still do)
05:22:06 <mauke> what's the opposite of meta in "meta-language"?
05:22:12 <agemo> so i did sudo port install darcs
05:22:30 <agemo> and it needed ghc (obviously), so it pulled ghc in as dependency
05:22:49 <luqui> mauke, the (linguistic) converse, as in "if the meta language of X is Y, then the Z-language of Y is X"?
05:22:52 <agemo> that failed
05:23:00 <luqui> mauke, not that it matters, because I don't know what Z is
05:23:10 <agemo> and since then i've been using sudo port install ghc
05:23:19 <agemo> or sudo port install -v ghc
05:23:22 <doserj_> "object-language" is sometimes used
05:23:25 <mauke> luqui: yes
05:23:50 <agemo> (-v might be somewhere else, depending on when i think about the fact that i want it in there)
05:24:20 <luqui> mauke, bingo, object language
05:25:51 <agemo> maybe i'll try erasing everything from ghc and then reinstalling
05:26:38 <roconnor> @pl (\x y -> imp (g0 (minus x y)) (g x y))
05:26:38 <lambdabot> ap (ap . ((imp . g0) .) . minus) g
05:58:25 <Deewiant> how can I change (a, IO b) into IO (a, b)
05:59:13 <quicksilver> :t \(a,mb) -> do { b <- mb ; return (a,b) }
05:59:16 <lambdabot> forall t (t1 :: * -> *) t2. (Monad t1) => (t, t1 t2) -> t1 (t, t2)
05:59:26 <quicksilver> Deewiant: like that, generally
05:59:36 <Deewiant> duh... thanks
05:59:47 <quicksilver> if you wnat to be funky you could write \(a,mb) -> mb >>= (,) a
06:00:09 <Deewiant> @pl f (a,mb) = mb >>= (,) a
06:00:09 <lambdabot> f = uncurry ((=<<) . (,))
06:00:45 <mauke> :t \(a,mb) -> mb >>= (,) a
06:00:45 <lambdabot> forall t a. (Monad ((,) t)) => (t, (t, a)) -> (t, a)
06:01:00 <mauke> @. pl undo \(a,mb) -> do { b <- mb ; return (a,b) }
06:01:00 <lambdabot> uncurry (fmap . (,))
06:01:00 <quicksilver> hmm I didn't get that quite right, did I? :)
06:01:10 <quicksilver> if you wnat to be funky you could write \(a,mb) -> mb >>= return . (,) a
06:01:15 <quicksilver> I should have said?
06:01:18 <mauke> >>= return . is liftM
06:01:22 <quicksilver> or, (,) a <$> mb
06:01:59 <quicksilver> @pl \(a,mb) -> (,) a <$> mb
06:01:59 <lambdabot> uncurry ((<$>) . (,))
06:02:37 <Deewiant> @src <$>
06:02:37 <lambdabot> f <$> a = fmap f a
06:13:03 <dblhelix> good to be bacj
06:13:09 <dblhelix> /s/bacj/back
07:08:46 <zstars> Hi people, if I have a config file, and a program reads it like this: ,join_trigger :: Maybe IRC.Message     what would I actually have to put in the config file?
07:09:27 <zstars> I know that         join_trigger = Nothing   works
07:09:44 <zstars> But I wanna specify the message, does anyone know which syntax I could use? :(
07:10:35 <Milt_> Any of you guys familiar with F#?
07:12:45 <byorgey> zstars: something of type Maybe A is either Nothing, or Just x where x is a value of type A.
07:13:04 <byorgey> zstars: so you probably want to put something like join_trigger = Just foo, where foo is an IRC.Message.
07:13:16 <byorgey> but I don't know what an IRC.Message would look like.
07:13:28 <zstars> Where would that be defined? Could it just be a string?
07:13:30 <skew> NathanINTJ: not really, #ocaml would be closer if there isn't already an F# channel
07:13:38 <byorgey> zstars: what is this for?
07:13:53 <byorgey> zstars: maybe in a module named IRC.hs?
07:13:53 <zstars> An IRC bot
07:14:23 <zstars> Nice I'll try to find it
07:14:45 <byorgey> zstars: it might be just a string, that's certainly a possibility
07:14:59 <NathanINTJ> no fsharp channel as far as i can tell ;0
07:15:06 <luqui> NathanINTJ, you mean more than it is basically O'Caml?
07:15:20 <NathanINTJ> yeh luqui, i meant more than that it is basically O'Caml ;0
07:15:33 <zstars> Parsing error with    Just "PRIVMSG" :(
07:16:02 <skew> zstars: can you load it up in ghci and :info IRC.Message?
07:18:23 <zstars> What would be the command to load it?
07:25:24 <byorgey> zstars: do you have the haskell source where IRC.Message is defined?
07:25:40 <dmead> hey people
07:25:55 <dmead> where do i look for stuff on how to read bits off a serial port?
07:29:06 <monochrom> Thunkify, thunkify, thunk'em all the way. Oh what fun it is to write in a lazy-by-need way, Hey!
07:29:13 <zstars> I suppose I do, I'll try to find it
07:29:27 <monochrom> Monadic, monadic, monad all the way. Oh what fun it is to write in a categoric way!
07:31:36 <byorgey> zstars: what IRC bot is this?
07:32:00 <ricky_clarkson> @quote world
07:32:00 <lambdabot> Heffalump says: (re the RealWorld# token) The compiler knows that it can implement the token using the  arrow of time
07:32:11 <ricky_clarkson> monochrom: Monads won't change the world, you know.
07:32:38 <monochrom> Yeah yeah yeah, linear types can change the world, and all that.
07:33:22 <matthew_-> depends on your definition of change the world
07:33:40 <byorgey> @remember monochrom  Thunkify, thunkify, thunk'em all the way. Oh what fun it is to write in a lazy-by-need way, Hey! / Monadic, monadic, monad all the way. Oh what fun it is to write in a categoric way!
07:33:40 <lambdabot> It is stored.
07:33:45 <byorgey> nice song =)
07:33:54 <zstars> I think this is it: http://www.pastebin.ca/m2937235d        (It's geordi bot btw, the one at #geordi)
07:34:04 <monochrom> hehe thanks. There will be more.
07:34:48 <ricky_clarkson> zstars: Bah, I thought it would be the Geordie dialect, from Newcastle, England.
07:35:02 <zstars> Sorry I mean http://pastebin.com/m2937235d
07:35:08 <ricky_clarkson> Instead it's something far less comprehensible.. C++ ;)
07:35:28 <zstars> I actually wish it was in C++ lol
07:36:08 <byorgey> hm, pastebin.com isn't loading for me
07:36:21 <byorgey> zstars: I bet the person who wrote it doesn't =)
07:37:00 <zstars> It says that "  IRC Messages are parsed like [ ':' prefix space ] command { space param } crlf   "
07:37:22 <zstars> Is that somehow related to how it is parsed on a config file? :(
07:37:29 <byorgey> zstars: I have no idea.
07:37:59 <zstars> Where would it be defined how it is parsed from a config file?
07:38:34 <byorgey> ok, the paste loaded for me now.
07:38:44 <zstars> :)
07:39:17 <byorgey> so that says a value of type Message looks like this: Message x y z, where x has type (Maybe Prefix), y has type Command, and z is a list of Parameters.
07:40:58 <dmead> ?hoogle serial communications
07:40:59 <lambdabot> Did you mean: Serial Communications
07:40:59 <lambdabot> Prelude.undefined :: a
07:40:59 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
07:41:23 <byorgey> a Prefix, in turn, looks like either Server n, where n is a ServerName, OR NickName s user server where s is a String, user :: (Maybe UserName), and server :: (Maybe ServerName).  and so on.
07:41:41 <byorgey> zstars: does that make sense?
07:42:09 <zstars> So in the config file I'd have to put, for example,     Just IRC.Message Nothing  "PRIVMSG" ["Param1", "Param"]     ?
07:42:27 <dylan> hrm, what library provides gnu-getopt-style argumentparsing?
07:42:47 <wli> System.GetOpt
07:42:58 <dylan> is that part of base?
07:43:27 <byorgey> zstars: hm, except without the IRC.Message.  something like Just Nothing "PRIVMSG" ["Param1", "Param"].
07:43:41 <byorgey> zstars: assuming that Command and Parameter are both type synonyms for String.
07:46:04 <dylan> @index System.GetOpt
07:46:04 <lambdabot> bzzt
07:46:09 <dylan> @docs System.GetOpt
07:46:09 <lambdabot> System.GetOpt not available
07:47:51 <zstars> Looks like I am doing something wrong :(          Just Nothing "Wot" ["Wot"]
07:48:01 <quicksilver> that's not valid haskell at all
07:48:21 <quicksilver> Just (IRC.Message Nothing "PRIVMSG" ["Param1","Param2"])
07:48:23 <quicksilver> perhaps ?
07:48:43 <zstars> It's a config file though
07:48:49 <quicksilver> well, true
07:48:59 <quicksilver> but what you're saying implies that this file is using haskell syntax
07:49:11 <zstars> Oh ok I'll try that then :)
07:52:05 <matveev> hi, I find often myself manually "lifting" the function over representation f' (Box a) (Box b) = Box (f a b) where Box is not parametric: data Box = Box [Type] with specific Type == e.g. Integer.  Is there some standard primitive like fmap/liftM?
07:53:13 <integral> @pl \ba bb = Box (f (unBox ba) (unBox bb))
07:53:13 <lambdabot> (line 1, column 8):
07:53:13 <lambdabot> unexpected "="
07:53:13 <lambdabot> expecting pattern or "->"
07:53:19 <integral> @pl \ba bb -> Box (f (unBox ba) (unBox bb))
07:53:19 <lambdabot> (Box .) . (. unBox) . f . unBox
07:54:06 <zstars> No luck either :(
07:54:19 <mauke> Data.Generics could have something for that
07:54:21 <wli> liftM2?
07:54:29 <wli> liftA2?
07:54:46 <zstars> http://www.pastebin.ca/m376666e3        That's the config file itself, the bot code that parses it, and the IRC.Message definition
07:54:47 <mauke> no
07:55:12 <zstars> Anyone happens to know what the syntax for the config file should be? :(
07:58:44 <quicksilver> matveev: you can make Box into an applicative
07:58:51 <quicksilver> matveev: then that is liftA2
07:59:11 <quicksilver> liftA2 f boxa boxb
07:59:12 <quicksilver> or
07:59:18 <quicksilver> f <$> boxa <*> boxb
07:59:32 <mauke> no, you can't
07:59:49 <quicksilver> why not?
08:00:04 <quicksilver> (Box f) <*> (Box a) = Box (f a)
08:00:08 <quicksilver> looks like an applicative to me...
08:00:08 <mauke> because Applicative requires * -> *
08:00:19 <ToRA> c
08:00:26 <quicksilver> right, he'd have to redo the type slightly
08:00:30 <quicksilver> but that's OK
08:00:34 <quicksilver> it's a price worth paying :)
08:00:51 <matveev> so "Box . unBox" or "Box . f1 . unBox"  are all legal functions, even it Box starts with capital?
08:01:03 <quicksilver> matveev: constructors are also functions
08:01:05 <quicksilver> :t Just
08:01:07 <lambdabot> forall a. a -> Maybe a
08:01:30 <mauke> zstars: can't connect
08:02:15 <zstars> Ops sorry http://pastebin.ca/m376666e3
08:02:35 <doserj_> zstars: you could try quicksilvers example. but without the "IRC." prefix
08:03:22 <zstars> Doesn't seem to work either :(
08:08:30 <byorgey> zstars: what you pasted there looks good. maybe you just need a closing } ?
08:08:42 <byorgey> (to match the opening one on line 4)
08:09:23 <zstars> There's one already, if I change Just (IRC.Message( ... thing for just "Nothing" it works
08:09:38 <zstars> Problem is I want to specify my own Message :(
08:10:25 <dons> ?users
08:10:25 <lambdabot> Maximum users seen in #haskell: 420, currently: 387 (92.1%), active: 14 (3.6%)
08:11:43 <byorgey> zstars: what error do you get?
08:12:05 <zstars> user error "Parsing cfgfile"
08:12:14 <byorgey> oh =P
08:14:19 <byorgey> zstars: do you have ghc or hugs installed?
08:14:40 <zstars> Yeah I have ghc6 installed
08:15:45 <byorgey> zstars: try running ghci, then load the haskell file that defines BotConfig (by typing something like :load "foo.hs")
08:16:15 <byorgey> zstars: then you can try typing Just (IRC.Message ( blah blah... at the prompt and you'll get much more useful error information.
08:18:51 <zstars> Gives some error when loading, tells me to use -fglasgow-exts
08:19:16 <byorgey> ok, quit and start ghci again but give it the -fglasgow-exts option
08:21:02 <zstars> "Could not find module 'util'. It is a member of package ghc-6.6.1, which is hidden" :(
08:21:17 <hpaste>  toyvo pasted "query a collection by type" at http://hpaste.org/4288
08:22:14 <byorgey> zstars: hrm, boo.  I downloaded it to try playing around with it myself and I got the same error.  I was hoping you wouldn't since you've actually compiled it and everything... =(
08:22:48 <zstars> :(
08:23:33 <hpaste>  matveev pasted "lift1/lift2 (a bit too specialized?)" at http://hpaste.org/4289
08:25:58 <matveev> is there a simpler or not so specialized way to turn f1 into f1' and f2 into f2' ?  (see http://hpaste.org/4289)
08:34:32 <hpaste>  byorgey annotated "lift1/lift2 (a bit too specialized?)" with "an Applicative instance for Box" at http://hpaste.org/4289#a1
08:35:04 <byorgey> matveev: but notice that essentially this is the same as ZipList, from Control.Applicative.
08:35:12 <byorgey> so you might not need Box at all.
08:36:19 <byorgey> matveev: but also, there are other possible choices for the semantics of the Applicative instance.  e.g. the list monad semantics.
08:38:03 * oerjan found himself wondering, given ordinary [] and ZipList (which probably can be made a monad), if there is a list monad such that return x = [x,x]
08:41:44 <shag> how do i eliminate the warning "Warning: Defaulting the following constraint(s) to type `Integer' `Num t' arising from the literal `1' at ..."?
08:41:46 <oerjan> although considering bottoms it seems it would need join [[x,x],[undefined,undefined]] = [x, undefined] = join [[x,undefined],[x,undefined]] and similarly for the lower half
08:42:02 <shag> "In the expression: 1"
08:42:25 <oerjan> shag: you have -Wall on, probably?
08:42:32 <shag> oerjan: of course
08:42:51 <oerjan> because i recall a discussion about how annoying that was
08:42:56 <shag> hm
08:43:08 <oerjan> apparently the only way is to add type annotations
08:43:12 <shag> i was thinking about just turning -Wall of but ...
08:43:17 <shag> off, even
08:43:26 <byorgey> oerjan: consider f = (:[]) . map (1+), then we have return 2 >>= f = [3,3], but f 2 = [3].
08:43:31 <doserj_> -fno-warn-type-defaults?
08:43:33 <byorgey> so the monad laws don't hold.
08:43:33 <oerjan> which is sort of annoying if you end up with things like x^(2::Integer)
08:43:58 <shag> okay.
08:44:15 <byorgey> oerjan: for the same reason, you can't make a monad with return = repeat, either.
08:44:31 <oerjan> byorgey: um, ZipList _is_ a monad with return = repeat, i think
08:44:36 <byorgey> um, wait, that didn't make sense
08:44:55 * byorgey goes off to think some more
08:45:55 <oerjan> yeah i think you used the ordinary >>= in your argument
08:46:37 <shag> ah. -fno-warn-type-defaults is doing the trick and  does not requre me to turn off -Wall. thansk doserj (although he left...)
08:46:56 <mauke> two :: Int; two = 2
08:47:01 <oerjan> heh, should have known there'd be a specific option :)
08:47:42 <nolrai> I think i want to use the Cont monad, but i'm not positive.  I want to be able to write error handelers that get data from the user and then return to the computation.
08:49:13 <matveev> byorgey: list is not essential there, I wonder why there are liftM* primitives for (Monad m) => m a, fmap primitive for (Functor f) => f a and (apparently) no primitives for (special case?) of "non-parametric" type data Box = Box a.
08:50:29 <oerjan> nolrai: possibly Error monads will be sufficient, and they're easier if so
08:51:08 <oerjan> matveev: data Box = Box a is not a legal declaration...
08:51:53 <joelr1> good day
08:52:04 <byorgey> matveev: but for non-parametric types, there would have to be a separate type class/set of combinators for each different underlying type.
08:52:06 <joelr1> @seen bringert
08:52:06 <lambdabot> I saw bringert leaving #ghc and #haskell 1h 20m 51s ago, and .
08:52:23 <matveev> oerjan: right, thats why I used something more specific as an example data Box = Box [Int], sorry.
08:52:40 <byorgey> matveev: you don't particularly have anything to gain by making such a type non-parametric, IMO.
08:53:13 <oerjan> byorgey:  unboxed arrays...
08:54:30 <nolrai> Yeah thats what i was thinking but the propogating isn't quite right, because i need to get back to where the error happened after i handle it.
08:55:03 <MyCatVerbs> @pl \f a b -> a + (f b)
08:55:03 <lambdabot> flip ((.) . (+))
08:55:04 <nolrai> at oerjan ^^
08:55:25 <mauke> @pl \(+) -> a + b
08:55:25 <lambdabot> (line 1, column 3):
08:55:25 <lambdabot> unexpected "+"
08:55:25 <lambdabot> expecting pattern
08:55:49 <MyCatVerbs> @pl \a f b -> a + (f b)
08:55:49 <oerjan> nolrai: what kind of error is this?  if you make your error handler a function that is called ordinarily and only escapes if it wants to abort completely, you could simplify things
08:55:49 <lambdabot> (.) . (+)
08:55:56 <MyCatVerbs> @pl \a b f -> a + (f b)
08:55:56 <lambdabot> (. flip id) . (.) . (+)
08:56:10 <MyCatVerbs> :t (. flip id)
08:56:11 <lambdabot> forall c a c1. (((a -> c1) -> c1) -> c) -> a -> c
08:58:34 <oerjan> i recall reading somewhere that some lisps(?) use this approach for resumable exceptions
08:59:16 <nolrai> :oerjan - true does using lasy evaluation to make co-computations work?
09:00:09 <nolrai> I.E using getContents ?
09:00:44 <oerjan> not sure
09:00:54 <oerjan> my guess is, some times
09:02:42 <nolrai> or i could make it part of the IO monad, or a restriction of the IO monad. That would work! thanks!
09:03:42 <quicksilver> matveev: if you make it parametric, as in data Box a = Box a
09:03:48 <quicksilver> matveev: then you can make it applicative
09:03:57 <quicksilver> which solves your initial problem, I believe
09:04:08 <oerjan> ah, the amap function already does this for Arrays
09:04:18 <oerjan> matveev: ^^
09:04:44 <oerjan> :t amap
09:04:51 <lambdabot> Not in scope: `amap'
09:04:59 <oerjan> :t Data.Array.IArray.amap
09:05:00 <lambdabot> forall e' e (a :: * -> * -> *) i. (Ix i, Data.Array.Base.IArray a e, Data.Array.Base.IArray a e') => (e' -> e) -> a i e' -> a i e
09:05:19 <matveev> quicksilver: by adding the instance Functor Box, yes?
09:05:44 <oerjan> as you see, it is based on an MPTC connecting content and container types
09:07:23 <oerjan> oh wait i'm misreading
09:07:39 <oerjan> a must be the same in both cases
09:12:09 <quicksilver> matveev: wel yes, but also Applicative
09:12:28 <quicksilver> matveev: Functor only lets you lift unary functions
09:13:32 <nolrai> Does there exist a monad transformer for the IO monad?
09:13:55 <oerjan> nolrai: no
09:14:18 <nolrai> \oerjan++
09:14:35 <oerjan> @karma \oerjan
09:14:35 <lambdabot> \oerjan has a karma of 1
09:14:55 <\oerjan> woohoo!
09:15:04 <oerjan> @karma byorgey
09:15:04 <lambdabot> byorgey has a karma of 7
09:15:50 <quicksilver> nolrai: there can't be, as that would suggest you could rollback IO actions and even duplicate IO continuations
09:17:29 <nolrai> Yeah that makes sense. So I want something like StateT s IO r.
09:20:06 <chessguy> hiya haskellers
09:20:15 <daniel_larsson> hi
09:21:32 <chessguy> @remember lambdacats I CAN HASKELL CHEEZEBURGER?
09:21:32 <lambdabot> I will never forget.
09:24:59 <shapr> hiya chessguy
09:25:11 <chessguy> shapr :)
09:25:35 <shapr> lambdacats is so cool!
09:26:13 <bmeph_> Lambdacats, HOOOOOOOOOO! ;)
09:30:20 <dons> ?yow
09:30:25 <lambdabot> CONGRATULATIONS!  Now should I make thinly veiled comments about
09:30:25 <lambdabot> DIGNITY, self-esteem and finding TRUE FUN in your RIGHT VENTRICLE??
09:31:11 <araujo> hi dons
09:31:33 <dons> shapr: this serialisation stuff -- we need a paper from the HAppS crew for CUFP or HW 08 :)
09:31:37 <dons> lots of interesting stuff going on
09:31:39 <dons> hey araujo !
09:31:43 <araujo> :-)
09:31:43 <shapr> Good idea!
09:31:50 <araujo> hi shapr
09:32:30 <shapr> hola araujo
09:33:44 <araujo> :-)
09:36:57 <dons> shapr: we need to send a copy of 'programming in haskell' to the xkcd guy
09:37:29 <dons> i mean, come on, math + romance + language == haskell!
09:37:38 <shapr> truly
09:37:39 <dcoutts_> here here!
09:38:01 <byorgey> indeed!
09:38:30 <dons> :)
09:38:32 <mauke> haha
09:38:33 <mauke> seems like all programming channels read xkcd
09:38:57 <chessguy> dons, haha. did you read the python one today?
09:39:06 <loupgaroublond> does haskell make you fly too?
09:39:20 <loupgaroublond> i've been using python for years, i don't think i'd notice a difference
09:39:24 <byorgey> loupgaroublond: teleport, actually
09:39:45 --- mode: ChanServ set +o dons
09:39:49 --- topic: set to '["The Haskell programming language","math + romance + language == haskell","http://haskell.org ","http://www.jobs-in-fp.org/","Paste: http://hpaste.org ","Logs: http://tunes.org/~nef/logs/haskell/"]' by dons
09:39:53 --- mode: ChanServ set -o dons
09:39:54 <dons> time travel
09:40:17 <byorgey> yes, I meant teleport in space-time, of course... =)
09:40:33 <dons> yes, we assume higher-kinded teleportation in #haskell
09:41:12 <wli> If you can fly with Python, then you can fold space like a Guild Navigator with Haskell?
09:41:19 <dons> mmm
09:41:23 <byorgey> haha
09:41:32 <chessguy> Guild Navigator?
09:41:54 <byorgey> chessguy: Dune reference
09:42:02 <chessguy> ah
09:42:13 <byorgey> @remember wli If you can fly with Python, then you can fold space like a Guild Navigator with Haskell?
09:42:13 <lambdabot> Done.
09:42:15 <chessguy> i really should read that sometime
09:42:59 * byorgey faxes chessguy a copy
09:43:15 <chessguy> very kind of you
09:45:13 <dylan> whee.
09:45:23 <dylan> I created a query language for my addressbook. :)
09:46:53 <Japsu> dylan: nice. now remember, "Leaving a syntax definition informal is unforgivable unprofessionality" (-prof. Antti Valmari)
09:46:56 <Japsu> ;)
09:47:21 <ricky_clarkson> It's formal if you've written the parser. ;)
09:47:23 <mornfall> Is a parser considered a formal definition?
09:48:06 <dylan> it's a parsec parser, it also depends on my own eccentric addressbook format
09:48:15 <dylan> (which is ... relatively close to a dos ini file)
09:49:26 <dylan> a few months ago, I got tired of abook and translated its address book into a format that was easy to maintain in a text editor.
09:49:56 <dylan> I missed abook's mutt integration (abook --mutt-query). I think I have gone overboard in replacing that functionality
09:50:39 <chessguy> heh. you patterened something after DOS...isn't that like building a ship from a model of the Titanic?
09:50:47 <dylan> chessguy: well,
09:51:14 <dylan> I think [nickname]\nname=full name\nemail=address\nphone=...\n is fairly easy
09:51:37 <dylan> it's quite easy to type, which is good as I maintain the file by hand right now.
09:51:45 <chessguy> you should have used YAML. YAML rocks
09:51:53 <dylan> yaml would require more typing.
09:52:00 <dylan> and is harder to parse with awk.
09:52:09 <chessguy> so parse it with haskell
09:52:16 <chessguy> haskell could use a good YAML parser
09:52:31 <dylan> (I use a quick awk script to turn my addressbook into a spam assassin whitelist on my email/webhost)
09:53:01 <dylan> anyway. it was originally yaml, I translated it to the ini-like format because it was easy to type.
09:53:41 <dylan> my address book has been through mutt alias file -> custom yaml file -> abook's own ini-like, but numbered instead of nickname'd format, -> my own format.
09:53:45 <chessguy> you could also just write a simple ini->yaml converter
09:53:54 <dylan> why would I do that?
09:54:04 <chessguy> because, yaml's cool
09:54:22 <dylan> it's a useless use.
09:54:45 <chessguy> no more useless than creating your own format based on something archaic
09:55:13 <dylan> I'll also point out parsers exist for my own format in C, python, perl, haskell, and probably others
09:55:38 <chessguy> oh? you wrote them?
09:55:41 <dylan> No
09:55:58 <chessguy> well then it's hardly your own format :)
09:55:59 <dylan> they just exist. :)
09:56:11 <dylan> well, as I said, it resembles an .ini file
09:56:39 <dylan> CosmicRay wrote a ConfigParser module for haskell, which is mostly compatible with a module of the same name in python.
09:56:51 <dylan> which uses a [name]\nkey=value syntax.
09:57:06 <chessguy> bah. too many formats, too many standards
09:57:08 <dylan> I *do* use yaml for tracking metadata between my PDA and the 'remind' program
09:58:12 <dylan> eh, parsing is easy. as long as it isn't xml. :)
09:58:37 <chessguy> ha!
09:58:38 <dylan> (actually, parsing yaml isn't very easy, it's a very complicated format with multiple syntaxes for identical things...)
09:58:48 <chessguy> yeah, it is complex
09:59:11 <alexj> why not use xml?
09:59:15 <dylan> I haven't been able to get the syck parser working with haskell on OS X, either.
09:59:21 <dylan> alexj: xml is hard to write.
09:59:21 <alexj> there are a zillion xml editors.
09:59:33 <alexj> xml emacs mode works pretty well too.
09:59:44 <dylan> xml requires more typing, this little file I have is mostly read and written by me.
10:00:09 <dylan> I can also go over it with a simple awk script to whitelist everyone in my addressbook.
10:00:37 <alexj> ok
10:01:18 <dylan> I also use the 'remind' program, which is similar in that I edit a file in a given format (which is actually a calendar-language)...
10:03:23 <dylan> what's fun, is using the query language I wrote in haskell, I have written a shell script that extracts birthday events from my calendar (with rem -s) and prompts me to send them an email a day before their birthday. :)
10:04:25 <fasta> file =~ "^([[:digit:]]+).dot$")::String <- how can I only have the group in the String instead of the complete matching?
10:09:33 <oerjan> :t (=~)
10:09:41 <lambdabot> Not in scope: `=~'
10:09:50 <oerjan> @index =~
10:09:50 <lambdabot> bzzt
10:10:36 <byorgey> fasta: IIRC, isn't =~ polymorphic?  see if you can get some sort of match data structure from which you can extract the first group, rather than just a String.
10:10:47 <byorgey> I'm guessing here, but since no one else has responded... =)
10:10:57 <fasta> byorgey: yes, it is polymorphic.
10:11:12 <oerjan> :t (Text.Regex.=~)
10:11:12 <lambdabot> Not in scope: `Text.Regex.=~'
10:11:16 <fasta> byorgey: but since the polymorphic instances are not documented perfectly...
10:11:23 <byorgey> fasta: ah. =(
10:11:30 <fasta> byorgey: I am not basically trying all the instances .
10:11:38 <fasta> not -> now
10:13:28 <fasta> "This is the same as the type from JRegex."
10:13:39 <doserj> http://haskell.org/ghc/docs/latest/html/libraries/regex-base-0.72.0.1/Text-Regex-Base-Context.html is quite comprehensive, isn't it?
10:13:39 <lambdabot> http://tinyurl.com/2htztm
10:14:07 <fasta> doserj: yes, that seems so.
10:14:32 <fasta> doserj: but I am using posix, so I am not sure whether that's the same.
10:14:55 <doserj> ah, no idea :)
10:15:05 <alexj> @seen lemmih
10:15:05 <lambdabot> lemmih is in #haskell. I last heard lemmih speak 5h 47m 29s ago.
10:16:48 <fasta> doserj: it helped somewhat, since when I use [[String]] I get the desired answer. I just don't see why it would work.
10:17:08 <fasta> "This is the list of the list of the text of the sub-part of each match. "
10:17:35 <fasta> The result I get is [["complete match", "first group"]]
10:17:46 <byorgey> Is that even English? =P
10:20:57 <doserj> index 0 also seems to be used for the whole match in the Array intances, so it seems to be consistent
10:21:16 <bos> glguy: wow!
10:21:16 <lambdabot> bos: You have 1 new message. '/msg lambdabot @messages' to read it.
10:22:19 <fasta> doserj: yes, that seems so, but it's not documented.
10:22:58 <grahamhutton> hi andy -- i pulled an all-dayer on the paper today; 18 pages now revised!
10:25:03 <Meldon> Does anyone here have access to JSTOR?
10:30:51 <nolrai> > zip ['a'..'z'] [1..]
10:30:53 <lambdabot>  [('a',1),('b',2),('c',3),('d',4),('e',5),('f',6),('g',7),('h',8),('i',9),('j...
10:31:03 <nolrai> > zip ['a'..'c'] [1..]
10:31:03 <lambdabot>  [('a',1),('b',2),('c',3)]
10:32:57 <Deewiant> has anybody managed to get GHCi on Acid working on Windows?
10:34:41 <bmeph_> Deewiant: Not I, but I'm just dabbling.
10:36:08 <Deewiant> It would appear I need a lambdabot binary before I can even think about it, but that tells me it needs "unix -any" so I guess I might be out of luck :-)
10:36:47 <oerjan> i am not sure hs-plugins which lambdabot is based on runs on windows
10:37:01 <oerjan> @where hsplugins
10:37:01 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
10:38:00 <conal> I'd like to hear how people interpret "Control" in the module hierarchy (Control.Applicative, Control.Monad, etc).
10:38:05 <Deewiant> "hs-plugins should only be
10:38:05 <Deewiant> limited to platforms with a working GHC dynamic loader, which is all the
10:38:05 <Deewiant> systems I've tested on, plus Windows. Any unixy dependencies should be
10:38:05 <Deewiant> considered bugs"
10:38:11 <Deewiant> bah, sorry about the multiline
10:38:14 <conal> We're having a taxonomy discussion on the Yampa list, and some different interpretations have come up.
10:38:31 <Deewiant> but anyhoo, that's from a message from 2004, so I guess that shouldn't be the biggest problem
10:38:31 <oerjan> control flow structures?
10:38:52 <fasta> conal: as in "control operator"
10:39:03 <Deewiant> as in "supreme control"
10:39:17 <fasta> conal: how do you interpret it?
10:40:12 <sclv_> It seemed intuitive to me to think of it as "custom control structures"
10:40:54 <sclv_> or, if you prefer, "reified" rather than "custom"
10:40:55 <oerjan> http://www.cse.unsw.edu.au/~dons/hs-plugins/hs-plugins-Z-H-1.html#node_sec_2 seems to agree
10:40:56 <lambdabot> Title: hs-pluginsDynamically Loaded Haskell Modules, http://tinyurl.com/2gbcwr
10:41:31 <oerjan> @where lambdabot
10:41:32 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
10:42:37 <sclv_> ?where you
10:42:37 <lambdabot> I know nothing about you.
10:42:43 <sclv_> no kidding.
10:42:44 <conal> fasta: When I look at base/Control/*, the common thread I see is type classes whose most popular current applications happen to be imperative programming.  I think that's the sense of "Control" being used: imperative programming.
10:43:16 <fasta> conal: I do not agree.
10:43:31 <conal> fasta: no surprise here
10:43:42 <conal> ;)
10:43:55 <conal> (statistically speaking)
10:43:57 <fasta> conal: sure, most people use monads for sequencing stuff.
10:44:18 <mrd> Control.Parallel?
10:44:36 <fasta> conal: renaming it as Imperative.Monad or something like that would basically rape the idea of Monad, however.
10:44:40 <fasta> of a*
10:44:47 <shag> is there something like a reference to haskell arrows? or am i just too stupid to use google correctly?
10:44:56 <byorgey> @where arrows
10:44:56 <lambdabot> http://www.haskell.org/arrows/
10:45:00 <conal> fasta: i wouldn't suggest Imperative.Monad
10:45:05 <conal> fasta: nor Control.Monad
10:45:10 <fasta> conal: then what?
10:45:12 <byorgey> shag: try that =)
10:45:14 <conal> as monad isn't about either.
10:45:15 <shag> yes. i know that page. but even the &&& is not explained there
10:45:16 <bmeph_> conal: Isn't Arrows in the Control module? (Now doesn't THAT sound like poor English? ;)
10:45:19 <mrd> Combinators.Monad
10:45:29 <sclv_> conal: yr. much beloved Control.Applicative, which seems hardly imperative, is there to, no?
10:45:37 <sclv_> s/to/too/
10:45:42 <shag> i need something like "arrows for dummies" i suppose...
10:45:47 <byorgey> shag: yes it is.  click on the "arrow syntax" link at the top.
10:45:51 <conal> yes.  and i wouldn't put Applicative or Arrow there
10:45:56 <conal> nor Category
10:46:05 <conal> because none of them is about control
10:46:12 <conal> they're all more general.
10:46:14 <byorgey> shag: there's also the wikibook
10:46:17 <byorgey> @where wikibook
10:46:17 <lambdabot> http://en.wikibooks.org/wiki/Haskell
10:46:22 <dcoutts_> conal: I was thinking more over the weekend about make and applicative. It seems to me that applicative describes static dependency structures and a monad could be used to describe dependency structures where the very dependencies react to the environment.
10:46:25 <fasta> conal: I don't want to know what infinite numbers of strings are not your suggestion.
10:46:29 <byorgey> shag: I think there's a section on arrows in there.
10:46:32 <shag> byorgey: proc and -< are explained, but not &&& as far as i can see. the &&& is only used, but not explained
10:46:35 <mrd> Wonads are the evil twin of Monads
10:46:37 <skew> conal: what is the word for this more general thing they are aboud?
10:46:43 <bmeph_> conal: But are Monads about control, for that matter?
10:47:04 <shag> well, the wikibook on arrows is not that extensive ...
10:47:05 <conal> bmeph_: no, they're not.
10:47:18 <mrd> shag: &&& is pretty easy though, it just splits the arrow into two copies
10:47:19 <SamB_XP> mrd: is there also a game called Monad Party?
10:47:38 <byorgey> shag: oh, I see, you're right.  well, try the wikibook.
10:47:40 <fasta> But why does every implementation of >>= does something to control the control-flow?
10:47:42 <conal> fasta: i was replying to questions about arrow & applicative,
10:47:43 <mrd> and Wonad World
10:47:53 <shag> byorgey: ok thanks
10:48:21 <fasta> > Just 1 >> Nothing
10:48:23 <lambdabot>  Nothing
10:48:28 <sclv_> Conal: so your issue is that the word "Control" doesn't capture what you think these structures have in common then?
10:48:47 <skew> conal: arrows and applicative and monads all seem to be pretty similar to me, and not just about imperative sequencing
10:49:10 <dcoutts_> fasta: because the type of >>= allows dependent calculations, and data dependencies implies sequencing in calculation order
10:49:13 <conal> sclv_: close.  it's that in each case (Monad, Applicative etc), Control is too specific.  It captures some uses and not others.
10:49:24 <conal> skew: exactly!
10:49:31 <oerjan> Effect.Monad perhaps?
10:49:39 <conal> oerjan: still too specific.
10:49:45 <skew> conal: more sort of a "general notion of computation", or something algebraic
10:49:47 <conal> consider the Maybe monad
10:49:55 <SamB_XP> oerjan: I think Effect is less accurate than Control
10:49:56 <conal> skew: consider Maybe & List
10:50:00 <skew> conal: I consider that all control.
10:50:02 <sclv_> Category, obv. But that would be way too confusing.
10:50:24 <conal> skew: then you'd want Data.List to move to Control.List?
10:50:28 <sclv_> or Compose
10:50:29 <mrd> Combinators!
10:50:35 <dcoutts_> conal: my view on the Control.* name is that its about the structure of the calculation, and people often think about that in terms of control flow
10:50:43 <fasta> dcoutts_: just because it allows it, doesn't mean that it should use it.
10:50:56 <dcoutts_> fasta: but if it doesn't use it, then monad is too general
10:51:06 <skew> conal: the monadic stuff certainly
10:51:21 <oerjan> conal: because in haskell the boundary between Data and Control is fuzzy
10:51:23 <conal> dcoutts_: because they're thinking imperatively
10:51:26 <dcoutts_> conal: yes.
10:51:31 <conal> oerjan: yes!
10:51:47 <doserj> Data.* should be general purpose data types
10:51:55 <conal> dcoutts_: that's why it's important *not* to reinforce their imperative thinking.  functional programming is a different mindset.
10:51:58 <doserj> i don't think that is fuzzy
10:52:01 <conal> doserj: you mean for classes?
10:52:13 <doserj> classes should not be in Data.*
10:52:20 <oerjan> Flow.Monad then?
10:52:23 <conal> doserj: i agree!  nor in Control.
10:52:35 <conal> oerjan: flow?  does Maybe fit?
10:52:41 <doserj> Category.Monad, Category.Applicative, ... ?
10:52:51 <oerjan> conal: sure, Nothing aborts
10:52:53 <conal> Category.Applicative.Monad?
10:53:03 <skew> conal: things like map and fold seem a little trivial to be interesting as languages
10:53:16 <dcoutts_> conal: aye, I can't think of a immediately obvious name though. Category is either uninformative or scary :-)
10:53:19 <byorgey> how about NiftyStuff.Monad, NiftyStuff.Applicative, and so on =)
10:53:20 <sclv_> we could put them all in the Data.Function.* category!
10:53:34 <sclv_> byorgey: NiftyStuff.WarmFuzzy
10:53:54 <SamB_XP> conal: what should be in Control, if not Monad or Arrow?
10:54:02 <byorgey> sclv_: oh, of cousre! =)
10:54:31 <doserj> Control.Exception, Control.Concurrent, Control.Parallel seem ok
10:54:31 <Saizan> btw, are the names in the hierarchy so important?
10:54:44 <fasta> Saizan: no :)
10:54:48 * SamB_XP thinks conal has the wrong issue
10:54:50 <skew> conal: I think that's getting closer to the point, it's profitable to imagine a language whose denotational semantics are based on many of the things in control.
10:54:53 <conal> SamB_XP: do you mean Control is a category so it needs filling?
10:55:11 <dcoutts_> conal: do you see what I meant about monad & applicative with respect to make and deps. eg imports foo_hs >>= \is -> ghc <*> (foo_hs : is)
10:55:23 <sclv_> what was the famous quote about arguments over semantics?
10:55:25 <conal> dcoutts_: sure
10:55:37 <SamB_XP> conal: you should worry more about what methods are in which classes and less about the inability of the name of the module to properly describe the contents
10:55:45 <dcoutts_> conal: the dependencies actually depend on the environment, the existence and content of foo_hs
10:55:49 <skew> conal: and then you complain the the surface syntax of haskell is a bit awkward, and invent sugar for it
10:56:41 <skew> SamB_XP: now there's an idea! module import_Data_List_main_equal_put_str_ln_lp_nub_oq_hello_world_cq_rp where ...
10:57:44 <dcoutts_> conal: so that fits >>=, the structure of one time-varying value depends on another. TV a >>= (a -> TV b)
10:58:02 * SamB_XP proposes that Monad, Arrow, etc. all go in "Cool."
10:58:03 <dcoutts_> so whenever the first changes, we have to recalculate the structure of the second time varying value
10:58:13 <conal> SamB_XP: i think i'm missing your point.  do the class methods tell you something useful about categorizing in the examples we've been discussing?
10:58:47 <SamB_XP> conal: no, I just think it's more important to get fail and mzero into MonadZero where they belong than to argue about the module names...
10:59:04 <dcoutts_> and to get applicative as a superclass of Monad!
10:59:13 <skew> dcoutts_: or Functor!
10:59:14 <dcoutts_> and same with Functor
10:59:19 <dcoutts_> skew: yes :-)
10:59:22 <sclv_> and fix monads so that Set can be one!
10:59:31 <dcoutts_> hmm, that's rather more tricky
10:59:34 <conal> SamB_XP: oh -- you're focused on a different question, whose importance is more obvious to you.  cool.  go for it.
10:59:36 <SamB_XP> sclv: that's a lot harder
10:59:46 <SamB_XP> that's something you could actually write a paper about
11:00:07 <dcoutts_> Functor => Applicative => Monad
11:00:29 <sclv_> SamB_XP: I think oleg already sort of did.
11:00:32 <dcoutts_> it'd be really nice to be able to define defaults for superclass methods in a subclass
11:00:32 <skew> sclv_: yeah, set can't really be a monad on all of Haskell
11:00:35 <conal> dcoutts_: i'd love to have a focused discussion with you.  would you mind waiting a bit?
11:00:41 <dcoutts_> conal: sure, np.
11:00:42 <fasta> What's ambiguous here? http://paste.debian.net/44249
11:00:51 <SamB_XP> well, you might be able to write a sociology paper about renaming modules or something
11:01:12 <dcoutts_> so eg for all the people who don't care about Functor, Applicative they can define return and >>= and get default implementations of fmap, pure, <*> for free.
11:01:27 <conal> I have two simple answers for the question of where to put Monad, Arrow, Applicative, etc.
11:01:31 <SamB_XP> dcoutts_: that would be pretty sweet
11:01:44 <SamB_XP> conal: what are your two answers?
11:01:51 <SamB_XP> are they mutually incompatible?
11:02:02 <conal> One is Class.  The other is that hierarchical taxonomy is unworkable and unnecessary.  See http://www.shirky.com/writings/ontology_overrated.html .
11:02:03 <lambdabot> Title: Shirky: Ontology is Overrated -- Categories, Links, and Tags
11:02:48 <conal> SamB_XP: yes.  the answers are alternatives.
11:03:01 <SamB_XP> conal: is that by any chance about package names?
11:03:10 <SamB_XP> some things actually belong together, you know!
11:03:14 <dcoutts_> conal: but it's pretty useful to be able to give things names and not just have one big mass of them but to be able to split them up into related things
11:03:16 <fasta> It seems that type-inference should be able to figure out what instance of read to select.
11:03:40 <dcoutts_> sure, some belong in multiple places
11:03:47 <conal> See the paper.  The alternative to hierarchy isn't lack of structure.  it's much richer structure.
11:03:53 <xinming> local f m = Reader $ runReader m . f     <-- in this example, anyone here would tell me what the final result please?  for "runReader m . f" part.  is the order which will be like.  (runReader m) . f, or runReader (m . f) ?
11:04:01 <byorgey> fasta: hmm, indeed
11:04:34 <SamB_XP> conal: I don't see anything stopping you from adding those kinds of structure to what we have now...
11:04:34 <conal> We can capture *all* meaningful relationships, not just a few short-sighted and arbitrary ones.
11:04:37 <byorgey> xinming: (runReader m) . f.   function application always binds most tightly.
11:04:55 <SamB_XP> conal: even short-sighted arbitrary relationships are sometimes useful
11:05:16 <conal> SamB_XP: and they'll captured as well.
11:05:23 <roconnor> When is the next hackathon?
11:05:29 <doserj> conal: I could live with Class.Applicative, Class.Monad, etc. (and also put Foldable, Traversable, etc there)
11:05:45 <skew> conal: I think I've already told you I don't think you can do that solely with the module naming system
11:05:47 <SamB_XP> conal: but we aren't losing the heirarchical names
11:05:55 <xinming> byorgey: what does "function application" mean please?
11:06:02 <conal> doserj: me too.  taking taxonomy as a given for now, it's the only logical choice i see.
11:06:05 <SamB_XP> and we aren't including all that other stuff in the concept of names
11:06:23 <conal> skew: plus tags & links
11:06:32 <oerjan> fasta: what error message do you get?
11:06:49 <skew> conal: and all that lives in the docs and in hackage and in pragmas at the module declaration and so on
11:06:50 <byorgey> xinming: giving a vale as an argument to a function.  In this case, runReader is a function being applied to m.
11:06:54 <conal> SamB_XP: i don't know what you mean by "we aren't"?  statement?  prediction? ...
11:07:03 <SamB_XP> conal: go ahead and hack up a way to tag/link modules using hackage and/or haddock
11:07:09 <conal> skew: exactly
11:07:17 <doserj> conal: one could settle on the convention: top-level names describe the purpose of the module (like Network, Graphics, etc), and for general purpose things one has the Data.* and the Class.* hierarchy
11:07:21 <SamB_XP> conal: like "you can pry it from our cold dead hands"
11:07:25 <skew> conal: I don't see how to profitably change what you type after "import"
11:07:39 <fasta> oerjan: Ambiguous type variable `a' in the constraint:  `Read a' arising from a use of `dot_files'
11:07:41 <conal> SamB_XP: i really don't understand your reaction.  what's the threat?
11:08:29 <SamB_XP> now, you might be able to convince us to rename a lot of stuff, but some of it we really will want those heirarchical names for
11:08:36 <conal> SamB_XP: no one is going to take away something useful without providing something better.
11:08:58 <fasta> oerjan: do you see anything ambiguous?
11:09:10 <SamB_XP> these tags/links/categories aren't unambiguously better in this case
11:09:32 <SamB_XP> think of it like this:
11:09:40 <conal> is anyone getting the impression that i'm trying to force something on people?  how could i have made it clear that i'm doing research?
11:09:43 <SamB_XP> what if you tried to take away the dash from Debian package names?
11:09:58 <skew> conal: I don't understand why you seem to cast this as a module naming question, rather than suggestions for hackage and haddock and so on
11:10:04 <conal> SamB_XP: non-ambiguity is easy.  use PackageName.WhateverYouWant.MoreIfThatRingsYourBell.
11:10:30 <sclv_> instead of a messy string representation, each module should be uniquely identified by a GUID!
11:10:32 <conal> skew: what suggestion are you referring to?
11:10:37 <fasta> oerjan: the type of both the if branches is Int, the only way that can happen is if the Read instance Int is selected.
11:10:38 <oerjan> fasta: loaded in hugs, removed a couple missing things and get no error
11:10:38 <conal> sclv_: strawman?
11:10:46 <SamB_XP> I'm just saying, though those dots may not be good for all the things we use them for at the moment, they are still damn useful...
11:10:52 <skew> conal: all this talk about breaking up control, or maybe things should go somewhere else
11:11:04 <fasta> oerjan: ok, then GHC has a bug.
11:11:04 <conal> SamB_XP: for disambuation?  anything else?
11:11:16 <SamB_XP> conal: not just disambiguation
11:11:21 <SamB_XP> exactly
11:11:32 <conal> SamB_XP: also descriptiveness?
11:11:32 <sclv_> conal: don't mind me, just playing around.
11:11:35 <SamB_XP> well. I guess it's sort of like disambiguation...
11:11:55 <skew> conal: for instance, capturing the commonality between all the weird categorical things that live under Control that you seem to want to dismiss with the useless label "Class"
11:12:28 <SamB_XP> I was thinking more along the lines of "these things are all part of the same component"
11:12:28 <skew> conal: talking about changing the name of something implies you thing the old name should go away
11:12:33 <conal> skew: actually, i want to capture it more effectively while capturing other relationships as well.
11:12:45 <oerjan> fasta: what i removed was filter filled $ and replacing (file =~ "^([[:digit:]]+).dot$") by undefined
11:12:51 <conal> skew: i don't mind a transition period.
11:12:53 <dcoutts_> conal: hmm, but the problem is once we've found our library we still need an unambiguous url to it, though that url does not need to encode the category any more.
11:12:58 <skew> conal: where as most of the other stuff you say sounds like adding a bunch of tagging and other organization
11:12:59 <SamB_XP> conal: you can't capture a name more effectively!
11:13:08 <conal> dcoutts_: exactly!
11:13:41 <dcoutts_> conal: and we need to make hoogle work better, that should be the primary interface rather than the hackage/haddock contents/index
11:13:51 <conal> SamB_XP: more clearly: actually, i want to capture *that commonality* more effectively while capturing other relationships as well.
11:14:31 <skew> conal: A module needs some kind of identifier. If people are typing them in they should be short and memorable
11:14:32 <conal> dcoutts_: exactly.  hoogle and other rich tools.  don't try to make naming also suffice for description.
11:14:41 <conal> skew: agreed.
11:14:44 <SamB_XP> conal: well, the logical way to try this would be to come up with mechanisms that you could use with what we already have...
11:14:44 <skew> conal: all that argues against trying to encode any of this rich stuff into module names
11:14:57 <conal> skew: agreed.  which i wasn't suggesting.
11:15:03 <sclv_> haha i just finished that shirkey article. it turns out that maybe it wasn't such a strawman.
11:15:12 <conal> SamB_XP: "the" logical way?  the one & only?
11:15:25 <skew> conal: so asking people about renaming modules is rather misleading
11:15:29 <SamB_XP> conal: well, okay, it might not be the only one
11:15:38 <skew> conal: you should ask something like "how else should we categorize these things"
11:15:44 <conal> skew: i meant that question as well.
11:15:48 <skew> conal: or "what crossreferences would be useful"
11:15:48 <SamB_XP> conal: but it's better than suggesting wholesale renames
11:16:02 <conal> skew: that wasn't the question i started with.  then someone asked me my answers.
11:16:32 <skew> conal: I think the current organization generally corresponds to good categorys
11:16:42 <conal> skew: i believe that you do
11:16:50 <skew> conal: you seem to mostly want to also reflect other good organizations
11:17:09 <conal> skew: while at the same time, i see inconsistencies
11:17:20 <SamB_XP> conal: yeah?
11:17:27 <conal> skew: all possible useful organizations.
11:17:55 <skew> conal: arguing that another specific organization is sufficiently better to bother changing the current canonical unique these modules seems quite beside your point
11:18:05 * Philippa_ doesn't have any problem with Control as a name anyway
11:18:25 <conal> skew: good thing i wasn't arguing that
11:18:27 <Philippa_> so long as your notion of "control flow" allows for more than one valid path it works fairly well IMO
11:18:41 <conal> skew: what did i say that you interpreted that way?
11:18:53 <SamB_XP> conal: you should attempt to argue more clearly about stuff like this
11:19:04 <SamB_XP> in order to avoid putting people on the defensive
11:19:06 <skew> conal: oh, anything about changing names, anything complaining that the current hierarchy is too rigid, or wrong in places.
11:19:08 <Philippa_> imperative programming is just a particular (degenerate?) case thereof
11:19:35 <skew> conal: I don't even think the module names per-se are actually what you are talking about.
11:20:05 <SamB_XP> conal: it would be a lot more clear if you hadn't mentioned the idea of changing module names
11:20:16 <skew> conal: and it would be a lot clearer and I think just as accurate if you were talking in terms of improved documentation and search and labelling tools
11:20:38 <conal> SamB_XP: i think i was asked.
11:21:17 <SamB_XP> anyway, changes to hackage, haddock, and hoogle seem like a pretty good idea
11:21:47 <SamB_XP> together with some brainstorming about what sort of tags/categories you were thinking of
11:22:19 <SamB_XP> er.
11:22:32 <SamB_XP> s/you were thinking of/would be good/
11:23:24 <mauke> I wrote the beginnings of an IO tutorial: http://mauke.ath.cx/stuff/haskell/how-to-io.html
11:23:25 <lambdabot> Title: Haskell: How To IO
11:23:44 <conal> SamB_XP & skew: you two both seem to have objections to something about my part of this conversation.  i'd like to understand what.  are you saying that if i have some additional thoughts on a larger question (hierarchy vs heterarchy in this case), you'd like some kind of head's up?
11:23:49 <skew> conal: anyway, it's all uninterpreted bytestrings at the level of the code.
11:24:15 <SamB_XP> conal: I think this whole vs. thing is beside the point
11:24:29 <conal> vs?
11:24:43 <SamB_XP> both seems good to me...
11:25:17 <conal> SamB_XP: got it.  still, i'd like to know if i'm on the road to understanding your objection.
11:25:32 <conal> SamB_XP: to my part in the conversation.
11:25:50 <jimstutt> in the gap
11:26:02 <jimstutt> hacking: operating a machine with little brain
11:26:15 <SamB_XP> well. it sounded like you wanted to change a bunch of names.
11:26:24 <SamB_XP> possibly slaughter the .
11:26:25 <jimstutt> design: dunno but it's probably something to do with the left adjoint
11:26:32 <skew> conal: and it sounds like you should hardly care about the names
11:27:07 <SamB_XP> whereas it's probably a lot more productive to add this taggy stuff
11:28:25 <conal> SamB_XP: and also, when i started asking about "Control", would you have liked to know that i have doubts about taxonomy in general?
11:28:37 <Philippa_> conal: when you're unclear about what you're getting at, people will consider and respond to all the possibilities they can think of
11:28:45 <SamB_XP> since about the only resistance you would encounter there would be the implementation effort + release cycle
11:28:46 <Philippa_> if you'd intended the conversation to go that way it would've been a good thing
11:28:49 <Philippa_> hi Graham
11:28:57 <grahamhutton> hi philippa!
11:28:57 <conal> skew: and maybe you didn't get any indication that i was considering what's important to you about the names?
11:28:59 <SamB_XP> conal: well, you made it clear that you had doubts about taxonamy
11:29:28 <SamB_XP> conal: this may be why it sounded like you might be wanting to get rid of .
11:29:46 <conal> Philippa_: thanks.  and what if i hadn't intended the conversation to go any particular way?  what if i was answering a question that someone else brought up?
11:30:20 <Philippa_> then sometimes it's helpful to indicate things you definitely don't want to discuss - for example, renaming chunks of the existing hierarchy
11:30:26 <conal> SamB_XP: i see.  you thought that eliminating taxonomy means eliminating ".".
11:30:37 <SamB_XP> or things you at aren't proposing, at any rate...
11:30:47 <SamB_XP> er. s/at //
11:31:21 <conal> Philippa_: it's also kind of nice to go with the flow of the conversation.  i didn't mind that some others asked questions off the topic i first asked about.
11:31:25 <conal> after all, i'm going for data, not for control. ;)
11:31:58 <SamB_XP> hahahaha
11:32:34 <conal> SamB_XP: do you what i said that you heard as a proposal?
11:32:49 <SamB_XP> eh?
11:32:58 <skew> conal: I still don't understand why you think module names have any relevence to representing multiple views or organizing modules without hierarchy
11:32:58 <SamB_XP> you have an extra/missing word there
11:34:04 <skew> conal: the web is the canonical example of free organzation, and even there pages are named by unique hierarchial urls.
11:34:09 <conal> SamB_XP: were you interpreting my part in the conversation as making a proposal?  if so, what?
11:34:29 <SamB_XP> conal: well... it sure sounded like you wanted to do something
11:34:49 <conal> skew: do you mean why relate module names to taxonomy?
11:35:37 <SamB_XP> and you seemed to think that the heirarchy was worthless, and that it should be replaced with a tagarchy
11:35:46 <byorgey> mauke++
11:35:46 <Philippa_> SamB: that, and it was taking a long time for someone to propose a non-silly (given the existing state of affairs) course of action
11:35:48 <conal> SamB_XP: thanks.  i certainly want to do something.  but just learning, in this conversation.
11:36:10 <byorgey> mauke: that's great.  I wish that tutorial had existed when I was learning about IO!
11:36:12 <SamB_XP> well, you can seriously propose something in the "just learning" stage
11:36:28 <mauke> byorgey: thanks! :-)
11:36:30 <conal> Philippa_: only if you believe your interpretation that i had an agenda to make a proposal.
11:37:01 <skew> conal: relate module names to taxonomy, sure, but you need another layer of organization to do anything about it
11:37:21 <byorgey> mauke: in particular, it took me a long time to finally understand the whole "a value of type IO a is an action which, when run, does xyz."
11:37:40 <Philippa_> conal: no, at that point it doesn't depend on the someone being you at all. Even if it's just a hypothetical "in another language..." type proposal
11:37:45 <SamB_XP> anyway... I have this to say: tags are a cool idea and I think someone should figure out how to work them into hackage/hoogle/haddock
11:38:04 <byorgey> mauke: once I figured out to think about it in terms of "composing actions into larger actions" instead of actually executing statements, it all fell into place.
11:38:05 <conal> SamB_XP: me too!  :)
11:38:13 <mauke> yeah
11:38:17 <SamB_XP> just keep your hands of my dots
11:38:20 <SamB_XP> ;-)
11:38:29 <conal> SamB_XP: :)
11:38:57 <byorgey> mauke: and I've explained IO to a few others, and that perspective really helped them, too.
11:39:04 <dmwit> eeeeheeeehehehe
11:39:10 <dmwit> I like today's \cat.
11:39:15 <Philippa_> incidentally, I forget if we heard conal's preferred name for Control.*, assuming one has to be picked?
11:39:36 <conal> i don't understand your comment about "taking a long time for someone to propose a non-silly (given the existing state of affairs) course of action".  do you mean that you want all #haskell conversations to be toward proposals?
11:40:04 <Philippa_> no. I mean that in some discussions (and this would be one) people tend to be itching for something concrete to knock around
11:40:19 <SamB_XP> and preferably avoid fairly pointless renames to other not-too-great names
11:40:23 <conal> Philippa_: got it. thanks.
11:40:30 <conal> SamB_XP: me too!
11:40:33 <Philippa_> and in the absence of someone actually making a proposal they'll generate a few likely ones from the conversation so far
11:41:09 <Philippa_> it's often a good idea to kill the silly ones off as "not what any of us are suggesting" fast
11:41:16 <SamB_XP> because renaming is a lot of work for things people use a lot, and is only worth the trouble if the new name is a good deal better
11:41:41 <Philippa_> yep. For a mildly generalised value of Control, Control.* at least works
11:41:43 <conal> SamB_XP: it sure is!
11:41:44 <dmwit> How about just knocking off the "Control."?
11:41:55 <SamB_XP> dmwit: that's still a rename
11:41:59 <dmwit> yes
11:42:00 <skew> and the name is mostly just there to be something you can remember and type in, even more so if you build some nice tagging for finding modules in the first place
11:42:14 <SamB_XP> nevermind that that's what the Haskell 98 module is called
11:42:29 <conal> skew: once you have searching & tagging, then "Monad" is enough, isn't it?
11:42:31 <dmwit> Oh, right, it's already possible to do that.
11:43:13 <SamB_XP> we still have a module or two with no . in the name, I think...
11:43:18 <skew> conal: probably for monad. For CoolNewProgram.Utilities?
11:43:20 <SamB_XP> (besides Prelude ;-)
11:43:24 * Philippa_ does find it mildly irritating having to import Control.ST and Data.STRef separately though
11:43:26 <oerjan> SamB_XP: Numeric iirc
11:43:27 <dmwit> As a fairly minor point, Monad.State would be nicer than Control.Monad.State.  Hardly worth a rename, though.
11:43:40 <SamB_XP> do we still have a System?
11:43:56 <conal> skew: which use: importing or browsing/searching?
11:44:07 <conal> add seeing relationships to the latter
11:44:16 <skew> conal: for not colliding with ConolsOldProgram.Utilities
11:44:20 <fasta> I'd rather see things to import :)
11:44:25 <conal> skew: okay, for import.
11:44:30 <oerjan> SamB_XP: no
11:44:38 <conal> then packagename.Utilities
11:44:48 <SamB_XP> do we have a Foreign?
11:44:54 <conal> we already have the requirement of unique package names
11:45:27 <oerjan> hm, seems so
11:45:46 <oerjan> it's not in the haskell98 package
11:45:52 <oerjan> but in base
11:46:11 <SamB_XP> conal: yeah, I wouldn't mind that. though I'd want to be able to somehow specify that a different package be used instead...
11:46:29 <SamB_XP> oerjan: I didn't say that they were from Haskell 98
11:46:37 <conal> SamB_XP: differentpackage.Utilities ?
11:46:49 <conal> SamB_XP: i'm probably missing your meaning.
11:46:54 <oerjan> SamB_XP: the doc page now lists all the h98 compatibility modules in the haskell98 package
11:46:54 <SamB_XP> conal: without changing the haskell code
11:47:10 <oerjan> so i assume you wanted to exclude those
11:47:14 <conal> SamB_XP: oh!  which is awkward without parameterized modules.
11:47:17 <skew> conal: I think I get it - you seem to talk about module names because that's what you see now, but I don't think it matterns
11:47:20 <conal> can you do that now?
11:47:25 <conal> SamB_XP: can you do that now?
11:47:40 <skew> conal: And if you build up new and better tagging infrastructure the importance of names goes away on it's own
11:47:43 <oerjan> (i.e. System is listed under that package)
11:47:46 <SamB_XP> conal: right now we can just tell ghc to use a different package on the commandline
11:47:50 <SamB_XP> or in the cabal file
11:47:58 <conal> skew: thanks!  that's it.  :)
11:48:04 <SamB_XP> which happens to export modules of the same name
11:48:16 <SamB_XP> er, names
11:48:23 <skew> conal: and on the other hand trying to rip out the old systems before they are vestigial is just a distaster
11:48:25 <oerjan> oh right, Foreign never was in H98
11:48:28 <conal> SamB_XP: okay.  and that works if i don't want to use pieces of both packages.
11:48:54 <SamB_XP> conal: well... I'm talking about drop-in replacements
11:48:55 <conal> skew: i totally agree.  and maybe people assumed that i wanted to, and hence some of the reaction.  does that fit?
11:49:22 <conal> SamB_XP: i get it now.  to simulate ML parameterized modules.
11:49:34 <skew> conal: you seem to talk an awful lot about module names, and elimiating hierarchy
11:49:36 <SamB_XP> conal: I'm not sure that's the right way to put it
11:49:38 <conal> SamB_XP: i hadn't thought of that use.  thanks.
11:49:56 <conal> skew: and?
11:50:03 <skew> conal: there would be no confusion if you talked about adding tagging and cross-referencing and new organization possibilities
11:50:11 <conal> SamB_XP: what's not the right way?  parameterized modules?
11:50:29 <SamB_XP> but I think you've got basically gist of why I'd want to do it...
11:50:47 <conal> skew: thanks for that data point.  i wonder if it'd be clearer for you and murkier for some others.
11:51:18 <SamB_XP> conal: how could coming right out and stating your intent make things murkier?
11:51:53 <conal> SamB_XP: didn't i?  i wanted to know how people understood "Control"?  and i answered some questions.
11:51:56 <Philippa_> SamB: "my intent is to just kick stuff around for a while" isn't going to clarify much, no?
11:52:04 <SamB_XP> hmm.
11:52:26 <Philippa_> conal: you'll find a lot of haskellers use generalised notions that they can't quite state clearly, that makes "how do you understand...?" tricky sometimes
11:52:28 <conal> SamB_XP: would you have also liked to know that i also have some doubts about the whole taxonomy paradigm?
11:52:41 <SamB_XP> conal: I gathered that already
11:52:48 <SamB_XP> several times
11:52:56 <conal> SamB_XP: and yet something was missing for you?
11:53:01 <Philippa_> I'm pretty sure the only objection you'd have to my description is that it sounds like imperative terminology?
11:53:18 <Philippa_> What you'd want to do with those doubts, I imagine
11:53:36 <conal> Philippa_: e.g., answer questions?
11:54:06 <conal> Philippa_: maybe you'd rather i refused to answer questions if they weren't on track with my original question?
11:54:12 <Philippa_> separating that from the module naming early on would probably have saved some grief - there are good reasons beyond the historical why filesystems tend to stay with hierarchical names for at least 'canonical' naming
11:54:28 <Philippa_> conal: I was filling in Sam's blank there, that's all
11:54:38 <conal> Philippa_: in hindsight, if i could have predicted people's questions & reactions
11:54:50 <skew> conal: seeing as I think you are only proposing to add external mechanisms, and perhaps hope the current taxonomy atropies for a while, it would be clearer to say so
11:55:19 <conal> skew: in retrospect, yes.
11:55:23 <Philippa_> conal: I probably could have predicted it - it's probably easiest if I explain how and why in PM?
11:56:08 <conal> Philippa_: if you prefer
11:56:09 <Philippa_> (we've got multiple threads of conversation trying to cross over in here, they're strangling each other somewhat)
11:56:56 <SamB_XP> conal: yeah, if you are asking questions that imply that you are thinking about doing something Haskell, it's a good idea to actually go on to say what things you were thinking of doing -- and what things you most certainly aren't thinking of doing, if anyone seems to get the wrong idea
11:57:30 <SamB_XP> s/Haskell/to Haskell/
11:58:21 <conal> anyway, thanks for all the feedback.  i learned that some folks really want up-front reassurance that they'll get to use the old mechanism while possible new ones are being added and evolved.
11:59:40 <skew> conal: that's still not quite right.
11:59:57 <conal> skew: great.  go on, please.
11:59:58 <SamB_XP> conal: why the "while"
12:00:28 <conal> SamB_XP: i see.
12:00:50 <conal> SamB_XP: there'd still be worry about whether the old mechanism would be available indefinitely.
12:01:08 <SamB_XP> conal: well... I can't say I'm worried exactly...
12:01:37 <skew> conal: when a mechanism does a critical job well and an important job poorly we want reassurances that the critical job will be taken care of if somebody starts talking about *replacing* it to do a better job at the important thing
12:01:44 <SamB_XP> but I might be if your name were Guido
12:02:06 <SamB_XP> conal: yeah, that's pretty much it
12:02:12 <byorgey> conal: people are worried by change, period.  =)
12:02:39 <Philippa_> skew: talking of replacing was kinda something people saw in the shadows - I think it's fair to say that sometimes conal's discussion style's slightly odd by most people's standards (as mine has often been as well)
12:02:40 <SamB_XP> well, personally I'm worried about thinking too far ahead
12:03:32 <conal> skew: people want to know that their criticial concerns will be covered.  and you didn't get that.  is that it?
12:04:10 <byorgey> conal: perhaps that's part of why some (me included) initially assumed that your innocuous query had deeper intentions/proposals/etc. behind it, because of a visceral emotional reaction to the possibility (even imagined) of Change.
12:04:41 <Philippa_> a lot of people use a similar style of conversation to start proposing things, too
12:04:46 <Philippa_> which probably didn't help
12:04:54 <hpaste>  mightybyte pasted "Adding randomization" at http://hpaste.org/4291
12:05:12 <atomicphr> evening all - mind if i ask for some coding help?
12:05:20 <mightybyte> Anyone have some suggestions about how to add randomization in the code that I just hpasted?
12:05:21 <byorgey> also true.  "what do people think about X?  ... because I was thinking Y."  is a common (if annoying) pattern.
12:05:40 <byorgey> atomicphr: not at all, ask away! =)
12:05:45 <Taejo> @src IOMode
12:05:45 <lambdabot> data IOMode = ReadMode | WriteMode | AppendMode | ReadWriteMode
12:06:17 <Philippa_> byorgey: that, and the conversation also included this - 1. Problem with existing system 2. Deeper underlying problem 3. Alternative approach that avoids it
12:06:22 <conal> i *do* have the intention to recommend a huge change w.r.t taxonomy & haskell.  and i'm looking for help in understanding all of the issues/concerns, so as to make sure that a proposal would handle all concerns at least as well as the current system.
12:06:28 <Philippa_> which is often followed by 4. Proposal using alternative approach
12:06:44 <SamB_XP> conal: we'd like to keep the current system mostly
12:06:47 <SamB_XP> thanks
12:07:00 <Philippa_> conal: did my comment about canonical names make sense, or would you like me to expand on it?
12:07:16 <atomicphr> byorgey: thanks :) my problem is this. i need to take two lists of lists of Bools, and return a list of lists, where each Bool element is the (||) of the input lists
12:07:19 <conal> SamB_XP: i know that.  and what' helpful to me is to hear why.  so i can offer something that even you will prefer.
12:07:29 <skew> conal: something like that, more pointing out that the thing you are talking about serves other purposes
12:07:35 <SamB_XP> conal: I'd prefer to keep what I've got
12:07:40 <conal> Philippa_: which comment?
12:07:51 <conal> SamB_XP: I know that.  People almost always do.
12:07:55 <Philippa_> conal: that a hierarchical namespace is desirable in order to maintain them
12:08:02 <SamB_XP> you shouldn't bundle together orthogonal things like tags and this thing where you take away what we have
12:08:08 <atomicphr> for example, [[True,False],[True]] and [[False,True],[True]] would return [[True,True],[True]]
12:08:23 <byorgey> > zipWith (zipWith (||)) [[True,True],[False,False]] [[True,False],[True,False]]
12:08:25 <lambdabot>  [[True,True],[True,False]]
12:08:29 <SamB_XP> because your tagging idea is GREAT
12:08:30 <byorgey> how about that? =)
12:08:39 <SamB_XP> but doesn't require you to take anything away
12:08:52 <Philippa_> SamB_XP: until you spot the canonical naming issue they don't appear to be orthogonal at all
12:09:09 <SamB_XP> Philippa_: well, I mean, from an implementation standpoint
12:09:09 <Philippa_> especially as tags are only really the start - tags themselves tend to end up getting organised in the long run too
12:09:11 <conal> SamB_XP: i agree that it doesn't.  i bundle them in my mind because i like orthogonality.
12:09:16 <skew> and taking things away hierarchial names doesn't advance tagging and general better organization
12:09:23 <atomicphr> byorgey: so the general idea is to use two zipWiths? (i'm just getting into haskell - i like to understand what i'm using :) )
12:09:46 <Philippa_> SamB_XP: even implementationally they're not orthogonal if you start using an alternative system for module names in the language itself
12:09:48 <SamB_XP> Philippa_: since adding tags won't disturb any existing code
12:09:57 <byorgey> atomicphr: zipWith takes a function and two lists, and "zips" the list together into one new list by applying the function to each pair of corresponding items.
12:10:15 <byorgey> atomicphr: so if you have a list of lists, you want to zip with... a zipWith.
12:10:30 <Cale> :t zipWith . zipWith
12:10:30 <lambdabot> forall a b c. (a -> b -> c) -> [[a]] -> [[b]] -> [[c]]
12:10:31 <conal> for the record: i imagine (a) adding folksonomy (social tagging, linking, searching) to hierarchy, then (b) exploring how little of hierarchy we still want, and then (c) maybe dropping hierarchy, if as a community it's clear that it has no remaining value.
12:11:01 <conal> are people still worried?
12:11:02 <atomicphr> byorgey: i see :) many thanks for that indeed! will give it a play now
12:11:08 * Cale is a hierarchy person :)
12:11:29 <Philippa_> conal: I'm pretty sure people will want to retain hierarchy both to conserve/extend namespace and make it easier to remember what something is when you read an import statement
12:11:29 <SamB> conal: only when you talk about things that are "better" than heirarchical naming
12:11:31 <conal> Cale: most people in modern cultures are.
12:11:47 <conal> Philippa_: maybe so.
12:11:58 <skew> conal: that is a sensible proposal. You were saying things about being opposed to taxonomy and module names and so on, and little about the positive efforts like adding tags.
12:12:11 <SamB> conal: just remember that you should propose each thing seperately ;-)
12:12:17 <doserj> conal: the unclear thing is, where do you want to add tagging? on the language level, or on the infrastructure level?
12:12:20 <conal> SamB: sure. because you hear the either or, before you get a chance to say you want both.
12:12:55 <Philippa_> and that'd be because you say "thing bad" rather than "thing not good for specific purpose"
12:13:09 <Toxaris> mightybyte: about your planets & fleets: you have to get some source of randomness in there
12:13:20 <mightybyte> Toxaris: I'd like to.
12:13:32 <conal> doserj: there are lots of possibilities.  i like shirkey's reasons for decentralizing tagging, i.e., putting *outside* of the content.  then we have social tagging -- very fertile for emergent relationships.
12:13:41 <skew> Philippa_: also to have canonical names to communicate with.
12:13:58 <doserj> conal: then I'm not worried :)
12:14:06 <Toxaris> mightybyte: randomness in Haskell is normally traded around as (1) RandomGen values, (2) infinite lists of random values or (3) access to IO
12:14:08 <mightybyte> And I'm still trying to get a feel for how to separate the purely functional aspects of my application from the non-functional ones.
12:14:19 <SamB> conal: I think tags should be allowed both inside and outside
12:14:28 <Philippa_> skew: that too, yeah. Knowing when you're talking about the same module or not...
12:14:31 <conal> SamB: i'll remember that when i make a proposal.  i still don't like the idea of refusing to answer questions.
12:14:40 <conal> SamB: i have no problem with that.
12:14:50 <conal> SamB: (i.e., with in & out)
12:14:52 <skew> conal: when you say taxonomy bad, hierarchial names bad, nobody needs an implied either-or to think you mean to take something away
12:14:56 <Toxaris> mightybyte: so the obvious solution would be to monadify all your code and either use a State-monad to access a RandomGen or use IO directly to produce random numbers.
12:15:05 <Philippa_> conal: you don't have to refuse to add them, but sometimes adding extra info ("this isn't what I'm aiming at", say) is a good idea
12:15:05 <bos> @seen glguy
12:15:05 <lambdabot> glguy is in #haskell. I don't know when glguy last spoke.
12:15:24 <conal> skew: where did i say "taxonomy bad, hierarchical names bad"?
12:15:43 <mightybyte> Toxaris: So would those core functions that I have have to be put into a monad or is there a nice way to separate the two?
12:16:03 <Philippa_> conal: you expressed strong doubts about them. You may just have been bitten by the tendency to academic restraint
12:16:05 <conal> Philippa_: thanks.  maybe would have helped.
12:16:06 <SamB> conal: well... where didn't you?
12:16:41 <Philippa_> SamB: that's not reasonable, the burden on showing he didn't on each and every line is rather higher than that of digging up one where he did
12:16:41 <skew> conal: "11:28:25 <conal> ... i have doubts about taxonomy in general"
12:16:53 <mightybyte> Toxaris: I thought that making contestFunc an argument to doAttack might be a step in the right direction.
12:16:58 <conal> SamB: i know you interpreted much of what i said in that way. i'm also trying to find out what it was i said that helped.
12:17:02 <Toxaris> mightybyte: you could try to put as few as possible functions into a monad, and lifting the other, pure functions as needed (using liftM<n> or the Applicative operators)
12:17:08 <conal> skew: go on
12:17:15 <SamB> Philippa_: do I have to be reasonable on every line?
12:17:29 <Toxaris> mightybyte: but I have another idea: what about giving every entity in the game (planets, fleets, ...) a source of randomness (when it is created)?
12:17:45 <mightybyte> Toxaris: Ok, that sounds promising.
12:17:56 <Philippa_> SamB: given that conal's genuinely confused rather than trolling, it'd be a better idea to
12:18:01 <Toxaris> mightybyte: hmm yes you could hide your source of randomness in contestFunc, too, interesting idea
12:18:32 <mightybyte> Toxaris: I was thinking the randomness could be passed in inside contestFunc by main
12:18:43 <mightybyte> Toxaris: But I'm not quite seeing how to do it.
12:18:47 <Taejo> @instances Fractional
12:18:47 <SamB> hmm. a good troll would be nice about now ;-)
12:18:48 <lambdabot> Double, Float
12:18:48 <Toxaris> mightybyte: the question is: is it ok to reuse the same random bits for multiple decisions, e.g. for all decisions regarding an entity (my idea), or for all decisions during one tick (your idea)
12:19:11 <Taejo> why can't I use (^^) on ints?
12:19:23 <Toxaris> mightybyte: I assume you are writing a planetarion clone
12:19:30 <byorgey> @type (^^)
12:19:31 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
12:19:32 <SamB> Taejo: well, what is 2^(-1)
12:19:35 <conal> i know that we humans are very creative in our interpretations, i.e., in filling in the blanks.  that's why i like to distinguish between observations & interpretations.  so i can consciously reconsider the latter.
12:19:45 <mightybyte> Toxaris: Actually, it's supposed to be a clone of Konquest.
12:19:51 <byorgey> Taejo: Ints aren't Fractional.
12:20:18 <Taejo> SamB: thank you, forgot about negatives
12:20:26 <skew> I think more of it was when you were talking before
12:20:29 <mightybyte> Toxaris: I think you would want to just grab values from one single source of randomness.
12:20:30 <SamB> Taejo: that's the only point of ^^
12:20:30 <mauke> > 2^(-1)
12:20:31 <lambdabot>  Exception: Prelude.^: negative exponent
12:20:34 <SamB> it works on negatives
12:20:35 <conal> creative interpretation is an incredibly valuable skill.  as is noticing and questioning.  a phrase i like to remind myself of is "don't believe everything you think".
12:20:43 <Olathe> > demonstrate foldr
12:20:43 <lambdabot>  "fold (+) 0 [1..5] = (1 + (2 + (3 + (4 + (5 + 0)))))"
12:20:50 <Olathe> > demonstrate foldl
12:20:51 <lambdabot>  "fold (+) 0 [1..5] = (((((0 + 1) + 2) + 3) + 4) + 5)"
12:20:54 <Olathe> > demonstrate foldb
12:20:55 <lambdabot>  "fold (+) 0 [1..5] = (0 + (((1 + 2) + (3 + 4)) + 5))"
12:21:05 <byorgey> wha...?
12:21:08 <Taejo> SamB: I didn't know about (^), thanks
12:21:08 <mightybyte> Toxaris: That would ensure the statistical independance of the random values over the course of the game.
12:21:28 <mauke> > demonstrate 2
12:21:29 <lambdabot>        add an instance declaration for
12:21:29 <lambdabot>       (Num (([Char] -> [Char] -> [Char...
12:21:34 <mauke> haha
12:21:39 <Olathe> Needs a fold.
12:21:45 <Toxaris> mightybyte: that would be the "thread a RandomGen through" approach
12:21:51 <byorgey> > demonstrate foldl'
12:21:51 <lambdabot>  "fold (+) 0 [1..5] = (((((0 + 1) + 2) + 3) + 4) + 5)"
12:22:23 <byorgey> heh, neat
12:22:42 <Lilly> I'm a hot woman want to be fucked twice a day pm me 32 years
12:23:08 --- mode: ChanServ set +o Philippa_
12:23:18 --- mode: Philippa_ set +b *!*@209.217.118.34
12:23:22 --- kick: Lilly was kicked by Philippa_ (Philippa_)
12:23:27 <mightybyte> Toxaris: My problem was getting the doAttack calls to sequence properly.
12:23:33 --- mode: Philippa_ set -o Philippa_
12:23:37 * byorgey cheers Philippa_ 
12:23:47 <Nafai> byorgey: demonstrate, that's nice!
12:24:06 <Philippa_> now someone PM Lilly "32 years"?
12:24:07 <mightybyte> Toxaris: I tried putting a do block in the otherwise clause, but I couldn't get it to compile.
12:24:13 <byorgey> Nafai: indeed.  I wish I could say I had anything to do with it!
12:24:21 <SamB> hahaha
12:24:47 <mauke> Philippa_: already done
12:24:57 <SamB> > domonstrate foldl
12:24:58 <lambdabot>   Not in scope: `domonstrate'
12:25:02 <SamB> > demonstrate foldl
12:25:03 <lambdabot>  "fold (+) 0 [1..5] = (((((0 + 1) + 2) + 3) + 4) + 5)"
12:25:07 <Toxaris> mightybyte: you have to decide wich monad you want and change the type, then change the code to work with that monad
12:25:38 <SamB> oh, someone just did that huh.
12:25:47 <SamB> > demonstrate map
12:25:48 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
12:25:55 <vininim> >d demonstrate liftM_
12:26:00 <vininim> > demonstrate liftM_
12:26:00 <lambdabot>   Not in scope: `liftM_'
12:26:03 <SamB> lame lame
12:26:04 <mightybyte> Toxaris: Hmmm, I guess I'm not sure how to do that.
12:26:17 <Toxaris> mightybyte: for the RandomGen-threading aproach, doAtack becomes doAtack :: ... -> State RandomGen Planet
12:26:17 <byorgey> only works on folds, go figure. ;-)
12:27:48 <mightybyte> Toxaris: Ok.  Would it be better to do that or pass it an infinite list of random numbers?
12:29:01 <byorgey> @src foldl
12:29:01 <lambdabot> foldl f z xs = lgo z xs
12:29:01 <lambdabot>     where lgo z []     =  z
12:29:01 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
12:29:09 <Toxaris> mightybyte: the problem would be how to make sure that every number is exactly used once
12:29:23 <Toxaris> mightybyte: (if you care, what you seem to do)
12:29:40 <Saizan> there's a MonadSupply on the wiki
12:29:57 <mauke> @djinn ([Char] -> [Char] -> [Char]) -> [Char] -> [[Char]] -> [Char]
12:29:57 <lambdabot> f a b _ = a b b
12:29:58 <Toxaris> mightybyte: so you would have to return the unused part of the random list to be used in the next fight, wich means that the two aproaches are in fact equivalent.
12:30:09 <byorgey> @let folda = foldar where foldar f z [] = z; foldar f z (x:xs) = x `f` (foldal f z xs); foldal f z [] = z; foldal f z (x:xs) = foldar f (f z x) xs
12:30:15 <lambdabot> Defined.
12:30:17 <mauke> @. pl djinn ([Char] -> [Char] -> [Char]) -> [Char] -> [[Char]] -> [Char]
12:30:17 <lambdabot> f = (const .) . join
12:30:22 <byorgey> > demonstrate folda
12:30:23 <lambdabot>  "fold (+) 0 [1..5] = (1 + (3 + (5 + ((0 + 2) + 4))))"
12:30:33 <mauke> > demonstrate ((const .) . join)
12:30:33 <lambdabot>  "fold (+) 0 [1..5] = (0 + 0)"
12:30:36 <mightybyte> Toxaris: ...since that's what the RandomGen approach is doing.
12:30:41 <Olathe> mauke: Heheh
12:31:12 <Olathe> > ((const .) . join) (+) 0 [1..5]
12:31:12 <lambdabot>  0
12:31:18 <byorgey> @let folda = foldar where foldar f z [] = z; foldar f z (x:xs) = x `f` (foldal f z xs); foldal f z [] = z; foldal f z (x:xs) = foldar f (f x z) xs
12:31:19 <lambdabot> <local>:15:0:     Multiple declarations of `L.folda'     Declared at: <local>...
12:31:26 <vininim> > demonstrate filter
12:31:26 <lambdabot>  Couldn't match expected type `[Char] -> [Char]'
12:31:34 <byorgey> @let folda' = foldar where foldar f z [] = z; foldar f z (x:xs) = x `f` (foldal f z xs); foldal f z [] = z; foldal f z (x:xs) = foldar f (f x z) xs
12:31:36 <lambdabot> Defined.
12:31:40 <byorgey> > demonstrate folda'
12:31:41 <lambdabot>  "fold (+) 0 [1..5] = (1 + (3 + (5 + (4 + (2 + 0)))))"
12:31:49 <byorgey> hm, nevermind =)
12:31:52 <Olathe> How would you make a demonstrate that could tell the type of a function ?
12:31:55 <Taejo> why can't array out of bounds exceptions in ghc say "1 out of bounds in array with bounds (100, 200)" instead of just "out of bounds"
12:31:56 <Taejo> ?
12:32:20 <Taejo> or rather "Error in array index"
12:32:26 <mauke> because ghc hates you
12:32:29 <mightybyte> Toxaris: I guess doing it this way will still restrict the monadic portions to just those functions directly involved in time-of-gameplay activity.
12:32:39 <Olathe> Taejo: Make a wrapper for it.
12:32:44 <Taejo> mauke: just checking :)
12:32:52 <Taejo> Olathe: for what?
12:33:10 <Olathe> So that, if it gets the error, it can replace the message.
12:33:43 <Taejo> Olathe: I didn't mean "for what purpose", but "wrapper for what". I don't know what to wrap.
12:34:34 <hpaste>  (anonymous) annotated "query a collection by type" with "(no title)" at http://hpaste.org/4288#a2
12:35:22 <Olathe> Oh, for the functions or for the whole of Array.
12:36:51 <Toxaris> mightybyte: yes, more or less :)
12:36:51 <byorgey> you could call it ArrayWithErrorMessagesThatDontSuck.
12:36:51 <Taejo> @index unsafePerformIO
12:36:51 <lambdabot> System.IO.Unsafe, Foreign
12:37:13 <Olathe> You could do import ArrayWithErrorMessagesThatDontSuck when debugging and just switch that one line when you publish.
12:41:56 <Toxaris> mightybyte: I would probably ignore possible statistics-related fairness problems and go for the every entity carries a source of randomness aproach. that would result in pure functions and a deterministic game engine (no more save - try - load - retry cheats, because the result of the random fights is already determined by the state of the various random number generators in the entities)
12:42:39 <Toxaris> mightybyte: or i would just go for deterministic fights, but that would be a different game ...
12:45:37 <ClaudiusMaximus> I'm thinking of writing a translator from Haskell 'proc' notation for arrows to the Faust language for DSP, has this been done yet?  So far I've got in a mess with GADTs and -fno-implicit-prelude, because the type of 'arr' isn't what I want it to be - I'm wondering if there's a module I can use to parse 'proc' notation into an AST directly?
12:45:58 <lQg> if i have two lists, but not necessarily of the same length, how do i make a new list with every element in the first list recombined with every element in the second list
12:46:46 <Toxaris> > (,) <$> "abcd" <*> [1..3] -- lQg like this?
12:46:48 <lambdabot>  [('a',1),('a',2),('a',3),('b',1),('b',2),('b',3),('c',1),('c',2),('c',3),('d...
12:47:14 <Toxaris> > liftM2 (,) "abcd" [1..3] -- lQg equivalent to this
12:47:15 <lQg> that looks pretty good
12:47:15 <lambdabot>  [('a',1),('a',2),('a',3),('b',1),('b',2),('b',3),('c',1),('c',2),('c',3),('d...
12:47:39 <quicksilver> > [(a,b) | a <- "abcd", b<-[1..3]] -- or, in list comprehension style
12:47:40 <lambdabot>  [('a',1),('a',2),('a',3),('b',1),('b',2),('b',3),('c',1),('c',2),('c',3),('d...
12:47:41 <Toxaris> > [(a, b) | a <- "abcd", b <- [1..3]] -- lQg and this
12:47:41 <lambdabot>  [('a',1),('a',2),('a',3),('b',1),('b',2),('b',3),('c',1),('c',2),('c',3),('d...
12:48:02 <lQg> what if i need them to be lists instead of tuples? same type are strings
12:48:20 <Toxaris> lQg: use a different function instead of (,)
12:48:44 <Toxaris> lQg: (,) :: a -> b -> (a, b), you would need foo :: a -> a -> [a]
12:48:46 <mightybyte> Toxaris: I guess I could start with deterministic fights to get something working.
12:48:52 <lQg>  > liftM2 : [4..6] [1..3]
12:49:05 <lQg>  > liftM2 [] [4..6] [1..3]
12:49:10 <lQg> hmmm
12:49:18 <MyCatVerbs> @hoogle Int -> [a] -> ([a],[a])
12:49:18 <lambdabot> Prelude.splitAt :: Int -> [a] -> ([a], [a])
12:49:33 <Toxaris> lQg: you have a space to much to let lambdabot realize you want her to do something.
12:49:54 <mightybyte> Toxaris: If every entry carries a source of randomness, isn't that essentially the same as every entity using the global random number generator?
12:49:57 <lQg> > liftM2 : [4..6] [1..3]
12:49:57 <lambdabot>  Couldn't match expected type `t
12:50:02 <lQg> > liftM2 [] [4..6] [1..3]
12:50:02 <lambdabot>  Couldn't match expected type `a1 -> a2 -> r'
12:50:20 <MyCatVerbs> > liftM2 (:) [4..6] [1..3]
12:50:20 <lambdabot>   add an instance declaration for (Num [a1])
12:50:20 <lambdabot>     In the expression: 3
12:50:24 <lQg> > :t liftM2
12:50:25 <lambdabot>   parse error on input `:'
12:50:36 <MyCatVerbs> lQg: omit the > when using @type
12:50:48 <Toxaris> mightybyte: I don't know. depends on how these sources are created, I assume. are they independent from each other?
12:50:55 <mauke> > liftM2 (\x y -> [x, y]) [4 .. 6] [1 .. 3]
12:50:55 <lambdabot>  [[4,1],[4,2],[4,3],[5,1],[5,2],[5,3],[6,1],[6,2],[6,3]]
12:51:29 <Toxaris> mightybyte: but I don't know enough about pseudorandom numbers to discuss this. for a game: just ignore it, who cares
12:51:43 <mightybyte> Toxaris: Ideally they would all just use the same source.  How is that different from each of them having their own source?  It seems like it's just a special case.
12:51:54 <mightybyte> Toxaris: True.
12:52:03 <lQg> nice
12:52:51 <mightybyte> Toxaris: Even if the numbers aren't independant, it would be unlikely anyone would actually exploit it.
12:53:00 <mauke> :t (. return) . (:)
12:53:03 <lambdabot> forall a. a -> a -> [a]
12:53:19 <joelr1> bringert: knock-knock
12:54:12 <Toxaris> mightybyte: yes, think so, too.
12:55:24 <mightybyte> Toxaris: So doAttacks needs to return State RandomGen Planet?
13:00:25 <lQg> what if i have a non-deterministic amount of lists that need to be recombined?
13:00:35 <lQg> so could be two or five or tweleve
13:01:15 <lQg> currently i have
13:01:27 <lQg> merge [] == []
13:01:28 <lQg> merge (x:xs) = liftM2 (\x y -> [x, y]) (x) (merge xs)
13:01:54 <lQg> where merge :: [[String]] -> [String] but i don't think that really works
13:02:20 <dmwit> :t concat
13:02:22 <lambdabot> forall a. [[a]] -> [a]
13:02:43 <dmwit> Also, in the future:
13:02:50 <dmwit> ?hoogle [[String]] -> [String]
13:02:51 <lambdabot> No matches, try a more general search
13:02:52 <lQg> > concat ["a","3","4"]
13:02:56 <lambdabot>  "a34"
13:02:59 <dmwit> ?hoogle [[a]] -> [a]
13:03:00 <lambdabot> Prelude.concat :: [[a]] -> [a]
13:03:21 <lQg> > concat [["a","3"],"4"]
13:03:22 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
13:03:28 <jimstutt> conal: Did you come across John Sowa's comments about the IEEE SUO?
13:03:40 <lQg> > concat [["a","3"],["4"]]
13:03:41 <lambdabot>  ["a","3","4"]
13:03:46 <jimstutt> conal: about 8yrs of fail to agree iirc
13:04:47 <lQg> > concat [["a","3"],["4","5"]]
13:04:47 <lambdabot>  ["a","3","4","5"]
13:04:53 <lQg> lol
13:05:02 <dmwit> lQg: To fix your above definition, you want:
13:05:12 <dmwit> merge (x:xs) = x : merge xs
13:05:18 <dmwit> sorry
13:05:25 <dmwit> merge (x:xs) = x ++ merge xs
13:05:44 <dmwit> :t \(x:xs) -> x ++ merge xs -- did I get it right this time?
13:05:45 <lambdabot> Not in scope: `merge'
13:05:59 <dmwit> :t let merge (x:xs) = x ++ merge xs in merge
13:05:59 <lambdabot> forall a. [[a]] -> [a]
13:06:20 <lQg> well every x is a [String] that needs to be recombined with every [String] of xs
13:06:27 <dmwit> :t foldr (++) []
13:06:27 <lambdabot> forall a. [[a]] -> [a]
13:06:30 <glen_quagmire> f g a; in haskell, it's evaluated as (f g) a;   if there's a language that evaluates this as f (g a);, given f, g are functions, is the language lazy evaluation?
13:06:44 <lQg> and a 0 needs to actually also be added at the end of every one
13:06:56 <lQg> every recombined string
13:07:03 <dmwit> lQg: What should be the result of 'merge ["a", "b", "c"]' in your problem domain?
13:07:05 <lQg> but i was thinking could do that in another function
13:07:21 <dmwit> Yes, appending a '0' should come later.
13:07:45 <dmwit> glen_quagmire: Bind order and laziness are orthogonal.
13:07:52 <pejo> glen_quagmire, you're kind of mixing concepts here.
13:08:09 <lQg> merge [["a"],["b"],["c"]] should be "a b c"
13:08:31 <dmwit> glen_quagmire: You can always change the order of a bind by inserting appropriate parentheses, but you can't change a strict language into a lazy one easily.
13:08:34 <glen_quagmire> dmwit: does that mean they are not related?
13:08:37 <lQg> merge [["a"],["b","d"],["c"]] should be ["a b c","a d c"]
13:08:40 <dmwit> glen_quagmire: yes
13:09:05 <dmwit> lQg: aha!
13:09:15 <glen_quagmire> dmwit: is it easy to change lazy language into strict one?
13:09:30 <dmwit> > sequence [["a"], ["b", "d"], ["c"]]
13:09:32 <lambdabot>  [["a","b","c"],["a","d","c"]]
13:09:38 <dmwit> lQg: Does that help?
13:09:47 <lQg> yep
13:09:54 <dmwit> glen_quagmire: Well, not really.  You need language support.  But Haskell has it. ;-)
13:09:59 <lQg> thanks :D
13:10:24 * glen_quagmire reads up wiki pedoa
13:10:30 <glen_quagmire> wikipedia
13:10:39 <glguy> @seen bos
13:10:39 <lambdabot> bos is in #haskell and #ghc. I last heard bos speak 55m 34s ago.
13:12:04 <glguy> bos, I'll be around for a while
13:12:37 <bos> yo
13:12:59 <glguy> (were you lookin gfor me)
13:13:43 <bos> glguy: your code is cute!
13:14:12 <glguy> ^_^
13:17:11 <glguy> bos, where did you come upon that puzzle?
13:17:51 <bos> glguy: using the power of my own mind!
13:18:26 <bos> glguy: the checkDigit function is the EAN-13 barcode checksum validation routine
13:18:51 <glguy> looks quite similar to the credit card checksum
13:18:54 <Taejo> Note to self: don't go out without logging out of root on a production machine
13:19:31 <dmwit> Yay, what pranks got pulled?
13:19:47 <Taejo> none, fortunately
13:20:40 <glguy> that you *know* of
13:20:42 <conal> jimstutt: no, i missed that. pointer?
13:20:56 <glguy> system compromised! reformat
13:21:41 <Taejo> glguy: my mom has very little interest in h4x0ring the computer olympiad
13:22:19 <dmwit> Shows what you know.
13:22:25 <dmwit> The most successful hackers are never discovered.
13:22:47 <jimstutt> conal: http://suo.ieee.org/
13:22:48 <lambdabot> Title: Standard Upper Ontology Working Group (SUO WG) - Home Page
13:23:07 <conal> jimstutt: thx
13:23:11 <Taejo> she has nothing to gain: neither she nor her son qualify for a medal
13:24:17 <Taejo> 1,3,4,7,6,12,8,15,13,18,12,28,14,24,31,18,...?
13:24:46 <conal> jimstutt: and the 8 yrs part?
13:26:33 <dmwit> ?oeis 1 3 4 7 6 12 8 15 13 18 12 28 14 24 31 18
13:26:33 <lambdabot> Plugin `oeis' failed with: Prelude.init: empty list
13:28:14 <Olathe> http://www.research.att.com/~njas/sequences/?q=+1+3+4+7+6+12+8+15+13+18+12+28+14+24+31+18
13:28:15 <lambdabot> Title: The On-Line Encyclopedia of Integer Sequences, http://tinyurl.com/2kwaot
13:28:15 <conal> jimstutt: i like shirky's comment "I want to argue that even the ontological _ideal_ is a mistake."  (see context.)
13:28:55 <conal> http://www.shirky.com/writings/ontology_overrated.html#what_is_ontology
13:28:56 <lambdabot> Title: Shirky: Ontology is Overrated -- Categories, Links, and Tags, http://tinyurl.com/7z8lz
13:29:47 <dmwit> Taejo: Where did that question come from, out of curiosity?
13:31:56 <Taejo> dmwit: a friend of mine puts an integer sequence in his gtalk status every few days, until someone finds what it is (of course, oeis is cheating, but I'd given up)
13:33:12 <vininim> his sequence gives a strange oeis
13:33:20 <vininim> blank result, not even "not found"
13:33:44 <Taejo> vininim: I get http://www.research.att.com/~njas/sequences/A000203
13:33:44 <lambdabot> Title: The On-Line Encyclopedia of Integer Sequences
13:34:39 <vininim> , 3, 4, 7, 6, 12, 8, 15, 13, 18, 12, 28, 14, 24, 24, 31, 18
13:34:45 <vininim> not
13:34:54 <vininim> , 3, 4, 7, 6, 12, 8, 15, 13, 18, 12, 28, 14, 24, 31, 18
13:34:58 <Taejo> oh, looks like he left out a 24
13:35:30 <Taejo> or maybe it's a different sequence (he said it had something to do with reversi, but I thought he was kidding)
13:36:06 <dmwit> Taejo: Look farther on the page of results.
13:36:49 <dmwit> Wait, never mind.
13:37:24 <Taejo> if you're refering to A069192, then that's not it
13:37:40 <dmwit> Taejo: I was looking at A090128, but that's not it either.
13:37:41 <dmwit> =P
13:44:19 <hpaste>  (anonymous) annotated "nicer?" with "(no title)" at http://hpaste.org/4267#a1
13:47:21 <norgul> Don't know if ths is the right place, but I'm about to install Xmonad on my ubuntu now
13:47:38 <allbery_b> #xmonad might be more interest{ed,ing}
13:47:46 <norgul> thanks
13:53:26 * SamB wonders what conal thinks of debtags
13:55:10 <conal> SamB: what are they?
13:55:29 <SamB> http://debtags.alioth.debian.org/
13:55:29 <lambdabot> Title: Debian Package Tags
13:58:07 <conal> SamB: it's *multiple* tagging, i'm for it! :)
14:03:16 <Toxaris> mightybyte: still around?
14:05:54 <SamB> conal: I really like the idea of facets
14:06:24 <hpaste>  mightybyte annotated "Adding randomization" with "possible approach" at http://hpaste.org/4291#a1
14:06:51 <mightybyte> Toxaris: Yeah
14:07:09 <mightybyte> Toxaris: Just hpasted an idea
14:07:50 <roconnor> dons: any word on a sweedish hackathon?
14:08:26 <Toxaris> mightybyte: well, to your last question: yes. but IO is also possible.
14:08:41 <daniel_larsson> meatballs included?
14:09:45 <mightybyte> Toxaris: I'm not sure how to do it the State RandomGen way, but this IO method was fairly straightforward.
14:10:05 <jimstutt> conal: he bemoaned what I now think was 11 years effort. He said it on the SUO mailing list so some search needed.
14:10:31 <Toxaris> mightybyte: you can keep it the IO way for now, since you can switch monads quite easily (you only have to change randRoll)
14:10:45 <conal> jimstutt: was the effort to reach agreement on an ontology?
14:10:46 <Toxaris> mightybyte: or are you interested in some sample code showing it the State RandomGen way?
14:10:52 <jimstutt> conal/l didn't get round to buying his book Formal Philosophy
14:10:54 <mightybyte> Toxaris: Ok, excellent.
14:11:09 <jimstutt> conal: yes
14:11:11 <mightybyte> Toxaris: Sure, I'm doing this to learn haskell. :)
14:11:36 <jimstutt> conal: but I agree strongly with his views over the years
14:11:39 <conal> jimstutt: i think that's because it's an inherently doomed task.
14:12:16 <jimstutt> conal: for a perspectivist isn't it all updatable, multi-user views :)?
14:12:38 <quicksilver> Toxaris,mightybyte: even better, MonadRandom
14:12:45 <mightybyte> Toxaris: I was afraid I'd have to change contestFunc and doAttack if I wanted to change approaches.
14:12:59 <quicksilver> then it's polymorphic over IO, StateT RandomGen, or any other monad providing RNG facilities
14:13:00 <mightybyte> I guess that's the beauty of type inferrence.
14:13:08 <jimstutt> conal: Sowa suggests working on useful stuff in the middle and ignoring to top tautologies and bottom absurd set.
14:13:24 <mightybyte> quicksilver: Ahh, what would that involve?
14:14:06 <jimstutt> conal: the Information Flow Framework seems about as rigorous as anybody has bome up with so far. But I err often.
14:14:32 <jimstutt> conal: /bome/come/
14:14:47 <Toxaris> mightybyte: yes, and the beauty of monads: once you have written in monadic style, you can add and change capabilities relatively easily
14:15:00 <conal> jimstutt: do you know the goal of the 11 year effort? i mean why they cared?
14:15:18 <Toxaris> mightybyte: but quicksilver's MonadRandom sounds like being one step ahead
14:15:27 <Toxaris> mightybyte: so ignore me :)
14:15:43 <jimstutt> conal: Praps Boeing were prepared to pay to sort out their library? ie. forget.
14:16:34 <dons> roconnor: initial page is up on the haskell wiki
14:16:35 <mightybyte> Toxaris: Yeah, I'm starting to see that.  I thought monadic code would essentially tie me to an approach, but since contestFunc and doAttack only use the do structure, I can see that it's really the monad concept that's providing nice generalization.
14:16:39 <jimstutt> conal: anyway I'm +1 for bottom up bayesian classification of folksonomy tags
14:17:02 <conal> jimstutt: :)
14:17:16 <jimstutt> conal: back to (>>>)
14:18:47 <joelr1> @seen bringert
14:18:47 <lambdabot> bringert is in #ghc and #haskell. I don't know when bringert last spoke.
14:20:07 <conal> jimstutt: have fun
14:20:43 <quicksilver> Toxaris: MonadRandom is a type-class which abstracts over different monads offering randomness features
14:21:03 <quicksilver> mightybyte: hmm, and you too :)
14:21:06 <quicksilver> it's not in the standard libs
14:21:08 <quicksilver> but it's here:
14:21:09 <quicksilver> http://www.haskell.org/haskellwiki/New_monads/MonadRandom
14:21:09 <lambdabot> Title: New monads/MonadRandom - HaskellWiki
14:22:08 <Toxaris> quicksilver: I actually figured it from the name MonadRandom :) are there more libraries hiding in the wiki?
14:23:29 <Toxaris> quicksilver: ok, browsing through it shows that this is indeed the case. i wasn't aware of that
14:26:02 <Toxaris> mightybyte: if I understand that correctly, you could simply copy the code from the wiki into your program, and use getRandom in IO for now. later, you can refine IO to a more specialized monad wich also supports the MonadRandom interface
14:27:19 <davidL> Why does this happen "/home/foo/executable: runInteractiveProcess: does not exist (No such file or directory)"? The file clearly exists.
14:30:12 <daniel_larsson> davidL: execute bit set?
14:30:30 <davidL> daniel_larsson: yes, 755
14:30:45 <daniel_larsson> Or, if it's a script, what about the file that's refered to by the #! line?
14:31:16 <davidL> "#! /bin/bash"
14:32:14 <daniel_larsson> And I guess you can execute it by typing "/home/foo/executable"?
14:32:28 <pheaver> wouldn't happen to be in cygwin or anything, would you?
14:32:41 <davidL> nope, debian 4
14:33:09 <pheaver> and can you open it within haskell using openFile or something?
14:33:38 <davidL> actually just running it produces, "Null", that is odd
14:33:48 <pheaver> ?
14:33:55 <dmwit> Can we see the code you're using?
14:34:01 <dmwit> (The Haskell bit.)
14:37:10 <hpaste>  davidL pasted "runInteractiveProcess, file not found?" at http://hpaste.org/4292
14:39:22 <allbery_b> the first argument has to be the path to the program
14:39:42 <davidL> it is, binary = "/home/math/runmath"
14:39:54 <allbery_b> no, the list
14:40:04 <allbery_b> [src] shuld be [binary, src]
14:40:13 <allbery_b> argv[0] on unix is the program
14:40:33 <allbery_b> so you're invoking runmath with no "real" arguments
14:41:33 <dmwit> Also, it needs to be Nothing, not (Just "").
14:42:22 <davidL> allbery_b: uh I am confused, I thought the first argument should be a FilePath
14:42:43 <dmwit> runInteractiveProcess binary [binary, source] ... -- allbery_b's suggestion
14:42:59 <allbery_b> yes
14:43:11 <dmwit> Are you sure about that?
14:43:17 <allbery_b> and dmwit is right about the current directory; POSIX forbids the empty path
14:43:34 <allbery_b> about what?
14:43:49 <dmwit> That you need to explicitly pass the first argument to runInteractiveProcess?
14:44:08 <davidL> so it doesn't just take the first argument, and execute it with the arguments from the second argument?
14:44:21 <allbery_b> not absolutely certain
14:44:32 <allbery_b> it does look rather like it's using execv() which would require that
14:45:28 <allbery_b> but it's possible the implementation of runInterctiveProcess does that automatically (which would reduce its usability on Unix since sometimes you want to change argv[0], e.g. to force behavior of a shell)
14:46:25 <allbery_b> (execl("/path/to/shell", "-shell", ...) tells shellsto run as login shells, for example)
14:47:02 <dmwit> (i, o, e, p) <- runInteractiveProcess "/home/daniel/echo.sh" [] Nothing Nothing -- succeeds
14:47:34 <davidL> hmm
14:48:02 <allbery_b> the real question is, if you invoke an echoer with arguments, what does it think $1 is?
14:48:09 <dmwit> Right, I'll check.
14:48:17 <allbery_b> I think only older Linux outright breaks if you omit argv[0] completely
14:48:56 <allbery_b> (a.out-format programs used that for ldd behavior)
14:48:59 <davidL> ah well changing (Just "") to Nothing makes the file path error go away but I'm not sure if the correct args are being passed
14:50:02 <dmwit> hmmm...
14:50:16 <dmwit> Prelude System.Process IO> (i, o, e, p) <- runInteractiveProcess "/home/daniel/echo.sh" ["hey", "there"] Nothing Nothing
14:50:16 <dmwit> Prelude System.Process IO> hGetContents o
14:50:16 <dmwit> ""
14:50:51 <davidL> :-(
14:54:21 <allbery_b> ok, my quick test in ghci says it doesn't need an argv[0]
14:54:36 <newsham> dec 5, 2007 and ghci still doesnt support freebsd/amd64 :(
14:54:44 <allbery_b> that's sad, what if I need to change argv[0]?
14:54:53 <Olathe> Down with freebsd/amd64 !
14:55:04 * Olathe chants !
14:55:34 <dmwit> allbery_b: What did I do wrong?
14:55:41 <dmwit> (Mine doesn't even see argv[1].)
14:56:18 <newsham> > fix ghci
14:56:19 <lambdabot>   Not in scope: `ghci'
14:56:24 <hpaste>  allbery_b pasted "runInteractiveProcess test" at http://hpaste.org/4293
14:56:25 <idnar> heh
14:56:52 <dmwit> Ah, I didn't waitForProcess.
15:02:44 <davidL> everything works now, thanks all
15:08:31 <chessguy> so it seems to me that pattern-matching on a complex data structure is rather an inflexible way of writing a function
15:08:54 <chessguy> because if you need to change the data structure, you have to change the pattern-matching in all the places you do so
15:09:00 <chessguy> or am i missing something?
15:09:06 <Saizan> that's true
15:09:16 <Toxaris> chessguy: are you aware of record syntax in patterns? it sometimes helps
15:09:28 <chessguy> Toxaris, i'm not
15:10:11 <Saizan> if you've a "complex structure" with welldefined semantics you might write a small internal api for that and avoid direct pattern matching
15:11:09 <hpaste>  Toxaris pasted "entities carry their randomness around" at http://hpaste.org/4294
15:11:26 <Toxaris> mightybyte: ^^^ my aproach
15:11:50 <chessguy> oh, i thought for a minute that was for me :)
15:12:57 <chessguy> Toxaris, can you give me an idea what record syntax for patterns looks like?
15:13:05 <Toxaris> chessguy: already typing
15:13:09 <chessguy> oh, sorry
15:16:33 <Toxaris> ahhh xchat has stolen my clipboard
15:16:45 <chessguy> naughty xchat
15:17:17 <Toxaris> or rather uedit is not able to copy anymore...
15:17:27 <chessguy> uedit?
15:17:54 <Toxaris> http://en.wikipedia.org/wiki/UltraEdit
15:17:54 <lambdabot> Title: UltraEdit - Wikipedia, the free encyclopedia
15:18:48 <hpaste>  Toxaris pasted "finally: record syntax in patterns" at http://hpaste.org/4295
15:18:55 <chessguy> you could do worse, i suppose
15:19:58 <chessguy> hmm
15:20:13 <chessguy> i assume that's H98?
15:20:25 <Toxaris> I have no idea
15:20:55 <Toxaris> well, ghc accepts it without any flags, if that says anything
15:20:57 * chessguy tries it
15:21:17 <chessguy> looks good
15:21:30 <chessguy> is that exhaustive then? the last case covers everything?
15:21:54 <Toxaris> it's like pattern matching
15:22:10 <chessguy> nice
15:22:58 <hpaste>  Toxaris annotated "finally: record syntax in patterns" with "translation" at http://hpaste.org/4295#a1
15:23:49 <Toxaris> in this case, it's exhaustive, because every value is matched by either Alternative{} or Record{b = b}
15:23:59 <chessguy> yes
15:24:36 <chessguy> that is indeed handy
15:25:39 <chessguy> but it adds to my suspicion that record syntax is superior for data definitions if the data structure is complex
15:26:01 <Toxaris> "complex"?
15:26:14 <Toxaris> record syntax is for unstructured data
15:26:35 <Toxaris> if you have some sensible structure, you can use existing typeclasses / higher order functions / apis
15:26:38 <chessguy> by complex, i just mean more than, say, 2 or 3 fields
15:27:07 <Toxaris> like Functor, Foldable, ...
15:27:25 <chessguy> i don't see how they would help
15:27:42 <Toxaris> by structured, i mean, involves lists, trees, ...
15:29:42 <Toxaris> consider data Ex = Ex [[Maybe [Ex]]]
15:30:04 <Toxaris> this is rather complex, but you need no pattern matching to handle it, since you can use existing library functions for [] and Maybe
15:30:40 <Toxaris> but consider data Ex = Ex Int Int Int Int Int Int Int Int Int Float Int
15:30:53 <Toxaris> this is not complex at all, but rather boring. but you have to handle it with pattern matching (or record syntax)
15:30:59 <chessguy> i was thinking more about objects like data Foo = Foo Int String (Int, Int) DataType
15:31:11 <dibblego> Toxaris, is that standard H98?
15:31:25 <Toxaris> dibblego: what?
15:31:28 <chessguy> Toxaris, yes, the latter is more what i was thinking of
15:31:34 <dibblego> Toxaris, that kind of pattern matching
15:31:44 <chessguy> dibblego, you mean in his paste?
15:31:47 <dibblego> yes
15:31:55 <chessguy> it works for me without an y flags
15:32:01 <Toxaris> dibblego: it's standard record syntax. i don't know if record syntax is standard h98
15:32:07 <allbery_b> it is
15:32:12 <dibblego> ok cheers
15:32:47 <allbery_b> and I don't think there re any significant extensions in GHC, because record syntax extensions are a major bikeshed
15:33:06 <allbery_b> (Hugs has an implementation of an alternative record syntax IIRC)
15:36:16 <allbery_b> in particular H98 guarantees that R a b x and R {foo: a; bar: b; baz: x} are the same, so you can try out record syntax without having to rewrite everything
15:36:38 <ddarius> R { foo = a, bar = b, baz = x }
15:36:40 <allbery_b> (ultimately you should, though, since mixing them is confusing to human readers of the program)
15:36:43 <allbery_b> yeh
15:36:44 <LoganCapaldo> s/:/=? right?
15:37:01 <allbery_b> actually I was doing the declaration
15:37:08 <allbery_b> so I think both : and ; are right
15:37:16 <Toxaris> allbery_b: R { foo :: a; ...
15:37:21 <allbery_b> (a, b, x type variables)
15:37:22 <ddarius> allbery_b: That's not valid syntax at all.
15:37:26 <allbery_b> durrr
15:37:28 <LoganCapaldo> R { foo :: a. ///
15:37:32 <LoganCapaldo> arg
15:37:38 <allbery_b> yeh, double colon at least
15:37:43 <LoganCapaldo> s/./,/ s/////...
15:37:50 <LoganCapaldo> I typo extreme today
15:37:58 <Toxaris> lambdabot should process declarations
15:38:06 <ddarius> Toxaris: Add it.
15:38:09 <LoganCapaldo> people keep saying that
15:43:46 <Toxaris> I consider implementing some graph algorithms in Haskell i'm supposed to learn in a lecture about -surprise- graph algorithms. is there some generally agreed upon interface for graphs?
15:44:42 <ddarius> Not really.
15:44:46 <Toxaris> I'm only aware of graph libraries wich come with their own datastructure, but not of a data-structure independent aproach (wich i would like)
15:45:41 <chessguy> you mean like a Graph class?
15:45:46 <Toxaris> exactly
15:46:13 <Toxaris> class Graph g v e | g -> v e where outgoing :: g -> v -> [e]; ...
15:46:41 <Toxaris> or what do i know...
15:46:42 <chessguy> hm,
15:47:08 <kfish> interesting
15:47:13 * kfish is playing with fgl atm
15:49:38 <kfish> hi fishey
15:50:16 <hpaste>  Toxaris pasted "graph stuff so far" at http://hpaste.org/4296
15:52:41 <kfish> Toxaris, i think the motivation behind the different graph libraries is to allow the implementation of algorithms to have desired properties (more efficient, more easily provable etc.)
15:53:45 <kfish> Toxaris, so in that sense, it might not make sense to implement dfs/bfs in terms of node and edge lists
15:54:04 <kfish> but perhaps class methods for bfs/dfs etc. might be useful?
15:54:50 <Toxaris> kfish: are there any other implementations for bfs/dfs?
15:54:51 <chessguy> Toxaris, ha! check your -cafe mail
15:55:55 <kfish> Toxaris, eg. Data.Graph is based on http://citeseer.ist.psu.edu/36266.html , which is all about lazy depth-first search
15:55:55 <lambdabot> Title: Lazy Depth-First Search and Linear Graph Algorithms in Haskell - King, Launchbur ...
15:56:41 <chessguy> oh wait
15:57:24 <Toxaris> chessguy: not exactly related, but quite interesting, too
15:57:25 <chessguy> hmm, apparently you actually need fno-mono-pat-binds for that record syntax based pattern-matching
15:57:41 <chessguy> Toxaris, yeah, i just saw the title and lauged
15:58:17 <chessguy> oh, never mind, i'm crazy
15:59:57 <Toxaris> kfish: I've cross-read that paper before and had the impression that it basically deals with the idea to implement dfs :: Graph -> [Node] using some ST-magic and then build upon this [Node]
16:00:16 <Toxaris> kfish: but instead of [Node], they use some Tree or Forest to preserve more structure
16:04:30 <kfish> Toxaris, well, yes, but i think the point is that that structuring is where the efficiency comes from
16:04:50 <kfish> they can walk the spanning forest in preorder for dfs, or postorder for topological sorting
16:05:50 <Toxaris> hmm, yes, they can apply well-known algos for trees
16:08:53 <kfish> the structuring they use preserves the relationships that are interesting; that the algorithms for walking that structure are well-known merely makes the implementation simpler ;-)
16:10:07 <Toxaris> hmm yes, that seems to be the point. they remove the "problem" about graphs (the circularity) without removing the information they want
16:10:15 <kfish> -- if i had coffee, i'd say "illuminates" instead of "preserves", but i've banned myself from coffee this week :-(
16:10:32 <kfish> Toxaris, yeah
16:10:41 <Toxaris> so maybe i should read that paper more carefully and consider building upon their framework
16:11:07 <Toxaris> (possible problem: there will be not much left from the treatment of graphs we learn in the lecture)
16:11:33 <Toxaris> (possible benefit: maybe the results will be actually usable by someone)
16:11:42 <kfish> heh :-)
16:14:58 <Toxaris> but i still think that a class Graph would be a good thing. uniplate goes in that direction (but doesn't offer support for handling circularity, afaik)
16:21:55 <SamB> Toxaris: can't!
16:22:12 <Toxaris> SamB: ?
16:22:31 <SamB> offer support for handling circularity
16:23:51 <Toxaris> SamB: would be out of scope I assume. what would you need? a function identity :: Uniplate a -> UniqueValue as part of the Uniplate class and some efficient   Set UniqueValue
16:24:32 <Toxaris> identity :: Uniplate a => a -> UniqueValue
16:24:51 <hpaste>  anton annotated "query a collection by type" with "further generics" at http://hpaste.org/4288#a3
16:42:42 <hpaste>  chessguy pasted "This apparently doesn't work. Is there an easy way to do something similar?" at http://hpaste.org/4297
16:43:35 <ddarius> chessguy: Use one of the various functional references approaches.
16:43:47 <chessguy> meh, i was afraid you were going to say that.
16:43:55 <chessguy> i'd like to be a bit more lightweight about it
16:44:25 <chessguy> i guess i can do edit 'x' val foo = ...
16:46:48 <chessguy> but in my actual case it's 4 cases, and i hate repeating myself that much
16:47:14 <nburlett> has anyone here tried accessing a Microsoft SQLSever database from haskell?
16:47:21 <LoganCapaldo> use the preprocessor? or template haskell?
16:47:43 <Toxaris> chessguy: or an array?
16:49:03 <chessguy> preprocessor?
16:49:52 <LoganCapaldo> you know, that #define nonsense :)
16:50:22 <chessguy> ...
16:50:25 <chessguy> in haskell?
16:50:30 <Niat> good morning!
16:50:36 <chessguy> hi Niat
16:50:42 <chessguy> @users
16:50:42 <lambdabot> Maximum users seen in #haskell: 420, currently: 395 (94.0%), active: 8 (2.0%)
16:51:00 <LoganCapaldo> sure, generating code is generating code, right?
16:51:16 <mightybyte> chessguy: If I understand your code right, you're basically trying to do reflection in that hpaste, right?
16:51:38 <chessguy> someone check LoganCapaldo's medication, he's babbling again
16:51:50 <chessguy> mightybyte, mm, not really reflection
16:52:21 <LoganCapaldo> well you said you didn't want to repeat yoursef, one way to do that is to write a macro to write the repetive code for you
16:52:23 <mightybyte> chessguy Hmm, then what would you call it?
16:52:31 <chessguy> mightybyte, more like, specifying a field at runtime
16:52:53 <Toxaris> i would call it "first class fields"
16:52:56 <Niat> ehm... i don't really know whether i should be asking this here or better in #xmonad, but to me it seems more haskell-related: why do i get a "Setup.hs:16:18: Not in scope: `buildHook'" when trying to configure X11 bindings before build?
16:53:00 <chessguy> Toxaris, yes
16:53:08 <mightybyte> chessguy Yeah, me (a Java programmer most recently) thinks that is called reflection in some languages.
16:53:11 <chessguy> Function References are the right way to do it
16:53:22 <chessguy> s/ion/ional/
16:53:40 <chessguy> i just don't particularly want to be bothered with them
16:53:50 <mightybyte> Yeah
16:54:06 <Toxaris> I agree with mightybyte, but in Haskell, we speak about making things first class, not reflect upon them
16:54:12 <daniel_larsson> Niat: you didn't import the module defining "buildHook"
16:54:29 <mightybyte> Toxaris Ok, that's good to know.
16:54:42 <chessguy> mightybyte, reflection is more about being able to see what fields exist on an object than specifying fields dynamically
16:54:46 <Niat> well, i didn't know i was supposed to. i just executed "runhaskell Setup.lhs configure --prefix=$HOME"
16:55:12 <Toxaris> chessguy: but FieldName -> FieldReference is a typical reflection operation
16:55:13 <mightybyte> chessguy Hmmm, I always considered it to be both "read" and "write"
16:55:18 <LoganCapaldo> Niat: your cabal is probaly older or newer than the cabal that Setup.hs was done with
16:55:26 <Niat> as you might guess, haskell is totally knew to me.
16:55:35 <Niat> oke, i'll try to get a new one.
16:55:49 <chessguy> anyway, we're just tinkering with terminology now
16:55:54 <mightybyte> chessguy Could be just my exposure to the term.
16:56:04 <lemmayoshi> hmm
16:56:05 <chessguy> likewise
16:56:06 <lemmayoshi> I wonder
16:56:18 <mightybyte> Although it's good to know the haskell language for it.
16:56:26 <lemmayoshi> DCC SEND "FSDFSDFFSDSDFSDDFdfsdfdfssdffsdsdfsdfSDFSDFSDsorry"
16:56:28 <Ganondorf> IM IN DAWG
16:56:29 <lemmayoshi> ok
16:56:30 <lemmayoshi> Bye.
16:56:32 <LoganCapaldo> I don't think reflection and first class are the same thing, I think in this particular case you could use either to get where you want to go, but the route you'd take would be different
16:56:46 <chessguy> i think of reflection as stuff like DataType -> [Field]
16:56:51 <Ganondorf> you all are late
16:57:07 <Ganondorf> ah well
16:57:08 <Ganondorf> DCC SEND "FSDFSDFFSDSDFSDDFdfsdfdfssdffsdsdfsdfSDFSDFSDsorry"
16:57:17 <chessguy> or hasField :: Field -> DataType -> Bool
16:57:30 <mightybyte> Yeah, I can see what you're saying.
16:57:48 <mightybyte> You view it more as a method of discovery rather than a method of access.
16:57:53 <Toxaris> chessguy: I would say: if you want to exploit the fact, that your data is structured (it's all Int's), you should structure it and use an [Int] or a Array FieldName Int or Map FieldName Int
16:58:16 <Toxaris> chessguy: on the other hand you could just accept to write 4 lines of boilerplate and go on :)
16:58:34 <chessguy> mightybyte, yes, because the access part is generally just like it is anywhere else, so it's not really part of the reflection (to me)
16:58:50 <mightybyte> Yeah
16:58:58 <chessguy> Toxaris, agreed. i tend to make things too complicated for some reason
16:59:31 <mightybyte> chessguy I particularly think of instantiating Java classes from a string like "com.foo.bar.MyClass"
16:59:40 <HairyDude> is it at all possible to use an instance in a module but not export it?
17:00:07 <chessguy> well, that's certainly dynamic, but i wouldn't call it reflection
17:00:11 <LoganCapaldo> HairyDude: maybe if the class is also confined to that module and you don't export the class?
17:00:28 <HairyDude> LoganCapaldo: unfortunately I'm talking about Eq and Ord
17:00:33 <mightybyte> Toxaris Yeah, I like the map approach too, but I can kind of see the use of chessguy's approach in a domain like web frameworks where easy, clean DSLs are desireable.
17:00:50 <LoganCapaldo> HairyDude: you coudl define the instance on a newtype that you don't export
17:00:51 <mwc> HairyDude, if you do import Foo (), then you bring all the instances visible from Foo into scope
17:01:04 <HairyDude> LoganCapaldo: but afact it still exports the instance
17:01:04 * chessguy 's domain is indeed web frameworks
17:01:09 <chessguy> but not for this project :)
17:01:15 <LoganCapaldo> so it would still be exported, but effectively unexported
17:01:17 <mightybyte> chessguy Yeah, probably just my shade of the word's use.
17:01:32 <mightybyte> Aha, I thought so.
17:01:41 <LoganCapaldo> since no one but you could create values of that type
17:01:41 <mightybyte> It looked web-framework-ish
17:02:28 <HairyDude> I have a type I want other modules to use, and I need to use an instance that breaks the rules (curse Haskell not having first class instances) but be able to use a different instance elsewhere
17:05:25 <hpaste>  Toxaris pasted "(not) building hsplugins" at http://hpaste.org/4298
17:05:57 <Toxaris> what should I do about: "Constructor `STArray' should have 4 arguments, but has been given 3"
17:06:04 <hpaste>  LoganCapaldo pasted "HairyDude, what I meant" at http://hpaste.org/4299
17:07:31 <HairyDude> oh, I think I see what you mean
17:09:13 <LoganCapaldo> I think newtypes are one of my favorite bits
17:09:37 <njbartlett> Nah my favourite bit is 1
17:09:46 <njbartlett> Or maybe 0 ;-)
17:10:17 <LoganCapaldo> Just don't let JFI values escape your module
17:10:38 <HairyDude> suppose Foo imports Bar and BarInstances, but doesn't export Bar. am I right in thinking that Foo nonetheless exports the instances in BarInstances? so another module Baz importing Bar and Foo but not BarInstances still gets the instances
17:11:05 <sjanssen> HairyDude: yes, instances are exported implicitly
17:11:12 <HairyDude> that really sucks
17:11:34 <loupgaroublond> njbartlett: my favourite is 2, it's very rare
17:12:36 <njbartlett> loupgaroublond: Actually my favourite bit is a quantum superposition of 0 and 1 ;-)
17:12:48 <Toxaris> njbartlett: wich?
17:12:50 <Pseudonym> That's not a bit, it's a qbit.
17:12:53 <Pseudonym> qubit
17:12:55 <Pseudonym> Something.
17:13:00 <SamB> cubit?
17:13:21 <njbartlett> Pseudonym: Yeah, if you must nitpick...
17:13:22 <chessguy> @pl \p -> targets p >>= mapSource (location p)
17:13:22 <lambdabot> liftM2 (>>=) targets (mapSource . location)
17:13:30 <Pseudonym> Q*bert
17:13:31 <Pseudonym> That's it.
17:13:39 <wisnt> quibbit
17:16:23 <dibblego> ?type foldl
17:16:30 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
17:17:46 <dibblego> ?type foldl1
17:17:48 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
17:18:03 <davidL> > foldr1 (\x y->x+1/y) [3,7,15,1,292,1,1,1,2,1]
17:18:08 <lambdabot>  3.141592653591404
17:18:37 <dibblego> ?src foldl1
17:18:38 <lambdabot> foldl1 f (x:xs) = foldl f x xs
17:18:38 <lambdabot> foldl1 _ []     = undefined
17:20:01 <chessguy> wow, i threw a liftM2 at a type problem i was having, and it just worked!
17:20:07 <chessguy> maybe i have learned a thing or two
17:20:07 <nburlett> anyone tried to build HDBC for ghc 6.8?
17:20:17 <nburlett> it fails for me
17:21:03 <nburlett> ooh, darcs version builds
17:23:26 <dmwit> > 150 / 1000
17:23:27 <lambdabot>  0.15
17:24:32 <dmwit> Is there some scale that's commonly used that is... anti-logarithmic?
17:24:46 * byorgey high-fives chessguy
17:25:04 <dmwit> i.e. numbers with a small absolute value get a lot of space, and bigger and bigger numbers get less and less space?
17:25:27 <chessguy> err, isn't that logarithmic?
17:25:29 <Smirnov> hmm, i've been looking at this Denotational Semantics page on the wiki, but I can't seem to understand one thing. Are there any examples of how to prove a function is continuous?
17:27:15 <lament> dmwit: that's logarithmic
17:27:45 <dmwit> errr, yes it is
17:28:02 <dmwit> I feel slightly silly.
17:29:14 <dmwit> No, that's a lie.  I feel very silly.
17:29:40 * byorgey points at dmwit and laughs
17:29:53 <SideFFect> can someone explain to me when its best to use the [x| x <- xs, x <= p] notation (as an example) in haskell?
17:30:05 <SideFFect> and what it means exactly? I always get it mixed up
17:30:18 <davidL> that's called a list comprehension
17:30:24 <SideFFect> x gets xs given x <= p?
17:30:25 <dmwit> do { x <- xs; guard (p x); return x } -- how it desugars
17:30:44 <dmwit> Well... in your case, it's
17:30:51 <dmwit> do { x <- xs; guard (x <= p); return x }
17:30:54 <lament> SideFFect: are you familiar with the similar notation for sets?
17:30:57 <byorgey> > [ x | x <- [1,3,7,6,2,4], x <= 5 ]
17:30:59 <lambdabot>  [1,3,2,4]
17:31:11 <SideFFect> ohh
17:31:12 <lament> SideFFect: in mathematics?
17:31:26 <dmwit> SideFFect: That notation is most effective when the LHS of the | is not so trivial.
17:31:34 <SideFFect> x is assigned the new list given the second statement as a function kinda
17:31:54 <dmwit> Sort of!
17:31:58 <dmwit> One way to think of it is this:
17:32:02 <SideFFect> I was just unsure how to read it
17:32:06 <SideFFect> but go on!
17:32:16 <dmwit> 'x' takes on each of the values in the list, but only if it satisfies the condition.
17:32:37 <byorgey> > [ reverse x | x <- ["foo", "bar", "foop"], "foo" `isPrefixOf` x ]
17:32:39 <SideFFect> ah...cause I was looking at the definition for quicksort and was just wondering how to read that
17:32:39 <lambdabot>  ["oof","poof"]
17:33:17 <dmwit> The reason I word it in exactly that way is because list comprehensions are actually closely related to the list *monad*, which can be thought of nondeterminism.
17:33:28 <SideFFect> so quicksort (p:xs) then what I wrote takes p as the first element and then comares the rest of the list w/ it?
17:33:29 <dmwit> *as nondeterminism
17:33:43 <dmwit> right!
17:33:54 <SideFFect> ahh thanks :D
17:34:12 <lament> nonterminism
17:34:12 <SideFFect> any tips on Using Do and atoms I should know of?
17:34:34 <byorgey> > [ (x,y,z) | x <- [1..100], y <- [x+1..100], z <- [y+1..100], x^2 + y^2 == z^2]
17:34:37 <lambdabot>  [(3,4,5),(5,12,13),(6,8,10),(7,24,25),(8,15,17),(9,12,15),(9,40,41),(10,24,2...
17:35:11 <SideFFect> oh actually a quick q!
17:35:26 <SideFFect> when I use a do statement, why is the <- needed to take out the IO?
17:35:39 <SideFFect> all it does is remove the IO and returns the value associated w/ uit right?
17:35:53 <lament> that is SO not a quick question :)
17:35:54 <SideFFect> like do  etc  name <- getLine
17:35:57 <SideFFect> hehe
17:36:01 <dmwit> Actually, that's a bit of a mistake.  What you're actually doing is wrapping everything after the (<-) in a layer of IO.
17:36:22 <SideFFect> so since getLine is an IO() it wraps it?
17:36:27 <dmwit> do { x <- getLine; print x } -- what this actually does is:
17:36:42 <byorgey> SideFFect: getLine is IO String, not IO ()
17:36:52 <SideFFect> oh
17:37:14 <dmwit> print takes a String; but getLine gives an IO String!  So, let's wrap print's argument in IO with do notation.
17:37:38 <SideFFect> ohh! I think I get it!
17:37:46 <dmwit> Then it will have type IO String -> IO (); then it is a function we can apply to getLine.
17:37:47 <SideFFect> it kinda hides the unneeded bits
17:37:52 <dmwit> yep
17:38:12 <SideFFect> and theres no limit to how many statements you can apply after a do right?
17:38:33 <dmwit> nope
17:38:38 <SideFFect> just checking :P
17:38:40 <byorgey> dmwit: that's an interesting way of thinking about it =)
17:38:56 <njbartlett> do { x <- getLine; print x} is equivalent to getLine >>= (\x -> print x)
17:38:59 <dmwit> byorgey: I picked it up from the "Schroedinger's Cat" article a few days ago.  I like it! =)
17:39:07 <lament> :t >>=
17:39:08 <byorgey> dmwit: which article is that?
17:39:21 <lament> blah
17:39:22 <lambdabot> thread killed
17:39:29 <dmwit> http://programming.reddit.com/info/61zbt/comments/
17:39:29 <lament> :t (>>=)
17:39:30 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
17:39:33 <SideFFect> whats the thing called? the \x notation?
17:39:35 <dmwit> :t (>>= print)
17:39:36 <lambdabot> forall a. (Show a) => IO a -> IO ()
17:39:40 <dmwit> SideFFect: lambda
17:39:44 <SideFFect> thats it heh
17:39:45 <byorgey> dmwit: right, I see.
17:39:47 <lament> dmwit: ah, right
17:39:55 <SideFFect> now for atomic transactions
17:40:02 <SideFFect> any hints?
17:40:08 <SideFFect> like things I should know?
17:40:10 <lament> dmwit: that... does make sense
17:40:16 <SideFFect> I already know TVar and retry and etc
17:40:25 <SideFFect> and it doesnt commit until all actions are done
17:40:42 <dmwit> lament: Kind of backwards, isn't it? =D
17:40:57 <hpaste>  chessguy pasted "this doesn't work either?" at http://hpaste.org/4301
17:41:04 <lament> dmwit: not really
17:41:07 <lament> dmwit: :)
17:41:10 <dmwit> hehe
17:41:11 <chessguy> man, haskel syntax kills me sometimes
17:41:14 <njbartlett> SideFFect: Have you read a monad tutorial yet?
17:41:27 <dmwit> chessguy: x:y?
17:41:28 <byorgey> SideFFect: I don't know if anyone has any hints, why don't you just come back if you have any specific questions.
17:41:45 <SideFFect> well, I read the notes my teacher gave and the tutor
17:41:45 <SideFFect> is there a good tutorial out there I can read?
17:41:48 <nburlett> :t head
17:41:49 <nburlett> :t tail
17:41:50 <lambdabot> forall a. [a] -> [a]
17:41:50 <lambdabot> forall a. [a] -> a
17:41:54 <dmwit> chessguy: Or is it the scope that it's complaining about?
17:41:57 <nburlett> :t head
17:41:57 <lambdabot> forall a. [a] -> a
17:42:00 <nburlett> :t tail
17:42:00 <lambdabot> forall a. [a] -> [a]
17:42:02 <chessguy> dmwit, err, yeah, i meant [head s]
17:42:08 <nburlett> wow, lambda bot got those out of order?
17:42:11 <chessguy> yeah, the scope is the issue
17:42:32 <chessguy> doesn't it just substitute where clauses?
17:42:36 <lament> dmwit: it makes sense in terms of the monads-as-pipes analogy :)
17:43:27 <BMeph> nburlett: Huh? What order? Lambdabot is no imperative cult member! ;)
17:43:37 <dmwit> chessguy: The where applies to foo's scope, not the lambda's scope, apparently.
17:43:47 <chessguy> @pl \s -> k s ++ q s
17:43:47 <lambdabot> liftM2 (++) k q
17:44:17 <dmwit> ?pl \s -> x : y where { x = head s; y = tail s }
17:44:17 <lambdabot> (line 1, column 19):
17:44:17 <lambdabot> unexpected "{"
17:44:17 <lambdabot> expecting variable, "(", operator, ":", "++" or end of input
17:44:32 <dmwit> > (\s -> x : y where { x = head s; y = tail s }) "hey"
17:44:32 <lambdabot>  Parse error at "where" (column 14)
17:44:44 <dmwit> where may not be allowed in lambdas.
17:44:46 <chessguy> dmwit, apparently i have to do x s = ..
17:45:23 <byorgey> SideFFect: try http://haskell.org/haskellwiki/Monads_as_computation
17:45:41 <byorgey> SideFFect: you may also want to read http://mauke.ath.cx/stuff/haskell/how-to-io.html to see the connection to IO.
17:45:41 <SideFFect> lots on google but ill check yours out first
17:46:10 <byorgey> SideFFect: yeah, writing a monad tutorial seems to be something of a rite of passage.  unfortunately, many of them are just confusing or unhelpful.
17:46:34 <SideFFect> heh thanks for then right ones then :D
17:46:40 <SideFFect> the second link doesnt seem to work tho
17:48:19 <BMeph> byorgey, SideFFect: In the Haskell world, Monad tutorials are like compilers, they're done to demonstrate competence in the language, but they're not really meant for human consumption. Kind of like Ph. D. dissertations. ;)
17:48:22 <byorgey> hmm, you're right, maybe mauke took it down
17:48:25 <lament> monads are like love, everybody keeps writing about them yet nobody can really explain them
17:48:58 <SideFFect> hehe to the ph.d statement
17:49:14 <SideFFect> love is just a trigger...an emotional state
17:49:32 <lament> yes, and monads are just a category theory object with a few simple properties
17:49:53 <SideFFect> heh :P
17:50:11 <dmwit> "Sufficiently advanced incompetence is indistinguishable from malice."
17:50:13 <dmwit> discuss
17:50:18 <lament> haha
17:50:56 <chessguy> dmwit, where did that come from?
17:51:23 <dmwit> http://programming.reddit.com/info/628t3/comments/
17:51:31 <dmwit> (I spend a lot of time on proggit.)
17:51:56 <nburlett> ahh, gray's law
17:52:24 <BMeph> "Never attribute to malice, what can be explained by human stupidity."
17:52:27 <idnar> monads are like analogies
17:52:32 <chessguy> dmwit, you're spending too much time there, if you have a pet name for it :)
17:52:39 <dmwit> Marijuana is, like, whatever.
17:54:52 <lament> a beatiful simile
17:55:15 <SideFFect> for the sequence example of monads
17:55:25 <SideFFect> it takes in do v <- x
17:55:30 <SideFFect> but isnt xs just a list?
17:55:36 <SideFFect> it says its a list of computations
17:55:40 <SideFFect> but I see that as just a list?
17:55:48 <dmwit> SideFFect: It should be a list of lists.
17:55:59 <dmwit> (Although I'm not totally sure without seeing the same thing you're looking at.)
17:56:28 <SideFFect> sequence (x:xs) = do v <- x   vs <- sequence xs   return (v:vs)
17:56:46 <lament> a list of computations is just a list, yes.
17:56:49 <lament> of computations.
17:57:02 <dmwit> SideFFect: Note that "x" is the first element of the list... and hence an instance of a monad.
17:57:08 <SideFFect> would it be possible to pass it things to cpmpute in a list technically?
17:57:15 <dmwit> yup!
17:57:27 <SideFFect> cool just wondering :D
17:57:49 <dmwit> > sequence [print 3, getLine >>= putStrLn, return ()]
17:57:51 <lambdabot>  <IO [()]>
17:58:04 <dmwit> Try it at the command prompt. ;-)
17:58:11 <dmwit> err... ghci prompt, that is
17:58:56 <SideFFect> what u just typed? ok Ill try
17:59:57 <SideFFect> its 3...then it waits for me to press enter again then display 3 empty lists
18:00:19 <dmwit> Well, so it's not the most interesting example.
18:00:34 <SideFFect> its ok? it still works and shows me how it works!
18:00:36 <dmwit> But those are three "computations": one that just prints 3, one that echos a single line, and one that does nothing.
18:00:54 <SideFFect> why does it return the three () tho?
18:00:57 <dmwit> And the point is you can easily run those computations in order with the "sequence" function.
18:01:05 <dmwit> SideFFect: Ah, good question!
18:01:09 <dmwit> That's from the type of sequence:
18:01:11 <dmwit> :t sequence
18:01:12 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
18:01:25 <dmwit> Those particular computations aren't very interesting; they return a () every time.
18:01:35 <SideFFect> but I see two functions being done..why the third then?
18:01:39 <dmwit> But if you had more complicated computations, you'd want to be able to get at their results after you ran them.
18:01:41 <SideFFect> the print 3 and the getLine
18:01:53 <dmwit> return () is also a computation (albeit a trivial one).
18:01:59 <SideFFect> ahh heh true!
18:02:45 <SideFFect> hey cool a for loop done w/ sequence :P
18:09:57 <chessguy> @quote loop
18:09:57 <lambdabot> chessguy says: the loop is only in your brain
18:10:01 <chessguy> SideFFect, ^^
18:10:32 <Smirnov> does anyone here know how to show a function is scott-continuous?
18:11:08 <SideFFect> hehe
18:12:57 <ddarius> Smirnov: Implement it.
18:13:01 <chessguy> Smirnov, sounds like a uestion for #math
18:13:05 <Smirnov> math
18:13:06 <Smirnov> thanks
18:13:25 <ddarius> chessguy: It's a computer science question.
18:13:32 <byorgey> what does scott-continuous mean?
18:14:06 <chessguy> well it can't hurt to ask there
18:14:34 <dons> ?users
18:14:34 <lambdabot> Maximum users seen in #haskell: 420, currently: 394 (93.8%), active: 11 (2.8%)
18:14:43 <chessguy> hiya dons
18:15:13 <davidL> 420? did lambdabot lose some state?
18:15:19 <ddarius> yes
18:15:22 <Nafai> byorgey: How's the application process going?
18:15:46 <ramza3> random general comment, is lisp only composed of Functions and Types?
18:15:51 <ramza3> haskell I mean
18:16:03 <byorgey> Nafai: it's going ok, I guess.  I'll be glad when it's over though. =)
18:16:25 <Nafai> byorgey: Saw your blog entry about your "personal statement" or whatever it is called
18:16:25 <dons> ramza3: kinda
18:17:11 <chessguy> ramza3, not quite
18:17:21 <ddarius> byorgey: You can stop any time you like.
18:17:29 <Nafai> byorgey: Been working on anything fun lately?
18:17:31 <ddarius> The question doesn't make sense.
18:17:47 <byorgey> ddarius: hehe, I guess that's true. =)
18:18:23 <byorgey> Nafai: not really.  ask me again in January though. =)
18:18:32 <byorgey> Nafai: how about you?
18:19:05 <Nafai> Not really, just boring work stuff.
18:20:37 <dons> dcoutts_: better error message on non-existing packages?
18:20:37 <dons> $ cabal install parsetime
18:20:38 <dons> cabal: user error (Unresolved dependencies: parsetime -any)
18:20:43 <byorgey> Nafai: heh, I hear that.  let me guess, Enterprise Java Beans?
18:21:22 <Nafai> byorgey: Parts of what I do, yeah. But yeah, that sort of stuff.
18:21:48 <chessguy> @pl \s -> not (m s b)
18:21:49 <lambdabot> not . flip m b
18:22:32 <byorgey> EJBs = "Making large, robust enterprise applications is really hard.  So, I know, let's make it really complicated, too!" =P
18:27:43 <chessguy> @type all
18:27:44 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
18:30:11 <chessguy> @type and
18:30:22 <lambdabot> [Bool] -> Bool
18:30:27 <chessguy> no wonder!
18:31:02 <byorgey> @type (&&)
18:31:02 <lambdabot> Bool -> Bool -> Bool
18:31:28 <byorgey> yeah, I always have to think for a minute about 'and'/'all'/&&...
18:32:20 <Smirnov> is there a channel for general CS theory
18:32:47 <SamB> Smirnov: you mean this isn't it?
18:33:00 <Smirnov> uh.. i'm having some problems with denotational semantics
18:33:12 <proqesi> yeah, ##cinema
18:33:42 <proqesi> oh, you didn't mean creative screenplay
18:34:41 <Smirnov> well i need to prove a monotone function F is scott-continuous, but I have no idea how because I can't find any examples of such a proof
18:38:08 <wellwisher> how do you convert a .hsc file to a .hi file?
18:42:37 <dons> hsc2hs , then compile the .hs file
18:42:41 <dons> yielding a .o and a .hi
18:42:49 <dons> you generally let the build system do this for you
18:42:54 <dons> and you don't need to care about .hi files
18:43:29 <wellwisher> i am trying to get the pcap libray installed
18:43:41 <dons> it builds with cabal,  I think
18:43:50 <dons> are you using the normal build process for cabal packages?
18:44:17 <wellwisher> i tried that and it failed
18:44:26 <dons> which ghc are you using?
18:44:35 <dons> (i think the pcap lib was updated just last week)
18:44:47 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/pcap-0.4.1
18:44:48 <lambdabot> http://tinyurl.com/2jkf7m
18:44:48 <dons> that one?
18:44:57 <chessguy> @type gets $ liftM2 (++) ?k ?q
18:44:59 <lambdabot> forall s (m :: * -> *) a. (MonadState s m, ?k::s -> [a], ?q::s -> [a]) => m [a]
18:45:13 <dons> ah,
18:45:13 <dons> Base.hsc:135:22:  pcap-bpf.h: No such file or directory
18:45:14 <dons> compiling dist/build/Network/Pcap/Base_hsc_make.c failed
18:45:21 <wellwisher> the way the person who made the library set cabal up, it will only compile under linux
18:45:22 <dons> so i need that header
18:45:51 <dons> ok. so that is a portability issue. perhaps you can just ensure the correct paths are set in the .cabal file?
18:46:12 <wellwisher> i have no idea
18:46:33 <dons> why does it fail?
18:46:45 <dons> what OS are you building on?
18:47:00 <wellwisher> but it mostly worked using cygwin, but it didn't generate the Base.hi
18:47:07 <wellwisher> win XP
18:47:09 <dons> ok. that sounds odd.
18:47:23 <dons> so Base.hsc failed for some reason?
18:47:32 <dons> did you get any error message?
18:47:36 <chessguy> oy, i hate when my monads appear to go out of alignment
18:52:28 <hpaste>  wellwisher pasted "Pcap build errors" at http://hpaste.org/4302
18:52:57 <wellwisher> what might have something to do with it
18:53:08 <dons> pcap-bpf.h: No such file or directory
18:53:15 <dons> so missing include paths?
18:53:26 <dons> sys/socket.h
18:53:34 <dons> its failing because the C headers aren't found
18:55:04 <chessguy> @undo do i <- k; if i then k' else return []
18:55:05 <lambdabot> k >>= \ i -> if i then k' else return []
18:55:27 <chessguy> @pl \ i -> if i then k' else return []
18:55:27 <lambdabot> flip (flip if' k') (return [])
18:56:48 <chessguy> hmm
18:59:27 <wellwisher> so yah it only works on linux
19:00:56 <newsham> which pcap library are you using under windowsxp?
19:04:11 <th3lib> I've got a quick question regarding GHC 6.6.1 - I'm pretty sure I've read the answer to this question somewhere else before, but cannot recall it.
19:04:37 <th3lib> I have a program that is reading in a very large dataset, and consequently uses up a lot of memory
19:05:07 <th3lib> This program runs fine in GHCi, but stall once it's up to about 128MB ram when compiled
19:05:19 <dons> stall?
19:05:25 <dons> ghc -O ?
19:05:28 <th3lib> I assume there is some switch or option to overcome this limitation?
19:05:38 <dons> there shouldn't be a limitation
19:05:45 <dons> how do you compile the program?
19:05:53 <dons> and what data types do you use?
19:06:13 <th3lib> Stall is the only word i can think of - it starts to load the data set, gets to approx. 128MB ram then stops doing anything as far as i can tell
19:06:18 <dons> there's no limit imposed by ghc on how much you can allocate
19:06:28 <dons> what data types do you use to load the data into?
19:06:51 <th3lib> I'm reading in an approx. 9MB CSV file using the CSV 0.1.1 library
19:06:56 <dons> oh, that's tiny.
19:07:04 <dons> ah, but its represented as a String , is it
19:07:07 <dons> not a bytestring?
19:07:18 <th3lib> which is basically lists of lists of strings which I turn into floats with read
19:07:31 <dons> ok. you should use ByteStrings for that
19:07:31 <wellwisher> winpcap
19:07:39 <dons> it'll use 9M instead of 9*16 ?
19:07:56 <th3lib> That would probably help
19:08:07 <th3lib> Though the funny thing is it works perfectly in GHCi
19:08:21 <dons> yes, that's strange. do you compile with -O ?
19:08:22 <newsham> looks like this pcap library was a little sloppy.
19:08:39 <th3lib> I haven't yet - I'll try that now
19:08:54 <dons> yes, if you're going to compile, you may as well optimise it.
19:08:54 <newsham> You can comment out the #include <pcap-bpf.h> and you may have to an an "#undef DLT_PFSYNC" or fix the code to add a constructor for DLT_PFSYNC
19:09:02 <newsham> after that, it builds fine in FreeBSD
19:09:11 <dons> th3lib: is the format simple? you should be able to load and parse 9M almost instantly with a good bytestring parser.
19:09:20 <dons> my rule is anything over 10k i use bytestrings for
19:09:38 <kfish> dons: what's happening with bytestring parsec?
19:09:38 <th3lib> It's very simple - tab separated values
19:10:12 <dons> th3lib: super easy then. fixed number of columns?
19:10:17 <th3lib> Yup
19:10:22 <dons> how many columns? all floats?
19:10:28 <dmwit> Any spaces?
19:10:55 <th3lib> 18 columns, the last 16 of which are the only ones I care about, all floats, no spaces
19:11:03 <dmwit> Yay, words!
19:11:05 <dmwit> :t words
19:11:06 <lambdabot> String -> [String]
19:11:10 <th3lib> the first two columns are ints, but I don't worry about those
19:11:13 <dons> easy then.
19:11:41 <th3lib> How would I go about this?
19:11:54 * dons hacks up a demo
19:11:57 <dons> how fast does it need to be?
19:12:04 <th3lib> BTW, -O doesn't seem to help
19:12:07 <dons> reallly really fast, or fast enough?
19:12:16 <th3lib> Doesn't need to be fast
19:12:22 <th3lib> fast enough
19:12:34 <dmwit> :t \s -> lines s >>= map read . words
19:12:34 <lambdabot> forall a. (Read a) => String -> [a]
19:13:01 <dmwit> Oh, right.
19:13:18 <dmwit> :t map (map read . words) . lines
19:13:19 <lambdabot> forall a. (Read a) => String -> [[a]]
19:13:39 <dmwit> Now, if ByteString has the equivalent of map, read, words, and lines (I'm assuming it does), you're all set.
19:13:45 <lament> why is installing anything on os x (say, ghc) such a huge pain all the time?
19:14:05 <dmwit> lament: Get a real OS. ;-)
19:14:09 * dmwit ducks
19:14:15 <dons> dmwit: yep, all except reading floats
19:14:18 <dons> but we can use C for that
19:15:00 <dmwit> dons: Would unpacking the word-at-time strings be bad?
19:15:10 <dmwit> i.e. would it only keep one in memory at a time?
19:15:24 <dons> that's one way
19:20:58 <th3lib> Thanks for the pointers dons and dmwit
19:21:28 <hpaste>  dons pasted "float parsing, break on white space, bytestrings" at http://hpaste.org/4303
19:21:46 <dons> th3lib: there's an example of how to split up on words, then call atof to parse the bytestring to a Double
19:22:26 <th3lib> dons: Cool, thanks very much for that
19:23:12 <hpaste>  dons annotated "float parsing, break on white space, bytestrings" with "types" at http://hpaste.org/4303#a1
19:23:40 <dons> i've found coding haskell for a living really improves your knowledge of the libraries, btw.
19:24:24 <wellwisher> how do you set your path in bash?
19:24:29 <newsham> dons: is haskell's read too slow?
19:24:56 <th3lib> wellwisher: export PATH=$PATH:<new path>
19:24:57 <dons> newsham: to first unpack the bytestring to string, then parse it ?
19:25:09 <dons> probably not. depends on your use case :)
19:25:19 <dons> its certainly possible to write a nice fast bytestring float parser, btw.
19:25:20 <th3lib> dons: thanks very much for those snippets - it will help a lot.
19:25:21 <dons> i'm just lazy
19:26:37 <dons> th3lib:
19:26:38 <dons> 13.9M	in
19:26:38 <dons> $ time ./A in
19:26:38 <dons> 177600
19:26:38 <dons> ./A in  0.03s user 0.02s system 85% cpu 0.059 total
19:26:55 <dons> with 14M input in the form, 0.1 1.1 2.2 3.3 0.1 1.1 2.2 3.3 0.1 1.1 2.2 3.3 3.141592653589793 0.1 1.1 2.2 3.3
19:27:30 <th3lib> dons: very nice
19:28:01 <dons> $ du -hs in
19:28:01 <dons> 222M	in
19:28:01 <dons> $ time ./A in
19:28:01 <dons> 2841600
19:28:03 <dons> ./A in  0.51s user 0.36s system 99% cpu 0.876 total
19:28:07 <dons> should be enough for most uses.
19:28:16 <dons> that's not the best code either (lines is expensive)
19:28:53 <dons> (comparatively)
19:29:37 <dons> newsham: i get pretty good results with (show.read) too, btw
19:30:32 <th3lib> dons: more than fast enough for my purposes
19:30:59 <dons> let me know if you get stuck adopting that code
19:31:20 <th3lib> dons: is atof available on windows? It would be nice (but not crucial) if I could get this to work on Windows
19:31:40 <th3lib> more specifically, stdlib.h
19:31:48 <dons> not sure. you can just replace it with readf with (read . show), if its a problem
19:32:04 <th3lib> I'll try it and see how I go in that case
19:32:06 <dons> parse = map (map (read.show) . S.words) . S.lines
19:32:22 <dons> probably fine for 9M, I warrant
19:32:57 <th3lib> Thanks again for your help. If I run into trouble, I'll come back here and blame you :)
19:33:04 <dons> heh :)
19:33:12 <dons> ibid: xmonad feed now with 100% more content
19:36:36 <SideFFect> haskell does implicit variable declarations right?
19:37:25 <lament> that's a very wrong way of thinking about it
19:37:31 <lament> but yes :)
19:37:53 <SideFFect> heh thanks :P was just wondering because reading a book on principles of programming languages
19:40:15 <SideFFect> ant haskell has dynamic type binding too right?
19:40:18 <SideFFect> and*
19:40:50 <dons> dynamic type binding?
19:41:03 <davidL> is it cheating on project euler to get help from TAOCP?
19:41:32 <SideFFect> meaning list = {10.2, 5} will only give a type to list when its run
19:42:08 <byorgey> davidL: not if you learn something =)
19:42:25 <SamB> davidL: why would using a textbook be cheating?
19:42:52 <esdrasbeleza> Hi. I'm newbie on Haskell and I'm trying to implement a module that has a instance of Show. But I'm getting this error: ListADT.hs:74:2: `show' is not a (visible) method of class `List'
19:42:53 <SamB> anyway, I don't remember there being any rules against cheating on project euler
19:42:54 <davidL> I dunno, because I didn't figure out the algorithm on my own
19:43:20 <SideFFect> ahh no I think its static type binding in haskell
19:43:29 <SamB> basically, whether or not you feel cheated is what you should go by ;-)
19:43:40 <davidL> have you done problem 122?
19:43:42 <mokus> yea, haskell wants to know all types at compile time
19:44:09 <Pseudonym> esdrasbeleza: Haskell thinks you're declaring an instance of "List", not "Show".
19:44:11 <Pseudonym> !paste
19:44:11 <hpaste> Haskell paste bin: http://hpaste.org/
19:44:12 <SideFFect> yeah you can't assign an int to a float for haskell
19:44:15 <SideFFect> so its static
19:44:18 <Pseudonym> Can we see some code please?
19:44:24 <byorgey> davidL, I have
19:44:54 <dons> esdrasbeleza: hmm. so you're writing a new class List ?
19:45:05 <dons> and you've called show on something from that class?
19:45:11 <dons> ?paste <-- can you paste the code
19:45:11 <lambdabot> Haskell pastebin: http://hpaste.org/new
19:45:32 <davidL> byorgey: quick hint, to find l(n) do you have to brute-force addition chains?
19:45:57 <hpaste>  esdrasbeleza pasted "(no title)" at http://hpaste.org/4304
19:46:03 <esdrasbeleza> http://hpaste.org/4304
19:46:09 <davidL> err brute force may have been the wrong word
19:47:09 <esdrasbeleza> dons, yes
19:47:10 <byorgey> davidL: I'm not entirely sure what you're asking, but I think there's a better way
19:47:23 <Pseudonym> esdrasbeleza: OK, here's what that means.
19:47:24 <davidL> byorgey: a better way than using addition chains?
19:47:40 <Pseudonym> instance {- stuff -} List t where
19:47:47 <Pseudonym> declares an instance of the class List.
19:47:51 <Pseudonym> What you want is an instance of Show.
19:47:56 <dons> esdrasbeleza: you'll need to deriving Show for List
19:47:58 <Pseudonym> I assume your type is List?
19:48:08 <byorgey> davidL: no, I meant, a better way than computing each m(k) separately.
19:48:27 <esdrasbeleza> let me paste all the code
19:48:29 <byorgey> davidL: to be honest, it's been a while since I solved it, and I'm not sure I quite understand my solution now =)
19:48:31 <Pseudonym> OK
19:48:43 * Nafai tries to figure out how to read a file in
19:49:07 <byorgey> Nafai: getContents, perhaps?
19:49:19 <byorgey> err, hGetContents, if it's a file
19:49:26 <hpaste>  esdrasbeleza pasted "(no title)" at http://hpaste.org/4305
19:49:27 <mokus> or readFile
19:50:22 <byorgey> esdrasbeleza: you need to say instance Show t => Show (List t)
19:50:29 <Pseudonym> esdrasbeleza: One more thing.
19:50:37 <Pseudonym> data Enum t => List t = {- ... -}
19:50:45 <Pseudonym> It almost certainly doesn't mean what you think it means.
19:50:49 <byorgey> i.e. if t is an instance of Show, (Show t) then List t is an instance of Show as well ( Show (List t) ).
19:51:16 <davidL> byorgey: alright I will keep playing with it, generating all the chains of length 8 takes 8 seconds, but I'm pretty sure the worst case is some chain of length 10 or 11
19:51:20 <monochrom> TEE HEE HEE!
19:51:46 <Nafai> readFile is nice...now to parse what I'm getting
19:52:05 <Pseudonym> Anyway, yes, byorgey is right.
19:52:10 <Pseudonym> The => is a logical "implies".
19:52:20 <Nafai> byorgey: I'm trying out Project Euler #22
19:52:21 <Pseudonym> What you want is if t can be shown, then List t can be shown.
19:55:23 <davidL> woot only 223 seconds for length 9 chains! inefficient algorithms ftw
20:04:14 <Nafai> Is there a way to strip newlines off of the end of a string?
20:04:31 <esdrasbeleza> it's working :D
20:04:41 <Olathe> Nafai: Yes.
20:05:19 <Zao> > takeWhile (/='\n') "omgwtf\n"
20:05:26 <Olathe> > strip "" = ""; strip "\n" = ""; strip (x:xs) = x:strip xs in strip "omghi\n"
20:05:26 <lambdabot>  Parse error at "=" (column 10)
20:05:34 <lambdabot>  thread killed
20:05:35 <Olathe> Why you !
20:05:39 <Olathe> > let strip "" = ""; strip "\n" = ""; strip (x:xs) = x:strip xs in strip "omghi\n"
20:05:45 <Olathe> Faster !
20:05:53 <Olathe> :|
20:05:55 <lambdabot>  thread killed
20:05:58 <Olathe> > let strip "" = ""; strip "\n" = ""; strip (x:xs) = x:strip xs in strip "omghi\n"
20:06:01 <lambdabot>  "omghi"
20:06:01 <Zao> Parse error, wtf?
20:06:15 <Olathe> > let strip "" = ""; strip "\n" = ""; strip (x:xs) = x:strip xs in strip "omghi\nomghi"
20:06:15 <lambdabot>  "omghi\nomghi"
20:06:18 <Olathe> > let strip "" = ""; strip "\n" = ""; strip (x:xs) = x:strip xs in strip "omghi\nomghi\n"
20:06:19 <lambdabot>  "omghi\nomghi"
20:06:23 <Olathe> Oh, wait.
20:06:46 <Olathe> @let chomp "" = ""; chomp "\n" = ""; chomp (x:xs) = x:chomp xs in chomp "omghi\nomghi\n"
20:06:46 <lambdabot>  Parse error
20:06:51 <Olathe> @let chomp "" = ""; chomp "\n" = ""; chomp (x:xs) = x:chomp xs
20:06:59 <lambdabot> Defined.
20:07:01 <Olathe> > chomp "omghi\n"
20:07:02 <lambdabot>  "omghi"
20:07:35 <dons> th3lib: get things working nicely?
20:08:12 <Smirnov> anyone around who knows denotational semantics here.
20:08:20 <dons> a few
20:09:03 <th3lib> dons: To be honest I haven't yet had time to change my program to using the new parsing method. I'm sticking with my current method until I iron out a couple more bugs - I'll probably get around to it later this afternoon or tomorrow
20:09:24 <dibblego> is there a maximum/minimum (or similar) on Foldable?
20:09:37 <dons> th3lib: ok, cool.
20:09:56 <dons> dibblego: oh, hmm. Foldable on Num types?
20:10:00 <davidL> > "foobar\n" \\ "\n"
20:10:00 <lambdabot>  "foobar"
20:10:03 <chessguy> @src Foldable
20:10:03 <lambdabot> Source not found. :(
20:10:06 <dons> or Ord ?
20:10:10 <Olathe> @src (\\)
20:10:10 <lambdabot> (\\) = foldl (flip delete)
20:10:11 <dons> :t maximum
20:10:12 <lambdabot> forall a. (Ord a) => [a] -> a
20:10:19 <dibblego> dons, I was thinking Ord or (a -> a -> Ordering)
20:11:39 <dons> :t \(x:xs) -> Data.Foldable foldl max x xs
20:11:41 <lambdabot> Couldn't find qualified module.
20:12:37 <dons> oh, head /tail
20:13:16 <gwern> what does a ! mean in Clean type signatures? anyone know off hand?
20:13:44 * gwern is finally looking at the Esther source. it's confusing, Clean looks so much like haskell, and yet... not
20:17:09 <dons> gwern: strict
20:17:16 <dons> and * is unique (?)
20:17:28 <sjanssen> dibblego: yes, see Data.Foldable.maximum
20:17:28 <gwern> oh. well, that makes sense given bangpatterns in haskell
20:17:57 <dons> ah yes, sjanssen
20:18:33 <dmwit> > chomp "omghi\n\n" -- not good
20:18:35 <lambdabot>  "omghi\n"
20:18:54 <dmwit> > let chomp = reverse . dropWhile (=='\n') . reverse in chomp "omghi\n\n"
20:18:55 <lambdabot>  "omghi"
20:19:06 <dons> gwern: e.g. f :: !String !String !Int !*File -> *File
20:19:20 <dons> == f :: String -> String -> Int -> IO ()
20:19:26 <dons>    f !s !t !n = ...
20:20:23 <gwern> wait, !Int !*File -> *File corresponds to Int -> IO ()? where'd the second file go?
20:20:31 <dibblego> sjanssen, er, duh thanks
20:22:15 <gwern> 'More or less, that is what HAppS-State does.  It provides a way to
20:22:16 <gwern> serialize function calls for replay either on-restart or on other
20:22:16 <gwern> replicated boxes.  The $(method) TH function has the relevant magic. '
20:22:19 <dmwit> > let chomp ('\n':xs) = chomp' 1 xs; chomp "" = ""; chomp (x:xs) = x : chomp xs; chomp' _ "" = ""; chomp' n ('\n':xs) = chomp' (n+1) xs; chomp' n (x:xs) = replicate n '\n' ++ chomp (x:xs) in chomp "omghi\n\n" -- even better
20:22:19 <lambdabot>  "omghi"
20:22:34 <dmwit> > let chomp ('\n':xs) = chomp' 1 xs; chomp "" = ""; chomp (x:xs) = x : chomp xs; chomp' _ "" = ""; chomp' n ('\n':xs) = chomp' (n+1) xs; chomp' n (x:xs) = replicate n '\n' ++ chomp (x:xs) in chomp ['a','a'..] -- because it can handle this
20:22:34 <lambdabot>  "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
20:22:42 <gwern> I had hoped to avoid HAppS for some time... guess I must delve into its and TH's intricacies :(
20:23:10 <dons> the *File is stdout, being threaded, iirc
20:23:21 <dons> we just write to stdout, and thread the world instead
20:23:25 <dons> and hide it in a monad
20:24:23 <gwern> hm. I never did quite understand the Clean/haskell split - you can do one in the other I understood, so why not just have a uniqueness typing library in haskell, use the unsafe functions to remove the built-in IO, and avoid having an entirely separate language
20:24:31 <gwern> (or vice-versa)
20:26:41 <wli> Clean is 6 or7 years older.
20:27:10 <Nafai> Is there something like Python's enumerate?  Or should I just write my own?
20:27:31 <Pseudonym> What does Python's enumerate do?
20:27:31 <Olathe> enumerate ?
20:27:39 <davidL> @type enumerateFromTo
20:27:39 <lambdabot> Not in scope: `enumerateFromTo'
20:27:46 <Olathe> Eww.
20:27:59 <Nafai> Oh
20:28:02 <Brian`> @src ()
20:28:03 <lambdabot> data () = ()
20:28:05 <gwern> '{- Oh, how I wish I was allowed to use Data.Binary. *sigh*'
20:28:18 <ray> :t enumFromTo
20:28:19 <lambdabot> forall a. (Enum a) => a -> a -> [a]
20:28:28 <Brian`> enumFromTo 1 10
20:28:31 <gwern> Nafai: does that work like [1..10]?
20:28:32 <Brian`> > enumFromTo 1 10
20:28:33 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
20:28:37 <Brian`> > [1..10]
20:28:38 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
20:28:41 <Nafai> >>> for x,y in enumerate(['a', 'b', 'c']): print x,y
20:28:41 <Nafai> ...
20:28:41 <Nafai> 0 a
20:28:41 <Nafai> 1 b
20:28:42 <Nafai> 2 c
20:28:43 <Brian`> @src (..)
20:28:43 <lambdabot> Source not found. Wrong!  You cheating scum!
20:28:46 <gwern> > [1..10] -- sweet sweet sugar
20:28:47 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
20:28:55 <Brian`> m... sweet~
20:28:59 <dons> :t enumFromTo
20:29:00 <lambdabot> forall a. (Enum a) => a -> a -> [a]
20:29:04 <Brian`> :src enumFromTo
20:29:08 <dons> > enumFromTo 1 10
20:29:08 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
20:29:09 <Brian`> @src enumFromTo
20:29:09 <lambdabot> Source not found. Maybe you made a typo?
20:29:18 <wli> [1, 3 .. 11]
20:29:19 <dons> ?src Enum
20:29:19 <lambdabot> class  Enum a   where
20:29:19 <lambdabot>     succ                     :: a -> a
20:29:19 <lambdabot>     pred                     :: a -> a
20:29:19 <lambdabot>     toEnum                   :: Int -> a
20:29:19 <lambdabot>     fromEnum                 :: a -> Int
20:29:21 <lambdabot> [3 @more lines]
20:29:24 <dons> @more
20:29:24 <lambdabot>     enumFrom                 :: a -> [a]
20:29:25 <lambdabot>     enumFromThen, enumFromTo :: a -> a -> [a]
20:29:27 <lambdabot>     enumFromThenTo           :: a -> a -> a -> [a]
20:29:37 <Nafai> I could do a zip, looks like
20:29:51 <davidL> > enumFromThenTo 2 4 10
20:29:52 <lambdabot>  [2,4,6,8,10]
20:30:05 <dons> fwiw, enumFromTo is stream fusible,
20:30:05 <dons> enumFromToInt x y = Stream next (L x)
20:30:05 <dons>   where next (L !n)
20:30:05 <dons>             | n > y     = Done
20:30:08 <dons>             | otherwise = Yield n (L (n+1))
20:30:14 <dons> (little tidbit of the day)
20:30:36 <dons> so you can consume such generated lists without allocating them.
20:31:07 <davidL> :t enumFromToInt
20:31:08 <lambdabot> Not in scope: `enumFromToInt'
20:31:34 <dons> (Data.Stream)
20:32:46 <dmwit> dons: In 6.8.1?
20:33:07 <Brian`> @src guard
20:33:07 <lambdabot> guard True  =  return ()
20:33:07 <lambdabot> guard False =  mzero
20:33:20 <dmwit> (or do we have to wait for a future version?)
20:33:28 <Pseudonym> > zip [1..] "abc"
20:33:29 <lambdabot>  [(1,'a'),(2,'b'),(3,'c')]
20:33:33 <sjanssen> enumFromTo is foldr/build fusible too
20:33:42 <sjanssen> dmwit: which exists in GHC 6.8
20:33:44 <gwern> when you have a 'class' declaration, the :: specifies the name of a function anything in that type class must implement and what type it must cohere to; any actual function definition is just a 'default' definition, right?
20:33:48 <dmwit> That is so awesome.
20:33:50 <Olathe> > zip [1..] ['a', 'b', 'c']
20:33:51 <lambdabot>  [(1,'a'),(2,'b'),(3,'c')]
20:34:02 <Olathe> > zip [0..] ['a', 'b', 'c']
20:34:02 <Pseudonym> Yeah, same thing.
20:34:03 <lambdabot>  [(0,'a'),(1,'b'),(2,'c')]
20:34:13 <Olathe> Yep :)
20:34:20 <th3lib> This has got me stumped - why does this not compile? map (* 0.25) [0.0 .. ((length blocks) - start)]
20:34:26 <Pseudonym> > [ show x ++ " " ++ show y | (x,y) <- zip [1..] "abc" ]
20:34:26 <lambdabot>  ["1 'a'","2 'b'","3 'c'"]
20:34:37 <Pseudonym> etc etc
20:34:43 <mokus> > [x | x <- [1..50], and [x `mod` y /= 0 | y <- [2 .. x-1]]]
20:34:43 <lambdabot>  [1,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47]
20:34:45 <dmwit> th3lib: Because length returns an Int, not a Floating.
20:34:55 <dmwit> th3lib: Use fromIntegral or similar.
20:35:07 <th3lib> Ah
20:35:11 <dmwit> th3lib: Or genericLength, if start is already a Floating.
20:35:33 <th3lib> I was puzzled, as it worked OK, when I typed it into GHCi
20:35:44 <dmwit> It shouldn't.
20:36:22 <FMota> So... I designed an imperative language for Java programmers without OOP, but with no implicit side-effects, with Haskell-style data types, and with typeclasses.
20:36:28 <FMota> Someone shoot me? :o
20:36:40 <dmwit> ?slap FMota
20:36:41 * lambdabot smashes a lamp on FMota's head
20:36:43 <dmwit> You're welcome.
20:36:43 <dibblego> an imperative language with no side-effects?
20:36:43 <Olathe> Eww.
20:36:48 <Olathe> Eww eww eww.
20:36:50 <FMota> lol. No.
20:37:07 <FMota> dibblego: No implicit side-effects.
20:37:09 <Olathe> > "Eww " ++ (cycle "eww ")
20:37:10 <lambdabot>  "Eww eww eww eww eww eww eww eww eww eww eww eww eww eww eww eww eww eww eww...
20:37:20 <dibblego> you mean unsafePerformIO is not an implicit argument?
20:37:46 <FMota> er
20:37:49 <FMota> something like that.
20:37:54 <FMota> Mostly, anyway.
20:37:55 <dibblego> then what makes it imperative?
20:38:02 <FMota> No shared global state, for one.
20:38:19 <FMota> Well, it is stateful.
20:38:20 <dibblego> how does that make it imperative?
20:38:37 <FMota> You can pretty much translate a C program into it directly.
20:38:52 <dibblego> but a type system enforces that you control your side-effects?
20:38:54 <FMota> (Almost. I mean, no pointers and no global variables. But everything else..)
20:38:58 <FMota> Yes.
20:39:09 <dibblego> isn't that a "not imperative" language?
20:39:27 <Smirnov> you can describe an imperative program with denotational semantics
20:39:29 <Smirnov> functionally!
20:39:39 <dibblego> yep
20:39:55 <FMota> Well, it looks imperative.
20:40:09 <dmwit> So does "do" notation.
20:40:10 <dmwit> ;-)
20:40:13 <FMota> ;)
20:40:21 <FMota> Good point.
20:44:35 <FMota> Int fib(Int n) { Nat *a = 0; Nat *b = 1; for _ in 1 .. n { *a, *b = b, a + b;  } return b; }
20:44:48 <FMota> is ugly
20:44:54 <FMota> and not the way I'd do it.
20:44:57 <Pseudonym> Good heavens, it's Bliss.
20:44:59 <FMota> But obviously imperative.
20:45:04 <FMota> Bliss?
20:45:06 <Pseudonym> Only opposite.
20:45:29 <Pseudonym> Bliss didn't have the usual imperative distinction between lvalues and rvalues.
20:45:48 <Pseudonym> So "a", say, always means a location.
20:45:55 <dmwit> By Jove, I do believe Bliss is the name of a Programming Language.
20:45:57 <Pseudonym> So you'd write (probably haven't got the syntax right):
20:46:00 <Pseudonym> x := .y
20:46:10 <Pseudonym> You needed to explicitly dereference the y.
20:46:17 <FMota> aha
20:46:35 <FMota> Well, to me it makes more sense to * where changes are going to occur.
20:46:35 <mauke> looks like OCaml
20:46:40 <dmwit> FMota: What you have created is, indeed, the opposite of bliss.
20:46:41 <Pseudonym> dmwit: It is.  The language is totally uninteresting, but its compiler was very, very influential./
20:46:45 <FMota> Rather than the opposite :)
20:47:00 <FMota> Nice ;)
20:47:17 <Pseudonym> It was the first compiler, IIRC, to understand that register allocation was an NP-hard problem.
20:47:32 <Pseudonym> It used a knapsack solver rather than later graph colouring solvers.
20:49:39 <FMota> and then, well, the haskell-like features...
20:49:41 <Smirnov> why wouldnt register allocation be NP-hard? it is reducable to graph colouring
20:49:59 <FMota> data List(T) { nil; cons(T head, List(T) tail); }
20:50:13 <Nafai> Yay!  Problem #22 done
20:50:21 <FMota> Congrats, Nafai
20:50:31 <Pseudonym> Smirnov: The reduction to graph colouring wasn't discovered until about 1981.
20:50:32 <Smirnov> Pseudonym: hey do you happen to know denotational semantics
20:50:40 <Pseudonym> Smirnov: A bit.
20:50:45 <Smirnov> awesome
20:51:00 <Pseudonym> BLISS/11 was written in about 1973.
20:51:32 <Pseudonym> Also, the need for graph colouring wasn't as great until the advent of RISC.
20:52:09 <Pseudonym> Because memory accesses became MUCH more expensive relative to register operations all of a sudden.
20:52:23 <Smirnov> Pseudonym: so there's this function F, s.t. fix(F) denotes an imperative loop. i'm trying to prove F is (scott)-continuous, but I'm not sure how to do that at all since I can't even find any examples of how to prove functions are continuous
20:52:44 <Pseudonym> You know what continuity means, right?
20:53:11 <Pseudonym> F-of-lub-of-X = lub-of-F-of-X
20:53:13 <Smirnov> yeah
20:53:14 <Smirnov> exactly
20:53:24 <Smirnov> but i'm not sure how to show that
20:54:31 <Pseudonym> IIRC, the usual thing is to show it by structural induction on the language.
20:55:47 <Smirnov> that sounds somewhat hardcore
20:56:29 <Pseudonym> Not really.  The role that continuity plays is essentially that it's an approximation to "computability".
20:57:34 <Pseudonym> So to prove that F is continuous, you show that it's made of continuous parts.
20:57:40 <Pseudonym> Much the same way that you'd prove computability.
21:00:34 <Pseudonym> Really, though, if you have a specific F in mind, just try starting with F-of-lub-of-X and see what happens when you expand it.
21:02:07 <Smirnov> I can certainly try that and see if it helps
21:27:21 <dibblego> why is Data.Foldable.sum (Num a) and not (Monoid a)?
21:29:36 <Smirnov> Pseudonym: do you have any suggestions for proving the equivalence of a (specific language's semantics described using) denotational semantics to big-step sos semantics?
21:30:25 <Pseudonym> Not off the top of my head, no.
21:30:32 <sjanssen> dibblego: because they're different things
21:30:36 <Pseudonym> Sounds like fun stuff you have to do, though.
21:30:44 <Smirnov> Pseudonym: is there any kind of strategies that can be followed for this type of thing
21:30:57 <sjanssen> dibblego: sum is guaranteed to add the numbers, the Monoid instance might do any number of things
21:31:00 <Smirnov> Pseudonym: eh, yeah.. the language is actually a simple imperative one with <30 big-step sos rules
21:31:14 <dibblego> sjanssen, but isn't that just more general?
21:31:32 <sjanssen> dibblego: not more general, just different
21:31:38 <Pseudonym> To be honest, I haven't DONE much with denotational semantics.
21:31:42 <sjanssen> dibblego: did you know that Int doesn't have a Monoid instance?
21:31:45 <Pseudonym> Just read a lot, a long time ago.
21:32:01 <Smirnov> oh boy :-
21:32:15 <Smirnov> some idiot in our class asked the prof to change the syllabus to include denotational semantics
21:32:16 <dibblego> sjanssen, ok, so I guess then, perhaps passing another argument : a -> a -> a
21:32:31 <sjanssen> dibblego: besides, Data.Foldable already has operations for Monoids
21:32:40 <Smirnov> and then we managed to cover it in 2 lectures and the homework questions are way too hard for the amount of lack of depth that it was covered in
21:32:45 <dibblego> sjanssen, ah so it does
21:33:07 <sjanssen> dibblego: and there are class methods that take functions as arguments too
21:33:21 <sjanssen> dibblego: sum is a function that is based on that functionality
21:33:44 <dibblego> ok cheers, I'll read the source
21:33:48 <sjanssen> it is nicer to type 'sum xs' than 'foldl (+) 0 xs'
21:34:10 <sjanssen> dibblego: it's all in the haddocks too, if you don't feel like digging
21:34:20 <dibblego> ok thanks again
22:01:17 <newsham> [19:30] < Smirnov> some idiot in our class asked the prof to change the syllabus to include denotational semantics
22:01:43 <newsham> bastard trying to learn stuff after paying tuition :(
22:01:56 <Korollary> There may not be enough time
22:02:26 <newsham> never enough hours in the day
22:06:16 <goalieca> school is all about getting grades. nothing more :(
22:07:01 <ddarius> goalieca: So don't go to school.
22:07:02 <TSC> It's not really polite to change the syllabus halfway through the subject
22:07:19 <goalieca> TSC i've had the curriculum changed after the first midterm.
22:07:23 <goalieca> and it was immediate
22:07:30 <goalieca> new text and everything
22:07:52 <TSC> I hope you chastised whoever it was for being rude
22:07:55 <ddarius> CS 345 Advanced Functional Programming has now changed to Intermediate Underwater Basketweaving.
22:07:59 <goalieca> SFU is extremely unprofessional. don't ever go there
22:08:08 <dibblego> @remember <TSC> It's not really polite to change the syllabus halfway through the subject
22:08:08 <lambdabot> It is stored.
22:08:48 <newsham> tsc: wow, you're gonna hate life.
22:09:04 <newsham> syllabus always changes mid course
22:09:04 <TSC> ?
22:09:18 <Korollary> You know, underwater basketweaving may prove more useful to a software developer
22:09:41 <goalieca> global warming!
22:09:44 <nanothief> Korollary: it would definitely make your resuma stand out
22:10:00 <hpaste>  Nafai pasted "Why is this happening?" at http://hpaste.org/4307
22:10:01 <TSC> I think I'm safe from syllabus changes; I don't plan to take many more courses
22:10:33 <goalieca> what about as a TA
22:11:13 <TSC> It's ok to change the course if you don't have to study it (:
22:12:24 <TSC> Nafai: What's the problem?
22:13:16 <TSC> It seems to work for me
22:13:40 <Nafai> TSC: The closing bracket "]" isn't going at the end of the string read from the file for me :(
22:13:56 <Nafai> It worked on another data file, but on this particular file it isn't for me
22:15:38 <Nafai> So confused
22:16:51 <TSC> I get "[79,59,12,2,79,35,8,28 ... 22,73\r]"
22:17:06 <TSC> And I can pass it to read and get a [Int]
22:17:28 <ddarius> That looks right to me if it's using DOS newlines.
22:17:32 <Smirnov> newsham: not really, it just wasnt on the syllabus initially and i feel that 2 1.5hr lectures are not enough to fully appreciate denotational semantics
22:17:34 <TSC> Yeah, it looks fine to me
22:18:04 <Smirnov> ive nothing against learning, but glancing over something is essentially pointless
22:18:35 <hpaste>  Nafai annotated "Why is this happening?" with "What I get" at http://hpaste.org/4307#a1
22:19:49 <TSC> Nafai: Could you show us how you call getListAsStringFromFile and how you use its return value?
22:20:51 <Nafai> Woah
22:21:06 <Nafai> I never imagined this would be because of a type error
22:21:12 <Nafai> (on my part)
22:21:16 <TSC> Ah, what did you do?
22:22:10 <hpaste>  Nafai annotated "Why is this happening?" with "Whoops" at http://hpaste.org/4307#a2
22:23:13 <Nafai> I guess it was reading those things in as ASCII codes or something?
22:25:24 <TSC> If I try to read it as [String] instead of [Int], it just says it can't parse it
22:25:33 <TSC> (which is no surprise)
22:31:27 <Niat> g'morning!
22:31:51 <oerjan> morn morn
22:52:49 <dfranke> Whaaa.  I want dependent types.
22:53:00 <newsham> how about agda?
22:54:30 <dfranke> Would be great if it had a real implementation with real libraries.  This is commercial software, not research project.
22:55:20 <newsham> is coq's code generation (to ocaml) appropriate?
22:58:22 <dfranke> I'm not downgrading from Haskell to OCaml for the sake of being able to enforce that groups under multiplication don't include 0.
22:59:26 <goalieca> 1/0 = oops
22:59:42 <goalieca> i should learn ocaml
23:00:05 <xyyw> goalieca: why?
23:00:11 <oerjan> i vaguely recall that Coq can generate both haskell and scheme as well...
23:00:29 <glguy> Nafai: You there?
23:00:32 <Nafai> glguy: Yeah
23:00:46 <glguy> Did you end up going any further with problem 22 as pasted?
23:01:39 <Nafai> I annotated my final version: http://hpaste.org/4306#a1
23:02:18 <Nafai> Well, I replaced foldr1 (+) with sum, but other than that, it's the same as what I have
23:02:42 <glguy> why do you put functions into IO that are pure?
23:02:52 <glguy> instead of using let bindings?
23:03:09 <glguy> visual choice or not knowing about let bindings ?
23:03:36 <Nafai> Not really thinking about it, I guess
23:03:44 <Nafai> I'm still learning Haskell style
23:04:09 <Nafai> Could you annotate that paste with how you'd clean it up?
23:04:12 <glguy> I didn't know if you knew you could have lets inside a do block or not
23:04:15 <glguy> sure
23:07:11 <hpaste>  quicksilver annotated "Problem 22" with "like this, perhaps?" at http://hpaste.org/4306#a2
23:07:19 <quicksilver> Nafai: that's one way
23:07:30 <hpaste>  glguy annotated "Problem 22" with "my version" at http://hpaste.org/4306#a3
23:07:43 <quicksilver> Nafai: I don't like giving names to things which are only used once unless I feel that name is "documentation"
23:07:52 <quicksilver> Nafai: it's worth naming something if it helps the reader understand
23:08:11 <quicksilver> but a little name like 'l' or 'c' doesn't really contribute much IMO, I'd rather inline it all
23:08:22 * Nafai nods
23:08:25 <Nafai> Good point
23:08:36 <glguy> though I think that this: read $ "[" ++ contents ++ "]"   is kind of ugly
23:08:41 <glguy> (from my code)
23:09:16 <oerjan> well it _is_ the easiest way to read a comma separated list
23:09:35 <glguy> yeah, I never said it wasn't the easiest
23:11:40 <Nafai> Nice
23:12:53 <Nafai> How would I do a nested map without the result being a nested list?
23:12:58 <Nafai> Er, let me explain that better
23:13:15 <dmwit> (>>=)
23:13:19 <dmwit> ;-)
23:13:39 <Nafai> n/m
23:13:47 <Nafai> I could do this with a list comprehension I think
23:14:57 <oerjan> sure, list comprehensions desugar to concatMap = (>>=)
23:15:21 <Dooms> hey can any of you guys watch this video i made? And yes im the girl
23:15:23 <Dooms> http://youtube.com/watch?v=eXdkyAyOcGo
23:15:23 <lambdabot> Title: YouTube - USF ACTION HERO
23:15:31 <oerjan> @redo concatMap f l
23:15:31 <lambdabot> concatMap f l
23:15:54 <mauke> @pl concatMap f l
23:15:55 <lambdabot> f =<< l
23:16:00 <mauke> @. redo pl concatMap f l
23:16:00 <lambdabot> f =<< l
23:16:08 <oerjan> > fix ("SPAM "++)
23:16:10 <lambdabot>  "SPAM SPAM SPAM SPAM SPAM SPAM SPAM SPAM SPAM SPAM SPAM SPAM SPAM SPAM SPAM ...
23:16:37 <Dooms> lol
23:16:41 <glguy> namesListP = (between (char '"') (char '"') (munch isAlpha)) `sepBy` char ','
23:16:52 <glguy> Anyone know enough ReadP to make that consume as much as possible?
23:17:18 <glguy> instead of considering ending at every element?
23:17:40 <glguy> in parsec I might use "eof"
23:19:48 <oerjan> glguy: look perhaps?
23:20:46 <glguy> look returns the remaining string..
23:20:58 <oerjan> so you can test if it's empty
23:20:59 <glguy> you mean to guard
23:21:02 <glguy> that it isn't empty?
23:21:11 <oerjan> yep
23:22:33 <glguy> that seems reasonable
23:22:37 <glguy> I wonder if it was intended
23:24:51 <oerjan> i think eof = guard . null =<< look
23:25:22 <hpaste>  glguy annotated "Problem 22" with "with custom parser" at http://hpaste.org/4306#a4
23:25:50 <glguy> oerjan: "guard . null =<< look" was exactly what I pasted, I think we are on the same page :)
23:26:14 <oerjan> :)
23:26:22 <glguy> oerjan: did you see the solution I posted last night to that barcode puzzle?
23:26:33 <oerjan> no...
23:26:52 <glguy> http://hpaste.org/4282#a3
23:27:01 <glguy> I think we were on the same page here too
23:27:49 <oerjan> oh that one
23:27:59 <oerjan> i did not understand your solution then
23:29:31 <glguy> Hmm, I thought we were describing the same logic
23:35:05 * glguy needs a name for:  \ m n -> m >>= a -> n >> return a
23:35:11 <glguy> that comes up way too much not to have one
23:35:19 <oerjan> @pl \ m n -> m >>= a -> n >> return a
23:35:19 <lambdabot> (line 1, column 18):
23:35:19 <lambdabot> unexpected ">" or "-"
23:35:19 <lambdabot> expecting variable, "(", operator, ">>", ">>=", "=<<" or end of input
23:35:21 <mauke> <*
23:35:30 <mauke> :t (<*)
23:35:31 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
23:35:34 <oerjan> oh
23:35:39 <oerjan> @pl \ m n -> m >>= \a -> n >> return a
23:35:39 <lambdabot> (. ((. return) . (>>))) . (>>=)
23:35:45 <oerjan> well, not that
23:36:02 <oerjan> :t (*>)
23:36:04 <dmwit> :t let m ## n = do { x <- m; n; return x } in (##)
23:36:07 <lambdabot> forall (t :: * -> *) t1 t2. (Monad t) => t t1 -> t t2 -> t t1
23:36:07 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
23:36:10 <dmwit> (From module Dmwit.)
23:36:38 <dmwit> (Also from module WASH.CGI.CGI.)
23:36:45 <oerjan> er no
23:36:46 <mauke> char '"' *> contents <* char '"'
23:36:50 <oerjan> :t (<*)
23:36:50 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
23:36:58 <oerjan> that's the one
23:37:03 <dmwit> Ooo, it has a name!
23:37:11 <glguy> now I just need an Applicative instance for ReadP :)
23:37:21 <dmwit> heh
23:37:25 <mauke> should be easy if it's a monad
23:37:32 <mauke> @src Applicative
23:37:32 <lambdabot> class Functor f => Applicative f where
23:37:32 <lambdabot>     pure  :: a -> f a
23:37:32 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
23:37:37 <glguy> That can be automatically derived from any monad with loose enough instances, right?
23:37:39 * dmwit :b Applicative
23:37:43 <mauke> pure = return; (<*>) = ap
23:37:44 <oerjan> pure = return, (<*>) = liftM2 ($)
23:38:19 <oerjan> fmap = liftM for the Functor
23:38:43 <mauke> @pl liftM2 ($)
23:38:43 <lambdabot> ap
23:39:30 <oerjan> @src ap
23:39:30 <lambdabot> ap = liftM2 id
23:39:35 <hpaste>  glguy annotated "Problem 22" with "add a few lines to save 2" at http://hpaste.org/4306#a5
23:42:05 <dmwit> :t \m n -> unwrapMonad (WrapMonad m <* WrapMonad n) -- ewww
23:42:07 <lambdabot> forall (m :: * -> *) a b. (Applicative (WrappedMonad m)) => m a -> m b -> m a
23:45:36 <dmwit> :t (<*>) . pure
23:45:37 <lambdabot>     Ambiguous occurrence `pure'
23:45:37 <lambdabot>     It could refer to either `pure', imported from Control.Applicative
23:45:37 <lambdabot>                           or `pure', imported from Control.Arrow
23:45:46 <dmwit> :t (<*>) . Control.Applicative.pure
23:45:47 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => (a -> b) -> f a -> f b
23:45:51 <dmwit> :t liftA
23:45:51 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (a -> b) -> f a -> f b
23:46:15 <oerjan> = (<$>)
23:46:26 <oerjan> :t (<$>)
23:46:27 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
23:46:27 <dmwit> right
23:46:51 <oerjan> @src fmapDefault
23:46:51 <lambdabot> Source not found. Sorry.
23:47:17 <glguy> I was just thinking to myself "Haskell is too easy for people that have just started learning it, we need more operators"
23:47:18 <dmwit> ?src fmap Id
23:47:18 <lambdabot> Source not found. It can only be attributed to human error.
23:47:25 <glguy> but I guess I was wrong, we have enough :)
23:48:03 <hpaste>  aaim annotated "this doesn't work either?" with "usefull?" at http://hpaste.org/4301#a1
23:48:10 <oerjan> @src liftA
23:48:10 <lambdabot> liftA f a = pure f <*> a
23:48:12 <dmwit> ?src optional
23:48:12 <lambdabot> optional v = Just <$> v <|> pure Nothing
23:48:26 <dmwit> interesting
23:48:43 <oerjan> -- This function may be used as a value for `fmap` in a `Functor` instance.
23:49:06 <mauke> :t (<|>)
23:49:07 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f a -> f a
23:49:16 <oerjan> @src Alternative
23:49:16 <lambdabot> class Applicative f => Alternative f where
23:49:16 <lambdabot> 	empty :: f a
23:49:16 <lambdabot> 	(<|>) :: f a -> f a -> f a
23:49:33 <mauke> ApplicativePlus
23:49:51 <dmwit> Is it?
23:49:58 <dmwit> > [3,4,5] <|> [6,7]
23:49:59 <lambdabot>  [3,4,5,6,7]
23:50:10 <dmwit> > optional [5,7]
23:50:11 <lambdabot>  [Just 5,Just 7,Nothing]
23:50:13 <dmwit> =/
23:51:36 <oerjan> er what?
23:52:03 <oerjan> :t optional
23:52:03 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f (Maybe a)
23:52:14 <dmwit> sequence . optional = const Nothing -- =/
23:53:13 <dmwit> Well, I guess that's not true for infinite lists. =P
23:53:13 <oerjan> hm right it's not intended for lists
23:53:22 <dmwit> ?instances Alternative
23:53:23 <lambdabot> Couldn't find class `Alternative'. Try @instances-importing
23:53:31 <oerjan> > optional $ repeat 1
23:53:33 <dmwit> ?instances-importing Control.Applicative Alternative
23:53:33 <lambdabot>  [Just 1,Just 1,Just 1,Just 1,Just 1,Just 1,Just 1,Just 1,Just 1,Just 1,Just ...
23:53:34 <lambdabot> Maybe, WrappedMonad m, []
23:53:55 <dmwit> How is optional better than mplus for any of those instances?
23:54:00 <dmwit> Wait.
23:54:04 <dmwit> WrappedMonad?
23:54:16 <oerjan> it's not a replacement for mplus
23:54:19 <mauke> > const 1 <|> const 2
23:54:20 <lambdabot>        add an instance declaration for (Alternative ((->) b))
23:54:20 <lambdabot>     In the expr...
23:54:25 <dmwit> > unwrapMonad (optional (WrapMonad (print 3)))
23:54:26 <lambdabot>  <IO (Maybe ())>
23:54:32 <mauke> > WrappedMonad (const 1) <|> WrappedMonad (const 2)
23:54:33 <lambdabot>   Not in scope: data constructor `WrappedMonad'
23:54:33 <oerjan> there is an optional in Parsec which is the same, i think
23:54:43 <mauke> > WrapMonad (const 1) <|> WrapMonad (const 2)
23:54:44 <lambdabot>        add an instance declaration for (Show (WrappedMonad ((->) b) t))
23:54:54 <mauke> > unwrapMonad (WrapMonad (const 1) <|> WrapMonad (const 2)) ()
23:54:54 <lambdabot>   add an instance declaration for (MonadPlus ((->) ()))
23:55:03 <oerjan> it's useful for parser monads
23:55:10 <dmwit> mm
23:58:58 <oerjan> ah yes:
23:59:01 <oerjan> :t asum
23:59:01 <lambdabot> Not in scope: `asum'
23:59:09 <oerjan> :t Data.Foldable.asum
23:59:10 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Alternative f, Data.Foldable.Foldable t) => t (f a) -> f a
