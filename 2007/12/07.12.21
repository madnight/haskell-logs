00:07:32 <Jomyoot> i love how "monads" sound
00:08:23 <Jomyoot> Has Haskell been gaining in adopters ?
00:08:39 <olsner> you know, "monad" sounds different depending on how you pronounce it :P
00:09:17 <luqui> yo monads loves how monads sound!
00:09:18 <TSC`> Most words sound different, depending on how you prounce them
00:09:27 <TSC`> Or pronounce, even
00:09:44 <psi> Jomyoot: http://www.cse.unsw.edu.au/~dons/irc/ - might be some indication :)
00:09:46 <lambdabot> Title: Haskell IRC Activity
00:10:08 <luqui> god I love haskell; I just refactored some dense incomprehesible code into some dense comprehensible code!
00:10:22 <luqui> little higher-order helper functions are my friend
00:10:35 <Jomyoot> Well OCAML was like that too wasn't it?
00:11:09 <luqui> #haskell is remarkably on-topic most of the time
00:11:44 <glguy> > let fib = snd . (iterate (uncurry (ap (,) . (+))) (0,1) !!) in map fib [0..9]
00:11:45 <lambdabot>  [1,1,2,3,5,8,13,21,34,55]
00:12:19 <glguy> > let fibs = map snd $ iterate (uncurry (ap (,) . (+))) (0,1) in take 10 fibs
00:12:20 <lambdabot>  [1,1,2,3,5,8,13,21,34,55]
00:13:06 <dons> by the looks of it, 2007 has been #haskell's best year yet, growth wise
00:13:18 <dons> though i feel we've lots some of the long tutorials we used to do
00:13:22 <dons> s/lost/
00:13:37 <glguy> > let fibs = unfoldr (\(a,b) -> Just (b,(b,a+b))) (0,1) in take 10 fibs
00:13:38 <lambdabot>  [1,1,2,3,5,8,13,21,34,55]
00:14:00 <Korollary> Holy schmoly. Yet another fib.
00:14:47 * glguy loves the people who wait for a recursive function to appear on reddit so they can knowingly point to tco
00:14:59 <dons> heh. look, tail calls!
00:15:03 <glguy> *any recursive function* inspires this reaction
00:15:04 <psi> heh
00:15:05 <dons> i can has one?
00:15:14 <dons> why can't i has one?
00:15:21 <dons> you're mean
00:15:43 <glguy> proggiter don't use "you're"
00:15:47 <scook0> bah, tail calls are old hat
00:15:48 <glguy> You've given yourself away
00:15:59 <scook0> lazy non-tail recursion is what all the cool kids are doing these days
00:15:59 <Korollary> Tail calls are cool. The function doesn't even have to be correct.
00:16:07 <dons> ok. 'erlang' is now officially meaningless, http://www.beatniksoftware.com/blog/?p=80
00:16:09 <lambdabot> Title: beatnikblog » Blog Archive » Erlang-style concurrency with JavaScript 1.7
00:16:45 <glguy> the -style suffix has a long history of being used to describe things that are totally unrelated
00:16:49 <scook0> Korollary: (\x -> x x) (\x -> x x) -- omg a tailcall!
00:17:02 <dons> my head has explodes
00:17:43 <Korollary> type mismatch. You meant asplode.
00:17:58 <dons> oh noes!
00:18:09 <Korollary> But your sentence was dynamic.
00:18:13 <dons> i can has a spellings?
00:18:40 * ddarius starts wondering what a "non-associative array" is.
00:19:02 <tetha> heh, trying to recreate that erlang-concurrency in js is about as good as comparing erlangs processes with javas threads and yelling "look, erlang is more efficient" :)
00:19:27 <Korollary> you mean non-regular associative arrays
00:19:30 <glguy> dons, do I need to know what I'm talking about to start a blog?
00:19:40 <dons> glguy: generally, i would say, no.
00:19:46 <dons> and in your case, no. specifically.
00:19:54 <Korollary> You need to write long, tho
00:20:01 <glguy> awesome, could you tell me what the qualifications *are*?
00:20:07 <Korollary> and ponder whether something is a good lisp.
00:20:10 <glguy> if not knowledge?
00:20:18 <scook0> qualifiedToBlog = const True
00:20:21 <ddarius> glguy: Blogging software an internet connection.
00:20:28 <OceanSpray> I have a program compiled in linux.
00:20:32 <glguy> whoa, I have *both* of those
00:20:32 <OceanSpray> would it work in windows?
00:20:36 <dons> it helps to use words.
00:20:47 <ddarius> dons: But it isn't necessary.
00:20:47 <Korollary> OceanSpray: The binary executable won't.
00:20:52 <OceanSpray> well, dang
00:20:57 <dons> yes, pictures or sound would do.
00:21:04 <dons> grunting noises, for example
00:21:19 <dons> as long as they sound like erlang or python
00:21:34 <OceanSpray> now, would moving the excecutable to another linux machine allow it to work, even if no haskell implementation is installed?
00:21:58 <ddarius> Sure.
00:22:01 <TSC`> OceanSpray: Probably, depending on libraries
00:22:08 <OceanSpray> libraries...
00:22:09 <dons> OceanSpray: ghc binaries are mostly statically linked (they have some dynamic deps). you can use -static -optc-static -optl-static to ensure its fully statically linked
00:22:11 <Korollary> also cpu type
00:22:24 <dons> then there's a minimum of issues, and a maximum of binary portability
00:22:34 <dons> glguy: what would you write about?
00:22:38 <dons> you need a brand
00:22:41 <ddarius> A GHC generated binary is just like any other binary.
00:23:14 <dons> sigfpe has yoneda's lemma, i have fibonacci :), alpheccar does web monads. what do you want to stand for?
00:23:15 <glguy> dons, I'd probably stick to unenlightening generalizations and metaphors
00:23:34 <ddarius> sigfpe hasn't talked about Yoneda in a long time
00:23:45 <dons> ensuring there's always some code, and some numbers, a few interesting metaphors, is a good mix, i reckon
00:24:02 <dons> i've heard its coming back big in 08, ddarius
00:24:34 <dons> just look at what happened to 'holy schmoly' in 07!
00:25:12 <dons> glguy: getting feedback here is good too
00:25:12 <glguy> I could explain that ruby and perl are like a horde of barbarians with clubs and torches, lisp is like a boomerang, and Haskell is like a three-section staff and python is like jumbo Lego blocks
00:25:28 <glguy> I think I could write pages about that
00:25:31 <dons> i prefer the quarter staff, but yes.
00:26:20 <ddarius> jumbo Lego blocks are deadly
00:26:59 <glguy> yeah, if you use your imagination they could form anything
00:27:13 * tetha wants to build a giant deathray using the jumbo lego blocks
00:28:26 <dons> glguy: perhaps observations of the commercial haskell developer?
00:28:47 <dons> one of the few, the proud. :)
00:29:01 <glguy> You are thinking of the Marines ;)
00:29:10 <dons> with your quarterstaff and typechecker
00:29:23 <glguy> three-section*
00:29:46 <dons> ok, you get one of those.
00:29:53 <dons> i'm going medieval
00:30:10 <glguy> Get a bastard sword then
00:30:24 <glguy> those things cut like katanas
00:30:31 <dons> looks a bit like you! http://upload.wikimedia.org/wikipedia/en/a/a4/Three_sectional_staff.jpg
00:30:32 <lambdabot> http://tinyurl.com/2fjhrt
00:30:52 <glguy> dons, in that he's *male*?
00:31:08 <dons> and has a beard
00:31:55 <glguy> I guess I've been away from the office for 4 days now... your mental image of me might be blurry ;)
00:31:56 <dons> ok, this guy is closer, http://www.tmnttoys.com/05figures/combatwarriors/5153.jpg
00:32:32 <cpst> I never really got the "holy schmoly" series of posts
00:32:48 <dons> cpst: oh? what's to "get"?
00:33:18 <cpst> oh, well, I guess I just don't get the point of microbenchmarks against interpreted languages
00:33:35 <glguy> cpst, It is an indictment of blog posts everywhere, intended to trivialize them in general ;)
00:33:40 <dons> well, you like shooting ducks in barrels, right?
00:33:54 <glguy> "I don't know how to write a compiler for my language" isn't an excuse for being slow...
00:33:58 <cpst> yeah, but if you want fast loops you use C with SIMD extensions or assembly
00:34:17 <cpst> it's not like people don't already know the fastest way to do it
00:34:38 <glguy> dons, I have often though of myself as a ninja turtle
00:34:48 <dons> so hmm, what was the development. it was: ruby is slow, oh its a bit faster, oh haskell is faster, and `par` is nice, ghc is weird, lisp can be ok, python guys get confused, gcc is fancy
00:35:19 <dons> cpst: but you know what `par` is now?
00:35:34 <cpst> the one I really didn't get was the horrible raytracer
00:35:39 <cpst> that has to be under 100 lines
00:35:46 <dons> oh, forget that...
00:35:49 <dons> the jdh one?
00:35:51 <cpst> as if the intellectual market for 100 line raytracers is so huge
00:36:22 <cpst> with a decent low-level language, raytracing is so fast that the only issue is memory bandwidth
00:36:25 <dons> anyway, fibonacci is so yesterday. factorial is where it is at.
00:36:41 <cpst> so the only thought involved in writing a raytracer is traversing memory so you get as few cache misses as possible
00:37:08 <cpst> that would have been a better contest
00:37:13 <sclv> ok that distributive law post is sort of classic
00:37:25 <Korollary> It's not like there is a much better (although admittedly still imperfect) suite of benchmarks at the great lang shootout.
00:37:34 <Korollary> s/is/is not
00:38:18 <dons> well, we know roughly where ghc fits in now. that's useful. we didn't know 5 years ago.
00:38:34 <Korollary> A lisper friend of mine used to bring up cl-pcre all the time. Oh how it beats even perl's re, which is in C and polished, etc. There's a reason you need "a suite".
00:38:43 <dons> and its good to remind dynamic language weenies of what's outside
00:38:58 <dons> cl-pcre eh? curious.
00:39:19 * dons is attempting to replace regex-*-bloat with a pcre-light atm.
00:39:46 <cpst> does pcre have a reputation of being fast at all though?
00:39:50 <dons> glguy: did you get to write some code today?
00:39:52 <Korollary> dons: it turns out cl-pcre and perl's re slightly differ anyway. tcl's re engine beats both. Totally meaningless comparison.
00:39:56 <dons> cpst: its medium-to-good
00:40:05 <cpst> we use it in WebKit and someone just submitted a few weeks of patches speeding it up at least 25%
00:40:07 <dons> yeah, tcl's is very nice.
00:40:09 <glguy> dons, not really, spent the day with my grandparents
00:40:18 <dons> glguy: they don't code much?
00:40:19 <cpst> and that's not even doing that much different
00:40:29 <glguy> dons, not in Haskell at least ;)
00:40:36 <dons> interesting
00:41:39 <Korollary> from what I see people like free libraries more than high performance.
00:42:13 <cpst> people really like snappy web browsers though ;-)
00:42:34 <Korollary> What if a hacker releases a huge and capable web framework in assembly for kicks? Oh horror.
00:42:54 <cpst> I'd give him props
00:43:01 <cpst> actually implementing a web browser is such a huge pain
00:43:24 <cpst> the W3C designs standards without ever actually implementing them
00:43:34 <Jomyoot> what happened to OCAML? It was going strong for few years, but now everyone is talking Haskell
00:44:02 <cpst> OCaml has a pretty critical mass, and people like FSharp
00:44:03 <dons> community, french, and lack of a parallelism story ?
00:44:13 <cpst> I just used OCaml for some program analysis stuff, it was okay
00:44:27 <cpst> I completely destroyed the original Haskell implementation with no effort ;-)
00:44:33 <cpst> but I hope that is because it was poorly coded
00:44:51 <dons> they should be fairly identical, if you use identical techniques
00:45:10 <Jomyoot> But haskell has larger user sizes?
00:45:15 <Jomyoot> userbase than Ocaml?
00:45:17 <ddarius> I doubt that.
00:45:24 <cpst> there were some memory usage issues in the Haskell version, but I didn't write it
00:45:30 <dons> #ocaml: Total of 62 nicks
00:45:35 <dons> ?users
00:45:35 <lambdabot> Maximum users seen in #haskell: 434, currently: 352 (81.1%), active: 12 (3.4%)
00:45:44 <glguy> netcraft confirms it
00:46:11 <ddarius> dons: So they don't hang out on IRC, do you think Haskell has a comparable userbase to ruby and python?
00:46:18 <dons> nope.
00:46:20 <profmakx> dons, do you know whether Cale made a version of hs-plugins available that works with 6.8?
00:46:32 <ddarius> profmakx: He did.
00:46:32 <dons> i think we make better use of our community.
00:46:33 <sjanssen> #haskell is special
00:46:42 <profmakx> dons: where? :)
00:46:48 <Jomyoot> So Ocaml may have larger user base than haskell?
00:46:49 <profmakx> whups
00:46:56 <Jomyoot> everyone complains about it s syntax
00:47:06 <profmakx> ddarius  where, i asked him yesterdayu, but he did not answer
00:47:09 <dons> Jomyoot: i'm not sure. it seems to have a) less researchers, b) less libraries c) less community
00:47:18 <ddarius> profmakx: I don't think he "released" it yet.
00:47:29 <glguy> dons, you mean that it seems to be d* all of the above?
00:47:37 <profmakx> I would be happy enough to test it though
00:47:48 <dons> profmakx: the patch is in the darcs repo, affaik
00:47:49 <profmakx> i spend the whole evening yesterday trying to fix it
00:47:54 <profmakx> hm
00:48:21 * ddarius wonders how low #haskell will get over the holidays?
00:48:22 <profmakx> okay, perhaps i checked out the wrong repo?
00:48:34 <dons> ddarius: should spike in jan (has previously)
00:48:44 <profmakx> we could make lambdabot sing christmas songs
00:48:50 <ddarius> dons: I imagine.  People will be back and students will be starting a new semester.
00:49:21 <ddarius> Plus all those people with a New Year's resolution to use less state.
00:49:24 <Jomyoot> what IDE do you guys use for Haskell?
00:49:25 <dons> http://ircbrowse.com/cdates.html?channel=haskell is interressting
00:49:29 <lambdabot> Title: Meme Channel haskell by Dates
00:49:31 <dons> we need new colours for high numbers
00:49:45 <Jomyoot> Well does the fact that Ocaml wins the functional programming contest many times say anything?
00:49:49 <glguy> Jomyoot, Most people just use their favorite editor
00:50:03 <scook0> Jomyoot: plenty of people use emacs/vim
00:50:04 <profmakx> @where plugins
00:50:05 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
00:50:13 <dons> Jomyoot: it says something. it has won it less than haskell has though (iirc)
00:50:16 <scook0> personally, I get by with gedit
00:50:28 <dons> profmakx: its on code.haskell.org/~dons/code now
00:50:34 <profmakx> oh well
00:50:41 <profmakx> then i checked out the wrong one :/
00:51:35 <Jomyoot> Why does Ocaml wins ICFP all the time more often than other languages?
00:52:04 <dons> Jomyoot: it does?
00:52:10 <Jomyoot> yeah
00:52:12 <Jomyoot> i think so
00:52:24 <Jomyoot> really?
00:52:30 <Jomyoot> it gets in the top 3 most often
00:52:33 <dons> from what i recall, its 4 haskell, wins 3 ocaml, 2 c++, et al.
00:52:52 <dons> its a good language :) fp techniques are excellent, and we have fast compilers
00:53:01 <dons> ocaml is a useful skill.
00:53:17 <Jomyoot> hmm
00:53:20 <ddarius> Also the people in the O'Caml community, like the people in the Haskell community, tend to be smart.
00:53:26 <Jomyoot> is there a web site that summarizes all the years of ICFP?
00:53:43 <glguy> well, if you use Ocaml, then the specific team that won those two competitions will help you with your project and it will rock...
00:53:56 <dons> you may get frustrated by the community size, and lack of growth. things move a lot faster this side of the fp gap
00:54:12 <dons> also, haskell programmers have more fun
00:54:16 <ddarius> O'Caml is/(was recently) definitely growing.
00:54:23 <cpst> OCaml is definitely growing
00:54:32 <shivernz> surely with the whole F# being close to ocaml may boost there membership a bit?
00:54:42 <shivernz> their*
00:54:43 <dons> yeah, F# definitely helps
00:54:45 <Jomyoot> who is building f#?
00:54:46 <cpst> on my campus, I notice more people getting into OCaml than Haskell
00:55:00 <dons> cpst: which campus?
00:55:03 <cpst> Waterloo
00:55:09 <profmakx> i supoose that is because they can still use the imperative features
00:55:15 <shivernz> to be honest i only heard about both recently and ocaml was definitely the one i heard about the most
00:55:17 <profmakx> which gives a warm fuzzy feeling
00:55:30 <cpst> and Cale went here ;-)
00:55:38 <dons> shivernz: very interesting. tiobe says ocaml is fairly obscure still though
00:55:45 <ddarius> Relatively recently (i.e. two or so years ago) there was a definite up trend in most "high-level" languages.
00:56:06 <ddarius> There's an obvious up-trend (perception-wise) in functional techniques in general.
00:56:10 <dons> yep
00:56:10 <shivernz> the only reason i went the haskell route is that if i was going to learn FP, i wanted it to be pure
00:56:22 <dons> purity is very very useful
00:56:29 <glguy> helps to know French if you are going to be active in the ocaml community, no?
00:56:45 <cpst> I think a lot of people like the Caml family of languages because they like to be able to do dirty things every now and then and not feel dirty about them ;-)
00:56:46 <ddarius> glguy: It helps to know French v. not knowing French period.
00:56:48 <dons> to be active, hmm. i'm not sure we know anyone active in the community, do we? other than xavier
00:57:03 <cpst> but OCaml is definitely getting long in the tooth
00:57:05 <Jomyoot> is Ocaml going to improve on its syntax though?
00:57:09 <glguy> ddarius, it is particularly a less relevant skill in the Haskell community
00:57:10 <ddarius> dons: Indeed, the O'Caml mailinglist is just Xavier talking to himself all day long.
00:57:24 <shivernz> lol
00:57:26 <ddarius> Jomyoot: There has been a "revised" syntax for years.
00:57:33 <dons> ddarius: i can't tell if you're serious or not.
00:57:35 <cpst> and there's the caml light syntax
00:57:42 <Jomyoot> but Ocaml community does not embrase the revised syntax?
00:57:59 <cpst> the current syntax isn't all that horrible
00:58:18 <cpst> it's not worse than other MLs at least
00:58:38 <ddarius> cpst: It's about comparable to other MLs but that isn't a good thing.
00:58:49 <Jomyoot> http://www.google.com/trends?q=haskell%2C+ocaml
00:58:49 <lambdabot> Title: Google Trends: haskell, ocaml
00:59:04 <Jomyoot> Is the google trend representative?
00:59:27 <ddarius> Jomyoot: The issues with that should be obvious.
00:59:33 <cpst> the thing that annoys me the most about OCaml is the hit you take for using functors
00:59:42 <doserj> well, haskell is also a name
00:59:45 <ddarius> Jomyoot: It's representative that the word "Haskell" is used more often the "OCaml".
00:59:56 <cpst> I had to defunctorize a lot of code by hand to get acceptable performance
01:01:01 <mercury^> "Haskell goes from serious fall to the Super Bowl"
01:01:09 <mercury^> Hmm, yeah, must be the language.
01:01:20 <dons> super bowl, yaya
01:01:30 <dons> ocaml is trending down??
01:01:40 <cpst> and it would be nice to see some new additions to the type system in OCaml
01:01:53 <dons> this is useful, http://www.google.com/trends?q=erlang%2C+ocaml&ctab=0&geo=all&date=all&sort=0
01:01:54 <lambdabot> Title: Google Trends: erlang, ocaml, http://tinyurl.com/yojqat
01:02:03 * ddarius wonders if anyone actually uses -rectypes in real code.
01:02:12 <cpst> I am scared
01:03:09 <shivernz> i'm surprised at those trends. could have to do with the places which i frequent though
01:03:19 <shivernz> until recently i didn't even know what fp really was
01:03:40 <dons> there's been a noticeably increase in volume in the last 3 years.
01:03:41 <ddarius> I'm not surprised about the relative trends, but the "downward" trend for O'Caml seems wrong.
01:03:58 <dons> yeah, i'd have expected general upswing
01:04:00 <cpst> someone should actually implement rank-2 type inference
01:04:04 <cpst> and use it in a real language
01:04:24 <ddarius> cpst: It's undecidable in general and GHC does do it to some extent.
01:04:30 <cpst> rank-2 is decidable
01:04:36 <cpst> it's just the algorithm is insane
01:04:39 <profmakx> isnt that undecidable in general?
01:04:41 <profmakx> ups
01:04:42 <ddarius> cpst: Not type inference for it.
01:04:49 <ddarius> Unless I'm highly mistaken.
01:05:03 <glguy> I was under the same impression
01:05:10 <ddarius> Maybe you have a different meaning of "rank-2"
01:05:54 <cpst> http://citeseer.ist.psu.edu/193248.html
01:05:56 <lambdabot> Title: A Direct Algorithm for Type Inference in the Rank 2 Fragment of the Second-Order ...
01:05:56 <ddarius> (GHC actually supports arbitrary rank polymorphism, albeit requiring explicit type annotations strategically placed)
01:06:09 <puusorsa> for me the main reason for learning haskell instead of ocaml was that i find ocaml's syntax really ugly
01:06:23 <Jomyoot> why does MS pick Ocaml for F# and not Haskell?
01:06:56 <sclv> http://www.google.com/trends?q=ocaml%2C+erlang%2C+blub&ctab=0&geo=all&date=all&sort=0
01:06:58 <lambdabot> Title: Google Trends: ocaml, erlang, blub, http://tinyurl.com/2dwc7b
01:08:48 <shivernz> any estimates as to when "Real World Haskell" will be done?
01:09:08 <cpst> of course that algorithm isn't really practical for a bunch of reasons
01:09:10 <profmakx> Jomyoot, I suppose MS did want to have functional, imperative and OO
01:09:22 <cpst> but someone here just got a PhD for coming up with a more practical one
01:10:01 <ddarius> cpst: Perhaps it's the lack of principal types that is the issue.
01:10:02 <sclv> F# is secretly objects underneath in the .NET runtime, it seems.
01:10:26 <ddarius> Jomyoot: The obvious answer would be the O in O'Caml.
01:10:28 <sclv> or at least somewhat. Monad is an object, for example.
01:11:37 <cpst> ddarius: yeah, that's part of the problem, so their algorithm will also give you useless types
01:12:10 <cpst> ddarius: the main problem seems to be that the inference algorithm is developed by translating inference into a different problem in a fairly indirect way
01:12:18 <sclv> lots of the F# work looks like the libs they're creating are going to be used across the .NET platform and v/v -- it seems pretty natural to want a language that interoperates like that.
01:12:35 <cpst> ddarius: and there is a lot of program transformation done to actually perform the inference on a restricted language
01:13:00 <cpst> so you could never give an actual error message that makes sense to a human
01:13:12 <ddarius> humans are overrated
01:17:52 <Jomyoot> who is writing real world haskell?
01:17:57 <Jomyoot> where is that book available?
01:18:24 <roger`> in all good bookstores someday.
01:18:29 * shivernz points at dons 
01:18:36 <shivernz> and one or two others
01:18:40 <shivernz> its not done yet though
01:19:18 <ddarius> bos, CosmicRay and dons
01:21:47 <glguy> Why has Igloo had +o for the better part of a week now?
01:25:34 <ddarius> @seen Igloo
01:25:34 <lambdabot> Igloo is in #ghc, #darcs and #haskell. I last heard Igloo speak 1d 16h 28m 13s ago.
01:26:52 <Cin> glguy: ping
01:27:08 <glguy> ?
01:27:19 <Cin> glguy: shouldn't the 'raw' view on hpaste be 'text/plain' as opposed to 'text/html'? :o
01:27:36 <glguy> probably
01:27:43 <glguy> I imagine that it was at one point
01:32:20 <roconnor> sounds like a type error
01:32:35 <roconnor> serving plain text as html
01:36:42 <ddarius> roconnor: HTML is a dynamic type
01:52:33 <quicksilver> Ooh yuck!
01:52:45 <quicksilver> Justin's unlifted automata code is horrid :)
01:59:44 <b_jonas> @src join
01:59:44 <lambdabot> join x =  x >>= id
02:00:00 <b_jonas> @type join
02:00:13 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
02:14:07 <roconnor> are delta_1 formulas decidable, or just delta_0 formulas.
02:14:19 <roconnor> or are delta_1 formulas the same as delta_0 formulas
02:15:34 <b_jonas> can't remember that
02:15:40 <Syzygy-> What's a good starting point to get a grasp on type theory and lambda-calculus?
02:15:40 <b_jonas> was years ago that I learnt it
02:17:10 <kfish> Syzygy-, ttfp perhaps?
02:17:11 <kfish> www.cs.kent.ac.uk/people/staff/sjt/TTFP/
02:17:20 <Syzygy-> I'm looking to collate good travel reading for my x-mas trips...
02:17:39 <therp> syzygy: ftp://ftp.cs.ru.nl/pub/CompMath.Found/HBK.ps is nice
02:18:12 <antypaladyn> how does haskell paralell computing work?
02:18:30 <Syzygy-> therp: What's the title of that? Do I have any chance of finding it at my library?
02:18:51 <roconnor> b_jonas: me neither
02:19:26 <therp> syzygy: yes, handbook of logic in computer science (as it says on the first page) -- a collection of quite lengthily articles on classical topics.
02:19:37 <therp> there is also a volume two of this handbook IIRC
02:19:43 <therp> quite old..
02:19:58 <Syzygy-> My university library gives me 5 volumes of the handbook of logic in CS. :)
02:20:58 <quicksilver> I found barandreck (sp?) quite a good intro to lambda-calculus
02:21:04 <quicksilver> it says nothing or little about types, though
02:21:20 <quicksilver> barendregt
02:21:20 <integral> vol2 of hand book of logic has an article by barendregt on "Lambda Calculi with Types"
02:21:25 <quicksilver> would appear to be who I mean :)
02:21:25 <therp> quicksilver: the link I posted was from barendregt
02:21:29 <quicksilver> ah.
02:21:57 <psi> the compiler construction book by spj also has an introduction to lambda calculus
02:22:12 <psi> it's the only one i've read so i don't know if it's good
02:22:52 <psi> i don't the remember what the book is called... the implementation of functional languages maybe.
02:23:03 <therp> I really have difficulties to remember his name...hmm, there might be some evolutionary pressure in family names for names that are easy to remember and google.
02:23:15 <therp> his name=barendregt
02:24:24 <psi> (and it's also available online, iirc)
02:24:31 <Syzygy-> therp: I wonder how I work out for that particular aspect - Vejdemo Johansson
02:25:30 <integral> "Implementing Functional Languages: a tutorial" SPJ and David R Lester.  there's a .ps.gz somewhere online of it
02:26:55 <Liskni_si> czShadoW: ^^
02:27:05 <quicksilver> http://research.microsoft.com/~simonpj/Papers/pj-lester-book/
02:27:06 <lambdabot> Title: Simon Peyton Jones: book
02:27:10 <quicksilver> there it is
02:28:37 <therp> are you sure you meant this book?
02:28:55 <quicksilver> that has the title that integral gave
02:28:55 <therp> there is another implementing function programming languages as it seems
02:29:09 <integral> ah.  I didn't realise there was more than one book
02:29:23 <therp> I just found out now too
02:30:12 <psi> yeah, that's not the one i meant
02:30:36 <therp> there is the one with the red cover and the "bad" scan
02:31:00 <therp> http://research.microsoft.com/~simonpj/Papers/slpj-book-1987/index.htm
02:31:01 <lambdabot> Title: The Implementation of Functional Programming Languages, http://tinyurl.com/yempzk
02:31:02 <therp> this one
02:31:45 <drigz> can someone tell me if euler problem 100 needs something you don't learn in high-school level maths?
02:32:11 <drigz> there's a solution here, but i'm being careful not to look at it: http://www.haskell.org/haskellwiki/Euler_problems/91_to_100#Problem_100
02:32:12 <lambdabot> Title: Euler problems/91 to 100 - HaskellWiki, http://tinyurl.com/ys5hn3
02:33:12 <therp> syzygy: I'd recommend to get "The implementation of functional programming languages" by SPJ. this one is more fun to read than the papers from barendregt
02:45:06 <roconnor> Barendrecht
02:46:10 <roconnor> oh crap
02:46:15 <roconnor> Barendregt
02:46:20 <roconnor> I'm in big trouble
02:50:13 <Cin> argh
02:50:21 <Cin> ghc keeps giving me this error: <no location info>: file name does not match module name `Main'
02:50:35 <Cin> the filename is Main.hs and the module is "module Main where" etc
02:50:56 <pejo> Cin, does it include a file that is empty?
02:51:02 <Cin> it was building fine two minutes ago. i restarted my shell and now it's borked
02:51:04 <Cin> pejo: i'll double check
02:51:34 <pejo> Cin, I think that was a bug in 6.6, where you got those strange messages.
02:51:37 <Cin> ahhh
02:51:46 <Cin> it was another file, my mistake
02:52:00 <Cin> "smodule Grid where"
02:52:27 <Cin> pejo: indeed, i found a post about it: http://www.haskell.org/pipermail/glasgow-haskell-users/2006-November.txt
02:52:28 <lambdabot> http://tinyurl.com/yqntge
02:52:34 <Cin> pejo: says it's fixed, though, so that's good
02:53:15 <Cin> (indeed, i'm on 6.6)
02:55:57 <dozer> on the last day of my contract, I get my software running correctly :)
02:56:38 <dozer> on ubuntu, how do I fix this error after installing ghc 6.8.2:
02:56:41 <dozer> error while loading shared libraries: libreadline.so.4: cannot open shared object file: No such file or directory
02:57:47 <Cin> dozer: is libreadline5 installed?
02:57:58 <doserj> dozer: install readline4?
02:58:00 <pejo> dozer, did you install a binary distribution from ghc hq?
02:58:07 <dozer> yes, yes and yes
02:58:16 <Cin> dozer: what about the -dev version?
02:58:26 <Cin> i had a similar problem recently for sqlite, and i needed to install the -dev package
02:58:51 <dozer> I installed the linux (x86) build from: http://haskell.org/ghc/download_ghc_682.html#x86linux
02:59:39 <pejo> dozer, I'll side with doserj - are you really sure that libreadline.so.4 is on your system?
03:00:17 <Cin> even if libreadline is installed, the link might not be made to it. the -dev package usually creates that link
03:01:36 <dozer> ok, I have libreadline5 installed
03:01:50 <dozer> so should I install readline4?
03:03:12 <luqui> @pl \(a,b) (c,d) -> (f a c, g b d)
03:03:13 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. g) . flip . (((.) . (,)) .) . f)
03:03:16 <luqui> yow
03:03:17 <pejo> dozer, or wait for ubuntu to package stuff. The Gentoo people seem to be pretty close to 6.8.2, so wouldn't surprise me if the Debian people are too.
03:03:37 <dozer> hehe, not an option - last day, code must work on the production server :)
03:07:48 <opqdonut> luqui: you want something like (f***g) (a,b) (c,d)
03:08:02 <luqui> yes something like that
03:08:04 <opqdonut> arrow combinators are great for that sort of stuff
03:08:15 <luqui> except... that doesn't do it
03:08:27 <luqui> it needs to be a binary *** :-)
03:08:41 <luqui> (er, binary on the second order)
03:09:12 <luqui> I'm just going to write it in as a lambda.  screw higher-orderness
03:09:41 <b_jonas> lol
03:11:30 <opqdonut> i think f (a,b) = (f a***g b) is good enough
03:11:38 <opqdonut> half-pointfree
03:11:53 <quicksilver> luqui: you can make two-tuples into an applicative.
03:11:55 <quicksilver> then you can write
03:12:03 <quicksilver> (f,g) <$> (a,b) <*> (c,d)
03:12:16 <quicksilver> although, that does force a and b to be the same type, which is sad
03:12:43 <opqdonut> yeh, i was thinking of something like that
03:12:54 <opqdonut> but there's really no way to make it generically enough
03:13:10 <opqdonut> using app might work
03:13:20 <opqdonut> (from ArrowApply)
03:13:51 <b_jonas> @hoogle (b -> b -> c) -> (a -> b) -> a -> a -> c
03:13:52 <lambdabot> Data.Function.on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
03:14:32 <opqdonut> isn't that new in 6.8?
03:15:15 <b_jonas> you could use that probably
03:15:24 <b_jonas> you'd also need a diadic fork
03:16:14 <b_jonas> @hoogle (a -> c) -> (c -> d -> e) -> (b -> d) -> a -> b -> e
03:16:15 <lambdabot> No matches, try a more general search
03:17:08 <b_jonas> if you had those, you could write fork2 (,) (f on fst) (g on snd)
03:18:02 <kombinator> has anyone heard of region inference for memory management? is it advantageous to have region inference if there is already a generational garbage collector?
03:18:17 <b_jonas> @hoogle (c -> d -> e) -> (a -> c) -> (b -> d) -> a -> b -> e
03:18:18 <lambdabot> No matches, try a more general search
03:20:10 <b_jonas> > let { bond u v x y = u (v x) (v y); fork2 v u w x y = v (u x y) (w x y); } in fork2 (,) (bond (+) fst) (bond (*) snd) (3,10) (5,9)
03:20:12 <lambdabot>  (8,90)
03:20:20 <b_jonas> that's the way I'd write it
03:20:31 <b_jonas> except maybe with more infixes
03:23:13 <b_jonas> does that make sense?
03:23:27 <quicksilver> kombinator: yes, I've heard of it
03:23:41 <quicksilver> kombinator: I believe it is advantageous for a variety of reasons.
03:24:30 <b_jonas> > let { bond = Data.Function.on; fork2 v u w x y = v (u x y) (w x y); } in fork2 (,) (bond (+) fst) (bond (*) snd) (3,10) (5,9)
03:24:31 <lambdabot>   Not in scope: `Data.Function.on'
03:24:35 <kombinator> quicksilver: what are they?
03:31:52 <kombinator> quicksilver: I mean, what are the advantages?
03:37:52 <Cin> hm. i have a grid object for a game, and i have some function placeMove of type Grid -> Int -> Position -> Grid, whereby the Int is which column to place a move on, and the a Position is Empty | Player Int, if you can follow that
03:38:38 <Cin> my question is, currently i am trying it as returning Maybe Grid, that is, if the column they want to place is out of bounds, or if there is no more room to place a move, it returns Nothing
03:38:54 <Cin> is there a better way to do this or is this a good way to do it?
03:39:16 <pejo> kombinator, "collecting" regions is cheap. It's a difficult problem to figure out what things to put in a certain region though.
03:40:36 <kombinator> pejo: I believe that you can call minor collections 'cheap' as well because they have high collection ratios
03:41:33 <pejo> kombinator, what is a minor collection?
03:41:43 <Cin> http://hpaste.org/4615#a1
03:42:28 <kombinator> pejo: collection of the youngest generation, that often has a low survivability ratio and fits in the processor's cache
03:43:11 <pejo> kombinator, should be linear to the amount of live memory in a copying collector?
03:43:19 <quicksilver> kombinator: well the idea is that you can collect a whole region at once
03:43:25 <quicksilver> kombinator: which is a very cheap notion
03:43:37 <quicksilver> and traditionally region usage is a static property
03:43:42 <quicksilver> so there is no runtime checking at all
03:43:45 <kombinator> pejo: but it amortises
03:43:58 <quicksilver> so, it's actually like "local variables" in standard C/C++ compilation
03:44:08 <quicksilver> they're just unwound as the stack frame unwinds
03:44:12 <quicksilver> no need for costly GC passes
03:44:13 <kombinator> pejo: and does not cause memory accesses
03:44:28 <quicksilver> region analysis can be seen as an attempt to generalise stack-based allocation to a wider setting.
03:45:11 <kombinator> I was wondering why no one considered region inference in GHC
03:45:28 <quicksilver> I would be surprised if no one has considered it :)
03:45:52 <kombinator> I guessed that it might be that region inference doesn't give much in presence of generational gc
03:46:18 <quicksilver> I think it might be that the GC isn't seen as "much" of a problem.
03:46:34 <quicksilver> so the incentive to "Fix" it isn't that big.
03:46:53 <kombinator> as long as most of the garbage is collected in minor passes it's 'ok'
03:47:14 <kombinator> but I feel that often it is a problem
03:47:23 <byorgey> Cin: I think that's a fine way to do it.  That recursion in placeMoves doesn't look right though.
03:47:43 <doserj> jhc aims to implement region inference
03:51:47 <Cin> byorgey: hm. the placeMoves is a test function to place all the moves it can in column 0 until it gets Nothing
03:52:15 <fons> I just asked about this problem in haskell-cafe but probably I didn't express myself correctly
03:52:36 <kombinator> quicksilver: I was thinking that while all the short-living objects are well handled by the generational gc, region inference might help in collecting some of the long living objects that end up thrashing the major heap
03:52:37 <Cin> byorgey: (in which case it returns the grid of the last move)
03:52:42 <fons> I want to code a function dynAppList :: Dynamic -> [Dynamic] -> Dynamic
03:52:46 <Cin> byorgey: is that what you meant?
03:53:01 <kombinator> quicksilver: but I don't know yet if it's feasible
03:53:04 <byorgey> Cin: oh, if that's what it's supposed to do, then looks good =)
03:53:08 <fons> it is supposed to apply the first argument (originally a function transformed to a dynamic) to the second one
03:53:09 <Cin> byorgey: yay!
03:53:17 <fons> does anyone have any suggestions?
03:53:21 <Cin> byorgey: thanks for looking at it
03:53:24 <byorgey> Cin: sure
03:54:23 * Cin will add comments next time
03:54:38 <fons> The problem seems to transform the list of Dynamics into a Dynamic in order to apply the usual dynApp
03:56:02 <pejo> kombinator, don't let us stop you from looking into the problem though, on the contrary - it's an interesting one that someone should look into. :-)
03:56:55 <kombinator> pejo: the problem is that I have not seen any papers on region inference in lazy languages
03:57:19 <kombinator> pejo: so it's difficult to start
03:58:43 <quicksilver> kombinator: I think region inference is less likely to help with long lived objects, but I'm not sure
03:58:51 <quicksilver> The main issue people have with the GHC GC is threads
03:59:06 <quicksilver> I would be very nice to use some static analysis to identiy thread-private data
03:59:14 <quicksilver> stick that all in a region and just chuck it all out when the thread stops.
03:59:23 <quicksilver> At least, that would be ideal for short running worker threads.
03:59:53 <kombinator> quicksilver: like in erlang? I see
04:00:33 <Jomyoot> is there a rails-like framework in haskell?
04:01:46 <b_jonas> quicksilver: but threads (in ghc) are only a problem if you use parallelism, aren't they?
04:02:02 <quicksilver> Jomyoot: There is hAppS. It's not much like rails.
04:02:21 <quicksilver> b_jonas: well, it's a problem if you want to take advatnage of multiple cores.
04:02:22 <kombinator> quicksilver: in this situation region inference might help with short-living objects as well
04:02:41 <quicksilver> b_jonas: and may modern machines have more than one core :)
04:02:47 <quicksilver> b_jonas: and this trend is expected to continue.
04:03:21 <Jomyoot> how strong is hAppS
04:03:44 <b_jonas> quicksilver: that's true, but I don't always want to use multiple cores when I use threads
04:04:02 <pejo> Jomyoot, have you written any Haskell?
04:04:05 <b_jonas> I've used threads to simplify the code that does io
04:04:10 <Jomyoot> pejo: not yet
04:04:11 <quicksilver> b_jonas: yes, true.
04:04:38 <pejo> Jomyoot, try it out and get a feel for the language - it's great!
04:05:57 <b_jonas> though this might not be as significant in haskell than in other languages
04:06:03 <b_jonas> but I guess I'd still use threads for io
04:06:29 <b_jonas> even if some other coroutine-like thingies might be easier to (write without threads) in haskell than in other languages
04:06:33 <b_jonas> because of lazyness
04:06:42 <quicksilver> b_jonas: definitely. And don't get me wrong, there isn't a problem with GC and threads.
04:06:51 <quicksilver> it's just that, if you have genuinely paraller computation
04:06:54 <quicksilver> and a GC happens
04:06:56 <quicksilver> it stops every thread
04:07:02 <quicksilver> which is a shame
04:07:09 <quicksilver> if you're trying to squeeze out max performance.
04:07:19 <b_jonas> yep
04:07:22 <kombinator> quicksilver: do all the threads share the same minor heap?
04:07:24 <quicksilver> Some region analysis might reduce the amount of GC and/or permit threadlocal GC
04:07:31 <quicksilver> kombinator: I believe so but I could be wrong
04:07:36 <b_jonas> and it could be avoided in theory but that might mean worse overall performance
04:07:46 <quicksilver> kombinator: don't forget threads operate on the same values
04:07:59 <quicksilver> kombinator: they can be happily reducing different thunks in teh same large ADT
04:08:06 <quicksilver> and lazily passing thunks between each other.
04:08:27 <b_jonas> obviously, if you want to squeeze out max performance, you can fork and transfer data between threads only in an explicit way or something
04:08:50 <kombinator> quicksilver: sure, still it would be very advantageous to separate them
04:09:01 <quicksilver> kombinator: hence my comments about region analysis :)
04:09:18 <quicksilver> kombinator: because it's not obvious how you separate...
04:09:20 <quicksilver> analysis would help
04:09:35 <roconnor> ugh, I need a linear algebra bot
04:09:58 <roconnor> what's the inverse of [[1 -1] [a (1-a)]]?
04:11:54 <roconnor> looks like [[1-a 1],[a 1]]
04:12:41 <roconnor> er
04:12:44 <roconnor> looks like [[1-a 1],[-a 1]]
04:14:17 <visof> > let  abs n = if n >=0 n then n  else -n in abs -3
04:14:18 <lambdabot>   add an instance declaration for (Num (a -> a))
04:14:42 <roconnor> > let  abs n = if n >=0 n then n  else (-n) in abs -3
04:14:43 <lambdabot>   add an instance declaration for (Num (a -> a))
04:14:52 <roconnor> > let  abs n = if n >=0 then n  else -n in abs -3
04:14:53 <lambdabot>   add an instance declaration for (Num (a -> a))
04:14:53 <lambdabot>     In the expression: let a...
04:14:56 <b_jonas> rovonnor: mbot (or some similar name) evals mathematica if you need symbolic expressions;
04:15:11 <roconnor> b_jonas: in #math?
04:15:15 <b_jonas> yes
04:15:18 <roconnor> :)
04:15:25 <roconnor> that would be great
04:15:26 <b_jonas> for just numeric ones, I like the j evaluating bots
04:15:48 <visof> isn't  this  right?
04:15:53 <visof> > let  abs n = if n >=0 n then n  else -n in abs -3
04:15:54 <lambdabot>   add an instance declaration for (Num (a -> a))
04:15:55 <roconnor> b_jonas: I used an online matrix calculated and pluged (1/5) in for a
04:16:02 <roconnor> b_jonas: then guessed at the generalization.
04:16:23 <b_jonas> rocconor: that's why I'm mentioning numeric
04:17:09 <roconnor> :)
04:18:10 <b_jonas> it says  [0.8, 1; -0.2, 1]
04:19:11 <b_jonas> visof: no, there's an extra n after 0
04:19:18 <b_jonas> > let  abs n = if n >=0 then n  else -n in abs -3
04:19:19 <lambdabot>   add an instance declaration for (Num (a -> a))
04:19:19 <lambdabot>     In the expression: let a...
04:19:29 <b_jonas> > let  abs n = if n >=0 then n  else -n in abs (-3)
04:19:29 <lambdabot>  3
04:19:32 <b_jonas> that too
04:20:08 <Saizan_> fons: the only solution i see is to tranform f before putting it in a Dynamic, like this: toDyn (f . catMaybes . map fromDynamic)
04:21:29 <fons> Saizan_:  Thanks, actually I just happened to be trying that solution
04:22:14 <fons> basically is like having a [Dynamic] -> Dynamic function instead of only Dynamic
04:23:34 <fons> which is not a problem for me
04:57:28 <therp> hmm.. freenode is a bit unstable today.. at least for me
04:58:22 <therp> infinite lazy knuth-bendix, woot woot. this really sounds like brilliant idea to deal with undecidability
04:58:36 <SamB_XP> eh?
04:58:56 <therp> (the above is referring to Kenn Knowles blog post  http://www.kennknowles.com/blog/2007/12/20/infinite-lazy-knuth-bendix-completion-for-monoids-in-haskell/ )
04:58:57 <lambdabot> Title: Mathematical Pamphlet » Infinite lazy Knuth-Bendix completion for monoids in Has ..., http://tinyurl.com/2l7ntb
05:00:07 <therp> Knuth-Bendix is a completion algorithm for term rewriting systems (TRS) turning non-confluent TRS into confluent TRS
05:00:47 <SamB_XP> ... sounds magical
05:01:30 <pejo> therp, first-order ones?
05:01:52 <therp> the problem with it is that it's undecidable, but doing this lazy results in my opinion in a TRS that is useful in practice, as you will the rule you need for confluence is guarenteed to be generated at some point, hence the overall thing must terminate (right?) despite the completion algorithm never generated its infinite set of rewrite rules
05:02:04 <therp> pejo: I presume yes. what are higher order TRS?
05:02:27 <SamB_XP> therp: so the rule you need next will eventually be reached?
05:02:29 * therp fetches his baader nipkow textbook
05:02:34 <SamB_XP> what if you run out of RAM first?
05:02:38 <therp> samb: yes, that's I idea I guess
05:02:47 <therp> samb: RAM is not theoretical limit :)
05:02:51 <therp> s/not/no/
05:03:06 <SamB_XP> so your solution was ?
05:03:20 <quicksilver> well then there are feasibility questions, right?
05:03:28 <therp> samb: kenn knowles solutions was to generate the list lazy
05:03:37 <quicksilver> does it tend to take exponential time/space to generate the next rule you actually need?
05:03:51 <pejo> therp, I'm not really sure. I think Nipkow has done work on confluence and similar stuff for higher-order trs's.
05:03:52 <quicksilver> or does it generate the next rule you need quickly (constant time?)
05:04:04 <quicksilver> the feasibility difference between those options is large..
05:04:36 <SamB_XP> quicksilver: well, if you are just making a list of rules and then going over it for rules that match, it's not going to be constant time...
05:04:43 <pejo> therp, there's an article from LICS99 about termination analyasis.. hm. HORPO, Higher-order recursive path-ordering.
05:04:59 <therp> quicksilver: hmm good question. I have only done knuth bendix by hand. but yes, I think it's computational hard as for every new you have to check for critical pairs with all existing rules
05:05:31 <quicksilver> sounds possibly linear, for next rule
05:05:38 <quicksilver> so perhaps quadratic over all
05:05:39 <therp> there is algorithmic simplification by Huet
05:05:39 <vincenz> que pasa?
05:06:21 <SamB_XP> what is a finitely presented monoid?
05:07:04 <doserj> a monoid that has a finite presentation. a presentation being a set of generators and relations
05:08:19 <doserj> for example, the list monoid has no relations, a group would have the relation aa^-1 = e
05:08:34 <doserj> (for each a)
05:08:53 <quicksilver>  [Integer] isn't finitely presentable, for example
05:08:58 <quicksilver> although [Int] is
05:09:18 <luqui> there's something undecidable about finitely presented groups (and thus monoids?)
05:09:24 <luqui> post correspondence problem, right
05:09:26 <zx]treads> join #concatenative
05:09:31 <zx]treads> oups
05:09:44 <quicksilver> zx]treads: could be worse. Could have been join #php
05:09:53 <quicksilver> zx]treads: at least concatenative is cool :)
05:09:59 <zx]treads> lmao
05:10:05 <SamB_XP> I was just about to ask "why do you want us in #concatenative?"
05:10:23 <zx]treads> yeah sound like spam
05:10:37 <therp> pejo: sounds interesting
05:10:42 <SamB_XP> no, it sounds like a bad way to ask for help in an argument
05:12:28 <pejo> therp, if you pursue that path, feel free to tell me what you find out. :-)
05:13:10 <moobax> hello
05:13:37 <Saizan_> hi
05:13:56 <moobax> does anyone know if there is a way to get haskell to derive you a hash function for a user data type?
05:14:13 <quicksilver> not built in to GHC
05:14:15 <SamB_XP> Haskell can't
05:14:18 <moobax> I don't really want to write one myself :(
05:14:21 <quicksilver> but it sounds like an obvious thing for someont to have written
05:14:26 <vincenz> it might be feasible
05:14:27 <quicksilver> let's look around
05:14:27 <SamB_XP> why? do you have a decent hashtable library for us?
05:14:32 <vincenz> quicksilver: if you use storable a
05:14:36 <vincenz> which is defined for most types
05:14:43 <vincenz> and then just write a combination functino
05:14:51 <vincenz> to roll your bytes into a fixed number of bytes
05:14:53 <quicksilver> vincenz: it's definitely feasible
05:14:56 <vincenz> you could have
05:14:56 <moobax> Data.HashTable?
05:15:10 <vincenz> foo :: (Storable a) => a -> Word32
05:15:17 <SamB_XP> moobax: nope, that's not good
05:15:23 <moobax> how come?
05:15:32 <SamB_XP> we really need to stick a warning label on that thing
05:15:39 <vincenz> @src Data.Hashtable
05:15:39 <lambdabot> Source not found. Just try something else.
05:15:44 <SamB_XP> moobax: the word on the street is that it is slow
05:15:47 <vincenz> @doc Data.HashTable
05:15:48 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-HashTable.html
05:15:49 <SamB_XP> and annoying
05:15:49 <moobax> oh, because stuff is not mutable?
05:16:18 <quicksilver> moobax: You probably don't want to use a hashtable anyway )
05:16:26 <quicksilver> moobax: Data.Map is fine for most purposes
05:16:28 <SamB_XP> I'm not sure there is a REASON it is slow...
05:16:36 <vincenz> moobax: why do you wish hash-values?
05:16:38 <SamB_XP> and it does use mutable state
05:17:12 <moobax> I figured a hashtable might be faster than a Map... but I guess I could be wrong
05:17:53 <quicksilver> asymptotically, it might be
05:17:56 <quicksilver> but in practice it ain't
05:18:01 <SamB_XP> but I'm definately under the impression that Data.Map is a better choice for most or all applications...
05:18:08 <quicksilver> and O(1) is known to #haskell inhabitants to be a fiction, anyway :)
05:18:26 <quicksilver> it also screws up your code by forcing you into a Monad
05:18:29 <quicksilver> which makes everything ugly!
05:18:34 <moobax> hehe
05:18:42 <quicksilver> However, to answer your original quesiton : Yes, almost.
05:18:46 <quicksilver> You can derive Binary instances.
05:18:57 <quicksilver> and then you could write a generic Binary -> Hashable instance.
05:19:01 <quicksilver> fairly easily
05:19:06 <moobax> I'm finding haskell is great for most things (I'm writing a compiler) but graph algorithms are weird and scary
05:19:08 <quicksilver> xor groups of 4 words, or something.
05:19:28 <SamB_XP> moobax: have you looked at FGL?
05:19:35 <moobax> good idea, I'll stick to the map though
05:19:47 <moobax> I have, yes
05:19:55 <vincenz> moobax: there's Data.Graph
05:20:07 <SamB_XP> Data.Graph?
05:20:12 * SamB_XP wasn't too impressed...
05:20:22 * vincenz was
05:20:38 <vincenz> It does most of the plain stuff you might need, it just has terrible docs
05:20:44 <SamB_XP> well, the interface doesn't seem too great either
05:20:51 <moobax> do you mean Graph, or Inductive.Graph?
05:20:57 <vincenz> Data.Graph.Inductive
05:20:58 <moobax> they seem to be different
05:21:01 <vincenz> it has a lot of std algos
05:21:10 <SamB_XP> oh, that, that's a lot better than Data.Graph, I think
05:21:15 <vincenz> finding cyclical components
05:21:19 <moobax> I appreciate the graphviz stuff too
05:21:19 <SamB_XP> that is the FGL I mentioned ;-P
05:21:23 <vincenz> bfs,dfs
05:21:40 <SamB_XP> @doc Data.Graph
05:21:41 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Graph.html
05:21:49 <vincenz> ah, you're right
05:21:52 <vincenz> separate stuff
05:22:02 <SamB_XP> lambdabot really needs to stop linking to "latest"
05:22:05 * vincenz has used plain D.G, it's not too bad
05:22:10 <moobax> confusing, but I got the same impression as Sam
05:22:26 <moobax> Inductive seemed better
05:23:05 <SamB_XP> see, http://haskell.org/ghc/docs/6.6/html/libraries/base/Data-Graph.html is kind of raw
05:23:06 <lambdabot> http://tinyurl.com/2rylrf
05:23:23 <moobax> it's just it seemed overkill for my immediate problem, but I guess I could do it
05:23:34 <moobax> anyway, have to dash (lunch ;) )
05:23:40 <moobax> thanks for your help
05:23:40 <vincenz> silly side-q, what is a typical price for a laptop hd
05:31:40 <alexj> @seen lemmih
05:31:40 <lambdabot> I saw lemmih leaving #haskell 3h 17m 7s ago, and .
05:32:14 <ricky_clarkson> The suspense is killing me.
05:33:04 <Saizan_> suspense?
05:34:05 <ricky_clarkson> "I saw lemmih..., and <blank> ."
05:53:48 <Cin> guards are so ace. i had loads of if/elses and now with guards it's much more concise
05:55:21 <quicksilver> yup
05:55:30 <quicksilver> easier to read, too
05:55:59 <Cin> verily
05:58:08 <Valodim> praise the h
06:00:01 <dmwit> ?tell vincenz If you still care, laptop drives are typically $1-$2/GB.
06:00:02 <lambdabot> Consider it noted.
06:03:17 <mwc> dmwit: less than that I think
06:03:30 <dmwit> Really?
06:03:38 <dmwit> It's less for desktop drives, for sure.
06:04:00 <mwc> I replaced the HD in my powerbook two years ago or so, it was $80 bucks for a new 2.5" 100 GB
06:04:13 <mwc> and that's in Canada, were we get screwed on high-tech
06:04:33 <dmwit> wow
06:04:51 <dmwit> ?tell vincenz Actually, mwc says it's even cheaper than that, so don't mind me. =P
06:04:52 <lambdabot> Consider it noted.
06:06:21 <mwc> I'd look it up, but I'm on dialup at the moment]
06:06:49 <quicksilver> Yup. You can get 120G 2.5" for GBP44 inc VAT
06:07:02 <quicksilver> I imagine a similar drive in the US would be $80 or so.
06:07:50 <mwc> quicksilver: probably less, I hear the UK gets shafted as bad as Canada
06:08:08 <mwc> anything with a transister on it explicably picks up a 25% price hike when it crosses the obrder
06:08:19 <mwc> *transistor
06:08:51 * dmwit discovers vim's :set ft=mail
06:09:06 <profmakx> ;) welcome to tomorrow, dmwit
06:09:21 <dmwit> =)
06:09:22 * mwc shoves dmwit to www.mutt.org
06:09:30 <BMeph> mwc: Ah, but the US dollar is so "shafted" from the last ten years of manipulation, that it balances out.
06:09:31 <dmwit> mwc: I'm trying out Sup instead.
06:09:38 <Philippa> mwc: of which about 2/3rds is VAT, no?
06:09:52 <Philippa> (effectively "sales tax")
06:09:59 <mwc> Philippa: no, the GST and PST (federal and provincial sales taxes) get added on on top of that
06:10:18 <profmakx> one shouldnt call it value added tax, just plain added tax
06:10:22 <quicksilver> mwc: it's not as bad as it used to be. E.g. Apple kit is only about a 10% hike.
06:10:23 <Philippa> UK, not Canada
06:10:25 * desegnis always wondered why ft=mail does not deliver tw=72.
06:10:36 <quicksilver> profmakx: it is value added tax because the tax only applies on added value.
06:10:45 <mwc> profmakx: true, I don't see a whole lot of value being added :)
06:10:57 <profmakx> quicksilver, i know that, it was a joke
06:11:10 <quicksilver> But you're right, anway. 120G for $65.
06:11:12 <profmakx> (which isnt quite as funny as i thought)
06:11:18 <quicksilver> so the US is quite a bit cheaper :)
06:11:22 <mwc> quicksilver: oh that's nice. Here, the govn't takes 14% on top of every sale
06:11:24 * BMeph hides his copy of GHC from the VAT assayors
06:11:32 <Lycurgus> if there's no middle man there's no "value added"?
06:11:41 <quicksilver> Lycurgus: there is always a middle man
06:11:51 <Philippa> Lycurgus: middle men don't "add value"
06:11:53 <Lycurgus> not if I sell something I made.
06:12:16 <mwc> That's why the national soport of Cxnada (expecially since our dollar hit parity) is to drive to the USA to shop, and hide a bunch of shit in thr trunk, and hope customs doesn't find it
06:12:24 <desegnis> Lycurgus: You added value by making it.
06:12:53 <quicksilver> Lycurgus: right, you made it out of raw materials.
06:12:55 <quicksilver> unless you are God.
06:13:02 <quicksilver> so you added value to the raw materials.
06:13:06 <Lycurgus> so there's no difference if you create all the value or just add some?
06:13:14 <mwc> works expcially well for Laptops if you dump the box in a dumpster in Rochester
06:13:17 <quicksilver> If you create all the value then you added all the value :)
06:14:04 <desegnis> createFrom = foldr add nothing
06:14:04 <dmwit> mwc: Next time you're in Rochester, come visit me. =)
06:14:34 <Lycurgus> would be a good reason to vend ones product and services from the US if it weren't for financing fascists
06:14:37 <desegnis> Hrm, I forgot the added value in the equation :)
06:14:45 * dmwit wishes for a HUG
06:15:10 <Philippa> I think there're rather a lot of Haskell Using Geeks in here
06:15:41 <mwc> I think he means user group
06:15:55 * byorgey HUGs dmwit
06:16:03 <Philippa> yeah. Best way to do that's generally to start one
06:16:04 <mwc> I've seen a couple of posters in the math builing for haskell tutorial events
06:16:23 <mwc> I'm sure there's one on campus
06:20:24 <zx]treads> is there sth like python's dir() in ghci ? i mean like getting  a list of exposed symbols from an imported module
06:20:32 <dmwit> :browse
06:20:42 <dmwit> if <= 6.6.1, then :b will also do it
06:20:53 <zx]treads> dmwit: thx !
06:22:07 <desegnis> Btw, what was the rationale for changing the behavior of : in ghci? People not finding the command listing?
06:22:37 <dmwit> It was a bug. =P
06:22:56 <dmwit> It was perhaps the first example of a bug that really *was* a feature.
06:23:12 <desegnis> Hey, what...
06:23:22 <desegnis> It *was* a feature for me.
06:23:27 <dmwit> agreed
06:23:33 <desegnis> But hey, I'll type one letter more now.
06:23:39 * EvilTerran liked being able to type ":" to reload
06:24:32 <EvilTerran> what was "wrong" about the behaviour?
06:26:57 <dmwit> http://www.mail-archive.com/glasgow-haskell-users@haskell.org/msg13081.html
06:26:58 <lambdabot> Title: Re: ghci changes in 6.8 that are not improvements, http://tinyurl.com/2wur3v
06:27:18 <mwc> Oh well, I'm not desperate enoguh to continue trying to hack haskell over this damn laggy ssh
06:27:22 <dmwit> One of the funnier mails on that list, really. =P
06:27:29 <mwc> merry christmas to all
06:27:35 <dmwit> Bye mwc!
06:27:38 <mwc> I hope I get a lambda for christmas
06:27:39 <dmwit> Merry Christmas.
06:27:43 <mwc> http://www.mail-archive.com/glasgow-haskell-users@haskell.org/msg13081.html
06:27:44 <lambdabot> Title: Re: ghci changes in 6.8 that are not improvements, http://tinyurl.com/2wur3v
06:29:57 <Heffalump> it's been reinstated in 6.8.2, AFAIK
06:30:19 <Heffalump> at least, in a different form, namely that it repeats the last command or similar
06:31:00 <desegnis> Funny list reply:   âI knew about it too, though I'd assumed that it repeated the previous : command. It's just that ':r' is the only command I ever repeat.â
06:31:57 <Heffalump> that was me
06:32:38 <desegnis> ah, right
06:33:03 <Heffalump> :-)
06:33:08 * Cin chortles
06:33:28 <alexeevg> @seen dolio
06:33:28 <lambdabot> I haven't seen dolio.
06:42:21 <Zvpun> What do I do wrong? http://hpaste.org/4616 (This is actually part of the C to Haskell tutorial I am reading at the moment)
06:43:22 <Jaak> summAll [1,2]
06:43:29 <Jaak> :t 1:2
06:43:30 <lambdabot> forall t. (Num t, Num [t]) => [t]
06:43:39 <Jaak> :t [1:2]
06:43:40 <lambdabot> forall t. (Num t, Num [t]) => [[t]]
06:43:55 <quicksilver> Zvpun: you want [1,2], not [1:2]
06:44:04 <quicksilver> [1,2] or 1:2:[]
06:44:19 <Jaak> and
06:44:35 <Jaak> summAll [] = 0 should be (i think) sumAll [] = 0
06:44:45 <visof> > (lambda x -> x+x) 2
06:44:46 <lambdabot>  Parse error at "->" (column 11)
06:45:01 <visof> what is the wrong?
06:45:04 <Jaak> > (\x -> x + x) 2
06:45:05 <lambdabot>  4
06:45:10 <visof> oh
06:45:16 <visof> thanks
06:45:24 <visof> lambda = \
06:45:28 <visof> ok
06:45:43 <Zvpun> Jaak, quicksilver: thank you
06:48:14 <alexeevg> @where unsafeCoerce
06:48:14 <lambdabot> I know nothing about unsafecoerce.
06:48:22 <alexeevg> @doc unsafeCoerce
06:48:22 <lambdabot> unsafeCoerce not available
06:49:01 <Jaak> :t Unsafe.Coerce.unsafeCoerce
06:49:02 <lambdabot> Couldn't find qualified module.
06:49:39 <alexeevg> Jaak: is Unsafe.Coerce available in GHC 6.6 (no 6.6.1) ?
06:50:32 <zx]treads> instead of some sql haskell library + sql what can i use for a database?
06:50:40 <Saizan_> @index unsafeCoerce
06:50:41 <lambdabot> bzzt
06:50:58 <Jaak> alexeevg: I really don't know, sorry
06:50:59 <zx]treads> sth simple like using in a blog
06:50:59 <desegnis> @hoogle unsafeCoerce
06:50:59 <lambdabot> Unsafe.Coerce.unsafeCoerce :: a -> b
06:51:06 <desegnis> hm.
06:51:16 <Saizan_> zx]treads: some Maps
06:51:19 <vincenz> We should rename that to the C-operator :)
06:51:19 <lambdabot> vincenz: You have 2 new messages. '/msg lambdabot @messages' to read them.
06:51:36 <alexeevg> I'm trying to build dolio's CC_delcont on GHC 6.6
06:52:00 <quicksilver> zx]treads: hAppS contains a rather sophisticate persistence setup for things like that.
06:52:14 <Saizan_> zx]treads: or you could look at HAppS-IxSet which has been developed exactly for that
06:52:35 <zx]treads> ty
06:52:49 <alexeevg> First I got rid of {-# LANGUAGE GADTs #-}, but I don't know what to do with Unsafe.Coerce
06:53:32 <dave_> hello all, im a c++ programmer whose a complete newbie to haskell, im not asking anyone to hold my hand through the learning process but I have one major issue, Im a noob to linux running opensuse 10.3,  where/ which compiler should I use
06:53:34 <Saizan_> mmh maybe it was still unsafeCoerce# in 6.6?
06:54:02 <scook0> dave_: GHC is the compiler you want
06:54:15 <alexeevg> Saizan_: do I need to import something to make it available?
06:54:21 <dave_> can I get that through yast?
06:54:36 <scook0> probably
06:54:51 <Philippa> if you can't then it's unlikely you can get any haskell implementation through it
06:55:00 <alexeevg> Saizan_: Prelude> :s -fglasgow-exts
06:55:00 <alexeevg> Prelude> :t unsafeCoerce#
06:55:00 <alexeevg> <interactive>:1:0: Not in scope: `unsafeCoerce#'
06:55:20 <Saizan_> dave_: you can get a standard linux binary from here http://haskell.org/ghc/download_ghc_682.html#x86linux
06:55:57 <Saizan_> alexeevg: you surely need to import something, GHC.Exts maybe? i don't really remember
06:56:22 <alexeevg> Saizan_: thanks, it works
06:58:17 <dave_> gracias
07:00:18 <czShadoW> away
07:00:36 <czShadoW> I'm sorry, typo :)
07:04:44 <mdurr> given a function func :: (Storable a) => a  how can you find sizeOf a?
07:04:55 <mdurr> in the function
07:05:12 <mdurr> generics?
07:05:42 <Jaak> > sizeOf (undefined :: Int)
07:05:44 <lambdabot>   Not in scope: `sizeOf'
07:06:18 <Jaak> aah
07:06:40 <EvilTerran> > maxBound :: Int
07:06:41 <lambdabot>  2147483647
07:06:46 <EvilTerran> > minBound :: Int
07:06:47 <lambdabot>  -2147483648
07:07:41 <desegnis> @hoogle sizeOf
07:07:41 <lambdabot> Foreign.Storable.sizeOf :: Storable a => a -> Int
07:08:00 <benny91> > maxBound :: Int - minBound :: Int
07:08:01 <lambdabot>  Parse error at "-" (column 17)
07:08:05 <benny91> :(
07:08:05 <desegnis> Foreign.Storable.sizeOf (0 :: Int)
07:08:11 <mdurr> in the function I need to calculate how big of a pointer to malloc to hold type a
07:08:11 <desegnis> er
07:08:12 <EvilTerran> > logBase 2 $ fromIntegral (fromIntegral (maxBound :: Int) - fromIntegral (minBound :: Int))
07:08:13 <lambdabot>  31.999999999664098
07:08:15 <desegnis> > Foreign.Storable.sizeOf (0 :: Int)
07:08:15 <lambdabot>   Not in scope: `Foreign.Storable.sizeOf'
07:08:18 <EvilTerran> :P
07:08:19 <benny91> > (maxBound :: Int) - (maxBound::Int)
07:08:19 <lambdabot>  0
07:08:35 <benny91> > (maxBound :: Int) + (maxBound::Int)
07:08:36 <lambdabot>  -2
07:08:38 <Saizan_> mdurr: func = result where size = sizeOf result; result = ..
07:09:03 <benny91> > (maxBound :: Int) + (minBound::Int)
07:09:04 <lambdabot>  -1
07:09:31 <mdurr> Saizan_: thanks
07:09:34 <benny91> strange stuff :
07:09:44 <EvilTerran> or func x = ... where size = sizeof (func x)
07:10:08 <EvilTerran> seeing as sizeOf shouldn't evaluate its parameter
07:10:12 <desegnis> benny91, if you want to do it that way:
07:10:14 <EvilTerran> er, drop the x. still.
07:10:37 <benny91> why is the maxBound /= -minBound ?
07:10:39 <Saizan_> EvilTerran: you could pick a different "a" for the internal call of func
07:10:40 <desegnis> benny01, er, wait, EvilTerran wrote it already
07:10:49 <mdurr> well it is actually returning Maybe (a,b) but I think I can figure something out now, thanks all
07:11:12 <desegnis> benny91, because the size of the representation of an Int is an even number.
07:11:34 * benny91 feels stupid
07:11:50 <Saizan_> EvilTerran: in fact i think you'll get an "ambiguous type variable" error
07:11:51 <benny91> desegnis: is not stored as "sign-bit : number" ?
07:11:58 <mdurr> its great this channel is so helpful :)
07:12:11 <desegnis> benny91, I think it is
07:12:38 <desegnis> benny91, but you did count the 0?
07:13:47 <benny91> desegnis: hm :o
07:13:53 <benny91> desegnis: there was a -0 and a +0 then
07:14:07 <benny91> desegnis: in "ieee-standard-or-whatever storage"
07:14:21 <Saizan_> 0: take 31 (repeat 1) == 2^31 -1
07:15:07 <b_jonas> what does '0:' mean there?
07:15:16 <b_jonas> oh, you mean a list
07:15:20 <Saizan_> ints are usually stored as 2-complement numbers, so there's only one representation for zero
07:15:47 <Saizan_> b_jonas: yeah, it was funny syntax for bits :)
07:16:42 <benny91> Saizan_: sorry, 2 complement numbers ._. ?
07:17:14 <doserj> http://en.wikipedia.org/wiki/Two's_complement
07:17:15 <lambdabot> Title: Two's complement - Wikipedia, the free encyclopedia
07:17:15 <desegnis> Saizan_: Although always hanging around on IRC is a little stupid, I *do* learn something new here so often.
07:17:34 <b_jonas> 2s complement is when you store a binary number modulo 2^w
07:17:40 <b_jonas> where w is the number of bits in a word
07:17:50 <dmwit> Uh, it's a bit more than that.
07:17:54 <b_jonas> and 1s complement is when you store it modulo (2^w)-1
07:17:55 <dave_> yeah
07:18:12 <dmwit> The important part of 2s complement is that negative numbers are the complement of their positive counterpart.
07:18:18 <dave_> two's compliment is useful in binary arithimetic, when you want to subtract
07:18:24 <b_jonas> similarly, it's called 10-s complement and 9-s complement when it's a decimal number
07:18:31 <dave_> do what is called 'taking the twos comliment"
07:18:43 <dave_> which is simply turning every 1 into a 0 and every 0 into a 1
07:18:46 <b_jonas> dmwit: what does complement mean there?
07:18:50 <dave_> then you increment your inverted binary and add the two
07:18:53 <benny91> thanks :o
07:18:57 <dmwit> (The complement is just when you take the logical not of each bit.)
07:18:59 <benny91> wow, I started a conversation =D
07:19:05 <dave_> :-)
07:19:07 <b_jonas> but then what you said is 1s complement
07:19:12 <dmwit> Oh, yeah, and then add one.
07:19:16 <b_jonas> yep
07:19:23 <dave_> i just studied this shizzit in computer architecture -circuit design
07:19:24 <b_jonas> in 1s complement, not x = -x
07:19:27 <dave_> I had my final yesterday
07:19:31 <b_jonas> in 2s complement, not x = -1-x
07:19:38 <b_jonas> where not means complement each bit
07:19:55 <b_jonas> Knuth vol 2 describes these somewhat
07:20:09 <dmwit> Yeah, the off-by-one thing really makes or breaks it. =P
07:20:11 <Saizan_> http://en.wikipedia.org/wiki/Two%27s_complement
07:20:11 <lambdabot> Title: Two's complement - Wikipedia, the free encyclopedia
07:20:12 <dave_> I've never worried about the mathematical expression for the two's comliment, but im positive what I just said orks
07:20:41 <b_jonas> dmwit: I think that's what _fixes_ two's complement
07:20:46 <b_jonas> but it's a matter of looking at it
07:20:58 * benny91 learned some new basics today *hooray*
07:41:19 <mdurr> ok guess the Maybe a causes an issue because I have to evaluate the function to get the maybe to find the type of a to get the size which is required in the function
07:45:33 <moonlite> are there any function available that takes a tuple (a,b) and a function f and "returns" (f a, f b)
07:46:02 <doserj> @type Control.Arrow.&&&
07:46:02 <lambdabot> parse error on input `Control.Arrow.&&&'
07:46:07 <doserj> @type (Control.Arrow.&&&)
07:46:08 <dmhouse> ?type (&&&)
07:46:08 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
07:46:09 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
07:46:24 <doserj> for a = (->)
07:46:41 <dmhouse> Wait, that's not what you want.
07:46:44 <moonlite> i thought so too
07:46:50 <ricky_clarkson> How can I rephrase this so that djinn can solve it?
07:46:54 <Botje> @pl \f (a,b) -> (f a, f b)
07:46:54 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
07:47:02 <ricky_clarkson> @djinn [a] -> (a -> b) -> [[a]]
07:47:03 <lambdabot> -- f cannot be realized.
07:47:04 <dmhouse> > (show &&& (+1)) 4 -- that's what &&& does.
07:47:05 <lambdabot>  ("4",5)
07:47:32 <ddarius> ricky_clarkson: @djinn doesn't do lists
07:47:32 <doserj> ups. it's f***f
07:47:39 <ddarius> join (***)
07:47:56 <ricky_clarkson> ddarius: I realise that.  However, someone pointed out that you can always rephrase the question in terms of Maybe or some other monad.
07:48:06 <moonlite> thx
07:49:02 <ddarius> ricky_clarkson: That's not going to give answers that are trivially equivalent.
07:55:02 <moonlite> > join (***) (1,"wee")
07:55:03 <lambdabot>   add an instance declaration for (Arrow (,))
07:55:43 <ddarius> > join (***) (1+) (2,3)
07:55:44 <lambdabot>  (3,4)
07:56:56 <moonlite> > join (***) show (1,"wee")
07:56:57 <lambdabot>   add an instance declaration for (Num [Char])
07:56:57 <lambdabot>     In the expression: 1
07:57:13 <moonlite> ok, i got how i'll use it now at least
07:57:17 <moonlite> thx again
07:57:34 <b_jonas> @hoogle [a] -> (a -> b) -> [[a]]
07:57:35 <lambdabot> No matches, try a more general search
07:57:41 <b_jonas> I wonder how that would work
07:57:44 <ddarius> :t join (***)
07:57:45 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
07:58:20 <ddarius> b_jonas: It would ignore the second argument and be one of the countable infinity of functions [a] -> [[a]]
07:58:27 <Saizan_> mdurr: no, you don't have to evaluate anything to find the type
07:58:54 <b_jonas> only countable infinity?
07:59:03 <b_jonas> I think there are more than that
08:00:44 <Saizan_> mdurr: e.g func :: Storable a => Maybe a; func = result where size = sizeOf (fromJust result); result = .. -- since sizeOf doesn't use its parameter fromJust is never evaluated, so it doesn't matter if result == Nothing
08:07:54 <ddarius> b_jonas: There is only a countable infinity of programs period.
08:08:32 <b_jonas> ddarius: oh well
08:08:38 <dons> ?users
08:08:39 <lambdabot> Maximum users seen in #haskell: 434, currently: 379 (87.3%), active: 15 (4.0%)
08:08:45 <b_jonas> so countable infinite of those functions is recursive
08:08:58 <b_jonas> but I could imagine the rest of them to exist as well
08:09:19 <desegnis> OT question coming to my mind: Is there some relation (<) so that N < Q (where N, Q are the natural and rational numbers)? I have been disappointed learning that |N| = |Q|.
08:10:16 <doserj> desegnis: you can defined < however you like. What properties should < have?
08:13:12 <desegnis> doserj: It should meet my intuition that Q is somehow greater than N and have some more-or-less established name. Maybe it should be related to the existance of surjective but not injective functions from Q to N, like f(p/q) = p.
08:13:36 <desegnis> (Ignore the signum error in my example)
08:13:49 <Heffalump> p and q coprime?
08:13:56 <doserj> desegnis: there also are surjective, but not injective functions from N to Q
08:14:21 <desegnis> Heffalump: yes
08:15:24 <quicksilver> desegnis: how about subset?
08:15:28 <quicksilver> desegnis: N is a subset of Q.
08:15:32 <quicksilver> desegnis: that's a relation :)
08:15:34 <desegnis> doserj: Hm, right...
08:15:44 <desegnis> quicksilver, hey, that's a fine one :)
08:15:56 <quicksilver> howabout this:
08:16:09 <quicksilver> all order-preserving maps from N to Q are injective but not surjective
08:16:15 <quicksilver> does that help your intuition?
08:16:17 <yrlnry> One intitive way that Q is "bigger" than N is that it is dense, and N is not.
08:16:46 <quicksilver> somehow the "ordering" is a kind of "topology". If you use that to limit the maps you consider
08:16:57 <quicksilver> then you do indeed come to the conclusion one is "smaller"
08:17:03 * desegnis will lookup dense sets
08:17:38 <yrlnry> Dense just means that for any rational numbers p < q, there is rational x with p < x< q.
08:18:14 <desegnis> ah, so it is about ordering, too
08:18:19 <quicksilver> yes
08:18:25 <desegnis> Let me think...
08:18:28 <quicksilver> you need some structure, to tell them apart.
08:18:40 <quicksilver> if you just view them as sets, they are equal.
08:18:42 <yrlnry> Yes.   If you want Q to be different from N, you have to consider some property that they have that is not just about their being sets.
08:18:45 <yrlnry> Because
08:18:47 <quicksilver> but if you consider also the ordering or the arithmetic
08:18:49 <doserj> and quicksilver and yrlnry assume that the natural order is somewhat special :)
08:18:52 <yrlnry> I was about to say what quicksilver just said.
08:18:55 <quicksilver> then you can find ways to tell them apart.
08:19:07 <quicksilver> doserj: it's not special. It's part of the definition.
08:19:08 <ddarius> You need a topology not necessarily an order for the notion of "dense"
08:19:14 <quicksilver> doserj: Q is not just a set
08:19:20 <quicksilver> doserj: Q is a set with some operations, including an order.
08:19:31 <quicksilver> in that sense, the natural order is special, because it is part of what Q is.
08:19:38 <yrlnry> Well, your intuition about Q and N is based on their arithmetic properties.  So if you want an intuitive reasons for saying N < Q, it is natural to look at the artihmetic properties.
08:19:45 <quicksilver> If Q was just a set, it would indeed be indistinguishable from N.
08:19:52 <doserj> Q is a set of equivalence classes of pairs of integers. the definition of order comes after that :)
08:20:00 <quicksilver> no, that's one definition.
08:20:06 <quicksilver> and even that is wrong.
08:20:15 <quicksilver> Q is not just a set of equivalence classes.
08:20:26 <quicksilver> Q is a set of equivalences classes together with a whole bunch of operations.
08:20:27 <ddarius> quicksilver: They'd still be distinguishable.
08:20:29 <quicksilver> including order.
08:20:33 <yrlnry> To construct the equivalence classes in the first place, you need to have defined arithmetic operations on integers.
08:20:41 <doserj> yrlnry: yes
08:20:50 <desegnis> If I have a set M that is isomorphic (hope that's the word I mean) to N, but which does not have defined an order on itself per se... will I still need to resort to an ordering to describe M âsmallerâ than Q? (Or is the order obvious due to the isomorphism?) -- Hey, I cannot read and write at the same time! :P
08:21:15 <quicksilver> desegnis: there are a bunch of ways you can imagine defining 'smaller'
08:21:29 <quicksilver> desegnis: for the most obvious ways, the fact you have an isomorphism means it obviously isn't :)
08:21:40 <quicksilver> but you can try some topological approachs, explicitly or implicitly.
08:21:49 <Valodim> can I have guards after a let .. in?
08:21:55 <ddarius> quicksilver: As you said, M can be a subset of N while N isn't a subset of M.
08:21:56 <quicksilver> orders can give rise to topologies, but there are other ways of coming to the natural topology on Q
08:22:15 <ddarius> Valodim: You can have them on any function declaration, local or otherwise, or any case expression.
08:22:19 <quicksilver> Valodim: you can have guards inside the let
08:22:35 <quicksilver> Valodim: but "after" doesn't really make sense. A let ... in is a complete expression.
08:22:43 <quicksilver> Putting a guard on an expression doesn't really make sense.
08:22:59 <Valodim> so I have to put () around the in expression including the guards?
08:22:59 <desegnis> quicksilver, ddarius: Above I imagined M not being a subset of Q, but M being âsmallerâ than Q in the same sense that I wnat N to be âsmallerâ than Q.
08:23:06 <gwern> I should probably stop following darcs cabal - it keeps breaking stuff like yi
08:23:07 <quicksilver> ddarius: it is normal to consider isomorphic things indistinguishable, which is what I meant.
08:23:20 <quicksilver> ddarius: clearly there is a different between Q and N in that Q contains 1.5 and N doesn't.
08:23:23 <Valodim> well it gives a syntax error that's why I'm asking
08:23:26 <quicksilver> ddarius: but that's not what I was getting at.
08:23:27 <ddarius> quicksilver: For categorist, not for set theorists.
08:24:02 <Valodim> I'll just stick to where :P
08:26:21 <ddarius> desegnis: Then, as quicksilver was saying, once you add intemediating functions the natural notion of "same" is isomorphic (or just bijective for sets) and you get the "normal" notion of size, so you must add structure and use functions which preserve that structure.
08:28:59 <BMeph> quicksilver: Is the sset of even integers "smaller" than the set of all integers?
08:29:15 <ddarius> BMeph: You have to define "smaller".
08:29:35 <ddarius> BMeph: However with the "usual" notion, no.
08:29:58 <desegnis> ddarius, I interpret that like: Isomorphic relates to structure, and the structure of N includes its ordering; so the structure of M includes an identical ordering. - Does that meet your point?
08:30:13 <BMeph> ddarius: Why not? Every even integer is an integer = the even integer set is a subset of the integers.
08:30:50 <BMeph> Similarly, there's a 1-1 function mapping the non-negative integers to the rationals
08:30:58 <doserj> BMeph: the usual notion of smaller is "lower cardinality"
08:31:18 <desegnis> BMeph: The definition I've not yet found says yes, but mathematically, I think that  |{ z <- Z | even z }|  =  |Z|
08:31:54 <BMeph> doserj: But not in this instance, since, Q and N have the same cardinality, but we're trying to make N "smaller" than Q.
08:32:00 <ddarius> desegnis: If you are working with posets then arguably the natural morphisms are the monotonic functions which don't have to use the same ordering, they just need to preserve the relationship.
08:32:12 <doserj> BMeph: then define "smaller" :)
08:32:37 <ddarius> desegnis: In fact, this must be what you do if M is not a subset of N because an ordering works on some specified domain.
08:34:10 <ddarius> (Technically, you could even say they have to be the same set as you'd still need to inject the subset into the superset to apply the ordering.)
08:35:44 <desegnis> Does âtechnicallyâ mean âreallyâ or âin some senseâ?
08:35:55 <BMeph> doserj: It's not going to be satisfying, because subset seems to be the only meaningful way to class it. However, some supersets (i.e., R) have a higher cardinality than certain of their subsets.
08:36:44 <yrlnry> All nonempty sets have a higher cardinality than certain of their subsets.  :)
08:37:14 <ddarius> desegnis: Oftentimes the injection is taken tacitly, but given A subset of B, (<) : BxB -> Bool is different than (<) : AxA -> Bool
08:37:15 <doserj> BMeph: to class *what*?
08:38:01 <quicksilver> BMeph: no, it's not by my definition of smaller.
08:38:10 <desegnis> ddarius, right
08:38:12 <quicksilver> BMeph: it's not even by my extended order-preserving definition
08:38:15 <BMeph> doserj: Sorry - to classify/define what it means for a set to be "smaller" than another.
08:38:23 <quicksilver> (there is an order-preserving bijection between N and 2N)
08:38:37 <quicksilver> I think you have to struggle pretty hard to find a sense in which 2N is smaller than N
08:38:47 <BMeph> quicksilver: There is an order-preserving bijection between N and Q, as well.
08:38:53 <quicksilver> strict subset inclusion, no renaming permitted, is the best you can do.
08:38:58 <quicksilver> BMeph: There is no such thing!
08:39:07 <quicksilver> BMeph: definitely not.
08:39:13 <quicksilver> BMeph: N has order-type omega.
08:39:21 <BMeph> Hold on, I'll find the paper.
08:39:25 <quicksilver> Q has an exotic order-type whose name I do not know.
08:39:31 <quicksilver> (maybe it's just called Q?)
08:39:32 <BMeph> ?go pearl rational
08:39:33 <lambdabot> http://www.ibm.com/developerworks/forums/thread.jspa?messageID=13906365
08:39:34 <lambdabot> Title: developerWorks : Rational : Pattern Solutions : Pearl Circle Online Auction ...
08:39:54 <BMeph> ?go pearl rational functional
08:39:56 <lambdabot> http://web.comlab.ox.ac.uk/oucl/work/jeremy.gibbons/publications/rationals.pdf
08:40:22 <quicksilver> BMeph: that demonstrates an elegant bijection
08:40:28 <quicksilver> I don't deny the existance of bijections
08:40:36 <quicksilver> given a moment, I could think of a few, I believe.
08:40:42 <quicksilver> but it certainly isn't order-preserving.
08:40:46 <quicksilver> Which is the key point here.
08:40:50 <yrlnry> quicksilver: Let S be a set.  Say the "density" of S is  lim(n->inf) |{k in S: k<n}| / n  , if such limit exists.
08:40:58 <yrlnry> The density of N is 1, but the density of 2N is 1/2.
08:41:21 <quicksilver> yrlnry: yes, that's a reasonable notion.
08:41:23 <yrlnry> Maybe that qualifies as "struggling pretty hard", but it is a pretty common number-theoretic notion
08:41:51 <quicksilver> I also note that while N,0,+ and 2N,0,+ are isomorphic as monoids
08:42:00 <quicksilver> N,0,* and 2N,0,* are not
08:42:07 <quicksilver> maybe you can wrestle something out of that
08:42:15 <quicksilver> they're the same as additive monoids but they aren't the same field.
08:42:27 <quicksilver> s/0/1 in the second line :)
08:42:46 <ddarius> They are not a field at all.
08:43:15 <yrlnry> Yeah, 2N has no multiplicative identity.  But any solution based on that is going to be pretty unsatisfying, wince it will work for the even numbers but not for the odd ones.
08:43:15 <quicksilver> yeah, sorry, I'm being sloppy.
08:43:32 <quicksilver> yrlnry: that's not the only failure of isomorphism though
08:43:44 <quicksilver> yrlnry: there is the mere fact that each multiplication 'scales you up another k'
08:43:44 <yrlnry> If one has a notion in which the even numbers are "smaller" than the naturals, I would hope it would apply to the odd numbers also.
08:43:54 <desegnis> yrlnry: I wouldn't be able to compute that limit off-hand of a given set, but it looks useful.
08:43:54 <cpst> of course there isn't an order-preserving bijection
08:43:58 <cpst> Q is a dense linear ordering
08:44:02 <cpst> N isn't lol
08:44:09 <desegnis> (i.e., useful to me)
08:44:09 <yrlnry> cpst: we've been over that already.
08:44:16 <quicksilver> does anyone know what the ordinal for Q is called?
08:44:27 <quicksilver> ah
08:44:28 <doserj> ?
08:44:30 <quicksilver> Q isn't well ordered
08:44:33 <quicksilver> so it's not an ordinal.
08:44:40 <doserj> !
08:44:41 <quicksilver> I'm clearly too tired. Friday, nearly christmas.
08:44:43 <yrlnry> desegnis: it is very useful.
08:45:05 <quicksilver> However is there a special name for the order-type of Q? Or is it just called Q?
08:45:05 <cpst> quicksilver: Cantor's notation for the order type of the rationals was eta
08:45:10 <yrlnry> desegnis: for example, it is an amazing theorem that the density of the primes is 1/log(n).
08:45:44 <ddarius> desegnis: Just a little complex analysis...
08:45:51 <ddarius> er yrlnry
08:45:54 <yrlnry> (You need to tweak my definition of "density" a bit.)
08:46:49 <ddarius> Which reminds me... shite
08:47:07 <desegnis> ^^
08:49:55 <yrlnry> Is there a standard notation for the order type of the negative integers?
08:49:59 <dons> ?uptime
08:50:00 <lambdabot> uptime: 4d 11h 3m 34s, longest uptime: 1m 10d 23h 44m 29s
08:50:44 <desegnis> Just to make this clear, if I have my next mathematical problem, I'll know where to ask!
08:52:01 <quicksilver> yrlnry: -omega, maybe?
08:52:04 <quicksilver> yrlnry: I'm not sure :)
08:52:24 <b_jonas> prolly no.
08:52:37 <b_jonas> because there's not much you can say on ordering types in general
08:52:51 <b_jonas> people consider more special cases, like well-orderings (ordinals)
08:57:24 <harlekin> When I want to close a terminal, I type exit. But since a few days, I have to hit alt-j for it to disappear. Otherwise the window's still there but halts the exit command. Is this a bug or a feature? :D
08:58:07 <doserj> your terminal is written in haskell?
08:58:45 <dons> harlekin: wrong channel?
08:58:55 <harlekin> dons: Yeah, pretty much. :D Sorry.
08:59:34 <b_jonas> there's lattice theory but I wouldn't say it's about special partial ordering _types_
09:00:10 <quicksilver> b_jonas: in a sense a lattice is precisely a partial ordering type, though :)
09:00:27 <b_jonas> quicksilver: it's a special partial ordering type, yes
09:00:35 <quicksilver> b_jonas: so maybe the study of ordering types is just the study of totally ordered lattices
09:00:36 <b_jonas> but I think the theory is not really about the types
09:01:02 <b_jonas> that is, it won't, like, define addittion and multiplication like operations on such types
09:01:53 <quicksilver> true
09:02:36 <b_jonas> sort of like how in number theory, you work with operations on ideals in a ring, not operations on whole rings
09:03:06 <b_jonas> (and operations on elements of the ring of course, but that's what makes a ring an algebraic structure)
09:04:10 * roconnor smells the yonada lemma lurking
09:05:23 <pejo> @quote yoneda
09:05:24 <lambdabot> slava says: Because top enterprise industry analysts recommend that managers need to focus on Agile methodologies, SOA, B2B and Yoneda's lemma in today's rich internet application-driven environment.
09:05:24 <lambdabot>  Don't get left behind by the AJAX craze by missing out on call center outsourcing and Yoneda's lemma!
09:06:00 <cpst> what's this inside joke about the Yoneda lemma?
09:06:02 * noteventime shoots agile methods
09:06:02 <roconnor> :D
09:06:24 <roconnor> wow, eating an orange is more difficult while drunk
09:06:32 <roconnor> I wonder if I can still do math
09:06:41 <ehaas> what time is it where you live
09:06:58 <roconnor> 18:06
09:07:02 <ddarius> Cheybshev is spelled so many different ways.
09:07:05 <ehaas> nice
09:07:29 <roconnor> we had some sake to celebrate the last Aikido class of the year
09:07:38 <roconnor> but I still want to construct this counter example
09:08:08 <b_jonas> what counterexample?
09:08:11 <cpst> what counterexample?
09:08:34 <Saizan_> now we also have questions in stereo?
09:08:43 <roconnor> that when you map (ie compose) a uniformly continuous function over step functions, the result is a uniformly continuous function from step functions to step functions
09:08:54 <b_jonas> Saizan_: an echo
09:09:25 <roconnor> (with the same modulus of continuity)
09:10:34 <b_jonas> what counts as a step function?
09:12:03 <doserj> piecewise constant?
09:12:16 <cpst> and which metric on the step functions?
09:12:29 <roconnor> cpst: ah good point
09:12:32 <roconnor> cpst: L1
09:12:40 <roconnor> with L_inf, then I think it is true
09:15:56 <roconnor> crap, the counter example I had in mind doesn't work :(
09:17:14 <roconnor> er maybe I'm doing it wrong
09:17:45 <dons> > (head . drop 1000000 $ [1..]) :: Integer
09:17:47 <lambdabot>  Exception: stack overflow
09:17:49 <dons> > (head . drop 1000000 $ [1..]) :: Int
09:17:50 <lambdabot>  1000001
09:18:01 <dons> anyone got time to look at that?
09:18:15 <roconnor> nope doesn't work
09:18:52 <allbery_b> that the "Integer isn't' lazy enough" problem with enumFrom?
09:19:14 <ddarius> dons: It's already answered on the Stack overflow page.
09:19:15 <allbery_b> (or something like that;s till fuzzybrained.  damn bronchitis robbing me of sleep)
09:21:39 <ddarius> :t enumFrom
09:21:41 <lambdabot> forall a. (Enum a) => a -> [a]
09:21:42 <ddarius> :t iterate succ
09:21:43 <lambdabot> forall a. (Enum a) => a -> [a]
09:22:21 <ddarius> @src Int enumFrom
09:22:22 <lambdabot> Source not found. You type like i drive.
09:22:29 <ddarius> @src enumFrom
09:22:29 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
09:22:39 <ddarius> @src Integer enumFrom
09:22:41 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
09:27:59 <ddarius> dons: "	-- Blarg: technically I guess enumFrom isn't strict!"
09:29:30 <yrlnry> :t map map
09:29:31 <lambdabot> forall a b. [a -> b] -> [[a] -> [b]]
09:29:42 <yrlnry> :t map . map
09:29:43 <lambdabot> forall a b. (a -> b) -> [[a]] -> [[b]]
09:29:50 <desegnis> > (head . drop 1000000 $ enumFromTo 1 (10^1000)) :: Integer
09:29:51 <lambdabot>  1000001
09:29:56 <byorgey> :t (map .) . map
09:29:57 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `[b1]'
09:29:57 <lambdabot>     In the second argument of `(.)', namely `map'
09:32:06 <BMeph> o.O
09:32:50 <ddarius> @wiki Stack overflow
09:32:50 <lambdabot> http://www.haskell.org/haskellwiki/Stack_overflow
09:33:51 <jmob> :t mapM
09:33:52 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
09:34:01 <roconnor> > logBase 3 2
09:34:03 <lambdabot>  0.6309297535714574
09:34:27 <jmob> :t Data.HashTable
09:34:28 <lambdabot> Couldn't find qualified module.
09:34:41 <jmob> :t HashTable
09:34:42 <lambdabot> Not in scope: data constructor `HashTable'
10:10:09 <sclv_> @quote
10:10:10 <lambdabot> JaffaCake says: Casting boxed types to unboxed types or vice versa is pretty much guaranteed to end in tears
10:11:33 <yrlnry> @quote
10:11:33 <lambdabot> twifkak says: [on dons] i wonder if he and SPJ have a bet going for "most newbs recruited in '07"
10:12:54 <ehaas> how does spj recruit newbs
10:13:49 <ddarius> ehaas: Videos, talks, presence.
10:13:57 <noteventime> Is merge sort O(n^2) when used on a linked list?
10:14:08 <ddarius> noteventime: It shouldn't be.
10:14:12 <pejo> ehaas, his oscon speech probably attracted quite a lot of people.
10:14:57 <noteventime> ddarius: Each step requires that you split the list into two. which is n/2, isn't it?
10:15:06 * noteventime is still not used to this :-)
10:15:37 <noteventime> Or is it linear
10:15:47 <noteventime> err, n
10:16:03 <noteventime> I just realised n/2 was also linear
10:16:59 <BMeph> noteventime: It depends on if you already know the length of the list: after all, after the first split, you could use auxiliary functions that are also passed the length of the list halves that they're given.
10:17:34 <ehaas> mergesort is actually one ofthe better sorts for linked lists...it shouldnt be n^2
10:17:52 <noteventime> hmm
10:18:07 <noteventime> I think it's the splitting part that's confusing me
10:18:25 <Saizan_> sort (in ghc at least) is implemented as a merge sort, you can look at how they've written it
10:18:27 <ehaas> what confuses you about it
10:18:43 <ehaas> why it works or the complexity?
10:19:00 <noteventime> ehaas: The way it affects the complexity of merge sort
10:19:59 <yrlnry> On average, the entire list gets split about log(n) times, and each scan-and-split runs in O(n) time.  So that's there n log n comes from.
10:21:15 <noteventime> yrlnry: Worst case though?
10:21:39 <yrlnry> Oh, in the worst case it's O(n^2) because it recurses n times instead of log(n).
10:21:56 <yrlnry> Excuse me, I just realized you were discussing mergesort.
10:22:04 <ehaas> i thought mergesort is n log n
10:22:06 <ehaas> worst cast
10:22:12 <yrlnry> Please ignore everything I said; I read quicksort for some reason.
10:22:45 <noteventime> ehaas: Also for linked lists?
10:22:48 <ehaas> are you familiar with telescoping...
10:23:00 <ehaas> been awhile since i took an algorithms class
10:23:26 <noteventime> ehaas: No, but I'm looking it up now :-)
10:23:53 <ehaas> T(n) = 2T(n/2) + n
10:24:21 <dons> ddarius: i'm going to propose we fix these atomic strictness issues with Integer
10:24:37 <ehaas> worse case you can get the length of the list in O(n) and pass that through
10:24:42 * ddarius is reminded of a paper on Mellin Transforms he downloaded recently but hasn't read yet.
10:25:01 <ddarius> dons: The issue in your particular example was a "bug" in the Int instance of Enum.
10:25:32 <dons> ddarius: well... Int is stricter, as it is in a lot of code in the libraries
10:25:40 <dons> i think its a bug that Integer isn't also stricter
10:25:45 <dons> enumFrom' :: Integer -> [Integer]
10:25:45 <dons> enumFrom' x = enumDeltaInteger  x 1
10:25:45 <dons> enumDeltaInteger :: Integer -> Integer -> [Integer]
10:25:45 <dons> enumDeltaInteger x d = x `seq` x : enumDeltaInteger (x+d) d
10:25:48 <ddarius> I'm not exactly sure what the Report specifies
10:25:49 <dons> is what was missing.
10:25:54 <noteventime> Could you just do a slow split the first time, and then keep passing splitAt with half the "current" length?
10:25:55 <dons> it doesn't specify strictness properties
10:26:17 <dons> we talked the other day about the irregular strictness applied to Num Integer code
10:26:22 <jmob> Does reverse force the whole list?
10:26:33 <noteventime> Anyway, thanks for the help
10:26:40 <dons> jmob: it forces the spine
10:26:50 <noteventime> I think I need to get used to this before I start discussing it seriously :-)
10:26:56 <Valodim> what's the spine of a list?
10:26:59 <jmob> dons: what is a spine?
10:27:09 <yrlnry> The cdrs, without the cars.
10:27:11 <mauke> the structure, not the values
10:27:35 <jmob> ah
10:27:45 <yrlnry> the same thing that length forces.
10:28:40 <ddarius> dons: The Report tends to be as lazy as possible, though it does not say anything clear on this particular issue.
10:29:05 <dons> yep. lazy to the point of failure :)
10:29:19 <ddarius> Indeed.
10:29:24 <jmob> Would it make sense to get a warning if you did "map f someList" in a do construct where f was some function that produced monad updates?
10:29:50 <ddarius> jmob: You should just get a type error
10:30:05 <jmob> since the state updates that f produces aren't seen unless you do mapM
10:30:33 <jmob> ddarius: return $ map f ls
10:31:01 <int-e> jmob: that looks entirely plausible
10:31:09 <ehaas> noteventime: i'm not good at reasoning about laziness but i don't think it matters...remember that your lists are half as big with each iteration
10:31:19 <ddarius> jmob: That's perfectly legitimate code.
10:31:25 <int-e> jmob: in the sense that there are good reasons to write code that produces a list of actions which will be performed later.
10:31:46 <ehaas> so it's not O(N) work for each one
10:32:04 <int-e> (for example they could be cleanup actions)
10:32:14 <jmob> Interesting ... so those state updates could be passed around, and/or just performed later?
10:32:21 <ddarius> Of course.
10:32:24 <ddarius> :t sequence
10:32:27 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
10:32:30 <int-e> jmob: yep
10:32:54 <int-e> @type sequence
10:32:54 <jmob> Oh, cool
10:32:55 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
10:33:05 <int-e> jmob: using sequence for example.
10:34:50 <ehaas> noteventime: i mean twice as big :)
10:35:00 <fons> hi all
10:35:13 <noteventime> hullo fons
10:35:29 <noteventime> ehaas: You do? O_o
10:35:32 <noteventime> Why's that?
10:35:48 <jmob> OK, this stems from a problem I was having with not seeing HashTable updates, I figured out that I needed mapM instead of map to "merge" the updates in to the monad, though I didn't quite understand the usefulness of being able to do the computation without seeing the effects (I do now though)
10:36:07 <noteventime> ehaas: Anyway, I'll continue reading :-)
10:36:09 <ehaas> noteventime: first you go through your list treating it as a bunch of 2-element lists
10:36:17 <ehaas> then 4-element lists
10:36:18 <ehaas> etc.
10:36:20 <noteventime> Ohh
10:36:28 <noteventime> I thought you meant each recursion
10:36:55 <ehaas> ok
10:37:00 <noteventime> I think I need to go on reading until I can properly reason about algorithm complexity :-D
10:37:25 <noteventime> Has anyone read Introduction to algorithms?
10:37:26 <ddarius> jmob: The whole thing is that the computations -aren't- "done".  Computations (like everything else) are values.  They don't get executed until you use (>>=) or some "run" function (or bind it to main for IO).
10:37:26 <ehaas> you make N "traversals" each time...and do it log N times
10:37:27 <ehaas> ok
10:38:02 <noteventime> Is it just me or does it take for granted that you're using an imperative language with pointer arithmetic?
10:38:53 <ehaas> take a look at List.sort
10:52:36 <dons> > head (take 1000000 (1 .. 1000000000000))
10:52:37 <lambdabot>  Parse error at ".." (column 23)
10:52:40 <dons> > head (take 1000000 (1 .. 1000000000000]))
10:52:41 <lambdabot>  Parse error at ".." (column 23)
10:53:04 <dons> > head (drop 1000000 [1 .. 1000000000000])
10:53:06 <lambdabot>  1000001
10:53:09 <dons> > head (drop 1000000 [1 .. ])
10:53:10 <lambdabot>  Exception: stack overflow
10:53:12 <dons> heh
10:53:51 <dons> > head (drop 1000000 [ 1000000000000, 999999999999 .. ])
10:53:52 <lambdabot>  Exception: stack overflow
10:54:30 <dons> interesting
10:54:37 <dons> > head (drop 1000000 [ 1000000000000, 999999999999 .. 0 ])
10:54:38 <lambdabot>  999999000000
10:54:48 <vincenz> dons: odd it flows on ..
10:55:01 <ddarius> enumFromTo has to be strict(er)
10:55:12 <dons> yep, it checks the lim
10:55:28 <vincenz> enumFrom could probably be strictified,
10:55:29 <dons> so although its written in a lazy style, that's enough for the strictness analyser
10:55:33 <dons> vincenz: quite so!
10:55:40 <dons> esp. since Int already is.
10:55:43 * dons darcs records
10:55:44 <vincenz> enumFrom !x
10:56:21 <dons> ddarius: do you remember what the other Integer strictness issue we had the other day was?
10:56:36 <dons> > foldl (+) 0 [1 .. 1000000]
10:56:38 <lambdabot>  Exception: stack overflow
10:56:40 <dons> > foldl (+) 0 [1 .. 1000000 :: Int]
10:56:47 <lambdabot>  1784293664
10:56:53 <vincenz> o.
10:56:57 <ddarius> dons: Unless by "other day", you mean like a month ago, I think I wasn't in the conversation you're referring to.
10:57:06 <int-e> > sort (take 1000000 [1..])
10:57:07 <lambdabot>  Exception: stack overflow
10:57:12 <dons> ok, 2 days ago we discussed the foldl here.
10:57:34 <dons> ghc can see through the (+) strictness for Int, not for Integer
10:57:57 <int-e> > sort [1..1000000]
10:57:59 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
10:58:31 <dons> actually, ghc 6.8 can see Integer strictness there, but not 6.6
10:58:41 <dons> so 6.8 does get foldl (+) on Integer right
10:58:54 <yrlnry> > [10..1]
10:58:56 <lambdabot>  []
10:59:06 <ddarius> Bah, foldl is wrong anyway.
10:59:12 <BMeph> >[10,9..1]
10:59:27 <roconnor> > [10, 9 .. 1]
10:59:28 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
11:00:02 <BMeph> :-(...
11:00:03 <b_jonas> hmm
11:00:08 <b_jonas> how does that work?
11:00:22 <ddarius> :t enumFromThenTo
11:00:24 <lambdabot> forall a. (Enum a) => a -> a -> a -> [a]
11:01:24 <yrlnry> @source enumFromThenTo
11:01:24 <lambdabot> enumFromThenTo not available
11:01:32 <ddarius> @src enumFromThenTo
11:01:32 <lambdabot> Source not found. I am sorry.
11:01:34 <ddarius> @src Enum
11:01:35 <lambdabot> class  Enum a   where
11:01:35 <lambdabot>     succ                     :: a -> a
11:01:35 <lambdabot>     pred                     :: a -> a
11:01:35 <lambdabot>     toEnum                   :: Int -> a
11:01:35 <lambdabot>     fromEnum                 :: a -> Int
11:01:37 <lambdabot> [3 @more lines]
11:01:45 <ddarius> @more
11:01:45 <lambdabot>     enumFrom                 :: a -> [a]
11:01:46 <lambdabot>     enumFromThen, enumFromTo :: a -> a -> [a]
11:01:46 <lambdabot>     enumFromThenTo           :: a -> a -> a -> [a]
11:01:56 <yrlnry> Perl's ".." operator also produces an empty result when the left operand exceeds the right, and people sometimes argue that it should count backwards in that case.
11:02:06 <ddarius> yrlnry: Those people are wrong.
11:02:11 <yrlnry> Clearly.
11:02:24 <yrlnry> [10..10]
11:02:36 <yrlnry> >[10..10]
11:02:40 <yrlnry> > [10..10]
11:02:41 <Valodim> what's wrong about that?
11:02:42 <lambdabot>  [10]
11:02:53 <yrlnry> Valodim: It breaks pretty much every sensible use of .. .
11:02:57 <int-e> you can't get an empty list anymore
11:03:15 <Valodim> [10, 9..1] to result in a list from 10 to 1 sounds perfectly reasonable to me
11:03:31 <ddarius> Valodim: That's not the same as [10 .. 1]
11:03:33 <yrlnry> I'm not talking about [10, 9 .. 1].  I'm talking about [10 .. 1].
11:03:36 <Valodim> oh
11:03:41 <Valodim> yeah that's right
11:03:45 <Valodim> that should be empty
11:03:50 <yrlnry> Clearly.
11:03:54 <Valodim> Quite.
11:04:32 <b_jonas> actually,
11:04:43 <b_jonas> if you have the .. operator exclude the upper limit
11:04:48 <int-e> It might work in Python (where range(a,b) returns [a..b-1], so range(a,a) is empty).
11:04:59 <b_jonas> which is I belive a much better choice than the perl or haskell way
11:05:02 <b_jonas> then you can do that
11:05:16 <b_jonas> and indeed, J does that with the iota operator
11:05:30 <b_jonas> (i. 5) results in 0 1 2 3 4
11:05:56 <int-e> (But even in Python, range(a,b) with a>b is empty)
11:06:07 <b_jonas> (i. ) results in the empty list
11:06:11 <b_jonas> I mean (i. 0)
11:06:27 <b_jonas> and (i. _5) results in 4 3 2 1 0
11:06:49 <int-e> hmm, positive numbers?
11:06:52 <b_jonas> though of course that makes more sense because other operators use negative indexing in similar ways
11:07:08 <b_jonas> like, negative index in indexing an array counts from the end
11:07:34 <b_jonas> negative index -n in take/drop takes or drops the last n elements of the list
11:07:35 <b_jonas> etc
11:07:48 <b_jonas> (note that those lists are arrays, not linked lists)
11:08:15 <b_jonas> yes, positive numbers so it's not the same
11:08:22 <ddarius> b_jonas: So call them arrays. Don't be corrupted by python.
11:08:30 <b_jonas> ddarius: no,
11:08:37 <b_jonas> arrays can mean arbitary dimensions
11:08:44 <b_jonas> rank-1 arrays are lists or vectors
11:08:49 <b_jonas> rank-2 are matrices or tables
11:08:51 <ddarius> vectors is acceptable
11:08:54 <b_jonas> rank-0 are atoms or scalars
11:08:56 <yrlnry> xectors.
11:09:00 <b_jonas> yep, vectors can be better
11:09:18 <b_jonas> however, if I talk about the uppermost axis of a (possibly higher than 1 rank) array,
11:09:22 <b_jonas> then I think list is the good word
11:09:34 <jmob> HXT is pretty impressive, it's very fast
11:09:35 <ddarius> b_jonas: Anyway, that's fine for J but van Rossum is just a crack head.
11:09:44 <b_jonas> so negative indexing a matrix counts rows from the end
11:09:56 <b_jonas> ddarius: yes, I don't like python either
11:10:29 <b_jonas> I mean, list in that context is better than _1-frame
11:10:58 <b_jonas> but yes, J has very strange terminology sometimes
11:11:03 <b_jonas> like, it calls unary verbs "monads"
11:11:08 <b_jonas> and binary verbs "diads"
11:11:17 <ddarius> That comes from APL
11:11:20 <b_jonas> yep
11:11:30 <yrlnry> I believe the trademark on *that* term was taken up some time ago by G.W. Leibniz, and *all* of us are misusing it.
11:11:33 <b_jonas> but it conflicts with the haskell meaning of "monad"
11:11:47 <ddarius> b_jonas: I don't think that that is a significant issue.
11:12:00 <b_jonas> ddarius: yep
11:12:01 <ehaas> when i first learned about haskell i thought monads were derived from leibniz philosophy :)
11:12:08 <b_jonas> some of J terminology is very obscure though
11:12:48 <b_jonas> more obsucre than apl, both because J has higher-level concepts to name and because Ken has learnt more obscure English words by the time he's made J
11:15:11 <ehaas> are there any good haskell libraries for interfacing to a sound card (say i have a bunch of bytes that i want to play as a sound)
11:16:06 <jmob> ehaas: What OS?
11:16:08 <ehaas> linux
11:16:19 <jmob> ehaas: write to /dev/esd ?
11:16:26 <jmob> or somethign similar
11:16:30 <ehaas> ok i'll look into that
11:16:32 <ehaas> thanks
11:16:33 <jmob> /dev/dsp i mean
11:16:40 <ehaas> k
11:17:26 <ddarius> ehaas: I made a LADSPA binding that I could finish packaging up.
11:18:15 <ehaas> i actually dont know what that is
11:19:16 <jmob> linux audio developers simple plugin api
11:19:26 <jmob> (http://ladspa.org)
11:20:51 <ehaas> cool...if you wouldn't mind packaging it up that looks pretty useful
11:21:29 <b_jonas> /dev/dsp only works with the older kind of linux sound, doesn't it?
11:22:36 <opqdonut> can anyone link to a simple memoize function
11:22:55 <opqdonut> (using IOArrays or something efficient like that)
11:24:46 <jmob> b_jonas: it's still there my (persumably somewhat modern) Linux installation
11:25:05 <jmob> b_jonas: cat /dev/random > /dev/dsp still works :)
11:25:31 <Vq^> techno musÃ¯c! :D
11:25:50 <FunctorSalad> more like white noise. what format does /dev/dsp take anyway?
11:26:10 <joaop> hi! new in haskell and fp's, how do i get from a given list all the elements from offset n to o ?
11:26:23 <joaop> this does not sound the best way: [ xs!!x | x <- [h..i ] ]
11:26:27 <Mantaar_> jmob: the more modern variant would be: aplay - < /dev/urandom
11:26:34 <oerjan> joaop: take (o-n) . drop n
11:27:16 <oerjan> *+1 somewhere, possibly
11:27:26 <ehaas>  /dev/dsp doesn't work for me but aplay does
11:28:07 <jmob> "The default is 8-bit unsigned samples, using one channel (mono), and an 8 kHz sampling rate."
11:28:34 <joaop> oerjan: thanks.
11:28:37 <oerjan> > take 4 . drop 5 $ [0..20]
11:28:40 <lambdabot>  [5,6,7,8]
11:28:45 <FunctorSalad> thanks jmob
11:29:49 <joaop> 5 being 8-4+1
11:29:51 <joaop> thanks
11:30:29 <Tac-Tics> > take 4 . drop 5 [0..20]
11:30:30 <lambdabot>  Couldn't match expected type `a -> [a1]'
11:30:55 <quicksilver> Tac-Tics: semantics error, missing $
11:31:03 <mauke> > (take 4 . drop 5) [0 .. 20]
11:31:04 <lambdabot>  [5,6,7,8]
11:33:03 <b_jonas> jmob: it is there
11:33:17 <b_jonas> because the newer one is quite new and doesn't have a driver for every sound card,
11:33:26 <b_jonas> and because lots of older programs use the old interface
11:33:37 <dmwit> OpenAL?
11:33:45 <b_jonas> dunno
11:33:48 <b_jonas> one of them is ALSA
11:33:49 <harlekin> I've defined a data type "Check TM TM", how can I access the first and the second TM without being in a case expression? (Using case, I can just do: case e of Check t1 t2, but this won't work without case.)
11:34:08 <b_jonas> looking up, the other is OSS
11:34:25 <oerjan> harlekin: you can adjust the data type to include field names
11:34:32 <b_jonas> and yes, what jmob says, you use ioctls to change to any other raw format
11:34:37 <b_jonas> well, not _any_
11:34:52 <b_jonas> @info Check
11:34:53 <lambdabot> Check
11:34:59 <b_jonas> useful, damn it
11:35:02 <b_jonas> @src Check
11:35:02 <lambdabot> Source not found. Maybe you made a typo?
11:35:03 <oerjan> Check { field1 :: TM, field2 :: TM }
11:35:18 <harlekin> oerjan: Okay. I'll read that one up. I recall that a gentle introduction to haskell programming has a section about that.
11:35:21 <harlekin> Thank you.
11:36:37 <oerjan> harlekin: oh and also you can use (Check t1 t2) patterns in other definitions
11:36:41 <BMeph> > take 3 . drop 1 $ [0..6]
11:36:42 <lambdabot>  [1,2,3]
11:37:02 <oerjan> doesn't need to be case.  let, where and function arguments can all use patterns.
11:37:18 <dmwit> harlekin: oerjan's example is equivalent to defining (by hand) two functions
11:37:26 <dmwit> field1 (Check answer _) = answer
11:37:31 <dmwit> field2 (Check _ answer) = answer
11:37:42 <harlekin> Okay. Didn't thought of that. (-:
11:38:04 <dmwit> With the single exception that when defined using record syntax, you can use the field name in pattern matching.
11:38:33 <oerjan> also record updates </mumble>
11:38:51 <dmwit> ...two exceptions.
11:41:12 <bench> #happs
11:58:33 <Valodim> *** Exception: C:/eclipse/workspace/Euler/src/Problem89.hs:(11,2)-(13,23): Non-exhaustive patterns in function sub1
11:58:41 <Valodim> I have an | otherwise guard in said function
11:59:00 <Valodim> are there any other common causes for this?
11:59:50 <oerjan> Valodim: what are the function arguments before that | otherwise?
11:59:58 <Valodim>   sub1 (x:xs)
11:59:58 <Valodim>    | x == 'I' = 1 + sub1 xs
11:59:58 <Valodim>    | otherwise = sub2 $ x:xs
12:00:06 <mauke> doesn't match []
12:00:07 <oerjan> won't match an empty list
12:00:30 <Valodim> it detects that the otherwise uses x:xs?
12:00:33 <Valodim> ah
12:00:34 <Valodim> ok
12:00:37 <Valodim> yeah makes sense
12:00:55 <oerjan> yep.  guards are refinements to the patterns used, not a replacement for them
12:01:40 <roconnor> Finally, I think I've constructed a counter-example
12:02:02 <BMeph> roconnor: counter to what? :)
12:02:04 * oerjan did that years ago.
12:02:14 <titusg> can I tell from haddock when a function was introduced in a module?
12:02:16 <oerjan> unless you mean to a specific hypothesis :)
12:03:07 <roconnor> my claim that mapping (composing) a uniformly continuous function over step functions yields a uniformly continuous function from step functions to step functions (with the same modulus of continuity)
12:03:12 <roconnor> using the L1 metric
12:04:48 <byorgey> roconnor: oh, that's trivial. ;-)
12:05:01 <roconnor> byorgey: is it?
12:05:09 <titusg> I don't want to demand a more recent version than necessary in .cabal
12:05:13 <byorgey> i'm just kidding
12:05:18 <roconnor> :)
12:05:37 <roconnor> I probably ought to check the counter example in Coq
12:07:09 <FunctorSalad> Coq?
12:07:39 <roconnor> @go Coq
12:07:41 <lambdabot> http://coq.inria.fr/
12:07:41 <lambdabot> Title: The Coq proof assistant
12:08:07 <FunctorSalad> roconnor: you mean you have a uniformly continuous f and the map is s \mapso fs, s a step function?
12:09:46 <roconnor> yes, where fs is (f . s)
12:09:53 <roconnor> so
12:10:03 <FunctorSalad> f after s, not the other way around?
12:10:18 <roconnor> \s -> f . s where s is a step function and the result is a step function.
12:10:27 <roconnor> and we are using the L1 metric
12:10:40 <roconnor> I believe it is true if we use the Linf metric
12:10:52 <roconnor> I hoped it would be true for the L1 metric
12:11:54 <FunctorSalad> hmm, if s = sum_i a_i 1_{A_i}, then |s|_1 is just sum_i |a_i| * measure(A_i)
12:12:13 <FunctorSalad> (where 1_something is the indicator function)
12:12:36 <FunctorSalad> btw, off-topic -> #not-math ;)
12:15:01 <Saizan_> math has never been considered off topic here :)
12:15:34 <FunctorSalad> Saizan_: oh, I'm new here. though I thought infinitary stuff is pretty off-topic for a programming language ;)
12:16:22 <araujo> hello
12:17:17 <Valodim> math is the essence of functional languages, that's whta makes them special
12:17:43 <ddarius> Valodim: Huh?
12:18:03 <oerjan> > nubBy (((>1).).gcd) [2..] -- infinitary stuff
12:18:06 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
12:18:33 <Valodim> (about being off topic talking about maths)
12:18:52 <b_jonas> wow
12:18:53 <ddarius> Valodim: I was responding to your statement
12:18:56 * Saizan_ remembers a discussion on "would alien cultures have a math similar to ours?"
12:19:11 <b_jonas> but that's misuse, isn't it? nubBy should be passed an equivalence relation
12:19:55 <b_jonas> Saizan_: yeah, that is an interesting question
12:20:16 <oerjan> nubBy and groupBy are made to be misused :)
12:20:16 <b_jonas> whether aliens are interested in classification of simple finite groups and Riemann-hypothesis
12:20:42 <b_jonas> oerjan: but isn't it defined in such a way that if you misuse it it could behave in an undefined way?
12:20:43 <Valodim> well depending on how many fingers they have
12:20:47 <Valodim> they wouldn't use the decimal systems
12:20:47 <ddarius> b_jonas: It's reflexive and symmetric.
12:20:53 <Valodim> but the underlying problems would stay the same
12:20:54 <ehaas> Valodim: i was going to say the same thing
12:21:01 <FunctorSalad> oerjan: well, that's only potential infinity. a continuous function is an actually infinite object
12:21:15 <FunctorSalad> (which we were talking about)
12:21:15 <b_jonas> ddarius: in old perl versions, passing a wrong comparision function to sort could cause a segfault
12:21:20 <b_jonas> this was since fixed
12:21:21 <Valodim> math is universal :)
12:21:28 <ddarius> b_jonas: I'm pretty sure the closest thing to a "normative standard" is an implementation.
12:21:32 <ddarius> b_jonas: That's perl.
12:21:38 <b_jonas> ddarius: sure,
12:21:41 <mauke> it's also C
12:21:46 <b_jonas> it wouldn't crash haskell
12:21:49 <ddarius> math is not universal
12:21:52 <mauke> qsort can fail in spectacular ways
12:21:54 <b_jonas> but couldn't it give a "wrong" output?
12:21:54 <Valodim> it's not?
12:22:03 <b_jonas> some parts of maths isn't
12:22:09 <Valodim> like?
12:22:14 <ddarius> b_jonas: At that point the output would be unspecified so it couldn't be "wrong"
12:22:27 <b_jonas> the theorems you _discover_ is, the theorems you _invent_ isn't
12:22:35 <ddarius> Valodim: All of it.  It's based on our (common) ways of perceiving reality.
12:22:42 <Valodim> it's not
12:22:45 <b_jonas> ddarius: oh sure, but it might not be the list of primes
12:22:45 <Valodim> that's the point
12:22:46 <ehaas> what's the difference between a discovered theorem and an invented theorem?
12:22:55 <Valodim> math is definition
12:22:57 <ehaas> "god invented the natural numbers, all else is the work of man"?
12:23:01 <Valodim> it is not what we perceive, but what we define
12:23:19 <ddarius> Valodim: Okay, then that is even less universal than what I was claiming.
12:23:25 <Saizan_> the formalisms we use are influenced by what we see/it's useful for us
12:23:33 <b_jonas> yep
12:23:45 <FunctorSalad> yes, we don't define things randomly
12:23:48 <b_jonas> I really wonder whether the concept of real numbers is a universal one
12:23:58 <FunctorSalad> it's a useful fiction.
12:24:02 <ddarius> FunctorSalad: I agree.  A definition can be "wrong".
12:24:04 <b_jonas> useful, yes
12:24:11 <b_jonas> but is it universal?
12:24:15 <Valodim> physics = maths in a box
12:24:15 <Valodim> chemistry = physics in a box
12:24:15 <Valodim> biology = chemistry in a box
12:24:15 <Valodim> so to get anywhere thinking about those, you need maths. thus, any kind of culture would sooner or later define some kind of mathematical system to work with
12:24:29 <Valodim> I can't prove that of course, but it's a good guess imvho
12:24:35 <FunctorSalad> assuming infinite precision can be simpler than calculating with something discrete but with 10^25 or whatever elements...
12:25:33 <ddarius> Valodim: The question is usually: Is -our- math universal (in substance at least)?
12:25:41 <Valodim> it's not
12:25:44 <Valodim> and I never said that
12:25:59 <ehaas> ddarius: isn't it impossible to prove that it's universal
12:26:06 <FunctorSalad> Valodim: universal across cultures modulo some small differences, probably yes
12:26:07 <sieni> ddarius: all mathematics is universal, obviously
12:26:10 <ehaas> even if we find aliens who use our math, there could be others who dont
12:26:12 <ddarius> Valodim: I agree that you never said that, though that's what it seemed like you were saying originally.
12:26:23 <sieni> ddarius: if you think formalistically
12:26:25 <Valodim> I would never claim such a thing
12:26:33 <b_jonas> I'm quite sure some of our maths is universal and some isn't
12:26:40 <ddarius> sieni: Formalistically, there is no reason for math to be universal.
12:26:54 <FunctorSalad> maybe you should first agree what "universal" means :)
12:26:55 <sieni> ddarius: but yes there is!
12:26:59 <b_jonas> (though of course if aliens don't (and didn't and won't) exist than even the question doesn't mean anything)
12:27:17 <Valodim> why wouldn't they exist?
12:27:47 <b_jonas> by universal, I mean that a civilisation as developped as ours that's not in contact with us in any way would develop the same
12:27:49 <ddarius> Valodim: Again, all I said is that's what you seemed to be saying "math is universal" (because the question was "would alien cultures have a math similar to ours?"{
12:27:52 <b_jonas> not that it really exists
12:27:55 <b_jonas> physically
12:28:02 <b_jonas> that's an entirely different question
12:28:20 <ddarius> sieni: From a Formalist viewpoint, math is fiddling with symbols whose meaning is entirely given by us.
12:28:25 <b_jonas> (we've had an argument about the latter with a friend a few weeks ago and it was quite interesting)
12:28:49 <Valodim> b_jonas: I think they would
12:29:10 <b_jonas> Valodim: I think only some of our maths is like that
12:29:13 <sieni> ddarius: and if math is only that, then that's what math's about and why wouldn't that be universal?
12:29:17 <ddarius> I think they may, if they use the similar means of perceiving the world, but not that they must.
12:29:29 <FunctorSalad> whether a mathematical object "exists in the real world" is a messy topic
12:29:33 <sieni> I gotta go get the bus
12:29:36 <b_jonas> FunctorSalad: yep
12:29:44 <FunctorSalad> some would say that being useful makes it exist
12:29:45 <Valodim> b_jonas: no, our methods are like that. any culture would sooner or later discover the same underlying concepts. primes for example are bound to come up sooner or later
12:29:49 <b_jonas> RÃ©nyi touches that topic in one of his books
12:29:49 <ddarius> sieni: Does this universal math cease to exist when humans go extinct?
12:29:58 <sieni> ddarius: no
12:30:00 <b_jonas> primes, yes
12:30:07 <sieni> well, I don
12:30:11 <b_jonas> but what about real numbers?
12:30:19 <ddarius> sieni: That's a consequence of how I stated the Formalist viewpoint.
12:30:22 <b_jonas> or the residue theorem
12:30:23 <sieni> well, I don't find time to be that universal
12:30:31 <b_jonas> or any of the calculus Euler has invented in general
12:30:42 <sieni> so our existence or non-existence is quite irrelevant
12:30:50 <FunctorSalad> hell, even electrons "exist" only because they are part of a useful theory. you can't observe them when not given the rest of physical theory
12:30:51 <Valodim> it's relative
12:30:53 <b_jonas> or what about the classification of simple finite groups
12:31:04 <sieni> time is quite a complicated physical concept and pretty irrelevant for mathematics
12:31:11 <Valodim> everything is relative - except maths
12:31:13 <ddarius> The book "Where Mathematics Comes From" states a case very similar to my philosophy of mathematics.
12:31:23 <Valodim> (except for our misassumptions, of course)
12:31:55 <Valodim> one pie and one pie might not be two pies in some different reality
12:31:59 <Valodim> but one and one will always be two
12:32:14 <sieni> I gotta go now... :-/
12:32:21 <ddarius> Valodim: You are assuming that the alien race even has a notion of "one".
12:32:45 <Valodim> the alien culture, yes
12:32:45 <ddarius> There are (were) human cultures with only the notion of "one, two, many"
12:32:52 <b_jonas> ddarius: who wrote that book?
12:33:18 <Valodim> right, but that doesn't invalidate any underlying concepts of maths, they just didn't discover them yet (and might never have)
12:33:24 <Saizan_> Valodim: we're not asking if our math can be applied in a different reality, but if our math is what will eventually arise from a sufficiently developed culture
12:33:25 <b_jonas> I think they would have the notion of natural numbers, including "one" eventually
12:33:29 <FunctorSalad> ddarius: hmm, subtraction is not well-defined on that set ;)
12:33:41 <Valodim> the methods will likely be entirely different
12:33:46 <b_jonas> Saizan_: agreed
12:33:55 <ddarius> b_jonas: George Lakoff and Rafael Nunez cognitive scientists.
12:33:57 <ehaas> Valodim: i refuse to contemplate a universe such as you describe
12:34:11 <b_jonas> Valodim: the methods don't matter, the topics of interest and the results are
12:34:20 <Valodim> pie matters
12:34:24 <b_jonas> probably the definitions more than the results
12:34:31 <ddarius> Valodim: You are just asserting that math is universal.
12:35:25 <FunctorSalad> it's at a funny intersection between fantasy and sometimes actually being useful :)
12:35:29 <Valodim> assuming it, yes
12:37:36 <ddarius> b_jonas: Indeed.  The fact that there are "good" and "bad" definitions already suggests issues with, at least, a Formalist approach (though that is fine from a Platonic or Social Constuctivism)
12:37:57 <b_jonas> um
12:38:12 <b_jonas> I think the formalist approach might be ortogonal to that
12:38:15 <FunctorSalad> ddarius: I guess you are a social constructivist then?
12:38:24 <b_jonas> I mean, even if we only had the imprecise proofs of pythagoras,
12:38:39 <b_jonas> we could ask whether that maths (euclidean geometry) is universal
12:38:44 <ddarius> FunctorSalad: Hell no
12:39:08 <ddarius> http://en.wikipedia.org/wiki/Philosophy_of_mathematics#Embodied_mind_theories This is a short blurb about the view espoused in the book I mentioned above
12:39:09 <lambdabot> http://tinyurl.com/hmsj4
12:39:13 <FunctorSalad> oh. thought you were because you mentioned agreeing with cognitive scientists, but I'm prolly misunderstanding the word
12:39:33 <Valodim> b_jonas: it is, but alien cultures with different physics might never discover it, but instead something equivalent
12:39:34 <ddarius> I highly recommend getting it from a library and reading it just to see a relatively new viewpoint.
12:39:51 <ddarius> (even if you ultimately seriously disagree with them)
12:40:52 <ddarius> b_jonas: From a Formalist perspective and definition can't be "wrong", though you may still argue it could be "bad" if it didn't lead to "interesting" results, but then you are already straying outside of Formalism.
12:40:57 <FunctorSalad> ddarius: I think I misinterpreted "social constructivism". no offense meant ;)
12:41:56 <ddarius> FunctorSalad: I wasn't offended, I just (similarly to most mathematicians/practitioners of a (somewhat) mathematical field) see something more objective about math than just arbitrary convention.
12:42:52 <Valodim> hmmmm,"arbitrary"
12:42:56 <FunctorSalad> yes, I don't think it's arbitrary convention either. I was just thinking about the fact that it does in some way relate to the empirical world
12:43:01 <ehaas> ddarius: a definition is bad if you build a bridge using it and it falls down
12:43:58 <ddarius> ehaas: I can agree with that.  From my view, physical reality -is- (directly and indirectly) where the objectivity of mathematics comes from.
12:43:58 <Valodim> a definition might just be falsified by another definition
12:44:19 <b_jonas> actually, I think I'm wrong about discovery and invention
12:44:25 <ddarius> Valodim: So?  Then you can't have them both together, but there is no basis to decide which one is "right" or "better".
12:44:26 <Saizan_> how do you build a bridge on a definition? on a theorem i could understand, but..
12:44:36 <b_jonas> that's more related to whether that notion exists physically than whether it's universal
12:44:38 <Valodim> yeah
12:44:55 <Valodim> and we use our perception as a basis for deciding which one is ultimately right (and its implications)
12:45:40 <ddarius> Valodim: We don't perceive mathematics.  You can't -see- the number one or the Cauchy residue theorem.
12:45:45 <b_jonas> physical reality obviously inspired mathematics, just like it's inspired everything else
12:46:08 <Valodim> ddarius: one pie plus one pie is two pies
12:46:15 <b_jonas> we do everything because we live in the physical world
12:46:22 <ddarius> Valodim: However, we do perceive the real world and (as is quite obvious from history) build our mathematics around it.
12:46:31 <Valodim> exactly
12:46:55 <FunctorSalad> Valodim: yes. but 1+1=2 is an abstraction of that (and "one cat plus one cat is two cats", and ...)
12:46:55 <b_jonas> wait, which theorem does "residue theorem" refer to? the quadratic residue one with Legendre-forms, or the complex analytic function one, or something else?
12:47:01 <ddarius> Valodim: Yes, but (assuming) physical reality is universal, our means of perception is not (necessarily).
12:47:13 <opqdonut> b_jonas: the complex analytic one usually
12:47:18 <ddarius> b_jonas: The one I'm referring to is the complex analysis one.
12:47:27 <opqdonut> ah, it was mentioned
12:47:32 <Valodim> that's right
12:47:35 <ddarius> Valodim: One ball of mud plus one ball of mud is one ball of mud.
12:47:47 <b_jonas> I said "residue theorem" first but I didn't clarify which one it was
12:48:00 <ehaas> only if you put them together
12:48:05 <ehaas> if they're side by side it's still 2 balls of mud
12:48:12 <Zao> ddarius: One handful of mud plus one handful of mud added is not one handful of mud.
12:48:16 <FunctorSalad> Î»(mud_1) + Î»(mud_2) = Î»(mud_1 âª mud_2) (for disjoint balls of mud :))
12:48:23 <ehaas> if i put 2 apples in a blender and mix them up is that 1 apple or 2
12:48:34 <ddarius> ehaas: Okay, then one ball of mud plus one ball of mud is millions of balls of mud.
12:49:07 <Valodim> but no matter what an alien culture perceives, if they bring what they see to a more abstract level, they will find that 1+1=2
12:49:16 <b_jonas> ah, that Lakoff book is in the library of the department
12:49:24 <ddarius> Valodim: Why?
12:49:31 <Japsu> ehaas: blender is a catamorphism on apples
12:50:06 <ddarius> Perhaps they can't perceive a difference between "two" pies.
12:50:07 <FunctorSalad> it makes the apple into a totally disconnected space.
12:50:25 <Valodim> well assuming they exist and perceive existing things, "one existing entity plus one existing entity equals two existing entities" which is pretty universal
12:50:40 <lament> ddarius: it's pretty unlikely that anything could survive in a competitive (ie evolutionary) environment without perceiving a difference between "two" pies.
12:51:04 <FunctorSalad> numbers essentially require making bijections between sets of real objects, which prolly is pretty universal
12:51:05 <lament> because things which do perceive this difference will eat all the pie, and then you die
12:51:07 <b_jonas> lament: the concept of numbers isn't so trivial
12:51:18 <FunctorSalad> (natural numbers, I mean)
12:51:31 <ddarius> Valodim: Why do you think there is more than one existing entity?  Also many things don't have well-defined boundaries (heck, QM suggests nothing has a well-defined boundary and from that perspective one might argue that there is only one thing)
12:51:40 <b_jonas> proven by the fact that it takes 6 years for some human children to grasp
12:51:40 <lament> b_jonas: i haven't said anything about "the concept of numbers"
12:51:48 <b_jonas> lament: I meant natural numbers
12:52:01 <lament> b_jonas: but animals seem to have no trouble distinguisting between one and two htings
12:52:02 <b_jonas> that is, abstracting "two" from two pies and two fingers etc
12:52:05 <Valodim> aw
12:52:07 <Valodim> ok
12:52:13 <Valodim> "perceived entity"
12:52:18 <Valodim> it doesn't even have to exist
12:52:18 <b_jonas> animals can distinguish one pies from two pies
12:52:31 <ddarius> lament: Animals have sensory apparatus rather similar to our own.
12:52:33 <b_jonas> but I don't think they see the connection between three pies and three worms
12:52:56 <Valodim> yep
12:52:57 <lament> ddarius: sure, my point is that an alien life wouldn't be all that different from ours
12:52:59 <ddarius> (Well, most.)  Does an amoeba know the difference between one and two?
12:52:59 <Valodim> they never discover that 1+1=2
12:53:06 <Valodim> but that doesn't make it less true
12:53:10 <lament> ddarius: sufficiently complex alien life, that is
12:53:16 <ddarius> lament: Perhaps not, but that is a different question.
12:53:46 <FunctorSalad> thinking about what aliens are probably like is kind of like trying to define a uniform probability distribution on the natural numbers ;)
12:53:57 <lament> FunctorSalad: not really
12:53:58 <ddarius> lament: We aren't really in a position to make any claims about it.
12:54:08 <lament> ddarius: sure we are. We know how things evolve.
12:54:21 <ddarius> lament: So?
12:54:22 <lament> ddarius: and we know what the chemical and physical makeup of any likely planet is.
12:54:39 <FunctorSalad> lament: in the sense that we can't think generally enough
12:54:52 <FunctorSalad> it was not meant to be an exact analogy ;)
12:54:59 <ddarius> Indeed, it may just be a failure of creativity on our part.
12:55:08 <lament> ddarius: so we know the environment, we know that they have a problem of limited resources, we know that they will have evolution driven by competition for resources, this limits everything quite a bit
12:56:00 <Valodim> a reality where there is no way of perceiving the abstract concept of "1+1=2", I don't want to live in
12:56:07 <Valodim> and it is far beyond my imagination
12:56:10 <Valodim> thus, as far as I am concerned
12:56:10 <ddarius> lament: I'm of the mind that aliens will be similar to us, in a kind of "same problem same solution" way, but I don't assume that they must necessarily be.
12:56:12 <Valodim> 1+1=2
12:56:38 <b_jonas> you don't have to think of aliens, just think of uncivilized humans
12:56:38 <lament> ddarius: they must be "creatures which are able to survive", which limits creativity quite a bit
12:56:49 <b_jonas> like, Americans if we don't discover America
12:56:59 <b_jonas> the Majas or Aztecs or whatever
12:57:01 <FunctorSalad> "surviving" can be quite different depending on what "stuff" they consist of
12:57:12 <Valodim> if they consist
12:57:12 <ddarius> lament: Nature has repeatedly demonstrated that we've underestimated that creativity time and time again.
12:57:19 <lament> ddarius: it has?
12:57:21 <FunctorSalad> we don't know all the laws of physics...
12:57:30 <Valodim> getting there, getting there
12:57:35 <FunctorSalad> agree with ddarius
12:57:41 <lament> FunctorSalad: we more or less do, for the purposes of figuring out how living things work.
12:58:02 <ddarius> FunctorSalad: There are perhaps "laws of physics" that we can't know (I'm not sure if they would be relevant or not to us then)
12:58:02 <FunctorSalad> lament: only how living things work under conditions sufficiently similar to ours :)
12:58:28 <ddarius> lament: The recent example is various extremophiles.
12:58:32 <FunctorSalad> maybe flows inside the sun can evolve (silly example, but you know what I mean)
12:58:32 <lament> FunctorSalad: we more or less know the kind of conditions where any sort of life can arise. That's what astronomy's for.
12:58:38 <Valodim> how could we not be able to know them?
12:58:46 <Valodim> we could be unable to discover them, but unable to know them?
12:59:04 <b_jonas> good night now
12:59:22 <Valodim> 'night
12:59:23 <lament> ddarius: either very similar to other life forms, or very simple
12:59:36 <lament> ddarius: there's more room for creativity for simple stuff (ie early stages of evolution)
12:59:55 <lament> hence ediacaran fauna and all that
13:00:14 <lament> because there's basically no competition
13:00:15 <Saizan_> lament: well considering that there are theories that consider an n-dimensional universe (for some n), we could just be seeing a very narrow part of what "exists"
13:00:39 <ehaas> aren't the other dimensions really small though
13:00:54 <ddarius> ehaas: Depends on the particular theory you are working with.
13:00:59 <ehaas> ah
13:01:00 <lament> Saizan_: i'm of course talking about life existing in this particular set of dimensions.-
13:01:11 <lament> i'm not interested in theology.
13:01:24 <Valodim> I once read a very interesting description of perception of space
13:01:26 <Saizan_> lament: i'm not sure that's a well founded definition :)
13:01:35 <Valodim> in a world with only two dimensional beings
13:01:39 <FunctorSalad> I think we know very much about the physics of the world we are living in (and to some degree of the universe we can observe), but out knowledge about the whole universe is overestimated...
13:01:42 <Valodim> one being one day sees a circle
13:01:53 <Valodim> which grows bigger, and bigger, and then goes back in size until it vanishes
13:02:07 <purplepenguins> flatworld
13:02:09 <lament> that book (Flatland) was mostly about how women are stupid
13:02:16 <purplepenguins> err, flatland, right
13:02:28 <Valodim> that doesn't make that point any less interesting
13:02:42 <lament> what point?
13:03:04 <Valodim> I find myself completely unable to imagine how a fourth dimension of space would work
13:03:12 <lament> (btw, i always wanted to write a Flatland first-person-shooter)
13:03:22 <ehaas> a slowly growing, followed by shrinking, sphere :)
13:03:43 <FunctorSalad> Valodim: spatially yes, but you can develop a good intuition for the algebra of n dimensions
13:03:43 <lament> Valodim: hopefully you see how unrelated that is to the problem of alien life?
13:03:57 <Valodim> haha, yeah it is... dunno how I got there
13:04:05 <Valodim> true
13:04:44 <lament> it's probably pretty easy to hack the Doom renderer to make it display everything on one line of pixels
13:04:55 <FunctorSalad> :)
13:05:25 <lament> the devil's in the details, though, you'd have to change all the graphics to be reasonable
13:05:27 <Valodim> 1d doom?
13:05:42 <lament> 2d
13:05:48 <FunctorSalad> maybe he means a plane
13:05:57 <purplepenguins> 1d games would be kinda boring
13:06:11 <Saizan_> lament: aliens could be able to perceive that dimension, however assuming we know "almost all" is a broad statement, we might know a lot of what is relevant to us, but e.g. who would have imagined relativity until we developed technology able to see its effects?
13:06:33 <FunctorSalad> that's what I said
13:07:21 <FunctorSalad> my favourite is the guy who claimed that "everything that can be invented has been invented" around 1900 I think :)
13:07:31 <lament> Saizan_: if our hypothetical aliens can see extra dimensions, something is very wrong with all of modern sciecne.
13:07:34 <lament> *science
13:08:09 <lament> if that's the case, obviously all bets are off.
13:09:48 <sclv_> FunctorSalad: everything was.
13:10:21 <FunctorSalad> sclv_: what do you mean?
13:11:37 <sclv_> FunctorSalad: well, in one sense, no. i was just thinking in terms of the degree to which society has been changed by any of those things.
13:12:22 <zekus_> hi there. i think my question is quiet simple but i colud not find the answer :)) how can i take only last line of a file?
13:12:43 <sclv_> He had banks, financial instruments, publishing and distribution networks, reasonably fast communication for those who could afford it, and the foundations for pretty much everything since.
13:12:49 <sclv_> s/He/We
13:13:38 <lament> no transistors, though.
13:13:50 <lament> that's a big one. :)
13:14:51 <sclv_> yeah, but we had Maxwell's equations.
13:15:15 <ddarius> sclv_: He didn't have quantum mechanics.
13:15:24 <oerjan> zekus_: liftM (last . lines) $ readFile "filename", although that will read through everything else first
13:15:28 <purplepenguins> he didn't have the airplane
13:15:34 <purplepenguins> though that was soon to come afterwards
13:15:39 <Saizan_> ?hoogle seek
13:15:40 <lambdabot> System.IO.SeekMode :: data SeekMode
13:15:40 <lambdabot> System.IO.SeekFromEnd :: SeekMode
13:15:40 <lambdabot> System.IO.hSeek :: Handle -> SeekMode -> Integer -> IO ()
13:15:41 <sclv_> we still sort of don't have quantum mechanics.
13:16:05 <ddarius> sclv_: We have it enough that we've made devices that wouldn't have been doable without it.
13:16:06 <sclv_> anyway, airplanes are only marginally better than boats for most purposes.
13:16:13 <lament> nuclear energy is another big one in terms of novelty factor
13:16:18 <purplepenguins> no GR, so no GPS systems
13:16:58 <ehaas> you probably couldn;t have GPS without fast digital computers (transistors) either
13:17:03 <mattam> sclv_: you overlook the use of planes as a fast way of travelling ?
13:17:07 <sclv_> yeah, but people could navigate pretty well from like 500 AD onwards at least.
13:17:07 <Saizan_> zekus_: if you don't want to read all the file you have to use hSeek and related functions from System.IO to find the start of the line and read it
13:17:29 <sclv_> mattam: so are railroads.
13:17:46 * sclv_ enjoys being the devil's advocate a tad too much.
13:17:57 <mattam> indeed, except railroads don't cross water that easily
13:18:07 * Japsu plays with the thought of a maglev in a vacuum tube underneath the Atlantic
13:18:12 <ehaas> mattam: that's why we have boats :)
13:18:12 * mattam enjoys just as well
13:18:20 <mattam> great
13:18:21 <lament> the world certainly wouldn't be very different if planes never existed
13:18:38 <ehaas> WW2 would have played out differently
13:18:50 <FunctorSalad> antibiotics...
13:19:06 <ddarius> Japsu: Why would you put it in a vacuum tube?
13:19:10 <mattam> lament: I can't tell
13:19:29 <Japsu> ddarius: to eliminate air resistance
13:19:45 <nbarterd> http://hpaste.org/4619 (is there a faster way to nub? ("nub [1..10^5]" looks like it'll take at least an hour)
13:19:48 <ddarius> Japsu: That'd have to be some strong ass tube.
13:20:00 <Japsu> yeah
13:20:11 <Japsu> vacuum inside, dozens of atms outside
13:20:14 <ddarius> nbarterd: nub is O(n^2), you can do better if you have an ordering and even better for numbers.
13:20:24 <lament> look on the bright side
13:20:39 <lament> when it's deep underwater, it doesn't really matter much if it's vacuum or 1 atm inside :)
13:20:46 <lament> just 1 atm difference
13:20:48 <FunctorSalad> that's what I thought too
13:21:00 <Japsu> lament: hahaha yeah
13:21:08 <FunctorSalad> but wouldn't there still be losses in the electromagnet?
13:21:13 <Japsu> probably some
13:21:25 <nbarterd> ddarius: whaddo I read? whaddo I do?
13:21:30 <Japsu> but aren't they negligible compared to the air resistance of maglev trains
13:21:35 <FunctorSalad> no idea
13:22:02 <nbarterd> perhaps use Data.Map?
13:22:09 <nbarterd> functions from Data.Map?
13:22:19 <ddarius> nbarterd: The quick solution to get an O(n log n) one, if you don't need it to be "stable", is just map head . group . sort
13:22:43 <nbarterd> what is stable?
13:22:56 <ddarius> nbarterd: Order preserving.
13:23:21 <yrlnry> Who was responsible for  http://www.hpaste.org/4607
13:23:22 <yrlnry> ?
13:23:52 <Taejo> @src liftM
13:23:52 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
13:23:57 <ehaas> isn't haskell using mergesort, which is stable?
13:24:03 <ddarius> nbarterd: With a data structure that has O(1) inserts and lookups, e.g. some hash-table approaches, you could do it in O(n) time.
13:24:19 <ddarius> ehaas: Sorting at all is going to break the order the elements arrive in (in general)
13:24:30 <ddarius> In his particular case it doesn't make any difference.
13:24:51 <psnively> Hey guys. Anyone know of a solution to the ld bus error on PPC Leopard for GHC 6.8.x?
13:25:09 <ehaas> ohh :)
13:25:12 <oerjan> > map snd . sortBy (comparing `on` fst) . map head . groupBy ((==) `on` snd) . sortBy (comparing `on` snd) . zip [0..] $ [10000,9999..1]
13:25:13 <lambdabot>      Occurs check: cannot construct the infinite type: b = b -> a
13:25:14 <lambdabot>     Probabl...
13:25:14 <Taejo> psnively: you're getting a bus error in ld?
13:25:34 <psnively> Taejo: In attempting to build 6.8.x, yes.
13:25:45 <Taejo> sounds like a bug in ld
13:25:50 <allbery_b> known issue, bug in leopard's ld
13:26:03 <psnively> Right. The question is whether anyone's found a workaround.
13:26:06 <mattam> psnively: there's a mess with readline and leopeard and 6.8.x discussed on the cafe apparently
13:26:06 <allbery_b> people have been trying to use ld_classic but it apparently doesn't cope with leopard's libc
13:26:33 <psnively> mattam: Good to know, thanks. :-)
13:26:44 <oerjan> > map snd . sortBy (comparing fst) . map head . groupBy ((==) `on` snd) . sortBy (comparing snd) . zip [0..] $ [10000,9999..1]
13:26:45 <lambdabot>  [10000,9999,9998,9997,9996,9995,9994,9993,9992,9991,9990,9989,9988,9987,9986...
13:26:56 <psnively> allbery_b: Yeah. I just thought someone might have rewritten split-objs so as not to tickle the bug
13:27:24 <allbery_b> not as of discussion this morning on the list
13:27:26 <Valodim> replicate with negative values results in an empty list, right?
13:27:47 <oerjan> > replicate (-3) 4
13:27:48 <lambdabot>  []
13:27:54 <allbery_b> and I assume that nothing much will be happening over the next 2 weeks...
13:27:55 <Valodim> :)
13:28:32 <psnively> Yeah. Thanks!
13:30:03 <nbarterd> ddarius and co: thanks for explaining.
13:38:06 <diltsman> How do I use modules in mulitple files?
13:39:00 <shachaf> diltsman: "module A where ...", "module B where import A; ..."?
13:39:04 <shachaf> diltsman: What do you mean?
13:39:52 <diltsman> shachaf: Yeah, like that.  I have two source files, one has Main, the other is a module I need to import.  I use Module A where import B, but it can't find B.
13:40:23 <shachaf> diltsman: Name the file that contains A "A.hs" (or .lhs), maybe?
13:40:42 <diltsman> Both source files are in the same directory, and both source files are named after the modules.
13:41:35 <shachaf> diltsman: And it's not working? What's the error? "Can't find module"?
13:42:02 <diltsman> Just a second, things are locking up...
13:45:43 <diltsman> "Can not find module 'ConfigFile': Use -v ..."
13:47:24 <sclv_> I was up late last night reading about category theory, and now I feel a bit freyd.
13:48:07 <ddarius> My impression is that Freyd categories are primarily a computer science thing (though that doesn't detract from it being categorical)
13:48:48 <diltsman> shachaf: you get thtat?
13:49:11 <shachaf> diltsman: Can you @paste?
13:49:29 <diltsman> @paste what?
13:49:30 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:51:06 <shachaf> diltsman: The files that aren't working.
13:51:21 <shachaf> diltsman: How are you compiling this?
13:51:46 <diltsman> Using Visual Haskell (that uses Cabal).
13:52:06 <oerjan> diltsman: is it named ConfigFile.hs precisely? (including capitalization if your OS cares about it)
13:53:40 <diltsman> oerjan: it is spelled "ConfigFile.hs"
13:54:13 <oerjan> right.  perhaps the compiler is not running with the same current directory?
13:54:59 <oerjan> say if the main file is given to it with a longer path...
13:55:01 <diltsman> Don't know.  Let me check that...
14:00:44 <diltsman> oerjan: Weird, if I run it through Visual Haskell, then it doesn't work, if I do it through the command line, then it does.  Thanks for the help.
14:01:44 <oerjan> diltsman: perhaps there is somewhere in VH to set your source directory?
14:04:46 <diltsman> oerjan: Honestly, I have so much trouble with VH locking up VS 2005, that I'm probably going to just use Vim in the future.
14:05:01 <wy> hello~
14:05:08 <oerjan> ouch
14:05:27 <oerjan> hi wy
14:05:31 <wy> I just found that I lost one night's sleep ;-)
14:06:00 <wy> gradually in a week...
14:06:34 <jonafan> just one?
14:07:13 <wy> I slept later and later each night, from 3am to 5am to 7am, to... 12pm to 2pm, ...
14:07:15 <ehaas> that makes you 1/7th more effective
14:07:36 <jonafan> oh i see what you mean
14:08:22 <oerjan> @go 28-hour day
14:08:24 <lambdabot> http://www.dbeat.com/28/
14:08:24 <lambdabot> Title: The 28 Hour Day
14:09:25 <jonafan> i would so love to do that
14:09:35 <jonafan> except work would get boring after 10 hours
14:09:39 <ehaas> there haven't been any real long term studies on the health impact of doing that
14:09:43 <jonafan> work gets boring after 5 hours
14:09:47 <ehaas> i'll let someone else be the guinea pig
14:09:55 <jonafan> or even 3 hours
14:09:59 <wy> Is there a way to specify the commutativity of operators?
14:10:01 <jonafan> sometimes it gets boring in a matter of minutes
14:14:12 <wy> I didn't know that I was practicing this cool time system. It would be good if the world agrees
14:14:23 <sclv_> wy: see GHC rules pragmas for some ideas
14:17:05 <ddarius> No one happens to have "Non-Determinism in Functional Languages"?
14:18:45 <oerjan> we may or we may not have.
14:21:50 <ehaas> how do i convert a Double directly to an Int
14:21:51 <oerjan> *it
14:21:59 <Valodim> depends
14:22:02 <oerjan> @src RealFrac
14:22:02 <lambdabot> class  (Real a, Fractional a) => RealFrac a  where
14:22:03 <lambdabot>     properFraction                   :: (Integral b) => a -> (b,a)
14:22:03 <lambdabot>     truncate, round, ceiling, floor  :: (Integral b) => a -> b
14:22:13 <Valodim> truncate to just get rid of the decimal
14:22:20 <Valodim> (I think)
14:22:44 <ehaas> thx
14:25:48 <magnusth> I'm somewhat puzzled: http://hpaste.org/4621#a0
14:25:59 <magnusth> why isn't the exception caught?
14:27:31 <mauke> because (return foo) never throws an exception in IO
14:27:59 <mauke> you'd need to evaluate the whole thing inside CE.catch
14:28:37 <magnusth> mauke, what do you mean?
14:29:03 <mauke> you know, laziness?
14:29:07 <oerjan> magnusth: because of laziness, the part of the code throwing is not evaluated until _after_ catch has returned
14:29:14 <mauke> (return foo) doesn't evaluate foo
14:29:43 <mauke> you can see how it prints [1,66, before hitting the value that blows up
14:29:51 <magnusth> mauke, yes, but surely it needs to be evaluated before catch returns, how would catch now whether an exeption is thrown in (return foo) otherwise?
14:30:00 <mauke> no.
14:30:16 <magnusth> so, catch is lazy?
14:30:24 <magnusth> that sounds backwards to me
14:30:24 <mauke> what do you mean by "it"?
14:30:33 <mauke> it'll evaluate return, but not foo
14:30:38 <oerjan> exceptions in haskell are non-deterministic
14:31:04 <magnusth> what you are saying is that "catch foo handle_error" will return before "foo" is evaluated
14:31:07 <magnusth> ??
14:31:15 <mauke> yes, of course
14:31:19 <mauke> but that's irrelevant
14:31:20 <oerjan> exactly because they do not mesh well with unspecified evaluation orders
14:31:38 <magnusth> but how can I _ever_ handle an exception in that case?
14:31:41 <oerjan> um not foo, but return foo
14:31:51 <Jiten> so the laziness is implemented by returning a pointer to a function that produces the value that doesn't get calculated yet?
14:32:09 <mauke> you wrap the evaluation with catch
14:32:33 <magnusth> mauke, but the "evaluation" can't have  a call to "return" in it?
14:32:42 <mauke> in this case, ghci evaluates the expression by calling 'print'
14:32:43 <mauke> magnusth: huh?
14:33:08 <monochrom> "return" doesn't return, as you will soon find.
14:33:22 <monochrom> > do { return 0; [1,2,3] }
14:33:23 <lambdabot>  [1,2,3]
14:33:27 <monochrom> not 0.
14:33:27 <mauke> "return" is a virtual constructor
14:33:33 <mauke> it wraps stuff in boxes
14:33:40 <magnusth> mauke, well, I tried to minimize the example before asking in here, the actual code is a bit longer
14:33:46 <oerjan> Jiten: it's a two-step redirection.  first a pointer to a thunk, which contains a pointer to the function plus any arguments.
14:34:12 <oerjan> and when finished the function overwrites the thunk with the final value
14:34:35 <magnusth> basically I have a list of Maybe values, I map fromMaybe over it, I can't allow Nothings in the list, so I thought I'd throw an exception
14:34:53 <mauke> magnusth: "error" doesn't really throw an exception
14:35:04 <mauke> on the other hand, Nothing is pretty much ane exception :-)
14:35:43 <Jiten> oerjan: I see.
14:35:53 <magnusth> mauke, yes, but I can't afford to do a sequence over the list, because that won't be lazy enough, basically my stack explodes then :(
14:36:02 <Jiten> so, if it gets evaluated elsewhere, the next time you get the value instead of recalculating it
14:36:11 <mauke> magnusth: you have to
14:37:30 <magnusth> mauke, I simply can't afford to, the input data is of arbitrary length so laziness is required
14:38:21 <magnusth> every Just value should be written to a file, existance of a Nothing should break evaluation and I'd like to delete whatever I've written so far
14:38:43 <mauke> delete how?
14:38:45 <mauke> truncate the file?
14:38:58 <magnusth> mauke, "removeFile fn"
14:39:19 <mauke> ok, so throw a real exception
14:39:45 <oerjan> magnusth: you need to put the catch around the whole file i/o then
14:40:04 <magnusth> oerjan, yes, it already is
14:40:05 <wy> monochrom: Then you will get a type mismatch normally ?
14:40:22 <oerjan> hm that should work
14:40:49 <magnusth> oerjan, not with "error" it doesn't, do you want the whole piece of code?
14:41:03 <mauke> magnusth: use fail instead of error
14:41:08 <mauke> and inside IO
14:41:47 <magnusth> mauke, I was hoping to keep that part of the computation pure, raise some kind of exception and catch it inside IO in my "unpure" functions
14:41:52 <oerjan> mauke: that will ruin his laziness again
14:41:53 <mauke> er
14:42:04 <mauke> how are you going to raise an IO exception outside IO?
14:42:13 <wy> Be right back. I'm figuring out how to put my Ubuntu to suspend...
14:42:30 <mauke> on the other hand, using 'error' should work. kind of.
14:42:58 <oerjan> mauke: um that's what Control.Exception Exceptions are for - they include IO exceptions too
14:43:00 <mauke> if you're in an IO loop, writing values as you go, it should force the computation
14:43:05 <ddarius> magnusth: Which 'catch' are you using?
14:43:25 <mauke> ddarius: Control.Exception
14:43:39 <magnusth> ddarius, Control.Exception.catch
14:43:40 <oerjan> magnusth: better paste some more
14:43:44 <monochrom> http://hpaste.org/4621#a1 for magnusth and interested parties.
14:43:51 <oerjan> especially the catch and file writing part
14:44:15 <monochrom> Short summary: "evaluate"
14:44:41 <mauke> short summary: mapM_
14:44:51 <monochrom> Yeah that's the other factor.
14:44:57 <oerjan> monochrom: that too ruins the laziness
14:45:35 <mauke> oerjan: no, it doesn't
14:45:37 <monochrom> Don't you worry. If you have [ ... Just undefined ... ] somewhere, that undefined won't blow up.
14:46:05 <ddarius> mauke: That will require the whole list to be in memory
14:46:13 <mauke> ddarius: why?
14:46:37 <monochrom> But yes, it forces the whole list, and forces in each item up to the Just/Nothing constructor. The rest is lazy.
14:46:55 <mauke> oh yeah, the return x part
14:48:10 <ddarius> If you were going to do, mapM_ evaluate x >> writeFile "foo" (show x) then it would not have the same streaming behavior.
14:48:22 <monochrom> If you really like to keep laziness and give up purity, unsafePerformIO outside catch.
14:48:48 <mauke> catch (mapM_ print x)
14:48:49 <ddarius> That said, just writeFile "foo" (show x) should do mostly the right thing, if you don't mind having to clean up if something goes wrong.
14:49:20 <ddarius> If magnusth wants to be sure that the write will succeed (as far as this is concerned), there is no way around it.
14:49:23 <lQg_> does ghci support sin cos tan ?
14:49:38 <monochrom> Oh yeah, catch around writeFile, delete file in handler.
14:49:41 <mauke> lQg_: of course
14:49:44 <ddarius> lQg_: Yes, of course.  It supports the whole Haskell language.
14:49:50 <oerjan> > sequence [sin,cos,tan] 1
14:49:51 <lambdabot>  [0.8414709848078965,0.5403023058681398,1.5574077246549023]
14:50:08 <lQg_> o okay
14:50:11 * magnusth off testing stuff
14:50:13 <lQg_> =)
14:50:51 <monochrom> Oh in real world no one can ensure any write succeeds. All you can do is: write to temp file, then decide whether you like it or not. If you like it, move temp file to true target file; if you don't like it, delete temp file, true target file therefore untouched.
14:50:59 <wy> :t sequence
14:51:00 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
14:51:08 <monochrom> For example text-mode email programs do that all the time to your mail box.
14:51:14 <ddarius> monochrom: Hence "as far as this is concerned"
14:51:20 <monochrom> (E.g., "mail", mutt, pine, ...)
14:51:36 <oerjan> wy: ye olde -> monad again
14:51:53 <monochrom> Added benefit is that the true target file is changed or unchanged atomically.
14:52:13 <wy> oerjan: I'm still learning it
14:52:17 <ddarius> monochrom: That is certainly the appropriate way to do these things.
14:53:03 <shachaf> wy: Translate the type: (m a) becomes (r -> a).
14:53:15 <oerjan> wy: sequence may be one of the few cases where using the -> monad _isn't_ fundamentally obfuscating
14:53:54 <ddarius> oerjan: ...
14:54:00 <shachaf> oerjan: You think it's clearer than map ($ x)?
14:54:18 <shachaf> What about join, liftM2, etc.? Those all have uses.
15:01:25 <Cale> The (->) e monad isn't fundamentally obfuscating at all.
15:01:48 <wy> .... Got no help from #ubuntu. Anyone uses it here?
15:02:04 <Cale> The basic idea behind it is that to "run" an action, you apply it to the parameter which is passed to the whole computation.
15:02:30 <Cale> Once you know that, it's not so hard to work out the meanings of all the stuff in Control.Monad
15:02:56 <Cale> wy: Help on ubuntu?
15:03:24 <wy> Cale: Right. I'm trying to make it able to suspend because I hate reboot and open my windows ...etc
15:03:38 <wy> Cale: Do you use it?
15:03:57 <Cale> I use ubuntu, but I hardly ever shut my machine down.
15:04:09 <TSC> In Debian, I've used "hibernate"
15:04:10 <wy> Mine is a laptop
15:04:29 <ddarius> wy: It just worked for me, I believe.
15:04:42 <Cale> Is there something wrong with the suspend button in the quit menu?
15:05:00 <wy> ddarius: I have to resize my swap partition currently. I have 2G ram but I gave it only 1.2G of swap space
15:05:12 <Cale> System -> Quit -> Suspend.  There's also "Hibernate", though to be honest, I have no idea what the difference is.
15:05:15 <Plareplane> i've never had suspend/hibernate work properly on any machine ever. usually some combination of video card/networking fail to come back up properly (for some definition of properly)
15:05:24 <Cale> oh, power consumption
15:05:29 <wy> But I got the messages "Partition 1 does not end on cylinder boundary" for all my partitions
15:05:30 <Plareplane> hibernate writes memory to disk, suspend keeps ram powered
15:06:11 <ddarius> Hibernate turns your computer off, suspend doesn't.
15:06:19 <wy> When I tried that several days ago, the suspend LED just blinked, and monitor turned down. But the fan was still turning. It's not suspended
15:06:45 <Shinuza> wy: Yeah, it should have turned off
15:06:59 <Cale> Here, suspend just seems to turn the screensaver on and lock the X server.
15:07:12 <Cale> (so that I have to enter my password to get back in)
15:07:37 <wy> Shinuza: When I used windows I just hit a hotkey and everything suspends in 2 seconds to ran. and then I can carry it everywhere
15:07:38 <ddarius> Both suspend and hibernate seem to mostly work for me.
15:07:59 <roger`> hibernate on ubuntu, just works for me too.
15:08:09 <Shinuza> wy: On a laptop, it would work correctly most of the time
15:08:28 <wy> maybe because of my ATI driver
15:08:37 <Shinuza> wy: The problem I usually have with hibernate is that I can do it only on time
15:08:51 <Shinuza> the next time I try it It won't go back to the desktop
15:10:35 <toad3k> I have a small question:  How do you catch an exception from the read function?
15:10:48 <oerjan> toad3k: reads
15:10:48 <Cale> heh, hibernate seems isomorphic to shutdown here.
15:11:38 <oerjan> > reads "Notanumber" :: [(Int,String)]
15:11:39 <lambdabot>  []
15:11:46 <oerjan> > reads "15Notanumber" :: [(Int,String)]
15:11:47 <lambdabot>  [(15,"Notanumber")]
15:12:04 <toad3k> hmm, ok that actually works perfectly.  thank oerjan
15:12:06 <wy> Cale: It's nice to suspend. Because it wakes up in 2 seconds and everything back to work as if they haven't been stopped.
15:12:48 <nbarterd> http://hpaste.org/4622 -- how would this bang pattern definition desugar in haskell 98?
15:14:41 <oerjan> nbarterd: inserting a sum `seq` count `seq` after = should do the same i think
15:15:19 <allbery_b> that's my recollection as well
15:18:06 <nbarterd> yep, thanks oerjan.
15:19:01 <magnusth> ddarius, oerjan, thanks for the tips, I ended up moving the catch "down" (or "up) to main so that it covers the writing to the file... not sure who mentioned that but that keeps the laziness nicely
15:21:14 <ddarius> oerjan originally mentioned it
15:23:54 <magnusth> ddarius, it works very well, and now it's so obvious I feel silly for not thinking of it myself... well I guess that just means I'm a novice while oerjan and you are gurus
15:38:09 <toad3k> another question:  How do I make readFile consume the entie file?  (so that it doesn't lock the file for a future writeFile)
15:39:00 <Valodim> trick the laziness?
15:39:08 <oerjan> apply a function to the result that requires looking at the end, such as length or last
15:39:28 <toad3k> I guess that works.
15:40:44 <toad3k> but if I don't actually use the length or tail, laziness won't evaluate it.
15:40:56 <oerjan> for that you have seq
15:41:37 <oerjan> and in IO, evaluate
15:42:09 <toad3k> hmm, ok
15:42:32 * ddarius would just use a strict readFile.
15:42:37 <byorgey> @type evaluate
15:42:38 <lambdabot> forall a. (Testable a) => a -> Gen Result
15:42:53 <byorgey> oerjan: what's evaluate?  I've never heard of that.
15:43:05 <oerjan> that's not the one
15:43:14 <ddarius> :t Control.Exception.evaluate
15:43:14 <oerjan> :t System.IO.evaluate
15:43:15 <lambdabot> forall a. a -> IO a
15:43:15 <lambdabot> Not in scope: `System.IO.evaluate'
15:43:19 <oerjan> oh
15:43:36 <byorgey> oh, interesting
15:44:01 <oerjan> right it's there for things like what magnusth was asking earlier
15:44:11 <oerjan> i guess
15:44:44 <oerjan> it's almost but not quite the same as (return $!)
15:44:51 <oerjan> @src evaluate
15:44:52 <lambdabot> evaluate a = IO $ \s -> case a `seq` () of () -> (# s, a #)
15:45:03 <ddarius> It's for when you want something to be forced when the IO action is run, not when it is evaluated.
15:45:26 <byorgey> I see, that makes sense.
15:45:45 <ddarius> The difference is (return $! undefined) `seq` () is undefined while evaluate undefined `seq` () is not.
15:46:06 <ddarius> Meanwhile, evaluate undefined >> return () is undefined while return undefined >> return () is not.
15:47:09 <Valodim> man these roman numbers are pissing me off
15:48:01 <byorgey> Valodim: hm, the rest of us upgraded... maybe you didn't get the memo =)
15:48:20 <Valodim> doing the euler problems
15:48:31 <byorgey> heh, I figured it was something like that =)
15:48:52 <Valodim> good way of getting into the syntax
15:49:00 <byorgey> indeed
15:49:35 <Valodim> without monads you can't do much but mathematical calculations, and learning those without at least some intuition of the syntax is really difficult
15:49:54 <Valodim> wrote romanRead and romanShow routines and checked 10 results, they were all correctly parsed and printed out
15:50:09 <Valodim> but the result isn't correct
15:50:18 <magnusth> quick, and possibly silly question: will an uncaught throwIO be a filure from a system POV, or should I call exitFailure?
15:50:37 <magnusth> oups :) s/filure/failure/
15:51:19 <ddarius> magnusth: Try it and find out.
15:51:55 <magnusth> ddarius, I'm in the middle of a darcs checkin, was hoping I could get a quick answer :)
15:52:10 <ddarius> magnusth: I suspect it will, but I really don't know.
15:54:39 <magnusth> ddarius, yes, it seems that an uncaught throwIO is a failure: if (dont_catch_throwIO); then echo "success"; fi doesn't print anything
15:55:06 <magnusth> calling something that doesn't end on a throwIO does print "success"
15:55:09 <magnusth> good!
15:55:29 <duki> hello everyone
15:56:12 <byorgey> Valodim: try using QuickCheck to help
15:56:23 <KirinDave> Hey, I'm interested in a good introduction to haskell book. I know functional programming from ocaml and erlang, but I don't know some of the more haskell specific concepts. Can anyone recommend.
15:56:31 <KirinDave> ?
15:56:35 <byorgey> Valodim: e.g. you could check that romanRead (romanShow n) == n
15:56:36 <allbery_b> yes, it does exit(1)
15:56:42 <Valodim> quickcheck?
15:56:57 <Valodim> that's a good idea
15:57:24 <byorgey> Valodim: it's a library for testing properties with randomly generated data.
15:57:31 <magnusth> that's it for me tonight, thanks for all the help!
15:57:39 <byorgey> night magnusth
15:58:16 <byorgey> KirinDave: do you specifically want a physical book, or are online resources OK too?
15:58:26 <oerjan> magnusth: "A program that fails in any other way is treated as if it had called exitFailure. A program that terminates successfully without calling exitWith explicitly is treated as it it had called exitWith ExitSuccess."
15:58:45 <oerjan> (from System.Exit docs)
15:58:53 <Valodim> ooh I think I found it
15:58:59 <byorgey> =D
15:59:01 <KirinDave> byorgey: I prefer a dual format, but pure physical is preferred to pure online. Both are fine.
15:59:05 <Valodim> MCM -> 2100
15:59:12 <Valodim> oh god, I am so stupid >_>
15:59:13 <byorgey> Valodim: oops =)
15:59:17 * magnusth fades into black
15:59:38 <Valodim> http://hpaste.org/4623 <- check it out. been debugging the show for ~an hour, and just look at the read
16:00:33 <byorgey> KirinDave: well, I'm not as familiar with paper-book resources.  I've heard good things about Graham Hutton's book, although I think it's intended for a beginner level which sounds like probably not what you're looking for.
16:00:42 <Valodim> the answer is still not correct but it is now closer to working correctly than before :P
16:01:21 <KirinDave> byorgey: Well I hear things about haskell entering into the world of concurrency. And I'd like to check it out.
16:01:54 <KirinDave> byorgey: Lately I've been a full time erlang programer, but I hear that haskell is better suited to more script-like functionality which erlang is fairly bad at.
16:02:59 <byorgey> KirinDave: that sounds pretty accurate, although I'm not very familiar with Erlang.
16:03:30 <KirinDave> Well I am, and I've been looking at the concurrency operators in haskell. They seem kinda primitive, but the functional part is more evolved, so it could be a useful tool.
16:04:33 <scandal> i was curious about the question earlier regarding reading the last line of a file.  i was able to get the imperative style version working, but I wanted to try and build a version using the State monad.  here is my first attempt: http://hpaste.org/4624
16:05:21 <byorgey> KirinDave: have you checked out http://www.haskell.org/haskellwiki/Books_and_tutorials ?
16:05:23 <lambdabot> Title: Books and tutorials - HaskellWiki
16:05:28 <Saizan_> well haskell has not a native support for distribuited programming, but STM is very nice, at an higher level than message passing for in-process concurrency
16:05:40 <scandal> the problem is that it attempts to read the entire file.  i was hoping that it would be 'lazy' so that I could just compose it with  reverse.head.lines
16:07:03 <Valodim> reverse after head?
16:07:16 <Valodim> you reverse the strings?
16:07:26 <scandal> Valodim: because it returns the byte stream in reverse order
16:07:34 <Valodim> ah
16:07:40 <allbery_b> scandal: assuming you reverse the right thing, that'll strictify it
16:07:46 <oerjan> scandal: alas monad transformers over IO are never lazy
16:07:53 <scandal> doh
16:08:30 <oerjan> so the sequence performs all reads always
16:09:16 <scandal> yeah, i figured that wasn't the right way.  but i didn't now how you would just rerun getChar' repeatedly to get the next byte and append it to the output
16:09:18 <oerjan> you could try unsafeInterleaveIO to make something similar to readFile/getContents
16:10:12 <Saizan_> doesn't that die with an EOF exception?
16:10:31 <scandal> Saizan_: yeah, i was hopign that it would be lazy
16:10:37 <scandal> to avoid that issue
16:10:54 <scandal> since it is strict, you get an eof exception before anything is returned
16:11:27 <Saizan_> well fortunately IO is strict :), it would be a pain otherwise :)
16:11:34 <oerjan> you'd get trouble if the file was just one line in any case...
16:16:17 <scandal> Saizan_: well thats the thing i dont understand.  how come this will print out the each line instead of waiting until all the input is read:
16:16:32 <scandal> main = do s <- getContents
16:16:33 <scandal>           mapM_ print (lines s)
16:16:41 <oerjan> getContents cheats
16:16:52 <Saizan_> because getContents is written with unsafeInterleaveIO
16:16:54 <oerjan> using the aforementioned unsafeInterleaveIO
16:17:00 <scandal> ah
16:17:19 <Saizan_> which injects laziness, more or less
16:21:33 <duki> I am trying to lauch xmonad with startx (/usr/bin/xmonad &) in .xinitrc or with qingy (putting /usr/bin/xmonad) in /etc/X11/sessions,  but after X run, noting else. just at X
16:22:04 <jsnx> are undecideable instances like `instance Show Foo` followed by `instance Show (Foo, Foo)` allowed in Haskell?
16:23:03 <allbery_b> in standard Haskell, no.  ghc has options to enable them but the resulting behavior may not be what you expect
16:23:40 <jsnx> allbery_b: when you say, not what I expect, you mean...undefined?
16:24:02 <allbery_b> worst case the typechecker goes into an infinite loop.
16:24:25 <jsnx> ai yai ai yai ai!
16:24:56 <ddarius> What's undecideable about instance Show Foo; instance Show (Foo,Foo)?
16:24:57 <scook0> hence "undecidable"
16:25:03 <allbery_b> even if that doesn't happen, it doesn't necessarily select the most specific matching instance (I forget the details, but it doesn't even try to determine most specific)
16:25:58 <scook0> ddarius: Show a => Show (a, a) will interfere
16:26:12 <Saizan_> ah, so overlapping
16:26:12 <scook0> though I don't know if that qualifies as "undecidable"
16:26:20 <scook0> but it will require some kind of extension flag
16:26:32 <Saizan_> and with overlapping you do get the most specific one
16:26:52 <ddarius> scook0: He didn't list instance Show a => Show (a,a)
16:26:54 <Saizan_> only incoherent instances are really hard to predict
16:27:30 <ddarius> Perhaps you meant instance (Show a, Show b) => Show (a,b)?
16:27:36 <scook0> ddarius: yes
16:27:44 <scook0> thanks
16:27:52 <ddarius> Yes, that's overlapping not undecideable.
16:27:56 <wferi> Hi! What's now the preferred library/method for UTF-8 output?
16:28:03 <jsnx> overlapping is what i meant
16:28:11 <jsnx> wferi: utf8-string is nice
16:28:20 <ddarius> @where hackage
16:28:21 <lambdabot> http://hackage.haskell.org/
16:28:28 <scook0> ddarius: I wasn't sure whether you were objecting to undecidable, or objecting to there being a problem at all
16:30:54 <wferi> Thanks for the pointer. Description: Support for encoding UTF8 Strings to and from [Word8].
16:30:57 <Valodim> ok readRoman. showRoman works for 30+ random variables
16:31:15 <wferi> isn't this description somehow strange? A string isn't utf8, is it?
16:31:34 <wferi> [word8] can be utf8 AFAIU
16:32:57 <oerjan> wferi: that description sounds a little backwards, as you say it's the [word8] side that is utf8
16:33:19 <allbery_b> wferi: utf8 is an encoding of unicode codepoints into strings composed of bytes.  Haskell String is theoreticlally Unicode codepoints, but practically the I/O subsystem only handles bytes
16:33:30 <allbery_b> it should probably say UTF8-encoded strings
16:33:32 <wferi> wait, encodeString :: String -> String
16:33:38 <dons> the IO subsystem writes bytes at the lowest level
16:33:45 <dons> but you can encode and decode those bytes as you see fit
16:33:51 <dons> and Char is a 32 bit value
16:34:12 <dons> so, use utf8string if you need utf8 on top of the basic byte layer
16:34:21 <wferi> looks like this library really defines "utf8 string"
16:34:45 <sclv> @ty let dot = (.).(.) in concat `dot` sequence
16:34:46 <lambdabot> forall a a1. [a1 -> [a]] -> a1 -> [a]
16:34:55 <wferi> what is utf8string? is that a function in some module?
16:34:57 <dons> it lets you do IO on top of the byte layer,wferi preserving utf8 encodings
16:35:29 <wferi> what is "it"?
16:35:30 <sclv> such a pretty function -- it should have a name and stuff.
16:37:04 <oerjan> @unpl (.).(.)
16:37:05 <lambdabot> (\ i b c f -> i (b c f))
16:37:07 <wferi> System.IO.UTF8.putStr :: String -> IO () outputs the given string in UTF-8, right? While putStr simply strips off the high bytes.
16:37:55 <sclv> catenate?
16:39:08 <gwern> I have a question. suppose I have a module full of functions
16:39:22 <gwern> and all these functions are reimplementations of classic shell utilities
16:39:30 <wferi> anybody knows whether Codec.Binary.UTF8.String.decode throws an exception on invalid UTF-8 input?
16:39:43 <oerjan> gwern: there's a getProgName somewhere
16:39:51 <gwern> and in the interests of usability for quick scripting, I want to set up a second module which imports all the functions from the second but applies unsafePerformIO
16:39:52 <sclv> do we like catenate?
16:40:00 <gwern> so one isn't mucking around with IO
16:40:13 <ddarius> gwern: Are you insane?
16:40:27 <gwern> is there any eaiser way to do it than to go 'cat = unsafePerformIO Module.cat' for each and every function?
16:40:41 <ddarius> gwern: Not really.
16:40:41 <gwern> any way to map unsafePerformIO over re-exported stuff?
16:40:41 <sclv> btw: this is the function last night that I ended up defining as flip (swing (=<<))
16:41:00 <gwern> ddarius: I do not believe so, but if I were insane, I could be wrong about not being insane
16:41:12 <chessguy_> @type flip  (?swing (=<<))
16:41:13 <lambdabot> forall a b c a1 (m :: * -> *) b1. (?swing::((a1 -> m b1) -> m a1 -> m b1) -> a -> b -> c, Monad m) => b -> a -> c
16:41:57 <sclv> @ty let swing f c a = f ($ c) a in flip (swing (=<<))
16:41:58 <lambdabot> forall a (m :: * -> *) b. (Monad m) => m (a -> m b) -> a -> m b
16:42:33 <gwern> so there is no clever way to avoid all that repetition? that's kind of disapointing
16:43:11 <chessguy> i wonder if TH or some other templating stuff could do it?
16:43:34 <gwern> chessguy: I dunno. why I am asking
16:43:35 <ddarius> TH might be able to do it if it able to query modules
16:45:56 <chessguy> well clearly something somewhere can query modules, because ghc et al. have to do it, right?
16:48:21 <allbery_b> ghc does but that doesn't guarantee that the information is placed where TH can get to it
16:48:21 <scandal> @hoogle [m a] -> m [a]
16:48:21 <lambdabot> Prelude.head :: [a] -> a
16:48:21 <lambdabot> Prelude.last :: [a] -> a
16:48:21 <lambdabot> Data.List.head :: [a] -> a
16:48:21 <ddarius> That's a bit different.  However, worst case scenario you -can- use GHC API or whatever to parse the .hi/.o files or you can parse the other file from TH.  You can do arbitrary IO and computation.
16:48:21 <chessguy> @type sequence
16:48:21 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
16:48:21 <oerjan> scandal: @hoogle is not good with monads
16:48:21 <oerjan> has some bugs
16:48:21 <scandal> thanks
16:48:21 <chessguy> @hoogle (Monad m) => [m a] -> m [a]
16:48:21 <lambdabot> Prelude.head :: [a] -> a
16:48:21 <lambdabot> Prelude.last :: [a] -> a
16:48:21 <lambdabot> Data.List.head :: [a] -> a
16:48:21 <chessguy> @type forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
16:48:21 <lambdabot> parse error on input `*'
16:48:21 <chessguy> silly bot
16:48:21 <chessguy> on that note, back to the real world
16:49:48 <wferi> Hmm, I can't see any input checking in Codec.Binary.UTF8.String.decode. How comes? There surely are byte sequences which aren't valid UTF-8.
16:50:51 <gwern> hm. the TH wiki page mentions as a wishlist item 'The ability to add things to the export list from a splice(?)'
16:51:12 <scandal> is the source for hGetContents available online anywhere?  i'd like to see how it uses unsafeInterleaveIO
16:51:20 <ddarius> scandal: It does.
16:51:22 <dons> its in GHC/IO.hs
16:51:25 <ddarius> @src hGetContents
16:51:26 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
16:51:36 <wferi> Well, maybe it simply inserts replacement_character in case of error...
16:52:26 <allbery_b> @source GHC.IO
16:52:26 <lambdabot> GHC.IO not available
16:52:32 <allbery_b> hm
16:53:07 <wferi> Sven Moritz Hallberg's UTF8.lhs has decode :: [Word8] -> ([Char], [(Error,Int)]) which makes more sense to me.
16:54:39 <scandal> erg, ok, way over the head of this haskell newbie
16:55:34 <gwern> ddarius: anyway, so what's so bad about a IO-less module for convenience?
16:56:53 <ddarius> gwern: If they are all pure functions, then they didn't need to be in IO in the first place, if not, there is a reason there is essentially no lazy-by-default imperative language in existence.
16:57:31 <gwern> ddarius: haskell includes lazy io stuff
16:57:51 <gwern> if you're just constructing a pipeline, then you already have something of a monad going there
16:58:22 <ddarius> gwern: And the "lazy IO stuff" is a constant source of problems.
16:58:23 <gwern> cat foo | uniq | sort | tee file... doesn't matter whether cat and tee are in io
16:58:48 <ddarius> gwern: Try it and see what happens.
16:59:10 <gwern> ddarius: well, I can't without a lot of tedious typing, that's the issue
16:59:23 <ddarius> gwern: It's called sed or awk or an editor macro.
16:59:51 <gwern> macros don't seem very haskelly or abstract...
17:00:34 <ddarius> Editor macros are designed to (partially) solve the problem of tedious typing, why not use them for that?
17:00:35 <gwern> wait, I guess TH can't do it after all - http://cvs.haskell.org/trac/ghc/ticket/1475
17:00:39 <lambdabot> Title: #1475 (Adding imports and exports with Template Haskell) - GHC - Trac
17:00:50 <ddarius> gwern: You don't need to add imports and exports.
17:02:51 <wy> back
17:11:05 <wy> What does "orphaned project" mean? I found HIDE just now and it says it's orphaned
17:11:05 <ddarius> Presumably that it has no maintainer.
17:11:05 <wy> ddarius: I hope there is an IDE, maybe an universal IDE for all languages
17:11:05 <sclv> wy: have you explored all the features of haskell-mode in emacs fully?
17:11:21 <sclv> there's also flymake bindings on the emacs wiki
17:11:33 <wy> sclv: Not all. But I feel emacs is not the way...
17:11:50 <sclv> emacs is the universal ide after all.
17:11:59 <sclv> s/ide/thingamajig/
17:12:03 <wy> It must be replaced sooner or later
17:12:43 <wy> or evolved faster
17:13:14 <wy> The problem is that it doesn't really understand any language except elisp
17:13:16 <Valodim> http://hpaste.org/4625 <- can someone please give me a hint what I'm doing wrong here?
17:13:31 <Valodim> is it not possible to define "end of list see here" like elements, only self-referential?
17:14:06 <sclv> What I'd really like for a haskell ide, but seems hellaciously hard, would be the ability to select a subsection of code and determine its type on the fly.
17:14:30 <sclv> i.e. not just top level functions, but anything.
17:14:55 <oerjan> Valodim: the collatz sequence has some numbers which grow a _lot_ before shrinking again
17:15:07 <ddarius> sclv: It's not particularly hard, it just requires either a much tighter integration with an implementation or another implementation of the type checker.
17:15:07 <wy> right. haskell-mode currently can't know the types that's not declared
17:15:46 <sclv> ddarius: right. it's all stuff ghc and hugs have to figure out stuff internally anyway.
17:15:53 <oerjan> and also, looking up !!n is O(n)
17:16:03 <sclv> wy: actually, with emacs-inferior-mode you can automagically insert type signatures.
17:16:25 <Valodim> for 99999 you can see each single number being computed , all numbers being around 7 digits
17:16:53 <sclv> I don't like inferior mode though, because there's no proper readline when interacting with ghci.
17:16:55 <Valodim> mmmmmhh
17:17:54 <wy> sclv: I saw Anjuta just now and it looks good.
17:18:04 <oerjan> Valodim: moreover, for every number less than n it needs to allocate a thunk
17:18:54 <sclv> Valodim: do you know Debug.Trace?
17:19:00 <Valodim> nope
17:19:11 <sclv> ?hoogle Debug.Trace.trace
17:19:12 <lambdabot> No matches, try a more general search
17:19:33 <wy> Is there a language for describing semantics so that it can be used to implement plugins for an IDE for any language?
17:19:54 <sclv> take a look -- it lets you unsafely insert an i.o. call inside any thunk, so that you can watch how many times it gets executed and with what arguments.
17:20:00 <sclv> very nice for trying to reason about CAFs
17:20:01 <Valodim> that can be done with regular grammars
17:20:08 <Valodim> ok
17:20:32 <wferi> Valodim: what's this, by the way? Looks somehow familiar.
17:20:50 <sclv> i.e. if you have a func foo x= bar x. then you can instead have:
17:20:51 <Valodim> what's what?
17:20:52 <Valodim> the paste?
17:21:09 <wferi> yes, what does this function compute?
17:21:17 <Valodim> the collatz sequence
17:21:18 <sclv> foo x =  trace (show x ++ "\n") $ bar x
17:21:23 <wy> Have you tried Yi?
17:21:36 <Valodim> "if even, n/2, otherwise 3n+1"
17:21:43 <Valodim> what is Yi
17:22:13 <Valodim> I see
17:22:22 <wferi> :) I can read, actually. Now found Lothar Collatz on Wikipedia.
17:23:35 <Valodim> man haskell is somewhat more difficult to predict than other languages
17:24:02 <wferi> Just found strange you provided a base case for x=1 but started the iteration from x=0.
17:24:40 <Valodim> I could leave zero out, but then I'd have to use -1 on the index
17:25:20 <wferi> or start counting from 1?
17:25:36 <Valodim> ?
17:25:43 <wferi> x<-[1..]
17:25:46 <Valodim> yes
17:25:57 <Valodim> but I'd have to subtract one from all !! calls then
17:26:27 <wferi> yes.
17:26:36 <Valodim> the method obviously sucks that way, gonna redo it. or do something else.
17:27:03 <sclv> Valodim: did you learn anything interesting from the traces?
17:27:14 <ddarius> wferi: The function computes 1.
17:27:22 <sclv> I have a suspicion that a 2-deep CAF might not work very well.
17:27:25 <wferi> :) Probable.
17:27:28 <TSC> Valodim: Maybe the linear time of !! is hurting you
17:27:37 <sclv> you could try to memoize with a better structure.
17:27:39 <Valodim> not tried yet, been googling/writing/stuff since
17:27:43 <Valodim> yeah
17:27:53 <wferi> There's no proof, AFAIK.
17:28:07 <sclv> the memoization page at the haskell wiki should be pretty good now.
17:28:11 <Valodim> I thought cross-referencing those lists would save some memory, if you have computed collatz 5273952  before, no need to do it again if you find that number in a sequence
17:28:20 <Valodim> but that approach doesn't work
17:28:51 <sclv> Do you have an expected max bound on how high the values will go?
17:28:58 <wferi> Use an array instead, if you can.
17:29:05 <ddarius> wferi: If it returns, it clearly returns 1.
17:29:30 <sclv> an IntMap should actually give pretty decent performance too.
17:29:52 <wy> Where does Cabal install packages to?
17:30:26 <sjanssen> wy: /usr/local by default
17:30:41 <wferi> ddarius: the last element, if exists, is 1.
17:31:02 <sclv> except, then you need to not overflow int bounds of course.
17:31:17 <wy> sjanssen: I'm just wondering if cabal installed package will break ubuntu's package system
17:31:31 <davidL> How can I simplify (fromIntegral a, fromIntegral b, fromIntegral c)?
17:32:10 <sjanssen> davidL: let fi = fromIntegral in (fi a, fi b, fi c) -- :(
17:32:22 <wy> sjanssen: How do you usually install those packages?
17:32:35 <sjanssen> wy: I use --prefix=$HOME --user
17:32:50 <wy> sjanssen: Good idea :-)
17:32:53 <sjanssen> wy: that installs the package for that user only
17:33:07 <davidL> sjanssen: no magic monad stuff to apply a function to each element in a 3-tuple? :-(
17:33:08 <wy> sjanssen: How do you deal with the dependencies?
17:33:33 <sjanssen> wy: manually, or sometimes I'll use cabal-install
17:33:48 <sclv> davidL: how do you have a guarantee that each element in a 3-tuple will have a compatible type?
17:34:25 <sjanssen> davidL: nope
17:34:40 <sclv> if you need to do it a whole bunch, you could always define app3 f (x, y, z) = (f x, f y, f z) of course.
17:35:16 <davidL> sclv: this is what I have: (fromIntegral $ x `shiftR` 12, fromIntegral $ (x `shiftR` 6) .&. 0x3f, fromIntegral $ x .&. 0x3f)
17:39:01 <oerjan> seems there could be a need for on3 etc.
17:42:15 <ddarius> wferi: Typically, it's just defined as collatz 1 = 1; collatz n | even n = collatz (n `div` 2) | otherwise = collatz (3*n+1)
17:42:46 <davidL> > let f x = liftM3 (,,) (fromIntegral . (`shiftR` 12)) (fromIntegral . ((.&. 63) . (`shiftR` 6))) (fromIntegral . (.&. 63)) in f 579
17:42:47 <lambdabot>  <Integer -> (Integer,Integer,Integer)>
17:43:45 <ddarius> "In the 17'th Century, even so learned a man as Halley did not have the habits of full, clear expression that we expect in scholarly works today."
17:43:47 <oerjan> missing or superfluous x
17:44:07 <davidL> oh, err
17:44:38 <davidL> > let f = liftM3 (,,) (fromIntegral . (`shiftR` 12)) (fromIntegral . ((.&. 63) . (`shiftR` 6))) (fromIntegral . (.&. 63)) in f 847
17:44:39 <lambdabot>  (0,13,15)
17:45:22 <sclv> > length "liftM3 (,,) (fromIntegral . (`shiftR` 12)) (fromIntegral . ((.&. 63) . (`shiftR` 6))) (fromIntegral . (.&. 63)) "
17:45:24 <lambdabot>  112
17:45:44 <sclv> > length "(fromIntegral $ x `shiftR` 12, fromIntegral $ (x `shiftR` 6) .&. 0x3f, fromIntegral $ x .&. 0x3f)  "
17:45:45 <lambdabot>  99
17:46:32 <davidL> > length "fromIntegral fromIntegral fromIntegral" - "fi fi fi where fi = fromIntegral"
17:46:33 <lambdabot>  Couldn't match expected type `Int' against inferred type `[Char]'
17:46:41 <davidL> > length "fromIntegral fromIntegral fromIntegral" - length "fi fi fi where fi = fromIntegral"
17:46:42 <lambdabot>  6
17:46:55 <Valodim> haha
17:47:22 <sclv> > let f = (,,) <$> (fromIntegral . (`shiftR` 12)) <*> (fromIntegral . ((.&. 63) . (`shiftR` 6))) <*> (fromIntegral . (.&. 63)) in f 847
17:47:23 <lambdabot>  (0,13,15)
17:47:51 <sclv> > length "(,,) <$> (fromIntegral . (`shiftR` 12)) <*> (fromIntegral . ((.&. 63) . (`shiftR` 6))) <*> (fromIntegral . (.&. 63))"
17:47:52 <lambdabot>  116
17:47:59 <sclv> prettier though, I think.
17:48:09 <Valodim> totally
17:49:27 <davidL> Is Control.Applicative in 6.8.* only?
17:49:30 <sclv> why you need fromIntegral anyway?
17:49:38 <sclv> Control.Applicative is 6.6 too.
17:50:00 <davidL> the input is Word16 and I want (Word8, Word8, Word8)
17:50:31 <sclv> by which I mean, I've found that with fromIntegral the trick tends to be trying to figure out where to place them in your program so that you have to use the least amount.
17:51:28 <sclv> ?quote fromIntegral
17:51:28 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
17:51:37 <davidL> > (38573 :: Word16) `shiftR` 12 :: Word8
17:51:38 <lambdabot>  Couldn't match expected type `Word8' against inferred type `Word16'
17:51:52 <davidL> :-(
17:52:01 <sclv> ?ty shiftR
17:52:02 <lambdabot> forall a. (Bits a) => a -> Int -> a
17:52:05 <oerjan> @pl on3 t f x y z = t (f x) (f y) (f z)
17:52:06 <lambdabot> on3 = join . ((flip . ((flip . ((.) .)) .)) .) . join . ((flip . ((.) .)) .) . (.)
17:52:22 <sclv> @unpl join . ((flip . ((flip . ((.) .)) .)) .) . join . ((flip . ((.) .)) .) . (.)
17:52:22 <lambdabot> (\ z -> (\ az b c f i -> ((\ bi n o r -> z (bi o) (n r)) >>= \ ao -> ao) az c f (b i)) >>= \ aa -> aa)
17:52:33 <sclv> @undo (\ z -> (\ az b c f i -> ((\ bi n o r -> z (bi o) (n r)) >>= \ ao -> ao) az c f (b i)) >>= \ aa -> aa)
17:52:34 <lambdabot> (\ z -> (\ az b c f i -> ((\ bi n o r -> z (bi o) (n r)) >>= \ ao -> ao) az c f (b i)) >>= \ aa -> aa)
17:52:53 * araujo hates global variables
17:53:13 <sclv> \ao -> ao! genius!
17:53:23 <dons> http://programming.reddit.com/info/63neg/comments/ yay SyntaxNinja blogging again :)
17:54:06 * araujo ends up programming Ã  la Haskell using any other language
17:54:46 <ddarius> araujo can write Haskell in any language.
17:55:08 <oerjan> @pl on3 t f x = t (f x) `on` f
17:55:08 <lambdabot> on3 = join . ((flip . (on .)) .) . (.)
17:55:15 <ddarius> dons: I read that on Planet Haskell and didn't even realize it was Isaac.
17:55:25 <dons> :)
17:56:10 <araujo> Every time I find some algorithm or procedure that gets messy or hard to write , I think in terms of Haskell and the solution comes up
17:56:19 <sclv> sigh. I should just write a default php security consultant report that says: Yes. Your application is insecure. Hope that nobody notices. Everybody else does it!
17:56:38 * araujo thinks he understands now why Haskell belongs to the meta-language branch family
17:57:16 <Valodim> it is possible to write secure php code
17:57:31 <dons> for some definition of secure, Valodim.
17:57:33 <EvilTerran> yeah, you can write haskell in any language if you try hard enough ;)
17:57:34 <Valodim> the problem is, noone cared about that five years ago, and most widespread applications are that old
17:57:40 <ddarius> Valodim: Sure.  Don't connect it to the Internet.
17:57:46 <Cale> haha
17:57:59 <sclv> for some definition of code.
17:58:01 <Valodim> :P
17:58:27 <oerjan> @check \t f x y z -> on (t (f (x::Bool)::Bool) f (y::Bool) (z::Bool)::Bool) == t (f x) (f y) (f z)
17:58:29 <lambdabot>   Not in scope: `on'
17:58:37 <araujo> Probably the bad side of it is that people when look at your code says ... "wth? ... why are you using <x-language> like this?" :-P
17:58:38 <sclv> masses of major os codebases still require registerGlobals, etc.
17:58:46 <Cale> araujo: Well, it looks a whole lot like ML in terms of the type system and pattern matching, etc.
17:58:50 <oerjan> @let on (+) f x y = f x + f y
17:58:53 <lambdabot> Defined.
17:58:55 <oerjan> @check \t f x y z -> on (t (f (x::Bool)::Bool) f (y::Bool) (z::Bool)::Bool) == t (f x) (f y) (f z)
17:58:56 <lambdabot>  Couldn't match expected type `t1 -> t1 -> t2'
17:59:05 <Valodim> registerGlobals was one of the worst ideas in the history of programming languages
17:59:13 <Valodim> next to delphi
17:59:24 <araujo> Cale, yeah, but I meant more in the term of a kind of language that helps you think well in terms of other languages.
18:00:00 <oerjan> @check \t f x y z -> (on t (f (x::Bool)::Bool) f (y::Bool) (z::Bool)::Bool) == t (f x) (f y) (f z)
18:00:01 <lambdabot>  Couldn't match expected type `t -> t1' against inferred type `Bool'
18:01:22 <oerjan> :t let on (+) f x y = f x + f y in [t (f x) (f y) (f z), (t (f x) `on` f) y z]
18:01:23 <lambdabot> Not in scope: `t'
18:01:26 <lambdabot> Not in scope: `f'
18:01:26 <lambdabot> Not in scope: `x'
18:01:37 <sk> hi araujo
18:01:37 <oerjan> :t let on (+) f x y = f x + f y in \t f x y z -> [t (f x) (f y) (f z), (t (f x) `on` f) y z]
18:01:38 <lambdabot> forall t t1 t2. (t1 -> t1 -> t1 -> t) -> (t2 -> t1) -> t2 -> t2 -> t2 -> [t]
18:01:42 <araujo> hello sk
18:02:03 <sk> i just happened to read an article of yours about gui toolkit, what coincidence :)
18:02:13 <dons> http://lambdalounge.blogspot.com/2007/12/my-type-of-language.html
18:02:14 <lambdabot> Title: Lambda Lounge: My Type of Language...
18:02:21 <dons> wow, this guy is enthusiastic
18:02:43 <ddarius> Puffins are cute.
18:02:54 <sclv> oh wow. the SM_PATH variable that the hack overwrote is the base path, so includes get called from there. And thanks to the magic of PHP, it treats remote urls just like local files!
18:03:11 <davidL> sclv: thanks btw
18:03:26 <sclv> that's pretty awesome, in an evil way.
18:05:29 <cpst> decent idea for a post, but poorly written
18:07:05 <dons> cpst: which one?
18:07:14 <cpst> the last one you linked
18:07:29 <dons> yeah, its a bit stream-of-conciciousness :)
18:08:55 <sk> wonder how many ppl started scheme b4 haskell..
18:09:27 <dons> ?users #xmonad
18:09:28 <lambdabot> Maximum users seen in #xmonad: 107, currently: 78 (72.9%), active: 6 (7.7%)
18:10:10 <ddarius> sk: I'd bet most had some experience with Scheme before using Haskell, or at the very least most ignoring students.
18:10:26 <dons> well, in the US maybe?
18:10:35 <dons> in .au i don't think scheme is taught anywhere..
18:11:32 <sk> for me at least, but somehow or rather scheme makes my fingers tired to type that much for little to happen, which brings me to haskell
18:11:58 <ddarius> dons: I was mainly referring to people who were not taught (Haskell) programming
18:11:59 <ivanm> dons: it was
18:12:10 * sclv took brian harvey's intro class in scheme at berkeley (using, I recall, SICP) and suspects that's the last time he had fun programming until haskell.
18:12:11 <ivanm> up here in queensland
18:12:17 <ivanm> but UQ is changing to Python AFAIK
18:12:22 <dons> ivanm: well, that's queensland for you :)
18:12:25 <ivanm> QUT might be sticking with scheme though
18:12:25 <ivanm> heh
18:12:43 <ddarius> dons: A decent chunk of Scheme in the US.
18:12:52 <dons> the US is a weird place
18:12:57 <ddarius> The US was always the Common Lisp/Scheme place.
18:13:17 <wy> But now every school is using Java...
18:13:50 <wy> Is this related to Bush?
18:13:54 <sclv> I thought germany was pretty functional-heavy too.
18:14:06 <Valodim> <- :)
18:14:11 <ddarius> sclv: Yes, but more the statically typed school.
18:14:26 <allbery_b> intro courses in US tend to be Java, upperclass Scheme, Haskell is relegated to graduate programs
18:14:33 <sk> one question for everyone, what is your favourite gui toolkit?
18:15:10 <dons> favourite?
18:15:13 <dons> what if they all suck?
18:15:22 <ddarius> (hint: they do all suck)
18:15:29 <ivanm> s/favourite/least hated/
18:15:32 <wy> We used SML in graduate PL course, OCaml in undergrad PL course, but most of the other courses use Java
18:15:33 <ivanm> sk: there, fixed it for you :p
18:15:34 <dons> least hated eh?
18:15:53 <sk> but u might still need to pick one, yea least hated
18:15:54 <puusorsa> phooey!
18:16:06 <sk> ivanm: thanks lots
18:16:13 <ivanm> heh, no probs ;-)
18:16:16 <clanehin> at my college it was almost entirely java, in seven years I never heard the word "haskell", and incidentally, our chancellor was bush's former science advisor in texas :(
18:16:19 <sclv> c/c++ is still a necessity for operating systems, databases & cet.
18:16:19 <araujo> sk, gtk2hs
18:16:43 <ddarius> clanehin: Was he from Haskell, TX?
18:16:56 <ddarius> sclv: Why do you say that?
18:17:06 <clanehin> ddarius: no, she wasn't
18:17:49 <sclv> ddarius: well, the closer to the metal you get, the better for those sorts of things, learningwise, right?
18:18:02 <araujo> wy, it's related to Sun world-wide campaign for infecting all univ and schools with java
18:18:11 <sclv> heck, folks should even learn a little assembly, i think.
18:18:18 <araujo> replacing pascal & c where possible
18:18:27 <Valodim> pascal sucks
18:18:30 <Valodim> and C is the new asm
18:18:37 <sclv> otherwise, how do you reason about what's really happening?
18:18:38 <araujo> anything else is better than java
18:18:47 <araujo> even brain f***
18:18:49 <sk> i dont know java all that much
18:18:52 <Valodim> I like java
18:19:04 <araujo> java is one of the worse language out there
18:19:05 <sclv> @karma java
18:19:06 <lambdabot> java has a karma of -22
18:19:06 <ddarius> sclv: "learning-wise"?
18:19:09 <araujo> java--
18:19:23 <sk> but java makes u have this library envy
18:19:26 <ddarius> sclv: I heartily agree that people should know assembly.
18:19:41 <araujo> sk, there are languages with more libs
18:19:56 <araujo> C for instance
18:20:01 <wy> I've used Java for some time because of the course I took and TA
18:20:03 <ddarius> Valodim: Language-wise (and library-wise and seemingly IDE-wise) C# is much better.
18:20:04 <sclv> ddarius: I mean, having to program parts of toy OSes, device drivers, etc. Either you do it in assembly, or you do it in C. You can't do it in a language with GC and a VM, so what else is there except, uh, pascal?
18:20:24 <Valodim> never tried C#
18:20:29 <Valodim> trying to keep away from MS
18:20:34 <sclv> and a database is sort of like a mini-os anyway.
18:21:10 <ddarius> sclv: Huh, those things -have- all been done in languages with GCs and/or VMs.
18:21:19 <wy> Valodim: SPJ is working for MS...
18:21:27 <ddarius> As is Simon Marlow
18:21:37 <sclv> B-but what do you program the GC and VM in then?
18:22:38 <Valodim> the point is, when microsoft starts doing "campaigns for infecting etc"
18:22:50 <ddarius> sclv: Depends.  E.g. Smalltalk used Smalltalk and Squeak in particular had a cut down version it used whose name escapes me.  There's PreScheme.  For e.g. the current Haskell OSes, the runtime system of GHC was simply made standalone.
18:22:50 <Valodim> that would have somewhat more impact than sun's actions
18:22:53 * sclv ph34rs the day when Windows 2010 is all in C#
18:23:12 <ddarius> sclv: Singularity OS!
18:23:27 <sclv> ok fine, I know when I'm bested.
18:23:36 <Valodim> ph34r the H#
18:23:54 <Plareplane> http://jikesrvm.org/
18:23:55 <lambdabot> Title: Jikes RVM - Home
18:24:00 <sclv> haha is it wrong that I read C# as unsafeC ?
18:24:04 <ddarius> sclv: I don't know what KAOS did.
18:24:05 <Plareplane> A distinguishing characteristic of Jikes RVM is that it is implemented in the Javaâ¢ programming language and is self-hosted i.e., its Java code runs on itself without requiring a second virtual machine.
18:24:15 <ddarius> @src Char
18:24:15 <lambdabot> data Char = C# Char#
18:25:19 <octoberdan> I'm sick of articles on PT explaining themselves through a language I don't know... so it's time for me to learn haskel :-)
18:25:27 <sclv> bootstrapping confuses me :-(
18:25:32 <ddarius> PT?
18:25:40 <sclv> octoberdan: welcome to the party!
18:25:43 <octoberdan> Programming Theory
18:26:05 * ddarius didn't know programming had a theory.
18:27:29 <octoberdan> ddarius: Source is theory. Running the program is proof.
18:27:31 <sk> octoberdan: sorry, typo, mind to explain PT in more detail?
18:27:34 <octoberdan> ;-)
18:29:00 <octoberdan> As wikipedia tells us "the design, implementation, analysis, characterization, and classification of programming languages"
18:29:17 <ddarius> Usually that's called PLT, Programming Language Theory.
18:29:55 <octoberdan> I've heard it referred to as either, sorry about the mixup
18:30:13 <octoberdan> :-(
18:31:42 <ddarius> octoberdan: I understood what you meant, I'm just a pain in the rear.
18:31:47 <cpst> are any of the haskell OS attempts serious?
18:31:48 * sclv always thought the PLT in PLT Scheme stood for "Party Lambda Time!"
18:32:42 <dons> cpst: yes. but they're for commercial use, not open source linux competitors
18:32:51 <dons> also, serious as research projects
18:33:02 <cpst> what's the best?
18:33:10 <ddarius> cpst: There is not going to be a new desktop OS anytime in the near future at the very least.
18:33:42 <dons> they're research kernels
18:33:50 * octoberdan is putting his money on EmacsOS
18:34:19 <cpst> ddarius: why do you say that?
18:34:42 <Korollary> Because 2008 will be linux' year on the desktop!
18:34:49 <Korollary> argh
18:35:06 <octoberdan> cpst: Breaking into the market is almost impossible. It would come out of left field
18:35:09 <sclv> but the desktop will be replaced by the iPhone, you didn't hear?
18:35:12 <octoberdan> Which has happened...
18:35:22 <Korollary> sclv: No, the desktop will be replaced by google
18:35:24 * octoberdan vomits
18:35:34 <cpst> the desktop will be replaced with xmonad
18:35:39 <cpst> on a floppy disk
18:36:17 <cpst> dons: still doesn't answer the question of which ones are good ;-)
18:36:18 <sclv> I want a personal google device. all it knows how to do is google. it can't even browse the web -- just talk to google. it should be wearable on my wrist.
18:36:45 <sclv> cpst: if you want yr. mind expanded, look at ZipperFS
18:37:14 <cpst> sclv: yeah I've seen that, but it's not really an OS
18:37:21 <sclv> also, maybe, it can talk to twitter!
18:37:29 <octoberdan> cpst: Your question was "which one is best," which is practically a useless question
18:38:06 <cpst> okay, I'll be more specific, which have the best ideas or approaches to writing an OS in a functional language?
18:38:19 <octoberdan> Again with your "best"
18:38:45 <sclv> symbolics?
18:38:45 <octoberdan> cpst: Is there a metric?
18:38:58 <cpst> the personal opinion?
18:39:09 <cpst> since no one has mentioned any of them, that would be a start ;-)
18:39:50 <dons> house is the most widely known haskell os
18:39:53 <dons> and the best documented
18:40:04 <dons> there's also a good l4 kernel with papers published in the last couple of years
18:40:19 <dons> cpst: they're both documented well on the wiki.
18:40:26 * octoberdan realizes he's being a jerk and shuts up
18:40:59 <sclv> http://lambda-the-ultimate.org/node/299
18:41:01 <lambdabot> Title: House , hOp - the Haskell Operating System | Lambda the Ultimate
18:41:08 <dons> cpst: http://haskell.org/haskellwiki/Research_papers/Program_development#Operating_systems
18:41:09 <lambdabot> http://tinyurl.com/y4929f
18:41:46 <cpst> how much are they of the form "oh cool we got the language runtime to boot!"
18:41:55 <ddarius> cpst: None of the Haskell OSes take the approach I'd prefer.
18:42:18 <cpst> I am interested because I used to be involved in a pie-in-the-sky OS project
18:42:34 <cpst> and most of the ones I see have the same flaws
18:42:42 <dons> cpst: check the papers. they're about building high assurance systems, not so much about hacking ghc on funny archs
18:42:50 <cpst> Vapour, maybe even someone remembers it ;-)
18:44:19 <ddarius> cpst: I'm a big fan of the exokernel approach.
18:45:00 <cpst> ddarius: combined with the mythical "sufficiently smart compiler", that would work fairly well I think
18:46:30 <ddarius> cpst: Huh? It doesn't necessarily nor in current incarnations have anything to do with a compiler at all.  It certainly doesn't require a sufficiently smart one.
18:47:00 <cpst> ddarius: sure, I know that
18:47:13 <cpst> ddarius: I am saying it might work better with one ;-)
18:47:41 <ddarius> cpst: The systems that have been made already worked better than mainstream versions.
18:48:05 <cpst> ddarius: I remember the MIT benchmarks, but have they benchmarked against a more recent OS?
18:49:15 <cpst> the one OS idea that no one has tried to duplicate in any real way is Henry Massalin's Synthesis
18:49:35 <cpst> runtime code generation to speed up the kernel!
18:49:39 <ddarius> cpst: Aegis or Xok?
18:49:56 <ddarius> cpst: That's related to much of the exokernel work.
18:50:28 <cpst> yeah, but it's a better hack
18:50:48 <cpst> writing runtime codegen in assembly for an OS kernel is a pretty manly programming task
18:50:51 <ddarius> cpst: Dawson Engler, who wrote his PhD on Xok, also worked on TickC and the (actually used) dynamic package filter compilers.
18:51:00 <cpst> nevermind for a computer you built yourself
18:51:17 <ddarius> Synthesis was cool, but I'd prefer something much less ad-hoc than what they had.
18:52:55 <ddarius> Everything Dawson Engler has done and is doing is cool: http://www.stanford.edu/~engler/
18:52:56 <lambdabot> Title: Dawson Engler
18:53:29 <cpst> yeah, I like the filesystem model checking paper
18:53:58 <cpst> dislike the Coverity work
18:54:24 <ddarius> Hmm, Cristian Cadar, that's almost as bad as Bjorn Lisper.
18:55:35 <cpst> although I have to give Coverity credit, it is surprising that such a completely unsound program analysis is useful
18:55:46 <cpst> it's just annoying when you have to pass it to get Coverity certified for some markets
18:57:26 <ddarius> cpst: I imagine that that unsound analysis ends up working vaguely the same way a human reviewing the code would.
19:06:49 <cpst> ddarius: it's also incomplete
19:07:08 <cpst> ddarius: so you get both of the bad aspects of humans reviewing code
19:16:20 <ddarius> cpst: Indeed, but humans nevertheless find many bugs this way.  The benefit is that it is cheap and simple (which is why humans do it)
19:48:05 <xpik1> how do you write fizzbuzz the shortest in haskell?
19:52:27 <TSC> xpik1: Have you seen this?  http://programming.reddit.com/info/10d7w/comments/c10gz2
19:52:42 <dons> there's 20-char long versions, iirc
19:52:54 <sjanssen> xpik1: http://programming.reddit.com/info/10d7w/comments/c10g19 my favorite version
19:53:05 <dons> we should collect these on the wiki
20:08:28 <dmwit> I would add my point-free version, but it pales in comparison to those.
20:20:21 <ddarius> No APL or J?
20:25:55 <gwern> shachaf: nothing, really. it's just my personal preference to specify the search engine through the keybinding
20:26:05 <gwern> bleh. mischan
20:29:15 <davidL> > let fizz x = concatMap (++ "zz") $ ["fi" | x mod 3==0] ++ ["bu" | x mod 5 ==0] in map fizz [1..100]
20:29:17 <lambdabot>        add an instance declaration for (Num ((a -> a -> a) -> t -> a1))
20:29:17 <lambdabot>     I...
20:31:28 <davidL> > let fizz x = concatMap (++ "zz") $ ["fi" | x `mod` 3==0] ++ ["bu" | x `mod` 5 ==0] in map fizz [1..100]
20:31:28 <lambdabot>  ["","","fizz","","buzz","fizz","","","fizz","buzz","","fizz","","","fizzbuzz...
20:31:41 <davidL> cool
20:32:36 <shachaf> davidL: You have to show the number if it's not divisible by either. :-)
20:33:33 <davidL> > null ""
20:33:36 <lambdabot>  True
21:01:43 <orbitz> what would be the most efficient pure functional data structure for a buffer taht will generally be growing?  Using a list then reversing it when I finally need it?
21:02:33 <dibblego> foldr on the list producer?
21:03:20 <shachaf> Maybe a DList?
21:03:28 <orbitz> what's a DList?
21:03:34 <dibblego> @where DList
21:03:35 <lambdabot> http://www.cse.unsw.edu.au/~dons/dlist.html
21:04:19 <shachaf> Or perhaps Data.Sequence?
21:04:25 * shachaf hasn't used it. :-(
21:04:35 <bos> @seen dons
21:04:36 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 54m 4s ago.
21:04:59 <moconnor> What's a snoc operation?
21:05:02 <orbitz> thanks
21:05:12 <shachaf> > reverse "cons"
21:05:14 <lambdabot>  "snoc"
21:05:15 <moconnor> oh
21:05:18 <moconnor> heh
21:05:24 <shivernz> lol
21:06:59 <bench> so I upgraded to 6.8.2 of ghc, but packages installed with ghc are not registered anymore
21:07:09 <bench> what's the best way to reregister them?
21:09:28 <wy> What's the hotkey for inserting the type signatures in haskell-mode?
21:09:49 <shachaf> dons: Why does DList.hs only make an Applicative instance #if __GLASGOW_HASKELL__ >= 608, but always imports Control.Applicative?
21:09:50 <bos> C-u C-c C-t
21:10:30 <dibblego> wy, for emacs?
21:10:44 <wy> dibblego: yes
21:10:52 <sjanssen> shachaf: that's actually wrong on several points
21:11:07 * sjanssen finds the repo to send dons a patch
21:11:12 <shachaf> sjanssen: What is?
21:11:20 <wy> bos: haha! thanks!
21:11:26 <sjanssen> shachaf: Applicative came with GHC 6.6 too
21:11:47 <sjanssen> and you shouldn't use __GLASGOW_HASKELL__ at all, because some Hugs versions have Applicative too
21:12:05 <shachaf> http://code.haskell.org/~dons/code/dlist
21:12:06 <lambdabot> Title: Index of /~dons/code/dlist
21:12:14 <shachaf> Oh, DList.hs, not what I said. :-)
21:18:39 <wy> Is there a way to map putStr ?
21:19:30 <TSC> map putStr
21:19:47 <TSC> ... but maybe you want mapM_ putStr, or sequence . map putStr
21:22:53 <kscaldef> the problem with movie audio commentary tracks is that they spend way too much time just blathering on about nothing
21:25:32 <mdmkolbe|work> does this function already exist? http://hpaste.org/4627
21:26:26 <sjanssen> mdmkolbe|work: no, but it has been discussed on the libraries list
21:26:43 <dibblego> ?djinn [Either a b] -> ([a], [b])
21:26:43 <lambdabot> -- f cannot be realized.
21:26:47 <mdmkolbe|work> sjanssen: is there a standard name?
21:26:58 <mdmkolbe|work> dibblego: djinn doesn't understand lists :-(
21:27:02 <sjanssen> mdmkolbe|work: I can't remember what they came up with
21:27:24 <sjanssen> ?djinn Either a b -> (Maybe a, Maybe b)
21:27:25 <lambdabot> f a =
21:27:25 <lambdabot>     case a of
21:27:25 <lambdabot>     Left b -> (Just b, Nothing)
21:27:25 <lambdabot>     Right c -> (Nothing, Just c)
21:28:02 <wy> TSC: Thanks. sequence works
21:30:36 <mdmkolbe|work> sjanssen: any dates or other keywords that I can use to look through the list archives?
21:30:51 <moconnor> what does djinn do?
21:31:59 <mdmkolbe|work> moconnor: it takes a type and constructs a program with that type.  (or did you mean how does it do it?)
21:32:04 <mdmkolbe|work> @djinn a -> a
21:32:04 <lambdabot> f a = a
21:32:19 <mdmkolbe|work> @type f a = a
21:32:20 <lambdabot> parse error on input `='
21:32:24 <moconnor> mdmkolbe|work: Thanks, that answers my question.  Now I'm curious how it does it, yeah.
21:32:49 <moconnor> mdmkolbe|work: I mean, why not just f _ = (Nothing, Nothing) as a valid answer for the above case
21:33:10 <dibblego> ?type foldr (\e (a, b) -> case e of Left a' -> (a':a, b); Right b' -> (a, b':b)) ([], [])
21:33:11 <lambdabot> forall t t1. [Either t t1] -> ([t], [t1])
21:33:46 <mdmkolbe|work> moconnor: I think it's based on a proof system and using the curry-however isomorphism (do you know what that is?).  I'm not sure about how it enforces whether arguments are used.
21:34:52 <moconnor> I've read about the curry-howard isomorphism.  But I bet this conversation will quickly outstrip my understandings.  I was just mildly curious.
21:34:54 <dibblego> ?type let (+++) = mplus . return in Data.Foldable.foldr (\e (a, b) -> case e of Left a' -> (a'+++a, b); Right b' -> (a, b'+++b)) (mzero, mzero)
21:34:55 <lambdabot> forall (m :: * -> *) t t1 (t2 :: * -> *). (MonadPlus m, Data.Foldable.Foldable t2) => t2 (Either t t1) -> (m t, m t1)
21:35:15 <dibblego> ?hoogle (MonadPlus m) => a -> m a -> m a
21:35:16 <lambdabot> Prelude.const :: a -> b -> a
21:35:16 <lambdabot> Prelude.asTypeOf :: a -> a -> a
21:35:16 <lambdabot> Prelude.seq :: a -> b -> b
21:36:23 <stepcut> moconnor: start here, http://lambda-the-ultimate.org/node/1178
21:36:24 <lambdabot> Title: Djinn, a theorem prover in Haskell, for Haskell. | Lambda the Ultimate
21:36:36 <stepcut> moconnor: and then use google as needed :)
21:40:11 <mdmkolbe|work> moconnor: 30 second summary.  take the type (e.g. a -> (a -> b) -> b); read it as a propositional logic term (e.g. a implies (a implies b) implies b); construct a proof for that term and convert that proof back into lambda calculus
21:40:35 <mdmkolbe|work> sjanssen: thx, I've found the references in the libraries list
21:42:37 <mdmkolbe|work> @info foldMap
21:42:38 <lambdabot> foldMap
21:42:45 <mdmkolbe|work> @doc foldMap
21:42:46 <lambdabot> foldMap not available
21:42:49 <mdmkolbe|work> @index foldMap
21:42:50 <lambdabot> bzzt
21:42:54 <mdmkolbe|work> @type foldMap
21:42:56 <lambdabot> Not in scope: `foldMap'
21:43:02 <ddarius> moconnor: djinn can return multiple results, lambdabot just doesn't display all of them
21:53:26 <wy> let me test if this is a bug of haskell-mode. Try doing some undos in the Inf-Haskell buffer, then use C-c C-l to reload your file in the haskell buffer
21:56:04 <TSC> wy: I've noticed that if the prompt is not the plain "Main>" (or whatever), sometimes it gets confused
21:56:53 <TSC> For example, if you delete the space after the ">" (by pressing backspace) and then try to load, it doesn't like it
21:57:49 <wy> What do you do in this situation?
21:59:27 <TSC> Press C-g to cancel the load, then go into the inf-haskell buffer and press enter to fix the prompt
22:09:28 <jsnx> :q
22:09:32 <jsnx> haha
22:32:39 <wy> Is there a way to get partially inferred types from ghci? If something goes wrong, I can't get any type information.
22:35:19 <sk> you mean as you couldn't even load a file ?
22:36:01 <wy> Right. There are type errors.
22:36:41 <wy> But in order to correct it, sometimes I need to know the type of the things
22:37:40 <notsmack> wy: doesn't it tell you the inferred type?
22:37:51 <sk> i understand
22:38:57 <sk> notsmack: he probably means some other functions or types, not the part that pops up error.
22:39:04 <wy> notsmack: It only tells me type of the thing that goes wrong, but no type information of other things
22:39:14 <wy> right
22:39:42 <wy> Is there a way to tell it to go as far as it could?
22:40:26 <sk> are you working on your own program or some large program written by others?
22:41:17 <wy> My own
22:41:37 <notsmack> you can check the type of any expression in ghci with ":t"
22:42:22 <sk> i am actually still quite new to the language, but if i were you i would explicitly write down all the types for all functions and let the interpreter catch the type errors.
22:42:55 <sk> no so much of type inference that is =/
22:43:01 <sk> not*
22:43:07 <notsmack> good point, explicit type declarations won't let type inference wander far enough to get confusing
22:44:06 <wy> But then what's the use of type inference?
22:44:24 <shachaf> wy: You can alwayss comment out the problematic piece of code.
22:44:45 <shachaf> wy: However, you probably should write at least top-level type declarations.
22:45:50 <wy> I guess the toplevel declaration is written for other people
22:46:06 <wy> So it's better to insert them automatically
22:46:18 <sjanssen> sometimes
22:46:39 <sjanssen> though, as others have noted, explicit type declarations help the type inferencer enormously
22:47:21 <notsmack> wy: type inference is handy in a lot of cases, but can make things tricky if you're not very good with the type system yet
22:50:39 * bos struggles for a compelling, yet simple example of using the list monad for the book.
22:51:34 <bos> it's easy to appeal to it as a funny notation for nested loops, but i'll be damned if i'm going to present a sudoku solver or similar.
22:52:19 <dmwit> How about NFAs?
22:52:27 <dibblego> replacing SGML characters with an escape sequence
22:52:42 <dmwit> It's so straightforward to turn a DFA into an NFA by just sticking it into the list monad that it's not even funny.
22:53:35 <bos> dmwit: i don't have very much space for this example, and i wouldn't otherwise be talking about finite automata at all.
22:53:51 <dmwit> hm
22:54:21 <bos> dibblego: not a bad idea, hmm.
22:54:40 <dibblego> bos, I'm just recalling an example I used for someone who had (and still doesn't have) any idea what a monad is
22:54:46 <bos> heh
22:54:53 <dibblego> bos, Scala has a flatMap function on various types; List, Option/Maybe, etc.
22:55:28 <bos> dibblego: yeah, haskell has concatMap for that
22:55:58 <dibblego> yeah, Scala calls all of them flatMap (not just list)
22:56:06 <dmwit> Well, really it's closer to msum or so.
22:56:25 <dibblego> xs.flatMap(f) where xs is a List[A] and f is a function: A => List[B] for example
22:56:37 <dibblego> we just got done writing a web application in Scala
22:58:05 <bos> dibblego: on further thought, sgml quoting isn't very compelling, i think.  it's just a single concatMap.
22:58:21 <dibblego> bos, indeed; he was and still is a beginner :)
22:58:39 <bos> sod it, i'll just put a remark "help! need example!" and move on :-)
22:59:12 <dmwit> Well, you can use it for (depth/breadth)-first search.
22:59:21 <dmwit> I'm too tired to figure out which one it is just now.
22:59:54 <sk> dibblego: how long has your friend been learning haskell?
23:00:08 <dibblego> sk, hasn't touched it yet; he's too scared
23:00:55 <sk> dibblego: i thought you were showing him examples for monads, heh
23:01:07 <dibblego> sk, he has some very undisciplined ways of thinking that I had to battle with (it was just him and I on the project); which I blame on Ruby, so I've suggested he learn Hasskell to *force* him to think more disciplined
23:01:22 <dibblego> sk, I do and I use Haskell syntax; but he doesn't know that's what it is :)
23:01:45 <dibblego> sk, we have posters hanging up around the office that are written in Haskell, but he thinks it's just shortened Scala to fit on the paper ;)
23:02:01 <jaredj> scalad down
23:02:06 <jaredj> ogh
23:02:46 <dibblego> we use the Monad abstraction, but he makes me apply the type argument first in a redundant function
23:04:01 <sk> so ruby actually makes you think in an undisciplined way, or perhaps it's more like haskell forces you to think in a discriplined way
23:04:37 <dibblego> sk, he produces some abominations "because RoR does it that way" and doesn't bother thinking about using the type system
23:04:41 <sk> i can't speak of scala i havent looked at that yet
23:05:00 <dibblego> it's statically-typed
23:05:23 <bos> ruby doesn't make you think in a sloppy way, it just doesn't penalise you for doing so.
23:05:26 <sk> RoR is a DSL in which you do things in it's very own way, u can't apply the RoR way everywhere
23:05:38 <dibblego> there's also repetition because of the lack of recognition of function composition
23:05:43 <bos> haskell, by contrast, beats you with a stick.
23:05:47 <dibblego> bos, yes I think that's more accurate
23:07:16 <sk> hope you have your luck getting your friend to get his hands on haskell
23:08:00 <dibblego> sk, I know now to start people off on Haskell, rather than Scala or other less disciplined languages
23:08:16 <dibblego> I think he is scared of Haskell
23:08:52 <dmwit> Start with the thumbscrew, then the bed of nails doesn't seem so bad. ;-)
23:09:19 <dibblego> it's just difficult dealing with it when you're on a commercial project
23:10:07 <dibblego> in week 1, my use of flatMap was far less readable than spreading it over 20 or so lines of code
23:11:03 <sk> in the end was it a painful project?
23:11:37 <dibblego> lots of arguments and I have to fix all the code up if I am ever to maintain it and nobody is going to understand why, so I'll have to do it on my own time
23:11:47 <dibblego> but there were lots of good parts as well
23:12:37 <sk> the biggest part would be: hey, we've finished the project!
23:13:00 <dibblego> except the code is so inconsistent as learning progressed
23:15:33 <sk> i just googled for scala, the syntax looks a little like ruby/python
23:16:04 <dibblego> it's a little more verbose I think
23:17:07 <glguy> I found a Ruby bumper sticker on Amazon.com http://www.amazon.com/Completely-Appalled-Havent-Attention-Sticker/dp/B0002U6PTS
23:17:09 <lambdabot> http://tinyurl.com/2vhveu
23:18:05 <jaredj> wait, what?
23:18:20 <jaredj> heh
23:23:40 <jaredj> bargh. getpass(3) - get a password. "This function is obsolete. Do not use it." No clues what to use instead.
23:26:26 <jh__> pam_get_item() a PAM_AUTHTOK perhaps
23:27:56 <jaredj> it's not going to pam - it's going to NSS. i just want to not echo things, getpass looks like it does exactly what i need, but it Shouldn't Be Used.
23:28:41 <jaredj> and i'm putting it in darcs, so portability will matter
23:29:37 <jaredj> i could punt and use it, leaving it to be solved later
23:30:05 <jaredj> (right now the password is coming out of an env var. that's highly unsustainable, heh)
23:30:09 <jh__> odd that the manpage doesnt suggest the replacement
23:30:20 <jh__> ive seen a fair bit of 'use real_getpass or posix_getpass' type things
23:30:45 <jaredj> usually they're more helpful :/ i googled it and found a glibc documentation page that doesn't say not to use it, but does contain a replacement
23:30:52 <jaredj> ah
23:31:18 <ddarius> Wow.  The Screamer examples are stolen from SICP.
23:31:21 <jaredj> :d  http://www.gnu.org/software/libc/manual/html_node/getpass.html
23:31:22 <lambdabot> Title: getpass - The GNU C Library
23:35:25 <jaredj> http://cygwin.com/ml/cygwin/2003-05/msg01537.html
23:35:26 <lambdabot> Title: Carlo Florendo - Re: is getpass function in cygwin obsolete?
23:35:30 <ddarius> bos: Some kind of scheduling problem perhaps?
23:45:43 <ddarius> bos: One example that may be workable is placing tabbing out music for an instrument (i.e. guitar).
