00:02:48 <jsnx> i should work, really, i've spent far too much time on IRC
00:02:51 <jsnx> oops
00:33:10 <bos> @hoogle userError
00:33:10 <lambdabot> Prelude.userError :: String -> IOError
00:33:10 <lambdabot> System.IO.Error.userError :: String -> IOError
00:33:11 <lambdabot> Control.Exception.userErrors :: Exception -> Maybe String
00:47:20 <skew> gtk is annoying me - it seems resize events carry an outdated size
00:49:56 <skew> so even carefully calculating text extents and pretty-printing my document to fit, a scrollbar still blinks on and off if I resize the window quickly
00:50:12 <skew> probably nothing to do with gtk2hs
00:53:01 <nostradamos> helo iam searching for a job can any one help me ?
00:54:52 <nostradamos> any one
01:55:35 <mravibsp> hi
01:59:11 <gvdm> I'm busy doing the 99 problems and I'm getting frustrated, because I can solve the problems, every time and it doesn't take me that long, but it generally involves making a sub function with extra parameters with intial starts, kinda a recursive loop, and then I look at the solution AND IT'S A FRIGGING LINE
02:00:36 <TSC> With some practice you figure out how to abstract away the recursive loopy-function
02:01:00 <TSC> With map, folds, unfold, etc.
02:03:45 <gvdm> yes! I beat solutions
02:03:53 <gvdm> problem 19
02:04:09 <gvdm> concatMap was cool
02:04:30 <gvdm> I'm putting the better versions next to my code
02:05:04 <shag> 99 problems?
02:05:49 <hpaste>  gvdm pasted "progress on 99 problems" at http://hpaste.org/4668
02:06:12 <gvdm> http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems
02:06:13 <lambdabot> Title: H-99: Ninety-Nine Haskell Problems - HaskellWiki, http://tinyurl.com/2wg98q
02:06:18 <shag> gvdm: ah, thanks
02:06:38 <gvdm> the hpaste is so people can see how crappy a functional programmer I am
02:07:46 <leaves_> hey, I have a function and I want it to be able to "return" a list of arbitrary length of elements of the type Num, how would I do that?
02:08:06 <leaves_> I tried:  f :: something -> List Num
02:08:21 <shag> foo :: Num a => [a]
02:08:50 <shag> or, including something: foo :: Num a => some -> thing -> [a]
02:09:45 <leaves_> aah this works, thank you
02:10:14 <leaves_> I know have getPosition :: Num b => a -> [b]
02:23:10 <quicksilver> nice. Haskell Qt bindings.
02:25:56 <earthy> yeah. me like
03:00:18 <dcoutts_> bos: pong
03:02:58 <dcoutts_> alexj: there's documentation on the .cabal syntax in the cabal user guide
03:03:14 <dcoutts_> alexj: if you want to parse it, just use the parser in the Cabal lib
03:03:59 <dcoutts_> since if you want to do anything interesting with it, it's not just parsing that you have to worry about, you also have to resolve conditionals etc
03:04:38 <dcoutts_> alexj: you're absolutely right about the utf8 & repo thing, those are on the todo list, but we have a very very long todo list
03:05:32 <leaves_> hi, do you know why this doesn't work? type MassObject = Num a => (a, [a])
03:05:50 <quicksilver> (a) type synonyms can't have contexts
03:05:57 <quicksilver> (b) type synonyms can't have unbound variables
03:07:35 <leaves_> but this works type MassObject = (Int, [Int])
03:07:54 <leaves_> And I want it to be independent of Int, it could be any number, do you know how to do that?
03:08:12 <dcoutts_> alexj: do please write with your concerns to the cabal-devel list, and make sure any issues you raise are well described in bug reports in the cabal/hackage trac
03:08:46 <dcoutts_> alexj: eg your feature request to provide searchpath maps for packaes on hackagedb
03:08:59 <quicksilver> leaves_: type MassObject a = (a,[a])
03:09:16 <quicksilver> leaves_: although, I would think it's preferred to do
03:09:24 <quicksilver> data MassObject a = MassObject a [a]
03:10:10 <leaves_> Ok, but how does haskell know a must support + - * etc?
03:11:02 <quicksilver> it doesn't
03:11:09 <quicksilver> but you show that with a type signature like
03:11:13 <quicksilver> (Num a) => MassObject a
03:11:40 <leaves_> okay, that's clear, thank you
03:11:52 <leaves_> I btw don't know yet how data works
03:12:56 <quicksilver> it defines a new data type
03:13:05 <quicksilver> this is generally preferred to making a type synonym
03:13:08 <quicksilver> which is what 'type' does
03:13:52 <leaves_> but when I did this with data, how would I create a new variable of that datatype?
03:14:34 <leaves_> with type I know it is a tuple
03:15:33 <quicksilver> well I used MassObject as the constructor name
03:15:39 <quicksilver> so it would be like this:
03:15:44 <quicksilver> MassObject 5 [6,7,8]
03:15:57 <quicksilver> (which would correspond to (5,[6,7,8]) with your type)
03:16:12 <quicksilver> data MassObject a = MkMassObject a [a]
03:16:15 <quicksilver> makes it more explicitly
03:16:19 <quicksilver> MassObject is the type name
03:16:25 <quicksilver> and MkMassObject is the constructor name
03:16:31 <quicksilver> but you are allowed to have them as the same name
03:16:31 <leaves_> okay, and how would I extract say the first element from this data?
03:16:35 <quicksilver> and that's quite a common convention.
03:17:05 <quicksilver> let MkMassObject n _ = foo in "first component was " ++ show n
03:17:13 <quicksilver> pattern matching
03:17:24 <quicksilver> although if you do that frequently ou could define a function for it
03:19:29 <leaves_> okay
03:20:32 <wolverian> define a function = use records
03:27:24 <shag> why can't haddock/cabal/hscolour generate a default hscolour.css file? is everyone now including that file in the distribution to be able to generate colourised source output with haddock/cabal?
03:33:48 <leaves_> do you know how to element wise substract two lists?
03:34:47 <xerox> :t zipWith (-)
03:34:50 <lambdabot> forall a. (Num a) => [a] -> [a] -> [a]
03:36:28 <leaves_> thank you, that's a nice solution, I had though about using zip first and then map with fst and snd :)
03:37:15 <xerox> np :)
03:38:27 <quicksilver> shag: there is a default css file, but I forget where it lives
03:38:49 <shag> quicksilver: included in the hscolour package?
03:40:51 <shag> hscolour has an option to output the default .css file, but i cannot pass this option through cabal and haddock to hscolour ...
03:40:59 <Liskni_si> @pl (\f a b -> map (uncurry f) (zip a b))
03:40:59 <lambdabot> (. zip) . (.) . map . uncurry
03:42:52 <Heffalump> @type (\f a b -> map (uncurry f) (zip a b))
03:42:54 <lambdabot> forall c a b. (a -> b -> c) -> [a] -> [b] -> [c]
03:48:48 <quicksilver> Liskni_si: looks like zipWith to me
03:48:58 <Liskni_si> quicksilver: yeah.
03:49:26 <Liskni_si> i was just looking how long it is :)
03:49:40 <quicksilver> ;)
03:52:18 <dcoutts_> shag: it's fixed in hscolour 1.9 and the latest cabal supports it too
03:52:40 <shag> ah ok. thanks
03:52:52 <dcoutts_> shag: it's because older versions of hscolour had no way to find the default .css file, so cabal could not do anything useful
03:53:21 <dcoutts_> shag: we pestered malcolmw until that got improved :-)
03:53:26 <shag> hehe
03:53:54 <dcoutts_> (not that the default css is very exciting, improvements welcome)
03:55:00 <quicksilver> especially involving <BLINK> and <MARQUEE>
03:55:29 <shag> dcoutts: but much more exciting than just plain black on white sourcecode ...
03:55:47 <dcoutts_> shag: certainly
03:56:02 <dcoutts_> quicksilver: heh
04:27:33 <quicksilver> hmm
04:27:41 <quicksilver> interesting point by mr baboi
04:27:48 <quicksilver> "In Pascall, Files have Types"
04:27:53 <quicksilver> shame I can't spell
04:27:55 <quicksilver> but the point is there
04:28:29 <roconnor> ?
04:29:42 <quicksilver> Seems like a file library based on giving files types might be interesting.
04:29:48 <quicksilver> well, it seemed interesting to me.
04:30:10 <audreyt> newtype MyFileType = MkMyFileType Handle
04:31:43 <roconnor> quicksilver: did I miss a reference?
04:31:57 <roconnor> Is Pascall not Pascal?
04:32:58 <roconnor> Somewhere on my desk I have a file system for Clean where files have types, and executables are function types.
04:33:05 <roconnor> er
04:33:21 <roconnor> somewhere on my desk I have a thesis that has a files system ...
04:33:45 * quicksilver nods
04:33:52 <quicksilver> audreyt: that's not quite the point :)
04:34:01 <audreyt> no it's not :)
04:34:02 <quicksilver> audreyt: the idea would be to have a type which represents the contents
04:34:11 <quicksilver> roconnor: yes, I did mean pascal.
04:34:32 <audreyt> the point would be something like "class File a where ..." and then newtype-derive things?
04:36:21 <roconnor> Files had types in Pascal?
04:36:41 <roconnor> ... It's been a long time since I've used Pascal.
04:36:54 <quicksilver> roconnor: me too, but it rings a faint bell
04:37:31 <roconnor> Ah pascal.  The good ol' days when arrays were arrays instead of being pointers.
04:42:29 <vincenz> roconnor: you mean the good old days when arrays were abstract enough :
04:42:29 <vincenz> :)
04:42:54 <roconnor> passing C arrays as parameters confused the heck out of me.
05:03:06 <zx]treads> any1 knows in what state currently is happs?
05:06:54 <ricky_clarkson> Illinois?
05:11:17 <zx]treads> :D
05:52:50 <EvilTerran> @b52s
05:52:50 <lambdabot> She drove a Plymouth Satellite faster than the speed of light!
06:40:08 <njbartlett> @seen dcoutts
06:40:08 <lambdabot> dcoutts is in #gentoo-haskell, #haskell, #ghc and #haskell-overflow. I don't know when dcoutts last spoke.
06:40:15 <njbartlett> @seen dcoutts_
06:40:15 <lambdabot> dcoutts_ is in #ghc, #gentoo-haskell and #haskell. I last heard dcoutts_ speak 2h 3m 21s ago.
06:42:00 <Eelis> is it a well known problem that parsec's manyTill is extremely memory inefficient?
06:42:04 <Eelis> for example, evaluating the following expression consumes 20 megabytes of memory on my system:  parse (manyTill anyChar (char 'b')) "" $ replicate (100 * 1024) 'a'
06:45:50 <EvilTerran> probably a strictness thing
06:46:30 <Eelis> i think it might have something to do with manyTill not being tail recursive or something
06:48:54 <quicksilver> Eelis: compiled or interpreted?
06:49:00 <Eelis> compiled, with -O
06:49:04 <Eelis> ghc 6.8.2
06:49:06 <quicksilver> try with -O2 ?
06:49:35 <Eelis> same thing.
06:49:40 <quicksilver> interesting.
06:49:46 <quicksilver> I find that a bit surprising :)
06:50:17 <Eelis> i'm measuring by running the executable with  +RTS -tstderr  and looking at the "21M in use" part.
06:50:38 <quicksilver> > 100 * 1024 * 24
06:50:42 <lambdabot>  2457600
06:50:48 * quicksilver nods
06:56:03 <ricosecada> Hi. I am taking a look at haskell for the first time, and I have some problems locating a good tutorial using compiled examples rather than just interpreted onces. Anyone who can recommend a good book or tutorial, than DOESN'T use the console intrepreter all the time?
06:56:31 <Eelis> quicksilver: should i bring the issue up with the parsec folks?
06:57:25 <oal``> ricosecada, what's the difference? just paste the examples into a file and compile it
06:58:10 <oal``> the thing you probably are searching for is > main = do print $ yourFunctionGoesHere
06:59:48 <quicksilver> Eelis: yes, I think so.
07:00:03 <Eelis> quicksilver: alright.
07:00:15 <quicksilver> oal``: strangely pointless use of "do" :)
07:00:36 <oal``> meh
07:01:26 <oal``> quicksilver, it's abbriged form of my usual main = do let foo = bar (* ... *) print $ someThing foo baz biz
07:02:04 <quicksilver> oal``: why not main = let foo = bar in print $ someThing foo baz biz ?
07:02:23 <oal``> but yes, in this case it's really pointless. In sence: it has no point ;)
07:02:30 <oal``> meh. let me try it
07:02:39 <oal``> I always used do mindlessly
07:02:51 <gbacon> > do print 3
07:02:53 <lambdabot>  <IO ()>
07:02:58 <gbacon> @botsnack
07:02:58 <lambdabot> :)
07:03:46 <oal``> ok, I know now
07:04:08 <quicksilver> ;)
07:04:16 <quicksilver> do with one statement inside is always superfluous
07:04:23 <quicksilver> the point of do is to combine multiple statements
07:04:41 <oal``> quicksilver, my most typical use of main includes reading something from stdin.
07:04:50 <oal``> so I *need* the precedence in there
07:05:04 <oal``> that's what the do monad does, right?
07:05:11 <osfameron> maybe do with one statement signals intent better?
07:05:23 <quicksilver> "do" is never more than syntactic sugar, oal``
07:05:34 <quicksilver> I'm not entirely sure what point you're mkaing with stdin
07:05:48 <quicksilver> but certainly, many people find do notation easier to read than >>=
07:06:14 <quicksilver> so, for example, people write do { l <- getLine ; putStrLn l } in preference to getLine >>= putStrLn
07:06:37 <oal``> Oh, we rapidly descend in the IO, monads and other horrible stuff ;)
07:06:41 <oal``> errm
07:06:52 <quicksilver> personally I only use do notation if there are at least a copule of different variables and normally3+ statements
07:06:57 <quicksilver> otherwise I use the combinators directly
07:07:02 <quicksilver> but it is a matter of taste, no more
07:07:08 <oal``> yes, that's also my typical usage of do in main
07:07:23 <oal``> I also typically have some let's inbetween
07:08:05 <oal``> something like do {*read n*; *make correct foo, bar, biz*; print $ f foo bar biz}
07:08:21 <oal``> mostly with time measerment for f
07:08:28 * quicksilver nods
07:08:40 <quicksilver> fair enough :)
07:09:24 <oal``> so whem I was giving an example of main, I simply stripped all that from do, but forgot the do itself ;)
07:09:29 <quicksilver> ;)
07:10:30 <oal``> by the way, which direction I should look for nice examples of using HaXml?
07:11:11 <oal``> All I want is to get some values from XML encoded data, do my stuff and put the result back in XML
07:11:15 * oal`` shudders
07:11:31 <quicksilver> can't help you there, I"m afraid.
07:11:32 <oal``> currently I have everything, but not the XML part
07:11:47 <oal``> oh, it's ok
07:12:05 <oal``> I still have the source and the examples from the library itself
07:12:21 <oal``> but I am also searching for an easy way ;)
07:14:50 <therp> oal: str <- readFile "foo.xml"; case (xmlParse "foo.xml" str) of (Document _ ...)
07:15:22 <hpaste>  therp pasted "parsing google geocoder with HaXML" at http://hpaste.org/4670
07:15:39 <oal``> therp, okay, I'll take a look
07:15:48 <therp> I'm not sure about the output though
07:16:19 <oal``> basicly I have <foo>bar</foo> in my XML file and I want to get "bar" if I know that's enclosed in "foo" tags
07:16:54 <oal``> ah, I see, I see
07:17:05 <oal``> disregard the foo bar question
07:18:10 <Eelis> xerox: ping.
07:26:55 <gbacon> http://internetisseriousbusiness.com/
07:26:56 <lambdabot> Title: blah blah
07:26:58 <gbacon> don't go there
07:27:00 <gbacon> wow
07:28:19 <bringert> dons: is anyone working on hs-plugins for GHC 6.8?
07:29:40 <quicksilver> bringert: cale already made it work, I thought?
07:29:50 <quicksilver> bringert: he ported it to the 6.8.x GHC-API
07:29:58 <bringert> oh
07:30:20 <bringert> nice
07:31:19 <bringert> quicksilver: where is it?
07:33:43 <quicksilver> bringert: not sure :)
07:37:42 <quicksilver> win 25
07:40:35 <sw17ch> @src readInt
07:40:35 <lambdabot> Source not found. Sorry.
07:41:07 <byorgey> > read "23" :: Int
07:41:09 <lambdabot>  23
07:42:06 <byorgey> sw17ch: is that what you're looking for?
07:45:40 <sw17ch> byorgey: no, I'm looking for the one that goes like this "readInt base cToBool cToInt stringRep"
07:45:46 <sw17ch> in the Numeric module
07:46:15 <byorgey> ah
07:46:21 <byorgey> @hoogle readInt
07:46:22 <lambdabot> Numeric.readInt :: Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
07:46:22 <lambdabot> Data.ByteString.Char8.readInt :: ByteString -> Maybe (Int, ByteString)
07:46:22 <lambdabot> Data.ByteString.Lazy.Char8.readInt :: ByteString -> Maybe (Int, ByteString)
07:46:56 <sw17ch> it's a pretty cool function :) and i have it working, i just want to figure out what the first (Char -> Bool) function is for
07:47:24 <EvilTerran> "is this character a digit?"
07:47:30 <byorgey> 'a predicate distinguishing valid digits in this base'
07:47:36 <sw17ch> mmm...
07:47:40 <byorgey> http://haskell.org/ghc/docs/latest/html/libraries/base/src/Numeric.html#readInt
07:47:41 <lambdabot> http://tinyurl.com/ytn38t
07:47:48 <sw17ch> so, does an invalid character terminate the interpretation then?
07:47:55 <sw17ch> (i suppose I could check)
07:48:04 <byorgey> sw17ch: I dunno.  I just found that using hoogle =)
07:48:14 <byorgey> I linked to the source above.
07:48:34 <EvilTerran> it's worth noting the existence of readDec, readOct, and readHex, too
07:48:52 <sw17ch> EvilTerran: yes, but it's not what i need
07:49:13 <sw17ch> I'm working on parsing common lisp's integer representations
07:49:16 <byorgey> > :t readInt 10 (`elem` "0123456789") Char.intToDigit
07:49:17 <lambdabot>   parse error on input `:'
07:49:18 <sw17ch> this is for the radix notation
07:49:19 <byorgey> :t readInt 10 (`elem` "0123456789") Char.intToDigit
07:49:21 <lambdabot>     Couldn't match expected type `Char' against inferred type `Int'
07:49:21 <lambdabot>       Expected type: Char -> Int
07:49:21 <lambdabot>       Inferred type: Int -> Char
07:49:24 * EvilTerran notes that readHex:showHex :: readDec:showInt :: readInt:showIntAtBase
07:49:31 <byorgey> :t readInt 10 (`elem` "0123456789") Char.digitToInt
07:49:32 <lambdabot> forall t. (Num t) => String -> [(t, String)]
07:49:46 <byorgey> :t readInt 10 (`elem` "0123456789") Char.digitToInt "143"
07:49:47 <lambdabot> forall t. (Num t) => [(t, String)]
07:49:50 <EvilTerran> which isn't very consistent
07:49:52 <byorgey> > readInt 10 (`elem` "0123456789") Char.digitToInt "143"
07:49:53 <lambdabot>  [(143,"")]
07:49:58 <byorgey> > readInt 10 (`elem` "012456789") Char.digitToInt "143"
07:49:59 <lambdabot>  [(14,"3")]
07:50:14 <sw17ch> ah, i also don't understand the [(Int,[Char])]
07:50:31 <byorgey> sw17ch: the Int is the parsed Int, the [Char] is the part of the string that's left over
07:50:34 <sw17ch> > readInt 10 (`elem` "012456789") Char.digitToInt "143a123"
07:50:35 <lambdabot>  [(14,"3a123")]
07:50:47 <sw17ch> odd
07:50:52 <sw17ch> > readInt 10 (`elem` "012456789") Char.digitToInt "143123"
07:50:52 <lambdabot>  [(14,"3123")]
07:51:24 <sw17ch> Char.digitToInt "123"
07:51:26 <byorgey> and it's in a list because there could be multiple possible parses (not in this case, but in general something with type ReadS a could
07:51:27 <sw17ch> > Char.digitToInt "123"
07:51:27 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
07:51:45 <sw17ch> mmm
07:52:16 <sw17ch> I was half expecting it to parse all the numbers in the string provided and the second part of the tuple would be the separating characters until the next
07:52:31 <sw17ch> or something equally ridiculous
07:53:01 <byorgey> sw17ch: well, just based on the type that's not a ridiculous expectation =)
07:53:26 <sw17ch> =)
07:53:42 <sw17ch> ah, it does stop parsing after the first function fails
07:53:46 <sw17ch> err... returns False
07:54:02 <byorgey> but yeah, this particular function could probably just return a (t,String) instead of [(t,String)], but it returns the latter so that it is consistent with other parsing functions.
07:54:25 <byorgey> sw17ch: yup, looks like it
07:55:00 <byorgey> haha, check out this comment from the Numeric source:
07:55:02 <sw17ch> alright, so the fact that i just return the first part of the tuple from the first index isn't a BadThing(tm) then :)
07:55:03 <byorgey> -- It's turgid to have readSigned work using list comprehensions,
07:55:03 <byorgey> -- but it's specified as a ReadS to ReadS transformer
07:55:03 <byorgey> -- With a bit of luck no one will use it.
07:55:21 <byorgey> sw17ch: nope =)
07:55:40 <sw17ch> hahaha, fantastic
07:55:52 <byorgey> @dict turgid
07:55:52 <lambdabot> Supported dictionary-lookup commands:
07:55:53 <lambdabot>   all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
07:55:53 <lambdabot> Use "dict-help [cmd...]" for more.
07:56:25 <byorgey> @web1913 turgid
07:56:26 <lambdabot> *** "Turgid" web1913 "Webster's Revised Unabridged Dictionary (1913)"
07:56:26 <lambdabot> Turgid \Tur"gid\, a. [L. turgidus, from turgere to swell.]
07:56:26 <lambdabot>    1. Distended beyond the natural state by some internal agent
07:56:26 <lambdabot>       or expansive force; swelled; swollen; bloated; inflated;
07:56:26 <lambdabot>       tumid; -- especially applied to an enlarged part of the
07:56:28 <lambdabot> [8 @more lines]
07:56:50 * byorgey wonders if 'turgid' was really the word they wanted there...
07:57:04 <Choko> (\(x,y) -> xor x y) can i rewrite it to some xor.plyf ?
07:57:11 <sw17ch> alright, now an even bigger question... is there an equivalent function which can read Integer's rather than Int's ?
07:58:06 <sw17ch> byorgey: well... the code for readSigned is a bit more bloated/wide/long than the rest of the various "read"s
07:58:18 <byorgey> sw17ch: oh, indeed
07:58:38 <byorgey> Choko: uncurry xor
07:58:43 <Choko> thanks
07:59:04 <byorgey> @type reads
07:59:05 <lambdabot> forall a. (Read a) => String -> [(a, String)]
07:59:15 <sw17ch> I think the idea of "turgid" works out great... though i have a hard time getting some pictures of illustrated fat and happy plants from biology class out of my head
07:59:32 <byorgey> > reads "123a6" :: ReadS Integer
07:59:33 <lambdabot>  Couldn't match expected type `ReadS Integer'
07:59:48 <byorgey> > reads "123a6" :: [(Integer,String)]
07:59:48 <lambdabot>  [(123,"a6")]
07:59:52 <byorgey> > reads "123a6" :: [(Int,String)]
07:59:53 <lambdabot>  [(123,"a6")]
07:59:56 <byorgey> sw17ch: haha =)
08:00:08 <byorgey> > reads "1232386987345078345a6" :: [(Int,String)]
08:00:09 <lambdabot>  [(2122606665,"a6")]
08:00:13 <byorgey> > reads "1232386987345078345a6" :: [(Integer,String)]
08:00:14 <lambdabot>  [(1232386987345078345,"a6")]
08:00:32 <sw17ch> oh my, look at that
08:00:38 <sw17ch> :)
08:00:58 <sw17ch> > reads "9999999999999999999999999999999999999999" :: [(Integer,String)]
08:00:59 <lambdabot>  [(9999999999999999999999999999999999999999,"")]
08:01:06 <sw17ch> > reads "9999999999999999999999999999999999999999aab" :: [(Integer,String)]
08:01:07 <lambdabot>  [(9999999999999999999999999999999999999999,"aab")]
08:01:38 <byorgey> sw17ch: reads obviously isn't as flexible as readInt and its kin, but it works for any type which is an instance of the Read type class.
08:01:40 <sw17ch> well, that solves that... but i still need it to handle an arbitrary base :(
08:02:21 <byorgey> hm, wait
08:02:25 <byorgey> @type Numeric.readInt
08:02:27 <lambdabot> forall a. (Num a) => a -> (Char -> Bool) -> (Char -> Int) -> String -> [(a, String)]
08:03:07 <byorgey> > readInt 10 (`elem` "012456789") Char.digitToInt "143" :: [(Integer,String)]
08:03:08 <lambdabot>  [(14,"3")]
08:03:17 <byorgey> > readInt 10 (`elem` "0123456789") Char.digitToInt "1432439834897645" :: [(Integer,String)]
08:03:18 <lambdabot>  [(1432439834897645,"")]
08:03:26 <sw17ch> hmmm :)
08:03:33 <byorgey> despite its name, it appears that readInt can also read Integers =)
08:03:48 <sw17ch> glorious
08:04:55 <byorgey> notice that it returns a (Num a) => [(a, String)] rather than [(Int,String)]
08:05:14 <sw17ch> this may be a dumb question, but how does one specify that type in a source file?
08:05:32 <sw17ch> i have a wrapper that takes care of both of the needed functions for me
08:05:53 <byorgey> sw17ch: well, there are two ways: you can either give it an explicit type annotation, or if the type is known in context, the compiler can infer it for you.
08:06:39 <byorgey> you could do something like readHexInteger :: String -> [(Integer,String)] ; readHexInteger = readInt 16 ... and so on
08:08:04 <byorgey> > readInt 4.3 (`elem` "0123456789") Char.digitToInt "1423" -- Num a, eh?
08:08:04 <lambdabot>  [(165.067,"")]
08:08:10 <byorgey> o.O
08:08:21 <sw17ch> ...wow
08:08:26 <sw17ch> i don't even know what that means
08:08:30 <sw17ch> :)
08:08:40 <sw17ch> 1423 in base 4.3?
08:08:53 <byorgey> > let b = 4.3 in b^2 + 6*b + 5 + 6*b^(-2) + 7*b^(-3)
08:08:54 <lambdabot>  Exception: Prelude.^: negative exponent
08:09:01 <byorgey> > let b = 4.3 in b^2 + 6*b + 5 + 6*b^^(-2) + 7*b^^(-3)
08:09:02 <lambdabot>  49.70254229187367
08:09:08 <byorgey> hm... nope
08:09:18 <sw17ch> > readInt 3.14 (`elem` "0123456789") Char.digitToInt "100"
08:09:19 <lambdabot>  [(9.8596,"")]
08:09:38 <byorgey> oh, wait, right.  I was thinking backwards.
08:10:08 <byorgey> that's not 100 in base 3.14, that's the decimal equivalent of "100" interpreted AS base 3.14.
08:10:15 <byorgey> > 3.14^2
08:10:16 <lambdabot>  9.8596
08:10:45 <sw17ch> > readInt 3.14 (`elem` "0123456789") Char.digitToInt "1000"
08:10:45 <lambdabot>  [(30.959144000000002,"")]
08:10:54 <davidL> @type showIntAtBase
08:10:55 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
08:10:57 <byorgey> > sum $ zipWith (*) [3,2,4,1] (iterate (*4.3) 1)
08:10:58 <lambdabot>  165.06699999999998
08:11:42 <sw17ch> well, curious, but useless?
08:12:00 <sw17ch> it would be interesting if it could be reversed.... but i'm not seeing how to do that
08:12:11 <Tac-Work> @t iterate
08:12:11 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
08:12:17 <sw17ch> i've always wondered about base switching "encryption"
08:12:18 <Tac-Work> @type iterate
08:12:18 <lambdabot> forall a. (a -> a) -> a -> [a]
08:12:53 <sw17ch> > take 3 $ iterate (\x -> "f(" ++ x ++ ")") "x"
08:12:54 <lambdabot>  ["x","f(x)","f(f(x))"]
08:13:01 <sw17ch> > take 4 $ iterate (\x -> "f(" ++ x ++ ")") "x"
08:13:02 <lambdabot>  ["x","f(x)","f(f(x))","f(f(f(x)))"]
08:17:25 <moldy> hi
08:19:54 <sw17ch> hi
08:39:09 <glen_quagmire> how can I find meaning of $= ?
08:39:18 <glen_quagmire> hoogle returns nothing
08:39:46 <quicksilver> it is a haskell opengl thing
08:39:56 <quicksilver> it is essentially like writeIORef
08:39:59 <quicksilver> but generalised
08:40:11 <quicksilver> so it works on IORefs but also on a bunch of openGL state variables.
08:40:19 <glen_quagmire> so, it's not a haskell operator?
08:40:33 <quicksilver> depends what "a haskell operator" means
08:40:45 <quicksilver> it's not defined in the prelude, if that's what you mean.
08:40:46 <Tac-Work> not a core part of the language
08:40:53 <glen_quagmire> like, ($) is haskell operator for apply
08:40:55 <quicksilver> It is an operator which works in haskell programs, though :)
08:41:13 <glen_quagmire> so, opengl overloaded ($=) ?
08:41:19 <olsner> > all undefined []
08:41:21 <lambdabot>  True
08:41:31 <olsner> > any undefined []
08:41:31 <quicksilver> glen_quagmire: not overloaded. Defined.
08:41:31 <lambdabot>  False
08:42:01 <Tac-Work> > any (const True) undefined
08:42:02 <lambdabot>  Undefined
08:42:05 <glen_quagmire> oh can I create my own operator? say, ---> ?
08:42:08 <Valodim> weird, but it kinda makes sense
08:42:16 <Valodim> yeah, define function name like (--->)
08:42:20 <quicksilver> glen_quagmire: of course
08:42:28 <quicksilver> glen_quagmire: and operator is just a function written infix
08:42:30 <glen_quagmire> oh i didin't know
08:42:44 <quicksilver> let a ~~++~~++~~ b = a+b in 5 ~~++~~++~~ 9
08:42:45 <quicksilver> > let a ~~++~~++~~ b = a+b in 5 ~~++~~++~~ 9
08:42:47 <lambdabot>  14
08:42:58 <Valodim> 5 `div` 2
08:42:58 <Valodim> would be an infix use of div
08:43:01 <Tac-Work> @let (?) b t f = if b then t else f
08:43:04 <lambdabot> Defined.
08:43:14 <quicksilver> http://www.haskell.org/ghc/docs/latest/html/libraries/OpenGL/Graphics-Rendering-OpenGL-GL-StateVar.html
08:43:16 <lambdabot> http://tinyurl.com/24hd3h
08:43:16 <Tac-Work> > True ? 1 0
08:43:17 <lambdabot>   add an instance declaration for (Num (t1 -> t))
08:43:26 <quicksilver> glen_quagmire: that is the docs for $=, such as they are
08:43:27 <Tac-Work> hehe tertiary
08:43:31 <Tac-Work> not quite
08:43:31 <glen_quagmire> > let (--->) a b = b in 1 ---> 2
08:43:32 <lambdabot> Unbalanced parentheses
08:43:59 <Tac-Work> For lambdabot, you need to use @let
08:44:07 <Tac-Work> @let cool = "cool"
08:44:08 <lambdabot> Defined.
08:44:08 <Tac-Work> > cool
08:44:09 <quicksilver> not for a local definition, you don't
08:44:09 <lambdabot>  "cool"
08:44:18 <quicksilver> he was only trying to define it locally like I did
08:44:20 <Tac-Work> oh whoops
08:44:25 <Tac-Work> didn't see that X-(
08:44:56 <quicksilver> glen_quagmire: that's actually a bug in lambdabot :)
08:45:04 <quicksilver> glen_quagmire: it has a buggy parser. That will work in ghci
08:45:12 <quicksilver> Prelude> let (--->) a b = b in 1 ---> 2
08:45:12 <quicksilver> 2
08:45:17 <glen_quagmire> yup it works on ghci
08:45:34 <olsner> > (?) True 1 0
08:45:35 <lambdabot>  1
08:45:46 <olsner> > True ?
08:45:46 <lambdabot>   parse error on input `}'
08:46:00 <glen_quagmire> > let a ( b = a + b in 1 ( 2
08:46:00 <lambdabot> Unbalanced parentheses
08:46:03 <Tac-Work> > True ? 1
08:46:04 <lambdabot>  <Integer -> Integer>
08:46:17 <olsner> > (True ? 1) 0
08:46:18 <lambdabot>  1
08:46:23 <glen_quagmire> do I look at haskel98 report to see what kind of operator I can define?
08:46:31 <quicksilver> glen_quagmire: syntactically, yes
08:46:37 <mux> > 1 > 2 ? "foo" $ "bar"
08:46:37 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `Bool'
08:46:39 <olsner> > True ? 1 $ 0
08:46:40 <lambdabot>  1
08:46:47 <mux> > (1 > 2) ? "foo" $ "bar"
08:46:48 <lambdabot>  "bar"
08:47:04 <quicksilver> glen_quagmire: it's basically most of the !@$%^&*()-+/?|
08:47:16 <quicksilver> but there are a couple of strange rules
08:47:29 <quicksilver> anything beginning with : is a constructor, not a normal operator
08:47:34 <quicksilver> and a few things are reserved
08:47:39 <quicksilver> ::, ->, <-
08:47:57 <quicksilver> but yes, the detrails are in the report
08:48:33 <glen_quagmire> quicksilver: thank you
08:56:30 <gigamonkey> I'm trying to follow along with this tutorial: http://sigfpe.blogspot.com/2006/05/grok-haskell-monad-transformers.html
08:56:32 <lambdabot> Title: A Neighborhood of Infinity: Grok Haskell Monad Transformers, http://tinyurl.com/y6w3jr
08:56:45 <gigamonkey> Am I right to assume there are some steps the author skipped over.
08:57:23 <gigamonkey> when I type the code in ghci I syntax errors in the neighborhood of the '=' in the test1 = do ... expression.
08:57:34 <quicksilver> it's not code to be typed in
08:57:36 <quicksilver> erm
08:57:39 <quicksilver> that's a silly thing to say
08:57:41 <quicksilver> let me try again :)
08:57:47 <EvilTerran> it's not code to type into ghci
08:57:48 <quicksilver> that code needs to go into a file, not straight into ghci
08:57:56 <EvilTerran> it's code to save in a file, and load from there
08:57:57 <quicksilver> ghci can't do multi-line definitions
08:58:02 <quicksilver> or, not conveniently
08:58:11 <quicksilver> you can :load files into it though
08:58:16 <gigamonkey> So I tried typing it one one line using { and ; instead of layout but got the same error.
08:58:22 <gigamonkey> Maybe I just screwed up the syntax.
08:58:29 <kpreid> gigamonkey: the repl is not like a file
08:58:35 <EvilTerran> ghci can only do things that you can do in a do{...} block
08:58:35 <quicksilver> gigamonkey: no, you didn't.
08:59:02 <kpreid> gigamonkey: files are module definitions, primarily composed of *declarations*, and the repl takes *expressions* (or rather, do-block statements)
08:59:03 <quicksilver> gigamonkey: you could have got somethign to work by putting 'let' in front of test1 and test2 and typing them on one line
08:59:07 <EvilTerran> (mostly. it adds a "print (...)" around things when necessary)
08:59:13 <quicksilver> but it's probably not worth it
08:59:33 <quicksilver> EvilTerran: I don't think that's a useful way to think of it, true though it may be. IMO the *main* thing that ghci does is evaluate expressions.
08:59:49 <EvilTerran> gigamonkey, as he says at the top, the post is in literate haskell format
08:59:53 <quicksilver> EvilTerran: I think it's sad to relegat this 'main thing' to a footnote containig the word "mostly" :)
09:00:15 <gigamonkey> So what tool groks literate Haskell
09:00:28 <EvilTerran> this means you can paste it verbatim into a file with extension .lhs, and ghc will be able to understand it
09:00:32 <EvilTerran> (including ghci)
09:01:10 <gigamonkey> (If it was me, I'd call it "Literate Haskell" rather than "literate Haskell" to give a clue it's a specific thing not just a description. But now I know.)
09:01:45 <EvilTerran> indeed. i tend to just call it "literate haskell", but that's primarily because i'm too lazy to capitalise properly.
09:01:48 <olsner> erlang is weird, some process called "beam" inside the build process has now been running for 23 minutes of cpu time
09:02:35 <kpreid> olsner: beam is the erlang vm
09:02:39 <kpreid> iirc.
09:04:48 <olsner> the erlang compiler is apparently written in erlang and run in the VM... I hope it's compiling everything in one go and that that's why its taking so long
09:04:57 <gigamonkey> beam = Bob's Erlang Abstract Machine, IIRC (for some B name which may not be Bob.)
09:06:11 <gigamonkey> So it's a specific feature of the State monad that there's evalState that lets you get at the "wrapped" value, right.
09:06:14 <gigamonkey> ?
09:06:25 <Tac-Work> Literate Haskell is the clearest evidence we have that Haskell was invented as a topic for professors to write research papers on
09:06:45 <EvilTerran> gigamonkey, yes
09:06:50 <EvilTerran> @src evalState
09:06:51 <lambdabot> Source not found. stty: unknown mode: doofus
09:06:54 <Tac-Work> evalState is the "Way Out" of the state monad
09:06:55 <EvilTerran> @src State
09:06:56 <lambdabot> Source not found. The more you drive -- the dumber you get.
09:06:59 <EvilTerran> bah
09:07:31 <gigamonkey> Doesn't that violate the point of having a Monad in the first place?
09:07:36 <desegnis> gigamonkey, if by “specific” you mean that it's not related to  State  being a monad, then yes
09:07:40 <sieni> Tac-Work: I haven't quite figured out the point of literate programming in general
09:07:54 <quicksilver> gigamonkey: not at all, no
09:07:58 <gigamonkey> I mean specific to that monad. For instance there's no equivalent for the IO monad.
09:07:59 <Philippa> Tac-Work: One of the reasons for Haskell's existance was so researchers would all be writing about the same non-strict language, yes
09:08:16 <quicksilver> gigamonkey: many monads provide some degree of inspection of the monad's internals
09:08:27 <quicksilver> gigamonkey: most monads have some special things which only apply to them...
09:09:01 <gigamonkey> As I understand it if there was a way to get at the wrapped value of the IO monad that would allow non-functional foo to contaminate the rest of your program and then you might as well be programming in C. I don't yet see why the State monad should be any different.
09:09:02 <Tac-Work> Literate Haskell is quite an interesting example of a polygot program though
09:09:03 <EvilTerran> gigamonkey, one of the fundamental points of monads in programming is that you can't necessarily get the values out again afterwards
09:09:18 <EvilTerran> gigamonkey, because State is pure haskell :)
09:09:30 <EvilTerran> @source Control.Monad.State
09:09:30 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/State.hs
09:09:37 <quicksilver> gigamonkey: well, notice that you *can't* get the value out of a state monad, just like that
09:09:40 <Tac-Work> gigamonkey: The state monad's state is self contained. Changes made inside of it can only affect the "input" for evalState
09:09:49 <quicksilver> gigamonkey: you need to provide an initial state each time
09:09:50 <EvilTerran> @source Control.Monad.State.Lazy
09:09:50 <lambdabot> Control.Monad.State.Lazy not available
09:10:03 <quicksilver> gigamonkey: so your object of type 'State s a' is like a program
09:10:05 <EvilTerran> @go you could have invented monads
09:10:17 <quicksilver> gigamonkey: runState evalState etc let you "run" that program, by providing an initial state
09:10:19 <lambdabot> http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
09:10:19 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ...
09:10:44 <EvilTerran> iirc, that describes how State gives the impression of mutable state using only pure code
09:10:45 <quicksilver> gigamonkey: because the program is a first-class value, you can run it over and over again with as many different states s as you want, or not at all.
09:10:50 <Tac-Work> gigamonkey: It's sort of like how a function in other languages can use destructive updates locally, but at the end of the day, the function as a whole is referrentially transparent
09:11:28 <Botje> >
09:11:40 <Philippa> gigamonkey: IO is special because it can't be implemented in Haskell
09:11:50 <desegnis> Botje: unexpected end of input.
09:12:12 <Philippa> ST is special like that too, but not as strongly so - if you don't mind using dynamic typing features and ignoring performance you can implement it today
09:12:41 <Philippa> but State is much simpler (and incidentally doesn't use mutable state under the hood)
09:13:06 <Tac-Work> State lets you do things such as creating an empty list, cons values onto it as you calculate, and then, you pull out the final value
09:13:27 <Tac-Work> But it doesn't let you do stuff with the outside world... you can only mess with that one mutable value. No IO allowed.
09:13:43 <shachaf> Tac-Work: You could also use Writer for that.
09:13:55 <kpreid> gigamonkey: the "can't open it or things go non-functional" is a property of IO, not a property of monads
09:14:54 <gigamonkey> So I haven't really thought this through but it seems that if I have some function that does 1 + evalState x the result of that function is going to depend on the current state of x, no?
09:15:06 <kpreid> No.
09:15:14 <kpreid> @type evalState
09:15:15 <shachaf> gigamonkey: The State monad is really just the equivalent of threading state manuall.
09:15:16 <lambdabot> forall s a. State s a -> s -> a
09:15:30 <kpreid> gigamonkey: x does not contain a state
09:15:31 <shachaf> gigamonkey: You don't use evalState inside the functions, actually.
09:15:43 <Philippa> gigamonkey: evalState takes two parms, that won't typecheck
09:15:49 <Philippa> you have to pass it an initial state
09:15:49 <kpreid> x is a procedure with input and output state
09:16:09 <shachaf> gigamonkey: Nomally you'd say something like do { x <- m; return (1 + x) }
09:16:13 <gigamonkey> Ah, I see.
09:16:16 <kpreid> @let proc = do a <- get; put (a + 10)
09:16:17 <lambdabot> Add a type signature
09:16:30 <kpreid> @let proc = do a <- get; put (a + 10) :: State Int ()
09:16:32 <lambdabot> Defined.
09:16:41 <kpreid> > 1 + (evalState proc 99)
09:16:42 <lambdabot>   add an instance declaration for (Num ())
09:16:42 <lambdabot>     In the expression: 1 + (evalSt...
09:16:48 <kpreid> > 1 + (execState proc 99)
09:16:49 <lambdabot>  110
09:16:54 <kpreid> > 1 + (execState proc 0)
09:16:54 <lambdabot>  11
09:17:09 <kpreid> the input state is supplied; the output state is returned
09:17:21 <Tac-Work> gigamonkey: the trick with the state monad, in my learning experience, was that it's really not as fancy as your mind imagines it might be
09:17:34 <shachaf> @unmtl State s a -- gigamonkey: Just keep in mind that these are equivalent.
09:17:34 <lambdabot> s -> (a, s)
09:18:01 <gigamonkey> Yeah, I just missed noticing the extra argument to evalState
09:18:25 <kpreid> gigamonkey: Monad doesn't say anything about inaccessibility; it's just a standard way of composing operations into a program
09:18:28 <Tac-Work> @let add10 = execState proc
09:18:29 <lambdabot> Defined.
09:18:29 <roconnor> Whew, done my proof that my new integral is correct.
09:18:32 <Tac-Work> > add10 9
09:18:33 <lambdabot>  19
09:19:05 <Tac-Work> You can name evalState <statemonad> and it looks like a 'normal' function and is one too
09:19:33 <shachaf> Except that you have to give it the initial state.
09:19:52 <dcoutts_> njbartlett: ping
09:19:53 <Tac-Work> well, the "initial state" is simply your parameter then
09:20:14 <kpreid> so the State monad isn't a magic way to do stateful stuff; it's a way to write functions in terms of a state present
09:20:21 <shachaf> Tac-Work: That doesn't return the value, though, it returns the new state.
09:20:31 <dcoutts_> bos: you were after me yesterday I think
09:20:43 <olsner> @djinn ((a -> b) -> a -> c) -> a -> b -> c
09:20:43 <lambdabot> f a b c = a (\ _ -> c) b
09:20:50 <Tac-Work> shachaf: ah yeah
09:20:55 <bos> dcoutts_: yes, i was going to ask you some c2hs questions.
09:21:01 <Tac-Work> :t evalState
09:21:02 <lambdabot> forall s a. State s a -> s -> a
09:21:04 <Tac-Work> :t execState
09:21:05 <lambdabot> forall s a. State s a -> s -> s
09:21:14 <bos> dcoutts_: but then i gave up and started using the FFI directly.
09:21:19 <shachaf> @ty runReader
09:21:19 <lambdabot> forall r a. Reader r a -> r -> a
09:21:28 <Tac-Work> :t runState
09:21:29 <lambdabot> forall s a. State s a -> s -> (a, s)
09:21:29 <dcoutts_> bos: heh, c2hs is great for function calls, much less useful for Storable instances
09:21:31 <Tac-Work> I couldn't remember the last one
09:21:48 <bos> dcoutts_: yeah, it's actually function calls i'm dealing with.
09:22:06 <bos> but c2hs seems to have the gnome function naming conventions pretty well baked in.
09:22:25 <dcoutts_> bos: the underscore to CamlCase thing?
09:22:33 <bos> yeah.
09:22:42 <dcoutts_> I think that's not default
09:22:47 <bos> dcoutts_: i'm writing bindings for LLVM, which has a different naming convention.
09:23:00 <dcoutts_> anyway, you specify {# call the_real_c_function_name#}
09:23:48 <dcoutts_> bos: so what goes wrong? there's no case convention for function names
09:24:45 <gigamonkey> bos: when are you guys going to post some chapters of RWH for public consumption?
09:27:41 <dcoutts_> bos: actually I'm quite confused about what could go wrong about the caml case stuff, none of it is on by default and it only affects the Haskell names
09:27:52 <dcoutts_> bos: so you'll have to show me what's going wrong
09:34:53 <shachaf> "Sorry, we hit ⊥ when trying to find the page you requested.". :-)
09:35:48 <bos> dcoutts_: there's nothing going wrong, it's just that the default helpful name mangling (stripping off "gtk_" or some other prefix) doesn't quite match my needs
09:36:05 <bos> gigamonkey: whenever i have some cycles to spare
09:36:28 <dcoutts_> bos: then don't use {# context prefix="gtk" #} and it will not do it. If it's doing that it's because you've told it to do so.
09:36:47 <dcoutts_> bos: there is no default name mangling
09:37:20 <bos> dcoutts_: the thing is, it's *almost* what i want. the name mangling is very nearly useful to me :-)
09:37:45 <bos> the problem lies with the LLVM function naming convention, where functions have names like LLVMCreateInterpreter
09:38:00 <bos> so what one would want is to strip off "LLVM" and lowercase the first letter
09:38:06 <dcoutts_> bos: if you don't use the prefix thing then you can just say {# call LLVMCreateInterpreter as createInterpreter #}
09:38:26 <bos> dcoutts_: yeah, it just doesn't save as much typing as I'd like :-)
09:38:43 <dcoutts_> bos: it's type safety you should worry about, not typing
09:38:46 <bos> it would be nice if the name mangling could be specified via a String -> String function.
09:38:53 <dcoutts_> bos: indeed, that'd be nice
09:39:34 <bos> dcoutts_: but i want to have my cake and eat it!
09:39:40 <bos> it's a nice cake!
09:39:41 <dcoutts_> bos: supporting that mangling should be easy actually, since the haskell name always has to be lower case
09:39:58 <dcoutts_> bos: so adding that mangling would not interfere with the existing "prefix_" convention
09:40:15 <dcoutts_> drop the given prefix plus any _, then lower case the first letter
09:40:21 <dcoutts_> that covers both
09:41:55 <bos> true
09:42:22 <dcoutts_> bos: so presumably at the moment you end up with an upper case haskell identifier?
09:42:46 <dcoutts_> bos: like : foreign import CreateInterpreter "LLVMCreateInterpreter" :: Blah -> Blah
09:44:07 <bos> dcoutts_: yes, right
09:44:19 <bos> dcoutts_: which, well, doesn't work out so well :-)
09:44:24 <dcoutts_> no :-)
09:45:27 <bos> dcoutts_: but really, i was initially expecting c2hs to autogenerate stubs for me, and it doesn't seem to.
09:45:51 <dcoutts_> bos: stubs, you mean the foreign import statements?
09:46:04 <dcoutts_> or to do some default marshaling?
09:46:43 <dcoutts_> {# call #} does no marshaling, {# fun #} is a top level function declaration with marshaling for parameters and result
09:50:36 <bos> dcoutts_: stubs as in autogenerating the function calls for me
09:51:33 <dcoutts_> bos: that's what {# fun #} hooks do
09:51:51 <dcoutts_> bos: if I wrote a patch for that name mangling issue, would you mind testing it for me
09:52:00 <dcoutts_> I think it's just one well placed toLower
09:52:45 <bos> dcoutts_: well, i'm not currently using c2hs.
09:52:56 <bos> but i'll give it a whirl.
09:53:02 <dcoutts_> bos: ta
10:00:49 <Cale> http://uk.youtube.com/watch?v=FZeoHPRoBVk  :D
10:00:50 <lambdabot> Title: YouTube - Distributive laws 4
10:02:14 * roconnor made a distributive monad last week.
10:02:44 <oerjan> o_O
10:02:55 <Philippa> I'm writing one for dataflow programming (with cells all the same type at the moment)
10:03:44 <roconnor> oerjan: I have a completion monad and a step-function monad.
10:04:12 <roconnor> oerjan: there is an injection Step (Complete X) -> Complete (Step X)
10:04:49 <roconnor> for example a step function to real numbers is the limit of step function to rational numbers.
10:05:29 <oerjan> i was just wondering because i didn't think you could implement distributivity without an Eq constraint?
10:05:32 <roconnor> oerjan: anyhow, I used this distribuative function to define integration.
10:06:34 <roconnor> oerjan: I don't think an Eq constraint is necessary anymore than an Eq constraint is needed for any monad laws.
10:07:24 <roconnor> M distributs over N when there is a function distr: M (N x) -> N (M x) that satifiies a bunch of laws.
10:08:04 <oerjan> ah, so it's a technical term
10:08:11 <roconnor> indeed
10:08:32 <oerjan> i was sort of imagining the monad of free distributive algebras
10:08:45 <roconnor> when M distributes over N, then the composition N (M a) is a monad.
10:08:47 <oerjan> (like rings)
10:09:13 <roconnor> so N (M a) is almost obviously a monad, the only problem is join.
10:09:33 <roconnor> We need a function N (M (N (M a))) -> (N (M a))
10:10:12 <roconnor> The trick is to use liftM distr : N (M (N b)) -> N (N (M b))
10:10:26 <roconnor> then when b = (M a)
10:10:48 <roconnor> we get liftM distr : N (M (N (M a))) -> N (N (M (M a)))
10:11:16 <roconnor> then we can use the join on N and join (with some lifts) on M to result in N (M a)
10:14:37 <oerjan> nearly diagram chasing there...
10:15:45 <byorgey> roconnor: neat, that was a really clear explanation =)
10:15:48 <mxcantor> anyone get ghc 6.8.x working on mac osx 10.5 PPC?
10:18:02 <roconnor> byorgey: I forget what the laws for distr are.
10:20:58 <byorgey> roconnor: that's ok, my learning of CT is still in the "handwavy/piecemeal" phase, so the actual laws would probably be lost on me anyway.  I'll read about the laws when I actually go back and learn CT properly from the ground up. =)
10:21:34 <roconnor> byorgey: yeah, the laws are pretty much always true anyways whenever you use reasonable functions of the right type. :)
10:21:51 <byorgey> roconnor: exactly. =)
10:22:07 <roconnor> what is really usefull is to know the types of the functions.
10:22:25 <roconnor> that way, when you encounter them in the wild, you can try to see if they fit your framework.
10:27:52 * byorgey imagines hunting wild functions
10:40:38 <qebab> "... Did you see that lambda over there? It was trying to sneak up on us!"
10:41:18 <proqesi> don't hit it with your car!
10:41:24 <glen_quagmire> in .lsh, is there a way to force ghc consider lies with '    ' consider to be a source code instead of '> ' ?
10:41:55 <EvilTerran> don't think so
10:42:04 <EvilTerran> it'd be pretty easy to make a preprocessor for it, tho, i guess
10:42:04 <dylan> if there is, I'm making the coolest quine ever!
10:42:08 <glen_quagmire> that way, i can convert .lsh to html using markdown. ok i'll just have to sed it
10:42:31 <EvilTerran> sorry, you do mean .lhs, right?
10:42:37 <glen_quagmire> yes
10:42:55 <EvilTerran> just checkin'. literate shell script would be weird, but possible. ;)
10:42:59 <oerjan> glen_quagmire: you are aware of the \begin{code} ... \end{code} variation?
10:43:10 <Saizan> hscolour is quite good at formatting code in literate haskell leaving the comments untouched
10:43:18 <qebab> :o TeXskell?
10:43:45 <glen_quagmire> oerjan: oh didn't know that. thanks
10:44:24 <EvilTerran> or, you could use -pgmL
10:44:45 <EvilTerran> "-pgmL cmd Use cmd as the literate pre-processor."
10:45:24 <byorgey> qebab: lhs2TeX, in fact =)
10:45:51 <qebab> byorgey: yeah I noticed erm a certain similarity there
10:46:06 <glen_quagmire> darn google considers -pgml special
10:46:21 <glen_quagmire> so, the pre-processor should delete everything except the code
10:46:23 <fadec> what's the difference between literate haskell and haskell?
10:46:34 <byorgey> qebab: you can write .lhs files in such a way that they are simultaneously valid Haskell files, and can be input to lhs2TeX in order to produce a nicely typeset article (or whatever). =)
10:46:44 <byorgey> or documentation.
10:46:44 <qebab> cool
10:46:51 <gbacon> fadec: commenting style
10:47:24 <oerjan> fadec: in literate haskell everything is a comment unless you explicitly mark it otherwise
10:47:33 <fadec> I've seen the term thrown around quite a bit so I was beginning to wonder.
10:48:02 <byorgey> qebab: yup, it's pretty cool. =)  For example, most of the Monad.Reader is typeset that way.
10:48:04 <jfoutz> there's a fair number of blog articles that say, paste this whole think into a lhs file to see the examples.
10:48:07 <byorgey> @where Monad.Reader
10:48:07 <lambdabot> I know nothing about monad.reader.
10:48:12 <byorgey> @where monad reader
10:48:13 <lambdabot> I know nothing about monad.
10:48:34 <durka> http://www.haskell.org/haskellwiki/The_Monad.Reader
10:48:35 <lambdabot> Title: The Monad.Reader - HaskellWiki
10:48:37 <gbacon> http://www.haskell.org/onlinereport/literate.html
10:48:37 <lambdabot> Title: The Haskell 98 Report: Literate Comments
10:48:51 <byorgey> thanks durka
10:49:09 <byorgey> @where+ monad.reader http://www.haskell.org/haskellwiki/The_Monad.Reader
10:49:09 <lambdabot> Done.
10:49:14 <byorgey> @where Monad.Reader
10:49:14 <lambdabot> http://www.haskell.org/haskellwiki/The_Monad.Reader
10:49:45 <EvilTerran> -pgmL 'awk "/^    / { print substr($0,4,-1) }'
10:49:54 <EvilTerran> would also work (as a flag to ghc), i think
10:50:07 <EvilTerran> er, make that last ' a "', but still
10:50:40 <fadec> That's a pretty neat idea (literate) for haskell. Since I started using haskell I've noticed that my code window became the 1/4 size window on my screen anyway. It's so dense info-wise.
10:52:35 <qebab> yeah, haskell is really terse
10:53:05 <gbacon> it'd be nice to have WEB's reordering
10:53:29 <byorgey> gbacon, what's that?
10:55:23 <gbacon> byorgey: http://en.wikipedia.org/wiki/WEB
10:55:33 <gbacon> it's Knuth's literate programming system
10:56:21 <gbacon> hmm..
10:56:25 <gbacon> @wikipedia WEB
10:57:17 <roconnor> gbacon: what do you mean by reordering?
10:57:31 <byorgey> gbacon: right, sorry, that's what I was trying to ask =)
10:57:42 <gbacon> reordering means your docs can approach the software in the order that makes sense as opposed to giving a chunk-by-chunk commentary
10:57:50 <shapr> @users
10:57:50 <lambdabot> Maximum users seen in #haskell: 434, currently: 377 (86.9%), active: 18 (4.8%)
10:58:09 <byorgey> gbacon: well, Haddock can do that
10:58:20 <roconnor> gbacon: haskell's ability to order functions arbitarily within a module means that isn't as much of an issue.
10:58:37 <byorgey> it orders the generated documentation in order by the export list, instead of in the order it occurs in the file
10:58:52 <roconnor> > let {a = b; b = 1} in a
10:58:55 <lambdabot>  1
10:59:18 <gbacon> sorry, different contexts.. I was talking about within an lhs file
10:59:39 <byorgey> roconnor: yes, but in my experience, sometimes the code makes the most sense in a certain order, while the documentation makes the most sense in a different order.
10:59:47 <roconnor> gbacon: same thing works inside a module definition.
10:59:59 <roconnor> byorgey: really?
11:00:01 <gbacon> but you still have to have the front matter at the front
11:00:11 <mxcantor> the scheme in 48 hours tutorial is really good
11:00:11 <roconnor> gbacon: true
11:00:12 <gbacon> module Foo where ...
11:00:19 <mxcantor> if the writer happens to be lurking here
11:00:29 <roconnor> that goes in chapter 0
11:00:40 <gbacon> :-)
11:00:58 <byorgey> roconnor: yes, although I don't have a good example at the moment =)
11:01:25 <roconnor> gbacon: did you see http://contracts.scheming.org/
11:01:34 <lambdabot> Title: Composing Contracts
11:01:48 <byorgey> roconnor: in particular for library modules, when most users just want to know how to use the library, rather than understand how it is implemented.
11:01:51 * gbacon fetches
11:02:00 <roconnor> gbacon: the first chapter is Module header: code but not comment
11:02:13 <roconnor> gbacon: I sort of agree it isn't ideal, but it isn't so bad.
11:02:16 <gbacon> I remember reading that paper a long time ago
11:02:21 <gbacon> roconnor: granted
11:06:04 <gbacon> especially when not shackled down with a language where "Pascal order" makes a difference
11:07:08 <gbacon> but byorgey's point holds
11:10:01 <wy> Is foldr more powerful than foldl?
11:10:23 <gbacon> didn't notice the HAppS interface in that paper before!
11:10:40 <oerjan> wy: foldr can work on infinite lists
11:11:05 <wy> oerjan: ah, that's the point
11:11:13 <oerjan> on finite lists, you could always apply reverse to convert between them...
11:11:30 <Tac-Work> :t foldl
11:11:31 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
11:11:31 <Tac-Work> :t foldr
11:11:32 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
11:11:43 <wy> So I can define many other functions in foldr, but not in foldl
11:12:03 <oerjan> also, foldl' is nearly always better than foldl
11:12:15 <wy> foldl' ?
11:12:23 <gbacon> it's the strict variant of foldl
11:12:31 <gbacon> @src foldl'
11:12:31 <lambdabot> foldl' f a []     = a
11:12:32 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
11:12:32 <Tac-Work> @src foldl'
11:12:32 <lambdabot> foldl' f a []     = a
11:12:33 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
11:12:45 <gbacon> Tac-Work: jinx :-)
11:12:51 <Tac-Work> =-X
11:13:17 <wy> How does that work?
11:13:31 <Tac-Work> where is Cale's drawings of the different kinds of folds?
11:13:32 <gbacon> @src seq
11:13:32 <lambdabot> Source not found. Take a stress pill and think things over.
11:13:40 <byorgey> @where fold
11:13:40 <lambdabot> I know nothing about fold.
11:13:43 <gbacon> @botsnack
11:13:44 <lambdabot> :)
11:13:45 <byorgey> @where folds
11:13:46 <lambdabot> http://cale.yi.org/index.php/Fold_Diagrams
11:13:50 <byorgey> there =)
11:13:54 <oerjan> it makes sure to evaluate as you go down the list, rather than building up a huge thunk to be evaluated at the end
11:14:04 <byorgey> wy: foldr is not 'more powerful' than foldl, they are just different
11:14:04 <gbacon> @karma+ cgibbard
11:14:05 <lambdabot> cgibbard's karma raised to 1.
11:14:13 <oerjan> the latter can cause space leaks and stack overflows
11:14:33 * oerjan though Cale used Cale as nick
11:15:07 <oerjan> *thought
11:15:21 <gbacon> hmm.. I've seen him here as cgibbard, but looks like he's Cale now
11:15:26 <Tac-Work> wow, that server is slow as molases
11:15:39 <wy> Is it called catamorphism?
11:15:57 <jfoutz> any thoughts on a datastructure to use to hold the netflix dataset? the standard list has too much overhead for my limited supply of ram.
11:16:04 <wy> byorgey: Nice pictures. Thanks
11:16:18 <Tac-Work> jfoutz: an array?
11:16:21 <byorgey> wy: well, Cale made them, not me, but you're welcome
11:16:37 <gbacon> @karma+ Cale
11:16:37 <lambdabot> Cale's karma raised to 55.
11:16:54 <olsner> @pl \f x y -> (\xs ys -> xs ++ max (maximum xs) (maximum ys + 1) ++ ys) (f x) (f y)
11:16:54 <lambdabot> flip =<< (((.) . liftM2 (.) (++) (join . ((++) .) . (. ((1 +) . maximum)) . max . maximum)) .)
11:17:04 <byorgey> wy: foldr is a catamorphism for lists.
11:17:07 <EvilTerran> oof
11:17:29 <oerjan> olsner: ++ ?
11:17:41 <gbacon> @botsnack
11:17:41 <lambdabot> :)
11:18:07 <gbacon> olsner: nice
11:18:38 <olsner> oerjan? yes, list concatenation
11:18:51 <oerjan> that outer thing is an on
11:18:51 <wy> byorgey: So I guess there are catamorphism for other structures?
11:19:13 <oerjan> on (\xs ys -> ...)
11:20:07 <byorgey> wy: indeed =)
11:20:37 * EvilTerran manipulates the inner thing as far as (\xs -> (++) =<< (xs ++) . max (maximum xs) . succ . maximum)
11:21:03 <oerjan> the inner thing probably could use an `on` maximum too
11:21:07 <byorgey> @go banans lenses
11:21:16 <roconnor> bananas
11:21:18 <byorgey> @go bananas lenses
11:21:41 <glen_quagmire> -pgmL says can't execute ...  I just write normal literate haskell  then do sed -e 's/^>\s*/    /' Hello.lsh | pandoc    to convert it into html
11:21:46 <byorgey> @botsnack
11:21:46 <lambdabot> :)
11:21:50 <byorgey> odd
11:21:56 <roconnor> google is down
11:21:57 <Jangler> @pl foldl (\x y -> x*b + y) 0
11:21:58 <lambdabot> foldl ((+) . (b *)) 0
11:22:03 <byorgey> really!?
11:22:10 <roconnor> no j/k
11:22:19 <EvilTerran> \xs -> (++) =<< (xs ++) . (max `on` maximum) xs . map succ
11:22:47 <byorgey> wy: http://citeseer.ist.psu.edu/meijer91functional.html
11:23:14 <byorgey> roconnor: heh =P
11:23:31 <dcoutts_> wy: you can implement foldl in terms of foldr, but not the other way around.
11:24:15 <gbacon> @src foldl'
11:24:16 <lambdabot> foldl' f a []     = a
11:24:16 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
11:24:16 <wy> This little thing is hiding a lot of fun ;-)
11:24:31 <gbacon> @pl let a' = f a x in a' `seq` foldl' f a' xs
11:24:32 <lambdabot> f a x `seq` foldl' f (f a x) xs
11:24:41 <byorgey> wy: this little thing called Haskell?
11:24:48 <gbacon> @pl foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
11:24:49 <lambdabot> foldl' = fix (flip flip tail . ((flip . (ap .)) .) . flip flip head . ((flip . ((.) .)) .) . ((.) . (.) . flip . (ap seq .) . flip =<<))
11:24:54 * gbacon laughs
11:25:02 <gbacon> @botsnack
11:25:02 <lambdabot> :)
11:25:06 <benny99> I can't laugh :'(
11:25:16 <wy> byorgey: This little thing is foldr... haskell is not that little
11:25:24 <byorgey> wy: oh, hehe
11:25:50 <gbacon> @src fix
11:25:51 <lambdabot> fix f = let x = f x in x
11:25:54 <wy> byorgey: It seems those picture are drawn with inkscape
11:26:14 <dcoutts_> wy: foldr is the natural inductive encoding of the list data type so it can do everything
11:26:23 <byorgey> wy: yup
11:26:33 <dcoutts_> wy: the same style of encoding can be used with all algabraic data types
11:26:50 <dcoutts_> wy: eg, maybe is the natural fold for the Maybe type
11:26:50 <roconnor> dcoutts_: well, foldr isn't a primative recursor.
11:26:57 <dcoutts_> @type maybe
11:26:58 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
11:27:09 <dcoutts_> @src Maybe
11:27:10 <lambdabot> data Maybe a = Nothing | Just a
11:27:50 * benny99 wonders whether somebody is interested in "Gobbying around" a bit :) -- (http://gobby.0x539.de/trac/) 
11:27:51 <lambdabot> Title: obby - Trac
11:28:13 <dcoutts_> benny99: we've used it for cabal hacking before, it's not too bad
11:28:27 <wy> dcoutts_: Ah. There is a lot in it
11:28:27 <benny99> dcoutts_: :)
11:28:46 * benny99 is looking for other clueless hobby newBs :)
11:28:51 <wy> byorgey: Is inkscape the best thing I can find in linux for drawing pictures?
11:29:22 <Zao> For vectoring, probably.
11:29:32 <benny99> or anybody else who wants to play around a bit :)
11:29:55 <byorgey> wy: yes, IMO, although I haven't played with much else =)
11:30:24 <byorgey> wy: gimp is good too, depending what kinds of pictures you want to draw
11:31:20 <wy> byorgey: I guess gimp is like photoshop, inkscape is like illustrator. I used to use illustrator to draw pictures in windows
11:31:28 <byorgey> wy: right, exactly
11:31:35 <benny99> wy: yep
11:31:54 <benny99> gimp got just more cool plugins =)
11:32:08 <wy> I hope there is a good mind mapper in Linux, so I won't forget things
11:32:20 <gbacon> @src foldr
11:32:20 <lambdabot> foldr k z xs = go xs
11:32:20 <lambdabot>     where go []     = z
11:32:20 <lambdabot>           go (y:ys) = y `k` go ys
11:32:36 <byorgey> mind mapper?
11:33:13 <gbacon> how do you write where clauses without layout?
11:33:20 <sw17ch> wy: i remember wanting a mind mapper, but don't remember what it was
11:34:21 <wy> sw17ch: I like to take notes with it, and it's easier to discover connections between ideas with it
11:34:37 <oerjan> gbacon: all layout can be replaced with { ; }
11:34:45 <benny99> wy: for sure not in linux, but maybe in some repos :p
11:35:04 <benny99> wy: there are some for sure, wait
11:35:20 <gbacon> @pl foldr k z xs = go xs where { go [] = z; go (y:ys) = y `k` go ys; }
11:35:20 <lambdabot> (line 1, column 28):
11:35:21 <lambdabot> unexpected "{"
11:35:21 <lambdabot> expecting variable, "(", operator or end of input
11:35:52 <oerjan>  @pl's parser has a lot of holes...
11:35:59 <benny99> wy: http://www.clemens-kraus.de/linux/oss-mindmap-programme-unter-linux.htm
11:36:02 <lambdabot> Title: www.clemens-kraus.de - OpenSource MindMap-Programme unter Linux, http://tinyurl.com/3yf7v4
11:36:32 <oerjan> gbacon: also you won't be able to do that kind of pattern matching with @pl
11:37:50 <gbacon> :-(
11:38:02 <wy> benny99: Ah ha! vym is in ubuntu
11:39:02 <sw17ch> wow, freemind looks cool
11:39:42 <benny99> Is there somebody who got some time spare?
11:40:10 <monochrom> That is relative to how the spare time will be spent.
11:40:16 <oerjan> @pl foldr k z xs = let go l = if null l then z else (head l) `k` go (tail l) in go xs
11:40:17 <lambdabot> foldr = (fix .) . flip ((.) . ap . flip (if' . null)) . (. (. tail)) . ap . (. head)
11:40:40 <benny99> monochrom: helping some newb to code something stupid
11:40:49 <benny99> monochrom: *easy
11:40:55 <sw17ch> how stupid/easy :)
11:42:13 <benny99> sw17ch: waha... very easy :( -- you might do whatever you like, but you might spend more time on explaining then than on coding
11:43:35 <benny99> :-( great
11:44:11 <gbacon> oerjan: nice
11:44:17 <byorgey> benny99: what code are you trying to write?
11:45:20 <benny99> byorgey: an extremly simple interpreter for thingies like "2+23*4"
11:45:28 <benny99> byorgey: i.e. a calculator
11:45:56 <wy> benny99: This one is very attractive! http://www.webofweb.net
11:46:00 <lambdabot> Title: Web of Web
11:47:12 <benny99> wy: cool :)
11:47:58 <wy> benny99: google should buy it ;-)
11:48:20 <benny99> or copy it :p
11:49:39 <sw17ch> benny99: my connection died... do you still need help, or did you find it elsewhere
11:49:52 <sw17ch> (i may not be able to help either, but i can try)
11:50:13 <benny99> sw17ch: gnah, you don't need to :)
11:50:17 <benny99> wait a sec
11:51:41 <benny99> sw17ch: sent you the ip and port number
11:53:18 <monochrom> Arithmetic interpreter can be done using Parsec. This may be a mean advice because it says you have to learn Parsec.
11:53:48 <benny99> nah, I want to do it on my own first
11:54:12 <benny99> sw17ch: still there :-[ ?
11:54:15 <sw17ch> yes
11:54:15 <sw17ch> sorry
11:54:20 <sw17ch> had to help my wife quick
11:54:34 <sw17ch> just so i know, what are we doing with the ip and port?
11:54:43 <sw17ch> i lost that part of the conversation
11:55:02 <benny99> :'( you are cheating on me?
11:55:20 <sw17ch> well, yes, if helping my wife is considered that :P
11:55:22 <benny99> sw17ch: no, I wanted to "gobby" with you
11:55:29 <wy> benny99: This one is even cooler: http://comapping.com/
11:55:39 <lambdabot> Title: Com.org - Only the best links ...
11:56:00 * byorgey keeps trying to use ++ for string concatenation in Java =P
11:56:06 <sw17ch> to be honest, i've never used it before =)
11:56:12 <benny99> (http://gobby.0x539.de/trac/)
11:56:13 <lambdabot> Title: obby - Trac
11:56:19 <sw17ch> just a second and i'll have it
11:56:24 <sw17ch> :)
11:56:40 <benny99> sw17ch: gnah, I hope I'll be able to wait that long
11:56:58 <monochrom> If you want to write the parser internals yourself, most Haskell books have it (e.g, Bird's, Hutton's), or the paper http://www.cs.nott.ac.uk/~gmh//bib.html#monparsing
11:56:59 <sw17ch> gentoo just has to pull it all in
11:57:00 <lambdabot> Title: Graham Hutton: Publications
11:57:09 <benny99> wy: no, you got to pay for it :p
11:57:41 <monochrom> The short story is: a parser is like a function of type String -> [(a,String)]
11:57:46 <benny99> monochrom: yeah, but it should be that simple, that I won't really need to know anything about parsers
11:57:54 <wy> benny99: Hope there is one like that and for free
11:58:07 <benny99> monochrom: yep
11:58:32 <byorgey> yeah, if you want to do a really simple version, you could only allow single-digit numbers
11:58:39 <byorgey> then 34+ would be 7
11:58:41 <byorgey> and so on
11:59:07 <benny99> byorgey: gnah, well
11:59:07 <byorgey> that way you don't have to worry about parsing per se, just interpret the input character by character.
11:59:18 <byorgey> it might be a good place to start, at least
11:59:26 <benny99> byorgey: I need an additional "previous result * 10"
11:59:39 <sw17ch> benny99: well, that broke... there isn't another way to do this is there?
11:59:50 <benny99> byorgey: and if an operator like + follows, the number is "finished"
11:59:58 <benny99> sw17ch: broke ?
12:00:01 <monochrom> "42 56 + 2 ^" in postfix is not too bad. Just needs a lexer.
12:00:04 <sw17ch> compiling gobby
12:00:20 <benny99> sw17ch: gentoo?
12:00:24 <sw17ch> yep
12:00:31 <monochrom> But "(42+56)^2" is CFG. There is no escape from a parser.
12:00:32 <benny99> uh, yeah :(
12:00:36 <wy> http://touchgraph.com/TGGoogleBrowser.html
12:00:37 <lambdabot> Title: TouchGraph | Products: Google Browser
12:01:32 <wy> try search haskell in it :-)
12:01:47 <benny99> sw17ch: gimme a sec
12:01:47 * Madrok gives benny99 a bag of Cheerios
12:01:52 <sw17ch> alright
12:01:54 <benny99> :-[ ?
12:03:05 <benny99> wy: cool :)
12:04:11 * sw17ch grumbles about java plugins
12:08:27 <Spark> compact flash is nothing other than what should have happened to java if they hadn't made a colossal pigs ear of it
12:08:31 <Spark> erm
12:08:33 <Spark> macromedia flash, even
12:08:57 <sw17ch> hehe... i was going to say... Compact Flash did what with Java?
12:08:59 <sw17ch> :P
12:09:02 <monochrom> Haha, I was thinking how compact flash is analogous to java... :)
12:10:50 <benny99> sw17ch: maybe that works :-[
12:10:59 <Spark> i was thinking more about the marketting and distribution
12:11:05 <sw17ch> benny99: pw?
12:11:23 <Spark> they should have got it shipped with firefox
12:11:40 <Spark> this open source stuff is too little too late
12:17:01 <benny99> http://moonedit.com/down.htm <-?
12:17:04 <lambdabot> Title: MoonEdit
12:19:16 <sw17ch> benny99: what are you trying to do?
12:19:25 <sw17ch> like... what's your actual problem?
12:19:26 <benny99> sw17ch: telling you to use moonedit
12:19:31 <benny99> and finally do something :-[
12:19:41 <sw17ch> hpaste
12:20:00 <sw17ch> http://hpaste.org/new
12:20:35 <sw17ch> that will let you put whatever you want, and then inform the list that you've updated the paste
12:20:42 <sw17ch> and by list, i mean channel
12:21:17 <benny99> yeah
12:21:41 <benny99> guess that's the best :o
12:21:50 * osfameron loves the idea of moonedit, not tried it since a few years ago (when I didn't like it all that much)
12:23:14 <hpaste>  benny pasted "(no title)" at http://hpaste.org/4671
12:23:36 <benny99> osfameron: gobby is much better
12:24:14 <jonafan> aw, built in music sequencer is windows only
12:24:27 <jonafan> PS built in music sequencer????
12:24:42 <benny99> yep, that code might be bad and stupid, but I got to start somewhere
12:24:57 <sw17ch> you're trying to make a calculator then? cool
12:25:09 <benny99> kind of :-[
12:25:16 <benny99> it's "the state"
12:25:23 <osfameron> yes. that's what I always wanted in my editor.  a builtin collaborative music sequencer
12:25:25 <benny99> with some "virtual registers"
12:25:36 <benny99> osfameron: xD
12:25:46 <osfameron> ooo, gobby supports mac+win+linux
12:26:04 <benny99> osfameron: yep
12:26:08 <SamB> compact flash is analogous to Java?
12:26:35 <sw17ch> mmm... maintaining state inside the calculator then :)
12:26:53 <osfameron> oh, their website really is at 0x539.de
12:27:10 <osfameron> I was worried it was a honeypot site that had somehow got decent googlerank...
12:27:12 <jonafan> i'm kind of a musician and i know musicians so a collaborative music editor might be kind of fun
12:27:23 <osfameron> jonafan: yes! it's a great idea
12:27:35 <osfameron> just not really high priority for a text editor
12:27:35 <gbacon> @pl (>>= \(a,_) -> [a])
12:27:36 <benny99> jonafan: there's ejam
12:27:36 <lambdabot> (fst `fmap`)
12:27:40 <jonafan> yeah hehe
12:27:43 <oerjan> > 0x539
12:27:46 <lambdabot>  1337
12:27:52 <gbacon> @pl lst >>= \(a,_) -> [a]
12:27:53 <lambdabot> fst `fmap` lst
12:27:54 <oerjan> gah!
12:27:56 * osfameron still occasionally thinks about a collaborative ascii art editor
12:27:57 <benny99> xD
12:28:12 * benny99 is away, looking at his stupid code
12:30:09 <gbacon> @pl lst >>= \(a,b) -> [Rec{f1 = a, f2 = b}]
12:30:09 <lambdabot> (line 1, column 19):
12:30:09 <lambdabot> unexpected "["
12:30:09 <lambdabot> expecting lambda abstraction or expression
12:30:19 <oerjan> gbacon: return = (:[]) in the list monad, and for every monad x >>= return . f = fmap f x
12:31:15 <oerjan> and fmap = map for lists, of course
12:31:18 <gbacon> oerjan: thanks.. what's the analog to pure inside a monad?
12:31:30 <oerjan> er pure = return
12:31:36 <oerjan> if you mean the Applicative pure
12:31:43 <gbacon> Arrow.pure
12:32:01 <oerjan> @src Kleisli pure
12:32:01 <lambdabot> Source not found. You speak an infinite deal of nothing
12:32:06 <oerjan> @src Kleisli arr
12:32:07 <lambdabot> Source not found. I am sorry.
12:32:38 <oerjan> 	arr f = Kleisli (return . f)
12:32:50 <oerjan> so (return .)
12:33:28 <gbacon> @src Control.Arrow.pure
12:33:28 <lambdabot> Source not found. Take a stress pill and think things over.
12:33:58 <gbacon> @pl \(a,b) -> Rec { f1 = a }
12:33:58 <oerjan> it's a method
12:33:58 <lambdabot> (line 1, column 15):
12:33:58 <lambdabot> unexpected "{"
12:33:58 <lambdabot> expecting variable, "(", operator or end of input
12:34:08 <oerjan> pure = arr, arr = pure are the defaults
12:34:17 <gbacon> gotcha
12:35:04 <gbacon> I'm trying to pack a record in the second argument to >>=
12:35:07 <oerjan> i don't think you can @pl record syntax
12:35:30 <gbacon> yes, I can KISS and use pattern matching
12:35:38 <oerjan> but you can always use ordinary constructor syntax
12:35:54 <oerjan> @pl \(a,b) -> Rec a
12:35:55 <lambdabot> Rec . fst
12:36:11 <byorgey> gbacon: does Rec have more fields than just f1 and f2?
12:36:24 <byorgey> if not, you can just say lst >>= uncurry Rec
12:36:38 <gbacon> byorgey: yes, but their values don't depend on the input pair
12:37:01 <byorgey> gbacon: what do you mean?
12:37:52 <gbacon> byorgey: yes there are more fields, but the values of those fields are independent of a and b
12:39:02 <gbacon> what's the point free equivalent to \(a,b) -> Rec { f1 = a, f2 = b, f3 = undefined }?
12:39:26 <oerjan> assuming f1, f2, f3 are all the fields in order?
12:39:32 <gbacon> yes
12:39:44 <oerjan> @pl \(a,b) -> Rec a b undefined
12:39:45 <lambdabot> uncurry (flip flip undefined . Rec)
12:39:57 * gbacon chuckles
12:39:59 <gbacon> whee!
12:40:04 <byorgey> you could define mkRec a b = Rec a b undefined
12:40:11 <byorgey> then just say uncurry mkRec
12:40:59 <byorgey> @type flip flip undefined
12:41:00 <lambdabot> forall a b c. (a -> b -> c) -> a -> c
12:41:20 <byorgey> @type flip flip flip undefined
12:41:21 <lambdabot> forall a c. a -> c
12:41:28 <gbacon> what a fun language!
12:41:29 <byorgey> @type flip undefined
12:41:30 <lambdabot> forall a b c. b -> a -> c
12:41:40 <byorgey> hehe
12:42:40 <gbacon> it's nice being able to pluck out parts of the input using pure inside an arrow
12:46:30 <gbacon> ok, so if I'm wrapping a single result inside an array just so I can use >>=, is that a sign I should simply use map?
12:47:11 <oerjan> yep
12:47:24 <gbacon> > [(1,2),(3,4)] >>= \(a,b) -> [a]
12:47:26 <lambdabot>  [1,3]
12:48:25 <oerjan> > [a | (a,b) <- [(1,2),(3,4)]]
12:48:26 <lambdabot>  [1,3]
12:49:29 <gbacon> right.. the last bit in the sequence is ... >>= \(a,b) -> [Rec ...]
12:49:51 <gbacon> map mkRec $ step1 >>= step2
12:51:44 <gbacon> too bad it doesn't look as nice
12:52:11 <oerjan> mkRec <$> step2 =<< step1
12:52:34 <EvilTerran> mkRec . step2 =<< step1
12:52:40 <EvilTerran> (i think...)
12:53:13 <byorgey> EvilTerran: I don't think that's the same thing
12:53:20 <timseves> Is there anyone knowledgeable in haddock & cabal who might be able to help with this: (using binary as an example here) I'd like to generate and install the documentation for package binary so that it appears linked into the ghc libs contents page and indexes along with base etc
12:53:39 <EvilTerran> ?type (\f g h -> (f <$> g =<< h, f . g =<< h))
12:53:41 <lambdabot> forall a (m :: * -> *) b a1. (Monad m) => (a -> m b) -> (a1 -> a) -> m a1 -> (m b, m b)
12:54:05 <oerjan> maybe the precedences are wrong
12:54:06 <byorgey> > (+1) `fmap` (\x -> [x+1,x+2]) =<< [1,2,3]
12:54:06 <lambdabot>   add an instance declaration for (Num [a])
12:54:16 <byorgey> > (+1) `fmap` ((\x -> [x+1,x+2]) =<< [1,2,3])
12:54:16 <lambdabot>  [3,4,4,5,5,6]
12:54:26 <byorgey> > (+1) . (\x -> [x+1,x+2]) =<< [1,2,3]
12:54:26 <lambdabot>   add an instance declaration for (Num [a])
12:54:42 <oerjan> > (0$0 <$>)
12:54:42 <lambdabot>      The operator `<$>' [infixl 4] of a section
12:54:43 <lambdabot>         must have lower prece...
12:54:48 <oerjan> > (0$0 =<<)
12:54:49 <lambdabot>      The operator `=<<' [infixr 1] of a section
12:54:49 <lambdabot>         must have lower prece...
12:54:57 <oerjan> <$> is much higher
12:55:02 <durka> > (+1) . ((\x -> [x+1,x+2]) =<< [1,2,3])
12:55:03 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `[a1]'
12:55:05 <timseves> So far I've used cabal to generate the haddock documention and tried using Setup.lhs configure --haddock-options to pass --use-contents and --gen-content etc
12:55:28 <timseves> but get the error "-h cannot be used with --gen-index or --gen-contents"
12:55:37 <byorgey> ah, I see what's going on
12:56:28 <byorgey> mkRec <$> step2 =<< step1 is the same as mkRec . step2 =<< step1, since <$> has higher precedence than =<< and fmap = (.) for the ((->) r) functor.
12:56:40 <oerjan> yep
12:56:53 <byorgey> but that isn't the point since mkRec <$> step2 =<< step1 isn't the same as map mkRec $ step2 =<< step1 in the first place =)
12:57:01 <byorgey> because of precedence
12:57:12 <EvilTerran> ahh
12:57:19 <oerjan> mkRec <$> (step2 =<< step1)
12:57:23 <byorgey> right =)
12:58:19 <byorgey> gbacon, got all that? ;-)
12:58:30 * gbacon nods :-)
12:59:22 <byorgey> ah, excellent =)
13:25:06 <wy> benny99: I finally found this one the best and free. http://www.mind42.com
13:25:08 <lambdabot> Title: Mind42 - Free Online Mind Map
13:37:01 <wy> Is the comment starting with "-- |" something special, like the doc string?
13:37:03 <glen_quagmire> > foldl (\x y -> x*2 + (if y == '0' then 0 else 1))  0 "01011"
13:37:10 <lambdabot>  11
13:37:14 <glen_quagmire> weeeeeeeeeee
13:37:33 <glen_quagmire> wy: -- is single line comment.  {-   is nested block comment -}
13:37:48 <byorgey> wy: yes, that's a Haddock comment.
13:37:58 <glen_quagmire> oh sorry my bad
13:38:15 <gbacon> @pl \v -> [v]
13:38:16 <lambdabot> return
13:38:21 <byorgey> the haddock tool can take such comments and generate nicely formatted documentation in various formats (e.g. html)
13:38:36 <wy> byorgey: good
13:38:58 <byorgey> @where haddock
13:38:59 <lambdabot> http://www.haskell.org/haddock/
13:39:01 <fxr> wy: http://www.haskell.org/haddock/doc/html/markup.html
13:39:08 <lambdabot> Title: Chapter 3. Documentation and Markup
13:40:56 <wy> fxr: Thanks!
13:47:37 <opqdonut> wasn't there some optimization-related use for ()?
13:48:04 <lQg> dumb parsers
13:48:48 <lQg> or symbol parsers
13:49:06 <lQg> tsal gyd
13:53:01 <wy> @src foldl
13:53:01 <lambdabot> foldl f z xs = lgo z xs
13:53:02 <lambdabot>     where lgo z []     =  z
13:53:02 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
13:53:30 <wy> Why isn't it foldl f z (x:xs) = foldl f (f z x) xs ?
13:54:27 <allbery_b> something about optimizations
13:55:37 <wy> -- We write foldl as a non-recursive thing, so that it
13:55:37 <wy> -- can be inlined, and then (often) strictness-analysed,
13:55:37 <wy> -- and hence the classic space leak on foldl (+) 0 xs
13:55:55 <wy> What's that comment about classic space leak about?
13:57:36 <bos> wy: write out the expansion of foldl (+) 0 [1,2,3] and see what it looks like.
13:58:23 <sw17ch> has any one made a packet sniffer/filter with haskell?
14:00:06 <basti_> not yet, to my knowledge.
14:00:21 <sw17ch> seems like an interesting project
14:00:33 <sw17ch> if any one has used something similar to EtherApe... i want something similar, only better... :)
14:00:49 <sw17ch> tied in with OpenGL some how... and using the libpcap bindings
14:01:01 <wy> foldl (+) 0 [1,2,3] = foldl (+) (0+1) [2,3] = ...
14:01:02 <sw17ch> seems like haskell would be good at this
14:01:51 <wy> = foldl (+) ((0+1)+2) [3]...
14:02:16 <wy> = foldl (+) (((0+1)+2)+3) []
14:02:50 <wy> So the second argument is not evaluated until the last step?
14:03:51 <ivanm> wy: isn't that foldr you're describing there?
14:03:54 <ivanm> @type foldl
14:03:56 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
14:04:28 <wy> ivanm: We are talking about the "classic space leak" of foldl
14:04:40 <ivanm> ahhh
14:04:50 * ivanm really should stop joining in in the middle of conversations :p
14:05:10 <sw17ch> ivanm: i was hoping you'd push it so i would not have to ask my self :)
14:05:49 <ivanm> heh
14:06:19 <wy> I still don't know why the implementation in the prelude is better. It just created a closure on f
14:08:17 <wy> Is that lgo much different from foldl ?
14:08:30 <wy> foldl2 f z xs = lgo z xs
14:08:30 <wy> 	     where
14:08:30 <wy> 		lgo z []     =  z
14:08:30 <wy> 		lgo z (x:xs) = lgo (f z x) xs
14:09:49 <allbery_b> for one, f is lifted out of the arguments to lgo
14:12:53 <benny99> wy: thanks
14:13:38 <wy> benny99: Maybe we can do brainstorming on one of the sites there :-)
14:13:51 <benny99> wy: why not :)
14:14:02 <benny99> though: what should we brainstorm ?
14:14:03 <wy> benny99: This one is also good and free: http://thinkature.com
14:14:04 <lambdabot> Title: Thinkature - Real-time collaboration for the web
14:14:32 <wy> benny99: Anything, it's just like a scratch board
14:15:35 <benny99> wy: but we got to have a topic I guess :)
14:16:31 <wy> benny99: I've got a topic now. If you want, try sign up at thinkature
14:16:50 <wy> benny99: Just try :-)
14:16:53 <benny99> I try :)
14:16:58 <benny99> to sign up :-[
14:17:11 <wy> My id is shredderyin there.
14:17:24 <benny99> but it appears as if it doesn't work right now :(
14:18:44 <wy> benny99: I'm using it. Maybe not so stable
14:18:56 <benny99> I can't sign up
14:19:31 <wy> why? It'll send you email
14:19:45 <wy> I also have some delay...
14:21:41 <tehgeekmeister> anyone know what's up with real world haskell?
14:22:06 <hpaste>  Naked pasted "pattern matches and guards combined" at http://hpaste.org/4672
14:22:41 <benny99> The username you specified has an invalid format. <-- nonesense :(
14:23:01 <benny99> tehgeekmeister: no
14:23:23 <tehgeekmeister> benny99: as in you don't know, or no one knows?
14:23:45 <benny99> tehgeekmeister: I don't know and I didn't get an answer either ;)
14:23:53 <tehgeekmeister> okay.
14:23:55 <Hadaka> hm
14:24:00 <Hadaka> didn't mean to announce that here :)
14:24:02 <tehgeekmeister> i've been waiting so patiently!
14:24:34 <benny99> wy: sorry, that thingy doesn't work right now :(
14:24:55 <wy> benny99: alright. We can try it later
14:25:00 <benny99> wy: or tomorrow :)
14:25:08 <benny99> wy: guess you are often around here ;) ?
14:25:26 <wy> benny99: Which usename did you try?
14:25:30 <sw17ch> does any one else have this train of thought when working with haskell? "I hate this.. i hate this.. i hate this... wtf.. i'm going back to C++.... .... .... I LOVE THIS LANGUAGE!!"
14:25:49 <benny99> sw17ch: yeah
14:25:56 <tehgeekmeister> sw17ch: if you substitute C++ with ruby, sure.
14:26:00 <sw17ch> haha, alright =)
14:26:03 <benny99> sw17ch: it's also described in the Haskell 98 standard :o... no...
14:26:16 <MyCatVerbs> sw17ch: no, I never have that.
14:26:23 <sw17ch> I just finished my Lisp parser... and i'm quite pleased with my self.. and the language... but the last few hours have been trying
14:26:29 <wy> sw17ch: I like haskell most
14:26:51 <sw17ch> wy: oh, i do as well... the happy spikes make up for the crappy parts
14:26:52 * benny99 loves haskell as well, thous he's on #haskell
14:27:10 <MyCatVerbs> sw17ch: occasionally I get, "Fuckiiiiiit, I'm going to go try Scheme again..." followed by, five minutes later, "Oh fucking Hell, I don't fucking know Scheme at all. Fuck. GHC, I still love you! Take me back! </3"
14:27:11 <benny99> I did never finish any project :(
14:27:27 <monochrom> hehe
14:27:34 <tehgeekmeister> playing with scheme and erlang lately, i begin to see all the little things i love about haskell that they just don't have.
14:27:36 <MyCatVerbs> sw17ch: except when I try using Concurrent Haskell.
14:27:38 <sw17ch> MyCatVerbs: isn't scheme a subset of haskell any way? :P
14:27:39 <benny99> wy: bebenny
14:27:51 <wy> benny99: That should work
14:27:54 <benny99> sw17ch: what?
14:27:56 <Philippa> sw17ch: uh, no
14:27:58 <MyCatVerbs> sw17ch: every time I use Concurrent Haskell, I just can't stop wanting to hug Simon Peyton Jones.
14:27:59 <Philippa> really, really not
14:28:02 <benny99> sw17ch: everything is a subset of scheme :p
14:28:05 <Philippa> for example, scheme has mutation
14:28:07 <sw17ch> haha, the syntax at least :P
14:28:19 <benny99> sw17ch: I was serious :|
14:28:36 <monochrom> I like Haskell.
14:28:43 <benny99> at least I read that often
14:28:44 <MyCatVerbs> I like Haskell.
14:28:51 <sw17ch> okay... perhaps i should rephrase that to Haskell can be translated to S-Exps quite easily
14:28:51 <benny99> I like Haskell.
14:28:51 <opqdonut> I like Haskell.
14:28:56 <MyCatVerbs> I really like Haskell-with-extensions.
14:29:01 <MyCatVerbs> I love Concurrent Haskell. <3
14:29:05 <sw17ch> I think we've all established that we like haskell...
14:29:07 <benny99> *spam*
14:29:18 <sw17ch> MyCatVerbs: Haven't used Concurrent Haskell... what's it taste like?
14:29:30 <MyCatVerbs> sw17ch: kittens, coated in sugar.
14:29:33 <benny99> ok, I'm off reading that monadic parser haskell-paper :) -- bye
14:29:43 <sw17ch> cya
14:29:46 <benny99> uh, oh, sorry
14:30:22 <benny99> does somebody actually got a good idea for a beginner? "what to program first with haskell"
14:30:46 <wy> benny99: A scheme interpreter ;-)
14:30:52 <sw17ch> MyCatVerbs: for whatever reason, that description brought this to mind...
14:30:53 <sw17ch> http://uncyclopedia.org/wiki/Kitten_huffing
14:30:55 <lambdabot> Title: Kitten Huffing - Uncyclopedia, the content-free encyclopedia
14:30:59 <shapr> mmm, Haskell!
14:31:07 <MyCatVerbs> sw17ch: ah, yes.
14:31:13 <tehgeekmeister> benny99: i say, once you've read some decent tutorials, build yourself a scheme and go thru project euler.
14:31:16 <tehgeekmeister> that's what i'm doing.
14:31:17 <MyCatVerbs> sw17ch: concurrent Haskell is like the orange ones. =)
14:31:20 <tehgeekmeister> the combination is great.
14:31:23 <wy> benny99: Actually, a lambda calculus interpreter would be better
14:31:35 <benny99> tehgeekmeister: sorry, a project euler ?
14:31:39 <sw17ch> benny66: build me a haskell based packet inspector
14:31:51 <benny99> wy: I like that idea though it sounds hard, I'm even to stupid to build that very simple interpreter
14:31:51 <tehgeekmeister> benny99: http://projecteuler.net/
14:31:59 <lambdabot> Title: Project Euler
14:32:01 <tehgeekmeister> benny99: http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/overview.html
14:32:04 <lambdabot> Title: Write Yourself a Scheme in 48 hours, http://tinyurl.com/l986o
14:32:11 <monochrom> benny99: certain number theory projects, binary search tree algorithms, ... these tend to be nice.
14:32:36 <benny99> tehgeekmeister: thanks =)
14:32:41 <wy> benny99: Write yourself a foldr in 48 minutes
14:33:05 <tehgeekmeister> wy: does that really exist?  that could actually be a decent tutorial
14:33:07 <MyCatVerbs> sw17ch: that wouldn't be such a great idea, neccessarily.
14:33:25 <MyCatVerbs> sw17ch: for a beginner, anyway. For an intermedia, Hell fucking yes.
14:33:44 <wy> tehgeekmeister: Write yourself a ... foldr?
14:33:49 <MyCatVerbs> sw17ch: just on the basis that Data.Binary is pretty new and unstable-ish. But it'd be *really* good to give that API a good workout.
14:33:52 <benny99> thanks once again :) - - I'm off then
14:34:04 <tehgeekmeister> wy: yes, well, for introducing the idea of folds and how they're useful.
14:34:14 <sw17ch> MyCatVerbs: well, perhaps when i wrap up my Senior Project i'll look at that next
14:34:19 <wy> Hey I still haven't figured out why this form of foldl would be better. foldl2 f z xs = lgo z xs
14:34:19 <wy> 	     where
14:34:19 <wy> 		lgo z []     =  z
14:34:19 <wy> 		lgo z (x:xs) = lgo (f z x) xs
14:34:29 <benny99> @src lgo
14:34:30 <lambdabot> Source not found. Where did you learn to type?
14:34:33 <benny99> :-[· ?
14:34:35 <Japsu> @src foldl
14:34:36 <lambdabot> foldl f z xs = lgo z xs
14:34:36 <lambdabot>     where lgo z []     =  z
14:34:36 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
14:34:37 <monochrom> Write yourself a foldr in 48 seconds.
14:34:57 <tehgeekmeister> monochrom: sure, if you already know what folds do.
14:34:59 <wy> monochrom: 48 seconds is not enough ;-)
14:35:18 <sw17ch> I need something to get me into HOpenGL and I'm thinking of doing a 3D mandelbrot set viewer where the color AND elevation of a point is the 2 dimensional distance from the mandelbrot set
14:35:29 <sw17ch> with rotation zooming and so on
14:35:30 <monochrom> Yes, it is not "read the specification for foldr in 48 second".
14:35:50 <monochrom> Hell, actually it is!
14:36:10 <wy> It seems that this lgo only capsuled f in a pointer, and did nothing more?
14:36:20 <monochrom> That's right.
14:36:34 * benny99 is off, night (yeah, once again ;) )
14:36:55 <monochrom> Naive compilation generates faster code with lgo. Smart compilation probably too.
14:37:04 <MyCatVerbs> LGO?
14:37:23 <monochrom> lgo is the local function in an implementation of foldr. See above.
14:37:30 <wy> monochrom: Why is that? because it has less parameters?
14:37:39 <monochrom> Yes. Tighter loop.
14:38:01 <wy> monochrom: I see. Is it about the graph reduction process?
14:38:09 <monochrom> Yes.
14:38:17 <wy> Aha!
14:38:17 <opqdonut> sw17ch: sounds nice
14:39:20 <sw17ch> opqdonut: i remembered how much i like fractals after working through one of my recent High Performance Computing assignments where we had to render the mandelbrot set using OpenMPI and mpich
14:39:47 <sw17ch> since the state isn't required to calculate anything in that set... seemed like it would be pretty "easy"
14:40:01 <opqdonut> "flying" through fractal landscapes is something i've always enjoyed
14:40:05 <davidL> sw17ch: you were wondering about packet sniffing and packet dissection, I am working on one
14:40:19 <sw17ch> davidL: oh really... for what purpose?
14:40:31 <davidL> sw17ch: not sure, really :P
14:41:12 <sw17ch> davidL: the thing I had in mind was a network timeline. i have no idea if something like this exists already. where connections show up as a line, and their thickness at any point along the line is the amount of data sent in that time slice
14:41:31 <davidL> right now it dissects ethernet v2, ip, and tcp protocols, but I'm trying to do tcp stream desegmentation now
14:41:32 <sw17ch> graphical of course... something that you could put up on a wall in a NOC office and watch
14:41:40 <sw17ch> cool
14:42:23 <sw17ch> the last packet sniffer i had to write was for my security class... simulated all ports being open on an nmap target
14:42:28 <davidL> that shouldn't be too difficult
14:42:39 <sw17ch> unfortunately... the tools are all outdated
14:42:43 <sw17ch> :(
14:43:13 <davidL> I don't think you would need to even do tcp desegmentation for that, which I think is one of the harder parts of packet sniffing
14:43:38 <wy> so is foldl more efficient than foldr?
14:44:06 <keseldude> it's just a different way of evaluating it afai
14:44:07 <keseldude> k
14:44:15 <monochrom> foldr (:) [] is more efficient than foldl whatever.
14:44:22 <thetallguy> wy: depends on what you apply it to
14:44:35 <SamB> monochrom: id is better though
14:44:40 <monochrom> hehe
14:44:42 <wy> I wonder if foldl can be used to define map?
14:44:52 <monochrom> foldr (\x xs -> f x : xs) []
14:44:56 <durka> @src foldr
14:44:56 <sw17ch> davidL: yeah... as far as i can tell... you'd only need to count packets, check length, look for the SYN/SYNACK and the RST packets...
14:44:56 <lambdabot> foldr k z xs = go xs
14:44:56 <lambdabot>     where go []     = z
14:44:56 <lambdabot>           go (y:ys) = y `k` go ys
14:45:02 <sw17ch> oh, and match port...
14:45:11 <jonafan> everything can be implemented as a fold
14:45:18 <sw17ch> all seems easy enough
14:45:21 <sw17ch> in C :)
14:45:40 <wy> But can you use foldl?
14:45:52 <monochrom> I can use anything.
14:46:03 <davidL> I'm not sure what would be the best way to keep state for all the connections, maybe the Writer monad?
14:46:50 <MyCatVerbs> sw17ch: I like the sound of that.
14:47:18 <sw17ch> davidL: I'm assuming you're using the libpcap bindings?
14:47:25 <monochrom> Suppose you read some articles saying "foldl' (+) is best". I say, they're right about Int and Integer and Double... But...
14:47:28 <wy> monochrom: I mean, define map in foldl ?
14:47:33 <davidL> sw17ch: yeah
14:47:39 <sw17ch> how are those?
14:48:04 <monochrom> But, foldl' (+) is totally stupid for "lazy naturals".
14:48:09 <davidL> I haven't had any problems: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/pcap-0.4.2
14:48:12 <lambdabot> http://tinyurl.com/22n4ux
14:48:32 <monochrom> "Lazy naturals" refers to something along the line of: data Nat = Zero | Succ Nat.
14:50:16 <alexj> does any of the socket code call getnameinfo?
14:50:24 <monochrom> This is with a (+) operator defined recursively. Usually this (+) is non-strict in the second argument, e.g., Succ (Succ Zero) + undefined = Succ (Succ undefined).
14:52:31 <monochrom> You also define comparisons, e.g., (>), to be as non-strict as possible. E.g., x>=2 evaluates x as much as seeing two Succ's only, and not evaluate any further. Thus, Succ (Succ undefined) >= 2 works, doesn't diverge.
14:54:44 <monochrom> An application of lazy naturals is with genericLength. If you have a potentially infinite list, genericLength gives potentially Succ (Succ (Succ ...  If all you care is "is the list length at least 2?", then genericLength with lazy naturals works. You just ask: genericLength mylist >= (2 :: Nat).
14:55:21 <opqdonut> yep
14:55:41 <monochrom> genericLength happens to be like foldr. You see it is totally counterproductive to make it foldl or even foldl', even though "conventional wisdom" would have you count list lengths with foldl.
14:55:55 <Ben`> how can I get an MD5 hash in Haskell?
14:56:09 <MyCatVerbs> Ben`: I think there's a library or two on Hackage.
14:56:21 <davidL> Ben: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Crypto-3.0.3
14:56:23 <lambdabot> http://tinyurl.com/2z4ujp
14:56:54 <Ben`> I installed the Crypto library, but I can't work out how to use it
14:57:00 <durka> is it just me, or is it generally very hard to install the cabal packages
14:57:03 <davidL> or: http://hackage.haskell.org/packages/archive/nano-md5/0.1.1/doc/html/Data-Digest-OpenSSL-MD5.html
14:57:05 <lambdabot> http://tinyurl.com/yssumg
14:57:24 <monochrom> Defining map with foldl is equally stupid, since it would not work for infinite lists, it would use too much memory, etc.
15:00:12 <monochrom> There is no royal road to efficiency.
15:03:01 <izuker> quick question
15:03:18 <izuker> if M is a type constructor
15:03:27 <izuker> is there some name for the function:
15:03:38 <izuker> project :: M ( M a ) -> M a
15:03:39 <izuker> ?
15:03:50 <monochrom> join, if M is a Monad.
15:04:20 <izuker> k, thanks
15:04:55 <conal> izuker: and join is slightly more general than your question: M can be a partial type application as well.
15:05:32 <monochrom> E.g., Either String (Either String a) -> Either String a
15:05:45 <monochrom> where M is replaced by Either String
15:06:04 <conal> or even (a -> a -> b) -> a -> b
15:06:16 <monochrom> this is valid because (Either String) is still waiting for the one last parameter.
15:06:32 <conal> as is ((->) a)
15:07:37 <izuker> hmmm.  interesting
15:08:03 <izuker> i'm trying to create a type for probability disributions
15:08:12 <izuker> (or "functionals")
15:08:30 <izuker> so far, i have type Dist a = ( a -> Float ) -> Float
15:08:50 <izuker> and then join :: Dist ( Dist a ) -> Dist a
15:09:40 <conal> izuker: do you also have a return :: a -> Dist a ?  if so, you have amonad.
15:09:45 <conal> (a monad)
15:09:53 <izuker> yeah
15:10:18 <izuker> but i've defined (>>=) in terms of join
15:10:31 <conal> izuker: i often do that as well.
15:10:44 <izuker> oh, whew, ok, that's alright then :)
15:11:28 <conal> izuker: though you might want to choose a different name, say joinDist.  then the usual join will be equivalent to joinDist.
15:12:29 <conal> izuker: in an alternate universe Monad derives from Functor and join and >>= are both Monad methods defaulted in terms of each other.
15:13:06 <SamB> we are all trying to figure out how to move to that universe
15:14:08 <izuker> i seem to've done just that:
15:14:36 <izuker> d >>= f = join $ fmap f $ d
15:15:05 <SamB> izuker: what does the haskell report say in your universe?
15:16:05 <conal> izuker: yep -- that's the default for >>= in the alternate universe, along with a default join mm = mm >>= id
15:16:16 <conal> then we wouldn't have to keep repeating these definitions.
15:16:55 <izuker> is there any documentation about this reality shift?  papers?  blogs?
15:17:09 <conal> i don't know.  SamB?
15:17:29 <Ben`> how do I use the hash function from Data.Digest.MD5?
15:17:49 <SamB> Cale: ?
15:18:13 <Cale> yeah?
15:18:56 <SamB> Cale: do you know of any documentation about this?
15:19:13 <Cale> About Data.Digest.MD5?
15:19:20 <SamB> no, the reality shift...
15:19:30 <Cale> oh
15:19:51 <Cale> I'm sure people have written up various proposals for the Monad hierarchy
15:19:59 <SamB> to a world where Functor is a superclass of Monad, join is a method, etc.
15:21:05 <Cale> yeah, and optionally, Applicative stuck in between the two
15:21:45 <SamB> http://www.haskell.org/haskellwiki/Class_system_extension_proposal is maybe interesting...
15:21:47 <lambdabot> Title: Class system extension proposal - HaskellWiki, http://tinyurl.com/ypupbe
15:24:25 <izuker> perfect.  thanks, people
15:24:32 <sw17ch> > (read "10.32e3" :: Double)
15:24:34 <lambdabot>  10320.0
15:24:37 <sw17ch> heck yes
15:26:59 <sw17ch> > (read "10.32e-3" :: Double)
15:27:00 <lambdabot>  1.032e-2
15:29:57 <sw17ch> > (read "-10.32e-3" :: Double)
15:29:58 <lambdabot>  -1.032e-2
15:32:35 <sw17ch> exciting, my parser handles all the fun numbers now... :)
16:12:54 <EvilTerran> @. vixen yow
16:12:55 <lambdabot> no
16:13:31 <Saizan> @vixen
16:13:31 <lambdabot> where can I a see a picture of you?? URL??
16:14:09 <EvilTerran> @vixen my name isn't earl
16:14:09 <lambdabot> that's a nice name
16:14:48 <dcoutts> njbartlett: you were after me earlier I think
16:16:48 <dainanaki> hey does anyone know where i could find free stock market data? i'm working on a little pet program that will do stock analysis, but I don't know where I can find that any stock market info for parsing.
16:17:21 <mae> is there a lightweight alternative to happs
16:17:39 <dcoutts> @hackage Finance-Quote-Yahoo
16:17:40 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Finance-Quote-Yahoo
16:17:54 <dcoutts> dainanaki: that might be what you want ^^
16:18:00 <Saizan> Network.CGI ?
16:18:19 <EvilTerran> dainanaki, if you don't need up-to-date data, there's archives of old data at, say, http://biz.swcp.com/stocks/
16:18:20 <lambdabot> Title: Historical Stock Data
16:18:32 <dainanaki> gotcha
16:18:34 <dainanaki> thank you
16:18:38 <dcoutts> mae: it depends on what features you want
16:18:51 <dainanaki> well i'm looking for up-to-date data mostly
16:19:05 <mae> ok, and what can i use to connect to a mysql database
16:19:20 <dainanaki> my grandpa does some stuff in the stock market, so I was gonna write him a program to help him with some stuff
16:19:21 <mae> something practical.. theres a few dead projects but i have no idea if there is something recent
16:20:38 <Saizan> mae: HDBC?
16:21:00 <mae> ty
16:25:49 <Hadaka> gah, I've got a typing problem in haskell I'm having a hard time solving
16:26:14 <opqdonut> paste?
16:26:42 <monochrom> New Year Eve Menu: Functor Salad, Monad Steak, Arrow Cake.
16:26:56 <Hadaka> I'll try to clean up a decent version of this, just a moment
16:27:18 <Saizan> dcoutts: in Hackage.Config, some ConfigFlags' fields lacks a FieldDescr, is that intentional?
16:29:30 <Saizan> how do you bind a steak? or compose a cake?
16:29:48 <FunctorSalad> please help a newb :( why doesn't this compile? until somefunction <newline> \x y -> foo <newline> (bar,baz)
16:31:19 <Saizan> ?type until
16:31:22 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
16:31:47 <FunctorSalad> a is a pair type here
16:31:49 <hpaste>  Hadaka pasted "Probability monad typing problem" at http://hpaste.org/4673
16:31:58 <Saizan> so use \(x,y) -> ..
16:32:12 <Hadaka> opqdonut: see http://hpaste.org/4673
16:32:53 <Saizan> until somefunction $ \(x, y) -> foo (bar,baz) <-- get an error here?
16:33:03 <FunctorSalad> Saizan: thanks. I think another problem is that my "somefunction" doesn't work on pairs, but on the type of y. well, the error was just "parse error on input `\'" :(
16:33:17 <Hadaka> run_ddist is polymorphic, run_samples is polymorphic, select_mode is polymorphic, but for some reason process_die is not polymorphic (enough)
16:33:45 <FunctorSalad> Saizan: yes, that would yield an error for said reason
16:34:45 <Saizan> ok, lambdas need to be wrapped in paretheses, or with a low precedence operator like $
16:35:14 <FunctorSalad> ah, I see. fixed the other things but still got the parse error
16:35:17 <Hadaka> the code uses -fno-monomorphismrestriction though, so that probably makes it a bit more harder to solve - but that was recommended by the probabilitymonads
16:36:25 <Saizan> Hadaka: can you annotate with the error?
16:36:59 <hpaste>  Hadaka annotated "Probability monad typing problem" with "(no title)" at http://hpaste.org/4673#a1
16:37:11 <Hadaka> Saizan: sure, http://hpaste.org/4673#a1
16:37:36 <Saizan> ok, as i suspected the problem is that you're mixing Int and Float in that function
16:38:00 <Hadaka> Saizan: yeah, but I *want* to mix those - I want it to accept either as the functions the values are being passed to accept either
16:38:14 <Saizan> so the right thing is probably to promote the results of roll_ndn_* to Float?
16:38:52 <Hadaka> Saizan: but that I definitely do not want to do - since I need the values in the file as "4", not "4.0" - and I may have different values there than just ints
16:39:06 <shapr> I want code!
16:39:06 <sw17ch> with the ghc debugger, is it possible to set a breakpoint in a different module?
16:39:13 <sw17ch> one that is included from Main?
16:39:21 <sw17ch> err... imported?
16:39:24 <Hadaka> Saizan: here's the type of one of the called functions: run_ddist :: (Ord a, Show a) => Handle -> DDist a -> IO ()
16:39:33 <sw17ch> nm... just found it
16:39:39 <Hadaka> Saizan: I'd like the type of that be similar, but for some reason it's not polymorphic
16:40:01 <FunctorSalad> still doesn't parse :( http://hpaste.org/4674
16:40:27 <FunctorSalad> (indentation)
16:41:23 <Saizan> Hadaka: ah, then you want impredicative polymorphism, you need an explicit type signature to process_die for that
16:41:52 <Hadaka> Saizan: thanks! will try
16:41:57 <dcoutts> Saizan: not entirely intentional
16:42:34 <dcoutts> mae: hdbc is good but does not have a mysql backend
16:43:00 <Saizan> dcoutts: sure? i recall to have used it with mysql
16:43:14 <dcoutts> Saizan: perhaps via odbc?
16:43:18 <dcoutts> Saizan: do you want to look into tidying up that config file code in cabal-install? it needs it
16:43:42 <Hadaka> Saizan: this doesn't seem to work: process_die :: (Dist d, Ord a, Show a) => (d a -> IO ()) -> [[Char]] -> IO ()
16:43:53 <Hadaka> Saizan: am I doing something obvious wrong?
16:44:14 <EvilSporkMan> YAHT says that func1 x = map (*x) is point-free; isn't x a point?
16:44:30 <Saizan> dcoutts: ah, no, confusing it with HSQL
16:44:44 <dcoutts> Saizan: right
16:45:26 <Saizan> dcoutts: yes, but i'd need some pointers on what to do :)
16:45:29 <Hadaka> EvilSporkMan: well, x could be considered a point - but what was meant that the *next* parameter there is not shown and as such it's point-free with regard to map's second parameter
16:46:15 <dcoutts> Saizan: well, take a look at the recently cleaned up command line handling, it seems to me that we could unify much of the sutff needed for command line handling and config file handling
16:46:26 <dcoutts> Saizan: they represent essentially the same information.
16:46:35 <Jangler> @pl (\x -> map (*x))
16:46:35 <lambdabot> map . (*)
16:46:38 <Saizan> Hadaka: process_die :: (forall a d. (Dist d, Ord a, Show a) => d a -> IO ()) -> [[Char]] -> IO () ?
16:46:58 <EvilSporkMan> Hadaka: so it has less points but is not free of them ;)
16:48:04 <Saizan> dcoutts: which module?
16:48:09 <Hadaka> EvilSporkMan: well, a point refers to a certain point, not any point I guess - but yeah, true :)
16:48:27 <Hadaka> Saizan: there's a syntax error there and I can't seem to fix it :(
16:48:41 <Hadaka> Saizan: samplecalc.hs:49:53: parse error on input `=>'
16:49:16 <dcoutts> Saizan: in Cabal lib, Distribution.Simple.Command and .Setup and for the config file stuff, some utils in Distribution.ParseUtils and used in Distribution.InstalledPackageInfo
16:49:25 <FunctorSalad> same here. "parse error (possibly incorrect indentation)", but even putting everything in one line doesn't fix it.
16:49:36 <dcoutts> Saizan: then also used in cabal-install in .Config and .Setup and Main
16:50:21 <Saizan> Hadaka: use -fglasgow-exts or -XRank2Types
16:50:37 <Hadaka> Saizan: ah, thanks
16:53:00 <hpaste>  Hadaka annotated "Probability monad typing problem" with "(no title)" at http://hpaste.org/4673#a2
16:53:15 <Saizan> FunctorSalad: sure that the error is in that line? it parses here
16:53:22 <Hadaka> Saizan: new error from then - tried to document it as best as I could here: http://hpaste.org/4673#a2
16:53:55 <Hadaka> Saizan: the error shown is similar to the errors I get from elsewhere in the code if I leave '-fno-monomorphism-restriction' out
16:55:44 <Hadaka> I really should teach myself how these 'forall' clauses really work
16:55:52 <FunctorSalad> Saizan: odd. the rest of the program (just defining the things used in that line) parses here
16:55:56 <Saizan> Hadaka: with that signature the runner function is force to accept any Dist d, but you functions are tied to a particular instance, a solution is to move (Dist d) => out of the parentheses, and put it on the left
16:56:02 <FunctorSalad> (using ghci)
16:56:53 <Hadaka> Saizan: WHEE! I managed to do that myself! And by great scott, it works!!
16:58:07 <Hadaka> Saizan: and I think I now have a faint understanding why the earlier version didn't work and why this version now works
16:58:18 <hpaste>  Saizan annotated "(no title)" with "this loads in ghci for me" at http://hpaste.org/4674#a1
16:59:50 <FunctorSalad> Saizan: I'm probably getting something really basic wrong (my first multiline program ;))
17:00:00 <Hadaka> so thank you very much Saizan and others on this channel
17:01:54 <FunctorSalad> doh, I think I have to *do* something with the value returned by the until. I thought the interpreter would just output dangling expressions like that
17:02:14 <FunctorSalad> (like in octave or something)
17:02:31 <Saizan> Hadaka: well, for a start all type variables are implicitly universally quantified in haskell98, so show :: Show a => a -> String can be written as show :: forall a. Show a => a -> String, things becomes interesting when the forall is nested inside an argument of (->)
17:04:18 <FunctorSalad> it works :D thanks Saizan
17:05:08 <Saizan> FunctorSalad: ah, no, there's nothing like that, ghci just loads the code
17:07:52 <FunctorSalad> is there some idiom to do pointwise operations on functions? e.g. square = id * id
17:08:19 <FunctorSalad> (would be trivial to define but wondering whether this is in the standard library)
17:08:54 <EvilTerran> Control.Arrow has a bit of that
17:09:12 <Saizan> or the monad instance for (->) e
17:09:15 <ari> FunctorSalad: I'm not quite sure what you mean... what would be the type of square?
17:09:24 <allbery_b> @pl sq x = x * x
17:09:25 <lambdabot> sq = join (*)
17:09:25 <Saizan> square = join (*)
17:09:29 <allbery_b> what I thought
17:10:00 <FunctorSalad> ari: (Num a) => a -> a
17:10:02 <EvilTerran> i'm guessing he means square f = f.f; that or square f = (^2) . f
17:10:28 <EvilTerran> in the latter case, that's the sort of thing the (e ->) monad instance is for
17:10:31 <FunctorSalad> EvilTerran: not composition, pointwise multiplication
17:10:44 <FunctorSalad> as in (f*g)(x) = f(x)*g(x)
17:10:51 <FunctorSalad> with * being mult. of Nums
17:10:53 <EvilTerran> yeah, (e ->)
17:11:03 <EvilTerran> aka Control.Monad.Reader
17:11:09 <FunctorSalad> ah, thanks, I will look into that
17:11:22 <opqdonut> what's the difference between these:
17:11:24 <opqdonut> (Dist d) => (forall a. (Ord a,  Show a) => d a -> IO ()) -> x
17:11:42 <opqdonut> (Dist d, Ord a, Show a) => (d a -> IO ()) -> x
17:12:37 <EvilTerran> the latter's parameter can be more specific than (Ord a, Show a) => (d a -> IO ())
17:12:45 <EvilTerran> the former's must be at least that general
17:12:51 <Saizan> that in the first case the function argument is guaranteed to work with *any* Ord a, Show a => a
17:12:51 <EvilTerran> i think
17:13:44 <Saizan> i often see it in terms of who chooses 'a' in the former is the HOF, in the latter is the callback
17:14:48 <conal> FunctorSalad: ("is there some idiom to do pointwise operations on functions?") yes: applicative functor operations, e.g., liftA2 (*).  and much more generally than functions.
17:15:15 <opqdonut> ermmm
17:15:28 <opqdonut> could you explain this a little more concretely?
17:16:08 <Saizan> ok
17:16:28 <Saizan> ?type let g f = (f 'a',f (1 ::Int) in g
17:16:31 <lambdabot> parse error on input `in'
17:16:38 <EvilTerran> opqdonut, the former's parameter has to work *for all* a s.t. (Ord a,  Show a)
17:16:41 <Saizan> ?type let g f = (f 'a',f (1 ::Int)) in g
17:16:42 <lambdabot>     Couldn't match expected type `Int' against inferred type `Char'
17:16:42 <lambdabot>       Expected type: Int -> t
17:16:42 <lambdabot>       Inferred type: Char -> t1
17:16:54 <EvilTerran> the latter's could just work for one specific a
17:17:08 <opqdonut> ah yes
17:17:29 <Saizan> > let g :: (forall a. Show a => a -> b) -> (b,b); g f = (f 'a',f (1 ::Int)) in g show
17:17:30 <lambdabot>  Parse error at "." (column 19)
17:17:37 <Saizan> ?type let g :: (forall a. Show a => a -> b) -> (b,b); g f = (f 'a',f (1 ::Int)) in g show
17:17:38 <lambdabot> (String, String)
17:17:48 <opqdonut> thanks
17:17:52 <EvilSporkMan> so where's the tut that downloads the entirety of Prelude into my brain so I don't reinvent it every 5 seconds? (I'm doing H-99)
17:18:21 <EvilTerran> *eyebrow*
17:19:26 <EvilSporkMan> did you just read straight through the thing?
17:19:45 <EvilTerran> i keep the docs open in a firefox tab
17:20:03 <EvilTerran> whenever i need a function i suspect might be in the prelude (or some other stdlib module), i go have a look
17:20:10 <FunctorSalad> conal: sorry, total newbie to haskell. but in ct terms, I think what I want to do is lift the multiplication function *: R x R -> R to Hom(X,R)xHom(X,R) -> Hom(X,R) for some set X. I think that's essentially just applying the hom functor (X,·). probably has something to do with this liftA2? :)
17:20:15 <EvilTerran> after a while, i stopped having to look most of 'em up
17:21:02 <FunctorSalad> (well, Hom(X,*): Hom(X,R x R) -> Hom(X, R) and then you use the natural iso from Hom(X,R x R) to Hom(X,R) x Hom(X,R))
17:21:15 <Saizan> ?type liftA2 (*)
17:21:16 <lambdabot> forall a (f :: * -> *). (Num a, Applicative f) => f a -> f a -> f a
17:21:29 <Botje> FunctorSalad: your name is well chosen, but it made me hungry.
17:21:41 <FunctorSalad> Botje: :)
17:22:13 <EvilTerran> ?type liftM2 (*)
17:22:13 <lambdabot> forall a1 (m :: * -> *). (Num a1, Monad m) => m a1 -> m a1 -> m a1
17:22:33 <Saizan> Hom(X,·) is both a Monad and an Applicative, if i'm right thinking that it corresponds to ((->) x) in haskell types
17:22:46 <FunctorSalad> So I should probably learn the basics first before asking questions that lead into arrows :)
17:23:11 <EvilTerran> don't worry, this isn't arrows (yet); just monads and applicative functors ;)
17:24:18 <EvilTerran> the arrow-based solution would probably just be the kleisli arrows of the (e->) monad, anyway
17:24:24 <conal> and as applicative functor is simpler than arrow & monad
17:24:41 <EvilTerran> yeah, applicatives're EASY! ;D
17:24:51 <EvilSporkMan> is it really beneficial to try to write functions as folds?
17:25:24 <EvilTerran> EvilSporkMan, depending on the function. go for what's clearest.
17:25:51 <conal> EvilSporkMan: yes, when doing so eliminates some recursive boilerplate and reveals (more of) the essence.
17:30:20 <EvilSporkMan> for your amusement: isPalindrome (x:xs) = (x == last xs) && (isPalindrome $ reverse $ drop 1 $ reverse xs)
17:31:24 <FunctorSalad> thanks everyone for the pointers. I think I will look up what an Applicative is and/or how I use this (x ->) monad
17:31:47 <conal> FunctorSalad: enjoy!
17:32:08 <FunctorSalad> conal: yes, the connections to CT are quite interesting
17:32:29 <resiak> EvilSporkMan: isPalindrome "aba"
17:32:57 <durka> @let isPalindrome (x:xs) = (x == last xs) && (isPalindrome $ reverse $ drop 1 $ reverse xs)
17:33:00 <lambdabot> Defined.
17:33:07 <durka> > isPalindrome "aba"
17:33:08 <lambdabot>  Exception: Prelude.last: empty list
17:33:13 <EvilTerran> isPalindrome = (==) =<< reverse
17:33:25 <durka> @let isPalindrome [] = True
17:33:26 <lambdabot> Defined.
17:33:28 <durka> > isPalindrome "aba"
17:33:29 <lambdabot>  Exception: Prelude.last: empty list
17:33:33 <durka> bah
17:33:43 <FunctorSalad> not that using functors to write a sieve of Eratosthenes is slight mission creep or something ;)
17:33:48 <ari> :t ap (==) reverse
17:33:49 <lambdabot> forall a. (Eq [a]) => [a] -> Bool
17:34:05 <ari> > (ap (==) reverse) "aba"
17:34:05 <lambdabot>  True
17:34:07 <ari> > (ap (==) reverse) "abab"
17:34:07 <lambdabot>  False
17:34:08 <FunctorSalad> (but the point was learning haskell anyway)
17:34:12 <EvilTerran> > filter ((==) =<< reverse) (words "foo bar abcba quuxuuq blah eve")
17:34:13 <lambdabot>  ["abcba","quuxuuq","eve"]
17:34:16 <durka> @let isPalindrome [a] = True
17:34:17 <lambdabot> <local>:9:0:     Warning: Pattern match(es) are overlapped              In th...
17:34:22 <sw17ch> how does one go about learning how to use ghcprof
17:34:26 <EvilTerran> yeah, ap works as well as (=<<) here
17:34:52 <durka> @undefine
17:34:52 <lambdabot> Undefined.
17:34:57 <durka> @let isPalindrome (x:xs) = (x == last xs) && (isPalindrome $ reverse $ drop 1 $ reverse xs)
17:34:59 <lambdabot> Defined.
17:35:04 <durka> @let isPalindrome [x] = True
17:35:05 <lambdabot> <local>:1:0:     Warning: Pattern match(es) are overlapped              In th...
17:35:13 <EvilTerran> anyway, for the normal use of "palindrome", you want to disregard case and spaces
17:35:28 <durka> wait, what
17:35:32 <durka> oh
17:35:39 <durka> @let isPalindrome (x:[]) = True
17:35:40 <lambdabot> <local>:1:0:     Warning: Pattern match(es) are overlapped              In th...
17:35:43 <durka> nope
17:36:07 <EvilTerran> > ap (==) reverse . map toLower . filter isLetter $ "Doc, note I dissent. A fast never prevents a fatness. I diet on cod."
17:36:08 <lambdabot>  True
17:36:09 <Zao> durka: Your first x:xs catches everything the latter ones would.
17:36:17 <durka> oh
17:36:22 <durka> so i need to do the base case first
17:36:22 <EvilTerran> @undef
17:36:23 <lambdabot> Undefined.
17:36:27 <durka> @let isPalindrome (x:[]) = True
17:36:28 <lambdabot> Defined.
17:36:32 <durka> @let isPalindrome (x:xs) = (x == last xs) && (isPalindrome $ reverse $ drop 1 $ reverse xs)
17:36:32 <EvilTerran> you want views
17:36:33 <lambdabot> Defined.
17:36:43 <durka> > isPalindrome "aba"
17:36:43 <lambdabot>  True
17:36:47 <durka> > isPalindrome "abab"
17:36:47 <lambdabot>  False
17:36:55 <resiak> > isPalindrome ""
17:36:56 <lambdabot>  Exception: <local>:(1,0)-(2,85): Non-exhaustive patterns in function isPalin...
17:37:10 <EvilSporkMan> i dropped the base cases on purpose
17:37:10 <durka> @let isPalindrome [] = False
17:37:11 <lambdabot> Defined.
17:37:18 <durka> > isPalindrome ""
17:37:19 <lambdabot>  False
17:37:20 <EvilSporkMan> and isPalindrome [] = True ;)
17:37:22 <EvilTerran> isPalindrome (x0 : (reverse -> xN : xs)) = (x0 == xn) && isPalindrome xs; isPalindrome _ = True
17:37:32 <durka> well, what meaning does isPalindrome [] really have
17:37:38 <EvilTerran> > reverse [] == []
17:37:39 <lambdabot>  True
17:37:41 <EvilTerran> that's what
17:37:52 <EvilSporkMan> and there's a MUCH nicer implementation of isPalindrome, which I facepalmed after seeing
17:38:07 <EvilTerran> EvilSporkMan, what, (\xs -> xs == reverse xs) ?
17:38:14 <EvilSporkMan> EvilTerran: yeah exactly
17:38:29 <EvilSporkMan> this is what I get for doing too much C++
17:38:32 <EvilTerran> (or, as we like to call it, "ap (==) reverse" :P)
17:39:13 <EvilTerran> in this context, ap is the S combinator; it gives its first parameter the before-and-after of the application of its second parameter to its third
17:39:43 <conal> aka <*>
17:39:54 <EvilTerran> indeed. that's more general, even
17:39:58 <EvilTerran> ?type (<*>)
17:39:58 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
17:40:02 <EvilSporkMan> sigh, my head is exploding
17:40:10 <EvilTerran> here, "f" is (e ->)
17:40:29 <EvilTerran> > (<*>) :: (e -> a -> b) -> (e -> a) -> (e -> b)
17:40:30 <lambdabot>  Add a type signature
17:40:32 <EvilTerran> hm
17:40:34 <EvilSporkMan> i'll get back to you after i get in somewhere for graduate study in Programming Languages ;)
17:40:35 <EvilTerran> ?type (<*>) :: (e -> a -> b) -> (e -> a) -> (e -> b)
17:40:36 <lambdabot> forall e a b. (e -> a -> b) -> (e -> a) -> e -> b
17:40:58 * EvilTerran is not a graduate
17:41:16 * Botje will become one next year
17:41:40 * EvilTerran will still be an undergrad for the best part of three years
17:41:51 <EvilTerran> (four-year course, buu)
17:41:56 <EvilSporkMan> silly people with copious free time
17:42:57 <Botje> HAH
17:43:07 <Botje> copious it not a word I associate with free time :)
17:50:03 <nanothief> if you have a type data MyType ..... deriving (Show,Read), is read (show mytypeVar) == mytypeVar always going to be true?
17:50:30 <monochrom> Yes.
17:52:49 <nanothief> monochrom: that would have to be the most simple serialization technique i've ever seen
17:53:50 <monochrom> It is not very fast or compact.
17:54:40 <monochrom> But it's very simple. :)
17:54:56 <conal> nanothief: i think read.show==id only if the same is true for component types of MyType
17:59:33 <andyjgill> How do you solve the problem of  posting blog entries including code?
18:00:13 <conal> andyjgill: which blog engine?
18:00:20 <andyjgill> wordpress
18:00:25 <andyjgill> Hi Conal!
18:00:32 <conal> andyjgill: howdy!
18:00:57 <andyjgill> The editor is great for small hey, here is a couple of sentences, but not for including real ideas.
18:01:05 <andyjgill> What do you use?
18:01:21 <conal> andyjgill: i use blogger
18:01:33 <monochrom> I use HTML.
18:01:34 <conal> andyjgill: though not often.
18:01:40 <Japsu> erm, just wrote https://pajukanta.fi/blog/2007/12/28/minkaspituisilla-nikeilla-sita-oikein-irkataan/ (in finnish 'xcept for the C++, sorry) in the wp editor
18:01:42 <lambdabot> Title: Järkyttävää avautumista  Blog Archive  Minkäspituisilla nikeillä sitä o ..., http://tinyurl.com/2rec5y
18:02:02 <conal> andyjgill: if you have another way to generate html, you can copy&paste into wordpress.
18:02:32 <andyjgill> Someone must have solved the wordpress problem (I'm asking here because Haskell programers love sharing coding ideas!)
18:02:33 <conal> and there are scads of wp plugins.  perhaps there's one for code, with auto-coloring (if you care).
18:02:49 <Japsu> andyjgill: I pipe my code to php -R 'echo htmlentities($argn) . "\n";' and then include it in <blockquote><pre>
18:03:10 <Japsu> no colors, not automated, but works
18:03:12 <andyjgill> I do that right now, conal.. but its really hacking. As if I try *any* edits, the code layout disappears
18:03:25 <conal> andyjgill: urg :p
18:03:33 <andyjgill> exactly!
18:04:01 <conal> andyjgill: i mostly use tiddlywiki, with various plugins, including one for haskell code.
18:04:03 <andyjgill> Hence; this smells like a problem that someone else must have solved.
18:04:36 <andyjgill> Japsu: Your layout looks good.
18:04:50 <andyjgill> Japsu: and you uses wordpress
18:05:08 <Japsu> yeah, that's just the wp default theme, no hacks of my own
18:05:18 <shachaf> andyjgill: I don't know about how he posts, but edwardk seems to have something nice set up with Wordpress.
18:05:41 <andyjgill> shachaf: Have you a URL?
18:06:00 <shachaf> andyjgill: Possibly http://comonad.com/reader/2006/hello-world/?
18:06:03 <lambdabot> Title: The Comonad.Reader  Hello, World!
18:06:32 <andyjgill> That looks *really* good.
18:06:50 <andyjgill> And again, a wordpress blog.
18:07:13 <andyjgill> I'll fire off an email to edwardk. Thanks for the ideas!
18:39:49 <scodil> when you do +RTS -sstderr, what does the MUT stand for?
18:49:03 <conal> scodil: the "mutator", i.e., everything but the GC
18:49:14 <conal> GC-centric terminology
18:49:20 <scodil> ah ok. thanks
18:49:21 <conal> afaiu
18:49:36 <conal> especially weird for a functional programming language.
19:32:06 <tehgeekmeister_> after learning a decent amount of haskell, sicp doesn't have too much to teach me (at least half way thru the second chapter i haven't learned much.)
19:32:57 <ricky_clarkson> tehgeekmeister_: Then I presume writing a metacircular evaluator for Haskell is trivial for you.
19:33:28 <Philippa> ricky_clarkson: SICP teaches that?
19:33:32 <tehgeekmeister_> i did clarify that i only meant up to halfway thru the second part.
19:33:44 <Philippa> writing a metacirciular one for lisp is much easier though
19:33:57 <ricky_clarkson> Philippa: Yes.
19:34:11 <tehgeekmeister_> i'm not bragging -- i'm not an exceptional programmer by any means at all -- just saying i think haskell's taught me a lot of these things already.
19:34:18 <tehgeekmeister_> i left the chatroom?
19:34:20 <conal> any opengl users here?
19:34:27 <skew> it seems to get interesting around section 4
19:34:36 <ricky_clarkson> tehgeekmeister_: Well keep going.  Perhaps skip some parts.  There should be useful stuff in there.
19:34:53 <tehgeekmeister> i'm sure there will be, but at this point specifically it's really boring.
19:35:19 <ricky_clarkson> It is an intro to CS course.. if you're past that level some bits will be boring.
19:35:34 <ricky_clarkson> The videos might be better than the book for you.
19:37:19 <tehgeekmeister> perhaps.  the problem for me is that i know a smattering of cs, and so i really need to go thru all of it to pick up on all the details i've not learned anywhere else in my studies.
19:47:09 <Svrog> conal: yes
19:48:25 <Svrog> and i just saw your post on the yampa mailing list about half an hour ago - very interesting :)
19:48:33 <conal> :)
19:49:20 <conal> Svrog: i'm working on a new version of functional synthesis of continuous & infinite imagery, using opengl underneath, as well as the "reactive" lib.
19:49:39 <Svrog> oh cool
19:50:15 <conal> unlike my past implementations (Pan & Pajama), this one uses an infinite data representation for images.
19:50:20 <conal> Svrog: do you know whether there's a way to turn on double-buffering without using glut?
19:51:37 <Svrog> yes there is - but it comes down to either using something similar to glut or write a glut like lib yourself
19:52:11 <conal> Svrog: okay.  then i'll try to use glut.  i had trouble in the past.
19:52:23 <EvilTerran> i believe you can use gtk2hs in place of GLUT
19:52:23 <Svrog> i dont really like glut and of all the alternatives ive seen sdl seems the most mature
19:52:34 <EvilTerran> (when working in haskell, i mean)
19:52:35 <Svrog> glfw would be pretty good if it wasnt for some limitations
19:52:51 <conal> i'm using wxHaskell for the gui.  all i want from glut is double-buffering
19:52:57 <Svrog> for my stuff i avoided glut and even the haskell opengl libs and wrote my own wrappers
19:53:15 <EvilTerran> just a double-buffer shouldn't be too hard to do manually...
19:53:35 <EvilTerran> ...unless i'm confused and the functionality's present but un-bound in openGL proper
19:54:16 <Svrog> conal: if you run into problems i'd be glad to help out, whether you're using glut or whether you decide to take a different route
19:54:16 <conal> i don't know what opengl functionality to use to implement double-buffering.
19:54:43 <conal> Svrog: thanks much!
19:58:25 <Svrog> conal: before using glut, it might be a good idea to look at sdl - there are haskell bindings for it even though im not sure what state they're in
19:58:33 <Svrog> also wxwidgets can be compiled with sdl support
19:59:01 <Svrog> but im not sure whether that helps or not - i havent really used wxhaskell
19:59:47 <Svrog> so im not sure how much of wx functionality it exposes
20:01:09 <conal> Svrog: thanks.  i'll check out sdl first.
20:03:06 <Svrog> http://sourceforge.net/projects/hsdl/
20:03:39 <thetallguy> conal: I have some Haskell code that does opengl double buffering
20:04:05 <conal> thetallguy: please send it my way
20:05:17 <thetallguy> conal: in progress.  Will take a few minutes
20:05:25 <conal> thetallguy: thx.
20:08:05 <Svrog> http://www.libsdl.org/cgi/docwiki.cgi/SDL_5fSetVideoMode
20:08:06 <lambdabot> Title: SDL_SetVideoMode - SDL Documentation Wiki
20:08:17 <Svrog> SDL_DOUBLEBUF
20:11:07 <Svrog> oops - that flag is for programs that dont use opengl heh
20:11:14 <Svrog> it's been a while since ive used sdl..
20:11:56 <Svrog> http://www.libsdl.org/cgi/docwiki.cgi/SDL_5fGL_5fSetAttribute
20:11:57 <lambdabot> Title: SDL_GL_SetAttribute - SDL Documentation Wiki
20:13:20 <tehgeekmeister> is there some more accepted way of manipulating nested lists than mapping maps (or mapping maps over maps)?
20:13:47 <tehgeekmeister> it's really hard to think about anything like map (map (map...
20:15:28 <Mitt4Prez> http://digg.com/2008_us_elections/Mike_Huckabee_If_you_vote_for_me_you_live_if_you_don_t
20:15:34 <Mitt4Prez> Look at Mike Huckabee's psychotic comments.
20:15:36 <Mitt4Prez> Vote Mitt Romney 2008.  He is a tech savvy candidate that will put the US back on track economically and help us win in Iraq and defend our borders.
20:16:21 <tehgeekmeister> irc campaigning?
20:16:39 <loupgaroublond> is that even legal?
20:17:04 <Randroid> No way. Anyway, it's Ron Paul for me.
20:17:12 <Randroid> But let's talk about Haskell.
20:17:27 <tehgeekmeister> Randroid: i agree.  but yes, haskell.
20:17:30 <loupgaroublond> well, if haskell were running in the green party, i would vote for that
20:17:37 <Randroid> loupgaroublond: lol
20:18:02 * tehgeekmeister realizes that nested maps are the next topic in sicp
20:19:08 <mxcantor> what are the rules on banning political spambots?
20:20:18 <Svrog> they get banned but they come back with a different name
20:20:22 <loupgaroublond> off topic, i think a ban is in order, and asking freenode ops to kline it if more people ask
20:21:40 <thetallguy> conal: check your inbox
20:21:59 <Svrog> i kinda wonder if the intention really is to get people to vote for someone to get them not to vote? surely whoever's behind it must know how annoying it is and that it might damage the image of whoever they're supposedly promoting
20:22:30 <thetallguy> my former CEO is campaining for Romney
20:22:38 <thetallguy> I wonder if it was him
20:25:42 <sw17ch> I heard Ron Paul loves Haskell
20:26:31 <sw17ch> no but really, i can't escape all the campaign talk on the internet... please lets stop now
20:26:35 <sw17ch> :)
20:27:04 <skew> Anybody else have an XO?
20:27:33 <Randroid> Ron Paul may love Haskell, but we all know Al Gore invented it.
20:28:30 <loupgaroublond> i think i just found that moment where haskell made 15 times more sense than any other language
20:28:40 <durka> do tell
20:28:44 <skew> I've got mine running Hugs.
20:28:47 <durka> oh, i thought you meant a code example
20:28:49 <durka> cool
20:29:34 <loupgaroublond> durka, turning a monadic expression into a function that takes a file handle and returns a monadic expression
20:29:47 <shachaf> skew: cjb ran xmonad on the XO.
20:30:16 <skew> shachaf: did he make instructions?
20:30:25 <loupgaroublond> did he get sugar to work inside xmonad?
20:30:38 <shachaf> skew: I don't think so. :-)
20:30:43 <shachaf> skew: But it can't be that hard.
20:30:47 <sw17ch> does any one have both an Asus EEE and an XO?
20:30:57 <sw17ch> or have used both?
20:31:06 <loupgaroublond> that's asking for quite a bit of awesomeness out of just one person
20:31:14 <sw17ch> this is #haskell
20:31:21 <skew> sw17ch: my girlfriend just got an EEE.
20:31:34 <sw17ch> see, skew here has it all... :)
20:31:57 <sw17ch> how does she like it?
20:32:01 <sw17ch> err... how do you like it?
20:32:33 <skew> sw17ch: seems also pretty nice, that's more of a standard linux with lots of nice programs installed
20:32:57 <skew> sw17ch: while the XO is very cute and has neat things like logo and a camera, but it's just rpms and stuff underneath
20:33:03 <sw17ch> hmmm...
20:33:18 <sw17ch> well, my wife informed me she'd let me buy a laptop if i take a job when I graduate instead of going to grad school :)
20:33:46 <skew> sw17ch: but if you go to grad school you could still afford one of the little ones?
20:33:56 <sw17ch> well, see that's the thing :)
20:34:20 * cjb runs xmonad on his XO.  :)
20:34:36 <skew> cjb: how did you set that up?
20:34:49 <sw17ch> Grad School with sweet laptop, or Job with other sweet lap top... hmmm
20:34:57 <cjb> skew: by copying the xmonad binary over from a Fedora 7 box.  The XO is just x86/F7.
20:35:28 <shachaf> cjb: Runs or ran? Are you still using it?
20:35:32 <loupgaroublond> skew: i have xmonad rpms that may or may not compile on F7
20:35:37 <mxcantor> Randroid: Ron Paul may love Haskell, but we all know Al Gore invented it <- ask Vint Cerf or any of the other 'fathers of the internet' - al gore contributed more to the development and opening of the internet than any other politician
20:35:50 <mxcantor> i'm sick of hearing about that comment
20:36:01 * mxcantor cowers back into his newbie hole
20:36:31 <loupgaroublond> mxcantor: it's a politician's job to take credit for what he/she gets other people to do (but this belongs in #haskell-blah
20:36:41 <mxcantor> noted
20:36:45 <mxcantor> sry
20:37:42 <loupgaroublond> you can just continue there :)
20:37:50 <mxcantor> by the way, is anyone here familiar with compiling ghc 6.8.x on os x 10.5 ppc?
20:37:56 <cjb> shachaf: I still use it sometimes, but have mostly switched to Sugar.
20:38:05 <Randroid> mxcantor: I'm aware of Gore's contributions (The Gore Bill, Electronic Bill of Rights, etc.). The comment was meant to be amusing.
20:38:07 <cjb> (which is a lot more usable now than it was six months or so ago.)
20:38:23 <cjb> (which is when I got xmonad going.)
20:38:38 <shachaf> cjb: Xmonad's gottena lot more usable too. :-)
20:38:44 <loupgaroublond> cjb: would it be feasible to run sugar inside of xmonad instead of matchbox or whatever the WM is called?
20:39:21 <cjb> loupgaroublond: wow, there's an idea.
20:39:37 <cjb> I don't think sugar would scale well at the point you opened up a new xmonad frame.
20:40:26 <cjb> sugar also relies on new windows going on top of old ones, it's a full-screen environment.
20:40:44 <cjb> but when that happened under xmonad, I think the sugar "home" screen would stay open in one a frame, and you'd get a new frame with just your new activity in.
20:40:53 <skew> cjb: Are you working on the project?
20:41:06 <loupgaroublond> cjb, that depends on the Layout you use, there are full screen layouts
20:41:08 <cjb> skew: Yes, I work for OLPC, have been for over a year now.
20:41:11 <Svrog> mxc: what problems are you having with compiling ghc on 10.5?
20:41:17 <cjb> loupgaroublond: That's true.
20:41:43 <loupgaroublond> although i know you OLPC junkies love python, it might be interesting to script out WM events from the OLPC in haskell
20:42:08 <cjb> loupgaroublond: Hm, not sure what you mean by that.  Go on?
20:42:10 <mxc> linker seg fault
20:42:48 <cjb> loupgaroublond: Quite a few of us like Haskell too -- e.g. m_stone also works for OLPC.  But python is a better language for young kids to start with.
20:42:56 <skew> cjb: cool, so is sugar just sluggish from the graphics, or is Python performance an issue?
20:43:09 <sw17ch> cjb: why python over ruby?
20:43:33 <skew> because ruby has more syntax, and is yet slower?
20:44:16 <cjb> skew: performance is an issue, mainly memory-wise.  At the moment we're running a python interpreter per activity, which means we duplicate all the libraries we're using in memory and have to reinitialize them every time something new starts up.
20:44:20 <loupgaroublond> sw17ch: millions of reasons, python has fewer 'symbols' over alphabetic syntax, because python doesn't force you into certain concepts the way ruby does, python boasts of a single way to do things which is ultimately better in an educational environment where programming is secondary to what's being taught
20:44:29 <bos> @seen dcoutts
20:44:29 <lambdabot> dcoutts is in #gentoo-haskell, #haskell, #ghc and #haskell-overflow. I last heard dcoutts speak 3h 54m 53s ago.
20:44:31 <bos> @seen dcoutts_
20:44:32 <lambdabot> I saw dcoutts_ leaving #ghc, #gentoo-haskell and #haskell 5h 40m 51s ago, and .
20:44:36 <Randroid> I prefer Ruby strongly over Python, but that's neither here nor there.
20:44:47 <cjb> I'd like us to move towards at least forking new interpreters from a master interpreter, and ideally it would be kinda neat to just use one interpreter period, in the style of a lisp machine.
20:45:03 <cjb> loupgaroublond: Thanks, you explained it better than I could.
20:45:17 <cjb> "Python looks more like BASIC than Ruby does" is an eminently sensible reason, too.  :)
20:45:40 <bos> @seen dons
20:45:40 <lambdabot> dons is in #ghc, #xmonad and #haskell. I last heard dons speak 1d 5h 24m 10s ago.
20:46:09 <loupgaroublond> i didn't want to say it that way, i think the only reason why they would have chosen basic is for its syntax, not because it's basic
20:46:17 <cjb> Right.
20:46:34 <cjb> For the feeling of "hey, I feel like I'm just writing English pseudocode, yet it seems to run fine".
20:46:41 <loupgaroublond> besides, i'm a python junkie too, why compare one of my favorite languages to BASIC?
20:46:45 <cjb> :)
20:47:40 <bos> cjb: nice hostname :-)
20:47:42 <Randroid> BASIC has to be the second ugliest common programming language ever invented, after COBOL.
20:47:55 <cjb> bos: thanks :) there's also pedal, crank, etc.
20:47:57 <Randroid> (There are some uncommon ones that are uglier.)
20:49:01 <shachaf> cjb: How about Inform 7, then? :-)
20:49:04 * bos tries to remember how to get cabal going with autostools
20:49:11 <loupgaroublond> Randroid: Glib in C, Java, mixing javascript, jsp, and xhtml....
20:49:33 <loupgaroublond> bos, have you tried out my patchs btw?
20:50:15 <bos> loupgaroublond: yeah, applied them. haven't really looked at the consequences. one package that i never tried to build before doesn't build now, but that's not exactly a data point :-)
20:52:01 <loupgaroublond> bos, well i've been getting a strange error out of some packages, and i had some overall issues for which i don't have a trivial solution, plus a few comments about naming packages
20:52:03 <bos> loupgaroublond: your changes are in my darcs repo now
20:52:13 <loupgaroublond> awesome, i got your email about that :)
20:52:40 <sw17ch> loupgaroublond: huh, thanks. I guess i don't know a lot of python... i really should learn it... all the Aerospace people i do stuff for love python
20:52:43 <bos> loupgaroublond: i'm building stuff with ghc 6.8.2, and i am suspicious of the builtin-package-filter-thingy
20:52:53 <sw17ch> no one seems to buy my haskell preaching
20:53:30 <loupgaroublond> bos, which filter thingy?
20:53:39 <bos> python and haskell have comparable power to weight ratios in many instances
20:54:05 <bos> loupgaroublond: the code that decides whether a library is built into the ghc package or needs a dependency generated
20:54:15 <explicitjelly> I tell you. writing compilers is SO MUCH LESS WORK in haskell than in java
20:54:22 <explicitjelly> visitor pattern *everywhere*
20:54:30 <loupgaroublond> bos, oh yeah, i had a few comments about that too :)
20:54:31 <bos> explicitjelly: the same is true of almost everything.
20:54:45 <loupgaroublond> bos, any chance you're going to FudCon?
20:54:48 <bos> loupgaroublond: you may have noticed i wrote a tool to automate the scraping
20:54:51 <sw17ch> does any one know for sure whether or not the '#' character is legal in clisp atom names?
20:55:01 <loupgaroublond> bos, i haven't seen that tool
20:55:06 <bos> loupgaroublond: not unless redhat randomly decides to buy me a ticket and give me a hotel room
20:55:11 <durka> FudCon? fear, uncertainty, & doubt convention?
20:55:11 <bos> loupgaroublond: it's in tools/
20:55:17 * cjb knows quite a bit of python and not a lot of Haskell and would like to learn more Haskell but doesn't really have any problems that need it.
20:55:25 <explicitjelly> bos, yes, maybe, but with compilers (and/or interpreters) i have direct comparision
20:55:47 <bos> cjb: just use it for normal scripting stuff. works nicely as a learning vehicle.
20:55:57 <sw17ch> cjb: if you're anything like me... you don't realize all the problems you have that need it :)
20:56:27 <loupgaroublond> bos, damn, i was hoping i could sit down with some people who know haskell and write up guidelines, i guess i'll put something on the wiki
20:56:44 <loupgaroublond> cjb, just go out and make some problems ;)
20:56:45 <bos> loupgaroublond: we've been talking about getting a SIG going
20:57:00 <loupgaroublond> bos, i saw, my name is on that wiki page
20:57:13 <bos> loupgaroublond: but the only active fedora developers who care are you and me
20:58:13 <loupgaroublond> bos, if there's one thing i learnt working with fedora people, when no one cares, the people who bother make the decisions, but then you have to get them approved by everyone who all of a sudden cares, and has to start a flame war :P
20:59:01 <ac> hum. What's a higher order function that takes "hGetLine handle" and returns a list of strings?
20:59:21 <bos> loupgaroublond: yeah
20:59:39 <ari> :t hGetLine
20:59:41 <lambdabot> Not in scope: `hGetLine'
20:59:49 <bos> ac: you want to call hGetLine repeatedly?
20:59:54 <ac> bos: exactly
20:59:59 <loupgaroublond> bos, i feel like being verbose tonight, let me see if i can get something typed up
21:00:22 <ac> bos: I've used the function before, but forgot the name
21:01:00 <bos> hmm.
21:01:08 <ac> replicateM, or somethnig?
21:01:12 <bos> @hoogle (Monad m) => m a -> [m a]
21:01:13 <lambdabot> Prelude.repeat :: a -> [a]
21:01:13 <lambdabot> Data.List.repeat :: a -> [a]
21:01:13 <lambdabot> Prelude.iterate :: (a -> a) -> a -> [a]
21:01:38 <bos> replicateM takes a count
21:01:54 <bos> you really want something like sequence . repeat
21:02:16 <bos> at least if you want an infinite list of lines
21:02:40 <bos> ac: but what is it you're really trying to do?
21:02:44 <ac> bos: I was thinking to "takeWhile (not . isEOF)"
21:03:14 <ac> bos: @foo = <FILE>
21:03:20 <bos> ac: won't work. isEOF is monadic.
21:03:34 <bos> ac: lines `liftM` hGetContents handle
21:03:44 <bos> ac: just beware that it's lazy.
21:03:52 <cjb> sw17ch: I don't doubt it.  :)
21:04:01 <bos> you have to consume all of the lines before you close the handle, or you'll get a crash.
21:04:17 <ac> bos: hm. ultimately I'm building a Data.Map by inserting each line as a key
21:04:24 <bos> ac: ah.
21:05:00 <bos> ac: then use the line i gave you, and build the map using foldl'
21:05:17 <ac> right. why should I beware of laziness?
21:05:41 <bos> ac: because hGetContents doesn't read the file; it promises to read the file when you need the data.
21:06:07 <ac> bos: would that be a problem if I randomly query the map later?
21:06:09 <explicitjelly> you know what is a GREAT tool?
21:06:11 <bos> so if you make yourself a promise like that, then close the file handle, it can't fulfil the promise, and the runtime will be sad.
21:06:12 <explicitjelly> graphviz
21:06:27 <explicitjelly> it's so easy to generate the source
21:06:38 <bos> ac: if you force the evaluation of the map before closing the handle, you'll be fine.
21:06:55 <explicitjelly> and graphviz does the rest of rendering it as a pretty useful directed or undirected graph
21:07:07 <explicitjelly> example: http://www.frodoid.org/stuff/intmtree.png
21:11:50 <wy> ... spent a whole afternoon figuring out why foldr works...
21:12:33 <bos> wy: great idea.
21:13:47 * sjanssen <3 foldr
21:13:50 <wy> It seems that it works for infinite list just because list is defined to recurse on the tail
21:14:15 <ac> what has a type of "(a -> b -> c -> d) -> (b -> c -> a -> d)"?
21:14:35 <ac> anotherwords a function that rots the agruments of a 3 arg function
21:14:36 <sjanssen> @djinn (a -> b -> c -> d) -> (b -> c -> a -> d)
21:14:36 <lambdabot> f a b c d = a d b c
21:14:48 <wy> sjanssen: What's djinn?
21:14:48 <sjanssen> @. pl djinn (a -> b -> c -> d) -> (b -> c -> a -> d)
21:14:49 <lambdabot> f = (flip .) . flip
21:15:25 <ac> hah. more readable to just say (\b c a -> foo a b c)
21:15:35 <sjanssen> wy: given a type (a theorem) it generates a function (a proof)
21:16:10 <ac> I was hoping something like "rot3" was in the prelude
21:16:21 <wy> sjanssen: That's great
21:16:28 <sjanssen> wy: yeah, it's really cool
21:16:37 <wy> sjanssen: How is it implemented?
21:17:04 <sjanssen> wy: I don't know the details, you might ask augustss
21:19:12 <sjanssen> @djinn Either (a, b) (a, c) -> (a, Either b c)
21:19:12 <lambdabot> f a =
21:19:12 <lambdabot>     case a of
21:19:12 <lambdabot>     Left (b, c) -> (b, Left c)
21:19:12 <lambdabot>     Right (d, e) -> (d, Right e)
21:19:58 <sjanssen> that's a proof that (a&&b) || (a&&c) implies a && (b||c)
21:21:03 <wy> Just a little idea about foldr: to convert a function myfunc that recurse on lists, one just need to figure out the appropriate function to put on the node, such that x and (myfunc xs) can be connected to express myfunc (x:xs). I wonder where can I look up this idea instead of think up it myself.
21:21:41 <sjanssen> wy: I've read this in a paper, "On the something something of fold"
21:21:54 <skew> wy: http://web.comlab.ox.ac.uk/oucl/work/jeremy.gibbons/publications/
21:21:55 <lambdabot> Title: Jeremy Gibbons' Publications
21:23:06 <skew> wy: "When is a function a fold or an unfold?"
21:23:18 <sjanssen> @google a tutorial on the universality and expressiveness of fold
21:23:20 <lambdabot> http://www.cs.nott.ac.uk/~gmh/fold.pdf
21:24:02 <wy> thanks =)
21:27:09 <wy> sjanssen: Is this called automatic programming? hehe
21:27:45 <wy> skew: Thanks! He wrote so many papers on fold and unfold!
21:28:31 <cjb> Ooh, here's a topic:  I know elementary Haskell, but haven't read any academic papers on Haskell/fp.  Which paper would be the awesomest to start with, given a long plane ride or two in the next few days?
21:28:59 <skew> cjb: have you read "Why functional programming matters"?
21:29:21 <cjb> Nope!  At least, I don't remember doing so.
21:29:30 * cjb googles.
21:29:50 <skew> that's good one, John Hughes explaining why lazy evaluation is cool
21:29:59 <wy> skew: Can you give me a starting point?
21:30:18 <skew> wy: I think sjanssen suggested a good one
21:31:21 <bos> sjanssen: used cabal much?
21:31:25 <wy> skew: thanks! Maybe Dexter will also know something about it. He put these on blackboard and it didn't make sense to me until today ;-)
21:31:27 <sjanssen> bos: a bit
21:32:00 <bos> sjanssen: don't suppose you've ever tried to change the linker used?
21:33:14 <sjanssen> bos: nope
21:33:21 <bos> oh well :-)
21:36:32 <wy> sjanssen: That's a good introduction. Thanks
21:38:08 <ac> @hoogle Char -> Int
21:38:09 <lambdabot> Data.Char.digitToInt :: Char -> Int
21:38:09 <lambdabot> Data.Char.ord :: Char -> Int
21:38:09 <lambdabot> Data.ByteString.Char8.count :: Char -> ByteString -> Int
21:40:33 <ac> @hoogle Int -> Char
21:40:34 <lambdabot> Data.Char.intToDigit :: Int -> Char
21:40:34 <lambdabot> Data.Char.chr :: Int -> Char
21:40:34 <lambdabot> Data.PackedString.indexPS :: PackedString -> Int -> Char
21:40:42 <wy> It seems denotational semantics make much more sense in haskell than other languages. Is it because of the laziness?
21:45:27 <ac> hm. How to add branches to a tree?
21:45:44 <ac> (that's a rhetorical question I suppose)
21:46:28 <wy> ac: really ;-)
21:46:49 <wy> ac: paste it on ;-)
21:48:24 <ac> wy: with duct tape??
21:48:59 <wy> ac: It's not a leaf
21:49:59 <wy> so you connect it to another branch I think
21:52:31 <ac> screw Haskell!!! It takes too much thought to write
21:53:47 <byorgey> ac: so you'd rather spend that time & thought debugging instead? ;-)
21:54:08 <skew> ac: what are you thinking about?
21:54:13 <Svrog> hehe
21:55:09 <wy> ac: screw it!!!
21:55:36 <wy> ac: and you'll come back again and again ;-)
21:56:18 * bos wonders why LLVM has such weird linking conventions
21:56:45 <skew> bos: what's weird about it?
21:56:52 <wy> ac: Can you describe your questions more precisely?
21:57:25 <bos> skew: it installs some plain object files (.o) to /usr/lib, so you have to specify the entire path to one instead of just -lfoo
21:57:47 <ac> wy: I don't have any question
21:58:27 <ac> wy: I'm just fooling around. Answering the question is the goal here, not writing code
21:58:56 <ac> wy: Er, I mean writing the code is the goal, not having working code
21:59:27 <Svrog> whats the point in writing code that doesnt work?
22:02:59 <ac> Svrog: well, it can be interesting. But I intend to end up with working code. But the goal is the thought process required to write it, not to paste code from #haskell
22:06:45 <wy> gosh, I can't find one book of Richard Bird in my library!
22:09:28 <ac> wy: if you're really curious I'll hpaste the code when I'm done
22:17:36 <mhiku> anyone want to have homebased php web dev pm me :)
22:17:58 <ari> ...
22:18:13 --- mode: ChanServ set +o bos
22:18:36 --- kick: mhiku was kicked by bos (bos)
22:18:59 --- mode: bos set -o bos
22:19:08 <ari> An internet cafe in the Philippines. What an interesting place to advertise from.
22:19:39 <byorgey> hey, I thought he said he was homebased.
22:19:46 <byorgey> and to think that I trusted him.
22:21:25 <ari> Heh, well, I actually just interpreted "INTERNET CAF" by adding a letter to it, so I could be wrong... but I don't see how he could be working from an internet constant applicative form :(
22:21:48 <byorgey> haha
22:22:51 <allbery_b> he waas an internet CAF, then he got gc-d
22:23:41 <wy> anyone want to try some online collaborative mind-mapping and brain storming software with me?
22:30:10 <loupgaroublond> bos: http://fedoraproject.org/wiki/Features/GoodHaskellSupport https://fedoraproject.org/wiki/PackagingDrafts/Haskell
22:30:11 <lambdabot> Title: Features/GoodHaskellSupport - Fedora Project Wiki
22:37:59 <yoshi> Hi all. I need some help in developing a special version of the show function. The function must take a Double, n, and: if n is a whole number then show n as an Integer; otherwise show n as a Double (ex: specialshow 2.0 = 2 and specialshow 3.42 = 3.42). Does anyone have any segestions as to how I can make this work?
22:38:29 <skew> just like you said
22:39:07 <skew> you can use (fromIntegral . round) in checking if n is a whole number
22:39:08 <yoshi> skew: specialshow :: Double -> Either Integer Double?
22:39:51 <skew> then either show show?
22:40:41 <yoshi> skew: ok I'll experiment with that a little. Thanks
22:41:00 <byorgey> yoshi: essentially, I would think you want to check whether the Double value is within some "epsilon" of a whole number.  if so, round it to an Integer; if not, don't.
22:45:05 <wy> @src foldr
22:45:06 <lambdabot> foldr k z xs = go xs
22:45:06 <lambdabot>     where go []     = z
22:45:06 <lambdabot>           go (y:ys) = y `k` go ys
22:46:09 <wy> Is ghc clever enough to transform foldr f z (x:xs) = f x (foldr f z xs) into this definition?
22:46:58 <wy> I guess this is also a kind of "premature optimization"?
22:47:08 <skew> wy: try and see, with -ddump-simpl
22:47:19 <wy> skew: Thanks
22:48:30 <sjanssen> wy: it isn't necessarily "premature" -- foldr is very important in GHC and it needs to be fast
22:49:04 <wy> sjanssen: I'm just trying to find out if this transformation can be done automatically
22:49:16 <skew> wy: looks like no, and remember to use -O2 if you want to see how it compiles with optimizations
22:50:04 <quicksilver> ghc doesn't unroll much
22:50:20 <quicksilver> possibly never, with standard options?
22:51:24 <sjanssen> this isn't unrolling, it's worker/wrapper
22:52:20 <skew> which may only be triggered with constructors
22:53:42 <skew> it still doesn't split out a local definition
22:53:58 <quicksilver> sjanssen: I think wy is talking about unrolling.
22:54:09 <quicksilver> oh
22:54:11 <quicksilver> maybe not!
22:54:13 <quicksilver> I misread him :)
22:54:32 <skew> but I'm not sure it would actually be faster to get the invariant arguments from a closure than arguments, if they pass in registers
22:54:44 <quicksilver> wy: no, ghc is not clever enough to derive that definition, that's why it is written that way.
22:55:24 <wy> quicksilver: I just meant that k and z is not changed during the recusion, so they can be encapsuled
22:55:48 <sjanssen> skew: GHC can't inline/specialize recursive functions, so they use this worker/wrapper trick
22:56:29 <quicksilver> wy: yes, well there is a sense in which GHC knows not to waste time passing unchanged values
22:56:37 <quicksilver> it can just pass existing stack offsets, IIRC
22:57:02 <quicksilver> but the details of STG parameter passing are rather different from, e.g., standard C stack discipline
22:57:10 <quicksilver> and I generally forget the details! :)
22:57:58 <wy> quicksilver: It seems that it's not very hard to know that k and z are not changed
22:59:31 <wy> The outputted core code seems to be quite straight forward translation. Might there be other optimizations after this stage?
22:59:54 <skew> not much
22:59:59 <hpaste>  Yoshi pasted "Special Show Function" at http://hpaste.org/4675
23:00:05 <skew> -ddump-stg shows the next stage
23:01:16 <shachaf> yoshi: You probably want «Left $ show ...» instead of «show $ Left ...».
23:01:48 <shachaf> yoshi: show always returns a String -- in this case, it would return "Left ...".
23:02:05 <quicksilver> wy: core doesn't tell you much about how parameters are actually passed :) Core is still a rather declarative language. It's pretty much desugared haskell.
23:03:14 <wy> quicksilver: right. I've read parts of SPJ's book and it's rather straight forward translation
23:03:37 <skew> I think stg is just a simple translation from core that makes it clear which lambdas turn into local jump targets and that sort of thing
23:03:41 <wy> alright. It doesn't matter at this stage of mine ;-)
23:03:50 <skew> with -ddump-asm or -ddump-cmm you could actually see how parameters are passed
23:03:53 <wy> What's STG by the way?
23:04:17 <skew> I'm not sure why that is the name of the intermediate language
23:04:29 <allbery_b> 'spineless tagless G-machine'
23:04:40 <ari> That's what it stands for, although AFAIK it's not quite tagless anymore :)
23:04:47 <allbery_b> (which is neither these days, but the STG name sticks for historical reasons)
23:04:56 <ari> Ooh
23:05:03 <ari> Spineful Tagful G-machine?
23:05:16 <allbery_b> if you google for that phrase you should find the paper where it's discussed
23:05:27 <allbery_b> (minus recent updates)
23:05:28 <yoshi> shachaf: success! thank you
23:05:40 <wy> allbery_b: any good introductions to this thing? I'm quite interested in compilers
23:05:47 <skew> yeah, but I'm not sure what that has to do with the intermediate language
23:06:03 <allbery_b> @go spineless tagless g-machine
23:06:04 <lambdabot> http://citeseer.ist.psu.edu/peytonjones92implementing.html
23:06:05 <lambdabot> Title: Implementing lazy functional languages on stock hardware: the Spineless Tagless  ...
23:06:22 <allbery_b> that should be a decent introduction to it
23:06:37 <ari> skew: The STG language is the language for the STG machine?
23:07:07 <allbery_b> language optimized for it
23:09:03 <wy> Thanks
23:09:47 <allbery_b> (more accurately, not a different language at all, just haskell core optimized for the STG)
23:10:15 * dufflebunk realizes he needs to get the extralibs when building the latest ghc
23:12:10 <lQg> how would i split a [String] into a [[String]] after certain String ?
23:12:13 <dufflebunk> That would explain why I can't build this stuff suddenly.
23:13:41 <lQg> so if i have ["a",".","gi","1qf","1qf1q","111","gi"] turn into  [["a",".","gi"],["1qf","1qf1q","111","gi"]]
23:13:44 <dufflebunk> lQg: STring, or ByteString?
23:13:56 <dufflebunk> Oh
23:14:30 <dufflebunk> I'd do it with foldl
23:14:47 <lQg> how?
23:16:13 <dufflebunk> or something using List.span
23:16:24 <lQg> they all start with "lQ" if that makes it easier then parsing at ending "gi"
23:17:23 <wy> Is there a way to put the code region of bird-style lhs back into comments?
23:18:22 <oerjan> > let undelim d xss@(x:xs) | d == x = [x]:yss | otherwise = (x:y):ys where yss@(y:ys) = undelim d xs in undelim "gi" ["a",".","gi","1qf","1qf1q","111","gi"]
23:18:22 <lQg> vim block selection mode prepend -- to lines you want to comment out
23:18:26 <lambdabot>   Non-exhaustive patterns in function undelim
23:18:34 <oerjan> bah
23:18:48 <dufflebunk> f [] = [] ; f l = fst (span (\ a -> a == "gi")) : (f (snd (span (\ a -> a == "gi"))))
23:19:05 <dufflebunk> lQg: Something like that... although I'm sure there's a prettier way
23:19:22 <lQg> hmmm
23:19:31 <oerjan> oh wait that _really_ has trouble at the end
23:20:56 <oerjan> oh wait it should keep it at the _end_? that's my groupBy trick from the other day
23:21:34 <oerjan> or not.
23:22:43 <oerjan> gah, it is much harder to keep the delimiter at the end than at the beginning
23:22:49 <wy> It seems Bird style is better for everyday use than TeX
23:23:55 <lQg> dufflebunk: span takes two arguments
23:24:25 <oerjan> fst (span is takeWhile and snd (span is dropWhile
23:24:28 <lQg> wy: TeX is so you can write your PhD simultaneously
23:24:42 <lQg> ;)
23:24:58 <dufflebunk> lQg: Right, the second argument is the list, l
23:25:06 <wy> lQg: hmmm I'm far from that
23:28:00 <icarroll> @quote either
23:28:01 <lambdabot> qwe1234 says: what you linked to is neither formal nor a notion.
23:28:08 <wy> TeX is so cluttering the code...
23:28:15 <icarroll> @quote either
23:28:15 <lambdabot> Korollary says: And Haskell is not all that great, either.
23:29:07 <wy> But I hope there is some simple mark-ups in bird style. For sections etc...
23:29:24 <oerjan> > let undelim d l = case span (/= d) l of (t,[]) -> [t]; (t,d:ds) -> (t++d):undelim d ds in undelim "gi" ["a",".","gi","1qf","1qf1q","111","gi"]
23:29:28 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
23:29:29 <lambdabot>       Expected...
23:29:32 <oerjan> ouch
23:29:37 <dufflebunk> wy: Put HTML in there
23:29:41 <oerjan> > let undelim d l = case span (/= d) l of (t,[]) -> [t]; (t,d:ds) -> (t++[d]):undelim d ds in undelim "gi" ["a",".","gi","1qf","1qf1q","111","gi"]
23:29:44 <lambdabot>  [["a",".","gi"],["1qf","1qf1q","111","gi"],[]]
23:30:07 <oerjan> gah, i still kept that final []
23:31:15 <wy> dufflebunk: That's another kind of clutter... My goal is just to write some documentation for myself to read together with the code. Maybe I can just put "*" and "**" in front...
23:33:26 <EvilSporkMan> what's teh traditional way to print something returned by an IO action at the interpreter? doIt >>= show doesn't work because show doesn't go back into the monad
23:34:09 <skew> ghci prints it if you have a recent version
23:34:14 <EvilSporkMan> apparently doIt >>= putStrLn . show works
23:34:28 <EvilSporkMan> I'm using WinHugs (the Win is under protest)
23:34:28 <skew> print = putStrLn . show
23:35:26 <EvilSporkMan> skew: so doIt >>= print? seems clunky...
23:35:43 <oerjan> > let undelim d (x:xs@(_:_)) | d == x = [x]:yss | otherwise = (x:y):ys where yss@(y:ys) = undelim d xs; undelim _ [x] = [[x]]; undelim _ [] = [] in undelim "gi" ["a",".","gi","1qf","1qf1q","111","gi"]
23:35:46 <lambdabot>   Non-exhaustive patterns in function undelim
23:38:16 <oerjan> how can that be non-exhaustive? :(
23:39:34 <dufflebunk> oerjan: might it match []:[]  ?
23:40:11 <oerjan> undelim should never return []:[]
23:40:25 <skew> maybe it is the guards?
23:40:27 <dufflebunk> I mean in the patter where you have (_:_)
23:41:20 <oerjan> it's supposed to match any list with at least 2 elements
23:41:33 <oerjan> (the whole pattern)
23:41:57 <dufflebunk> perhaps you want [x,y:rest] ?
23:42:26 <oerjan> at _least_ 2 elements, i said
23:43:07 <skew> oerjan: ghc doesn't try very hard to tell if boolean guards are exhaustive
23:43:21 <oerjan> er, there's an _otherwise_
23:43:25 <sjanssen> oerjan: what about undelim _ [x]?
23:43:34 <dibblego> undelim _ [x] = [[x]]
23:43:36 <sjanssen> oh, sorry
23:43:55 <skew> oerjan: not very hard at all
23:44:05 <skew> oerjan: but I would expect it to notice the undefined
23:45:14 <oerjan> um that exhaustive warning is a runtime error
23:45:28 <oerjan> it says it couldn't find a match
23:45:35 <skew> oh
23:45:39 <dibblego> it should say the pattern that failed to match
23:45:48 <dibblego> the arguments that is
23:45:58 <skew> have you tried the debugger
23:46:03 <oerjan> i think hugs did
23:46:20 <oerjan> Program error: pattern match failure: v2376 "gi" [".","gi","1qf","1qf1q","111","gi"]
23:47:39 <sjanssen> oerjan: the problem is the nested where
23:47:52 <oerjan> gah!
23:47:57 <oerjan> needs brackets
23:48:31 <oerjan> > let undelim d (x:xs@(_:_)) | d == x = [x]:yss | otherwise = (x:y):ys where { yss@(y:ys) = undelim d xs }; undelim _ [x] = [[x]]; undelim _ [] = [] in undelim "gi" ["a",".","gi","1qf","1qf1q","111","gi"]
23:48:34 <lambdabot>  [["a",".","gi"],["1qf","1qf1q","111","gi"]]
23:48:38 <oerjan> yay
23:48:47 <oerjan> sjanssen: thanks
23:49:36 <oerjan> lQg: ^^
23:49:42 <lQg> hi
23:49:43 <wy> I wish I could draw a picture in the code
23:49:55 <oerjan> your function up there
23:50:28 <oerjan> (^^ means look above, although you can get a smiley too :) )
23:50:42 <lQg> i'm working on speakable programing language, currently making compiler
23:50:50 <dufflebunk> wy: ascii art!
23:51:27 <lQg> with your generous support :$
23:51:42 <oerjan> lQg: see my last undelim attempt, which seems to work
23:51:51 <wy> dufflebunk: I'm in picture-mode ;-) hope that's enough
23:51:54 <lQg> kk looking
23:52:17 <lQg> what does the @ do?
23:52:23 <dibblego> as-pattern
23:52:35 <oerjan> it gives a name to the whole pattern as well as the subparts
23:52:37 <dibblego> names the match that follows
23:53:45 <EvilSporkMan> why is [] an instance of [ [a] ]?
23:54:00 <oerjan> :t []
23:54:11 <lambdabot> forall a. [a]
23:54:34 <oerjan> it's an instance of [a] for every type a
23:54:46 <dibblego> [[a]] is a restricted type of [a]
23:54:54 <EvilSporkMan> ah ha
23:55:34 <oerjan> @src []
23:55:35 <lambdabot> data [] a = [] | a : [a]
23:55:48 <dibblego> @src IO
23:55:49 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
23:55:52 <oerjan> (that's a fake definition)
23:56:03 <oerjan> (the IO one is real)
23:56:26 <EvilSporkMan> hash mark: does not compute
23:56:56 <oerjan> (# ... #) is an unboxed tuple
23:57:18 <oerjan> an internal optimization used by ghc
23:57:30 <oerjan> State# is a type for internal use
23:57:48 <lQg> nice not sure how but it works :D
23:58:18 <EvilSporkMan> i'll wrestle with ghc later...
23:58:39 <oerjan> @src State#
23:58:39 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
23:59:21 <lQg> oerjan: thanks a bunch was much tougher than excpected
23:59:28 <EvilSporkMan> is the given solution to H-99 problem 26 really more natural than the recursive definition of k-combinations? my recursive solution is six lines vs. four, but it's not at all clear to me why we needed this "tails" business. (http://www.haskell.org/haskellwiki/99_questions/21_to_28)
23:59:29 <lambdabot> Title: 99 questions/21 to 28 - HaskellWiki
23:59:53 <wy> dufflebunk: It's really kind of fun to draw pictures in programs :-)
23:59:57 <oerjan> lQg: yep as i said keeping delimiters at the _end_ of the groups is a bit hard
