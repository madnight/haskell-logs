00:00:11 <Cale> and for every object A in the category, there is an arrow id_A : A -> A
00:00:28 <Tac-Tics> Reading wikipedia, I have to wonder, is a functor just a mathematical compiler of sorts?
00:00:41 <Cale> such that for any arrows f and g, id_A . f = f, and g . id_A = g
00:00:56 <Cale> Tac-Tics: Umm...
00:01:08 <Cale> I'd have to think about that, but yeah, maybe
00:01:14 <jsnx> Tac-Tics: shut up!
00:01:28 <Cale> okay
00:01:37 <Cale> So that's basically all there is to a category
00:02:02 <Tac-Tics> If I want to write a compiler, I need to write a way to translate every function (aka: morphism) and native object (aka: integers, floating points, lists, vectors) to another form
00:02:04 <Cale> Another category I'm certain you've run into would be the category of vector spaces (over a fixed field), and linear transformations between them
00:02:27 <Cale> Or perhaps if you've had an abstract algebra course, the category of groups and group homomorphisms
00:02:38 <jsnx> Cale: are these arrows called morphisms?
00:02:41 <Cale> Or the category of topological spaces and continuous maps between them
00:02:44 <Cale> yes, often
00:03:03 <Cale> arrow and morphism are used interchangeably
00:03:11 <Tac-Tics> Lists in Lisp are cons cells, but in C, they would be linked lists, and the functor from Lisp to C would need to map Conses to Linked Lists and Cars to ->heads and nils to nulls
00:03:37 <Cale> Tac-Tics: but it's some work getting the arrows to line up
00:03:47 <Cale> (not saying it can't be done)
00:03:54 <jsnx> Linux localhost 2.6.24-rc2-kamikaze1 #2 Tue Dec 25 01:08:10 PST 2007 i686 Intel(R) Pentium(R) M processor 1500MHz GenuineIntel GNU/Linux
00:03:57 <jsnx> ooops
00:04:21 <Cale> Haskell types, and Haskell-definable functions between them is another good category
00:04:38 <Cale> All these examples have rather "function like" arrows, but that's not even necessary.
00:04:50 <radetsky> quick question: is "data enumeration = x1 | x2 | ... | xn" the right thing to do?
00:05:10 <Cale> radetsky: Make sure you get the capitalisation right.
00:05:13 <radetsky> or is there a better/more-correct way to do this?
00:05:23 <radetsky> Cale: yeah, it's pseudocode
00:05:26 <Cale> If you're creating an enumeration type, that's how you do it.
00:05:41 <Cale> deriving (Eq, Ord, Enum)
00:05:57 <radetsky> ah, that's what I forgot
00:06:00 <radetsky> thanks
00:06:04 <Cale> no problem
00:06:42 <Cale> jsnx: Okay, so if you have some vague idea of what a category is, a functor is like a homomorphism, that is, a structure-preserving map, of categories.
00:07:10 <Cale> It sends objects of one category to objects of another, and arrows of that category to arrows of the corresponding objects
00:07:20 <Cale> such that composition is preserved
00:07:30 <Cale> and identity arrows map to identity arrows
00:07:51 <jsnx> Cale: so, it does both? objects and arrows?
00:07:57 <Cale> yes
00:08:11 <jsnx> Cale: uhm, why do you want to make them the same thing?
00:08:15 <Cale> and the way in which the arrows are mapped has to preserve composition in a reasonable way
00:08:28 <Cale> make what the same thing?
00:08:36 <jsnx> sorry, vague
00:08:55 <Cale> Let me be slightly more formal. If T is a functor between the category C and category D, and A and B are objects of C
00:08:55 <jsnx> why does the functor handle both? why wouldn't you have one for objects and one for arrows?
00:09:02 <Cale> and f is an arrow A -> B
00:09:13 <Cale> then Tf : TA -> TB
00:09:54 <jsnx> Cale: okay, i see
00:09:58 <Cale> Well, in some sense, it's only the arrows which matter in a category, but the objects just help to remember when composition is defined.
00:10:23 <Cale> Also, remember that there might be many (even infinitely many) arrows between two objects, or none at all.
00:10:37 <jsnx> Cale: aye
00:10:53 <Cale> also:
00:10:54 <jsnx> that part is easy to understand
00:10:56 <Cale> T(f.g) = Tf . Tg
00:11:05 <Cale> and T(id_X) = id_(TX)
00:11:25 <jsnx> Cale: hmmm
00:11:36 <jsnx> Cale: that last one seems like an abuse of notation...
00:11:42 <radetsky> A friend of mine joked that haskell was created so that programmers would have an excuse to talk about math
00:11:59 <radetsky> I have no idea what would make him think this
00:12:00 <Cale> I could have abused notation there, but I didn't.
00:12:15 <Cale> I could have written T(id) = id
00:12:24 <jsnx> radetsky: yeah, my boss hates me now -- "our transaction processing system is like an infinite vector space..."
00:12:41 <Tac-Tics> radetsky: that, and for writing research papers
00:12:49 <Cale> radetsky: heh, what, like the last 3 hours of chat here weren't sufficiently convincing?
00:13:00 <jsnx> Cale: okay, well, so we have categories
00:13:07 <jsnx> which are objects and arrows
00:13:23 <jsnx> and there is composition of the arrows
00:13:28 <jsnx> and an identity arrow
00:13:28 <radetsky> Cale: maybe your irc client doesn't know how to render <sarcasm> tags or something
00:13:45 <jsnx> radetsky: might doesn't either
00:13:49 <Cale> Heh, that reminds me of my friend trying to explain unitary transformations in QM to my other friend in a quantum computing course: "They're just like rotations in infinitely many dimensions"
00:13:51 <jsnx> s/might/mine/
00:14:33 <jsnx> Cale: i thought infinite dimensional vectors made our transaction processing simpler to understand
00:14:41 <jsnx> but my boss was hard to convince
00:14:50 <jsnx> he thought i should explain it with SQL instead
00:14:55 <jsnx> bah
00:15:01 <Tac-Tics> are unitary trans. on infinite-dimension vectors?
00:15:01 <Cale> radetsky: The appropriate response to sarcasm is sarcastically pretending that the statement was ordinary ;)
00:15:24 <Tac-Tics> Dirac is the enemy of the C.S. major as well
00:15:24 <Cale> Tac-Tics: In quantum mechanics they usually are.
00:15:35 <Cale> Tac-Tics: Not in general.
00:16:06 <radetsky> Cale: zomg, i r pwn'd!
00:16:09 <Tac-Tics> I got a book on quantum computation, and it deals with bound binary states
00:16:22 <jsnx> there is a *separate* identity arrow for each object, right?
00:16:30 <Cale> jsnx: yes
00:16:46 <Cale> jsnx: here, I subscript the names of those arrows with their corresponding object
00:17:02 <jsnx> aha
00:17:04 <Cale> jsnx: But usually if it's clear from context, those subscripts are elided.
00:17:12 <jsnx> scary
00:17:23 <Cale> Kind of like we do in Haskell:
00:17:26 <Cale> :t id
00:17:28 <lambdabot> forall a. a -> a
00:17:45 <jsnx> well, we have polymorphic "arrows" in haskell
00:18:07 <jsnx> but the Category theory arrows are not polymorphic
00:18:12 <Cale> Well, id ends up being a natural transformation from the identity functor to itself ;)
00:18:26 <jsnx> Cale: right, of course
00:18:34 <jsnx> Cale: what?
00:18:46 <Cale> Polymorphic functions in Haskell end up being natural transformations in category theory. You're not expected to understand this yet. :)
00:19:03 <jsnx> okay, because we haven't gotten to natural transformations yet
00:19:18 <Cale> right
00:19:44 <Cale> So if we have two functors between the same pair of categories, say S and T going from C to D
00:19:45 <Tac-Tics> I'm giving up. I can't find $50 worth of books worth buying on this site
00:19:52 <jsnx> so, now functors take all the arrows and objects in one category, and put them in another category, such that composition and identity arrows are preserved
00:19:59 <Tac-Tics> everyone have a happy post-christmas night
00:20:04 <jsnx> Tac-Tics: g'night
00:20:14 <jsnx> Tac-Tics: can you get candy from B&N?
00:20:17 <Cale> Then a natural transformation is essentially a structure-preserving map between functors:
00:20:43 <jsnx> the structure is identity and composition?
00:20:57 <Cale> well, I have to make that more precise...
00:21:09 <jsnx> please, go ahed
00:21:15 <jsnx> s/ahed/ahead/
00:22:06 <Cale> eta : F -> G, a natural transformation, consists of a map for each object X in C: eta_X : FX -> GX
00:22:50 <Cale> Such that for any objects X and Y in C, and any arrow f: X -> Y, we have:
00:22:58 <jsnx> the ':' means "has type"?
00:23:13 <Cale> eta_Y . F(f) = G(f) . eta_X
00:23:16 <Cale> yeah
00:23:19 <Cale> essentially
00:23:29 <Cale> eta_X is an arrow going from FX to GX
00:23:48 <Cale> This is best pictured as a square:
00:24:00 <Cale> FX  --F(f)-->  FY
00:24:11 <Cale> |              |
00:24:13 <Cale> |              |
00:24:24 <Cale> eta_X          eta_Y
00:24:27 <Cale> |              |
00:24:36 <Cale> V              V
00:24:51 <Cale> GX  --G(f)-->  GY
00:25:05 <Cale> (phew, on the fly ascii-art)
00:25:28 <Cale> and both paths along that square are equal
00:26:06 <Cale> So essentially, you can view eta as sending the map Ff to the map Gf in a certain sense.
00:27:18 <Cale> Oh, I suppose it's important to note that it's for each object X in C, we have an arrow eta_X in *D*
00:27:36 <Cale> http://en.wikipedia.org/wiki/Natural_transformation has the definition again, if you'd like :)
00:27:37 <lambdabot> Title: Natural transformation - Wikipedia, the free encyclopedia
00:27:53 <jsnx> Cale: the square is the "associativity square" ?
00:28:08 <jsnx> Cale: or is that a different square?
00:28:12 <Cale> uhh...
00:28:19 <Cale> I think that might be a different one
00:28:24 <jsnx> okay
00:28:28 <Cale> It's called a commutative square in general.
00:28:46 <jsnx> i saw some stuff from eugenia cheung on youtube
00:28:55 <jsnx> i'm sure it got muddled
00:29:07 <Cale> Oh, hmm, I can't recall what they called that one in particular.
00:29:18 <Cale> naturality probably
00:29:28 <jsnx> oh, maybe that was it
00:29:45 <Cale> associativity sounds more like the diagram for monads.
00:30:01 <jsnx> oh, maybe that was it!
00:30:23 <jsnx> well, i got totally lost at the part about natural transformations -- but that's okay
00:30:29 <jsnx> Cale: thank you
00:30:31 <Cale> http://en.wikipedia.org/wiki/Image:Monad_mult.png
00:30:33 <Cale> (that one)
00:30:55 <Cale> jsnx: Well, a functor is, in a certain sense, like a "sketch" of a category
00:31:22 <jsnx> Cale: so, why do we even have natural transformations?
00:31:26 <Cale> It writes one category in terms of another in a possibly somewhat imprecise way, so you might lose some information about the original category.
00:31:34 <jsnx> i see
00:31:57 <Cale> A natural transformation is like a comparison between two such sketches then.
00:32:05 <jsnx> Cale: can a natural transformation be a functor on a category of functors?
00:32:07 <Cale> That's *really* vague :)
00:32:19 <Cale> It's an arrow in a category of functors.
00:32:27 <jsnx> Cale: oh
00:32:29 <jsnx> syck
00:32:56 <Cale> If you have a pair of categories you can form the category [C,D] of functors from C to D, and natural transformations between them.
00:33:08 <jsnx> aha
00:33:23 <jsnx> and the natural transformations are arrows in [C, D] ?
00:33:35 <Cale> There's also a category of all "small" categories, whose arrows are functors.
00:33:40 <Cale> yes
00:33:59 <jsnx> so, now we have natural transformations, functors and categories
00:34:04 <Cale> (The "small" constraint is a technicality from set theory)
00:34:27 <jsnx> please allow me to touch on the "smallness" at a later time
00:34:39 <Cale> Right, MacLane said that he invented category theory not to be able to talk about functors, but to be able to talk about natural transformations
00:35:06 <jsnx> but, we don't need natural transformations, because they are functors in another category!
00:35:15 <Cale> they're arrows in another category
00:35:21 <jsnx> or arrows
00:35:27 <jsnx> i forgot about those
00:35:29 <Cale> But you still need to be able to define them to even talk about that category.
00:35:49 <jsnx> hmm
00:36:07 <jsnx> i do not understand why, but i am happy to accept that, for the sake of argument
00:36:23 <Cale> Well, how else are you going to know which natural transformations you have?
00:36:57 <Cale> In order to know a category, you have to know two things: what the objects are, and for any pair of objects, what the arrows are between them
00:36:59 <jsnx> well, we make the functors, and then we make the category they are in, and then we enumerate the arrows
00:37:19 <jsnx> okay, please go ahead
00:37:22 <Cale> Oh, and another thing -- what the composition of any composable pair of arrows is, of course :)
00:37:37 <jsnx> an arrow?
00:37:47 <Cale> Not just *any* arrow though.
00:37:52 <jsnx> no?
00:37:52 <Cale> You have to say *which* arrow.
00:38:15 <Cale> Just like when you compose two functions you don't just get something random, you get the composite function.
00:38:23 <jsnx> lolz
00:38:38 <Cale> (f.g)(x) = f(g(x))
00:39:07 <Cale> (that's in the case of sets and functions, and many other categories whose arrows happen to be described as functions)
00:39:17 <jsnx> so, why is this special?
00:39:49 <jsnx> when you said, not just *any* arrow, i thought you meant, it is a special *kind* of arrow
00:40:05 <jsnx> but it's just an ordinary one, right?
00:40:15 <Cale> Well, if I composed sin and cos, and got tan instead of the map which sends x to sin(cos(x)), then I'd be pretty surprised, and it would mean that I'm not working in the ordinary category of sets and functions anymore.
00:40:36 <Cale> (but maybe in some other category)
00:40:45 <jsnx> okay
00:41:19 <Cale> So in order to talk about a category, you have to know exactly how the arrows compose.
00:41:21 <jsnx> so, the result of composing arrows is defined by the category somehow
00:41:31 <Cale> That's part of the data which specify the category.
00:41:33 <jsnx> oh, and that is the natural transformations!
00:41:38 <Cale> uhh...
00:41:42 <jsnx> no
00:41:44 <jsnx> doh
00:42:01 <jsnx> i thought they were just around the corner, sorry
00:42:26 <Cale> Well, the natural transformations between two functors F,G: C -> D specify a bunch of arrows F -> G in the category [C,D] of functors from C to D.
00:42:53 <Cale> You have to be able to define what those natural transformations are in order to define which arrows you have
00:42:57 <jsnx> is composition a functor?
00:43:03 <jsnx> . : C -> C
00:43:19 <Cale> hmm...
00:43:25 <Cale> not overtly
00:43:31 <jsnx> oh, wait
00:43:38 <jsnx> . : C*C -> C
00:44:01 <jsnx> so, i guess not
00:44:47 <jsnx> so, the natural transformations specify the functors
00:44:54 <jsnx> and the functors specify the arrows?
00:45:01 <Cale> You know (roughly) what a manifold is?
00:45:08 <jsnx> no
00:45:12 <Cale> okay...
00:45:20 <Cale> topological space? :)
00:45:29 <jsnx> Cale: no
00:45:30 <Cale> Well, okay, let's say subset of R^3?
00:45:36 <jsnx> sure
00:45:39 <Cale> okay
00:45:56 <Cale> I want to give a nontrivial example of a functor
00:46:09 <Cale> How about groups? Do you know what a group is?
00:46:23 <Cale> (it's okay if not :)
00:46:54 <Cale> I suppose this is rather funny :)
00:47:01 <jsnx> Cale: a group is a field with some operation, a '0' of some kind, and some other stuff
00:47:07 <Cale> A set
00:47:14 <Cale> (not a field)
00:47:19 <jsnx> Cale: oh, okay
00:47:22 <Cale> A field is a group under addition though.
00:47:41 <jsnx> Cale: the other stuff is, like, an inverse op?
00:47:43 <Cale> You have associativity, an identity element, and inverses.
00:47:50 <jsnx> aha
00:48:00 <jsnx> could not have said it better myself
00:48:04 <Cale> So let's consider the subsets of R^3 which contain the origin.
00:48:23 <Cale> pick one...
00:48:34 <jsnx> the unit sphere
00:48:41 <jsnx> lolz
00:48:46 <Cale> translated by a unit, sure.
00:49:07 <Cale> Or a torus, or some other interesting shape
00:49:20 <jsnx> Cale: okay, a dinosaur shape
00:49:31 <Cale> Now, consider paths in that subset which start and end at the origin.
00:49:45 <Cale> That is, continuous functions [0,1] -> S, where S is your subset.
00:49:52 <jsnx> so, this is a surface?
00:49:57 <Cale> where f(0) = 0, and f(1) = 0
00:50:08 <Cale> sure, a surface if you like, or it can be solid
00:50:08 <jsnx> oh, got it
00:50:38 <jsnx> i was trying to figure out what you did not like about the unit sphere
00:50:54 <jsnx> so, we have these paths
00:51:03 <Cale> turns out the unit sphere is not interesting later on (but that's actually quite tricky to prove)
00:51:22 <jsnx> aye
00:51:46 <Cale> Now two paths are considered equivalent if one can be continuously deformed into the other, while remaining in our subset.
00:52:12 <Cale> Let's just take the unit circle for a moment, with the origin at some point.
00:52:52 <jsnx> aye
00:52:52 <Cale> you have a bunch of paths which don't make a full revolution around the circle and are equivalent to the boring path which just stays at the origin
00:53:12 <Cale> then you have the paths which are equivalent to one full revolution clockwise
00:53:21 <Cale> and those are different
00:53:46 <jsnx> aye
00:53:51 <Cale> because they're hooked around the circle, you can't "pull the rope tight"
00:54:13 <jsnx> Cale: aye
00:54:18 <Cale> well, you can pull it tight, but it doesn't all collapse down, if you get what I mean :)
00:54:26 <jsnx> aye
00:54:35 <Cale> I'm talking in vague terms, but it's possible to make this rigourous with a little more time.
00:54:54 <oerjan> an actual sheet of paper would help, too ;)
00:54:56 <Cale> Now, you can define an operation on paths which joins them together end to end
00:55:22 <Cale> So you follow one path, and then the other, (technically, you're doing each twice as fast)
00:55:47 <Cale> and that actually lifts to equivalence classes of paths
00:56:31 <Cale> (that is, if f and f' are equivalent and g and g' are equivalent paths, then f # g is equivalent to f' # g', where # is this concatenation of paths
00:56:35 <Cale> )
00:56:46 <jsnx> Cale: wow
00:56:57 <Cale> This actually gives us a group on the set of equivalence classes of paths.
00:56:57 <jsnx> Cale: that last bit was dense
00:57:53 <jsnx> Cale: thanks for all your hard work
00:57:58 <Cale> and this group (normally defined in a slightly broader context) is actually a functor from the category of subsets of R^3 containing the origin under continuous maps, to the category of groups.
00:57:59 <jsnx> i should go to bed, though
00:58:08 <jsnx> oh, there is more
00:58:23 <Cale> That line there was the goal. :)
00:58:49 <Cale> This is typically called the fundamental group, and normally defined for pointed topological spaces.
00:58:55 <jsnx> well, i'm there, but i can't eat the food yet -- i'm not acclimatized to the local diseases
00:59:03 <jsnx> thank you, though
00:59:03 <Cale> The idea though
00:59:20 <Cale> is that topological spaces are sometimes hard to work with, but often groups are easier
00:59:27 <jsnx> oic
00:59:44 <Cale> So if we have something which turns topological spaces into groups in a way which preserves something about them
00:59:49 <Cale> in this case, the loops
01:00:04 <Cale> then maybe we can turn topological problems into group problems
01:00:13 <jsnx> aha
01:00:35 <Cale> Now, that's not a natural transformation yet, but it's an interesting example of a functor at least.
01:00:40 <jsnx> Cale: aye
01:00:49 <jsnx> Cale: please allow me to bow out, though
01:00:53 <Cale> okay :)
01:00:56 <jsnx> Cale: i will be back tomorrow
01:01:00 <Cale> yep :)
01:01:13 <Cale> I'll tell you how it relates to Haskell (which is much simpler)
01:01:24 <jsnx> Cale: well, i don't care about that
01:01:39 <Cale> I think it's good to see at least one colourful example which isn't just a data structure :)
01:01:39 <jsnx> Cale: because i'm a sick, sick man!
01:05:47 <tehgeekmeister> hpaste isn't working for me, has anyone else been having trouble with it?
01:06:51 <Cale> hmm, it worked up to the point where I just went to save my paste
01:06:52 <oerjan> got an error
01:07:03 <tehgeekmeister> same here
01:07:05 <Cale> It hasn't responded back yet.
01:07:48 <oerjan> Proxy Error The proxy server received an invalid response from an upstream server.  The proxy server could not handle the request POST /new.  Reason: Error reading from remote server
01:08:48 <tehgeekmeister> then i suppose since my code fragment is a single line, i'll just paste it in here: filter test $ concat [[[a,b,(1000-(a+b))] | b <- [(a+1)..1000], (1000-(a+b))>(a+b) ] | a <- [1..1000]] where test (a:b:c) = a^2 + b^2 == (head c)^2
01:08:57 <tehgeekmeister> this is an attempted solution to project euler problem 9
01:09:20 <tehgeekmeister> which isn't working, probably because i'm not understanding the problem itself right
01:09:29 <tehgeekmeister> the code runs just fine, it just fails to find an answer.
01:09:45 <tehgeekmeister> http://projecteuler.net/index.php?section=problems&id=9 <== the problem
01:09:48 <lambdabot> Title: Problem 9 - Project Euler
01:09:58 <tehgeekmeister> if anyone is bored enough to take a look and point out my mistakes.
01:11:01 <Cale> I have to go to bed :)
01:11:30 <tehgeekmeister> sleep well then
01:12:02 <oerjan> it runs to completion?
01:12:23 <tehgeekmeister> yes, returns an empty list
01:12:32 <tehgeekmeister> takes just around a minute to run
01:13:14 <tehgeekmeister> i don't test for a few of the properties because i structured my approach so it's guaranteed to provide those
01:13:27 <tehgeekmeister> (i.e.: a<b<c, a+b+c=1000)
01:13:42 <oerjan> i see that
01:16:37 <oerjan> oh wait
01:16:53 <Lycurgus> wow walmart.com!
01:17:10 <oerjan> tehgeekmeister: the test should be (1000-(a+b))>b
01:17:18 <TSC> Yeah
01:17:24 <TSC> > last $ concat [[[a,b,(1000-(a+b))] | b <- [(a+1)..1000],(1000-(a+b))>(a+b) ] | a <- [1..1000]]
01:17:27 <lambdabot>  [249,250,501]
01:17:37 <TSC> Doesn't go as far as it should
01:19:22 <tehgeekmeister> now i get just one result, like i should.  cool.  why is it b and not a+b?
01:19:57 <oerjan> you want a < b < c but you were testing c > a+b
01:21:05 <tehgeekmeister> okay, thanks.
01:22:00 <oerjan> you could clean it up a bit btw - you could do all in one list comprehension, including the filter
01:22:50 <tehgeekmeister> really?
01:23:05 <tehgeekmeister> i hate to admit it, but that's a whole lot cleaner than it was before.
01:23:28 <tehgeekmeister> at one point i had a three line list comprehension with no newlines.  i decided it was a kludge and i should start from scratch.
01:26:19 <oerjan> [[a,b,(1000-(a+b)] | a <- [1..1000], b <- [(a+1)..1000], let c = 1000-(a+b), c > b, a^2 + b^2 == c^2]
01:27:38 <desegnis> Now I /finally/ know where to put lets in a list comprehension!
01:27:55 <desegnis> Namely, just right in there.
01:28:29 <oerjan> er, an error in it
01:28:56 <oerjan> [[a,b,(1000-(a+b))] | a <- [1..1000], b <- [(a+1)..1000], let c = 1000-(a+b), c > b, a^2 + b^2 == c^2]
01:29:40 <desegnis> Actually, c should be in scope where you have 1000-(a+b) again
01:29:41 <oerjan> it is also quite legal to put newlines in it.
01:29:51 <oerjan> oh
01:30:03 <oerjan> i was just modifying bit by bit
01:30:19 <oerjan> [[a,b,c] | a <- [1..1000], b <- [(a+1)..1000], let c = 1000-(a+b), c > b, a^2 + b^2 == c^2]
01:30:26 <tehgeekmeister> ah, i wasn't sure if it was possible to use a variable which was being bound on the rhs in the rhs
01:30:51 <oerjan> that would explain your workarounds :)
01:31:27 <oerjan> the scope includes everything to the right
01:33:17 <TSC> You could write it as a do block too, if you want to sprinkle some newlines
01:34:03 <tehgeekmeister> yes, i realized that would be possible
01:34:13 <tehgeekmeister> but i didn't want to mess around with that
01:34:21 <TSC> It would look more or less the same
01:34:31 <TSC> And you can get rid of the "c > b" test by fixing the upper bound on b
01:34:43 <tehgeekmeister> yes, and the functionality would be almost identical.
01:35:33 <tehgeekmeister> oh, how could you do that?
01:36:11 <TSC> Once you know a, you know that b+c = 1000-a
01:36:28 <TSC> That is, what's left in 1000-a has to be spread over b and c
01:36:33 <TSC> But b < c
01:36:50 <TSC> So the upper bound of b is (1000-a) `div` 2
01:37:06 <tehgeekmeister> right
01:37:13 <oerjan> now just add that a need not go over 333 or so, and you have my solution :)
01:37:24 <TSC> Yeah, the same logic applies to a (:
01:38:13 <TSC> The Project Euler problems are quite fun
01:38:32 <tehgeekmeister> yes, they really are.
01:39:53 <TSC> They're well suited to learning haskell, too
01:39:59 <desegnis> However, those bounds include the candidate (200,400,400), which does not meet the criterion a < b < c, right?
01:40:50 <desegnis> (Of course that couldn't be a Pyth. triangle anyway, but just to be correct)
01:41:13 <TSC> desegnis: Change the "1000-a" to "999-a" and I think it's right
01:46:16 <desegnis> TSC: That looked wrong at first sight, you're fully right.
01:46:26 <desegnis> s/, /, but/
01:46:40 <TSC> It's just a hacky way to get the right rounding
01:46:52 <oerjan> yeah, takes a bit of thought to see it is right for both odd and even a
01:53:51 <tehgeekmeister> i attempted the 10th problem (the sum of all primes less than a million), thinking it'd be simple since i had (what i considered) a fast prime generator already implemented, but no, alas, my prime generator takes more than a minute to reach a million.  must get better algorithm.
01:58:27 <TSC> You can get a long way by doing nothing trickier than using "mod" to look for factors
01:59:16 <desegnis> Speaking of algorithms... I got a book for christmas, ‚ÄúIntroduction to Algorithms‚Äù, and their descriptions how they analyze imperative algorithms makes me sigh, ‚Äúwhy doesn't FP rule the world?‚Äù
02:00:01 <TSC> Analysis of lazy algorithms isn't easy either
02:00:18 <sk_> I have that book too... and yea most of the algorithms use destructive updates
02:01:07 <desegnis> TSC, well it includes properties of the code, too, like: at the start of each iteration of this loop, j is always... etc.
02:01:09 <ginkgo> I'm currently working with MIX assembly for Knuth's "Art of Computer Programming" :P
03:13:39 <Jomyoot> Do you guys miss Objects OOP at all?
03:19:58 <opqdonut> not really
03:30:30 <therp> for encapsulation we have ADTs, for subtyping, we have type classes
03:34:36 <Saizan> typeclasses don't really provide subtyping
03:36:07 <therp> hm true, what else?
03:36:25 <therp> but what about super classes of type classes?
03:36:40 <therp> don't they form a type class hierarchy?
03:40:08 <Saizan> yeah, but they are not types
03:46:28 <therp> but I'd argue that the code you can express in OOP is also expressible in Haskell due to type classes.
03:47:14 <opqdonut> @where oohaskell
03:47:15 <lambdabot> http://homepages.cwi.nl/~ralf/OOHaskell/
03:47:20 <opqdonut> see that paper
03:48:09 <therp> interesting thanks
03:48:51 <therp> huch but pretty long paper
03:50:17 <pejo> therp, doesn't that basically boil down to almost all languages being turing complete in the end?
03:52:39 <IvdSangen> pejo: no, the ease and clarity with which you can use a certain paradigm is of importance, if that is too low people say something like "C does not support Object Orientation"
03:53:22 <IvdSangen> but you can emlate object orientation (be it weak typed)
03:54:04 <therp> pejo: technically I'd say you're right on that. probably I should have restricted "the code" to something without the need for hand-made encoding of types, manual dispatching of methods, and so own. that basically ends up at IvdSangen's comment about clarity
03:54:16 <pejo> IvdSangen, sure, OOHaskell is evidence of that. But nobody writes programs in OOHaskell, afaik. Nevertheless, it's an interesting paper.
04:09:37 <kryptos23> the Linux kernel is the finest example of OO in C
04:10:43 <Jomyoot> Is OO Haskell really supported?
04:11:08 <therp> I'd rather say glib (as in GTK's dependencies) is a good example of OO in C
04:11:41 <therp> the Linux kernel mostly plays with pointer indirections, but nothing else
04:12:12 <wolverian> by some definitions of OO, that's all there is ..
04:12:57 <therp> iirc, glib has also an informally standardised set of macros to do type casts and type inspection
04:13:18 <pejo> Jomyoot, website is last updated in 2005. Ralf L‰mmel is moving to germany according to his blog, so he's probably fairly busy. As mentioned, not many people use OOHaskell.
04:13:28 <wolverian> yup. it's still a gigantic pain in the ass to code glib in c, but at least it works
04:13:35 <pejo> Jomyoot, what kind of system are you trying to code in Haskell?
04:13:49 <wolverian> well, it's nice to _use_ libraries written with glib, but implementing your own objects is annoying
04:13:55 <wolverian> the amount of boilerplate is astounding
04:13:59 <Jomyoot> mathematical / matrix computation
04:16:34 <vali> does anyone know of a university course in haskell that has exercises with solutions? i don't learn so well by just reading.. i need to bang my head against the wall.. and i found such a site, but i lost the url
04:18:28 <pejo> vali, http://www.cs.chalmers.se/Cs/Grundutb/Kurser/funvt/ perhaps? The exams from 2004/2005 are in english. "Lˆsningar" is solutions.
04:18:30 <lambdabot> Title: Introduktion till funktionell programmering
04:19:05 <pejo> vali, oh, "Tenta oktober 2004" is the one I was referring to.
04:21:01 <pejo> vali, the advanced course seems to have stuff written in english too: http://www.cs.chalmers.se/Cs/Grundutb/Kurser/afp/
04:21:02 <lambdabot> Title: Advanced Functional Programming -- HT2006
04:58:52 <EvilTerran> @b52s
04:58:53 <lambdabot> You belong in Ripley's Believe It Or Not
05:15:31 <fons> hi
05:17:09 <fons> this might be a pretty concrete question, but does anyone know if it's necessary to supply -fglasgow-exts to GHC when using any extension which uses the forall keyword? (the -X flags are more expressive and specify a concrete extension)
05:17:45 <basti_> hm
05:17:48 <fons> for instance, imagine you had to code a function such as
05:18:00 <basti_> i'd guess so, especially if the "forall" leaks out.
05:18:10 <fons> f :: forall a b . (Typeable a, Typeable b) => (a,b) -> a
05:18:10 <basti_> why don't you just try it? ^^
05:18:41 <fons> basti_: Ive been trying hehe, and it seems it's needed, but I don't know what -X flag is specific to what I'm trying to do
05:18:50 <fons> (see the example I just typed)
05:19:14 <basti_> hmm
05:19:48 <fons> -XExistentialQuantification on its own doesn't work
05:19:51 <fons> I tryi
05:20:03 <basti_> ah i think i understand your point now
05:20:12 <therp> ExistentialQuantification is something else imho
05:20:16 <fons> ops, I tried PolymorphicComponents too
05:20:52 <fons> well, maybe I should rephrase my question to, what extension is my code using?
05:20:58 <fons> (in the example above)
05:21:52 <therp> http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#universal-quantification
05:21:53 <lambdabot> Title: 8.7. Other type system extensions, http://tinyurl.com/3c7ura
05:22:07 <fons> needing to use -fglasgow-exts anyway veils the whole purpose of the -X extensions
05:22:07 <therp> try -XRank2Types, -XRankNTypes
05:24:08 <Saizan> fons: btw, you don't need the forall in that signatures
05:24:15 <Saizan> s/s//
05:24:40 <fons> Saizan: yes, I do, I thought the same before too
05:24:52 <fons> Saizan:  I'll show you a better example
05:25:16 <Saizan> f :: (Typeable a, Typeable b) => (a,b) -> a, is enough
05:25:26 <fons> http://www.haskell.org/pipermail/haskell-cafe/2007-December/036684.html
05:25:27 <lambdabot> Title: [Haskell-cafe] Dynamic typing of polymorphic functions, http://tinyurl.com/2j9g87
05:25:47 <fons> see the cons function
05:26:06 <fons> cons :: forall a b. (Typeable a, Typeable b) =>
05:26:06 <fons> 	Signal a -> Signal b -> Signal (a,b)
05:26:16 <fons> it won't compile with the forall
05:26:33 <fons> without*
05:27:16 <Saizan> ah, that's because you're using the type variables in the body of cons
05:27:24 <Saizan> so you need ScopedTypeVariables
05:27:34 <fons> Saizan:  yep
05:27:41 <fons> I'm using that extension
05:27:49 <fons> but without the forall it doesn't compile
05:28:26 <Saizan> yes, that's how the extension work, but doesn't it also allow foralls in signatures?
05:28:48 <fons> no, it doesn't seem so
05:29:46 <Saizan> ugh, almost a bug, i'd say
05:32:41 <fons> I'm asking in ghc, let's see what they say
05:33:23 <fons> I don't really understand either why isn't there a concrete flag for unboxed types (# char)
05:33:43 <ndm> fons: historical accident, it is being proposed as -XMagicHash
05:34:05 <fons> thanks ndm
05:35:03 <fons> ok, so it seems that -fglasgow-exts shouldn't be needed in the future
05:36:12 <ndm> i know Igloo propsed it, i'm not quite sure if it is in yet
05:39:08 <fons> ok, Saizan, it seems that not unlocking the forall keyword with -XScopedTypeVariables was actually a bug
05:39:28 <fons> it's fixed in head but unfortunately I'm using 6.8.1
05:54:31 <fons> Now I'm begining to wonder, why does the compiler need the forall keyword at all when using Lexically Scoped Type Variables?
05:56:19 <fons> I mean, is there a reason that makes them more difficult to implement without using forall?
05:57:17 <Saizan> well, h98 signatures work differently, so it's applied only to non-h98 signatures, i.e. with foralls
05:57:54 <Saizan> it's probably less important now that you can activate each extension separately, it makes more sense with only -fglasgow-exts
05:59:25 <fons> I see
06:09:42 <zx]treads> in a datatype i have to declare all its constructors? i mean, in data SubInteger = One | Two | Three ... How can i reach TwoHundred without enumerating all?
06:10:01 <zx]treads> is it possible ?
06:10:51 <basti_> zx]treads: by recursion maybe?
06:11:08 <ndm> zx]treads: why do you want to?
06:11:12 <basti_> data Nat = Zero | Succ nat
06:12:25 <ndm> data SubInteger = Int
06:12:38 <zx]treads> and how i set the bounds of this type
06:12:49 <ndm> zx]treads: you can't
06:12:54 <zx]treads> hmm
06:13:13 <ndm> but you can't call One | Two ... TwoHundred setting bounds either - its hacking bounds at best
06:13:18 <ndm> and rather horribly
06:13:24 <ndm> why do you want bounds?
06:14:02 <zx]treads> i don't want this type to go over 200 but i'm too lazy to provide all the constructors
06:14:41 <zx]treads> i'll try data Nat = Zero | Succ Nat
06:14:47 <basti_> why do you want that?
06:14:49 <basti_> after all?
06:16:16 <zx]treads> i just want 0..200 , maybe i should build a function that checks if the data don't go over that limit?
06:16:37 <basti_> eg.
06:17:07 <basti_> maybe you can implement a class that checks that.
06:17:17 <roconnor> smart constructors!
06:17:42 <zx]treads> ok that sounds even better
06:21:42 <ndm> zx]treads: Int is bounded, data Nat is both not bounded and dead slow - seems like going worse
06:22:15 <ndm> zx]treads: i think you are trying to push this check into the types, which isn't where it belongs - a nice assert is probably better - and smart constructors as roconnor says
06:23:52 <zx]treads> ndm: smart constructors? could you elaborate?
06:25:22 <ndm> zx]treads: newtype Bounded200 = Bounded200 Int, bounded200 x = assert (x `inRange` (0,200)) (Bounded200 x)
06:26:03 <ndm> zx]treads: then you don't export the constructor, so if someone wants to change an Int to a Bounded200 they must do so using bounded200, which guarantees any Bounded200 is in teh correct range
06:26:23 <zx]treads> ty
06:26:41 <roconnor> or bounded200 x | 0 <= x <= 200 = return x
06:27:11 <roconnor>         | otherwise = fail $ (show x)++" is out of the range 0..200"
06:27:29 <roconnor> or both
06:27:50 <zx]treads> roconnor : fail is like throwing an exception ? or am i wrong ?
06:27:54 <zx]treads> :t fail
06:27:56 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
06:28:09 <ndm> zx]treads: in this case, it probably maps to Maybe - i.e. Just or Nothing
06:29:14 <roconnor> zx]treads: it depends on if you want a run-time exception, or something you can catch internally.
06:29:47 <roconnor> ndm's gives a runtime exception.  Mine can give you a Maybe Bounded200
06:29:58 <roconnor> what you want depends on what you are doing.
06:30:38 <sieni> roconnor: everybody wants a runtime exception saying
06:31:04 <sieni> "expected <cadarable value>; got `7'"
06:31:13 <ndm> if you are doing something like getArgs to get this number, and are doing "production quality" stuff you probably want the Maybe variant
06:31:21 <roconnor> sieni: runIdentity will give you that
06:31:44 <ndm> if its numbers that you know are going to be in the correct range, or its only you running it, error is less effort
06:32:04 <sieni> symbian actually seems to have a pretty nice kernel
06:32:10 <zx]treads> k ty all
06:32:21 * sieni has been reading "symbian os internals"
06:32:24 <zx]treads> i'll try and se
06:32:26 <zx]treads> see*
06:32:54 <basti_> hpaste doesnt work
06:33:29 <basti_> http://pastebin.com/m66b80a83
06:34:39 <basti_> zx]treads: look at this.
06:34:45 <basti_> it isnt pretty but it works.
06:38:41 <zx]treads> i'll test this too then
06:40:35 <basti_> it sucks, though.
06:41:31 <ndm> zx]treads: for what reason do you want bounded numbers?
06:41:33 <basti_> if you're interested in safe programs, i'd have a look into coq, too - ask me (or roconnor or some of the other coq guys) if you need more information
06:43:30 <zx]treads> nothing special, just to test a value from getArgs to be in this subset of int
06:44:06 <zx]treads> maybe i'm looking too deep. i should try it with an assertion
06:44:58 <ndm> yes, i think you are going too deep on this one
06:46:09 <basti_> actually the concern is pretty obvious. I wouldn't want a program to break because it causes an integer overflow.
06:47:20 <ndm> Integer  answers that one nicely
06:47:43 <basti_> true.
06:49:13 <zx]treads> maybe i thought that throwing exceptions i a good programming practice .. but obviously i am wrong in this one
06:49:26 <ndm> it isn't
06:49:36 <basti_> its better than nothing.
06:49:37 <osfameron> it can be
06:49:37 <basti_> ;)
06:49:49 <osfameron> it's better than just carrying on regardless
06:50:08 <zx]treads> so i'm not totally wrong !! :)
06:51:06 <ndm> catching exceptions is bad practice, i guess, rather than throwing them
06:51:32 <basti_> you can catch them and pass them on with additional informatio
06:51:36 <zx]treads> ndm : true
06:51:42 <basti_> "file error ... while decoding JPEG" or something
06:52:35 <ndm> i think IO exceptions are a special case of exceptions
06:52:44 <ndm> one thats a bit more defensible to use
06:53:18 <basti_> or "artihmetical error ... while searching for large eigenvalues"
07:07:29 <noecksit> hello, something about data types im not understanding, when I am creating my own data, such as "data Newtype Int = Newtype Int", is the Int before the equals sign necessary?
07:08:19 <noecksit> i understand that whats after the equal sign is the constructor of the data type, but then what is the arguments after the name of the data type?
07:08:47 <noecksit> do u declare the type of the data in there?
07:09:09 <basti_> uhm, you got something wrong there.
07:09:47 <noecksit> basti_: what is it?
07:09:56 <basti_> this line wouldn't compile.
07:11:38 <noecksit> like in http://en.wikibooks.org/wiki/Haskell/YAHT/Type_basics on the data types example
07:11:42 <basti_> so i can't answer the question.
07:11:47 <basti_> lets have a look
07:12:00 <noecksit> they have "data Pair a b = Pair a b"
07:12:07 <ndm> are CAF's actually in teh Haskell standard?
07:12:32 <basti_> noecksit: one "Pair" is the name of the Type, the other one is the constructor of a value of that type.
07:12:44 <basti_> both are necissary, since they aren't assumed to be identical
07:12:52 <noecksit> what is the "a and b" before the equals sign for, when there is a constructor for it already?
07:13:30 <basti_> to tell the compiler the new type needs variables of two other types (a and b) to be complete.
07:14:21 <basti_> you could have a constructor that needs no values at all
07:14:31 <noecksit> i thought it meant that it just tells the compiler what type the constructor needs, but later on they talk about enumerations with data Color
07:14:37 <basti_> then you wouldn't know what proper type the value constructed by that belongs
07:15:16 <basti_> lets look at list: "data List a = a:(List a) | []" - or something like that
07:15:24 <noecksit> and they have "data Color = Custom Int Int Int" among others
07:15:32 <basti_> what type is []?
07:15:41 <basti_> yes, and the "Int"s are not variable
07:15:45 <basti_> "a" is variable in List
07:15:54 <basti_> @type [5]
07:15:57 <lambdabot> forall t. (Num t) => [t]
07:15:59 <basti_> @type [5.0]
07:16:00 <lambdabot> forall t. (Fractional t) => [t]
07:16:04 <basti_> >_<
07:16:06 <basti_> @type [true]
07:16:06 <lambdabot> Not in scope: `true'
07:16:10 <basti_> argh
07:16:11 <basti_> @type [True]
07:16:12 <lambdabot> [Bool]
07:16:16 <basti_> there we go
07:16:42 <basti_> @type []
07:16:43 <lambdabot> forall a. [a]
07:17:10 <basti_> you need to tell the compiler which type of values could go into the list.
07:17:36 <basti_> or, if the list could take two types of values.
07:17:44 <basti_> otherwise you wouldn't know how to treat []
07:18:12 <noecksit> so do u mean that we need to declare on the LHS only if the argument to the constructor is variable, like a or b, but not when it's Int, Char, or String?
07:18:20 <olsner> I need a name for my (Ord a => [a] -> LambdaExp) esolang
07:18:20 <basti_> exactly.
07:18:43 <basti_> you need a variable to express a variable.
07:18:52 <basti_> just, in this case, a and b are *type variables*
07:19:13 <basti_> this thing of stuff is rather rare in other languages
07:19:29 <basti_> but it happens - generic typing etc. (there are type-variable lists in C++ and Java as well)
07:20:00 <noecksit> so, the "data someName a b ..." is like a function, with those parameters, and then they evaluate to the RHS?
07:20:22 <noecksit> thanx for clearing it up
07:20:51 <basti_> uhm, no, not really. "data someName a b" is like the declaration of a function (like "int someName(char * a,int b)")
07:21:18 <basti_> "= X a b" is like the body of said function (like "{return strlen(a)+b;}")
07:21:37 <basti_> in some way.
07:21:43 <basti_> not very tightly though.
07:21:44 <basti_> ^^
07:22:25 <basti_> if you mention "SomeName a b", the compiler "evaluates" and knows, the result can only be along the lines of "X a b" (or one of the other constructors)
07:22:49 <basti_> it can, eg., check if you said you would supply an Int for "a" but you supplied a network socket instead.
07:23:51 <basti_> usually, that part happens implicitely - you give a value and it doesn't check, because of some type mismatch
07:24:07 <basti_> you can however check explicitely, with arbitrary granularity.
07:24:17 <basti_> you could, e.g., say, "a::Int"
07:24:39 <noecksit> wouldn't it not know whether u supplied int or network socket since it's an a (variable type)?
07:25:03 <noecksit> oh ok
07:25:38 <basti_> yes, it knows. but it knows only because a is declared as a variable type in that spot
07:27:10 <basti_> how would the compiler be able to check if it weren't for the "a" in the type "List"
07:40:15 <ndm> @seen catamorphism
07:40:16 <lambdabot> I haven't seen catamorphism.
07:40:29 <ndm> @seen tim -- anyone know what nick he's using?
07:40:30 <lambdabot> I haven't seen tim.
07:41:04 <ndm> Philippa: do you know what tim is going as on IRC?
07:56:17 <roconnor> ndm: Binkley
07:56:21 <roconnor> @seen Binkley
07:56:22 <lambdabot> I haven't seen Binkley.
07:56:28 <roconnor> :/
08:01:09 <ndm> have emailed Tim (cc ghc-users) so doesn't matter anymore
08:02:02 <olsner> is it possible to search hpaste? I know I pasted some code there a while ago and now I want it back
08:02:51 <olsner> wow, I just guessed at offset = 20 and there it was
08:08:10 <shapr> @yow !
08:08:10 <lambdabot> Is it 1974?  What's for SUPPER?  Can I spend my COLLEGE FUND in one
08:08:10 <lambdabot> wild afternoon??
08:09:31 <roconnor> I wonder if I can prove integration by substituion within 60 minutes.
08:11:23 <kalven> do it, fgj
08:19:03 <roconnor> I think the answer is no
08:20:45 <roconnor> stupid boundry cases
08:21:00 <sieni> roconnor: there are no answers, only questions.
08:21:34 <sieni> roconnor: answers are uninteresting to a sensible person
08:22:11 <chessguy> @users
08:22:12 <lambdabot> Maximum users seen in #haskell: 434, currently: 364 (83.9%), active: 10 (2.7%)
08:22:40 <qebab> sieni: unless the answers can let you define new and interesting questions
08:22:44 <olsner> foldr (flip f) = foldl f . reverse?
08:23:20 <shapr> @users
08:23:20 <lambdabot> Maximum users seen in #haskell: 434, currently: 363 (83.6%), active: 11 (3.0%)
08:23:21 <chessguy> @type foldr (flip f)
08:23:24 <lambdabot> Not in scope: `f'
08:23:25 <shapr> Hiya chessguy
08:23:30 <chessguy> @type foldr (flip ?f)
08:23:30 <lambdabot> forall a c. (?f::c -> a -> c) => c -> [a] -> c
08:23:37 <chessguy> @type foldl ?f . reverse
08:23:38 <lambdabot> forall b a. (?f::[a] -> b -> [a]) => [a] -> [b] -> [a]
08:23:51 <shapr> olsner: hpaste is currently using 2.2GB of space, my server ran out of space for email...
08:23:57 <chessguy> shapr!!
08:24:00 <shapr> Hiya!
08:24:13 <chessguy> how was your Christmas?
08:24:13 <shapr> flippo: y0, long time no see! How's code?
08:24:17 <shapr> chessguy: Exciting...
08:24:26 <shapr> I'm busy preparing to move to Boston.
08:24:32 <chessguy> oh wow
08:24:36 <shapr> And busy with the largest spam deluge I've had yet.
08:24:45 <chessguy> spam on hpaste?
08:24:52 <shapr> Nah, email spam.
08:24:54 <chessguy> ah
08:24:59 <chessguy> gmail ftw
08:25:07 <shapr> I got about two thousand spam bounces in three days.
08:25:09 <flippo> shapr, maybe today will be the day.
08:25:18 <shapr> flippo: Yay! The day for Haskell code?
08:25:36 <shapr> Today I only had 222 spams.
08:25:41 <flippo> shapr, why not?  Everyone else at the office is on vacation.
08:25:55 <olsner> shapr: so you're saying searching hpaste is infeasible?
08:26:13 <shapr> flippo: Quick! Convert your entire codebase to Haskell code! You should end up with less than thirty 8x12 printed pages.
08:26:25 <shapr> olsner: Just saying it's not feasible to search it by hand.
08:26:38 <sieni> qebab: indeed :-)
08:26:40 <chessguy> @go site:hpaste.org Functor
08:26:48 <shapr> olsner: You could use the IxSet built into HAppS to automatically index hpaste.
08:26:51 <lambdabot> Plugin `search' failed with: getHostByName: does not exist (no such host entry)
08:26:59 <chessguy> silly bot
08:27:04 <chessguy> http://www.google.com/search?source=ig&hl=en&rlz=&q=site%3Ahpaste.org+Functor&btnG=Google+Search
08:27:07 <Saizan> shapr: deleted HPaste_state/archive?
08:27:27 <shapr> Saizan: apt-get autoclean got me 2gb, so I was happy.
08:27:49 <chessguy> shapr, seems really roundabout to me. why not use google?
08:29:02 <Saizan> btw, hpaste's state is a Data.Sequence.Seq Entry, not very fulltext search friendly
08:29:21 <shapr> chessguy: Because text indexing is cool.
08:29:30 <chessguy> lol
08:29:39 <shapr> So I'd rather steal kimbly's inverted index code and write it myself, or just use the included functionality.
08:30:36 <shapr> Google's text indexing is even more cool than inverted indices, but I don't have access to enough hardware to make Google-style indices worth investigating.
08:30:38 <Saizan> shapr: what's that?
08:30:58 <shapr> I guess I could try it with a bunch of Amazon instances.
08:31:22 <Saizan> ?google kimbly inverted index
08:31:30 <lambdabot> http://www.kimbly.com/code/invidx/
08:31:30 <lambdabot> Title: Inverted Index Language Shootout
08:31:34 <shapr> @go kimbly inverted index haskell
08:31:35 <shapr> Right, that
08:31:35 <lambdabot> http://www.kimbly.com/code/invidx/
08:31:35 <lambdabot> Title: Inverted Index Language Shootout
08:42:04 <olsner> @pl (\x -> x `id`)
08:42:04 <lambdabot> (line 1, column 14):
08:42:04 <lambdabot> unexpected ")"
08:42:04 <lambdabot> expecting white space or simple term
08:46:39 <Saizan> that inverted index code looks very slow
08:47:01 <chessguy> @pl \x -> x `id`
08:47:01 <lambdabot> (line 1, column 13):
08:47:02 <lambdabot> unexpected end of input
08:47:02 <lambdabot> expecting white space or simple term
08:47:25 <chessguy> @pl \x -> `id` x
08:47:26 <lambdabot> (line 1, column 7):
08:47:26 <lambdabot> unexpected "`"
08:47:26 <lambdabot> expecting lambda abstraction or expression
08:49:35 <Saizan> @pl \x -> (x `id`)
08:49:36 <lambdabot> id
08:50:03 <chessguy> hm. well that's silly
08:51:06 <Saizan> for a section you need parentheses, though maybe it would be reasonable to parse (\x -> x `id`)
08:51:24 <Saizan> ?type (\x -> x `id`) -- ghc?
08:51:25 <lambdabot> parse error on input `)'
08:58:37 <shapr> Saizan: I think kimbly was learning Haskell along the way.
09:01:10 <Saizan> shapr: yeah, but i was hoping for a nice algorithm :)
09:50:10 <araujo> hello
09:50:50 <oerjan> hi
09:52:38 <basti_> where vowel nicks meet...
09:53:14 * oerjan never knew b was a vowel.
09:54:06 <basti_> :|
09:55:28 <oerjan> makes for some awkward syllables.
09:56:57 <oerjan> region around tblisi excepted.
10:00:09 <oerjan> hm, apparently that's fake, should be tbilisi.
10:14:54 <diltsman> I have a question about basic Parsec use.  I'm trying to use the lexeme command.  The code works fine without, but when I add it I get an error.  My code is: parser :: Parser (String, String)\nparser = do whiteSpace\n            s1 <- lexeme $ many1 letter\n            c1 <- lexeme $ char '='\n            s2 <- lexeme $ many1 letter\n            return (s1, s2)
10:17:01 <diltsman> The error is at the first many1.
10:17:22 <diltsman> Any ideas why that doesn't work?
10:18:09 <oerjan> how are you defining lexeme?
10:18:39 <opqdonut> what error are you getting?
10:19:00 <oerjan> i mean, is it the Parsec function?  it is not actually used like that
10:20:45 <oerjan> actually the manual is rather confusing.
10:21:18 <diltsman2> Ok, sorry, I had some trouble with my connection.
10:21:21 <diltsman2> What were you saying?
10:21:33 <allbery_b> find the parsec paper, it explains how lexeme works
10:21:37 <oerjan> the type given for lexeme is not for the actual parsec-defined function, but instead assumes that you have defined lexeme = P.lexeme lexer as in the previous section
10:22:20 <diltsman2> http://legacy.cs.uu.nl/daan/download/parsec/parsec.pdf ?
10:22:31 <allbery_b> yes
10:22:33 <oerjan> :t Text.ParserCombinators.Parsec.ParsecToken.lexeme
10:22:36 <lambdabot> Couldn't find qualified module.
10:22:36 <resiak> Hrm.   HFuse seems to need some TLC.  Does anyone know if anyone's planning to develop it further?
10:22:47 <allbery_b> it's a little dated but the basics are still correct
10:22:56 <oerjan> :t Text.ParserCombinators.Parsec.Token.lexeme
10:22:57 <lambdabot> forall st a. Text.ParserCombinators.Parsec.Token.TokenParser st -> Text.ParserCombinators.Parsec.Char.CharParser st a -> Text.ParserCombinators.Parsec.Char.CharParser st a
10:24:48 <oerjan> for this peculiarity, read the subsection on makeTokenParser + the following section on TokenParser
10:28:54 <diltsman2> ok, that is starting to make sense, thanks.
10:57:14 <sw17ch> i have a goofy question dealing with imports
10:57:48 <sw17ch> if i have a few .hs files and one of them depends on all of the rest, but the rest only need access to the first one... is such a thing possible?
10:58:07 <sw17ch> a.hs has an Import B and b.hs has an Import A
10:58:30 <oerjan> yes, but you need a special file to break cyclic dependences
10:58:50 <sw17ch> hmmm... i thought so, i'm still trying to figure that part out
10:58:57 <diltsman2> Question: The parsec structure LanguageDef uses something called "named fields" I believe.  Does anybody know of a reference to learn how to use these?
10:59:26 <oerjan> @where report
10:59:27 <lambdabot> http://www.haskell.org/onlinereport/
11:00:14 <Botje> diltsman2: they're called records, "haskell records" will turn up some hits
11:00:26 <oerjan> ^^ see sections on data/newtype declarations
11:01:09 <oerjan> sw17ch: http://haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#mutual-recursion
11:01:11 <lambdabot> http://tinyurl.com/2y3hr6
11:01:43 <sw17ch> merci
11:03:30 <diltsman2> Botje: How do I actually use the constructor for the data type?
11:06:05 <oerjan> > State { runState = \s -> (1,s) } :: State Bool Int
11:06:07 <lambdabot>        add an instance declaration for (Show (State Bool Int))
11:06:41 <oerjan> > State ( \s -> (1,s) ) :: State Bool Int
11:06:42 <lambdabot>        add an instance declaration for (Show (State Bool Int))
11:07:53 <sw17ch> oerjan: this will be my first time using {-# SOURCE #-}, what does this actually do? Similar to the #include "something.c" idea from that other language?
11:07:59 <oerjan> the first uses the record notation, the second uses ordinary datatype notation
11:10:22 <oerjan> sw17ch: i don't know either
11:10:34 <sw17ch> mmm. alright :) thanks i'll look
11:10:39 * shapr falls over laughing while reading http://steve-yegge.blogspot.com/2007/12/codes-worst-enemy.html
11:10:39 <lambdabot> Title: Stevey's Blog Rants: Code's Worst Enemy
11:10:50 <shapr> "Java is like a variant of the game of Tetris in which none of the pieces can fill gaps created by the other pieces, so all you can do is pile them up endlessly."
11:11:13 <b_jonas> two new lambdacats pics!
11:11:16 <b_jonas> cool
11:11:18 <shapr> This rant encourages me to write that Design Patterns in Haskell article.
11:11:21 <shapr> b_jonas: yay!
11:11:33 <b_jonas> "STATIC CAT is checked at compile time"
11:11:45 <shapr> "polymorphic cat haz class"
11:12:18 <Valodim> haha, static cass
11:12:21 <Valodim> cat
11:12:36 <loupgaroublond> is this a cat that has its fur sticking out?
11:12:37 <wolverian> shapr, also note his comment where he says he's not using a static HM language like scala or haskell because his game is dynamic
11:12:52 <Valodim> lol
11:13:09 <shapr> wolverian: I haven't gotten that far yet. But maybe hs-plugins would help?
11:13:30 <wolverian> shapr, probably, indeed, though you would have some boilerplate in defining a common interface
11:22:19 <_roconnor> http://en.wikipedia.org/wiki/Integration_by_substitution <- why does g'(t) /=0 ?
11:22:20 <lambdabot> Title: Integration by substitution - Wikipedia, the free encyclopedia
11:22:57 * roconnor thinks wikipedia may be wrong
11:23:47 * roconnor checks the talk page
11:24:25 * oerjan recalls something might break with infinite variation
11:24:47 <oerjan> i.e. if the derivative changes too fast
11:25:08 <oerjan> or was that integration by parts
11:25:33 <roconnor> Once I finish my coq proof, I'll know for sure
11:25:55 <roconnor> but I think that requirement can be dropped
11:28:15 <b_jonas> rocconor: it's because it says limits from g(a) to g(b)
11:28:20 <b_jonas> it's easier to define that way
11:28:35 <b_jonas> you don't have to mess with the integration path turning back
11:29:22 <hpaste>  ToRA pasted "simple Cabal + arrows + Stream issue..." at http://hpaste.org/4664
11:29:48 <ToRA> does any kind soul know a work-around for the problem in the paste?
11:30:56 <oerjan> roconnor: the wikibook link does not have that condition
11:33:01 <roconnor> b_jonas: It's really not harder to have g be non-monotone
11:33:06 <roconnor> b_jonas: the same proof works
11:33:27 <b_jonas> roconnor: but I think (I'm not sure) that that simple formula at the top of that en.wikipedia page doesn't work
11:33:51 <roconnor> b_jonas: what simple formula?
11:34:51 <b_jonas> int[a..b] f(g(t))g'(t)dt = int[g(a)..g(b)] f(x)dx
11:36:09 <roconnor> what's wrong with that formula?
11:36:26 <roconnor> I'm pretty sure it works fine.
11:36:39 <b_jonas> let me thnik...
11:38:24 <b_jonas> hmm yes, you're right
11:38:43 <roconnor> and there is not requirement that g'(t) =/= 0
11:38:48 <b_jonas> it does seem like it's not needed
11:38:52 * roconnor nods
11:39:19 <roconnor> I'm not using that assumption in my Coq proof (although I am assuming that f is continuous)
11:41:47 <oerjan> hm i recall the infinite variation problem may only happen when you weaken the conditions on the other function (although i now think it is integration by parts i remember)
11:42:07 <oerjan> so dropping continuity might indeed require finite variation for g
11:43:12 <roconnor> oerjan: interesting theory.
11:43:24 <roconnor> sounds plausable.
11:44:04 <b_jonas> I don't know calculus
11:44:15 <b_jonas> though I'll have to take a big exam in January
11:44:23 <b_jonas> and there I'll have to be answer this I guess
11:44:44 <b_jonas> however, the examiner isn't too strict
11:44:59 <conal> ToRA: are you saying that Stream-0.2.2 shows up in your "ghc-pkg list" result?
11:45:10 <b_jonas> and he always asks some topics from his favourite topic
11:45:47 <conal> ToRA: i'm confused about the second "/home/tora/.ghc/i386-linux-6.8.2/package.conf:"
11:46:32 <ToRA> conal: Stream-0.2.2 is in my ghc-pkg list, under the .ghc/.../package.conf: entry
11:47:39 <conal> ToRA: oh.  i didn't realize there could be more than one package.conf.  where do the .ghc ones come from?
11:47:59 <ToRA> runghc Setup.[l]hs install --user
11:48:13 <ToRA> afaict
11:48:51 <conal> ToRA: got it.  thanks.  i wonder if the --user for Stream is somehow causing the arrows configure to fail.
11:49:12 <ToRA> it's possible, i'm wondering if this is a known issue
11:49:22 <bos> http://programming.reddit.com/info/63wcr/comments/
11:49:39 <bos> wah, no lambdabot
11:50:30 <bos> ToRA: if you're building stream with --user, you have to do the same with packages that need it
11:50:48 <oerjan> @bot
11:50:49 <lambdabot> :)
11:50:57 <ToRA> bos: thank-you
11:51:46 <gbacon> @botsnack
11:51:47 <lambdabot> :)
11:52:27 <augustss> bos: I agree!
11:54:20 <bos> augustss: :)
11:59:05 <sclv_> :t foldl
11:59:08 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
11:59:09 <sclv_> :t foldr
11:59:10 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
12:01:14 <sclv_> :t catMaybe
12:01:15 <lambdabot> Not in scope: `catMaybe'
12:01:21 <sclv_> ?hoogle catmaybe
12:01:22 <lambdabot> Data.Maybe.catMaybes :: [Maybe a] -> [a]
12:08:38 <shapr> wolverian: Any idea why Steve thinks his game requires a dynamic language?
12:08:49 <Botje> he's a nutjob
12:08:52 <conal> is there a more generic version of catMaybes, beyond [] ?  I use something analogous for functional events: justE :: Event (Maybe a) -> Event a
12:08:59 <Botje> that or he wants an excuse to hack on rhino
12:09:12 <wolverian> shapr, not really.
12:09:21 <shapr> Botje: Er, I was hoping for a more detailed answer than that :-) I mean like... what could not be easily done in Haskell?
12:09:50 <jsnx> which steve? yegge?
12:10:00 <jsnx> shapr: he hates static languages
12:10:02 <shapr> jsnx: yup
12:10:11 <jsnx> shapr: it's all over his blog
12:10:26 <jsnx> static typing is against his religion
12:10:33 <jsnx> has nothing to do with his game specifically
12:10:42 <wolverian> jsnx, well, he did say HM-style typing is fine with him, except for this game.
12:10:45 <shapr> Aside from that, he specifically mentions javascript-style prototype delegation. It seems to me that typeclasses could cover most of that.
12:10:48 <sclv_> conal: what would Event (Nothing) be?
12:10:54 <jsnx> wolverian: really?
12:10:57 <wolverian> jsnx, yes
12:11:00 <wolverian> shapr, what is prototype delegation?
12:11:08 <jsnx> wolverian: i read that article, i don't remember seeing that part
12:11:15 <wolverian> jsnx, he replied in the comments
12:11:20 <jsnx> wolverian: oh, i see
12:11:21 <sclv_> or do you want [Event (Maybe a)] -> [Event a]
12:11:32 <shapr> Um, it's the difference between object oriented and prototype oriented languages...
12:11:36 <conal> sclv_: Nothing-valued occurrences become non-occurrences.
12:11:41 <b_jonas> perhaps he wants to load new code dynamically, which is easier in some dynamically typed languages
12:11:42 <b_jonas> ?
12:11:46 <jsnx> shapr: that's not very clear
12:11:46 * shapr looks for a better word
12:11:51 <conal> sclv_: like catMaybes
12:12:01 <shapr> jsnx: I know, I'm trying to clarify
12:12:19 <shapr> aha - http://en.wikipedia.org/wiki/Prototype-based_programming
12:12:26 <jsnx> wolverian: are you familiar with how prototype based OO works?
12:12:31 <b_jonas> I wonder why there's no lambdacats with catMaybes yet
12:12:48 <shapr> I like prototype based programming over 'standard' OOP because I think separate class/instance hierarchies is needlessly complex.
12:12:52 <b_jonas> though there's one with catAmorphisms
12:12:54 <wolverian> jsnx, yes
12:13:07 <wolverian> well, somewhat
12:13:11 <jsnx> shapr: so, what is the delegation part about?
12:13:14 <EvilTerran> conal, what's your definition of justE?
12:13:25 <jsnx> wolverian: well, that's good!
12:13:25 <b_jonas> ah, classless objects
12:13:39 <shapr> Anyway, it seems to me that implementing prototype based programming with typeclasses in Haskell would imply that Steve Yegge's game could be implemented in Haskell.
12:13:40 <wolverian> ah, wikipedia educated me :)
12:13:57 <wolverian> shapr, he does say as much -- he says it'd take more code.
12:14:20 <shapr> I'm not sufficiently convinced, but neither can I disprove, so...
12:14:28 <jsnx> shapr: yeah, but his game could be implemented in java...he's not making a point about *could* but rather *should*
12:14:33 <sclv_> Conal: so that's really something of Cont ((IO())(Maybe a)
12:15:16 <shapr> jsnx: That's true. I think my real question is "Are there examples of programming problams that are should be implemented in dynamic languages rather than Haskell?"
12:15:49 <conal> sclv_: for DataDriven, justE = inCont (. maybe mempty), where inCont, just works inside the Cont constructor.
12:15:57 <jsnx> shapr: i think the answer is "no"
12:16:14 <conal> i'm working with two very different Event representations: DataDriven and Reactive
12:16:20 <shapr> jsnx: So I'd like to know enough about Steve's game to convince myself one way or the other.
12:16:21 <conal> http://haskell.org/haskellwiki/Reactive
12:16:32 <jsnx> shapr: but then again, i do use the shell for its "first class files"
12:17:09 <b_jonas> sclv_: unbalanced parens
12:17:34 <conal> EvilTerran & sclv_: semantically, events are just lists of time/value pairs.
12:17:44 <oerjan> conal: catMaybe can be generalized to MonadZeros, i think
12:17:54 <oerjan> :t (>>= maybe mzero return)
12:17:55 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m (Maybe a) -> m a
12:18:02 <oerjan> er, Plus
12:18:19 <oerjan> would have been Zero if it existed :)
12:18:29 <conal> oerjan: i like that.  thanks.
12:18:58 <conal> oerjan: oh, right.  since it doesn't use mplus.
12:19:16 <oerjan> could use fail in a pinch ;)
12:20:25 <conal> alternatively,
12:20:25 <conal> :t (>>= maybe mempty return)
12:20:26 <lambdabot> forall a (m :: * -> *). (Monoid (m a), Monad m) => m (Maybe a) -> m a
12:21:15 <conal> :t (>>= maybe mempty pure)
12:21:16 <lambdabot>     Ambiguous occurrence `pure'
12:21:16 <lambdabot>     It could refer to either `pure', imported from Control.Applicative
12:21:16 <lambdabot>                           or `pure', imported from Control.Arrow
12:21:33 <conal> i like that one best.
12:21:42 <xerox> anybody remembers the url of the article (I think it was a blog post) talking about functional equality for special kinds of functions defined on very special infinite sets?
12:21:51 <b_jonas> someone gave a nice short equivalent to catMaybes the last day
12:21:51 <oerjan> you cannot get rid of the Monad.. it's in the >>=
12:21:56 <b_jonas> what was it...
12:22:03 <xerox> some keywords were compactification and cantor set, I can't find it anymore.
12:22:05 <conal> oerjan: oh yeah.  thx.
12:22:21 <xerox> :t \xs -> [x | Just x <- xs] -- b_jonas ?
12:22:22 <lambdabot> forall t. [Maybe t] -> [t]
12:22:31 <b_jonas> xerox: no
12:22:35 <oerjan> and this kind of structure-changing mapping essentially requires it
12:22:39 <sclv_> :t fmap (maybe mempty id)
12:22:40 <lambdabot> forall a (f :: * -> *). (Monoid a, Functor f) => f (Maybe a) -> f a
12:22:50 <conal> oerjan: agreed
12:23:50 <b_jonas> it was something short, like (concatMap . maybeToList) but I think not that one
12:24:02 <b_jonas> something with monads or some other general thingy
12:24:20 <sclv_> :t fmap (fromMaybe mempty)
12:24:21 <lambdabot> forall a (f :: * -> *). (Monoid a, Functor f) => f (Maybe a) -> f a
12:25:09 <sclv_> ?ty fromMaybe mempty <$>
12:25:09 <lambdabot> parse error (possibly incorrect indentation)
12:25:21 <sclv_> ?ty (fromMaybe mempty <$>)
12:25:22 <lambdabot> forall a (f :: * -> *). (Monoid a, Functor f) => f (Maybe a) -> f a
12:26:55 <oerjan> xerox: http://sigfpe.blogspot.com/2007/10/how-can-it-possibly-be-that-we-can.html seems relevant
12:26:55 <vincenz> :t (fromMaybe mempty mappend)
12:26:55 <lambdabot>     Couldn't match expected type `Maybe a'
12:26:56 <lambdabot>            against inferred type `a1 -> a1 -> a1'
12:26:56 <lambdabot>     In the second argument of `fromMaybe', namely `mappend'
12:26:56 <lambdabot> Title: A Neighborhood of Infinity: How can it possibly be that we can exhaustively sear ..., http://tinyurl.com/2mckmf
12:27:05 <vincenz> :t fromMaybe
12:27:06 <lambdabot> forall a. a -> Maybe a -> a
12:27:31 <xerox> oerjan: thanks much
12:29:45 <oerjan> :t fromJust . msum
12:29:46 <lambdabot> forall a. [Maybe a] -> a
12:29:54 <oerjan> um nah
12:30:13 <sclv_> ./msg lambdabot ?ty let insertM m k v = Data.Map.insert k v m in uncurry (insertM m)
12:30:18 <oerjan> :t concat . maybeToList
12:30:19 <lambdabot> forall a. Maybe [a] -> [a]
12:30:27 <Valodim> so
12:30:38 <oerjan> that's one
12:30:40 <sclv_> +(insertM m)
12:30:40 <sclv_> <oerjan> :t concat . maybeToList
12:30:40 <sclv_> <lambdabot> forall a. Maybe [a] -> [a]
12:30:40 <sclv_> <Valodim> so
12:30:41 <sclv_> *** Signoff: ac (Read error: 104 (Connection reset by peer))
12:30:42 <Valodim> why is it "eager cat is eager, lazy cat is lazy" and not "strict cat is strict"
12:30:43 <sclv_> [1] 15:30 sclv_ on #haskell (+cnt) * type /help for help
12:31:22 <osfameron> PLEASE DON'T OVERTHINK LAMBDALOLS KTHX LUV X
12:31:25 <sclv_> sorry for the spam -- command line irc is a pain.
12:31:32 <conal> i like justE = (>>= maybe mzero return) .  It fits nicely as a special case of event branching (>>=).
12:31:51 <Valodim> k
12:32:46 <sclv_> anyway, look at that cat, does he *look* strict?!
12:33:01 <oerjan> i like to think of >>= as your general substitution operator
12:33:28 <conal> oerjan: nicely general.  with collapsing & expanding.
12:33:57 <conal> oerjan: substitution with branching & collapsing universes
12:34:44 <conal> what would be a good name for (>>= maybe mzero return) ?
12:35:11 <Valodim> ze_rox
12:35:16 <oerjan> joinMaybe
12:35:22 <oerjan> joinMaybes
12:35:30 <oerjan> since concat = join
12:36:24 <conal> i like that.  slight preference for the joinMaybe.
12:42:49 <conal> how about this one: filterMP :: MonadPlus m => (a -> Bool) -> m a -> m a
12:43:00 <conal> easy to define via joinMaybe & liftM.
12:43:19 <conal> oerjan: suggestions for a nicer name?
12:48:55 <conal> oerjan: oic why "joinMaybes" instead of "joinMaybe": generalizing "catMaybes"
12:49:02 <oerjan> :)
12:49:46 <conal> i'll go with that.  and "filterMP" until something better comes along.
12:50:54 <oerjan> i think filterMP would be (=<<).guarded, where guarded p x = guard (p x) >> x
12:52:09 <oerjan> er, return x
12:52:56 <oerjan> hm actually filterMP itself could be guarded
12:53:42 <oerjan> it's a function where it's not obvious what to keep monadic
12:54:29 <Saizan> what's the difference between call-by-name and laziness? sharing?
12:54:35 <oerjan> yep
12:54:40 <conal> oerjan: what properties is mzero supposed to have
12:54:44 <conal> ?
12:55:08 <oerjan> mzero >>= f  =  mzero v >> mzero   =  mzero
12:55:33 <Saizan> mzero v?
12:55:39 <oerjan> the second is not always kept
12:55:47 <oerjan> er i pasted and newline was lost
12:55:54 <oerjan> mzero\n v
12:55:56 <conal> oerjan: so quite different from mempty.  hm.
12:55:56 <Saizan> ah ok
12:56:28 <oerjan> (it's in the Control.Monad doc)
12:57:12 <oerjan> actually it should also be a monoid with mplus
12:57:22 <oerjan> (though not necessarily a Monoid)
12:58:15 <conal> oic.  i have both Monoid and MonadPlus.  i was getting mappend & >> confused.
12:58:55 <Saizan> mappend ~ mplus
12:58:55 <oerjan> yeah, MonadPlus has two natural monoids in it
12:59:04 <oerjan> well not entirely
12:59:23 <oerjan> (>> return ()) is not quite id
12:59:33 <oerjan> but the rest hold for them
12:59:35 <Saizan> mplus is associative and mzero is its identity..
12:59:49 <olsner> @ty liftM2 (&&) (not . null) head
12:59:51 <lambdabot> [Bool] -> Bool
13:01:14 <EvilTerran> @ty maybe True id . listToMaybe
13:01:15 <lambdabot> [Bool] -> Bool
13:01:41 <EvilTerran> er, that should be maybe False
13:01:55 <olsner> ah, that's shorter even
13:02:05 <oerjan> @ty and . take 1
13:02:07 <lambdabot> [Bool] -> Bool
13:02:13 <EvilTerran> @check liftM2 (==) (liftM2 (&&) (not . null) head) (fromMaybe False . listToMaybe)
13:02:14 <oerjan> er, or
13:02:14 <lambdabot>  OK, passed 500 tests.
13:02:23 <oerjan> @ty or . take 1
13:02:24 <lambdabot> [Bool] -> Bool
13:02:39 <olsner> > or . take 1 $ []
13:02:40 <lambdabot>  False
13:02:42 <EvilTerran> @check liftM2 (==) (or . take 1) (fromMaybe False . listToMaybe)
13:02:42 <lambdabot>  OK, passed 500 tests.
13:06:13 <olsner> (or . map p . take 1 . fst) vs (maybe False p . listToMaybe . fst)
13:06:52 <oerjan> (any p . take 1 . fst)
13:07:31 <olsner> I have underestimated the power of #haskell
13:07:50 <EvilTerran> that's even all in the prelude :D
13:08:40 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/4665
13:08:44 <olsner> is there a 'none' to match 'any'?
13:08:51 <oerjan> all
13:08:54 <oerjan> is the dual
13:09:06 <noecksit> hello, could someone please look at what i hpasted
13:09:28 <oerjan> so not . all p
13:09:34 <noecksit> im trying to make a data type of Card, and then make a a Deck of [Card] objects
13:09:37 <oerjan> or any (not . p)
13:09:50 <TSC> That's not none, that's "not all"
13:09:52 <TSC> none f = not . any f
13:10:03 <oerjan> er the other way around then
13:10:05 <noecksit> then each Card has a Face and Suit
13:10:41 <noecksit> i think my code is right, but im not sure how to pass data types to functions
13:11:18 <TSC> noecksit: The type of newDeck' looks wrong
13:11:27 <noecksit> i passed the constructor of Card, however it says that it cannot find neither Suit or Face, however it does find FileName
13:11:35 <TSC> It seems like it should be something like "Card -> Int -> [Card]"
13:12:15 <olsner> ah, there, my 7 line shift/reduce parser is getting even shorter
13:12:19 <noecksit> oh yeah, i just added that, sorry, it still gives the same error
13:12:31 <noecksit> i just modified it
13:13:07 <TSC> Oh!
13:13:20 <oerjan> noecksit: seems to me like nextCard (newDeck' is in the wrong order
13:13:31 <TSC> newDeck' (Card Suit Face FileName) is not quite what you want
13:13:32 <roconnor> whew, done my Coq proof of integration by substitiution.
13:13:36 <roconnor> boy that sucked.
13:13:51 <TSC> It should be "Card suit face file", or so
13:14:10 <TSC> (or you shouldn't match on the constructor at all)
13:14:41 <olsner> and since (error "Parse error") isn't more helpful than a pattern match failure anyways I don't really have to cover all cases ;-)
13:14:53 <TSC> Also, "Card : nextCard ..." isn't going to work; Card must take arguments
13:15:25 <noecksit> oh, so i can just have "newCard' (Card) i"?
13:15:50 <oerjan> noecksit: card
13:16:37 <noecksit> so it has to be all lowercase when declaring parameters to a function, i didn't see that before
13:16:52 <oerjan> since that function is not itself looking inside the card anyhow, it just passes it on to nextCard
13:17:15 <oerjan> yep, upper case is all constructors
13:17:35 <oerjan> (in expressions and patterns)
13:18:19 <hitodama> I'm working on one of the problems on project euler (problem #12), I think my code is correct but somewhere in my code I'm being too inefficient to get my answer in a reasonable amount of time
13:19:12 <noecksit> i keep forgetting that Haskell looks whether something is uppercase or lowercase
13:19:34 <Cale> hitodama: I can look
13:22:18 <olsner> > length "(const value)" == length "(\_ -> value)"
13:22:18 <lambdabot>  Illegal escape sequence at ""(\_" (column 34)
13:22:26 <olsner> > length "(const value)" == length "(\\_ -> value)"
13:22:26 <lambdabot>  True
13:23:10 <oerjan> noecksit: btw your newDeck' function can be expressed using take and iterate
13:23:26 <AtnNn> ?- apropos(help).
13:23:27 <lambdabot> Maybe you meant: . ? @ v
13:23:43 <oerjan> sorry, haskell only :)
13:23:54 <AtnNn> lol, oops
13:24:09 <olsner> no prolog in the prelude.. yet
13:24:16 <oerjan> (there would be bf and unlambda but they have been disabled for some reason ;) )
13:25:56 <araujo> hello there
13:27:57 <oerjan> apparently saying hello kills the channel.  weird that.
13:28:35 <oerjan> @quote hello
13:28:36 <lambdabot> erg0t says: <erg0t> @bf  ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.   <lambdabot>  Hello World!
13:28:58 <roconnor> @bf  ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.
13:28:59 <lambdabot>  fd:21: hClose: resource vanished (Broken pipe)
13:29:12 <olsner> does that program use some kind of differential encoding of the string?
13:29:55 <oerjan> it uses 4 bf cells, incrementing and decrementing
13:30:47 <oerjan> the part up to ] is initialization
13:31:08 <oerjan> to get values in the cell suitably close to the ascii values to be printed
13:32:16 <oerjan> essentially a loop calculating map (10*) [7,10,3,1]
13:33:00 <olsner> aha, the zeroeth cell contains 10, being the number of times to run the loop
13:33:18 <olsner> I think I just learnt brainfuck
13:34:06 <oerjan> we may guess that the cells are used for capitals, lower-case, space/! and newline respectively
13:34:27 <olsner> should be obvious from the cell movements in the part after the loop
13:36:02 <oerjan> yeah, there is only one command missing, , for input
13:41:36 <hpaste>  olsner annotated "folded, but not much simpler :(" with "working folds and more pointlessness" at http://hpaste.org/4141#a1
13:43:21 <dons> ?users
13:43:21 <lambdabot> Maximum users seen in #haskell: 434, currently: 381 (87.8%), active: 9 (2.4%)
13:43:27 <olsner> what annoys me is the gyrations necessary to convert between pointless style and pattern-matching style
13:47:06 <olsner> or rather that they combine so poorly
13:56:45 <sarah> why the \ in map f = foldr (\x xs -> f x : xs) []?
13:56:57 <basti_> its a lambda.
13:57:20 <sw17ch> > map (\x -> (1 + x)) [1..10]
13:57:23 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
13:57:41 <sarah> ah ty
14:00:13 <noecksit> oerjan: i looked at iterate, but im not sure how it can be implemented
14:00:48 <noecksit> i would need some kind of pointer to the next item, and then i would still have to construct it manually
14:01:25 <noecksit> i was thinking about just manually putting nextCard, with all the possible cards, and then returning the next card that should follow
14:03:18 <noecksit> i mean, i know what i want to do, i want to recurse over all the possible constructors of Suit once, then go the second constructor of Face, then recurse over Suit again
14:03:35 <noecksit> it would be a nested for loop in an imperative language
14:04:36 <Saizan> mmh so recurse on the cartesian product?
14:05:41 <Saizan> [(s,f) | s <- suits, f <- faces]?
14:05:49 <noecksit> i think so
14:07:03 <noecksit> except im using data types, like Card, Suit, Face, and Filename
14:07:13 <noecksit> maybe i should use tuples instead?
14:07:30 <Saizan> well no, tuples are not the point here
14:07:58 <notsmack> [Card s f | s <- suits, f <- faces]
14:08:07 <Saizan> yeah
14:08:21 <Modius> Asking here as this is the kind of crowd who may know.  A guy I know is talking about his new job using the language K, kind of spawned off of APL/J.  Where does such a thing fit in the language continuum?  The syntax is used up in some pretty cool but exotic (and esoteric?) ways - would that count as a DSL, or a full language?
14:09:06 <dons> strange math dsl's, basically. maybe for statistics?
14:09:19 <dons> pretty obscure
14:10:21 <Modius> Problem is he started on it about 3 days ago, and is claiming to have "seen the light" on functional now (after a lifetime of imperative C# programming) - I'd like to know if he's really getting the "functional programming" experience or a very focused DSL.
14:10:50 <visof> can i get debian package for YI editor?
14:11:16 <exDM69> visof: there wasn't one in ubuntu
14:11:28 <exDM69> visof: but I've heard that YI is deprecated/abandoned
14:12:09 <Modius> dons:  There's something I consider functional programming where problems can be broken down similarly (albeit at different levels of convenience; but similarly) in Haskell, OCaml - even C# - that I want to at least warn him on if he's not really doing it in K
14:12:13 <visof> why?
14:12:24 <visof> exDM69?
14:12:45 <nolrai> how does one patern match on named fields again?
14:13:19 <exDM69> visof: I've heard there's no-one developing it anymore
14:13:24 <exDM69> visof: but I am not sure
14:13:56 <visof> ok
14:14:11 <Saizan> nolrai: Contr{field=v}
14:15:03 <nolrai> Saizan++
14:28:15 <nolrai> > unwords ["a", " b", "c d", " c d e "]
14:28:17 <lambdabot>  "a  b c d  c d e "
14:28:24 <shapr> Modius: K is very much like J. In my mind it's in the Joy/PostScript category of languages... extremely concise and somewhat functional.
14:31:45 <nolrai> unwords ["a", ""]
14:31:49 <nolrai> > unwords ["a", ""]
14:31:50 <lambdabot>  "a "
14:32:10 <Tac-Tics> > unwords ["Concat ", "these ", "strings"]
14:32:11 <lambdabot>  "Concat  these  strings"
14:32:59 <nolrai> you get double spaces.
14:33:21 <Tac-Tics> ah yeah
14:33:21 <nolrai> > words "Concat  these  strings"
14:33:22 <lambdabot>  ["Concat","these","strings"]
14:33:39 <Tac-Tics> > concat ["Concat ", "these ", "strings"]
14:33:40 <lambdabot>  "Concat these strings"
14:35:00 <nolrai> i wish unwords was just a tad smarter. its just intersperse " " despite words being a bit more complex.
14:35:14 <Botje> how should unwords be smarter?
14:36:21 <nolrai> well removing trailing white space before adding the space so that it and words are more of inverses to each other.
14:36:50 <nolrai> but that is also kindof complex so the KISS in me likes the curent unwords.
14:36:54 <Tac-Tics> smartUnwords = unwords . map strip
14:37:09 <Tac-Tics> what unwords should be is join-with
14:37:37 <Tac-Tics> like in javascript: [1, 2, 3].join(" ") => "1 2 3"
14:38:29 <nolrai> > (unwords . map strip) ["a b c", " a", "a"]
14:38:31 <lambdabot>   Not in scope: `strip'
14:39:05 <nolrai> > (unwords . filter( /= ' ')) ["a b c", " a", "a"]
14:39:06 <lambdabot>  Couldn't match expected type `String' against inferred type `Char'
14:39:14 <nolrai> > (unwords . map filter( /= ' ')) ["a b c", " a", "a"]
14:39:15 <lambdabot>      The section `(/= ' ')' takes one argument,
14:39:15 <lambdabot>     but its type `[a -> Bool]...
14:39:36 <nolrai> > (unwords . map (filter( /= ' '))) ["a b c", " a", "a"]
14:39:37 <lambdabot>  "abc a a"
14:40:14 <Tac-Tics> @let joinWith _ [] = []; joinWith sep (x:xs) = (x ++ sep) ++ joinWith sep xs
14:40:15 <dcoutts_> dons: good first xmas in portland? :-)
14:40:16 <lambdabot> Defined.
14:40:35 <Tac-Tics> > joinWith " and then " ["kitties", "puppies", "flowers", "rainbows"]
14:40:36 <lambdabot>  "kitties and then puppies and then flowers and then rainbows and then "
14:40:45 <Tac-Tics> er close =-)
14:41:21 <Tac-Tics> @let joinWith _ [] = []; joinWith _ [x] = x; joinWith sep (x:xs) = (x ++ sep) ++ joinWith sep xs
14:41:22 <lambdabot> <local>:3:0:     Warning: Pattern match(es) are overlapped              In th...
14:43:34 <nolrai> > joinWith " and then " ["kitties", "puppies", "flowers", "rainbows"]
14:43:35 <lambdabot>  "kitties and then puppies and then flowers and then rainbows and then "
14:43:49 <nolrai> @let a = 2
14:43:50 <lambdabot> Defined.
14:43:55 <nolrai> > a
14:43:56 <lambdabot>  2
14:44:03 <nolrai> @let a = 3
14:44:03 <lambdabot> <local>:5:0:     Multiple declarations of `L.a'     Declared at: <local>:4:0 ...
14:44:30 <nolrai> @unlet a
14:44:30 <lambdabot>  Parse error
14:51:26 <perspectiva1> does anyone know if there is a way to install a package (hsh) which gives this error: "it was found in multiple packages: MissingH-0.18.6 base"? neither ghc-pkg unregister nor ghc-pkg hide manage to do the trick
14:53:43 <Saizan> perspectiva1: is it a cabal package?
14:54:38 <perspectiva1> Saizan: both HSH and MissingH are cabalized, and i'm trying to install HSH on Gentoo
14:56:51 <Saizan> well, you probably need to edit MissingH so it uses a different name, for that module
14:57:33 <Saizan> and HSH accordingly
14:58:29 <dons> dcoutts_: i'm in mexico, actually :) though i hear it is snowing in portland
14:59:03 <perspectiva1> ah, sorry--I left out an important part of the error message, the important part of which was: "Could not find module `Data.String': it was found in multiple packages: MissingH-0.18.6 base"
14:59:17 <perspectiva1> Saizan: i will look at what you're suggestinrg
14:59:29 <perspectiva1> =suggesting ;-)
15:00:11 <Saizan> i think gwern had the same problem recently, and resolved to this
15:04:45 <nolrai> yeah it snowed on christmass! (but it melted fast)
15:08:07 <dcoutts_> dons: oh, nice! xmas holiday? :-)
15:19:38 <Anon4888> I have a couple of questions:  1. Does haskell assume that the Monad laws are true for optimization purposes (just for standard library monads or for any instance of Monad)?
15:20:00 <sjanssen> Anon4888: no
15:20:09 <Anon4888> ok thanks
15:21:00 <Anon4888> 2. Do you know of any papers on CPS (continuation passing style) and monads?  I'm interested in building Monads using something like CPS style... does that ring any bells?
15:21:30 <dons> dcoutts_: yeah. 10 days off here with suzie. nice and warm :)
15:22:09 <dcoutts_> dons: I'm jelous, it's cold and wet here :-) I hear the US is also suffering ice storms, though perhaps not on the west coast
15:22:25 <Anon4888> oops, must go
15:22:32 <Anon4888> thanks for the help sjanssen
15:23:12 <benny99> guess Anon was looking for the state-monad :/
15:24:27 <Saizan> well you can describe most (any?) monads with CPS + effects, usually gaining some performance
15:27:32 <grahamhutton_> saizan: any (monadic) effect can be described in terms of call/cc and a single reference cell
15:28:40 <grahamhutton_> http://www.diku.dk/~andrzej/papers/CE-abstract.html
15:28:41 <lambdabot> Title: Controlling Effects (abstract)
15:30:39 <benny99> this might sound stupid
15:31:10 <benny99> but are there "typical haskell jobs" ?
15:31:16 <Saizan> grahamhutton_: yeah, i think i've read some slides describing the haskell side of that concept
15:32:26 <monochrom> I think monad laws are used in optimizations.
15:32:40 <monochrom> Err nevermind.
15:32:58 <grahamhutton_> without the monad laws, the do notation doesn't make sense
15:33:42 <grahamhutton_> (perhaps surprisingly, the monad laws are little used in optimisation)
15:34:09 <dcoutts_> sadly we cannot rely on them
15:34:41 <dcoutts_> though I think it'd be interesting to allow classes to specify axioms that we may rely on
15:35:07 <monochrom> Everyone certainly uses monad laws in re-factoring.
15:35:11 <dcoutts_> true
15:35:17 <dcoutts_> it's a problem with being pernikity with the language specification
15:36:11 <dcoutts_> someone can argue that the language spec does not allow a compiler to modify their program's meaning by applying the monad laws
15:36:30 <jsnx> dcoutts_: that would modify a program's meaning?
15:36:34 <monochrom> My faith is on: One day the compiler will make you write specifications, not just code; then it will come back and say "well you haven't written a valid proof that your code satisfies your spec, I'm going on strike!"
15:36:55 <grahamhutton_> dependent types :-)
15:37:35 <dcoutts_> jsnx: a program using a monad instance that did not follow the laws would have it's meaning changed by using the monad laws as transformations
15:38:11 <dcoutts_> monochrom: yes, you can do that now, see epigram and agda
15:38:32 <jsnx> dcoutts_: if a monad does not follow the monad laws...
15:38:39 <jsnx> dcoutts_: i didn't know that could happen
15:38:50 <jsnx> dcoutts_: i guess they could decide not to implement them or something
15:39:01 <dcoutts_> jsnx: it's easy, just write a monad instance that does silly things
15:39:26 <jsnx> dcoutts_: yeah, i guess this is one of those software engineering/philosophy things
15:39:26 <osfameron> but it wouldn't be the compilers fault if it optimized something, believing it to obey those laws
15:39:40 <jsnx> yeah, as long as it spat out a warning
15:39:43 <monochrom> Suppose your "return" code contains a call to Debug.Trace.trace. Suppose you choose "meaning" to care about its side effect. Then monad laws are violated, since k >>= return generates an output, but k doesn't.
15:39:43 <dcoutts_> osfameron: not according to the H98 spec
15:39:44 <osfameron> couldn't you switch off the optimization for specific (badly behaved) instances?
15:40:07 <osfameron> dcoutts_: oh?  allowing naughty monads is a feature?
15:40:26 <jsnx> osfameron: well monads are not really part of the language
15:40:33 <jsnx> they are a library
15:40:40 <monochrom> Santa doesn't want you to write naughty monads. :)
15:41:13 <jsnx> osfameron: so you can see why they punted on that, to keep the spec compact
15:41:21 * osfameron rushes off to write a monad tutorial involving chimneys, reindeer, and naughty children
15:43:31 <dcoutts_> osfameron: as far as I can see, the H98 spec does not say that instances of the monad class must follow any laws
15:43:41 <dcoutts_> osfameron: hence the compiler cannot rely on them
15:44:26 <osfameron> dcoutts_:  but do 99% of useful monads obey the laws?  In which case it might be a (togglable in general/specific case) optimization?
15:44:52 <dcoutts_> osfameron: it's something you could implement for specific monads using ghc rules pragmas.
15:45:11 <monochrom> ONE MONAD TO RULE THEM ALL.
15:45:24 <monochrom> Or is it: one rule to monad them all?
15:45:38 <opqdonut> does someone have material on how to use ghc rule pragmas
15:45:43 <opqdonut> to gain optimization benefits
15:46:47 <dcoutts_> opqdonut: see the ghc manual and for an example see the bytestring or stream fusion papers
15:47:03 <opqdonut> @where stream fusion
15:47:04 <lambdabot> I know nothing about stream.
15:47:07 <opqdonut> @where streamfusion
15:47:08 <lambdabot> I know nothing about streamfusion.
15:47:13 <opqdonut> @go stream fusion
15:47:15 <lambdabot> http://www.cse.unsw.edu.au/~dons/papers/stream-fusion.pdf
15:47:33 <oal`> I actually have build the last stable ghc for debian. Here it goes: http://haskellblag.lobachev.de/?p=7
15:47:35 <lambdabot> Title: Haskellblag ª Blog Archive ª Latest GHC build for Debian
15:47:47 <dcoutts_> opqdonut: or the original paper on ghc's rules
15:47:55 <dcoutts_> @google playing by the rules
15:47:58 <lambdabot> http://www.amazon.com/Rules-Play-Game-Design-Fundamentals/dp/0262240459
15:48:02 <dcoutts_> hmm
15:48:02 <sjanssen> I don't think the compiler (or language spec) ought to rely on properties that aren't enforced
15:48:53 <grahamhutton_> osfameron (and dcoutts): the H98 spec doesn't even specify that Haskell is lazy (only non-strict), never minds such obtuse things as monad laws...
15:49:23 <dcoutts_> opqdonut: http://haskell.org/haskellwiki/GHC/Using_rules
15:50:47 <moonlite> couldn't a revised language spec itself say that the monad laws must be followed and that any compiler that lets code containing Monads that don't follow the Monad laws compile are a misimplementation?
15:51:31 <jsnx> moonlite: if we go down that road, it would soon bloat the spec with arrows and on and on
15:51:45 <Saizan> moonlite: you should provide an algorithm to check that a monad respect them :)
15:51:48 <sjanssen> moonlite: well, then we have to write compilers that can prove instances are correct
15:51:58 <sjanssen> moonlite: this is not trivial :)
15:52:01 <dcoutts_> moonlite: good luck on testing requiring haskell implementations check if instances obey the laws
15:52:03 <jsnx> sjanssen: or just fail to terminate if they aren't :)
15:52:14 <opqdonut> dcoutts_: thanks!
15:52:14 <grahamhutton_> moonlite: this would also require Haskell having a semantics ;-)
15:52:22 <dcoutts_> moonlite: it requires proofs
15:52:33 <jsnx> dcoutts_: not really
15:52:42 <jsnx> dcoutts_: it could be like a c++ spec...
15:52:49 <jsnx> dcoutts_: you just *say* it has to
15:52:59 <jsnx> dcoutts_: that's all a spec is
15:53:01 <dcoutts_> grahamhutton_: but it does have a semantics, though apparently it takes 2 JFP papers to describe (as I recall)
15:53:41 <grahamhutton_> the type system has been formalised, but not the dynamic semantics (as far as I know)
15:54:02 <dcoutts_> I thought the JFP paper was on the static semantics
15:54:15 <grahamhutton_> yes, that's the paper about the type system
15:54:18 <dcoutts_> it had lots of stuff on the complexities of pattern matching
15:54:25 <dcoutts_> was that just types?
15:55:11 <moonlite> can you prove that an unknown monad m follows the monad laws by writing quickcheck properties?
15:55:45 <dcoutts_> http://journals.cambridge.org/action/displayAbstract?fromPage=online&aid=114971
15:55:46 <lambdabot> Title: CJO - Abstract - A static semantics for Haskell, http://tinyurl.com/yqfpo2
15:55:58 <dcoutts_> moonlite: you can test it, somewhat
15:56:10 <sjanssen> moonlite: you can't prove anything with quickcheck, because only some inputs are checked
15:56:21 <dcoutts_> quickcheck can prove failures :-)
15:56:29 <moonlite> ah that's true
15:56:52 <osfameron> you could prove *all* your inputs :-)
15:57:35 <jsnx> osfameron: but then you have to prove they are all your inputs...
15:57:40 <grahamhutton_> dcoutts: it's just about types (http://citeseer.ist.psu.edu/cache/papers/cs/27093/http:zSzzSzwww.imit.kth.sezSz~kffzSzsemantics.pdf/faxen98static.pdf)
15:57:41 <lambdabot> http://tinyurl.com/ypuhum
15:58:10 <moonlite> my idea was that type classes with laws should come with quickcheck properties that would be enforced by the compiler.
15:58:17 <dcoutts_> grahamhutton_: mm, seems I mis-remembered
15:58:47 <jsnx> moonlite: that would work, but it seems evil to me...i don't know why
15:59:05 <grahamhutton_> it's always embarassing to give a talk about Haskell reasoning and having someone in the audience ask what the underlying semantics is ;-)
15:59:42 <grahamhutton_> especially when that someone is andy pitts (who seems to ask this at every opportunity)
15:59:51 <Saizan> are there intrinsic problems in defining one or is just a lot of work noone has done?
16:00:31 <grahamhutton_> it's a lot of work, and there are tricky corners, and (unfortunately) there isn't much academic credit for this sort of thing
16:01:04 <dcoutts_> grahamhutton_: we've got static semantics for smaller lazy pure languages (via domain theory), what are the tricky features?
16:01:09 <jsnx> grahamhutton_: why is it emberassing?
16:01:22 <diltsman> In Parsec, reserved takes a string for the keyword to attempt to parse.  How would I make it so that it tries to parse any string in a list?
16:01:48 <dcoutts_> jsnx: accademic language designers like to have formal semantics
16:01:55 <grahamhutton_> it's embarsasing because ML has a (50 page) semantics right from the start
16:02:19 <jsnx> does java have a semantics, too?
16:02:25 <jsnx> does python or ruby?
16:02:35 <oal`> err... every language does
16:02:38 <osfameron> what's a semantics? ;-)
16:02:44 <oal`> but not every has it formal defined
16:02:45 <jsnx> i mean, do they have one written up
16:02:51 <jsnx> oal`: cute
16:02:59 <grahamhutton_> no - but do people do proofs about these programs?
16:03:07 <oal`> jsnx, thanks
16:03:07 <jsnx> grahamhutton_: oh, i see
16:03:12 <dcoutts_> grahamhutton_: is the ML semantics a dynamic semantics, transition style, or a static semantics it terms of sets/domains/something?
16:03:15 <jsnx> oal`: u r welcome
16:03:36 <grahamhutton_> dcoutts: it's an operational semantics
16:03:37 <byorgey> diltsman: what's the type of 'reserved'?
16:03:54 <jsnx> diltsman: you could try a map over the list
16:04:07 <jsnx> diltsman: mapM maybe
16:05:51 <grahamhutton_> the "definition of standard ML" is a great book --- last semester i taught a semantics course, and took great delight in holding up the java spec (unpteem hundred pages of english text), and then contrasting with this boo (50 pages of precise mathematics)
16:06:05 <dcoutts_> :-)
16:06:40 * dcoutts_ was demonstrating a programming languages course last term which concentrated on types and semantics
16:07:34 <dcoutts_> we were doing small and big step semantics for little functional languages, adding features like let, references, etc
16:08:11 <diltsman> Ok, I figured that out...kind of, but I'm still wondering how to deal with things.  It is somewhat equivalent to try $ string "...".  However, it returns () on success.
16:08:15 <grahamhutton_> dcoutts: back to your earlier question about tricky corners --- if you haven't seen it already, it's worth taking a look at Dick Kieburtz's work on PLogic as an example of the kind of complexities that are involved: http://citeseer.ist.psu.edu/cache/papers/cs/27399/ftp:zSzzSzcse.ogi.eduzSzpubzSzpacsoftzSzpaperszSzPlogic.pdf/kieburtz02plogic.pdf
16:08:17 <lambdabot> http://tinyurl.com/2gjwyn
16:08:33 * dcoutts_ looks
16:09:33 <grahamhutton_> my experience has been that lazy languages such as Haskell promise simple reasoning, but the deeper you dig, the more complex it gets
16:09:56 <byorgey> diltsman: maybe paste what you have?
16:10:00 <augustss> it's that darn non-termination
16:10:02 <byorgey> ?paste
16:10:03 <lambdabot> Haskell pastebin: http://hpaste.org/new
16:10:15 <grahamhutton_> indeed -- maybe these dependent types people have something :-)
16:10:21 <diltsman> parser' = do s1 <- reserved "abcd"
16:10:35 <dcoutts_> grahamhutton_: though it's looking at a static semantics, not an operational semantics which seems easier
16:10:51 <cpst> grahamhutton_: have fun reasoning about the space complexity of a Haskell program with a real Haskell compiler
16:10:52 <diltsman> The problem with that is that reserved returns () whether or not it succedes.  There is no way to figure out if it worked without using the <|> operator.
16:10:55 <cpst> :-D
16:10:57 * Philippa liked Neelakantan Krishnaswami's comment on clf about reasoning about space usage under lazy evaluation...
16:11:09 <byorgey> @hoogle reserved
16:11:11 <lambdabot> Text.ParserCombinators.Parsec.Token.reserved :: TokenParser st -> String -> CharParser st ()
16:11:11 <lambdabot> Text.ParserCombinators.Parsec.Token.reservedNames :: LanguageDef st -> [String]
16:11:11 <lambdabot> Text.ParserCombinators.Parsec.Token.reservedOpNames :: LanguageDef st -> [String]
16:11:25 <dcoutts_> cpst: that's something the operational semantics should tell you, what the sharing behaviour is
16:11:40 <byorgey> diltsman: what is the 'reserved' function for?  and what are you trying to do?
16:11:48 <byorgey> I'm not familiar with the 'reserved' function
16:11:58 <cpst> dcoutts_: I agree, there is such a semantics proposed, but I don't think it is respected by GHC
16:12:05 <grahamhutton_> cpst: that's another interesting point -- functional languages are supposed to make it easier to reasoning about what programs mean (denotational), but this often comes at the price of not being able to say much about what they do (operational)!
16:12:29 <diltsman> reserved is in Parsec.  It tests the thing as a reserved keyword.
16:12:46 <diltsman> It allows you to parse as a reserved word rather than just a string.
16:13:06 <cpst> grahamhutton_: well, in the Standard ML world they are pretty big into being safe-for-space, so at least some people in the functional programming world get it ;-)
16:13:09 <Philippa> grahamhutton_: it's a shame really, because they potentially offer the opportunity to treat the two orthogonally. Show denotationally that this can be done safely with mutation, state operationally that it should then be done that way (or not)
16:14:07 <grahamhutton_> cpst: yes, operational reasoning is much simpler in ML
16:14:38 <diltsman> Basically I want it to be equivalent to (do reserved "...1"...)<|>(do reserved "...2"...)<|>...  For each string in a list.
16:14:55 <Philippa> there's a lot to be said for a pure ML as a basis for a practical language
16:14:58 <diltsman> I just can't figure out how to do that from a list of strings.
16:15:19 <cpst> grahamhutton_: it would be interesting to see somebody make a practical optimizing Haskell compiler that is safe-for-space
16:15:51 <cpst> (for any of the operational semantics proposed for lazy evaluated languages)
16:16:04 <grahamhutton_> philippa: i think simon PJ got it right here: the main advantage of lazyness is that it keeps the language pure
16:16:36 <byorgey> diltsman: something like (foldl1 (<|>) (map reserved strs)) ?
16:16:52 <Philippa> I've done things where it was helping maintain reasonable operational behaviour, but then enough people have the opposite experience
16:17:01 <tehgeekmeister> is there some subtractive analogue of (++)?
16:17:16 <byorgey> tehgeekmeister: there's (\\)
16:17:26 <byorgey> > [1..10] \\ [3,5,7]
16:17:27 <Philippa> most of the time I'd take total semantics over non-strict
16:17:29 <lambdabot>  [1,2,4,6,8,9,10]
16:17:37 <byorgey> tehgeekmeister: is that what you're looking for?
16:17:39 <tehgeekmeister> ?src (\\)
16:17:40 <lambdabot> (\\) = foldl (flip delete)
16:17:48 <tehgeekmeister> ?src delete
16:17:48 <lambdabot> delete = deleteBy (==)
16:17:51 <diltsman> byorgey: Yeah, something like that.  I'm gonna play with that.  Thanks for the suggestion.
16:18:15 <tehgeekmeister> byorgey: thanks.
16:18:25 <diltsman> byorgey: I'm mostly a C/C++ programmer, so I'm still getting the hang of Haskell, folds, etc.
16:18:41 <byorgey> diltsman: yup, it takes some getting used to =)
16:21:09 <cpst> I asked a question the other day, but maybe more people are here now
16:21:26 <cpst> what is the status of exhaustiveness checking for pattern matching with GADTs?
16:22:25 <jsnx> diltsman: the best thing about Haskell relative to C/C++ -- no semicolons!
16:22:35 <jsnx> diltsman: all this monads stuff is worth it for that
16:23:01 <Philippa> oh, it's better
16:23:08 <Philippa> no semicolons, but you can still overload them...
16:24:05 <osfameron> on the other hand... has anyone ever written a tutorial on semicolons?
16:24:29 <Philippa> I've seen people confused about what goes where
16:24:31 <jsnx> osfameron: what would be in it?
16:24:36 <Philippa> especially moving from one of Pascal or C to the other
16:25:08 <osfameron> jsnx: certainly nothing about nuclear waste processing plants :-)
16:25:09 <jsnx> Philippa: i hope i don't sound like a goof, but it was `letrec` and `;` that made me decide for Haskell over O'Caml
16:25:39 <jsnx> before i knew anything about FP
16:26:13 <jsnx> osfameron: is there really something worth having a tutorial about?
16:26:17 <Philippa> heh. Yeah, Haskell's got much nicer surface syntax
16:26:31 <jsnx> yes it does. the sugary sweetness of it...
16:26:34 <lament> ;;
16:26:38 <jsnx> ack!
16:26:50 <cpst> but you don't need to use ;; unless you are working interactively?
16:26:51 * jsnx melts, convulses
16:27:11 <lament> jsnx: do you play nethack or something? :)
16:28:08 <jsnx> lament: no
16:28:39 <jsnx> lament: but all my error messages on irssi are derived from it :)
16:28:54 <osfameron> jsnx: well, that's more or less my point, feeble as it is: monads are more powerful than semicolons, but more confusing (as evidenced by the relative number of tutorials about them)
16:29:14 <jsnx> osfameron: okay, i see now
16:29:16 <lament> more powerful things do tend to be more confusing
16:29:29 <jsnx> osfameron: sometimes, sarcasm does not work on the intarwebz
16:29:51 <osfameron> jsnx: very true
16:30:07 <tehgeekmeister> i just started learning erlang (got programming erlang for christmas) and i really didn't realize how much i liked haskell's type system until i got back to a dynamic language.
16:30:19 <tehgeekmeister> i can't use :t anymore!
16:33:12 <OceanSpray> SCHTOOPEED?
16:34:32 <Cale> http://www.marriedtothesea.com/120707/wizard-needs-food.gif
16:35:09 <Valodim> I don't get it
16:36:32 <Cale> "Wizard needs food badly" was a phrase first used in the arcade game Gauntlet, and later replicated in Nethack.
16:37:11 <Valodim> ah
16:37:18 <Valodim> <- ToME
16:37:21 <Valodim> never played nethack much :)
16:37:54 <osfameron> I always found that I died before I understood where the fun was
16:38:26 <osfameron> usually killed by a mold or a bat or something while trying to remember the key combination to fight or run away
16:38:37 <Valodim> hehe
16:41:10 <Cale> The grid bug bites!
16:41:29 <OceanSpray> That cartoon is a veiled critique of the relationship between computer scientists and industry programmers.
16:41:43 <OceanSpray> That's how I interpret it, given the context of this channel.
16:42:41 <lament> that's pretty scary
16:42:50 <lament> because it's pretty obvious what happens in the next panel
16:43:25 <lament> actually i suppose the wizard can't cast fireball (too hungry), but he probably has an offensive wand or two
16:43:36 <lament> the guy is screwed.
16:43:53 <osfameron> please stop waving that offensive wand around in public!
16:45:45 <angelsofdust> http://www.cybertown.com/cgi-bin/jail/place?plc=jail&ac=place&ID=0000000000000033&force=s
16:45:47 <lambdabot> Title: Cybertown - Civilization for the Virtual Age, http://tinyurl.com/29bctu
16:45:51 <angelsofdust> http://www.cybertown.com/cgi-bin/jail/place?plc=jail&ac=place&ID=0000000000000033&force=s
16:45:53 <lambdabot> Title: Cybertown - Civilization for the Virtual Age, http://tinyurl.com/29bctu
16:45:58 --- mode: ChanServ set +o Cale
16:46:30 <Cale> oh, the ban list is full
16:47:05 --- mode: Cale set -b *!*=Horehoun@*.160.163.127.cable.dyn.cableonline.com.mx
16:47:30 --- mode: Cale set +b *!*@77.54-242-81.adsl-dyn.isp.belgacom.be
16:47:43 <Cale> He'll probably get klined anyway.
16:48:36 <tehgeekmeister> can guards be used in case expressions?
16:49:06 <Saizan> > case 1 of x | False -> "foo" | True -> "bar"
16:49:08 <lambdabot>  "bar"
16:49:12 <mrd> yes
16:53:12 <opqdonut> function definitions too
16:53:45 <opqdonut> > let o x y | x > y = GT | x < y = LT | otherwise = EQ in o 1 2
16:53:46 <lambdabot>  LT
17:00:56 <OceanSpray> Now that I know that guards exist,
17:01:20 <OceanSpray> I'm afraid that, in my old code, I could have used them to make things much shorter and clearer
17:01:28 <monochrom> Yes.
17:02:06 <OceanSpray> Problem is, I can't tell where I could have been using guards by looking over the code.
17:02:06 <mrd> esp. since if-then-else is so clunky
17:14:52 <Saizan> ghc stores needed packages in .hi files, is there some option or ghc api function to query that information?
17:28:00 <vali> hmm
17:28:14 <Valodim> Parser/DFA.hs:77:0-78:
17:28:14 <Valodim>     parse error on input `--===========================================================================--'
17:28:16 <Valodim> wtf?
17:28:23 <Valodim> parse error on something starting with --?
17:30:13 <Saizan> > let (--=) a b = a + b in 3 --= 4
17:30:14 <lambdabot> Unbalanced parentheses
17:31:10 <Saizan> mmh, i'd try with a space after the first -- anyhow
17:31:45 <Valodim> now it changed to
17:31:46 <Valodim> Parser/DFA.hs:81:0: parse error (possibly incorrect indentation)
17:32:04 <Saizan> so there's something broken around it
17:35:48 <Valodim> hm, it simply doesn't seem to like this line
17:35:48 <Valodim> --===========================================================================--
17:36:47 <dylan> -- is a comment
17:37:45 <dylan> so, let (--=) ... is the same as let (
17:37:57 <dylan> which is clearly an unclosed paren
17:38:08 <Valodim> I know that
17:38:13 <Valodim> and there is nothing like that in the file
17:38:29 <Valodim> I removed all of those --==========-- lines and it works now
17:39:08 <ricky_clarkson> I bet your code's more readable too!
17:39:13 <dylan> heh, --[^ ] is in fact a symbol.
17:39:19 <Valodim> it's not mine
17:39:23 <Valodim> it's the Lexer library
17:55:42 <OceanSpray> Science!
17:55:55 <nolrai> > do {"abc", "defg"}
17:55:55 <lambdabot>  Parse error at "," (column 10)
17:56:34 <nolrai> > sequence ["abc", "defg"]
17:56:36 <lambdabot>  ["ad","ae","af","ag","bd","be","bf","bg","cd","ce","cf","cg"]
17:57:04 <nolrai> > sequence_ ["abc", "defg"]
17:57:05 <lambdabot>  [(),(),(),(),(),(),(),(),(),(),(),()]
17:57:25 <nolrai> > sequence_ ["abc"]
17:57:26 <lambdabot>  [(),(),()]
17:57:29 <nolrai> > sequence ["abc"]
17:57:30 <lambdabot>  ["a","b","c"]
18:00:08 <nolrai> > do {"abc"}
18:00:08 <lambdabot>  "abc"
18:00:18 <nolrai> > do {"abc", "cdef"}
18:00:18 <lambdabot>  Parse error at "," (column 10)
18:00:39 <nolrai> > do {Nothing, Just 1}
18:00:40 <lambdabot>  Parse error at "," (column 12)
18:00:45 <Saizan> do "abc"; "cdef"
18:00:46 <nolrai> > do {Nothing; Just 1}
18:00:46 <lambdabot>  Nothing
18:00:52 <nolrai> > do {"abc"; "cdef"}
18:00:52 <lambdabot>  "cdefcdefcdef"
18:01:36 <nolrai> @src sequence
18:01:37 <lambdabot> sequence ms = foldr k (return []) ms
18:01:37 <lambdabot>     where
18:01:37 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
18:06:00 <nolrai> sequence [Nothing, Just 1]
18:06:06 <nolrai> > sequence [Nothing, Just 1]
18:06:07 <lambdabot>  Nothing
18:18:32 <nolrai> > let ex = [[c..'f']|c <- "abcd"] in do {(a,b) <- zip ex [1..]; return $ a ++ show b}
18:18:34 <lambdabot>  ["abcdef1","bcdef2","cdef3","def4"]
18:18:58 <nolrai> > let ex = [[c..'f']|c <- "abcd"] in do {(a,b) <- zip ex [1..]; a' <- a; return $ a' ++ show b}
18:19:00 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Char'
18:19:13 <nolrai> > let ex = [[c..'f']|c <- "abcd"] in do {(a,b) <- zip ex [1..]; a' <- a; return $ a' : show b}
18:19:18 <lambdabot>  ["a1","b1","c1","d1","e1","f1","b2","c2","d2","e2","f2","c3","d3","e3","f3",...
18:19:41 <nolrai> > let ex = [[c..'d']|c <- "abc"] in do {(a,b) <- zip ex [1..]; a' <- a; return $ a' : show b}
18:19:42 <lambdabot>  ["a1","b1","c1","d1","b2","c2","d2","c3","d3"]
18:21:57 <ricky_clarkson> Wow, it's only a couple of steps from a loop unroller!
18:23:11 <Cale> > sequence [id, reverse, map toUpper] "hello"
18:23:13 <lambdabot>  ["hello","olleh","HELLO"]
18:23:44 <Cale> > sequence ["abc","123"]
18:23:45 <lambdabot>  ["a1","a2","a3","b1","b2","b3","c1","c2","c3"]
18:25:46 <okgo> hello
18:26:06 <Japsu> hmm
18:28:22 <okgo> do you know any good library for prime numbers in Haskell?
18:28:49 <oal``> okgo, you mean for something beyond naive methods?
18:29:23 <Japsu> @src sequence
18:29:24 <lambdabot> sequence ms = foldr k (return []) ms
18:29:24 <lambdabot>     where
18:29:24 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
18:29:50 <okgo> oal``:  I guess I could write my own naive methods, but other programming languages have already prime numbers libraries, including gcd and other basic number theory algorithms.
18:30:11 <oal``> oh, you have gcd in standard prelude
18:30:25 <oal``> but for high stuff of number theory...
18:30:41 <oal``> you could take a look at DoCon
18:31:06 <oal``> but I'd suggest writing your own library
18:31:16 <okgo> oal``:  Am I wrong in believing that in the Haskell community there isn't too much "code" or "library" reuse? I got this impression
18:31:28 <oal``> or come back in a year, by then I hope to have mine done ;)
18:31:54 <oal``> okgo, meh. there is some heavy libraries work
18:32:07 <oal``> but I suppose haskell people are less interested in number theory
18:32:25 <byorgey> okgo: check out hackage.haskell.org, lots of code/library reuse =)
18:32:26 <okgo> oal``: that's odd. it strikes me as a very mathematical language.
18:32:34 <oal``> it
18:32:35 <oal``> is
18:32:55 <oal``> but there are the cs people, who are at the ball
18:33:13 <byorgey> okgo: try http://www.polyomino.f2s.com/david/haskell/main.html, some number theory stuff there
18:33:14 <lambdabot> Title: Haskell for Maths
18:33:21 * oal`` is a diligent exception, I am actually a mathematician
18:33:24 <oal``> meh
18:33:49 <okgo> oal``:  that's very cool (that you are a mathematician)
18:34:08 <oal``> byorgey, I haven't taken a deep look at haskell for math, but it seems to be a rather basics + finiancial math library
18:34:09 <okgo> thank byorgey
18:34:12 <oal``> okgo, thanks
18:34:33 <oal``> byorgey, AFAIR it's horrible at multiplicating polynomials
18:35:27 <oal``> O(n^2) for you, better than my naive version, worse than numeric prelude and far worse than subquadratic methods
18:35:50 <oal``> btw, okgo, numeric prelude is a possibility
18:36:04 <okgo> oal``: looking at it
18:36:26 <oal``> bt I would take some math library, peferably from a functional language and try to port in to haskell
18:36:53 <oal``> that seems to be a decent and quite a fast way to obtain your library, I persume, you want to do something with it
18:37:06 <okgo> oal``: that's an interesting exercise
18:37:36 <oal``> you could take a look a R project, they use scheme and have *plenty* of stastistical stuff
18:37:47 <oal``> but I am not sure about fast sieves
18:38:38 <oal``> okgo, yes. but my way is different. I'd like to fondle with the algorithms themselves, porting a library from another language is not a sollution for me. at most a hint.
18:39:48 <oal``> oh, it seems, it'll be 4 am here soon, need to get some sleep...
18:43:02 <okgo> oal``: night
18:50:48 <okgo> Style question. Do I do print(show(sum[1..100])) or print $ show $ sum[1..100]?
18:51:50 <okgo> nevermind
18:51:59 <okgo> the show is not needed
18:52:21 <Cale> I usually use  f . g . h $ x
18:52:32 <Cale> Try to avoid abusing the associativity of $
18:52:55 <okgo> Cale: so the . is good? Like print . sum [1..100]?
18:53:13 <Cale> print . sum $ [1..100], or print $ sum [1..100]
18:53:44 <okgo> Cale thanks
18:54:39 <Cale> Using composition as much as possible also gets you into the right mindset for functional programming.
18:56:34 * ricky_clarkson clicks his fingers and sits down at the keyboard to compose a function.
18:57:50 <ricky_clarkson> How might one, to quote Cale, "abus[e] the associativity of $"?
19:00:35 <allbery_b> Cale thinks it should associate in the other direction, IIRC, and prefers that people not fix the current behavior in stone
19:01:44 <okgo> allbery_b: I understand Cale's logic, but isn't print $ sum cleaner than print . sum $ ?
19:02:08 <EvilTerran> in some ways. vice-versa in others.
19:02:15 <allbery_b> yeh
19:02:47 <Cale> okgo: It's fewer characters to use  print $ sum [1..10], but print $ sum doesn't mean anything on its own, whereas print . sum does.
19:04:05 <EvilTerran> and the sum $ [1..10] remains meaningful, likewise
19:04:30 <chessguy> @type print . sum
19:04:33 <lambdabot> forall a. (Num a) => [a] -> IO ()
19:05:19 <okgo> Cale: I think I see what you mean. But either are correct, right?
19:05:37 <ricky_clarkson> :t print $ sum
19:05:38 <lambdabot>     No instance for (Show ([a] -> a))
19:05:38 <lambdabot>       arising from use of `print' at <interactive>:1:0-4
19:05:38 <lambdabot>     Possible fix: add an instance declaration for (Show ([a] -> a))
19:05:41 <Cale> Either  print . sum $ [1..10]  or  print $ sum [1..10]
19:05:55 <ricky_clarkson> :t (print $ sum)
19:05:56 <lambdabot>     No instance for (Show ([a] -> a))
19:05:56 <lambdabot>       arising from use of `print' at <interactive>:1:1-5
19:05:56 <lambdabot>     Possible fix: add an instance declaration for (Show ([a] -> a))
19:05:56 <okgo> thanks
19:06:09 <ricky_clarkson> I don't understand why there's no type sig.
19:06:16 <chessguy> okgo, either are correct, and Cale's objection isn't one you'll hear much of, whether valid or not
19:06:44 <Cale> okgo: In general, the thing to really avoid is where $ is repeated, like f $ g $ h $ x
19:06:54 <Cale> You can always replace that with f . g . h $ x
19:06:55 <EvilTerran> :t sum
19:06:55 <lambdabot> forall a. (Num a) => [a] -> a
19:07:05 <EvilTerran> @instances Show
19:07:06 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), All, Any, Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, Product a, ST s a, Sum a, [a]
19:07:08 <EvilTerran> :t print
19:07:08 <lambdabot> forall a. (Show a) => a -> IO ()
19:07:21 <chessguy> @pl \xs -> print $ sum xs
19:07:21 <lambdabot> print . sum
19:07:25 <EvilTerran> you can only print things that instantiate show
19:07:29 <Cale> which is nicer to refactor, and doesn't abuse the fact that $ is right associative
19:07:33 <EvilTerran> and functions don't
19:07:45 <Cale> (when it really ought to be left associative, like function application is)
19:07:45 <EvilTerran> that's why
19:08:25 <okgo> ok, since I want to learn Haskell seriously, what can I do to really become good at it?
19:08:43 <EvilTerran> @go Project Euler
19:08:44 <lambdabot> http://projecteuler.net/
19:08:44 <lambdabot> Title: Project Euler
19:08:49 <chessguy> same thing you should do to learn any language: write a chess engine in it!
19:08:54 <EvilTerran> is good to get your general proficiency up in haskell
19:09:00 <Cale> okgo: I suppose after you've read the tutorials a bunch and played around, write something that you've been interested in writing.
19:09:08 <Cale> (Or get hired to write something ;)
19:09:22 <chessguy> ha. good luck with that
19:09:50 <EvilTerran> a lot of the early Project Euler problems are wonderfully trivial in haskell
19:10:11 <Cale> There's not so many people who hire Haskell programmers, but those who do need Haskell programmers will look pretty hard to find you. :)
19:10:24 <okgo> Cale: well, I didn't read too many tutorials so far. A friend of mine suggested that I try to follow SICP in Haskell
19:10:43 <ricky_clarkson> okgo: The metacircular evaluator might be a tad tricky.
19:10:57 <ricky_clarkson> (if you try to make it evaluate Haskell)
19:11:02 <chessguy> yeah, haskell doesn't have quite the "code as data" mentality
19:11:17 <okgo> oh ok
19:11:24 <Cale> That might be interesting. I at least recommend watching the lectures. It's interesting how some of the idioms they talk about have turned into language features, and how some of the open problems have been solved.
19:11:45 <okgo> Cale: I assume you talk about Monads, for example.
19:11:49 <Cale> yeah
19:11:58 <chessguy> every programmer should have to watch the SICP lectures
19:12:01 <ricky_clarkson> I suggest following SICP in Scheme. ;)
19:12:33 <okgo> I guess what I need is a good tutorial that I can read over a week or so and then I can start learn by "doing"
19:12:52 <Cale> Well, one of the commonly recommended ones is "Yet Another Haskell Tutorial"
19:12:59 <Cale> The wikibook is also reasonable.
19:13:08 <Cale> When you get to monads, I have some tutorials :)
19:13:21 <EvilTerran> http://projecteuler.net/index.php?section=problems&id=1 <- you can probably do that one already ;)
19:13:22 <lambdabot> Title: Problem 1 - Project Euler
19:13:34 <Cale> (or just ask and I'll give you an interactive tutorial on the spot :)
19:13:36 <loupgaroublond> what is SICP?
19:13:42 <okgo> EvilTerran: I've done that, and working through the second one.
19:13:50 <Cale> loupgaroublond: Structure and Interpretation of Computer Programs
19:14:08 <EvilTerran> student internet cervise providings!
19:14:21 <Cale> loupgaroublond: It's a famous intro to CS course using scheme.
19:14:31 <loupgaroublond> cale, is that the MIT one?
19:14:34 <Cale> Yep.
19:14:43 <ricky_clarkson> @go sicp
19:14:44 <lambdabot> http://mitpress.mit.edu/sicp/
19:14:44 <lambdabot> Title: Welcome to the SICP Web Site
19:14:47 <Cale> The book and lectures are all online.
19:14:57 * EvilTerran doubts anyone else here is common enough to watch fonejacker, so that reference is probably wasted
19:14:58 <loupgaroublond> i have that link floating aronud somewhere...
19:15:06 <Cale> It shows its age just slightly.
19:15:09 <ricky_clarkson> loupgaroublond: Follow it.
19:15:22 <Cale> (But moreso, it's way ahead of its time)
19:16:19 <ricky_clarkson> @quote Peyton
19:16:19 <lambdabot> syntaxfree says: Many people think the core ideas behind Haskell came from academic luminaries such as Philip Wadler and Simon Peyton-Jones. What actually happened is that during a functional
19:16:19 <lambdabot> programming conference, some key academics were teleported to the Deep Complex Universe. In the Deep Complex Universe some Gnomes were having Tangling problems. Wadler & friends solved their
19:16:19 <lambdabot> problems and as a reward the Tangled Gnomes gave them the S
19:16:33 <ricky_clarkson> gulp
19:16:46 <loupgaroublond> it is, it's on that list of projects i could do to become a better programmer, that i have, but i keep getting caught in other projects
19:18:11 <chessguy> "gave them the S"?
19:18:51 <ricky_clarkson> S Combinator?
19:19:11 <monochrom> probably something like: the Super Programming Language.
19:19:31 <monochrom> The short is that Haskell is that Super Programming Language.
19:20:30 <monochrom> The long is that the Super Programming Language is too advanced, and the researchers are slowly divulging bits of it into Haskell revisions over decades so we don't notice anything odd.
19:21:51 <okgo> yes! I solved Euler 2
19:22:02 <byorgey> okgo: \o/
19:22:26 <okgo> wanna take a look at the code?
19:23:36 <durka> are there answers somewhere to check
19:23:51 <hpaste>  okgo pasted "my euler2" at http://hpaste.org/4667
19:24:07 <Cale> durka: yeah, on the main Haskell site, there's a page with solutions to most or all of them
19:24:44 <Cale> http://www.haskell.org/haskellwiki/Euler_problems
19:24:45 <lambdabot> Title: Euler problems - HaskellWiki
19:34:27 <durka> @src sequence_
19:34:28 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
19:35:41 <snhmib> uhm, it this the place to ask about the parsec module?
19:35:59 <skew> yes
19:36:30 <skew> at least if you have to ask where to talk about it :)
19:36:55 <snhmib> oO
19:38:01 <snhmib> http://rafb.net/p/zgEI3664.html <- what is wrong here?
19:38:02 <lambdabot> Title: Nopaste - No description
19:38:33 <snhmib> it should parse expressions llike {+ 1 {+ 3 4}}, which works, but not for {- 1 2} :S
19:39:36 <skew> Ah - that's the LL1 stuff - it commits to the first alternative that matches at least one char, unless you use "try"
19:40:00 <snhmib> !
19:40:12 <snhmib> d'oh
19:40:13 <skew> so it sees the '{' and things parseAdd is the way to go
19:40:26 <skew> I'd probably factor out the braces
19:40:51 <monochrom> If you say (string "{+") and (string "{-") it will make the right choice.
19:41:18 <skew> char '{'; op <- (char '+'>>return AEAdd) <|> (char '-'>>return AESub); l <- parseExp; r <- parseExp; char '}'; return (op l r)
19:42:14 <snhmib> you can do that with datatype things?
19:42:54 <skew> sure, constructors act like functions, just spelled uppercase. Used to O'Caml?
19:43:46 <snhmib> hehe, nope
19:46:30 <ricky_clarkson> And you can dispatch on the constructor something 'was' made with.
19:46:49 <ricky_clarkson> fwiw to say 'was' in a pure FP setting.
19:47:10 <snhmib> ? you mean pattern matching
19:47:13 <snhmib> ?
19:47:23 <ricky_clarkson> Yes.
19:48:03 <snhmib> yea that's nice too =)  i'm still not very good at haskell though.. but it looks very neat!
20:28:32 <Shimei3> The Haskell FFI spec says you can only import C functions and global vars. How about custom C types? (structs)
20:28:55 * Shimei3 is assuming that's not possible either
20:30:26 <sjanssen> Shimei3: that's correct
20:30:38 <Shimei3> Okay. Thanks.
20:31:22 <sjanssen> generally you write Storable instances to convert between Haskell and C representations
20:34:15 <sw17ch> @src fmap
20:34:16 <lambdabot> Source not found. Are you on drugs?
20:34:41 <sw17ch> yes
20:34:45 <sw17ch> wait, no
21:17:47 <sw17ch> any one have a second to explain fmap and/or functors?
21:18:19 <r3m0t> hello there
21:18:28 <sw17ch> hi
21:18:57 <r3m0t> I'm not normally known for explaining
21:19:05 <r3m0t> did you understand "map" for lists?
21:19:08 <sw17ch> yes, quite
21:19:19 <sw17ch> one of my favorites :)
21:19:26 <r3m0t> mine too
21:19:39 <sw17ch> fmap :: (Functor f) => (a -> b) -> f a -> f b
21:19:39 <r3m0t> with so few functions in haskell, it's difficult to have your own favourites
21:19:45 <sw17ch> i just have a hard time grocking that
21:19:53 <sw17ch> :)
21:20:17 <r3m0t> ok, well think of a datatype that has elements in it, for example [a] -- a list
21:20:25 <sw17ch> gotcha
21:20:46 <r3m0t> there are two parts to it: 1) the structure of the list, e.g. "I'm of length 4", and 2) the contents of the list, all of which are of type a
21:21:04 <r3m0t> when you do a map, you keep (1) constant while changing (2)
21:21:44 <r3m0t> map :: (a -> b) -> List a -> List b, although in Haskell we write [a] for "List a"
21:21:54 <sw17ch> yep, following so far
21:22:03 <r3m0t> similarly, a tree has (1) its structure and (2) its contents
21:22:15 <r3m0t> and when you map over a tree, you only change (2)
21:22:43 <sw17ch> so how does fmap differ from map?
21:22:49 <sw17ch> (or are you going over functors? :))
21:23:01 <r3m0t> fmap works over any structure, including lists, trees and other things
21:23:13 <sw17ch> huh
21:23:23 <r3m0t> map only works on lists
21:23:34 <r3m0t> you can't use the "map" function on trees
21:23:39 <sw17ch> hmmm
21:23:50 <sw17ch> well, here's why i'm even asking this.. perhaps you could help...
21:23:57 <r3m0t> suredy
21:24:22 <sw17ch> i have a function which converts something like 2DK23 from base 36 (or whatever base) to an Integer
21:24:29 <sw17ch> fromBase :: Int -> String -> Int
21:24:29 <sw17ch> fromBase b r = fromJust $ let digs = ['0'..'9']++['A'..'Z']
21:24:29 <sw17ch>                           in fmap (sum . zipWith (*) (iterate (* b) 1) . reverse) .
21:24:29 <sw17ch>                           mapM (\x -> elemIndex x digs) $ r
21:24:57 <sw17ch> this is not my code... i got it quite awhile back and can't remember who first gave it to me :)
21:25:14 <r3m0t> ok
21:25:44 <sw17ch> i do'nt see the need for the fmap there as opposed to a map (since i only see a list)
21:26:20 <sjanssen> sw17ch: it isn't a list, it's a Maybe
21:28:20 <sw17ch> hmmm... alright
21:28:47 <alexj> does anyone know where the actual documentation for what is in a cabal file actually resides?
21:28:51 <sjanssen> (you can tell that it is due to the 'fromJust' applied to the result)
21:29:06 <r3m0t> there's hoogle
21:29:21 <sjanssen> alexj: have you checked the cabal manual?
21:29:45 <sw17ch> i had found that. I'm still a bit of a Haskell newbie so the more esoteric type problems still give me issues
21:29:52 <alexj> I found a description of the data structure used to represent cabal files, but it is not well documented.
21:30:35 <sjanssen> alexj: http://www.haskell.org/cabal/release/latest/doc/users-guide/x30.html#pkg-descr
21:30:38 <lambdabot> http://tinyurl.com/2hxddg
21:31:07 <sw17ch> well, my function aside, i know there's another one in a non-prelude module that does exactly what i want
21:31:11 <tehgeekmeister_> ?src sum
21:31:12 <lambdabot> sum = foldl (+) 0
21:31:21 <sw17ch> but can't rememberwhat it is
21:32:32 <alexj> sjanssen: thanks.  that document is not formal about syntax.
21:32:44 <alexj> it says nothing about begin mime or yaml or whatever.
21:35:20 <sw17ch> what's the complementary function to Numeric.showIntAtBase ?
21:35:46 <sjanssen> sw17ch: readInt
21:36:00 <sw17ch> there it is, right in front of my nose
21:36:30 <sjanssen> alexj: I don't think it is any of those, it's a made-up syntax
21:36:45 <sjanssen> alexj: the source might be the best place to look?
21:37:12 <alexj> sjanssen: yes that is what I figured.  it has other weirdnesses as well.
21:38:35 <alexj> notably, it lacks a repo url or repo access pattern.  and the package-url does not have a defined format.
21:38:57 <tehgeekmeister_> are there any extensions to haskell that do anything along the lines of erlang's bit syntax?
21:39:32 <sjanssen> alexj: a 'repo' field was proposed a while back, but I don't think anything was done about it (IIRC)
21:40:21 <sjanssen> @google haskell bitsyntax
21:40:22 <lambdabot> http://www.haskell.org/pipermail/haskell/2006-September/018549.html
21:40:22 <lambdabot> Title: [Haskell] BitSyntax for Haskell
21:42:17 <alexj> sjanssen: also the freeform concept is lovely.  what charactersets are allowed? etc.
21:44:44 <sjanssen> alexj: latin1 in practice, due to infelicities in GHC's IO system
21:45:46 <alexj> sjanssen: uh ok.  I think cabal needs cleanup in a major way.
21:46:10 <alexj> may take a shot at posting something tomorrow.
21:46:19 <sjanssen> alexj: why?
21:46:32 <alexj> this stuff makes it a little unusable.
21:47:30 <alexj> yaml, xml, or json have the nice property of having standard parsers and not giving you weird surprises.
21:47:51 <alexj> having a repo field would be nice (searchpath uses repo info).
21:48:38 <alexj> forcing explicit enumeration of all the haskell files in the repo is sort of annoying and basically means you end up wanting a tool to generate cabal files.
21:50:56 <alexj> and that is in addition to the build-depends messiness.
21:51:22 <sjanssen> "messiness"?
21:51:27 <alexj> and the ambiguity between module name scope and package name scope.
21:51:33 <sjanssen> oh, the mere fact that it exists?
21:51:46 <sjanssen> instead of automatically determining them from module imports?
21:51:53 <alexj> I'm a little tired so I may not be communicating well right now.
21:52:45 <alexj> I think build-depends is messy even if you assume that module names have only package scope.
21:53:42 <alexj> since module names currently have program scope, the problem is worse.
21:54:33 <sjanssen> I think that's beyond Cabal's scope -- more in GHC's area
21:55:15 <sjanssen> or even Haskell', since Haskell '98 only considers a single module namespace
21:55:26 <mudge> hello
21:56:50 <bos> @seen dcoutts
21:56:50 <lambdabot> dcoutts is in #gentoo-haskell, #haskell, #ghc and #haskell-overflow. I don't know when dcoutts last spoke.
21:58:37 <alexj> sjanssen: it may be that there is a hypothetical language for which build-depends makes sense, but given the single module namespace of all current haskell implementations, haskell isn't one of them.
21:59:34 <sjanssen> alexj: we should use module names instead?
22:00:28 <alexj> searchpath maps module bases to locations on the internet.
22:00:47 <alexj> check out http://searchpath.org/default.map
22:01:12 <alexj> it currently supports any repo retrieval command and tgz files.
22:02:06 <sjanssen> software is typically developed and distributed at larger units
22:02:56 <sjanssen> (units larger than a module)
22:03:45 <sjanssen> so why not name these units as packages?  And specify that my project uses modules provided by this package?
22:04:34 <alexj> Text.XML.HaXml   http://www.haskell.org/HaXml/HaXml-1.13.3.tar.gz HaXml-1.13.3/src
22:05:23 <alexj> that is a line that tells searchpath to find any modules below Text.XML.HaXml by retrieving that tgz, unpacking it, and looking in the src directory.
22:05:45 <sjanssen> what is searchpath's story for packaging in eg. a Linux distribution?
22:06:07 <alexj> not sure I understand the question.
22:06:51 <sjanssen> you're familiar with apt or rpm?
22:07:09 <alexj> not in detail.
22:07:56 <sjanssen> a rough idea is plenty.  They're just binary distributions with some metadata, like dependencies
22:07:58 <alexj> but I know that haskell source imports module names, so all you need is a way to map module names to procedurs to find and retreive those modules.
22:09:02 <alexj> searchpath assumes source distribution.
22:09:41 <alexj> otherwise it can't look at the source and figure out the imports and the go retrieve them.
22:10:23 <alexj> here is how to get searchpath to retrieve a darcs repo with a particular tag: HAppS.State    "darcs get --partial  --tag=0.9.1.3 http://happs.org/HAppS/HAppS-State" HAppS-State/src
22:11:03 <alexj> It knows that if a package imports HAppS.State.Foo there is a chance that this repo will have it.
22:11:36 <alexj> otherwise it tries other lines in the module maps that also start with HAppS.State.Foo or HAppS.State or HAppS.
22:12:16 <alexj> not that HAppS.StdMain happens to be in the same repo so there is line that looks like this in the mapfile: HAppS.StdMain    "darcs get --partial  --tag=0.9.1.2 http://happs.org/HAppS/HAppS-State" HAppS-State/src
22:12:27 <alexj> does that make sense?
22:12:37 <sjanssen> yes
22:20:35 <Jomyoot> Is compiled Haskell code = obfusucated?
22:22:21 <alexj> gnight.
22:22:24 <oerjan> i've heard ugly things about the C intermediate version, especially after the Evil Mangler (in Perl) phase.
22:23:32 <oerjan> but they've changed ghc to use its own code generator rather than the via-C path more often.
22:24:15 <oerjan> oh and ghc completely rewrites your code with a lot of optimizations, so in that sense yes...
22:28:39 <skew> Are there any pretty printing libraries designed for interactive use?
22:29:18 <skew> That help map selections from rendered text back to the expression, and maybe have some clever incremental re-rendering for resising?
22:30:07 <Yurivilca> http://digg.com/2008_us_elections/Mike_Huckabee_If_you_vote_for_me_you_live_if_you_don_t
22:30:09 <Yurivilca> Check out this candidate's latest psychotic utterance!
22:53:46 <wy> Is there a different notion of "single-threadedness" in lazy languages?
22:58:57 <bparkis> is it practical to have a pure functional language without GC?
22:59:06 <bparkis> with explicit memory management
23:00:36 <bparkis> just curious not because it would be desirable, but because it would be interesting to see how something like that might be done
23:10:09 <wy> augustss: Are lazy languages by nature "multi-threaded"?
23:13:29 <skew> bparkis: http://lambda-the-ultimate.org/node/2551
23:13:30 <lambdabot> Title: Monadic and Substructural Type Systems for Region-Based Memory Management | Lamb ...
23:14:04 <skew> wy: that's probabaly a different sense of single-threaded
23:14:40 <skew> wy: In a pure language any operation on a data structure has to return a new version
23:15:06 <skew> wy: but if you don't keep a reference to old versions that's "single-threaded", as opposed to "persistant"
23:15:23 <wy> I'm reading Wadler's another monad paper. And a little confused about the secton about arrays
23:16:13 <skew> If you know the array is single-threaded, then you can make the "new" version by actually changing the array entry, because the old version isn't being used any more
23:16:24 <bparkis> well skew that puts itself in contrast to basic malloc/free but I am actually wondering how you might do malloc/free without violating referential transparency
23:16:47 <skew> bparkis: I think you can do malloc and free on that
23:17:07 <wy> skew: I wonder how is that implemented
23:17:47 <skew> wy: completely aside from implementation tricks, it's a lot easier to design data structures for good amortized performance if you require it to be used in a single-threaded way
23:18:27 <wy> For example: update i (eval t x) x. It is only single-threaded only if update is strict?
23:18:43 <wy> here i is index, x is an array
23:19:00 <wy> (eval t x) is something to update the entry
23:19:15 <Yurivilca> http://digg.com/2008_us_elections/Mike_Huckabee_If_you_vote_for_me_you_live_if_you_don_t
23:19:17 <Yurivilca> Check out Mike Huckabee's latest psychotic utterance!  Vote Romney 2008   He is different!!!
23:19:20 <skew> that can't be, it's using x several times
23:20:11 <wy> Because of the implicit thunk created on them?
23:20:38 <skew> no, it's only single threaded if a given value or version of x is used just once
23:21:24 <skew> like, if it was let x' = eval t x in update i 0 x'
23:23:32 <wy> But if eval doesn't return a new state, and won't affect the state?
23:24:13 <bparkis> skew: that really seems very complicated and obscuring what I'm actually after
23:24:48 <bparkis> which is, what type of mechanic would be used, in a FP setting, to denote explicit memory management?
23:26:09 <bparkis> speaking generally, what data would be passed around and how would it be used?
23:29:36 <Yurivilca> http://digg.com/2008_us_elections/Mike_Huckabee_If_you_vote_for_me_you_live_if_you_don_t
23:29:38 <Yurivilca> Check out Mike Huckabee's latest psychotic utterance!  Vote Romney 2008   He is the tech candidate that will lead America into the 21st century!
23:30:28 --- mode: ChanServ set +o bos
23:30:38 <Svrog> fp without gc: http://home.pipeline.com/~hbaker1/LinearLisp.html
23:30:39 <lambdabot> Title: ACM Sigplan Notices 27, 8 (Aug. 1992), 89-98.
23:30:46 <Svrog> http://home.pipeline.com/~hbaker1/ReverseGC.html
23:30:46 <lambdabot> Title: NREVERSAL of Fortune
23:31:08 <skew> bparkis: in general I think you need some kind of substructural type system
23:31:24 <skew> bparkis: so you can make sure you actually fed the last reference into free
23:31:30 --- kick: Yurivilca was kicked by bos (bos)
23:32:07 <bos> hmph, the banlist is full
23:34:13 --- mode: bos set -o bos
23:36:01 <jsnx> bos: what makes someone think to join #haskell to chat politics?
23:36:16 <jsnx> bos: how many people in this channel are from the EU, i wonder?
23:36:28 <allbery_b> jsnx: it's spamming all over the place
23:36:36 <bos> jsnx: it's a bot
23:36:51 <allbery_b> ops have been alerted
23:37:22 <jsnx> oh
23:37:24 <jsnx> a bot
23:37:36 <jsnx> i will never get used to them
23:40:22 <jsnx> do you think lamdabot is one of them?
23:44:04 <lambdabot> I'm a nice bot!
