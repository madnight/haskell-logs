00:00:24 <Toxaris> i consider newtype a hack, since it's not firstclass (you need to name it)
00:00:57 <atp> that's true, but it's not uncommon for there to be several ways to define an instance of any class, not just monoid.  obviously there's monad too, but also foldable for some structures, functor, etc...
00:01:09 <atp> how can you really get around that?
00:01:48 <dmwit> I read in a paper that newtype introduces an isomorphism between two types, and that the constructor you give names that isomorphism.
00:01:49 <ddarius> atp: Oftentimes there is a single "natural" way plus maybe some other useful but less "natural" ways.
00:01:54 <dmwit> I thought that was a pretty nice way of thinking about  it.
00:02:25 <ddarius> E.g. Eq on Strings has multiple possible implementations (e.g. case insensitive), but the actual one is the "natural" one.
00:02:42 <Toxaris> dmwit: but it's not "true". numbers with + and numbers with * are the *same* numbers, not just isomorphic numbers
00:02:56 <dfranke> atp: I would advocate adding something to the language along the lines of: with Monoid Maybe from Foo.Bar { ... }
00:03:30 <allbery_b> Toxaris: he's talking about how newtype works, not about using newtype to define multiple monoid instances
00:03:39 <dfranke> lexically-scoped importing of instances
00:03:43 <dmwit> Toxaris: But numbers where (?) means (*) and numbers where (?) means (+) *are* isomorphic (and not the same).
00:04:22 <allbery_b> (in essence demonstrating why newtype isn't suitable for defining multiple monoid instances, specifically because it *does* indicate an isomorphism)
00:04:39 <allbery_b> hm?
00:05:11 <ddarius> dmwit: No.  The -type- isn't the monoid.
00:05:16 <Toxaris> dmwit: thats why I want to express instance Monoid Number (+) and instance Monoid Number (*)
00:05:29 <dmwit> Yes.
00:05:38 <dmwit> I agree that there might be a nicer way to do it.
00:05:42 <dmwit> (potentially)
00:06:22 <ddarius> Functors or "theories" a la ML or OBJ respectively are probably the nicest way of handling this particular issue.
00:06:33 <allbery_b> but then how do you specify which monoid you're using?
00:06:57 <atp> ddarius: how does it work?
00:06:58 <Toxaris> and what about class (Monoid a op1, Monoid a op2) => Ring a op1 op2
00:07:34 <atp> Toxaris: you need more than a monoid, you need an abelian group for a ring...
00:07:42 <atp> Toxaris: on the (+) op anyway
00:08:07 <Toxaris> atp: okok. you see what i mean... :)
00:08:22 <ddarius> atp: Functors are roughly parameterized modules.  The problem with type classes (in this case) is that there is only one global instance.
00:08:25 <atp> Toxaris: sure, i was just being a dick :)
00:09:21 <Toxaris> allbery_b: the caller has to specify wich monoid to use, either explicitly, or using some kind of defaulting
00:09:23 <atp> ddarius: right, but if you define two monoids on one type, for example, how do you pragmatically distinguish between the two in the same code?
00:09:37 <atp> ddarius: using different ops defeats the purpose of having a class
00:09:42 <allbery_b> that's really what I was asking
00:09:54 <ddarius> atp: I was suggesting this instead of using a type class.
00:10:58 <Toxaris> yes, this goes away from the pragmatic ad-hoc polymorphism use of type classes
00:11:44 <atp> ddarius: hm, ok, so i missed that i guess.  how would i write a polymorphic function which uses a monoid operation then, if we don't have type classes?
00:12:23 <dfranke> *headdesk* *headdesk* *headdesk*
00:12:40 <Toxaris> sum :: (Monoid a (+)) => [a] -> a; sum = foldr (+)
00:12:41 <dfranke> I kant Haskell today.  I has teh dumb.
00:12:54 <Zao> dfranke: On a monday? Unheard of.
00:12:55 <Toxaris> called as   sum [1..4] with (*)  to yield product
00:13:18 <dfranke> Zao: the operative stupidity actually happened a week ago.
00:13:36 <dfranke> http://hackage.haskell.org/trac/ghc/ticket/1936#comment:6
00:13:39 <lambdabot> Title: #1936 (When lazy IO blocks, it blocks the whole runtime) - GHC - Trac
00:13:39 <ddarius> atp: Check out section 4 of "Introducing OBJ"
00:13:43 <ddarius> @google "Introducing OBJ"
00:13:44 <lambdabot> http://www-cse.ucsd.edu/users/goguen/ps/iobj.ps.gz
00:13:54 <atp> ddarius: ok, i will do that.
00:14:08 <atp> ddarius: thanks for the chat, it was stimulating. :) i think i need to hit the hay though
00:14:11 <ddarius> atp: (Actually all of OBJ is pretty cool in many ways.)
00:14:14 <ddarius> @time atp
00:14:15 <lambdabot> Local time for atp is Sun Dec  2 16:09:23
00:14:19 <ddarius> @time ddarius
00:14:21 <lambdabot> Local time for ddarius is Mon Dec  3 02:14:13
00:14:32 <atp> that appears to be wrong
00:14:44 <ddarius> atp: It asks you (is my understanding)
00:14:46 <atp> the time on my laptop must be screwed up, it's 12:14 here... i'm in PST
00:14:49 <atp> ddarius: it does
00:15:19 <atp> ddarius: the clock on my linux server must be wrong, i'm xforwarding this xchat session :p
00:16:24 <atp> anyway, i'm going to bed guys
00:16:27 <atp> see you all
00:16:31 <Toxaris> but if we have to write (sum [1..4] with (*)), we can write (foldr (*) 1), wich makes perfectly sense, given that we recently learned that list is the free monoid.
00:17:51 <ddarius> Toxaris: Indeed, foldr is closely related to the "mediating" morphism of the adjunction.
00:18:11 <Toxaris> ddarius: hmm, and that means?
00:19:21 <ddarius> Toxaris: That foldr is as special as people say it is (or were you looking for a technical response?)
00:20:31 <Toxaris> ddarius: i would have tried to understand a more technical response, but i'm equally fine with learning about it some other day
00:20:47 <Toxaris> ddarius: I understand the "foldr is super cool"-part :)
00:21:29 <ddarius> Toxaris: For this specific case, it's pretty concrete (the general notion is very simple too, but takes a small bit of background and some time to fully appreciate)
00:21:33 <xpika> I'm tempted to use string lookups to simulate objects in haskell.
00:21:49 <dmwit> I think it just means that foldr replaces constructors with an arbitrary function.
00:21:50 <lament> xpika: ouch.
00:22:05 <Taejo> xpika, what is your problem domain?
00:22:18 <xpika> vector graphics editor
00:22:53 <ddarius> Toxaris: Something being a free monoid on A, means that every function A -> B gives rise to a unique monoid homomorphism [A] -> (B,*,1) essentially via foldr (*) 1
00:22:55 <Taejo> hmm, vector graphics does seem like a rather objecty domain
00:23:13 <ddarius> foldr (*) 1 . map f (where f : A -> B) is that function
00:23:19 <lament> not a combinatorial domain?
00:23:27 <ddarius> (or using fusion, foldr ((*) . f) 1
00:24:14 <Toxaris> ddarius: [] is the free monoid here?
00:25:18 <ddarius> Toxaris: Yes.
00:25:36 <ddarius> (Or rather, to be cleare ([a],(++),[]) is the free monoid on a)
00:26:44 <ddarius> (Incidentally, freeness is (one view of) what leads to the fusion law for foldr)
00:28:56 <Plareplane> is there a reason that the arguments for f in foldr/foldl are swapped?
00:29:11 <Toxaris> ddarius: cool.
00:29:20 <ddarius> Plareplane: Yes.  The same reason why one has 'r' at the end and the other 'l'
00:32:13 <Toxaris> in a free instance of some algebra, we have "maximum structure" (for that type of algebra)? in the term algebra we even have this structure "seperated" from additional information? and using this unique homomorphism, we can "blend" these together.
00:33:38 <Toxaris> some years ago, i learned about free algebras etc., but without underlying sets. just ordinary algebraic data types. this seems to come back now in a sense.
00:34:51 <ddarius> Toxaris: I'm not sure how to interpret your sentence so maybe.  Putting it another way, a free structure doesn't assume anything it doesn't have to and thus every other such structure can be made from it by adding assumptions (identifying parts of it) in a unique manner.
00:35:26 <Toxaris> hmm, yes, "maximum structure" is not well-defined
00:35:43 <ddarius> The term algebra is (up to isomorphism) the free algebra.
00:36:13 <ddarius> (Actually, stronger than that: up to unique isomorphism)
00:37:07 <Toxaris> in a free algebra, i have as many differences as possible. my morphisms take some of these differences away
00:37:18 <ddarius> Toxaris: Indeed.
00:38:40 * ddarius needs to sleep.
00:38:56 <Toxaris> i don't want to keep you from sleeping :)
00:39:13 <Toxaris> have learned enough for today anyway
00:39:36 <Toxaris> (hmm wait, you said it isn't really midnight at your site, but afternoon?)
00:40:01 <Korollary> @localtime ddarius
00:40:19 <Korollary> it's past midnight
00:41:57 <Toxaris> so thank you, your explanations helped a lot, as always!
00:46:44 <tuomov_> Is there any way to have GHC produce more sane exception messages?
00:46:54 <tuomov_> such as including the source file and line triggering it
00:47:22 <sjanssen> @hackage loch
00:47:22 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/loch
00:47:35 <sjanssen> you can give that a try
00:47:58 <dmwit> O_o
00:48:03 <dmwit> Such a thing can be done as a library?
00:48:17 <sjanssen> dmwit: to some extent
00:48:23 <sjanssen> it's a crazy hack, though
00:48:27 <tuomov_> and hwo would one set that up?
00:48:32 <sjanssen>  failure assert "no such thing"
00:48:41 <sjanssen> tuomov_: it is well documented
00:49:07 <tuomov_> doesn't seem so to me
00:49:07 <dmwit> tuomov_: Got cabal?
00:49:28 <dmwit> (Have you used hackage or cabal before?)
00:49:28 <sjanssen> http://hackage.haskell.org/packages/archive/loch/0.2/doc/html/Debug-Trace-Location.html
00:49:28 <tuomov_> I don't get cabal
00:49:29 <lambdabot> http://tinyurl.com/2la7gt
00:49:40 <tuomov_> over-complicated wheel-reinventing
00:49:54 <tuomov_> os within an os
00:50:10 <dmwit> Yet some people still use emacs. ;-)
00:50:19 <tuomov_> I don't
00:50:50 <dmwit> Cool.  Now that we have that out of the way...
00:50:55 <dmwit> When you unpack that .tar.gz
00:51:03 <dmwit> There should be either a Setup.hs or a Setup.lhs.
00:51:32 <dmwit> You can then use "runhaskell Setup.[l]hs configure", then similarly "... build" and "... install".
00:52:22 <tuomov_> this is pure shit
00:52:24 <tuomov_> fuck convirus
00:52:27 <tuomov_> I want a fucking simple makefile
00:52:36 <tuomov_> to edit
00:52:38 <sjanssen> tuomov_: I will kick you if you continue to rant
00:52:41 <dmwit> (Of course each one rolls a 20-sided die, and if the number is over 18, it fails.  Then you have to try something else. ;-)
00:52:41 <tuomov_> instead of figuring out options to some convirus shit
00:53:00 <Sizur> i think somebody mixed up haskell for some other channel
00:53:13 <tuomov_> I will never use cabal for my haskell shit
00:53:39 <dmwit> Good, we'll keep cabal for only non-shitty Haskell things. =)
00:55:19 <tuomov_> where did this piece of shit even install my stuff
00:55:21 <tuomov_> it didn't take --prefix
00:55:39 <dmwit> The configure step should accept --prefix, I think.
00:55:46 <Sizur> i dont want to read this
00:55:54 <tuomov_> well, i didn't get ~/opt/loch...
00:56:10 <dmwit> Try ~/opt/.ghc or so?
00:56:16 <tuomov_> nope
00:56:29 <tuomov_> it installed shit somewhere in ~ since it didn't complain of permission denied, but not where I wanted it
00:56:39 <glguy> tuomov_: You've been warned already
00:56:51 <tuomov_> fuck you too
00:56:59 --- mode: ChanServ set +o glguy
00:57:04 --- mode: glguy set +b tuomov_!*@*
00:57:07 --- kick: tuomov_ was kicked by glguy (glguy)
00:57:14 <Sizur> thank you
00:57:37 --- mode: glguy set +b *!*=tuomov@*
00:57:45 --- mode: glguy set -b tuomov_!*@*
00:57:45 <dmwit> I wonder if he gets drunk or something.
00:57:59 --- mode: glguy set -o glguy
00:58:25 <earthy> PMS? :P
00:58:30 <sjanssen> dmwit: AFAICT (from reading the ion3 list), he is always like this
00:58:33 <dmwit> He doesn't come that often, but when he does come, he's pissing mad.
00:58:57 <dmwit> earthy: It all fits now! =D
00:59:56 <sjanssen> he's so crazy
01:00:30 <sjanssen> at the first mention of the word "configure" he automatically assumes it's autoconf and whines about that
01:00:49 <dmwit> Ah... is that what started the convirus thing?
01:00:57 <sjanssen> yeah
01:01:07 <dmwit> I was going to ask what convirus meant, but I figured it would just fuel the fire... =P
01:02:55 <ttfh> hmm, is there some way of catching the error when "read" fails?
01:03:04 <sjanssen> ironically, from what I know about his rants, Cabal might be a build system he'd actually like
01:03:08 <Toxaris> > reads "nonsense" :: Int
01:03:09 <dmwit> ttfh: Use reads instead.
01:03:10 <lambdabot>  Couldn't match expected type `Int'
01:03:11 <sjanssen> ttfh: yeah, use reads
01:03:12 <dmwit> :t reads
01:03:12 <lambdabot> forall a. (Read a) => String -> [(a, String)]
01:03:18 <glguy> ttfh: there is, but typically don'twant to do it that way
01:03:20 <Toxaris> > reads "nonsense" :: [(Int, String)]
01:03:33 <lambdabot>  []
01:03:47 <ttfh> aha, a possibly empty list
01:04:02 <Toxaris> > reads "14morestuff" :: [(Int, String)]
01:04:02 <lambdabot>  [(14,"morestuff")]
01:04:19 <ttfh> glguy: so there's some way of magically catching the read error?
01:04:34 <dmwit> :t catch
01:04:35 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
01:04:42 <mauke> :t evaluate
01:04:43 <lambdabot> Not in scope: `evaluate'
01:05:18 <dmwit> Turns out read throws an IOError exception up to the nearest enclosing IO computation.  (roughly)
01:05:33 <ttfh> hmm, that seems wrong
01:05:38 <glguy> asynchronous exceptions are hard to catch
01:05:49 <glguy> since they are thrown by lazy computations
01:06:07 <glguy> its hard to ensure that if they are going be to thrown that they will be throw inside your catch block
01:06:11 <dmwit> ttfh: Indeed it does, but if you think about it for a little while, you'll see why it more or less has to be that way.
01:09:07 <ttfh> Is it common to have to "wrap" stuff like this, and IO operations that might fail, into your own ErrorT-stuff?
01:09:27 <sjanssen> ttfh: not really
01:10:04 <dmwit> Unfortunately, there's several different ways to fail in Haskell, and different libraries choose different failure modes.
01:10:07 <sjanssen> ttfh: generally, Maybe and friends are preferred over exceptions when you expect a computation to fail
01:11:27 <ttfh> sjanssen: Yes, I have som of my own things that may fail, that use ErrorT, but then I want the error handling to be uniform, so I wrap IOErrors into my Error type
01:12:03 <dmwit> What IOError are you handling?
01:12:33 <dmwit> It's often considered good form to check failure conditions before doing an action.
01:12:40 <ttfh> for example, reading a file that doesn't exist
01:12:56 <dmwit> How about using "doesFileExist"?
01:13:04 <mauke> dmwit: bad idea
01:13:06 <glguy> the file could still be deleted
01:13:12 <dmwit> oh
01:13:14 <mauke> adds complexity and doesn't solve the problem
01:13:17 <glguy> between the time you checked and the time you look
01:13:34 <mauke> also, reading a file can fail for other reasons
01:14:13 <ttfh> this way, I really just forward the IOError to the user, but hh/she can decide what to do
01:25:08 <glguy> @users
01:25:08 <lambdabot> Maximum users seen in #haskell: 401, currently: 390 (97.3%), active: 12 (3.1%)
01:26:21 <goalieca> > [1,4..]
01:26:23 <lambdabot>  [1,4,7,10,13,16,19,22,25,28,31,34,37,40,43,46,49,52,55,58,61,64,67,70,73,76,...
01:26:42 <goalieca> > [65,65+9,..]
01:26:42 <lambdabot>  Parse error at "..]" (column 10)
01:26:50 <goalieca> > [65,(65+9)..]
01:26:51 <lambdabot>  [65,74,83,92,101,110,119,128,137,146,155,164,173,182,191,200,209,218,227,236...
01:27:16 <goalieca> > [65,(65+10)..]
01:27:17 <lambdabot>  [65,75,85,95,105,115,125,135,145,155,165,175,185,195,205,215,225,235,245,255...
01:27:44 <dmwit> > enumFromBy 65 10
01:27:44 <lambdabot>   Not in scope: `enumFromBy'
01:28:04 <dmwit> ?hoogle (Enum a) => a -> a -> [a]
01:28:05 <lambdabot> Prelude.enumFromThen :: Enum a => a -> a -> [a]
01:28:05 <lambdabot> Prelude.enumFromTo :: Enum a => a -> a -> [a]
01:28:18 <dmwit> > enumFromThen 65 75
01:28:19 <lambdabot>  [65,75,85,95,105,115,125,135,145,155,165,175,185,195,205,215,225,235,245,255...
01:28:44 <Toxaris> dmwit: how could there be enumFromBy? enum values have no distances
01:28:51 <Syzygy-> > [65,65,..,66]
01:28:51 <lambdabot>  Parse error at "..,66..." (column 8)
01:28:56 <dmwit> :t fromEnum
01:28:56 <lambdabot> forall a. (Enum a) => a -> Int
01:28:59 <Syzygy-> > [65,65..66]
01:29:00 <lambdabot>  [65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,...
01:29:24 <flux> syzygy-, I bet the last number after the infinite sequence of 65's is 66.
01:29:29 <Syzygy-> flux: Ayup.
01:29:36 <Syzygy-> > last [65,65..66]
01:29:42 <lambdabot> Terminated
01:30:04 <Toxaris> dmwit: hmm ok.
01:30:49 <dmwit> > let last = fmap (+1) head in last [65,65..66] -- =)
01:30:49 <lambdabot>  66
01:30:54 <Toxaris> > [65, 67 .. 82] -- no 82 here, flux
01:30:54 <lambdabot>  [65,67,69,71,73,75,77,79,81]
01:31:21 <dmwit> > [3.5, 4.5..5.5]
01:31:21 <lambdabot>  [3.5,4.5,5.5]
01:31:25 <flux> ah, right
01:31:28 <dmwit> > [3.5, 4.5..6.5]
01:31:28 <lambdabot>  [3.5,4.5,5.5,6.5]
01:32:00 <dmwit> > [3.5,4.5..6]
01:32:00 <lambdabot>  [3.5,4.5,5.5,6.5]
01:32:05 <dmwit> Surprise!
01:32:26 <Toxaris> interesting
01:32:36 <goalieca> heh.. all i was trying to do was figure out medical image slice numbers to stick in my paper
01:34:10 <Toxaris> dmwit: is it stated that enumFromTo and fromEnum relate in some way
01:34:23 <dmwit> No, I don't think so.
01:34:32 <dmwit> ?src Enum
01:34:32 <lambdabot> class  Enum a   where
01:34:32 <lambdabot>     succ                     :: a -> a
01:34:32 <lambdabot>     pred                     :: a -> a
01:34:32 <lambdabot>     toEnum                   :: Int -> a
01:34:32 <lambdabot>     fromEnum                 :: a -> Int
01:34:34 <lambdabot> [3 @more lines]
01:34:41 <dmwit> @more
01:34:41 <lambdabot>     enumFrom                 :: a -> [a]
01:34:41 <lambdabot>     enumFromThen, enumFromTo :: a -> a -> [a]
01:34:41 <lambdabot>     enumFromThenTo           :: a -> a -> a -> [a]
01:35:06 <dmwit> Well, that wasn't helpful, I thought it might show the default implementations.
01:35:15 <dmwit> ?source Prelude
01:35:15 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
01:35:44 <dmwit> ?source GHC.Enum
01:35:44 <lambdabot> GHC.Enum not available
01:36:01 <dmwit> bah
01:36:04 <dmwit> ?where Prelude
01:36:04 <lambdabot> http://www.haskell.org/onlinereport/standard-prelude.html
01:37:01 <Toxaris> For Float and Double, the semantics of the enumFrom family is given by the rules for Int above, except that the list terminates when the elements become greater than e3+i/2 for positive increment i, or when they become less than e3+i/2 for negative i.
01:37:20 <Toxaris> crazy
01:38:10 <dmwit> It looks like the default instances do, indeed, use toEnum/fromEnum.
01:40:52 <Toxaris> > map fromEnum [0.4, 0.5, 0.6]
01:40:53 <lambdabot>  [0,0,0]
01:41:30 <Toxaris> so why the funny behaviour with Float and Double arithmetic sequences?
01:41:31 <dmwit> > map fromEnum [1.4, 1.5, 1.6]
01:41:32 <lambdabot>  [1,1,1]
01:41:56 <dmwit> Toxaris: Because of banker's rounding, I think.
01:42:10 <dmwit> > map round [0.5..]
01:42:10 <lambdabot>  [0,2,2,4,4,6,6,8,8,10,10,12,12,14,14,16,16,18,18,20,20,22,22,24,24,26,26,28,...
01:42:29 <dmwit> ^_^
01:42:53 <Syzygy-> > map round [0.4..]
01:42:54 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
01:42:57 <Syzygy-> Ah.
01:45:44 <Sizur> how can i enumerate data T = A | B without specifying A in [A ..]?
01:47:36 <dmwit> [toEnum 0..] -- maybe?
01:48:48 <dmwit> > [toEnum 0..] :: [Bool]
01:48:49 <lambdabot>  [False,True]
01:49:30 <Sizur> ok i got it, it must derive (Bounded,Enum) [minBound::T ..]
01:49:46 <dmwit> That's even better.
01:50:16 <dmwit> > [minBound..] :: [Bool]
01:50:16 <lambdabot>  [False,True]
01:57:34 <bparkis> "each vertex is visited once, and for all vertices x, x is visited after the parent of x" is a sufficient condition for a preorder traversal, isn't it?
01:58:25 <dmwit> Nope.
01:58:32 <bparkis> no, what am I missing?
01:58:33 <dmwit> It doesn't specify the order of the children.
01:58:41 <bparkis> that's true it doesn't
01:59:04 <bparkis> but disregarding the order of the children
01:59:20 <dmwit> In fact, that allows you to have children from separate branches juxtaposed in your output! =/
01:59:40 <bparkis> hmm! that's a more serious problem thanks
02:08:10 <bparkis> so I can add the condition that for all vertices x, if y is a sibling of x and y is visited after x and z is a child of x, then z is visited before y
02:09:36 <bparkis> or simply "the successor of a vertex is a child of that vertex"
02:10:33 <bparkis> er no
02:11:19 <bparkis> that second one is too restrictive, better is "if a vertex has any children, its successor is one of its children"
02:11:23 <dmwit> You can do something simpler, I think.
02:11:56 <dmwit> Are you allowed to refer to a set of ancestors?
02:12:05 <dmwit> err... s/ancestors/descendants/
02:13:03 <bparkis> maybe, i have to actually prove these properties of something so they  have to be easily provable within that framework
02:13:41 <bparkis> I can prove the "if a vertex has any children, its successor is one of its children" one
02:14:16 <dmwit> Mmm, that's nice.
02:14:23 <dmwit> Are we restricting ourselves to binary trees?
02:15:10 <bparkis> no the tree is not binary
02:15:31 <bparkis> also the children are unordered
02:15:44 <dmwit> Still not good enough, though.
02:16:21 <bparkis> hmm yes you're right
02:16:28 <dmwit> =)
02:16:31 <bparkis> you could go down one branch to a leaf then go down a completely different one
02:16:43 <dmwit> exactly
02:19:12 <dmwit> bparkis: So, if we ignore the sufficient conditions for now, what is the definition of a preorder traversal?
02:19:30 <bparkis> i have none
02:19:37 <dmwit> !
02:19:41 <bparkis> besides the common sense one of how to algorithmically produce it
02:19:48 <bparkis> so i basically can make up my own conditions
02:19:56 <dmwit> What is this for?
02:20:09 <bparkis> a homework problem
02:20:42 <dmwit> It's a poor problem if you haven't defined preorder traversals.
02:21:15 <dmwit> Well, can you sketch the algorithm in Haskell for me?
02:21:17 <dmwit> Let's assume:
02:21:35 <dmwit> data Tree a = Leaf a | Branch a (Tree a) (Tree a)
02:21:45 <hpaste>  dons pasted "naive parallel tree traversal" at http://hpaste.org/4240
02:21:45 <falbani> Hi...
02:22:00 <dons> its tree night, is it?
02:22:04 <dmwit> Hi falbani!
02:22:46 <dons> sjanssen: if you get bored, there's the tree traversal/allocation benchmark from the shootout, that seems to parallelise ok. would be good to get a better strategy (needs the depth info, I think)
02:22:54 <bparkis> the general problem is to show that, given a graph G, if you start with a trivial cycle and continue adding the closest point x to that cycle immediately after the point y in the cycle that is closest to it, then the resulting cycle (over the whole graph) approximates the travelling salesman problem to within a factor of 2, so long as the edge weights in the graph satisfy the triangle inequality d(a, b) <= d(a, c) + d(c, b)
02:23:04 <bparkis> but don't get specific or say anything out loud about that please
02:23:13 <bparkis> because i don't want to feel like i'm cheating
02:23:15 <falbani> I have a question about outputting acuted characters... Ã¡ Ã© Ã­ Ã³ Ãº... (but I thinks this is more general to all extended chars)
02:23:34 <dons> do you need utf8string library?
02:23:56 <dmwit> bparkis: Right, I'll be careful.  (I've been careful so far, too. =)
02:24:48 <falbani> If I make a naive "putStrLn "Ã¡Ã©Ã­Ã³Ãº"", compile and execute under bash, I got some backslashes with numers...
02:25:01 <falbani> lambdabot: "Ã¡"
02:25:08 <dmwit> Try
02:25:14 <dmwit> > "Ã¡"
02:25:15 <lambdabot>  "\225"
02:25:30 <dons> falbani: right. you need to use the library utf8string, to get non-truncated output directly
02:25:48 <falbani> Thanks, dons.
02:25:49 <dmwit> bparkis: Ah, so this is a complete graph?
02:26:00 <dons> its really sipmle, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/utf8-string-0.2
02:26:01 <bparkis> yeah no infinite edge weights
02:26:02 <lambdabot> http://tinyurl.com/2e6gmt
02:26:19 <dons> System.IO.UTF8.putStrLn
02:26:58 <dmwit> bparkis: Cool, okay.  So what have you been thinking?
02:27:06 <falbani> dons: will I have to make changes to my code (except from importing that)?
02:28:14 <dons> falbani: i hope not. you will have to hide the default putStrLn though
02:28:31 <bparkis> well, I know how to solve it except for how to define a preorder traversal in a way i can prove in this framework-basically, if I can show that the resulting cycle is a preorder traversal of the MST of G generated by Dijkstra's algorithm, then I am done
02:29:34 <dons> lots of interesting performance details in the backend, http://eigenclass.org/hiki/legitimate-microbenchmarks (see Simon marlow's comments at the end)
02:29:39 <lambdabot> Title: eigenclass - Legitimate uses of micro-benchmarks: parameter passing and function ...
02:29:41 <bparkis> because a MST is a lower bound on a TSP cycle and a preorder traversal with the triangle inequality does somewhat less than traverse every edge of the tree twice
02:29:48 <falbani> dons: look what ghc says:        fuente.hs:26:7: parse error on input `System.IO.UTF8.putStrLn'
02:30:10 <dons> falbani: after you build the utf8string package, import System.IO.UTF8
02:30:17 <dons> then use putStrLn
02:30:28 <dons> and hide the default putStrLn
02:31:30 <dmwit> bparkis: Well, okay, but the MST might not be a binary tree, right?
02:31:38 <bparkis> yes it probably isn't
02:31:42 <dmwit> Anyway, it doesn't change the idea.
02:32:19 <bparkis> for my purposes a preorder traversal goes like, visit parent, then preorder traverse each child, in some order
02:32:27 <falbani> dons: oops... i'm under a Debian Etch, using the GHC package from official repositories... is this package included in another more general? (that would allow me to use apt-get, I think...)
02:32:51 <glguy> what is an "or pattern"?
02:32:56 <dmwit> bparkis: Right.
02:33:03 <sjanssen> falbani: no, I don't think so
02:33:13 <dmwit> bparkis: Okay, suppose we're looking at two sibling nodes.
02:33:23 <dmwit> (call them c and d)
02:33:32 <sjanssen> glguy: a pattern that matches when either pattern matches
02:33:40 <glguy> ah
02:33:40 <sjanssen> glguy: reading JDH junk?
02:33:44 <dmwit> And let's say that we visit c before we visit d.
02:33:53 <glguy> sjanssen: browsing the link Don pasted
02:34:02 <bparkis> (by the way the children happen to be ordered in decreasing distance from their parent but this is irrelevant)
02:34:03 <falbani> dons, sjanssen: I have never installed a package... is there anything I should know before?
02:34:34 <sjanssen> falbani: just grab the tarball and run runghc Setup configure, build, install
02:34:44 <cpst> Jon Harrup is hilarious
02:34:58 <cpst> oops, Harrop, can't even spell the name of trolls properly
02:35:01 <dmwit> bparkis: Now, with that setup, tell me all the things we want to be true about c/d/c's descendants/d's descendants.
02:35:01 <sjanssen> falbani: possibly giving --user --prefix=$HOME if you don't want to clutter system wide stuff
02:35:19 <dmwit> bparkis: From there, we can winnow it down to a set of sufficient conditions. ;-)
02:36:05 <falbani> sjanssen: I don't want to bother so much... Is there an instruction guide so I can RTFM?
02:36:19 <bparkis> well, assuming c is visited before d, you want all of c's descendants to be visited before d
02:36:22 <sjanssen> falbani: haskell.org/cabal might help
02:36:23 <dons> i proclaim simonm's response here, explaining the asm generated, the best result from the "6 day fibonacci war"
02:36:25 <bparkis> this might be difficult to prove
02:36:40 <dons> along with the increase in experience with `par`, the main results
02:36:46 <dmwit> bparkis: Why would it be difficult to prove?
02:37:24 <dmwit> bparkis: I'll give you a hint: the set of all possible trees is an inductive set.
02:37:45 <bparkis> well at least messy to prove, i'd rather find conditions that avoid an induction if i can
02:38:04 <dmwit> hmm...
02:38:19 <quicksil1er> it would be foolish to want to avoid induction on something defined over an inductive type
02:38:30 <quicksil1er> induction is the natural logic for proofs over inductive types :)
02:38:48 <dmwit> Yeah, I'm not really sure that it's going to be easy to find a non-inductive proof for this.
02:39:12 <dmwit> You might find something simpler than "all the descendants" but you're still going to end up with induction. =)
02:39:12 <cpst> you probably won't be able to
02:39:22 <cpst> arithmetic without induction is pretty weak
02:40:03 <dmwit> arithmetic?
02:40:36 <cpst> the (first-order) logical theory of arithmetic
02:41:23 <dmwit> I guess I never heard of arithmetic on trees.
02:41:43 <cpst> all of finite combinatorics can easily be encoded in arithmetic
02:43:04 <sjanssen> dons: I think we need something better than par
02:43:20 <Cale> cpst: Haha, Jon Harrop *is* ridiculous. "I'm going to promote functional programming! Step 1... Completely alienate myself from the FP community?"
02:43:37 <dons> we need more precision. its too broad a brush, isn't it, sjanssen
02:43:42 <cpst> that being said
02:43:57 <cpst> OCaml *is* fast for doing nested for loops on floating-point arrays
02:44:03 <cpst> because they special case it in the IR
02:44:08 <dons> Cale, he has written that he doesn't see that as a problem.
02:44:11 <sjanssen> s/promote functional programming/promote FP languages that I sell books and services for/
02:44:20 <dons> Cale, as it drives up discussion and traffic
02:44:27 <cpst> it's a lot slower if you actually use functional programming features like functors
02:44:39 <cpst> I had to rewrite some program static analysis tools I wrote in C for speed
02:46:05 <dons> yeah, i'm not sure its compellingly faster. can't wait to see the 6.8 graphs
02:46:27 <dons> ghc's often around 10% down on ocaml, which often can be regained with pointer tagging, i suspect.
02:46:30 <dons> we'll see.
02:46:41 * dmwit had a really hard time parsing cpst's last sentence
02:46:54 <cpst> oops, it's late and I should go to bed then
02:46:55 <dons> some only moderate improvements in ghc's native code gen and the story would be over, i'd say
02:47:04 <cpst> I wrote some program analysis tools in OCaml and they were pretty slow
02:47:10 <cpst> so I had to rewrite them in C
02:47:16 <dmwit> aha
02:47:25 <pejo> dons, did the O'caml compiler stop being developed?
02:47:45 <cpst> pejo: they haven't really worked on optimizing their compiler that much for a while
02:48:02 <jedbrown> dons, sjanssen: Control.Concurrent (or something close) scales to distributed memory and is much more flexible than `par`, albeit with much more programming effort.
02:48:18 <cpst> pejo: it certainly has acceptable performance for most applications, both in terms of compile time and the generated code
02:48:44 <falbani> dons: "configure: No haddock found" <-- Is this a so called "unsatisfied dependencie"? (in the output of "runghc Setup configure)
02:49:01 <cpst> pejo: they designed it fairly well when they first made it, i.e. things like for loops with integer ranges are built in to the language (and the compiler IR)
02:49:04 <sjanssen> jedbrown: that's a different kettle of fish, in my opinion.  par is pure
02:49:19 <sjanssen> jedbrown: though perhaps there's a pure parallelism monad waiting to be found?
02:49:21 <dmwit> falbani: That's probably not a really big problem.  Did it say "configure failed" or so at the end?
02:49:33 <falbani> dons: no
02:50:05 <dmwit> falbani: Then go ahead and try to build it.  (Haddock is for the documentation, but you can get it online in a pinch.)
02:50:05 <pejo> cpst, is/was Leroy the main implementor?
02:50:11 <falbani> dons: runghc Setup.lhs build seems to finish fine, too...
02:50:34 <glguy> is: fib x | x == 0 || x == 1 = x -- comparable to or-patterns?
02:50:37 <glguy> (in this case)
02:50:50 <dmwit> Close, but there's an Eq constraint.
02:50:51 <falbani> and, finally, runghc Setup.lhs install didn't complaint...
02:51:02 <sjanssen> glguy: similar enough, I think
02:51:03 <cpst> pejo: not sure, I was in grade school then
02:51:10 <jedbrown> sjanssen: Very true.  We do need something that works for non-embarrassingly parallel problems.
02:51:10 <Cale> There's an Eq contraint when you use n-patterns anyway
02:51:17 <Cale> s*
02:51:25 <falbani> dons: but I keep getting    fuente.hs:26:7: parse error on input `System.IO.UTF8.putStrLn'
02:51:34 <jedbrown> sjanssen: And scaling to distributed (or highly non-uniform memory access) would be good.
02:51:44 <dmwit> falbani: Maybe you should paste your code at hpaste:
02:51:45 <dmwit> ?hpaste
02:51:45 <lambdabot> Haskell pastebin: http://hpaste.org/new
02:52:54 <sjanssen> jedbrown: even embarassingly parallel problems have difficulties, eg. http://hpaste.org/4240
02:53:13 <falbani> is this correct: "import System.IO.UTF8.putStrLn" ?
02:53:16 <cpst> someone should make a benchmark where you design the best raytracer bar none
02:53:21 <glguy> falbani: no
02:53:23 <cpst> not one that has to fit in under 100 lines
02:53:28 <sjanssen> jedbrown: 'check' is massively parallel, but the solution there will be inefficient due to the cost of making too many par thunks
02:53:40 <glguy> falbani: import System.IO.UTF8 (putStrLn)
02:54:03 <glguy> falbani: when I wrote it I figured it would be used: import qualified System.IO.UTF8 as UTF8
02:54:10 <glguy> or by hiding the stuff from System.IO
02:54:17 <jedbrown> sjanssen: Correcting that requires some heuristic regarding how much work the thunk represents.
02:55:21 <jedbrown> sjanssen: Maybe some generalization of the 'cutoff' method could make it into library.
02:58:49 <jedbrown> sjanssen: I don't know how to automatically generate the heuristic except by running the code.  Otherwise, the programmer has to use knowledge of the algorithm to write the heuristic.
02:59:13 <sjanssen> jedbrown: there was a paper about this recently
02:59:59 <dmwit> xmonad++
03:00:06 <sjanssen> jedbrown: http://research.microsoft.com/~tharris/papers/2007-fdip.pdf
03:00:58 <falbani> glguy: now the code compiles... but, is this correct: aacute = "\161" ?
03:01:31 <glguy> falbani: assuming that the 161 is correct, then yet
03:01:40 <dmwit> 161 looks a bit low to be in the true Unicode range.
03:01:52 <dmwit> I thought 128..256 were more or less verboten.
03:01:58 <falbani> glguy: I have tried with aacute="Ã¡" and got    lexical error in string/character literal (UTF-8 decoding error)
03:02:01 <int-e> hmm? it's in the iso 8859-1 subset of unicode.
03:02:16 <Zao> falbani: http://www.fileformat.info/info/unicode/char/00e1/index.htm
03:02:16 <lambdabot> Title: Unicode Character 'LATIN SMALL LETTER A WITH ACUTE' (U+00E1)
03:02:23 <sjanssen> falbani: is your editor set to UTF-8?
03:02:39 <falbani> sjanssen: how do I ask that to vim? :)
03:02:41 <glguy> http://www.fileformat.info/info/unicode/char/00e1/index.htm
03:02:42 <lambdabot> Title: Unicode Character 'LATIN SMALL LETTER A WITH ACUTE' (U+00E1)
03:02:52 <hpaste>  sizur pasted "iRadio metaplayer" at http://hpaste.org/4241
03:03:33 <glguy> looks like 225 instead of 161
03:03:54 <jedbrown> sjanssen: Cool, I'm reading it now.  By the way, do you have thoughts about distributed memory parallelism?  It is inherently impure, but quite important, at least for scientific computing.
03:03:56 <falbani> lambdabot: > "Ã¡"
03:04:08 <falbani> lambdabot: "Ã¡"
03:04:30 <sjanssen> jedbrown: no, not really
03:04:33 <falbani> lambdabot > "Ã¡"
03:04:33 <dmwit> > "this is how to get something evaluated"
03:04:41 * int-e smells encoding whims.
03:04:45 <falbani> > "Ã¡"
03:04:48 <lambdabot>  "\225"
03:04:48 <lambdabot>  "this is how to get something evaluated"
03:04:58 <falbani> hehehe...
03:05:19 <falbani> > Ã¡
03:05:19 <lambdabot>  Illegal character ''\161''
03:05:19 <lambdabot>  at "¡" (column 2)
03:05:25 <falbani> there is the 161 !!!
03:05:38 <falbani> i wasn't crazy...
03:06:33 <falbani> btw, the output i get for "Ã¡" is "ÃƒÂ¡"
03:06:57 <falbani> and "Ã‚Â©" for Ã©
03:07:03 <int-e> oh. the \161 comes from the utf-8 encoding of \225
03:07:08 <sjanssen> falbani: sounds like your terminal isn't expecting UTF-8
03:07:42 <int-e> hmm. does it?
03:08:01 <falbani> sjanssen: ok... but the important things is that the problem now is with the terminal and not with haskell... am I right?
03:08:11 <sjanssen> falbani: I think so
03:08:19 <int-e> > map ord "Ã¡"
03:08:22 <lambdabot>  [225]
03:08:27 <int-e> eek.
03:08:39 <falbani> > chr 225
03:08:39 <lambdabot>  '\225'
03:08:46 <falbani> > chr 161
03:08:46 <lambdabot>  '\161'
03:08:53 <int-e> Prelude Data.Char> map ord "Ã¡"
03:08:54 <int-e> [195,161]
03:09:34 <hpaste>  ttfh pasted "Idea for wrapping IOErrors" at http://hpaste.org/4242
03:09:42 <int-e> so there's your 161.
03:09:51 <falbani> well... ho do I set bash encoding?
03:10:14 <dmwit> It's probably your terminal's fault, not bash's.
03:10:35 <dmwit> Try urxvt or some similar unicode-aware terminal.
03:10:52 <falbani> dmwit: Im a Linux newbie :D...
03:11:32 <dmwit> falbani: apt-get urxvt # ;-)
03:11:42 <falbani> dmwit: Solved!
03:11:59 <falbani> now I get the output as I wanted... :D
03:12:23 <falbani> Many many thanks people (and specially to glguy for writting the package)
03:12:25 <dmwit> That was quite a saga. =)
03:12:36 <glguy> falbani: glad you've found it useful :)
03:13:00 <falbani> Sorry for so many dumb/newbie questions hehehe...
03:13:10 <falbani> Now I can go in peace...
03:13:16 <falbani> Bye.
03:14:23 <int-e> It's funny. ghc parses UTF-8 string literals in source files but not on the ghci prompt.
03:17:00 <xpik2> @users
03:17:00 <lambdabot> Maximum users seen in #haskell: 401, currently: 390 (97.3%), active: 13 (3.3%)
03:17:21 <soroush> hi, Are there any dimension variable in haskell
03:17:33 <soroush> I mean sth like the ones in Fortran
03:17:46 <dmwit> What does it do?
03:17:52 <dmwit> Like a list?
03:17:56 <soroush> dmwit, no
03:17:58 <dmwit> > [3..10]
03:18:00 <lambdabot>  [3,4,5,6,7,8,9,10]
03:18:09 <soroush> it is for manipulation of physical dimesions
03:18:11 <pejo> dmwit, think physical dimensions.
03:18:15 <dozer> no - dimensions would be nice
03:18:19 <dmwit> aha
03:18:20 <soroush> it exchanges them
03:18:38 <dmwit> I've seen a library or two for it, though I couldn't recall the name now.
03:18:43 <dmwit> ?go haskell dimension analysis
03:18:45 <lambdabot> http://osdir.com/ml/lang.haskell.general/2001-04/msg00056.html
03:18:45 <lambdabot> Title: Re: Dimensional analysis with fundeps
03:18:49 <soroush> you set dimension fo each number and it does everything
03:19:02 <dozer> the dimensions libs I've seen all work with a pre-canned menu of dimensions
03:19:50 <dmwit> dozer: Naturally.  I assume Fortran had to do something similar.
03:19:56 <jedbrown> soroush: like this? http://hackage.haskell.org/cgi-bin/hackage-scripts/package/dimensional-0.7.1
03:19:57 <lambdabot> http://tinyurl.com/34gpv6
03:20:19 <soroush> readiing
03:20:22 <dozer> the java dimensions extension lets you arbitrarily extend your dimensions
03:21:28 <quicksilver> one of the dimensions libs on hackage lets you define you r own
03:21:33 <quicksilver> I'm not sure which one
03:22:34 <soroush> looks nice. I'll test them as soon as possible
03:25:26 <xpik2> what is the arrows-any dependancy?
03:25:37 <xpik2> is it arrows-0.3?
03:25:45 <dmwit> sure
03:25:54 <dmwit> It's *any* arrows. =)
03:26:04 <xpik2> I thought I already had arrows
03:26:12 <dmwit> You might.
03:26:15 <dmwit> What does ghc-pkg list say?
03:26:17 <xpik2> control.monad.arrow
03:26:40 <xpik2> ghc-pkg disagrees
03:26:47 <dmwit> hold on
03:27:19 <dmwit> I think arrows comes for free with GHC >= 6.6.
03:27:29 <xpik2> I have 6.8.1
03:27:30 <dmwit> So it may be that the dependencies are outdated.
03:27:37 <jsnx> say i have a chinese character, stored as a Char
03:27:39 <xpik2> that's not fair
03:27:43 <dmwit> It should probably say arrows-any or base >= 2.0.
03:27:45 <jsnx> how do i get the byte values?
03:27:58 <xpik2> maybe I should just hack the cabal file?
03:27:59 <SamB_XP> jsnx: "byte values"?
03:28:11 <dmwit> xpik2: Try just deleting that dependency from the cabal file and see what happens. ^_-
03:28:19 <SamB_XP> say, haven't I heard this joke before?
03:28:22 <jsnx> SamB_XP: there are 3 bytes in a UTF-8 Char representing a Chinese character
03:29:07 <SamB_XP> jsnx: ah, so you want to do utf8 encoding
03:29:30 <jsnx> SamB_XP: i have to URL encode the Chinese chars...
03:29:44 <jsnx> the libs do not do it properly, so i have to do it by hand
03:29:56 <SamB_XP> what do the libs do?
03:30:06 <xpik2> dmwit: Could not find module `Control.Arrow.Operations': -- looks like I didn't have arrows after all
03:30:28 <jsnx> they make 2 bytes instead of 3
03:30:34 <dmwit> xpik2: Or maybe it's been renamed.
03:30:47 <dmwit> I don't see Control.Arrow.Operations in the docs.
03:31:04 * dmwit doesn't really know, though, so your guess is as good as mine
03:31:54 <xpik2> dmwit: is the a hackage haskell package manager?
03:32:10 <dmwit> kind of
03:32:34 <dmwit> xpik2: Wait, you mean cabal-install?
03:32:35 <SamB_XP> jsnx: well... you could steal some existing utf-8 code...
03:48:01 <jsnx> SamB_XP: from where?
03:48:31 <SamB_XP> does bytestring still have some?
03:48:41 <dmwit> ?hackage encoding
03:48:41 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/encoding
03:48:47 <dmwit> Maybe there?
03:49:01 <SamB_XP> oh, that code you probably wouldn't need to even steal ;-)
03:49:02 <dcoutts> SamB_XP: the bytestring package doesn't have anything unicode
03:49:21 <SamB_XP> dcoutts: hmm. what am I thinking of?
03:49:30 <Mitar> I cannot use when and unless with the Error monad? I would like to make simple: unless (...) throwError ...
03:49:39 <dcoutts> SamB_XP: there are several other packages on hackage with utf8 stuff though
03:49:52 <SamB_XP> Mitar: try more parens
03:50:27 <SamB_XP> dcoutts: did a previous incarnation have some utf8 code, or am I just getting confused with one of dons' programs?
03:50:44 <dcoutts> SamB_XP: it's never had any
03:50:59 <Mitar> which is defined where?
03:51:10 <SamB_XP> not even when it was Data.FastPackedString?
03:51:24 <SamB_XP> unless (...) (throwError ...)
03:51:39 <SamB_XP> Mitar: that kind of "more parens"
03:51:47 <Mitar> lol
03:51:54 <Mitar> no, the problem is in type i think
03:52:17 <SamB_XP> not using parens gets you the wrong type, yes
03:52:18 <Mitar> @type throwError
03:52:20 <lambdabot> forall e (m :: * -> *) a. (MonadError e m) => e -> m a
03:52:27 <Mitar> @type unless
03:52:27 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
03:52:36 <Mitar> see, it expects ()
03:52:42 <Mitar> i will check parens
03:53:03 <SamB_XP> @type unless True (throwError "")
03:53:04 <lambdabot> forall (m :: * -> *). (MonadError [Char] m) => m ()
03:53:35 <Mitar> works :-)
03:53:37 <SamB_XP> see, throwError returns whatever "a" you want
03:53:42 <SamB_XP> including ()
03:53:52 <Mitar> but why does parens solve this?
03:54:09 <Mitar> this is just ugly: when (isJust $ lookup name top) (throwError $ SemError $ name ++ " already defined")
03:54:13 <Mitar> any nicer syntax?
03:54:54 <SamB_XP> well, you were passing throwError itself as the next argument to when...
03:55:40 <SamB_XP> anyway, you could trade in those $s for some parens if you like...
03:55:55 <ivanm> I did try asking this a few hours ago, but I'm not sure if it went out since I didn't notice till later that the CGI:IRC client I was using at the time died, so I'll try asking again
03:56:17 <ivanm> does anyone know if someone's tried using graph theory to analyse source code, in particular haskell code?
03:56:33 <ivanm> (with an aside question of whether fgl is any good, and if it works with 6.8.1)
04:03:26 <dozer> I'm getting some werid type errors in my program]
04:03:45 <dozer> is there an option I can give to ghc that will print out lots of info about how it decided on what types things are?
04:05:37 <ADEpt> dozer: if they are really weird, you'd better 1)comment out offending code and examine (:info, :type in ghci) types of functions used in offending code; or 2)sprinkle some type annotations on functions used in code that fails to typecheck - that could help you pinpoint the difference of opinion between you and compiler
04:05:53 <ADEpt> dozer: and then, there is hpaste where you can paste you code and ask channel to help :)
04:05:56 <ADEpt> @paste
04:05:56 <lambdabot> Haskell pastebin: http://hpaste.org/new
04:06:32 <dozer> I've done rather more than sprinkle it so far - broken it down into a million lines each with type info
04:07:05 <dozer> I'll try building from clean, just in case it's something weird with cabal
04:08:14 <Mitar> where is GenParser defined?
04:11:25 <Mitar> forget :-0
04:16:56 <bringert> http://www.jobs-in-fp.org/
04:16:57 <lambdabot> Title: Jobs in Functional Programming
04:17:16 <bringert> Dec 14 at Chalmers
04:18:17 <bringert> dons: Galois should be there
04:53:13 <resiak> @type forkIO
04:53:16 <lambdabot> Not in scope: `forkIO'
05:13:41 <zeloran> hi
05:14:28 <jedbrown> hi zeloran
05:15:05 <zeloran> is there anyway to do this smarter: i have             data TestType = TestInt Int | TestChar Char
05:15:32 <zeloran> so that haskell can determinate the correct constructor on it's own?
05:15:48 <zeloran> at the moment i have to to         TestInt 5         for example
05:15:52 <matthew-_> you could use a type class
05:15:59 <zeloran> i want a common name for the constructor
05:16:07 <matthew-_> yeah, hang on
05:16:09 <matthew-_> class Test a where
05:16:16 <matthew-_>     test :: a -> TestType
05:16:25 <matthew-_> no no no. I'm rubbish. Ignore all that!
05:16:32 <zeloran> :)
05:16:36 <matthew-_> instance Test Int where
05:16:44 <matthew-_>     test :: Int -> TestType
05:16:46 <johnw> shapr: ping
05:16:49 <matthew-_> instance Test Char where
05:16:59 <matthew-_>     test :: Char -> TestType
05:17:03 <matthew-_> yeah, that would work actually
05:17:11 <mar77a> @src (1 -)
05:17:11 <lambdabot> Source not found. :(
05:17:12 <matthew-_> so then your common constructor would just be "test"
05:17:20 <mar77a> @undo (1 -)
05:17:20 <lambdabot> (1 -)
05:17:21 <zeloran> oh i will give it a try
05:17:23 <mar77a> eek
05:17:39 <Saizan> matthew-_: you still need the class declaration
05:17:50 <doserj> @unpl (1 -)
05:17:50 <lambdabot> (\ a -> 1 - a)
05:17:51 <matthew-_> yeah, I gave that too!
05:18:21 <Saizan> matthew-_: and implementation of test in the instances :)
05:18:45 <matthew-_> yes, that would be a 7 or 8 char implementation ;)
05:19:35 <zeloran> how to do the class implemenatations?
05:19:44 <zeloran> sorry implementations
05:20:29 <matthew-_> as I wrote - instance $className $classParams where ($methodName $methodImplementations)+
05:20:30 <jedbrown> zeloran: instance Test Int where test = TestInt
05:20:53 * matthew-_ mixes perl and EBNF in #haskell ;)
05:23:06 <asmanur> bjjjhjhjhjhjhjh
05:23:08 <jedbrown> zeloran: Alternatively, you could have newtype TestType = Test (Either Int Char)
05:23:11 <mar77a> > length [0,'a',"ah"]
05:23:13 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
05:23:22 <mar77a> eh, how would i do that?
05:23:44 <Saizan> mar77a: what do you want to do?
05:23:59 <mar77a> get the size of the list
05:23:59 <Saizan> mar77a: a list contains only elements of the same type
05:24:20 <Saizan> yeah, but that's not a valid list
05:24:34 <mar77a> oh i see
05:25:33 <Saizan> > length (['\0','a'] ++ "ah")
05:25:37 <lambdabot>  4
05:27:16 <Olathe> > length "\0aah"
05:27:22 <Olathe> Faster
05:27:23 <Olathe> !
05:27:32 <lambdabot>  thread killed
05:27:32 <Olathe> > 10
05:27:34 <lambdabot>  10
05:33:42 <shteou> @seeen ndm
05:33:42 <lambdabot> I haven't seen ndm.
05:33:54 <shteou> :[
05:36:05 <Sizur> where is ExitCode defined?
05:36:20 <Sizur> that's referred in System.Cmd?
05:37:03 <doserj> @hoogle ExitCode
05:37:03 <lambdabot> System.Exit.ExitCode :: data ExitCode
05:37:03 <lambdabot> System.Process.getProcessExitCode :: ProcessHandle -> IO (Maybe ExitCode)
05:37:12 <doserj> @src ExitCode
05:37:12 <lambdabot> data ExitCode = ExitSuccess | ExitFailure Int
05:39:19 <mar77a> > log 0
05:39:21 <lambdabot>  -Infinity
05:39:24 <Sizur> doserj: thank you
05:41:11 <scook0> @where report
05:41:11 <lambdabot> http://www.haskell.org/onlinereport/
05:51:42 <ttfh> ttfh in monad transformer-land part 34534: ContT inside ErrorT or the other way around? My theory is, because I'm using callcc in the most basic way, just for "quitting" a computation, the ContT should be the outermost monad, because "quit" is not something that should fail
05:52:52 <cjay> this would make a wonderful lambdacat http://icanhascheezburger.com/2007/11/30/kitteh-included/
05:52:59 <cjay> kitteh trapped in IO Monad
05:55:02 <scook0> @hoogle Char -> Integer
05:55:04 <lambdabot> No matches, try a more general search
05:55:41 <doserj> @hoogle Char -> Int
05:55:42 <lambdabot> Char.digitToInt :: Char -> Int
05:55:42 <lambdabot> Char.ord :: Char -> Int
05:58:19 <Olathe> > digitToInt '6'
05:58:26 <lambdabot>  6
05:58:37 <Olathe> > digitToInt '600'
05:58:37 <lambdabot>  Improperly terminated character constant at "'600'" (column 12)
05:58:42 <Olathe> Bah.
06:00:43 <Olathe> Why is lambdabot so slow ?
06:01:17 <mar77a> cause it can't be faster
06:01:38 <Olathe> It has been faster.
06:01:46 <mar77a> > 2
06:01:47 <lambdabot>  2
06:01:50 <mar77a> blame freenode
06:03:21 <Olathe> I mean that it's getting Thread killed for simple things.
06:04:10 <mar77a> oh
06:06:17 <Olathe> > let digitsToInt = foldl' ((. digitToInt) . (+) . (10 *)) 0 in digitsToInt "1234"
06:06:17 <lambdabot>  1234
06:12:24 <dcoutts_> hia nominolo, busy this week?
06:12:46 <nominolo> depends...
06:15:43 <nominolo> > let 46'n'2 = "foo" in 42
06:15:43 <lambdabot>  Parse error in pattern at "in" (column 20)
06:15:51 <nominolo> > let _46'n'2 = "foo" in 42
06:15:57 <lambdabot>  42
06:16:53 <nominolo> > let 'quotes'in'vars'look'funny = 32 in ()
06:16:53 <lambdabot>  Improperly terminated character constant at "'quot..." (column 5)
06:17:15 <nominolo> ah, well...
06:17:24 <nominolo> dcoutts_: asking for cabal?
06:17:35 <dcoutts_> nominolo: yup ;-)
06:19:09 <nominolo> dcoutts_: k.  but i'm a bit tired today.  so if you see a random combination of letters being pressed with high repetition i've fallen asleep with my head on the keyboard ..
06:19:25 <dcoutts_> nominolo: hah hah hah, ok :-)
06:32:46 <joelr1> good afternoon
06:32:57 <joelr1> @seen bringert
06:32:58 <lambdabot> I saw bringert leaving #ghc and #haskell 22m 50s ago, and .
06:33:04 <joelr1> mmm
06:33:34 <nominolo> heh
06:33:35 <joelr1> bringert: hi bjorn!
06:33:40 <joelr1> speak of the devil
06:33:42 <bringert> hi joelr1
06:33:58 <bringert> joelr1: I'm writing a GF IRC bot example atm
06:34:22 <joelr1> bringert: in plain haskell?
06:34:32 <bringert> joelr1: yes
06:34:50 <joelr1> bringert: why did you write the embedded java interpreter originally?
06:35:11 <bringert> joelr1: I was paid to do it
06:35:19 <ndm> @seen dcoutts
06:35:19 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-overflow, #haskell and #ghc. I last heard dcoutts speak 2h 44m 35s ago.
06:35:27 <bringert> joelr1: it was needed for a research project
06:35:29 <joelr1> bringert: a solid undisputable reason! :D
06:35:30 <dcoutts_> hia ndm
06:35:38 <joelr1> bringert: how long did it take (java)?
06:35:44 <ndm> dcoutts_ so how do i make it so i can run cabal install?
06:35:49 <ndm> darcs get, then install cabal?
06:36:11 <dcoutts_> ndm: you need the darcs version of cabal-1.2 branch and darcs version of cabal-install
06:36:29 <ndm> cabal head not work?
06:36:33 <bringert> joelr1: quite a while. but I've just started writing an article about how to write GF interpreters, which should make it a lot quicker to write a new one
06:36:45 <Saizan> why on hackage some packages have a build log and some doesn't?
06:36:45 <dcoutts_> ndm: that's probably work too, but it has more other changes
06:36:53 <bringert> joelr1: we have been working on simplifying the low-level language to make it easier to write interpreters
06:36:58 <dcoutts_> ndm: and then you need to tell me when you run into the bug where it fails deleting the temp build dir
06:37:11 <dcoutts_> Saizan: some did not build
06:37:15 <ndm> dcoutts_ - i've been running Cabal head for ages, so thats my already downloaded repo
06:37:23 <dcoutts_> ndm: go for it
06:37:36 <Saizan> dcoutts_: ah so the log is only for those that had an error?
06:37:49 <dcoutts_> Saizan: no, only for the ones it tried to build
06:38:03 <bringert> joelr1: I wouldn't recommend writing your erlang gf interpreter just yet. if you can, go with Haskell for now, and write the erlang implementation in a few months when we have figured out and described all the details you need
06:38:18 <yaxu> sigfpe++ # monad transformer post from last year is helpful
06:38:28 <joelr1> bringert: hmm... you don't think simply translating the your java code would work?
06:38:49 <dcoutts_> bringert: btw, might you have some cabal-install hacking time this week?
06:39:21 <bringert> joelr1: the Java code is getting outdated. we have changed the grammar formats since then. GF can still produce the old formats, but they're deprecated, and more difficult to work with than the new ones.
06:39:51 <bringert> joelr1: I will rewrite the Java interpreter to use the new formats
06:40:10 <bringert> dcoutts_: not terribly likely I'm afraid
06:40:19 <dcoutts_> bringert: np
06:43:33 <ndm> @where cabal-install
06:43:33 <lambdabot> I know nothing about cabal-install.
06:44:05 <dcoutts_> @where+ cabal-install http://darcs.haskell.org/cabal-install/
06:44:05 <lambdabot> Okay.
06:44:08 <nominolo> @hackage cabal-istall
06:44:08 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/cabal-istall
06:48:57 <ndm> dcoutts_ chances of any of this working on GHC 6.6.1?
06:49:10 <dcoutts_> ndm: reasonable
06:49:11 <yaxu> if monadic programming is central to haskell, why don't packages like control.monad.random and maybet come packaged with ghc?
06:49:30 <ndm> dcoutts_ chances of installing zlib from hackage?
06:49:35 <ndm> @paste
06:49:35 <lambdabot> Haskell pastebin: http://hpaste.org/new
06:49:52 <dcoutts_> ndm: it works on windows, I've tested it.
06:50:20 <dcoutts_> ndm: certainly cabal works with all ghc versions, and cabal-install mostly uses cabal stuff so should be fine with most ghc versions too, at least 6.4+
06:50:26 <hpaste>  ndm pasted "Because cabal hates me" at http://hpaste.org/4243
06:50:42 * yaxu thinks he's missing something
06:50:53 <sjanssen> yaxu: MaybeT should probably be in mtl
06:51:14 <dmead> http://www.codinghorror.com/blog/archives/000818.html
06:51:15 <lambdabot> Title: Coding Horror: The "Works on My Machine" Certification Program
06:51:17 <ndm> thats an error installing zlib from hackage on GHC 6.6.1 Cabal Head Windows
06:51:18 <sjanssen> yaxu: I think the random monad isn't needed so frequently
06:51:52 <ndm> yaxu: is monadic programming central to haskell? i think pure functional programming is the good bits, monads are handy, but the important bit in a monad is >>= and return - all of which is in the standard libs
06:53:29 <ndm> oh, and missing H on hackage is foobared
06:53:52 <dcoutts_> ndm: I'm trying to reproduce it...
07:12:29 <tcr> ndm: ping?
07:13:55 <dcoutts_> ndm: I cannot reproduce that bug, it works fine for me with 6.6.1, Cabal HEAD and zlib fresh from hackage
07:15:31 <dcoutts_> ndm: it creates the zlib/include dir in the install location and puts zlib.h into it
07:16:08 <tcr> ndm: Setup.hs: uniplate.cabal:19: 'Executable' stanza starting with field 'flag splitbase description'  -- while trying to configuring uniplate. Am I missing something obvious?
07:17:04 <dcoutts_> ndm: whereas in your log it copies zlib.h to $prefix\zlib-0.4.0.1\ghc-6.6.1\
07:17:33 <dcoutts_> ndm: are you sure that's using the right cabal version?
07:19:47 <hpaste>  aaim pasted "GA for chessguy" at http://hpaste.org/4244
07:19:54 <hpaste>  dcoutts annotated "Because cabal hates me" with "I get this" at http://hpaste.org/4243#a1
07:29:19 <ndm> tcr: pong
07:29:40 <ndm> tcr: have you installed Cabal 1.2? or GHC 6.8.1
07:30:57 <dcoutts_> ndm: ping :-)
07:31:00 <ndm> dcoutts_ i have cabal from 2 minutes ago
07:31:15 <dcoutts_> hmm
07:32:23 <dcoutts_> ndm: there must be something odd going on, nobody has ever reported that before
07:33:29 <ndm> dcoutts_ - suggestions? experiments? this is cabal head
07:33:42 <int-e> i.e. http://darcs.haskell.org/packages/Cabal ?
07:33:42 <lambdabot> Title: Index of /packages/Cabal
07:33:44 <dcoutts_> ndm: try this:
07:34:16 * dcoutts_ checks his patch typechecks...
07:35:15 <hpaste>  dcoutts annotated "Because cabal hates me" with "includes tracing" at http://hpaste.org/4243#a2
07:40:44 <int-e> dcoutts_: could you put a motd in  http://haskell.org/~duncan/b?zlib  saying that the repository moved, please?
07:42:23 <dcoutts_> int-e: sure
07:43:38 <joelr1> bringert: i think implementing the parsing algorithms straight from the paper is too much for me. having no math background it's all foreign science :-(. i'm looking for burden's thesis now since it has implementations in haskell
07:45:42 <ndm> dcoutts_: ("installIncludeFiles","C:\\Program Files\\Haskell\\zlib-0.4.0.1\\ghc-6.6.1",["zlib.h"])
07:46:22 <dcoutts_> ndm: ok, that's very odd, we need to trace it back to find out why it's getting the wrong include dir
07:46:29 <dcoutts_> int-e: done
07:46:44 <doserj> ndm: does it work if you specify --user?
07:47:09 <int-e> dcoutts_: thanks
07:47:20 <dcoutts_> ndm: the include dir template is "$libdir" </> "$libsubdir" </> "include", specified in Distribution/Simple/InstallDirs.hs
07:47:27 <ndm> doserj: where or how?
07:47:37 <ndm> doserj: i never use --user, i just use the defaults
07:47:54 <doserj> at Setup configure
07:47:56 <dcoutts_> ndm: hmm, I was using --user as I'm not admin, that might be related
07:49:15 * dcoutts_ tries to reproduce again without --user
07:49:32 <dcoutts_> nope, still works
07:50:02 * dcoutts_ was using runghc Setup.hs configure --disable-optimization --prefix="D:\Program Files\Haskell"
07:50:19 <mightybyte> Heh, was I the only one who thought that reproduce comment sounded funny?
07:50:22 <davidL> "Monads are non-extended, soul-like, metaphysical simples. Every material that exists, according to Leibniz, is composed entirely of monads. These monads have no causal relationship to one another, or to any other monads, and are moved about (and appear to affect each other) through what Leibniz called pre-established harmony. In other words, without God overseeing and directing every action of every monad, the entire universe would fall apart."
07:50:28 <byorgey> @pl \s -> map (map (s*))
07:50:28 <lambdabot> map . map . (*)
07:50:40 <dcoutts_> mightybyte: heh :-)
07:51:08 <davidL> monadology is awesome
07:56:30 <Cale> davidL: Of course, that use of the word is not etymologically related to the monad from category theory and functional programming (which is a portmanteau of monoid and triad).
07:56:35 <hpaste>  dcoutts annotated "Because cabal hates me" with "more includes tracing" at http://hpaste.org/4243#a3
07:56:42 <dcoutts_> ndm: ^^
07:57:03 <ndm> dcoutts_ - i didn't have --prefix
07:57:04 <mar77a> are lambdas better than lists comprehensions?
07:57:15 <Cale> mar77a: they're not quite interchangeable
07:57:33 <mar77a> Prelude> map (\x -> x+1) [1,2,3,4,5]
07:57:36 <mar77a> Prelude> [x+1|x<-[1,2,3,4,5]]
07:57:37 <dcoutts_> ndm: right, but I can't specify the default --prefix=C:\Program Files\Haskell as I cannot write there.
07:57:39 <ndm> dcoutts_ can you just put the whole InstallDirs file on the web somewhere?
07:57:50 <Cale> mar77a: well, that uses map :)
07:57:57 <mar77a> hmm i see
07:58:00 <njbartlett> dcoutts: Do you know of many people using gtk2hs on Mac OS?
07:58:02 <dcoutts_> ndm: you've got the whole thing there, I'm only suggesting changing two lines
07:58:14 <hthththt> hello
07:58:18 <dcoutts_> njbartlett: not many but a few, I can't name names off the top of my head though
07:58:24 <Cale> mar77a: You can always translate list comprehensions into concatMap
07:58:26 <Cale> hthththt: hi
07:58:32 <mar77a> alright
07:58:33 <njbartlett> dcoutts_: Hmm. I've had an absolute bitch of a time getting it working
07:58:43 <MyCatVerbs> mar77a: list comprehensions are (mainly) just used as a really compact way of writing out a bunch of maps, filters and binds.
07:58:45 <dcoutts_> njbartlett: I hear macports is a pita
07:58:46 <Cale> mar77a: But sometimes they're way more convenient
07:58:50 <davidL> Cale: aren't the two uses of the worded related?
07:58:58 <Cale> davidL: no
07:59:05 <dcoutts_> njbartlett: if you have a suggestion for something better please share, I don't know much about mac packaging
07:59:07 <njbartlett> dcoutts_: Yeah. The main problem is it wants to download and build GHC itself.
07:59:13 <Cale> davidL: Except that the Latin root 'mono-' is common to both.
07:59:30 <dcoutts_> njbartlett: right, and probably an old version at that
07:59:32 <MyCatVerbs> mar77a: they're freely interchangable - isomorphic, even - so just use whichever happens to be easier to read in the situation.
07:59:47 <dcoutts_> njbartlett: how about using macports to install gtk and then build gtk2hs manually
08:00:13 <dcoutts_> njbartlett: the latter is fairly straightforward, ./configure && make && sudo make install
08:00:30 <davidL> Cale: that is interesting
08:01:03 <njbartlett> dcoutts_: Yeah that's what i did, essentially. Except there's a lot more to get than just gtk
08:01:03 <dcoutts_> ndm: does it sill go wrong if you try with --prefix="C:\program files\haskell" ?
08:01:22 <ndm> dcoutts_ yes, just tried that
08:01:22 <yitz> Cale: there are some amusing parallels in Leibnitz' essay, though.
08:01:23 <dcoutts_> njbartlett: gtk depends on a few things, glib, cairo, freetype
08:01:44 <dcoutts_> ndm: can you try that includedirs tracing?
08:01:57 <Cale> davidL: the use in philosophy is much older, and comes basically directly from Latin word for "unit, unity"
08:01:58 <njbartlett> dcoutts_: Yup. I had to follow a process of trial and error. Get a package with macports, try the gtk2hs build, see what's missing, rinse and repeat
08:02:05 <ndm> am just rebuilding cabal now...
08:02:21 <yitz> "And supposing there were a machine, so constructed as to think, feel, and have perception... we should, on examining its interior, find only parts which work one upon another, and never anything by which to explain a perception. "
08:02:27 <dcoutts_> njbartlett: if you've got a working recipe we could post that on the gtk2hs website
08:02:59 <dcoutts_> njbartlett: did you find it needed anything more than gtk and what gtk depends on?
08:03:00 <njbartlett> dcoutts_: I'd like to do that, but I would need to test the recipe on somebody else's Mac
08:03:08 <ndm> ("absoluteInstallDirs","$libdir\\$libsubdir\\include","C:\\Program Files\\Haskell\\zlib-0.4.0.1\\ghc-6.6.1\\include","C:\\Program Files\\Haskell\\zlib-0.4.0.1\\ghc-6.6.1\\include")
08:03:11 <Cale> davidL: The use in category theory is a portmanteau between "monoid" (a particular algebraic structure having an associative multiplication and an identity element), and "triad" (referring to the triple (T, eta, mu) -- monads were called 'triples' or 'triads' for a while before 'monad' was settled on)
08:03:37 <yitz> Kind of like how "Haskell" means "Enlightenment" in Classical Hebrew...
08:03:50 <dcoutts_> ndm: ok, and on that run it still ends up installing .h files into "C:\\Program Files\\Haskell\\zlib-0.4.0.1\\ghc-6.6.1" ?
08:04:26 <ndm> ghc-pkg.exe: C:\Program Files\Haskell\zlib-0.4.0.1\ghc-6.6.1\include doesn't exist or isn't a directory (use --force to override)
08:04:50 <ndm> so as far as i can tell, that's a yes :)
08:04:51 <byorgey> yitz: it does?  interesting.
08:04:55 <dcoutts_> ndm: better check is your earlier install -v where it says exactly where it's installing the .h files
08:05:05 <tcr> ndm: No I haven't.
08:05:15 <dcoutts_> ndm: and the other trace that we added still is missing the "include" subdir?
08:05:31 <dcoutts_> ndm: and that the only time it calls absoluteInstallDirs?
08:05:35 <Mitar> i have a: data Foo = Bar1 Something | Bar2 Something type and would like to make a function, where I could pass as an argument either Bar1 or Bar2 constructors and fhe function would mach on that (so it would be different behaviour if I pass Bar1 or Bar2 as a constructor), I could do this with (Bar1 undefined) or (Bar2 undefined) but it is ugly ..
08:05:37 <byorgey> yitz: I guess that's probably not a coincidence, since that's ultimately where Haskell Curry's name came from (?)
08:05:56 <quicksilver> Mitar: occasionally I want that. It's annoying.
08:06:06 <yitz> byorgey: it comes from the root SKL, basic meaning "intelligence".
08:06:08 <Mitar> and is there a solution?
08:06:11 <quicksilver> Mitar: you want a related type 'CTFoo = CTBar1 | CTBar2'
08:06:20 <davidL> Cale: I think that info should be in the wikipedia article :)
08:06:21 <quicksilver> Mitar: I make the type by hand, when I want it.
08:06:30 <byorgey> yitz: cool.
08:06:31 <hpaste>  ndm annotated "Because cabal hates me" with "(no title)" at http://hpaste.org/4243#a4
08:06:33 <yitz> byorgey: I doubt it, probably Indo-European.
08:06:34 <quicksilver> Mitar: and foo_to_ctfoo (Bar1 _) = CTBar1; etc
08:06:37 <tcr> ndm: So GHC 6.8 is mandatory now?
08:06:40 <Mitar> hmm, but this should be a class function ;-(
08:06:44 <quicksilver> Mitar: if you need it a lot, you can probably make Derive derive it.
08:06:54 <quicksilver> Mitar: yes, I would make it a class function if I need it more than once.
08:06:55 <ndm> tcr: no, if you install Cabal 1.2 with the old GHC you can do it just fine
08:07:12 <ndm> tcr: i am still on 6.6.1 on this machine, and installed the Uniplate on that
08:07:31 <dcoutts_> ndm: see why it's a bit confusing? all it's doing is calling InstallDirs { ..., includedir = incPref } = absoluteInstallDirs ...
08:07:37 <ndm> if you upgrade to 6.8.1 you get Cabal 1.2 for free
08:07:56 <Mitar> no, i would like to make a class on this data type
08:08:00 <dcoutts_> ndm: so if absoluteInstallDirs is apparently returning the right result and yet incPref ends up wrong... wtf?!
08:08:02 <ndm> dcoutts_ - haven't looked at the code at all - has been a long weekend, only came in today because have a friend in a viva right now!
08:08:16 <ndm> dcoutts_ - i can hit my monitor if that might help?
08:08:20 <ndm> @slap screen
08:08:20 <lambdabot> why on earth would I slap screen?
08:08:23 <Mitar> and class function: do_something :: a -> Result
08:08:23 <dcoutts_> heh
08:08:46 <Mitar> where I do not want that I have to call then this do_something with (Bar1 undefined)
08:09:00 <Mitar> so the do_something :: a -> Result signature is not good
08:09:25 <Toxaris> Mitar: do you really need a class?
08:09:29 <Mitar> how can I make a clean interface here, so that the user will understand that he has to pass something like just a constructor
08:09:37 <Mitar> yes, because I also have other functions there
08:09:41 <yaxu> @src evalRandIO
08:09:41 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
08:09:44 <dcoutts_> ndm: so on that run, we really only get one trace output of absoluteInstallDirs and one from installIncludeFiles right? and the absoluteInstallDirs has the trailing "include" and the installIncludeFiles trace does not. Correct?
08:10:22 <Mitar> I am adding a new function, but for which as an parameter I would only need to know on which constructor it should work and not the value build with this constructor as a whole
08:10:40 <ndm> dcoutts_ that run is 100% what it gave, with no malicious editing on my part
08:10:41 <Mitar> so one way is to define do_something :: a -> Result
08:10:55 <Mitar> but then i will have to call always do_something (Bar1 undefined)
08:11:12 <Mitar> of course, I could make a wrapper function as quicksilver suggested
08:11:26 <Mitar> but this will make a class less useful
08:11:32 <quicksilver> Mitar: you make a clean interface by making it a new type
08:11:33 <dcoutts_> ndm: I'm not implying anything like that, I just want to check we get the apparently contradictory traces from the same run, you told me about them separately earlier.
08:11:56 <quicksilver> you don't need a wrapper function, that's just useful sometimes.
08:12:27 <Toxaris> Mitar: well you need   data TConstructor   for every   T   you want to have in your class, and you may want to somehow associate these types
08:12:49 <dcoutts_> ndm: can you annotate the eariler paste with the full run, from configure to install -v
08:13:10 <Mitar> it would be nice if pattern could match on a constructor :-)
08:13:31 <Toxaris> Mitar: by using   class ConsRep t ct | t -> ct where constRep :: t -> ct   or something more modern using ATs
08:13:44 <Toxaris> Mitar: well, you can't, since constructors aren't data
08:13:52 <Mitar> but are functions :-)
08:13:57 <Mitar> which is a value in haskell
08:13:58 <ndm> dcoutts_ will do...
08:14:07 <dcoutts_> ta muchly
08:14:31 <ndm> dcoutts -v thoughout?
08:15:03 <dcoutts_> ndm: mm, leave it off for build
08:15:39 <dcoutts_> clean, configure -v, build, install -v would be great
08:15:45 <Toxaris> Mitar: then you may be able to do something like   class ConsRep t ct => Something t where soSomething :: ct -> Something
08:15:59 <hpaste>  ndm annotated "Because cabal hates me" with "(no title)" at http://hpaste.org/4243#a5
08:16:20 <ndm> now hpaste hates me...
08:16:25 <ndm> can someone lift the 5k limit?
08:16:38 <dcoutts_> ndm: well, leave out the less interesting bits I guess
08:16:55 <Toxaris> user of your interface will have to create not only a Type, but a ConsType too and associating them with an ConsRep instance before they can define a Something instance
08:16:56 <Mitar> Toxaris, could you please paste something like this for me? because I am bit lost ... I am not sure I follow all this classes
08:17:13 <Toxaris> Mitar: but I wonder if this isn't totally oversized :)
08:17:18 <dcoutts_> ndm: leave off -v in the build
08:17:24 <ndm> http://www-users.cs.york.ac.uk/~ndm/temp/cabal.txt
08:18:04 <dcoutts_> ta
08:20:11 <Mitar> "ConsRep t ct | t -> ct" << what is this part after | ?
08:20:28 <ndm> think my friend just passed their viva, so off for champagne - but will be back in half an hour or so
08:21:14 <dcoutts_> ndm: ok
08:21:16 <Mitar> viva?
08:21:28 <doserj> Mitar: http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#functional-dependencies
08:21:28 <lambdabot> Title: 8.6. Class and instances declarations, http://tinyurl.com/245leb
08:22:03 <ndm> Mitar: the exam for a phd
08:22:24 <Mitar> in USA?
08:22:31 <Mitar> or where do you have this?
08:23:17 <Igloo> ndm is almost certainly talking about York, England
08:23:24 <Mitar> ok
08:23:53 <Igloo> Most places have them, though, although the details vary from country to country (and perhaps even uni to uni)
08:24:40 <ndm> Igloo is right
08:24:46 <Mitar> and the name :-)
08:24:52 <ndm> she's just finished the talky bit, now she's waiting for the resulty bit
08:25:03 <ndm> so if dcoutts_ wants another trace'd iteration
08:25:13 <Mitar> great ... i am a few years from that still :-)
08:25:25 <dcoutts_> ndm: ok, one more trace insertion...
08:25:26 <quicksilver> hmm, ndm's uni has more class than mine
08:25:31 <quicksilver> we never got champagne :(
08:25:51 <Mitar> hm, but this is a defense of phd thesis or something else?
08:25:51 <Igloo> Mitar: Where are you? And what do you call it?
08:26:00 <quicksilver> Mitar: yes, viva == defense
08:26:04 <Mitar> aha :-)
08:26:11 <Mitar> so we call it defense :-)
08:26:26 <Mitar> i am from slovenia
08:26:55 <hpaste>  dcoutts annotated "Because cabal hates me" with "yet more tracing" at http://hpaste.org/4243#a6
08:27:08 <dcoutts_> ndm: just connecting the dots ^^^
08:27:10 <ndm> quicksilver: sparkling wine, provided by the candidate
08:27:24 <ndm> i'm off to slovenia in february :)
08:27:30 <Mitar> really?
08:27:32 <Mitar> how so?
08:27:34 <dcoutts_> ndm: an intermediate trace point to find where the value is magically mutating
08:28:27 <ndm> just for a holiday
08:29:41 <Mitar> interesting :-)
08:31:00 <Mitar> hope you will enjoy it
08:32:06 <ndm> me too :)
08:32:12 <quicksilver> Mitar: viva = viva voce = "living voice" = traditional UK term for a spoken examination
08:32:25 <quicksilver> Mitar: these days it's only the higher degrees that have them, as a rule.
08:34:20 <hpaste>  (anonymous) annotated "Because cabal hates me" with "(no title)" at http://hpaste.org/4243#a7
08:34:31 <Mitar> hmm, we have it also for bsc :-)
08:34:39 <Mitar> but of course it is not so strict ...
08:35:02 <tcr> ndm: Thanks. Uniplate built perfectly fine with cabal 1.2.
08:35:31 <ndm> tcr: good good :)
08:36:03 <ndm> we have viva for undergrad degrees, but only for maybe 2% of people, those who just miss a degree boundary, if they pass a viva can be awarded the higher class
08:36:53 <hpaste>  Toxaris pasted "constructor representations for Mitar" at http://hpaste.org/4245
08:37:35 <dozer> mm - is there a function that will concatenate strings using a 'joining' string?
08:37:38 <ndm> hpaste has stopped remembering user names
08:37:47 <ndm> intercalate
08:37:49 <mauke> dozer: yes, (concat .) . intersperse
08:37:53 <ndm> only GHC 6.8 and above
08:37:56 <dozer> ah great
08:38:13 * dozer reaches for the hoogle plugin in firefox
08:38:29 * ndm points out that hoogle still doesn't do 6.8 data
08:38:36 <ndm> but it is on my todo list!
08:39:15 <Mitar> Toxaris, thanks, i will check
08:39:32 <dozer> I'm finding that lots of the hoogle links don't take me anywhere useful
08:39:35 <dozer> for example:
08:39:38 <dozer> http://haskell.org/ghc/docs/latest/html/libraries/haskell98-1.0.1.0/List.html#v%3Aintersperse
08:39:39 <lambdabot> http://tinyurl.com/yocjhc
08:39:46 <Mitar> ndm: we only have one type of a degree and everybody have to make a defense of their diploma work
08:40:20 <Mitar> but some faculties also have a final exam, where you get questions from the whole study period
08:40:26 <mauke> http://haskell.org/ghc/docs/latest/html/libraries/base-3.0.0.0/Data-List.html#v%3Aintersperse
08:40:27 <lambdabot> http://tinyurl.com/2lz9qt
08:40:57 <ndm> dozer: known problem, todo on a whiteboard!
08:41:12 <ndm> i have to update to GHC 6.8.1, but my install of hoogle got hozed, so a bit harder to do
08:47:35 <roconnor> fuck me, kate just crashed on me
08:48:57 <byorgey> who's kate?
08:49:02 <Mitar> what's kate?
08:49:05 <Mitar> :-)
08:49:19 <byorgey> how's kate?
08:49:27 <Mitar> where's kate?
08:49:28 <Mitar> :-)
08:49:34 <mightybyte> why kate?
08:49:43 <byorgey> these are all very important questions.
08:52:05 <roconnor> kate is an editor for kde
08:52:14 <roconnor> I had just finished writing my review
08:52:17 <mar77a> pics
08:52:22 <mar77a> :p
08:53:17 <byorgey> oh, boo =(
08:54:42 <MyCatVerbs> Hrmn. What'd be the sanest way to round a number up to the nearest power of two?
08:55:40 <dcoutts_> ndm: if possibly can you reproduce on any other machine, I swear your box is haunted.
08:56:09 <ndm> dcoutts_ my home machine is 6.8.1, i think this is my last 6.6.1 machine
08:56:12 <oerjan> MyCatVerbs: i recall that being discussed before
08:56:16 <dcoutts_> ndm: before the call to installIncludeFiles incPref is right then inside the call it's different. It doesn't make any sense at all.
08:56:22 <dons> ndm: i was able to use tagsoup rather nicely in lambdabot yesterday. thanks!
08:56:32 <dozer> is ghc 6.8.1 a big improvement over 6.6?
08:56:38 <dons> dozer: yeah
08:56:49 <MyCatVerbs> dozer: a huge performance leap, and a nice debugger too.
08:57:00 <Mitar> Too many parameters for class `Somethingy'?
08:57:00 <dozer> mm - that is almst good enough to convince me to upgrade
08:57:17 <ndm> my debugger experiences have been suboptimal so far, it was next to useless
08:57:25 <MyCatVerbs> dozer: pointer tagging is supposed to be worth 10-15% straight off the bat, plus that's not the only additional optimization.
08:58:00 <ndm> dcoutts_ - missingh wouldn't have installed anyway, so i'll just give up
08:58:14 <oerjan> not if there was a really good result though
08:58:24 <dozer> ok, well, once I've delivered working binaries to my guys, I will atempt to compile with 6.8.1 then
08:58:25 <dcoutts_> ndm: I think we should provide a binary for cabal-install once it works reliably
08:58:25 <MyCatVerbs> @hoogle Int32 -> Int
08:58:26 <lambdabot> No matches, try a more general search
08:58:29 <ndm> i wouldn't bother
08:58:38 <ndm> @type fromIntegral
08:58:40 <lambdabot> forall a b. (Num b, Integral a) => a -> b
08:58:42 <Mitar> aha, this is an extension
08:58:50 <MyCatVerbs> ndm: ah, danke.
08:59:04 <ndm> dozer: i wouldn't bother, 6.8.2 is quite soon away, so you could just wait a week or so
08:59:49 <dozer> oh, fine
09:00:04 <dozer> in practice I will probably wait untill it's packaged for ubuntu
09:00:29 <Mitar> how can i enable GHC extensions from the source code?
09:00:46 <mux> {-# LANGUAGE SomeExtension #-}
09:00:48 <mux> at the top
09:00:59 <dozer> put comments like {-# OPTIONS_GHC -fglasgow-exts -fallow-undecidable-instances #-} before the module line
09:01:03 * desegnis looks forward to compiling ghc 6.8.2 with 6.8.1
09:01:43 <oerjan> LANGUAGE is preferred as it has a chance of being portable
09:01:59 <oerjan> in theory at least :)
09:02:13 <Mitar> is MultiParamTypeClasses portable?
09:02:29 <oerjan> hugs has MPTCs
09:03:28 <oerjan> i think it's probably one of the most portable extensions
09:03:37 <Mitar> so language
09:04:02 <Mitar> FunctionalDependencies?
09:04:10 <oerjan> that too
09:04:10 <idnar> \o/ power
09:04:49 <Mitar> ghc --supported-languages ...
09:04:56 <oerjan> otoh i am not sure whether hugs actually reads LANGUAGE pragmas, it seems everything is turned on with one flag
09:09:31 <yaxu> i'm trying to work out how multiple calls to evalRandIO return different results
09:09:38 <yaxu> evalRandIO (Rand (RandT x)) = getStdRandom (runIdentity . runStateT x)
09:10:47 <oerjan> :t evalRandIO
09:10:48 <lambdabot> Not in scope: `evalRandIO'
09:10:49 <yaxu> is it anything to do with the State monad, or just because it has IO in its type?
09:10:55 <yaxu> evalRandIO :: Rand StdGen a -> IO a
09:11:05 <oerjan> oh
09:11:11 <oerjan> :t getStdRandom
09:11:12 <lambdabot> forall a. (StdGen -> (a, StdGen)) -> IO a
09:12:13 <oerjan> a little of both
09:12:31 <oerjan> or rather, getStdRandom seems designed to turn State into IO
09:13:00 <Cale> There's a little bit of evil in the System.Random library.
09:13:49 <hpaste>  yaxu pasted "(no title)" at http://hpaste.org/4246
09:13:58 <Cale> In particular, there's a global variable which maintains the state of a random number generator
09:14:24 <yaxu> when i call go there, it returns the same thing each time
09:15:43 <oerjan> getStdRandom uses setStdGen internally
09:16:36 <Cale> yaxu: try it with newStdGen instead
09:16:45 <oerjan> evalRandT seems to throw the updated generator away
09:17:01 <yaxu> ah, i see
09:18:25 <oerjan> there is a default   randomIO	   = getStdRandom random
09:19:04 <dons> ?users
09:19:04 <lambdabot> Maximum users seen in #haskell: 406, currently: 405 (99.8%), active: 18 (4.4%)
09:19:09 <yaxu> newStdGen is what I wanted
09:19:20 <oerjan> and similar for randomRIO
09:20:38 <yaxu> oerjan: i guess i can only use those within an IO monad though?
09:20:46 <oerjan> yep
09:21:30 <oerjan> you could write your own version of getStdRandom to substitute into another state monad
09:22:07 <yaxu> i'm trying to combine the Maybe and Random monads
09:22:33 <yaxu> for following a markov chain with backtracking
09:23:13 <oerjan> oh now i see.  i don't know the Random monad but there is probably a runRandT too right?
09:23:50 <puusorsa> @src Random
09:23:50 <lambdabot> class Random a where
09:23:50 <lambdabot>   random    :: RandomGen g => g -> (a, g)
09:23:50 <lambdabot>   randoms   :: RandomGen g => g -> [a]
09:23:50 <lambdabot>   randomR   :: RandomGen g => (a,a) -> g -> (a,g)
09:23:50 <lambdabot>   randomRs  :: RandomGen g => (a,a) -> g -> [a]
09:23:52 <lambdabot>   randomRIO :: (a,a) -> IO a
09:23:54 <lambdabot>   randomIO  :: IO a
09:24:24 <yaxu> oerjan: there is
09:24:29 <oerjan> the RandomT monad keeps track of the generator state but your go throws it away
09:24:40 <yaxu> oerjan: i'm getting my head around monad transformers, that's the difficulty really
09:25:09 <oerjan> if you want to use that feature of RandomT you _don't_ want to escape it.
09:25:28 <yaxu> how do you mean 'escape'?
09:26:21 <oerjan> i mean that successive uses of RandomT actions should be inside the same invocation
09:27:18 <yaxu> do you mean RandT ?
09:27:49 <oerjan> :t replicateM_
09:27:51 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m ()
09:27:55 <oerjan> probably
09:28:05 <yaxu> ok :)
09:28:18 <laz0r> anybody know how Control.Monad.Fix plays together with StateT?
09:28:32 <puusorsa> if i have and xsd file, and would like to use haskell for generating a html input form and thing that parses the result of that into xml, how should i start?
09:29:17 <Syzygy-> "module MyModule where" is always a good start.
09:29:18 <Syzygy-> ;)
09:29:22 <puusorsa> true
09:29:32 <laz0r> i somehow managed to have the need to 'go back in time' and Control.Monad.Fix seems to have that feature...
09:29:43 <hpaste>  Mitar pasted "how could i this precode and postcode for parsing put into a function?" at http://hpaste.org/4247
09:29:51 <puusorsa> i have the html part kinda figured out, using fcgi
09:29:57 <oerjan> laz0r: the result value is channeled lazily back, but the action is run only once, that's the general rule for MonadFix
09:30:07 <quicksilver> laz0r: go back in time is normally free, in functional programming
09:30:07 <dozer> puusorsa: so I'm guessing you need an xsd lib next?
09:30:18 <quicksilver> it may be that you dont' mean what I mean by time travel, though
09:30:33 <quicksilver> I've always thought of monadfix as a weak version of 'go forward in time' not go backward...
09:30:48 <quicksilver> there is a MonadFix instance for StateT, anyhow.
09:30:50 <hpaste>  Mitar annotated "how could i this precode and postcode for parsing put into a function?" with "(no title)" at http://hpaste.org/4247#a1
09:30:57 <oerjan> in particular the state is _not_ automatically channeled back
09:31:08 <hpaste>  Cale annotated "how could i this precode and postcode for parsing put into a function?" with "perhaps like this?" at http://hpaste.org/4247#a2
09:31:18 <laz0r> i think we both mean the same, i have actually attempted the 'going back in time' thing by just relying on the laziness of the language
09:31:24 <ddarius> No one ever seems to need to go back in time in imperative languages.
09:31:30 <laz0r> but mfix seems to be a better way of doing it
09:32:01 <ddarius> Cale: Did you ever put something about your strictness/laziness advice on the wiki?
09:32:09 <Mitar> Cale: but "name" and "ty" got defined in your "x"
09:32:29 <Cale> ddarius: hmm, I don't think I have
09:32:49 <Cale> Mitar: ah, then you might want to make them part of the result of x
09:33:05 <Cale> Mitar: (I obviously didn't look really closely :)
09:33:50 <Mitar> but the problem is that it should work for different types of Syn
09:34:15 <hpaste>  Mitar annotated "how could i this precode and postcode for parsing put into a function?" with "examples" at http://hpaste.org/4247#a3
09:34:30 <puusorsa> dozer, right, and i'm thinking whether i should use hs-plugins or something like that and generate haskell code from the xsd when it changes, or do something like generateHtml::XSDFile -> Html and responseToXML :: XSDFile -> Input -> (Html, XMLFile)
09:35:13 <Cale> Mitar: so that "let" is really part of the code which varies
09:35:22 <Mitar> yes
09:35:45 <Mitar> but it varies only to one extend: which constructor and which parameters are used
09:35:51 <dozer> puusorsa: I'd go the latter rout - the functional one
09:36:02 <dozer> unless you have a reason to generate an API for the xsd, that you give to someone else
09:36:31 <dozer> puusorsa: presumably the xsd has some contract about when it changes? at compile-time? at run-time? frequently? once in a blue moon?
09:37:13 <puusorsa> doing this so that change in xsd doesn't require recompiling would be nice
09:37:34 <dozer> then you want a function from xsd to web page
09:39:07 <ddarius> @wiki Performance
09:39:07 <lambdabot> http://www.haskell.org/haskellwiki/Performance
09:39:09 <chessguy> whassssup, haskellers??
09:39:16 <Mitar> cale: maybe haskell template?
09:39:51 <Cale> Mitar: maybe, but I'm not sure how much you really can abstract that, or if it's really worthwhile to do so.
09:39:52 <Saizan> Mitar: i'd start with a function that takes a node, and does the rest, factoring the common (Constructor params) doesn't seem worth the trouble
09:40:00 <puusorsa> generatePageFunc :: XsdFile -> (MonadIO m => CGIT m CGIResult -> m ()) seems functional too to me
09:40:20 <Cale> Mitar: you can certainly abstract out the updateState at the beginning and the setState at the end
09:40:43 <Saizan> and checkType ..
09:40:51 <puusorsa> and i could run that whenever the xsd changes, right? would that need using hs-plugins?
09:41:03 <Mitar> i cannot abstract setState at the end as it takes env' as an argument ...
09:41:07 <Cale> maybe checkType...
09:41:26 <Cale> Mitar: so you have the parameter return the env'
09:43:12 <alexj> @seen igloo
09:43:12 <lambdabot> igloo is in #haskell, #ghc and #darcs. I last heard igloo speak 1h 17m 21s ago.
09:43:57 <hpaste>  aaim annotated "GA for chessguy" with "leave out intermediate conversions" at http://hpaste.org/4244#a1
09:44:41 <hpaste>  Saizan annotated "how could i this precode and postcode for parsing put into a function?" with "like this?" at http://hpaste.org/4247#a4
09:45:17 <Saizan> ah no, very wrong.
09:45:26 <Mitar> tym is missing :-)
09:46:43 <hpaste>  Cale annotated "how could i this precode and postcode for parsing put into a function?" with "maybe not worth it" at http://hpaste.org/4247#a5
09:47:03 <hpaste>  Saizan annotated "how could i this precode and postcode for parsing put into a function?" with "this should work if tym is always the last parameter" at http://hpaste.org/4247#a6
09:47:07 <chessguy> @seen aaim
09:47:07 <lambdabot> I haven't seen aaim.
09:47:16 <chessguy> ...
09:47:20 <chessguy> ok then
09:47:42 <Mitar> yes, tym is always the last paramater
09:47:49 <Cale> ah, yeah, you could do that.
09:49:00 <Cale> and even if it wasn't, you can return a lambda :)
09:49:12 <Mitar> yes :-)
09:49:17 <chessguy> @quote lambda
09:49:17 <lambdabot> mauke says: haskell software should move from alpha to beta to eta, then lambda
09:50:29 <Mitar> the only question is ... what type does foo have :-)))
09:51:03 <Cale> Let GHC sort it out? :)
09:51:12 <Mitar> :-)))
09:52:07 <bmeph_> Haskell: In constant lambda testing since 1998. ;)
09:52:30 <Saizan> which leaves with "how should foo be named?"
09:55:10 <Mitar> :-)
09:55:17 <Mitar> doAlmostEveryhing :-)
09:55:21 <Mitar> biggerDo
09:55:28 <Mitar> mightierDo
09:55:35 <Mitar> hideFromDo
09:55:43 <mrd> dobedobedo
09:59:30 <dozer> ah, my code compiled for the first time in 8 days
09:59:36 <dozer> a good feeling
09:59:44 * dozer commits code to repo and goes to pub
09:59:45 <Mitar> is there a known error with GHC reporting the wrong line for the error?
09:59:52 <mrd> is that because you haven't tried to compile it for 8 days
09:59:54 <Mitar> it looks like it would not cound line comments in
10:00:31 <Laney> Don't suppose anyone's got any hints for configuring kile with lhs2tex?
10:04:34 <desegnis> Mitar, version?
10:04:51 <Mitar> 6.8.1
10:05:17 <Mitar> nop, it was my mistake
10:05:26 <Mitar> it looks some cariage returns got into the file
10:05:34 <Mitar> while pasting ...
10:05:39 <desegnis> ah
10:10:03 <Mitar> but it is a little strange that this generates errors
10:11:22 <thetallguy> anyone have a link to  the video of John Hughes' keynote from ICFP 2007?
10:13:32 <pejo> thetallguy, www.ludd.ltu.se/~pj/icfp2007/ICFP2007.html
10:14:22 <thetallguy> pejo: thanks.
10:21:38 <dons> ddarius: what does the head strict list type in Clean look like?
10:21:43 <dons> !x : xs ?
10:21:54 <dons> since i've be pondering why we don't have one.
10:23:51 <dcoutts_> dons: because it'd be a different type so would be annoying in interfaces I guess
10:24:16 <dcoutts_> dons: and it doesn't help with removing indirections
10:24:56 <dons> dcoutts_: right, since we can't unbox
10:25:16 <dcoutts_> we can't at the moment, I'd like to be able to SPECIALISE that kind of thing
10:25:21 <dons> yeah
10:25:34 <dons> though package UArr is probably more useful
10:25:43 <dons> in the short erm
10:25:53 <dcoutts_> it's a more general thing than lists/arrays
10:26:18 <dons> in terms of our dev priorities :) unless you want to write about it for your thesis ?
10:26:28 <dons> (spec on strictness info , that is)
10:26:43 <dcoutts_> dons: oh, that, I might write about it, yes.
10:26:57 <dons> have we ever raised this with spj?
10:27:02 <dons> rules that match on !
10:27:24 <dcoutts_> dons: not really, I think it's major engineering since the strictness is not available at rule matching time atm.
10:27:30 <dcoutts_> it's run rather late
10:27:47 <dons> Cale: yeah, the python guy a) didn't compile with -O, b) parallelised it by forking at the top level (not on each call).
10:27:58 <dons> dcoutts_: ah yes, we talked about this
10:30:03 <dons> ?users
10:30:03 <lambdabot> Maximum users seen in #haskell: 407, currently: 404 (99.3%), active: 10 (2.5%)
10:30:31 <dons> dcoutts_: we should talk about targetting data.binary at something in 08, too.
10:30:46 <dcoutts_> dons: you mean a conference?
10:30:55 <dons> yeah. HW I'd think
10:31:05 <dcoutts_> mm, yes, that'd be good
10:31:23 * dons hacks work hacks. bbl
10:31:53 <dcoutts_> dons: though I'd also like to spend some time looking at the nested list comp issue next year either before or after finishing my thesis
10:32:27 <dcoutts_> dons: spj suggested I should apply to spend 3 months at msr doing that
10:32:55 <dons> that would be ideal. oh, i'm glad he's interested in finishing this off, too.
10:33:06 <dcoutts_> dons: I'm pretty sure it's very closely related to traditional loop optimisation and approaching it from that angle might help
10:33:19 <dons> yeah. there's many unexplored avenues here.
10:33:27 <dons> i'm pretty confident its crackable
10:33:31 <dcoutts_> @yarr!
10:33:31 <lambdabot> Arr! Me ship be the biggest brig in the port!
10:33:41 <dons> yikes
10:33:47 <dcoutts_> :-)
10:34:04 <Pastorn> @type par
10:34:08 <lambdabot> forall a b. a -> b -> b
10:34:12 <Pastorn> @type parseq
10:34:13 <lambdabot> Not in scope: `parseq'
10:34:16 <dons> pseq
10:34:21 <Pastorn> @type pseq
10:34:21 <lambdabot> Not in scope: `pseq'
10:34:32 <dcoutts_> it's the same type as seq
10:34:34 <dons> no ghc 6.8 installed on the lambdabot
10:34:36 <Pastorn> @type Control.Parallel.pseq
10:34:36 <lambdabot> Not in scope: `Control.Parallel.pseq'
10:34:41 <Pastorn> aww
10:34:47 <dcoutts_> @type seq
10:34:47 <lambdabot> forall a t. a -> t -> t
10:35:02 <oerjan> @index pseq
10:35:02 <lambdabot> GHC.Conc
10:35:21 <dcoutts_> @type GHC.Conc.seq
10:35:21 <lambdabot> Not in scope: `GHC.Conc.seq'
10:35:24 <dcoutts_> heh
10:35:34 <sjanssen> @src pseq
10:35:34 <lambdabot> Source not found. Just what do you think you're doing Dave?
10:36:02 <doserj> @type GHC.Conc.pseq
10:36:03 <lambdabot> forall a b. a -> b -> b
10:36:06 <sjanssen> pseq  x y = x `seq` lazy y
10:36:40 <Saizan> lazy?
10:37:02 <dons> sjanssen: so , xmonad 0.5? :)
10:37:06 <Pastorn> @src par
10:37:06 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
10:37:21 <Pastorn> @src seq
10:37:21 <lambdabot> Source not found. My mind is going. I can feel it.
10:37:33 <Pastorn> @src GHC.Conc.seq
10:37:33 <lambdabot> Source not found.
10:37:46 <Pastorn> now she's just f*ck*n with me
10:39:13 <oerjan> @index seq
10:39:13 <lambdabot> Prelude, Control.Parallel
10:40:03 <sjanssen> dons: soon
10:43:46 <Pastorn> is par forced evaluation (is that was i called "strict"?)
10:43:54 <Pastorn> *is called*
10:44:36 <desegnis> Pastorn: par is a hint for parallel evaluation (i.e. in different threads)
10:44:46 <dons> Pastorn: check the description in my last blog entry
10:45:15 <andrei> I have a function that I want c2hs to generate bindings for but its argument is of type void*; I know the C types that I have to shove in, how do I make c2hs accept  that as a function taking something of type Ptr?
10:45:50 <andrei> {`Ptr ()'} ->  (); doesn't work, it complains that there's no in marshaller for haskell type Ptr () to C type Ptr ()
10:51:18 <Pastorn> dons: that is what i am reading... though i am too much of a novice to understand why you built your fibs in that particular way
10:51:32 <dons> hmm?
10:51:40 <dons> its just some random code, basically
10:51:46 <dons> to look at how par works
10:51:55 <Pastorn> yes?
10:54:54 <Pastorn> but i don't get what par/parseq does
10:57:04 <sjanssen> Pastorn: do you know seq?
10:58:13 <sjanssen> Pastorn: actually, the docs here are good http://www.haskell.org/ghc/docs/latest/html/libraries/parallel-1.0.0.0/Control-Parallel.html#v%3Apar
10:58:14 <lambdabot> http://tinyurl.com/3cz2nr
10:59:18 <Pastorn> sjanssen: no, i don't know seq, but thanks
11:10:08 <monochrom> <3 haskell
11:11:21 <laz0r> mfix (\xs' -> let xs = map (+1) (1:xs') in Just xs)
11:11:51 <laz0r> ^ is there a way to stop that, when the list has a certain lenght?
11:12:29 <laz0r> without writing 'take x' in front of it
11:12:56 <oerjan> > mfix (\xs' -> let xs = map (+1) (1:xs') in Just xs)
11:12:57 <lambdabot>  Just [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
11:13:17 <oerjan> > fix (\xs' -> let xs = map (+1) (1:xs') in xs)
11:13:17 <lambdabot>  [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
11:14:05 <yaxu> laz0r: what's wrong with take x?
11:14:11 <oerjan> well the Maybe monad has nothing to do with it
11:14:37 <monochrom> You have to write "take x" somewhere. Let's say like take 10 (map (+1) (1:xs'))
11:15:28 <yaxu> that reminds me, must find my copy of programming in haskell
11:15:38 <laz0r> yaxu, this is only a simple example with which im trying to understand that MonadFix thing, i actually wanna do sometinhg else, and there it would be necessary to stop the loop based on the information i have inside the loop
11:16:22 <oerjan> laz0r: the first thing to note is that the _action_ is always executed once and once only
11:16:49 <Stinger_> @ty mfix
11:16:50 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
11:17:01 <shapr> @yow !
11:17:02 <lambdabot> My nose feels like a bad Ronald Reagan movie ...
11:17:06 <grahamhutton> yaxu :-)
11:17:09 <Stinger_> @src mfix
11:17:09 <lambdabot> Source not found.
11:17:13 <Stinger_> bah humbug
11:17:25 <oerjan> @src MonadFix
11:17:25 <lambdabot> class (Monad m) => MonadFix m where
11:17:25 <lambdabot>     mfix :: (a -> m a) -> m a
11:17:44 <oerjan> @src Maybe mfix
11:17:44 <lambdabot> mfix f = let a = f (unJust a) in a where unJust (Just x) = x
11:18:25 <Stinger_> Im assuming mfix f does something like   =>> f =>> f=>> etc
11:18:34 <monochrom> No, it doesn't.
11:18:45 <oerjan> Stinger_: no.  i made that mistake once too.
11:19:12 <monochrom> It gives recursion over the value returned, not the action.
11:20:17 <shapr> What's going on?
11:21:10 <laz0r> mmh, ok what i actually want to do: i wnat to evaluate runStateT s foo, and i would like to change the foo based on what comes out of runStateT
11:21:20 <laz0r> i fear that might be impossible altogether
11:21:45 <laz0r> or maybe it is a stupid idea and i should have done it somehow different in the first place...
11:21:57 <oerjan> laz0r: as long as you don't actually look at what comes out (i.e. is sufficiently lazy) before it does
11:23:41 <oerjan> but you can probably save it in the state
11:24:53 <nominolo> @seen dcoutts
11:24:53 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-overflow, #haskell and #ghc. I last heard dcoutts speak 7h 34m 9s ago.
11:24:54 <oerjan> > flip runState 1 $ mfix $ \v -> do x <- get; put v; return x
11:24:56 <lambdabot>  (1,1)
11:25:00 <dcoutts_> hia nominolo
11:25:00 <nominolo> @seen dcoutts_
11:25:01 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell-overflow, #haskell and #ghc. I last heard dcoutts_ speak 1s ago.
11:25:05 <dcoutts_> @arr!
11:25:05 <lambdabot> Yo ho ho, and a bottle of rum!
11:25:15 <laz0r> oerjan, i tried with something like this: let ps = execStateT r p; zps = zip [0..] ps in map (\(z,_) -> (runStateT r (P (i,j) z)) !! z) zps
11:25:32 <laz0r> but that doesnt look like the right thing to do
11:25:33 <nominolo> dcoutts_: rrreaaadyyy?
11:25:50 <dcoutts_> nominolo: sure, want to look at make stuff or cabal-install ?
11:26:02 <nominolo> i don't care
11:26:26 <laz0r> oerjan, the idea behind that is to enumerate the results
11:26:40 <dcoutts_> nominolo: there are more paralelisable dev tasks in the make stuff I guess...
11:26:49 <dcoutts_> nominolo: lets move discussion to #ghc
11:26:54 <nominolo> k
11:27:27 <oerjan> laz0r: sorry, i'm too tired it seems
11:28:17 <laz0r> oerjan, ok, no problem
11:35:22 <jsnx> i'd like to turn a String into a ByteString -- how do i do it?
11:35:38 <dcoutts_> @hoogle String -> ByteString
11:35:39 <lambdabot> No matches, try a more general search
11:35:42 <dcoutts_> bah
11:35:46 <Saizan> jsnx: Data.ByteString.Char8.pack
11:35:53 <dcoutts_> @type Data.ByteString.Char8.pack
11:35:54 <lambdabot> String -> Data.ByteString.Base.ByteString
11:36:00 <dcoutts_> silly hoogle
11:36:19 <andrei> I have a function I need c2hs bindings; but its argument is void*; how do I get c2hs to do that (I know which Ptr type it will take if that helps)?
11:37:13 <jsnx> @hoogle  String -> Data.ByteString.Base.ByteString
11:37:13 <lambdabot> No matches, try a more general search
11:37:39 <jsnx> Saizan: well, that doesn't work when the string is "ä½ "
11:37:48 <jsnx> (unicode 20320)
11:38:13 <jsnx> @hoogle a -> Data.ByteString.Base.ByteString
11:38:13 <lambdabot> No matches, try a more general search
11:38:23 <jsnx> @hoogle a -> ByteString
11:38:23 <lambdabot> No matches, try a more general search
11:38:52 <dcoutts_> jsnx: ByteString is a string of bytes, it's not unicode.
11:39:33 <jsnx> dcoutts_: unicode is a string of bytes
11:39:48 <jsnx> when i convert "ä½ " i should get three bytes
11:39:51 <jsnx> instead, i get one
11:39:56 <monochrom> Let's just agree to disagree.
11:40:25 <monochrom> (Hint: UTF-8 /= Unicode. Type mismatch.)
11:40:25 <jsnx> monochrom: i don't understand
11:40:42 <jsnx> still don't understand what you're getting at
11:40:57 <dcoutts_> jsnx: no, unicode is a string of characters, not a string of bytes
11:41:11 <allbery_b> unicode is composed of codepoints.  there are multiple ways to encode codepoints as bytes
11:41:19 <Zao> jsnx: One can stuff UTF-8, which is an unicode transformation format into a bytestring.
11:41:24 <allbery_b> utf8? utf7? ucs2?
11:41:29 <Zao> It doesn't make the bytestring aware of the contents in any way.
11:41:42 <jsnx> dcoutts_: very well -- but i what i want is the three bytes in utf8 representation of "ä½ "
11:41:48 <glguy> jsnx, that character in UTF-8 is e4 bd a0
11:41:56 <jsnx> glguy: yes, i know
11:42:04 <jsnx> but i am going to process thousands of them
11:42:09 <Zao> jsnx: The Unicode Standard documents how to convert to the assorted transformation formats.
11:42:19 <Zao> Shouldn't be that hard to implement a converter.
11:42:31 <Zao> Chapter 5, if I'm not all wrong :)
11:42:34 <allbery_b> have you checked hackage?
11:42:40 <jsnx> Zao: i am not asking how to do the conversion
11:42:44 <jsnx> i know how
11:42:59 <jsnx> i am asking, how to get the three bytes, so i can do the conversion
11:43:04 <glguy> jsnx, and the utf8-string library handles that correctly
11:43:08 <monochrom> Look for packages "encoding" and "utf8-string" on Hackage.
11:43:29 <jsnx> glguy: well, i have not fully explained the conversion...
11:43:38 <monochrom> Also notable: iconv
11:43:54 <dcoutts_> jsnx: if you want proper unicode use String, we do not yet have a unicode equivalent of ByteString though everyone knows we need one.
11:44:44 <jsnx> i want to convert a utf8 char to a percent encoded string -- 'ä½ ' -> "%e4%bd%a0"
11:45:07 <jsnx> none of the URL libs do it correctly
11:45:20 <glguy> jsnx, so use the functions provided in Network.URI
11:45:27 <glguy> to escape the UTF-8 encoded string
11:45:37 <monochrom> Do you know function composition?
11:45:40 <jsnx> glguy: doesn't work
11:45:49 <glguy> jsnx, you, you aren't doing it right :-/
11:45:51 <jsnx> glguy: it gives the wrong result
11:45:52 <glguy> no*
11:46:01 <monochrom> Like given two functions f and g, you can construct yet another function f . g ?
11:46:38 <monochrom> And therefore, for example, there is no need for a library to provide "a function that does foo and then bar"?
11:47:04 <monochrom> Because if one library provides foo, and another library provides bar, then all you need to do is "foo . bar"?
11:47:11 <jsnx> > Network.URI.escapeURIChar (const False) 'ä½ '
11:47:11 <lambdabot>  Improperly terminated character constant at "'ä½ '" (column 41)
11:47:33 <jsnx> yields %4f60
11:47:45 <jsnx> not %e4%bd%a0
11:47:49 <glguy> jsnx, like everyone keeps telling you, you have to utf-8 encode first
11:47:49 <monochrom> And therefore, for example, if one library function outputs UTF-8, and another library function does % encoding, then you can just use "." to combine them?
11:47:50 <jsnx> glguy: and that is wrong
11:47:56 <glguy> jsnx, right, you screwed up
11:47:59 <glguy> so you got bad result
11:48:28 <monochrom> And therefore, there is no need for the first library to do % encoding, and no need for the second library to do UTF-8 encoding?
11:48:48 <glguy> yes, leave the utf-8 bytes alone if you are treating them opaquely
11:49:15 <monochrom> Did you know that there are infinitely many programs?
11:49:53 <monochrom> But the library does not have to be infinite, because a small number of primitives can combine to generate any of them?
11:50:12 <jsnx> glguy: in my program, i use utf8 simple to read in the chars
11:50:42 <jsnx> glguy: then i feed each char to the percent-encoder
11:51:00 <jsnx> here, just a sec
11:51:02 <glguy> jsnx, use the normal System.IO, not the utf8-string
11:51:10 <gio123> is somebody here german speaker?
11:51:12 <glguy> because you don't want to decode the UTF-8
11:51:25 <glguy> you want to percent encode it instead
11:51:40 <jsnx> tps://svn.j-s-n.org/public/notes/chinoiserie/bin/Lookup.hs
11:51:50 <jsnx> https://svn.j-s-n.org/public/notes/chinoiserie/bin/Lookup.hs
11:52:02 <dcoutts_> jsnx: I think Network.URI.escapeURIChar is wrong if it doesn't escape unicode chars correctly, afterall it does accept String and String in Haskell is Unicode.
11:52:12 <jsnx> dcoutts_: right
11:52:18 <glguy> URLs don't support unicode
11:52:28 <dcoutts_> jsnx: now, on the other hand, Data.ByteString.Char8.pack is a different matter
11:52:36 <jsnx> dcoutts_: ?
11:52:37 <glguy> the encoding of UTF-8 characters like you do is a hack
11:52:55 <dcoutts_> glguy: oh I thought they did via some standard encoding. My mistake.
11:53:04 <glguy> general you
11:53:07 <jsnx> glguy: can you write a line of code that correctly percent encodes 'ä½ ' ?
11:53:16 <glguy> yes
11:53:20 <glguy> and I have told you how many times
11:53:23 <glguy> but you don't read
11:53:25 <Zao> If you want Unicode URIs, they're called IRIs: http://www.w3.org/International/O-URL-and-ident.html
11:53:25 <lambdabot> Title: Internationalized Resource Identifiers (IRIs)
11:53:34 <dcoutts_> jsnx: Data.ByteString.Char8 is explicitly only for 8 bit chars, not unicode.
11:53:34 <jsnx> Zao: i've read that
11:54:34 <jsnx> so, if i read the chars in with a utf8 aware getContents, they should be a utf8 string, yes-no?
11:54:47 <monochrom> If every program has already been written, what is the purpose of existence of programmers?
11:54:56 <glguy> jsnx, you need to encodeString in formURL around hanzi!
11:55:09 <glguy> you have to percent encode utf-8 bytes
11:55:45 <Zao> monochrom: Finding the right program.
11:56:01 <Zao> Although there will be a program for that, bah.
11:56:07 <monochrom> haha
11:56:10 <andrei> I have a function I need c2hs bindings; but its argument is void*; how do I get c2hs to do that (I know which Ptr type it will take if that helps)?
11:56:28 <Zao> I do see a bootstrapping problem though in finding the program that finds programs.
11:56:44 <glguy> jsnx, and no, if you read a string with a utf8 aware function, it wil be a *unicode* string
11:56:47 <glguy> and not a utf-8 one
11:57:01 <jsnx> glguy: aha
11:57:03 <jsnx> thanks
11:57:08 <monochrom> I don't want to call that "programmer". "Programmer" should write programs. Someone else will have to find written ones. Maybe "system analyst".
11:57:27 <jsnx> so i need to turn it back into utf8 with encodeString
11:57:32 <jsnx> glguy: thank you
11:57:58 <monochrom> Or, do not decode in the first place. Use the dumb getContent.
11:58:37 <Zao> Text is hard.
11:59:32 <monochrom> Yes. 90% of programmers still don't know that the standards have divorced glyphs, code points, internal representations, external representations.
11:59:57 <monochrom> They still assume the 19th Century notion of "character set".
12:00:16 <jsnx> monochrom: i have to decode, so i can iterate over the chars one by one and do a dictionary lookup on them
12:00:30 <monochrom> I see.
12:01:08 <jsnx> of course, i could always `take 3` over and over again
12:01:17 <jsnx> seems like a bad practice to me, though
12:01:32 <Deewiant> Do you want to iterate over code points or grapheme clusters? "character" is overloaded.
12:01:47 <olsner> I think many programmers even assume that everybody speaks english and/or can write their language in 7-bit ascii
12:02:08 <monochrom> Someone is bound to enter "ä½ å¥½å¤švirus". take 3 will break.
12:03:14 <jsnx> monochrom: i agree
12:03:21 <monochrom> It is probably a good thing Americans are losing programming jobs to Indians. At least the latter know that there are a couple more languages!
12:03:21 <jsnx> so, i decoded it
12:03:24 <Deewiant> Should U+00e4 be considered the same as U+0061 U+0308? If so, you have to do decomposition.
12:03:46 <jsnx> Deewiant: eh, what? decomposition?
12:03:55 <monochrom> It also helps that China is also rising.
12:04:00 <Deewiant> U+00e4 is Ã¤, "latin small letter a with diaeresis"
12:04:24 <Deewiant> U+0061 is a, "latin small letter a" and U+0038 is "combining diaeresis"
12:04:42 <Deewiant> so with U+0061 U+0308 you get the same "grapheme cluster" as U+00e4
12:04:42 <jsnx> monochrom: where are you from?
12:04:54 <monochrom> I'm in Canada. I came from Hong Kong.
12:05:08 <Deewiant> And under normalization, they're the same "character". But in the byte string you get, one is two "characters" and the other is one "character".
12:05:11 <monochrom> But I really want to say, I came from Earth.
12:05:24 <monochrom> (IMO petty boundaries should be ignored.)
12:05:50 <allbery_b> worse than that, actually:  there are at least 3 ways to look at ×›Ö¼Ö°
12:06:01 <jsnx> allbery_b: go on
12:06:07 <monochrom> fun fun fun
12:06:29 <Deewiant> allbery_b: hey, don't mess up my display like that :-)
12:06:42 <allbery_b> it can be mu;tiple UTF8bytes, multiple codepointns (kaf-dagesh-sheva), or a single grapheme
12:06:42 <Plareplane> allbery_b, something must be wrong with my eyes. that bit at the end flops around when i select it
12:06:56 <allbery_b> Plareplane: it's Hebrew, so RTL
12:06:56 <olsner> unicode has so many dark corners so poorly understood by so many
12:07:09 <allbery_b> most programs handle switchng from LTR to RTL inline poorly at best
12:07:57 <olsner> it flops around for me too when selecting - seems GTK's selection code interferes with the support for bidirectional text
12:08:14 <ray> wouldn't it be a problem if it *didn't* do that?
12:08:16 <jsnx> we should all just use 'simple english'
12:08:16 <allbery_b> yep
12:08:32 <jsnx> or classical chinese...
12:08:39 <SamB_XP> ray: didn't do what?
12:08:44 <jsnx> pick one, impose it on the world, and get it over with
12:09:03 <ray> jump to the right side of the rtl stuff
12:09:03 <jsnx> just not arabic, because it's hard to render all the ligatures
12:09:28 <SamB_XP> jsnx: it's not that hard
12:09:33 <allbery_b> heh, yes, that's another fun one.  4 letterforms for each letter
12:09:42 <jsnx> SamB_XP: i am just teasing
12:09:53 <SamB_XP> jsnx: if we used that, we'd get the support rigt
12:09:56 <SamB_XP> er. right
12:10:17 <jsnx> SamB_XP: cobra la la la la
12:10:18 <lament> written text is impossible to "quantize" sanely in the general case
12:10:24 <olsner> allbery_b: are those letter forms encoded differently, or is the differentiation done as part of rendering the font?
12:10:37 <Deewiant> both?
12:10:38 <jsnx> lament: for a second, i though lambdabot said that :)
12:10:44 <SamB_XP> olsner: rendering, of course
12:10:44 <allbery_b> not sure, actually
12:11:24 <olsner> SamB_XP: I wouldn't be too sure of that... if I know anything it is that I know nothing!
12:11:51 <SamB_XP> now what I can't say is whether the font is supposed to give instructions or whether the renderer is supposed to understand arabic
12:12:05 <allbery_b> looks to me like separate codepoints for each variant
12:12:15 <SamB_XP> allbery_b: what, seriously?
12:12:21 <SamB_XP> yuck
12:12:23 <allbery_b> how Unicode deals with this I don't know
12:12:38 <jsnx> i think there must be separate code points, so that you can say, here is something that looks like <particular form>
12:12:51 <allbery_b> agreed
12:12:55 <SamB_XP> they give seperate codepoints for each version of the same letter, but they use the SAME codepoints for japanese and chinese???
12:13:04 <allbery_b> it's not up to unicode to specify usage like that
12:13:07 <jsnx> SamB_XP: well, they are the same characters
12:13:13 <allbery_b> SamB_XP: welcome to the fun that is Unicode
12:13:18 <jsnx> just like all the european languages share ASCII
12:13:21 <lament> jsnx: that's very debatable
12:13:27 <lament> also false
12:13:28 <jsnx> lament: for a few characters
12:13:30 <ray> i thought the font handled that stuff for arabic?
12:13:47 <jsnx> lament: but many are the same, and they encode some of the different ones
12:14:22 <lament> what does "the same" mean?
12:14:32 <SamB_XP> there are apparantly people who feel very strongly that the japanese characters aren't the chinese characters
12:14:47 <lament> what does "all the european languages share ascii" mean? Is Russian H the same as English H?
12:14:50 <SamB_XP> I imagine these people ought to know...
12:15:03 <jsnx> lament: fine, *western* european...
12:15:20 <SamB_XP> since I can hardly imagine such strong feelings from people who do not know...
12:15:30 <jsnx> SamB_XP: there are strong opinions both ways on the issue
12:15:36 <allbery_b> some of it is political
12:15:37 <ray> what about Ã§?
12:15:42 <lament> Why is Russian X different from English X, but English X and Portuguese X are the same?
12:15:47 <SamB_XP> jsnx: yes, but who holds the unification opinion?
12:15:50 <jsnx> ray: they have all of ASCII, and they add some
12:15:51 <lament> all three are pronounced differently
12:16:16 <olsner> I get the feeling that unicode will never be implemented correctly until we have omniscient software
12:16:25 <jsnx> just like Japanese and Chinese share a large corpus of characters, and then have their own variations, too
12:16:28 <Deewiant> lament: the Russian comes from the cyrillic alphabet, the latter from the latin?
12:16:37 <jsnx> for example, different ways to write the number one
12:16:40 <SamB_XP> lament: western europeans have been using compatible type for ages, haven't they?
12:16:50 <ray> olsner: it could be done if you didn't have to be compatible with anything else
12:16:53 <jsnx> SamB_XP: since the dawn of type
12:17:01 <lament> SamB_XP: they have, i'm just trying to understand what "the same" means
12:17:14 <SamB_XP> well, if the type is compatible that's a good clue ;-)
12:17:25 <jsnx> and the chinese and japanese have been using compatible characters
12:17:29 <lament> SamB_XP: surely that's the case with japanese/chinese characters as well?
12:17:38 <lament> simplified chinese, anyway
12:17:43 <Plareplane> problem with han unification is that it's difficult to specify which variant glyph you want
12:18:03 <jsnx> lament: actually, simplified chinese marks a break with the characters in use by the japanese
12:18:31 <jsnx> since the japanese still use the "old" characters (as do the taiwanese)
12:18:43 <lament> i'm pretty sure i've seen simplified characters in japanese
12:19:00 <jsnx> lament: they have their own simplifications :)
12:19:02 <desegnis> gio123: Check #haskell.de
12:19:23 <lament> aha, "Some of the new forms found in Shinjitai are also found in Simplified Chinese, but Shinjitai is generally not as extensive in the scope of its modification as Simplified Chinese. "
12:19:33 <SamB_XP> lament: I'm pretty sure I've seen Es in japanese...
12:19:37 <lament> i guess this is a good argument for keeping japanese and chinese characters separate, after all
12:20:04 <lament> since japanese is neither like simplified chinese, nor like traditional chinese, but a mixture of both plus its own characters...
12:20:10 <jsnx> when was shinjitai introduced? is it a japanese simplification effort?
12:20:19 <lament> yes, after WWII
12:21:37 <olsner> SamB: you mean like 'ãƒ¨'?
12:21:46 <SamB_XP> olsner: no... like E
12:22:05 <jsnx> one of the major benefits of the characters, in an economic sense, was a uniform writing system *not attached* to a spoken language
12:22:21 <jsnx> it facilitated trade and diplomacy
12:22:28 <SamB_XP> of course, it was probably in the middle of an english word...
12:22:43 <monochrom> ï¼¡ï¼¢ï¼£ï¼¤ï¼¥
12:22:55 <lament> (is german SS the same an english SS? Apparently they are, since they're "the same type"...)
12:22:59 <jsnx> it is too bad all the major character users are balkanizing the hanzi, introducing variations and so forth
12:23:24 <jsnx> it's like the browser wars
12:23:34 <allbery_b> lament: actually there's a related issue there.  es-zet is technically nto the same as Greek lowercase beta but is often encoded that way
12:23:53 <SamB_XP> hey, those letters are serifed in the middle of my otherwise sans-serif text...
12:23:54 <olsner> jsnx: iirc, the chinese also use idiograms to write phonetically using the pronounciation of the chinese words they represent
12:24:20 <andrei> Hi; can c2hs generate bindings for a function taking a void* ?
12:24:52 <jsnx> olsner: no, they make new ideograms with ones that had similar sounds in ancient times
12:25:09 <jsnx> these ideograms have two parts
12:25:14 <jsnx> a sound part and a meaning part
12:25:27 <jsnx> but they don't use an ideogram for sound alone
12:25:36 <Plareplane> SamB, are you just talking about full width latin characters?
12:25:42 <ray> allbery_b: but they don't even look the same
12:25:46 <lament> of course the chinese use characters phonetically, when they want to transcribe foreign names for example
12:26:01 <allbery_b> right, but they're "close enough" and beta was often more readily available than proper es-zet
12:26:05 <SamB_XP> Plareplane: yeah... those ones up there ^^^
12:26:05 <jsnx> lament: they tend to use english for that, these days
12:26:15 <ray> well, by that logic you could just use 'B'
12:26:18 <jsnx> lament: unless it's a 'proper name'
12:26:28 <jsnx> (like a business partner or something)
12:26:30 <ray> but yeah, i get you
12:26:34 <lament> jsnx: not always.
12:26:44 <monochrom> ï¼¡ is a "full-width" character. It originated in 20th Century "Chinese software".
12:26:47 <jsnx> as implied by 'tend'
12:27:08 <monochrom> Or perhaps there were more originations, e.g., the Japanese also invented the same idea.
12:27:14 <olsner> Aï¼¡Aï¼¡A
12:27:19 <lament> plus there's centuries of tradition of literary translation
12:27:26 <jsnx> lament: however, olsner was referring to a different practice
12:27:42 * SamB_XP was under the impression that chinese characters were pronounced differently in different chinese languages
12:27:50 <jsnx> SamB_XP: yes, they are
12:28:06 <jsnx> and in japanese, korean, vietnamese...
12:28:09 <SamB_XP> would make phonetic usage odd...
12:28:14 <lament> SamB_XP: it is odd
12:28:29 <lament> SamB_XP: eg, classical poetry no longer reliably rhymes
12:28:45 <lament> of course, that sometimes happens even in English
12:28:46 <monochrom> haha, poetry non-portable!
12:29:03 <monochrom> "this poem requires ghc >= 6.8.1"
12:29:04 <jsnx> SamB_XP: the phonetic compounds were formed a long time ago, by a few literati
12:29:15 <allbery_b> Î²ÃŸ
12:30:03 <SamB_XP> allbery_b: the sad thing is that I can't tell which one of those is the real beta
12:30:08 <jsnx> the troubling thing with the rhyming is that there is no way to get it back in Chinese, because it's just characters...
12:30:16 <jsnx> SamB_XP: the former
12:30:25 <lament> jsnx: you can read with classical pronunciation rules :)
12:30:46 <lament> which the linguists can probably figure out to a large extent
12:31:05 <jsnx> lament: they have a lot of trouble
12:31:29 <jsnx> the 'classical pronounciation' is also suspiciously different from place to place in china
12:31:50 <SamB_XP> jsnx: I find it hard to consider that suspicious
12:31:50 <jsnx> (according to professors -- i haven't done that kind of leg work myself)
12:31:54 <ray> cycle through possible pronunciations until it rhymes
12:32:13 <jsnx> SamB_XP: if it's the 'classical pronounciation', it should be *exactly* the same
12:32:24 <SamB_XP> jsnx: china is a big place
12:32:39 <Cale> orange ~ door hinge
12:32:57 <jsnx> SamB_XP: what it tells us is that none of the received pronounciations for classical is likely correct
12:33:25 <jsnx> SamB_XP: and so, we have to try to do historical phonology on a language that does not record its sounds...
12:33:30 <lament> chinese sounds kinda silly anyway :)
12:33:47 <monochrom> Yes absolutely.
12:33:49 <lament> jsnx: no languages recorded their sounds... until the invention of the grammophone :)
12:34:01 <monochrom> And English sounds fine but spells silly.
12:34:12 <SamB> at least english sometimes looks something like it sounds...
12:34:22 <lament> jsnx: look at latin, they're having similar problems with classical pronunciation
12:34:23 <allbery_b> some people would disagree about that, especially with respect to "r"
12:34:29 <jsnx> monochrom: english has the most convoluted spelling system of any western european language
12:34:30 <Cale> http://en.wikipedia.org/wiki/Lion-Eating_Poet_in_the_Stone_Den
12:34:30 <lament> SamB_XP: chinese also sometimes looks something like it sounds.
12:34:31 <lambdabot> Title: Lion-Eating Poet in the Stone Den - Wikipedia, the free encyclopedia
12:34:45 <monochrom> I mean what's with needing to add "s" sometimes?
12:35:00 <jsnx> monochrom: for what? the plural?
12:35:03 <monochrom> Yes!
12:35:13 <jsnx> monochrom: all western languages have that
12:35:14 <SamB> monochrom: we have to that when we talk too
12:35:16 <desegnis> SamB: Not always from the perspective of a learner. In fact, English and Chinese are quite similar here. For every word you have to learn how it's written as well as how to pronounce it.
12:35:19 <jsnx> or something similar
12:35:58 <lament> monochrom: where in canada are you?
12:36:03 <monochrom> Toronto
12:36:04 <Cale> With English, the written form is a pretty strong hint to pronunciation though.
12:36:05 <jsnx> desegnis: a worthy point. english is considered to be grammatically closer to chinese than other western languages, because we've lost so much of the indo-european case system
12:36:05 <SamB> desegnis: at least in english you also have the option of mispronouncing it
12:36:20 <SamB> I gather that isn't feasable in chinese
12:36:26 <desegnis> :)
12:36:48 <monochrom> hahaha, lots of Chinese characters are mispronounced on a daily basis.
12:37:08 <jsnx> lament: alphabetic languages don't record their 'sounds' but they record their phonemes -- meaningful sound elements
12:37:08 <lament> Cale: that's also true of many chinese characters.
12:37:17 <allbery_b> "ghoti" }:>
12:37:20 <SamB> well, I mean, you have to at least know the character in order to mispronounce it, don't you?
12:37:33 <jsnx> lament: whereas character languages record their 'memes' :)
12:37:36 * desegnis praises the rather well-known http://www.hep.wisc.edu/~jnb/charivarius.html
12:37:37 <lambdabot> Title: Chaos: A Poem
12:37:58 <Cale> lament: How do you guess the sound of a character? Can it be derived from the radicals in some way?
12:38:10 <SamB> jsnx: how do you explain new york?
12:38:25 <lament> Cale: yes
12:38:27 <jsnx> SamB: uhm...
12:38:34 <jsnx> SamB: can you repose the problem?
12:38:49 <lament> jsnx: alphabetic writing systems may or may not record phonemes in any sensible fashion :)
12:39:00 <lament> jsnx: eg english is alphabetic and look how that turned out
12:39:08 <jsnx> lament: english is an extreme rarity
12:39:09 <SamB> well, they don't seem to assign the same phonemes to the text as normal people do...
12:39:40 <jsnx> lament: it's the result of forced latinization of a germanic language
12:39:58 <jsnx> with explosive vocabulary growth, at the same time
12:40:02 <SamB> jsnx: are you blaming this on the romans?
12:40:09 <jsnx> the norman french
12:40:21 <SamB> ah
12:40:25 <Botje> is there a time table for haskell prime?
12:40:30 <lament> jsnx: anyway, i don't know of any indoeuropean languages with real phonetic writing
12:40:39 <jsnx> lament: italian
12:40:40 <SamB> do I have them to blame for the idea that you shouldn't split infinitives?
12:40:43 <lament> they all have weird exceptions
12:40:56 <jsnx> lament: but generally a few exceptions
12:41:04 <jsnx> and fewer overlaps
12:41:21 <jsnx> english is exceptional -- 45 phonemes, 1500 ways to spell them
12:41:44 <jsnx> italian is on the other end of the spectrum -- 22 phonemes, 35 ways to spell them
12:42:00 <SamB> how many different combinations of one of those phonemes with one of those ways to spell them are there?
12:42:11 <jsnx> SamB: what?
12:42:25 <desegnis> lament: French, in a sense. The rules are overly complicated, but there are only very few exceptions in how to pronounce a word.
12:42:35 <jsnx> german, too
12:42:36 <SamB> jsnx: what, sometimes you could spell two different phonemes the same way
12:42:54 <jsnx> SamB: sure -- haven't seen figures for that
12:43:16 <lament> jsnx: wikipedia lists a bunch of interesting exceptions for italian, such as "pesca" being pronounced two different ways and meaning different things
12:44:53 <lament> desegnis: oh, it's true of many languages "in a sense
12:44:56 <fasg> i have the weirdest problem. a simple function works ok when i write it at the toplevel, but when i put it inside a "let" in another function then i get a type error during compile
12:44:56 <lament> "
12:45:17 <jsnx> lament: my point is the english is unusually full of exceptions
12:45:36 <TSC> fasg: Can you paste it for us to have a look at? (hpaste.org)
12:45:41 <jsnx> lament: and that the organizing principle for alphabetic languages is to record phonemes
12:45:51 <lament> right, but my original point was that just because latin is alphabetic, there still are problems figuring out the classical pronunciation :)
12:45:53 <jsnx> lament: and that makes reconstructing rhymes easier
12:45:58 <lament> s/just because/despite
12:46:52 <fasg> TSC: well it's actually a pretty large program. i'm wondering if there is some issue about this
12:47:10 <jsnx> lament: now, on the other hand, consider ideographic languages -- they don't bother with phonemes, and that makes reconstructing the rhymes more difficult
12:48:15 <TSC> fasg: What's the type error?
12:48:31 <lament> jsnx: but chinese does, for many characters
12:48:56 <lament> jsnx: and egyptian used characters phonetically all the time
12:49:16 <fasg> TSC: ah, i figured it out! i called the argument to the outer function "map" and my inner function used the map function. doh!
12:49:22 <jsnx> lament: in classical chinese, that's not the case
12:49:28 <desegnis> A difficult thing about Chinese is that you want to think that half of the words rhyme anyway.
12:49:48 <jsnx> lament: there were phonetic compounds, sure -- that's all we have to go on
12:50:01 <TSC> fasg: With GHC, using -Wall will warn you when you do things like that
12:50:05 <fasg> TSC: This is not the first time this has happened to me, and it is always very confusing! I think ghc should give a better error message
12:50:20 <jsnx> lament: and sometimes, people forgot a character and so picked a similar sounding one
12:50:58 <CRathman> this Haskell newbie is lost.  could use some help trying to grapple with random number generation.
12:50:59 <jsnx> lament: but that doesn't really provide you with the quality of information available for latin or old english or german or even greek
12:51:00 <olsner> hmm, does aÌˆ look like an Ã¤ to you? (0041+0308 vs 00e4)
12:51:21 <CRathman> from the wiki I gather:
12:51:23 <CRathman> my_random n = do
12:51:24 <lament> jsnx: hee, http://www.paulwilt.com/Chinese/Hanzi/how_phonetic_is_the_chinese_script.htm
12:51:25 <lambdabot> Title: How Phonetic is the Chinese Script, http://tinyurl.com/2qcfs2
12:51:25 <CRathman>    x <- getStdRandom $ randomR (0, n)
12:51:27 <CRathman>    return x
12:51:28 <CRathman> n = my_random 999
12:51:34 <jsnx> olsner: to me, it looks like 'a' followed by dot-dot
12:51:42 <fasg> TSC: when using -Wall, the error message is the same
12:52:00 <TSC> fasg: But when you use the name "map", it will say that it shadows an existing binding
12:52:14 <fasg> TSC: no, it didn't say that
12:52:35 <jsnx> lament: how is that relevant to classical studies?
12:53:35 <lament> has the character set changed significantly from classical times?
12:53:39 <TSC> fasg: Really?  It does for me, if I write "f map = 0" for example
12:53:48 <jsnx> lament: the language has changed enormously
12:53:58 <jsnx> lament: the characters are used differently
12:54:02 <fasg> TSC: i am using ghc 6.6
12:54:09 <TSC> Even 6.6 should do it
12:54:20 <jsnx> lament: 'modern chinese' was not written in until the early 1900s
12:54:36 <yaxu> CRathman: what's the problem?
12:54:39 <jsnx> lament: 'modern chinese' -> 'vernacular chinese'
12:55:08 <TSC> fasg: Oh, it might not print it if it gets confused by the error beforehand
12:55:09 <fasg> TSC: hm... i guess you are right. Thanks! wow -Wall gives me hundreds of warnings throughout my code! :O
12:55:14 <CRathman> yaxu: that random generator seems to work - but it doesn't return an int (IO a or somesuch)
12:55:35 <jsnx> lament: that article argues persuasively that studies promoting the phoneticity of chinese are methodologically flawed
12:55:43 <yaxu> CRathman: by the way please use this when sharing code with the channel http://hpaste.org/new
12:56:04 <jsnx> lament: these things are complicated. i am very wise. just shut your face and believe me.
12:56:10 <lament> not sure about persuasively, but yes, it certainly argues that :)
12:56:33 <lament> wow, went out with a bang
12:56:42 <hpaste>  crathman pasted "random numbers" at http://hpaste.org/4248
12:56:45 <Deewiant> is there a way to get GHCi to output the "forall" with :t
12:56:54 <yaxu> CRathman: thanks :)
12:57:21 <CRathman> not exactly all the code, but hopefully enuf to get idea?
12:57:37 <TSC> Deewiant: Try -fglasgow-exts
12:58:05 <Deewiant> TSC: cheers. So it's not standard?
12:58:28 <CRathman> Not haskell savvy enuf, but I think the question is how do you convert an 'IO a' result into a plain 'a'?
12:58:33 <hpaste>  (anonymous) annotated "random numbers" with "(no title)" at http://hpaste.org/4248#a1
12:58:50 <yaxu> CRathman: I added a version that works
12:58:56 <TSC> Deewiant: The forall is implicit in Haskell 98; I think you only explicitly need foralls when you're doing non-Haskell-98 stuff, so normally it doesn't bother to print it
12:59:03 <SamB> yaxu: you forgot your name!
12:59:05 <CRathman> yaxu: thanks!
12:59:31 <Deewiant> TSC: alright, cheers
12:59:33 <yaxu> SamB: yes but it's ok, I've got it written down somewhere
13:01:30 <yaxu> CRathman: you'll need to read about IO to get a feel for why you need <- there and not =
13:02:58 <Deewiant> question follows
13:03:03 <Deewiant> I have a String containing two types of records, call them "A" and "B"
13:03:08 <yaxu> CRathman: making the random number generator involves IO -- it's seeded from the clock or something
13:03:10 <CRathman> yaxu: It's the part of Haskell I'm currently blind to.  Trying to rework my SICP translation for Haskell a bit.
13:03:14 <Deewiant> in an imperative language what I'd do is use a for loop to iterate over the string
13:03:24 <CRathman> planning on getting Haskell School of Expression for xmas
13:03:31 <Deewiant> then when I find a record, I'd pass it to doStuffWithA or doStuffWithB and increment the index of the for loop so that I skip over it
13:03:48 <Deewiant> is there a relatively elegant way to do the equivalent in haskell
13:04:06 <yaxu> CRathman: as a beginner I much prefer Programming in Haskell
13:04:30 <dons> Deewiant: fold or map
13:04:38 <dons> > map toUpper "haskell"
13:04:44 <Deewiant> yeah
13:04:46 <dons> :t foldl
13:04:47 <Deewiant> but it's not that simple
13:04:48 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
13:04:49 <lambdabot>  "HASKELL"
13:04:55 <desegnis> Deewiant: You have a function parse :: String -> [Record]; and a function work :: [Record] -> IO () (or something)
13:05:34 <yaxu> CRathman: I found the graphics/music context in SoE got in the way of teaching the language, and I am someone who is solely using haskell for making music
13:05:41 <Deewiant> say I've got "afoobarbaz bfoobarbaz afoobarbaz", I want to do a different thing to the "foobarbaz" bit depending on whether it's "a" or "b"
13:05:56 <yaxu> YMMV
13:06:04 <Deewiant> but the thing is, I can't split it into as and bs beforehand
13:06:11 <SamB> Deewiant: perhaps you'd have data REcord = A Foo | B Bar
13:06:18 <Deewiant> i.e. I don't know reliably where an a or b begins
13:06:31 <SamB> er. s/REcord/Record/
13:06:37 <desegnis> Deewiant: What is your rationale for breaking up the string then?
13:07:07 <desegnis> Deewiant: Whitespace? Parentheses? Identifiers? A funny mix?
13:07:09 <Deewiant> in an imperative languages, what I'd do is read up to an a, then do stuff until done where done is different depending on whether it's a or b
13:07:16 <Deewiant> s/languages/language/
13:07:17 <CRathman> yaxu: I will look into it.  Was going strictly by sticker price (not always the best indicator).  I read Craft a couple of years back but go lost somewhere near the end.
13:07:33 <Deewiant> and then continue reading from after the a
13:07:35 <desegnis> Deewiant: Or just the appearances of a and b in the string?
13:08:15 <SamB> Deewiant: does that sound fun?
13:08:30 <Deewiant> in the above "afoo bbar abaz" you can consider it as the appearances of a and b
13:08:35 <Deewiant> in actuality it's a bit more complicated
13:09:05 <yaxu> CRathman: you can browse them on amazon i think
13:09:16 <Deewiant> i.e. you could have "afoo bbar abaz" where bbar is part of the first A record, this depends on "foo"
13:09:29 <Deewiant> I'm trying to simplify the case here so we don't get bogged up in the details :-P
13:09:41 <Deewiant> SamB: it sounds like the easiest way to do it, currently :-)
13:10:23 <Deewiant> it's more like parsing a DSL really
13:10:36 <SamB> Deewiant: oh, try Parsec then
13:10:50 <Deewiant> yeah, but I'd like to try and do it manually :-)
13:11:03 <Deewiant> if I wanted to just get it done quickly, I wouldn't be using Haskell ;-)
13:11:14 <SamB> that's rather odd
13:11:29 <Deewiant> simply due to the fact that I'm not very proficient in Haskell
13:11:35 <SamB> ah, right ;-)
13:11:51 <desegnis> Deewiant: parse [] = []; parse (x:xs) = (case x of 'a' -> A foo; 'b' -> B foo) : parse rest; where (foo,rest) = break (`elem` "ab") xs
13:12:16 <desegnis> Deewiant: Well, that's the general idea. No production code there.
13:12:44 <SamB> I expect that he actually wanted to parse what came after an a or a b ;-)
13:12:52 <SamB> not just skip to the next one
13:12:58 <Deewiant> yup, exactly
13:13:03 <Deewiant> I was wondering why it looked so simple ;-)
13:13:05 <desegnis> Deewiant: But don't you /really/ want to use parsec? :)
13:13:12 <Deewiant> :-D
13:13:29 <SamB> look, you can use parsec today and write your own parsing library tomorrow ;-)
13:13:38 <desegnis> Oh well then, s/A foo/parseA foo/ s/B foo/parseB foo/
13:13:42 <Deewiant> okay, just give me the general idea of how I would do it if I didn't have Parsec, and I'll go on to simplify the DSL so I don't need this level of complexity ;-)
13:13:59 <Deewiant> really I can just add some arbitrary sentinel chars to make this much easier
13:14:39 <Deewiant> but if I had to do it the way it was, without Parsec, would it involve State monads or something or is there a 'neater' way of doing it
13:15:53 <desegnis> When parsing, you don't need state in the simple case.
13:16:07 <allbery_b> if you have a Read instance you can use reads
13:16:07 <desegnis> (not sure how to define the difficult case)
13:16:23 <Deewiant> But in an arbitrarily general case, you do?
13:16:37 <Deewiant> Well, of course you do, in some sense.
13:16:45 <desegnis> Hmm, in an arbitrary general case, you need anything.
13:16:47 <dfranke> dons: alright, looks like I have to concede defeat on PipeArrow until somebody figures out ticket #1936.  Avoiding ByteString IO just makes it hang in a different place, because whatever bug ByteString is triggering, I seem to be triggering elsewhere.
13:16:58 <dons> mm.
13:17:21 <dons> well, it works for 6.6, right?
13:17:43 <dfranke> right
13:17:50 <Deewiant> desegnis, SamB: alright, I guess I'm happy, thanks. :-)
13:19:14 <dcoutts_> dons: I'm pretty sure it's not our fault in the bytestring code for lazy hGetContentsN
13:19:58 <dfranke> but if I'm going to spend the time involved in setting up a parallel installation and then backporting my code, I really need to spend that time on the project that's putting food in my mouth, not this one.
13:20:52 <dons> fair enough, dfranke
13:23:31 <roconnor> @go 1 CAD in USD
13:23:32 <lambdabot> 1 Canadian dollar = 1.003009 U.S. dollars
13:23:39 <dons> woot
13:23:44 <dons> ?go 1 AUD in USD
13:23:44 <lambdabot> 1 Australian dollar = 0.8861 U.S. dollars
13:23:46 <dons> boo
13:23:55 <dons> ?go 1 CAD in AUD
13:23:56 <lambdabot> 1 Canadian dollar = 1.13193658 Australian dollars
13:23:57 <blarz> ?go 1 EUR in USD
13:23:57 <lambdabot> 1 Euro = 1.4738 U.S. dollars
13:24:17 <desegnis> dfranke, dons: Is that issue related to the EOF thing about which I was wondering some time ago?
13:24:42 <desegnis> I mean ticket #1936
13:38:21 <shapr> Excitement?
13:38:23 <shapr> @users
13:38:24 <lambdabot> Maximum users seen in #haskell: 420, currently: 408 (97.1%), active: 11 (2.7%)
13:38:45 <TomMD> We are 11 shy?  Lets release GHC 8.6 - that will get people in here.
13:39:26 <dfranke> release the 6.8 sources and plead dyslexia.
13:39:40 * desegnis goes to sleep
13:40:42 <musiKk> when is one considered 'active'?
13:41:30 <shapr> I think if you've spoken in the last .. hour?
13:41:35 <TomMD> s/11/12
13:41:35 <shapr> Or was it twenty minutes? I forget...
13:42:13 <musiKk> sounds readonable
13:42:21 <musiKk> *reasonable
13:42:36 <Stinger_> readonlyable? :)
13:42:41 <shapr> musiKk: You could look in the lambdabot source and find out :-)
13:43:06 <musiKk> i'm afraid my knowledge of haskell isn't that good already
13:43:48 <shapr> musiKk: This is a great opportunity to improve!
13:44:17 <musiKk> i think i'll finish yaht first
13:44:28 <musiKk> right now i try to fold a tree :-)
13:44:43 <shapr> yay folding!
13:44:44 <Botje> oh, I know that one. turn it into paper first!
13:45:24 <Stinger_> hmm hoogle is giving me 404s :(
13:45:55 <shapr> Origami algorithms!
13:45:56 <njbartlett> @seen Heffalump
13:45:56 <lambdabot> Heffalump is in #haskell-blah, #haskell and #darcs. I don't know when Heffalump last spoke.
13:47:23 <alexj> anything obviously wrong with this? class ProxyType (m t r) where proxyType::m t r -> Proxy t -> m t r
13:47:27 <Stinger_> is there a control seq to clear ghci's prompt if you hit up/down and get history in there?
13:47:48 <alexj> I am getting type found where type  variable expected.
13:47:53 <Botje> trl-u helps
13:48:02 <allbery_b> hit down until it goes away, or ctrl-u
13:48:25 <Stinger_> bah doesnt work, probably cause I'm using windows
13:48:44 <sjanssen> alexj: parameters must be type variables, (m t r) isn't a type variable
13:48:58 <sjanssen> alexj: you probably mean an MPTC: class ProxyType m t r ...
13:49:27 <alexj> isn't monad defined using (m a)?
13:49:36 <alexj> monad doesn't need MPTC, right?
13:49:46 <sjanssen> alexj: no, it's class Monad m where ...
13:49:58 <sjanssen> that's an option for ProxyType too
13:50:03 <alexj> ah ok will do it that way.
13:52:44 <alexj> sjanssen: now I am getting kind errors on the instances: instance ProxyType (Update t r) where proxyType f proxy = setUpdateType proxy >> f
13:53:05 <sjanssen> alexj: instance ProxyType Update?
13:53:18 <Heffalump> njbartlett: ping
13:54:10 <alexj> sjanssen:    Type synonym `Update' should have 1 argument, but has been given 0
13:54:10 <alexj> when I give it 1 argument, i get a kind error telling me I need two.
13:54:47 <alexj>  Expected kind `* -> * -> *', but `Update t' has kind `* -> *'
13:54:59 <sjanssen> what is the defn. of Update?
13:56:13 <alexj> type Update state = Ev (Control.Monad.State.Lazy.StateT state GHC.Conc.STM)
13:56:26 <alexj> Ev actually takes two type parameters
13:56:57 <alexj> newtype Ev m t = HAppS.State.Types.Ev {HAppS.State.Types.unEv :: HAppS.State.Types.Env -> m t}
13:57:15 <sjanssen> you have two options: make Update a newtype, or change your class definition
13:57:16 <alexj> do I need to modify Updtae to take to parameters explicitly rather than by currying?
13:57:48 <alexj> ok so the class def should now be MPTC?
13:58:06 <sjanssen> nah, GHC can cope with that -- the problem is the 'state' parameter stuck deep inside the type
13:59:09 <sjanssen> something like class ProxyType m t where proxyType :: m a -> Proxy t -> m a should work
13:59:10 <alexj> ?
13:59:29 <alexj> weird.  ok
13:59:31 <sjanssen> (GHC can cope with currying of type synonyms)
14:00:18 <sjanssen> m is always a Monad?
14:00:47 <alexj> there are only two instances: Update and Query
14:01:06 <alexj> and this is just to simpify things for the user so they don't have to remember yet another monad specific funciton.
14:01:20 <alexj> e.g. ask vs gets
14:01:53 <alexj> I could just force the user to do updateProxyType vs queryProxyType
14:02:08 <alexj> butI figured it would be nicer just to have proxyType work for both.
14:02:10 <alexj> both monads.
14:04:10 <sjanssen> alexj: is there any reason that Update/Query shouldn't be newtypes?
14:04:18 <alexj> your solution worked!
14:04:33 <alexj> class ProxyType m t where proxyType :: m a -> Proxy t -> m a
14:04:34 <alexj> instance ProxyType (Update t) t where proxyType f proxy = setUpdateType proxy >> f
14:04:57 <alexj> I suppose they could be but your idea worked so it is not necessary.
14:05:04 <sjanssen> sure
14:05:10 <loupgaroublond> hi
14:05:35 <loupgaroublond> i'm very new, so please bear with me
14:06:04 <alexj> thanks
14:06:13 <Cale> loupgaroublond: We like beginners here :)
14:06:28 <Cale> loupgaroublond: Make sure to ask lots of questions :)
14:06:43 <loupgaroublond> i have an expression that is a type IO [[a]], but what i really want is the value  that's [[a]],  I'm doing this mainly because i want to debug the program, and i'm trying to throw a few random putStr's all over the place...
14:06:49 <alexj> sjannsen: nope your idea didn't work. because I am doing the types in the wrong ordre.
14:06:58 <loupgaroublond> ... so either, how do i pull everything out of this Monad, or better yet, how can i debug programs?
14:07:18 <Zao> loupgaroublond: There's a Trace module.
14:07:25 <Zao> Or if it's a function in Debug or something.
14:07:31 <joelr1> good evening
14:07:38 <alexj> sjanssen: making Update and Query newtypes involves actual surgery.
14:07:48 <joelr1> bringert: do i need to install gf3 to compile the bot?
14:08:13 <loupgaroublond> Zao, how does that work? i basically want to see what the values of all the variables in the scope of a function are when it executes
14:08:21 <Zao> :t lo	http://haskell.org/ghc/docs/latest/html/libraries/base-3.0.0.0/Debug-Trace.html#
14:08:23 <lambdabot> lexical error at character '\NAK'
14:08:23 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base-3.0.0.0/Debug-Trace.html#
14:08:32 <Zao> Bah, lag.
14:08:34 <Cale> loupgaroublond: Well, yeah, there is Debug.Trace.trace which will print a given string when evaluated.
14:08:44 <Cale> :t Debug.Trace.trace
14:08:44 <lambdabot> forall a. String -> a -> a
14:08:54 <Cale> So you can write something like
14:08:56 <Zao> Heh, looks like lambdabot dislikes empty anchors.
14:09:05 <Cale> tq x = trace (show x) x
14:09:07 <alexj> for now I'm going to live with proxyUpdate and proxyQuery
14:09:15 <Cale> and then in your function:
14:09:19 <hpaste>  Mitar pasted "How many times is the tree traversed in this program?" at http://hpaste.org/4249
14:09:36 <Cale> f x = tq $ ...
14:09:40 <loupgaroublond> Cale, looks good to me :)
14:09:43 <Cale> To see what the result is
14:09:51 <Cale> Or just
14:09:56 <sjanssen> alexj: you could add another parameter to the class, but I agree that is getting a bit out of hand
14:10:03 <Cale> f x = trace (show x) $ ...
14:10:05 <gwern> so, I've been reading some research papers. Is anyone here familiar with the Esther shell written in Clean? I'm having a hard time finding source for it or even understanding what the heck its Dynamic stuff is all about
14:10:11 <Cale> to see what it was called with
14:10:24 <Cale> loupgaroublond: There's also a proper debugger in GHC 6.8.1
14:10:35 <Cale> loupgaroublond: but it's rather new, and apparently has some bugs
14:10:47 <loupgaroublond> Cale, sounds cool, right now it's a project for class (due tomorrow, actually), but i'll have to find out more about debugging later
14:11:17 <Cale> loupgaroublond: The standard approach is just to break things down to the point where you can tell that the different parts are correct
14:11:50 <Cale> Referential transparency means that you usually don't have to worry too much about constructing a particular context to debug the program in.
14:12:10 <Cale> If a function returns a particular result for particular arguments, then it always will.
14:12:22 <loupgaroublond> Cale, i'm still not thinking like that yet, i see
14:12:24 <Mitar> is there a way to get the number of traverses of the tree in a program?
14:15:50 <Cale> Mitar: of which tree?
14:16:09 <Mitar> abstract tree of a program ... i pasted the source
14:16:10 <Mitar> abstract tree of a program ... i pasted the source
14:16:56 <sethk> would that not vary with the data in the tree?
14:17:09 <sethk> Maybe I don't really understand the question
14:18:34 <Mitar> hmm
14:19:00 <Mitar> no ... i parse a program and i build an abstract tree, after that i do semantic analysis of the program
14:19:16 <Mitar> i would like to know how many times it traverses the tree to get to this step
14:19:16 <Cale> You're referring to checkType?
14:20:53 <Cale> That looks to me like it's doing a single traversal of the tree, but perhaps I'm not reading it carefully enough.
14:21:14 <Mitar> but is not this traversal at the same time it is beeing built?
14:21:18 <Mitar> could i profile this?
14:22:44 <Cale> uh, hang on...
14:25:08 <Cale> checkType for SynScope does mapM_ getType syns. I suppose if one of the syns there is a Left, then that will cause the error to be propagated...
14:25:31 <Mitar> yes ... from my tests it is like this
14:25:55 <Mitar> (and this is the correct behavior)
14:26:22 <Cale> But where does the recursion come in?
14:26:26 <Mitar> but this does not add do the number of times it traverses the tree
14:26:33 <Mitar> which recursion?
14:26:53 <Cale> Don't you have to collect type constraints inside the SynScope?
14:27:40 <Mitar> i do not undestand what you mean by "collect ype constraints"?
14:27:53 <Mitar> SynVar define a new var with a type
14:27:54 <Cale> Well, for example, in your example program
14:28:05 <Cale> You have var char a inside the scope there
14:28:11 <Mitar> yes
14:28:12 <alexj> anyone know why TH was chosen over real macros?
14:28:35 <Cale> Mitar: how does the typechecker reach that point?
14:29:06 <Mitar> it is called in "checkType (SynVar name ty _) env"
14:29:19 <Mitar> there i check if the var is already defined in this scope -> error
14:29:32 <Mitar> if it is not i add it to the current scope
14:29:35 <Cale> oh!
14:29:43 <Cale> You have calls to checkType in your parser
14:29:49 <Cale> That's very strange :)
14:30:04 <Mitar> no, i have devised them into antother step
14:30:10 <Mitar> because Haskell is lazy :-)
14:30:31 <Mitar> until i am not interested in types of the tree nodes i do not have any types known :-)))
14:31:09 <Cale> Yeah, but still, you have a call to checkType in parseNode
14:31:27 <Mitar> true
14:31:30 <Mitar> and this is bad?
14:31:31 <Saizan> alexj: "real macros"?
14:31:36 <Cale> It's just strange.
14:31:39 <Mitar> why?
14:31:53 <Mitar> i found it more appropriate for the haskell
14:31:54 <Cale> Normally the parser just works on building a tree, and you just operate on that tree afterward.
14:32:12 <alexj> saizan: macros that look like functions but operate at compile time.
14:32:20 <Heffalump> that's what TH is
14:32:23 <Mitar> i could write a tree traversing function which would go over the tree and rewrite it to the tree with semantic data ...
14:32:39 <alexj> you don't need special syntax to call a c macro.  it looks like c.
14:32:47 <alexj> you only need special syntax to declare it.
14:32:57 <Mitar> but this way i (if i see correctly) build the tree only once
14:33:00 <Heffalump> that's because it uses text substitution, so there's nothing complicated going on
14:33:02 <Mitar> and I never traverse it
14:33:15 <Mitar> so it should be better then rewriting the whole tree
14:33:22 <Cale> Is it necessary that the tree become annotated with the types?
14:33:29 <Heffalump> if you want to work with syntax trees, you need some representation of them.
14:33:35 <Mitar> (but of source the compiler is smart enough so in fact there is no real difference)
14:33:50 <Heffalump> C macros also don't look at all like functions when you use them in non-expression context.
14:33:54 <Mitar> this is only an example
14:33:57 <ddarius> This is something that I've wondered about.  On the one hand making splicing implicit (and thus needing "macros" rather than just running functions at compile-time) has some benefits, but also some drawbacks some unique to Haskell, others just exacerbated by it.
14:34:29 <Mitar> smaller code
14:34:46 <alexj> Heffalump: fair point.  but sometimes string substitution is actually what I want.
14:34:48 <Mitar> in my real project where i will use the same techinque the next step is to go to intermediate code
14:35:01 <ddarius> alexj: I like camlp4's approach.
14:35:01 <Mitar> and then to compile it to assembler
14:35:14 <Heffalump> alexj: then use CPP
14:35:22 <Heffalump> TH doesn't take that away
14:35:26 <Mitar> so i do need types for almost all nodes as i have to know how to translate it further
14:35:46 <Mitar> i just thought it would be nice if I skip one tree traversal
14:35:47 <Heffalump> it would seem like overkill to add *another* macro system just to get more Haskell-y syntax, if that's what you're suggesting
14:36:16 <Cale> Mitar: okay, then with respect to typechecking, once the type of a node is known, it *certainly* won't be recomputed, in the way that you've written this
14:36:43 <Mitar> :-)
14:36:45 <alexj> Heffalump: HAppS-State uses TH to generate data types for functions that operate on state from getSession key you get GetSession key.
14:37:03 <Mitar> Cale, so you think this approach is good?
14:37:16 <Mitar> or it is unnecessary?
14:37:18 <alexj> though as I think about it, you are right that I can't really do better.
14:37:31 <alexj> because I can't at runtime convert back from the textual representation to strings.
14:37:34 <alexj> ok I'm sold.
14:37:40 <Cale> Mitar: Well, I don't have enough experience to say how it'll all work out, but it looks all right for now.
14:37:41 <alexj> thanks for the head check.
14:37:42 <ddarius> alexj: There are some issues about having "transparent" macros in Haskell.
14:37:53 <andrei> Hi; can c2hs create bindings for a function that has as one of its arguments a void*?
14:38:11 <Cale> andrei: I'm fairly sure that it can.
14:38:25 <andrei> Cale, I can't seem to get it to work
14:38:40 <andrei> Cale, It doesn't want arguments of Ptr (), or any other Ptr
14:39:03 <andrei> Cale, Nor does it work when I typedef my void* so that I can create a haskell type with {#type ..#} for it
14:39:51 <Cale> Which kind of hook are you using?
14:40:33 <andrei> Cale, {# fun #}
14:41:07 <sphynx> hi! Is there some way to get call trace in GHC? I'd like to instrumentautomatically  somehow all the functions, so they printed something info whrn it is called and when it is exited
14:41:24 <sphynx> something like -finstrument-functions in GCC
14:42:21 <sphynx> so it makes possible to get call trace of functions when program is running
14:42:35 <Botje> sphynx: there's a Debug.Trace
14:42:38 <monochrom> The profiler has some extra capability like that. I forgot how to invoke it.
14:43:13 <monochrom> Look under the profiling sections. There is a heading for that.
14:43:16 <sphynx> Botje: I need to use Debug.Trace inside of functions code?
14:43:29 <sphynx> monochrom: ok, thanks, I will take a look now
14:43:33 <Botje> that's one way. Or go with monochrom's way :)
14:43:35 <bringert> joelr1: ah, yes, gfc needs to be in your path
14:43:44 <bringert> joelr1: I'll add that
14:43:50 <Cale> andrei: {# fun my_function as ^ { id `Ptr ()' id } -> `()' #} -- perhaps something like that?
14:44:00 <joelr1> bringert: i don't even know what that is. does it even get built?
14:44:01 <xpika> @src replicateM
14:44:02 <lambdabot> replicateM n x = sequence (replicate n x)
14:44:03 <sphynx> Botje: yeah, I'd like not to modify functions themselfes
14:44:12 <Cale> andrei: Of course, using c2hs and not plain FFI in that case is a little silly :)
14:44:22 <monochrom> Debug.Trace is manual instrumentation, if you don't mind manual.
14:44:25 <andrei> Cale, It's actually part of something quite a bit larger :)
14:44:28 <joelr1> bringert: i build gf previously and installed it. it didn't seem to build gfc
14:44:40 <andrei> Cale, Doing it by hand would take a while..
14:44:44 <andrei> Cale, I'll give that a try :)
14:44:47 <Cale> andrei: ah, okay
14:45:15 <bringert> joelr1: it gets built when you do make gf3
14:45:44 <joelr1> bringert: not in my case, apparently. the make rule for gfc looks weird
14:45:47 <bringert> joelr1: you will need to pull down the latest GF darcs, and re-run configure
14:46:07 <bringert> joelr1: I had forgotten to push tha patch that builds a better gfc script
14:46:09 <joelr1> bringert: i just did darcs pull -a. let me reconfigure
14:46:33 <andrei> Cale, Thanks! That worked, why did it work? :P
14:46:41 <bringert> joelr1: oh, sorry, you need make gfc, not make gf3
14:46:47 <andrei> Cale, What do the two calls to id do?
14:47:02 <Cale> andrei: I set the input and output marshallers to the identity function so that nothing would happen before and after
14:47:03 <joelr1> bringert: i'm lost :D let me try reconfigure and build gfc
14:47:19 <andrei> Cale, Oh, I see; thank you!
14:47:30 <Cale> andrei: Normally, you'd put functions for reading and writing the pointer's value there
14:48:14 <andrei> Cale, Well.. I have to pass it around as a pointer
14:48:40 <andrei> Cale, It gets worse as the thing I'm calling is a C interface on top of a C++ project
14:48:43 <Cale> andrei: It's common to make a more informative newtype for that sort of thing
14:48:57 <Cale> newtype MyObject = MyObject (Ptr MyObject)
14:48:58 <andrei> Cale, Yup; I've got one
14:49:04 <sphynx> monochrom: do yo mean this: The HPC instrumentation is enabled using the -fhpc flag.?
14:49:12 <andrei> Cale, Well.. I used {# type #} to get it
14:49:15 <Cale> So then you can just do:
14:49:28 <Cale> {# fun my_function as ^ { id `MyObject' id } -> `()' #}
14:49:34 <Cale> and it should do the right thing
14:49:52 <andrei> Cale, That's what I was trying but without the id marshallers it wouldn't work
14:49:53 <Cale> (you don't need to expose the fact that it's a Ptr to your users)
14:50:52 <andrei> Cale, It's why I was asking; The whole newtype using the type hook seem to work in most cases, aside from this one
14:52:29 <andrei> Cale, Is there a reason it has to be told to use the id marshalllers?
14:52:35 <andrei> Cale, Even if my type is Ptr ()?
14:54:31 <Cale> What error does c2hs produce when the marshallers are unspecified?
14:54:44 <Cale> I think it just doesn't have a default marshaller for Ptr ()
14:55:28 <andrei> That it can't Ptr () can't be marshallled to Ptr ()
14:55:36 <Cale> ah, yes
14:56:01 <Cale> It's silly, but it can't figure that one out. It would be nice if someone added id as default in that case.
14:56:11 <dons> ?users
14:56:11 <lambdabot> Maximum users seen in #haskell: 420, currently: 413 (98.3%), active: 17 (4.1%)
14:56:38 <dmhouse> 420? The channel continues to get more popular.
14:56:39 <andrei> Cale, I did the newtype thing but it complains that MyObj and Ptr () aren't the same type
14:56:45 <andrei> ghc does, not c2hs
14:56:50 <Cale> oh
14:57:01 <RemiTurk> morning everyone
14:57:36 <dons> heya RemiTurk
14:58:28 <andrei> Cale, Any way to make that work?
14:59:02 <Cale> hmm... you're creating the type with {#pointer ... #}?
14:59:43 <joelr1> dons: hi don! did you guys add distribution to haskell yet?
15:00:54 <Cale> For example in the library that I'm working on, there's
15:01:06 <Cale> {#fun imlib_context_set_color_modifier as contextSetColorModifier {id `ImlibColorModifier'} -> `()'#}
15:01:17 <Cale> {#pointer Imlib_Color_Modifier as ImlibColorModifier newtype#}
15:01:26 <Cale> and that works okay
15:02:42 <Cale> andrei: You might want to hpaste the relevant bits of the .chs and the generated .hs file
15:02:51 <andrei> Caelum, Thanks :)
15:02:55 <andrei> erm
15:03:02 <andrei> Cale, Thanks :) it all works
15:03:06 <Cale> cool
15:03:12 <andrei> Cale, I'll have to look at c2hs and see why that's such a pain
15:03:39 <Cale> It's just missing default marshallers for void pointer types
15:04:13 <Cale> I think an argument could be made for using id as the default inmarshaller at least, in those cases.
15:04:43 <yaxu> @hoogle finitemap
15:04:47 <lambdabot> Data.FiniteMap :: module
15:04:47 <lambdabot> Data.Graph.Inductive.Internal.FiniteMap :: module
15:04:47 <lambdabot> Data.FiniteMap.FiniteMap :: data FiniteMap key elt
15:08:14 <andrei> Cale, Oh, any reason why? (at least the error message should say something about it)
15:11:00 <dons> joelr1: to the runtime?
15:11:23 <joelr1> dons: no, of course not. in the form of libraries.
15:11:38 <dons> oh, mpi style? there's a few older libs for this.
15:11:52 <joelr1> dons: erlang-style?
15:12:02 <joelr1> dons s/?/!/
15:12:02 <dons> i worked on a project last year where we just ran nodes across the cluster, talking over ports, over tcp
15:12:20 <dons> nothing terribly polished
15:12:24 <joelr1> dons: you are referring to mpi, right?
15:12:24 <dcoutts> dons: is there any need for quickcheck vs quickcheck' in QC2? why not just have one of them, the version that returns Bool
15:12:29 <dcoutts> dons: less clutter
15:12:49 <dons> joelr1: yeah, mpi, or roll-your-own mpi
15:12:52 <dons> dcoutts: yeah
15:12:58 <joelr1> dons: ok
15:13:05 <SamB_XP> I think I've heard something about distribution related to [ny]hc ...
15:13:32 <dons> well, bytecode makes sending functions easier, but i don't know of anyone actually attempting it
15:18:11 <dons> http://www.jobs-in-fp.org/
15:18:12 <lambdabot> Title: Jobs in Functional Programming
15:18:16 <dons> for those who hadn't seen it
15:18:45 <SamB_XP> dons: that's some pretty good timing there
15:19:25 <dons> hmm?
15:19:48 <SamB_XP> wli just mentioned performance reviews in -blah...
15:20:05 <dmhouse> Wow. I can't read the headline on that page due to the poor decision to use frames.
15:20:18 <Heffalump> register, and they'll *buy you a sandwich*
15:20:26 <Zao> Meh, wrong side of the country.
15:20:46 <SamB_XP> it's an event, huh
15:20:48 <dons> we should hold a simultaneous event at PSU
15:20:50 <dons> :)
15:20:59 <dons> or down in the bay area, perhaps
15:21:06 <SamB_XP> PSU?
15:21:18 <olsner> wrong day, I'm already booked :(
15:22:09 <ddarius> PSU means something different in my head than it does in dons'.
15:22:23 --- mode: ChanServ set +o dons
15:22:24 <olsner> and the next one's bound to be abroad
15:22:25 <SamB_XP> in my head PSU means Penn State University
15:22:29 --- topic: set to '["The Haskell programming language","Want an FP job? http://www.jobs-in-fp.org/","http://haskell.org ","Paste: http://hpaste.org ","Logs: http://tunes.org/~nef/logs/haskell/ "]' by dons
15:22:30 <wli> Portland State University
15:22:33 <olsner> Power Supply Unit :P
15:22:52 <SamB_XP> wli: but... portland ain't a state!
15:23:07 <dons> Heffalump: so Barclay's have come out of the closet?
15:23:08 --- mode: ChanServ set -o dons
15:23:11 <wli> It's the name.
15:23:26 <dons> SamB_XP: portland is a state of mind
15:23:29 <ddarius> Pennsylvania is a state.
15:23:33 <dons> one that is cold and damp
15:23:33 <SamB_XP> yes!
15:23:36 <SamB_XP> it is
15:23:51 <SamB_XP> aka Penn
15:24:07 <SamB_XP> at least in the names of other things
15:24:49 <SamB_XP> though if you say just Penn, it's liable to be interpreted as meaning upenn...
15:24:59 <ddarius> SamB_XP: Indeed.
15:25:32 <Cale> Heh, it's still 14 degrees in Portland. Here it's 5 below.
15:25:35 <SamB_XP> which incidentally you shouldn't bother applying for if you are white and live in greater philadelphia
15:26:16 <dons> Cale, ok, not so cold then
15:26:25 <ddarius> SamB_XP: I applied to PSU.
15:26:29 <dons> humidity is 100%
15:26:31 * locomalo is away: Ausente
15:26:48 <ddarius> They are swimming through the streets in Portland.
15:26:52 <SamB_XP> ddarius: eh? I meant don't apply to upenn
15:26:59 <ddarius> SamB_XP: I know.
15:27:29 <ddarius> Either way I'm mixed and lived (at the time) in Virginia.
15:28:00 <SamB_XP> I guess if they want you and you live that close, they could come to your house ;-)
15:28:33 <Cale> dons: I suppose it's cold compared to most places in Australia :)
15:28:43 <dons> yes, i'm still in shock.
15:28:56 <ddarius> It's like 68 F here.
15:29:13 <Cale> dons: But there ought to be proper heating anyway.
15:29:18 <dons> "To Microsoft, ?computer sciency? was a
15:29:18 <dons> bad word used to make fun of new hires with their bizarre
15:29:18 <dons> hypotheses about how Haskell is the next major programming
15:29:20 <dons> language"
15:29:36 <dons> Cale, yes, there's real support built in for cold and wetness
15:29:38 <SamB_XP> apparantly it's 64 F in my house
15:29:42 <ddarius> dons: link?
15:29:48 <dons> http://www.joelonsoftware.com/items/2007/12/03.html
15:29:49 <lambdabot> Title: Talk at Yale: Part 1 of 3 - Joel on Software
15:30:02 <ddarius> SamB_XP: If I believed the thermostat, it's 49 F in my office.
15:30:23 <SamB_XP> ddarius: you want me to look at the other thermometer?
15:30:43 * ddarius considers it...
15:30:49 <SamB_XP> it also says 64 F
15:30:53 <SamB_XP> but it has a different time
15:30:56 <Saizan> is it common practice for network protocols to have packet headers that exactly match some C struct?
15:31:06 <dons> yeah
15:31:06 <olsner> anyone know which company named "kreditor" is at the event? the one at kreditor.se (which incidentally matches the logo), only advertises legal jobs atm... but perhaps that's just that they haven't announced them yet
15:31:15 <wli> It's 13.3C (56F) here.
15:31:26 <SamB_XP> Saizan: eh?
15:32:18 <wli> (Where "here" refers to Tanasbourne, a Portland suburb near galois.com etc.)
15:32:38 <dons> yeah, nice warm day after last weeeeeek
15:32:40 <olsner> at least it's not good practice, unless you also put your C compiler in bondage in order to get a reliable byte layout
15:33:16 <Saizan> SamB_XP: well, i've seen that technique porting a client for distribuited IPC to haskell
15:33:53 <SamB_XP> well, the people in ##c would never suggest such a thing
15:34:45 <Saizan> because the byte format is not guarateed by the standard?
15:35:03 <SamB_XP> not even in practice!
15:35:32 <Stinger_> byte length isnt even generally guaranteed
15:36:15 <SamB_XP> indeed, some systems may even have larger bytes
15:39:34 <Saizan> well. it seemed handy :)
15:40:22 <olsner> you can do it if you know for sure the other end is compiled exactly the same way you are and that it is trustworthy ;-)
15:43:30 <Saizan> olsner: i was actually tempted to describe somehow the struct/format at the type level and make binary do the work. but i'm not sure if will worth it or will be comfortable to use
15:48:42 * locomalo is back (gone 00:22:12)
15:49:46 <dons> locomalo: perhaps turn off the auto-updates?
15:50:53 <locomalo> dons, sorry but I don't what is that
15:51:43 <mauke>  * locomalo is away: Ausente
15:51:44 <ricky_clarkson> no necesitamos conocer si tu estÃ¡s aquÃ­ o no.
15:52:02 <dons> thanks ricky_clarkson
15:52:17 <ricky_clarkson> You may now laugh at my Spanish.
15:52:39 <Stinger_> haw haw
15:52:44 <chessguy> jejeje
15:52:54 <mauke> @vixen do you speak el spanisho?
15:52:54 <lambdabot> yes i do
15:53:12 <ddarius> mauke: "el spanisho"?
15:53:23 <chessguy> @vixen a que hora cenas?
15:53:23 <lambdabot> why don't you guess?
15:53:25 <ricky_clarkson> locomalo: Sorry, s/tu/vos/ for you Argentinians.
15:53:36 <lament> saber
15:53:40 <olsner> translation?
15:54:03 <chessguy> i asked her what time she eats dinner
15:54:07 <locomalo> ok, I was the default setup of my irc client, I'll change it
15:54:13 <ricky_clarkson> lament: I can never remember which is saber and which is conocer.
15:54:42 <chessguy> ricky_clarkson, it's not always a matter of remembering. it depends on the context
15:55:21 <lament> ricky_clarkson: more or less, saber is information and conocer is being familiar with things and people
15:55:43 <davidL> spanish?
15:56:11 <olsner> oh, I meant translation for "no necesitamos conocer si tu estás aquí o no." ... "not necessary" something "you are here" something, right?
15:56:13 <chessguy> davidL, parles vous francais?
15:56:35 <davidL> chessguy: nope :-\
15:56:35 <chessguy> olsner, "we don't need to know if you are here or not"
15:56:49 <olsner> cool
15:57:09 <ddarius> davidL: That's a bad thing?
15:57:11 <davidL> that should be saber btw
15:57:12 <olsner> perhaps one should consider learning some spanish some day
15:57:17 <chessguy> indeed
15:57:32 <davidL> ddarius: no, I love spanish ;)
15:57:46 <chessguy> spanish is a very functional language!
15:57:56 <chessguy> (someone had to say it)
15:58:10 <olsner> I'll probably learn spanish after writing that haskell paper, or any of the other things on the TODO list :P
15:58:33 <lament> learning a language takes some time, it's best done "during" rather than "after" :)
15:58:40 <lament> (some time = years)
15:58:55 <davidL> you should learn spanish, it's easy and fun
15:59:11 <lament> much unlike haskell papers :)
15:59:16 <ddarius> davidL: Perhaps I'll have my 3 year old nephew teach me some.
15:59:37 <davidL> ddarius: it's amazing how young people can pickup on new languages so quickly
16:00:04 <lament> ddarius: you could have a language exchange, he teaches you spanish and you teach him haskell
16:00:39 <chessguy> a three-year-old learning haskell? what do you want, another sorear?
16:00:55 <ddarius> I'll buy him a copy of Real World Haskell for his next birthday.
16:00:59 <lament> another Stewie Griffin
16:03:05 <SamB_XP>  "But I don't _want_ functional programming!"
16:03:05 <SamB_XP>   -- Sarah Peyton Jones, age 11, upon hearing the rules of Go.
16:03:24 <davidL> hmm, I wonder if young children can pickup on programming languages as fast as they can human languages
16:04:13 <ddarius> davidL: Yes and no, probably more no for young values of young.
16:04:22 <olsner> ¿He oído que te gustó mudkips?
16:05:06 <lament> davidL: they would if they had to use them as often as they do human languages.
16:05:07 <fasg> i think it is required that you already know a human language before you can learn a programming language
16:06:32 <Thomas2> human languages need to be learned in a fuzzy, intuitive sense, with rules mostly followed but abused where appropriate
16:06:33 <ddarius> lament: I don't think so.
16:06:43 <Thomas2> such things are best learned young
16:07:21 <davidL> SamB_XP: the rules of Go?
16:07:21 <Thomas2> programming languages typically demand precision, grammar, and a strong appreciation of the precise semantics, rather than those that might be interpreted by an equally intelligent peer
16:07:22 <ddarius> lament: Programming requires abstract thought and precision in a way that just learning to -speak- a natural language doesn't.
16:07:35 <SamB_XP> davidL: that's how the quote goes, yes
16:07:43 <davidL> what's Go?
16:07:54 <Stinger_> a board game
16:07:56 <SamB_XP> @google go (game)
16:07:57 * ddarius needs to go rescue as much of the HaWiki QuotesPage as he can.
16:07:58 <lambdabot> http://en.wikipedia.org/wiki/Go_(board_game)
16:07:58 <lambdabot> Title: Go (board game) - Wikipedia, the free encyclopedia
16:08:09 <lament> go is a functional programming board game :)
16:08:14 <davidL> ohhh
16:08:29 <davidL> that's the game people are playing in movies!
16:08:38 <lucca> heh, Go is magnificent
16:08:39 <SamB_XP> people play a lot of games in movies
16:08:50 <davidL> well some movies about math
16:09:00 <ddarius> E.g. "A Beatiful Mind"
16:09:03 <davidL> yeah
16:09:08 <ddarius> Now with 100% less 'u'
16:09:27 <lucca> 50%
16:09:53 <lament> people tend to play go rather badly in movies
16:10:03 <lament> the go wiki (sensei's library) makes fun of all of them
16:10:06 <lucca> people tend to play go rather badly in general.
16:10:45 <lament> lucca: have you seen the position from Pi? http://senseis.xmp.net/?ReconstructionOfThePiGame
16:10:56 <lambdabot> Title: Sensei's Library: Reconstruction Of The Pi Game
16:11:00 <lament> there's a difference between "rather badly" and that :)
16:11:21 <njbartlett> Machines tend to play go even worse in general
16:12:03 <lucca> lament: haven't seen that yet
16:12:14 <lucca> ... wow
16:12:15 <lucca> heeee
16:12:26 <lament> :D
16:12:47 <SamB_XP> @devil war
16:12:48 <lambdabot> *** "WAR" devils "THE DEVIL'S DICTIONARY ((C)1911 Released April 15 1993)"
16:12:48 <lambdabot> WAR, n.  A by-product of the arts of peace.  The most menacing
16:12:48 <lambdabot> political condition is a period of international amity.  The student
16:12:48 <lambdabot> of history who has not been taught to expect the unexpected may justly
16:12:48 <lambdabot> boast himself inaccessible to the light.  "In time of peace prepare
16:12:50 <lambdabot> [18 @more lines]
16:15:33 <lament> (pi is a great movie, by the way. It never tries to be even remotely factually accurate, and shouldn't be interpreted as such)
16:16:23 <ddarius> I didn't like pi at all.
16:16:40 <lament> i think it's very pretty
16:16:58 <lament> some Massive Attack in the soundtrack, too! <3
16:18:17 <davidL> "1. Mathematics is the language of nature. 2. Everything around us can be represented and understood through numbers. 3. If you graph these numbers, patterns emerge. Therefore: There are patterns everywhere in nature."
16:18:35 <davidL> pretty awesome
16:19:22 <Mitar> how could i make a new class which could i use for automatically deriving?
16:19:32 <ddarius> You can't.
16:20:08 <Mitar> why not?
16:20:15 <lament> because 'deriving' is magical
16:20:22 <Stinger_> what are the automatically deriving classes?
16:21:07 <Mitar> which would enable me to write: data Foo = Bar deriving (MyClass)
16:21:42 <conal> Is there research about making "deriving" extensible?
16:22:00 <ddarius> conal: Kind of, yes.
16:22:16 <lament> wouldn't that require immense ugliness?
16:22:28 <conal> ddarius: what do you know about?
16:22:52 <conal> Drift & Derive, maybe?
16:24:52 <ddarius> http://www.haskell.org/ghc/docs/latest/html/users_guide/generic-classes.html
16:25:03 <lambdabot> Title: 8.15. Generic classes
16:25:13 <fasg> does template haskell have anything to do with this?
16:26:30 <ddarius> fasg: Yes and no.
16:26:35 * ddarius is always so helpful.
16:26:58 <fasg> i appreciate it
16:27:23 <Stinger_> how is that with the same level of sarcasm :)
16:27:28 <Stinger_> s/h/n/
16:27:44 <ddarius> You could use TH to do similar things, but it isn't explicitly aimed at that per se  (or maybe it is)
16:28:34 <tmoertel> Is there another site hosting the talk videos from the Haskell Workshop 2007?  The site listed on the HaskellWiki doesn't resolve.
16:32:23 <davidL> What is the best way to parse a list of bytes :: [Word8]? I don't know if Parsec is right for this.
16:34:13 <dfranke> davidL: not the best, but the easiest way, would just be to cast them to Char.
16:34:18 <dons> Data.ByteString
16:34:21 <Mitar> ddarius: if you are interested, the final version: http://hpaste.org/4249
16:34:25 <dons> and Data.Binary :)
16:34:47 <dfranke> The Get monad doesn't give you backtracking, though.
16:34:57 <davidL> dfranke: you mean, map chr foo?
16:35:10 <dfranke> davidL: right
16:36:20 <davidL> dfranke: but then it becomes a bunch of \NUL\FOO\BAR stuff
16:36:42 <dfranke> davidL: okay, so it's truly a binary stream then?
16:37:01 <davidL> dfranke: it's a network packet, so the answer is yes I suppose
16:37:19 <dfranke> davidL: then use Data.Binary if it's sufficient and Parsec if it isn't. (GenParser Word8 s a)
16:38:46 <davidL> dfranke: what I've been doing now is using things like splitAt and/or really long pattern matching like parseIP [a,b,c,d,e,f,g,h]
16:39:34 <dfranke> davidL: sounds like Data.Binary will do the job.
16:39:46 <clanehin> With ghc 6.6, I have a program that runs dramatically faster with optimizations turned off.  9.2 seconds vs 4 minutes 16 seconds.  I think the optimized version is recomputing an intermediate data structure when it doesn't need to.
16:40:27 <dons> clanehin: please make a bug report
16:40:29 <davidL> thanks dfranke
16:40:33 <fasg> why is parsec specific a list of Char, and not any polymorphic?
16:40:35 <dons> sounds like an optimiser bug that needs fixing
16:40:42 <fasg> is it for performance?
16:40:43 <dons> clanehin: oh, check with ghc 6.8
16:40:44 <dfranke> fasg: it isn't.
16:40:59 <dfranke> fasg: it just has one module of convenience functions specific to Char
16:41:29 <fasg> oh
16:41:47 <clanehin> dons: ok
16:54:03 <davidL> are there any good examples of programs that use Data.Binary extensively?
16:55:30 <chessguy> davidL, maybe one of the programs from the last ICFP?
16:57:17 <chessguy> oh, Binary, never mind
16:57:59 <davidL> I see two of them use Data.ByteString.Lazy
17:00:03 <dons> davidL: lambdabot does too
17:01:22 <Olathe> Is there a monad where (>>=) = flip id and return = id ?
17:01:54 <liyang> Flip id? That's just ($) isn't it?
17:02:03 <liyang> @i Identity
17:02:03 <lambdabot> Maybe you meant: id ignore index instances instances-importing irc-connect . ? @ v
17:02:10 <Olathe> @unpl flip id
17:02:10 <lambdabot> (\ b c -> c b)
17:02:11 <liyang> @info Identity
17:02:11 <lambdabot> Identity
17:02:16 <olsner> @src Identity (>>=)
17:02:17 <lambdabot> m >>= k  = k (runIdentity m)
17:02:41 <Olathe> @src runIdentity
17:02:42 <lambdabot> Source not found. I've seen penguins that can type better than that.
17:02:42 <ddarius> ($) = id
17:02:47 <Olathe> @src Identity runIdentity
17:02:47 <lambdabot> Source not found. Where did you learn to type?
17:03:04 <EvilTerran> @src Identity
17:03:04 <lambdabot> newtype Identity a = Identity { runIdentity :: a }
17:03:07 <EvilTerran> @src Identity return
17:03:07 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
17:03:23 <ddarius> Olathe: There's a paper about CPS and stuff that I think has it, but I can't think of the name offhand.
17:03:30 <EvilTerran> return = Identity
17:03:53 <ddarius> Ah, I remember, but let me verify
17:04:27 <Olathe> Alright, thanks.
17:05:49 <ddarius> Nah, it has return = flip ($) -- == flip id (which is typical for CPS) but (>>=) = id
17:14:43 <dmwit> Can you pattern match on a partially applied constructor?
17:15:05 <ddarius> No.
17:15:14 <dmwit> If not, how come you need parentheses like this: "f (Leaf x) = ..."?  Just to simplify parsing?
17:15:28 <dmwit> I guess it simplifies reading, too.
17:15:49 <Spark> disambiguation
17:16:10 <dmwit> Can you give an example of a possible ambiguity?
17:16:13 <Spark> i thought you could do f Leaf = ...
17:16:38 <dmwit> > let f (:) = 3 in f (:)
17:16:39 <lambdabot>      Constructor `:' should have 2 arguments, but has been given 0
17:16:39 <lambdabot>     In the...
17:16:40 <olsner> dmwit: f Leaf x is a function of two arguments, f (Leaf x) is a function of one
17:16:53 <dmwit> olsner: I know what the syntax is right now.
17:17:08 <dmwit> What I'm wondering is: is there anything technical that prevents the syntax from being as I propose?
17:17:16 <Spark> does it work with case?
17:17:27 <dmwit> The proposal is this: if some argument starts with a capital letter, then look for as many arguments as that constructor needs.
17:17:57 <dmwit> That entire group acts as the first argument to the function.
17:18:22 <mkehrt> hmm...dumb question
17:18:37 <olsner> I guess it's desired to be able to parse it without knowing things about all visible constructors
17:18:44 <dmwit> yeah
17:18:50 <mkehrt> does Haskell syntactically distinguish capital lettered ids from lowercase ones?
17:18:51 <dmwit> ok
17:18:57 <dmwit> mkehrt: yes
17:18:59 <mkehrt> I know ocaml does and sml does not
17:19:00 <mkehrt> ok
17:19:31 <dmwit> mkehrt: Identifiers that start with a capital letter are types, constructors, classes, or modules.
17:19:33 <scook0> at the term/pattern level, Capitalized identifiers are data constructors
17:19:49 <dmwit> mkehrt: Identifiers that start with a lower case letter are variables.
17:19:51 <mkehrt> ok, cool
17:19:58 <dmwit> mkehrt: Identifiers that start with a : are infix constructors.
17:20:02 <ddarius> Every case-sensitive language syntactically distinguishes upper and lower case identifiers.
17:20:18 <chessguy> errr
17:20:28 <chessguy> i'm not so sure about that ddarius
17:20:29 <mkehrt> ddarius: nonono, that's not the question
17:20:37 <ddarius> mkehrt: I agree.
17:20:38 <chessguy> javascript comes to mind quickly
17:20:41 <dmwit> ddarius: Yes, that is a pedagogically correct answer, but I think it's obvious what the meaning of the question was.
17:20:43 <Spark> c is case sensitive, both bob and Bob are identifiers in c
17:20:47 <mkehrt> hmm
17:20:57 <mkehrt> no, I believe I asked the correct question
17:20:58 <scook0> but in haskell, the two aren't inter-alpha-convertible
17:20:58 <mkehrt> as
17:21:09 <Spark> the problem is not case but arity
17:21:09 <mkehrt> foo and Foo are of different syntactic classes
17:21:26 <Spark> it knows that Leaf is a constructor but doesn't know its arity
17:21:32 <mkehrt> and therefore can be said to be syntactically distinguished
17:21:38 <Spark> thus it can't parse until the end of its arguments
17:21:39 <scook0> in C, if you consistently rename "bob" to "Bob", your program will still work -- that's not the case in Haskell
17:21:42 <monochrom> arity is always 0.
17:21:43 <LoganCapaldo> Spark: it's arity is 1 of course :)
17:21:46 <dmwit> Spark: It certainly does know the arity.
17:22:00 <dmwit> Spark: It knows from the "data" declaration.
17:22:05 <Spark> that's a type
17:22:17 <Spark> you want to parse, then look at types
17:22:27 <Spark> not look at types while you're parsing
17:22:29 <dmwit> Aaah, good point.
17:23:19 <scook0> it's important to remember, too, the rules for application precedence
17:23:39 <scook0> so "foo Leaf 3" should always be parsed as "foo (Leaf) (3)", even if that doesn't make any sense
17:24:05 <jsnx> scook0: why not `foo (Leaf 3)` ?
17:24:10 <Spark> it would be a bit inconsistent if it allowed removal of parentheses in pattern matches but not generally
17:24:20 <dmwit> scook0: Since I was proposing a change to application precedence, I feel that what you say is slightly irrelevant.
17:24:30 <dmwit> scook0: Or, rather, considering, rather than proposing.
17:24:40 <scook0> dmwit: oh, in that case never mind
17:24:43 <LoganCapaldo> jsnx: because funtion application leans to the left
17:24:49 <Spark> it still stands
17:24:57 <dmwit> Spark: Right, I agree that what I was talking about was a bad idea.  I was just curious about it. =)
17:24:59 <ddarius> Bleeding heart function application.
17:24:59 <Spark> it would be ambiguous in calls but not in patterns
17:25:04 <chessguy> leans? an amusing metaphor
17:25:05 <jsnx> LoganCapaldo: wouldn't that be `(foo Leaf) 3`?
17:25:10 <LoganCapaldo> yep
17:25:15 <scook0> Spark: though there's value in having the two be consistent
17:25:17 <Spark> yeah that's what he should have said
17:25:21 <Spark> not foo (Leaf) (3)
17:25:31 <jsnx> ah, okay
17:25:33 <jsnx> thank you
17:25:48 <jsnx> i couldn't figure out what kind of precedence would result in parens like that :)
17:25:52 <scook0> yeah, my main point was just that "Leaf" wouldn't be applied to "3"
17:26:10 <dmwit> I don't think those particular parens disambiguate that point. =)
17:26:18 <dmwit> But it's moot.
17:26:29 <chessguy> so what happens if the function application falls over, from leaning too far left?
17:26:36 <Spark> why can't we pattern match on constructors anyway?
17:26:38 <dmwit> budget deficits?
17:26:42 <Spark> it's possible to pattern match on other values
17:26:49 <dmwit> Spark: You can.
17:26:54 <dmwit> f (Leaf _) = ...
17:27:07 <Spark> no that's pattern matching on the application of a constructor
17:27:10 <andrei> What's the nice way to marshal lists in c2hs, I need an array from it?
17:27:12 <Spark> f Leaf = ...
17:27:23 <dmwit> Spark: Because that's a function, not a pattern?
17:27:29 <dmwit> Spark: What would that mean?
17:27:37 <BlackMeph> chessguy: Then the government falls, anarchy spreads, and the international workers declare Revolution! >:)
17:27:39 <Spark> Leaf = Leaf
17:27:43 <Spark> you can do that, right?
17:27:45 <chessguy> woohoo!
17:27:46 <Spark> why not do patterns?
17:27:55 <Spark> f Leaf = Leaf
17:28:00 <chessguy> BlackMeph, and a good time was had by all
17:28:11 <LoganCapaldo> you can't do Leaf = Leaf ...
17:28:16 <Spark> why not?
17:28:21 <Spark> i've never actually tried it
17:28:24 <dmwit> Spark: I don't understand.  What would "(\Leaf -> id) (Leaf 3)" result in?
17:28:27 <gwern> yay I got my hackage account!
17:28:28 <scook0> actually, that should work
17:28:33 <scook0> though I can't see it doing anything
17:28:37 * gwern can has package uploads? but of course
17:28:48 <gwern> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Shu-thing-1.0.20071203 http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Monadius-0.9.20071203
17:28:50 <lambdabot> http://tinyurl.com/2lwqlf
17:29:04 <scook0> > let True = True in ()
17:29:06 <Spark> dmwit: that's a closure, not a pattern
17:29:06 <lambdabot>  ()
17:29:12 <gwern> they are not really my programs, but I'm still proud of'em
17:29:20 <Spark> you mean fun Leaf = id | _ = id
17:29:21 <Spark> or something like that
17:29:22 <gwern> how do I go about doing an announcement on haskell-cafe?
17:29:34 <dmwit> Spark: Okay, then how about "{f Leaf = id; f (Leaf 3)}", same thing?
17:29:35 <BlackMeph> chessguy: Well, until the fascist pattern matchers shove the whole thing to the right again... ;p
17:29:39 <LoganCapaldo> > let Just = Just in ()
17:29:39 <lambdabot>      Constructor `Just' should have 1 argument, but has been given 0
17:29:39 <lambdabot>     In t...
17:29:45 <Olathe> @pl (\Leaf -> id) (Leaf 3)
17:29:46 <lambdabot> id
17:29:48 <monochrom> ... Monadius ...
17:29:52 <chessguy> stupid socialist party poopers
17:29:57 <Spark> > if Just = Just then 1 else 0
17:29:57 <lambdabot>  Parse error at "=" (column 9)
17:30:04 <Spark> argh!
17:30:05 <gwern> monochrom: it's a fine name -_-
17:30:15 <LoganCapaldo> Spark: did you mean ==?
17:30:19 <Spark> > if Just == Just then 1 else 0
17:30:19 <lambdabot>   add an instance declaration for (Eq (a -> Maybe a))
17:30:19 <lambdabot>     In the predicate ex...
17:30:22 <LoganCapaldo> not that would work either
17:30:33 <chessguy> if (Just == Just) then 1 else 0
17:30:34 <Spark> that's more like it
17:30:36 <chessguy> > if (Just == Just) then 1 else 0
17:30:36 <lambdabot>   add an instance declaration for (Eq (a -> Maybe a))
17:30:36 <lambdabot>     In the predicate ex...
17:30:46 <Spark> clearly the parentheses are redundant
17:30:55 <chessguy> hmm. ok
17:30:55 <monochrom> The error message tells you what's wrong with your own idea.
17:31:00 <Spark> it's complaining about not being able to compare functions for equality
17:31:14 <monochrom> Focus on "function".
17:31:17 <Spark> you can compare functions in most languages
17:31:24 <dmwit> name one
17:31:26 <Spark> c
17:31:28 <chessguy> javascript
17:31:29 <Spark> lua
17:31:34 <dmwit> No, you're comparing pointers.
17:31:37 <dmwit> That's completely different.
17:31:37 <monochrom> You are mistaken.
17:31:40 <Spark> doesn't matter
17:31:45 <dmwit> Yes, it does.
17:31:54 <Spark> not to me
17:32:00 <dmwit> If you have two functions with exactly the same body, their pointers are not equal.
17:32:01 <monochrom> int f(void) { return 0; }
17:32:05 <lament> there's an important theorem about how you can't compare functions
17:32:05 <monochrom> int g(void) { return 0; }
17:32:08 <monochrom> f == g ?
17:32:11 <Spark> monochrom: no
17:32:21 <monochrom> Why not?
17:32:24 <dmwit> Spark: Your idea of equality is broken, in my opinion.
17:32:26 <Spark> because they're different
17:32:28 <gwern> lament: probably that pesky halting theorem again, eh? (or moreparticularly rice's theorem mebbe?)
17:32:32 <Spark> dmwit: better a weak definition than no definition at all
17:32:35 <monochrom> I only see different names.
17:32:40 <lament> gwern: something like that :)
17:32:42 <dmwit> Spark: I disagree.
17:32:47 <olsner> anyone solve the halting problem lately?
17:32:51 <Spark> no definition at all is useless, but a weak definition is still useful for some things
17:32:52 <scook0> better no definition than a broken one
17:32:55 <LoganCapaldo> not since last tuesday
17:32:58 <Spark> it's not broken
17:33:02 <lament> Turing rears his ugly head :)
17:33:13 <gwern> olsner: I solved it for a small class of programs!
17:33:17 <Spark> it's possible to define an equality without solving the halting problem
17:33:17 <chessguy> olsner, i solved it over lunch, but the proof was too large to fit in the margin of my napkin
17:33:30 <monochrom> Why don't you just admit you're asking to compare pointers, not constructors.
17:33:37 <LoganCapaldo> this is why we need bigger napkins
17:33:50 <lament> Spark: it's just a crappy definition. It's not that it's weak. It's that it's crappy.
17:33:53 <Spark> monochrom: i don't see any reason to differentiate
17:33:58 <Spark> lament: subjective
17:33:59 <markb> LoganCapaldo: or we need smaller pens for smaller writing
17:34:02 <monochrom> "Leaf == Leaf" can be true or false depending on pointer and memory and so on.
17:34:12 <Spark> monochrom: nah
17:34:17 <Spark> Leaf will always == Leaf
17:34:19 <gwern> so, uh, no one knows how you go about posting announcements to haskell-cafe?
17:34:33 <ddarius> You just mail the list.
17:34:40 <Spark> assuming the tree has no "cargo", it is more interesting if Leaf == []
17:34:40 <ddarius> Just like any other post to it.
17:34:41 <Spark> or somethign like that
17:34:55 <scook0> let a = Leaf ; b = Leaf ; in a == b
17:34:59 <gwern> ddarius: no special etiquette?
17:35:16 <Spark> and if the semantics is in keeping with other languages, Leaf != []
17:35:31 <ddarius> gwern: Look at the others if you care.  No one is going to complain about the formality of your tone.
17:35:31 <gwern> uh oh. hm. 'cabal install Shu-thing' works, but not 'cabal install Monadius'.
17:35:31 <dmwit> Spark: That doesn't even type-check.
17:35:40 <Spark> < Spark> assuming the tree has no "cargo"
17:35:48 <monochrom> what is "no cargo"?
17:36:06 <Spark> i have no idea how to make it any simpler than that
17:36:09 <ddarius> monochrom: I'm pretty sure he means, Leaf v. Leaf x
17:36:26 <ddarius> i.e. data Tree = Leaf | Branch Tree Tree or some such.
17:36:32 <Spark> yeah
17:36:38 <Spark> what else would "no cargo" mean
17:37:00 <monochrom> I don't know. It's your coined term. I never saw it elsewhere.
17:37:14 <Spark> thought it was pretty intuitive
17:37:24 <monochrom> It's intuitive to you of course.
17:37:28 <gwern> perplexing. anyone feel like telling me why 'cabal install Monadius' doesn't work? :)
17:37:28 <dmwit> Spark: Out of curiosity, are you in college yet?
17:37:38 <monochrom> Hell everything you have thought up is intuitive to you.
17:37:43 <gwern> Spark: it was intuitive to me
17:37:43 <monochrom> Completely useless tautology.
17:37:58 <ddarius> gwern: There are very diverse backgrounds here.
17:37:59 <Spark> nah i've thought up many things that were counter intuitive :)
17:38:00 <markb> monochrom: CUT for short
17:38:16 <dmwit> markb: Perfectly intuitive!
17:38:17 <Spark> and no i left college when i was 18
17:38:27 <Spark> 6 years ago
17:38:32 <dmwit> Spark: Oh, what do you do now?
17:38:35 <Spark> phd
17:38:47 <Spark> so anyway
17:38:49 <dmwit> Cool, in what area?
17:39:05 <Spark> why not define equivalence of functions in the simple way that other languages use
17:39:07 <dmwit> (I'm applying to grad schools now, want to recommend me to your school? ;-)
17:39:13 <Spark> just whether the two values originated from the same definition
17:39:33 <dmwit> If you're really stuck on it, have a look at the FFI.  Maybe you can get something good going with FunPtr.
17:39:34 <Spark> not in terms of  âˆ€x. f(x) = g(x)
17:39:58 <Stinger_> we're going unicode mad this morning
17:40:00 <chessguy> augh, my unicode support is borked :(
17:40:07 <Spark> it's not something to be stuck on
17:40:11 <Spark> a language can either do it or not do it
17:40:30 <markb> Spark: why does a language need to do it?
17:40:39 <Spark> a language doesn't need to do anything
17:40:53 <markb> but hopefully, things that a language can do, turn out to be of some use
17:41:02 <Spark> it shouldn't have things that are inconsistent or encourage bad programming
17:41:05 <markb> can you think of a time when you would want to use such a feature?
17:41:23 <Cale> Spark: what other equivalence of functions is there?
17:41:40 <Cale> Spark: equality at a specific point in the domain?
17:41:52 <dmwit> Cale: He wants function pointer equality. =/
17:41:52 <Spark> coming from the same original definition
17:41:58 <Spark> nothing to do with pointers
17:42:01 <gwern> Cale: doesn't common lisp have like 6 different notions of equality for stuff? equality seems to be a hard problem
17:42:35 <scook0> Spark: that will break referential transparency
17:42:38 <sieni> Spark: what use would there be for such a definition?
17:42:40 <lament> currying makes it worse
17:42:44 <Spark> > let x = Just in x == Just
17:42:46 <lambdabot>   add an instance declaration for (Eq (a -> Maybe a))
17:42:46 <lambdabot>     In the expression: ...
17:42:51 <Spark> scook0: how?
17:42:59 <Cale> But then you have functions which are equal but which don't test as equal, which is strange.
17:43:21 <scook0> eta f = \x -> f x
17:43:30 <Spark> Cale: you mean you may have functions that are not the same by the definition of equality but appear to be the same
17:43:35 <ddarius> Cale, you don't remember the intensional equality operator ;=)
17:43:39 <Spark> you're prejudicing a particular definition of equivalence
17:43:51 <scook0> (eta f) == (eta f) ?
17:44:00 <scook0> join (==) (eta f) ?
17:44:12 <Cale> Spark: well, there's a particular definition of 'function' which I'm using ;)
17:44:32 <jhdev> ah how depressing
17:44:33 <Spark> but i admit you do get into issues like (Î»x.x)==(Î»x.x) and even alpha renaming
17:44:41 <ricky_clarkson> eta is unpl?
17:44:47 <ddarius> ricky_clarkson: No.
17:44:49 <Spark> it depends how far you want to look into the data structure in question
17:45:25 <monochrom> Suppose I write code to define x = \a -> a; y = x. The compiler is free to inline, erase, duplicate, or specialize that function definition there. Once you turn on optimizations, information about "did x and y came from the same origin or not" is lost.
17:45:32 <Spark> arguably you can always pair up functions with numbers to give them some identity that you can compare
17:45:40 <scook0> Spark: if you *really* want to, it should be possible to use unsafe GHC trickery to compare functions (via pointers)
17:45:47 <scook0> but the results may be arbitrarily surprising
17:45:50 <Cale> If A and B are sets, then a function f: A -> B is a subset of A x B such that for each a in A, there is exactly one b in B such that (a,b) is in f.
17:46:00 <monochrom> "x == y" easily gives you random answers. Even different answers in the same run.
17:46:15 <Spark> scook0: few people want anything that badly
17:46:23 <Cale> Haskell functions are meant to mimic that definition
17:46:35 <dmwit> monochrom: Oh, neat, I can get random numbers in pure code!  YES
17:46:46 <chessguy> @slap dmwit
17:46:47 * lambdabot smacks dmwit about with a large trout
17:46:48 <P_D> At most one b in B such that (a,b) is in f
17:46:59 <Cale> P_D: exactly one!
17:47:03 <ddarius> reallyUnsafePtrEq
17:47:03 <P_D> fine
17:47:05 <dmwit> Total functions are nicer.
17:47:11 <monochrom> G-machine and STG-machine diliberately copy around function definitions all the time.
17:47:18 <lament> are these functions equal? (const [1..]) and (const [1..])
17:47:46 <dmwit> very nice
17:48:16 * dmwit googles "haskell funptr" and gets "Did you mean: haskell functor"
17:48:17 <ddarius> lament: Extensionally, yes.
17:48:18 <dmwit> <3
17:48:37 <Cale> (Of course, _|_ is actually an element of all the types in Haskell, so when we say that a Haskell function isn't defined for a given value, we really mean that it's defined and equal to _|_)
17:48:47 <monochrom> No one prejudices this "same origin" notion of equality. It's objectively completely unusable.
17:48:56 <ddarius> Cale: Except that that is a model.
17:49:13 <Cale> What isn't?
17:49:31 <Spark> monochrom: i think you can keep most optimisations without losing equality
17:49:41 <Spark> monochrom: or ending up with an unportable notion of equality
17:49:48 <Spark> monochrom: but it's more work than i initially thought
17:49:55 <Spark> and probably needs to be in the language from day 1
17:50:04 <Cale> We're not going to define Haskell as a particular pattern of electron charges in someone's computer.
17:50:05 <monochrom> Haskell is not C. I mean the code execution aspect.
17:50:06 <ddarius> Liquid crystals charged to form a pattern saying "Error: <<loop>>" versus a bunch of uncharged liquid crystals.
17:50:21 <Spark> monochrom: programming languages are programming languages
17:50:22 <Cale> (and even that's a model)
17:50:34 <Spark> they differ only in their feature sets, which often overlap substantially
17:51:12 <monochrom> "programming languages are programming languages" is a sign of total negligence.
17:51:24 <lament> monochrom: are you suggesting they aren't? :)
17:51:42 <Spark> i thought equivalence was reflexive :)
17:51:46 <monochrom> Why don't you go implement this notion in GHC and report back to us.
17:52:06 <Spark> i'm not a vigilante
17:52:08 <Spark> i'm just curious
17:52:12 <Spark> if there's a good reason
17:53:48 <Cale> The only really meaningful way to compare functions for equality isn't in general computable. If the domain is finite and the codomain has computable equality, it's relatively easy.
17:53:57 <monochrom> You have seen how C is typically executed low-level, and you can point out what operations are meaningful.
17:54:18 <Spark> then many languages use unmeaningful definitions of equality :)
17:54:21 <Cale> There are also cases where the domain is infinite and yet you can compare functions for equality computably.
17:54:22 <monochrom> You haven't seen how Haskell is typically executed low-level. You just take your C model and assume it carries over.
17:54:30 <Spark> can you compare functions in ruby?
17:55:06 <olsner> ask #ruby, but I assume they will tell you something about solving the halting problem and "No."
17:55:12 <Spark> monochrom: thinking about implementation details while designing an language gets you perl
17:55:21 <byorgey> Cale: really?
17:55:21 <jhdev> ack!
17:55:26 <lament> i dunno in ruby, but in python functions are first of all objects, in the sense of being things with a bunch of properties, one of which being the function body, and one being a unique identity key
17:55:31 * byorgey tries to think how that might work
17:55:34 <dmwit> jhdev: Oh no, what happened!
17:55:36 <mar77a> is lambdabot open source?
17:55:38 <lament> so you can compare functions in python, in the same sense as you can compare any objects
17:55:40 <gwern> ruby might give you a duck typing answer, though
17:55:40 <jhdev> perl!
17:55:46 <lament> this makes sense in python, but it clearly makes no sense in haskell
17:55:48 <monochrom> If you are truly curious, and not just a whiny, study at least the G-machine first. Any explanation why "same origin equality" is unusable is based on that knowledge.
17:55:50 <byorgey> mar77a: sure is.
17:55:51 <dmwit> mar77a: Yes, I think so
17:55:54 <mar77a> good
17:55:55 <dmwit> ?where lambdabot
17:55:55 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
17:56:05 <jhdev> bytecode equality ;)
17:56:23 <dmwit> jhdev: Doesn't work, sometimes thunks aren't yet evaluated.
17:56:40 <Spark> lua: http://rafb.net/p/mGfUE451.html
17:56:40 <lambdabot> Title: Nopaste - paste
17:56:58 <dmwit> jhdev: And deciding how much to evaluate isn't always possible, like in the (const [1..]) == (const [1..]) example somebody gave earlier.
17:57:37 * dmwit doesn't find lua's notion of function equality terribly useful
17:57:41 <byorgey> Spark: that's just pointer equality.
17:57:44 <Spark> lament: it strikes me as odd that a language that takes pride in having functions as values can't compare functions, since that is something you expect to be able to do with values
17:57:49 <Spark> byorgey: lua doesn't have pointers
17:57:57 <dmwit> false
17:57:57 <sieni> Spark: since when?
17:58:06 <mar77a> what's the syntax to untar, again
17:58:08 <byorgey> ok, "reference" equality =)
17:58:10 <dmwit> tar xf
17:58:14 <monochrom> I don't expect equality on most values.
17:58:38 <Spark> what other values can't you expect equality for?
17:58:46 <monochrom> abstract data types
17:59:06 <Spark> java can compare classes
17:59:26 <ricky_clarkson> Spark: Java's behaviour sucks.  It compares pointers.
17:59:35 <dmwit> I suggest you use Java or Lua when you need those capabilities.
17:59:57 <ricky_clarkson> Pointers aren't relevant when your data objects are immutable.
18:00:11 <lament> Spark: i don't think you can convince anybody here that a feature is good by pointing out that Java has it :)
18:00:29 <olsner> oh noes! I lost the terminal window that held the mplayer command line to restart the movie at the place I left it a couple of days ago
18:00:30 * markb hi5's lament
18:00:38 <Cale> byorgey: actually, perhaps I'm confusing that for taking an arbitrary total predicate on a specified infinite domain and computably deciding if it's satisfiable
18:00:39 <Spark> that's just subjective though
18:00:49 <dmwit> olsner: Turn on shell history?
18:00:50 <ricky_clarkson> Spark: Which bit?
18:00:51 <Spark> and that attitude is very close minded
18:01:03 <monochrom> Right way to say it, lament. Java and C have null pointers. Why haskell doesn't?
18:01:04 <lament> "Pointers aren't relevant when your data objects are immutable." - i believe this is the root of the problem
18:01:11 <Spark> monochrom: it has Maybe
18:01:13 <gwern> ok, now that monadius and shu-thing are taken care of...
18:01:15 <sjanssen> Spark: the real issue is that object identity breaks referential transparency
18:01:24 <Spark> sjanssen: noone has explained why yet
18:01:28 <Spark> that was mentioned before though
18:01:35 <olsner> dmwit: it wasn't 'Enter'ed, just entered, so that wouldn't have saved me...
18:01:43 <dmwit> ah
18:01:47 <Spark> we've had "it breaks lots of common optimisations"
18:01:47 <dmwit> bummer
18:01:55 <sjanssen> Spark: imagine Haskell extended with ===, which compares objects by identity
18:02:04 <Cale> oh, right
18:02:05 <Cale> heh
18:02:17 <sjanssen> Spark: look at the code fragment "let x = 1 + 1 in x === x"
18:02:22 <sjanssen> Spark: clearly True, yeah?
18:02:26 <gwern> I hae a question. I want to parse a sh-like language. is parsec a good parser library for that? if it is, has anyone written anything similar?
18:02:49 <Spark> sjanssen: right, you can't compare things unless they have been fully evaluated
18:02:57 <Cale> Yes, that's right. If you have two totally computable functions on such a domain, and the codomain has computable equality, then f(x) /= g(x) is a total computable predicate
18:02:58 <byorgey> olsner: ...you know, there are these things called "text files" which are made specifically for storing... text!
18:03:00 <dmwit> gwern: Parsec has some nice interface for parsing programming languages at a very high level.
18:03:05 <Cale> So you can solve equality there.
18:03:11 <lament> @let (===) = const $ const False
18:03:14 <lambdabot> Defined.
18:03:15 <ricky_clarkson> Spark: In Java, you can have two String objects that both have the text "hello".  Because Strings are immutable you never need to know or care whether they're the same object or not, unless you compare using == instead of .equals, which is bad practice.
18:03:18 <sjanssen> Spark: referential transparency says we can replace any subexpression with its value, so "(1 + 1) === (1 + 1)" should be the same thing according to referential transparency
18:03:26 <araujo> hello
18:03:30 <sjanssen> Spark: however, it will return False
18:03:46 <olsner> byorgey: what an alien concept!
18:03:54 <Spark> sjanssen: it's the "by name" idea
18:03:57 <ricky_clarkson> Spark: If any pair of objects are immutable, they may actually be implemented as one object, or a different object each every time you use them, and it just doesn't matter.
18:04:02 <Spark> sjanssen: unless you can also compare things by name instead of by value
18:04:02 <sjanssen> Spark: and this is why we can't have === in Haskell
18:04:13 <dmwit> gwern: See the ParsecLanguage module, I think.
18:04:21 <lament> > (\x->x) === (\x->x)
18:04:33 <lambdabot>  False
18:04:37 <lament> it works!
18:04:49 <Spark> > let x = 1 + 1 in x === x
18:04:51 <lambdabot>  False
18:04:51 <byorgey> hehe
18:04:58 <Spark> what does === actually do?
18:05:02 <ricky_clarkson> > 1 === 1
18:05:02 <lambdabot>  False
18:05:02 <mkehrt> return false
18:05:06 <gwern> dmwit: thanks, I was still reading the parsec homepage
18:05:07 <mkehrt> obviously
18:05:08 <Spark> ah right
18:05:09 <byorgey> Spark: lament defined it above, as a joke
18:05:12 <ricky_clarkson> @src (===)
18:05:12 <lambdabot> Source not found. Do you think like you type?
18:05:14 <mwc> @tupe (===)
18:05:15 <Spark> ah i didn't see that
18:05:19 <lambdabot> Not in scope: `==='
18:05:23 <Spark> that clearly isn't an equivalence relation :)
18:05:44 <dmwit> Spark: That's what we're trying to tell you.
18:05:45 <sjanssen> Spark: it doesn't actually exist, I was proposing a hypothetical operator for object identity, similar to Java's ==
18:06:14 <Spark> sjanssen: yeah i raelised that, i just didn't see him define it so i thought it clashed with something that did exist
18:06:17 <Spark> dmwit: err no
18:06:23 <sjanssen> Spark: do you agree now that === isn't referentially transparent?
18:06:32 <Spark> yeah that was a good explanation, thanks
18:06:42 <monochrom> thanks sjanssen.
18:06:46 <gwern> hm. that's odd. why java, haskell, and... Mondrian in ParsecLanguage?
18:07:08 <ddarius> gwern: Why not Mondrian?
18:07:12 <sjanssen> now, certain Haskell objects support identity.  IORef, STRef, MVar, etc.
18:07:41 <gwern> ddarius: well, uh, aren't there bazillions of other languages more important? I never even heard of mondrian before that
18:07:51 <Spark> is it so bad to force a particular evaluation order if you don't have laziness?
18:08:11 <dmwit> gwern: Somebody thought it was fun?
18:08:21 * gwern shrugs. I guess so!
18:08:21 <ddarius> gwern: They had Mondrian lexical notes.  I think Daan worked on Mondrian some (though I may easily be mistaken)
18:08:36 <sjanssen> since IORefs and the like have very clear semantics wrt. creation, we can reasonably provide === for them
18:08:44 <ddarius> Spark: Laziness is a particular evaluation order.
18:09:03 <gwern> ah, here comes the 'haskell isn't really lazy, but non-strict' spiel
18:09:18 <ddarius> gwern: I wasn't going to go there.
18:09:33 <Spark> ddarius: in that case, why doesn't the same argument apply to deduce that laziness breaks referential transparency
18:09:44 <monochrom> I like assuming laziness too, not just assuming non-strictness.
18:10:19 <ddarius> Spark: An evaluation order doesn't make or break referential transparency.
18:10:54 <ddarius> I'm not sure what "same argument" you are referring to.
18:10:55 <SamB_XP> the lack of referential transparency might make or break an evaluation order, though
18:11:23 * LoganCapaldo awards SamB_XP 2pts. for clever turn of phrase
18:11:25 <Spark> having === would require both sides to be evaluated before it could
18:11:28 <ddarius> SamB_XP: Only in practicality.  There is nothing inherently wrong with a call-by-name/need imperative language (see Algol 68(?))
18:11:39 <ddarius> Spark: That has nothing to do with the issue.
18:11:47 <Spark> it puts a constraint on the evaluation order
18:11:55 <Spark> same as laziness?
18:11:58 <ddarius> Which has nothing to do with the issue.
18:12:00 <monochrom> Some proof is done to show that various evaluation orders give the same answer, before it is asserted that you are free to choose any of them.
18:12:06 <Spark> ddarius: just run with it and see where it goes
18:12:09 <SamB_XP> ddarius: yes, but... practicality actually does matter
18:12:17 <ddarius> Spark: There's nothing to run with.
18:12:40 <thoughtp1lice> gwern: hm, note on monadius: it seems to need a Monadius.Util module but only Main is provided :/
18:13:12 <ddarius> And I already said where "different" evaluation orders go with regards to this.  It is completely orthogonal to referential transparency.
18:13:18 <SamB_XP> Spark: in actuallity, reallyUnsafePointerEquality# (or whatever the real name is) doesn't check that...
18:13:20 <monochrom> sjanssen++
18:13:23 <gwern> thoughtpolice: yes, that's why cabal install doesn't work. it works fine for me if I do the runhaskell dance, though
18:13:27 <monochrom> SamB_XP++
18:13:32 <ricky_clarkson> Spark: Object identity hampers JVM optimisation already - every time you do 'new SomeClass' the JVM is bound to create a new object.  It makes more sense to do SomeClass(value) and have that exist exactly when you need it, with no particular reference-based identity.
18:14:22 <Spark> ricky_clarkson: you can only transparently create aliases to immutable objects
18:14:37 <Spark> why would (1 + 1) === (1 + 1) have to be false?
18:14:54 <Spark> it would just have to evaluate the left side then the right side, then compute the equality
18:14:55 <monochrom> two thunks are created.
18:15:07 <monochrom> or maybe one thunk is created for both
18:15:10 <Spark> all it does is constrain the evaluation order
18:15:14 <ricky_clarkson> It wouldn't have to be false, but it wouldn't have to be true either.
18:15:15 <sjanssen> Spark: === is identity comparison, not value comparison
18:15:24 <Spark> let's just talk about semantics, not implementations
18:15:32 <Spark> sjanssen: what's the difference?
18:15:39 <ricky_clarkson> === is about implementation, not semantics.
18:15:42 <monochrom> All === does is asking "what code has the compiler produced?"
18:15:51 <ricky_clarkson> Thus it is too low level to be worth thinking about.
18:16:17 <SamB_XP> which is why it should have a much longer, sharper name including the word "unsafe" at some point
18:16:21 <Spark> monochrom: why does it have to compare code, rather than values
18:16:39 <monochrom> If you just talk about semantics, like high-level semantics, sjanssen's explanation kills it.
18:16:41 <SamB_XP> Spark: it compares heap addresses, actually
18:16:53 <monochrom> Your own "same origin" definition.
18:17:09 <SamB_XP> Spark: but whether those are the same or not depends what the compiler did
18:17:18 <ricky_clarkson> @let (unsafePointless===) = const $ const False
18:17:18 <lambdabot>  Parse error in pattern
18:17:19 <Spark> once it has executed them though
18:17:25 <ddarius> Spark: To combine what SamB_XP and monochrom has said: that is the definition -you- gave.
18:17:25 <Spark> they cease to be arbitrary
18:17:26 <sjanssen> Spark: you're familiar with the difference between == and .equals() in Java?  Same thing here
18:17:27 <Spark> they are values
18:17:27 <monochrom> What is the formal (symbolic logical) definition of your === anyway?
18:17:43 <SamB_XP> basically the only thing that you can assume is that if one side has a given value, the other side will have the same value
18:18:05 <SamB_XP> you can't necessarily assume that they are ==, though, since NaNs don't compare equal
18:18:11 <ricky_clarkson> Spark: Integer x=500;  x+1==x+1 gives false, in Java. ;)
18:18:17 <Spark> monochrom: you mean the semantics?
18:18:23 <sjanssen> I think the reason we're getting a bit confused here is that the semantics of Haskell don't support this concept at all
18:18:32 <ricky_clarkson> Sorry, that's a lie, but something similar gives false.
18:18:33 <SamB_XP> ricky_clarkson: well, in the old days you weren't allowed to use a + there, were you?
18:18:53 <ricky_clarkson> SamB_XP: Right.
18:19:10 <LoganCapaldo> unless x was a string...
18:19:20 * LoganCapaldo mumbles incoherently
18:19:36 <thoughtpolice> Spark: they're still values, but they aren't at the same location, pointer or whatever you want to call it, which is what == compares for.
18:19:54 <sjanssen> Haskell's semantics are primarily defined denotationally, === is a very operation concept
18:19:58 <Spark> sjanssen: i think your example works better if you consider let x = Î»x.x in x === x
18:20:19 <sjanssen> Spark: why?
18:20:23 <ricky_clarkson> Integer x=500,y=500; x!=y
18:20:37 <Spark> because i consider 1 + 1 to be 2, whereas Î»x.x is not something you can further reduce
18:20:50 <ricky_clarkson> So even in the language of imperative strictness, object identity is often uninteresting.
18:21:26 <pi3> I'm starting to learn Haskell and I have a question: what kind of algorithms isn't Haskell good for?
18:21:40 <Spark> actually haskell implementations thrive on aliases being indistinguishable from separate things (due to mutability)
18:21:54 <Spark> so this goes at right angles to every design choice made
18:22:10 <monochrom> Algorithms written with presumption about mutable variables.
18:22:47 <ricky_clarkson> That reminds me.  Apparently there is no hashtable implementation for Haskell.  Why is that?
18:22:54 <ddarius> Spark: There is no reason for 2 === 2
18:22:57 <monochrom> You are supposed to use a different algorithm that gives the same answer.
18:23:31 <monochrom> Data.HashTable may be usable.
18:23:32 <ddarius> ricky_clarkson: There is, it just sucks.
18:23:51 <ddarius> ricky_clarkson: That said, it apparently doesn't bother people too much when the just sit down and write code.
18:23:58 <Spark> so any algorithm involving a hashtable then :)
18:24:09 <ddarius> (i.e. they use Data.Map and get on with life)
18:24:40 <monochrom> Here is a sample problem. Build a list with 0 and then 0 and then 0 and on and on and on.
18:24:59 <byorgey> pi3: ...algorithms that require lots of mutable state?
18:25:13 <byorgey> pi3: but I'm not sure that question really means all that much
18:25:16 <markb> monochrom: f = 0 : f?
18:25:17 <monochrom> Imperative algorithm. Initialize a list variable to be empty. Loop: append 0 to the list variable.
18:25:22 <jhdev> can it clean up a function, optimize it, and then print it as stardardized text?
18:25:27 <ddarius> Haskell is still fine for those.
18:25:29 <monochrom> Yes markb.
18:25:32 <jhdev> and compare the text
18:25:33 <markb> yay :D
18:25:47 <monochrom> The imperative algorithm is completely busted if you just dumbly translate to haskell.
18:25:50 <byorgey> yeah, it is actually.
18:26:06 <ricky_clarkson> > [0,0..]
18:26:07 <jhdev> can a function be uncompiled back into text haskell?
18:26:08 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
18:26:32 <monochrom> Functional algorithm: what markb says. Use recursion. Define the list to be 0 prepended to the list itself.
18:26:40 <ddarius> jhdev: If your implementation supports it.
18:26:44 <sjanssen> jhdev: not in any existing implementation
18:26:47 <Spark> monochrom: one list is finite, the other isn't
18:26:55 <sjanssen> AFAIK, maybe yhc can do it
18:27:04 <davidL> Is Data.Binary useful for data that hasn't been serialized with it? I'm just interested in deserialization.
18:27:07 <monochrom> The functional algorithm is totally busted if you just dumbly translate to C.
18:27:12 <Spark> you'd create an infinite list in an imperative language by creating a cycle on the heap
18:27:14 <ddarius> davidL: Part of it is.
18:27:16 <byorgey> jhdev: it would probably be really, really ugly though.  assuming the compiler applied some optimizations.
18:27:26 <markb> Spark: they are both infinite, but constrained by physical and virtual memory
18:27:28 <ddarius> Spark: fibs = 0:1:zipWith (+) fibs (tail fibs)
18:27:30 <jhdev> no doubt
18:27:37 <Spark> markb: not really
18:27:37 <sjanssen> davidL: yep, the Get Monad can be used for custom formats
18:27:45 <ricky_clarkson> Spark: Requiring TCO or mutation, afaict.
18:27:52 <davidL> sjanssen: is there an example of that somewhere?
18:27:58 <mauke> struct node x = { 0, &x };
18:28:01 <Spark> markb: a cycle and an infinite list in haskell take up finite memory (until you start stepping over them)
18:28:31 <sjanssen> davidL: the library itself is full of serialization/deserialization examples
18:28:56 <Spark> of course an infinite list of 0 isn't very useful :)
18:28:57 <monochrom> If you want bounded lists, change my problem specification to: "produce a list of 10 0's". Change both code to: stop after getting 10 elements. The main point still stands.
18:29:10 <davidL> thanks, I will have a look
18:29:18 <markb> Spark: tell that to `yes`
18:30:14 <monochrom> The main point is: C algorithms look funny in Haskell.
18:30:22 <ddarius> Actually that "trivial" values are "useless" is a common misconception in most imperative programmers' minds.
18:30:30 <monochrom> It is the same as: Chinese poems sound funny in English.
18:30:51 <Spark> surely you'd hope that the interface would export more than just a function on a list
18:31:30 <monochrom> Most of the time I don't want to waste time arguing what is useless.
18:31:46 <monochrom> Give me a problem. I show you how I solve it, what I use.
18:31:50 <byorgey> arguing about what is useless, is useless.
18:32:01 <markb> thats useless
18:32:10 <Brian`> quick question (out of topic), what does ~= represent?
18:32:18 <byorgey> Brian`: in what context?
18:32:33 <Brian`> in the paper i'm reading now, it says
18:32:38 <jhdev> it's a cat pouncing on a duck
18:32:39 <Brian`> where satisfied b = f b ~= 0.0
18:32:42 <Spark> it's a worm that just got missed by a car
18:32:49 <Spark> not equals, probably
18:32:49 <jhdev> o im wrong
18:32:51 <Brian`> they are saying it's Newton's method
18:33:00 <byorgey> Brian`: approximately equal to, perhaps?
18:33:03 <monochrom> approximately equal, perhaps.
18:33:05 <scook0> approximately equal? equivalent?
18:33:06 <Brian`> oh i c
18:33:11 <Brian`> is it supported in haskell?
18:33:14 <ddarius> Brian`: You are reading the algebra paper by Foekker and it means approximately equal and is defined on the next page.
18:33:19 <monochrom> @quote approximately
18:33:19 <lambdabot> No quotes match. You untyped fool!
18:33:25 <monochrom> @quote equal
18:33:25 <lambdabot> Gwern says: actually, i define bottom to equal 1 in all my programs, so I can guarantee they will never crash
18:33:34 <byorgey> Brian`: you could define it.  it's not in the standard libraries.
18:33:35 <Brian`> ddarius// oh you're right haha :)
18:33:45 <Brian`> i should've looked the next page lol
18:33:47 <monochrom> They've lost my great saying about approximately equal. But ok, I can tell you again.
18:33:52 <LoganCapaldo> > let a ~= 0.0 = True in 7 ~= 0.9
18:34:01 <ddarius> ~= the dual to ===
18:34:06 <byorgey> pattern match failure!
18:34:07 <Spark> why didn't they use â‰ˆ
18:34:08 <lambdabot>  thread killed
18:34:11 <monochrom> All "approximately equal"s are approximately equal. Some are more approximately equal than others.
18:34:17 <LoganCapaldo> I'm the thread killer
18:34:29 <ray> i could use a man like you
18:34:31 <Spark> or just x - y < Îµ
18:34:34 <Spark> or something like that
18:34:46 <monochrom> Brian` that is why there is no standardized "approximately equal".
18:34:49 <Zime> PROBLEM!!! Haskell can't do symbolic manipulation. And I really want to learn a programming language that will help solidify my knowledge of calculus (numerical approximations don't cut it). What Should I do? ption 1) Stop leaning Haskell and start learning Mathematica (. Or (option 2)
18:35:10 <monochrom> Option 2 is probably start learning Maple.
18:35:11 <Brian`> monochrom, gotcha :)
18:35:25 <monochrom> Option 3 is probably start learning Maxima. It's free and open source.
18:35:25 <Brian`> what about matlab?
18:35:28 <ddarius> Zime: You can code up symbolic stuff fine in Haskell, but yes some CAS is probably better.
18:35:36 <ddarius> (There are way more than just Mathematica.)
18:35:44 <monochrom> matlab is weak or incapable on the symbolic front.
18:35:55 <Stinger_> If I wanted to learn calc, I'd probably read a math book
18:35:58 <jhdev> Apl?
18:36:05 <ddarius> (That said, I don't see the value of a CAS for "solidifying one's knowledge of calculus", but I'm probably just old-fashioned.)
18:36:34 <monochrom> Most likely a CAS also plots graphs. It helps.
18:37:07 <mar77a> > (+)
18:37:22 <lambdabot>  thread killed
18:37:37 <Zime> (option two) attempt to write a sophisticated algorithm that computes things like derivatives, integrals, etc
18:37:41 <SamB_XP> you can get differentiation rules out of CASes...
18:37:56 <ddarius> Zime: Derivatives are easy
18:38:05 <Zime> you'd think someone would have done that by know
18:38:06 <sw17ch> Does some one have a second to verify that I have the concept of Zippers down well?
18:38:14 <SamB_XP> integrals are impossible
18:38:31 <Zime> ddarius: OMG please show me on Hpaste!
18:38:49 <ddarius> @google Oleg Kiselyov
18:38:52 <lambdabot> http://okmij.org/ftp/
18:38:52 <lambdabot> Title: This FTP site
18:38:54 <monochrom> simplification is where the money is at.
18:39:21 <sjanssen> @google augustsson automatic differentiation
18:39:22 <lambdabot> http://brainwagon.org/?p=2400
18:39:22 <lambdabot> Title: brainwagon » Lennart Augustsson on Automatic Differentiation
18:39:28 <monochrom> It's trivial to write code that takes in "x+x" and outputs "1+1".
18:39:38 <sjanssen> @hackage numbers
18:39:38 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/numbers
18:39:47 <monochrom> The money is at recognizing "1+1" and outputing "0" instead.
18:39:51 <monochrom> err I mean "2".
18:39:56 <SamB_XP> monochrom: hahahahaha
18:40:11 * SamB_XP wonders if monochrom did that on purpose
18:40:14 <sjanssen> Zime: ^^^ has a nice module you can use
18:40:53 <ray> the money is at recognizing "1+1", wiring 2 to your swiss bank account, and outputting "0" instead
18:41:26 <monochrom> Of course, this is not contradicting SamB_XP. The money is also at doing integrals. It's even harder than algebraic simplifications.
18:41:28 <Zime> sjanssen: who is ^^^
18:41:31 <Pseudonym> Remind me not to work at Credit Suisse.
18:41:52 <Brian`> why not?
18:41:57 <sjanssen> Zime: he is arrows point upwards to the link http://hackage.haskell.org/cgi-bin/hackage-scripts/package/numbers :)
18:41:58 <lambdabot> http://tinyurl.com/33mfjx
18:42:00 <Brian`> don't they use lovely haskell at work?
18:42:11 <davidL> is Data.BitSyntax deprecated by Data.Binary?
18:42:13 <SamB_XP> monochrom: is your ISP named after the structure from abstract algebra?
18:42:22 <monochrom> No. :)
18:42:24 * Pseudonym doesn't want to be involved in software bug-based fraud courtesy of monochrom
18:42:25 <ddarius> Pseudonym: Don't work at Credit Suisse.
18:42:32 <monochrom> hahahahaha
18:42:41 <Brian`> lol
18:42:57 <ddarius> http://www.haskell.org/pipermail/haskell/2004-November/014939.html
18:42:58 <lambdabot> Title: [Haskell] Typeful symbolic differentiation of compiled functions, http://tinyurl.com/2gxa53
18:43:45 <jhdev> wanyone used a language called J?
18:43:46 <LoganCapaldo> ddarius: I've been googling for that since the topic came up. That's for making me stop doubting my sanity
18:43:50 <jhdev> *anyone
18:43:57 <dmwit> jhdev: No, but I've seen it.  Looks dense.
18:44:05 <LoganCapaldo> s/That's/Thanks/
18:44:08 <jhdev> yeah too many operators
18:44:17 <jhdev> but it is functional-ish
18:44:24 <davidL> J shows up often on project euler
18:44:31 <jhdev> someone wants me to learn it for a project
18:44:56 <ddarius> It's probably worth learning (presuming you enjoy things that are different)
18:44:59 <LoganCapaldo> I almost took a job programming the succeeding letter.
18:45:08 <LoganCapaldo> *programming in the
18:45:27 <davidL> K!
18:45:30 <LoganCapaldo> does that count?
18:45:38 <jhdev> I'm more of an assembly programmer, warps the mind
18:45:42 <ddarius> LoganCapaldo: Almost.
18:45:52 <ddarius> jhdev: What's wrong with assembly?  I like assembly.
18:46:03 <monochrom> assembly doesn't warp the mind.
18:46:05 <davidL> isn't K a business-oriented version of J?
18:46:10 <dmwit> LoganCapaldo: You almost took a job in a different language? Amazing!
18:46:23 <jhdev> must be me ;)
18:46:42 <LoganCapaldo> dmwit: heh. well they're similar, same guy(s?) :)
18:47:14 <monochrom> OK, everything warps the mind.
18:48:09 <loupgaroublond> Brainfuck does other things to the mind
18:48:18 <monochrom> haha
18:48:20 <jhdev> I find functional languages non-intuitive, thought it must be the assembly
18:48:36 <monochrom> Anyway, knowing assembly helps learning continuations.
18:48:38 <LoganCapaldo> no intuition for you!
18:48:43 <jhdev> :(
18:48:53 <LoganCapaldo> it's better that way
18:48:54 <dmwit> Intuition is overrated.
18:49:01 <monochrom> Knowing continuations helps learning functional programming.
18:49:31 <ddarius> jhdev: You'd probably find Telegu unintuitive that doesn't really mean much.
18:49:46 <jhdev> is there a specific way I should go about learning functional programming?
18:49:53 <ddarius> monochrom: Knowing continuations helps learning assemblyi.
18:49:56 <jhdev> coming from a very narrow procedural background
18:50:02 <dmwit> Just use it for a while.
18:50:03 <monochrom> It works both ways and more.
18:50:07 <ddarius> jhdev: Learn however you learn best.
18:50:10 <loupgaroublond> jhdev: from my newbie perspective (mostly python) just start writing stuff
18:50:36 <jhdev> i ALSO SUFFER FROM A LACK OF IMAGINATION IN THIS DEPARTMENT
18:50:39 <jhdev> thx
18:50:43 <jhdev> opos caps lock!
18:50:58 <jhdev> heh
18:51:01 <ddarius> jhdev: How did you learn assembly?
18:51:05 <davidL> bind caps lock to control :)
18:52:07 <monochrom> I have always thought "C for Haskell programmers" sheds new light on things.
18:52:55 <LoganCapaldo> there's a C for haskell programmers?
18:52:57 <ray> is there such a thing? i want to see!
18:53:02 <LoganCapaldo> @go C for haskell programmers
18:53:03 <lambdabot> http://www.haskell.org/~pairwise/intro/intro.html
18:53:03 <lambdabot> Title: Haskell for C Programmers
18:53:09 <LoganCapaldo> no
18:53:14 <LoganCapaldo> wrong lb
18:53:15 <monochrom> Not yet. But I think it will be a great idea.
18:53:34 <LoganCapaldo> monochrom: get on that ASAP. I would kike to read it :)
18:53:43 <ddarius> Assembly for Haskell programmers would be cool, C would be boring.
18:53:53 <ddarius> I should write that.  I'll add it to my ideas list.
18:54:18 <monochrom> Hopefully "C for Haskell programmers" is the adjoint of "Haskell for C programmers" and puts things in a nice perspective.
18:56:14 <monochrom> Maybe it is the forgetful functor.
18:56:46 <ddarius> I doubt Haskell programmers can be freely generated from C programmers.
18:57:00 <monochrom> hahahahaha
18:58:30 <StoneNote> "Haskell for COBOL Programmers" First, you are no longer in the novel writing business...
18:59:43 <loupgaroublond> The greatest salesmen is the man who sold a freezer full of "Haskell for Haskell Programmers" to an eskimo
19:00:06 <loupgaroublond> his sequel "I am SQL, and so can you" failed, as all sequels do
19:00:20 <Pseudonym> StoneNote: To be fair, I suspect that most COBOL programmers know another language.
19:00:24 <jaj> you can actually join #haskell at any time, there will always be people talking :)
19:00:25 <Pseudonym> PL/I, for example.
19:00:26 <Zime> sjanssen: omg that helps so much!
19:00:32 <ray> loupgaroublond: that's very clever
19:00:41 <ray> meaning the part where you used SQL and 'sequel' together
19:00:48 <monochrom> hahahahaha loupgaroublond
19:01:06 <StoneNote> Pseudonym, some do some don't, just like any other group of programmers.
19:01:23 <monochrom> @remember loupgaroublond The greatest salesmen is the man who sold a freezer full of "Haskell for Haskell Programmers" to an eskimo. His sequel "I am SQL, and so can you" failed, as all sequels do.
19:01:23 <lambdabot> It is forever etched in my memory.
19:01:36 * ddarius bets all Intercal programmers know another language.
19:01:45 <Pseudonym> StoneNote: Are there any working COBOL programmers who don't know some other language?
19:01:45 <loupgaroublond> oh, nice :)
19:01:47 <Pseudonym> Seriously.
19:01:56 <Pseudonym> There might be a few retired ones,.
19:02:02 <ddarius> loupgaroublond: Unfortunately the bot will forget in about 7 hours.
19:02:03 <Pseudonym> And dead ones.
19:02:11 <Spark> there is always one
19:02:19 <Spark> who seeks to defy statistics
19:02:21 <monochrom> oh noes, what will happen 7 hours later?
19:02:23 <loupgaroublond> that's a shame, though i never met a bot that does that
19:02:30 <loupgaroublond> *before
19:02:38 <dmwit> ?quote
19:02:38 <lambdabot> Gwern says: actually, i define bottom to equal 1 in all my programs, so I can guarantee they will never crash
19:02:41 <lambdabot> My AI kernel hurts. What WAS I doing last night?
19:02:45 <ddarius> monochrom: You'll see, or maybe you won't.  One of the two.
19:02:51 <StoneNote> Pseudonym, if you count SAS as a language, and I would, then I can;t think of any I know personally
19:02:59 <monochrom> I won't see. I'll be in bed and offline.
19:03:11 <lambdabot> I vaguely remember the IRC seach bot buying me a drink. It's kind of a blur after that.
19:03:37 <nebulous> how can i take the cartesian product of a list?
19:03:46 <NotOlathe> lambdabot: Learn to spell !
19:03:48 <ddarius> nebulous: with itself?
19:03:52 <nebulous> yes
19:03:53 <Pseudonym> > [ (x,y) | x <- [1,2,3], y <- [3,4,5] ]
19:03:54 <lambdabot>  [(1,3),(1,4),(1,5),(2,3),(2,4),(2,5),(3,3),(3,4),(3,5)]
19:03:55 * dmwit was kicked by lambdabot ("you're making my headache worse")
19:04:06 <ddarius> > join (liftM2 (,)) [1,3,4]
19:04:07 <lambdabot>  [(1,1),(1,3),(1,4),(3,1),(3,3),(3,4),(4,1),(4,3),(4,4)]
19:04:45 <dmwit> nebulous: Note that you have to be slightly more clever if you want to do the cartesian product of infinite lists.
19:04:54 <nebulous> thank you.
19:05:01 <Stinger_> hmmm
19:05:09 <Stinger_> @ty liftM2
19:05:12 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
19:05:12 <Brian`> what does const do? does it just return the first number?
19:05:14 <Brian`> > const 8 3
19:05:15 <lambdabot>  8
19:05:19 <Brian`> > const 9323295 0
19:05:19 <lambdabot>  9323295
19:05:20 <ddarius> @src const
19:05:20 <lambdabot> const x _ = x
19:05:20 <dmwit> yes
19:05:27 <ddarius> In fact
19:05:29 <ray> not just numbers
19:05:31 <ddarius> @. djinn type const
19:05:32 <glguy> > const id 4 5
19:05:38 <lambdabot> f a _ = a
19:05:38 <lambdabot>  5
19:05:45 <LoganCapaldo> > const (Just "3") False
19:05:46 <lambdabot>  Just "3"
19:06:00 <Brian`> i c... what is it useful for?
19:06:10 <mauke> > const sqrt log 10
19:06:11 <lambdabot>  3.1622776601683795
19:06:12 <ddarius> > const "somebody set us up the" (error "bomb")
19:06:13 <lambdabot>  "somebody set us up the"
19:06:31 <LoganCapaldo> > foldr1 const [1,2,3]
19:06:31 <lambdabot>  1
19:06:32 <mauke> ignoring values
19:06:36 <ddarius> Brian`: To stick into other functions (and often it's handy itself)
19:06:38 <glguy> > zipWith const [1..] [3,4,5,6]
19:06:39 <lambdabot>  [1,2,3,4]
19:06:40 <NotOlathe> Brian`: Do you know about currying ?
19:06:53 <LoganCapaldo> @src (->) return
19:06:53 <lambdabot> return = const
19:06:55 <Brian`> Not0lathe, yeah
19:07:06 <NotOlathe> Brian`: What does (const 3) give ?
19:07:14 <Brian`> 3
19:07:18 <dmwit> nope
19:07:19 <NotOlathe> > const 3
19:07:19 <lambdabot>  Add a type signature
19:07:26 <NotOlathe> :t const 3
19:07:27 <lambdabot> forall t b. (Num t) => b -> t
19:07:30 <dmwit> const 3 === \x -> 3
19:07:33 <Brian`> oh you mean a function?
19:07:40 <ddarius> > const 3 === \x -> 3
19:07:40 <Brian`> ok
19:07:40 <lambdabot>  False
19:07:45 <gwern> :t null
19:07:45 <lambdabot> forall a. [a] -> Bool
19:07:48 <Brian`> :t (const 3)
19:07:49 <lambdabot> forall t b. (Num t) => b -> t
19:07:52 <gwern> > null []
19:07:53 <lambdabot>  True
19:07:55 <gwern> > null [1]
19:07:55 <lambdabot>  False
19:08:03 <monochrom> Some library function wants me to provide a callback Int->Int. I want my callback to always give 2. The callback is then const 2.
19:08:08 <NotOlathe> > let f = (const 3) in f 5
19:08:09 <lambdabot>  3
19:08:18 <mauke> modify (const 0)
19:08:30 <dmwit> > map (const 3) [1..]
19:08:35 <lambdabot>  [3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3...
19:08:37 <monochrom> Control.Monad.Reader.local is an example.
19:08:44 <NotOlathe> > [3,3..]
19:08:45 <lambdabot>  [3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3...
19:08:53 <mauke> > repeat 3
19:08:54 <lambdabot>  [3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3...
19:09:02 <tehgeekmeister> in this version of the state monad's bind, is the let statement binding both v and s' to the value x s: (State x) >>= f = State $ \s -> let (v,s') = x s in runState (f v) s' ?
19:09:06 <NotOlathe> > let f = 3:f in f
19:09:07 <lambdabot>  [3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3...
19:09:12 <dmwit> > fix (3:)
19:09:13 <lambdabot>  [3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3...
19:09:16 <NotOlathe> Heh
19:09:33 <mauke> > map ((* 3) . join (/)) [1 ..]
19:09:33 <lambdabot>  [3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0,3.0...
19:09:38 <ddarius> tehgeekmeister: It's binding v and s' to the components of the tuple returned by x s
19:09:39 <mauke> > map ((* 3) . join div) [1 ..]
19:09:40 <lambdabot>  [3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3...
19:09:59 <NotOlathe> @unpl ((* 3) . join div)
19:09:59 <lambdabot> (\ d -> ((div >>= \ e -> e) d) * 3)
19:10:07 <NotOlathe> Damn you >>= !
19:10:17 <dmwit> It comes from join.
19:10:21 <LoganCapaldo> Don't take >>= in vain.
19:10:33 <mauke> \e -> e is id
19:10:36 <mauke> >>= id is join
19:10:38 <tehgeekmeister> ddarius: does this have to do with the nature of let statements or is it related to pattern matching, so i can look up more about it in the haskell report?
19:10:49 <NotOlathe> @pl (\a -> (div a a) * 3)
19:10:49 <lambdabot> (3 *) . join div
19:10:51 <ddarius> tehgeekmeister: It's just pattern matching on a tuple.
19:10:59 <NotOlathe> @pl (\a -> 3*(div a a))
19:10:59 <lambdabot> (3 *) . join div
19:11:00 <ddarius> > let Just x = Just 5 in x
19:11:10 <ddarius> > let (x,y) = (3,6) in y
19:11:12 <lambdabot>  6
19:11:12 <lambdabot>  5
19:11:59 <mauke> > let Nothing = Just 3 in "what"
19:11:59 <lambdabot>  "what"
19:12:38 <NotOlathe> > let Just = Nothing in Just 3
19:12:39 <lambdabot>      Constructor `Just' should have 1 argument, but has been given 0
19:12:39 <lambdabot>     In t...
19:12:57 <NotOlathe> Heh
19:13:01 <dmwit> > let just = const Nothing in just 3
19:13:03 <lambdabot>  Nothing
19:13:18 <LoganCapaldo> dmwit: madness!
19:13:20 <NotOlathe> > id id id 3
19:13:21 <lambdabot>  3
19:13:32 <NotOlathe> > fix id 3
19:13:33 <lambdabot>  Exception: <<loop>>
19:13:36 <NotOlathe> Lies.
19:13:39 <mauke> > join join id 3
19:13:39 <lambdabot>      Occurs check: cannot construct the infinite type:
19:13:39 <lambdabot>       m = (->) (m (m a...
19:13:43 <laz0r> oh noes!
19:13:43 <ddarius> Sometimes I wonder about you people.
19:13:47 <LoganCapaldo> > fix (. id) 3
19:13:52 <NotOlathe> Oh, nose !
19:13:54 <lambdabot> Terminated
19:14:10 <NotOlathe> > id id id id id id id 3
19:14:10 <lambdabot>  3
19:14:10 <laz0r> i spend three days fighting with my code, where i needed unique numbers, trying with random and state and whatnot
19:14:17 <mauke> > fix (const 3)
19:14:18 <lambdabot>  3
19:14:22 <laz0r> and i just discovered Data.Unique
19:14:26 <laz0r> ...
19:14:32 <dmwit> \o/
19:14:33 <laz0r> at least i got a solution
19:14:34 <NotOlathe> > join id id 3
19:14:34 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -> t1 -> t
19:14:34 <lambdabot>     P...
19:14:40 <NotOlathe> > join id id
19:14:41 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -> a1
19:14:41 <lambdabot>     Probab...
19:14:46 <NotOlathe> :|
19:15:17 <dmwit> laz0r: But that only works in the IO monad... =/
19:15:40 <laz0r> i know, i think i can live with that
19:15:52 <laz0r> at least right now it looks like i can
19:16:04 <ddarius> laz0r: All you should need is a simple use of the state monad.
19:16:07 <oerjan> > join id
19:16:09 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -> a1
19:16:09 <lambdabot>     Probab...
19:16:13 <ray> > let 1 = undefined in 1
19:16:15 <lambdabot>  1
19:16:15 <ddarius> There's even a specialization of it on the wiki for that specific problem.
19:16:20 <davidL> Does Adam Langley ever show up here?
19:16:21 <ray> > let 1+1 = undefined in 1+1
19:16:21 <lambdabot>  Undefined
19:16:55 <dmwit> ray: Integer literals have an implicit "fromIntegral" in front of them.
19:17:01 <laz0r> ddarius, i tried with the state monad
19:17:02 <Brian`> @src undefined
19:17:03 <lambdabot> undefined =  error "Prelude.undefined"
19:17:06 <ddarius> dmead: That's irrelevant.
19:17:10 <ddarius> er dmwit
19:17:12 <LoganCapaldo> @src error
19:17:13 <lambdabot> error s = throw (ErrorCall s)
19:17:24 <LoganCapaldo> @src throw
19:17:24 <lambdabot> throw exception = raise# exception
19:17:32 <LoganCapaldo> @src raise#
19:17:32 <NotOlathe> > error "omg !"
19:17:32 <lambdabot> Source not found. That's something I cannot allow to happen.
19:17:33 <lambdabot>  Exception: omg !
19:17:44 <NotOlathe> > throw "omg !"
19:17:44 <lambdabot>   Not in scope: `throw'
19:17:48 <NotOlathe> Lies.
19:17:56 <ddarius> @index throw
19:17:56 <lambdabot> Control.Exception
19:18:00 <monochrom> NotLies.
19:18:07 <dmwit> ddarius: Mmm, it seems you're right, as usual.
19:18:11 <LoganCapaldo> Lies -> Void
19:18:19 <monochrom> haha
19:18:23 <laz0r> ddarius, actually i would still prefer a solution with the state monad, where i could use information from the result of my computation to change the state of the computation
19:18:53 <laz0r> ddarius, i spend some time trying with Control.Monad.Fix, but i couldnt get it to do what i wanted it to do
19:19:02 <NotOlathe> > error "<<loopy>>"
19:19:03 <lambdabot>  Exception: <<loopy>>
19:19:22 <dmwit> laz0r: Is a simple accumulator unique enough?
19:19:26 * NotOlathe starts to think evilly.
19:19:49 <laz0r> dmwit, yes
19:19:50 <dmwit> ?let x + y = error "<<loop>>"
19:19:50 <lambdabot> <local>:5:12:     Ambiguous occurrence `+'     It could refer to either `+', ...
19:19:52 <ddarius> sorear: What the hell are you talking about on haskell-cafe?
19:20:22 <NotOlathe> lambdabot is spiffy.
19:20:24 <dmwit> unique :: State Integer Integer
19:20:35 <ddarius> Shite!
19:20:39 <dmwit> unique = get ## modify (+1)
19:20:52 <LoganCapaldo> @type (##)
19:20:53 <lambdabot> Not in scope: `##'
19:20:57 <dmwit> a ## b = do { x <- a; b; return x }
19:21:05 <tehgeekmeister> how does it work to apply x in that definition of state's bind to anything?  isn't it just a tuple?
19:21:19 <dmwit> (##) was defined in some monad library, and I've used it a few times since.
19:21:32 <laz0r> dmwit, where is unique defined?
19:21:42 <dmwit> laz0r: Right here, in #haskell. =)
19:21:51 <NotOlathe> > let id = const (error "<<loop>>") in id 5
19:21:51 <lambdabot>  Exception: <<loop>>
19:21:56 <LoganCapaldo> newtype State = State { runState :: s -> (a, s) }
19:21:59 <laz0r> oh, i see
19:22:16 <LoganCapaldo> values in State are functions from state to a tuple, they're not tuples themselves
19:22:18 <ray> #haskell is a massively multiplayer REPL
19:22:23 <LoganCapaldo> (for one implementation of State)
19:22:35 <tehgeekmeister> oh, right, i'd forgotten.
19:22:45 <loupgaroublond> how often is it normal to want to smack one's self for misreading cols as columns when learning haskell?
19:22:50 <tehgeekmeister> i need to learn how to read type signatures better, sorry.
19:22:52 <Brian`> what' the difference between newtype and type?
19:23:04 <monochrom> What is cols?
19:23:07 <dmwit> Brian`: newtype requires a constructor
19:23:16 <Brian`> then is it same as data?
19:23:26 <dmwit> No, it only gets one constructor.
19:23:29 <Brian`> @src newtype
19:23:29 <lambdabot> Source not found. Just what do you think you're doing Dave?
19:23:32 <NotOlathe> @src fix
19:23:32 <lambdabot> fix f = let x = f x in x
19:23:40 <dmwit> Brian`: And the constructor must be of arity 1.
19:23:43 <dmwit> (I think.)
19:23:47 <gwern> @type splitAt
19:23:48 <lambdabot> forall a. Int -> [a] -> ([a], [a])
19:24:19 <NotOlathe> > let fix _ _ = error "<<loop>>" in fix (+1) 5
19:24:20 <lambdabot>  Exception: <<loop>>
19:24:28 <NotOlathe> As you can see, it's the same thing.
19:24:55 <dmwit> > fix (+1) 5
19:24:55 <lambdabot>   add an instance declaration for (Num (t -> a))
19:25:12 <oerjan> @remember ray #haskell is a massively multiplayer REPL
19:25:13 <lambdabot> Done.
19:25:24 <dmwit> NotOlathe: Doesn't look the same to me. =)
19:26:07 <monochrom> Observationally equivalent XD
19:26:55 <NotOlathe> ;)
19:27:23 <NotOlathe> > let fix _ _ = error "<<loop>>" in fix id 5
19:27:23 <lambdabot>  Exception: <<loop>>
19:27:27 <NotOlathe> How's that.
19:27:59 <oerjan> :t (<*)
19:28:00 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
19:28:53 <ricky_clarkson> > split "hello world" " "
19:28:54 <lambdabot>  Couldn't match expected type `[Char] -> t'
19:29:00 <ricky_clarkson> @type split
19:29:01 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
19:29:03 <dmwit> > let fix = error "<<loop>>" :: (a -> a) -> a in fix (+1) 5 -- now it's closer =)
19:29:03 <lambdabot>   add an instance declaration for (Num (t -> a))
19:29:14 <ricky_clarkson> Is there something like what I want?
19:29:23 <oerjan> ricky_clarkson: no
19:29:25 <ricky_clarkson> [Char] -> [Char] -> [[Char]]
19:29:26 <dmwit> > splitAt isSpace "hello world"
19:29:26 <lambdabot>  Couldn't match expected type `Int'
19:29:38 <dmwit> > break isSpace "hello world"
19:29:39 <lambdabot>  ("hello"," world")
19:29:49 <dmwit> > words "hello world"
19:29:50 <lambdabot>  ["hello","world"]
19:29:51 <ricky_clarkson> Why's that a tuple?
19:29:53 <NotOlathe> @src (->)
19:29:53 <lambdabot> Source not found. I am sorry.
19:29:58 <gwern> > break (== ">>") "foo bar >> top"
19:29:59 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
19:30:01 <dmwit> ricky_clarkson: Because it does exactly one break.
19:30:03 <Brian`> @src break
19:30:03 <lambdabot> break p =  span (not . p)
19:30:04 <ricky_clarkson> Ah, words seems good.
19:30:17 <Brian`> @src span
19:30:17 <lambdabot> Source not found.
19:30:21 <Brian`> :t span
19:30:22 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
19:30:40 <Brian`> > span (\x -> True) [3,4,5]
19:30:40 <lambdabot>  ([3,4,5],[])
19:30:46 <dmwit> ?src Data.List.span
19:30:46 <lambdabot> Source not found. That's something I cannot allow to happen.
19:31:03 <NotOlathe> > span (> 4) [3..5]
19:31:03 <ricky_clarkson> I need it for something of great importance..
19:31:04 <lambdabot>  ([],[3,4,5])
19:31:08 <oerjan> dmwit: i don't think adding module to @src ever helps
19:31:08 <ricky_clarkson> > reverse $ words "somebody set up us the bomb"
19:31:09 <lambdabot>  ["bomb","the","us","up","set","somebody"]
19:31:13 <dmwit> Brian`: There's your chance to use const!
19:31:20 <dmwit> > span (const True) [3,4,5]
19:31:20 <lambdabot>  ([3,4,5],[])
19:31:31 <oerjan> @src Data.List.break
19:31:31 <lambdabot> Source not found. Are you on drugs?
19:31:35 <Brian`> dmwit, wow! that's right :) hehe useful application there
19:31:38 <NotOlathe> > span (< 4) [3..5]
19:31:39 <lambdabot>  ([3],[4,5])
19:31:52 <dmwit> Brian`: heh
19:32:04 <dmwit> > span (< 4) [3,4,5,4,3,2,1]
19:32:05 <lambdabot>  ([3],[4,5,4,3,2,1])
19:32:19 <dmwit> > partition (< 4) [3,4,5,4,3,2,1]
19:32:20 <lambdabot>  ([3,3,2,1],[4,5,4])
19:33:01 <ddarius> I like Dirichlet serios.
19:33:06 <ddarius> s/serios/series
19:33:16 <NotOlathe> @pl \ch xxs -> let (x, xs) span (/= ch) xs in [x, f xs]
19:33:16 <lambdabot> (line 1, column 16):
19:33:16 <lambdabot> unexpected "("
19:33:16 <lambdabot> expecting natural, identifier or "in"
19:33:25 <NotOlathe> @pl \ch xxs -> let (x, xs) = span (/= ch) xs in [x, f xs]
19:33:25 <lambdabot> (line 1, column 16):
19:33:25 <lambdabot> unexpected "("
19:33:25 <lambdabot> expecting natural, identifier or "in"
19:33:41 <NotOlathe> @pl \ch xxs -> let sp = span (/= ch) xs in [fst sp, f (snd sp)]
19:33:41 <lambdabot> const . liftM2 (:) fst (return . f . snd) . fix . const . flip span xs . (/=)
19:33:56 <gwern> > break (== ">>") (words "foo bar >> top baz quuz >> nick nack")
19:34:02 <dmwit> NotOlathe: Wortheless, there's no base case.
19:34:07 <lambdabot>  (["foo","bar"],[">>","top","baz","quuz",">>","nick","nack"])
19:34:16 <Brian`> how come span (>4) [3..6] gives ([], [3,4,5,6])? I was expecting something like ([3,4],[5,6])
19:34:24 <chessguy> dons++ nice advice on -cafe
19:34:30 <Brian`> since span (<4) [3..6] gives
19:34:36 <NotOlathe> > let wordsBy _ "" = ""; wordsBy ch xs = const . liftM2 (:) fst (return . wordsBy . snd) . fix . const . flip span xs . (/=) in wordsBy 't' "testing"
19:34:36 <lambdabot>  Couldn't match expected type `[Char] -> [Char]'
19:34:36 <Brian`> > span (<4) [3..6]
19:34:37 <lambdabot>  ([3],[4,5,6])
19:34:39 <NotOlathe> :(
19:34:41 <chessguy> if a little...brief
19:34:49 <NotOlathe> Oh.
19:34:51 <NotOlathe> Bah.
19:35:01 <dmwit> Brian`: It goes until the very first match.
19:35:14 <dmwit> Brian`: Or, rather, it goes unti the very first non-match.
19:35:27 <dmwit> Brian`: Since [3..6] begins with a non-match, it stops immediately.
19:35:30 <NotOlathe> > let wordsBy _ "" = ""; wordsBy ch xxs = let (x, xs) = span (/= ch) xxs in [x, f xs] in wordsBy 't' "testing"
19:35:31 <lambdabot>   Not in scope: `f'
19:35:36 <dmwit> > span (>4) [3..5]
19:35:36 <lambdabot>  ([],[3,4,5])
19:35:37 <NotOlathe> > let wordsBy _ "" = ""; wordsBy ch xxs = let (x, xs) = span (/= ch) xxs in [x, wordsBy xs] in wordsBy 't' "testing"
19:35:38 <Brian`> dmwit, aha i c
19:35:38 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
19:35:40 <dmwit> > span (<4) [3..5]
19:35:41 <lambdabot>  ([3],[4,5])
19:35:46 <dmwit> > break (>4) [3..5]
19:35:47 <lambdabot>  ([3,4],[5])
19:35:47 <NotOlathe> > let wordsBy _ "" = [""]; wordsBy ch xxs = let (x, xs) = span (/= ch) xxs in [x, wordsBy xs] in wordsBy 't' "testing"
19:35:48 <Brian`> span (>4) [5..9]
19:35:48 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
19:35:51 <Brian`> > span (>4) [5..9]
19:35:51 <lambdabot>  ([5,6,7,8,9],[])
19:36:01 <dons> chessguy: thanks
19:36:07 <NotOlathe> > let wordsBy _ "" = [""]; wordsBy ch xxs = let (x, xs) = span (/= ch) xxs in [[x], wordsBy xs] in wordsBy 't' "testing"
19:36:08 <dons> got to follow Conal's lead -- no IO!
19:36:08 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
19:36:13 <NotOlathe> Bah.
19:36:29 <chessguy> i'm not sure i get this though:
19:36:35 <chessguy>        events  <- map processInput <$> getContents
19:36:35 <chessguy>        mapM_ print (runGame events)
19:36:44 <Brian`> > span (>4) [6,5,4,3,2]
19:36:44 <lambdabot>  ([6,5],[4,3,2])
19:36:51 <NotOlathe> > let wordsBy _ "" = [""]; wordsBy ch xxs = let (x, xs) = span (/= ch) xxs in [x]:(wordsBy xs) in wordsBy 't' "testing"
19:36:51 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
19:36:54 <chessguy> wouldn't that try to pull all the events out of IO before processing any of them?
19:36:58 <NotOlathe> Yay, it switched !
19:37:03 <NotOlathe> > let wordsBy _ "" = [""]; wordsBy ch xxs = let (x, xs) = span (/= ch) xxs in [x]:(wordsBy ch xs) in wordsBy 't' "testing"
19:37:03 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
19:37:07 <NotOlathe> Stop that !
19:37:22 <Stinger_> is there an elegant way to split a list into lists of n elements
19:37:55 <dons> chessguy: that's a lazy stream, looks ok to me.
19:37:59 <chessguy> > map (:[]) [1..10] -- is this what you mean?
19:37:59 <lambdabot>  [[1],[2],[3],[4],[5],[6],[7],[8],[9],[10]]
19:38:10 <chessguy> dons, i'm sure it is ok, it's my brain that's not :)
19:38:32 <Stinger_> more like [1..10] -> [[1,2,3],[4,5,6],[7,8,9],[10]]
19:38:32 <dmwit> > let wordsBy c xs = let (b, e) = break (==c) xs in b : (if null e then [] else wordsBy c (tail e)) in wordsBy 't' "hey there"
19:38:33 <lambdabot>  ["hey ","here"]
19:38:33 <ddarius> We have another McBride.
19:38:48 <dons> > map (\c -> case c of 'l' -> LT ; 'r' -> GT ; _ -> EQ) "lrllrrlrq"
19:38:49 <lambdabot>  [LT,GT,LT,LT,GT,GT,LT,GT,EQ]
19:38:50 <NotOlathe> > let f _ [] = []; f n xs = (take n xs):f n (drop n xs) in f 3 [1..10]
19:38:51 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10]]
19:38:55 <chessguy> dons, let me try to re-formulate my question
19:39:18 <NotOlathe> @src splitAt
19:39:18 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
19:39:38 <chessguy> i read the above code as, essentially "get the events, and then map print over them"
19:39:41 <oerjan> > let chunks n = takeWhile (not . null) . unfoldr (Just . splitAt n) in chunks 3 [1..10]
19:39:41 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10]]
19:39:55 <oerjan> Stinger_: ^^
19:39:58 <ddarius> Is processInput supposed to only take a character?
19:40:01 <NotOlathe> Eww ! Just !
19:40:07 <dmwit> > let chunks n = takeWhile (not . null) . iterate (splitAt n) in chunks 3 [1..10]
19:40:07 <lambdabot>  Couldn't match expected type `[a]'
19:40:11 <chessguy> whereas the effect that it's meant to achieve is more like "get an event, process it, then repeat"
19:40:24 <Stinger_> hmm not too bad :)
19:40:34 <dons> there may be type errors in the code, yes :)
19:40:36 <dmwit> oh, duh
19:40:36 <NotOlathe> > let chunks n = iterate (drop n) in [1..10]
19:40:38 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
19:40:49 <NotOlathe> > let chunks n = iterate (drop n) in chunks 3 [1..10]
19:40:50 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10],[4,5,6,7,8,9,10],[7,8,9,10],[10],[],[],[],[],[],[],[...
19:41:00 <dons> mapM_ print . runGame . process =< getContents
19:41:07 <NotOlathe> > let chunks n = map (take n) . iterate (drop n) in chunks 3 [1..10]
19:41:09 <dmwit> > let chunks n = takeWhile (not . null) . map (take n) . iterate (drop n) in chunks 3 [1..10]
19:41:10 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[...
19:41:10 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10]]
19:41:21 <ddarius> Let's just decide on the nicest chunks implementation and then @remember it.
19:41:22 <chessguy> @type mapM_ print . runGame . process =< getContents
19:41:25 <lambdabot>     precedence parsing error
19:41:25 <lambdabot>         cannot mix `(.)' [infixr 9] and `(=<)' [infixl 9] in the same infix expression
19:41:25 <lambdabot> Not in scope: `runGame'
19:41:26 <dons> was roughly my idea. and runGame = evalState (mapM game es) initState
19:41:48 <chessguy> @type mapM_ print . runGame . process =<< getContents
19:41:49 <lambdabot> Not in scope: `runGame'
19:41:49 <lambdabot> Not in scope: `process'
19:41:56 <gwern> I am having trouble defining this function: split match string = ....; > split
19:42:02 <chessguy> @type mapM_ print . ?runGame . ?process =<< getContents
19:42:03 <lambdabot> (?runGame::b -> [Integer], ?process::String -> b) => IO ()
19:42:07 <dons> the original post had io pushed all the way down into the code
19:42:13 <dons> hence it was ugly. along with state passing
19:42:19 <dmwit> > let chunks n = map snd . groupBy (\x y -> x `div` n == y `div` n) . zip [0..] in chunks 3 [1..10]
19:42:19 <lambdabot>  Couldn't match expected type `(a, b)'
19:42:22 <gwern> " >> " "foo bar >> top top >> quuz" -> ["foo bar", "top top", "quuz"
19:42:23 <dons> interesting defaulting there
19:42:26 <chessguy> dons, oh i agree. i'm trying to wrap my head around your solution
19:42:30 <NotOlathe> > let wordsBy n = iterate (dropWhile (/= n)) in wordsBy 't' "testing"
19:42:30 <lambdabot>  ["testing","testing","testing","testing","testing","testing","testing","test...
19:42:38 <dmwit> > let chunks n = map snd . groupBy (\x y -> fst x `div` n == fst y `div` n) . zip [0..] in chunks 3 [1..10]
19:42:38 <lambdabot>  Couldn't match expected type `(a, b)'
19:42:50 <NotOlathe> > let wordsBy n = iterate (drop 1 . dropWhile (/= n)) in wordsBy 't' "testing"
19:42:50 <lambdabot>  ["testing","esting","ing","","","","","","","","","","","","","","","","",""...
19:43:02 <dons> chessguy: so you get a lazy stream of input events (a pure list), then run the game on that stream, yielding in turn a stream of boards to draw
19:43:03 <dmwit> :t groupBy
19:43:04 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
19:43:07 <oerjan> dmwit: clearly you want ((==) `on` (`div` n))
19:43:11 <dmwit> yes
19:43:13 <dons> that's the yi main loop, btw.
19:43:16 <NotOlathe> > let wordsBy n = map (takeWhile (/= n)) . iterate (drop 1 . dropWhile (/= n)) in wordsBy 't' "testing"
19:43:16 <lambdabot>  ["","es","ing","","","","","","","","","","","","","","","","","","","","","...
19:43:24 <oerjan> um, and fst
19:43:39 <chessguy> dons, how does it know that it's an infinite list though?
19:43:48 <NotOlathe> > let wordsBy n = map (takeWhile (/= n)) . takeWhile (not . null) . iterate (drop 1 . dropWhile (/= n)) in wordsBy 't' "testing"
19:43:49 <lambdabot>  ["","es","ing"]
19:43:55 <dons> lazy, not infinite
19:44:03 <NotOlathe> > let wordsBy n = map (takeWhile (/= n)) . takeWhile (not . null) . iterate (drop 1 . dropWhile (/= n)) in wordsBy ',' "1,2,3,4,5"
19:44:03 <lambdabot>  ["1","2","3","4","5"]
19:44:14 <chessguy> dons, but it would have to be infinite, wouldn't it?
19:44:22 <chessguy> at least in theory
19:44:34 <Brian``> :t iterate
19:44:34 <lambdabot> forall a. (a -> a) -> a -> [a]
19:44:36 <ddarius> chessguy: Why?
19:44:43 <dons> "But applications are getting more complex, and eventually even ?simple? programs will nned multiple
19:44:46 <dmwit> > let chunks n = map (map snd) . groupBy (\x y -> fst x `div` n == fst y `div` n) . zip [0..] in chunks 3 [1..10]
19:44:47 <dons> threads. Does that mean developers will suddenly flock to Haskell? Again, no. Language designers are
19:44:47 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10]]
19:44:49 <dons> well aware of the situation. Sun and Microsoft are constantly working on improving the Java and .NET
19:44:52 <dons> frameworks. And by the time the average programmer needs it, both will have plenty of support for
19:44:53 <NotOlathe> @pl \n -> map (takeWhile (/= n)) . takeWhile (not . null) . iterate (drop 1 . dropWhile (/= n))
19:44:53 <lambdabot> ap ((.) . map . takeWhile . (/=)) ((takeWhile (not . null) .) . iterate . (drop 1 .) . dropWhile . (/=))
19:44:56 <dons> easy threading"
19:45:14 <dons> chessguy: just unfold the game on the list, stopping on a Quit event
19:45:31 <ddarius> They'll pretty much look like Haskell with C-syntax by then anyway, or at least C# will.
19:45:34 <dons> its really just a while loop as a data structure
19:45:57 <chessguy> @type exitWith
19:45:58 <lambdabot> Not in scope: `exitWith'
19:45:58 <gwern> let wordsBy n = map (takeWhile (/= n)) . takeWhile (not . null) . iterate (drop 1 . dropWhile (/= n)) in wordsBy ">>" $ words "foo bar >> foo bar"
19:46:04 * dons claims the simple programs need threads"
19:46:05 <chessguy> @hoogle exitWith
19:46:06 <gwern> > let wordsBy n = map (takeWhile (/= n)) . takeWhile (not . null) . iterate (drop 1 . dropWhile (/= n)) in wordsBy ">>" $ words "foo bar >> foo bar"
19:46:08 <lambdabot> System.exitWith :: ExitCode -> IO a
19:46:11 <dons> par fibonacci now!
19:46:16 <lambdabot>  [["foo","bar"],["foo","bar"]]
19:46:26 <gwern> hm. almost there.
19:46:35 <gwern> > let wordsBy n = map (takeWhile (/= n)) . takeWhile (not . null) . iterate (drop 1 . dropWhile (/= n)) in map concat $ wordsBy ">>" $ words "foo bar >> foo bar"
19:46:35 <lambdabot>  ["foobar","foobar"]
19:46:42 <Pseudonym> http://wadler.blogspot.com/2007/12/lambdacats.html <- I felt compelled to comment.
19:46:44 <lambdabot> Title: Wadler's Blog: Lambdacats
19:46:52 <gwern> > let wordsBy n = map (takeWhile (/= n)) . takeWhile (not . null) . iterate (drop 1 . dropWhile (/= n)) in map concat $ wordsBy ">>" $ words "foo bar >> foo bar >> top -waste space and son on; >> end"
19:46:52 * ddarius needs his shell scripts to scale to multi-core distributed computing clusters.
19:46:52 <lambdabot>  ["foobar","foobar","top-wastespaceandsonon;","end"]
19:46:55 * sorear wants to see C with Haskell syntax
19:46:58 <NotOlathe> How does wordsBy handle strings ?
19:47:02 <chessguy> Pseudonym, i noticed that post today too
19:47:08 <gwern> wait, I guess I want unwords then
19:47:22 <gwern> > let wordsBy n = map (takeWhile (/= n)) . takeWhile (not . null) . iterate (drop 1 . dropWhile (/= n)) in map unwords $ wordsBy ">>" $ words "foo bar >> foo bar >> top -waste space and son on; >> end"
19:47:23 <lambdabot>  ["foo bar","foo bar","top -waste space and son on;","end"]
19:47:38 <NotOlathe> > let wordsBy n = map (takeWhile (/= n)) . takeWhile (not . null) . iterate (drop 1 . dropWhile (/= n)) in wordsBy ",," "1,,2,3,4,5"
19:47:39 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
19:47:40 * chessguy decides to actually type-check dons' code :)
19:47:54 <sjanssen> sorear: do you mean Foreign.* stuff, or actual C semantics?
19:48:06 <gwern> Pseudonym: hah, I like that! too bad they turned it down
19:48:08 <dons> chessguy: i'm sure there are type errors. but the concept is sound.
19:48:13 <gwern> the more lambda cats the better
19:48:26 <chessguy> dons, coming from you, i'm sure it is. that's why i'm trying to understand it
19:48:42 <sorear> sjanssen: I meant like actual C semantics.
19:48:49 <sjanssen> ddarius: that isn't so outlandish, I had an interesting experience lately writing a parallel fgrep
19:49:06 * sjanssen wants to grep years of #haskell logs with maximum speed
19:50:06 <glguy> sjanssen: fgrep :)
19:50:18 <sjanssen> glguy: my program is faster than fgrep
19:50:27 <NotOlathe> @src lift
19:50:27 <lambdabot> Source not found. That's something I cannot allow to happen.
19:50:27 <glguy> nowai
19:50:29 <sjanssen> even in the single threaded case
19:50:45 <sjanssen> glguy: faster for this one particular use case
19:50:50 <oerjan> @src MonadTrans
19:50:50 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
19:51:05 <oerjan> NotOlathe: lift is the method of MonadTrans
19:51:17 <chessguy> @index (<$>)
19:51:17 <lambdabot> bzzt
19:51:24 <chessguy> @hoogle (<$>)
19:51:25 <lambdabot> Did you mean: (<$>)
19:51:25 <lambdabot> Prelude.undefined :: a
19:51:25 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
19:51:34 <dons> sjanssen: is it a WideFinder? :)
19:51:40 <ddarius> Control.Applicative
19:51:54 <sjanssen> dons: not sure, I didn't pay much attention to that
19:52:02 <dons> yeah, sorry, should probably not have put that in, but its so addictive, <$>
19:52:12 * dons likes sugar
19:52:17 <ddarius> dons: You have to get them when they're young
19:52:23 <chessguy> @hoogle getContents
19:52:23 <lambdabot> Prelude.getContents :: IO String
19:52:23 <lambdabot> IO.hGetContents :: Handle -> IO String
19:52:26 <oerjan> chessguy: hoogle has a bug with $ and *
19:52:28 <dons> ddarius: i like your attitude :)
19:52:44 <dons> we can set the new idioms now :)
19:52:49 <Brian``> is there a probability library in haskell?
19:52:57 <oerjan> @src <$>
19:52:57 <lambdabot> f <$> a = fmap f a
19:52:58 <ddarius> @where hackage
19:52:58 <lambdabot> http://hackage.haskell.org/
19:52:58 <chessguy> @where pfp
19:52:58 <lambdabot> I know nothing about pfp.
19:52:59 <dons> Brian``: i think there's one or two on hackage
19:53:00 <ddarius> Go nuts.
19:53:13 * chessguy breaks out the cashews
19:53:34 <chessguy> getContents returns a string?
19:53:44 <dons> :t getContents
19:53:44 <glguy> in IO
19:53:44 <lambdabot> IO String
19:53:44 <ddarius> :t getContents
19:53:45 <lambdabot> IO String
19:53:55 <dons> IO! String!
19:53:55 <chessguy> ok, now i'm really lost
19:54:10 <sorear> chessguy: it returns all of stdin as a single string
19:54:10 <dons> well, what's a dead simple game we could play like this?
19:54:11 <chessguy> <$> is fmap is liftM, yes?
19:54:15 <sorear> chessguy: read until EOF
19:54:16 <dons> tic-tac-toe?
19:54:17 <sorear> chessguy: yes
19:54:23 <oerjan> :t Data.ByteString.getContents
19:54:24 <lambdabot> IO Data.ByteString.Base.ByteString
19:54:50 <dons> try writing a little tic tac toe game purely
19:54:52 <ddarius> chessguy: Yes, by his code, processInput (or whatever) has type Char -> ...
19:55:24 <ddarius> dons: That's almost too trivial.
19:55:41 <Saizan> ?type interact
19:55:41 <lambdabot> (String -> String) -> IO ()
19:56:03 <Stinger_> chunks n xs = uncurry (fix (\f a b c -> case a of {[] -> c ; x -> uncurry f (splitAt n b) (c ++ [a])})) (splitAt n xs) []
19:56:17 <Stinger_> theres my attempt to make it smaller which didnt work heh
19:56:49 <Saizan> is the interact approach really usable? didn't monads were invented to avoid stream based IO?
19:58:06 <glguy> > let chunks _ [] = []; chunks n xs = let { (a,b) = splitAt n xs in a : chunks n b } in chunks 3 [1..10]
19:58:06 <lambdabot>  Parse error at "in" (column 64)
19:58:09 <glguy> :(
19:58:26 <glguy> > let chunks _ [] = []; chunks n xs = (let (a,b) = splitAt n xs in a : chunks n b) in chunks 3 [1..10]
19:58:27 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10]]
19:59:09 <dmwit> > let chunk = do { x <- uncurry take; y <- chunk . (fst &&& uncurry drop); return (takeWhile (not . null) (x:y)) } in curry chunk 3 [1..10] -- obfuscation FTW!
19:59:09 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10]]
19:59:13 <Stinger_> theres gotta be some iterating primative we can use
19:59:15 <oerjan> Saizan: i guess ironically interact is best for programs that are _not_ really interactive :)
19:59:15 <ajk249> How does one extract a value from an IO monad in this context:[processSubject x trans | x <- [1..num]]
19:59:32 <chessguy> @hoogle exitWith
19:59:32 <lambdabot> System.exitWith :: ExitCode -> IO a
19:59:39 <glguy> ajk249: sequence?
19:59:46 <Saizan> oerjan: that's roughly my point :)
19:59:56 <oerjan> Saizan: also, the stream based I/O was far more complicated than interact
20:00:03 <ajk249> glguy: that may be it
20:00:41 <ajk249> the processSubject function returns IO CSV, and I want to extract the CSV to construct a list of CSV
20:00:53 <chessguy> hmm, newtype Game a = Game (StateT World IO) a gives this error: `StateT World IO' is not applied to enough type arguments
20:00:56 <Saizan> oerjan: yup, it wasn't only fot stdin/stdout
20:01:13 <Saizan> chessguy: use the 'a' :)
20:01:33 <chessguy> Saizan, huh?
20:01:37 <Saizan> ah, inside the parens.
20:01:53 <chessguy> ah
20:02:06 <Saizan> it has to be the last argument for StateT
20:02:07 <glguy> :t sequence
20:02:17 <oerjan> Saizan: but interact is really nice for those things that _are_ just stdin -> stdout pipes
20:02:22 <lambdabot> thread killed
20:02:50 <chessguy> yeah, got it
20:03:05 <hpaste>  gwern pasted "Monad confuzzledness" at http://hpaste.org/4250
20:03:13 <Saizan> oerjan: but a game doesn't seem like one of those
20:03:31 <gwern> I could swear I'm lifting it right, but the compiler doesn't agree
20:03:37 <oerjan> Saizan: indeed
20:03:57 <hpaste>  sjanssen pasted "parallel hsgrep (just a quick hack)" at http://hpaste.org/4251
20:04:52 <Saizan> gwern: liftM = map there
20:05:08 <Saizan> gwern: since x :: [Char]
20:05:21 <sjanssen> boo on liftM!
20:05:29 <chessguy> @hoogle evalStateT
20:05:30 <lambdabot> Control.Monad.State.evalStateT :: Monad m => StateT s m a -> s -> m a
20:05:43 <Saizan> ?type liftM ?f (undefined :: [Char])
20:05:44 <lambdabot> forall r. (?f::Char -> r) => [r]
20:06:09 <oerjan> gwern: let foo = spl x perhaps
20:06:30 <faxathisia> hi
20:06:31 <gwern> oerjan: that does work
20:07:05 <oerjan> gwern: x is not really monadic in spirit here, although accidentally both it and the monad actions are lists here
20:07:34 <oerjan> er, wait no
20:07:49 <Brian`> internet outage...
20:07:56 <oerjan> rather, x being a list confuses the compiler as to which monad that do expression is
20:08:15 <chessguy> @type exitWith ExitSuccess
20:08:16 <gwern> oh, the list as monad thing?
20:08:16 <lambdabot> Not in scope: `exitWith'
20:08:16 <lambdabot> Not in scope: data constructor `ExitSuccess'
20:08:23 <oerjan> yep
20:08:32 <gwern> one of these days I'll figure that out
20:08:43 <chessguy> @type System.exitWith System.ExitSuccess
20:08:44 <lambdabot> forall a. IO a
20:09:00 <faxathisia> is haskell a lot like SQL
20:09:04 <chessguy> @type liftIO
20:09:05 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
20:09:08 <faxathisia> or am I just hallucinating
20:09:19 <Saizan> SQL?
20:09:27 <faxathisia> I just tried out SQL a bit
20:09:39 <oerjan> faxathisia: SQL is a monad probably :)
20:09:39 <faxathisia> seems a lot like Haskell
20:09:45 <faxathisia> hehe
20:09:46 <chessguy> @hoogle IO a -> StateT s IO a
20:09:46 <lambdabot> No matches, try a more general search
20:09:54 <monochrom> everything is somewhat like everything else
20:09:55 <chessguy> @hoogle IO a -> m s IO a
20:09:56 <lambdabot> Foreign.unsafePerformIO :: IO a -> a
20:10:16 <faxathisia> monochrom Not really
20:10:25 <chessguy> how do i turn an IO a into a StateT MyState IO a
20:10:26 <Saizan> monochrom: "approximately equal"?:)
20:10:31 <Brian`> what kind of theorem can a haskell theorem prover prove?
20:10:34 <monochrom> yeah! :)
20:10:35 <Saizan> chessguy: lift
20:10:37 <chessguy> @type lift
20:10:38 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
20:10:41 <faxathisia> Brian`: lol
20:10:43 <chessguy> ah
20:11:16 <monochrom> what a theorem prover can do depends on the algorithms used.
20:11:18 <faxathisia> Brian`: about as much wood a wood chucker would chuck if a wood chucker could chuck wood
20:11:19 <Saizan> chessguy: or more/less generically liftIO
20:11:42 <faxathisia> which theorem prover?
20:11:48 <glguy> sjanssen: What is Control.Concurrent.Pool?
20:11:55 <faxathisia> (how long is a piece of string?)
20:12:04 <sjanssen> glguy: a micro-library I'm toying with
20:12:05 <oerjan> faxathisia: 5 Chars
20:12:12 <Brian`> faxathisia, lol yeah it sounds like hehe
20:12:16 <chessguy> ugh
20:12:26 <faxathisia> Brian`: Are you looking at a specific theorem prover?
20:12:43 <sieni> faxathisia: do you mean a woodchuck?
20:12:48 <chessguy> there's something wrong with "game Quit   =  exitWith ExitSuccess", but i don't know how to fix it
20:12:54 <faxathisia> sieni: probably, it doesn't really matter
20:12:57 <hpaste>  sjanssen annotated "parallel hsgrep (just a quick hack)" with "Control.Concurrent.Pool" at http://hpaste.org/4251#a1
20:13:17 <Brian`> faxathisia, not really.. i just wondered what's an example for theorem proving work..
20:13:17 <oerjan> chessguy: is game in IO ?
20:13:20 <gwern> yay, my little interactive thing can now successfully evaluate '1+1 >> 5*5 >> take 100 [1..]'
20:13:38 <chessguy> newtype Game a = Game (StateT World IO a)
20:13:42 <chessguy> (from dons' code)
20:13:45 <faxathisia> Brian`: That didn't make any sense
20:13:45 <oerjan> chessguy: liftIO should help
20:13:46 <sorear> @djinn Either (Not a) (Not b) -> Not (a,b)
20:13:51 <sorear> Brian`: ^^^
20:13:51 <lambdabot> f a =
20:13:51 <lambdabot>     case a of
20:13:51 <lambdabot>     Left b -> \ (c, _) -> b c
20:13:51 <lambdabot>     Right d -> \ (_, e) -> d e
20:13:53 <oerjan> or wait
20:14:16 <oerjan> chessguy: you may add deriving MonadIO to Game, then use liftIO
20:14:17 <chessguy> oerjan, doesn't seem to
20:14:29 <Saizan> chessguy: you should add 'deriving (MonadIO,MonadState World), or write your specific primitives
20:14:31 <monochrom> Brian`: try out http://www.umsu.de/logik/trees/  not written in haskell, and only good for basic FOL, without equality, without axiom schema, but very effective in practice. written in javascript (in fact runs on your computer)
20:14:32 <lambdabot> Title: Tree Proof Generator
20:14:36 <Brian`> faxathisia, sorry for my poor grammar :)
20:14:46 <ajk249> :glguy sequence is exactly what I needed. Thank you very much.
20:15:41 <monochrom> (The algorithm it uses for proving is straightforward "tableau search".)
20:15:48 <oerjan> chessguy: the newtype hides the operations for the wrapped value, but newtype deriving can pull them through
20:16:01 <Brian`> monochrom, what does that mean? looking up a table or something?
20:16:03 <monochrom> (The algorithm it uses for disproving is straightforward "try all finite models from small to large".)
20:17:02 <Brian`> monochrom, how are these propositional logic used in real application?
20:17:02 <monochrom> A tableau is a proof by contradiction. Suppose the given statement is false. This is written as "not statement" at the top.
20:17:29 <monochrom> Then various conclusions can be drawn. These conclusions are added to the below, vertically.
20:17:32 <Brian`> I remember taking a logic course in my first year and I thought it was useles... but since I see many people researching in that area I'm kinda interested :)
20:18:20 <monochrom> At various points, you also have to consider cases. E.g., if a certain conclusion says "x or y", then you have to consider two cases: x, y. These are added horizontally, as branches.
20:18:55 <SideFFect> can anyone help me with an assignment? our teacher wants us to complete a mutable tree definition :(
20:18:56 <monochrom> The goal is to reach contradictions on all branches, by seeing both "blah" and "not blah" on the same path.
20:18:58 <SideFFect> using atomic
20:19:02 <SideFFect> and im beyond confused
20:19:04 <Brian`> monochrom, i c... yeah i kinda remember doing that in logic course hehe
20:19:12 <faxathisia> why are you confused SideFFect ?
20:19:21 <SideFFect> because I have NO idea what he wants
20:19:25 <chessguy> @type mapM
20:19:26 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
20:19:31 <SideFFect> I get the do and tvar etc, but his assignments...ugh
20:19:35 <SideFFect> i'll paste it one sec
20:19:39 <faxathisia> SideFFect: Do you think it might be a good idea to fail the class to show your teacher he's incapable of teaching?
20:19:54 <SideFFect> lol it wont benefit me no :P
20:20:14 <gwern> @where hGetStr
20:20:14 <lambdabot> I know nothing about hgetstr.
20:20:20 <faxathisia> SideFFect: maybe you should tell him directly then
20:20:28 <monochrom> So this algorithm just tries to build a tableau. There are false turns encountered sometimes; it has to backtrack if it gets stuck, or if some branch seems to grow forever.
20:20:29 <Saizan> SideFFect: still with that vapourware of a language?
20:20:33 <gwern> @where hPutStr
20:20:34 <lambdabot> I know nothing about hputstr.
20:20:42 <SideFFect> he wont listen, he thinks hes right and its simple
20:20:53 <faxathisia> SideFFect: Then go with approach 1
20:21:09 <hpaste>  sideffect pasted "haskell++help" at http://hpaste.org/4252
20:21:09 <monochrom> Logic is always useful. Even more useful than numbers.
20:21:24 <faxathisia> monochrom: How do you detect if a branch might go on forever?
20:21:25 <SideFFect> heh no all that will show is im an idiot :P
20:21:25 <gwern> @location hPutStr
20:21:25 <lambdabot> Unknown command, try @list
20:21:30 <gwern> @locate hPutStr
20:21:31 <lambdabot> Unknown command, try @list
20:21:35 <dons> tiobe index Dec, http://www.tiobe.com/tpci.htm haskell stays at #34, ocaml drops out of top 50, erlang at #40
20:21:36 <lambdabot> Title: TPCI - TIOBE Programming Community Index
20:21:36 <monochrom> Precisely because it's too useful, everyone thinks he/she already knows it, and so thinks a course on logic is completely dumb.
20:21:47 <gwern> gah. where are the h* line IO functions?
20:22:03 <oerjan> :t hGetLine
20:22:04 <lambdabot> Not in scope: `hGetLine'
20:22:21 <SideFFect> I pasted the assign tho
20:22:22 <oerjan> :t System.IO.hGetLine
20:22:23 <lambdabot> GHC.IOBase.Handle -> IO String
20:22:37 <monochrom> We never know for sure whether a branch will go on forever. (Undecidable problem.) We dumbly say: after it becomes 10 units long, let's abort and try something else.
20:22:40 <oerjan> gwern: er, the command is @index
20:22:53 <oerjan> or @hoogle
20:23:09 <faxathisia> ok
20:23:20 <glguy> dons: D is a major programming language?
20:23:20 <monochrom> It is also possible: something else is tried and you also abort them. Then you say, ok, go back to the original attempt, now let it grow to 20 units long and see.
20:23:35 <faxathisia> iterative deepening ?
20:23:37 <dons> "It is interesting to see that the large programming languages are losing ground percentage wise"
20:23:39 <monochrom> YES!
20:24:01 <dons> FP langs rose +1.1%
20:24:32 <toad_> @hoogle <$>
20:24:32 <lambdabot> No matches found
20:24:43 <scook0> toad_: (<$>) = fmap
20:24:43 <monochrom> D minor is a favourite key of mine. As is C# minor. C# major is just evil.
20:24:49 <scook0> @hoogle fmap
20:24:49 <lambdabot> Prelude.fmap :: Functor f => (a -> b) -> f a -> f b
20:24:49 <lambdabot> Data.FunctorM.fmapM :: (FunctorM f, Monad m) => (a -> m b) -> f a -> m (f b)
20:24:49 <lambdabot> Data.FunctorM.fmapM_ :: (FunctorM f, Monad m) => (a -> m b) -> f a -> m ()
20:24:58 <toad_> no offense, but haskell needs to lose some operators
20:24:58 <chessguy> hmm, there's something broken with runGame es = evalState (mapM game es) 0
20:25:08 <dons> toad_: they're library functions
20:25:09 <toad_> but thanks
20:25:32 <monochrom> Examples. Mozart's PC20 and Brahms's PC1 are in D minor. Beethoven's Moonlight and Mahler's 5th are in C# minor. I love them very much.
20:26:26 <faxathisia> @src Functor
20:26:26 <lambdabot> class  Functor f  where
20:26:26 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
20:26:31 <faxathisia> wtf
20:26:46 <faxathisia> @instances Functor
20:26:47 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
20:26:52 <monochrom> well tempered functor? :)
20:26:55 <Saizan> chessguy: you've to unpack the Game constructor and use evalStateT
20:27:15 <faxathisia> > fmap (+2) [1,2,3]
20:27:16 <lambdabot>  [3,4,5]
20:27:40 <faxathisia> @src fmap
20:27:40 <lambdabot> Source not found. Just what do you think you're doing Dave?
20:27:47 <chessguy> i suspected it was something with evalStateT. but i'm not sure what you mean by 'unpack the Game constructor', Saizan
20:27:53 <faxathisia> you can write fmap in terms of monad operations?
20:27:56 <dons> i wonder how jdh feels about ocaml /and/ F# being out of the top 50 now
20:29:05 <Saizan> faxathisia: well Functor is more general than Monad, but if you've a monad fmap = liftM
20:29:16 <Saizan> ?src liftM
20:29:16 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
20:29:28 <faxathisia> hcool
20:29:48 <chessguy> Saizan, i need liftM game?
20:29:53 <ddarius> dons: Probably feels like he needs to up his efforts then.
20:30:10 <gwern> dons: you've really taken a shine against harrop haven't you...
20:30:21 <ddarius> Clearly he should be having a Java v. F# campaign
20:30:30 <ddarius> (or rather should liven it up more)
20:31:08 <Saizan> chessguy: no
20:31:30 * faxathisia wonders what to write in haskell....
20:31:35 <oerjan> chessguy: Game is a newtype.  whenever you want to use a function defined on the internal StateT you need to unwrap the Game constructor.
20:32:39 <dons> gwern: i pity the fool ;)
20:32:43 <oerjan> exception, class methods, for which you can use newtype deriving
20:32:55 <scook0> something like evalGame (Game x) = evalStateT x
20:33:34 <chessguy> ...
20:33:37 <chessguy> i'm so lost
20:33:58 <chessguy> so i need to liftM evalStateT, right?
20:34:06 <chessguy> to unwrap Game?
20:34:31 <Saizan> btw, what's the type of game?
20:34:41 <oerjan> chessguy: no one has mentioned liftM in your context
20:34:42 <gwern> @index join
20:34:43 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
20:34:48 <chessguy> newtype Game a = Game (StateT World IO a)
20:35:16 <SideFFect> did anyone understand what my teacher wants?
20:35:19 <chessguy> oh, Saizan switched contexts on me :)
20:35:21 <Saizan> chessguy: no, the "game" in your runGame
20:35:28 <chessguy> no wonder i was so confused
20:35:37 <chessguy> game :: Event -> Game Action
20:36:23 <toad_> he's describing a post from haskell-cafe
20:36:31 <Stinger_> chunks2 n = takeWhile (not . null) . map (take n) . iterate (drop n)
20:36:32 <Saizan> well, if you're using the stream of events approach your monad shouldn't contain IO..
20:36:42 <oerjan> chessguy: try runGame es = evalState (mapM s es) 0 where Game s = game
20:36:48 <Stinger_> ^ did someone already say something like that?
20:36:53 <chessguy> let me paste code so we're all talking about the same thing
20:37:15 <ddarius> But it's so much funner when we are all talking about different things.
20:37:37 <hpaste>  chessguy pasted "got dons' code almost working" at http://hpaste.org/4253
20:37:49 <chessguy> well, almost type-checking
20:38:16 <ddarius> chessguy: Are you trying to get some sketchy incomplete pseudo code working?
20:38:17 <Stinger_> hmm yes someone did something rather similar
20:38:18 <oerjan> chessguy: oh, Event -> Game Action? i assumed Game (Event -> Action).  a moment
20:38:31 <chessguy> ddarius, yes
20:38:34 <wli> What's this code do?
20:38:37 <chessguy> ddarius, for studying purposes
20:38:45 <oerjan> chessguy: runGame es = evalState s 0 where Game s = mapM game es
20:38:48 <ddarius> wli: Nothing!
20:39:38 <wli> Some kind of artificial terrain traversal?
20:39:41 <Saizan> oerjan: "T"
20:39:50 <oerjan> Saizan: huh?
20:39:58 <oerjan> the lisp kind?
20:40:06 <Saizan> evalStateT
20:40:36 <oerjan> Saizan: oh, chessguy didn't have T in what he commented
20:40:46 <chessguy> yeah, it needs the T
20:40:58 <Saizan> and.. runGame can't be pure if game uses exitWith!
20:41:11 <chessguy> still not working though
20:41:13 <Saizan> and Game has IO inside
20:41:20 <oerjan> chessguy: is Game deriving Monad ?
20:41:29 <chessguy> yes
20:41:37 <Saizan> chessguy: you're mixing two different proposals i think.
20:41:43 <hpaste>  gwern pasted "a haskell shell" at http://hpaste.org/4254
20:42:15 <dons> pseudo code is a big puzzle of fun!
20:42:15 <gwern> thus far, I've got it to the point where you can go '!1+1' and be answered with '2', and you can type in, say, 'nano Main.hs' and it works
20:42:25 <dons> "finish this thought ..."
20:43:08 <oerjan> chessguy: i think you need runGame :: [Event] -> IO [(Board,Action)]
20:43:21 <gwern> the big problem is that I need a real parser, I think, but I really don't understand parsec. it'
20:43:22 <sorear> ?quote pseuso
20:43:23 <lambdabot> No quotes match. You type like i drive.
20:43:24 <sorear> ?quote pseudo
20:43:24 <gwern> s awfully complex
20:43:24 <lambdabot> mwc says: I actually got away with running Haskell through a TeX pretty printer and handing it in as pseudocode
20:43:31 <oerjan> or wait
20:43:32 <faxathisia> gwern: parsec rules!
20:43:34 <sorear> ?quote haskell.pseudo
20:43:34 <lambdabot> No quotes match. The more you drive -- the dumber you get.
20:43:36 <oerjan> :t evalStateT
20:43:38 <lambdabot> forall s (m :: * -> *) a. (Monad m) => StateT s m a -> s -> m a
20:43:40 <gwern> faxathisia: it hurts my brain!
20:43:41 <faxathisia> It's very easy to use
20:44:08 <oerjan> chessguy: runGame :: [Event] -> IO [Action]
20:44:17 <wli> chessguy: What's this game?
20:44:21 <gwern> faxathisia: if you have a phd, maybe. this is the first time I've tried to do anything but ad hoc parsing, and I was utterly baffled by its documentation. I spent a few hours at it and have nothing to show for't
20:44:25 <oerjan> evalStateT throws away the Board
20:44:31 <faxathisia> haha
20:44:33 <faxathisia> I don't have a PHD
20:44:34 <faxathisia> :p
20:44:38 <Smirnov> hey guys , in eager evaluation are you supposed to reduce the rator or the rand first?
20:44:43 <faxathisia> What are you parsing? maybe I can help
20:44:51 <ddarius> Smirnov: Yes.
20:44:53 <faxathisia> I used parsec a few times for programming languages
20:45:01 <Smirnov> ddarius: yes? that wassnt a yes/no question
20:45:10 <ddarius> Smirnov: I realize.
20:45:23 <Smirnov> ddarius: then how can you say yes to it
20:45:31 <gwern> faxathisia: an unholy admixture of sh and haskell
20:45:39 <gwern> a true confusion, if you will
20:45:45 <faxathisia> uh...
20:45:51 <oerjan> Smirnov: what's rator and rand?  i don't remember those terms
20:45:56 <faxathisia> Maybe you should write out the language
20:46:07 <gwern> faxathisia: it was moot, though, as I couldn't even get the example Haskell parsing to work, so...
20:46:09 <faxathisia> like just describe it in a concise and unambigous way in text
20:46:17 <Smirnov> oerjan: f x. f is the rator, x is the rand
20:46:18 <faxathisia> then making a parser for it will be a lot easier
20:46:20 <ddarius> Smirnov: Because there is no correct answer.
20:46:21 <wli> I very strongly prefer LR parsing.
20:46:24 <chessguy> oerjan, if i comment out the body of runGame, but leave the type as [Event] -> [(Action, Board], it type-checks
20:46:26 <Smirnov> ddarius: hows that
20:46:33 <oerjan> Smirnov: x first
20:46:36 <gwern> sh doesn't have a concise and unambigous text :)
20:46:43 <oerjan> or wait...
20:46:46 <Smirnov> oerjan: ok, so... f x y, reduce y first?
20:46:48 <oerjan> Smirnov: er no.
20:46:49 <wli> Table-driven parsing etc. I guess.
20:47:03 <oerjan> Smirnov: you evaluate _both_, and eager says nothing about that order
20:47:08 <gwern> seriously, if you could just get rid of the name restrictions and the whole IO type, haskell itself would be a good sh
20:47:14 <wli> I'm not sure what this game is supposed to be.
20:47:54 <oerjan> Smirnov: eager only means x is evaluated before the whole
20:48:07 <ddarius> Smirnov: You can reduce either first.  Eagerness simply says that in (\x.M) E you will reduce E before beta-reducing the whole expression.
20:48:09 <Smirnov> oerjan: hmm, there's no canonical evaluation strategy that reduces y before x?
20:48:39 <ddarius> There's no canonical evaluation strategy period.
20:48:44 <Smirnov> ddarius: yes but in the case of (\x. M) E E' ?
20:49:40 <ddarius> Smirnov: This is just the same question again with F = (\x.M) E and X = E', you can evaluate either first.
20:49:54 <hpaste>  oerjan annotated "got dons' code almost working" with "try this" at http://hpaste.org/4253#a1
20:50:16 <chessguy> oerjan, that type signature is wrong
20:50:30 <chessguy> i mean, that's not what the function needs to be
20:50:33 <oerjan> chessguy: are you sure?
20:50:48 <Smirnov> ddarius: but surely you shouldnt evaluate (\x. M) reduced(E) until E' is also reduced
20:51:02 <ddarius> Smirnov: Why not?
20:51:14 <oerjan> chessguy: game :: Event -> Game Action does not leave any Board
20:51:22 <chessguy> like i said, if i comment out the function, but leave the type signature as [Event] -> [(Board, Action)], it type checks
20:51:37 <Smirnov> ddarius: how peculiar..
20:51:39 <loupgaroublond> 'lo
20:52:00 <Smirnov> ddarius: so that restriction you just listed is the ONLY restriction in eager evaluation?
20:52:07 <oerjan> chessguy: is what you pasted everything?
20:52:13 <Smirnov> that seems kind of lenien
20:52:14 <chessguy> yes
20:52:22 <oerjan> because i think it will typecheck with my type as well?
20:52:32 <loupgaroublond> how do i refer to a monad generically, that is, how do i type a function that takes a string and just runs return on it (yeah, i know it's silly, but i'm trying to break a few pieces down to make them more pedantic)
20:52:51 <loupgaroublond> so the result is something like String -> Monad String
20:52:59 <Saizan> loupgaroublond: return?
20:53:02 <TSC> Monad m => String -> m String
20:53:03 <chessguy> nope
20:53:06 <mrd> @type return "a"
20:53:07 <chessguy> oerjan, Couldn't match expected type `[a]'
20:53:07 <chessguy> 	   against inferred type `IO [Action]'
20:53:07 <TSC> :t return
20:53:08 <ddarius> Smirnov: It's supposed to be lenient.  Anything more is over specification and (without effects) not observably different.
20:53:08 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
20:53:08 <lambdabot> forall (m :: * -> *). (Monad m) => m [Char]
20:53:21 <Smirnov> ddarius: well i know its not observably different
20:53:26 <loupgaroublond> Saizan: well, what TSC said
20:53:29 <loupgaroublond> TSC, thanks :)
20:53:37 <ddarius> Smirnov: So why bother specifying it?
20:53:42 <TSC> No worries
20:53:42 <oerjan> chessguy: argh i forgot the T
20:53:50 <Smirnov> but neither is lazy if eager terminates..
20:54:05 <hpaste>  oerjan annotated "got dons' code almost working" with "try, try again" at http://hpaste.org/4253#a2
20:54:11 <chessguy> oerjan, i didn't put your body in, that's just the type signature
20:54:12 <ddarius> Smirnov: Yes, but different termination behavior is observable.
20:54:15 <Smirnov> ddarius: i dont know, i was hping my roommate with an eager evaluation homework assignment and realized i didnt know the 100% semantic definition of eager evaluation
20:54:32 <faxathisia> I'd take scheme R5RS as the definition
20:54:44 <Smirnov> surely eager evaluation was invented much earlier than scheme..
20:55:00 <faxathisia> sure but was it ever written out so concisely and well?
20:55:26 <Smirnov> in the original Church paper perhaps?
20:55:40 <faxathisia> was it or not? :|
20:55:45 <ddarius> Smirnov: Maybe but I doubt he would have.
20:55:46 <oerjan> chessguy: oh right, there's a problem in main
20:55:46 <dons> > (2 ^ 1000000 :: Integer) `testBit` 1000000
20:55:48 <lambdabot>  True
20:55:57 <ddarius> But probably in some paper of his in the 40's.
20:55:58 <Smirnov> ddarius: hows that
20:56:33 <monochrom> call-by-name was invented first. call-by-value much later.
20:56:37 <ddarius> Initially he was hoping the untyped lambda calculus might provide a "universal" mathematical language.  Things kind of fell apart after the Y combinator was discovered.
20:56:48 <monochrom> or I may be wrong.
20:57:01 <Smirnov> faxathisia: i cant even find the word "eager" in r5rs anywhere?
20:57:09 <faxathisia> Smirnov: OK
20:57:19 <monochrom> OK, the first thing invented was: oh, we can actually prove that evaluation order doesn't matter!
20:57:21 <Smirnov> is call-by-value === eager evaluation?
20:57:28 <ddarius> monochrom: They were probably "discovered" together though the call-by-name evaluation order would be preferred.
20:57:29 <dons> > (2 ^ 10000000 :: Integer) `testBit` 10000000
20:57:31 <hpaste>  oerjan annotated "got dons' code almost working" with "and again" at http://hpaste.org/4253#a3
20:57:31 <lambdabot>  True
20:57:32 <sorear> Smirnov: does it mention applicative order, or call-by-value?
20:57:42 <sorear> Smirnov: those are other names for it
20:57:42 <nornagon> @check \x -> 2 ^ (abs x :: Integer) `testBit` (abs x)
20:57:43 <lambdabot>  Couldn't match expected type `Int' against inferred type `Integer'
20:58:07 <nornagon> @check \x -> (2 ^ (abs x :: Integer)) `testBit` (abs x)
20:58:07 <dons> very nie oerjan
20:58:07 <lambdabot>  Couldn't match expected type `Int' against inferred type `Integer'
20:59:00 <Smirnov> searching for call-by-value or applicative doesnt help either
20:59:12 <faxathisia> Smirnov: in R5RS?
20:59:14 <Smirnov> hm
20:59:30 <Smirnov> "the operator and operand expressions are evaluated in an unspecified order, and the resulting procedure is passed the resulting arguments"
20:59:33 <aspect> smirnov: uhm I think you should find applicative in there. In the first few paragraphs if I'm not mistaken.
21:00:05 <Smirnov> doesnt scheme allow unlimited function arguments though, or is that only common lisp
21:00:07 <chessguy> oerjan, Ok, modules loaded: Game.
21:00:09 <chessguy> w00t
21:00:17 <faxathisia> common lisp does not
21:00:33 <aspect> scheme does not either
21:00:37 <sorear> Smirnov: it says 'the operand expressions are evaluated... and then ... is passed'
21:00:39 <tehgeekmeister> ?src modify
21:00:39 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
21:00:44 <sorear> Smirnov: IOW, applicative order
21:00:46 <ddarius> It's the error undefined game!
21:00:47 <Smirnov> no one of them definitely does, ive done (+ 5 6 7 8 9 10) before
21:00:58 <faxathisia> Smirnov: That's 6 parameters
21:01:07 <aspect> 6 is bounded
21:01:19 <Smirnov> ok in that case i wasnt clear enouh
21:01:19 <faxathisia> Smirnov: Read the R5RS
21:01:34 <faxathisia> It's short and to the point, I'm sure it will help you
21:01:34 <aspect> you can do that in both CL and scheme, but there's an upper limit in scheme and (so I'm told) CL also
21:01:35 <oerjan> ok afk
21:01:56 <monochrom> IMO this is not rocket science. Just plug and chug. Use the rules.
21:01:59 <Smirnov> ok you cant do that in haskell though without having 6 arguments to + though can you..or returning a function each time?
21:02:01 <chessguy> @redo mapM_ print =<< runGame events
21:02:01 <lambdabot> mapM_ print =<< runGame events
21:02:05 <mrd> there is but it's required to be at least 16 and is usually tens of thousands
21:02:10 <chessguy> @do mapM_ print =<< runGame events
21:02:10 <lambdabot> mapM_ print =<< runGame events not available
21:02:13 <mrd> call-arguments-limit
21:02:24 <faxathisia> > sum [5, 6, 7, 8, 9, 10]
21:02:26 <lambdabot>  45
21:02:31 <mrd> you would do sum in Haskell
21:02:34 <Smirnov> thats not the same thing
21:02:47 <Smirnov> the + in common lisp can magically map to a list of arguments
21:02:48 <oerjan> @redo runGame events >>=  mapM_ print
21:02:48 <lambdabot> do { a <- runGame events; mapM_ print a}
21:02:49 <mrd> it basically is, since CL would turn that into a list
21:02:53 <faxathisia> > (printf "%d %d %d %d %d %d" 5 6 7 8 9 10) :: String
21:02:53 <lambdabot>  "5 6 7 8 9 10"
21:03:01 <mrd> no it doesn't magically map to a list of arguments
21:03:03 <oerjan> chessguy: ^^ last comment
21:03:05 <Smirnov> ah, yes, i meant *variable* arguments instead of unlimited arguments
21:03:13 <mrd> that would mean it works on (+ (list 1 2 3)) which it doesn't
21:03:13 <faxathisia> > (printf :: Int -> Int -> Int -> Int -> Int -> Int -> String) "%d %d %d %d %d %d" 5 6 7 8 9 10
21:03:14 <lambdabot>  Couldn't match expected type `Int' against inferred type `String'
21:03:19 <faxathisia> > (printf :: String -> Int -> Int -> Int -> Int -> Int -> Int -> String) "%d %d %d %d %d %d" 5 6 7 8 9 10
21:03:20 <lambdabot>  "5 6 7 8 9 10"
21:03:30 <faxathisia> Smirnov: You can do it see those two examples
21:03:48 <Smirnov> you can get the same result , its just not sugared in the same way
21:03:54 <faxathisia> what
21:03:55 <lament> :t printf
21:03:57 <lambdabot> forall r. (PrintfType r) => String -> r
21:04:05 <faxathisia> Smirnov: What?
21:04:27 <Smirnov> i did not doubt the semantic power of haskell to be able to sum up a list
21:04:40 <chessguy> oerjan, thanks a lot
21:04:40 <mrd> you can use printf-like typeclass tricks to get functions which return functions as needed to take on additional parameters
21:04:43 <Smirnov> thanks for all the help everyone.
21:04:43 <mrd> i don't recommend it though
21:04:55 <faxathisia> Smirnov: Did you see the printf examples I gave
21:05:02 <dons> chessguy: so is the pure game world design validated now?
21:05:21 <chessguy> dons, i wasn't trying to validate it, i was trying to understand it
21:05:21 <ddarius> dons: Not until we unit test it.
21:05:35 <dons> chessguy: oh, i meant, did it work? :)
21:05:42 <chessguy> dons, it type-checks
21:05:43 <ddarius> . . . . . Error: undefined  *** GREEN BAR ***
21:05:43 <dons> ddarius: quickcheck, please
21:06:10 * dons tries to find the upper practical limit on Integer
21:06:26 <mrd> > product [1..100]
21:06:30 <dons> 2 ^ 500000000 is getting kinda slow
21:06:31 <lambdabot>  9332621544394415268169923885626670049071596826438162146859296389521759999322...
21:06:45 <dons> but still, a lot of ram to go
21:06:57 <dons> > 2 ^ 500000000
21:07:02 <Smirnov> ddarius: ah, what if your arguments have expressions dont terminate?
21:07:03 <lambdabot> Terminated
21:07:13 <dons> > 2 ^ 500000000 `testBit` 500000000
21:07:14 <lambdabot>   add an instance declaration for (Integral Bool)
21:07:14 <lambdabot>     In the expression: 2 ^ ...
21:07:18 <Smirnov> ddarius: wouldnt visiting the arguments of a function in different order result different non-terminating expression trees?
21:07:25 <dons> > (2 ^ 500000000) `testBit` 500000000
21:07:25 <lambdabot>  Add a type signature
21:07:36 <faxathisia> Smirnov: did you see the printf example I gave you?
21:07:46 * mrd imagines lambdabot travelling back in time someday, sent to save the fate of humanity from its certain doom at the hands of evil Lambda overlords.  Terminated.
21:08:45 <dons> 2 ^ 600000000 is getting slower..
21:09:08 <lekro> did something happen to lambdabot's quote archive (as linked from the hwiki humor site)? http://www.cse.unsw.edu.au/~dons/code/lambdabot/State/quote
21:09:24 <mrd> hmm, getting O(n log log n) asymptotic performance out of GMP on multiplies?
21:09:47 <dons> close to 1G allocated nowww
21:09:55 <ricky_clarkson> Does log log mean anything?
21:09:59 <dons> for 2 ^ 700000000
21:10:06 <mrd> ricky_clarkson: it increases realllly slowly
21:10:20 <mrd> log (log (n))
21:10:34 <dons> 2 ^ 600000000 has bit 600000000 set: True
21:10:34 <dons> A: out of memory (requested 202375168 bytes)
21:10:34 <dons> ./A  504.00s user 1.73s system 99% cpu 8:26.71 total
21:10:59 <lekro> mrd: what multiplication algorithm achieves O(n log log n)?
21:11:09 <mrd> karatsuba iirc
21:11:19 <lekro> karatsuba is O(n^log_2(3))
21:11:23 <mrd> ah nvm
21:11:26 <mrd> that's the better one
21:11:33 <Pseudonym> The limit on applying "show" to Integer is smaller than the limit on working with Integers.
21:11:37 <lekro> schoenhage-strassen is O(n log n log log n)
21:11:43 <mrd> something wacky
21:11:59 <Pseudonym> But since you asked, the limit is around 4Mb.
21:12:00 <dons> btw, this game fits the 'every program is an interpreter' rule
21:12:10 <lekro> mrd: but I haven't heard of O(n log log n), that's why I'm curious
21:12:14 <Pseudonym> I tried to multiply two 2.8Mb numbers and it didn't work.
21:13:28 <ddarius> Smirnov: Non-termination is non-termination.
21:13:33 <wli> O(n * log(n) * log(log(n))) ?
21:13:44 <wli> There is effective nontermination also.
21:13:49 <ddarius> Smirnov: You can't tell the difference between the third argument not terminating and the fourth.
21:13:53 <lekro> is it just my browser that I see strange symbols on http://www.cse.unsw.edu.au/~dons/code/lambdabot/State/quote instead of a list of quotes?
21:14:15 <monochrom> It is not just you.
21:14:15 <wli> For instance, you can prove it will terminate, but only after so long that you'll die first.
21:14:23 <tehgeekmeister> >>= in the state monad chains together computations which must then be evaluated with runState (or evalState or execState), correct?
21:14:29 <Pseudonym> Oh, the limit on 64-bit architectures is greater.
21:14:38 <ddarius> lekro: In a fit of insanity (and probably playing with the bytestring library) the files are gzipped text files.
21:14:49 <lekro> ddarius: oh, I see
21:14:57 <monochrom> Yes tehgeekmeister
21:15:09 <lekro> then my browser doesn't seem to recognize that encoding
21:15:16 <Pseudonym> But it's not a limit on RAM, it's a limit in libgmp
21:15:55 <Pseudonym> I have a need to multiply hundred-megabyte-sized integers, so I need to do it out of core.
21:16:04 <Smirnov> ddarius: true that
21:16:38 <Smirnov> ddarius: of course in a rewrite system you could look at the state and discern the difference by looking at where it got stuck
21:17:08 <Smirnov> i think whats important here if the professor wants the eager evaluation to be done canonically or not
21:18:43 <ddarius> I don't know how you are using the word "canonical" here.
21:19:31 <dons> Pseudonym: 'hundred-megabyte-sized integers' ? for work, or pleasure?
21:20:27 <Smirnov> ddarius: well if theres a specific way the professor wanted it
21:20:34 <Pseudonym> Pleasure, if you can call it that.
21:20:51 <Smirnov> another thing i noticed was while playing with ocaml , they eagerly evaluate b, then a, in (f a b)
21:20:51 <chessguy> dons, in what sense would you call that code 'pure' though? i mean, there's IO throughout, hidden in Game
21:20:52 <dons> bondage and discipline
21:21:10 <dons> chessguy: well, only for the ExitWith
21:21:17 <ddarius> Pseudonym makes use of the L4 cache (or is it down to L5, L6? now?)
21:21:20 <dons> try and unfoldr instead of a map over the event list
21:21:23 <dons> to unfold the game state
21:21:27 <dons> the use of exitWith is a true hack
21:21:29 <ricky_clarkson> Couldn't you work out ways of multiplying those integers without them all being in RAM at once?
21:21:34 <dons> you could also call error :)
21:21:46 <wli> Easiest is representing them in a special way.
21:21:51 * dons tries to unfold the game state
21:21:55 <ricky_clarkson> If you can generate the digits in reverse, that might help.
21:23:20 <ricky_clarkson> I suppose there's a divide and conquer way.  If only I could find a pen and paper.
21:23:49 * ddarius has a pen and paper.
21:24:31 * sorear has 5,000 sheets of paper and 100 pens
21:24:47 <ricky_clarkson> How many limbs?
21:24:52 <wli> http://news.bbc.co.uk/2/hi/business/7123970.stm
21:24:53 <lambdabot> Title: BBC NEWS | Business | MI5 warns over China spy threat
21:24:57 <wli> ugh
21:25:16 <lament> divide and conquer, just like napoleon did with russia
21:25:46 <monochrom> What? He didn't divide, and he didn't conquer.
21:25:59 <Pseudonym> ricky_clarkson: The way I'm doing it is to use Karatsuba, with libgmp as the base case.
21:26:09 <Pseudonym> Adding integers out of core isn't hard.
21:27:14 <Pseudonym> It's not commonly appreciated that "really" large integer multiplication doesn't need to use only one method.
21:27:51 <monochrom> It's because few people has needed really large.
21:28:13 <ddarius> Pseudonym: What the?  It's exactly the same principle as switching sorts when they get small enough.
21:28:13 <sorear> Pseudonym: why use karatsuba and *then* libgmp?  I thought gmp used karatsuba as one of its multipliers
21:28:21 <monochrom> For example sorting. Same thing. Few people realize really large sorting is done by combining several methods.
21:28:27 <ddarius> sorear: GMP is not out of core.
21:28:28 <Pseudonym> monochrom: Yes.
21:28:55 <Pseudonym> For its largest integers, libgmp uses finite-ring FFT, of course.
21:29:15 <BlackMeph> dons: HA! I like Alanna's quote about Java. ;)
21:29:16 <ddarius> NTT?
21:29:22 <Pseudonym> So you use libgmp on as much as you can fit in memory...
21:29:24 <Pseudonym> ddarius: Not sure.
21:29:27 <chessguy> @quote java
21:29:27 <lambdabot> dons says: my feeling is that the Java programmers will welcome us as liberators
21:29:30 <Pseudonym> Their description SOUNDS like NTT...
21:29:33 <Pseudonym> But I haven't looked.
21:29:56 <davidL> @quote gender
21:29:56 <lambdabot> Alanna says: Saying that Java is nice because it works on all OS's is like saying that anal sex is nice because it works on all genders.
21:30:32 <chessguy> not exactly family-friendly :(
21:30:50 <lament> it's true, though
21:31:22 * Pseudonym isn't sure if that's an argument against Java or not
21:31:38 <ddarius> Pseudonym: It's just a statement.
21:32:45 <monochrom> It is a flawed analogy.
21:33:18 <chessguy> dons, i'm off to bed...@tell me if you get anywhere?
21:33:50 <ddarius> chessguy: "anywhere"?
21:34:16 <chessguy> ddarius, he was trying to unfold the game state instead of use mapM_
21:35:16 <dons> oh, just use an Either
21:35:23 <dons> and toss out a Left when you're done
21:35:32 <dons> even a MaybeT would be ok :)
21:35:52 <ddarius> I say use two continuations.
21:41:21 <oerjan> Smirnov: i recall reading that Moscow ML, which is an implementation of Standard ML using Ocaml techniques, has an incompatibility with SML's strict evaluation order because of it
21:41:52 <oerjan> iirc SML order is f, then a, then f a, then b, then f a b
21:42:13 <BlackMeph> So, I gather Oleg's latest project is re-writing Emacs...
21:42:26 <ddarius> ... in the type system!
21:42:32 <wli> In the type system, of course.
21:42:39 <BlackMeph> 8D
21:42:47 <ivanm> for real? :o
21:42:47 <ivanm> :p
21:42:49 <lament> hahaha
21:42:54 <ddarius> oerjan: Yes, I'm pretty sure SML's is just left to right.
21:43:19 <oerjan> hm, is "in the type system" the haskell variant of "in bed"? :D
21:43:33 <Pseudonym> ?quote OlegFacts
21:43:33 <lambdabot> OlegFacts says: Oleg solves NP-hard problems in N log N time... in the type system
21:43:38 <Heffalump> oerjan: Moscow ML reuses the O'Caml bytecode engine. I'm not aware of any semantic problems as a result.
21:43:38 <Smirnov> ddarius: hmm what's the deal with not being able to reduce an expression within a lambda abstraction?
21:43:38 <ddarius> oerjan: Or Triumph's saying.
21:43:53 <Pseudonym> ?remember OlegFacts Oleg's latest project is re-writing Emacs... in the type system.
21:43:53 <lambdabot> It is stored.
21:44:00 <oerjan> @quote triumph
21:44:00 <lambdabot> No quotes match. Maybe if you used more than just two fingers...
21:44:37 <Pseudonym> There used to be more OlegFacts.
21:44:40 <ddarius> oerjan: You probably don't really want to know.
21:44:41 <Pseudonym> There used to be more OlegFacts.
21:44:46 <Pseudonym> Whoops.
21:44:48 <lament> @quote OlegFacts
21:44:48 <lambdabot> OlegFacts says: Oleg's latest project is re-writing Emacs... in the type system.
21:44:51 <lament> @quote OlegFacts
21:44:51 <lambdabot> OlegFacts says: Oleg's latest project is re-writing Emacs... in the type system.
21:44:55 <dons> Heffalump: oh, the bytecode interpreter, not the native code gen?
21:44:57 <lament> yeah.
21:45:25 <ddarius> Smirnov: You can, but that's neither call-by-name nor call-by-value.
21:46:00 <Smirnov> hmm
21:46:25 <oerjan> Smirnov: i think that's called super-eager or something
21:46:44 <Smirnov> i dont suppose haskell does any kind of eta reductions then
21:47:35 <oerjan> Smirnov: no.  in fact because of seq haskell does not satisfy eta equivalence: (\x -> undefined x) `seq` True = True
21:47:39 <ddarius> Smirnov: No, because you can actually tell the difference.
21:47:48 <conal> anyone know where STM's "throw" is?  I don't seem to get it from import Control.Concurrent.STM.
21:47:55 <Smirnov> ddarius: in what case (excepting IO) ?
21:47:57 <oerjan> > (\x -> undefined x) `seq` True
21:48:00 <lambdabot>  True
21:48:03 <ddarius> Smirnov: The one oerjan just said.
21:48:06 <oerjan> undefined `seq` True
21:48:09 <oerjan> > undefined `seq` True
21:48:09 <lambdabot>  Undefined
21:48:27 <BlackMeph> Whoa, that blows my mind...
21:48:33 <Smirnov> whoa, what the heck
21:49:18 <BlackMeph> @guote BMeph "Is it just a weird coincidence that the text 'Abstract Computing Machines' was written by a man named Kluge?"
21:49:18 <lambdabot> No quotes for this person. Maybe if you used more than just two fingers...
21:49:23 <oerjan> essentially a lambda is a lazy constructor
21:49:26 <Smirnov> doesnt `seq` just make it eagerly evluate
21:49:49 <BlackMeph> @remember BMeph "Is it just a weird coincidence that the text 'Abstract Computing Machines' was written by a man named Kluge?"
21:49:49 <lambdabot> Okay.
21:50:21 <sclv> > ((\x -> undefined x) True) `seq` True
21:50:25 <oerjan> Smirnov: it evaluates the first to "weak head normal form"
21:50:26 <lambdabot>  Undefined
21:51:17 <sclv> > Just undefined `seq` True
21:51:29 <lambdabot>  True
21:51:43 <BlackMeph> oerjan: Oleg and the type system is Haskell's version of Chuck Norris in WOW..
21:52:42 <ddarius> Am I interpreting this correctly.  You think Chuck Norris jokes are limited to WOW?
21:53:01 <Smirnov> oerjan: i wish i knew what that meant.. looks like i still need to take many more classeS:)
21:54:05 <sclv> @quote advanced.compiler
21:54:05 <lambdabot> Pseudonym says: "Assuming an advanced compiler, your code will be sent to Oleg who will implement it in the type system."
21:55:07 <BlackMeph> ddarius: No, I think a chat channel dedicated to Chuck Norris jokes is limited to WOW. Well, I fervently pray...
21:55:08 <ddarius> dons: Actually if you crack open GHC's representation you can readily get the size.
21:55:10 <sclv> Smirnov: think of WHNF as it gets evaluated just enough to figure out what the top level constructor is. so it looks at Just undefined and says "oh, the top level constructor is Just" and then moves on.
21:55:23 <ddarius> dons: Er of Integer
21:55:28 <Smirnov> sclv: "just" /
21:55:56 <Heffalump> dons: I believe so, yes
21:56:02 <sclv> @src Maybe
21:56:02 <lambdabot> data Maybe a = Nothing | Just a
21:56:14 <ddarius> Smirnov: WHNF is the minimum (local at least)work possible in a lazy language to continue evaluation.
21:57:08 <Smirnov> the "minimum work"? does it count substitution of an expression in two places as more expensive than in one place or something?
21:57:11 <sclv> > (fromJust $ Just undefined) `seq` True
21:57:13 <lambdabot>  Undefined
21:57:33 <Smirnov> is there a semantical definition of that somewhere
21:57:44 <ddarius> @foldoc weak head normal form
21:57:44 <lambdabot> No match for "weak".
21:57:44 <lambdabot> No match for "head".
21:57:44 <lambdabot> No match for "normal".
21:57:44 <lambdabot>  
21:57:44 <lambdabot> *** "form" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
21:57:47 <lambdabot> [14 @more lines]
21:57:52 <ddarius> @foldoc whnf
21:57:52 <lambdabot> *** "whnf" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
21:57:52 <lambdabot> WHNF
21:57:53 <lambdabot>  
21:57:55 <lambdabot>         {weak head normal form}
21:57:57 <lambdabot>  
21:58:03 <OceanSpray> what exactly does 'lift' do?
21:58:08 <ddarius> :t lift
21:58:10 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
21:58:20 <OceanSpray> I noticed that I'm using a lot of liftIO, and yet have no idea of its inner workings.
21:58:27 <dons> ddarius: ah,    | J# Int# ByteArray#         -- large integers
21:58:37 <thoughtpolice> Smirnov: there's some stuff on the wikibook pages about how these evaluations happen
21:58:50 <OceanSpray> okay
21:58:55 <OceanSpray> :t MonadTrans
21:58:56 <lambdabot> Not in scope: data constructor `MonadTrans'
21:58:56 <thoughtpolice> i'll find a link if I can.
21:59:01 <thoughtpolice> :t liftIO
21:59:01 <OceanSpray> ...?
21:59:02 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
21:59:22 <thoughtpolice> liftIO brings IO actions into your monad, while lift simply brings them into the 'upper' monad.
21:59:24 <sclv> Smirnov: the "Just" is like a box -- it checks that it has a box to work with and then moves on. If you then say "add five to the contents of this box" then it needs to look inside the box, and if the inside is "undefined" then a big scary monster jumps out and halts your program.
21:59:33 <OceanSpray> ah
22:00:16 <Smirnov> i dont like scary monsters:(
22:01:02 <OceanSpray> lifts, as in, the action will be performed when the 'upper' monad is evaluated?
22:01:08 <thoughtpolice> Smirnov: ah, here's the link
22:01:11 <virgil> anyone care to help me with http://paste.lisp.org/display/51842
22:01:16 <thoughtpolice> http://en.wikibooks.org/wiki/Haskell/Laziness
22:01:24 <thoughtpolice> it's fairly incomplete but what's there should probably shed some light
22:01:25 <virgil> (same recursive interface question from yesterday)
22:01:55 <Smirnov> holy shit
22:01:56 <Smirnov> denotational semantics
22:02:04 <Smirnov> we were just covering that last week in my class
22:02:35 <thoughtpolice> Smirnov: the wikibook has a bit of interesting stuff that you might find useful. feel free to contribute; it needs it.
22:02:42 <sclv> Smirnov: haskell doesn't like scary monsters either. that's why it tries to avoid looking in boxes unless you force it to.
22:02:47 <Smirnov> unfortunately that was the week that i wasnt in class because i was out of town
22:03:19 <BlackMeph> Smirnov: Busted! ;)
22:03:26 <Smirnov> what, my professor was okay with it lol
22:03:29 <thoughtpolice> OceanSpray: there's a good post on sigfpe's blog,
22:03:35 <thoughtpolice> @go grok haskell monad transformers
22:03:36 <lambdabot> http://sigfpe.blogspot.com/2006/05/grok-haskell-monad-transformers.html
22:03:36 <lambdabot> Title: A Neighborhood of Infinity: Grok Haskell Monad Transformers
22:03:39 <Smirnov> that was probably the hardest thing all year though :(
22:04:02 <conal> augustss: here?
22:05:00 <thoughtpolice> in any case, sleep is good.
22:05:05 <Heffalump> conal: it's 6am, so unless his cat has woken him up or something, it's unlikely
22:05:05 <Smirnov> thoughtpolice: this is nice though, i can read the lectures and the wikibooks and get a better idea of what denotational semantics is (before i even tackle that Laziness page). thx
22:05:24 <thoughtpolice> Smirnov: np
22:05:51 <Smirnov> man haskell always makes me feel smarter :_)
22:06:14 <conal> Heffalump: thanks
22:06:21 <conal> i'm wondering about IVars.  anyone here used them?
22:06:43 <ddarius> @time augustss
22:06:44 <lambdabot> Local time for augustss is 2007-12-04 06:06:44 +0000
22:07:05 <conal> in particular, why the IO in the type readIVar :: IVar a -> IO a
22:09:28 <shachaf> conal: Are IVars still around? The last Haskell reference I've found to them is http://www.haskell.org/ghc/docs/3.02/users_guide/users_guide-4.html .
22:09:29 <lambdabot> Title: The Glasgow Haskell Compiler User's Guide, Version&nbsp;3.02: GHC Language Featu ..., http://tinyurl.com/22fmtf
22:10:06 <conal> shachaf: that's the latest i could find, too.  they're easy to define via STM.
22:10:25 <xpika> is it possible to set a pixel using openGL?
22:10:35 <xpika> set an individual pixel that is
22:11:17 <conal> i think "readIVar v" yields the same value every time it's called, so I wonder why not simply readIVar :: IVar a -> a .
22:13:52 <shachaf> conal: I think this is the same question obk asked yesterday, when you were discussing futures. :-)
22:16:25 <conal> shachaf: really?? which of obk's questions?
22:16:59 <shachaf> conal: Unless I misunderstood something.
22:17:47 <Smirnov> omg hax. _|_ belongs to all types!
22:17:58 <dons> Smirnov: freaky stuff, eh?
22:18:09 <Smirnov> yeah.
22:18:20 <dons> > take 5 $ [1..5] ++ undefined
22:18:35 <lambdabot>  thread killed
22:18:40 <Smirnov> lol
22:18:40 <dons> > take 5 $ [1..5] ++ undefined
22:18:48 <Smirnov> stop trying to kill the threads
22:18:53 <lambdabot>  Undefined
22:19:04 <dons> > take 4 $ [1..5] ++ undefined
22:19:06 <markb> _|_ looks like the bird
22:19:06 <lambdabot>  [1,2,3,4]
22:19:15 <dons> ?src take
22:19:16 <lambdabot> take n _      | n <= 0 =  []
22:19:16 <lambdabot> take _ []              =  []
22:19:16 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
22:19:57 <Smirnov> > [1..5]
22:19:59 <lambdabot>  [1,2,3,4,5]
22:20:06 <Smirnov> hey why cant you take 5 elements out of that anywas.
22:20:15 <dons> > take 5 $ [1..5] ++ [undefined]
22:20:28 <xpika> when compiling a hackage package is it possible to save my package as a file?
22:20:28 <Smirnov> ? src ++
22:20:30 <lambdabot>  thread killed
22:20:33 <dons> > take 5 $ [1..5] ++ [undefined]
22:20:36 <Smirnov> ?src ++
22:20:37 <lambdabot> (++) []     ys = ys
22:20:37 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
22:20:38 <dons> bot is being a bit weird :(
22:20:42 <lambdabot>  [1,2,3,4,5]
22:20:48 <Smirnov> oh oh, ++ appends lists. nm
22:20:59 <dons> xpika: sure. as a tar.gz file
22:21:12 <dons> or a libHSfoo.a ?
22:21:53 <xpika> dons: but then I still have to unzip and run runhaskell setup.hs install right?
22:22:42 <Smirnov> what the heck, _|_(x) is _|_ as well ?
22:23:54 <dmwit> Smirnov: What else would that be?
22:24:13 <Smirnov> and you cant test for equality of _|_ ? :(
22:25:09 <shachaf> Smirnov: fix id == fix id?
22:25:24 <Smirnov> ?src fix
22:25:24 <lambdabot> fix f = let x = f x in x
22:25:35 <Smirnov> oh
22:25:37 <shachaf> Smirnov: sum [1..] == sum [1..]?
22:25:47 <Smirnov> fix is the mu from lambda calc?
22:26:35 <Smirnov> shachaf: well i guess that depends
22:26:53 <shachaf> Smirnov: How about sum [1..] == product [1..]?
22:26:55 <Smirnov> technically its the same expression so why not
22:27:05 <Smirnov> well i dont know
22:27:11 <Smirnov> i am not versed with different orders of infinities
22:27:33 <shachaf> Smirnov: let x = x; y = y in x == y?
22:27:41 <dmwit> Smirnov: These are just examples.  There are arbitrarily many ways to get _|_, and it's not obvious which ones should be equal.
22:28:11 <dmwit> Smirnov: So, we just let (_|_ == _|_) be the same as _|_. =)
22:28:11 <shachaf> Smirnov: _|_ is a function that doesn't return.
22:28:44 <Smirnov> dmwit: whoa i had to parse that sentence twice because of the smiley face.
22:28:51 <dmwit> hehehe, sorry
22:29:04 <shachaf> :_|_)
22:29:09 <BlackMeph> shachaf: So, _|_ is bottomless? ;)
22:30:10 <Smirnov> is _|_ [ _|_ ?
22:30:27 <shachaf> Smirnov: [?
22:30:29 <dmwit> What's '[' in this notation?
22:30:40 <Smirnov> [ is the "less defined" operator
22:30:48 <xpika> .
22:30:49 <Smirnov> like a box with the right side missing
22:31:11 <xpika> so has Text.PrettyPrint.HughesPJ merged with language.haskell.pretty?
22:32:18 <Smirnov> otherwise known as the semantic approximation order?
22:33:01 <Smirnov> the wiki says _|_ [ x for all other x, but im not sure if that means "for all other x that are not _|_" or "for any x"
22:33:38 <shachaf> Smirnov: Which wiki?
22:33:44 <Smirnov> http://en.wikibooks.org/wiki/Haskell/Denotational_semantics
22:34:00 <Smirnov> http://en.wikibooks.org/wiki/Haskell/Denotational_semantics#Partial_Functions_and_the_Semantic_Approximation_Order
22:34:00 <lambdabot> http://tinyurl.com/yxxgb8
22:37:21 <shachaf> Smirnov: It looks like _|_ [= _|_, no?
22:38:05 <Smirnov> well yes
22:38:22 <Smirnov> since _|_ has the same semantic approximation order as _|_
22:38:53 <pejo> Smirnov, according to that page bottom is the least element - you'd get an infinite chain if _|_ [ _|_
22:39:08 <Smirnov> oh where does it say that ?
22:39:35 <Smirnov> or are you just deducing that
22:40:11 <pejo> Smirnov, 2 paragraphs below the definition of g(n) it talks about the least element of a datatype.
22:40:28 <Smirnov> pejo: oh it talks about it later.. thx
22:40:35 <BlackMeph> Smirnov: Using [= to mean "at least as defined," then yes.
22:41:00 <BlackMeph> It isn't just [, though.
22:41:03 <Smirnov> ok
22:41:20 <Smirnov> but whats the deal with x [= y ==> f(x) [= f(y) ?
22:41:44 <Smirnov> what if x = 1, y = 2, f(y) = if 1 then 1 else undefined ?
22:42:00 <shachaf> Smirnov: if 1?
22:42:14 <Smirnov> oops if y==1
22:44:18 <ddarius> 1 is not less defined than 2
22:44:30 <ddarius> They are incomparable.
22:44:40 <Smirnov> 1 is equally well defined as 2
22:44:47 <Smirnov> so 1 [= 2 holds, does it not?
22:44:49 <ddarius> Smirnov: No.
22:45:37 <Smirnov> so is there any x,y s.t. x!=y && x is as well defined as y ?
22:46:24 <ddarius> Not for the usual flat domain of numbers.
22:46:31 <Smirnov> How odd.
22:46:51 <Smirnov> I just assumed that 1,2 were equally well defined for some reason, probably because I was thinking of the <= operator
22:47:04 <ddarius> Not really.  "at least as defined as" is a misleading reading of the operator
22:47:50 <Smirnov> ah
22:48:07 <BlackMeph> Smirnov: Check the section: [= is anti-symmetric.
22:48:12 <Smirnov> aha
22:48:25 <Smirnov> x [= y is not(x [ y) and not(y [ x) ?
22:49:10 <shachaf> Smirnov: "Likewise, a [= b will denote that either b is more defined than a or both are equal (and so have the same definedness)."
22:49:54 <Smirnov> oh.
22:50:26 <Smirnov> that certainly explains the confusion i was having
22:51:14 <Smirnov> thanks well now i agree with x [= y ==> f(x) [= f(y)
22:51:18 <dons> $ cabal install rss
22:51:24 <dons> cabal install rocks.
22:51:49 * dons votes cabal-install the haskell tool of 07
22:52:07 <dons> maybe we should have a haskell open source annual award
22:52:19 <dons> best library, best app, best dev tool
22:52:28 <dons> best tested library
22:54:12 <Smirnov> so (0 +) is not more defined than (0 /) ?
22:54:30 <Smirnov> that seems kind of odd doesnt it, considering that (0 / ) 0 would be undefined
22:57:11 <BlackMeph> Smirnov: That, I guess, depends on if there's a difference between undefined and indeterminate, semantically, at least.
22:58:24 <BlackMeph> But yes, it does seem odd. :p
22:59:26 <Smirnov> well i guess if you call it indeterminate.. it does sound better
23:01:16 <luqui> Can anyone think of a way to have a value be alive (according to gc) iff _both_ of two other values are alive
23:01:17 <dcoutts> dons: you should integrate your mkcabal into cabal-install
23:01:24 <luqui> a "half-reference" of sorts
23:01:25 <dcoutts> $ cabal init
23:01:41 <dons> dcoutts: yes, sounds like a good idea.
23:02:03 <dcoutts> dons: I'm probably going to merge cabal-upload into cabal-install.
23:02:18 <dons> yes, a single tool for this stuff is most efficient
23:17:27 <dons> bringert's new rss package is the awesome :)
23:17:27 <dons> just rolled a custom rss feed in 5 mins
23:45:27 <shachaf> Hmm, `cabal install` is giving me "cabal: user error (Unresolved dependencies: base -any)" or variations for any package I try to install.
23:46:33 <shachaf> It didn't use to do that -- I think that was before I darcs pulled GHC to 6.9.20071128.
23:46:52 <shachaf> Has anyone else had this?
23:46:59 <dons> shachaf: hmm. haven't tried it with ghc head
23:47:31 <shachaf> dons: Before that I ran .20071030.
23:56:24 <jsnx> say i have an entity like this: &#x01ce;
23:56:33 <jsnx> and i want to make it a utf8 char
23:56:42 <jsnx> is their a library for that?
23:56:50 <dmwit> > '\x01ce' -- ?
23:56:52 <lambdabot>  '\462'
23:57:15 <dmwit> Plus something like the "Encoding" library on hackage?
23:58:16 <jsnx> dmwit: so, i should take the string with "&#x01ce;" in it, reformate it to "\x01ce" and then encode it, maybe?
23:58:19 <skew> jsnx: do you mean to do something more general like handle &amp; too, and do a whole file?
23:58:35 <jsnx> skew: it needs to be whole file of stuff, yeah
23:59:06 <jsnx> but i'm used to have a lib that has a function like `decodeEntities :: String -> String`
23:59:14 <dmwit> jsnx: I'm not sure, I haven't seen any libraries for en-/de-coding &; syntax.
23:59:26 <dmwit> There might be one, though, have you browsed around on Hackage yet?
23:59:32 <jsnx> dmwit: yes, i have
23:59:49 <skew> hmm, Text.XHtml.stringToHtml goes the other way
23:59:57 <skew> I suppose one of the xml parser libraries would do it
23:59:57 <Korollary> XML or HTML packages would deal with that
