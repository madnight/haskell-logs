00:23:09 <wy> Do you guys have blogs? I want to set up one, but gave up because I haven't figured out how to preserve indent for my code
00:26:35 <bos> @seen cale
00:26:35 <lambdabot> cale is in #ghc, #haskell-overflow and #haskell. I last heard cale speak 1h 26m 14s ago.
00:28:20 <wy> @seen wy
00:28:21 <lambdabot> You are in #haskell. I last heard you speak just now.
00:28:27 <shapr> wy: You could try bringert's Hope blog system.
00:29:22 <wy> shapr: You made it?
00:30:19 <shachaf> wy: edwardk seems to have something nice set up at comonad.com.
00:30:30 <wy> If it takes too much effort, I'd like to give up ;-)
00:38:31 <wy> gave up :p
01:45:56 <Sizur> how can I call a function that is not exported by a module?
01:46:04 <Sizur> is that impossible?
01:46:28 <Sizur> I'm trying to qualify Text.Printf.uprintf, and compiler complains
01:50:46 <shachaf> Sizur: Generally not possible, yes.
01:51:30 <Sizur> I have to instantiate Text.Printf.PrintType
01:51:36 <Sizur> any suggestions on how to do that?
01:55:57 <Sizur> I guess the only way would be to copy the source code and modify it...
02:05:26 <mcnster> hi.  is there any problem with making "data AType a = ... deriving Show" in a .hs file and "instance Show (AType a)" in a hs-boot file?
02:06:05 <mcnster> ghc claims the instance is defined in the .hs-boot file, but not in the module itself (6.8.2)
02:10:44 <desegnis> Since the subject was raised: Where are hs-boot files documented? (They look like C header files really...)
02:11:22 <mcnster> desegnis, in the user docs under recursive imports, as i recall
02:11:34 <Sizur> ok too many questions, we have to prioritize. mine first ;P
02:12:10 <Sizur> jk
02:12:29 <desegnis> mcnster, thanks. (Hm, we should fix the file types listing in the ghc docs to include hs-boot with a reference to that section then)
02:13:07 <mcnster> yes, it was difficult to locate the first time
02:19:35 <mcnster> aha.  the solution is to make "(Show a) => Show (AType a)" in the .hs-boot file.  makes sense.  goodnight.
02:30:21 <oerjan> Sizur: as far as i can see, uprintf is equal to the String instance of spr, apart from reversing the argument list
02:30:57 <oerjan> hm i guess spr might not be exported either...
02:45:29 <scook0> @src liftM
02:45:29 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
02:45:38 <scook0> @. @undo @src liftM
02:45:38 <lambdabot> Plugin `compose' failed with: Unknown command: "@undo"
02:45:43 <scook0> @. undo src liftM
02:45:43 <lambdabot> ()
03:30:00 <Sizur> when did we come up with a Maybe?
03:31:03 <Sizur> because C.J.Date talks about NULLs as a nonvalues, yet Maybe monad solves that very cleanly
03:32:33 <scook0> Sizur: yeah, I've often idly wondered what would happen if Maybe was applied to relational data
03:32:57 <scook0> seems like it would solve a lot of problems
03:34:00 <scook0> to me, the major evil of NULL seems to be that it isn't consistently treated as a value or non-value
03:34:29 <Sizur> well, 3v logic is flawed if evaluated eagely
03:34:37 <Sizur> that's a bigger problem to me
03:35:09 <scook0> how so?
03:39:36 <Sizur> p a b = a /= r || b /= are -- this should always return True
03:39:51 <Sizur> p a b = a /= r || b /= r -- this should always return True
03:40:51 <Sizur> but if R contains NULLs for both a and b, the result will be NULL too
03:41:42 <Sizur> a anb b here are attributes of are relation
03:41:53 <Sizur> bleh, autocompletion
03:44:12 <Sizur> ("London" <> x) OR ("Paris" <> x) -- must always be True
03:45:06 <Sizur> just a simple example from 'Database in Depth' book
03:46:52 <Sizur> if x is Unknown, the result will be Unknown according to 3v logic. but with 2v this evaluates to what expected -- True
03:49:00 <scook0> ah ... so in other words, if you just liftM2 (&&) and liftM2 (||), you get stupid results
03:49:18 <scook0> but if you use more intelligent operators, you can get better results
03:49:35 <scook0> though I guess that doesn't fix the London/Paris case
03:50:25 <Sizur> > (Just "a" /= Nothing) || (Just "b" /= Nothing)
03:50:27 <lambdabot>  True
03:56:08 <Sizur> > let p x = (Just "Paris" /= x) || (Just "London" /= x) in (p (Just "Paris"), p (Just "London"), p (Just "Budapest"), p Nothing)
03:56:09 <lambdabot>  (True,True,True,True)
03:59:20 <Sizur> simply instead of allowing Nulls in attributes, make the attribute a Maybe
03:59:52 <Sizur> then everybody knows whether an attribute can contain Nothing. it's type-safe, and it is still a value
04:12:51 <Saul> I'm having a bit of a problem with my html form system :(
04:13:34 <Saul> It's actually quite elegant so far, however I need something that seems impossible the way I set it up
04:14:12 <Saul> I basically have a datatype called Form a (which returns an html form and a value of type a)
04:15:44 <Saul> I've made this into an applicative functor, which allows you to do something like: pure SomeConstructor <*> checkbox <*> textfield <*> optional textfield if SomeConstructor is of type Bool -> String -> Maybe Int -> SomeDatatype
04:16:12 <Saul> which is pretty nice, since it's very easy to create forms for records this way
04:17:15 <Saul> however, my problem is that sometimes I need to edit one of those records, and I have no elegant way of unfolding the values in the record over the form
04:17:31 <Saul> does anyone have any suggestions?
04:17:45 <Saul> is anyone even reading this? :)
04:19:08 <roconnor> what do you mean edit?
04:20:28 <roconnor> (what you describe remindes me of TV (tangable values))
04:22:39 <Saul> roconnor: Well whatever the form is made for
04:23:03 <Saul> say you have a Person datatype with some fields like name, age and gender
04:23:57 <Saul> sometimes you would like to add a person, but othertimes you might like to update someone's information
04:24:13 <Saul> And then you would basically want a filled out form to begin with
04:24:59 <roconnor> so you want to be able to give default values?
04:24:59 <Saul> and what's TV?
04:25:06 <roconnor> @wiki TV
04:25:06 <lambdabot> http://www.haskell.org/haskellwiki/TV
04:25:19 <Saul> well not so much default as initial
04:25:31 <roconnor> tangible values ("TVs"), i.e., values that carry along external interfaces.
04:26:39 <roconnor> with TV you would be forced to give initial values to everything
04:27:27 * roconnor thinks
04:27:44 <roconnor> maybe TV's are not really what you want
04:27:57 <roconnor> not sure
04:28:21 <roconnor> anyhow, let me think about how I would directly address your problem
04:29:22 <roconnor> The tricky part is that SomeConstructor is just like a function
04:29:36 <roconnor> so it cannot know how to get information out of a record.
04:29:43 <Saul> indeed, there is no way there to add values to it
04:30:01 <roconnor> to do that you need to explictly tell it what all the projection functions are.
04:30:41 <Saul> yeah but then it's goodbye applicative functor
04:30:57 <Saul> I'll paste my code, that might help a little
04:33:09 <hpaste>  Saul pasted "HtmlForm" at http://hpaste.org/4715
04:33:18 <Saul> Here you go
04:33:50 <Saul> It's not very pretty in some places, but you can get a good idea of what I'm trying to do
04:36:24 <roconnor> how about pure SomeConstructor <*> checkbox getBool <*> textfield getName <*> optional textfield getAge
04:36:33 <roconnor> mix in a reader monad
04:36:50 <roconnor> and add arguments to get the initial values from the environment
04:36:58 <roconnor> I'm just thinking off the top of my head
04:37:14 <Saul> That might work
04:37:47 <Saul> I'm thinking of a wrapper datatype myself at this point, but I'll need to fiddle with it some more
04:38:40 <roconnor> this stuff reminds me soo much of TVs
04:38:48 <roconnor> I just can't quite fit the two together in my head
04:40:03 <Saul> they do look very similar
04:41:37 <roconnor> ``The "sources" will be applicative functors (AFs), and the "sinks" will be cofunctors.
04:43:20 <Saul> I'm not sure what that means
04:44:01 <roconnor> TV's have source that generate data
04:44:05 <roconnor> like your HTML forms
04:44:11 <roconnor> and they are applicative functions
04:44:14 <roconnor> functors
04:44:22 <roconnor> like your Form AF
04:44:32 <roconnor> they also have sinks that consume data
04:44:39 <roconnor> they are cofunctors
04:44:55 <roconnor> I'm trying to think how ``default'' values would fit into this.
04:45:08 <roconnor> are defaults a sink?
04:45:26 <roconnor> or are they something else, tied to the applicative functor.
04:46:02 <roconnor> I'm still learning about TVs :)
04:49:11 <Saul> default values are a little different from values from the database since those don't actually have to adhere to constraints (it doesn't even have to be of the correct type)
04:49:38 <Saul> for example an url field could have "http://" as a default value, however this is not a valid url
04:50:40 <Saul> also they might make more sense on some forms than on others, so I'm reluctant to bind them strongly to individual fields
04:51:18 <roconnor> oh, that is an interesting point.
04:51:43 <roconnor> anyhow, my suggestion above was to bind the accessor to the inital value to the field rather than the inital value.
04:52:09 <roconnor> this should give you the flexiability you need.
04:52:36 <Saul> ah and then the reader monad
04:53:01 <roconnor> that's my idea
04:53:15 <roconnor> not sure it will work
04:54:08 <roconnor> all fields would need an accessor that consumes the same record type (which would become a parameter of the applicative functor)
04:54:16 <Saul> I don't really like it too much, but I'll try it if I can't think of anything better
04:54:18 <roconnor> I don't know if this is bad.
04:54:28 <roconnor> because you may be trying to reuse your form elements.
04:54:42 <Saul> Yup I am
04:54:48 <roconnor> yep
04:54:56 <roconnor> so what I suggest doesn't quite work
04:55:15 <Saul> No not generic enough :(
04:55:44 <Saul> What if we leave the form as it is, and later use a function to add the values to it?
04:56:09 <roconnor> a bit sad
04:56:15 <roconnor> might work
04:56:16 <Saul> data Form a where
04:56:16 <Saul>   Constant :: a -> Form a
04:56:16 <Saul>   Widget :: (Maybe String -> Either InputError a) -> (Maybe String -> Index -> Html) -> Form a
04:56:16 <Saul>   Modify :: (Either InputError a -> Either InputError b) -> (Maybe InputError -> Html -> Html) -> Form a -> Form b
04:56:16 <Saul>   Apply :: (Html -> Html -> Html) -> Form (a -> b) -> Form a -> Form b
04:56:38 <Saul> Basically I could add inverse functions to Widget en Modify here
04:56:47 <roconnor> right
04:56:56 <roconnor> well, I need to go clean now
04:57:00 <roconnor> good luck!
04:57:05 <Saul> ok
04:57:10 <Saul> thanks for your help
05:08:13 <Sizur> @hoogle [a] -> Maybe a
05:08:13 <lambdabot> Data.Maybe.listToMaybe :: [a] -> Maybe a
05:08:14 <lambdabot> Data.List.find :: (a -> Bool) -> [a] -> Maybe a
05:08:53 <Sizur> > listToMaybe []
05:08:55 <lambdabot>  Nothing
05:09:03 <Sizur> > listToMaybe [1,2,3]
05:09:03 <lambdabot>  Just 1
05:11:04 <Sizur> :t do { a <- Just a; fail a }
05:11:05 <lambdabot> Not in scope: `a'
05:11:22 <Sizur> :t do { a <- Just 'a'; fail a }
05:11:22 <lambdabot>     Couldn't match expected type `String' against inferred type `Char'
05:11:22 <lambdabot>     In the first argument of `fail', namely `a'
05:11:22 <lambdabot>     In the expression: fail a
05:11:44 <Sizur> :t do { a <- Just 'a'; fail "" }
05:11:44 <lambdabot> forall t. Maybe t
05:12:19 <Sizur> > do { Just a <- Nothing; return a }
05:12:20 <lambdabot>  Nothing
05:39:17 <EvilTerran> > do Nothing
05:39:19 <lambdabot>  Nothing
05:39:50 <fophillips> Is there a working IMAP library?
05:43:56 <roconnor> @type putString
05:43:57 <lambdabot> Not in scope: `putString'
05:44:05 <roconnor> @type putStr
05:44:06 <lambdabot> String -> IO ()
05:44:24 <roconnor> @type \f -> cofmap f putStr
05:44:25 <lambdabot> Not in scope: `cofmap'
05:55:46 <mattam> @src cofmap
05:55:46 <lambdabot> Source not found. Maybe if you used more than just two fingers...
05:56:05 <mattam> roconnor: What's a cofunctor ?
06:01:46 <dmhouse> class Cofunctor f where cofmap :: (a -> b) -> (f b -> f a), it seems.
06:01:53 <dmhouse> Looks like a contravariant functor.
06:30:02 <L> Hello
06:30:06 <L> Some one Germann here
06:30:08 <L> =)
06:30:34 <ricky_clarkson> #haskell.de ?
06:31:16 <zx]treads> hey any1 saw asus eee pc ? can it run haskell stuff?
06:45:44 <Caelum> it should
06:59:52 <earthy> zxtreads: it can.
07:40:38 <ballzack3> Wie ghets!
07:42:54 <ballzack3> Ich bin ein Computer!
07:44:04 <roconnor> take it to #haskell.de
07:44:14 <roconnor> :)
07:44:57 <ballzack3> Ich kann den Roboter tanzen 8-\-< 8-|-< 8-/-<
07:46:09 <EvilTerran> du ist ein Computer? hast du blinkenlichten?
07:46:18 <ballzack3> haha I wish
07:46:22 <earthy> ich bin kein haburger??
07:46:44 <earthy> +m
07:46:44 <roconnor> Ich bin Berliner
07:49:45 <kalven> no nazi speak plz
07:54:44 <EvilTerran> ... I hope the irony of that comment doesn't escape you.
07:57:21 <ballzack3> I don't think that word means what you think it means.
07:58:53 <EvilTerran> complaining about perceived nazis while being racist?
07:59:06 <EvilTerran> i'd say that fits the meaning pretty well.
07:59:22 <ballzack3> How was he being racist?
07:59:28 <ricky_clarkson> Your type always says that.
08:00:09 <Caelum> well, considering that Roosevelt was a nazi :P
08:12:06 <MoxJet> hello. I'm trying to get xmonad working in gentoo, however I get an error when trying to emerge darcs - all ebuilds that could satisfy "dev-haskell/parsec" have been masked... Any solutions?
08:14:16 <nomeata> Igloo: Hi. sorry for being annoying, but can you upload the new X11 or give me green lights to NMU it? I’d like to upload xmonad now that it’s ready to go.
08:17:24 <int-e> MoxJet: try asking on #gentoo-haskell
08:18:43 <kalven> is that an actual channel?
08:19:30 <int-e> yes
08:19:45 <MoxJet> int-e: yes thanks
08:25:06 <phobes> hmm... Perhaps a better way to phrase my point is, from another point of view, that State is the only Monad you need
08:25:30 <phobes> Monads other than state are dumb :)
08:25:41 <osfameron> Maybes are lovely
08:26:16 <phobes> Maybes are just applicative
08:26:25 <phobes> Using Monads for Maybe is overkill
08:26:25 <osfameron> applicative?
08:26:43 <phobes> Isn't that the right structure?
08:26:51 <phobes> Sorry if not... basically, order doesn't matter
08:27:00 <phobes> Nothing + _ = _ + Nothing = Nothing
08:27:06 <osfameron> er, dunno, I just dunno what you mean by applicative :-)
08:27:14 <osfameron> <-- not a computer scientist
08:27:14 <phobes> It's a more general structure than Monads
08:27:38 <phobes> Of course you can also trivially build Maybe with State too :)
08:29:07 <osfameron> but that really would be overkill?
08:32:44 <nomeata> phobes: is it really trivial, when you can not use Maybe inside the State?
08:33:42 <Saul> phobes: Applicative works a little different from monads actually
08:34:40 <Saul> of you have a bunch of functions of type a -> Maybe b that you want to perform in sequence than using the monad is much more natural
08:34:41 <Saul> of := if
08:35:21 <Saul> since Applicative works with functions of Maybe a -> Maybe b (or a -> b which can be lifted to the former)
08:36:55 <Saul> and besides, any monad is unnecessary, they are handy though
08:37:20 <Saul> gonna go and eat now, bbl
08:51:51 <olsner> fargh, I should've gone darcs a long time ago... found a folder with 7 copies of the same program, named bak2?.Main(-old2?)?.l?hs, along with a folder with a modularized version of the same
08:55:40 <olsner> hmm, why does http://darcs.net/cgi-bin/darcs.cgi/stable/?c=browse not show any files?
08:55:41 <lambdabot> Title: darcs repository
08:55:49 <mmmdonuts> Once you've gone darcs, you never go .bak
08:55:59 <olsner> @quote .bak
08:55:59 <lambdabot> syntaxfree says: <Bourbaki> the best thing i have ever read in economy is a statement of some guy "i have never met the homo oeconomicus" <syntaxfree> I have never met a catamorphism, either.
08:56:38 <olsner> @remember mmmdonuts Once you've gone darcs, you never go .bak
08:56:38 <lambdabot> I will remember.
08:56:45 <oerjan> @quote [.]bak
08:56:45 <lambdabot> mmmdonuts says: Once you've gone darcs, you never go .bak
08:56:47 <oerjan> @quote [.]bak
08:56:47 <lambdabot> mmmdonuts says: Once you've gone darcs, you never go .bak
08:56:59 <mmmdonuts> :)
08:57:29 <joeyh> runghc -fXXX seems to exit 127, while ghc works ok with those flags. Is this normal?
08:58:37 <allbery_b> -f for runghc specifies the path to ghc
08:58:58 <joeyh> aha
08:59:02 <allbery_b> runghc -- -f...
08:59:20 <joeyh> -- doesn't seem to work
08:59:39 <joeyh> -f/usr/bin/ghc -f... wordls
08:59:40 <allbery_b> hm.  usage bug?  (wouldn't be the first)
08:59:41 <FunctorSalad> http://arcanux.org/lambdacats/type-error-2.jpg
08:59:55 <joeyh> thanks, I can at least file a sane bug report with that
09:00:14 <dmhouse> FunctorSalad: heh.
09:00:36 <olsner> anyways, am I misunderstanding how darcs works? shouldn't that repository browser do something like  display the last versions of the files in the repository?
09:00:47 <FunctorSalad> these are awesome
09:01:30 <olsner> ?where lambdacats
09:01:30 <lambdabot> http://arcanux.org/lambdacats.html
09:05:42 <mmmdonuts> olsner, I agree.  I have darcs repos which show file lists on the equivalent page, with links from each file to annotations and patches.  The darcs.net repo browser is broken maybe?
09:07:21 <phobes> oops
09:07:50 <phobes> Disregard claims about State being universal :^)
09:08:55 <phobes> There is a universal Monad I think, and it's related to State, but it's more complicated than that
09:09:23 <oerjan> delimited continuations iirc
09:09:44 <oerjan> proof by filinski
09:10:01 <oerjan> (which i haven't read)
09:17:15 <FunctorSalad> universal monad? as in universal property?
09:17:21 <FunctorSalad> @ phobes
09:17:45 <oerjan> @bot
09:17:45 <lambdabot> :)
09:18:06 <LoganCapaldo> Iwant a galatic monad
09:18:13 <LoganCapaldo> *galactic
09:18:20 <LoganCapaldo> or a multiversal one
09:19:25 <Sizur> "The Everything Monad"
09:19:49 <FunctorSalad> hmm the monads over a fixed category C, with natural transformations as morphisms, is a category, no?
09:19:58 <mmmdonuts> Time to read http://rbjones.com/rbjpub/philos/classics/leibniz/monad.htm
09:19:59 <lambdabot> Title: THE MONADOLOGY
09:20:17 <mmmdonuts> "The Monad, of which we shall here speak, is nothing but a simple substance, which enters into compounds. [...] We may also hold that this supreme substance, which is unique, universal and necessary, nothing outside of it being independent of it,- this substance, which is a pure sequence of possible being, must be illimitable and must contain as much reality as is possible."
09:20:22 <Sizur> i like arrowology more
09:21:13 <Sizur> mmmdonuts: izznt that the IO?
09:21:20 <Sizur> IO = world state
09:21:21 <davidL> someone on here once told me that monadology has nothing to do with the monads that come from category theory
09:21:33 <LoganCapaldo> they would be right
09:21:44 <FunctorSalad> well Leibniz precedes category theory a bit
09:21:46 <mmmdonuts> Except for the name,,,
09:21:48 <LoganCapaldo> monadology monads are like "atoms" IIRC
09:22:10 <LoganCapaldo> indivisble bits of reality
09:22:40 <mmmdonuts> Sizur, you'd have to resurrect Leibniz, explain category theory to him, and then ask him whether he meant IO.
09:23:30 <Sizur> do same with me. you'll have an advantage of skipping the first step
09:25:02 <LoganCapaldo> well it's the second step that's the most challenging <g>
09:25:33 <LoganCapaldo> category theory is hard, let's go shopping
09:25:47 <Sizur> lol
09:27:17 <FunctorSalad> hmm I tried the reverse "shopping is boring, let's learn category theory", but she didn't like it (j/k)
09:27:56 <mmmdonuts> Bedtime reading: http://wwwhome.cs.utwente.nl/~fokkinga/mmf92b.html
09:28:01 <lambdabot> Title: Introduction to Category Theory
09:28:20 <Sizur> for infants
09:28:25 <mmmdonuts> It's actually titled "A Gentle Introduction to Category Theory".
09:28:34 <mmmdonuts> So you know it's easy. :)
09:28:59 <LoganCapaldo> i need a violent, no holds barred eXtreme introduction to category theory.
09:29:03 <LoganCapaldo> tough love.
09:29:10 <Sizur> i need A Very Gentle Step By Step Introduction to Category Theory for Dummies
09:29:20 <LoganCapaldo> this gentleness nonsense does cut it in today's dog eat dog world
09:29:32 * LoganCapaldo head bangs
09:30:22 <Sizur> or even a cookbook with a superset of recipes
09:30:33 <ricky_clarkson> That was written in 1994.
09:30:47 <ricky_clarkson> Clearly we need a guide to category theory complete with cartoon foxes.
09:30:59 <Sizur> yeah, that might help
09:31:20 <Sizur> preferably in anime style
09:32:33 <Sizur> @help jinn
09:32:33 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
09:32:42 <Sizur> @help ginn
09:32:42 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
09:32:51 <Sizur> what was it again
09:32:53 <mmmdonuts> Perhaps Neon Genesis Evangelion *was* an introduction to category theory.
09:33:53 <mmmdonuts> I suspect that would explain many aspects of the plot.
09:33:55 <ricky_clarkson> @quote category
09:33:55 <lambdabot> bos says: it looks like an interesting book, although i find the idea that software engineers might be ready for category theory this side of the 22nd century charmingly naive
09:34:20 <FunctorSalad> LoganCapaldo: maybe like the xkcd "stand back, I know regular expressions"?
09:34:34 <Sizur> hah that's funny
09:35:12 <FunctorSalad> "oh noes, we need a functor from a to b to save the kittens but we only have one in the other direction" "stand back, I know adjoint functors"
09:35:25 <FunctorSalad> sorry
09:35:41 <mmmdonuts> Sounds like an idea for a game
09:36:03 <Sizur> we need an extended Djinn compiler where you code only with types and let the compiler find the solution
09:36:41 <LoganCapaldo> @remember FunctorSalad "oh noes, we need a functor from a to b to save the kittens but we only have one in the other direction" "stand back, I know adjoint functors"
09:36:41 <lambdabot> Good to know.
09:36:51 <FunctorSalad> :)
09:39:34 <mmmdonuts> There's also Category Theory for Beginners: http://www.cs.toronto.edu/~sme/presentations/cat101.pdf
09:39:35 <FunctorSalad> seriously, I'm afraid (but not sure) that much of the didactics may be in vain and there is no way around sitting down and actively solving exercises
09:39:41 <mmmdonuts> Has some pictures, but no cartoon foxes.
09:39:51 <FunctorSalad> even if you are just plugging in definitions
09:40:40 <LoganCapaldo> but but exercises are boooooring
09:40:47 <LoganCapaldo> lets go shopping
09:40:47 <FunctorSalad> ideas which confused the hell out of me became clear after I sat at a problem involving that idea for a few hours
09:41:03 <FunctorSalad> LoganCapaldo: it's hard to get started, but once you are it's not so bad IMHO
09:41:46 <LoganCapaldo> I don't kneed to no category theory anyway. :p
09:41:46 <ricky_clarkson> Shopping is boring, let's drink coffee and do some programming.
09:42:17 <FunctorSalad> LoganCapaldo: well it's useful for math anyway, I don't learn it just for Haskell
09:43:28 <Sizur> math is boring, let's do metamath
09:44:17 <EvilTerran> ricky_clarkson, okay, you program, i'll drink coffee. we'll get more of both done that way.
09:44:26 <FunctorSalad> I prefer math to metamath...
09:44:35 <ricky_clarkson> EvilTerran: Hey, I'm good at drinking coffee.
09:44:40 <EvilTerran> i've never metamath I didn't like
09:45:34 <FunctorSalad> hell everything is boring, math is not really worse
09:45:51 <EvilTerran> everything2 isn't boring
09:46:34 <mdmkolbe|work> Are there any tools to help track down where a stack-overflow is comming from (i.e. an infinite loop)?
09:46:36 <Sizur> i like the third slide of that presentation [cat101]. an example of an explanation of a concept in usual category papers
09:47:01 <mdmkolbe|work> Sizur: what presentation?
09:47:17 <Sizur> http://www.cs.toronto.edu/~sme/presentations/cat101.pdf
09:49:36 <oerjan> mdmkolbe|work: there's some option to get a stack trace from profiling, i believe
09:50:16 <Heffalump> mdmkolbe|work: the tracing in ghci 6.8 can be of some use
09:50:17 <LoganCapaldo> what about the shiny new ghci debugger?
09:50:36 <Heffalump> though it depends abit on how long a single iteration of the loop is
09:50:58 <LoganCapaldo> > let loop = loop in loop
09:51:00 <lambdabot>  Exception: <<loop>>
09:51:27 <LoganCapaldo> > let loop = go where go = loop >> go
09:51:28 <lambdabot>  Parse error at end of input
09:51:36 <LoganCapaldo> > let loop = go where go = loop >> go in loop
09:51:37 <lambdabot>   add an instance declaration for (Show (m a))
09:51:43 <olsner> hmm... I still don't know what use I could have for category theory
09:52:27 <LoganCapaldo> I dunno any branch of math w/ diagrams has gotta be a good'un
09:52:50 <oerjan> > let loop = go where go = loop >> go in loop :: Maybe (Either String Ordering)
09:52:51 <lambdabot>  Exception: <<loop>>
09:52:51 <olsner> isn't that like fix (fix . (>>))?
09:53:04 <LoganCapaldo> it's like nonsense :)
09:53:20 <oerjan> @pl let loop = go where go = loop >> go in loop
09:53:21 <lambdabot> (line 1, column 24):
09:53:21 <lambdabot> unexpected "="
09:53:21 <lambdabot> expecting variable, "(", operator, ";" or "in"
09:53:41 <oerjan> @pl let loop = go; go = loop >> go in loop
09:53:41 <lambdabot> snd (fix (uncurry (flip =<< ((,) .) . flip (>>))))
09:53:44 <olsner> @ty let loop = go where go = loop >> go in loop
09:53:44 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a
09:53:46 <oerjan> eek
09:54:02 <xerox> > fix (join (>>)) :: [a]
09:54:03 <lambdabot>  Exception: <<loop>>
09:54:15 <conal> does anyone know whether opengl is thread-safe?
09:54:26 <oerjan> @pl let go = go >> go in go
09:54:26 <lambdabot> fix (join (>>))
09:54:31 <FunctorSalad> olsner: well if you're a math student it's kind of fun to formulate things from other courses in category theory terms
09:54:45 <FunctorSalad> one can go overboard with that though ;)
09:55:14 <olsner> @ty fix (join (>>))
09:55:15 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a
09:55:22 <olsner> @ty fix (fix (>>))
09:55:23 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m b)
09:55:23 <lambdabot>     Probable cause: `>>' is applied to too few arguments
09:55:23 <lambdabot>     In the first argument of `fix', namely `(>>)'
09:55:29 <olsner> @ty fix (fix . (>>))
09:55:30 <lambdabot> forall (m :: * -> *) b. (Monad m) => m b
09:56:10 <olsner> hmm, perhaps I should've started out in math rather than CS
09:58:02 <FunctorSalad> don't know, it depends on what you like
09:58:56 <FunctorSalad> CS (even theoretical) tends to get a bit messy for my tastes, I prefer the neatness of math. but OTOH it can be quite far removed from reality
09:59:08 <FunctorSalad> on the third hand, you still learn reasoning ;)
10:00:31 <mdmkolbe|work> ok so, i've got a recent GHC with the new debuger commands.  how do I start tracking down the loop?
10:06:36 <mmmdonuts> olsner, for uses for category theory, see http://www-cse.ucsd.edu/users/goguen/ps/manif.ps.gz .
10:06:57 <mmmdonuts> "A Categorical Manifesto"
10:08:15 <olsner> cool, sounds interesting
10:09:30 <mmmdonuts> It's actually fairly readable - lots of prose, few formulae.
10:09:38 <FunctorSalad> uhm how is the explanation of colimits in the previous pdf better than the one it is critizing?
10:09:49 <FunctorSalad> because the formulas are not typeset in latex? :/
10:13:10 <xerox> anybody can fetch a paper from sciencedirect.com please?
10:13:25 <mmmdonuts> Good point.  Maybe the author was hoping the audience would have forgotten that critique by the time they got to his own colimit slide.
10:13:33 <FunctorSalad> hehe
10:13:58 <mdmkolbe|work> I don't understand slide 7 of cat101.pdf.  Where does he get the claim that f . h = ID_b?  What if we were on the category of functions on sets, wouldn't f . h not nessisarily be ID_b?
10:15:24 <benny99> mdmkolbe|work: where did you get that paper?
10:15:36 <FunctorSalad> mdmkolbe|work: it is because he has drawn /all/ morphisms that are supposed to exist
10:15:48 <FunctorSalad> odd example, I agree
10:16:29 <mdmkolbe|work> benny99: "Sizur: http://www.cs.toronto.edu/~sme/presentations/cat101.pdf"
10:16:30 <FunctorSalad> f . h is a morphism from b to itself, and because the only morphism from b to b is the id, we must have f.h=id
10:16:33 <shapr> @yow !
10:16:33 <lambdabot> Are we on STRIKE yet?
10:16:35 <benny99> thanks :)
10:16:52 <shapr> I'm HUNGRY! Where's my MULTIPARAMETER TYPECLASS?
10:17:27 <mdmkolbe|work> FunctorSalad: so if we add another 2(?) morphisms from b to b, would it become a catagory (e.g. the way it is on slide 8)?
10:18:48 <mdmkolbe|work> (also could we do the same with only one extra morphism)
10:18:51 <FunctorSalad> mdmkolbe|work: depends on the composition law, too lazy to figure out all the possibilities now ;) but don't let it discourage you, it's just a silly toy example
10:19:36 <mdmkolbe|work> FunctorSalad: heh, I always seem to get stuck on silly toy examples in catagory theory;  there's always something critical left implicit.
10:22:04 <mmmdonuts> That's why I prefer CS - can't get away with the lazy sleights of hand mathematicians are always pulling. ;)
10:22:10 <shapr> Hiya huh, learning Haskell?
10:22:23 <shapr> mmmdonuts: I dunno, look at C
10:22:31 <FunctorSalad> ok, let's call the new morphisms x and y. we still have f.h = f.g = id. we need to define x.x, x.y, y.x, y.y, y.h, y.g, x.h, x.g
10:23:32 <FunctorSalad> hmm I think an easier way might be to just implement the thing as a subcat of Set
10:23:46 <mmmdonuts> shapr, not sure if C qualifies as CS,,,
10:23:50 <shapr> mmmdonuts: Good point!
10:24:44 <FunctorSalad> mmmdonuts: well I think if you truly understand it already, handwaving is ok. sometimes there is nothing to be gained by writing everything out
10:24:53 <FunctorSalad> mmmdonuts: in this case I didn't pretend to have solved the problem
10:26:58 <FunctorSalad> ok, let A={0,1}, B = {0}, f is obvious, g: 0 mapsto 0, h: 0 mapsto 1, x: constant 0, y: constant 1. that thingy should be closed under composition
10:27:06 <FunctorSalad> so it is a category of that shape
10:27:46 <mmmdonuts> FunctorSalad, the problem is you can't always tell when your audience will need something written out.  There was a paper recently about how the most elementary papers aimed at outsiders end up being the most popular within a field.
10:27:50 <mmmdonuts>   People overestimate what their audiences know.
10:27:52 <loupgaroublond> how come i get so many dead links when being linked back to documentation?
10:28:15 <FunctorSalad> mmmdonuts: ok, teaching is another matter, agreed that sometimes it's too terse
10:28:52 <mmmdonuts> All communication is a form of teaching... :)
10:29:43 <FunctorSalad> yes, but it's not always just communication, but anyway I think we agree
10:30:01 <FunctorSalad> (I mean sometimes you are just figuring things out yourself)
10:30:35 <FunctorSalad> so, is my solution to slide 7 ok?
10:30:48 <FunctorSalad> (used the same names we had earlier)
10:30:49 <mdmkolbe|work> FunctorSalad: yes, I think I see
10:31:02 <mmmdonuts> True.  Although when I'm figuring things out myself, I end up communicating with myself quite a bit.
10:31:38 <FunctorSalad> mdmkolbe|work: now that we have implemented it as a subcat of Set, we don't need to check associativity; function composition is always associative. but we needed to check closure under composition
10:32:11 <kscaldef> hi... Am I wrong to be expecting the parsec "float" token to accept negative numbers?
10:33:30 <mdmkolbe|work> FunctorSalad: the composition part I understand.  what does "subcat of Set" mean?  (If it's to complicated at this point (only begingin category theory), I'm comfortable skipping that.)
10:35:02 <FunctorSalad> mdmkolbe|work: oh, Set is the category that has sets as objects and functions as morphisms. a subcategory of a category C is given by picking some objects and some morphisms from C, such that the composition of two chosen morphisms is included too. just like subvectorspace and whatnot
10:35:34 <FunctorSalad> as is always the case in algebra, associativity is inhered by substructures
10:35:55 <mdmkolbe|work> FunctorSalad: so Set includes *all* possible sets over *all* possible objects?
10:36:40 <FunctorSalad> mdmkolbe|work: yes
10:37:11 <FunctorSalad> mdmkolbe|work: that's why the bunch of objects isn't called a set (avoiding russell)
10:38:11 <FunctorSalad> but as we do nothing nasty with the collection of objects, it's ok :)
10:40:01 <kscaldef> anyone around who can help with Parsec?
10:40:59 <mdmkolbe|work> so if we wanted to try using only one extra morphism would the following work? A={0,1}, B={0,1}, f is id, g is id, h: 0 mapsto 1 and 1 mapsto 0, x: 0 mapsto 1 and 1 mapsto 0
10:41:18 <mdmkolbe|work> (maybe I need to make B={2,3} to avoid A=B)
10:41:49 <Sizur> ok, enough cat101 for me ... time for my coffee
10:42:40 <FunctorSalad> mdmkolbe|work: that wouldn't be closed under composition I think. f.x.g would be the flip on B, which we don't have
10:43:07 <FunctorSalad> mdmkolbe|work: but you could leave B at {0} and otherwise leave things the same
10:44:19 <FunctorSalad> hmm no, that wouldn't work either
10:44:40 <mdmkolbe|work> FunctorSalad: yeah, you end up needing "const 1" and "const 0"
10:44:48 <FunctorSalad> yeah
10:45:05 <FunctorSalad> maybe that's the reason why he suggested two morphisms :)
10:46:26 <mdmkolbe|work> FunctorSalad: hmm, well.  I'll have to think on that one.  in the meantime, you've been most helpfull.
10:46:27 <oerjan> kscaldef: seems minus signs don't work...
10:46:31 <mdmkolbe|work> @karma+ FunctorSalad
10:46:32 <lambdabot> FunctorSalad's karma raised to 1.
10:46:38 <FunctorSalad> thanks :)
10:47:07 <kscaldef> oerjan: yeah, seems that way :-(
10:47:31 <kscaldef> it's a surprising bug, though
10:47:33 <Cheery> do you know a proper latex -> html converter_?
10:47:47 <loupgaroublond> is there any good guides for fundeps that is easier to understand than the documentation?
10:48:23 <oerjan> kscaldef: it may be inspired by Numeric.readFloat, which i recall has the same restriction
10:48:34 <oerjan> > readFloat "3.1"
10:48:36 <lambdabot>  [(3.1,"")]
10:48:39 <oerjan> > readFloat "-3.1"
10:48:39 <lambdabot>  []
10:49:29 <kscaldef> ugh... lame
10:49:42 <EvilTerran> > read "-3.1" :: Float
10:49:42 <lambdabot>  -3.1
10:49:46 <EvilTerran> hm
10:49:55 <mdmkolbe|work> loupgaroublond: look at Control.Monad.Reader for an example fundep.  it basically says that each particular m only has one r instance associated with it.  that's about evertything most people end up needing to know about fundeps (to use them), unless you want the theory.
10:50:39 <loupgaroublond> mdmkolbe|work: hmm.... i'll have  a look
10:50:41 <mdmkolbe|work> how do I get GHC's :history to be longer than 50?
10:51:24 <kscaldef> sigh... and the Parsec maintainer email is apparently no longer active
10:51:39 <oerjan> kscaldef: actually it may be a feature.
10:52:09 <oerjan> e.g. you want to be able to refuse something like "2.0--3.1"
10:52:38 <EvilTerran> it's fairly easy to extract a - yourself beforehand
10:52:43 <oerjan> which requires you to be able to parse the sign separately
10:53:07 <kscaldef> well, it seems like there should at lest be a tokenizer that gives the option.  (like how there is natural and integer)
10:53:08 <oerjan> sign = (char '-' >> return negate) <|> return id
10:53:17 <kscaldef> yeah, I can write a wrapper
10:53:21 <oerjan> sign `ap` float ...
10:55:08 <EvilTerran> signRead :: Num a => ReadS a -> ReadS a; signRead f ('-':xs) = map (first negate) (f xs); signRead f xs = f xs
10:55:28 <oerjan> EvilTerran: we are talking Parsec here
10:55:38 <EvilTerran> i was working from readFloat
10:56:11 <EvilTerran> got back on ''<oerjan> > readFloat "3.1"'', and didn't bother with reading the scrollback ;)
10:56:32 <EvilTerran> i like your parsec solution
10:57:06 <oerjan> :t readSigned -- already exists
10:57:06 <lambdabot> forall a. (Real a) => ReadS a -> String -> [(a, String)]
10:57:53 <EvilTerran> aha.
10:57:57 <EvilTerran> is that a 6.8 thing?
10:58:01 <oerjan> although i don't know why they chose Real rather than Num
10:58:04 <oerjan> definitely not
10:58:14 <oerjan> H98 i think
10:58:26 <EvilTerran> hm. okay then. I haven't studied Numeric in detail
10:58:34 <EvilTerran> yeah, the Real constraint strikes me as odd
10:58:58 <olsner> hmm, what does it mean for a diagram to commute?
10:59:25 <loupgaroublond> fundeps just became my new best friend :)
10:59:38 <oerjan> olsner: it means that any two paths between two vertices give the same composition
10:59:47 <mdmkolbe|work> loupgaroublond: did you have any trouble figuring them out once you saw one?
11:01:21 <loupgaroublond> mdmkolbe|work: nope, i understood the syntax right away, i still don't really understand how they work though, and if it were something more complicated, i'd probably still be screwed
11:01:24 <hpaste>  mdmkolbe|ubuntu pasted "what does this Hat error mean?" at http://hpaste.org/4716
11:01:31 <loupgaroublond> mdmkolbe|work: but i'd been trying to get this to work for two days
11:02:23 <mdmkolbe|work> Since the GHC debugger only seems to heep a history of 50, I wanted to try Hat instead.  But it gives me this error http://hpaste.org/4716
11:04:24 <mdmkolbe|work> loupgaroublond: fundeps are usually used when (in a -> b) the "b" is part of the type of "a" (e.g. how the Reader datatype is implemented).  anything beyond that is probably wrong (as a general guideline for beginers, but there are exceptions)
11:04:29 <Heffalump> mdmkolbe|work: I think you can configure the history length
11:08:19 <mdmkolbe|work> Heffalump: do you know how? (I've been unable to find such a way)
11:09:16 <Heffalump> not OTTOMH. I'll go look..
11:10:52 <Heffalump> ah, the manual says "perhaps in the future we'll make this configurable".
11:11:00 <Heffalump> sorry for the misinformation :-)
11:12:51 <mdmkolbe|work> Heffalump: hmm, thx anyway
11:14:44 <loupgaroublond> what does this mean: the Coverage Condition fails for one of the functional dependencies
11:15:22 <Heffalump> loupgaroublond: the coverage condition is a conservative restriction designed to guarantee that type-checking terminates
11:15:32 <EvilTerran> it means one of your fundeps, when applied by the type inferrer, makes the problem of "what type is everything?" bigger rather than smaller
11:15:33 <Heffalump> the GHC manual describes it more precisely
11:15:46 <loupgaroublond> ah
11:15:51 <Heffalump> you can get rid of the error by using -XUndecidableInstances
11:15:54 <EvilTerran> so, with it, typechecking *may* diverge
11:16:03 <EvilTerran> it is very conservative, tho
11:16:06 <Heffalump> at the cost of risking non-termination at type-checking time - but in practice it's rare
11:16:37 <loupgaroublond> i'd rather make it more correct than use a million flags, i already have a huge number of extra flags in this module
11:16:52 <EvilTerran> the only time i can think of when i've blown the typechecker's stack with -XUndecidableInstances, I had -XIncoherentInstances as well
11:17:08 <mdmkolbe|work> loupgaroublond: you may want to paste your class and instances to hpaste.org
11:18:00 <loupgaroublond> mdmkolbe|work: it's fairly messed up, since i'd have to post about 40 lines of non trivial code, but i think i have a better idea anyways
11:18:04 <mdmkolbe|work> loupgaroublond: blind guess is that you wrote "r -> m" instead of "m -> r" (Cf. Control.Monad.Reader.MonadReader)
11:19:13 <mdmkolbe|work> loupgaroublond: we'd probably just need the class and the first line of each instance (unless you are doing serious type hackerty, most fundeps are easy to debug for an experienced user)
11:19:24 <loupgaroublond> mdmkolbe|work: i told you i don't understand it very well :P
11:20:47 <hpaste>  loupgaroublond pasted "bad fundeps ?" at http://hpaste.org/4717
11:21:25 <b_jonas> wtf
11:21:34 <b_jonas> do you really need a class with FIVE parameters
11:21:42 <b_jonas> of which only one is fundepped
11:23:05 <loupgaroublond> yes, and and that's the part i don't quite get
11:23:18 <b_jonas> I think even that class shouldn't compile though... most methods don't determine all class parameters from their types
11:23:34 <b_jonas> I'm surprise you get an error after that apparently
11:24:39 <mdmkolbe|work> loupgaroublond: well, the learning curve for fundeps is sort of a step function.
11:25:05 <conal> loupgaroublond: from the types of (-->) and (>>=), p == f
11:25:08 <mdmkolbe|work> loupgaroublond: I'm not sure that is a fundep related error (still thinking through it)
11:25:27 <b_jonas> I think it's fundep related
11:25:38 <b_jonas> I've got a similar error with fundeps last time
11:26:04 <b_jonas> this one: http://hpaste.org/4695
11:26:14 <conal> i don't think it's related to the fundep.  just the type and definition of -->
11:26:44 <b_jonas> someone in the channel said that it works with ghc 6.8 if they change 'main = print bar;' to 'main = print (bar :: IO)'
11:27:46 <conal> since p :: Query Bool, the body of the \b -> .. must have type Query b for some b.  so f, mempty :: Query b.
11:28:24 <conal> but f :: mh.  thus the error message: Query b /= mh, since mh is universally quantified
11:28:32 <mdmkolbe|work> loupgaroublond: the problem is that the RHS of >>= needs to be a "Bool -> Query Bool" since the LHS is "Query Bool", and the RHS can only be proven to be mh
11:28:40 <loupgaroublond> well, i should say that the code compiles cleanly when i split up the first three types and last three types into two seperate classe
11:29:03 <conal> loupgaroublond: maybe you could show us that code as well.
11:29:10 <loupgaroublond> conal, sure
11:29:24 <mdmkolbe|work> loupgaroublond: I only see 5 types, do you mean "i p m" and "m h f"?
11:29:36 <Lemmih> b_jonas: 'bar' is type 'Int', not type 'Foo a => a'.
11:29:57 <b_jonas> Lemmih: well, I think it's of type Foo a => a
11:30:14 <loupgaroublond> mdmkolbe|work: yup, i'll paste that
11:30:15 <b_jonas> because,
11:30:28 <b_jonas> as I say it in that paste,
11:30:31 <b_jonas> "When I put the class Foo and bar to a separate module, and import them into main, it works."
11:30:36 <hpaste>  loupgaroublond pasted "split into two classes, compiles" at http://hpaste.org/4718
11:30:50 <mdmkolbe|work> loupgaroublond: the naive solution would be to make the instance "QueryPredicate a a Bool (Query Bool) (Query Bool)', but that may not be what you want
11:31:00 <b_jonas> well, maybe it's Int
11:31:02 <b_jonas> I dunno
11:31:09 <b_jonas> still, it doesn't work either way in ghc 6.6
11:31:12 <Lemmih> b_jonas: Exactly. When 'instance Foo Int' is in scope, 'bar' must be an 'Int'.
11:31:17 <loupgaroublond> mdmkolbe|work: it's something called a ManageHook, that's a Query(Endo WindowSet)
11:31:19 <int-e> loupgaroublond: when did ManageHook become mh?
11:31:36 <b_jonas> Lemmih: but why do I have to tell that with an explicit annotation?
11:31:45 <loupgaroublond> int-e: because sometimes i have a Query(Maybe (Endo WindowSet))
11:31:55 <conal> loupgaroublond: is ManageHook an alias for Query <ty> for some ty ?
11:31:59 <mdmkolbe|work> @src Endo
11:32:00 <lambdabot> Source not found. :(
11:32:02 <b_jonas> anyway, I'll probably install ghc 6.8
11:32:26 <loupgaroublond> conal: maybe, i'm not sure i understand that fully either
11:32:37 <conal> loupgaroublond: what's the definition of ManageHook?
11:32:57 <int-e> loupgaroublond: but mh is not of the form (Query b) - you can try instance Eq a => QueryPredicate a a Bool (Query x) (Query x) where perhaps.
11:33:08 <conal> loupgaroublond: i'd expect "type ManageHook = Query <??>"
11:33:19 <Lemmih> b_jonas: Well, things could be one way or the other. The GHC people picked one.
11:33:21 <conal> (if that code type-checks)
11:33:31 <b_jonas> Lemmih: I mean, if I don't have the fundep for that class,
11:33:39 <b_jonas> then obviously I need the type annotation
11:33:44 <b_jonas> to tell what class parameter to use
11:33:47 <hpaste>  loupgaroublond annotated "split into two classes, compiles" with "with managehook" at http://hpaste.org/4718#a1
11:33:50 <oerjan> newtype Endo a = Endo { appEndo :: a -> a }
11:34:01 <b_jonas> but this way, I have the fundep so I think ghc should figure it out
11:34:02 <mdmkolbe|work> oerjan: what is the point of Endo?
11:34:06 <b_jonas> that's the whole point of the fundep
11:34:16 <conal> loupgaroublond: you can simplify/generalize <&&>, <||> by using liftA2 in place of liftM2.
11:34:29 <loupgaroublond> :t liftA2
11:34:30 <oerjan> mdmkolbe|work: to use function composition as a monoid
11:34:30 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
11:34:39 <Lemmih> b_jonas: It does figure it out. It is an Int and can never be anything else.
11:34:39 <shachaf> conal: type ManageHook = Query (Endo WindowSet), I think.
11:34:46 <shachaf> conal: Are you working on xmonad? :-)
11:34:48 <conal> loupgaroublond: yep -- the Query in ManageHook is why that version type-checks.
11:34:48 <b_jonas> Lemmih: but it doesn't
11:34:51 <loupgaroublond> conal: those bits weren't mine actually
11:35:01 <oerjan> e.g. look at the default of Data.Foldable.foldr:
11:35:05 <b_jonas> because if you compile it as is pasted with ghc 6.8, it fails
11:35:06 <conal> shachaf: using?
11:35:07 <mdmkolbe|work> loupgaroublond: the suggestion from int-e is correct make the instance declaration "QueryPrediate a a Bool (Query x) (Query x)"
11:35:07 <loupgaroublond> shachaf: i'm working on xmonad :)
11:35:15 <b_jonas> at least that's what somebody said to me on the channel
11:35:20 <b_jonas> I don't have 6.8 installed
11:35:21 <Lemmih> b_jonas: Of course. You've giving it the wrong type.
11:35:25 <shachaf> loupgaroublond: Oh.
11:35:25 <conal> oh -- is that xmonad code?
11:35:27 <oerjan> 	foldr f z t = appEndo (foldMap (Endo . f) t) z
11:35:29 <shachaf> conal: Yes.
11:35:35 * shachaf wasn't keeping up, sorry.
11:35:45 <mdmkolbe|work> @src Data.Folderable.foldr
11:35:46 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
11:35:50 <conal> shachaf: i haven't tried xmonad yet.
11:35:59 <conal> shachaf: i'm enjoying linux, though!
11:36:02 <mdmkolbe|work> @src Data.Foldable.foldr
11:36:02 <lambdabot> Source not found. Are you on drugs?
11:36:07 <mdmkolbe|work> @source Data.Foldable
11:36:08 <lambdabot> Data.Foldable not available
11:36:15 <conal> lambdabot's a narc!
11:36:15 <mdmkolbe|work> @src Data.Maybe
11:36:15 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
11:36:22 <shachaf> @src Maybe
11:36:22 <lambdabot> data Maybe a = Nothing | Just a
11:36:23 <mdmkolbe|work> @source Data.Maybe
11:36:23 <lambdabot> http://darcs.haskell.org/packages/base/Data/Maybe.hs
11:36:58 <conal> loupgaroublond: do you see now why one version type-checks and the other doesn't?
11:37:22 <loupgaroublond> mdmkolbe|work, conal, Query x is the same problem i had before i did fundeps
11:38:09 * mdmkolbe|work wishes GHC had an interactive type checking system (i.e. interatively fill-in the parts GHC can't infer)
11:38:22 <mdmkolbe|work> loupgaroublond: what problem is that?
11:38:39 <dufflebunk> I'm working with moands, and I need a function which would look like: (a -> b -> c) -> M a -> M b -> M c, there aren't any, and I'm not sure how I would make it
11:39:05 <mdmkolbe|work> loupgaroublond: is MangeHook the same problem as Query x?
11:39:13 <mdmkolbe|work> @type liftM2
11:39:14 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
11:39:31 <shachaf> mdmkolbe|work: type ManageHook = Query (Endo WindowSet), I think.
11:39:38 <dufflebunk> duh, I've used that before even. Thanks mdmkolbe|work.
11:40:33 <mdmkolbe|work> shachaf: yes. I'm wondering if delcaring the instance as "Query a a Bool MangageHook ManageHook" fixes things
11:40:47 <loupgaroublond> mdmkolbe|work: nope, it clashes with other code in another module horribly
11:40:57 <loupgaroublond> i think i'm going to split it up back into two classes
11:41:26 <loupgaroublond> it won't make for quite as clean of a patch, but it works, and that's important
11:41:32 <oerjan> dufflebunk: perhaps you hit the bug in hoogle that makes it not understand monads & other higher kind types
11:45:28 <mdmkolbe|work> Is there a shorter way to write do { s <- get; x <- foo; put s; return foo }?
11:45:55 <xerox> return x perhaphs?
11:46:29 <oerjan> :t (<*)
11:46:30 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
11:46:35 <mdmkolbe|work> xerox: "get" and "put" side effect the state. but I don't want the side effects in "foo" to be seen outside
11:46:36 <EvilTerran> do you mean return x?
11:46:58 <dufflebunk> oerjan: I must have since it didn't find anything
11:47:01 <oerjan> foo <* put s would be slightly shorter
11:47:32 <dufflebunk> Thankfully #haskell doesn't have that bug and doesn't mind dumb questions.
11:47:35 <b_jonas> what does that even mean?
11:47:35 <mdmkolbe|work> EvilTerran: yes, that should have been "do { s <- get; x <- foo; put s; return x}" (sorry xerox, I mussunderstood you)
11:47:43 <b_jonas> @undo do { s <- get; x <- foo; put s; return foo }
11:47:43 <lambdabot> get >>= \ s -> foo >>= \ x -> put s >> return foo
11:48:17 <b_jonas> hmm
11:48:26 <xerox> ?docs
11:48:26 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
11:48:27 <b_jonas> don't you need lots of parenthesis in that?
11:48:28 <EvilTerran> ?pl \foo -> get >>= \ s -> foo >>= \ x -> put s >> return x
11:48:28 <lambdabot> (get >>=) . (. ((. return) . (>>) . put)) . (>>=)
11:48:36 <EvilTerran> maybe not
11:48:36 <mdmkolbe|work> dufflebunk: also note that you can do "return fun `ap` m1 `ap` m2" so you aren't limited to thinking which liftM to use
11:48:50 <oerjan> b_jonas: \ -> scopes over everything rightward
11:49:00 <mdmkolbe|work> @src liftM2
11:49:00 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
11:49:07 <b_jonas> oerjan: but around the lambdas?
11:49:21 <b_jonas> like '>>= (\ s'
11:49:25 <mdmkolbe|work> @type \f a b = return f `ap` a `ap` b
11:49:26 <lambdabot> parse error on input `='
11:49:34 <mdmkolbe|work> @type \f a b -> return f `ap` a `ap` b
11:49:34 <lambdabot> forall a a1 b (m :: * -> *). (Monad m) => (a -> a1 -> b) -> m a -> m a1 -> m b
11:49:43 <oerjan> no, a \ may come right after any operator, but is still greedy rightwards
11:49:46 <b_jonas> probably you don't, @undo likely knows the syntax more than me
11:50:08 <oerjan> quite useful for CPS style things, i understand
11:50:13 <b_jonas> oerjan: so you need parens in 'foo (\x ->' but not in 'foo `bar` \x ->'
11:50:35 <oerjan> b_jonas: yep, can use $ in the first
11:50:37 <dufflebunk> @src ap
11:50:37 <lambdabot> ap = liftM2 id
11:50:40 <mdmkolbe|work> @type \f -> f \x -> 1
11:50:41 <lambdabot> parse error on input `\'
11:50:52 <b_jonas> I see
11:50:56 <mdmkolbe|work> @type \f -> 1 `f` \x -> 1
11:50:57 <lambdabot> forall t t1 t2 t3. (Num t, Num t2) => (t -> (t1 -> t2) -> t3) -> t3
11:51:13 <mdmkolbe|work> b_jonas: heh, I'd never noticed that difference before
11:51:22 <idnar> @type \f -> f $ \x -> 1
11:51:23 <lambdabot> forall b t t1. (Num t1) => ((t -> t1) -> b) -> b
11:51:27 <EvilTerran> if you're staying in just State, not MonadState m => m, you could do something with run/exec/evalState
11:51:32 <idnar> @type \f -> f (\x -> 1)
11:51:33 <lambdabot> forall t t1 t2. (Num t1) => ((t -> t1) -> t2) -> t2
11:51:55 <b_jonas> and it's the same with if or do probably
11:51:57 <b_jonas> like
11:52:06 <desegnis> So what's the heuristics behind »f \x -> 1« being disallowed?
11:52:12 <b_jonas> 'foo `bar` if' is ok but 'foo if' isn't
11:52:27 <b_jonas> same with do and if
11:52:51 <b_jonas> and probably let or case too
11:53:42 <oerjan> b_jonas: yep they're all the same syntactic element just above operator precedences
11:53:54 <mdmkolbe|work> desegnis: my guess is that "f _" position expects many space separated args where as "f $ _" position knows there is only one arg remaining
11:54:07 <mdmkolbe|work> (due to operator precidence)
11:54:13 <oerjan> desegnis: readability i think.  it has been proposed changed
11:54:34 <mdmkolbe|work> @type \if -> if
11:54:35 <lambdabot> parse error on input `if'
11:55:02 <desegnis> hm... so »f \x -> g h« would be ambiguous if we allowed to leave out the parentheses
11:55:07 <desegnis> right
11:55:29 <desegnis> (more or less)
11:55:39 <b_jonas> oerjan: yep, and the unbounded right argument of if or let also extends as far as possible to the right, just like the body of a lambda
11:56:59 <mdmkolbe|work> desegnis: I'm not completely sure.  one could argue that the "\" should be enough to signal that there is only one remaining argument to the parser (i.e. you cant treat "\x" as f it were one arg and "->" were the next)
11:57:19 <mdmkolbe|work> @src withState
11:57:19 <lambdabot> Source not found. Maybe you made a typo?
11:57:34 <mdmkolbe|work> @source Control.Monad.State.Lazy
11:57:34 <lambdabot> Control.Monad.State.Lazy not available
11:57:38 <mdmkolbe|work> @source Control.Monad.State
11:57:38 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/State.hs
11:58:15 <desegnis> mdm, yea, that's the »less« part
12:00:03 <b_jonas> I think it's rather the 'f \x -> g `h` j' strange that would be unconfortable
12:00:17 <b_jonas> (and perhaps also layout stuff)
12:01:26 <oerjan> > ($ 4) \x -> x :: Int + 3
12:01:26 <lambdabot>  Parse error at "\x" (column 7)
12:01:57 <dolio> > ($ 4) $ \x -> (x :: Int) + 3
12:01:58 <lambdabot>  7
12:02:07 <oerjan> > \x -> x :: Int $ 3
12:02:07 <lambdabot>  Parse error at "$" (column 16)
12:02:29 <dolio> That's "x :: (Int $ 3)" I believe.
12:02:44 <mdmkolbe|work> desegnis: how do you type those funny quotes? e.g. "»less«"
12:02:46 <oerjan> dolio: the point was to check some strange parsing possibilities
12:05:15 <b_jonas> mdmkolbe|work: they're some 8859-1 characters I think
12:05:47 <b_jonas> at the positions where 8859-2 has funny variants of t I guess
12:06:23 <b_jonas> I've added some wierd non-ascii punctation to my keyboard layout recently
12:06:23 <koxinga> mdmkolbe|work: these are "guillemets". How to enter them depends on your system. Wikipedia explains it : http://en.wikipedia.org/wiki/Guillemets
12:06:24 <lambdabot> Title: Guillemets - Wikipedia, the free encyclopedia
12:06:48 <b_jonas> not those french guillamots, but the double quotes like “„” and other like   …–
12:06:52 <bart416> okay, simple question, how the hell do you get the x'th element out of a list, I can't seem to find anything for that :S
12:07:07 <b_jonas> perhaps I should also add the single quotes with shift
12:07:20 <hpaste>  mdmkolbe|ubuntu pasted "Request for function name suggestions" at http://hpaste.org/4719
12:07:32 <sjanssen> bart416: xs !! x
12:07:33 <oerjan> > [1,2,3,4] !! 3
12:07:33 <lambdabot>  4
12:07:35 <desegnis> mdm, those are book quotes as used in some European languages. It's AltGr-x, AltGr-y on a standard German keyboard layout, at least with X.org
12:07:40 <bart416> thanks
12:07:58 <b_jonas> desegnis: like French and Hungarian, but in the opposite direction
12:07:59 <b_jonas> and in perl6
12:08:18 <b_jonas> I should add those to my layout too
12:08:20 <b_jonas> hmm
12:08:50 <mdmkolbe|work> any takers on a better function name? http://hpaste.org/4719
12:08:58 <desegnis> b_jonas, oh right, the French write « cela » (original only with the extra spaces)
12:09:11 <dolio> mdmkolbe|work: Something with the word "local"?
12:09:15 <b_jonas> desegnis: yep, something like that
12:09:38 <dolio> mdmkolbe|work: Oh, you already thought of that. :)
12:10:05 <mdmkolbe|work> dolio: well you mentioning it means it may be a good idea
12:10:28 <b_jonas> it's \uBB and \uAB, right?
12:11:10 <int-e> mdmkolbe|work: preservingState maybe.
12:11:53 <xerox> I guess you could borrow `local' from Reader.
12:12:15 <dibblego> @where bananas
12:12:16 <lambdabot> I know nothing about bananas.
12:12:33 <oerjan> @go bananas lenses
12:12:34 <lambdabot> http://citeseer.ist.psu.edu/meijer91functional.html
12:12:34 <lambdabot> Title: Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire (Research ...
12:12:42 <dibblego> nice thanks
12:12:57 <mdmkolbe|work> @where+ bananas http://citeseer.ist.psu.edu/meijer91functional.html
12:12:58 <lambdabot> I will remember.
12:13:22 * Heffalump hadn't realised it was that old
12:18:05 <FunctorSalad> does this package fail to "runghc Setup.hs configure" for anyone else? http://hackage.haskell.org/cgi-bin/hackage-scripts/package/haskell-src-1.0.1.1
12:18:08 <lambdabot> http://tinyurl.com/23vlme
12:21:06 <LoganCapaldo> FunctorSalad: we re more likely to be able to help you out if you tell us _how_ it fails
12:21:42 <FunctorSalad> "Setup.hs: haskell-src.cabal:15: Invalid syntax (no colon after field name)"
12:21:59 <FunctorSalad> mb I need a newer version of cabal...
12:22:14 <LoganCapaldo> that's usually it
12:29:43 * mdmkolbe|work just tied a knot worth of a boy scout
12:30:00 <sime> hi. Just a short question: Does anybody of you know, if there's any library that's able to load .png files?
12:31:36 <LoganCapaldo> check hackage?
12:31:43 <LoganCapaldo> @where hackage
12:31:43 <lambdabot> http://hackage.haskell.org/
12:31:45 <mdmkolbe|work> sime: a quick glance at hackage shows that there is an SDL-image binding for haskell.  that will probably be able to load png images.
12:32:28 <LoganCapaldo> gd and imlib may also be capab;e
12:32:58 <sime> LoganCapaldo, mdmkolbe|work: OK, thanks. I have already checked it a bit and just wanted to know, if I've overlooked something.
12:33:38 <LoganCapaldo> Cale: Imlib bindings do png?
12:34:16 <Cale> LoganCapaldo: yes. I've been working on a better binding to Imlib, but have been taking my sweet time. :)
12:34:57 <LoganCapaldo> sime ^
12:35:37 <sime> LoganCapaldo: Jep, noted. :-)
12:36:15 * LoganCapaldo hearts this community
12:36:21 <bart416> huh, you have a floor function and not a ceil function O_o
12:36:40 <shachaf> > ceiling 5.3
12:36:40 <lambdabot>  6
12:36:42 <Valodim> ceiling
12:36:47 <bart416> oh
12:36:47 <Valodim> :)
12:37:12 <LoganCapaldo> we use long names, I mean look at how we spell popen
12:37:12 <bart416> is there any reference that lists them all?
12:37:35 <olsner> LoganCapaldo: how do we spell popen?
12:38:00 <LoganCapaldo> @hoogle runInteractiveProccess
12:38:00 <lambdabot> No matches found
12:38:09 <LoganCapaldo> @hoogle runInteractive
12:38:09 <lambdabot> System.Process.runInteractiveCommand :: String -> IO (Handle, Handle, Handle, ProcessHandle)
12:38:10 <Valodim> cc
12:38:10 <shachaf> @src RealFrac
12:38:11 <lambdabot> System.Process.runInteractiveProcess :: FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> IO (Handle, Handle, Handle, ProcessHandle)
12:38:13 <lambdabot> class  (Real a, Fractional a) => RealFrac a  where
12:38:15 <lambdabot>     properFraction                   :: (Integral b) => a -> (b,a)
12:38:17 <lambdabot>     truncate, round, ceiling, floor  :: (Integral b) => a -> b
12:39:02 <olsner> runInteractiveProcess, neat
12:39:46 <mdmkolbe|work> bart416: at the GHCI run ":info RealFrac" or ":i RealFrac", or look in the GHC library documentation
12:41:07 <b_jonas> that's no problem, you can always give a shorter name to anything you use often
12:41:20 <b_jonas> (~) = System.Process.runInteractiveProcess;
12:41:23 <EvilTerran> apart from classes
12:41:41 <LoganCapaldo> I didn't mean to imply it was a program
12:41:45 <LoganCapaldo> *problem
12:41:58 <LoganCapaldo> just that we tend to spell things out
12:42:07 <LoganCapaldo> (ceiling vs. ceil)
12:42:11 <b_jonas> yep
12:42:14 <b_jonas> it's a consistent way
12:42:25 <EvilTerran> putStrLn :)
12:42:27 <MyCatVerbs> Hey, Haskell programs generally have so few damn symbols anyway...
12:42:35 <b_jonas> on the other hand, high-level category theory abstractions tend to have short names
12:42:44 <hpaste>  (anonymous) annotated "Esolang Pre-Alpha Manual" with "(no title)" at http://hpaste.org/4721#a1
12:42:47 <EvilTerran> <*>
12:42:48 <MyCatVerbs> ...what does it matter if the average symbol length resembles War and Peace?
12:42:51 <LoganCapaldo> EvilTerran: exception that proves the rule? :)
12:42:58 <MyCatVerbs> :t <*>
12:42:58 <lambdabot> parse error on input `<*>'
12:43:00 <b_jonas> liftM, sequence, >>=, id
12:43:05 <MyCatVerbs> :t (<*>)
12:43:05 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
12:43:13 <b_jonas> and it gets shorter with higher levels
12:43:14 <EvilTerran> mistranslation from the original greek/latin/whatever it was, that, iirc
12:43:23 <LoganCapaldo> the more generic the shorter the name, the more specific the longer the name?
12:43:24 <Korollary> fst & snd
12:43:30 <b_jonas> yeah
12:43:34 <MyCatVerbs> Ah, maybe not.
12:43:42 <MyCatVerbs> The more problem-domain specific, the longer the name
12:44:22 <mdmkolbe|work> I think the rule is that mathish functions get short names and icky floating/system.* funktions get long names ;-)
12:44:26 <EvilTerran> ?hoogle (.)
12:44:27 <lambdabot> Did you mean: (.)
12:44:27 <lambdabot> Prelude.undefined :: a
12:44:27 <lambdabot> Control.Monad.State.Class.get :: MonadState s m => m s
12:44:34 <EvilTerran> ?hoogle .
12:44:34 <lambdabot> Prelude.(.) :: (b -> c) -> (a -> b) -> a -> c
12:44:35 <lambdabot> Data.Function.(.) :: (b -> c) -> (a -> b) -> a -> c
12:44:35 <lambdabot> Control.Category.(.) :: Category cat => cat b c -> cat a b -> cat a c
12:44:57 <EvilTerran> there we go. (Control.Category..) fits nicely with "it gets shorter with higher levels" :P
12:45:06 <MyCatVerbs> e.g. runInteractiveCommand, getWorkingDirectory...
12:45:44 <MyCatVerbs> rewindDirStream, isCommutableBy...
12:45:59 <b_jonas> @type isCommutableBy
12:45:59 <lambdabot> Not in scope: `isCommutableBy'
12:46:03 <b_jonas> what's that?
12:46:06 <b_jonas> @hoogle isCommutableBy
12:46:07 <lambdabot> No matches found
12:46:54 <mdmkolbe|work> @source Control.Catagory
12:46:55 <lambdabot> Control.Catagory not available
12:47:36 <mdmkolbe|work> Is Control.Category in the upcoming GHC or an extra lib?
12:47:37 <MyCatVerbs> b_jonas: I just picked it at random out of HHL. It's from QuickCheck.
12:47:45 <EvilTerran> it's in 6.8, iirc
12:50:30 <int-e> Control.Category is not in ghc 6.8. it's in the darcs head only.
12:50:39 <EvilTerran> oh, okay
12:51:44 <mdmkolbe|work> int-e: I lookforward to it.  Are there any other *interesting* category theory classes being added or maybe a guide to them?
12:52:28 <int-e> no, the change as is has no interesting effect besides breaking HXT :/
12:54:06 <oerjan> sorry about that last paste, told someone about hpaste and didn't clarify it was only for haskell
12:54:21 <int-e> and personally I believe a separate package for exploring ideas would be the right way to go for Control.Category.
12:54:28 * int-e shrugs
12:54:50 <Cale> oerjan: That's all right, but you may want to uncheck the announce box :)
12:55:15 <olsner> there, my first published esolang published
12:55:42 <olsner> http://esolangs.org/wiki/1337 - be gentle ;-)
12:55:42 <lambdabot> Title: 1337 - Esolang
12:56:52 <mdmkolbe|work> int-e: funny thing is that Catagory theory has been around long enough that it ought to be "obvious" how to build a usefull set of category related classes.  But the same is true about the number tower and look how that turned out.
12:56:54 <Cale> A friend of mine had a really nice esolang, but I haven't been able to find it online, so maybe he never put it up. It was like befunge, but connected chunks of code acted like rafts which could be pushed around by certain instructions.
12:57:40 <shapr> Cale: Contact him! We want it!
12:58:57 <FunctorSalad> mdmkolbe|work: number tower?
12:59:23 <b_jonas> someone mentioned these "futures" here which would represent values that can only be computed in the future, and which form a monad with return x being the value x computable right now, and >>= meaning computing the left one first, and then the right one
12:59:27 <mdmkolbe|work> @index Rational
12:59:27 <lambdabot> Prelude, Data.Ratio
12:59:41 <mdmkolbe|work> FunctorSalad: Rational, RealFrac, Integral, Num, etc
12:59:42 <b_jonas> that makes sense, but I don't understand how it's different from just IO
13:00:09 <FunctorSalad> mdmkolbe|work: so you mean numbers have been around for long enough, but you don't like the implementation?
13:00:30 <FunctorSalad> I'm too new to comment on the number types
13:00:37 <conal`> b_jonas: maybe Data.Future in Reactive
13:00:43 <conal`> @wiki reactive
13:00:43 <lambdabot> http://www.haskell.org/haskellwiki/reactive
13:01:12 <mdmkolbe|work> FunctorSalad: yes. (though in fairness this is mostly b/c numbers in computers are not math numbers, but rather bit-patterns and is a problem with most languages)
13:01:16 <b_jonas> maybe it was that it forms an arrow or something
13:01:18 <conal`> b_jonas: those futures are instances of Monoid, Functor, Applicative, and Monad
13:02:01 <conal`> Monad works with future futures.
13:02:04 <Cale> FunctorSalad / mdmkolbe|work: The numeric prelude is pretty good, but there are several things which are annoying about it. The most important of these, in my opinion are the fact that Eq and Show are superclasses of Num, and that abs and signum are in the Num class.
13:02:21 <mdmkolbe|work> FunctorSalad: from a math perspective you should have class (Complex x) => Real x, class (Real x) => Rational x, class Rational x => Integer x, etc.
13:02:32 <Cale> I actually *really* like the fact that we have three exponentiation operators, corresponding to the various definitions for exponentiation from mathematics.
13:02:39 <int-e> mdmkolbe|work: conversion between numbers really belongs into a multi parameter type class - which didn't exist at the time. And there's a case of premature optimization in making Show and Eq superclasses of Num.
13:02:44 <b_jonas> Cale: I have different problems with that
13:02:53 <b_jonas> with the numeric tower
13:03:13 <Cale> b_jonas: what in particular?
13:03:14 <b_jonas> on the other hand, I don't know a really perfect way to do the numeric tower either
13:03:17 <int-e> mdmkolbe|work: it could be a lot worse :)
13:03:19 <mdmkolbe|work> Cale: in practice, yes the number tower implementation is good.  it just doesn't match number theory in any obvious way
13:03:55 <Cale> I've found it for the most part to be a lovely compromise between the abstract mathematics, and the practicalities of numeric implementations on computers.
13:04:11 <b_jonas> Cale: that we don't have a good Double->Int and Double->Double variant of the floor/ceil/round/trunc functions
13:04:12 <Cale> The pure mathematical hierarchy of rings and fields, etc, isn't *quite* appropriate
13:04:36 <EvilTerran> we need dependent types, so we can have type Integer = Ring int0 intPlus int1 intTimes ;)
13:04:38 <b_jonas> only ones that convert to Integer and to those from it
13:04:51 <Cale> :t floor
13:04:51 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
13:05:00 <b_jonas> yes, but look
13:05:08 <mdmkolbe|work> Cale: since when have practicalities stoped haskell from doing the "right thing" ;-J
13:05:12 <b_jonas> > floor 1e99 :: Int
13:05:13 <lambdabot>  0
13:05:44 <Cale> mdmkolbe|work: Well, it still is the "right thing", since we want to work with floating point numbers, for instance.
13:05:55 <Cale> Those don't satisfy any reasonably nice axioms. :)
13:06:00 <b_jonas> > floor 1e20 :: Int
13:06:01 <lambdabot>  1661992960
13:06:13 <Cale> (Well, commutativity of multiplication and addition, but that's almost it.)
13:06:19 <olsner> > 1e20
13:06:19 <lambdabot>  1.0e20
13:06:39 <b_jonas> > (floor 1e20 :: Integer) `mod` 2^32
13:06:39 <lambdabot>  1661992960
13:06:48 <b_jonas> clearly it converts through Integer
13:06:54 <olsner> > (floor 1e20 :: Integer)
13:06:55 <mdmkolbe|work> Cale: actually they might.  In Scheme, they don't distinguish between float and rational.  Instead they go with exact vs inexact.  If you consider floats as just an implementation of inexact arith, then you could come up with axioms
13:06:55 <lambdabot>  100000000000000000000
13:06:56 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/4722
13:07:08 <olsner> oic
13:07:17 <Cale> mdmkolbe|work: But they don't, for example, satisfy the field axioms.
13:07:35 <Cale> The usual hierarchy we use in mathematics doesn't *quite* apply.
13:07:40 <b_jonas> I want like the libc floor and lfloor and llfloor functions,
13:07:57 <b_jonas> where floor converts from double to double efficently
13:08:09 <b_jonas> > floor (1e99 :: Double) :: Double
13:08:10 <lambdabot>   add an instance declaration for (Integral Double)
13:08:10 <lambdabot>     In the expression: fl...
13:08:24 <b_jonas> (and correctly)
13:09:04 <b_jonas> and lfloor/llfloor converts from double to int/longlong with overflow and nan converted to the right values
13:09:10 <b_jonas> (unlike floor x :: Int does)
13:09:22 <Pickles> Hi all! I'm trying to install GHC on my MacBook running Leopard. I have not yet successfully installed any version, although I have tried several, both in Tiger and Leopard. I just tried MacPorts, but got the error "GHC is required unless bootstrapping from .hc files." So I'm attempting this, having failed at every other install of GHC I tried. Thing is, I need the .hc files, and can't find any, much less any made on Leopard. Can anyone tell me where I can f
13:09:41 <b_jonas> (and the same in all four rounding modes and for float as well as double, obviously)
13:10:06 <Zao> Pickles: Your line got truncated.
13:10:15 <Pickles> thanks Zao - where?
13:10:22 <Zao> "where I can f"
13:10:27 <b_jonas> and if we keep the exact Double->Integer function like now as a useful feature for bigints, that's good too
13:10:36 <Pickles> Can anyone tell me where I can find .hc files (and hopefully those necessary for my system), or if they have gotten GHC to install successfully on Leopard? Until then, I'm stuck using Hugs to learn, and I'd like to be able to compile. Thanks for any advice / information you can offer.
13:10:44 <Zao> Pickles: You need to unpack the source tree on a platform that has a GHC, and follow the Porting guide on the wiki.
13:11:06 <thorkilnaur> Pickles, Is a binary GHC good enough for you?
13:11:06 <Pickles> yeah, that's the problem - I don't know anyone who has GHC
13:11:16 <b_jonas> oh, and I'd like UArray (Complex Double) and equal treatment of complex and real floating point in every other respect
13:11:18 <Pickles> it would be if i could get one to work - I've tried several
13:11:30 <Zao> Pickles: I suppose you've tried the pre-10.5 binary package?
13:11:34 <b_jonas> with complex using the libc functions when possible
13:11:59 <Pickles> The Porting guide mentioned finding .hc files appropriate to one's platform available for download, but I haven't found any, much less for Leopard
13:12:36 <Pickles> Zao: I tried the pre-10.5 packages on Tiger, and I've tried the 10.5 packages on Leopard, but I have not tried pre-10.5 packages on Leopard
13:12:54 <Zao> "There may be some supplied on the GHC download page, otherwise you'll have to compile some up yourself."
13:12:56 <thorkilnaur> Pickles, I have a binary GHC 6.6.1 running on a Mac OS X Leopard, would you like the details? (I will just have to shuffle around to find them...)
13:12:59 <Zao> http://hackage.haskell.org/trac/ghc/wiki/Building/Porting
13:13:01 <lambdabot> Title: Building/Porting - GHC - Trac
13:13:15 <Pickles> That would be great, thorkilnaur
13:13:53 <thorkilnaur> Pickles, Ok, just a few minutes ...
13:14:00 <Pickles> Thanks, Zao. I'm trying to follow that, but I can't make a set of .hc files without having access to a machine with GHC already installed, and I don't have such a machine available.
13:14:38 <b_jonas> and, in general, I'd like a haskell interface for all C99, POSIX, unix, linux, *bsd, glibc, *bsd libc system call and function except for functions where it _really_ doesn't make sense
13:14:46 <Cale> Pickles: you probably shouldn't have to port GHC to Leopard. I'm pretty sure someone must have already done that, and it's really a job for someone familiar with the compiler.
13:14:49 <b_jonas> but that's too much to ask
13:14:55 <Zao> Pickles: I defer to thorkilnaur then.
13:15:25 <Pickles> Cale: I'm shouldn't need to do a full port, but I think I could manage bootstrapping from the intermediate C files, if necessary
13:15:28 <Cale> Pickles: ppc or intel?
13:15:32 <Pickles> Intel
13:15:47 <Cale> http://www.haskell.org/ghc/dist/6.8.2/chakravarty/ghc-6.8.2-i386-apple-darwin.tar.bz2
13:15:48 <lambdabot> http://tinyurl.com/32u3sr
13:16:01 <Cale> There's a binary release for Leopard.
13:16:13 <Cale> You'll also apparently need Xcode 3.0
13:16:20 <thorkilnaur> Pickles, Oh, the 10.5 Leaopard I am talking about is a PPC, so maybe the answer will be no good?
13:16:35 <b_jonas> is 6.8.1 or 6.8.2 the newest ghc?
13:16:37 <Cale> (which is on the Leopard install CD, or available from developer.apple.com)
13:16:42 <Pickles> thorkilnaur: That's likely the case
13:16:42 <Cale> 6.8.2 is the newest
13:17:03 <Pickles> Cale: I've got Xcode 3.0 installed
13:17:36 <b_jonas> thanks
13:17:37 <Cale> The basic answer is that you should never compile GHC unless you're actually prepared to be hacking on GHC. :) Use binary distributions.
13:17:49 <conal`> i'm just starting to use linux, after umpty years on windows, and i'm having trouble with ghc+cabal.  I built & installed one package.  When I build a package that depends on it, I get past the configure phase, but build says "Could not find module `Control.Compose':".  Any ideas?  Remember: linux newbie, so I could be missing something very basic.
13:17:55 <b_jonas> Cale: is that for me?
13:18:04 <Cale> http://www.haskell.org/ghc/download_ghc_682.html -- they're always available from the GHC download page.
13:18:05 <lambdabot> Title: GHC: Download version 6.8.2
13:18:18 <Cale> b_jonas: the note about 6.8.2 was
13:18:47 <Cale> conal`: hmm, Control.Compose?
13:19:00 <Cale> conal`: Happen to know which package that's in?
13:19:11 <conal`> Cale: yes, from package TypeCompose.  It shows up in ghc-pkg list
13:19:16 <Pickles> I think I've tried that one already, Cale, but I am not certain why it failed. I'll give it another go and see if I come up with any problems.
13:20:14 <Cale> conal`: hmm... personally, I've found it works best if all the packages are installed globally, though I'm not certain why that is.
13:20:24 <thorkilnaur> Pickles, Just for completion: I would expect http://haskell.org/ghc/dist/6.8.2/chakravarty/ghc-6.8.2-i386-apple-darwin.tar.bz2 (see http://haskell.org/ghc/download_ghc_682.html) to work in your case, but it is not something that I have tried.
13:20:25 <lambdabot> http://tinyurl.com/2wyf92
13:20:32 <Cale> conal`: Does it show up in the main package list, or in the one specifically for your user?
13:20:52 <Cale> (i.e. is it in the list for /usr/local/lib/ghc-6.8.2/package.conf ?)
13:20:57 <Pickles> I'm trying that out, thorkilnaur. Thanks for the advice.
13:20:58 <Cale> (or equivalent)
13:20:59 <conal`> Cale: main list.  i don't have a user list.
13:21:02 <Cale> okay
13:21:25 <Cale> Make sure that the package is listed as a dependency in the cabal file for the package you're building?
13:21:34 <conal`> Cale: it is.
13:21:37 <Cale> hmm
13:21:52 <conal`> Cale: it's been building fine on windows.
13:21:58 <Cale> Which package is it?
13:22:26 <conal`> TypeCompose configures, builds & installs.  DeepArrow configures, but won't build.
13:22:52 <bart416> I'm not exactly sure what I'm doing wrong with http://hpaste.org/4723
13:23:28 <Cale> conal`: sudo cabal --global install DeepArrow  -- this works for me
13:23:36 <Zao> @src print
13:23:36 <lambdabot> print x = putStrLn (show x)
13:23:56 <Cale> bart416: avoid tab characters
13:24:06 <Korollary> bart416: why do you have a do-block in calcDist ?
13:24:06 <Cale> bart416: have your editor convert them automatically into spaces
13:24:10 <thorkilnaur> Pickles, ... and if it doesn't work in a new and iteresting way, file a bug report (http://hackage.haskell.org/trac/ghc/wiki/ReportABug). Thanks.
13:24:17 <bart416> Korollary this is my first attempt at writing something
13:24:17 <Cale> and yes, that do-block is out of place
13:24:25 <conal`> Cale: after building?
13:24:45 <Cale> conal`: that command ought to download/compile/install the package
13:24:46 <hpaste>  sjanssen annotated "(no title)" with "this should work" at http://hpaste.org/4723#a1
13:24:51 <Pickles> sure thorkilnaur
13:25:01 <sjanssen> erm, maybe not
13:25:09 <sjanssen> why the duplicate bindings for distance?
13:25:11 <conal`> Cale: I see.  how about building from my local repo?
13:25:12 <Cale> conal`: (I used cabal-install to do it)
13:25:30 <conal`> Cale: nice to know that works! :)
13:25:42 <Cale> ah, is yours a newer version?
13:26:23 <Cale> caba
13:26:26 <Cale> whoa
13:26:33 <conal`> Cale: it's probably the same version as the darcs repo but might be newer than hackage version.  in any case, i want to compile & use the darcs version.
13:26:34 <Cale> cabal --global install
13:26:37 <Cale> er
13:26:43 <qebab> Haskell keeps breaking my head
13:26:43 <Cale> sudo cabal --global install
13:26:50 <Cale> from the directory your package is in
13:26:53 <Cale> should install it
13:26:57 * qebab decides to take an hour of break
13:26:59 <hpaste>    Korollary annotated "(no title)" with "(no title)" at http://hpaste.org/4723#a2
13:27:11 <qebab> it's just so different
13:27:19 <Cale> I'll grab the darcs repo and see
13:27:19 <Korollary> bart416: I annotated yours
13:27:24 <conal`> Cale: unrecognized option `--global' -- maybe i need a super-new cabal?
13:27:31 <Cale> hmm
13:27:42 <bart416> Korollary how do I get it to actually execute that entire block of getDistance without using a do there
13:27:55 <bart416> cause if I don't place that do there it will simply stop after the first line
13:28:01 <int-e> > digitToInt '0'
13:28:01 <lambdabot>  0
13:28:26 <Cale> actually I probably have the old version :) My Cabal is the default one released with 6.8.2 (particularly, 1.2.3.0)
13:28:26 <Saizan> --global is a flag to install recently
13:28:53 <conal`> i'll grab the latest cabal & retry.
13:29:04 <conal`> isn't --global the default?
13:29:09 <Saizan> no
13:29:16 <Korollary> bart416: The putStrLn in main requires distance. In calcDist, distance depends on (I suppose all) those declarations. They will be executed then.
13:29:40 <int-e> bart416: note that the syntax is  let <bindings> in <expression>   --- that expression gives the value of the function. (distance here)
13:30:31 <Cale> okay, the darcs versions of TypeCompose and DeepArrow install fine for me when using cabal install
13:30:32 <int-e> bart416: this is different from the  let  syntax in  do  blocks.
13:30:51 <bart416> int-e I find most of the tutorials rather confusing :S
13:30:53 <Cale> I did: sudo cabal --global install  in each of their directories.
13:31:18 <Cale> If that doesn't work, you might get http://hackage.haskell.org/cgi-bin/hackage-scripts/package/cabal-install-0.4.0
13:31:19 <lambdabot> http://tinyurl.com/yss6oz
13:31:25 <Korollary> bart416: Which ones have you read?
13:31:38 <oerjan> @src ReadS
13:31:39 <lambdabot> Source not found. Maybe if you used more than just two fingers...
13:31:41 <bart416> The one on wikibook
13:31:58 <bart416> Haskell for C Programmers
13:32:05 <Korollary> bart416: I don't like that one personally
13:32:10 <bart416> Me neither
13:32:11 <conal`> Cale: thanks for checking.  i'm building the latest cabal.
13:32:15 <bart416> and I didn't bother to install a pdf reader
13:32:30 <Cale> heh, that's kind of funny. cabal-install can't seem to update itself, failing with resource busy
13:32:48 <Korollary> bart416: Give this a try: http://en.wikibooks.org/wiki/Haskell
13:32:48 <lambdabot> Title: Haskell - Wikibooks, collection of open-content textbooks
13:32:59 <bart416> uhm Korollary I tried that one
13:33:02 <Sgeo> Bye all
13:33:23 <Cale> moving the main executable out of the way works though
13:33:29 <bart416> it seems to jump over certain things that would be worth mentioning
13:33:41 <qebab> I seriously need a dead-tree book instead of all these online tutorials. I need something that I can sit down and read, digest over a night and preferrably with some exercises. Can anyone recommend something that won't cost me my food-budget for january? :)
13:34:18 <bart416> qebab it's called a library, you can go there and read the book :P
13:34:31 <bart416> assuming they have it
13:34:36 <qebab> bart416: I've looked for haskell books in my local university library, but they don't have any
13:34:37 <FunctorSalad> or even borrow it
13:34:49 <FunctorSalad> oh
13:34:53 <qebab> well, I can afford to pay £30 or so for a book
13:34:59 <Cale> qebab: Graham Hutton's new book is supposed to be really good for beginners.
13:35:01 <qebab> conversely they have a hundred Java books heh
13:35:04 <conal`> is there an "cabal unregister" command?
13:35:10 <dibblego> qebab, Graham Hutton's book is the best bang for buck
13:35:17 <dibblego> qebab, sad eh?
13:35:19 <FunctorSalad> qebab: or maybe just print out a good online tut
13:35:25 <qebab> cool
13:35:25 <wolverian> hutton has a new book?
13:35:29 <Cale> http://www.cs.nott.ac.uk/~gmh/book.html -- the paperback version is in your price range :)
13:35:30 <lambdabot> Title: Programming in Haskell
13:35:41 <qebab> yeah that looks great
13:35:49 <wolverian> ah, cool
13:37:05 <Cale> bart416: did you get that code fixed up or would you like some more help?
13:37:07 <qebab> hrm, Cale do you know how advanced it gets? My main problem so far is understanding monads and the type/typeclass system
13:37:12 <bart416> Cale I'm still trying
13:37:20 <bart416> I like to figure out things myself before I ask for help
13:37:42 <dibblego> qebab, it has a good section on laziness at the end; it covers type-classes and probably a bit about monads from memory
13:37:54 <qebab> that sounds good
13:38:09 <conal`> oops -- i forgot the --global.  how can i unregister/uninstall user packages?
13:38:26 <Cale> bart416: the multiple lets are unnecessary. A single let ... in ... with multiple declarations should work. You also don't need a do-block unless you're composing a monadic computation, which you're not doing in calcDist
13:39:02 <qebab> okay, I think I'll order that when my student loan arrives
13:39:19 <Cale> yes, it covers monads, looking at the code for the Parser :)
13:39:26 <Cale> http://www.cs.nott.ac.uk/~gmh/Parsing.lhs
13:39:34 <qebab> ah, great
13:39:54 <Cale> qebab: Have you seen my tutorials on monads?
13:40:27 <Cale> http://haskell.org/haskellwiki/Monads_as_computation
13:40:33 <Cale> http://haskell.org/haskellwiki/Monads_as_containers
13:40:36 <dibblego> has anyone written a tutorial on monads starting with concatMap on lists and whatever-it-is for Maybe and so on?
13:40:49 <qebab> Cale: no, not really
13:40:53 <bart416> Cale I keep getting http://pastebin.ca/839159
13:40:53 <Cale> http://haskell.org/haskellwiki/Introduction_to_IO -- this is just a quick blurb about how to do IO
13:41:26 <qebab> yeah, I've understood enough of the IO to write a simple (really simple) IRC bot on my own from the Network reference and with a few hints from this channel
13:41:29 <Cale> bart416: apprarently coordone !! 1 is a Char and not a String
13:41:38 <Cale> bart416: So applying read to it doesn't work.
13:41:49 <bart416> I tried [Char]
13:42:02 <qebab> it's just that my code feels so clumsy whenever I start involving a monad of some sort
13:42:02 <Cale> bart416: If you want to read the one-character string which consists of that character
13:42:04 <b_jonas> I like irc bots
13:42:07 <Cale> then you can write
13:42:14 <Cale> read [coordone !! 1]
13:42:22 <int-e> @index digitToInt
13:42:23 <lambdabot> Data.Char
13:42:27 <b_jonas> but all my irc bot code is very ugly (and buggy at some places) too
13:42:35 <qebab> I try to seperate the monad from the rest of it but it doesn't always work out
13:42:41 <b_jonas> it's mostly unstructyured code with very few functions
13:42:48 <qebab> b_jonas: I like it as a project for learning languages
13:42:53 <bart416> Cale so you have to handle it as a list with 1 item in it?
13:43:02 <Cale> bart416: If you want to apply read to it.
13:43:12 <bart416> thanks :)
13:43:13 <qebab> b_jonas: I have one that's nearly 6k lines of python code with an ingenius dynamic plugin system :)
13:43:24 <b_jonas> qebab: ah, dynamic plugins
13:43:28 <b_jonas> I didn't do that yet
13:43:30 <Cale> bart416: By any chance is it a number?
13:43:51 <bart416> the coordinates are like: A01:23:45:67
13:43:54 <qebab> b_jonas: yeah that quickly makes things more complicated but it's really fun when you get it working
13:43:58 <Cale> Data.Char has a function  digitToInt which might be more appropriate than read
13:44:02 <b_jonas> qebab: yep
13:44:14 <qebab> b_jonas: I've had mine running for 2 months and I've added plenty of functionality during those months without ever having to reboot it
13:44:34 <Cale> btw, you may also consider pattern matching
13:44:54 <b_jonas> qebab: I've run a bot for two months without having to change anything
13:45:09 <qebab> hehe, that works as well :)
13:45:14 <Cale> (and then do something like map digitToInt to convert from characters to numbers)
13:45:18 <b_jonas> but that's not an evalbot
13:45:20 <b_jonas> it's simpler
13:45:28 <qebab> mine is not an evalbot either really
13:45:43 <b_jonas> I have an evalbot too
13:45:50 <b_jonas> that one is much more buggy
13:45:58 <b_jonas> and badly designed
13:46:04 <qebab> yeah that's a much greater challenge
13:46:30 <b_jonas> so, um, let's bring this to another channel like #haskell-blah or #buubot or #jeval or whatever
13:46:46 <qebab> I looked into making a repl-bot for python but I'd have to make a separate sandbox for it and all that but it seemed too much trouble at the time
13:46:59 <qebab> right :P
13:47:43 <qebab> one of the problems with that idea by the way (last one on this!) was that there are no other ways to delimit python blocks than whitespace and that's bad for the IRC protocol
13:48:08 <b_jonas> qebab: you could allow multi-line queries which you buffer up
13:48:26 <b_jonas> I allow that in my evalbot for convenience
13:48:37 <qebab> yeah, that's an option
13:49:08 <b_jonas> or allow three special sequences that you translate to newlines, indents, and dedents
13:49:14 <EvilTerran> could have something whitespace-insentitive that preprocesses into real python
13:49:45 <b_jonas> wait, I know an example of someone doing that with python
13:49:58 <EvilTerran> ; for newline,retain indentation { for newline,indent one more } for newline,indent one less
13:50:02 <b_jonas> though it's not really for manual typing, rather for machine-generated code
13:50:25 <b_jonas> ";" can clash with normal python syntax thouhg
13:50:31 <qebab> EvilTerran: that's a problem in python because {} is the literal for dicts
13:50:33 <EvilTerran> say. maybe use some multi-character or non-ascii characters so it won't clash with existing syntax
13:50:54 <qebab> it'd be pretty cool if I could manage to do this in haskell
13:51:07 <fasta> Why does one need to specify the types of a C-function in a FFI declaration when the .h file is known?
13:51:15 <fasta> type*
13:51:16 <qebab> it's going to have to wait until my head stops hurting after a meager three hours of hacking it though :P
13:51:23 <EvilTerran> is there any ascii punctuation that's never valid in python? ` or something, say?
13:51:24 <b_jonas> fasta: I asked that in the opposite way
13:51:32 <b_jonas> why the fuck do you need to give the .h file
13:51:37 <qebab> `foo` is short for repr(foo)
13:51:38 <b_jonas> but it's logical
13:51:42 <fasta> b_jonas: when?
13:51:49 <b_jonas> it's impossible to parse the h file
13:51:51 <fasta> b_jonas: I know why you need to give the .h file.
13:51:55 <int-e> b_jonas: to avoid a warning when compiling via C
13:52:07 <fasta> b_jonas: "impossible"?
13:52:08 <int-e> or possibly invalid code
13:52:09 <bart416> so you have "var_ast0 / 5" but it doesn't like that cause that's not always an integer, how do I get it to typecast it to an integer
13:52:14 <b_jonas> fasta: yes
13:52:21 <fasta> b_jonas: because?
13:52:23 <bart416> the decimal part doesn't really matter
13:52:26 <EvilTerran> qebab, any other character on a standard keyboard, then?
13:52:29 <EvilTerran> bart416, div?
13:52:31 <fasta> b_jonas: It seems C compilers do just fine.
13:52:32 <int-e> fasta: c2hs can parse .h files. ghc can't.
13:52:33 <EvilTerran> ?type div
13:52:33 <lambdabot> forall a. (Integral a) => a -> a -> a
13:52:35 <b_jonas> only the c compiler could parse it
13:52:44 <b_jonas> but there's no way to ask the c compiler for its types,
13:52:52 <fasta> b_jonas: of course there is.
13:52:54 <qebab> EvilTerran: yeah there are a few but none that would be intuitive
13:52:56 <b_jonas> except by parsing the debugging information it emits
13:53:02 <b_jonas> at least there's no easy and portable
13:53:03 <b_jonas> way
13:53:06 <b_jonas> also,
13:53:11 <EvilTerran> ...which (out of curiosity)?
13:53:14 <b_jonas> I think it's better if you give the haskell type
13:53:15 <fasta> b_jonas: right "easy"
13:53:21 <qebab> I could use -> for indents and <- for dedents heh
13:53:31 <b_jonas> because if the haskell type is derived, and unexpectedly changes (or is just not what you think)
13:53:36 <b_jonas> then you'll get very wierd errors
13:54:21 <b_jonas> so I think it's better this way
13:54:29 <qebab> EvilTerran: anything monetary, !, §, ¤, ?, '
13:54:33 <qebab> probably more
13:54:41 <EvilTerran> well, '{ '} and '; would do, i guess
13:54:51 <qebab> true
13:55:04 <b_jonas> plus, the haskell compiler would have to mess with compiling c code when parsing your file
13:55:10 <b_jonas> which would be a bit ugly
13:55:11 <fasta> int-e: last time I used c2hs it contained some bugs and I seem to recall it was not complete.
13:55:13 <qebab> foo(); bar(); is already valid python though so I wouldn't have to think about that
13:55:34 <EvilTerran> oh right. just '{ and '}, then.
13:55:38 <fasta> b_jonas: in the case of a shared library it doesn't need to compile anything.
13:55:48 <EvilTerran> or maybe '{ and } , given that {}s have to be matched anyway
13:55:50 <b_jonas> fasta: still you have to parse the debugging info
13:55:57 <b_jonas> or whatever it takes to find out the types
13:56:16 <fasta> b_jonas: right, so it's just a non-trivial parsing task.
13:56:19 <b_jonas> though maybe it's not so bad
13:56:32 <b_jonas> because you have to read the haskell types from all the imports too
13:56:37 <fasta> You would get _free_ access to C libraries.
13:56:49 <b_jonas> but I still think the previous reason (unexpected haskell types) is good
13:56:58 <b_jonas> fasta: I don't think it would be so easy
13:57:09 <b_jonas> you have to write a wrapper around most c functions anyway
13:57:14 <int-e> fasta: what platform are you on that shared libraries contain C types of functions?
13:57:38 <fasta> The odd thing is that I know of zero language implementations that have such a parser facility. (I doubt calling C functions from VB is difficult, though)
13:57:40 <b_jonas> int-e: if they have full debugging information, then they do
13:57:49 <b_jonas> at least on modern platforms
13:57:57 <int-e> granted. but that's not a given
13:57:59 <b_jonas> stabs and whatnot
13:58:03 <b_jonas> int-e: yep
13:58:07 <b_jonas> that's the problem
13:58:16 <fasta> int-e: it's a very common situation to have a header file.
13:58:33 <bart416> k what does ghc mean with "Possible fix: add an instance declaration for (Fractional Integer)"
13:58:34 <fasta> int-e: a compiler writer should "optimize" for that case.
13:58:44 <b_jonas> the good thing with header files is that you could use a macro too
13:58:52 <b_jonas> if it behaves like a proper c function
13:59:23 <b_jonas> that is only if the haskell compiler compiles actual c code though, not just calls the function from the library
13:59:29 <EvilTerran> bart416, it means it's determined that something needs to be both an Integer and some Fractional type, but Integer isn't Fractional
13:59:37 <EvilTerran> ?instances Fractional
13:59:37 <lambdabot> Double, Float
13:59:38 <b_jonas> which it probably won't do
13:59:40 <EvilTerran> ?src Fractional
13:59:40 <lambdabot> class  (Num a) => Fractional a  where
13:59:41 <lambdabot>     (/)             :: a -> a -> a
13:59:41 <lambdabot>     recip           :: a -> a
13:59:41 <lambdabot>     fromRational    :: Rational -> a
13:59:55 <bart416> EvilTerran yes but I don't mind if the decimal part is dropped
14:00:00 <EvilTerran> bart416, in all likelihood, it means you're trying to use (/) on Integers
14:00:01 <oerjan> bart416: usually means you haven't converted between Integer and Double somewhere it's needed
14:00:02 <b_jonas> g'night now
14:00:03 <sjanssen> bart416: use 'div'
14:00:03 <bart416> and floor() and ceiling() don't work :S
14:00:14 <EvilTerran> [21:52] <EvilTerran> bart416, div?
14:00:15 <b_jonas> round ?
14:00:35 <int-e> fasta: no I don't think it's reasonable to expect a haskell compiler to contain a C parser.
14:00:41 <EvilTerran> [21:52] <EvilTerran> ?type div <lambdabot> forall a. (Integral a) => a -> a -> a
14:00:51 <EvilTerran> > 10 `div` 3
14:00:51 <b_jonas> wait, it's probably the other way, so you need a fromIntegral
14:00:52 <lambdabot>  3
14:01:02 <EvilTerran> bart416, do you see?
14:01:21 <bart416> k
14:01:46 <bart416> thanks EvilTerran
14:01:51 <EvilTerran> np
14:03:25 <jhns> Y halo thar mikael
14:03:32 <EvilTerran> ... the demo sources provided by the gtk2hs windows installer have posix-only makefiles
14:03:41 <mikael> o hi jhns
14:08:00 <phobes> Cale:  That paper on strategies using 'seq' to force computation was interesting
14:08:18 <phobes> I guess that's one way to do it :
14:08:19 <phobes> :)
14:08:29 <fasta> int-e: considering that C is the defacto standard anything that is intended to replace it for some purposes should have backwards-compatibility.
14:11:07 <bart416> fasta the only language that meets those requirements would be C++, and well, C++ is pretty much an extended C so I wouldn't even call it a new language
14:14:15 <mercury^> bart416: ofc it is a language on its own. You can use it in totally novel ways throughout the whole time.
14:14:37 <bart416> mercury^ a lot of people mix the two though :S
14:14:57 <bart416> I've seen a lot of people use sprintf and printf instead of streams, and for good reasons I'd guess
14:15:53 <mercury^> There is no good reason imo. With most compiler/library combination streams are pretty much as fast as printf these days from what I read.
14:17:10 <mercury^> Also, even if the majority of haskell users were calling C functions for io, I would not call haskell a dialect of C. :>
14:17:56 <fasta> So, we should all program in C++?
14:19:07 <bart416> mercury^ sprintf and printf have the built in type casting
14:19:15 <bart416> or whatever you want to call it :)
14:20:25 <fasta> I prefer "Built-in segfaulting".
14:21:12 <mrd> haskell printf can fail at runtime too
14:21:34 <EvilTerran> it shouldn't segfault, tho
14:22:07 <mrd> ruins all the fun
14:22:51 <Lemmih> @seen dons
14:22:51 <lambdabot> dons is in #xmonad, #haskell and #ghc. I don't know when dons last spoke.
14:29:24 <sfogarty> Hi. I'm looking into cross-compiling from a x86 machine for a IA64 cluster. What little I've been able to dig up implies this is exceedingly difficult. Any chance someone can correct me on that?
14:31:02 <sfogarty> (to clarify: I want to use ghc to cross-compile a haskell program, not cross-compile the ghc compiler)
14:31:56 <Saizan> does ghc do cross-compilation?
14:32:40 <sfogarty> That's pretty much the question :)
14:33:22 <Saizan> i don't think so
14:33:29 <byorgey> Lemmih: IIRC, dons is on vacation in Mexico =)
14:34:24 <LoganCapaldo> compile via C and cross compile the C code?
14:34:28 <LoganCapaldo> mmm pain
14:34:32 <EvilTerran> sfogarty, if you pass -fvia-C to ghc, you might be able to cross-compile the resulting C code with gcc to your target platform?
14:34:39 <EvilTerran> ach, beaten :P
14:34:45 <shapr> !paste
14:34:45 <hpaste> Haskell paste bin: http://hpaste.org/
14:34:51 <shapr> Good, it's still up!
14:34:57 <sfogarty> Beaten, but with the flag :) I will give it a shot, thank you.
14:36:11 <Saizan> i've read that the .hc files are not portable
14:36:36 <sfogarty> it looks like you also need the haskell runtime files
14:37:17 <EvilTerran> Saizan, you probably couldn't compile .hc's generated on one architecture on another one, but i thought you might be able to build them on the same arch you made 'em, but targetting a different arch
14:37:19 <sfogarty> which should exist for IA64
14:37:34 <sfogarty> oh, right!
14:37:50 <thoughtpolice> well, if you go through the ghc porting process you notice you must use the configuration from the target machine to configure and create the HC files on the host machine
14:38:18 <EvilTerran> sfogarty, if you give ghc the -C flag too, it'll stop the build process after generating the intermediate C files
14:38:21 <thoughtpolice> it might be possible to hack around with that to see if you could get it to generate .hc files for a host machine
14:38:30 <thoughtpolice> and then just copy the includes and runtime info and whatnot
14:38:39 <thoughtpolice> but for some reason I think what you're asking for would be pretty tough
14:39:22 <sfogarty> the google-mind seems to think so too. But I don't think they'll be happy if I build a compiler on their cluster.
14:39:30 <sfogarty> perhaps I simply need to find an IA64 machine.
14:39:42 <EvilTerran> isn't there a binary available?
14:40:03 <sfogarty> not that I see
14:40:13 <sfogarty> x86_64, but not IA64
14:40:37 <thoughtpolice> you'd basically need all the includes and whatnot configured to the host system, and those includes are configured in the ghc build...
14:41:03 <thoughtpolice> so either finding a box and making a binary or building it on the cluster are probably your only bets i would think
14:41:37 <sfogarty> curses. Alright, better to know that now than in two hours :)
14:42:32 <thoughtpolice> if you can find an ia64 box with ghc on it just compile your binaries with -optl-static -static i believe so you'll have stand-alone binaries
14:42:41 <thoughtpolice> that can just be sent over
14:44:30 <sfogarty> didn't even think about that. Right, thank you.
14:48:42 <sfogarty> although, curiously, I've never done that before, and haven't had any problems on computers without ghc
14:52:21 <reppie_> heh, ia64
14:53:44 <Pickles> Cale, thorkilnaur: Thanks for your help! I managed to get the 6.8.2 binary working this time around, and successfully compiled Hello World.
14:54:07 <Cale> Pickles: cool :)
14:54:36 <sfogarty> reppie: surprisingly, this is the cluster with all the available time
14:55:36 <Korollary> Imagine a cluster of those.
14:55:46 <Korollary> Wait nm
15:02:46 <bart416> isn't there any virtualisation software that allows you to emulate an IA64 machine?
15:02:53 <sfogarty> not a bad idea, actually
15:03:20 <LoganCapaldo> oh man
15:03:25 <bart416> I think vmware and virtualpc are out of the question
15:03:27 <LoganCapaldo> that emulator would be brutal
15:04:09 <sfogarty> just needs to compile one program
15:04:14 <sfogarty> well, two, I suppose, with the compiler itself
15:04:29 <bart416> OpenVZ
15:04:29 <conal> any recommendations for a java browser plugin for linux?
15:05:14 * LoganCapaldo has always used sun's
15:05:30 <LoganCapaldo> that's not really a recommendation though :)
15:06:10 <sfogarty> did suns ever run on IA64's?
15:06:32 <sfogarty> er, solaris
15:07:10 <conal> one choice is gcj.  i don't know how up-to-date it is, e.g., with Java 5.0 language/VM changes.
15:08:04 <allbery_b> sfogarty: they had at least a development platform for it
15:08:47 <sfogarty> maybe one of the old suns floating around is IA64 then
15:10:53 <sfogarty> hmn. might compiling with -O break external functions?
15:10:55 <conal> i'll try sun's.
15:11:01 <Jangler> In Hugs, when I have a longish output, sometimes it gets garbled (some bits are repeated, some are deleted, etc.) Why is that? Is it fixable?
15:15:27 <Cale> Jangler: what platform?
15:15:47 <Cale> Jangler: it might be a problem with your terminal emulator
15:16:42 <ehird`_> so, since oerjan disappeared, anyone want to help me with http://hpaste.org/4724? i'm trying to make the parser detect unmatched [s and ]s
15:17:12 <Jangler> Windows
15:17:16 <Jangler> Probably so
15:18:42 <LoganCapaldo> ehird`_: mmm
15:19:05 <LoganCapaldo> you should distinguish between everything else and [ ]
15:19:46 <ehird`_> LoganCapaldo: i do
15:19:59 <LoganCapaldo> program = command* | [ program ] where command = oneof <>-+,.
15:20:51 <ehird`_> yes
15:20:55 <ehird`_> actually command = *
15:21:03 <ehird`_> anyway, i am doing that
15:21:05 <ehird`_> read all my functions
15:21:38 <greenrd> Can someone help me prove or disprove the following claim?
15:21:49 <LoganCapaldo> parseCMd ('[', [ shoudn't be a Cmd
15:22:02 <LoganCapaldo> imo
15:22:46 <ehird`_> well, parseCmd is a bad name
15:22:48 <ehird`_> but whatever
15:22:51 <greenrd> "For all applicative functors, (\f x -> fmap second f <*> fmap ((,) (0::Int)) x) is equivalent to \f x -> fmap ((,) (0::Int)) (f <*> x)"
15:23:51 <LoganCapaldo> mmm
15:24:05 <LoganCapaldo> I think I see what you are doing
15:24:40 <greenrd> There are 4 conditions or "laws" which any applicative functor should follow
15:24:57 <greenrd> I want to prove that this claim follows from those "laws"
15:25:32 <ehird`_> LoganCapaldo: :)
15:25:52 <LoganCapaldo> I think keeping track of the "distances" etc. at parse time is complicating matters, I would parse it to the basic rep firt and then transform that seperately
15:25:53 <ehird`_> it's a strange, mutually recursive thing
15:25:58 <ehird`_> but it works apart from error reporting
15:25:59 <greenrd> (second is Control.Arrow.second, which in this context behaves like \f x -> (fst x, f (snd x)))
15:26:38 <LoganCapaldo> well for error reporting you should throw in newline nodes
15:27:11 <ehird`_> eh, the line/col thing is fine
15:27:21 <LoganCapaldo> oh wait
15:27:27 <Leimy> anyone here use, or develop Yi?
15:27:27 <ehird`_> i just don't know where to put my error "OSHI" :-)
15:27:29 <LoganCapaldo> your ints are not what I thought they were
15:27:52 <ehird`_> my ints are line/column numbers for arguments and return tuples, but related to my optimizations for the BFs
15:30:39 <LoganCapaldo> well you can use Either for this right
15:30:51 <ehird`_> uh, i guess? i'm  complete newbie
15:30:52 <ehird`_> *a
15:31:37 <LoganCapaldo> Instead of returning ([BF], String, Int, Int) return Either ErrorMsg ([BR], String, Int, Int)
15:31:49 <LoganCapaldo> it's the Error monad
15:32:10 <LoganCapaldo> youcan ake the ErrorMsg type include the line + col numbers
15:32:16 <ehird`_> OK, but /where/ does the error occur?
15:32:27 <ehird`_> i don't see where in my code i would be for an unmatched ], nor an unmatched [
15:32:35 <ehird`_> my brain is still adjusting to haskell
15:32:45 <LoganCapaldo> an unmatched [ you will always be at the end of the string
15:32:50 <ehird`_> right
15:32:51 <ehird`_> but where in the program
15:33:00 <ehird`_> and how will i know
15:34:21 <LoganCapaldo> this is what I was refferring to before, you need to distinguish between the commands and [ ] brackted programs
15:34:50 <LoganCapaldo> when you see a '[' you call teh program parse function
15:34:52 <ehird`_> i do
15:34:56 <ehird`_> i do
15:35:04 <ehird`_> read the definition of parseCmd ('[':s)
15:35:12 <LoganCapaldo> when that returns the first char of the string needs to be a ], if it's not you know you have a mismatch
15:35:42 <LoganCapaldo> iow
15:35:47 <LoganCapaldo> check for ']'
15:35:49 <ehird`_> ok
15:35:52 <LoganCapaldo> in parseCmd '['
15:35:56 <ehird`_> so i check s' to be ]
15:35:58 <LoganCapaldo> not in parseCmdList
15:36:12 <ehird`_> ok, now to figure out what haskell function checks for something starting a string :)
15:36:30 <LoganCapaldo> well that's jsut  apattern match
15:36:42 <thoughtpolice> > "a" `isPrefixOf` ['a'..'z']
15:36:44 <lambdabot>  True
15:36:49 <LoganCapaldo> case s' of ('[':_) -> horray ; _ -> failure
15:37:00 <LoganCapaldo> s/[/]/
15:37:26 <ehird`_> surely using if "a" `isPrefixOf` is better than using a case, in this case (no pun intended)
15:37:52 <ehird`_> > "]" `isPrefixOf` "]a"
15:37:53 <lambdabot>  True
15:38:03 <ehird`_> > ']' `isPrefixOf` "]a"
15:38:04 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Char'
15:38:17 <dolio> > length "\"z\" `isPrefixOf "
15:38:17 <lambdabot>  16
15:38:34 <LoganCapaldo> well it's either if a isPrfeixOf b then c else d or it's case s' of a -> c ; _ -> d
15:38:36 <dolio> > length "case  of 'z':_ -> "
15:38:36 <lambdabot>  18
15:39:32 <LoganCapaldo> eh I got my variables mixed up there
15:39:59 <LoganCapaldo> but yur not just gonna call isPrefix Of, you're gonna make a choice based on the result so it's gonna end up being about the same as the case
15:40:36 <ehird`_> your case example doth not work, LoganCapaldo :)
15:41:12 <LoganCapaldo> why cause it's full of typos and mistakes?
15:41:14 <LoganCapaldo> :)
15:41:33 <ehird`_> yes
15:46:34 <dibblego> the Jon Harrop post disappeared off reddit?
15:48:11 <dibblego> er, nothing
15:50:23 <dufflebunk> Another monad function I'm having trouble making: untilM :: Monad m => (m a -> m Bool) -> m a -> m a
15:51:15 <dufflebunk> oops, missing something there
15:51:20 <dufflebunk> that might be my problem.
15:51:56 <cytzol> yeah, you're missing that thing there
15:52:00 <dufflebunk> Nope. Still not sure: untilM :: Monad m => (m a -> m Bool) -> (m a -> m a) -> m a -> m a
15:52:26 <EvilTerran> more normal would be (a -> m Bool) -> (a -> m a) -> a -> m a
15:54:03 <ehird`_> LoganCapaldo: so i got [ matching checks working
15:54:05 <ehird`_> but not ]
15:54:17 <EvilTerran> dufflebunk, well, you'll want to start with, say, "untilM pred iter init = "
15:54:33 <EvilTerran> (predicate, iteration, initial value)
15:55:44 <dufflebunk> EvilTerran: Yeah. The problem though is I'm not sure how to do a conditional when the Bool is stuck in a monad. I'll get it eventually... I was just hoping there was an existing function to do it
15:56:13 <EvilTerran> do stop <- pred init; if stop then return init else ...?
15:56:49 <LoganCapaldo> ehird`_: now you'll want to add another equation for parseCmd (']':s) ... = explode in error unexpected ]
15:57:08 <LoganCapaldo> if I understand your question correctly
15:58:00 <dufflebunk> EvilTerran: That could do it. Thanks
15:59:27 <ehird`_> what's the thing that can either return Nothing or Just x
15:59:32 <Korollary> Maybe
15:59:34 <dibblego> Maybe
15:59:39 <ehird`_> thanks
15:59:41 <LoganCapaldo> Maybe x
15:59:53 <dibblego> LoganCapaldo is righter!
16:00:43 <Korollary> dibblego is cheerier!
16:00:47 <ehird`_> since parseCmd "" _ _ = []
16:00:50 <ehird`_> err
16:00:51 <ehird`_> Nothing
16:00:51 <ehird`_> :-)
16:00:57 <ehird`_> that is correct usage, right?
16:02:21 <Korollary> That's about right. You may also be interesed in Either.
16:02:23 <chessguy> @src Maybe
16:02:23 <lambdabot> data Maybe a = Nothing | Just a
16:02:38 <Cin> might wanna check out the chapter on types on YAHT or Gentle
16:02:48 <ehird`_> @src Either
16:02:48 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
16:02:48 <Cin> enlightening
16:02:51 <ehird`_> Cin: perhaps
16:03:03 <ehird`_> nah, i don't think Either would help
16:05:20 <Cin> oo Haddock looks shibby
16:06:10 <explicitjelly> ok, veeery dumb question
16:06:34 <explicitjelly> in a haskell interpreter, how do you define a function using the interactive interpreter?
16:06:46 <LoganCapaldo> let f x = x + `1
16:06:59 <LoganCapaldo> ` not necessariy or even recommended
16:07:05 <ehird`_> bleargh
16:07:06 <allbery_b> you can define a temporary one with let.
16:07:09 * LoganCapaldo typos again
16:07:18 * allbery_b is slow
16:07:46 <explicitjelly> thanks a lot
16:10:29 <Svrog> conal: how did you go with double buffering and opengl?
16:10:41 <ehird`_> :| hm
16:11:42 <conal> Svrog: i tried the GLUT operation (together with wxhaskell for GUI).  it doesn't seem to make any difference.  but i have other problems to track down as well.
16:11:51 <ricky_clarkson> > head []
16:11:51 <lambdabot>  Exception: Prelude.head: empty list
16:11:55 <Svrog> oh right
16:12:02 <ricky_clarkson> How would you programmatically handle that exception?
16:12:07 <Svrog> have you looked at sdl?
16:12:11 <conal> Svrog: i had trouble with GLUT on 6.8.1 (in windows), but not in 6.8.2.
16:12:22 <conal> Svrog: just a bit.
16:12:23 <Svrog> ah
16:12:34 <conal> Svrog: do you use sdl?
16:13:07 <Zao> Svrog: initialDisplayMode $= [DoubleBuffered, WithDepthBuffer] -- for glut
16:13:23 <Svrog> i used to use it - but for commercial stuff it's always felt a bit unprofessional to me to i ended up writing my own libs to handle that stuff
16:13:32 <Svrog> glut's even worse in that respect
16:13:45 <Korollary> ricky_clarkson: See Control.Exception for GHC
16:14:28 <ehird`_> help! in inf-haskell, hwo do i abort evaluation?
16:14:38 <Zao> I saw there was a GLFW library added the other day to hackage.
16:14:40 <mrd> C-c C-c
16:14:46 <Svrog> i like glfw better than both glut and sdl but it's not as mature as sdl
16:15:10 <conal> Svrog: what does glfw give you?
16:15:57 <conal> btw, is opengl thread-safe?
16:16:31 <Svrog> well for simple demos and the like glfw should be as good as glut or sdl - it can set video modes, handles mouse and keyboard input, etc
16:16:48 <Svrog> no opengl is not thread safe
16:16:50 <Svrog> well
16:16:53 <Svrog> sort of
16:17:00 <Svrog> you can use the same context from multiple threads
16:17:08 <Svrog> as long as only one thread actively uses the context
16:17:19 <ricky_clarkson> Korollary: Thanks.
16:17:26 <conal> Svrog: got it.  thanks.
16:17:47 <Svrog> im pretty sure that's the case under windows, linux and os x anyway
16:21:12 <Svrog> most of the issues ive had with glfw were under os x - there was an issue with antialiasing and another one where it couldnt differentiate between different shift keys as it's using the carbon api - there were some other small things
16:28:24 <Svrog> conal: how does Data.Reactive cache values?
16:30:33 <conal> Svrog: yes
16:30:58 <conal> Svrog: cheap & automatic caching is one of the motivations over DataDriven
16:31:05 <conal> Svrog: oh -- "how"
16:31:17 <Svrog> yeah but i just cant quite get my head around how it works
16:31:31 <Svrog> its a very interesting library though
16:32:02 <conal> Svrog: the caching technique was a big aha for me.  it's in <*>
16:32:13 <Svrog> oh
16:32:43 <conal> Svrog: which deserves a comment at least!
16:32:53 <conal> i'll have a paper about DataDriven & Reactive.
16:32:59 <Svrog> cool :)
16:34:47 <conal> Given rf <*> rx, either rf or rx can change first, say rf changes to rf'.  then the next version of the application will be rf' <*> rx.
16:35:04 <conal> but if rx changes to rx', then rf <*> rx'.
16:35:42 <conal> Svrog: it occurs to me that i might not be answering your question.
16:36:41 <conal> what i just explained (in brief) is how rf <*> rx remembers the non-changing part when the other part changes.
16:36:42 <Svrog> well every hint is useful in trying to get my head around how it works :)
16:37:14 <Svrog> btw, does the paper compare datadriven and reactive with other approaches to frp? so far yampa/afrp make more sense to me than the other approaches and i can't tell the pros and cons of each approach
16:37:33 <conal> Svrog: it certainly will make the comparison.
16:37:39 <Svrog> great
16:37:57 <conal> and i'll have a third new approach as well that is more closely related to yampa
16:38:02 <Svrog> oh nice
16:38:16 <conal> Svrog: interested in functional animation & reactivity?
16:38:21 <Svrog> very
16:38:34 <Svrog> im using yampa for a project
16:38:41 <conal> nifty.  about what?
16:39:07 <Svrog> a 3d engine
16:39:59 <conal> Svrog: if you're using yampa, i guess you're doing *functional* (non-IO) 3D?
16:40:43 <noteventime> Svrog: Are you the author of Frag?
16:41:08 <conal> nope.  of Fran though.
16:41:11 <conal> Svrog: i've done several functional graphics designs and have a pretty good feel for it.  if you'd like design feedback, let me know.
16:42:07 <Svrog> well im trying to - trying to write some code so that scene description is high level and shading is a bit like your approach in vertigo only using glsl instead of arb shaders
16:42:13 <Svrog> noteventime: no
16:42:34 <Svrog> progress is pretty slow
16:42:40 <conal> Svrog: nifty.  doing exactly that has been on my list.
16:42:47 <conal> (vertigo via glsl)
16:42:50 <noteventime> Svrog: ok :-) Just got curious, as you were working on a functional 3D engine
16:43:01 <Svrog> yes
16:44:05 <conal> Svrog: are you in school?
16:44:23 <conal> in .au?
16:44:35 <Svrog> no - im doing this so i can hopefully start a company and dont have to work on crappy c++/java/c# projects anymore :)
16:45:22 <conal> i hope it works out for you.
16:45:35 <conal> let me know if you'd like some design feedback, etc.
16:45:40 <Svrog> thanks :)
16:45:40 <fnord123> url for vertigo?
16:45:47 <conal> @where vertigo
16:45:47 <lambdabot> I know nothing about vertigo.
16:45:53 <conal> @where+ http://conal.net/Vertigo
16:45:53 <lambdabot> Nice!
16:46:11 <Svrog> vertigo is great
16:46:28 <conal> thanks!
16:46:49 <conal> i've been wondering how best to resurrect it.
16:47:07 <fnord123> requires C# :(
16:47:22 <conal> fnord123: yeah -- i haven't been able to use it myself in quite a while.
16:47:33 <conal> is it still possible to use the old assembler-style shaders in opengl?
16:47:40 <Svrog> yes it is
16:47:45 <Svrog> but it's not recommended
16:48:28 <conal> i'm interested in re-doing & modernizing vertigo.  i've been waiting for someone interested in collaborating.  more motivating for me.
16:48:39 <Svrog> id definitely be interested
16:48:49 <conal> Svrog: cool.  let's do it.
16:48:58 <conal> how about dropping me some email with contact info?
16:49:10 <conal> then we can exchange ideas about how to proceed.
16:49:19 <conal> it might be easy with glsl.
16:49:29 <Saizan> Data.Reactive is better suited for when generation of events doesn't depend on consuming them or i'm misunderstanding?
16:50:18 <conal> Saizan: i don't understand: "when generation of events doesn't depend on consuming them"
16:51:14 <jsnx> conal: would your version be dependent on Windows?
16:51:31 <conal> jsnx: definitely not!  i'm done with the Windows ghetto.
16:51:34 <Svrog> with glsl it's easier yes
16:51:54 <Svrog> in some ways much easier - but on the other hand there's a lot more stuff to support
16:52:07 <Svrog> conal: check pm
16:52:28 <conal> jsnx: i'm typing on my new linux machine (old laptop).
16:52:37 <conal> Svrog: i'm not seeing a pm.  hm.
16:52:43 <Svrog> oh
16:53:05 <Svrog> ill just email you with my contact details then
16:53:23 <Saizan> well, i've this problem: parse a network packet with size-variable fields, only after having parsed the header with the sizes i know how many more bytes i need to read. so if bytesread is a Event, i need to trigger a new Future in that event based on consuming some previous future
16:53:27 <conal> Svrog: thx.  odd.  pm usually works for me.  maybe something with my new setup (ubuntu).
16:56:19 <jsnx> Svrog: pm'd you
16:56:48 <Svrog> jsnx: i replied - im guessing it may be my irc client that doesnt work heh
16:56:55 <sjanssen> Svrog: are you registered?
16:56:58 <jsnx> Svrog: hmmm
16:57:00 <Svrog> no
16:57:05 <Svrog> thata might be it
16:57:07 <Svrog> heh
16:57:12 <sjanssen> Svrog: you can't send messages unless you're registered
16:57:13 <Svrog> should register
16:57:18 <Svrog> aah
16:57:24 <jsnx> Svrog: yeah, i did not get your message -- but you got mine?
16:57:29 <Svrog> jsnx: yes
16:59:17 <Svrog> conal: you couldn't see my messages because i havent registered a username yet
16:59:24 <conal> Svrog: oh!
16:59:32 <conal> urg -- bumped off my wifi
17:00:19 <fnord123> conal are you still at msft research?
17:01:21 <conal> fnord123: i left 5+ years ago.  now i work at home in the woods in central-northern CA.
17:02:17 <conal> fnord123: fnord123 == spot?
17:02:31 <fnord123> spot?
17:02:34 <fnord123> i am not spot
17:03:03 <conal> fnord123: ok
17:03:13 <conal> (sounds like leonard nimoy)
17:03:50 <chessguy> "i'm a doctor, not a spot"
17:04:05 <chessguy> oh, wrong character
17:04:10 <Svrog> hehe
17:04:57 <conal> wow -- interns sought for electric sheep: http://draves.org/blog/archives/000522.html
17:04:58 <lambdabot> Title: spot blog: Electric Sheep Seeks Interns
17:07:13 <fnord123> I'm doing some haskell work with OpenGL and I can't seem to escape the io monad for long. So I'm interested in seeing functional reactive animation work going somewhere. :)
17:08:15 <conal> fnord123: great.  IO seems to be a hard habit for many to break.  it's an art to tease a purely functional essence away from the presentation stuff.
17:09:05 <conal> fnord123: if you have an example of where things get IO-ish, i could make suggestions.
17:13:25 <Saizan> conal: the only way to feed events with values is from IO, right?
17:14:46 <conal> Saizan: as a seed, that's it so far.  wouldn't be hard to add other ways, given the simplicity of the design.
17:18:30 <conal> Saizan: do you have something in mind?
17:22:51 <Saizan> nothing precise, just trying to see if reactive could solve my problem of dynamically feeding more input to a parser basing the decision to do so on the parsing result so far
17:24:02 <FunctorSalad> hey guys I installed the newest Cabal but still the .cabal file of this project doesn't work for me :( http://hackage.haskell.org/cgi-bin/hackage-scripts/package/haskell-src-1.0.1.1
17:24:04 <lambdabot> http://tinyurl.com/23vlme
17:24:16 <FunctorSalad> "Setup.hs: haskell-src.cabal:15: Invalid syntax (no colon after field name)"
17:25:33 <DukeDave> Hey gang, I've just moved over from hugs to ghci and having set +t I'm getting types like "it :: Integer". Can someone explain the "it" component?
17:25:42 <Saizan> FunctorSalad: weird, what does ghc-pkg list prints?
17:26:26 <Saizan> DukeDave: it is the variable each expression is bound to when typed at the prompt
17:27:17 <hpaste>  FunctorSalad pasted "ghc-pkg -list" at http://hpaste.org/4725
17:27:34 <DukeDave> Oh, hang on, it means "it" as in "it is of type .."
17:27:36 <DukeDave> ?
17:27:46 <FunctorSalad> maybe one of you can try to install the package in question, maybe it is really broken?
17:28:08 <Liskni_si> DukeDave: That would be the type of the whole expression you have it
17:28:12 <sjanssen> DukeDave: no, 'it' is a variable
17:28:20 <Cin> dukedave: no, as in what ghci internally names your expression
17:28:29 <sjanssen> DukeDave: try entering an expression, then entering 'it'
17:29:19 <DukeDave> Gotcha, makes sense now. Thanks all :D
17:30:21 <FunctorSalad> btw, is lambdabot really the girl on the lambdabot website? :D
17:32:54 <Saizan> FunctorSalad: it works here
17:33:09 <FunctorSalad> Saizan: hmm, thanks for checking
17:33:25 <Saizan> sure you don't have old Setup.o/Setup.hi around?
17:33:54 <FunctorSalad> oh, thought this is overwritten when I run ghc.
17:34:22 <FunctorSalad> works now :)
17:34:27 <FunctorSalad> @karma+ Saizan
17:34:27 <lambdabot> Saizan's karma raised to 7.
17:36:20 <Saizan> :)
17:37:12 <Saizan> ghc doesn't check if a package has been updated between compilations, i think there's some work in this direction though
17:42:14 <brx> (I can't wait for my ipod touch to arrive)
17:42:26 <chessguy> iphone ftw!
17:43:01 <brx> .. bah wrong channel, sry
17:43:40 <chessguy> how do you send to the wrong channel when you're only in one channel?
17:44:17 <FunctorSalad> hidden channels :o
17:44:31 <brx> false assertion
17:44:34 <shachaf> chessguy: Perhaps not all of brx's channels are visible, or this is on another server, or not in IRC at all?
17:45:10 <brx> (I am also in emacs)
17:45:17 <brx> +#
17:45:20 <chessguy> i've never heard of hidden channels
17:45:35 <qpu> that's because they are a secret!
17:45:49 <shachaf> chessguy: See? brx is in one-and-a-half channels. :-)
17:46:04 <chessguy> oh, WHOIS only lists channels that that user shares with me. wierd
17:46:14 <shachaf> chessguy: Not necessarily.
17:46:27 <chessguy> bah. whatever
17:46:43 <Zao> chessguy: If the user is invisible, he won't reveal channels.
17:46:53 <Zao> The same goes for +s channels, usually.
17:47:52 <FunctorSalad> #emacs is hidden because it is a secret conspiracy against #vi :)
17:48:22 <Cin> chessguy: +i mode
17:48:57 <shachaf> FunctorSalad: It looks like ##vi has 5 people, including Chanserv and me.
17:49:04 <shachaf> FunctorSalad: Or are they hidden too?
17:49:12 <bparkis> is there a function with type signature (a -> b) -> (b -> a)?
17:49:19 * shachaf goes back on topic, ot something like that.
17:49:27 <shachaf> bparkis: How would such a function work?
17:49:32 <Zao> :t flip
17:49:33 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
17:49:47 <Zao> Oh right. c.
17:50:39 <chessguy_> @hoogle (a -> b) -> (b -> a)
17:50:39 <lambdabot> No matches, try a more general search
17:50:43 <shachaf> bparkis: What's f (const 0) 0?
17:52:25 <allbery_b> <bparkis> is there a function with type signature (a -> b) -> (b -> a)?
17:52:51 <allbery_b> how would that work?  functions are not guaranteed to be invertible, nor is there any general algorithm for inverting a random function
17:52:55 <bparkis> does the curry-howard correspondence mean that nothing can have a type signature that is not a theorem when interpreted as a logical formula?
17:52:58 <mikael> use the curry-howard isomorphism, luke!
17:52:58 <FunctorSalad> shachaf: so f would at least have to pick on element from every type?
17:53:04 <FunctorSalad> *one
17:54:19 <FunctorSalad> allbery_b: f would not have to actually invert the function
17:54:28 <shachaf> FunctorSalad: What do you mean?
17:55:05 <FunctorSalad> shachaf: f (const 0 :: b -> Int) 0 would get us some element of b, no?
17:56:11 <shachaf> How about «f (\x -> if x == 11235 then 1 else 0) 1»?
17:57:05 <FunctorSalad> huh? noone said what it has to do on elements. he simply wanted something that maps a->b functions to b->a functions
17:57:32 <shachaf> FunctorSalad: For any a and b.
17:57:41 <shachaf> FunctorSalad: How do you produce any a at all?
17:57:54 <bparkis> I think the curry howard isomorphism prevents it
17:57:56 <shachaf> FunctorSalad: Given (a -> b) and (b)?
17:58:06 <bparkis> but i'm testing my understanding of it
17:58:22 <shachaf> bparkis: Well, it doesn't prevent it, but it shows why it's prevented. :-)
17:58:24 <FunctorSalad> shachaf: that's what I meant. you'd have to chose one element from every type a, I think
17:58:25 <clanehin> you might be able to write some kind of arrow that would support (a -> b) -> (b -> a) if each component was also invertable, and stuff
17:58:58 <monochrom> Let f :: (a->b) -> (b->a) be given. Let g:a->b be given. Then f g . g :: a->a, g . f g :: b->b.
17:59:40 <monochrom> Do you know that there are severe restrictions on functions of type a->a?
17:59:59 <shachaf> FunctorSalad: So, how do you produce a value :: forall a. a?
18:00:35 <FunctorSalad> can't the value depend on a?
18:00:42 <FunctorSalad> monochrom: no, what are they?
18:00:56 <monochrom> Either divergence or the identity function.
18:01:20 <shachaf> FunctorSalad: Do you mean something like (Exists a) => (a -> b) -> (b -> a)?
18:01:39 <monochrom> See for example "Theorems for Free".
18:04:24 <FunctorSalad> shachaf: I guess I don't quite understand this type quantification yet. but mathematically, I meant this: for every type B (lets assume there are no empty types), pick some value x_B of type B (axiom of choice). then if g :: T -> S, define f g = const x_T
18:05:13 <monochrom> That requires dependent type or type class or OOP or C++ operator overloading.
18:05:22 <FunctorSalad> I'm probably misunderstanding something basic...
18:07:04 <shachaf> FunctorSalad: Why do you assume there are no empty types?
18:07:43 <shachaf> FunctorSalad: And even if there are, how do you actually produce x_T?
18:07:52 <FunctorSalad> shachaf: well, if there are then it's obvious it won't work since if B is empty, there is no function at all to B
18:08:10 <FunctorSalad> so we'd have to exclude empty types
18:08:14 <shachaf> FunctorSalad: Yes.
18:08:39 <shachaf> FunctorSalad: Which is one reason a function :: forall a b. (a -> b) -> b -> a doesn't work.
18:09:26 <FunctorSalad> I still don't get the deeper reason
18:09:44 <FunctorSalad> I suppose it is something about these arbitrary choices.
18:09:51 <EvilTerran> incidentally, that's not really the axiom of choice
18:10:22 <shachaf> FunctorSalad: How do you actually get an x_T for any T?
18:10:59 <FunctorSalad> shachaf: of course you can't give an algorithm, not given any additional information about the universe of types
18:11:09 <FunctorSalad> EvilTerran: ?
18:11:25 <EvilTerran> may i suggest class Exists a where exists :: a;? given that, :: forall a b. Exists a => (a -> b) -> b -> a would be possible, albeit not in a particularly interesting way
18:11:40 <EvilTerran> (\_ _-> exists)
18:12:35 <shachaf> EvilTerran: That's just passing an a as an argument.
18:12:51 <EvilTerran> you could look at it that way, yeah
18:13:20 <monochrom> It's a little bit of dependent type.
18:13:42 <mikael> I bet if you import Test.QuickCheck you can just define f g = arbitrary
18:13:51 <FunctorSalad> EvilTerran: what was wrong with my use of AC?
18:17:23 <EvilTerran> hm... "given any set  of mutually disjoint nonempty sets, there exists at least one set that contains exactly one element in common with each of the nonempty sets."
18:18:36 <EvilTerran> i guess you could call the set of all non-empty haskell types, with each value annotated with its type, "a set of mutually disjoint nonempty sets"
18:18:53 <EvilTerran> but it's a finite one. AoC is overkill. ;)
18:19:42 <FunctorSalad> uhm, it is equivalent to existence of choice functions for sets of sets (disjoint or not)
18:20:04 <FunctorSalad> EvilTerran: AC is not overkill for infinite collections of finite sets.
18:21:34 <fnord123> what is AoC?
18:21:34 <EvilTerran> meh. suit yourself. I'm by no means an expert in set theory, so i may be wrong
18:21:48 <EvilTerran> that definition was me quoting http://mathworld.wolfram.com/AxiomofChoice.html , incidentally
18:21:48 <lambdabot> Title: Axiom of Choice -- from Wolfram MathWorld
18:21:59 <FunctorSalad> EvilTerran: I was using the eqv version "for any set of sets S, there is a f: S -> union S such that f(A) in A".
18:23:28 <FunctorSalad> and I thought there were infinitely many haskell types
18:23:48 <EvilTerran> in theory, maybe
18:24:01 <mikael> if you have a type a, Maybe a is another type
18:24:06 <FunctorSalad> Int, (Int,Int), (Int,Int;Int), ....
18:24:11 <EvilTerran> quite
18:24:50 <LoganCapaldo> for an infitinte number of types all you need is one type and one type constructor with kind * -> *, right?
18:25:07 <LoganCapaldo> Maybe, and () give you an infinite number of types right?
18:25:13 <LoganCapaldo> or () + ->
18:25:42 <EvilTerran> it's late. i reserve the right to talk utter balderdash. ;)
18:26:19 <FunctorSalad> LoganCapaldo: yeah though in this case you could probably construct a value for every type
18:26:27 <FunctorSalad> (by induction)
18:26:54 <FunctorSalad> EvilTerran: ok, I was only set-theory-lawyering because you said I was wrong :)
18:27:33 <EvilTerran> as you say, by induction, it's probably possible to do the proof without the AoC. that's all i meant.
18:28:06 <FunctorSalad> dunno how the universe of types is defined exactly
18:29:58 <EvilTerran> if everything were Typeable (maybe even Data would be needed), it'd be possible to construct a haskell function to produce a non-bottom value of any non-empty type, i think
18:30:45 <EvilTerran> not necessarily monomorphically of that type, though
18:31:21 <EvilTerran> (easy counterexample; any data/newtype with a phantom type parameter)
18:33:47 <FunctorSalad> ok, that's over my head for now
18:34:17 <EvilTerran> data Foo a = Foo
18:34:51 <FunctorSalad> oh, "monomorphically" as opposed to polymorphically, not as in monomorphism?
18:35:07 <EvilTerran> it's much the same thing, in terms of the DMR
18:35:36 <EvilTerran> monomorphism restriction = "things that look like constants can't be polymorphic"
18:35:45 <EvilTerran> ish
18:36:40 <FunctorSalad> ah ok, Foo isn't a monomorphism
18:40:38 <FunctorSalad> I'll better stop embarassing myself about this topic now
18:43:54 <FunctorSalad> (and pick another topic for that :))
18:59:32 <loupgaroublond> in retrospect, the type problem i was bugging you all about earlier, splitting it into two classes, gooood idea.....
19:29:09 <Robert1> doesnt ghc work on 64 bit *BSDs?
19:30:05 <shachaf> Robert1: Doesn't it?
19:30:28 <Robert1> shachaf: not according to BSD's package systems
19:31:48 <Zao> Robert1: If you managed to build it yourself, it would probably work.
19:32:20 <Robert1> Zao: well its locked against i386 with pkgsrc
19:33:54 <Zao> Robert1: Which means you have to crosscompile, I suppose.
19:34:28 <Zao> Robert1: The ports port downloads a minimal binary ghc suite to bootstrap the one you're installing.
19:34:45 <Zao> I suppose there's no others than i386 in there yet.
19:35:45 <Robert1> Zao: well i dont use freebsd, and ports port is also locked against i386
19:36:29 <Zao> Robert1: It also doesn't support FBSD 7.0 yet either :(
19:36:37 <Zao> New default gcc and libc, I believe.
19:36:54 <Robert1> well freebsd isnt my main consern anyway
19:38:13 <rue> Robert1: I have 6.6.1 running on FreeBSD 6.2R 64
19:38:23 <Robert1> rue: really?
19:39:30 <rue> http://www.mail-archive.com/glasgow-haskell-users@haskell.org/msg12189.html
19:39:30 <lambdabot> Title: Re: ghc-6.6.1 for FreeBSD/amd64 binary distribution, http://tinyurl.com/2fv256
19:39:47 <rue> I think that one, I do not remember anymore :P
19:40:16 <rue> You should be able to use that to build yourself a custom version
19:40:30 <Robert1> rue: did you compile it your self?
19:41:31 <rue> That one is a ready binary
19:41:43 <Robert1> well im not using freebsd
19:48:52 <rue> Robert1: Give it a try, NetBSD of course has F binary compat anyway but if you are running OpenBSD, you may need to get creative
19:49:23 <Robert1> rue: hmm i shall try it on netbsd amd64
19:54:28 <wy> I found that heterogeneous lists are really needed in GUI applications
19:54:55 <LoganCapaldo> what? really? why?
19:55:08 <wy> I'm wondering how to use HList
19:55:46 <Lemmih> You almost never want HList.
19:56:18 <LoganCapaldo> I can't even think of where to use a heteregenous list in gui programming, much less a necessary one. I'm really curious
19:56:44 <wy> In Gtk2Hs.. but maybe there should be redesign of gtk?
19:56:51 <nelhage> Can someone tell me whether this looks like expected behavior for Parsec.Expr? http://paste.husk.org/10628
19:57:28 <nelhage> Basically Parsec.Expr parsers seem to not like two prefix operators in a row, e.g. --5
19:57:48 <LoganCapaldo> woud you mind elaborate on the scenario where you want to use hetereogenous lists?
19:58:03 <wy> I have three group of buttons, two separaton bars separating them. But I can't use something like mapM_ (\widget -> boxPackStart vbox widget PackNatural 0) (boxgroup1++[sep1]++boxgroup2++[sep2]++boxgroup3) to display them
19:59:01 <Lemmih> wy: You can if you cast them to Widget's.
19:59:11 <LoganCapaldo> I'm guessing all the widgets are in a class which is why you can expect that boxPackStart to work?
19:59:38 * LoganCapaldo notes that Lemmih seems to actually know something about gtk2hs and shuts up
19:59:57 <wy> LoganCapaldo, They are all widgets.
20:00:15 <wy> Lemmih, oh I haven't been to the part yet
20:00:19 * LoganCapaldo was going to offer up existensionals
20:00:36 <allbery_b> wy: they are, but not to the type system
20:00:46 <allbery_b> but gtk2hs provides castTo... operations
20:01:42 <allbery_b> if you cast them to Widgets then they all have the same type and can be put in a list and any Widget operation applied to them
20:02:03 <allbery_b> (this is how gtk2hs simulates OO)
20:05:16 <wy> still a little inconvenient, but it's better
20:05:59 <wy> I hope intersection types be there soon
20:06:44 * LoganCapaldo fears intersection types
20:10:43 <wy> LoganCapaldo, why?
20:11:06 <LoganCapaldo> looks like  acan to me ;)
20:12:45 <wy> I guess it's good. Because you can always know what's the common classes in the list, and if you use a method not supported by those classes, there is a type error
20:14:03 <wy> >   mapM_ (\widget -> boxPackStart vbox widget PackNatural 0)
20:14:03 <wy> >             ([castToWidget label1] ++ map castToWidget boxgroup1 ++ [castToWidget sep1] ++
20:14:03 <wy> >              [castToWidget label2] ++ map castToWidget boxgroup2 ++ [castToWidget sep2] ++
20:14:03 <wy> >              [castToWidget quitbox])
20:14:04 <lambdabot> Unbalanced parentheses
20:14:04 <lambdabot> Unbalanced parentheses
20:14:04 <lambdabot>   parse error on input `}'
20:14:04 <lambdabot>   Not in scope: data constructor `PackNatural'
20:14:30 <wy> Aha. So now all the boxes are packed in one express
20:15:34 <davidL> Is this photoshopped or does someone actually have the y combinator tattooed on their arm? http://www.flickr.com/photos/carlzimmer/1414689773/
20:15:35 <lambdabot> Title: The Y Combinator.jpg on Flickr - Photo Sharing!
20:16:56 <LoganCapaldo> I knew a guy with the madelbrot set ttatoted across his back, and i and sqrt -1 _scarred_ into the back of his ankles
20:17:21 <LoganCapaldo> so I have no doubt someone out there has the y combinator
20:18:00 <dibblego> I saw a guy (studying Physics) with a lambda tattooed on his arm
20:18:09 <ricky_clarkson> Shouldn't it be sqrt (-1) ?
20:18:32 <LoganCapaldo> sure :)
20:18:46 <LoganCapaldo> his was using the "check mark" notation
20:18:53 <LoganCapaldo> he had the video of when he had it done
20:18:55 * LoganCapaldo shivers
20:19:06 <LoganCapaldo> they sliced strips of flesh off
20:19:12 <LoganCapaldo> did not look pleasant
20:19:55 <ricky_clarkson> Not for me thanks.  I'm quite attached to my flesh.
20:20:22 <FunctorSalad> davidL: hmm, I'm not a tatoo expert, but looks a bit photoshopped to me
20:20:42 <FunctorSalad> looks a bit superimposed
20:20:48 <FunctorSalad> but OTOH I can hardly keep my eyes open
20:23:01 <FunctorSalad> 'night
20:38:17 <loupgaroublond> what does this mean: Functional dependencies conflict between instance declarations:
20:42:34 <LoganCapaldo> I would guess you have a class like class A a b | a -> b and two instances like instance A Foo Bar instance A Foo Baz
20:43:02 <monochrom> Yeah, if you declare a->b, then for each a there should be at most one b.
20:43:02 <LoganCapaldo> but that's just a guess
20:43:15 <loupgaroublond> ah....
20:43:19 <loupgaroublond> andi have more than one b
20:43:30 <loupgaroublond> damn
20:44:01 * LoganCapaldo thanks his teachers for his reading comprehension skills
20:46:09 <loupgaroublond> for this:  -fallow-undecidable-instances, what's the LANGUAGE pragma i can put in a .hs file?
20:46:36 <LoganCapaldo> UndecidableInstances IIRC
20:46:56 <monochrom> Yes.
20:48:00 <loupgaroublond> thanks
20:56:27 <boegel> dons: ping
20:57:06 <Lemmih> boegel: I've heard he's on vacation in Mexico.
20:57:19 <boegel> Lemmih: ah, ok
20:57:34 <boegel> Lemmih: I was going to ask him if he's getting ready to party :-)
20:58:32 <ricky_clarkson> @bab en es ping
20:58:33 <lambdabot>   silbido de bala
20:59:55 <wy> I found that I can't cast a HScale to a VScale
21:01:56 <glguy> you need additional reagents?
21:02:13 <LoganCapaldo> hehe
21:02:17 <LoganCapaldo> reagents
21:02:41 <LoganCapaldo> Stone.philosophize hscale
21:02:45 * glguy casts Delayed Blast Fireball
21:02:50 * glguy afk
21:07:15 <wy> This ridiculous: setDigits :: (ScaleClass self) => self -> Adjustment -> IO () said I can do this to any type of class ScaleClass, but I can't put them into a list and map this function
21:08:13 * LoganCapaldo mentions existensionals again
21:12:07 <loupgaroublond> what's the syntax for a lambda function that takes more than one parameter?
21:12:28 <LoganCapaldo> > (\x y -> x + y) 2 3
21:12:29 <funktio> (\x y -> x+y)
21:12:30 <lambdabot>  5
21:12:34 <loupgaroublond> thanks :)
21:12:44 <LoganCapaldo> > (\x -> \y -> x + y) 2 3 -- also works
21:12:45 <lambdabot>  5
21:13:34 <LoganCapaldo> there are no functions that take more than one paramter :)
21:15:16 <rue> There can only be one
21:15:25 <fnord123> > (\!x !y -> x + y) 2 3
21:15:25 <lambdabot>  Parse error at "->" (column 9)
21:15:37 <fnord123> no bang patterns?
21:16:15 <sieni> > (\(x,y) -> x+y) (2,3)
21:16:15 <lambdabot>  5
21:16:36 <dibblego> > (uncurry (\(x,y) -> x+y)) 2 3
21:16:36 <lambdabot>        add an instance declaration for
21:16:36 <lambdabot>       (Num ((b -> t -> a, b -> t -> a)...
21:16:43 <LoganCapaldo> i thought you could only bang constructors?
21:16:52 <dibblego> LoganCapaldo, you can in H98
21:17:05 <fnord123> you need -fbang-patterns
21:17:15 <funktio> > (curry (\(x,y) -> x+y)) 2 3
21:17:15 <lambdabot>  5
21:17:22 <funktio> :)
21:17:32 <dibblego> yeah that
21:22:32 <wy> data Scale = forall a. (ScaleClass a) => Scale a
21:23:00 <wy> But I have to make (Scale a) an instance of ScaleClass
21:23:28 <wy> Why isn't this automatic?
21:24:01 <LoganCapaldo> deriving (ScaleClass)
21:24:07 <LoganCapaldo> ok that won't really work
21:24:26 <LoganCapaldo> but it does for newtypes :)
21:24:41 <wy> Can't make a derived instance of `ScaleClass Main.Scale'
21:24:41 <wy>       (`ScaleClass' is not a derivable class)...
21:25:19 <wy> A newtype constructor cannot have an existential context,
21:25:25 <LoganCapaldo> i said it wouldn't really work :)
21:25:33 <LoganCapaldo> those were't actual suggestions
21:26:41 <wy> I guess I need to look at HList or intersection types
21:27:16 <LoganCapaldo> you could just suck it up and type setDigits more than once <g>
21:27:47 <wy> I think data Scale = forall a. (ScaleClass a) => Scale a should have Scale a derived from ScaleClass. Why isn't it?
21:27:57 <loupgaroublond> how do i represent 'bottom' or rather, why can't i use () for some time a ?
21:28:21 <LoganCapaldo> loupgaroublond: undefined or error "the bottoms"
21:29:03 <loupgaroublond> ah
21:29:12 <LoganCapaldo> @src undefined
21:29:13 <lambdabot> undefined =  error "Prelude.undefined"
21:29:23 <LoganCapaldo> @type error
21:29:25 <lambdabot> forall a. [Char] -> a
21:29:33 <loupgaroublond> yup, that's what i wanted
21:29:50 <loupgaroublond> wikibooks keeps using this symbol _|_ without ever explaining how to use it in the realworld
21:30:17 <ricky_clarkson> _|_ means bottom, or a really basic cartoon figure.
21:30:26 <ricky_clarkson> > undefined
21:30:27 <lambdabot>  Undefined
21:30:37 <ricky_clarkson> undefined is _|_
21:31:02 <ricky_clarkson> An infinite loop is _|_.  "does not terminate".
21:31:18 <LoganCapaldo> loupgaroublond: you can also use something like let bot = a where a = a
21:31:34 <LoganCapaldo> @type let bot = a where a = a in bot
21:31:35 <lambdabot> forall t. t
21:31:44 <loupgaroublond> i don't need anything so complex, i just need something that is like 'None' in python
21:31:45 <ricky_clarkson> > let bot = a where a =a in bot
21:31:46 <lambdabot>  Exception: <<loop>>
21:31:47 <ricky_clarkson> heh
21:32:03 <ricky_clarkson> loupgaroublond: See Maybe.
21:32:15 <ricky_clarkson> @src Maybe
21:32:15 <lambdabot> data Maybe a = Nothing | Just a
21:32:21 <ricky_clarkson> Nothing ~= None
21:32:36 <LoganCapaldo> undefined isn' "inspectable" like None is in python
21:32:47 <loupgaroublond> you can't use it in pattern matching?
21:32:49 <LoganCapaldo> you can't check for undefinedness
21:32:53 <LoganCapaldo> right
21:32:54 <loupgaroublond> hmm...
21:33:20 <LoganCapaldo> (just like you can't pattern match an infinite loop)
21:34:16 <loupgaroublond> i guess i do still need maybe then
21:34:24 <LoganCapaldo> hence why you probably want something like Maybe or possibly Either
21:34:46 <loupgaroublond> i'm working on an DSL, it'll destroy othorgonality a bit, but meh, makes my life easier :)
21:34:57 <LoganCapaldo> haskell has no nil / null or None, and I thank the designers everyday for that spark of sanity
21:35:21 <monochrom> hehe
21:38:36 <shachaf> ricky_clarkson: Perhaps "does not return" is more accurate.
21:38:41 <fnord123> LoganCapaldo: there is Nothing, but you have to explicitly make the value a Maybe, which makes you rethink what you're doing. :)
21:38:44 <shachaf> ricky_clarkson: Since undefined does terminate. :-)
21:39:00 * fnord123 reads up and sees Maybe was mentions. /mode +lurk
21:40:28 <loupgaroublond> Maybe a is Eq for all a that is Eq?
21:40:59 <Heffalump> loupgaroublond: yes
21:41:59 <ricky_clarkson> shachaf: Yes, but it represents a lack of termination.
21:42:03 <loupgaroublond> hah, restricting myself to Maybe makes like easier :)
21:42:33 <ricky_clarkson> loupgaroublond: Eliminating the possibility of None/Nothing can make code simpler, if it's practical to do so.
21:43:44 <ricky_clarkson> Imperative-style code can be the source of a lot of Nothing.
21:44:01 <loupgaroublond> ricky_clarkson: in this case, it's that i'm still stuck in thinking in 'duck typing'
21:45:16 <ricky_clarkson> @src Ord
21:45:16 <lambdabot> class  (Eq a) => Ord a  where
21:45:16 <lambdabot>     compare      :: a -> a -> Ordering
21:45:16 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
21:45:16 <lambdabot>     max, min         :: a -> a -> a
21:45:28 <ricky_clarkson> class Duck d where
21:45:39 <ricky_clarkson>   walk :: IO ()
21:45:48 <ricky_clarkson>   quack :: IO ()
21:47:05 <loupgaroublond> nice :)
21:47:26 <loupgaroublond> i always wondered if it tasted like a duck, though
21:47:44 <loupgaroublond> cause you know, if it looks like a cookie, smells like a cookie, and tastes like a cookie, then it's a cookie
21:48:41 <johnnowak> with arsenic
21:49:43 <Zao> loupgaroublond: If it doesn't taste like a duck, it's a leaky abstraction.
21:50:27 <dibblego> you can't have class Duck, since both walk and quack do not use d
21:57:17 <loupgaroublond> is there a class that can be used like Bool for any data type?
21:57:47 <dibblego> loupgaroublond, what would such a type do?
22:00:36 <loupgaroublond> the constructor is Match Bool a, so something matchAnd :: Match a -> Match a -> Match a concatenate the two a's assuming they are MonadPluses
22:02:15 <hpaste>  jfoutz pasted "existential type problem" at http://hpaste.org/4727
22:02:31 <jfoutz> hi, what am i doing so horribly wrong?
22:02:48 <jfoutz> or, how do i declare the type for doIdentity?
22:05:27 <jfoutz> so, i like the "smart constructor" idea from the wikki
22:06:01 <jfoutz> but it's not obvious how to provide type declarations for things that aren't functions.
22:07:32 <jfoutz> i worked with the theory that  :t doScale 0 0 0 produces doScale 0 0 0 :: AnyGLC
22:07:35 <Heffalump> loupgaroublond: there's nothing existing that'll do that (AFAIK). You could write on easily enough.
22:08:09 <jfoutz> so i figured doIdentity ought to be typed like doIdentity::AnyGLC but that dosn't work.
22:08:38 <Heffalump> jfoutz: really, what error do you get?
22:09:18 <jfoutz>     Ambiguous type variable `a' in the constraint:
22:09:18 <jfoutz>       `MatrixComponent a'
22:09:18 <jfoutz> 	arising from a use of `AnyGLC' at test.hs:27:13-33
22:09:39 <Heffalump> oh, I see
22:09:54 <Heffalump> you'll need a type signature in that particular case, purely because it is ambiguous as the error message says
22:09:59 <jfoutz> yeah. scale and rotate give hints as to the type. i'm sorta stumped.
22:10:15 <Heffalump> AnyGLC (ActionIdentity :: MatrixActions Int)
22:10:25 <Heffalump> or something appropriate in place of Int, I'm just guessing there
22:10:36 <jfoutz> ahh... and for every type, GLfloat, GLdouble etc.?
22:10:39 <Heffalump> the problem is that nothing fixes what kind of MatrixActions you have.
22:10:49 <Heffalump> well, you are hiding the type.
22:11:04 <Heffalump> So you have to pick one, because there is no way that the overloading can be resolved later, as it's not part of the AnyGLC type.
22:11:26 <Heffalump> If you want to keep the overloading, you need to change the definition of AnyGLC
22:11:48 <jfoutz> hmm... i think i see. i need to hide some of the type but not all of the type... hmm.
22:11:49 <Heffalump> so that it passes on the parameter to the contained type
22:12:15 <conal> any gtk2hs folks here?  i'm wondering whether to grab gtk2hs-0.9.12.1.tar.gz or the darcs repo.
22:12:22 <Heffalump> it's possible that GLCommand will need to change if you do that, so that your instance is for MatrixActions rather than (MatrixActions a). Bit of a tricky area, that.
22:12:35 <loupgaroublond> are you supposed to get a 'prescient' feeling that you have 'good' haskell the closer you get to compiling warning free?
22:12:43 <Heffalump> loupgaroublond: perhaps :-)
22:12:53 <trie> Hi. Does some here have experience installing ghc on OS X (10.5)?
22:13:13 <Heffalump> jfoutz: I need to go shower and then leave for work, but I'll be back briefly inbetween.
22:13:19 <loupgaroublond> I just have to keep reminding myself, i'm learning this faster than i learnt python 3 years ago
22:13:27 <jfoutz> thank you very much Heffalump. i knew i was missing some magic with forall...
22:13:37 <jfoutz> i just need to cogitate on that for a bit.
22:13:39 <trie> install went fine by i now get "ghc-6.8.2: panic! (the 'impossible' happened)"
22:18:17 <jfoutz> trie, it looks like you ran into a difficult to reproduce bug. i wonder if we can wake up Igloo
22:18:41 <jfoutz> http://hackage.haskell.org/trac/ghc/ticket/1646
22:18:43 <lambdabot> Title: #1646 (: panic! (the 'impossible' happened)) - GHC - Trac
22:19:12 <jfoutz> did you build from source?
22:19:47 <trie> I did look at that one, but that should have been fixed for 6.8.2 --- No the binary form the download page
22:20:15 <jfoutz> well, it was closed because "worksforme" so... id doubt there's a change :)
22:21:30 <trie> Oh ok.  did not see that. I am cleaning and reinstalling now.
22:23:15 <jfoutz> i've got 6.8.1 on osx 1.5 ... i seem to recall some crazyness with readline libraries, but nothing out of control. odd that the stock download would be that broken.
22:23:51 <trie> "Loading package base ... linking ... done. ..." The reinstall fixed it. Hmm..
22:24:45 <trie> Thanks jfoutz.
22:24:47 <jfoutz> i blame gremlins.
22:24:59 <jfoutz> sure, i don't think i was much help tho.
22:32:56 <Heffalump> jfoutz: waking up Igloo at 6:30 in the morning is unlikely to be feasible :-)
22:33:20 <jfoutz> well, make clean fixed it... there must be some random temp file somewhere.
22:33:30 * jfoutz shrugs
22:37:10 <jfoutz> Heffalump: i think i'm going to have to split out the underlying numerical type from all of my intermediate structures.
22:37:19 <arjanoosting> p/window 9
22:38:01 <Heffalump> jfoutz: quite possibly.
22:41:57 <jfoutz> I'm (i guess obviously) trying to build up a tree of opengl operations that can be composed in a functional style. Everything in that API expects to be in the IO monad.
22:45:05 <jfoutz> anyway, thanks again. g'night.
22:59:23 <Jangler> ?hoogle [a] -> [a]
22:59:23 <lambdabot> Prelude.tail :: [a] -> [a]
22:59:24 <lambdabot> Prelude.init :: [a] -> [a]
22:59:24 <lambdabot> Prelude.reverse :: [a] -> [a]
23:01:02 <wy> augustss: Do you know some progress in intersection type recently?
23:04:28 <thetallguy> Is there an existing integer exponentiation defined?
23:04:43 <wy> > 2^8
23:04:45 <lambdabot>  256
23:04:57 <wy> :t (^)
23:04:58 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
23:05:23 <thetallguy> got it.
23:05:25 <thetallguy> thanks
23:06:17 <thetallguy> wow, big numbers
23:07:59 <Cale> > 2^512
23:08:00 <lambdabot>  1340780792994259709957402499820584612747936582059239337772356144372176403007...
23:08:27 <thetallguy> yeah, turned out to be wrong
23:09:52 <thetallguy> foldr (+) 0 . map (^ k)  <>  foldr plusk 0 where plusk a b = (a ^ k) + (b ^ k)
23:09:55 <thetallguy> Time for bed.
23:20:46 <fnord123> foldr isn't space constrained.
23:26:51 <sclv> I have a function as such:
23:26:52 <sclv> foldUp :: (Monoid c) => [[a] -> b -> c] -> [a] -> b -> c
23:26:53 <sclv> foldUp fs as = mconcat $ zipWith (. (:[])) (cycle fs) as
23:26:57 <sclv> What should I name it?
23:27:24 <sclv> it's a variant of mconcat, really.
23:28:53 <sclv> Taking out the mconcat we get: foldUp :: (Monoid c) => [[a] -> b -> c] -> [a] -> b -> c
23:28:53 <sclv> foldUp fs as = mconcat $ zipWith (. (:[])) (cycle fs) as
23:29:00 <sclv> foldUp :: [[b] -> c] -> [b] -> [c]
23:29:02 <sclv> rather.
23:29:19 <sclv> which is, I supose, iterApply ?
23:37:17 <jz87> I have a (prossibly noob) question
23:37:49 <jz87> what is to prevent someone from implement erlang's messaging functionality in haskell?
23:38:08 <Korollary> Nothing. There are already channels I believe.
23:38:31 <jz87> why not just write a combinator library that uses forkIO and have type classed TVars to define message passing interfaces
23:39:20 <jz87> it seems like it wouldn't be too difficult to then just write spawn(fun) where spawn calls forkIO internally and return a process handle
23:39:52 <jz87> and then you can define ! to use writeTVar to pass a typed message to that object
23:40:39 <Korollary> yeah it should already work one the same machine. But erlang already has its runtime take care of connections etc. I think.
23:40:49 <jz87> oh
23:40:57 <jz87> you mean remote messaging?
23:41:10 <jz87> hmm, yeah that would be a problem
23:41:15 <Korollary> yes. I don't know erlang, but I remember something like that from the tutorial.
23:41:32 <jz87> I've been looking through erlang
23:41:40 <jz87> and my first impression was, this language is ugly
23:41:50 <Korollary> Yeah, a bit. It's old.
23:42:05 <jz87> the lack of static typing means that erlang code is littered with atoms that annotate types
23:42:28 <jz87> wasn' erlang started around the same time as haskell though?
23:42:30 <jz87> in the late 80s?
23:43:44 <Korollary> hmm yes
23:43:48 <Korollary> wikipedia says 1987
23:43:49 <jsnx> jz87: erlang seems to be like shell script for networks
23:44:12 <jsnx> if it just had better bindings to other languages...
23:44:21 <jz87> you mean FFI?
23:44:39 <jz87> yeah, I think they explicitly ruled out having a normal FFI
23:44:41 <jz87> as being unsafe
23:44:58 <jsnx> jz87: well, maybe not -- maybe just intelligent way to start workers and share bytes with them
23:45:04 <jz87> basically you're supposed to interface with foreign langauges with ports
23:45:14 <jsnx> jz87: i think that's a good idea
23:45:16 <jz87> using a binary port protocol
23:45:27 <jsnx> jz87: you can use any protocol
23:45:38 <jsnx> it prevents you from handling the data in erlang
23:45:38 <jz87> and the foreign language module would run in a separate OS process so it doesn't corrupt erlang's runtime if something goes wrong
23:45:57 <jsnx> jz87: yes, seems good to me -- very much like bourne shell
23:46:10 <jz87> but the syntax is so ugly
23:46:17 <jsnx> jz87: yes, it is beastly
23:46:38 <jsnx> but you get all those nice libs for workers, monitors, and transparent distribution
23:46:44 <jz87> yes I know
23:46:47 <jsnx> the runtime is slick
23:46:49 <jz87> their runtime system and libraries are first rate
23:46:52 <jz87> it's just the language
23:46:57 <jsnx> yes, i know
23:47:12 <jz87> If only I can write in haskell and run on erlang
23:47:21 <jsnx> well, would that even make sense?
23:47:38 <Cale> Kind of reminds me of the situation with GAP. The library is incredible, but the language itself is mediocre.
23:47:47 <jz87> the algebra language?
23:47:52 <Cale> Yeah.
23:47:55 <jsnx> a lot of the optimizations haskell makes are not practical in erlang
23:47:56 <jz87> *shudders*
23:48:02 <jz87> I remeber that from college algebra class
23:48:12 <jsnx> because erlang can decide at runtime whether or not to do copies, for example
23:48:14 <Cale> It's really good, once you get the hang of it.
23:48:31 <jz87> you mean for message passing?
23:48:37 <jsnx> jz87: right
23:49:09 <jz87> that's something I don't quite understand
23:49:11 <jsnx> static analysis can't tell us what to do there
23:49:19 <jz87> why would you need to do copies if you're dealing with immutable data structures
23:49:34 <jsnx> because they are being sent to a different computer!
23:49:37 <jz87> can't you just pass pointers if you're in the same os process?
23:49:45 <Cale> But the language is odd -- there's lots of stuff which does mutation behind your back, and, for example, lists are allowed to have skips in them, so [,,2,,4,5,] is a valid list.
23:49:54 <jz87> oh yeah, in that case
23:50:01 <jsnx> jz87: if you are on the same computer, yes
23:50:33 <jsnx> it's probably totally possible, though -- by deferring certain optimizations to runtime
23:50:47 <jsnx> but right now, haskell does *static* optimizations
23:50:59 <jz87> well I was thinking you would just implement ! as an alias to writeTVar
23:51:31 <jsnx> jz87: well, does that get you the transparent networking?
23:51:47 <jz87> well not in the present haskell
23:52:12 <jz87> I guess what you can do
23:52:15 <jz87> is implement a library
23:52:18 <jz87> a ! function
23:52:25 <jz87> that can take a sum type
23:52:35 <jsnx> what is a sum type?
23:52:50 <jz87> like the data A = C1 | C2
23:52:57 <jsnx> oh, i see
23:53:00 <jz87> some programming langauge books call it sum type
23:53:13 <jz87> where as typles like C(T1, T2,...) is called Product type
23:53:21 <jsnx> ah, i see
23:53:29 <jz87> so if you have Pid ! Msg
23:53:45 <jsnx> Cale: is   A = C1 | C2   like a coproduct?
23:53:45 <jz87> where data Pid a = Local(a) | Remote(a)
23:54:00 <jsnx> jz87: ah, i see
23:54:02 <Cale> jsnx: yes
23:54:08 <jz87> you can define Local(a) ! Msg = writeTVar ...
23:54:19 <jz87> Remote(a) ! Msg = some socket related code
23:54:22 <jsnx> Cale: cool! i've been reading the CT notes
23:54:34 <jz87> CT?
23:54:37 <Cale> jsnx: (which is where the sum terminology comes from, coproducts are also sometimes called sums)
23:54:44 <Cale> category theory
23:54:47 <jz87> ah
23:54:53 <runar> How to prove that (reverse . map f) = (map f . reverse) ?
23:55:22 <Cale> Well, induction of course ;)
23:55:24 <jsnx> jz87: very helpful notes  [  http://www.math.uchicago.edu/~eugenia/catnotes/categorynotes-cheng.pdf  ]
23:55:25 <lambdabot> http://tinyurl.com/28sclm
23:55:27 <runar> well, yes.
23:55:36 <jz87> thanks lambda bot
23:55:41 <Cale> Yeah, Eugenia's notes are quite good :)
23:55:46 <jaredj> i've just been reading the paper that the Reader and Writer monads reference
23:56:03 <jz87> I have a couple of books on CT I bought at ICFP last year I haven't gotten around to yet
23:56:09 <jsnx> Cale: well, they are her student's notes...
23:56:09 <jz87> too much to read
23:56:17 <jaredj> it's got things about reversing things over lists and how it ends up coolly the same
23:56:48 <jsnx> jz87: so, you would have this library... but you still need a bunch of other stuff
23:56:49 <Cale> jsnx: Probably taken during her lectures for that course?
23:57:04 <jsnx> Cale: yes, the notes were taken at cambridge
23:57:17 <jaredj> :d http://web.cecs.pdx.edu/~mpj/pubs/springschool95.pdf
23:57:33 <jz87> what do you mean jsnx?
23:57:33 <jaredj> !
23:57:47 <jz87> doesn't the rest just depend on haskell's runtime?
23:57:54 <jz87> like how efficiently that can spawn threads?
23:58:08 <jz87> I recall that concurrent GHC implements user level threads
23:58:18 <jsnx> jz87: well, haskell's runtime needs a socket server, listening for these messages
23:58:19 <jz87> which should be fairly close to erlang's in terms of lightweight
23:58:29 <jsnx> jz87: and it does not have one
23:58:43 <jz87> well haskell has socket libraries
23:58:47 <jsnx> jz87: also, where is the hot code reloading in this scheme?
23:58:53 <jz87> ah yes
23:58:54 <jz87> sorry, try
23:58:56 <jz87> true
23:59:07 <jsnx> jz87: and the global registration of processes with a certain name?
23:59:12 <jsnx> hate to be a downer?
23:59:18 <jsnx> s/?/./
23:59:22 <jz87> yeah, the erlang runtime comes with a socket server that can execute spawn process requests from remote nodes
23:59:43 <jz87> well hot code replacement is just rebinding of functions
23:59:56 <jsnx> well it comes with this pseudo DNS thing so you can register processses, replace them
23:59:57 <runar> I get as far as: map f (reverse xs ++ [x]) = reverse (map f xs) ++ [f x]
