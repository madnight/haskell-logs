00:00:04 <wli> We must be speaking at cross purposes.
00:00:18 <P_D> indeed.
00:01:26 <P_D> heh, there's a COQ proof of a GMP sqrt algorithm.
00:01:42 <P_D> the correctness thereof*
00:01:53 <ddarius> Is there a proof of the code or just the algorithm?
00:02:00 <P_D> The code
00:03:06 <P_D> Bertot/Magaud/Zimmerman.  A proof of GMP square root using the Coq assistant.  Some INRIA memo?  June 2002
00:03:52 <P_D> Somewhere between code and algorithm
00:06:12 <Meldon> ftp://ftp-sop.inria.fr/lemme/Nicolas.Magaud/GMP-sqrt-why/index.html
00:07:56 <Meldon> http://citeseer.ist.psu.edu/rd/56723766%2C702491%2C1%2C0.25%2CDownload/http://citeseer.ist.psu.edu/cache/papers/cs/32967/ftp:zSzzSzftp.inria.frzSzINRIAzSzpublicationzSzpubli-ps-gzzSzRRzSzRR-4475.pdf/bertot02proof.pdf
00:07:59 <lambdabot> http://tinyurl.com/25tqda
00:11:51 <Meldon> http://www.inria.fr/rrrt/rr-3805.html
00:11:52 <lambdabot> Title: RR-3805 : Karatsuba Square Root
00:11:53 <dons> this is rather nasty, http://programming.reddit.com/info/61viy/details
00:14:05 <Nafai> dons: Well, it is Harrop
00:18:41 <dons> it is.
00:19:08 <dons> i think we can expect a 2x slowdown on a numeric-heavy program, so his numbers are reasonable.
00:19:23 <dons>  the shootout suggests similar, (1.6x faster to 2.3x slower for the numeric stuff)
00:19:26 <dons>   http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=ghc&lang2=gpp
00:19:27 <lambdabot> Title: Haskell GHC benchmarks | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lang ..., http://tinyurl.com/yptp36
00:19:48 <dons> but, he has to present like this since its a direct threat to his consultancy business, i suppose (does anyone buy those books)
00:20:27 <P_D> there's no threat, he can write a book in any language.  just a crackpot.
00:20:52 <dons> he's very effective at alienating large proportions of the FP community
00:21:00 <dons> i wonder why i've never seen him at icfp. hmm
00:21:55 <sclv> wtf: you read the conversation in the comments at the original blog post and he's quite personable. and then... yip! http://augustss.blogspot.com/2007/11/benchmarking-ray-tracing-haskell-vs.html
00:21:56 <lambdabot> Title: Things that amuse me, http://tinyurl.com/25sj6t
00:22:45 <dons> yeah, its weird.
00:23:30 <ray> all that benchmark stuff has been cluttering my poor rss feed :(
00:23:50 <dons> heh
00:30:07 <sjanssen> "Can be as fast as Java" is some clever FUD
00:30:48 <dons> yes, http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=ghc&lang2=java
00:30:49 <lambdabot> Title: Haskell GHC benchmarks | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lang ..., http://tinyurl.com/2hozbt
00:31:19 <dons> java's surprisingly fast these days
00:33:03 * sjanssen laughs at the 50x faster startup over Java
00:33:34 <P_D> that gcc optimization is insanely cool
00:33:46 <dons> P_D: oh, the fib one?
00:33:50 <P_D> yes
00:33:53 <dons> yeah, that's scary
00:33:58 <P_D> probably bogus :)
00:34:04 <Nafai> Honestly, the big slowness with Java is really starting up the JVM
00:34:06 <wli> What's it do?
00:34:07 <dons> i wonder on who the proof obligation for new translations in gcc is
00:34:30 <Korollary> I don't think gcc can do that for everything. There's got to be a different function that reveals it.
00:34:31 <Nafai> I think that's why many Java programs are targeted to long-running application servers
00:34:33 <goalieca> also gcc is very very fast for numerics and floating point
00:34:42 <dons> i hope gcc is , yeah, goalieca :)
00:34:49 <P_D> it notices the second fib call is a tail, and then transforms that to a loop
00:35:02 <P_D> so it calls the first fib and reduces n by 2 in a loop
00:36:12 <sclv> the jvm is really good on strings and numerics
00:36:16 <Korollary> The weird thing is that JDH doesn't work for Inria. The next release of Ocaml may be slower by 10% for some reason. Does that mean he'll go hungry? This is just insane.
00:36:32 <Olathe> @src even
00:36:32 <lambdabot> even n = n `rem` 2 == 0
00:36:41 <P_D> that's the sad thing about ocaml, closed development
00:36:41 <sclv> but object creation and function calls and especially reflection can be insanely slow.
00:36:42 <dons> Korollary: oh, that's something I'd not though about.
00:36:52 <P_D> he has F#.
00:36:57 <Olathe> Does ghc optimize that to n .&. 1 ?
00:37:00 <sclv> i read a good blog somewhere where they did microbenchmarks of all the basic jvm opcodes
00:37:06 <dons> just that he's really outside the FP community in general -- you'd think someone with that kind of interest would turn up at ICFP, but no.
00:37:13 <dons> very odd.
00:37:52 <P_D> gcc is such an insane program
00:37:58 <P_D> 20 years old?
00:38:35 <Korollary> As much as I admire GHC HQ for their efforts, I would not risk my professional reputation for standards they have to live up to.
00:38:55 <dons> oh, interesting how jdh links to reddit comments on potss , not the orignal posts.
00:39:09 <dons> and has added comments to some of them in the last few hours
00:39:49 <dons> Korollary: maybe jdh keeps a private copy of the ocaml source in maintainance in case of bus errors at inria?
00:39:54 <Korollary> I doubt (and hope) anybody who makes a decision is ever skewed by whatever JDH does online.
00:40:25 <dons> do other communities have weird people like this?
00:40:40 <wli> The kernel community is chock full of crackpots.
00:40:48 <dons> ah yes.
00:41:01 <P_D> There's a great google talk on Poisonous People.  I think it's from two SVN guys.
00:41:13 <codemac> Yea, that's a great tech talk.
00:41:38 <dons> it must be a bit scary to have bet on ocaml, and have this big silly haskell community baring down.
00:41:54 <sjanssen> gah, this article is rife with mistakes
00:42:02 <sjanssen> latest unstable release of GHC (6.8)
00:42:21 <sjanssen> "Lennart Augustsson, author of the hbcc"
00:42:42 <dons> mmm.
00:42:57 <Korollary> Lennart eats babies
00:43:23 <P_D> Haha.  Harrop:  "Hmm, Haskell doesn't seem to support or-patterns yet.  Shame.  Back to OCaml. :-)"
00:43:37 <dons> yeah, saw that, P_D. they'd be quite useful, actually!
00:43:50 <dons> case x of 0 | 1 -> y  ; _ -> z
00:43:50 <Korollary> What's an or-pattern?
00:44:11 <dons> case x of m | m == 0 || m == 1 -> y  ; _ -> z
00:44:14 <sjanssen> IIRC, GHC's new views can do or patterns
00:44:18 <wli> They're most useful when you bind the same set of vars in each branch.
00:44:35 <dons> what can the compiler do that it makes a perf difference though?
00:44:49 <dons> (he was suggesting it was a key performance thing, iirc)
00:45:02 <P_D> yes, 25% faster with
00:45:02 <Korollary> or could be lazy?
00:45:30 <dons> its just syntax, surely, so something else is going on
00:47:24 <Korollary> "The pattern pattern1 |  pattern2 represents the logical .or. of the two patterns pattern1 and pattern2. A value matches pattern1 |  pattern2 either if it matches pattern1 or if it matches pattern2. The two sub-patterns pattern1 and pattern2 must bind exactly the same identifiers to values having the same types. Matching is performed from left to right."
00:48:10 <Korollary> The performance difference could be due to a bug heh
00:48:19 <P_D> I vaguely recall not liking it when using ocaml, since it's not a very flexible feature
00:49:31 <P_D> I suspect the reason for that was being unaware of _
00:54:02 <dons> "F# is interesting because, due to its functional and side-effect-free nature, one can get a huge amount of parallelism out of straightforward code"
00:54:18 <dons> hmm?
00:54:47 <integral> F# is side-effect free?
00:54:52 <sjanssen> no, it isn't
00:55:01 <Korollary> Ask your doctor
00:55:04 <glguy> "F# is interesting because, due to its functional and side-effect-free nature, one can get a huge amount of parallelism out of straightforward code. (It's the lack of side effects that allow such analysis to be performed.) The Xbox Live matching service, for example, is using a TrueSkill engine developed in F# by Microsoft Research."
00:55:08 <P_D> you can go a long ways side effect free though...
00:55:09 <glguy> http://chanson.livejournal.com/178802.html
00:55:12 <glguy> lolwut?
00:55:21 <Korollary> are you guys on IM or something?
00:55:50 <dons> Korollary: http://programming.reddit.com/info/61vni/comments/
00:55:54 <glguy> lol, I didn't bother reading the backlog before pasting that
00:55:58 <Korollary> It's a "bold" huge, btw
00:55:58 <glguy> good catch don
00:56:05 <P_D> and it has laziness, so you don't have that O(n log n) problem
00:56:33 <dons> glguy: bizarre, did you just find and paste the same quote?
00:56:36 <glguy> yeah
00:56:42 <glguy> the internet is getting small
00:56:44 <dons> ok. you're so jinxed
00:56:57 <glguy> again??
00:57:07 <Korollary> No
00:57:34 <glguy> so you are going to crush that guy's dreams or leave him to his delusions?
00:58:01 <dons> i'd like to see him parallelise some F#. its hard enough when you really do have purity!
00:58:26 <Korollary> Magic happens when things become commercial products
00:58:28 <dons> F# does have this `workflow' extension, iirc, for spawn/fork syntax?
01:00:31 <sjanssen> workflows seem interesting
01:03:05 <dons> something like strategies, and even laziness?
01:03:27 <codemac> new goal, get paid for haskell.  WITH 0 EXPERIENCE.  I'm totally listing the tutorials I've completed as experience.
01:03:43 <Cale> :)
01:04:00 <dons> codemac: :)
01:04:19 <dons> hack hack on some code too. open source counts as experience
01:04:30 <Nafai> Hrm
01:04:33 <Nafai> Maybe I should do that
01:05:16 <Nafai> But what to work on that isn't over my head? :)
01:05:37 <codemac> It's hard because I barely know what a Monad is... so I feel like I'd have a hard time being constructive
01:05:49 <codemac> but alas, I am off to dream of FP
01:05:57 <dons> hmm. new libs are a good way, Nafai
01:06:20 <dons> presumably there's some domain you're more fluent in that the average haskeller, write a lib in that area
01:06:25 * goalieca doesn't get monads very well either. at first they were just abstract nonsense
01:10:13 <Nafai> The question is, then, what's that domain? :)
01:12:48 <Cale> goalieca: First work out what combinator libraries are about. :) Monads are just a particular kind of those.
01:13:31 <Nafai> combinator libraries?
01:17:10 <Cale> Yeah. Essentially they're libraries with rich enough APIs to act like small embedded programming languages.
01:18:05 <Cale> They'll generally have some primitive computations, together with ways to combine those primitives into more complicated things.
01:18:25 <Nafai> What's a good example?
01:18:43 <Cale> For example, in a parser combinator library, you start with simple parsers which parse single characters, for instance, and then ways to combine those parsers (concatenation, alternation, etc.)
01:19:45 * Nafai nods
01:20:15 <Cale> Or in a drawing library, you might start out with simple primitive images (lines, fills, and so on), and then interesting ways to combine those (clipping one image with another, drawing one image atop another or beside it)
01:21:05 <Cale> Perhaps even higher-order ways: "take all the lines in this image, and replace them according to the drawing this function gives you"
01:21:38 <Nafai> composability is pretty nice
01:22:17 <Cale> Right, so monads (as far as functional programmers are concerned) are just those combinator libraries which fit a particular pattern of composition.
01:22:51 <dons> jdh is so weird, he's trying to cultivate the fp community, but failing so badly, alienating them in the process, and driving up criticism .
01:23:10 <dons> maybe it works like a pyramid scheme: as long as he can find new people faster than he can alienate others
01:24:25 <Nafai> I watched Brian Beckman's (I think that's his name) video on MS's Channel 9 about Monads...I think I understand the basics now
01:24:46 <Cale> Nafai: In particular, the computations need to have "results", there needs to be a way to construct a computation which for any value x, "does nothing but gives the result x", and there needs to be a way to take a computation, and a function from possible results of that computation to further stuff to be done, and combine those in the only obvious way.
01:24:48 <sjanssen> it's telling that the first comment on the reddit post is "Jon Harrop is a troll (see the comp.lang.lisp newsgroup)."
01:25:29 <njbartlett> dons: I think that's a Ponzi scheme, not pyramid ;-)
01:25:37 <Cale> Nafai: http://www.haskell.org/haskellwiki/Monads_as_computation
01:25:38 <lambdabot> Title: Monads as computation - HaskellWiki
01:26:02 * Nafai reads
01:26:13 <dons> sjanssen: right, so he's now got enough people alienated, badly enough, that they're working against him.
01:27:05 <dons> so in a small community, is his position tenable? or he relies on not needing the FP community
01:27:25 <dons> njbartlett: ah!
01:29:41 <Nafai> I guess I didn't know about (>>), only (>>=)
01:29:57 <Cale> Well, (>>) can be defined from (>>=)
01:29:57 <Nafai> I would say if I knew Haskell before C++, C++ stream syntax would be confusing for me
01:30:21 <Nafai> Because in my mind >> in C++ streams is more like >>=
01:30:32 <Nafai> (Yes, it's just syntax...)
01:30:41 <Cale> Even if you don't know Haskell, C++ stream syntax is pretty confusing at first :)
01:30:52 <Nafai> Indeed
01:31:07 * Taejo saw 'putStrLn "Hello World"' being shifted right 'return ()' times and new this Haskell thing was not for me
01:31:52 <Cale> Nafai: I just mention >> before >>= because it makes >>= easier to understand.
01:32:02 * Nafai nods
01:33:36 <Olathe> > Nothing >> id
01:33:37 <lambdabot>  Couldn't match expected type `Maybe' against inferred type `(->) a'
01:33:45 <Olathe> > Nothing >>= id
01:33:46 <lambdabot>  Nothing
01:33:54 <Cale> > Nothing >> Just 5
01:33:55 <lambdabot>  Nothing
01:34:06 <Cale> > Just 5 >> Just 7
01:34:07 <lambdabot>  Just 7
01:34:15 <Olathe> > Just 5 >> [11]
01:34:15 <lambdabot>  Couldn't match expected type `Maybe b' against inferred type `[a]'
01:34:19 <Olathe> Ahh.
01:34:23 <Olathe> @src >>
01:34:23 <lambdabot> m >> k      = m >>= \_ -> k
01:35:10 <Cale> Odd choice of variables there :)
01:35:29 <Cale> > [1,1] >> "Hello"
01:35:30 <lambdabot>  "HelloHello"
01:35:42 <kaol> > [1,2] `mplus` [3,4]
01:35:48 <lambdabot>  [1,2,3,4]
01:36:24 <Olathe> > ((++ "!!").(>> "AA")) "Hello world !"
01:36:25 <lambdabot>  "AAAAAAAAAAAAAAAAAAAAAAAAAA!!"
01:36:37 <Cale> haha
01:36:43 <desegnis> > Just False >>= not
01:36:43 <lambdabot>  Couldn't match expected type `Maybe b' against inferred type `Bool'
01:36:54 <desegnis> > Just False >>= return . not
01:36:54 <lambdabot>  Just True
01:37:03 <Cale> > fmap not (Just False)
01:37:04 <lambdabot>  Just True
01:37:14 <desegnis> Yes, that came into my mind right now...
01:37:23 <kaol> I got into habit of understanding mplus to mean "use the first one, or take the second one if the first one's empty" with Maybe. That didn't quite work that well when I tried that with List too.
01:37:35 <Cale> kaol: Yes, we need to split that class.
01:37:55 <Cale> http://www.haskell.org/haskellwiki/MonadPlus_reform_proposal
01:37:55 <lambdabot> Title: MonadPlus reform proposal - HaskellWiki
01:38:18 <kaol> Lists have a concept of emptiness too, but where'd that concat come in there?
01:38:23 <Cale> see also: http://www.haskell.org/haskellwiki/MonadPlus
01:38:24 <lambdabot> Title: MonadPlus - HaskellWiki
01:39:08 <Cale> kaol: Yeah, there should be a class for "orElse" like things separate from "plus" like things.
01:39:24 <Cale> kaol: Then both could be defined for lists.
01:39:32 <Nafai> I just groked sequence.
01:39:34 <dons> Korollary: i note jdh maintains the F# news too -- i wonder what the F# guys think of that.
01:39:36 <Nafai> Fascinating
01:39:40 <Cale> Nafai: nice :)
01:40:06 <dons> oh, and he also publishes the F#.NET Journal
01:40:24 <dons> `Subscribe to the F#.NET Journal today and read our growing repository of fascinating articles on the F# programming language from Microsoft'
01:43:14 <Cale> I'm really getting tired of how he always refers to himself using plural pronouns.
01:44:48 <Taejo> how do you get the source of typeclass instances from lambdabot?
01:45:13 <Cale> @src Functor []
01:45:13 <lambdabot> Source not found. You untyped fool!
01:45:19 <Cale> @src fmap []
01:45:19 <lambdabot> Source not found. It can only be attributed to human error.
01:45:21 <Cale> hmm
01:45:25 <Cale> @src [] Functor
01:45:25 <lambdabot> Source not found. You untyped fool!
01:45:28 <Cale> @src [] fmap
01:45:28 <lambdabot> fmap = map
01:45:35 <Cale> there we go :)
01:45:35 <Taejo> shot
01:45:42 <Cale> @src [] (>>=)
01:45:42 <lambdabot> m >>= k     = foldr ((++) . k) [] m
01:45:44 <Taejo> shot == thanks, btw
01:45:48 <Cale> heh
01:46:41 <Nafai> So I'm looking at the definition of liftM from that monads as computation page and I'm unsure of why you have v <- x \n return (f v) instead of just return (f x)
01:48:09 <Cale> Nafai: because f x would be applying f to the computation x
01:48:15 <Cale> rather than the result of the computation x
01:48:43 <Nafai> Ah
01:49:20 <Nafai> v <- x involves actual function application whereas (f v) just passes in whatever v is
01:50:08 <Cale> Well, it "runs" x, whatever that means in the given monad
01:50:22 <Cale> to produce a result which it calls v
01:50:54 <Nafai> ok
01:51:09 <Cale> f x won't run x automatically, it will pass in the whole computation x, and f will be allowed to manipulate that before it ever gets run
01:52:06 <Cale> This is a little strange for imperative programmers who are used to being able to stick parameters into functions which have side effects when they're evaluated.
01:52:45 <Cale> But it gives you a lot more flexibility, since you can pass computations around as first class values and write whatever sorts of control structures you'd like as ordinary functions.
01:53:04 <Cale> It also makes the order in which effects occur more explicit.
01:53:10 <kaol> should Bool be an instance of MonadOr? What would lifting a value to a Bool even mean?
01:53:26 <Cale> kaol: No, because Bool is not a type constructor, it's just a type.
01:53:40 <Nafai> I think I'm starting to grasp this at some level conceptually
01:53:43 <P_D> does C2HS make life harder than normal FFI or am I missing something?
01:54:05 <Cale> Nafai: Like in C, when you have f(g(x), h(y)), if g and h are functions with side effects, what order do the effects happen in?
01:54:43 <Cale> I'm not even sure that the language spec ensures a particular order.
01:55:13 <Nafai> I doubt that it does
01:55:33 <wli> C mostly says everything is undefined or implementation-specific.
01:55:44 <Cale> So here, you'd be forced to write something like  do v <- g x; w <- h y; f v w
01:55:48 <jql> anything fun, at least
01:55:54 <Nafai> Man my whole previously defined notion of "correct" or "good" code is coming crashing down
01:55:56 <Cale> or else:  liftM2 f (g x) (h y)
01:56:58 <jql> it's weird to think that C was invented even before byte size was decides upon
01:57:23 <jql> I'm too young for that stuff
01:57:30 <Nafai> Eek.
01:57:33 <Nafai> 4 AM
01:57:50 <Cale> 5 AM here :)
01:57:51 <Olathe> How'd you read my clock ?
01:58:12 <benny> Uri Geller told him his tricks
01:58:13 <Cale> I woke up at 3:30 since I went to sleep at 6 PM.
01:58:20 <jql> get a better clock. mine says 1:58
01:58:29 <Nafai> Time to sleep
01:58:34 <glguy> I can't beleive my first attempt at a solution to this in Haskell runs in 0.002s user time :-D http://projecteuler.net/index.php?section=problems&id=139
01:58:36 <Nafai> Thanks Cale for the info
01:58:37 <lambdabot> Title: Problem 139 - Project Euler
01:58:37 <wli> Mostly what's been going on is monopolization and elimination of alternate archiectures.
01:58:39 <dons> is it possible that alienating open source FP will have no effect on jdh's business, so he can happily do that?
01:58:42 <Cale> Nafai: No problem
01:58:42 <Olathe> jql: Wow. That's way off !
01:58:55 <jql> but it's more pleasing
01:59:16 <glguy> maybe I should profile it :)
01:59:20 <jql> according to my irc client, it's properly 3:59am
01:59:29 <jql> but I forgot to read the docs
01:59:39 <jewel> wli, what are you discussing?
02:00:12 <Olathe> According to this short story, it's 4:23 PM.
02:01:23 <Cale> There's something oddly futuristic feeling about coming up to a computer in the dark with a few blinking lights, bumping the optical mouse and having the thing wake up.
02:02:00 <opqdonut> :)
02:02:16 <wli> Problem 139 is so badly phrased I can't figure out what it's asking.
02:02:37 <Cale> http://programming.reddit.com/info/61tx5/comments/c02kk1v -- I love the snide reply to this comment.
02:03:17 <glguy> given a right triangle you can take 4 of them and make the hypotenuse of each the side of a square
02:03:27 <glguy> this will form a smaller square inside
02:03:49 <Cale> wli: Are you using a text browser?
02:03:58 <Cale> wli: The diagram makes it fairly clear.
02:04:10 <glguy> how many triangles have the property that the small square can be used to tile the large one
02:04:19 <opqdonut> it basically asks if (c^2-a*b/2) divides c^2
02:04:27 <opqdonut> mmh, sorry
02:04:34 <opqdonut>  (c^2-2*a*b) divides c^2
02:04:42 <Cale> I want to see a closed form or generating series solution to that ;)
02:05:03 <Cale> Project Euler's problems are too specific.
02:06:45 <glguy> Cale: fortunately for the rest of us, the problems are approachable to non-math people
02:07:30 <Cale> I suppose, it's just sort of strange.
02:07:46 <Cale> I'm not used to seeing problems that have constants in them. :)
02:11:06 <wli> Me neither. It bugs the bejesus out of me.
02:11:35 <wli> The diagram was useless to me. I figured it out by other means.
02:11:52 <glguy> then solve the general case, and then apply your general solution to the constant values to verify ;)
02:18:29 <glguy> wli: it does lend itself to a general solution :)
02:18:39 <desegnis> glguy, that is how you solve any real problem anyway
02:19:57 <vikrant> can anybody help me installing hsakore?
02:20:04 <vikrant> I mean haskore
02:20:45 <dmwit_> Hey guys, I want to export a function with a different name than the one it's defined by.
02:20:48 <dmwit_> Can I do it?
02:21:30 <desegnis> newName = oldName -- then export newName?
02:21:52 <dmwit_> Well, I have a top-level "parse" and "parseIncomplete".
02:22:00 <dmwit_> I want to export parseIncomplete as parse.
02:22:31 <desegnis> Then you cannot, I think.
02:22:36 <dmwit_> (That's what I *want*.  It might not be what I end up actually doing. =)
02:22:37 <dmwit_> ok
02:25:43 <wli> (a-b)^2 | (a^2+b^2) where a^2+b^2 is a perfect square, so basically |a-b| | (a^2+b^2)^(1/2), etc. You start wanting integer points on a different curve.
02:26:30 <goban_> hi! i know python and scheme, whats a really good book for learning haskell?
02:26:57 <Cale> goban_: If you're interested in a paper book, I've heard Graham Hutton's is rather good
02:27:17 <Cale> http://www.cs.nott.ac.uk/~gmh/book.html
02:27:18 <lambdabot> Title: Programming in Haskell
02:27:23 <dmwit_> If online tutorials are acceptable, the Gentle Intro is also quite nice.
02:27:28 <dmwit_> ?where gentle
02:27:28 <lambdabot> http://www.haskell.org/tutorial/
02:27:42 <Cale> Depending on how much of a functional programmer you are already :)
02:28:03 <Cale> (The Gentle Intro is mostly only gentle if you already know ML :)
02:28:05 <dmwit_> Yeah. =)  But I figured if the two languages he named were Scheme and Python...
02:28:26 <Cale> But maybe scheme people would find it okay too :)
02:28:44 <dmwit_> I don't know.  I used the Gentle Intro with no previous functional programming, and I liked it a lot.
02:28:50 <Cale> Cool :)
02:29:19 <Cale> The Wikibook and "Yet Another Haskell Tutorial" are pretty good as well, at least for the initial bits.
02:29:19 <wli> x^2+y^2=z^2, w*(x-y)=z, so basically integer points along the intersection of those two quadrics.
02:29:38 <Cale> goban_: Make sure that you ask lots of questions here as well :)
02:30:46 <Cale> wli: I really should learn more about the intersection between algebraic geometry and algebraic number theory.
02:31:19 <wli> Cale: I don't know anything. I have to look up answers when it comes to all this.
02:31:44 <goban_> thanks guys
02:31:59 <wli> Cale: I know just enough to massage problems into forms where I can do that if the problem is nice enough to make that possible.
02:38:22 <wli> (x^2+y^2)/t^2 = w^2*(x-y)^2/t^4 so t^2*(x^2+y^2) = w^2*(x-y)^2 is some horrendous quartic curve coming out of that. If I can get it down to cubic it's an elliptic curve problem I might be able to look up the answer to.
02:41:25 <Porges> @src ==
02:41:25 <lambdabot> x == y = not (x /= y)
02:41:31 <Porges> @src /=
02:41:31 <lambdabot> x /= y = not (x == y)
02:41:38 <Porges> <_>
02:42:00 <Cale> Porges: those are just the default implementations
02:42:20 <Taejo> @src [] ==
02:42:20 <lambdabot> Source not found. I am sorry.
02:42:26 <Cale> Porges: At least one of them will be defined in a more specific way for any given type
02:42:26 <Taejo> @src [] (==)
02:42:26 <lambdabot> []     == []     = True
02:42:26 <lambdabot> (x:xs) == (y:ys) = x == y && xs == ys
02:42:26 <lambdabot> _xs    == _ys    = False
02:42:48 <Porges> I see now :)
02:42:51 <Cale> (any given type in the class Eq, anyway)
02:43:14 <goban_> is there a haskell equivalent to "objects"? (inheritence tree)
02:43:34 <Cale> goban_: Not a direct one.
02:44:07 <Cale> goban_: Probably the closest thing I could suggest are simply "types".
02:44:19 <Cale> Or rather values of a particular type
02:44:36 <wli> A Grobner basis seems to be x^2+y^2-z^2, w*(x-y)-z, w*(2*y^2-z^2)+z*(x+y), the latter of which is merely cubic, albeit with one more variable than I know how to address.
02:44:48 <goban_> can haskell types be types of other haskell types
02:44:56 <goban_> sorry values
02:45:12 <Cale> Well, there are polymorphic values.
02:45:18 <Cale> For example,
02:45:27 <Cale> map :: (a -> b) -> [a] -> [b]
02:45:40 <Cale> map takes a function from a's to b's, and a list of a's and gives a list of b's.
02:45:48 <Taejo> but types don't have types, if that's what you're asking... types have kinds
02:45:49 <Cale> (for any types a and b)
02:46:45 <Cale> There are also typeclasses, which serve to restrict the set of types over which type variables range (type variables like a and b there)
02:47:05 <Cale> In particular, to restrict them to types where certain functionality is present
02:47:17 <Cale> For a simple example, there's a typeclass called Ord
02:47:41 <Cale> and it's the class of types for which < and >= etc. make sense for.
02:47:50 <Cale> > "Hello" < "World"
02:47:52 <lambdabot>  True
02:47:54 <goban_> ah
02:48:10 <Cale> :t sort
02:48:10 <goban_> what are kinds?
02:48:10 <lambdabot> forall a. (Ord a) => [a] -> [a]
02:48:59 <Cale> kinds are the (very simplistic) type system which is applied to parts of types
02:49:06 <Cale> We can have basic types:
02:49:11 <Cale> :kind Char
02:49:15 <Cale> err
02:49:17 <Cale> @kind Char
02:49:18 <lambdabot> *
02:49:23 <Cale> @kind Integer
02:49:24 <lambdabot> *
02:49:26 <goban_> oh char, string etc
02:49:28 <Cale> @kind String
02:49:28 <lambdabot> *
02:49:36 <Cale> and then type constructors
02:49:39 <Cale> @kind Maybe
02:49:39 <lambdabot> * -> *
02:49:42 <Cale> @kind IO
02:49:43 <lambdabot> * -> *
02:49:50 <Cale> @kind Maybe Integer
02:49:50 <lambdabot> *
02:49:56 <hpaste>  (anonymous) annotated "I get an error i don't understand, please explain, so i can learn! tia!" with "(no title)" at http://hpaste.org/4175#a4
02:50:00 <Cale> @kind IO String
02:50:00 <lambdabot> *
02:50:21 <Cale> @kind Control.Monad.RWS.RWST
02:50:21 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
02:50:36 <Cale> hehe, that's the most complicated kind in the libraries, I'm fairly sure :)
02:51:11 <goban_> =p, wow thats alot of ->s
02:52:03 <Cale> If you haven't seen type constructors before, if t is any type (with kind *) then the type (Maybe t) has values which are either the value Nothing, or Just x, where x is something of type t
02:52:16 <Cale> For example
02:52:21 <Cale> Just 5 :: Maybe Integer
02:52:28 <Cale> Nothing :: Maybe Integer
02:52:41 <Cale> Just "Hello" :: Maybe String
02:53:01 <Cale> Nothing :: Maybe String  -- Nothing is actually polymorphic
02:53:12 <Cale> :t Nothing
02:53:13 <lambdabot> forall a. Maybe a
02:53:42 <Cale> It's a useful type for when you have a function that might fail to produce a value for some inputs.
02:54:04 <Cale> So you can then have it produce Nothing when it fails, and Just x when it succeeds.
02:54:32 <Cale> Another example of a type constructor is the type constructor for lists: []
02:54:37 <Cale> @kind []
02:54:38 <lambdabot> * -> *
02:54:44 <hpaste>  (anonymous) annotated "Problems in main" with "(no title)" at http://hpaste.org/4183#a3
02:54:45 <Cale> @kind [Integer]
02:54:45 <lambdabot> *
02:55:03 <Cale> If t is any type, then [t] is the type of lists of values of that type.
02:55:50 <Cale> goban_: does that make sense?
02:57:05 <goban_> yeah does
02:57:33 <Cale> But there's not really any sense of inheritance.
02:58:07 <Cale> You can declare that instances of one typeclass must always be instances of another
02:58:23 <Cale> But that doesn't save you from doing the work of actually writing the instances.
02:58:37 <Taejo> Cale, what's the syntax for that?
02:58:54 <Cale> class Super a => Sub a where ...
02:59:11 <Cale> @src Num
02:59:11 <lambdabot> class  (Eq a, Show a) => Num a  where
02:59:11 <lambdabot>     (+), (-), (*)           :: a -> a -> a
02:59:11 <lambdabot>     negate, abs, signum     :: a -> a
02:59:11 <lambdabot>     fromInteger             :: Integer -> a
02:59:41 <Cale> (that's kind of an embarrassing example, given that Eq and Show really shouldn't be superclasses of Num, but they are anyway.
02:59:43 <Cale> )
02:59:46 <Cale> @src Ord
02:59:46 <lambdabot> class  (Eq a) => Ord a  where
02:59:46 <lambdabot>     compare      :: a -> a -> Ordering
02:59:46 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
02:59:46 <lambdabot>     max, min         :: a -> a -> a
03:00:01 <wli> instance Ord t => Ord [t] where ... is I think what they wanted.
03:00:29 <Cale> Oh, right, you can define instances of classes which make use of existing instances too.
03:00:57 <goban_> so if i wanted one typeclass that was slightly different than another typeclass, i would have to cp the similar code?
03:01:28 <Cale> Yes, but usually you'd just implement one typeclass, and then have a smaller typeclass holding the extra bits.
03:01:37 <goban_> Cale: actually ill just come back after ive read the tutorial =p thanks for all the help
03:01:58 <Cale> goban_: We do a lot of things in a very different way from OO programming :)
03:02:23 <Cale> goban_: another option is just to pass around data structures that have a bunch of functions in them
03:02:26 <goban_> yeah most of my experience is in java (college), trying to learn new stuff
03:02:30 <Cale> Those are sort of like objects.
03:03:08 <Cale> Functions are first class values, so if you want to package functions together with data, then you can just do that.
03:03:30 <goban_> yeah do it all the time in python =p
03:04:31 <mercury^> Cale: but then every instance of the type carries around all the function pointers, no?
03:04:57 <Cale> mercury^: yep
03:05:11 <dmwit_> That's okay, instances of classes carry around a dictionary of functions, too. ;-)
03:05:11 <mercury^> Sounds more useful for when you really need that flexibility.
03:05:38 <mercury^> the instances of classes just carry a single pointer
03:05:41 <Cale> mercury^: well, yeah, you wouldn't do it if you didn't need to
03:05:53 <Cale> mercury^: oh?
03:06:06 <mercury^> Well, for all member functions.
03:06:22 <Cale> Like a pointer to a table?
03:06:25 <mercury^> Yes.
03:06:40 <nipuL> if i want to upgrade the X11 module, do i need to remove the old one or can they coexist?
03:06:54 <wli> Dictionary passing is only needed under certain circumstances.
03:06:57 <Cale> mercury^: Well, I suppose you can replicate that trick as well
03:07:17 <mercury^> Yeah, but then you're just manually implementing typeclasses again.
03:07:20 <wli> Static typing eliminates the need for it most of the time.
03:07:25 <Cale> mercury^: Just have values which share a tuple (or more likely record) of functions
03:07:57 <mercury^> Cale: problem is to type that tuple
03:08:02 <Cale> and then keep the other bits separate. It seems like a bit of a premature optimisation to be worried about that cost though.
03:08:31 <Cale> mercury^: Usually it would be a custom datatype corresponding to the class you'd have in OO.
03:16:57 <Beelsebob> okay... I'm really missing what's hard about problem 79
03:17:05 <Beelsebob> I just did it in about 10 seconds in my head
03:17:52 <dibblego> Beelsebob, problem 79?
03:17:58 <Beelsebob> Project Euler
03:20:05 <desegnis> Beelsebob: The hard thing is interpreting the description and understanding that it is really meant to be that simple.
03:20:12 <Beelsebob> hehe
03:21:01 <RayNbow> hmm, Project Euler... I haven't spent any time on that recently... (too busy with completing all kind of assignments)
03:21:53 <dibblego> what do people do with their answers? post them on their own website?
03:22:14 <glguy> dibblego: they log in and enter them to get credit for them
03:22:20 <glguy> which gives them access to the forum
03:22:33 <glguy> and if their answer was particularly novel or they are excited, they can post it
03:22:34 <dibblego> then what?
03:22:46 <glguy> it check them off your list
03:22:51 <dibblego> mk
03:23:04 <glguy> You don't get money or anything, if that's what you were wondering :)
03:23:19 <dibblego> no, I wsa just wondering if it was entirely personal
03:24:00 <RayNbow> Project Euler is good for your own ego ;)
03:24:23 <Beelsebob> dibblego: use them for debugging Hat
03:24:23 <Beelsebob> :D
03:24:34 <wli> It's not for mine.
03:24:49 <Beelsebob> every time I hit a bug in one of my answers, I use Hat on it, and check that it works properly
03:24:59 <glguy> wli: they make you feel bad for not working on harder problems?
03:25:40 <dibblego> wtf is Hat?
03:25:45 <Beelsebob> Haskell debugger
03:25:54 <dibblego> gotta get around to playing with that
03:26:55 <wli> glguy: I feel like something has destroyed my brain because problems I'm sure I could've done in the past are very difficult or impossible for me.
03:29:24 <Beelsebob> what type is necessary for Haskell to be able to generate an aritmetic sequence? i.e. what type must 2 and 4 be in [2,4..]
03:29:40 <wli> Enum
03:30:18 <Beelsebob> so... it can't do it for Integers then
03:30:20 <Beelsebob> :/
03:30:32 <glguy> :t \ x y -> [x,y..]
03:30:33 <wli> It can.
03:30:33 <lambdabot> forall t. (Enum t) => t -> t -> [t]
03:30:48 <glguy> > [1,2::Integer..]
03:30:48 <lambdabot>  Parse error at "Integ..." (column 7)
03:30:56 <glguy> > [1,(2::Integer)..]
03:30:58 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
03:31:06 <Beelsebob> okay... that confuses me then
03:31:16 <Cale> @src Enum
03:31:17 <lambdabot> class  Enum a   where
03:31:17 <lambdabot>     succ                     :: a -> a
03:31:17 <lambdabot>     pred                     :: a -> a
03:31:17 <lambdabot>     toEnum                   :: Int -> a
03:31:17 <lambdabot>     fromEnum                 :: a -> Int
03:31:19 <lambdabot> [3 @more lines]
03:31:24 <Cale> @more
03:31:24 <lambdabot>     enumFrom                 :: a -> [a]
03:31:24 <lambdabot>     enumFromThen, enumFromTo :: a -> a -> [a]
03:31:24 <lambdabot>     enumFromThenTo           :: a -> a -> a -> [a]
03:31:41 <Cale> toEnum and fromEnum just have stupid types
03:31:47 <Beelsebob> I'm currently getting: No instance for (Enum [Integer]) arising from the arithmetic sequence `2, 4 .. ' at Euler.hs:178:45-51
03:32:08 <Cale> Beelsebob: That's because there's no instance of Enum for lists of integers
03:32:20 <Beelsebob> oh... duh
03:32:22 <Beelsebob> I fail
03:32:26 <Beelsebob> why the fuck does it want that
03:32:32 * Beelsebob goes and ponders
03:32:56 <Beelsebob> bah, just a bracketing error
04:20:05 <noteventime> Is there some way to create an alias for a constructor?
04:20:26 <Cale> noteventime: Not one which you can pattern match with.
04:20:36 <noteventime> ok :-/
04:20:57 <noteventime> Thanks anyway :-)
04:21:24 <Cale> It would be nice if views were implemented. That would be a trivial application of them.
04:21:45 <Heffalump> 6.10 will have view patterns
04:24:16 <Cale> noteventime: You *do* mean a data constructor of course :)
04:25:15 <kaol> 6.8 just came out and people are anticipating 6.10 already?
04:26:04 <opqdonut> view patterns?
04:26:37 <opqdonut> ah, performing predicates/transforms while matching?
04:27:21 <Cale> opqdonut: If you have a function view :: T -> V then you can have a pattern of the form (view -> pat), where pat matches against V, and that's a pattern for matching values of type T.
04:27:38 <opqdonut> yeah, that's what i meant :)
04:29:38 <Cale> http://hackage.haskell.org/trac/ghc/wiki/ViewPatterns
04:29:40 <lambdabot> Title: ViewPatterns - GHC - Trac
04:32:23 <noteventime> Cale: Yes :-)
04:39:00 <Heffalump> kaol: I want to play with type synonym families properly.
04:39:34 <zx]treads> hey, prob with build hsql-1.7 pkg
04:39:46 <zx]treads> with ghc6.8 i get Database/HSQL.hsc:66:7:
04:39:46 <zx]treads>     Could not find module `System.Time':
04:39:46 <zx]treads>       it is a member of package old-time-1.0.0.0, which is hidden
04:39:59 <Heffalump> add it to the cabal file
04:39:59 <zx]treads> i do ghc-pkg expose old-time
04:40:20 <Heffalump> cabal builds always hide everything except things listed in the .cabal file
04:41:04 <zx]treads> i should add it in build-depends: ?
04:43:58 <Heffalump> zx]treads: yes
04:45:19 <zx]treads> i add it to build-depends, now i get a bunch of build error
04:45:40 <zx]treads> errors*.  maybe hsql doesn't compile with 6.8.1 ?
04:49:21 <jewel> was the source code for the miranda compiler ever released?
05:03:48 <Cale> jewel: I don't know, but I'm fairly sure that Haskell was in part a response to the fact that Miranda was proprietary. (And also that there was too much segmentation in lazy language research.)
05:05:05 <Heffalump> yes, the HOPL-III paper confirms that
05:06:37 <sciolizer> @pl \x -> x x
05:06:37 <lambdabot> join id
05:06:43 <sciolizer> :)
05:07:14 <EvilTerran> isn't that ill-typed?
05:07:20 <EvilTerran> ?type join id
05:07:22 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a1
05:07:22 <lambdabot>     Probable cause: `id' is applied to too many arguments
05:07:22 <lambdabot>     In the first argument of `join', namely `id'
05:07:28 <Cale> Yeah, it is, but @pl doesn't know about types
05:07:31 <sciolizer> pl is more powerful than haskell!
05:07:45 <Cale> No, it just has a weaker type system :)
05:07:48 <sciolizer> :)
05:08:27 <idnar> ?type \x -> x x
05:08:29 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
05:08:29 <lambdabot>     Probable cause: `x' is applied to too many arguments
05:08:29 <lambdabot>     In the expression: x x
05:09:11 <sciolizer> The set of all sets that evaluate themselves?
05:09:40 <zx]treads> managed to build hsql-1.7 with ghc6.8.1 . i added -fglasgow-exts option in build flags
05:09:51 <zx]treads> i dunno if was the right way to do it
05:11:35 <phao> is haskell standarized ?
05:12:18 <sciolizer> phao: Haskell98 is the standard. Almost everybody includes extensions in the compiler, though.
05:14:27 <sciolizer> zx]treads: I can build hsql without extensions, but I have ghc6.6.1
05:15:28 <puusorsa> if i have a list, how to get another list of same length with numbers ranging from 1 to -1?
05:16:31 <EvilTerran> ... 1 to -1?
05:16:55 <EvilTerran> > zipWith const (cycle [-1..1]) "abcdefg"
05:16:57 <lambdabot>  [-1,0,1,-1,0,1,-1]
05:18:01 <puusorsa> no, like: makeIt "abcde" = [1, 0.5, 0, -0.5, -1]
05:19:13 <olsner> > zipWith (const . (*0.5)) (cycle . reverse $ [-2..2]) "abcdefg"
05:19:15 <lambdabot>  [1.0,0.5,0.0,-0.5,-1.0,1.0,0.5]
05:19:46 <desegnis> > let h = 2 / fromInteger (length "abcdefg") in [1,1-h..-1]
05:19:46 <MyCatVerbs> > [ x + y | x <- [1..] | y <- [2..] ]
05:19:47 <lambdabot>   Not in scope: `..-'
05:19:47 <lambdabot>  Parse error at "|" (column 22)
05:20:18 <desegnis> We need a new [...] syntax :)
05:20:46 <olsner> > [ x + y | x <- [1..], y <- [2..] ]
05:20:47 <lambdabot>  [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,3...
05:20:54 <MyCatVerbs> Does \bot support parallel list comprehensions?
05:21:01 <EvilTerran> no, it's only h98
05:21:28 <desegnis> > let h = 2 / fromIntegral (length "abcdefg") in [1,(1-h)..(-1)]
05:21:28 <lambdabot>  [1.0,0.7142857142857143,0.4285714285714286,0.1428571428571429,-0.14285714285...
05:21:31 <olsner> > {- or did you mean -} zipWith (+) [1..] [2..] -- ?
05:21:31 <lambdabot>  [3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,5...
05:21:45 <MyCatVerbs> EvilTerran: thanks, handy to know.
05:21:52 <fasta> > take (length (['a'..'g'])(cycle [-1..1])
05:21:52 <lambdabot> Unbalanced parentheses
05:22:02 <EvilTerran> it uses Language.Haskell, iirc
05:22:24 <EvilTerran> which only does h98
05:22:44 <MyCatVerbs> olsner: not quite the same objective. :)
05:23:18 <fasta> > take (length ['a'..'g']) (cycle [-1..1])
05:23:20 <lambdabot>  [-1,0,1,-1,0,1,-1]
05:30:59 <thorsten> hi folks
05:31:52 <RayNbow> @src Bounded
05:31:52 <lambdabot> class  Bounded a  where
05:31:52 <lambdabot>     minBound, maxBound :: a
05:31:57 <zx]treads> sciolizer: hsql-1.7 doesn't seem to build right with ghc6.8.1 and new version of cabal. I can't build the hsql-sqlite3 and hsql-mysql
05:32:16 <zx]treads> maybe i have to stick with 6.6.1
05:32:29 <zx]treads> hey does any1 know the state of hackage?
05:32:39 <zx]treads> are the pkgs updated to work with 6.8 ?
05:41:28 <Heffalump> zx]treads: not consistently, I believe
07:17:20 <Beelsebob> @hoogle [a] -> [a]
07:17:21 <lambdabot> Prelude.cycle :: [a] -> [a]
07:17:21 <lambdabot> Prelude.init :: [a] -> [a]
07:17:21 <lambdabot> Prelude.reverse :: [a] -> [a]
07:17:26 <Beelsebob> @hoogle [a] -> [[a]]
07:17:26 <lambdabot> List.inits :: [a] -> [[a]]
07:17:26 <lambdabot> List.tails :: [a] -> [[a]]
07:17:26 <lambdabot> List.group :: Eq a => [a] -> [[a]]
07:21:38 <byorgey> hiya Beelsebob, how's Project Euler? =)
07:22:09 <Beelsebob> 41 done :)
07:22:24 <byorgey> nice!
07:24:16 <Beelsebob> got a bit confused when I did one in my head in about 10 seconds
07:24:21 <Beelsebob> and wondered if it was meant to be harder
07:24:26 <Beelsebob> but it was right, so meh
07:24:52 <byorgey> heh, yeah, some of them aren't so hard if you already know whatever math you need to know to solve it.
07:25:18 <Choko> how do I get the type for / or * in ghci ?
07:25:24 <Heffalump> :t (/)
07:25:25 <lambdabot> forall a. (Fractional a) => a -> a -> a
07:25:28 <Choko> thanks
07:28:35 <Mitar> where can i find definition of a monad either?
07:28:49 <Mitar> i am getting this error when I am trying to use it as a monad
07:28:53 <oerjan> @src Monad
07:28:53 <lambdabot> class  Monad m  where
07:28:53 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
07:28:53 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
07:28:53 <lambdabot>     return      :: a -> m a
07:28:53 <lambdabot>     fail        :: String -> m a
07:28:55 <Mitar> No instance for (Monad (Either SemError))
07:29:11 <oerjan> Control.Monad.Error
07:29:30 <oerjan> or .Instances
07:30:37 <oerjan> note that SemError then needs to be an instance of Error
07:31:11 <byorgey> \o/  <-- me solving another Project Euler problem! =D
07:32:04 <Mitar> but I would not like to be an instance of Error :-)
07:32:22 <Mitar> i do not need "throwException" and "catchException"
07:32:28 <Mitar> i would like only "return" and "fail" :-)
07:32:42 <oerjan> alas it's used in the definition of fail for that monad
07:32:57 <oerjan> @src Either fail
07:32:57 <lambdabot> fail msg      = Left (strMsg msg)
07:33:52 <Mitar> hm, thanks
07:40:42 <noteventime> :t iterateM
07:40:43 <lambdabot> Not in scope: `iterateM'
07:41:28 <oerjan> it is hard to make an infinite list monadically...
07:41:41 <oerjan> although some monads can do it
07:43:21 <Beelsebob> > 5%3
07:43:23 <lambdabot>  5%3
07:43:34 <Beelsebob> @index %
07:43:34 <lambdabot> Data.Ratio
07:43:52 <idnar> @type fail
07:43:53 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
07:43:55 <oerjan> :t let iterateM f x = liftM (x:) (f x >>= iterateM f) in iterateM
07:43:55 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m a) -> a -> m [a]
07:45:08 <oerjan> > let iterateM f x = liftM (x:) (f x >>= iterateM f) in runReader (iterateM return 1) "whatever"
07:45:09 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
07:45:53 <fasta> Anyone who built nhc98?
07:49:30 <LoganCapaldo> @type let iterateM f x = liftM (x:) (f x >>= iterateM f) ; iterate f x = runIdentity (iterateM (return .f) x) in iterate
07:49:31 <lambdabot> forall b. (b -> b) -> b -> [b]
07:50:57 <LoganCapaldo> > let iterateM f x = liftM (x:) (f x >>= iterateM f) ; iterate f x = runIdentity (iterateM (return .f) x) in iterate id 1
07:50:59 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
08:03:30 <sethk> Hello, everyone.
08:05:33 <byorgey> hi sethk.
08:06:31 <sethk> who maintains the web site?  6.4 is marked as "latest" in the docs section.
08:06:55 <SamB_XP> !
08:07:00 <SamB_XP> what page is that?
08:07:08 <SamB_XP> sethk: perhaps you do?
08:07:56 <sethk> SamB_XP, I'd need all sorts of passwords.  :)  haskell.org/ghc/docs
08:08:18 <SamB_XP> that doesn't look like a page to me
08:08:49 <sethk> SamB_XP, it's a list of directories, which is surely a page.
08:09:13 <SamB_XP> I think 6.4-latest just means "the latest version in the 6.4.x series"
08:09:28 <tphyahoo-haskell> instance Functor ((->) r)
08:09:29 <SamB_XP> i.e. a symlink to 6.4.2
08:09:52 <tphyahoo-haskell> *Prompt> :t ((->)
08:09:53 <tphyahoo-haskell> <interactive>:1:2: parse error on input `->'
08:09:59 <sethk> SamB_XP, I guess I misinterpreted, then.
08:10:12 <tphyahoo-haskell> so what is this type, and can I get ghci to give me meaningful information about it?
08:10:22 <Eliecer> alguien que hable español?
08:10:27 <tphyahoo-haskell> I understand it's like the arrow in a function type but... my brain doesn't get it
08:10:29 <tphyahoo-haskell> yo hablo
08:10:31 <tphyahoo-haskell> que pasa
08:10:35 <SamB_XP> tphyahoo-haskell: try ":i (->)"
08:10:51 <SamB_XP> :t tells you the type of an expression, not information about a type
08:10:57 <lambdabot> parse error on input `type'
08:10:58 <Eliecer> hola! estoy estudiando haskell, y tengo una duda sobre los tipos enumerados
08:11:17 <SamB_XP> also... (->) is the type constructor for function types
08:11:18 <Eliecer> data Direccion = Norte | Sur | Este | Oueste deriving Show
08:11:32 <Eliecer> puedo hacer referencia a una direccion con un número? esa es mi pregunta
08:11:47 <SamB_XP> tphyahoo-haskell: that arrow IS the arrow in function types...
08:11:55 <darrint> Is it hard to cross compile from x86-32 to x86-64?
08:12:03 <fasta> Eliecer: I hope you are joking.
08:12:09 <sethk> Eliecer, you could make an array, but that sort of defeats the purpose of enumerations
08:12:13 <SamB_XP> darrint: you only need to use qemu
08:12:50 <darrint> I'm familiar enough with qemu. Seems like that'd be a slow compile. :-)
08:12:58 <Eliecer> my question is... i can said 1 and i an said... Norte?
08:13:00 <SamB_XP> by which I mean, yes, it IS hard ;-)
08:13:07 <darrint> ok. hehe
08:13:16 <Eliecer> i can't speak English
08:13:27 <fasta> Eliecer: then join #haskell-es
08:13:42 <Eliecer> thank you! fasta
08:13:43 <SamB_XP> so you have to cheat and run the x86-64 compiler
08:13:47 <Eliecer> jejeje
08:14:00 <sethk> Eliecer, ya dicho en inglais
08:14:12 <darrint> What's the easiest way to do string formatting? I see text.printf but it isn't installed by default on ubuntu.
08:14:36 <sethk> darrint, install it.
08:14:40 <darrint> ok
08:14:43 <Eliecer> bye
08:15:14 <tphyahoo-haskell> darrint: you get it by default on 6.8, I thought 6.6 as well
08:15:18 <tphyahoo-haskell> as part of extralibs
08:15:21 <SamB_XP> darrint: another option is to upgrade your computer to an x86-64 and install a 64-bit userspace somehow or other
08:15:49 <fasta> Why is this cross-compilation business so difficult?
08:15:57 <SamB_XP> or ... um ... use someone else's x86-64
08:16:00 <oerjan> fasta: #haskell.es not -es
08:16:13 <fasta> oerjan: well, there was one in -es.
08:16:25 <fasta> oerjan: I will use .es next time.
08:16:50 <SamB_XP> fasta: I'm not sure
08:17:32 <darrint> I am such an idiot. Text.Printf was there. I guess I mistyped. thanks all.
08:17:36 <SamB_XP> it might have something to do with figuring out the offsets of things in structures?
08:17:39 <SamB_XP> darrint: hehe
08:18:03 <SamB_XP> darrint: perhaps you tried it with a capitol f?
08:18:10 <darrint> possibly
08:18:14 <SamB_XP> (capital?)
08:18:50 <darrint> One more thing, what's the right way to import functions into the namespace of ghci? I've been doing :m +module but that does annoying stuff with the prompt.
08:19:42 <SamB_XP> well, if you are working on a module of your own, you could just import the module there and then :l the file
08:19:57 <fasta> darrint: I don't think you can load individual functions.
08:20:10 <darrint> fasta: The whole module would be fine
08:20:17 <fasta> darrint: and define annoying
08:20:30 <darrint> Prelude Text.Printf>
08:21:00 <fasta> darrint: unless you hack ghci yourself, that's not going to go away, I guess.
08:21:05 <darrint> ok
08:21:11 <SamB_XP> darrint: make a file of your own, stick import Text.Printf at the top, then :l that file
08:21:28 <SamB_XP> then probably you will see "*Main>"
08:21:44 <EvilTerran> :set prompt "ghci> "
08:21:48 <tphyahoo-haskell> (,) is both a data constructor and a type constror. (->) is only a type constructur.
08:22:04 <darrint> EvilTerran: nice
08:22:13 * EvilTerran has this in his $HOME/.ghci
08:22:25 <tphyahoo-haskell> I got these concepts confused in my mind...
08:22:32 <SamB_XP> tphyahoo-haskell: ah
08:22:57 <tphyahoo-haskell> I guess I assumed all operator-looking type things were data constructors.
08:24:22 <oerjan> EvilTerran: prompt is not listed in the docs?
08:24:47 <EvilTerran> it's listed in :?
08:27:59 <chessguy> > 'a' - 'b'
08:28:08 <lambdabot>   add an instance declaration for (Num Char)
08:28:08 <lambdabot>     In the expression: 'a' - 'b'...
08:28:18 <oerjan> tphyahoo-haskell: i think in haskell 98, (->) is the only exception, but type operators have been added since
08:29:55 <SamB_XP> oerjan: such as?
08:30:13 <tphyahoo-haskell> I'm no longer so sure (,) is a type constructor or not.
08:30:23 <SamB_XP> tphyahoo-haskell: it is
08:30:32 <tphyahoo-haskell> and also a data constructor?
08:30:36 <SamB_XP> yeah
08:30:56 <tphyahoo-haskell> But just is only a data constructor?
08:31:01 <tphyahoo-haskell> I mean, Just?
08:31:28 <SamB_XP> Just isn't even a reserved word
08:31:41 <tphyahoo-haskell> it constructs a Maybe value, I mean
08:32:12 <SamB_XP> Prelude does indeed export a data constructor of that name, and not a type constructor
08:32:12 <tphyahoo-haskell> so it's a data constructor... data constructors take data values as arguments... type constructors take types as arguments...
08:32:44 <tphyahoo-haskell> (,) can take both, so it's both. Maybe can take only types, so it's a type constructor. Same with (->)
08:33:08 <SamB_XP> well, (->) is actually special syntax
08:33:11 <tphyahoo-haskell> that makes sense to me.
08:33:19 <oerjan> SamB_XP: i mean type operators are allowed now.  i don't know where they are used.
08:33:25 <chessguy> @hoogle iterateM
08:33:25 <lambdabot> No matches found
08:34:07 <chessguy> @hoogle (a -> m a) -> a -> m [a]
08:34:08 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
08:34:08 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
08:34:08 <lambdabot> Data.Generics.Schemes.everywhere :: (a -> a) -> a -> a
08:35:11 <oerjan> chessguy: it may not be too useful, after all it doesn't work with strict monads such as IO
08:35:39 <chessguy> oh, so i can't create an infinite list in IO ?
08:35:42 <chessguy> with that
08:35:47 <oerjan> nope
08:35:53 <tphyahoo-haskell> @hoogle ((->) a)
08:35:53 <lambdabot> Did you mean: ((->) a
08:35:53 <lambdabot> Prelude.undefined :: a
08:35:53 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
08:36:09 <chessguy> bah
08:36:16 <ari> chessguy: I'm under the impression that you can, using unsafeInterleaveIO, but I've never done it myself
08:36:26 <oerjan> indeed you can
08:36:49 <oerjan> although of course that ruins ordering of actions
08:37:29 <hpaste>  chessguy pasted "trying to impove this simple GA" at http://hpaste.org/4192
08:37:50 <chessguy> i was going to use iterateM and takeWhile to simplify this, but i guess that's not going to happen
08:38:31 <tphyahoo-haskell> no, I didn't mean prelude.undefined. I meant, a type constructor that when given a type b, yields function type (a->b)
08:38:43 <tphyahoo-haskell> at least, I think that's what I meant, oh lambdabot :)
08:38:53 <oerjan> chessguy: you can write an iterateWhile
08:39:14 <oerjan> as long as the final result is finite
08:39:19 <SamB_XP> "((->) a)" meets those constraints
08:39:23 <idnar> @kind ((->) a)
08:39:25 <lambdabot> Not in scope: type variable `a'
08:39:27 <idnar> @kind ((->) ?a)
08:39:28 <lambdabot> parse error on input `?a'
08:39:45 <SamB_XP> hoogle asks the silliest questions sometimes
08:39:47 <idnar> @kind (->)
08:39:47 <lambdabot> ?? -> ? -> *
08:39:56 <SamB_XP> "did you mean ((->) a" indeed
08:40:30 <tphyahoo-haskell> yes, but I thought hoogle might be able to feed me other examples
08:40:41 * SamB_XP wonders why ghci wants a to be in scope
08:41:01 <idnar> @kind forall a. ((->) a)
08:41:02 <lambdabot>     `(->) a' is not applied to enough type arguments
08:41:02 <lambdabot>     Expected kind `*', but `(->) a' has kind `? -> *'
08:41:14 <chessguy> @type let iterateWhile f p = f >>= flip when p in iterateWhile
08:41:14 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m () -> m ()
08:41:26 <idnar> hmm, I don't actually know anything about kinds
08:41:39 <SamB_XP> I think :kind needs some lovin'
08:42:01 <idnar> what does "?" mean?
08:42:21 <doserj> ? means * or #
08:42:37 <chessguy> @undo do { x <- f; when (p x) f }
08:42:37 <lambdabot> f >>= \ x -> when (p x) f
08:42:43 <SamB_XP> that means "anything at all, down to and including unboxed tuples", doesn't it?
08:42:46 <tphyahoo-haskell> what do * and # mean?
08:42:55 <chessguy> @pl \f p ->  f >>= \ x -> when (p x) f
08:42:55 <lambdabot> liftM2 (.) (>>=) (flip (flip . (when .)))
08:43:00 <SamB_XP> @kind (->)
08:43:01 <lambdabot> ?? -> ? -> *
08:43:08 <doserj> * are the normal types, # are unboxed
08:43:12 <idnar> and ??
08:43:13 <chessguy> @type do { x <- f; when (p x) f }
08:43:15 <lambdabot> Not in scope: `f'
08:43:15 <lambdabot> Not in scope: `p'
08:43:15 <lambdabot> Not in scope: `f'
08:43:21 <idnar> er, that is, what does ?? mean?
08:43:25 <chessguy> @type do { x <- ?f; when (?p x) ?f }
08:43:25 <lambdabot> forall (t :: * -> *). (Monad t, ?p::() -> Bool, ?f::t ()) => t ()
08:43:34 <doserj> ?? means ? or unboxed tuples, i think
08:43:34 <lambdabot> Plugin `compose' failed with: Unknown command: ""
08:43:54 <SamB_XP> but unboxed tuples are for return values
08:43:56 <SamB_XP> not arguments
08:44:30 <oerjan> doserj: the other way around
08:44:31 <int-e> ? is ?? or (#), ?? is * or #
08:44:43 <SamB_XP> that's more like it ;-)
08:44:46 <doserj> oerjan: ah
08:46:12 <tphyahoo-haskell> that doesnt quite parse for me.
08:46:25 <SamB_XP> (#) is the kind of unboxed tuples
08:46:54 <tphyahoo-haskell> ?? is * (normal) or # (unboxed?)      ?
08:46:54 <lambdabot> Plugin `compose' failed with: Unknown command: ""
08:47:27 <oerjan> tphyahoo-haskell: btw the places i know that has ((->) r) are Control.Monad.Reader and Control.Monad.Instances, which define it as a monad
08:47:32 <tphyahoo-haskell> that still leaves unclear what ? is
08:48:13 <allbery_b> <int-e> ? is ?? or (#), ?? is * or #
08:48:24 <allbery_b> # is a simple unboxed type such as Int#
08:48:34 <allbery_b> (#) is an unboxed tuple
08:48:49 <allbery_b> such as (# Int#,Char# #)
08:49:15 <SamB_XP> http://hackage.haskell.org/trac/ghc/wiki/IntermediateTypes may be of use?
08:49:17 <lambdabot> Title: IntermediateTypes - GHC - Trac
08:49:24 <allbery_b> you won't see those in normal code but they're often used behind your back
08:50:21 <SamB_XP> especially if you wnat your brain to explode, I guess..
08:51:47 <oerjan> That page still does not list that mysterious ! kind (did i ever get an explanation of it? i forget)
08:53:02 <cyberix> "data Pari a b = Pari a b" fails in ghci. Why?
08:53:15 <allbery_b> ghci can't do data types etc.
08:53:20 <allbery_b> put it in a file and :load it
08:53:32 <allbery_b> the prompt only supports evaluation
08:53:58 <cyberix> Is this unfixable or on the ghci todo list?
08:54:32 <allbery_b> I think there's an enhancement request open.  not sure what priority if any it's been given
08:54:37 <tphyahoo-haskell> thanks, that will really help me understand this obscore syntax that google doesn't help much with (try googling on # or * sometime :) )
08:59:12 <tphyahoo-haskell> folks, on page 5 of http://research.microsoft.com/%7Esimonpj/papers/ext%2Df/fc-popl.pdf is a mess of greek leters and notations that says it is "typing rules for system F(c)"
08:59:15 <lambdabot> http://tinyurl.com/27ecf3
08:59:41 <tphyahoo-haskell> I see this kind of thing a lot in haskell papers and have zero comprehension. is there some intro to understanding this type of notation?
08:59:54 <tphyahoo-haskell> or some book to read?
09:00:13 <allbery_b> Types and Programming Languages, I think
09:00:27 <byorgey> by Benjamin Pierce
09:00:41 <oerjan> sequent calculus or natural deduction is also something to look up
09:01:57 <oerjan> since that's essentially what it is, with type assignments instead of propositions
09:04:22 <oerjan> http://en.wikipedia.org/wiki/Sequent_calculus
09:04:23 <lambdabot> Title: Sequent calculus - Wikipedia, the free encyclopedia
09:05:37 <darrint> Is there a typeclass for records with some kind of key which can be compared, but is distinct from Eq?
09:06:21 <tphyahoo-haskell> maybe you want Data.Map? what do you want to do, darring?
09:06:33 <tphyahoo-haskell> s/darring/darrint/
09:06:59 <tphyahoo-haskell> do you want a lookup type table?
09:07:12 <tphyahoo-haskell> like a hash in perl?
09:07:29 <oerjan> darrint: might be easier to use a newtype and a custom Eq
09:07:33 <darrint> I have a record (I think that's the word) Player {name:: String, etc. } I want to capture that two player recordss with the same name are the same player, even though the records are not Eq.
09:07:50 <Heffalump> you should make your own class, probably
09:08:02 <darrint> Oh ok. I figured that one would be stock somewhere.
09:08:09 <EvilTerran> or just your own function; playerEq or sth
09:08:27 <darrint> sth?
09:08:32 <EvilTerran> "something"
09:08:34 <tphyahoo-haskell> why not just data Player..... deriving Eq?
09:08:45 <oerjan> darrint: if you never compare records for ordinary equality you _could_ redefine Eq
09:09:04 <EvilTerran> haskell's type system doesn't really lend itself to functions that can work on more than one record type, unfortunately
09:09:09 <axm> cause the rest of the data might be different and that could be a problem to call equal in his case
09:09:20 <EvilTerran> i think the general consensus is that our current record system is a bit rubbish ;)
09:09:24 <oerjan> tphyahoo-haskell: because he does _not_ want to use the usual definition
09:09:30 <darrint> I thought of that, but it seems like a bad idea to "abuse" if you will, Eq, since that could bite me later. A new class it is.
09:09:44 <EvilTerran> do you even need a class for it?
09:09:48 <darrint> Class recordIdentity here I come.
09:10:19 <oerjan> darrint: if you are not using it for more than one record type a class seems overkill
09:10:35 <darrint> but fun, and since I'm implementing "go fish", I'm allowed to have fun. ;-)
09:10:56 <oerjan> can't argue with that
09:11:19 <tphyahoo-haskell> darrint: have you read ryan ingram's thread on using MonadPrompt for scriptable games on haskell cafe and on his blog?\
09:11:37 <darrint> I haven't, but I bet that will come in handy soon.
09:12:25 <axm> is there a way to force strict evaluation of an arrow?
09:12:56 <tphyahoo-haskell> I am trying to use this to script a simple (guess a number) game I wrote as an exercise.
09:15:25 <Heffalump> axm: what kind of arrow?
09:15:37 <sethk> I have a value:  array (0,0) [(0,("74.6.23.124",(0,11)))]      I need to get the [ ... ] portion.  How do I do that?
09:15:57 <axm> IOStateArrow
09:16:16 <byorgey> @type elems
09:16:17 <lambdabot> forall i e. (Ix i) => Array i e -> [e]
09:16:19 <integral> @hoogle toList
09:16:19 <lambdabot> Data.HashTable.toList :: HashTable key val -> IO [(key, val)]
09:16:19 <lambdabot> Data.IntMap.toList :: IntMap a -> [(Key, a)]
09:16:19 <lambdabot> Data.IntSet.toList :: IntSet -> [Int]
09:16:47 <sethk> integral, thanks
09:16:51 <axm> i am updating some data while rereading it, going into endless recursion it seems and i would like to test, if making the rereading strict would change that
09:16:55 <byorgey> @type assocs
09:16:57 <lambdabot> forall i e. (Ix i) => Array i e -> [(i, e)]
09:17:05 <byorgey> sethk: ^^^ maybe that's what you want?
09:17:15 <integral> err, assocs and elems look more useful, sethk, so I don't see why you're thanking me and not byorgey
09:17:20 <Heffalump> axm: is that in a standard library?
09:17:34 <sethk> integral, mostly because I don't understand byorgey's answer.  :)
09:17:52 <integral> His answer contains the word "Array".  Mine didn't. sheesh.
09:17:59 <axm> Heffalump, ugh, what exactly? i am mostly using hxt
09:18:11 <byorgey> sethk: the 'elems' and 'assocs' functions from Data.Array extract the list of elements, and the list of (index,element) pairs from an array, respectively.
09:18:32 <sethk> byorgey, thanks, I'll try that now.
09:18:33 <byorgey> sethk: why exactly do you have an array containing one element, anyway? =)
09:18:49 <sethk> byorgey, returned by the matchAllText function in regex-posix
09:18:59 <byorgey> oh, ok =)
09:19:09 <sethk> byorgey, obviously there could be more than one element  :)
09:19:18 <byorgey> right, I see.
09:19:45 <Heffalump> axm: hmm. I think you'd need to go into the source to change the strictness.
09:19:57 <Heffalump> you might be able to make a wrapper arrow that strictifies some stuff.
09:21:22 <axm> hm, i have not tried to do anything strict by now, any good starting pointers?
09:21:58 <axm> only thing i would know now would be the existence of $!
09:22:18 <Heffalump> there's that, and the DeepSeq module
09:22:20 <oerjan> also seq
09:22:43 <axm> ah, stumbled upon that but could not make sense of it
09:23:29 <Heffalump> seq and $! just evaluate the top-level of an expression
09:23:40 <Heffalump> this is a concept known as WHNF - "weak head-normal form"
09:23:53 <Heffalump> DeepSeq (which has deepSeq and $!!) evaluates an expression completely
09:23:53 <axm> oh, and $!! does it deep?
09:24:11 <Heffalump> right.
09:24:14 <sethk> integral, what I meant before was that I didn't see the @type assocs that he had written, only the lambdabot output for it, so I didn't know where it came from.
09:24:16 <axm> thanks, i'll try to use that
09:28:33 <byorgey> sethk: ah, sorry about that sethk.  I'm so used to using lambdabot to answer questions I forget that it's not necessarily obvious if you're not used to it =)
09:28:57 <ricky_clarkson> How does Haskell's compile-time polymorphism differ from C++ template expansion?
09:29:18 <Heffalump> ricky_clarkson: it's properly type-checked, for starters
09:30:16 <ricky_clarkson> You could imagine an extension to C++ allowing the same type checking.  How else does it differ?
09:30:34 <ricky_clarkson> Does source code get generated at any point in the implementation(s)?
09:30:57 <Heffalump> no, generally the same implementation is used for all the different types
09:31:17 <Heffalump> in the case of parametric polymorphism (no type class restriction), the same code can be used without any runtime information
09:31:35 <Heffalump> in the case of ad-hoc polymorphism (type classes) generally a dictionary gets passed, but it is open to implementations to specialise, and sometimes they do
09:31:51 <ricky_clarkson> A dictionary containing function pointers?
09:31:59 <Heffalump> I doubt any implementation uses explicit source expansion
09:32:02 <Saul_> Does anyone know of good sources on the history of haskell (other than 'Being lazy with class')?
09:32:04 <Heffalump> ricky_clarkson: yes
09:32:52 <ricky_clarkson> Is there any way to force specialisation (I'm not saying there should be)?
09:33:22 <oerjan> there is a pragma
09:33:31 <darrint> What is a "rigid variable" ?
09:33:35 <Heffalump> that's implementation-dependent. I know jhc lets you.
09:33:45 <ricky_clarkson> I see.  Thanks.
09:33:54 <Heffalump> darrint: one that can't be instantiated to an arbitrary type.
09:34:05 <Heffalump> (as opposed to a flexible variable)
09:34:05 <timstewart> How do I code an anonymous function of type IO Bool?  I have tried (\ -> return False) but I get an error, "parse error on input `->'".
09:34:19 <Heffalump> timstewart: return False
09:34:32 <timstewart> Heffalump: I'll try that.  Thanks!
09:34:41 <ricky_clarkson> @unpl return False
09:34:41 <lambdabot> return False
09:35:00 <Heffalump> timstewart: \ introduces parameters, which you need when you have types on the LHS of a function arrow, e.g. Int -> IO Bool could be implemented by \i -> return False
09:35:30 <ricky_clarkson> So would an implementation of QuickCheck in C++ allow you to 'infer' generators, as Haskell's does?
09:35:42 <ricky_clarkson> I'm not planning on writing this, just wondering.
09:35:48 <Heffalump> ricky_clarkson: I think so, yes
09:36:13 <ricky_clarkson> That really leaves Java out in the cold.
09:36:22 <Heffalump> doesn't Java have templates too now?
09:36:33 <ricky_clarkson> Not templates, generics.
09:36:39 <Heffalump> how do they differ?
09:36:40 <timstewart> Heffalump: Thanks!
09:37:10 <ricky_clarkson> They're erased, in general.
09:37:30 <Heffalump> which are?
09:37:35 <Heffalump> oh, as in there's no expansion?
09:37:42 <ricky_clarkson> Right.
09:37:55 <Heffalump> there must be some mechanism for ad-hoc polymorphism, though?
09:38:02 <ricky_clarkson> No dictionary, no generation of code.  You can use reflection in some cases.
09:38:19 <Heffalump> can't they use virtual dispatch on the contained type?
09:38:23 <ricky_clarkson> Nope.
09:38:42 <ihope> @docs
09:38:42 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
09:38:52 <ricky_clarkson> Not unless it happens to be retained for use reflectively, which isn't possible to guarantee statically.
09:39:07 <ricky_clarkson> That statement's a bit inaccurate.
09:40:35 <ricky_clarkson> C# always lets you get at the type at runtime.  I wonder whether Java is the only one that doesn't either provide static polymorphism or reification.
09:40:46 * ricky_clarkson wanders off to look at Nice.
09:41:27 <jdrake> What exactly does 'Just' do? (I noticed it is a -> Maybe a, but it doesn't really help)
09:41:37 <ihope> jdrake: well, it's a data constructor.
09:41:42 <ricky_clarkson> jdrake: It is a constructor.
09:41:53 <unk_red_> when doing c programming i "ctags -R /usr/include". This helps me enourmously when trying to figure out where things are and how they are defined. There are also man pages for most standard functions which I can call from my editor.
09:42:01 <ihope> It's like the number 3: it doesn't do anything; it just means something.
09:42:02 <unk_red_> is there anything i can do like that for haskell?
09:42:17 <oerjan> @src Maybe
09:42:17 <lambdabot> data Maybe a = Nothing | Just a
09:42:17 <ihope> And what it means depends on how the function it's passed to interprets it.
09:42:21 <Heffalump> there's a hasktags
09:42:25 <Heffalump> I've never used it
09:42:49 <unk_red_> what would i run hasktags on though?
09:43:38 <unk_red_> i want to be able to dig up all the stuff in Prelude and various imports. quickly.
09:43:57 <unk_red_> google/haskell.org aren't as pleasant to work with while i'm coding.
09:43:57 <ihope> Well, there's the GHC module documentation.
09:46:42 <jdrake> I have a setup where I am doing times <- ...  and then the next line I am using a let times3 = ...  with that value. Is there a way I can use a let times3 = ...   where times = ... so that <- is in someway put into the where clause?
09:47:30 <Heffalump> yes, just indent the where clause so it's part of the let
09:47:34 <gwern> goodness. using the GHC api sure results in a large binary. does anyone know any ways to slim it down? strip brought it down to 16m, and upx to 2.9M, but that still seems pretty big (also there must be a lot of redundancy there for upx to get that much of a compression)
09:47:49 <Heffalump> jdrake: oh, wait, why do you want to redefine times in the where clause?
09:48:04 <jdrake> Heffalump: I want it to look nicer mainly.
09:48:11 <Heffalump> no, I mean semantically
09:48:16 <ihope> jdrake: you mean like do let times3 = blah where times <- foo
09:48:20 <ihope> Er, ?
09:48:33 <Heffalump> oh, I see
09:48:36 <Heffalump> no, you can't
09:49:05 <jdrake> Something like that. Is there an alternative to <- that would allow me to do this?
09:49:38 <ihope> Hmm...
09:49:44 <Heffalump> not really, no
09:49:54 <allbery_b> jdrake: <- is fake (it's a friendly syntax for something which isn't an assignment)
09:49:57 <ihope> New feature time, then? :-)
09:50:00 <Heffalump> you could recast blah as a function taking times as an argument
09:50:07 <EvilTerran> jdrake, the problem with that is that monads are order-dependent
09:50:20 <Heffalump> liftM (\times -> blah) foo
09:50:28 <EvilTerran> indeed, the main point of 'em in haskell is to impose some kind of ordering on things
09:50:34 <Heffalump> times3 <- liftM (\times -> blah) foo
09:50:35 <Heffalump> in fact
09:50:37 <allbery_b> @undo do { times <- foo; let times3 = bar foo; return times3 }
09:50:37 <lambdabot>  Parse error at "}" (column 56)
09:50:46 <Heffalump> blah123: nickname highlighting problems? :-)
09:50:51 <ihope> @undo do times <- foo; let times3 = bar foo; return times3
09:50:51 <lambdabot>  Parse error at end of input
09:50:56 <EvilTerran> but that'd possibly make the ordering ambiguous
09:50:59 <blah123> yeah :)
09:51:04 <jdrake> So what exactly does return do?
09:51:04 <allbery_b> I don't think @undo handles the let, actually
09:51:12 <EvilTerran> @src IO return
09:51:12 <lambdabot> return x    = returnIO x
09:51:22 <EvilTerran> @src [] return
09:51:23 <lambdabot> return x    = [x]
09:51:24 <allbery_b> return turns an x into an m x
09:51:26 <EvilTerran> @src (->) return
09:51:26 <lambdabot> return = const
09:51:28 <allbery_b> where m is the monad
09:51:29 <byorgey> @type return
09:51:31 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
09:51:47 <ihope> What return does depends on the monad, really. EvilTerran just gave a bunch of examples.
09:51:50 <ihope> @src Maybe return
09:51:51 <lambdabot> return              = Just
09:51:51 <EvilTerran> the exact process varies, depending on the monad, as you can see :)
09:52:04 <allbery_b> and x <- y translates into y >>= \x ->
09:52:21 <allbery_b> (an incomplete expression requiring something else to follow)
09:52:43 <EvilTerran> > do x <- return 1 -- that being why this is invalid
09:52:43 <lambdabot>  Parse error at end of input
09:53:38 <ihope> > do x <- return 1; return x :: [Int]
09:53:45 <lambdabot>  [1]
09:53:47 <allbery_b> that incompleteness is why you can't move the y <- x somewhere else
09:54:17 <ihope> > do a <- return 1; b <- return a; c <- return b; d <- return c; e <- return d; return e :: [Int] -- :-P
09:54:17 <lambdabot>  [1]
09:55:05 <EvilTerran> the good ship monad is listing dangerously!
09:55:15 <EvilTerran> :D
09:55:43 <unk_red_> hmm. i suppose lambdabot on the command line would satisfy some of my quick lookup needs. that would be easy enough to call from vim
09:56:00 <allbery_b> there used to be GoA but it's broken :(
09:56:02 <EvilTerran> you can use our lambdabot via pm
09:56:40 <allbery_b> (GoA: "ghci on acid", hooks lambdabot into ghci)
09:57:25 <unk_red_> how much of lambdabot's functionality depends on having internet connectivity?
09:57:36 <ihope> I'm guessing just about none of it.
09:57:38 <byorgey> unk_red_: not much
09:57:51 <byorgey> only the url-related stuff, I think
09:58:14 <unk_red_> awesome
09:58:54 <EvilTerran> should be possible to factor out things like @pl and @djinn into modules, which could then be used by both ghci and lambdabot
10:05:39 <augustss> howdy
10:05:51 <conal> augustss: hi!
10:07:04 <conal> was anyone here involved in the discussions that led to hierarchical modules in haskell?
10:07:40 <conal> i'd like to get some more insight about motivation and alternatives, as i'm having pretty serious doubts about them.
10:08:28 <skew> I wasn't, but I think they are documented in the archives
10:08:29 <Igloo> What sort of alternatives? The design seems entirely natural if you're starting from Haskell 98
10:08:48 <skew> the discussions documented in the mailing list archives, that is
10:09:26 <conal> skew: probably so.  i don't know if i could find them there.
10:09:40 <conal> i wonder what a good starting point would be in searching
10:09:57 <Heffalump> I don't think there was much controversy
10:10:02 <Heffalump> What are your doubts?
10:11:01 <conal> Heffalump: a lot of little symptoms.  e.g., Monad, Applicative, & Arrow are in Control, but they apply equally well to Data.
10:11:11 <conal> do i put my new functional image library in Graphics or Data?
10:11:23 <Igloo> Oh, you mean where things go, not the extension itself
10:11:25 <conal> who's stream library gets to be Data.Stream
10:11:40 <Heffalump> I think the "whose library" problem is what led to packages
10:11:55 <Heffalump> you can write your own Data.Stream if you want
10:12:00 <conal> Igloo: I mean the question of "where things go" is a consequence of the extension, and the question doesn't have good answers.
10:12:12 <SamB> Heffalump: but you can only use one at a time
10:12:13 <Heffalump> conal: that problem was there before, though.
10:12:21 <byorgey> yes, it seems odd that e.g. Monoid is in Data, but Monad is in Control.
10:12:29 <Heffalump> The problem is really "what to name things", not "where things go"
10:12:33 <conal> byorgey: yes.  another example.
10:12:44 <byorgey> I've wondered about that before.
10:12:46 <conal> Heffalump: so what's the value of the question "where things go"?
10:12:56 <Heffalump> I don't follow.
10:12:57 <EvilTerran> on hackage, of course! ;)
10:13:24 <SamB> I think Heffalump is looking at Control.Monad and seeing a name, or something
10:13:48 <Heffalump> the hierarchical modules proposal really just defined an equivalence between . and directory structures, didn't it?
10:13:50 <Igloo> The answers are mostly decided by concensus, anyway. For example, I think there's a pretty good concensus of what a stream is, and that's what should be Data.Stream
10:14:04 <SamB> Heffalump: that is exactly what it does NOT do
10:14:19 <SamB> what it did do is allow . in module names...
10:14:19 <Heffalump> SamB: well, a recommendation that it could be implemented that way
10:14:27 <SamB> it did suggest that, yes
10:14:29 <conal> i'm guessing that hierarchical name spaces are there to resolve ambiguity.  is that so?  are there other purposes?
10:14:51 <skew> conal: I think it's mostly there to exapand the namespace
10:15:00 <Heffalump> conal: I think they are there to assist with providing structure
10:15:12 <augustss> It's nice with a hierarchy to find things.  But some things belong in many places
10:15:13 <conal> Heffalump: and why provide structure?
10:15:14 <Heffalump> I guess you could argue that this created the question of what structure to use.
10:15:20 <conal> augustss: exactly!
10:15:22 <SamB> Heffalump: that seems to lend credence to the question "where do they go?"
10:15:26 <conal> that's the problem with all hierarchies.
10:15:44 <conal> taxonomies almost never work
10:15:45 <augustss> But as for naming, would just have been using _ instead of .
10:15:57 <augustss> There's nothing magic about .
10:16:08 <Heffalump> conal: really? I'd say that they never cover all possible requirements. They still have some benefit, however.
10:16:27 <augustss> I prefer some taxonomy over none
10:16:29 <conal> Heffalump: great!  i'd like to clarify the benefit and see if we can get it without the problems.
10:16:41 <SamB> conal: never!
10:16:43 <conal> augustss: how about tagging instead of taxonomy?
10:16:50 <conal> SamB: ! :)
10:16:50 <skew> conal: I think any kind of packaging system needs to have human-usable names for things
10:16:56 <SamB> you can't get rid of the problems
10:16:59 <Heffalump> conal: that would lead to ambiguity, though
10:17:07 <conal> Heffalump: what would?
10:17:10 <Heffalump> people wouldn't know if Control.Monad and Data.Monad were the same thing or not
10:17:14 <Heffalump> tagging
10:17:24 <skew> conal: you are surely not proposing to flatten the namespace and just import by e.g. GUID?
10:17:25 <SamB> you can maybe choose between problems
10:17:55 <conal> Heffalump: agreed.  so dismbiguation is one of the key motivations for hierarchy, but hierarchy isn't necessary.
10:18:05 <Heffalump> it's not necessary, but it's useful
10:18:16 <Heffalump> just like Haskell isn't necessary :-)
10:18:21 <conal> is it more useful than simply using the package name?
10:18:22 <SamB> conal: so how would you do it?
10:18:32 <conal> SamB: package name + tags.
10:18:43 <LPhas> hey, someone here played with the last version of happs?
10:18:44 <SamB> that sounds so "eww"
10:18:56 <Heffalump> conal: I think so, yes. It provides some measure of logical grouping, however imperfect.
10:18:59 <conal> package name for disambiguation, and tags for description, searching, etc.
10:19:14 <conal> Heffalump: and what's "logical grouping" for?
10:19:18 <Heffalump> you need more than just the package name, as you need to divide things up inside packages
10:19:19 <SamB> what would appear in the imports?
10:19:25 <conal> Heffalump: agreed.
10:19:39 <skew> conal: it seems you mostly just object to the assumption that hierarchial package names give a tree rather than a DAG?
10:19:41 <conal> package name + module names
10:19:43 <Heffalump> some level of indication of what things do
10:19:44 <conal> + tags
10:19:56 <skew> after all, whose package gets to be called "streams-1.0"?
10:20:04 <SamB> tagging as an addition is not a bad idea
10:20:13 <conal> skew.  main objection is single category instead of multiple descriptors.
10:20:13 <SamB> tagging as the way to specify what module to import???
10:20:27 <SamB> ... well, you can think about that for yourself I guess ;-)
10:20:32 <conal> skew: right.  that's a problem that we have now.  hierarchy isn't helping any.
10:20:41 <Heffalump> I think it's helping!
10:20:56 <skew> conal: dropping hierarchial names to go for package names doesn't change that problem
10:21:04 <conal> SamB: i didn't mean tagging for importing.  only because i don't see how it could be workable.
10:21:14 <SamB> we could use the first maintainers initials!
10:21:22 <conal> skew: agreed.
10:21:43 <SamB> conal: that could be done, but it would get ridiculous
10:21:55 <conal> skew: i'm not trying to fix that problem.  just saying that hierarchy doesn't fix it, so it's not a reason to keep hierarchy.
10:21:59 <EvilTerran> as someone said earlier; GUIDs!
10:22:03 <conal> SamB: what would?
10:22:11 <SamB> tagging in imports
10:22:22 <SamB> GUIDs are more appealing to me, honestly
10:22:29 <conal> SamB: maybe so.  i wasn't at all considing doing that
10:22:41 <Heffalump> SamB: really? Have you ever tried reading COM IDL files?
10:22:43 <skew> I think there's something like Zooko's triangle here
10:22:47 <byorgey> import 297FA330; import qualified 9984E2C as QQ; ...
10:22:48 <SamB> though I'd want human-readable names too...
10:22:57 <Heffalump> I find GUIDs a real pain.
10:23:01 <EvilTerran> the problem with tagging for that would be that tag-based queries could produce zero or >1 results
10:23:06 <Heffalump> Though there is a need for them, I agree. But they're not nice to use.
10:23:12 <EvilTerran> while the existing system can never return >1
10:23:15 <SamB> Heffalump: well, it seems more workable then import-by-tags
10:23:29 <skew> GUID not memorable!
10:23:56 <SamB> I was thinking the programmer would not be typing GUIDs directly
10:24:10 <skew> so what do they type? Control.Monad perhaps?
10:24:18 <SamB> perhaps
10:24:25 <conal> my understanding is that hierarchical modules are for two things: disambiguating and describing ("logical grouping").  afaict, they don't address the first purpose any better than package-name mechanism, and they're more rigid than tagging for the second purpose.
10:24:57 <SamB> probably GUIDs are not the best way, though... perhaps the XML namespace approach?
10:25:00 <Heffalump> the use of punctuation characters helps them do a better job of disambiguating
10:25:10 <Heffalump> SamB: I don't think import-by-tags is worthwhile or workable either :-)
10:25:31 <SamB> Heffalump: anyway, my point was that GUIDs are less unworkable than import-by-tags
10:25:36 <skew> conal: an important function is specifying what you want to import
10:25:47 <conal> skew: yes -- disambiguating
10:25:48 <skew> conal: which monad transformers you are using from mtl, that sort of thing
10:25:51 <conal> that's the first purpose.
10:25:52 <Heffalump> and the fact that the same mechanism can be used for disambiguation as for describing means that the system is more lightweight than it would otherwise be
10:26:08 <conal> skew: mtl.StateT
10:26:16 <conal> <package>.<module>
10:26:17 <skew> conal: so hierarchial names within packages
10:26:29 <Heffalump> conal: and what about lazy StateT?
10:26:32 <conal> skew: strictly two-level.
10:26:45 <skew> conal: WX will be unhappy
10:26:45 <conal> Heffalump: ah!  good example.
10:27:16 * SamB would want to be able to import packages "qualified as", then...
10:27:33 <conal> these are the kinds of examples i'm fishing for.  thanks.
10:27:58 <Heffalump> conal: big application codebase have lots of hierarchy, too.
10:28:04 <Heffalump> s/codebase/codebases/
10:28:42 <skew> conal: the primary function is to be able to put different code in different places, recursively
10:28:54 <conal> Heffalump: certainly there's lots of use of the hierarchy mechanism out there.  what i'm wondering is are there alternatives that works as well without the rigidity.
10:29:08 <conal> skew: sounds like a strategy rather than a purpose
10:29:29 <conal> skew: in other words, i'd guess that "function" serves another function.
10:29:46 <conal> ick -- sorry for the scare quotes.
10:29:50 <Heffalump> conal: personally, I doubt it, because the rigidity provides uniqueness. But if you have a concrete proposal rather than a list of claimed problems with the current system I'd be interested :-)
10:30:03 <skew> it's like compositionality
10:30:13 * Heffalump disappears to make a bed
10:30:15 <conal> skew: great.  got it.
10:30:42 <skew> now doing that without structure?
10:30:59 <Heffalump> oh, also, you typically want hierarchy with tags, too. It's just that they can be non-unique.
10:31:47 <SamB> one of the bestist things about heirarchical module names is that it makes it easier for new programmers to get up to speed on a big project, because the subdirectory names will be encoded in the module names...
10:32:02 <conal> SamB: i like that benefit also
10:32:06 <SamB> compare with ghc
10:32:43 <SamB> so, anyway, I don't think we're about to give them up
10:33:28 <sethk> If that were a word, it would be spelled bestest, but it's not a word.
10:33:49 <skew> conal: would it help your objections if modules names formed a DAG?
10:33:56 <conal> SamB: i wouldn't expect that.  not until there's a compellling alternative.  looking for that alternative is why i want to start having this kind of conversation.  it'll take a better understanding than i had about what's compelling about the the current system.
10:34:15 <sethk> SamB, Looking at some library code, Text.Posix is in a directory /Text/Posix
10:34:23 <sethk> SamB, not terrible difficult to handle
10:34:28 <skew> conal: what was compelling about the current system was that it was like a 2-line change from no hierarchial modules :)
10:34:31 <SamB> personally, I think it would be more productive to explore alternative naming strategies and ways to augment heirarchical names
10:34:33 <sethk> Text.Regex.Posix, sorry
10:34:43 <conal> skew: hmm.  probably not.  that would exacerbate the current ambiguity problems.
10:34:54 <skew> hmm?
10:35:19 <skew> wasn't one of your problems that modules might logically go in several places?
10:35:30 <conal> yes
10:35:51 <skew> I suppose it differs from tagging in keeping the order of components
10:36:01 <conal> skew: order?
10:36:09 <conal> oh.
10:36:15 <SamB> conal: tags are definately not a bad idea in terms of allowing people to find modules that are relevant to their needs
10:36:26 <conal> foo.bar /= foo && bar
10:36:53 <conal> SamB: let's play with that idea.  if we have tags, then where would we put Monad?
10:37:08 <conal> or my new imaging library
10:37:17 <skew> conal: this seems like the sort of thing that goes in hackage. Have you followed the grafting proposals>
10:37:32 <conal> skew: not at all.  hadn't even heard the word
10:37:46 <conal> skew: and yes -- very related to hackage.  overlapping problems.
10:38:05 * SamB looks at the debtags cloud
10:38:17 <skew> well, basically the current system just says Control.Monad = mtl, and then further components reference modules inside mtl (or something like that)
10:38:36 <skew> that proposal is to let that be part of your build description
10:39:23 <skew> in your command line or cabal file or something, you say "compile this program with mixmaster-12 accessible as Foozles.Sound.Mixmaster"
10:39:35 <conal> does anyone have ideas for where to put Monad, Applicative, Arrow, and Monoid?
10:40:00 <halassocracy> yes
10:40:13 <conal> and list.  is it data or control?
10:40:38 <skew> Data.List is about data
10:40:50 <waern> why separate data and control?
10:40:57 <conal> exactly.
10:41:06 <conal> functional programming only has data, not control
10:41:07 <SamB> how about a scale of 1 to 10
10:41:11 <SamB> with voting
10:41:15 <conal> we use data where imperative program uses control
10:41:32 <conal> SamB: :(  tyranny of the majority
10:41:50 <conal> SamB:  i'm hoping for a win-win
10:41:51 <SamB> or we could base it on actual use...
10:42:19 <skew> conal: so how about using some kind of tagging on hackage to find the packages you want to use, and something like grafting to decide what you want to call them, if you don't like the author's suggestion?
10:42:27 <SamB> anyway, yeah, it's definately not either/or
10:42:41 <conal> i suspect that type classes are inherently at odds with taxonomy.
10:42:52 <conal> because of their very generality.
10:42:56 <SamB> hmm, you know, even in Python we use data structures for control sometimes...
10:43:03 <SamB> on account of not having case ;-)
10:43:04 <conal> that's why type classes are awesome.
10:43:22 <Heffalump> conal: if you want a tagging system, you could suggest a pragma that people would put in their source
10:43:28 <conal> SamB: maybe an FP inflence
10:43:49 <conal> Heffalump: sure.  for module tagging.  and the hackage for package tagging.
10:44:09 <Heffalump> cabal, not hackage
10:44:22 <conal> Heffalump: oh, sure.  thanks.
10:44:57 <conal> my current favorite answer for where to put Monad, Applicative, Arrow, and Monoid (assuming hierarchical taxonomy) is a new top-level "Class".
10:44:58 <SamB> conal: if you've got no case, you don't need FP influence to come up with the idea of using a data structure full of closures for control...
10:45:01 * Heffalump thinks an auxiliary tagging system would be nice, though I think (a) tags should be hierarchical too and (b) it shouldn't interfere with naming
10:45:08 <conal> SamB: okay :)
10:45:28 <Heffalump> conal: I hate that; it resolves the argument about whether it's control or data by making it neither.
10:45:32 <SamB> no comment on whether closures are fp-inluenced or not
10:45:45 <ricky_clarkson> SamB: I implemented that in Java recently.
10:45:51 <conal> Heffalump: exactly.  because it *is* neither.
10:45:54 <ricky_clarkson> A type-based switch, roughly.
10:46:03 <Heffalump> no, they are both
10:46:22 <conal> Heffalump: no, they are *applicable* to both
10:46:31 <conal> and to Graphics, etc.
10:46:39 <skew> maybe Categorical
10:46:48 <conal> most importantly, they're applicable to things we can't yet think of.
10:46:52 <SamB> conal: so... show me a monad that isn't a control structure?
10:47:02 <skew> sometimes we program in the internal language, sometimes we manipulate them as values
10:47:09 <Heffalump> conal: so? Those things can go into that namespace too.
10:47:15 <conal> SamB: are you ready to put List into Control?
10:47:49 <Heffalump> for List, Data is a better place than Control. But that doesn't mean Control is intrinsically wrong.
10:47:54 <SamB> are you kidding? lists are what we use in Haskell instead of loops ;-)
10:48:10 <conal> Heffalump: so Data.Monad & Control.Monad & Graphics.Monad & ... ?
10:48:24 <Heffalump> no, just pick one. Control.Monad.
10:48:32 <Heffalump> I don't see the logic of Graphics.Monad at all
10:48:34 <conal> SamB: i agree: lists are used as both control and data
10:48:43 <conal> so they don't strictly belong to either
10:48:52 <conal> Heffalump: no?
10:48:55 <laz0r> does something like the reverse of sequence exist?
10:49:05 <skew> seuqence . reverse?
10:49:05 <ricky_clarkson> :t sequence
10:49:07 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
10:49:14 <laz0r> oh
10:49:20 <SamB> laz0r: you can't unsequence things, no
10:49:21 <Heffalump> Monads aren't necessarily graphical. There's some element of control and data about all monads.
10:49:22 <grahamhutton> SamB: how about substitution forming a monad - is this a control structure?
10:49:25 <ricky_clarkson> > sequence [1,2,3]
10:49:25 <lambdabot>   add an instance declaration for (Show (m [a]))
10:49:29 <conal> Heffalump: because you don't know of a graphics-related monad?
10:49:37 <SamB> grahamhutton: maybe?
10:49:41 <conal> Heffalump: ah. i see
10:49:47 <Heffalump> no, because I don't think *all* monads are graphical.
10:49:59 <SamB> Heffalump: what about IO?
10:50:01 <conal> Heffalump: isn't there an element of control and data to *all* haskell types?
10:50:03 <Heffalump> I wouldn't particularly mind it being Data.Monad.
10:50:03 <SamB> I don't see any data there...
10:50:06 <grahamhutton> i don't think substitution has anything to do with control
10:50:10 <conal> Heffalump: gotcha
10:50:30 <Heffalump> conal: yes, but there Data and Control typically hold generic things that are to do with control and data.
10:50:37 <ricky_clarkson> Where's the element of control in Int?
10:50:40 <Heffalump> whereas specific types tend to be grouped more by their function
10:50:42 <conal> Heffalump: by "gotcha", i mean i understand why not graphics
10:50:55 <conal> ricky_clarkson: loop counter?
10:51:08 <conal> ricky_clarkson: yes, i know it's a stretch
10:51:14 <ricky_clarkson> conal: I don't know how to write a loop in Haskell.
10:51:32 <grahamhutton> Int isn't a counter example, because it falls under the identity monad (no control)
10:51:34 <conal> i might have said scads of types rather than all types.
10:51:50 <ricky_clarkson> Ok.
10:52:08 <conal> my point is that lots & lots of types are used both as data and control in lazy languages.
10:52:09 <ricky_clarkson> grahamhutton: What's the identity monad?
10:52:28 <SamB> data Id a = Id a
10:52:39 <grahamhutton> It just maps every type to itself
10:52:42 <conal> so, if Control & Data are categories, where do we put loads of our types.
10:52:42 <Heffalump> conal: IMO, the algorithm is roughly "find all the sensible ways of classifying X. Pick the best."
10:52:53 <Heffalump> So for specific things, there is typically somewhere better than Control or Data.
10:53:04 <conal> Heffalump: there's a basic flaw to that algorithm.  we can't know all of the sensible ways in advance.
10:53:06 <Heffalump> For generic things and basic types, there isn't.
10:53:13 <conal> another is that there are a lot of close seconds.
10:53:17 <conal> so it's not compelling.
10:53:44 <SamB> instance Monad Id where return = Id; Id x >>= f = f x
10:53:51 <conal> type clases are all about generalizing widely across uses.
10:53:52 <Heffalump> in the case of close seconds, it doesn't really matter which you pick
10:53:55 <skew> conal: why is that a problem?
10:54:16 <conal> skew: it's why they're in tension with use-based taxonomy
10:54:17 <skew> conal: because people have a hard time finding things?
10:54:18 <Heffalump> and not knowing the future just means that sometimes it might become necessary to move something. I doubt that'd be common, though.
10:54:46 <grahamhutton> @users
10:54:46 <lambdabot> Maximum users seen in #haskell: 430, currently: 422 (98.1%), active: 12 (2.8%)
10:55:00 <Heffalump> grahamhutton: not bad :-)
10:55:09 <grahamhutton> indeed!
10:55:30 <skew> grahamhutton: have you ever written a do block typed in a substitution monad?
10:55:50 <conal> Heffalump: move?  what we've learned it that it's in yet another category.  not that it's in the wrong category.
10:55:59 <grahamhutton> if you mean i have ever used the do notation for the substitution monad, then yes
10:56:12 <Heffalump> conal: and if it turns out that the extra category is much stronger than the existing ones, then move it.
10:56:28 <conal> Heffalump: backward-compatibly?
10:56:50 <Heffalump> conal: stick in forwarding or something. I don't think it's likely to happen much or be a big deal.
10:56:54 <SamB> conal: leave a stub with a deprecation notice for a few years?
10:56:56 <conal> BTW, have you guys read http://www.shirky.com/writings/ontology_overrated.html ?  he gives more examples.
10:56:56 <lambdabot> Title: Shirky: Ontology is Overrated -- Categories, Links, and Tags
10:57:02 <SamB> maybe a decade?
10:57:15 <grahamhutton> for category theorists, substitution is the canonical example of a monad
10:57:53 <conal> Heffalump: yes forwarding.  see the shirky article.  he describes an evolution of forwarding into tagging and then release of the underlying rigid hierarchy.
10:57:56 <SamB> sure, ontology is overrated
10:57:56 <skew> conal: I think you are mixing up two functions package names kind of try to serve, and it might be better to separate them
10:58:13 <SamB> but for things in Text. it makes plenty of sense, IMO...
10:58:17 <conal> SamB: but why bother deprecating.  the old tags/categories are still valid.
10:58:20 <Heffalump> conal: we need a rigid hierarchy for uniqueness.
10:58:22 <grahamhutton> skew: i just figured out who you are -- hi brandon!
10:58:23 <Heffalump> Which is a very important property.
10:58:29 <skew> grahamhutton: yep! Hi
10:58:37 <SamB> conal: well, that's optional I guess
10:58:42 <conal> Heffalump: you mean disambiguation?
10:58:48 <grahamhutton> skew: are you now doing a PhD?
10:58:55 <Heffalump> yes.
10:58:57 <skew> grahamhutton: not quite, applying for the fall
10:59:08 <grahamhutton> where abouts?
10:59:14 <conal> Heffalump: dag paths are no more ambiguous than tree paths
10:59:26 <grahamhutton> hi lennart!
10:59:27 <skew> grahamhutton: just decided fairly recently, and I'm only applying to UIUC as I just moved to the town anyway
10:59:31 <Heffalump> I mean that people should only need to know one name to know what something is.
10:59:47 <Heffalump> If I learn what Control.Monad is, I shouldn't have to also learn that it's sometimes called Data.Monad.
11:00:01 <skew> conal: one function for module names is for identifying a module you already know about to the compiler, another is to help somebody find a new module
11:00:04 <Heffalump> There are also practical problems with implementation if things have two names.
11:00:05 <conal> Heffalump: you wouldn't have to.  use either one.
11:00:14 <Heffalump> conal: I mean when I read other people's code.
11:00:22 <conal> skew: yep.  different purposes :)
11:00:22 <waern> conal: there's also a google tech talk video about ontology overratedness... seen it?
11:00:31 <conal> waern: shirky?
11:00:38 <waern> conal: don't know
11:00:45 <conal> waern: http://www.shirky.com/writings/ontology_overrated.html
11:00:45 <lambdabot> Title: Shirky: Ontology is Overrated -- Categories, Links, and Tags
11:00:55 <waern> conal: I can't remember
11:00:57 <conal> i haven't seen the video.  maybe same guy?
11:01:15 * conal doesn't have the bandwidth for much video watching
11:01:18 <skew> conal: I see no reason to expect both problems to be solved well by the same system, and no particular problem with identifying a module rigidly with some name that at least references a reasonable categorization
11:01:30 <waern> conal: ah, okay then :)
11:01:38 * Heffalump is with skew
11:01:46 <Heffalump> and needs to go
11:01:55 <conal> later, Heffalump
11:02:08 <skew> conal: among other things communicating with people would probably be harder if you could only refer to modules with names like "3rd hit for control + data + monad"
11:02:28 <conal> skew: i'm with you part-way.  yes, different problems and likely different solutions.  i'd like the solutions to be orthogonal -- no overlapping functionality.
11:03:03 <conal> skew: that sure would be harder.  i hope you're not making a strawman argument for hierarchy with that comment.
11:03:13 <skew> conal: having a global shared identifier for things is nice, bonus points if it can be semi-mnenomic.
11:03:30 <conal> skew: agreed
11:03:48 <skew> conal: most of your points sound like they are going the other way around, that there are much better systems for people to find modules they don't know or don't quite remember
11:04:20 <conal> skew: yes -- that's the "description" aspect.
11:05:32 <conal> our current hierarchically module system uses one mechanism for both identifying and describing.  and so does neither well.  i'm wondering if there's an elegant & compelling way to tease apart these two purposes to do both well, composably and with no overlap.
11:05:52 <SamB> conal: no
11:05:56 <SamB> you will see overlap
11:05:58 <conal> i like shirky's examples of the library of congress.
11:05:59 <skew> conal: no overlap?
11:06:04 <conal> SamB: giving up so easily?
11:06:10 <SamB> I think probably it's better to just try to do both things well
11:06:18 <SamB> and not have gratuitous overlap
11:06:19 <skew> conal: not at all! you'd have to purposely eradicate any mnenomic value from module identifiers if you wanted no overlap!
11:06:28 <SamB> (probably natural laziness takes care of that anyway)
11:06:30 <conal> skew: interesting
11:07:48 <conal> SamB: i don't mind if my quest doesn't inspire you, and/or if you're satisfied with the current system.  i'm fishing to see who else has an itch to re-examine the fundamental questions and see what else is possible that we don't see now.
11:08:21 <conal> i've been feeling increasingly unsettled about this module hierarchy thing.
11:08:28 <conal> and i'd like to know if i'm alone
11:08:35 <chessguy> conal, within the confines of the language as it is now, or possibly in a new language?
11:08:41 <conal> or other people have this elephant-in-the-rooom feeling also
11:09:30 <conal> chessguy: i'd leave that question open initially, while seeing what ideas emerge.
11:09:48 <skew> conal: I'm more bothered by things like the lack of parameterized modules
11:10:49 <conal> skew: i'm glad!
11:11:22 <conal> skew: because i'd like to see progress there, too.
11:11:58 <skew> conal: I don't see the hierarchy names as some kind of immutable ontology, just some convenient names
11:12:25 <conal> skew: because you're comfortable with dag-shaped namespaces?
11:12:28 <conal> unlike Heffalump
11:12:31 <skew> something like grafting or in the worst-case rebuilding the library can move them around if they are in your way
11:12:53 <skew> I don't think it's currently DAG shaped - maybe you get that if you abuse hardlinks
11:13:24 <conal> skew: or module forwarding (import/export)
11:13:27 <RayNbow> @docs unfoldr
11:13:27 <lambdabot> unfoldr not available
11:13:38 <conal> skew: though symlinks are simpler
11:13:39 <skew> finding new and exciting packages is more properly a job for hackage
11:13:41 <RayNbow> @docs List.unfoldr
11:13:42 <lambdabot> List.unfoldr not available
11:13:45 <RayNbow> hmm...
11:13:54 <conal> skew: i mean file system links period
11:14:13 <skew> RayNbow: Lies! unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
11:14:30 <conal> skew: i haven't gotten the gist of grafting.  could you briefly explain or give me apointer?
11:14:36 <skew> conal: I don
11:14:57 <skew> I don't think it's implemented, but it's been proposed a few times by simons.
11:15:27 <skew> http://hackage.haskell.org/trac/ghc/wiki/PackageMounting
11:15:29 <lambdabot> Title: PackageMounting - GHC - Trac
11:16:21 <conal> skew: thanks
11:16:48 <skew> If it feels like the rigid ontologies are closing in, just imagine it already works that way :)
11:17:13 <fasta> conal: good development environments make up for lots of those issues.
11:18:52 <SamB> conal: that doesn't get you a DAG, really
11:19:29 <conal> SamB: module forwarding doesn't?
11:19:37 <SamB> no
11:19:53 <conal> because there's "one true path"?
11:20:03 <conal> shirky mentions that point
11:20:03 <SamB> because if I forwarded Foo to Bar, Foo.Baz wouldn't also be forwarded...
11:20:30 <conal> SamB: oh.  i hadn't thought of that.  yeah.  forwarding is no solution.
11:20:51 <EvilTerran> haskell's current module system's flat pretending to be heirarchical. nowhere near a DAG.
11:20:55 <SamB> I'm not saying that this is a BAD thing, just that it doesn't get you a DAG
11:21:19 <conal> SamB: i understand, and thanks.
11:23:22 <fasta> A tree is a DAG too [/anal]
11:23:38 <RayNbow> @src List.unfoldr
11:23:38 <lambdabot> Source not found. :(
11:23:42 <RayNbow> @src Data.List.unfoldr
11:23:42 <lambdabot> Source not found. The more you drive -- the dumber you get.
11:23:56 <allbery_b> @src unfoldr
11:23:56 <lambdabot> unfoldr f b  = case f b of
11:23:56 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
11:23:56 <lambdabot>    Nothing        -> []
11:24:15 <RayNbow> allbery_b, thx
11:25:49 <fasta> That message should be changed to: "I am lambdabot and this functionality was just a quick hack. Don't feel bad about my limitations."
11:25:50 <sethk> what's the function to change a string into a list of lines?  The lines are separated by newline in the input string?
11:26:09 <fasta> sethk: lines?
11:26:13 <SamB> fasta: yes, but a tree is a special kind of DAG in common usage
11:26:32 <fasta> SamB: yes, I know what was meant.
11:26:40 <fasta> > lines "hi\nthere"
11:26:42 <lambdabot>  ["hi","there"]
11:26:51 <fasta> sethk: ^^
11:27:02 <sethk> fasta, thank you.  My brain isn't working very well today.
11:27:28 <sethk> I was looking in Text, but it's in Data.LIst
11:28:33 <fasta> Yes, Haskell dev tools need a search engine for functions like Factor has.
11:28:44 <mwc> hoogle?
11:28:52 <fasta> mwc: oh, please, no.
11:29:05 <sethk> fasta, hoogle is better than grep  :)
11:29:59 <sethk> @lines
11:29:59 <lambdabot> Unknown command, try @list
11:30:23 <fasta> sethk: hoogle doesn't work on user modules.
11:30:25 <toad__> Anyone know what this means?  I was setting up ghc and it works, compiles stuff fine but I get an error when I try to browse libraries "module 'System.Random' is not interpreted"
11:30:31 <fasta> sethk: or interactively
11:30:35 <toad__> Anyone know what that means?
11:30:45 <fasta> toad__: yes
11:30:54 <mwc> fasta, sure it does. use cabal's haddock build option to produce a hoogle index
11:31:07 <toad3k> How do I fix it?
11:31:13 <ddarius> toad3k: Type :browse
11:31:28 <ddarius> In 6.8.1, :b means :breakpoint
11:31:30 <sethk> @list
11:31:30 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
11:31:42 <monochrom> haha
11:31:42 <toad3k> ahh, ok, well that's good that it was something simple
11:31:52 <toad3k> thanks guys
11:31:58 <fasta> mwc: how is that interactive?
11:32:06 <fasta> mwc: that's the same lame system as TAGS.
11:32:18 <mwc> well, except that its type aware
11:32:23 <mwc> which is the killer feature for hoogle
11:32:28 <fasta> mwc: type aware? Since when?
11:32:35 <sethk> @hoogle lines
11:32:35 <lambdabot> Prelude.lines :: String -> [String]
11:32:35 <lambdabot> Data.PackedString.linesPS :: PackedString -> [PackedString]
11:32:35 <lambdabot> Text.Html.linesToHtml :: [String] -> Html
11:33:04 <fasta> sethk: is that supposed to be proof?
11:33:24 <mwc> @hoogle (a -> Bool) -> [a] -> [a]
11:33:24 <lambdabot> Prelude.dropWhile :: (a -> Bool) -> [a] -> [a]
11:33:24 <lambdabot> Prelude.filter :: (a -> Bool) -> [a] -> [a]
11:33:24 <lambdabot> Prelude.takeWhile :: (a -> Bool) -> [a] -> [a]
11:33:27 <sethk> fasta, no, it's supposed to be "Maybe if I type it in a  few times I'll remember the command"  :)
11:33:47 <fasta> sethk: /msg lambdabot <command>
11:34:26 <sethk> fasta, what's the difference between    /msg lambdabot command    and     @command    ?
11:34:37 <fasta> sethk: you don't annoy us.
11:34:58 <sethk> fasta, you are too easily annoyed.  I suppose you mean that in the second case only I will see it.
11:35:17 <allbery_b> you need the @ even for the /msg form
11:35:25 <ski> s/second/first/
11:35:46 <sethk> allbery_b, you would say   /msg lambdabot @hoogle lines     e.g.?
11:36:46 <allbery_b> yes
11:36:56 <sethk> allbery_b, thanks
11:37:08 <fasta> sethk: there's also an Emacs extension.
11:37:11 <fasta> sethk: hoogle.el
11:37:43 <sethk> fasta, to hoogle from within emacs, analgous to ctags?
11:37:51 <sethk> analagous
11:37:54 <sethk> however it's spelled
11:37:58 <fasta> sethk: I haven't used it.
11:38:07 <shachaf> There is also haskel.org/hoogle
11:38:17 <shachaf> sethk: Probably not -- I'd guess it uses Hoogle.
11:38:17 <sethk> fasta, ok.  I'll try it.  thanks
11:38:23 <shachaf> sethk: Which has its own database.
11:38:44 <shachaf> sethk: There's also :ctags from ghci.
11:38:58 <sethk> shachaf, ok, I'll try that also.
11:39:16 <fasta> Anyway, how Factor does it is a nice solution; anything less is a hack.
11:39:38 <ski> does what ?
11:39:48 <sethk> shachaf, looks like ctags is for vi, and etags is for emacs.
11:40:01 <fasta> ski: searching for functions/packages etc.
11:40:08 <ski> ok
11:40:43 <fasta> ski: install it to see it. The language implementation obviously isn't as far as GHC is, but the UI already is better.
11:42:04 <shachaf> sethk: Yes, there's also :etags.
11:42:20 <fasta> ski: unlike some Haskell projects, it compiles out of the box.
11:43:05 <Mr_Awesome> fasta: which project are you talking about?
11:43:41 <fasta> Mr_Awesome: nhc98, hat for example.
11:43:44 <Mitar> is there any example code on combining Error and State monad?
11:43:58 <Mr_Awesome> ah, i see
11:43:59 <Mitar> I would need a Monad which would have both functionalities
11:44:14 <ddarius> Mitar: Then you use monad transformers.
11:45:05 <Mitar> StateT s (Error e)?
11:45:28 <Mitar> will this work so that I can always throw an execption, but still set/read State?
11:45:44 <ddarius> s/Error/Either or ErrorT e (StateT s)
11:45:55 <ddarius> er just State
11:46:19 <shachaf> @unmtl Error e
11:46:19 <lambdabot> Either String e
11:46:26 <ddarius> :t runStateT
11:46:28 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
11:46:37 <ddarius> There is an Error?  Okay, use that.
11:46:48 <ddarius> :t runErrorT
11:46:49 <lambdabot> forall e (m :: * -> *) a. ErrorT e m a -> m (Either e a)
11:47:13 <Mitar> i am reading he last paragraph at http://www.haskell.org/all_about_monads/html/standardxformers.html#example3
11:47:14 <lambdabot> Title: Standard monad transformers, http://tinyurl.com/2733eo
11:47:42 <Mitar> but is the order correct? StateT s (Error e) produces a combined type of s -> Error e (a,s), in which the computation can either return a new state or generate an error?
11:47:44 <ddarius> StateT s (Error e) will throw out the state upon failure while ErrorT e (State s) will not.
11:48:09 <TomMD> @messages
11:48:09 <lambdabot> You don't have any new messages.
11:48:26 <Mitar> is it correctly written?
11:48:37 <ddarius> Mitar: It depends on what you want.
11:49:25 <Mitar> I want to have a monad, where can I always throw an Exception and it just boils out to the end of the Monad "world"
11:49:45 <Mitar> but if everything is going normally I would like to use State to store some things ...
11:49:55 <ddarius> Both of them do that.  The question is how you want it to interact with state when an exception is thrown.
11:50:11 <Mitar> does not care at that moment anymore :-0
11:50:31 <ddarius> Then you probably want StateT s (Error e)(
11:50:34 <Mitar> i just want to retrieve the exception and live on ...
11:51:15 <Mitar> but i will still need to use lifting functions?
11:51:34 <ddarius> Yes and no.  Mostly no.  There are classes that automatically lift things for you.
11:51:36 <Mitar> why wouldn't I declare one monad which would combine both things ...
11:51:42 <Mitar> like State?
11:51:47 <ddarius> Mitar: Why would you?
11:52:03 <Mitar> is there any example code with this? i bet this is quite common ...
11:52:09 <fasta> Mitar: ...
11:52:11 <ddarius> If you want, you could wrap the monad transformer type in a newtype and declare that an instance of Monad.
11:52:48 <Mitar> fasta?
11:53:18 <unk_red> is it possible to set universaly default cabal flags. for --user and --prefix in particular
11:54:24 <ddarius> Mitar: The whole point of monad transformers is that you -don't- have to constantly write "combined" monads.
11:54:32 <Mitar> i know
11:54:40 <Mitar> but i would not like to constantly write lift :-)
11:54:54 <ddarius> Mitar: As I said, you already don't have to.
11:55:05 <Mitar> i remember one time when i was combining IO and state and I had to liftIO all the time
11:55:14 <ddarius> The MonadError and MonadState classes will automatically handle lifting.
11:55:29 <Beelsebob> Hmm, Project Euler is beginning to get hard now :)
11:55:38 <mwc> don't you just write lift for each monad transformer
11:55:39 <ddarius> Even without them, you only have to write lift once for each "primitive" that needs to be lifted rather than everytime you use something.
11:55:40 <Mitar> i will try it ... but is there an example?
11:55:59 <mwc> then you get your lift = lift . lift  . ... . lift
11:56:12 <ddarius> Mitar: There are examples in that tutorial that you said you were reading.
11:56:19 <mwc> but the RHS is automagic given the typeclasses?
11:58:56 <ddarius> Mitar: IO actions can't be automatically lifted because their types are not parameterized.  That said, you don't have to write lift (putStrLn "foo") everywhere (though that isn't too bad), you'd just write myPutStrLn = lift . putStrLn and use myPutStrLn
11:59:27 <ddarius> On the other hand, e.g. get has this type:
11:59:29 <ddarius> :t get
11:59:30 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
11:59:37 <dons> ?yow!
11:59:38 <lambdabot> There is no TRUTH.  There is no REALITY.  There is no CONSISTENCY.
11:59:38 <lambdabot> There are no ABSOLUTE STATEMENTS.   I'm very probably wrong.
11:59:58 <Mitar> hmm, thans, ddarius
12:00:04 <Mitar> i will check this all :-)
12:01:50 <Mitar> one more question ... i am reading the Reader monad ... if I understand correctly it is similar to State monad only that after the action finishes the previous state is restored?
12:03:12 <Cale> Mitar: well, the same initial state gets passed down to everything
12:03:15 <ddarius> Mitar: It potentially could be thought of like that, but I think that would be less than ideal.  Using Reader is like having something bound in an outer scope.
12:03:27 <ddarius> Cale: It can get "shadowed" with local.
12:03:30 <Cale> ddarius: right
12:03:34 <Mitar> yes, but i can check it for local scope
12:03:43 <Cale> ddarius: But you could write local using runReader anyway :)
12:03:44 <Mitar> s/check/change/
12:04:05 <ddarius> Mitar: And that's just like shadowing a variable rather than updating it.
12:04:11 <Mitar> yes ...
12:04:26 <Mitar> and after the action finishes, it is again unshadowed ..
12:04:34 <Mitar> so my analogy holds?
12:04:58 <ddarius> Mitar: Do you think of normal variables as being like state that gets restored?
12:05:30 <ddarius> Mitar: You can't, for example, make a "counter" that will be "restored" after execution.
12:06:21 <noobie> i have used the reads functions to  return back the correct types or [] if a incorrect type is entered, but what if i want to show which entry was incorrect e.g. reads "1 y" ::[Int],  i want it to return 'y' as been incorrect
12:06:24 <Mitar> i can make a counter of how many nestings there was ...
12:06:40 <Mitar> or recursive calls ...
12:06:43 <Mitar> for example
12:08:49 <ddarius> As I said at the get-go, it can potentially be thought of like that, but it more directly corresponds to binding with dynamic scope.
12:08:51 <Saizan> > reads "1 y" :: [(Int,String)]
12:08:52 <lambdabot>  [(1," y")]
12:08:54 * SamB wonders why google often has access to paysites (for journals etc.)
12:09:01 <gio123> somebody has access to download for me that article
12:09:01 <lambdabot> gio123: You have 1 new message. '/msg lambdabot @messages' to read it.
12:09:14 <gio123> GRAPHS AND NIELSEN TRANSFORMATIONS OF SYMMETRIC, ORTHOGONAL, AND SYMPLECTIC GROUPS
12:09:31 <int-e> SamB: it's good advertising for the publisher.
12:09:45 <pejo> SamB, how else would scholar.google.com work?
12:09:49 <SamB> so they give googlebot a free subscription?
12:09:51 <noobie> > reads "1 y" :: [(String)]
12:09:51 <lambdabot>  Couldn't match expected type `String'
12:09:59 <SamB> pejo: I meant for web search
12:10:04 <noobie> > reads "1 y" :: [[String]]
12:10:05 <lambdabot>  Couldn't match expected type `[String]'
12:10:18 <Saizan> ?type reads
12:10:18 <lambdabot> forall a. (Read a) => String -> [(a, String)]
12:10:19 <pejo> SamB, are they any different from a crawling perspective?
12:10:25 <noobie> > reads "1 y" :: [(Int,String)]
12:10:25 <lambdabot>  [(1," y")]
12:10:47 <noobie> i want to only return the incorrect input, not both
12:10:53 <SamB> well, I don't like pay-only pages/PDF files showing up in web search...
12:11:15 <Saizan> noobie: you just have to extract it from the list
12:11:50 <noobie> but what if it's a long list with more than one incorrect entry
12:12:02 <pejo> SamB, personally I find it very convenient to get the best matches, regardless of source.
12:12:20 <Saizan> noobie: i'd pick the first
12:12:25 <SamB> well, I'd at least like their to be a "subscription required" flag
12:12:40 <noobie> how???
12:12:45 <EvilTerran> try spoofing your useragent to pretend to be the google bot?
12:12:46 <SamB> or "subscription required for full access"
12:12:55 <SamB> EvilTerran: I was wondering about that, actually...
12:12:59 <noobie> how do i do that?
12:13:18 <Saizan> extract the first element from a list?
12:13:40 <noobie> yes
12:13:58 <sethk> head
12:13:58 <noobie> first incorrect element
12:14:09 <sethk> ah, now that's different  :)
12:14:24 <noobie> > head [1, "y"]
12:14:24 <lambdabot>   add an instance declaration for (Num [Char])
12:14:24 <lambdabot>     In the expression: 1
12:14:31 <EvilTerran> head . filter(not.correct) ?
12:15:11 <Saizan> head [(1," y")]
12:15:13 <Saizan> > head [(1," y")]
12:15:13 <lambdabot>  (1," y")
12:15:25 <Saizan> > snd (head [(1," y")])
12:15:25 <lambdabot>  " y"
12:16:22 <SamB> EvilTerran: well, it didn't work for this one...
12:16:28 <SamB> @google GRAPHS AND NIELSEN TRANSFORMATIONS OF SYMMETRIC, ORTHOGONAL, AND SYMPLECTIC GROUPS
12:16:29 <lambdabot> http://qjmath.oxfordjournals.org/cgi/reprint/36/3/297.pdf
12:18:35 <EvilTerran> funny, i can get to that. must be an ip address thing.
12:27:07 <Beelsebob> is there a way to get the integer part of a rational... i.e. rounded down to the nearest int
12:27:36 <gwern> > let a =
12:27:36 <lambdabot>  Parse error at end of input
12:27:37 <noobie> > map reads (words "1 2 3 4 y")::[(Int,String)]
12:27:38 <lambdabot>  Couldn't match expected type `(Int, String)'
12:27:41 <gwern> > let a = "foo"
12:27:41 <lambdabot>  Parse error at end of input
12:27:50 <gwern> > foo
12:27:50 <lambdabot>   Not in scope: `foo'
12:27:59 <dons> augustss: jdh explains why he acts the way he does, http://groups.google.co.uk/group/comp.lang.functional/msg/5369c7d65905191d
12:28:00 <lambdabot> Title: beginning with ML - comp.lang.functional | Google Groups, http://tinyurl.com/23z3ha
12:28:13 <noobie>  map reads (words "1 2 3 4 y")::[([Int],String)]
12:28:22 <ski> Beelsebob : `floor' ?
12:28:25 <gwern> > "'" ++ a ++ "'"
12:28:25 <lambdabot>   Not in scope: `a'
12:28:27 <noobie> > map reads (words "1 2 3 4 y")::[([Int],String)]
12:28:27 <lambdabot>  Couldn't match expected type `([Int], String)'
12:28:47 <gwern> > "'" ++ "foobar" ++ "'"
12:28:47 <lambdabot>  "'foobar'"
12:28:52 <ski> > floor (23/10 :: Rational)
12:28:52 <lambdabot>  2
12:29:03 <Beelsebob> oh, duh
12:29:30 <gwern> > let a = "foobar" in "''" ++ a "'"
12:29:30 <lambdabot>  Couldn't match expected type `[Char] -> [Char]'
12:29:42 <gwern> > let a = "foobar" in "'" ++ a "'"
12:29:42 <lambdabot>  Couldn't match expected type `[Char] -> [Char]'
12:30:15 <gwern> > let a = "foobar" in "'" ++ a ++ "'" -- oops
12:30:16 <lambdabot>  "'foobar'"
12:32:07 <ski> que ?
12:32:53 <gwern> 'Next, I'll publish the results on my site showing that Don can't compare
12:32:55 <gwern> numbers correctly'
12:33:22 <gwern> dons sure does get a lot of criticism because of his benchmarking stuff :)
12:36:19 <Heffalump> @seen fasta
12:36:19 <lambdabot> I saw fasta leaving #haskell 42m 27s ago, and .
12:37:01 <noobie> reads "1 y t y " :: [(Int,String)]
12:37:10 <noobie> > reads "1 y t y " :: [(Int,String)]
12:37:10 <lambdabot>  [(1," y t y ")]
12:37:31 <noobie> > reads "1 1 1 1 y " :: [(Int,String)]
12:37:32 <lambdabot>  [(1," 1 1 1 y ")]
12:37:34 <gwern> > let a = "foobar" in '"' ++ a ++ '"'
12:37:35 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Char'
12:38:00 <dons> gwern: except he didn't post any results about that
12:38:09 <gwern> hm.
12:38:18 <dons> gwern: he linked to a guy who used a different algorithm, and then corrected himself
12:38:25 <noobie> > snd (head (reads "1  y " :: [(Int,String)]))
12:38:26 <lambdabot>  "  y "
12:38:54 <gwern> dons: maybe he intended to post his benchmarks but just forgot about it?
12:38:54 <noobie> > snd$ head (reads "1  y " :: [(Int,String)])
12:38:54 <lambdabot>  "  y "
12:38:56 <dons> gwern: but he doesn't care -- the goal is publicity, not some benchmarking purpose
12:39:12 <noobie> > snd$ head$ reads "1  y " :: [(Int,String)]
12:39:12 <lambdabot>  Couldn't match expected type `(Int, String)'
12:39:20 <gwern> > let a = "foobar" in \" ++ a ++ \"
12:39:20 <lambdabot>  Improperly terminated string at """ (column 22)
12:39:25 <noobie> > snd$ head(reads "1  y " :: [(Int,String)])
12:39:26 <lambdabot>  "  y "
12:39:50 <gwern> > let a = "foobar" in "\"" ++ a ++ \"
12:39:50 <lambdabot>  Improperly terminated string at """ (column 35)
12:39:54 <gwern> doh
12:40:06 <gwern> > let a = "foobar" in "\"" ++ a ++ "\"" -- maybe that will work
12:40:07 <lambdabot>  "\"foobar\""
12:40:44 <gwern> finally - at least, I think that works, as I need a "spawn "foobar"" ultimately
12:41:44 <jimstutt> @users
12:41:45 <lambdabot> Maximum users seen in #haskell: 432, currently: 426 (98.6%), active: 14 (3.3%)
12:41:57 <gwern> writing shells is harder than it looks! and the ghc api is kind of hard to work with
12:42:18 <ddarius> 432
12:42:33 <jimstutt> forall a b.
12:42:40 <jimstutt> :t forall a b.
12:42:41 <lambdabot> parse error (possibly incorrect indentation)
12:42:48 <jimstutt> t: forall a b.
12:43:17 <jimstutt> oops
12:43:24 <dmwit> jimstutt: What are you trying for?
12:43:25 <shapr> So, what's good to learn today?
12:43:34 <dons> wow
12:43:41 <dons> ddarius: that's the jdh principle at work
12:44:07 <jimstutt> dmwit: where's the lambdabot syntax?
12:44:07 <shapr> ddarius: What's the jdh principle? I know who he is...
12:44:21 <dmwit> jimstutt: For what?  What are you trying to do?
12:44:31 <dons> shapr: http://groups.google.co.uk/group/comp.lang.functional/msg/5369c7d65905191d
12:44:32 <lambdabot> Title: beginning with ML - comp.lang.functional | Google Groups, http://tinyurl.com/23z3ha
12:44:37 <dons> "Unfavorable publicity increases sales. Favorable publicity increases
12:44:38 <dons> sales a lot."
12:44:56 <jimstutt> dmwit: learn  haskell using lambdabot and YAHT
12:45:07 <shapr> haha!
12:45:08 <dmwit> > "this evaluates an expression"
12:45:11 <shapr> @quote harrop
12:45:13 <lambdabot> No quotes match. Your mind just hasn't been the same since the electro-shock, has it?
12:45:14 <lambdabot>  "this evaluates an expression"
12:45:15 <gwern> makes sense. when you're small, there's no such thing as bad publicity...
12:45:16 <dmwit> :t "this finds the type of an expression"
12:45:16 <lambdabot> [Char]
12:45:17 <dons> not also the comments on why he divides the FP communities -- in his scheme, the damage is insignificant compared to sales going up
12:45:38 <jimstutt> :t forall a b. a
12:45:39 <lambdabot> Not in scope: `forall'
12:45:39 <lambdabot> Not in scope: `a'
12:45:39 <lambdabot> Not in scope: `b'
12:45:49 <dmwit> jimstutt: That's *already* a type.
12:45:54 <dmwit> Maybe you want kind?
12:46:01 <shapr> I think that unfavorable publicity produces short term gains and long term losses.
12:46:04 <dmwit> :k forall a b. a
12:46:05 <lambdabot> *
12:46:09 <shapr> But favorable publicity produces long term gains.
12:46:17 <jimstutt> aha might get going now
12:46:45 <SamB> shapr: hmm?
12:47:06 <SamB> unfavorable publicity of what sort?
12:47:38 <shapr> I think jdh is missing one big thing too... If someone critiques a language and that critique is quickly remedied, then it's favorable publicity.
12:47:39 <gwern> (wish I knew what the heck the datatype 'RunBreak' means in the ghc api... it's totally inscrutable)
12:48:15 <dons> shapr: he doesn't care though, as long as links to his page are connected to the publicity some how
12:48:35 <gwern> shapr: if anyone follows up. you remember that fellow who was doing poker and eventually moved to erlang? I still see him mentioned even though I think sjanssen has repeatedly said all his criticisms were fixed or his own fault
12:48:37 <shapr> He does have a point that mindshare is mindshare.
12:49:07 <jimstutt> :t forall a. (T a) => a - > b
12:49:07 <lambdabot> parse error on input `=>'
12:49:12 <SamB> gwern: he comes around from time to time
12:49:20 <SamB> name of joelr
12:49:22 <dons> marketing disguised as online community contributions
12:49:27 <dmwit> jimstutt: That's a type.
12:49:28 <Heffalump> dons can't compare numbers properly? :-)
12:49:36 <shapr> gwern: Yes, but if someone uses joelr's negative comments against Haskell, other people can show that they're not correct.
12:49:39 <dmwit> jimstutt: Why would you ask the runtime system for the type of a type?
12:49:49 <dons> apparently. though he didn't actually get to that in his advertisement. just an attack on augustss
12:49:52 <dmwit> jimstutt: What do you *really* want to know?
12:49:56 <jimstutt> dmwit: looking for legit types for a type error so good
12:50:08 <Heffalump> which advertisement? That post?
12:50:11 <shapr> dons: I think he's being facetious.
12:50:16 <dmwit> jimstutt: You need to give lambdabot an expression to get type information.
12:50:17 <ddarius> shapr: And what if they look at joelr's blog and simply decide not to use Haskell and instead use Erlang or neither.
12:50:27 <dons> Heffalump: linked from here, http://programming.reddit.com/info/61vni/comments/
12:50:35 <dons> oh, hang on , wrong one.
12:50:37 <dmwit> jimstutt: A type declaration is not really an expression...
12:50:44 <dons> this one , http://programming.reddit.com/info/61viy/comments/
12:50:47 <Heffalump> his argument that the Haskell-Ocaml competition is just the product of two small percentages is completely bogus
12:50:50 <shapr> ddarius: I would hope that people investigating Haskell would check more than one source of information.
12:50:50 <dmwit> jimstutt: So, if you're having trouble defining a function because the types don't match...
12:50:59 <dmwit> jimstutt: Use ":t <body of the function here>"
12:51:16 <dmwit> jimstutt: That will ask lambdabot to imagine the type of that expression for you.
12:51:21 <SamB> ddarius: well, he was trying to use Haskell as Erlang. Erlang makes a better Erlang, obviously...
12:51:25 <jimstutt> thnx guys can't look up my notes this fast
12:51:30 <dons> he needed to get linked to the haskell publicity somehow, so he cross references the recent posts, attacks haskell a bit (via augustss) and then is happy at the website hits
12:51:56 <puusorsa> url or it didn't happen
12:52:12 <jimstutt> dmwit: was just looking for body of function so good
12:52:49 <dmwit> jimstutt: Oh, if you want to go the other way (i.e. find some code that results in a given type), you can *sometimes* use djinn.
12:53:05 <dmwit> I say sometimes because it doesn't know about lists or typeclasses.  But...
12:53:11 <dmwit> ?djinn a -> b -> a
12:53:12 <lambdabot> f a _ = a
12:53:13 <jimstutt> dmwit: dogpiling djinn
12:53:16 <dmwit> for example
12:55:13 <dons> shapr: so unfortunately, this is his business model. he's going to continue to incite, to drive publicity
12:56:18 * shapr shrugs
12:56:23 <bartw> dons: did you make that fib microbenchmark recently ?
12:56:38 <bakert> ?hoogle [Char] -> [[Char]] -> [Char]
12:56:38 <shapr> So what do you do? Not incite but continue to refute?
12:56:39 <lambdabot> No matches, try a more general search
12:56:46 <ddarius> bartw: He did, but it was "inspired" by another blog post.
12:56:49 <maihem> I'm trying to improve my haskell, but I wonder if there are any small realworld programs that are well written (eg, not huge complex nested stuff where everything is called a, b and c)? Especially programs that do I/O.
12:56:50 <shapr> Or maybe just go off and write real useful code and distribute that?
12:56:57 <bakert> Is there a "join" in prelude?  Like: join s xs = foldr (\a b -> a ++ s ++ b) "" xs
12:57:05 <dons> bartw: this week i was playing with it, yep.
12:57:06 <bakert> (only without the trailing s)
12:57:10 <shapr> maihem: dons' shell tools replacements are cool.
12:57:11 <ddarius> maihem: xmonad
12:57:32 <maihem> ddarius: thanks
12:57:35 <dons> maihem: hmm. yeah, maybe the unix tools stuff
12:57:36 <dmwit> bakert: concat?
12:57:40 <dmwit> :t concat
12:57:41 <lambdabot> forall a. [[a]] -> [a]
12:57:44 <bartw> dons: it was a bit of a cheapshot
12:57:48 <bakert> ?src concat
12:57:48 <lambdabot> concat = foldr (++) []
12:57:50 <nexi> hello there
12:57:58 <dmwit> :t join :: [[a]] -> [a] -- also, with exactly the same name as the one you proposed. =)
12:57:58 <lambdabot> forall a. [[a]] -> [a]
12:58:00 <shapr> Hi nexi, learning Haskell?
12:58:04 <ddarius> bartw: There was a bit of a joke woven into the first one.
12:58:20 <gwern> @where isInfixOf
12:58:21 <lambdabot> I know nothing about isinfixof.
12:58:21 <jimstutt> aargh: darcs get http://www.augustsson.net/Darcs/Djinn/ is 404
12:58:22 <lambdabot> Title: Index of /Darcs/Djinn
12:58:23 <dons> bartw: yeah, the first was a joke. the second was to look at `par`.
12:58:24 <nexi> shapr: no just need it for xmonad but got many problems with haskell
12:58:26 <bakert> dmwit: oh. how odd.  i only found a monad-y thing.  must have done something stoopid.  thanks!
12:58:37 <dmwit> bakert: Lists are a monad. =)
12:58:39 <jimstutt> @where djinn
12:58:39 <lambdabot> darcs get http://darcs.augustsson.net/Darcs/Djinn
12:58:41 <conal> maihem: you want to improve your haskell *and* do I/O?  part of doing haskell well is seeing how *not* to use IO.
12:58:46 <dmwit> jimstutt: You can use it here on this channel.
12:58:53 <dmwit> ?djinn a -> b -> a
12:58:53 <lambdabot> f a _ = a
12:58:56 <gwern> that's odd. I coukd;ve sworn there was an isInfixOf function
12:58:57 <bakert> dmwit: ah yes.  a fact of which i am aware but which has not much meaning to me!
12:59:01 <jimstutt> dmwit: aha, ta
12:59:04 <ddarius> @src isInfixOf
12:59:04 <lambdabot> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
12:59:05 <bakert> dmwit: i shall have to look intot hat
12:59:35 <ddarius> @help where
12:59:35 <lambdabot> where <key>. Return element associated with key
12:59:50 <bartw> i was a bit supprised nobody started complaining that the 'native' once weren't reusing intermediate results
12:59:55 <ddarius> @index isIndexOf
12:59:55 <lambdabot> bzzt
13:00:10 <jimstutt> :t x :: [forall a . a]
13:00:10 <lambdabot> Not in scope: `x'
13:00:31 <davidL> @index isInfixOf
13:00:31 <lambdabot> bzzt
13:00:32 <dmwit> ...
13:00:49 <dmwit> jimstutt: If you already have the type, why use :t ?
13:01:00 <shachaf> davidL: Data.List.
13:01:03 <dmwit> jimstutt: Maybe you should summarize for me what you think :t does, and see if there's any misconception. =)
13:01:11 <shapr> dons: Speaking of good publicity, "UPDATE : Don and the other guys on reddit who gave me a hard time about using an O(n) algorithm are really cool folks. Thanks for the responses guys, I’ll probably be looking more at Haskell in the near future because of your great replies." from http://jng.imagine27.com/articles/2007/11/29/dude-your-quad-cores-have-been-smoking-way-too-much-haskell is good publicity!
13:01:12 <lambdabot> Title: ungrasping it all : Dude, your quad-cores have been smoking way too much Haskell ..., http://tinyurl.com/2dnt5d
13:01:13 <davidL> shachaf: I know ;)
13:01:34 <bartw> dons: ohwell, it was a good read, but people might think you're serious
13:01:42 <shachaf> There should be @index+.
13:02:03 <davidL> What does the error "Irrefutable pattern failed" mean?
13:02:07 <ddarius> shapr: Well Haskell's community itself has been a significant draw for, at least the past six years in my own personal experience and probably far longer than that.
13:02:16 <ddarius> davidL: Exactly what it says.
13:02:24 <dmwit> davidL: It means you're pattern matching on less than the complete set of constructors.
13:02:26 <ddarius> > let Just x = Nothing in x
13:02:28 <lambdabot>   Irrefutable pattern failed for pattern Data.Maybe.Just x
13:02:39 <gwern> > let foo-bar = id
13:02:40 <lambdabot>  Parse error at end of input
13:02:46 <shapr> ddarius: So how to grow the community more?
13:02:48 <ddarius> dmead: That would be non-exhaustive patterns.
13:02:57 <shapr> I'm beginning to think that #haskell is saturated at ~400
13:03:08 <gwern> > let foo++ = foo + 1
13:03:08 <lambdabot>  Parse error at "=" (column 11)
13:03:21 <gwern> > let (foo++) = foo + 1
13:03:21 <lambdabot>  Parse error in pattern at end of input
13:03:29 <ddarius> shapr: That will change.  Nothing "big" has happened in a while.  That said it does look like it has (at least temporarily) slowed down.
13:03:38 <gwern> doh. hm.
13:03:48 <dmwit> gwern: You need an "in". =)
13:03:52 <dons> ?users
13:03:52 <lambdabot> Maximum users seen in #haskell: 432, currently: 429 (99.3%), active: 18 (4.2%)
13:03:58 <dmwit> > let (++) foo = foo + 1 in (3++)
13:04:00 <lambdabot>  4
13:04:04 <dons> well, this is a new peak. we traditionally have spikes in Dec and Jan
13:04:09 <ddarius> shapr: There is probably also some seasonal aspects going on.
13:04:23 <dons> and that coincides with ghc 6.8 and the recent publicity
13:04:28 <bartw> i irc more in the winter :)
13:04:43 <bartw> not that i actively  use haskell, but all the cool people hang out here
13:04:49 <gwern> > let (foo++) = (+ 1)
13:04:49 <lambdabot>  Parse error in pattern at end of input
13:05:00 <augustss> howdy
13:05:07 <jimstutt> dmwit: forall b. T -> (forall a. (T a) => a -> b)  is my attempt to parse a type error being unlucky enough to jump straight into ghc-6.8.1 and get some rudimentary db n web stuff built
13:05:17 <gwern> dmwit: I'm not sure that works. what I'm actually trying to do is something like 'let c++ = spawn "c++"'
13:05:18 <dmwit> > let (foo++) = foo + 1 in (3++)
13:05:18 <lambdabot>  Parse error in pattern at "in" (column 23)
13:05:25 <shapr> hej augustss
13:05:29 <shapr> God morgon!
13:05:48 <jimstutt> ?djinn: forall b. T -> (forall a. (T a) => a -> b)
13:05:48 <dmwit> > let (++) c = show "c++" in (c++)
13:05:49 <lambdabot>   Not in scope: `c'
13:05:49 <lambdabot> Cannot parse command
13:05:58 <dmwit> > let (++) c = show "c++"; c = c in (c++)
13:05:58 <lambdabot>  "\"c++\""
13:06:02 <davidL> irrefutable: "that which cannot be refuted" ...great
13:06:04 <dmwit> gwern: ;-)
13:06:25 <augustss> jimstutt: djinn doesn't do forall much
13:06:43 <dmwit> jimstutt: Maybe you should paste the code that's producing that error?  We can help, maybe.
13:06:44 <dmwit> ?hpaste
13:06:44 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:06:49 <gwern> dmwit: interesting...
13:07:03 <dmwit> jimstutt: It would also be helpful if you could paste the exact error.
13:07:45 <jimstutt> ?djinn: let x =  forall b. T -> (forall a. (T a) => a -> b)
13:07:46 <lambdabot> Cannot parse command
13:08:06 <gwern> > let (-) ghc pkg = show "ghc-pkg" in (ghc-pkg)
13:08:07 <lambdabot>   Not in scope: `pkg'
13:08:17 <dons> ?users
13:08:17 <lambdabot> Maximum users seen in #haskell: 432, currently: 430 (99.5%), active: 19 (4.4%)
13:09:15 <bakert> dmwit: where is the join of type [a] -> [[a]] -> [a] .
13:09:26 <bakert> .. i get "not in scope"
13:09:27 <jimstutt> :t forall b. T -> (forall a. (T a) => a -> b)
13:09:28 <lambdabot> parse error on input `=>'
13:09:30 <ddarius> :t intercalate
13:09:30 <lambdabot> Not in scope: `intercalate'
13:09:45 <ddarius> :t \sep -> concat . intersperse sep
13:09:45 <lambdabot> forall a. [a] -> [[a]] -> [a]
13:09:51 <jimstutt> :t let x = forall b. T -> (forall a. (T a) => a -> b)
13:09:51 <dmwit> bakert: join :: m (m a) -> m a for any monad, including [].
13:09:51 <lambdabot> parse error on input `->'
13:10:00 <jimstutt> hoooray
13:10:08 <shapr> I'd like to recreate PreludeExts on HaskellWiki.
13:10:10 <dmwit> > join ["hey", " there"]
13:10:11 <lambdabot>  "hey there"
13:10:16 <dmwit> ?index join
13:10:16 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
13:10:16 <bakert> dmwit: oh i see, gosh [] really is a monad :)
13:10:17 <noobie> > map reads (words "1 2 nonumber") :: [[(Integer,String)]]
13:10:17 <lambdabot>  [[(1,"")],[(2,"")],[]]
13:10:31 <dmwit> bakert: Heh, sorry.  Maybe in Control.Monad?
13:11:00 <noobie> > sequence $ map reads (words "1 2 3") :: [[(Integer,String)]]
13:11:01 <lambdabot>  [[(1,""),(2,""),(3,"")]]
13:11:04 <Porge1> gwern: you can't really do unary operators
13:11:20 <noobie> > sequence $ map reads (words "1 2 3 y") :: [[(Integer,String)]]
13:11:20 <gwern> > let ghc = "ghc" in let pkg = "pkg" in let (-) ghc pkg= show "ghc-pkg" in (ghc-pkg)
13:11:21 <lambdabot>  []
13:11:21 <lambdabot>  "\"ghc-pkg\""
13:11:25 <Porge1> the closest I think would be (++) = const . (1 +)
13:11:30 <bakert> dmwit: sorry was meaning to poke fun at me not you!  gah ... sleeepy ... not very good at conveying my meaning.  thanks, anyway!  off to import Control.Monad (join) ...
13:12:05 <Japsu> hmm
13:12:16 <gwern> huh. that actually worked?
13:12:26 <noobie> > sequence $ map reads (words "1 2 3") :: [[(String,Integer)]]
13:12:26 <lambdabot>  Couldn't match expected type `Integer'
13:12:37 <ddarius> shapr: What we -really- need to do is rebuild the CommonIdioms page.
13:12:41 <shapr> Yeah, truly.
13:12:41 <dmwit> gwern: Sure, you didn't even need the parens:
13:13:00 <dmwit> > let ghc = "ghc"; pkg = "pkg"; ghc - pkg = "ghc-pkg" in ghc-pkg
13:13:01 <lambdabot>  "ghc-pkg"
13:13:07 <dmwit> But beware!
13:13:09 <noobie> sequence $ map reads (words "1 2 3 y") :: [[(String,String)]]
13:13:14 <dmwit> > let ghc = "ghc"; pkg = "pkg"; ghc - pkg = "ghc-pkg" in "a"-"b"
13:13:14 <lambdabot>  "ghc-pkg"
13:13:40 <marceau> noobie: you need a "> "
13:13:45 <noobie> > sequence $ map reads (words "1 2 3 y") :: [[(String,String)]]
13:13:46 <lambdabot>  []
13:13:53 <gwern> oh. hm. that's not good at all
13:14:10 <dmwit> On the other hand...
13:14:15 <gwern> I guess I can't coerce the haskell parser into being more shell-like as easily as that then...
13:14:31 <dmwit> > let ghc = "ghc"; pkg = "pkg"; a - b = a ++ '-':b in ghc-pkg
13:14:35 <lambdabot>  "ghc-pkg"
13:14:38 <dmwit> > let ghc = "ghc"; pkg = "pkg"; a - b = a ++ '-':b in "a"-"b"
13:14:38 <lambdabot>  "a-b"
13:14:49 <dmwit> You just need the right definition. =)
13:15:11 <jimstutt> :t let x = AnyE a forall err. Either err a
13:15:12 <lambdabot> <command line>:
13:15:12 <lambdabot>     Could not find module `L':
13:15:12 <lambdabot>       Use -v to see a list of the files searched for.
13:15:19 <davidL> > let x = 1; y = 2; x - y = 7 in x - y
13:15:19 <lambdabot>  7
13:15:28 <davidL> > let x = 1; y = 2; x - y = 7 in 9-4
13:15:29 <lambdabot>  7
13:15:43 <dmwit> jimstutt: You're trying to bind 'x' to a type.  That doesn't work in general.
13:15:56 <noobie> i want to return the values that are not int n the lst
13:15:59 <dmwit> jimstutt: You need to bind 'x' to an *instance* of the type.
13:16:01 <noobie> sequence $ map reads (words "1 2 3 y") :: [[(String,String)]]
13:16:12 <jimstutt> dmwit: ta - Q coming up
13:16:12 <noobie> but not workng
13:16:32 <marceau> > reads "1"
13:16:33 <lambdabot>  [(1,"")]
13:16:39 <dmwit> > filter (all isDigit) . words $ "1 2 3 y"
13:16:40 <lambdabot>  ["1","2","3"]
13:16:45 <marceau> the first element is not a string
13:16:46 <gwern> dmwit: ack! I have no idea what you are doing there!
13:16:50 <dmwit> whooops
13:16:59 <dmwit> > filter (not . all isDigit) . words $ "1 2 3 y"
13:17:00 <lambdabot>  ["y"]
13:17:02 <jimstutt> :t  AnyE a forall err. Either err a
13:17:02 <lambdabot> Not in scope: data constructor `AnyE'
13:17:02 <lambdabot> Not in scope: `a'
13:17:02 <lambdabot> Not in scope: `forall'
13:17:21 <dmwit> noobie: Just be more explicit about what you want, and it's easy. =)
13:17:37 <jimstutt> :t  instance x of AnyE a forall err. Either err ae
13:17:37 <lambdabot> parse error on input `instance'
13:17:40 <noobie> but what f it is  A data type i created
13:17:59 <dmwit> noobie: Then just write your own predicate function to pass to filter.
13:18:28 <noobie>  filter (not . all Colors) . words $ "1 2 3 y"
13:18:31 <dmwit> Or maybe I'm misunderstanding.
13:18:35 <noobie> could that wor?
13:18:56 <noobie> defned a type called Colors
13:19:03 <gwern> > let ghc = "ghc"; pkg = "pkg"; a - b = a ++ '-':b in 1-1
13:19:03 <lambdabot>   add an instance declaration for (Num [Char])
13:19:14 <dmwit> newbie: Aha, I see.  You want to use the Read instance to see if a word is an instance of your datatype?
13:19:27 <noobie> yes
13:19:32 <dmwit> :t reads
13:19:32 <lambdabot> forall a. (Read a) => String -> [(a, String)]
13:19:35 <jimstutt> :t
13:19:36 <jimstutt> forall b.
13:19:36 <jimstutt>                    ConnWrapper -> (forall conn. (IConnection conn) => conn -> b) -> b
13:21:12 <dmwit> noobie: Then you probably want something like (isColor s = not . null . (reads :: String -> [(Color, String)]) $ s) or so.
13:21:29 <dmwit> jimstutt: So tell me in your own words what you think :t does.
13:21:41 <jimstutt> : t let x = forall b. Connwrapper -> (forall conn. (IConnection conn) => conn -> b) ->b
13:22:03 <davidL> is this pattern not matchable? [v,y,l0,l1,i0,i1,f0,f1,t,p,c0,c1,s0,s1,s2,s3,d0,d1,d2,d3,o0,o1,o2,o3,a]
13:22:06 <noobie> i want to return the incorrect value a person may enter, that is something not defined in my data type e.g data Col = Bk | Cy |Rd read whateva "cy cy rd gf" return gf
13:22:30 <dmwit> davidL: That's matchable, but keep in mind that it matches *only* lists of exactly that length.  Longer or shorter just will not do.
13:22:31 <jimstutt> :t let x = forall b. Connwrapper -> (forall conn. (IConnection conn) => conn -> b) ->b
13:22:32 <lambdabot> parse error on input `->'
13:22:43 <davidL> dmwit: ohhh, that's the problem
13:22:50 <davidL> dmwit: how can I fix that?
13:23:05 <dmwit> davidL: More pattern matches. =)
13:23:13 <dmwit> davidL: Do you want to match longer lists or shorter ones?
13:23:19 <ddarius> (a:b:c:_) if you wanted to match three or more
13:23:24 <davidL> dmwit: longer ones
13:23:34 <jimstutt> dmwit: my Q is how I parse the last post, I just wanted :t to tell me there was a type error and there was. Help much appreciated.
13:23:34 <dmwit> Yep, see what ddarius said then.
13:23:38 <bakert> ?src concat
13:23:38 <lambdabot> concat = foldr (++) []
13:23:44 <bakert> ?src Control.Monad.join
13:23:44 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
13:23:57 <dmwit> jimstutt: There's never a type error on an annotation.  Only on an expression.
13:24:17 <dmwit> ?src join []
13:24:17 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
13:24:21 <dmwit> ?src [] join
13:24:21 <lambdabot> Source not found. Do you think like you type?
13:24:25 <dmwit> Well, anyway
13:24:29 <shachaf> dmwit: join = (>>= id)
13:24:32 <shachaf> @src join
13:24:32 <lambdabot> join x =  x >>= id
13:24:32 <dmwit> join xs = xs >>= id
13:24:48 * dmwit leaves
13:24:50 <bakert> The trouble with join is that it does this:
13:25:02 <bakert> ["a", "b"] ----> "ab"
13:25:05 <bakert> and i want
13:25:08 <bakert> ",
13:25:11 <bakert> grr
13:25:21 <bakert> "," ["a", "b"] -----> "a,b"
13:25:26 <bakert> which is kind of a fold
13:25:31 <TSC> intersperse?
13:25:33 <Korollary> @index intersperse
13:25:33 <lambdabot> Data.List
13:25:33 <dmwit> bakert: See intersperse.
13:25:36 <bakert> but doesn't add the last comma
13:25:38 <bakert> ah
13:25:39 <bakert> cool!
13:25:44 <shachaf> > concat . intersperse "," $ ["a","b"]
13:25:45 <lambdabot>  "a,b"
13:25:47 <TSC> or intercalate
13:25:50 * dmwit really leaves this time
13:25:50 <bakert> that's my boy
13:25:52 <TSC> @src intercalate
13:25:53 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
13:26:10 <bakert> intercalcate is excting.  nice name
13:26:16 <jimstutt> dmwit: it's the function denifition of withWConn in HDBC.Datase.Types which gives an Illegal polymorphic or qualified type
13:26:17 <gwern> wonderful. so if the name has a leading capital letter, a -, a ., a + or a god knows what else, it's not a legal function name. wonderful
13:26:17 <bakert> ?hoogle intersperse
13:26:17 <lambdabot> List.intersperse :: a -> [a] -> [a]
13:26:43 <gwern> bakert: how about catenate?
13:26:49 <Japsu> Which monad is it here (for join):
13:26:50 <Japsu> @pl \n m -> (10 ^ (floor (log (fromIntegral m) / log 10) + 1)) * n + m
13:26:50 <lambdabot> join . ((+) .) . (. ((10 ^) . (1 +) . floor . (/ log 10) . log . fromIntegral)) . (*)
13:26:53 <bakert> ?src catenate
13:26:53 <lambdabot> Source not found. Maybe if you used more than just two fingers...
13:26:56 <Japsu> r (->) ?
13:26:58 <bakert> :t catenate
13:26:59 <lambdabot> Not in scope: `catenate'
13:27:04 <bakert> blah
13:27:12 <bakert> ?hoogle catenate
13:27:12 <lambdabot> No matches found
13:27:24 <bakert> gwern: now you are just making things up to upset me :(
13:27:28 <allbery_b> concat
13:27:36 <gwern> ...catenate was the name from which 'cat' was derived, and mistakenly expanded to 'concatenate' by subsequent generations, afaik
13:27:38 <Japsu> > concat ["a", "boo", "c"]
13:27:38 <lambdabot>  "abooc"
13:27:56 <gwern> and as allbery_b rightly points out, then condensed down to 'concat'
13:28:05 <davidL> gwern: interesting
13:28:24 * gwern thought it was a nice bit of trivia to share while we were discussing obscure latinates
13:29:12 <luqui> catenulate...
13:29:22 <conal> ooh, i like that one
13:29:32 <jimstutt> ?hoogle withWConn
13:29:33 <lambdabot> No matches found
13:29:52 <jimstutt> ?index IConnection
13:29:52 <lambdabot> bzzt
13:30:32 <nexi> hm how long does it need to build ghc? p3 1000 756mb ram
13:31:19 <jimstutt> ?lambdabot
13:31:19 <lambdabot> Unknown command, try @list
13:31:28 <jimstutt> @list lambdabot
13:31:28 <lambdabot> No module "lambdabot" loaded
13:31:32 <jimstutt> @list index
13:31:33 <lambdabot> haddock provides: index
13:31:38 <gwern> figure two or three hours for both stages. for a quad core with 4gb, it's between half an hour and an hour iirc
13:31:49 <jimstutt> @list haddock
13:31:49 <lambdabot> haddock provides: index
13:31:59 <davidL> gwern: really? did you use -j10 ?
13:32:06 <nexi> =O
13:32:21 <luqui> @src Ordering mappend
13:32:21 <lambdabot> Source not found. stty: unknown mode: doofus
13:33:58 <dikini> dons: http://patrickyeon.blogspot.com/2007/11/holy-cannoli-here-comes-assembly.html
13:33:59 <lambdabot> Title: Semi-Random Neuron Firings: Holy Cannoli! Here Comes Assembly!, http://tinyurl.com/37o2u3
13:34:10 <dikini> this thing has a life of its own
13:34:12 <dikini> :)
13:35:15 <RayNbow> Another episode in the Naive Fibonacci wars? Cool :)
13:37:23 <augustss> It's totally crazy.
13:38:55 <augustss> It's amazing how clueless some people are. :)
13:40:41 <dikini> well, i'm from the clueless ones too, still this wars shootout is amazing, socially
13:41:15 <RayNbow> should I get my TI-83+ and write a Fib program in TI-BASIC? :p
13:41:49 <Korollary> I propose that fibonacci be included in SSE4
13:42:12 * ddarius writes a "massively parallel" fibonacci in the Game of Life.
13:43:20 <jimstutt> ddarius: how about billiard fredkin gates?
13:43:29 <int-e> oh, using millions of gliders and space ships?
13:44:13 <SamB> ti-basic has function definition?
13:44:23 <SamB> int-e: what is a space-ship?
13:44:25 <RayNbow> http://www.dalkescientific.com/writings/diary/archive/2007/06/01/lolpython.html <-- a "new" contestant... a Fibonacci function written in LOLPython :)
13:44:25 <lambdabot> Title: LOLPython, http://tinyurl.com/2n2dl5
13:45:00 <RayNbow> too bad it's iterative
13:45:46 <bakert> int-e: http://www.radicaleye.com/lifepage/patterns/newc5/newc5.html
13:45:46 <lambdabot> Title: David Bell's c/5 spaceship
13:45:57 <davidL> this is my favorite fib function: http://compsoc.dur.ac.uk/whitespace/fibonacci.ws
13:46:04 <Porge1> I did one in C# using a GMP wrapper
13:46:29 <int-e> SamB: a generalization of gliders, http://en.wikipedia.org/wiki/Spaceship_(CA) (or see bakert's link)
13:46:37 <RayNbow> davidL, I'm not fluent in whitespace... is that implementation iterative or recursive?
13:46:52 <davidL> RayNbow: recursive
13:48:10 <jimstutt> forall b.
13:48:10 <jimstutt>                    ConnWrapper -> (forall conn. (IConnection conn) => conn -> b) -> b
13:48:44 <dons> yeah, its pretty crazy. the perfect storm of extreme simplicity, many alternative algorithms, and performance measuring
13:49:17 <jimstutt> :t let x = forall b. ConnWrapper -> (forall conn. (IConnection conn) => conn -> b) -> b
13:49:17 <lambdabot> parse error on input `->'
13:49:23 <dons> ?users
13:49:23 <lambdabot> Maximum users seen in #haskell: 432, currently: 429 (99.3%), active: 29 (6.8%)
13:49:50 <jimstutt> :t let x = forall b. ConnWrapper -> (forall conn. (IConnection conn) )
13:49:50 <lambdabot> parse error on input `->'
13:50:07 <jimstutt> :t let x = forall b. ConnWrapper -> (forall a. a)
13:50:08 <lambdabot> parse error on input `->'
13:50:20 <dons> jimstutt: you'll need to do that in ghci
13:50:28 <dons> since lambdabot doesn't support more than h98 syntax
13:50:30 <jimstutt> dons: ta
13:54:07 <grahamhutton> @users
13:54:08 <lambdabot> Maximum users seen in #haskell: 433, currently: 433 (100.0%), active: 30 (6.9%)
13:54:20 <grahamhutton> record!
13:54:41 <monochrom> good evening
13:54:50 <dons> yeah, new record. wow.
13:54:57 <grahamhutton> indeed!
13:55:22 <monochrom> oh, 400+, I haven't noticed. last time the celebration was for 300+.
13:55:27 <dons> :)
13:55:56 <dons> i wonder how far off #python we are now
13:56:07 <fasta> The number of bots doubled? ;)
13:56:34 <dons> #python, Current: 462, Avg: 440,. #haskell, 433 433
13:56:41 <dons> avg . 389 here
13:56:42 <Nafai> Yay for the new record!
13:57:23 <fasta> This plan for not becoming popular is not working...
13:59:01 <monochrom> We need more scary abstractions such as lax natural transformations!
13:59:15 <fasta> Yes, I just saw that on hackage.
13:59:21 <monochrom> haha
13:59:46 <fasta> Well, I don't know whether it were natural transformations.
14:01:21 <dons> ?users
14:01:21 <lambdabot> Maximum users seen in #haskell: 434, currently: 434 (100.0%), active: 27 (6.2%)
14:02:31 <Korollary> oh no. somebody quit.
14:02:54 <davidL> woot!
14:04:55 <davidL> is it possible to write a quine in one line of haskell?
14:05:22 <olsner> @faq
14:05:22 <lambdabot> The answer is: Yes! Haskell can do that.
14:06:00 <opqdonut> :D
14:06:18 <musiKk> i bet this is an often used command, eh?
14:06:29 <Zao> Not as popular as @stereo
14:06:35 <Zao> (the old one)
14:06:50 <musiKk> @stereo
14:06:50 <lambdabot> Unknown command, try @list
14:06:54 <davidL> majestic stereo?
14:06:56 <grahamhutton> here's a one line quine: http://www.ipl.t.u-tokyo.ac.jp/~scm/quine.hs
14:06:58 <musiKk> what happened then?
14:07:19 <davidL> grahamhutton: amazing
14:07:22 <dons> ?users
14:07:22 <lambdabot> Maximum users seen in #haskell: 435, currently: 434 (99.8%), active: 26 (6.0%)
14:07:26 <grahamhutton> (but one-line doesn't mean much, as you can put arbitrarily much into one line)
14:08:54 <davidL> > let bod = " in  \"let bod = \" ++ show bod ++ bod" in "let bod = " ++ show bod ++ bod
14:08:55 <lambdabot>  "let bod = \" in  \\\"let bod = \\\" ++ show bod ++ bod\" in  \"let bod = \"...
14:09:54 <davidL> that was FMota's ;)
14:12:21 * Nafai starts reading "All about Monads"
14:12:22 <FMota> hm
14:12:34 <FMota> I actually liked more this one:
14:12:41 <FMota> > ap(++)show"ap(++)show"
14:12:42 <lambdabot>  "ap(++)show\"ap(++)show\""
14:12:51 <FMota> :)
14:13:24 <FMota> *this one more. Must not forget how to speak english.
14:13:32 <hpaste>  Mitar pasted "problems with circular imports" at http://hpaste.org/4197
14:13:34 <davidL> :)
14:14:15 <Mitar> can anybody help me with that? i read GHC documentation on solving circular imports, but i do not have to make a boot file from this ...
14:14:25 <dmwit> jimstutt: Still around?
14:15:46 <dmwit> Mitar: You need to name your files the same as the module.
14:16:07 <Mitar> ahh, that was a typo :-(
14:16:12 <Mitar> now, when i was pasting ...
14:16:18 <dmwit> ok
14:16:55 <Mitar> i tried importing with {-SOURCE-} SynTree in SemType
14:17:08 <Mitar> but i do not managed to make a working -boot file ...
14:17:21 <Mitar> as i see it should contain everyhing ...
14:17:22 <dmwit> Ah, I have no experience with -boot files.
14:17:40 <Mitar> is there an other way around?
14:18:11 <jimstutt> dmwit: yeh but ghci ing and pondering
14:18:34 <dmwit> jimstutt: Have you worked with any other languages (which ones)?
14:20:03 <jimstutt> dmwit: my zortech c compiler burned out in the 80s -> c++/Z -> java
14:20:21 <dmwit> Okay.  So I'll give an analogy to C.
14:20:42 <dmwit> In C, there's a difference between the declaration "int f(int x);" and the definition "int f(int x) { return x + 1; }".
14:20:51 <dons> welcome to all the new people :)
14:21:07 <dmwit> Haskell makes a similar distinction between a type declaration "f :: Int -> Int" and a function definition "f x = x + 1".
14:21:34 <dmwit> What Haskell has that C doesn't, really, is a convenient way to recover a type declaration from the name of the function.
14:21:51 <wellwisher> is there a Prelude function that extracts the old indexed elements from a list?
14:21:53 <dmwit> So, ":t f" is that mapping, and it would give "Int -> Int".
14:22:01 <dmwit> Okay.
14:22:08 <dmwit> Does it make sense so far?
14:22:30 <dmwit> wellwisher: "old" indexed elements?
14:22:51 <wellwisher> i.e. [1,3,5,7,9,11] returns [(1,3),(5,7),(9,11)]
14:23:07 <wellwisher> i ment odd
14:23:09 <jimstutt> dmwit: yeh course, can I ask something diff cos it's just I haven't read any tool info yet, just luv the linear programming?
14:23:38 <dmwit> wellwisher: What would the return for [1,1,3,3] be?
14:23:54 <dmwit> wellwisher: Anyway, I don't think there's a Prelude function for that.
14:24:00 <wellwisher> [(1,1),(3,3)]
14:24:03 <dmwit> jimstutt: Okay, sure.
14:24:08 <ddarius> wellwisher: No.
14:24:12 <dons> > (\s -> zip s (tail s)) [1,3,5,7,9,11]
14:24:13 <lambdabot>  [(1,3),(3,5),(5,7),(7,9),(9,11)]
14:24:21 <dmwit> almost
14:24:47 <dmwit> > let f (x:y:rest) = (x, y) : f rest; f [] = [] in f [1,3,5,6,7,8]
14:24:48 <lambdabot>  [(1,3),(5,6),(7,8)]
14:24:55 <ddarius> wellwisher: It is easy to write, but there is no convenient way to do it with what exists (i.e. more convenient than a direct recursive definition)(
14:25:04 <dmwit> It's closely related to "chunk", which everybody writes at least once. =)
14:25:07 <dons> yeah, its slightly harder than you'd imagine
14:25:15 <wellwisher> i was just wondering
14:25:22 <dons> its a good question, wellwisher
14:25:57 <dons> there's a mapAccum solution too, I suspect
14:26:02 <dons> :t mapAccumL
14:26:03 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
14:26:26 <wellwisher> a function like that would be useful if it were included in the prelude
14:26:58 <dmwit> wellwisher: What are you using it for?
14:27:10 <dmwit> (Just out of curiosity.)
14:27:20 <wellwisher> parsing data
14:27:26 <dons> ah!
14:27:33 <dons> perhaps you can use take and drop
14:27:38 <wellwisher> two columns of different data
14:27:59 <dons> right, so zip up the columns
14:28:07 <dmwit> yep
14:28:15 <ddarius> > let bitrev :: [a] -> [a]; bitrev [x] = [x]; bitrev xs = uncurry (++) . unzip . bitrev . pairUp $ xs where pairUp [] = []; pairUp (x:y:xs) = (x,y):pairUp xs in bitrev [0..15]
14:28:15 <lambdabot>  [0,8,4,12,2,10,6,14,1,9,5,13,3,11,7,15]
14:28:28 <ddarius> Polymorphic recursion ho!
14:28:30 <bakert> is there a commonPrefix function hiding somewhere?  Something in between takeWhile and intersect
14:28:43 <bakert> Eq a => [a] -> [a] -> [a]
14:29:10 <dmwit> No, but there's zipWith ((==) &&& id) ;-)
14:29:16 <dmwit> err
14:29:19 <dmwit> :t (&&&)
14:29:20 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
14:29:25 <dmwit> yeah
14:29:58 <Syzygy-> :t ((==) &&& id)
14:29:59 <lambdabot> forall a. (Eq a) => a -> (a -> Bool, a)
14:30:06 <jimstutt> dmwit: Database.HDBC.Types and its dependents load into ghci ok; my forall b. ConnWrapper -> (forall conn. (IConnection conn) => conn -> b) ->b barfs at '->'; I need to lookup  (=>)
14:30:09 <ddarius> :t zipWith ((==) &&& id) -- are you sure that is what you want?
14:30:09 <lambdabot>     Couldn't match expected type `b -> c'
14:30:09 <lambdabot>            against inferred type `(a -> Bool, a)'
14:30:09 <lambdabot>     In the first argument of `zipWith', namely `((==) &&& id)'
14:30:36 <dmwit> I'm sure it isn't what I want. =P
14:31:14 <bakert> commonPrefix (x:xs) (y:ys)
14:31:14 <bakert>     | x == y = (x:(commonPrefix xs ys))
14:31:14 <bakert>     | otherwise = []
14:31:28 <bakert> (plus the case for either arg being [] = [])
14:31:44 <dmwit> bakert: Yeah, nice and simple.
14:31:51 <bakert> that doesn't have a name?
14:31:52 <ddarius> takeWhile (uncurry (==)) . zip
14:32:22 <bakert> :t takeWhile (uncurry (==)) . zip
14:32:23 <lambdabot>     Couldn't match expected type `[(a, a)]'
14:32:23 <lambdabot>            against inferred type `[b] -> [(a1, b)]'
14:32:23 <lambdabot>     In the second argument of `(.)', namely `zip'
14:32:23 <dmwit> jimstutt: Care to paste?
14:32:29 <ddarius> > (takeWhile (uncurry (==)) .) . zip $ "Sally" "Salute"
14:32:29 <lambdabot>  Couldn't match expected type `t -> [b]'
14:32:58 <ddarius> > ((takeWhile (uncurry (==)) .) . zip)  "Sally" "Salute"
14:32:59 <lambdabot>  [('S','S'),('a','a'),('l','l')]
14:33:11 <ddarius> > (map fst . takeWhile (uncurry (==)) .) . zip)  "Sally" "Salute"
14:33:12 <lambdabot> Unbalanced parentheses
14:33:24 <chessguy> heh. i did something yesterday like length . filter id . zipWith (==) to count the number of characters in two strings that were the same
14:33:27 <ddarius> > (map fst . (takeWhile (uncurry (==)) .) . zip)  "Sally" "Salute"
14:33:27 <lambdabot>  Couldn't match expected type `[(a, b)]'
14:33:33 <dmwit> > map fst . takeWhile (uncurry (==)) $ zip "Sally" "Salute"
14:33:33 <lambdabot>  "Sal"
14:34:27 <ddarius> [x | x <- "Sally" | y <- "Salute", x == y]
14:34:52 <dmwit> > [x | (x, y) <- zip "Sally" "Salute", x == y]
14:34:53 <lambdabot>  "Sal"
14:35:02 <dmwit> pretty
14:35:02 <notsmack> > [x | x <- "Sally" | y <- "Salutey", x == y]
14:35:03 <lambdabot>  Parse error at "|" (column 19)
14:35:07 <bakert> nice
14:35:24 <ddarius> notsmack: lambdabot doesn't have that extension enabled (which I'm perfectly fine with)
14:35:26 <chessguy> >  [x | (x, y) <- zip "Sally" "FooSal", x == y]
14:35:26 <lambdabot>  ""
14:36:03 <bakert> ah, the list comprehension has a problem though:
14:36:11 <notsmack> >  [x | (x, y) <- zip "Sally" "Fooly", x == y]
14:36:11 <lambdabot>  "ly"
14:36:13 <bakert> > let f a b =  [x | (x, y) <- zip a b, x == y]
14:36:13 <lambdabot>  Parse error at end of input
14:36:15 <dmwit> ddarius: Does that generalize to any old monad?
14:36:38 <chessguy> yeah, i thouht there was something wrong there
14:36:41 <dmwit> notsmack: mmm, good point
14:36:47 <ddarius> dmwit: I doubt it.  Certainly not -any- monad.
14:37:09 <bakert> brave attempt :)
14:37:14 <jimstutt> dmwit: sure, but sorry, have been luvin hpaste but not read the destructions...
14:37:45 <dmwit> ...
14:37:50 <dmwit> just click "New"
14:39:06 <chessguy> it's not exactly a complicated app :)
14:39:41 <Mitar> is this correct?
14:39:41 <Mitar> type SemTypeM = ReaderT Environment (Either SemError) SemType
14:39:56 <hpaste>  jimstutt pasted "Illegal polymorphic or qualified type" at http://hpaste.org/4199
14:40:17 <Mitar> before i had: type SemTypeM = Either SemError SemType, and now I would like to put Reader on top of that
14:40:26 <Porge1> is there anywhere to request bugfixes for hpaste?
14:40:36 <dmwit> jimstutt: Just to make sure, you've put that in a file, right?  Along with a definition for withWConn?
14:40:49 <dmwit> (You can't type that directly in ghci without a few changes.)
14:41:01 <jimstutt> dmwit: ghci -fglasgow-exts
14:41:14 <dmwit> You still have to put it in a file.
14:41:20 <jimstutt> dmwit: :l Database.HDBC.Types
14:41:30 <wellwisher> how do i specify the type of read in: print (map (read :: Int) (words input))  ?
14:41:52 <jimstutt> dmwit: ...Statement and ...ColTypes load ok
14:41:59 <dmwit> jimstutt: ghci only evaluates expressions.  Anything else needs to be put in a file.
14:42:17 <dmwit> print (map (read :: String -> Int) (words input))
14:42:29 <jimstutt> dmwit: ok was just working on that before your much needed attm
14:43:10 <dmwit> porges: What's wrong with it?
14:43:30 <dmwit> porges: If it's really a bug, you can ?tell glguy, probably.
14:43:45 <porges> the code highlighter breaks unicodea
14:43:49 <porges> unicode
14:43:53 <dmwit> mm
14:44:23 <hpaste>  jimstutt pasted "HDBCTest.lhs" at http://hpaste.org/4200
14:44:43 <Mitar> now I get this error: No instance for (Show SemTypeM)
14:45:08 <dmwit> jimstutt: Aaah, IConnection is a type class, not a type. =)
14:45:13 <dmwit> err...
14:45:28 <dmwit> jimstutt: Aaah, IConnections is a type constructor, not an expression.
14:45:57 <dmwit> bah
14:46:02 <desegnis> Mitar: (Either SemError SemType) is not a monad, (Either SemError) is (probably).
14:46:08 * dmwit tries a third time
14:46:13 <Mitar> how can I derive Show for such type: type SemTypeM = ReaderT Environment (Either SemError) SemType
14:46:20 <dmwit> IConnection is a type class, not an expression.
14:46:41 <dmwit> jimstutt: A type class is just a set of types.  The type signature for ConnWrapper means,
14:47:08 <dmwit> jimstutt: ... that any type "conn" that's in the set of types "IConnection" is an acceptable argument.
14:47:37 <dmwit> jimstutt: That's why you can't use ":t" on IConnection... because there are multiple IConnection types.
14:47:59 <jimstutt> dmwit: in the doc it says that ConnWrapper is an IConnection but I'm not sure 6.8.1 thinks so?
14:48:34 <dmwit> jimstutt: You can find out by using ":i ConnWrapper" or ":i IConnection".
14:48:48 <dmwit> If ConnWrapper is listed as an instance of IConnection, then you're good to go.
14:49:05 <desegnis> Mitar: Any Monad is of kind * -> *, so that you have the result of the “computation” in the type. E. g. return 5 :: IO Int, where IO has kind * -> *.
14:49:17 <dmwit> jimstutt: As an aside, if withWConn is defined in one of your imports, you don't need to re-declare its type. ;-)
14:49:47 <Mitar> what means?
14:49:52 <Mitar> is it ok?
14:50:02 <jimstutt> dmwit: :i ConnWrapper gives 'Top level not in scope or constructor or class 'ConnWrapper'; same with IConnection
14:50:02 <Mitar> it seems type checking is satisfied
14:50:13 <Mitar> but i do not really get the semantics
14:50:43 <desegnis> Mitar: paste?
14:52:07 <dmwit> jimstutt: uhh... hm.
14:52:12 <hpaste>  Mitar pasted "reader lifting" at http://hpaste.org/4201
14:53:01 <dmwit> jimstutt: Oh.  Have a look at the top of your file there.
14:53:18 <dmwit> jimstutt: It should be "import Database.HDBC".
14:54:03 <hpaste>  Mitar annotated "reader lifting" with "(no title)" at http://hpaste.org/4201#a1
14:54:18 <dmwit> i.e. "import ConnWrapper" and "import IConnection" don't work; you have to import modules.
14:55:52 <desegnis> Mitar: SemTypeM is not a monad in either case. An example of a monad would be type SemMonad a = Either SemError a. (And then you need to import something, I think it's Control.Monad.Error)
14:56:58 <desegnis> Mitar: Then you can put ReaderT on top of that: type SemMonadReader a = ReaderT Environment (Either SemError) a
14:57:32 <desegnis> But with this approach, you lose SemType in the definitions, because a monad must be able to compute values of any type a, not just SemType.
14:59:27 <Mitar> and if i fix a to SemType?
14:59:43 <dmwit> Then you can't declare it as an instance of Monad. =/
15:00:16 <Mitar> but it looks like type checking eat it :-)
15:00:22 <unk_red> i'm trying to install plugins with cabal-install and i'm getting the following error. http://hpaste.org/4202 any ideas?
15:00:51 <dons> unk_red: unfortunately, only the darcs version of hs-plugins works, and only with ghc 6.6
15:01:07 <desegnis> Mitar: If you need it to be fixed in a particular context, just require it to be  SemMonad SemType
15:01:38 <desegnis> That is, a value of your monad computing a SemType.
15:02:21 <hpaste>  Mitar annotated "reader lifting" with "better?" at http://hpaste.org/4201#a2
15:02:30 <davidL> > showHex 167772165 ""
15:02:30 <lambdabot>  "a000005"
15:03:21 <unk_red> dons: thanks.   i've got 6.6. how do i find the darcs repos for a package?
15:03:38 <desegnis> Mitar: A value in a ReaderT monad cannot be shown. You must comupte it first, using runReaderT.
15:03:52 <jimstutt> dmwit: woopee fun; back to the beginning; repalced withWConn name in hpastewith a let xand got my original 'parse error on 'input ->''; debugging tutorial excellent
15:04:21 <dmwit> jimstutt: Just omit the entire line.
15:04:24 <desegnis> Mitar: But it is hard to explain your errors without knowing the code that has them.
15:05:09 <RyanT5001> is there anything like cron in HAppS?
15:05:28 <RyanT5001> i need to send out emails that depend on the application state
15:05:36 <RyanT5001> and the sending of those emails needs to update the application state
15:05:38 <jimstutt> dmwit: It's hard to give enough or (if newb) useful info in short space
15:06:33 <dons> unk_red: its a www.cse.unsw.edu.au/~dons/code/hs-plugins
15:06:39 <jimstutt> dmwit: it's the definition of withWConn in HDBC which is stopping me having a database - it's illegal in 6.8.1 for some reason
15:06:50 <unk_red> hackage needs links to home pages and darcs repositories. haskell packages aren't very google friendly :)
15:06:58 <unk_red> dons: thanks again
15:07:58 <dmwit> jimstutt: Are you having trouble building HDBC (the library), or are you having trouble building your own code using HDBC?
15:08:42 <bakert_> Is there an easy way of soring a list by "length" (the function)?
15:08:57 <bakert_> sortBy (compare length)???
15:08:57 <dmwit> sortBy length
15:09:10 <dmwit> sortBy (compare `on` length)
15:09:10 <Heffalump> sortBy (compare `on` length)
15:09:19 <bakert_> cool thanks
15:09:34 <Heffalump> (f `on` g) x y = f (g x) (g y)
15:09:34 <bakert_> on is a very good name :)
15:09:42 <jimstutt> dmwit: the library. As unfortunate newb didn't want to learn obsolete 6.8.; 2 weeks of mod'ing .cabal files I think I now know where I am and am not
15:09:44 <Heffalump> though there's probably a definition in some standard library somewhere
15:09:50 <desegnis> bakert_: Come back when you experience performance penalties :)
15:09:57 <jimstutt> dmwit: so I started to try an understand
15:10:14 <Heffalump> yes, that'll do (n log n) length calls
15:10:34 <Heffalump> someone should add a rewrite rule beside the definition of `on`.
15:10:38 <jimstutt> forall b. T -> (forall a. (T a) => a -> b ) -> b is what I guess the type of withWConn should be if IConnect and ConnWrapper have some equivalence
15:10:51 <bakert_> desegnis: i would love to hit performance problems .. that would mean my program was working! :)
15:11:12 <dmwit> If performance becomes a problem, you can adapt Python's old "decorate, sort, undecorate" approach.
15:11:13 <desegnis> hehe
15:11:26 <jimstutt> dmwit:s/6.6/6.8/
15:11:33 <porges> hoogle (b -> b -> a) -> (c -> b)  -> c -> c -> a
15:11:38 <desegnis> dmwit: Oh, that's Python's approach? :)
15:11:44 <porges> @hoogle (b -> b -> a) -> (c -> b)  -> c -> c -> a
15:11:44 <lambdabot> No matches, try a more general search
15:11:55 <ddarius> Heffalump: ?
15:12:04 <RyanT5001> bakert_: try: map snd . sortBy (compare `on` fst) . map (length &&& id)
15:12:15 <Heffalump> ddarius: ? ?
15:12:18 <RyanT5001> bakert_: that'll only do the lengths once
15:12:30 <ddarius> [17:10] <Heffalump> someone should add a rewrite rule beside the definition of `on`. ?
15:12:53 <Heffalump> to transform the inefficient code into the decorate,sort,undecorate approach
15:12:54 <Mitar> is this correct: "Which order to choose depends on the role of errors in your computation. If an error means no state could be produced, you would apply StateT to Error. If an error means no value could be produced, but the state remains valid, then you would apply ErrorT to State."
15:13:02 <Mitar> is not exactly the oposite?
15:13:07 <Heffalump> though you'd have to be a bit careful given that sortBy (compare `on` fst) would also match the rule :-)
15:14:16 <bakert_> The trouble with a nifty little name like "on" is that i can't blooming well find it ... what module does it live in?
15:14:31 <bakert_> Ordering seems to be in the Prelude but not on
15:14:31 <notsmack> @hoogle on
15:14:32 <lambdabot> Test.QuickCheck.oneof :: [Gen a] -> Gen a
15:14:32 <lambdabot> System.Console.Readline.onNewLine :: IO ()
15:14:32 <lambdabot> Text.ParserCombinators.Parsec.Char.oneOf :: [Char] -> CharParser st Char
15:14:33 <Heffalump> bakert_: I don't know if it does, but I generally just put a definition inline when I need it, as above.
15:14:37 <ddarius> @index on
15:14:37 <lambdabot> bzzt
15:14:39 <ddarius> on is relatively new.
15:14:51 <bakert_> oh i see.  i will add it.  thanks.
15:14:55 <dmwit> It's only in 6.8
15:15:09 <desegnis> Mitar, it is.
15:15:39 <desegnis> wait
15:15:50 <ddarius> Mitar: That paragraph is correct.
15:16:03 <Mitar> hmm
15:16:17 <Mitar> but if i compare it with the last example on http://www.haskell.org/ghc/docs/latest/html/libraries/mtl-1.1.0.0/Control-Monad-Error.html
15:16:18 <lambdabot> http://tinyurl.com/2rr3l5
15:16:27 <desegnis> Mitar: The paragraph is correct. Think of the order in which you'd apply the “run” functions.
15:17:58 * ddarius just always goes back to the types for these kind of issues.
15:18:02 <ddarius> :t runStateT
15:18:03 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
15:18:04 <ddarius> :t runErrorT
15:18:05 <lambdabot> forall e (m :: * -> *) a. ErrorT e m a -> m (Either e a)
15:18:21 <porges> wait, so is `on` in the libraries or not?
15:18:22 <ddarius> @unmtl StateT s (Either e) a
15:18:22 <lambdabot> err: Unknown MTL(1)
15:18:32 <ddarius> @unmtl StateT s (Error e) a
15:18:32 <lambdabot> err: Unknown MTL(1)
15:18:41 <ddarius> porges: It's in the newest versions.
15:19:14 <Mitar> ok, for example in my case, where i am doing a semantic analysis of a abstract tree and I would like to use Reader to store currently known identifiers and Error to report semantic errors, is the correct order ErrorT on Reader?
15:19:56 <ddarius> It doesn't make any difference in that case.
15:20:24 <porges> ddarius: under what? I can't seem to find it :/
15:20:26 <Mitar> why not?
15:21:00 <Mitar> (and, is Reader suitable for this task or - it looks like it should be quite good for "scoping")
15:21:48 <ddarius> Whether reader is good depends on how identifiers get introduced, but it probably is.
15:22:05 <ddarius> :t runErrorT
15:22:05 <lambdabot> forall e (m :: * -> *) a. ErrorT e m a -> m (Either e a)
15:22:40 <ddarius> :t ReaderT
15:22:40 <lambdabot> forall r (m :: * -> *) a. (r -> m a) -> ReaderT r m a
15:23:10 <darrint> Anyone know there a complete example of how to use MonadPrompt online?
15:23:13 <ddarius> ErrorT e (Reader r) a = r -> Either e a, ReaderT r (Either e) a = r -> Either e a
15:25:03 <ddarius> porges: http://www.haskell.org/ghc/docs/latest/html/libraries/base-3.0.0.0/Data-Function.html#v%3Aon
15:25:04 <lambdabot> http://tinyurl.com/2gq27x
15:25:12 <porges> thanks :)
15:25:33 <ddarius> To find it I went to the "Standard Libraries" page, clicked on Index in the upper right corner and looked for "on"
15:25:55 <porges> seems I put too much faith in hoogle :P
15:26:58 <bakert_> I know this is an over-general question, but what do people tend to use as a data store for haskell?
15:27:09 <bakert_> i don't see a lot of SQL talk on here
15:27:25 <ddarius> The same way you use it in any other language.
15:27:49 <bakert_> my brain is trained to turn everything into a relational database ... but i'm considering text files or something ... ?
15:28:04 <bakert_> happs actually seems to store haskell data in some way?
15:28:32 <sethk> @hoogle system
15:28:32 <lambdabot> System.system :: String -> IO ExitCode
15:28:32 <lambdabot> System :: module
15:28:32 <lambdabot> System.Win32.Info.SystemColor :: type SystemColor
15:30:14 <gwern> I've been wondering about the infix syntax stuff. if you have a period between two strings foo.bar, how does the compiler figure out whether this is function application without any spaces, or using a function from a qualified import?
15:30:40 <unk_red> plugins is still failing to build for me. it fails on the configure step when it checks the C compiler. it tries to compile conftest.c which somehow has | ^[[?1034h" in the middle of its source.
15:30:59 <RyanT5001> gwern: modules are always uppercase; function identifiers are always lowercase
15:31:05 <Mitar> how could i make an instance of Show for this transformed monad, which would just ignore Reader and use Error show?
15:31:31 <RyanT5001> gwern: although i suppose if you had a constructor that took at least one variable, named Foo, and you had a module named Foo, this could be ambiguous
15:32:16 <gwern> RyanT5001: ah. that makes sense. too bad the standard didn't simply say someting like infix operators must have some whitespace between the arguments
15:32:53 <unk_red> seems like someone on #haskell had the same problem http://ircarchive.info/haskell/2007/4/16/20.html
15:32:53 <lambdabot> Title: haskell lol my family left that place many years ago, thank you eh? igli: and la ...
15:32:59 <resiak> @pl \x -> f x >> g x
15:32:59 <lambdabot> liftM2 (>>) f g
15:33:01 <ddarius> Mitar: Usually it doesn't make much sense to make a monad an instance of show.  At any rate, what are you going to provide for the environment, you have a function r -> Either e a,.
15:33:12 <RyanT5001> gwern: that would make some stuff uglier, e.g. arithmetic
15:33:24 <RyanT5001> gwern: although i'll agree that the current system is also lame
15:33:43 <resiak> @pl \x y -> f x y >> g x y
15:33:43 <lambdabot> ap (ap . ((>>) .) . f) g
15:34:12 <Mitar> hmm, maybe i will have to ask it his way: i had a so-so working code which used Error monad to report errors while doing semantic analysis
15:34:25 <Mitar> I had a Show instanced this, so that errors were nicely formated
15:35:06 <gwern> RyanT5001: 2 + 2 is uglier than 2+2? at least then people can
15:35:06 <Mitar> but I had to pass variable environment as a parameter all the time in a type checking function (which was returning this Error I am talking about)
15:35:10 <gwern> t abuse it to do stuff like foo.bar.baz.quux 1*2/3+1
15:35:24 <Mitar> so I thought I could wrap this passing of a environment into a monad
15:35:31 <gwern> and have stuff that looks like "foo-bar ="
15:35:37 <davidm123> any recommendations on reducing executable file size? "module Main where main = return 1" compiles to 3MB under ghc.
15:35:43 <Mitar> and now i am trying to do this and learn how to do this but not really successfully
15:36:22 <wli> davidm123: That shouldn't even typecheck.
15:36:24 <gwern> davidm123: strip it first
15:36:25 <Mitar> so I would like to use some monad instead of passing a value in a function parameter
15:36:39 <allbery_b> wli: it does in ghc, as an extension
15:36:44 <wli> davidm123: Also split-objs etc.
15:36:47 <davidm123> gwern: now it's 1.5 GB.  thats improvement :)
15:36:50 <davidm123> 1.5 MB
15:36:51 <Mitar> but whatever the function returns (it is returning the Error monad) I would like to show it ...
15:36:55 <gwern> explicitly exporting nothing except main might help, and gzexe/upx/other-program-compressors do wonders on haskell binaries
15:36:57 <Mitar> to be able to show it
15:37:06 <bakert_> ?src lookup
15:37:06 <lambdabot> lookup _key []          =  Nothing
15:37:06 <lambdabot> lookup  key ((x,y):xys) | key == x  = Just y
15:37:06 <lambdabot>                         | otherwise = lookup key xys
15:37:16 <bakert_> is there a lookup with default?
15:37:22 <gwern> davidm123: I've also seen slight size decreases when compiling -fvia-c and passing the -Os option to gcc
15:37:25 <johnnowak> david_koontz: it compiles to 391K here
15:37:40 <wli> How's split-objs etc. work?
15:37:41 <david_koontz> johnnowak: ?
15:37:56 <johnnowak> david_koontz: no idea why
15:38:10 <ddarius> You can show the errors fine.  You just have to execute the calculation first or do it with the calculation.
15:38:11 <david_koontz> johnnowak: I think you mean davidm123
15:38:15 <allbery_b> ghc version?
15:38:16 <gwern> davidm123: you can get good decrases. today I was compiling a little shell using the GHC API which start off as 17MB; strip took off a meg or two, and then upx got it all the way down to 2.5
15:38:21 <johnnowak> david_koontz: ah! i do. sorry
15:38:38 <allbery_b> bakert_: compose with maybe
15:38:47 <allbery_b> @src maybe
15:38:47 <lambdabot> maybe n _ Nothing  = n
15:38:47 <lambdabot> maybe _ f (Just x) = f x
15:38:57 <gwern> johnnowak: how is that possible? I thought the ghc RTS alone was like 500kb
15:39:07 <allbery_b> maybe default id $ lookup ...
15:39:08 <wli> I get 232K
15:39:30 <jimstutt> :t forall b. T -> (forall a. (T a) => a -> b) -> b
15:39:31 <lambdabot> parse error on input `=>'
15:39:35 <johnnowak> gwern: no idea... i'm on OS X if it matters
15:39:38 <johnnowak> 6.8.1
15:39:59 <davidm123> gwern: I get unrecognized option for -Os.  -O2 works though.  this is ghc/ubuntu
15:40:28 <davidm123> ghc -O2 -fvia-c  --make 4.hs -o 4
15:40:33 <wli> -dynamic would also help
15:40:35 <davidm123> strip 4
15:40:58 <gwern> davidm123: well as I said, it's for GCC, not GHC. you can have GHC generate C code which GCC then compiles, and GCC has an option for optimizing for small code size
15:41:23 <monochrom> look for -optc or something
15:41:24 <gwern> wli: what does -dynamic do?
15:42:12 <wli> Uses dynamic libraries.
15:42:25 <davidm123> thanks all.  will be back in approx 30 min
15:42:29 <allbery_b> it should be doing that by default
15:42:44 <allbery_b> (except for haskell runtime libs, which aren't available as shlibs)
15:42:47 <wli> Not with Haskell libraries.
15:43:11 <wli> -dynamic is for Haskell libraries.
15:43:36 <allbery_b> last I heard you coudn't build dynamic Haskell libs
15:43:49 <wli> Not on most platforms.
15:43:55 <wli> It's limited to MacOS X.
15:44:07 <gwern> yeah... -dynamic doesn't work here on amd64
15:45:15 <dons> ?users
15:45:15 <lambdabot> Maximum users seen in #haskell: 436, currently: 420 (96.3%), active: 20 (4.8%)
15:46:58 <jimstutt> :t let x = instance x :: forall b. T -> (forall a. (T a) => a -> b) -> b
15:46:58 <lambdabot> parse error on input `instance'
15:47:28 <jimstutt> ?instance
15:47:28 <lambdabot> Maybe you meant: instances instances-importing
15:47:49 <jimstutt> ?instances-importing
15:47:49 <lambdabot> Plugin `instances' failed with: Prelude.last: empty list
15:49:24 <unk_red> dons: that problem i had with plugins not building is something you've seen before. http://ircarchive.info/haskell/2007/4/16/22.html something about ghc outputing some extra wierd characters when figuring TOP out.
15:49:25 <lambdabot> Title: haskell /bin/sh: ghc -e '' | hexdump: command not found ? dunno why /exec got it ...
15:50:26 <wellwisher> how do i determine when i am done reading input? i.e. eof?
15:50:44 <wellwisher> sdf
15:51:06 <dons> unk_red: i think you can just edit the configure script then
15:53:39 <dufflebunk> wellwisher: input from what, a file or stdin?
15:53:57 <wellwisher> user input, std in
15:54:56 <dufflebunk> Usually an EOF then
15:55:59 <dufflebunk> or a read that returns 0 chars in C as well.
15:57:47 <porges> @src (,) fmap
15:57:47 <lambdabot> fmap f (x,y) = (x, f y)
15:57:54 <porges> does anyone know the reasoning behind that?
15:58:03 <porges> why isn't it (f x, f y)
15:58:11 <jimstutt> bakert: newb managed to build and install hsql-1.17, hsql-mysql-1.17, haskelldb-0.10 with ghc-6.8.1 but not HDBC.
15:58:51 <bakert_> jimstutt: i've used haskell with postgres before, but i was just wondering if other people preferred other approaches.
15:59:25 <bakert_> i don't see much mention of sql dbs on this channel, for example, and HAppS does something crazee to do with serializing haskell data.
16:00:07 <bakert_> plus lambdabot seems to store text representations of lists of (String, Int) pairs in it's karma module
16:00:24 <dons> people use haskell serialisation for haskell data, or some larger projects use the various db bindings
16:00:30 <jimstutt> bakert: too new to comment but somebody said haskellers (cos academic?) use flat files. IIUC haskelldb has all search distinct and some lack of joins. HDBC was recommended.
16:00:31 <bakert_> using read and show i suppose
16:00:32 <dons> sqlite3, hdbc, haskelldb, etc
16:00:40 <LoganCapaldo> porges: think about teh types
16:00:43 <dons> bakert_: using Data.Binary and GZip
16:00:46 <LoganCapaldo> @type (,)
16:00:47 <lambdabot> forall a b. a -> b -> (a, b)
16:00:51 <allbery_b> databases are not a win for small amounts of data
16:01:07 <LoganCapaldo> you can't have an f :: (a or b) -> c
16:01:20 <Nafai> It's hard to read about monads when I have a bad headache
16:01:40 <bakert_> allbery_b: i'm going to be storing information on football matches going back 5 years or more so maybe i will push on with mysql
16:01:41 <jimstutt> allbery_b: webservers need db speed and functions.
16:01:49 <allbery_b> 300 rows total, not really worth it.  3000, maybe.  30000, consider something like sleepycat db.  300,000, think mysql etc.
16:02:18 <allbery_b> sqlite is in the same space as sleepycat because it's fairly light
16:02:24 <bakert_> i looked at sleepycat.
16:02:59 <bakert_> but weirdly enough i've spent so much time with sql that i think that would in some strange way be harder to use
16:03:01 <bakert_> :)
16:03:05 <LoganCapaldo> porges: so if fmap for pairs was fmap f (a, b) = (f a, f b) it would mean that only (a, a) could be a functor
16:03:42 <allbery_b> so, sqlite3
16:04:24 <porges> ah
16:04:45 <bakert_> allbery_b: could be
16:04:52 <porges> thanks Logan
16:05:31 * allbery_b has nothing against RDBMSes in general, and in fact used to be a DBA.  but they're often used when they aren't needed
16:05:57 <allbery_b> now, it mightbe that some canned web server inbtegration thing will force you into mysql or etc.
16:06:06 <ddarius> class Bifunctor f where bimap :: (a -> b) -> (c -> d) -> f a b -> f c d
16:06:07 <porges> so now I need a type for pairs (a,a)
16:06:45 <bakert_> this is pretty much my own baby ... it will need to interface with IRC and the web and possibly mediawiki (!) at some stage.  i'm using dons' irc tutorial as the basis of the first interface
16:06:55 <ddarius> In most cases the data is given and already in some format so you just use whatever is being used.
16:06:59 <allbery_b> but that comes at a performance cost which is usually excessive unless you're manipulating 50,000 rows or more
16:07:21 <wli> allbery_b: They're more often not used when they are needed.
16:17:42 <noecksit> how may i be able to import a file and use functions that have the same name as some in the prelude?
16:17:51 <noecksit> is function overloading possible?
16:18:20 <noecksit> maybe i could specify like in my_module.function 1 2 or smthing?
16:18:34 <gwern> import foo as bar; bar.repeatedname?
16:18:46 <allbery_b> import qualified
16:18:55 <noecksit>  how about in ghci?
16:21:24 <noecksit> does anyone have any idea?
16:23:44 <noecksit> hello, im back smthing timed out?
16:23:51 <tphyahoo-haskell> in 6.8.1, Prelude> :b Data.Maybe
16:23:51 <tphyahoo-haskell> module 'Data.Maybe' is not interpreted
16:23:59 <tphyahoo-haskell> in 6.6.1 this works fine.
16:24:11 <tphyahoo-haskell> anyone else have this problem? anyone know why?\
16:24:12 <daniel_larsson> tphyahoo-haskell: use :browse
16:24:24 <daniel_larsson> :b means :breakpoint in 6.8.1
16:24:30 <noecksit> could anyone know how i can overload functions using the interpeter ghci?
16:24:52 <tphyahoo-haskell> ah.
16:27:10 <allbery_b> noeksit: see section 3.4.3.1 of the ghc manual
16:27:22 <allbery_b> (summary:  just use the qualified name)
16:31:32 <wellwisher> i think i found a bug in ghci
16:32:03 <allbery_b> ?
16:32:27 <wellwisher> a 3 is being read as a g
16:34:08 <allbery_b> that sounds ... odd
16:36:25 <LoganCapaldo> @let g = "bug" in 3
16:36:25 <lambdabot>  Parse error
16:36:34 <LoganCapaldo> > let g = "bug" in 3
16:36:34 <lambdabot>  3
16:36:44 <LoganCapaldo> drat
16:37:01 <LoganCapaldo> fromInteger 3 = "g" ?
16:37:18 <allbery_b> show us what you're doing?
16:37:21 <allbery_b> @paste
16:37:21 <lambdabot> Haskell pastebin: http://hpaste.org/new
16:38:52 <wellwisher> actually it probably is a bug in cmd.exe
16:39:27 <LoganCapaldo> that still seems odd
16:39:43 <xpika> To get StateT to work with GTK events do I have to wrap it in an IORef?
16:40:09 <allbery_b> yes
16:44:37 <allbery_b> xpika: see http://hpaste.org/3137
16:46:11 <allbery_b> ...and mutable state in MWPState lives in an IORef, hence askr / setr
16:48:43 <allbery_b> s/an IORef/IORefs
16:54:31 <davidL> I'm trying to make a datatype, which has a single constructor consisting of six Word8's, an instance of Show, however I am confused as to what I put in the second parameter of showsPrec.
16:54:50 <darrint> @hoogle runStateT
16:54:50 <lambdabot> Control.Monad.State.runStateT :: StateT s m a -> (s -> m (a, s))
16:56:27 <LoganCapaldo> davidL: be lazy. derive Show. <g>
16:56:54 <davidL> But I want the output to be different
16:56:56 <dons> davidL: you leave off the second argument
16:56:56 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
16:57:04 <dons> since showsPrec is a function
16:57:53 <davidL> so I can do showsPrec = convertFooToShowS ?
16:57:55 <hpaste>  Japsu pasted "Applying IRC-style corrections ("foobar" "*baz")" at http://hpaste.org/4203
17:01:55 <Japsu> *Correction> "applicarions of linear algebra" `correct` "tion"
17:01:55 <Japsu> "applications of linear algebra"
17:01:57 <nornagon> Hmph, I can't get hssdl to compile :(
17:02:07 <nornagon> Configuring SDL-0.5.1...
17:02:07 <nornagon> configure: error: cannot find sources (includes/HsSDLConfig.h.in) in . or ..
17:03:48 <hpaste>  wellwisher pasted "A wierd bug" at http://hpaste.org/4204
17:04:02 <nornagon> hm
17:04:07 * nornagon grabs the darcs hssdl
17:04:12 <wellwisher> that explains how to get the 3 to g bug
17:04:15 <hgolden> Hi. Can someone point me to a discussion of how to deal with writing code that is tolerant of library version changes (or updating code to handle being compiled with different library versions)? I'm just learning Haskell and I want to see about fixing the code that GHC 6.8.1 won't compile any more.
17:04:54 <wellwisher> join the ghc mailing list?
17:05:23 <Japsu> hmm
17:05:38 <Japsu> should I perhaps write a QWERTY distance function for that
17:05:52 <wellwisher> and the reason why the code deosn't compile is because you must specify the extensions you are using
17:06:07 <nornagon> Japsu: write a dvorak one too! :)
17:06:34 <Japsu> distance 's' 's' == 0, distance 's' 'd' == 11, distace 's' 'f' == 12 etc
17:06:46 <Japsu> need some basic penalty for inequality, used 10 here
17:06:55 <Japsu> but hmm
17:07:10 <Japsu> currently the Correction module cannot change the length of the input
17:07:33 <Japsu> that is, it always changes at least as many characters as "length correction"
17:07:52 <nornagon> that seems annoying
17:08:07 <Japsu> so can't do "exampfle" `correct` "mple" -> "example"
17:08:27 <Japsu> though adding support for that would greatly increase the complexity
17:08:31 <Cale> wellwisher: I can't reproduce it under linux.
17:08:51 <Cale> wellwisher: I'm willing to bet that it has something to do with windows' terminal emulator.
17:09:19 <Cale> But that is rather strange.
17:10:24 <Japsu> Hmm
17:10:31 <hgolden> wellwisher: I'm trying to recompile Gentoo packages under GHC 6.8.1 that compiled correctly under GHC 6.6.1. I want to fix packages to compile under both. Not sure of the Haskell "Way" to do this (for example, use C preprocessor macros?).
17:10:43 <allbery_b> does it show up correctly in the terminal emulator when you paste it?
17:10:57 <Japsu> Suppose I wanted to hack my copy of Lambdabot to use that correction module of mine every time someone says something like "*mple" on a channel
17:11:02 <Japsu> Where would I start?
17:11:17 <Japsu> I'd need to keep a backlog of, say, twenty lines and their respective nicks
17:11:39 <Cale> hgolden: which packages?
17:12:22 <Cale> hgolden: I remember seeing some tricks to getting cabal packages to work with both the pre-split and post-split library packages.
17:12:50 <allbery_b> you need a newer Cabal so you can use the flags mechanism
17:14:19 <wellwisher> i think that bug lies in the encoding used in notepade
17:14:39 <allbery_b> @wiki Upgrading_packages
17:14:39 <lambdabot> http://www.haskell.org/haskellwiki/Upgrading_packages
17:15:02 <allbery_b> ^^ hgolden: how to use cabal to be compatible with mutiple ghc versions
17:15:10 <Cale> wellwisher: Yeah, I recommend against using notepad as an editor for editing Haskell source, since iirc, it can't convert tabs to spaces automatically for you and has no support for syntax colouring
17:15:13 <Japsu> hmm
17:15:35 <allbery_b> and it has some known encoding glitches, although that would be a peculiar way to show it (still possible though)
17:15:37 <Japsu> Wonder if my distance function there (http://hpaste.org/4203) equivalent to Levenshtein distance
17:16:05 <hgolden> allbery_b: Thanks!
17:16:23 <Japsu> The example (imperative) implementation of LD in Wikipedia looks... hairier
17:17:10 <Japsu> Meh, too tired to think. Perhaps I should just implement that, too, in Haskell and then quickCheck them for equality.
17:17:17 <Japsu> *equivalence
17:18:12 <Japsu> hmm
17:18:20 <Japsu> Jaro-Winkler distance... let's implement that
17:20:03 <Japsu> Oh. Mine's basically Hamming distance that takes into account the possibility of differing lengths.
17:20:27 <skew> does anyone here know if lazy and call-by-value are really that different for control flow analysis?
17:21:00 <nornagon> what's the difference between Hamming distance and Levenshtein distance?
17:21:13 <allbery_b> er?  call-by-value is strict by defiinition, no?
17:21:24 <skew> call-by-name, I mean
17:21:43 <Japsu> nornagon: As I understand it, Levenshtein("foozbar", "foobar") = 1 as Hamming("foozbar", "foobar") = 4
17:21:59 <nornagon> ah.
17:22:14 <Japsu> Not sure, though.
17:22:19 <nornagon> wikipedia seems to say that Hamming distance only works for equal-length strings?
17:22:23 <Cale> um, isn't the Hamming distance generally undefined for strings of differing length?
17:22:39 <Japsu> Yeah well, mine's Hamming extended for strings of differing length ;)
17:22:42 <Japsu>  03:20   Japsu : Oh. Mine's basically Hamming distance that takes into account the possibility of differing lengths.
17:22:55 <Japsu> so s/Hamming/ModifiedHamming/ in that example
17:23:04 <gwern> > :type (<+>)
17:23:04 <lambdabot>  Parse error at "type" (column 2)
17:23:06 <nornagon> Japsu: that makes it levenshtein, doesn't it? >.>
17:23:10 <Cale> So how do you modify it?
17:23:10 <nornagon> :t (<+>)
17:23:11 <lambdabot>     Ambiguous occurrence `<+>'
17:23:11 <lambdabot>     It could refer to either `<+>', imported from Control.Arrow
17:23:11 <lambdabot>                           or `<+>', imported from Text.PrettyPrint.HughesPJ
17:23:14 <gwern> :type (<+>)
17:23:21 <Japsu> nornagon: No. The example still holds
17:23:25 <nornagon> :t Control.Arrow.(<+>)
17:23:26 <lambdabot> Couldn't find qualified module.
17:23:38 <Japsu> Levenshtein("foozbar", "foobar") = 1, ModifiedHamming("foozbar", "foobar") = 4.
17:23:50 <nornagon> (<+>) :: (ArrowPlus a) => a b c -> a b c -> a b c
17:24:05 <Japsu> The point here is that you can get from "foobar" to "foozbar" by doing one edit, namely adding "z" in the middle
17:24:16 <allbery_b> :t (Control.Arrow.<+>)
17:24:16 <lambdabot> forall (a :: * -> * -> *) b c. (ArrowPlus a) => a b c -> a b c -> a b c
17:24:17 <Japsu> which is what I understand Levenshtein to measure
17:24:44 <Cale> Japsu: How did you modify the Hamming distance to do that?
17:24:46 <Japsu> but Modified Hamming just counts differing bytes + length difference
17:25:06 <Japsu> http://hpaste.org/4203 <-- see the definition of "distance" there
17:25:06 <Cale> ah
17:25:30 <nornagon> @help ask
17:25:30 <lambdabot> ask <nick> <message>. When <nick> shows activity, ask them <message>.
17:25:45 <nornagon> @ask lemmih what happened to your SDL_gfxPrimitives binding? :(
17:25:46 <lambdabot> Consider it noted.
17:25:59 <Japsu> hmm
17:26:14 <Japsu> Wonder if correct completely blows up if I try using a corr longer than orig.
17:26:27 <Japsu> "*** Exception: Prelude.minimum: empty list
17:26:29 <Japsu> youp.
17:26:30 <Japsu> *yup
17:26:54 <Japsu> *Correction> "youp" `correct` "yup"
17:26:54 <Japsu> "yyup"
17:26:55 <Japsu> ;)
17:29:12 <hpaste>  davidL pasted "need help with making an instance of Show" at http://hpaste.org/4205
17:29:14 <xpik1> @type lift
17:29:14 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
17:29:17 <nornagon> Why is there no clear doc link on the haskell.org front page? :(
17:29:35 <xpik1> so does lift only work for functions with an arity of one?
17:29:43 <Japsu> @type lift3
17:29:44 <lambdabot> Not in scope: `lift3'
17:29:45 <Japsu> :<
17:29:54 <nornagon> oh, nevermind, i guess i have to go to the ghc page
17:30:07 <davidL> nornagon: there is, on the side
17:30:09 <nornagon> @src lift
17:30:10 <lambdabot> Source not found.
17:30:16 <skew> nornagon: which docs, and what do you want it to look like?
17:30:27 <nornagon> the ghc library docs
17:30:28 <nornagon> ;P
17:30:29 <skew> "Standard Libraries" links straight to the ghc library docs
17:30:30 <allbery_b> davidL: you forgot an argument
17:30:37 <Japsu> nornagon: There's a link to the language definition, which is the only impartial documentation ;)
17:30:44 <allbery_b> so MacAddress is partially applied and waiting for an additional Word8
17:30:47 <Japsu> nornagon: The real docs you want are those of the GHC library
17:31:07 <davidL> allbery_b: ah, let me try again
17:31:11 <Japsu> nornagon: but if haskell.org linked that directly to those, it'd be endorsing one implementation over the others ;)
17:31:28 <davidL> allbery_b: gah, thank you so much (I feel like an idiot)
17:31:37 <allbery_b> (it wants 6 Word8s, you passed it 5, ghci resonably doesn't know how to show a function
17:31:40 <skew> but implementations could list "GHC (Docs)"
17:32:35 <allbery_b> enh.  the error message is a bit opaque (but follows from partial application)
17:32:42 <davidL> my user input was the last thing I would have checked :-\
17:33:45 <allbery_b> you'll eventually learn to recognize things like Show (Word8 -> MacAddress) as meaning "missing parameter"
17:34:11 <allbery_b> that basically says it wants to display a function from Word8 to MacAddress
17:34:52 <allbery_b> given that MacAddress takes 6 Word8 arguments, the first place to look is to make sure it got 6 arguments :)
17:35:12 <davidL> :-)
17:40:36 <Beelsebob> argh, why can't I do integration any more
17:41:42 <chessguy> have you been drinking?
17:41:46 <Beelsebob> no
17:41:52 <Beelsebob> just haven't done this for years
17:41:56 <chessguy> oh wait, never mind. it's drinking and deriving that you can't do
17:42:00 <Beelsebob> and now even the most simple stuff is eluding me
17:42:06 <chessguy> *rimshot*
17:42:11 <Beelsebob> :P
17:42:28 <Japsu> bah, integration
17:42:33 <Japsu> that's what Mathematica is for
17:42:36 <Japsu> or Maple
17:42:45 <Japsu> or even Maxima
17:42:51 <chessguy> % Integrate [x, x]
17:42:56 <Beelsebob> I'm trying to find a formula for the sequence 3,6,10,15,21,28,36... which is obviously quadratic... I just can't remember how to gain the formula from the data points
17:43:04 <Japsu> integrate(x, x);
17:43:21 <chessguy> hm. i guess LB doesn't have the mbot module installed
17:43:23 <Japsu> Least mean squares!
17:43:43 <Beelsebob> least mean squares?
17:43:48 <Japsu> yeah
17:43:53 <Japsu> that ain't pretty but it works
17:43:54 <Japsu> ;)
17:43:56 <chessguy> @go wikipedia least mean squares
17:43:57 <lambdabot> http://en.wikipedia.org/wiki/Least_mean_squares_filter
17:43:57 <lambdabot> Title: Least mean squares filter - Wikipedia, the free encyclopedia
17:44:01 <Japsu> no, not that
17:44:26 <Japsu> in octave/matlab you can do A \ y where A is a matrix and y is a vector
17:44:39 <Japsu> and it gives you a least mean squares solution to Ax = y
17:45:11 <allbery_b> @go quadratic curve fitting
17:45:12 <lambdabot> http://www.math.duke.edu/education/ccp/materials/linalg/curvefit/curvfit1.html
17:45:12 <lambdabot> Title: Curve Fitting, Part 1
17:45:15 <allbery_b> hm
17:45:19 <Japsu> Now suppose y = [3,5,10,15,21,28,36]'
17:45:30 <Beelsebob> s/5/6/
17:45:32 <Japsu> and n = [1,2,3,4,5,6,7]
17:45:43 <Japsu> Now you have a basic formula of some sorts, for which you need the constants
17:46:05 <Beelsebob> see... there should be a way of doing this by integration
17:46:08 <Japsu> say, (a * n + b)^2
17:46:19 <EvilTerran> can't you do it by looking at the repeated differences?
17:46:25 <Beelsebob> exactly
17:46:29 <allbery_b> 2,3,4,5,6,...
17:46:37 <Beelsebob> d_x = 3,4,5,6,7...
17:46:40 <allbery_b> yeh
17:46:46 <skew> you also need to look at the difference of the abstract formula
17:46:47 <Beelsebob> so d2_x = 1,1,1,1,1....
17:46:48 * allbery_b counted gaps instead, durr
17:46:56 <Beelsebob> I just can't remember how to get from that to the formula
17:47:01 <EvilTerran> let xs = [3,6,10,15,21,28,36]; ys = zipWith (-) xs (tail xs); zs = zipWith (-) ys (tail ys) in (xs,ys,zs)
17:47:03 <ddarius> Why would you break out integration for a problem that clearly doesn't need it?
17:47:06 <EvilTerran> > let xs = [3,6,10,15,21,28,36]; ys = zipWith (-) xs (tail xs); zs = zipWith (-) ys (tail ys) in (xs,ys,zs)
17:47:08 <lambdabot>  ([3,6,10,15,21,28,36],[-3,-4,-5,-6,-7,-8],[1,1,1,1,1])
17:47:12 <skew> (a(x+1)^2+b(x+1)+c)-(ax^2+bx+c) = ?
17:47:18 <Japsu> Oh, that's cool
17:47:20 <skew> but something not involving c
17:47:30 <EvilTerran> hm. wrong way 'round.
17:47:41 <EvilTerran> > let xs = [3,6,10,15,21,28,36]; ys = zipWith subtract xs (tail xs); zs = zipWith subtract ys (tail ys) in (xs,ys,zs)
17:47:41 <lambdabot>  ([3,6,10,15,21,28,36],[3,4,5,6,7,8],[1,1,1,1,1])
17:47:51 <Beelsebob> EvilTerran: that's what I was trying to do... I'm just can't get from there to the formula
17:48:00 <EvilTerran> > [x^2 + 3 | x <- [0..]]
17:48:00 <lambdabot>  [3,4,7,12,19,28,39,52,67,84,103,124,147,172,199,228,259,292,327,364,403,444,...
17:48:04 <skew> Beelsebob: how about the stuff I wrote?
17:48:04 <Japsu> Oops
17:48:05 <EvilTerran> wait
17:48:18 <Japsu> my way wouldn't work
17:48:22 <Beelsebob> skew: sorry, I'm missing how it relates
17:48:22 <Japsu> at least not that straight-forward
17:48:30 <EvilTerran> there'll be an algorithm on t'internets somewhere
17:48:32 <wli> @pl \xs -> zipWith (-) xs (tail xs)
17:48:32 <lambdabot> ap (zipWith (-)) tail
17:48:34 <skew> Beelsebob: you are assuming there is a quadradic
17:48:40 <Beelsebob> they are
17:48:44 <Beelsebob> the differences say they are
17:49:01 <Japsu> but fitting ax^2+bx+c would go just like that
17:49:03 <wli> I'd think you'd want
17:49:12 <wli> @pl \xs -> zipWith (-) (tail xs) xs
17:49:12 <lambdabot> zipWith (-) =<< tail
17:49:19 <skew> so [3,6,10,...] = [A*0^2+B*0+C,A*1^2+B*1+C,A*2^2+B*2+C... for some constants
17:49:23 <Beelsebob> EvilTerran: the differences are gradients, so surely it should just be integration
17:49:27 <Japsu> N = [n.^2 n ones(length(n),1)]; b = N \ y and you have the coefficients in b
17:49:32 <EvilTerran> mhh
17:49:45 <Beelsebob> so at the base it's constant 1
17:49:56 <EvilTerran> kinda, yeah. very limited form of integration, but yeah.
17:50:12 <Beelsebob> so to generate 3,4... it's x + c
17:50:13 <allbery_b> > [x^2 + 1 | x < [1..]]
17:50:13 <lambdabot>   Not in scope: `x'
17:50:15 <Beelsebob> so c == 2
17:50:18 <allbery_b> > [x^2 + 1 | x <- [1..]]
17:50:18 <lambdabot>  [2,5,10,17,26,37,50,65,82,101,122,145,170,197,226,257,290,325,362,401,442,48...
17:50:21 <allbery_b> durr
17:50:29 <Beelsebob> so the next one up must be x^2 / 2 + x + c
17:50:29 <allbery_b> > [x^2 + 2 | x <- [1..]]
17:50:30 <lambdabot>  [3,6,11,18,27,38,51,66,83,102,123,146,171,198,227,258,291,326,363,402,443,48...
17:50:40 <allbery_b> nope
17:50:41 <wli> iterate (zipWith (-) =<< tail) maybe scaled by some factorial gives you coefficients of the Newton series.
17:50:46 <skew> Beelsebob: so subtract adjacent things once and the formulas turn into (ax^2+(a+b)), as x increases
17:51:08 <Beelsebob> > [x ^ 2 / 2 + x | x <- [1..]]
17:51:09 <lambdabot>  [1.5,4.0,7.5,12.0,17.5,24.0,31.5,40.0,49.5,60.0,71.5,84.0,97.5,112.0,127.5,1...
17:51:14 <Japsu> [x^2 `div` 2 + x | x <- [1..]]
17:51:18 <Japsu> > [x^2 `div` 2 + x | x <- [1..]]
17:51:19 <lambdabot>  [1,4,7,12,17,24,31,40,49,60,71,84,97,112,127,144,161,180,199,220,241,264,287...
17:51:23 <skew> subtract adjacent numbers/formulas again, and the formulas are all 2*a, and hopefully the numbers all constant
17:52:02 <noobie> how can some1 be unbanned?
17:52:23 <Zao> noobie: By not being a moron, repenting and waiting for a while.
17:52:30 <Beelsebob> > [x ^ 2 / 2 + x / 2 | x <- [1..]]
17:52:31 <lambdabot>  [1.0,3.0,6.0,10.0,15.0,21.0,28.0,36.0,45.0,55.0,66.0,78.0,91.0,105.0,120.0,1...
17:52:50 <noobie> well its been 4 months
17:53:25 <noobie> my friend msses it here
17:53:27 <Beelsebob> > [(x-1)^2 / 2 + x / 2 + 0.5 | x <- [1..]]
17:53:27 <lambdabot>  [1.0,2.0,4.0,7.0,11.0,16.0,22.0,29.0,37.0,46.0,56.0,67.0,79.0,92.0,106.0,121...
17:53:48 <Beelsebob> > [(x-1)^2 / 2 + x / 2 - 0.5 | x <- [1..]]
17:53:48 <lambdabot>  [0.0,1.0,3.0,6.0,10.0,15.0,21.0,28.0,36.0,45.0,55.0,66.0,78.0,91.0,105.0,120...
17:53:54 <jsnx> noobie: what did your friend do?
17:53:59 <Beelsebob> > [(x+1)^2 / 2 + x / 2 + 0.5 | x <- [1..]]
17:54:00 <lambdabot>  [3.0,6.0,10.0,15.0,21.0,28.0,36.0,45.0,55.0,66.0,78.0,91.0,105.0,120.0,136.0...
17:54:03 <Beelsebob> woot
17:54:05 <Beelsebob> we have a winner
17:54:34 <jsnx> Beelsebob: what are you trying to do again?
17:54:58 <Beelsebob> jsnx: fine a formula to computer the series [3,6,10,15,21,28,36,...]
17:55:16 <allbery_b> feed it to OEIS? :_
17:55:18 <allbery_b> :)
17:55:30 <ddarius> @oeis 3 6 10 15 21 28
17:55:30 <lambdabot> Triangular numbers: a(n) = C(n+1,2) = n(n+1)/2 = 0+1+2+...+n.
17:55:30 <lambdabot> [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,27...
17:55:43 <Beelsebob> of course they are
17:55:48 <Beelsebob> I knew they looked familiar
17:55:56 <chessguy> @help oeis
17:55:56 <lambdabot> oeis <sequence>. Look up a sequence in the Online Encyclopedia of Integer Sequences
17:56:00 <marceau> > scanl (+) 1 [2..10]
17:56:01 <lambdabot>  [1,3,6,10,15,21,28,36,45,55]
17:56:14 <Beelsebob> now... why the fuck are they appearing
17:56:17 <Porges> oeis [1,5,8,9]
17:56:21 <Porges> @oeis [1,5,8,9]
17:56:21 <lambdabot> Sequence not found. :(
17:56:33 <Porges> @oeis 1 5 8 9
17:56:33 <lambdabot> Triangle of partition numbers: T(n,k) = number of partitions of n in which th...
17:56:33 <lambdabot> [1,1,1,1,1,1,1,2,1,1,1,2,2,1,1,1,3,3,2,1,1,1,3,4,3,2,1,1,1,4,5,5,3,2,1,1,1,4,...
17:56:48 <marceau> the sum of the first n integers is given by n (n+1) /2
17:56:52 <Beelsebob> > map (1/) (scanl (+) 1 [2..10])
17:56:52 <lambdabot>  [1.0,0.3333333333333333,0.16666666666666666,0.1,6.666666666666667e-2,4.76190...
17:56:58 <newsham> @oeis [1,4,1,5,9,2]
17:56:58 <lambdabot> Sequence not found. Just try something else.
17:57:18 <Beelsebob> > map (1/) (scanl (+) 1 [3..10])
17:57:19 <lambdabot>  [1.0,0.25,0.125,7.692307692307693e-2,5.263157894736842e-2,3.8461538461538464...
17:57:19 <allbery_b> it's a sequence, not a list
17:57:48 <EvilTerran> @help oeis
17:57:48 <lambdabot> oeis <sequence>. Look up a sequence in the Online Encyclopedia of Integer Sequences
17:57:55 <Porges> @let f `over` g = curry $ uncurry f <<< g *** g
17:57:56 <lambdabot> Defined.
17:58:00 <Porges> @src over
17:58:00 <lambdabot> Source not found. The more you drive -- the dumber you get.
17:58:18 <ddarius> @. oeis run scanl (+) 1 [2..10]
17:58:18 <lambdabot> Sequence not found. My brain just exploded
17:58:34 <Beelsebob> > map (1/) $ tail $ scanl (+) 1 [2..10]
17:58:35 <lambdabot>  [0.3333333333333333,0.16666666666666666,0.1,6.666666666666667e-2,4.761904761...
17:58:39 <ddarius> @oeis "1 3 6 10"
17:58:40 <lambdabot> Triangular numbers: a(n) = C(n+1,2) = n(n+1)/2 = 0+1+2+...+n.
17:58:40 <lambdabot> [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,27...
17:59:07 <ddarius> @. oeis run concatMap (\x -> show x++" ") $ scanl (+) 1 [2..10]
17:59:08 <lambdabot> Triangular numbers: a(n) = C(n+1,2) = n(n+1)/2 = 0+1+2+...+n.
17:59:08 <lambdabot> [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,27...
17:59:22 <EvilTerran> groovy
17:59:35 <Japsu> hmm
17:59:42 <noobie> e bother llambdabot
17:59:42 <Porges> @oeis 1 3 5 7 9 10
17:59:43 <lambdabot> Table T(n,k) = |n-k| read by antidiagonals (n >= 0, k >= 0).
17:59:43 <lambdabot> [0,1,1,2,0,2,3,1,1,3,4,2,0,2,4,5,3,1,1,3,5,6,4,2,0,2,4,6,7,5,3,1,1,3,5,7,8,6,...
17:59:53 <chessguy> > concatMap (\x -> show x++" ") $ scanl (+) 1 [2..10]
17:59:53 <lambdabot>  "1 3 6 10 15 21 28 36 45 55 "
17:59:54 <Beelsebob> > 3: map ((3+) . (1/)) $ tail $ scanl (+) 1 [2..10]
17:59:55 <lambdabot>  Couldn't match expected type `[t]'
18:00:07 <Porges> <3 lambdabot
18:00:18 <Japsu> If I defined, say, (\\) as my string correction operator, which level would I make it? Below or above (++)?
18:00:25 <chessguy> LB is ridiculous
18:00:25 <Japsu> *Correction> "foobar" ++ "hyperion" \\ "baz" \\ "fog"
18:00:25 <Japsu> "fogbazhyperion"
18:00:31 <Beelsebob> > map (\x -> 3+ 1/x) $ tail $ scanl (+) 1 [2..10]
18:00:32 <lambdabot>  [3.3333333333333335,3.1666666666666665,3.1,3.066666666666667,3.0476190476190...
18:00:41 <noobie> s a ban 4 lfe??
18:00:54 <chessguy> @pl \x -> 3+ 1/x
18:00:54 <lambdabot> (3 +) . (1 /)
18:01:02 <Beelsebob> > scanl (*) 2 (3:map (\x -> 3+ 1/x) $ tail $ scanl (+) 1 [2..10])
18:01:02 <ihope> Japsu: string correction operator?
18:01:02 <lambdabot>  Couldn't match expected type `[t]'
18:01:11 <skew> noobie: I'm not sure any ops are here now
18:01:15 <davidL> @. oeis run concatMap (\x -> show x++" ") $ nubBy(((>1).).gcd)[2..]
18:01:16 <lambdabot> Plugin `compose' failed with: Prelude.(!!): index too large
18:01:23 <Beelsebob> > 3:map (\x -> 3+ 1/x) $ tail $ scanl (+) 1 [2..10]
18:01:23 <lambdabot>  Couldn't match expected type `[t]'
18:01:29 <Beelsebob> > 3:(map (\x -> 3+ 1/x) $ tail $ scanl (+) 1 [2..10])
18:01:29 <lambdabot>  [3.0,3.3333333333333335,3.1666666666666665,3.1,3.066666666666667,3.047619047...
18:01:42 <Beelsebob> > scanl (*) 2 (3:(map (\x -> 3+ 1/x) $ tail $ scanl (+) 1 [2..10]))
18:01:43 <lambdabot>  [2.0,6.0,20.0,63.33333333333333,196.33333333333331,602.0888888888888,1834.93...
18:01:50 <Beelsebob> damn it
18:01:54 <Beelsebob> not quite
18:01:58 <Japsu> ihope: http://hpaste.org/4203
18:02:12 <Japsu> *Correction> "foobar" \\ "fog"
18:02:12 <Japsu> "fogbar"
18:02:27 <Japsu> *Correction> "foobar" \\ "baz"
18:02:27 <Japsu> "foobaz"
18:02:51 <ihope> So it finds the longest substring of the left argument that's a prefix of the right argument and replaces accordingly?
18:02:51 <Japsu> that is, "Having orig and corr, find the substring of orig having least distance to corr, and replace it with corr"
18:03:00 <Beelsebob> oh, I see
18:03:12 <ihope> Oh.
18:03:13 <Japsu> No, it uses a distance function to determine which substring to replace
18:03:16 <Beelsebob> > scanl (+) 3 (map (1/) $ tail $ scanl (+) 1 [2..10])
18:03:16 <lambdabot>  [3.0,3.3333333333333335,3.5,3.6,3.666666666666667,3.7142857142857144,3.75,3....
18:03:17 <Japsu> at the moment Modified Hamming
18:03:35 <davidL> @unpl nubBy(((>1).).gcd)[2..]
18:03:35 <lambdabot> nubBy (\ e h -> (gcd e h) > 1) [2 ..]
18:03:45 <Beelsebob> > scanl (*) 2 (scanl (+) 3 (map (1/) $ tail $ scanl (+) 1 [2..10]))
18:03:45 <lambdabot>  [2.0,6.0,20.0,70.0,252.0,924.0000000000001,3432.0000000000005,12870.00000000...
18:03:49 <Japsu> but hmm
18:03:53 <Beelsebob> win :D
18:03:58 <noobie> darn
18:04:09 <skew> So, how do I test an evaluator?
18:04:11 <Japsu> My question was whether to make (\\) bind stronger or weaker than (++)
18:04:13 <Beelsebob> now... the question is... why is that the answer to 15
18:04:21 <Porges> weaker
18:04:32 <Beelsebob> > (scanl (*) 2 (scanl (+) 3 (map (1/) $ tail $ scanl (+) 1 [2..10])))) !! 20
18:04:32 <lambdabot> Unbalanced parentheses
18:04:33 <skew> I don't really trust quickcheck to make large enough terms to validate any equivalences I want
18:04:36 <Beelsebob> > (scanl (*) 2 (scanl (+) 3 (map (1/) $ tail $ scanl (+) 1 [2..10]))) !! 20
18:04:37 <lambdabot>  Exception: Prelude.(!!): index too large
18:04:37 <Japsu> So does "foobar" ++ "hyperion" \\ "fog" == "fogbarhyperion" make sense to you?
18:04:50 <Beelsebob> > (scanl (*) 2 (scanl (+) 3 (map (1/) $ tail $ scanl (+) 1 [2..]))) !! 20
18:04:51 <lambdabot>  5.382578744399993e11
18:04:55 <chessguy> skew, try sparseCheck
18:05:02 <chessguy> @where sparsecheck
18:05:03 <lambdabot> http://www-users.cs.york.ac.uk/~mfn/sparsecheck/
18:05:05 <Beelsebob> > (scanl (*) 2 (scanl (+) 3 (map (1/) $ tail $ scanl (+) 1 [2..]))) !! 19
18:05:05 <lambdabot>  1.3784652881999985e11
18:05:15 <skew> I'm thinking program extraction - not quite sure how to deal with termination, though
18:05:26 <Japsu> Or "foobar" ++ "hyperion" \\ "fog" == "foobarhyperfog"?
18:05:43 <Beelsebob> > ((scanl (*) 2 (scanl (+) 3 (map (1/) $ tail $ scanl (+) 1 [2..]))) !! 19) :: Integer
18:05:43 <lambdabot>   add an instance declaration for (Fractional Integer)
18:05:54 <Beelsebob> oh, bah
18:06:09 <Porges> actually, thinking about it, make it tighter
18:06:13 <Japsu> "foobar" ++ ("hyperion" \\ "fog") vs. ("foobar" ++ "hyperion") \\ "fog"
18:06:21 <Japsu> so "foobar" ++ ("hyperion" \\ "fog")
18:06:22 <Japsu> ?
18:06:27 <Porges> x = something ++ something ++ something \\ replace ++ something ++ something
18:06:32 <Japsu> hmm
18:06:34 <Japsu> that's true
18:06:45 <Japsu> so, infixl 7 \\
18:06:48 <Japsu> or 6
18:06:49 <Japsu> hmm
18:06:51 <Japsu> ++ is5
18:06:54 <Beelsebob> okay... so that worked... but WHY????
18:06:56 <Porges> and you'd want that  ++ (something \\ replace) ++
18:06:58 <Japsu> *is 5
18:07:03 <Japsu> Porges: yep, I agree
18:07:06 <Japsu> good case
18:08:04 <ddarius> @. oeis run concatMap (\x -> show x ++ " ") $ scanl (+) 1 [2..10]
18:08:04 <lambdabot> Triangular numbers: a(n) = C(n+1,2) = n(n+1)/2 = 0+1+2+...+n.
18:08:04 <lambdabot> [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,27...
18:08:34 <davidL> @. oeis run concatMap (\x -> show x++" ") $ take 10 $ nubBy(((>1).).gcd)[2..]
18:08:34 <lambdabot> The prime numbers.
18:08:34 <lambdabot> [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,1...
18:09:44 <ddarius> @pl \x -> show x ++ " " -- (++" ") . show
18:09:44 <lambdabot> (++ " ") . show
18:12:17 <LoganCapaldo> @unpl (++" ").show
18:12:17 <lambdabot> (\ d -> (show d) ++ " ")
18:13:17 <Porges> one thing I've wondered: why is there no shuffle in the default libraries?
18:13:29 <EvilTerran> shuffle?
18:13:54 <Japsu> you mean like randomizing a list?
18:13:56 <SamB> what, like 7 riffles or something?
18:14:05 <Japsu> because thats, like, nontrivial at best ;P
18:14:34 <Porges> nontrivial? these are haskell libraries!
18:14:52 <Japsu> Nontrivial, meaning there might be good reasons to implement it in a number of ways
18:15:06 <Porges> provide them all?
18:15:29 <Porges> or just knuth's
18:15:38 <EvilTerran> RandomGen g => shuffle :: g -> [a] -> [a] --?
18:15:59 <chessguy> shuffleIO :: [a] -> IO [a]
18:16:25 <Japsu> I seem to have a shuffleDeck' :: RandomGen g => g -> [a] -> [a] -> ([a], g)
18:16:28 <Japsu> lying around here
18:16:39 <chessguy> err
18:16:45 <chessguy> why does it take two lists?
18:16:49 <EvilTerran> riffle?
18:16:49 <Japsu> Hmm
18:17:03 <Japsu> To avoid blowing up the stack.
18:17:14 <Japsu> I mean, the other just carries stuff around for tail recursion
18:17:17 <Japsu> hence the '
18:17:25 <Japsu> but where's the non-'...
18:17:31 <Japsu> oh
18:17:32 <Japsu> shuffleDeck :: Cards -> IO Cards
18:17:42 <Japsu> data Card = Card Rank Suit deriving (Show, Read, Eq, Ord, Bounded)
18:17:49 <Japsu> etc.
18:17:52 <chessguy> yeah, that's my shuffleIO
18:17:56 <Japsu> yeah
18:17:59 <Japsu> brrrh, evil
18:18:05 <Japsu> my implementation's O(n^2)
18:18:35 <Japsu> zipping with a list of random numbers and then sorting would be O(n log n), assuming sort is O(n log n)
18:18:46 <Japsu> though Data.List.sort is O(n^2)
18:18:58 <chessguy> really?
18:19:01 <chessguy> that's dumb
18:19:04 <EvilTerran> average-case nlogn, tho, isn't it?
18:19:10 <Japsu> @src sort
18:19:10 <lambdabot> sort = sortBy compare
18:19:12 <EvilTerran> like quicksort
18:19:14 <Japsu> @src sortBy
18:19:14 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
18:19:17 <Japsu> @src insertBy
18:19:17 <lambdabot> insertBy _   x [] = [x]
18:19:17 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
18:19:17 <lambdabot>                                  GT -> y : insertBy cmp x ys'
18:19:17 <lambdabot>                                  _  -> x : ys
18:19:22 <Japsu> looks like insertion sort to me
18:19:23 <ddarius> Didn't they switch to a mergesort?
18:19:29 <Japsu> Did they? :O
18:19:31 <Japsu> cool
18:19:31 <EvilTerran> it does, rather, doesn't it =/
18:19:31 <ddarius> Japsu: That's the standard's specification.
18:19:32 <davidL> I thought it was a shell sort
18:19:44 <LoganCapaldo> meeeeeeergesort
18:19:47 <LoganCapaldo> mmm
18:19:48 <EvilTerran> shell sort is voodoo. i'd be happier with mergesort.
18:20:01 <davidL> I would be too
18:20:03 <chessguy> why not quicksort, since that's the example everyone seems to use anyway
18:20:15 <Japsu> merge sort's stable
18:20:24 <chessguy> bah
18:20:26 <LoganCapaldo> cause quicksort is still O(n^2)
18:20:44 <chessguy> ugh, i don't remember all the runtimes any more
18:20:51 <LoganCapaldo> mergesort is way 1337e
18:20:57 <LoganCapaldo> *1337er
18:21:03 <Japsu> heap sort!
18:21:04 <Japsu> :P
18:21:07 <davidL> LoganCapaldo: that's the worst case
18:21:28 <LoganCapaldo> that's what O means yes
18:22:00 <davidL> the average case is n log n
18:22:12 <EvilTerran> the quicksort that can be implemented in haskell is not the true quicksort ;)
18:22:19 <Japsu> hehe
18:22:36 <davidL> you mean the one liner?
18:22:41 <ddarius> @wiki Introduction/Direct_translation
18:22:41 <lambdabot> http://www.haskell.org/haskellwiki/Introduction/Direct_translation
18:22:45 <EvilTerran> seriously, tho; it only really works efficiently with in-place array shuffling, as i understand it
18:22:59 <ddarius> @wiki Introduction/Direct_Translation
18:22:59 <lambdabot> http://www.haskell.org/haskellwiki/Introduction/Direct_Translation
18:22:59 <Japsu> > let fakeqsort (x:xs) = fakeqsort less ++ [x] ++ fakeqsort more where (less, more) = partition (<= x) xs in fakeqsort [1,7,3,9[
18:22:59 <lambdabot>  Parse error at end of input
18:23:03 <Japsu> > let fakeqsort (x:xs) = fakeqsort less ++ [x] ++ fakeqsort more where (less, more) = partition (<= x) xs in fakeqsort [1,7,3,9]
18:23:04 <lambdabot>   Non-exhaustive patterns in function fakeqsort
18:23:08 <Japsu> bah
18:23:14 <Japsu> > let fakeqsort [] = []; fakeqsort (x:xs) = fakeqsort less ++ [x] ++ fakeqsort more where (less, more) = partition (<= x) xs in fakeqsort [1,7,3,9]
18:23:15 <lambdabot>  [1,3,7,9]
18:23:46 <LoganCapaldo> also trying to do something like "pick a random pivot" makes life difficult
18:24:08 * ddarius randomly picks the first one.
18:24:20 <LoganCapaldo> yeah you don't have to
18:24:31 <SamB> isn't the middle one a better choice?
18:24:42 <chessguy> random = 4 -- chosen by rolling a die, guaranteed to be random
18:25:00 <phlpp> hehe
18:25:01 <ddarius> For a list the middle one isn't handy, but then quicksorting a list is not the brightest thing in the first place.
18:25:06 <Japsu> chessguy: :D
18:25:08 <phlpp> that's pretty old ;__
18:25:20 <Japsu> that should be written out in Java syntax
18:25:27 <chessguy> yeah, but i couldn't miss the chance for an xkcd joke
18:25:31 <Japsu> ;)
18:25:35 <chessguy> @karma- java
18:25:35 <lambdabot> java's karma lowered to -23.
18:25:45 <ddarius> @karma+ java
18:25:45 <lambdabot> ddarius's karma lowered to 7.
18:25:55 <chessguy> haha
18:25:55 <ddarius> Hah, they changed that.
18:26:03 <chessguy> yeah they did
18:26:17 <chessguy> @karma+ c++
18:26:18 <lambdabot> c++'s karma raised to -7.
18:26:36 <ddarius> I used to be at 9, I wonder what happened to the other one or is incrementing Java's karma worth two karma points?
18:26:52 <LoganCapaldo> @karma
18:26:52 <lambdabot> You have a karma of 2
18:26:55 <chessguy> @karma
18:26:56 <lambdabot> You have a karma of 5
18:26:57 <monochrom> You can try again. :)
18:26:58 <LoganCapaldo> @karma+ java
18:26:59 <lambdabot> LoganCapaldo's karma lowered to 1.
18:27:04 * chessguy sneers at LoganCapaldo 
18:27:09 <Japsu> :DDD
18:27:10 <chessguy> pitiful fool
18:27:27 <LoganCapaldo> Well the missing karma point remains a mystery
18:27:53 <LoganCapaldo> Unless the amount of karma lost but upping jav's isn't constant
18:27:59 <LoganCapaldo> *lost by
18:28:03 <LoganCapaldo> *java's
18:28:18 <chessguy> why wouldn't it be constant?
18:28:31 * LoganCapaldo shrugs
18:28:34 <LoganCapaldo> Why would it?
18:29:29 <chessguy> i for one can't think of a formula that would make much sense
18:30:27 <shachaf> It is constant, I think.
18:30:42 <shachaf> Last time I looked at it, it just changed the nick when it saw "java".
18:33:50 <shachaf> Yes: changeKarma msg km sender nick | map toLower (Msg.nName nick) == "java" && km == 1 = changeKarma msg (-km) (Msg.lambdabotName msg) sender
18:34:47 <chessguy> @karma- java
18:34:47 <lambdabot> java's karma lowered to -24.
18:38:38 <LoganCapaldo> @karma chameleon
18:38:38 <lambdabot> chameleon has a karma of 2
18:41:12 <jimstutt> rfi: trying to build HAppS with ghc-6.8.1 using SearchPath but I get "unable to load package random1.0.0.0". but  ghc-pkg list | grep rand -> "random-1,0,0,0" is registered and in /usr/local/lib/ghc-6.8.1/lib/random-1.0.0.0 where it should be. Any suggestions?
18:41:50 <jimstutt> @users
18:41:50 <lambdabot> Maximum users seen in #haskell: 414, currently: 400 (96.6%), active: 13 (3.3%)
18:42:09 <ddarius> Jeez.
18:42:53 <LoganCapaldo> lambdabot: do you count yourself?
18:43:12 <ddarius> LoganCapaldo: Seemingly.
18:43:19 <chessguy> she must, because there are exactly 400 in the channel
18:43:46 <LoganCapaldo> I'm also curious about the active number
18:43:59 <chessguy> @help users
18:43:59 <lambdabot> users [chan]. Report the maximum number of users seen in a channel, and active users in the last 30 minutes
18:44:10 <LoganCapaldo> Is lambdabot one of the 13 active people?
18:44:14 <darrint> What does (->) mean in type signatures?
18:44:17 <monochrom> haha
18:44:23 <Botje> LAMBDABOT IS MADE OF PEOPLE!
18:44:39 <chessguy> LoganCapaldo, someone said LB has herself on ignore
18:45:17 <monochrom> (->) is the same -> in "a -> b"
18:46:18 <LoganCapaldo> @type pure
18:46:19 <Japsu> "lambdabot är ingen bot, hon är en väldigt, väldigt vacker tjej, som nu tyvärr är väldigt främmande till mig..."
18:46:19 <lambdabot>     Ambiguous occurrence `pure'
18:46:19 <lambdabot>     It could refer to either `pure', imported from Control.Applicative
18:46:19 <lambdabot>                           or `pure', imported from Control.Arrow
18:46:26 <LoganCapaldo> @type arr
18:46:26 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
18:47:16 <chessguy> @quote arrow
18:47:20 <lambdabot> Heffalump says: (re the RealWorld# token) The compiler knows that it can implement the token using the  arrow of time
18:48:06 <darrint> Is there a service somewhere that will derive a function from a type?
18:48:24 <SamB> @djinn Just a
18:48:25 <lambdabot> -- f cannot be realized.
18:48:30 <chessguy> @djinn a -> (a -> a) -> a
18:48:30 <lambdabot> f a b = b a
18:48:32 <SamB> @djinn () -> Just a
18:48:32 <lambdabot> -- f cannot be realized.
18:48:34 <SamB> er.
18:48:40 <SamB> @djinn Maybe a
18:48:40 <lambdabot> f = Nothing
18:48:51 <darrint> thanks
18:48:57 <chessguy> @help djinn
18:48:57 <lambdabot> djinn <type>.
18:48:58 <lambdabot> Generates Haskell code from a type.
18:48:58 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
18:49:04 * SamB thinks djinn should only say "f cannot be realized" if the it actually understood the type
18:49:05 <chessguy> augustss++
18:50:17 <allbery_b> @help free
18:50:17 <lambdabot> free <ident>. Generate theorems for free
18:50:54 <darrint> @djinn  StateT c b a -> IO a
18:50:54 <lambdabot> -- f cannot be realized.
18:50:56 <darrint> rats
18:51:18 <ddarius> darrint: It's mostly lacking information there.
18:51:50 <darrint> ddarius: I've been trying (for hours!!) to figure out how to make MonadPrompt do it's thing with the console. :-)
18:51:58 <gwern> this is getting interestinger and interestinger... the web form for signing up on community.haskell.org is broken; so you email the support address; that's broken too. You google around and see there's a bug report on rt.haskell.org about all this - except rt.haskell.org is itself broken!
18:52:06 <LoganCapaldo> @djinn StateT c IO a -> IO a
18:52:06 <lambdabot> -- f cannot be realized.
18:52:15 <LoganCapaldo> @djinn c -> StateT c IO a -> IO a
18:52:15 <lambdabot> -- f cannot be realized.
18:52:30 <gwern> now the question is whether the email address the rt.haskell.org error message points to is broken also
18:52:32 <ddarius> It doesn't know what StateT or IO is.
18:52:40 <LoganCapaldo> tear
18:52:47 <ddarius> gwern: Just post something on one of the mailing lists.
18:52:52 <darrint> I'm surprised. I'd think it would know StateT at least.
18:53:29 <LoganCapaldo> @djinn a -> IO a
18:53:30 <lambdabot> -- f cannot be realized.
18:53:38 <darrint> @djinn StateT cba
18:53:38 <lambdabot> -- f cannot be realized.
18:53:39 <LoganCapaldo> @djinn a -> State Int a
18:53:39 <lambdabot> -- f cannot be realized.
18:53:41 <darrint> @djinn StateT c b a
18:53:41 <lambdabot> -- f cannot be realized.
18:53:41 * gwern often gets the sense when dealing with Haskell matters that there's all this awesome stuff which just hasn't ever been used and so is buggy
18:53:55 <gwern> ddarius: no, no, I want to see how deep the rabbit hole goes :)
18:55:09 <ddarius> community.haskell.org has/is definitely used.
18:55:18 <shachaf> @djinn a -> IO a
18:55:18 <lambdabot> f = return
18:55:53 <darrint> ok. so it knows IO.
18:56:22 <shachaf> darrint: No, I just djinn-add-ed it in /msg. :-)
18:56:26 <gwern> ddarius: yes, I know it is used; I think I have some darcs repos which pull from there or something
18:56:40 <shachaf> darrint: Djinn wouldn't help you with this anyway, though.
18:57:11 <darrint> Well, here's the thing. I've been staring all day at: http://www.nabble.com/An-interesting-monad:-%22Prompt%22-p13825883.html
18:57:12 <lambdabot> Title: Nabble - An interesting monad: "Prompt", http://tinyurl.com/33fmes
18:58:13 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/4206
18:58:31 <darrint> I've been trying to write runGameIO there, and failing. (for hours)
19:06:19 <Porges> how can I get getStdGen to give me something difference in GHCI?
19:06:52 <Porges> *different
19:06:56 <LoganCapaldo> @type getStdGen
19:06:57 <lambdabot> IO StdGen
19:07:05 <Nafai> If you make a lambda function with \_ does that mean it takes no parameters?
19:07:11 <oerjan> Porges: use newStdGen instead
19:07:23 <LoganCapaldo> Nafai: it means it takes one paramter that it pays no attention to
19:07:29 <Porges> ah
19:07:31 <Porges> thx
19:07:42 <Nafai> LoganCapaldo: Okay, duh.  No different from pattern matching everywhere else
19:07:50 <LoganCapaldo> Nafai: indeed
19:08:21 <Nafai> I guess a lamdba function with no parameters doesn't really make sense in Haskell
19:08:32 <oerjan> Nafai: in haskell taking no parameters is no different from the result expression
19:08:45 <ddarius> Nafai: No, no it doesn't.
19:09:14 <Nafai> Slowly these things are clicking for me :)
19:09:27 <Nafai> It only took a year of lurking
19:10:45 <oerjan> dblog: not defined in 1
19:10:52 <oerjan> wrong channel
19:12:29 <LoganCapaldo> @type \_ -> ?expr
19:12:29 <lambdabot> forall t t1. (?expr::t1) => t -> t1
19:14:03 <ddarius> As helpful as #haskell is, actually using the language is probably the most effective way of learning it.
19:14:14 <LoganCapaldo> ddarius: bah
19:14:33 <LoganCapaldo> I never learned a thing by trying to actually use it ;)
19:14:55 <allbery_b> that's how I generally learn to actually use things
19:15:00 <Porges> GHC.IOBase.ErrorCall is a bad place to be getting exceptions from :S
19:15:04 <allbery_b> (reading manuals is never sufficient)
19:15:16 <dons> I'm going to get a tshirt with "grand fibonacci misinformation field at work" written on it.
19:15:54 <wli> I hope I'm not part of that.
19:16:11 <dons> wli, it stretches near and far!
19:16:25 * dons didn't see any snow today :(
19:16:39 <LoganCapaldo> what precisely is a grand fibonacci misinformation field?
19:17:04 <dons> oh, my little war with jon harrop :)
19:17:18 * ddarius didn't see any snow today either.
19:17:19 <dons> http://programming.reddit.com/info/61ecu/comments/c02k8ty for example
19:18:10 * ddarius has now been assaulted with one of the worst Internet ads he has seen.
19:18:11 <dons> i can't tell whether he honestly sees haskell as a threat to his sales, or he just wants to get some traffic to his site.
19:18:25 <dons> probably the latter, i guess.
19:18:26 <ddarius> At least the latter, possibly both.
19:19:14 <dons> he does this thing of planting innocent queries in old threads that make haskell (and probably other communities) seem suspect
19:19:24 <oerjan> LoganCapaldo: sounds like something by Douglas Adams
19:19:44 <dons> i guess the idea is people will google, come across something , and there'll be a seed of doubt there
19:20:12 <LoganCapaldo> geez
19:20:22 <LoganCapaldo> why is _haskell_ the threat?
19:20:33 <dons> what must be weird though is that xavier and don syme have both complained of this divide-and-conquer marketing technique as being damaging to the FP community.
19:20:36 <ddarius> Haskell is taking over the world!
19:20:39 <dons> and jon's even writing a book with don syme.
19:20:43 <LoganCapaldo> shouldn't he be doing this in C threads or something?
19:20:47 <dons> yet he explicitly refutes their complaints
19:21:19 <dons> and continues with the advertising spam hints
19:21:56 <dons> ah well, he's a minor fish in a big pond.
19:22:20 <dons> though if he's the public face of FP in the say, windows community, that's scary
19:22:54 <dons> btw, we have a user running xmonad on the ps3 :)
19:23:16 <dons> i'm not sure that was even theoretically possible, but there you go
19:23:26 <augustss> wow!
19:23:34 <ddarius> dons: I'm not certain how significant JDH is in any community.
19:23:48 <ddarius> Though I wonder how the O'Caml people view him.
19:24:04 <dons> i'll see if we can get a photo of this ps3. (must be running netbsd, I guess?)
19:24:29 <allbery_b> he's working on it, he says
19:24:43 <LoganCapaldo> Linux no? At least the PS2 run Linux
19:24:50 <dons> ddarius: well, xavier has complained of his techniques. and don syme raised the marketing issue at cufp. so i guess they're not viewed well
19:25:05 <dons> oh, yes, ubuntu
19:25:14 <ddarius> dons: Is the Xavier complaint online?
19:25:25 <dons> yeah, let me find it.
19:26:55 <dons> "The answer is: a disservice to the Caml community.  (This also applies to most of Skaller's rants and some of Harrop's marketing, by the way.) "
19:27:01 <dons> http://groups.google.com/group/fa.caml/browse_frm/thread/180889107dce82e5/c9c45d1e026319b0?lnk=gst&q=Harrop#c9c45d1e026319b0
19:27:02 <lambdabot> Title: fa.caml | Google Groups, http://tinyurl.com/2joqfv
19:28:03 <ddarius> It's one thing to alienate "the competitors", it's another to alienate your support.  I'm confident he'd get tons more sales if his books/etc. got put in a prominent position on their respective homepages.
19:28:25 <dons> well, we talked about his theory of FP marketing earlier,  I think
19:29:28 <chessguy> dons, is harrop the one that blog-flamed you the other day?
19:29:30 <dons> ok, so this ps3 is a ppc64, running sony's linux
19:29:39 <SamB> libel + ??? + profit?
19:30:07 <mkehrt_office> from ocaml list
19:30:12 <mkehrt_office> "You've just demonstrated out that this practice is very effective at
19:30:12 <mkehrt_office>  pissing me off.  Are you satisfied?
19:30:12 <mkehrt_office>  - Xavier Leroy "
19:30:22 <mkehrt_office> shit
19:30:23 <jsnx> jdh30 has shown up on LtU recently
19:30:27 <mkehrt_office> wrong window
19:30:29 <mkehrt_office> apologies
19:30:33 <ddarius> "You've just demonstrated out that this practice is very effective at pissing me off.  Are you satisfied?" Hah.
19:30:46 <ddarius> Doh.
19:30:54 <dons> chessguy: kinda. its more just linking to articles, weird bitterness, that'll be used as a longer term positioning for his arguments.
19:31:10 <dons> i'd imagine he'll just keep linking and repeating the claims of misinformation and so on, as he has done
19:31:38 <ricky_clarkson> I knew this was about Harrop before I saw the name.
19:31:52 <jsnx> he's of course making remarks about O'Caml and F# -- and of course, "Lisp is dead"
19:32:03 <dons> you know, in 2 years time, he'll drop a link to his ray tracer, to sow some doubt
19:32:03 <dbueno> ricky_clarkson... Me too.
19:32:15 <ddarius> jsnx: He's seemed to gone away again on LtU.
19:32:17 <dons> yeah, the lisp guys got the pointy end of it
19:32:22 <jsnx> yes
19:32:31 <jsnx> the community kicked him in the teeth
19:32:39 <jsnx> i am happy to say i was part of that :)
19:32:44 <dons> ddarius: i just hope he's going to be distracted with all the F# mainstream things (e.g. F#.NET Rocks!) that we won't see much of him
19:32:58 <hpaste>  gwern pasted "odd cabal error?" at http://hpaste.org/4207
19:33:10 <ddarius> jsnx: You were pushing it yourself.
19:33:43 <gwern> I'm not sure what's up with this cabal thing; the dependency is installed, just apparently not in the right package.conf?
19:33:50 <allbery_b> gwern: didyou configure --user ?
19:34:01 <hpaste>  gwern annotated "odd cabal error?" with "forgot the command" at http://hpaste.org/4207#a1
19:34:06 <allbery_b> if you're using something installed --user, you need to configure --user
19:34:18 <dbueno> Question: I have a case statement matching on a Maybe, and returning a State value; the Just case contains (in addition to other stuff) the code 'error "something"'.  If I comment out the Just case, when I run my program, I get a non-exhaustive pattern match error in that statement; if I leave it in, I never see the error.
19:34:21 <gwern> allbery_b: well, I tried, but that seemed to be problematic
19:34:22 <jsnx> ddarius: can you explain?
19:34:35 <allbery_b> (because it makes little sense to build something global that requires something --user)
19:34:36 <dbueno> I'm assuming laziness can explain it?
19:34:37 <jsnx> pushing the limit or pushing O'Caml?
19:35:39 <dons> ddarius: see, like this, he finds some 2 month old post to his own site, then comments on it today http://programming.reddit.com/info/2pxtn/comments
19:35:58 <basti_> dbueno: yes i'd guess so
19:36:02 <dons> i had no idea how deeply comitted to this business model he is. its wacky
19:36:09 <gwern> heh. 'cabal install base
19:36:28 <basti_> dbueno: you have to "touch" an error value to make it abort a program
19:36:37 <gwern>  -> cabal: user error (Unresolved dependencies: base -any)
19:36:42 <dbueno> basti_ The problem with that explanation is that the runtime non-exhaustive error occurs in the middle of printing; i.e. the None case is obviously forced
19:37:26 <basti_> dbueno: I'm not sure if pattern matching behaves normally.
19:37:37 <jimstutt> gwern: I have sim? prob with random while trying to build HAppS. I know it's no help but I'm new and would like to follow progress.
19:37:38 <dbueno> basti_ "Normally?"
19:38:08 <basti_> (that'd be: evaluating the value to be matched, then evaluating the matching expression)
19:38:19 <gwern> jimstutt: your errors up on hpaste?
19:38:29 <basti_> i remember something about pattern matching being somehow complicated for some reason when it comes to laziness
19:38:41 <dbueno> basti_: So you're saying Haskell might complain about non-exhaustiveness even if it never actually goes into the pattern that's not there?
19:38:52 <dbueno> If that's the case, I'd fell slightly less insane.
19:39:38 <basti_> dbueno: that might be possible yes. you should ask some of the hardcore guys in here for a reference. i'll google myself in a few moments, but i'm not sure if i'll be able to find it
19:40:05 <dbueno> Could someone point me to some documentation about how Haskell treats the matching of case statements?
19:40:27 <dons> woot, "This page has been accessed 1,001,758 times." haskell.org frontpage
19:40:36 <dons> 1M page views since we moved to media wiki
19:40:40 <hpaste>  jimstutt pasted "unable to load registered pkg" at http://hpaste.org/4208
19:40:51 <Nafai> dons: How long ago was that?
19:40:51 <ddarius> @where report
19:40:51 <lambdabot> http://www.haskell.org/onlinereport/
19:41:10 <dons> Nafai: hmm, a bit more than a year? I'm not sure exactly.
19:41:12 <gwern> (I'd be happier if it was hackage that had those stats)
19:41:14 <ddarius> dbueno: The Report specifies exactly how patterns are matched.
19:41:27 <dons> so that's people directly going to the frontpage.
19:41:45 <gwern> 'ghc-6.8.1: /usr/local/lib/ghc-6.8.1/lib/random-1.0.0.0/HSrandom-1.0.0.0.o: unknown symbol `oldzmtimezm1zi0zi0zi0_SystemziTime_a99_info'' <-- reminds me of those errors you get when you forget --make
19:41:48 <ricky_clarkson> How many of those are bots?
19:41:51 <ddarius> Just check the history of the front page.
19:41:59 <dons> 4.5M views all up.
19:42:02 <dbueno> ddarius, should I look at the revised or original?
19:42:12 <gwern> jimstutt: afraid your problem seems to be linking errors - my problems are with cabal and configuration, so entirely different
19:42:47 <jimstutt> gwern: using SearchPath for the install
19:43:56 <ddarius> dbueno: You should look at the current one which is the one I linked.  I don't think there were any major changes in the revision and I'm sure they weren't about that aspect.
19:44:28 <dbueno> ddarius: Oh, thanks; didn't see the link.
19:44:40 <ddarius> You probably want section 3.17
19:45:46 <ricky_clarkson> dons: Have you met Harrop?
19:46:37 <dons> ricky_clarkson: no, strangely. i don't think he goes to the FP conferences. (nor CUFP, strangely)
19:49:13 <ddarius> dons: Why would he?  He's after newbies.
19:49:36 <basti_> back
19:50:30 <dons> ddarius: right, yes.
19:57:43 <diltsman> Question:  What is the difference between Control.Monad.State.Class, Control.Monad.State.Lazy, and Control.Monad.State.Strict?
19:58:22 <allbery_b> .Class is used when you want to declare your own MonadState, I think
19:59:48 <allbery_b> Lazy and Strict variants are whether the state is strict or not.  (the default is lazy IIRC)
20:00:55 <diltsman> What is the difference between strict and non-strict state?
20:01:08 <allbery_b> the same as for strictness anywhere else
20:01:37 <diltsman> So, you could put an infinite list in non-strict state, but not in strict state?
20:01:38 <allbery_b> if you put or modify the state, it happens immediately instead of possibly waiting until something (usually IO) forces it
20:01:44 <dons> diltsman: so the new state is evaluated when you insert it (strict), or when it is finally used (lazy)
20:01:48 <basti_> dbueno: of what type is the parameter (or, the parameters) of your function?
20:02:12 <dbueno> basti_:  The function, actually, is here: http://hpaste.org/4209?lines=true
20:02:27 <dbueno> basti_: It won't compile, of course, but that's how it looks.
20:02:34 * basti_ nods
20:02:36 <diltsman> I'm wanting to use it to store the contents of a configuration file after parsing, rather than passing a tuple or reparsing every time I need something from it.
20:02:41 <allbery_b> as usual, lazy can be faster (because unneeded changes are never evaluated) but can conusume more memory (becuse of a buildup of unevaluated thinks)
20:03:15 <allbery_b> ( ^^ vast oversimplification )
20:03:30 <basti_> and you're talking about commending out the second "Just" expression?
20:03:40 <allbery_b> for that use it probably doesn't matter
20:03:41 <basti_> uhm sorry
20:03:49 <basti_> the "Just" expression
20:03:57 <diltsman> If we didn't want to oversimplify things, I would just read all of the code for ghc until I understood it all.
20:04:25 <dbueno> basti_: Yes.  If I comment that out, my program dies in the middle.  But leaving it in I never see the "error"
20:04:52 <basti_> dbueno: might it be that the parameter of the case expression returns e.g. "Just (1,2,3)"?
20:05:30 <basti_> oh no
20:05:32 <basti_> it might not
20:05:33 <basti_> >_<
20:05:52 <dbueno> basti_:  Right.  It's always a pair.
20:06:02 <diltsman> Thanks so much, that is just what I wanted to know.  Now to see if I can figure out how to use it correctly.  :-P
20:07:49 <basti_> maybe the problem happens in the lambda?
20:08:15 <basti_> what's the type of assignmentOfDecision and with?
20:08:25 <allbery_b> @src State >>
20:08:25 <lambdabot> Source not found. Wrong!  You cheating scum!
20:08:41 <allbery_b> does (>>) in State discard the lefthand expression?
20:09:29 <dbueno> allbery_b I wondered about that.  Does it?
20:09:42 <allbery_b> not sure, that's why I'm asking
20:09:52 * allbery_b is still not entirely up on these things
20:10:02 <allbery_b> (and rapidly falling asleep again.  *sigh*)
20:10:20 <dbueno> basti_: assignmentOfDecision :: Lit -> Assignment
20:11:02 <dbueno> basti_: with is part of my own Setlike typeclass; in this case, it has type with :: Assignment -> Lit -> Assignment, I think
20:12:03 <basti_> o.0
20:12:19 <basti_> i guess you should simplify your code ^^
20:12:57 <dbueno> basti_: I'd welcome ideas. It's supposed to implement non-chronological backtracking in a SAT solver, so, it's not the simplest task around. =]
20:13:06 <basti_> how about making the type of the lambda explicit?
20:13:13 <allbery_b> aha.
20:13:18 <dbueno> allbery_b: evalState (error "hi" >> put 3 >> return 1) 4
20:13:19 <dbueno> Loading package mtl-1.1.0.0 ... linking ... done.
20:13:19 <dbueno> 1
20:13:28 <allbery_b> > runState (error "foo" >> put 2) 0
20:13:28 <basti_> it would fail to compile then, if it isn't what you think it is
20:13:29 <lambdabot>  ((),2)
20:13:30 <dbueno> The State monad hates me.
20:13:34 <diltsman> Is there a way to put/get mulitple independent pieces of data with the Control.State.Lazy/Control.State.Strict monads, or do I have to write something to do that?
20:13:38 <allbery_b> use strict State
20:13:43 <allbery_b> maybe?
20:13:58 <oerjan> allbery_b: try get instead of put
20:13:59 <allbery_b> > Control.Monad.State.Strict.runState (error "foo" >> put 2) 0
20:14:00 <lambdabot>   Not in scope: `Control.Monad.State.Strict.runState'
20:14:17 <oerjan> because of the put it never needs to look at the first part
20:14:18 <dbueno> allbery_b: evalState?
20:14:23 <allbery_b> oerjan: I'm simplifying the code presented
20:14:45 <basti__> like (\x->blah x)::MyType->SomeType
20:14:47 <basti__> 24h disconnect
20:15:19 <dbueno> basti_: I don't think the lambda is at fault, because the runtime error indicates the line at fault, and it's the Just case
20:15:27 <basti_> oh
20:15:35 <allbery_b> right, backJump doesn't examine the state so the error gets discarded.
20:15:42 <basti_> ok
20:15:49 <dbueno> allbery_b: Yeah, that makes sense, on reflection.  Thanks for the help!
20:16:01 <basti_> then make the type of the variables in the Just expression explicit maybe?
20:16:23 * basti_ has the feeling of asymptotically approaching a meaningful idea
20:16:29 <allbery_b> > runState (error "foo" >>= put 2) 0
20:16:30 <lambdabot>  Couldn't match expected type `State s a' against inferred type `()'
20:16:41 <Porges> @let x ?=> y = do if x then do y; else return ()
20:16:42 <dbueno> basti_: The error is because I was expecting a strict state monad, but I was using the lazy one.
20:16:43 <lambdabot> Defined.
20:16:51 <basti_> oh.
20:18:54 <dons> ?=> mm.
20:18:54 <lambdabot> Maybe you meant: . ? @ bf ft id pl rc v wn
20:18:58 <dons> should remember that one
20:19:40 <oerjan> but but - it's just when
20:20:14 <dons> yeah, i'm more interested in the use of ?=> and similar as an operator.
20:20:24 <dons> i don't think i've seen ? in prefix form like that before
20:21:04 <dons> ?let x ?! y = repeat x ++ repeat y
20:21:06 <lambdabot> Defined.
20:21:22 <dons> > "wtf" ?! "ftw" -- :-)
20:21:23 <lambdabot>  ["wtf","wtf","wtf","wtf","wtf","wtf","wtf","wtf","wtf","wtf","wtf","wtf","wt...
20:21:37 <dons> there's a whole set of interesting !? ?!! ?!? ops to be made :)
20:23:56 <dbueno> basti_: Thanks for your help.
20:24:23 <basti_> dbueno: what help?
20:24:24 <basti_> ^^
20:24:35 <basti_> you mean, like, guiding you on the wrong trail? ;)
20:25:38 <Nafai> @index mplus
20:25:38 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
20:26:04 <dbueno> basti_: You can't be right all the time. =]
20:26:48 <basti_> ^^
20:27:22 * Nafai tries to understand how mplus is used
20:28:28 <chessguy> @type mplus
20:28:29 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
20:29:08 <chessguy> > foldr mplus Just 0 [Just 3, Just 2, Nothing]
20:29:09 <lambdabot>        add an instance declaration for
20:29:09 <lambdabot>       (Num [[Maybe t] -> Maybe [Maybe ...
20:29:22 <chessguy> yikes
20:29:29 <allbery_b> parens
20:29:35 <chessguy> > foldr mplus (Just 0) [Just 3, Just 2, Nothing]
20:29:36 <lambdabot>  Just 3
20:29:36 <chessguy> yeah
20:30:12 <chessguy> > foldr mplus (Just 0) [Nothing, Nothing, Nothing]
20:30:13 <lambdabot>  Just 0
20:30:23 <chessguy> > foldr mplus Nothing  [Nothing, Nothing, Nothing]
20:30:24 <lambdabot>  Nothing
20:30:32 <Nafai> I'm trying to understand the first example
20:31:25 <allbery_b> @src Maybe mplus
20:31:25 <lambdabot> Nothing `mplus` ys  = ys
20:31:25 <lambdabot> xs      `mplus` _ys = xs
20:31:26 <chessguy> first example?
20:31:43 <Nafai> > foldr mplus (Just 0) [Just 3, Just 2, Nothing]
20:31:44 <lambdabot>  Just 3
20:31:47 <chessguy> _ys lol
20:32:11 <chessguy> @src foldr
20:32:11 <lambdabot> foldr k z xs = go xs
20:32:11 <lambdabot>     where go []     = z
20:32:11 <lambdabot>           go (y:ys) = y `k` go ys
20:32:14 <allbery_b> the point of mplus is you could write something that can produce 0, 1, or many values using mzero and mplus paramaterized over MonadPlus
20:32:34 <allbery_b> then you can use it with Maybe to get fail/first result, or with a list ot get all results
20:32:58 <Nafai> allbery_b: Okay, that makes sense
20:33:32 <allbery_b> (and it shortcircuits, so if you use it with Maybe laziness will stop t from computing all results only to throw them away)
20:37:12 <allbery_b> another example of mplus:  in 6.8.1, IO is a MonadPlus and mplus does a catch, so you can try a bunch of alternatives which might fail, jined with `mplus` so the first that succeeds is produced
20:37:58 <allbery_b> (think trying a sequence of possible filenames)
20:40:32 * Nafai nods
20:42:06 <wy> hey!
20:43:02 <wy> I'm trying to mapping my messy Java concepts back to those of FPs. I noticed that abstract classes are just datatypes. Then what are interfaces?
20:43:53 <urk> am I imagining things, or is the 'inits' function in the prelude not lazy enough?
20:44:19 <allbery_b> > inits [1..]
20:44:21 <lambdabot>  [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],[1...
20:44:45 <Zao> wy: Probably not that mirrorable, since that wouldn't be that Haskellic.
20:45:17 <wy> Zao: probably yes. I guess
20:45:29 <allbery_b> in a twisted kinda of way they might be typeclasses
20:46:03 <jdrake> I have some structured data that I which to store in something named. The best thing I can describe it as would be similar to the 'struct' in C. What would be the best ting to look at?
20:46:07 <urk> > take 3 (List.inits (1:2:[]))
20:46:09 <lambdabot>  [[],[1],[1,2]]
20:46:12 <urk> > take 3 (List.inits (1:2:undefined))
20:46:13 <lambdabot>  Undefined
20:46:15 <allbery_b> jdrake: records
20:46:46 <allbery_b> > take 1 $ take 3 $ inits [1,2,undefined]
20:46:46 <lambdabot>  [[]]
20:47:02 <dmwit> urk: No, it's take that's not lazy enough. =/
20:47:03 <allbery_b> it's as lazy as whatever consumes the values is
20:47:10 <dmwit> > take 2 [1,2,undefined]
20:47:15 <lambdabot>  [1,2]
20:47:23 <dmwit> Oh.
20:47:29 <jdrake> If I had a list of records, would it be easy to store these in a file on disk?
20:47:39 <dmwit> Hmm, what am I thinking of?
20:47:44 <urk> inits always returns []:something
20:47:55 <dmwit> jdrake: deriving (Read, Show) should do it.
20:47:57 <urk> but it matches to see if the list is empty before doing so
20:48:00 <allbery_b> sure.  trivially via show/read, Data.Binary on hackage for more complex stuff
20:49:56 <jdrake> dmwit: Is there a good discussion on this somewhere? I notice it isn't in the gentle introduction. I am unsure exactly how these things work.
20:51:01 <dmwit> http://haskell.org/tutorial/stdclasses.html#sect8.4
20:51:03 <dmwit> ?
20:51:29 <urk> > let x = 1 : map length (tail (List.inits x)) in x
20:51:31 <lambdabot>  Exception: <<loop>>
20:51:36 <urk> let x = 1 : map length (tail (inits' x)); inits' m = [] : case m of {[] -> []; a:as -> map (a:) (inits' as)} in x
20:51:42 <urk> > let x = 1 : map length (tail (inits' x)); inits' m = [] : case m of {[] -> []; a:as -> map (a:) (inits' as)} in x
20:51:43 <lambdabot>  [1,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
20:52:05 <davidm123_> it seems compiled executable sizes on a trivial program are approx 5 times less in ghc 2.8.1 over 2.6.1
20:52:29 * dmwit hopes davidm123_ means 6.8.1 vs 6.6.1
20:52:36 <davidm123_> yeah
20:52:46 <dmwit> Wow!  That's impressive.
20:52:59 * LoganCapaldo hopes davidm123_ means 2.8.1 vs. 2.6.1 cause that would be way weirderer
20:52:59 <dmwit> Have you accidentally turned some kind of optimization on in one but not the other?
20:53:34 <davidm123_> dunno, 2.6.1 is from the ubuntu distribution. 2.8.1 I compiled myself using 2.6.1.
20:54:10 <davidm123_> the hello-world-like program in 2.6.1 is 1.5MB stripped.  the one in 2.8.1 is about 260KB
20:54:22 <dmwit> *blink*
20:54:35 <dmwit> Why do you keep saying 2.*?  It's very confusing. =P
20:54:41 <davidm123_> sorry :)
20:55:24 <dmwit> That's pretty cool though.
20:55:25 <davidm123_> I'm using ghc-inplace in 6.8.1 (not sure if that matters)
20:56:49 <voidlogic> can anyone tell me why I can't declare a function like this: adjacent n (e:es) =
20:57:03 <voidlogic> where n is a tuple
20:57:39 <TSC> I think you can do that
20:57:45 <Nafai> Okay, I'm the exercises from "All about Monads" and in exercise 3 it talks about using mplus from the List monad.  How is that different from mplus that is defined in the Monad module?
20:57:53 <LoganCapaldo> voidlogic: cause you need something after the = ?
20:58:00 <allbery_b> tuple is , not :
20:58:06 <voidlogic> i know, i have stuff there
20:58:10 <allbery_b> (: is for lists)
20:58:16 <urk> voidlogic: show the stuff -- the first part is valid :)
20:58:37 * allbery_b misread, sorry
20:59:29 <voidlogic> ERROR "/home/undriedsea/Desktop/HW5.hs":20 - Type error in function binding
20:59:29 <voidlogic> *** Term           : adjacent
20:59:29 <voidlogic> *** Type           : (a,b) -> [a] -> [a]
20:59:29 <voidlogic> *** Does not match : [a] -> [a]
20:59:39 <voidlogic> adjacent n (e:es) =
20:59:40 <voidlogic>     if fst n == e then e:adjacent es
20:59:40 <voidlogic>     else adjacent es
20:59:40 <voidlogic> adjacent n [] = []
20:59:57 <TSC> When you call adjacent, you need "adjacent n es"
20:59:58 <LoganCapaldo> voidlogic: you need to pass n to the recurse calls
20:59:59 <dmwit> adjacent takes two arguments. ;-)
21:00:06 <LoganCapaldo> *recursive
21:00:18 <dmwit> Nafai: It isn't, mplus is part of the MonadZero (MonadPlus?) class.
21:00:21 <voidlogic> wow, i'm dumb
21:00:31 <voidlogic> thanks guys
21:00:32 <Nafai> dmwit: Er, yeah MonadPlus
21:00:51 <TSC> voidlogic: If you add a type declaration for the function, you'll get a better error message
21:01:13 <dmwit> Nafai: List is just an instance of the MonadPlus class.  (Is that what you were asking?)
21:01:18 <voidlogic> ok, i'll do that, the generic errors are mind boggling somtimes
21:01:22 <allbery_b> Nafai: each instance of MonadPlus provides its own implementation
21:01:27 <allbery_b> @src Maybe mplus
21:01:27 <lambdabot> Nothing `mplus` ys  = ys
21:01:27 <lambdabot> xs      `mplus` _ys = xs
21:01:30 <allbery_b> @src [] mplus
21:01:31 <lambdabot> mplus = (++)
21:01:48 <allbery_b> @src IO mplus
21:01:48 <Nafai> dmwit: Yeah
21:01:48 <lambdabot> m `mplus` n = m `catch` \_ -> n
21:02:14 <dmwit> huh
21:02:20 <allbery_b> @src Either mplus
21:02:20 <lambdabot> Left _ `mplus` n = n
21:02:20 <lambdabot> m      `mplus` _ = m
21:02:32 <urk> dmwit: ah, found it: http://www.nabble.com/inits--is-too-strict-t3913668.html
21:02:33 <lambdabot> Title: Nabble - Haskell - Haskell-prime - inits is too strict
21:02:35 <dmwit> Where is the IO instance defined?
21:03:01 <allbery_b> not sure, it's new in 6.8 though
21:03:25 <allbery_b> (can't easily check now, backups in progress :> )
21:03:50 <dmwit> Oh, okay.  Never mind, then.
21:03:59 <dmwit> I haven't upgraded yet anyway.
21:04:01 <voidlogic> "adjacent n (e:es) = ..." and an "adjacent n [] = []", but it says Error - "adjacent" multiply defined, what am I doing wrong?
21:04:22 <TSC> voidlogic: Make sure the different cases are next to other
21:04:41 <voidlogic> the n [] comes directly after the other
21:04:54 <LoganCapaldo> voidlogic: you could write it like adjacent _ [] [] ; adjacent n xs = adjacent' xs where adjacent' (e:es) = if fst n == e then e:adjacent' es else adjacent' es
21:05:07 <allbery_b> @paste it
21:05:08 <lambdabot> Haskell pastebin: http://hpaste.org/new
21:05:32 <LoganCapaldo> if you didn't want to worry about forgetting the n
21:05:40 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/4210
21:05:51 <voidlogic> here she be http://hpaste.org/4210
21:05:57 <oerjan> allbery_b: actually it's not that new
21:06:08 <oerjan> it's in hugs
21:06:13 <oerjan> Control.Monad.Error
21:06:21 <allbery_b> hm
21:07:05 <allbery_b> that looks like it should work
21:07:23 <voidlogic> i tried replacing the n in the second one with _ to no avail
21:08:22 <oerjan> voidlogic: is that your whole file? maybe you have another adjacent somewhere
21:08:41 <oerjan> @hoogle adjacent
21:08:41 <lambdabot> No matches found
21:09:07 <voidlogic> oh, your right, I wrote a similar function much later and copy and pasted but missed a change
21:09:08 <hpaste>  LoganCapaldo annotated "(no title)" with "guards and such" at http://hpaste.org/4210#a1
21:09:26 <voidlogic> i with it told me the line number of the second instance found
21:09:31 <voidlogic> *wish
21:09:56 <oerjan> voidlogic: can you paste the whole file?
21:10:06 <oerjan> oh never mind
21:10:16 <oerjan> i didn't see all your messages
21:12:32 <oerjan> allbery_b: hmph, MonadPlus IO should have been in .Instances, not .Error
21:13:06 <oerjan> afaik that's the place for forgotten instances of builtin type/class combinations
21:13:20 <allbery_b> yeh
21:13:25 <allbery_b> I just verified it's in .Error
21:13:37 <shachaf> @src IO mzero
21:13:37 <lambdabot> mzero       = ioError (userError "mzero")
21:13:42 <allbery_b> annoying, as I'd tried it and not found it previously
21:14:04 <allbery_b> (otoh it means I can now go back ad use it :)
21:14:07 <hpaste>  LoganCapaldo annotated "(no title)" with "pointless edition" at http://hpaste.org/4210#a2
21:14:15 <oerjan> i just guessed .Error because i knew it used catch
21:14:55 <allbery_b> hm, although I thought I already ... nm, I used Control.Exception, not Control.Monad.Error
21:14:57 <allbery_b> wheee
21:15:29 <allbery_b> (rehash earlier namespace discussion, anyone? :)
21:17:24 <omg911> is there a library function that randomizes a list?
21:17:38 <dons> nope, but its a one liner
21:17:45 <oerjan> the order you mean? no
21:18:02 <omg911> uh liner eh?
21:18:11 <dons> i reckon :)
21:18:46 <oerjan> maybe not _that_ short
21:18:59 <dons> no, pretty sure...
21:19:30 <omg911> lol i don't know about that
21:20:20 <omg911> but i'm new at haskell so meh i can get a random list from the orginal but i can't figure out how to efficiently remove duplicates
21:20:22 <sclv> ok i'm trying to learn the ST monad
21:20:43 <sclv> I have a function that I want to take a list of items and return a new STUArray
21:20:44 <dons> ?let s = [1..10]
21:20:48 <lambdabot> Defined.
21:20:54 <dons> > map fst . sortBy (compare `on` snd) $ zip s (randomRs (0,length s-1) (mkStdGen 42))
21:20:59 <lambdabot>  [1,2,6,8,4,10,5,3,7,9]
21:21:02 <sclv> it's essentially a call to newListArray
21:21:10 <Olathe> omg911: How fast is nub for you ?
21:21:17 <sclv> I understand how to type it for IO arrays
21:21:33 <omg911> nub?
21:21:42 <sclv> as returning IO (IOArray Int Double)
21:21:46 <dons> > nub [1,1,2,1,2,2,3,4]
21:21:47 <lambdabot>  [1,2,3,4]
21:21:49 <Olathe> > nub [1, 2, 1, 3, 1, 5, 5, 7]
21:21:49 <lambdabot>  [1,2,3,5,7]
21:21:56 <Olathe> Removes duplicates.
21:22:00 <omg911> lol
21:22:01 <sclv> What do I change the type signature to so it returns an ST array instead?
21:22:02 <dons> :t comparing
21:22:03 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
21:22:09 <omg911> i never knew about that function
21:22:14 <omg911> thx
21:22:21 <shachaf> @src nub
21:22:21 <lambdabot> nub = nubBy (==)
21:22:21 <dons> > map fst . sortBy (comparing snd) . zip s  $ randomRs (0,length s-1) (mkStdGen 42)
21:22:25 <Olathe> You're welcome.
21:22:26 <shachaf> @src nubBy
21:22:26 <lambdabot> nubBy eq []             =  []
21:22:26 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
21:22:31 <lambdabot>  [1,2,6,8,4,10,5,3,7,9]
21:22:46 <Olathe> That's not in the source for nubBy !
21:22:53 <sclv> nevermind -- no sooner do I ask then the asking helps me figure it out.
21:22:54 <omg911> [n=chatzill@99.162.107.147] has joined #haskell
21:23:07 <oerjan> dons: you want to ensure it's using something with insignificant chance of duplicates for the random list
21:23:11 <sclv> ST s (STUArray s Int Double)
21:23:23 <dons> > map fst . sortBy (comparing snd) . zip s . randoms . mkStdGen $ 42
21:23:24 <lambdabot>  [10,1,7,3,9,8,6,5,4,2]
21:23:29 <shachaf> Olathe: Why not?
21:23:38 <dons> oerjan: yeah. true
21:23:39 <Olathe> shachaf: It just isn't.
21:23:39 <shachaf> Olathe: It's what H98 says, I think.
21:23:42 <shachaf> @where report
21:23:42 <lambdabot> http://www.haskell.org/onlinereport/
21:23:44 <dons> > map fst . sortBy (comparing snd) . zip s . nub . randoms . mkStdGen $ 42
21:23:44 <lambdabot>  [10,1,7,3,9,8,6,5,4,2]
21:23:50 <Olathe> shachaf: I mean the numeric list :)
21:23:58 <Olathe> (23:20.22) (lambdabot) nubBy eq (x:xs) = x : nubBy eq (filter (\ y -> not (eq x y)) xs)
21:23:58 <Olathe> (23:20.27) (lambdabot) [1,2,6,8,4,10,5,3,7,9]
21:24:01 <dons> pretty happy with that. looks good
21:24:19 <shachaf> Olathe: Oh. :-)
21:24:39 <dons> ?undefine
21:24:40 <lambdabot> Undefined.
21:24:57 <dons> ?let randomise s = map fst . sortBy (comparing snd) . zip s . nub . randoms . mkStdGen
21:24:57 <lambdabot> <local>:1:32: Not in scope: `comparing'
21:25:00 <dons> oh boo
21:25:20 <dons> omg911: what do you think? pretty cute, eh? :)
21:25:22 <shachaf> @let on f g x y = g x `f` g y
21:25:23 <lambdabot> Defined.
21:25:33 <dons> ?src comparing
21:25:33 <lambdabot> Source not found. That's something I cannot allow to happen.
21:25:42 <Olathe> @index comparing
21:25:42 <lambdabot> bzzt
21:25:47 <Olathe> bzzt ?!
21:25:49 <shachaf> > comparing id 1 2
21:25:52 <Olathe> That's not a module !
21:25:54 <dons> ?let comparing p x y = compare (p x) (p y)
21:25:56 <lambdabot>  LT
21:26:04 <lambdabot> Defined.
21:26:07 <dons> ?let randomise s = map fst . sortBy (comparing snd) . zip s . nub . randoms . mkStdGen
21:26:07 <lambdabot> Add a type signature
21:26:07 <glguy> Olathe: did the lowercase give it away?
21:26:10 <shachaf> Olathe: Data.Ord.
21:26:17 <Olathe> glguy: :)
21:26:29 <omg911> what package is nub in?
21:28:37 <Olathe> @index nub
21:28:37 <lambdabot> Data.List
21:28:37 <shachaf> omg911: Package?
21:28:37 <dons> ?hoogle nub
21:28:37 <lambdabot> List.nub :: Eq a => [a] -> [a]
21:28:37 <lambdabot> List.nubBy :: (a -> a -> Bool) -> [a] -> [a]
21:28:37 <omg911> oh ok
21:28:37 <dons> its in the Data.List module
21:28:37 <shachaf> omg911: It's in Data.List, if that's what you mean.
21:28:37 <glguy> in the base package?
21:28:37 <shachaf> omg911: Otherwise it's in base.
21:28:37 <oerjan> > "did this break now"
21:28:37 <lambdabot>  "did this break now"
21:28:37 <Olathe> > "no it didn't"
21:28:37 <lambdabot>  "no it didn't"
21:28:37 <dons> i won't define it if there's errors
21:28:37 <omg911> yup
21:28:37 <dons> ?let randomise :: Ord a => Int -> [a] -> [a] ; randomise s = map fst . sortBy (comparing snd) . zip s . nub . randoms . mkStdGen
21:28:37 <lambdabot> Couldn't match expected type `[a]' against inferred type `Int'
21:28:37 <oerjan> there was a weird race condition up there
21:28:37 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/4211
21:28:37 <dons> ?let randomise :: Ord a => [a] -> Int -> [a] ; randomise s = map fst . sortBy (comparing snd) . zip s . nub . randoms . mkStdGen
21:28:37 <lambdabot> Add a type signature
21:28:37 <dons> screw you, lambdabot
21:28:41 <oerjan> ?let test = 1
21:28:43 <lambdabot> Defined.
21:28:59 <voidlogic> I must be using map wrong, I'm getting a confusing msg about unification causing infinite types? http://hpaste.org/4211
21:28:59 <dons> glguy: i added a simple rss plugin to lambdabot, btw. currently just weather feeds, on demand
21:29:13 <omg911> dons: thx for the help
21:29:19 <dons> no worries.
21:29:23 <glguy> dons: I can help with that one, the weather is: cold and rainy
21:29:30 <glguy> link?
21:29:46 <Olathe> How did I exit from here ?
21:29:48 <dons> lambdabot> Tonight - Rain...locally mixed with snow above 500 to 1000 feet northeast of Vancouver. Light snow accumulation. Lows around 35. Southeast wind 15 to 25 mph.
21:30:01 <dons> glguy: uses our xml lib though.
21:30:09 <glguy> when is that going out?
21:30:31 <dons> not sure. i added some more cabal stuff to make it easier. we should do it next week though
21:30:44 <dons> its nice for little xml jobs, actually
21:30:46 <voidlogic> I must be using map wrong, I'm getting a confusing msg about unification causing infinite types? Anyone know what that could mean?  http://hpaste.org/4211
21:30:48 <oerjan> voidlogic: a good rule of thumb is to add an explicit declaration for the type you want it to have.  it improves error messages.
21:31:35 * glguy finally bothered to sit down and code this one up http://projecteuler.net/index.php?section=problems&id=144
21:31:37 <lambdabot> Title: Problem 144 - Project Euler
21:31:50 <glguy> Some of the project euler problems aren't about figuring them out as much as finishing htem
21:32:16 <laz0r> is there a nice way to assign type declaration to nested do-loops?
21:32:39 <glguy> let m :: Type
21:32:42 <glguy> m = do ...
21:32:50 <glguy> and then on its own line, m :)
21:33:00 <glguy> or
21:33:04 <glguy> (do ...) :: IO Int
21:33:26 <laz0r> glguy, ah ok, the last one i already knew, but it is kind of ugly
21:33:52 <laz0r> the other one isnt so great either
21:34:05 <shachaf> Do-loops?
21:34:15 <glguy> he means do blocks I would imagine
21:34:18 <Olathe> > map (length.collatzChain) [1..10]
21:34:18 <lambdabot>  [1,2,8,3,6,9,17,4,20,7]
21:35:54 <jdrake> I have a function that does \file -> do ...  and inside that do I have a let statement that assigns a value to 'time'. I need to be able to return that value, is there an agreeable way of doing that?
21:36:01 <laz0r> since i tend to always make a linebreak after a do, i would have hoped for something like (do :: Type) and then a newline with the actual do block following
21:36:31 <andyjgill> hi bos
21:36:40 <oerjan> jdrake: "return time" at the end of the do expression
21:37:08 <oerjan> jdrake: if this is the same as before you also want to change forM_ to forM
21:37:20 <jdrake> yes, that has been done :p
21:37:23 <jdrake> Thank you again
21:39:50 <jdrake> Is there a shortcut function that can do [a] -> [b] -> [(a,b)]? (otherwise, I can just as easily do it with a regular function)
21:39:53 <oerjan> laz0r: you could put it at the end, typing the final expression
21:40:07 <andyjgill> :t unzip
21:40:13 <lambdabot> forall a b. [(a, b)] -> ([a], [b])
21:40:15 <oerjan> which of course is the same as the whole type
21:40:20 <andyjgill> :t zip
21:40:21 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
21:40:42 <jdrake> perfect
21:40:44 <andyjgill> (always get these two mixed up)
21:41:07 <jdrake> At least I was in the right place in the documentation :p
21:41:17 <oerjan> jdrake: if they're computed by the same do expression you can of course return (x,y)
21:41:25 <laz0r> oerjan, yes, glguy already pointed that out, ok, not exactly the same what you are proposing, but quite similar
21:41:49 <shachaf> laz0r: there's "(`asTypeOf` (undefined :: ...)) $ do ...". :-)
21:42:12 <shachaf> laz0r: Maybe you can @paste some context?
21:42:52 <jdrake> oerjan: files and timestamps, which by the code that I am using from you, it is done separately.
21:43:17 <oerjan> laz0r: i mean you don't need parentheses if you put it on the last expression
21:43:40 <laz0r> shachaf, mmh, i could maybe, but actually i was just wondering, and did see someone saying something about type declarations scrolling over the screen
21:43:46 <laz0r> so i thought, i just ask
21:44:01 <oerjan> jdrake: well you could still return (file, time)
21:44:14 <jbauman> @hoogle [a] -> [b] -> [(a,b)]
21:44:15 <lambdabot> Prelude.zip :: [a] -> [b] -> [(a, b)]
21:44:16 <oerjan> since the \file -> is passed in
21:44:19 <shachaf> @ty let {unzipC l k = let (x,y) = unzip l in k x y } in unzipC
21:44:19 <lambdabot> forall a b t. [(a, b)] -> ([a] -> [b] -> t) -> t
21:44:26 <laz0r> oerjan, yes, i know i could just type the last expression, but i mean the type would still be at the end of the block
21:44:45 <shachaf> There's no way to make unzip's type look closer to zip's?
21:45:05 <Olathe> > zip
21:45:06 <lambdabot>  Add a type signature
21:45:08 <ddarius> :t zip
21:45:09 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
21:45:09 <Olathe> :t zip
21:45:10 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
21:45:14 <ddarius> :t unzip
21:45:15 <Olathe> :t unzip
21:45:15 <lambdabot> forall a b. [(a, b)] -> ([a], [b])
21:45:15 <lambdabot> forall a b. [(a, b)] -> ([a], [b])
21:45:21 <oerjan> laz0r: seems like another case for a (:: Type) extension.  then you could have done (:: Type) $ do
21:45:28 <ddarius> :t uncurry zip
21:45:28 <jbauman> :t uncurry zip
21:45:28 <lambdabot> forall a b. ([a], [b]) -> [(a, b)]
21:45:29 <lambdabot> forall a b. ([a], [b]) -> [(a, b)]
21:45:46 <jbauman> aww, beaten
21:45:48 <shachaf> The extra pair (for returning multiple values) looks unnecessary.
21:45:49 <oerjan> of course just after do would be prettier.
21:46:47 <ddarius> shachaf: There is no natural isomorphism with pairs in the bottom (okay there is (AB)^C ~ A^C B^C
21:46:49 <ddarius> )
21:47:07 <laz0r> oerjan, i was thinking about something like the type signatures of functions
21:47:26 <laz0r> i tend to always write one, directly followed by the function
21:47:41 <jbauman> ddarius, so zip and unzip are the isomorphism he wants? :)
21:47:41 <laz0r> they make things alot more easier/better to understand
21:48:06 <ddarius> :t uncurry zip . unzip
21:48:07 <lambdabot> forall a b. [(a, b)] -> [(a, b)]
21:48:14 <laz0r> and i thought it would be great to type do blocks in a similar way, especially when you have more then one nested in each other
21:48:53 <laz0r> because then i tend to ... get confused
21:49:49 <oerjan> @check \l -> (zip.unzip) (l::[(Bool,Bool)]) == l
21:49:50 <lambdabot>  Couldn't match expected type `[a]'
21:50:00 <oerjan> @check \l -> (uncurry zip.unzip) (l::[(Bool,Bool)]) == l
21:50:03 <lambdabot>  OK, passed 500 tests.
21:50:54 <oerjan> @check \l -> (unzip.uncurry zip) (l::([Bool],[Bool])) == l
21:50:55 <lambdabot>  Falsifiable, after 1 tests: ([True],[False,True])
21:51:22 <oerjan> @check \l@(l1,l2) -> length l1 == length l2 ==> (unzip.uncurry zip) (l::([Bool],[Bool])) == l
21:51:22 <lambdabot>  Arguments exhausted after 133 tests.
21:52:00 <jbauman> so more of a homomorphism?
21:52:20 <oerjan> projection?
21:52:28 <diltsman> Can anybody point me to a good tutorial to learn how to use the State monad?
21:52:53 <oerjan> @go all about monads
21:52:54 <lambdabot> http://www.haskell.org/all_about_monads/html/
21:52:54 <lambdabot> Title: All About Monads
21:53:48 <diltsman> Thanks.  Lets see if that un-confuses me.
21:53:57 <shachaf> diltsman: Use s -> (a,s) functions for a bit, then try to reimplement it yourself.
21:55:20 <diltsman> I'm still confused about what the state and return values are.
21:56:15 <shachaf> diltsman: Do you understand how s -> (a,s) functions work for "emulating" state?
21:56:29 <oerjan> > runState (do x <- get; put (x*x); return (x+3)) 5
21:56:31 <lambdabot>  (8,25)
21:56:59 <laz0r> diltsman, the state is the state you want to keep track of while doing some kind of a computation, and the return value is the value you are actually computing
21:57:13 <laz0r> disclaimer: im kind of a noob myself, maybe im wrong
21:57:37 <dmwit> The trick is that the state has the same type throughout the entire calculation, but the return type can be anything you want.
21:58:07 <dmwit> So, if you look at the (State Int) monad, the type of the state is always an integer (say, a counter).
21:58:26 <diltsman> Weird...Ok, I'm officially confused.  I'm primarily a C/C++ programmer, so functional programming is new for me.
21:58:35 <dmwit> But you could have different stateful actions that used the integer to determine a string, or a function, or anything.
21:58:59 <diltsman> shachaf: No, I don't understand.
21:59:02 <oerjan> > runState (do x <- get; modify (^3); return ("x is "++show x)) 5
21:59:03 <lambdabot>  ("x is 5",125)
21:59:17 <allbery_b> State monad just carries state around for you transparently while you do stuff
21:59:38 <laz0r> diltsman, i found the whole monad thing suddenly 'unfolded' in front of me when i got that 'i am doing things _inside_ of the monad'
21:59:42 <shachaf> diltsman: A function that gets some arguments, can read a state, and can write a new state can look like this: f :: args -> s -> (a,s)
21:59:53 <diltsman> So it only carries it around in the one function (unless you explicitly pass the state object)?
21:59:57 <shachaf> diltsman: (As opposed to :: args -> a)
22:00:12 <shachaf> diltsman: The first s is the initial state, and the second s is the new state.
22:00:16 <ddarius> @wiki Monads as computation
22:00:16 <lambdabot> http://www.haskell.org/haskellwiki/Monads_as_computation
22:00:42 <allbery_b> except your one function can invokek other fjunctions, which quietly get the state propagated through them
22:00:45 <shachaf> @wiki Monads as containers
22:00:45 <lambdabot> http://www.haskell.org/haskellwiki/Monads_as_containers
22:00:54 <allbery_b> as long as their result typementions the State type
22:01:01 <shachaf> Talks about it a little bit -- computation doesn't.
22:01:20 * ddarius poos on Monads as Containers
22:01:34 <diltsman> How would I use the state monad to emulate a global variable?
22:01:35 <laz0r> guys i have to say this, i personally found all those tutorials pretty confusing
22:01:38 <diltsman> lol
22:01:53 <shachaf> diltsman: Is it a changing variable?
22:01:54 <ddarius> laz0r: I agree. Read Wadler.
22:01:58 <ddarius> @google Wadler monads
22:01:59 <lambdabot> http://homepages.inf.ed.ac.uk/wadler/topics/monads.html
22:01:59 <lambdabot> Title: Wadler: Monads
22:02:01 <shachaf> diltsman: (If not, you can use Reader.)
22:02:39 <dmwit> I think sigfpe's "debuggable functions" are a good example of the State monad.
22:02:40 <diltsman> I only set it when I parse the config file.
22:02:42 <laz0r> it 'clicked' for me when i played around with the list monad alot
22:02:46 <dmwit> (Well, Writer, really, I guess, but...)
22:02:47 * ddarius thinks back to the good 'ole days when he started learning Haskell and the monad tutorial business had not swung in full gear.
22:03:04 <dmwit> laz0r: me too =)
22:03:42 <oerjan> diltsman: then it may be a good idea to parse the config file first and enter a Reader monad afterward
22:04:03 <diltsman> I'd say that since I only started with Haskell about 1.5 weeks ago, that I'm not doing too badly...just not as well as I would like.
22:04:31 <diltsman> I might re-parse the config file at a later date.
22:04:44 <ddarius> diltsman: It's not going to be as easy as learning, say C#, would be.
22:05:15 <diltsman> lol  I know that, but it is a *SWEET* language so far.
22:05:37 <ddarius> Sweet like cocaine.
22:06:01 <diltsman> No, much more useful than cocaine.
22:06:10 <ddarius> True.
22:06:46 <shachaf> diltsman: Look at Reader before State, possibly -- it's simpler.
22:06:59 <shachaf> @unmtl Reader r a
22:06:59 <lambdabot> r -> a
22:07:24 <diltsman> Ok.  I'm sure when I really start to understand Monads that things like this will click.
22:07:25 <shachaf> diltsman: It just hides an extra argument.
22:07:35 <diltsman> Thanks so much.
22:07:38 <shachaf> #haskell needs something like a Gobby session.
22:07:43 <shachaf> That would be useful.
22:08:43 <dmwit> I found that list, State, and IO "clicked" separately, and then Reader, Writer, and several special-purpose monads came easily after that.
22:09:07 <allbery_b> @go you could have invented monads
22:09:09 <lambdabot> http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
22:09:09 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ...
22:09:14 <allbery_b> that one helped me the most
22:09:38 <shachaf> dmwit: List is odd -- it didn't really feel like any of the others at first.
22:09:57 <ddarius> None of them should feel like any of the others.
22:09:59 <allbery_b> it essentially goes through several examples "manually" and then shows how the "monad" concept applies to them by looking at the common behaviors/actions
22:10:11 <ddarius> Or they should all feel "roughly" the same.
22:10:40 <oerjan> ddarius: well Writer and Reader feel a bit like stripped down State
22:10:49 <ddarius> Not really.
22:10:51 <dmwit> yeah
22:10:51 <diltsman> Thanks for all the help/advice.  I have to go to bed now, but I will keep looking into this in the morning.
22:11:28 <oerjan> although the stripping down does allow for more lazyness
22:11:41 <shachaf> ddarius: Yes -- but I thought of instance Monad [] as almost "cheating" at first, forcing it into a monad rather than it naturally being one.
22:11:53 <shachaf> ddarius: I don't feel that way anymore -- I guess I got used to it. :-)
22:12:15 <ddarius> shachaf: It would be nice to introduce people to something more aimed at the effect the list monad captures rather than the list monad directly.
22:12:23 <allbery_b> best way to think about list monad is list comprehensions
22:12:32 <dmwit> "In mathematics, you don't understand things.  You just get used to them." -- John von Neumann
22:12:49 <allbery_b> (because that's whatlist comprehensions are)
22:13:24 <ddarius> allbery_b: That connects it most directly to something one may already know, but then how do you think about list comprehensions.
22:14:01 * ddarius views the list monad (or preferably some other monads, e.g. the Tree monad) as non-deterministic computations as Moggi intended (actually he used the powerset monad for that, but...)
22:14:19 <allbery_b> seems to me list comprehensions are easier to "figure out"
22:14:39 <allbery_b> then you just show how the comprehension syntax translates directly into monad syntax
22:15:03 <Olathe> > let evenLength = not.oddLength; oddLength [] = False; oddLength (_:xs) = not (oddLength xs) in evenLength [1..]
22:15:07 <lambdabot> Terminated
22:15:10 <Olathe> How can I speed that up ?
22:15:20 <oerjan> :D
22:16:00 <oerjan> @quote heat.death
22:16:00 <lambdabot> sorear says: Unfortunatly, Coq *cannot* prove that your program will terminate before the heat-death of the universe. // psnively> Right. That's a software engineering problem, not a computer
22:16:00 <lambdabot> science problem. ;-)
22:16:08 <dmwit> > let evenLength xs = undefined in evenLength [1..] -- faster
22:16:10 <lambdabot>  Undefined
22:16:22 <jdrake> There is a win32 function, GetFileSize(), that I need to be able to use (or rather vastly prefer its use). I cannot find anything in the libraries that does it, is there an easy way to be able to make use of it?
22:16:45 <dmwit> fmap length . readFile -- ?
22:17:03 <dmwit> Actually, that's not really the same.
22:17:36 <jdrake> dmwit: The problem with opening a file is that it might be locked. Although I am willing to do that IF the other is more effort then justified.
22:18:43 <dmwit> Maybe hFileSize?
22:18:58 <oerjan> weird that it's not in System.Win32.File
22:19:28 <Olathe> > let evenLength = not.oddLength; oddLength (_:_:xs) = oddLength xs; oddLength [x] = True; oddLength [] = False in evenLength [1..]
22:19:29 <jdrake> dmwit: I have not seem hFileSize, I have only seen a reference to it. Where can this be found?
22:19:33 <lambdabot> Terminated
22:19:34 <Olathe> Not so many nots.
22:19:42 <dmwit> System.IO
22:20:12 <oerjan> Olathe: why don't you make even and odd mutually recursive?
22:20:27 <dmwit> Olathe: On [1..], that doesn't have a reasonable answer.
22:20:38 <Olathe> dmwit: I know :)
22:20:43 <dmwit> ok
22:20:45 <dmwit> =)
22:20:48 <ddarius> > let even = liftM2 (||) (0==) (not . odd); odd = not . even in odd 32
22:20:57 <lambdabot> Terminated
22:21:16 <jdrake> dmwit: Thank you, I think I might try with that.
22:21:18 <Olathe> oerjan: I think it will require more code in the cache or something.
22:21:32 <jdrake> I think I have to think about what can fail in my program as well, to be thorough.
22:21:39 <dmwit> jdrake: See also getFileStatus and friends in System.Posix.Files
22:22:11 <jdrake> posix won't work here
22:22:19 <oerjan> Olathe: ah.
22:22:24 <dmwit> Are you sure?
22:22:49 <jdrake> *Main> import System.Posix
22:22:51 <jdrake> Could not find module `System.Posix':
22:23:09 <oerjan> jdrake: there is some posix-compat library or something for partial windows support i think
22:23:15 <Olathe> Now that I think about it, it might slim it down to define evenLength without oddLength.
22:23:27 <Olathe> Even less nots, too.
22:23:28 <oerjan> but you may have to install it?
22:23:33 <ddarius> > even . length $ [1..]
22:23:38 <lambdabot> Terminated
22:24:02 <dmwit> :t even
22:24:06 <dmwit> :t Prelude.even
22:24:09 <lambdabot> forall a. (Integral a) => a -> Bool
22:24:09 <lambdabot> forall a. (Integral a) => a -> Bool
22:24:19 <oerjan> ddarius: you mean genericLength
22:24:27 <dmwit> Olathe: Maybe evenLength = even . genericLength?
22:24:32 <oerjan> this is a _large_ list, Ints won't do
22:24:35 <Olathe> @src genericLength
22:24:35 <lambdabot> genericLength []    = 0
22:24:35 <lambdabot> genericLength (_:l) = 1 + genericLength l
22:24:44 <Olathe> That requires lots of adding and so on.
22:24:50 <ddarius> That would be a type error, unresolvable class constraint
22:25:08 <ddarius> Though I guess it would default to Integer
22:25:15 <ddarius> > even . genericLength $ [1..]
22:25:19 <lambdabot> Terminated
22:25:29 <Olathe> For speed, no operations except recursing through the list.
22:25:38 <Olathe> (by twos at that)
22:26:04 <oerjan> perhaps Word1 would be a good idea to use
22:26:10 <oerjan> going the other way
22:26:22 <Olathe> Maybe the pattern matching is slower than the nots.
22:26:44 <dmwit> > let evenLength [] = True; evenLength [_] = False; evenLength (_:_:xs) = evenLength xs; oddLength = not . evenLength in evenLength [1..]
22:26:48 <lambdabot>  Terminated
22:27:18 <dmwit> one not
22:28:16 <conal> i'm surprised not to see Bounded instances for Float or Double.  are these instances not definable?
22:28:30 <dmwit> jdrake: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/unix-compat-0.1.2.1
22:28:31 <lambdabot> http://tinyurl.com/3dlrps
22:29:08 <oerjan> conal: not portably perhaps
22:29:31 <conal> oerjan: yeah -- that's probably it.
22:29:53 <jdrake> Any ideas how to get this to work? printf "%12s %7d %s\n" date size name   size should be an Integer
22:30:34 <oerjan> jdrake: printf sometimes has trouble deciding which type to use, add explicit declarations
22:30:50 <jdrake> a type declaration for my function?
22:31:08 <oerjan> no, for the arguments to printf
22:31:11 <dmwit> (date :: String) (size :: Integer) (name :: String)
22:31:21 <jdrake> oh, ok
22:31:33 <oerjan> it's only necessary if they're not decidable in some other way
22:32:58 <jdrake> Monad problem again. It appears that size is inferred as an IO Integer
22:33:07 <oerjan> ah.
22:33:10 <jdrake> sizes <- forM files getFileSize
22:33:14 <jdrake> That is where I get it from
22:33:22 <jdrake> But shouldn't that have stripped IO off?
22:33:36 <dmwit> > 7*7*7 + 7*7 + 7
22:33:37 <oerjan> on sizes yes. how do you define size?
22:33:37 <lambdabot>  399
22:33:44 <conal> back to Bounded for Float/Double, how about minBound = -1/0; maxBound = 1/0 ?
22:33:56 <dmwit> > 399 + 7*7*7*7
22:33:57 <lambdabot>  2800
22:33:59 <oerjan> :t getFileSize
22:33:59 <lambdabot> Not in scope: `getFileSize'
22:34:29 <hpaste>  jdrake pasted "ls.hs" at http://hpaste.org/4212
22:34:47 <jdrake> Code in there
22:35:06 <oerjan> :t hFileSize
22:35:07 <lambdabot> Not in scope: `hFileSize'
22:35:12 <oerjan> :t System.IO.hFileSize
22:35:13 <lambdabot> GHC.IOBase.Handle -> IO Integer
22:35:30 <oerjan> that let in getFileSize needs to use <- instead
22:36:38 <jdrake> funny stuff - there is a problem with this method because I can't open '.'
22:36:55 <jdrake> So I best look at that other package that was pointed out.
22:37:02 <oerjan> ouch
22:37:28 <dmwit> What happens if you put 'getDirectoryContents "."' at the ghci prompt?
22:37:44 <dmwit> (After :m + Whatever.The.Right.Module.Is, of course.)
22:38:42 <jbauman> > 1.0 / (1.0 - 7.0) - 7.0*7.0*7.0*7.0*7.0/(1.0-7.0)
22:38:42 <lambdabot>  2801.0
22:38:54 <jdrake> Good thing irssi catches pasting. These two lines wanted to paste 12 here.
22:38:56 <jbauman> > 1.0 / (1.0 - 7.0) - 7.0*7.0*7.0*7.0*7.0/(1.0-7.0) - 1.0
22:39:00 <lambdabot>  2800.0
22:39:16 <jdrake> *Main> getDirectoryContents "."
22:39:16 <jdrake> [".","..","ls.hi","ls.hs","ls.o","main.exe","main.exe.manifest"]
22:39:43 <dmwit> Does that look right?
22:39:49 <jdrake> It is exactly right.
22:39:58 <dmwit> If so, you may want to figure out if you have a bug in your current code before you go chasing another package. =)
22:40:08 <oerjan> is the problem that it's a directory perhaps?
22:40:14 * dmwit doesn't see anything wrong right off the bat, though
22:40:17 <jdrake> oerjan: that is exactly it
22:40:40 <jdrake> There is a solution, catch the error and ignore it
22:40:43 <dmwit> Oh, I see what your saying.
22:41:03 <dmwit> I thought it was failing at getDirectoryContents, but it is actually failing at getFileSize or so?
22:41:10 <jdrake> yes
22:41:24 <jdrake> So what should I look at for catching these errors?
22:41:42 <dmwit> :t catch -- =(
22:41:44 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
22:41:48 <oerjan> jdrake: you may filter away directories with doesFileExist
22:41:56 <dmwit> jdrake: But maybe you want to filter directories out instead.
22:42:07 * dmwit gets out of oerjan's way
22:42:28 <oerjan> :t filterM System.Directory.doesFileExist
22:42:29 <lambdabot> [FilePath] -> IO [FilePath]
22:44:17 <jdrake> oerjan: There is a problem with this - no directories are able to be shown.
22:44:28 <jdrake> Of course, I could treat them differently
22:45:44 <jdrake> files <- filterM doesFileExist =<< getDirectoryContents "."
22:45:58 <jdrake> nice it works
22:46:57 <jdrake> So, I have a basic ls working. I suppose I can look into adding some parameter support to it, or I can work on a du, which would be the next logical program.
22:47:58 <dmwit> Are you doing this to learn the language?
22:48:05 <jdrake> yes
22:48:09 <dmwit> Cool!
22:48:22 <jdrake> I haven't made it this far with this level of understanding before now.
22:48:23 <dmwit> How do you like Haskell's IO so far?
22:48:27 <oerjan> seems that partitionM is missing, would have been nice to get the directories too
22:48:42 <jdrake> dmwit: I believe it is manageable.
22:48:58 * dmwit chuckles
22:49:25 <jdrake> dmwit: I also have a friend who used to be a system administrator. He is extremely skeptical about the viability of functional programming languages owing to his conservative nature.
22:49:58 <allbery_b> funny, sysadmin is a large part of why I became interested in Haskell
22:50:50 <allbery_b> (1) strong typing -> safer programs; (2) observation: most system confguration management tools work a lot like non-strict evaluation
22:51:34 <jdrake> allbery_b: Keeping something UP usually leads one to be conservative about what they do.
22:51:41 <allbery_b> sure
22:52:01 <allbery_b> programs that are more likely to work successfully help a lot with keeping things UP / not breaking them
22:52:09 <jdrake> He has done C and Perl a lot.
22:52:22 <allbery_b> no wonder he doesn't trust new stuff :)
22:52:22 <jsnx> allbery_b: could you say more about (2) ?
22:52:44 <jdrake> He also believes that the syntax of a language tends to restrict your expressiveness.
22:53:10 <dmwit> jsnx: Consider package management.  There's always a separation between selecting *what* you want to install, and actually installing it.
22:53:20 <dmwit> That's lazy installation, in a sense.
22:53:39 <jdrake> @src Text.Printf.printf
22:53:39 <lambdabot> Source not found. You untyped fool!
22:53:45 <allbery_b> jsnx: it's still something of a vague notion, but practical SCM is generally about doing the minimum necessary to bring a system into spec.  non-strict eval leads to only performing things that need to be performed
22:53:47 <jdrake> @src printf
22:53:47 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
22:54:00 <allbery_b> @source Text.Printf
22:54:00 <lambdabot> http://darcs.haskell.org/packages/base/Text/Printf.hs
22:54:06 <allbery_b> that won't work :(
22:54:30 <allbery_b> printf is too large to fit into @src without major channel spam
22:54:44 <allbery_b> use the source link at the top of the libraries page for Text.Printf
22:55:06 <oerjan> actually not:
22:55:07 <oerjan> printf :: (PrintfType r) => String -> r
22:55:07 <oerjan> printf fmt = spr fmt []
22:55:09 <jsnx> dmwit: i agree
22:55:27 <oerjan> not that this helps any :D
22:55:32 <jsnx> it would be nice if file synchronization tools handled things this way
22:55:37 <jdrake> It looked almost like printf used some magic.
22:55:48 <jdrake> I have experienced the magic of ocaml's printf.
22:55:49 <jsnx> generated a list of actions, and then allowed you to perform them
22:55:51 <dmwit> It uses a metric ton of magic.
22:55:52 <conal> anyone know of a reason that join isn't a method of Monad.  if it were, then (>>=) and join could be defaulted in terms of each other, and one would be free to define either, as convenient.
22:55:53 <oerjan> jdrake: the magic is in the type
22:56:15 <jdrake> Actually, I find Haskell so far is easier than ocaml.
22:56:43 <allbery_b> anyway, SCM is one of my specializations, you could say, but I'm still something of a beginner to it.  I have this notion that Haskell could simplify existing CM tools because much of the work they do in order to *not* do unnecessary things would be more or less automatic
22:57:27 <jdrake> What is SCM?
22:57:38 <allbery_b> and the more I work with both, the clearer a view I get of it.
22:57:38 <jsnx> jdrake: VCS
22:57:43 <allbery_b> system configuration management
22:57:44 <jdrake> ah
22:58:01 <allbery_b> stuff like cfengine, bcfg2, lcfg, puppet ...
22:58:21 <jsnx> printf disappoints me
22:58:33 <jdrake> allbery_b: What do you think about a purely functional language that configures a webserver with dozens of domains and virtual domains, mail handling, and the like?
22:58:39 <allbery_b> or see http://infrastructures.org
22:58:40 <lambdabot> Title: Infrastructures.Org: Best Practices in Automated Systems Administration and Infr ...
22:58:43 <jsnx> for example, `printf "%10s" really_long_string` prints a long string
22:59:09 <jsnx> as opposed to a ten character string
22:59:11 <allbery_b> jsnx: pintf behavior is defined by ANSI C
22:59:15 <allbery_b> you want %.10s
22:59:21 <jsnx> allbery_b: aha
22:59:40 <jdrake> The future has arrived! http://wiki2.hcoop.net/DomTool/
22:59:40 <lambdabot> Title: DomTool - HCoop Wiki
22:59:55 <allbery_b> depends on how much it manages and how
23:00:03 <jsnx> uhm, doesn't work
23:00:07 <jdrake> Checkout the 'working examples'
23:00:11 <allbery_b> one of the problems with SCM is that not everyone can do it the same way
23:00:34 <jsnx> > printf "%.5s" "0123456789"
23:00:35 <lambdabot>  Add a type signature
23:00:44 <allbery_b> so for example lcfg does cookie-cutter stuff, all machines in a class are identical; bcfg2 lets you have one-offs (we manage research machines)
23:00:50 <jsnx> > (printf "%.5s" "0123456789") :: String
23:00:51 <lambdabot>  "0123456789"
23:01:01 <jsnx> see
23:01:02 <allbery_b> hm, that seems broken
23:01:16 <jsnx> > (printf "%.5c" "0123456789") :: String
23:01:18 <lambdabot>  Exception: Printf.printf: bad argument
23:01:27 <jdrake> > printf "%5.2f\n" (4.2::Integer)
23:01:27 <lambdabot>   add an instance declaration for (Fractional Integer)
23:01:27 <lambdabot>     In the expression:...
23:01:36 <jdrake> > printf "%5.2f\n" (4.2::Real)
23:01:36 <lambdabot>      Class `Real' used as a type
23:01:36 <lambdabot>     In the type `Real'
23:01:36 <lambdabot>     In an expression ...
23:01:41 <jdrake> hmm
23:01:45 <allbery_b> Double
23:01:46 <oerjan> Double
23:01:48 <jdrake> > printf "%5.2f\n" (4.2::Double)
23:01:48 <lambdabot>  Add a type signature
23:02:08 <jsnx> jdrake: use `:: String` at the end
23:02:20 <jdrake> (> printf "%5.2f\n" (4.2::Double))::String
23:02:25 <jdrake> >( printf "%5.2f\n" (4.2::Double))::String
23:02:26 <allbery_b> printf's return type determines whether it writes to stdout or produces a string
23:02:30 <jsnx> (printf "%5.2f\n" 4.2) :: String
23:02:34 <allbery_b> (the former being forbidden in lambdabot...)
23:02:34 <jsnx> > (printf "%5.2f\n" 4.2) :: String
23:02:35 <lambdabot>  " 4.20\n"
23:02:41 <jdrake> > (printf "%5.2f" (4.2::Double))::String
23:02:42 <lambdabot>  " 4.20"
23:02:45 <jsnx> > (printf "%5.2f\n" 4.212354627326) :: String
23:02:46 <lambdabot>  " 4.21\n"
23:02:53 <nanothief> pl \x y -> x y
23:03:04 <allbery_b> I should mention that I'm unhappy with haskell's printf bu am not quite up to fixing it
23:03:29 <jdrake> > (printf "%X %x" 27 27)::String
23:03:30 <lambdabot>  Exception: Printf.printf: bad formatting char X
23:03:38 <jdrake> wtf?
23:04:02 <allbery_b> there's an example f what I'm unhappy with
23:04:10 <nanothief> > pl \x y -> x y
23:04:10 <lambdabot>  Parse error at "\x" (column 4)
23:04:22 <glguy> nanothief: id
23:04:24 <allbery_b> it also doesn't support ANSI field syntax for integers (%n.md)
23:04:29 <allbery_b> @pl
23:04:29 <lambdabot> (line 1, column 1):
23:04:29 <lambdabot> unexpected end of input
23:04:29 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
23:04:36 <allbery_b> @pl \x y -> x y
23:04:37 <lambdabot> id
23:04:45 <nanothief> oh cool
23:04:47 <allbery_b> @localtime
23:04:48 <lambdabot> Local time for allbery_b is Sun Dec  2 02:04:48
23:04:52 <allbery_b> I should go to bed already...
23:04:59 <jdrake> What should I look into for catching IO errors?
23:05:08 <hpaste>  conal pasted "Monad instance for (,) o  and a question" at http://hpaste.org/4213
23:05:46 <oerjan> catch, although there are two versions of it
23:06:36 <oerjan> the Control.Exception one can catch other things than IO errors as well
23:07:12 <nanothief> @pl \(a,b) (c,d) -> compare a c
23:07:12 <lambdabot> (`ap` snd) . (. fst) . (const .) . compare . fst
23:07:19 <allbery_b> conal: there's discussion in -cafe archives about why join isn't part of Monad
23:07:30 <conal> allbery_b: oh?
23:07:32 <oerjan> oh and that module contains useful variations too
23:07:37 <conal> allbery_b: remember any keywords for searching?
23:07:45 <allbery_b> I think "historical accident" might cover it
23:07:52 <allbery_b> not offhand
23:07:56 <conal> :) !
23:07:58 <jdrake> I think I might have found something on it.
23:08:13 <wy> Are there any comparisons of Haskell and OCaml in performance around?
23:08:39 <jdrake> catch getLine'' (\err -> return ("Error: " ++ show err)) where getLine'' = ...
23:09:00 <allbery_b> that is, join was made part of Functor before Monad was added, or something like that, so it's stuck there now
23:09:07 <allbery_b> @src Functor
23:09:08 <lambdabot> class  Functor f  where
23:09:08 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
23:09:11 <allbery_b> hm, no
23:09:20 <allbery_b> don't recall where join lives now
23:09:22 <allbery_b> @src join
23:09:22 <lambdabot> join x =  x >>= id
23:09:29 <allbery_b> ah.
23:09:31 <allbery_b> right
23:09:39 <conal> allbery_b: join isn't in functor
23:09:52 <conal> (oh, just read your second comment)
23:09:59 <allbery_b> they chose the return/bind implementation, join was an afterthought
23:10:00 <conal> join stands alone.
23:10:05 <jsnx> too bad you have to spoon feed printf
23:10:06 <allbery_b> there's been some ranting about that choice
23:10:21 <conal> i'd think we could change join, as long as the current definition were true as an equation.
23:10:41 <oerjan> jsnx: it works better inside a context
23:10:45 <allbery_b> I'm uncertain
23:11:12 <allbery_b> but it might be possible to make that a default, then provide a default of >>= in terms of join and allow someone to define either
23:11:30 <allbery_b> except the error messages would *suck* if someone forgot to define either or made a mistake in the definition
23:11:45 <allbery_b> and the Haskell committee seems to have been terrified of that idea
23:11:56 <allbery_b> (see also monad comprehensions)
23:12:02 <oerjan> so why did they allow it for Ord? :)
23:12:18 <allbery_b> easier to decipher, compared to monads
23:12:23 <dmwit> Who writes Ord instances?
23:12:44 <allbery_b> and yes, most Ord instances are auto-derived
23:13:07 <conal> allbery_b: i'd say define >>= and join in terms of each other.  with one or the other plus return as "minimal required".
23:13:17 <conal> pretty standard practice in haskell type classes.
23:13:23 <allbery_b> sure, but there's no wa to enforce the requirement
23:13:57 <conal> allbery_b: standard situation.
23:14:02 <conal> monad is no dft
23:14:04 <conal> different
23:14:26 * allbery_b thinks he just ran through why it's problematic
23:15:12 <oerjan> it should be possible for strictness analysis to detect cyclic defaults...
23:15:49 <conal> allbery_b: but not why to make an exception of Monad
23:15:58 <conal> by avoiding mutually referential defaults.
23:16:17 <allbery_b> because Monad is harder to debug than, say, Ord
23:16:31 <allbery_b> (just by being higher order)
23:16:53 <allbery_b> and, as I said earlier, the H98 committee seems to have been afraid of that
23:16:53 <conal> allbery_b: the bugs would be exactly the same in both cases and give the same error message, which is non-termination.
23:17:03 <conal> even before getting to the higher-order part.
23:17:36 <conal> allbery_b: okay.  thanks for the input.  i'll take it up on the mailing list.
23:17:54 <conal> maybe someone there will point me to previous discussions.
23:17:56 <oerjan> hm wait can you define >>= in terms of join without a Functor instance?
23:18:15 <conal> oerjan: oh ...
23:18:21 <allbery_b> there's another example of brokenness in h98 :)
23:18:30 <conal> maybe that's the historical accident
23:18:51 <conal> like Monad not deriving from Applicative
23:18:57 <conal> a much more recent example
23:19:58 <allbery_b> at least one could experiment with changing that
23:20:36 <allbery_b> (you can't with e.g. alternative numeric hierarchies because some behavior is wired into ghc)
23:21:09 <allbery_b> well, you can't fully.  there's some experimentation
23:25:59 <ddarius> Indeed, m >>= f = join (fmap f m)
23:36:29 <dmwit> Is it required that main :: IO ()?
23:36:36 <dmwit> I mean, by the standard.
23:36:53 <dmwit> GHC clearly accepts main :: IO [String], for example.
23:37:39 <oerjan> "The value of the program is the value of the identifier main in module Main, which must be a computation of type IO t for some type t"
23:37:47 <oerjan> section 5
23:38:07 <dmwit> cool!
23:38:24 <dmwit> A bit pointless, but cool anyway.
23:39:05 <oerjan> the result is always discarded
23:39:26 <conal> too bad about the type of main, since it inherently means that haskell programs are not composable.
23:39:51 <oerjan> er what?
23:40:06 <oerjan> too bad about the result being discarded, you mean?
23:41:32 <conal> not just that.  it encourages/requires mixing I/O code in with the functionality.  composing (more than trivially) requires extracting that I/O code back out, so the functionality can talk the the other functionality.
23:42:47 <conal> which is what my "modern marriage of usability and composability" talk is about.
23:43:14 <conal> (google techtalk)
23:44:46 <xpika> my pixmap renders black!
23:44:51 <xpika> @paste
23:44:51 <lambdabot> Haskell pastebin: http://hpaste.org/new
23:44:56 <conal> xpika: don't you like black?
23:45:10 <oerjan> i would say that's taking a dark view of it
23:45:17 <conal> lol
23:45:40 <conal> xpika: maybe you're zoomed way in.
23:45:48 <conal> or forgot to turn the lights on
23:45:51 <hpaste>  xpika pasted "just black" at http://hpaste.org/4214
23:45:56 <basti_> any color you like as long as it's black...
23:46:11 <conal> basti_: :)
23:46:13 <xpika> I prefer transparency
23:46:31 <conal> xpika: yes.  no secrets please.
23:47:01 <ddarius> Why is your indentation so inconsistent?
23:47:44 <xpika> I've never used Pixmap new before.
23:49:28 <conal> ack.  that's some imperative code!  is that what gtk2hs code looks like?
23:50:07 <conal> btw, am i alone in distinguishing between functional programming and imperative programming in a functional language?
23:50:11 <ddarius> It (this code in particular) definitely has that C-style look to it.
23:50:41 <ddarius> conal: Most experienced functional programmers can immediately tell by the "shape" of the code.
23:50:43 <xpika> conal: no, I think that's IO's job
23:50:43 <conal> i.e., (a) functional programming, and (b) imperative programming in a functional language
23:50:56 <basti_> definitely not conal
23:50:58 <conal> ddarius: can tell which is which?
23:51:17 <conal> :) phew!
23:51:20 <ddarius> conal: Yes.
23:51:20 <basti_> i don't think imperative code is necissairly bad though
23:51:38 <ddarius> basti_: Not necessarily, but it definitely has a different shape than functional code.
23:51:41 <conal> ddarius: you mean you don't distinguish?
23:51:41 <basti_> yes
23:51:49 <jdrake> ddarius: Isn't the imperative code usually lined up and other stuff more indents?
23:52:00 <ddarius> jdrake: That's part of it.
23:52:18 <ddarius> conal: I do distinguish as I believe most can and do immediately.
23:52:54 <conal> so i wonder why i've been reading people refering to haskell IO programming as "functional programming".
23:53:03 <ddarius> jdrake: Another significant difference is FP encourages more, smaller functions.
23:53:27 <conal> for me it's about whether there's a simple semantics.  for IO, no.  for lists, images, animation, etc, yes.
23:53:44 <conal> and no for anything that exposes IO or depends on IO for its semantics.
23:54:05 <conal> in other words, the properties that are "good for reasoning".
23:54:14 <xpika> haskell: types functions implict , IO explicit , C: IO implicit, types ,function explicit
23:55:00 <conal> yep, it's nice to have the presence of IO (absence of tractable semantics) made explicit.
23:55:26 <conal> in other words to mark and check when we're doing functional programming and when imperative in a functional language.
23:56:08 <conal> but i get the impression that most haskell programmers are content with using IO instead of always looking for functional alternatives.
23:56:16 <flux> I would still call IO in haskell functional. an IO function must always do the same steps to perform its operation, given the same inputs
23:56:48 <flux> I suppose that's a bit hair splitting though, because one of the steps might be retrieve_a_random_number () ;)
23:57:10 <conal> flux: are you calling the whole physical universe part of the "same inputs"?
23:57:23 <flux> no
23:57:24 <conal> because that's what IO can access.
23:57:44 <dmwit> conal: You are perhaps coming down too hard on IO.
23:57:44 <conal> then an IO can do different things for the same inputs
23:57:46 <flux> but if that's the first IO operation of a function does with parameter 1, then the next calls with the same argument must call perform the same operation first
23:57:54 <conal> dmwit: how hard is too hard?
23:58:06 <dmwit> At the very least, the same IO computation is built each time the program runs.
23:58:28 <dmwit> In my opinion, that is a pretty powerful result of functional programming.
23:58:36 <conal> dmwit: yes, but it has intractable semantics.  so no non-trivial reasoning is possible.
23:58:45 <conal> so what's the use
23:58:52 <dmwit> I don't think that's totally true.
23:59:11 <dmwit> SPJ gives an operational semantics for IO in Tackling the Awkward Squad, for example.
23:59:19 <conal> flux: what if that first operation is to ignore parameter 1 and look at the time?
23:59:27 <flux> the use is that it doesn't break the functional model: IO is simply a convenient way of constructing an interactive stream of IO for the runtime to perform
23:59:30 <dmwit> I agree: having additional abstractions on top of IO that make user interaction easier is a big win.
23:59:32 <conal> dmwit: for only a subset, I believe.
23:59:36 <dmwit> But IO is not so terrible.
23:59:51 <dmwit> conal: Okay, a subset.
23:59:59 <flux> conal, how would you write an IO function that sometimes ignores the parameter and sometimes doesn't, without doing some IO before that decision?
