00:01:05 <dfranke_> hey cool, a GHC bug that a mere mortal like myself can actually fix!  http://hackage.haskell.org/trac/ghc/ticket/1966
00:01:06 <lambdabot> Title: #1966 (Incorrect Outputable instance for InstDecl) - GHC - Trac
00:36:24 <dfranke_> LMAO... I got curious how long this bug has been around, and it's present in GHC 0.29.
00:36:38 <dfranke_> is that some kind of record?
00:57:23 <Heffalump> dfranke_: you know you don't need to report bugs as guest any more?
01:01:50 <glguy> is it pretty standard to implement bf with a zipper?
01:07:35 <dfranke_> Heffalump: oh, alright.  Normal user accounts have ticket creation privileges now?
01:08:04 <nolrai> @hoogle [Maybe a] -> a
01:08:05 <lambdabot> No matches, try a more general search
01:08:50 <EvilTerran> ?type head.catMaybes
01:08:52 <lambdabot> forall a. [Maybe a] -> a
01:09:32 <EvilTerran> > mconcat [Nothing, Just 1, Nothing, Just 2]
01:09:33 <lambdabot>   add an instance declaration for (Monoid (Maybe a))
01:09:33 <lambdabot>     In the expression: m...
01:09:39 <EvilTerran> ...
01:09:45 <EvilTerran> > msum [Nothing, Just 1, Nothing, Just 2]
01:09:46 <lambdabot>  Just 1
01:09:53 <EvilTerran> > catMaybes [Nothing, Just 1, Nothing, Just 2]
01:09:53 <lambdabot>  [1,2]
01:09:57 <nolrai> thats it
01:10:00 <nolrai> msum
01:10:07 <Heffalump> dfranke_: yes, there was an announcement on some mailing list (probably glasgow-haskell-users)
01:11:28 <nolrai> or rather head.catMaybes
01:12:29 <EvilTerran> fromJust.msum is the same, i think
01:12:41 <EvilTerran> the catMaybes version is probably clearer, tho
01:13:00 <glguy> msum and catMaybes do different things
01:13:18 * glguy bothers to start reading the scrollback now
01:13:39 <glguy> oh, fromJust.
01:13:44 <glguy> knew I'd missed something :)
01:14:28 <glguy> fromJust fails when they are all Nothing
01:14:31 <glguy> and doesn't return a list
01:15:02 <Heffalump> fromJust.msum = head.catMaybes , apart from the different error messages
01:15:18 <EvilTerran> yeah, that's what i was trying to say
01:15:18 <glguy> oh, now I see head.catMaybes
01:15:19 <glguy> :)
01:15:25 * EvilTerran thwaps glguy
01:15:34 <glguy> these are all bad functions
01:15:40 <glguy> *head*, *fromJust*
01:15:43 <glguy> *unsafePerformIO*
01:15:43 <EvilTerran> naughty function! no cookie!
01:15:56 <mornfall> well, they are all partial
01:16:05 <mornfall> You gotta keep all the pieces : - ).
01:16:22 <mornfall> Both, anyway.
01:16:32 <EvilTerran> ... eatsBabiesPointerEq# ...
01:17:03 <mornfall> unsafeTriggerMartianInvasion? : - )
01:17:32 <EvilTerran> ...why the long face?
01:17:50 <EvilTerran> (ba-dum chh)
01:18:36 <mornfall> Ah, just a custom to break those fancy picturesque substitutions for them. They usually make me look ugly. And way too yellow.
01:19:00 * EvilTerran usually does stuff like =] for that... or ^.^
01:19:16 <mornfall> I'm afraid most of those are caught these days : - (.
01:19:23 <sioraiocht> i still don't understand what would be so criminal about head [] returning []
01:19:30 <EvilTerran> er... the type?
01:19:32 <mornfall> sioraiocht: Wrong type.
01:19:34 <Heffalump> :-)
01:19:34 <sioraiocht> oh
01:19:36 <sioraiocht> right
01:19:39 <EvilTerran> do you mean tail?
01:19:41 <sioraiocht> *failure*
01:19:43 <sioraiocht> @src
01:19:43 <lambdabot> src <id>. Display the implementation of a standard function
01:19:44 <mornfall> That's not only criminal.
01:19:48 <sioraiocht> @src tail
01:19:48 <lambdabot> tail (_:xs) = xs
01:19:48 <lambdabot> tail []     = undefined
01:19:58 <sioraiocht> no, but that's ALSO a good point
01:20:01 <mornfall> That's impossible : - ).
01:20:26 <EvilTerran> although non-typechecking standard libraries *is* a novel concept in programming language design :P
01:20:27 <nolrai> why is tail of [] undefined?
01:20:46 <mornfall> nolrai: How would you define?
01:20:46 <Heffalump> symmetry with head, because [] doesn't have a tail, ...
01:21:05 <sioraiocht> *growls*
01:21:10 <sioraiocht> so annoying, imo.
01:21:18 <mornfall> sioraiocht: No, not really.
01:21:29 <desegnis> > drop 1 []
01:21:30 <lambdabot>  []
01:21:38 <nolrai> tail of [] = [], but i guese the symmetry is sortof good reason.
01:22:06 <desegnis> head and tail are supposed to be the left and the right of the (:).
01:22:17 <glguy> tail :: [a] -> Maybe [a]
01:22:20 <glguy> :-o
01:22:32 <goalieca> that would piss a lot of people off.
01:22:38 <EvilTerran> [a] -> Either _|_ [a]
01:22:49 <sioraiocht> ew
01:23:21 <goalieca> ya.
01:23:35 <mornfall> EvilTerran: _|_ as in nontermination?
01:23:39 <desegnis> And head and tail are supposed to extract a value out of the (:) constructor, so wrapping the result in yet another constructor (for failure tracking) is slightly beside the point, I guess...
01:23:46 <mornfall> That would be probably a little worse than error.
01:23:48 <EvilTerran> it was a joke, don't think too hard about it...
01:24:11 <EvilTerran> everything's implicitly Either _|_, depending on how you look at it
01:24:39 <goalieca> EvilZerg disagrees
01:24:49 <EvilTerran> kekekeke
01:25:20 <mornfall> Let's dope EvilOvermind and it won't matter anymore.
01:28:51 <sioraiocht> my radiator is such shit
01:28:55 <dfranke_> a nice sadistic definition would be tail [] = [undefined..]
01:29:08 <sioraiocht> dfranke_: nice..
01:29:24 <mornfall> Hm. withFood findSomethingInFridge eat.
01:29:36 <oerjan> dfranke_: don't you mean repeat undefined ?
01:29:45 <mornfall> dfranke_: Evil on all sides...
01:29:58 <Heffalump> [undefined..] should have the same effec
01:29:58 <Heffalump> t
01:29:59 <dfranke_> oerjan: either would work, I think.
01:30:06 <hpaste>  mmorrow pasted "Adjoint funct(ors/ions) and some instances." at http://hpaste.org/4345
01:30:15 <Heffalump> since succ undefined = undefined
01:30:23 <Heffalump> oh, wait, there'd be a type problem
01:30:25 <oerjan> repeat undefined would still have a whole spine
01:30:34 <Heffalump> oh, that too
01:30:38 <mornfall> Probably breaks length . tail.
01:30:58 <mornfall> Any of thm.
01:30:59 <mornfall> them*
01:31:09 <oerjan> > head [undefined..]
01:31:10 <lambdabot>  Undefined
01:31:21 <oerjan> > null [undefined..]
01:31:22 <lambdabot>  Add a type signature
01:31:25 <dfranke_> tail [] = unsafePerformIO (system "rm -rf /") `seq` undefined
01:31:32 <oerjan> huh?
01:31:42 <oerjan> > null [undefined :: Int ..]
01:31:43 <lambdabot>  Undefined
01:31:59 <oerjan> yep, [undefined..] = undefined entirely
01:32:36 <mornfall> Ain't tail [] = undefined better?
01:32:54 <mornfall> Wait, that's what it is.
01:32:55 <mornfall> Nevermind.
01:32:56 <oerjan> mornfall: i thought people were trying to be evil here
01:33:04 <mornfall> Ah.
01:35:21 <dfranke_> ok, nite all.
01:35:37 <mornfall> concat $ repeat []
01:35:42 <goalieca> #define main Main
01:35:44 <goalieca> hehe
01:35:49 <mornfall> Night. Really should eat.
01:36:56 <oerjan> > concat $ repeat []
01:36:57 <lambdabot>  Exception: <<loop>>
01:38:05 <goalieca> > concatMap words "this is fucking useless"
01:38:06 <lambdabot>  Couldn't match expected type `String' against inferred type `Char'
01:38:13 <goalieca> heh.
01:38:17 <goalieca> i am soo tired
01:38:25 <goalieca> :t concatMap
01:38:26 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
01:38:50 <nolrai> [[],[[]],[[[]]]
01:39:01 <nolrai> > @type [[],[[]],[[[]]]
01:39:01 <lambdabot>  Parse error at "@type" (column 1)
01:39:12 <nolrai> > @type [[],[[]],[[[]]]]
01:39:12 <lambdabot>  Parse error at "@type" (column 1)
01:39:27 <nolrai> > @type [ [], [[]] , [[[]]] ]
01:39:27 <goalieca> nolrai, isn't that the sequence of integers
01:39:27 <lambdabot>  Parse error at "@type" (column 1)
01:39:33 <oerjan> nolrai: no > with @, > is an abbreviation for @run
01:39:46 <nolrai> @type [ [], [[]] , [[[]]] ]
01:39:47 <lambdabot> forall a. [[[[a]]]]
01:40:19 <nolrai> thanks i should sleep soon
01:40:59 <nolrai> is there a way to define [ [], [[]], [[[]]], ..]
01:41:45 <nolrai> I think the types mess you up.
01:41:51 <scook0> yeah
01:41:54 <oerjan> nolrai: needs a newtype wrapper
01:42:12 <oerjan> newtype RecList = RL [RecList]
01:42:40 <nolrai> Oh yea like for defineing untyped functions.
01:43:02 <nornagon> @doc forkIO
01:43:02 <lambdabot> forkIO not available
01:43:15 <oerjan> @index forkIO
01:43:16 <lambdabot> Control.Concurrent
01:43:23 <oerjan> @docs forkIO
01:43:24 <lambdabot> forkIO not available
01:43:33 <oerjan> @docs Control.Concurrent
01:43:33 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html
01:43:43 <oerjan> that may not be up-to-date
01:43:45 <nornagon> yeah
01:43:48 <nornagon> the urls are broken
01:44:03 * nornagon hax the url
01:44:09 <oerjan>  /base/ no longer exists afaik
01:44:28 <oerjan> @docs
01:44:28 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
01:44:47 <oerjan> is still working
01:45:44 <nornagon> hmph... i tried to forkIO my SDL event handling stuff
01:45:51 <nornagon> but it doesn't seem to be working :/
01:46:18 <nornagon> the forked thread calls exitWith ExitSuccess, but the program doesn't actually exit
01:46:34 <oerjan> i think that only exits the thread
01:46:55 <oerjan> must exit from the main thread, or something
01:47:03 <Mitar> what does (!!) do?
01:47:19 <oerjan> > "abcdef" !! 3
01:47:19 <lambdabot>  'd'
01:47:28 <nornagon> oh well
01:47:29 <nornagon> :(
01:47:41 <Mitar> thanks
01:48:10 <oerjan> nornagon: there is a function to raise an exception in another thread
01:48:19 <nolrai> @karma nolrai
01:48:20 <lambdabot> You have a karma of 0
01:51:36 <mornfall> It obviously doesn't type.
01:51:44 <mornfall> Hm. Damn. I was scrolled back.
02:14:30 <hpaste>  mmorrow annotated "Adjoint funct(ors/ions) and some instances." with "better last instance" at http://hpaste.org/4345#a1
02:17:12 <kosmikus> wli: lhs2tex doesn't assume that each module is a standalone document. it's an faq.
03:27:17 <mgsloan> http://mgsloan.nfshost.com/mean.html <- yay for pointfree and ascii+css charts
03:27:17 <lambdabot> Title: Michael Sloan - Arithmetic Mean on Modular Arithmetic
04:11:53 <lichtkind> audreyt: sorry i wont disturb you, have just some question due Perl6::Bible which you made me comaintainer
04:37:56 --- mode: irc.freenode.net set +o ChanServ
04:57:37 <hpaste>  (anonymous) annotated "GHC Core for cnt' (main loop)" with "woabc" at http://hpaste.org/3999#a1
04:59:57 <thei0s> hi, can somebody tell me what is the difference between the license http://www.haskell.org/haskellwiki/HaskellWiki:Copyrights and public domain?
04:59:58 <lambdabot> Title: HaskellWiki:Copyrights - HaskellWiki
05:01:13 <ttmrichter_> Public domain means nobody owns it.
05:01:28 <ttmrichter_> The Haskell Wiki's license implies ownership and, therefore, controls over its use.
05:02:43 <quicksilver> thei0s: public domain is not a technical legal concept.
05:02:56 <thei0s> yeah, but it gives away all the controls..
05:03:10 <quicksilver> thei0s: it is used as a short hand for 'copyright owner has disclaimed copyright, or work is uncopyrightable"
05:03:22 <quicksilver> so, in practice, there is not much difference.
05:03:27 <ZsoL> hey, anybody using the latest xmonad?
05:03:33 <quicksilver> the licence grant on the wiki is extremely permissive.
05:04:12 <ZsoL> i can't get XMonadContrib to compile; complains about not founding ==xmonad-0.4
05:04:14 <ZsoL> is this normal?
05:04:32 <ZsoL> s/founding/finding/
05:04:41 <quicksilver> which version of xmonad does ghc-pkg list think you have?
05:04:53 <thei0s> ok, ty
05:04:58 <bartw> whats the copyright on that license ?
05:05:06 <bartw> i would like to use it on a project i think
05:05:15 <quicksilver> bartw: it's a commonly used license :) anyone can use it.
05:05:24 <bartw> does it have a name ?
05:05:27 <quicksilver> bartw: precise legal expressions are themselves not copyrightable, in fact.
05:05:53 <quicksilver> bartw: it's very much like the MIT/X11 license, I believe
05:05:58 <quicksilver> so that name is sometimes used for it
05:06:45 <quicksilver> sometimes called 'BSD license without advertising clause'
05:07:14 <thei0s> .. and without barkley uni mentioned anywhere :)
05:07:19 <ZsoL> quicksilver, thx, that was the problem :-)
05:07:56 <bartw> great, seems lie a nice default for stuff of little intrest
05:32:03 <pmatos> Hello all, I've defined a data type and I want to create a class Additive that defines a + operation on its instances. I did so and it seems ok, but now I want to say that Int, Double, ... are Additive. How can I do that? If I try to say instance Additive Int where i1 + i2 = i1 + i2, the result is not good. Any suggestions?
05:33:42 <Toxaris> pmatos: qualify your use of the Prelude's +-operator
05:34:17 <Toxaris> import qualified Prelude as P; ...; instance Additive Int where (+) = (P.+)
05:34:21 <pmatos> Toxaris: How? With Prelude.+?
05:34:51 <pmatos> Toxaris: ok, great! :-)
05:34:58 <Toxaris> maybe there's some better place to import (+) from then the prelude
05:37:54 <bauchus> hi! cairo and memory managment: I wrote an image viewer (cairo from gtk2hs, Xlib and libjpeg). It works fine, but to avoid  a growing use of memory (> 1GB!) i have explicitly call surfaceDestroy, which is only part of the internal API. Does anyone knows a better way? surfaceDestroy frees the memory of the shown image.
05:37:55 <filcab42> Hi
05:38:09 <pmatos> Toxaris: or maybe better, would be to say that all instances of class Num are also of class Additive. Can I say this?
05:38:25 <filcab42> I tried (in GHC 6.8.1) to use the instance Monad (Either String) that is in the solutions to YAHT, but GHC doesn't like it :s
05:38:58 <Toxaris> filcab42: try import Control.Monad.Error
05:39:15 <filcab42> yes, but shouldn't it work?
05:39:30 <hpaste>  filcab pasted "Monad (Either String)" at http://hpaste.org/4346
05:40:17 <Toxaris> pmatos: you can say instance Num a => Additive a where (+) = (P.+), but this only works with some extension enabled (overlapping instances at least)
05:40:24 <filcab42> it says:
05:40:46 <hpaste>  (anonymous) annotated "Monad (Either String)" with "(no title)" at http://hpaste.org/4346#a1
05:40:55 <filcab42> sorry, didn't sign it
05:41:17 <pmatos> Toxaris: ok, I'll take a look at that extension. thanks.
05:41:31 <Toxaris> filcab42: oh ok, I misunderstood your question
05:41:45 <scook0> filcab42: looks like you just need to enable the relevant extension
05:42:38 <Toxaris> filcab42: well, try to enable FlexibleInstances :)
05:42:39 <filcab42> thanks
05:44:58 <quicksilver> filcab42: yeah, that's a slightly baffling restriction in haskell 98 instance forms
05:45:03 <quicksilver> I don't really understand it myself.
05:45:16 <quicksilver> I think it's because String is [Char].
05:45:46 <Heffalump> it's to guarantee deterministic instance selection
05:46:26 <Heffalump> if you are trying to reduce the class constraint Foo [a], you need to know what to do
05:46:49 <quicksilver> Heffalump: but the [Char] isn't part of the class constraint...
05:47:06 <quicksilver> Heffalump: that [Char] is just a concrete type
05:47:11 <quicksilver> in Either [Char] a
05:47:26 <quicksilver> I can't see how it would get mixed up in constraint resolution...
05:48:26 <Heffalump> if you have instance Monad (Either [Char] b) and instance Monad (Either [Int] b), how do you select an instance when trying to reduce Monad (Either [a] b]) ?
05:49:47 <quicksilver> you don't really want those bs there
05:49:49 <quicksilver> ;)
05:50:04 <quicksilver> woudln't you just leave an outstanding constraint?
05:50:10 <quicksilver> Monad (Either [a]) => ....
05:51:32 <Toxaris> I don't see what an instance Monad (Either [ConcreteType]) has to do with the constraint Monad (Either [a]). I cannot instantiate a to ConcreteType because of the instance, can I?
05:52:14 <quicksilver> no, I agree
05:52:17 <quicksilver> you have to wait
05:52:27 <quicksilver> if it becomes clear what the concrete type is, then you instantiate
05:52:31 <quicksilver> or you error, if it was wrong.
05:52:40 <quicksilver> :t \x y -> [x,y] + [y,x]
05:52:42 <lambdabot> forall t. (Num [t]) => t -> t -> [t]
05:52:53 <quicksilver> this generates a constraint Num [t]
05:53:04 <quicksilver> which could later be satisfied by an instance Num [Int]
05:53:08 <quicksilver> if I applied it to Ints
05:53:13 <quicksilver> I don't see the problem...
05:53:19 <quicksilver> (or the different between that situation and this one)
05:53:35 <Heffalump> the existence of FlexibleInstances is a demonstration that there are ways round the problem, such as those you describe
05:53:54 <quicksilver> OK, but I don't understand why it is even conceivably a problem.
05:54:01 <Heffalump> However, H98 specifies things more rigidly, so that you can always do constraint reduction once you know the top-level type constructor
05:54:34 <Heffalump> it makes inferring types harder, IIRC
05:54:44 <Heffalump> and makes type errors worse
05:55:55 <quicksilver> hmm
05:56:07 <quicksilver> maybe there was a notion that instances for type constructors should always be polymorphic
05:56:12 <quicksilver> that is more elegant, I suppose.
05:56:24 <quicksilver> e.g. the non-standard show instance for [Char] is ugly
05:56:29 <quicksilver> because it breaks polymorphism.
05:56:42 <quicksilver> well, parametricity.
05:57:20 <Heffalump> type classes break parametricity on their own
05:58:09 <wli> Dumbing things down to "improve type errors" is how we got a Prelude that sucks. Color me nonplussed.
05:58:35 <Heffalump> there may well be a more convincing explanation than mine. I just don't know what it is.
05:58:55 <wli> And how we lost monad comprehensions.
05:59:01 <Toxaris> the non-standard show instance for [Char] is ugly because there also is a standard one for [a]. but there is no instance Monad (Either [a]). so the situation seems not to be comparable
05:59:01 <Heffalump> my best guess is that it was just being conservative, because the implications of generalising weren't well understood.
05:59:14 <Heffalump> there is no non-standard show instance for [Char]
05:59:21 <Heffalump> it's worked around using the showList member of Show
05:59:42 <sjanssen> which is one clever hack
05:59:55 <quicksilver> but, it's just a hack
06:00:04 <quicksilver> morally, there *is* a non-standard show instance for [Char]
06:00:11 <quicksilver> it's just they used a haskell98 hack for it
06:00:21 <quicksilver> instead of OverlappingInstances :P
06:00:26 <Heffalump> well, the same hack is available if you want to redefine Monad..
06:00:32 <quicksilver> true
06:00:42 <Heffalump> now OverlappingInstances I would definitely argue against.
06:00:43 <sjanssen> I'll take showList over OverlappingInstances -- they always make me suspicious
06:00:46 <Heffalump> IM having them be default.
06:00:54 <quicksilver> sjanssen: yeah, so would I.
06:00:56 <Heffalump> I use them a lot, but you definitely lose something by doing so.
06:01:38 <nornagon> :t do { x <- randomIO; return x }
06:01:40 <lambdabot> forall a. (Random a) => IO a
06:01:48 <nornagon> :t [ x | x <- randomIO ]
06:02:02 <nornagon> @bot
06:02:02 <lambdabot> :)
06:02:03 <lambdabot> thread killed
06:02:04 <nornagon> :(
06:02:17 <quicksilver> :t [ x | x <- randomIO ]
06:02:19 <lambdabot>     Couldn't match expected type `[t]' against inferred type `IO a'
06:02:19 <lambdabot>     In a list comprehension: x <- randomIO
06:02:28 <nornagon> ... interesting.
06:02:41 <nornagon> the bot behaviour, that is, not the type error.
06:02:53 <nornagon> (though the type error is sad)
06:03:49 <Saizan> just realized that we don't have monad comprehensions?
06:04:08 <nornagon> well, no, i knew that
06:04:17 <nornagon> but i thought i'd try just in case :)
06:05:07 <pmatos> Toxaris: I've read about instance overlapping in http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#instance-overlap and this doesn't seem to be the case of instance overlapping. Anyway, GHC rejects: instance Num a => Additive a where (+) = (P.+), because it says is a ill-formed instance declaration.
06:05:10 <lambdabot> Title: 8.6. Class and instances declarations, http://tinyurl.com/245leb
06:05:33 <pmatos> It makes some sense to say it is ill-formed because Additive a is a class and it should probably be a type.
06:05:40 <Heffalump> you need FlexibleInstances for that
06:06:03 <Heffalump> and if you want any other instances of Additive, you'll also need OverlappingInstances
06:06:15 <Saizan> and UndecidableInstances iirc
06:06:34 <pmatos> :-) heh, so many things... ok, I'll check them. Thanks! :-)
06:06:39 <Saizan> "the context is not smaller than the head.."
06:07:58 <pmatos> Saizan: yes, it is not... does that imply the use of undecidable instances?
06:08:13 <Saizan> yes
06:08:17 <pmatos> Heffalump: are FlexibleInstances a ghc extension?
06:08:19 <pmatos> Saizan: ok.
06:09:19 <pmatos> Saizan: the word undecidable doesn't look good. Is the use of undecidable instances seen as bad practice or something?
06:09:40 <Saizan> pmatos: yes it is, you can pass -xFlexibleInstances as a flag or put {-# LANGUAGE FlexibleInstances #-} at the top of your file
06:10:15 <Saizan> pmatos: it only means that if your instances are truly undecidable the typechecker won't terminate
06:10:34 <pmatos> Saizan: ok, thanks.
06:10:36 <Saizan> pmatos: it's usually safe
06:12:02 <Saizan> (what i said for "FlexibleInstances" is also valid for "UndecidableInstances", "OverlappingInstances" and others)
06:12:32 <pmatos> Saizan: yes, I can find all the others but not flexible instances in the manual. are flexible instances a recent addition?
06:13:12 <Saizan> well, it's there from 6.6.1 iirc
06:13:45 <Saizan> if your version doesn't support it you can use -fglasgow-exts that turns on all the safe extensions
06:14:03 <scook0> how about http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#instance-rules
06:14:03 <lambdabot> Title: 8.6. Class and instances declarations, http://tinyurl.com/245leb
06:14:32 <scook0> the extension itself predates the fine-grained extension mechanism
06:14:42 <scook0> so the documentation might not have been properly updated yet
06:16:53 <pmatos> scook0: that's it then because I've been looking at exactly that chapter and there's no mention of FlexibleInstances.
06:17:00 <pmatos> Thanks!
06:22:05 <Syzygy-> Okay. Much as I like what I've seen so far from Ruby on Rails, sometimes it outsmarts you in ugly ways. It works a lot on conventions - one of them being that a database table is supposed to have the plural of the correspondign class name as its name.
06:22:11 <Syzygy-> So - what's the plural of "Person"?
06:22:17 <Syzygy-> "People" of course!
06:22:51 <Syzygy-> It makes me wonder whether the internal engine at that point considers index to be pluralized indexes or indices
06:22:55 <Syzygy-> </rant>
06:23:51 <ricky_clarkson> Indexes is a form of the verb, afaik.
06:24:01 <ricky_clarkson> He indexes many files, producing indices.
06:24:38 <tuor> I think Rails has a mapping file for pluralization special cases.
06:25:29 <tuor> ...To make it easy to add new cases they didn't anticipate.
06:26:36 <tuor> I do agree that they get too clever sometimes. I'm learning TurboGears right now, and I appreciate that it seems to be more straightforward Python.
06:26:57 <Toxaris> "index (pl. indexes or especially in technical use indices)" according to the Compact Oxford English Dictionary
06:27:42 <Toxaris> that would suggest to use "indices" for multiple database indices but indexes as plural of a user-data table containing more then one index
06:31:42 <Heffalump> I'd have thought that the technical and non-technical spellings would be the other way round.
06:49:57 <Saizan> hah, you _can_ write liftMn!
06:56:44 <olsner> how? some printf-style type magic?
06:58:35 <Heffalump> without bad interactions with the Monad instance for (a ->) ?
07:03:03 <Saizan> Heffalump: it seems not
07:03:53 <Saizan> no interactions i mean, however i'm going to paste the type hackery
07:05:01 <filcab42> hi all
07:05:34 <filcab42> Why can't I do: newtype Bad = Bad Int Double
07:05:47 <filcab42> but I can do: newtype State st a = \st -> (st,a)
07:06:18 <Heffalump> newtypes can only have one type parameter
07:06:30 <Heffalump> IM one parameter to the data constructor
07:06:45 <filcab42> and in the second example the parameter is \st -> (st,a)
07:06:45 <filcab42> ?
07:06:56 <Heffalump> in your newtype State, (I assume you left out the State on the RHS), you only have one parameter, namely that function type.
07:07:08 <filcab42> (yeah, I'm missing "State" before the "\st" in the second example)
07:07:13 <hpaste>  Saizan pasted "liftMn" at http://hpaste.org/4347
07:08:11 <filcab42> and the type State may be parameterized (is that the right word) over two types?
07:08:19 <Saizan> newtype State st a = \st -> (st,a) is mixing type and value level syntax and lacks a constructor
07:09:12 <Saizan> so you also have a '\' too much :)
07:09:54 <Heffalump> filcab42: yes, it's fine to parameterize the type over two types, but the data constructor can only take one argument.
07:10:04 <filcab42> oh
07:10:05 <filcab42> thanks
07:10:20 <Heffalump> the point is that it's supposed to be operationally equivalent to the underlying type
07:10:28 <Heffalump> so by definition you can't have multiple underlying types :-)
07:10:34 <fasta> Is there a function f s.t. f 8 = "eight", f 9 = "nine" that works for all non-negative numbers? I think Common Lisp has such a function.
07:10:55 <filcab42> common lisp has ~r in the format string
07:10:59 <filcab42> (I thinks
07:11:08 <fasta> filcab42: what does the ~r stand for?
07:11:10 <Heffalump> such a function obviously exists, but I'm not aware of a widely-available implementation
07:11:17 <filcab42> I have no idea
07:11:19 <filcab42> 5 secs
07:11:39 <fasta> Heffalump: right, of course, I meant implemented and ready for use.
07:11:57 <wolverian> Lingua::EN::Numbers
07:12:01 <wolverian> oh, ffff this is not #perl
07:12:12 <wolverian> sorry, first time I got confused :)
07:12:44 <filcab42> there's also a unix program that does that (can't remember the name), maybe you can call it, if you don't want to make such a function :P
07:13:23 <wolverian> number
07:13:46 <wolverian> it has a somewhat strange output format, but you can work around that
07:15:12 <filcab42> ~r = Radix
07:15:12 <filcab42> http://www.lisp.org/HyperSpec/Body/sec_22-3-2-1.html
07:15:13 <lambdabot> Title: CLHS: Section 22.3.2.1
07:15:27 <fasta> wolverian: bin/number is not in Debian anywhere
07:15:51 <filcab42> you can print it as a cardinal english number, ordinal number, roman numeral or old roman numeral (IV -> IIII)
07:16:07 <wolverian> fasta, it's not in bsdgames?
07:16:24 <filcab42> wolverian: last time I checked it was in bsdgames, also
07:16:33 <wolverian> there you go.
07:17:02 <fasta> wolverian: /usr/games/number
07:17:23 <wolverian> fasta, um.. yesh?
07:17:26 <wolverian> s/sh/ah/
07:17:27 <fasta> This "games" distinction is rather stupid.
07:17:38 <wolverian> sure.
07:18:23 <fasta> Some people play the how to make gcc crash game, and I don't see gcc in /usr/games... ;)
07:28:43 <TomMD> @let fib3 = 1 : 1 : fib3 : (tail fib3) : (tail (tail fib3))
07:28:44 <lambdabot> <local>:4:48:     Occurs check: cannot construct the infinite type: a = [a]  ...
07:29:31 <TomMD> @let fib3 = zipwith (+) (zipWith (+) (1 : 1 : fib3) (tail fib3)) (tail (tail fib3))
07:29:31 <lambdabot> <local>:4:7: Not in scope: `zipwith'
07:29:41 <TomMD> @let fib3 = zipWith (+) (zipWith (+) (1 : 1 : fib3) (tail fib3)) (tail (tail fib3))
07:29:43 <TomMD> there
07:29:43 <lambdabot> Defined.
07:29:50 <TomMD> take 10 fib3
07:29:55 <TomMD> > take 10 fib3
07:29:56 <lambdabot>  Exception: <<loop>>
07:30:00 <TomMD> oh
07:33:59 <Juanma`> /?
07:36:11 <wli> > let derangements = 1 : 0 : zipWith3 (\n dCur dPrev -> n * (dCur + dPrev)) [1..] (tail derangements) derangements in take 10 derangements
07:36:11 <lambdabot>  [1,0,1,2,9,44,265,1854,14833,133496]
07:36:39 <Japsu> @oeis [1,0,1,2,9]
07:36:39 <lambdabot> Sequence not found. Take a stress pill and think things over.
07:36:59 <wli> @oeis [0,1,0,1,2,9]
07:36:59 <lambdabot> Sequence not found. There are some things that I just don't know.
07:38:16 <wli> Look for derangement and subfactorial
07:42:48 <wli> I suspect one should be able to automatically produce things vaguely resembling closed forms for recurrences of the form a(n)*x_{n+1} = b(n)*x_n + c(n)*x_{n-1} where a(n), b(n), c(n) are arbitrary-degree polynomials.
07:44:43 <wli> You get xs = x0 : x1 : zipWith3 (\n xcur xprev -> (a(n)*xcur + b(n)*xprev) / c(n)) [1..] (tail xs) xs or some such as a general "zipWith solution" in any event but even more can be done.
07:45:01 <idnar> @hoogle unsafeInterleaveIO
07:45:02 <lambdabot> System.IO.Unsafe.unsafeInterleaveIO :: IO a -> IO a
07:45:20 <wli> (the "zipWith solution actually generalizes to arbitrary functions of n and arbitrary-order recurrences)
07:45:54 <wli> (so long as c(n) doesn't vanish anyway)
07:48:32 <wli> Okay, I'm off on the closed form. You get a diffeq for the generating function whose order depends on the degree of the polynomials.
07:49:00 <Heffalump> augustss: can you explain why H98 has such stringent restrictions on the form of instances?
07:50:03 <augustss> They were an easy set of restrictions that guaranteed termination and coherence.
07:50:23 <augustss> And with single parameter type classes they are not too bad.
07:50:47 <Heffalump> why does instance Foo [Char] cause problems?
07:51:24 <augustss> It could cause coherence problems if there are also instances for [a] and Char
07:51:46 * wli needs ATTaPL to figure out what on earth is going on with module systems.
07:52:06 <Heffalump> but you could just ban overlapping instances to prevent that
07:53:32 <augustss> Sure, but as I said, the restrictions were easy and easily enforced
07:53:45 <Heffalump> fair enough
07:54:26 <augustss> It was known it was not the only possible design.  But the space was less explored and understood in those days.
07:56:41 <quicksilver> interesting, thanks
07:56:49 <quicksilver> Heffalump and I were discussing this morning.
08:02:48 * wli thought he understood quicksilver's module system ideas until others came along and shot it all down.
08:05:50 <quicksilver> wli: better to be shot down whilst soaring high than never get off the ground?
08:07:44 <MyCatVerbs> Better to be shot down while in the atmosphere than to develop a pressure leak while travelling betwixt planets.
08:13:07 <wli> That's happened to me many times while hacking on Linux.
08:22:57 <wli> (the interplanetary bit that is)
08:23:18 <wli> If Linux has taught me anything, it's that there's no code so spectacular it can't be ignored.
08:25:23 <MyCatVerbs> If Haskell has taught me anything, it's that the sooner you finally get a particular piece of code to successfully compile, the sooner you can get around to finding all the bugs in it. :)
08:34:23 * wli feels dirty after being aped so crudely.
08:34:55 <MyCatVerbs> wli: imitation is the sincerest form of flattery.
08:35:34 <MyCatVerbs> wli: though admittedly I'm enough of a jerk that I'm not sure it's quite guaranteed to be a *good* thing to receive my compliments :)
09:01:47 <pjd> what is that monad expression proposal called again?
09:01:59 <pjd> the (<- foo) thing
09:02:21 <EvilTerran> monadic subexpressions?
09:02:34 <pjd> ah, thanks
09:03:23 <quicksilver> s/proposal/abomination/
09:31:18 <hpaste>  tphyahoo-haskel pasted "how do I read a string containing a quoted backslash?" at http://hpaste.org/4349
09:33:24 <oerjan> tphyahoo-haskell: note that read "\"\\\"" in a sense means reading _twice_
09:33:31 <oerjan> > "\"\\\""
09:33:33 <lambdabot>  "\"\\\""
09:33:40 <oerjan> > read "\"\\\""
09:33:40 <lambdabot>  Exception: Prelude.read: no parse
09:34:44 <oerjan> you are first using haskell string notation: "\"\\\"" means the string containing the characters "\" in order
09:35:16 <oerjan> but then you are attempting to perform a _second_ read on the result of that
09:35:30 <oerjan> which doesn't work because "\" is not legal haskell string syntax
09:35:44 <tphyahoo-haskell> so my question didn't make any sense.
09:35:49 <tphyahoo-haskell> ?
09:36:04 <oerjan> more or less, yeah
09:36:28 <oerjan> if you try instead: interact read
09:37:05 <oerjan> and then give the string as input, then you will see what happens with only one conversion
09:37:11 <tphyahoo-haskell> where does the *second* read come in? because I'm in the ghci repl?
09:37:16 <pmatos> In GHCi, how can I try something using a arrays? I can't use import, so how can I access arrays?
09:37:40 <tphyahoo-haskell> :m +Data.Array
09:37:45 <oerjan> tphyahoo-haskell: haskell's syntax parsing
09:37:46 <tphyahoo-haskell> :b Data.Array
09:38:18 <tphyahoo-haskell> sure you want to use arrays? simple stupid stuff usually just uses lists.
09:38:52 <pmatos> tphyahoo-haskell: ah, thats it, thax!
09:40:07 <pmatos> tphyahoo-haskell: yes, I need to try out arrays, basically I just want to know if I can use listArray with multidimensional arrays
09:40:23 <oerjan> :t listArray
09:40:24 <lambdabot> forall i e. (Ix i) => (i, i) -> [e] -> Array i e
09:40:44 <oerjan> > listArray ((0,0),(1,1)) [1,2,3,4]
09:40:46 <lambdabot>  array ((0,0),(1,1)) [((0,0),1),((0,1),2),((1,0),3),((1,1),4)]
09:41:06 <oerjan> > range ((0,0),(1,1))
09:41:07 <lambdabot>  [(0,0),(0,1),(1,0),(1,1)]
09:41:13 <pmatos> oerjan: ah, yes, it works! :-) and it does the right thing! heh
09:41:16 <pmatos> great! thanks!
09:41:34 <pmatos> I always forget I can try things on lambdabot. ;)
10:07:49 <jimstutt> let mnem= "how i need a drink alcoholic of course after heavy chapters involving quantum mechanics""
10:08:07 <jimstutt> map length (words mnem)
10:08:24 <jimstutt> >let mnem= "how i need a drink alcoholic of course after heavy chapters involving quantum mechanics""
10:08:29 <jimstutt> >map length (words mnem)
10:08:43 <shachaf> jimstutt: lambdabot isn't ghci, lets don't carry over.
10:08:44 <oerjan> > let mnem= "how i need a drink alcoholic of course after heavy chapters involving quantum mechanics" in  map length (words mnem)
10:08:46 <lambdabot>  [3,1,4,1,5,9,2,6,5,5,8,9,7,9]
10:08:50 <shachaf> jimstutt: And you need spaces.
10:09:09 <shachaf> Should Writer be used with lists, in general?
10:09:14 <jimstutt> shachaf: spaces where?
10:09:17 <oerjan> missing a 3 in there
10:09:22 <shachaf> jimstutt: "> ".
10:09:43 <oerjan> > let mnem= "how i need a drink alcoholic of course after the heavy chapters involving quantum mechanics" in  map length (words mnem)
10:09:43 <lambdabot>  [3,1,4,1,5,9,2,6,5,3,5,8,9,7,9]
10:10:05 <jimstutt> oerjan,shachef: tnx
10:10:13 <oerjan> > pi
10:10:13 <lambdabot>  3.141592653589793
10:10:27 <shachaf> Would the tells get slower and slower?
10:11:19 <Saizan> shachaf: yes
10:11:37 <shachaf> Saizan: What should be used instead? DList?
10:11:43 <Saizan> yes
10:11:44 <oerjan> shachaf: i guess it would depend on which way the ++'s nest?
10:11:48 <Saizan> or Endo [a]
10:12:12 <jimstutt>  >let mnem= "how i need a drink alcoholic of course after the heavy chapters involving quantum mechanics" in map length (words mnem)
10:12:13 <Saizan> (++) nests the wrong way with Writer
10:12:24 <idnar> jimstutt: the space goes after >, not before :P
10:12:36 <Saizan> so use DList or cps transform it
10:12:56 <oerjan> > let test = tell "Really? " >> test in runWriter test
10:12:59 <jimstutt> idnar: is specialise in early error :)
10:13:00 <lambdabot>  Exception: stack overflow
10:13:03 <oerjan> oops
10:13:11 <jimstutt>  > let mnem= "how i need a drink alcoholic of course after the heavy chapters involving quantum mechanics" in map length (words mnem)
10:13:43 <Saizan> ?src tell Writer
10:13:43 <lambdabot> Source not found. You speak an infinite deal of nothing
10:13:53 <Saizan> > let mnem= "how i need a drink alcoholic of course after the heavy chapters involving quantum mechanics" in map length (words mnem)
10:13:54 <lambdabot>  [3,1,4,1,5,9,2,6,5,3,5,8,9,7,9]
10:13:55 <oerjan> er wait a moment
10:14:03 <oerjan> > let test = tell "Really? " >> test in snd $ runWriter test
10:14:04 <lambdabot>  "Really? Really? Really? Really? Really? Really? Really? Really? Really? Rea...
10:14:17 <oerjan> ah, it was not the tell, but the forcing of the result
10:14:58 <oerjan> works perfectly well with right recursion
10:15:16 <Saizan> that doesn't prove anything about (++) nesting :)
10:15:27 <oerjan> @src Writer >>=
10:15:27 <lambdabot> Source not found. Take a stress pill and think things over.
10:16:24 <oerjan> 	m >>= k  = Writer $ let
10:16:24 <oerjan> 		(a, w)  = runWriter m
10:16:24 <oerjan> 		(b, w') = runWriter (k a)
10:16:24 <oerjan> 		in (b, w `mappend` w')
10:16:53 <mux> @src Writer (>>=)
10:16:53 <lambdabot> Source not found. stty: unknown mode: doofus
10:17:02 <mux> @src MonadWriter (>>=)
10:17:03 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
10:17:04 <mux> mmm
10:17:39 <oerjan> Saizan: as you can see, the second part is just the mappend ((++)) of the parts
10:18:11 <Saizan> oerjan: see? its (((w ++ w') ++ w'') ++ w''') ... so it becomes quadratic
10:18:32 <oerjan> Saizan: not with recursion in the right part
10:18:39 <nolrai> msg
10:19:39 <quicksilver> Saizan: surely oerjan's example did prove it.
10:19:47 <oerjan> Saizan: if that had been the case for my > let test above, then it would never have produced any string
10:19:50 <quicksilver> if it had been associating to the left it could not have been prodiuctive
10:19:51 <oerjan> otoh:
10:19:57 <quicksilver> you would never have see the first >>
10:20:04 <quicksilver> erm
10:20:12 <quicksilver> never have seen the first Really?
10:20:15 <oerjan> > let test = test >> tell "Really? " in snd $ runWriter test
10:20:16 <lambdabot>  Exception: stack overflow
10:20:30 <oerjan> > let test = test >> tell (Dual "Really?) " in snd $ runWriter test
10:20:30 <lambdabot> Unbalanced parentheses
10:20:38 <oerjan> > let test = test >> tell (Dual "Really? ") in snd $ runWriter test
10:20:39 <lambdabot>   add an instance declaration for (Show (Dual [Char]))
10:20:52 <oerjan> > let test = test >> tell (Dual "Really? ") in getDual . snd $ runWriter test
10:20:53 <lambdabot>  "Really? Really? Really? Really? Really? Really? Really? Really? Really? Rea...
10:21:25 <nolrai> is there a standard name for the datatype data D a = Branch D D | Leaf a, because a binary tree is data D a= Branch D a D | Empty, right?
10:21:50 <nolrai> whats the deal with the font?
10:22:04 <quicksilver> nolrai: a binary tree might be data D a = Empty | Leaf a | Branch D D
10:22:14 <quicksilver> nolrai: you always have the choice of labelling leaves or branches or both.
10:22:35 <Saizan> oerjan: ok, but that works for a particular association of >>/>>= which in practice means that you go quadratic
10:22:45 <nolrai> Ok so they are both called binary trees, gotcha. thanks.
10:22:58 <quicksilver> nolrai: yeah. there isn't really a standard binary tree
10:23:00 <quicksilver> nolrai: there are a few choices
10:23:35 <Saizan> oerjan: with DList or CPS tranformation you get always the right association of (++) regardless of how you associate >>/>>=
10:23:41 <oerjan> Saizan: i am not so sure about practice, because isn't "tail recursive" do expressions more common than front recursive ones?
10:24:10 <oerjan> but of course it is possible
10:24:18 <mux> @hoogle ZipList
10:24:19 <lambdabot> Control.Applicative.ZipList :: newtype ZipList a
10:24:19 <lambdabot> Control.Applicative.ZipList :: [a] -> ZipList a
10:24:19 <lambdabot> Control.Applicative.getZipList :: ZipList a -> [a]
10:25:26 <oerjan> nolrai: btw i see the same font as always, must be your irc client
10:25:30 <desp> @pl \x -> x & x
10:25:30 <lambdabot> join (&)
10:25:36 <desp> @pl \x -> x * x
10:25:36 <lambdabot> join (*)
10:25:40 <desp> right.
10:25:56 <oerjan> and this channel is +c so no special formatting is allowed
10:26:02 <Saizan> oerjan: well composing small components you usually get a tree of applications, rather than a list
10:26:29 <sioraiocht> +c?
10:27:00 <quicksilver> +c forbids styles + colours
10:27:02 <quicksilver> mores the pity.
10:28:34 <jimstutt>  > let mnem = "how ticked ho hum" in head(head(words mnem))
10:29:00 <quicksilver> > let mnem = "how ticked ho hum" in head(head(words mnem))
10:29:01 <lambdabot>  'h'
10:29:10 <quicksilver> jimstutt: extra space at the beginning :P
10:29:26 <jimstutt> > let mnem = "how ticked ho hum" in isChar(head(head(words mnem)))
10:29:27 <lambdabot>   Not in scope: `isChar'
10:29:35 <gwern> > let eval '!':as = undefined
10:29:36 <lambdabot>  Parse error in pattern at end of input
10:29:42 <jimstutt> quicksilver: can I load modules?
10:29:45 <gwern> why does that pattern not work?
10:29:57 <oerjan> @index isChar
10:29:57 <lambdabot> bzzt
10:30:14 <gwern> > let eval ['!':as] = undefined -- maybe?
10:30:15 <lambdabot>  Parse error at end of input
10:30:23 <doserj> gwern: the pattern did work ...
10:30:28 <oerjan> jimstutt: what's isChar? maybe you mean isAlpha or something?
10:30:35 <gwern> > let eval '!':as:[] = undefined
10:30:35 <lambdabot>  Parse error in pattern at end of input
10:30:59 <doserj> > let eval ('!':as) = undefined in 5
10:31:00 <lambdabot>  5
10:31:23 <gwern> > let eval '!':as = undefined in 5
10:31:24 <lambdabot>  Parse error in pattern at "in" (column 29)
10:31:32 <gwern> > let eval '!':as:[] = undefined in 5
10:31:32 <lambdabot>  Parse error in pattern at "in" (column 32)
10:31:33 <quicksilver> jimstutt: no, but it has most of the standard modules loaded
10:31:37 <quicksilver> jimstutt: isChar isn't a functions :)
10:31:53 <quicksilver> > let mnem = "how ticked ho hum" in isLetter(head(head(words mnem)))
10:31:53 <lambdabot>  True
10:31:59 <oerjan> gwern: function application binds tighter than nearly everything, also in function definitions
10:31:59 <quicksilver> jimstutt: maybe you meant isLetter?
10:32:10 <oerjan> :t isAlpha
10:32:11 <lambdabot> Char -> Bool
10:32:15 <oerjan> :t isLetter
10:32:16 <lambdabot> Char -> Bool
10:32:23 <doserj> @hoogle Char -> Bool
10:32:24 <lambdabot> Data.Char.isControl :: Char -> Bool
10:32:24 <lambdabot> Data.Char.isSpace :: Char -> Bool
10:32:24 <lambdabot> Data.Char.isLower :: Char -> Bool
10:32:31 <quicksilver> function definitions are parsed as if they were expressions, in terms of precedence etc.
10:32:50 <jimstutt> quicksilver: yep
10:32:56 <quicksilver> then the 'top level' is determined to be the thing being defined, and everything else is variables.
10:35:20 <oerjan> > (liftM2 (==)`on`map) isLetter isAlpha ['\NUL' .. '\0xff']
10:35:20 <lambdabot>  Improperly terminated character constant at "'\0xf..." (column 50)
10:35:28 <oerjan> > (liftM2 (==)`on`map) isLetter isAlpha ['\NUL' .. '\xff']
10:35:29 <lambdabot>  True
10:36:41 <cizra> Hey, how can I get a "substring" of a list? I want to get a list that contains all but the last element.
10:36:55 <cizra> reverse + head!
10:37:01 <shachaf> cizra: init?
10:37:06 * oerjan thinks that liftM2 (==)`on`map is one of his better creations
10:37:09 <gwern> @src init
10:37:09 <lambdabot> init [x]    = []
10:37:09 <lambdabot> init (x:xs) = x : init xs
10:37:09 <lambdabot> init []     = undefined
10:37:12 <jimstutt> @src takeWhile
10:37:12 <lambdabot> takeWhile _ []                 =  []
10:37:12 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
10:37:12 <lambdabot>                    | otherwise =  []
10:37:29 <gwern> undefined? that's not nice
10:37:32 <gwern> > init []
10:37:35 <lambdabot>  Exception: Prelude.init: empty list
10:38:15 <cizra> shachaf: Thanks!
10:38:15 <shachaf> gwern: What do you expect?
10:38:36 <gwern> an empty list makes as much sense to me
10:38:36 <shachaf> cizra: (Keep in mind that it's O(n), of course.)
10:38:42 <shachaf> gwern: Huh?
10:38:44 <shachaf> @ty init
10:38:44 <lambdabot> forall a. [a] -> [a]
10:38:50 <shachaf> Oh, hmm.
10:38:55 <gwern> the beginning of an empty list is empty; 0-0 is 0, and thus forth
10:38:57 <shachaf> Sorry, I was thinking of last.
10:39:13 <olsner> @type liftM2 (==)`on`map
10:39:14 <lambdabot> Not in scope: `on'
10:39:14 <cizra> shachaf: don't care, it's a school assignment
10:39:26 <gwern> :type last
10:39:31 <shachaf> gwern: init is like reverse . tail . reverse.
10:39:35 <gwern> > :type last
10:39:35 <lambdabot>  Parse error at "type" (column 2)
10:39:40 <gwern> bleh.
10:39:44 <gwern> @ty last
10:39:45 <lambdabot> forall a. [a] -> a
10:40:04 <gwern> shachaf: ok, I do agree it's hard to see how 'last []' couldn't be undefined though
10:43:02 <nolrai> in ghc can operator constructors has a associativity? (getting rid of some parens would really clean up my patterns.)
10:43:14 <olsner> @type let (*) `on` f = \x y -> f x * f y in liftM2 (==) `on` map
10:43:15 <lambdabot> forall a b. (Eq [b]) => (a -> b) -> (a -> b) -> [a] -> Bool
10:44:29 <jimstutt> @demonstrate takeWhile
10:44:29 <lambdabot> Unknown command, try @list
10:44:39 <jimstutt> @list takeWhile
10:44:40 <lambdabot> No module "takeWhile" loaded
10:44:41 <nolrai> i defined my own on like ten times before finding that it already exitsted.
10:45:17 <nolrai> > takeWhile (> 2) [10 .. -10]
10:45:18 <lambdabot>  []
10:45:47 <nolrai> > takeWhile (> 2) [10 .. -1 ]
10:45:48 <lambdabot>  []
10:45:48 <jimstutt> @demonstrate liftM2
10:45:49 <lambdabot> Unknown command, try @list
10:46:13 <nolrai> > takeWhile (< 2) [-10 .. ]
10:46:13 <lambdabot>  [-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,0,1]
10:46:48 <jimstutt> nolrai: ta; how do i use '@demonstrate'
10:46:49 <nolrai> @type LiftM2
10:46:50 <lambdabot> Not in scope: data constructor `LiftM2'
10:47:17 <nolrai> jimstutt: does it exitst?
10:47:52 <jimstutt> nolrai: can't tell whether somebody made it....up
10:48:01 <jimstutt> @info demonstrate
10:48:01 <lambdabot> demonstrate
10:48:19 <jimstutt> > demonstrate concat
10:48:19 <lambdabot>   Not in scope: `demonstrate'
10:48:25 <nolrai> @list
10:48:25 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
10:48:56 <jimstutt> lambdabot: tnx :)
10:49:10 <nolrai> lambdabot++
10:49:23 <nolrai> @karma lambdabot
10:49:24 <lambdabot> lambdabot has a karma of 52
10:51:35 <dons> ok. awesome. hugs on the nintendo
10:51:35 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
10:51:38 <dons> http://closuretohome.blogspot.com/2007/12/hugs-for-nintendo-ds.html
10:51:39 <lambdabot> Title: Closure to Home: Hugs for the Nintendo DS, http://tinyurl.com/yoncqv
10:52:53 <oerjan> > let a & b = a-b; infixr 5 & in 1 & 2 & 3 -- nolrai
10:52:54 <lambdabot>  2
10:53:30 <nolrai> oerjan: thanks
10:53:52 <esteban2> <dons> http://closuretohome.blogspot.com/2007/12/hugs-for-nintendo-ds.h
10:57:20 <olsner> hmm, I recognize the name Andreas Farre
10:59:58 <dons> ?users
10:59:58 <lambdabot> Maximum users seen in #haskell: 412, currently: 399 (96.8%), active: 16 (4.0%)
11:00:45 <olsner> lambdabot needs to have fewer mindwipes - I remember seeing larger maximums than that!
11:00:51 <olsner> (maximi?)
11:01:37 <oerjan> i remember remembering seeing larger maximums than what i currently saw several times :)
11:04:27 <cizra> http://pastie.caboo.se/126254 -- This function is supposed to take a [[]] and an input list, then cut the input list into growing substrings.
11:04:30 <lambdabot> Title: #126254 - Pastie
11:04:34 <oerjan> olsner: btw, maxima
11:04:35 <cizra> It doesn't compile, for some mysterious reason.
11:05:14 <qweqwe> what is wrong there ?
11:05:15 <qweqwe> http://pastebin.com/m24d9d5ef
11:05:37 <oerjan> cizra: we like error messages here ;)
11:05:40 <jimstutt> > let hunks = takeWhile (isDigit) in ('a','b','c')
11:05:41 <lambdabot>  ('a','b','c')
11:06:04 <jimstutt> > let hunks = takeWhile (isDigit) in (1,'c')
11:06:05 <lambdabot>  (1,'c')
11:06:18 <jimstutt> mm
11:06:25 <oerjan> jimstutt: you're not actually _using_ hunks
11:06:37 <cizra> http://pastie.caboo.se/126254
11:06:38 <jimstutt> > takeWhile (isDigit) in (1,'c')
11:06:38 <lambdabot> Title: #126254 - Pastie
11:06:38 <lambdabot>  Parse error at "in" (column 21)
11:06:46 <cizra> There, now it comes bundled with an error message
11:07:02 <olsner> oerjan: oh, yes, I mixed up maximum with maximus... obviously I meant maxima! :P
11:07:20 <nolrai> > let hunks = takeWhile (isDigit) in  hunks (1,'c')
11:07:21 <lambdabot>  Couldn't match expected type `[Char]'
11:07:27 <nolrai> > let hunks = takeWhile (isDigit) in  hunks ('1','c')
11:07:27 <lambdabot>  Couldn't match expected type `[Char]'
11:07:44 <nolrai> > let hunks = takeWhile (isDigit) in  hunks ['1','c']
11:07:44 <lambdabot>  "1"
11:08:06 <nolrai> >[1,'c']
11:08:12 <nolrai> > [1,'c']
11:08:12 <lambdabot>   add an instance declaration for (Num Char)
11:08:12 <lambdabot>     In the expression: 1
11:08:12 <lambdabot>     In ...
11:08:32 <jimstutt> nolrai: ta ur much faster than me
11:08:32 <nolrai> > [Data.Char.chr 1,'c']
11:08:33 <lambdabot>  "\SOHc"
11:08:46 <nolrai> > [Data.Char.chr 64,'c']
11:08:47 <lambdabot>  "@c"
11:09:36 <cizra> Oh, I guess I found an error..
11:11:05 <oerjan> cizra: (init juba ++ (last juba ++ [x])) cannot be right, at least
11:11:21 <cizra> yep, that's the error
11:11:28 <cizra>         | (head $ (head juba)) <= x = abifn (init juba ++ [last juba ++ [x]]) xs
11:11:31 <cizra> This one should be better...
11:11:53 <cizra> .. except that now ghc complains about Ord a. How do I tell it to calm down, every input will be ordered?
11:12:05 <nolrai> cizra: wouldn't that just be "juba ++ [x]"?
11:12:12 <cizra> no
11:12:27 <oerjan> cizra: Ord a =>[[a]] -> [a] -> [[a]]
11:12:51 <cizra> Thanks!
11:12:52 <nolrai> @ty init
11:12:53 <lambdabot> forall a. [a] -> [a]
11:13:01 <nolrai> @ty last
11:13:02 <lambdabot> forall a. [a] -> a
11:13:46 <nolrai> > let a = [1..10] in init a ++ (last a ++ [12])
11:13:47 <lambdabot>      Occurs check: cannot construct the infinite type: t = [t]
11:13:47 <lambdabot>       Expected...
11:14:09 <nolrai> > let a = [1..10] in init a ++ ([last a] ++ [12])
11:14:10 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,12]
11:18:26 <oerjan> cizra: btw modifying lists at the end is much more expensive than at the beginning
11:22:08 <cizra> oerjan: Performance isn't a limitation here.
11:22:12 <cizra> We weren't told to write fast code.
11:22:13 <pjd> ObMantra: [] is the stack data type, which happens to be called "list" too
11:26:49 <sfultong> greetings friendly haskellers!
11:27:42 <sfultong> anyone have recommendations about good intermediate-advanced functional programming books?
11:27:58 <dons> hmm. TaPL ?
11:28:10 <dons> purely functional data structures is excellent
11:28:11 <sfultong> is this a good book? : http://www.amazon.co.uk/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504/ref=wl_it_dp?ie=UTF8&coliid=I3IMNVRMV2GFK0&colid=276MAG0201BHN
11:28:13 <lambdabot> http://tinyurl.com/yur47g
11:28:25 <sfultong> heh, nice!
11:28:33 <sfultong> exactly what I was looking at
11:28:56 <sfultong> what's TaPL?
11:29:50 <oerjan> @where tapl
11:29:50 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
11:30:09 <sfultong> ooo, nice... a new xmonad's out
11:31:22 <esteban2> what's a monad?
11:31:45 <oerjan> @src Monad
11:31:45 <lambdabot> class  Monad m  where
11:31:45 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
11:31:45 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
11:31:45 <lambdabot>     return      :: a -> m a
11:31:45 <lambdabot>     fail        :: String -> m a
11:32:06 <esteban2> ohh thanks
11:32:39 <desegnis> esteban2: Note that only (>>=) and  return  are essential for a monad.
11:33:28 <esteban2> i didn't have to work with monads in my class but i'm just curious because everyone in here is always mentioning them. i might try some of it soon
11:35:40 <sfultong> monads are a trap
11:35:45 <sfultong> once, you get in, you never get out
11:36:07 <kaol> > fromJust $ Just "no"
11:36:08 <lambdabot>  "no"
11:36:22 <esteban2> so that means they're cool, thats cool
11:38:03 <sfultong> yeah, I wasn't correct
11:38:36 <oerjan> ah, you might escape, but to what?
11:38:44 <oerjan> > fromJust $ Nothing
11:38:45 <lambdabot>  Exception: Maybe.fromJust: Nothing
11:41:23 <sfultong> I wish xmonad had a changelog up on the website
11:42:04 <dons> sfultong: it has a news feed now
11:42:10 <sfultong> ah, nice
11:42:14 <dons> sfultong: but you want versoin-by-version changelogs?
11:42:19 <dons> or commit messages?
11:42:33 <dons> (we have both, just not linked from the website)
11:43:26 <sfultong> version-version
11:43:34 <sfultong> would be my preference
11:43:45 <sfultong> why not on the website?
11:45:43 <desp> @pl \x -> f (a ! x)
11:45:44 <lambdabot> f . (a !)
11:46:30 <dons> oh, never thought to add them.
11:46:39 <dons> the 0.5 release is imminent, and will have the changelog in the news feed
11:46:52 <dons> you might want to try the 0.5 release candidate, sfultong
11:48:57 <sfultong> is it wonderful?
11:49:09 <sfultong> I will only use wonderful software
11:49:25 <pippijn> haskell is wonderful
11:49:26 <Pastorn> http://closuretohome.blogspot.com/
11:49:27 <lambdabot> Title: Closure to Home
11:49:40 <pippijn> closure to home :-D
11:54:23 <dons> sfultong: yeah, its pretty wonderful
11:55:25 <desp> Does the array index operator ! have higher precedence than arithmetic operators?
11:55:35 <oerjan> > (0$0 !)
11:55:36 <lambdabot>      The operator `!' [infixl 9] of a section
11:55:36 <lambdabot>         must have lower precede...
11:55:43 <oerjan> yep
11:56:01 <desp> Thanks.
11:57:29 <gwern> thoughtp1lice: yes, that's why cabal install doesn't work. it works fine for me if I do the runhaskell dance, though
11:57:37 <sfultong> damn, rc 0.5 requires x11 1.4, which the gentoo-haskell overlay doesn't have
11:57:37 <pjd> esteban2: don't just look at monads;  look at Functor (and Applicative)
11:59:13 <pjd> they are simpler, and monads are a special case of them
12:00:09 <idnar> @src (>>)
12:00:10 <lambdabot> m >> k      = m >>= \_ -> k
12:00:32 <esteban2> ohh
12:02:57 <sfultong> funny:  http://www.amazon.com/review/product/0201342758/ref=cm_cr_pr_link_next_2?%5Fencoding=UTF8&pageNumber=2
12:02:59 <lambdabot> http://tinyurl.com/3yrsyp
12:08:59 <nolrai> @pl lleaf a b = Leaf $ Left $ Lambda a b
12:08:59 <lambdabot> lleaf = ((Leaf . Left) .) . Lambda
12:11:29 <desp> @pl uncurry f (bounds a)
12:11:29 <lambdabot> uncurry f (bounds a)
12:12:40 <desp> @hoogle bsearch
12:12:41 <lambdabot> No matches found
12:12:45 <desp> @hoogle search
12:12:45 <lambdabot> System.Directory.searchable :: Permissions -> Bool
12:12:45 <lambdabot> System.FilePath.Windows.searchPathSeparator :: Char
12:12:45 <lambdabot> System.FilePath.Posix.searchPathSeparator :: Char
12:16:46 <roconnor>  @bab nl en Lidmaatschap
12:18:34 <pjd> roconnor: membership
12:18:57 <roconnor> @pjdsnack
12:18:57 <lambdabot> Unknown command, try @list
12:19:07 <pjd> :)
12:19:49 <sfultong> @yow
12:19:49 <lambdabot> Is something VIOLENT going to happen to a GARBAGE CAN?
12:19:57 <nolrai> @ty fmap
12:19:58 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:20:00 <olsner> @b52s
12:20:00 <lambdabot> Some say she's from Mars, or one of the seven stars that shine after 3:30 in the morning. WELL SHE ISN'T.
12:20:19 <olsner> ... she's from planet claire ;-)
12:20:28 <nolrai> @b52s
12:20:28 <lambdabot> His ear lobe fell in the deep. Someone reached in and grabbed it. It was a rock lobster!
12:20:57 <nolrai> is that the random lines command?
12:21:13 <olsner> random lines from b-52 songs, yeah ;-)
12:21:30 <nolrai> wow and i thought i was wasting my time.
12:21:40 <olsner> @protontorpedo
12:21:40 <lambdabot> wil I make mroe $$ than learning java or APL or smalltalk or plt scheme or ruby or perl or clisp?
12:22:43 <monochrom> Learning doesn't make money. I'm speaking as someone with 20 years of learning.
12:23:35 <nolrai> where is Functor defined?
12:24:19 <dons> ?users
12:24:19 <lambdabot> Maximum users seen in #haskell: 412, currently: 403 (97.8%), active: 18 (4.5%)
12:24:35 <nolrai> @hoogle fmap
12:24:35 <lambdabot> Prelude.fmap :: Functor f => (a -> b) -> f a -> f b
12:24:36 <lambdabot> Control.Monad.fmap :: Functor f => (a -> b) -> f a -> f b
12:24:36 <lambdabot> Control.Monad.Instances.fmap :: Functor f => (a -> b) -> f a -> f b
12:24:40 <dmwit> nolrai: In the Prelude, I think.
12:24:44 <nolrai> cool
12:25:00 <nolrai> hoolge is nice
12:25:13 <nolrai> hoogle++
12:25:28 <saturday> ?bf +++.
12:25:28 <lambdabot>  fd:20: hClose: resource vanished (Broken pipe)
12:25:55 <dmwit> > chr 3 -- equivalent, but way more readable ;-)
12:25:57 <lambdabot>  '\ETX'
12:26:16 <saturday> :O
12:33:52 <oerjan> b-52 songs? here i was assuming it was yet another channel crackpot...
12:34:16 <olsner> @help b52s
12:34:16 <lambdabot> b52s. Anyone noticed the b52s sound a lot like zippy?
12:34:46 <oerjan> @list b52s
12:34:46 <lambdabot> quote provides: quote remember forget ghc fortune yow arr yarr keal b52s brain palomer girl19 v yhjulwwiefzojcbxybbruweejw protontorpedo
12:35:01 <olsner> @yhjulwwiefzojcbxybbruweejw
12:35:01 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
12:35:19 <oerjan> > fix show
12:35:21 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
12:35:32 <olsner> @v
12:35:32 <lambdabot> Exception: <<loop>>
12:35:38 <olsner> @girl19
12:35:38 <lambdabot> I have been into not actually hacking, but social engineering
12:35:39 <oerjan> > fix id
12:35:40 <lambdabot>  Exception: <<loop>>
12:36:08 <nolrai> > fix (+)
12:36:09 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -> a
12:36:10 <lambdabot>     Probabl...
12:36:21 <nolrai> @ty fix
12:36:21 <lambdabot> forall a. (a -> a) -> a
12:37:25 <oerjan> @src fix
12:37:25 <lambdabot> fix f = let x = f x in x
12:37:28 <nolrai> > fix (\(x,y) -> (x+y,x+y))
12:37:28 <lambdabot>  Exception: <<loop>>
12:37:33 <dmwit> > fix (\f x -> if x > 1 then f (x - 1) + f (x - 2) else 1) 5
12:37:34 <lambdabot>  8
12:37:45 <dmwit> > map (fix (\f x -> if x > 1 then f (x - 1) + f (x - 2) else 1)) [0..10]
12:37:46 <nolrai> so what is fix?
12:37:48 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89]
12:37:54 <oerjan> nolrai: ^^
12:38:01 <dmwit> nolrai: It returns the least fixed-point of a function.
12:38:09 <oerjan> fix needs a lazy function to apply to
12:38:12 <dmwit> nolrai: Where _|_ is considered smaller than any other value.
12:38:24 <oerjan> otherwise it just gives that loop exception
12:39:00 <dmwit> nolrai: It's closely related to the Y combinator, if you know what that is.
12:39:01 <oerjan> > fix (1:)
12:39:01 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
12:40:46 <sorear> dmwit: it *is* the Y combinator
12:41:23 <dmwit> sorear: Well, except that it's typed.
12:41:41 <sorear> dmwit: ever heard of typed SK?  Y is typable fine
12:42:14 <dmwit> sorear: No, I had never heard of any typed calculi.  Thanks for the pointer.
12:50:34 <nolrai> @hoogle mfmap
12:50:34 <lambdabot> No matches found
12:50:39 <nolrai> fmapM
12:51:01 <nolrai> @hoogle fmapM
12:51:01 <lambdabot> No matches found
12:52:10 <dmwit> nolrai: fmap already works on Monads
12:52:29 <dmwit> All sane Monad instances are also Functor instances.
12:52:49 <oerjan> for the insane ones, you can use liftM
12:52:56 <nolrai> yeah but i want something that puts the results in a monad.
12:53:16 <oerjan> results of what?
12:53:20 <nolrai> maybe i realy want foldM
12:53:20 <dmwit> :t fmap :: (Monad m, Functor m) => (a -> b) -> m a -> m b
12:53:22 <lambdabot> forall a b (m :: * -> *). (Functor m, Monad m) => (a -> b) -> m a -> m b
12:53:46 <oerjan> yeah, take a look in Data.Foldable and Data.Traversable
12:54:15 <oerjan> :t foldM
12:54:15 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
12:54:23 <oerjan> @index foldM
12:54:23 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
12:56:32 <oerjan> Data.Traversable.mapM is more general than the Control.Monad one
12:57:14 <nolrai> what i want is to map over the function and then fold with the monad. myfun :: (a -> M b) -> (S a) -> (M (S b))
12:57:26 <OceanSpray> :t liftM
12:57:27 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
12:58:00 <oerjan> that's precisely Data.Traversable.mapM
12:58:15 <oerjan> :t Data.Traversable.mapM
12:58:15 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
12:58:38 <nolrai> awsome!
12:58:42 <nolrai> oerjan++
12:59:04 <oerjan> :t Data.Traversable.traverse -- even more general
12:59:04 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
13:01:42 <nolrai> @hoogle pure
13:01:44 <lambdabot> Control.Arrow.pure :: Arrow a => (b -> c) -> a b c
13:01:44 <lambdabot> Control.Applicative.pure :: Applicative f => a -> f a
13:03:36 <khalsah> Is there any way in haskell to have a list (or list like) data structure that can contain elements of different types as long as the types are all instances of a particular type class? I'm guessing the answer is no but...
13:03:40 <nolrai> > ((Control.Arrow.pure 3) :: Int -> Int) 0
13:03:40 <lambdabot>   add an instance declaration for (Num (Int -> Int))
13:04:07 <oerjan> khalsah: you need a data type wrapper
13:04:12 <nolrai> (+ :: Int -> Int) 0
13:04:21 <nolrai> ((+1) :: Int -> Int) 0
13:04:24 <nolrai> >((+1) :: Int -> Int) 0
13:04:29 <nolrai> > ((+1) :: Int -> Int) 0
13:04:29 <lambdabot>  1
13:04:46 <oerjan> e.g. data Showable = forall a. Show a => SH a
13:05:05 <oerjan> aka existential types
13:05:34 <oerjan> then you can just put Showable's in your list
13:06:15 <nolrai> what is <*>
13:06:29 <oerjan> @src Applicative
13:06:29 <lambdabot> class Functor f => Applicative f where
13:06:29 <lambdabot>     pure  :: a -> f a
13:06:29 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
13:06:33 <Botje> it's ap for functors!
13:06:42 <khalsah> oerjan: thanks! I think that was exactly what I was looking for
13:07:34 <nolrai> and <$> is ap for applicables(sp)?
13:07:46 <shachaf> nolrai: (<*>) is ap.
13:07:48 <oerjan> > Just (+) <*> Just 1 <$> Just 1
13:07:49 <lambdabot>  Couldn't match expected type `a -> a1 -> b'
13:07:52 <shachaf> nolrai: (<$>) = fmap
13:07:58 <oerjan> er wrong way
13:08:17 <oerjan> > Just (+) <*> Just 1 <*> Just 1
13:08:18 <lambdabot>  Just 2
13:08:19 <desp> @hoogle OHandle
13:08:19 <lambdabot> No matches found
13:08:21 <desp> @hoogle Handle
13:08:22 <lambdabot> System.IO.Handle :: data Handle
13:08:22 <lambdabot> Control.Exception.handle :: (Exception -> IO a) -> IO a -> IO a
13:08:22 <lambdabot> System.IO.HandlePosn :: data HandlePosn
13:08:52 <oerjan> > (+) <$> Just 1 <*> Just 1
13:08:54 <lambdabot>  Just 2
13:09:27 <dmwit> > Just (+1) <*> Just 3
13:09:28 <lambdabot>  Just 4
13:09:28 <nolrai> Ahh. thanks
13:09:52 <dmwit> > Just (+) <*> Just 3 <*> Just 5
13:09:53 <lambdabot>  Just 8
13:10:04 <dmwit> neat
13:10:37 <OceanSpray> how do I figure out whether a value is an integer or a double?
13:10:45 <nolrai> >  [(+)] <*> [3] <*> [5]
13:10:45 <OceanSpray> what's the pattern match?
13:10:46 <lambdabot>  [8]
13:10:54 <oerjan> > [(+),(-)] <*> [10,20] <*> [1,2]
13:10:55 <lambdabot>  [11,12,21,22,9,8,19,18]
13:11:05 <shachaf> OceanSpray; Figure out?
13:11:10 <OceanSpray> find.
13:11:19 <OceanSpray> typecheck in runtime.
13:11:24 <shachaf> OceanSpray: Can you give more context?
13:11:40 <oerjan> OceanSpray: depends on what data type you put them in
13:11:50 <OceanSpray> I'd rather not, because it'd turn into one big "YOU SHOULDN'T BE DOING THIS IN THE FIRST PLACE" argument.
13:11:52 <shachaf> OceanSpray: Didn't you have a data LispNum = Int Int | Double Double | ...?
13:11:57 <OceanSpray> I got a value 'num'
13:12:08 <OceanSpray> case num of
13:12:10 <OceanSpray> ...?
13:12:12 <nolrai> >  [(+),(-)] <*> [3] <*> [5]
13:12:12 <lambdabot>  [8,-2]
13:12:14 <Toxaris> OceanSpray: :)
13:12:26 <Toxaris> OceanSpray: it depends on the static type of num
13:12:28 <nolrai> >  [(+),(-)] <*> [10,20] <*> [5]
13:12:29 <lambdabot>  [15,25,5,15]
13:12:29 <shachaf> OceanSpray: What's the type of the function?
13:12:46 <OceanSpray> Uhh...
13:12:59 <oerjan> OceanSpray: well with that LispNum type it would be case num of Int i -> ... ; Double d -> ...
13:13:06 <oerjan> (the one shachaf gave)
13:13:10 <OceanSpray> oh ok
13:13:16 <OceanSpray> that's all I need.
13:13:47 <oerjan> but note that the Int and Double there are the data constructors, which only accidentally had the same name as the type within
13:14:16 <nolrai> @hoogle <$>
13:14:16 <lambdabot> Control.Applicative.(<$>) :: Functor f => (a -> b) -> f a -> f b
13:14:22 <OceanSpray> Parser.hs:59:16: Not in scope: data constructor `Int'
13:14:28 <OceanSpray> well, damn
13:14:49 <Toxaris> OceanSpray: do you know how pattern matching works?
13:15:01 <OceanSpray> I thought I did.
13:15:09 <sannysanoff> hi gentlemen! sorry for lame question; is there any way to extract value from state monad variable in functional code?
13:15:19 <dmwit> sannysanoff: Yes!
13:15:27 <dmwit> sannysanoff: It depends how you want to get at it, though:
13:15:28 <oerjan> OceanSpray: you need to use the constructor name you used in your data definition
13:15:29 <dmwit> :t get
13:15:31 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
13:15:34 <dmwit> :t execState
13:15:34 <lambdabot> forall s a. State s a -> s -> s
13:15:39 <oerjan> as i just said :)
13:15:45 <sorear> dmwit: runS
13:15:54 <OceanSpray> that's... weird.
13:16:30 <dmwit> :t runState -- or, as sorear mentioned, maybe this is what you want
13:16:33 <lambdabot> forall s a. State s a -> s -> (a, s)
13:16:38 <dmwit> sannysanoff: Do one of those do what you want?
13:16:51 <nolrai> OceanSpray: is it a haskell int or your data type?
13:16:54 <sannysanoff> i need to pass initial "s"  in runState, but i only have "State s a"
13:17:14 <oerjan> OceanSpray: it's _not_ testing the type of the item within, really.  you usually don't want to do that in haskell.
13:17:19 <dmwit> sannysanoff: Right, that's what "get" is for. (?)
13:17:25 <dmwit> sannysanoff: Or do I misunderstand?
13:17:41 <oerjan> it's just testing whether it is in the slot that you decided to put Int's in, etc.
13:17:46 <nolrai> testing _a_
13:17:52 <sannysanoff> i will check this out.. but I still not undesrtand it well ;-)) can I use get in functional code?
13:17:56 <dmwit> sannysanoff: (Eventually, you will have to provide an initial state *somewhere*, the compiler can't guess what you want.)
13:18:08 <Toxaris> sannysanoff: (State s a)-values doesn't contain any state. they are actions wich use state of type s to produce values of type a. if you want to run such an action, you have to provide an initial state of type s.
13:18:09 <oerjan> for example there is nothing preventing you from giving two different constructors with Int's in them...
13:18:21 <dmwit> sannysanoff: No, as the type-signature of "get" shows, it must be used inside a State monad.
13:18:38 <sannysanoff> all: uh uh... Sorry, I am starting to get it!
13:18:50 <sannysanoff> all: so unusual, need to tweak my mind
13:18:56 <dmwit> heehee
13:19:05 <sfultong> anyone know of the state of the "Do What I Mean, Not What I Say" compiler?  I've been waiting a long time for it to be ready
13:19:17 <nolrai> sannysanoff: it has to be inside the state mondad, a value of State s a is a trans ion from one state to another.
13:19:19 <dons> yeah, hurry up with it already!
13:19:25 <dons> i want to not think when i program!
13:19:30 <OceanSpray> ok, here's the problem here.
13:20:05 <OceanSpray> I got data constructors (Real x) and (Integer x), which are then supposed to be passed into data contructor (Number n) to yield a LispVal
13:20:14 <OceanSpray> right now, I got:
13:20:21 <oerjan> OceanSpray: you'll probably have to show us the data definitions
13:20:32 <nolrai> so match on (Number (Integer x))
13:20:39 <OceanSpray> lispNum = liftM (Number . Integer) integer <|> liftM (Number . Real) float
13:20:48 <OceanSpray> note that lispNum is a Parser LispVal
13:20:50 <OceanSpray> from Parsec
13:20:58 <oerjan> OceanSpray: what nolrai said, i think
13:21:21 <roconnor> @src guard
13:21:21 <lambdabot> guard True  =  return ()
13:21:21 <lambdabot> guard False =  mzero
13:21:38 <roconnor> @src unless
13:21:39 <lambdabot> unless p s = if p then return () else s
13:21:49 <nolrai> hence my complaing about lots of parens in my patterns.
13:21:52 <OceanSpray> I was trying to do (integer <|> float), where integer and float are Parser Integer and Parser Double, respectively
13:22:01 <OceanSpray> but that didn't work
13:22:08 <OceanSpray> so I can't use pattern matching.
13:22:09 <roconnor> what's the opposite of unless
13:22:20 <OceanSpray> when?
13:22:20 <Toxaris> OceanSpray: what has pattern matching to do with parsing?
13:22:40 <roconnor> @src when
13:22:40 <lambdabot> when p s = if p then s else return ()
13:22:41 <OceanSpray> I'm... not sure.
13:22:54 <oerjan> OceanSpray: lispNum = liftM Number (liftM Integer integer <|> liftM Real float) should work
13:23:09 <OceanSpray> thanks, I'll try that.
13:23:10 <Toxaris> parsing is for constructing values out of smaller values, pattern matching is for deconstructing values into smaller values
13:23:17 <sfultong> dons: has anyone ever told you that your nick reminds them of this?: http://us.st11.yimg.com/us.st.yimg.com/I/engrish-store_1976_2706158
13:23:19 <roconnor> cdsmithus: if any (diagonal (r, c)) ps then return () === when (any (diagonal (r,c)) ps)
13:23:20 <lambdabot> http://tinyurl.com/yr7dt8
13:23:20 <oerjan> although it's really equivalent...
13:23:24 <OceanSpray> never actually thought of using multiple liftMs
13:23:38 <OceanSpray> oerjan, equivalent?
13:23:40 <nolrai> yeah you need - (integer >>= return . Integer) <|> (float >>= return.float)
13:24:06 <dmwit> nolrai: x >>= return . y === liftM y x
13:24:10 <oerjan> OceanSpray: oh wait. you said you wanted integer to have type Parser Integer?
13:24:24 <nolrai> duhhhhh!
13:24:26 <OceanSpray> it already has type Parser Integer
13:24:32 <OceanSpray> not MY Integer, Haskell's Integer
13:24:38 <oerjan> er right.
13:24:41 <nolrai> me stupid
13:24:48 <oerjan> never mind that.
13:24:53 <nolrai> right thats the problem.
13:25:01 <dons> sfultong: never seen it, but that's awesome
13:25:16 <nolrai> It should be your Integer.
13:25:42 <Toxaris> nolrai: no it shouldn't. he has no Integer-type, just an Integer constructor for an dynamically typed LispNum type
13:25:48 <OceanSpray> ok, so I make two extra parsers?
13:25:52 <qweqwe> someone here understands redblack trees?
13:25:54 <sfultong> dons: you should buy one, wear it
13:25:58 <dons> i think i should.
13:26:04 <dons> fomr http://www.engrish-store.com/dondonelt.html ?
13:26:05 <lambdabot> Title: Don Don Elephant T-shirt
13:26:07 <oerjan> OceanSpray: what you have already should work
13:26:15 <roconnor> cdsmithus: wait, I screwed that up
13:26:17 <Toxaris> everyone knows OceanSpray's code by heart by now :)
13:26:24 <roconnor> @src unless
13:26:24 <lambdabot> unless p s = if p then return () else s
13:26:29 <nolrai> no change the parsers you do have to return lispVals(or what ever).
13:26:38 <oerjan> separating out liftM Number doesn't really make a difference
13:26:49 <OceanSpray> but it isn't.
13:27:04 <Toxaris> why are we talking about changing OceanSpray's already working parser code? (it is working, isn't it?)
13:27:13 <sfultong> dons: yup, that tshirt
13:27:20 <oerjan> OceanSpray: or wait, maybe you want lispNum to have type Parser Number ?
13:27:20 <OceanSpray> > 2
13:27:20 <OceanSpray> Parsing error: "screw" (line 1, column 2):
13:27:22 <lambdabot>  2
13:27:34 <OceanSpray> > 2.3
13:27:34 <OceanSpray> 2.3
13:27:34 * dons orders a tshirt
13:27:34 <lambdabot>  2.3
13:27:52 <qweqwe> can someone explain to me that redblack algorithm http://pastebin.com/m335d5d3d
13:27:56 <oerjan> OceanSpray: oh ... you may need try around the first parser
13:28:02 <qweqwe> tree
13:28:04 <OceanSpray> that's when I put liftM (Number . Real) float first.
13:28:27 <OceanSpray> but when I put liftM (Number . Integer) integer BEFORE float,
13:28:43 <OceanSpray> I get > 3.4
13:28:43 <OceanSpray> 3
13:28:50 <dmwit> OceanSpray: Yes, we get it.  oerjan has already given you the solution, too.
13:29:27 <OceanSpray> have lispNum have type Parser Number?
13:29:40 <oerjan> OceanSpray: no, it seems your problem is missing try
13:29:43 <dmwit> No, put "try" around the first parser.
13:30:01 <OceanSpray> :t try
13:30:03 <lambdabot> Not in scope: `try'
13:30:57 <oerjan> to be more efficient, Parsec throws away the alternatives once _one_ character matches in the first parser, unless you put it in try
13:31:04 <qweqwe> can someone explain to me that redblack algorithm http://pastebin.com/m335d5d3d
13:31:15 <qweqwe> how it works
13:32:04 <qweqwe> why it works so i mean
13:32:18 <nolrai> how are traverse and fmap differnt?
13:32:44 <Toxaris> qweqwe: you could consider reading something about it and then asking concrete questions
13:32:55 <oerjan> nolrai: traverse allow you to do actions while traversing, fmap can only collect pure values
13:33:17 <nolrai> @ty traverse
13:33:19 <lambdabot> Not in scope: `traverse'
13:33:27 <oerjan> :t Data.Traversable.traverse
13:33:28 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
13:33:34 <qweqwe> i know that tree algorithm but i can"t understand merge of two trees
13:33:50 <qweqwe> why it goes so
13:35:02 <nolrai> can you define fmap in terms of traverse?
13:35:15 <oerjan> yeah i think so
13:35:26 <OceanSpray> whoo!
13:35:30 <OceanSpray> it finally works.
13:35:42 <oerjan> in fact the module contains an fmapDefault function for this use
13:35:51 <OceanSpray> thanks, people, for putting up with this annoyance.
13:36:05 <oerjan> fmapDefault f = getId . traverse (Id . f)
13:37:04 <oerjan> that uses the Identity monad, which is trivial
13:37:45 <oerjan> :t Id
13:37:47 <lambdabot> Not in scope: data constructor `Id'
13:37:52 <oerjan> @index Id
13:37:52 <lambdabot> bzzt
13:38:08 <oerjan> oh wait it's defined in the module
13:38:51 <oerjan> defined and _not_ exported, although i think it exists under a different name elsewhere
13:38:57 <oerjan> @index Identity
13:38:57 <lambdabot> Control.Monad.Identity, Control.Monad.Identity
13:39:31 <nolrai> Ok that makes sense.
13:42:16 <oerjan> @instances-importing Control.Monad.Identity Applicative
13:42:16 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
13:42:25 <oerjan> @instances-importing Control.Monad.Identity Control.Applicative Applicative
13:42:26 <lambdabot> ((,) a), ((->) a), Const m, IO, Maybe, WrappedArrow a b, WrappedMonad m, ZipList, []
13:43:00 <oerjan> seems to be missing an instance there
13:43:51 <nolrai> my Instance of Foldable is empty but ghc isn't complaining?
13:44:29 <oerjan> it defaults to making all the methods undefined, alas
13:44:36 <monochrom> haha great
13:44:49 <nolrai> thats a trap.
13:44:59 <oerjan> except those with defaults
13:45:18 <oerjan> yeah, it could be better
13:46:00 <nolrai> so fmap should be traverse fmapDefault, right?
13:46:15 <oerjan> no, just fmapDefault
13:47:07 <nolrai> the doc is confusingly writen.
13:47:19 <oerjan> are you sure you need to define an instance yourself?
13:47:58 <nolrai> as oposed to? its my data type.
13:48:17 <oerjan> i guess so.
13:48:29 <nolrai> its only two lines.
13:48:30 <oerjan> if it's a newtype you could try deriving
13:49:04 <oerjan> anyway, Minimal complete definition: foldMap or foldr
13:49:12 <oerjan> for Foldable
13:49:42 <nolrai> and i can set foldMap = foldMapDefault so that works.
13:50:29 <oerjan> right i guess
13:51:12 <nolrai> and now i can use - wait what was the point of all this?
13:52:04 <oerjan> foldMap = foldMapDefault for Foldable, fmap = fmapDefault for Functor
13:52:34 <oerjan> and then, "Minimal complete definition: traverse or sequenceA" for Traverse itself
13:52:43 <oerjan> *Traversable
13:57:28 <nolrai> yeah so the whole thing is only 7 lines.
13:57:35 <nolrai> and now i can use mapM.
14:01:29 <nolrai> :mapM
14:01:41 <nolrai> @ty mapM
14:01:42 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
14:02:02 <oerjan> that's the Control.Monad one
14:02:08 <oerjan> there's a name clash
14:02:08 <nolrai> ok good
14:03:34 <nolrai> its in the prelude so i have to hide it.
14:06:04 <glguy> hmm, is there a more direct way to get    f :: Word8 -> Char  than   toEnum . fromEnum?
14:06:25 <glguy> chr . fromEnum    is shorter in terms of keystrokes, but still works through Int ..
14:06:54 <oerjan> ought to be optimized away...
14:06:56 <dons> w2c = unsafeChr . fromIntegral
14:06:57 <nolrai> is there a way to browse a module in ghc if ghci crashes?
14:07:08 <dons> c2w = fromIntegral . ord
14:07:13 <glguy> ?index unsafeChr
14:07:13 <lambdabot> bzzt
14:07:18 <dons> GHC.Base
14:07:35 <dons> see Data.ByteString.Internal.{w2c,c2w}
14:08:16 <glguy> hmm, I don't want to resort to GHC specific function, this conversion isn't *that* critical
14:08:17 <glguy> :)
14:08:29 <oerjan> dons: why not just a rule?
14:08:33 <dons> replace unsafeChr with chr
14:08:40 <dons> oerjan: a rule for what?
14:09:28 <oerjan> fromIntegral . fromEnum with Char -> Word8
14:09:53 <glguy> I'm just playing with a bf interpreter:  program :: ReadP [Zipper Word8 -> IO (Zipper Word8)]
14:10:05 <glguy> since it came up last night
14:10:07 <oerjan> er wait
14:10:08 <glguy> and I wanted to play with ReadP
14:10:10 <oerjan> the other way
14:11:01 <oerjan> since unsafeChr is a ghc-specific optimization anyway, isn't it.
14:11:23 <dons> oerjan: oh, jsut a rule for that. yeah, you could replace chr with unsafeChr via a rule
14:12:22 <hpaste>  glguy pasted "playing with BF and ReadP" at http://hpaste.org/4351
14:12:32 <glguy> I know everyone's written one of these and most are shorter
14:13:03 <glguy> look who's on irc!
14:13:27 <monochrom> who?
14:13:35 <yavor> hey you are there
14:13:40 <glguy> need me?
14:13:46 <yavor> i have a darcs question but the darcs channel is silent :-)
14:13:53 <glguy> oh, need don?
14:14:14 <yavor> anyone really:  how do i get a file from a darcs repo that i have since deleted?
14:14:25 <yavor> i need to rollback all patches up to  a point, or something
14:14:58 <dons> so you've just deleted the file?
14:15:08 <dons> does it show up in : darcs whatsnew -s ?
14:15:17 <dons> in which case, darcs revert
14:15:22 <yavor> no, i deleted some time ago, and i just realized that i need it
14:15:34 <dons> ok. and you've recorded patches since then?
14:15:38 <yavor> yes
14:15:58 <dons> i'l darcs unpull until you get back to the patch that last had that file
14:16:01 <dons> then copy the file out
14:16:06 <dons> maybe do it in a copy
14:16:17 <yavor> oh yes.  i already messed up a few copies :-)
14:16:33 <quicksilver> ick, that sounds really heard
14:16:35 <quicksilver> hard
14:16:35 <OceanSpray> I read somewhere that monads are equivalent to continuations.
14:16:46 <glguy> dons, you should write a blog post about how darcs makes hard what git makes easy
14:16:47 <OceanSpray> Why, then, is there are Cont monad?
14:16:49 * quicksilver looks unconvinced by darcs' interface.
14:17:03 <quicksilver> OceanSpray: tehre is a Cont monad.
14:17:08 <quicksilver> :t Cont
14:17:10 <lambdabot> forall a r. ((a -> r) -> r) -> Cont r a
14:17:12 <OceanSpray> I know.
14:17:13 <dons> glguy: i think you should!
14:17:21 <OceanSpray> why IS there a Cont monad?
14:17:28 <dons> being the git uber master of #haskell, as you are
14:17:29 <glguy> dons, think of me more as a muse than a *blagger*
14:17:35 <dons> oh, you're my muse eh?
14:17:39 <quicksilver> OceanSpray: because continuations are a useful kind of effect?
14:17:51 <dmwit> OceanSpray: Monads are computations, not continuations.
14:18:07 <quicksilver> OceanSpray: I think the correct statement of what you refer to is "all monads can be expressed with state + continuation".
14:18:25 <glguy> yavor: convert your repository to a git repo,   git checkout   old_revision_name:file_you_wanted.ext
14:18:26 <quicksilver> so StateT s Cont r a is somehow univerasal
14:19:05 <yavor> ok the unpull worked, and it was not too bad
14:19:20 <yavor> thanks
14:19:34 <andyjgill> With monads, you can think of them as their unfolding (StateM => passing state via tuples, for example)
14:20:10 <andyjgill> With Continuations, you can do other tricks which can hurt the head, and not be unfolded in the same way.
14:20:30 <andyjgill> (Sounding old) in Haskell 1.2, IO was done using continuations
14:21:17 <glguy> hmm, worst part about making a fire is having to clean up the ashes
14:21:19 <allbery_b> Cont represents a computation which can be aborted early
14:22:04 <andyjgill> They are called double-barreled continuations
14:22:19 <andyjgill> monad x  ==> (
14:22:57 <andyjgill> monad x ==> fail cont -> pass cont -> ...
14:23:29 <OceanSpray> oh wow.
14:26:38 <yavor> "shoot yourself in the foot with a double barrel continuation"? :-)
14:27:33 <ricky_clarkson> allbery_b: Without side-effects, why would there be a distinction between continuations that can be aborted early and those that cannot?
14:30:00 <allbery_b> I think that question is why Cont is not widely used :)
14:30:29 <nolrai> I almost thought about using it.
14:30:37 <conal> how does one get the return code of a unix (cygwin really) process run in a shell?
14:30:54 <olsner> something like $? iirc
14:30:56 <conal> i think cabal's invocation of haddock is returning an error code.
14:31:25 <dmwit> Use zsh, it will tell you automatically. ;-)
14:31:35 <dmwit> Also, yes, $?.
14:31:45 <olsner> dmwit: I'm pretty sure you have to enable some extra feature to actually get that though
14:31:54 <olsner> (never seen it in my zsh's)
14:32:00 <nolrai> @hoogle Error
14:32:01 <lambdabot> System.IO.Error :: module
14:32:02 <lambdabot> Foreign.Marshal.Error :: module
14:32:02 <lambdabot> Foreign.C.Error :: module
14:32:05 <dmwit> setopt printexitvalue
14:32:15 <dfranke_> There's not currently any syntax for infix GADT constructors, correct?
14:32:34 <sorear> dfranke_: why would there be?  what would it mean?
14:32:37 <nolrai> is there a Error monad, i can find ErrorT but not Error?
14:32:44 <sorear> dfranke_: can you give an example?
14:33:01 <dfranke_> sorear: it's just that I'm contributing a patch for ticket #1966, and doing warning cleanup in the process...
14:33:02 <nolrai> whats GADT?
14:33:16 <sorear> dfranke_: ie, what doesn't work about the obvious extension data X where (:+) :: X -> X -> X
14:33:18 <dfranke_> sorear: and I'm getting an inexhaustive pattern warning for the pretty printer that would handle that.
14:34:05 <dfranke_> sorear: and I want to make sure that that's really an impossible case.
14:36:08 <nolrai>  :t throwError
14:36:16 <nolrai> @ty throwError
14:36:17 <lambdabot> forall e (m :: * -> *) a. (MonadError e m) => e -> m a
14:45:49 <sorear> dfranke_: does my sxample work?
14:51:01 <dfranke_> sorear: I haven't checked, but that would parse as prefix notation anyway.
14:52:37 <sorear> dfranke_: huh?
14:52:49 <sorear> dfranke_: what are you trying to do?
14:53:59 <oerjan> dfranke_: um there are no infix type declarations of functions, so why should there be of constructors?
15:08:21 <jimstutt> @listmodules
15:08:22 <lambdabot> activity babel base bf check compose dice dict djinn dummy elite eval fact figlet free fresh ft haddock help hoogle instances irc karma localtime log maya more oeis offlinerc pl pointful poll pretty
15:08:22 <lambdabot> quote search seen slap small source spell state system tell todo topic type undo unlambda unmtl url version vixen where
15:09:34 <oerjan> @list maya
15:09:34 <lambdabot> maya provides: temp forecast ring
15:09:44 <oerjan> @help forecast
15:09:44 <lambdabot> Local forecast
15:09:54 <oerjan> @help temp
15:09:54 <lambdabot> Local temperature
15:10:00 <sieni> @help slap
15:10:00 <lambdabot> slap <nick>. Slap someone amusingly.
15:10:04 <oerjan> @temp
15:10:07 <sieni> @slap lambdabot
15:10:08 <lambdabot> *SMACK*, *SLAM*, take that lambdabot!
15:10:12 <cjay> @temp
15:10:28 <sieni> @help irc
15:10:28 <lambdabot> irc is a module.
15:10:38 <oerjan> @list fresh
15:10:38 <lambdabot> fresh provides: freshname
15:10:44 <oerjan> @freshname
15:10:45 <lambdabot> Haa
15:10:59 <ddarius> @help freshname
15:10:59 <lambdabot> freshname. Return a unique Haskell project name.
15:11:01 <dmwit> Next up, Hab.
15:11:04 <dmwit> Then Hac.
15:11:08 <ddarius> @freshname Hide
15:11:08 <lambdabot> Hab
15:16:21 <duksdiha> si alguien habla espaol... necesito ayuda
15:16:47 <dons> blackdog: know the swirlies?
15:16:49 <oerjan> #haskell.es
15:16:51 <duksdiha> definiendo una clase y una instancia de la clase
15:16:52 <dons> duksdiha: perhaps ask on #haskell.es ?
15:17:02 <dons> ?babel es en si alguien habla espaol... necesito ayuda
15:17:03 <lambdabot>   if somebody speech espaol... I need aid
15:17:11 <dons> ?babel en es definiendo una clase y una instancia de la clase
15:17:11 <lambdabot>   clase y una instancia de la clase del una del definiendo
15:17:12 <duksdiha> thankyou
15:17:22 <dons> ok :)
15:17:32 <dmwit> He's trying to define a class and an instance of the class. ;-)
15:17:35 <dons> yep
15:17:49 <mudge> hey dons
15:18:00 <duksdiha> dons en #haskell.es planteo el problema, por si quieres ayudarme
15:18:25 <dons> ?babel es en dons en #haskell.es planteo el problema, por si quieres ayudarme
15:18:26 <lambdabot>   dons in # haskell.es I create the problem, in case you want to help me
15:18:38 <dons> ?babel en es my spanish is not good enough
15:18:45 <lambdabot>   mi espaol no es bastante bueno
15:19:55 <ricky_clarkson> creo que "suficiente" es mejor que "bastante bueno"
15:20:40 <oerjan> not necessarily in that context.
15:20:52 <oerjan> you want them to believe you, after all :)
15:20:58 <ricky_clarkson> jeje
15:24:29 <chessguy> hola duksdiha, que hay/
15:26:19 <hpaste>  duksdiha pasted "clases e instancias" at http://hpaste.org/4352
15:26:45 <aca05rb> hi I was wondering if someone could advise me in creating a binary parser that turns "+" "(5+2) rest" into [(Expr,Expr,rest)]
15:27:28 <ricky_clarkson> Wow, #haskell.es is real and not just a 2-user channel like it is for other Spanish/foreign language channels.
15:28:06 <ricky_clarkson> I just wish I understood Haskell enough to be of some use there. ;)
15:30:58 <oerjan> instance (Enum a) => Medible a  is going to overlap with all the rest...
15:31:40 * SamB thinks apples typographers don't know english very well... claiming that a character has a single semantic or phonetic meaning, indeed...
15:32:21 <araujo> ricky_clarkson, surpringsily, #haskell.es is one of the biggest spanish speaker channel in the network :-)
15:32:34 <esteban2> why is this room so populated?
15:32:36 <araujo> (of a programming language)
15:32:42 <ddarius> esteban2: Why not?
15:33:02 <ddarius> @users
15:33:03 <lambdabot> Maximum users seen in #haskell: 414, currently: 412 (99.5%), active: 24 (5.8%)
15:33:23 <esteban2> dunno... #smalltalk has 18 people in it and i thought it was a popular language
15:33:48 <ddarius> They use other fora.
15:33:52 <ricky_clarkson> My guess is that smalltalk is less interesting to talk about.
15:34:02 <ricky_clarkson> Not because it's boring, but because it's more simple.
15:34:04 <vininim> maybe smalltalk is more easy to grasp =p
15:34:10 <vininim> yeah
15:34:23 <esteban2> all the object theory is also interesting
15:34:36 <ddarius> I suspect they just use a mailing list or a different network etc.
15:34:44 <dons> languages with new ideas, versus languages we finished thinking about in 1990
15:34:57 <SamB> dons: slowed down a lot, anyway
15:35:10 <ricky_clarkson> I can't stop thinking that objects just become functions or bags of functions when you take out the inconsistencies.
15:35:15 <SamB> ST80 only came out in 1980, you know...
15:35:23 <ddarius> ST72..
15:35:40 <SamB> I heard that ST72 is a heck of a lot different from ST80...
15:36:38 <ddarius> Play guitar or crochet?
15:37:05 <vininim> uh what?
15:37:42 <RayNbow> @src fail
15:37:43 <lambdabot> fail s      = error s
15:38:09 <RayNbow> lambdabot makes you lazy :p
15:40:37 <hpaste>  duksdiha pasted "clases e instancias" at http://hpaste.org/4353
15:48:27 <jimstutt> Can't resist this - quiver of arrows
15:48:40 <jimstutt> http://www.swaminarayan.org/yogijimaharaj/talesofwisdom/44.htm
15:48:41 <lambdabot> Title: 101 Tales of Wisdom - A Quiver of Arrows
15:49:54 <v1rtus> Hi everybody, I have problem with FFI on windows. I've created small test application that compiles and runs on linux wihtout problem, but on windows I get linker error. If anybody would like to help here is copypaste http://rafb.net/p/TkU1ll24.html
15:50:43 <v1rtus> There are 3 files, Test.hs, test.c and test.h, and output from both linux and windows.
15:50:59 <jimstutt> @wikipedia quiver
15:50:59 <lambdabot> No Result Found.
15:52:36 <dmwit> What's the dynamic typing library for Haskell?
15:52:39 <dmwit> ?hoogle Dynamic
15:52:39 <lambdabot> Data.Dynamic :: module
15:52:39 <lambdabot> Data.Dynamic.Dynamic :: data Dynamic
15:52:39 <lambdabot> Data.Dynamic.fromDynamic :: Typeable a => Dynamic -> Maybe a
15:57:06 <luqui> is there a way to make ghci be quiet so I can pipe something into it and just get the output?
15:57:15 <luqui> (by something I mean an expression)
15:57:18 <TSC> ghci -e ?
15:57:27 <allbery_b> ghc -e 'expr' might be better
15:57:27 <luqui> woah
15:57:31 <luqui> I thought I tried that
15:57:51 <luqui> well, thanks :-p
16:03:37 <roconnor> > logBase 2 (product [1..52])
16:03:39 <lambdabot>  225.5810031237028
16:06:43 <hpaste>  nornagon pasted "Removing the 'x' point from ltSqrt significantly increases performance?" at http://hpaste.org/4354
16:07:10 <nornagon> ^-- running with ghc -O2
16:07:11 <vininim> > forM [1..] return
16:07:12 <lambdabot>   add an instance declaration for (Show (m [t]))
16:07:48 <nornagon> with the pointed function, it takes 17s on my computer... remove the point and it runs in under 2 seconds
16:07:52 <glguy> nornagon, makes it less polymorphic?
16:08:09 <glguy> nornagon, try adding a type signature while keeping the x?
16:08:14 <hpaste>  virtus pasted "FFI problem on windows" at http://hpaste.org/4355
16:08:55 <vininim> > forM [1..10] return
16:08:55 <lambdabot>   add an instance declaration for (Show (m [t]))
16:09:01 <oerjan> nornagon: without a point, ltSqrt n might be able to cache intSqrt n, is my guess
16:09:14 <nornagon> i thought ghc didn't do caching?
16:09:18 <vininim> > join (forM [1..10] return)
16:09:18 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
16:09:35 <nornagon> glguy: i'm pretty sure the two functions have the same type signature
16:09:40 <nornagon> at least, ghci tells me that
16:09:51 <nornagon> Prelude> :t \n x -> (<= (intSqrt n)) x
16:09:51 <nornagon> \n x -> (<= (intSqrt n)) x :: Integer -> Integer -> Bool
16:09:56 <nornagon> Prelude> :t \n -> (<= (intSqrt n))
16:09:56 <nornagon> \n -> (<= (intSqrt n)) :: Integer -> Integer -> Bool
16:10:11 <oerjan> nornagon: no, but there is then no reevaluation
16:10:31 <nornagon> oh?
16:11:06 <oerjan> because ltSqrt n = (<= (intSqrt n))  is just one expression on the right
16:11:35 <oerjan> so takeWhile (ltSqrt n) primes only evaluates ltSqrt n once
16:11:50 <nornagon> ah.
16:11:54 <vininim> > join (forM [1..] return)
16:11:55 <lambdabot>  Exception: stack overflow
16:12:28 <vininim> hum... I must learn about lazy evaluation and monads
16:12:41 <nornagon> reinerp: boo
16:12:49 <oerjan> :t join (forM [1..] return)
16:12:50 <reinerp> heh
16:12:50 <lambdabot> forall t. (Num t, Enum t) => [t]
16:13:15 <oerjan> :t (forM [1..] return)
16:13:16 <lambdabot> forall t (m :: * -> *). (Num t, Enum t, Monad m) => m [t]
16:13:23 <reinerp> :t 5
16:13:24 <lambdabot> forall t. (Num t) => t
16:13:34 <oerjan> > (forM [1..] return)
16:13:34 <lambdabot>   add an instance declaration for (Show (m [t]))
16:13:43 <oerjan> > (forM [1..] return) :: [[Int]]
16:13:44 <lambdabot>  Exception: stack overflow
16:13:46 <nornagon> maybe ghc should remove points sometimes in the optimisation stage :)
16:14:41 <glguy> vininim, You have to evaluate the WHOLE list to know the answer
16:14:51 <glguy> vininim, because if a [] was ever returned
16:14:53 <oerjan> nornagon: i think ghc assumes that the programmer knows best whether to reevaluate or to cache, either decision could cause space leaks
16:14:55 <glguy> then the result would be []
16:15:12 <nolrai> @ty any
16:15:12 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
16:15:13 <glguy> and ghc doesn't know that every result will be non null
16:15:36 <hpaste>  araujo pasted "(no title)" at http://hpaste.org/4356
16:15:58 <glguy> > join (forM [1..] (\x -> if x < 10 then return x else []))
16:15:59 <lambdabot>  []
16:16:28 <vininim> @src join
16:16:28 <lambdabot> join x =  x >>= id
16:16:41 <vininim> @src forM
16:16:41 <lambdabot> forM = flip mapM
16:17:02 <vininim> @src mapM
16:17:03 <lambdabot> mapM f as = sequence (map f as)
16:17:09 <nolrai> is there an genralization of any to functors?
16:17:10 <vininim> ah ok
16:17:33 <ddarius> nolrai: It doesn't generalize to an arbitrary functor.
16:17:44 <mattam> Is there any consensus regarding what CoMonads should look like in Haskell, and code ?
16:17:53 <nolrai> or do i mean foldables?
16:18:01 <ddarius> You could do it with Foldable.
16:18:11 <ddarius> mattam: It's just another type class.
16:18:37 <mattam> Is there a standard definition somewhere you could point me to ?
16:18:53 <nolrai> @ty foldMap
16:18:54 <lambdabot> Not in scope: `foldMap'
16:19:15 <nolrai> @hoogle foldMap
16:19:15 <ddarius> Nothing "blessed".  There sholud be something on hackage and there are a few papers.  Usually the Monad operations are just blindly dualized.
16:19:15 <lambdabot> Data.Foldable.foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
16:19:15 <lambdabot> Data.Traversable.foldMapDefault :: (Traversable t, Monoid m) => (a -> m) -> t a -> m
16:19:44 <nolrai> @ty Data.Foldable.foldMap
16:19:45 <lambdabot> forall a m (t :: * -> *). (Data.Foldable.Foldable t, Monoid m) => (a -> m) -> t a -> m
16:20:09 <ddarius> foldMapDefault would do it with the appropriate monoid.  (Bools form a monoid in two different ways.)
16:20:15 <ddarius> Er, foldMap
16:21:19 <mattam> ddarius: okay. I just have trouble dualizing the associativity property, but maybe it's just too late in the night :)
16:21:46 <ddarius> mattam: It's just associativity.  Alternatively use the duals of return and join and work from there.
16:21:57 <nolrai> what does one use CoMonads for?
16:23:16 <ddarius> newtype Conj = Conj { unConj :: Bool }; instance Monoid Conj where mempty = Conj True; mappend (Conj a) (Conj b) = Conj (a && b); Then unConj . foldMap (Conj . p) would be a generalized all, and dually for a Disj newtype would be a generalize any.
16:23:30 <ddarius> nolrai: Coalgebriac things.
16:23:50 <goalieca> lol @ math
16:24:22 <vininim> @src sequence
16:24:23 <lambdabot> sequence ms = foldr k (return []) ms
16:24:23 <lambdabot>     where
16:24:23 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
16:24:25 <ddarius> @src all
16:24:25 <lambdabot> all p =  and . map p
16:24:31 <ddarius> @src and
16:24:32 <lambdabot> and   =  foldr (&&) True
16:24:35 <ddarius> @src or
16:24:35 <lambdabot> or    =  foldr (||) False
16:26:04 <StaZ|home> hey guys, i'm a little confused here what is an "Ordering"... i wanna use the sortBy function that takes a (a -> a -> Ordering) function, so i made a myfunc (myClass a1 list1) (myClass a2 list2) = a1 `elem` list2   but it doesn't seem to work
16:26:18 <mauke> @src Ordering
16:26:19 <lambdabot> data Ordering = LT | EQ | GT
16:26:30 <StaZ|home> ahhhhh!
16:26:39 <StaZ|home> of course, i forgot the data constructor syntax
16:26:40 <StaZ|home> thanks
16:26:48 <ddarius> :t compare
16:26:48 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
16:28:27 <ddarius> vininim: Incidentally, sequence = foldr (liftM2 (:)) (return [])
16:32:50 <dons> xmonad 0.5 released
16:32:51 <dons>   http://xmonad.org/news.html#2
16:32:51 <lambdabot> Title: xmonad : news
16:33:03 <dcoutts> dons: yay
16:33:16 <dcoutts> maybe this one will make it into portage :-)
16:33:22 <dons> i hope so!
16:34:14 <dcoutts> dons: -Werror is not a good idea in a released version
16:34:23 <nolrai> allr prepositon struct = (foldr && True) (fmap prepositon struct)
16:34:25 <nolrai> anyr prepositon struct = (foldr || False) (fmap prepositon struct)
16:34:26 <nolrai> whould work right?
16:34:34 <dcoutts> dons: it confuses people enormously when ghc adds a new warning. I've seen this happen.
16:34:59 <dons> dcoutts: oh, that's a good point
16:35:24 <luqui> nolrai, no, I don't think so
16:35:37 <luqui> nolrai, maybe you mean (foldr (&&) True), etc.
16:36:13 <nolrai> yes
16:36:17 <dcoutts> dons: what does -optl-Wl,-s do ?
16:36:26 <dons> strips the binary
16:36:46 <sorear> dcoutts: iirc, people were complaining about the filesize of xmonad
16:37:10 <luqui> nolrai, and in that case, yes (fmap is a little strange there, why not just map?)
16:38:02 <nolrai> is there a way to tell ghc "when module a conflicts with module m just allwas go with m"?
16:38:05 <dcoutts> dons: hmm, that's something that cabal should do automatically and let distributers turn on or off. Portage prefers to do striping itself, we get QA warnings if we get any pre-stripped binaries.
16:38:18 <dcoutts> dons: want to file a feature request for cabal binary striping?
16:38:25 <nolrai> lugui: the point is to have it work on trees and such.
16:38:30 <dcoutts> dons: (though check if one exists already)
16:38:35 <nolrai> luqui: the point is to have it work on trees and such.
16:38:43 <luqui> nolrai, ah, that won't work then
16:38:47 <luqui> because foldr wants a list
16:38:59 <luqui> you need a way to turn struct into a tree
16:39:07 <nolrai> no it dosnt
16:39:09 <luqui> er, a list
16:39:26 <luqui> nolrai, oh, you're using a different version of foldr
16:39:27 <luqui> ?
16:40:02 <nolrai> yeah Data.Foldable.foldr
16:40:07 <luqui> aa soo
16:41:44 <jimstutt> http://comonad.com
16:45:02 <nornagon> "waiting for comonad.com" :(
16:45:53 <sorear> @botsnack
16:45:53 <lambdabot> :)
16:46:06 <dmwit> It is a funny joke. =)
16:48:05 <mauke> :t guard
16:48:07 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
16:48:27 <idnar> haha
16:49:03 <jimstutt> all, sorry
16:49:20 <nolrai> @ty fail
16:49:21 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
16:49:56 <oerjan> nolrai: er, all and any already have Data.Foldable versions too
16:50:21 <nolrai> dohh!
16:51:15 <oerjan> although that certainly won't help with your module conflict problem :D
16:51:53 <nolrai> the hideing line on Prelude is only like 9 functions.
16:52:26 <jimstutt> comonad.com turns up eventually - not a joke.
16:52:46 <oerjan> nolrai: the alternative usually is something like import Data.Foldable as F
16:53:02 <oerjan> er
16:53:13 <oerjan> import qualified Data.Foldable as F
16:53:33 <nolrai> the first works too, right?
16:53:57 <oerjan> sure, it is a tradeoff
16:54:22 <oerjan> list all the functions in the import, or add a qualifier to every use
16:55:47 <dmwit> nolrai: They both work, but they have different meanings.
17:00:36 <nolrai> eh I'll stick with hiding, it just is annoying  because I never want the prelude version.
17:01:08 <ddarius> :t Data.Foldable.foldr
17:01:09 <lambdabot> forall a b (t :: * -> *). (Data.Foldable.Foldable t) => (a -> b -> b) -> b -> t a -> b
17:05:13 <oerjan> nolrai: my impression is there is a growing market for someone making an alternative, maximally generalized Prelude
17:05:33 <nolrai> that would be nice.
17:06:37 <nolrai> can you export funtions that use type classes with out exporting the class?
17:06:53 <dmwit> I look forward to the "import Prelude (); import RealPrelude" days.
17:07:08 <dmwit> nolrai: yes
17:07:56 <dmwit> ghc --fnew-prelude
17:08:11 <nolrai> then that would be perfect.
17:08:28 <Karle> hi
17:08:48 <dmwit> Hi, Karle!
17:09:16 <Karle> I have got a lot of helps from you guys... I would likt to thank all you all...
17:10:32 <BMeph> Karle: okay, whenever you want to, don't let us stop you... ;)
17:11:50 <dmwit> BMeph: Ah, I love this channel.  Pedantic, even when getting compliments. =)
17:20:14 <davidL> is PHP turing complete?
17:20:34 <loupgaroublond> afaik, yes
17:21:19 <hpaste>  mmorrow annotated "Adjoint funct(ors/ions) and some instances." with "free as in freedom" at http://hpaste.org/4345#a2
17:21:36 <mauke> why wouldn't it be?
17:22:10 <dmwit> Basically anything with dynamically-sized arrays is Turing complete.
17:23:20 <sorear> it's hard to make something interesting and yet not turing complete
17:23:35 <ricky_clarkson> SQL?
17:23:42 <ddarius> SQL? Various typed lambda-calculi?
17:23:50 <dmwit> regexes
17:24:07 <mauke> command.com
17:24:10 <sorear> ddarius: making typed lambda calculi is hard, if you want them to be incomplete
17:24:29 <dons> dcoutts: interesting thread here about people getting xmonad installed on gentoo
17:24:32 <dons>   http://forums.gentoo.org/viewtopic-t-627497-postdays-0-postorder-asc-start-0.html
17:24:34 <lambdabot> http://tinyurl.com/2m7329
17:24:35 <dons> various issues raised
17:24:36 * dcoutts reads
17:24:40 <dons> it /has/ to be easier, surely?
17:24:54 <ddarius> sorear: The simply typed lambda calculus is easy.  Even system F2 isn't that hard.  And LF is not too bad either.
17:25:27 <sorear> ddarius: Easy to implement, or easy to invent?
17:26:32 <ddarius> sorear: The general idea that leads to them is pretty obvious once you see it, and surely I doubt Church had much trouble making the simply typed lambda calculus.
17:27:29 <dons> the ease of getting ghc onto a system is probably the main barrier to xmonad adoption, fwiw. at least to experimentally trying it
17:27:31 <dcoutts> dons: the main chap who is having problems is using the overlay without any clue about what he's doing. He's playing with the latest 6.8.2 snapshot for example.
17:27:50 <dcoutts> it's people like him that should stick to portage
17:27:52 <dons> so that's solved by having obvious, stable ghc in portage?
17:28:08 <mauke> portage is still at 6.4, right?
17:28:10 * ddarius hasn't darcs pulled a new xmonad in a long, long time.
17:28:15 <smack_> dons: yeah.  the problem is you need the overlay currently for anything recent
17:28:25 <dons> ddarius: just running an old stable one? or ... ?
17:28:28 <ddarius> I don't think my current version of the source is even the version I'm running.
17:28:32 <ddarius> dons: An old darcs pull.
17:28:34 * sorear is still running 6.7 and xmonad darcs-before-0.4
17:28:42 <dons> might want to try the 0.5 release :)
17:28:52 <ddarius> Mine I think is either pre-0.3 or pre-0.4
17:28:57 <dons> though if it works, it works
17:29:14 <dcoutts> mauke: no 6.6.1
17:29:21 <sorear> dons: any killer features?  my xmonad is near-perfect as is :)
17:29:34 <dons> easier to configure. contrib library on hackage
17:29:39 <smack_> dcoutts: that's keyword masked still, isn't it?
17:29:40 <dons> bugs fixed with funny apps
17:29:50 <dcoutts> smack_: no it's stable on amd64 and x86
17:29:54 <mauke> ah, ok
17:30:01 <dmwit> I'm still using the first darcs version that floated Gimp. =P
17:30:02 <smack_> dcoutts: ah, nevermind, thanks.  (I'm on the overlay)
17:30:06 <sorear> dons: do I need to get 6.8 yet?
17:30:12 <dons> nope
17:30:18 <mauke> darcs xmonad works fine with 6.6.1
17:30:19 <sjanssen> sorear: you will need Cabal 1.2
17:30:19 <dcoutts> http://packages.gentoo.org/package/dev-lang/ghc
17:30:19 <lambdabot> Title: Gentoo Packages /package/dev-lang/ghc
17:30:56 <dons> i'm waiting to see xmonad on hppa...
17:30:57 * sorear should also get cabal-install, and cabal-1.2, and... ugh
17:31:05 <dons> cabal-install would be interesting
17:31:08 * dons should try that now..
17:31:25 * sorear checks if cabal-install and ghc6-6.8.2 are on debian yet
17:31:30 <dcoutts> dons: I'm hacking on cabal-install atm
17:31:35 <dons> $ cabal install xmonad
17:31:36 <dons> ...
17:31:38 <dcoutts> sorear: I expect cabal-install is not
17:31:51 <sorear> dcoutts: aww.
17:31:52 <dons> Downloading 'xmonad-0.5'...
17:32:00 <dons> building...
17:32:07 <dons> /usr/bin/ar: creating dist/build/libHSxmonad-0.5.a
17:32:20 <dcoutts> cabal-install's verboisty is all over the place
17:32:23 <dons> Installing: /home/dons/.cabal/lib/xmonad-0.5
17:32:43 <dons> $ cabal install xmonad-contrib
17:32:52 <dcoutts> dons: it puts binaries in .cabal/bin atm
17:32:55 <dons> apprently needs utf8-string
17:32:59 <dcoutts> ie not in the path
17:33:05 <dons> argh. failed in xmonad-contrib
17:33:17 <dons> freetype.h? hmm
17:33:25 <dons> oh, 'X11-xft-0.2'...
17:33:38 <dons> hmm. that should be off by default
17:34:01 <dons> not sure why it even thought utf8-lib/xft was dep.
17:34:03 <dons> ah well
17:34:04 <dons> xmonad worked
17:34:28 <dcoutts> dons: it's not off by default
17:34:35 <dcoutts> flag use_xft
17:34:36 <dcoutts>   description: Use Xft to render text
17:34:40 <dcoutts>     if flag(use_xft)
17:34:40 <dcoutts>         build-depends: X11-xft >= 0.2
17:34:46 <jimstutt> * xmonad-0.2 from ghc-6.8.1 runs on ubuntu gutsy 7.10
17:34:46 <dcoutts> that's on by default
17:34:47 <dons> flag use_xft description: Use Xft to render text
17:34:49 <dons> hmm
17:35:33 <dcoutts> dons: sure, if you try and build just that package on it's own and you do not have X11-xft installed then it does not select that configuration
17:35:40 <dons> oh, so cabal-install is just satisfying some more general deps , that cabal itself doesn't do on my local system
17:35:46 <dons> yep
17:35:48 <dcoutts> dons: but cabal-install can pull in extra deps from hackage so it does so
17:35:52 <dons> yeah
17:36:02 <dons> ok. hmm
17:36:09 <dcoutts> Setup.hs considers the available packages to be the installed ones
17:36:13 <sorear> aww.  ghc is only at 6.6.1
17:36:26 <dcoutts> cabal-install considers the available packages to be all of hackage
17:36:42 <dcoutts> sorear: distros will not upgrade ghc til the other stuff works
17:36:44 <sorear> what version should I use to build the HEAD?  I remember having trouble the last couple times I tried
17:36:55 <dcoutts> and many other pakcages at this point do not work with 6.8
17:37:27 <dcoutts> dons: we need to do a survey of the main packages and name and shame those that do not have versions on hackage yet that work with 6.8
17:38:17 <desp> Can I write a lambda expression with guards?
17:38:21 <sorear> no
17:38:24 <dons> the Xft issue looks like a portability problem
17:38:29 <desp> :C
17:38:31 <dons> dcoutts: yeah. all the build logs are there
17:39:10 <dmwit> desp: You can write case statements in a lambda, though.
17:39:17 <dcoutts> dons: though we cannot yet use those build logs to automatically email people since many packages that use FFI etc will not build on the hackage server
17:39:30 <dmwit> > (\c -> case () of () | odd c = 1 | even c = 2) 32
17:39:30 <lambdabot>  Parse error at "=" (column 30)
17:39:35 <mauke> > (\x | True -> x) 2
17:39:36 <lambdabot>  Parse error at "|" (column 5)
17:39:37 <dmwit> > (\c -> case () of () | odd c -> 1 | even c -> 2) 32
17:39:41 <lambdabot>  2
17:39:49 <desp> Ugh.
17:39:51 <desp> ;)
17:39:53 <dmwit> indeed =P
17:39:53 <sorear> asides from Robert Dockins, Mark Zander, and wli, does anyone else use vty?
17:40:03 <desp> ().()
17:40:59 <sorear> desp: error: tycon mismatch
17:41:16 <desp> Whoever can tell me what this does gets a cookie:
17:41:16 <dmwit> sorear: I almost did, but then the web-page for it said it sucked, so I started writing my own. =P
17:41:18 <desp> http://pastie.textmate.org/private/vb0kfwnsl1b4zlj24tzsga
17:41:19 <lambdabot> Title: Private Paste - Pastie
17:41:47 <sorear> dmwit: How did it suck?
17:41:55 <dmwit> sorear: I don't know, I never tried it.
17:42:43 <chessguy> desp, that's some ugly code
17:42:49 <desp> Thanks.
17:43:10 <chessguy> where'd it come from?
17:43:14 <desp> My brain.
17:43:32 <Botje> too. many. subfunctions. :(
17:44:03 <chessguy> and repetition
17:44:05 <chessguy> DRY
17:44:14 <desp> Repetition? Where?
17:44:23 <chessguy> and bad variable names
17:44:23 <sorear> desp: It generates a type error.
17:44:28 <desp> No way!
17:44:32 <ddarius> chessguy: I really wish people who said "Don't Repeat Yourself" would take their own advice.
17:44:33 <sorear> desp: Or rather, a constraint entailment error.
17:44:48 <chessguy> i try to
17:44:52 <sorear> desp: You use (show x), but Show a is not entailed by ord a, num a
17:44:57 <sorear> desp: or... *bah*
17:45:07 <dmwit> chessguy: He means, he wants you not to repeat the DRY maxim. ;-)
17:45:20 <desp> sorear: True, but that's just within a trace.
17:45:27 <sorear> desp: sorry, forgot that they idiotically required numbers to be Show-able, I try to forget decisions that stupid
17:45:27 <chessguy> i don't think i've ever said it in here, so i'm not repeating myself :)
17:45:35 <desp> sorear: However, GHC 6.6.1 doesn't barf on it.
17:45:41 <desp> Oh.
17:45:50 <desp> chessguy: Really, where do you see repetition?
17:46:34 <chessguy> p_ and h_i seem to do something similar, for example
17:46:39 <desp> Sorry about the variable names; replacing m!i with firstDerivativeCoefficient!i won't help things here.
17:46:52 <chessguy> and the makerarray calls all over the place...
17:46:56 <mauke> how do I make my brainf_k interpreter smaller :(
17:47:01 <chessguy> s/er/e/
17:47:25 <dmwit> mauke: More information, please. =P
17:47:39 <sorear> desp: it computes quadratic splines, badly
17:47:48 * dmwit refrains from pulling an ?hpaste on an old regular
17:47:52 <desp> sorear: Woop. You get a cookie.
17:47:54 <mauke> it's 598 bytes. I need to get under 512
17:47:59 <desp> sorear: Why badly, though? :)
17:48:00 <ddarius> It's an evil quadratic spline computer.
17:48:06 <ddarius> poorly
17:48:24 <desp> Yes, kill me now.
17:48:30 <sorear> desp: too much repetition, first-order-ness
17:48:30 <hpaste>  mauke pasted "brainf_k" at http://hpaste.org/4357
17:48:48 <sorear> desp: what is the 'f' parameter for?
17:49:06 <desp> sorear: f is the function that is interpolated by the spline.
17:49:11 <Botje> findInterval looks like a binary search :)
17:49:21 <dmwit> mauke: k=fmap.fmap
17:49:38 <desp> I would welcome any hints towards de-first-ordering this.
17:49:45 <sorear> desp: ah.  and within the interval, you want it to be C_1?
17:49:51 <desp> sorear: Exactly.
17:50:03 <mauke> dmwit: thanks!
17:50:18 <desp> Well, within the whole interval, i.e. q!1 .. q!n
17:51:24 <ddarius> @google "Refunctionalization"
17:51:25 <lambdabot> http://www.brics.dk/RS/07/7/
17:51:25 <lambdabot> Title: Refunctionalization at Work
17:51:50 <dmwit> mauke: p""=z([],[])
17:51:54 <desp> This is my assignment for a numerical analysis lab; since I find the subject boring I figured I'd make the TAs read Haskell for a change.
17:52:20 <mauke> dmwit: z is monomorphic
17:52:25 <dmwit> =/
17:52:25 <sorear> desp: does that mean you hve to use arrays?
17:52:35 <dmwit> mauke: Sneakier:
17:52:42 <dmwit> Put p"" last, and make it
17:52:49 <dmwit> p x=Just(x,x)
17:52:55 <dmwit> two more bytes down =P
17:53:09 <mauke> dmwit: doesn't typecheck
17:53:13 <dmwit> oh bah
17:53:14 <dmwit> right
17:53:17 <mauke> the second element is [X], not String
17:53:19 <desp> sorear: I might've overoptimized a bit... I suppose only m needs to be an array.
17:54:00 <desp> Perhaps also h1 and d1.  Sigh.  It's hard to assign meaningful names for coefficients that are hard to visualize.
17:54:27 <sorear> what's m?
17:54:53 <dmwit> mauke: Why not make p return a list?
17:55:21 <desp> sorear: m!i is the approximation of the first derivative of the spline at q!i
17:55:31 <dmwit> There's a whole host of things you can do if you know it's going to be at most a one-element list.
17:55:49 <dons> http://programming.reddit.com/info/62ki2/details "xmonad 0.5 released"
17:55:57 <dmwit> mauke: obviously, fmap->map, but also you get to use "z" instead of Just, and the pattern match in the case gets shorter
17:56:24 <desp> sorear: m is calculated by doing a simple variant of Gaussian elimination on a tridiagonal matrix.
17:57:04 <desp> sorear: If you're really curious, the definitions are in http://desp.night.pl/hm.pdf -- if you can gloss over the non-English text. ;)
17:58:02 <ddarius> Explanation is for the weak.
18:01:33 <dmwit> mauke: Is the order of arguments for 'i' critical?
18:01:41 <dmwit> (Can you switch the array to be the last argument?)
18:02:31 <dmwit> If so, you might be able to move the "newArray" into the "Just" case and eliminate both the argument and the type-annotation.
18:03:04 <mauke> dmwit: z is IO return
18:03:11 <dmwit> ah
18:03:23 <dmwit> But still, [([],[])] is shorter than Just([],[]).
18:03:49 <dmwit> dinner-time
18:04:06 <mauke> indeed
18:05:22 <mokus> as many times as Just is used, 'j=Just' would save several bytes
18:05:56 <mauke> it's used twice
18:06:17 <mauke> but I just changed it to []
18:09:03 <scook0> mauke: repaste?
18:09:37 <hpaste>  mauke annotated "brainf_k" with "(no title)" at http://hpaste.org/4357#a1
18:10:36 <scook0> I see i r a p at least four times -- can that be lifted to a where?
18:10:57 <scook0> and as far as I can see, i's second argument is always the same a
18:11:05 <mauke> yes, a is constant
18:11:11 <scook0> so you might be able to rearrange the arguments
18:11:21 <scook0> and partially apply i a in a where
18:12:18 <mauke> yep, already working on it
18:12:23 <ddarius> If you get it down to two arguments, replacing it with an operator might be an idea.
18:13:51 <sorear> desp: okay, I think I see how to do this...
18:20:42 <mokus> mauke: could you drop the filter and add a _ case as a noop?
18:20:55 <mauke> mokus: huh?
18:21:10 <mokus> don't filter your input to valid ops - just ignore them when they happen
18:21:17 <mokus> that might make a net gain, i dunno
18:21:17 <mauke> ah
18:21:23 * ddarius has an idea.
18:22:10 <sorear> :t mapAccumL
18:22:11 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
18:22:31 <megalither> don't mean to change the subject, but anyone ever try to see how small they could get a haskell compiled win32 binary to be?
18:23:22 <megalither> by that i mean a combination of executable compression (PECompact, etc) and cunning use of compiler/linker flags?
18:23:25 <mauke> mokus: yep, works
18:24:00 <dons> i'd imagine something under 180k megalither . that's a minimum helloworld on linux
18:24:03 <mauke> wait, it doesn't
18:24:28 <megalither> hm...that's better than I expected to be honest
18:24:55 <mauke> fixed
18:25:16 <dons> well, 180k is the size of the runtime. depends then on how many things you link in. if you're happy to leave the src interpreted, then the 'binary' is going to be pretty small too :)
18:25:42 <SamB_XP> dons: what?
18:25:51 <SamB_XP> but then you need GHCi
18:26:03 <megalither> well, i'm referring to statically linking everything you need so that you can distribute it more easily to the masses
18:26:30 <megalither> "everything" does not include base windows libraries...just so that we're clear :)
18:26:37 <SamB_XP> duh!
18:26:50 <SamB_XP> you aren't allowed to statically link those for fairly obvious reasons...
18:26:52 <wli> In principle, one can circumvent the C runtime bloat, but in practice, C's not really even trying to compete on bloat.
18:27:05 <megalither> SamB_XP: indeed ;)
18:28:50 <megalither> i was simply wondering if anyone had done tests of this before, if not, i will have to do some of my own
18:29:24 <dons> that's roughly what i'd expect. ymmv on windows though
18:30:11 <megalither> yeah
18:30:19 <megalither> cool...well, thanks dons
18:30:31 <dons> no worries
18:39:26 <dmwit> mauke: What's your latest code?
18:39:36 <mauke> sec, I'm trying something
18:39:37 <dmwit> Is the hpaste it?
18:44:13 <hpaste>  mauke annotated "brainf_k" with "(no title)" at http://hpaste.org/4357#a2
18:46:20 <ddarius> You actually parse it?
18:46:38 <mauke> only the [ ] parts
18:46:53 <ddarius> That's pretty much the only syntax there is to parse
18:50:36 <dmwit> This code is awfully hard on GVim's Haskell highlighter. =P
18:50:54 <mauke> seems to work fine here
18:51:17 <dmwit> if c`mod`256==0then r?p {- then is not highlighted, for example -}
18:51:27 <mauke> oh, right
18:52:28 <dmwit> Yikes, we've only made it about halfway to your target.
18:52:58 <sorear>       Expected type: (a, a, a) -> (a, a) -> ((a, a, a), y)
18:52:58 <sorear>       Inferred type: (a, a, a) -> (a, a) -> ((a, a -> a), (a, a, a))
18:53:05 <sorear> yay for higher order programming!
18:54:07 <hpaste>  sorear pasted "how's this, desp?" at http://hpaste.org/4358
18:56:03 <hpaste>  mmorrow annotated "Adjoint funct(ors/ions) and some instances." with "Example: Restriction of a map of Vectors via filtering through Data.Map via an adjunction" at http://hpaste.org/4345#a3
18:56:29 <desp> sorear: wow.
18:57:45 <desp> sorear: why is the \x explicitly a lambda?
18:57:54 <desp> sorear: just a matter of style, or something deeper?
18:58:24 * wli doesn't understand how adjoints came in.
18:58:27 <desp> Is this still using the same algorithm? :^^
18:58:37 <ricky_clarkson> Does Haskell's ad hoc polymorphism count as late binding in some way?
18:58:48 <ddarius> No.
18:58:59 <dmwit> \x -> (x, f x) can be clearer than id &&& f in some cases.
18:59:00 <sorear> desp: it does the same thing; I couldn't understand your code so I had to reinvent it
18:59:07 <desp> Ah ha.
18:59:16 * wli doesn't understand what's going on at all.
18:59:22 <desp> It's a pity, then. I have to stick to this algorithm. :(
19:01:20 <sorear> desp: http://haskell.org/haskellwiki/GHC:FAQ#When_can_I_rely_on_full_laziness.3F
19:01:21 <lambdabot> http://tinyurl.com/27tp4v
19:01:54 <sorear> desp: the explicit lambda makes the code asymptotically more efficient, so if you say (x = spline f pts) then the array will be computed *once*
19:02:10 <desp> Right, I was wondering about that.
19:02:12 <sorear> desp: withoute, the entire spline will be recomputed for each point
19:02:17 <desp> Thanks.
19:02:45 <wli> That computes a spline?
19:03:04 <sorear> wli: yes.
19:03:17 <sorear> desp: it might be the same algorithm.
19:03:21 <wli> Is the function spline defined elsewhere?
19:03:56 <dmwit> Uh, it's defined right there.
19:04:04 <ddarius> wli: It helps if you look at the right code.
19:04:37 <nolrai> http://hpaste.org/4358 not http://hpaste.org/4345#a3
19:05:07 <sorear> desp: my code works from the front of the list to the end; for each segment it calculates what the average slope needs to be, then determines the d^2 y / dx^2 required to get there
19:05:25 <sorear> desp: how close is that to yours?
19:05:58 <desp> That's a good question. ;)
19:06:49 <desp> There are many ways to approximate the derivative.
19:06:59 <desp> It looks like you're doing it a bit differently.
19:15:03 <nolrai> @ty fmap
19:15:04 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:34:09 <wli> Data.Map seems to be much nicer for polynomial representations at the moment.
19:45:19 <dibblego> ?src (!!)
19:45:19 <lambdabot> xs     !! n | n < 0 = undefined
19:45:19 <lambdabot> []     !! _         = undefined
19:45:19 <lambdabot> (x:_)  !! 0         = x
19:45:19 <lambdabot> (_:xs) !! n         = xs !! (n-1)
19:45:34 <dylan> any wise career programmers about?
19:50:55 <mrd> dylan: i can be, if you do the opposite of what I suggest
19:56:15 <glguy> dylan, I can help you as a wise IRC user ;) asking to ask is a sure way not to get an answer
19:58:19 <dmwit> truer words, pixels, etc
19:59:33 <dmwit> Hiya, masta!
20:00:26 <mikael> what's the buzz?
20:01:07 <mwc> http://programming.reddit.com/info/62kbq/comments/
20:01:14 <mwc> wow, somebody doesn't understand monads
20:01:46 <mikael> you're just a tool for the monad illuminati, man
20:01:48 <mwc> file this clown under "Thinks every haskell programmer spends all day doing category theory''
20:02:37 <dmwit> I love how every first-level response can actually be summarized as, "Well, duh."
20:03:01 <dons> its fun when the anti-math programmers pop up
20:03:17 <dons> "look man, i'm just a programmer. i don't need no stinkin' math"
20:03:27 <ricky_clarkson> Heh.  I don't think I've seen a mathematical version of what monads are yet.
20:03:50 <dmwit> ricky_clarkson: Don't say that, somebody might see it and start spewing. ;-)
20:04:12 <loupgaroublond> i was just getting geared up....
20:04:42 <ricky_clarkson> I wouldn't mind, if they explained it from first principles instead of starting assuming you know category theory first, etc.
20:04:54 * HeartOfDarkness was gonna throw MacLane at him
20:05:25 <ddarius> The Brian Beckman video is horribly horribly bad though.
20:06:02 <ddarius> ricky_clarkson: It's not hard to explain the category theory you need to know from first principles.
20:06:11 * wli ponders Enum and Real instances for polynomials being required to get quotRem going.
20:06:12 <ddarius> ricky_clarkson: The hard part is seeing
20:06:17 <ricky_clarkson> Is it done somewhere?
20:06:21 <ddarius> -why- any of it is useful/interesting?
20:06:30 <ddarius> ricky_clarkson: Any introduction to category theory.
20:07:19 <Pseudonym> wli: I usually define my own Ring and EuclideanRing classes.
20:07:39 <wli> The Prelude is that useless?
20:08:12 <Pseudonym> From the point of view of numeric algebra, yes.
20:08:36 <wli> It's polynomial arithmetic, not numeric algebra.
20:08:48 <HeartOfDarkness> .o0(perhaps a paid tutor ...)
20:08:56 <clanehin> dons: thanks for your attention to that optimizer bug . . . it seems odd to me that 0-arity CAFs would ever be inlined.  Were not for that, I would never have noticed it.
20:10:22 <clanehin> although the example that I posted didn't use one as such
20:10:42 <ddarius> ricky_clarkson: To define what a monad is in category theory you need to know what a natural transformation and a functor is, to define those all you need is to know what a category is.  Natural transformations and functors are some of the absolute basics of category theory.
20:11:07 <Pastorn> @src diagonal
20:11:07 <lambdabot> Source not found. The more you drive -- the dumber you get.
20:11:18 <Pastorn> sorry...
20:11:28 <mikael> so what kinds of fun spare-time hacks or learning endeavors are you guys working on?
20:11:29 <ddarius> "sorry..."?
20:11:45 <ddarius> mikael: I'm reworking through some analytical number theory I did earlier.
20:12:22 <mikael> did you take a class?
20:12:25 <ddarius> No.
20:12:26 <wli> I'm implementing polynomial division for the umpteenth time.
20:12:36 <Pastorn> ddarius: i had it in the source file i was browsing, just did't see it
20:12:39 <wli> I will probably fail.
20:16:35 <mikael> ddarius: have any interesting programs in mind?  or, like, "what can you use it for?"
20:16:45 <dmwit> This guy says, "We're not scared" and "you already know this" way too much.
20:17:05 <ddarius> dmwit: I warned you.
20:18:06 <SamB_XP> dmwit: you're scared, aren't you!
20:18:06 <ddarius> mikael: I'm aiming at writing some article on understanding the Riemann hypothesis.  I.e. how do you do the math to actually get to the point where you would actually ask such a question.
20:18:14 <dmwit> Yes!
20:18:25 <dmwit> I'm afraid he's boring!
20:18:25 <ddarius> You should be.
20:18:32 <SamB_XP> oh.
20:18:33 <ddarius> dmwit: He's worse than boring.
20:18:44 <xpika> what haskell library can I use to download from an ftp server?
20:18:50 <SamB_XP> maybe you should have got one of those teachers who are going senile and tell stories for half the time?
20:18:54 <dmwit> He's also very condescending.
20:19:05 <dmwit> SamB_XP: Learning hard things can be fun.
20:19:30 <dmwit> xpika: I'm not sure, does System.Network do it?
20:19:40 <SamB_XP> not that such teachers aren't able to teach well or anything
20:19:43 <ddarius> xpika: Check hackage.
20:19:53 <SamB_XP> but sometimes the stories are interesting
20:20:28 <ddarius> xpika: Though worse-case scenario you can always implement it yourself with the networking libraries.
20:20:33 <ddarius> SamB_XP: Indeed.
20:20:35 <newsham> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/ftphs-1.0.3
20:20:36 <lambdabot> http://tinyurl.com/yu7rln
20:20:53 <ddarius> @hackage ftphs
20:20:53 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/ftphs
20:21:03 <dmwit> I have a teacher that seems to think "slow" is the correct speed for teaching.
20:21:14 <dmwit> The hilarious bit is that in normal conversations, he talks at a completely normal pace.
20:21:47 <ricky_clarkson> I think that's fine as long as you smirk mysteriously every so often.
20:22:15 * ricky_clarkson is thinking of G.J.Sussman.
20:22:43 * ddarius doesn't remember Sussman talking particularly slow most of the time.
20:23:35 <Pseudonym> I had a lecturer who inserted pauses in every sentence.  It was like the Rocky Horror Picture Show.
20:23:54 <Pseudonym> Had he ever repeated lectures, we probably would have come up with audience participation.
20:23:54 * ddarius hasn't seen that movie in a long, long time.
20:25:32 <mikael> I dropped in on an algebra class with a guy who I guess felt uncomfortable not talking, so if he finished a sentence before he finished writing it on the blackboard, he'd repeat suffixes, like "assuming x is greater than zero... greater than zero... than zero... than zero!"
20:26:22 <ddarius> I usually just continue talking.
20:26:24 <dmwit> heheehee
20:26:26 <dfranke_> you know what be a really awesome classroom tool?
20:26:37 <ddarius> A taser?
20:26:46 <dfranke_> a blackboard that's a big touchscreen LCD with handwriting recognition, wired to Mathematica.
20:26:55 <ddarius> Oh...
20:26:59 <ddarius> I'd prefer a taser.
20:27:01 <loupgaroublond> doesn't help us linguists
20:27:33 <dmwit> Wow, you linguists use tasers?
20:27:52 <tttz> Or they're immune to them.
20:28:06 <dino-> In this: class (Monoid w, Monad m) => MonadWriter w m | m -> w where ...
20:28:12 <loupgaroublond> we're immune :), you learn to settle for cursing in five languages
20:28:30 <dino-> Is the (Monoid w, Monad m) part what we call a multi-parameter type class?
20:28:36 <ddarius> No
20:28:38 <dmwit> no
20:28:52 <dmwit> A multi-parameter type class is something like
20:28:54 <dfranke_> The MonadWriter w m part is.
20:28:56 <dino-> The part where it's about w and m both?
20:29:00 <dmwit> class Foo a b where ...
20:29:03 <dino-> on the right, ok
20:29:13 <dmwit> So, yes, the MonadWriter w m part is multi-parameter.
20:29:24 <clanehin> the w and m is the multi part, and the m -> w is the functional dependency part
20:29:27 <dfranke_> and the | m -> w part is called a functional dependency.
20:29:27 <dino-> And the | m -> w is the fundep?
20:29:29 <dino-> ok
20:29:37 <dfranke_> echo! echo!
20:29:47 <dmwit> Wow... that was a stereo answer to a question that *hadn't even been asked yet*.
20:30:00 <ddarius> dmwit: Not the first time.
20:30:04 <dmwit> Welcome to #haskell, where we answered your question yesterday.
20:30:14 <pjd> ...in stereo!
20:30:15 <ddarius> That is very very likely.
20:30:29 <dino-> Where the AnswerList monad has answers to all questions simultaneously.
20:31:01 <dfranke_> yeah, we have every answer, but we're too lazy to compute them all.
20:31:03 <ricky_clarkson> Would non-deterministic computing as mentioned in SICP be an alternative way of thinking about/implementing quickcheck?
20:31:10 <clanehin> I just remember asking what m -> w was, because you can't google it
20:31:22 <ivanm> of course, the problem with answers being provided yesterday is that you're quite often not online when the answer you don't know you want yet is provided... :p
20:31:29 <clanehin> It's just a little arrow for no apparent reason
20:31:34 <dfranke_> ricky_clarkson: huh?
20:31:39 <dfranke_> ricky_clarkson: what's one got to do with the other?
20:31:47 <dmwit> ivanm: That's the beauty of #haskell logs. ;-)
20:31:49 <dino-> Thank you.
20:32:05 <pjd> ricky_clarkson: probably;  amb is essentially the list monad
20:32:30 <dfranke_> more Like ContT []
20:32:54 <dfranke_> but I still don't see what that has to do with quickcheck.
20:33:07 <ricky_clarkson> dfranke_: You could do (\a b -> a+b-b==a) :: Double -> Double -> Bool and have the answer be a stream of values for which that fails.
20:33:23 <ivanm> dmwit: true
20:33:40 <ivanm> while I remember...
20:33:44 <ricky_clarkson> list, rather.
20:33:56 <pjd> ricky_clarkson: termination? :)
20:33:59 <ivanm> @remember dmwit Welcome to #haskell, where we answered your question yesterday.
20:33:59 <lambdabot> Done.
20:34:04 <ricky_clarkson> pjd: [1..]?
20:34:47 <pjd> ricky_clarkson: i mean, you're going to need some kind of input limiting
20:34:56 <ricky_clarkson> Sure, ok.
20:35:09 <ricky_clarkson> And eventually you're back round at QuickCheck.
20:35:58 <ddarius> @google Quickcheck logic language
20:35:59 <lambdabot> http://www.cs.chalmers.se/~koen/pubs/tt04-quickcheck.ppt
20:41:56 <ricky_clarkson> ddarius: In that ppt, there's a slide with lots of code like (Uno Minus (Duo Div (Val (Num (-17... Is that some form of AST for Haskell?
20:42:09 <ricky_clarkson> What's the general name for it?
20:42:41 <ddarius> That just an algebraic data type representing an AST for another language.
20:43:29 <ricky_clarkson> I see.  So QuickCheck was made to generate random valid code in that language, to test out a parser?
20:46:27 <ddarius> ricky_clarkson: That wasn't the hit I was hoping for.
20:46:37 <ddarius> I think what I want was discussed in a Haskell Workshop video.
20:46:44 <ricky_clarkson> Still, that was fun.
20:47:03 <ricky_clarkson> A good presentation, though saying there is a port in Java seems a little optimistic, from what I've seen.
20:47:23 <ricky_clarkson> There are a number of half-hearted efforts.
20:48:29 <mlh> what symbols are you allowed to use to define new operators?
20:48:35 <ddarius> @where report
20:48:35 <lambdabot> http://www.haskell.org/onlinereport/
20:50:19 <ddarius> ricky_clarkson: Anyway, the upshot of what I was looking for is that instead of picking values randomly one could pass in unbound logic variables.
20:50:42 <ricky_clarkson> Ahh.
20:51:19 <yrlnry_> I know that in Haskell every type is inhabited, but is it also the case that every type is inhabited by a non-bottom value?
20:51:26 <ricky_clarkson> If I play with Prolog for a few days will I likely grasp how what you said works?
20:51:32 <dmwit> yrlnry_: No, there's the Void type.
20:51:47 <dmwit> yrlnry_: data Void -- that's the whole declaration
20:51:48 <yrlnry_> Any other example?
20:51:59 <ricky_clarkson> data Void2 -- I just made it up
20:52:09 <ddarius> Probably this stuff: http://www-users.cs.york.ac.uk/~mfn/
20:52:10 <lambdabot> Title: Matthew Naylor's Web Page
20:52:12 <dmwit> yrlnry_: Sure, phantom types are generally useful.
20:52:22 <ddarius> :t undefined
20:52:23 <lambdabot> forall a. a
20:52:39 <ddarius> ricky_clarkson: That link was for you.
20:52:49 <ricky_clarkson> I clicked, thanks.
20:53:49 <mlh> ddarius: have a link for me?  :-)
20:53:54 <yrlnry_> I guess what I'm really wondering is, suppose I manufacture some arbitrary type expression, like say ((a->(b->a))->(a->b).   Will it necessarily be inhabited by some non-bottom value?
20:54:20 <ricky_clarkson> ddarius: Lazy SmallCheck seems very interesting.
20:54:20 <ddarius> mlh: Yes, the report which I linked above.
20:54:25 <yrlnry_> Or consider (a OR b) -> (a, b)  where  (a OR b) is the union of type a and type b.
20:54:32 <yrlnry_> Is it inhabited by a non-bottom value?
20:54:36 <mlh> oh, anything more specific?
20:54:43 <ddarius> yrlnry_: No.
20:54:56 <yrlnry_> How can one know?
20:55:52 <scook0> looks like !#$%&*+./<=>?@\^|-~
20:56:24 <scook0> and :
20:56:28 <ddarius> mlh: Section 2.2 and 2.4
20:56:33 <scook0> though some combinations are reserved
20:56:41 <scook0> and anything beginning with : is a constructor
20:56:59 <dmwit> yrlnry_: Why would it matter?
20:57:01 <scook0> > let (!#$%&*+./<=>?@\^|-~) = 1 in (!#$%&*+./<=>?@\^|-~)
20:57:03 <lambdabot>  1
20:57:06 <scook0> \o/
20:57:21 <yrlnry_> dmwit: matter to whom?
20:57:32 <ddarius> yrlnry_: That problem in general is a theorem proving problem.
20:57:44 <dmwit> yrlnry_: to you
20:58:04 <mlh> yeah this is what I've vaguely concluded.  .. is out, things starting with : are no go,
20:58:42 <yrlnry_> ddarius: can you elaborate?   The reason I ask is that I discovered a couple of weeks ago that (a->a)->a is nontrivially inhabited in Haskell, contrary to Curry-Howard, and now I'm trying to understand more precisely the extent to which C-H does or does not apply here.
20:59:16 <yrlnry_> ddarius: I thought that since the haskell type system corresponded to an inconsistent logic, you couldn't get anything useful at all from the theorem-proving side of things.
20:59:32 <yrlnry_> dmwit: Why would it matter to you why it matters to me?
20:59:43 <mlh> ddarius: thanks for the section numbers
20:59:52 <ddarius> (a->a)->a is non-trivially inhabited by fiat essentially.  It's basically provided as an axiom.
20:59:57 <dmwit> yrlnry_: It is often easier to change the question than to answer it. ;-)
21:00:22 <ddarius> yrlnry_: You can get useful stuff, you just have to prove that your statements are normalizing/productive.
21:00:55 <yrlnry_> ddarius: what does that mean?
21:01:38 <ddarius> If you prove that your program terminates for all inputs and/or is productive then you have a real proof of the theorem represented by the types.
21:02:03 <yrlnry_> Oh, because C-H applies for total functions?
21:02:19 <ddarius> Yes.
21:02:34 <ddarius> CH applies to Haskell too.  The logic is just inconsistent.
21:02:43 <yrlnry_> So how do you know there isn't a partial function with principal type  (a OR b) -> (a, b) ?
21:02:55 <ddarius> Naive set theory has issues to, but that doesn't mean every result in it is wrong.
21:04:27 <hpaste>  wli pasted "Map -based polynomials" at http://hpaste.org/4359
21:04:52 <ddarius> yrlnry_: a OR b doesn't mean anything without you providing more information that "the union of a and b".
21:05:02 <dmwit> Either a b -- ?
21:05:27 <dmwit> Not quite, I guess.
21:05:29 <yrlnry_> ddarius: I mean the usual union type that is meant in discussions of C-H that is analogous to the logical expression (a OR b).  Does that help>
21:05:48 <ddarius> That's the disjoint union and does correspond to Either a b.
21:06:03 <yrlnry_> It comes equipped with two injection operators, sometimes called inL and inR, and a "case ..." structure for uninjecting it again.
21:06:10 <ddarius> Now write a function forall a b. Either a b -> (a,b)
21:06:24 <yrlnry_> I can't, but it might just be a failure of cleverness.
21:06:48 <ddarius> @djinn Either a b -> (a,b)
21:06:48 <lambdabot> -- f cannot be realized.
21:06:55 <yrlnry_> If you had asked me a couple of weeks ago to write a function of type forall a. (a->a)->a I wouldn't have been able to do that either.
21:07:01 <ddarius> :t fix
21:07:02 <lambdabot> forall a. (a -> a) -> a
21:07:10 <dmwit> ?djin (a -> a) -> a
21:07:11 <lambdabot> Maybe you meant: djinn djinn-add djinn-clr djinn-del djinn-env djinn-names djinn-ver
21:07:15 <dmwit> ?djinn (a -> a) -> a
21:07:16 <lambdabot> -- f cannot be realized.
21:07:23 <dmwit> So djinn is not proof.
21:07:37 <ddarius> yrlnry_: It should be no problem to prove that something -can't- be proven (under suitable assumptions)
21:07:47 <yrlnry_> Why?
21:07:54 <ddarius> dmwit: djinn isn't a theorem prover for Haskell's type system.
21:08:07 <ddarius> yrlnry_: Who is that directed at?
21:08:22 <yrlnry_> You.  Why should it be no problem to prove that something can't be proven?
21:08:27 <dmwit> ddarius: Right, that's my point.  So the ?djinn Either a b -> (a, b) result doesn't mean anything, really.
21:08:38 <ddarius> yrlnry_: Sorry, not in general, but in that case it should be easy.
21:08:57 <yrlnry_> Maybe I should stop pestering you and go try to find the references myself.
21:09:00 <yrlnry_> Thanks for your help.
21:09:20 <xinming_> anyone here can tell me, If it's possible to compose 2 partial application into one function conveniently?
21:09:46 <ddarius> There is at least one non-bottom proof of Either a b -> (a,b), namely const (undefined, undefined)
21:10:11 <yrlnry_> @src const
21:10:11 <lambdabot> const x _ = x
21:10:20 <yrlnry_> Oh, const is k.
21:10:26 <ddarius> However, it's usually necessary to -completely- normalize such things, so that doesn't work for something meaningful.
21:11:03 <yrlnry_> I'm gonna go see if there's anything relevant in Srenson and Urzyczyn.
21:11:17 <ddarius> There should be.
21:16:01 <scook0> xinming_: what types do you have?
21:25:51 <xinming_> scook0: sorry, can't give a concrete example about what I am doing. Just got the inspiration from the dot (.)  function composition. But the (.) is linear
21:28:16 <xinming_> eg,  x . f means, the arg passed to f, and the result of f, passed to x. eg. for f, if the type is,  (Int -> Int -> Int), then, (x . f) needs 2 params
21:28:48 <desp> dons: Nice setup you have there at Galois. ;)
21:29:29 <dons> that's  glguy's actually
21:29:32 <dons> mine is similar though
21:29:38 <dibblego> xinming_, try using @pl
21:29:45 <dibblego> @pl \x -> f(g(x))
21:29:46 <lambdabot> f . g
21:30:38 <desp> Ah.
21:31:07 <xinming_> hmm, I think I still need to think about what my question is. sorry, ignore this please.
22:17:45 <nolrai> @pl f a b c d = a (b c) (b d)
22:17:45 <lambdabot> f = join . ((flip . ((.) .)) .) . (.)
22:17:55 <nolrai> eww
22:26:45 <olsner> nolrai: f = on
22:27:14 <nolrai> realy?
22:27:22 <nolrai> @ty on
22:27:23 <lambdabot> Not in scope: `on'
22:27:50 <nolrai> @hoogle on
22:27:51 <lambdabot> Data.Function.on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
22:27:51 <lambdabot> Text.ParserCombinators.Parsec.Char.oneOf :: [Char] -> CharParser st Char
22:27:51 <lambdabot> Data.Function :: module
22:28:03 <olsner>  @let-variables aren't in a scope visible to @type, unfortunately
22:28:19 <olsner> @ty \f a b c d -> a (b c) (b d)
22:28:19 <lambdabot> forall t t1 t2 t3. t -> (t2 -> t2 -> t3) -> (t1 -> t2) -> t1 -> t1 -> t3
22:29:10 <nolrai> cool i was just thinking about what xinming_ could have ment.
22:32:27 <nolrai> I still dont understand fix
22:33:07 <pjd> > fix (1:)
22:33:09 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
22:33:18 <nolrai> > fix (*2)
22:33:18 <lambdabot>  Exception: <<loop>>
22:33:44 <pjd> i.e. (1:(1:(1:...)))
22:34:23 <pjd> versus (2*(2*(2*...)))
22:35:50 <nolrai> ah but how does one get funtions that fix f isnt undefined for? lazyness?
22:36:13 <ivanm> @type fix
22:36:14 <lambdabot> forall a. (a -> a) -> a
22:36:47 <ivanm> fix takes a function that returns the same type of value that it is given, so it just repeatedly keeps applying the function to itself
22:36:51 <ivanm> @src fix
22:36:51 <lambdabot> fix f = let x = f x in x
22:37:14 <nolrai> oh
22:37:42 <ivanm> so in the case of fix (1:), you have a partial result because the recursion occurs at the end, if you will
22:37:58 <ivanm> so there is a partial evaluation possible before lambdabot cuts it off
22:38:11 <pjd> nolrai: Haskell evaluates "outside in"
22:38:40 <nolrai> ah i think i was thinking inside out.
22:39:03 <nolrai> ^^ that sounds like it would hurt.
22:40:27 <mattam> @src join
22:40:27 <lambdabot> join x =  x >>= id
22:40:29 <pjd> so evaluating fix (1:) is like peeling an infinite onion, if you will
22:40:42 <pjd> one layer at a time
22:41:12 <pjd> whereas fix (*2) never produces any layers to unwrap
22:41:43 <quicksilver> peeling an infinite onion always makes me cry.
22:42:38 <Enzo> >sum $ map (\x->1/x^2) [1..]
22:43:12 <Enzo> >sum $ map (\x->1/x^2) [1..100]
22:43:35 <olsner> quicksilver: and an infinite onion has infinite cry in it!
22:44:24 <Enzo> can I not sum an infinite series?
22:45:21 <pjd> Enzo: you might want a space after your >
22:45:30 <nolrai> > fix (\x: -> if null x then (1:) else ((head x + 1) :) )
22:45:30 <lambdabot>  Parse error at ":" (column 8)
22:45:45 <nolrai> > fix (\x: -> if null x then (1:) else ((head x + 1) : ) )
22:45:45 <lambdabot>  Parse error at ":" (column 8)
22:45:57 <Enzo> pjd oh yes
22:46:33 <pjd> nolrai: the \ pattern match
22:46:47 <nolrai> > fix (\x -> if null x then (1:) else ((head x + 1) : ) )
22:46:50 <lambdabot>  Couldn't match expected type `[a]'
22:48:40 <nolrai> > let fx -> if null x then ([1]) else ((head x + 1) :x ) )
22:48:40 <lambdabot> Unbalanced parentheses
22:48:55 <nolrai> > let fix (\x -> if null x then ([1]) else ((head x + 1) :x ) )
22:48:56 <lambdabot>  Parse error at end of input
22:49:07 <nolrai> > let fix (\x -> if null x then ([1]) else ((head x + 1) : x ) )
22:49:07 <lambdabot>  Parse error at end of input
22:49:39 <nolrai> > fix (\x -> if null x then ([1]) else ((head x + 1) : x ) )
22:49:39 <lambdabot>  Exception: <<loop>>
22:49:56 <nolrai> oh
22:50:29 <nolrai> how is fix used?
22:50:59 <ricky_clarkson> > fix cos $ 2
22:50:59 <lambdabot>   add an instance declaration for (Floating (a -> b))
22:51:27 <ricky_clarkson> :t fix
22:51:28 <lambdabot> forall a. (a -> a) -> a
22:51:33 <nolrai> > (fix cos) 2
22:51:36 <lambdabot>   add an instance declaration for (Floating (t -> a))
22:51:43 <quicksilver> nolrai: fix is precisely equivalent to recursion.
22:51:48 <ricky_clarkson> > fix cos
22:51:49 <lambdabot>  Exception: <<loop>>
22:51:52 <ricky_clarkson> > fix sin
22:51:53 <lambdabot>  Exception: <<loop>>
22:51:56 <quicksilver> nolrai: therefore in a language with native recursion it's quite unnecessary
22:52:16 <ricky_clarkson> > fix (/2)
22:52:17 <lambdabot>  Exception: <<loop>>
22:52:58 <ricky_clarkson> > fix (True ||)
22:52:59 <lambdabot>  True
22:53:06 <ricky_clarkson> > fix (False ||)
22:53:06 <lambdabot>  Exception: <<loop>>
22:53:57 <quicksilver> the two || examples are quite instructive, actually
22:54:01 <ricky_clarkson> fix (True ||) would be like True || (True || (True ||...)), except that we don't need to evaluate the rhs.
22:54:08 <quicksilver> fix can be see as constructing an infinite expression
22:54:11 <quicksilver> but it's only *useful*
22:54:20 <quicksilver> if we can gain some answer by evaluating only a finite amount
22:54:29 <quicksilver> because we don't have time to evaluate an infinite amount...
22:55:25 <ivanm> quicksilver: speak for yourself! :p
22:56:46 <quicksilver> ok, I don't have time. ivanm is obviously less busy than me :P
22:57:03 <quicksilver> if you have infinite expressions to evaluate, as ivanm, he'll get back to you...
22:57:34 <nolrai> > let f x = if x > 10 then x else x + 1 in fix f
22:57:35 <lambdabot>  Exception: <<loop>>
22:58:13 <ivanm> nolrai: it starts with a non-existent value...
22:59:35 <nolrai> ?! i think i almost under stand, but how do you do any thing other then a infinite list of ones with it?
22:59:35 <lambdabot> Maybe you meant: . ? @ v
23:00:06 <quicksilver> well, it's exactly like recursion
23:00:12 <quicksilver> how do you write a useful recursive function?
23:00:23 <quicksilver> normally not by recursing up-front as the first thing you do
23:00:27 <quicksilver> that's an infinite loop
23:00:29 <ivanm> here's a useless use of fix :p
23:00:30 <ivanm> > let f (a:b:cs) = (a+b):(f cs) in take 20 . f . map length . group $ fix show
23:00:31 <lambdabot>  [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262...
23:00:53 <quicksilver> > let ones = 1 : ones in ones
23:00:53 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
23:01:01 <quicksilver> > fix (\ones -> 1 : ones)
23:01:02 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
23:01:11 <quicksilver> ^^ that's the relationship between fix and recursion
23:01:16 <quicksilver> and example thereof
23:02:10 <olsner> is *any* recursive function expressible as a 'fix' expression?
23:02:21 <nolrai> > so can you use it to compute factorials?
23:02:22 <lambdabot>   parse error on input `}'
23:02:47 <olsner> I've seen a factorial function based on fix, so I guess it's possible :P
23:03:27 <sjanssen> olsner: yes
23:03:39 <sjanssen> except for fix itself
23:03:55 <sorear> fix = fix
23:04:24 <ivanm> fix isn't really recursive though, is it?
23:04:33 <ivanm> they type signature is all wrong...
23:04:41 <sjanssen> @src fix
23:04:41 <lambdabot> fix f = let x = f x in x
23:04:58 <nolrai> > fix fix
23:04:59 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -> a
23:04:59 <lambdabot>     Probabl...
23:05:43 <sclv> ?ty fix
23:05:44 <lambdabot> forall a. (a -> a) -> a
23:06:12 <nolrai> > let f (a : b : cs) = (a : f : cs) in fix f
23:06:15 <lambdabot>      Occurs check: cannot construct the infinite type: t = [t] -> t1
23:06:15 <lambdabot>     Prob...
23:07:15 <nanothief> is there any tutorials/resources on the use of foreach and how and when to use it?
23:07:38 <sclv> the type signature for fix is right if instead of each a you read (a->b) -- i can't figure out a simple way for lambdabot to show that though.
23:08:17 <glguy> does  (  msum . map return  )
23:08:25 <glguy> exist in some form in standard libraries?
23:08:31 <Cale> glguy: no, but it should
23:08:34 <sclv> ty \f x -> (fix f) x
23:08:36 <sclv> ?ty \f x -> (fix f) x
23:08:37 <lambdabot> forall t t1. ((t -> t1) -> t -> t1) -> t -> t1
23:08:38 <Cale> glguy: I usually name it 'option'
23:08:58 <glguy> http://programming.reddit.com/info/62jnu/comments/
23:09:07 <glguy> seems like a good case for ChoiceT
23:09:12 <glguy> rather than Writer
23:09:25 <Cale> nanothief: foreach isn't the name of a function in the standard libraries, but perhaps you're looking for forM or forM_
23:09:53 <quicksilver> sclv: not sure what you mean by that. the type signature for fix is right as it is!
23:09:58 <nanothief> Cale, no i'm looking for the foreach thing you sometimes have to put in type signatures eg foreach a . stuff
23:10:03 <quicksilver> sclv: fix works on all fypes.
23:10:08 <quicksilver> nanothief: ITYM forall :)
23:10:09 <Cale> nanothief: Oh, forall
23:10:25 <nanothief> i just realized that when i typed it the second time :P
23:10:37 <quicksilver> sjanssen: surely fix f = fix (\x -> f x)
23:10:48 <sclv> quicksilver: i just meant that i only saw how fix worked for recursion when i saw how its type signature expanded.
23:10:52 <quicksilver> sjanssen: so you can express fix using fix... although it's not useful as a definition.
23:11:01 <quicksilver> sclv: it doesn't have to expand like that though
23:11:05 <quicksilver> > fix (1:)
23:11:07 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
23:11:08 <Cale> nanothief: You only have to put it into a type signature explicitly if you want to make use of the fact that GHC will cause explicitly scoped type variables to scope over the entire function declaration
23:11:19 <sclv> > fix 1
23:11:19 <lambdabot>   add an instance declaration for (Num (a -> a))
23:11:28 <sclv> > fix (const 1)
23:11:28 <lambdabot>  1
23:11:36 <quicksilver> :t fix
23:11:37 <lambdabot> forall a. (a -> a) -> a
23:11:45 <quicksilver> sclv: fix works on any function a->a
23:11:47 <Cale> (so if you say  forall a. (...) in the type signature of a function f, you can use 'a' in type signatures of things inside f to refer to that type
23:11:49 <Cale> )
23:11:55 <quicksilver> sclv: e.g. (1:) :: [Int] -> [Int]
23:12:18 <nanothief> how do you do multiple foralls, eg forall a,b. (...)?
23:12:21 <Cale> You also need to use it if you want to use higher rank types
23:12:31 <quicksilver> sjanssen: obviously I don't intend that to bind 'fix' recusrively :) turn one of the fixes into a fix'
23:12:35 <Cale> :t map
23:12:35 <sclv> quicksilver: yes. i know. but understanding how it worked for most recursive cases only made sense to me when i saw the expansion. so i posted the expansion so as to aid others in seeing this as well. klaren?
23:12:36 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
23:12:42 <Cale> just a space will do
23:12:57 <quicksilver> sclv: Well, not clear to me. Maybe it's clear to others.
23:13:05 <Cale> If you leave out the forall, it's added implicitly for you.
23:13:09 <sjanssen> quicksilver: I was just trying to point out that we need either 'let' or fix/lambda as a primitive
23:13:09 <quicksilver> sclv: it is a common myth that "fix only works on function types"
23:13:15 <quicksilver> sjanssen: yeah, agreed.
23:13:45 <quicksilver> sclv: I understood you to be buying into that myth :) maybe it's not what you meant.
23:13:51 <Cale> quicksilver: But it does only work on function types ;)
23:13:54 <Cale> :t fix
23:13:55 <nanothief> Cale, thanks
23:13:55 <lambdabot> forall a. (a -> a) -> a
23:14:04 <quicksilver> Cale: yes, the myth is that you have to instantiate a == b -> c
23:14:20 <quicksilver> Cale: and the "true" type of fix is ((b->c) -> b -> c) -> b -> c
23:14:25 <Cale> Yeah, I'm just being annoying :)
23:14:35 <sclv> apparently we all are.
23:15:09 <quicksilver> I think it comes out of the fact that most other languages only permit recursive functions, not recursive values.
23:15:17 <quicksilver> whereas haskell permits recursive values
23:15:26 <quicksilver> ...which is what makes it useful to define fix on value types.
23:16:15 <Cale> It's much more natural that way anyway.
23:16:49 <Cale> You're finding a fixed point of a function. It should take a 'function' and produce a 'value'.
23:17:29 <quicksilver> agreed.
23:18:25 <nolrai> > let f f' n = if n == 0 then 1 else n = n * (f' ( n - 1)) in fix f 3
23:18:25 <lambdabot>  Parse error at "=" (column 38)
23:18:40 <nolrai> > let f f' n = if n == 0 then 1 else n * (f' ( n - 1)) in fix f 3
23:18:41 <lambdabot>  6
23:18:49 <nolrai> > let f f' n = if n == 0 then 1 else n * (f' ( n - 1)) in fix f 6
23:18:49 <lambdabot>  720
23:19:00 <quicksilver> nolrai: I think you've got it :)
23:19:37 <quicksilver> nolrai: the next question to ask is "why bother?", as in, given that we have recursive definitions why do we want fix?
23:19:45 <quicksilver> Personally I almost never use it.
23:20:02 <quicksilver> but it does give you a way to have a 'recursive inline expression' without a let binding.
23:22:04 <nolrai> > let f f' list = if null list then 0 else head list + f' list in fix f [1,2,3]
23:22:07 <lambdabot>  Exception: stack overflow
23:22:25 <nolrai> > let f f' list = if null list then 0 else head list + f' (tail list) in fix f [1,2,3]
23:22:25 <lambdabot>  6
23:23:58 <nolrai> Ok
23:33:58 <nolrai> > let l = 1 : map (+1) in l
23:33:59 <lambdabot>  Couldn't match expected type `[t]'
23:34:08 <nolrai> > let l = 1 : map (+1) l in l
23:34:09 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
23:34:39 <nolrai> > fix (\x -> 1 : map (+1) x)
23:34:40 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
23:37:16 <nolrai> > let f l = 1 : 1 : map ( + head l) l in fix f
23:37:18 <lambdabot>  [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,...
23:40:05 <nolrai> > let dif (x : x2 : xs) = x - x2 : dif xs; f l = 1 :  dif l in fix f
23:40:17 <lambdabot>  Exception: <<loop>>
23:45:53 <nolrai> > let sums (a:b:c) = a + b : b : sums c in sums (fix (1:))
23:45:54 <lambdabot>  [2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1...
23:46:19 <nolrai> > let sums (a:b:c) = a + b : sums c in sums [1..]
23:46:20 <lambdabot>  [3,7,11,15,19,23,27,31,35,39,43,47,51,55,59,63,67,71,75,79,83,87,91,95,99,10...
23:46:32 <nolrai> > let sums (a:b:c) = a + b : sums c in sums [0..]
23:46:33 <lambdabot>  [1,5,9,13,17,21,25,29,33,37,41,45,49,53,57,61,65,69,73,77,81,85,89,93,97,101...
23:48:34 <nolrai> > let {sums (a:b:c) = a + b : sums c in sums; f x = 0 : sums x } in fix f
23:48:34 <lambdabot>  Parse error at "in" (column 36)
23:48:48 <nolrai> > let {sums (a:b:c) = a + b : sums c in sums; f x = 0 : sums x;} in fix f
23:48:48 <lambdabot>  Parse error at "in" (column 36)
23:48:59 <nolrai> > let sums (a:b:c) = a + b : sums c in sums; f x = 0 : sums x; in fix f
23:48:59 <lambdabot>  Parse error at ";" (column 42)
23:49:21 <nolrai> > let sums (a:b:c) = a + b : sums c in sums; f x = 0 : sums x in fix f
23:49:21 <lambdabot>  Parse error at ";" (column 42)
23:49:32 <nolrai> > let {sums (a:b:c) = a + b : sums c in sums; f x = 0 : sums x} in fix f
23:49:32 <lambdabot>  Parse error at "in" (column 36)
23:51:26 <nolrai> > let sums = fix (\ f (a : b : c) -> a + b : f (a : c)) [1..]
23:51:26 <lambdabot>  Parse error at end of input
23:51:40 <nolrai> > let sums = fix (\ f (a : b : c) -> a + b : f (a : c))
23:51:40 <lambdabot>  Parse error at end of input
23:51:50 <glguy> nolrai: maybe try doing this in a /msg ?
23:51:59 <nolrai> sorry
23:53:23 <glguy> if sums requires the first two elements of a list
23:53:37 <glguy> and only produces one as a result
23:53:53 <glguy> you'll need to at least start with two elements
23:54:11 <glguy> if sums consumes 2 and only reutrns 1
23:54:44 <glguy> then you won't be able to loop the result back into the input
23:54:50 <glguy> since you'll run out of computed elements
23:59:43 <miclorb> anyone know about lambdabot ? (trying to understand what deps I need to build it)
23:59:52 <miclorb> (for a total newbie !)
