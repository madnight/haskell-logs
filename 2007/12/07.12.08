00:00:07 <ivanm> @type Debug.Trace.trace
00:00:08 <lambdabot> forall a. String -> a -> a
00:00:34 <ivanm> > let f n = Debug.Trace.trace "c" (f (succ n)) in f 0
00:00:35 <lambdabot>   Not in scope: `Debug.Trace.trace'
00:00:47 <ivanm> that's right, no IO
00:22:29 <faxathisia> Hello
00:22:58 <goalieca> salut
00:23:15 <faxathisia> Has anyone here read The Science of Programming?
01:04:23 <Eidolos> Shimei: hi!
01:26:39 <xpika> Eidolos: hi
01:28:31 <Eidolos> hi
01:39:43 <quicksilver> dons, dcoutts : what is the key reason that Bytestring uses ForeignPtr instead of ByteArray# ?
01:48:36 <sjanssen> quicksilver: ForeignPtr is much more portable
01:49:08 <quicksilver> sjanssen: is that the reason, though?
01:49:34 <sjanssen> quicksilver: I think you'd have to ask droundy, or perhaps even some earlier maintainer
01:49:39 <sjanssen> ByteString has a long history
01:49:47 <sjanssen> bos wrote the first version
01:50:00 <quicksilver> not all versions used foreignptr, IIRC
01:50:10 <sjanssen> yes, the first used UArray Char
01:51:08 <xpika> who is bos?
01:51:44 <sjanssen> Bryan O'Sullivan, one of the authors of the upcoming Real World Haskell, among other things
01:57:12 <benny> wait, isn't that the guy from mercurial?
01:57:21 <sjanssen> yep, same guy
01:58:00 <benny> (and I didn't meant "wait" in the sense "stop the press!!!") ;-)
01:59:12 <quicksilver> to late, I already stopped them
01:59:20 <quicksilver> going to take a few hours to build up a head of steam again
01:59:24 * quicksilver goes back to stoking coal
02:29:03 <Cheery> hrm..
02:30:49 <Cheery> I'd want to find a channel discussing computer graphics, ie. channel of guys who make/cultivate computer graphics
02:31:35 <faxathisia> ##opengl
02:32:41 <Cheery> hmm. that'd may be a good place to ask my question
02:45:07 <Hirvinen_> window goto
03:18:35 <RyanT5000> is there any way to prevent people from instancing a class?
03:18:53 <ivanm> hide the class?
03:18:56 <Zao> Don't export the constructors?
03:19:06 <RyanT5000> i need to export a function from the class
03:19:18 <RyanT5000> i've come up with some type hackery that, provided no one can instance a particular class, provides some nice guarantees involving Map looks
03:19:21 <RyanT5000> *lookups
03:19:24 <ivanm> then just export that function
03:19:36 <RyanT5000> that'll work?
03:19:38 <ivanm> or move that function out of the class declaration if you can
03:19:41 <ivanm> I think so...
03:19:45 <RyanT5000> ok
03:20:01 <ivanm> so just ClassName(wanted_func)
03:20:03 <faxathisia> lol
03:20:12 <faxathisia> "is there any way to stop ...." "hide it"
03:22:36 <quicksilver> RyanT5000: there is a nasty hack involving using a second class
03:23:08 <quicksilver> RyanT5000: if you don't export the class at all, the problem is that users of your code can't write down the type signatures
03:23:12 <RyanT5000> quicksilver: nasty hacks seem in order ;) this class only has one function, and that functoin is just const . id
03:23:32 <RyanT5000> quicksilver: the function in this class is called recertifyKey
03:23:52 <RyanT5000> basically, i'm creating a container datatype where you can make "certified keys"
03:23:52 <quicksilver> RyanT5000: I think you make class B and instance (A a) => B a
03:23:58 <quicksilver> (B has no methods)
03:24:01 <RyanT5000> which are statically guaranteed to be present in the container
03:24:04 <quicksilver> then you export B instead of A
03:24:15 <quicksilver> and write all your (exportable) type sigs using B rather than A
03:24:29 <quicksilver> hmm that doesn't quite sound right
03:24:33 <quicksilver> maybe it has to be a superclass
03:24:37 <quicksilver> class A a => B a
03:25:02 <RyanT5000> quicksilver: well, i'll figure it out later, but i think you've pointed me in the right direction
03:25:02 <quicksilver> it was discussed sometime in the last couple of months on the -cafe btu I don't remember the context
03:25:07 <RyanT5000> ah
03:25:26 <quicksilver> I dont' remember enough to find the right terms to search for, I fear
03:25:36 <RyanT5000> so, you can say let Just ck = certifyKey k m, and now ck is guaranteed by the type system to be present in m
03:26:02 <RyanT5000> the problem is, then when you say let m' = insert k2 v2 m
03:26:18 <RyanT5000> you can't bring your certified keys from m to m'
03:26:32 <RyanT5000> so i made it so that rather than a single type doing the magic in m, it's a linked list of types
03:26:47 <quicksilver> RyanT5000: http://www.haskell.org/pipermail/haskell-cafe/2007-March/023110.html
03:26:49 <lambdabot> Title: [Haskell-cafe] Non-exported type classes?, http://tinyurl.com/2wdfmy
03:26:51 <quicksilver> (found it)
03:27:33 <RyanT5000> recertifyKey searches the linked list of types for the marker type under which your key was certified, and gives you a key with an updated type signature
03:28:14 <RyanT5000> since that should get optimized away, you get the benefit of not checking keys at runtime without losing any safety
03:29:13 <RyanT5000> but if users could instance RecertifyKey then they could just unify all the universally quantified types i'm using to keep things straight, and the whole house of cards would fall
03:29:34 <RyanT5000> this code really makes me wish i could just chuck actual program code into my type system
03:30:01 <faxathisia> What?>
03:30:08 <RyanT5000> meaning
03:30:12 <RyanT5000> i wish i could extend the type checker
03:30:24 <faxathisia> YOu coulduse a language with dependant types
03:30:24 <RyanT5000> to allow me to have Sets of types
03:30:40 <RyanT5000> yeah, if i wanted to use a language in which i can't get anything done :P
03:30:58 <faxathisia> By that you mean.. it's too hard or in general dependant types are useless?
03:30:59 <RyanT5000> you won't find a bigger fan of dependent types than me
03:31:22 <RyanT5000> i mean there aren't any currently existing dependently typed languages that are even remotely usable
03:31:23 <quicksilver> most people like the idea that type-checking will terminate
03:31:25 <quicksilver> I tend to agree
03:31:48 <RyanT5000> quicksilver: yeah, but i'm happy enough with the idea that that can be ensured by me writing terminating type-checker code
03:31:56 <faxathisia> type checking will terminate if you ... help the computer a bit..
03:32:16 <RyanT5000> i'm comfortable with the prospect that the termination of the typechecker isn't provable a priori
03:32:33 <faxathisia> but typechecking can terminate in a dependantly typed language
03:32:45 <faxathisia> I mean can be proven to always terminate*
03:32:58 <faxathisia> just have to have an oracle
03:33:06 <faxathisia> (e.g. the programmer)
03:33:12 <RyanT5000> well, yes
03:33:13 <RyanT5000> lol
03:33:27 <faxathisia> What extention did you want to add to the typechecker?
03:33:44 <RyanT5000> i want to make a datatype something like Map
03:33:59 <RyanT5000> where you can produce a "certified key"
03:34:14 <RyanT5000> which is a key value that is statically known to be present in a given map
03:34:43 <RyanT5000> and thus you can safely use a lookup function that has no failure case
03:34:48 <RyanT5000> e.g. (!)
03:35:06 <faxathisia> Sounds like you want strongly specified functions :p
03:35:12 <faxathisia> lol
03:35:17 <RyanT5000> hm, that sounds like a buzzword i should learn :)
03:35:30 <quicksilver> I've wanted that kind of thing
03:35:40 <RyanT5000> well i've figured out how to do it
03:35:43 <RyanT5000> in haskell
03:35:43 <quicksilver> although normally I come down to deciding it's enough to have a total map from a finite type
03:35:45 <faxathisia> Do you know how easy it is to write a scheme?
03:35:59 <RyanT5000> except it's a pretty conservative estimate
03:36:04 <RyanT5000> for example, whenever you delete a key
03:36:05 <faxathisia> Maybe if we got good at using dependantly typed languages.. It's going to be easy to write a useful one!
03:36:09 <RyanT5000> all your certified keys get invalidated
03:36:58 <RyanT5000> i can deal with adding a new key in O(n) programmer work and O(1) computer work, which i guess is better than O(n) and O(n)
03:37:09 <RyanT5000> (design-time and run-time, respectively)
03:37:13 <phlpp> morgen
03:37:26 <RyanT5000> and i can deal with repeated usage of a certified key in O(1) and O(1)
03:37:43 <faxathisia> hey why not just shove the code in the Maybe monad
03:37:50 <faxathisia> :t (lookup)
03:37:51 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
03:38:07 <RyanT5000> Maybe monad doesn't help you track down the error at all
03:38:13 <faxathisia> error.. ?
03:38:22 <faxathisia> I thought you knew the key was in the map
03:38:35 <RyanT5000> not necessarily at the very beginning
03:38:47 <RyanT5000> the client of the Map needs to be forced to check at least once
03:38:55 <RyanT5000> it's just that subsequent checks are annoying
03:40:04 <faxathisia> mm if you can prove it yourself, you could use fromJust or whatever..
03:40:23 <faxathisia> not everything needs to be in the type system, I understand the motivation thouh
03:40:32 <RyanT5000> yeah; this is more of an experiment
03:40:36 <RyanT5000> than a "real thing"
03:40:59 <RyanT5000> when in my role as library designer, i like to pretend that the client is the stupidest person on the planet
03:41:09 <RyanT5000> which mostly involves chucking everything into the type system
03:41:10 <faxathisia> I can't see why you'd want to solve this problem as opposed to a more general one though....
03:41:20 <RyanT5000> what's the more general one?
03:42:39 <RyanT5000> i mean, *generally*, the goal is to compute part of the result of a function and then statically remember it
03:43:08 <RyanT5000> i just think container keys are a particularly compelling example
03:43:16 <RyanT5000> especially if you have a multicolumn container
03:43:18 <faxathisia> heh why not just save the value of the key
03:43:27 <RyanT5000> where?
03:43:28 <faxathisia> instead of doing a lookup again, knowing it's going to succeed
03:43:45 <RyanT5000> oh, because suppose you want to do an update
03:43:53 <RyanT5000> also, this is *actually* for more graph-like structures
03:44:01 <faxathisia> maybe you could sync it with a state monad thne?
03:44:19 <RyanT5000> so, for example, in order to add an edge to the graph, you would need to provide two certified node IDs
03:44:34 <faxathisia> oh ok, I see what you're getting at
03:44:35 <RyanT5000> that way, there's no error checking to be done in the insertEdge function
03:45:16 <RyanT5000> (the *actual* datastructure i'm contemplating is one that manages several different kinds of objects, each with a separate ID namespace)
03:45:30 <RyanT5000> (people, tasks, deadlines, etc.)
03:46:11 <RyanT5000> it's really infuriating to have to put error checking in every manipulation function when all you really care about is that the user isn't providing invalid IDs
03:46:53 <RyanT5000> and it's infuriating to the user to have to (effectively) deal with potential lookup errors on the same ID multiple times
03:47:11 <RyanT5000> so if you, e.g., add 5 nodes to a graph and then link them together
03:47:24 <RyanT5000> there's no reason you should *ever* have to do *any* error checking
03:47:39 <RyanT5000> at design-time, or run-time
03:48:22 <RyanT5000> (unless there are other kinds of errors, like if it's an error to insert a duplicate edge, or something like that)
03:48:27 <RyanT5000> (but that's semantically meaningful)
03:48:57 <RyanT5000> so anyway, i'd prefer a type system that can "decide" things like that for me than a type system that is "decidable" ;)
03:49:07 <RyanT5000> s/than/to/
03:49:09 <faxathisia> hmf
03:49:13 <faxathisia> you write code manually
03:49:27 <RyanT5000> hm?
03:49:30 <faxathisia> why not write the type checking algorithm out too
03:49:34 <faxathisia> I don't see a problem with that
03:49:48 <RyanT5000> what do you mean?
03:50:23 <RyanT5000> why should all the clients be writing all the type checking code?
03:50:25 <faxathisia> just saying, I can't find any compelling reason a type system should be decideable -- since it's just another programming language
03:50:30 <RyanT5000> oh
03:50:31 <RyanT5000> yeah
03:50:46 <RyanT5000> yay, another supporter
03:50:47 <RyanT5000> lol
03:50:48 <faxathisia> of course it's a nice property!
03:50:50 <lakupuu> heyssan
03:50:54 <faxathisia> I like subturing programming languages too
03:51:04 <RyanT5000> lol yeah, they can be fun toys
03:51:31 <RyanT5000> well i also have a darwinian argument: every powerful type system tends towards undecidability over time
03:51:45 <RyanT5000> Java's the only counterexample i've really found
03:51:49 <RyanT5000> granted, it's a big one
03:51:50 <quicksilver> faxathisia: because it's pretty annoying property of a compiler not to terminate?
03:51:59 <quicksilver> faxathisia: how do you decide when compilation hasn't terminated?
03:52:05 <quicksilver> after 1 minute? 5 minutes? half an hour?
03:52:11 <RyanT5000> quicksilver: is it any more annoying than a program you ship to your client that doesn't terminate?
03:52:18 <quicksilver> yes, much more annoying.
03:52:22 <RyanT5000> really?
03:52:26 <quicksilver> yes
03:52:29 <RyanT5000> why?
03:52:39 <quicksilver> if I ship a program which does not terminate, that is a bug in the program.
03:52:45 <RyanT5000> right...
03:52:49 <quicksilver> If my compiler does not terminate, I don't know if it's a bug in the compiler or a bug in what I've written.
03:52:51 <faxathisia> quicksilver: Nah..
03:53:18 <faxathisia> if the compiler can't automatically typecheck, it can ask you what to try next
03:53:34 <quicksilver> faxathisia: but that's not what happens
03:53:35 <RyanT5000> quicksilver: attach a debugger to your compiler, see what code it's hitting all the time
03:53:37 <faxathisia> sure it is
03:53:52 <quicksilver> faxathisia: make your type checker turing complete, and you will have programs which do not terminate, type checker
03:54:01 <quicksilver> faxathisia: the compiler doesn't know it can't typecheck
03:54:04 <quicksilver> it fails to terminate
03:54:06 <quicksilver> that's the pont
03:54:07 <faxathisia> Yes.. it does :|
03:54:11 <quicksilver> no, it doesn't
03:54:15 <quicksilver> that's the halting problem.
03:54:22 <faxathisia> I think we are talking about two totally different things
03:54:23 <faxathisia> lol
03:54:25 <RyanT5000> quicksilver: we could also do something in between: prove that the *unextended* typechecker is decidable, but allow undecidable user extensions
03:54:35 <quicksilver> RyanT5000: which is, indeed, what ghc does :)
03:54:46 <RyanT5000> ghc doesn't allow *user* extensions
03:54:47 <quicksilver> faxathisia: well I'm talking about the same thing as RyanT5000, so it's you that is different
03:54:55 <faxathisia> whatever
03:55:03 <quicksilver> faxathisia: RyanT5000 is suggesting a turing complete type language
03:55:04 <RyanT5000> it allows phd-student-who-is-contributing-to-ghc extensions
03:55:15 <faxathisia> quicksilver: I was talking to Ryan...
03:55:16 <quicksilver> faxathisia: I'm pointing out that a consequence of that is that compilation may not terminate
03:55:19 <faxathisia> quicksilver: You are just talking to me
03:55:27 <quicksilver> faxathisia: and I believe that is undesirable
03:55:36 <faxathisia> sure.... that's not what I was talking about though
03:55:39 <Philippa> faxathisia: whether or not the compiler needs more info will /also/ be undecidable
03:55:41 <faxathisia> I'm leaving this discussion
03:55:52 <RyanT5000> faxathisia: i am indeed suggesting an undecidable type system
03:55:54 <Philippa> it's not "yes/no/unknown" that's the issue...
03:56:06 <RyanT5000> faxathisia: sorry :(
03:56:10 <quicksilver> "just saying, I can't find any compelling reason a type system should be decideable -- since it's just another programming language"
03:56:14 <quicksilver> faxathisia: you said this.
03:56:20 <quicksilver> I'm giving my reason
03:56:25 <quicksilver> I understand why RyanT5000 doesn't agree
03:56:33 <quicksilver> but non-terminating compilers is certainly something to think about/worry about
03:56:40 <RyanT5000> yeah, i agree with that
03:56:43 <quicksilver> it's a sacrifice to make
03:56:44 <faxathisia> I don't agree with statements like "A programming language should be haskell"
03:56:53 <quicksilver> you have to be sure it's worth it :)
03:57:09 <quicksilver> faxathisia: if I appeared to be saying that, it's certainly not what I meant
03:57:15 <RyanT5000> quicksilver: right; i don't want everyone to extend the type system willy-nilly
03:57:31 <RyanT5000> which is a very valid social concern
03:57:57 <quicksilver> RyanT5000: one approach, of course, is to allow the programmer to also provide the proof of termination.
03:58:06 <quicksilver> RyanT5000: that is, more or less, what systems like epigram do.
03:58:11 <Philippa> congratulations, you just reinvented Omega
03:58:14 <Philippa> no, epigram doesn't do that
03:58:14 <quicksilver> turns out to be quite a lot of work :)
03:58:25 <RyanT5000> quicksilver: yeah, i'm cool with that solution, but i also want to allow programmers to prove things by assertion
03:58:27 <Philippa> rather, the entire calculus is guaranteed to terminate
03:58:48 <quicksilver> Philippa: yes, so it traps you into a box in which you *have* to provide a proof of termination.
03:58:52 <RyanT5000> there's no reason to require the programmer to prove every property of his program
03:59:00 <quicksilver> Philippa: i.e. valid terms of the calculus necessarily embed such proofs
03:59:12 <RyanT5000> so if he doesn't mind not knowing whether his compiler will terminate (maybe he just loves compiler debugging, for example)
03:59:16 <quicksilver> Philippa: but when you try to do something complex, you really have the sensation that you are providing the proof
03:59:26 <RyanT5000> then he can just say "This code terminates because i say it does" and go on his way
03:59:35 <quicksilver> Philippa: e.g. you are forced to define an auxiliary inductive type which is the right shape for the termination proof of your code
03:59:56 <RyanT5000> and, because this is a purely compile-time thing, it doesn't affect the quality of the produced executable
04:00:03 <quicksilver> even just defining vector append in epigram I have the strong sensation that I'm explicitly providing proofs to the system.
04:00:08 <RyanT5000> i.e.: the produced executable can still have no unproven properties
04:00:10 <faxathisia> RyanT5000: Better than "This code terminates because i say it does" would be "This code terminates because, list some lemma or an induction principle" or whatever..
04:00:54 <RyanT5000> faxathisia: i don't think that's *always* better; i think the programmer should be allowed to choose whether to *actually* prove it or not
04:00:57 <quicksilver> RyanT5000: but the down side is that certain classes of bugs lead to no produced executable at all :)
04:00:58 <EvilTerran> "because <insert machine-readable proof checked at compile-time>"
04:01:10 <faxathisia> Well I think it's ridiculous to have a type system you can just lie to..
04:01:12 <RyanT5000> quicksilver: yeah, but so do syntax errors
04:01:16 <faxathisia> there seems to be no point in that ta all
04:01:23 <quicksilver> RyanT5000: ah yes, but at least they terminate with an error message
04:01:28 <quicksilver> RyanT5000: rather than running for ever :)
04:02:22 <quicksilver> faxathisia: the reason to be allowed to lie to the type system is that sometimes telling the truth is too hard.
04:02:24 <RyanT5000> quicksilver: true, but just because it's slightly trickier to debug than a syntax error doesn't mean we shouldn't allow programmers to exercise their own discretion at whether to risk creating such errors
04:02:41 <RyanT5000> we can certainly spit out a warning whenever the programmer uses a "proof by assertion"
04:02:45 <faxathisia> oh oh
04:02:53 <quicksilver> that is, if your type system is powerful enough to embed all proofs, it becomes turing complete
04:02:58 <quicksilver> and we're back to non-termination.
04:03:32 <quicksilver> if you're happy to allow only certain classes of proofs then it all works out
04:03:41 <quicksilver> and that's how I think about epigram, personally...
04:04:01 <faxathisia> http://jaguar.it.miami.edu/~chris/formal_methods_in_the_movies/index.html
04:04:02 <lambdabot> http://tinyurl.com/2t5wzb
04:04:04 <faxathisia> reminds me of that :P
04:04:06 <quicksilver> but that leaves you with programs you can't write :)
04:04:07 <RyanT5000> quicksilver: you know, software development isn't decidable
04:04:24 <RyanT5000> quicksilver: should we refuse to do it?
04:04:28 <quicksilver> RyanT5000: Intuitively I agree although I'm not quite sure how you'd formalise that statement.
04:04:53 <RyanT5000> quicksilver: given a programmer and a software problem, you're not guaranteed to get a solution in any finite amount of time
04:04:56 <faxathisia> esp relevant, http://jaguar.it.miami.edu/~chris/formal_methods_in_the_movies/CoolHandLuke.html
04:04:58 <lambdabot> http://tinyurl.com/2h2l83
04:05:14 <RyanT5000> quicksilver: nor can you determine with certainty whether such solution will ever be produced
04:05:20 <RyanT5000> programmers are turing-complete ;)
04:05:20 <quicksilver> RyanT5000: you could take the view that all useful programs are, in fact, specifiable in PA and therefore the process of writing them is decidable.
04:05:31 <quicksilver> RyanT5000: that's a bit of an extreme view, of course.
04:05:31 <RyanT5000> in PA?
04:05:36 <quicksilver> peano arithmetic
04:05:40 <quicksilver> a decidable logic
04:06:03 <RyanT5000> all useful programs are specifiable in that? why would that be the case?
04:06:05 <faxathisia> I thought peano is inconsistent
04:06:19 <quicksilver> RyanT5000: it's an intuitive judgment; you might not agree
04:06:29 <RyanT5000> i don't know PA well enough to have an intuition about it
04:06:35 <faxathisia> oh seems like I am wrong
04:06:36 <quicksilver> it amounts to saying "we don't really need turing completeness to write all the programs we want"
04:06:42 <RyanT5000> ok how about this
04:06:42 <Philippa> RyanT5000: all programs can be considered as functions :: Nat -> Nat
04:07:03 <Philippa> (except it's a little tricky doing so sensibly with a server with no quit option, for example)
04:07:16 <RyanT5000> "write a program that outputs a proof of the riemann hypothesis"
04:07:31 <Philippa> got a spec for it in PA?
04:07:31 <quicksilver> RyanT5000: absolutely. So in my definition that would be "not a program we want"
04:07:37 <faxathisia> Can I assume False?
04:07:47 <quicksilver> RyanT5000: i.e. I'd exclude that from the set of valid software engineering problems.
04:07:48 <RyanT5000> even though the program is just a printf, it's still not (presently) known whether it can be produced in finite time
04:08:08 <RyanT5000> quicksilver: i seriously doubt that there are software engineering problems that are not of similar quality
04:08:16 <RyanT5000> quicksilver: we've just not found them yet ;)
04:08:20 <quicksilver> I think that's a very difficult judgement
04:08:27 <quicksilver> and not one I have more than an intuitive feel for.
04:08:49 <RyanT5000> i only say that on the basis of the principle that most fields tend to find hard problems given a long enough time
04:08:50 <Philippa> RyanT5000: again, can you specify it in PA?
04:09:21 <RyanT5000> Philippa: i don't know, but i know it's not decidable because the existence of a proof for something is, in general, not decidable
04:10:00 <quicksilver> to return to your point about compilers, my strong personal feeling is that a compiler not guaranteed to terminate would be an annoying thing to work with.
04:10:09 <quicksilver> however, i'd be the last person to stop someone trying
04:10:13 <quicksilver> and therefore prove me wrong :)
04:10:14 <Philippa> it depends on what you're doing with it
04:10:27 <Philippa> it'll be appropriate for some things and not others. Being able to hook up a debugger to it as it runs will help
04:10:29 <RyanT5000> quicksilver: i doubt it would be so annoying if, in practice, 99.9% of users never encountered a situation in which it didn't terminate
04:10:43 <RyanT5000> for example, C++'s type system is undecidable
04:10:54 <RyanT5000> that doesn't stop millions of programmers from writing in it every day
04:11:04 <RyanT5000> because only the crazy template hackers ever encounter problems
04:11:05 <faxathisia> It should..
04:11:14 <faxathisia> (if only)
04:11:18 <RyanT5000> faxathisia: no, i think *other* problems with C++ should stop them :P
04:11:24 <Philippa> 99.9% of users don't want to do anything interesting with C++
04:11:31 <Philippa> or at least, not with its type system
04:11:40 <quicksilver> that's an interesting point, yes
04:12:07 <Philippa> once you're doing interesting things, it'll come up a lot more often
04:12:08 <RyanT5000> Philippa: the only reason more than .1% of haskell users *do* want to do anything interesting is that haskell has no market penetration
04:12:15 <quicksilver> but what you're suggesting, if I'm understanding you right, would be a system where type hackery was much more encouraged
04:12:34 <RyanT5000> quicksilver: only by the people capable of it
04:12:45 <Philippa> RyanT5000: that's not true
04:12:50 <RyanT5000> quicksilver: there is, as i said, a social problem, which is that you need to make things look about as hard as they are
04:13:07 <RyanT5000> Philippa: which bit of it?
04:13:13 <Philippa> other reasons include that you can do a lot more interesting stuff in it, and that haskell users tend to be interested in stronger engineering practices than current mainstream programmers
04:13:22 <Philippa> emphasis on /current/ mainstream programmers
04:13:49 <Philippa> life would be rather different if most of the systems we interacted with required proofs to interoperate, for example
04:14:08 <RyanT5000> Philippa: by "no market penetration" i specifically meant "into mainstream programmers"; and, while i do agree with you somewhat that having a better language would improve programmers *somewhat*, but i don't think we agree as to the extent
04:14:13 <RyanT5000> Philippa: that's a chicken-egg problem
04:14:22 <faxathisia> Philippa: Would it be worth it, for bug free programs?
04:14:32 <RyanT5000> i think that the requirement of extensive proofs is partially the *cause* of the lack of penetration
04:14:48 <RyanT5000> also, it just doesn't make sense to prove the correctness of *everything*
04:14:59 <Philippa> I didn't say correctness, did I?
04:15:13 <RyanT5000> ok, let me rephrase
04:15:14 <faxathisia> uh I didn't mean to imply you did
04:15:16 <Philippa> weaker properties such as resource-safety are generally enough
04:15:24 <RyanT5000> i don't believe there's *any* property that should *always* be proven
04:15:34 <RyanT5000> at least not in principle
04:15:35 <Philippa> faxathisia: you didn't use the word correctness either, RyanT5000 did
04:15:48 <Philippa> I don't recall saying anything about always, either
04:15:49 <RyanT5000> because proving a property is always more expensive than not bothering to prove it
04:15:50 <faxathisia> oh you werent talk to me
04:15:55 <RyanT5000> Philippa: you said "required"
04:16:04 <RyanT5000> which i thought implied always
04:16:18 <Philippa> "if most of the systems we interacted with required proofs to interoperate"
04:16:23 * faxathisia goes away
04:16:27 <RyanT5000> ah, i didn't catch the word most
04:16:28 <RyanT5000> yeah
04:16:29 <RyanT5000> that's fine
04:16:42 <quicksilver> well, also Philippa doesn't not necesarily mean correctness proofs
04:16:49 <quicksilver> things like liveness and resource useage bounds
04:16:57 <quicksilver> are often the safety conditions you care about
04:17:00 <RyanT5000> yeah, a lot of proofs are easy
04:17:02 <Philippa> quicksilver: those're partial correctness though
04:17:03 <quicksilver> if I understand her correctly
04:17:14 <quicksilver> indeed. Maybe I should stop trying to put words in her mouth :P
04:17:17 <Philippa> they're not "does what I intend it to", just "doesn't do what the host prohibited me from"
04:17:24 <RyanT5000> but the truth of the matter is that we're acting in a very ivory-tower kind of way if we expect to force very many proofs at all on people
04:17:35 <RyanT5000> i mean, look at the ridiculous reception the market gave to GC
04:17:42 <Philippa> there are fields that positively want the chance to
04:17:48 <quicksilver> Personally I'd love to see all "important" programs proved correct
04:17:49 <Philippa> GC has run-time consequences though
04:17:59 <quicksilver> but I belief the state of the art is not yet there
04:18:07 <quicksilver> however, I believe good progress is being made...
04:18:12 <RyanT5000> Philippa: run-time consequences are way less important than development-cost consequences
04:18:18 <RyanT5000> (politically)
04:18:28 <RyanT5000> don't forget that adoption is a political problem, not a technical one
04:18:28 <faxathisia> A C Compiler to ppc assembly was proven correct
04:18:33 <faxathisia> What's harder than hat?
04:18:41 <Philippa> faxathisia: a lot
04:18:46 <faxathisia> e.g?
04:18:55 <RyanT5000> faxathisia: that sounds just time-consuming, not particularly difficult
04:19:04 <faxathisia> sounds really hard to me...
04:19:06 <RyanT5000> faxathisia: the riemann hypothesis ;)
04:19:07 <Philippa> anything AI
04:19:22 <faxathisia> Like proving A* is optimal??
04:19:22 <RyanT5000> ooh, thank you Philippa
04:19:27 <Philippa> RyanT5000: it wasn't just a political problem in the fields I was working in
04:19:29 <faxathisia> that seems far easier
04:19:44 <quicksilver> faxathisia: you're referring to http://pauillac.inria.fr/~xleroy/bibrefs/Blazy-Dargaye-Leroy-06.html ?
04:19:47 <lambdabot> Title: leroy : Blazy-Dargaye-Leroy-06, http://tinyurl.com/2kneag
04:19:49 <faxathisia> yes
04:19:54 <RyanT5000> quicksilver: there are interesting software engineering problems involving AI that are undecidable :)
04:20:02 <Philippa> faxathisia: you'll have trouble proving that
04:20:14 <RyanT5000> Philippa: not "just" political, sure, but politics are at the root of it
04:20:24 <RyanT5000> as they are with all decisions involving more than one person
04:20:33 <quicksilver> it wasn't quite C, as I understand it
04:20:39 <quicksilver> mind you, it's interesting work, certainly
04:20:47 <Philippa> RyanT5000: right, because the fact that you *couldn't write 'correct' games with GC tech as it stood at the time* wasn't relevant
04:20:47 <faxathisia> quicksilver: A subset
04:21:05 <Philippa> where 'correct' includes constraints about framerate
04:21:19 <faxathisia> Philippa: Why ?
04:21:26 <faxathisia> (would it be hard to prove A* is optimal)_
04:21:47 <Philippa> faxathisia: because it doesn't produce the 'right' answer unless your heuristic's admissible
04:22:03 <RyanT5000> Philippa: to the extent that there are technical considerations for switching languages, they are part of the political process
04:22:07 <faxathisia> I dont' understand...
04:22:20 <faxathisia> obviously you would have to use a conservative heuristic
04:22:24 <Philippa> RyanT5000: oh sod off
04:22:29 <faxathisia> (otherwise you can't prove it because it's false)
04:22:36 <RyanT5000> Philippa: sorry, i'm not trying to be insulting
04:22:40 <Philippa> "it's all political because ultimately it's humans making the decisions". Not a useful point.
04:22:41 <int-e> faxathisia: can you even formally state what "optimal" means in a tree searching context?
04:22:54 <faxathisia> int-e: shortest cost path
04:22:58 <faxathisia> to a goal
04:23:15 <faxathisia> I mean this is a pretty trivial example
04:23:24 <faxathisia> but it's gotta be easier than proving a c compiler correct
04:23:29 <Philippa> int-e: "produces optimal paths" is what faxathisia had in mind
04:23:29 <RyanT5000> Philippa: no no it is a useful point; i'm trying to say that there's no situation in which technical superiority completely trumps irrational or emotional decisionmaking
04:23:33 <Philippa> faxathisia: size
04:23:48 <Philippa> you're not telling us anything about algorithmic complexity
04:23:50 <faxathisia> Philippa: I'm sorry but I really am not understanding what you mean
04:23:54 <Philippa> it's not necessarily harder, just bigger
04:24:03 <int-e> Philippa: I see now. I had something different in mind.
04:24:05 <RyanT5000> Philippa: certainly, in some settings the technical considerations might take the fore - probably situations with more competent programmers in charge
04:24:22 * wli would go so far as to say that the influence of technical superiority is extremely limited and extremely small.
04:24:26 <int-e> faxathisia: I'd call that correctness.
04:24:39 <faxathisia> int-e: Yeah, that's why I gave it as an example
04:24:39 <Philippa> RyanT5000: it's far from adequate to draw useful conclusions about the kinds of orders of magnitude difference we were talking about
04:25:22 <Philippa> faxathisia: basically you're not telling us anything about complexity, only complication
04:25:42 <Philippa> the C compiler has a bigger spec, sure - it's more complicated
04:26:10 <faxathisia> No, I mean I think it's also actually a lot harder
04:26:21 <Philippa> I suspect the single hardest thing is actually formalising what it means to be an adequate C compiler
04:26:27 <faxathisia> the size being just one contributing factor
04:26:27 <Philippa> what with the standard being informal
04:26:36 <Philippa> yes, but you're not actually giving any grounds for it
04:26:51 <Philippa> it is, after all, just a composition of parts most of which we already know how to prove
04:26:58 <faxathisia> ok well you have a language specification of syntax and semantics for I think they have 5 languages
04:27:22 <faxathisia> you gotta write a conversion routine and prove semantics are the same for them all
04:27:34 <faxathisia> with A* you just have to prove it's a graph search which fits a certain specification
04:27:52 <faxathisia> I've not gone through either proof formally.. but I would imagine the compiler being much harder
04:27:59 <Philippa> with the conversion you've just got to prove it's a mapping which fits a certain specification
04:28:02 <faxathisia> Would you say it's not, and why would you think it's not?
04:29:28 <Philippa> I would say that almost all the hard work's in structuring it right. The type system's mostly niggling and we're not looking to prove hard properties, the run-time semantics aren't actually all that complicated and most of the tough stuff'll be about memory layout...
04:29:36 <quicksilver> the key thing about providing a proof of a C compiler is a formal semantics for C, plus a formal semantics for assembly.
04:29:46 <quicksilver> then you 'just' have to prove the two are equivalent
04:29:54 <Philippa> right. The hard part's having a spec at all
04:29:58 <RyanT5000> Philippa: i'm sorry if i was unclear, and i'm not really trying to produce predictions of which exact language features will prevail, but it's crucial to recognize that irrationality (specifically fear of change, cronyism, and group identity) can, in some circumstances, completely dominate technical superiority; I wasn't saying it always does
04:30:02 <quicksilver> well, that the compiler is semantic-preserving
04:30:09 <faxathisia> quicksilver: They use several intermediate stages though.. I think that probably makes it easier but also shows how difficult it is overall
04:30:42 <Philippa> RyanT5000: it can't do it to the entire market though, and there are fields where there are extremely clear advantages to having the proofs
04:30:49 <quicksilver> in a sense which I can't quite make precise, it's not "maths-hard" though
04:30:52 <Philippa> there are areas where it's definitely going to happen
04:30:56 <faxathisia> mm ok
04:31:04 <quicksilver> whereas correctness of some graph algorithms is definitely "maths-hard"
04:31:20 <faxathisia> I'd love if you could make precise "maths-hard"
04:31:28 <quicksilver> the hard bit is not proving that your programming language implements the algorithm
04:31:33 <quicksilver> the hard bit is proving the algorithm works
04:31:35 <faxathisia> I think I have a vauge Idea what you mean by that
04:31:37 <Philippa> faxathisia: "waah, intermediate stages!" - that tell you that you end up with complication, but it actually tells you that it's not so complex if you know how to split it
04:31:38 <quicksilver> which is maths, not computer science
04:31:48 <Philippa> rather, it shows that elements of the proof can be split easily
04:31:50 <RyanT5000> Philippa: absolutely; i completely agree that proofs should be required in some areas
04:32:03 <faxathisia> Philippa: ah.. I never thought of it that way
04:32:09 <faxathisia> That's very much possible
04:32:16 <Philippa> RyanT5000: once it's in those areas, clue will spread out
04:32:29 <Philippa> it probably won't hit the average web page scripter, sure
04:32:34 <RyanT5000> Philippa: true, but i think there will always be room for buggy-but-cheap software
04:32:47 <Philippa> yeah, but that's a very different argument to the one we were having
04:33:24 <RyanT5000> Philippa: yeah, i think the root of the heated part of our argument was me missing the word "most" in your "required" sentence
04:33:34 <wli> From what I understand of how the world works there is no technical property that will stand up in the face of economic, corruption, cronyism, or ideological influences. The hope for a technically superior product to prevail is miniscule at best.
04:33:40 <Philippa> faxathisia: compiler writing can be like that, you end up tackling a few elements of the translation problem at a time
04:33:57 <Philippa> wli: in the immediate term, yes
04:34:09 <Philippa> in the long term, the OS I have today is technically superior to the one I was using 15 years ago
04:34:33 <quicksilver> technically superiority will bring economic benefits
04:34:40 <quicksilver> but they may not be obvious to the right people at the right time
04:34:41 <RyanT5000> Philippa: i think we basically agree that the proportion of code with proven properties should be increased
04:34:43 <Philippa> or 10. Debatable re 5, but that's because we're talking about win2K vs winXP then
04:34:44 <quicksilver> and they may be long term
04:35:04 <wli> I don't know. OS's have been at something of a theoretical standstill for longer than 15 years.
04:35:12 <RyanT5000> i seriously doubt that, at any given time, the technically-best thing will also be the thing chosen by the political process
04:35:16 <Philippa> sure. But 15 years ago I was still booting DOS
04:35:30 <RyanT5000> however, the thing chosen may be the technically-best thing from 5 years ago
04:35:36 <quicksilver> wli: theoretical != technical
04:35:44 <Philippa> and all you need for progress is that it be technically better than the previous thing
04:35:49 <quicksilver> wli: 15 years ago I was using a single-tasking system
04:35:53 <RyanT5000> Philippa: right
04:35:58 <faxathisia> @remember wli From what I understand of how the world works there is no technical property that will stand up in the face of economic, corruption, cronyism, or ideological influences. The hope for a technically superior product to prevail is miniscule at best.
04:35:59 <lambdabot> Nice!
04:36:00 <quicksilver> wli: now I have a pre-emptive multitasking system with virtual memory
04:36:05 <Philippa> quicksilver: 15 years ago my OS was little more than a fancy bootloader with a shell slapped on top :-)
04:36:08 <quicksilver> wli: that is a technical improvment :)
04:36:49 <quicksilver> wli: it's true that theory that drives my current OS mostly existed 15 years ago. Maybe all of it did.
04:36:51 <RyanT5000> irrationality is instantaneous, whereas technical superiority takes a while to demonstrate convincingly
04:36:53 <quicksilver> wli: but I didn't have them then.
04:37:18 <Philippa> right. The theory may be done but that doesn't mean the engineering is yet
04:37:32 <RyanT5000> yep
04:37:48 <faxathisia> just add curry howard!
04:37:58 <nornagon> :t curry howard
04:37:59 <lambdabot> Not in scope: `howard'
04:38:09 <quicksilver> I can use the internet from the sofa, wireless, and from the train
04:38:13 <RyanT5000> so here's a semi-useful conclusion out of all of this: haskell is doing a wonderful job of the technical superiority thing, but a pretty bad job of the "feel good" stuff
04:38:20 <wli> I was never very involved with the early Microsoft/Intel "desktop" affairs. They were a rather extreme backward movement on the technical front.
04:38:29 <faxathisia> eh, Ryan?
04:38:35 <faxathisia> what do you mean feel good
04:39:03 <RyanT5000> i mean things that make people feel good when they use the language, particularly for the first time
04:39:26 <RyanT5000> people want to start using the language and immediately feel comfortable with it at least on some level
04:39:28 <faxathisia> yeah... when I first used haskell I actually got a bunch of stuff done.. quickly
04:39:30 <quicksilver> 15 years ago I just had access to a dial-up bulletin board with uucp mail...
04:39:33 <Philippa> RyanT5000: that's okay, that's not Haskell's job
04:39:41 <faxathisia> It was a bit irritaitnig because then I had to think of something else to write to learn the language better
04:39:53 <RyanT5000> faxathisia: that's certainly true for some people - it was true of me as well
04:39:57 <RyanT5000> Philippa: who's job is it?
04:40:00 <faxathisia> but it's fun !
04:40:02 <Philippa> Haskell would be fundamentally not Haskell had it made seriously populist choices along the line
04:40:04 * nornagon agrees with faxathisia 
04:40:25 <RyanT5000> Philippa: i don't think getting a debugger earlier than 6.8 would have hurt anything
04:40:30 <Philippa> RyanT5000: Some other language. Currently the .NET langs, the latest P lang, things like that. And yes, they're behind us technically
04:40:42 <faxathisia> What are P langs?
04:40:45 <wli> I was using SPARCstations with X11 on them wired with ethernet onto the internet when PC's were doing DOS and dialup was a sort of strange thing to get people who did serious work connected under extreme circumstances.
04:40:45 <faxathisia> oh programming...
04:40:46 <Philippa> RyanT5000: no, it wouldn't have. However, nobody was paying to get it developed
04:40:58 <Philippa> faxathisia: PHP, Perl, Python et al
04:41:02 <faxathisia> ohh
04:41:27 <RyanT5000> Philippa: well, the only way to get anything done is to convince someone (possibly yourself) to do it; money's one way, and argument's another
04:41:29 <Philippa> RyanT5000: note how the languages I've listed all have much, much more money pouring into their development?
04:41:32 <faxathisia> other than starting with p... what's the common factor?
04:41:43 <RyanT5000> Philippa: yeah, not having money makes it really tough
04:41:58 <Philippa> faxathisia: they're populist langs from a scripting, do-it-now background and with a high-level of newbie-friendliness for their target market
04:42:13 <Philippa> (which in perl's case was existing *nix shell scripters who were familiar with tools like grep and awk)
04:42:30 <faxathisia> I find perl quite useful at times.. but I know what you mean
04:42:57 <bgeron> they're more domain-specific
04:43:00 <Philippa> thankfully there's no Enterprise Ruby, so nobody talks about a LAMER stack
04:43:06 <RyanT5000> Philippa: but i think if populist concerns become more a part of the haskell developers' collective consciousness, we might see some popularization that comes without monetary compensation
04:43:08 <Philippa> bgeron: Python isn't
04:43:25 <bgeron> agree
04:43:30 <Philippa> RyanT5000: Yes. We also risk losing what makes the language worthwhile for us
04:43:42 <Philippa> now let's put this in perspective: a debugger's been clearly on the wishlist for a very, very long time
04:43:43 <faxathisia> how do you classify a language as domain-specific?
04:43:47 <quicksilver> bgeron: I don't think perl's particularly domain specific either.
04:44:04 <RyanT5000> Philippa: do we really? i think we could stand to be more populist with dev tools, etc., without damaging the language
04:44:06 <Philippa> it isn't these days, though it started out as shell-on-crack
04:44:27 <Philippa> RyanT5000: Risk != certainty
04:44:31 <quicksilver> RyanT5000: better to train people not to use a debugger than provider a debugger :)
04:44:39 <RyanT5000> Philippa: well, there's always risk :)
04:44:58 <bgeron> quicksilver: well, it only has a few basic data types (based on strings, imho), lists, hashes and references.. s
04:45:02 <bgeron> oops
04:45:06 <bgeron> meant to ^K
04:45:13 <faxathisia> bgeron: how do you classify a language as domain-specific?
04:45:21 <RyanT5000> quicksilver: it would be much better if you provided a debugger helped people learn to work without it
04:45:27 <bgeron> it's got lots of language constructs specifically for strings, for example
04:45:30 <quicksilver> bgeron: that much is true of python and also lisp
04:45:34 <faxathisia> Certainly *I* use langs for specific types of tasks..
04:45:37 <RyanT5000> quicksilver: of course, that's difficult to design
04:45:41 <quicksilver> RyanT5000: that would be a neat trick, yes :)
04:45:41 <faxathisia> but I don't know what domain specific means in general
04:45:41 <bgeron> quicksilver: how lisp?
04:45:44 <Philippa> RyanT5000: so, aside from prettying up the debugger, what populist tools do you think that we can manage to build without a significant risk of the damage I described?
04:45:55 <Philippa> if you say "an IDE", I will burst out laughing
04:45:57 <quicksilver> bgeron: lisp just has cons-cells plus a few basic types of atoms
04:46:01 <faxathisia> lisp has conses and arrays
04:46:04 <RyanT5000> Philippa: a better module system
04:46:04 <faxathisia> and atoms and a bunch of stuff
04:46:13 <quicksilver> bgeron: (string, number, couple more in more sophisticated dialects)
04:46:18 <RyanT5000> Philippa: a better record system
04:46:21 <bgeron> atoms = {characters, strings, streams, functions, macros, ..}
04:46:26 <Philippa> yeah. Any other bikesheds?
04:46:30 <int-e> Philippa: does the debugger even matter? it's not part of the language as such. actually the same goes for an IDE.
04:46:33 <bgeron> structs (talking about Common Lisp now :)
04:46:37 <quicksilver> bgeron: very similar to perl, then...
04:46:56 <bgeron> perl was made for strings, imho
04:47:05 <quicksilver> it probably was, yes
04:47:06 <bgeron> but maybe that's only its basis
04:47:10 <quicksilver> but that doesn't mean that's what it is now :)
04:47:12 <Philippa> and our module system already compares well to pretty much anything that doesn't have a lot of ML in its heritage
04:47:17 <bgeron> you're right
04:47:18 <faxathisia> isn't it in TCL, everything is a string at one point
04:47:47 <Philippa> yeah, TCL:strings::lisp:lists
04:47:49 <bgeron> that must hurt speed
04:47:50 <Philippa> only more so
04:48:02 <quicksilver> I don't find the experience of writing perl, python, or javascript significantly different from each other
04:48:02 <faxathisia> .. speed..
04:48:05 <Philippa> int-e: the word "tools" was used...
04:48:06 <faxathisia> does that really matter
04:48:08 <RyanT5000> Philippa: there are some trivial changes that would make the module system a lot better, for instance eliminating the self-referential header line
04:48:22 <quicksilver> I haven't tried ruby to any significant extent
04:48:29 <bgeron> faxathisia: yes, how would you feel if your favorite language performed 20x worse?
04:48:31 <RyanT5000> Philippa: also, i'm not sure why "an IDE" is such a ridiculous desire
04:48:34 <Philippa> RyanT5000: yes, I'd like to see GHC do that right too
04:48:37 <quicksilver> meanwhile I do find haskell and ML to be quite different from the former :)
04:48:37 <Philippa> RyanT5000: because it won't happen
04:48:44 <faxathisia> bgeron: my favorite language? :p
04:48:46 * bgeron doesn't know numbers for speed though
04:48:55 * bgeron assumes it's haskell ;)
04:49:06 <wli> I miss ML functors so bad it hurts.
04:49:08 * faxathisia is language agnostic
04:49:19 <bgeron> that's a good excuse ;)
04:49:26 <RyanT5000> Philippa: just because it's hard?
04:49:39 <faxathisia> but I imagine if every programming language was 20x slower.. I would just do things slower and think more
04:49:54 <Philippa> RyanT5000: for "lots of work" values of hard, and also because most existing users don't need one badly enough
04:49:54 <faxathisia> It's not really important
04:50:08 <faxathisia> basically the difference between search and replace taking 0.02s or 2s
04:50:28 <RyanT5000> Philippa: i couldn't care less about *existing* users; i care about all the users we *don't* have
04:50:35 * bgeron is trying to implement a new Lisp these days, and the way I implemented it, compiles take ~8 min
04:50:37 <Philippa> oh, and /also/ because doing anything that can't be done easily with any of a whole pile of existing text editors is extremely hard indeed
04:50:51 <faxathisia> bgeron: I was bored yesterday so I wrote a schemeish compiler :p
04:50:57 <bgeron> nice
04:51:07 <Philippa> RyanT5000: I asked about things we can actually get done. I don't give a damn what you would like that won't get done, code needs to be written by existing users
04:51:15 <faxathisia> bgeron: new Lambda(new Cons(Symbol.Intern("x"), ...
04:51:38 <bgeron> written a reader too? ;)
04:51:52 <Philippa> there have been multiple IDE projects. We have a text editor with emacs-like features. We still don't have an IDE.
04:51:56 <Philippa> this ought to tell you something
04:52:02 <faxathisia> nah, I'll just find one someone else already wrote in shceme
04:52:46 <faxathisia> I found that using a text editor and having ghci open is great for writing haskell..
04:52:49 <faxathisia> is that usual?
04:52:50 <Philippa> to actually be useful in a "does things you can't knock up with an existing text editor" way, we need to /rewrite large chunks of GHC/!
04:53:01 <RyanT5000> Philippa: i agree that it's very difficult, and even more difficult to convince people who are happy with the status quo to put effort into changing it for the benefit of others
04:53:03 <pejo> faxathisia, 4 times slower means your calculations take 40 hours instead of 10.
04:53:20 <Philippa> we don't have a parser suitable for syntax highlight. We don't have a suitably interactive typechecker, or the ability to debug typings or even access to the info necessary to do so
04:53:30 <faxathisia> pejo: yeah.. that doesn't affect me really
04:53:45 <bgeron> lucky :)
04:53:48 <RyanT5000> Philippa: even rudimentary Eclipse integration would be helpful
04:54:04 <RyanT5000> (for beginners)
04:54:06 <Philippa> RyanT5000: so go round up a bunch of people who use Eclipse and write it
04:54:12 <faxathisia> Eclipse ? :(
04:54:30 <Philippa> ISTR it's Java-based, so personally I'd rather stab my eyes out with a fork than have to develop for it. You'll find a lot of people here who feel the same
04:54:30 <faxathisia> will hav to learn every editor under the sun
04:54:38 <RyanT5000> Philippa: well i suffer from the same problem you're quite correctly pointing out: lack of time to spend on it
04:54:59 <faxathisia> Philippa: What's so bad about java... everyone keeps complaining about it but I never understood
04:55:05 <faxathisia> Is it that.. it doesn't have goto?
04:55:15 <Philippa> So do us a favour: stop berating the community and start looking at things we can get done. Hell, even a hitlist of things needed for eclipse integration would be a starting point
04:55:18 <faxathisia> (I find a lot of people like C but claim to hate java)
04:55:28 <bgeron> faxathisia: my complain is that Hello World takes 5 lines
04:55:34 <RyanT5000> Philippa: i'm not berating "the community"!
04:55:50 <Philippa> faxathisia: if you've never tried to do AST manipulation in Java, you're unlikely to hate it as much as I do
04:55:51 <faxathisia> do you think code in general is 5x longer?
04:56:00 <RyanT5000> Philippa: i'm not berating anything, in fact
04:56:02 <bgeron> dunno, never tried
04:56:05 <Philippa> no, I'd say 10x by the time you try to factor usefully
04:56:19 <bgeron> but the type system sucks too, apparently
04:56:22 <faxathisia> Philippa: I'd do AST manipulation in haskell or java
04:56:23 <faxathisia> ere
04:56:29 <faxathisia>  I mean haskell or scheme*
04:56:30 <Philippa> you end up with classes coming out of orifices you didn't even know you had
04:56:40 <faxathisia> so you could just use a scheme interpreter written in java
04:56:41 <Philippa> faxathisia: you talk as if there was a choice involved
04:56:47 <faxathisia> yes of course it is
04:56:49 <Philippa> yes. I think that says it all
04:57:14 <Philippa> any time the correct answer is to implement the whole of a different general purpose language in the one you're working in and work in that language instead, there is a problem
04:57:33 <faxathisia> not at all
04:57:41 <faxathisia> This is an excellent strategy for programming
04:57:45 <quicksilver> RyanT5000: there *is* rudimentary eclipse integration
04:57:46 <faxathisia> look at some of the best lisp code
04:57:52 <Philippa> no, it's the degenerate version of an excellent strategy
04:58:08 <faxathisia> or even haskell
04:58:24 <Philippa> the excellent strategy is to implement the whole of a special-purpose or the semantic core of a different general-purpose one
04:58:32 <quicksilver> Philippa: editor support such as 'best attempt' type-checking of incomplete input would certainly be a nice thing to have.
04:58:45 <quicksilver> Philippa: it's not easy though, as you say
04:59:13 <RyanT5000> quicksilver: i think i tried it about 6 months ago and it basically just crashed all the time, and the repositories didn't work right; one of my friends (a haskell beginner with significant experience in other languages) tried it and gave up
04:59:19 <Philippa> exactly. It probably requires a complete restructuring of the typechecker
04:59:34 <quicksilver> RyanT5000: Yeah. FSOV 'rudimentary' rather close to 'totally broken'
04:59:50 <quicksilver> RyanT5000: but, I believe there are peopple who use it, so it must be possible to limp it into shape
05:00:09 <quicksilver> occasionally a post on -cafe indicates that someone uses it as their preferred platform
05:00:09 <RyanT5000> quicksilver: yeah, that may be true
05:00:46 <quicksilver> Philippa: I have some vague thoughts that you might be able to hack things together by running the type checker over a version which has 'undefined' inserted in the 'holes'
05:01:11 <RyanT5000> Philippa: for the record, i'm not entirely full of hot air, here; i'm planning on doing a Ph.D. next, in which I'll hopefully be able to make some contributions to Haskell
05:01:25 <quicksilver> Philippa: but the best solution would of course be a totally independent re-implementation of GHC's type-checker.
05:01:34 <quicksilver> Philippa: designed for sensible external use
05:01:37 <RyanT5000> Philippa: and usually my contributions have some kind of populist slant, even if they are primarily theoretical
05:01:42 <quicksilver> Philippa: (such as incremental re-checking after small changes)
05:02:53 <Philippa> quicksilver: no, that's a guaranteed broken solution because it'd have to keep pace
05:03:17 <Philippa> better to refactor the GHC checker appropriately
05:03:40 <RyanT5000> Philippa: if it's enough easier, it might be worth it to have a solution that is perpetually slightly broken than one that is correct
05:03:59 <RyanT5000> (we seem to have switched sides of the argument :P)
05:04:22 <quicksilver> Philippa: it's a fair point but I don't think the fundamentals of type checking change all that often?
05:04:51 <Philippa> fundamentals aren't good enough - and GHC's had some major changes in the last couple of years there, too
05:04:52 <RyanT5000> quicksilver: I think Philippa's referring to associated types, etc., which are being developed pretty rapidly...?
05:04:56 <Philippa> associated types are a big one
05:05:04 <Philippa> not only that, but fundeps have been constantly tweaked
05:05:43 <Philippa> GADTs required a fair amount of work, and much has changed with them
05:06:31 <RyanT5000> Philippa: a hacked-out Haskell 98 typechecker would be good enough for beginners
05:06:47 <Philippa> and a pain in the arse the moment they became intermediate users
05:07:05 <RyanT5000> yeah, but then you can just turn it off and go back to emacs-style :P
05:07:07 <Philippa> the moment you start using, say, the monad transformers in the standard libraries...
05:07:51 <RyanT5000> once someone's gotten to that level of adoption, it's way less important how shiny haskell looks to them
05:08:05 <RyanT5000> also, they might contribute to the typechecker
05:08:12 <RyanT5000> or might be inspired to rewrite the GHC one as required
05:08:22 <integral> editor support isn't just about being shiny but about being useful to actual programmers...
05:08:25 <Philippa> you have to be way beyond that level to do that usefully
05:08:45 <RyanT5000> integral: true, but right now we have neither
05:09:17 <RyanT5000> Philippa: yeah, but they might remember it when they reach that level, and say to themselves "man, i really wish i had had _____; let me go implement it"
05:09:55 <wli> The monad transformer type system situation is rather disturbing.
05:10:07 <Philippa> if you're at "that level" you're not going to need the kiddie tool to encourage it
05:10:28 <RyanT5000> i mean, i spend a lot of time personally teaching people haskell, because i wish someone had done that for me when i was learning to program
05:10:45 <RyanT5000> if someone had actually done that for me, though, i might not see the value in doing it myself
05:10:49 <Philippa> wli: it'll get sorted, it'll just take time for ATs to finish rolling out
05:11:16 <RyanT5000> Philippa: it'll make the absence of intermediate-level features stand out in their mind, instead of just getting used to a complete absence of the entire thing
05:11:28 <sjanssen> wli: in what respect?
05:11:33 <RyanT5000> Philippa: (but of course you're right that it's not going to be conclusive or anything)
05:12:12 <wli> sjanssen: Just the way fundeps appear to need fixups that aren't described in papers on them.
05:13:00 <Heffalump> Philippa: I'm not entirely convinced by ATs; there's no really natural equivalent of a 2-way fundep.
05:13:32 <Philippa> Heffalump: I'm not convinced that needs more than a little sugar?
05:14:25 <Heffalump> what would the sugar look like?
05:14:57 <Philippa> good question. Sorry, probably a good idea if we come back to that another time - I'm not on top form today. But if you want to elaborate on your concerns?
05:15:07 <integral> @type curry
05:15:08 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
05:15:50 <Heffalump> well, I just think that Foo a b | a -> b, b -> a is rather more natural than type family Foo a ; type family UnFoo b
05:16:02 <wli> I've still not gotten a copy of ATTaPL to see what's going on with module systems.
05:17:13 <sjanssen> Heffalump: but how often do we need the two way fundep?
05:18:01 <quicksilver> Heffalump: yeah, can you give a concrete example of the kind of code which needs that?
05:18:20 <quicksilver> There was some on the -cafe btu I wasn't convinced it was sensible :)
05:19:41 <Philippa> Heffalump: yeah, I think that can be done with some mildly smart relationship-to-function sugar
05:19:43 <wli> I heard rumors of an ICFP paper on grafting a more ML-like module system onto Haskell.
05:20:03 <quicksilver> wli: have you read the peyton-jones module system paper?
05:20:27 <Heffalump> Philippa: why not just stick with fundeps?
05:20:31 <wli> quicksilver: Probably not.
05:20:39 <Philippa> Heffalump: AIUI ATs have nicer theoretical properties
05:20:59 <Philippa> there's talk of reimplementing fundeps on top of ATs, that works for me
05:21:02 <Heffalump> sjanssen: for example, a mapping between native Haskell types and the SQL representations of those types.
05:21:04 <quicksilver> wli: it's worth reading, then
05:21:18 <quicksilver> wli: although the obvious question is "OK, why didn't he implement this?" and I don't know the answer :)
05:21:31 <Philippa> wli: there's been a lot of work done on the relationship between type classes and modules
05:22:05 <quicksilver> Heffalump: hmm, that is an interesting example, thank you.
05:22:11 <Philippa> keeping the extras that come with ATs seems fairly clearly useful to me, anyway
05:22:26 <wli> It's kind of tough for me to keep up with it all.
05:36:30 <MyCatVerbs> Does anyonehavea copy of "Diagnosing Deadlock Bugs for Retards"?
05:36:46 * MyCatVerbs has a huge pile of jammed-up code, and also apparently a jammed up spacebar.
05:49:50 <pmatos> For a given type class, where can I find the functions I need to define in order to say that my data is an instance of that class?
05:50:21 <quicksilver> in the definition of the class
05:50:24 <quicksilver> or the documentation of it
05:50:39 <quicksilver> or by typing :info in ghci
05:51:16 <pmatos> quicksilver: I've been looking at the Show class in specific and at this page which seems to be the reference: http://www.haskell.org/onlinereport/basic.html
05:51:17 <lambdabot> Title: The Haskell 98 Report: Predefined Types and Classes
05:51:32 <pmatos> quicksilver: it seems to make my data instance of the show class I need to define 3 functions then, right?
05:51:57 <pmatos> quicksilver: (previously I thought it was only show but it seems to be show, showprec and showlist)
05:52:07 <quicksilver> pmatos: correct
05:52:17 <pmatos> quicksilver: ok, thanks.
05:52:21 <quicksilver> pmatos: well. thre is a default definition for showsPrec
05:52:27 <quicksilver> pmatos: so you don't need to define that
05:52:35 <quicksilver> pmatos: and also for showList :)
05:52:50 <quicksilver> pmatos: this is all explained in 6.3.3 "The Read and Show Classes"
05:52:59 <quicksilver> pmatos: so, it really is just 'show' you need to define as you first thought
05:53:01 <pmatos> quicksilver: so, going back to my question, how do I know what do I need to define and what is defined in terms of what I define?
05:53:11 <pmatos> quicksilver: lol, ok, I'll look into 6.3.3
05:53:14 <quicksilver> by looking at the definition, or reading the documentation
05:53:25 <pmatos> quicksilver: ok :-)
05:53:28 <quicksilver> pmatos: that's a section number in the document you pointed me to ;)
05:53:39 <Saizan> or by not defining it and not getting a warning from ghc
05:54:47 <pmatos> Saizan: okidoki
05:56:30 <roconnor> > 6^6 `mod` product [1..6]
05:56:33 <lambdabot>  576
05:58:31 <ari> > map (\n -> n^n `mod` product [1..n]) [1..10]
05:58:31 <lambdabot>  [0,0,3,16,5,576,2023,4096,227529,2656000]
05:58:47 <ari> @oeis 0 0 3 16 5 576
05:58:48 <lambdabot> Remainder when n^n is divided by n!.
05:58:48 <lambdabot> [0,0,0,3,16,5,576,2023,4096,227529,2656000,26301011,443667456,5268921853,2943...
05:59:23 <EvilTerran> oeis++
06:02:14 <MyCatVerbs> Printlining with hPutStrLn is... challenging, in a multi-threaded environment.
06:02:37 <MyCatVerbs> Certainly reading the output is.
06:02:40 <quicksilver> MyCatVerbs: yeah, don't call putStrLn from more than one thread.
06:02:49 <quicksilver> MyCatVerbs: use a Chan; perhaps a Chan String.
06:03:08 <pmatos> Hello, is there a way to define a type class that acts as the union of pre-existent classes? So, for example, instead of saying that all my data is instance of Show, Eq, ..., can I define a new class that is union of Show, Eq, ... and then each time I define a datatype, say that it derives from my union-class?
06:03:35 <quicksilver> pmatos: yes. But it may not do what you want.
06:03:44 <pmatos> quicksilver: what do you mean?
06:03:45 <quicksilver> class (Eq a, Show a) => MyClass a where
06:03:54 <quicksilver> will enforce that all myclasses are also eq, show
06:04:05 <quicksilver> it won't stop you from having to write the instances, though
06:04:12 <quicksilver> it will just complain if you don't/
06:04:20 <pmatos> quicksilver: yes, I understand.
06:04:47 <pmatos> quicksilver: but it means that all instances of MyClass will have to be instances of Eq, Show, etc... :-) great! thx
06:04:51 <quicksilver> (types don't "derive from" classes in haskell, by the way)
06:05:13 <pmatos> quicksilver: so the correct way to say it is that types are instances of classes?
06:05:15 <ari> http://repetae.net/recent/out/classalias.html is more like what you want, as far as I know, but it's just a proposal
06:05:15 <lambdabot> Title: Class Alias Proposal for Haskell
06:05:17 <quicksilver> yes
06:05:23 <quicksilver> instances or members, yes
06:05:23 <l0llasdasd> Hey people, Visit and join http://www.vidvoter.com IT is an awesome site for Applications, E-books, Games, Movies and TV SHows! Please Visit! :)
06:05:24 <lambdabot> Title: VIDV0TER
06:05:35 <quicksilver> l0llasdasd: go away.
06:05:51 <pmatos> quicksilver: ok. great
06:05:57 <pmatos> ari: I'll check that out, thx.
06:06:05 <quicksilver> ari: the proposal would save pmatos some typing.
06:06:12 <quicksilver> ari: the enforcement we can do already :)
06:06:13 <EvilTerran> quicksilver, not all bots're as well-behaved as lambdabot when you tell 'em to leave ;)
06:06:26 <EvilTerran> @bot
06:06:26 <lambdabot> :)
06:06:28 <quicksilver> EvilTerran: yeah, shame ;)
06:07:08 <pmatos> ari: this is a proposal, there's no implementation of it, right
06:07:09 <pmatos> ?
06:07:14 <quicksilver> pmatos: right.
06:07:23 <quicksilver> EvilTerran: ah, it seems to have worked :) My words are powerful!
06:07:44 * quicksilver 15 t3h K-|_1|\|3R !
06:07:50 <pmatos> quicksilver: great! :-)
06:10:37 <EvilTerran> @. elite yow
06:10:37 <lambdabot> 4rE ThE $Tew3D Prun35 sti11 In 7he h4IR DryEr?
06:10:56 <quicksilver> @. elite yarr
06:10:57 <lambdabot> zP|ice +h3 maINBra(3!
06:11:27 <EvilTerran> @. elite quote quicksilver
06:11:28 <lambdabot> QuiCx$iLveR z4y5: z0MEONE wITH 4r7I$tIC taLEnT 5h0U1D dO 4 draWing EntI+|3d un5afepERf0rm/\/\ETA/\/\OrPho$I5
06:32:48 <sorear> @users
06:32:48 <lambdabot> Maximum users seen in #haskell: 406, currently: 396 (97.5%), active: 10 (2.5%)
06:33:36 <EvilTerran> @quote \?$
06:33:36 <lambdabot> dolio says: [psnl] its been made worse by uni doing a sexual awareness week [dolio] Some people at your university weren't aware of sex?
06:33:44 <EvilTerran> hm...
06:33:46 <EvilTerran> @. vixen quote \?$
06:33:46 <lambdabot> isn't it obvious?
06:36:17 <ttt-> @quote \?$
06:36:18 <lambdabot> Binkley says: so then why can't I attach notes to my butt with a refrigerator magnet?
06:36:19 <njbartlett> @seen Heffalump
06:36:19 <lambdabot> Heffalump is in #darcs and #haskell. I last heard Heffalump speak 1h 15m 17s ago.
06:37:35 <esteban2> lol
06:38:01 <EvilTerran> @@ @run "(@quote)"
06:38:02 <lambdabot>  "(@quote)"
06:38:06 <EvilTerran> harumph.
06:43:51 <Altair^> why does "round 0.5" return 0
06:44:05 <EvilTerran> @src round
06:44:05 <lambdabot> Source not found. :(
06:44:16 <EvilTerran> it probably does bankers' rounding
06:45:48 <Altair^> without the check included :/
06:45:52 <Altair^> weird
06:45:58 <byorgey> > round 0.5
06:45:59 <lambdabot>  0
06:46:03 <byorgey> > round 1.5
06:46:04 <lambdabot>  2
06:46:13 <EvilTerran> http://haskell.org/onlinereport/standard-prelude.html#$tRealFrac
06:47:14 <sorear> @src Double round
06:47:15 <lambdabot> Source not found. I feel much better now.
06:47:45 <EvilTerran> "... 0  -> if even n then n else m ..."
06:48:01 <EvilTerran> says bankers' rounding to me
06:49:06 <vininim> @src round
06:49:06 <lambdabot> Source not found. The more you drive -- the dumber you get.
06:49:40 <EvilTerran> the canonical implementation's at that link i posted
07:00:30 <quicksilver> > map round [0.5,1.5,2.5,3.5,4.5,5.5,6.5,7.5,8.5,9.5,10.5]
07:00:32 <lambdabot>  [0,2,2,4,4,6,6,8,8,10,10]
07:00:48 <quicksilver> interesting. banker's round it is. I didn't know that.
07:00:49 <EvilTerran> > map round [1.5..]
07:00:50 <lambdabot>  [2,2,4,4,6,6,8,8,10,10,12,12,14,14,16,16,18,18,20,20,22,22,24,24,26,26,28,28...
07:01:06 <quicksilver> EvilTerran: that's not very reliable because .. can't be trusted on floating point numbers..
07:01:12 <EvilTerran> > [1.5..]
07:01:13 <lambdabot>  [1.5,2.5,3.5,4.5,5.5,6.5,7.5,8.5,9.5,10.5,11.5,12.5,13.5,14.5,15.5,16.5,17.5...
07:01:20 <quicksilver> although, 1.5 should be stored exactly?
07:01:24 <quicksilver> since our native rep is base 2?
07:01:25 <faxathisia> > map round [2%3..]
07:01:26 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
07:01:29 <EvilTerran> x.5 can all be represented exactly, yeah
07:01:34 <faxathisia> > [2%3..]
07:01:35 <lambdabot>  [2%3,5%3,8%3,11%3,14%3,17%3,20%3,23%3,26%3,29%3,32%3,35%3,38%3,41%3,44%3,47%...
07:01:39 <quicksilver> EvilTerran: but is it guaranteed to be so?
07:01:52 <EvilTerran> i'd hope so
07:01:56 <quicksilver> I suspect it is
07:02:06 <quicksilver> I suspect 1.5 is, by defintion, fromRational (15/10)
07:02:31 <faxathisia> > map round [3%2..]
07:02:32 <lambdabot>  [2,2,4,4,6,6,8,8,10,10,12,12,14,14,16,16,18,18,20,20,22,22,24,24,26,26,28,28...
07:03:14 <quicksilver> btu I'm not sure.
07:03:18 <faxathisia> :t (%) -- huh?
07:03:19 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
07:03:32 <faxathisia> oh you need Data.Rational
07:03:43 <byorgey> that is Data.Rational.
07:54:42 <Element14> > 1
07:54:44 <lambdabot>  1
07:54:56 <Element14> > "hi"
07:54:57 <lambdabot>  "hi"
07:59:21 <Lycurgus> hallo
07:59:38 <quicksilver> > map (chr.(subtract 2).ord) "jgnnq\"Gngogpv36"
07:59:39 <lambdabot>  "hello Element14"
08:01:41 <esteban3> > map (chr.(subtract 2).ord) "jgnnq\"Gngogpv36"
08:01:41 <lambdabot>  "hello Element14"
08:01:46 <esteban3> huh?
08:01:57 <Element14> hi lambdabot
08:02:03 <esteban3> ah, i figured it out
08:02:08 <gwern> @index liftIO
08:02:09 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
08:18:55 <aFlag> I have X11 installed with --user, how do I unregister it in order to install newer X11?
08:22:26 <sorear> aFlag: Why bother?  Cabal was designed to support multiple versions of one package.  Are you saying it doesn't work?  If so, complain to dcoutts!
08:26:06 <aFlag> hm
08:26:10 <aFlag> good then :)
09:32:08 <ihadgentoo> does my pupil size matter? and does grammar matter? if so how much (grammar)?
09:32:29 <benny> the pupil has to the same size as the other pupils, or the children will mock him
09:33:17 <Heffalump> ihadgentoo/benny: huh?
09:33:49 <benny> Heffalump: sorry, I thought it was so random I had to be random too
09:35:10 <mauke> <GumbyBRAIN> A coma is a detailed microsoft project plan that is a common substring of the duck in the installer configuration.
09:37:32 <lament> seems Haskell was too much for some people's brains
09:38:42 <esteban3> i think prolog is more confusing
09:39:01 <lament> but prolog is completely LOGICAL!
09:39:20 <ihadgentoo> any of you know david deangelo allan pease (tv show 1987) ? and what is your opinion about him? thank you
09:39:38 <oerjan> > ("BR"++).(++"INS! ").(`replicate`"A")$[1..]
09:39:42 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
09:39:49 <oerjan> > ("BR"++).(++"INS! ").(`replicate`'A')$[1..]
09:39:50 <lambdabot>  Couldn't match expected type `Int' against inferred type `[a]'
09:39:57 <oerjan> sheesh
09:39:57 <mar77a> infix functions must have 2 arguments, right?
09:40:33 <oerjan> mar77a: they can have more
09:40:40 <mar77a> and how would that work?
09:40:57 <oerjan> currying
09:41:14 <idnar> oerjan: you can't actually call such a function in infix style though
09:41:16 <idnar> unless I'm missing something
09:41:17 <oerjan> > ("BR"++).(++"INS! ").(`replicate`'A')<$>[1..]
09:41:20 <lambdabot>  ["BRAINS! ","BRAAINS! ","BRAAAINS! ","BRAAAAINS! ","BRAAAAAINS! ","BRAAAAAAI...
09:41:41 <idnar> (a `f` b) c isn't exactly infix
09:42:30 <Toxaris> idnar: and what about   map (a `f` b) [1, 2, 3]
09:42:51 <Toxaris> idnar: i would say it's infix in a sense
09:42:55 <Cale> idnar: sure it is
09:43:11 <Cale> f is applied infix to a and b and then the result is applied to c
09:43:23 <idnar> Cale: I'd call that a function of two arguments then ;)
09:43:38 <Cale> That's what infix operators generally are
09:43:40 <oerjan> > (succ &&& pred) 2
09:43:42 <lambdabot>  (3,1)
09:43:45 <Cale> f is actually a function of three parameters there
09:43:49 <Cale> (at least 3)
09:44:12 <Cale> Infix operators are just functions of two parameters
09:44:13 <idnar> Cale: *shrug* multiple arguments is basically a convenient fiction anyway
09:44:17 <oerjan> > ("BR"++).(++"INS! ").(`replicate`'A')=<<[1..]
09:44:18 <lambdabot>  "BRAINS! BRAAINS! BRAAAINS! BRAAAAINS! BRAAAAAINS! BRAAAAAAINS! BRAAAAAAAINS...
09:44:23 <Cale> Right.
09:44:34 <lament> oerjan: hah
09:44:58 <oerjan> now if i could just learn to get things right on the first try :)
09:45:12 <oerjan> ok, testing in private _might_ also work
09:46:45 <oerjan> lament: also, LOGIC is probably too much for some peoples' brains :)
09:47:20 <quicksilver> > "LOGIC" > "BRAINS"
09:47:21 <lambdabot>  True
09:47:26 <quicksilver> seems so
09:47:42 <mar77a> no
09:47:58 <mar77a> 5 isn't bigger than 6
09:48:00 <mar77a> :o)
09:48:16 <lament> it is now!
09:48:26 <mar77a> oui
09:48:52 <oerjan> > "brains" > "LOGIC" -- a little brain is better than big logic
09:48:54 <lambdabot>  True
09:50:22 <ihadgentoo> i got banned from #ubuntu
09:51:04 <oerjan> ihadgentoo: people _do_ get banned from here too, if they never speak on topic...
09:51:37 <conal> ihadgentoo: what does it take to get banned from #ubuntu?
09:53:52 <lament> i'm guessing that all it takes is a few questions about pupil size and grammar
09:54:06 <ihadgentoo> <conal> just talking weather on topic or not
09:54:18 <newsham> > "small" > "big"
09:54:20 <lambdabot>  True
09:54:31 <lament> which ihadgentoo seems to ask indiscriminately in every channel he's in
09:54:42 <oerjan> ihadgentoo: this is a channel about the programming language haskell
09:54:44 <newsham> so someone decided to try to do a mathematica (in python!) http://www.sagemath.org/
09:55:01 <oerjan> although i _do_ recall someone adding weather reports to lambdabot recently :)
09:55:22 <newsham> google does weather.  its too bad you cant access it from ?google
09:55:51 <quicksilver> @go weather in berlin
09:55:53 <lambdabot> http://www.weather.com/outlook/travel/businesstraveler/local/GMXX0007?from=search_city
09:55:53 <lambdabot> Title: Berlin Weather Forecast and Conditions Berlin
09:56:08 <quicksilver> yeah, it doesn't parse the celver bit at the top
09:56:16 <newsham> celver?
09:56:26 <lament> newsham doesn't even parse "celver" :)
09:56:32 <lament> (google does)
09:56:42 <newsham> is celver a word I dont know or a typo?
09:56:56 <mar77a> i suspect he mean clever
09:56:59 <mar77a> meant
09:57:14 <newsham> aww, I was hoping i'd get to learn a cool new word
09:57:21 <oerjan> you have to be celver to understand it
09:57:27 <esteban3> ...
09:57:58 <oerjan> @list weather
09:57:58 <lambdabot> No module "weather" loaded
10:09:52 <roconnor> @bab nl en borg
10:09:53 <lambdabot>   guarantor
10:10:10 <oerjan> o_O
10:10:30 <mauke> @bab de en borgen
10:10:31 <lambdabot>   borrow
10:11:37 <roconnor> @bab nl en borgen
10:11:38 <lambdabot>   to secure
10:11:55 <mauke> @bab de en bergen
10:11:56 <lambdabot>   save
10:12:23 <roconnor> @bab nl en bergen
10:12:24 <lambdabot>   to store
10:13:06 <Botje> "bergen" means "to salvage" in dutch, actually
10:13:27 <roconnor> Botje: and borgen?
10:13:33 <ricky_clarkson> @bab es en grabacin
10:13:34 <lambdabot>   grabacin
10:13:55 <ricky_clarkson> "recording".  I find it funny that recording sounds like grabbing in Spanish.
10:14:15 <mauke> @bab en de recorder
10:14:16 <lambdabot>   Recorder
10:14:17 <Botje> vandale.nl tells me it means "to secure", as @bab says
10:14:53 <qweqwe> http://pastebin.com/m7d1dd44f
10:15:01 <qweqwe> can someone help me with that ?
10:15:38 <oerjan> qweqwe: need parentheses
10:16:07 <oerjan> ((a,b):xs)
10:16:29 <qweqwe> hanks
10:16:31 <qweqwe> t
10:17:43 <qweqwe> but i now problem with the \n there
10:18:01 <Botje> ++ appends two lists
10:18:13 <oerjan> "\n" not '\n'
10:18:14 <Botje> so use "\n" (:: String) instead of '\n' (:: Char)
10:18:26 <qweqwe> ok thanks
10:18:30 <oerjan> or use '\n' : instead of '\n' ++
10:19:21 <oerjan> : prepends just one element
10:20:29 <qweqwe> is it possible there make some const that will has in it the length of original list ?
10:20:37 <roconnor> @go 1 USD in CAD
10:20:38 <lambdabot> 1 U.S. dollar = 1.01340019 Canadian dollars
10:20:53 <roconnor> @go 1 CAD in USD
10:20:53 <lambdabot> 1 Canadian dollar = 0.986777 U.S. dollars
10:20:57 <Botje> qweqwe: a "const" ?
10:21:02 <Botje> @go 1 EUR in USD
10:21:03 <lambdabot> 1 Euro = 1.4601 U.S. dollars
10:21:06 <qweqwe> yep
10:21:34 <Botje> qweqwe: you can use length somelist to get the length, yes
10:21:49 <mauke> const as in a -> b -> a?
10:22:09 <vininim> @go 1 USD in BRR
10:22:10 <lambdabot> http://sheila.nomadlife.org/2006/11/brr-its-cold.aspx
10:22:10 <lambdabot> Title: Live, from the field: Brr, It's Cold!
10:22:25 <Botje> lol :)
10:22:28 <qweqwe> but it recorsion and i want to know the length of the original list
10:22:41 <Botje> qweqwe: you need to do that before you start looping through the list.
10:22:54 <qweqwe> ok like i thought
10:22:56 <qweqwe> thanks
10:22:57 <oerjan> qweqwe: you may want to use a helper function in a where clause
10:25:52 <oerjan> @bot
10:25:52 <lambdabot> :)
10:28:17 <Orphi> @vixen hello
10:28:17 <lambdabot> hi
10:28:49 <qweqwe> @bot
10:28:49 <lambdabot> :)
10:28:54 <qweqwe> funny
10:28:59 <mar77a> @sex
10:29:00 <lambdabot> Maybe you meant: let seen src thx
10:29:07 <Orphi> lol!
10:29:10 <mar77a> @lol
10:29:10 <lambdabot> Maybe you meant: let pl url yow
10:29:10 <Botje> BUTTSECKS
10:29:15 <Botje> I mean botsex.
10:29:17 <Saizan> @thx
10:29:17 <lambdabot> you are welcome
10:29:31 <Brian`> @genius
10:29:31 <lambdabot> Unknown command, try @list
10:29:41 <ricky_clarkson> @bab aol en ppl r u ok
10:29:41 <lambdabot> Plugin `babel' failed with: Error: Language aol not supported
10:29:56 <Orphi> @seen dcoutts
10:29:57 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-overflow, #haskell and #ghc. I last heard dcoutts speak 29m 44s ago.
10:30:05 <dcoutts> @arr!
10:30:05 <lambdabot> Swab the deck!
10:30:12 <Orphi> lol! works every time...
10:30:12 <dcoutts> hia Orphi
10:30:20 <Orphi> hi duncan
10:30:21 * dcoutts grins
10:30:35 <Orphi> OOC, which part of the world are you in anyway?
10:31:55 <Orphi> dcoutts: I've written a small layer over Gtk2hs which enables me to (easily) work with bitmapped images.
10:32:10 <dcoutts> Orphi: .uk
10:32:18 <dcoutts> Orphi: sounds nice
10:32:41 <Orphi> dcoutts: I can read/write pixels, and I can load/save images, and that all works fine.
10:32:56 <Orphi> dcoutts: any thoughts on how to make it *display* images?
10:33:34 <dcoutts> Orphi: sure, there are functions for copying from a bitmap to a surface
10:34:13 <Orphi> dcoutts: do I want to open a window and copy the image to it every time there's a damage message?
10:34:21 <dcoutts> Orphi: X and Gtk call them Drawables, there are on screen ones DrawWindows and off scree ones Pixmaps
10:34:24 <Orphi> dcoutts: or is there some kind of an "image widget" I can use that will do it for me?
10:35:10 <filcab42> hi
10:35:36 <conal> welcome filcab42
10:35:48 <dcoutts> Orphi: I was initially confused between Pixmaps and Pixbuf, Pixmap is a graphics card / X windows / server side resource. A Pixbuf is the bitmap in your address space that you can modify directly.
10:35:58 <dcoutts> Orphi: yes, there is a Image widget
10:36:01 <filcab42> What's the best way to create an array of integers from a file?
10:36:11 <filcab42> I have a file with lines like: '1 2 3 4 5'
10:36:38 <mauke> map read . words
10:37:10 <oerjan> or even map (map read . words) . lines
10:37:12 * Orphi checks code
10:37:16 <filcab42> and stuff. Now I'm creating a list of lines, then a list of words per line, then 'read' ing
10:37:20 <filcab42> but I think I'm slowing the problem there :s
10:37:36 <dcoutts> Orphi: there are a couple demos in the gtk2hs demo collection that use bitmaps and display them on screen
10:37:59 <Orphi> dcoutts: my code uses a Pixbuf currently.
10:38:46 <Orphi> dcoutts: so presumably there's no way to make it so that when I draw on that, it appears on the screen. I need to explicitly paint it.
10:38:52 <filcab42> I need an array because I'm doing dynamic programming after that. Reading a list would be slow (even optimizing through lazy evaluation)
10:39:31 <dcoutts> Orphi: correct.
10:39:35 <conal> filcab42: maybe the list will get fused away
10:39:40 <oerjan> filcab42: to make an array you need to know the size
10:39:58 <filcab42> sorry, I know the size
10:40:05 <dcoutts> Orphi: so if you're doing animation then you want to use something like what the FastDraw demo does
10:40:15 <oerjan> then i think it should fuse
10:40:20 <Orphi> dcoutts: right, ok...
10:40:23 <dcoutts> Orphi: if it's a static image once you've finished drawing it then just use imageSetFromPixbuf
10:40:23 * Orphi checks more code
10:40:40 <Orphi> dcoutts: OK, well that covers one common case.
10:40:41 <filcab42> it's a squared array of integers (in fact, they're Int32) and I know the size
10:40:43 <filcab42> what do you mean by fusing?
10:40:54 <dcoutts> Orphi: or nicer: set image [ imagePixbuf := pixbuf ]
10:41:00 <oerjan> optimizing away the intermediate list
10:41:15 <filcab42> oh, right
10:41:41 <Orphi> grr... Firefox doesn't know how to handle the MIME type for Haskell files :-S
10:44:29 <oerjan> Orphi: googling on haskell.org brought up this discussion: http://www.haskell.org/pipermail/haskell-cafe/2007-October/033751.html
10:44:31 <lambdabot> Title: [Haskell-cafe] viewing HS files in Firefox, http://tinyurl.com/2mnfg7
10:44:54 <Orphi> dcoutts: right, so use a DrawingArea and manually paint on my image whenever I want to see it. (?)
10:45:25 <dcoutts> Orphi: if you're doing high frequency animation then that's the best way to go
10:45:40 <Orphi> dcoutts: actually I'm doing compute-bounded rendering, but yeah. ;-)
10:45:50 <dcoutts> Orphi: if it's low frequency of updates then using an Image is probably easier
10:45:51 <Orphi> dcoutts: does DrawingArea handle damage repair itself?
10:46:09 <dcoutts> Orphi: no, you have to respond to the expose event, see the demo
10:46:18 <dcoutts> Orphi: sounds like you might prefer the Image method
10:46:29 <Orphi> dcoutts: does Image repair? (I'm guessing yes?)
10:46:35 <dcoutts> yep
10:46:54 <Orphi> ok... so it looks like Image is more appropriate for "finished" images, and a DrawWindow for stuff while it's drawing.
10:46:54 <dcoutts> Orphi: ie each time you want to update the image just calculate a new Pixbuf and assign it to the Image
10:47:01 <dcoutts> right
10:47:15 <dcoutts> but if you're doing the latter then that suffices for the former too
10:47:47 <dcoutts> the only saving in effort is if you are only using occasionally changing images, not rapid animation
10:48:21 <ricky_clarkson> It looks like one cannot define (+) on a type to work with foreign types.  Does this have negative consequences?
10:48:34 <dfranke_> data Bar = forall a. Bar (Foo) -- Is there any good reason this can't be a newtype instead of data, or is it just a limitation of GHC?
10:48:38 <dfranke_> err
10:48:39 <Orphi> well, I'm trying to write a library so that in future I can easily do imaging stuff without having to look up the Gtk2hs API every time ;)
10:48:39 <ricky_clarkson> E.g., you can't define your own Distance type and have aDouble*aDistance.
10:48:42 <dfranke_> data Bar = forall a. Bar (Foo a) -- Is there any good reason this can't be a newtype instead of data, or is it just a limitation of GHC?
10:49:08 <dcoutts> ricky_clarkson: right, (*) requires both args to be of the same type
10:49:21 <ricky_clarkson> Is this a good thing?
10:49:26 <dcoutts> ricky_clarkson: so you cannot multiply a vector by a scalar for example
10:49:47 <Orphi> or multiply a tensor by a colour...
10:49:54 <ricky_clarkson> I can see that it makes using (*) as a value possible/easy.
10:49:55 <dcoutts> ricky_clarkson: it means the types are never ambiguous like they would be quite often if the args and result could be of different types
10:50:37 <Orphi> dcoutts: what's the story with GTK and threading?
10:50:44 <ricky_clarkson> I suppose if (*) could be of a -> b -> c, you'd need to qualify it to use it as a value, e.g.: (*)::Double -> Distance -> Distance
10:51:16 <oerjan> dfranke_: i guess if there are no class constraints on the a, it should be possible...
10:51:38 <ricky_clarkson> dcoutts: I'm not sure how the types could be ambiguous - you'd just have to add explicit types as above, or have I missed something?
10:51:41 <dcoutts> Orphi: if you use the single threaded ghc rts then the story is simple, if you use the -threaded rts then you have to be very very careful
10:52:13 <dcoutts> ricky_clarkson: right, you'd have to use explicit type annotations a lot, not just when you're using them at different types but also in the common case, a + 1
10:52:22 <dcoutts> a + (1 :: Int)
10:52:33 <dcoutts> it'd be really annoying
10:52:33 <ricky_clarkson> Gotcha, thanks.
10:52:37 <Orphi> dcoutts: will doing compute-bounded stuff in the main thread prevent the UI from responding to events?
10:52:43 <dcoutts> Orphi: yes
10:52:54 <Orphi> dcoutts: right. this would be Bad.
10:53:05 <Orphi> dcoutts: I'd like the "Stop" button to make the program... stop. ;)
10:53:13 <oerjan> dfranke_: otoh you would then be unable to use the a part in any way other than passing it
10:53:21 <dcoutts> Orphi: so you can use threads or you can use idle handlers, threads are easier.
10:53:36 <ricky_clarkson> dcoutts: What's the usual workaround when you actually want *?  Define your own unrelated operator name?
10:53:57 <dcoutts> ricky_clarkson: yep, or just a function name, desn't always have to be an operator
10:53:58 <dfranke_> oerjan: heh... actually that's not true :-).  I'll post the code snippet in a moment.
10:54:02 <ddarius> ricky_clarkson: That's the -usual- approach, e.g. .* for Double -> Vector -> Vector
10:54:17 <Orphi> dcoutts: so presumably event handles always run in the right thread. if I run my main computation in a different thread, that should work?
10:54:27 <ricky_clarkson> Cheers.
10:54:29 <dcoutts> Orphi: yes.
10:54:47 <Orphi> dcoutts: so I just need to make sure I do all the GTK stuff from the main thread?
10:55:15 <dcoutts> Orphi: if you use the normal single threaded rts then you can do anything from any haskell thread
10:55:38 <Orphi> dcoutts: I'm likely to use the multithreaded RTS - this stuff is SLOW and I have a dual-core CPU ;)
10:55:40 <dcoutts> Orphi: it's only with the -threaded rts that you have to be so careful since it can migrate haskell threads onto other OS threads
10:55:40 <oerjan> dfranke_: oh, i guess the Foo type could contain the necessary ingredients
10:56:27 <dcoutts> Orphi: ok, so in the latter case you do have to ensure that gui stuff is only done in the main thread, using postSync or postASync
10:56:32 <dfranke_> oerjan: not exactly... one sec.  This is proprietary code so I just need to put together a sanitized example.
10:57:05 <dcoutts> Orphi: that posts the gui action to the gui thread
10:57:09 <Orphi> dcoutts: well, all the main thread needs to do is spawn the computation thread, and periodically display the output. and handle any GUI events.
10:57:51 <Orphi> dcoutts: is it OK to write to the buffer returned by pixbufGetPixels from multiple threads?
10:58:04 <ricky_clarkson> In http://haskell.org/haskellwiki/Introduction_to_QuickCheck they split up the side-effecting code from the pure code and test the pure code separately with QuickCheck.
10:58:18 <ricky_clarkson> How would they test the side-effecting code?
10:58:32 <dcoutts> Orphi: yes, if you can guarantee they don't do it at the same time, or if you don't worry about them stepping on each others toes
10:58:53 <Orphi> dcoutts: I'm thinking each thread renders a different square.
10:59:19 <Orphi> dcoutts: I just need to make sure I only try to draw it to the screen from the main thread. ;)
10:59:26 <jelousbuddy> i have a unpleasant feeling in my eye!! why do i see light when i open my eyes? am i giving out light and effecting or harming anyone?
10:59:39 <dcoutts> Orphi: you may prefer to allocate separate bitmaps just to ensure the threads don't end up thrashing cache lines
11:00:10 <Orphi> dcoutts: care to explain that one? how would seperate bitmaps make this better?
11:00:21 <dcoutts> Orphi: so all events will happen in the main thread, so you only need to worry about gui calls you do in your computation threads, those have to be posted to the main thread
11:00:51 <dcoutts> Orphi: you know that if two cpu cores try to write to the same 64byte cache line then it's really slow
11:01:05 <Orphi> dcoutts: that's news. :|
11:01:08 <dcoutts> Orphi: as they keep stealing the cache line into their own private L1 cache
11:01:35 <ricky_clarkson> I've just been reading SICP again, and the bit about non-deterministic computing (where an expression can have more than one value, and invalid values get filtered out as you go) seemed quite interesting.
11:01:56 <ricky_clarkson> I can see how you'd do that with lists in Haskell, but I wondered if Haskell has a more natural way of playing with that stuff.
11:02:05 <dcoutts> Orphi: well, it's slow if they try and do it frequently over a short period, as each core has to have exclusive access to the cache line it's writing into
11:02:20 <Orphi> dcoutts: ouch. :S
11:02:25 <dcoutts> Orphi: so tiling is a good idea but make sure the tiles do not cross cache lines
11:02:30 <byorgey> ricky_clarkson: the list monad seems like a pretty natural way to do that sort of thing.
11:02:35 <conal> ricky_clarkson: probably the prettiest it'll get in haskell is using Applicative with lists.
11:02:46 <Orphi> dcoutts: haha, not that you can see cache line edges from a high level language such as Haskell...
11:02:46 <conal> note Applicative rather than Monad
11:02:51 <byorgey> gasp! indeed.
11:02:53 <dcoutts> Orphi: and the easiest way to do that would be to allocate separate Pixbufs for each tile and then combine them at the end.
11:03:05 <Orphi> dcoutts: OK, I'll try that.
11:03:06 <byorgey> conal, I am ashamed =)
11:03:24 <ricky_clarkson> conal: Thanks, I'll look into that.
11:03:28 <conal> lol
11:03:30 <Orphi> dcoutts: as far as threading goes, all I want is for the display to update itself every X seconds with the currently generated image.
11:03:55 <Orphi> dcoutts: presumably I can just make main sleep for X seconds, paint the display, and recurse... never need to talk to GTK from any other thread.
11:04:03 <dcoutts> Orphi: then use a timeout handler in the main thread that invalidates the image widget
11:04:08 <conal> ricky_clarkson: teaser (<*>) applies a nondeterministic function to a nondeterministic argument.
11:04:18 <ricky_clarkson> :t (<*>)
11:04:20 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
11:04:27 <dcoutts> Orphi: never paint anything to the screen directly except in a expose event handler
11:04:38 <conal> ricky_clarkson: and usually the nondeterministic function will itself come from a partial function application.
11:04:42 <Orphi> dcoutts: right. OK. how do I set up a timeout handler?
11:04:52 <dcoutts> Orphi: timeoutAdd, it's in the docs
11:04:56 <ricky_clarkson> Heh.
11:04:58 <ricky_clarkson> @instances-importing Applicative
11:04:59 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
11:05:04 <dcoutts> Orphi: and in several demos, like the cairo clock demo
11:05:15 <EvilTerran> @instances-importing Control.Applicative Applicative
11:05:16 <conal> > pure (*) <*> [1..3] <*> [6..8]
11:05:16 <lambdabot> ((,) a), ((->) a), Const m, IO, Maybe, WrappedArrow a b, WrappedMonad m, ZipList, []
11:05:17 <lambdabot> Terminated
11:05:31 <jelousbuddy> what does  4077.982 FPS mean?
11:05:47 <conal> or, equivalently, liftA2 (*) [1..3] [6..8]
11:05:53 <ricky_clarkson> > Just <*> 5
11:06:04 <lambdabot>  Couldn't match expected type `a -> b'
11:06:11 <ricky_clarkson> > Just <*> id
11:06:12 <conal> pure Just <*> 5
11:06:14 <lambdabot>  Couldn't match expected type `a -> b'
11:06:26 <conal> > pure Just <*> 5
11:06:28 <lambdabot> Terminated
11:06:48 <ricky_clarkson> > Just <*> chr
11:06:49 <lambdabot>  Couldn't match expected type `a -> b'
11:06:55 <ricky_clarkson> @hoogle a -> b
11:06:56 <Orphi> damn, I need a search function for the GTK API :S
11:06:56 <lambdabot> Unsafe.Coerce.unsafeCoerce :: a -> b
11:06:56 <lambdabot> Data.Generics.Aliases.unGM :: GenericM' m -> Data a => a -> m a
11:06:56 <lambdabot> Control.Monad.Error.Class.throwError :: MonadError e m => e -> m a
11:07:03 <conal> > pure Just <*> pure 5
11:07:04 <lambdabot> Terminated
11:07:07 <conal> ??
11:07:10 <ricky_clarkson> :t pure
11:07:10 <roconnor> Orphi: there is one
11:07:11 <lambdabot>     Ambiguous occurrence `pure'
11:07:11 <lambdabot>     It could refer to either `pure', imported from Control.Applicative
11:07:11 <lambdabot>                           or `pure', imported from Control.Arrow
11:07:20 <ricky_clarkson> :t Control.Applicative.pure
11:07:21 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
11:07:28 <roconnor> Orphi: for gtk2hs at least
11:07:41 <ricky_clarkson> @src Control.Applicative.pure
11:07:42 <lambdabot> Source not found. That's something I cannot allow to happen.
11:07:44 <conal> :t (<$>)
11:07:45 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:07:48 <ricky_clarkson> Is pure like id?
11:07:59 <dcoutts> Orphi: there was a hoogle for gtk2hs but the recent hoogle update broke it unfortunately
11:08:04 <conal> ricky_clarkson: for lists, pure = (:[])
11:08:24 <dcoutts> @tell ndm how do I get gtk2hs's hoogle working again?
11:08:25 <lambdabot> Consider it noted.
11:08:26 <Orphi> well, I found it now. It's in Graphics.UI.Gtk.General. heh.
11:08:31 <ricky_clarkson> Isn't that newsham's smiley?
11:08:32 <conal> > pure Just <*> pure 5 :: [Maybe Int]
11:08:33 <lambdabot> Terminated
11:08:39 <jelousbuddy> i ran glxgear and it gave me that, so does video driver effect fps?
11:10:04 <Orphi> dcoutts: OK, that's nice... so what unit is the time delay in? :P
11:10:19 <dcoutts> Orphi: milliseconds I think
11:10:23 <oerjan> > pure
11:10:23 <lambdabot> Terminated
11:10:29 <Orphi> dcoutts: maybe add this to the documentation? ;)
11:11:08 <Orphi> I wonder... the GTK docs might tell me...
11:11:12 <oerjan> iirc lambdabot seems to respond with Terminated to ambiguous imports
11:11:20 <jelousbuddy> if i have 4877.982 FPS why do i get broken video's sometimes on xvid movies?
11:11:36 <jedbrown> > Just <$> Control.Applicative.pure 5 :: [Maybe Int]
11:11:37 <lambdabot>  [Just 5]
11:11:54 <sorear> jelousbuddy: because it takes a lot more cpu power to run an IDCT than to draw a few polygons
11:12:01 <dcoutts> Orphi: mm, good point
11:12:18 <Orphi> dcoutts: ;) it's always useful to know these things.
11:12:26 <dcoutts> indeed
11:12:48 <Orphi> dcoutts: yes, it's milliseconds. just checked GTK+ docs
11:13:01 <Orphi> http://library.gnome.org/devel/gtk/unstable/gtk-General.html#gtk-timeout-add
11:13:01 <jelousbuddy> sorear> what is idct?
11:13:01 <lambdabot> Title: Main loop and Events, http://tinyurl.com/24r9oj
11:13:08 <dfranke_> oerjan: http://hpaste.org/4336
11:15:02 <sorear> @go idct
11:15:04 <lambdabot> http://rnvs.informatik.tu-chemnitz.de/~jan/MPEG/HTML/IDCT.html
11:15:04 <lambdabot> Title: IDCT
11:15:14 <sorear> @go discrete cosine transform
11:15:15 <lambdabot> http://en.wikipedia.org/wiki/Discrete_cosine_transform
11:15:15 <lambdabot> Title: Discrete cosine transform - Wikipedia, the free encyclopedia
11:15:16 <filcab42> How can I make a type class "derivable"?
11:15:33 <oerjan> dfranke_: clever
11:15:35 <filcab42> and how does ghc implement == if I derive from Eq?
11:15:41 <oerjan> and with data it works?
11:15:43 <filcab42> (Hi all :$ sorry)
11:15:47 <sorear> filcab42: send a message to haskell-prime@haskell.org
11:15:59 <dfranke_> oerjan: yup
11:15:59 <filcab42> ?
11:16:05 <ricky_clarkson> filcab42: You define that.
11:16:26 <filcab42> sorear: I wanted to know how ghc derives it so I knew what the semantics is
11:16:41 <sorear> filcab42: it's a Haskell thing, it's in the Report
11:16:45 <filcab42> ricky_clarkson: I define what? If a class is derivable? can't find out how :s
11:16:51 <oerjan> dfranke_: although in this case it seems you could simply merge TypeInstance and TIWrap
11:17:19 <ricky_clarkson> filcab42: With an instance declaration.
11:17:27 <quicksilver> filcab42: derivings are all special cases
11:17:31 <sorear> filcab42: you make a class derivable by sending an e-mail to haskell-prime@haskell.org and petitioning for your class to be added to the list in the next version of the language standard
11:17:34 <ricky_clarkson> instance YourType of Eq or something, I forget the syntax.
11:17:36 <quicksilver> filcab42: the Eq deriving is the natural thing on ADTs.
11:17:38 <Toxaris> filcab42: I don't think you can add "derivable" classes to the language
11:17:44 <filcab42> oh, right
11:17:52 <filcab42> it's not extensible, then
11:17:54 <quicksilver> right
11:18:00 <quicksilver> there are metaprogramming tools, though
11:18:04 <quicksilver> like Data.Derive
11:18:11 <dfranke_> oerjan: right.  In the real code it's helpful to have them separate.
11:18:26 <filcab42> thanks
11:18:26 <filcab42> ricky_clarkson: That's how you use, not how it works ;)
11:18:34 <Toxaris> filcab42: derived EQ-instances compare constructors and call (==) recursively on fields
11:18:50 <ricky_clarkson> filcab42: Fair enough.
11:18:51 <filcab42> thanks
11:19:28 <sorear> filcab42: you could have found this for yourself in the Report.  http://haskell.org/onlinereport
11:19:35 * Orphi thinks about the design possibilities
11:20:11 <fasta> Report, that has a biblical sense to it. :P
11:20:24 <fasta> The Book of Truth.
11:20:48 <dfranke_> oerjan: and now it's time for me to learn TH, because the real ForeignType has 30 constructors and I'm going to get COBOL fingers if I have to write the entire definition of extractValues by hand.
11:21:11 * Orphi suffers analysis paralysis
11:21:13 <fasta> dfranke_: that sounds as a blog post in the making.
11:21:18 <oerjan> dfranke_: i guess you could post a feature request for ghc
11:21:33 <oerjan> of course that will not help right now
11:21:48 <dfranke_> oerjan: what feature would I be requesting?
11:22:03 <fasta> dfranke_: a workable version of TH?
11:22:13 <oerjan> that newtype can have forall a.  if a has no class restriction
11:23:13 <oerjan> (still on your previous issue :) )
11:23:32 <dfranke_> ah, yes.  Perhaps I'll request that.
11:23:47 <Orphi> hmm. my head hurts!
11:25:55 * Orphi has an idea
11:26:56 <dcoutts> stand back, Orphi's head's going to blow!
11:27:32 <byorgey> @index comparing
11:27:32 <lambdabot> bzzt
11:28:04 <oerjan> byorgey: Data.Ord i think
11:28:11 <byorgey> oerjan: thanks
11:30:02 * Orphi head blows
11:30:17 <dcoutts> noo!
11:30:23 <oerjan> > ("BR"++).(++"INS! ").(`replicate`'A')=<<[1..]
11:30:25 <lambdabot>  "BRAINS! BRAAINS! BRAAAINS! BRAAAAINS! BRAAAAAINS! BRAAAAAAINS! BRAAAAAAAINS...
11:30:35 <dcoutts> Orphi: have a cup of tea, that always helps :-)
11:30:49 <Orphi> muth gabidoall withwaa nitheb nithembith; maf mana mishon meaf meow fwor!
11:31:32 <quicksilver> mmm tea
11:32:25 <ricky_clarkson> > ("ref"++).(++"ee! ").(`replicate` "er")=<<[1..]
11:32:25 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
11:32:34 <Orphi> http://icanhascheezburger.com/2007/11/27/zombie-kiteh-want-brainz/
11:32:35 <lambdabot> Title: zombie kiteh want brainz  Lolcats &#8216;n&#8217; Funny Pictures - I Can Has Ch ..., http://tinyurl.com/36xc3d
11:33:18 <oerjan> > ("ref"++).(++"ee! ")=<<(`replicate` "er")=<<[1..]
11:33:19 <lambdabot>  "referee! referee! referee! referee! referee! referee! referee! referee! ref...
11:33:41 <oerjan> oops
11:34:59 <magnusth> all right, I feel a little daft, this may be a stupid question, but what's the Cont monad actually good for in Haskell?
11:35:38 * Orphi starts coding
11:35:48 <oerjan> > ("ref"++).(++"ee! ").concat.(`replicate` "er")=<<[1..]
11:35:49 <lambdabot>  "referee! refereree! referereree! refererereree! referererereree! refererere...
11:36:03 <ddarius> magnusth: Continuations
11:36:16 <jelousbuddy> is daylight too bright? and does light have any pushing force like sunlight , lamp, or computer LCD/ screen light?
11:36:19 <oerjan> there must be something better than using concat there...
11:36:24 <magnusth> ddarius, yes, I know, but besides callCC, what is the Cont monad useful for?
11:36:48 <ddarius> magnusth: Anything callCC is useful for, which is quite a lot of stuff.
11:37:07 <int-e> > ("ref"++).(++"ee! ")=<<tail(iterate("er"++)"")
11:37:08 <lambdabot>  "referee! refereree! referereree! refererereree! referererereree! refererere...
11:37:15 <int-e> oerjan: better?
11:37:21 <oerjan> indeed
11:37:27 <int-e> actually
11:37:28 <magnusth> ddarius, again, yes, but is that all?  does it only exist for callCC?
11:37:44 <Cale> magnusth: callCC is the only method of MonadCont
11:37:52 <int-e> > ("ref"++)=<<iterate("er"++)"eree! "
11:37:52 <lambdabot>  "referee! refereree! referereree! refererereree! referererereree! refererere...
11:38:04 <Cale> @src MonadCont
11:38:04 <lambdabot> class (Monad m) => MonadCont m where
11:38:04 <lambdabot>     callCC :: ((a -> m b) -> m a) -> m a
11:38:17 <Cale> So in a sense, yes, that's the only point
11:38:34 <Cale> callCC gives you pretty sophisticated control flow mechanisms though.
11:38:35 <magnusth> Cale, but Cont is itself a monad
11:38:42 <magnusth> @src Cont
11:38:42 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
11:38:52 <Cale> Sure, it's in some sense the "smallest" monad which supports callCC
11:38:53 <qweqwe> instance (Show a) => Show RedBlackTree value key where
11:38:53 <qweqwe> show = printme
11:39:10 <quicksilver> @src Cont CallCC
11:39:10 <lambdabot> Source not found. My mind is going. I can feel it.
11:39:16 <jelousbuddy> simonrvn> is half life 2 a good game(educational?) and can be run in Debian?
11:39:20 <quicksilver> @src CallCC Cont
11:39:20 <lambdabot> Source not found. My pet ferret can type better than you!
11:39:26 <ddarius> callCC
11:39:38 <quicksilver> @src Cont callCC
11:39:39 <lambdabot> callCC f = Cont $ \c -> runCont (f (\a -> Cont $ \_ -> c a)) c
11:39:41 <quicksilver> thanks :)
11:39:54 <Cale> jelousbuddy: wrong channel/
11:39:55 <Cale> ?
11:40:06 <quicksilver> Cale: he's one of these weird markov chain / AI bots
11:40:15 <quicksilver> Cale: not entirely sure what the point is...
11:40:30 <magnusth> Cale, ok, so when I read about things like failure continuations I shouldn't think that Cont can handle that somehow?
11:40:30 <Cale> Who is running it?
11:40:32 <clanehin> Seems like it was saying something that seemed innapropriate last night.
11:40:32 <qweqwe> http://pastebin.com/m75234cfc
11:40:43 <qweqwe> can you help me with that error
11:41:19 <quicksilver> qweqwe: I think you mean Show (RedBlackTree value key)
11:41:28 <qweqwe> ok now i get Ambiguous type variable "a
11:41:36 <oerjan> qweqwe: yep, you are not using a
11:41:36 <quicksilver> qweqwe: yeah, I don't know what that (Show a) bit is
11:41:40 <quicksilver> it doesn't look relevant
11:41:46 <qweqwe> sec
11:41:48 <quicksilver> possibly you want (Show key, Show value) =>
11:41:49 <jelousbuddy> what is trolling? and when ops kick+ban me they say "mentor sets ban on *!*@CPE363d96b503e0-CM00194757ed42.cpe.net.cable.rogers.comYou have been kicked from #debian by mentor (mentor)"what does it mean?
11:41:53 <quicksilver> but I don't know
11:42:03 <Botje> *sigh*
11:42:10 --- mode: ChanServ set +o Cale
11:42:16 <byorgey> it means... this.
11:42:19 --- kick: jelousbuddy was kicked by Cale (Cale)
11:42:20 <quicksilver> because I don't see the source for 'printme'
11:42:23 <Japsu> lol
11:42:29 <byorgey> booyah!
11:42:34 --- mode: Cale set -o Cale
11:42:37 * oerjan wanted to get the popcorn, but was too late
11:42:47 <quicksilver> but the most natural way to write printme would give rise to a (Show key, Show value) constraint I suspect
11:42:48 <Cale> If it comes back, I'll ban it.
11:43:07 <quicksilver> Cale: it's very odd, I've seen a couple. They don't even seem to have a particular point.
11:43:07 <mar77a> 'it'...also what's with ops-in-disguise?
11:43:09 <BlackMeph> * applauds respectfully
11:43:13 <quicksilver> they don't spam links
11:43:20 <quicksilver> in fact, they don't spam much at all
11:43:25 <quicksilver> just random gibberish rather rarely
11:43:27 <qweqwe> http://pastebin.com/m1bdedb8f
11:43:28 <Cale> qweqwe: looks like you missed some parens in your instance head
11:43:36 <qweqwe> yes
11:43:40 <qweqwe> look at that now
11:43:41 <Cale> Perhaps you wanted  Show (RedBlackTree value key)
11:43:41 <qweqwe> http://pastebin.com/m1bdedb8f
11:43:48 <quicksilver> qweqwe: ah well, you are already deriving Show
11:43:52 <Cale> mar77a: In disguise?
11:43:54 <quicksilver> qweqwe: that's what that error means
11:44:01 <quicksilver> qweqwe: no need to give the instance if you're deriving it
11:44:04 <ddarius> mar77a: I'm pretty sure that's the way freenode works.
11:44:16 <quicksilver> qweqwe: or, if you want to use the instance you provide, don't derive it :)
11:44:19 <mar77a> oh, sorry
11:44:23 <mar77a> im used to quakenet
11:44:25 <quicksilver> not necessarily
11:44:32 <quicksilver> in other freenode channels I see people perma-opped
11:44:34 <Cale> mar77a: You don't leave your +o on, it's just asking for problems. :)
11:44:36 <quicksilver> it's just a social convention
11:44:44 <mar77a> i see
11:44:45 <Cale> and yeah, it's socially bad
11:44:48 <qweqwe> sec i will check it
11:45:07 <Orphi> it's like when I play Team Fortress 2, everybody keeps asking if they can join my clan :S
11:45:08 <ricky_clarkson> Does Haskell have anything like Scala's implicit conversions?
11:45:15 <idnar> being opped the whole time is sort of like waving your police badge around the whole time during a conversation
11:45:25 <dmwit> ricky_clarkson: no
11:45:30 <conal> what's +o and why turn it off?
11:45:31 <quicksilver> ricky_clarkson: you can build stuff like that with type classes
11:45:35 <ricky_clarkson> conal: Operator.
11:45:42 <quicksilver> ricky_clarkson: people often argue that it's not a good idea, though
11:45:52 <dmwit> ricky_clarkson: I've never used Scala, but that doesn't sound like something that interacts well with Haskell's super-strict everything.
11:45:56 <quicksilver> :t (+)
11:45:58 <lambdabot> forall a. (Num a) => a -> a -> a
11:46:02 <conal> something about channel privileges?
11:46:15 <quicksilver> ricky_clarkson: if that type was: (Num a, Num b, Num c) => a -> b -> c
11:46:18 <dmwit> conal: +o is operator status, and you turn it off so people don't bug you. ;-)
11:46:22 <quicksilver> ricky_clarkson: then that would be something like implicit conversions
11:46:30 <quicksilver> or you could make other choices, like 'convert to left'
11:46:33 <quicksilver> a -> b -> a
11:46:35 <conal> dmwit: and why would they bug you?
11:46:40 <ricky_clarkson> dmwit: I don't think it affects the type system, as it's just a step in inference.
11:47:29 <quicksilver> :t let a +++ b = (realToFrac a) + (realToFrac b) in (+++)
11:47:30 <lambdabot> forall a a1 b. (Real a, Real a1, Fractional b) => a -> a1 -> b
11:47:34 <qweqwe> http://pastebin.com/m261988c2
11:47:37 <quicksilver> ricky_clarkson: for example, like that.
11:47:38 <conal> i.e., why do people get annoyed when someone leaves +o on?
11:47:54 <ricky_clarkson> quicksilver: Thanks.
11:47:59 * conal doesn't know much about IRC
11:48:01 <quicksilver> but, there are reasons not to like it
11:48:05 <allbery_b> it's cultural.  I'm in a channel on Cognet where it's normal for folks to have ops
11:48:07 <quicksilver> someone put together an EasyNum class
11:48:11 <quicksilver> along those lines
11:48:17 <quicksilver> I don't recally the exact name
11:48:19 <ricky_clarkson> conal: Because it continuously shows authority, which on IRC is often arbitrary.
11:48:20 <dmwit> (+) `on` realToFrac
11:48:40 <LoganCapaldo> I think not having ops all the time maes it more dramatic
11:48:40 <ricky_clarkson> E.g., if a normal user says "I don't think this is relevant" it seems less threatening than when an op does it.
11:48:45 <conal> ricky_clarkson: thanks.
11:48:52 <LoganCapaldo> clark kent diving into a phone booth thing sort of deal
11:48:55 <ari> :t (+) `on` realToFrac
11:48:55 <lambdabot> Not in scope: `on'
11:49:00 <allbery_b> (but then we're all sysadmins, so in some sense we'r all "ops" anyway)
11:49:00 <qweqwe> i did what you say and got tht thing http://pastebin.com/m261988c2
11:49:06 <LoganCapaldo> or a semi transforming into a giant robot :)
11:49:06 <dmwit> LoganCapaldo: hehe
11:49:08 <oerjan> qweqwe: btw we've got our own pastebin with haskell highlighting and automatic announcements
11:49:14 <oerjan> !paste
11:49:28 <qweqwe> !paste
11:49:33 <ddarius> LoganCapaldo: Usually you find out pretty quickly which people have op, so...
11:49:35 <oerjan> er...
11:49:36 <quicksilver> ricky_clarkson: http://www.haskell.org/pipermail/haskell-cafe/2007-June/027092.html
11:49:37 <lambdabot> Title: [Haskell-cafe] Perl-style numeric type, http://tinyurl.com/ytoxkb
11:49:45 <quicksilver> ricky_clarkson: and following
11:50:01 <allbery_b> hpaste may still be down
11:50:01 <Philippa> conal: if you've got visible ops in a chan this size with few ops then a) everyone expects you do Do Stuff and b) you're "showing off"
11:50:03 <oerjan> i guess announcing doesn't work without hpaste here :(
11:50:03 <quicksilver> here we are a loquacracy!
11:50:03 <mar77a> have you ever gotten complaints from tinyurl?
11:50:10 <quicksilver> or so dons assures me
11:50:18 <Philippa> oh, and c) it can affect how people treat you in arguments because you can (potentially) kick or ban them
11:50:27 <quicksilver> no, tinyurl are happy to have their service used :)
11:50:30 <LoganCapaldo> @wn loquacracy
11:50:30 <lambdabot> No match for "loquacracy".
11:50:34 <oerjan> allbery_b: the site is up
11:50:39 <oerjan> but not the bot
11:50:54 <qweqwe> have you ideas about that show error
11:50:58 <conal> thanks.  now i get it.
11:51:01 <dmwit> LoganCapaldo: People who speak the best are given control, I think.  (Just based on the root syllables.)
11:51:10 * Orphi attempts to compile the code...
11:51:10 <qweqwe>  http://pastebin.com/m261988c2
11:51:23 <quicksilver> qweqwe: now I think it could be an indentation error?
11:51:28 <quicksilver> if that is, indeed, exactly your code
11:51:35 <quicksilver> you need at least one space before 'show = printme'
11:52:25 * Orphi is thwarted
11:52:29 <qweqwe> ok got a new error now
11:52:57 <sorear> at least I can log in now
11:52:59 <quicksilver> Now I guess you do need the (Show value , Show key)
11:53:03 <quicksilver> constraint
11:53:05 <sorear> the connection is still terrible
11:53:11 <_roconnor> I said it before and I'll say it again, why does kpdf take control of my sound device?
11:53:12 <desegnis> qweqwe, probably about IO () and String mismatching?
11:53:14 <sorear> I'm not used to lag on ssh
11:53:16 <quicksilver> since you've now shown me the type of printme
11:53:17 <LoganCapaldo> dmwit: sure it's not just the people who speak the most? <g>
11:53:26 <dmwit> hahaha, it might be =P
11:53:26 <quicksilver> qweqwe: but, on top of that, printme has entirely the wrong type :)
11:53:32 <quicksilver> as desegnis points out before I noticed it
11:53:49 <_roconnor> maybe kpdf think I don't want to be disturbed while reading
11:53:49 <quicksilver> dmwit: speak the most is what I meant, but it was a neologism.
11:54:06 <quicksilver> dmwit: since it was my neologism perhaps I get to choose the meaning :)
11:54:18 <qweqwe> http://pastebin.com/ma2b002b
11:54:23 <qweqwe> the new error
11:54:24 <qweqwe> http://pastebin.com/ma2b002b
11:54:53 <quicksilver> qweqwe: did you read the things desegnis and I said?
11:54:54 <dmwit> The great thing is that it's just one letter away from being a lo"quack"racy.
11:55:04 <quicksilver> qweqwe: because we anticipated that error, too
11:55:12 <dmwit> Give the craziest people the control! =D
11:55:24 <quicksilver> dmwit: no no, give the ducks control!
11:55:26 <oerjan> quicksilver: the only google hit is from this channel :)
11:56:19 <quicksilver> I for one welcome our new duck-like overlords!
11:56:33 <quicksilver> I was hoping for a latinate adjective along the lines of 'equine' for duck-like, but I dont find it
11:56:45 <qweqwe> so i should change the type of printme
11:56:51 <qweqwe> to string
11:56:53 <quicksilver> "anatine", perhaps
11:57:03 <quicksilver> qweqwe: probably yes, but only oyu know what your code is supposed to do
11:57:48 <nolrai> is there a way to use monadic parsers to parse something like
11:57:49 <nolrai> leftList ::= leftList item
11:57:50 <nolrai>                |  empty
11:57:52 <nolrai> ? when I try the naive implementation in parsec I get infinite loops galore.
11:57:56 <quicksilver> oerjan: woo. SEO eat your heart out!
11:58:04 <sorear> nolrai: yes, `chainl1`
11:58:15 <quicksilver> oerjan: I knew one day I would get 1st google hit for something, all on my own
11:58:21 <Orphi> dcoutts: The documentation for DrawingArea helpfully suggests using pixbufRenderToDrawable - but this doesn't seem to exist.
11:58:29 <nolrai> doh!
11:58:32 <sorear> nolrai: left recursion doesn't work in monadic parsers, use right recursion if possible or `chainl` otherwise
11:58:38 <LoganCapaldo> nolrai: or just leftList ::= item*
11:59:05 <sorear> nolrai: in LL(k) parsers right recursion is preferred - this is opposite of the nature of LR(k), beware
12:00:25 <quicksilver> an applicative parser might be able to do enough static analysis to resolve its own left-recursions, I suspect
12:00:26 <nolrai> Im trying to make a Lazy K interpreter and the grammar is full of left recursion.
12:01:06 <sorear> nolrai: yeah, this is a good use for chainl1
12:02:17 <qweqwe> http://pastebin.com/m5247f54f
12:02:23 <qweqwe> new error i got now
12:02:53 <quicksilver> qweqwe: as I told you about 10 minutes ago, you will need (Show key, Show value) => constraints
12:03:08 <qweqwe> where to put them ?
12:03:21 <quicksilver> where you had (Show a) before :)
12:03:26 <quicksilver> in the instance head
12:04:04 <ddarius> qweqwe: Perhaps randomly permuting your code and then posting the new error messages is not the best way to go about this...
12:04:31 * quicksilver mutters about a certain "RB" who appears to be copying and pasting from an exercise sheet into haskell-cafe
12:04:49 <qweqwe> thanks it works now
12:05:05 <byorgey> quicksilver, indeed =(
12:05:23 <quicksilver> qweqwe: good! :)
12:11:19 <NathanINTJ> is hIDE still under development?
12:11:43 <quicksilver> NathanINTJ: I don't believe so.
12:12:14 <quicksilver> I believe it was dcoutts' baby, most recently
12:12:18 <NathanINTJ> What are some open source projects of note in haskell?
12:12:25 <quicksilver> darcs
12:12:38 <NathanINTJ> I'm looking to get involved in something
12:12:56 <dmwit> NathanINTJ: xmonad is easy to get into, and very useful
12:13:01 <NathanINTJ> xmonad eh?
12:13:04 <quicksilver> yeah, xmonad is cool.
12:13:08 <quicksilver> if you like minimal wms
12:13:14 <quicksilver> I'm more of an eyecandy man myself ;P
12:13:23 <dmwit> NathanINTJ: Probably not going to score a Summer of Code, though. ;-)
12:13:29 <quicksilver> if you're interested in editors then Yi is a nice project
12:13:37 <quicksilver> which *is* under active development, but has a long way to go
12:13:51 * Orphi tries to compile again...
12:14:03 <NathanINTJ> i'm not in school, summer of code is irrelevant to me ;0
12:14:55 <Saizan> quicksilver: so write a compiz extension for xmonad?:)
12:15:25 * Orphi fails again.
12:15:46 <quicksilver> Saizan: well, maybe. I don't use X11 at the moment.
12:15:55 <quicksilver> Saizan: although I may well come back to it some day.
12:16:25 <Orphi> gaaaah! >_<
12:16:49 <oerjan> more brains?
12:16:50 <NathanINTJ> yeah I read about Yi
12:16:53 <NathanINTJ> it sounds interesting.
12:16:59 <Orphi> foo -2 -3 doesn't do what you'd expect...
12:17:10 <Orphi> damn operator precidences! :P
12:17:19 * Orphi adds brackets
12:17:39 <Orphi> @type (+1)
12:17:40 <lambdabot> forall a. (Num a) => a -> a
12:17:44 <Orphi> @type (-1)
12:17:45 <lambdabot> forall a. (Num a) => a
12:17:50 <Orphi> hmmm. :)
12:17:56 <NathanINTJ> so waht do most of you haskell hackers do when you're not haskelling?  Do you have day jobs involving haskell or something else?
12:18:15 <Orphi> NathanINTJ: I am slowly trying to infiltrate Haskell into my work...
12:18:18 <Toxaris> NathanINTJ: hanging around in #haskell
12:18:20 <oerjan> Orphi: unary minus is the only prefix operator in haskell.  everything else becomes a section
12:18:35 <Orphi> oerjan: yeah. isn't it great? :S
12:18:36 <hpaste>  magnusth pasted "playing with callCC" at http://hpaste.org/4337
12:18:54 * Orphi compiles again
12:19:09 <dmwit> NathanINTJ: I'm in school, so that's my day job.
12:19:15 <NathanINTJ> ah school.
12:19:20 <NathanINTJ> graduate?
12:19:22 <Orphi> can't... match... Word16 against Int... GRRR! >_<
12:19:31 <oerjan> @quote fromIntegral
12:19:32 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
12:19:36 <magnusth> I fail to see the reason for the second result at http://hpaste.org/4337, could someone with good knowledge of callCC explain why I don't get a result of -1?
12:19:42 <ddarius> :t odd
12:19:43 <lambdabot> forall a. (Integral a) => a -> Bool
12:19:57 <Orphi> that doesn't rhyme at all! :P
12:20:01 <dons> ?users
12:20:01 <lambdabot> Maximum users seen in #haskell: 417, currently: 414 (99.3%), active: 24 (5.8%)
12:20:03 <dons> ?yow!
12:20:05 <ddarius> magnusth: You are using callCC backwards effectively.
12:20:09 <lambdabot> ONE:    I will donate my entire "BABY HUEY" comic book collection to
12:20:10 <lambdabot> 	the downtown PLASMA CENTER ...
12:20:10 <lambdabot> TWO:	I won't START a BAND called "KHADAFY & THE HIT SQUAD" ...
12:20:10 <lambdabot> THREE:	I won't ever TUMBLE DRY my FOX TERRIER again!!
12:20:18 <magnusth> ddarius, how do you man?
12:20:25 <dmwit> NathanINTJ: With any luck, yes. ;-)
12:20:35 <Betovsky> hi ppl
12:20:44 <Betovsky> is it possible to force ghc to free memory?
12:20:47 <Orphi> oh, wait, it's Word32 instead of Int. hehe!
12:20:50 <NathanINTJ> My fiance is in grad school.  I have 2 friends who went to get PhDs in CS as well, but both of them decided that it was a horrible idea after they got their masters.
12:20:51 <ddarius> magnusth: Not that it makes any difference in this case.
12:21:04 <dmwit> Betovsky: Yes, unsafePerformGC or something like that.  But why?
12:21:05 <Orphi> glad this code doesn't get called much...
12:21:05 <NathanINTJ> I was planning on going back to school after 2 years off... but, after their experiences, im not very exciteda bout the idea :)
12:21:09 * Orphi compiles yet again
12:21:22 <Orphi> OMG! IT COMPILES!! :o
12:21:27 <Betovsky> dmwit im doing this just to know how mutch time it takes to generate all combinations
12:21:36 <quicksilver> NathanINTJ: I'm a perl programmer *duck*
12:21:39 <Betovsky> print $ last $ replicateM 16 [1..16]
12:21:42 <NathanINTJ> hehe
12:21:47 <NathanINTJ> quicksilver: I'm a C# programmer.
12:21:49 <dons> Betovsky: you can use 'performGC' or tune the GC values
12:21:53 <Betovsky> but it seems it keeps all de list in memory
12:22:06 <ddarius> NathanINTJ: How did you hear about Haskell?
12:22:07 <NathanINTJ> I was a standard C programmer at my first job ;0
12:22:11 * Orphi tests it
12:22:18 <dons> Betovsky: you'll have to think about the code. (and do you mean replicate 16 ?)
12:22:19 <NathanINTJ> Wes Dyer's blog
12:22:24 <NathanINTJ> and then some on channel 9 MS
12:22:25 <Betovsky> dons yes
12:22:32 <magnusth> ddarius, I still don't get it, why isn't the answer -1?
12:22:33 <dons> Betovsky: the key is to write it in such a way that the intial part of the list can be discarded
12:22:46 <dons> (also, compile it with -O , so any fusion gets a chance)
12:22:50 <Orphi> what...the...hell....?! O_O
12:22:53 <NathanINTJ> C# 3.0 rips off some functional language stuff, so leading about that lead me into Haskell.
12:22:57 <NathanINTJ> leading = reading*
12:22:59 <dons> NathanINTJ: very interesting!
12:23:16 <dons> NathanINTJ: it does, we grumble sometimes :) purely functional data structures, list comphrehensions :)
12:23:25 <Betovsky> dons the function last shouldnt make the initial part discardedabled?
12:23:27 <Orphi> Test2: gtk/Graphics/UI/Gtk/Gdk/PixbufData.hs.pp:58:0: No instance nor default method for class operation Data.Array.Base.getNumElements
12:23:39 <Betovsky> dons i tryed both with -O and -O2
12:23:52 <dons> Betovsky: for specifically the expression: print $ last $ replicateM 16 [1..16]
12:23:55 <dons> ?
12:24:09 <Betovsky> all the code is main = that line
12:24:11 <Orphi> er... ok, what in the name of God does this imply? :|
12:24:15 <NathanINTJ> I actually like C# just fine for a lot of things, but ... at my current job, we're working on a proprietary video player and on a bittorrent like transfer engine, and C# dosen't seem like the best choices for those
12:24:21 <NathanINTJ> and in the future, I'd like to work on things like that but not in C#
12:24:25 <Orphi> dcoutts: you still around?
12:24:46 <Betovsky> the only purpose is to see how mutch time it takes to generate all combinations
12:24:52 <ddarius> Yes!  The Microsoft propaganda machine is working.
12:24:53 <NathanINTJ> I looked into OCaml too, but I hated the syntax
12:24:58 <dons> Betovsky: wow, that program has an amazing space leak
12:25:07 <ddarius> magnusth: Why do you think it should be?
12:25:13 <dons> 810M  812M onproc/1 -         0:08 32.96% A
12:25:22 <dons> main = print $ last $ replicateM 16 [1..16]
12:25:31 <Betovsky> ohh
12:25:33 <dons> nice program, Betovsky. I'd not have guessed that behaviour
12:25:42 <Betovsky> so it shouldnt be that way of behaviour?
12:25:43 * dons ponders what replicateM is doing here
12:25:58 <dons> replicateM n x    = sequence (replicate n x)
12:26:10 <dons> in the list monad, I guess?
12:26:17 <ddarius> It's doing a cartisian product of [1..16] with itself 16 times.
12:26:18 <dmwit> Yes, because of the final argument.
12:26:31 <Betovsky> yes
12:27:11 <oerjan> > 16^16
12:27:13 <lambdabot>  18446744073709551616
12:27:24 <magnusth> ddarius, the 'next' passed into 'half' should be the doubling (the current continuation) and if I don't call it then it shouldn't happen
12:27:25 <dons> mmm
12:27:41 <quicksilver> dons: this has come up before
12:27:52 <quicksilver> dons: the last iteration requires to hold into memory the last-but-one iteration
12:28:12 <quicksilver> > 16^15
12:28:13 <lambdabot>  1152921504606846976
12:28:26 <quicksilver> so the 16th iteration is trying to hold in memory a list which is that long
12:28:30 <dons> yep
12:28:30 <quicksilver> that looks like a big number to me :)
12:28:49 <quicksilver> of course, you can write an algorithm which uses constant space for this and similar problems :)
12:28:52 <quicksilver> but replicateM isn't it.
12:29:17 <dons> yep. replicateM is just the wrong function here, Betovsky
12:29:31 <dons> its naive 'searching'
12:29:37 <ddarius> magnusth: Not using callCC or the continuation passed by callCC should behave like normal code, not specially.  Also, callCC is scoped in a sense, it will always perform what follows it (unless it jumps due to some other continuation provided from some other callCC)
12:29:40 <oerjan> magnusth: you might consider what happens with the types if you use something like show instead of (2 *)
12:29:51 <wolverian> isn't the last element just replicate 16 16?
12:29:55 <Betovsky> didnt understand
12:30:23 <Betovsky> shouldnt the last but one iteration be the list [16,16,16,16,16,...,15] of length 16 ?
12:30:37 <wolverian> yup
12:31:01 <Toxaris> may it be that replicateM does iterate all those lists in breadth-first style, but depth-first style would be approbiate?
12:31:21 <wolverian> if you just want the last one you don't need to iterate at all
12:31:22 <dons> ?let search n = replicateM n [1..n]
12:31:25 <lambdabot> Defined.
12:31:28 <dons> > search 1
12:31:29 <lambdabot>  [[1]]
12:31:29 <dons> > search 2
12:31:30 <lambdabot>  [[1,1],[1,2],[2,1],[2,2]]
12:31:31 <dons> > search 3
12:31:32 <lambdabot>  [[1,1,1],[1,1,2],[1,1,3],[1,2,1],[1,2,2],[1,2,3],[1,3,1],[1,3,2],[1,3,3],[2,...
12:31:38 <dons> uh oh... growing quickly :)
12:31:41 <dons> > search 5
12:31:41 <lambdabot>  [[1,1,1,1,1],[1,1,1,1,2],[1,1,1,1,3],[1,1,1,1,4],[1,1,1,1,5],[1,1,1,2,1],[1,...
12:31:43 <Betovsky> wolverian the ideia is to genereate all them just to see the time it takes
12:31:44 <dons> > search 8
12:31:44 <lambdabot>  [[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,2],[1,1,1,1,1,1,1,3],[1,1,1,1,1,1,1,4],[1,...
12:31:47 <dons> > search 12
12:31:47 <lambdabot>  [[1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,2],[1,1,1,1,1,1,1,1,1,1,1,...
12:31:49 <dons> > search 16
12:31:50 <lambdabot>  [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2],[1,1,1,...
12:31:51 <wolverian> Betovsky, ah
12:31:55 <Betovsky> i just want the last to make sure everything is processed
12:31:57 <dons> so you can get the head in quick time :)
12:32:03 <dons> but the last one is a bit expensive
12:32:13 <sorear> NathanINTJ: maybe darcs?  the code is apparently some of the worst Haskell in existance, expect major pain, but if you can fix even one of the ghc-critical bugs expect eternal universal gratitude
12:32:46 <quicksilver> Toxaris: well, it's just that it bases the n-1th iteration on the nth
12:33:00 <dons> > head $ search 16
12:33:01 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
12:33:05 <dons> > (search 16) !! 2
12:33:06 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,3]
12:33:06 <quicksilver> Toxaris: the algorith to generate 'nth' is "for each item in n-1th, for each value, append tother to one'
12:33:07 <dons> > (search 16) !! 3
12:33:07 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4]
12:33:09 <dons> > (search 16) !! 4
12:33:09 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,5]
12:33:11 <dons> > (search 16) !! 5
12:33:11 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,6]
12:33:13 <dons> > (search 16) !! 7
12:33:14 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,8]
12:33:15 <dons> > (search 16) !! 10
12:33:16 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,11]
12:33:18 <dons> > (search 16) !! 12
12:33:19 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,13]
12:33:21 <dons> > (search 16) !! 13
12:33:21 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,14]
12:33:24 <dons> > (search 16) !! 15
12:33:24 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,16]
12:33:29 <dons> hmm
12:33:47 <wolverian> it's a bit longer than that
12:33:57 <wolverian> 16^16 elems, to be exact
12:34:00 <dons> ah, wrong monad.
12:34:26 <quicksilver> dons: laziness saves you somewhat for the first few elements
12:34:34 <quicksilver> dons: but as you get deeper in, more stuff gets forced
12:34:40 <quicksilver> (and is never let go)
12:34:42 <dons> yep, sure.
12:35:08 <oerjan> @src sequence
12:35:09 <lambdabot> sequence ms = foldr k (return []) ms
12:35:09 <lambdabot>     where
12:35:09 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
12:35:16 <dons> yow
12:35:17 <jedbrown> > 16^16 / 3e9 / 3.15e7 -- Years to enumerate
12:35:21 <Toxaris> quicksilver: well, that is breadth-first, isn't it? you first generate *all* 15 element lists before the first 16 element list is generated
12:35:48 <wolverian> so what's the simplest way to make this sane? :)
12:36:05 <ddarius> Toxaris: No, it's not breadth-first.
12:36:55 <jedbrown> (= 195.20364099163547) at 3 Billion per second
12:36:57 <dons> Betovsky: so you were expecting [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,16] ?
12:37:03 <Toxaris> or is it just the problem that laziness caches the n-1th iteration, and it would be better (memory-wise) to just recalculate it?
12:37:04 <Orphi> > ps [1..10] where p [] = []; p (x:xs) = (x,xs) : map (\(y,ys) -> (y,x:ys)) p xs; ps [] = []; ps xs = do (x0,xs0) <- p xs; xs1 <- p xs0; return (x0:xs1)
12:37:30 <Betovsky> dons ah? didnt understand the question
12:37:36 <NathanINTJ> sorear: I was under the impression that Haskell made it hard to write truly bad code.
12:37:55 <oerjan> @bot
12:37:56 <conal> hm.  that sequence definition easily generalizes to Applicative, since k = liftA2 (:), and return = pure.
12:38:02 <lambdabot> :)
12:38:04 <dmwit> NathanINTJ: No, it's just that the audience of Haskell is a bit self-selecting.
12:38:28 <Betovsky> but is there a better way to generate combinations?
12:38:28 <Orphi> surely no language can make it *hard* to write bad code?
12:38:32 <oerjan> conal: it's in Data.Traversable
12:38:40 <Betovsky> i always used replicateM but with small numbers
12:38:42 <waern> NathanINTJ: it's actually possible to write really bad code in haskell
12:38:45 <NathanINTJ> Orphi, the python guys would disagree ;0
12:38:46 <bos> dcoutts: ping
12:38:59 <musiKk> dmwit: you mean, the audience is somewhat elite?
12:39:05 <oerjan> :t Data.Traversable.sequenceA
12:39:06 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Data.Traversable.Traversable t, Applicative f) => t (f a) -> f (t a)
12:39:10 <NathanINTJ> I hate python, but their idea of a language where there is only one right way to do something is very interesting.
12:39:11 <OceanSpray> I got [Integer]
12:39:12 <magnusth> ddarius, yes, of course, I keep on having problems wrapping my mind around the flow when callCC is involved
12:39:12 <Orphi> NathanINTJ: don't know Python. probably wouldn't like it either ;)
12:39:15 <NathanINTJ> and just leaving all the wrong ways out of the language
12:39:18 <NathanINTJ> yeh, python blows
12:39:21 <OceanSpray> what's the most succinct way to add them together?
12:39:23 <dons> Betovsky: consider,
12:39:25 <dons> Prelude> length $ (\n -> Control.Monad.replicateM n [1..n]) 6
12:39:25 <dons> 46656
12:39:25 <dons> Prelude> length $ (\n -> Control.Monad.replicateM n [1..n]) 7
12:39:25 <dons> 823543
12:39:28 <dons> Prelude> length $ (\n -> Control.Monad.replicateM n [1..n]) 8
12:39:30 <dons> 16777216
12:39:37 <dons> so by the time you get to 16, there's an awful lot to traverse :)
12:39:47 <NathanINTJ> I'll take Ruby over Python any day, no matter how much less efficient it is.
12:39:58 <Betovsky> I see.
12:39:58 <dibblego> is there a strict Data.Map?
12:40:05 <quicksilver> Toxaris: yes, I think that is one way of explaining it.
12:40:06 <Orphi> > pick [1..10] where pick [x] = [(x,[])]; pick (x:xs) = (x,xs) : map (\(y,ys) -> (y,x:ys)) (pick xs)
12:40:06 <lambdabot>  Parse error at "where" (column 14)
12:40:08 <ddarius> OceanSpray: zipWith (+), assuming that is what you mean.
12:40:17 <Betovsky> it first builds all and then it traverses
12:40:19 <OceanSpray> :t sipWith
12:40:20 <lambdabot> Not in scope: `sipWith'
12:40:22 <OceanSpray> :t zipWith
12:40:23 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
12:40:26 <Betovsky> is it because of foldr in sequece?
12:40:29 <Orphi> lol @ sipWith
12:40:31 <hpaste>  magnusth annotated "playing with callCC" with "the expected results using callCC" at http://hpaste.org/4337#a1
12:40:33 <dons> Betovsky: and the result of each depends on the previous one, so it is all kept.
12:40:34 <quicksilver> Betovsky: it does, most of the time. But it still implements the algorithm you tell it to use :)
12:40:48 <quicksilver> Betovsky: if you tell it to generate the 16th iter based on the 15th, that's what it will do...
12:40:55 <quicksilver> and that implies keeping the 15th in memory.
12:41:05 <Betovsky> yes
12:41:09 <Orphi> > let pick [x] = [(x,[])]; pick (x:xs) = (x,xs) : map (\(y,ys) -> (y,x:ys)) (pick xs) in pick [1..10]
12:41:09 <lambdabot>  [(1,[2,3,4,5,6,7,8,9,10]),(2,[1,3,4,5,6,7,8,9,10]),(3,[1,2,4,5,6,7,8,9,10]),...
12:41:17 <Orphi> > let pick [x] = [(x,[])]; pick (x:xs) = (x,xs) : map (\(y,ys) -> (y,x:ys)) (pick xs) in pick [1..3]
12:41:17 <lambdabot>  [(1,[2,3]),(2,[1,3]),(3,[1,2])]
12:41:23 <Betovsky> if i make a homemade replicateM but insted of using foldr use foldl
12:41:29 <magnusth> ddarius, thanks, I managed to massage the code into doing what I expect of it: http://hpaste.org/4337#a1
12:41:32 <Betovsky> it shouldnt have this rpoblema right?
12:41:52 <Betovsky> it shouldnt have this problem right?
12:41:54 <OceanSpray> > zipWith (+) [1, 2, 3] [2, 3, 4]
12:41:55 <lambdabot>  [3,5,7]
12:42:11 <Orphi> my mind is blown... leaving. :-)
12:42:23 <OceanSpray> that's not really what I was looking for.
12:42:33 <quicksilver> OceanSpray: what where you after?
12:42:36 <ddarius> > let half n next | even n = next (n `div` 2) | otherwise = return (-1); in runCont (callCC $ \e -> half 3 e >>= return . (2*)) id
12:42:36 <OceanSpray> for a list [1, 2, 3] I want 1 + 2 + 3
12:42:36 <lambdabot>  -2
12:42:50 <OceanSpray> just sum 'em together.
12:42:51 <quicksilver> > foldl1 (+) [1,2,3]
12:42:51 <lambdabot>  6
12:42:55 <quicksilver> or, just
12:42:57 <quicksilver> > sum [1,2,3]
12:42:58 <lambdabot>  6
12:42:58 <Toxaris> > sum [1, 2, 3]
12:42:58 <lambdabot>  6
12:42:59 <ddarius> magnusth: The code you wrote doesn't lead to that output.  Perhaps you pasted the wrong code?
12:43:07 <swiert> dons: I've got a quick question about the XMonad source.
12:43:11 <OceanSpray> ok, thanks
12:43:30 <OceanSpray> For some reason, I've never used fold before.
12:43:39 <ddarius> OceanSpray: What the?!
12:44:04 <magnusth> ddarius, ah, yes, I forgot to paste the changes I made to half
12:44:42 <hpaste>  magnusth annotated "playing with callCC" with "correcting definition of half" at http://hpaste.org/4337#a2
12:44:45 <dons> swiert: yep, ask away
12:45:14 <swiert> dons: why is StackSet and friends parameterized by so many types?
12:45:14 <Philippa> <NathanINTJ> I hate python, but their idea of a language where there is only one right way to do something is very interesting. <- Function application. HTH HAND
12:45:16 <quicksilver> dcoutts: gtk2hs contains gnome canvas bindings doesn't it?
12:45:18 <swiert> is it just for testing?
12:45:24 <bos> randall munroe (the xkcd guy) gave a talk at google yesterday. donald knuth came to the talk, and asked "hat's the name of my O(log log n) search algorithm?"  (referring to http://imgs.xkcd.com/comics/1337_part_2.png )
12:45:44 <quicksilver> bos: awesome :)
12:45:47 <dfranke_> nice!
12:46:19 <dons> swiert: so testing, and to ensure the different window indexes don't get confused with each other
12:46:35 <dons> swiert: we use newtypes to keep Ints apart (there were bugs in the past where we indexed the wrong level)
12:46:51 <dons> swiert: the parameterisation over the window type was the main thing -- that's for testing
12:47:01 <swiert> dons: right - that's what I thought.
12:47:25 <ddarius> magnusth: Much better.
12:47:27 <dons> oh, and tags, some users like non-string tags
12:47:35 <dons> so we allow them to drop in any comparable type as a tag
12:47:37 <bos> newtypes and GeneralizedNewtypeDeriving turn Ints from nuclear weapons back into friendly companions
12:48:03 <dfranke_> bos: I'll be disappointed if he doesn't blag about that.
12:48:33 <magnusth> ddarius, thanks for your help... I might actually get continuations right on the first try some day :)
12:48:46 <swiert> dons: by comparable you mean "instance Eq"?
12:49:05 <bos> swiert: Ord
12:49:18 <bos> at least iirc
12:49:39 <dons> oh, maybe we only use Eq
12:49:51 <dons> no fancy searching, thanks :)
12:53:52 <dibblego> is Data.Map spine strict?
12:54:09 <oerjan> yes
12:54:17 <oerjan> @src Map
12:54:18 <lambdabot> Source not found. Do you think like you type?
12:54:22 <dibblego> thought so, cheers
12:54:45 <Sizur> OpenGL and ghc-6.8.1 don't like each other yet?
12:54:57 <oerjan> data Map k a  = Tip  | Bin {-# UNPACK #-} !Size !k a !(Map k a) !(Map k a)
12:55:13 <SamB_XP> Sizur: why do you say that?
12:55:20 <swiert> dons: Thanks for the answers. I've got bits of StackSet in Coq. I'll drop you an e-mail some time soon.
12:55:32 <Sizur> configure: ghc-6.8.1: could not execute: gcc
12:55:50 <SamB_XP> sounds more like you forgot to install gcc
12:56:12 <dibblego> oerjan, thanks (strange I cannot find any mention in the haddock)
12:56:38 <Sizur> just installed opensuse few days ago, might be the case. checking
12:56:45 <oerjan> was discussed here before
12:57:03 <dons> swiert: awesome
12:57:29 <swiert> yeah. It's about time some dep. typed people put their code where their mouth is.
12:57:40 <cdsmithus> dons: Hey!  Saw your messages earlier.  Yes, I suspected HaskellWiki was the wrong way to go for what I'm trying to do.
12:58:34 <Zime> hey anyone is are cube roots built into the prelude?
12:58:51 <oerjan> > 8 ** (1/3)
12:58:53 <lambdabot>  2.0
12:59:03 <jelousbuddy> has anyone ever shot infrared fire/energy from eyes? do you know if i do it or learned how to do it? are my eyes dangerous for glasses (ex windows)?
12:59:11 <SamB_XP> knuth reads xkcd?
12:59:23 <sorear> Cale!
13:00:30 <ricky_clarkson> SamB_XP: Huh?
13:00:46 <Cale> sorear: yeah?
13:00:53 <oerjan> Zime: ^^
13:00:54 <sorear> Cale: two lines up
13:01:06 <Cale> oh
13:01:10 --- mode: ChanServ set +o Cale
13:01:13 * oerjan finds popcorn
13:01:20 <bos> Cale: do that thing with the infrared energy from your eyes!
13:01:32 --- mode: Cale set +b *!*n=tulpit@*.cpe.net.cable.rogers.com
13:01:44 --- mode: Cale set -o Cale
13:01:45 <dons> has this guy been around before?
13:01:49 <Cale> It's a bot
13:01:53 <dons> ah
13:02:12 <allbery_b> you forgot the kick part
13:02:30 * SamB_XP laughs
13:02:49 <bos> #haskell emergency medicine
13:03:14 <oerjan> allbery_b: cannot speak when banned, i think
13:03:39 <SamB_XP> jelousbuddy: hi
13:03:42 <allbery_b> hopefully
13:04:16 <nolrai> @type chainl
13:04:16 <lambdabot> Not in scope: `chainl'
13:04:56 <sorear> nolrai: haskell has these things called modules... (how much of what I'm about to tell you do you already know?)
13:05:21 <Sizur> SamB_XP: thanks... I did not expect suse to not include gcc by default
13:05:23 <nolrai> most
13:05:51 <oerjan> :t Text.ParserCombinators.Parsec.chainl
13:05:51 <lambdabot> forall tok st a. Text.ParserCombinators.Parsec.Prim.GenParser tok st a -> Text.ParserCombinators.Parsec.Prim.GenParser tok (a -> a -> a) -> a -> Text.ParserCombinators.Parsec.Prim.GenParser tok st
13:05:51 <lambdabot> a
13:06:17 <SamB_XP> nolrai: what part don't you know?
13:06:26 <nolrai> I dont know.
13:06:56 <nolrai> I think I under stand them but I have thought that before and been wrong.
13:07:26 <SamB_XP> hmm,
13:07:35 <nolrai> I just didnt bother to look up the full module name.
13:08:02 <SamB_XP> I guess that wasn't a great joke
13:08:03 <nolrai> I have enough for now.
13:08:46 <nolrai> jokes are allway hard in text.
13:08:59 <dons> ?users
13:08:59 <lambdabot> Maximum users seen in #haskell: 412, currently: 410 (99.5%), active: 26 (6.3%)
13:09:13 <oerjan> lambdabot the amnesiac
13:09:35 <dons> the new server tends to kill her off a bit more viciously than the old one
13:09:41 <SamB_XP> @seen
13:10:02 <dons> so while we seem to have stopped the url timeout block, high load on the server leads to things getting killed
13:10:35 <SamB_XP> @seen JaffaCake
13:10:35 <lambdabot> I haven't seen JaffaCake.
13:10:47 <nolrai> a `b` c d should parse to ((b a) c) d right?
13:10:57 <oerjan> doesn't lambdabot save user stats?
13:11:07 <oerjan> even when @flush'ing?
13:11:21 <oerjan> nolrai: no, b a (c d)
13:11:24 <dons> it does, but if it gets killed nastily, that can cause state loss
13:11:37 <SamB_XP> why doesn't lambdabot have a roomier box?
13:11:56 <oerjan> dons: i understand that it loses state from the _current_ session
13:11:57 <dons> do you have one available?
13:12:04 <oerjan> but not why it forgets old data
13:12:15 <dons> it generally reverts to the last saved data, yep.
13:12:17 * ddarius doesn't have M[f(x)](s) = ...
13:12:18 <nolrai> So, one cant use trinary ops easly?
13:12:23 <dons> there's cases where it can be killed when writing though
13:12:29 <dons> that leads to discarding state
13:12:38 <SamB_XP> dons: it should rotate or something
13:12:46 <nolrai> Oh well a $ should fix it.
13:12:57 <dons> patch away, SamB_XP
13:13:16 <ddarius> SamB_XP: "rotate"?
13:13:25 <SamB_XP> what version of GHC would I need to do that?
13:13:47 <quicksilver> ddarius: periodically checkpoint state and discard old backups, I imagine he means.
13:14:00 <Toxaris> nolrai: multi-ary ops are usefull in higher-order settings
13:14:12 <dons> ?version
13:14:13 <lambdabot> lambdabot 4p581, GHC 6.6 (Linux i686 2.40GHz)
13:14:13 <lambdabot> darcs get http://code.haskell.org/lambdabot
13:14:29 <Toxaris> :t (.) -- consider this one, nolrai
13:14:30 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
13:14:34 <OceanSpray> If I have a data constructor (Something n)
13:14:49 <OceanSpray> how do I get the n out without using pattern-matching?
13:14:54 <ddarius> OceanSpray: You don't.
13:15:02 <nolrai> ah ok.
13:15:06 <oerjan> Toxaris: i think he means syntax without parentheses
13:15:34 <OceanSpray> let a = (Something 5)
13:15:42 <OceanSpray> do I HAVE to use
13:15:46 <oerjan> OceanSpray: you can define it with a field name though
13:15:51 <nolrai> OceanSpray: you can name the field, but thats just sytatic sugar for pattern maching.
13:16:11 <Toxaris> oerjan: I think so, too. But I wanted to show him that a trinary op may be usefull without ever applying it to three operands at once
13:16:23 <OceanSpray> ok.
13:16:24 <ddarius> You can also simply define an "accessor" function using pattern matching and use that.
13:16:44 <nolrai> which is what name ing the field does.
13:16:49 <oerjan> @src Reader
13:16:49 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
13:16:53 <ddarius> nolrai: But that's not all it does.
13:16:54 <oerjan> gah
13:17:03 <nolrai> true.
13:18:15 <nolrai> it also allows you to use that god awful update syntax (actually its nice in many ways but very odd)
13:18:38 <Toxaris> nolrai: and it allows you do use name-based pattern matching
13:19:06 <Toxaris> nolrai: wich is nice and odd, too
13:19:07 <nolrai> say more.
13:19:13 <Brian`> hi, i have a question
13:19:31 <dfranke_> ooh, hmm...  Are GADTs supported by Template Haskell?  The DataD constructor doesn't look like it's intended to handle them.
13:19:43 <Toxaris> nolrai: http://hpaste.org/4295
13:19:44 <Brian`> you say haskell is first order functional programming language right? meaning functions can be passed as arguments..
13:19:53 <Brian`> what would it mean to say 0th order or 2nd order?
13:20:02 <Philippa> Brian`: "first order" doesn't mean that
13:20:08 <Nafai> Where is the current lambdabot repo?
13:20:15 <Brian`> doesn't it? then what does it mean..?
13:20:26 <Philippa> rather, haskell isn't a first order functional language because it also allows higher-order functions
13:20:32 <Philippa> first order functions can't take or return functions
13:20:41 <oerjan> Brian`: maybe you are thinking of first class functions
13:20:43 <Philippa> a second order function takes or returns first-order functions
13:20:49 <ddarius> dfranke_: It's doubtful.
13:20:56 <Nafai> I tried an update on an old source tree I had and it said lambdabot was moved to http://code.haskell.org/lambdabot but I can't darcs get from there
13:21:02 <Heffalump> anyone know where I can search #haskell logs? The link from tunes.org that claims to offer searchable logs doesn't seem to.
13:21:04 <Brian`> oh right right .. my bad ; i was confused with higher-order -_-; lol
13:21:07 <Brian`> hm.. i c
13:21:21 <Brian`> and third-order would take or returns 2nd-order.. and so on..?
13:21:36 <nolrai> do you mean that funtions are first class values?
13:21:42 <ddarius> Heffalump: google "site:tunes.org #haskell blah" ?
13:21:55 <quicksilver> Heffalump: google with a site tag
13:21:59 <quicksilver> oh, beaten to the pip :)
13:22:01 <Heffalump> oh yeah. Cunning :-)
13:22:02 <Philippa> Brian`: right
13:22:07 <dfranke_> ddarius: well, that bites.
13:22:10 <Brian`> nolrai, hm.. I think so haha ; man.. I am so bad at terminologies...
13:22:12 <SamB_XP> ddarius: but blah isn't logged publicly...
13:22:28 <quicksilver> Heffalump: google is better than just about all specific site searches
13:22:31 <quicksilver> strange but true...
13:22:43 <Brian`> Philippa, and 0th order functions are values like 0,1,2,... ?
13:22:44 <SamB_XP> quicksilver: I dunno about for IRC logs...
13:23:02 <Brian`> Philippa, or True/False or any primitive values?
13:23:23 <SamB_XP> in particular, it seems to think of an IRC log file as one thing
13:23:26 <Philippa> Brian`: I don't think anyone talks about 0th order functions because they're, uh, not functions
13:23:46 <SamB_XP> you mean like True?
13:23:50 <dons> dcoutts_, Igloo, apache on community.haskell.org needs restarting
13:23:51 <Philippa> but yes, that would be the obvious definition if you work in terms of how deep function arrows get - no function arrow at all
13:23:57 <Toxaris> quicksilver: why strange? google can evaluate inter-site links to rate contents, wich site-specifics searches can't. more information yields better search results.
13:24:11 <dons> (i think the server started killing processes when lambdabot was being stressed .. might have to move lambdabot somewhere roomier..)
13:24:13 <nolrai> Brain`: but if any one did complex data types would still be first order.
13:24:42 <Philippa> nolrai: huh? That doesn't make any sense
13:25:09 <Philippa> in fact, I don't think you can give any sensible definition where that's the case rather than 1st-or-higher order
13:25:10 <SamB_XP> data of complex types
13:25:18 <Brian`> nolrai, Philippa: where can I find formal definitions of "first class", "2nd order", "1st order" and so on?
13:25:27 <Brian`> nolrai, Philippa: in a logic textbook?
13:25:29 <Philippa> Brian`: there isn't a formal definition of "firest class"
13:25:31 <SamB_XP> are 0th order functions
13:25:34 <Philippa> *first class
13:25:40 <SamB_XP> unless they have functions in them...
13:25:47 <SamB_XP> in which case I have no clue ;-)
13:26:07 <oerjan> @go first class value
13:26:08 <lambdabot> http://en.wikipedia.org/wiki/First-class_object
13:26:08 <lambdabot> Title: First-class object - Wikipedia, the free encyclopedia
13:26:09 <Brian`> SamB_XP, aha i c.. then what about data of non-complex types? primitives?
13:26:21 <Philippa> Brian`: formally, you're a 1st rank function if you take and return non-function values, and an n+1th rank function if you take or return an nth rank function
13:26:34 <Philippa> er, order even
13:26:36 <Philippa> rank'd be polymorphism
13:27:11 <SamB_XP> so, what is the rank of id?
13:27:13 <thetallguy> arrr!
13:27:24 <quicksilver> rank, or order?
13:27:26 <nolrai> A resonable definithion of not funtional would be is in Shows.
13:27:29 <SamB_XP> sorry
13:27:30 <SamB_XP> order!
13:27:30 <quicksilver> it's rank is 1
13:27:36 <quicksilver> its order depends how you instantiate it
13:27:40 <Heffalump> could someone remove the ban on *!i=41b708c2@gateway/web/cgi-irc/*, please? It seems someone was banned for being annoying, and now someone has come along claiming that the IP is the exit point for an entire uni and so is affecting others. So I think it's worth offering it another chance.
13:27:48 * SamB_XP caught the confusion from Philippa 
13:27:58 <quicksilver> if id :: a -> a then order(id) = order(a) + 1 ;)
13:28:00 <Philippa> nolrai: no, that's sufficient but not necessary
13:28:34 <Toxaris> so id is polyordered?
13:28:46 <Philippa> nolrai: and you might want to explain what you meant about complex data types. Or stop making statements in an authoritative rather than tentative tone
13:28:47 <quicksilver> well it's polymorphic :)
13:28:49 <SamB_XP> Heffalump: exit point ... sounds like a tor misconfiguration ;-)
13:28:56 <quicksilver> order is a property of concrete types
13:29:03 <quicksilver> not polymorphic type schemes
13:29:06 <quicksilver> AIUI
13:29:08 <Heffalump> or NATting...
13:29:13 <quicksilver> although you could choose other definitions
13:29:16 --- mode: ChanServ set +o dons
13:29:18 <oerjan> nolrai: you _could_ define a Show instance for a function type
13:29:22 --- mode: dons set -b *!i=41b708c2@gateway/web/cgi-irc/*
13:29:25 --- mode: ChanServ set -o dons
13:29:38 <dons> yes, you have to be careful blocking gateways like that
13:29:41 <Philippa> oerjan: it'd show you its bottom?
13:29:57 <Toxaris> > show (id :: Char -> Char) -- let's try it
13:29:58 <lambdabot>  "<Char -> Char>"
13:30:08 <Heffalump> dons: It wasn't a gateway per se, that ident identifies a single IP address using cgi-irc.
13:30:19 <nolrai> char would work because it is finite.
13:30:21 <SamB_XP> hmm, huh, it even says right in the utility mask...
13:30:41 <Toxaris> > show (id :: [Char] -> [Char]) -- let's try it again
13:30:42 <lambdabot>  "<[Char] -> [Char]>"
13:30:52 <oerjan> Philippa: it could evaluate on a particular value
13:30:53 <dons> ?users
13:30:53 <lambdabot> Maximum users seen in #haskell: 412, currently: 405 (98.3%), active: 25 (6.2%)
13:31:08 <Heffalump> anyway, the original banner was glguy, and there are logs at http://tunes.org/~nef/logs/haskell/07.10.25, in case anyone wants to review them in future.
13:31:22 <Philippa> oerjan: sure. show _ = "(_|_)"...
13:32:06 <oerjan> Philippa: you are misinterpreting me.
13:32:33 <oerjan> example: instance Show (Int -> Int) where show f = show (f 0)
13:32:35 <nolrai> > let showf f = map f ['\0'..] in showf id
13:32:36 <lambdabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\SY...
13:32:42 <quicksilver> > show (id :: forall a. a -> a)
13:32:42 <lambdabot>  Parse error at "." (column 21)
13:32:46 <quicksilver> > show (id :: forall a . a -> a)
13:32:46 <lambdabot>  Parse error at "." (column 22)
13:32:55 <quicksilver> odd, I thought lambdabot had ghc extensions on
13:33:28 <oerjan> quicksilver: nope, > only has extended defaults
13:33:29 <nolrai> > let showf f = map f ['\0'..] in showf (+ 1)
13:33:29 <lambdabot>   add an instance declaration for (Num Char)
13:33:31 <SamB_XP> it parses without them, though
13:33:42 <ddarius> quicksilver: It has different extensions for different things.
13:33:47 <quicksilver> ddarius: ah
13:33:48 <oerjan> but :t is quite liberal
13:33:50 <ddarius> :t unsafePerformIO
13:33:51 <lambdabot> Not in scope: `unsafePerformIO'
13:33:55 <Toxaris> what's the order of (++)? one, because it accepts a non-function. or two, because it returns a first-order-function?
13:33:57 <ddarius> :t System.Unsafe.unsafePerformIO
13:33:58 <lambdabot> Couldn't find qualified module.
13:34:12 <SamB_XP> :t Foreign.unsafePerformIO
13:34:13 <lambdabot> forall a. IO a -> a
13:34:34 <Philippa> Toxaris: fair nitpick. Take the max
13:35:10 <nolrai> whell returning a first order function is the same as just taking an extra argument, right?
13:35:16 <Toxaris> so order is somewhat related to arity in a currying language
13:35:16 <Philippa> however, it's reasonable to describe it as first-order via the currying isomorphism, which everyone applies when talking
13:35:27 <Philippa> arity? What's that?
13:35:29 <SamB_XP> (++) is a first order function...
13:35:42 <Philippa> SamB: uncurry (++) is
13:35:44 <SamB_XP> oh, you mean from the second argument...
13:35:47 <Toxaris> Philippa: how many arguments a function takes
13:35:53 <quicksilver> SamB_XP: from the return value...
13:36:06 <quicksilver> I'm not sure if order "on the right" of an arrow is suppose to stack
13:36:09 <Philippa> Toxaris: you misunderstand. If you're going to take that line, all functions have the same arity in haskell
13:36:19 <quicksilver> I'd have guess a definition would be
13:36:22 <ddarius> Indeed, (++) is second-order.
13:36:29 <quicksilver> order (A -> B) = max (A+1,B)
13:36:45 <quicksilver> because it's only in the contravariant place that you're really making stuff more complex
13:37:00 <quicksilver> analagus to the fact that nested foralls only "matter" in contravariant positions
13:37:01 <Toxaris> Philippa: well, the arity of the fully uncurried version of f is the minimum order of f
13:37:01 <Philippa> that's a decent currying-aware definition, yeah
13:37:10 <quicksilver> nested foralls in covariant positions can be floated up
13:37:42 <dcoutts> dons: apache restarted
13:38:04 <SamB_XP> so... what is the order of id?
13:38:21 <Philippa> SamB: instantiate the type variable and I'll tell you
13:38:41 <Philippa> it'll be a minimum of first-order
13:38:43 <oerjan> order(id :: a -> a) = 1 + order(undefined :: a)
13:38:50 <SamB_XP> hmm. I suppose if I passed map to it, it would be third order...
13:39:05 <Toxaris> :t id map
13:39:05 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
13:39:05 <ddarius> SamB_XP: At least...
13:39:40 <dcoutts> quicksilver: someone is trying to bind one of the canvas apis but no we don't have gnomecanvas bound. It is generally considered deprecated.
13:39:46 <dcoutts> bos: pong
13:40:17 <quicksilver> dcoutts: ah. What's the repolacement?
13:40:42 <conal> id is polyordered
13:41:09 <dcoutts> quicksilver: either using cairo directly, building something domain-specific on top of cairo or one of the new cairo based canvas apis that are under development
13:41:10 <SamB_XP> dcoutts: cairo isn't a canvas API?
13:41:15 <bos> dcoutts: never mind, sorry
13:41:25 <dcoutts> SamB_XP: no, it's an immediate mode drawing api, like ps/pdf
13:41:36 <dcoutts> bos: ok :-)
13:41:41 <SamB_XP> dcoutts: oh.
13:42:13 <dcoutts> when people talk about canvas apis they generally mean something that lets you define objects and then tweak their attributes over time
13:42:24 <SamB_XP> that sounds really icky
13:42:35 <dcoutts> it's not very functional
13:43:13 <bos> it's not icky. the drawing model is very nice to work with, in fact.
13:43:16 <dons> dcoutts: "Just a success report, after 58 min of coding I got kind of ReadP parser over ByteString working and my memory usage went down from 1500MB to...  1.2MB! Over 1000 times better! Incredible!"
13:43:20 <conal> or it's *very* functional, if the attributes are time-varying values.
13:43:31 <dcoutts> right
13:43:32 <Heffalump> personally, I'd call id first-order, and just accept that type instantiation doesn't preserve order.
13:43:35 <conal> (i.e., functional behaviors)
13:43:42 <SamB_XP> conal: "tweak" kind of excluded that
13:43:57 <dcoutts> it's possible to layer a functional model over the top of that
13:43:57 <SamB_XP> bos: which isn't icky?
13:44:08 <bos> SamB_XP: cairo
13:44:23 <SamB_XP> bos: I meant canvas APIs sound icky
13:44:39 <bos> oh. yes, they're awkward and lame and slow.
13:44:39 <conal> immediate mode is more purely imperative
13:44:40 <Philippa> Heffalump: yeah, it's as good a shorthand as any
13:44:42 <dcoutts> we need a simple functional layer over cairo, it'd be easy
13:44:55 <Toxaris> since we have a unlimited-order language, is there any need to care about invidual function's order?
13:45:32 <dcoutts> dons: nice, though ReadP is pretty unpleasant. It's slow because it doesn't control backtracking and it doesn't give any information about parse errors, just [].
13:45:39 <bos> canvas APIs were popular back in the early 1990s, but have since fallen out of favour.
13:45:47 <conal> dcoutts: yes, it's easier to build genuinely functional (no IO) layers over immediate mode than retained mode APIs.  though i wrote a paper on the latter.
13:45:49 <ddarius> It's kind of tricky to have a language with k-order functions (with k>1) (as in it's trickier than just having higher order functions in general)
13:45:53 <SamB_XP> conal: well, immediate mode is more like FP than canvas APIs are ...
13:46:04 <SamB_XP> darn
13:46:05 <conal> SamB_XP: how's that??
13:46:08 <SamB_XP> I took to long to say it
13:46:09 <Philippa> ddarius: unless they're built-ins
13:46:25 <fasta> dcoutts: by functional layer, you mean some set of functions and data structures that model Cairo operations, but are delayed and possibly optimised to more efficient Cairo sequences of commands?
13:46:42 <SamB_XP> ddarius: well, yes, but you COULD
13:46:43 <dcoutts> there's more or less a 1-1 translation from the cairo immediate model to an expression language for drawings
13:46:44 <conal> immediate mode is one action after another.  purely imperative.
13:46:56 <dcoutts> fasta: no, much simpler, no data or introspection
13:47:21 <SamB_XP> conal: yes, without nearly as much nasty state as the other way
13:47:29 <conal> dcoutts: if you do, i'd be interested in collaborating, with an eye on simplicity/orthogonality.
13:47:44 <fasta> dcoutts: isn't a Canvas basically a bytearray, what are you going to make functional about that then?
13:47:56 <dcoutts> fasta: eg we have an imperitive operation to save/restore the current transformation matrix and operations to rotate etc. So we get rotate :: Angle -> Picture -> Picture
13:48:22 <dcoutts> fasta: no, what people often mean by a canvas api is some OO thing where you define a scene graph
13:48:35 <conal> SamB_XP: or just more complex state.  while immediate mode is pure imperative, retained mode is sort of part-way to a functional model, and that's why it's a mess.
13:48:54 <fasta> dcoutts: oh, I think just about the Java Canvas.
13:48:55 <desegnis> dcoutts: You mean, just transform cairo state into arguments of (higher-order) functions?
13:49:05 <dcoutts> desegnis: yup
13:49:27 <quicksilver> dcoutts: I like the design with the Render monad. I wish openGL was like that...
13:49:45 <byorgey> hi all, is there a monad transformer for ST, or is that impossible for some reason?
13:49:45 <desegnis> dcoutts: That sounds indeed not too hard.
13:49:56 <quicksilver> byorgey: it's impossible.
13:49:59 <SamB_XP> byorgey: ST is IO only nastier
13:50:00 <dcoutts> rotate angle (Picture p) = Picture (Cairo.save >> Cairo.rotate angle >> p >> Cairo.restore)
13:50:01 <quicksilver> byorgey: you'd be able to rollback mutations.
13:50:10 <ddarius> SamB_XP: What?
13:50:13 <byorgey> quicksilver: ah, I see.
13:50:18 <ski> SamB_XP : other way around ?
13:50:22 <allbery_b> "nastier"?
13:50:31 <SamB_XP> yes. nastier.
13:50:33 * allbery_b got the impression ST was a sort of simplified IO
13:50:42 <allbery_b> just the IOref part
13:50:47 <quicksilver> and the array part
13:50:48 <dcoutts> conal: that'd be great though I'm always short on time, writing up my thesis etc (and have to get a JFP paper in my April)
13:50:53 <byorgey> well, I have a program where I'm using StateT over IO, where the state contains a DiffArray, but I'd like to change it to something faster.
13:51:03 <SamB_XP> well, it has more complicated types
13:51:03 <byorgey> I guess I should use IOUArray instead of STUArray then.
13:51:22 <ddarius> SamB_XP: Most things have more complicated types than IO, that doesn't make them nastier.
13:51:24 <allbery_b> well, I'd consider IOArray v STArray as part of IORef vs STRef
13:51:26 <conal> dcoutts: sure.  and as you said, you can do a straightforward wrapper, without a simple, orthogonal semantics.
13:51:36 <allbery_b> (and -U-)
13:51:37 <SamB_XP> more complicated in a nasty way
13:51:42 <ddarius> Anyway, I'll be back eventually.
13:51:52 <dcoutts> conal: some bits are easy, like rotate above, but some are more subtle and I don't have a clear grasp of the algebra
13:51:59 <quicksilver> allbery_b: I don't think you can implement STArray with STref, can you?
13:52:09 <dcoutts> conal: since cairo is based on the pdf model it's fairly good, not too ad-hoc
13:52:16 <quicksilver> allbery_b: STArrays have mutation in place, STRefs don't really.
13:52:24 * allbery_b has no idea actually
13:52:47 <fasta> quicksilver: strefs have no in-place mutation?
13:52:48 <SamB_XP> well, clearly the difference between STArray and IOArray mirros that between STRef and IORef
13:52:56 <quicksilver> fasta: I don't think so, no.
13:52:59 <conal> dcoutts: i've done a *lot* of these designs.  i have a pretty good feel for it.  but almost no one designs these APIs for simplicity and or orthogonality.
13:53:03 <quicksilver> fasta: they are just a pointer. That's not mutation.
13:53:12 <SamB_XP> s/mirros/mirrors/
13:53:13 <quicksilver> fasta: you get a completely fresh new value.
13:53:25 <ski> the cell the pointer points to is mutated in-pace
13:53:25 <allbery_b> see, I thought IORefs *were* STRefs
13:53:29 <fasta> quicksilver: well, you mutate the contents of a box.
13:53:30 <oerjan> :t Data.STRef.modifySTRef
13:53:31 <lambdabot> forall s a. GHC.STRef.STRef s a -> (a -> a) -> GHC.ST.ST s ()
13:53:34 <quicksilver> that is true
13:53:36 <quicksilver> but only the box
13:53:38 <quicksilver> (the pointer)
13:53:40 <quicksilver> not the value
13:53:45 <allbery_b> IO ~~ ST RealWorld
13:53:50 <quicksilver> mutable pointers is not really mutable values IMO.
13:53:55 <pejo> dcoutts, what's the jfp paper on?
13:53:56 <fasta> quicksilver: the old value if you referred to it, still exists, yes.
13:53:57 <ski> the difference is that with arrays, the pointer points to a sequence of cells
13:53:58 <conal> dcoutts: so they end up more complex & less general than they might be.  and lack nice algebraic properties, and thus optimizability.
13:54:01 <dcoutts> pejo: stream fusion
13:54:06 <SamB_XP> STArray only has a bunch of mutable pointer cells in the same box
13:54:08 <fasta> quicksilver: if that's what you meant.
13:54:15 <dcoutts> conal: aye
13:54:18 <quicksilver> SamB_XP: well the unboxed one has real mutable values.
13:54:37 <ski> values are not mutable
13:54:38 <quicksilver> ski: no, the difference is that with arrays you don't change that pointer.
13:54:46 <SamB_XP> coincidentally... that's where the complicated types come to bite you in the ass...
13:54:47 <quicksilver> ski: you keep the pointer (to the sequence of cells)
13:54:50 <quicksilver> and you change the cells
13:54:57 <ski> quicksilver : same with `IORef'
13:55:06 <quicksilver> hmm
13:55:10 <quicksilver> I'm not communicating this clearly
13:55:20 <quicksilver> with an STArray the 'spine' of the array is actually re-used
13:55:28 <quicksilver> the pointer to the spine doesn't change.
13:55:33 <quicksilver> an STref is "just" a pointer
13:55:36 <quicksilver> and that pointer does change.
13:55:44 <ski> with a `IORef', the "spine" (just a single cell) is re-used
13:55:48 <SamB_XP> STRef/IORef *could* be implemented as one-element STArray/IOArray
13:55:54 <ski> the pointer to the "spine" doesn't change
13:56:02 <quicksilver> right.
13:56:02 <oerjan> @src STRef
13:56:02 <lambdabot> data STRef s a = STRef (MutVar# s a)
13:56:05 <quicksilver> agreed :)
13:56:08 <oerjan> @src IORef
13:56:08 <lambdabot> newtype IORef a = IORef (STRef RealWorld a)
13:56:09 <ski> a `IORef' is just a pointer
13:56:12 <ski> and that pointer does change
13:56:21 <oerjan> @src STArray
13:56:21 <lambdabot> data STArray s i e = STArray !i !i (MutableArray# s e)
13:56:23 <ski> s/does/doesn't/ :)
13:56:37 <quicksilver> but I don't think you can implement an STArray with an STRef
13:56:39 <allbery_b> huh, IORefs are indirect STRefs.  I missed that
13:56:43 <allbery_b> ok
13:57:01 <quicksilver> I mean, you can you implement something with the same semantics, of course.
13:57:02 <ski> allbery_b : indirect ?
13:57:07 <fasta> quicksilver: what pointer of an stref changes?
13:57:09 <quicksilver> but not somethign with the same 'shared spine' approach.
13:57:19 <fasta> quicksilver: and when specifically?
13:57:19 <quicksilver> fasta: the one inside the box, not the pointer to the box
13:57:21 <allbery_b> <lambdabot> newtype IORef a = IORef (STRef RealWorld a)
13:57:29 <quicksilver> allbery_b: newtype isn't indirection
13:57:36 <quicksilver> allbery_b: newtype is just a type-level trick.
13:57:42 <ski> @src STArray
13:57:42 <lambdabot> data STArray s i e = STArray !i !i (MutableArray# s e)
13:57:50 <SamB_XP> newtype is specifically NOT indirection, actually
13:57:59 <allbery_b> hm, right,, missed that was a newtype
13:58:00 <fasta> quicksilver: ok, so a new pointer to another value is made, so the old value still exists.
13:58:02 <allbery_b> duh me
13:58:04 <quicksilver> fasta: yes.
13:58:10 <fasta> quicksilver: that's consistent with how I thought about it.
13:58:19 <byorgey> hmm, ghc complains about not finding the profiling libraries for mtl... where would I get those?
13:58:28 <byorgey> I don't see anything likely on hackage...
13:58:32 <ski> quicksilver : i still don't see the difference with these "spines" ..
13:58:34 <SamB_XP> if you want you can use the silly IOURef. well, if someone would bother to implement it.
13:58:51 <quicksilver> ski: I agree that STRef has a simple little 1-cell spine
13:59:00 <ski> ok
13:59:03 <quicksilver> ski: but I don't think you can implement an n-cell spine given only a 1-cell spine
13:59:06 <allbery_b> byorhey: get the mtl package from hackage, tell cabal to configure it with profiling?
13:59:06 <oerjan> byorgey: profiling is just a different compilation option?
13:59:12 <quicksilver> in that sense, STArry has to be primitive, not defined with STRef
13:59:15 <allbery_b> byorgey even
13:59:23 * allbery_b doing *real* good today... feh
13:59:39 <byorgey> allbery_b: oh, I have to install it with profiling?  I see.
13:59:57 <ski> quicksilver : you could make a list (or tree) of cells ..
14:00:04 <allbery_b> right, it's just a build option.  Cabal default is to not build profiling libs
14:00:10 <SamB_XP> ski: that misses the whole point
14:00:15 <allbery_b> I don't recall hw you tell Cabal to build profiling libs
14:00:16 <quicksilver> ski: right. but then it wouldn't be the same thing.
14:00:21 <quicksilver> ski: semantically it would match.
14:00:23 <ski> quicksilver : and maybe have whole and maybe also parts of that inside cells .. but this the uses more indirections
14:00:24 <fasta> --enable-library-profiling
14:00:25 <SamB_XP> ski: sure it would WORK
14:00:26 <quicksilver> ski: but it would miss the point :)
14:00:33 <fasta> byorgey: ^^
14:00:37 <ski> s/the/then/
14:00:47 <ski> quicksilver : what is the point ? :)
14:00:53 <byorgey> fasta: thanks.
14:01:08 <SamB_XP> ski: blazing fast code
14:01:24 <quicksilver> ski: the point is the for the spine to stay in one place ;)
14:01:24 <SamB_XP> using imperative techniques
14:01:37 <quicksilver> the spine never changes
14:01:47 <ski> meaning what ?
14:01:48 <quicksilver> of course, I'm not sure if that is really all that important.
14:01:50 <quicksilver> but it *is* the point.
14:02:01 <quicksilver> meaning that if you have an array of 10 elements, change each element
14:02:06 <ski> is the spine the sequence of cells ?
14:02:07 <quicksilver> the spine is still the same 10-cell structure
14:02:13 <quicksilver> (only the pointers insid have changed)
14:02:15 <ski> ok
14:02:36 <quicksilver> this is what I understand to be the contract of STArray
14:02:45 <ski> so, would a 10-tuple work, then ?
14:02:48 <quicksilver> although, as I say, I don't really know how much it gains you in the real world.
14:02:59 <ski> (hm, no)
14:03:00 <quicksilver> ski: no, when you alter a 10-tuple, a new top-level constructor is built
14:03:05 <ski> *nod*
14:03:11 <SamB_XP> well, it makes some things O(1) that would otherwise be O(log(n))
14:03:19 <quicksilver> precisely
14:03:36 <quicksilver> or O(log k) for some clever-clever algorithms
14:03:37 <quicksilver> where k < n
14:03:42 <quicksilver> such as fingertrees and so on
14:03:49 <quicksilver> but still not O(1)
14:03:58 <ski> so .. i think the point then is that the "spine" structure that the array pointer points to is a unique structure (in the sense of Clean), so that it can be modified in-place
14:04:03 <SamB_XP> what function of n is k?
14:04:11 <quicksilver> SamB_XP: not clearly defined
14:04:23 <fasta> O(log (log (f(n))) where k is some polynomial over n.
14:04:24 <quicksilver> SamB_XP: but certain fingertree operations are O(log(distance from nearest end))
14:04:32 <SamB_XP> < doesn't say much
14:04:34 <fasta> quicksilver: ^^
14:04:41 <quicksilver> SamB_XP: which is always slightly better than O(log n)
14:04:54 <SamB_XP> nearest end?
14:04:57 <quicksilver> SamB_XP: there are other clever data structures with other clever complexities
14:05:10 <oerjan> quicksilver: if complexity is all you want, you could do STArray by Array ... STRef ...
14:05:10 <quicksilver> SamB_XP: yes, updating the last element of a fingertree-based array is O(1)
14:05:29 <SamB_XP> oh, that
14:05:33 <fasta> But clever complex data structures are often only fast for universe sized problem sets.
14:05:36 <quicksilver> SamB_XP: updating k elements in, is O(log k). Irrespective of the size of the entire array.
14:05:46 <SamB_XP> ah,
14:05:49 <SamB_XP> I get it now.
14:06:02 <quicksilver> So, my point was that purely functional structures can do better than O(log n)
14:06:06 <quicksilver> but not attain O(1)
14:06:14 <quicksilver> depending exactly what kind of array alogirthm you're talking about
14:06:32 <SamB_XP> is that actually better than O(log(n)) in all cases?
14:07:12 <oerjan> SamB_XP: k <= n/2
14:07:51 <SamB_XP> so... what happens if you apply that to a uniform frequency distribution?
14:08:16 <oerjan> uniform frequency?
14:08:27 <ski> (quicksilver : .. so, ephemereal structures as in Clean and Mercury are not purely functional ?)
14:08:34 <quicksilver> then you get O(log(n/2)) which is O(log (n))
14:08:45 <quicksilver> so it's not a win, in complexity terms
14:08:47 <quicksilver> ;)
14:08:54 <SamB_XP> that's what I thought ;-)
14:09:07 <quicksilver> btu for stuff like priority queues and so on
14:09:12 <quicksilver> you don't expect uniform access
14:09:18 <quicksilver> and the functional structure can do rather well
14:09:23 <quicksilver> ski: good question.
14:09:46 <quicksilver> ski: I guess by purely functional there I meant 'implementable in pure H-M type languages'
14:09:54 <SamB_XP> anyway... it's still not useful for implementing STArray...
14:09:59 <ski> (my answer would be that they are "pure" .. i'm not sure4 however what "purely functional" means)
14:10:09 <quicksilver> ski: I agree it's not a very precise term
14:10:33 <quicksilver> although in my defense, it's the term Okasaki uses :)
14:10:37 <fasta> purely functional == fully-persistent, AFAIK.
14:10:40 <quicksilver> and that is a well known book/thesis.
14:10:41 <SamB_XP> you should get O(1) if you give up persistance ;-)
14:11:02 <fasta> Purely functional is more of a new hype term.
14:11:07 <quicksilver> and of course you can *imagine* compilers which might be able to infer uniqueness constraints.
14:11:11 <pejo> quicksilver, does he use the term in the same sense as Sabry uses it?
14:11:15 <ski> by "pure" here, i roughly mean that you don't have to give up "referential transparency" reasoning
14:11:26 <quicksilver> and therefore beat the complexity of the 'naive' algorithm
14:11:44 <quicksilver> but all the imagination in the world doesn't make such compilers exist, sadly :(
14:11:49 <SamB_XP> fasta: I think purely functional usually impies that you can't backpatch the old versions...
14:12:10 <Philippa> which a good many persistant implementations do
14:12:23 <ski> DiffArray
14:12:23 <SamB_XP> I don't think DiffArray counts, for instance
14:12:32 <Philippa> quicksilver: you don't need the inference to retain pure functionality though
14:12:36 <ski> Splay
14:12:38 <fasta> Philippa: what do you mean?
14:13:06 <dibblego> *persistence, kthxbai
14:13:17 <quicksilver> Philippa: no, but when I speak of the complexity of an algortihm in haskell I'm speaking of its complexity according to a fairly naive execution model.
14:13:29 <quicksilver> Philippa: there are already cases where ghc can beat that complexity class.
14:13:42 <SamB_XP> Splay is totally at odds with purely-functional programming...
14:13:49 <fasta> SamB_XP: wrong.
14:13:51 <fourbissime> hello there. I'm following the wikibook chapter on cabal. I'd like to use "hs-source-dirs" to put my sources inside a src/ directory. but when I add the line, I've got an error saying "A library was specified, but no exposed modules list has been given." - even when I'm simply trying to generate an executable. anyone can tell me what I missed there ?
14:14:02 <SamB_XP> well, it would wreak havoc with laziness...
14:14:09 <Philippa> quicksilver: fair enough, it's arguably a different algorithm with the uniqueness constraint added
14:14:18 <fasta> SamB_XP: ?
14:14:26 <dons> fourbissime: you need to use a library stanza
14:14:32 <quicksilver> Philippa: yes, because algorithm is really an operational thing not a denotational thing.
14:14:33 <dons> library
14:14:36 <sjanssen> fourbissime: you need to put hs-source-dirs in the executable stanza
14:14:42 <dons>   hs-source-dirs:  src
14:14:42 <dons>   ghc-options:     -O2 -Wall -fliberate-case-threshold=1000
14:14:52 <quicksilver> Philippa: but we lazy haskell programmers are used to having a good intuition of operational from denotation.
14:14:52 <dons> or in the executable, depending on what you're writing :)
14:14:55 <SamB_XP> lets put it like this... purely functional programmers don't expect lookup functions to return a new tree...
14:15:38 <fasta> SamB_XP: well, you can tell them :)
14:15:38 <ski> well
14:15:43 <fourbissime> hmm ok. the simple example in the wikibook doesn't talk about this stanza, right ?
14:15:44 <Philippa> right. When a data structure's described as 'purely functional' this means as in implementation, not just interface
14:15:56 <quicksilver> yes
14:16:05 <sjanssen> fourbissime: link?
14:16:06 <quicksilver> although people do sometimes speak of "purely functional interface"
14:16:07 <bauchus> hi, i have a question about haskells Xlib binding...There is a type XKeyEvent, but the keycode is strange. What is it?
14:16:12 <fourbissime> http://en.wikibooks.org/wiki/Haskell/Packaging
14:16:17 <quicksilver> in which case what they really mean is "referentially transparent interface"
14:16:18 <quicksilver> I suspect.
14:16:34 <SamB_XP> fasta: most of the time it would be VERY inconvenient to do anything with the new tree, anyway
14:16:39 <ski> one can imagine the Splay type being a quotient (partition) over some representation type .. then one could "change representation behind covers" as long as the new representation still represents the same equivalence class
14:16:45 <quicksilver> As in "Bytestrings do all kinds of hackery under the hood, but they have a purely functional interface to it"
14:16:48 <sjanssen> bauchus: consider it to be a random number, use one of the keycode to keysym functions
14:16:57 <SamB_XP> quicksilver: yeah, that's exactly what that means
14:17:30 <SamB_XP> ski: that sounds liable to make things worse
14:17:39 <sjanssen> bauchus: the xlib bindings follow C very closely, so any reference (man pages, a tutorial, etc.) for the C library should help
14:17:43 <ski> SamB_XP : in presence of laziness ?
14:17:49 <SamB_XP> ski: yeah
14:17:59 <SamB_XP> I'm not an expert though
14:18:06 <SamB_XP> also, then you have to worry about synchronization
14:18:13 <fasta> SamB_XP: well, I didn't have big problems with it.
14:18:19 <sjanssen> fourbissime: the simple example there does have an executable stanza, it's the paragraph that starts with "executable: "
14:18:26 <ski> SamB_XP : could be .. possibly it works better for strict things
14:18:36 <ski> SamB_XP : *nod*
14:18:44 <fasta> SamB_XP: but I didn't use it in a concurrent setting and I found out later that I implemented it for nothing.
14:18:47 <SamB_XP> that is ... is IORef threadsafe?
14:19:01 <oerjan> SamB_XP: no
14:19:05 <bauchus> sjanssen: thanks. do you have a hint how to get the keysym?
14:19:05 <fasta> SamB_XP: you need an MVar, AFAIK.
14:19:17 <fourbissime> sjanssen: ok, I just found my mistake. I just had to put the line "hs-source-dirs" after the "executable:" line.
14:19:27 <sjanssen> bauchus: IIRC, the function is called keycodeToKeysym
14:19:43 <sjanssen> fourbissime: yes, in the "executable stanza" :P
14:19:46 <SamB_XP> in the sense of "reads of the IORef will always return a value that was stored to that IORef"
14:21:23 <fourbissime> sjanssen: I understand now ... but to me the delimitation of the stanza is not really enforced, thus my mistake :)
14:21:38 <nolrai>  /msg NickServ IDENTIFY miprami
14:21:58 <quicksilver> nolrai: oops :P
14:22:12 <quicksilver> nolrai: you may wish to change that password...
14:22:13 <nolrai> ive done that now like 3 times
14:22:29 <quicksilver> dcoutts: browsing old blog posts, found the gtk2hs L-systems.
14:22:34 <nolrai> yea i should
14:22:34 <quicksilver> dcoutts: really nice! was that you?
14:22:59 <dcoutts> quicksilver: yep, I ran that practical this term for our first year FP course.
14:23:40 <quicksilver> dcoutts: nice :)
14:23:53 <quicksilver> dcoutts: should do an interactive L-system evolution thingy
14:24:36 <dcoutts> quicksilver: what kind of interaction?
14:24:50 <quicksilver> dcoutts: where you display the current system plus 20 "neighbours"
14:24:53 <quicksilver> with slightly different configurations
14:25:03 <quicksilver> if someone clicks a neighbour, that becomes the center
14:25:08 <quicksilver> and you have 20 new neighbours
14:25:15 <quicksilver> so people can explore L-system-space interactively
14:25:21 <nolrai> Whats the strict application operator?
14:25:26 <fasta> $!
14:25:31 <quicksilver> of course, defining 'neighbour' is the tricky bit, probabluy.
14:25:34 <nolrai> fasta++
14:25:42 <fasta> nolrai: that's the wrong command
14:25:57 <dcoutts> quicksilver: interesting
14:26:13 <fasta> @help karma
14:26:13 <lambdabot> karma <polynick>. Return a person's karma value
14:26:28 <LoganCapaldo> <polynick>
14:26:30 <LoganCapaldo> ?
14:26:33 <fasta> Whatever
14:26:38 <LoganCapaldo> why not <nick> ?
14:26:40 <byorgey> fasta: what do you mean?
14:26:45 <nolrai> whats the right one?
14:26:54 <fasta> byorgey: I meant to raise my karma.
14:26:56 <bauchus> sjanssen: thanks a lot! it works. Juchhu!
14:27:10 <LoganCapaldo> @karma fasta
14:27:10 <byorgey> @karma fasta
14:27:11 <lambdabot> fasta has a karma of 3
14:27:11 <lambdabot> fasta has a karma of 3
14:27:16 <LoganCapaldo> fasta++
14:27:21 <LoganCapaldo> @karma fasta
14:27:21 <lambdabot> fasta has a karma of 4
14:27:32 <OceanSpray> And in the end, I didn't have to use fold anyway.
14:27:32 <LoganCapaldo> @karma+ fasta
14:27:33 <lambdabot> fasta's karma raised to 5.
14:27:37 <fasta> Oh, so, it's not. How convenient.
14:27:38 <OceanSpray> So I still have never used fold.
14:28:01 <OceanSpray> I must be a crappy Haskell coder.
14:28:12 <nolrai> @help
14:28:12 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:28:12 <fasta> OceanSpray: that was only introduced in 6.8
14:28:16 <fasta> OceanSpray: ;)
14:28:18 <OceanSpray> fold?
14:28:19 <nolrai> @list
14:28:19 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
14:28:44 <fasta> OceanSpray: yes, there is foldl, foldr and fold.
14:28:47 <dmwit> OceanSpray: foldl and foldr are more specific
14:28:55 <OceanSpray> I meant ANY fold.
14:28:59 <clanehin> the Foldable typeclass?
14:29:01 <fasta> OceanSpray: confusing, isn't it?
14:29:02 <dmwit> fasta: fold is a binary-tree style fold?
14:29:14 <fasta> OceanSpray: I was making an ill-received joke.
14:29:22 <OceanSpray> I didn't get it.
14:29:28 <OceanSpray> I still don't get it.
14:29:37 <OceanSpray> It seems that I will never get it.
14:29:56 <sjanssen> OceanSpray: aren't you a lisp guy?
14:30:02 <OceanSpray> yeah.
14:30:03 <dmwit> :t let fold f (x:y:rest) = f (f x y) (fold f rest) in fold
14:30:09 <lambdabot> forall t. (t -> t -> t) -> [t] -> t
14:30:17 <sjanssen> OceanSpray: they call 'foldl' 'reduce' in lisp land
14:30:25 <OceanSpray> I know what fold is.
14:30:31 <nolrai> @hoogle $!
14:30:31 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
14:30:45 <dmwit> :t fold
14:30:46 <lambdabot> Not in scope: `fold'
14:31:02 <OceanSpray> I'm just noting that I have never used any variant of 'fold' while coding in Haskell.
14:31:31 <byorgey> OceanSpray: it comes up less often than you'd think.
14:31:44 <dmwit> > let fold f d (x:y:rest) = f (f x y) (fold f d rest); fold _ _ [x] = x; fold _ d [] = d in fold (+) 0 [1..32]
14:31:46 <lambdabot>  528
14:33:17 <fourbissime> Simple IO question. I'm trying to delete one line from a text file. right now I have something like this:  http://hpaste.org/4340 and I get an error saying the file is already in use and cannot be written. What is the cause ? Is it the lazy reading of the file which clashes with the writing ? how can I overcome this ?
14:33:52 <oerjan> :t Data.Foldable.fold
14:33:52 <lambdabot> forall (t :: * -> *) m. (Data.Foldable.Foldable t, Monoid m) => t m -> m
14:34:10 <oerjan> dmwit: ^^
14:34:34 <dmwit> Oh, interesting.
14:34:42 <dmwit> Monoid implies a zero and a (+)?
14:34:46 <dmwit> ?src Monoid
14:34:46 <lambdabot> class Monoid a where
14:34:46 <lambdabot>     mempty  :: a
14:34:46 <lambdabot>     mappend :: a -> a -> a
14:34:46 <lambdabot>     mconcat :: [a] -> a
14:34:52 <dmwit> That's pretty clever!
14:35:07 <dibblego> I wrote that function in Scala just yesterday
14:35:31 <byorgey> dmwit: yup, a monoid is a set with an associative binary operation with an identity.
14:35:51 <dmwit> I love how smart Haskell people are. <3
14:36:03 <ultracool> what is violent and threatening behavior? can jerking movement a fidgeting around counts?
14:36:25 <oerjan> o_O
14:36:31 <dibblego> fold just calls foldMap with id iirc
14:36:32 <byorgey> dmwit: my favorite monoid is Endo, which is the set of endomorphisms (functions of type a->a) under composition =)
14:36:37 <dibblego> ?type foldMap
14:36:38 <lambdabot> Not in scope: `foldMap'
14:36:44 <dibblego> ?type Data.Foldable.foldMap
14:36:44 <lambdabot> forall a m (t :: * -> *). (Data.Foldable.Foldable t, Monoid m) => (a -> m) -> t a -> m
14:36:46 --- mode: ChanServ set +o Philippa
14:36:49 <dibblego> ?type Data.Foldable.foldMap id
14:36:50 <lambdabot> forall a (t :: * -> *). (Data.Foldable.Foldable t, Monoid a) => t a -> a
14:36:51 --- kick: ultracool was kicked by Philippa (bye bye bot)
14:36:55 <dibblego> ?type Data.Foldable.fold
14:36:55 <lambdabot> forall (t :: * -> *) m. (Data.Foldable.Foldable t, Monoid m) => t m -> m
14:37:14 --- mode: Philippa set -o Philippa
14:37:24 <dmwit> byorgey: Ah, interesting.  I can't think of a time I'd have liked to use that, though.
14:37:26 <dibblego> def fold[T[_], M](ms: T[M])(implicit fd: Foldable[T], m: Monoid[M]) =
14:37:26 <dibblego>     foldMap[T, M, M](ms)(id)
14:37:29 <dibblego> ;)
14:37:37 * dmwit tries to think of all his a . b . c . d . e . f chains
14:37:43 <oerjan> fourbissime: yep lazy reading tends to make files close later than you want
14:38:48 <smack_> fourbissime: you may want to write to a temp file and then copy it over
14:40:18 <byorgey> dmwit: it's more the sort of thing where you transform a list of some sort of data into a list of functions, and then compose them all into a single function
14:41:05 <OceanSpray> Does Haskell have a numerical tower?
14:41:09 <dmwit> fold . map aComplicatedFunctionTakingTwoArguments -- or so?
14:41:17 <dmwit> :t toLower
14:41:18 <lambdabot> Char -> Char
14:41:30 <dmwit> :t ord . toLower . chr
14:41:30 <lambdabot> Int -> Int
14:41:45 <oerjan> OceanSpray: sort of, though you need to explicitly convert
14:41:52 <oerjan> @instances Num
14:41:52 <lambdabot> Double, Float, Int, Integer
14:41:55 <dmwit> Oh, I read "tower" as "tolower", sorry.
14:42:12 <OceanSpray> whoah.
14:42:35 <OceanSpray> I just got the most vivid case of Deja Vu right now.
14:42:38 <oerjan> @instances-importing Data.Word Data.Int Foreign.Types Num
14:42:38 <lambdabot> Double, Float, Int, Integer
14:42:49 <oerjan> huh?
14:42:57 <oerjan> @instances-importing Data.Word Data.Int Num
14:42:58 <lambdabot> Double, Float, Int, Int16, Int32, Int64, Int8, Integer, Word, Word16, Word32, Word64, Word8
14:43:12 <oerjan> @instances-importing Data.Word Data.Int Foreign Num
14:43:12 <lambdabot> Double, Float, Int, Int16, Int32, Int64, Int8, IntPtr, Integer, Word, Word16, Word32, Word64, Word8, WordPtr
14:43:24 <Toxaris> > 4 :: Rational
14:43:25 <lambdabot>  4%1
14:43:32 <OceanSpray> whoah.
14:43:45 <oerjan> ah yes
14:43:54 <OceanSpray> that's a lot of data types.
14:43:56 <dmwit> > 4 :: Ratio Double Double -- ?
14:43:56 <lambdabot>      Kind error: `Ratio' is applied to too many type arguments
14:43:56 <lambdabot>     In the typ...
14:43:57 <oerjan> @instances-importing Data.Word Data.Int Foreign Data.Complex Data.Ratio Num
14:43:57 <lambdabot> Complex a, Double, Float, Int, Int16, Int32, Int64, Int8, IntPtr, Integer, Ratio a, Word, Word16, Word32, Word64, Word8, WordPtr
14:44:05 <dmwit> > 4 :: Ratio Double -- ?
14:44:06 <lambdabot>   add an instance declaration for (Integral Double)
14:44:06 <lambdabot>     In the expression: 4
14:44:06 <lambdabot> ...
14:44:07 <OceanSpray> Does Haskell have a vector type?
14:44:14 <dmwit> no
14:44:18 <SamB_XP> vector?
14:44:30 <dmwit> Although I think several people have written one, so have a Google for it.
14:44:33 <OceanSpray> like an array
14:44:42 <dmwit> There's certainly Data.Array.
14:44:43 <OceanSpray> best for random access
14:44:47 <clanehin> in the most general sense, a list of tuple is a vector
14:45:01 <clanehin> a list or a tuple, not a list of tuples . . .
14:45:10 <SamB_XP> OceanSpray: we use the word vector for something else
14:45:22 <OceanSpray> magnitude and direction?
14:45:26 <dmwit> yep =)
14:46:00 <OceanSpray> are list traversals O(1)?
14:46:10 <dmwit> O(n), of course
14:46:20 <byorgey> OceanSpray: for length-1 lists, sure =)
14:46:20 <mux> how can a traversal be O(1)?
14:46:22 <OceanSpray> well then, they're not vectors.
14:46:24 <dmwit> (You can't traverse an n-length list in <n-length time.)
14:46:31 <oerjan> OceanSpray: btw there are even more number types that i didn't remember the modules for, foreign C types
14:46:31 <clanehin> > let magnitude = sqrt . sum. map (^2)
14:46:31 <lambdabot>  Parse error at end of input
14:46:43 <clanehin> > @let magnitude = sqrt . sum. map (^2)
14:46:44 <lambdabot>  Parse error at "@let" (column 1)
14:46:44 <dmwit> OceanSpray: I think we may have some terminology problems here.
14:46:56 <clanehin> @let magnitude = sqrt . sum. map (^2)
14:47:00 <lambdabot> Defined.
14:47:04 <OceanSpray> Something like C arrays.
14:47:05 <dmwit> OceanSpray: By "traversal", do you really mean "walking down the list", or do you just mean, "accessing a particular element"?
14:47:11 <clanehin> > magnitude [1,1]
14:47:12 <lambdabot> Terminated
14:47:13 <dmwit> OceanSpray: There is Data.Array, as I've said already.
14:47:20 <OceanSpray> oh whoops
14:47:24 <OceanSpray> I meant access, yeah
14:47:27 <OceanSpray> my bad.
14:47:34 <clanehin> boggle
14:47:40 <dmwit> Okay, access is O(index) for lists, O(1) for Arrays.
14:48:00 <dmwit> > magnitude [1,1]
14:48:00 <lambdabot> Terminated
14:48:05 <ari> Of course list traversal is O(1) for lists that fit in RAM... if you just choose a sufficiently large constant that's always your upper limit :p
14:48:08 <oerjan> :t magnitude
14:48:09 <lambdabot> forall a. (RealFloat a) => Complex a -> a
14:48:09 <nolrai> who ever decided to name c++ vectors vectors was confused.
14:48:22 <dmwit> oh, heh
14:48:30 <dmwit> ?undefine
14:48:35 <lambdabot> Undefined.
14:48:36 <OceanSpray> Scheme calls them vectors too.
14:48:45 <dmwit> ?let mag = sqrt . sum . map (^2)
14:48:45 <lambdabot> Defined.
14:48:47 <dmwit> > mag [1,1]
14:48:48 <lambdabot>  1.4142135623730951
14:48:49 <nolrai> realy?
14:48:51 <clanehin> \me is failing to illustrate the point that vectors as in "arrays" and vectors as in geometry aren't fundamentally different
14:48:54 <OceanSpray> yeah
14:48:57 <SamB_XP> scheme is dynamically typed
14:49:06 <OceanSpray> #(1 2 3 4) defines a vector.
14:49:07 <dmwit> clanehin: They *are* fundamentally different.
14:49:16 <Pastorn> how do i enforce typeclass restrictions on a datatype?
14:49:25 <dmwit> clanehin: Lists of different lengths are still compatible, but vectors of different lengths are not.
14:49:27 <SamB_XP> they aren't fundamentally different in dynamicly-typed systems
14:49:32 <Pastorn> data TwoFourTree a = ...
14:49:32 <Toxaris> > array (0, 10000) [(10000, "hello world")] ! 10000 -- allocates a 10k-array with only one element actually defined, and accesses that element without traversing the others
14:49:33 <lambdabot>  "hello world"
14:49:43 <dmwit> Pastorn: Prefer to enforce that only on functions using that data type.
14:49:52 <dibblego> Pastorn, you don't; only on each function
14:50:02 <dmwit> Pastorn: It's possible, but just don't do it. ;-)
14:50:18 <Pastorn> but a Two-Four-tree will ALWAYS require ord
14:50:33 <dmwit> Not an empty one. ;-)
14:50:40 <clanehin> dmwit: depends on the operation, some operations have more specific domains than others, yes
14:50:55 <Pastorn> except for the empty node and a tree with just one element
14:51:06 <oerjan> Pastorn: you won't get away from annotating the functions in any case
14:51:34 <oerjan> (assuming you declare their types at all)
14:52:08 <Pastorn> fine, i give up...
14:53:35 <OceanSpray> ok, right now I have data LispVal = Number Integer
14:54:06 <OceanSpray> and I have +, -, and * implemented.
14:54:45 <OceanSpray> what should I replace 'Integer' with in order to be able to implement division?
14:55:02 <oerjan> Double or Rational
14:55:04 <quicksilver> what kind of devision?
14:55:09 <OceanSpray> all kinds.
14:55:11 <quicksilver> > 18 `div` 5
14:55:13 <lambdabot>  3
14:55:18 <quicksilver> Integers do support division, of a sort
14:55:20 <byorgey> @type (/)
14:55:21 <lambdabot> forall a. (Fractional a) => a -> a -> a
14:55:27 <oerjan> > 18 / 5
14:55:27 <lambdabot>  3.6
14:55:33 <byorgey> so, anything that is Fractional.
14:55:37 <byorgey> @instances Fractional
14:55:37 <lambdabot> Double, Float
14:55:43 <quicksilver> Rational would be your infinite precision option
14:55:45 <byorgey> Rational counts too.
14:55:59 <quicksilver> Double would be the natural cheap machine fpu option
14:55:59 <OceanSpray> rational it is, then, for now.
14:56:04 <oerjan> Complex Double if you want to be fancy
14:56:12 <quicksilver> @instances-importing Data.Ratio Fractional
14:56:13 <lambdabot> Double, Float, Ratio a
14:56:14 <Toxaris> OceanSpray: if you want to mimic lisp's behaviour, you may need to auto-convert values
14:56:16 <quicksilver> there it is :)
14:56:25 <nolrai> > (234 % 56) / 4
14:56:26 <lambdabot>  117%112
14:56:39 <Toxaris> OceanSpray: data LispVal = Integer Integer | Double Double | ...
14:57:06 <dmwit> I'd like a Double Double, that's some double trouble!
14:57:07 <OceanSpray> But that's not good.
14:57:22 <Toxaris> OceanSpray: no it's not, but it's lispy, isn't it?
14:57:33 <OceanSpray> Maybe data LispNum = Int Integer | Doub Double | ...
14:57:43 <OceanSpray> and then data LispVal = Number LispNum
14:57:52 <dbueno> OceanSpray, Int is also a Haskell data type name.
14:58:02 <chessguy> OceanSpray, i don't think "Myabe data..." is valid syntax :)
14:58:12 <Toxaris> OceanSpray: yes you can divide these, but why?
14:58:18 <OceanSpray> why?
14:58:27 <OceanSpray> hold on
14:58:36 <OceanSpray> @hpaste
14:58:36 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:59:17 <hpaste>  OceanSpray pasted "part of LispData.hs" at http://hpaste.org/4341
14:59:49 <OceanSpray> because LispVal can be all sorts of other stuff, too
14:59:55 <koala_man> I have a function that goes through a list and adds to/gets from a Data.Map. it uses hundreds of MBs of ram. if I have "trace (show $ Data.Map.size m) $ foo m" it just uses 20mb. I tried "foo ((Data.Map.size m) `seq` m)" but it doesn't help. what can I do?
15:00:05 <koala_man> it's kind of long and horrible so I don't know if I should paste it
15:00:51 <dmwit> koala_man: Maybe "Data.Map.size m `seq` foo m" would be closer to the "trace" version.
15:01:11 <bos> koala_man: you're probably leaking memory like crazy
15:01:23 <dmwit> koala_man: You can also paste it on hpaste.org if you want us to have a look.
15:01:42 <oerjan> koala_man: Data.Map is already strict in the structure of the map - you need to seq the contained values i guess
15:01:52 <bos> koala_man: the first function you need to know about is the insertWith' function
15:01:53 <koala_man> I use insertWith'
15:01:57 <bos> \hmm
15:02:04 <oerjan> oh
15:02:20 <bos> it's possible you're being lazy in whatever you're traversing to construct the map, too
15:02:39 <koala_man> dmwit: hmm, that did the trick
15:02:41 <bos> so you've eliminated the usual most obvious leak, but there are still a few common candidatres
15:02:55 <koala_man> what's the difference?
15:03:11 <oerjan> koala_man: what is the type of the values in the map? insertWith' would only evaluate them to the top constructor
15:03:38 <oerjan> it worked? o_O
15:03:40 <koala_man> oerjan: Map String [Cow], for Cow Integer String String
15:03:57 <quicksilver> values are fully lazy, in maps
15:04:16 <bos> if seq on the size of the map is fixing the leak, then the leak is probably occurring before you ever build the map
15:04:39 <koala_man> m `seq` foo m  works too
15:04:52 <quicksilver> yes, what bos said
15:05:00 <quicksilver> I bet you're building up a huge thunk of inserts
15:05:09 <quicksilver> your seq will fix that
15:05:26 <Toxaris> OceanSpray: hmm ok, since "dynamically typed numbers" is a sensible type in itself, it makes sense to have it as stand-alone type. (and it's hard enough to get it correct, so you may want to quickcheck it etc)
15:05:26 <koala_man> I do, but I added seqs all over the place with no luck
15:05:30 <bos> koala_man: where are you calling the inserts from, a fold?
15:06:02 <bos> koala_man: i bet you're using foldr or foldl
15:06:06 * dmwit bets foldl' would solve a bunch of problems
15:06:08 <sorear> reading through the (poly)ml standard libraries, see a whole bunch of repititions of
15:06:09 <bos> either of which would explain the leak
15:06:28 <bos> dmwit: stereo :-)
15:06:30 <gabor> dons: around?
15:06:32 <sorear> 	eqtype dev / val wordToDev : SysWord.word -> dev / val devToWord : dev -> SysWord.word
15:06:41 <sorear> makes me appreciate newtype a lot more :)
15:06:42 <koala_man> bos: almost, it's a tail recursive function that adds stuff to a map (and looks up some) for every element
15:06:50 <bos> koala_man: that's your problem, then
15:06:59 <bos> tail recursive functions are thunky
15:07:03 <xinming_> anyone here would tell me a channel about asking boolean algebra question? :-)
15:07:20 <dmwit> Maybe #math?
15:07:28 <xinming_> thanks.
15:07:39 <xinming_> sorry to distrube. :-)
15:07:43 <bos> koala_man: you're probably only partially forcing the construction of your map when you look it up, and it's not enough to offset the insertions that are getting thunked
15:07:47 <dmwit> ?hpaste
15:07:47 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:07:59 <dmwit> koala_man: We can help. =)\
15:08:06 <dmwit> uhh... -/
15:08:10 <bos> koala_man: here's a quick fix. compile with -fbang-patterns, and put a ! in front of the parameter of your function that is the map
15:08:15 <koala_man> bos: why didn't the  foo (Data.Map.size m `seq` m) help?
15:08:28 <bos> koala_man: because the seq has to be on the outside there
15:08:40 <oerjan> koala_man: Data.Map.size m `seq` m is equivalent to m
15:08:43 <bos> i.e. Data.Map.size m `seq` foo m
15:09:02 <dmwit> koala_man: It's because "foo" is also lazy, so putting the strictness "inside" the laziness doesn't help.
15:09:38 <koala_man> I think I get it
15:09:42 <bos> who said laziness was hard?
15:10:31 <dmwit> ?quote laziness is hard
15:10:31 <lambdabot> No quotes for this person. Maybe if you used more than just two fingers...
15:10:41 <dmwit> Nobody, I guess. ;-)
15:10:51 <bos> dmwit: you mustn't read enough reddit :)
15:11:09 <koala_man> foo looks up stuff using the map so I figured it would evaluate the seq part
15:11:16 <dmwit> I'll have to up my quota from 8 hours/day to 12, then. =)
15:12:15 <bos> koala_man: that may or may not occur, depending on how foo is structured
15:12:54 <koala_man> will m `seq` foo m evaluate all the elements of the map?
15:13:13 <dmwit> I doubt it.
15:13:49 <dmwit> It will, however, evaluate the structure of the map, collapsing any thunks having to do with a dynamically-generated list of elements.
15:14:29 <dufflebunk> The (>=>) monad looks like it's meant to be used as an infix operator, but takes three values... How would you use it infix?
15:14:49 <quicksilver> dufflebunk: that's just a trick of currying
15:14:50 <dufflebunk> oops, the (>=>) monad /function/
15:14:59 <quicksilver> dufflebunk: morally it's two inputs, one output
15:15:01 <kpreid> dufflebunk: (a >=> b) c
15:15:10 <quicksilver> (a -> mb) -> (b -> mc) -> (a -> mc)
15:15:17 <quicksilver> dufflebunk: it's like composition
15:15:19 <quicksilver> :t (.)
15:15:20 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
15:15:24 <byorgey> dufflebunk: really, all functions take only one input anyway =)
15:15:32 <kpreid> @index >=>
15:15:32 <lambdabot> bzzt
15:15:45 <allbery_b>  @index is too old to knw about it
15:15:46 <bos> oh, nice. some russian hackers have written a bot that sits in sex chatrooms, and tries to winkle personal information out of unwitting marks. now there's a novel deployment of a nondeterminism monad.
15:15:49 <quicksilver> dufflebunk: it's (.) somehow promoted to functions whhich are 'monadic on the right'
15:15:50 <allbery_b> but it's Control.Monad
15:15:50 <dufflebunk> Ah, ok.
15:16:06 <quicksilver> dufflebunk: otherwise known as kleisli arrows
15:17:14 <kpreid> @type >>=
15:17:15 <lambdabot> parse error on input `>>='
15:17:18 <kpreid> @type (>>=)
15:17:19 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
15:17:27 <kpreid> (been so long that I've almost forgotten...)
15:17:34 <dmwit> Is there any logic to the ordering of '>', '<', and '=' in the various monad operators?
15:17:45 <quicksilver> a bit, yes
15:17:51 <quicksilver> they show the direction the values flow
15:18:03 <dmwit> Nothing finer-grained, though, like in Applicative, right?
15:18:05 <quicksilver> there is logic to the difference between > and < at least
15:18:12 <dmwit> yeah
15:18:25 <quicksilver> I'm not aware of any particular logic to the different between >>, >>= and >=> though
15:18:52 <quicksilver> >>= looks like you can 'see' where the value gets piped
15:18:59 <quicksilver> and >=> looks 'like >>= but different' :)
15:19:19 <dmwit> Heh, I was wondering if that was the motivation. =P
15:21:14 <bparkis> suppose i have a set of facts all of the form predicate(arg1, arg2) and i will be receiving queries of the form pred(arg1, _), or pred(_, arg2), or pred(arg1, arg2), or some conjunction of queries of that form
15:21:34 <bparkis> how can i store those facts in such a way that those queries are answered quickly?
15:22:27 <bparkis> explaining notation a query of the form pred(arg1, _) means give me all facts of the form pred(arg1, substitution) for any substitution
15:22:49 <quicksilver> I imagine you need two Data.Maps
15:22:52 <koala_man> ah crap, my function never actually looked things up in the map due to some failing regexps. when it did, things worked substantially better
15:22:53 <quicksilver> would be the simple naive approach
15:23:01 <quicksilver> one 'indexed' by arg1
15:23:04 <quicksilver> one 'indexed' by arg2
15:23:19 <quicksilver> Map Arg1 [Arg2] and Map Arg2 [Arg1]
15:23:39 <bparkis> and for example pred(arg1, _) AND pred2(_, arg1) means give me all facts of the form pred(arg1, subst) that also satisfy pred2(subst2, arg1) for any subst and subst2
15:24:03 <quicksilver> well list operations may be quite sufficient for that
15:24:13 <quicksilver> but if the lists were really huge, you might replace [] with Data.Set
15:24:13 <bparkis> but there may be a faster way
15:24:22 <quicksilver> to get asymptotically faster intersection calculation
15:24:37 <quicksilver> for moderate sized data I would think list operations would be fine.
15:24:59 <bparkis> ideally i could avoid performing intersection if i can help it
15:25:29 <quicksilver> how would you propose to do an AND query without calculating the intersection?
15:26:04 <bparkis> one way for small queries is to simply pre-store the answer to queries of that form
15:27:48 <quicksilver> well I would start with the simplest specification of your problem
15:27:55 <quicksilver> which is probably in terms of Maps
15:27:59 <quicksilver> and work towards correctness
15:28:20 <quicksilver> once you have correctness, if things are too  slow, identify the source of slowness and improve that bit :)
15:28:27 <quicksilver> much time can be wasted in premature optimisation.
15:34:35 <cpfr> hey is they any function that generalizes flip, so arbitrary arguments can be flipped within it
15:35:10 <quicksilver> well, you can write one
15:35:15 <quicksilver> for particular cases
15:35:16 <clanehin> cpfr: you can use a lambda  \f a b c d -> g b d c a
15:35:26 <conal> cpfr: try: ((.).(.).(.)) flip, e.g.,.
15:35:36 <conal> @ty ((.).(.).(.)) flip
15:35:37 <lambdabot> forall a a1 a2 a3 b c. (a -> a1 -> a2 -> a3 -> b -> c) -> a -> a1 -> a2 -> b -> a3 -> c
15:36:10 <clanehin> I type everything wrong today
15:37:00 <cpfr> thanks conal
15:37:08 <conal> :)
15:37:22 <cpfr> im amazed how you did that
15:37:36 <conal> cpfr: you can get non-adjacent swaps by composing adjacent swaps.
15:38:01 <conal> cpfr: i thought of it because of what i went through in figuring out DeepArrow for Eros
15:38:03 <cpfr> though i meant more like gflip 3 = (a->b->c->d)->c->a->b->d
15:38:04 <conal> @wiki DeepArrow
15:38:04 <lambdabot> http://www.haskell.org/haskellwiki/DeepArrow
15:38:11 <conal> @wiki Eros
15:38:11 <lambdabot> http://www.haskell.org/haskellwiki/Eros
15:38:20 <quicksilver> cpfr: taht wouldn't be well typed
15:38:39 <quicksilver> cpfr: it would have a different type for each 'n'
15:39:02 <conal> cpfr: i doubt haskell's type system is powerful enough for your gflip.
15:39:26 <cpfr> i suspected it might require a dependently typed system
15:41:56 <cpfr> but i try to avoid going down that road when i can
15:42:15 <conal> on the other hand, haskell typing has done some other pretty tricky stuff, e.g., printf.  maybe if you encoded your numbers into types and used a type class.
15:43:05 <Toxaris> hehe what about a gflip wich does "the right thing" (tm) ?
15:43:14 <ddarius> Yeah, it should be pretty straight forward to do with type level naturals.
15:43:17 <quicksilver> conal: the problem is that (a->b) overlaps with (a->b->c)
15:43:26 <quicksilver> conal: at least, that's my conceptual problem with it...
15:43:41 <Toxaris> didn't we learn about IsFunction from the -cafe lately?
15:43:41 <quicksilver> so I can't see how to make a non-overlapping typeclass for that.
15:43:50 <dmwit> quicksilver: The type of the natural number would differentiate between them.
15:44:11 <quicksilver> dmwit: but what type would gflip have?
15:44:28 <quicksilver> (Nat n) => n -> X -> Y
15:44:34 <quicksilver> what are X and Y?
15:44:44 <cpfr> functions
15:44:49 <quicksilver> well, indeed :)
15:44:58 <quicksilver> but actually, no they're types
15:45:03 <quicksilver> and I mean to ask, what types are they?
15:45:06 <cpfr> oh crap
15:45:34 <dmwit> class Flippable n a b c where gflip :: (a -> b -> c) -> (b -> a -> c) -- ?
15:45:46 <dmwit> To put the nth argument first?
15:45:55 <cpfr> yes
15:45:57 <dmwit> Although I'm not totally sure, I haven't done any type-level programming before. =P
15:46:13 <cpfr> i havent trailblazed
15:46:27 <cpfr> @ty (.)(.)
15:46:28 <lambdabot> forall b c a a1. (a1 -> b -> c) -> a1 -> (a -> b) -> a -> c
15:47:01 <Pastorn> @let tits = (.) . (.)
15:47:04 <lambdabot> Defined.
15:47:07 <Pastorn> yay
15:47:44 <Pastorn> @type and $ zipWith (&&)
15:47:44 <lambdabot>     Couldn't match expected type `[Bool]'
15:47:44 <lambdabot>            against inferred type `[Bool] -> [Bool] -> [Bool]'
15:47:44 <lambdabot>     In the second argument of `($)', namely `zipWith (&&)'
15:47:59 <dmwit> :t and
15:47:59 <lambdabot> [Bool] -> Bool
15:48:07 <dmwit> :t and . zipWith (&&)
15:48:07 <Pastorn> @type and `tits` (zipWith (&&))
15:48:07 <lambdabot>     Couldn't match expected type `[Bool]'
15:48:07 <lambdabot>            against inferred type `[Bool] -> [Bool]'
15:48:07 <lambdabot>     In the second argument of `(.)', namely `zipWith (&&)'
15:48:07 <lambdabot> Not in scope: `tits'
15:48:14 <dmwit> oh, right
15:48:24 <dmwit> :t (and .) . zipWith (&&)
15:48:25 <lambdabot> [Bool] -> [Bool] -> Bool
15:48:40 <Pastorn> why can't she remember tits?
15:48:49 <cpfr> hmm so if I used a naturalnumber  typeclass it might be possible
15:48:51 <Pastorn> or see it...
15:48:51 <quicksilver> dmwit: that's not right, no.
15:48:58 <quicksilver> @type doesn't know about @let
15:48:58 <lambdabot> parse error on input `let'
15:49:00 <Toxaris> :t L.tits
15:49:00 <lambdabot> Couldn't find qualified module.
15:49:08 <dmwit> :t (and .) . (++)
15:49:09 <lambdabot> [Bool] -> [Bool] -> Bool
15:49:10 <quicksilver> dmwit: it's the nth argument...
15:49:18 <quicksilver> dmwit: but 'a' is clearly only one argument
15:49:31 <quicksilver> dmwit: so b is 'definitely' 2nd, and you've jsut written flip.
15:49:47 <quicksilver> dmwit: it's only the tail (c) that might represent many.
15:50:28 <Toxaris> class Flippable n f x g where gflip :: n -> f -> x -> g
15:50:57 <quicksilver> I think the best you can do is probably class GFlip n a b | n -> a, n -> b where gflip :: n -> a -> b
15:51:01 <quicksilver> which is rather a copout :)
15:51:08 <quicksilver> since the work is all done in the instances.
15:51:14 <quicksilver> the type doesn't really tell you what it means.
15:51:42 <ddarius> quicksilver: The type of a function doesn't really tell you what the function means either.
15:51:46 <quicksilver> instance GFlip (Succ Zero) (a -> b -> c) (b -> a -> c)
15:51:55 <ddarius> class declarations are like types in a type-level language.
15:52:09 <quicksilver> instance GFlip (Succ (Succ Zero)) (a -> b -> c -> d) (c -> a -> b -> d)
15:52:19 <quicksilver> ddarius: I know what I meant, damnit :P
15:52:22 <dmwit> In any case, I think *using* such a class would be more painful than just writing the appropriate lambda. ;-)
15:52:36 <ddarius> Indeed.
15:52:46 <quicksilver> ddarius: my point is you could implement that GFlip class in ways which had nothing to do with flipping.
15:52:58 <cpfr> true but its a nice abstraction mechanism, reminds me of template traits
15:53:00 <quicksilver> ddarius: they class signature completely failed to indicate the flippiness of it all.
15:55:07 <ddarius> quicksilver: And my point is that this is no different from a normal type for a normal value.
15:55:35 <dmwit> Well, I think djinn shows that at least some types indicate an implementation.
15:55:49 <dmwit> (As long as you aren't using unsafePerformIO or something weird like that.)
15:56:09 <ddarius> dmwit: Indeed, but that's a relatively small set.
15:56:20 <cpfr> what i wondered was if something like Succ N could be done that indicated typing rules
15:58:08 <dons> who's this? http://programming.reddit.com/info/62fte/comments/c02mgu8
15:58:12 <dons> must be someone in here...
15:58:29 <dons> :)
16:03:05 <gabor> dons: heisenbug.blogspot.com/2007/12/only-one-of-each-please.html (but please only post it to reddit if you like it! ;-)
16:03:42 <dmwit> gabor: You could always post it to reddit yourself... ;-)
16:03:55 <gabor> that is cheating
16:04:16 <dmwit> Not really, it's explicitly encouraged under reddit's FAQ.
16:04:57 <diltsman> I've been having some problems with if/then/else and layout.  Could anybody advise me as to how they interact?
16:06:13 <dmwit> diltsman: In a do-block, the "then/else" bit must be indented differently than the "if" bit.
16:06:40 <dmwit> diltsman: That's pretty much the only rule, and as somebody explained to me yesterday, it happens because each line of a do-block is supposed to be a single expression.
16:06:51 <dons> oh, nice gabor
16:08:39 <diltsman> So, where do I put indents?  I tend to want to put something like: if (boolean statement) then<newline><indent>(statement)<newline><un-indent>else<newline><indent>(statement)
16:08:40 <quicksilver> ddarius: well, in particular, the type for flip constrains its implementation
16:08:48 <quicksilver> ddarius: and it was flip we were generalising
16:09:07 <quicksilver> diltsman: that's fine as long as the if isn't in a layout block, i.e. do block
16:09:08 <gabor> dons: will take some time till Haskell can pull this feat
16:09:18 <diltsman> Ok, how does it work IN a do block?
16:09:28 <quicksilver> diltsman: you need at least 1 more space before else than if
16:09:32 <diltsman> What do I have to change for that?
16:09:33 <quicksilver> diltsman: because it's aprt of the same expression
16:09:37 <Toxaris> diltsman: indent the "else" more then the "if"
16:09:45 <diltsman> Ok.  That makes sense.
16:09:51 <quicksilver> diltsman: if else is at the same column as if, they're separate "lines" in the do block
16:09:55 <quicksilver> and that's syntactically invalid
16:10:04 <quicksilver> do { if foo then bar ; else baz }
16:10:14 <quicksilver> ^^ invalid, cos "else" isn't the start of an expression.
16:10:20 <diltsman> Sweet.  I've been having trouble understanding.  That helps.
16:10:35 <quicksilver> although, I thought some version of ghc had a workaround for this particular edge case?
16:10:37 <diltsman> That fixed it, thanks.
16:10:49 <diltsman> I'm using ghc 6.8.1
16:10:49 <quicksilver> which I was not convinced was a good idea, since I think it's good to understand :)
16:10:54 <quicksilver> ah, I must be misinformed then
16:10:57 <diltsman> Agreed.
16:10:59 <quicksilver> I'm sure I read that somewhere
16:11:07 <quicksilver> but then, I read a lot and my memory is flawed :)
16:11:17 <mauke> :t many
16:11:18 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f [a]
16:11:37 <quicksilver> mauke: that's a little-used combinator, I'll wager!
16:11:39 <Toxaris> diltsman: I recommend this (wich saves one line containing only "else" and looks more functional in my eyes):
16:11:39 <Toxaris> if <condition>
16:11:39 <Toxaris>   then <branch>
16:11:39 <Toxaris>   else <other branch>
16:12:03 <quicksilver> mauke: I've never really grokked the possible use-cases for Alternative.
16:12:19 <dmwit> I also use that layout, I think it looks nice.
16:12:41 <twanvl_> quicksilver: http://hackage.haskell.org/trac/haskell-prime/wiki/DoAndIfThenElse?
16:12:43 <lambdabot> Title: DoAndIfThenElse - Haskell Prime - Trac, http://tinyurl.com/2jbxun
16:13:31 <quicksilver> twanvl_: exactly.
16:13:35 <quicksilver> twanvl_: including "This has been recently added to jhc, GHC and Hugs, and so far it has not caused any problems"
16:13:45 <quicksilver> twanvl_: I *did* read it somewhere.
16:13:48 <quicksilver> apparently it's not true?
16:13:56 <twanvl_> You probably need -fglasgow-exts
16:14:07 <quicksilver> well, I thik it's a bad idea
16:14:08 <quicksilver> ;)
16:14:14 <diltsman> Now, haskell doesn't require a newline at the end of a source file, like C, right?
16:14:18 <quicksilver> I think it's good to understand layout desugaring
16:14:26 <quicksilver> diltsman: I don't think so
16:14:58 <mauke> it should :/
16:15:36 <toad_> @hoogle sequence
16:15:37 <lambdabot> Prelude.sequence :: Monad m => [m a] -> m [a]
16:15:37 <lambdabot> Control.Monad.sequence :: Monad m => [m a] -> m [a]
16:15:37 <lambdabot> Data.Traversable.sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
16:16:24 <mauke> hmm, this many looks overly general: many :: (Monad m1, Monad m) => (m1 [a1] -> m [a] -> m1 [a1]) -> m1 a1 -> m1 [a1]
16:17:46 <twanvl_> That is a completely different 'many' than the one from Applicative
16:17:49 <toad_> is there a lazy version of sequence?
16:18:06 <mauke> twanvl_: yes
16:18:26 <twanvl_> lazy how?
16:18:32 <glguy> ?seen dons
16:18:32 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 4m 54s ago.
16:18:45 <quicksilver> toad_: sequence is as lazy as the monad containing it.
16:18:53 <quicksilver> toad_: it's certainly possible to have a monad with lazy >>
16:19:15 <Toxaris> > runIdentity $ (sequence undefined) >> return 5
16:19:16 <toad_> well let me explain what I tried
16:19:18 <lambdabot>  5
16:19:33 <toad_> chars <- sequence $ repeat getChar
16:19:35 <Toxaris> > runIdentity $ (sequence [undefined, return 5]
16:19:35 <lambdabot> Unbalanced parentheses
16:19:42 <Toxaris> > runIdentity $ sequence [undefined, return 5]
16:19:42 <lambdabot>  Undefined
16:19:43 <toad_> then passed chars into mapM printChar
16:19:46 <quicksilver> toad_: yeah. the IO monad can't do that.
16:19:49 <toad_> But the first is an infinite loop
16:21:04 <quicksilver> because of what the type "IO [a]" means
16:21:14 <quicksilver> it means "do a bunch of IO, and then produce a list [a]"
16:21:23 <quicksilver> the IO can't be interleaved within the list, it's all up-front
16:21:29 <quicksilver> that's the nature of the beast
16:21:30 <toad_> ok, so the answer is to just leave it [IO a] and pass that into something?
16:21:38 <quicksilver> you can cheat with unsafeinterleave if you want
16:21:40 <Toxaris> > last $ runIdentity $ (sequence_ [undefined, return 5]
16:21:40 <lambdabot> Unbalanced parentheses
16:21:43 <OceanSpray> The Parsec page is timing out on me
16:21:45 <quicksilver> but that's evil :)
16:21:45 <Toxaris> > last $ runIdentity $ sequence_ [undefined, return 5]
16:21:45 <lambdabot>  Couldn't match expected type `[a]' against inferred type `()'
16:21:49 <Toxaris> > last $ runIdentity $ sequence [undefined, return 5]
16:21:49 <lambdabot>  5
16:21:52 <Toxaris> :)
16:22:12 <OceanSpray> I need the documentation. Dang.
16:22:13 <toad_> Ahh, that explains how getcontents does it.
16:22:44 <quicksilver> toad_: exactly. it cheats :)
16:22:50 <quicksilver> @src getContents
16:22:50 <lambdabot> getContents = hGetContents stdin
16:22:53 <toad_> thanks qs
16:22:56 <quicksilver> @src hGetContents
16:22:56 <lambdabot> Source not found. Do you think like you type?
16:23:09 <quicksilver> toad_: some people, me included, this is a bad thing :)
16:26:35 <dbueno> quicksilver: Think getContents' laziness is a bad thing?
16:27:00 <quicksilver> dbueno: yeah.
16:27:26 <dbueno> quicksilver: Difficult to predict behavior?
16:27:33 <dons> its useful to have both strict and lazy, depending on what your use is
16:28:02 <dons> dbueno: more that you lose fine grained control of resources
16:28:17 <dons> so as soon as you open more than say, 100 files, you have to use strict io
16:28:23 <dons> which is fine: we have libs for that.
16:28:39 <dbueno> dons, Ah, right. But for one file you're likely okay.
16:29:02 <dons> yeah. the only case that comes to mind is when you want to write back onto the file you're reading from
16:29:13 <dons> i.e. mutable files. there you'll also need strict io
16:29:37 <quicksilver> I don't really dispute that both are useful
16:29:41 <quicksilver> the argument is about the correct default
16:29:51 <quicksilver> also, I get upset by the terminology
16:29:56 <quicksilver> (then, I'm a sensitive kind of guy!)
16:30:03 <quicksilver> since there is safe laziness and unsafe laziness
16:30:21 <Toxaris> another problematic use case is testing in ghci and not reading all of the file. the second test case can't open the file again, because the first hasn't closed it yet
16:30:53 <twanvl_> lazy getContents is pretty safe, it is when using files that the problems start
16:30:55 <quicksilver> Toxaris: sounds like it probably only bites you on OSes with exclusive file locks as default ?
16:30:58 <koala_man> how do I remove leading and trailing whitespace from a String?
16:31:20 <Toxaris> quicksilver: maybe. it's a problem on windows
16:31:20 <quicksilver> Toxaris: but there is an analagous problem with sockets which is also annoying.
16:31:35 <quicksilver> Toxaris: windows locks files by default, unix-based OSes don't. As a rule.
16:31:35 <dons> > let clean = reverse . dropWhile isSpace . reverse in clean . clean $ "   some stuff   "
16:31:35 <Toxaris> quicksilver: when developing parsers
16:31:37 <lambdabot>  "   some stuff"
16:31:45 <twanvl_> > let trim = dropWhile isSpace . reverse . dropWhile isSpace . reverse in trim "  test  "
16:31:45 <lambdabot>  "test"
16:31:55 <dons> > let clean = reverse . dropWhile isSpace in clean . clean $ "   some stuff   "
16:31:55 <lambdabot>  "some stuff"
16:32:02 <glguy> no no no, you don't want to use reverse :-p
16:32:03 <quicksilver> unless the haskell IO library does something
16:32:07 <quicksilver> which I don't think it does
16:32:14 <mauke> > join (.) (reverse . dropWhile isSpace) "  x  "
16:32:15 <lambdabot>  "x"
16:32:21 <dons> nice mauke
16:32:35 <twanvl_> > unwords . words $ "  x  " -- this does other things as well
16:32:35 <lambdabot>  "x"
16:32:41 <glguy> let trimRight = foldr (\x xs -> case xs of " " -> [x]; _ -> x:xs) []
16:32:54 <mauke> glguy: why not reverse?
16:32:59 <dbueno> :t join
16:33:00 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
16:33:12 <glguy> mauke, no reason to go to the end of the string until you have to
16:33:23 <glguy> mauke, the reverse / reverse method is wastful, doesn't stream :)
16:33:48 <Toxaris> how can trimRight stream?
16:34:03 <glguy> non-space characters will never been removed
16:34:04 <quicksilver> by reading ahead through whitespace
16:34:08 <glguy> so when it sees one it can return it outright
16:34:09 <quicksilver> caching it locally
16:34:19 <quicksilver> and throwing it away only if the string turns out to end
16:34:21 <Toxaris> (hmm ok it only has to find the next non-whitespace, not the end of the string)
16:34:24 <quicksilver> considerably more fiddly to write.
16:34:25 <mauke> > foldr (\x xs -> case xs of " " -> [x]; _ -> x:xs) [] "   foo   bar   "
16:34:26 <lambdabot>  "   foo   bar"
16:34:31 <twanvl_> > let trimRight = foldr (\x xs -> case xs of " " -> [x]; _ -> x:xs) [] in trimRight $ " x " ++ cycle "stuff"
16:34:32 <glguy> quicksilver, yeah, so you write it once and move on :)
16:34:33 <lambdabot>  Exception: stack overflow
16:34:54 <mauke> > foldr (\x xs -> case xs of " " -> [x]; _ -> x:xs) [] " "
16:34:55 <lambdabot>  " "
16:34:58 <mauke> glguy: fail
16:35:09 <sjanssen> glguy: that doesn't stream either
16:35:09 <glguy> well its fixable without resorting to reverse
16:35:25 <sjanssen> glguy: "case xs of" means O(n) stack use
16:35:46 <glguy> OK, so my solution was as bad as the reversing one
16:35:51 <glguy> but that doesn't mean that reversing is good :-p
16:36:22 <dons> http://programming.reddit.com/info/62i9j/comments/ 'Unit testing in Haskell '
16:36:34 <sjanssen> hmm, what is the optimal solution?
16:36:35 <koala_man> how do I remove leading and trailing whitespace from a String?
16:36:42 <glguy> mauke, and your example only works because you dropped the "dropWhile isSpace"
16:37:29 <twanvl_> > let trimRight = foldr (\x xs -> if isSpace x && null xs then "" else x:xs) [] in trimRight " trim me "
16:37:30 <lambdabot>  " trim me"
16:37:32 <dons> koala_man: what an odd question. we'v just been discussing it for 5 mins :)
16:37:40 <twanvl_> > let trimRight = foldr (\x xs -> if isSpace x && null xs then "" else x:xs) [] in trimRight " trim me " ++ cycle "stuff"
16:37:41 <lambdabot>  " trim mestuffstuffstuffstuffstuffstuffstuffstuffstuffstuffstuffstuffstuffst...
16:37:43 <koala_man> oh, freaky
16:37:48 <dons> > join (.) (reverse . dropWhile isSpace) "  x  "
16:37:48 <lambdabot>  "x"
16:37:55 <dons> koala_man: based on your original question
16:37:57 <Saizan> > let trimRight = foldr (\x xs -> x: case xs of " " -> []; _ -> xs) [] in take 10 . trimRight $ " x " ++ cycle "stuff"
16:37:58 <lambdabot>  " x stuffst"
16:38:05 <koala_man> damn, I asked. wow, I thought I didn't
16:38:08 <Saizan> guarded recursion ftw :)
16:38:50 <koala_man> sorry and thanks :P
16:44:13 <dcoutts> @type join (.)
16:44:14 <lambdabot> forall b. (b -> b) -> b -> b
16:45:24 <dmwit> > let trimRight = foldr (\x xs -> x: case xs of " " -> []; _ -> xs) [] in trimRight "huh    "
16:45:25 <lambdabot>  "huh"
16:46:29 <nolrai> @type foldl
16:46:30 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
16:46:48 <dmwit> :t foldl' -- often better in terms of performance
16:46:49 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
16:47:02 <dcoutts> so join (.) = twice = (\f = f . f) right?
16:47:17 <dbueno> Is there something like unions but which has the signature Ord a => Set (Set a) -> Set a?
16:47:17 <Saizan> yup
16:47:36 <mauke> that would be join if Set was a monad
16:47:49 <Saizan> Set.fold union empty ?
16:49:06 <twanvl_> unions . toList?
16:49:08 <dbueno> Saizan, right, thanks.
16:49:30 <dbueno> twanvl_: I wanted not to bother with an intermediate list, if possible.
16:50:55 <Saizan> those two should be equal if deforestation/fusion kicks in
16:51:35 <twanvl_> which it should do, toList = foldr (:) []
16:51:39 <diltsman> Ok, another newbie question...How do I use a function that returns a non-monad value in a do block?
16:52:06 <OceanSpray> diltsman, do you want to return that value or use it in the same function?
16:52:15 <diltsman> Use it.
16:52:18 <twanvl_> do { ... ; let something = notMonadic ; ... }
16:52:22 <dbueno> Saizan: Sure, but, I'd rather not count on that fact, if it's easy not to.
16:52:23 <ddarius> twanvl_: ? foldr (:) [] = id
16:52:26 <OceanSpray> what twanvl_ said.
16:52:41 <twanvl_> ddarius: that was Set.foldr
16:53:02 <nolrai> @type maybe
16:53:03 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
16:53:28 <Toxaris> Saizan: Set.toList is fusion-friendly?
16:53:45 <mauke> twanvl_: Set.fold?
16:54:30 <Saizan> Toxaris: "if" :)
16:54:40 <twanvl_> looking at the sources, there is a foldr, but it is not exported
16:55:02 <Saizan> i presume fold = foldr?
16:55:09 * bos wonders why Data.Map has insertWith' but not insert'
16:55:44 <twanvl_> if you are using insert you can seq yourself
16:56:07 <ddarius> bos: Indeed, it shouldn't be necessary for insert.
16:56:07 <bos> i know, but that's also true of insertWith'
16:56:15 <ddarius> :t insertWith
16:56:16 <lambdabot> Not in scope: `insertWith'
16:56:21 <ddarius> :t Data.Map.insertWith
16:56:21 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> k -> a -> Data.Map.Map k a -> Data.Map.Map k a
16:56:23 <Toxaris> bos: how?
16:56:25 <bos> well, actually not
16:56:28 <twanvl_> (as in apply 'seq' yourself, not "go seq yourself!")
16:56:29 <bos> spoke before thinking
16:58:53 <dons> wow, i hadn't seen this: http://programming.reddit.com/info/62iap/comments/ "Calculating the reflect-rotate-translate normal form for an isometry of the plane in Haskell, and verifying it with QuickCheck."
17:00:20 <ddarius> No one really uses literate Haskell the Knuth envisioned it...
17:02:42 <wli> ddarius: How goes Risch integration?
17:03:38 <dcoutts> ddarius: one does occasionally see some literate hs progs as emails explaining some code
17:03:53 <dcoutts> is that not in the tradition?
17:04:30 <wli> I do literate programming now and then.
17:04:47 <allbery_b> literate hs in email and/or blog seems fairly common to me
17:04:47 <dcoutts> I've tried that a couple times in emails and it's quite fun, I hope the results were readable
17:04:52 <wli> It needs a little help because it doesn't mix well with the module system.
17:05:22 <wli> lhs2tex, for instance, pretty much assumes each module is a standalone document.
17:05:36 <dcoutts> wli: yes, I like how the chap who wrote that simple linux hypervisor did that literate walkthrough
17:05:47 <ddarius> wli: That conversation was in reference to http://andrew.bromage.org/blog/archive/series/integration/
17:05:48 <lambdabot> Title: The BWAIN: integration Archives
17:06:06 <dcoutts> wli: the clever thing was that the walkthrough didn't follow exactly the order of the code in the .c modules as I recall
17:06:29 <dcoutts> is was a good order for the exposition, which is not necessarily the same as module order
17:06:52 <ddarius> dcoutts: Such uses was what I was talking about.  They are not exactly what Knuth was intending (I don't think) though I doubt he'd have problems with it.
17:07:37 <ddarius> How many people just code in a literate form with no intention of making a paper or a blog post or an email post?
17:07:56 <wli> ddarius: I usually go by bronstein98symbolic.pdf
17:08:10 <dcoutts> ddarius: people mostly only do it if they think it'll be read
17:08:12 <ddarius> wli: I'm not trying to implement Risch integration.
17:08:23 <ddarius> dcoutts: Exactly.
17:08:41 <clanehin> ddarius: I do.  Sometimes the pdf is easier to browse through the code.  Rarely, but sometimes.
17:10:03 <ddarius> There was a lambdabot module written in literate form that was entertaining though probably still not quite what Knuth had in mind.
17:10:09 <ddarius> @version
17:10:10 <lambdabot> lambdabot 4p581, GHC 6.6 (Linux i686 2.40GHz)
17:10:10 <lambdabot> darcs get http://code.haskell.org/lambdabot
17:12:37 <diltsman> Is there a way to get ghc to process a finite list at compile time?
17:13:08 <diltsman> I can do it in C++ using templates, but I don't know if there is a way to do it in Haskell.
17:13:36 <mauke> you can always (ab)use template haskell
17:13:43 <diltsman> lol
17:13:58 <Saizan> or typelevel lists, but that depends on how you want to use the list
17:14:50 <diltsman> Basically it is a list of prime numbers in a known range.
17:15:43 <dmwit> My suggestion is to store them in a file and have a separate program that generates the file, if you think you'll be changing the range often.
17:16:01 <diltsman> Nah, it is for SPOJ.
17:16:11 <mauke> oh, which problem?
17:16:16 <diltsman> PRIME1
17:16:27 <wli> ddarius: The part that messes me up is elliptic integrals esp. eliptic integrals in terms of Jacobian elliptic functions or inverses thereof.
17:16:50 <diltsman> If I can generate the list at compile time, I can use a naive prime generator.
17:17:07 <sjanssen> diltsman: IIRC, compile time is limited too
17:17:26 <mauke> to something like 30s IIRC
17:17:29 <diltsman> Really?  Wasn't aware of that.  That sucks.  :-P
17:18:05 <sjanssen> diltsman: I used a naive seed to generate the small primes
17:18:15 <sjanssen> s/seed/sieve
17:18:45 <sjanssen> I used a smarter UArray Bool sieve for the second part
17:19:09 <diltsman> Yeah, I'm using that for the entire list at the moment, but I really don't want to go to somebody at school who knows number theory to find an efficient way of doing it.
17:19:32 <mauke> ooh, Igloo has a 1.68s solution
17:19:56 <mauke> who is mrd?
17:19:57 <diltsman> Right now I'm having a problem that it isn't executing anything in a [...|x<-xs] statement.
17:20:04 <wli> Basically you get (dt/dx)^2 = (t^2+p^2)*(t^2+q^2) where either p, q, or both may be pure real or pure imaginary, which doesn't fit the dt/dx = p(t) pattern.
17:20:12 <Igloo> mauke: To what?
17:20:19 <wli> mauke: To what?
17:20:52 <mauke> http://www.spoj.pl/ranks/PRIME1/
17:20:54 <lambdabot> Title: Sphere Online Judge (SPOJ)
17:21:59 <wli> ergh, p got overloaded. dt/dx = f(t) where f(.) is a polynomial.
17:22:37 <dmwit> mauke: You're one /whois and one two Google searches (one if you're smarter than me) away from knowing who mrd is. ;-)
17:23:30 <diltsman> input x = [line x y | y <- [1..x]]
17:23:45 <diltsman> I know that x > 1, but line never gets executed.
17:24:29 <diltsman> Any ideas why that doesn't seem to work?
17:24:29 <mauke> what is line?
17:24:40 <dmwit> Does "input" ever get called/used?
17:25:00 <diltsman> A function declared in the where clause.  Yes, it gets called from main.
17:25:00 <Jonnie> How can I sort this error out? "Could not find module `System.IO.UTF8':" I'm trying to run a program, I have emerged ghc-6.6.1 and I thought as a standard library, it would be there, but it can't seem to find it ...
17:25:23 <mauke> why do you think System.IO.UTF8 is a standard library?
17:25:35 <bos> diltsman: are you sure it's called?
17:25:45 <dmwit> Not just called, but also used.
17:26:10 <diltsman> Yes.  I've verified that it gets called by replacing the body with a putStrLn, but when I use what I need, then it doesn't execute right...
17:26:18 <Jonnie> bos: Well I thought it was, I'm not really a haskell man, just trying to use a haskell program
17:26:20 <glguy> ?hackage utf8-string
17:26:20 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/utf8-string
17:26:31 <glguy> Jonnie, which program?
17:26:39 <diltsman> line does use the IO monad.
17:26:47 <Jonnie> geordie bot
17:26:53 <mauke> Jonnie: so you think all modules are standard?
17:26:54 <Jonnie> Someone wants me to run it for them ...
17:27:06 <Jonnie> No I don't mauke
17:27:16 <glguy> maybe he means that utf8 support should be ;)
17:27:39 <bos> diltsman: so you're generating a list of [IO a] for some type a, then
17:27:40 <Jonnie> I don't know haskell ... I presumed it was as there was nothing in the documentation of the bot that said I needed anything extra other than GHC
17:27:54 <bos> diltsman: that's not going to execute unless you do something with it
17:27:58 <dmwit> Does it use cabal?
17:28:00 <diltsman> [IO ()]
17:28:10 <Saizan> diltsman: you need to sequence_ it
17:28:19 <diltsman> How do I do that?
17:28:26 <dmwit> :t sequence_
17:28:26 <bos> diltsman: yeah, call sequence_ on the list
17:28:26 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
17:28:52 <mauke> input x = mapM_ (line x) [1 .. x]
17:28:55 <bos> diltsman: unless the IO type is present at the top level of your result type, it's not going to actually be executed
17:29:04 <diltsman> That's good to know.
17:29:23 <dmwit> I'm surprised you even got it to compile.
17:29:24 <nolrai> I have a question about the notation that the SKI calculus is written in. I know this isn't quite the right place but ..
17:29:26 <nolrai> What is the tree structure of "x(y)z"? i.e. in "x(y)" x is the left subtree and y is the right and contains > 1 combinator.
17:29:41 <dmwit> It shouldn't be possible to compile a do block with an expression that is not an IO computation.
17:29:58 <bos> i'm guessing there's a let clause involved
17:29:59 <diltsman> Yeah, that is why I made creative use of "return"
17:30:04 <byorgey> dmwit: wha? there are other monads too, you know...
17:30:15 <mauke> diltsman: return x has no effect for all x
17:30:18 <bos> byorgey: yeah, but diltsman is executing inside IO
17:30:19 <dmwit> byorgey: Ugh, yes, sorry.
17:30:26 <byorgey> ok, sorry, I came in late =)
17:30:30 <dmwit> byorgey: On the other hand, he did say he replaced it with putStrLn. ;-)
17:30:39 <byorgey> dmwit: fair enough.
17:32:40 <diltsman> Alright!  That fixed that problem.  Still doesn't output the prime numbers, but at least it is processing my input.
17:32:45 <OceanSpray> :t Rational
17:32:45 <lambdabot> Not in scope: data constructor `Rational'
17:32:50 <OceanSpray> :t Integer
17:32:51 <lambdabot> Not in scope: data constructor `Integer'
17:32:52 <dmwit> nolrai: Actually, I think (x(y)) is the left subtree, and (z) is the right subtree there.
17:32:55 <OceanSpray> dang it.
17:33:00 <ddarius> nolrai: The parentheses are just grouping then?  Then it's just like Haskell.
17:33:13 <ddarius> OceanSpray: What are you hoping for?
17:33:15 <ddarius> :k Integer
17:33:16 <lambdabot> *
17:33:21 <nolrai> thanks
17:33:26 <OceanSpray> :k Fractional
17:33:27 <lambdabot> Class `Fractional' used as a type
17:33:34 <OceanSpray> :k Raional
17:33:34 <lambdabot>     Not in scope: type constructor or class `Raional'
17:33:38 <dmwit> ?instances Fractional
17:33:39 <lambdabot> Double, Float
17:33:41 <OceanSpray> :k Rational
17:33:42 <lambdabot> *
17:33:52 <OceanSpray> alright, got what I needed to know
17:34:03 <ddarius> :k Ratio
17:34:04 <lambdabot> * -> *
17:35:14 <byorgey> @info Rational
17:35:14 <lambdabot> Rational
17:35:21 <byorgey> =P
17:35:29 <byorgey> I hate you, @info
17:35:46 <mauke> @info do { x <- foo; return x }
17:35:46 <lambdabot> foo >>= \ x -> return x
17:35:52 <mauke> hint hint
17:36:04 <byorgey> haha
17:36:08 <dbueno> What does @info do?
17:36:17 <mauke> gets corrected to @undo
17:36:19 * byorgey smacks forehead
17:36:22 <dbueno> (Besides desugar do?)
17:36:24 <bos> is there a way to get ghci to list the instances of a typeclass without dumping out the class definition too?
17:36:34 <bos> :info gives me both, but i only want the instances
17:36:50 <bos> i guess not
17:37:04 <byorgey> bos: not that I know of.
17:37:09 <dons> no, there's no way, that i'm aware of. we built our own db for lambdabot for this
17:37:13 <dons> ?instance Monad
17:37:13 <lambdabot> Maybe you meant: instances instances-importing
17:37:15 <dmwit> bos: 1. install lambdabot
17:37:16 <dmwit> ;-)
17:37:17 <dons> ?instances Monad
17:37:18 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
17:37:23 <mauke> heh. if anyone needs a challenge: http://www.spoj.pl/problems/BRAINF_K/ has no haskell solutions yet
17:37:24 <lambdabot> Title: Sphere Online Judge (SPOJ) - Problem BRAINF_K
17:38:12 <byorgey> wait, I already have a brainf_k interpreter written in Haskell
17:38:14 <byorgey> !
17:39:33 <dmwit> ?bf ++++++++[>+++++++++<-]>.<+++++[>++++++<-]>-.+++++++..+++.<++++++++[>>++++<<-]>>.<<++++[>------<-]>.<++++[>++++++<-]>.+++.------.--------.>+.
17:39:33 <lambdabot>  fd:18: hClose: resource vanished (Broken pipe)
17:39:44 <dmwit> interesting
17:41:18 <wli> {-# LANGUAGE PatternGuards #-}
17:41:21 <mauke> nb: this brainfuck has comments and "Score is the length of your source."
17:41:24 <wli> That's right?
17:41:38 <mauke> wli: does it compile?
17:41:50 <wli> It gives warnings.
17:42:11 <wli> Ah, bad literate interaction.
17:42:53 <idnar> poof goes the resource
17:44:58 <dmwit> haskell++
17:45:23 <dmwit> stripForBrainfuck s = lines s >>= takeWhile (/='%') . filter (`elem` "<>+-.[]") -- so short!
17:45:44 <mauke> I AWAIT YOUR SUBMISSION
17:46:09 <dmwit> Hey, I said short, not fast. ;-)
17:46:49 <mauke> > length "
17:46:49 <lambdabot>  Improperly terminated string at """ (column 8)
17:47:01 <mauke> thanks, mouse button
17:47:47 <dmwit> ?index Word8
17:47:47 <lambdabot> Data.Word, Foreign
17:47:50 <mauke> > length "f s=lines s>>=takeWhile(/='%').filter(`elem`\"<>+-.[]\")"
17:47:50 <lambdabot>  54
17:48:07 <mauke> that leaves around 100 characters for the main program
17:48:20 <dmwit> Wait, what?
17:48:36 <mauke> you'll have to beat 167 chars to get in the top 5
17:48:37 <dmwit> I have to write the entire interpreter in 150 characters?
17:48:41 <dmwit> yow
17:48:55 <mauke> the worst solution is 505 chars (in C++)
17:49:03 * dmwit gives up
17:50:45 <saturday> ?bf ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++++++.+++.---.>>-.<++++++.+.>++++.>.
17:50:45 <lambdabot>  fd:18: hClose: resource vanished (Broken pipe)
17:50:56 <saturday> hmm whats wrong ...
17:51:15 <mauke> ?bf
17:51:15 <lambdabot> Done.
17:51:24 <mauke> ?bf .
17:51:24 <lambdabot>  fd:18: hClose: resource vanished (Broken pipe)
17:51:30 <mauke> . doesn't work
17:51:39 <byorgey> doh, I didn't realize there was a size limit!
17:51:46 <byorgey> =P
17:51:51 <saturday> ?bf ++.
17:51:51 <lambdabot>  fd:18: hClose: resource vanished (Broken pipe)
17:52:31 <hpaste>  (anonymous) pasted "Make me nicer!" at http://hpaste.org/4342
17:52:36 * byorgey thinks about how to strip down his 3400-character BF interpreter into only 512...
17:52:40 <Igloo> Oh, that makes it a rather more interesting problem
17:53:10 <mauke> byorgey: one character identifiers, no whitespace :-)
17:53:26 <byorgey> mauke: yeah, that will help
17:53:35 <byorgey> mauke: I think there are a bunch bigger optimizations I can make first, though
17:53:47 <skew> byorgey: how is the language defined?
17:53:48 <byorgey> I wrote this a while ago as an exercise to learn Haskell =)
17:54:20 <byorgey> skew: see  http://www.spoj.pl/problems/BRAINF_K/
17:54:22 <lambdabot> Title: Sphere Online Judge (SPOJ) - Problem BRAINF_K
17:54:22 <saturday> dosen't bf also come with a "," word for input?
17:54:52 <ddarius> saturday: Yes, that's the operation they omit for reasons that should be clear.
17:56:08 <saturday> so true
17:56:31 <byorgey> hm, the wraparound stuff also makes things annoying
17:57:00 <mauke> byorgey: just ignore it
17:57:07 <mauke> they don't actually test for it
17:57:15 <byorgey> mauke: good to know.
17:58:37 <byorgey> down to 3000 chars
18:01:23 <nanothief> perl is dominating this problem :P
18:01:36 <byorgey> removing type signatures --> 2500...
18:02:23 <mauke> nanothief: that's usually the case for size-based problems
18:03:40 <mauke> compare http://www.spoj.pl/ranks/KAMIL/ and http://www.spoj.pl/ranks/SIZECON/
18:03:41 <lambdabot> Title: Sphere Online Judge (SPOJ)
18:04:50 <wli> Trying to come up with a polynomial data structure that deals with normalizing things nicely.
18:05:07 <wli> (for univariate polynomials)
18:06:42 <wli> Num t => Map Natural t maybe.
18:07:01 <wli> That's sort of sparse.
18:08:23 <wli> Hmm. I get inexhaustive pattern match warnings when I shouldn't.
18:19:10 <byorgey> down to 1990 chars...  *sigh*
18:19:27 <ddarius> Why do you need so many characters?
18:19:32 <davidL> are you playing code golf?
18:21:51 <byorgey> http://www.spoj.pl/problems/BRAINF_K/
18:21:55 <byorgey> 512 character limit
18:21:55 <lambdabot> Title: Sphere Online Judge (SPOJ) - Problem BRAINF_K
18:21:56 <skew> byorgey: that sounds like a lot
18:22:31 <byorgey> @unpl uncurry (flip (,))
18:22:31 <lambdabot> uncurry (\ b c -> (,) c b)
18:24:25 <skew> byorgey: how does your code work?
18:24:35 <skew> I've got a rather verbose abstract machine that's about half the size
18:25:10 <byorgey> skew: well, it's based on some code I wrote a long while ago as a way to learn Haskell.
18:25:29 <byorgey> no doubt if I rewrote it from scratch with the intention of being small, it would be a lot smaller...
18:25:54 <byorgey> for one, it uses Parsec...
18:26:20 <ddarius> Parsec is a touch overkill...
18:28:04 <skew> ReadP is shorter
18:28:57 <byorgey> well, I already had this sitting around so I thought I'd try stripping it down
18:28:58 <ddarius> I'd probably write it with a top-level like, main = getContents >>= foldM doIt initialState
18:29:00 <Svrog> is there any way to get cabal to compile objective c sources?
18:29:02 <byorgey> we'll see if it works =)
18:29:12 <Svrog> seems to ignore all files that end with .m in the c-sources line
18:29:33 <byorgey> ddarius: well, you have to deal with comments, but that's probably the idea
18:29:49 <skew> is that non-space characters?
18:29:53 <ddarius> byorgey: That takes one bit of state.
18:30:25 <byorgey> ddarius: oh, I see, true.
18:30:44 <byorgey> see, my code actually builds an AST and then interprets that... =P
18:31:15 <byorgey> well, whatever =)
18:31:34 <ddarius> byorgey: Just fuse the AST building process and the interpretation process.  The latter should be expressed as a fold so it should be almost trivial.
18:32:21 <byorgey> ddarius: too late, half my identifiers are one letter by now =)
18:32:33 <ddarius> byorgey: So?
18:34:50 <ddarius> If you have parse :: String -> Exp where, for example, data Exp = Num Int | Add Exp Exp and eval :: Exp -> Int; eval = foldExp id (+) then you can get eval :: String -> Int by just replacing Add with (+) and Num with id everywhere in the source of parse.
18:35:57 <byorgey> ddarius: well, it isn't exactly a fold because of the looping... I think.
18:36:00 <Saizan> but you've to print only COMPILE ERROR if there's a non-matching ]
18:36:33 <ddarius> byorgey: Your interpreter is not compositional?!  That's heresy!
18:36:59 <byorgey> heh
18:39:13 <OceanSpray> Can I 'overload' operators?
18:39:41 <ddarius> Uh, you can overload anything that's in a type class.  Operators aren't special.
18:39:41 <dibblego> OceanSpray, type-classes exist, yes
18:39:49 <dfranke_> meh... the GHC-as-a-library API is a mess.
18:41:33 <OceanSpray> :k Number
18:41:33 <lambdabot> Not in scope: type constructor or class `Number'
18:41:48 <OceanSpray> ok, what class has the operators +, -, * and / ?
18:41:53 <dbueno> OceanSpray, Num?
18:41:57 <OceanSpray> oh
18:42:11 <mauke> but not /
18:42:15 <ddarius> :t (+)
18:42:15 <lambdabot> forall a. (Num a) => a -> a -> a
18:42:17 <ddarius> :t (/)
18:42:17 <lambdabot> forall a. (Fractional a) => a -> a -> a
18:42:58 <OceanSpray> dang.
18:43:12 <mokus> :t div
18:43:12 <lambdabot> forall a. (Integral a) => a -> a -> a
18:44:40 * byorgey gives up (for now)
18:45:01 <OceanSpray> this is getting more complicated than I thought.
18:45:45 <byorgey> OceanSpray: trying to implement dynamically typed numbers?
18:46:00 <OceanSpray> yes.
18:46:11 <ddarius> It's not a good idea.
18:46:12 <OceanSpray> unless, of course, there's a library for that already.
18:46:18 <OceanSpray> ddarius, what do you mean?
18:46:29 <OceanSpray> I'm trying to write a lisp interpreter here
18:46:31 <Toxaris> ddarius: he writes an interpreter for a language with dynamically typed numbers
18:46:44 <ddarius> Then you don't need to overload operators.
18:46:50 <OceanSpray> oh?
18:47:41 <ddarius> You don't need to translate (+ x y) into x + y
18:48:34 <OceanSpray> I still don't get what you mean.
18:48:48 <OceanSpray> eventually, the values inside x and y HAVE to use (+)
18:49:36 <mauke> how would you do it in C?
18:50:03 <OceanSpray> I'd probably have some structs containing ints and floats or somesuch
18:50:06 <skew> OceanSpray: or, eventually they could use add_together_my_interpreted_numbers
18:50:29 <mauke> OceanSpray: but no operator overloading
18:50:36 <OceanSpray> I think a clarification is in order
18:50:39 <OceanSpray> @hpaste
18:50:39 <lambdabot> Haskell pastebin: http://hpaste.org/new
18:50:47 <skew> OceanSpray: you might like to make your numbers instances of floating for convenience in implementing the interpreter
18:51:21 <skew> OceanSpray: but if you are actually parsing and interpreting some language, you can interpret their symbols however you like
18:51:26 <OceanSpray> and how would I handle integers?
18:52:13 <mauke> you could implement them as Integers
18:52:34 <Toxaris> OceanSpray: there's no need to use the Num-operators +, -, ..., you can use your own operators (e.g. <+>, <->, ...) or alphanumeric function names (e.g. plus, minus, ...)
18:52:55 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/4343
18:53:03 <OceanSpray> that's my addition function
18:53:21 <OceanSpray> for when LispVal = Number Integer
18:53:32 <OceanSpray> right now, I'm trying to do LispVal = Number LispNum
18:53:57 <OceanSpray> where data LispNum = Integer Integer | Real Double | ...
18:54:01 <ddarius> OceanSpray: So have add :: LispNum -> LispNum -> LispNum there's no need to use (+).  Also you may want to look into the Maybe monad.
18:54:20 <ddarius> (or MaybeT)
18:54:22 <Toxaris> but there's nothing wrong with using (+), either, is there?
18:54:27 <OceanSpray> why look into it? I'm already using it.
18:54:39 <skew> OceanSpray: so the question is how to work with the existing numeric types, more than how to overload operations?
18:54:50 <OceanSpray> yeah?
18:55:07 <glguy> OceanSpray, he means to use the >>= for the Maybe monad, just simply to use the Maybe type constructor
18:55:12 <glguy> not just*
18:55:25 <skew> OceanSpray: more important, use fromIntegral for casting integers in the mixed case
18:55:46 <ddarius> OceanSpray: The nested case analyses are exactly the kind of code using Maybe(T) simplifies.
18:56:19 <OceanSpray> ok
18:58:43 <gwern> I have a question about the GHC API. once you've specified the path to your ghc installation, compiled with 'ghc -package ghc' and so on, is ghc included in the binary or is it just linked? ie. is there still a runtime dependency?
18:58:43 <OceanSpray> I'm getting confused
18:59:06 <OceanSpray> how would using MaybeT avoid the pattern-matching?
18:59:20 <OceanSpray> can someone make an example?
18:59:20 <dfranke_> gwern: judging by the size of the binary, I'm pretty sure there isn't.
19:00:11 <dfranke_> gwern: funny you should bring it up... that makes two of us currently busy swearing at this API :-)
19:00:40 <gwern> dfranke_: well, I was thinking that, but between strip and upx it went down to like 2 or 3 megs or something, which indicates a lot of redundancy - which I'm not sure an optimizing advanced compiler like GHC would have if it were really being linked in and not some sort of runtime accessing of the ghc library
19:00:56 <gwern> dfranke_: the documentation is pretty atrocious :)
19:01:06 <dfranke_> gwern: what documentation? :-)
19:01:22 <gwern> the code is its own documentation!
19:01:32 <ddarius> OceanSpray: Ideally you should be able to write: apply Add (val :/ rest) = liftM2 (+) (eval val) (apply Add rest) `mplus` throwError (NoValue 0) -- (or better)
19:02:15 <OceanSpray> wow
19:02:22 <gwern> heh. but srsly, some of the choices aren't so good. like why does 'runStmt' return the status of evaluation and not the String? why does newSession have a Maybe String in its type when the String is mandatory? etc.
19:02:52 <OceanSpray> note that apply :: LispProc -> LispVal -> LispEnv -> ErrorT LispErr IO (Maybe LispVal)
19:02:54 <dfranke_> gwern: what are you doing with the API?
19:03:00 <gwern> dfranke_: a shell
19:03:01 <OceanSpray> it's complicated enough as it is.
19:03:15 <OceanSpray> plus, I got to stick continuations in there somewhere
19:03:17 <dfranke_> gwern: ah.  I'm using it as a preprocessor because TH isn't doing what I need.
19:03:53 <ddarius> OceanSpray: It's -too- complicated. You want to name the monad (or alternatively leave stuff parametric in it), and get something like LispProc -> LispVal -> LispM LispVal
19:03:54 <gwern> dfranke_: just now I got an email back from shellac's author in which he shows how to actually evaluate expressions :) I had a primitive non-shellac shell which worked, and a shellac shell which didn't work
19:04:06 <gwern> so I'm happily looking at it and testing it
19:04:19 <gwern> dfranke_: what are you trying to do that th can't?
19:04:27 <dfranke_> gwern: handle GADTs.
19:04:45 <gwern> you can't do that at compile-time?
19:05:00 <OceanSpray> apply :: LispProc -> LispVal -> LispEnv -> LispCont -> LispRet
19:05:02 <dfranke_> gwern: nope.  There's no Decl constructor for them.
19:05:04 <OceanSpray> is what I have right now
19:05:29 <ddarius> OceanSpray: When done properly, you'll only need to deal with the parts of the monad that are relevant to what you are working on.  I.e. your add code doesn't do anything special with the environment or continuations so it shouldn't even know about them.
19:05:50 <dfranke_>  gwern: TH doesn't support very much outside H98.
19:05:53 <OceanSpray> of course it needs to know about the environment or continuation
19:06:02 <OceanSpray> read more closely
19:07:37 <Stinger> what do people recommend for an intermediate Haskell book?
19:07:38 <ddarius> OceanSpray: Why?  Does it do anything special with them?  Does it query the environment itself or extend it?  Does it manipulate the continuation in any special way that isn't already handled by exceptions?  It just passes the environment along (so it doesn't need to see it) and uses the continuation in the normal manner (so it doesn't need to see it)
19:08:05 <OceanSpray> ...dang.
19:09:08 <OceanSpray> I'm really confused now.
19:09:34 <gwern> dfranke_: oh. well, that makes sense. th always stuck me as pretty complex, I can see them not wanting to make life more difficult
19:09:58 <geezusfreeek> \quit
19:10:03 <geezusfreeek> woops
19:11:48 <ddarius> OceanSpray: Wadler's "The essence of functional programming" and/or "Monads for Functional Programming" and Liang, Hudak, and Jones' "Monad Transformers and Modular Interpreters" are good papers for this sort of thing.
19:13:10 <Toxaris> that brainf*ck task is pretty hard
19:13:21 <OceanSpray> ddarius, thanks for the info, but
19:13:34 <OceanSpray> I'd rather keep my code on a level that I can understand.
19:13:41 <dibblego> ?type break
19:13:43 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
19:14:41 <ddarius> OceanSpray: Read those papers.  I'm sure you'll understand it afterwards and your code will be a lot cleaner and, well, generally understandable later since it won't be nearly so cluttered and will make clear exactly what each part needs.
19:16:46 <ddarius> However, the idea in a very compressed nutshell is: Let's say you have a very simple arithmetic expression evaluator. data Exp = Num Int | Add Exp Exp and you write eval (Num n) = return n; eval (Add a b) = do a' <- a; b' <- b; return (a+b); then eval's type is Monad m => Exp -> m Int, which explicitly states we aren't using any effect.
19:19:21 <ddarius> Now say you want to add division.  You extend Exp to data Exp = ... | Div Exp Exp, and add a line to eval, eval (Div a b) = do a' <- a; b' <- b; if b' == 0 then throwError "div by zero" else return (a'/b').  Note that since the Add case of eval didn't need to do anything with exceptions it didn't deal with them.  Now we have added exceptions, but we haven't needed to change any old code, just add new cases.  Now eval's type is (MonadError m String, Monad
19:19:21 <ddarius> m) => Exp -> m Int which makes it clear that it uses exceptions but no other effects.
19:20:14 <OceanSpray> whoah.
19:21:18 <ddarius> If we do eval (Add (Num 3) (Div (Num 2) (Num 0))) it will Just Work even though we didn't have to tell the Add case how to deal with exceptions.
19:24:33 <wli> How do you do arrays? State for the store and Error for out-of-bounds exceptions?
19:25:39 <ddarius> wli: How do you support interpreting array operations?
19:26:57 <wli> Not sure. I suspect there's a canonical monadic strategy for it.
19:29:15 <ddarius> Monads deal with the effects supported and are mostly independent of the values.  So there's nothing special about handling (mutable) arrays as compared to handling any type of references and nothing special about handling out of bounds exceptions as compared to division by zero.
19:30:19 <OceanSpray> ddarius, do you have a degree?
19:30:23 <ddarius> OceanSpray: No.
19:30:30 <OceanSpray> wow.
19:30:45 <wli> Sounds like the canonical monadic strategy for arrays is described.
19:31:19 <ddarius> wli: For semantics, that's what I'd use.  In practice, I'd just use IO/STArrays and probably the Error monad.
19:31:24 <toad_> college doesn't teach this stuff.
19:33:25 <Toxaris> could there be MonadST (like there is MonadIO), or is that impossible due to ST's funny typing?
19:33:58 <ddarius> Toxaris: The typing isn't the issue.  What it -is- is the issue.
19:34:49 <ddarius> E.g. StateT s [] a, has a different state for each non-deterministic choice.  That'd be difficult to implement reasonably for ST.
19:35:02 <ddarius> Backtrackable state so to speak.
19:35:09 <ddarius> And that's just one monad.
19:36:25 <sjanssen> Toxaris: yes, there could be
19:36:31 <ddarius> Oh, I misread the question.
19:36:36 <Toxaris> ddarius: do you know MonadIO?
19:36:38 <sjanssen> Toxaris: in fact, monadlib generalizes this concept to MonadBase
19:37:15 <wli> Which concept is this?
19:37:41 <Toxaris> wli: the concept of accessing the "base monad" in a monad transformer stack
19:37:48 <Toxaris> wli: that base monad is normally Identity, IO or ST
19:38:14 <Toxaris> because IO and ST, as ddarius argued for, can
19:38:21 <Toxaris> can't be monad transformers
19:39:06 <Toxaris> so basically, with MonadIO, I have a similar typeclass to MonadState, MonadReader and so on, saying: I want IO to be *somewhere* in my monad transformer stack
19:39:23 <Toxaris> wli: http://hpaste.org/4329
19:40:41 <Toxaris> wli: so if there is something like MonadST somewhere, we can use MonadST to type an operation wich needs mutable arrays
19:43:31 * Toxaris has a working bf interpreter in 754 Byte of Haskell source (including whitespace). but no error handling yet :(
19:57:12 <sorear> And yet, there are working bf interpreters in far less x86 machine code.  Does this mean x86 machine code is a better language?
19:57:26 <ddarius> Damn skippy!
19:57:50 <Toxaris> sorear: for writing short bf interpreters? maybe
20:01:00 <dmwit> I don't suppose there's a Word15?
20:02:26 <dmwit> > -1 `mod` 16
20:02:27 <lambdabot>  -1
20:02:29 <dmwit> > -1 `rem` 16
20:02:30 <lambdabot>  -1
20:02:34 <dmwit> ...humm
20:03:10 <skew> dmwit: do you want Int15?
20:03:20 <skew> dmwit: Int16, rather
20:03:32 <dmwit> Nope, I want 15 bits.
20:03:59 <dmwit> Specifically, I want 32767+1=0.
20:04:08 <dmwit> (and 0-1=32767, ideally)
20:04:11 <twanvl_> Making it yourself should be easy
20:04:21 <dmwit> Easy, but it costs precious characters. ;-)
20:04:43 <dmwit> Also, I thought one of mod/rem did what I wanted; is there another function that does it?
20:05:24 <twanvl_> (.&.)
20:05:36 <dmwit> uhh
20:05:40 <dmwit> > -1 .&. 16
20:05:42 <Toxaris> > length "import Data.Bits"
20:05:43 <lambdabot>  Add a type signature
20:05:43 <lambdabot>  16
20:05:49 <twanvl_> > -1 `mod` (2^15)
20:05:49 <lambdabot>  -1
20:06:00 <twanvl_> > (-1) `mod` (2^15)
20:06:01 <lambdabot>  32767
20:06:01 <dmwit> > -1 .&. 16 :: Int
20:06:02 <lambdabot>  0
20:06:13 <dmwit> oh...
20:06:23 <dmwit> > -(1 `mod` 16) -- is this how it parses? O_o
20:06:24 <lambdabot>  -1
20:06:49 <dmwit> Well, great, thanks!
20:07:04 <gwern> https://secure.wikimedia.org/wikipedia/en/wiki/Image:Simon_Peyton_Jones_01.jpg <-- I can't help but look at this picture and want it to be a lolcat/lambdacat/lolhuman
20:07:05 <lambdabot> http://tinyurl.com/2fnyyb
20:10:05 <idnar> :t (.&.)
20:10:06 <lambdabot> forall a. (Bits a) => a -> a -> a
20:10:54 * Toxaris added error handling. now at 863 bytes
20:11:48 <chessguy> SPJ looks like the british butler who did it in all the murder mysteries
20:13:45 * ddarius really liked the old black and white photo that was on Simon Peyton Jones' MSR page.
20:26:18 <OceanSpray> > 5 / 6
20:26:18 <lambdabot>  0.8333333333333334
20:26:30 <OceanSpray> :t (6 / 7)
20:26:30 <lambdabot> forall t. (Fractional t) => t
20:26:44 <OceanSpray> something's weird...
20:26:47 <dmwit> ?hoogle Word8 -> Char
20:26:47 <lambdabot> Data.ByteString.Internal.w2c :: Word8 -> Char
20:26:57 <dmwit> urgh
20:27:11 <shachaf> OceanSpray: What?
20:28:17 <OceanSpray> wait, why is 5/6 not correctly rounded?
20:29:29 <sjanssen> that is how Haskell numerals work
20:29:46 <sjanssen> use 'div' for integer division
20:30:44 <dmwit> No, it's just an artifact of floating point arithmetic.
20:31:20 <shachaf> OceanSpray: If you prefer, you can use Data.Ratio. :-)
20:31:43 <OceanSpray> > 5 `div` 6
20:31:44 <lambdabot>  0
20:31:48 <OceanSpray> oookay.
20:32:27 <skew> isn't defined on integers
20:32:38 * sjanssen prefers CReal :)
20:32:40 <skew> (/) isn't defined on integers
20:32:47 <sjanssen> Data.Number.CReal> 5 / 6 :: CReal
20:32:48 <sjanssen> 0.8333333333333333333333333333333333333333
20:37:25 <falbani> Hi.
20:38:01 <falbani> I have a question about user keyboard input...
20:38:24 <skew> buffering?
20:39:35 <falbani> When my program needs some user input, I always write something like this:
20:39:35 <falbani> putStrLn "Your name, please:"
20:39:35 <falbani> name <- getLine
20:39:52 <falbani> But...
20:40:03 <falbani> I would like not to use 2 lines for that...
20:40:13 <dmwit> name <- putStrLn "name" >> getLine
20:40:32 <skew> how about  prompt str = putStrLn prompt >> getLine
20:40:37 <falbani> dmwit: jejeje... I mean 2 lines of screen, not of code
20:40:40 <skew> name <- prompt "You name, please:"
20:40:48 <skew> falbani: oh, then it is buffering :)
20:40:53 <falbani> I would use "putStr"
20:41:00 <falbani> but it is wreird
20:41:01 <skew> putStr "Your name, please" >> hFlush stdout
20:41:10 <falbani> (forgive my english, i'm from Argentina)
20:42:01 <skew> or you could use hSetBuffering stdout NoBuffering, so things will always appear right away
20:42:17 <falbani> And why "putStr "Your name, please:" ; name <- getLine" behaves in the way it behaves?
20:42:56 <skew> falbani: because by default something waits until it sees the newline before it sends output to the screen
20:43:42 <falbani> skew: oh, thanks...
20:45:30 <falbani> skew, dmwit: Thanks. Bye.
20:53:35 <dmwit> > sequence ["a", "b", "c"]
20:53:36 <lambdabot>  ["abc"]
20:53:44 <dmwit> > sequence ["a", "", "c"]
20:53:44 <lambdabot>  []
20:53:49 <dmwit> aha!
20:54:20 <Toxaris> > sequence ["ab", "12"]
20:54:21 <lambdabot>  ["a1","a2","b1","b2"]
20:55:44 <Toxaris> > msum ["ab", "12"]
20:55:44 <lambdabot>  "ab12"
20:59:40 <noecksit> hello, i am trying to make a function called scanSum, which adds all the items in a list and returns a list of running totals
20:59:57 <dmwit> :t scanl (+) 0
20:59:57 <lambdabot> forall a. (Num a) => [a] -> [a]
21:00:12 <dmwit> > scanl (+) 0 [1,3,5,7,9]
21:00:13 <lambdabot>  [0,1,4,9,16,25]
21:00:13 <noecksit> so if the input of scanSum was [2,3,4,5], the output would be [2,5,9,14]
21:00:26 <dmwit> > scanl1 (+) [2,3,4,5]
21:00:27 <lambdabot>  [2,5,9,14]
21:00:33 <OceanSpray> '/' isn't defined on integers, eh?
21:00:37 <dmwit> nope!
21:00:41 <TSC> :t (/)
21:00:42 <lambdabot> forall a. (Fractional a) => a -> a -> a
21:00:45 <idnar> > scanl1 (+) [2]
21:00:45 <lambdabot>  [2]
21:00:49 <jcreigh> OceanSpray: use `div` if you want integer division
21:00:51 <dmwit> OceanSpray: div is, though.
21:00:56 <OceanSpray> >div 4 5
21:01:00 <OceanSpray> > div 4 5
21:01:00 <lambdabot>  0
21:01:10 <OceanSpray> how?
21:01:18 <OceanSpray> :t div
21:01:19 <lambdabot> forall a. (Integral a) => a -> a -> a
21:01:20 <dmwit> > (/) `on` fromIntegral 4 5
21:01:20 <lambdabot>   Not in scope: `on'
21:01:21 <Toxaris> OceanSpray: what would you expect?
21:01:26 <noecksit> oh, how would i go about doing it myself recursively?
21:01:31 <noecksit> is it complicated?
21:01:36 <idnar> @src scanl
21:01:36 <lambdabot> scanl f q ls = q : case ls of
21:01:36 <lambdabot>     []   -> []
21:01:36 <lambdabot>     x:xs -> scanl f (f q x) xs
21:01:41 <dmwit> noecksit: No, not at all!  You should have a try. =)
21:01:48 <Toxaris> noecksit: no just try it
21:01:50 <OceanSpray> I need a function that takes two integers, divides them, and returns a float.
21:01:55 <dmwit> :t on
21:01:56 <lambdabot> Not in scope: `on'
21:02:06 <dmwit> ?let on (*) f x y = f x * f y
21:02:06 <lambdabot> <local>:3:0:     Warning: Pattern match(es) are overlapped              In th...
21:02:08 <Toxaris> OceanSpray: so convert the integers to floats and use (/)
21:02:16 <OceanSpray> ok then
21:02:18 <idnar> > (fromIntegral 4) / (fromIntegral 5)
21:02:18 <lambdabot>  0.8
21:02:27 <noecksit> yeah, ive been thinking about it for a while but cant seem to grasp it
21:02:27 <TSC> OceanSpray: Or divide the integers to get a rational, then convert the rational to floating point
21:02:55 <dmwit> :t \x y -> fromRational (x%y)
21:02:55 <lambdabot> forall t t1 a. (%y::t1, Fractional a) => (t1 -> Rational) -> t -> a
21:03:03 <OceanSpray> > 5%6
21:03:04 <lambdabot>  5%6
21:03:12 <dmwit> :t \x y -> fromRational (x % y)
21:03:13 <lambdabot> forall a. (Fractional a) => Integer -> Integer -> a
21:03:18 <dmwit> So many choices!
21:03:28 <noecksit> because in one case, the list need to descend down, but we also need to know of the initial elements too
21:03:47 <OceanSpray> > 12 % 6
21:03:48 <lambdabot>  2%1
21:04:12 <Toxaris> noecksit: consider writing a helper function first
21:04:14 <dmwit> noecksit: Ah, but there's a bit of a trick, isn't there?  Since, after all, you can return the current result immediately, so you don't need to keep it. ;-)
21:04:18 <davidL> @type toRational
21:04:18 <lambdabot> forall a. (Real a) => a -> Rational
21:04:39 <davidL> > toRational 4.5
21:04:39 <lambdabot>  9%2
21:04:44 <noecksit> dmwit: what do u mean?
21:04:47 <Toxaris> dmwit: but you *have* to keep it to use it in subsequent subtotals
21:04:51 <davidL> > toRational pi
21:04:52 <lambdabot>  884279719003555%281474976710656
21:05:18 <dmwit> Toxaris, noecksit: I mean, you need to keep the result of the calculation, but you don't need to keep the components that resulted in that calculation.  Like this:
21:05:36 <Toxaris> dmwit: well, that makes sense, then
21:05:37 <dmwit> > let f x = x : f (x + 1) in f 1
21:05:37 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
21:05:45 <noecksit> yeah, u need to know the head always, or at least the result of the last calculated result
21:05:54 <dmwit> right
21:07:10 <Toxaris> noecksit: so you have to tell the recursively called function the so-far calculcated result
21:07:54 <olsner> @pl let f x = x : f (x + 1) in f
21:07:54 <lambdabot> fix (ap (:) . (. (1 +)))
21:08:10 <OceanSpray> > (5%6) / 2%3
21:08:11 <lambdabot>   add an instance declaration for (Integral (Ratio t))
21:08:15 <OceanSpray> > (5%6) / (2%3)
21:08:16 <lambdabot>  5%4
21:09:19 <davidL> > 5%6%2%3
21:09:19 <lambdabot>        add an instance declaration for (Integral (Ratio (Ratio t)))
21:13:16 <noecksit> i think i got it, thanx
21:26:23 <shachaf> Does the ghci prompt only substitute %s and %%? Can't I be more detailed in what I want?
21:27:36 <OceanSpray> If I overloaded (Real a) + (Integer b),
21:27:49 <OceanSpray> do I also have to overload (Integer b) + (Real a)?
21:28:36 <shachaf> OceanSpray: I missed the earlier conversation, but I thought you'd decided not to overload?
21:28:48 <OceanSpray> well, I'm doing it anyway.
21:29:13 <dmwit> :t (+)
21:29:14 <lambdabot> forall a. (Num a) => a -> a -> a
21:29:38 <SamB_XP> you don't seem to understand the point of decisions ;-P
21:30:16 <shachaf> OceanSpray: GHC doesn't know that (+) is commutative, if that's what you mean.
21:30:25 <OceanSpray> oh
21:30:26 <OceanSpray> well, dang
21:30:36 <shachaf> OceanSpray: But why are you doing it this way?
21:31:16 <OceanSpray> what's the alternative? Define a function 'add :: LispNum -> LispNum -> LispNum'?
21:32:18 <shachaf> OceanSpray: Why not? The + primitive in LISP has nothing to do with the (+) function in Haskell.
21:32:32 <shachaf> OceanSpray: (Well, except that they do the same thing. :-) )
21:32:51 <OceanSpray> I KNOW. DANG.
21:33:08 <SamB_XP> I personally wonder why + is even a primitive in CL...
21:33:14 <SamB_XP> it seems silly
21:33:36 <OceanSpray> Doesn't overloading and defining a function do the same thing?
21:34:00 <OceanSpray> I mean, GHC doesn't know that `add` is commutative, either
21:34:27 <OceanSpray> the same amount of work goes into both, and + is two letters shorter and more intuitive
21:34:30 <OceanSpray> so there.
21:34:52 <shachaf> OceanSpray: Where do you use Haskell's (+)?
21:35:34 <shachaf> OceanSpray: I'd expect you only use it in the spot where you define the primitives, not all over the code.
21:35:45 <shachaf> OceanSpray: LispNums aren't exactly numbers.
21:35:51 <OceanSpray> see http://hpaste.org/4343
21:36:07 <OceanSpray> I'm not using it all over the code.
21:36:24 <shachaf> OceanSpray: So no need to call it (+).
21:36:37 <Toxaris> OceanSpray: overloading will make your numeric type usable with various library functions (like sum), wich may be good (if you want to do so) or bad (if it leads to typing confusion). by defining instance Num LispNum you declare that your LispNums are equally good to the builtin numbers.
21:36:44 <shachaf> OceanSpray: Why aren't you using Maybe?
21:36:58 <OceanSpray> I am using Maybe.
21:37:01 <shachaf> OceanSpray: I mean the Maybe monad.
21:37:06 <shachaf> OceanSpray: Sorry.
21:37:14 <shachaf> OceanSpray: Or something like it.
21:37:18 <OceanSpray> Because I'm too stupid to understand how
21:37:46 <OceanSpray> besides, the structure of that function kind of throws a wrench into trying to incorporate another monad.
21:37:53 <shachaf> OceanSpray: People suggested using your own monad before, to keep the environment/continuation/error/etc.
21:38:07 <shachaf> OceanSpray: Why not do that?
21:38:09 <OceanSpray> And I have no idea how to do that.
21:38:24 <OceanSpray> I don't even get what they mean.
21:39:28 <shachaf> OceanSpray: Have you used the Maybe monad by itself?
21:39:39 <OceanSpray> nope.
21:39:43 <shachaf> OceanSpray: Or others, like State/Reader?
21:39:57 <OceanSpray> nope.
21:41:22 <OceanSpray> In other words, I'm a complete novice whose first actual Haskell project was this interpreter.
21:41:40 <OceanSpray> no other programs written, no tutorials read all the way through, nothing.
21:47:55 <ricky_clarkson> OceanSpray: Are you doing the metacircular evaluator from SICP?
21:48:30 <OceanSpray> I've never read SICP.
21:51:06 <dmwit> My desire to help you drops a little bit with each additional thing you haven't bothered reading. =P
21:51:43 <srid> Prelude> square x = x * x
21:51:43 <srid> <interactive>:1:9: parse error on input `='
21:51:46 <srid> ^^ why?
21:52:02 <dmwit> Try "let square x = x * x".
21:52:16 <srid> ah ok
21:52:20 <srid> ghci thing?
21:52:27 <dmwit> srid: All the things you give at the ghci prompt are in the IO monad, so there are some... quirks. =)
21:52:50 <srid> ok.. I am yet to come to the Monads chapter in YAHT.
21:52:55 <davidL> pretend you're in a do block
21:52:56 <skew> srid: things at the prompt have to be statements that could go in a do block
21:53:11 <srid> that makes sense now
21:56:12 <srid> ``let pfunc1 x = map (\y -> y*x)`` is the most concise point-free style way to write ``let func1 x l = map (\y -> y*x) l``?
21:56:28 <srid> is it possible to do away with that 'x'?
21:57:06 <davidL> @pl \x -> map (\y -> y*x) [1,2,3]
21:57:06 <lambdabot> flip map [1, 2, 3] . (*)
21:57:18 <dmwit> Sure!
21:57:26 <srid> @help pl
21:57:26 <lambdabot> pointless <expr>. Play with pointfree code.
21:57:44 <dmwit> map . (*) -- ought to do it
21:57:48 <dmwit> :t map . (*)
21:57:50 <lambdabot> forall a. (Num a) => a -> [a] -> [a]
21:58:06 <dmwit> :t \x -> map (\y -> y*x)
21:58:07 <lambdabot> forall a. (Num a) => a -> [a] -> [a]
21:58:48 <dmwit> srid: The basic idea of point-freeing code is this one:
21:58:57 <dmwit> \x -> f $ x === f
21:59:02 <dmwit> So, starting with your code:
21:59:12 <dmwit> \x -> map (\y -> y * x)
21:59:18 <dmwit> \x -> map (*x)
21:59:31 <dmwit> \x -> map ((*) x)
21:59:44 <dmwit> \x -> (map . (*)) $ x
21:59:54 <dmwit> map . (*)
22:00:03 <dmwit> Of course, the second-to-last step is the tricky one. =)
22:00:21 <TSC> That assumes that * is commutative, too
22:00:30 <dmwit> Ah, good point.
22:00:44 <dmwit> map . flip (*) -- is more correct
22:01:04 <TSC> Does @pl know that some functions are commutative (and use that knowledge)?
22:01:30 <dmwit> It seems to, see the ?pl above.
22:03:44 <davidL> dmwit: does it take you longer to realize what `map . (*)' does (as opposed to `map (\y -> y * x)')?
22:04:04 <dmwit> davidL: A little, but map (*x) is quite natural.
22:05:01 <xpik1> @pl (\x y -> (+1) $ (x+y))
22:05:02 <lambdabot> ((1 +) .) . (+)
22:05:12 <dmwit> It takes a little practice to decide how pointy you want your functions to be. =)
22:05:36 <davidL> dmwit: that's what I'm curious about, how do you know when to stop? :P
22:06:00 <dmwit> davidL: My rule of thumb is to model it after how I think of the function.
22:06:12 <dmwit> davidL: Some functions just naturally seem like the composition of other functions:
22:06:40 <dmwit> map (+3) . filter even -- definitely ought to be point-free
22:07:04 <dmwit> Every once in a while, after I see the point-free version, I think of the function differently, and so I leave it. =)
22:08:07 <davidL> so you wouldn't sacrafice readability to save some characters?
22:09:10 <davidL> it's what @pl seems to do most of the time :|
22:09:21 <dmwit> heh
22:09:32 <dmwit> Yeah, ?pl is a bit mindless about how far to go. =)
22:09:58 <dmwit> I almost always prefer readability.
22:10:13 <dmwit> Although, after a while, what you deem "readable" changes.
22:10:45 <davidL> I suppose it comes with practice
22:16:21 <jcreigh> okay, I give up: How do I format the date/time in the local machines time zone? Right now I have currentDateTime = formatTime defaultTimeLocale "%a %Y-%m-%d %I:%M %p" `liftM` getCurrentTime
22:16:28 <jcreigh> ...which seems to give the UTC time.
22:16:51 <dmwit> utcToLocalTime?
22:17:04 <jcreigh> @hoogle utcToLocalTime
22:17:05 <lambdabot> Data.Time.LocalTime.utcToLocalTime :: TimeZone -> UTCTime -> LocalTime
22:17:05 <lambdabot> Data.Time.LocalTime.utcToLocalTimeOfDay :: TimeZone -> TimeOfDay -> (Integer, TimeOfDay)
22:19:40 <dmwit> Time handling is kind of lousy in Haskell.
22:19:47 <dmwit> Well... time handling is kind of lousy.
22:19:47 <jcreigh> yeah. :(
22:20:51 <conal> is anyone here using the --hyperlink-source flag for cabal's "haddock" command?  i'm getting an error message "haddock --hyperlink-source requires Haddock version 0.8 or later", though "haddock --version" says version 2.0.
22:22:43 <jcreigh> dmwit: thanks, that works.
22:26:17 <durka> can someone help me install wxhaskell?
22:26:39 <hpaste>  jcreigh pasted "Is this the easiest way to get the time?" at http://hpaste.org/4344
22:27:47 <jcreigh> of course, there appear to be more than one set of time libraries, and it's unclear which one I should use...
22:28:25 <dmwit> System.Time sucks even harder than Data.Time.
22:28:54 <TSC> I think you can import just "Data.Time"
22:29:01 <dmwit> right
22:29:49 <dmwit> You may also be interested in the time format "%c", which is locale-specific.
22:30:46 <jcreigh> TSC: ah, that helps, thanks. I still need to import System.Locale for defaultTimeLocale, though...
22:31:21 <dmwit> Sadly, yes.
22:32:41 <clanehin> I hate to be like, "are we there yet?" but is there any idea when 6.8 packages will get into debian?
22:32:53 <Zao> Knowing debian, any decade now.
22:35:36 <goalieca> the shootout will then adopt it once debian does?
22:37:35 <sjanssen> goalieca: Gentoo, actually
22:39:16 <goalieca> gentoo can be bloody slow
22:39:30 <sjanssen> @tell dons this is interesting: http://shootout.alioth.debian.org/gp4/benchmark.php?test=threadring&lang=all vs. http://shootout.alioth.debian.org/debian/benchmark.php?test=threadring&lang=all
22:39:30 <lambdabot> Consider it noted.
22:43:59 <durka> has anyone managed to install wxhaskell recently?
22:47:04 <Plareplane> why would erlang get half the time on one of the test compared to the other (but not ghc)?
22:47:44 <sjanssen> Plareplane: it's a mystery
22:57:39 <goalieca> did they use the same algorithm exactly?
23:02:48 <sjanssen> the same program exactly
23:03:16 <sjanssen> well, same program for each language
23:03:35 <sjanssen> there isn't very much leeway in the algorithm, however
23:05:47 <saturday> is the monad state library included with ghc?
23:07:16 <dibblego> saturday, Control.Monad.State I think?
23:07:30 <sjanssen> saturday: it is included in the "extralibs" bundle
23:07:42 <sjanssen> saturday: if you don't have it already, just grab it from:
23:07:44 <sjanssen> @hackage mtl
23:07:44 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mtl
23:07:52 <saturday> thanks
23:50:03 <jsnx> are all computations of the form `foldr1 op $ unfoldr f val` automatically deforested?
23:50:53 <mwc> jsnx, I don't know off hand, you'd have to check the core
23:51:12 <mwc> that being said, if you find it isn't, you can probably use a rewrite rule to make GHC aware of it
23:51:25 <jimstutt> durka: wxhaskell build fails for me on WXCore.Types on ghc-6.8.1. I suggest mailing the maintainer.
23:52:11 <jsnx> mwc: how do i 'check the core' ?
23:53:54 <mwc> http://www.haskell.org/ghc/docs/latest/html/users_guide/ext-core.html
23:53:55 <lambdabot> Title: 5.15. Generating and compiling External Core Files, http://tinyurl.com/yv4yuz
23:54:19 <mwc> core is essentially a haskell-like represetnation of the optimized code GHC has generated
23:54:27 <mwc> http://www.haskell.org/ghc/docs/latest/html/users_guide/options-debugging.html#id3165385 gives a guide on how to read it
23:54:28 <lambdabot> Title: 5.16. Debugging the compiler, http://tinyurl.com/t96uq
23:56:27 <jsnx> mwc: thank you!
23:58:46 <mwc> jsnx, sorry I didn't have a more definitive answer for you
