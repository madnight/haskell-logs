00:09:46 <dons> http://article.gmane.org/gmane.comp.lang.haskell.cafe/33159 !
00:09:46 <lambdabot> Title: Gmane -- Mail To News And Back Again
00:09:54 <dons> "announcing darcs 2.0.0pre1, the first prerelease for darcs 2"
00:35:07 <hpaste>  smack_ pasted "Kind error in instance..." at http://hpaste.org/4379
00:36:01 <dmwit> smack_: Try F.Foldable Sequence where...
00:36:44 <dmwit> Oh, wait.
00:36:46 <dmwit> hmm
00:37:02 <smack_> can't match 't a' against 'a1' (a rigid variable)
00:37:07 <dmwit> Yeah.
00:37:13 <dmwit> Something like:
00:37:42 <dmwit> instance F.Foldable a => F.Foldable . Sequence where ... -- not yet valid Haskell
00:37:58 <dmwit> I think what you really want is
00:38:09 <dmwit> data Sequence t a = Sequence [t a]
00:38:14 <dmwit> Then
00:38:26 <dmwit> instance (F.Foldable t) => F.Foldable (Sequence t) where ...
00:38:29 <smack_> Sequence t of Foldable t, right
00:39:28 <smack_> dmwit: i'm confused by gentle intro:  instance (Eq a) => Eq (Tree a) where
00:39:47 <sjanssen> smack_: Foldable is a 'constructor class'
00:40:09 <sjanssen> meaning that instances are for data constructors, not data types
00:40:27 <dmwit> smack_: If "t" is an instance of Foldable, then "t" is a type *constructor*, not a type.
00:40:37 <smack_> ah...
00:40:49 <dmwit> smack_: In the gentle intro example, if "a" is an instance of Eq, it is already a type (not a type constructor).
00:41:03 <smack_> yep.
00:43:17 <smack_> sjanssen, dmwit: thanks, that works
01:11:25 <Syzygy-> I wonder who this Chris is, who takes my griping about the pluralization in Rails as a model of the unfriendliness and arrogance of the entire Haskell community, and who now has told me three or four times to get the f*** out of his programming community...
01:11:59 <sjanssen> Syzygy-: huh, where?
01:12:06 <faxathisia> Sounds like someone worth ignoring
01:12:43 <Syzygy-> sjanssen: My blog.
01:12:47 <Syzygy-> http://blog.mikael.johanssons.org/archive/2007/12/pluralization-in-rails/
01:12:48 <lambdabot> Title: Michi&#8217;s blog » Blog Archive » Pluralization in Rails, http://tinyurl.com/yt4gsv
01:12:52 <Syzygy-> Read the comment thread.
01:22:29 <quicksilver> Syzygy-: judging by the comments I just read, I think you overstate the case.
01:22:37 <quicksilver> Syzygy-: he didn't seem *that* negative to me
01:26:15 <roger`> i found it slightly amusing
01:28:57 <faxathisia> heh is there any program which can pluralize correctly?
01:30:34 <osfameron> localisation frameworks?
01:31:28 <osfameron> in Perl there's Lingua::EN::Inflect, but don't think there are versions for other languages
01:32:04 <osfameron> oh.  there's Lingua::FI::Inflect for Finnish.  Here endeth the off-topic trivia.
01:33:10 <roger`> localization was my first though too.
01:34:47 <quicksilver> faxathisia: no, not without a complete and total list. SOme of them do fairly well, though.
01:35:01 <quicksilver> I don't know if lingua::en:inflect is better or worse than ruby's
01:36:15 <kfish> Syzygy-, "Until you realize that pluralization is actually not quite as regular in English as it is in Japanese." -- heh (japanese generally has no plurals)
01:36:40 <osfameron> well, that's about as regular as you can get then :-)
01:40:32 <Syzygy-> quicksilver: I'm mainly reacting to the fact that he describes me as arrogant, repeatedly, and ascribes my arrogance to what all the Haskell community is like, repeatedly.
01:40:43 <Syzygy-> kfish: My point exactly.
01:41:43 <kalven> there there
01:45:18 * quicksilver shrugs
01:45:43 <quicksilver> I didn't come across with the impression he called you arrogant
01:45:44 * quicksilver checks
01:45:46 <mux> I find his last comment rather offensive, and really uncalled for
01:45:59 <quicksilver> he uses the word once, and it wasn't directed at you
01:46:05 <quicksilver> he certainly didn't use it repeatedly.
01:46:28 <quicksilver> mux: ? His last comment is one in which he admits to being wrong?
01:46:58 <mux> no, you need to read on
01:47:28 <quicksilver> maybe I'm looking int he wrong place?
01:47:36 <mux> it seems you are
01:47:37 <mux> wait
01:47:40 <quicksilver> The last message I can see is "BTW, I was wrong that the pluralize method is not necessarily a Rails feature - the Gem that contains it was extracted from Rails."
01:48:46 <mux> But youâ€™re obviously looking for problems, so you should probably avoid Rails and code your sites in Haskell so that you donâ€™t waste your time on something as vulgarly popular as Rails with its out-of-control pluralizations and all :-p.
01:48:52 <mux> this is part of it
01:49:14 * quicksilver shrugs
01:49:19 <quicksilver> to me, he's obviously joking
01:49:23 <quicksilver> he ends the comment with :-p
01:49:24 <mux> the next paragraph is on the same tone
01:49:32 <mux> I quite doubt it
01:49:40 <quicksilver> well, he's right. There is arrogance in the haskell community.
01:49:41 <faxathisia> sounds like a joke to me
01:49:53 <faxathisia> since he says 'vulgarly popular'
01:50:13 <mux> he's just being ironic I think, but he's not joking
01:50:13 <quicksilver> and I can understand why people woudl find it unattractive
01:50:21 <quicksilver> there's also a lot of friendliness, true
01:50:27 <doserj> come on, someone disses ruby for some obscure feature, another one replies tongue-in-cheek, and the originator gets upset?
01:50:28 <faxathisia> (Unless he thinks haskell isn't populer, then it might actually be a slight)
01:50:29 <quicksilver> overall it's one of the most friendly communities I know
01:50:35 <faxathisia> but clearly.. haskell is popular
01:50:36 <mux> well that's right, but on the other hand we all know that the haskell community is one of the friendliest
01:50:42 * quicksilver nods
01:50:49 <quicksilver> but, it does contain its fair share of arrogance
01:50:54 <quicksilver> which is not an attractive feature
01:51:06 <mux> anyways
01:51:30 <mux> that's not telling me why this freaking serial console won't log over nfs like it used to
01:51:34 <quicksilver> my point is, I don't think Syzygy- should be upset by that :)
01:51:41 <quicksilver> now, it's his choice to be upset
01:51:44 * osfameron likes the way #haskell oscillates from dealing with peope-like-me's numpty questions to ivory tower musings, and never gets rude or personal
01:51:49 <quicksilver> but I don't think the guy intended offense.
01:51:51 <mux> I guess Syzygy- needs to grow a thicker skin :)
01:51:56 <mux> the world out there is nasty
02:12:18 <faxathisia> "Note that Haskell uses lazy evaluation and so this function does not take an infinite amount of time to run" :D
02:14:37 <Syzygy-> quicksilver: The guy comes off to me as looking for a fight with me and projecting this onto my own griping.
02:15:32 <Syzygy-> I really must have a problem with my text communication. People seem to read me as upset (doserj, just now) and arrogant and completely uninterested in a system I'm trying to learn (Chris@my blog)
02:17:43 <sieni> wtf is wrong with the blog, it doesn't load
02:17:55 <sieni> does it require referrer urls?
02:22:41 <Syzygy-> sieni: My blog? No. loads fine for me too...
02:23:27 <doserj> Syzygy-: if you question what other read into your text, maybe you should also question what you read into other people's text :)
02:23:48 <baboa> hi
02:23:56 <Syzygy-> doserj: Good point.
02:23:56 <baboa> a ByteString compat question
02:24:15 <sieni> Syzygy-: I can't load it. Just an empty page.
02:24:35 <Syzygy-> sieni: What adress are you going to?
02:24:47 <sieni> http://blog.mikael.johanssons.org/archive/2007/12/pluralization-in-rails/
02:24:48 <lambdabot> Title: Michi&#8217;s blog » Blog Archive » Pluralization in Rails, http://tinyurl.com/yt4gsv
02:25:10 <baboa> I import Data.ByteString.Internal in GHC 6.8.1
02:25:25 <baboa> that was Data.ByteString.Base in GHC 6.6.1
02:25:37 <baboa> how to create a module that works for both cases?
02:25:44 <Syzygy-> Weird. Try it again? I'm following the logfile now...
02:26:16 <sieni> now lynx got something unintellifible
02:27:12 <Syzygy-> afk
02:58:49 <dozer> I've got an app that is crashing with what i think is a run-away loop
02:59:07 <dozer> is there a quick way to find out what functions/symbols are responsible for the recursion?
02:59:16 <dozer> other than adding trace statements everywhere?
02:59:40 <sjanssen> you can use the GHC debugger
02:59:51 <dozer> ok
03:00:01 <sjanssen> there's also a trick with the profiler, but it's hit-or-miss
03:00:36 <dozer> ghc 6.8 isn't packaged for ubuntu :(
03:00:45 <dozer> at least not for feisty
03:00:51 <roger`> dozer: not for gutsy either
03:01:09 <dozer> that sucks
03:01:17 <roger`> dozer`, if you download the binary, you'll need to symlink the missing readline library to the existing one
03:01:28 <roger`> dozer: though, I'm not sure about todays latest release
03:01:37 <roger`> 6.8.2?
03:04:33 <dozer> I see a source tarball for 6.8.1
03:06:32 <dozer> is there a date for 6.8.2?
03:06:44 <roger`> I saw 6.8.2 up on haskell.org a few hours ago
03:07:46 <dozer> I must be getting an old page back then
03:08:52 <roger`> good, i thought i'd lost my mind for a moment: http://www.haskell.org/ghc/dist/stable/dist/
03:08:53 <lambdabot> Title: Index of /ghc/dist/stable/dist
03:09:18 <dozer> found it
03:09:19 <dozer> thx
04:10:06 <njbartlett_> Finally got another London HUG video online... http://www.londonhug.net/2007/12/11/video-design-patterns-as-higher-order-datatype-generic-programs/
04:10:07 <lambdabot> Title: Î»ondon HUG » Blog Archive » Video: Design Patterns as Higher-Order Datatype Gen ..., http://tinyurl.com/35yhqp
04:17:08 <SamB_XP> lambdabot: ? that's not how you spell a lambda!
04:17:08 <lambdabot> Maybe you meant: . ? @ activity activity-full admin all-dicts arr ask b52s babel bf botsnack brain bug check choice-add choose clear-messages compose devils dice dict dict-help djinn djinn-add djinn-
04:17:09 <lambdabot> clr djinn-del djinn-env djinn-names djinn-ver docs dummy easton echo elements elite eval fact fact-cons fact-delete fact-set fact-snoc fact-update faq figlet figlet' flush foldoc forecast forget
04:17:09 <lambdabot> fortune fptools free freshname ft gazetteer get-shapr ghc girl19 google gsite gwiki hackage help hitchcock hoogle hoogle+ id ignore index instances instances-importing irc-connect jargon join karma
04:17:09 <lambdabot> karma+ karma- karma-all keal kind learn leave let list listall listchans listmodules listservers localtime localtime-reply lojban map messages messages? more msg nazi-off nazi-on oeis offline
04:17:11 <lambdabot> oldwiki palomer part paste pl pl-resume pointful pointless pointy poll-add poll-close poll-list poll-remove poll-result poll-show pretty print-notices protontorpedo purge-notices quit quote rc read
04:17:14 <lambdabot> [3 @more lines]
04:18:14 <SamB_XP> @help pointy
04:18:14 <lambdabot> pointful <expr>. Make code pointier.
04:18:27 <sgillesp1e> I'm not really sure what to look for
04:18:40 <sgillesp1e> how can I execute a shell command in haskell
04:20:46 <TSC`> sgillesp1e: I think with "system"
04:20:48 <TSC`> @type system
04:20:53 <lambdabot> Not in scope: `system'
04:20:55 <TSC`> Bah
04:21:00 <TSC`> @type System.Cmd.system
04:21:01 <lambdabot> String -> IO GHC.IOBase.ExitCode
04:21:48 <sgillesp1e> There it is
04:21:50 <sgillesp1e> lovely
04:21:51 <sgillesp1e> thanks
04:21:56 <profmakx> heyho. anyone dealt with hs-plugins on 6.8.1 yet?
04:22:05 <profmakx> i poked around a bit yesterday
04:22:49 <klutometis> is there an equivalent to SICP for haskell, like YAHT?
04:22:55 <klutometis> or should one just do SICP in haskell
04:23:06 <faxathisia> you should do SICP with scheme
04:23:11 <klutometis> done
04:23:21 <ibid> what would equivalent to SICP mean?
04:23:30 <SamB_XP> you write a Haskell interpreter?
04:23:35 <klutometis> producing similar epiphanies, changing your life, etc.
04:23:36 <ibid> the same book with examples in haskell?
04:23:40 <klutometis> hmm; that would be nice
04:23:47 <ibid> also unlikely :)
04:23:58 <faxathisia> similar epiphanies -- in a different language? I don't think there's any reaso to expect that
04:24:09 <sgillesp1e> There is a tutorial somewhere on writing a haskell in scheme
04:24:13 <sgillesp1e> I haven't looked at it yet
04:24:17 <SamB_XP> haven't people already translated those examples that could be translated?
04:24:27 <klutometis> sgillesp1e: i remember coming across that
04:24:36 <sgillesp1e> Also, I've been looking at, Implementing a functional language: a tutorial
04:24:39 <klutometis> SamB_XP: for SICP? I've seen a wiki to that effect
04:24:43 <sgillesp1e> thats a pretty good read
04:24:48 <SamB_XP> and, like, made them available online somewhere reachable by keywords SICP and Haskell?
04:25:04 <faxathisia> actually read TAPL
04:25:13 <faxathisia> it wont teach you haskell but it's a great book
04:25:16 <sgillesp1e> TBH, i didn't really like SICP all that much
04:25:19 <sgillesp1e> whats TAPL?
04:25:23 <klutometis> SamB_XP: the SPJ book?
04:25:26 <faxathisia> you can learn a lot of relevant into about type systems
04:26:11 <SamB_XP> klutometis: I think you should have addressed that one to sgillesp1e
04:26:31 <klutometis> SamB_XP: you're right;
04:26:35 <klutometis> sgillesp1e: the SPJ book?
04:26:43 <sgillesp1e> Yes
04:27:41 <sgillesp1e> I've heard that the earlier one was much better though
04:28:01 <faxathisia> sgillesp1e: Another book
04:28:01 <sgillesp1e> Also, what is TAPL?
04:28:03 <SamB_XP> earlier one?
04:28:09 <SamB_XP> he wrote an EARLIER book?
04:28:26 <klutometis> sgillesp1e: http://www.cis.upenn.edu/~bcpierce/tapl/
04:28:26 <lambdabot> Title: Types and Programming Languages
04:28:33 <sgillesp1e> yeah, I think it was called, Implementation of Functional Languages or something
04:28:51 <klutometis> i'm guessing there's no canonical haskell book to complete, then; no rite of passage
04:29:11 <SamB_XP> faxathisia: did you just answer sgillesp1e before he asked a question?
04:29:12 <faxathisia> clearly we should starting writing this book in order to be the next GJS :)
04:29:18 <faxathisia> SamB_XP: Yes
04:29:18 <sgillesp1e> TAPL looks like exactly what i'm looking for
04:30:27 <quicksilver> klutometis: not that I'm aware of, no
04:30:31 <SamB_XP> faxathisia: good, because I don't think the IRC protocol allows re-ordering of interdependant messages, and if that had happened I'd have been really confused trying to figure out how...
04:30:34 <quicksilver> klutometis: tehre are some good books and interesting papers
04:30:41 <quicksilver> klutometis: but, perhaps, no epiphany :)
04:30:43 <klutometis> quicksilver: do you have any favorites?
04:30:53 <faxathisia> SamB_XP: "interdependant" messages?
04:30:58 <quicksilver> klutometis: I'm quite exciting about the upcoming Real World Haskell
04:31:12 <quicksilver> but, it's not here yet :)
04:31:19 <sgillesp1e> quicksilver: I am definitely excited about that too!
04:31:39 <SamB_XP> faxathisia: where one message is sent in response to another
04:31:39 <quicksilver> klutometis: most of my detailed haskell knowledge comes from papers, many but not all co-authered by SPJ
04:31:50 <faxathisia> There's no way IRC could know that...
04:32:02 <klutometis> hmm; no release date for RWH
04:32:19 <quicksilver> klutometis: no. Middle of next year would be my guess. It's not finished yet.
04:32:40 <SamB_XP> faxathisia: well, it doesn't... but I think once you've recieved a message, any message you send will be recieved by all other parties AFTER that message
04:32:41 <sgillesp1e> Are they going to realize a rough draft to the community or something?
04:32:54 <klutometis> quicksilver: maybe I'll start, then, by perusing his bibliography
04:33:15 <SamB_XP> RWH?
04:33:21 <klutometis> sgillesp1e: apparently they "will soon be posting early chapters for public review."
04:33:26 <klutometis> SamB_XP: real world haskell
04:33:28 <SamB_XP> oh right
04:33:32 <faxathisia> I'm not sure about that SamB.. how it interacts when there are multiple servers
04:33:32 <klutometis> yeah, book acronyms get out of hand
04:33:46 <SamB_XP> I figured it out as soon as I saw the word "chapter"
04:33:51 <faxathisia> I only enough about the clients side of IRC
04:34:05 <sgillesp1e> ...And that was by the middle of November right?
04:34:19 <SamB_XP> faxathisia: well, it's a bit like general relativity
04:34:26 <faxathisia> no I don't so :p
04:34:39 <SamB_XP> don't so?
04:34:41 <sgillesp1e> oh no, nevermind
04:34:44 <faxathisia> don't think so
04:34:52 <sgillesp1e> i misunderstood the last post
04:34:55 <SamB_XP> I'm serious!
04:35:47 <faxathisia> Me ---- IRC server 1 ------- IRC server 2 ---- You
04:35:51 <SamB_XP> I might have got general and special mixed up though
04:36:00 <klutometis> thanks for the pointers
04:36:08 <faxathisia> I mean in this situation.. there is a possibility that messages come out of order.. but I don't know how the spec is for it
04:36:58 <faxathisia> if you had an observer at IRC server 1 and another at IRC server 2.. I couldn't say 100% whether or not they see the same thing
04:37:09 <SamB_XP> They often won't
04:37:11 <faxathisia> (Would have to check the spec in detail...)
04:37:32 <SamB_XP> depends on network latency etc.
04:37:38 <faxathisia> (And make the assumption that implementations of IRC servers are correct!)
04:37:46 <SamB_XP> okay, so I meant special relativity
04:41:30 <SamB_XP> it works like this: as an event propagates through the spanning tree, it takes time to go from one server to the next...
04:42:27 <SamB_XP> so if you have events starting from opposite ends of the tree, the servers may not all see the messages in the same order
04:54:15 <faxathisia> ah ok
04:59:00 <ricky_clarkson> njbartlett_: Every few minutes, that LondonHUG video stops.  Is there a reason not to provide a download link?
04:59:10 * ricky_clarkson goes 'view source'ing.
04:59:20 <njbartlett_> I just added a link
04:59:39 <njbartlett_> ricky_clarkson: No reason other than my forgetfulness
04:59:59 <njbartlett_> It's a shame it's not streaming well for you though
05:01:31 <ricky_clarkson> Thanks.
05:14:32 <ydo> I started to learn haskell, first little functions is here: http://rafb.net/p/xoulcf22.html  can somebody please give me comments about what can be improved / done in another more elegant way?
05:14:33 <lambdabot> Title: Nopaste - No description
05:16:20 <mux> ydo: I find your code is mostly just fine; I would have written some of those a bit differently though
05:16:24 <oerjan> \x -> x/2 = (/2) and \x -> 2*x = (2*)
05:16:25 <mux> ie, double = (2*)
05:16:51 <mux> and scale s = transform (s*)
05:16:56 <mux> point-free style is addictive :-)
05:16:59 <ydo> ah nice
05:17:31 <mux> normalgrid n = transform (/n) $ grid n n
05:18:38 <ydo> \a b -> a/b  could that somehow be shortened to (/) or something? does the () convert infix-operators to suffix?
05:18:42 <oerjan> minor nit: you don't need parentheses around f i and f j
05:18:54 <oerjan> @pl \a b -> a/b
05:18:54 <lambdabot> (/)
05:19:06 <opqdonut> normalgrid = transform >>= join grid
05:19:35 <oerjan> i think opqdonut is entering the silly realm :)
05:20:05 <ydo> opqdonut: that is beyond me now though
05:20:13 <opqdonut> :t (join (undefined::r->r->a) >>= (undefined::a->r->a))
05:20:24 <opqdonut> that wasn't completely right, working on it
05:20:28 <lambdabot> forall r a. r -> a
05:20:32 <opqdonut> yeah, that's it
05:20:36 <oerjan> yeah, the -> monad is not for beginners, and rarely for real code anyhow
05:20:52 <opqdonut> join grid >>= transform . (/)
05:20:55 <opqdonut> that should do it
05:21:34 <oerjan> i don't think that works
05:21:49 <mux> I don't think it's worth obfuscating that code anyways
05:21:51 <mux> :-)
05:21:54 <oerjan> @pl normalgrid n = transform (\x -> x/n) $ grid n n
05:22:07 <oerjan> @bot
05:22:07 <opqdonut> yeah it needs a flip at least
05:22:07 <lambdabot> normalgrid = ap (transform . flip (/)) (join grid)
05:22:08 <lambdabot> optimization suspended, use @pl-resume to continue.
05:22:08 <lambdabot> :)
05:22:18 <mux> hah, what's that?
05:22:27 <opqdonut> yes, ap of course
05:22:28 <oerjan> @pl-resume
05:22:28 <lambdabot> normalgrid = ap (transform . flip (/)) (join grid)
05:22:51 <oerjan> the ap should be infix there
05:23:00 <mux> yeah, would be prettier
05:23:57 <quicksilver> transform.flip(/)`ap`join grid
05:24:04 <quicksilver> purge the whitespace!
05:24:11 <opqdonut> yeh, in my :t the (a->r->a) should've been (r->a->a) of course
05:24:12 <mux> hah
05:24:38 <oerjan> ydo: btw yes, \a b -> a/b = (/)
05:27:29 <ydo> cool
05:27:33 <ydo> where did join come from?
05:27:41 <opqdonut> :t join
05:27:42 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
05:27:43 <ydo> is it something like permute?
05:27:47 <opqdonut> now when m is r->
05:27:51 <opqdonut> that becomes
05:28:03 <opqdonut> :t join :: (r->r->a) -> (r->a)
05:28:03 <lambdabot> forall r a. (r -> r -> a) -> r -> a
05:28:21 <opqdonut> > join (*) $ 4  -- for example
05:28:27 <lambdabot>  16
05:28:29 <quicksilver> ydo: it's an unnecessarily cute way of applying the same arguement twice :)
05:28:32 <mux> LB needs some steroids
05:28:47 <opqdonut> well i wouldn't say unnecessarily :)
05:28:57 <opqdonut> quite necessary for getting some things into point-free form
05:29:11 <mux> cuteness should be mandatory
05:29:11 <opqdonut> of course pf shouldn't be an end in itself
05:29:15 <mux> and enforced by the type checker!
05:29:25 <mux> Type checking failed: ugly code
05:29:45 <roconnor> join is the fundamental way of duplicating arguments.
05:29:57 <opqdonut> generalized to all monads
05:30:14 <mux> > let dup = join (,) in dup 3
05:30:16 <lambdabot>  (3,3)
05:30:24 <ydo> I don't have join in my ghci, do I have to import something?
05:30:26 * roconnor uses pf in for proofs about his applicative functor.
05:30:29 <mux> ydo: Control.Monad
05:30:32 <oerjan> @index join
05:30:33 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
05:30:33 <mux> @index join
05:30:33 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
05:30:36 <mux> heh
05:30:39 <mux> stereo style
05:30:58 <ricky_clarkson> > join.join $ (,) $ 3
05:30:58 <lambdabot>  Couldn't match expected type `(->) b' against inferred type `(,) a'
05:31:19 <scook0> > join . join $ (,,) $ 3
05:31:19 <lambdabot>  Couldn't match expected type `(->) c'
05:31:21 <ricky_clarkson> > join.join (,) $ (,) 3
05:31:22 <lambdabot>      Occurs check: cannot construct the infinite type: a = (a, a1)
05:31:22 <lambdabot>       Expe...
05:31:23 <quicksilver> :t join.join
05:31:24 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m (m a)) -> m a
05:31:38 <osfameron> join duplicates its arguments?
05:31:51 <mux> join applies the same argument two times to the same function
05:31:54 <quicksilver> osfameron: that's its effect in the (r ->) monad, yes
05:31:58 <ricky_clarkson> @djinn a -> (a,a,a,a)
05:31:58 <lambdabot> f a = (a, a, a, a)
05:32:03 <mux> > join (+) 2
05:32:04 <lambdabot>  4
05:32:05 <oerjan> :t join.join $ (,,)
05:32:05 <lambdabot> forall a. a -> (a, a, a)
05:32:08 <scook0> > (join . join $ (,,)) 3
05:32:08 <lambdabot>  (3,3,3)
05:32:19 <roconnor> @. pl djinn a -> (a,a,a,a)
05:32:19 <lambdabot> f = join (join (join (,,,)))
05:32:25 <oerjan> ah yes, beaten by associativity of $
05:32:41 <quicksilver> join.join.(,,) $ 3
05:32:44 <quicksilver> > join.join.(,,) $ 3
05:32:44 <lambdabot>  Couldn't match expected type `(->) b'
05:32:47 * quicksilver sobs
05:33:04 <roconnor> > (join.join$(,,)) 3
05:33:04 <scook0> more generally, join takes two layers of "monad-ness" and squishes them into one
05:33:05 <lambdabot>  (3,3,3)
05:33:19 <nornagon> :t (,,,,,,)
05:33:19 <lambdabot> forall a b c d e f g. a -> b -> c -> d -> e -> f -> g -> (a, b, c, d, e, f, g)
05:33:24 <quicksilver> scook0: two layers of warmth and fuzziness! :)
05:33:25 <mux> > ((join.join)(,,)) 3
05:33:25 <lambdabot>  (3,3,3)
05:33:28 <mux> > ((join.join)(,,))3
05:33:28 <lambdabot>  (3,3,3)
05:33:32 <mux> whitespace is for weenies
05:34:03 <scook0> quicksilver: if monads are warm and fuzzy, are arrows merely warm, or merely fuzzy?
05:34:11 <roconnor> I was explaining to a student how in the lambda calculus white space as left-associative.
05:34:15 <oerjan> > concat.words$"whitespace is for weenies"
05:34:15 <lambdabot>  "whitespaceisforweenies"
05:34:17 <nornagon> @. type run "(" ++ (replicate 27 ',') ++ ")"
05:34:18 <lambdabot> [Char]
05:34:21 <roconnor> He almost up and left at that point.
05:34:31 <scook0> and are comonads really "cold, pointy things"?
05:34:39 <quicksilver> scook0: arrows are sleek
05:34:46 <ydo> I'm trying to use join interactively
05:34:52 <osfameron> how does squishing two levels of monadicity become equivalent to duplicating your arguments?
05:34:52 <nornagon> rats
05:34:55 <ydo> howevery I get this errors:  No instance for (Monad ((->) a))
05:34:55 <ydo>       arising from use of `join' at <interactive>:1:0-9
05:34:56 <ydo>     Possible fix: add an instance declaration for (Monad ((->) a))
05:35:06 <osfameron> rats are fuzzy.  But not necessarily warm.
05:35:08 <mux> > (first (*2) *** second (+1)) (1,2)
05:35:08 <lambdabot>   add an instance declaration for (Num (d, b))
05:35:09 <lambdabot>     In the expression: 2
05:35:15 <roconnor> ydo: I think you need to also import Control.Monad.Reader
05:35:22 <mux> > ((*2) *** (+1)) (1,2)
05:35:23 <scook0> osfameron: how familiar are you with the ((->)r) monad?
05:35:23 <lambdabot>  (2,3)
05:35:27 <roconnor> ydo: to get the Monad instance for ((->)r)
05:35:28 <opqdonut> control.monad.instances
05:35:54 <scook0> :t join
05:35:54 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
05:35:55 <mux> > (first (-1) >>> (*2) *** (+1)) (3,4)
05:35:56 <lambdabot>   add an instance declaration for (Num (b -> b1))
05:36:02 <osfameron> scook0: if that's a function call, then I'm familiar with function calls... but not with why they're also a monad
05:36:07 <mux> > (first (-1) >>> ((*2) *** (+1))) (3,4)
05:36:07 <lambdabot>   add an instance declaration for (Num (b -> b1))
05:36:14 <mux> > (first (subtract 1) >>> ((*2) *** (+1))) (3,4)
05:36:15 <scook0> osfameron: if you replace m with r -> in the type of join, you should see it
05:36:15 <lambdabot>  (4,5)
05:36:18 <quicksilver> osfameron: becauses there is monad, (r ->), and two layers of that is (r -> r ->)
05:36:36 <quicksilver> osfameron: and the canonical way to go from (r -> r ->) to (r ->) is to use the same 'r' both times :)
05:36:39 <scook0> osfameron: oh, and ((->)r) is type application, not function application
05:36:41 <nomeata> Igloo: hi. are you around? Iâ€™m trying to get haskell-utils working with your ghc6.8 package. Do you have a working package around somewhere?
05:36:59 <opqdonut> the reader monad is for having a common environment that all functions in the chain can read from
05:37:05 <osfameron> scook0: what's type application
05:37:06 <osfameron> ?
05:37:07 <scook0> (well, application of the type-constructor (->) to type-variable r)
05:37:38 <osfameron> quicksilver: *from* (r->r->) ?  don't you then have 2 r's to squash together?
05:37:42 <scook0> try not to be too confused by my sloppy terminology :/
05:38:06 <scook0> osfameron: if you have a function (r -> r -> a)
05:38:11 <quicksilver> osfameron: well (r -> r ->) had two arguments. YOu're converting that to something with only one argument.
05:38:16 <osfameron> scook0: don't worry. I'm not being pedantic, just genuinely ignorant :-)
05:38:21 <quicksilver> osfameron: so, somehow, you need to manufacture two from one.
05:38:27 <quicksilver> osfameron: there is one natural way to do that.
05:38:45 <osfameron> ah, ok
05:38:53 <scook0> osfameron: I know, I'm just trying not to accidentally mislead you
05:39:26 <oerjan> @djinn (r -> r -> a) -> (r -> a)
05:39:26 <lambdabot> f a b = a b b
05:39:33 <ydo> I guess I should read a book or something..
05:39:53 <oerjan> osfameron: ^^ that's join in the -> monad
05:40:20 <oerjan> the only sensible function with the right type
05:40:59 <roconnor> the only function with the type. :)
05:41:29 <oerjan> sensible = not bottom, unsafePerformIO, seq etc.
05:41:44 <osfameron> join seems to be often written by a process of elimination.  I still don't understand why the end result is often actually useful :-)
05:42:02 <oerjan> @src join
05:42:03 <lambdabot> join x =  x >>= id
05:42:41 <MyCatVerbs> @tgt join
05:42:41 <lambdabot> Maybe you meant: ft let thx
05:43:00 <MyCatVerbs> Awwww, no target? I thought Haskell functions were supposed to be analogous to arrows. :(
05:43:26 <oerjan> indeed.
05:43:46 <roconnor> oerjan: join is the W combinator is Curry's(?) BCKW calculus
05:44:00 <roconnor> osfameron: er, that was for you
05:44:00 <scook0> in mathematics, monads are defined in terms of (join, fmap/liftM, return) instead of ((>>=), return)
05:44:05 <roconnor> well it is for everyone :)
05:44:09 <scook0> (though they use more greek letters)
05:44:46 <scook0> for programming, (>>=) seems to be a more useful operation than join most of the time
05:45:04 <MyCatVerbs> fmap is usually equivalent to liftM for things that're instances of both Functor and Monad, right?
05:45:34 <scook0> I'm not aware of any instances that don't obey that
05:45:38 <oerjan> yep.  in fact there is only one sensible function with that type, too
05:45:53 <oerjan> (such that f id = id)
05:46:14 <scook0> in an ideal world, all Monads would be Functors, since all monads are functors
05:46:21 <roconnor> http://en.wikipedia.org/wiki/B%2CC%2CK%2CW_system
05:46:43 <scook0> but it's easy enough to make any particular Monad a Functor, using liftM
05:46:51 <Saul_> @src monad
05:46:51 <lambdabot> Source not found. It can only be attributed to human error.
05:47:10 <oerjan> @src Monad
05:47:11 <lambdabot> class  Monad m  where
05:47:11 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
05:47:11 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
05:47:11 <lambdabot>     return      :: a -> m a
05:47:11 <lambdabot>     fail        :: String -> m a
05:47:39 <oerjan> @src Functor
05:47:39 <lambdabot> class  Functor f  where
05:47:40 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
05:51:21 <Toxaris> is it somehow possible to define a function join' so that join' (.) join' == join . join ?
05:51:35 <Toxaris> (I mean == join' . join' of course)
05:51:51 <scook0> huh?
05:52:08 <scook0> I don't get what your question is
05:52:16 <nornagon> :t join (.)
05:52:18 <lambdabot> forall b. (b -> b) -> b -> b
05:52:22 <Saizan> Toxaris: the problem there is that the two joins on RHS are instanced to different types
05:52:49 <Toxaris> Saizan: yes, I figured so much. But is there a work-around?
05:53:03 <MyCatVerbs> scook0: wouldn't it be possible to provide a default instance Monad a => Functor a where fmap = (>>=) ?
05:53:08 <scook0> f g f == g f f in other words
05:53:29 <scook0> MyCatVerbs: not out-of-the-box
05:53:31 <MyCatVerbs> scook0: or would that cause some problem(s) with the way the typeclasses system works?
05:53:34 <oerjan> MyCatVerbs: the problem is that it would overlap with every other Functor instance
05:53:44 <scook0> enabling some tricky GHC extensions might allow it
05:53:47 <nornagon> scook0: f g h = ?
05:54:06 <oerjan> because the Monad a => is only checked after lookup
05:54:23 <MyCatVerbs> oerjan: Ahhh, I see. Yes, that would be a pain.
05:54:39 <scook0> theoretically, enabling those extensions shouldn't cause problems
05:54:53 <scook0> since existing Monad&Functor instances should already obey liftM=fmap
05:55:05 <scook0> but I can't say for sure :)
05:55:18 <MyCatVerbs> Theoretically, there's no significant difference between theory and practice. ;)
05:56:00 <scook0> I guess my point is that the default instance restrictions are there to prevent you from doing (some) stupid things
05:56:19 <scook0> but they also prevent some legitimate things, which is why the extensions can be useful
05:57:09 <dcoutts> scook0: I had a proposal where Monad could define defaults for Functor
05:57:15 <quicksilver> well, overlapping instances is quite ugly
05:57:32 <quicksilver> I don't think anybody is really happy with the 'choose most specific instance' rule
05:57:36 <quicksilver> it's too fragile
05:57:48 <quicksilver> not very compositional.
05:57:55 <dcoutts> you know how a class can declare default impls of methods, well if that class extends another one, why not allow default impl of methods for the superclass
05:57:59 <quicksilver> the "right" answer is simply for Functor to be a superclass of Monad.
05:58:05 <scook0> dcoutts: in my view, that is very important to any "class aliases" proposal
05:58:11 <quicksilver> and a defaults enhancment like dcoutts suggests would just make it a bit easier :)
05:58:12 <dcoutts> quicksilver: yes, with a default impl
05:58:12 <roconnor> not that the current type class systems is very compositional.
05:58:20 <quicksilver> roconnor: no, it's not
05:58:25 <quicksilver> roconnor: but overlaps are even worse :)
05:58:31 <roconnor> :)
05:58:38 <scook0> quicksilver: overlapping instances et al. are fine if, for example, all of the instances are known/proven to be equivalent
05:59:07 <scook0> as *should* be the case in Monad=>Functor
05:59:41 <quicksilver> scook0: but that's not what instance Monad a => Functor a means
05:59:49 <quicksilver> scook0: it means that *all* types a get that instance
05:59:53 <quicksilver> (whether they be monads or not)
06:00:00 <quicksilver> but the monad constraint gets added
06:00:16 <scook0> oh, I did not know that
06:00:26 <quicksilver> so, if you were'nt careful, ZipList would get that Functor instance
06:00:34 <quicksilver> but it would acquire a Monad constraint in the process
06:00:37 <quicksilver> definitely not wanted :)
06:00:48 <Saizan> dcoutts: if you still have to instance Functor i don't see it so problematic to add a fmap = liftM line..
06:00:58 <quicksilver> of course, with correct overlap resolution it would be ok.
06:01:15 <oerjan> quicksilver: ZipList could be a monad though :)
06:01:29 <scook0> incidentally, I find myself writing where (<$>) = liftM quite a bit these days :)
06:01:29 <Igloo> nomeata: Please prod me tomorrow if I haven;t done anything about it by then
06:01:46 <oerjan> not a very useful one, though - join is taking the main diagonal
06:02:01 <dcoutts> Saizan: right, if we do that, is there any need for the class alias proposal?
06:02:04 <nomeata> Igloo: great. Iâ€™m just writing a mail to the debian-haskell list with some notices about ghc6.8 and haskell-utils.
06:02:22 <scook0> oerjan: though wouldn't that cause ap to conflict with <*>?
06:02:32 <scook0> (I seem to recall that being noted somewhere)
06:02:48 <oerjan> scook0: obviously Applicative should also be a superclass
06:03:29 <quicksilver> dcoutts: well, the class alias proposal becomes more interesting the more finegrained the hierarchy becomes
06:03:52 <scook0> discovering new points in class hierarchies seems to be a popular hobby :P
06:03:53 <quicksilver> dcoutts: for Functor/Monad alone I don't think it's vital by any means.
06:04:15 <dcoutts> quicksilver: Functor => Applicative => Monad
06:04:43 <doserj> quicksilver: if you have to implement more than one method for a class, the hierarchy is not fine-grained enough :)
06:04:49 <EvilTerran> => MonadZero => MonadPlus
06:05:30 <oerjan> EvilTerran: with Applicative => Alternative => MonadPlus
06:05:41 <EvilTerran> hm
06:05:58 <Toxaris> would pure alias return make sense without <*> or >>=?
06:06:09 <scook0> doserj: makes you wonder if the functions themselves should be "first-class", instead of the classes
06:06:30 <oerjan> hm MonadZero would seem to require a corresponding Applicative
06:06:47 <doserj> Toxaris: class Box b where box:: a -> b a
06:07:17 <EvilTerran> class Return ...?
06:07:23 <oerjan> something like that
06:07:32 <oerjan> no, class Failable
06:07:54 <oerjan> or Fallible
06:08:08 <EvilTerran> classes Return, Fail, Bind
06:08:37 <oerjan> i have a hunch there _will_ be multiple inheritance problems
06:08:53 <oerjan> especially with things spread across modules
06:09:34 <oerjan> and defaults trickling up everywhere
06:10:35 <Toxaris> there is no need for MonadPlus, we should use (Alternative f, Monad f) => ... instead
06:11:36 <oerjan> scook0: i think Clean has a one function per class system
06:11:59 <oerjan> Toxaris: plus of course an actual alias
06:13:06 <oerjan> scook0: with the class named the same as the function
06:13:22 <oerjan> which of course Haskell does not support
06:13:58 <scook0> interesting
06:14:36 <scook0> that plus class aliases might be nice, though there are probably gotchas I haven't thought of
06:15:39 <oerjan> hm that's an interesting idea.  is there actually any syntactic ambiguity to allowing lower-case class names?  i can think of export/import lists, but they would need improvement anyhow
06:16:33 <EvilTerran> they could be easily disambiguated with import ... (..., class foo, ...)
06:16:42 <oerjan> my thought too
06:16:54 <scook0> only problem I can think of is confusion with lower-case type variables where a type is expected
06:17:01 <scook0> (at least from a human's point of view)
06:17:05 <EvilTerran> altho, if the class name was inexorably linked to one of the method names, that wouldn't even be necessaryu
06:17:11 <EvilTerran> scook0 has a point, actually
06:17:22 <oerjan> i.e. harder to read
06:17:50 <oerjan> and more lookahead in the parser, i guess
06:17:52 <scook0> or we could pretend to be Larry Wall and slap a sigil in front of the function name :)
06:18:07 <EvilTerran> lowercase identifiers in type annotations are currently variables, and uppercase ones not
06:18:20 <EvilTerran> altho, with explicit quantification, that'd not be a problem, i guess (?)
06:18:32 <oerjan> i want a sigil for field names, to automatically denote the corresponding functional reference
06:19:12 <scook0> oerjan: heh, I have some TH that effectively makes _ such a symbol :)
06:19:27 <oerjan> scook0: cool!
06:20:19 <scook0> or you can use overloaded references, so the accessor function and reference have the same name
06:21:12 <scook0> it seems that "derive functional references using TH" has been done many many times over
06:21:38 <BMeph> scook0: Everyone that loves fiddling around with high-order (if that's the right name for it) tuples would Love that capability
06:22:10 <scook0> nested tuples?
06:22:41 <BMeph> High order? High degree? What's the right name for "large number of members of a tuple"?
06:23:00 <scook0> heh
06:23:02 <EvilTerran> high cardinality?
06:23:04 * roconnor votes for high dimension
06:23:15 <Toxaris> BMeph: are you talking about (a,b,c,d) or (a, (b, (c, (d, ()))))?
06:23:22 <EvilTerran> high arity, even?
06:23:43 <BMeph> Some people I know use nested tuples, because, for example, Haskell's tuple-manipulating functions stop before you get to eight.
06:24:06 <scook0> there's also HList for that kind of trickery
06:24:07 <flux> they don't go up to eleven? insane!
06:24:13 <EvilTerran> given that the number of elements in it is the same as the arity of the constructor, i'd be inclined to go for arity
06:24:30 <Toxaris> Control.Arrow uses nested tuples
06:24:31 <flux> (or even ten ;))
06:24:31 <BMeph> Toxaris: Folks using ((a,b),(c,d),(e,f),(g,h)) because they cannot easily manipulate (a,b,c,d,e,f,g,h).
06:24:52 <scook0> "arity" feels slightly wrong, but it's also highly likely to be understood correctly
06:24:54 <Toxaris> BMeph: now that data layout i find crazy. did you tell them about "data"?
06:25:19 <EvilTerran> wikipedia says "rank" is synonymous with "arity"
06:25:26 <EvilTerran> better?
06:25:50 <scook0> I like "arity" simply because you probably won't have to explain it to the other person
06:26:11 * EvilTerran would only use nested tuples in the cases where it would provide semantic information to do so
06:26:36 * scook0 caddadaar
06:26:49 <BMeph> Toxaris: Yes = "Dude, just roll your Own data types, it's much easier!" "...but I can do the same thing with the nested tuples, w/o having to invent new functions." "But, half of the fun of Haskell is in making your own functions! :)" "Well, you can have your fun, I'm trying to work."
06:27:02 <osfameron> hehe
06:27:11 <EvilTerran> eg, type Triple a = (a,a,a); type Square a = Triple (Triple a); type Sudoku = Square (Square Int)
06:27:25 <scook0> I feel uneasy using naked types to represent my data
06:27:38 <scook0> so I almost never use type declarations
06:27:40 * EvilTerran has those very lines in his sudoku solver
06:28:03 <scook0> nominal typing for life!
06:28:10 <EvilTerran> om nom nominal typing?
06:28:11 <nornagon> BMeph: if you restrict yourself to two-tuples, you can get through the tuple with just fst and snd! (((a,b),(c,d)),((e,f),(g,h))) :D
06:28:29 <nornagon> EvilTerran: haha
06:28:30 * EvilTerran points nornagon to "* scook0 caddadaar"
06:28:44 <EvilTerran> :D
06:28:47 <Toxaris> but binary layout leads to faster access times
06:28:47 <oerjan> nornagon: and use curry and uncurry
06:28:48 <nornagon> <.<
06:29:08 <BMeph> nornagon: Please, don't say that too loud - then my friends will Never leave it alone! =8*O
06:29:39 * EvilTerran notes that BMeph's nose seems to have exploded
06:29:54 <BMeph> Octonions are confusing enough w/o worrying over the representational layout. p
06:30:40 <Toxaris> BMeph: what are there for builtin tuple manipulation functions wich are not available for home-made data types?
06:31:00 <EvilTerran> if you derive Data, nothing! :D
06:31:17 <nornagon> @src Data
06:31:17 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
06:31:28 <nornagon> @index Data
06:31:29 <lambdabot> Data.Generics.Basics, Data.Generics
06:31:35 <nornagon> @src Data.Generics.Data
06:31:35 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
06:31:41 <roconnor> Hmm, the wikibook on linear algebra is missing a lot
06:32:10 <nornagon> @src Data.Generics.Basics.Data
06:32:11 <lambdabot> Source not found. You type like i drive.
06:32:38 <BMeph> ROFL! I never noticed that lower-case "i" before - that's funny!
06:32:46 <EvilTerran> you don't ever manually instantiate Data, so you don't need to know the source ;)
06:33:09 <BMeph> EvilTerran: "You can't handle the source"? ;)
06:33:31 <EvilTerran> that's quite likely, actually
06:33:56 <EvilTerran> i hear the guts of Data.Generics is fairly horrific
06:34:50 <BMeph> Toxaris: Mostly, it's doing silly stuff with zipping (and not with Zippers, heaven forbid, that's another weird Data type...). :)
06:34:55 <BMeph> @bot
06:34:56 <lambdabot> :)
06:35:26 * BMeph is glad that he's not the only one who abuses the Smilie protocols...
06:35:44 <EvilTerran> @vixen Smile!
06:35:49 <lambdabot> you seem upset...
06:35:59 <Toxaris> well, there is zipWith
06:37:30 <EvilTerran> zapp!
06:37:30 <oerjan> ZOT!
06:37:31 <Toxaris> hehe, the ZipList idion should be usable as  zip <many lists> zap
06:37:31 <Toxaris> idiom
06:37:34 <scook0> zippety <many lists> doodah
06:38:01 <BMeph> Toxaris: Then everyone will start bugging poor dons to do it with Streams, too... ;)
06:41:42 <oerjan> merrily merrily
06:41:43 <BMeph> Actually, curry/uncurry would go well with Streams. Uh-oh...
06:44:45 <rxpat> I'm trying to learn Haskell for the n-th time. I tried in different ways but I don't see an easy way out to solve this exercise I found in a book: Define a function removeFst that removes the first occurrence of an integer m from a list of integers. If m does not occur in the list, the list remains unchanged. I'm sure it's trivial, but my haskell skill are very rusty at the moment.
06:44:54 <BMeph> EvilTerran: Wouldn't a Sudoku be more like a Square (Square (Square (Square Int))))? ;)
06:45:17 <EvilTerran> no...
06:45:23 <BMeph> rxpat: You want nub
06:45:26 <EvilTerran> it's a 3x3 square of 3x3 squares
06:45:54 <EvilTerran> it'd be a Triple (Triple (Triple (Triple Int)), tho
06:45:55 <quicksilver> BMeph: "define a function" does not mean "locate a function in the standard library ;)"
06:46:02 <Zao> rxpat: It should be a simple recursive function.
06:46:06 <oerjan> BMeph: no he doesn't
06:46:33 <BMeph> EvilTerran: Oh, yeah, I got you - the Suquare is already that 3x3 structure.
06:46:37 <BMeph> @src nub
06:46:37 <lambdabot> nub = nubBy (==)
06:46:43 <EvilTerran> indeed. hence "square". :P
06:46:45 <quicksilver> rxpat: like most simple list functions, you define it by recursion with cases for (x:xs) and []
06:46:53 <BMeph> @src nubBy (==)
06:46:53 <lambdabot> Source not found. Where did you learn to type?
06:47:04 <oerjan> BMeph: nub removes every occurence _except_ the first, of _all_ the items
06:47:49 <rxpat> quicksilver: I guess what I need to know is... how do I obtain the element position and how do I drop an element
06:48:48 <oerjan> BMeph: deleteFirstBy could do it, but is overkill
06:48:54 <oerjan> *FirstsBy
06:49:12 <scook0> rxpat: it would probably be easier to directly write a recursive function on the structure of lists
06:49:25 <scook0> i.e. removeFirst elem [] = []
06:49:34 <scook0> removeFirst elem (x:xs) = ...
06:49:40 <BMeph> oerjan: Ah, yes, thanks. I think my anti-allergy medicine is working on my brain directly, and not just my nose. ;)
06:49:44 <quicksilver> rxpat: element positions won't be part of it
06:50:00 <quicksilver> rxpat: it's quite unusual in haskell to think positionally, in fact
06:50:09 <quicksilver> it's not well suited to the list model
06:50:14 <rxpat> ok, in C I would loop in the list, in Haskell it has to be different
06:50:26 <quicksilver> it will still be a loop
06:50:28 <BMeph> quicksilver: Is that because of the history of the list monad definition? :)
06:50:32 <quicksilver> the different will be what it does
06:50:36 <quicksilver> in C you would modify the list
06:50:40 <quicksilver> in haskell, you can't modify
06:50:47 <quicksilver> so you're generating a new list for the result
06:50:48 <rxpat> quicksilver: side effects and all that
06:50:49 <scook0> BMeph: it's because haskell (and most FP) lists are linked-lists
06:51:00 <quicksilver> apart from that the basic pattern would be very similar
06:51:04 <quicksilver> loop the list, looking for the element
06:51:07 <Zao> rxpat: In C you would follow the next pointer in your homebrew linked list until you found the first occurence.
06:51:10 <quicksilver> once you've found it once....
06:51:43 <rxpat> let me try, I'll be back so you tell me if it's decent or not
06:52:46 <BMeph> removeFst elem (x:xs) = case (elem == x) of { True -> xs; False -> x:removeFst elem xs }
06:53:08 <BMeph> Does that look right?
06:53:09 <oerjan> > (uncurry(++).second(drop 1).break(==5)) [1..10]
06:53:12 <lambdabot>  [1,2,3,4,6,7,8,9,10]
06:53:15 <Zao> BMeph: Guards are your friends :)
06:53:15 <BMeph> Better: IS that right?
06:53:29 <oerjan> (just teasing :) )
06:53:54 <BMeph> Zao: Guards are against my religion. ;)
06:54:00 <scook0> BMeph: and case analysis on Bool is pretty rare ... most people just use if
06:54:38 <BMeph> removeFst elem (x:xs) = if' (elem == x) xs x:removeFst elem xs
06:54:47 <BMeph> scook0: Like that?
06:55:04 <scook0> removeFst elem (x:xs) = if elem == x then xs else x : removeFst elem xs
06:55:43 <scook0> but for this example, I'd use guards :)
06:55:52 <Toxaris> BMeph: you need parens around (x:...)
06:55:56 <BMeph> removeFst elem (x:xs) = if' (elem == x) xs (x:removeFst elem xs)
06:56:10 <BMeph> Toxaris: yeah, I figured... :)
06:56:44 <rxpat> how do you concat two lists? [1,2,3] and [4,5,6]
06:56:49 <Zao> rxpat: ++
06:56:56 <EvilTerran> @hoogle [a] -> [a] -> [a]
06:57:02 <lambdabot> Prelude.(++) :: [a] -> [a] -> [a]
06:57:02 <lambdabot> Data.List.(++) :: [a] -> [a] -> [a]
06:57:02 <lambdabot> Data.List.deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
06:57:05 <Toxaris> > [1, 2, 3] ++ [4, 5, 6]
06:57:05 <oerjan> > flip(flip deleteFirstsBy.return) 5 [1..10]
06:57:07 <lambdabot>  [1,2,3,4,5,6]
06:57:08 <lambdabot>        add an instance declaration for (Num ([t] -> [t] -> Bool))
06:57:41 <BMeph> oerjan: Huh? :)
06:57:42 <oerjan> > flip(flip deleteFirstsBy.((==)`on`).return) 5 [1..10]
06:57:42 <lambdabot>   Not in scope: `on'
06:57:54 <rxpat> allright. I think I got it.
06:57:58 <oerjan> @let on (==) f x y = f x == f y
06:57:58 <rxpat> hpaste is coming
06:57:59 <lambdabot> Defined.
06:58:03 <oerjan> > flip(flip deleteFirstsBy.((==)`on`).return) 5 [1..10]
06:58:03 <lambdabot>  Couldn't match expected type `[a]'
06:58:07 <oerjan> sheesh
06:58:19 <oerjan> BMeph: cannot get the type right
06:58:21 <gbacon> > map ((+1) . join (*)) [1..5]
06:58:21 <lambdabot>  [2,5,10,17,26]
06:58:26 <oerjan> :t deleteFirstsBy
06:58:26 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a] -> [a]
06:58:31 <gbacon> such a good lambdabot
06:59:18 <hpaste>  rxpat pasted "Remove First attempt" at http://hpaste.org/4383
06:59:25 <oerjan> > flip(flip deleteFirstsBy(==).return) 5 [1..10]
06:59:25 <lambdabot>  Couldn't match expected type `[a]'
06:59:56 <gbacon> :t (==).return
06:59:59 <lambdabot> forall a (m :: * -> *). (Eq (m a), Monad m) => a -> m a -> Bool
07:00:06 <EvilTerran> > flip(flip(deleteFirstsBy(==)).return) 5 [1..10]
07:00:07 <lambdabot>   add an instance declaration for (Num [[t]])
07:00:26 <rxpat> am I on the right track? (http://hpaste.org/4383)
07:00:37 <oerjan> > (flip deleteFirstsBy(==).return) 5 [1..10]
07:00:39 <lambdabot>  Couldn't match expected type `[a]'
07:00:58 <oerjan> > (flip(deleteFirstsBy(==)).return) 5 [1..10]
07:00:59 <gbacon> rxpat: what do your QuickCheck properties say? :-)
07:01:00 <lambdabot>  [1,2,3,4,6,7,8,9,10]
07:01:04 <oerjan> whew
07:01:17 <Toxaris> rxpat: right track, yes. but you can follow it further :)
07:01:48 <rxpat> gbacon: QuickCheck? What's that?
07:02:24 <gbacon> http://www.cs.chalmers.se/~rjmh/QuickCheck/
07:02:26 <lambdabot> Title: QuickCheck: An Automatic Testing Tool for Haskell
07:02:28 <gbacon> quickcheck rocks!
07:02:38 <Toxaris> rxpat: a minor point: you should use (:) instead of (++) since you only want to prepend a single element
07:02:54 <rxpat> thanks Toxaris
07:03:08 <rxpat> gbacon: maybe an overkill for my exercise? :)
07:03:11 <hpaste>  scook0 annotated "Remove First attempt" with "a few comments" at http://hpaste.org/4383#a1
07:03:23 <Toxaris> rxpat: more important: notElem is very expensive, do you need to call it that often? do you need to call it at all?
07:03:27 <gbacon> rxpat: no, it'd be great exercise
07:03:46 <gbacon> rxpath: right, you're already doing notElem's work
07:04:50 <rxpat> gbacon: good point. I'll try quickcheck
07:05:41 <hpaste>  scook0 annotated "Remove First attempt" with "my version" at http://hpaste.org/4383#a2
07:06:11 <hpaste>  rxpat annotated "Remove First attempt" with "Second Attempt at removeFst" at http://hpaste.org/4383#a3
07:07:00 <rxpat> actually, let me do a further change
07:07:42 <hpaste>  rxpat annotated "Remove First attempt" with "Third attempt and then back to QuickCheck" at http://hpaste.org/4383#a4
07:08:27 <Toxaris> rxpat: you don't need the parens around the recursive call, because function application has always priority over operator application
07:08:48 <rxpat> I see Toxaris
07:09:04 <scook0> though sometimes I like to put them in anyway, when it helps readability
07:09:10 <hpaste>  gbacon annotated "Remove First attempt" with "(no title)" at http://hpaste.org/4383#a5
07:09:15 <rxpat> now, regarding QuickCheck
07:09:24 <scook0> e.g. my redundant parens on (e == x)
07:10:23 <rxpat> from hugs how I do I "load" QuickCheck
07:11:38 <oerjan> rxpat: put import Test.QuickCheck in your main file
07:12:10 <oerjan> (you could load _just_ quickcheck with :l, but then you wouldn't have access to your program)
07:13:40 <oerjan> alas Hugs supports only one "root" file to load at a time
07:14:04 <shapr> flippo: *poke*
07:14:44 <rxpat> ok, QuickCheck told me that I messed it up
07:14:48 <flippo> shapr, howdy
07:15:44 <rxpat> gbacon: but I notice that it's the prop to be wrong
07:15:56 <shapr> flippo: Long time no see, are you back to Haskell?
07:16:24 <rxpat> but this is cool, nevertheless
07:16:31 <rxpat> thanks people
07:16:34 <flippo> shapr, not really, but I decided to stop feeling guilty about coming here anyway.
07:16:50 <shapr> flippo: hah
07:17:02 <flippo> shapr, I'm still trying to think of something useful I can do with it, other than admire it.
07:17:29 <shapr> flippo: taxes?
07:18:33 <flippo> shapr, gah.  Actually, tracking finances isn't such a bad idea.  I've used scripts for that before.
07:18:57 <flippo> shapr, I was hoping to think of something relevant to my research, though.
07:20:32 <flippo> shapr, I do mostly numerical work, but occasionally more.  Most researchers in my field use Fortran or C.
07:21:17 * BMeph pities the first Vietnamese programmer named "Pho Tran"; poor soul didn't have a chance...
07:21:23 <byorgey> eek
07:22:05 <flippo> BMeph, heh
07:22:20 <shapr> flippo: Ok, so finance tracking...
07:22:32 <flippo> Yaaawn.
07:23:01 <shapr> Hey, it'll get you started with Haskell, and then you can see if you can do work-related stuff as well.
07:23:39 <flippo> shapr, you're quite an evangelist.  The best, really.
07:23:48 <shapr> :-)
07:24:06 <byorgey> @remember flippo shapr, you're quite an evangelist.  The best, really.
07:24:06 <lambdabot> It is stored.
07:24:08 <byorgey> so true.
07:24:10 <oerjan> @go pho-tran
07:24:11 <lambdabot> http://www.eclipse.org/photran/
07:24:12 <lambdabot> Title: Photran - An Integrated Development Environment for Fortran
07:24:28 <byorgey> are there any physics engines written in Haskell?
07:25:22 <BMeph> byorgey: I think Oleg's writing a quantum interaction simulator...in the type system, of course. ;)
07:25:30 <byorgey> BMeph: haha!
07:25:39 <oal`> lawl
07:26:01 <oerjan> mm, quantum types
07:26:01 <oal`> byorgey, numeric prelude has a bit of physics
07:27:25 <tetha> if you want a language for numerical calculations in a functional way, you could take a look at sac
07:27:45 <shapr> Proselytizing Haskell to analytic programmers isn't difficult. It's like selling toys to children.
07:29:01 <quicksilver> shapr: I like toys.
07:29:03 * BMeph imagines shapr in an alley, wearing a trenchcoat, offering Haskell to little girls...
07:29:11 <shapr> BMeph: yeesh
07:29:14 <ricky_clarkson> on a unicycle
07:29:21 <shapr> haha
07:29:33 * shapr throws sugar lambdas at BMeph 
07:30:09 * shapr is thinking about unicycle upgrades...
07:30:19 * byorgey imagines shapr riding a unicycle while juggling sugar lambdas.
07:30:40 * BMeph wonders if Oleg will come along and develop a type system for shapr's unicycle...
07:31:40 <shapr> BMeph: How would you apply type theory to a unicycle?
07:32:12 <scook0> presumably by introducing a monotype
07:32:26 <dylan> shapr: You could say selling haskell to Java programmers is like selling pants to the naked.
07:32:34 <shapr> dylan: oooh
07:32:40 <shapr> scook0: hah!
07:32:41 * tetha is pondering about inductive unicycles. if you combine 2 unicycles, you get another unicycle. even if you combine a number of unicycles with a unicycle, you get another unicycle... thingy
07:32:46 <Nafai> Yay for pants!
07:33:03 <Stinger> if you combine two unicyles you get a bicycle :P
07:33:28 <tetha> darn :) thus, the set of unicycles is no group
07:33:36 <tetha> given the general composition
07:33:40 <Stinger> cycles perhaps
07:33:43 <Zao> So no unicycle algebra?
07:33:59 <Stinger> but then what is the identity?
07:34:05 <Stinger> the nocycle :(
07:34:13 <tetha> Zao: with a secial composition, yes. that would be "tape wheel to seat"
07:35:02 <shapr> http://www.geekologie.com/2007/07/09/ultimate-wheel.jpg ?
07:35:38 <tetha> hm. taping to pedals?
07:35:44 <Stinger> oh god that looks dangerous
07:36:00 <byorgey> Stinger: probably safer than a unicycle.
07:36:05 <shapr> :-P
07:36:13 <byorgey> hehe
07:36:59 <shapr> So, is anyone hacking Haskell this fine morning?
07:37:09 <dylan> I am.
07:37:21 <dylan> working on a thing for keeping track of my various machine's IPs.
07:37:33 * tetha has no time. He gotta hack together great mighty unittests in java :(
07:37:36 <dylan> no matter which one is offline.
07:37:49 <dylan> (no central server).
07:38:11 <shapr> tetha: Maybe you could use the jvm bridge to get QuickCheck in Java?
07:38:23 <gbacon> rxpat: still there?
07:39:29 <tetha> shapr: I guess I could, but the other great mighty tool of code coverage wont accept bytecode-tests afaik. and most tests are just for that code coverage *coughs*
07:39:30 <RayNbow> heh, dons' name is being mentioned in http://www.londonhug.net/2007/09/25/nested-data-parallelism-video-returns/ :p
07:39:33 <lambdabot> Title: Î»ondon HUG » Blog Archive » Nested Data Parallelism Video Returns!, http://tinyurl.com/2pw275
07:39:56 <Nafai> shapr: Ooo.  That's a fun idea
07:49:46 <shapr> tetha: You could use quickcheck to generate random input for tests written in java. Then you get coverage and entertainment!
07:50:03 <tetha> :D
07:50:39 <tetha> I could even try to generate a tool that analyses my code and recognizes edge cases and raises the proability of inputing a testcase. even more entertainment
07:51:17 <tetha> noo, tetha, stop thinking about that right now.
07:52:47 <shapr> I was reading a paper about that yesterday.
07:53:47 <tetha> is it available online? available
07:53:48 <tetha> err
07:53:49 <tetha> heh :)
07:56:19 <Nafai> I wish I could somehow slip Haskell into my Java work
07:57:16 <mrd> i wrote testing stuff
07:57:35 <tetha> In our softwareproject from university, we implemented simple, crude patternmatching on our most important datastructure.. so, just apply "you can code fortran in any language" :)
08:00:03 <Saizan> can someone point me to a paper on applicative parser combinators?
08:00:19 <ricky_clarkson> I've written a QuickCheck-alike in the prototype Java 7.
08:02:36 <heisenbug> any readline lib experts around?
08:03:06 <heisenbug> haskell readline
08:03:15 <heisenbug> bindings
08:03:48 <ricky_clarkson> check({Float f=>f+1!=f})
08:06:16 <heisenbug> I am looking for something like (hIsTTY :: IO Bool)
08:06:38 <heisenbug> errr, (hIsTTY :: Handle -> IO Bool)
08:06:39 <mux> hIsTty :: Handle -> IO Bool actually
08:06:42 <mux> yeah :-)
08:06:50 <mux> it wouldn't be hard to write FFI bindings for isatty()
08:06:51 <mauke> @hoogle tty
08:06:52 <lambdabot> Data.Typeable.funResultTy :: TypeRep -> TypeRep -> Maybe TypeRep
08:06:52 <lambdabot> Foreign.C.Error.eNOTTY :: Errno
08:06:52 <lambdabot> Data.Typeable.splitTyConApp :: TypeRep -> (TyCon, [TypeRep])
08:06:52 <heisenbug> coooL
08:07:38 <mauke> heisenbug: queryTerminal
08:08:03 <heisenbug> :t queryTerminal
08:08:04 <lambdabot> Not in scope: `queryTerminal'
08:08:13 <mauke> @index queryTerminal
08:08:13 <lambdabot> System.Posix.Terminal, System.Posix
08:08:26 <mauke> :t System.Posix.Terminal.queryTerminal
08:08:26 <lambdabot> System.Posix.Types.Fd -> IO Bool
08:08:56 <heisenbug> fd would be 0 for stdin?
08:09:24 <mux> you can use HandleToFd
08:09:31 <mux> err, handleToFd
08:09:35 <mux> it's in System.Posix.IO
08:09:37 <mauke> mux: no, you can't
08:09:44 <mauke> heisenbug: stdInput
08:10:01 <mux> yeah but what when you need to test something else than stdio?
08:10:23 <mauke> openFd
08:10:53 <mux> that's still not fitting every scenario..
08:11:40 <mauke> for example?
08:12:14 <mux> for example I have a Handle, and I want an Fd for doing one of the hundreads different things that would need me to pass an fd
08:12:20 <mux> obviously
08:12:35 <mux> it sure isn't going to be of much use for isatty()
08:13:00 <mauke> then you're screwed because handleToFd closes the Handle
08:13:11 <mux> that's not necessarily a problem
08:13:26 <mauke> then why open a Handle in the first place?
08:13:57 <mux> for any of the obvious reasons, who knows what you might have needed to do before hand
08:15:28 <mrd> 353% CPU usage!
08:16:09 <mauke> compiling with -O23 again?
08:16:36 <mrd> -
08:16:38 <mrd> -Okickass
08:24:54 <heisenbug> thanks so far, it seems to work.
08:25:29 <heisenbug> now what is the difference between readLn, getLine and hGetLine ? :-O
08:25:49 <oerjan> :t readLn
08:25:50 <lambdabot> forall a. (Read a) => IO a
08:25:53 <oerjan> :t getLine
08:25:54 <lambdabot> IO String
08:25:58 <oerjan> :t hGetLine
08:25:58 <lambdabot> Not in scope: `hGetLine'
08:26:00 <mauke> heisenbug: getLine reads a line
08:26:03 <oerjan> :t IO.hGetLine
08:26:03 <lambdabot> GHC.IOBase.Handle -> IO String
08:26:09 <mauke> readLn gets a line and parses it
08:26:22 <mauke> it's nice when you need a number or something
08:26:26 <oerjan> @src readLn
08:26:26 <lambdabot> readLn =  do l <- getLine; r <- readIO l; return r
08:26:33 <oerjan> @src getLine
08:26:34 <lambdabot> getLine = hGetLine stdin
08:26:41 <heisenbug> okay, readLn is in a class?
08:26:54 <oerjan> @src readIO
08:26:54 <lambdabot> Source not found. Sorry.
08:27:03 <mauke> heisenbug: no
08:27:05 <oerjan> @src Read
08:27:05 <lambdabot> class Read a where
08:27:05 <lambdabot>   readsPrec    :: Int -> ReadS a
08:27:05 <lambdabot>   readList     :: ReadS [a]
08:27:05 <lambdabot>   readPrec     :: ReadPrec a
08:27:05 <lambdabot>   readListPrec :: ReadPrec [a]
08:27:31 <oerjan> :t readIO
08:27:31 <lambdabot> forall a. (Read a) => String -> IO a
08:27:39 <byorgey> hm, why readIO?
08:27:41 <heisenbug> okay, got it
08:27:47 <oerjan> to get fail rather than error, i think
08:28:00 <byorgey> oh, ok
08:29:06 <oerjan> @src fail
08:29:06 <lambdabot> fail s      = error s
08:29:12 <oerjan> @src error
08:29:13 <lambdabot> error s = throw (ErrorCall s)
08:29:32 <oerjan> @src IO fail
08:29:32 <lambdabot> fail s  = failIO s
08:29:37 <oerjan> @src failIO
08:29:38 <lambdabot> failIO s = ioError (userError s)
08:29:49 <oerjan> ah, thought so.  it could have been readM
08:30:27 <oerjan> readIO uses ioError . userError, which is just fail
08:30:47 <oerjan> everything else is monad polymorphic
08:30:56 <oerjan> @index readM
08:30:56 <lambdabot> bzzt
08:31:11 <byorgey> @src readM
08:31:12 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
08:31:20 <byorgey> :t readM
08:31:22 <lambdabot> Not in scope: `readM'
08:31:28 <byorgey> @hoogle readM
08:31:28 <lambdabot> Control.Concurrent.MVar.readMVar :: MVar a -> IO a
08:31:28 <lambdabot> System.IO.ReadMode :: IOMode
08:31:41 <oerjan> it doesn't exist, i just say that readIO -> readM simply by simplifying the source
08:31:55 <oerjan> to use fail instead
08:33:05 <byorgey> oh, ok.  something like readM s = (return $ read s) `catch` (\_ -> fail "") ?
08:33:17 <quicksilver> byorgey: nah, you'd use readS
08:33:29 <byorgey> quicksilver: oh, right, fair enough
08:33:35 <oerjan> you cannot catch outside an Error monad
08:33:39 <quicksilver> byorgey: that catch doesn't work because of laziness
08:33:59 <quicksilver> (and because of typin :)
08:34:06 <byorgey> quicksilver: hmm... explain, please?
08:34:31 <oerjan> readIO s         = case [x | (x,t) <- reads s, ("","") <- lex t] of
08:34:31 <oerjan>                         [x] -> return x
08:34:31 <oerjan>                         []  -> ioError (userError "PreludeIO.readIO: no parse")
08:34:31 <oerjan>                         _   -> ioError (userError
08:34:31 <oerjan>                                        "PreludeIO.readIO: ambiguous parse")
08:34:45 <quicksilver> :t catch
08:34:50 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
08:35:01 <quicksilver> byorgey: catch only works in IO, that's what I meant by that
08:35:11 <quicksilver> byorgey: but, even if you were actually in IO after all
08:35:13 <byorgey> right, I see that now, but what did you mean about laziness?
08:35:20 <quicksilver> byorgey: your code still woudln't do what you want
08:35:22 <quicksilver> return $ read s
08:35:27 <quicksilver> doesn't force "read s"
08:35:32 <quicksilver> to be evaluated
08:35:36 <quicksilver> so the exception won't "happen"
08:35:52 <quicksilver> return $! read s might be enough, depending what the 'type' is.
08:35:58 <byorgey> ok, I see now.
08:36:41 <oerjan> byorgey: what i meant was replacing ioError (userError ...) by fail ... in the above
08:36:52 <byorgey> oerjan: right.
08:37:06 <oerjan> which is exactly the same in the IO monad
08:37:54 <oerjan> and would be very useful in Maybe and the like
08:38:00 <byorgey> oerjan: right, got it.  that looks like a useful generalization.
08:38:02 <byorgey> yup
08:38:43 <quicksilver> except that fail is a hideous abomination, of course
08:38:51 <quicksilver> other than that, the idea is sound :)
08:38:57 <oerjan> @slap quicksilver
08:38:58 * lambdabot karate-chops quicksilver into two equally sized halves
08:39:09 <oerjan> fail is just fine, it is just in the wrong class.
08:40:02 <mauke> I just had an :awesome: idea
08:40:27 <mauke> for symmetry with 'fail' we should rename 'return' to 'win'
08:41:01 <oerjan> the problem with that is it leads to 'tie'
08:41:03 <byorgey> nice!  or maybe even 'pwnz0r'
08:41:24 <mauke> oerjan: you mean 'meh'
08:43:11 <Nafai> byorgey: So have you worked on any fun programming projects lately?
08:43:45 <byorgey> Nafai: nope, grad school applications
08:43:52 <quicksilver> oerjan: well, the "String" argument is slihtly dubious too
08:43:59 <quicksilver> oerjan: although useful in practice, certainly
08:44:01 <byorgey> but I definitely plan to in a couple weeks!
08:44:48 <byorgey> quicksilver: what should it be instead?  (Show a) => a?  Or should fail not take an argument at all?
08:45:49 <shapr> mmm, code
08:46:48 <tetha> byorgey: I vote for (Show a) => a, because you can emulate no argument using a type, but you cant do that the other way that easy
08:47:46 <Saizan> ideally the monad should be able to choose it.
08:48:19 <oerjan> and this allows polymorphic code how?
08:48:24 <quicksilver> byorgey: I'm not really sure...
08:48:41 <quicksilver> byorgey: one of the reasons why I feel this problem doesn't have an easy solution :)
08:49:14 <oerjan> oh btw Show a => a would mean that if you passed an _actual_ string, it would be quoted
08:49:50 <byorgey> oerjan: you're right, that's yucky.
08:51:27 <oerjan> but you can have both with the strMsg method MonadError uses
08:51:35 <oerjan> @src MonadError
08:51:35 <lambdabot> class (Monad m) => MonadError e m | m -> e where
08:51:35 <lambdabot>     throwError :: e -> m a
08:51:35 <lambdabot>     catchError :: m a -> (e -> m a) -> m a
08:51:40 <oerjan> @src Error
08:51:40 <lambdabot> class Error a where
08:51:40 <lambdabot>     noMsg  :: a
08:51:40 <lambdabot>     strMsg :: String -> a
08:54:18 <Saizan> in fact the Either instance is kinda annoying because it accomodates fail using Error
08:54:47 <oerjan> yep, but that would not be a problem if fail was not in Monad
08:59:26 <oerjan> if MonadError => MonadCatch, with only throwError in the first, then fail = throwError . strMsg
09:01:31 <oerjan> oh, the bus
09:01:47 <roconnor> oerjan will never make it
09:02:23 <tetha> if thats true, then chatting is not pure
09:03:27 <mrd> @src iterate
09:03:28 <lambdabot> iterate f x =  x : iterate f (f x)
09:13:58 <[AE][HDF]sudd1> pls klick! ---> http://www.pennergame.de/ref.php?refid=8915041
09:13:59 <lambdabot> Title: Pennergame
09:14:09 --- mode: ChanServ set +o shapr
09:14:23 --- kick: [AE][HDF]sudd1 was kicked by shapr (Kicked by shapr)
09:14:30 <shapr> Oh, I thought he said please kick.
09:14:42 <conal> me too
09:14:44 <Nafai> shapr: Haha
09:15:13 <dylan> the sad thing is, lambdabot clicked.
09:15:22 <shapr> suck
09:15:35 <shapr> I wonder if lambdabot should skip everything after ? ?
09:16:04 <dylan> or not follow links from people that just joined?
09:16:30 <conal> dylan: i like that idea
09:16:49 <quicksilver> I don't think it matters, does it?
09:16:51 <dylan> not that I'm offering to implement it.
09:16:51 <Toxaris> dylan *should* follow such links, and automatically sends an email to the game's administrator that the guy uses bots to get better score
09:16:56 <quicksilver> LB won't have clicked the adverts
09:16:59 <Igloo> With those sorts of things you don't get money unless people actually buy something, do you?
09:17:05 <quicksilver> or wahetver else it is you have to click
09:21:44 <quicksilver> in fact, I don't know what pennergame is and surprisingly google doesn't seem to know either
09:21:48 <quicksilver> don't suppose I care that much
09:25:03 <Toxaris> quicksilver: "penner" is german for beggar. I therefore assume that this "pennergame" is a website where you register a player's account and then get points when you lure people to "your" page. there are similar games with other themes (one of the first was something with vampires vs. werewolves).
09:26:26 <Toxaris> quicksilver: It's interesting from a game design perspective, since there is nothing the player can do, all "moves" are performed by non-players, but scored for the players.
09:29:35 <mrd> curious situation.  if i use more parallel combinators, i get less parallelism, but also much less overhead.  if i use less parallel combinators, i get more parallelism, but much more overhead.   i suspect the "more parallelism" is due to some computation being repeated (not shared) between threads.
09:31:19 <quicksilver> Toxaris: yeah, that is quite interesting technically
09:31:24 <quicksilver> Toxaris: quite annoying socially though :)
09:32:37 <dcoutts> I love it when really practical stuff can be expressed in a neat functional way:
09:32:38 <dcoutts> accumFlags flags = foldr (flip (.)) id [ f | Right f <- flags ]
09:33:04 <dcoutts> this is for processing command line flags ^^
09:33:20 <quicksilver> dcoutts: flip (.) is (<<<) if you're so inclined :)
09:33:30 <quicksilver> :t (<<<)
09:33:31 <dcoutts> quicksilver: I need to stick to core libs
09:33:32 <lambdabot> forall (a :: * -> * -> *) c d b. (Arrow a) => a c d -> a b c -> a b d
09:33:34 <quicksilver> ah
09:33:44 <quicksilver> define it yourself then :P
09:34:10 <thetallguy> dcoutts: nice work on the options as monoid
09:34:15 <quicksilver> dcoutts: you could also write that as
09:34:23 <dcoutts> thetallguy: ta :-)
09:34:25 <quicksilver> dcoutts: mconcat [ Endo f | Right f <- flags ]
09:34:32 <quicksilver> dcoutts: or something like that :)
09:34:54 <dcoutts> quicksilver: yep, if I could use those Monoid data types, which I cannot as they're not present in ghc-6.2 :-)
09:35:00 * quicksilver nods
09:35:07 <ddarius> The problem is that composes them the other way.
09:36:33 <dcoutts> ddarius: that's what the Dual monoid is for I think
09:36:40 <ddarius> :t Dual
09:36:42 <lambdabot> forall a. a -> Dual a
09:36:59 <ddarius> @src Dual Monoid
09:37:00 <dcoutts> that doesn't help, you need to see the src of it's Monoid instance
09:37:03 <lambdabot> Source not found. :(
09:37:08 <ddarius> @src Monoid Dual
09:37:08 <lambdabot> Source not found. I feel much better now.
09:37:28 <dcoutts> instance Monoid a => Monoid (Dual a) where
09:37:28 <dcoutts>         mempty = Dual mempty
09:37:28 <dcoutts>         Dual x `mappend` Dual y = Dual (y `mappend` x)
09:37:34 <quicksilver> presumably (Dual a) `mappend` (Dual b) = Dual (b `mappend` a)
09:37:36 <quicksilver> doh
09:37:37 <quicksilver> dcoutts: wins
09:37:41 <dcoutts> :-)
09:37:45 * ddarius presumed that anyway.
09:38:10 <sjanssen> hmm, does Either have a Monoid instance?
09:38:31 <quicksilver> I don't think so?
09:38:37 <quicksilver> it has a MonadPlus instance
09:38:40 <ddarius> What would mempty be?
09:38:48 <sjanssen> foldMap (either (const mempty) (Dual . Endo)) -- :)
09:38:52 <sjanssen> ddarius: good point
09:39:03 <quicksilver> Left "nothing to see here"
09:39:05 <quicksilver> ;)
09:39:34 <sjanssen> you gotta use Data.Foldable.foldMap here for maximum win
09:39:52 <sjanssen> and the catamorphism on Either if no Monoid will do
09:44:14 <dcoutts> quicksilver: there should be a Monoid instance I think
09:44:20 <dcoutts> just as there is for (,)
09:44:25 <dcoutts> quicksilver: for Either I mean
09:44:57 <dcoutts> quicksilver: hmm though it does require an arbitrary preference of Left over Right
09:45:12 <dcoutts> perhaps best to leave it out then
09:46:43 <glguy> speaking of std libs, forever has the wrong type :(
09:47:30 <sjanssen> glguy: you do know that the responsible guy is just a few desks away, right?
09:49:46 <shapr> Who's the responsible guy?
09:49:50 <sjanssen> dons
09:50:33 <opqdonut> :t forever
09:50:38 <lambdabot> Not in scope: `forever'
09:50:51 <opqdonut> wasn't there a discussion on this a few days ago?
09:51:05 <sjanssen> forever :: (Monad m) => m a -> m ()
09:51:08 <opqdonut> m a -> m b vs. m a -> m ()
09:51:10 <opqdonut> iirc
09:51:28 <ddarius> Jerzy saved me some time.
09:53:43 <bos> does anyone use tex4ht to mangle latex papers, perchance?
09:53:58 <bos> #latex is a graveyard
10:02:37 <dylan> @hoogle TVar a -> (a -> a) -> STM ()
10:02:37 <lambdabot> No matches, try a more general search
10:02:48 <dylan> @hoogle (a -> a) -> TVar -> STM ()
10:02:49 <lambdabot> No matches, try a more general search
10:07:03 <roconnor> @hoogle STM
10:07:04 <lambdabot> Control.Monad.STM :: module
10:07:04 <lambdabot> Control.Concurrent.STM :: module
10:07:04 <lambdabot> GHC.Conc.STM :: data STM a
10:07:12 <roconnor> @hoogle STM ()
10:07:12 <lambdabot> GHC.Conc.alwaysSucceeds :: STM a -> STM ()
10:07:12 <lambdabot> GHC.Conc.always :: STM Bool -> STM ()
10:07:12 <lambdabot> GHC.Conc.writeTVar :: TVar a -> a -> STM ()
10:07:30 <roconnor> @hoogle modifyTVar
10:07:30 <lambdabot> No matches found
10:07:32 <roconnor> :(
10:07:52 <roconnor> @hoogle readTVar
10:07:52 <lambdabot> GHC.Conc.readTVar :: TVar a -> STM a
10:08:02 <conal> dylan: how about modifyRef in http://darcs.haskell.org/packages/TypeCompose/doc/html/Data-RefMonad.html
10:08:03 <lambdabot> http://tinyurl.com/28qme5
10:08:19 <mauke> modifyTVar v f = readTVar v >>= writeTVar v . f
10:09:41 <conal> hm.  formatting bug in the paper reference on that Data.RefMonad page.
10:10:21 <dylan> conal: IORefs arn't STM actions.
10:10:36 <conal> dylan: right
10:10:46 <conal> dylan: and?
10:10:48 <dylan> anyway, it's trivial to define that function given the type
10:10:56 <dylan> just wanted to make sure it didn't already exist.
10:11:08 <conal> dylan: it does exist.  modifyRef
10:11:31 <conal> just needs a RefMonad instance for STM
10:11:48 <dylan> which is more typing than the function itself.
10:17:06 <conal> and more reusable.  np, though.
10:18:04 <conal> would be nice to have RefMonad in a standard library and put an STM instance in STM
10:18:14 <conal> for another day
10:21:14 <dylan> well, this code is rather STM-specific.
10:21:24 <dylan> I'm trying to write a quick hack anyway. :P
10:24:56 <conal> sure.  btw, what are you up to?  i'm working with STM also.
10:25:30 <dylan> making a service to find what my computer's IP address is, instantly.
10:25:53 <conal> neat!  and why STM?
10:25:55 <dylan> with no central point of failure.
10:26:10 <dylan> because I have multiple threads representing connections by other daemons.
10:26:24 <conal> sounds cool.
10:26:59 <conal> STM is so lovely.  yay composability.
10:29:58 <dylan> I wish I could automatically liftIO stuff into this ReaderT-based monad.
10:47:09 <ricky_clarkson> Damn it, there I was writing an article about OOP, and it's turning into a monad tutorial.
10:47:13 <joelr1> evening
10:47:21 <joelr1> @seen bringert
10:47:21 <lambdabot> I saw bringert leaving #haskell 6h 41m 34s ago, and .
10:47:44 <lament> ricky_clarkson: ouch... You Know You're a Haskell Programmer when...
10:48:04 <dmwit> gt $ fstr -- Get's the first element of your state.
10:49:19 <ydo> why can't I use = interactively?
10:49:34 <ydo> or can I? how?
10:49:41 <dmwit> Use "let" in front.
10:49:45 <desegnis> ydo: Because, in an interactive context, the order of your definition matters.
10:50:02 <dmwit> ydo: In ghci, you're in the IO monad, so only monadic actions are allowed.
10:50:24 <desegnis> ydo: That's why you use  let,  which belongs to do-notation.
10:50:25 <ydo> I don't know about monads just yet..
10:50:45 <desegnis> ydo, no need to know anything about monads here.
10:50:59 <mauke> you're not in the IO monad, you're in a do block :-)
10:51:06 <dmwit> Don't worry about it; just use "let" for now and you'll be fine. =)
10:52:32 <ricky_clarkson> dff
10:53:10 <ricky_clarkson> sorry, dodgy connection confused me.
11:01:22 <dmwit> I know KLOC, what's KSLOC?  Just a typo?
11:02:10 <gbacon> thousands of source lines of code
11:03:08 <ydo> I intend to study a masters programme in bioinformatics, are there any companies that use functional programming in that area? hopefully in sweden..
11:03:26 <dmwit> gbacon: ah, thanks
11:04:36 <filcab42> Hi
11:04:47 <filcab42> is there any way to shadow the Prelude's imports?
11:05:00 <dmwit> import Prelude ()
11:05:03 <filcab42> I wanted to define a "Just" datatype (I'm doing a presentation)
11:05:05 <filcab42> hmm
11:05:09 <dmwit> or, better:
11:05:14 <filcab42> but I just wanted to shadow Just and Nothing
11:05:16 <dmwit> import Prelude hiding (Maybe(..)) -- or so
11:05:20 <filcab42> (and maybe some others)
11:05:22 <filcab42> hmmm
11:05:24 <filcab42> nice
11:05:27 <filcab42> I'll try that
11:05:28 <filcab42> thanks ;)
11:05:47 <Zao> filcab42: Define the type "Mayhaps" instead :)
11:05:56 <filcab42> lol
11:06:03 <gbacon> @src Maybe
11:06:03 <lambdabot> data Maybe a = Nothing | Just a
11:10:45 <mauke> data Option a = None | Some a
11:10:52 <mauke> ocaml'd
11:11:36 <andy_> Can someone recommend a finite automata lib? Im up to writing a simple presburger arithmetic solver to boost my abstract interpretation toolset. :>
11:17:20 <filcab42> where can I find a good tutorial about Control.Parallel.Strategies?
11:17:26 <filcab42> I can't seem to use parMap :s
11:18:19 <ydo> I want to do something like: data Expression a = Nothing | Just a | Foo (Expression a)   can I somehow use the Maybe type inside Expression?
11:19:19 <wbeene> .w 2
11:19:40 <filcab42> I don't think so
11:19:51 <filcab42> maybe if you hide the ones from the Prelude
11:20:15 <Saizan> data Expression a = Bar (Maybe a) | Foo (Expression a) ..
11:21:01 <andy_> ydo: why not use   data Expression a = Maybe (Either a (Expression a))  or the like?
11:21:44 <Saizan> actually, why use it?
11:22:30 <andy_> well, you could reuse standard combinators for maybe and either. ^^
11:23:33 <ydo> Either? :)
11:23:34 <byorgey> filcab42: the original paper about it is a good tutorial.
11:23:41 <mauke> @src Either
11:23:42 <lambdabot> Source not found. Sorry.
11:23:54 <andy_> data Either a b = Left a | Right b
11:24:08 <filcab42> hmm
11:24:10 <byorgey> @go Algorithm Strategy Parallelism
11:24:12 <lambdabot> http://www.macs.hw.ac.uk/~dsg/gph/papers/abstracts/strategies.html
11:24:12 <lambdabot> Title: Algorithm + Strategy = Parallelism
11:24:16 <byorgey> filcab42: ^^^
11:24:18 <filcab42> thanks
11:33:34 <_ry> i want to define a new monad on [] (just for shits and giggles)... but when i try to i get  Duplicate instance declarations warnings
11:33:40 <_ry> s/warning/error/
11:33:47 <mauke> yes, you need a new type
11:34:00 <_ry> type List = []  ?
11:34:08 <mauke> newtype List a = List [a]
11:45:13 <hpaste>  _ry pasted "list monad" at http://hpaste.org/4384
11:45:23 <_ry> what am i doing wrong?
11:45:47 <mauke> you need to unwrap your Lists
11:45:48 <_ry> oh, do i need a new concat and map?
11:46:04 <mauke> newtype List a = List { unList :: [a] }
11:46:22 <mauke> xs >>= f = List (concatMap f (unList xs))
11:50:02 <_ry> i think that doesn't work cause f :: a -> List a
11:50:21 <mauke> oh
11:50:27 <mauke> right
11:50:40 <_ry> unList . f ?
11:50:47 <mauke> yeah
11:51:29 <_ry> is there a way to just remove the monad structure from [] and add it again?
11:51:35 <gwern> I have a question: I need to find the directory of the GHC installation compiling a gien haskell program, and then substitute it in as a String constant; is the sort of thing Template Haskell is meant for?
11:51:46 <mauke> _ry: no
11:51:51 <_ry> things look so unclear with all this wrapping and unwrapping
11:52:04 <mauke> you could define a completely different type
11:52:15 <hpaste>  _ry annotated "list monad" with "this works" at http://hpaste.org/4384#a1
11:52:29 <mauke> wait, all you have to do is define your own map and concat
11:57:27 <andy_> Hmm, if you define the new monad via join and fmap, you could possible give a more concise definition reusing join and fmap of the [a] monad.
11:59:48 <Taejo> where can I find a reference on GHC's RTS options?
12:00:40 <oerjan> @users
12:00:40 <lambdabot> Maximum users seen in #haskell: 420, currently: 418 (99.5%), active: 18 (4.3%)
12:03:01 <Taejo> is it possible to limit (stack+heap) in the RTS rather than each individually?
12:10:02 <_ry> how could i make this List type an instance of Show ?
12:10:30 <mauke> ... deriving (Show)
12:11:23 <fasta> What does this mean "copied during GC (not scavenged)"?
12:14:03 <Heffalump> fasta: I'd guess that it was live at the point of the GC
12:14:09 <Heffalump> do you know about how copying collectors work?
12:14:33 <fasta> Heffalump: not exactly.
12:14:56 <Heffalump> fasta: basically the idea is that they copy all the live stuff to a new area of heap, then throw away the entire old area
12:15:09 <Heffalump> and live stuff is identified by tracing from a set of roots, typically the stack or similar
12:15:24 <fasta> Heffalump: right, I know that, I just never implemented it.
12:15:59 <Heffalump> well, copied presumably refers to the copying bit, and scavenged refers to the chucking away of the old area, at a guess
12:17:17 <fasta> "chucking away"?
12:17:41 <fasta> Meaning that it is reused in the new graph?
12:17:45 <Heffalump> as in the deletion
12:18:01 <Heffalump> but yes, in the case of the text you quoted, I assume it means that it kept the thing in question
12:18:55 <fasta> It also depends on how it "kept it".
12:19:15 <fasta> It could copy everything always, or it could do it in some other way.
12:21:27 <Igloo> Taejo: myProg +RTS -?    (you might need to say -\?)
12:21:47 <Igloo> Taejo: And no, you can't set stack+heap TTBOMK
12:22:19 <Taejo> Igloo: thanks. TTBOMK?
12:22:26 <pitecus_> Any idea what this could runtime error mean: Main: Prelude.chr: bad argument
12:22:28 <Igloo> To The Best Of My Knowledge
12:22:52 <smack_> @src chr
12:22:52 <lambdabot> Source not found. Where did you learn to type?
12:22:53 <Igloo> pitecus_: The Int is too big
12:22:58 <Lemmih> > chr maxBound
12:22:59 <lambdabot>  Exception: Prelude.chr: bad argument
12:23:38 <pitecus_> I dont think I'm using chr anywhere though
12:23:45 <pitecus_> how could that happen?
12:24:47 <jedbrown> sjanssen: What do you think about a lazy storablevector?  Is there a Right Thing with regard to chunk size?
12:24:55 <byorgey> pitecus_: are you using any String-related things?
12:25:17 <pitecus_> byorgey, toLower
12:25:29 <byorgey> hm, interesting
12:25:41 <byorgey> @src toLower
12:25:41 <lambdabot> Source not found. It can only be attributed to human error.
12:25:52 <Taejo> Igloo: will the RTS kill the program if the limits are exceeded, or does it just endeavour not to reach the limits?
12:25:59 <pitecus_> is there some way to get a stack trace or something??
12:26:36 <Igloo> Taejo: With the heap it'll GC, but with the stack there's nothing it can do
12:28:21 <Taejo> Igloo: so it doesn't kill?
12:28:31 <oerjan> > read "\xffffffff" :: String
12:28:31 <lambdabot>  Character constant out of range at ""\xff..." (column 6)
12:28:54 <oerjan> that didn't do it
12:29:51 <Igloo> Taejo: It does if it can't free enough by GCing
12:29:54 <oerjan> > last.show.toLower$['\NUL'..]
12:29:55 <lambdabot>  Couldn't match expected type `Char' against inferred type `[a]'
12:30:04 <oerjan> > last.show.map toLower$['\NUL'..]
12:30:05 <Taejo> Igloo: great!
12:30:06 <lambdabot>  '"'
12:30:29 <oerjan> no surprises there
12:30:47 <oerjan> > sum.map(ord.toLower)$['\NUL'..]
12:30:48 <lambdabot>  2146914569
12:31:02 <oerjan> ok they are all well-defined
12:31:04 <Saizan> pitecus_: compiling with -auto-all -prof and running with +RTS -xc you should get one
12:31:16 <pitecus_> Saizan, thanks
12:31:46 <dylan> okay
12:32:03 <dylan> I read sum.map(ord... as "map slumlord...."
12:32:28 <mauke> go back to bed, garfield
12:33:16 <dylan> garfield?
12:33:36 <pitecus_> Saizan, I get smth like: <System.Directory.CAF><GramLab.Maxent.TempDir.withTempFilePath,GramLab.Maxent.ZhangLe.IntModel.fromByteString,GramLab.Maxent.ZhangLe.Model.fromByteString,GramLab.Maxent.ZhangLe.Model.load,GramLab.Morfette.Utils.predict,GramLab.Morfette.Utils.commands,GramLab.Morfette.Utils.morfette,Main.CAF><GHC.Base.CAF>Main: Prelude.chr: bad argument
12:33:48 <pitecus_> So thats not very informative...
12:33:55 <QuietPurple> hello, can i ask a question---how are vector calculations done in haskell?
12:34:02 <_ry> anyway i can use list comprehensions with my new List type?
12:34:32 <_ry> e.g. can i do something like this [x | x <- List [1,2,3,4], even x]
12:34:51 <oerjan> QuietPurple: for simple things you can just use lists
12:35:01 <fasta> _ry: no, that would require monad comprehensions.
12:35:16 <_ry> i have "instance Monad List"
12:35:17 <QuietPurple> so [Double] -> [Double]?
12:35:22 <oerjan> there are some vector packages on hackage, probably
12:35:38 <QuietPurple> i suppose
12:35:45 <_ry> http://hpaste.org/4384 <--- my list monad
12:36:06 <oerjan> zipWith gives you sum, scalar product and dot product easily
12:36:10 <hpaste>  _ry pasted "weird list monad" at http://hpaste.org/4385
12:36:14 <gbacon> @src zipWith
12:36:14 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
12:36:14 <lambdabot> zipWith _ _      _      = []
12:36:59 <_ry> QuietPurple: if you're working in a fixed dimension use the tuples
12:37:00 <QuietPurple> ok so zipWith (+) a b adds a and b?
12:37:07 <oerjan> yep
12:37:08 <QuietPurple> tuples?
12:37:23 <QuietPurple> (Double, Double)?
12:37:24 <gbacon> > zipWith (+) [1..3] [10..13]
12:37:24 <lambdabot>  [11,13,15]
12:37:29 <_ry> eg (a,b,c) + (d,e,f) = (a+d, b+e, c+f)
12:37:34 <QuietPurple> cool
12:37:35 <vininim> QuietPurple: you might want to try http://dis.um.es/~alberto/GSLHaskell/
12:37:38 <lambdabot> Title: GSLHaskell
12:37:39 <oerjan> tuples are nice for type safety but you cannot use the builtin functions...
12:37:47 <oerjan> for lists
12:37:54 <gbacon> > zipWith (+) [1..3] [4..6]
12:37:55 <lambdabot>  [5,7,9]
12:38:01 <QuietPurple> so i can't say (1,2) + (2,3)?
12:38:11 <jedbrown> vininim, QuietPurple: That's on hackage now.  It's called hmatrix.
12:38:14 * gbacon tosses lambdabot a Scooby Snack
12:38:50 <oerjan> QuietPurple: not as such.
12:38:51 <gbacon> > zipWith (
12:38:51 <lambdabot> Unbalanced parentheses
12:39:06 <vininim> > balance (
12:39:06 <lambdabot> Unbalanced parentheses
12:39:18 <gbacon> > zipWith (\(a,b) (c,d) -> (a+c, d+b)) [(1,2), (2,3)]
12:39:19 <lambdabot>  <[(Integer,Integer)] -> [(Integer,Integer)]>
12:39:49 <QuietPurple> ok, i think lists is the best way to do what i want
12:40:05 <pitecus_> So is there no way to locate where this bad argument junk comes from??
12:40:11 <vininim> > map (\(a,b) (c,d) -> (a+c,d+b)) [(1,3),(2,3)]
12:40:14 <lambdabot>  [<(Integer,Integer) -> (Integer,Integer)>,<(Integer,Integer) -> (Integer,Int...
12:40:31 <gbacon> :t zipWith
12:40:32 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
12:40:38 <QuietPurple> how do i return the first or last member of a list?
12:40:48 <QuietPurple> sorry, my haskell is really rusty :-)
12:40:50 <mauke> head, last
12:40:56 <byorgey> pitecus_: what's all that GramLab.Maxent stuff?
12:41:11 <QuietPurple> > head [0,0,2,3,4]
12:41:11 <lambdabot>  0
12:41:26 <QuietPurple> > last [9,8,7,6]
12:41:26 <lambdabot>  6
12:41:27 <byorgey> > ((+) *** (+)) (1,2) (3,4)
12:41:28 <lambdabot>  Couldn't match expected type `t1 -> t'
12:41:39 <pitecus_> byorgey, thats the program loading some data into memory from disk
12:41:41 <augustss> @seen dons
12:41:41 <lambdabot> dons is in #darcs, #xmonad and #haskell. I last heard dons speak 45m 32s ago.
12:41:43 <roconnor> @check \x y -> fromIntegral (x + y::Int)::Double == (fromIntegral x + fromIntegral y)
12:41:43 <lambdabot>  Parse error at "==" (column 43)
12:41:45 <QuietPurple> ok, thnks for your help
12:41:51 <roconnor> @check \x y -> (fromIntegral (x + y::Int)::Double) == (fromIntegral x + fromIntegral y)
12:41:53 <lambdabot>  OK, passed 500 tests.
12:42:10 <roconnor> !
12:42:12 <roconnor> @check \x y -> (fromIntegral (x + y::Int)::Double) == (fromIntegral x + fromIntegral y)
12:42:12 <lambdabot>  OK, passed 500 tests.
12:42:38 <roconnor> @check \x y -> ((fromIntegral (x + y::Int))::Double) == (fromIntegral x + fromIntegral y)
12:42:39 <lambdabot>  OK, passed 500 tests.
12:43:04 <roconnor> > maxBound + maxBound
12:43:04 <lambdabot>  Add a type signature
12:43:05 <augustss> that's true for the tiny Ints quickcheck uses
12:43:17 <roconnor> oh
12:43:28 <conal> roconnor: i wonder how big the test ints are
12:43:44 <QuietPurple> oooh, if i want a list of vectors can i say [[Double]]?
12:43:47 <augustss> they start out ver ysmall
12:43:54 <byorgey> > (uncurry (***) . (+) *** (+)) (1,2) (3,4)
12:43:55 <lambdabot>  Couldn't match expected type `(a b c, a b' c')'
12:44:04 <mauke> @scheck \x y -> (fromIntegral (x + y::Int)::Double) == (fromIntegral x + fromIntegral y)
12:44:05 <lambdabot>   Completed 169 test(s) without failure.
12:46:54 <roconnor> @check \x -> x < 10000
12:46:55 <lambdabot>  Add a type signature
12:46:55 <QuietPurple> > zipWith (zipWith (+)) [[0,1],[2,3],[3,4]] [[0,0],[3,4],[4,5]]
12:46:56 <lambdabot>  [[0,1],[5,7],[7,9]]
12:47:01 <roconnor> @check \x -> x < (10000::Int)
12:47:01 <lambdabot>  OK, passed 500 tests.
12:47:02 <QuietPurple> woooo!
12:47:32 <pitecus_> it must be some bug in utf8-string, i can't think of anything else that could be happening...
12:47:33 <conal> maybe Int needs a new generator.
12:48:36 <mauke> @scheck \x -> x < (10000::Int)
12:48:37 <lambdabot>   Completed 13 test(s) without failure.
12:49:04 <oerjan> > let pap p = uncurry (***) p; ppure f = join (***) f in ppure (+) `pap` (1,2) `pap` (3,4)
12:49:05 <lambdabot>  Couldn't match expected type `(b, c)'
12:49:11 <byorgey> QuietPurple: =)
12:49:37 <oerjan> > let pap p = uncurry (***) p; ppure f = join (,) f in ppure (+) `pap` (1,2) `pap` (3,4)
12:49:38 <lambdabot>  (4,6)
12:49:41 <gwern> I have a question: I need to find the directory of the GHC installation compiling a gien haskell program, and then substitute it in as a String constant; is the sort of thing Template Haskell is meant for?
12:50:04 <byorgey> oerjan: nice =)
12:50:17 <ikegami--> > check (Config {configSize x = x ** 10}) (\x -> x < (10000::Int))
12:50:18 <lambdabot>  Parse error at "x" (column 27)
12:50:19 <Heffalump> gwern: did you check if there's a CPP macro for it?
12:50:29 <Heffalump> TH seems a bit heavyweight, but you could use it for that.
12:50:47 <gwern> I'm not a fan of CPP. seems to mess with ghci and stuff
12:51:00 <vininim> > check True::Boolean
12:51:00 <lambdabot>   Not in scope: type constructor or class `Boolean'
12:51:06 <ikegami--> > check (Config {configSize y = y ** 10}) (\x -> x < (10000::Int))
12:51:06 <lambdabot>  Parse error at "y" (column 27)
12:51:10 <ikegami--> hm
12:51:14 <roconnor> > check True::Bool
12:51:14 <lambdabot>   Not in scope: `check'
12:51:18 <roconnor> @check True::Bool
12:51:18 <QuietPurple> > zipWith (zipWith (zipWith (+))) [[[0,1],[0,0]],[[1,0],[0,0]]] [[[1,1],[0,0]],[[1,0],[0,1]]]
12:51:19 <lambdabot>  OK, passed 500 tests.
12:51:19 <lambdabot>  [[[1,2],[0,0]],[[2,0],[0,1]]]
12:51:24 <roconnor> @scheck True::Bool
12:51:24 <lambdabot>   Completed 1 test(s) without failure.
12:51:41 <mauke> why the type annotation?
12:51:45 <roconnor> @scheck True
12:51:46 <lambdabot>   Completed 1 test(s) without failure.
12:52:12 <ikegami--> > Test.QuickCheck.check (Test.QuickCheck.Config {configSize y = y ** 10}) (\x -> x < (10000::Int))
12:52:12 <lambdabot>  Parse error at "y" (column 59)
12:52:25 <vininim> mauke: you might as well ask why testing True :)
12:52:38 <mauke> no, that's perfectly sensible
12:53:01 <ikegami--> aha
12:54:12 <mauke> now if you'd be testing False ...
12:54:31 <oerjan> @check False
12:54:31 <lambdabot>  Falsifiable, after 0 tests:
12:54:43 <ikegami--> > Test.QuickCheck.check (Test.QuickCheck.Config {Test.QuickCheck.configSize = \y -> y ** 10}) (\x -> x < (10000::Int))
12:54:44 <lambdabot>   Not in scope: `Test.QuickCheck.configSize'
12:54:58 <oerjan> 0 tests?
12:55:08 <oerjan> @check \_ -> False
12:55:08 <lambdabot>  Add a type signature
12:55:24 <oerjan> @check \_ -> False :: (Int -> Bool)
12:55:25 <lambdabot>  Couldn't match expected type `Int -> Bool'
12:55:31 <roconnor> @scheck False
12:55:31 <lambdabot>   Failed test no. 1. Test values follow.:
12:55:33 <ikegami--> > Test.QuickCheck.check (Test.QuickCheck.Config {configSize = \y -> y ** 10}) (\x -> x < (10000::Int))
12:55:34 <lambdabot>   Not in scope: `configSize'
12:55:39 <oerjan> @check (\_ -> False) :: (Int -> Bool)
12:55:40 <dmhouse> @check (\_ -> False) :: (Int -> Bool)
12:55:41 <lambdabot>  Falsifiable, after 0 tests: 1
12:55:41 <lambdabot>  Falsifiable, after 0 tests: 0
12:55:55 * dmhouse doens't think it means 0 tests there.
12:56:02 <dmhouse> ?check \x -> x > 1
12:56:02 <roconnor> BUUUUUUUUUUUUUUUG!
12:56:03 <lambdabot>  Add a type signature
12:56:06 <dmhouse> ?check \x -> x > 1::Int
12:56:06 <lambdabot>  Couldn't match expected type `Int' against inferred type `Bool'
12:56:15 <dmhouse> ?check \x -> x > (1::Int)
12:56:16 <lambdabot>  Falsifiable, after 2 tests: 0
12:57:16 <oerjan> conclusion: checking False was completely sensible, as it found a bug
12:57:31 <Heffalump> yay, 6.9 linux bindists of GHC working again
13:02:25 <augustss> @check \ x -> x < (1000::Int)
13:02:26 <lambdabot>  OK, passed 500 tests.
13:02:45 <augustss> @check \ x -> x < (100::Int)
13:02:46 <lambdabot>  Falsifiable, after 219 tests: 109
13:02:55 <augustss> @check \ x -> x < (200::Int)
13:02:55 <lambdabot>  OK, passed 500 tests.
13:02:57 <mauke> @check \x -> x > (-10 :: Int)
13:02:58 <lambdabot>  Falsifiable, after 17 tests: -11
13:03:04 <mauke> @check \x -> x > (-200 :: Int)
13:03:04 <lambdabot>  OK, passed 500 tests.
13:03:42 <augustss> Not very confidence inspiring
13:04:48 <roconnor> @check \x -> x > (-200 :: Integer)
13:04:49 <lambdabot>  Falsifiable, after 491 tests: -216
13:04:54 <Igloo> I don't know, "Finds 50% of bugs" isn't a bad tagline  :-)
13:05:26 <mauke> just run it twice!!
13:06:34 <QuietPurple> sorry another question---how do i devide each value in a list by 2, say?
13:06:48 <oerjan> map (/2)
13:06:51 <vininim> > map (/2) [1..10]
13:06:52 <lambdabot>  [0.5,1.0,1.5,2.0,2.5,3.0,3.5,4.0,4.5,5.0]
13:07:01 <QuietPurple> ah, i see
13:07:26 <QuietPurple> > map (^4) [1..10]
13:07:27 <lambdabot>  [1,16,81,256,625,1296,2401,4096,6561,10000]
13:07:33 <vininim> list operations are exhausted in most haskell book/guide/tutorials
13:08:30 <oerjan> QuietPurple: http://www.haskell.org/ghc/docs/latest/html/libraries/base-3.0.0.0/Data-List.html
13:08:37 <lambdabot> http://tinyurl.com/22sg7z
13:08:38 <mauke> > (^4) <$> [1..10]
13:08:39 <dmhouse> QuietPurple: http://en.wikibooks.org/wiki/Haskell/List_processing might be useful, too.
13:08:39 <lambdabot>  [1,16,81,256,625,1296,2401,4096,6561,10000]
13:09:01 <mauke> > (^2) <$> sqrt $ 2
13:09:03 <lambdabot>  2.0000000000000004
13:10:24 <vininim> @t <$>
13:10:25 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
13:10:36 <vininim> @type <$>
13:10:37 <lambdabot> parse error on input `<$>'
13:11:15 <vininim> hmm.. what is that?
13:11:32 <jedbrown> @type (<$>)
13:11:32 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:11:59 <oerjan> an operator is not an expression without parentheses
13:13:57 <dmhouse> It's to do with applicative functors IIRC.
13:14:13 <dmhouse> It's basically fmap, which is just map for the list functor.
13:16:54 <QuietPurple> foldr (zipWith (+)) [[0,1],[1,2],[2,3],[3,4],[4,5]]
13:17:10 <mauke> no
13:17:16 <QuietPurple> foldr (zipWith (+)) [0,0] [[0,1],[1,2],[2,3],[3,4],[4,5]]
13:17:18 <dmhouse> You have to ask nicely.
13:17:23 <dmhouse> > foldr (zipWith (+)) [0,0] [[0,1],[1,2],[2,3],[3,4],[4,5]]
13:17:25 <lambdabot>  [10,15]
13:17:25 <QuietPurple> > foldr (zipWith (+)) [0,0] [[0,1],[1,2],[2,3],[3,4],[4,5]]
13:17:26 <lambdabot>  [10,15]
13:17:36 <idnar> sudo foldr zipWith
13:17:40 <dmhouse> ">" is like saying "please" to lambdabot. She won't stand for rudeness.
13:17:46 <QuietPurple> damn, you got there just in front of me! :-)
13:19:52 <oerjan> > map sum.transpose $  [[0,1],[1,2],[2,3],[3,4],[4,5]]
13:19:54 <lambdabot>  [10,15]
13:20:29 <dmhouse> oerjan: you should really get out of the habit of using '.' for composition without a space.
13:20:46 <dmhouse> oerjan: it'll screw you over when you try things like "Just.not"
13:20:51 <dmhouse> > Just.not $ false
13:20:52 <oerjan> dmhouse: i know that
13:20:56 <dmhouse> > Just.not $ False
13:20:59 <lambdabot>   Not in scope: `Just.not'
13:20:59 <lambdabot>   Not in scope: `false'
13:21:19 <oerjan> i have been known to do Just .something.somethingelse
13:21:27 <mauke> argh
13:21:55 <mauke> ATTENTION PEOPLE: PUT SPACES AROUND YOUR OPERATORS. thank you.
13:22:00 * dmhouse would be happy if we enforced spaces around all operators
13:22:12 <dmhouse> Then we could get sexy record access too.
13:22:39 <dmhouse> E.g. f (length $ record.field) -- yum.
13:22:44 <mauke> (.) = flip id
13:25:16 <ibid> mauke: except that doesn't solve the namespace issue :)
13:25:54 <lament> enforced spaces around operators would probably lead to very angry programmers
13:29:10 <ibid> like enforced spaces around identifiers did (among the c64-indoctrinated crowd)? :)
13:31:03 <lament> forth has enforced spaces around everything, and look how that turned out ;)
13:31:35 <ibid> or postscript? :)
13:31:48 <ibid> ... sleep time, bbl :)
13:31:56 <ski> ibid : enforced spaces on c64 ??
13:32:26 <ibid> ski: just the oppoite
13:32:32 <ski> just so
13:32:35 <ibid> when they lesrned other stuff
13:32:38 <ibid> was my point
13:32:48 <ski> ok
13:32:57 <ibid> ... gone
13:53:39 <yrlnry> advice 11941
13:55:05 <shivernz> what would the type signature be for a function that takes three parameters and returns a list? i'm obviously fairly new to haskell and functional programming :)
13:55:14 <oerjan> yrlnry: always shake before use.
13:55:26 <Lemmih> shivernz: a -> b -> c -> [d]
13:55:30 * yrlnry shakes.
13:55:40 <yrlnry> Wow, this is strenuous.
13:55:45 <_ry> say i have a [Bool] and a [Int] of the same length.. how can i get a [Int] with only the elements which are True?
13:56:38 <oerjan> > map snd . filter fst $ zip [True,False,True,False] [1,2,3,4]
13:56:40 <lambdabot>  [1,3]
13:56:43 <Lemmih> _ry: [ x | (b,x) <- zip bools ints, b ]
13:57:28 <shivernz> Lemmih, thats what I have, but I think i'm doing something else wrong somewhere
13:57:37 <yrlnry> @src filter
13:57:37 <lambdabot> filter _ []     = []
13:57:37 <lambdabot> filter p (x:xs)
13:57:37 <lambdabot>     | p x       = x : filter p xs
13:57:37 <lambdabot>     | otherwise = filter p xs
13:58:05 <oerjan> shivernz: a,b,c and d need to be properly filled in, too
13:58:13 <yrlnry> Lemmih: tricky.
13:58:20 <shivernz> i assume its in the actual function itself
13:58:32 <shivernz> i'm actually getting a compile error
13:58:47 <oerjan> !paste
13:58:48 <hpaste> Haskell paste bin: http://hpaste.org/
13:59:02 <shivernz> oerjan, will do
13:59:12 <oerjan> and include the error :)
14:00:40 <hpaste>  shivernz pasted "basics" at http://hpaste.org/4387
14:01:06 <Lemmih> shivernz: tribleFstTwo only has one argument.
14:01:30 <Lemmih> shivernz: tripleFstTwo :: Triple a a b -> [a]
14:01:53 <Lemmih> shivernz: You might want: tripleFstTwo :: Triple a b c -> (a,b)
14:01:56 <oerjan> shivernz: one way to find the type is to leave off the annotation, and ask with the :t command
14:02:20 <oerjan> shivernz: also, a:b:[] = [a,b]
14:03:07 <yrlnry> shivernz: Do you realize that "Triple" is not actually useful there?
14:04:09 <gwern> @hoogle catch
14:04:09 <lambdabot> Prelude.catch :: IO a -> (IOError -> IO a) -> IO a
14:04:10 <lambdabot> Control.Exception.catch :: IO a -> (Exception -> IO a) -> IO a
14:04:10 <lambdabot> System.IO.Error.catch :: IO a -> (IOError -> IO a) -> IO a
14:05:54 <hashendgame> does anyone know of any MUD/MOO/... servers written in haskell? google's not being too helpful in turning up anything useful
14:07:15 <gbacon> @src cycle
14:07:16 <lambdabot> cycle [] = undefined
14:07:16 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
14:07:50 <gbacon> > take 5 $ cycle [1..3]
14:07:51 <lambdabot>  [1,2,3,1,2]
14:07:58 <yrlnry> why not just   cycle xs = xs ++ xs' ?
14:07:58 <mwc> hmm, why is cycle [] undefined
14:08:10 <oerjan> > cycle ""
14:08:10 <lambdabot>  Exception: Prelude.cycle: empty list
14:08:11 <mwc> seems like cycle [] = [] would be a better definiton
14:08:36 <yrlnry> Er, sorry, cycle xs = xs ++ cycle xs ?
14:08:47 <yrlnry> Some sort of internal knot-tying thing?
14:09:04 <gbacon> yrlnry: what's the correct URL for the clpmod charter?!
14:09:05 <mwc> yrlnry: exactly, more sharing th other way
14:09:06 <oerjan> yrlnry: yep, so it only allocates cycle xs once
14:09:07 <hashendgame> mwc: my guess is that if cycle [] = [] then you don't have "cycle xs defined => cycle xs infinite" which may or may not be a useful property
14:09:31 <mwc> hashendgame: I suppose so
14:09:41 <yrlnry> Oh, I see.  With cycle xs = xs' where xs' = xs ++ xs'   you only get one copy of xs.
14:09:49 <yrlnry> gbacon: sorry!
14:10:01 <lelf> Huh, <lambdabot> Plugin `quote' failed with: getRandItem: empty list  [02:08]
14:10:05 <yrlnry> gbacon: all www.plover.com/~mjd/X  urls are now at www.plover.com/X
14:10:53 <gbacon> I didn't think it was under ~mjd
14:11:21 <yrlnry> Oh, wait.
14:11:26 * gbacon waits
14:12:00 <shivernz> thanks guys... i was entirely confused there for a bit. looks like its working now
14:12:09 <kpreid> yrlnry: that is, it should be noted, a property of the implementation â€” a commone one, though.
14:12:19 <oerjan> lelf: it's a frequent lambdabot bug :(
14:12:24 <oerjan> @quote
14:12:24 <lambdabot> ghc says: No constructor has all these fields
14:12:41 <shivernz> yrlnry, i do realise that the function is not useful at all though. i was just trying to get my head around the concept :)
14:12:51 <hashendgame> @src mkWeakIORef
14:12:52 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
14:12:58 <hashendgame> @help
14:12:58 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:13:23 <oerjan> @index mkWeakIORef
14:13:24 <lambdabot> Data.IORef
14:13:29 <yrlnry> gbacon: http://perl.plover.com/clpm/charter
14:13:50 <yrlnry> shivernz: "Triple" takes items of type a, b, and c and returns *one* item of type Triple a b c.
14:13:55 <gbacon> yrlnry: thanks
14:14:06 <yrlnry> shivernz: then you give this *one* item to your function.
14:14:17 <yrlnry> gbacon: sorry for the delay!
14:14:29 <gbacon> yrlnry: no sweat
14:16:26 <vininim> :t let rep n f x = if n > 0 then (f x >>= (rep (n -1) f x)) else return () in rep
14:16:26 <lambdabot>     Occurs check: cannot construct the infinite type: b = a -> b
14:16:26 <lambdabot>     Probable cause: `>>=' is applied to too many arguments
14:16:26 <lambdabot>     In the expression:
14:17:46 <vininim> :t let rep n f x = if n > 0 then (f x >> (rep (n -1) f x)) else return () in rep
14:17:46 <lambdabot> forall a t (m :: * -> *) a1. (Ord a, Num a, Monad m) => a -> (t -> m a1) -> t -> m ()
14:19:53 <oerjan> :t let rep n f x = if n > 0 then (f x >>= (rep (n -1) f)) else return () in rep
14:19:53 <lambdabot> forall a a1 (m :: * -> *). (Ord a, Num a, Monad m) => a -> (a1 -> m a1) -> a1 -> m ()
14:20:03 <shivernz> is my assumption here correct? http://hpaste.org/4387#a1
14:21:10 <hashendgame> shivernz: yeah it looks right
14:21:29 <shivernz> hashendgame, thanks
14:21:31 <hashendgame> though I don't see why you use Triple a b c instead of (a, b, c)
14:21:58 <shivernz> hashendgame, the reason is probably my lack of understanding :)
14:22:22 <Saizan> shivernz: is this a yaht exercise?
14:22:31 <shivernz> Saizan, yeah
14:22:38 <shivernz> it doesn't actually serve a purpose
14:22:48 <hashendgame> shivernz: ok, well you could do away with the triple type and write something like tripleFst (a, b, c) = (a, b)
14:22:48 <shivernz> other than to confuse me
14:22:52 <BMeph> Lurk w/ y'all later - "work" (heh,heh) is done. ;)
14:23:51 <shivernz> hashendgame, ah. unfortunately though, the exericse is about type definitions and type signatures :)
14:24:06 <hashendgame> shivernz: fair enough then
14:25:58 <shivernz> thanks for the advice though
14:26:07 <Taejo> The South African Computer Olympiad is opening its training camps to the public. We now allow Haskell submissions. The first camp is on the 15th (this Saturday). Please join us: https://olympiad.cs.uct.ac.za:8082/contest.html
14:26:57 <shapr> Taejo: Cool!
14:28:30 <shivernz> nice
14:28:50 <sorear> shapr: <@shapr>
14:28:56 <shapr> ?
14:29:00 <shapr> oh
14:29:02 --- mode: shapr set -o shapr
14:29:56 <hashendgame> I'm thinking about putting together a mud server in haskell, but I don't really know where to start in terms of setting up the concurrency control. Anyone interested in discussing data structure design in PM? (don't want to flood)
14:30:19 <sorear> there's also #haskell-overflow
14:30:36 <mrd> @go simple tcp server haskell
14:30:38 <lambdabot> http://sequence.complete.org/node/258
14:30:38 <lambdabot> Title: A simple TCP server | The Haskell Sequence
14:31:59 <hashendgame> mrd: thanks, but I've seen this and I'm comfortable with the network side. I'm thinking more about what to wrap in MVars, and dealing with things like World = [Zone], Zone = [Room], data Room = ...
14:33:28 <mrd> perhaps Arrays or Data.Maps would be useful
14:34:19 <hashendgame> Data.Map sounds promising because I could refer to zones and rooms by a string name
14:35:30 <vininim>  :t let f = getLine >>= \ x -> putStr (show (read x+1)) >>  getLine in f
14:35:42 <vininim> @t let f = getLine >>= \ x -> putStr (show (read x+1)) >>  getLine in f
14:35:42 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
14:35:53 <oerjan> vininim: space
14:36:08 <vininim> @type let f = getLine >>= \ x -> putStr (show (read x + 1)) >>  getLine in f
14:36:09 <lambdabot> IO String
14:36:21 <Taejo> btw, we would prefer if you *don't* post the SACO training camp on Reddit: we're not sure about our university's bandwidth, and we've got to make sure our squad has access.
14:36:40 <Taejo> (or Slashdot, etc)
14:37:03 <Taejo> and our IT services already dislike us
14:37:45 * oerjan recalls a reddit advice of making reddited pages static
14:38:07 <Taejo> oerjan: it wouldn't be much of a competition if it was static :)
14:38:07 <oerjan> might be used proactively...
14:38:41 <oerjan> well i suppose that refers to the page you give the link for
14:39:35 <pejo> Taejo, perhaps you should update the page every nth minute, and have it otherwise static?
14:39:52 <Taejo> pejo: have you looked at what the link is?
14:39:53 <vininim> it doesn't mention haskell in the page btw
14:40:20 <oerjan> that link looks rather static to begin with
14:40:39 <Taejo> vininim: is there no "Haskell support is still somewhat experimental/unofficial..."?
14:40:46 <Taejo> oerjan: it is static
14:41:04 <Taejo> what we can't handle is thousands of competition entrants
14:41:15 <oerjan> so hopefully that means you will not be hit that hard even if it ends up somewhere
14:41:29 <vininim> heh sorry, just saw it
14:42:50 <Taejo> oerjan: the thing is, for each entry we have to compile a program and run it ten times, and we only have 4 cores or something
14:43:00 <oerjan> oh
14:43:30 <Taejo> well, one on the web server and I think two each on two marking servers
14:45:46 <mrd> hmm, what's a good -ddump option for examining strictness
14:49:43 <gwern> @hoogle join
14:49:44 <lambdabot> Control.Monad.join :: Monad m => m (m a) -> m a
14:49:44 <lambdabot> Data.PackedString.joinPS :: PackedString -> [PackedString] -> PackedString
14:49:44 <lambdabot> System.FilePath.Windows.joinDrive :: FilePath -> FilePath -> FilePath
14:50:34 <ski> @help join
14:50:34 <lambdabot> join <channel>
14:50:58 <oerjan> @src join
14:50:58 <lambdabot> join x =  x >>= id
14:51:52 <gwern> is there a better way of getting the absolute addresses of directories in $HOME than 'homedirs = [liftM (++ "/bin/lib/") getHomeDirectory, liftM (++ "/lib/") getHomeDirectory]'?
14:52:05 <gwern> @type getHomeDirectory
14:52:07 <lambdabot> Not in scope: `getHomeDirectory'
14:52:15 <gwern> @hoogle getHomeDirectory
14:52:16 <lambdabot> System.Directory.getHomeDirectory :: IO FilePath
14:53:34 <oerjan> something in FilePath?
14:53:47 <hashendgame> @hoogle canonicalizePath
14:53:49 <lambdabot> System.Directory.canonicalizePath :: FilePath -> IO FilePath
14:53:53 <hashendgame> might be promising
14:54:48 <gwern> hm. canonicalizes based on where you are...
14:55:02 <hashendgame> gwern: how about System.FilePath.normalize?
14:55:34 <oerjan> nope
14:55:43 <oerjan> normalise "../bob/fred/" == "../bob/fred/"
14:56:34 <gwern> normalise "~/bin" -> "~/bin"
14:57:32 <oerjan> ah, combine looks promising
14:58:45 <gwern> you'd still need an IO call to get the user name, for something like 'combine "/home" "gwern"'
14:59:06 <gwern> at which point you might as well just call getHomeDirectory (home isn't always in /home)
15:01:20 <pejo> gwern, and home isn't always $USER either.
15:02:00 <oerjan> liftM2 combine getHomeDirectory . return
15:02:05 <sorear> erm, ~ is strictly a shell thing
15:04:51 <gwern> sorear: still useful
15:10:12 <nornagon> :t canonicalizePath
15:10:13 <lambdabot> Not in scope: `canonicalizePath'
15:10:23 <nornagon> :t System.FilePath.canonicalizePath
15:10:24 <lambdabot> Not in scope: `System.FilePath.canonicalizePath'
15:10:36 <nornagon> canonicalizePath :: FilePath -> IO FilePath
15:10:40 <nornagon> ^- why IO?
15:10:46 <nornagon> oh
15:10:49 <nornagon> darnit
15:10:53 <nornagon> it's obvious :(
15:11:02 <nornagon> i guess i need more coffee.
15:11:03 <mwc> pejo: indeed, to be portable (and why not be?) there may not even be a home directory (Windows)
15:11:10 <idnar> Windows has a home directory
15:11:25 <mwc> I'd guess that there's smoething in the libs that returns a home-like directory on all systems
15:11:33 <mwc> idnar: what, My Documents?
15:11:34 <idnar> well, it has a user directory anyway, although it's not used quite the same way as $HOME on UNIX
15:11:35 <nornagon> c:\documents and settings\$user\
15:12:01 <idnar> what nornagon said
15:12:14 <ddarius> %USER%
15:12:22 <dibblego> ?hoogle (a, b) -> (b -> c) -> (a, c)
15:12:23 <lambdabot> No matches, try a more general search
15:12:28 <nornagon> the whole path has a % name
15:12:29 <nornagon> iirc
15:12:33 <idnar> although there's a function you can call to get the real directory
15:12:49 <dibblego> ?type \x f -> (fst x, f (snd x))
15:12:50 <lambdabot> forall a b t. (a, b) -> (b -> t) -> (a, t)
15:13:04 <ddarius> :t second
15:13:05 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
15:13:08 <idnar> (it doesn't have to be on c:, and the path can also be \users or \windows\profiles\users depending on version of windows, and it can be moved elsewhere if you really want, and...)
15:13:08 <nornagon> @pl \x f -> (fst x, f (snd x))
15:13:08 <lambdabot> ap ((.) . (,) . fst) (flip id . snd)
15:13:24 <dibblego> nice one
15:13:29 <ddarius> :t flip second
15:13:29 <lambdabot> forall b c d. (d, b) -> (b -> c) -> (d, c)
15:13:34 <idnar> (er, I meant \users\$user and \windows\profiles\$user)
15:13:40 <nornagon> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,)
15:13:41 <lambdabot> forall a b c d e f g h i j k l m n o p q r s t u v w x y z t28 t29. -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z ->
15:13:41 <lambdabot> t28 -> t29 -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t28, t29)
15:13:43 <Toxaris> idnar, nornagon: and the name is locale-dependent. it's called "Dokumente und Einstellungen" on my german Windows XP.
15:13:49 <idnar> Toxaris: indeed
15:14:51 <nornagon> i'm sure lambdabot meant a -> b there
15:15:00 <nornagon> a -> b -> (etc), that is
15:15:29 <idnar> :t (,,,)
15:15:29 <lambdabot> forall a b c d. a -> b -> c -> d -> (a, b, c, d)
15:15:36 <idnar> curious
15:15:40 <shag> is there an easy way to convert utf8-encoded strings into general unicode strings?
15:15:57 <ddarius> utf8 encoded strings are general unicode strings
15:16:48 <koala_man> as in, a series of utf-8 bytes into a series of chars?
15:17:04 <shag> koala_man: yes
15:17:12 <shag> ddarius: well, yes, but no :)
15:18:23 <oerjan> afaik you need an extra library
15:18:36 <oerjan> and there may be several
15:18:49 <ddarius> @where hackage
15:18:49 <lambdabot> http://hackage.haskell.org/
15:18:53 <ddarius> Have a ball.
15:19:15 <idnar> "convert a sequence of bytes containing a utf-8 encoded string into a sequence of unicode characters" might be a better way to phrase it
15:19:26 <shag> well yea. i hoped someone knows the "quick and easy" solution ... thanks anyways :)
15:19:34 <ddarius> Or just "decode a utf8 encoded byte string"
15:20:12 <ddarius> shag: The quick and easy solution is: cabal install the appropriate library on hackage and then decode myString.
15:20:31 <Zao> shag: I believe that Char can hold an Unicode codepoint.
15:20:57 <ddarius> Zao: It can, but GHC's IO facilities don't read Unicode.
15:21:05 <ddarius> I.e. they don't decode it.
15:21:14 <Zao> Which is why one needs something like that nice utf8string library.
15:21:14 <shag> Char can hold an unicode, yes. but when reading some utf8 encoded string from the outside world, it will not be automatically transformed into unicode
15:21:39 <shag> i just discovered that one
15:45:54 <mrd> woot.  Haskell / NDP only 2x slower than C++ / OpenMP
15:51:18 <Pastorn> as an exercise i want to write instance Monad [a], is there any way i can load the prelude so that the list monad isn't instanciated (or whatever the correct word is)?
15:52:15 <oerjan> nope
15:52:20 <twanvl> There is no way to do that, the list type and the instance come together
15:52:26 <oerjan> instances are always imported
15:52:45 <oerjan> make your own list data type instead, i guess
15:52:49 <twanvl> You could make your own data type, data MyList a = Nil | Cons a (MyList a)
15:53:24 <EvilTerran> twanvl, well, that's not strictly true, but any module is inexorably linked to the instances declared in it, i believe
15:53:43 <twanvl> it is true for []
15:53:46 <EvilTerran> isn't the normal approach to that to use a newtype?
15:53:58 <oerjan> could do that yeah
15:54:04 <EvilTerran> i guess so. as i said, "not strictly true". just true enough. ;)
15:54:25 <oerjan> newtype ML a = ML [a]
15:54:45 <Pastorn> huh?
15:54:51 <twanvl> "the list type and the instance come together" `seq` return() -- now it is strictly true :)
15:54:53 <Pastorn> what will happend with newtye?
15:56:18 <EvilTerran> Pastorn, a newtype allows you to have something that looks like a different type to the typechecker, but is effectively the same as, an existing type
15:56:22 <oerjan> Pastorn: a newtype can have different instances from the type within
15:57:37 <oerjan> but you can still use all the old functions on the contents
15:58:57 <EvilTerran> as long as you wrap/unwrap the constructor at appropriate moments, anyway
15:59:09 <Pastorn> so i can create a Naybe a and then make a newtype Oaybe a = Naybe a and then instance Monad for Oaybe without it implying Monad Naybe?
15:59:29 <oerjan> yep
15:59:37 <EvilTerran> and vice-versa
15:59:37 <Pastorn> cool
16:00:05 <Pastorn> so then newtype List a = [a] will not inherit Monad?
16:00:16 <EvilTerran> you need a value constructor
16:00:20 <oerjan> although ghc also has "newtype deriving", which is a quick way of transferring instances when you do want them
16:00:26 <EvilTerran> so it can tell (List a)s apart from [a]s
16:00:32 <EvilTerran> newtype List a = List [a], say
16:01:19 <EvilTerran> then none of the functions on []s will work on your Lists directly, but you can unwrap the [] from the List constructor with pattern-matching, apply [] functions to it, then wrap it in the List constructor again
16:01:26 <EvilTerran> List :: [a] -> List a
16:01:52 <Pastorn> yeah :)
16:02:10 <EvilTerran> alternatively, you can get around having to use pattern-matching with an unList (List l) = l
16:02:18 <EvilTerran> which can be bundled into the newtype decleration with
16:02:27 <EvilTerran> newtype List a = List { unList :: [a] }
16:04:55 <Pastorn> thanks
16:05:03 <EvilTerran> :)
16:05:56 <scandal> is there no standard filterM function?  i have a list of filenames I want to only select the "regular" (ie, non-dir) files from, and the test function from System.Posix.Files has a type signature of  FilePath -> IO FileStatus.
16:06:41 <sarehu> you mean besides Control.Monad.filterM?
16:07:08 <EvilTerran> @hoogle filterM
16:07:09 <lambdabot> Control.Monad.filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]
16:07:10 <sarehu> or sorry, Monad.filterM
16:07:21 <scandal> thanks, i did see that one.
16:07:24 <scandal> err, didnt
16:07:33 <sarehu> there's filterM :: Monad m => (a -> m Bool) -> [a] -> m [a] in the haskell 98 standard
16:13:05 <hpaste>  gwern pasted "monad/io problem" at http://hpaste.org/4388
16:13:20 <gwern> I cannot get my type sigs to match up :(
16:16:17 <allbery_b> :t mapM
16:16:19 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
16:17:17 <Toxaris> gwern: did you try it without liftM?
16:17:22 <Toxaris> gwern: what type has getPaths?
16:17:32 <gwern> [IO FilePath]
16:18:00 <Toxaris> gwern: so what do you expect (liftM getPaths) to do? you should apply liftM to functions
16:18:33 <gwern> Toxaris: I expect it to allow the IO FilePaths from  canonicalize to be fed into  getPaths
16:18:39 <gwern> which takes FilePaths
16:18:57 <Toxaris> gwern: how can it take FilePaths, if it has type [IO FilePath]?
16:19:25 <gwern> Toxaris: you use a map to handle the [], and liftM to handle the IO
16:19:50 <Toxaris> gwern: but it surely has type (FilePath -> [IO Filepath]) then, hasn't it?
16:20:03 <oerjan> that map canonicalize looks a bit inefficient, it reruns getHomeDirectory for each path
16:20:43 <gwern> oerjan: I doubt it's an expensive operation; it's used only a few times; and I ultimately intend to use this at compile-tume through TH anyway
16:20:56 <oerjan> ok
16:21:15 <gwern> Toxaris: I don't follow
16:21:27 <Toxaris> <Toxaris> gwern: what type has getPaths?
16:21:28 <Toxaris> <gwern> [IO FilePath]
16:21:34 <oerjan> liftM's first argument must be a _function_
16:21:45 <oerjan> not a list, not an IO action
16:22:16 <gwern> but it has to be [IO FilePath], as it's getting a list of Strings, each of which is tainted by coming from an IO source
16:22:35 <Toxaris> gwern: can you show the source of getPaths?
16:23:24 <ricky_clarkson> @dinn [IO Integer] -> IO [Integer]
16:23:25 <lambdabot> -- f cannot be realized.
16:23:33 <pjd> ricky_clarkson: sequence
16:23:36 <allbery_b> :t sequence
16:23:36 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
16:23:42 <hpaste>  gwern annotated "monad/io problem" with "oops" at http://hpaste.org/4388#a1
16:23:53 <gwern> I didn't paste it - I thought I did, but I didn't
16:24:16 <Toxaris> gwern: as you have correctly written in your program, getPaths has type (FilePath -> IO [FilePath])
16:24:28 <Toxaris> gwern: so it indeed *is* a function
16:25:00 <Toxaris> gwern: but of entirely different type then you wrote!
16:25:34 <oerjan> gwern: use >>= getPaths instead of liftM getPaths, i think
16:25:41 <ricky_clarkson> @djinn Integer -> IO Integer
16:25:41 <lambdabot> -- f cannot be realized.
16:26:08 <Toxaris> oerjan: not possible because paths is [IO FilePath], not IO FilePath
16:26:11 <gwern> oerjan: yes, that compiles and works
16:26:20 <ricky_clarkson> @t return
16:26:20 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
16:26:23 <Toxaris> oerjan: ok, so indeed possible because of the mapM?
16:26:28 <gwern> 'ghcDirectory = liftM (last . sort . concat) $ mapM (>>= getPaths) paths'
16:26:30 <ricky_clarkson> :t return
16:26:31 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
16:26:32 <oerjan> yep
16:26:51 <ricky_clarkson> :t return :: IO Integer
16:26:51 <lambdabot>     Couldn't match expected type `IO Integer'
16:26:52 <lambdabot>            against inferred type `a -> m a'
16:26:52 <lambdabot>     In the expression: return
16:26:58 <ricky_clarkson> :t return :: IO
16:26:59 <lambdabot>     `IO' is not applied to enough type arguments
16:26:59 <lambdabot>     Expected kind `?', but `IO' has kind `* -> *'
16:26:59 <lambdabot>     In an expression type signature:
16:27:21 <gwern> :t (>>=)
16:27:21 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
16:27:26 <Toxaris> :t return :: a -> IO a
16:27:27 <lambdabot> forall a. a -> IO a
16:27:35 <allbery_b> :t return (5 :: Int)
16:27:36 <lambdabot> forall (m :: * -> *). (Monad m) => m Int
16:28:10 <vininim_> > getLine >>= (return .  (+1) . read)
16:28:12 <lambdabot>  <IO Integer>
16:28:18 <ricky_clarkson> > return 5 :: Maybe Integer
16:28:19 <lambdabot>  Just 5
16:28:26 <ricky_clarkson> How does it know to pick Just?
16:28:40 <Toxaris> ricky_clarkson: what should it pick instead?
16:28:54 <davidL> gwern: do you have a screenshot of your emacs somewhere? I stumbled across your config on wikipedia, I'm particularly interested in PrettyLambda :)
16:29:07 <ricky_clarkson> > return 5 :: Either Integer Integer
16:29:08 <lambdabot>   add an instance declaration for (Error Integer)
16:29:08 <lambdabot>     In the expression: retu...
16:29:10 <gwern> davidL: got a place to upload and I'll take it right now
16:29:19 <gwern> davidL: I think my WP config is pretty old right now
16:29:24 <ricky_clarkson> > return 5 :: Either Integer String
16:29:24 <lambdabot>   add an instance declaration for (Num String)
16:29:34 <Toxaris> > return 5 :: Either String Integer
16:29:35 <lambdabot>  Right 5
16:29:44 <ricky_clarkson> boggle
16:29:48 <Toxaris> > fail "time for left, too" :: Either String Integer
16:29:49 <lambdabot>  Left "time for left, too"
16:30:10 <ricky_clarkson> @src Maybe
16:30:10 <lambdabot> data Maybe a = Nothing | Just a
16:30:37 <ricky_clarkson> Why doesn't mine work?
16:30:55 <Toxaris> ricky_clarkson: wich one? Either Integer String?
16:31:02 <ricky_clarkson> Yes.
16:31:14 <davidL> gwern: want me to make a temporary ftp account to upload with or can you email it?
16:31:21 <gwern> davidL: email works
16:31:27 <Toxaris> ricky_clarkson, because the Monad instance for Either hardwires the use of Left = fail and Right = return
16:31:44 <oerjan> @src Either return
16:31:44 <lambdabot> return        = Right
16:31:50 <oerjan> @src Maybe return
16:31:50 <lambdabot> return              = Just
16:31:53 <ricky_clarkson> I see.
16:32:04 <gwern> huh. so that's what Maybe was actually doing
16:32:37 <ricky_clarkson> Doall monads do that?
16:32:47 <Toxaris> ricky_clarkson: basically, yes
16:32:59 <Toxaris> ricky_clarkson: every monad is different, of course
16:33:00 <oerjan> all monads must have return and (>>=) defined
16:33:19 <Toxaris> > return "test" :: [String] -- consider the list monad
16:33:20 <lambdabot>  ["test"]
16:33:35 <ricky_clarkson> @src Maybe (>>=)
16:33:35 <lambdabot> (Just x) >>= k      = k x
16:33:35 <lambdabot> Nothing  >>= _      = Nothing
16:33:38 <Toxaris> > fail "never shown" :: [String] -- wich represents failure as empty list
16:33:39 <lambdabot>  []
16:34:23 <ricky_clarkson> > Just id >>= 5
16:34:24 <gwern> davidL: the screenshot is even now wafting its way across the ether to you
16:34:24 <lambdabot>        add an instance declaration for (Num ((a -> a) -> Maybe b))
16:34:26 <Toxaris> > return "one" <|> return "two" :: [String] -- and can contain more then one result at once
16:34:27 <lambdabot>  ["one","two"]
16:35:00 <ricky_clarkson> > Just 5 >>= id
16:35:01 <lambdabot>   add an instance declaration for (Num (Maybe b))
16:35:40 <oerjan> > Just 5 >>= return
16:35:41 <lambdabot>  Just 5
16:35:56 <oerjan> > Just (Just 5) >>= id
16:35:57 <lambdabot>  Just 5
16:36:22 <Toxaris> > Just 5 >>= \resultSoFar -> return (2 * resultSoFar)
16:36:23 <lambdabot>  Just 10
16:36:28 <davidL> gwern: that is pretty, hopefully I wont need leet elisp skills to install that
16:37:20 <gwern> davidL: I don't have elite elisp skills, but by this point i've worked on my .emacs for like 3 years, so I'm not sure if anyone can follow it
16:37:31 <gwern> the haskell bits are relatively recent, so they should still be uncrufty
16:37:41 <davidL> ah good to know
16:38:00 <vininim_> >  Just "1" >>= (return . (take 5) . (repeat) . read) :: Maybe String
16:38:01 <lambdabot>  Exception: Prelude.read: no parse
16:38:16 <gwern> ok, so now I have my function which locates ghc installations! all I need to do now is learn Template Haskell and substitute at runtime
16:38:23 <gwern> er, compiletime
16:39:29 <oerjan> >  Just "'a'" >>= (return . (take 5) . (repeat) . read) :: Maybe String
16:39:30 <lambdabot>  Just "aaaaa"
16:39:55 <vininim_> o_O
16:40:08 <oerjan> that read is trying to get a Char...
16:40:22 <sgillesp1e> hello everyone
16:40:38 <vininim_> >  Just "1" >>= (return . (take 5) . (repeat) . read) :: Maybe Integer
16:40:39 <lambdabot>  Couldn't match expected type `Integer' against inferred type `[b]'
16:40:45 <vininim_> >  Just "1" >>= (return . (take 5) . (repeat) . read) :: Maybe [Integer]
16:40:45 <lambdabot>  Just [1,1,1,1,1]
16:40:54 <sgillesp1e> looking through the ghc source - is javaGen used at all?
16:41:15 <vininim_> oh, the type annotation was refering to the whole expression
16:41:34 <oerjan> indeed
16:41:48 <oerjan> :: has lower precedence than operators
16:41:55 <sgillesp1e> Just 5
16:41:57 <Nafai> gwern: Where's your .emacs?
16:42:57 <gwern> Nafai: I attached it to the email I sent davidL
16:43:09 <gwern> there's an outdated version in my Wikipedia userspace too
16:43:21 <vininim_> > getLine >>= (return . (take 5) .( repeat) . (read::String->Integer))
16:43:22 <lambdabot>  <IO [Integer]>
16:43:31 <Nafai> Just curious to see what you've done haskell-wise in it
16:43:37 <vininim_> somehow I was expecting read to be magical
16:44:18 <gwern> > getLine >>= (take 5 $ repeat $ read (andThenaMiracleOccurs))
16:44:18 <lambdabot>   Not in scope: `andThenaMiracleOccurs'
16:44:28 <gwern> I think you need to work on that function
16:45:38 <oerjan> incidentally, x >>= return . f = liftM f x
16:46:05 <Toxaris> > take 5 . repeat . read $ "42 :: [Integer]
16:46:05 <lambdabot>  Improperly terminated string at ""42" (column 26)
16:46:09 <Toxaris> > take 5 . repeat . read $ "42" :: [Integer]
16:46:09 <lambdabot>  [42,42,42,42,42]
16:46:34 <Toxaris> > replicate 5 . read $ "42 :: [Integer]
16:46:34 <lambdabot>  Improperly terminated string at ""42" (column 22)
16:46:44 <Toxaris> > replicate 5 . read $ "42" :: [Integer] -- should not copy the wrong version
16:46:44 <lambdabot>  [42,42,42,42,42]
16:47:04 <oerjan> > Improperly terminated string at ""42" (column 22)
16:47:04 <lambdabot>  Improperly terminated string at """ (column 37)
16:47:22 <oerjan> > Improperly terminated string at """ (column 37)
16:47:22 <lambdabot>  Improperly terminated string at """ (column 35)
16:47:28 <oerjan> > Improperly terminated string at """ (column 35)
16:47:28 <lambdabot>  Improperly terminated string at """ (column 35)
16:47:34 <smack_> ha
16:47:47 <Toxaris> > replicate 5 . read <$> getLine :: IO [Integer]
16:47:47 <lambdabot>  <IO [Integer]>
16:47:48 <oerjan> yay
16:48:02 <ricky_clarkson> @pl \x -> [x,x..]
16:48:02 <lambdabot> join enumFromThen
16:48:03 <Toxaris> oerjan: cool. is that bot-art?
16:48:34 <Saizan> syntax-error quine! wonderful!
16:48:40 <oerjan> Toxaris: it's known as kimian self-reproduction, according to the Quine Page
16:49:00 <ricky_clarkson> > take 5 . join enumFromThen . read "42" :: [Integer]
16:49:01 <lambdabot>  Couldn't match expected type `[Integer]'
16:49:13 <oerjan> which refers to GEB
16:49:20 <ricky_clarkson> > take 5 . join enumFromThen . read $ "42" :: [Integer]
16:49:20 <lambdabot>  [42,42,42,42,42]
16:51:24 <Toxaris> oerjan used a fixpoint iteration to arrive at the quine. is that generally usefull in quine-search?
16:52:08 <int-e> Toxaris: it's often easier to write a quine-generating program than a quine, so in that sense, yes it is.
16:53:04 <gwern> :t replicate
16:53:04 <lambdabot> forall a. Int -> a -> [a]
16:53:22 <ricky_clarkson> > "let's go "++fix ("meta"++)
16:53:22 <lambdabot>  "let's go metametametametametametametametametametametametametametametametame...
16:54:02 <vininim> > getLine >>= (return . (replicate 5) . (read::String->Integer))
16:54:03 <lambdabot>  <IO [Integer]>
16:54:31 <oerjan> Toxaris: actually i didn't notice until you said it that i had responded with the same thing lambdabot answered, i thought i was modifying my own text :D
16:55:23 <smack_> oerjan: that's even more interesting
16:56:48 <oerjan> vininim: btw you don't need parentheses around replicate 5
16:57:19 <oerjan> or the outer ones for that matter
16:57:31 <moconnor> If I have some code which is constantly getting "Exception: stack overflow" how do I go about figuring out exactly which function is doing the wrong thing?
16:57:46 <visof> please can i ask question out haskell??
16:58:12 <gwern> visof: no, the lolcatese is 'i can has answer??'
16:58:12 <visof> about ghc installation?
16:58:18 <EvilTerran> > return . replicate 5 . read =<< getLine
16:58:18 <lambdabot>  Add a type signature
16:58:23 <EvilTerran> hm
16:58:39 <visof> ok
16:58:39 <oerjan> EvilTerran: it still cannot guess what type you want to read
16:58:47 <EvilTerran> yeah, i see
16:59:45 <EvilTerran> > return . replicate 5 =<< (readLn :: IO Integer)
16:59:46 <oerjan> moconnor: well everywhere you think you are tail recursing is a good bet ;)
16:59:46 <lambdabot>  <IO [Integer]>
17:00:00 <EvilTerran> > liftM (replicate 5) (readLn :: IO Integer)
17:00:01 <lambdabot>  <IO [Integer]>
17:00:05 <oerjan> also, profiling...
17:00:06 <EvilTerran> ok, i'm done :P
17:00:17 <ddarius> And the debugger...
17:00:34 <moconnor> @src foldl'
17:00:34 <lambdabot> foldl' f a []     = a
17:00:34 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
17:01:18 <oerjan> > replicate 5 <$> (readLn :: IO Integer) -- obligatory
17:01:18 <lambdabot>  <IO [Integer]>
17:13:16 <hpaste>  shivernz pasted "basics x2" at http://hpaste.org/4390
17:14:17 <oerjan> shivernz: you must have a Nil at the end
17:14:18 <faxathisia> shivernz: The Cons takes two parameters
17:14:29 <gwern> goodness. that template haskell stuff was a lot easier to do than I expected. a good night's work!
17:14:39 <gwern> now to do something less stressful on me fingers
17:15:11 <oerjan> listLength (Cons 1 (Cons 2 Nil))
17:15:28 <shivernz> faxathisia, cerjan, thanks. nothing like trying to learn fp for the first time to make you feel like a complete idiot
17:15:38 <davidL> > (^2)<$>[1..10]
17:15:40 <lambdabot>  [1,4,9,16,25,36,49,64,81,100]
17:15:53 <shivernz> everything is so obvious, but only after i've seen the answer :)
17:16:02 <faxathisia> shivernz: How are you learning?
17:16:31 <shivernz> faxathisia, the "Yet Another Haskell Tutorial"
17:16:38 <faxathisia> oh yeah I've seen that
17:16:43 <shivernz> and various other tutorials
17:16:57 <shivernz> i jump around when one gets too far ahead of me
17:17:27 <shivernz> they all see to assume a bit too much for my basic skills/lack there of
17:17:43 <Laney> window level all
17:17:54 <Laney> oops :(
17:18:05 <falbani> Hi.
17:18:12 <shivernz> are your windows level now? :)
17:18:16 <dmwit> Hiya, falbani.
17:18:26 <Laney> i would hope so :(
17:18:50 <falbani> I want to combine Haskell with graphics...
17:19:18 <dmwit> Gtk2Hs, HOpenGL, I think a few others
17:19:24 <pjd> shivernz: have you looked at the wikibook/
17:19:25 <pjd> ?
17:19:31 <davidL> wxHaskell maybe?
17:19:35 <faxathisia> *lol*
17:19:55 <shivernz> pjd, only briefly. is it worth a better look?
17:20:06 <pjd> shivernz: dunno, maybe
17:20:27 <falbani> I remember long ago playing in QBasic with simple primitives and drawing pixels for making dummie apps for, basically, play and experiment...
17:20:50 <pjd> shivernz: it should cover all the basics fairly evenly / without assuming too much
17:20:52 <falbani> And I'm wondering if there is a way of doing graphics in a very very easy way in Haskell
17:21:40 <shivernz> pjd, ill give it a go. thanks
17:21:51 <shivernz> hopefully my next question here won't be so sad
17:21:53 <dmwit> falbani: Have a look at Hugs, I think it has a pretty simplistic library for graphics.
17:21:58 <EvilTerran> falbani, HOpenGL's fairly straightforward
17:22:34 <EvilTerran> there's HGL, which is even more straightforward, but dead as a project (and rather limited)
17:22:52 <falbani> I'm aware of various graphics libraries for Haskell, but I never saw an example of less than a bunch of lines for making very precise things...
17:23:28 <falbani> I'm very slow at thinking & typing in english...
17:23:47 <falbani> Are there such examples in haskellWiki?
17:25:19 <EvilTerran> falbani, have a look at http://blog.mikael.johanssons.org/archive/2006/09/opengl-programming-in-haskell-a-tutorial-part-1/
17:25:21 <lambdabot> Title: Michi&#8217;s blog » Blog Archive » OpenGL programming in Haskell - a tutorial ( ..., http://tinyurl.com/ea6tc
17:25:46 <EvilTerran> the first example doesn't work with current versions of GLUT, but the rest of it's fine
17:25:58 <falbani> Nice, thanks...
17:51:08 <dibblego> > let g = reverse . f; f n = if n == 0 then [] else n `mod` 10 : f (n `div` 10) in g 12345 -- can this function be written in a better way?
17:51:08 <lambdabot>  [1,2,3,4,5]
17:52:35 <vininim> > [1..5]
17:52:35 <lambdabot>  [1,2,3,4,5]
17:52:41 <faxathisia> > show 12345
17:52:41 <lambdabot>  "12345"
17:52:45 <faxathisia> hmm
17:52:50 <EvilTerran> > reverse . map (`mod`10) . takeWhile (/=0) . iterate (`div`10) $ 12345
17:52:50 <lambdabot>  [1,2,3,4,5]
17:52:58 <faxathisia> > map digitToInt . show 12345
17:52:58 <lambdabot>  Couldn't match expected type `a -> [Char]'
17:53:26 <faxathisia> > map digitToInt (show 12345)
17:53:26 <allbery_b> map digitToInt . show $ 12345
17:53:26 <lambdabot>  [1,2,3,4,5]
17:53:41 <allbery_b> hm
17:53:45 * allbery_b is wrong
17:53:52 <faxathisia> > map digitToInt . show $ 12345
17:53:52 <lambdabot>  [1,2,3,4,5]
17:53:56 <faxathisia> you are not wrong
17:54:04 <allbery_b> > map digitToInt . show $ 12345
17:54:04 <lambdabot>  [1,2,3,4,5]
17:54:06 <allbery_b> ah
17:54:11 * allbery_b is just confused, then
17:54:12 * EvilTerran would use map digitToInt . showInt...
17:54:20 <EvilTerran> @index showInt
17:54:20 <lambdabot> Numeric
17:54:30 <faxathisia> ok I didn't know about showInt
17:54:33 <allbery_b> (also a bit wobbly which probably explains it)
17:54:35 <faxathisia> that's better
17:54:47 <EvilTerran> well, i'd use my big long one, actually; i don't like the via-string-ness of that one
17:55:01 <shachaf> > unfoldr (\x -> guard (x /= 0) >> return (x `mod` 10, x `div` 10)) 12345
17:55:01 <lambdabot>  [5,4,3,2,1]
17:55:03 <shachaf> Hmm.
17:55:12 <faxathisia> backwards lol
17:55:16 <EvilTerran> but i prefer showInt to show for supersticious performance-related reasons
17:55:22 <ricky_clarkson> > foldl (\x y -> x*10+y) [1,2,3,4,5]
17:55:23 <lambdabot>   add an instance declaration for (Num [t])
17:55:23 <lambdabot>     In the expression: (x * 10) +...
17:55:28 <ricky_clarkson> > foldl (\x y -> x*10+y) 0 [1,2,3,4,5]
17:55:28 <lambdabot>  12345
17:55:29 <faxathisia> performance.... :/
17:55:36 <faxathisia> does it still matter?
17:55:42 <EvilTerran> well, and that it provides more semantic context
17:55:44 <faxathisia> ohhhhh
17:55:50 <faxathisia> you said supersticious that makes mse happy
17:56:02 <vininim> I would guess ghc does a good job at optimizing [1..5]
17:56:47 <ricky_clarkson> @check \x -> x==foldl (\x y ->x*10+y) 0 $ map digitToInt . show $ 12345
17:56:48 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `Bool'
17:57:06 <shachaf> ricky_clarkson: ($) problems again.
17:57:22 <ricky_clarkson> @check \x -> x==foldl (\x y ->x*10+y) 0 (map (digitToInt . show) 12345)
17:57:22 <lambdabot>  Couldn't match expected type `Char' against inferred type `String'
17:57:45 <ricky_clarkson> @check \x -> x==foldl (\x y ->x*10+y) 0 (map (digitToInt . show) x)
17:57:45 <lambdabot>  Couldn't match expected type `Char' against inferred type `String'
17:58:09 <EvilTerran> > reverse . unfoldr ((>>) <$> guard.(/=0) <*> Just.(snd&&&fst).(`divMod`10)) $ 12345
17:58:09 <lambdabot>  [1,2,3,4,5]
17:58:31 <EvilTerran> (i'm sorry)
17:58:47 <faxathisia> lol
17:59:01 <shachaf> EvilTerran: Not liftA2?
17:59:09 <EvilTerran> eh
17:59:48 <oerjan> @check \x -> x==foldl (\x y ->x*10+y) 0 (map digitToInt . show $ x)
17:59:48 <lambdabot>  Exception: Char.digitToInt: not a digit '-'
17:59:57 <shachaf> > reverse . unfoldr (liftA2 (>>) (guard . (/=0)) (Just . (snd &&& fst) . (`divMod` 10))) $ 12345
17:59:57 <lambdabot>  [1,2,3,4,5]
18:00:04 <EvilTerran> > foldl (flip id) [] . map ((:).(`mod`10)) . takeWhile (/=0) . iterate (`div`10) $ 12345
18:00:05 <lambdabot>  [1,2,3,4,5]
18:00:07 <oerjan> @check \x -> x >= 0 ==> x==foldl (\x y ->x*10+y) 0 (map digitToInt . show $ x)
18:00:08 <lambdabot>  OK, passed 500 tests.
18:01:21 <EvilTerran> > foldl (flip$(:).(`mod`10)) [] . takeWhile (/=0) . iterate (`div`10) $ 12345
18:01:22 <lambdabot>  [1,2,3,4,5]
18:01:24 <vininim> @type (==>)
18:01:25 <lambdabot> Not in scope: `==>'
18:01:42 <oerjan> :t (Test.QuickCheck.==>)
18:01:42 <lambdabot> forall a. (Test.QuickCheck.Testable a) => Bool -> a -> Test.QuickCheck.Property
18:02:00 <EvilTerran> (beware my tired mind)
18:02:09 <ricky_clarkson> oerjan: What was wrong with mine, apart from the missing guard?
18:03:05 <oerjan> ricky_clarkson: map (digitToInt . show) vs. (map digitToInt) . show
18:03:26 <ricky_clarkson> Ahh.
18:04:53 <ricky_clarkson> @check \x -> (x :: Integer)==0 ==> x==0
18:04:53 <lambdabot>  Arguments exhausted after 96 tests.
18:08:00 <SamB_XP> @scheck \x -> (x :: Integer)==0 ==> x==0
18:08:01 <lambdabot>   Completed 13 test(s) without failure.  But 12 did not meet ==> condition.
18:14:57 <ddarius> @scheck join and
18:14:57 <lambdabot> Couldn't match expected type `[Bool] -> a'
18:15:02 <ddarius> @scheck join (&&)
18:15:03 <lambdabot>   Failed test no. 2. Test values follow.: False
18:25:10 <Pastorn> @help
18:25:11 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
18:25:19 <Pastorn> @list
18:25:19 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
18:26:10 <Pastorn> @help dice
18:26:11 <lambdabot> dice <expr>. Throw random dice. <expr> is of the form 3d6+2.
18:26:28 <Pastorn> @dice 3d6+2
18:26:28 <lambdabot> 3d6+2 => 11
18:26:37 <Pastorn> @dice d1+2
18:26:37 <lambdabot> unexpected "d": expecting number
18:26:39 <Pastorn> @dice 1d1+2
18:26:40 <lambdabot> 1d1+2 => 3
18:26:58 <Pastorn> helpful... or something...
18:27:17 <faxathisia> @dice 100
18:27:17 <lambdabot> 100 => 100
18:27:24 <faxathisia> I just rolled a 100
18:27:25 <faxathisia> :)
18:27:43 <mokus> @dice 101
18:27:43 <lambdabot> 101 => 101
18:27:43 <Pastorn> lucky you
18:27:48 <faxathisia> foiled!
18:27:49 <EvilTerran> @dice 1d100
18:27:49 <lambdabot> 1d100 => 8
18:27:54 <Pastorn> or maybe not
18:28:00 <EvilTerran> @dice 100d1
18:28:00 <lambdabot> 100d1 => 100
18:28:07 <EvilTerran> @dice 0d0+100
18:28:08 <lambdabot> 0d0+100 => 100
18:28:14 <oerjan> @dice 1d100
18:28:14 <lambdabot> 1d100 => 82
18:28:15 <faxathisia> @dice 2*3+7
18:28:15 <lambdabot> unexpected "*": expecting digit, "d", "+" or end
18:28:23 <Pastorn> @dice 1d6
18:28:23 <lambdabot> 1d6 => 2
18:28:24 <mokus> @dice 1d10000
18:28:24 <Pastorn> @dice 1d6
18:28:25 <lambdabot> 1d10000 => 1038
18:28:25 <lambdabot> 1d6 => 1
18:28:36 <Pastorn> @dice 2d6
18:28:36 <lambdabot> 2d6 => 7
18:28:39 <Pastorn> @dice 2d6
18:28:40 <lambdabot> 2d6 => 11
18:28:41 <Pastorn> @dice 2d6
18:28:41 <lambdabot> 2d6 => 7
18:28:46 <Pastorn> yay! seven
18:28:55 <davidL> @dice 10000d10000000
18:28:55 <lambdabot> 10000d10000000 => 50040486646
18:28:56 <Pastorn> @dice 1d1+2
18:28:56 <lambdabot> 1d1+2 => 3
18:29:14 <faxathisia> @dice 1d1+2d2+3d3+4d4+5d5+6d6+7d7+8d8+9d9
18:29:15 <lambdabot> 1d1+2d2+3d3+4d4+5d5+6d6+7d7... => 167
18:29:23 <oerjan> @dice 10000000d2
18:29:24 <lambdabot> 10000000d2 => 15003467
18:29:39 <oerjan> @dice 1000000000d2
18:29:39 <lambdabot> 1000000000d2 => 1500025140
18:29:50 <Pastorn> fuck... i should never have started this...
18:29:56 <davidL> @dice (-1)d(-4)
18:29:56 <lambdabot> unexpected "(": expecting number
18:29:57 <faxathisia> @dice Parstor
18:29:57 <lambdabot> unexpected "P": expecting number
18:30:02 <oerjan> _something_ tells me it is not actually doing those throws directly :D
18:30:25 <faxathisia> oerjan: because the results are totally wrong?
18:30:41 <faxathisia> > 15003467*2
18:30:42 <lambdabot>  30006934
18:30:43 <oerjan> faxathisia: because 1000000000d2 should take a while to calculate
18:30:54 <faxathisia> oh..
18:30:54 <oerjan> @dice 10000000000000d2
18:30:55 <lambdabot> 10000000000000d2 => 15000000671613
18:31:09 <faxathisia> > (15000000671613-10000000000000)*2
18:31:11 <lambdabot>  10000001343226
18:31:18 <faxathisia> I forgot die start at 1 and not 0 :p
18:31:49 <faxathisia> @dice 1d0
18:31:50 <lambdabot> 1d0 => 0
18:31:53 <faxathisia> @dice 0d0
18:31:53 <lambdabot> 0d0 => 0
18:32:17 <davidL> @dice "1d6"
18:32:17 <lambdabot> unexpected "\"": expecting number
18:40:32 <moconnor> @src iterate
18:40:33 <lambdabot> iterate f x =  x : iterate f (f x)
18:41:33 <moconnor> @src length
18:41:33 <lambdabot> Source not found. I am sorry.
18:41:46 <moconnor> bah!
18:41:59 <oerjan> weird
18:42:25 <oerjan> length            = foldl' (\n _ -> n + 1) 0
18:43:39 <moconnor> thanks
18:44:01 <visof> how can i install lambdabot on my own ghc
18:44:04 <visof> ?
18:44:34 <oerjan> @where goa
18:44:35 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/goa/
18:44:47 <allbery_b> painfully; the source has bitrotted a bit and was never especially friendly to install
18:44:48 <newsham> get a copy of the src from darcs, get the prerequisites, build it with the cabal or with the build script (if its still using the build script)
18:47:48 <Brian`> hey is there a program like cscope for haskell?
18:48:17 <SamB_XP> Brian`: haven't heard of one
18:48:24 <oerjan> ah, @dice cheats with normal distribution if number of throws > 100
18:48:32 <SamB_XP> but you can grep for module names...
18:48:53 <visof> newsham when i did sudo runghc Setup.hs configure
18:48:55 <visof> i had
18:48:58 <visof>  At least the following dependencies are missing:
18:48:59 <visof>     plugins >=1.0, fps >=0.7
18:49:13 <visof> newsham what should i do?
18:49:58 <Brian`> SamB_XP, yeah I guess.. I'm not using on Linux ; so it may not work for me?
18:51:03 <moconnor> @src maximum
18:51:03 <lambdabot> maximum [] = undefined
18:51:03 <lambdabot> maximum xs = foldl1 max xs
18:51:04 <allbery_b> there should be a couple of cabal files in the distribution, one disables plugins, one supports ghc-6.6.x (where fps is in base)
18:51:15 <moconnor> Why is maximum defined w/ foldl1 and not foldl1' ?
18:51:20 <allbery_b> I don't think there's one for 6.8 yet (where it's not fps any more, it's bytestrinsg)
18:51:38 <oerjan> moconnor: foldl1' is not in original H98
18:51:39 <ddarius> moconnor: foldl1 is in the standard foldl1' isn't.
18:51:46 <moconnor> thanks
18:52:12 <oerjan> (that length definition probably was a modernised one)
18:52:29 <newsham> visof: which ghc are you using?
18:52:47 <visof> i use ghc-6.8.1
18:53:06 <newsham> it might require 6.6, I dont know if hs-plugins has been ported to 6.8 yet
18:53:20 <newsham> ?where hs-plugins
18:53:20 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
18:53:24 <nolrai> @src foldl1
18:53:24 <lambdabot> foldl1 f (x:xs) = foldl f x xs
18:53:24 <lambdabot> foldl1 _ []     = undefined
18:53:42 <nolrai> @ty foldl1
18:53:43 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
18:54:09 <newsham> > foldl1 (+) [3,5,8]
18:54:09 <oerjan> nolrai: usually you want the ' version
18:54:10 <lambdabot>  16
18:54:16 <nolrai> @ty foldl1'
18:54:16 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
18:54:23 <nolrai> @src foldl1'
18:54:23 <lambdabot> Source not found. Just what do you think you're doing Dave?
18:54:25 <TSC> Same type, only stricter
18:54:33 <oerjan> @src foldl'
18:54:33 <lambdabot> foldl' f a []     = a
18:54:34 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
18:54:34 <nolrai> ?
18:54:56 <TSC> > foldl1 (+) [1..1000000]
18:54:57 <lambdabot>  Exception: stack overflow
18:55:00 <TSC> > foldl1' (+) [1..1000000]
18:55:01 <lambdabot>  500000500000
18:55:03 <TSC> Ta da
18:55:13 <nolrai> @src foldl1'
18:55:14 <lambdabot> Source not found. Just what do you think you're doing Dave?
18:55:17 <nolrai> @src foldl'
18:55:17 <lambdabot> foldl' f a []     = a
18:55:17 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
18:55:44 <moconnor> Is there a way to get lambdabot's @src functionality fromt he command line, w/o having to go to IRC?
18:55:55 <oerjan> nolrai: @src has rather unpredictable holes in its database
18:56:13 <TSC> I think you could define: foldl1' f (x:xs) = foldl' f x xs
18:56:15 <nolrai> just checking my sanity
18:57:22 <oerjan> moconnor: what visof just asked, but it's hard to do
18:57:40 <moconnor> oh, ok
18:58:11 <oerjan> this actually is easier with hugs, because it's an interpreter so has the sources
18:58:32 <oerjan> :f functionName brings it up in the editor
18:59:22 <visof> newsham when i try to install "hs-plugins" i have  :
18:59:25 <visof>  Could not find module `Data.Array.Base':
18:59:26 <visof>       it is a member of package array-0.1.0.0, which is hidden
18:59:26 <oerjan> (which is how i found length to paste)
19:01:03 <visof> oerjan how can i install lambdabot on hugs?
19:01:10 <newsham> visof: I believe hs-plugins isnt yet ported to ghc-6.8
19:01:17 <oerjan> visof: impossible
19:01:26 <oerjan> hs-plugins is ghc only afaik
19:01:53 <oerjan> it's just that hugs has its own command to go to the source
19:03:56 <thoughtpolice> you can embed lambdabot in ghci if you compile it but it's not ready with 6.8 yet (hs-plugins isn't either)
19:04:03 <thoughtpolice> sucks. i missed @src and whatnot in ghci. :(
19:06:27 <newsham> visof: can you deal with ghc6.6?
19:06:55 <visof> how?
19:07:11 <newsham> by installing ghc6.6?
19:07:20 <visof> no
19:07:41 <visof> can i install hs-plugins for ghc6.6
19:07:42 <visof> ?
19:07:57 <newsham> it should build in ghc6.6
19:08:42 <thoughtpolice> yes, if you use the darcs repo.
19:08:43 <nolrai> > http://en.wikipedia.org/wiki/Special:Search?go=Go&search=1,2][3,4 ! 1 ! 2
19:08:44 <lambdabot>  Parse error at "=Go&s..." (column 47)
19:09:11 <nolrai> stupid irc client
19:09:33 <visof> newsham i installed ghc6.6 and ghc-6.8
19:09:51 <roger`> is it possible to satisfy the "unix -any" dependency when trying to build with cabal on windows?
19:09:51 <visof> how can i use ghc6.6 rather than ghc6.8
19:09:52 <visof> ?
19:10:02 <visof> for installing lambdabot?
19:10:06 <thoughtpolice> try 'ghc-6.6 --version' ?
19:10:26 <thoughtpolice> if it's 6.6.1 just add the '.1' to the command
19:11:30 <nolrai> > [[1,2][3,4]] ! 1 ! 2
19:11:31 <lambdabot>  Couldn't match expected type `Array i e'
19:11:38 <nolrai> > [[1,2][3,4]] !! 1 !! 2
19:11:39 <lambdabot>  Couldn't match expected type `t -> a' against inferred type `[a1]'
19:11:43 <newsham> www.haskell.org/ghc should have the ghc6.6.1 release available for download if you dont have it yet
19:11:59 <nolrai> > ([[1,2][3,4]] !! 1) !! 2
19:11:59 <lambdabot>  Couldn't match expected type `t -> a' against inferred type `[a1]'
19:12:12 <nolrai> @ty (!!)
19:12:13 <lambdabot> forall a. [a] -> Int -> a
19:13:05 <nolrai> > [1,2] !! 2
19:13:06 <lambdabot>  Exception: Prelude.(!!): index too large
19:13:12 <nolrai> > [1,2] !! 1
19:13:12 <lambdabot>  2
19:13:24 <nolrai> its zero indexed?
19:13:46 <chessguy> but of course :)
19:14:01 <nolrai> > ([[1,2],[3,4]] !! 1) !! 2
19:14:02 <lambdabot>  Exception: Prelude.(!!): index too large
19:14:08 <nolrai> > ([[1,2],[3,4]] !! 0) !! 1
19:14:09 <lambdabot>  2
19:14:17 <nolrai> > [[1,2],[3,4]] !! 0 !! 1
19:14:18 <lambdabot>  2
19:14:22 <nolrai> cool
19:16:35 <nolrai> is there a simple way to filter the elements of a list of lists?
19:16:51 <chessguy> example?
19:16:54 <allbery_b> map (filter ...) -- ?
19:17:11 <nolrai> yeah I think thats what i want.
19:17:38 <chessguy> @type map . filter
19:17:39 <lambdabot> forall a. (a -> Bool) -> [[a]] -> [[a]]
19:18:46 <nolrai> @pl playerNsFleets fleets n = map (filter ( (== n) . owner)) fleets
19:18:46 <lambdabot> playerNsFleets = flip (map . filter . (. owner) . (==))
19:18:52 <byorgey> > map (filter even) [[1,2,3], [4,6,7], [9,9]]
19:18:53 <lambdabot>  [[2],[4,6],[]]
19:19:12 <nolrai> yep thats it.
19:20:09 <nolrai> are diff arrays worth using?
19:20:29 <nolrai> not for above.
19:22:07 <allbery_b> someone benchmarked diffarrays and determined that they're not really all that useful even for the applications where theyr'e useful, IIRC
19:22:26 <allbery_b> (although I suppose soemone might have optimized them a bit since then)
19:22:53 <nolrai> the idea behind them _seems_ sound.
19:23:33 <oerjan> apparently the locking to make them thread safe is just too expensive, iiuc
19:23:38 <allbery_b> the idea is sound, the implementation just sucks a lot currently (or did around 6.6.0's base)
19:24:11 <allbery_b> I thought they came up with some ideas to optimize them a bit; the existing implementationt hen was reportedly unoptimized
19:24:39 <nolrai> although i realy shouldnt be woring about efficintcy for what im doing.
19:25:45 <nolrai> I can see that thread safeing them would be tough, i think.
19:27:54 <Brian`> hey is ListUtils module Data.List?
19:28:16 <Brian`> I was looking at Probability.hs file by Martin Erwig
19:28:26 <Brian`> and when I try to compile that file, it says ListUtils cannot be found..
19:28:37 <Brian`> wondering if any of you knows..
19:29:25 <chessguy> implicit imports ftl!
19:29:37 <chessguy> s/imports/import lists/
19:30:14 <allbery_b> huh.  google tells me that;s one ancient (and obsolete?) module
19:31:16 <moconnor> Has there ever been a proposal for an alternate do-syntax like this: "n <= 5" which is short for "n <- return 5" ?
19:31:47 <sjanssen> moconnor: why not use let?
19:31:51 <oerjan> :t (<=)
19:31:52 <lambdabot> forall a. (Ord a) => a -> a -> Bool
19:32:06 <nolrai> less then or equal
19:32:31 <allbery_b> moconnor: let n = 5
19:32:48 <moconnor> I didn't know you could use "let" w/o "in"
19:32:50 <oerjan> > do let {n = 5} ; [n,2]
19:32:51 <lambdabot>  [5,2]
19:32:58 <allbery_b> it's specific to "do" syntax
19:33:05 <moconnor> thanks!
19:33:26 <allbery_b> @undo do { let p = 5; return p }
19:33:27 <lambdabot>  Parse error at "}" (column 26)
19:33:31 <allbery_b> @undo do { let p = 5; return p; }
19:33:31 <lambdabot>  Parse error at ";" (column 25)
19:33:34 <allbery_b> hm
19:33:53 <allbery_b> anyway, translates roughly into let n = 5 in do ...
19:36:24 <nolrai>  @undo do { let p = 5; return p}
19:36:37 <nolrai> @undo do { let p = 5; return p}
19:36:37 <lambdabot>  Parse error at "}" (column 25)
19:37:24 <BMeph> Am I missing something, or was "swap" a dumb thing to leave out of the Prelude?
19:37:27 <Brian`> oh ; actually that ListUtils was in the same package -_-;
19:37:47 <Brian`> how come it cannot find a module in the same directory?
19:37:53 <Brian`> i'm using emacs + haskell
19:37:55 <smack_> @djinn (a, b) -> (b, a)
19:37:55 <lambdabot> f (a, b) = (b, a)
19:38:34 <allbery_b> doesn't seem like there's much point in defining a function for it
19:39:14 <allbery_b> (\(a,b) -> (b,a))
19:39:54 <BMeph> allberry_b: I use it a lot, especially when copying folks' cheap "use tuple pairs as Arrows" tricks.
19:40:01 <oerjan> allbery_b: nolrai: the let in do syntax is one place where you cannot leave out { } in one-liners
19:40:08 <Brian`> does anyone know how to load all the modules in a directory when using Emacs + Haskell mode?
19:40:10 <allbery_b> oh, right
19:40:11 <ddarius> @undo do { let { p = 5 }; return p }
19:40:12 <lambdabot> let { p = 5} in return p
19:40:26 <allbery_b>  @undo doesn't even try to get that syntax rule right, I keep forgetting
19:40:28 <oerjan> although the outer ones could be left out
19:40:33 <allbery_b> (it's undecidable inm general :)
19:40:40 <ricky_clarkson> @pl \(a,b) -> (b,a)
19:40:41 <lambdabot> uncurry (flip (,))
19:40:43 <oerjan> allbery_b: er, @undo is perfectly right there
19:41:02 <ricky_clarkson> We'd all much rather write uncurry (flip (,)) than swap, anyway.
19:41:32 <oerjan> since it is _possible_ that return does not end the let, it doesn't
19:41:33 <allbery_b> hm?  seems to be the magic "insert braces" rule applies
19:41:54 <oerjan> note that the insert braces rule only looks one token ahead
19:42:12 <ddarius> allbery_b: What's going on makes perfect sense.  You can have let p = 5; q = 6
19:42:21 <allbery_b> hm?  I thought H98 was rather .. more flexible than that
19:42:44 <ricky_clarkson> > let p=5; q=p+1; return q
19:42:45 <lambdabot>  Parse error at end of input
19:42:51 <ricky_clarkson> > let p=5; q=p+1 in return q
19:42:52 <lambdabot>   add an instance declaration for (Show (m t))
19:43:00 <ricky_clarkson> > let p=5; q=p+1 in return q :: IO Integer
19:43:01 <lambdabot>  <IO Integer>
19:43:29 <ricky_clarkson> > let p=q-1; q=p+1 in return q :: IO Integer
19:43:29 <lambdabot>  <IO Integer>
19:43:54 <ricky_clarkson> > let p=q-1; q=p+1 in q
19:43:55 <lambdabot>  Exception: <<loop>>
19:43:57 <ricky_clarkson> haha
19:44:11 <oerjan> > let p=5; q=p+1; return q = 5 in "whee"
19:44:11 <lambdabot>  "whee"
19:44:50 <ricky_clarkson> > let p=q-1; q=p+1 in q-p
19:44:51 <lambdabot>  Exception: <<loop>>
19:45:12 <ricky_clarkson> You mean you don't do algebra, lambdabot?
19:46:03 <oerjan> > (snd&&&fst) (1,2) -- Brian`
19:46:04 <lambdabot>  (2,1)
19:46:57 <ricky_clarkson> > (snd,fst) (1,2)
19:46:57 <lambdabot>  Couldn't match expected type `t1 -> t'
19:47:18 <paczesiowa> does anybody familiar with oleg's polyvariadic function build can tell me if it's possible (but don't tell me how to do it) to make that build function work even with no arguments at all (so not only build' 1 :: [Int] would work, but also build' :: [Int])
19:47:36 <ricky_clarkson> > (snd,fst) <$> [(1,2),(1,2)]
19:47:37 <lambdabot>  Couldn't match expected type `a -> b'
19:47:48 <ricky_clarkson> > map (snd,fst) [(1,2),(1,2)]
19:47:49 <lambdabot>  Couldn't match expected type `a -> b'
19:48:05 <oerjan> ricky_clarkson: (,) doesn't have the right kind for a Functor instance
19:49:37 <ricky_clarkson> > map (\f -> map f [(1,2),(1,2)]) [fst,snd]
19:49:38 <lambdabot>  [[1,1],[2,2]]
19:51:01 <ricky_clarkson> I don't know what I'm looking for.  It seems strange that (snd&&&fst) seems related to \(a,b) -> (b,a).
19:51:36 <oerjan> *weird thing
19:51:45 <oerjan> wrong channel
19:51:49 <mrd> @pl (fst&&&snd)
19:51:49 <lambdabot> fst &&& snd
19:52:35 <nolrai> @ty (fst &&& snd)
19:52:36 <lambdabot> forall a b. (a, b) -> (a, b)
19:52:52 <mrd> @djinn (a,b) -> (a,b)
19:52:52 <lambdabot> f a = a
19:52:58 <nolrai> what is &&&
19:53:10 <mrd> @index (&&&)
19:53:10 <lambdabot> Control.Arrow
19:53:12 <oerjan> :t (&&&)
19:53:13 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
19:53:16 <mrd> that
19:53:21 <oerjan> :t (&&&).(id.)
19:53:22 <lambdabot> forall c' b a. (a -> b) -> (a -> c') -> a -> (b, c')
19:53:52 <nolrai> ???
19:53:58 <mrd> @type ???
19:53:59 <lambdabot> parse error on input `???'
19:54:07 <nolrai> brain melting
19:54:08 <mrd> @type (???)
19:54:08 <lambdabot> Not in scope: `???'
19:54:25 <nolrai> sorry
19:54:28 <chessguy> @hoogle (???)
19:54:28 <lambdabot> Did you mean: (???)
19:54:28 <lambdabot> Prelude.undefined :: a
19:54:28 <lambdabot> Control.Monad.State.Class.get :: MonadState s m => m s
19:54:35 <oerjan> > (show &&& (+1)) 3
19:54:36 <lambdabot>  ("3",4)
19:54:42 <mrd> its easy actually.  just think of it as splitting an arrow input and applying two different functions
19:54:56 <mrd> 3 is the input, show and (+1) are the two different functions
19:55:08 <nolrai> oh that makkes sense
19:56:02 <ricky_clarkson> > let (???) a b="halp me i stuck in "++a++" ??? "++b in "type theory" ??? "aargh"
19:56:03 <lambdabot>  "halp me i stuck in type theory ??? aargh"
19:56:28 <shachaf> ricky_clarkson: Why strange?
19:57:17 <nolrai> >(fst&&&snd) (1,2)
19:57:25 <shachaf> nolrai: "> ".
19:57:29 <nolrai> > (fst&&&snd) (1,2)
19:57:30 <lambdabot>  (1,2)
19:57:44 <ricky_clarkson> I don't know.
19:57:46 <nolrai> > (snd&&&fst) (1,2)
19:57:46 <lambdabot>  (2,1)
19:58:11 <Brian`> :t isAlpha
19:58:12 <lambdabot> Char -> Bool
19:58:14 <Brian`> :t isSpace
19:58:15 <lambdabot> Char -> Bool
19:58:25 <shachaf> ricky_clarkson: (&&&) :: (a -> b) -> (a -> c) -> a -> (b,c) -- In this case.
19:59:21 <nolrai> > (snd&&&id) (1,2)
19:59:22 <lambdabot>  (2,(1,2))
20:00:51 * SamB_XP needs the name of a useful, non-turing-complete language
20:01:28 <nolrai> state machines?
20:01:29 <chessguy> SQL
20:01:42 <chessguy> i've heard some versions of SQL aren't turing compelte
20:02:13 <loupgaroublond> html
20:02:26 <chessguy> ah, good one. probably many markup language
20:02:26 <chessguy> s
20:02:35 <chessguy> XML
20:02:55 <shachaf> SamB_XP: Useful in what sense (and "language" in what sense)?
20:03:06 <ddarius> Hmm, is English Turing-complete?
20:03:10 <Korollary> regular expressions?
20:03:13 <loupgaroublond> there are things based on xml that might be turing complete though, xslt
20:03:37 <loupgaroublond> ddarius: i think most spoken languages are ;)
20:03:57 <nolrai> yes because you can describe the lambda calc in english.
20:04:32 <shachaf> loupgaroublond: You might as well say that ASCII is Turing-complete.
20:04:39 <SamB_XP> nothing like Epigram?
20:04:52 <paczesiowa> and if you write down that description you have turing complete html
20:05:00 <Korollary> simply typed lambda calculus
20:05:38 <loupgaroublond> shachaf: i theoretically could, but if i type up a text in english, do you recognize it as english or ascii?
20:05:49 <shachaf> loupgaroublond: I meant what you said about XSLT.
20:05:51 <nolrai> well no because ASCII dosent have a semantics.
20:06:34 <loupgaroublond> shachaf: ah, i thought about saying XML too, but then i realized there would be that one idiot that said what i said
20:07:11 * shachaf thought about saying the simply-typed lambda-calculus too.
20:07:24 <shachaf> But thenI realized I needed to know what is meant by "useful". :-)
20:07:27 <nolrai> thats not turin compleat?
20:07:42 <nolrai> *turing*
20:08:04 <sieni> turin <3
20:08:15 <sieni> although never been there
20:08:37 <nolrai> so your not turin compleat then.
20:08:51 <oerjan> let
20:08:59 <sieni> lete
20:09:11 <oerjan> let's just put a shroud over that typo
20:09:18 <Korollary> ew
20:09:41 <Korollary> is there anything else Turin is famous for?
20:10:05 <sorear> SamB_XP: C
20:10:11 <sieni> Korollary: "Cars"?
20:10:44 <ddarius> SamB_XP: You can view most theorem provers as programming languages.
20:11:06 <oerjan> last year's winter olympics
20:11:51 <Korollary> sieni: Yay. Fiat.
20:12:16 <chessguy> is Coq turing complete?
20:12:19 <oerjan> ooh, chocolate
20:12:36 <oerjan> "Turin is the birth place of solid chocolate"
20:12:39 <sorear> chessguy: yes and no
20:12:53 <sorear> chessguy: calculationally, it's not turing complete
20:13:11 <sorear> chessguy: but it is quite capable of describing turing machines, asmuchso as English
20:13:22 <Brian`> @src init
20:13:22 <lambdabot> init [x]    = []
20:13:22 <lambdabot> init (x:xs) = x : init xs
20:13:22 <lambdabot> init []     = undefined
20:14:09 <sorear> chessguy: incidentally, this is I think a good example of intuitionism in action - Coq (without custom axioms) cannot prove forall a: turing_machine, halts a \/ ~halts a
20:14:34 <sorear> chessguy: because that would contradict Turing's theorem under C-H
20:14:57 <sorear> chessguy: while that statement is an immediate consequence of the LEM (exclusive to *classical* logic)
20:16:00 <mrd> a good reason to be an intuitionist
20:16:01 <dfranke> I've never quite understood the motivation for not having the excluded middle as an axiom.  What sort of thing does it make unsound?
20:16:37 <ddarius> dfranke: It's doesn't make anything unsound.
20:17:02 <ddarius> dfranke: It's simply: more axioms => less applicable
20:17:16 <dfranke> ddarius: let me rephrase that.  To what does classical logic not apply when intuitionist logic does?
20:17:34 <ddarius> dfranke: Constructive logic.
20:17:40 <sieni> dfranke: e.g. proofs
20:17:57 <nolrai> is there a function that returns a list with one element replaced?\
20:18:12 <mrd> nolrai: map
20:18:18 <ddarius> nolrai: No, because that would be a bad idea.
20:18:30 <sieni> dfranke: if you interpret P as saying "P has a proof" and ~P as "~P has a proof" then unless the axiom system is complete then the law of the excluded middle does not hold
20:18:31 <Pseudonym> dfranke: Perhaps more importantly, the law of the excluded middle makes it harder to come up with efficient algorithms/theorem provers.
20:19:00 <nolrai> :ddarius but i need it.
20:19:01 <Pseudonym> That's the pragmatic answer.
20:19:10 <nolrai> ddarius: but i need it.
20:19:29 <ddarius> nolrai: It's easy to write.
20:19:33 <dibblego> > map (n -> if n == 1 then 42 else n) [1..10]
20:19:33 <lambdabot>  Parse error at "->" (column 8)
20:19:38 <dibblego> > map (\n -> if n == 1 then 42 else n) [1..10]
20:19:40 <lambdabot>  [42,2,3,4,5,6,7,8,9,10]
20:19:45 <ddarius> If you need it though, it suggests that you should be using a different data structure.
20:19:48 <dibblego> nolrai, ^
20:19:54 <nolrai> like what?
20:19:56 <ddarius> dibblego: That replaces all ones.
20:19:57 <dibblego> ?type if'
20:19:58 <lambdabot> Not in scope: `if''
20:20:21 <dibblego> > 42 : tail [1..10]
20:20:21 <lambdabot>  [42,2,3,4,5,6,7,8,9,10]
20:20:26 <ddarius> nolrai: Like a Map or an array or a hash table or something else.
20:20:55 <mrd> > listArray (1,10) [1..10] // [(5,11)]
20:20:56 <lambdabot>  array (1,10) [(1,1),(2,2),(3,3),(4,4),(5,11),(6,6),(7,7),(8,8),(9,9),(10,10)]
20:21:03 <dfranke> sieni: okay, I see.
20:21:19 <nolrai> so array would be better?
20:21:31 <sorear> Map
20:21:42 <ddarius> Probably not.  Even the array libraries don't offer a single element update function.
20:21:50 <oerjan> nolrai: btw if you are replacing _all_ elements of the list, then it is more efficient to do all at once (e.g. with map) than one at a time
20:21:53 <ddarius> (Again, because it would be a bad idea.)
20:22:13 <dfranke> sieni: so in in inuitionist logic you can interpret P as "|- P" whereas in classical logic you interpret it as "|= P" and therefore need to define |=
20:22:19 <mrd> > M.insert 5 11 (M.fromList (zip [1..10] [1..10]))
20:22:19 <lambdabot>  fromList [(1,1),(2,2),(3,3),(4,4),(5,11),(6,6),(7,7),(8,8),(9,9),(10,10)]
20:22:41 * sorear still has no idea of the difference
20:22:59 <mrd> sorear: because you are an intuitionist?
20:23:40 <nolrai> but i have a state that is a colection of identical items (like a ~100,  so tuples are out).
20:23:55 <sorear> mrd: No, I'm a finitist.  (A classical finitist, but given how many other things it implies, Â¬AoI probably implies LEM too)
20:24:29 <mrd> well LEM holds easily when working in finite universes =)
20:25:24 <sieni> dfranke: something like that, or rather that you have one model M and interpret P as "M|=P" or something.
20:26:09 <dons> this whole 'haskell slogan' thing is annoying.
20:26:20 <dons> why don't we just muscle up and state it as we see it?
20:26:28 <dons> "Haskell is a purely functional programming language that is used for any
20:26:28 <dons> kind of software development. It is a cutting edge programming language,
20:26:28 <dons> using powerful results from research, that allow rapid development of
20:26:28 <dons> robust, concise, correct software."
20:26:39 <dons> kick your arse, python.
20:26:48 * mrd cut himself on haskell today, ouch
20:26:55 <dons> sharp!
20:27:36 <dons> maybe marketing is not something that gets done by commitees very well
20:27:43 <sieni> haskell#
20:27:48 * chessguy wonders if he should feel guilty for getting a python book today
20:27:52 <chessguy> @slap sieni
20:27:52 <lambdabot> I don't perform such side effects on command!
20:27:57 <chessguy> hahaha
20:27:58 <dons> heh
20:28:24 <dfranke> chessguy: *gasp*.  Off to the gallows with you.
20:28:36 <chessguy> at least it was free1
20:28:49 <chessguy> actually, *they* were free, to be precise
20:28:50 * chessguy ducks
20:29:05 <ray> ask your doctor if haskell is right for you. side effects may include: NOTHING
20:29:19 <dons> hah
20:29:21 <dons> ray++
20:29:25 <chessguy> @remember ray ask your doctor if haskell is right for you. side effects may include: NOTHING
20:29:25 <lambdabot> Good to know.
20:29:34 <dons> the compile will smack you down!
20:29:37 <chessguy> @quote side
20:29:37 <lambdabot> ray says: ask your doctor if haskell is right for you. side effects may include: NOTHING
20:29:40 <chessguy> @quote side
20:29:41 <lambdabot> bos says: it looks like an interesting book, although i find the idea that software engineers might be ready for category theory this side of the 22nd century charmingly naive
20:33:01 <dfranke> I'd be happy just having them ready for statistics.
20:33:30 <dons> how about:
20:33:32 <dons> "Haskell is a purely functional programming language that is used for any
20:33:32 <dons> kind of software development. It is a cutting edge programming language,
20:33:32 <dons> using powerful results from research, that allows rapid development of
20:33:34 <dons> robust, concise, correct software. With strong support for integration
20:33:37 <dons> with other languages, built in concurrency, debuggers, profilers, rich
20:33:39 <dons> libraries and an active community, Haskell makes it easier to produce
20:33:42 <dons> flexible, maintainable, high quality software."
20:33:46 <chessguy> too long
20:34:12 <dons> its 6 words longer than the python one
20:34:16 <Pseudonym> "Haskell R0XX0Rz!"
20:34:23 <chessguy> then the python one is too long too
20:34:33 <dibblego> dons, where do you plan to put it?
20:34:48 <nolrai> i like "Haskell R0XX0Rz!".
20:34:50 <dons> dibblego: front page of haskell.org, instead of "static typing, monads, polymorph-whatsit"
20:35:09 <dibblego> dons, then, I think it's pretty close to perfect
20:35:13 <chessguy> it should focus on the specifics that set it apart from other languages, like purity, laziness, proof of corectness
20:35:24 <dons> good idea, chessguy
20:35:26 <thetallguy> dons: is Haskell used for real-time embedded systems?
20:35:27 <mrd> what proof
20:35:36 <Pseudonym> Robustness.
20:35:37 <gwern> dons: heck, that'd be better than the current one
20:35:39 <dons> thetallguy: nope.
20:35:40 <mrd> @faq is haskell used for real-time embedded systems?
20:35:40 <lambdabot> The answer is: Yes! Haskell can do that.
20:35:53 <chessguy> robustness is so vague
20:35:56 <dons> we don't actually want to talk about language features
20:35:57 <thetallguy> dons: s/any/many/?
20:36:04 <dons> that's what gets people bogged down in detail
20:36:04 <dibblego> then it will appeal only to Haskell nuts
20:36:09 <dons> thetallguy: ah well :)
20:36:09 <gwern> hm. for those who are logged out, do you see 'edit' links on haskell.org?
20:36:26 <dons> nope
20:36:31 <thetallguy> dons: actually, what the heck.  Marketing 101 says 'all'
20:36:35 <chessguy> oh, for a minute there, i thought you meant logged out of IRC
20:36:41 <dons> thetallguy: :)
20:36:42 <Pseudonym> chessguy: It's not vague, we just don't have a good numeric measure for it.
20:36:53 <chessguy> ...
20:36:55 <thetallguy> dons: If there's one thing I learned at Linspire...
20:36:57 <Pseudonym> It's the opposite of fragility, which is also not vague.
20:37:01 <ray> gwern: yeah
20:37:11 <dons> thetallguy: :)
20:37:15 <gwern> you do? hm. that's ugly. I should fix those
20:37:22 <chessguy> fine, but any language can claim to be "robust", and in some cases it could be true, depending on your precise definition
20:37:38 <thetallguy> dons: I still don't like the first line.  Not enough punch
20:37:39 <Pseudonym> chessguy: Languages aren't robust.  Programs are.
20:37:40 <ray> yeah, they just tellme to log in
20:37:45 <Pseudonym> Languages either encourage or discourage it.
20:37:52 <Pseudonym> Or are neutral on the topic.
20:37:57 <chessguy> Pseudonym, thanks for the lecture
20:38:16 <Pseudonym> You're welcome!
20:38:23 * Pseudonym gets back to work now
20:38:44 <dons> thetallguy: hmm. ok. thinking...
20:38:59 <ddarius> Programs aren't robust, mountains are.
20:39:47 <dfranke> I'd define robustness as the empirical probability when deployed in the real world that a program will encounter a condition that it can't handle gracefully.
20:39:53 <mrd> ddarius: mountains erode!
20:40:20 <chessguy> dfranke, then you get to define 'condition', 'handle', and 'gracefully', at least
20:40:49 <Pseudonym> Surely that's no less vague than the term "bug".
20:41:06 <dons> "Haskell is a powerful purely functional programming language used for
20:41:06 <dons> all kind of software development. It is a cutting edge language
20:41:06 <dons> combining powerful results from research allowing rapid development of
20:41:06 <dons> robust, concise, correct software. With strong support for integration
20:41:06 <dons> with other languages, built in concurrency, debuggers, profilers, rich
20:41:08 <dons> libraries and an active community, Haskell makes it easier to produce
20:41:10 <dfranke> chessguy: well, "handle" is easy, and the end-user gets to define "gracefully" for himself.
20:41:11 <dons> flexible, maintainable, high quality software."
20:41:19 <ddarius> mrd: They are still far more robust than programs.
20:41:23 <dibblego> is there a == for [] that ignores order (don't care if it is O(n^2))?
20:41:32 <dons> i think i used 'powerful' twice there. hmm
20:41:43 <ddarius> sort a == sort b
20:41:52 <dibblego> that requires Ord a
20:42:19 <mrd> ddarius: some programs can run for millions of years!
20:42:27 <dons> "It is a cutting edge language
20:42:27 <dons> combining results from research to achieve rapid development of
20:42:28 <dons> robust, concise, correct software."
20:42:30 <chessguy> dons, still doesn't make it immediately obvious why i should choose haskell over some other language
20:42:34 <thetallguy> Haskell is a purely functional programming language that allows rapid
20:42:34 <thetallguy> development of robust, concise, correct software.
20:42:50 <dons> nice.
20:43:01 <Pseudonym> I'd add "general-purpose" in there.
20:43:02 <chessguy> s/correct/provably-correct/
20:43:13 <dibblego> if it were immediately obvious that one should use Haskell, then...
20:43:17 <ddarius> dons: I have a more constructive issue: Who would be the best person to talk to about getting a potential venue for AmeroHaskell.
20:43:25 <Pseudonym> Haskell has LOTS of adjectives.
20:43:33 <ddarius> Haskell: The Programming Language You Should Use
20:43:34 <dons> haskell owns all your adjectives
20:43:51 <mrd> Haskell: Not just for Curry anymore
20:43:57 <dons> "Haskell is a powerful purely functional programming language that allows
20:43:57 <dons> rapid development of robust, concise, correct software. With strong
20:43:57 <dons> support for integration with other languages, built in concurrency,
20:43:57 <dons> debuggers, profilers, rich libraries and an active community, Haskell
20:43:57 <dons> makes it easier to produce flexible, maintainable, high quality
20:44:00 <dons> software."
20:44:11 <nolrai> nice
20:44:23 <ray> mrd: remember, normal people think curry is a food
20:44:39 <dons> no language features in the headline. results! results!
20:44:39 <gwern> dons: are you going to add that?
20:44:40 <mrd> good stuff too
20:44:54 <mrd> Haskell: Monad Monad Monad Monad Monad Monad Monad Monad Monad
20:44:58 <dons> i think we've reached a deadlock trying to get the mailing list 2000 to agree on 3 paragraphs.
20:45:01 <ddarius> Haskell: It's Better Than The Language You Are Currently Using
20:45:12 <dons> so yes, i'm thinking i'll just add that. and see if anyone complains enough
20:45:21 <mrd> ^ I think that's how most people probably see it
20:45:29 <dons> wikis are made by those who turn up.
20:45:36 <mrd> sounds good
20:45:40 <dons> thetallguy: what do you think, should we go with that?
20:45:53 <chessguy> still sounds like so much fluff to me, but what do i know
20:45:56 <dfranke> ddarius: that's problematic for people already using it :-)
20:45:58 <ray> then the slogan should be haskell: has other stuff besides monads
20:46:05 <ddarius> dons: If my hypothesis is correct, the only people who will even notice it (not that it's different, but that it is there at all) are the people debating what it should be
20:46:14 <dons> possible, ddarius :)
20:46:21 <ddarius> I really don't think it makes much difference at all what is in that paragraph.
20:46:30 <dons> i agree.
20:46:44 <clanehin> for my part, when I first visited haskell.org, I thought, "these people are completely full of themselves"
20:46:51 <chessguy> haha
20:46:54 <dons> clanehin: hah!
20:47:13 <dfranke> clanehin: better than other things we could be full of.
20:47:20 <ddarius> Haskell: We're Completely Full of Ourselves
20:47:30 <chessguy> dfranke, s/better/slightly better/
20:47:37 <chessguy> :)
20:48:15 <oerjan> @check \a -> null $ deleteFirstsBy (a::[Int]) (sort a)
20:48:17 <lambdabot>  Couldn't match expected type `a -> a -> Bool'
20:48:25 <oerjan> @check \a -> null $ deleteFirstsBy (==) (a::[Int]) (sort a)
20:48:26 <mrd> > (:[]) "Haskell: Monkeys love to eat it"
20:48:27 <lambdabot>  OK, passed 500 tests.
20:48:27 <lambdabot>  ["Haskell: Monkeys love to eat it"]
20:48:45 * SamB_XP tries to go back in time to bed
20:48:54 <nolrai> ?
20:49:38 <oerjan> @check \a b -> sort a == sort b ==> null (deleteFirstsBy (==) (a::[Int]) (b::[Int])
20:49:38 <lambdabot> Unbalanced parentheses
20:49:43 <oerjan> @check \a b -> sort a == sort b ==> null (deleteFirstsBy (==) (a::[Int]) (b::[Int]))
20:49:45 <lambdabot>  Arguments exhausted after 75 tests.
20:50:20 <dons> ok. we have a new slogan on the front page
20:50:24 <dons> phew, that wasn't so hard after all.
20:50:43 <oerjan> @check \a b -> null (deleteFirstsBy (==) (a::[Int]) (b::[Int])) && null (deleteFirstsBy (==) (b::[Int]) (a::[Int])) ==> sort a == sort b
20:50:44 <lambdabot>  Arguments exhausted after 75 tests.
20:50:56 <oerjan> dibblego: ^^
20:51:00 <dons> now ... how do we tell haskell-cafe@  ?
20:51:06 <thetallguy> dons: 'm working on something
20:51:12 <thetallguy> some more edits
20:51:18 <dibblego> oerjan, thanks
20:51:26 <dibblego> ?type deleteFirstsBy
20:51:27 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a] -> [a]
20:51:27 <gwern> dons: did you mean to remove the â‚¬ sign?
20:51:53 <dons> gwern: i'm not sure what you're referring to, so possibly no.
20:52:04 <dfranke> dons: don't.
20:52:10 <clanehin> maybe if we're going to have that many features, we should go for bullet points
20:52:11 <dons> gwern: ah, my editor
20:52:34 <dons> gwern: yeah, vim ascii-fied the page
20:53:03 <gwern> tsk.
20:53:20 * gwern edits. personally, I like ampersands. they look classy to me
20:53:39 <thetallguy> Remove 'powerful'.  Every software description written in the last 30 years has overused the word.
20:53:53 <nolrai> i can never draw them on CS tests though.
20:53:54 <gwern> thetallguy: how about 'advanced'?
20:54:09 <dons> gwern: i'm not sure '&' is wanted there
20:54:19 <ddarius> dons: You don't and see if anybody (besides gwern) even notices.
20:54:20 <dons> yeah, i like 'advanced'
20:54:44 <ddarius> I think we should make one for GHC too.  GHC: Makes Dinosaurs Happy
20:54:52 <roger`> eloquent too? :p
20:54:55 <dons> ddarius: 'You don't and see' ?
20:55:10 <dons> gwern: the & breaks up the final kick of that sentence
20:55:18 <ddarius> You don't tell Haskell-Cafe and then see if
20:55:21 <dfranke> hmm, I'm having a weird problem with Haddock.
20:55:28 <dons> ddarius: yeah, i'm inclined to leave it.
20:55:32 <dfranke> gen_contents_index is generated HTML with links to the wrong directory.
20:55:49 <dfranke> generating*
20:55:57 * ddarius suspects many people here don't know why I chose the GHC motto I did.
20:56:04 <dons> i know :)
20:56:11 <gwern> ddarius: I don't
20:56:19 <dfranke> they all point to /usr/local/share/doc/ghc/libraries/Foo.html instead of /usr/local/share/doc/ghc/libraries/package/Foo.html
20:56:22 <roger`> who are the dinosaurs?
20:56:56 <dons> gwern: 'an advanced'
20:57:04 <gwern> ok, so now december's announcements are up on the main page. onto to november
20:57:08 <dons> gwern: and no '&' on the final sentence. its crucial! :)
20:57:19 <gwern> dons: yes; 'an' goes before voewls and silent 'h's
20:57:39 <dons> gwern: ...
20:57:42 <gwern> dons: what does 'and' have over '&'?
20:57:48 <dons> ah good.
20:57:59 <dons> i don't want either
20:58:05 <dons> maintainable high quality software.
20:58:13 <dfranke> high-quality should be hyphenated.
20:58:37 <dons> the hypen if that's what people like.
20:58:37 * ddarius places the comma between "high" and "quality"
20:58:39 <gwern> 'Haskell makes it easier to produce flexible, maintainable high-quality software. '?
20:58:45 * dons slaps dfranke 
20:58:45 <ddarius> That will sell Haskell far better.
20:58:49 * dons slaps ddarius 
20:58:52 <dfranke> adjectives are right-associative by default.  You need a hyphen to override it :-)
20:59:04 <dons> heh
20:59:38 <clanehin> what about "native code generation" alongside debugger and profiler?  That's a big win for some people.
20:59:55 <gwern> 'native compilation'?
21:00:13 <mrd> aboriginal compilation?
21:00:18 <clanehin> erm, compiles to a native binary
21:00:29 <thetallguy> Haskell is a purely functional programming language that allows rapid development of robust, concise, correct software.  The ongoing product of nearly twenty years of collaboration among leading programming language researchers, Haskell is the essence of technology transfer; professional developers work with researchers to implement and apply the latest theoretical advancements directly to todays commercial computing problems.
21:00:44 <Pseudonym> I like that!
21:00:53 <Pseudonym> That's prose, that is.
21:01:05 <dfranke> full colon.
21:01:10 <dons> its elegant, but focuses too much on the process, not on the result
21:01:17 <dons> they don't care about technology transfer.
21:01:24 <thetallguy> dons:  who is they?
21:01:24 <clanehin> What about non-commercial problems?
21:01:37 <thetallguy> clanehin: good point
21:01:43 <ddarius> "They" is all the people who are going to breeze right by this paragraph anyway.
21:01:55 <dons> i think we're at the point we move text to an introduction page
21:01:56 <Pseudonym> True.
21:02:04 <gwern> 'Haskell is an advanced purely functional programming language; the product of nearly twenty years of cutting edge research, it allows rapid development of robust, concise, correct software. With strong support for integration with other languages, built-in concurrency, debuggers, profilers, ..' <-- maybe?
21:02:07 <dons> this is the front page summary, then switch to an introduction page that is up to date wrt. the language
21:02:15 <thetallguy> ddarius: heh
21:02:27 <Pseudonym> People who don't care about hard problems which need real solutions are VB script kiddies.
21:02:33 <thetallguy> gwern: that seems good.
21:02:36 <dons> so we feel the sustained effort to produce the language is useful to mention?
21:02:39 <dons> that its mature?
21:02:51 <Pseudonym> Yes, maturity is important.
21:02:53 <thetallguy> That's the main drawing point for me
21:02:56 <gwern> dons: it conveys a sense of History
21:02:59 * Pseudonym hasn't learned Ruby for similar reasons
21:03:02 <gwern> with a capital H
21:03:14 <dfranke> yes, I agree, that's an important point.
21:03:16 <dons> yes, there's gravitas there.
21:03:16 <thetallguy> In the 80s, everyone declared languages a finished topic.
21:03:18 <Pseudonym> Though one nit.
21:03:23 <Pseudonym> It's more than 20 years of research.
21:03:28 <dons> i'd not put a particular number
21:03:29 <Pseudonym> It's nearly 20 years of Haskell. :-)
21:03:35 <Pseudonym> I'm not sure I'd word it differently, though.
21:03:38 <dons> yeah. but 50 years of language research
21:03:42 <dons> or 150..
21:04:07 <gwern> well, you could argue the MLs evolved into haskell
21:04:11 <dons> "... the mature product of cutting edge research .. "
21:04:12 <dfranke> it's what sets us apart from toy research languages.
21:04:12 <thetallguy> puts 150 years of mathematics at your fingertips
21:04:27 <gwern> schemers might well say they have ~50 years of research, right, and it's true enough
21:04:37 <clanehin> I don't like, "it has debuggers and profilers," that sounds like you're buying a new house and "it has a bedroom and a kitchen!"
21:04:44 <ddarius> thetallguy: To the extent thath it puts any mathematics at your fingertips, it puts far, far more than 150 years
21:04:45 <Pseudonym> Yeah, schemers want to co-opt McCarthyism.
21:04:52 <dfranke> clanehin: if only that were the case.
21:05:06 <dons> we'll take Frege
21:05:18 <thetallguy> ddarius: shaky ground anyway
21:05:22 <clanehin> it makes it sound like we're excited that we have the basics in order
21:05:27 <dfranke> clanehin: Ruby has neither.
21:05:33 <ddarius> clanehin: We are
21:05:43 <thetallguy> there's a lot of math in the last 150 years that isn't included. ;-)
21:05:46 <dons> its all there. you start work now!
21:06:12 <gwern> ok, I'll try adding in 'the product' to see how it looks on the page
21:06:28 <gwern> but is it 'nearly' or 'more than'?
21:06:45 <thetallguy> bunches o' math
21:07:18 <dons> i'm not sure we have consensus on this, gwern
21:07:21 <dons> so i'd hold off.
21:07:31 <dons> ah well.
21:07:32 <gwern> (uh oh)
21:07:32 <Brian`> @hoogle IO [t] -> IO ()
21:07:32 <ddarius> thetallguy: It is far from clear what "including [some] math" means
21:07:33 <lambdabot> No matches, try a more general search
21:07:39 <dons> yeah, that looks ok.
21:07:51 <thetallguy> ddarius: yeah, I agree.
21:08:12 <dons> gwern: you're putting ; in our slogans now?
21:08:24 <dibblego> ?type fmap (const ())
21:08:26 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> f ()
21:08:28 <thetallguy> I put the ; in
21:08:35 <ddarius> Thousands of potential newbies are being turned away right now because of it.
21:08:39 <gwern> dons: aren't you the one who was going around saying monads are programmable semicolons? :)
21:08:44 <thetallguy> Separate the wheat from the chaff?
21:08:46 <thetallguy> lol
21:08:57 <dons> marketing 101 -- only use . and !
21:09:06 <dons> !
21:09:06 <dfranke> thetallguy: it should be a full colon.
21:09:21 <clanehin> dons: and ? if it refers to the competition
21:09:30 <dons> :)
21:09:33 <thetallguy> Should be a separate sentence, I just couldn't figure out how to do it.
21:09:35 <dfranke> and eh, programming *language*
21:09:45 <dfranke> "Haskell is an advanced purely functional programming"
21:09:59 <dons> ok. no more edits.
21:10:04 <gwern> I wonder if 'pure' wouldn't sound better
21:10:28 <gwern> as in 'pure functional programming language'
21:10:42 <dons> long history of the current phrasing
21:10:59 <thetallguy> I have to get back to writing my own blurb for the Chalmers thing anyway
21:11:17 <thetallguy> Any of these are an improvement over what was read at CUFP
21:11:28 <dons> yep.
21:11:32 <dons> i'm happy now with it.
21:11:48 <thetallguy> That's 'now happy'
21:11:52 <thetallguy> :-)
21:12:43 <dons> i'm happy now.
21:12:44 <dons> !
21:13:07 <thetallguy> Editing tweaks diesel on.
21:13:09 <dfranke> I think he's right, actually.  It should be either "I'm now happy with it" or "I'm happy with it now"
21:13:26 <dons> definitely.
21:13:31 <Pseudonym> Actually, I think he left out a comma.
21:13:36 <Pseudonym> "I'm happy now, with it."
21:13:37 <thetallguy> And lord knows, we wouldn't want bad grammar in #haskell.
21:13:42 <Pseudonym> dons is always with it.
21:14:29 <dons> i can dig it.
21:14:47 <thetallguy> Is that a Shaft reference?
21:15:02 <Pseudonym> Damn right.
21:15:13 <thetallguy> They say that cat dons is a bad muthah...
21:15:26 <dons> watch your mouth!
21:15:42 <thetallguy> But I'm talkin' 'bout dons!
21:16:02 <dons> i can dig it.
21:16:03 <gwern> oh, that's cool then
21:16:32 <dons> i think that song fits lambdabot well.
21:16:47 <gwern> yay, News is now up to date
21:16:52 <dons> she's a complicated bot, and no one understands her.
21:16:59 <bparkis> what's the name of that standard form in logic and ai, the standard form of a simple implication--where you have like ~a v ~b v ~c v d
21:17:01 <gwern> now to templateize the main page
21:17:14 <Pseudonym> ?faq Who's the cat that won't cop out?
21:17:14 <lambdabot> The answer is: Yes! Haskell can do that.
21:17:22 <dons> gwern: so those news things are generated from a script.
21:17:26 <dons> you just fixed some typos?
21:17:53 <glguy> ?hoogle >=>
21:17:54 <lambdabot> Control.Monad.(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
21:17:54 <gwern> dons: they are? then how did it apparently miss so many?
21:18:26 <dons> gwern: hmm?
21:18:35 <dons> its not up to date...
21:18:45 <gwern> well, no xmonads for example
21:18:47 <gwern> no darcs
21:18:48 <dons> but each time a HWN comes out, that page gets regenerated
21:18:52 <gwern> neither of mine
21:18:57 <gwern> and a number of others
21:19:09 <dons> anyway, the point is, your edits to the news feed would get lost
21:19:20 <dons> but at least i know you did them, so i can hack the script a bit to sync with the changes
21:19:29 <gwern> http://haskell.org/haskellwiki/?title=News&diff=17368&oldid=16806
21:19:33 <ddarius> bparkis: Disjunctive normal form?
21:19:46 <nolrai> @src (>=>)
21:19:46 <lambdabot> Source not found. Take a stress pill and think things over.
21:20:16 <bparkis> no ddarius it's more restrictive than that
21:20:27 <bparkis> it has to be of the form ~x_1 v ~x_2 v ... v ~x_n v y
21:20:54 <bparkis> i.e. the translation of x_1 n x_2 n ... x_n -> y
21:21:06 <gwern> dons: so I suppose I shouldn't add in Haskell-mode 2.4 to News then?
21:21:33 <dons> gwern: i wouldn't, it'll just get clobbered. its good to have the major things, and i guess this means it about time for another hwn anyway
21:21:45 <bparkis> it's used in theorem proving systems, inference is easier when you have it
21:21:49 <dons> most of the new things are on the hackage rss feed, btw.
21:23:27 <dons> yay, thanks guys. gwern, thetallguy, Pseudonym, ddarius, clanehin et al. we have a much nicer slogan now.
21:23:52 <dfranke> bparkis: a Horn Sentence.
21:23:55 <dons> small groups can be more agile than 2000 people on a mailing list. who'd have thought.
21:24:06 <gwern> dons: what? absurd!
21:24:20 <gwern> (surely 2000 minds would be more effective than scare a dozen...)
21:24:24 <gwern> *scarce
21:24:42 <bparkis> oh, that's it thanks dfranke
21:25:00 <dons> i'm glad to see the erlang page looks worse :)
21:25:11 <dons> "Caml is a general-purpose programming language, designed with program safety and reliability in mind. It is very expressive, yet easy to learn and use. Caml supports functional, imperative, and object-oriented programming styles. It has been developed and distributed by INRIA, France's national research institute for computer science, since 1985"
21:25:25 <dons> i bet they changed that after cufp too.
21:26:06 <gwern> (you know, I' suggest we add something about being easy to learn, but I just can't take it seriously)
21:26:15 <dons> heh
21:26:21 <ddarius> I helped?
21:26:45 <dons> the python thing about 'easy to learn' only means 'easy to learn if you know something like python'
21:26:49 <dons> so haskell's also easy to learn
21:26:54 <dons> if you know clean
21:26:58 <gwern> 'if you know epigram'
21:27:04 <ddarius> Haskell: Easy to Learn if You Know Haskell
21:27:05 <gwern> 'if you know sml'
21:27:13 <dfranke> gwern: nope.
21:27:14 <Pseudonym> Haskell: Even easier than SML.
21:27:25 <dons> And twice as fast as Epigram
21:27:26 <gwern> 'if you know the polymorphic lambda calculi'
21:27:31 <dfranke> gwern: I knew OCaml before Haskell, and that didn't make Haskell easy.
21:27:53 <ddarius> dfranke: No one said O'Caml.
21:27:54 <gwern> dons: only twice? I'm impressed by epigram then
21:28:21 <dons> oh, twice as easy as epigram, and twice as fast as SML. that makes more sense
21:33:06 <dons> nice little thing on doing things, versus talking about doing things, http://www.codinghorror.com/blog/archives/001017.html
21:33:07 <lambdabot> Title: Coding Horror: Are You a Doer or a Talker?
21:33:10 <Pseudonym> All the syntactic sugar and twice the caffeine.
21:33:22 <dons> mmm.
21:33:39 <dons> only pure sugar! no high fructose corn syrup!
21:34:02 <gwern> I like brown sugar. does that make me racist?
21:34:14 <dons> against white sugar. yes.
21:34:36 <thoughtpolice> this is for good reason though. brown sugar is awesome.
21:34:51 <gwern> http://haskell.org/haskellwiki/User:Gwern/tmp <-- is there anything visually wrong there?
21:35:31 <nolrai> > nub [[1..n] | n <- [1..]]
21:35:33 <lambdabot>  [[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],[1,2,...
21:35:39 <dons> gwern: it looks right, i think
21:35:44 <nolrai> > nub . conat [[1..n] | n <- [1..]]
21:35:44 <lambdabot>   Not in scope: `conat'
21:35:53 <nolrai> > nub $ concat [[1..n] | n <- [1..]]
21:35:55 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
21:36:16 <ddarius> dons: Who best to talk to about a venue for AmeroHaskell?
21:36:41 <dons> ddarius: ah right. i wanted to get back to that. thanks.
21:36:45 <dons> so, in portland?
21:36:58 <dons> i think we want to get hold of someone at a university
21:37:14 <dons> since they've typically got everything available, and space
21:39:10 <tennin> Tim Sheard?
21:40:31 <gwern> dons: I've moved [[News]] to [[Template:Main/News]], so update that script of yours
21:41:23 <dons> gwern: will do.
21:42:10 <gwern> (in case anyone is wondering, there are considerable benefits to templatizing the main page related to edit conflicts, simpler edit history, modularity, and interaction with page protection)
21:43:39 <dons> looks fine, gwern
21:44:29 <dons> ok. scary url. http://img.photobucket.com/albums/v108/Calantorntain/donsguns.jpg
21:45:55 <ddarius> Hey!  I'll be in Indianapolis in the near future.  Maybe I'll drop in.
21:46:12 <glguy> dons: you look older in that picture
21:46:43 <dons> you think? must be the lighting.
21:46:44 <gwern> I thought dons was a young fellow. I feel betrayed
21:46:55 <ddarius> Betrayed by your own prejudices?
21:47:04 <ddarius> @users
21:47:04 <lambdabot> Maximum users seen in #haskell: 428, currently: 378 (88.3%), active: 14 (3.7%)
21:47:34 <dons> we oldies can sell guns as good as anyone .. ha ha ha!
21:47:45 <gwern> ok... the main page still looks normal, good
21:48:16 <dons> glguy: the events box is not centered now, but maybe it never was?
21:48:25 <dons> no, i think it used to be centered
21:48:28 <andyjgill> score "dons" ==> You have completed 1% of your adventure "becoming an american citizen". Please press n to continue.
21:48:30 <dons> gwern: ^
21:48:36 <dons> andyjgill: hah!
21:48:37 <glguy> events?
21:48:45 <dons> glguy: tab completion strikes.
21:50:10 <gwern> dons: oh, I see what you mean. the others are indented from the bullets
21:52:32 <gwern> dons: ok, how's that indentation?
21:53:07 <dons> gwern: ok. that looks alright. note the headings in the right column aren't in from the edge though
21:53:26 <dons> there's no gap between the edge of the right grey box and the text
21:54:11 * gwern slays the vermicious edit links
21:56:19 <dmwit> ?all-dicts vermicious
21:56:20 <lambdabot> *** "Vermicious" gcide "The Collaborative International Dictionary of English v.0.48"
21:56:20 <lambdabot> Vermicious \Ver*mi"cious\, a. [L. vermis a worm.]
21:56:20 <lambdabot>    Of or pertaining to worms; wormy.
21:56:20 <lambdabot>    [1913 Webster]
21:56:41 <gwern> dmwit: have you never heard tell of the Vermicious Knids?
21:56:52 <dmwit> heh
21:56:59 <dmwit> I didn't know what it meant then, either. ;-)
21:57:20 <gwern> you didn't really need to
21:57:30 <dons> like vermicelli :)
21:57:31 <gwern> I mean, 'vermicious' kind of telegraphs its meaning
21:57:39 <dons> yeah
21:57:51 <gwern> do you guys like the section numbering?
21:57:59 <dons> nope. not on the front page.
21:58:02 <dons> everywhere else: yes
21:58:07 * gwern will investigat tehn
22:01:41 <FauxFaux> What's the best way to remove new-lines from a string? Random code I found on google appears to fail if fed "\n" for no reasons that I understand, and I can't work out how to get text.string.subregex to match against the whole input as apposed to lines. :)
22:02:55 <thoughtpolice> > (concat . intersperse " " . lines) "hello\nworld"
22:02:57 <lambdabot>  "hello world"
22:03:02 <thoughtpolice> ?
22:03:52 <sieni> > filter (/='\n') "asd\nf"
22:03:52 <lambdabot>  "asdf"
22:04:05 <ddarius> > (unlines . lines) "hello\nworld"
22:04:06 <lambdabot>  "hello\nworld\n"
22:04:13 <ddarius> > (unwords . lines) "hello\nworld"
22:04:13 <jcreigh> okay, so I was wondering what the "Endo" type is, the docs have this to say: "The monoid of endomorphisms under composition." Oh, *of course*, silly me. Makes perfect sense now. (I guess I'm supposed to read the Monoid paper?)
22:04:13 <lambdabot>  "hello world"
22:04:28 <FauxFaux> Okay, okay, I get it. Thanks everyone. :)
22:04:57 <ddarius> FauxFaux: It's not clear what you want exactly.
22:05:11 <FauxFaux> All of the above.
22:05:50 <sieni> ddarius: well, I thought that removing newlines is just that: removing newlines
22:05:50 <ddarius> > map (\x -> if x == '\n' then ' ' else x) "hello   \n world \n\n\n"
22:05:52 <lambdabot>  "hello     world    "
22:06:16 <glguy> replacing newlines /= removing newlines
22:06:30 <ddarius> jcreigh: If there is a paper linked, sure, read it.
22:07:00 <sjanssen> jcreigh: the source is the clearest explanation
22:07:15 <jcreigh> ddarius: except I just noticed the link in the docs is a 404. no matter, Google knows all.
22:07:16 <ddarius> jcreigh: That said, the type of Endo and the definition makes it pretty clear what it is.
22:07:32 <ddarius> Or just read the source as sjanssen suggests.  Monoids are very simple things.
22:07:57 <gwern> ok, everyone look at haskell.org now
22:08:04 <gwern> good, bad?
22:08:13 <dons> gwern: so now you're centering the titles?
22:08:21 <sieni> > concatMap (\x -> if x == '\n' then "my big fat string" else "\n") "yip\nyap\n"
22:08:21 <lambdabot>  "\n\n\nmy big fat string\n\n\nmy big fat string"
22:08:23 <dons> they're indented too much.
22:08:27 <gwern> dons: yes, I'm avoiding the whole section issue
22:08:28 <sieni> oops
22:08:46 <sieni> > concatMap (\x -> if x == '\n' then "my big fat string" else [x]) "yip\nyap\n"
22:08:46 <gwern> they are not technically centered, just indented one
22:08:47 <lambdabot>  "yipmy big fat stringyapmy big fat string"
22:08:48 <dmwit> The blank space in the middle is a bit much on (this) big screen.
22:08:57 <sjanssen> what is this 'Search haskell.org' thing?
22:09:16 <sjanssen> do we really need to provide advertisements for this company?
22:09:17 <dons> i don't know. it just appeared a week ago. looks like  a google search
22:09:25 <dons> but i always just use our search engine..
22:09:30 <dons> the one on the wiki.
22:09:33 <dons> which works just fine.
22:09:41 <sjanssen> I always have trouble with it
22:09:54 <dons> the search thing is too prominent.
22:10:05 <sjanssen> a google search link is quite handy, but why is it provided by millstream.com
22:10:23 <sjanssen> "This search page provided for the Haskell community by Millstream Software."
22:10:23 <gwern> '
22:10:24 <gwern> Millstream Software, established in 1993, develops Windows software using the Delphi programming language. Specialist in control valve sizing and selection software for the valve manufacturing and process control industries.'
22:10:29 <dons> yeah, it should just point to, http://www.google.com/cse?cx=014102838545582129901%3Anhonl7a8bw8&q=&sa=Search
22:10:30 <lambdabot> Title: - Google Search, http://tinyurl.com/37gvwk
22:10:41 <dons> so they're just putting a page in front of that.
22:11:32 <sjanssen> yeah, they are.  What the crap?
22:12:09 <gwern> dons: is the indentation a problem? would you prefer not indented at all?
22:12:31 <dons> i think the before-indented looked better
22:14:05 <gwern> ok. now?
22:15:16 <dons> well, its still not as nice as it was before the template. spacing is squished
22:15:57 <gwern> spacing how?
22:15:58 <jcreigh> hmm, is Haddock crippled in some way? I keep seeing #ifndef __HADDOCK__ directives.
22:15:59 <dons> sjanssen: i think we should just point to the custom search.
22:16:08 <dons> gwern: see in the events panel. there's no gaps between columns
22:16:24 <gwern> oh. just in events?
22:17:14 <gwern> hm. I've restored the original table that was using, and it looks the same to me
22:17:28 <dons> ok.
22:18:57 <gwern> if there are no other problems with it, I guess I'll call it a night
22:20:28 <dons> yep, looks fine.
22:22:17 <dons> sjanssen: made it a direct link.
22:25:43 <conal> jcreigh: Haddock used to be way behind ghc's language extensions, and hence the ifndef.  Now haddock 2.0 is in sync with ghc.
22:31:02 <alogia> does anyone know how one would go about combining StateT functions and State functions in evalStateT and get the state to thread through?
22:31:51 <sarehu_> explain again?
22:33:26 <alogia> I have a few functions of type State Config () and a few of type StateT Config IO () and I would like to get the Config to pass through both, if that makes sense...
22:34:49 <sarehu> you have runState :: State s a -> s -> (a,s), and runStateT :: StateT s m a -> s -> m (a,s), right?
22:35:09 <sarehu> or maybe (s,a) instead of (a,s)
22:35:14 <sarehu> :t runState
22:35:15 <lambdabot> forall s a. State s a -> s -> (a, s)
22:35:19 <sarehu> nevermind
22:36:01 <alogia> i was using evalStateT.
22:36:04 <sarehu> alogia: is there any particular order you want them?
22:36:39 <sarehu> generally speaking, you can use runState and runStateT to do what you want
22:37:18 <sarehu> do { let (a,config') = runState m config ; (a,config'') <- runStateT m2 config' ; ... }
22:38:14 <sjanssen> alogia: probably the best solution here is to change your function types to "MonadState Config m => m ()" rather than "State Config ()"
22:38:30 <alogia> hmm, ok
22:38:35 <sjanssen> similarly for the IO functions
22:38:55 <alogia> yeah that make sense. thanks
22:49:52 <alogia> so I don't have ask you all, do you know where one could read up on some of the intricacies of combining monads? Something between PhD thesis and the info on haskell.org?
22:50:19 <alogia> that is the one part of haskell that gives me the most trouble...
22:50:55 <dons> perhaps the docs in mtl? or maybe some exmaples (e.g. xmonad ?)
22:53:43 <alogia> the docs for mlt look pretty sparse, but I will check out xmonad.
22:58:14 <sjanssen> alogia: have you looked at "All about monads"?
22:58:32 <sjanssen> it's a pretty nice tour of the common monads
22:59:50 <Spark> there should be a magazine about monads
22:59:53 <alogia> yeah, got through that, but still I am always finding that I don't quite know what I need for what I am doing
23:00:13 <Spark> like "tractors weekly"
23:00:21 <Spark> so that it can be a guest publication in have i got news for you
23:02:34 <alogia> heh, I don't think you would run out of subject matter very quickly....
23:03:06 <hpaste>  Paczesiowa pasted "polyvariadic sum" at http://hpaste.org/4392
23:03:18 <paczesiowa> can someone explain to me that type error?
23:06:49 <sjanssen> the type signature says that you're trying to construct a list that isn't heterogenous
23:07:13 <sjanssen> you've generalized to all Num, but there aren't enough constraints to say that they're the *same* Num
23:07:56 <Kirakishou> :t liftIO2
23:07:58 <lambdabot> Not in scope: `liftIO2'
23:08:01 <Kirakishou> hmm
23:08:05 <Kirakishou> :t liftIO
23:08:06 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
23:08:34 <Kirakishou> would liftIO still work if the IO monad is wrapped in three layers of monad tranformers?
23:08:41 <sjanssen> yes
23:08:50 <Kirakishou> oh goody.
23:08:53 <sjanssen> assuming all the transformers have the necessary instances for MonadIO
23:09:01 <Kirakishou> oh boy.
23:09:02 <sjanssen> (a given if you're working with the mtl)
23:09:09 <Kirakishou> ah, good.
23:09:24 <Kirakishou> I'm just using ErrorT, ReaderT, and ContT
23:09:37 <paczesiowa> sjanssen: where should I put that constraint? in snd instance declaration?
23:09:56 <sjanssen> paczesiowa: I don't think you can do it with this class declaration, I think you need an MPTC
23:10:58 <paczesiowa> sjanssen: thanks
23:13:09 <paczesiowa> is it possible to translate every mptc to regular haskell98 type class?
23:13:40 <paczesiowa> just curious if it's syntactic sugar or something new
23:14:49 <sjanssen> something new
23:39:39 <sannysanoff> @hoogle Session
23:39:40 <lambdabot> No matches found
23:40:00 <nolrai> @ty maybe
23:40:07 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
23:42:40 <nolrai> @pl f c = lookup c rules >> run
23:42:41 <lambdabot> f = (>> run) . flip lookup rules
23:43:17 <nolrai> wow a pointless exp thats not bad
23:58:24 <paczesiowa> context is everything on the lefthand side of "=>" in type signature?
23:58:57 <sjanssen> yes
23:59:40 <Kirakishou> for the Reader monad, can I put an environment INTO it manually?
23:59:53 <sjanssen> Kirakishou: no
