00:00:53 <JohnDoeKyrgyz> Hello all, I'm wondering if anyone can help answer my newbie question.
00:01:10 <sarehu> don't ask to ask
00:01:18 <JohnDoeKyrgyz> My implementation of splitAt is not working as expected:
00:01:19 <JohnDoeKyrgyz> splitAt' :: (Num a, Ord a) => a -> [b] -> ([b],[c])
00:01:19 <JohnDoeKyrgyz> splitAt' 0 x = (x,[])
00:01:19 <JohnDoeKyrgyz> splitAt' i (x:xs) |
00:01:19 <JohnDoeKyrgyz>  i > 0 = let (left, right) = splitAt' (i - 1) xs
00:01:19 <JohnDoeKyrgyz>   in (x : left, right)
00:01:20 <JohnDoeKyrgyz> splitAt' _ _ = error "index must be greater than 0"
00:01:50 <JohnDoeKyrgyz> It always returns ([input list],[])
00:01:57 <mauke> o rly?
00:02:36 <mauke> that's pretty much the only thing it can do with that type
00:03:16 <sarehu> JohnDoeKyrgyz: without looking at your code, what do you think   splitAt 1 [10,11,12,13]    should return?
00:03:35 <sarehu> JohnDoeKyrgyz: and then what about   splitAt 0 [10,11,12,13]?
00:03:43 <sarehu> and then what does your code return in the zero case?
00:05:33 <JohnDoeKyrgyz> The zero case should be ([input list],[])
00:05:51 <sarehu> > splitAt 0 [10,11,12,13]
00:05:54 <lambdabot>  ([],[10,11,12,13])
00:06:49 <JohnDoeKyrgyz> I guess the problem is that I don't understand why the type is not splitAt' :: (Num i, Ord i) => a -> [b] -> ([b],[b])
00:07:02 <sarehu> well it should e
00:07:13 <sarehu> except with (Num a, Ord a), not i...
00:07:16 <sarehu> :t splitAt
00:07:17 <lambdabot> forall a. Int -> [a] -> ([a], [a])
00:07:46 <sarehu> :t genericSplitAt
00:07:47 <lambdabot> forall i b. (Integral i) => i -> [b] -> ([b], [b])
00:08:29 <mauke> JohnDoeKyrgyz: because you always return [] for the second list
00:08:37 <mauke> and [] has any list type
00:08:49 <bench``> any one has a haxml example to convert a haskell data type to xml?
00:09:14 <JohnDoeKyrgyz> thanks, that makes sense
00:12:24 <alexj> @seen lemmih
00:12:25 <lambdabot> lemmih is in #haskell. I don't know when lemmih last spoke.
00:15:19 <roger`> bench``: try looking in the HAppS example repo
00:15:42 <bench``> roger, thanks
00:20:48 <JohnDoeKyrgyz> Okay, I see how making the zero case be splitAt' 0 x = ([],x) causes the type of the function to become (Num a, Ord a) => a -> [b] -> ([b],[b]), which works.
00:21:38 <wy> I feel a little limited that the type classes themselves can't be used as types
00:21:39 <JohnDoeKyrgyz> Just out of curiosity, what would I have to do to write this function such that my zero case would return (x,[]) and it would still work?
00:22:00 <mauke> switch the meaning of left and right
00:23:40 <JohnDoeKyrgyz> mauke thanks for your help! Its beginning to make sense now.
00:23:55 <mauke> heh, cool
00:25:30 <wy> If we have some operation that is common to several different types, and we want to make a heterogeneous list that contain those types, and invoke those operations, what do we do?
00:26:13 <wy> @users
00:26:13 <lambdabot> Maximum users seen in #haskell: 434, currently: 388 (89.4%), active: 10 (2.6%)
00:26:52 <mauke> wy: existential types
00:27:04 <mauke> or a new data type with a constructor for every type
00:28:34 <wy> mauke: This type can be inferred, because they must have some classes in common. Just take the intersection of their classes and make an anonymous type, is that more convenient?
00:28:56 <mauke> huh?
00:29:04 <mauke> what's an anonymous type?
00:29:04 <wy> Or is that called existential type?
00:29:48 <mauke> data Wrap = forall a. (SomeClass a) => Wrap a
00:29:59 <mauke> then you can use [Wrap]
00:31:23 <wy> That's the same thing I was thinking about
00:31:53 <pjd> http://haskell.org/haskellwiki/Existential_type
00:34:23 <wy> No... It's not the same
00:34:35 <wy> I guess I'm thinking about intersection types
00:37:38 <wy> For example [ 2.1, 'a'] might be inferred to have type t, where t is instance of Enum, Eq, Ord, Read, Show, because those are what Double and Char have in common.
00:38:04 <mauke> :t [2.1, 'a']
00:38:09 <lambdabot>     No instance for (Fractional Char)
00:38:09 <lambdabot>       arising from the literal `2.1' at <interactive>:1:1-3
00:38:09 <lambdabot>     Possible fix: add an instance declaration for (Fractional Char)
00:42:40 <wy> It can't be typed because we assumed that we need to use all of their properties. But we only need something they have in common
00:44:45 <wy> Existential type will ask you to define a new type that contains all the types with the specified class.
00:45:42 <wy> But actually we don't need to give it a name, and we don't even need to know what operations we expect them to be able to support.
00:46:23 <wy> If we put them together, that means we are going to do something they support in common.
00:46:46 <wy> So just take the intersection of the classes and make a new type...
00:51:31 <OceanSpray> oh boy
00:51:53 <OceanSpray> the ackermann function I wrote in my interpreter is still going at it
00:51:58 <OceanSpray> ...on (ack 1 2)
00:52:24 <OceanSpray> I have a feeling that either I wrote the function wrong, or there's something extremely inefficient with my interpreter.
00:55:22 <OceanSpray> oh wait, it works now
00:55:43 <OceanSpray> hey, it's reasonably fast.
00:57:43 <OceanSpray> no, it's not
00:57:52 <OceanSpray> very much slower than guile.
00:58:29 <nolrai> what is the ackermann function again?
01:00:06 <OceanSpray> http://en.wikipedia.org/wiki/Ackermann_function
01:00:07 <lambdabot> Title: Ackermann function - Wikipedia, the free encyclopedia
01:00:28 <nolrai> thanks.
01:00:49 <OceanSpray> wow
01:00:57 <OceanSpray> (ack 4 1) is taking forever
01:02:38 <OceanSpray> guile> (ack 4 1)
01:02:38 <OceanSpray> ERROR: Stack overflow
01:02:40 <OceanSpray> lol
01:03:21 <roger`> people actually use guile?
01:03:59 <OceanSpray> It's the Scheme implementation that's "just there."
01:04:16 <roger`> ah yes, I keep forgetting that it's used in gnucash too
01:04:47 <OceanSpray> it came as a dependency of lilypond
01:04:56 <OceanSpray> and I don't want to install PLT or anything,
01:05:02 <OceanSpray> so whatever
01:05:09 <roger`> ah, I always have PLT hanging around
01:14:37 <OceanSpray> the amount of time needed to calculate each increasing ack is exponential.
01:15:11 <OceanSpray> from (ack 3 1) to (ack 3 6), the change in time needed is dramatic.
01:27:45 <quicksilver> OceanSpray: it's super-exponential isn't it?
01:27:59 <quicksilver> OceanSpray: because exponential time is still primitive recursive time
01:28:04 * quicksilver looks doubtful
01:28:30 <OceanSpray> For m â‰¥ 4, however, it grows much more quickly; even A(4, 2) is about 2Ã—1019728, and the decimal expansion of A(4, 3) is very large by any typical measure.
01:28:40 <OceanSpray> ...according to wikipedia
01:28:50 <OceanSpray> yeah, it definitely grows very fast
01:29:12 <OceanSpray> (ack 4 1) had to be aborted since it took such a long time.
01:29:54 <quicksilver> right. ack grows faster than any primitive recursive function
01:30:01 <quicksilver> and exponential is primitive recursive.
01:30:19 <quicksilver> although, a project like \x -> ack (3,x) maybe doesn't
01:34:49 <shivernz> it looks like my package manager only offers up to 6.6.1 of ghc. is it worthwhile getting the latest?
01:35:25 <Taejo> shivernz: depends what you're doing
01:35:51 <shivernz> well... learning reallly. dont really want to learn things that have been depreciated though
01:35:58 <quicksilver> I'd stick with 6.6.1
01:36:06 <quicksilver> many libraries have not yet been updated to 6.8
01:36:15 <quicksilver> 6.8 could cause you pain, give it a month or so :)
01:36:22 <shivernz> ah ok
01:36:32 <shivernz> probably why portage still doesn't have the latest then
01:36:35 <shivernz> thanks
01:37:22 <quicksilver> I think people are working on overlays for 6.8
01:37:25 <quicksilver> people around here
01:37:33 <quicksilver> but I'm not a gentooer myself, and I can't remember who
01:39:32 <therp> shivernz: you might want to join #gentoo-haskell
01:40:00 <shivernz> therp, thanks :)
01:40:15 <therp> and as far as I know we have ghc-6.8 tested quite well in the gentoo overlays
01:40:57 <quicksilver> therp: but that doesn't help him with the fact that lots of libraries aren't ported yet :)
01:41:01 <quicksilver> dons: ping?
01:41:17 <shivernz> therp, sounds good. haven't needed to venture into the world of overlays as yet... so i'll probably hold out for a while still
01:41:58 <therp> shivernz: emerge layman; layman -a haskell;
01:42:13 <therp> shivernz: that's it
01:43:02 <shivernz> therp, will that leave me with both 6.8.2 and 6.6.1, or do both occupy the same slot?
01:44:59 <therp> shivernz: I think parallel installation isn't possible, so they occupy the same slot (no slots in the ghc ebuild)
01:47:09 <shivernz> therp, may give it a go. ill see how i actually get along doing just simple coding in it. still very much a noob so i dont technically "need" it yet :)
01:48:49 <therp> shivernz: then I'd stick with ghc-6.6.1 at the moment.
01:58:15 <xpika> hello #haskell!
02:21:28 <bringert> dcoutts: were you looking for me?
02:21:49 <dcoutts> bringert: oh, yeah, about cabal-install
02:21:51 <dcoutts> :-)
02:22:12 <dcoutts> much new goodness, but lots of stuff to test to make sure I've not broken things
02:22:36 <quicksilver> if you haven't broken at least some things, you weren't being ambitious enough!
02:22:44 <dcoutts> heh heh
02:23:34 <bringert> dcoutts: I tested some basic things with your patches. seems to work fine
02:24:14 <bringert> dcoutts: why not just push them to cabal head and see if anyone complains?
02:24:25 <dcoutts> bringert: yeah, I did that in the end
02:24:37 <dcoutts> and to cabal-install repo too
02:24:40 <dcoutts> lots of changes there
02:25:07 <dcoutts> I'd still like people to try it, cabal-install especially
02:25:17 <bringert> of course
02:25:22 <dcoutts> it now has all the functionality of cabal-setup and cabal-upload
02:25:28 <bringert> great!
02:25:34 <bringert> I'll start using it then
02:26:04 <dcoutts> bringert: though I've hidden the previous cabal-install clean command, if you can come up with a new command name for it then we can add it back
02:26:19 <dcoutts> perhaps an admin command with further sub-commands
02:26:21 <bringert> dcoutts: clear?
02:26:32 <bringert> ueah, admin might be better
02:26:52 <quicksilver> cabal-install dangerwillrobinson clean!
02:27:01 <quicksilver> cabal-install unsafe clean
02:27:07 <dcoutts> cabal admin reset-config; cabal admin delete-cache
02:27:48 <Sizur> cabal makememanygold --force
02:27:59 <dcoutts> bringert: some things are still a little inconsistent, eg cabal install does a per-user install but cabal configure configures like the default
02:30:01 <dcoutts> bringert: that's easily fixable, but there's some interesting point of contention if you do cabal configure; cabal build; cabal install;
02:30:01 <dcoutts> since the install command will go and re-configure and re-build
02:30:01 <dcoutts> this is where we really need the dependency infrastructure
02:30:06 <zeloran> hi
02:30:06 <zeloran> how to get an char from it's ascii code in haskell?
02:30:06 <mauke> @index chr
02:30:06 <lambdabot> Data.Char
02:30:06 <mauke> > chr 66
02:30:08 <lambdabot>  'B'
02:30:11 <dcoutts> Sizur: hmm, I wonder what that command would do. Who wants to add a "cabal lolz" command ?
02:30:40 <Sizur> dcoutts: why, make me money, of course!
02:31:03 <Sizur> the user should not care about those pesky implementation details
02:31:03 * dcoutts wonders how that works
02:31:07 <dcoutts> heh heh
02:32:23 <zeloran> hmm chr 66 does not work for me
02:32:39 <dcoutts> > Char.chr 66
02:32:40 <lambdabot>  'B'
02:32:46 <dcoutts> zeloran: you need to import Char
02:33:06 <zeloran> whats the import directive?
02:33:10 <dcoutts> zeloran: only a small number of functions are automatically imported from the Prelude
02:33:18 <dcoutts> zeloran: it's Haskell's module system
02:33:28 <Sizur> zeloran: import
02:34:45 <dcoutts> zeloran: are you familiar with modules/packages/headers in any other programming language?
02:35:03 <quicksilver> zeloran: <pedant> not ascii code, unicode code point </pedant>
02:35:13 <zeloran> yes @ dcoutts
02:35:40 <dcoutts> zeloran: so Haskell has a module system too, and you import modules with the syntax: import ModuleName
02:35:45 <dcoutts> like: import Data.Char
02:37:59 <dcoutts> that makes all the functions defined in that module available for you to use in your current module/program
02:37:59 <doserj> s/defined in/exported by/ *nitpick*
02:38:03 <dcoutts> bringert: now we need a cabal install --everything so we can do some hackage QA
02:38:10 <bringert> hehe
02:40:21 <Sizur> oy! The Purge
02:40:41 <quicksilver> haskell-cafe monitor: abrasiveness quotient HIGH
02:42:07 <doserj> quicksilver: do you subsume (+) and (+1) under "achieve correct precedence"? :)
02:43:25 <Sizur> doserj: do functions have precedence?
02:44:01 * bringert reboot
02:44:04 <bringert> s
02:44:08 <quicksilver> doserj: no, I forgot about sections :)
02:44:38 <doserj> quicksilver: and prefix-operator-application :)
02:44:47 <quicksilver> eh?
02:44:59 <quicksilver> ah yers
02:45:06 <quicksilver> well I think of that as a degenerate section
02:45:08 <doserj> (+) 3 5 is different to + 3 5
02:45:10 <quicksilver> but yes, agreed
02:45:20 <quicksilver> (+) is + with both arguments sectioned off :)
02:45:33 <doserj> :)
02:46:33 * doserj also mentions (..) in import/export lists...
02:46:37 * oerjan thought so as well, and was shocked to discover (`map`) was disallowed
02:47:32 * doserj would like to write `liftM2 (+)`
02:47:54 <sieni> then do that!
02:49:06 <sieni> >  liftM2 (+) [1,2,3] [4,5,6]
02:49:08 <lambdabot>  [5,6,7,6,7,8,7,8,9]
02:49:26 <quicksilver> doserj: so would I, but what does `zip`ap`tail` mean?
02:49:54 <quicksilver> there is a parsing problem with pseudo-brackets, where the bra and ket are the same...
02:50:57 <doserj> quicksilver: what if one forbids nesting?
02:51:22 <quicksilver> doserj: but how do you even detect nesting?
02:51:50 <quicksilver> you could parse that as (`zip`) ap (`tail`) or `zip(`ap`)tail`
02:52:11 <sjanssen> conal was talking about generalized infix earlier, he used the syntax `(foo bar)`
02:52:17 * quicksilver nods
02:52:21 <quicksilver> turning them into true brackets
02:52:23 <quicksilver> helps :)
02:52:26 <sjanssen> exactly
02:52:36 <Sizur> >liftM2 (&&) [minBound..] [minBound..]
02:52:44 <sjanssen> I'm also fond of the two operator hack
02:52:45 <Sizur> > liftM2 (&&) [minBound..] [minBound..]
02:52:46 <lambdabot>  [False,False,False,True]
02:52:53 <quicksilver> sjanssen: ?
02:52:55 <Sizur> > liftM2 (||) [minBound..] [minBound..]
02:52:56 <lambdabot>  [False,True,True,True]
02:53:37 <sjanssen> quicksilver: it goes something like: x -| f = f x; f |- x = f x
02:53:44 <sjanssen> with appropriate fixity
02:53:55 <quicksilver> ah, yes
02:53:58 <quicksilver> clever
02:54:06 <sjanssen> then you can write: [1, 2, 3] -| zipWith (+) |- [3, 2, 1]
02:54:22 <quicksilver> you can do a lot of weird syntax tricks with haskell given infix precedences
03:00:28 <quicksilver> haskell-cafe monitor: abrasiveness quotient FALLING
03:00:29 <quicksilver> :)
03:01:24 <sjanssen> quicksilver: talking about "New to Haskell"?
03:02:35 <quicksilver> yeah :)
03:02:40 <quicksilver> it appears to have calmed down now
03:02:55 <quicksilver> I felt communication errors were unnecessarily raising the temperature :)
03:03:09 <sjanssen> I didn't really understand the original post
03:05:36 <quicksilver> well, there were a lot of ways in which haskell wasn't quite as he expected
03:05:42 <quicksilver> and he attempted to ask some questions about it
03:05:47 <quicksilver> but some of them were pretty confusing :)
03:07:06 <zeloran> hi, another small newbie question
03:07:57 <zeloran> i'm using hugs and when i type/run "aaaaaa\n\rbbbbbbbbbb" it shows me exactly this text in the editor instead of doing a new line
03:08:37 <oerjan> yep it reescapes the string on showing it.  try putStr "aaaaaa\n\rbbbbbbbbbb"
03:09:12 <zeloran> wow :)
03:10:07 <oerjan> (also putStrLn)
03:10:31 <oerjan> @hoogle String -> IO ()
03:10:32 <zeloran> :) like Write/WriteLine...
03:10:32 <lambdabot> Prelude.putStr :: String -> IO ()
03:10:32 <lambdabot> Prelude.putStrLn :: String -> IO ()
03:10:32 <lambdabot> System.IO.putStr :: String -> IO ()
03:10:43 <zeloran> same sh** diff name -.-
03:10:47 <oerjan> @more
03:10:56 <oerjan> oh wait
03:11:14 <oerjan> :t print
03:11:16 <lambdabot> forall a. (Show a) => a -> IO ()
03:11:36 <oerjan> print is what is used by default, for pure values
03:11:43 <quicksilver> I must say, I never use print.
03:11:54 <quicksilver> It's a convenient method and it's not that convenient :)
03:12:07 <quicksilver> I just use putStr/putStrLn, and use show when I want to.
03:13:37 <oerjan> usually you want some other formatting around the show, i guess
03:13:48 <quicksilver> yeah
03:41:07 <bringert> dcoutts: cabal is still working great for me
03:41:13 <dcoutts> yay
03:42:04 <bringert> dcoutts: thanks for all your work on this
03:42:25 <dcoutts> np, I'm glad to get it done
03:42:29 <dcoutts> it's been annoying me :-)
03:43:13 <dcoutts> bringert: my only concern is that cabal-install now requires cabal-1.3
03:43:31 <dcoutts> and cabal-1.3 is not 100% compatible with 1.2 now, though we might be able to make it more so
03:44:02 <dcoutts> so we cannot easily upload cabal-install to hackage since we don't want to upload 1.3 unless it doesn't break stuff
03:44:15 <bringert> what does it break?
03:44:54 <dcoutts> not exactly sure, I'd have to try building everything, but I changed the types of all the FooFlags types
03:45:01 <dcoutts> like ConfigFlags
03:45:30 <dcoutts> eg configVerbosy used to be :: Verbosity, now it's Flag Verbosity
03:45:47 <dcoutts> that'd break some Setup.hs scripts
03:46:11 <dcoutts> we could keep some common ones like that as they were in a compat mode and use a different name for the interally used one
03:46:31 <dcoutts> I'd have to compile all the hackage Setup.hs scripts to see what breaks though
03:47:03 <dcoutts> since you never really know what bits of the cabal api they use, since the whole thing is exposed so we can use it in other tools etc
03:51:59 <_andre> if i have (f :: a -> StateT b IO c) and (g :: d -> a -> IO d), can i somehow call f inside g, like "x <- something $ f blah"? does this "something" exist?
03:53:59 <sjanssen> _andre: runStateT and friends
03:54:16 <sjanssen> but you need to provide an initial state to execute it
03:57:04 <Sizur> if i declare an instance in module A which is imported by B, can i use this instance in C provided i import B within the same application?
03:57:44 <Sizur> or do i have to specify this instance for explicit export in B?
03:58:07 <_andre> sjanssen: well, assuming it was initialized. i wanted to "extract" the value of type c from the return of f
03:58:16 <doserj> Sizur: the former
03:58:22 <Sizur> doserj: thanks
03:58:30 <quicksilver> _andre: which is no problem, but you do have to supply the initial state
03:58:44 <quicksilver> _andre: which will be of type b :)
03:58:44 <sjanssen> _andre: there is no value of type c until you pass in an initial state
03:58:55 <doserj> Sizur: there is no way to specify instances for explicit export/import anyway :)
03:59:03 <Sizur> good to know
03:59:33 <sjanssen> _andre: consider "StateT b IO c" to be "b -> IO (c, b)"
04:00:28 <quicksilver> :t runStateT
04:00:31 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
04:00:51 <quicksilver> runStateT is *precisely* the isomorphism implicit in sjanssen's consideration :)
04:01:24 <quicksilver> [well of course the type doesn't provie it to be an isomorphism but as it happens, it is]
04:02:43 <_andre> well, maybe i'm not getting this right then... i'm trying to write a function that would extract that c type value, but the initial state would be supplied elsewhere (which i haven't even written yet :p )
04:08:25 <_andre> i mean, in this case the state is a Map, so as i understood it, i should use runStateT when initializing the state (with Map.empty), but in this particular function i could assume the map is already initialized, and i just wanted to access it
04:08:31 <_andre> maybe that's not how it works?
04:09:03 <wy> I studied OCaml for sometime tonight and found that objects are something that's still inreplacable by type classes. There is still more to do in this direction. Even duck typing can be of interest.
04:11:17 <sjanssen> _andre: yep, that's not how it works :)
04:11:45 <sjanssen> _andre: the state isn't global, it's local to one invocation of runStateT
04:13:23 <_andre> does that mean that i should call runStateT then create a new state if i want to call get its value again?
04:14:05 <sjanssen> umm, maybe?  I'm not sure exactly what you want to do
04:14:15 <pejo> wy, have you seen OOHaskell?
04:15:17 <quicksilver> _andre: you could take the state as a parameter
04:15:25 <quicksilver> _andre: to the thing you're building
04:15:37 <quicksilver> _andre: that would be the obvious way to arrange for the initial state elsewhere
04:15:49 <_andre> sjanssen: i want to access the value corresponding to a key of the state map
04:15:50 <Sizur> wy: functional and OO are still at odds, but are converging
04:16:05 <_andre> but for each call of the function, a different key will be used
04:16:16 <Sizur> wy: some things are easier in one or another paradigm
04:17:42 <Sizur> f# joins them but at the expense of functional purity :(
04:20:04 <Sizur> i really want to see much more research done on arrows. it's a software equivalent to hardware design
04:20:21 <Sizur> i read somewhere that somebody discovered a few limitations of arrows here in #haskell
04:20:41 <wy> pejo: I just found oohaskell tonight, but the name "objective" might be better :-)
04:21:43 <pejo> wy, slight nameclash with O'Haskell then though.
04:23:33 <wy> Most of the time things are easy to categorize, but other times there could be so many attributes that even a librarian or zoolologist can't classify. That's why we need various ways of thinking
04:24:45 <wy> pejo: I'm interested in that existential type. Also, intersection type might be better
04:25:22 <wy> pejo: Going down this way, we'll reach duck typing, then chaos ;-)
04:26:40 <wy> So I guess the point is to know when to use what style of programming to do things. I have to go to sleep. It's like morning now ;-)
04:33:46 <matveev> hi, how to process the list by this pseudocode: foreach element e of list: call func e (list `without` e)
04:35:06 <quicksilver> matveev: map (\x -> func (l \\ [e])) l
04:41:54 <Sizur> i have a hard time figuring out how to generate a list of all possible groups within a list while keeping the order of the elements
04:43:43 <matveev> my lists are not sets, rather arrays: foreach index i within list: call func list!!i  (dropNth i list). A functions that returns all partitions of the list into "before" and "after" would suffice. I cannot find "inits", "tails" nowhere.
04:44:02 <dcoutts_> Sizur: try starting by pairing all elements with their index then you can reorder them as you like and still get the right order at the end by sorting on the index
04:44:20 <matveev> @where inits
04:44:20 <lambdabot> I know nothing about inits.
04:44:25 <matveev> @where tails
04:44:25 <lambdabot> I know nothing about tails.
04:44:31 <Sizur> something like [a,b,c,d] -> [[[a,b],d,c],[a,[b,c],d],[a,b,[d,c]],[[a,b,c],d],[a,[b,c,d]],[[[a,b],c],d],[[a,[b,c]],d],etc..
04:45:00 <Sizur> dcoutts_: oh, that's an idea
04:45:27 <doserj> Sizur: that doesn't typecheck, does it?
04:45:40 <Sizur> dcoutts_: i know, that's my issue
04:45:53 <Sizur> misstell
04:46:21 <Sizur> doserj: yeah, i want to generate *all possible* subgroups, not just one level subgroups
04:47:20 <doserj> Sizur: you want to generate all trees, whose pre-order traversal result in the given list?
04:47:52 <Sizur> doserj: yep, that would be the solution
04:48:32 <doserj> where data Tree a = Leaf a | Trees [a] or sth like that
04:48:52 <Sizur> yeah
04:51:10 <dcoutts_> Sizur: you want to use the [a] monad I think
04:51:22 <dcoutts_> and recursively split each sub-sequence at all possible positions
04:51:22 <Sizur> > take 10 $ zip ['a'..] [1..]
04:51:25 <lambdabot>  [('a',1),('b',2),('c',3),('d',4),('e',5),('f',6),('g',7),('h',8),('i',9),('j...
04:51:52 <dcoutts_> > filterM (const [True, False]) ['a','b','c','d']
04:51:53 <lambdabot>  ["abcd","abc","abd","ab","acd","ac","ad","a","bcd","bc","bd","b","cd","c","d...
04:52:40 <doserj> groups [x] = Leaf x ; groups (x:xs) = f x (groups xs) where f = <insert x at the front of all branches> ?
04:52:54 <Sizur> i cannot 'swallow' an element -- "abd" is not good
04:54:10 <dcoutts_> > map (\n -> splitAt n "abcd") [1..3]
04:54:11 <lambdabot>  [("a","bcd"),("ab","cd"),("abc","d")]
04:54:16 <dcoutts_> then do that recursively
04:54:23 <dcoutts_> for each sub-group that is non-empty
04:54:23 <Sizur> nice!
04:55:09 <dcoutts_> > let partitions xs = map (flip splitAt xs) (length xs) in partitions "abcd"
04:55:10 <lambdabot>  Couldn't match expected type `[Int]' against inferred type `Int'
04:55:27 <dcoutts_> > let partitions xs = map (flip splitAt xs) [1..(length xs)-1] in partitions "abcd"
04:55:28 <lambdabot>  [("a","bcd"),("ab","cd"),("abc","d")]
04:56:45 <doserj> or [0..(length xs)], depending on circumstances
04:57:37 <Sizur> then i can build all possibilities with partitions on each tree branch with empty partition being the leaf
04:58:15 <Sizur> hm, i'd have to accumulate the partition too
04:59:38 <matveev> is there a dropNth :: Int -> [a] -> [a] functions that complements (list !! nth) ?
05:00:11 <quicksilver> matveev: no because it's so easy
05:00:17 <Sizur> > filter (/='m') "abcdmgh"
05:00:18 <lambdabot>  "abcdgh"
05:00:20 <quicksilver> (take (n-1) x, drop n x)
05:00:52 <Sizur> my brain is the a cloud today
05:01:08 <Sizur> (as usual)
05:01:57 <osfameron> whose is the paper that suggests Haskell or similar might be used heavily in games programming in the future?
05:02:08 * osfameron can't find it on his delicious
05:02:45 <osfameron> ah, Tim Sweeney, found it
05:03:13 <ricky_clarkson> The guy who does xkcd gave a talk at google, and Knuth asked him questions.
05:14:34 <njbartlett> ricky_clarkson: Yeah and then somebody asked him "do you know who that was who just asked you a question?" :-)
05:15:04 <quicksilver> I think I'd recognise Knuth even though I've never met him
05:15:11 <quicksilver> I have at least two books with a photo of him on
05:15:52 <ricky_clarkson> I'd recognise him, I think.  I wonder why he always seems to put a long-sleeved shirt under a T-shirt.
05:15:55 <osfameron> what did knuth think of http://imgs.xkcd.com/comics/donald_knuth.png ?
05:16:01 <osfameron> or did he ask a different question?
05:16:45 <ricky_clarkson> That wasn't mentioned (thus far, I'm at 38 minutes of 60-ish).
05:18:04 <doserj> i think the question was about http://xkcd.com/342/
05:18:05 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
05:19:38 <ricky_clarkson> Ah, yes.
05:19:54 <ricky_clarkson> I need to watch it with better speakers. ;(
05:24:24 <dcoutts_> > let dropNth n xs = case splitAt n xs of (xs', _:xs'') -> xs' ++ xs'' in dropNth 3 "foobar"
05:24:24 <lambdabot> Unbalanced parentheses
05:24:32 <dcoutts_> bah
05:25:18 <dcoutts_> huh, I don't see the error, hugs accepts that code
05:25:29 <dcoutts_> matveev: I think that's correct even if lambdabot doesn't ^^^
05:26:18 <nomeata> Igloo: Hi. dons keeps bugging me about new xmonad package, so I guess Iâ€™ll keep asking you: Did you have a chance to work on the ghc packages?
05:27:00 <Saizan_> > let dropNth n xs = case splitAt n xs of (xs', (_:xs'')) -> xs' ++ xs'' in dropNth 3 "foobar"
05:27:00 <lambdabot> Unbalanced parentheses
05:27:12 <Saizan_> ahh the '' bug
05:27:22 <Jomyoot> Can haskell compile a Lib that is accessable from C?
05:27:33 <Thunder> Jomyoot: Yes.
05:28:20 <Thunder> http://www.haskell.org/ghc/docs/latest/html/users_guide/ffi-ghc.html#ffi-library
05:28:21 <lambdabot> Title: 9.2. Using the FFI with GHC, http://tinyurl.com/ytardt
05:29:23 <Jomyoot> that's awesome
05:29:58 <Jomyoot> How is haskell performance for for extensive hash set computation?
05:30:04 <Sizur> where can i see the talk by Tim Sweeney with Knuth's interrogation?
05:31:47 <scook0> Sizur: I think you have two conversations crossed
05:32:01 <Sizur> haha
05:32:27 <bos> is that the one in which knuth asks about the secret underground antlion lair in half life 2?
05:33:13 <Thunder> Jomyoot: If you keep the hash in a state monad and use chained hashing, you will get a pretty fast implementation.
05:33:45 <Jomyoot> I like Ruby and Lisp, will I find haskell similar or very different?
05:34:25 <Sizur> bos: exactly, and how it relates to literate programming of the texture sharing on the socks of the main character
05:34:31 <Thunder> Jomyoot: Depending on you current Ruby usage, you will find Haskell familar or quite different. You will find Haskell familar from the Lisp background.
05:34:50 <quicksilver> Jomyoot: haskell is quite a lot like a version of lisp with types + type inference
05:34:55 <Sizur> shading*
05:35:00 <quicksilver> Jomyoot: although, the syntax is a bit different.
05:35:09 <Jomyoot> does haskell have nice syntax like Ruby?
05:35:26 <Jomyoot> and is FFI  robust and can be depended upon?
05:35:29 <Thunder> Jomyoot: Depends on your personal feelings.
05:35:29 <bos> haskell people tend to use maps instead of hashes.
05:35:40 <Sizur> Jomyoot: if you take Math as the niceness model, then it's nicer
05:35:44 <quicksilver> dcoutts_: the problem with your code was the two nested layout blocks, I think?
05:36:03 <Jomyoot> is Monad difficult to understand?
05:36:15 <dcoutts_> quicksilver: bug in the Language.Haskell parser is it?
05:36:19 <quicksilver> some people find so, some don't
05:36:19 <Thunder> Jomyoot: Depends on your approach.
05:36:51 <quicksilver> > let { dropNth n xs = case splitAt n xs of { (xs', (_:xs'')) ->  xs' ++ xs''} } in dropNth 3 "foobar"
05:36:52 <lambdabot> Unbalanced parentheses
05:36:59 <quicksilver> dcoutts_: ah yes, apparently so :)
05:37:04 <quicksilver> dcoutts_: not what I thought it was.
05:38:40 <quicksilver> "These are not the bugs you are looking for"
05:38:49 <bos> Jomyoot: if you have someone explain them to you badly, monads are hard to understand.
05:39:32 <Thunder> http://thedailywtf.com/Articles/No-Loop-For-You!.aspx
05:39:33 <lambdabot> Title: No Loop For You! - The Daily WTF
05:40:06 <Japsu> -funroll-loops
05:46:27 <osfameron> hehe, BrillantML
05:49:28 <ricky_clarkson> I bet it had recursion and the guy just didn't realise.
05:51:21 <Thunder> ricky: Most probably.
06:07:12 <Saizan_> what would you use to uniwuely identify a type over the network?
06:07:33 <Thunder> ASN.1
06:07:59 <Saizan_> i was thinking somthing like TypeRep, but the only way to output it is Show
06:08:33 <Saizan_> Thunder: an haskell type, and i really mean over (de)serialization
06:12:15 <quicksilver> Saizan_: I would think TypeRep is the best you can do.
06:12:27 <quicksilver> deserialization turns out to be hard
06:12:28 <quicksilver> :)
06:12:40 <quicksilver> To be precise: it's fine if the call site knows what type to expect.
06:12:55 <quicksilver> But deserializing an unknown type into an existential or similar is hard.
06:13:15 <quicksilver> I don't *think* it's possible without maintaining an explicit list of all supported types, but I could be wrong.
06:17:14 <Saizan_> yeah i know, i'm just going to deserialize a discriminated union of them, but i'd like not to have an explicit "protocol" on how to identify which is which
06:18:46 <quicksilver> typerep should work
06:18:56 <quicksilver> mind you deriving Binary would do something similar :)
06:19:33 <Saizan_> binary doesn't include a tag to identify the type early iirc
06:19:49 <quicksilver> no, but it includes a tag to identify the tag
06:19:56 <quicksilver> and you were talking about a discriminated union
06:20:11 <Saizan_> ah right
06:21:10 <Saizan_> mmh no, i want the sender to not have to know how the union is shaped
06:21:36 <Saizan_> so it's more an HList with no real tag
06:23:45 <Saizan_> showing the TypeRep in the message seems wasteful
06:26:38 <matveev> I am a fortran guy. So I have troubles expressing fortran loops in haskell. The function weights' in http://hpaste.org/4559 prototype took most of my time. Is there a better idiom I could have used?
06:29:06 <Lemmih> matveev: Yes.
06:29:55 <Toxaris> > tails [1, 2, 4, 6]
06:29:58 <lambdabot>  [[1,2,4,6],[2,4,6],[4,6],[6],[]]
06:30:08 <Nafai> Hey byorgey
06:30:13 <Toxaris> matveev: map over the tails of rs
06:30:30 <matveev> @where tails
06:30:31 <lambdabot> I know nothing about tails.
06:30:38 <matveev> @src tails
06:30:39 <lambdabot> tails []         = [[]]
06:30:39 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
06:31:00 <Lemmih> Toxaris: I don't think that'll do.
06:31:33 <matveev> Not in scope: `tails'.  How can labdabot help in such cases?
06:31:42 <Saizan_> Toxaris: he uses the inits too
06:31:46 <Saizan_> ?index tails
06:31:46 <lambdabot> Data.List
06:31:55 <Saizan_> you've to import Data.List
06:31:57 <matveev> ?index inits
06:31:57 <lambdabot> Data.List
06:32:03 <Toxaris> matveev: hoogle can: http://haskell.org/hoogle/?q=tails
06:32:08 <dcoutts_> matveev: so for each element in the list we're calculating something with it and all the other element of the list
06:32:10 <Lemmih> matveev: weights = worker [] where worker acc [] = []; worker acc (x:xs) = product (map (s . mu x) xs + product (map (s . mu x)) acc : worker (x:acc) xs
06:32:49 <dcoutts_> so Lemmih's solution relies on the fact that the order of the other elements does not matter, I think
06:32:53 <Toxaris> matveev: oups, I've read dropNth as drop :(
06:32:55 <Lemmih> Yeah.
06:33:01 <dcoutts_> since it reverses the elements before the 'current' point
06:33:23 <Thunder> http://hpaste.org/4560  --- Problem with "`MonadState s' is not applied to enough type arguments" ... Any hint?
06:34:04 <Lemmih> Thunder: MonadState takes two arguments.
06:34:09 * Toxaris searches in yesterday's logs for his oneOf combinator
06:34:49 <dcoutts_> matveev: so Lemmih's solution walks over the list a good deal less, it partitions the list into two and moves the split point down by one each iteration
06:35:12 <dcoutts_> matveev: by moving the next element from one list to the other
06:35:40 <byorgey> hi Nafai
06:36:09 <Thunder> Lemmih: Oh, I never thought of moving the argumente in frÃ³nt of the =>
06:36:50 <Toxaris> > let oneOf [] = []; oneOf (x:xs) = (x, xs) : ((<$>). (<$>)) (x :) (oneOf xs) in oneOf "abcd"
06:36:51 <lambdabot>  [('a',"bcd"),('b',"acd"),('c',"abd"),('d',"abc")]
06:37:49 <kosmikus> @seen grahamhutton
06:37:50 <lambdabot> I haven't seen grahamhutton.
06:38:16 <Lemmih> Thunder: You've already given 'MonadState' a single argument, namely 's'.
06:38:22 <Toxaris> weights' = map (uncurry wfunc) . oneOf
06:39:20 <Thunder> http://hpaste.org/4560/diff?old=0&new=1  -- Solved.
06:39:58 <Saizan_> weird combinator -> ((<$>).(<$>))
06:40:36 <Toxaris> :t (<$>) <$> (<$>) -- is this the same thing?
06:40:38 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
06:40:50 <Toxaris> :t (<$>) . (<$>)
06:40:51 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
06:41:05 <Toxaris> it is :)
06:41:08 <MaxRabkin> Saizan_: dollar signs in your eyes
06:44:46 <sclv> Toxaris: Nice!
06:44:50 <matveev> Toxaris: do I really need <$> in order to: do i=1,N; res(i)=1; do j=1,N; if(j==i) cycle; res(i) = res(i) * wfunc( array(i), array(j) ); enddo; enddo
06:46:12 <sclv> matveev: you're not working with arrays, but with linked lists. idioms are different, performance is different.
06:46:45 <sclv> you can turn any loop into a recursion pretty simply, but its terribly unhaskellish.
06:46:58 <sjanssen> remember, Haskell is not Fortran :)
06:47:20 <Toxaris> matveev: I don't understand the code you've given. I'm one of these modern computer science students not learning about Fortran
06:47:44 <Toxaris> > let oneOf [] = []; oneOf (x:xs) = (x, xs) : (map . map) (x :) (oneOf xs) in oneOf "abcd"
06:47:45 <lambdabot>  Couldn't match expected type `(t, [t])' against inferred type `[b]'
06:47:54 <sclv> anyway, <$> = fmap
06:48:12 <Toxaris> matveev: but for my code: you can use second for one of <$> and map for the other
06:48:43 <Toxaris> if you're not familiar with <$>. but it's a simple, nice and wonderfull combinator wich is usefull all the time, so you may consider learn about it
06:48:44 <matveev> sclv: right, that was my problem. I needed something quick  for the above loop. And spent more time on loops that on the rest.
06:49:10 <sclv> it takes a while to get an intuition for it.
06:49:12 <BMeph> (<$>).(<$>) is the "show me the money" operator. ;)
06:49:20 <Saizan_> > let oneOf [] = []; oneOf (x:xs) = (x, xs) : (map . (\f (x,xs) -> (x, f xs))) (x :) (oneOf xs) in oneOf "abcd"
06:49:23 <lambdabot>  [('a',"bcd"),('b',"acd"),('c',"abd"),('d',"abc")]
06:50:47 <Saizan_> matveev: the first "rule" is to not work with indices but with consuming the list directly. (!!) is O(n) btw
06:51:42 <matveev> Toxaris: for a each number x from a list, compute average reciprocal distance 1/|x-y| to the others, avoiding the singularity. I have a func(x,y)/=func(y,x) instead.
06:53:00 <Koelle> yeaah i made it^^
06:53:15 <BMeph> Welcome, Koelle! ^_^
06:55:00 <Koelle> is probably anyone here that can help me to find access to haskell?? i´ve read several tuts but i am still unable to understand anything^^
06:55:34 <Koelle> is there any good souce page or anything else?
06:55:43 <BMeph> Toxaris: Thanks! That "oneOf" function is going in my Utility module. Duly creditted, of course. ;)
06:55:46 <Thunder> Koelle: Please ask a question or post your problem code to http://hpaste.org
06:56:02 <pejo> @where yaht
06:56:03 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
06:56:30 <pejo> Koelle, a lot of people like YAHT. Doing the exercises is a good way to learn.
06:56:34 <BMeph> Koelle: The best tutorials for Haskell are found at: http://www.haskell.org
06:56:35 <lambdabot> Title: Haskell - HaskellWiki
06:56:36 <Toxaris> BMeph: you're welcome :)
06:56:55 <ricky_clarkson> > fix (Yet Another++)++"Haskell Tutorial"
06:56:56 <lambdabot>   Not in scope: data constructor `Another'
06:57:05 <ricky_clarkson> > fix ("Yet Another "++)++"Haskell Tutorial"
06:57:06 <lambdabot>  "Yet Another Yet Another Yet Another Yet Another Yet Another Yet Another Yet...
06:57:58 <Koelle> yeah but my prof wants me to use haskell with openGL ^^ and he wants a full workng sample of 4 in a row by the end of january^^
06:58:26 <Koelle> and the doc on haskell.org about openGL seems to be outdatet
06:58:40 <Saizan_> > Yet
06:58:41 <lambdabot>   Not in scope: data constructor `Yet'
06:59:21 <Koelle> ^^
06:59:59 <Saizan_> well you should learn the basics first, i think
07:00:50 <sjanssen> matveev: http://hpaste.org/4559#a1 how does this look?
07:00:57 <Koelle> think so 2 but it´s very hard if one has worked with c# and java for the past 3 years
07:01:41 <SamB_XP> Koelle: I suggest you learn one at a time
07:02:04 <SamB_XP> well, to start with, anyway
07:02:07 <BMeph> Koelle: Microsoft is working on that for you. By the time C# 6.0 comes around, it'll likely look suspiciously like haskell'. ;)
07:02:20 <SamB_XP> haskell'''''
07:02:26 <SamB_XP> maybe
07:02:43 * sjanssen hopes Haskell' will be out by then
07:02:48 * SamB_XP too
07:03:05 <SamB_XP> what version of C# are they up to? 3.0?
07:03:22 <SamB_XP> 2.0?
07:03:45 * BMeph thinks SPJ will sneak over to the development folks and "accidentally" leave some haskell' specs on a desk...
07:04:05 <SamB_XP> BMeph: and here I thought MS was doing that on purpose
07:04:17 <BMeph> SamB_XP: I believe they're calling it C# 3.5
07:04:38 <vininim> what? C# is pure functional with lazy-evaluation?
07:04:49 <SamB_XP> crazy how they inflate the version numbers
07:05:04 <BMeph> SamB_XP: If by MS you mean select employees of MS, and not the upper management specifically, I think so. :)
07:05:12 * SamB_XP wonders how X11 got up to 11...
07:05:22 <Thunder> SamB: They does not inflate the version numbers, they set they lazily.
07:05:33 <vininim> or maybe it's the other way around and haskell''' will be... oh god
07:05:42 * BMeph thinks they were inspired by Spinal Tap ;)
07:05:54 <SamB_XP> BMeph: well, whoever at MS actually designs C#, I meant
07:05:59 <ricky_clarkson> I choose numbers that I definitely don't remember having chosen before.
07:06:08 <matveev> sjanssen: much better, thanks! I hoped that comprehensions or do/return may be usefull. I not fluent in either.
07:06:26 <SamB_XP> ricky_clarkson: eh?
07:06:26 <moobax> hello
07:06:38 <sjanssen> matveev: the key point (as others have mentioned) is to stay away from indices as much as possible
07:07:04 <ricky_clarkson> SamB_XP: In something non-software, I sometimes skip some numbers in case I've forgotten some recent 'versions'.
07:07:19 <SamB_XP> anyway... I think MS is incrementing the major version of the C# version an awful lot
07:07:22 <ricky_clarkson> I like the digits of PI version number.
07:07:28 <SamB_XP> though I suppose that "Java 2" thing was worse
07:07:46 <sjanssen> matveev: generally you want to use a list traversing function (like map, filter, the folds or list comprehensions) rather than a for loop with indices
07:07:59 <ricky_clarkson> J2SE 5.0 1.5.0, at one point.
07:08:06 <SamB_XP> since they did NOT increment the version number to 2.0.0
07:08:19 <SamB_XP> heh
07:08:23 <SamB_XP> 5.0 also?
07:08:33 <ricky_clarkson> Sorry, no .0 there.
07:08:36 <BMeph> They should probably break out a special "Don't ask for ___ if you're not using it directly" page from the "Things to Avoid" section in the HWiki.
07:08:41 <Spark> irritating version numbers are always irritating
07:08:52 <Sizur> @hoogle something
07:08:53 <lambdabot> Data.Generics.Schemes.something :: GenericQ (Maybe u) -> GenericQ (Maybe u)
07:09:07 <SamB_XP> anyway, I think that, for Java 2, they should have increased their version number to 2.0.0
07:09:08 <moobax> quick question: Lazy ByteStrings have a "chunk size of 64k". Does that mean that a one character L.B.S. takes up 64k..?
07:09:16 * BMeph pokes Sparx with a box of "Mac OS X"
07:09:21 <SamB_XP> wouldn't that have made sense?
07:09:27 <Toxaris> moobax: no
07:09:32 <SamB_XP> what version is OS X up to?
07:09:39 <sjanssen> moobax: depends on how you construct it.  Probably not.
07:09:46 <sieni> SamB_XP: 10.5
07:09:56 <SamB_XP> I wonder what they are going to do after 10.9
07:09:56 <BMeph> @remember Sizur <Sizur> @hoogle something
07:09:57 <lambdabot> I will never forget.
07:09:59 <moobax> if I do ByteString.pack "c"
07:10:10 <SamB_XP> Mac OS XI?
07:10:10 <pejo> SamB, what's wrong with 10.10?
07:10:12 <sjanssen> moobax: eg. fmap (take 1) (readFile "foo") will probably eat 64KB
07:10:16 <ricky_clarkson> SamB_XP: Sun have always done crap like that.. Solaris 8==SunOS 2.9 or something.
07:10:20 <BMeph> I want a T-shirt with that, now. ^_^
07:10:23 <SamB_XP> pejo: might confuse users...
07:10:25 <Sizur> BMeph: lol
07:10:35 <SamB_XP> ricky_clarkson: that's not as bad though
07:10:45 <pejo> SamB, .. because they can't tell that 10 > 9?
07:10:46 <sjanssen> moobax: that will use a few dozen bytes or so
07:10:46 <SamB_XP> because Solaris and SunOS don't sound the same
07:10:56 <moobax> oh ok, I see
07:11:13 <SamB_XP> whereas Java and Java Development Kit or Java Runtime Environment do sound the same
07:11:20 <moobax> but isn't the string meant to be lazy? how does it know not to allocate 64k?
07:11:37 <sieni> ricky_clarkson: not quite that :-)
07:11:41 <moobax> or does it evaluate in 64k chunks?
07:11:46 <sieni> ricky_clarkson: SunOS 2.8 == Solaris 8
07:11:57 <ricky_clarkson> sieni: I've never used it.
07:11:57 <sjanssen> moobax: it "looks ahead" in 64KB chunks
07:12:11 <moobax> yeah, that makes sense
07:12:13 <sjanssen> moobax: this is necessary because each individual chunk is strict
07:12:13 <moobax> thanks :)
07:12:13 <sieni> ricky_clarkson: noooooo
07:12:20 <moobax> sure, i get it
07:12:24 <SamB_XP> moobax: yeah, it is strict in small pieces
07:12:29 <moobax> I was being thick. :P
07:12:37 <sieni> ricky_clarkson: SunOS 5.8 == Solaris 8
07:12:57 <sieni> http://en.wikipedia.org/wiki/Solaris_%28operating_system%29#Versions
07:12:58 <lambdabot> http://tinyurl.com/3ynqyg
07:13:08 <SamB_XP> sieni: the 8s -- is that a coincidence?
07:13:11 <quicksilver> moobax: not at all, no. It's not obvious from the name.
07:13:14 <pejo> ricky_clarkson, Sun doesn't really talk about "SunOS" any longer, they stopped after SunOS 4. All they mention is Solaris.
07:13:18 <sieni> Solaris 2.6 == SunOS 5.6 :-)
07:13:26 <quicksilver> moobax: it started off as totally strict, and then that lazy version is just "a bit lazier" than the strict one
07:13:51 <SamB_XP> is this kind of like how MS didn't selel NT 5.0, 5.1, or 5.2 ?
07:13:59 <SamB_XP> s/selel/sell/
07:14:24 <ricky_clarkson> I suppose SunOS is just what people call it affectionately these days.
07:14:36 <ricky_clarkson> You know, while replacing it with a laptop running Ubuntu.
07:15:04 <SamB_XP> replacing a solaris box with a laptop running ubuntu?
07:15:09 <SamB_XP> that sounds wierd ;-)
07:16:12 <BMeph> SamB_XP: Actually, NT 5 is... Windows XP. Ironic... ;)
07:16:31 <SamB_XP> BMeph: I think 5.0 is Windows 2000, actually...
07:17:11 <pejo> SamB, http://en.wikipedia.org/wiki/SunOS has a nice explaination near the end of the page, which states pretty much what I said apparently, they don't market "SunOS".
07:17:12 <lambdabot> Title: SunOS - Wikipedia, the free encyclopedia
07:17:17 <SamB_XP> I don't remember what NT 5.2 was for...
07:17:17 <BMeph> SamB_XP: Oh, right. Then XP is 5.1
07:17:40 <SamB_XP> I think it was either 2003 server, or a 64-bit version of XP, or maybe both...
07:19:58 <int-e> SamB_XP: http://en.wikipedia.org/wiki/Windows_NT ... it's both.
07:19:59 <lambdabot> Title: Windows NT - Wikipedia, the free encyclopedia
07:21:13 <BMeph> It's a breath freshener. It's a toilet bowl cleaner. No, wait - it's BOTH! ;p
07:21:38 <ricky_clarkson> Do not reuse.
07:24:20 <Toxaris> what can I do to not have Prelude in scope in ghci?
07:25:42 <BMeph> Toxaris: :m - Prelude
07:28:09 <cognominal> on the last ghc...
07:28:09 <cognominal> Network/HTTP.hs:149:7   Could not find module `Data.Array.MArray':  it is a member of package array-0.1.0.0, which is hidden
07:28:42 <cognominal> what is the trick ti make it visible?
07:28:55 <quicksilver> add it to the cabal file
07:28:56 <Saizan_> add array to build-depends in the .cabal
07:29:14 <Toxaris> BMeph: I have loaded an interpreted module
07:29:59 <Toxaris> I change import statements in an interpreted module and use ":r" in ghci. why does ":t" doesn't respect the new imports afterward?
07:30:54 <Toxaris> (e.g. I add "import Prelude ()" but :t still has Prelude in scope)
07:32:18 <BMeph> Toxaris: Since GHCi had Prelude loaded before your module, having import Prelude() doen't tell it to unload the Prelude. I just figures that your module isn't using the Prelude.
07:33:20 <Toxaris> BMeph: but ":l\n:l <modulename>" instead of ":r" works
07:33:31 <dmead> ?seens augustss
07:33:32 <lambdabot> I saw augustss leaving #haskell 3h 29m 24s ago, and .
07:33:38 <dmead> ?msg
07:33:39 <lambdabot> Not enough privileges
07:33:46 <dmead> fack
07:40:25 <Toxaris> BMeph: http://hpaste.org/4562
07:41:29 <BMeph> Drat - GHCi is still crashing when I do the plugin eval1 test. :(
07:42:42 <Saizan_> Toxaris: perfect to file a bug :)
07:43:50 <Toxaris> Saizan_: how to do so?
07:43:55 <Saizan_> ?bug
07:43:56 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
07:44:15 <Toxaris> TICKET_CREATE privileges are required to perform this operation
07:44:21 <Saizan_> you can use guest/guest to login
07:45:04 <dozer> if I have a running program, is there a signal or keypress or somethiung that will get it to spit out where it is in the execution?
07:46:03 <Saizan_> no
07:46:24 <dozer> that makes me unhappy
07:47:13 <quicksilver> well, ghc doesn't have a notion of call stack and current location *quite* like an imperative system.
07:47:21 <dozer> I can send java apps running on the sun jvm a signal, and they will dump out where each thread is at
07:47:25 <quicksilver> Still, it would sometimes be useful.
07:47:37 <dozer> understood, but it could give me some hint as to the source code line or something
07:47:57 <quicksilver> in the presence of inlining, it generally doesn't know
07:48:17 <quicksilver> but, if the executable was compiled with -prof -auto-all then in principle it could be done
07:48:30 <dozer> right, that's what I was thinking
07:48:48 <quicksilver> yeah I can see it would be a useful thing in principle
07:48:56 <quicksilver> although I've never needed it myself :)
07:49:05 <dozer> the jvm does crasy stuff with run-time inlining - but it keeps enough history about to be able to reconstruct stack-traces
07:49:57 <dozer> well, my app is still looping to death, but I haven't been able to track down what the loop is within
07:50:11 <sjanssen> dozer: have you tried the ghci debugger?
07:50:22 <quicksilver> does Henning Thielemann IRC?
07:50:35 <dozer> yeah - unfortunately, when not compiled it takes 50 min to get past the initialization
07:50:38 <dozer> and then coredumps
07:51:10 <quicksilver> you could compile the slow modules and still run it in ghci
07:51:12 <sjanssen> quicksilver: I don't think so
07:51:16 <quicksilver> I'm not sure how that works with the debugger
07:51:22 <quicksilver> cos I've never tried the debugger...
07:51:37 <dozer> it's probably the slow module that's looping though :)
07:52:31 <quicksilver> well I don't know what the ghci debugger does with compiled code
07:52:37 <quicksilver> maybe it does something useful? :)
07:53:39 <BMeph> Toxaris: That effect with Prelude hiding - "it's not a bug, it's a feature!" - see 3.4.3 of the GHC UG.
07:53:59 <Toxaris> BMeph: "UG"?
07:54:06 <ZsoL> user guide?
07:54:14 <Toxaris> ZsoL: thanks :))
07:54:21 <BMeph> Toxaris: What ZsoL said. :)
07:54:22 <ZsoL> just a guess :-)
07:55:25 <ZsoL> quicksilver, i don't think it can do anything useful with it
07:56:38 <quicksilver> ZsoL: ah, shame
07:57:04 <Toxaris> BMeph: 3.4.3 is not talking about ":r"
07:57:38 <BMeph> Toxaris: Which version do you have?
07:58:09 <Toxaris> ghc 6.8.1 and latest user guide
07:59:09 <Toxaris> UG 3.7: ":reload attempts to reload the current target set (see :load) ..."
07:59:22 <Toxaris> so :r should behave like :l
08:00:18 <BMeph> Exactly. :r reloads whichever module you last did an :l with.
08:00:43 <Toxaris> so :l name\n:r should behave exactly like :l name\n:l name
08:00:52 <BMeph> Yes.
08:01:03 <Toxaris> wich it doesn't. so it's a bug, not a feature.
08:01:29 <BMeph> Because it doesn't do it the first time, you mean?
08:01:45 <BMeph> That is, because it doesn't suppress the Prelude on the first load?
08:01:55 <Toxaris> yse
08:01:56 <Toxaris> yes
08:02:31 <ZsoL> :l != :m +
08:03:01 <Saizan_> what if you start with :m - Prelude?
08:04:37 <BMeph> ZsoL, Saizan_: That isn't the issue. Check out Toxaris' hpaste. He adds the "import Prelude ()" line, reloads the module, and the Prelude def is still there.
08:04:53 <BMeph> Although, it might be because id is defined elsewhere.
08:05:16 <Toxaris> BMeph: elsewhere? there is no elsewhere. (and it's the same with other functions)
08:06:20 <Saizan_> Toxaris: if you :m - Prelude from the start then when you :r it's not there
08:06:45 <Saizan_> Toxaris: but it's there on the first load since Test initially imports it
08:08:26 <Saizan_> so maybe the current target set after the first :l test is supposed to be {Prelude,Test}? a bit ambiguous
08:10:10 <Toxaris> Saizan_: that would mean that "the current target set" is different from whats printed before the ">"
08:10:53 <BMeph> Toxaris: I just tried in in GHCi (6.8.2), and it works as expected. Maybe it was a 6.8.1 bug.
08:11:07 <Toxaris> BMeph: ok thanks
08:11:29 * Toxaris should have looked for fixed bugs
08:11:40 <BMeph> Toxaris: Don't thank me until you set up 6.8.2 and have it run correctly. ;)
08:12:11 <Toxaris> BMeph: I'll just remember to workaround this bug :)
08:12:53 <BMeph> Toxaris: Is there some reason why you can't just get 6.8.2?
08:14:05 <Toxaris> BMeph: I understand your remark so that there may be reasons. and in that case, i wouldn't bother. if there's a windows installer, i'll happily download and install it :)
08:14:54 <dons> heh, http://enhyper.blogspot.com/2007/12/haskell-next-mainstream-programming.html
08:14:55 <lambdabot> Title: Enhyper, http://tinyurl.com/3bxf97
08:15:02 <dons> Haskell - The Next Mainstream Programming Language?
08:15:09 <Toxaris> http://hpaste.org/4562#a3
08:15:37 <BMeph> Toxaris: http://haskell.org/ghc/download_ghc_682.html#windows
08:15:39 <quicksilver> dons: ah, I wanted to ask you something
08:15:57 <BMeph> ;)
08:16:20 <dons> quicksilver: ?
08:16:25 <dons> ?users
08:16:25 <lambdabot> Maximum users seen in #haskell: 434, currently: 407 (93.8%), active: 8 (2.0%)
08:16:41 <quicksilver> dons: these putative byestring arrays
08:16:48 <quicksilver> dons: how would they be different from storeablearray?
08:17:06 <dons> possibly they'd use ST instead
08:17:23 <dons> i was basically thinking of ripping out the ndp flat, unboxed arrays
08:17:25 <dons> which are in ST
08:17:34 <wolverian> hm, how does http://haskell.org/ghc/docs/latest/html/libraries/base/src/Data-List.html#inits work? is there a tool to visualise the evaluation for an example, when the user is too tired to figure it out properly? :)
08:17:34 <lambdabot> http://tinyurl.com/392kwb
08:17:37 <dons> but it would be similar to Storable too
08:17:47 <quicksilver> dons: *nods*
08:17:58 <quicksilver> dons: well you'd want an immutable interface for them too
08:18:06 <quicksilver> dons: don't want to force everyone into a monad
08:18:10 <Sizur> > inits "abcde"
08:18:13 <lambdabot>  ["","a","ab","abc","abcd","abcde"]
08:18:27 <wolverian> I know what it does, I'm just confused how
08:18:30 <scodil> dons: where are these ndp flat, unboxed arrays? got a link?
08:19:38 <byorgey> wolverian: you mean, you're not sure how you would write it yourself?  or you mean you're looking at the source and not sure how it accomplishes what it does?
08:19:54 <wolverian> byorgey, latter
08:20:10 <wolverian> well, former, too. I should figure out that first
08:20:15 <BMeph> @src inits
08:20:16 <lambdabot> inits []     =  [[]]
08:20:16 <lambdabot> inits (x:xs) =  [[]] ++ map (x:) (inits xs)
08:21:14 <byorgey> wolverian: ok, first I'll assume you understand how the first line works =)
08:21:21 <wolverian> byorgey, yes. :)
08:21:28 <ricky_clarkson> > "ref"++inits $ repeat "er"
08:21:28 <lambdabot>  Couldn't match expected type `[Char]'
08:21:29 <byorgey> wolverian: the interesting case of course is the recursive bit.
08:21:43 <byorgey> wolverian: do you understand 'map'?
08:21:49 <wolverian> byorgey, yes.
08:21:59 <byorgey> wolverian: ok, and do you understand what the (x:) is?
08:22:04 <wolverian> yes. :)
08:22:17 <byorgey> wolverian: ok, just making sure to start from the beginning =)
08:22:23 <wolverian> I'm confused by how it recurses and _then_ maps. I can't visualise what it's building
08:22:40 <Sizur> > (\x-> map (flip take x) [0..length x]) "abcd"
08:22:41 <lambdabot>  ["","a","ab","abc","abcd"]
08:22:48 <byorgey> wolverian: so let's suppose we're evaluating inits [1,2,3,4]
08:22:57 <byorgey> wolverian: so x is 1, and xs is [2,3,4]
08:23:31 <byorgey> wolverian: assuming inits works correctly (which you get to assume when considering the recursive case), inits xs should be [[],[2],[2,3],[2,3,4]]
08:23:35 <byorgey> right?
08:24:29 <wolverian> yes
08:24:57 <byorgey> wolverian: so the question is, how can we take [[], [2], [2,3], [2,3,4]] and transform it into the result that we want?
08:25:01 <sioraiocht> @djinn (a,(a,b)) -> b
08:25:02 <lambdabot> f (_, (_, a)) = a
08:25:03 <wolverian> ohh now I get it
08:25:18 <byorgey> > map (1:) [[], [2], [2,3], [2,3,4]]
08:25:18 <wolverian> it's gluing the inits to the tails, so to speak
08:25:19 <lambdabot>  [[1],[1,2],[1,2,3],[1,2,3,4]]
08:25:30 <byorgey> wolverian: sure, you can think of it that way
08:25:33 <wolverian> (not tails in the sense of the function called tails)
08:25:37 <byorgey> right =)
08:25:39 <Nafai> Hey byorgey!
08:25:42 <byorgey> hi Nafai!
08:25:44 <wolverian> byorgey, thanks a lot :)
08:25:52 <byorgey> wolverian: you're welcome =)
08:26:03 <sioraiocht> @djinn (a ->b)
08:26:03 <lambdabot> -- f cannot be realized.
08:26:10 <ZsoL> i like this channel; lots of nice and helpful ppl
08:26:11 <ZsoL> :-)
08:26:18 <wolverian> now could you explain how you would arrive at a definition like that from scratch?
08:26:34 <ZsoL> routine :-)
08:26:35 <wolverian> s/how/how and why/
08:26:36 <byorgey> wolverian: you'd do it pretty much exactly like my explanation.
08:26:40 <Toxaris> wolverian: he did :)
08:26:45 <wolverian> well, I suppose so..
08:27:00 <Japsu> @quickcheck let f (_, (_, a)) = a; g = snd . snd in \x -> f x == g x
08:27:00 <sioraiocht> @djinn ((a -> b),b)
08:27:01 <lambdabot> -- f cannot be realized.
08:27:01 <lambdabot> Unknown command, try @list
08:27:02 <byorgey> wolverian: first, since the function is defined for lists, you know you need two cases: one for the empty list, and one for the case (x:xs).
08:27:05 <Japsu> @check let f (_, (_, a)) = a; g = snd . snd in \x -> f x == g x
08:27:06 <lambdabot>  Add a type signature
08:27:08 <Japsu> bah
08:27:51 <byorgey> wolverian: in the (x:xs) case, you think, "well, I'll probably need to call inits recursively on xs.  once I do that, how can I combine the recursive result of (inits xs) with x to get what I want?"
08:28:45 <byorgey> wolverian: the magic of recursion is that you can *assume* that your function works correctly in the recursive case, and use that to build your function =)
08:28:59 <byorgey> as long as you've defined the base case correctly, induction takes care of the rest.
08:29:25 <BMeph> wolverian: Think about what it would do with various cases, then see what pattern you can see between the input and the output.
08:29:32 * sioraiocht is amused by djinn now that he understands the Curry-Howard Correspondence. 
08:29:39 <tetha> structural induction is madly powerful :)
08:29:55 <byorgey> tetha: indeed =)
08:29:59 <Sizur> how about instance recursion
08:30:11 <Valodim> umm, quick question? how do I get the square root of an Int, as an Int?
08:30:28 <Sizur> :t sqrt
08:30:29 <lambdabot> forall a. (Floating a) => a -> a
08:30:35 <byorgey> > floor . sqrt . fromIntegral $ (5 :: Int)
08:30:37 <lambdabot>  2
08:30:41 <Valodim> floor and sqrt have completely different classes, how do I get that back to a simple int?
08:30:44 <scodil> is there a way to do something like the WriterT monad transformer, but from the outside I can tell it to ignore all the written information, so that it just turns back into the normal inner monad? So I can write all my stuff in the WriterT-transformed monad, but easily turn the writing on and off?
08:30:44 <tetha> but ok, in general, thinking about a well structured world in a well structured way is powerful ;)
08:30:53 <wolverian> thanks again, all. it was just surprisingly inductive and I was thinking in more of an imperative way.
08:31:01 <quicksilver> Valodim: floor gets you back to Integral, of which Int is a member
08:31:11 <quicksilver> Valodim: so, floor gives you an int if that's what you want.
08:31:26 <Valodim> right, I would have expected floor (sqrt num) to work, where num is an Int
08:31:33 <byorgey> Valodim: also note that you must call fromIntegral on the Int first, because sqrt can't be applied to Integral types.
08:31:39 <quicksilver> no, because ints aren't floating
08:31:41 <byorgey> :t sqrt
08:31:42 <lambdabot> forall a. (Floating a) => a -> a
08:31:48 <quicksilver> and sqrt is Floating a => a -> a
08:31:54 <Valodim> alriight, thank you
08:31:59 <quicksilver> that's what the fromIntegral is for.
08:32:07 <quicksilver> plus a bit of magic defaulting
08:32:09 <byorgey> Valodim: the only reason you can say something like (sqrt 5) in other languages is that the 5 *implicitly* gets converted to Double, or whatever
08:32:18 <byorgey> Valodim: in Haskell, you must explicitly declare that conversion.
08:32:20 <quicksilver> (It doesn't know which floating instance to pick, so it picks Double by default)
08:32:50 <Valodim> not necessarily, sqrt can be defined for integers only just as well
08:32:52 <Valodim> works now
08:32:54 <Valodim> great
08:32:59 <quicksilver> yes, it could
08:33:03 <quicksilver> it just happens that it isn't :)
08:33:17 <quicksilver> I wasn't arguing abotu what sqrt *could* be. just pointing out what it is.
08:33:24 <Valodim> yeah I see
08:33:26 <byorgey> scodil: I don't understand.  Why would you need to do anything special in order to ignore the Writer monad?
08:33:53 <quicksilver> :t runWriterT
08:33:54 <lambdabot> forall w (m :: * -> *) a. WriterT w m a -> m (a, w)
08:33:58 <scodil> byorgey: i guess i don't. premature optimization.
08:34:04 <quicksilver> :t fst `fmap` runWriterT
08:34:05 <lambdabot> forall a w a1. WriterT w ((,) a) a1 -> a
08:34:09 <quicksilver> scodil: there you are :)
08:34:17 <quicksilver> erm, not quite
08:34:26 <tetha> btw: the next time, someone wants me to implement faculty, Ill implement the gamma function. Just to state this.
08:34:28 <quicksilver> :t (fmap fst) .` runWriterT
08:34:29 <lambdabot> parse error on input ``'
08:34:32 <quicksilver> :t (fmap fst) . runWriterT
08:34:33 <lambdabot> forall w (m :: * -> *) a. (Functor m) => WriterT w m a -> m a
08:34:35 <byorgey> Valodim: well, that's true.  I should point out also that this method (floor . sqrt . fromIntegral) works for Ints, but not for Integers -- the conversion to Double and back means that if the Integer is too large you might lose information in the conversion.
08:34:37 <quicksilver> scodil: try that one :)
08:34:50 <quicksilver> scodil: (fmap fst) . runWriterT ==== "ignore the writer"
08:34:57 <byorgey> Valodim: there are ways to write a purely integral square root function that doesn't have that problem, though.
08:35:07 <Valodim> \wouldn't an explicit cast just truncate the number?
08:35:16 <byorgey> Valodim: yes.
08:36:48 <Valodim> so... how would I do that with Integrals?
08:37:13 <Valodim> if not with fromIntegral?
08:38:38 <quicksilver> well you'd have to write an integer square root algorithm
08:38:44 <quicksilver> there isn't one in the ghc standard lib
08:38:52 <quicksilver> although there might be one lying around somewhere.
08:39:06 <Valodim> ugh
08:39:22 <quicksilver> I'd probably write something really naive using binary chop.
08:39:28 <quicksilver> but I know nothing about numerical algorithms.
08:39:38 <tetha> couldnt you just throw your integer-argument into the floating-point-sqrt, loook if thats an integer and return Just result in that case, or Nothing otherwise?
08:39:46 <byorgey> Valodim: there's an example implementation near the bottom of http://www.haskell.org/haskellwiki/Generic_number_type
08:39:48 <lambdabot> Title: Generic number type - HaskellWiki
08:39:51 <quicksilver> tetha: that doesn't help with the loss of precision case
08:40:04 <quicksilver> tetha: if the number is too large to fit in a Double with full accuracy
08:40:12 <quicksilver> > 2^56
08:40:17 <lambdabot>  72057594037927936
08:40:24 <quicksilver> ^^ larger than that, if Doubles do indeed have 56 bit mantissa
08:40:29 <quicksilver> I don't remember with confidence.
08:40:30 <byorgey> tetha: and in general, the idea of an 'integer square root' function would be to return the floor of the square root.
08:40:32 <tetha> ah, indeed
08:41:11 <byorgey> the basic idea is to use newton's method, but with integer arithmetic
08:41:18 <quicksilver> yeah, looks fine
08:41:26 <quicksilver> although can't you use the Double approximation as a seed?
08:41:28 <Valodim> where do you get the ^56 from? isn't int limited to 2^29-1?
08:41:31 <quicksilver> should save you quite a few steps
08:41:37 <quicksilver> Valodim: it was Double I was talking about.
08:41:42 <Valodim> oh
08:41:49 <quicksilver> floor . sqrt . fromIntegral doesn't go via Int
08:41:54 <quicksilver> but it does go via Double
08:42:46 <Valodim> ok
08:43:49 <BMeph> If real number sets are dense, then why are the real aproximations "Floats"? ;)
08:45:06 <byorgey> quicksilver: true, that should work I think
08:45:49 <byorgey> quicksilver: hm, what happens if you call fromIntegral on an Integer that is bigger than the largest representable Double?
08:46:16 <toRational> is there a foldl equivalant for IArray?
08:46:41 <byorgey> > fromInteger (10^5000) :: Double
08:46:42 <lambdabot>  Infinity
08:46:52 <byorgey> aha
08:47:32 <byorgey> > floor (fromInteger (10^5000) :: Double)
08:47:33 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
08:47:48 <byorgey> > floor (fromInteger (10^6000) :: Double)
08:47:49 <Japsu> > floor Infinity
08:47:49 <lambdabot>   Not in scope: data constructor `Infinity'
08:47:50 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
08:48:03 <byorgey> > floor (fromInteger (10^7243) :: Double)
08:48:04 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
08:48:06 <byorgey> heh
08:48:23 <byorgey> I guess it would still be better than nothing, as approximations go =)
08:48:32 <tetha> now subtract the maximum integerrepresentable
08:48:44 <byorgey> tetha: hehe
08:49:35 <quicksilver> toRational: foldl . elems ?
08:49:46 <BMeph> I think for doubles, max_value is around 10^308
08:50:07 <BMeph> If I remember my specs right.
08:50:19 <quicksilver> BMeph: doesn't seem to be, because byorgey just got a meaningful answer from 10^7243....
08:50:28 <quicksilver> ah
08:50:37 <quicksilver> maybe that was int defaulting
08:50:40 <toRational> ah yes duh, thanks (needs to be a lazy thinker*
08:50:50 <quicksilver> erm
08:51:01 <byorgey> quicksilver: no, that was floor of Infinity =)
08:51:07 <quicksilver> ah
08:51:08 <quicksilver> weird
08:51:26 <quicksilver> > floor (fromInteger (10^5000) :: Double)
08:51:28 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
08:51:37 <tetha> thus, 1/0 is about that value
08:51:44 <quicksilver> > log (floor (fromInteger (10^5000) :: Double))
08:51:45 <lambdabot>  Add a type signature
08:51:48 <tetha> a little more, but at most 1 more
08:51:57 <quicksilver> > log . fromIntegral (floor (fromInteger (10^5000) :: Double) :: Integer)
08:51:59 <lambdabot>   add an instance declaration for (Num (a -> b))
08:52:05 <byorgey> > length . show $ (fromInteger (10^7243) :: Double)
08:52:06 <lambdabot>  8
08:52:07 <quicksilver> > log $ fromIntegral (floor (fromInteger (10^5000) :: Double) :: Integer)
08:52:08 <lambdabot>  Infinity
08:52:16 <quicksilver> doh
08:52:17 <byorgey> > length . show . floor $ (fromInteger (10^7243) :: Double)
08:52:18 <lambdabot>  309
08:52:25 <quicksilver> ah, BMeph is right :)
08:53:01 <byorgey> toRational: can't you just do a fold over the result of 'elems'?
08:53:13 <BMeph> No, http://en.wikipedia.org/wiki/IEEE_754 is right: â‰ˆ Â±1.7976931348623157Ã—10^308
08:53:14 <lambdabot> Title: IEEE 754-1985 - Wikipedia, the free encyclopedia
08:53:23 <Sizur> > length $ show $ 10^308
08:53:24 <lambdabot>  309
08:53:45 <byorgey> makes sense
08:53:55 <quicksilver> byorgey: it's probably not a very useful optimisation
08:54:08 <quicksilver> byorgey: likely, if you're concerned with the sqrt of large integers,
08:54:12 <byorgey> quicksilver: yeah, probably not I guess
08:54:20 <quicksilver> you don't particularly thinkg 10^308 is "large"
08:54:28 <byorgey> quicksilver: right =)
08:54:54 <quicksilver> you could get a first approximation by cutting the decimal expansion in two :)
08:55:20 <byorgey> heh, yup
08:55:51 <quicksilver> let decexpn = show n in read $ take (length decexp `div` 2) $ show n
08:58:05 <Sizur> how can i convert a 200 digit number form Integer -> Double -> Integer?
08:58:15 <Armored_Azrael> How do I parallelize IO monad actions without using unsafePerformIO ?
08:58:31 <Sizur> i loos precision somewhere at the digit 20!
08:58:34 <quicksilver> Armored_Azrael: forkIO
08:58:45 <quicksilver> Sizur: yes, because Doubles only have 56 bits of precision
08:58:58 <quicksilver> > (2^56)/(10^20)
08:59:01 <lambdabot>  7.205759403792793e-4
08:59:08 <quicksilver> hmm, not quite
08:59:24 <quicksilver> if I'm right about 56 it's actually more like the 17th digit :)
08:59:27 <quicksilver> > (2^56)/(10^17)
08:59:29 <lambdabot>  0.7205759403792794
08:59:34 <Sizur> length $ show $ 2^56
08:59:35 <quicksilver> yeah, 17th digit or thereabouts
08:59:41 <Armored_Azrael> quicksilver: Thanks, looks like exactly what I was trying to find.
09:00:00 <Sizur> > length $ show $ 2^56
09:00:00 <lambdabot>  17
09:00:33 <dons> huh, http://programming.reddit.com/info/63bz9/comments/
09:00:42 <dons> Armored_Azrael: IO actions, just with forkIO
09:00:53 <Sizur> alright. so to extract root 13 from a 200 digit number, i'd need to implement a power function for Data.Ratio?
09:01:23 <quicksilver> Sizur: or just knock up a quick Integer solver
09:01:33 <quicksilver> Sizur: using Binary chop or newton-rhapson
09:04:02 <dons> ?show ord
09:04:03 <lambdabot> "ord"
09:04:05 <dons> > ord
09:04:06 <lambdabot>  <Char -> Int>
09:05:02 <desegnis> There is â€œ?showâ€? :-)
09:06:47 <quicksilver> ?show 4+$
09:06:48 <lambdabot> "4+$"
09:06:53 <quicksilver> I'm not sure how useful that is :P
09:07:02 <quicksilver> maybe it's useful as part of a chain
09:08:14 <dozer> gha! I wish we had 1st class pattern cases
09:08:14 <Toxaris> > id
09:08:16 <lambdabot>  Add a type signature
09:09:44 <dons> written in haskell, PXSL Tools 1.0: Your ticket out of XML Hell
09:09:52 <dons> http://blog.moertel.com/articles/2007/12/17/pxsl-tools-1-0-your-ticket-out-of-xml-hell
09:09:53 <lambdabot> Title: PXSL Tools 1.0: Your ticket out of XML Hell, http://tinyurl.com/29n38w
09:11:54 <dons> quicksilver: so what library are you working on today :)
09:12:02 * dons complains that no new code was uploaded to hackage!?
09:13:28 <sioraiocht> @djinn ((a -> b) -> c
09:13:29 <lambdabot> Cannot parse command
09:13:30 <Traveler> gfg
09:13:36 <sioraiocht> @djinn (a -> b) -> c
09:13:36 <lambdabot> -- f cannot be realized.
09:13:47 <dons> you must realise that!
09:14:06 <sioraiocht> @djinn (a,(a -> b) -> c)
09:14:06 <lambdabot> -- f cannot be realized.
09:14:11 <sioraiocht> @djinn (a,(a -> b) -> c))
09:14:11 <lambdabot> Cannot parse command
09:14:24 <sioraiocht> orly?
09:14:25 <dcoutts_> dons: here's a list of packages that need uploading to hackage:
09:14:25 <dcoutts_> http://hackage.haskell.org/trac/hackage/wiki/CabalPackages
09:14:27 <lambdabot> Title: CabalPackages - Hackage - Trac
09:14:36 <sioraiocht> @djinn (a,a -> b -> c)
09:14:37 <lambdabot> -- f cannot be realized.
09:14:43 <sioraiocht> =p
09:14:59 <dcoutts_> dons: I deleted the old ones that were done but a couple are still not done, this is a very old page from when hackage was young
09:15:01 <dozer> mm - is it wrong to simulate ml-style module closures using records of functions?
09:15:08 <dons> ah ha
09:15:24 <dons> dcoutts_: did you see the new mmap for *lazy* bytestrings :)
09:15:30 <dons> its rather interesting
09:15:35 <dcoutts_> dons: in particular the uulib and uuagc are not on hackage and they should be, someone needs to pester them
09:15:43 <dons> uulib would be useful.
09:15:48 <dcoutts_> dons: the bytestring-mmap package you uploaded the other day?
09:15:58 <dons> yeah, but it has a new module.
09:16:03 <dcoutts_> oh
09:16:04 <Zao> I don't suppose there's any wrapper for sendfile?
09:16:11 <dons> mmap a file, then unmap it chunk wise
09:16:14 <dons> as it goes out of scope
09:16:23 <dcoutts_> dons: oh, cunning.
09:16:35 <dons> so the finalizers unmap chunks.
09:16:40 <dons> of course, we need to convince the GC to run... :)
09:16:53 <dons> http://code.haskell.org/~dons/code/bytestring-mmap/System/IO/Posix/MMap/Lazy.hs
09:16:53 <lambdabot> http://tinyurl.com/2whzpf
09:17:05 <dcoutts_> dons: hmm, I hear that munmap is expensive, flushes page tables etc, have you seen memadvise?
09:17:22 <dons> i've looked at it. couldn't get any speedup. but perhaps i wasn't using it correctly
09:17:32 <dons> in terms of MADV_DONTNEED ?
09:17:42 <dons> or MADV_FREE ?
09:17:45 <dcoutts_> dons: memadvise (or a function with a name like it) can tell the VM that some range is not needed in memory anymore without upsetting the page tables and requiring TLB flushes I think
09:17:53 <dons> ah ha.
09:18:07 <dcoutts_> dons: oh, you did try it?
09:18:20 <dons> no, only MADV_SEQUENTIAL, to tell the vm to start prefetching (i think..)
09:18:42 <dons> its very interesting, connecting a lazy pure language to this strange lazy pure io system in the kernel
09:19:10 <dcoutts_> dons: posix_madvise(3P)
09:19:16 <dons> yep. i wrote a binding to it last night
09:19:22 <dcoutts_> ok
09:19:28 <dons> i'll try out some ideas later today for these free-ing hints
09:19:40 <dcoutts_> dons: btw, it'll be different on BSD vs Linux
09:20:02 <dcoutts_> dons: linux only just started following the posix_madvise hints
09:20:14 <dcoutts_> posix allows them all to be nops
09:20:20 <quicksilver> dons: it might be fairly hard to build test cases which actually exhibit the problem behaviour :)
09:20:37 <quicksilver> since haskell finalizers are triggered by memory shortage in the haskell heap
09:20:49 <quicksilver> but page flushes are triggered by shortage in the VM...
09:20:59 <quicksilver> very interesting, though
09:23:29 <dons> quicksilver: yes, its hard to get  the GC to run.
09:23:33 <dons> quicksilver: consider this program, http://code.haskell.org/~dons/code/bytestring-mmap/tests/fast-cp.hs
09:23:34 <lambdabot> http://tinyurl.com/37x3bl
09:23:40 <dons> it does basically no allocatoin in the haskell heap
09:23:45 <dons> yet you can happily copy a 1G file.
09:23:57 <dons> so you have to do your own finaliser calls
09:24:06 <dons> since there's not enough haskell heap pressure from the ForeignPtrs
09:24:21 <dcoutts_> dons: one wants to be able to assign costs to ForeignPtrs
09:24:27 <dons> usual issue with foreign resources not tracked acccurately
09:24:38 <dons> yeah, it would be nice if newForeignPtr (32k) ptr
09:24:40 <dons> worked as a hint
09:24:44 <dons> but then that complicates the heap check
09:25:16 <dcoutts_> JaffaCake: would it be technically feasible to attach resource hints to ForeignPtrs ?
09:25:42 <quicksilver> dons: yeah, it's the multiple open files hell over again
09:25:46 <quicksilver> dons: only more serious this time :)
09:25:55 <quicksilver> dons: because mapped memory is a very limited resource on 32 bit machines.
09:26:03 <dons> yep
09:26:09 <quicksilver> be lovely to get it right, of course
09:26:11 <quicksilver> really lovely.
09:26:30 <slrm> @pl flip (.)
09:26:30 <lambdabot> flip (.)
09:26:41 <quicksilver> slrm: (>>>) is flip (.)
09:26:55 <dcoutts_> JaffaCake: compare a ForeignPtr to a heap allocated block vs a ForeignPtr to a foreign allocated block of the same size, we'd like to attach a cost to the latter to make the GC try as hard as it does with the former
09:27:19 <slrm> thanks, quicksilver, i assumed there had to be a pipe operator but couldn't find it :)
09:27:42 <quicksilver> slrm: it's hidden in Control.Arrow
09:27:46 <quicksilver> sneaky...
09:28:39 <BMeph> quicksilver: All sorts of sneaky goodness is found in Control.Arrow. Tricksy Haskellses... ;)
09:28:49 <quicksilver> yeah
09:28:57 <quicksilver> tricksy haskellses took my precious combinator
09:29:01 <slrm> ah, (->) is an instance of Arrow. of course
09:30:15 <slrm> brilliant. thanks.
09:34:32 <mauke> @unpl ( ^ ) ( ^ )
09:34:33 <lambdabot> (^) (^)
09:36:26 <roconnor> @type (^) (^)
09:36:29 <lambdabot> forall a b b1. (Integral b, Num a, Integral b1, Num (a -> b -> a)) => b1 -> a -> b -> a
09:36:35 <vincenz> hi
09:36:44 <quicksilver> welcome back to the real world, vincenz
09:36:59 * vincenz chuckles :)
09:37:19 <vincenz> How's life been in #haskell
09:37:51 <dcoutts_> @yarr!
09:37:52 <lambdabot> Eat maggoty hardtack, ye unkempt, jenny frequentin', son of a gun.
09:37:55 <dcoutts_> vincenz: pretty good :-)
09:38:01 <vincenz> Good to hear :)
09:47:52 <bench> anyone with experience of haxml?
09:48:19 <bench> I'm getting output like this :<PostInfo\n      ><string\n        >1995</string\n      >
09:48:56 <monochrom> Yes, it does that.
09:49:51 <bench> I have data PostInfo {title:string, ...}, and was hoping for something like <PostInfo> <title> blah </title> ...</postInfo>
09:50:08 <bench> monochrom, why is that? especially the \n
09:50:46 <Igloo> To make the tree structure visible
09:52:14 <doserj> This way there is no potentially dangerous whitespace in the text nodes
09:52:54 <doserj> or, if there is, it really should be there, and not be skipped when parsing...
09:53:47 <bench> ok, sort of make sense, but it is very ugly to read -- what tools do you use to visually inspect it?
09:54:28 <bench> is there a way to get <title/> tag out of it w/o having to restructure my data PostInfo definition?
09:55:47 <nolrai> @ty randomR
09:55:49 <monochrom> putStrLn renders <PostInfo\n      ><string\n        >1995</string\n      > nicely
09:55:49 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
09:56:37 <monochrom> You are in HaXML. You can use it to write functions that transforms <string> to <title> whenever it is inside <PostInfo>.
09:59:30 <bench> monochrom, thanks for the putStrLn tip
10:00:11 <bench> monochrom, since i'm a newbie, how do you translate? especially there are multiple field in PostInfo that are of string type?
10:00:30 <doserj> you might also look at Text.XML.HaXml.Verbatim, not sure if it helps, though
10:00:45 <monochrom> Oh, multiple fields of string type, that is harder.
10:01:33 <monochrom> I will leave it at: You can write code to translate, but it takes more learning of HaXML.
10:03:03 <bench> the way the example is shown, i'd have to define newtype for title, etc, which means changing a lot of code
10:03:11 <Saizan_> well at that point the easiest thing is to write the conversion yourself
10:03:50 <monochrom> Haskell2Xml and DrIFT should be mapping your data PostInfo = ... { title: String, ... }  to  <PostInfo><title>...
10:04:32 <bench> Saizan, you meant writing my own show instance?
10:04:45 <bench> monochrom, i used haxml and DrIFT, that's the result shown
10:05:06 <Saizan_> no, the function PostInfo -> Xml
10:05:20 <Saizan_> instead of using DrIFT i mean
10:06:09 <malcolmw> you could even take the code generated by DrIFT and tweak it in minor ways to get what you want.
10:06:13 <monochrom> Yuck.
10:06:36 <bench> malcolm, the gen-ed code i thought shouldn't be touched
10:06:54 <bench> but haxml is a disappointment -- maybe i'm not using it right
10:07:27 <malcolmw> bench: what is it you want to do?
10:08:45 <bench> maclomw, I have this data that i want to output xml of the format <postInfo> <title>blah </title> <time>..</time> .. </postInfo>
10:09:21 <bench> but haxml gave me <postInfo> <string>..</string> <string>..</string>..
10:09:40 <malcolmw> bench: so the data is defined as Haskell types, and you just want to show it in a particular format?
10:09:49 <bench> yes
10:10:05 <malcolmw> and how are your types defined?
10:11:53 <bench> data PostInfo = {title:String, ...}
10:12:32 <bench> the example shows that i have to do newType Title = Title String, i think to get the <Title> tag, but that means
10:12:39 <bench> changing my existing code, etc
10:15:27 <malcolmw> bench: monochrom is right, DrIFT ought to generate the code to make the <title> tag, but it does not
10:16:31 <bench> malcolm, ok, so maybe i shuold be disappointed at DrIFT rather than haxml
10:16:45 <Armored_Azrael> Is there a way to perform IO actions under a State monad action?
10:17:07 <mauke> Armored_Azrael: sounds like you want StateT IO
10:18:39 <Armored_Azrael> mauke: Yes, thanks, that's what I was looking for.
10:19:03 <bench> mocolm/monochrom, anything else that would do what i want?
10:19:10 <mauke> btw, you can get perl 5.10.0 here: http://thepiratebay.org/tor/3938859 </random announcement>
10:19:10 <lambdabot> Title: perl-5.10.0.tar.gz - The Pirate Bay
10:20:08 <dozer> so, I can say 'f = [a] ++ listOfA' - how would I do the same thing in MonadPlus?
10:20:32 <mauke> return a `mplus` listOfA?
10:20:34 <malcolmw> bench: well, you could post-process the generated XML with a combinator script in HaXml, to convert "PostInfo/string" into "PostInfo/title"
10:21:32 <dozer> mauke: and that's the same as: (return a) `mplus` (listofA) ?
10:21:35 <Saizan_> malcolmw: but he has multiple fields of type String
10:21:39 <malcolmw> bench: but you would also need the inverse script, if you want to round-trip the XML back into your program
10:22:12 <mauke> dozer: yes, function application beats infix operators
10:22:15 <mauke> and (x) is just x
10:22:36 <malcolmw> Saizan_: whats the problem?  "postinfo/string[0]" -> "postinfo/title",   "postinfo/string[1]" -> "postinfo/time"  etc
10:24:09 <malcolmw> true, it is a bit ugly
10:25:14 <cognominal> cabal-install whines:  Setup.hs:22:15: Not in scope: `compilerPath'
10:25:15 <dozer> mauke: so I can replace [x] with return x, and a ++ b with a `mplus` b, and things should be OK?
10:25:23 <dozer> do I need to put this in a do-block?
10:26:11 <cognominal> ho. that's in yi Setup.hs
10:26:16 <Saizan_> dozer: no
10:26:19 <mauke> dozer: you sound a bit lost
10:26:34 <mauke> return x = [x] in the list monad
10:26:42 <mauke> likewise mplus = (++)
10:26:50 <mauke> so yeah, that change should just work
10:26:55 <mauke> do-blocks are never necessary
10:27:04 <dozer> mauke: I am - it's been a long week 0 and I'm getting lots of "Expecting m (x) Inferred m[x]" errors
10:28:00 <scodil> @type \x -> runST x
10:28:03 <lambdabot> Not in scope: `runST'
10:28:11 <scodil> @type \x -> Control.Monad.STrunST x
10:28:12 <lambdabot>     Not in scope: data constructor `Control.Monad.STrunST'
10:28:14 <scodil> @type \x -> Control.Monad.ST.runST x
10:28:15 <lambdabot>     Inferred type is less polymorphic than expected
10:28:16 <lambdabot>       Quantified type variable `s' is mentioned in the environment:
10:28:16 <lambdabot>         x :: GHC.ST.ST s a (bound at <interactive>:1:1)
10:28:19 <scodil> how do i do that?
10:28:32 <scodil> write a function that takes an ST action and runs it?
10:29:23 <mauke> you need an explicit type signature
10:29:29 <mauke> but why not just use runST?
10:29:43 <scodil> cause i'm going to do more than just run it
10:29:47 <scodil> some pre and post stuff
10:31:02 <scodil> like, \x  y -> runST (x >> y)
10:31:06 <scodil> is that possible?
10:31:14 <dozer> @type maybe mzero return
10:31:16 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => Maybe a -> m a
10:31:39 <alexj> anyone know how to download the entire hackagedb?
10:33:27 <mauke> :t let foo :: (forall s. ST s a) -> (forall s. ST s b) -> b; foo x y = runST (x >> y) in foo
10:33:29 <lambdabot> Not in scope: type constructor or class `ST'
10:33:29 <lambdabot> Not in scope: type constructor or class `ST'
10:33:29 <lambdabot> Not in scope: `runST'
10:33:32 <dons> alexj: you can scp it , if you have login access.
10:33:43 <dons> alexj: or perhaps just cabal install everything :)
10:33:45 <dozer> @type mapM
10:33:46 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
10:33:52 <mauke> :t let foo :: (forall s. Control.Monad.ST.ST s a) -> (forall s. Control.Monad.ST.ST s b) -> b; foo x y = Control.Monad.ST.runST (x >> y) in foo
10:33:53 <lambdabot> forall a b. (forall s. GHC.ST.ST s a) -> (forall s. GHC.ST.ST s b) -> b
10:33:59 <mauke> scodil: yes
10:34:37 <Nafai> Hey alexj, what's new in the world of HApps?
10:34:40 <scodil> ah ok you have to forall the s for each argument
10:34:46 <alexj> dons: I did a big refactor of the searchpath code last night so it now knows how to pull tagged darcs/svn/cvs repos.  I figure it would also be nice if it could hunt for stuff in hackagedb.
10:35:22 <dons> so hackagedb is just a flat file system layout
10:36:13 <alexj> Nafai: new version of searchpath hopefully in a few hours.  new webmonad for nice web interface.  happs-state now provides global access to your app state via tha typesystem with ACID guarantees.  hope to  do a nactual release soon.
10:36:22 <alexj> dons: yes, would like a flat file.
10:36:42 <Nafai> alexj: Awesome!
10:37:40 <dcoutts_> alexj: hackage uses a fairly simple directory layout and a .tar.gz index format consisting of a dir of .cabal files
10:38:07 <dcoutts_> alexj: there is code in cabal-install you might like to pinch that reads the index format
10:38:32 <dcoutts_> but it's a "standards based" index format so you don't need special code
10:39:15 <alexj> dcoutts: cool but is there a url to retrieve the current index and exposed modules or will I need to crawl?
10:39:18 * BMeph hugs his "standards-based"-based standards
10:39:42 <dcoutts_> alexj: yes, the index has a "well known" stable url
10:40:10 <dcoutts_> alexj: it's just a structured collection of .cabal files, so you'd have to crawl to find the exposed modules of each package
10:41:04 <dcoutts_> alexj: one warning though, reading the content of all the .cabal files in the index takes several seconds even on a fast machine. If you find you need to read it a lot you might prefer to extract the data you need into some other format.
10:41:19 <alexj> that is what I was thinking.
10:41:45 <dcoutts_> alexj: that's basically because the .cabal file parser is slow and the index has hundreds of them
10:41:46 <alexj> and I don't we want everyone who may be running searchpath to pull all those files each time.
10:41:51 <nolrai> so, for a newbie who knows nothing of linux and only a little haskell, what libs would you use for graphics and graphic UI on Ubuntu?
10:41:58 <dcoutts_> nolrai: gtk2hs
10:42:08 <dcoutts_> @where gtk2hs
10:42:08 <lambdabot> http://haskell.org/gtk2hs/
10:42:20 <nolrai> dcoutts++
10:42:29 <alexj> dcoutts: ok will think about it.
10:42:34 <dcoutts_> nolrai: try the glade tutorial on the gtk2hs website
10:42:50 <alexj> dcoutts: I think I need new code running on hackage that exposes the info I need.
10:43:31 <dcoutts_> alexj: for cabal-install we have this problem for "cabal list", we might have to generate a special compact search index each time we sync the hackage index
10:44:11 <dcoutts_> alexj: we solve it at the moment by only parsing the .cabal files for the ones we end up showing in the "cabal list" output, so if your search only returns a few it's fine.
10:44:17 <dcoutts_> ie we do it lazily
10:44:35 <alexj> ok can I search by exposed module?
10:44:50 <dcoutts_> alexj: so you might want to do something like that, when you sync the hackage index, write out a separate compact searchable index file
10:45:13 <dcoutts_> then you only have to do that once when downloading the hackage index, not on every search
10:45:20 <alexj> I'd rather have a map file like http://searchpath.org/default2.map
10:45:58 <dcoutts_> alexj: unfortunately, packages can change their exposed modules depending on the environment (eg compiler, os)
10:46:10 <alexj> All I need is the module base and the baseURL or repoURL.
10:46:38 <dcoutts_> alexj: how do map files deal with overlap?
10:46:47 <alexj> the first one wins.
10:47:02 <alexj> exactly the same as a set of directories supplied with -i
10:47:07 <dcoutts_> alexj: well I'm sure you can generate a map file from the hackage index
10:47:25 <dcoutts_> alexj: and that could be done each time you sync the hackage index
10:47:33 <scodil> does anyone know of a way to lock an STArray so you can unsafeThaw it and make a few small changes, change it back, and not mess up any threads that might be reading that array?
10:47:56 <alexj> dcoutts: new packages are added to hackage all the time, I'd like hackage just to serve the correct mapfile.
10:48:16 <alexj> I don't want to maintain a separate mapfile that is periodically synchronized.
10:48:23 <dcoutts_> alexj: well presumably you don't download them all the time anyway
10:48:42 <alexj> each user of searchpath will pull their own.
10:48:51 <alexj> and yes it gets pulled pretty frequently.
10:48:55 <dcoutts_> alexj: also at the moment, the packages are only in .tar.gz format, not unpacked, so searchpath would have to grok .tar.gz
10:49:12 <alexj> yeah working on that now for searchpath hence this discussion.
10:49:27 <nolrai> dcouttss_: is there an easy way to install gtk2hs on ubuntu or do i have to figure out how to buid it from source?
10:49:39 <dons> dcoutts_: request: cabal update; mapM_ (cabal install) (ghc-pkg list)
10:49:43 <dons> i.e. a cabal upgrade
10:50:10 <dcoutts_> alexj: well, hackage-scripts is on darcs.haskell.org, you're welcome to add generation of the map file to the things that get done when packages are added to the repo
10:50:14 <alexj> searchpath now supports passing a repo command in the mapfile e.g. "darcs get --partial --tag=mytag http://some/repo myrepo"
10:50:25 <BMeph> scodil: make a copy and thaw, etc. the copy
10:50:26 <dcoutts_> dons: please file a feature request
10:50:32 <dons> ok
10:51:05 <alexj> dcoutts: ok.  may be sendigyou a patch file.
10:51:05 <SyntaxNinja> dons: no fair just echoing stuff here from #galois ;)
10:51:10 <dcoutts_> dons: and if you'd like to implement cabal list better too :-) currently it only lists available not installed packages
10:51:11 <scodil> BMeph: that kind of defeats the purpose of unsafeThaw
10:51:44 <SyntaxNinja> gr. also, the location of the --global flag is some kind of mysterious trick that I can't figure out
10:52:11 <dcoutts_> SyntaxNinja: for cabal-install?
10:52:29 <dcoutts_> nolrai: I have a suspicion that the current ubuntu gtk2hs is really old, like 0.9.10, so you'd want to build from source, but don't worry it's easy.
10:53:01 <dcoutts_> SyntaxNinja: try out the new cabal-install, it fixes all the command line handling weirdness
10:53:11 <SyntaxNinja> dcoutts_: OK
10:53:14 <dcoutts_> ie it puts --global in the right place
10:54:03 <dons> SyntaxNinja: i'm a cross domain component!
10:54:13 <dcoutts_> heh heh
10:54:26 <Armored_Azrael> Anyone know of a job control system with dependencies for haskell? I don't believe one exists, but I wanted to check quickly before I wrote one.
10:54:28 <toRational> are there any known problems with ghc glut on os x-- keep getting unknown glutSetOption even after installing freeglut several times and rebuilding ghc
10:54:39 <Armored_Azrael> (I checked hackage, but I might be blind)
10:55:02 <dcoutts_> dons: handling upgrades properly probably requires a rewrite of package dependency analysis
10:55:07 <dons> mm
10:55:21 <dons> Armored_Azrael: job control in the unix shell sense?
10:55:27 <dons> or for haskell threads?
10:55:38 <dcoutts_> dons: currently we have little control over whether to upgrade or use the installed version, currently it always prefers the installed version
10:56:29 <dcoutts_> SyntaxNinja: I've been cleaning up the hackage wiki today, removing old stuff
10:56:35 <Armored_Azrael> dons: The idea was to have IO actions with dependencies
10:56:57 <dcoutts_> SyntaxNinja: I'm pretty happy with the direction things are going, consolidating into just the Cabal lib, cabal-install tool and HackageDB
10:57:03 <Armored_Azrael> dons: i.e. a job would have an IO action to perform, an IO action to check if this job had already been completed, and a list of Job ID dependencies
10:57:21 <Armored_Azrael> dons: And then it would start jobs from a queue as processing power became available.
10:57:21 <dcoutts_> SyntaxNinja: I merged cabal-setup and cabal-upload into cabal-install in the past few days
10:57:41 <dcoutts_> Armored_Azrael: we're trying to write a system like that for Cabal
10:57:50 <SyntaxNinja> dcoutts_: excellent :)
10:57:56 <SyntaxNinja> I'm really impressed with the progress of everything
10:57:57 <dcoutts_> Armored_Azrael: you're basically after make in haskell, done properly
10:58:12 <Armored_Azrael> dcoutts_: I'll take that as an "It's not done yet." so me trying it is not a waste of time.
10:58:20 <SyntaxNinja>  cabal install cabal
10:58:21 <SyntaxNinja> cabal: user error (Unresolved dependencies: cabal -any)
10:58:22 <SyntaxNinja> haha!
10:58:44 <dcoutts_> SyntaxNinja: see the bug about package name case (in-)sensitivity
10:58:45 <Armored_Azrael> dcoutts_: No, for it to handle make-like behavior, it would need a couple other things, but thanks for the information.
10:59:10 <SyntaxNinja> are there Debian packages for ghc 6.8?
10:59:19 <dcoutts_> SyntaxNinja: not yet
10:59:35 <dcoutts_> you'll just have to switch to Gentoo ;-)
11:00:06 <SyntaxNinja> ha!
11:00:20 <SyntaxNinja> I did actually switch to Ubuntu, just between you & me
11:00:41 <dcoutts_> its haskell packages are much older sadly
11:00:59 <dcoutts_> we need to get someone to manage the ubuntu haskell packages properly
11:02:11 <nolrai> how would i install the GHC package: mtl?
11:04:36 <BMeph> scodil: Okay, you stumped me. I'd suggest you look at the blurb for unsafeThaw in Data.Array.MArray, and see if your array changes can be atomically encapsulated like it demands.
11:04:53 <dcoutts_> nolrai: see hackage.haskell.org
11:05:18 <scodil> BMeph: yeah they can. I make some invertible transformations, record them, play them back after I'm done.
11:05:45 <nolrai> thanks
11:05:53 <scodil> its not like anything i'm doing is at all parallelizable, i just was wondering how one would lock an STArray
11:06:24 <scodil> or lock and ST action, in general
11:06:30 <scodil> lock an ST action, even
11:06:46 <scodil> i suppose you're not supposed to be able to, since all mutable state is internal
11:06:58 <scodil> but unsafeThaw breaks that
11:08:02 <BMeph> scodil: I think if it's "locked", it's done through an STM-style atomic access.
11:08:38 <scodil> yeah i guess you'd lock the array out in IO when you spawn the threads
11:09:06 <shivernz> hi there. having some problem install the imlib library on ghc 6.8.1. I get this error on the build step of the install: Could not find module `Data.Array': it is a member of package array-0.1.0.0, which is hidden
11:09:33 <shivernz> i've checked and i definitely do have array-0.1.0.0
11:09:43 <Saizan_> shivernz: add array to build-depends in the .cabal file
11:09:48 <mauke> you need to add it to the .cabal file
11:09:58 <shivernz> cool, ill give it a go
11:10:48 <newsham> romanians always trying to get at your blood
11:11:02 <mauke> what the
11:11:05 <shivernz> worked, thanks :)
11:11:06 <Saizan_> shivernz: and possibily send a mail(or better a patch) to the mantainer regarding this
11:11:24 <BMeph> scodil: (quoting the Haddock generation in Data.Array.MArray, of "unsafeThaw":) "If you use an unsafeThawwriteunsafeFreeze sequence in a multi-threaded setting, then you must ensure that this sequence is atomic with respect to other threads, or a garbage collector crash may result (because the write may be writing to a frozen array)."
11:11:57 <BMeph> Err, call it unsafeThaw/write/unsafeFreeze sequence.
11:12:04 <shivernz> Saizan_, will do
11:12:11 <scodil> ah ok
11:20:14 <newsham> the best thing about haskell -- on its mailing lists, a set of silly questions from some newbie can 'degenerate' into a discussion of the mathematical model of functions and which might be appropriate for haskell
11:20:22 <newsham> in most mailing lists discussions degenerate to the minimal educational level of the participants.  on haskell it goes to the maximum.
11:20:52 <SyntaxNinja> oh, and another thing... when I intsall a new GHC, I shoul dhave  a way to tell cabal install to go rebuild all the old packages for my new release :)
11:20:56 <Saras> http://agui.myminicity.es/ind/ jpg ex girlfriend join in
11:20:57 <Saras> http://agui.myminicity.es/ind/ jpg ex girlfriend join in
11:20:57 <Saras> http://agui.myminicity.es/ind/ jpg ex girlfriend join in
11:20:58 <Saras> http://agui.myminicity.es/ind/ jpg ex girlfriend join in
11:20:59 <Saras> http://agui.myminicity.es/ind/ jpg ex girlfriend join in
11:21:01 <Saras> http://agui.myminicity.es/ind/ jpg ex girlfriend join in
11:21:04 <MyCatVerbs> newsham: though it is still sort of a degeneration, since the set of people who can ffollow the discussion decreases rapidly.
11:21:23 --- mode: ChanServ set +o SyntaxNinja
11:21:27 <newsham> both can be entertaining, one is also educational
11:21:52 <bench> how do you break long line in haskell into multiple lines-- meaning i want to type one line, but it's too long for 80 columns
11:22:35 <newsham> depends on what you mean by break... do you need to find a whitespace on which to break?
11:22:45 <newsham> or are you just gonna inject a newline every 75 characters?
11:23:12 <monochrom> Call me an elitist, but I prefer the level to go up. The world has too much sentiment of "don't push anyone to learn more".
11:23:35 <MyCatVerbs> bench: indent the broken-off bit.
11:23:49 <newsham> monochrome: the downside is that you never hit godwin's law and your thread may not terminate.
11:23:57 <bench> MyCatVerbs: so a ++
11:23:59 <bench> "b"
11:24:04 <bench> in two lines would work?
11:24:11 <bench>  i thought that it wouldn't
11:24:18 <MyCatVerbs> bench: almost. You'll want to indent the "b" there.
11:24:33 <monochrom> I think non-termination is an upside. Liveness.
11:24:40 <MyCatVerbs> bench: So that the compiler can see what's going on. Haskell uses the indentation quite nicely.
11:25:02 <MyCatVerbs> monochrom: well, it's the Haskell crowd that're currently most enamoured with TFP's distinction between data and codata.
11:25:11 <MyCatVerbs> Discussions on #haskell-cafe are anamorphisms. ^_^
11:26:00 <monochrom> Actually, the thread terminates when everyone has learned category theory.
11:26:06 <MyCatVerbs> Plus, with a good mail reader, you can read haskell-cafe lazily, so who cares that it's infinite? ;)
11:26:22 <monochrom> A good mail reader is a must.
11:26:40 <MyCatVerbs> monochrom: not so. Someone then crops up and brings numerical analysis into it...
11:27:07 <tetha> monochrom: thus, every discussion on a haskell mailing list converges against nazi comparisions or understanding of category theory? interesting. Can we solve some NP-hard problems faster knowing that?
11:27:14 <newsham> monochrome: no, there are other theories higher in the lattice
11:27:23 <newsham> there is no least upper bound
11:27:42 <monochrom> Haha, I know that game. A thread terminates, a new thread starts. Every thread terminates, but there are more threads.
11:28:21 <bench> MyCatVerbs: thanks
11:29:59 <dcoutts_> SyntaxNinja: that's a nice idea, please add a feature request in the hackage trac so we do not forget
11:30:25 <MyCatVerbs> bench: no problem.
11:30:53 <SyntaxNinja> dcoutts_: :)
11:30:58 <dcoutts_> dons: and you've not added your request either I note :-)
11:39:57 <SyntaxNinja> dcoutts_: dons, I'm adding tickets
11:40:07 <dcoutts_> SyntaxNinja: thanks :-)
11:41:22 <dcoutts_> SyntaxNinja: btw, I moved the remaining relevant debian bugs into the hackage trac, doing it for the TODO list in the repo needs more thought, some of the TODO items are pretty vague
11:41:39 <dcoutts_> http://hackage.haskell.org/trac/hackage/ticket/2
11:41:41 <lambdabot> Title: #2 (move TODO stuff into this tracking system) - Hackage - Trac
11:41:56 <dcoutts_> SyntaxNinja: but it was nice to close but #1 :-)
11:41:56 <SyntaxNinja> dcoutts_: ok
11:42:00 <SyntaxNinja> heh
11:42:14 <SyntaxNinja> always feel free to break out tickets into more tickets.
11:42:20 <dcoutts_> sure, I do
11:42:25 <dcoutts_> it's easier said than done :-)
11:42:40 <SyntaxNinja> http://hackage.haskell.org/trac/hackage/ticket/197
11:42:41 <lambdabot> Title: #197 (implement cabal upgrade (installs new versions of all packages)) - Hackage ...
11:42:48 <SyntaxNinja> http://hackage.haskell.org/trac/hackage/ticket/198
11:42:50 <lambdabot> Title: #198 (cabal install foo should upgrade foo if there's a newer version) - Hackage ...
11:42:54 <SyntaxNinja> http://hackage.haskell.org/trac/hackage/ticket/199
11:42:56 <lambdabot> Title: #199 (when installing a new version of GHC, there should be a way to upgrade my  ...
11:43:01 <SyntaxNinja> was ther anything else?
11:43:09 <SyntaxNinja> these sound fun, now I want to hack on cabal.
11:43:23 <dcoutts_> SyntaxNinja: you're more than welcome to :-)
11:44:10 <dcoutts_> SyntaxNinja: I think those were all the ones you two just mentioned
11:44:51 <SyntaxNinja> cool.
11:45:01 <SyntaxNinja> dcoutts_: I'd love to. maybe I'll get some time this week.
11:46:26 <dcoutts_> SyntaxNinja: I think it'd be useful if we kept a bug search report of a list of bugs/tasks that we think would be useful now and doable by contributers
11:46:38 <dcoutts_> SyntaxNinja: we can use a trac report to keep that list up to date
11:46:57 <dcoutts_> and we should make it prominent on the website
11:53:08 <Saizan_> dcoutts_: has build-dep been removed for a particular reason or?
11:53:09 <SyntaxNinja> yeah.
11:53:37 <SyntaxNinja> you could add a "blocked" field or something and then just do a query on difficulty
11:53:39 <dcoutts_> Saizan_: I'm not sure what you're referring to
11:53:56 <dcoutts_> SyntaxNinja: blocked?
11:54:09 <dcoutts_> SyntaxNinja: we can already mark things as easy
11:54:11 <SyntaxNinja> dcoutts_: like, not doable now
11:54:23 <dcoutts_> ah, I see
11:54:25 <SyntaxNinja> dcoutts_: right, so difficulty + whether or not it's blocked by some other bug
11:54:33 <SyntaxNinja> bugzilla has bug dependencies, but trac doesnt'
11:54:37 <SyntaxNinja> at least not built in
11:54:45 <Saizan_> dcoutts_: at some point cabal-install had a build-dep command, that would take a .cabal file and try to install the deps, useful when you need to install something from a repo
11:55:06 <dcoutts_> I was thinking of a positive rather than negative tag, perhaps we should use a special bug keyword for ones that could be done by anyone and do not require further discussion
11:55:25 <dcoutts_> Saizan_: I don't recall that
11:55:54 <dcoutts_> Saizan_: cabal install in an unpacked build dir will probably do what you want though
11:56:10 <dcoutts_> Saizan_: it installs the deps and tries to configure, build and install the current package
11:56:27 <dcoutts_> though it will re-configure which may not be what you want
11:56:37 <dcoutts_> we need proper dependency infrastructure to avoid that
11:57:01 <Saizan_> ah, nice, can i tell it to use sudo when installing?
11:57:14 <dcoutts_> Saizan_: only if you use --global
11:57:23 <dcoutts_> by default it does per-user installs
11:57:32 <SyntaxNinja> dcoutts_: right, that'd be fine. and you could do it as a checkbox
11:57:52 <SyntaxNinja> dcoutts_: what do you think of checking if we're root and installing as --global in that case?
11:58:03 * Saizan_ upgrades cabal-install
11:58:11 <SyntaxNinja> or maybe ch3ecking if we have write permission to the global config file or something
11:58:26 <dcoutts_> SyntaxNinja: we have an open bug on that, but it's remarkably difficult to check if you are root in a portable way
11:58:35 <SyntaxNinja> yeah, I figured :(
11:58:48 <SyntaxNinja> it's not a well formed concept I guess
11:58:57 <SyntaxNinja> and sudo does strange things
11:59:58 <dcoutts_> SyntaxNinja: if you have any suggestions, add them to http://hackage.haskell.org/trac/hackage/ticket/59
12:00:00 <lambdabot> Title: #59 (cabal-install should default to --user-install when running as non-root) -  ...
12:00:15 * SyntaxNinja &
12:00:19 <dcoutts_> SyntaxNinja: or actually we should open a new bug, that one is closed and was a the dual of the issue
12:01:14 <dcoutts_> Saizan_: so what behaviour would you like in relation to sudo?
12:01:53 <dcoutts_> Saizan_: if it's a coherent idea, add a feature request
12:02:38 <dcoutts_> Saizan_: do you mean that things should work sensibly if you sudo cabal install, or that cabal install should call sudo itself for the installation step?
12:04:45 <sieni> calling sudo implicitly is a bad idea, especially on e.g. mac os x, which stores the sudoing credentials in a magic place and does not immediately ask them again if you do something else as a superuser
12:04:48 <Saizan_> dcoutts_: the problem with sudo cabal install --global is that it builds etc.. with root privileges and it's annoying, so i'd like a flag to make it use sudo only on install
12:05:55 <Saizan_> dcoutts_: for "only on install" i mean only when copying and registering the files
12:06:01 <dcoutts_> Saizan_: how would you expect it to work?
12:06:09 <dcoutts_> how would you configure it, to say to use sudo
12:06:14 <dcoutts_> or to use su
12:06:45 <njbartlett> @seen Heffalump
12:06:46 <lambdabot> Heffalump is in #darcs and #haskell. I don't know when Heffalump last spoke.
12:07:32 <Igloo> Lots of Debian tools take -rsudo or --rootcmd=sudo
12:07:37 <dcoutts_> Saizan_: suppose you set something in the ~/.cabal/config to tell it to use sudo, then perhaps $ cabal install --global would then always use it at the install step?
12:07:50 <sieni> I think the best option would be for cabal to say on "cabal foo" that "can't complete the requested operation, please use 'sudo cabal foo' or run 'cabal foo' as root"
12:07:51 <dcoutts_> Igloo: do su and sudo behave the same in that respect?
12:08:14 <Saizan_> dcoutts_: i think that's sensible
12:08:33 <dcoutts_> sieni: discovering that is actually remarkably hard, testing for permissions without actually doing it
12:08:42 <Igloo> I think you'd need to use "su -c" and to either chop it up or run it through a shell
12:09:23 <dcoutts_> Saizan_: would you like to make a feature request with as much detail as seems helpful
12:09:23 <dcoutts_> http://hackage.haskell.org/trac/hackage/
12:09:54 <Igloo> I'm not sure if anyone ever uses su with the Debian tools, or if it's even possible. sudo and fakeroot are the two common ones
12:10:01 <sieni> dcoutts_: well, I don't categorically oppose that, I just pointed out that Mac OS X has a really strange sudoing behaviour by default
12:10:02 <dcoutts_> Igloo: ok
12:10:30 <dcoutts_> sieni: what's the odd OS X sudo behaviour?
12:10:43 <Saizan_> dcoutts_: ok, after i see how the new cabal-install looks like
12:10:52 <dcoutts_> Saizan_: thanks
12:11:00 <sieni> dcoutts_: if you do sudo something, then it asks for the password once and then it doesn't ask it anymore at least for a while
12:11:09 <Igloo> That's standard
12:11:11 <dcoutts_> sieni: that's pretty common I think
12:11:20 <dcoutts_> few minutes timeout
12:11:42 <sieni> dcoutts_: well it doesn't mean that it doesn't suck :-)
12:11:52 <Armored_Azrael> Why doesn't there seem to be anything like getProcessStatus for threads?
12:11:55 <Igloo> You can configure it differently if you want
12:12:05 <ddarius> Armored_Azrael: Because they aren't processes.
12:12:23 <dcoutts_> Armored_Azrael: what info would you want?
12:12:33 <Armored_Azrael> Wheter or not they have terminated.
12:12:38 <Armored_Azrael> *Whether
12:12:48 <sieni> Igloo: of course, but it's a big security hole
12:13:09 <Armored_Azrael> I suppose I could use the mvar hack described in Control.Concurrent, but that seems like a silly way of doing things.
12:13:10 <dcoutts_> Armored_Azrael: threads are more lightweight than that
12:13:39 <Armored_Azrael> OK
12:13:47 <dcoutts_> Armored_Azrael: if you want to know then use MVars etc, it's not a hack, it's the right thing to do
12:13:58 <dcoutts_> Armored_Azrael: of course if you're doing it a lot, make a little abstraction
12:14:53 <sieni> Igloo: plus that the authors of sudo are idiots anyway, like all those stupid messages that are hard coded in the binary
12:15:05 <dcoutts_> sieni: would you like to make a feature request for that idea, that on install it should check first if installing there is possible and give a nice error rather than trying and then failing with a bad error message
12:15:08 <Armored_Azrael> dcoutts_: It just seemed like a hack to add a step to the end of every thread so that I would know it was done, but I suppose it's not.
12:15:45 <dcoutts_> Armored_Azrael: you're used to heavyweight threads that have all features built-in even if you don't need them :-)
12:15:55 <sieni> dcoutts_: why not, where do I submit it?
12:16:04 <dcoutts_> sieni: http://hackage.haskell.org/trac/hackage/
12:16:06 <lambdabot> Title: Hackage - Trac
12:16:40 <dcoutts_> Armored_Azrael: it does not necessarily mean you need lots of extra code for each use of a thread since you can make reusable function for making the kinds of threads you want
12:16:52 <Saizan_> data Thread = T (MVar ()) ThreadId; forkIO' t = do m <- newEmptyMVar; id <- forkIO $ t >> putMVar m (); return (T m id); joinThread (Thread m _) = readMVar m; etc..
12:22:05 <sieni> Igloo: for example the lecture "We trust you have received the usual lecture from the local System Administrator. It usually boils down to these three things: #1) Respect the privacy of others. #2) Think before you type. #3) With great power comes great responsibility." is so annoying that I have to compile sudo myself with the lecture removed before I want to use sudo on a box
12:22:47 <roger`> sieni: I've only ever seen that message displayed once.
12:22:59 <roger`> usually, it's the first time you use sudo.
12:23:06 <sieni> roger`: on every machine you use sudo for the first time
12:23:13 <sieni> and it's equally annoying every time
12:23:26 <roger`> O_o how often are you changing machines?
12:23:40 <sieni> occasionally a hard disk might fail
12:23:48 <sieni> not that often anyway
12:24:07 <sieni> usually I prefer su anyway
12:24:33 <roger`> I don't use a root password, so I don't use su.
12:25:55 <sieni> of course passwords suck anyway, since publickeys with passphrases are superior anyway
12:25:57 <monochrom> Re-wire your brain so you are never annoyed by anything.
12:27:07 <sieni> monochrom: good thing, I might for example stop using computers. But then I wouldn't have much to eat
12:30:02 <ndm> @seen Igloo
12:30:03 <lambdabot> Igloo is in #ghc, #darcs and #haskell. I last heard Igloo speak 18m 7s ago.
12:30:10 <ndm> @seen dcoutts
12:30:11 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-overflow, #ghc, #darcs and #haskell. I last heard dcoutts speak 8h 43m 7s ago.
12:30:13 <monochrom> If you are not annoyed by anything, you have more to eat, not less.
12:30:16 <dcoutts_> @yarr!
12:30:17 <lambdabot> Drink up, me 'earties
12:30:23 <dcoutts_> hia ndm
12:30:50 <ndm> hi dcoutts_
12:30:54 <ndm> http://darcs.haskell.org/ghc-6.8/packages/parsec/parsec.cabal has tabs in it
12:31:01 <ndm> which the latest version of cabal rejects
12:31:11 <sieni> If I wasn't annoyed about things I wouldn't get much done
12:31:12 <ndm> did something go wrong? is this going to cause upgrade issues?
12:31:32 <Saizan_> dcoutts_: it seems that "cabal install" in an unpacked dir configures with --user but builds without adding those packages
12:31:43 <dcoutts_> ndm: have you checked when those got added?
12:32:57 <dcoutts_> ndm: it's clearly a bug, it would not build with the cabal that comes with ghc-6.8 or ghc-HEAD so it must have been added recently
12:33:37 <dcoutts_> ndm: it's this patch:
12:33:43 <dcoutts_> Thu Dec 13 13:40:53 GMT 2007  Malcolm.Wallace@cs.york.ac.uk
12:33:43 <dcoutts_>   * use cabal configurations to select modules to build with nhc98
12:33:55 <dcoutts_> not tested with current cabal
12:34:17 <ndm> dcoutts_ that would probably be it
12:34:22 <ndm> @slap malcolmw
12:34:22 * lambdabot pushes malcolmw from his chair
12:34:24 <dcoutts_> ndm: just push a patch to fix it
12:34:27 <Igloo> There were some tabs in it before then, so presumably it's only tabs in configurations that Cabal rejects?
12:34:35 <dcoutts_> Igloo: right
12:34:40 <dcoutts_> Igloo: it's backwards compatible
12:35:01 <dcoutts_> Igloo: only configurations are visually ambiguous with tabs
12:35:02 <ndm> dcoutts_ - do you want to? i don't really know what the tabs should be and don't know the cabal syntax enough to not screw it up
12:35:11 <dcoutts_> ndm: replace them with spaces
12:35:48 <dcoutts_> ndm: the cabal error message even tells you what to do :-)
12:35:57 <dcoutts_> cabal: parsec.cabal:18: Do not use tabs for indentation (use spaces instead)
12:36:00 <ndm> dcoutts_ - that error message  is horrid! will fix it up and push
12:36:43 <dcoutts_> ndm: you want it to do range compression? lines 19-25 ? :-)
12:37:04 <ndm> dcoutts_ - i couldn't give a flying frog :)
12:37:19 <ndm> i just want to generate haddock documentation, and i process out all the build-depends lines anyway!
12:37:48 <dcoutts_> ndm: hmm? you process out what?
12:37:59 <Igloo> You won't get cross-package links if you do that
12:38:29 <ndm> Igloo: don't care, i'm passing --hoogle, and this way i can build the docs with 6.6 or 6.8
12:38:50 <ndm> dcoutts_ my script opens each cabal file, and blanks any line starting build-depends
12:39:28 <dcoutts_> ndm: that will not work since they can flow to multiple lines
12:39:45 <ndm> dcoutts_ works enough for me so far, its a hacky script for hoogle, if it breaks i'll fix it up
12:40:10 <ndm> apart from the broken parsec, of course
12:40:11 <dcoutts_> ndm: how about integrating hoogle indexing into hackage so we get it for all packages
12:40:50 <ndm> dcoutts_ this is to hack it up enough so it works with hoogle 3, and to get an idea of what needs doing for 4
12:40:57 <dcoutts_> ok
12:42:05 <dcoutts_> ndm or Igloo: are you fixing parsec then?
12:42:43 <Igloo> I'm not
12:42:49 <ndm> i will if thats what people want
12:43:06 <ndm> but can't actually test the result, which got us into this mess
12:43:24 <dcoutts_> ndm: in this example if cabal parses it, it's ok
12:43:43 <dcoutts_> ndm: just those last tabs in last lines is enough to fix it
12:44:05 <dcoutts_> line 31-32
12:44:05 * ndm fixes parsec
12:46:36 <ndm> Warning: A package using section syntax should require
12:46:38 <ndm> "Cabal-Version: >= 1.2" or equivalent.
12:51:04 <ndm> should malcolm be pushing to ghc-6.8 branch? or head?
12:52:49 <ndm> dcoutts_ - i have the patch all fixed, what do i push to? ndm@darcs.haskell.org:/ghc-6.8/packages/parsec/ gives little luck
12:53:43 <dcoutts_> ndm: prepend /srv/darcs to that path
12:54:02 <dcoutts_> ndm@darcs.haskell.org:/srv/darcs/ghc-6.8/packages/parsec/
12:55:21 <ndm> pushed!
12:57:29 * dcoutts_ pulls and builds
13:00:07 <ndm> i now have parsec documentation for hoogle building fine
13:00:18 <dcoutts_> quick poll: what would people expect this to do: $ cabal info xmonad
13:00:18 <ndm> still a bit worried that malcolm is playing on the 6.8 branch though...
13:00:28 <ndm> give information about xmonad
13:00:38 <dcoutts_> what kind of info?
13:00:39 <Saizan_> dcoutts_: cabal install --help says --global is the default, while the behavior seems to imply --user, which is wrong?:)
13:00:42 <ndm> is it installed, which versions, what dependencies, is it on hackage
13:00:55 <dcoutts_> Saizan_: the --help text is wrong
13:00:56 <ndm> can it be upgraded wrt the hackage version
13:01:33 <dcoutts_> ndm: I agree, the current behaviour is to act like install but just not to do the install, so it tells you what it would install and in what order
13:01:39 <dons> dcoutts_: print out the .cabal file?
13:01:47 <dcoutts_> dons: right, that'd be sensible
13:01:57 <dcoutts_> so I think the current 'info' should be renamed
13:02:03 <dcoutts_> to make way for a sensible info
13:02:09 <ndm> i disagree - cryptic configuration data can be obtained using less
13:02:35 <dcoutts_> ndm: it can be a selection of useful info from the .cabal file and stuff like you suggested
13:02:44 <dcoutts_> perhaps even as a $ cabal install --pretend xmonad
13:02:48 <dons> yes, it should be a pretty printed selction of relevant data
13:02:51 <dcoutts_> rather than a top level command
13:02:54 <ndm> dcoutts_ - as long as its collected hilights, rather than a text dump
13:03:22 <dcoutts_> so what should we do with the current info command? it's clearly useful to be able to do a dry run
13:03:34 <dcoutts_> to say what would be installed without actually doing it
13:03:48 <dcoutts_> in gentoo we have: emerge --pretend foobar
13:09:27 <doserj> dcoutts: analyze?
13:09:56 <dcoutts_> doserj: is that from any existing package manager?
13:10:06 <doserj> don't think so :)
13:10:46 <dcoutts_> we should probably go for something that's common for package managers or --dry-run like darcs uses
13:11:10 <dcoutts_> make uses --dry-run
13:11:28 <doserj> aptitude has a -s option, for "simulate"
13:23:04 <glen_quagmire> is unsw the famous haskell college? or is this university something else?
13:23:35 <dons> unsw does teach haskell, yep.
13:23:46 <dons> and has a reasonable haskell research group,imo
13:23:48 <dons> :)
13:24:12 <glen_quagmire> oh i see. I found http://www.cse.unsw.edu.au/~pls/thesis-topics/ghcjava.html  so I was wondering..
13:24:14 <lambdabot> Title: Thesis Topic : Compiling Haskell to Java
13:24:24 <dons> yep, dive in.
13:24:39 <dons> you'd probably want to see what F# does, since that was proposed.
13:25:05 <Zao> What's the state of Visual Haskell by the way?
13:25:08 <Zao> Is it still alive?
13:25:35 <pejo> Zao, was some discussion about it on ghc-users the other day. Not updated for 6.8 yet apparently.
13:25:36 <Heffalump> yes, but it only works with GHC 6.6.1
13:25:47 <Zao> I see it's lacking 2008 support.
13:25:54 <Zao> Or at least doesn't have it advertised.
13:26:35 <dons> 2008??
13:26:58 <Heffalump> Visual Studio 2008.
13:27:04 <Zao> Sorry, Visual Studio 2008.
13:27:11 <Zao> The one that just was released.
13:27:34 <glen_quagmire> this looks like a good ide. I never tried. http://wiki.workingmouse.com/index.php/IntelliJ_IDEA_Haskell
13:27:36 <lambdabot> Title: IntelliJ IDEA Haskell - Workingmouse Wiki
13:28:01 <BMeph> Quick poser: For a one-shot operation, even though it's hideous and inefficient, there isn't a more efficient way to "snoc"  on a standard list than the regular "xs++[x]", right?
13:28:53 <smack_> BMeph: not for a list, no
13:29:07 <glen_quagmire> never mind. it doesn't seem to be feature rich
13:29:11 <smack_> you may want to consider Data.Sequence or building the list backward, though...
13:30:28 <BMeph> Right - if I were doing more than that one-time only change, I would.
13:31:26 <ndm> i wouldn't
13:31:27 <BMeph> I just wanted to make sure I wasn't overlooking some fun way to exploit <*>, <$>, or (.)$(.) ;)
13:31:38 <ndm> write stuff, profile, fix slow stuff
13:33:31 <nolrai> I installed gtk2hs and installed glade, and i can import Graphics.UI.Gtk fine, but i cant import Graphics.UI.Gtk.Glade. What is going on? is there somthing else i need to install?
13:33:56 <ndm> dcoutts, i probably just overwrote the gtk.txt file in hoogle - care to send me your local version?
13:33:59 <ndm> (woops!)
13:34:24 <ndm> dcoutts, never mind, had it in my clipboard buffer after all
13:35:24 <ndm> hmm, you might want to check it anyway, may have screwed it up previously
13:37:01 <dcoutts_> ndm: ok...
13:37:16 <dcoutts_> nolrai: perhaps you do not have the libglade development libs
13:37:44 <ndm> @seen dons
13:37:45 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 11m 9s ago.
13:37:57 <nolrai> dcoutts_: thanks! i will check.
13:37:57 <dcoutts_> nolrai: try running gtk2hs's ./configure --enable-libglade
13:38:06 <ndm> dons: http://www.cse.unsw.edu.au/~dons/lambdabot/State/where - this used to be a key,value pair file which hoogle grabbed and used, now its binary or junk
13:38:27 <dcoutts_> nolrai: by default it doesn't build the components where the corresponding system libs are not available
13:38:57 <dcoutts_> nolrai: using --enable-libglade will make configure fail if it cannot find the stuff it needs, rather than just ignoring it
13:39:19 <dcoutts_> nolrai: so that's the way to be sure when you rebuild
13:40:29 <nolrai> dcoutts_++
13:40:57 <dcoutts_> ndm: seems to be ok, though I need to send you an updated db since the current one points to the 0.9.10 release
13:41:40 <ndm> dcoutts_ whenever you owant, just email it over
13:41:52 <dcoutts_> ndm: ok
13:45:21 <bench`> is there a function that takes list and returns a list that has everything except the last element
13:45:31 <bench`> w/o using reverse, or take?
13:45:51 <dobblego> > init [1..10]
13:45:54 <lambdabot>  [1,2,3,4,5,6,7,8,9]
13:46:21 <bench`> let l = [1,2,3] in delete (last l) l
13:51:02 <dozer> it's official, the functions on Data are uber-slow
13:51:07 <toRational> glut issue was due to actionOnWindowClose... found in cafehaskell logs
13:52:01 <BMeph> dozer: Every one in Data, or just certain modules (i.e., just Set, and Sequence, but not Data.List)? ;)
13:52:40 <dozer> no, the introspection stuff - Data.Generic? extQ, gmapQ and friends
13:53:05 <ndm> dozer: seen Uniplate?
13:53:07 <Zao> I don't suppose anyone knows off-hand if the AIX GHC on the site was built with gcc or xlc?
13:53:18 <smack_> > toRational 3.14
13:53:18 <BMeph> Ah. Okay, that's not good, but not hideous.
13:53:18 <lambdabot>  7070651414971679%2251799813685248
13:53:27 <ndm> up to 8 times faster than SYB (Data.Generic with GHC)
13:56:08 <sclv_> @src init
13:56:08 <lambdabot> init [x]    = []
13:56:09 <lambdabot> init (x:xs) = x : init xs
13:56:09 <lambdabot> init []     = undefined
13:56:15 <dozer> ndm: thx
13:56:58 <ndm> dozer: (but doesn't do everything the same, its much more restricted)
13:57:19 <dozer> ok - shall I tell you what I need then?
13:57:27 <ndm> go for it
13:57:44 <dozer> so, I have a load of datatypes, each with many constructors
13:57:57 <dozer> they map to the grammar of OWL 1.1
13:58:30 <ndm> yep, i can imagine
13:58:32 <dozer> I need to walk this to pull out things of a given type, or the values on a given constructor
13:58:48 <dozer> and possibly apply some arbitrary function to these before getting the result back
13:58:52 <ndm> uniplate would be faster, and shorter
13:59:02 <dozer> and ideally, do this in an arbitrary monad, although list is OK
13:59:03 <ndm> if you use Data.Derive to generate the instances
13:59:32 <dozer> ok - I was using Data.Generic, but it was dog slow, and now I'm binding a load of mutually-recursive functions together in a where block
13:59:37 <ndm> if you don't, you might expect a 20% speed up just using deriving Data
13:59:53 <ndm> i.e. built in deriving (Data,Typeable)
14:00:07 <ndm> for a big grammar, it could even be more like 70% faster using Uniplate
14:00:47 <dozer> well, I'm at the wrong end of a bottle of wine to be learning a new API tonight
14:00:57 <ndm> binding mutually recursive functions? using SYB?
14:00:57 <dozer> but I may give it a go on a test problem after the xmas break
14:01:11 <ndm> can you post a fragment of your ugly SYB-ness?
14:01:35 <dozer> sure - it's nothing fancy
14:01:50 <dozer> I'll paste the generic func, and an example of me hand-expanding it
14:02:09 <ndm> if you are doing it after xmas, i hope to have an even faster uniplate with better data.derive support by then
14:02:14 <ndm> cool :)
14:02:30 <ndm> hmm, any lambdabot experts?
14:02:43 <ndm> i remember when the channel was almost full of people writing lambdabot...
14:04:05 <dozer> mm - is hpaste not announcing any more?
14:04:06 <dozer> http://hpaste.org/4563
14:04:20 <Saizan_> lambdabot is quite a pain to build, and hard to run if you've multiple ghcs
14:05:08 <dobblego> trying to get lambdabot to build/run has cost me so many hours and I still have nothing to show; we need a lambdabot vmware image
14:05:35 <dozer> not at all a silly idea
14:05:48 <dobblego> I'd make one if I could :)
14:06:24 <ndm> i'm not after building lambdabot, just asking why the where file seems to be binary
14:07:02 <ndm> dozer: in uniplate, you can define: findAll = universe
14:07:36 <ndm> findSome p x = [y | y <- universe x, p y]
14:07:49 <ddarius> ndm: It's probably a gzipped text file.
14:08:15 <roger`> dobblego: wouldn't a virtualbox image be better?
14:08:20 <dozer> ok - I will definitely have a play with uniplate after the xmas break then
14:08:21 <ndm> ddarius: thanks for the hint!
14:09:06 <bench`> what's wrong with delete (last desc) desc
14:09:20 <bench`> i get "Couldn't match expected type `Char' against inferred type `String'"
14:09:28 <doserj> @type delete
14:09:29 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
14:09:45 <ndm> dozer: and will run faster, certainly if you use the Data.Derive instances - its about 1.5 times slower than a manually written well optimised version, although mine will do tricks like continuation passing and foldr/build fusion which you would have no hope to do manually
14:10:42 <doserj> > let desc = "abcdefg" in delete (last desc) desc
14:10:43 <lambdabot>  "abcdef"
14:11:07 <ndm> dozer: although findAll ~= everything or everywhere in SYB (can never remember which), would make your code slightly more pleasant if you stick to SYB
14:11:27 <ndm> but uniplate = simpler + faster + less powerful, and it doesn't look like less powerful is going to bite you at all
14:11:44 <dozer> I am primarily doing lookup
14:12:03 <dozer> there's one place where I do re-write - and the resulting type (type tree) is parameterised over different types
14:12:18 <bench`> let desc = ["a", "b", "c"] in delete (last desc) desc
14:12:19 <ndm> that uniplate cannot help with
14:12:27 <ndm> the different type parameterisation
14:12:46 <dons> ndm: that where file is gzipped
14:13:01 <bench`> doserj, isn't the above valid?
14:13:03 <doserj> > let desc = ["a", "b", "c"] in delete (last desc) desc
14:13:05 <lambdabot>  ["a","b"]
14:13:09 * ddarius assumes it was dons playing with the (then new) bytestring stuff.
14:13:14 <doserj> bench`: sure
14:13:28 <bench`> then why did i get the type matching error?
14:13:42 <doserj> where do you use the result?
14:14:51 <ndm> thanks dons, just updating the makefile to account for it
14:15:42 <bench`> words$ delete (last desc) desc
14:16:06 <doserj> > words ["a","b"]
14:16:08 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
14:16:11 <doserj> :)
14:16:23 <doserj> > words ['a','b']
14:16:24 <lambdabot>  ["ab"]
14:16:50 <Saul> Is there a way to lift one function of some type to another with each type in de signature contained in a constructor?
14:17:16 <Saul> so for f :: a -> b -> c -> d
14:17:33 <Saul> g f :: T a -> T a -> T c -> T d
14:17:33 <BMeph> @ty liftM3
14:17:34 <lambdabot> forall a1 a2 a3 r (m :: * -> *). (Monad m) => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
14:17:50 <Saul> ah ok
14:17:53 <BMeph> Like that, Saul? :)
14:18:03 <Saul> yes exactly like that :)
14:19:00 <wy> hello. I'm up
14:19:20 <Saul> too bad it's a bit messy (like one function for every kind)
14:19:29 <Saul> a bit like with the tuples
14:19:47 <Saul> Not sure I have a monad btw, so this might not work
14:20:55 <dobblego> Saul, you usually do have a monad :)
14:21:17 <Saul> data Form a where
14:21:17 <Saul>   Base :: (Maybe String -> Either InputError a) -> (Index -> Maybe String -> Html) -> Form a
14:21:17 <Saul>   Modify :: (Either InputError a -> Either InputError b) -> (Index -> Html -> Html) -> Form a -> Form b
14:21:17 <Saul>   Repeat :: ([Either InputError a] -> Either InputError b) -> ([Html] -> Html) -> [Form a] -> Form b
14:21:22 <Saul> I doubt this is one
14:22:38 <BMeph> No, it's more like three or four... ;)
14:22:38 <Saul> it's basically a skeleton tree for an html form
14:23:23 <Saul> BMeph: How's that?
14:25:42 <BMeph> Saul: Many data constructs are instances of Monads, including Either, Maybe, lists, and functions, to name a few. :)
14:26:03 <dobblego> *Either a
14:26:07 <Saul> are functions monads??
14:26:19 <dobblego> ?instances Monad
14:26:21 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
14:26:59 <Saul> Is that the same as arrows?
14:27:12 <wy> Has anyone looked at G'Caml ?
14:27:17 <doserj> It's essentially the Reader Monad
14:28:18 <doserj> functions are "values that can read from an environment", so to speak
14:28:39 <Saul> ah I think I get it
14:30:11 <wy> It seems type classes are powerful enough to cover most of the G'Caml features. I wonder if it's as powerful as CLOS's generic functions.
14:30:43 <nomeata> Igloo: FYI: I decided to try to package xmonad with the old cabal, so at meast from my side there is no hurry for the new ghc packages any more. Thanks for your effort, though!
14:30:50 <BMeph> Arrows are similar, but they're more complicated. Although given a monad, one can make an arrow isomorphic to it.
14:31:01 <Saul> Is my Form datatype elegant btw, or would you do it differently?
14:31:07 <monochrom> I think Arrow is simpler.
14:31:57 <bench`> doserj, thanks
14:32:21 <Saul> It's an open question :P
14:34:33 <BMeph> Saul: At first glance, it looks to me like you could break down the descriptions more, but I'd have to sit down and study it for a while.
14:35:11 <antipaladin> is there a DNS server done in haskell?
14:35:19 <antipaladin> nicer than bind etc.
14:35:19 <antipaladin> ?
14:35:25 <doserj> Saul: do you really need all the Eithers and Maybes in the constructors?
14:35:59 <doserj> in particular, in argument positions?
14:36:45 <Saul> doserj: Those Eithers are for error handling on user input, so I kind of need those
14:37:14 <dobblego> Saul, I wrote a library for lifting Either for validating user input in Scala, just recently
14:37:28 <dobblego> Saul, it is currently getting air time on reddit (thanks dons ;)
14:37:55 <Saul> it's possible for parent nodes to recover from those errors, so that's why it's input in de branches
14:37:59 <dobblego> Saul, you can't partially apply type arguments in Scala, and since it is actually (Either a) that is the monad, things get a little difficult
14:38:35 <Saul> dobblego: sounds difficult
14:38:40 <doserj> Saul: ok
14:38:47 <dobblego> Saul, it's just what you're doing :)
14:39:56 <Saul> dobblego: ok
14:40:28 <dobblego> Saul, in case you're interested; http://wiki.workingmouse.com/index.php/Scalaz_Validation
14:40:40 <lambdabot> Title: Com.org - Only the best links ...
14:41:52 <Saul> In general: The first function maps user input for a html widget to a value of the requested type (or an error) in the leaves, while the branches modify or merge these values
14:42:07 <Saul> the second function renders part for the form
14:43:01 <Saul> so for leaves, it renders an html widget, for branches it merges a bunch of them or adds some additional html
14:43:10 <Saul> dobblego: I'll check it out, thanks
14:44:08 <bench`> is there a function to test if two lists intersects?
14:44:56 <BMeph> bench': try "isInfixOf"
14:45:09 <BMeph> @type isInfixOf
14:45:11 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
14:45:12 <monochrom> Data.List.intersect
14:45:44 <monochrom> But if your elements are Ord, I recommend slurping the two lists into two Data.Map.Map's, then intersect there.
14:46:10 <monochrom> (n * log n instead of n^2 cost)
14:46:20 <BMeph> Ah, set intersection. Good point.
14:46:29 <monochrom> Oops! Data.Set.Set's :)
14:46:30 <bench`> how do you slurp them into Map?
14:46:50 <monochrom> Sorry it should be Set not Map.  Look for docs of Data.Set
14:47:14 * monochrom needs to hunt down the faulty wiring.
14:47:22 <Cale> > intersect "Hello" "World"
14:47:24 <lambdabot>  "llo"
14:47:38 <monochrom> Does anyone know of a debugging tool for brain?
14:47:41 <BMeph> Be back later - it's time to leave work... =8*O
14:48:00 <monochrom> I need to trace which neurons confuse Set with Map...
14:48:28 <monochrom> Gosh, using my brain is really like using hugs or the old ghci...
14:48:29 <bench`> Cale, so a test would be not.null intersect l1 l2?
14:48:42 <monochrom> Yeah, not . null will work
14:48:44 <Cale> not . null $ intersect l1 l2
14:49:25 <jasonmay> I got the the 12/17/2007 push of GHC from darcs, has anybody had any issues relating to base? I get an error of something along the lines of: "base -any is not found" (when attempting to configure Haskell X11 libs)
14:49:36 <jasonmay> I checked ghc-pkg, and base is in there (3.0
14:50:18 <jasonmay> and I did which runhaskell, which ghc-pkg, they both are in /usr/local/bin
14:51:20 <Saizan_> jasonmay: you builded ghc from darcs? did you ./darcs-all get before building?
14:51:30 <Armored_Azrael> How does one determine system load in haskell?
14:51:38 <Saul> I pasted the code into http://hpaste.org/4565, do you guys see any way to seperate the process en render functions so that I don't need two functions in my Form datatype?
14:52:10 <Cale> Armored_Azrael: That probably depends on which system you're on.
14:52:34 <antipaladin> so no dns server in haskell?
14:52:37 <Cale> Armored_Azrael: I suppose on linux you could do something like reading /proc/loadavg
14:52:47 <antipaladin> debugging tool for the brain? porn?
14:52:48 <Armored_Azrael> Cale: I tried using hoogle on "IO Double" and it returned nothing.
14:52:51 <Cale> antipaladin: Not that I'm aware of.
14:52:54 <Armored_Azrael> (Well, nothing useful)
14:52:55 <antipaladin> bugger
14:53:01 <Armored_Azrael> I suppose I'll just read the proc file, thanks
14:53:02 <antipaladin> I guess i have to try bind
14:53:16 <antipaladin> so what programs are done in haskell?
14:53:17 <mrd> use tinydns
14:53:21 <antipaladin> tinydns?
14:53:29 <antipaladin> does it do stuff like bind does?
14:53:32 <jasonmay> Saizan_: yes
14:53:35 <antipaladin> ok
14:53:36 <mrd> it's djb's dns server.  yes it is a nameserver
14:53:36 <antipaladin> cool
14:53:38 <Cale> oh, there's apparently a DNS server in HAppS?
14:53:39 <antipaladin> ah
14:53:41 <mrd> but no, it doesn't do what bind does
14:53:46 <antipaladin> :(
14:53:48 <mrd> namely, it doesn't provide an easy exploitable hole
14:53:52 <antipaladin> lol
14:53:54 <antipaladin> doh!
14:54:07 <mrd> so if you were looking to have people break into your system then run bind
14:54:11 <wy> Anyone tried flymake-mode ?
14:55:03 <antipaladin> no no no no breakinz
14:55:19 <antipaladin> this dan berseen guy sounds like he knows whats up
14:55:26 <antipaladin> where does he teach again?
14:55:31 <mrd> chicago
14:55:35 <antipaladin> ah
14:55:43 <mrd> though, feel free to write a Haskell DNs server
14:55:45 <antipaladin> I like the chicago school of economics
14:55:50 <Cale> http://software.pupeno.com/HaServers/ -- oh, and there's a minimalist DNS server in here.
14:55:51 <lambdabot> Title: Index of /HaServers
14:55:54 <antipaladin> !
14:55:59 <antipaladin> hmmmm
14:55:59 <antipaladin> !
14:56:37 <bench`> thanks cale
14:56:42 <Saul> I pasted some code into http://hpaste.org/4565, do you guys see any way to seperate the process en render functions so that I don't need two functions in my Form datatype?
14:57:54 <Cale> Saul: btw,  x >>= return . f is the same as fmap f x
14:58:24 <Saul> Cale: thanks
14:58:31 <Cale> (or liftM which is the same thing)
15:01:52 <monochrom> Why does Cale get all the thanks? :)
15:02:32 <ddarius> monochrom: Don't be bitter just because your timing/helpfulness is off.
15:02:54 <monochrom> Not bitter, don't worry.
15:04:50 <Saul> Cale: Do you also have ideas about separating the two functions in the constructors somehow?
15:04:50 <Saul> monochrom: If you want props, answer the question I just asked Cale :)
15:05:28 <Cale> What do you mean by separating?
15:06:57 <Saul> Cale: Well each constructor in the Form datatype has two functions in it
15:07:02 <Cale> Yeah...
15:07:20 <Cale> Do you mean encoding the information carried by those functions in some other fashion?
15:07:28 <Saul> Yeah pretty much
15:07:59 <Saul> Or abstracting away from the connection the two have to eachother
15:08:23 <Cale> I suppose I don't understand that connection.
15:08:54 <Cale> Do you only construct values of type Form a instantiated with particular functions?
15:09:08 <Cale> Or could those functions really be any function of the right type?
15:09:46 <Saul> Well the first function grabs user submitted data and transforms it to some haskell datatype (or an error) and the second one makes a piece of html in which the user can fill in values
15:10:00 <Saul> Cale: There are predefined functions
15:10:12 <dozer> could I ask that the output of the profiling be formated in csv or tdt so that it can be easily imported into my favorite spreadsheet?
15:10:24 <Saul> that make sure that what goes in one function can come out of the other
15:10:35 <Cale> I suppose you could construct some datatype to indicate which predefined pair of functions you're interested in.
15:10:49 <Saul> I'll add some of them in the paste, hold on
15:11:35 <Cale> But I'm not sure I understand the concern about the current design.
15:11:53 <Saul> Cale: http://hpaste.org/4565#a1
15:11:59 <Cale> (It seems reasonable to me)
15:12:31 <Saul> Cale: That's nice to hear
15:14:39 <Saul> I'm just a bit of a haskell noob and so far it seems that things can always be coded/generalized way more than I initially think is possible
15:15:21 * Vq^ wonders if that feeling ever stops
15:15:31 <byorgey> nope =)
15:15:41 <Saul> :)
15:16:19 <Saul> Cale: I guess I'll stay with what I have right now, thank you for your help
15:23:53 <dons> where can i get bytestring tshirts?
15:23:59 <Saul> dobblego: That Scalaz Validation stuff seems pretty interesting
15:24:20 <byorgey> dons: um, cafepress?
15:24:51 <dobblego> Saul, it is just monad lift
15:24:57 <dobblego> Saul, of various arity
15:24:59 <dobblego> ?type liftM2
15:25:02 <dobblego> ?type liftM3
15:25:02 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
15:25:02 <lambdabot> forall a1 a2 a3 r (m :: * -> *). (Monad m) => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
15:25:04 <dobblego> and so on
15:25:49 <nolrai> Now ghc cant find gtk.h and i have installed libgtk2.0-dev. Im stumped.
15:26:54 <Saul> dobblego: I don't really see that in the example code
15:27:20 <dobblego> Saul, you do in the type signature of the called code
15:28:08 <dobblego> Saul, http://projects.workingmouse.com/public/scalaz/artifacts/2.1/scaladoc/scalaz/validation/Validate$object.html look at the combine functions
15:28:10 <lambdabot> Title: object Validate in scalaz.validation, http://tinyurl.com/2o8wet
15:29:32 <wy> any ideas how to get flymake-mode to work?
15:30:03 <dobblego> having written a web application in Scala with a colleague not-well-versed on powerful programming techniques, I have formed the opinion that Haskell is the best first language for anyone who is heavily influenced already; to *force* the abandonment of bad programming habits
15:30:04 <Saul> dobblego: I see, is there a way to do something like that in haskell?
15:30:31 <dobblego> Saul, it's *much* easier in Haskell; the liftMN functions already exist for example
15:31:29 <Saul> dobblego: But then I need to know the arity of my input :S
15:31:45 <dobblego> Saul, applicative functors
15:32:36 <dobblego> ?type liftM2 <$> id
15:32:37 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
15:32:42 <dobblego> ?type liftM3
15:32:43 <lambdabot> forall a1 a2 a3 r (m :: * -> *). (Monad m) => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
15:32:48 <dobblego> same same :)
15:32:53 <dobblego> oops
15:34:01 <Saul> dobblego: I don't get it
15:34:06 <dobblego> I lied sorry
15:34:22 <nolrai> dont you want ap?
15:34:26 <dobblego> yes
15:36:21 <Saul> dobblego: You basically use the liftMN functions to make forms of data Person = Person Int String, right?
15:36:55 <dobblego> liftM is for applying a function inside a monad
15:37:07 <dobblego> notice that liftM has (almost the same) signature as fmap
15:37:09 <dobblego> ?type liftM
15:37:10 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
15:37:11 <dobblego> ?type fmap
15:37:12 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:37:28 * Saul noticed
15:37:29 <dobblego> you have probably encountered map, which is fmap over a list
15:37:48 <dobblego> fmap is just more abstract, in that the list part is actually now a type argument
15:38:44 <dobblego> liftM2 is called map2 in Scala
15:38:52 <dobblego> ?type liftM2
15:38:53 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
15:40:11 <Saul> ok so far I understand it
15:41:11 <Saul> I'm just not sure how you use that in the program
15:42:27 <Saul> and more importantly, how I can go from Person :: Int -> String -> Bool -> Person to something with type Form Int -> Form String -> Form Bool -> Form Person
15:42:47 <Saul> since I doubt that Form is a monad
15:42:48 <EvilTerran> ?type liftM3
15:42:49 <lambdabot> forall a1 a2 a3 r (m :: * -> *). (Monad m) => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
15:43:31 <EvilTerran> it might be an Applicative, in which case liftA3 would be better (or indeed application of <$> and <*>)
15:43:47 <EvilTerran> (i haven't read the scrollback, this might be useless/duplicated information)
15:44:22 <Saul> It's not, it is incomplete though (for me anyway)
15:45:10 <EvilTerran> any Monad is an Applicative, and any Applicative is a Functor, but not vice-versa
15:46:21 <EvilTerran> there's certain properties each class implies
15:46:35 <Saul> I'm not even sure it's a functor :S
15:47:15 <Saul> how does one map over Form in http://hpaste.org/4565#a1
15:47:16 <Saul> ?
15:47:17 <EvilTerran> but, basically, wanting a function of type (Int -> String -> Bool -> Person) -> Form Int -> Form String -> Form Bool -> Form Person is exactly what Applicative is about
15:48:01 <Saul> That is good to know at least
15:50:31 <EvilTerran> welll, I think fmap f (Base g h)     = Base (fmap f . g) h
15:51:00 <EvilTerran> I can't type-check it here, as i don't have enough information about your types and whatnot
15:51:52 <ddarius> The minimal requirements to have (a->b->c) -> F a -> F b -> F c is a finite product preserving functor.
15:52:01 <Saul> I'll try it out
15:52:06 <EvilTerran> but, basically, there'll be one sensible behaviour for a function :: (a -> b) -> (Form a -> Form b), for each constructor
15:53:52 <EvilTerran> similarly for the functions necessary to make Form an Applicative; there should be one obvious way to implement each function for each constructor
15:54:02 <EvilTerran> (relatively obvious)
15:55:02 <Saul> EvilTerran: The fmap for Base typechecks
15:55:31 <EvilTerran> does it seem like a sensible definition to you?
15:55:42 <Saul> No so obvious if you've never worked with functors or applicatives before, and never have defined your own monad
15:55:46 <EvilTerran> based on the type of the constructor
15:55:57 <EvilTerran> Base :: (Maybe String -> Either InputError a) -> (Index -> Maybe String -> Html) -> Form a
15:56:16 <EvilTerran> so, you've got a (Maybe String -> Either InputError a) and a (Index -> Maybe String -> Html)
15:56:42 <EvilTerran> according to the type of fmap, you've also got an (a -> b), and you want to make a (Maybe String -> Either InputError b) and a (Index -> Maybe String -> Html)
15:57:08 <EvilTerran> the second parameter is easy; a and b don't appear in its type, so it doesn't need to change
15:57:37 <EvilTerran> so now you've got a (Maybe String -> Either InputError a) and an (a -> b), and are trying to make a (Maybe String -> Either InputError b)
15:57:44 <EvilTerran> @src Either fmap
15:57:44 <lambdabot> fmap _ (Left x) = Left x
15:57:44 <lambdabot> fmap f (Right y) = Right (f y)
15:58:13 <EvilTerran> fmap on (Either e)s applies its function to Rights, but not Lefts. i took advantage of that.
15:59:03 <EvilTerran> "either id f" would do the same thing
15:59:30 <EvilTerran> as would (let g (Right x) = Right g x; g l = l in g), say
15:59:42 <antipaladin> why haskell over c?
15:59:47 <Zao> antipaladin: Why not?
15:59:53 <antipaladin> I got the haskell school of expression adn k+R
15:59:57 <antipaladin> sitting here on my desk
16:00:26 <antipaladin> heh
16:00:27 <EvilTerran> if you're learning haskell and you get stuck, you can come on here and bored phd students and suchlike will help you ;)
16:00:32 <antipaladin> haskell is scottish for oen thing
16:00:40 <antipaladin> and if it isnt scotish its CRAP
16:01:15 <loupgaroublond> what is it scottish for?
16:01:16 <antipaladin> so if I get a phd I can sit around playing with linux and haskell adn get paid to do it and a degree?
16:01:27 <antipaladin> friggin a
16:02:20 <bench`> can someone help me understand data accessors?
16:02:28 <bench`> i have the following in http://hpaste.org/4566
16:02:41 <bench`> one runs fines w/o the accessor, the other doesn't
16:02:58 <bench`> the only difference was that i use an accessor to get the [string]
16:03:05 <bench`> vs input it directly
16:03:07 <bench`> i don't get it
16:03:54 <EvilTerran> m in the second fn = p in the first
16:04:01 <Saul> EvilTerran: Ok I've tested it and it does actually seem rather sensible
16:06:27 <Saul> I can already fmap the not function to negate my boolean results from checkboxes
16:06:27 <EvilTerran> "foo x@PAT = ..." is much the same as "foo x = ... where PAT = x"
16:06:46 <bench`> EvilTerran, do you see any issue with the carInfo{misc=m} syntax
16:07:01 <ddarius> He already told you what the problem was.
16:08:35 <bench`> ddarius, i don't understand
16:08:53 <Saul> instance Functor Form where
16:08:53 <Saul>   fmap f (Base g h) = Base (fmap f . g) h
16:08:53 <Saul>   fmap f (Modify g h x) = Modify (fmap f . g) h (fmap x)
16:08:53 <Saul>   fmap f (Repeat g h x) = Repeat (fmap f . g) h (fmap fmap x)
16:09:08 <Saul> EvilTerran: Does this make sense?
16:09:30 <Saul> hmmz ghci doesn't think so :(
16:09:51 <bench`> ddarius, should i change this to let m = p{misc}, is that the right syntax?
16:10:32 <ddarius> bench`: Read what EvilTerran wrote.
16:11:45 <dcoutts> @yarr!
16:11:46 <lambdabot> I'd like to drop me anchor in her lagoon
16:11:48 <dcoutts> yay! bash command line completion for the cabal command!
16:12:14 <dcoutts> thanks to kolmodin
16:12:20 <EvilTerran> Saul, I don't think you need the second fmap in the Modify line
16:12:27 * dcoutts darcs pushes said patch
16:13:01 <EvilTerran> that constructor's returning something of type (Form b), so you only need to apply f to the (b)s in the definition of (fmap f), not the (a)s
16:13:22 <EvilTerran> think of f as being of type (b -> c) in that case, and the Repeat case
16:15:19 <EvilTerran> do you see?
16:15:25 <bench`> ddarius, i read it, and i don't understand what the problem is
16:15:34 <Saul> EvilTerran: I see
16:15:45 <Saul> EvilTerran: No sure I get everything yet though
16:15:47 <ddarius> bench`: So ask him to explain, don't start asking random questions.
16:16:19 <bench`> ddarius, which question is random?
16:16:27 <Saul> EvilTerran: I have something that works now, but it's a little weird so far, I'm not entirely sure what it does yet
16:16:46 <ddarius> bench`: All the ones you've asked since he told you what the problem was.
16:17:31 <Saul> As far as I can see I can use fmap to lift a normal function so that it modifies the result of the user input
16:17:43 <EvilTerran> that makes sense, i guess
16:17:57 <bench`> ddarius, if you knew the answer, please explain, or just tell me that  you won't help
16:18:06 <Saul> EvilTerran: Ok thanks a lot
16:18:17 <EvilTerran> now to define the Applicative instance :D
16:18:21 <Saul> I really have to go to bed though, I have to get up in 6 hours :S
16:18:44 <bench`> EvilTerran, can you explain what you saw as the problem in the hpaste, i don't quite understand the syntax that you pointed out
16:18:45 <Saul> Applicative will have to wait until tomorrow
16:18:47 <EvilTerran> ah, joy. fortune knows i've stayed up too late too many nights hacking away
16:19:08 <sieni> I don't even remember when I've spent a night hacking
16:19:27 <Saul> EvilTerran: Thanks and good night
16:19:28 <EvilTerran> bench`, when you define a function with "foo x@(...) =", x has the same value as if you'd defined it with "foo x ="
16:19:49 <EvilTerran> np, Saul. learning can be fun, even other people's :)
16:20:35 <bench`> EvilTerran, yes, but the code should still work, all it does it to get the [string] from a field in the data type
16:20:36 <EvilTerran> bench`, so, as i said before, m in the second function is the same as p in the first
16:20:45 <ice-i> bench`: couldn't you try to rewrite your first function by taking just the "p" argument and then accessing the mileage as "misc p". This is at least how I understood the accessor functions.
16:21:18 <ice-i> bench`: by mileage, I mean the variable "m" that you match in the pattern
16:21:29 <EvilTerran> bench`, no it shouldn't. the two "m"s are different values. heck, they're almost certainly different types.
16:22:01 * ddarius is also kind of surprised it even typed.
16:22:21 <EvilTerran> oh, wait, i see what you're doing
16:22:34 <bench`> evilTerran, i don't understand your comment
16:23:18 <bench`> ice-i, i used to have let v1 = misc p, i believe that someone on this channel suggested the syntaxt that i'm using now
16:23:22 <EvilTerran> ddarius, look at the functions' types; one of them isn't meant to take the record type as its parameter, only the list that would be a field in the first case
16:23:38 <bench`> which is a lot cleaner
16:24:15 <ddarius> EvilTerran: Yeah, I saw it too after you said "oh, wait ..."
16:24:53 <EvilTerran> perhaps. so, what's the problem?
16:25:26 <bench`> EvilTerran, its typed as CarInfo though
16:25:36 <EvilTerran> looks to me like a bug in initCarInfo rather than the two functions you've pasted
16:26:47 <ice-i> bench`, you're sure that the field "misc" contains the same value as "words <your-car-string"? try once using "debugMileage2 . misc $ initCarInfo <your-car-string>"
16:26:48 <ddarius> The functions are identical so the problem obviously has to be elsewhere.
16:26:48 <EvilTerran> that stray "-L" at the start may be throwing things off
16:26:48 <bench`> ice-i: it should be the misc field of the carInfo
16:27:00 <roger`> antipaladin: gavino?
16:27:56 <ice-i> bench`: well, I'm just pointing out a test that would identify a problem in initCarInfo.. if you've already done it then it's OK. Otherwise, test it :-)
16:28:17 <dons> roger`: hmm. suspicious..
16:28:29 <bench`> ice-i, yes, i've pasted the returns of initCarInfo
16:28:31 <roger`> dons, the dns comment tipped me off.
16:28:34 <bench`> and that looks fine
16:29:01 <EvilTerran> http://hpaste.org/4567 <- something idle/evil i threw together; wondering what to do with it...
16:29:10 <dons> roger`: yeah.. and g@
16:29:42 <bench`> EvilTerran/ice-i, any insight?
16:29:55 <ddarius> EvilTerran: Congratulations, Scott and Strachey only beat you by like 30-40 years.
16:29:55 --- mode: ChanServ set +o dons
16:30:01 --- kick: antipaladin was kicked by dons (go away)
16:30:09 <EvilTerran> ddarius, what?
16:30:15 --- mode: dons set -b *!*n=Torres@*.160.163.127.cable.dyn.cableonline.com.mx
16:30:23 --- mode: dons set -b *!*@81-7-78-206.ip.zebra.lt
16:30:31 <ddarius> That's the traditional domain for the untyped lambda calculus, D ~ D -> D
16:30:41 --- mode: dons set +b *!*n=g@147.21.16.*
16:31:07 <EvilTerran> well, yes. i wasn't aware of an existing embedding in haskell, tho (and i doubt that happened 30-40yr ago ;])
16:31:08 <dons> roger`: classic gavino, 15:59:42 <antipaladin> why haskell over c?
16:31:11 --- mode: ChanServ set -o dons
16:31:12 <ddarius> (Though the benefit of Scoot and Strachey's work wasn't the discovery of that type but giving it a semantics as it's obviously useless set theoretically.)
16:31:17 <ice-i> bench`: hmm sry, but I don't see the problem in the code you pasted. I personally wouldn't trust the output of "initCarInfo" too much. Especially, at it is pretty printed and may be hiding the internal structure. Try using the standard derived show function.
16:31:41 <EvilTerran> and i'm starting to suspect that that might be because values of that type are indistinguishable from one another
16:31:45 <ddarius> EvilTerran: I'm sure it happened in the same year Haskell was first implemented.
16:32:15 <ddarius> EvilTerran: Not completely, but yeah, there's not too much useful stuff that you can do.
16:32:42 <ddarius> Usually you have D ~ (D -> D) + B
16:32:56 <EvilTerran> booleans?
16:33:08 <ddarius> Just some arbitrary base type(s)
16:33:16 <bench`> ice-i, ok, though i've tested init carinfo
16:33:16 <EvilTerran> i see
16:33:57 <EvilTerran> and then you can actually do something vaguely useful with your SKI-as-haskell-functions, eh ;)
16:34:20 <ddarius> EvilTerran: Where would the fun be in that?
16:34:36 <ddarius> Anyway, maybe play with these:
16:34:41 <ddarius> @google Haskell hyperfunctions
16:34:42 <lambdabot> http://www.haskell.org/arrows/
16:34:42 <lambdabot> Title: Arrows: A General Interface to Computation
16:34:52 <EvilTerran> I guess there's something satisfying about knowing that people have had the same vaguely interesting ideas that i have in the past
16:36:37 <EvilTerran> (he said, trying to look on the bright side of "hey, here's something cool i've thought up" "yeah, you're decades too late" :P)
16:36:45 <dozer> I have some code that is very slow :(
16:37:03 <ddarius> dozer: Don't write slow code.
16:37:06 <bench`> EvilTerran/ice-i, any ideas of how do i go about debugging/funding the problem?
16:37:15 <dozer> I wish I knew how not to
16:37:29 <ddarius> dozer: That is the trick.
16:37:58 <EvilTerran> bench`, I'm looking at "<misc>l low miles 54k miles</misc>"; is that "l" at the start meant to be there? might that be throwing things off?
16:38:42 <EvilTerran> in the case where you use (words), that'd get grouped into "EX-L", so it wouldn't be there
16:38:48 <dozer> given a load of pairs in some relation R, I need to compute the transitive closure R*
16:38:51 <dozer> my code apparently is not very efficient
16:39:01 <bench`> EvilTerran, yes, l was supposed to be there as a separate words
16:39:17 <bench`> as i segmented using '-.,' etc
16:39:31 <EvilTerran> it is, however, a difference between the two inputs
16:40:17 <bench`> EvilTerran,  debugMileage2 $ words  "L LOW MILES 54k miles" results in ("54000", "54k")
16:40:29 <bench`> EvilTerran, so that's not the issue
16:41:02 <EvilTerran> i don't know, then.
16:41:45 <bench`> ok, thanks, i've been using the same pattern at other places, they all worked fine. that's why i'm really confused by this
16:51:28 <ddarius> bench`: You aren't passing the same input to each beyond the fact that one is truncated.
16:52:08 <smack_> is there an easy way to read a file into [Word16]?
16:52:52 <ddarius> smack_: What should it do for an odd-length file? or what do you mean?
16:53:23 <ddarius> Either way, Data.Binary is likely what you want.
16:53:34 <smack_> ddarius: right, thanks
16:55:30 <ddarius> bench`: What does 'debugMileage2 $ words "l low miles 54k miles"' return and/or, as ice-i suggested, what does 'debugMileage2 $ misc $ initCarInfo "..."' return (where ... is suitably filled in).
17:15:31 <dozer> @type Data.Set.unions
17:15:33 <lambdabot> forall a. (Ord a) => [Data.Set.Set a] -> Data.Set.Set a
17:16:49 <oerjan> bit backwards, that name
17:17:52 <monochrom> You want it named snoinu?
17:18:15 <oerjan> no, but it's the argument that is plural, not the result
17:18:27 <dozer> sunion?
17:18:29 <dozer> not sure that's better
17:19:57 <dozer> oh, I realy wish I could compute in a set monad as well as a list one
17:20:13 <dozer> eagerly dropping duplicate results would be a godsend
17:21:18 <monochrom> Some kind of logicT may serve you better.
17:21:33 <oerjan> well you could define your own variant, just loses syntactic sugar?
17:21:34 <dozer> oh?
17:22:10 <ddarius> The list monad is a pretty crappy non-determinism monad.
17:22:27 <jcreigh> ddarius: is it?
17:22:39 <ddarius> Yes.
17:23:10 <jcreigh> maybe I don't have a very clear understanding of what a good non-determinism monad would do...what's wrong with lists?
17:23:18 <dozer> well, to do unique things on List, you end up doing expensive things with it or piping it through a Set
17:23:27 <ddarius> jcreigh: What're some of the things wrong with Prolog?
17:25:07 <jcreigh> ddarius: I have no idea, I've never used prolog. Or is that a rhetorical question?
17:25:20 <ddarius> jcreigh: Do you know what SLD resolution is?
17:25:24 <jcreigh> no
17:25:40 <dozer> piping the data through set to reduce duplicates took my app down from processing ~50k datapoints in 5 min to 8k datapoints in 15 sec
17:26:20 <oerjan> > (50/300,8/15)
17:26:23 <lambdabot>  (0.16666666666666666,0.5333333333333333)
17:27:00 <ddarius> Okay, then here's a different argument.  If I want to process the "answers" that the list monad returns in that order I can traverse the tree using an in-order depth-first search.  However, if I use trees directly I can traverse the answers however I like.
17:27:51 <oerjan> free monads! inquire within.
17:27:53 <dozer> right - and if one of the intermediate results you don't chose to look at is very expensive or doesn't terminate, you are fine
17:28:12 <ddarius> oerjan: Indeed, the tree monad is a free monad on a signature representing non-deterministic operations.
17:29:06 <ddarius> dozer: A bigger issue is if the tree is infinite, a depth first search of it is not going to explore the whole thing.
17:29:29 <dozer> right
17:29:38 <ddarius> (This is one of the many problems with Prolog and it's use of SLD resolution.)
17:30:09 <dozer> but you don't want to encode breadth-first into your description of the problem itself, but rather just in the 'how I look at possible answers' bit of your application
17:30:55 <jcreigh> well, if the tree is infinite, no search is going to explore the whole thing. :) But a breadth-first search would probably yield a more interesting section of it than depth-first.
17:31:37 <dozer> well, e.g. for tableau algorithms, you have an infinite tree, but you are careful to only take a finite portion of it
17:31:52 <ddarius> jcreigh: Breadth-first search is complete in so far as it will return an answer if one exists (given enough time)
17:31:57 <dozer> but becuse these are coded up in c++ or java, the 'take' is folded into the code that generates the tree
17:32:01 <jcreigh> ddarius: oh, good point
17:32:30 <dozer> hence you get ugly spageti for rules like 'don't go down that path' that has non-local effects on if you are alowed down another
18:07:49 <shivernz> can anyone see where i am going wrong? http://hpaste.org/4568
18:08:52 <Pseudonym> What's a LispVal?
18:09:02 <shivernz> oops
18:09:10 <shivernz> probably should have included the other stuff too
18:09:14 <Pseudonym> Yeah.
18:09:14 <shivernz> one sec, ill update it
18:09:19 * Pseudonym nods
18:09:51 <Brian`> Hi, if I have data Foo = Foo { x :: Integer, str :: String } deriving (Eq,Ord)
18:10:08 <Brian`> how does it compare the order between two objects?
18:10:22 <Brian`> what determines which object comes before or after?
18:10:26 <Pseudonym> Brian: First element first, second element second.
18:10:45 <allbery_b> shivernz: at a guess, you don't want parentheses in that return
18:10:48 <dozer> @type namy1
18:10:49 <lambdabot> Not in scope: `namy1'
18:10:56 <dozer> @type many1
18:10:56 <lambdabot> Not in scope: `many1'
18:11:06 <allbery_b> because liftM lifts a function and you gave it a CAF (i.e. somethingt hat takes no arguments)
18:11:07 <shivernz> http://hpaste.org/4568#a1 -- added the data type in
18:11:18 <Brian`> so even if I have a = Foo {x = 3, str ="zzz"} and b = Foo {x = 4, str = "aaa"}, since b has higher x it comes after a?
18:11:21 <Pseudonym> You probably don't want liftM.
18:11:23 <Pseudonym> I'm guessing.
18:11:28 <Pseudonym> What's that for, anyway?
18:11:30 <allbery_b> (but once you do that your'e invoking it on a bare value, so it's still wrong
18:11:35 <allbery_b> yeh
18:12:02 <allbery_b> return lifts back into the monad, so return $ Number d
18:12:28 <shivernz> yeah, you're right
18:12:33 <shivernz> didnt need the liftM
18:12:46 <shivernz> why does the previous function need it though?
18:12:59 <shivernz> cause there was no return?
18:13:08 <allbery_b> because liftM substitutes for the return
18:13:18 <shivernz> ok
18:13:29 <scook0> @type return
18:13:30 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
18:13:31 <shivernz> and return is only valid in a do-notation function?
18:13:33 <scook0> @type liftM
18:13:34 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
18:13:38 <allbery_b> do {x <- a; return (b x)} <==> liftM b a
18:13:54 <scook0> shivernz: no, return is valid anywhere it would be well-typed
18:13:57 <allbery_b> (or fmap, which is usually but not always substitutable for liftM)
18:14:28 <shivernz> so would it have been possible to do: parseNumber = return (Number . read) $ many1 digit
18:14:39 <allbery_b> a >>= return . b <==> liftM b a
18:14:53 <allbery_b> (same thing without do-notation)
18:15:02 <dozer> no, because many1 digit is in the Read monad
18:15:06 <allbery_b> liftM is a convenient shorter way to do it
18:15:33 <dozer> you have to either get the result out of Read to feed it to (Number . read) or you have to lift (Number . read) into the monad
18:17:10 <shivernz> ok, that kind of makes sense... though if i come across another situation like this that is slightly different, i know ill get confused again :)
18:17:59 <shivernz> at the moment i lack the reasons behind doing things. i just know what commands to use, not really why i'm using them :/
18:18:19 <allbery_b> learn to read the types, they tell the story
18:18:24 <allbery_b> :t (>>=)
18:18:25 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
18:18:28 <allbery_b> :t return
18:18:29 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
18:18:33 <allbery_b> :t liftM
18:18:33 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
18:18:51 <allbery_b> :t a >>= return . ?b
18:18:52 <lambdabot> Not in scope: `a'
18:18:57 <allbery_b> :t ?a >>= return . ?b
18:18:58 <lambdabot> forall a b (m :: * -> *). (?a::m a, ?b::a -> b, Monad m) => m b
18:19:13 <nanothief> is there a standard function that works like this: takeWhileM (/= '\n') (repeat getChar) -- same as getLine
18:19:43 <allbery_b> :t liftM ?b ?a
18:19:44 <lambdabot> forall a1 r (m :: * -> *). (?b::a1 -> r, ?a::m a1, Monad m) => m r
18:20:41 <shivernz> allbery_b, yeah. i think my probably is that i still don't totally understand how to read those types
18:21:11 <shivernz> or at least i dont attempt to try and understand them because they look a little complex
18:22:01 <thetallguy> nanothief: I don't understand, your question has the answer in the comment.
18:22:05 <allbery_b> some of the complexity there is that I used implicit variables so I would't have to declare a and b
18:22:40 <nanothief> thetallguy: i mean the takeWhileM function not the getline function (takeWhileM is just a made up name)
18:23:23 <thetallguy> nanothief: got it.  I realized as soon as I tried to run it.
18:23:59 <nolrai> where whould i put gtk/gtk.h so that ghc can find it?
18:24:20 <nolrai> > unlines ["a","b","c"]
18:24:21 <lambdabot>  "a\nb\nc\n"
18:25:15 <thetallguy> ?src getLine
18:25:15 <lambdabot> getLine = hGetLine stdin
18:25:23 <thetallguy> ?src hGetLine
18:25:23 <lambdabot> Source not found. The more you drive -- the dumber you get.
18:27:51 <dons> ?users
18:27:52 <lambdabot> Maximum users seen in #haskell: 434, currently: 390 (89.9%), active: 11 (2.8%)
18:28:47 <nolrai> @pl \x -> (owner $ guard $ snd x) == player
18:28:48 <lambdabot> (player ==) . owner . guard . snd
18:29:03 <Brian`> http://contracts.scheming.org/
18:29:04 <lambdabot> Title: Composing Contracts
18:29:11 <Brian`> I wanted to do that myself but somebody else already did it!
18:29:16 <Brian`> lol
18:29:21 <nolrai> which do you think is better the pointless or the lambda?
18:29:31 <nolrai> ^pointfree
18:29:54 <allbery_b> I'd call them about even because it's not that hard to figure it out
18:30:30 <nanothief> i think the pointfree as the lambda you have to start in the middle to figure it out
18:31:21 <shachaf> @pl (== x)
18:31:21 <lambdabot> (x ==)
18:31:56 <bench```> how do i repeately apply a function to a list if certain condition exits in the list?
18:32:30 <shachaf> bench```: Exits?
18:34:04 <shachaf> bench```: Maybe you want map with takeWhile?
18:34:04 <allbery_b> "exists", I think
18:34:04 <shachaf> Oh.
18:34:04 <allbery_b> or with filter
18:34:04 <bench```> not takeWhile or filter
18:34:18 <bench```> hoogle exits showed a bunch of IO module stuff
18:34:19 <allbery_b> but the description is not clear
18:34:27 <shachaf> bench```: Can you give an example of arguments and result of what you want?
18:34:36 <shachaf> bench```: You actually want it to exit the program?
18:35:02 <pjd> shachaf: i think he means "exists"
18:35:23 <shachaf> bench```: (If that's not what you want, by the way, Hoogle is generally more successful with types when looking for a function, for me.)
18:35:38 <shachaf> pjd: He/she said "exits" twice.
18:35:48 <bench```> ["12", "miles", "original", "miles", "blah"]
18:36:10 <bench```> i want to process the list when it contains miles
18:36:19 <bench```> "miles"
18:36:23 <bench```> exists i meant
18:36:27 <bench```> to search
18:36:38 <shachaf> bench```: if "miles" `elem` list?
18:36:54 <shachaf> bench```: Perhaps give the type of what you want? That'll probably be clearer.
18:36:55 <bench```> yes, but that only gets me to process for the first time
18:37:33 <bench```> [String]->(String, String)
18:38:04 <bench```> ["original", "miles", "12k", "miles", "blah"] is a better example
18:38:17 <allbery_b> is the processing likely to insert the search term?
18:38:20 <bench```> I want the output be ["12k", "miles"]
18:38:49 <shachaf> bench```: How does it get to that output? :-)
18:39:05 <shachaf> bench```: Anything that starts with a number and the element after it?
18:39:42 <bench```> no, followed by 'miles'
18:40:33 <bench```> actually it could also be ["12k", "original", "mile"]
18:40:57 <shachaf> bench```: Could you explain how it gets to those elements (in that order)?
18:42:07 <BMeph> bench```: why is "miles" in the list? Isn't that what you want it to find?
18:42:32 <bench```> shachaf, you meant where did i get the input like that?
18:43:29 <bench```> I meant to say that this ["12k", "original", "mile"] as input, and the output should be ("12k", "miles")
18:44:22 <bench```> BMeph, i then would remove those elements from the original list
18:47:08 <shachaf> bench```: You want to remove "original"?
18:48:11 <bench```> shachaf, yes, but that's not important, the goal is to extact the keys -- numbers and miles
18:49:13 <shachaf> How do you decide if something is a "key"?
18:49:26 <bench```> shachaf, so that in a list of sequential words that may contain multiple "miles", i'd be able to get the number and its corresponding "miles"
18:50:18 <bench```> shachaf, if it fits in a pattern digits followed by 'k', or digits comma digits such as 12,500
18:50:24 <shachaf> Is someone else here understanding what bench``` wants? :-(
18:50:56 <BMeph> I almost think I somewhat believe I could understand what you're asking, brian```. ;)
18:51:01 <nolrai> almost
18:51:33 <shachaf> filter (\x -> matchesPattern x || x == "miles")? :-)
18:52:26 <nolrai> @hoogle Array ix (Maybe x) -> (ix, x)
18:52:27 <lambdabot> Did you mean: Array Ix (Maybe x) -> (Ix, x)
18:53:48 <bench```> shachaf, that's close, but i think that i'd have to restrict that pattern to be only two or 3 words ahead of "miles"
18:54:27 <nolrai> does evry number have a coresponding miles?
18:55:06 <bench```> nolrai, no, that's why i want to restricted to be at most two words ahead
18:55:36 <bench```> nolrai, an example ["low", "miles", "12,500", "orig", "miles"]
18:55:44 <BMeph> bench```: What about numbers after the "miles"?
18:56:36 <Toxaris> bench```: are you asking how to implement an algorithm you have in mind in haskell, or are you asking what algorithm to apply?
18:58:29 <bench```> Toxaris, the former
18:58:50 <nolrai> @pl f (a, b) -> (a, g b)
18:58:50 <bench```> i can deal with a list that only has one "miles" in it
18:58:50 <lambdabot> (line 1, column 10):
18:58:50 <lambdabot> unexpected ">" or "-"
18:58:50 <lambdabot> expecting variable, "(", operator or end of input
18:59:03 <TSC> @seen lemmih
18:59:03 <lambdabot> lemmih is in #haskell. I last heard lemmih speak 12h 20m 47s ago.
18:59:05 <bench```> when i used `elem'
18:59:10 <nolrai> @pl f (a, b) = (a, g b)
18:59:10 <lambdabot> f = second g
18:59:19 <dobblego> "Haskell also ensures that if you evaluate an argument once, then subsequent references to that argument do not get re-evaluated." <-- is this true?
18:59:25 <bench```> but it broke when the list has more than one "miles"
18:59:44 <bench```> BMeph, let's assume no numbers after miles
19:00:00 <pjd> dobblego: yes
19:00:44 <pjd> dobblego: for example, double x = x + x
19:01:23 <pjd> the evaluation of x only happens once
19:01:34 <Toxaris> bench```: so you would like to delete the matching number and the matching "miles" from the list and try again
19:01:36 <ddarius> dobblego: It's not guaranteed and it's not necessarily true.
19:02:17 <Toxaris> pjd: is this enforced by the language definition, or is it just how haskell tends to be implemented?
19:02:34 <pjd> Toxaris: the latter, actually
19:03:35 <pjd> IIRC the language definition just requires non-strictness, strictly speaking
19:04:09 <pjd> you do get non-lazy implementations, like Eager Haskell
19:04:13 <bench```> Toxaris, exactly, that's why i asked how to do this repeatedly
19:04:48 <Toxaris> bench```: well, quick and dirty would be to do it with recursion
19:05:09 <ehaas> how does eager haskell work...
19:05:35 <ehaas> in the face of infinite lists etc.
19:05:38 <BMeph> WARNING: The following chat channel may contain discussion of an explicitly recursive nature. ;)
19:05:56 <Toxaris> bench```: somehow like this:
19:05:56 <Toxaris> processAll process test oldList = let (result, newList) = process oldList in
19:05:56 <Toxaris>   if test newList then result : processAll process test newList else result
19:06:28 <Toxaris> bench```: assuming you already have process and test :)
19:07:32 <Toxaris> BMeph: "if you want to know how to apply this repeatedly, you should first learn how to repeatedly it repeatedly."
19:09:04 <pjd> ehaas: when evaluation exceeds some resource usage limit, it gets suspended
19:11:38 <dons> ehaas: we actually have some eager data structures in everyday haskell too
19:11:49 <ehaas> it switches to lazy?
19:11:52 <dons> things like lazy bytestrings, they do fixed amounts of strict computation, then suspend
19:11:54 <ehaas> essentially?
19:11:55 <dons> very useful
19:12:08 <dons> do littles bursts of evaluation
19:12:14 <dons> not just the bare minium
19:12:16 <ddarius> dons: That's not quite the same thing...
19:12:36 <dons> its not the same as ubiquitous eagerness in the runtime
19:12:52 <dons> but you can write eager data structures that do have similar behaviour
19:13:10 <ehaas> cool...who decides how big the burst of evaluation is
19:13:22 <ddarius> ehaas has hit the nail on the head
19:15:32 <ehaas> ahh...area of active research :)
19:15:55 <dons> right. for particular data structures, you can usually do some heuristics
19:16:05 <dons> for ubiquitous eagerness, its a bit tricky :)
19:16:06 <ddarius> Not exactly.  The difference is the difference between Eager Haskell and what dons is talking about.
19:16:26 <dons> yeah, library author (aka user) , versus runtime
19:16:51 <ricky_clarkson> dons: Ever had any complaint from tinyurl about lambdabot using it so much?
19:17:51 <Toxaris> will explicit management of evaluation order fade away as explicit memory management does?
19:18:22 <ddarius> Toxaris: Possibly, but I'm not expecting it to anytime soon.
19:18:38 <shachaf> ricky_clarkson: A lot of automated places/bots use tinyurl, I understand.
19:18:46 <roger`> ricky_clarkson: I'd think that they want people to use it as much as possible, they probably value their company by the amount of traffic it gets.
19:18:54 <ddarius> Toxaris: The problem is undecidable.
19:19:16 <ricky_clarkson> I agree.  Someone's fretting about it so I thought I'd ask.
19:19:44 <skew> Has anybody looked at the functional programming support in pxsl? It's really wierd!
19:20:08 <Toxaris> ddarius: what problem? optimal evaluation order?
19:20:50 <ddarius> Toxaris: Even just strictness analysis is undecideable and that is necessary to turn things like foldl into foldl'.
19:22:05 <skew> you can write higher-order functions, but to pass functional arguments to other functions you have to (recursively) eta-expand to the correct arity
19:22:49 <bench```> Toxaris, i was hoping for some magic like fold*, but oh well, i can do recursion
19:23:36 <fadec> I've begun to doubt my ability to learn Haskell on my own.
19:24:38 <ehaas> why
19:24:41 <Toxaris> bench```: there may be some magic, who knows. goes my processAll in the right direction?
19:24:53 <fadec> Using Math.OEIS to learn a bit the fun way.
19:25:15 <fadec> lookupSequence [0,1,1,2] returns a Maybe monad
19:25:32 <ddarius> fadec: If you lack motivation then you are probably right, but then if you lack motivation why bother?
19:26:01 <Toxaris> bench```: if you can express process as process :: x -> x, you can use iterate and takeWhile
19:26:16 <fadec> nah, I'll keep at. The language has it's appeal. I actaully really like it.
19:26:19 <skew> fadec: there's always John Meacham's approach
19:26:29 <fadec> skew: what's that?
19:26:33 <LoganCapaldo> learning haskell on your own is hard. this is why we have #haskell :)
19:26:34 <ddarius> fadec: Then you'll probably be fine.
19:26:48 * ddarius didn't come to #haskell to learn (Haskell).
19:27:02 <Toxaris> ddarius: we need teachers, too
19:27:14 * LoganCapaldo is not as cool as ddarius
19:27:21 <bench```> Toxairs, yes
19:27:25 <skew> fadec: you understand a language pretty well by the time you've implemented it
19:27:32 <fadec> Well, I'm here to learn but even asking a question may take a while. Give me a minute.
19:27:36 <skew> fadec: so write a Haskell compiler in Haskell and you'll learn twice as fast!
19:27:43 <ehaas> can you implement haskell without understanding category theory
19:27:55 <ehaas> haskell compiler, i mean
19:28:01 <ddarius> ehaas: That's how all current implementors have done it.
19:28:08 <fadec> skew: ha
19:28:22 <ddarius> fadec: That is actually what John Meacham did.
19:28:37 <fadec> length $ Just [4,5,6]
19:28:40 <fadec> no no no
19:28:48 <ddarius> > fmap length $ [4,5,6]
19:28:49 <lambdabot>   add an instance declaration for (Num [a])
19:28:49 <lambdabot>     In the expression: 6
19:28:52 <ddarius> > fmap length $ Just [4,5,6]
19:28:53 <lambdabot>  Just 3
19:28:53 <skew> that's where JHC came from.
19:29:18 <Toxaris> > length <$> Just [4, 5, 6]
19:29:19 <lambdabot>  Just 3
19:29:21 <ddarius> Pugs came from Audrey doing an exercise in TAPL.
19:29:48 <skew> ddarius: she was specifically trying to make perl 6, I think
19:29:57 <fadec> ddarius: nice
19:30:21 <shachaf> skew: Yes, but just a toy interpreter (right?).
19:30:28 <ddarius> skew: The exercise was to "implement a small language", she decided to make a toy implementation of Perl 6.
19:31:07 <ricky_clarkson> Some toys are more pointy than others.
19:31:36 <jcreigh> shachaf: IIRC, pugs is currently the most complete Perl6 implementation around. But I could be mistaken.
19:31:39 <lament> also may contain smaller parts
19:32:08 <shachaf> jcreigh: But it wasn't meant to be originally, as I understand it.
19:32:10 <pjd> > let (.) = fmap in length . Just [4, 5, 6]
19:32:11 <lambdabot>  Just 3
19:32:12 <ddarius> http://www.perl.com/pub/a/2005/03/03/pugs_interview.html
19:32:13 <lambdabot> Title: perl.com: A Plan for Pugs
19:33:10 <jcreigh> shachaf: yeah, it just got a little out of hand.
19:34:53 <ddarius> So who's going to write a compiling implementation of ruby as an exercise?
19:37:16 <skew> Hmm, I think I'm going to finish my lambda calculus -> pxsl translator first
19:37:54 <skew> although it would probably be less work just to fix pxsl...
19:39:03 <LoganCapaldo> is pugs a compiler now?
19:39:32 <ddarius> LoganCapaldo: It's been a compiler for most of its existence.
19:39:52 * LoganCapaldo thought it was ana interpeter
19:39:59 <LoganCapaldo> AI guess I was wrong
19:40:04 <bench```> is there a primitive to test if a string has all digit? such as Char.isNumber, but takes a string?
19:40:09 <ddarius> It was originally and can be used as such.
19:40:21 <ddarius> all isDigit
19:40:32 * LoganCapaldo writes ruby -> syntax translator
19:40:40 <LoganCapaldo> * -> smalltalk syntax
19:40:44 <ddarius> Having a specific function could hardly be clearer.
19:40:45 <LoganCapaldo> I'm done
19:41:31 <bench```> ddarius, thank you
19:41:38 <shachaf> LoganCapaldo: Done?
19:41:46 <LoganCapaldo> with a compiling ruby
19:42:10 <ddarius> Oh yes, compile to Smalltalk -that'll- help.
19:42:34 <LoganCapaldo> help what?
19:43:45 <ddarius> Performance (though I am being somewhat unfair to Smalltalk here)
19:44:46 <LoganCapaldo> or overly fair to ruby
19:46:32 <fadec> I'm wondering why someone doesn't write a set of macros to turn ruby into lisp and run it that way.
19:46:45 <ddarius> ruby doesn't have macros
19:46:56 <ddarius> Or write them in Lisp?  What would be the point?
19:47:03 <dons> a compiler in macros? fun :(
19:47:13 <LoganCapaldo> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=ruby&lang2=vw
19:47:15 <lambdabot> Title: Ruby benchmarks | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Language Be ..., http://tinyurl.com/2tp24f
19:47:27 <LoganCapaldo> standard disclaimer about meaningless benchmarks applies
19:47:33 <fadec> Speed would be the point I guess
19:47:40 <skew> fadec: of compiling lisp to ruby?
19:47:44 <dons> then you'd target C, not lisp :)
19:47:53 <fadec> no ruby to lisp
19:48:12 <LoganCapaldo> ruby to smalltalk would be way easier than ruby to lisp
19:48:22 <dons> ruby to haskell would make more sense, speedwise. :)
19:48:31 <fadec> Even with CLOS?
19:48:35 <ddarius> LoganCapaldo: As I said, I was being somewhat unfair to Smalltalk, but then do the Ruby v. Haskell or Smalltalk v. Haskell.
19:48:38 * BMeph pities skew's ability to ever "learn" COBOL...
19:48:41 <dons> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=ruby&lang2=ghc
19:48:42 <lambdabot> Title: Ruby benchmarks | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Language Be ..., http://tinyurl.com/2nf5kc
19:48:46 <dons> i love that graph.
19:48:59 <ddarius> dons: I want all speed bars to be pinned to the right.
19:49:10 <LoganCapaldo> yeah but ruby to smalltalk is "easy"
19:49:11 <ddarius> Er left in that one.
19:49:12 <dons> yeah. until then, i shall not rest!
19:49:14 <skew> BMeph: is there some hopelessly convoluted way to compile the lambda calculus into COBOL?
19:49:53 <shachaf> dons: How about this graph? http://people.debian.org/~igloo/popcon-graphs/index.php?packages=ghc6,ruby
19:49:53 <lambdabot> Title: popcon graph, http://tinyurl.com/36qvte
19:49:58 * shachaf tries to trick dons again.
19:50:02 <Nafai> dons: Is this still with ghc 6.6?
19:50:03 <ddarius> @google "A functional correspondence between abstract machines and interpreters"
19:50:04 <lambdabot> No Result Found.
19:50:09 <ddarius> @google "A functional correspondence between abstract machines"
19:50:11 <lambdabot> No Result Found.
19:50:17 <dons> shachaf: yeah, still with ghc6.
19:50:19 <ddarius> skew: The answer is yes.
19:50:27 <LoganCapaldo> in the "oh crap, I need this to be faster but it's all written in ruby! and I need it yesterday" scenario.
19:50:44 <shachaf> dons: s/shachaf/Nafai/?
19:50:45 <dons> shachaf: hah :((
19:50:55 <dons> Nafai: yeah. 6.6
19:51:00 <dons> shachaf: bad person
19:51:12 * LoganCapaldo can't think of when that scenario would ever happen
19:51:16 <dons> i find popcon depressing
19:51:51 * pjd parsed "popcorn"
19:52:02 <dons> american popcorn is depressing
19:52:06 <dons> the stuff that comes in bags
19:52:12 <dons> it smells ... weird.
19:52:19 <dons> i think they put a flavour on it
19:52:21 <ddarius> Popcorn is mostly nasty.
19:52:29 <ddarius> dons: There are all kinds of popcorn.
19:52:33 <thetallguy> Are there any library calls that get gc stats from the GHC runtime?
19:52:55 <dons> thetallguy: inside haskell?
19:52:57 <LoganCapaldo> maybe ruby -> eiffel would make more sense speed wise. http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=ghc&lang2=se . you'd have to start managing your own memory (I think, does eiffel have gc?)
19:52:58 <lambdabot> Title: Haskell GHC benchmarks | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lang ..., http://tinyurl.com/yrjldn
19:53:06 <dons> thetallguy: bernie pope wrote some bindings a while ago
19:53:15 <LoganCapaldo> but at least the keywords are pretty similar
19:53:18 <dons> i was thinking it would be nice to do my own heap checks just yesterday
19:53:28 <LoganCapaldo> if not necessarily always meinign the same thing
19:53:33 <thetallguy> dons: yes, like performGC :: IO Stats instead of IO ()
19:53:36 * LoganCapaldo is super off topic
19:54:08 * ddarius watches a movie.
19:54:18 <thetallguy> dons: I wrote a little timing function, but what I realized I really wanted both time and memory feedback
19:54:18 <shachaf> LoganCapaldo: Less than popcorn...
19:54:42 <Nafai> http://programming.reddit.com/info/63bz9/comments/c02paw6 <- What does the poster mean here in reference to aliasing and laziness?
19:55:12 <Nafai> Oh, it was explained in a later comment
19:55:18 <shachaf> Why does Ruby beat GHC so often in memory use?
19:55:24 <LoganCapaldo> someone used "idempotent" when they meant referentially transparent in some ancient joel on software thread. I was frustrated when I couldn't comment.
19:56:40 <LoganCapaldo> ghc probaby just alocates more from the get go
19:56:57 <LoganCapaldo> adn neither of them end up needing more
19:57:04 * LoganCapaldo random speculation
19:57:47 * shachaf doesn't understand why people confuse those two. "You get the same result when applying the function a second time?"
19:58:00 <LoganCapaldo> i blame rest
19:58:05 <LoganCapaldo> *REST
19:58:27 <ricky_clarkson> Why do you apply it a second time, when it'll just give the same value?
19:59:00 <LoganCapaldo> i think that started the whole "let's use idempotent to describe something analogous to it, but not exactly it" thing
19:59:08 <LoganCapaldo> and it just got corrupted from there
19:59:14 <LoganCapaldo> stupid web
19:59:30 <LoganCapaldo> lets go back to just irc and newsgroups
20:00:12 <shachaf> Idempotence is f(f(x)) == f(x), right? And referential transparency is f(x) == f(x)?
20:00:28 <shachaf> Or rather, (let x = f(x) in f(x) == x)?
20:00:43 <dobblego> shachaf, correct
20:00:46 <shachaf> (let y = f(x) in f(y) == y), I mean.
20:01:06 <LoganCapaldo> err that second one is wrongish
20:01:25 <LoganCapaldo> x == y -> f(x) == f(y) is referential transparency
20:01:37 <skew> it's hard to even write what not-referential transparency would be in a way that makes sense, in mathish
20:02:43 <Cale> Well, it's sort of like the difference between functions and relations.
20:02:46 <BMeph> I think it's interesting that when Ruby used less memory, it was most often in the range of 10% less, but got more dramatic when gzipped. This seems to suggest to me that Haskell's already densely written, in the sense of more information per byte.
20:03:12 <skew> gzipping source code is very odd
20:03:34 <shachaf> BMeph: Those don't measure the same thing.
20:04:27 <thetallguy> dons: is bernie pope on #haskell?
20:04:32 <shachaf> BMeph: And they're saying gzip(haskell-source) = 1.3 * gzip(ruby-source) (right?).
20:04:43 <Pseudonym> ?seen bjpop
20:04:44 <lambdabot> I haven't seen bjpop.
20:04:45 <BMeph> shachaf: Ah - it's memory used in running, and memory used in storing the program gzipped, you mean?
20:04:46 <Pseudonym> Nope.
20:04:58 <thetallguy> thanks, that's what I was looking for
20:05:00 <shachaf> BMeph: Yes.
20:05:08 <LoganCapaldo> BMeph: gzip(source) is supposed to be a "airer" vesion of lines of code
20:05:16 <LoganCapaldo> *"fairer"
20:06:05 <shachaf> Can you write a program in Haskell/Ruby such that gzipping the source makes it bigger? :-)
20:06:32 <skew> "fairer" in the sense of ignoring the enforced redundancy of the language and being totally useless to humans?
20:06:54 <BMeph> shachaf: I'm sure I could, and I know it's been done. I don't know why anyone would do it deliberately, though.
20:07:39 <goalieca> Korollary, go linden!!!
20:07:50 <LoganCapaldo> skew: I think that's the idea Possibly also to discourage cramming stuff together w/o whitespace?
20:08:52 <skew> measuring non-whitespace bytes is easy
20:09:22 <shachaf> Whitespace wins! :-)
20:09:26 <shachaf> @where whitespace
20:09:26 <lambdabot> I know nothing about whitespace.
20:10:29 <oerjan> @hoogle whitespace
20:10:30 <lambdabot> Text.ParserCombinators.Parsec.Token.whiteSpace :: TokenParser st -> CharParser st ()
20:10:46 <shachaf> @go whitespace language
20:10:46 <lambdabot> http://compsoc.dur.ac.uk/whitespace/
20:10:47 <lambdabot> Title: Whitespace
20:11:06 <Korollary> goalieca: I just switched to it during the 1st intermission of Ducks vs Sharks.
20:13:07 <goalieca> how is that game going?
20:13:23 <goalieca> i was at the home opener vs the sharks this year. they won of course
20:14:52 <wy> I guess I understand why Haskell need "main". Is it because of laziness? We don't know where to start unless we have some entry point.
20:15:16 <scook0> wy: well, most languages have some kind of defined entry point
20:15:22 <thetallguy> ?seen nanothief
20:15:23 <lambdabot> nanothief is in #haskell. I last heard nanothief speak 1h 44m 52s ago.
20:15:32 <scook0> except for "scripting"-family languages
20:15:48 <scook0> (which tend to just execute top-down)
20:15:55 <Korollary> goalieca: 0-0.
20:16:12 <nanothief> still here :)
20:16:30 <Korollary> goalieca: The game in Anaheim was great. I doubt it will be as good tonight in San Jose.
20:16:40 <thetallguy> nanothief: regarding takeWhileM
20:16:42 <scook0> the "top-down" approach wouldn't really work in haskell, because of the declaration/expression distinction
20:16:48 <oerjan> wy: since haskell has no notion of executing things just by loading a module (and this is considered a feature)
20:17:13 <thetallguy> nanothief: hard to implement the equivalent of takeWhile, because you need to look at the result, then put it back.
20:17:26 <Jomyoot> Is haskell productive still if your code requires a lot of state changes?
20:18:20 <nanothief> thetallguy: I ended up implementing it so that it takes one past where the guard fails
20:18:37 <thetallguy> Right, which is reasonable, but not the equiv of takeWhile
20:18:38 <nanothief> then no lookahead is required
20:18:54 <wy> So is this a feature of "compiled" languages?
20:18:56 <goalieca> Korollary, well its 4-0 for canucks. brodeur is wide open
20:19:19 <thetallguy> nanothief: and I think that's why it's not predefined.
20:19:28 <Korollary> goalieca: He couldn't do anything about that last one. I saw the first one, which was weak.
20:19:59 <thetallguy> nanothief: you could make a monad that would hang onto that value .  I think ghc does have ungetChar internally
20:20:02 <nanothief> if you did liftM init (myTakeWhileM) it would be the equivilant I think
20:20:42 <Korollary> goalieca: Phoenix absolutely trashed the Devils in NJ, too.
20:20:58 <thetallguy> nanothief: the result for that function would be the same, but it would leave the IO channel still one further character down than ideal.
20:21:02 <wy> In scripting languages, the definitions are considered to be "executed". Is that the reason they don't have main?
20:21:24 <thetallguy> takeUntil would be a better name
20:21:27 <oerjan> wy: scripting languages have commands other than definitions.
20:22:02 <wy> So is Lisp considered to be a scripting language?
20:22:06 <oerjan> so does scheme, which can be both compiled and interpreted.
20:22:18 <pjd> wy: "scripting" doesn't have any well-defined meaning
20:22:20 <scook0> wy: that really depends on your point of view
20:22:26 <Jomyoot> Does conceptualizing Monad for state change hinder or help programming, as opposed to typical procedual languages
20:22:35 <scook0> (which is why I put quotes around "scripting")
20:22:50 <wy> I guess the difference is that they have access to the "evaluator"
20:23:09 <pjd> wy: Python programs not uncommonly use a "main" entry point
20:23:34 <scook0> but for the purposes of this discussion, lisps tend to have the same properties as perl/python/ruby etc. in terms of executing definitions
20:23:46 <pjd> it has more to do with how you want to organize your particular program than anything else
20:24:18 <scook0> pjd: though in python, "main" is a convention rather than a requirement
20:24:25 <pjd> right
20:24:29 <nanothief> thetallguy: maybe takeTo as well? doesn't really matter though, I was just worried that I  was reimplementing a standard function (which i do all the time :P)
20:24:41 <scook0> (the original question being "why does Haskell need main?")
20:25:16 <pjd> s/Haskell need/Haskell implementations use/, really
20:25:21 <scook0> I believe in lispy circles it's commonplace to reload a modified source file into a running program
20:25:24 <skew> Jomyoot: It points out a useful conceptual distinction, between assembling and performing actions
20:25:28 <scook0> updating the existing definitions
20:25:49 <Jomyoot> Where is the best intro to monad?
20:25:50 <thetallguy> nanothief: yeah, nothing seems to quite fit.
20:25:51 <oerjan> pjd: well main is defined in the report
20:25:55 <scook0> pjd: main is H98, though...
20:26:08 <skew> Jomyoot: that really depends on what you know
20:26:18 <pjd> nothing prevents you from supporting alternate mechanisms in addition, though
20:26:22 <scook0> but in the broader sense, it's possible for non-standard Haskells to do different things
20:26:23 <scook0> yes
20:26:23 <thetallguy> nanothief: it's sort of like an unfoldR
20:26:26 <chessguy> @where metatutorial
20:26:26 <lambdabot> I know nothing about metatutorial.
20:26:30 <thetallguy> unfoldrM
20:26:32 <chessguy> @where metat-utorial
20:26:33 <lambdabot> I know nothing about metat-utorial.
20:26:40 <chessguy> @where meta-tutorial
20:26:40 <lambdabot> I know nothing about meta-tutorial.
20:26:43 <chessguy> bah
20:27:01 <Jomyoot> i am an experienced programmer but very new to haskell
20:27:14 <pjd> scook0: well, it wouldn't be non-standard if main is still available, would it?
20:27:28 <chessguy> Jomyoot, there are many monad tutorials out there. what background are you coming from?
20:27:39 <Jomyoot> lisp, ruby, java,
20:27:45 * oerjan points at ghc's --main-is flag
20:27:56 <skew> Jomyoot: if you already know functional programming, and maybe even denotational semantics then Wadler's papers could be good
20:28:08 <chessguy> Jomyoot, hmm, you might like the scheme tutorial then
20:28:09 <skew> Jomyoot: showing why you'd want to start using monads if you are writing interpreters
20:28:24 <scook0> pjd: I'm not familiar enough with the spec to have an answer to that
20:28:27 <wy> skew: agree. I'm reading it
20:28:28 <chessguy> @go write yourself a scheme in 24 hours
20:28:29 <lambdabot> http://www.scribd.com/doc/125018/Write-yourself-a-Scheme-in-48-hours
20:28:30 <lambdabot> Title: Write yourself a Scheme in 48 hours
20:28:37 <chessguy> Jomyoot, ^^
20:32:24 <SamB_XP> chessguy: ever optimistic, eh?
20:32:31 <skew> Jomyoot: I learned monads long before they were written, but Dan Pipponi has two articles that look really good
20:32:37 <chessguy> SamB_XP, hm?
20:32:38 <skew> http://sigfpe.blogspot.com/2007/11/io-monad-for-people-who-simply-dont.html
20:32:39 <lambdabot> Title: A Neighborhood of Infinity: The IO Monad for People who Simply Don't Care, http://tinyurl.com/yplmwx
20:32:47 <skew> http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
20:32:48 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ..., http://tinyurl.com/ecqzl
20:32:49 <SamB_XP> chessguy: you said 24 hours instead of 48
20:32:55 <chessguy> oh
20:32:59 <chessguy> i always get that wrong
20:33:29 <wy> scheme48 ? hehe
20:33:43 <oerjan> @go write yourself a scheme in 48 minutes
20:33:56 <lambdabot> http://www.supplycrawler.com/forums/write-yourself-a-scheme-in-48-hours/conclusion.html
20:33:56 <lambdabot> Title: Write Yourself A Scheme In 48 Hours/conclusion Forums
20:34:19 <chessguy> forums?
20:34:20 <skew> the top and more recent one should give enough context to start slinging around some basic IO, if for some reason reading the Haskell report and the Gentle Introduction wasn't enough
20:34:21 <SamB_XP> @go write yourself a scheme in 12 milliseconds
20:34:23 <lambdabot> Plugin `search' failed with: Lib.URL.isTextHTML: getHeader failed
20:34:30 <wy> I still like writing a lambda calculus interpreter better
20:34:43 <SamB_XP> ?
20:35:03 <wy> What's the difference between _|_ and Omega ?
20:35:30 <wy> > let bot=bot
20:35:31 <lambdabot>  Parse error at end of input
20:35:37 <oerjan> Omega is a type isn't it? </vague recall>
20:35:47 <oerjan> while _|_ is a value
20:36:03 <wy> Omega is (\x -> x x) (\x -> x x), if I remember
20:36:45 <chessguy> @type (\x -> x x) (\x -> x x)
20:36:47 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
20:36:47 <lambdabot>     Probable cause: `x' is applied to too many arguments
20:36:47 <lambdabot>     In the expression: x x
20:36:52 <oerjan> oh that one.  well Omega = _|_ in haskell's denotational semantics.  well it would if you could type it.
20:37:37 <oerjan> *would be
20:38:11 <oerjan> although fix id should be a close approximation
20:38:59 <oerjan> > fix id
20:39:00 <lambdabot>  Exception: <<loop>>
20:39:14 <wy> > bot = bot
20:39:14 <lambdabot>  Parse error at "=" (column 5)
20:39:41 <oerjan> that's a declaration. > requires an expression.
20:40:06 <wy> Can't I use let?
20:40:09 <oerjan> > let bot = bot in bot
20:40:10 <lambdabot>  Exception: <<loop>>
20:40:20 <wy> Oh, that's it
20:40:48 <oerjan> @let bot = bot
20:40:50 <lambdabot> Defined.
20:40:54 <oerjan> > bot
20:40:55 <lambdabot>  Exception: <<loop>>
20:41:31 <wy> Do I need some switch for ghc to make it detect loops?
20:41:57 <oerjan> it doesn't work automatically?
20:42:13 <wy> I used main = bot
20:42:18 <wy> But it just ran forever
20:42:50 <allbery_b> I think ghci catches such things but ghc does not
20:43:24 <allbery_b> (note that ghci catches them at runtime, by patching entered thunks so that immediate re-entry triggers an exception)
20:44:01 <wy> ghci doesn't either. ghc used to do that
20:44:55 <oerjan> "-dno-black-holing Turn off black holing (probably doesn't work)"
20:45:49 <oerjan> you would think that meant they were on by default...
20:47:25 <wy> ghc-6.6.1: unrecognised flags: -dno-black-holing
20:47:58 <oerjan> i was looking at the 6.8.2 manual
20:48:17 <wy> It appears in my manual too, but it doesn't work
20:48:26 * allbery_b forgot that LB compiles, not interprets, so it must be in the compiler too
20:49:44 <wy> I used switch -O2 and it works a.out: <<loop>>
20:51:31 <wy> Sometimes I'm wondering why the patterns in definitions can't be separated into different places.
20:51:55 <SamB_XP> too confusing!
20:52:27 <SamB_XP> also probably makes it rather harder to parse...
20:53:00 <wy> Have you tried regexp patterns? I saw a library for this somewhere
20:53:39 <wy> :t error
20:53:40 <lambdabot> forall a. [Char] -> a
20:54:00 <oerjan> @src error
20:54:00 <lambdabot> error s = throw (ErrorCall s)
20:54:15 <wy> :t throw
20:54:16 <lambdabot> Not in scope: `throw'
20:54:29 <wy> :t ErrorCall
20:54:29 <lambdabot> Not in scope: data constructor `ErrorCall'
20:54:48 <allbery_b> ?index ErrorCall
20:54:48 <lambdabot> Control.Exception
20:55:15 <wy> It seems ghci hasn't those conveniency
20:55:37 <wy> How can I show the source of some function?
20:56:09 <oerjan> @source Control.Exception
20:56:10 <lambdabot> http://darcs.haskell.org/packages/base/Control/Exception.hs
20:56:55 <oerjan> quite possibly ghc doesn't include the source
20:57:26 <oerjan> :t Control.Exception.throw
20:57:28 <lambdabot> forall a. GHC.IOBase.Exception -> a
20:57:42 <oerjan> :t Control.Exception.ErrorCall
20:57:43 <lambdabot> String -> GHC.IOBase.Exception
20:57:54 <wy> But we can download the source. I hope it's possible to tell ghc that we have the source somewhere
20:58:14 * oerjan doesn't know
20:58:15 <allbery_b> it's not
20:58:51 <allbery_b> @doc
20:58:51 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
20:59:08 <allbery_b> there are source links in the library documentation
21:00:38 <wy> alright. time to continue reading. Thanks!
21:08:41 <Korollary> goalieca: Naslund eh
21:14:38 <goalieca> hehe . yup
21:17:11 <dobblego> ?type hehe . yup
21:17:13 <lambdabot> Not in scope: `hehe'
21:17:14 <lambdabot> Not in scope: `yup'
21:19:48 <alexj> what is a likely cause of this error message? *** Exception: Text.ParserCombinators.Parsec.Prim.many: combinator 'many' is applied to a parser that accepts an empty string.
21:20:12 <alexj> it appears when I have too many choices I think but any subset of those choices works ok.
21:20:58 <oerjan> many, as it says, cannot take an argument that can succeed parsing an empty string.  it wouldn't know when to stop.
21:22:06 <alexj> I get that but I don't think I am doing that.
21:22:45 <alexj> many1 $ choice $ map try [thing1,thing2, thing3]
21:22:56 <alexj> none of the things can be empty.
21:23:02 <oerjan> hm...
21:23:12 <oerjan> and you have verified this?
21:23:47 <alexj> well I have thing[1-4] and if I have any 3 of them it works fine.
21:23:54 <alexj> onlye if I have all four do I get an error.
21:24:09 <oerjan> that's weird.
21:24:20 <alexj> yes.
21:24:32 <alexj> @hpaste
21:24:33 <lambdabot> Haskell pastebin: http://hpaste.org/new
21:25:42 <alexj> http://hpaste.org/4569
21:26:22 <alexj> actually I have 5 things but must eliminate at least one of 1-4.
21:26:32 <alexj> oejan: is the hpaste visible?
21:26:40 <alexj> oerjan: is the hpaste visible?
21:28:59 <oerjan> yep
21:31:46 <bench````> how do i express (isDigit || (== ',')) correctly?
21:32:14 <bench````> i want to do takeWhile (isDigit || (== ',')) s
21:32:17 <shachaf> liftM2 (||) isDigit (== ',')? :-)
21:32:41 <shachaf> (\x -> isDigit x || x == ',') -- Probably clearer.
21:32:41 <oerjan> (\c -> isDigit c || c == ',')
21:33:45 <moconnor> Is there a good mailing list for newbie / intermediate Haskell questions?
21:33:57 <dobblego> Haskell-Cafe
21:34:23 <bench````> shachaf/oerjan, thank  you
21:34:23 <oerjan> alexj: sorry too complicated at this time (i've got a slight headache)
21:34:40 <alexj> oerjan: ok thanks anyway.
21:40:10 <Nafai> So is xmonad a good example of a small-but-decent-sized Haskell application?  Something I can learn from by reading the source, seeing how it's packaged and split into modules and documented, etc?
21:40:20 <Nafai> Are there any other good examples people would recommend?
21:40:52 <Adamant> this is a question I'd like to see answered too
21:40:57 <smack_> Nafai: seems to be to me
21:41:03 <BMeph> Nafai: Have you had a look at the Data.Bytestring modules?
21:41:26 <sjanssen> Data.ByteString is not a typical Haskell module, IMO
21:41:50 <sjanssen> read that if you want to learn about Ptr
21:42:17 <Nafai> I haven't; but I'm not interested in libraries (though those are interesting in their own right), because I believe an application is designed slightly differerent, is it not?
21:42:23 <dons> i think xmonad is a good example of a 'classic' interactive,stateful haskell program
21:42:31 <dons> bytestring isn't. its very atypical
21:42:43 <dons> Data.Map is a better example for serious data structure libraries
21:42:47 <ddarius> xmonad is almost certainly an excellent case study of a well-designed Haskell program and an extremely effective methodology.
21:42:51 <Pseudonym> Besides, bytestring isn't a program.
21:43:36 <Nafai> All I've written so far is just small pieces of code to solve Project Euler problems
21:43:47 <dons> ok. so time to pick a problem in the medium size
21:43:48 <Nafai> So nothing large or where I have to worry about more than a few functions
21:44:01 <Nafai> So I'm curious how one approaches an "application"
21:44:01 <dons> irc bots are a good start
21:44:16 <dons> since they're not too stateful, but do have some little StateT things going on. and a nice pure core
21:45:10 <ddarius> dons: Bah, what's something that hasn't been done.
21:45:32 <dons> mm
21:45:52 <dons> ?remember praetorian42 I have yet to come across a scenario where compile-time type checking is a worthwhile substitute for reasonably thought-out dynamic code
21:45:52 <lambdabot> Okay.
21:46:21 <dons> its funny how you can flip 'compile-tim type checking' and 'dynamic' and the sentence makes perfect sense
21:46:26 <Nafai> dons: Is that a quote from a reddit comment thread?
21:46:31 <dons> yeah :)
21:46:38 <Pseudonym> No, you just need to be careful how you define "reasonably thought-out".
21:46:48 <Pseudonym> I define it as "Hindley-Milner type checking".
21:47:00 <dons> if figure, if you're doing reasonable thinking, may as well write down the type
21:47:49 <Nafai> I agree that staticly typed languages without type inference are a pain
21:48:02 <ddarius> It's just a tautological statement: good code => good code, static type checking =/> good code
21:48:46 <Pseudonym> It is true that compile-time type checking is not a substitute for thought.
21:48:52 <dons> heh
21:48:52 <Pseudonym> But that wasn't the claim.
21:49:22 <ddarius> Actually... with descriptive enough types...
21:49:27 <dons> i have to admit sometimes i just write the type, then let the checker do the thinking about what code breaks
21:49:37 <pjd> dons: "As far as security is concerned, I fail to see how type factors in to the security of a web framework/application."
21:49:52 <Pseudonym> ddarius: Trouble is, a descriptive-enough type system is essentially a dynamically typed programming language.
21:49:53 <dons> that scares me just a little, pjd
21:50:10 <ddarius> Pseudonym: Not necessarily dynamically typed, but yeah, I'm well aware of that.
21:50:14 <dons> since he then goes on to talk about how flexible it is to treat a url as a number
21:50:24 <dons> which i think might show how far gone he is...
21:50:25 <ddarius> "php" = 0 !
21:50:44 <SamB_XP> so URLs are php-terminated now?
21:51:10 <allbery_b> tiem to hack the bot so p[lusplussing php acts like plusplussing java :)
21:51:12 <ehaas> i thought php's were url terminated
21:51:18 <dons> "http://php.net" == null
21:51:19 <lambdabot> Title: PHP: Hypertext Preprocessor
21:51:40 <dons> Hypertext!?
21:51:43 <SamB_XP> allbery_b: but nobody plusplusses PHP
21:52:00 <dons> hypertext. mm. sounds awesome
21:52:10 <SamB_XP> dons: indeed!
21:52:14 <dons> i notice the first thing on the front page is
21:52:16 <dons> "Security Enhancements and Fixes in PHP 5.2.5:"
21:52:16 <skew> dons: I just did that with some CPS code, so much easier than chasing what sorts of lambdas end up where
21:52:18 <shachaf> Oh, someone made @karma case-insensitive?
21:52:44 <ddarius> Silly skew, you just have @djinn write that code for you.
21:52:58 <dons> how many of the security bugs on the frontpage of php.net are type errors?
21:53:04 <dons> "Fixed dl() to only accept filenames" -- looks like one.
21:53:15 <dons> "Fixed htmlentities/htmlspecialchars not to accept partial multibyte sequences"
21:53:33 <dons> "Fixed bug #41561 (Values set with php_admin_* in httpd.conf can be overwritten with ini_set())"
21:53:42 <ddarius> @djinn (a -> (b -> r) -> r) -> ((b -> r) -> r) -> (a -> r) -> r
21:53:42 <lambdabot> -- f cannot be realized.
21:54:27 <ddarius> @djinn ((a -> (b -> r) -> r) -> ((b -> r) -> r)) -> (a -> r) -> r
21:54:28 <lambdabot> -- f cannot be realized.
21:55:10 <dons> reading this was funny, http://www.fallenfrukt.com/blog.php?id=5479
21:55:14 <lambdabot> Title: c Fallen Frukt 4d
21:55:15 <dons> "A Common Lisp web startup test-case,"
21:55:45 <dons> "It's for example quite probable that your popular language X has got a JSON handling library, and we had to build it from scratch."
21:55:56 <dons> in particular. since i had to write a json lib a couple of weeks ago :)
21:56:02 <Korollary> dons: How about this one? http://programming.reddit.com/info/63bz9/comments/c02pcih?context=3
21:56:30 <dons> neelk is smart. so you have to be careful :)
21:56:42 <dons> http://www.cs.cmu.edu/~neelk/
21:56:43 <lambdabot> Title: Neel's home page
21:56:44 <skew> dons: how many weeks ago? I've seen a few floating around for a while
21:57:06 <Korollary> dons: I know who he is. You just need to tell him how much you've been plagued thinking about runtime behavior.
21:57:48 <dons> yeah, i'm just thinking about why i'm not being plagued
21:58:01 <skew> I'm thinking of the analyses in Okasaki
21:58:24 <skew> it's because you don't have to worry about everything going off at once and piling up to give the worst case stack usage
21:59:30 <skew> if the code is lazy enough to make ordering unclear, it's lazy enough that it's split up into thunks that just some small bit of code and maybe allocate a few more thunks
22:03:47 <ddarius> What the hell?  The answer is obvious.  One just doesn't bother unless a problem comes up.  How do you think imperative programs get written?  Obviously people learn how to write code that (usually) manages to avoid these issues.
22:04:50 <dons> i think that's it, yeah, ddarius. you learn what things cost.
22:05:02 <dons> and then its easy.
22:05:16 <dons> and then you hook mmap into your garbage collector and play with laziness all day long
22:05:19 <dons> and it is good
22:05:22 <chadz_> the problem is simple, play more starcraft
22:05:35 <SamB_XP> or at least you learn things that just don't work..
22:12:01 <dons> Korollary: of course, neelk has to make these statements. he's at cmu :)
22:12:34 <chadz_> all of my cmu friends think haskell is stupid.
22:12:35 <dons> i think you're not allowed to graduate, unless you disavow laziness (harper's pl intro book is really scathing :)
22:12:56 <dons> chadz_: yeah, its an sml school. that's the law.
22:13:15 <dons> it must suck writing compiler hacks without purity though. that's where all the fun is at.
22:14:19 <dons> Irssi: #sml: Total of 13
22:14:21 <dons> 'nuff said.
22:15:09 <thetallguy> what does harper have against laziness?
22:16:42 <allbery_b> hey now, some of us know better!
22:17:07 <allbery_b> I turn out not to be the only haskeller on the grad student zephyr setup, even
22:17:29 <dons> heh yay allbery_b !
22:17:53 <thetallguy> the spy who came in from ml
22:18:01 * dons flips through plbook looking for the laziness metaphor
22:18:16 <allbery_b> (of course I'm staff and not even in SCS, or having a degree from them...)
22:19:00 <thetallguy> Ah, it's that lack of a formal education that got you where you are.
22:19:26 <sclv> is that "comically baroque" comment on the reddit article 4 real!?
22:19:53 <allbery_b> enh, could be a formal education from /= CMU SCS
22:20:23 <allbery_b> (that said, in fact very little formal CS ed.  if I'd stuck to that I'd be writing COBOL...)
22:20:33 <dons> "eager languages are strictly more powerful than lazy languages" -- i've to to think about his argument here some more.
22:21:02 <Korollary> dons: it had something to do with function application, but I was about to doze off.
22:21:03 <olsner> huh? for what definition of power?
22:21:17 * allbery_b is baffled by that
22:21:22 <dons> Korollary: yeah, that's the one.
22:21:26 <skew> "More haste, less speed"
22:21:34 <dons> there used to be a sentence here about throwing the baby out with the bathwater
22:21:41 <dons> but that text seems to not be in the present text
22:22:34 <dons> but i note there's a new chapter on laziness and speculative parallelism
22:22:39 <dons> which looks nice
22:23:02 <sjanssen> "All the same difficulties that apply to reasoning about the behavior of code using shared mutable state apply to reasoning about the performance of Haskell programs." is a very interesting point
22:23:14 <allbery_b> enh?  laziness gets you "new syntax" without the need for macro processing facilities (thus try .. finally type stuff, etc.)
22:23:57 <BMeph> I like "The advantages and disadvantages of lazy vs. eager languages have been hotly debated. We will not enter into this debate here, but rather content ourselves with the observation that laziness is a special case of eagerness."
22:24:06 <skew> couldn't be asymptotic performance, maybe it's easier to integrate side effects?
22:24:22 <skew> sclv: which?
22:24:28 <dons> anyway, i don't want laziness, i want a continuum of strategies.
22:24:54 <thetallguy> Yes, and control over how those get applied
22:25:04 <thetallguy> and tools to see which ones work well.
22:26:21 <dons> i seem to be using partially strict, but lazy where it counts, structures a lot these days
22:26:22 <olsner> what does "special case of eagerness" mean?
22:26:32 <dons> strict spines with lazy bodies, lazy spines with strict bodies
22:27:39 <thetallguy> sounds like mythbusters dummies made with ballistic gel
22:27:52 <Cale> Uh, how is laziness a special case of eagerness?
22:28:12 <skew> Assuming an impure language with mutable references you can fake it, I suppose?
22:28:25 <Korollary> You can fake both with the other
22:28:36 <olsner> perhaps it's supposed to be the other way around? eagerness is a (the least lazy) special case of laziness
22:28:39 <skew> you can't get laziness right in a pure language
22:29:26 <skew> http://web.comlab.ox.ac.uk/oucl/work/geraint.jones/morehaste.html
22:29:27 <lambdabot> Title: Research Highlights - More Haste Less Speed
22:30:11 <wy> sjanssen: What are you talking about? Is it some article?
22:30:24 <sjanssen> wy: http://programming.reddit.com/info/63bz9/comments/c02pcih
22:31:05 <dons> sjanssen: yes, the correctness issue is the other one. there's an implication that programs go wrong.
22:31:09 <skew> "... This demonstrates that lazy evaluation is strictly more efficient - in asymptotic terms - than eager evaluation"
22:31:53 <dons> ah yes :)
22:32:08 <dons> good old Richard Bird. always has the big guns :)
22:32:48 <dons> so when you're too strict, its hard to know if your prograam will terminate
22:32:57 <skew> I heard of a case where laziness was important even in a strongly-normalizing language.
22:33:06 <Korollary> It's not just about asymptotic behavior, tho. Thunk creation has its overhead.
22:33:16 <dons> when you're too lazy, its hard to know when things are created.
22:33:55 <skew> Someone was programming an algorithm in Coq which terminated quite quickly, but could only be proved to terminate with awful giant numbers from Ramsey theory.
22:34:06 <dons> http://programming.reddit.com/info/63e6o/comments/
22:34:12 <dons> `More Haste, Less Speed: The Complexity of Lazy Evaluation'
22:34:31 <dons> some things reward a second read
22:34:32 <wy> I can't see why laziness can lead to inefficiency. Does it really need "thunks"?
22:34:44 <dons> skew: very interesting!
22:34:58 <olsner> hmm, but if it terminates for known values quickly, it is proven that the algorithm terminates for those values :P
22:35:11 <dons> wy, well, you have to stop the computation somehow
22:35:20 <dons> and track the results you've got so far
22:35:56 <sjanssen> wy: you have to record unevaluated subexpressions somehow
22:36:21 <dons> we have to emphasise more often how throwing out equational reasoning is unacceptable
22:37:12 <skew> I would say the critical part is having a machine-checked sublanguage where it's valid
22:37:14 <wy> Is that what thunks mean?
22:37:41 <Plareplane> strictly more powerful... is it only for those certain programs? or in general?
22:37:51 <wy> There is also eager parameters, but I haven't learned when to use them yet
22:37:54 <skew> Plareplane: the particular example is some kind of streaming computation thing
22:38:14 <dons> wy, yep, the object on the heap that stores your closed over environment, and a pointer to some code to jump to
22:38:32 <dons> wy, ghc even stores whether its been evaluated or not, and to what constructor, in the low bits of the pointer to the thunk
22:38:35 <dons> kinda super neat :)
22:39:29 <wy> dons: How does it write that part? Those bit operations?
22:40:20 <dons> bits get set by the runtime, when the thunks are evaluated.
22:42:03 <skew> wy: you can also implement laziness with graph reduction
22:42:03 <dons> "there is no general complexity-preserving translation of lazy programs into an eager functional language" is very interesting
22:42:06 <wy> I mean is it written in some low level package?
22:42:23 <wy> Data.Bits or something?
22:42:45 <dons> ah no, in the runtime C, and generated code from the compiler backend
22:43:24 <scook0> I suppose it makes sense that you can exploit laziness to give you some of the performance benefits of impurity
22:45:40 <dons> i like the mmap(2) example. you get sharing and amazing lazy io, but only if you don't go around mutating data
22:46:36 <dons> the mmap man page is like a twisted kernel level view of laziness, and the problems of unsafeInterleaveIO
22:46:37 <quicksilver> dons: surely that's not true (complexity-preserving translation). There is a well known and trivial embedding of lazy functional into eager functional, using () -> all over the place.
22:46:39 <dons>  http://linux.die.net/man/2/mmap
22:46:40 <lambdabot> Title: 3d mmap(2): map/unmap files/devices into memory - Linux man page 9
22:46:54 <wy> I guess laziness can be only slower than the eager one if there are lots of straighforward code that's even cheaper than the overhead of deciding whether an argument is evaluated. How can that happen?
22:46:59 <skew> quicksilver: that duplicates subcomputations
22:47:12 <sjanssen> quicksilver: () -> doesn't exhibit the same complexity
22:47:20 <quicksilver> ah
22:47:22 <skew> quicksilver: or you use mutation, it's talking about a pure eager language
22:47:35 <quicksilver> I see I'm confusing lazy and non-strict again
22:47:36 <quicksilver> bad quicksilver
22:47:58 <skew> quicksilver: the paper lists some other language features that might work as well, like certain kinds of circular data (only infinite circular data?)
22:52:01 <wy> 1/3 of the ghc code is in C
22:52:36 <quicksilver> 1/3? really?
22:52:37 <quicksilver> gosh
22:52:43 <quicksilver> I wouldn't have guessed so much.
22:52:58 <skew> it would be smaller, but it's written in C
22:52:58 <wy> I just wc'ed the *.c and *.hs files
22:53:26 <skew> what about .lhs files?
22:53:50 <wy> ... sorry. There is a lot
22:55:01 <wy> As much as the *.hs. So *.c is 1/4 now :-)
22:55:43 <dons> there's 100k lines of haskell, and 30 k C or so.
22:56:06 <dons> its most of an OS, the kernel, after all.
22:56:09 <dons> it runs on bare metal...
22:56:49 <OceanSpray> bare silicon.
22:56:51 <wy> Any ideas how to browser so much code?
22:57:11 <dons> i've not used hasktags on ghc itself
22:57:15 <dons> but its damn useful on the libraries
22:57:32 <dons> so could be good on the ghc src too
22:57:43 <dons> the rts src i just read module by module :)
22:59:50 <wy> does rts mean "run time system"
23:03:29 <olsner> ghc is only 130k lines? wow
23:10:49 <chadz_> still needs more linez to compete
23:11:13 <olsner> (although 100kloc of haskell probably counts as at least 10 lines of C)
23:24:19 <psi> olsner: i hope you mean 1 line of haskell
23:45:29 <bench`> the only thing from google is haifa, which hasn't been updated for a year
