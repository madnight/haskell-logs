00:00:05 <Kirakishou> damn.
00:00:05 <sjanssen> but there is 'local'
00:00:11 <Kirakishou> what's that do?
00:00:15 <sjanssen> @type local
00:00:16 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
00:00:36 <sjanssen> it executes a subcomputation with a different environment
00:00:46 <Kirakishou> that's all I need.
00:01:34 <sjanssen> it's particularly useful for handling lexical scope in an interpreter, and other things of that nature
00:01:49 <Kirakishou> that's exactly what I need.
00:03:55 <hpaste>  Paczesiowa annotated "polyvariadic sum" with "(no title)" at http://hpaste.org/4392#a1
00:04:29 <paczesiowa> sjanssen: could you look at that? how can I add smth to context, when it's already there?
00:06:10 <sjanssen> paczesiowa: I think you already know the answer :)
00:06:20 <sjanssen> "with fundep it compiles" :)
00:06:44 <sjanssen> this is an okay use of undecidable instances, I think
00:08:05 <paczesiowa> and why is that undecidable? if snd argument of Foo is String then we choose first instance rule, if it's smth more complicated we choose second rule, if I understand it right
00:09:30 <sjanssen> GHC has some conservative rules for decidability, since it can't determine decidability in the general case (halting problem)
00:09:41 <sjanssen> your instances run afoul of one of those rules
00:12:12 <paczesiowa> but without fundep, there is problem with context in sum2 which sounds easy (smth undecidable scares me much more than some context problem)
00:23:39 <Kirakishou> now let me get this straight
00:23:52 <Kirakishou> you pass two functions into 'local',
00:24:18 <Kirakishou> first one will evaluate to the environment you want the second function to use?
00:24:33 <Kirakishou> is that what (r -> r) means?
00:24:58 <Kirakishou> If so, why not just local :: r -> m a -> m a ?
00:25:00 <sjanssen> @type local
00:25:02 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
00:25:24 <sjanssen> Kirakishou: you can always write local (const myenv) foo
00:25:33 <Kirakishou> :t const
00:25:34 <lambdabot> forall a b. a -> b -> a
00:25:41 <Kirakishou> oh
00:25:56 <Kirakishou> I've been using (\_ -> env), but ok
00:44:14 * glguy gets his monad transformers in a "scheme-like" language running
01:07:40 <Taejo> @index seq
01:07:40 <lambdabot> Prelude, Control.Parallel
01:09:41 <Taejo> if I use seq in one function to make sure the list it generates is evaluated
01:10:19 <Taejo> should I expect runtime to increase in that function and decrease in the function that uses the list?
01:23:37 <joelr1> good morning
01:23:40 <joelr1> @seen bringert
01:23:41 <lambdabot> I saw bringert leaving #haskell 21h 17m 53s ago, and .
01:34:15 <roconnor> I don't suppose there is an open office presenation template for haskell.
01:34:20 <roconnor> ?
01:46:54 <qweqwe> if i want that first show enter will be done and after that recoursive call has to be done how i write it ? bfsq [] b = show('\n') bfsq(b,[])
01:49:22 <quicksilver> qweqwe: show just produces a string, I'm sure that's not what you mean
01:49:47 <quicksilver> qweqwe: perhaps you mean bfsq [] b = do putStrLn "" ; bfsq [] b
01:50:24 <doserj> which wouldn't be a very useful function...
01:50:33 <qweqwe> why ?
01:50:37 <qweqwe> not
01:51:49 <doserj> well, it would just go on printing newlines forever.
01:52:10 <doserj> so maybe describe more precisely what you want your function to do
02:00:35 <quicksilver> yes, I imagine you don't want the recursive call to be *exactly* the same
02:00:52 <quicksilver> but I assumed it was just an example
02:01:45 <qweqwe> you  are right
02:01:55 <qweqwe> sec i have there some erro
02:02:26 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/4393
02:02:40 <qweqwe> can you help me with it  plz
02:03:08 <quicksilver> qweqwe: you can't write two "do" expressions just next to each other like that
02:03:13 <mauke> the first line is broken
02:03:32 <quicksilver> qweqwe: you either make one big do expression or you use >> to join them
02:04:16 <qweqwe> i only need that it is the bfsq [] b = do putStrLn "\n"; bfsq(b,[]) line
02:04:21 <doserj> qweqwe: should this be a function declaration?
02:04:42 <therp> qweqwe: reddit?
02:04:45 <qweqwe> it"sonly my show function
02:05:46 <qweqwe> how i can make in one line print to screen the enter and the recoursion call be made
02:05:58 <doserj> on a quick count, I see at least five different problems here
02:06:10 <EvilTerran> doserj, yeah, i agree. about that.
02:06:22 <EvilTerran> printit RedBlackTree value key  -- something's missing
02:06:23 <mauke> 6!
02:06:34 <mauke> ok, 7
02:06:47 <EvilTerran> bfsq [] b = do putStrLn "\n"; bfsq(b,[])  -- it's defined to take multiple parameters, not a single tuple.
02:07:00 <mauke> EvilTerran: ah, but its type says it takes one
02:07:11 <EvilTerran> even better!
02:07:29 <EvilTerran> there's that missing newline that's confused quicksilver
02:08:04 <qweqwe> so how i can solve that ?
02:08:15 <doserj> oh, i didn't even scroll to the right...
02:08:20 <mauke> qweqwe: start on line 1
02:08:25 <mauke> what's that supposed to do?
02:08:41 <qweqwe> only take a tree and print it
02:08:49 <EvilTerran> bfsq [] []  -- what?
02:08:54 <mauke> qweqwe: line 1? are you sure?
02:08:55 <qweqwe> level by level
02:09:18 <doserj> EvilTerran: that might be bfsq [] = []
02:09:38 <EvilTerran> or bfsq [] [] = return ()
02:09:53 <doserj> one can only gues
02:09:58 <EvilTerran> or any of a number of other things
02:10:13 <qweqwe> so tell me plz what to change
02:10:13 <EvilTerran> i don't think #haskell's jitter correction can cope with this ;)
02:10:33 <qweqwe> and i will do it
02:10:35 <doserj> qweqwe: reread your haskell tutorial
02:10:43 <mauke> qweqwe: how about you start answering my questions instead of making us write your code
02:10:46 <qweqwe> i am really new to it
02:11:02 <qweqwe> what is your question?
02:11:05 <EvilTerran> also, "plz" is not an english word
02:11:11 <qweqwe> :)
02:11:13 <mauke> I hate it when people simply restate their problem instead of answering questions/reacting to what people say in the channel
02:11:59 <qweqwe> i am writing a function that gets  a tree and prints it
02:12:16 * therp is allergic to anything that starts with qwe* due to reddit
02:12:23 <mauke> yes, that
02:12:37 * EvilTerran notes a certain irony in those two lines
02:13:01 <vininim> @src seq
02:13:01 <lambdabot> Source not found. Just what do you think you're doing Dave?
02:13:58 * EvilTerran finishes reformatting that code to be syntactically correct, and concludes that, even then, it makes no f4ing sense.
02:15:15 <EvilTerran> qweqwe, mauke shouldn't need to tell you what his question is. scroll up.
02:16:58 <mauke> (don't bother, I have qweqwe on /ignore)
02:17:11 <vininim> is there a way in ghci to load all modules? =p
02:18:36 <EvilTerran> that's a lot of modules, it'd be very slow. are you sure that's what you want?
02:18:54 <doserj> and you would have nameclashes
02:19:05 <vininim> or something like Control.Monad.*
02:19:27 <EvilTerran> there isn't really anything like that
02:19:43 <EvilTerran> you could create a new module that just re-exported a load of existing modules, and load that
02:20:23 <EvilTerran> module Control.Monad.Everything (module Control.Monad, module Control.Monad.Cont, ...) where import Control.Monad; import Control.Monad.Cont; ...
02:28:43 <qweqwe> casn you help mewith the error i get on line 12 http://hpaste.org/4396?lines=true
02:29:52 <quicksilver> qweqwe: there error is really in line 11
02:30:05 <quicksilver> qweqwe: line 11 is missing its definition
02:30:28 <quicksilver> qweqwe: (and the indentation is slightly wrgon, it should line up with the other bfsqs)
02:31:02 <scook0> while you're at it, you might as well fix lines 13-14
02:31:13 <qweqwe> ok will chack it now
02:31:16 <qweqwe> check
02:31:20 <qweqwe> sec
02:31:23 <scook0> something weird seems to have occurred there
02:31:24 <hkBst> qweqwe: your indentation of bfsq doesn't line up
02:34:42 <doserj> and this one recursive call is still wrongly typed
02:34:55 <doserj> (but it looks much better alread :)
02:40:57 <qweqwe> line 11 now http://hpaste.org/4398?lines=true
02:41:08 <qweqwe> what is wrong is there wit the =
02:41:11 <qweqwe> with
02:42:06 <doserj> qweqwe: wrong indentation
02:42:14 <qweqwe> ok i think it should be (bfsq b [])
02:42:29 <doserj> that's another error, yes :)
02:43:12 <qweqwe> but what you mean by wrong indentatin on that line ?
02:43:33 <doserj> all your cases for the definition of bfsq should start on the same line
02:43:37 <roconnor> hmm, seems we can no longer unthread reddit comments
02:43:38 <doserj> *columns
02:44:09 <doserj> qweqwe: are you using tab's in your code?
02:44:48 <qweqwe> sec i will check it
02:47:19 <qweqwe> yes there where several tabs
02:47:49 <doserj> use spaces instead :)
02:49:27 <dozer> can someone walk me through installing the ghc 6.8.2 binary bundle under ubuntu?
02:49:48 <doserj> qweqwe: or set your editor to display tabs as 8 spaces width
02:49:55 <dozer> Ideally, I'd like to get it installed without hosing whatever apt has done for 6.6.*
02:50:31 <Plareplane> dozer, install it in your homedir?
02:52:10 <Zao> dozer: If I'm not all wrong, the deb is installed in /usr, while ghc defaults to /usr/local.
02:52:17 <qweqwe> i gat now anther error http://hpaste.org/4399
02:52:37 <Zao> So there should be no problem installing it into /usr/local, and since /usr/local comes before /usr in $PATH, the new one will be used.
02:53:34 <doserj> qweqwe: "showTree Node c a k v p" gets parsed as "(showTree Node) c a k v p".
02:53:48 <Zao> $ or parens is your friend.
02:54:06 <doserj> qweqwe: so write "showTree (Node c a k v p)", or "showTree $ Node c a k v p"
02:54:10 <SamB_XP> dozer: so long as you invoke GHC by version you should be okay...
02:54:34 * doserj really misses a FAQ on www.haskell.org
02:58:15 <EvilTerran> "what's the monomorphism restriction?"
02:58:43 <EvilTerran> "how do I get the a out of an IO a?"
02:59:01 <SamB_XP> the evil decision that started Haskell 98 down the slippery slope of feature loss
02:59:03 <EvilTerran> "can I ask a question?"
02:59:05 <SamB_XP> you can't
02:59:14 <SamB_XP> don't ask to ask
02:59:22 <smtms> yes, only one
02:59:28 <SamB_XP> (but do come to #haskell or haskell-cafe@)
02:59:44 <smtms> you hit your limit already by asking whether you may ask :-)
02:59:48 <doserj> EvilTerran: "why doesn't avg xs = sum xs / length xs work?"
02:59:54 <qweqwe> ok it worked noew
02:59:56 <qweqwe> ok it worked now
03:00:02 <qweqwe> thanks for help
03:00:14 <EvilTerran> doserj, indeed.
03:00:32 <SamB_XP> it doesn't work?
03:00:49 <EvilTerran> length returns an Int, (/) needs a RealFrac
03:00:59 <SamB_XP> oh, right.
03:01:00 * dozer starts to wrestle with update-alternatives
03:01:08 <SamB_XP> that's a pain :-(
03:01:26 <Zao> dozer: Just installing into /usr/local works like a charm for me, and doesn't affect the ghc6 package.
03:01:54 <EvilTerran> sorry, (/) needs a Fractional
03:02:22 <EvilTerran> > (1 :+ 2) / (2 :+ 1)
03:02:23 <lambdabot>  0.8 :+ 0.6
03:06:52 <hpaste>  glguy pasted "Monad transformers in a scheme-like language" at http://hpaste.org/4400
03:07:16 <roconnor> what language is this: http://programming.reddit.com/info/24p2c/comments/c24p4y
03:07:52 <glguy> ruby
03:08:43 <filcab42> hi
03:09:10 <roconnor> glguy: thanks
03:09:14 <Zao> filcab42: Hello there.
03:09:18 <roconnor> glguy: the formating is mangled :(
03:09:48 <EvilTerran> filcab42, do you pass the turing test?
03:10:01 <filcab42> not yet, hang on :P
03:10:03 <roconnor> what are the odds I could get the folks on #ruby to unmangle it for me?
03:10:24 <ndm> malcolmw: runhaskell Setup configure ???? - what is ??? to install a package in /grp/haskell
03:10:41 <doserj> --prefix=...
03:10:58 <EvilTerran> ah okay. there's been a bit of a wave of bots of the name structure [a-z]+\d\d, is all.
03:11:03 <ndm> thanks doserj, am not sure where we are putting the packages though...
03:11:04 <filcab42> I'm trying to write a simple action
03:11:22 <filcab42> like the cross-product one, one lists, but that prints each pair of numbers
03:11:38 <hpaste>  filcab pasted "cross-product action" at http://hpaste.org/4401
03:11:51 <filcab42> but I must have misunderstood something about lift :s
03:11:56 <filcab42> could anyone help me?
03:12:10 <malcolmw> ndm: --prefix=/grp/haskell ?? at a guess
03:12:39 <EvilTerran> do{ many1 letter; digit; digit }, even ;P
03:13:05 <ndm> someone has reported a spaceleak with GHC 6.6.1 on Linux, and I can't replicate it on 6.8.1 on Windows, so am trying to replicate...
03:13:45 <roconnor> @type lift
03:13:46 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
03:13:51 <EvilTerran> filcab42, what monads and transformers are involved here?
03:13:57 <filcab42> list and IO
03:14:21 <filcab42> the original cross action would receive two lists and return the list with the cross product
03:14:38 <EvilTerran> @unmtl ListT IO a
03:14:38 <lambdabot> IO [a]
03:14:59 <Saizan> ListT IO is not a monad
03:15:40 <dozer> ah, now that I've got the new ghc, I have to rebuild every library under the sun :(
03:15:51 <EvilTerran> Saizan, is that the problem here?
03:15:58 <filcab42> no?
03:15:59 <SamB_XP> dozer: 'tis the usual way of things
03:16:01 <filcab42> hmm
03:16:16 <SamB_XP> dozer: I hope someone comes up with a neat way to avoid that being so much work...
03:16:18 <EvilTerran> filcab42, iirc, the standard ListT is a bit broken
03:16:25 <filcab42> oh :s
03:16:25 <Saizan> EvilTerran: it was more additional info :)
03:16:46 <SamB_XP> but I expect it will always be a bit of work for first- or second-number changes...
03:16:48 <Saizan> however, cross product in a list-like monad is liftM2 (,)
03:18:07 <dozer> EvilTerran: maven does a reasonable job of this sort of thing for Java
03:18:08 <EvilTerran> ?type lift (print (?x,?y))
03:18:10 <lambdabot> forall (t :: (* -> *) -> * -> *). (?x::Integer, ?y::Integer, MonadTrans t) => t IO ()
03:18:13 <EvilTerran> what?
03:18:21 <doserj> dozer: there is cabal-install
03:18:33 <dozer> doserj: oh?
03:18:36 <filcab42> @type liftM2
03:18:37 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
03:18:52 <filcab42> but it has to be the same monad in all of them doesn't it?
03:18:54 <SamB_XP> doserj: how does one install it?
03:18:55 <doserj> doserj: it even works if the packages on hackage are updated...
03:18:57 <EvilTerran> @src liftM2
03:18:57 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
03:19:07 <SamB_XP> doserj: you are talking to yourself now?
03:19:07 <filcab42> oh
03:19:08 <filcab42> :s
03:19:22 <doserj> :)
03:19:30 <Saizan> filcab42: can you describe the type of the function you're trying to write
03:19:32 <Saizan> ?
03:19:42 <Saizan> btw: http://www.haskell.org/haskellwiki/ListT_done_right
03:19:43 <lambdabot> Title: ListT done right - HaskellWiki
03:19:59 <filcab42> thanks
03:20:31 <filcab42> m a -> m b -> m IO (a,b) or something
03:20:48 <filcab42> if I could get rid of the IO it would be nice but I don't think I can
03:20:56 <glguy> If you want a packaged monad transformer library where you don't have to copy listt done right, use monadlib
03:21:01 <EvilTerran> ?hoogle trace
03:21:17 <lambdabot> thread killed
03:21:21 <EvilTerran> ?hoogle trace
03:21:21 <lambdabot> Debug.Trace.trace :: String -> a -> a
03:21:22 <lambdabot> Debug.Trace :: module
03:21:22 <lambdabot> Debug.Trace.traceShow :: Show a => a -> b -> b
03:21:35 <Saizan> filcab42: why not? since you don't have it in the arguments you don't need it in the result, assuming you don't want to do I/O while computing the product
03:21:47 <EvilTerran> that's the second time she's killed my thread for no good reason in half an hour
03:21:53 <filcab42> I wanted to print the product while calculating it
03:21:54 <EvilTerran> @vixen are you feeling alright?
03:21:58 <filcab42> http://hpaste.org/4401
03:22:00 <lambdabot> do i not seem alright? i'm fine!
03:22:02 <filcab42> something like this
03:22:06 <SamB_XP> EvilTerran: well, at least it's not a forum thread
03:22:55 <Saizan> filcab42: that's not the haskell way at all
03:23:11 <SamB_XP> filcab42: print while calculating?
03:23:22 <filcab42> to debug and stuff
03:23:27 * SamB_XP thinks of scan*
03:23:33 <filcab42> right now I'm trying to learn about the Monad Trans
03:23:34 <SamB_XP> @type scanr
03:23:35 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> [b]
03:23:39 <SamB_XP> @type scanl
03:23:39 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
03:23:46 <mux> > scanl (*) 1 [1..10]
03:23:47 <EvilTerran> filcab42, to debug and stuff, you can use trace
03:23:47 <lambdabot>  [1,1,2,6,24,120,720,5040,40320,362880,3628800]
03:24:04 <SamB_XP> or you could use scanl
03:24:21 <filcab42> hanks
03:25:08 <SamB_XP> the Haskell way is to calculate stuff seperately from doing IO
03:25:43 <SamB_XP> and let laziness make it happen at the same time
03:25:50 <Saizan> filcab42: cross2 didn't work because you've to tranform you [a] in ListT IO a, which you can do with (msum . map return)
03:26:29 <Saizan> ?type msum . map return
03:26:30 <lambdabot> forall a (m :: * -> *). (MonadPlus m) => [a] -> m a
03:26:31 * SamB_XP wonders if he got the wrong kind of product
03:28:20 <SamB_XP> what is the point of http://www.haskell.org/haskellwiki/ListT_done_right_alternative
03:28:21 <lambdabot> Title: ListT done right alternative - HaskellWiki
03:29:48 <SamB_XP> shouldn't there be something about the difference between it and ListT_done_right?
03:29:53 <dozer> hehe, I'm having trouble installing cabal-install because it needs some dependencies :)
03:30:10 <SamB_XP> dozer: why do you suppose I was asking how you install cabal-install
03:30:13 <SamB_XP> ?
03:30:27 <doserj> SamB_XP: there is a note at the end of the ListT done right page
03:30:31 <Saizan> SamB_XP: well, the datatype
03:31:09 <SamB_XP> doserj: oh, huh.
03:31:34 <doserj> dozer: yes :) ideally, it would be self-contained :(
03:32:29 <dozer> ok, so how do I get zlib that it needs? (me is wearing the noob hat today)
03:32:31 <doserj> dozer: especially the dependency on Cabal is a bit hairy. the one shipped with ghc-6.8.1 does *not* work, for example :(
03:33:04 <SamB_XP> ideally ListT_done_right_alternative would have that description on it, and both pages would have proof of monadness...
03:34:38 <Saizan> dozer directly from hackage
03:34:42 <Saizan> ?hackage zlib
03:34:43 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/zlib
03:35:45 <Saizan> untar the package and runhaskell Setup configure, runhaskell Setup build, runhaskell Setup install (the last command probably needs root privileges)
03:36:01 <Saizan> or you can pass --user to configure and install only for your user
03:37:54 <SamB_XP> what version of cabal does cabal-install depend on?
03:38:18 <dozer> thx Saizan - trying it now
03:38:59 <doserj> SamB_XP: I think 1.2.1 is ok
03:39:41 <dozer> nmrp3@fluxion:~/devel/ghc/zlib-0.4.0.1$ ./Setup.hs configureimport: unable to open module file `/usr/lib/ImageMagick-6.2.4/modules-Q16/coders/simple.la': No such file or directory../Setup.hs: line 2: main: command not foundnmrp3@fluxion:~/devel/ghc/zlib-0.4.0.1$ cat Setup.hsimport Distribution.Simplemain = defaultMain
03:39:50 <dozer> wtf???
03:40:11 <doserj> "runhaskell ./Setup.hs configure"
03:40:24 <SamB_XP> dozer: what happened to the newlines?
03:40:53 <dozer> ok, so it was a following-instructions error on my part
03:45:38 <hpaste>  dozer pasted "System.Process" at http://hpaste.org/4402
03:46:32 <dozer> is this the sort of thing that's fixed by an extra import, or has the API shifted under me?
03:46:40 <quicksilver> dozer: that's not an import issue
03:46:40 <doserj> you will find this frequently when installing packages for ghc-6.8 :) just try to add the package to the build-depends in the .cabal file
03:46:47 <quicksilver> dozer: it's a dependency issue
03:46:58 <quicksilver> dozer: you need to decalre a package dependency on process
03:49:05 <dozer> ah, thx - and cabal even told me what to add to the dependencies for that and the other 5 packages
03:49:33 <quicksilver> ;)
03:49:35 <doserj> yep, but you may have to iterate this :)
03:49:52 <quicksilver> dozer: it's because tehre was a massigve package split-up
03:49:58 <quicksilver> hopefully this is a one-off
03:50:05 <quicksilver> rather than something which happens with every new version :)
03:51:43 <doserj> "containers" is another frequent candidate
03:53:43 <dcoutts> quicksilver: it'll happen again with ghc-6.10
03:54:12 <dcoutts> though we might have a better way of managing the transition next time
03:54:13 <doserj> dcoutts: not if someone finds a good working backwards compatibility solution
03:54:45 <doserj> (manually adjusting it in each and every package obviously isn't a solution)
03:55:16 <dcoutts> though unlimited backwards compatibility is also not a long term solution
03:55:45 <doserj> of course.
03:56:20 <doserj> supported -> deprecated -> unsupported, something like this
03:56:25 <dcoutts> aye
03:56:57 <dozer> the compiler seems vastly faster
03:57:18 <dcoutts> dozer: that's because it's using -fasm by default rather than calling gcc
03:57:24 <dozer> ok
03:57:27 <dcoutts> @seen bringert
03:57:27 <lambdabot> I saw bringert leaving #haskell 23h 51m 40s ago, and .
03:57:54 <dcoutts> Lemmih, xerox: ping. I've got a question about some existing cabal-install code
03:57:57 <dozer> but validating some fairly hairy class declarations used to take up to 5 min just completed in about 20 sec
03:58:49 <dcoutts> dozer: did it always take that long without optimisation?
04:00:53 <dozer> dcoutts_: yeah
04:04:10 <quicksilver> dozer: there were a few frontend bugs which might certain structures n^2 or worse.
04:04:14 <quicksilver> dozer: which they fixed.
04:04:20 <quicksilver> dozer: mabe yours tickled one of those :)
04:04:24 <dozer> cool
04:08:43 <roconnor> @go what is a monad
04:08:43 <lambdabot> http://en.wikipedia.org/wiki/Monad
04:08:43 <lambdabot> Title: Monad - Wikipedia, the free encyclopedia
04:08:50 <roconnor> @go what is the matrix
04:08:51 <lambdabot> http://whatisthematrix.warnerbros.com/
04:08:51 <lambdabot> Title: THE MATRIX TRILOGY
04:16:46 <Lemmih> dcoutts: Go ahead.
04:20:36 <dcoutts_> Lemmih: ok, so we have global options that apply to all the packages we want to install
04:20:53 <dcoutts_> Lemmih: and then we have local options that apply to each package
04:21:19 <dcoutts_> things like flags controling configurations, eg use_xft or whatever in xmonad-contrib
04:21:40 <dcoutts_> Lemmih: so currently these are just unstructured [String]
04:21:55 <dcoutts_> Lemmih: and I'm trying to convert them to be proper flags structures
04:22:00 <roconnor> @bab en de Warning
04:22:00 <lambdabot>   Warnung
04:22:05 <roconnor> @bab en de Danger
04:22:06 <lambdabot>   Gefahr
04:22:18 <roconnor> what's that german Achooo word?
04:22:21 <EvilTerran> achtung?
04:22:24 <roconnor> right
04:22:32 <dcoutts_> Lemmih: so my question is, what local per-package flags do we allow, since some doesn't really make sense to differ from the global ones.
04:22:49 <dcoutts_> Lemmih: obviously we allow configurations flags, but any others?
04:23:31 <Lemmih> dcoutts_: I think it has changed since I worked on cabal-install.
04:23:34 <mauke> @bab de en achtung
04:23:35 <lambdabot>   attention
04:24:06 <roconnor> ah
04:24:09 <dcoutts_> Lemmih: ok, what'd be your opinion for what flags we should allow.
04:24:41 <dcoutts_> Lemmih: (which is a slightly different question than what flags did the person who wrote that code intend to allow)
04:25:14 <dcoutts_> as far as I can see it doesn't make much sense to allow any local flags except configurations ones
04:25:35 <dcoutts_> eg installing several packages in one go and letting some be --user and some --global is just a bit silly
04:25:58 <Lemmih> Can't we just let the user decide?
04:26:15 <dcoutts_> Lemmih: no, because it would break installation
04:26:21 <roconnor> @type getChar
04:26:23 <lambdabot> IO Char
04:26:50 <dcoutts_> Lemmih: eg if someone asked for some --global and some --user, we would either have to take it into account or it'd break dependency resolution
04:27:32 <dcoutts_> Lemmih: it's also makes the cabal-install command line rather complex since depending on where you put the flag it'll apply to different things
04:27:59 <dcoutts_> cabal install --global foo bar vs cabal install foo bar --global
04:28:02 <Lemmih> Filter out --user and --global flags?
04:28:25 <Igloo> Allowing user and global to be per-package does make sense, but it's probably not worth the effort of implementing
04:28:30 <dcoutts_> Lemmih: it's easy for me to select the ones we need, I'm just not sure which ones we should allow
04:28:40 <dcoutts_> Igloo: especially when the user can just invoke it twice
04:28:45 <Igloo> Right
04:29:18 <dcoutts_> making the cabal command line a bit less order sensitive is a good thing imho
04:30:03 <dcoutts_> so I propose that "cabal install --global foo bar" is the one true way and "cabal install foo bar --global" be an error
04:30:22 <dcoutts_> and the only local per-package flags we should allow should be configurations flags
04:30:55 <dcoutts_> (though other package systems make people specify those globally too)
04:35:16 <Igloo> dcoutts_: The reason for disallowing "cabal install foo bar --global" is that for other flags that would mean --global only applies to things following it?
04:35:40 <dcoutts_> Igloo: it'd only apply to the package preceding it
04:35:55 <Igloo> Oh, I see
04:36:06 <dcoutts_> cabal install xmonad xmonad-contrib --flags=use_xft
04:36:15 <dcoutts_> means use that flag only for xmonad-contrib
04:36:20 <dcoutts_> cabal install --flags=use_xft xmonad xmonad-contrib
04:36:31 <dcoutts_> means use it for all packages, xmonad and xmonad-contrib
04:36:37 <dcoutts_> Igloo: is that not confusing?
04:36:58 <dcoutts_> I wouldn't mind at all dropping per-package flags
04:37:41 <dcoutts_> since 1. flags don't overlap much, 2. when they do hopefully they mean the same thing, 3. if not one can still install in multiple steps
04:37:42 <Igloo> Yeah, or maybe --flags=xmonad-contrib:use_xft if you really want to be able to say that
04:37:57 <dcoutts_> Igloo: right, that would be better I think
04:38:02 <Igloo> What happens if you set a flag that a package doesn't use? Is it ignored?
04:38:07 <dcoutts_> yes
04:38:21 <dcoutts_> (I think so)
04:38:31 <roconnor> stripPrefix!
04:38:33 * Igloo isn't sure that's a good idea, but failing would break the multiple-install
04:39:05 <dcoutts_> Igloo: it'd be ok if cabal-install just looked at the union of all flag names in the packages it proposes to install
04:39:33 <dcoutts_> Igloo: so I think we can either have it ignored or give an error up front
04:39:58 <Igloo> Oh, yes, cabal install looks at the cabal files, so it can only pass in the flags that are used, and normal Cabal can give an error if it doesn't recognise a flag
04:40:08 <dcoutts_> right
04:40:38 <dcoutts_> that's what it could and should do, I don't know what it really does atm, I think normal Setup.hs ignores unknown flags too
04:41:36 <quicksilver> dcoutts_, Igloo : fwiw I think flags doing different things depending where they appear on the line is a bit uncommon and possibly confusing :)
04:41:43 <quicksilver> i.e. I agree, I think :)
04:41:55 <dcoutts_> ok, great, I'll eliminate per-package flags
04:42:18 <dcoutts_> but leave open the possibility to say --flags=xmonad-contrib:use_xft
04:42:22 <dcoutts_> or something similar
04:46:23 <doserj> dcoutts_: if at all, per-package flags should apply to everything *after* the flag, not to the package before it
04:46:41 <doserj> (this would be consistent with global flags)
04:46:45 <dcoutts_> true
04:50:56 <roconnor> @type find
04:50:58 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
04:51:20 <roconnor> @type stripPrefix
04:51:20 <lambdabot> Not in scope: `stripPrefix'
04:51:29 <roconnor> @type Data.List.stripPrefix
04:51:30 <lambdabot> Not in scope: `Data.List.stripPrefix'
04:51:42 <roconnor> @hoogle stripPrefix
04:51:42 <lambdabot> Data.List.stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]
04:55:14 <roconnor> @src Maybe
04:55:14 <lambdabot> data Maybe a = Nothing | Just a
04:55:41 <gbacon> @src stripPrefix
04:55:42 <lambdabot> Source not found. Are you on drugs?
04:55:49 <gbacon> @src Data.List.stripPrefix
04:55:49 <lambdabot> Source not found. I feel much better now.
05:11:38 <matthew_-> right, can someone explain the differences between monads from category theory and linear logic?
05:13:35 <matthew_-> anyone at all. don't be shy now...
05:13:39 <quicksilver> does linear logic use monads?
05:13:46 <nihonjindes> Hello
05:13:51 <nihonjindes> Can anyone help me with this?
05:13:52 <nihonjindes> http://aycu28.webshots.com/image/35707/2000348046390172087_rs.jpg
05:14:18 <quicksilver> nihonjindes: what would a jpg have to do with haskell?
05:14:44 <osfameron> a jpeg containing maths homework
05:14:45 <nihonjindes> It says Math
05:14:59 <nihonjindes> yeah... '-_-
05:15:00 <quicksilver> right.
05:15:03 <Zao> Did you perchance just grep the channel list for "math"?
05:15:04 <nihonjindes> review T_T
05:15:09 <quicksilver> but this isn't #do-other-peoples-maths-homework
05:15:16 <quicksilver> I'm not sure such a channel exists, in fact :P
05:15:22 <ricky_clarkson> /topic
05:15:23 <matthew_-> quicksilver: well, linear logic seems to have very similar applications in terms of hiding state-plumbing as monads
05:15:24 <ricky_clarkson> oops
05:15:34 <nihonjindes> lol, sorry I guess
05:15:41 <ricky_clarkson> "math + romance + language == haskell" in /topic ;)
05:15:44 <nihonjindes> I have 1 hour till my final starts
05:15:57 <nihonjindes> lol
05:16:00 <matthew_-> nihonjindes: may I suggest beer ?
05:16:03 <osfameron> in which case either you know the stuff, or you're fucked
05:16:07 <osfameron> cramming--
05:16:09 <ricky_clarkson> Play the piano.
05:16:27 <nihonjindes> Cramming is the best way to get an A
05:16:29 <matthew_-> go base jumping?
05:16:39 <osfameron> no.  it's not
05:16:45 <matthew_-> only because exams these days don't test the ability of students to think
05:16:47 <osfameron> the best way to get an A is to have studied and know the material.
05:16:58 <matthew_-> cramming works because the question setters are lazy
05:17:07 <osfameron> ah, well, maybe for some topics
05:17:10 <quicksilver> matthew_-: linear logic turns out not to be quite the same thing as 'linearly used parameters'.
05:17:12 <ricky_clarkson> matthew_-: Which is bloody crap.
05:17:13 <osfameron> does it work for something creative like maths?
05:17:35 <quicksilver> matthew_-: but off hand, I'm not sure the two approachs are related at all.
05:17:44 <matthew_-> ahh. ok.
05:17:45 <nihonjindes> So any math pros here?
05:17:56 <Zao> nihonjindes: None that do homework.
05:18:04 <matthew_-> hence the Pro bit eh?
05:18:06 <quicksilver> matthew_-: linearly used parameters can force you to use things only once, but that's all. Monads can encapsulation a fairly wide variety of computational notions.
05:18:10 <quicksilver> ;)
05:18:13 <ricky_clarkson> nihonjindes: Why don't you consult your teacher 3 days in the past?
05:18:18 <quicksilver> If I was pro, I'd have to charge you for it, of course
05:18:24 <quicksilver> otherwise I'd be amateur by definitino
05:18:28 <matthew_-> quicksilver: yeah, that's kinda where I was going
05:18:34 <Zao> The answer to 3) is pi, by the way.
05:18:41 <quicksilver> matthew_-: e.g. I don't see an easy way to get exceptions out of linearity
05:18:52 <quicksilver> matthew_-: or non-determinism
05:18:53 <nihonjindes> It's not a homework, it's a review
05:19:01 <nihonjindes> My prof kinda sent it late
05:20:07 <nihonjindes> The answer for 3 is not pi.  #3 is easy
05:21:42 <nihonjindes> so... no math pros?
05:22:32 <mux> yeah, #3 is very easy
05:23:02 <nihonjindes> But other than #3, I am almost completely lost
05:23:04 <nihonjindes> =(
05:24:48 <Igloo> nihonjindes: This channel is not for maths homework help
05:25:14 <matthew_-> certainly not if you want the right answers ;)
05:25:25 <nihonjindes> lol
05:25:27 <nihonjindes> really?
05:25:36 <matthew_-> #2 is Î»x.xx
05:25:45 <nihonjindes> So what do we have here?  A bunch of liberal arts?
05:25:58 <matthew_-> I think a kick may be needed... :p
05:26:09 --- mode: ChanServ set +o Igloo
05:26:12 <mux> I'd hate to see a kick in #haskell
05:26:18 <mauke> use /remove
05:26:24 <mauke> it's more gentle
05:26:47 <matthew_-> /gentle-push-through-the-window
05:26:54 <nihonjindes> how about, "destroying the boon of life, with pure hatred.  Thou..."
05:26:54 --- kick: nihonjindes was kicked by Igloo (Igloo)
05:27:05 --- mode: Igloo set +b *!*@adsl-67-67-196-168.dsl.austtx.swbell.net
05:27:07 --- kick: nihonjindes was kicked by Igloo (Igloo)
05:27:14 <mux> the impossible happened :-
05:27:25 <mauke> /remove also doesn't trigger autorejoin
05:27:32 <ikegami--> nihonjindes means "I am a Japanese" in Japanese
05:27:57 <ikegami--> because i'm a japanese, i don't like his nickname :(
05:28:08 <ikegami--> indeed, Haskell becomes popular in Japan!
05:28:15 <qweqwe> what is the problem here ?http://hpaste.org/4406
05:28:23 <osfameron> or at least maths homework has become popular in Japan
05:28:54 <mauke> does "zero level curve of g" mean y=0?
05:29:15 <mux> this "curve" talk confuses me as well, it doesn't seem hard but I'm not sure what it means
05:29:38 <quicksilver> qweqwe: well, findvalue returns (value,key)
05:29:49 <qweqwe> yes
05:29:56 <nopoints> does anybody any FFT library in haskell? (one that compiles with ghc 6.6 at least)
05:30:01 <quicksilver> qweqwe: but then in the recursie call you try to nfeed that into a Node constructor
05:30:11 <quicksilver> qweqwe: Node c (findvalue key a) v k b
05:30:33 <quicksilver> qweqwe: and the Node constructor doesn't expect a '(value,key)' there
05:30:40 <quicksilver> qweqwe: that's what the error is tell you
05:35:53 <araujo> liberal arts are cool
05:35:57 <araujo> :-)
05:49:58 <dblhelix> http://www.cs.uu.nl/intern/pando/infpaginas/algemeen.htm#travelabroad
05:50:01 <lambdabot> http://tinyurl.com/2zdy65
05:50:13 <dblhelix> oops.. sorry... not intended for pasting
05:57:52 <vininim> > getStdGen >>= return.(randomRs (1,10))
05:57:54 <lambdabot>  <IO [Integer]>
05:57:57 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/4407
05:58:22 <rdmltrs> can you ever leave an IO type once you return something that is of that type?
05:58:49 <mauke> rdmltrs: only locally
05:59:06 <gbacon> > do { a <- return 3; print a }
05:59:07 <lambdabot>  <IO ()>
05:59:22 <rdmltrs> what do you mean locally?
05:59:35 <quicksilver> within an expression
05:59:43 <quicksilver> you can bind a name which reflects the non-IO value
05:59:45 <quicksilver> that's what <- does
05:59:46 <vininim> @type (>>=)
05:59:48 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
05:59:59 <quicksilver> however, your whole expression will certainly be within the IO monad.
06:00:04 <quicksilver> This isn't a problem, though.
06:00:08 <mauke> you can get your hands on the value in IO but only if you yourself are in IO
06:00:11 <quicksilver> But certainly, it *feels* like a problem.
06:00:11 <vininim> the (a -> m b) is the "locally" part
06:00:25 <quicksilver> until you get the hang of it
06:00:34 <rdmltrs> ahh but if i were to use that 3 in a int->int->int function i defined elsewhere that would be okay
06:00:54 <mauke> sure
06:01:01 <quicksilver> rdmltrs: right.
06:01:08 <quicksilver> rdmltrs: that's exactly what that <- notation is for
06:01:16 <quicksilver> (or, the >>= function if you prefer)
06:01:19 <gbacon> rdmltrs: yes, that's what people mean when they talk about running "inside the monad"
06:01:24 <quicksilver> one is just rewritten into the other.
06:01:30 <mauke> > do { x <- return 3; y <- return 39; return (x + y) } ()
06:01:30 <lambdabot>  Parse error at "()" (column 54)
06:01:35 <vininim> I kind of agree with the "do notation is bad" article
06:01:36 <mauke> > do { x <- return 3; y <- return 39; return (x + y) } $()
06:01:37 <lambdabot>  42
06:01:50 <rdmltrs> ah thank you
06:02:09 <gbacon> @type do { x <- return 3; y <- return 39; return (x+y) }
06:02:10 <lambdabot> forall t (t1 :: * -> *). (Num t, Monad t1) => t1 t
06:02:19 <quicksilver> vininim: which areticle is that?
06:02:57 <vininim> syntaxfree.wordpress.com/2006/12/12/do-notation-considered-harmful/
06:03:13 <gbacon> > (return 3 >>= \x -> return 39 >>= \y -> x + y) $ ()
06:03:14 <lambdabot>   add an instance declaration for (Num (() -> b))
06:03:14 <lambdabot>     In the expression: x + ...
06:03:33 <quicksilver> gbacon: missing return :)
06:03:42 <gbacon> > (return 3 >>= \x -> return 39 >>= \y -> return $ x + y) $ ()
06:03:43 <lambdabot>  42
06:03:46 <gbacon> gracias
06:04:00 <opqdonut> ?undo do { x <- return 3; y <- return 39; return (x+y) }
06:04:01 <lambdabot> return 3 >>= \ x -> return 39 >>= \ y -> return (x + y)
06:04:02 <opqdonut> ^_^
06:04:06 <vininim> > return 3 >>= return. (+39)
06:04:07 <lambdabot>   add an instance declaration for (Show (m b))
06:04:25 <gbacon> @pl (return 3 >>= \x -> return 39 >>= \y -> return $ x + y) $ ()
06:04:25 <lambdabot> return 42
06:04:30 <gbacon> hehe
06:04:42 * gbacon tosses lambdabot a Scooby Snack
06:05:08 <gbacon> @pl (return 3 >>= \x -> return 39 >>= \y -> return $ x + y)
06:05:09 <lambdabot> return 42
06:06:17 <vininim> > return 3 >>= Just . (+ 39)
06:06:19 <lambdabot>  Just 42
06:07:49 <vininim> > liftM (+ 39) (Just 3)
06:07:50 <lambdabot>  Just 42
06:09:49 <gbacon> > reverse . show $ foldl1 (*) [1..4]
06:09:50 <lambdabot>  "42"
06:17:02 <quicksilver> vininim: weird article.
06:17:23 <quicksilver> vininim: the author seems unaware of the style where you write code as
06:17:27 <quicksilver> foo >>= \a ->
06:17:32 <quicksilver> bar >>= \b ->
06:17:37 <quicksilver> return (a+b)
06:17:52 <quicksilver> That, in my understand, is the true father of do notation
06:18:07 <quicksilver> looking at it form that angle, I've always felt it was fairly obvious it was just a trivial rewrite
06:18:51 <vininim> as I showed
06:19:20 <vininim> liftM (+b) >>= Just a
06:19:24 <vininim> err
06:19:34 <vininim> liftM (+b) (Monad a)
06:19:54 <vininim> and he talks about people new to the language
06:20:03 <sjanssen> don't use liftM, it's an abomination :)
06:20:14 <vininim> yeah, learning haskell with do notaion
06:20:26 <vininim> sjanssen: come on, 6 months ago with was very hype =)
06:20:28 <matthew_-> sjanssen: eh? why's that then?
06:20:36 <vininim> *it
06:20:37 <quicksilver> matthew_-: it should be called fmap
06:20:39 <quicksilver> matthew_-: or map ;)
06:20:53 <matthew_-> well, fmap does exist too.
06:20:55 <sjanssen> matthew_-: as quicksilver says, it shouldn't exist
06:20:59 <quicksilver> vininim: I really don't agree that do notation should be considered harmful.
06:21:05 <sjanssen> fmap is The One True Name
06:21:09 <matthew_-> you think that IO should be an instance of Functor ?
06:21:16 <EvilTerran> (.) is the one true name
06:21:16 <sjanssen> it is
06:21:18 <quicksilver> vininim: I do agree that more emphasis should be given to it being just a simple rewrite of >>=
06:21:22 <EvilTerran> @instances Functor
06:21:23 <matthew_-> sjanssen: ah!
06:21:24 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
06:21:29 <matthew_-> well spotted ;)
06:21:39 <matthew_-> what about liftM2 ... ?
06:21:43 <quicksilver> vininim: I was just expressing surprise that he didn't show the rewrite with the code style I gave
06:22:05 <sjanssen> matthew_-: liftM2 is slightly better, but Control.Applicative should be preferred nowadays
06:22:14 <matthew_-> ugh, another paper to read...
06:22:27 <matthew_-> ok, well that's only about 10kloc Haskell to rewrite then...
06:22:34 <mauke> liftA2
06:22:47 <matthew_-> ahh, so sed will do it then!
06:23:39 <sjanssen> matthew_-: Applicative is somewhat new and not in Haskell '98, so it's less of a sin to use liftM2
06:23:46 <vininim> > liftA2 (+) (Just 3) (Just 46)
06:23:49 <lambdabot>  Just 49
06:23:50 <quicksilver> Although I dont' think we have Applicative instances for a lot of our monads
06:23:50 <roconnor> isn't liftM2 more efficent?
06:23:58 <quicksilver> don't think there are applicative instances for the mtl ones
06:24:15 <quicksilver> roconnor: not if you trust the inliner, I don't think.
06:24:29 <roconnor> hmmm
06:24:33 <quicksilver> but I'm not entirely sure.
06:24:34 <vininim> is ghci haskell prime ready? (as far as the draft goes)
06:24:46 <vininim> *ghc
06:24:52 <roconnor> quicksilver: does cabal produced optimized libs now?
06:25:09 <quicksilver> roconnor: did it ever not?
06:25:13 <sjanssen> roconnor: -O has been the default for some time now
06:25:30 <roconnor> quicksilver: yep, all the ubuntu haskell packages are not optimized
06:25:39 <roconnor> at least ubuntu 7.04
06:25:58 <sjanssen> roconnor: I'm sure the "base" libraries are compiled with -O
06:26:00 <roconnor> I assume not 7.10 or whatever it is neither.
06:26:19 <roconnor> sjanssen: presumably.  I'm thinking of add-ons like MTL
06:27:15 <matthew_-> is Alternative meant to be replacing MonadPlus ?
06:27:32 <roconnor> common lisp is derived from scheme?!
06:28:49 <opqdonut> i'd think not
06:29:00 <opqdonut> due to some pretty ortogonal design choices
06:29:17 <opqdonut> (separate function and variable namespaces in cl vs. one ns in scheme for example)
06:29:34 <mauke> didn't scheme introduces lexicals/closures?
06:29:37 <matthew_-> ahh, yes ignore that q. It's obvious it sorta is.
06:29:38 <roconnor> opqdonut: whew
06:30:09 <opqdonut> yeah isn't cl dynamically scoped?
06:30:10 <opqdonut> not sure
06:30:16 <ricky_clarkson> CL has both.
06:30:44 <ricky_clarkson> Dynamically scoped vars are 'special' in CL, and are usually written with a * either side by convention.
06:31:02 <ricky_clarkson> Presumably so that IRC clients would render them in *bold*.
06:31:13 <mauke> haha
06:32:42 <dcoutts_> roconnor: cabal configure --enable-optimizations has been the default since cabal-1.2
06:32:49 <opqdonut> :D
06:32:57 <quicksilver> matthew_-: I think alternative is only an 'OrElse-type' MonadPlus, never the additive type
06:33:01 <quicksilver> matthew_-: I'm not sure though :)
06:33:22 <opqdonut> yeah i guess you pretty much need dynscope if you don't have closures
06:44:37 <roconnor> @hoogle throw
06:44:38 <lambdabot> Control.Exception.throw :: Exception -> a
06:44:38 <lambdabot> GHC.Conc.throwTo :: ThreadId -> Exception -> IO ()
06:44:38 <lambdabot> Control.Exception.throwIO :: Exception -> IO a
06:44:49 <roconnor> @hoogle catch
06:44:50 <lambdabot> Prelude.catch :: IO a -> (IOError -> IO a) -> IO a
06:44:50 <lambdabot> Control.Exception.catch :: IO a -> (Exception -> IO a) -> IO a
06:44:50 <lambdabot> System.IO.Error.catch :: IO a -> (IOError -> IO a) -> IO a
06:45:48 <roconnor> @hoogle throwError
06:45:49 <lambdabot> Control.Monad.Error.Class.throwError :: MonadError e m => e -> m a
07:06:13 <dcoutts_> @seen CosmicRay
07:06:13 <lambdabot> I haven't seen CosmicRay.
07:06:32 <dcoutts_> grr, hdbc-* are borked
07:07:52 <BMeph> dcoutts_: Is that the technical term, "borked"? So, what - a Swedish Chef got into the code repository? ;)
07:08:23 <dcoutts_> BMeph: the technical term, sorry :-)
07:08:30 <sieni> BMeph: no that's slang, the technical term is "b0rked"
07:08:45 <dcoutts_> heh
07:08:59 <Botje> !remember BMeph Is that the technical term, "borked"? So, what - a Swedish Chef got into the code repository? ;)
07:09:01 <BMeph> :)
07:09:05 <Botje> remember BMeph Is that the technical term, "borked"? So, what - a Swedish Chef got into the code repository? ;)
07:09:10 <Botje> @remember BMeph Is that the technical term, "borked"? So, what - a Swedish Chef got into the code repository? ;)
07:09:10 <lambdabot> Done.
07:09:13 <Botje> third time's the charm. :(
07:09:50 <vininim> @src (<$>)
07:09:51 <lambdabot> f <$> a = fmap f a
07:10:21 <BMeph> So, why is it fmap, and not, say, mapF?
07:10:32 <vininim> @src mapF
07:10:32 <lambdabot> Source not found.
07:10:44 <vininim> maybe that's why :)
07:11:24 <BMeph> @src fmap
07:11:24 <lambdabot> Source not found. Where did you learn to type?
07:11:36 <vininim> =O
07:11:38 <BMeph> Oh, yes, that makes perfect sense... ;p
07:14:31 <byorgey> well, it's part of the Functor class, so the implementation is different for each instance of Functor.
07:14:42 <byorgey> @src [] fmap
07:14:42 <lambdabot> fmap = map
07:14:51 <byorgey> @src (->) fmap
07:14:51 <lambdabot> fmap = (.)
07:15:01 <oerjan> BMeph: hysterical raisins?
07:15:13 <byorgey> really, it *should* be called 'map'. =)
07:15:41 <byorgey> and the current 'map' should be called 'lmap' or something.
07:15:57 <BMeph> byorgey: Well, if it *should* be called 'map', then they should get the 'f' out!
07:16:10 <dylan> LOL
07:16:11 <byorgey> hehe =)
07:16:19 <BMeph> Err, take the 'f' out of the word, that is, heh-heh. :)
07:16:27 <opqdonut> "the f-word"
07:16:36 <oerjan> and we really believe that's what you meant, yeah sure
07:16:37 <dmhouse> byorgey: or we should get rid of the current 'map'.
07:17:23 <byorgey> dmhouse: well, it would have to be implemented somewhere to provide the Functor instance for [], but yeah, it wouldn't even have to be exported.
07:17:39 <vininim> there might be perfomance issues
07:17:52 <dmhouse> vininim: if you're worried about performance you shouldn't be using [].
07:18:14 <dylan> [] has good performance for some things.
07:18:19 <vininim> ^
07:19:02 <oerjan> hm... it should be possible to include [] in default.  then map could be fmap but still default to [].
07:19:04 <dylan> [Char] might not make a good string, but [a] makes a good stack.
07:19:21 <BMeph> byorgey: but, aren't lists a Functor instance?
07:19:26 <dmhouse> And how useful is it to map over a stack?
07:19:30 <dmhouse> I'd say it's a minor concern.
07:19:32 <byorgey> BMeph: yes, with fmap = map.
07:19:43 <dylan> stacks are not the only use of [a], either.
07:19:49 <byorgey> oerjan: interesting idea.
07:20:37 <dmhouse> Hmm, should there actually be any kind of performance hit at all? The types are discoverable at compile-time, so the indirection could be statically compiled away.
07:21:04 <dylan> I wish hoogle allowed searches like: [a] where a is not Char
07:21:12 <dmhouse> I.e. if you call fmap f xs, the compiler knows that xs is a list, and so can substitute the definition fmap = map at compile time, resulting in no runtime hit.
07:22:38 <oerjan> ghc pretty certainly does that already
07:22:51 <byorgey> dylan: suggest it to ndm!
07:23:10 <dylan> byorgey: I might, when he's here.
07:23:30 <BMeph> @commands
07:23:30 <lambdabot> Unknown command, try @list
07:23:34 <BMeph> @list
07:23:34 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
07:23:37 <dylan> I know @tell, yes.
07:24:17 <dylan> I'll just remember myself until he's here, it's a bit fiddly of an idea anyway.
07:24:40 <dylan> also, I am afraid of causing ndm to rewrite hoogle again. ;)
07:24:45 <oerjan> @kiss
07:24:45 <lambdabot> Maybe you meant: kind list
07:26:37 <nornagon> @lind
07:26:39 <byorgey> dylan: I think ndm is already planning a major update to Hoogle at some point in the future.
07:26:39 <lambdabot> parse error (possibly incorrect indentation)
07:29:40 <oerjan> oh no
07:29:44 <oerjan> @lin
07:29:44 <lambdabot> Maybe you meant: id join kind let list ring run wn
07:29:51 <oerjan> ah
07:29:57 <oerjan> @lind Maybe
07:29:58 <lambdabot> * -> *
07:32:18 <dylan> @ld
07:32:31 <dylan> @kist
07:32:31 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
07:32:40 <dylan> okay, that's just odd. :)
07:32:52 <byorgey> dylan: it corrects commands up to an edit distance of 2 =)
07:33:04 <dylan> @kiss
07:33:04 <lambdabot> Maybe you meant: kind list
07:33:20 <dylan> @kast
07:33:20 <lambdabot> Maybe you meant: ask fact list part paste
07:34:15 <oerjan> @help paste
07:34:15 <lambdabot> paste. Paste page url
07:36:30 <BMeph> @help ask
07:36:30 <lambdabot> ask <nick> <message>. When <nick> shows activity, ask them <message>.
07:38:42 <gbacon> yikes
07:38:46 <gbacon> @figlet foo
07:38:47 <lambdabot> Couldn't run the figlet command.
07:38:50 <gbacon> phew
07:39:08 <gbacon> @vixen
07:39:18 <gbacon> @vixen help
07:39:18 <lambdabot> )
07:39:19 <lambdabot> where can I a see a picture of you?? URL??
07:39:19 <mightybyte> @hoogle Network
07:39:20 <lambdabot> No matches found
07:39:39 <gbacon> @ghc help
07:39:40 <lambdabot> ghc says: For basic information, try the `--help' option.
07:39:46 <gbacon> @ghc foo
07:39:46 <lambdabot> No quotes match. I've seen penguins that can type better than that.
07:40:03 <gbacon> @yhjulwwiefzojcbxybbruweejw
07:40:03 <lambdabot> Just 'J'
07:40:09 <gbacon> @yhjulwwiefzojcbxybbruweejw help
07:40:10 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
07:41:00 <gbacon> @botsnack
07:41:00 <lambdabot> :)
07:41:04 <mightybyte> Anyone know why I get "undefined reference to `networkzm2zi0zi1_NetworkziSocket_zdf9_closure'" when I compile something that uses Network?
07:41:20 <idnar> yhjulwwiefzojcbxybbruweejw? what the heck?
07:41:30 <gbacon> idnar: that's what I thought
07:42:11 <byorgey> mightybyte: maybe you need to compile with --make?
07:42:57 <mightybyte> Aha, thanks.  I don't know how I got as far as I have in Haskell without knowing about that option.
07:43:21 <nominolo> @instances Foldable
07:43:23 <lambdabot> Couldn't find class `Foldable'. Try @instances-importing
07:43:31 <nominolo> @instances-importing Foldable
07:43:31 <lambdabot> Couldn't find class `Foldable'. Try @instances-importing
07:43:52 <gbacon> @yhjulwwiefzojcbxybbruweejw a
07:43:52 <lambdabot> Exception: <<loop>>
07:43:54 <shachaf> @instances-importing Data.Foldable Foldable
07:43:54 <lambdabot> Maybe, []
07:43:55 <gbacon> @yhjulwwiefzojcbxybbruweejw b
07:43:55 <lambdabot> "\"#$%&'()*+,\""
07:44:02 <gbacon> @yhjulwwiefzojcbxybbruweejw c
07:44:02 <lambdabot> Just 'J'
07:44:07 * gbacon scratches head
07:44:21 <faxathisia> @yhjulwwiefzojcbxybbruweejw yhjulwwiefzojcbxybbruweejw
07:44:21 <lambdabot> "\"#$%&'()*+,\""
07:44:22 <dylan> @y c
07:44:22 <lambdabot> Maybe you meant: yarr yhjulwwiefzojcbxybbruweejw yow . ? @ v
07:45:16 <nominolo> why doesn't it show that Set is Foldable?
07:45:37 <byorgey> dmhouse: I was trying out hpaste.el, and it seems to work, except that it also generates some errors at the end: http://hpaste.org/4409
07:45:40 <byorgey> dmhouse: any ideas?
07:46:22 <byorgey> mightybyte: yeah, for some reason, ghc doesn't track down dependencies for linking by default.  I don't know why.
07:47:17 <dmhouse> byorgey: hmm, yeah, I've noticed those too but never got around to fixing them. I'll try to have a look in the next couple of days. Thanks for the reminder.
07:47:30 <mightybyte> byorgey: Ok, I found it in the docs, but it's not in an obvious place for users to discover themselves.
07:47:33 <byorgey> dmhouse: ok, no worries =)
07:48:04 <byorgey> mightybyte: nope, it isn't.
07:48:10 <oerjan> gbacon: apparently at one time lambdabot's > command used an internal variable by that name, which allowed some hacks, and @yhjulwwiefzojcbxybbruweejw displays results of such hacks.
07:48:54 <lQg_> is there a form of take that returns a tuple with the part left over?
07:49:09 <mightybyte> byorgey: And there's no obvious FAQ entry for it.  It might be inferred from some of the other FAQs, but that's not how I usually use FAQs.
07:49:22 <faxathisia> @hoogle Int -> [a] -> ([a],[a])
07:49:22 <lambdabot> Prelude.splitAt :: Int -> [a] -> ([a], [a])
07:49:23 <lambdabot> Data.List.splitAt :: Int -> [a] -> ([a], [a])
07:49:31 <faxathisia> > splitAt 3 "testing 123"
07:49:33 <lambdabot>  ("tes","ting 123")
07:49:38 <lQg_> thanks :)
07:49:42 <oerjan> @instances-importing Data.Set Foldable
07:49:42 <lambdabot> Couldn't find class `Foldable'. Try @instances-importing
07:49:49 <oerjan> @instances-importing Data.Set Data.Foldable Foldable
07:49:50 <lambdabot> Maybe, Set, []
07:50:05 <byorgey> mightybyte: yeah, it's a problem indeed.  I think I learned about it from some tutorial.  Most people seem to learn about it from asking #haskell. =)
07:50:07 <gbacon> oerjan: thanks
07:50:25 <gbacon> @src splitAt
07:50:26 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
07:50:34 <Sizur> the docs say that UTCTime is instance of Show, but my compiler complains otherwise. why? http://haskell.org/ghc/docs/latest/html/libraries/time-1.1.2.0/Data-Time-Clock.html#t%3AUTCTime
07:50:38 <mightybyte> byorgey: Ok, thanks.  Glad it was so easy.  Just wish I didn't have to bother the channel with such simple questions.
07:50:53 <byorgey> mightybyte: but we like answering questions!
07:51:06 <mightybyte> byorgey: Great!
07:51:40 <mightybyte> I must say, this seems to be one of the most helpful IRC channels I've used.
07:52:04 <oerjan> Sizur: istr that the instance is defined in another module
07:52:05 * faxathisia agrees! Everyone here is great :D
07:52:13 <gbacon> @karma+ #haskell
07:52:13 <lambdabot> #haskell's karma raised to 6.
07:52:20 <oerjan> possibly something .Format
07:53:13 <Sizur> oerjan:  yes, thanks. i think it should state so in the docs.
07:54:27 <oerjan> Sizur: "orphan" instances (which are not defined with either the class or datatype) seem to be a problem with the docs
07:54:40 <Sizur> @hoogle IO a -> ExpQ
07:54:40 <lambdabot> No matches, try a more general search
07:55:14 <oerjan> apparently ghc doesn't like them either, has to track them specially
07:55:40 <mightybyte> Is there any tutorial or code that demonstrates how to write a server that listens to a socket and handles multiple connections?  I'm used to the Java threading approach of firing off a separate thread for each connection.  Is there a haskell idiom for doing that?
07:56:00 <mux> mightybyte: yes, forkIO is your friend :)
07:56:23 <mightybyte> mux: Thanks, that should get me started.
07:56:33 <joelr1> good day
07:56:39 <gbacon> mightybyte: http://sequence.complete.org/node/258
07:56:42 <joelr1> @seen bringert
07:56:43 <lambdabot> I saw bringert leaving #haskell 1d 3h 50m 55s ago, and .
07:57:28 <mightybyte> gbacon: Excellent
07:58:28 <mux> oh nice, this one is even using STM
07:58:40 <mux> mm, I wouldn't do that tough, I think
07:59:27 <vininim> > foldr1 (>>) (putChar <$> ['a'..])
07:59:29 <lambdabot>  <IO ()>
07:59:41 <quicksilver> mightybyte: the idiom is similar, but spawning the threads is even easier )
07:59:54 <mux> oh yes :) insanely easy
07:59:55 <quicksilver> mightybyte: you don't need the syntactic verbosity of a Runnable instance.
08:00:33 <quicksilver> mightybyte: and MVars are a more reliable communication method than shared state, but less limiting than object-level monitors.
08:00:36 <quicksilver> or, so it seems to me
08:00:42 <oerjan> > mapM_ putChar ['a'..]
08:00:42 <lambdabot>  <IO ()>
08:00:43 <quicksilver> maybe I'm evangelising a little :)
08:00:50 <oerjan> vininim: ^^
08:02:16 <dmhouse> vininim: foldr (>>) (return ()) = sequence; sequence . map f = mapM f;
08:02:30 <oerjan> dmhouse: missing _'s
08:02:49 <dmhouse> oerjan: I am? Where?
08:03:06 <oerjan> sequence and mapM collect the results
08:03:17 <oerjan> sequence_ and mapM_ throw them away
08:03:23 <nominolo> hm, what is the default data structure for bidirectional maps? just a pair of Maps?
08:03:39 <idnar> :t sequence
08:03:46 <dmhouse> > sequence [Just 1, Just 2, Just 3]
08:03:52 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
08:03:53 <lambdabot>  Just [1,2,3]
08:03:59 <oerjan> nominolo: apparently, it seems to be a FAQ
08:04:04 <dmhouse> > foldr (>>) (return ()) [Just 1, Just 2, Just 3]
08:04:04 <lambdabot>  Just ()
08:04:10 <dmhouse> Oh, my mistake.
08:04:11 <quicksilver> nominolo: there isn't one, yeah. Pair of maps is what I use.
08:04:20 <nominolo> oerjan: we have a FAQ?
08:04:22 <oerjan> (as far as it was asked yesterday too :) )
08:04:26 <quicksilver> oerjan: FSOV "frequent", yes, it is
08:04:44 <vininim> > sequence_ (Just <$> [1..3])
08:04:45 <lambdabot>  Just ()
08:05:18 <hpaste>  mmorrow pasted "Adjoint functors more rigorously defined" at http://hpaste.org/4410
08:05:22 <dmhouse> ?src sequence
08:05:23 <lambdabot> sequence ms = foldr k (return []) ms
08:05:23 <lambdabot>     where
08:05:23 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
08:05:29 <oerjan> nominolo: we have Frequently Asked Questions, but i don't know if there is a list...
08:05:42 <nominolo> oerjan: heh.  well, i have implemented it a couple of times now.  and it felt wrong
08:07:30 <oerjan> dmhouse: that k = liftM2 (:) btw
08:08:00 <oerjan> @src sequence_
08:08:00 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
08:13:45 <mightybyte> quicksilver: I figured haskell would have an easy, intuitive abstraction for it.
08:14:25 <quicksilver> mightybyte: well, I hope your hopes were not disappointed!
08:14:47 <mightybyte> No, definitely not.
08:18:25 <mightybyte> @hoogle newTChan
08:18:28 <lambdabot> Control.Concurrent.STM.TChan.newTChan :: STM (TChan a)
08:18:28 <lambdabot> Control.Concurrent.STM.TChan.newTChanIO :: IO (TChan a)
08:18:50 <quicksilver> TChans are overkill in most cases
08:18:58 <quicksilver> just a plain Chan is normallly fine :)
08:19:04 <quicksilver> STM has some neat tricks, though.
08:19:08 <mightybyte> Ok, don't know the difference yet.
08:19:20 <mightybyte> @hoogle Chan
08:19:21 <lambdabot> Control.Concurrent.Chan :: module
08:19:21 <lambdabot> Control.Concurrent.Chan.Chan :: data Chan a
08:19:21 <lambdabot> Control.Concurrent.STM.TChan :: module
08:19:44 <mightybyte> ...but I have a good idea now.
08:20:56 <nominolo> anyone remember why Set is not a Functor?
08:21:27 <alar> greetings!
08:21:34 * roconnor looks for a description of the ICPF 2006 adventure contest puzzle
08:21:38 <roconnor> ICFP
08:21:49 <faxathisia> hi
08:21:55 <mightybyte> @hoogle forkIO
08:21:56 <lambdabot> GHC.Conc.forkIO :: IO () -> IO ThreadId
08:21:56 <lambdabot> Control.Concurrent.forkIO :: IO () -> IO ThreadId
08:21:57 <faxathisia> @src Set
08:21:58 <lambdabot> Source not found.
08:22:02 <faxathisia> @instances Set
08:22:03 <lambdabot> Couldn't find class `Set'. Try @instances-importing
08:22:10 <faxathisia> What is Set nominolo
08:22:11 <quicksilver> nominolo: the Ord constraint
08:22:13 <dmhouse> ?instances-importing Data.Set SEt
08:22:13 <lambdabot> Couldn't find class `SEt'. Try @instances-importing
08:22:15 <dmhouse> ?instances-importing Data.Set Set
08:22:16 <lambdabot> Couldn't find class `Set'. Try @instances-importing
08:22:39 <alar> Is there a replacement for Num class that fits for vectors?
08:22:47 <nominolo> quicksilver: ah, right.  thanks
08:22:48 <dmhouse> nominolo: it's not an efficient functor, because to define an efficient Set you need an Ord constraint.
08:23:09 <alar> roconnor: http://www.boundvariable.org/
08:23:09 <quicksilver> dmhouse: you could embed the Ord dictionary in the type, if so inclined.
08:23:11 <lambdabot> Title: ICFP Programming Contest, 2006
08:23:28 <roconnor> alar: unfortunately they really only describe the codex problem.
08:23:41 <quicksilver> then you could write the functor instance.
08:23:55 <nominolo> quicksilver: you mean Ord a => Functor (Set a) ?
08:23:57 <Sizur> @type Language.Haskell.TH.runIO
08:23:58 <lambdabot> forall a. IO a -> Language.Haskell.TH.Syntax.Q a
08:24:12 <quicksilver> nominolo: no, I mean if you embed the dictinoary in the Set object
08:24:27 <alar> roconnor: other problems are revealed when you decode codex, but there is somewhere full description
08:24:38 <alar> don't know where to look for it
08:24:44 <quicksilver> nominolo: data Set' a = Set' (a -> a -> Ordering) (Tree a)
08:25:04 <quicksilver> hmm
08:25:12 <quicksilver> actually that might not be enough, on consideration
08:25:20 <oerjan> nominolo: Set a has the wrong kind to be a Functor
08:25:37 <dmhouse> oerjan: Set has the right type, though.
08:25:39 <oerjan> it must be Set itself
08:25:40 <dmhouse> *kind
08:25:51 <roconnor> alar: oh wait, the contest report!
08:25:55 <roconnor> :D
08:25:59 <roconnor> alar: you are a genious
08:26:02 <oerjan> and then you cannot pass on an Ord constraint
08:26:03 <roconnor> genius
08:26:19 <dmhouse> quicksilver: why not?
08:26:43 <roconnor> @where ICFP2006ContestReport
08:26:43 <lambdabot> I know nothing about icfp2006contestreport.
08:26:49 <oerjan> quicksilver: the covariance/contravariance mismatch, i guess
08:26:50 <quicksilver> you still need an ordering for 'b'
08:26:52 <quicksilver> the other type
08:27:04 <nominolo> quicksilver: right. but then you need to be careful with join and friends
08:27:26 <quicksilver> nominolo: yes, you'd have to be very careful. But that's monad :)
08:27:31 <quicksilver> nominolo: I was only worrying about functor, for now
08:27:51 <vininim> > runState State (\ x -> (x+1,x)) 1
08:27:53 <lambdabot>  Couldn't match expected type `State s a'
08:28:00 <nominolo> i believe you could do something with ATs
08:28:12 <vininim> > runState (State (\ x -> (x+1,x))) 1
08:28:14 <lambdabot>  (2,1)
08:28:14 <nominolo> but, i'm fine with Set.map for now
08:28:24 <oerjan> for T to be a Functor, i think T a must have a only in covariant positions
08:28:45 <roconnor> http://www.cs.cmu.edu/~rwh/papers/contest/icfp2006.pdf
08:28:45 <nominolo> what is "covariant"?
08:28:49 <Sizur> @type runState
08:28:50 <lambdabot> forall s a. State s a -> s -> (a, s)
08:28:57 <quicksilver> oerjan: well, it must have a in 'essential' places only on covariant positions, yes
08:29:11 <Sizur> @type State
08:29:11 <lambdabot> forall s a. (s -> (a, s)) -> State s a
08:29:13 <quicksilver> oerjan: I was thinking you could reconstruct the ordering part
08:29:16 <quicksilver> but it's not that easy :)
08:29:29 <quicksilver> however, the ordering part wasn't intuitively part of the 'data'
08:30:59 <Sizur> > runState (State (\x->("result",x+1))) 1
08:31:01 <lambdabot>  ("result",2)
08:31:41 <vininim> oops heh
08:32:15 <vininim> > runState (State (\ x -> (x+1,x+1))) 1
08:32:16 <lambdabot>  (2,2)
08:32:32 <oerjan> nominolo: well in the type a -> b,  b is in covariant position while a is in contravariant position
08:33:04 <chessguy> > (fst &&& snd) 1
08:33:05 <lambdabot>   add an instance declaration for (Num (a, b))
08:33:17 <Sizur> vininim: thanks for trying something like this out here. that's exactly what i'm looking for! a state machine
08:33:48 <quicksilver> I don't think the state monad is really a state machine
08:33:58 <quicksilver> it's just a pretty naive functional interpreation of state
08:34:14 <dmhouse> vininim: really you should avoid using the State constructor.
08:34:17 <quicksilver> state "machine" tends to imply named transistions.
08:34:19 <Sizur> quicksilver: i want a state machine and i could not find it in haskell
08:34:33 <quicksilver> Sizur: I don't think there is a pre-packaged one
08:34:37 <quicksilver> they're very easy to write though
08:34:38 <oerjan> covariant is sort of "directly" contained, while contravariant means to take as an argument.  except that when you nest it, it becomes more complicated
08:34:41 <dmhouse> > runState (do x <- get; put (x + 1); return (x + 1)) 1
08:34:44 <lambdabot>  (2,2)
08:34:47 <quicksilver> precise needs tend to vary.
08:34:48 <Sizur> quicksilver: yeah i can patternmatch against a set states
08:35:04 <quicksilver> I tend to just use recursion for state machines
08:35:12 <quicksilver> and definition-by-pattern-match
08:35:24 <quicksilver> of course, those are static ones
08:35:30 <quicksilver> i.e. transition rules defined at compile time
08:35:51 <Sizur> quicksilver: but how can you save the state then?
08:36:12 <oerjan> http://en.wikipedia.org/wiki/Covariance_and_contravariance_%28computer_science%29
08:36:13 <lambdabot> http://tinyurl.com/2njnzo
08:36:34 <quicksilver> Sizur: well the state would normally be a simple ADT
08:36:44 <quicksilver> Sizur: so I'd save it with show/read
08:36:52 <quicksilver> not entirely sure we're talking about the same thing, though :)
08:38:01 <Sizur> aha, so your stateRunner is iterative and you recurse at a higher level, right?
08:38:36 <quicksilver> hmm I'm not sure what you mean by stateRunner
08:38:45 <quicksilver> e.g., state machine for handling TCP connections:
08:39:01 <quicksilver> handle Startup = --- check authentication
08:39:17 <quicksilver>   -- (containts recursive calles to handle Startup and handle Established)
08:39:32 <quicksilver> handle Established = -- code for established connetions, calls itself recursively
08:39:38 <quicksilver> so, that's a two-state state machine
08:39:44 <quicksilver> (Startup/Established)
08:40:01 <quicksilver> with only one possible transition, from Startup -> Established
08:40:28 <Sizur> so if you want to add something in between you'd have to add it within the handle Startup
08:41:11 <Sizur> like logging for example
08:41:20 <quicksilver> yes, well I wouldn't view logging as another state
08:41:29 <quicksilver> logging would be another action, to add to the statup state
08:41:31 <quicksilver> so, yes.
08:41:39 <Sizur> but it's not part of the state machine for TCP
08:41:43 <Sizur> logically
08:42:00 <Sizur> i mean conceptualy
08:42:36 <Sizur> how can we separate the concerns here?
08:45:03 <scodil> what exactly is "Unfolding" in ghc?
08:45:13 <scodil> as in -ddump-simpl-stats
08:45:44 <dcoutts_> scodil: it's when a function call is replaced by it's body
08:45:47 <dcoutts_> it's inlining
08:46:07 <Sizur> and if you have a continuous state and want to save it, you'd have to save it at predefined cycles
08:46:11 <scodil> so then what are Pre/PostInlineUnconditionally ?
08:46:28 <Sizur> i mean continuous state stransformations
08:49:02 <quicksilver> Sizur: continuous and cycles don't really go together.
08:49:14 <scodil> do newtypes effect unfolding? it seems like it happens less when I use a newtype, along with other simplifications that i suspect are foiled by the lack of unfolding
08:49:20 <quicksilver> Sizur: if you have continuous state it is still presumably measurable, otherwise it's a bit useless.
08:49:31 <quicksilver> so you just save the measurable state, whatever that is.
08:50:08 <Sizur> Startup -> Established -> Startup. how do you save it at a specific point in time?
08:50:33 <Shurique> how are you supposed to use the (=~) and (=~~) regex functions?
08:50:47 <Sizur> once you enter the machine, you cannot do anything else, right?
08:52:15 * alar can't find a way to define "vector" class
08:52:48 <Sizur> alar: what definition of vector?
08:53:22 <Sizur> i think [] will do for a popular definition
08:53:40 <quicksilver> Sizur: well, you just save "Startup" or "Established". That's all the state there is.
08:53:48 <quicksilver> Sizur: real examples have more interesting state than that :)
08:53:53 <quicksilver> so there is normally more to save.
08:54:18 <Sizur> quicksilver: ok. but you'd have to save every cycle then
08:54:28 <Sizur> as part of the state evolution
08:55:07 <quicksilver> why would you have to save every cycle?
08:55:13 <quicksilver> you'd save when you wanted to save.
08:55:28 <quicksilver> or are you trying to save traces?
08:55:37 <Sizur> but i cannot exit the state machine, the saving code must be inside
08:56:10 <quicksilver> right, well using functions to model is always a first approximation
08:56:15 <quicksilver> because functions are opaque
08:56:23 <quicksilver> but it's a small state to go from functions which recurse
08:56:27 <quicksilver> to functions which return the next state
08:56:32 <Sizur> so to achieve that correctly one needs to write the machine using arrows
08:56:36 <quicksilver> and then you have room to impose an external handler
08:57:36 <Sizur> yeah, that kind of machine i wanted. where i can observe and do things 'in-between'
08:59:08 <Sizur> to separate the concerns, to have the state machine have only one purpose
08:59:22 <Sizur> in the functional spirit :)
08:59:29 <alar> Sizur: class form vectors
08:59:30 <oerjan> > "^ *\\([a-z]\\).*$" Text.Regex.=~ "  testing ho" :: [String]
08:59:31 <lambdabot>   Not in scope: `Text.Regex.=~'
08:59:36 <oerjan> bah
08:59:46 <alar> we have class Fractional for scalars
09:00:07 <Sizur> alar: a list can be viewed as a vector
09:00:29 <shapr> @yow !
09:00:29 <lambdabot> I wish I was on a Cincinnati street corner holding a clean dog!
09:00:35 <shapr> Wassup?
09:00:48 <yrlnry> @advice 11941
09:00:48 <lambdabot> 11941 => 11941
09:00:55 <yrlnry> Huh.
09:01:10 <Sizur> shapr: nice stuff in happsBasics, more of that please! :)
09:01:11 <alar> Sizur: yes, but also function can be viewes as vector, tuple can be viewed as vector, and there are more examples
09:01:14 <faxathisia> @adice 100
09:01:15 <lambdabot> 100 => 100
09:01:34 <yrlnry> @jsdfkjsd 139
09:01:35 <lambdabot> Unknown command, try @list
09:01:38 <shapr> Sizur: Ah, TheBasics ?
09:01:51 <Sizur> shapr: yeash
09:01:55 <EvilTerran> @. vixen yow
09:01:57 <shapr> Cool, glad you liked it!
09:02:01 <lambdabot> i think you know the answer to that one, silly
09:02:05 <Sizur> alar: so what definition of a vector do you need then?
09:02:31 <quicksilver> Sizur: I begin to see what you're after :)
09:03:01 <mauke> @advice 2d6
09:03:01 <lambdabot> 2d6 => 3
09:03:12 <shapr> @dice 2d6
09:03:13 <lambdabot> 2d6 => 9
09:03:17 * shapr beats mauke's roll
09:03:18 <alar> Sizur: a class with (+) and (*) properly defined
09:03:29 <shapr> @users
09:03:29 <lambdabot> Maximum users seen in #haskell: 428, currently: 417 (97.4%), active: 17 (4.1%)
09:03:29 <scodil> if I define in module M a function f, and in module N a function g that calls M.f, and both f and g have INLINE pragmas, if from module O I call g should I expect the body of f to be substituted into O's code? I hope that it would but it doesn't seem so
09:03:41 <faxathisia> @advice 1d417
09:03:41 <lambdabot> 1d417 => 279
09:03:46 <Nafai> @shapr
09:03:46 * lambdabot smacks  about with a large trout
09:03:46 <alar> (+)::vector->vector->vector
09:03:48 <alar> (*)scalar->vector->vector
09:03:48 <Sizur> alar: what would be the definition of (*) then?
09:03:52 <shapr> @shapr shapr
09:03:53 * lambdabot places her fist firmely on shapr's jaw
09:03:59 <shapr> firmly?
09:04:00 <Nafai> Hehe
09:04:05 <quicksilver> alar: yes, it's a sensible thing to want. It doesn't really fit with the NUm class.
09:04:06 <shapr> hiya conal!
09:04:15 <quicksilver> alar: you want something a bit more finegrained and sensible
09:04:23 <alar> quicksilver: but I can't!
09:04:26 <quicksilver> alar: there have been a bunch of proposals for better numeric class hierarchies.
09:04:27 * shapr hugs conal 
09:04:28 <conal> shapr: hi!  how goes it?
09:04:34 * conal smiles
09:04:42 <shapr> Life is good, how goes it with you?
09:04:42 <quicksilver> alar: but it would be easy enough to define your own.
09:04:54 <shapr> @seen alexj
09:04:54 <lambdabot> Last time I saw alexj was when I left #darcs, #ghc, #haskell and #scala 1m 2d 19h 47m 21s ago, and .
09:05:06 <alar> if I say class Vec v s where {(*)::s->v->v; (+)::v->v->v}
09:05:06 <Sizur> wow
09:05:08 <alar> i get error
09:05:13 * thetallguy thinks conal and shapr should get a room. ;-)
09:05:28 <alar> because type of (+) doesn't mention s
09:05:30 * conal blushes
09:05:44 * thetallguy laughs
09:05:52 <shapr> thetallguy: I'm just friendly, not trying to hit on conal! I think he has someone already :-)
09:06:00 <mauke> alar: you could say class Vec v s | v -> s where ...
09:06:03 <shapr> Plus, I'm only interested in getting a room with females.
09:06:11 <conal> yeah, but just *one*!
09:06:11 <roconnor> You are in a room with a pile of junk. A hallway leads south.
09:06:12 * shapr throws lambdas at thetallguy 
09:06:14 * thetallguy is just feelin' full of p&v this am
09:06:20 <shapr> conal: hah
09:06:33 <alar> mauke: it seems that fundeps is the only way to define it
09:06:38 * shapr suggests M-x dunnet to roconnor 
09:06:44 * alar is out to try fundeps
09:06:52 * thetallguy looks at \'s sticking through my roof
09:06:59 * faxathisia wonders if anyone knows how what to do with the computer chips in dunnet...
09:07:00 <roconnor> @remember adventure You are in a room with a pile of junk. A hallway leads south.
09:07:01 <lambdabot> I will remember.
09:07:09 <shapr> As far as I know, I'm the only person to lose dunnet in the first move with zero points.
09:07:15 <faxathisia> @quote world.works
09:07:15 <lambdabot> No quotes match. Maybe if you used more than just two fingers...
09:07:28 <faxathisia> shapr hahah :O
09:07:50 <shapr> faxathisia: I'm talented.
09:07:51 <Sizur> @adventure
09:07:51 <lambdabot> Unknown command, try @list
09:07:55 <shapr> hiya thepointer
09:07:55 * conal has been using emacs for 20+ years and didn't know about M-x dunnet !  emacs is my god.
09:08:13 <Sizur> @force adventure!!!
09:08:13 <lambdabot> Maybe you meant: forget free more source
09:08:18 <osfameron> dunnet?
09:08:28 <osfameron> oh, the adventure game baked into emacs?
09:08:33 <conal> yup
09:08:45 <Sizur> @force force
09:08:46 <lambdabot> Maybe you meant: forget free more source
09:08:46 <osfameron> meh.  vim is too busy being a decent editor to have such silliness :-)
09:08:47 <faxathisia> It's just a .el script
09:08:58 <faxathisia> vim isn't very good actually
09:09:10 <conal> M-x align-regexp is also mighty handy.  i just found that one recently.
09:09:11 <thetallguy> if that's the one I think it is, it's a really good adventure
09:09:26 <thetallguy> I just started using dabbrev-expand again
09:09:28 <roconnor> There is a bolt here.
09:09:28 <roconnor> Underneath the bolt, there is a spring.
09:09:35 <conal> thetallguy: i love that one!
09:09:36 <thetallguy> I had lost the binding.
09:09:37 <Sizur> vim is perfect for copy-paste: 500dd, RMB
09:10:01 <Sizur> actuayl paste only lol
09:10:06 <osfameron> faxathisia: it's a great editor.  The scripting environment is horrible though.
09:10:48 <thetallguy> Well folks, this is a breakthrough week.
09:10:57 * osfameron makes a mental note to try viper mode again some time
09:10:58 <Sizur> ED, ED IS THE STANDARD!
09:11:02 <faxathisia> osfameron: I found it to be not good..
09:11:33 * shapr throws primitive lambdas at Sizur 
09:11:36 <osfameron> faxathisia: good for you :-)
09:11:40 <roconnor> Underneath the screw, there is a (broken) motherboard.
09:11:40 <roconnor> Underneath the motherboard, there is a (broken) A-1920-IXB.
09:11:44 <thetallguy> in grad school I audited a course called constructive combinatorics, which had some neat algorithms
09:11:53 <faxathisia> osfameron: "good for you"?
09:12:03 <thetallguy> this week I found the perfect use for one of them.
09:12:18 <thetallguy> knew that knowledge would come in handy some day
09:12:20 <osfameron> faxathisia: as in "ok, that's nice for you, I'm not going to argue the point if you're happy with that"
09:12:37 <faxathisia> osfameron: seems quite condecending
09:12:50 <osfameron> faxathisia: so is telling someone that their preferred editor isn't very good :-)
09:13:16 <faxathisia> osfameron: So why did you do that, initially?
09:13:54 <quicksilver> alar: sure, well, it's easy enough to understand why, right?
09:14:02 <quicksilver> alar: suppose you have no fundep
09:14:20 <quicksilver> alar: and suppose you have an instance Vec v Int {..} and instance Vec v Double {..}
09:14:31 <quicksilver> alar: given a (+) expression, how shall it know which (+) to use?
09:14:56 <osfameron> faxathisia: er.  Just a throwaway comment about the distribution containing some silliness.  I admitted below that I think it's scripting environment is *better* than vim's.  I probably wasn't clear, apologies.  Anyway, off topic so I'll shush now :-)
09:15:13 <mauke> class Vec1 v where (+) :: v -> v -> v
09:15:24 <mauke> class (Vec1 v) => Vec2 v s where (*) :: s -> v -> v
09:16:19 <Spark> i have to use emacs because of proof general
09:16:22 <Spark> and it's a big bag of shit
09:16:56 <faxathisia> proof general is very good actually
09:17:03 <faxathisia> try .. not using it as a comparison
09:17:32 <Spark> so is eating a rotting skunk compared to starving to death
09:17:58 <Spark> my main problem is with emacs though
09:18:13 <faxathisia> which theorem prover are you using?
09:18:17 <Spark> proof general is just meh
09:18:19 <Spark> isabelle
09:18:35 <Spark> it'd be nice to have binds for the buttons so i don't give myself RSI going for the mouse all the time
09:18:49 <faxathisia> you can bind like that
09:18:55 <Spark> i'm sure you can but i haven't worked out how yet
09:19:37 <Spark> it'd also be nice to not have to use xsymbols and it seems to have an obsession with shit fonts
09:19:46 <faxathisia> You can set a custom font :p
09:19:53 <Spark> yeah but they're all crap
09:19:57 <Spark> xemacs segfaults all the time
09:20:00 <Spark> emacs is just crap
09:22:17 <conal> maybe it's time to start #haskell-editor-wars
09:22:35 <doserj> emacs won. end-of-war :)
09:23:22 <mauke> by filesize?
09:23:54 <alar> quicksilver: yes, I should either have vector type always parametric or use fundeps
09:24:02 <quicksilver> conal: I'm not sure that was an editor war, so much as software hate.
09:24:09 <quicksilver> alar: Excatly.
09:24:12 <erik_> @djiin (((t -> t1 -> t2) -> (t -> t1) -> t -> t2) -> (t3 -> t4 -> t3) -> t5) -> t5
09:24:12 <lambdabot> f a = a (\ b c d -> b d (c d)) (\ e _ -> e)
09:24:26 <sieni> doserj: emacs is semi-usable in viper-mode, but it's so damn buggy :-(
09:24:38 <alar> and parametric type wouldn't work for instance (Fractional a)=> Vec a a
09:24:44 <faxathisia> ?djinn a -> b -> (a,b,a,b,a,b,a,b,a,b,a,b,a,b,a)
09:24:44 <lambdabot> f a b = (a, b, a, b, a, b, a, b, a, b, a, b, a, b, a)
09:24:46 <quicksilver> alar: Or use associated types which are essentially like keeping the type parametric without it having to be syntactically parametric.
09:24:49 <quicksilver> alar: right. exactly.
09:25:03 <quicksilver> alar: another alternative is to newtype
09:25:10 <alar> how?
09:25:19 <quicksilver> newtype Wrapped a = Wrapped a
09:25:33 <quicksilver> then 'Wrapped Double' is parametric
09:25:36 <quicksilver> ;)
09:25:43 <quicksilver> but it's also isomorphic to Double
09:26:00 <alar> yes, but I can never define Vec a a with newtype
09:26:08 <mauke> newtype Wrapped a = Wrap { unwrap :: a }  -- the only newtype you'll ever need
09:26:09 <alar> only Vec Wrapper a
09:26:18 <alar> e.g. Identity monad
09:26:31 <mauke> Wrapped (Wrapped (Wrapped omg)))
09:27:03 <roconnor> @hoogle atomically
09:27:04 <lambdabot> GHC.Conc.atomically :: STM a -> IO a
09:27:04 <lambdabot> Control.Exception.NestedAtomically :: Exception
09:27:07 <r3m0t_> um. the only newtype I'll never need. I hope.
09:27:31 <quicksilver> alar: right. exactly. again :)
09:28:01 <quicksilver> I'm not a big fundeps fan but I actulaly think this is a pretty good example of where they work well.
09:28:39 <roconnor> instance Functor a => Functor (Wrapped a) where ...
09:29:29 <ski> roconnor : only if `Wrapped :: (* -> *) -> * -> *' instead
09:30:07 <manu_> @users
09:30:07 <lambdabot> Maximum users seen in #haskell: 428, currently: 420 (98.1%), active: 23 (5.5%)
09:30:10 <Syzygy-> Anyone in here who has done Haskell advocacy directed to mathematicians before?
09:30:52 <alar> mauke: what are associated types?
09:31:06 <mauke> I didn't do it!
09:31:32 <oerjan> no one can prove i did it!
09:31:46 <idnar> do ST and STM actually have anything to do with each other?
09:32:10 <alar> sorry
09:32:22 <alar> quicksilver: what are associated types?
09:32:25 <mauke> idnar: no
09:33:53 <byorgey> Syzygy-: http://sigfpe.blogspot.com/2006/01/eleven-reasons-to-use-haskell-as.html ?
09:34:04 <lambdabot> Title: A Neighborhood of Infinity: Eleven Reasons to use Haskell as a Mathematician, http://tinyurl.com/2dufqz
09:34:21 <quicksilver> alar: they let you associate types with other types
09:34:39 <quicksilver> alar: in the same way that Int is 'associated' with [Int] for trivial syntactic reasons
09:34:44 <quicksilver> alar: (because [] is a type constructor)
09:34:53 <quicksilver> alar: they let you do more general transformations like that
09:34:58 <trontonic> what happens when we reach maximum users? will #haskell explode? we're almost there, 98.1%, oh noes
09:35:12 <quicksilver> so you can say "Int is to MyCleverIntArray as Int is to [Int]" or something
09:35:20 <idnar> maximum users?
09:35:24 <quicksilver> alar: they are a restricted kind of type-level function, in fact
09:35:27 <idnar> oh, that
09:35:30 <idnar> teehee
09:35:37 <Syzygy-> byorgey: Yeah, sigfpe is who convinced me to go use Haskell. Only, now I'm going to go and talk about Haskell to mathematicians myself...
09:36:01 <byorgey> Syzygy-: ah, I see.
09:36:08 <Syzygy-> Even worse.
09:36:27 <Syzygy-> I got a 20min talk slot at the National AMS Meeting, with Haskell mentioned in the talk title.
09:36:30 <byorgey> Syzygy-: well, let me know how it goes, I might be doing the same in June =)
09:36:40 <byorgey> oh, goodness!
09:36:49 <Syzygy-> And I need to prepare the talk so that I can do a test run on tuesday (dept' seminar) and another one on thursday (grad' seminar)
09:36:54 <byorgey> I won't be doing anything *quite* so high-profile...
09:37:01 <Syzygy-> Hehe
09:37:09 <vininim> Sage should be written in Haskell *shrugs*
09:37:17 <byorgey> I'm still interested to know how it goes though =)
09:37:28 <Syzygy-> I have a paper waiting at a Journal too - written in Haskell. With a bit of mathematics around it.
09:37:49 <Syzygy-> That one's stuck because my editor (who asked me personally to write up the article) cannot find a reviewer for it.
09:37:51 <byorgey> right, and they can't find anyone to referee it, right?
09:38:03 <Syzygy-> Yeah.
09:38:20 <Syzygy-> I find the situation hilarious.
09:39:30 <alar> where can I read about them?
09:39:50 <alar> should I use, say, -fassociated-types with them?
09:40:00 <quicksilver> alar: they are not fully implemented, alas
09:40:17 <mauke> more like -XAssociatedTypes (does that exist?)
09:40:39 <quicksilver> alar: you can read about them at the following places:
09:40:45 <quicksilver> alar: http://hackage.haskell.org/trac/ghc/wiki/TypeFunctions
09:40:46 <lambdabot> Title: TypeFunctions - GHC - Trac
09:40:49 <r3m0t> does Haskell support type hints such as f x :: Int -> Int   ?
09:40:51 <quicksilver> alar: http://hackage.haskell.org/trac/ghc/wiki/TypeFunctions
09:40:52 <lambdabot> Title: TypeFunctions - GHC - Trac
09:40:57 <quicksilver> r3m0t: yes.
09:41:08 <quicksilver> r3m0t: (f :: Int -> Int) x
09:41:09 <mauke> > (+) 1 :: Int -> Int
09:41:10 <lambdabot>  <Int -> Int>
09:41:16 <quicksilver> r3m0t: perhaps :)
09:41:22 <quicksilver> r3m0t: not quite sure what you wanted...
09:41:52 <alar> > ((+) 1 :: Int -> Int) 2
09:41:52 <lambdabot>  3
09:42:17 <r3m0t> instead of saying f :: (Num a) => a -> Int -> Int, could you say f x :: Int -> Int and then let it infer the type of x by a definition?
09:42:34 <quicksilver> r3m0t: you don't have to say anything
09:42:43 <quicksilver> r3m0t: haskell infers types by default
09:42:51 <r3m0t> yes but if you put in the type hint, would it accept it?
09:42:53 <quicksilver> with complex type system tricks it may not infer what you want
09:43:00 <quicksilver> you can put a type hint in an expression
09:43:08 <quicksilver> you can't put it in a declaration
09:43:17 <quicksilver> (although with an extension in GHC you can put one in a pattern)
09:43:24 <r3m0t> oh ok
09:44:05 <alar> hehe
09:44:16 <alar> partial type inference would be nice sometimes
09:45:00 <alar> I had experience with arrow which GHC refused to accept without type annotation because of monomorpiism restriction
09:46:03 <alar> with type alike (XmlArrow a)=> a XmlTree (String,(stinr,String),[String],[(string,String)])
09:46:40 <alar> it would be nice to say myfun::(XmlArrow a)=> a XmlTree infer-what
09:46:51 <yrlnry> stinr?
09:46:57 <alar> String
09:46:59 <alar> a typo
09:48:36 <Altair^> how do I make a public "variable" in haskell?
09:49:04 <Altair^> if I just do size::Int in the beginning of the code, I cannot refer it in functions
09:49:12 <Lemmih> Altair^: Sure you can.
09:49:24 <Altair^> ok, then I just screwed it up
09:49:53 <Lemmih> Altair^: Try putting 'the_answer = 42' at the top of your file.
09:52:50 <conal> Altair^: though i won't be vary-able.
09:53:01 <conal> i mean "it" won't be
09:53:06 <Altair^> yes I know that
09:53:10 <conal> ok
09:53:42 <Altair^> I know something about haskell, I have just never programmed it really, so I decided that the best way to learn it is to take up a projec
09:53:49 <Altair^> project to be done with haskell
09:54:03 <conal> Altair^: awesome!
09:54:04 <Altair^> but I am a complete noob anyway :P
09:54:14 <faxathisia> Altair^: I think you are right about that
09:54:16 <faxathisia> being the best way
09:54:33 <conal> thetallguy: i'd like to talk sometime about the idea of composable haskell programs.
09:55:57 <thetallguy> "The only way to learn a new programming language is by writing programs in it."  - Kernighan and Ritchie
09:56:42 <faxathisia> I think it's true of haskell
09:56:49 <faxathisia> I don't think it is true in general though
09:56:54 <thetallguy> conal: Have to finish a blurb for John H's job fair and crank out a small app for my tester, but after that, would love to
09:57:05 <thetallguy> conal: have many thoughts brewing about modeling user
09:57:11 <roconnor> Quiz time:  Who said that Haskell is the best imperative langauge?
09:57:17 <koala_man> I know some guys who have failed their first year java exam six times. they write code on paper figuring that's the best way to practice since it's just like the exam
09:57:19 <conal> thetallguy: you bet.
09:57:24 <sieni> faxathisia: well, it's true for c and especially c++
09:57:25 <thetallguy> roconnor: SPG
09:57:34 <roconnor> and where
09:57:35 <thetallguy> roconnor: world's finest imperative
09:57:53 <sieni> faxathisia: in reality you have much fewer ways to shoot yourself in the foot in haskell
09:57:54 <roconnor> @quote finest
09:57:55 <lambdabot> No quotes match. My pet ferret can type better than you!
09:57:55 <thetallguy> roconnor: Planet Earth
09:58:06 <roconnor> thetallguy: in what paper :P
09:58:06 <thetallguy> lol
09:58:17 <thetallguy> roconnor: Awk Squad?
09:58:35 <roconnor> @where awkward squad
09:58:36 <lambdabot> I know nothing about awkward.
09:58:38 <roconnor> @where awkwardsquad
09:58:38 <lambdabot> I know nothing about awkwardsquad.
09:58:49 <EvilTerran> @go tackling the awkward squad
09:58:50 <lambdabot> http://research.microsoft.com/~simonpj/Papers/marktoberdorf/
09:58:50 <lambdabot> Title: Simon Peyton Jones: papers
09:59:51 * thetallguy puts blinders on.
10:00:07 <shapr> @users
10:00:07 <lambdabot> Maximum users seen in #haskell: 428, currently: 420 (98.1%), active: 22 (5.2%)
10:00:14 <shapr> Yay, numbers are growing!
10:02:43 <Lemmih> Someone isn't hearing our creed to avoid success at all cost.
10:02:57 <shapr> Must be a lot of someones
10:03:40 <shapr> Hopefully someones with CODE!
10:03:51 * shapr is Codependent, as usual.
10:04:01 <shapr> er, CODEpendent
10:04:08 * faxathisia would like to code something but doesn't know what to do.. just finishd up some things
10:05:09 <vininim> someone early was suggesting me to not use State Monad, what is suggested?
10:05:24 <shapr> faxathisia: hack on cabal?
10:06:42 <roconnor> @type put
10:06:44 <lambdabot> forall s (m :: * -> *). (MonadState s m) => s -> m ()
10:09:54 <Vulpyne> :r
10:09:58 <Vulpyne> Ops.
10:10:06 <Vulpyne> Damn, I can't even type "oops" correctly. :(
10:11:09 <manu_> @users
10:11:09 <lambdabot> Maximum users seen in #haskell: 428, currently: 423 (98.8%), active: 21 (5.0%)
10:21:14 <oerjan> vininim: the State monad is fine for its use.  they must have meant for your particular problem.
10:24:00 <BMeph> Here's one for you, faxathisia: do you know how to get the readline package to work with GHC 6.8 in Windows, w/o using Cygwin?
10:32:49 <oerjan> @remember sigfpe Haskell comes with a library of functions called the 'standard prelude'. Unfortunately, whoever designed it knew just enough mathematics to be dangerous and made a complete hash of it.
10:32:50 <lambdabot> Okay.
10:33:33 <roconnor> w00t, done my Haskell slides
10:34:11 <roconnor> ``Functional Programming Imperative''
10:35:14 <BMeph> roconnor: Nice! Was "A critique of Pure Functions" taken? ;)
10:38:23 <roconnor> BMeph: nah, my topic is about how to use different monads to solve problems.
10:39:32 <roconnor> So it is all about doing imperative style programming in haskell, and why one giant monad for the whole language isn't good enough.
10:39:54 <roconnor> hence it is imperative to use functional programming.
10:40:27 <BMeph> Hm, it sounds more like a case for monads as a "categorical imperative"... ;)
10:40:57 <ski> Divide et impere !
10:41:08 <roconnor> ;D
10:41:55 <roconnor> time for dinner
10:45:47 <dons> woot. ghc 6.8.2
10:45:53 <dons> http://haskell.org/ghc/docs/6.8.2/html/users_guide/release-6-8-2.html
10:45:55 <lambdabot> http://tinyurl.com/2coxep
10:46:07 <byorgey> hurrah, 6.8.2!
10:47:19 * BMeph does Snoopy's "happy dance"...until his co-workers start to stare.
10:51:42 <gbacon> @hoogle [a] -> [(a,a)]
10:51:43 <lambdabot> Prelude.zip :: [a] -> [b] -> [(a, b)]
10:51:43 <lambdabot> Data.List.zip :: [a] -> [b] -> [(a, b)]
10:52:02 <gbacon> @type unzip
10:52:02 <faxathisia> what function are you looking for gbacon?
10:52:03 <lambdabot> forall a b. [(a, b)] -> ([a], [b])
10:52:09 <faxathisia> I'm just curious what would have that type
10:52:53 <gbacon> I'd like to chop a list of as into a list of pairs (a,a)
10:53:01 <gbacon> easy to write, but I figured it's already there
10:53:13 <faxathisia> I don't understand
10:53:26 <gbacon> [1,2,3,4] -> [(1,2),(3,4)]
10:53:29 <faxathisia> ahh
10:53:56 <faxathisia> map (uncurry (,)) . chunk 2 -- might be nice
10:54:05 <faxathisia> or something like it
10:54:10 <BMeph> No, it's too easy, just like the 'swap' function isn't here.
10:54:24 <gbacon> > map (uncurry (,)) . chunk 2) [1,2,3,4]
10:54:25 <lambdabot> Unbalanced parentheses
10:54:28 * BMeph is still "grumpy" about 'swap' not being in the Prelude
10:54:35 <dons> swap?
10:54:40 <dons> (a,b) -> (b,a) ?
10:54:41 <gbacon> > map (uncurry (,) . chunk 2) [1,2,3,4]
10:54:43 <faxathisia> > map (uncurry (,)) [[1,2],[3,4]]
10:54:47 <dons> ?djinn (a,b) -> (b,a)
10:54:47 <lambdabot> f (a, b) = (b, a)
10:54:48 <lambdabot>   Not in scope: `chunk'
10:54:49 <lambdabot>  Couldn't match expected type `(a, b)' against inferred type `[a1]'
10:54:49 <BMeph> dons: swap (a,b) = (b,a)
10:54:56 <faxathisia> oh :|
10:55:04 <faxathisia> I think that was a bad idea of mine
10:55:05 <dons> i don't think people use tuples like that very often.
10:55:54 <gbacon> well, from a higher level, I'm trying to walk down a list of conceptually paired command line arguments
10:56:20 <gbacon> forM (pairs args) $ do -> ...
10:57:16 <BMeph> I had a program where I was using unfold to split a number into its digits, but you have to swap the members of divMod to match its expected format.
10:57:41 <BMeph> I was just minorly annoyed to see that a function that simple wasn't already defined.
10:57:51 <kscaldef> isn't that what flip is for, more or less?
10:58:39 <BMeph> More or less, but because there's no swap, you have to do something hokey, like uncurry (flip (,)), or such.
10:59:03 <BMeph> I'd rather just have a swap function.
10:59:13 <faxathisia> :t uncurry (flip (,))
10:59:15 <lambdabot> forall b a. (a, b) -> (b, a)
10:59:22 <faxathisia> so write swap = uncurry (flip (,))
10:59:28 <dons> we really need to get oleg to use cabal and hackage.
10:59:42 <BMeph> It's not a problem, I have a module of utility functions I keep for convenience.
11:00:25 <byorgey> or there could even be swap :: (Arrow a) => a (b,c) (c,b).
11:00:36 <BMeph> faxathisia: It's easier and more direct to go with the points, and just say swap (a,b) = (b,a)
11:00:48 <faxathisia> so write swap (a,b) = (b,a)
11:00:59 <BMeph> ...I do. ;p
11:01:05 <faxathisia> ok I missed your point then
11:02:04 <BMeph> My point, is that it looks like the kind of function that should already be defined, and I personally find it odd to have to define it myself.
11:02:05 <alar> :t flip
11:02:07 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
11:02:31 <byorgey> :t snd &&& fst
11:02:32 <lambdabot> forall a b. (a, b) -> (b, a)
11:02:34 <sclv_> :t (snd &&& fst)
11:02:34 <lambdabot> forall a b. (a, b) -> (b, a)
11:02:54 <byorgey> hmm, defaulting?
11:03:14 <byorgey> :t (snd &&& fst) :: (Arrow a) => a (b,c) (c,b)
11:03:15 <lambdabot>     Couldn't match expected type `a' (a rigid variable)
11:03:15 <lambdabot>            against inferred type `(->)'
11:03:15 <lambdabot>       `a' is bound by the polymorphic type
11:03:44 <BMeph> It's not a major problem, like 'fail' in the Monad class, it just seems odd to me.
11:03:53 <sclv_> @djinn (a,b)->(b,a)
11:03:53 <lambdabot> f (a, b) = (b, a)
11:04:23 <byorgey> :t (arr snd &&& arr fst)  -- oops
11:04:26 <lambdabot> forall a b (a1 :: * -> * -> *). (Arrow a1) => a1 (a, b) (b, a)
11:04:31 <byorgey> that's better =)
11:05:05 <profmakx> hmpf. anyone interested in fixing hs-plugins for 6.8? or is it to be replaced by something new-and-shiny? i poked around a bit in the code but i do certainly not have the knowledge to fix it...
11:06:14 <BMeph> >let swap (a,b) = (b,a)
11:06:31 <pejo> Oh, 6.8.2. Nice Igloo. :-)
11:12:01 --- mode: ChanServ set +o dons
11:12:04 --- topic: set to '["The Haskell programming language","GHC 6.8.2 released!","http://haskell.org ","http://www.jobs-in-fp.org/","Paste: http://hpaste.org ","Logs: http://tunes.org/~nef/logs/haskell/"]' by dons
11:12:08 --- mode: ChanServ set -o dons
11:12:57 * profmakx is compiling 6.8.2 on his machine right now
11:14:13 <mightybyte> Am I correct in my understanding that queues are channels in haskell?
11:14:30 <dons> hmm?
11:15:00 <mightybyte> I'm working on learning concurrency.
11:15:25 <mightybyte> The queue is an important data structure for concurrency in procedural styles.
11:15:37 <mightybyte> So I was looking for the equivalent in haskell
11:15:42 <dons> ah, right, as in Control.Concurrent.Chan
11:16:04 <mightybyte> Yes
11:16:30 <mightybyte> Or Control.Concurrent.STM.TChan
11:17:16 <alexj> someone just told me that ghc keeps multiple copies of all values in memory if you are using data.map or data.set... is that true?
11:17:33 <dons> no. yes. it depends.
11:18:23 <sieni> alexj: maybe the "someone" has problems understanding quantifiers
11:18:51 <alexj> ?
11:20:46 <sieni> alexj: I mean, your statement doesn't make much sense. why would you want to duplicate values in memory just for fun?
11:21:00 <alexj> dons: apparently it is an issue with generational garnage collection.
11:21:16 <alexj> sieni: to get nice garbage collection?
11:21:45 <sieni> alexj: so generational garbage collection is bad?
11:22:01 <scodil> what's it got to do with Set and Map?
11:22:08 <alexj> dunno.  that is why I am asking?
11:22:11 <vininim> mmm sigfpe post about E8 is nice.
11:24:40 <vininim> @src liftIO
11:24:40 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
11:24:43 <sieni> alexj: well, it typically moves objects and moving an object typically requires making a copy of it and deleting the previous one, but it does not follow that you are keeping multiple copies of all objects in the memory simultaneously
11:24:46 <vininim> @type liftIO
11:24:50 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
11:25:28 <pejo> sieni, the GC doesn't use any kind of forwarding pointer during the gc process?
11:26:14 <alar> quicksilver: it disallows me to derive one fundep class from the other
11:26:24 <sieni> what? I was talking about generational gc in general
11:26:35 <alar> class Listable v s | v -> s where ...
11:26:49 <alar> class Vec v s | v -> s where ...
11:26:58 <alar> instance Listable v s => Vec v s
11:27:31 <alar> Illegal type in class constraint
11:29:15 <alar> ah, sorry
11:29:41 <vininim> @type build
11:29:42 <lambdabot> Not in scope: `build'
11:30:15 <ski> @type GHC.Exts.build
11:30:16 <lambdabot> forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
11:30:24 <profmakx> well. nice!
11:30:37 <profmakx> ghc 6.8.2 build flawlessly on FreeBSD7-Beta4
11:31:15 <dcoutts_> profmakx: gah, your machine must be much faster than mine, I've been building since well before the release announcement :-)
11:31:32 <profmakx> its a 2.6ghz core2 duo
11:31:40 <dcoutts_> ah :-) nice
11:31:41 <profmakx> and i did not build extralibs
11:31:47 * dcoutts_ neither
11:31:53 <Lemmih> Simon Marlow: "Copying GC will use about 3x the live data in normal operation: 2x due to the copying, and an extra 1x to allocate into, plus there may be some free memory due to fragmentation (hopefully not much)."
11:31:56 <profmakx> pity, that ghci does not work
11:34:10 <alexj> any way to reduce that?  that seems hugely burdensome
11:34:22 * alar needs tutorial on using fundeps
11:34:33 <Lemmih> @seen JaffaCake
11:34:33 <lambdabot> JaffaCake is in #haskell and #ghc. I last heard JaffaCake speak 4h 15m 38s ago.
11:34:41 <gbacon> @pl concat . mapM
11:34:42 <lambdabot> join . mapM
11:34:59 <gbacon> @type concat . mapM
11:35:01 <lambdabot>     Couldn't match expected type `[[a]]'
11:35:02 <lambdabot>            against inferred type `[a1] -> m [b]'
11:35:02 <lambdabot>     In the second argument of `(.)', namely `mapM'
11:35:19 <gbacon> @type join . mapM
11:35:19 <lambdabot> forall a b. (a -> [a] -> b) -> [a] -> [b]
11:35:42 <mrd> did it just default to the [] monad
11:35:57 <mrd> @djinn (a -> [a] -> b) -> [a] -> [b]
11:35:58 <lambdabot> -- f cannot be realized.
11:36:17 <mrd> @djinn (a -> b) -> [a] -> [b]
11:36:17 <lambdabot> -- f cannot be realized.
11:36:33 * mrd stuffs djinn back in the bottle
11:37:28 <yrlnry> Why can't it  (a -> b) -> [a] -> [b] ?
11:37:52 <gbacon> @type map
11:37:53 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
11:38:32 <desegnis> Does djinn cope with lists at all?
11:38:50 <mrd> @djinn [a] -> a
11:38:51 <lambdabot> -- f cannot be realized.
11:38:58 <mrd> @djinn a -> [a]
11:38:58 <lambdabot> -- f cannot be realized.
11:39:00 <glguy> ?seen bos
11:39:01 <lambdabot> bos is in #ghc and #haskell. I don't know when bos last spoke.
11:39:22 <mrd> 6.8.2 came out quickly. or maybe time is flying.
11:39:30 <bos> que?
11:39:35 <glguy> it was needed to enable one of the star optimizations
11:40:18 <yrlnry> @djinn [a] -> [a]
11:40:18 <lambdabot> f a = a
11:40:21 <yrlnry> Ahhh.
11:40:56 <integral> free theorems?
11:41:15 <mrd> @free map
11:41:22 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
11:43:31 <alar> @seen lambdabot
11:43:32 <lambdabot> Yes, I'm here. I'm in #friendly-coders, #scannedinavian, #gentoo-haskell, ##logic, #xmonad, #unicycling, #perl6, #parrot, #jtiger, #haskell-soc, #haskell-overflow, #haskell-blah, #scala, #haskell, #
11:43:32 <lambdabot> ghc and #darcs
11:43:47 <mrd> @bot
11:43:47 <lambdabot> :)
11:44:35 <alar> does lambdabot unicycle?
11:44:54 <mrd> lambdabot unicycles in parallel
11:45:03 <sieni> I think he's bicyclual
11:45:03 <RockTheDragon> > let uni = true in uni `cycle`
11:45:03 <lambdabot>  Parse error at end of input
11:45:07 <sieni> she
11:45:12 <sieni> whatever
11:45:16 <RockTheDragon> > let uni = true in cycle uni
11:45:17 <lambdabot>   Not in scope: `true'
11:45:32 <RockTheDragon> > let uni = 1 in cycle uni
11:45:33 <lambdabot>   add an instance declaration for (Num [a])
11:45:33 <lambdabot>     In the expression: 1
11:45:33 <lambdabot>     In t...
11:45:44 <RockTheDragon> Gah.
11:45:49 <alar> :t cycle
11:45:50 <lambdabot> forall a. [a] -> [a]
11:45:58 <RockTheDragon> Oh, I was thinking of repeat
11:46:08 <RockTheDragon> > cycle "uni"
11:46:09 <lambdabot>  "uniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuni...
11:46:18 <RockTheDragon> Yes. lambdabot unicycles :-P
11:46:23 <alar> =))))
11:46:51 <RockTheDragon> Hmm. I need to refresh my haskell a bit
11:47:05 <idnar> uniunium
11:47:14 <byorgey> > ("uni" `cycle`)
11:47:14 <lambdabot>  "uniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuni...
11:47:22 <faxathisia> byorgey :D
11:48:12 <RockTheDragon> Hmm, you win, I guess :-)
11:51:10 <RockTheDragon> > flip ($) "uni" cycle
11:51:10 <lambdabot>  "uniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuniuni...
11:51:13 <kalmar> ghci doesn't respect CPP stuff?
11:51:22 <kalmar> #ifndef etc?
11:51:34 <kalmar> or am I missing a flag?
11:51:51 <sieni> kalmar: what?
11:52:06 <kalmar> I wanted to poke around the XMonad in ghci
11:52:16 <kalmar> browse, check types etc.
11:52:16 <Lemmih> kalmar: -XCPP
11:52:19 <kalmar> ah
11:52:23 <kalmar> Lemmih: thanks
11:52:35 <yrlnry> :t repeat
11:52:36 <lambdabot> forall a. a -> [a]
11:52:42 <kalmar> um unrecognised flag
11:52:44 <kalmar> weird
11:52:46 <yrlnry> Oh, here I've been using cycle [foo]
11:52:53 <yrlnry> @src repeat
11:52:53 <lambdabot> repeat x = xs where xs = x : xs
11:54:56 <roconnor> @free join
11:54:57 <lambdabot> Expected variable or '.'
11:56:05 <alar> @help free
11:56:05 <lambdabot> free <ident>. Generate theorems for free
11:59:58 <kalmar> ?free id
11:59:59 <lambdabot> f . id = id . f
12:00:10 <kalmar> ?free liftM2
12:00:11 <lambdabot> Expected variable or '.'
12:00:13 <roconnor> @free (.)
12:00:13 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
12:00:24 <kalmar> ?free fmap
12:00:25 <lambdabot> Expected variable or '.'
12:00:32 <kalmar> ?free Control.Monad.liftM2
12:00:33 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
12:00:43 <kalmar> ?free sort
12:00:44 <lambdabot> Extra stuff at end of line in retrieved type "forall a. (Ord a) => [a] -> [a]\n"
12:01:00 <kalmar> ?free foldr
12:01:00 <lambdabot> (forall x. g . h x = k (f x) . g) => g . foldr h y = foldr k (g y) . $map f
12:01:14 <roconnor> @free reverse
12:01:15 <lambdabot> $map f . reverse = reverse . $map f
12:01:31 <roconnor> @free Just
12:01:31 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
12:01:43 <roconnor> @free maybe
12:01:44 <lambdabot> f . h = k . g => f . maybe x h = maybe (f x) k . $map_Maybe g
12:01:59 <Altair^> how do I print a numeral using putStrLn? it works with print but I guess it would be useful to know that one too
12:02:08 <roconnor> @src print
12:02:08 <lambdabot> print x = putStrLn (show x)
12:02:15 <Altair^> oh yeah
12:02:43 <thetallguy> @pl print x = putStrLn (show x)
12:02:43 <lambdabot> print = putStrLn . show
12:02:59 <thetallguy> @pl (@src print)
12:03:00 <lambdabot> (@ src print)
12:03:14 <thetallguy> lambdabot commands aren't composable.
12:03:27 <opqdonut> yes they are
12:03:33 <roconnor> @. pl src print
12:03:33 <lambdabot> (line 1, column 1):
12:03:33 <lambdabot> unexpected end of input
12:03:33 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
12:03:34 <opqdonut> @. pl src print
12:03:34 <lambdabot> (line 1, column 1):
12:03:34 <lambdabot> unexpected end of input
12:03:35 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
12:03:40 <opqdonut> heh
12:03:46 <opqdonut> @. elite yow
12:03:47 <lambdabot> Yow! maYbE i $HoU1d |-|avE azked ph0r mY NeU7RoN 80/\/\B In pAi51ey --
12:03:50 <thetallguy> almost!
12:04:03 <thetallguy> ?type @.
12:04:04 <lambdabot> parse error on input `@.'
12:04:11 <roconnor> @help .
12:04:11 <lambdabot> . <cmd1> <cmd2> [args].
12:04:11 <lambdabot> . [or compose] is the composition of two plugins
12:04:11 <lambdabot>  The following semantics are used: . f g xs == g xs >>= f
12:04:26 <thetallguy> Nice.
12:04:27 <opqdonut> @help @
12:04:27 <lambdabot>  @ [args].
12:04:27 <lambdabot>  @ executes plugin invocations in its arguments, parentheses can be used.
12:04:27 <lambdabot>  The commands are right associative.
12:04:27 <lambdabot>  For example:    @ @pl @undo code
12:04:27 <lambdabot>  is the same as: @ (@pl (@undo code))
12:04:47 <opqdonut> @ @pl (@src print)
12:04:51 <opqdonut> @@ @pl (@src print)
12:04:51 <lambdabot>  (line 1, column 1):
12:04:52 <lambdabot> unexpected end of input
12:04:52 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
12:04:58 <opqdonut> yeah anyway
12:05:09 <roconnor> something is wrong with the output of src?
12:05:21 <thetallguy> @src print
12:05:21 <lambdabot> print x = putStrLn (show x)
12:05:29 <joelr1> evening
12:05:47 <allbery_b> @pl print x = putStrLn (show x)
12:05:47 <lambdabot> print = putStrLn . show
12:05:53 <allbery_b> ok, that works at least
12:06:11 <thetallguy> @. pl src id
12:06:11 <lambdabot> (line 1, column 1):
12:06:12 <lambdabot> unexpected end of input
12:06:12 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
12:06:22 <thetallguy> @src id
12:06:22 <lambdabot> id x = x
12:06:36 <thetallguy> @help src
12:06:36 <lambdabot> src <id>. Display the implementation of a standard function
12:06:52 <allbery_b>  @src produces no output when composed for some reason?
12:06:54 <thetallguy> I think src has the wrong type
12:07:08 <thetallguy> -> IO ()
12:07:23 <opqdonut> yeh
12:07:37 <thetallguy> Should be fixable.
12:08:25 <kalmar> ?help ?
12:08:26 <lambdabot> ? [args].
12:08:26 <lambdabot> ? executes plugin invocations in its arguments, parentheses can be used.
12:08:26 <lambdabot>  The commands are right associative.
12:08:26 <lambdabot>  For example:    ? ?pl ?undo code
12:08:26 <lambdabot>  is the same as: ? (?pl (?undo code))
12:08:34 <kalmar> cool
12:15:21 <njbartlett> @seen dcoutts
12:15:21 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-overflow, #ghc and #haskell. I last heard dcoutts speak 8h 16m 32s ago.
12:15:35 <dcoutts_> njbartlett: hia
12:15:54 <njbartlett> Oh hi
12:16:35 <njbartlett> dcoutts_: Just noticed somebody's written a port of Gtk+ so it runs natively on Mac
12:16:53 <njbartlett> dcoutts_: (ie without X11). Wondering if gtk2hs will work with it
12:17:30 <BMeph> @. pl (src print)
12:17:30 <lambdabot> Plugin `compose' failed with: Unknown command: "(src"
12:17:33 <dcoutts_> njbartlett: yes, that has been in development for a while now. I don't know if it's ready for end users yet.
12:18:02 <dcoutts_> njbartlett: but in principle it should work, the choice of gtk backends should not affect the gtk api so gtk2hs should work with it just fine.
12:18:07 <njbartlett> dcoutts_: I saw it mentioned in a news item about Mono. Apparently it can run MonoDevelop
12:18:26 <dcoutts_> njbartlett: well it's come pretty far then :-) perhaps it's time someone tried it with gtk2hs
12:18:37 <dcoutts_> I've not heard any reports so far
12:18:47 <njbartlett> Well I'm going to have a quick go
12:21:51 <ertai> does anyone succefully compiled (and ran) Yi using a recent ghc(6.8.1)?
12:22:49 <dcoutts_> njbartlett: let me know how it goes. You know that it does not yet use a native theme.
12:23:34 <njbartlett> dcoutts_: Yeah. Still, not having to use X11 will make it a lot nicer to use.
12:24:50 <dcoutts_> njbartlett: sure, I've been looking forward to this for ages, it should make gtk more of a first class citizen on osx
12:25:18 <hpaste>  alar pasted "Vector class with fundeps" at http://hpaste.org/4413
12:25:22 <RayNbow> hmm
12:25:34 <alar> What's wrong with my fundeps?
12:25:39 <RayNbow> Windows installer of GHC6.8.2 is a bit odd...
12:25:41 <augustss> @seen dons
12:25:41 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 1h 8m 8s ago.
12:25:41 <njbartlett> dcoutts_: Yup. I think first thing I need to do is make sure I get rid of the Gtk I got from MacPorts :-)
12:26:07 <dcoutts_> njbartlett: yeah, good idea, having two can cause real confusion
12:26:09 * alar don't understand why it says "conflicting definitions"
12:26:17 <RayNbow> it added "C:\Program Files\Haskell\bin" to the PATH... while that folder doesn't exist...
12:26:18 <scodil> alar: conflicting defs for what?
12:26:27 <dons> augustss: ?
12:26:49 <alar> instance Vec [s] s and instance (Res v s)=>  Vec v s
12:26:51 * dcoutts_ notes that Cabal-1.2.3.0 is out
12:27:04 <augustss> dons: Is Galois having any presence at jobs-in-fp?
12:27:05 <scodil> is [a] and instance of Res a b?
12:27:15 <dons> augustss: we hope to have some slides for john, yep.
12:27:18 <dons> i'm chasing that up now.
12:27:25 <alar> there are no instances of Res at the moment
12:27:31 <psykotic> dons: how many haskell guys are at galois total?
12:27:44 <augustss> dons: cool, I just wanted to make sure you guys weren't missing out because Andy is away
12:28:15 <dons> augustss: nope, we're just trying to work out what the best response would be, as we're not sending anyone
12:28:26 <dons> psykotic: several dozen?
12:28:49 <dons> augustss: thanks for pinging jh about it, btw.
12:29:32 <joelr1> augustss: aren't there visa issues since the people at jobs-in-fp would be european and galois is in the us? or is john holding another jobs-in-fp?
12:29:34 <psykotic> augustss, btw, you gave some presentation about haskell tricks for embedded DSLs somewhere, i remember seing--maybe Fun in the Afternoon? do you have the slides for that anywhere?
12:29:43 <augustss> wow, 89 registered now.  by backpack will be heavy with glossy brochures
12:29:53 <dons> heh
12:30:03 <dcoutts_> augustss: you're going in person then? that's great
12:30:05 <scodil> alar: i'm not sure you can use instance constraints as necessary conditions, only sufficient. Like, its not using the Res v s requirement to disqualify that second instance of Vec.
12:30:06 <dons> psykotic: maybe augustss' blog slides on that series?
12:30:19 <augustss> psykotic: no slides.  they were on my Mac that had a disk crash
12:30:32 <psykotic> augustss, ah okay. disk crashes are no fun.
12:30:38 <scodil> and so both instances apply, even though the compiler would fail if it tried to use the second one
12:30:38 <augustss> dcoutts_: yes, I'm going, and Simon Frankau frm BarCap
12:30:42 <psykotic> i just had one too
12:31:06 <scodil> alar: i'm not sure about that though
12:31:29 <alar> scodil: yes, but they do not overlap - there are no type which is both [a] and Res
12:31:35 <scodil> you have -fallow-overlapping-instances on?
12:31:36 <augustss> dons: tell rjmh to put the Galois logo on the web page
12:31:37 <Philippa> psykotic: most of it was the sort of stuff described as "overloadable syntax" in the GHC manual, taken perhaps a step further. Using the monad syntax for things that aren't monads because they don't have a use for return, say
12:31:44 <joelr1> @seen bringert
12:31:44 <lambdabot> I saw bringert leaving #haskell 1d 8h 25m 57s ago, and .
12:31:47 <alar> I'm just trying to define generic Vector class
12:31:51 <scodil> alar: but you could make them overlap at a later time by making [a] and instance of Res
12:31:54 <dcoutts_> augustss: I should see if it's possible to get some FP recruitment material to put in the undergraduate area here, along with all the management consultancy ****
12:31:59 <dons> augustss: will do.
12:32:00 <RayNbow> hey dons, I understood more about your paper about streams after watching http://www.londonhug.net/2007/09/25/nested-data-parallelism-video-returns/ :)
12:32:01 <lambdabot> Title: Î»ondon HUG » Blog Archive » Nested Data Parallelism Video Returns!, http://tinyurl.com/2pw275
12:32:07 <dons> RayNbow: ah, cool :)
12:32:31 <alar> scodil: yes, but how can I tell the compiler that they wil never overlap?
12:32:44 <alar> I'm just trying to make vector class
12:33:00 <scodil> i don't know that you can. why don't you make [a] an instance of Res? The methods would just be id
12:33:00 <alar> with addition and multiplication by scalar
12:34:05 <alar> scodil: yes, it would work, but after that I can't make instance (Fractional a) => Vec a a
12:34:21 <alar> because compiler will think it can overlap with something
12:34:45 <alar> is generic vector class unimplementable even with fundeps?
12:34:58 <scodil> i've done it at least 3 times
12:35:27 <scodil> with lists, with plain data types and with statically sized lists
12:35:42 <alar> that's what I want
12:35:43 <scodil> it seems like you're doing it with lists, why not just stick with that?
12:35:52 <scodil> i don't think you need a class
12:35:53 <alar> can they all be made instances of single class?
12:36:20 <scodil> Num a => (.+) :: [a] -> [a] -> [a]; a (.+) = zipWith (+)
12:36:39 <alar> I'm trying it with lists because it's easy, but I want to do it with plain data when it starts to work
12:36:45 <scodil> er, (.+) = zipWith (+). thats what i meant
12:37:16 <scodil> ok but what is Res?
12:37:43 <scodil> the only think messing you up is that catch-all instance, Res v s => Vec v s
12:37:46 <scodil> thing
12:38:18 <scodil> without that you're fine. you can later make an instance out of something like 'data Vec3 a = Vec3 a a a'
12:38:28 <alar> Res is a thing that can be unloaded into list and loaded from list
12:38:48 <mightybyte> What's the difference between a Chan and a TChan (other than the fact that TChan is in Concurrent.STM)?
12:38:53 <joelr1> dons: are you web-serving everything from haskell or using it in combination with a web server?
12:39:15 <scodil> alar: ok then isn't a list such a thing? why not make [] an instance of Res? then you just have one Vec instance, namely Res => Vec
12:40:02 <alar> yes, I can make [a] an instance of Res but
12:40:21 <alar> I'll get conflict between different instances of Res
12:40:42 <alar> just as I have conflist between different instances of Vec
12:41:06 <shapr> Is there anything like python's struct module that allows shorthand description of how to pull info out of a binary file?
12:41:39 <scodil> If it were me, I would get rid of the Res => Vec instance. So far you just have lists that are vectors. If you make another kind of vector later, you're going to want to write custom instances for those types, if nothing else for performance reasons
12:41:41 <dons> joelr1: ah, both.
12:41:50 <joelr1> dons: how do you decide?
12:42:13 <mrd> mightybyte: it uses Software Transactional Memory
12:42:21 <alar> yes, this is not bad solution
12:42:25 <dons> depends on the application. how much you have to store in memory, what you need to interact with to present content, how much the content has to be marked up. etc.
12:42:45 <alar> I'll only get minor code duplication that's tolerable
12:42:51 <joelr1> dons: interesting... and what about os kernels? anything other than hope?
12:43:15 <joelr1> dons: is there more info on the company work in this area?
12:43:33 <mightybyte> mrd: Yeah, I gathered that much.  But I'm not sure how that makes their behavior different.
12:43:50 <alar> I even can't make instances Fractional a=> Vec a a and Fractional a=> Vec [a] a
12:43:52 <dons> hope? hmm. wasn't that the blog framework bjorn wrote?
12:43:59 <alar> seems that fundeps are useless
12:44:00 <dons> oh, you mean hOp ? the research kernel
12:44:04 <mrd> mightybyte: well you probably won't notice in simple usage.  but it means you can combine it with other STM operations and combinators.
12:44:06 <dons> there are others, but I can't talk about them.
12:44:35 <mightybyte> mrd: Ahhh, but other than that is there any functional difference?
12:44:36 <mrd> mightybyte: for example:  readTChan ch1 `orElse` readTChan ch2 -- without STM, this becomes a lot harder
12:44:39 <joelr1> dons: i mean the mention of you using haskell for os kernels at the cufp (i think)
12:44:48 <shapr> joelr1: I've heard of hOp, an L4 kernel and one other kernel in Haskell.
12:45:21 <joelr1> shapr: ah, cool then. i thought it was only hope and didn't know galois worked on hOp
12:45:24 <mightybyte> mrd: Ok.  But if a single one were used in a vacuum there would be no difference?
12:45:56 <shapr> joelr1: I think Hope is bringert's webpublishing framework, I don't know of any other Haskell project by the name of Hope.
12:46:02 <dons> hope is a blog framework. hOp is a kernel.
12:46:07 <mrd> mightybyte: i'm not sure you get the same guarantees if you have multiple processors writing or reading from the same channel.  presumably you only get serializability with STM, but the normal Chans should be linearizable
12:46:14 <joelr1> shapr: mea culpa, house :) not hope
12:46:19 <shapr> Ah
12:46:20 <joelr1> hOuSe
12:46:29 <mightybyte> mrd: I was wondering if there were any difference along the lines of supporting concurrent reads vs. writes or something like that.
12:46:51 <mrd> mightybyte: well they support concurrent reads and writes, but it may be implemented with a lock
12:47:02 <mightybyte> mrd: Ok, and STM is lockless.
12:47:25 <mrd> well, it's No Deadlock at least.  I'm not sure if it's Lock free.
12:47:35 <joelr1> dons, shapr: i think i've been finally forced to use haskell by the requirements of a project i came up with
12:47:49 <shapr> What project is that?
12:47:54 <mightybyte> Ok, I think I've got the basic idea.
12:47:56 <mightybyte> Thanks.
12:48:00 <joelr1> that is i finally found an app that i can only (or best) do in haskell :)
12:48:02 <edsu> requirement 1. use haskell
12:48:10 <joelr1> shapr: it has to do with natural language processing and bots
12:48:19 <joelr1> shapr: bots that keep a dialog
12:49:00 <shapr> Sounds interesting.
12:49:12 <joelr1> brb
12:51:49 <Taejo> aargh, power failure brought our server down, and when it came back up, it was assigned a random IP by DHCP... so you can't access the SACO site, and I don't know its IP
12:52:39 <tetha> couldnt you just brute force that ip?
12:53:03 <Taejo> tetha: good idea, though it might upset IT services
12:53:56 <jonafan> i'm a total monad noob and frankly i don't know haskell at all.  I learned monads in ocaml.  I see how you can write imperative style code using them
12:54:03 <byorgey> Taejo: and once you get it working again, sounds like you need to get it a static IP =)
12:54:18 <joelr1> shapr: i looked at various ways to do the app and the grammatical framework turned out to be the cheapest and most effective way to go. the alternative being paying for prolog licenses or rolling my own stuff in lisp or erlang.
12:54:19 <tetha> Taejo: if they yell at you, you could tell them about the problem. if they dont.. you know how to get that ip, again :)
12:54:25 <joelr1> haskell ftw, finally!
12:54:42 <jonafan> but when i think about it, i don't understand the difference between a series of "let x = funcall y in" and a monad that models the same thing
12:55:02 <Taejo> byorgey: our IT services doesn't do static IPs (well, they claim DHCP always gives us the same one, but it doesn't)
12:55:13 <byorgey> Taejo: of course it doesn't.
12:55:39 <Taejo> byorgey: you can set up a DHCP server to do that. My home router does.
12:56:01 <mrd> yea we get our static IPs via DHCP
12:56:01 <byorgey> Taejo: oh, I didn't know that.
12:56:34 <sclv_> there's always dyndns
12:56:37 <byorgey> Taejo: well, if they won't do it for you, you could also use something like dyndns
12:56:50 * byorgey high-fives sclv_ 
12:56:52 <Taejo> we'll fix it eventually
12:57:11 <sclv_> I use it to ssh into my home box and haskell while at work.
12:57:36 <sebell> Ha, I use Haskell at work ;)
12:57:47 <pejo> jonafan, let x = f e in 7 wouldn't evaluate "f e" in Haskell.
12:57:51 * sclv_ sighs wistfully.
12:58:31 <Taejo> I've used SSH with *X-forwarding*, thanks to dyndns, just because our labs had the wrong version of Qt
12:58:32 <jonafan> nor in ocaml
12:58:54 <jonafan> oh i guess it probably would
12:59:05 <mrd> sebell: careful, you might get a flood of privmsgs asking where you work
12:59:08 <byorgey> jonafan, monads aren't really about imperative programming.
12:59:48 <jonafan> yeah, i get that, but they are a mechanism that allows it in haskell (among other things) right?
12:59:52 <faxathisia> doing Logic programming for example
12:59:55 <faxathisia> is a good exxample..
13:00:04 <faxathisia> (with monads)
13:00:13 <dons> woot, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Cabal-1.2.3.0
13:00:15 <lambdabot> http://tinyurl.com/2eey3b
13:00:24 <byorgey> jonafan: I just don't think that's a good way to think about them.  that's not their primary purpose or even their primary use.
13:00:34 <byorgey> jonafan: have you read any haskell monad tutorials?
13:00:42 <jonafan> no, sadly i'm still putting off haskell
13:01:02 <dons> ?users #xmonad
13:01:02 <lambdabot> Maximum users seen in #xmonad: 97, currently: 95 (97.9%), active: 5 (5.3%)
13:01:03 <jonafan> so a haskell monad tutorial wouldn't make much sense to me
13:01:09 <dons> 97. xmonad ftw!
13:01:17 <byorgey> dons: =D
13:01:21 <mrd> IO operations are presented through a monadic function interface
13:01:22 <dons> shapr: how's that, eh?
13:01:47 <byorgey> jonafan: ok, in that case, if I were you I wouldn't worry about monads yet =)
13:01:53 <jonafan> hehe
13:02:38 <jonafan> well, i'm still enjoying ocaml a lot so... haven't gotten around to learning haskell
13:03:06 <jonafan> but i saw an ocaml monad tutorial a while ago and thought it was interesting
13:04:04 <byorgey> jonafan: nothing wrong with that =)
13:04:37 <jonafan> yeah, from what i gather, haskell is much more monad friendly though, what with >>= and <-- and stuff
13:04:54 <dons> and do notation!
13:04:57 <jonafan> yeah
13:04:59 <byorgey> monads actually are pretty simple, it's just that they're so general that you have to read a lot before you get a good sense of all the places they can be used.
13:09:12 <shapr> dons: Can Data.Binary be used like python's struct library?
13:09:39 <dons> what does struct do?
13:10:32 <joelr1> shapr: what you want to do begs for a combinator approach
13:10:52 <shapr> jonafan: In my opinion, the best route to understanding monads is Functor -> Applicative -> Monad
13:11:06 <joelr1> shapr: imagine a combinator for extracting each field type. these could be combined into a struct combinator
13:11:19 <Nafai> shapr: Is there something already written that follows that pattern?
13:11:24 <Taejo> dons: since when is Oleg a type? I always thought of Oleg as a value of type Person, and "Polymorphic delimited continuations in Haskell" as a value of type Article
13:11:26 <joelr1> dons: it describes the layout of a record in a binary file
13:11:32 <shapr> dons: I want to read and write artist/title/etc fields for FLAC files.
13:11:35 <dons> Taejo: he is his own kind.
13:11:44 <Taejo> lol
13:11:45 <shapr> Taejo: forall a . Oleg a
13:11:51 <opqdonut> heh
13:11:57 <dons> joelr1: sure, that's what Data.Binary is for. you can parse and put structures in binary form.
13:12:01 <dons> the instance specifies the layout
13:12:33 * joelr1 wants pickler combinators on top of Data.Binary
13:12:46 <dons> pickler schmickler.
13:13:16 <joelr1> hehe
13:13:17 <mrd> good combinator
13:13:32 <joelr1> instance != pickler combinators
13:14:10 <dons> anyone tried out unicode ghci yet?
13:14:16 <mrd> you write your combinators in an instance method
13:14:21 <dons> i'd love to see someone's session with a literal lambda in the ghci prompt
13:14:41 <sebell> dons: Ooh.. I have to wait until I get home
13:15:19 <sorear> dons: nice try, lambda is a lowercase letter
13:15:35 <sorear> dons: so, sadly, it can't be used for \
13:15:36 <dons> its also a keyword
13:15:46 <dons> as is \forall
13:15:47 <Taejo> :t concatMap
13:15:50 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
13:15:59 <Taejo> @src (>>) []
13:15:59 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
13:16:12 <Taejo> @src [] (>>=)
13:16:12 <lambdabot> m >>= k     = foldr ((++) . k) [] m
13:16:32 <Taejo> @src concatMap
13:16:34 <lambdabot> concatMap f = foldr ((++) . f) []
13:16:44 <dons> sorear: oh, you might be right, actually
13:16:52 <dons>       ,("Ã¢~HÂ·",   ITdcolon, unicodeSyntaxEnabled)
13:16:52 <dons>        ,("Ã¢~G~R",   ITdarrow, unicodeSyntaxEnabled)
13:16:52 <dons>        ,("Ã¢~H~@",   ITforall, \i -> unicodeSyntaxEnabled i &&
13:16:52 <dons>                                 explicitForallEnabled i)
13:16:52 <dons>        ,("Ã¢~F~R",   ITrarrow, unicodeSyntaxEnabled)
13:16:55 <dons>        ,("Ã¢~F~P",   ITlarrow, unicodeSyntaxEnabled)
13:16:57 <dons>        ,("Ã¢~KÂ¯",   ITdotdot, unicodeSyntaxEnabled)
13:18:14 <Botje> How would I implement a parser that ignores comments in parsec?
13:18:16 <dons> still, seems like an easy enough patch to make it a keyword. what was the issue with that?
13:18:41 <Botje> currently I've got parser = many1 (spaces >> comment <|> statement)
13:19:07 <Taejo> anybody want to do a Haskell song? "Oleg is in the house/Scream and shout"
13:19:18 <Botje> hmmm
13:19:22 <Botje> wait, i'm being silly
13:19:28 <Botje> I can just use Maybe.
13:19:30 <dons> tra la la, laughing out loud
13:19:48 <shapr> Taejo: We should get MC Frontalot to do one.
13:19:56 <shapr> Cale could write the lyrics.
13:20:15 <lucca> grue-some
13:20:59 <shapr> hah
13:21:06 <shteou> Maybe and Baby spring to mind, Taejo.
13:25:36 <shapr> dons: For self teaching I'm trying to make an instance of Binary for 'newtype Fortune = Fortune String' so Data.Binary can read from fortune/cookie-jar files. Is there some way to consume everything up to and including "\n%\n" but no further?
13:26:20 <shapr> Doesn't xerox' ParsecT work on bytestrings?
13:26:25 <dons> the get instance for Fortune String will have to do a get while or something.
13:26:31 <dons> you might just want to use readp-bytestring
13:27:33 * shapr tries that
13:27:46 <ari> @instances Functor
13:27:47 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
13:27:49 <ari> @instances Monad
13:27:50 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
13:30:19 <Taejo> lol, my girlfriend saw Oleg's delimited continuation article earlier... she laughed at me
13:30:25 <shapr> Why did she laugh?
13:30:48 <faxathisia> She obviously eats monad transformers for breakfast
13:31:22 <Taejo> she laughs that I understand the long words that mean nothing to anybody outside of elite squad known as the special programming unit
13:31:45 <mrd> she keeps a pet catamorphism
13:32:20 <faxathisia> hehehe
13:32:54 <scodil> my wife saw me in this channel once, caught a glimpse of "lambdabot" and now she always makes fun of my by says "labjot and prabdot"
13:33:01 <scodil> by saying
13:33:05 <Sizur> http://haskell.org/ghc/docs/latest/html/libraries/template-haskell-2.2.0.0/Language-Haskell-TH.html
13:33:06 <lambdabot> http://tinyurl.com/37umuh
13:33:22 <Sizur> why is it not found?
13:33:30 <faxathisia> lol
13:33:34 <faxathisia> What's "labjot and prabdot"?
13:33:43 <faxathisia> ahh
13:33:57 <scodil> gibberish, as is lambdabot
13:34:36 <glguy> lambda-bot
13:35:43 <vininim> Î»bot
13:36:04 <shapr> Pseudonym wrote the original code for lambdabot, and chose the name.
13:36:14 <shapr> I wonder how long ago that was...?
13:37:45 <Sizur> what's up with ghc docs?
13:38:48 <TSC> http://haskell.org/ghc/docs/6.8.1/html/libraries/template-haskell-2.2.0.0/Language-Haskell-TH.html
13:38:48 <lambdabot> http://tinyurl.com/34x9vu
13:38:56 <TSC> Change "latest" to "6.8.1"
13:39:03 <TSC> The new release has probably buggered it up
13:40:36 <Sizur> TSC: thanks
13:41:48 * byorgey loves the copious output from a ghc build
13:41:55 <byorgey> makes me feel all hard-core =)
13:42:08 <pippijn> byorgey: error messages?
13:42:17 <opqdonut> huh, mine make no noise at all :)
13:42:19 <sebell> byorgey: Try building SBCL, tremendously copious (and fast) output
13:42:19 <byorgey> pippijn: no, just normal compilation stuff
13:42:23 <pippijn> huh
13:42:29 <pippijn> mine neither
13:42:56 <byorgey> really? you download the ghc sources, type './configure ; make' and it doesn't produce any output?
13:43:26 <pippijn> ah that
13:43:39 <pippijn> I thought ghc compiling your own sources
13:43:48 <byorgey> oh, heh, no =)
13:43:53 <byorgey> ghc compiling itself =)
13:53:51 <byorgey> ?users
13:53:51 <lambdabot> Maximum users seen in #haskell: 432, currently: 425 (98.4%), active: 17 (4.0%)
13:53:58 <byorgey> o.O
13:54:11 <dons> pretty good
13:57:33 <joelr1> dons: i have a plan
13:59:15 <joelr1> dons: i need to dig deep into erlang's mnesia (real-time distributed db) and the underlying disk storage scheme for the book. i think once i figure out the mnesia locking and replication protocol the same approach could be tried in haskell
13:59:49 <oerjan> hamnesia
13:59:49 <shapr> Is 432 the high water mark so far?
13:59:53 <oerjan> ;)
13:59:57 <earthy> !hpaste
13:59:58 <shapr> oerjan: Forget about pigs?
14:00:01 <augustss> joelr1: hmmmm, I've heard rather unflattering things about mnesia
14:00:06 <oerjan> shapr: what?
14:00:10 <joelr1> augustss: tell me more
14:00:11 <shapr> Exactly!
14:00:14 <oerjan> oh
14:00:17 <joelr1> augustss: please
14:00:23 <dons> shapr: 436 is the high mark
14:00:26 <shapr> Spiffy
14:00:48 <augustss> joelr1: from people who are actually using it.  it's not exactly bug free.  it was terrible when it was new, i guess it's better now
14:00:52 <hpaste>  Earthy pasted "Schweet haskell function..." at http://hpaste.org/4415
14:01:13 <earthy> that's the reason I *love* haskell
14:01:13 <joelr1> augustss: i have a suspicion that you didn't hear that in the last few years :D
14:01:14 <augustss> I think it's very hard to do what mnesia is trying to do
14:01:29 <joelr1> augustss: i agree with you re: hard to do but is it impossible in haskell?
14:01:30 <augustss> joelr1: last time was about 5 months ago
14:01:45 <Taejo> how do I put conditionals in a QuickCheck property? Like, if (xs == nub xs) then (sxs == nub sxs) where sxs = sort xs?
14:02:05 <augustss> joelr1: why would it be impossible in Haskell?
14:02:13 <augustss> if it's at all possible
14:02:22 <joelr1> augustss: the only trouble from my perspective is that each table would only be able to store a fixed and pre-defined structure. and changing the structure or format of the haskell-mnesia-table would require copying data to a new table, or something like that.
14:02:36 <joelr1> augustss: i'm betting that it's possible
14:02:40 <mauke> @check \x -> even x ==> not (odd x) :: Int -> Bool
14:02:41 <lambdabot>  Couldn't match expected type `Int -> Bool'
14:02:58 <mauke> @check \x -> even x ==> not (odd (x :: Int))
14:02:59 <lambdabot>  OK, passed 500 tests.
14:03:36 <augustss> joelr1: changing what is stored should be that difficult in Haskell compared to any other language
14:03:47 <augustss> s/difficult/different/
14:03:59 <joelr1> augustss: you mean should NOT be different?
14:04:08 <augustss> yes, NOT
14:04:11 <joelr1> augustss: or do you mean should be due to static typing
14:04:14 <joelr1> augustss: ah, ok
14:04:14 <augustss> bah.  can't type tonite
14:04:58 <augustss> I think static typing is the smaller problem when making a fault tolerant distributed data base
14:05:36 <nolrai> @ty msum
14:05:38 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
14:06:15 <joelr1> augustss: so you agree that it should be possible, right? i think a well-defined serialization protocol would simplify things
14:06:28 <joelr1> augustss: some sort of a haskell rpc mechanism
14:06:28 <augustss> sounds possible
14:08:14 <joelr1> augustss: i want that functionality nowadays (distribution, fault-tolerance, replication). for writing bots that understand natural language. in haskell .
14:08:33 <joelr1> augustss: bots that can keep a dialog
14:08:33 <faxathisia> natural language... haha
14:08:49 <augustss> good luck with that!
14:08:50 <joelr1> faxathisia: yeah, i figured out how to do it in haskell. no prolog necessary.
14:09:03 <faxathisia> It's not possible in Haskell or Prolog...
14:09:14 <Taejo> @instances MonadPlus
14:09:14 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
14:09:31 <joelr1> augustss: i'm not shooting for pie in the sky at all. each task the bot will perform will be backed by a grammar.
14:09:32 <Taejo> @instance MonadPlus Either
14:09:33 <lambdabot> Maybe you meant: instances instances-importing
14:09:41 <joelr1> faxathisia: http://gf.digitalgrammars.com
14:09:43 <lambdabot> Title: GF Version 2.8
14:09:45 <earthy> faxathisia: it is, for e.g. simplified english
14:09:45 <Taejo> @src Either mplus
14:09:45 <lambdabot> Left _ `mplus` n = n
14:09:45 <lambdabot> m      `mplus` _ = m
14:09:53 <augustss> joelr1: you'll be the first to succeed
14:10:05 <Taejo> @src Maybe mplus
14:10:05 <lambdabot> Nothing `mplus` ys  = ys
14:10:05 <lambdabot> xs      `mplus` _ys = xs
14:10:29 <joelr1> augustss: oh, c'mon lennart! this has been done over and over again. with speech even. for in-car entertainment systems, for example.
14:10:45 <joelr1> augustss: this is the site: http://www.talk-project.org/
14:10:48 <lambdabot> Title: TALK: Home
14:10:57 <joelr1> bringert: faxathisia and augustss are putting down your work here ;-)
14:10:57 <sioraiocht> is wolfram mathworld an acceptable scholarly resource?
14:11:00 <augustss> I would not call that a dialog
14:11:04 * joelr1 ducks
14:11:21 <dcoutts> hia bringert
14:11:29 <faxathisia> sioraiocht: I would say so
14:11:38 <dcoutts> bringert: I had a Q about some cabal-install code if you have a moment
14:11:39 <faxathisia> I've never seen any mistakes on it
14:11:57 <sioraiocht> faxathisia: i agree, thanks :)
14:11:57 <dcoutts> bringert: I'm trying to understand the purpose of something and whether we need to keep it
14:11:59 <augustss> joelr1: but if that's what you're aiming for, then ok :)
14:12:00 <joelr1> augustss: well, it is :) maybe not exactly the in-car entertainment example but certainly a travel agent one, or one that can give directions
14:12:37 <segfaux> Any emacs users want to help me out? inf-haskell.el can only find hugs or ghci when I run it from a windowless emacs instance, not from the GUI.
14:13:02 <augustss> joelr1: ok, for very limited domains it's been done
14:13:03 <joelr1> augustss: a travel agent bot is a quintessential example of a dialog. you can supply where you want to go, where from, when, what class, how, etc. you can supply the info in any order and the bot will ask for any missing info.
14:13:07 <joelr1> augustss: there, see
14:13:36 <Nafai> joelr1: This sounds like a fun problem!
14:13:44 <joelr1> augustss: each limited domain will have its own grammar but if you keep stringing these grammars together you can significantly expand the doamin!
14:13:44 <faxathisia> There's nothing better about trying to talk to a robot with "natural language" than filling in a form is there?
14:14:11 <joelr1> faxathisia: not sure i get your point
14:14:15 <augustss> faxathisia: you can do it on a phone
14:14:40 <SamB_XP> faxathisia: well, as long as the robot fills in the form and not you
14:15:09 <Philippa> augustss: I tend to see that as a source of parsing errors
14:15:15 <faxathisia> I would like to understand the motivation for the kind of NLP you are talking about here
14:15:17 * joelr1 thinks bringert's grammar and NLP work totally rocks
14:15:40 <faxathisia> joelr1: I'm not disputing that the code is good and useful
14:15:42 <augustss> Philippa: so is talking to a call center in India :)
14:15:50 <Philippa> augustss: Don't I know it...
14:15:50 <faxathisia> but you're intened use makes absolutely no sense to me.. :S
14:16:01 <joelr1> faxathisia: simple. i want a secretary bot of sorts. a bot that can keep my calendar, take messages for me, remind me or stuff, monitor ebay auctions, track stocks, etc. etc. etc.
14:16:30 <faxathisia> yes.. I can't understand why is that better than just having some useful programs
14:16:31 <augustss> and I'd like my own jet plane
14:16:35 <Philippa> I still need to file a complaint with Virgin Media about their idiot staff trying to tell me I had no ethernet drivers
14:16:43 <SamB_XP> sioraiocht: is wolfram research a respectable scholarly organization?
14:16:48 <Nafai> joelr1: Is this a "for fun" project or something else?
14:16:53 <Philippa> (that is, once they'd made it clear they didn't mean "internet drivers", which was about the level they'd been handling things at)
14:16:55 <joelr1> faxathisia: now, my wife is a travel agent. she spends a lot of time on IM answering questions, booking reservations, etc. a travel agent bot would be a big help for her
14:17:20 <joelr1> Nafai: i hope to make some money but this is ultimately what i'll be using myself
14:17:22 <faxathisia> joelr1: Would a robot be more or less helpful than an application
14:17:22 <SamB_XP> joelr1: how?
14:17:30 <faxathisia> joelr1: one which does exactly what you specify...
14:17:34 <joelr1> actively using
14:17:39 <faxathisia> (as opposed to guessing at your imprecise communication)
14:17:54 <joelr1> faxathisia: this is a bot that sits on IM
14:18:09 <faxathisia> I don't think you're understanding my question, so I'll just give up now
14:18:18 <joelr1> faxathisia: and flexibility in giving information beats the rigidity of a form
14:18:19 <augustss> @book LCY-GOT
14:18:19 <lambdabot> Unknown command, try @list
14:18:27 <joelr1> SamB_XP: how what?
14:18:33 <augustss> bah, lambdabot needs updating
14:18:36 <sioraiocht> SamB_XP: well, they produce mathmatica...
14:18:52 <joelr1> faxathisia: you are advocating supplying apps instead of bots, correct?
14:18:56 <SamB_XP> sioraiocht: 'twas a rhetorical question, yes
14:19:11 <faxathisia> I'm not advocating anything, I wanted to understand your motivation but I cannot get through to you so I'm giving up
14:19:18 <SamB_XP> joelr1: how would it be a big help to your wife?
14:19:33 <SamB_XP> personally
14:19:43 <joelr1> faxathisia: well... my motivation is simple. _I_ find it useful and want it.
14:19:44 <SamB_XP> I can't help but see it frustrating her clients...
14:20:24 <faxathisia> (that's not really what I was asking and you haven't written it yet)
14:20:49 <joelr1> SamB_XP: maybe but maybe not. people keep asking for the same kind of information and go through the same type of a process. where? what hotel? how to fly? a bot could let them look for a hotel (display variations, search for similar accomodation nearby, etc)
14:21:18 <joelr1> faxathisia: may i suggest rephrasing your question then?
14:21:35 <faxathisia> I did about 5 times
14:21:51 <davidL> aren't there websites for that?
14:21:56 <glguy> hmm, panties in bunches
14:22:05 <SamB_XP> I would personally expect the bot to start demanding to keep it's commisions around the point where it got actually usefull...
14:22:06 <joelr1> i can't figure out how else i can explain my motivation. i want it because i find it useful to _me_
14:22:51 <Philippa> joelr1: I think several people're essentially saying that they find tools where there's either something fuzzy or an unclear syntax being used a PITA to use
14:23:03 <joelr1> davidL: sure there are. but with a web site you need to figure out a rigid but user-friedly workflow. guide the user through a series of choices, etc. but what if they want to change a choice they made a few steps back? more complexity. a natural language interface simplifies all that
14:23:11 <Philippa> I'm in that category FWIW, though it's ameliorated if I'm given an efficient means of saying "no, I meant /that/"
14:23:36 <SamB_XP> joelr1: I'm not sure how a natural-language interface simplifies that
14:23:50 <SamB_XP> I find that this sort of thing can get confusing in natural language...
14:23:52 <joelr1> Philippa: yes, with means to undo or backtrack or change bits of info you previously supplied
14:24:04 <Philippa> joelr1: that's not useful if you're just being misparsed
14:24:12 <joelr1> where's my example...
14:24:15 <Philippa> or at least, it's not sufficiently useful
14:24:22 <joelr1> Philippa: you won't be misparsed because there's a grammar behind
14:24:29 <Philippa> ...and I know this grammar?
14:24:43 <joelr1> http://www.cs.chalmers.se/~bringert/xv/pizza/
14:24:43 <lambdabot> Title: Pizza Demo - GF XHTML+Voice - Description
14:24:46 <Philippa> ...and as a typical user, I know how to understand that?
14:24:49 <joelr1> is a good example
14:24:49 * SamB_XP gets misparsed in english all the time
14:25:35 <joelr1> Philippa: i'll have to find a way to guide you. suggest what you can ask about, for example
14:26:26 <faxathisia> Projects promoting programming in "natural language" are intrinsically doomed to fail.
14:26:33 <faxathisia> -- Dijkstra
14:26:45 <SamB_XP> faxathisia: at least this one isn't advocating programming in natural language
14:26:54 <joelr1> :D
14:26:54 <faxathisia> close enough
14:27:03 <SamB_XP> worlds apart
14:27:20 * faxathisia hates the distinction between computer users and computer programmers
14:27:38 <SamB_XP> you have a point there
14:27:41 <Philippa> SamB_XP: we're talking about queries though, that's starting to get into the same ballpark
14:27:47 <Pseudonym> It's the distinction between mechanics and drivers.
14:27:55 <alar>  YES! I've found it!
14:27:55 <Pseudonym> In 1912, there was no distinction.
14:27:58 <dons> drivers, mechanics and engineers
14:28:09 <faxathisia> but computers are different..
14:28:14 <faxathisia> You can't run a car on haskell!
14:28:30 <dons> sure you can. let me find the photo..
14:28:36 * bringert appears to show up in the middle of a discussion about his work
14:28:37 <SamB_XP> you could use Haskell to write the program
14:28:42 <byorgey> dons: http://i4.tinypic.com/6st6frd.png  =)
14:28:48 <joelr1> bringert: yes!
14:28:55 <byorgey> the lambdas look a little wonky in my font, but...
14:28:58 <joelr1> bringert: maybe you can articulat it better :D
14:29:04 <Philippa> bringert: the pizza example seems a lot saner than what joelr1's proposing, FWIW
14:29:06 <faxathisia> bringert: It's not your work we're talking about
14:29:17 <joelr1> Philippa: i'm proposing an expanded pizza example
14:29:24 <bringert> I agree that trying to make programming languages "natural" is stupid
14:29:26 <SamB_XP> joelr1: with extra cheeze?
14:29:32 <joelr1> bringert: it's not about programming
14:29:36 <bringert> the opposite however...
14:29:43 <earthy> russian haskell.
14:29:47 <earthy> wow. :)
14:29:50 <SamB_XP> bringert: hmm?
14:29:54 <Philippa> joelr1: sure. I'm proposing an extension of the simply-typed lambda calculus, that doesn't mean it works though
14:29:55 <dons> this guy, at one point, had a haskell-controlled acceleration and breaking, http://www.sunswift.com/Gallery/Sunswift3/Gallery_UNSWSunswiftIIIWSC05.jpg
14:29:57 <lambdabot> http://tinyurl.com/yos5d6
14:29:59 <dibblego> can o'caml define a type argument over a type argument?
14:30:03 <joelr1> bringert: augustss and faxathisia don't think that bots can talk natural language or that it would be useful!
14:30:12 <faxathisia> dons, that thing is cool!
14:30:15 <bringert> joelr1: right, I'm working my way backwards through the dialog
14:30:25 <joelr1> hehehe
14:30:26 <faxathisia> joelr1: No , I didn't say anything like that
14:30:29 * joelr1 is stiring up the pot
14:30:32 <joelr1> stirring
14:30:46 <earthy> dons: and he lost the challenge. :)
14:30:52 <faxathisia> joelr1: Please don't lie... like that
14:31:03 <augustss> And I didn't say that either.
14:31:09 <joelr1> allright, allright
14:31:23 * alar feels jealous to that southern driver
14:31:36 <SamB_XP> faxathisia: how do you want him to lie?
14:31:50 <Philippa> SamB_XP: straight down in front of a moving vehicle?
14:31:52 <joelr1> bringert: i think i'll have the complete picture once you and aarne answer my last three emails
14:32:21 <Philippa> wait, I actually hit enter, didn't I. Oops.
14:32:29 <faxathisia> lol
14:32:43 <bringert> joelr1: it depends on what you mean by "natural" language. We are a really long way from writing software that can handle the full range of human communication. But, it is possible to write programs that can communicate in a well-bahved fragment of natural language for a limited domain.
14:33:06 <joelr1> bringert: that's what augustss said. about the limited domain.
14:33:08 <SamB_XP> Philippa: why type these things if you aren't planning to hit enter?
14:33:09 <joelr1> right lennart?
14:33:22 <Philippa> yeah. Your example pretty much did lists with a little flexibility in the values, no?
14:33:38 <joelr1> bringert: my thesis is that your domain will no longer be limited if you string enough grammars together
14:33:45 <Philippa> SamB_XP: by analogy with "oh, wait, did I say that out loud?"
14:34:00 * faxathisia realizes what's going on now... haha
14:34:07 <faxathisia> he is doing a thesis on NLP and needs ideas
14:34:20 * joelr1 is a college dropout
14:34:41 <joelr1> 1 semester here and 1 more there. both 1st semesters so they count as 1.
14:34:45 <Philippa> joelr1: there be dragons. With laser-propelled ninjas strapped to their foreheads.
14:34:46 <SamB_XP> what was your major?
14:34:57 <augustss> joelr1: I suspect that as you string grammars together the error rate will go up
14:35:06 <glen_quagmire> my major is not math
14:35:09 <Philippa> as will the telephone destruction rate
14:35:18 <BMeph> faxathisia: There's a project for you: make a distributed fault tolerant real-time database in Haskell. Then get hpaste, hackage and darcs to use it. ;)
14:35:19 <Philippa> sorry, "customer dissatisfaction"
14:35:19 <bringert> SamB_XP: I meant that it could be useful to restrict human language for human-machine communication. talking machines are more usable if the user knows what he can and cannot say. which means that there have to be well-defined restrictions, like in programming languages.
14:35:24 <joelr1> majors don't quite apply during the 1st semester but it was electrical power systems and networks the first time (didn't have a choice) and cs the second time
14:35:39 <faxathisia> BMeph: Isn't something like SQL a possiblity, and haskell could just talk to that?
14:35:50 <joelr1> augustss: not necessarily. i haven't figured this out but you can just apply grammars sequentially until you get a parse.
14:35:50 <Philippa> bringert: Natural like COBOL, then
14:35:55 <SamB_XP> joelr1: that's a really strange sounding major
14:36:06 <Philippa> joelr1: the problem isn't finding a parse...
14:36:14 <Philippa> you'll get lots of them
14:36:29 <bringert> joelr1: well, no finite number of finite grammars will cover the full range of things people talk about, if you want to use the parse results for anything
14:36:33 <joelr1> Philippa: hmm... true...
14:36:38 <augustss> with varying probabilities of the parse being correct
14:36:41 <joelr1> SamB_XP: i know. that was in russia.
14:36:47 <bringert> a grammar covering everything is easy. sentence ::= word*
14:37:02 <faxathisia> #ai ?
14:37:03 <SamB_XP> joelr1: were the networks computer networks or power networks?
14:37:06 <joelr1> SamB_XP: actually, i think the major is electrical engineering. the weird thing is the specialization
14:37:11 <bringert> Philippa: heh, yeah, but hopefully allowing a bit more variation
14:37:12 <SamB_XP> oh.
14:37:22 * SamB_XP is actually majoring in EE
14:37:28 <Philippa> bringert: COBOL with algebraic datatypes, then :-)
14:37:32 <augustss> EE rulez!
14:37:34 <faxathisia> BMeph: cheers though, It's a good idea but not something I think I would do well
14:37:41 <joelr1> bringert: i don't want people to talk about everything. i want to keep a calendar, search social networks, monitor ebay auctions or stocks, etc.
14:37:41 <SamB_XP> I don't much like freshman years
14:37:59 <bringert> joelr1: right, so it's multiple limited domains
14:38:21 <joelr1> SamB_XP: electrical power networks. the huge things that carry wires. from substation to substation. the idea is to study electricity loss and things like that
14:38:45 <joelr1> bringert: right. if you string together enough grammars for limited domains you should get a pretty expanded domain.
14:38:49 <bringert> joelr1: that's still fairly limited compared to human communication. but a limited domain doesn't have to be a bad thing, as long as the user nows what he can do
14:38:57 <SamB_XP> at my school there are two tracks for EE students: the traditional track and the computer track
14:39:04 * alar is actually working on program that calculates power losses and distribution topology
14:39:06 <joelr1> bringert: oh, i fully agree with you or i won't be getting myself into this
14:39:23 <Pseudonym> Soemthing like 50% of the energy generated at the power station is dissipated by the grid, isn't it?
14:39:27 <Pseudonym> Before it gets to your house.
14:39:29 <bringert> joelr1: well, at some point you start getting enough overlap that you could get problems. especially if there's speech recognition involved
14:39:44 <SamB_XP> Pseudonym: why is it all trying to go to my house?
14:40:00 <augustss> SamB_XP: to get the cheese
14:40:03 <Pseudonym> You mean you don't have an aluminium smelter in your house?
14:40:05 <SamB_XP> oh noes!
14:40:10 <joelr1> bringert: i don't want to get into speech recognition. i have no idea how much nuance costs, for example. i'm focusing on instant messaging and web
14:40:13 * SamB_XP goes to eat it before the power gets here
14:40:29 <joelr1> SamB_XP: may the power be with you!
14:40:41 <bringert> joelr1: yeah, I think it's a very good idea to stay away from speech recognition.
14:40:57 <Philippa> it does rather accentuate the difficulties
14:41:15 * SamB_XP wonders if Philippa is punning   
14:41:23 <Philippa> and that's before you get someone who's just an unclear speaker like me
14:41:34 <Philippa> SamB_XP: would I do a thing like that?
14:41:43 <joelr1> bringert: i looked hard at trindikit and godis but haskell turns out to be the more straightforward path, specially now that i groked how gfedit does refining
14:42:07 <SamB_XP> hmm, someone should fill in the citations on this article... http://en.wikipedia.org/wiki/Turing_tarpit
14:42:08 <lambdabot> Title: Turing tarpit - Wikipedia, the free encyclopedia
14:43:26 * bos kicks off a ghc 6.8.2 build for fedora
14:44:42 <augustss> bos: how's that book coming along?
14:45:21 <bos> augustss: lots of writing done, lots to go.
14:45:41 <augustss> I've not seen any chapters to whine about in a while ;)
14:45:46 <bos> tonight, i start on the "all about monads" chapter, which i'm not looking forward to.
14:45:51 <bos> yes, i need to push some out!
14:46:13 <joelr1> bos: a fellow writer?
14:46:34 <bos> joelr1: yes, writing a book for o'reilly
14:48:03 <joelr1> bos: cool! prag progs here. o'reilly got in touch but then never got back to me
14:48:36 <bos> yeah, one far-out language at a time, i guess.
14:50:14 <joelr1> dons: what happened to the guy who had breaks and acceleration controlled by haskell? did he switch away in the end?
14:52:45 <SamB_XP> joelr1: oh, he died in a crash
14:53:24 <dmwit> punalicious
14:54:12 <oerjan> O_O
14:55:23 * SamB_XP hopes everyone realizes he's kidding
14:57:58 <oerjan> killed by a haskell space leak!
14:59:24 <dons> oh, it was a research project running nhc on an embedded arm device in the car
14:59:27 <dons> seemed to work.
14:59:31 <dons> i'm not sure if they still use it.
14:59:48 <joelr1> dons: why nhc?
14:59:58 <dons> embedded device
15:00:00 <Philippa> joelr1: good space performance
15:00:12 <dons> so you want small footprints, heap compression and so on
15:00:14 * joelr1 files away a note. nhc for embedded devices.
15:01:12 <joelr1> is this it? http://www.cs.chalmers.se/~rojemo/nhc.html
15:01:12 <lambdabot> Title: NHC - Nearly a Haskell Compiler
15:01:16 <joelr1> or is it nhc98?
15:01:24 <dons> nope. nhc98.
15:01:27 <joelr1> http://www.haskell.org/nhc98/
15:01:28 <lambdabot> Title: nhc98
15:01:32 <joelr1> ah, ok then
15:02:09 <joelr1> who is behind nhc98?
15:02:29 <joelr1> i wonder if its actively developed
15:02:47 <joelr1> aha, york
15:03:08 <dons> note the last release was Nov 22..
15:03:56 <joelr1> cool
15:06:22 <joelr1> i want haskell on arm devices
15:06:27 <joelr1> right after i'm done with bots
15:06:29 <joelr1> of course
15:06:41 <Philippa> you can get it running easily enough
15:06:59 <Philippa> it's a registerised GHC and GHCi and so forth that's hard
15:08:27 <joelr1> registered as in one that uses registers?
15:08:51 <Philippa> yeah
15:09:04 <Philippa> and doesn't have to trampoline for TCO
15:13:49 <wy> Hi, I want to try xmonads. I'm not sure which version to get. Is the darcs one better than the stable ones?
15:14:05 <dmwit> Hiya, wy.
15:14:29 <bos> wy: try asking in #xmonad
15:14:33 <dmwit> I think darcs xmonad is usually just as stable as the stable ones.
15:14:42 <dmwit> But yes, as bos says, make sure to visit #xmonad. =)
15:15:36 <dons> wy, use xmonad 0.5, the stable release
15:16:40 <wy> dmwit, hi
15:17:13 <wy> dons, how is it? I'm considering switch to such a WM. It's quite different. But maybe it's the way gurus work ;-)
15:17:14 <alar> what is xmonad?
15:17:32 <SamB_XP> alar: ion's replacement
15:17:43 <allbery_b> heh
15:17:47 <dons> i think its very nice. the developers are super friendly too
15:17:58 <jonafan> hah
15:18:06 <Nafai> dons: You'd think that, wouldn't you?
15:18:11 <dons> allbery_b: http://xmonad.org -- your 1 stop monadic window manager superstore
15:18:12 <lambdabot> Title: xmonad : a tiling window manager
15:18:31 <alar> monadic window manager! sounds nice
15:18:33 * allbery_b thinks dons miscompleted
15:18:39 <dons> i did. too many nicks
15:18:40 <ddarius> Aren't all xmonads since like version 0.3 supposed to be perfectly stable?
15:18:52 <wy> Isn't it on Ubuntu yet? Can apt-get it?
15:18:54 <SamB_XP> ddarius: perhaps it's the Debian sense
15:19:10 <dons> ddarius: yeah, not perfectly, but there's typically only 1 or 2 bugs found a month
15:19:35 <dons> and usually fairly obscure, as people try stranger and stranger clients
15:19:39 <dmwit> xmonad very rarely surprises me
15:19:42 <dmwit> That's why I like it.
15:19:46 <wy> How does it compare with sawfish?
15:20:03 <wy> I've used FVWM, sawfish before
15:20:05 <ddarius> Is that in the core or including the contributions?
15:20:19 <dons> oh, not including contributions, they've got less assurance
15:20:32 <dmwit> wy: Have you used dwm or wmii before?  It's very similar to those.
15:20:34 <Botje> how do I convert a Data.ByteString.Lazy to [Char] ?
15:20:45 <wy> I tried wmii once.
15:20:45 <Botje> unpack turns it into [Word8], where do I go from there?
15:20:50 <SamB_XP> oh, was it dwm that it as the replacement of?
15:20:56 <dcoutts> @hoogle Data.ByteString.Lazy -> [Char]
15:21:00 <lambdabot> No matches, try a more general search
15:21:01 <ddarius> SamB_XP: Yes and no.
15:21:02 <dmwit> SamB_XP: I think it was based on dwm, yes.
15:21:03 <sjanssen> SamB_XP: yes
15:21:05 <dcoutts> @hoogle Data.ByteString.Lazy.ByteString -> [Char]
15:21:06 <lambdabot> No matches, try a more general search
15:21:09 <sorear> Botje: utf8-string
15:21:11 <dcoutts> @hoogle ByteString -> [Char]
15:21:12 <lambdabot> Data.ByteString.Char8.unpack :: ByteString -> [Char]
15:21:12 <lambdabot> Data.ByteString.Lazy.Char8.unpack :: ByteString -> [Char]
15:21:14 <allbery_b> ideological descendant of dwm
15:21:17 <sorear> Botje: assuming you mean ByteString and Char
15:21:21 * SamB_XP wonders why nobody corrected him before...
15:21:25 <dcoutts> hoogle doesn't like module names it seems
15:21:25 <wy> After I install it, what's the best way to put it to default to start with Ubuntu?
15:21:29 <Botje> sorear: yes, i do.
15:21:38 <sorear> Botje: char is CHARACTERS, ByteString is BYTES, so you have to convert them using some encoding
15:21:46 <ddarius> SamB_XP: Because "ion's replacement" is a reasonable description as well.
15:21:50 <SamB_XP> oh.
15:21:54 <SamB_XP> okay
15:21:55 * allbery_b was mostly amused, due to the current ion bikeshedding on freebsd-ports
15:22:03 <dcoutts> Botje: unpack assumes ASCII/latin1 encoding
15:22:03 <ddarius> I was interested in xmonad because I had used ion a long time ago and really enjoyed it.
15:22:05 <dmwit> wy: I think there's some instructions for different distros on xmonad.org
15:22:10 <Botje> sorear: well, it's binary data.
15:22:18 <SamB_XP> does xmonad come in red?
15:22:25 <sorear> Botje: then what are you putting it in Char for?
15:22:28 <ddarius> SamB_XP: Yes!
15:22:37 <dcoutts> Botje: if you want utf8 or something else then yes you need the utf8-string package or something else
15:22:40 <sorear> Botje: [Word8] is the correct type for lazy lists of bytes
15:22:53 <Botje> hmmm
15:23:52 <Botje> maybe it's fixable without using bytestrings
15:23:52 <dmwit> wy: Well, I can't see the instructions I'm thinking of now, but ask again in #xmonad and they'll guide you through the process.
15:24:08 <wy> dmwit, Thanks
15:24:21 <ddarius> wy: I just added/changed my .Xsession
15:24:22 <sorear> Botje: why do you need to put binary data in a Char?
15:24:49 <Botje> I'm using show to print it to a http client :)
15:25:14 <sjanssen> SamB_XP: red is the default, in fact (for all that matters)
15:25:29 <Botje> which i'm now realizing is a Bad Idea(tm)
15:25:29 * ddarius actually has the borderwidth set to 0.
15:25:34 <sorear> Botje: just show the bytestring
15:26:18 <dcoutts> Botje: you can write a bytestring to a network handle directly without going via lists
15:26:32 <ddarius> You'd hope!
15:26:39 <Botje> blah
15:26:47 <Botje> probably can't get it fixed in a reasonable time
15:26:51 <Botje> need to finish slides first
15:29:02 <Botje> http://wilma.vub.ac.be/~dharnie/shttpd.hs
15:29:08 <Botje> It's a smallish webserver
15:29:31 <Botje> problem is, I just found out the thing isn't lazy enough
15:29:49 <Botje> the show $ length body is a major culprit in this, but there's another somewhere.
15:29:57 <Heffalump> Botje: you mean it sends data to users that they aren't actually reading?
15:30:08 <Botje> :)
15:30:15 <Heffalump> it should wait until their eyes focus on the relevant part of the screen
15:30:17 <Botje> no, it loads the entire file in memory
15:30:42 <wy> What's the ubuntu package for Cabal or is it included already?
15:30:54 <dmwit> It should be included in GHC.
15:34:02 <Botje> ah
15:34:03 <Botje> there we go
15:34:11 <Botje> passing an extra length parameter around should speed things up
15:34:37 <Botje> not really :[
15:37:36 <Botje> C++ is outperforming haskell by 100 req/s
15:37:54 <Botje> oh well. I'll just mention bytestrings then
15:42:21 <dons> Botje: doing what? String IO??
15:42:38 <Botje> yes
15:42:47 <dons> use bytestrings, ala happs' web server, and beat apache
15:42:51 <Botje> yes
15:42:59 <Botje> but I have to present these slides in ten hours :)
15:43:09 <Botje> i'll finish the slides first, then ahck some more
15:43:46 <dons> did you see the happs graphs recently?
15:43:51 <dons> versus ruby, erlyweb, fastcgi?
15:43:57 <Botje> not yet
15:44:09 <Botje> didn't see them pass by in my RSS reader, which is my main source of haskell news
15:47:46 <thoughtpolice> dons: link?
15:49:19 <bench> does someone has a good example of how parsec permute works?
15:49:25 <thoughtpolice> i've wanted to get into happs but i can't find any good resources.
15:49:29 * thoughtpolice goes to the hpaste source
15:49:31 <dons> http://blog.davber.com/2007/12/10/web-server-performance-shoot-out-simple-pages/
15:49:33 <lambdabot> Title: davber does IT » Web server performance shoot out - simple pages, http://tinyurl.com/3do7dh
15:50:18 <dons> so happs wiped the flaw for serving up dynamic pages
15:50:32 <dons> when will ror be ready for serious use? ;)
15:50:51 <dcoutts> dons: yeah, I saw that too, pretty nice
15:51:00 <roger`> dons: some complain about a lack of a stable release of HAppS and patchy information about it, is it really suitable for comparison?
15:51:07 <dons> musasabi was very very careful in the happs server code
15:51:12 <thoughtpolice> i figure they would have put something for you know, concurrency into rails 2.0 (it's still single threaded iirc)
15:51:20 <dons> roger`: i'm not sure. but its fast.
15:51:36 <dcoutts> happs is single threaded in the core as I understand it
15:51:36 <roger`> dons: http://programming.reddit.com/info/62shw/comments/c02nja4
15:51:57 <dons> jerf's a long time skeptic
15:52:37 <Mitar> is there any standard function which would split a string by tabs?
15:52:46 <dmhouse> Mitar: words
15:52:55 <Mitar> but not spaces :-)
15:52:56 <oerjan> Mitar: words splits both spaces and tabs
15:52:59 <dons> shapr: you could do more to address this, http://programming.reddit.com/info/62shw/comments/c02nlnw
15:53:24 <dmhouse> Mitar: then no. There also happens to be no function to split on an arbitrary delimiter, annoyingly.
15:53:36 <dmhouse> But you can write one fairly easily, using recursion, or using unfoldr (ugly).
15:54:37 <scodil> but do you call it wordsBy or linesBy?
15:55:22 <Botje> anyone who wants to proofread my presentation?
15:55:40 <Mitar> yes, if there is an:
15:55:41 <Mitar> foldr1 (\x y -> x ++ "\t" ++ y) ["abc","def"]
15:55:48 <Mitar> then I could make it also unfoldr :-)
15:56:55 <Botje> http://wilma.vub.ac.be/~dharnie/haskell.pdf # comments welcome
15:57:02 <Botje> but preferably in less than an hour
15:57:12 <dmhouse> > let f cur ('\t':xs) = cur : f "" xs; f cur (x:xs) = f (cur ++ [x]) xs; f cur [] = [cur]; splitOnTabs xs = f "" xs in splitOnTabs "hello there\tworld how are\tyou?"
15:57:13 <lambdabot>  ["hello there","world how are","you?"]
15:59:57 <bench> parsec permute?
16:00:13 <bench> anyone has any experience with it?
16:01:03 <xpika> what non functional languages support partial function application?
16:01:22 <dibblego> Scala
16:04:45 <ricky_clarkson> xpika: More allow it than support it.
16:04:53 <dmhouse> > let f = (\xs -> fmap (\ix -> (take ix xs, drop (ix+1) xs)) $ findIndex (== '\t') xs); splitOnTabs xs = unfoldr f (xs++"\t") in splitOnTabs "hello there\tworld how are\tyou?"
16:04:54 <lambdabot>  ["hello there","world how are","you?"]
16:05:04 <dmhouse> Mitar: chose the one you prefer. :)
16:05:43 <Mitar> thanks :-)
16:06:03 <ricky_clarkson> :t splitBy
16:06:04 <lambdabot> Not in scope: `splitBy'
16:06:13 <dmhouse> :t splitAt
16:06:13 <lambdabot> forall a. Int -> [a] -> ([a], [a])
16:06:30 <dmhouse> > let f = (\xs -> fmap (\ix -> splitAt ix xs) $ findIndex (== '\t') xs); splitOnTabs xs = unfoldr f (xs++"\t") in splitOnTabs "hello there\tworld how are\tyou?"
16:06:31 <lambdabot>  ["hello there","","","","","","","","","","","","","","","","","","","","","...
16:07:03 <dmhouse> > let f = (\xs -> fmap (\ix -> splitAt ix xs >>> (id *** drop 1)) $ findIndex (== '\t') xs); splitOnTabs xs = unfoldr f (xs++"\t") in splitOnTabs "hello there\tworld how are\tyou?"
16:07:03 <lambdabot>  Couldn't match expected type `(,)' against inferred type `(->)'
16:08:11 <oerjan> :t span
16:08:11 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
16:08:24 <dmhouse> > let f = (\xs -> fmap (\ix -> (id *** drop 1) $ splitAt ix xs) $ findIndex (== '\t') xs); splitOnTabs xs = unfoldr f (xs++"\t") in splitOnTabs "hello there\tworld how are\tyou?"
16:08:25 <lambdabot>  ["hello there","world how are","you?"]
16:09:50 <dmhouse> oerjan: it then gets ugly as you have to check whether the second is empty and return Nothing then.
16:10:06 <dmhouse> My favourite is probably still the simple recursion.
16:12:04 <dcoutts> dons: btw, I was wondering about hs-plugins, if there's any plan to update it or if we should drop it from gentoo
16:12:13 <dons> i'd drop it.
16:12:16 <dmhouse> Eurgh, maintaining Haskell dependencies is such a chore.
16:12:18 <dcoutts> ok, ta
16:12:20 <dons> it'll get pushed onto hackage as 1.1 eventually
16:12:23 <oerjan> > let splitOnTabs = unfoldr (\xs -> listToMaybe xs >> (id *** drop 1) <$> (Just $ break (== '\t') xs)) in splitOnTabs "hello there\tworld how are\tyou?"
16:12:24 <lambdabot>  ["hello there","world how are","you?"]
16:12:25 <dons> but nothing could possibly use it, I think
16:13:08 <oerjan> ok so listToMaybe is hack for guard . not . null :)
16:13:25 <dcoutts> dons: oh, so 1.1 will be a continuation of the hs-plugins api but updated for 6.6/6.8?
16:13:33 <dons> yep.
16:13:57 <dcoutts> dons: ok, I'll not remove the hs-plugins from portage yet then
16:14:10 <dmhouse> I want to fix a but in my hpaste.el, so I need to install hpaste. I get mysterious hpaste build errors, so I'm trying to update my version of HAppS (I've no idea if this will actually fix the problem). But HAppS now needs hslogger. I find and download hslogger, and try to build it. But hslogger needs a newer version of Cabal. *Sigh*
16:14:42 <dmhouse> Whatever happened to cabal-install?
16:14:46 <dcoutts> dmhouse: it's ok to locally install the newer cabal
16:14:58 <dcoutts> dmhouse: expect a new release of cabal-install in a few days
16:15:26 <dmhouse> dcoutts: what will this release do?
16:15:34 <dcoutts> dmhouse: though the current one ought to work with the latest cabal
16:16:04 <dmhouse> I.e. what features will it have?
16:16:07 <dcoutts> dmhouse: improved command line handling, cabal-setup merged with cabal-install and upload feature added (merged from cabal-upload)
16:16:25 <dcoutts> dmhouse: so it should be the one true interface to cabal
16:16:38 <dcoutts> no need to use runhaskell Setup.hs ever again
16:16:49 <dmhouse> dcoutts: great. :)
16:17:13 <bench> ok, so i'm new to this, but what's the protocol here?
16:17:17 <dcoutts> oh and it should have bash command line completion
16:17:25 <dmhouse> Oh, I see, I'm running an older version of GHC. Wow, I'm out of touch with the Haskell world.
16:17:42 <dcoutts> dmhouse: it's easy to use a new cabal with an old ghc
16:17:44 <Mitar> i found this the nicest:
16:17:45 <Mitar> tabs [] = [""]
16:17:45 <Mitar> tabs ('\t':ls) = []:(tabs ls)
16:17:46 <Mitar> tabs (l:ls) = (l:w):ws
16:17:46 <Mitar>   where (w:ws) = tabs ls
16:18:13 <oerjan> bench: fairly liberal
16:18:18 <dmhouse> dcoutts: may as well upgrade GHC.
16:18:36 <dcoutts> bench: just ask questions, if you want the #haskell tour ask shapr :-)
16:18:38 <astrolabe> bench: If you mean you're new to the channel, it is a pretty friendly place.  Try to stay roughley on topic and you'll be fine.
16:19:22 <dcoutts> bench: we have a very useful bot, lambdabot
16:19:25 <dcoutts> @botsnack
16:19:26 <lambdabot> :)
16:20:31 <oerjan> bench: also our own pastebin
16:20:35 <oerjan> !paste
16:20:35 <hpaste> Haskell paste bin: http://hpaste.org/
16:23:51 <bench> so just shout the questions to the entire channel typically?
16:23:58 <dcoutts> yep
16:24:16 <dcoutts> bench: unless you're talking to someone specifically
16:24:33 <oerjan> and if it involves some code put it on the pastebin, preferrably with any error messages :)
16:25:42 <oerjan> hpaste announces pastes here automatically
16:25:47 <Mitar> (l:w):ws is not the same as l:(w:ws), isn't it?
16:25:54 <oerjan> Mitar: nope
16:25:57 <Mitar> (l:w):ws is not the same as l:w:ws, isn't it?
16:26:19 <oerjan> but the last two on your lines are the same
16:26:30 <dcoutts> l:w:ws = l:(w:ws)
16:26:41 <oerjan> > (0$0:)
16:26:43 <lambdabot>      The operator `:' [infixr 5] of a section
16:26:43 <lambdabot>         must have lower precede...
16:26:52 <oerjan> right associative
16:27:21 <oerjan> :t \l w ws -> (l:w):ws
16:27:22 <lambdabot> forall a. a -> [a] -> [[a]] -> [[a]]
16:27:28 <Mitar> interesting ... so you can write (_:second:_:_:fifth:_)
16:27:34 <oerjan> :t \l w ws -> l:(w:ws)
16:27:34 <lambdabot> forall a. a -> a -> [a] -> [a]
16:27:58 <oerjan> yep
16:28:16 <ricky_clarkson> Fairly obviously l and w are just letters, but what are they standing for here?
16:28:44 <Mitar> check the code i pasted a little bit before
16:29:21 <Mitar> lines and words
16:30:28 <ricky_clarkson> Ta.
16:30:35 <moonlite> are there any documentation availible on the writer monad?
16:31:41 <SamB_XP> moonlite: what for you want documentation?
16:32:14 <moonlite> i'd like to now what tell, listen and pass does
16:32:30 * SamB_XP suspects that simply reading the code would be enough to see that
16:32:32 <moonlite> and what to pass to execWriter
16:33:02 <ricky_clarkson> @src Writer
16:33:02 <lambdabot> Source not found. My pet ferret can type better than you!
16:33:17 <oerjan> :t execWriter
16:33:18 <lambdabot> forall w a. Writer w a -> w
16:33:18 <ricky_clarkson> Yes, but it's not using its tail.
16:33:19 <astrolabe> http://www.haskell.org/ghc/docs/6.6/html/libraries/mtl/Control-Monad-Writer.html
16:33:21 <lambdabot> http://tinyurl.com/2l6u4e
16:33:53 <oerjan> moonlite: execWriter only takes one argument, a Writer action
16:34:27 <bench> need help on parsec's permute
16:34:46 <moonlite> oerjan: ie. a function in the writer monad?
16:35:00 <bench> which order will the permutation be tried?
16:35:18 <oerjan> a value in the writer monad.
16:35:19 <moonlite> the writer monad works like a sort of log right? Would "tell" be "append to log" in that case?
16:35:28 <oerjan> exactly
16:35:32 <bench> and it seems that each of the parser can't be overlapping?
16:35:38 <moonlite> oerjan: thx!
16:35:50 <oerjan> bench: have you read the parsec manual?
16:35:57 <bench> yes,
16:36:20 <bench> it seems that it would try the last parser first?
16:36:46 <bench> i have <$$>p1 <||> p2 <|?> p3
16:36:58 <bench> it seems that p3 is always tried first
16:37:08 <oerjan> iirc it is marked experimental
16:38:06 <oerjan> i guess it is not intended for things that can overlap
16:38:25 <oerjan> :t listen
16:38:26 <lambdabot> forall (m :: * -> *) a w. (MonadWriter w m) => m a -> m (a, w)
16:38:35 <oerjan> :t pass
16:38:35 <lambdabot> forall (m :: * -> *) a w. (MonadWriter w m) => m (a, w -> w) -> m a
16:38:40 <bench> that's what i'm guessing too
16:39:25 <bench> is there another way to write a parser using parsec for a set of random ordered tokens?
16:40:49 <faxathisia> bench token = a <|> b <|> c <|> d <|> d
16:41:02 <faxathisia> bench: read a lit of token you get a list of any a,b,c,d..
16:45:10 <bench> faxathisia: do u mean to define a separate scanner?
16:45:40 <bench> in your example, are you assuming that a b c .. are not overlapping?
16:45:58 <faxathisia> no
16:46:16 <faxathisia> Exactly what are you parsing
16:47:08 <bench> so if a b c can overlap, don't you have to do a try to backtrack?
16:51:08 <Mitar> is there a shorter way to write this lambda: (\(a,s) -> (read a,if s == "yes" then True else False)
16:52:00 <nanothief> Mitar, you dont need the if, just use s == "yes"
16:52:12 <Mitar> ?
16:52:29 <nanothief> (\(a,s) -> (read a,s == "yes")
16:52:32 <oerjan> Mitar: (read *** (== "yes"))
16:52:34 <Mitar> ohhh
16:52:38 <Mitar> so so true :-)))))))
16:52:52 <Mitar> what is ***?
16:53:02 <oerjan> :t (***)
16:53:04 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
16:53:17 <oerjan> :t (***).(id.)
16:53:17 <lambdabot> forall b' c' b a. (a -> b) -> (b' -> c') -> (a, b') -> (b, c')
16:53:59 <oerjan> (f *** g) (a,b) = (f a, g b)
16:54:23 <oerjan> @src -> ***
16:54:24 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
16:54:31 <oerjan> @src -> (***)
16:54:32 <lambdabot> Source not found. :(
16:55:02 <Mitar> oerjan: i do not really follow this types :-)
16:55:29 <oerjan> i hate never knowing if the source really isn't there or if i am getting wrong where the parentheses are needed :(
16:56:12 <nanothief> Mitar: (f *** g) (a,b) = (f a, g b) explains it pretty well, in this case f = read and g = (== "yes")
16:56:21 <oerjan> Mitar: *** is polymorphic over Arrows.  For the -> arrow it has that meaning
16:57:04 <Mitar> yes, i understand  (f *** g) (a,b) = (f a, g b) but I do not see how could i devise this from the type
16:57:51 <oerjan> :t (***).(id.)
16:57:53 <lambdabot> forall b' c' b a. (a -> b) -> (b' -> c') -> (a, b') -> (b, c')
16:58:03 <oerjan> can you see it from that type?
16:58:34 <oerjan> (.(id.) is just a trick to make the arrow ->)
16:59:50 <oerjan> @djinn (a -> b) -> (b' -> c') -> (a, b') -> (b, c')
16:59:51 <lambdabot> f a b (c, d) = (a c, b d)
17:00:30 <oerjan> a bit confusing naming there
17:01:10 <moonlite> execWriter will only return the log, i'd also need the other value. I have a function "check :: DSAParams -> StdGen -> Writer String StdGen" and besides the String i also need the StdGen. execWriter doesn't seem to be what i need, is there another way?
17:01:18 <oerjan> moonlite: runWriter
17:01:37 <Mitar> i do not see where it gets the resulting tuple type ...
17:02:00 <Mitar> because the parameter is a tuple?
17:02:20 <oerjan> you don't understand why that function has that type?
17:02:32 <Mitar> no no
17:02:52 <Mitar> :t (***)
17:02:53 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
17:02:59 <oerjan> oh.
17:03:03 <Mitar> where does the tuple come into a play here?
17:03:28 <oerjan> well there are tuples in that type, (b, b') and (c, c')
17:03:50 <oerjan> now set a = (->)
17:04:06 <Mitar> :t (->)
17:04:07 <lambdabot> parse error on input `->'
17:04:11 <oerjan> (->) b c -> (->) b' c' -> (->) (b, b') (c, c')
17:04:27 <oerjan> it's a type constructor not an expression
17:04:34 <oerjan> @kind (->)
17:04:35 <lambdabot> ?? -> ? -> *
17:04:51 <oerjan> (and with a particularly obscure kind)
17:04:58 <faxathisia> @kind Just
17:04:59 <lambdabot> Not in scope: type constructor or class `Just'
17:05:03 <faxathisia> @kind (Just)
17:05:04 <lambdabot> Not in scope: type constructor or class `Just'
17:05:11 <faxathisia> ;\
17:05:14 <oerjan> Just, howecer, _is_ an expression, not a type
17:05:15 <Mitar> @kind Maybe
17:05:16 <lambdabot> * -> *
17:05:21 <Mitar> :t Maybe
17:05:22 <lambdabot> Not in scope: data constructor `Maybe'
17:05:25 <faxathisia> ohh
17:05:28 <faxathisia> ok  thanks
17:05:30 <moonlite> oerjan: thanks again. (I got the impression that runWriter didnt take a parameter until i realised it was a "record"-function)
17:05:57 <atp> hey, what is (# #) ?
17:06:02 <oerjan> moonlite: most of the Control.Monad.* modules define their run* functions as record fields
17:06:15 <oerjan> atp: unboxed tuple
17:06:35 <Mitar> ok, i will have to read a little more about arrows obviously :-)
17:07:10 <oerjan> Mitar: one last step, turn the (->) infix:
17:07:19 <atp> oerjan: ah.  does placing # after a type unbox it as well?  i'm looking at the RealWorld magic that GHC does...
17:07:23 <oerjan> (->) b c -> (->) b' c' -> (->) (b, b') (c, c')
17:07:48 <oerjan> becomes (b -> c) -> (b' -> c') -> ((b, b') -> (c, c'))
17:07:59 <moonlite> oerjan: yep i know. Perhaps the haddock-docs should print "runWriter :: Writer w a -> (a, w)" instead. It is ofcourse implied from context, but still. :)
17:08:01 <oerjan> atp: that's only a convention
17:08:13 <moonlite> anyhow, many thanks
17:08:17 <atp> oerjan: how so?
17:08:30 <atp> oerjan: a convention for internals or what?
17:08:47 <oerjan> atp: ghc uses names with # for internal things.  it is not legally haskell 98
17:09:10 <dmhouse> Mitar: basically arrows are generalised monads but you can think of them as a kind of generalised function. So while (***) :: a b c -> a d e -> a (b, d) (c, e), you'd more normally use that as (***) :: (b -> c) -> (d -> e) -> (b, d) -> (c, e).
17:09:26 <dmhouse> Mitar: similarly with (&&&) and friends.
17:09:48 <atp> oerjan: i see, ok.  so the only place that # is actually part of the language is in unboxed types, then?  (# a, b #) is nominally isomorphic to data StrictPair a b = StrictPair !a !b or something?
17:10:03 <Mitar> thanks
17:10:19 <atp> oerjan: sorry, unboxed tuples*
17:10:42 <Saizan> unboxer tuples are ghc specific iirc
17:11:36 <oerjan> atp: haskell 98 doesn't mention unboxing at all
17:11:41 <atp> Saizan: hm, yes, i assumed so... i don't intend to use them in my code, i'm just trying to grok them.
17:11:50 <oerjan> afaik
17:12:03 <atp> oerjan: so seq, $!, and bang patterns aren't part of the h98 standard?
17:12:27 <dmhouse> atp: the first two are.
17:12:35 <faxathisia> @kind (!)
17:12:37 <lambdabot> parse error on input `)'
17:12:57 <atp> hm
17:13:09 <oerjan> atp: strict is not quite the same as unboxed
17:13:23 <oerjan> unboxed is an optimization ghc can use for strict fields
17:13:42 <oerjan> and it also has primitive unboxed types
17:13:56 <dmhouse> (Which are strict.)
17:14:10 <atp> oerjan: let me see if i understand...
17:14:27 <Saizan> the "box" is the indirection needed to make lazy evaluation work
17:14:30 <oerjan> everything unboxed must be strict, because unboxed means there is no thunk available to implement laziness
17:14:53 <oerjan> only a direct representation of the result
17:15:09 <atp> ah!  i see, so unboxed means no thunk, but strictness annotations don't get rid of the thunk, they just force evaluation
17:15:17 <dmhouse> atp: essentially values are actually represented as pointers to values. If the value is _|_ then the pointer is the null pointer. If you work with strict types then there is no _|_ so this level of indirection can be removed and you can 'unbox'.
17:15:17 <oerjan> right :)
17:15:41 <atp> dmhouse: hm, interesting.
17:15:53 <atp> oerjan: thanks a lot for explaining it to me
17:15:58 <atp> you too dmhouse
17:16:02 <atp> i appreciate it
17:16:37 <dmhouse> atp, http://en.wikibooks.org/wiki/Haskell/Laziness might be interesting.
17:17:21 <atp> dmhouse: i've looked at that, and it is.  the strictness link in the same series was also interesting...
17:17:23 <hpaste>  wellwisher pasted "Type Problems using FFI" at http://hpaste.org/4417
17:18:15 <atp> dmhouse: understanding the internals of how a purely functional lazy language like haskell is mapped onto a strict von neumann architecture is just going to take me more than one pass i'm afraid :)
17:18:44 <wellwisher> i am having type problems using the foreign function interface with stucts
17:19:01 <dmhouse> atp: let me know if you have any feedback on the Wikibook, especially the Laziness article, as I wrote a great deal of it.
17:19:11 <dmhouse> atp: catch me in here, or ?tell me if I'm not around.
17:19:22 <atp> dmhouse: ok, i'll take another look and give you feedback.
17:20:00 <atp> dmhouse: oh wait, it looks like the link i saw before was the one on haskell.org... i guess i haven't read this yet
17:20:07 <atp> dmhouse: this is rather more in depth
17:21:29 <wellwisher> any one have experience using the foreign function interface?
17:23:25 * oerjan only remembers something about structs not being directly supported
17:23:57 <sjanssen> wellwisher: yes
17:24:59 <oerjan> (and also something about c2hs or something containing workarounds)
17:25:13 <wellwisher> i am trying to figurue out how structs defined in c are defined in haskell
17:25:28 <sjanssen> I don't think the FFI supports passing structs by value
17:25:31 <sjanssen> you have to pass pointers
17:25:37 <wellwisher> o
17:25:44 <wellwisher> ill try that
17:32:12 <dmhouse> Goodness me, GHC is taking its time to compile.
17:34:40 <wellwisher> why would I get a paras error for this: item = IP {'A','B','C','D'}
17:35:11 <wellwisher> when data IP = IP { a :: Char, b :: Char, c :: Char, d :: Char }
17:35:37 <oerjan> you need to use the field names, or bracketless notation
17:35:54 <oerjan> IP {a='A', etc.
17:35:57 <wellwisher> o duh
17:36:05 <oerjan> or IP 'A' 'B' 'C' 'D'
17:38:22 <jcreigh> okay, I looked at the source of Data.Monoid as recommended, but I still don't see what it buys me. Why use Endo when, AFAICT, foldr (.) id would work just as well?
17:39:16 <sjanssen> the main attraction is that you can write code that is generic across all monoids
17:39:28 <sjanssen> @type Data.Foldable.foldMap -- for example
17:39:29 <lambdabot> forall a m (t :: * -> *). (Data.Foldable.Foldable t, Monoid m) => (a -> m) -> t a -> m
17:40:35 <oerjan> also, Endo is used to implement other Foldable functions, including its foldr
17:41:36 <oerjan> it could also be useful in Writer i think
17:43:23 <hpaste>  wellwisher annotated "Type Problems using FFI" with "(no title)" at http://hpaste.org/4417#a1
17:44:12 <jcreigh> hmm
17:45:40 <sjanssen> jcreigh: your question is like "why should I use >>= when I can use concatMap/bindIO/bindParsec/bindState/..."
17:46:24 <oerjan> well not really
17:46:50 <oerjan> it's more like why should i use ZipList when i can just use zipWith
17:46:59 <wellwisher> sjanssen: what is the correct way to use Ptr in my code?
17:47:15 <jcreigh> hmm, okay, so in Data.Foldable there's fold :: Monoid m => t m -> m
17:47:40 <jcreigh> you can just fold something, and because of the Monoid instance, it knows how to combine them, you don't have to tell it. That's kinda cool.
17:48:18 <sjanssen> wellwisher: you need to write some code to marshall between your code's data structure and the C data structure
17:48:20 <SamB_XP> works nicely with DLists too, I guess
17:49:06 <wellwisher> sjanssen: do know of some code that gives a good example of that?
17:49:44 <sjanssen> wellwisher: http://darcs.haskell.org/X11/Graphics/X11/Xlib/Extras.hsc has a bunch
17:49:54 <sjanssen> wellwisher: search for storable
17:50:30 <jcreigh> muhaha.
17:50:36 <jcreigh> > fold . map Product $ [1..5]
17:50:37 <lambdabot>   Not in scope: `fold'
17:50:44 <jcreigh> oh, lb doesn't have it. bummer.
17:51:39 <oerjan> > Data.Foldable.fold . map Product $ [1..5]
17:51:40 <lambdabot>  Product {getProduct = 120}
17:51:44 <sjanssen> jcreigh: have you read the finger tree paper?
17:51:55 <jcreigh> sjanssen: no, I haven't.
17:52:09 <oerjan> it doesn't import Data.Foldable unqualified, probably because of all the name clashes
17:52:16 <sjanssen> jcreigh: it has a very compelling use of monoids
17:52:19 <jcreigh> oerjan: yeah, good point.
17:52:21 <oerjan> > F.fold
17:52:21 <lambdabot>   Not in scope: `F.fold'
17:52:50 <jcreigh> sjanssen: is this the paper you're talking about? http://www.soi.city.ac.uk/~ross/papers/FingerTree.html
17:52:53 <lambdabot> Title: Finger Trees: A Simple General-purpose Data Structure
17:53:45 <sjanssen> jcreigh: yep.  They use monoids as a generic indexing interface, yielding a single data structure that can be used as an efficient random access sequence, priority queue, finite map, and more
17:55:49 <jcreigh> heh. I like how Haskell is the new pseudocode.
17:56:43 <ricky_clarkson> @spell pseudocode
17:56:49 <jcreigh> "A type with an associative operation and an identity forms a monoid." Okay, that makes sense.
17:57:01 <ricky_clarkson> @dict pseudocode
17:57:02 <lambdabot> Supported dictionary-lookup commands:
17:57:02 <lambdabot>   all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
17:57:02 <lambdabot> Use "dict-help [cmd...]" for more.
17:57:11 <faxathisia> jcreigh: E.g. the natural numbers with + and 0
17:57:16 <EvilTerran> @help hitchcock
17:57:16 <lambdabot> I perform dictionary lookups via the following 13 commands:
17:57:16 <lambdabot> all-dicts ... Query all databases on dict.org
17:57:16 <lambdabot> devils ...... The Devil's Dictionary
17:57:16 <lambdabot> easton ...... Easton's 1897 Bible Dictionary
17:57:16 <lambdabot> elements .... Elements database
17:57:18 <lambdabot> [9 @more lines]
17:57:19 <faxathisia> Natural numbers with * and 1
17:57:27 <faxathisia> booleans with False and AND
17:57:28 <faxathisia> etc
17:57:37 <ricky_clarkson> @remember jcreigh I like how Haskell is the new pseudocode.
17:57:38 <lambdabot> Done.
18:02:52 <BMeph> @quote pseudocode
18:02:52 <lambdabot> jcreigh says: I like how Haskell is the new pseudocode.
18:04:59 <faxathisia> ack you're right BMeph
18:05:04 <faxathisia> sorry False and AND are not a monoid
18:05:20 <faxathisia> I sshould have said True
18:06:04 <nolrai> @pl \a -> a /= ')' && a /= '(')
18:06:04 <lambdabot> (line 1, column 27):
18:06:04 <lambdabot> unexpected ")"
18:06:04 <lambdabot> expecting variable, "(", operator, "==", "/=", "<", "<=", ">=", ">", "`elem`", "`notElem`", "&&" or end of input
18:06:09 <nolrai> @pl \a -> a /= ')' && a /= '('
18:06:10 <lambdabot> liftM2 (&&) (')' /=) ('(' /=)
18:06:26 <mauke> (`notElem` ")(")
18:06:32 <jcreigh> it would be False and OR, right? (ie, the "Any" Monoid instance)
18:07:02 <nolrai> mauke++
18:08:59 <sjanssen> jcreigh: yep
18:09:30 <nolrai> @hoogle (a -> a) -> [a]
18:09:31 <lambdabot> Prelude.iterate :: (a -> a) -> a -> [a]
18:09:31 <lambdabot> Data.List.iterate :: (a -> a) -> a -> [a]
18:09:31 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
18:09:57 <mauke> :t (: []) . fix
18:09:58 <lambdabot> forall a. (a -> a) -> [a]
18:10:19 <nolrai> yeah i ment iterate though.
18:10:30 <nolrai> It read my mind!
18:11:49 <pastorn> > ((: []) . fix) (+1)
18:11:51 <lambdabot>  Exception: <<loop>>
18:11:59 <pastorn> awww
18:12:05 <mauke> you can't fix (+1)
18:12:15 <pastorn> what can i fix?
18:12:28 <sjanssen> you can fix what's broken
18:12:36 <mauke> ('!' :)
18:12:50 <pastorn> whut?
18:13:01 <mauke> > fix ('!' :)
18:13:01 <lambdabot>  "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!...
18:14:37 <oerjan> pastorn: a basic rule is that fix f = undefined  if f undefined = undefined
18:14:39 <faxathisia> > take 500 $ fix ('!' :)
18:14:40 <lambdabot>  "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!...
18:14:48 <faxathisia> > take 50000 $ fix ('!' :)
18:14:48 <lambdabot>  "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!...
18:15:19 <jcreigh> faxathisia: it won't matter, lambdabot is doing "take x . show $ your_expr"
18:15:27 <faxathisia> just checking...
18:15:35 <faxathisia> youu never know what might be int her e:p
18:16:14 <oerjan> > replicate 2000 '!' ++ undefined
18:16:15 <lambdabot>  Undefined
18:16:23 <oerjan> > replicate 2001 '!' ++ undefined
18:16:23 <lambdabot>  Undefined
18:16:29 <oerjan> > replicate 2050 '!' ++ undefined
18:16:29 <lambdabot>  "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!...
18:16:46 <oerjan> > replicate 2040 '!' ++ undefined
18:16:46 <lambdabot>  Undefined
18:16:47 <jcreigh> err, what? I don't understand that behavior.
18:16:55 <mauke> > fix error
18:16:55 <lambdabot>  Exception: <<loop>>
18:17:04 <mauke> zomg, infinite bugs
18:17:16 <oerjan> lambdabot does take 2048 . show $ your_expr, or thereabouts
18:17:51 <oerjan> er that's not quite enough
18:18:08 <jcreigh> oerjan: but then it truncates it anyway...why so many characters?
18:18:15 <oerjan> i don't know
18:19:20 <EvilTerran> you get more by /msg
18:19:32 <oerjan> ah
18:21:01 <ricky_clarkson> > fix (True ||)
18:21:02 <lambdabot>  True
18:21:11 <ricky_clarkson> > fix (False &&)
18:21:12 <lambdabot>  False
18:21:27 <ricky_clarkson> I just think that's really brilliantly cute.
18:24:54 <scook0> > (True || undefined, False && undefined)
18:24:55 <lambdabot>  (True,False)
18:27:52 <savvo> > [1..]
18:27:53 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
18:28:47 <mauke> > nubBy (((> 1) .) . gcd) [2 ..]
18:28:48 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
18:29:18 <savvo> lol this is awesome
18:29:27 <savvo> > (+) 1 1
18:29:28 <lambdabot>  2
18:29:29 <ricky_clarkson> > nubBy (((> 1) .) . gcd [2 ..] !! 400
18:29:29 <lambdabot> Unbalanced parentheses
18:29:39 <ricky_clarkson> > nubBy (((> 1) .) . gcd) [2 ..] !! 400
18:29:40 <lambdabot>  2749
18:30:04 <savvo> hmmmm
18:30:24 <savvo> > inf x = inf x+1
18:30:24 <lambdabot>  Parse error at "=" (column 7)
18:30:41 <savvo> err
18:30:51 <ricky_clarkson> > let inf x=inf x+1 in inf 1
18:30:52 <mauke> > let inf = inf + 1 in inf
18:30:52 <lambdabot>  Exception: <<loop>>
18:30:52 <lambdabot>  Exception: <<loop>>
18:31:34 <savvo> let x = 1 in x
18:31:37 <savvo> > let x = 1 in x
18:31:38 <lambdabot>  1
18:32:27 <ricky_clarkson> > let fac x=if' x<2 x n*fac x in fac 5
18:32:27 <lambdabot>   Not in scope: `n'
18:32:36 <ricky_clarkson> > let fac x=if' x<2 x x*fac (x-1) in fac 5
18:32:37 <lambdabot>   Not in scope: `if''
18:32:47 <mauke> > 1/2 + 1/3
18:32:47 <lambdabot>  0.8333333333333333
18:32:49 <ricky_clarkson> > let fac x=if (x<2) then x else x*fac (x-1) in fac 5
18:32:50 <lambdabot>  120
18:32:52 <mauke> > 1/2 + 1/3 :: Rational
18:32:52 <lambdabot>  5%6
18:33:10 <oerjan> > scanl1 (*) [1..]
18:33:11 <lambdabot>  [1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,87...
18:33:16 <ricky_clarkson> Why does it use % instead of / there?
18:33:39 <mauke> ricky_clarkson: because that's how its Show instance works
18:33:42 <sarehu> :t (%)
18:33:43 <ricky_clarkson> > length $ show $ scanl1 (*) [1..] !! 20
18:33:43 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
18:33:43 <lambdabot>  20
18:33:52 <ricky_clarkson> > length $ show $ scanl1 (*) [1..] !! 30
18:33:53 <lambdabot>  34
18:34:13 <ricky_clarkson> mauke: Sure.  Why?
18:34:42 <mauke> because % is an operator that constructs rationals from integers
18:34:51 <mauke> / is just generic division
18:35:20 <ricky_clarkson> > 1%3 + 1%3
18:35:22 <lambdabot>  2%3
18:35:27 <ricky_clarkson> I see.
18:36:04 <mauke> > 1/2/3/4/5 :: Rational
18:36:06 <savvo> sorry for the noob question; how do I separate let bindings in one line?
18:36:07 <lambdabot>  1%120
18:36:16 <mauke> savvo: ;
18:36:37 <nolrai> @ty foldMap
18:36:38 <lambdabot> Not in scope: `foldMap'
18:36:40 <ricky_clarkson> > let x=y+1; y=x+1 in y-x
18:36:41 <lambdabot>  Exception: <<loop>>
18:36:53 <oerjan> :t Data.Foldable.foldMap
18:36:53 <lambdabot> forall a m (t :: * -> *). (Data.Foldable.Foldable t, Monoid m) => (a -> m) -> t a -> m
18:37:03 <savvo> > let ack 0 n = n+1; ack (m+1) 0 = ack m 1; ack m (n+1) = ack (m-1) (ack m n) in ack 4 5
18:37:03 <lambdabot>  Parse error in pattern at ";" (column 41)
18:37:13 <dons> > let x= 'x' : y ; y= 'y' : x in x ++ y
18:37:17 <lambdabot>  "xyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyx...
18:37:37 <ricky_clarkson> > let ones=1:ones in ones
18:37:37 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
18:37:51 <nolrai> foldMap (\_->1) [1..5]
18:37:57 <nolrai> > foldMap (\_->1) [1..5]
18:37:57 <lambdabot>   Not in scope: `foldMap'
18:38:00 <savvo> > let ack 0 n= n+1 in ack 0 5
18:38:01 <lambdabot>  6
18:38:06 <oerjan> savvo: for some reason lambdabot doesn't allow n+k patterns
18:38:11 <nolrai> > Data.Foldable.foldMap (\_->1) [1..5]
18:38:11 <lambdabot>  Add a type signature
18:38:20 <savvo> oh, sucks
18:38:21 <nolrai> > Data.Foldable.foldMap (\_->1) [1..5] :: Int
18:38:24 <lambdabot>   add an instance declaration for (Monoid Int)
18:38:25 <lambdabot>     In the expression: Data.Fo...
18:38:52 <savvo> We need to make lambdabot crash :-)
18:38:54 <ricky_clarkson> It's really nice to have a channel where you actually learn from the bot and people don't seem to mind.
18:39:00 <ricky_clarkson> savvo: We need to stop doing that. ;)
18:39:05 <mauke> > let ack 0 n = n+1; ack m 0 = ack (m-1) 1; ack m n = ack (m-1) (ack m (n-1)) in ack 4 5
18:39:13 <lambdabot> Terminated
18:39:27 <nolrai> it seems like one should be able to use traverse to count elements but i cant figure it out.
18:39:35 <ricky_clarkson> :t traverse
18:39:36 <lambdabot> Not in scope: `traverse'
18:40:02 <nolrai> @ty Data.Traversible.traverse
18:40:03 <lambdabot> Couldn't find qualified module.
18:40:10 <nolrai> @ty Data.Traversable.traverse
18:40:10 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
18:40:28 * ricky_clarkson ducks as that type signature flies overhead.
18:40:40 <nolrai> yeah me too.
18:40:56 <nolrai> well not quite.
18:41:48 <nolrai> oh well i dont _need_ to use it.
18:42:31 <oerjan> > execWriter (traverse (const (tell (Sum 1))) [1,2,4,5])
18:42:32 <lambdabot>   Not in scope: `traverse'
18:42:41 <oerjan> > execWriter (Data.Foldable.traverse (const (tell (Sum 1))) [1,2,4,5])
18:42:42 <lambdabot>   Not in scope: `Data.Foldable.traverse'
18:42:52 <oerjan> > execWriter (Data.Traversable.traverse (const (tell (Sum 1))) [1,2,4,5])
18:42:53 <lambdabot>        add an instance declaration for (Applicative (Writer (Sum t)))
18:42:57 <oerjan> sheesh
18:43:06 <savvo> > let x = 1 in (let x=x in x)
18:43:07 <lambdabot>  Exception: <<loop>>
18:43:24 <faxathisia> @let __=__
18:43:25 <lambdabot> Defined.
18:43:27 <faxathisia> > __
18:43:28 <lambdabot>  Exception: <<loop>>
18:43:33 <oerjan> bah, that Monad is not Applicative :(
18:43:34 <savvo> That's interesting... For ack it gave a terminated rather than a <<loop>>
18:43:54 <savvo> > let ack 0 n = n+1; ack m 0 = ack (m-1) 1; ack m n = ack (m-1) (ack m (n-1)) in ack 4 5
18:44:01 <lambdabot> Terminated
18:44:02 <chadz> i can't seem to get lambdabot's runplugs working quite right with 6.6.1, @run results in a broken pipe, and ./runplugs results in a ShowQ error
18:44:07 <savvo> (ack is the ackermann function; takes forever to compute)
18:44:27 <Mitar> how could I convert this to point free style? (\x y -> ((x + y) / 2))
18:44:39 <faxathisia> @pl (\x y -> ((x + y) / 2))
18:44:39 <lambdabot> flip flip 2 . ((/) .) . (+)
18:44:40 <ricky_clarkson> @pl \x y -> ((x+y)/2)
18:44:40 <lambdabot> flip flip 2 . ((/) .) . (+)
18:44:49 <ricky_clarkson> Badly. ;)
18:45:06 <faxathisia> +/%#
18:45:06 <savvo> any ideas why?
18:45:19 <chadz> faxathisia: J? ehehe
18:46:04 <Mitar> @pl (\x y -> (0.5 * (x + y))
18:46:04 <lambdabot> (line 1, column 25):
18:46:04 <lambdabot> unexpected end of input
18:46:04 <lambdabot> expecting variable, "(", operator or ")"
18:46:08 <Mitar> @pl (\x y -> (0.5 * (x + y)))
18:46:08 <lambdabot> ((0 . 5 *) .) . (+)
18:46:09 <nolrai> fold (+) $ fmap (\_-> 1) [1..10]
18:46:17 <nolrai> > fold (+) $ fmap (\_-> 1) [1..10]
18:46:18 <lambdabot>   Not in scope: `fold'
18:46:28 <nolrai> > foldl (+) $ fmap (\_-> 1) [1..10]
18:46:29 <lambdabot>   add an instance declaration for (Num [t])
18:46:44 <faxathisia> @pl 0.5
18:46:44 <lambdabot> 0 . 5
18:46:45 <faxathisia> lol
18:46:48 <oerjan> savvo: <<loop>> only happens when a thunk is reached again while already evaluating that same thunk
18:46:52 <chadz> @pretty 0.5
18:46:52 <lambdabot>  0.5
18:47:01 <faxathisia> @pl a.b
18:47:01 <lambdabot> a . b
18:48:33 <oerjan> @pl \x y -> (/2)(x + y)
18:48:33 <lambdabot> ((/ 2) .) . (+)
18:48:35 <savvo> oerjan: ah of course, makes sense
18:49:38 <mauke> @pl \f g x y -> f (g x y)
18:49:39 <lambdabot> (.) . (.)
18:50:09 <chadz> imho, the pointfree style shouldn't be used.
18:50:16 <ricky_clarkson> Why?
18:50:16 <chadz> (in that case)
18:50:18 <ricky_clarkson> Ah.
18:51:07 <oerjan> > Data.Foldable.foldMap (const . Sum $ 1) [1,2,4,5]
18:51:08 <lambdabot>  Sum {getSum = 4}
18:51:09 <faxathisia> > uncurry (/) (sum &&& length) [5,7]
18:51:10 <lambdabot>  Couldn't match expected type `(a, c)'
18:51:13 <savvo> let x=1 in (let x=1-x in x)
18:51:15 <savvo> > let x=1 in (let x=1-x in x)
18:51:15 <faxathisia> > uncurry (/) $ (sum &&& length) [5,7]
18:51:15 <lambdabot>   add an instance declaration for (Fractional Int)
18:51:16 <lambdabot>  Exception: <<loop>>
18:51:23 <savvo> > let x=1 in (let x=1-x in x)
18:51:23 <lambdabot>  Exception: <<loop>>
18:51:29 <faxathisia> > uncurry (/) $ (sum &&& fromIntegral . length) [5,7]
18:51:31 <lambdabot>  6.0
18:51:52 <savvo> oerjan: this one goes like this: 0,1,0,1,... so that method wouldn't work... any takes?
18:51:57 <Kirakishou> I'm using five monads, three of them being monad transformers, all in one type.
18:52:26 <Kirakishou> how would the program know which monad I'm using when I just do something like 'env <- ask' ?
18:52:29 <oerjan> > sum $ zipWith const (cycle [0,1]) [1,2,5,6]
18:52:30 <chadz> ?src uncurry
18:52:30 <lambdabot> uncurry f p = f (fst p) (snd p)
18:52:31 <lambdabot>  2
18:52:43 <faxathisia> that kind of sucks
18:53:03 <faxathisia> :t uncurry
18:53:04 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
18:53:05 <faxathisia> :t curry
18:53:06 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
18:53:13 <faxathisia> I think the type explains much better
18:53:41 <faxathisia> the code is a bit strange
18:53:47 <chadz> how so?
18:54:00 <faxathisia> case all the ()'s and fst/snd
18:54:14 <ricky_clarkson> > uncurry (+) (3,4)
18:54:14 <lambdabot>  7
18:54:19 <mauke> Kirakishou: it doesn't
18:54:21 <ricky_clarkson> The code seems ok to me.
18:54:35 <Kirakishou> aw darn.
18:54:55 <Kirakishou> so I have to use 'lift'?
18:55:06 <mauke> > (do env <- ask; return (env * 2)) 21
18:55:07 <lambdabot>  42
18:55:18 <Kirakishou> or what?
18:55:22 <mauke> huh?
18:55:24 <scook0> Kirakishou: ask should work fine in any monad that's an instance of MonadReader
18:55:24 <oerjan> Kirakishou: the monad transformers in Control.Monad all have liftings of the common Monad* classes
18:55:30 <chadz> > let uncurry f (l,r) = f l r in uncurry (/) (4,2)
18:55:31 <lambdabot>  2.0
18:55:36 <chadz> that might be more obvious?
18:55:40 <scook0> @type ask
18:55:40 <lambdabot> forall (m :: * -> *) r. (MonadReader r m) => m r
18:55:52 <faxathisia> I think the type is better
18:56:03 <faxathisia> clearer.. more to the point
18:56:14 <oerjan> so ask is delegated down to the first that handles it (Reader or ReaderT, usually)
18:56:33 <Kirakishou> here's the thing, I got 'ErrorT LispErr (ReaderT LispEnv (ContT a IO)) a'
18:56:52 <Kirakishou> Cont and Reader both have 'ask', do they not?
18:56:55 <oerjan> ErrorT would delegate ask down
18:56:59 <oerjan> no
18:57:02 <Kirakishou> oh?
18:57:08 <oerjan> only ReaderT i believe
18:57:19 <oerjan> (from basics)
18:57:23 <Kirakishou> what about 'local'?
18:57:26 <mauke> @src MonadCont
18:57:26 <lambdabot> class (Monad m) => MonadCont m where
18:57:26 <lambdabot>     callCC :: ((a -> m b) -> m a) -> m a
18:57:27 <oerjan> the others only delegate downward
18:57:37 <oerjan> @src MonadReader
18:57:38 <lambdabot> Source not found. The more you drive -- the dumber you get.
18:57:48 <scook0> @instances MonadReader
18:57:49 <lambdabot> r ((->) r), r (ErrorT e m), r (RWS r w s), r (RWST r w s m), r (Reader r), r (ReaderT r m), r (StateT s m), r (WriterT w m), r' (ContT r m)
18:58:09 <oerjan> class (Monad m) => MonadReader r m | m -> r where ask   :: m r local :: (r -> r) -> m a -> m a
18:58:55 <nolrai> what dose | mean in class declarations?
18:59:14 <nolrai> or rather instance
18:59:30 <nolrai> declarations?
18:59:34 <scook0> nolrai: in class declarations, it indicates a functional dependency
18:59:59 <scook0> e.g. for MonadReader, it means that the choice of m uniquely determines the choice of r
19:00:17 <nolrai> Oh
19:00:21 <nolrai> neat
19:00:32 <scook0> i.e. a monad can't be MonadReader for more than one r type
19:00:55 <oerjan> chadz: uncurry doesn't use pattern matching directly because it's supposed to be as lazy as possible, so doesn't check that the second argument is a pair until actually used
19:01:09 <oerjan> although it _could_ use a ~ pattern instead of fst and snd
19:01:23 <scook0> this means the type checker can figure more stuff out without annotations
19:01:26 <faxathisia> What's a ~ pattern?
19:01:26 <ddarius> uncurry f ~(x,y) = f x y
19:01:38 <faxathisia> m...
19:01:46 <scook0> faxathisia: they're known as "irrefutable" patterns
19:02:09 <ddarius> > let f ~(Just x) = 3 in f Nothing
19:02:09 <lambdabot>  3
19:02:20 <ddarius> > let f ~(Just x) = x in f Nothing
19:02:21 <lambdabot>   Irrefutable pattern failed for pattern (Data.Maybe.Just x)
19:02:22 <faxathisia> ohh weird
19:02:45 <scook0> normally when you pattern-match (in case), the program actually evaluates the thunk being matched
19:02:51 <scook0> to check that it has the expected form
19:02:57 <ddarius> fix (\(a,b) -> (1:b,0:a))
19:03:07 <ddarius> > fix (\(a,b) -> (1:b,0:a))
19:03:07 <scook0> irrefutable patterns cause the evaluation/checking to be delayed until later
19:03:08 <lambdabot>  Exception: <<loop>>
19:03:11 <ddarius> > fix (\~(a,b) -> (1:b,0:a))
19:03:11 <chadz> oerjan: ah, gotcha,.
19:03:11 <lambdabot>  Parse error at "->" (column 14)
19:03:19 <ddarius> > fix (\(~(a,b)) -> (1:b,0:a))
19:03:19 <lambdabot>  ([1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,...
19:03:37 <faxathisia> I didn't expect that
19:03:41 <faxathisia> ohhh I see
19:03:53 <faxathisia> this is cool
19:03:59 <scook0> faxathisia: they're generally only sensible when you "know" that the thunk will evaluate to a particular form, e.g. because it's a single-constructor data type like (,)
19:04:15 <nolrai> > sequence $ reapeat $ putChar 'a'
19:04:20 <lambdabot>   Not in scope: `reapeat'
19:04:20 <ddarius> Very handy for knot tying.
19:04:27 <scook0> if an irrefutable match turns out to be wrong, the error will show up in weird places
19:04:27 <nolrai> > sequence $ repeat $ putChar 'a'
19:04:28 <lambdabot>  <IO [()]>
19:05:01 <nolrai> so a sequence of IO ops arnt evalated lazily?
19:05:21 <scook0> nolrai: lambdabot doesn't perform IO actions
19:05:28 <oerjan> nolrai: there's forever defined in the latest ghc, which lambdabot doesn't have yet
19:05:39 <scook0> nolrai: try it in ghci
19:05:52 <oerjan> forever = sequence_ . repeat
19:07:05 <oerjan> nolrai: it is useless with sequence rather than sequence_ there, because it will never finish and return a result.  there are _some_ monads that can manage it, though.
19:07:42 <nolrai> yeah I think i used it with Error.
19:08:17 <oerjan> > evalState (sequence . repeat $ do modify (+1); get) 1
19:08:18 <lambdabot>  [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
19:08:22 <Moosefish> Is there a preferred style to deal with wanting various visibility levels for different purposes?
19:08:59 <Moosefish> For example, I want a file to expose a handful of functions publicly, but the related HUnit and QuickCheck tests to see the whole content
19:10:56 <oerjan> you could put the checks _in_ the file, of course...
19:12:16 <Moosefish> I've been assuming so far that that would cause issues with linking multiple main method
19:12:56 <oerjan> well if you export just the check functions...
19:13:17 <Moosefish> not really better than exporting what they're checking
19:13:25 <Moosefish> (which is what I'm doing right now)
19:13:45 <oerjan> there is a --main-is flag in ghc
19:14:12 <ddarius> Moosefish: While there are ways to do this, I think the common approach is to just export whatever and simply not Haddock the "private" parts.
19:14:27 <Moosefish> would ghc be able to prune out the test code when it can prove it's not linked? Say, when I compile the final "production" binary
19:14:39 <Moosefish> s/linked/used/
19:15:00 <oerjan> split-objs or something
19:15:07 <Moosefish> split-objs?
19:15:15 <oerjan> causes it to create one object file per function
19:15:26 <oerjan> so it can include only what's actually used
19:16:03 <OceanSpray> so, for 'ErrorT LispErr (ReaderT LispEnv (ContT a IO)) a',
19:16:26 <OceanSpray> when I use 'return', it's Error's return?
19:16:43 <oerjan> lessee
19:16:45 <ddarius> No.  It's the whole "stack's" return.
19:16:47 <Moosefish> ddarius: The only approach I thought of so far was exporting everything, re-exporting the stuff I wanted from a source file whose sole purpose is pruning down the interface and call it a day. A big heavy handed at my current codebase size
19:16:57 <Moosefish> s/big/bit/
19:16:59 <oerjan> OceanSpray: that depends somewhat on implementation
19:17:10 <oerjan> it _could_ be implemented as lift return
19:17:14 <ddarius> Moosefish: Indeed.  That is the simplest thing and it is cumbersome which is why people don't usually bother.
19:17:22 <OceanSpray> I don't understand how it can be the whole stack's return...
19:17:27 <OceanSpray> I'm just using plain old GHC
19:17:48 <oerjan> OceanSpray: it depends on how the monad transformers are implemented
19:17:49 <ddarius> return :: a -> ErrorT LispErr (ReaderT LispEnv (ContT a IO)) a
19:18:28 <oerjan> there is a bit of fuzz about how using continuation-based implementations often allows them to avoid calling down the stack
19:18:49 <oerjan> but those are a new thing
19:19:05 <ddarius> oerjan: Still, it's the return for the monad and the monad here is ErrorT LispErr (ReaderT LispEnv (ContT a IO))
19:19:17 <ddarius> oerjan: They aren't particularly new.
19:19:33 <oerjan> ok
19:19:34 <OceanSpray> so does my return bypass the continuation?
19:20:06 <ddarius> return does the same thing conceptually in this monad as any other, nothing.
19:20:20 <oerjan> @src ErrorT return
19:20:20 <lambdabot> return a = ErrorT $ return (Right a)
19:20:36 <oerjan> apparently, it justs passes it down
19:20:40 <oerjan> *just
19:20:54 <ddarius> Not "just".  See the Right.
19:21:07 <oerjan> (the return on the right is from the inner monad)
19:24:28 <oerjan> as i expected, ContT is an exception
19:24:33 <oerjan> @src ContT return
19:24:33 <lambdabot> return a = ContT ($ a)
19:25:30 <ddarius> What ContT does is push all the work to the "continuation"
19:27:34 <oerjan> hm, does this mean that if you insert a ContT in a stack, it also automatically prevents unnecessary lifting from above it to below?
19:27:52 <oerjan> er the other way
19:28:13 <hpaste>  bogner pasted "(no title)" at http://hpaste.org/4420
19:28:34 <oerjan> so you can use it to "break the chain"
19:29:36 <wy> I switched back from xmonad. Still can't get used to the tiling wms
19:32:06 <ddarius> All the purely structural operations below it will not be "run."
19:42:42 <OceanSpray> so,
19:42:55 <OceanSpray> how does one 'inject' a custom continuation into the Cont monad?
19:43:16 <oerjan> @src Cont
19:43:17 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
19:43:19 <hpaste>  dons annotated "Unread message count in Pidgin" with "(no title)" at http://hpaste.org/4421#a1
19:43:20 <ddarius> Usually you'd express it with callCC, but callCC is arguably not the best primitive.
19:43:34 <ddarius> Worst-case scenario, you can directly use the ContT constructor.
19:43:51 <OceanSpray> then what does withCont do?
19:43:56 <ddarius> :t withCont
19:43:57 <lambdabot> forall b r a. ((b -> r) -> a -> r) -> Cont r a -> Cont r b
19:44:05 <ddarius> @src withCont
19:44:06 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
19:44:41 <oerjan> withCont f m = Cont $ runCont m . f
19:45:54 <OceanSpray> It calls the function supplied with the result from the current Cont monad, and puts it into a new Cont?
19:46:35 <hpaste>  (anonymous) annotated "Unread message count in Pidgin" with "(no title)" at http://hpaste.org/4421#a2
19:46:40 <oerjan> 	callCC f = Cont $ \c -> runCont (f (\a -> Cont $ \_ -> c a)) c
19:47:05 <oerjan> that \a -> Cont $ \_ -> c a  is the continuation callCC constructs
19:47:47 <OceanSpray> this is confusing me.
19:47:59 <oerjan> c is the underlying representation passed around
19:48:02 <OceanSpray> :t runCont
19:48:03 <lambdabot> forall r a. Cont r a -> (a -> r) -> r
19:48:08 <ddarius> CPS is intricate.
19:49:04 <oerjan> that \a -> Cont $ \_ -> c a  probably wraps it into something more monadic
19:49:07 <ddarius> You most likely can express what you want with callCC
19:49:16 <OceanSpray> ok, then
19:50:32 <oerjan> now if you _really_ wanted to bypass the original continuation, you would use something like \a -> Const $ \_ -> a , just removing the c i guess
19:50:39 <hpaste>  matthew pasted "Why does this require the Num class?" at http://hpaste.org/4422
19:50:53 <moconnor> Yeah, what I just pated.  Why does this code break: http://hpaste.org/4422
19:50:56 <oerjan> er, *Cont
19:50:59 <OceanSpray> I have a continuation (a -> r) at hand.
19:51:08 <moconnor> It works if I add (Num b), but I don't understand why it's required
19:51:18 <hpaste>  nolrai pasted "why dont i get any output?" at http://hpaste.org/4423
19:51:19 <oerjan> hm...
19:51:30 <oerjan> OceanSpray: i think you can just apply Cont to it
19:51:41 <oerjan> or ContT . return
19:52:05 <oerjan> er wait
19:54:04 <hpaste>  nolrai annotated "Why does this require the Num class?" with "(no title)" at http://hpaste.org/4422#a1
19:54:56 <OceanSpray> callCont :: LispCont -> LispVal -> ErrorT LispErr (ReaderT LispEnv (ContT (Maybe LispVal) IO)) (Maybe LispVal)
19:54:56 <OceanSpray> callCont cont (val :/ Null) = eval val >>= return . cont
19:55:02 <OceanSpray> ...won't work, would it?
19:55:46 <oerjan> what's :/
19:55:48 <moconnor> nolrai: So, in theory I don't want to care what bar returns as long as I can order it.  I will have a data structure like [(x,y)] where y is supplied by calls to bar.  Then I will order the list by the y's and then take out the x's.
19:55:59 <OceanSpray> that's just a constructor for a pair
19:56:00 <moconnor> nolrai: The fact that the y's are Nums, or not Nums, I don't care.  I thought I could express that
19:56:14 <OceanSpray> and LispCont :: (Maybe LispVal) -> (Maybe LispVal)
19:56:34 <nolrai> I thougt you could too.
19:56:44 <ddarius> nolrai: I don't know what you mean by "no output".  The program shouldn't terminate without printing something (but if it doesn't terminate at all then that's the problem).  Anyway, test' can be replaced with mapM_ test [0..]
19:57:24 <nolrai> yeah it dosent print anything but test 0 prints just fine.
19:57:34 <jre2> does anyone here know why "take" is Int->[a]->[a] instead of Integer->[a]->[a] ?
19:58:02 <oerjan> jre2: Int is more efficient
19:58:13 <oerjan> :t genericTake
19:58:14 <lambdabot> forall i a. (Integral i) => i -> [a] -> [a]
19:58:15 <nolrai> because taking more then max :: Int is kindof strange.
19:59:12 <jre2> oerjan: ah, not from some real limitation of any sort then
19:59:29 <oerjan> nope
19:59:31 <nolrai> ddarius: I dont want it to terminate. i just want to be able to see the first few thousand out puts.
20:00:21 <nolrai> > show (max :: Int)
20:00:25 <lambdabot>  Couldn't match expected type `Int'
20:00:33 <ddarius> It's probably just not flushing.
20:00:47 <clanehin> > show (maxBound :: Int)
20:00:48 <lambdabot>  "2147483647"
20:00:54 <nolrai> ah how do i force it to flush
20:01:30 <ddarius> You can change the buffering or there is a hFlush function.  Also, using putStrLn would probably do it as well.  I could be wrong though.
20:05:01 <nolrai> ddarius++
20:05:46 <OceanSpray> ddarius#
20:07:53 <TomMD> ?where porting
20:07:53 <lambdabot> I know nothing about porting.
20:11:17 <oerjan> http://hackage.haskell.org/trac/ghc/wiki/Building/Porting
20:11:19 <lambdabot> Title: Building/Porting - GHC - Trac
20:11:38 <oerjan> @where+ porting http://hackage.haskell.org/trac/ghc/wiki/Building/Porting
20:11:38 <lambdabot> It is stored.
20:18:31 <jaredj> :t cons
20:18:33 <lambdabot> Not in scope: `cons'
20:18:40 <jaredj> oh, right, (:)
20:24:29 <OceanSpray> :t callCC
20:24:30 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
20:25:34 <hpaste>  jaredj pasted "split list of lines on blank lines" at http://hpaste.org/4424
20:26:16 <jaredj> i can use a reduce, but i'm tired and unlearned and can't figure out how. any help?
20:28:02 <jaredj> right, eh, i can use a *fold*, see i'm tired :P
20:28:14 <chessguy> fold, reduce, same thing
20:28:24 <jaredj> yes. but hoogle can't find "reduce" :)
20:28:28 <chessguy> true
20:29:06 <chessguy> well first:[] is of course [first]
20:30:18 <chessguy> that line could be written first : if (null last) then last else (splitOnBlanks $ tail last)
20:30:24 <chessguy> if that's any better
20:30:40 <jaredj> that seems cool
20:30:55 <chessguy> beyond that, i think it's pretty good
20:30:56 <chadz> i can't seem to get lambdabot's runplugs working quite right with 6.6.1, @run results in a broken pipe, and ./runplugs results in a ShowQ error
20:32:02 <chessguy> but yes, there's probably a fold lurking in there
20:32:14 <jcreigh> what are the Monoid laws?
20:32:59 <jcreigh> is it just that mempty has to be the identity value and mappend has to be associative?
20:33:04 <oerjan> yep
20:33:08 <ddarius> mempty `mappend` x = x = x `mappend` mempty  and x `mappend` (y `mappend` z) = (x `mappend` y) `mappend` z
20:33:13 <ddarius> Yes.
20:33:35 <jcreigh> oh.
20:33:49 <ddarius> if null last then last else splitOnBlanks $ tail last
20:34:28 <jcreigh> I was hoping more for something like "A Monoid may not harm a human or allow a human to come to harm by inaction" :)
20:34:38 <sek> i know this isnt the maths channel, but i guess my question has alot more chance of being answered here. How do i project down from a tensor product A\otimes B in a symmetric monoidal closed category, where A,B are general objects rather than units?
20:34:48 <chessguy> meh, good poing ddarius
20:34:52 <chessguy> *point
20:35:00 <chessguy> i still get paren-happy
20:35:17 <ddarius> sek: You don't in general; that's the whole reason to use tensor products.
20:35:44 <sek> i actually have been given an endofunctor-comonoidal structure (a,b) as well, where a,b are nat transforms
20:36:05 <jaredj> poing! heh
20:37:02 <jaredj> i'll try to use "endofunctor-comonoidal" in a sentence tomorrow at work, that'll throw them for a loop
20:37:21 <sek> :)
20:38:50 <ddarius> I know what an endofunctor is and I know what a comonoid is, but I don't know what you mean by "endofunctor-comonoidal structure (a,b)" and I still don't think that gives you enough structure to have projections.
20:39:02 <sek> ddarius, so if i'm trying to interpret the weakening rule in an SMCC, more specifically given f: G -> B, i need to find a function from G\otimes FA -> B  where F is the endofunctor i was taking about
20:39:42 <sek> ddarius, a,b are natural transformations which are a:F->Id_C and b:F->FoF
20:41:37 <sek> ddarius, so in a sense (a,b) define the comonoid over F
20:41:46 <oerjan> i fear we are approaching an incomprehensibility singularity
20:41:59 <ddarius> They are a comonoid object in the endofunctor category.
20:42:40 <ddarius> sek: It's possible you could use a for weakening and b for contraction, but it isn't to me the most obvious way to go about it.
20:42:47 <sek> ok well maybe we have different definitions of comonoids. I have precisely that an F-comonoid is such a pair (a,b)
20:43:04 <jaredj> oerjan: i'm past the event horizon
20:43:05 <sek> ddarius, i made out the contraction rule with b its quite easy
20:43:37 <sek> but there seems to me no obvious way of "getting rid of the tensor product"
20:44:00 <ddarius> sek: I'm pretty sure we have the same definition for comonoid.  My comment was just another way of describing what you had.
20:44:08 <sek> ddarius, k:)
20:44:25 <nolrai> @src iterate
20:44:26 <lambdabot> iterate f x =  x : iterate f (f x)
20:45:25 <ddarius> sek: What was your definition for contraction?
20:46:11 <dmwit> > groupBy (const (not . null)) ["a", "b", "", "c", "d"]
20:46:16 <lambdabot>  [["a","b"],["","c","d"]]
20:46:33 <sek> so if f:G\otimes FA\otimes FA -> B, then f\circ (id_G \otimes b_A) : G\otimes FA -> B
20:46:34 <dmwit> mmm
20:47:03 <oerjan> > map (break null) . groupBy (const (not . null)) ["a", "b", "", "c", "d"]
20:47:04 <lambdabot>  Couldn't match expected type `a -> [[[a1]]]'
20:47:11 <oerjan> > map (break null) . groupBy (const (not . null)) $ ["a", "b", "", "c", "d"]
20:47:12 <lambdabot>  [(["a","b"],[]),([],["","c","d"])]
20:47:23 <oerjan> oops
20:47:25 <dmwit> > groupBy (comparing `on` null) ["a", "b", "", "c", "d"]
20:47:26 <lambdabot>      Occurs check: cannot construct the infinite type: b = b -> a
20:47:26 <lambdabot>     Probabl...
20:47:35 <oerjan> > map (dropWhile null) . groupBy (const (not . null)) $ ["a", "b", "", "c", "d"]
20:47:36 <lambdabot>  [["a","b"],["c","d"]]
20:47:53 <dmwit> Oh yeah, that's a much simpler solution.
20:48:18 <oerjan> hm...
20:48:28 <oerjan> > map (dropWhile null) . groupBy (const (not . null)) $ ["a", "b", "", "c", "d", ""]
20:48:28 <dmwit> (Well, simpler than what I had in mind. =)
20:48:28 <lambdabot>  [["a","b"],["c","d"],[]]
20:49:05 <dmwit> > groupBy (\x y -> null x == null y) ["a", "b", "", "", "c", "d", ""]
20:49:06 <lambdabot>  [["a","b"],["",""],["c","d"],[""]]
20:49:14 <dmwit> Now I just need a way to drop every other one. =P
20:49:15 <oerjan> and slightly buggy
20:49:31 <dmwit> Or...
20:49:55 <dmwit> > filter (not . null) . map (dropWhile null) . groupBy (const (not . null)) $ ["a", "b", "", "", "c", "d", ""]
20:49:55 <lambdabot>  [["a","b"],["c","d"]]
20:50:41 <dmwit> Explicit recursion might actually be prettier. =)
20:51:16 <oerjan> not to mention more efficient
20:51:26 <hpaste>  jaredj annotated "split list of lines on blank lines" with "splitOnBlanks, using groupBy" at http://hpaste.org/4424#a1
20:52:00 <dmwit> jaredj: no good, check out:
20:52:15 <jaredj> gyah
20:52:55 <dmwit> > filter (/= [""]) . groupBy (\x y -> (x /= "") && (y /= "")) $ ["a", "", "", "b"]
20:52:56 <lambdabot>  [["a"],["b"]]
20:53:03 <dmwit> err... hm
20:53:07 <jaredj> there it is. i knew i needed some dots
20:53:21 <dmwit> Maybe that *is* fine.
20:53:45 <dmwit> > groupBy (const (not . null)) ["a", "", "", "b"]
20:53:46 <lambdabot>  [["a"],[""],["","b"]]
20:53:55 <dmwit> jaredj: clever!
20:54:40 <jaredj> eh?
20:55:13 <dmwit> I think your solution is clever.
20:55:22 <jaredj> ah, thanks
20:55:26 <jcreigh> Are there any Haskell compilers that target the JVM? It would be cool if we could write for Android using Haskell...
20:55:36 <jaredj> groupBy is what i was looking for the whole time
20:55:37 <oerjan> > filter (not . null) . groupBy ((&&) `on` (not . null)) $ ["a", "", "", "b"]
20:55:38 <lambdabot>  [["a"],[""],[""],["b"]]
20:55:52 <dmwit> jcreigh: I thought Android avoided copyright issues by not using the JVM?
20:56:00 <jaredj> i have a bunch of certificates in a file separated by blank lines and i want to split them out to one file each
20:56:03 <jaredj> this is step 1
20:56:04 <oerjan> oh..
20:56:22 <oerjan> > filter (/= [""]) . groupBy ((&&) `on` (not . null)) $ ["a", "", "", "b"]
20:56:24 <lambdabot>  [["a"],["b"]]
20:56:26 <jcreigh> dmwit: they don't use the JVM, but they provide tools to convert .class files to their VM.
20:56:33 <dmwit> ah
20:56:34 <jaredj> :t on
20:56:34 <lambdabot> Not in scope: `on'
20:56:41 <jaredj> ?
20:56:53 <oerjan> it's a @let
20:57:00 <jaredj> a whot?
20:57:02 <jcreigh> so java appears to be the de facto language, even though they don't actually use the JVM on the phone.
20:57:12 <oerjan> only builtin in newest ghc
20:57:14 <dmwit> on (*) f x y = f x * f y
20:57:38 <jaredj> oh k cool
20:57:45 <jaredj> handy
21:01:05 <jaredj> > take 10 [1,2,...]
21:01:05 <lambdabot>  Parse error at "...]" (column 14)
21:01:10 <jaredj> > take 10 [1,2,..]
21:01:10 <lambdabot>  Parse error at "..]" (column 14)
21:01:19 <jaredj> doh how do i do that thing
21:01:32 <jaredj> ah
21:01:36 <jaredj> > take 10 [1,2..]
21:01:38 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
21:01:54 <oerjan> > [1..10]
21:01:54 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
21:02:04 <dmwit> Infinite lists, the new "that thing".
21:02:49 <jaredj> for numbering the files, no matter how many blank-separated pieces the original has
21:03:24 <dmwit> zip [1..] -- an excellent idiom
21:03:25 <oerjan> > zip [1..] "abcdef"
21:03:26 <lambdabot>  [(1,'a'),(2,'b'),(3,'c'),(4,'d'),(5,'e'),(6,'f')]
21:03:32 <jaredj> oui
21:05:29 <dmwit> > zip [10,20..] ["REM just for fun", "IN A", "OUT \"Hello, \", A, \"!\""]
21:05:31 <lambdabot>  [(10,"REM just for fun"),(20,"IN A"),(30,"OUT \"Hello, \", A, \"!\"")]
21:05:39 <jaredj> hehe
21:06:10 <oerjan> :t flip ap zip
21:06:12 <lambdabot> forall b a b1. ([a] -> ([b1] -> [(a, b1)]) -> b) -> [a] -> b
21:11:18 <jaredj> bargh, what's argv called?
21:11:35 <sjanssen> @hoogle getArgs
21:11:36 <lambdabot> System.Environment.getArgs :: IO [String]
21:11:41 <jaredj> ah. ty.
21:13:45 <moconnor> Why is this type decleration illegal: "let x :: a; x = True".  I know x is of type Bool, but saying it's of type "a" seems true enough.
21:14:16 <sjanssen> moconnor: because it isn't true
21:14:19 <oerjan> x :: a means x :: forall a. a
21:14:24 <moconnor> I guess I don't get why it isn't true
21:14:25 <jaredj> <3 irssi
21:14:35 <jaredj> 23:11 -!- Netsplit [...]
21:14:39 <moconnor> oerjan: oh, ok.  That makes sense
21:14:41 <sjanssen> for*all* a. a
21:14:50 <sjanssen> you want exists a. a
21:14:56 <sjanssen> (but Haskell doesn't have this)
21:15:11 <moconnor> heh
21:15:30 <moconnor> okay, I didn't know that forall was implicit there.  Thanks
21:16:05 <sjanssen> also, you can try:
21:16:14 <sjanssen> > True `asTypeOf` (undefined :: a)
21:16:15 <dibblego> @docs foldr
21:16:15 <lambdabot> foldr not available
21:16:19 <lambdabot>  True
21:16:19 <dibblego> @docs List.foldr
21:16:19 <lambdabot> List.foldr not available
21:16:23 <dibblego> @docs Data.List
21:16:24 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
21:17:40 <oerjan> oh, the links work again
21:18:14 <dibblego> indeed!
21:20:11 <oerjan> and there are even source links per function (although the ++ one didn't work properly)
21:21:32 <jaredj> great success!
21:22:34 <hpaste>  jaredj pasted "(no title)" at http://hpaste.org/4427
21:23:00 <jaredj> doh, call it "split_on_blanks.hs"
21:24:41 <oerjan> length args == 0  =  null args
21:25:18 <oerjan> and null has the advantage it only looks at the first cons of the list
21:25:40 <jaredj> ah good. that's my python accent showing through :)
21:26:13 <jaredj> if i'd been writing ruby all this time, i'd have been writing lis.empty?, and i'd have written null in haskell :)
21:26:24 <ddarius> oerjan: It also has the advantage or not requiring the elements of the list to be in class Eq.
21:27:05 <ddarius> Er never mind.
21:27:20 <oerjan> actually that is an issue for == [], not for length ... == 0
21:27:26 * ddarius was thinking of the other bad way of writing null.
21:27:40 <jaredj> gotcha. also good to know
21:28:18 * ddarius was only off by a monoid homomorphism.
21:28:29 <oerjan> heh :)
21:29:14 <shapr> Is it my imagination, or do the monad comprehension examples in Hutton & Meijer's 1996 monadic parsing paper not work in Haskell?
21:29:37 <ddarius> They worked in Haskell at the time.
21:29:49 <shapr> Oh, maybe I've done something wrong.
21:30:14 <ddarius> They could just be broken (i.e. if their translation to do notation doesn't work.)
21:30:42 <sorear> shapr: there are no monad comprehensions in 2007 Haskell
21:37:26 <shapr> mmm code while reading research papers
21:37:57 <shapr> I wish FLM were working, it'd be nice to just download working code for each paper.
21:38:11 <jcreigh> FLM?
21:38:34 <shapr> Fermat's Last Margin is some vaporware I've never finished.
21:38:46 <bos> there's no way to do an "import qualified" equivalent in ghci, right?
21:39:36 <dmwit> :!echo import qualified X as Y > simple.hs
21:39:38 <dmwit> ;-)
21:40:03 <bos> dmwit: :-P
21:40:32 <ivanm> I just saw on reddit that ghc-6.8.2 is out! \o/
21:40:36 <oerjan> bos: i thought qualified identifiers were imported automatically
21:41:00 <bos> oerjan: they are, but I'd like to e.g. import Data.Map as M
21:41:23 <dmwit> Incidentally, importing qualified and importing as are orthogonal.
21:42:00 <jre2> ivanm: notice the motd?
21:42:15 <bos> yes, i know.
21:42:23 <ivanm> jre2: I do now :p
21:42:32 <ivanm> but I only signed on to IRC after I saw the reddit post
21:42:41 <bos> but the point is that i can't get Data.Map under the name M without going through a source file.
21:43:15 <dmwit> bos: Right, I think that's correct.  sorry =/
21:43:59 <bos> no worries
21:48:05 <jre2> does anyone know of existing projects using hsSDL (not openGL)?
21:49:54 <shapr> jre2: maybe @google filetype:hs hsSDL ?
21:50:34 <jre2> shapr: 2 results, both the hsSDL darcs repo
21:50:52 <shapr> oh, too bad.. maybe try filetype:lhs as well?
21:51:41 <jre2> no luck, or with other similiar searches for that matter.  have only found the minor tests in the source tree as examples unfortunately
21:51:59 <ivanm> did you try google's codesearch?
21:52:27 <jre2> ivanm: no dice
21:53:05 <jre2> a few blogs mention hssdl, but it's always just using it along with opengl
21:56:48 <ivanm> @google hssdl -opengl
21:56:51 <lambdabot> http://darcs.haskell.org/~lemmih/hsSDL/
21:56:51 <lambdabot> Title: Index of /~lemmih/hsSDL
21:57:02 <ivanm> heh, don't think that'll help :p
22:07:42 <pierric> how to implement a shell-sort in haskell?
22:08:37 <ricky_clarkson> > repeat "she sells sea shells on the seashore "
22:08:44 <lambdabot>  ["she sells sea shells on the seashore ","she sells sea shells on the seasho...
22:08:51 <sjanssen> pierric: why would you?
22:08:55 <Pseudonym> pierric: The same way you would in any other language, assuming you're using arrays.
22:09:07 <pierric> i just want to have a try
22:09:07 <Pseudonym> (It doesn't make sense to use shell sort on non-arrays.)
22:09:17 <pierric> to see how it will be in haskell
22:09:18 <pierric> :)
22:09:24 <Pseudonym> That's a good reason.
22:09:33 <Pseudonym> In fact, the only good reason, arguably.
22:10:39 <pierric> yeap~. I do write one. But It's quite ugly.
22:11:11 <sjanssen> pierric: there are lots of sorts that look nice in Haskell, you should try one of those
22:11:29 <sjanssen> merge sort and quicksort immediately come to mind
22:11:52 <pierric> i know that quicksort
22:11:56 <sjanssen> there's a neat trick you can do with counting sort and accumArray
22:12:21 <pierric> how?
22:12:32 <sjanssen> do you know counting sort?
22:12:43 <pierric> i don't know that
22:12:53 <pierric> i have to take a look at that first
22:13:01 <sjanssen> http://en.wikipedia.org/wiki/Counting_sort
22:13:01 <lambdabot> Title: Counting sort - Wikipedia, the free encyclopedia
22:13:15 <ricky_clarkson> > map (\xs -> min xs:(filter xs (==min xs))) [3,2,5,6,1]
22:13:17 <lambdabot>      Occurs check: cannot construct the infinite type:
22:13:17 <lambdabot>       a = (a -> a) -> ...
22:13:27 <ricky_clarkson> > (\xs -> min xs:(filter xs (==min xs))) [3,2,5,6,1]
22:13:29 <lambdabot>      Occurs check: cannot construct the infinite type:
22:13:29 <lambdabot>       a = (a -> a) -> ...
22:13:31 <sjanssen> then check out the docs for Data.Array, and see if something comes to mind :)
22:13:52 <ricky_clarkson> > (\xs -> min xs:(filter (==min xs) xs)) [3,2,5,6,1]
22:13:52 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a -> a]
22:13:52 <lambdabot>       Exp...
22:13:54 <sjanssen> ricky_clarkson: argument order on filter
22:14:02 <pierric> thank you, sjanssen
22:14:05 <sjanssen> ricky_clarkson: s/min/minimum
22:14:11 <ricky_clarkson> > (\xs -> min xs:(filter (==minimum xs) xs)) [3,2,5,6,1]
22:14:12 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a] -> [a]
22:14:12 <lambdabot>     Pro...
22:14:20 <ricky_clarkson> > (\xs -> minimum xs:(filter (==minimum xs) xs)) [3,2,5,6,1]
22:14:21 <lambdabot>  [1,1]
22:14:28 <ricky_clarkson> > (\xs -> minimum xs:(filter (/=minimum xs) xs)) [3,2,5,6,1]
22:14:28 <lambdabot>  [1,3,2,5,6]
22:14:54 <sjanssen> > (\xs -> minimum xs:(filter (/=minimum xs) xs)) [1,1,1,3,2,5,6,1]
22:14:55 <lambdabot>  [1,3,2,5,6]
22:15:03 <sjanssen> use Data.List.delete instead
22:15:24 <ricky_clarkson> > let stupid=(\xs -> minimum xs:stupid $ filter (/=minimum xs) xs))) [3,2,5,6,1]
22:15:25 <lambdabot> Unbalanced parentheses
22:15:39 <ricky_clarkson> > let stupid=(\xs -> minimum xs:stupid $ filter (/=minimum xs) xs)) in stupid [3,2,5,6,1]
22:15:40 <lambdabot> Unbalanced parentheses
22:16:59 <dmwit> > let selectionSort xs = minimum xs : selectionSort (delete (minimum xs) xs) in selectionSort [1,1,3,2,5,6,1]
22:17:00 <lambdabot>  Exception: Prelude.minimum: empty list
22:17:45 <dmwit> Hehe, the original one doesn't even sort the list. =P
22:18:48 <dibblego> let f = \xs -> case xs of [] -> []; _ -> minimum xs:(f(delete (minimum xs) xs)) in f [1,1,1,3,2,5,6,1]
22:18:51 <dibblego> > let f = \xs -> case xs of [] -> []; _ -> minimum xs:(f(delete (minimum xs) xs)) in f [1,1,1,3,2,5,6,1]
22:18:51 <lambdabot>  [1,1,1,1,2,3,5,6]
22:19:54 <ricky_clarkson> > let stupid=(\xs -> case xs of [] -> []; _ -> minimum xs:stupid (filter (/=minimum xs) xs)) in stupid [3,2,5,6,1]
22:19:55 <lambdabot>  [1,2,3,5,6]
22:20:54 <ricky_clarkson> @src delete
22:20:54 <lambdabot> delete = deleteBy (==)
22:20:58 <ricky_clarkson> @src deleteBy
22:20:58 <lambdabot> Source not found. Just try something else.
22:21:11 <dmwit> > delete 1 [1,1,2,3]
22:21:11 <lambdabot>  [1,2,3]
22:21:23 <ricky_clarkson> Ah, right.
22:21:29 <ricky_clarkson> > let stupid=(\xs -> case xs of [] -> []; _ -> minimum xs:stupid (filter (/=minimum xs) xs)) in stupid [3,2,5,6,1,1,1,1,1]
22:21:30 <lambdabot>  [1,2,3,5,6]
22:27:57 <rdmltrs> let fac n = []
22:28:00 <rdmltrs> fac 5
22:28:38 <rdmltrs> hmm why didn't that work?
22:28:49 <ricky_clarkson> > let fac n = [] in fac 5
22:28:51 <lambdabot>  []
22:29:07 <rdmltrs> ahh thank you
22:29:08 <ricky_clarkson> Not least because you weren't addressing the bot.
22:29:11 <ricky_clarkson> @quote >
22:29:11 <lambdabot> syntaxfree says: <Bourbaki> the best thing i have ever read in economy is a statement of some guy "i have never met the homo oeconomicus" <syntaxfree> I have never met a catamorphism, either.
22:29:33 <rdmltrs> what's the syntax for addressing the bot?
22:29:38 <dmwit> > "this"
22:29:39 <lambdabot>  "this"
22:29:51 <rdmltrs> >"thanks"
22:29:52 <dmwit> Or, for any other commands, use a ?.
22:30:07 <ricky_clarkson> > "I do "++fix("not know "++)
22:30:08 <lambdabot>  "I do not know not know not know not know not know not know not know not kno...
22:30:10 <dmwit> > "space obligatory =)" -- (
22:30:10 <lambdabot>  "space obligatory =)"
22:30:49 <rdmltrs> very neat
22:31:01 <dmwit> rdmltrs: There's also a whole host of commands that can be accessed, try "?list" to find out what they are.
22:31:02 <ricky_clarkson> It gets better.
22:31:45 <ricky_clarkson> @check \x -> x*2>x :: Float -> Bool
22:31:45 <lambdabot>  Couldn't match expected type `Float -> Bool'
22:32:01 <ricky_clarkson> @check \x -> (x :: Float)*2>x
22:32:02 <lambdabot>  Falsifiable, after 1 tests: -1.5
22:32:16 <Sizur> what does Cxt represent in TH?
22:32:33 <chadz> any lambdabot experts around yet ? :)
22:32:52 <rdmltrs> ?list
22:32:52 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
22:33:00 <lament> @check answer = 42
22:33:00 <lambdabot>  Parse error at "=" (column 8)
22:33:36 <ricky_clarkson> > let (*) _ _=42 in 6*9
22:33:38 <lambdabot>  42
22:33:59 <dmwit> :t showBase
22:34:00 <lambdabot> Not in scope: `showBase'
22:34:09 <ricky_clarkson> @unpl \x y -> 42
22:34:10 <lambdabot> \ x y -> 42
22:34:14 <ricky_clarkson> @pl \x y -> 42
22:34:14 <lambdabot> const (const 42)
22:34:29 <ricky_clarkson> > let (*)=const (const 42) in 6*9
22:34:30 <lambdabot>  42
22:35:04 <Sizur> how can I construct a multiparam InstanceD
22:35:18 <dmwit> > showIntAtBase 13 (\x -> (['0'..'9'] ++ ['a'..'z']) !! x) (6*9)
22:35:19 <lambdabot>  <[Char] -> [Char]>
22:35:45 <dmwit> > let trueShow x = showIntAtBase 13 (\x -> (['0'..'9'] ++ ['a'..'z']) !! x) x "" in trueShow (6*9)
22:35:45 <lambdabot>  "42"
22:36:50 <dmwit> Whoa, hey, Hoogle went v3!
22:47:30 <ricky_clarkson> In hoogle v4, the type system will be enhanced such that hoogle will be able to find itself.
22:48:05 <dmwit> ?hoogle ?hoogle
22:48:06 <lambdabot> No matches, try a more general search
22:48:15 <dmwit> ?hoogle hoogle
22:48:15 <lambdabot> Distribution.Simple.Setup.haddockHoogle :: HaddockFlags -> Bool
22:48:23 <dmwit> eeeexcellent
22:52:51 <ricky_clarkson> @src Distribution.Simple.Setup.HaddockFlags
22:52:52 <lambdabot> Source not found. You type like i drive.
22:53:04 <ricky_clarkson> I guess that is some representation of types, etc.
22:54:54 <lament> You Jane like i Tarzan.
22:55:29 <ricky_clarkson> @bab en es lament
22:55:30 <lambdabot>   laméntese
22:55:59 <ricky_clarkson> @bab en es sit down
22:55:59 <lambdabot>   siéntese abajo
22:56:20 <lament> babelfish is a little daft
22:56:29 <ricky_clarkson> Yes.
22:56:44 <lament> @bab en es be
22:56:45 <lambdabot>   sea
22:56:48 <lament> heh
22:57:09 <ricky_clarkson> @bab en es to be
22:57:09 <lambdabot>   para ser
22:57:17 <ricky_clarkson> no, solo es 'ser'.
22:57:24 <ricky_clarkson> escuchame
22:57:33 <OceanSpray> I still haven't figured out what exactly withCont does
22:58:14 <ricky_clarkson> :t withCont
22:58:15 <lambdabot> forall b r a. ((b -> r) -> a -> r) -> Cont r a -> Cont r b
22:59:49 <dmwit> ?unmtl Cont r a
22:59:50 <lambdabot> (a -> r) -> r
23:00:08 <dmwit> ...
23:00:10 <dmwit> :t runCont
23:00:12 <lambdabot> forall r a. Cont r a -> (a -> r) -> r
23:00:24 <ricky_clarkson> @src Cont
23:00:24 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
23:00:30 <dmwit> What.
23:01:09 <dmwit> I really should figure out what is going on with Cont one day.
23:01:22 <ricky_clarkson> I don't think I can lambdabotpoke this one into shape.
23:01:37 <dmwit> What one?
23:01:56 <ricky_clarkson> I.e., I think I might actually have to know (instead of guess) what's going on here.
23:02:02 <ricky_clarkson> Cont etc.
23:02:21 <ricky_clarkson> @quote Cont
23:02:21 <lambdabot> slava says: I will continue not using Python just as I have been not using it for the last 10 years.
23:02:25 <dmwit> oh, heh
23:03:00 <ricky_clarkson> Yes, but some of those 10 years, shapr was Javaing.
23:03:19 <ricky_clarkson> Oh, slava.  Still, same.
23:03:45 <dmwit> ?quote cont[^a-z]
23:03:45 <lambdabot> No quotes match. My mind is going. I can feel it.
23:03:52 <dmwit> There you have it, no quotes on Cont.
23:09:44 <moconnor> If Foo is a type class is this legal: "instance (Num a) => Foo a where".  I got this from: http://www.haskell.org/haskellwiki/OOP_vs_type_classes#Inheritance_between_instances
23:09:46 <lambdabot> Title: OOP vs type classes - HaskellWiki, http://tinyurl.com/36tj4g
23:10:34 <dmwit> moconnor: Not in H98.
23:14:52 <zou`> does anyone have an example of parsec parsing with long look ahead?
23:15:05 <zou`> like 2 or 3 tokens ahead?
23:15:31 <dmwit> try (string "long lookahead") <|> try (string "long lookafoobar") -- something like this?
23:15:44 <dmwit> Of course, the second try isn't really necessary.
23:16:26 <zou`> the problem with the try is that you have to know how long you'd want to look
23:16:46 <dmwit> Why?
23:17:12 <dmwit> try someArbitrarilyComplicatedParser <|> theOtherOption
23:17:32 <zou`> the pattern is something like "product_name description id"
23:17:43 <zou`> where description could be arbitrarily long
23:18:07 <elad`> data Tree a = Empty | Branch a (Tree a) (Tree a)
23:18:07 <elad`> 	deriving (Show, Eq)
23:18:11 <elad`> cbal :: Int -> Tree
23:18:18 <elad`> What's wrong with this?
23:18:42 <zou`> an example of this would be
23:18:46 <dmwit> cbal :: Int -> Tree Int
23:18:51 <elad`> oh, crap
23:18:53 <elad`> Thanks.
23:19:13 <zou`> "Accord great condition low mileage 1987"
23:19:47 <dmwit> zou`: Got a recognizable end-marker after the id?
23:20:20 <zou`> not really, it could be the end of input or another description
23:20:52 <zou`> think of local paper auto ads posting
23:21:01 <dmwit> In which case, have you got a recognizable beginning-marker before the product_name?
23:21:21 <dmwit> (If not, what you're asking isn't really possible, Parsec or otherwise, without human-level AI. ;-)
23:21:56 <zou`> let's say that the format requires that you have product name as the first word
23:22:13 <zou`> I was afraid of that :)
23:22:27 <dmwit> zou`: So you've already broken them into single entries like that, then?
23:23:11 <zou`> yes, i've managed to break it somewhat like that
23:23:36 <dmwit> Okay, so "id" should always be followed by (a conceptual) eof, right?
23:24:46 <zou`> for similicity, let's assume that, though in reality, it is not always the case
23:25:41 <dmwit> Then we should have no problem:
23:26:18 <dmwit> hmm
23:26:46 <dmwit> Do you even need Parsec in that case?
23:26:54 <zou`> i was thinking something like parse_product_name words* parse_product_id
23:28:24 <dmwit> > let middle = drop 1 . reverse . drop 1 . reverse; triplize xs = (head xs, last xs, middle xs) in triplize ["product is named this", "this is some descriptionary text", "that went on multiple lines", "id32756"]
23:28:26 <lambdabot>  ("product is named this","id32756",["this is some descriptionary text","that...
23:29:56 <dmwit> But let's see how to do it in Parsec...
23:30:33 <dmwit> You want something like this, probably:
23:31:38 <dmwit> descAndID = try (id >> eof) <|> (singleWord >> descAndID) -- conceptually good, but needs some tweaking
23:32:29 <dmwit> Well... "id" isn't such a great name for a parser, since it conflicts with a Prelude function, but you get the idea.
23:33:24 <zou`> i was thinking about parsec because of its permute combinator
23:33:39 <OceanSpray> aaargh
23:33:53 <zou`> as the desc, id, and product_name could be some what random
23:34:35 <dmwit> zou`: Your format seems a bit ill-specified... =P
23:34:58 <OceanSpray> I have f :: LispVal -> ErrorT LispErr (ReaderT LispEnv (ContT (Maybe LispVal) IO)) (Maybe LispVal)
23:35:14 <zou`> yes, it's not strictly BNF
23:35:23 <OceanSpray> and I have a continuation (Maybe LispVal -> Maybe LispVal)
23:35:38 <OceanSpray> how do I get it 'into' that function?
23:36:12 <zou`> however, that's the nature of the "local for sale ads"
23:36:26 <zou`> i was afraid that it needs "AI"
23:37:32 <zou`> dmwit: what is the triplize in the code?
23:37:41 <zou`> :t triplize
23:37:43 <lambdabot> Not in scope: `triplize'
23:38:44 <shachaf> OceanSpray: Have you considered using MaybeT, by the way?
23:38:46 <dmwit> I just made it up, see it defined in the "let" clause right before that?
23:38:50 <shachaf> OceanSpray: (And a type alias?)
23:39:35 <OceanSpray> shachaf, I can't use MaybeT because I don't want my Nothings to propagate up
23:39:55 <OceanSpray> each Nothing match could result in different error messages, or no error at all.
23:40:32 <zou`> ah, ok, neat
23:41:05 <dmwit> :t join
23:41:07 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
23:41:17 <zou`> dmwit: here are a couple of examples
23:41:21 <zou`> 2001 Acura CL with navigation silver exterior and black interior
23:41:36 <zou`> and
23:41:37 <zou`> Infiniti G35 Coupe 2003 2K UNDER BLUE-BOOK!
23:41:44 <dmwit> :t join (.)
23:41:45 <lambdabot> forall b. (b -> b) -> b -> b
23:42:02 <zou`> note that the product name and year are in different positions
23:42:16 <dmwit> :t join (.) (reverse . drop 1)
23:42:17 <lambdabot> forall a. [a] -> [a]
23:42:33 <dmwit> zou`: If you knew it was going to be a year, why didn't you say so? =P
23:42:51 <zou`> that's just an example
23:43:13 <dmwit> Here comes my favorite question:
23:43:18 <dmwit> What are you trying to do?
23:43:33 <zou`> i'm trying to parse local ads
23:43:43 <zou`> such as the two examples above
23:43:52 <dmwit> No, no, no.  That's the local goal.
23:43:56 <dmwit> What's the Big Idea?
23:44:28 <dmwit> Are you trying to find a car for yourself, or trying to find the most common word used in ad descriptions, or measure the mean time to completion of an ad, or...?
23:45:12 <zou`> find a car for myself w/o having to check each of those ads
23:47:07 <dmwit> right
23:47:38 <dmwit> So, the things you want to pick out are like year, company, and model (I guess?).
23:48:07 <zou`> and mileage if it's posted
23:48:17 <dmwit> If you restrict yourself that way, it will help a lot, since it's a lot clearer what the parser "year" should do than waht the parser "ID" should do. =)
23:48:31 <dmwit> Sure, and mileage, why not.
23:48:46 <dmwit> My approach would be:
23:49:51 <dmwit> Start with dumb parsers for "year" (any four-digit number, say), "mileage", "company" (any of the strings "Infinity", "Ford", whatever), and "model".
23:50:02 <dmwit> Then run it on a bunch of different ads, and see which ones it didn't handle.
23:50:36 <dmwit> It won't take many iterations to get a parser that handles 90% of them, and filling in the last 10% by hand is way less work than filling in all 100%. =)
23:51:58 <zou`> that's what i tried, for example
23:52:06 <zou`> my year parser is something like
23:52:08 <zou`> yearp = do {
23:52:08 <zou`>   ds <- try (count 4 digit) <|> count 2 digit
23:52:08 <zou`>   ;return ds
23:52:09 <zou`>   }
23:52:12 <zou`>   <?> "error parsing year"
23:52:16 <zou`>  
23:52:51 <zou`> but the problem is that how do i apply each parser and ignore/drop all other descriptions, etc
23:53:05 <zou`> hence my original question of long-lookahead
23:56:17 <shapr> ricky_clarkson: So what language should I try next? What's the most commercial language of them all?
