00:29:31 <goltrpoat> ok, who broke programming.reddit?  it suddenly started coming up with interesting links.
00:38:55 <reqamst> Programming.reddit works fine.
00:47:09 <goltrpoat> im sorry to hear that (i think)
00:50:48 <Jomyoot> What's a good web engine for Haskell?
00:50:58 <Jomyoot> I want to try to puttogether a quick blog
00:53:10 <audreyt> HAppS surely?
00:53:13 <audreyt> or WaSH
00:53:24 <audreyt> Jomyoot: http://happs.org/HAppS-Begin/public/index.html
00:53:24 <lambdabot> Title: How To Make a blog using HappS
01:13:14 <hpaste>  mdmkolbe pasted "Lazy puzzle" at http://hpaste.org/4649
01:20:37 <Jomyoot> do you guys think the release of F# will make Ocaml a bit more active/popular?
01:21:48 <Mr_Awesome> what does that have to do with haskell?
01:21:51 <opqdonut> nah
01:21:54 <opqdonut> probably won't
01:22:07 <Mr_Awesome> i dont like F# anyway
01:22:39 <sjanssen> Mr_Awesome: why don't you like it?
01:22:49 <Jomyoot> deciding between ocaml vs. haskell now
01:23:02 <Mr_Awesome> sjanssen: no good reason. microsoft just annoys me
01:23:06 <lament> haskell? :)
01:23:08 <Cin> jomyoot: what problem are you trying to solve?
01:23:22 <Jomyoot> number crunching
01:23:26 <Mr_Awesome> and theres the fact that after learning haskell i dont really want to use any other language :)
01:23:27 <Jomyoot> needs something faster than Ruby I am using
01:23:29 <sjanssen> Mr_Awesome: guess who funds most GHC work :P
01:23:30 <goltrpoat> jomyoot:  probably will
01:23:39 <opqdonut> Jomyoot: ocaml might be marginally faster
01:23:49 <Mr_Awesome> sjanssen: really? i didnt know
01:23:52 <opqdonut> but haskell might have better libs
01:24:00 <opqdonut> depending on the specific type of cruching
01:24:08 <Jomyoot> Speed of Ocaml vs. Haskell is none issue for me. but I am interested in getting into language that will be more popular 2-3 years from now
01:24:17 <Jomyoot> As of now, Haskell is definitely more pouplar
01:24:26 <Jomyoot> but wondering if M$ will cause difference with F#
01:24:29 <goltrpoat> jomyoot:  supposedly, ms is making it a first-class language in the .net suite for some post-2008 release, so that'll help ml-derived languages in terms of visibility, if anything
01:24:53 <sjanssen> Mr_Awesome: yes, the two primary contributors to GHC work at Microsoft Research
01:24:54 <goltrpoat> i don't see f# as competing with haskell in any meaningful way, though
01:25:00 <goltrpoat> (jon harrop may disagree)
01:25:13 <sjanssen> Mr_Awesome: though I'd say Microsoft is much less involved with GHC than F#
01:25:27 <Cin> jon harrop spams the hell out of comp.lang.lisp. what an annoying man
01:25:33 <Mr_Awesome> sjanssen: doesn't really matter to me, as long as they don't exert a negative influence
01:26:06 <goltrpoat> cin:  i'm surprised he's so tame on haskell-cafe
01:26:32 <opqdonut> Jomyoot: i definitely recommend learning both
01:26:34 <Cin> heh
01:26:39 <opqdonut> and then concentrating on haskell ;)
01:26:45 <Jomyoot> i wish i had all the time in the world
01:26:54 <Jomyoot> i am already well spent in Ruby
01:26:56 <Jomyoot> and Rails
01:27:23 <Cin> is there anything novel in ruby that would actually make it hard to learn?
01:27:24 <Mr_Awesome> opqdonut: i dont know, what could he learn from ocaml that he couldnt from haskell?
01:27:27 <johnnowak> you won't be able to spend another minute with ruby anyway after learning either
01:27:45 <opqdonut> Mr_Awesome: well if he wants to be sure he can jump on the ml train when it heads for fame
01:27:51 <goltrpoat> jomyoot:  haskell and ocaml have the same ancestry, being relatively fluent with one means you can at least read the other
01:28:00 <opqdonut> but i think haskell will keep on getting more popular, as will ocaml
01:28:07 <Cin> goltrpoat: like lisp and scheme?
01:28:14 <opqdonut> and haskell is practically a strict superset of ocaml :)
01:28:35 <opqdonut> Cin: even closer than that
01:28:38 <Mr_Awesome> except for the object system and imperative bits
01:28:50 <goltrpoat> cin:  closer than that, if you mean CL and scheme
01:28:51 <johnnowak> and polymorphic variants
01:28:56 <Cin> goltrpoat: right
01:29:51 <Jomyoot> not in terms of purity, but which language Haskell or Ocaml is more suitable for Rapid Development and Prototyping?
01:30:47 <opqdonut> Jomyoot: couldn't really say
01:30:54 <goltrpoat> i use haskell for rapid prototyping a lot, actually.
01:31:06 <opqdonut> haskell has better interactive environments
01:31:15 <opqdonut> that's a definite plus
01:31:24 <goltrpoat> i don't know about ocaml, i don't see why not, but i haven't felt the need to switch
01:31:56 <opqdonut> yeah, the only reason to switch from haskell to ocaml would be the need for raw performance
01:32:05 <Mr_Awesome> one thing that really annoyed me about ocaml, that made it difficult to prototype (for me at least) was the lack of ad-hoc polymorphism
01:32:09 <opqdonut> but event that's kinda moot nowadays with ghc producing so good code
01:32:18 <Mr_Awesome> if im using that correctly
01:32:37 <Mr_Awesome> having to use different operators for each type of number always got in the way
01:33:04 <Mr_Awesome> and a different print function for every type
01:33:44 <goltrpoat> someone on the f# list asked what a haskell fib function that was polymorphic over Num would look like in f#
01:33:54 <goltrpoat> and, well, got the two separate specializations for ints and bigints
01:34:16 <opqdonut> Mr_Awesome: yeah, in a well-coded haskell program one can change the numeric type used in one place and stuff just workd
01:34:21 <opqdonut> -s+d
01:34:25 <goltrpoat> and then the guy who posted those kept insisting that this is a good thing.  it was cool.
01:34:39 <opqdonut> ;D
01:35:01 <Mr_Awesome> proponents of ml always insist that it's a good thing. and i strongly disagree
01:35:11 <opqdonut> me too
01:35:23 <opqdonut> tho that's kinda obvious as we are on this channel
01:35:28 <opqdonut> :P
01:35:28 <Mr_Awesome> heh
01:38:24 <goltrpoat> i've only ever heard arguments as to why it's a good thing, when it's opposed to implicit casting
01:38:28 <goltrpoat> which.. no argument there.
01:38:56 <goltrpoat> this guy was confusing implicit casting with polymorphism though
01:41:21 <goltrpoat> jomyoot:  to sum up, learn both, if for some reason you can only allot time for one, then learn haskell.  obviously we're biased though.
01:46:16 <lament> learn haskell because it has a far better irc channel
01:51:41 <Modius> Is there a haskell global variable that represents an infinite list from 0 +?
01:51:53 <Cin> [0..] ?
01:52:00 <Cin> oh, variable. sorry
01:53:02 <desegnis> Well, what would be variable about [0..]?
01:53:04 <sjanssen> Modius: no.  In fact, it's better to use "[0..]" than a global variable, due to sharing of global constants
01:53:14 <Modius> Acknowledged, thanks, all
01:53:33 <roconnor> stupid space leaks
01:55:21 <Cin> desegnis: yeah, i guess 'variable' doesn't have much meaning in haskell
01:56:06 <desegnis> Cin: Well you can call a symbol bound by a lambda abstraction “variable”.
01:56:07 <roconnor> a variable is something that doesn't change.
01:56:11 <roconnor> :)
01:56:42 <desegnis> Cin: Except if it is of type () ;)
01:56:46 <Mr_Awesome> iorefs are sort of like variables
01:57:38 <Cin> roconnor: in its original mathematical meaning?
01:58:30 <Cin> oh. you make joke :P
01:58:53 <roconnor> Cin: half a joke.  But yes, I mean it's mathematical meaning
01:58:55 <goltrpoat> 'variable' has plenty of meaning in haskell
01:59:59 <goltrpoat> you have bound variables, free variables, merely slightly oppressed variables, etc.
02:00:10 <Cin> ah. i'm confusing binding the value of the variable with mutation
02:00:26 <oerjan> @remember goltrpoat you have bound variables, free variables, merely slightly oppressed variables, etc.
02:00:27 <lambdabot> It is stored.
02:00:45 <roconnor> I am not a number, I am a free variable!
02:00:52 <goltrpoat> hehe
02:00:58 <desegnis> Cin, yea, that's the two general meanings you can think of if you hear “variable”.
02:01:06 <Cin> "yes. we're -all- free variables!"
02:01:14 <roconnor> A little joke refering the to use of debruijn indicies for bound variables.
02:01:25 <Cin> desegnis: oki doki
02:02:58 <goltrpoat> roconnor:  but a variable could be free in its enclosing scope, and still have a debruijn index :)
02:03:13 <goltrpoat> in fact, anything that's not a CAF will have one, depending on how far you want to go
02:03:48 <goltrpoat> so it's merely an illusion of freedom.  poor variables.
02:04:40 <roconnor> goltrpoat: in Conor's paper (of this title) bound variables are freed (and then named) when the scope changes and crosses the lambda (or whatever binder) in question.
02:04:59 <roconnor> @go "I am not a number, I'm a free variable"
02:05:00 <lambdabot> No Result Found.
02:05:04 <roconnor> :(
02:05:25 <roconnor> @go "I am not a number, I am a free variable"
02:05:30 <lambdabot> http://www.cs.nott.ac.uk/~ctm/notanum.ps.gz
02:05:36 <Cin> heh
02:06:37 <goltrpoat> roconnor:  oh, i see.  i had to do something similar for a toy scheme compiler -- i was using debruijn indices because it makes for a spiffy stack indexing scheme, but you may end up with continuations and whatnot on the stack at the scope change
02:06:43 <roconnor> Conor and James's paper
02:08:10 <goltrpoat> (of course, this was preceded by all variables renamed to unique names prior to a cps transform, so named variables were still renamed to things like $V12341)
02:11:55 <Modius> Is there a haskell function that returns a boolean sequence, returning one value until some condition is met (against an input list) then locks to returning the other boolean?
02:13:22 <oerjan> > scanl1 (&&) . map isAlpha $ "testing ho"
02:13:25 <lambdabot>  [True,True,True,True,True,True,True,False,False,False]
02:13:57 <goltrpoat> roconnor:  still reading the paper, but i think this is common in scheme and ml compilers:  bound variables in the immediate scope use indices, but the entire closure is passed as extra parameters (tagged as such).  the idea is that this enables both lambda lifting and destination-driven code generation
02:14:38 <oerjan> > scanl1 (||) . map isSpace $ "testing ho"
02:14:39 <lambdabot>  [False,False,False,False,False,False,False,True,True,True]
02:15:41 <roconnor> oerjan: nice
02:15:45 <oerjan> Modius: ^^
02:15:53 <Modius> oerjan:  Thanks!
02:23:11 <goltrpoat> haha jesus.  picking F as the data constructor for free variables was either intentional, or very, very, unfortunate.
02:24:06 <oerjan> Why can't it be both? </dogbert>
02:25:38 <roconnor> F me
02:26:00 <goltrpoat> what'sB this (F you) = F you
02:26:32 <Cin> F theMan
02:27:11 <goltrpoat> i don't fully follow their naming type
02:27:37 <goltrpoat> normally you want to decorate those as much as you can, but you'll want to pattern match on that decoration
02:28:51 <goltrpoat> while knowing how far down the scope you are, isn't usually a concern, unless i'm missing something
02:32:31 <goltrpoat> oy.  didn't realize this was in the context of epigram
02:33:17 <goltrpoat> makes my pedestrian "stack" and "continuation" concerns mostly inapplicable, i'd imagine.
02:38:12 <goltrpoat> roconnor:  cool paper, thanks.
02:38:28 <goltrpoat> i'll have to re-read it a second time, i apparently have compilation on my brain
02:56:31 <Beelsebob> is there a drop in replacement for Data.PackedString
02:56:57 <Beelsebob> i.e. I have someone else's code that relies on it, and don't particularly fancy modifying it all to get it running
02:57:03 <Beelsebob> what's the best approach to get it going
02:59:37 <firefly> use bytestring.
02:59:46 <goltrpoat> not exactly drop-in, that
03:00:27 <Beelsebob> is bytestring for the most part function-for-function identical?
03:00:28 <goltrpoat> although, the names are close enough that you could just search and replace most of them
03:00:35 <Beelsebob> :/
03:00:50 <Beelsebob> as I said, I really don't fancy modifying this
03:01:14 <Beelsebob> it essentially comes down to modifying the *whole* of nhc, and there's no way that that's gonna come out right in the end
03:01:33 <goltrpoat> it's mostly like..  remove the PS suffix and add a BS. in front, assuming you're importing ByteString.Whatever as BS
03:01:43 <goltrpoat> oh
03:01:47 <goltrpoat> yikes.
03:02:06 <Beelsebob> I mean... I've installed PackedString from Hackage
03:02:15 <goltrpoat> put the conversions in a module and import it, replacing PackedString?
03:02:25 <Beelsebob> that's a good idea
03:02:39 <Beelsebob> I may give that a go
03:02:57 <Beelsebob> in that there's already a module for "how to deal with all the different things different versions of ghc do"
03:03:06 <goltrpoat> heheh
03:03:30 <goltrpoat> good place to put it, then.
03:08:33 <goltrpoat> actually, an alternative might be to write a PackedString module, have it declare PackedString as a type synonym, write all the *PS functions in there in terms of ByteString functions, and put it somewhere that will get resolved before PackedString
03:08:48 <goltrpoat> no need to modify the source that way
03:09:12 <goltrpoat> no idea what effect that will have on optimization, though
03:15:02 <Beelsebob> @ho Word8 -> Char
03:15:03 <lambdabot> Maybe you meant: hoogle hoogle+ . ? @ bf echo ft ghc id pl rc show thx v wn yow
03:15:11 <Beelsebob> @hoogle Word8 -> Char
03:15:12 <lambdabot> Data.ByteString.Internal.w2c :: Word8 -> Char
03:15:36 <Beelsebob> @hoogle [Word8] -> String
03:15:37 <lambdabot> No matches, try a more general search
03:15:53 <Beelsebob> :/
03:16:06 <Beelsebob> is there an official way to get from bytes to a string?
03:16:07 <oerjan> :t map Data.ByteString.Internal.w2c
03:16:09 <lambdabot> Couldn't find qualified module.
03:16:33 <Beelsebob> sure, that's the obvious way to do it, but the word Internal in there has me worried
03:16:36 <goltrpoat> > chr (fromEnum (65 :: Word8))
03:16:37 <lambdabot>  'A'
03:16:50 <Beelsebob> ah, cool
03:17:00 <xmasZsoL> :t chr
03:17:01 <lambdabot> Int -> Char
03:17:05 <oerjan> @src chr
03:17:06 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
03:17:41 <xmasZsoL> lambdabot, i dont like your comments :P
03:17:45 <oerjan> she knows about the electro-shock.  she must be eliminated.
03:17:50 <goltrpoat> haha
03:17:51 <opqdonut> :D
03:19:04 <Beelsebob> hmm... is Data.ByteString part of ghc 6.8 by default?
03:19:12 <Beelsebob> or do I need to import packages?
03:19:57 <goltrpoat> well.. you'll need to import it whatever you do, but i think it's included with 6.7 and up (could be wrong -- i'm still on 6.6)
03:19:58 <oerjan> package bytestring
03:20:42 <xmasZsoL> afaik you have to import it
03:22:37 <oerjan> Beelsebob: it's a boot library, so should always be included
03:23:42 <goltrpoat> i remember i had to install BS here with 6.6, and ByteString.Lazy was (at least at the time) broken on windows
03:24:02 <goltrpoat> then my debian laptop gave up the ghost, taking 6.7 and ByteString.Lazy with it
03:24:14 <hpaste>  (anonymous) pasted "beelsebob" at http://hpaste.org/4650
03:24:33 <Beelsebob> that's both with and without -package bytestring
03:25:52 <Beelsebob> wait no, I'm a noob
03:25:58 <Beelsebob> it's with -backage bytestring
03:26:01 <Beelsebob> :D
03:26:09 <oerjan> useful flag, that.
03:26:33 <oerjan> always use it for all your backing.
03:26:41 <xmasZsoL> :-)
03:26:49 <goltrpoat> a -package for the discriminating backer.
03:26:50 <Beelsebob> backaging, surely :P
03:30:01 <hpaste>  beelsebob pasted "packedStrings" at http://hpaste.org/4651
03:30:06 <goltrpoat> #scheme appears to be completely dead.
03:30:17 <goltrpoat> MY EYES.
03:30:19 <Beelsebob> anyone able to see why that module apparently doesn't export PackedString?
03:30:34 <oerjan> i see - dead people
03:30:40 <oerjan> 121 of them, to be precise
03:32:20 <goltrpoat> beelsebob:  what's __GLASGOW_HASKELL__ on your machine, 608?
03:32:23 <goltrpoat> or 0x608
03:32:24 <Beelsebob> yep
03:32:30 <Beelsebob> should be 608
03:33:01 <goltrpoat> does PackedByteString exist?
03:33:11 <Beelsebob> yeh, it's pasted at the bottom there
03:33:14 <oerjan> Beelsebob: note that even if you reexport the _contents_ of an imported module, it is still qualified with the exporting module name, i think
03:33:42 <goltrpoat> ohh
03:33:55 <Beelsebob> hmmm? I don't quite get what you mean oerjan
03:34:09 <Beelsebob> it's reexported as being called PackedByteString?
03:34:24 <goltrpoat> yeah, i don't think that's true though
03:34:35 <oerjan> if SysDeps exports it, it will be as SysDeps.whatever?
03:34:49 <Beelsebob> I thought that was only if you imported qualified
03:35:01 <Beelsebob> (import qualified SysDeps (PackedString))
03:35:16 <oerjan> um this PackedString is a data type?
03:35:22 <Beelsebob> no
03:35:24 <Beelsebob> a module
03:35:26 <goltrpoat> no, he's importing a module
03:35:35 <oerjan> i don't you can import a module
03:35:40 <hpaste>  (anonymous) annotated "packedStrings" with "(no title)" at http://hpaste.org/4651#a1
03:35:42 <oerjan> *submodule
03:35:46 <Beelsebob> That's the code that imports it
03:35:48 <goltrpoat> ?
03:36:50 <oerjan> what i mean is, the module PackedString in the export list exports everything imported from PackedString, but _seamlessly_ as part of SysDeps
03:37:03 <oerjan> the module name is completely lost
03:37:08 <vincenz> what's with all the silence
03:37:19 <vincenz> #lua is completely silent, #scheme is completely silent, #oasis is completely silent
03:37:30 <vincenz> Has noone read the latest xkcd!?
03:37:36 <Beelsebob> oh, I see
03:37:45 <goltrpoat> oerjan:  you're saying, the import site says something like import SysDeps; x :: SysDeps.PackedString.PackedStringStuff, and the resolution doesn't go to PackedStringStuff?
03:37:59 <Beelsebob> so I need to dump type PackedString ByteString into PackedByteString
03:38:15 <goltrpoat> oerjan:  because that's not true
03:38:40 <ivanm> vincenz: are you saying that only haskellers are real coders/hackers?
03:38:56 <oerjan> goltrpoat: the hierarchical module names are _not_ resolved piece-by-piece
03:39:13 <vincenz> ivanm: *peers around suspiciously* Don't spread the secreet
03:39:26 <ivanm> heh
03:39:28 <oerjan> SysDeps.PackedString.PackedStringStuff refers to something in module SysDeps.PackedString, which is _not_ a submodule of SysDeps
03:39:33 <Beelsebob> thanks oerjan
03:39:36 <Beelsebob> that works fine
03:39:48 <ivanm> vincenz: who would I spread it to? only the haskellers are around! :p
03:39:51 <Beelsebob> sorry for the brain freeze moment
03:40:52 <oerjan> the dots in hierarchical module names usually turn directly into directory separators (e.g. /)
03:41:37 <goltrpoat> oerjan:  module Parser where import Parser.Lexer; import Parser.Syntax; import Parser.Utils; ... and import Parser; x = Parser.Syntax.something
03:41:48 <Beelsebob> o.O
03:41:52 <goltrpoat> works fine here, not sure what you're talking about.
03:41:52 <Beelsebob> what's happened to Data.Set
03:42:47 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/4652
03:42:49 <Beelsebob> that
03:42:57 <Beelsebob> splode apparently :/
03:43:08 <oerjan> goltrpoat: i am talking about the module SysDeps (module PackedString) where ... used in the paste
03:43:32 <goltrpoat> beelsebob:  i vaguely remember from some cafe traffic that Data.Set got moved somehow, but i could be making this up
03:43:35 <vincenz> rexporting modules exports them in the namespace of the module that is doing the export
03:43:38 <vincenz> Not the module that is exportd
03:44:24 <oerjan> import SysDeps then does not give you a PackedString module name, neither alone or qualified with SysDeps
03:44:30 <vincenz> module Foo(module Foo.Bar); import Foo.Bar
03:44:39 <vincenz> exports Foo.Bar's stuff as part of Foo's stuff
03:44:59 <vincenz> And Bar is no longer used
03:45:05 <goltrpoat> oerjan:  you're saying that A.B.C is a single module identifier, with no particular affiliation to A, B or C.
03:45:22 <goltrpoat> ?
03:45:26 <vincenz> module Foo(module Foo.Bar) where import Foo.Bar <^D> module Foo.Bar where x :: 0; x = 0
03:45:38 <vincenz> you can now access it as Foo.x not as Foo.Bar.x
03:45:43 <vincenz> I think that's what oerjan is saying
03:45:51 <vincenz> mporting Foo does not give you a Bar
03:45:58 <vincenz> it gives you the contents of Foo.Bar
03:46:06 <oerjan> goltrpoat: exactly
03:46:20 <goltrpoat> so basically we've been talking about the same thing all along.
03:46:28 <oerjan> funny that :)
03:46:34 <vincenz> violent agreement :)
03:46:39 <goltrpoat> hehe
03:47:15 <Beelsebob> goltrpoat: any idea when that happened, I don't see it in the archives
03:47:18 <oerjan> Beelsebob: you may want to look at the 6.8.1 release notes, there is a list of things that have moved.
03:47:27 <Beelsebob> course there is
03:47:31 <Beelsebob> *goes and pokes it*
03:48:19 <vincenz> Beelsebob: package 'containers'
03:48:27 <Beelsebob> cheers
03:48:28 <vincenz> 1.4.4.5. containers in the release notes
03:49:20 <oerjan> @docs
03:49:21 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
03:49:35 <oerjan> ^^ also the package name given beside each module in there
03:49:38 <Beelsebob> sry, my bad for not rtfm
03:51:50 <Beelsebob> o.O I *think* it compiled
03:53:10 <Beelsebob> bloody hell, it all worked!
03:56:14 <goltrpoat> all's well that ends well.
03:58:56 <vincenz> @users
03:58:57 <lambdabot> Maximum users seen in #haskell: 434, currently: 366 (84.3%), active: 7 (1.9%)
03:59:12 <vincenz> > replicate 366 "Happy X-mas!"
03:59:13 <lambdabot>  ["Happy X-mas!","Happy X-mas!","Happy X-mas!","Happy X-mas!","Happy X-mas!",...
03:59:29 <Beelsebob> thanks to everyone
04:00:18 <zx]treads> :D
04:00:51 <b_jonas> > concat it
04:00:52 <lambdabot>   Not in scope: `it'
04:00:59 <b_jonas> meh, it's not like ghci
04:01:03 <vincenz> > unwords $ replicate 366 "Happy X-mas!"
04:01:03 <lambdabot>  "Happy X-mas! Happy X-mas! Happy X-mas! Happy X-mas! Happy X-mas! Happy X-ma...
04:01:10 <goltrpoat> No instance for (Christian a) arising from the literal "Happy X-mas!" at <interactive>:1:1
04:01:21 <goltrpoat> Possible fix: add an instance declaration for (Christian a)
04:03:17 <ari> b_jonas: Cool, I didn't know about it before
04:03:21 <ari> b_jonas++
04:04:57 <vincenz> instance Christian goltrpoat where
04:05:01 <goltrpoat> haha
04:05:02 <vincenz>   baptism = burn
04:05:26 <goltrpoat> ah, but now i'm a type variable.
04:05:29 <goltrpoat> joke's on you.
04:05:34 <ari> faith = error "not implemented"
04:05:42 <vincenz> pray = scuff knees
04:06:05 <vincenz> instance (Annoying goltrpoat) => Christian goltrpoat where ...
04:06:56 <goltrpoat> better, although now you're saying that whenever there is a goltrpoat who's annoying, he is also christian.
04:07:31 <goltrpoat> i think you want a forall in there somewhere.
04:07:48 <goltrpoat> or just make me a constructor and get it over with.
04:13:00 <sjanssen> goltrpoat: the forall is implicit
04:13:56 <goltrpoat> pfft.
04:14:01 <sjanssen> well, it is
04:14:10 <sjanssen> you can't stick a forall in an instance declaration
04:15:01 <goltrpoat> ok, i'm confused.  are we talking about me or haskell now.
04:15:15 <sjanssen> Haskell
04:15:49 <goltrpoat> ok, i was leaning on the implicit exists, there.
04:16:25 <goltrpoat> as it is, i maintain the type is not inhabited.
04:16:45 <oerjan> case religion goltrpoat of HeathenScum a -> ...
04:16:51 <sjanssen> there are no instances of Annoying?
04:16:53 <goltrpoat> (but i can't really do that as a type variable)
04:17:01 <goltrpoat> so you see my conundrum.
04:17:31 <Associat0r> hey goltrpoat
04:17:48 <goltrpoat> howdy.
04:18:12 <Associat0r> not on flipcode anymore?
04:18:30 <goltrpoat> there's still a flipcode? :)
04:18:44 <oerjan> he thought he'd blown it up
04:19:02 <goltrpoat> site's dead, and the channel has three people i still talk to
04:19:07 <goltrpoat> who are never on.
04:19:21 <Associat0r> that is true
04:20:05 <Associat0r> have you been looking into F# btw?
04:20:48 <goltrpoat> i've played with it here and there.  been meaning to revisit it, since most of our toolchain is .net anyway
04:21:57 <goltrpoat> i have to write an animation post tool some time soon, was going to do it in F#
04:22:20 <Associat0r> how do you like it compared to haskell?
04:22:31 <Associat0r> and ocaml
04:22:59 <goltrpoat> the only thing i've done in it that was of any size whatsoever was porting parsec to it.  that sucked.
04:23:23 <goltrpoat> it was hardly idiomatic ocaml though
04:24:31 <goltrpoat> (the reason it sucked was because of the sheer amount of delay/force crap i had to add to what would've been lazy statements by default)
04:25:12 <Associat0r> yeah it is kinda ugly
04:25:23 <Associat0r> the lazy stuff
04:26:15 <goltrpoat> i suspect it'd be less painful if i were to revisit it now.  not sure though.
04:28:36 <Associat0r> are you doing any real work with haskell?
04:28:53 <goltrpoat> yes, in several ways
04:29:14 <Associat0r> like?
04:30:17 <goltrpoat> one is a compiler for a rendering language with a RAD frontend -- the idea is to have composable renderers, and abstract platform-specific stuff as much as possible
04:30:41 <goltrpoat> the backend is entirely in haskell, and the language itself is basically haskell.
04:31:20 <Associat0r> nice, do you even touch C++ these days?
04:31:31 <goltrpoat> heh yeah, daily.
04:31:55 <goltrpoat> we're balancing in-house tech development and contract work
04:33:18 <goltrpoat> ok, maybe not daily.  i don't think i've written a line of c++ in a week or so.
04:33:37 <goltrpoat> (written a boatload of c# though!)
04:33:39 <goltrpoat> heh
04:34:16 <Associat0r> I am kinda exploring functional stuff these days
04:38:33 <goltrpoat> get prepared to start confusing c++ people with your c++ code.
04:39:53 <goltrpoat> i'm working on a biggish c# system right now, and c# actually has first class closures.  i expect a gigantic wtf from the rest of the team once i check in.
04:40:02 <goltrpoat> blah, he left.
04:41:26 <Associat0r> damn freeze
04:41:39 <goltrpoat> last week, i discovered that c# has coroutines.
04:42:34 <ricky_clarkson> Do the language designers know?
04:43:06 <BaY_GeVeZe> WhaT
04:43:12 <BaY_GeVeZe> I can't speak english
04:43:15 <BaY_GeVeZe> No engLish :D
04:43:21 <BaY_GeVeZe> :)
04:43:30 <goltrpoat> dunno, there's a keyword for it.  it's a toss-up between "they know" and "holy crap, how'd that happen."
04:43:42 <scook0> @pl \xs -> zip xs [0..]
04:43:43 <lambdabot> flip zip [0..]
04:43:50 <Associat0r> I am sure they know
04:44:05 <Arnia> Remember who designed the Common Language Infrastructure
04:44:07 <goltrpoat> could be why there's a keyword for it.
04:44:17 <Associat0r> channel9 has some good discussion with the designers
04:44:22 <Associat0r> and their future intent
04:44:31 <ricky_clarkson> Yeah, they're smart guys, I was just joking.
04:45:20 <goltrpoat> arnia:  dunno, anders hejlsberg? :)
04:45:29 <goltrpoat> i don't think he designed the CLI though.
04:46:20 <Arnia> goltrpoat: well, several members of the GHC team were involved I believe
04:47:22 <goltrpoat> arnia:  oh, didn't realize that.  i could see erik meijer being involved, but i looked him up and it doesn't seem like he was
04:47:51 <Arnia> He's working on the LINQ stuff I think
04:48:44 <goltrpoat> looks like it
04:49:33 <Associat0r> I am not sure who did what exactly
04:50:45 <Arnia> The way I heard it characterised (by an SPJ video) is that Haskell is working at the problem of purity from one end, and C# from another and they're trying to both work towards Nirvana helping each other along the way
04:50:57 <goltrpoat> i do specifically remember don syme talking about the CLR being completely unsuited to dictionary passing, though
04:52:38 <goltrpoat> although, i didn't fully understand the argument then.
04:53:37 <goltrpoat> had something to do with interop issues.
04:58:49 <goltrpoat> (note to self:  never mention don syme in this channel again)
05:00:44 <Associat0r> why?
05:01:02 <goltrpoat> because apparently it kills the conversation for a good 10 minutes? :)  i was kidding.
05:01:36 <Associat0r> I have not much to add to the CLR stuff, I am not very familiar with it
05:02:16 <Associat0r> I come from a native world
05:02:39 <Associat0r> goltrpoat : how do you see the future of .NET gamedev?
05:05:34 <goltrpoat> i think we'll keep moving to more modern languages on the tools side, for the next cycle
05:06:20 <goltrpoat> i think the cycle after that will have more cores than you typically have threads, and people will start to panic.
05:07:21 <goltrpoat> i don't know how .net plays into that, really.
05:08:42 <Associat0r> what about openmp for native stuff?
05:09:45 <goltrpoat> well, my point was that task-level parallelism will stop making sense at some point
05:10:04 <goltrpoat> i don't know what to do with 80 threads in c++, honestly.
05:10:50 <goltrpoat> say they're all hardware threads, i'll pool them into chunks of 10, say, and try to round-robin the tasks.
05:11:44 <goltrpoat> doesn't sound like the most efficient way of doing things.
05:13:34 <Associat0r> you can't do it all kinds of code
05:13:39 <Associat0r> that is the problem
05:14:07 <goltrpoat> but, game developers are certainly used to parallel arrays, in a limited settings.  so for all i know, we'll all end up with a gigantic c++ library emulating fortran.
05:14:44 <goltrpoat> i'm hoping we'll all just switch to haskell or ocaml, but considering how far behind the curve gamedev is (compared to SIGGRAPH, say), i'm not holding my breath
05:15:03 <goltrpoat> settings=setting
05:15:31 <Associat0r> I read some stuff about systems haskell for low level stuff
05:15:57 <Associat0r> also clean is pretty fast, I wonder why gamedevs didn't take notice
05:16:44 <goltrpoat> well, same reason why it takes 5 years for things to filter from SIGGRAPH into a bite-sized GDC presentation and then another 2 years for someone to ship a title using the tech
05:17:00 <dons> ?users
05:17:00 <lambdabot> Maximum users seen in #haskell: 434, currently: 366 (84.3%), active: 6 (1.6%)
05:17:54 <oerjan> tim sweeney takes notice... he's a game developer frequently posting on the lambda-the-ultimate PL blog
05:18:04 <Associat0r> also people want their curly braces
05:18:41 <Associat0r> yeah but the majority don't
05:19:11 <Associat0r> but it isn't just gamedevs that are the problem
05:19:14 <goltrpoat> and the impression i got from tim's ppt that was making the rounds a while back, was that his familiarity with haskell was somewhat fleeting, at least at the time
05:20:09 <Associat0r> we are being spoonfed with imperative
05:20:34 <goltrpoat> heh
05:20:44 <Associat0r> people just want to get their stuff done
05:22:12 <goltrpoat> when i was young and naive, i was the physics lead on a biggish title.  i wrote the engine, but we had some issues with people having to enter a stupid amount of coefficients by hand
05:22:40 <goltrpoat> so i went to the project lead and said, hey, here's an idea.  i could take the texture, compute the entropy, and come up with a reasonable friction coefficient.
05:22:54 <goltrpoat> probably won't work in all cases, but we'd have a decent default value.
05:23:10 <goltrpoat> his response was "hehe, yeah, maybe on the next project."
05:24:05 <goltrpoat> that took me some time to figure out, but then i realized that there was no good reason for him to care
05:24:19 <goltrpoat> didn't make him look good, didn't make the engineering department look good, didn't make the art department look bad.
05:24:36 <goltrpoat> and that's basically how this industry works.
05:25:09 <roconnor> goltrpoat: ... It probably isn't so hard to compute the entropy of a texture.
05:25:16 <goltrpoat> it's a loop.
05:25:16 <roconnor> goltrpoat: sounds like a nice idea
05:25:30 <desegnis> goltrpoat: Did that guy understand what your proposition was?
05:25:36 <goltrpoat> desegnis:  yeah.
05:25:44 <desegnis> hmalright
05:27:13 <roconnor> How does one get from: http://contracts.scheming.org/Contracts.lhs to http://contracts.scheming.org/
05:27:33 <oerjan> backspace key
05:27:55 <oerjan> ( :) )
05:27:58 <roconnor> oerjan: I mean the soure files :)
05:28:14 <roconnor> the HTML is all nicely formated in the second link
05:28:20 <roconnor> and isn't literate HTML
05:28:30 <roconnor> but is presumably generated from Contracts.lhs
05:28:35 <roconnor> which is literate haskell
05:28:45 <goltrpoat> it's not generated from it, it's the same source
05:28:55 <Saizan> the html is in the comments
05:29:42 <goltrpoat> as in, renaming Contracts.lhs to index.html will do the job
05:29:53 <roconnor> goltrpoat: downloawd the two files and run diff
05:30:01 <roconnor> download
05:30:27 <roconnor> the sources are different
05:32:31 <goltrpoat> i'm diffing it
05:32:49 <goltrpoat> and they're different in the sense that.. the .lhs has </head></body> on separate lines while the .html has them on one line
05:33:09 <goltrpoat> and the hrefs are different
05:33:21 <goltrpoat> ohh
05:33:41 <goltrpoat> i'll shut up now (no idea, sorry)
05:35:09 <goltrpoat> i think i was using hscolour for my stuff, but i don't remember it handling literate haskell very well
05:35:34 <goltrpoat> of course i haven't posted anything in a good year, so maybe things have improved.
05:35:50 <roconnor> > cos 1
05:35:51 <lambdabot>  0.5403023058681398
05:36:58 <roconnor> > 1 - cos 1
05:36:59 <lambdabot>  0.4596976941318603
05:38:09 <goltrpoat> so i'm supposed to get on a plane in three hours.  perhaps i should get some sleep.
05:38:10 <goltrpoat> adios
05:52:18 <roconnor> > sin 1
05:52:19 <lambdabot>  0.8414709848078965
05:56:58 <ndm> someone should write a latex compatible tool in Haskell
05:57:14 <ndm> i've just found  that i only get line numbers in errors if you have --quiet specified!
05:59:46 <ndm> @seen kosmikus
05:59:47 <lambdabot> kosmikus is in #haskell, #darcs, #xmonad, #ghc and #gentoo-haskell. I last heard kosmikus speak 1d 3h 9m 28s ago.
06:15:49 <roconnor> ndm: do you mean a latex replacement?
06:15:52 <Cin> @src lines
06:15:52 <lambdabot> Source not found. Wrong!  You cheating scum!
06:16:40 <ndm> roconnor: yep
06:17:27 <vincenz> > 0.84^2
06:17:28 <lambdabot>  0.7055999999999999
06:17:31 <vincenz> > 0.54^2
06:17:32 <lambdabot>  0.2916
06:17:57 <vincenz> ndm: you're nuts
06:18:05 <vincenz> ndm: that's like saying you want emacs in scheme
06:18:15 <vincenz> Sure it might be an attractive idea, until you realize how many packages are out there
06:20:05 <Saizan> you should write one able to load old packages
06:20:38 <meta7> > sin 1
06:20:39 <lambdabot>  0.8414709848078965
06:21:56 <roconnor> ndm: can the latex replacement use SGML?
06:23:18 <meta7> > 1/0
06:23:19 <lambdabot>  Infinity
06:23:54 <vincenz> > const 0 1/0
06:23:55 <roconnor> > (-1)/0
06:23:55 <lambdabot>  NaN
06:23:55 <lambdabot>  -Infinity
06:24:03 <vincenz> > const 0 (1/0)
06:24:03 <lambdabot>  0
06:24:49 <oerjan> > const 0 (error "You evil scum!")
06:24:50 <lambdabot>  0
06:25:04 * vincenz was showing meta7 
06:25:52 <vincenz> > 1 / (error "You evil scum!")
06:25:53 <lambdabot>  Exception: You evil scum!
06:26:03 <vincenz> >  (error "You evil scum!") / 0
06:26:04 <lambdabot>  Exception: You evil scum!
06:27:15 <vincenz> @type error
06:27:16 <lambdabot> forall a. [Char] -> a
06:27:21 <vincenz> > error . show $ v
06:27:21 <lambdabot>   Not in scope: `v'
06:27:23 <vincenz> > error . show $ _v
06:27:24 <lambdabot>   Not in scope: `_v'
06:29:22 <meta7> > (1/3)*3
06:29:23 <lambdabot>  1.0
06:34:02 <roconnor> ndm: sometimes I want to rewrite DSSSL in Haskell
06:34:31 <vincenz> roconnor: as long as you do not want to rewrite C++ in Haskell
06:34:42 <SamB> roconnor: yeah, me too, but then I get overwhelmed
06:34:56 <Cin> :t mapM_
06:34:57 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
06:35:01 <Cin> what's the underscroll all about?
06:35:09 <roconnor> SamB: I get that for a lot of projects.
06:35:13 <oerjan> Cin: throwing away the final result
06:35:17 <oerjan> :t mapM
06:35:18 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
06:35:18 <Cin> ah, i see
06:35:19 <roconnor> @type mapM
06:35:19 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
06:35:49 <oerjan> (in fact, not collecting it in the first place - could be a long list)
06:36:01 <Cin> that explains 'forM_ = flip mapM_'. it's just like a for-loop for doing a set of side-effects?
06:36:20 <oerjan> pretty much
06:36:29 <ndm_> roconnor: it would want to be compatible to some degree with Latex, but alternative (and less crazy) syntaxes would be a good idea
06:36:51 <roconnor> SamB: I reason that it is hard to write incorrect programs in Haskell
06:37:02 <roconnor> SamB: and it is hard to write correct programs period.
06:37:14 <roconnor> SamB: Therefore it is hard to write programs in Haskell.
06:37:18 <Cin> oerjan: thanks
06:37:30 <SamB_XP> that's interesting reasoning ;-)
06:37:30 <roconnor> Hence there are few major applications written in Haskell
06:37:40 <ndm_> i disagree - its still hard to write correct programs in haskell, and its a nightmare to debug applications written in haskell
06:37:41 <oerjan> :)
06:37:41 <SamB_XP> but somehow it seems easier to write correct programs in Haskell
06:38:34 <roconnor> SamB_XP: perhaps it just seems that way because you are less distracted by incorrect programs.
06:38:46 <oerjan> > let sum l = foldl' (/) l in sum [1..10]
06:38:47 <roconnor> ndm_: I don't see how you are disagreeing with me :)
06:38:48 <lambdabot>   add an instance declaration for (Fractional [t])
06:38:48 <lambdabot>     In the expression: let...
06:39:02 <oerjan> > let sum l = foldl1' (/) l in sum [1..10]
06:39:04 <lambdabot>  2.7557319223985894e-7
06:39:16 <oerjan> ^^ incorrect program
06:39:38 <SamB_XP> well, it's harder to write incorrect programs by accident
06:40:59 <oerjan> it's harder to write programs by accident, period? :)
06:41:24 <pejo> Perhaps that is what is differing - often you write incorrect programs that happen to work for your dataset, and that makes perl/c/etc appear much more convenient to the programmer?
06:41:27 <roconnor> oerjan: yeah, your first try had a type error :P   You can't even write incorrect programs incorrectly.
06:43:24 <Cin> o_o
06:45:55 <oerjan> > recip . product $ [1..10]
06:45:56 <lambdabot>  2.755731922398589e-7
06:54:52 <ndm_> > recip $ product [1..10]
06:54:53 <lambdabot>  2.755731922398589e-7
06:55:08 <ndm> your . is redundant :)
06:55:58 <byorgey> > sum . map product $ inits [1..10]
06:55:59 <lambdabot>  4037914
06:56:11 <byorgey> > sum . map (recip . product) $ inits [1..10]
06:56:12 <lambdabot>  2.7182818011463845
07:00:18 <ndm> i still don't get why people do the . then $ thing
07:00:57 <oerjan> maximal point-free-ness
07:00:57 <roconnor> ndm: as opposed to?
07:01:14 <ndm> sum $ map product $ inits  [1..10]
07:01:31 * oerjan waits for the ndm - Cale deathmatch
07:01:35 <roconnor> ndm: I guess . are easier to type, look nicer, and makes refactoring code easier.
07:03:06 * dmhouse uses brackets as much as possible
07:03:23 <oerjan> dmhouse: hah, you fail
07:03:28 <oerjan> not a single bracket there
07:03:36 <dmhouse> > map product (inits [1..10]) -- Or something like that. I think it looks nicest.
07:03:36 <lambdabot>  [1,1,2,6,24,120,720,5040,40320,362880,3628800]
07:03:58 <ddarius> But it's
07:04:02 <oerjan> > scanl (*) 1 [1..10]
07:04:03 <lambdabot>  [1,1,2,6,24,120,720,5040,40320,362880,3628800]
07:04:07 <ddarius> > sum (map product (inits [1..10]))
07:04:08 <lambdabot>  4037914
07:04:36 <sjanssen> ndm: it makes each subexpression a valid expression
07:04:38 <dmhouse> ddarius: I wouldn't normally do nested levels
07:04:59 <sjanssen> eg. sum $ map f $ filter p xs, "sum $ map f" isn't well-typed, but "sum . map f" is
07:05:10 <ddarius> dmhouse: When you use (.), they aren't nested.  I have (.) "pipelines" 8-10 functions long.
07:05:13 <oerjan> > sum . scanl (/) 1 $ [1..30]
07:05:14 <lambdabot>  2.7182818284590455
07:05:17 <dmhouse> sum $ map product (inits [1..10])   or   sum (map product $ inits [1..10])
07:05:18 <ndm> sjanssen: fair point
07:05:41 <ddarius> > exp 1
07:05:42 <lambdabot>  2.718281828459045
07:05:45 <dmhouse> ddarius: yes, when it gets to expressions more than about 3 in length, I'd use . all the way.
07:05:50 <dmhouse> Actually scratch that, I'd use let.
07:06:26 <roconnor> sjanssen: that is really a clear explaination of why it makes refactoring easier :)
07:06:45 <sjanssen> roconnor: I stole it from Cale (who converted me from $ style at some point :)
07:06:53 * ndm becomes convinced
07:07:27 <SamB_XP> dmhouse: don't you need a $ at the end?
07:07:31 <ddarius> ndm: Cale also believes in a coming revolution where the associativity of ($) will be swapped (which would break ($) pipelines)
07:07:44 <dmhouse> SamB_XP: at the end of what?
07:07:51 <SamB_XP> dmhouse: of your . pipeline
07:08:00 <roconnor> sjanssen: technically it isn't so much that subexpressions are well typed as much as it is that the substrings we care about are actually subexpressions
07:08:10 <oerjan> > (sum . scanl (/) 1) [1..30]
07:08:11 <lambdabot>  2.7182818284590455
07:08:21 <dmhouse> SamB_XP: oh, right, well, yeah, of course, but the discussion was regarding bracket usage.
07:08:40 <oerjan> SamB_XP: no $ needed if you allow some parens
07:08:43 <dmhouse> roconnor: well surely "map $ sum f" is an expression, just not a well typed one.
07:08:46 <SamB_XP> yes, but you said "." all the way ;-)
07:08:58 <dmhouse> SamB_XP: yeah, fine, nitpicker :P
07:09:17 <roconnor> dmhouse: it is an expression, but it isn't a subexpression.
07:09:41 <dmhouse> roconnor: surely a subexpression is an expression which is a substring?
07:09:54 <dmhouse> (Or vice versa.)
07:09:58 <roconnor> dmhouse: nope, it has to be a subtree of the parse tree.
07:10:09 <dmhouse> Oh, okay.
07:10:21 <SamB_XP> roconnor: well, Haskell doesn't support "whatever" associativity
07:10:54 <ndm> ddarius: that would be a bit of a brutal change
07:11:12 <roconnor> SamB_XP: it's true that techinically (5 + 4) may not be a subexpression of (5 + 4 + 3), but with associativity we can pretend it is.
07:11:24 <ddarius> Christmas edition of Catster videos?
07:11:30 <SamB_XP> ndm: only if we don't convert everyone first
07:11:37 <oerjan> > (5 + 4 +) 3
07:11:38 <lambdabot>  12
07:11:39 <roconnor> certainly $ isn't associative :)
07:11:47 <oerjan> > (+ 4 + 3) 5
07:11:48 <lambdabot>      The operator `+' [infixl 6] of a section
07:11:48 <lambdabot>         must have lower precede...
07:12:08 <roconnor> oerjan: fine (4 + 3) then ;)
07:12:16 * roconnor doesn't know the associativity of +
07:12:26 * roconnor also doesn't need to know
07:12:29 <SamB_XP> he said "may not"
07:12:29 <oerjan> roconnor: ^^ infixl 6
07:12:39 <SamB_XP> implying he didn't remember if it was actually the case
07:12:44 <oerjan> roconnor: you do if you want to section it...
07:13:09 <dmhouse> Prelude> :info (+)
07:13:10 <dmhouse> (definition)
07:13:10 <dmhouse> infixl 6 +
07:13:14 <dmhouse> Or GHCi :info.
07:13:15 <roconnor> oerjan: you can slap me if I ever write sections like that ;)
07:13:21 <b_jonas> lol
07:13:26 <b_jonas> "whatever" associativity
07:13:33 <oerjan> roconnor: but but they would be useful
07:13:40 <ndm> SamB_XP: one at a time, and i got converted today
07:13:43 <roconnor> no!
07:13:43 <ndm> write a blog post!
07:13:45 <roconnor> :)
07:13:49 <b_jonas> plus, + isn't associative
07:14:01 <oerjan> and (x:y:) too...
07:14:02 <roconnor> b_jonas: it isn't?
07:14:02 <b_jonas> it's associative on most integeral types
07:14:03 <dmhouse> b_jonas: ... it's not?
07:14:05 <b_jonas> but not all numerics
07:14:12 <dmhouse> b_jonas: it ought to be, if Num is a field
07:14:17 <b_jonas> but it's not
07:14:18 <ddarius> dmhouse: Num isn't a field.
07:14:25 <eric-lavigne> overflow makes it not associative
07:14:34 <b_jonas> no, it's not overflow
07:14:35 <roconnor> eric-lavigne: how so?
07:14:40 <b_jonas> it's floating-point rounding
07:14:44 <b_jonas> it's commutative though
07:14:48 <SamB_XP> isn't + associative on all add-notation monoids?
07:14:51 <roconnor> damn floating point!!!
07:15:03 <dmhouse> SamB_XP: yes, by definition.
07:15:12 <dmhouse> (Algebraically speaking.)
07:15:15 <oerjan> SamB_XP: that's a tautology :)
07:15:16 <eric-lavigne> (infinity/2) + (- infinity/2) + 50
07:15:26 <roconnor> okay, I'm in favour of removing floating point from the numeric class ;)
07:15:36 <SamB_XP> roconnor: yeah, I was just thinking the same...
07:15:40 <oerjan> > (0$0 +) -- trick to make lambdabot tell fixities
07:15:41 <lambdabot>      The operator `+' [infixl 6] of a section
07:15:41 <lambdabot>         must have lower precede...
07:15:47 <dmhouse> Well, Num is too big anyway.
07:15:47 <b_jonas> > let e = 2^^(-53) in 1 + (e + e) == (1 + e) + e
07:15:47 <eric-lavigne> oops, i messed that up
07:15:48 <lambdabot>  True
07:15:52 <roconnor> let's remove it from all of haskell while we are at it :P
07:15:57 <b_jonas> > let e = 2^^(-53) :: Double in 1 + (e + e) == (1 + e) + e
07:15:58 <lambdabot>  True
07:16:00 <SamB_XP> roconnor: no way!
07:16:08 <SamB_XP> they's useful even if innacurate
07:16:17 <eric-lavigne> (infinity/2) + (infinity/2) + (-50)
07:16:18 <roconnor> will give out a floating point module to those who have a floating point licence.
07:16:33 <eric-lavigne> then you get either infinity or very high number, depending on how you associate
07:16:50 <SamB_XP> eric-lavigne: eh?
07:16:57 <b_jonas> > let e = 2^^(-63) :: Double in 1 + (e + e) == (1 + e) + e
07:16:58 <lambdabot>  True
07:16:59 <SamB_XP> how so?
07:17:01 <SamB_XP> oh.
07:17:01 <SamB_XP> wait.
07:17:03 <b_jonas> > let e = 2^^(-64) :: Double in 1 + (e + e) == (1 + e) + e
07:17:04 <lambdabot>  False
07:17:06 <b_jonas> there
07:17:11 <b_jonas> that shows it's not associative
07:17:11 <SamB_XP> how the heck do you divide infinity in half?
07:17:31 <dmhouse> Easily. infty/2 = infty
07:17:48 <dmhouse> (As there's a bijection Z/2Z -> Z, perhaps.)
07:17:52 <SamB_XP> > 1/0/2
07:17:53 <lambdabot>  Infinity
07:17:59 <b_jonas> it's associative on big integers, on fixed width integers (with modulo wrapping)
07:18:00 <SamB_XP> hmm, true ;-)
07:18:03 <b_jonas> but not on floats
07:18:11 <eric-lavigne> I don't divide infinity by half. I determine the smallest haskell number that is approximated by infinity, then manually input half of that number
07:18:12 <ddarius> Field axioms are for the weak.
07:18:13 <b_jonas> it's also associative on big rationals
07:18:36 <dmhouse> Certainly when you work in the (projectively) extended reals, you define a*infty = infty for any real a.
07:18:51 <b_jonas> some useful identities that apply for floating point numbers too can be found in Knuth vol 2
07:19:01 <b_jonas> they're weaker than field axioms
07:19:06 <ddarius> dmhouse: Don't you compactify my number line.
07:19:07 <oerjan> > fromIntegral (floor (1/0) `div` 2) :: Double
07:19:08 <lambdabot>  8.98846567431158e307
07:19:25 <eric-lavigne> let (infinity/2) = (approximately) 5.0e307
07:19:53 <b_jonas> obviously that book doesn't yet know about IEEE floats, so it just assumes that there are no overflows or underflows or division by zeros or illegal ops
07:20:07 <eric-lavigne> replace (-50) by a more negative number to provide more room for rounding error
07:21:31 <mmmdonuts> roconnor: HsColour -oContracts.html -lit -css Contracts.lhs.  It just colored the code fragments, the text was written by hand as html.
07:21:51 <eric-lavigne> (8.0e307) + (8.0e307) + (-8.0e307)
07:22:07 <eric-lavigne> why didn't lambdabot answer that?
07:22:27 <ddarius> eric-lavigne: Lambdabot doesn't like you, along with all other people who don't use '> '
07:22:38 <eric-lavigne> > (8.0e307) + (8.0e307) + (-8.0e307)
07:22:38 <lambdabot>  8.0e307
07:22:48 <eric-lavigne> > ((8.0e307) + (8.0e307)) + (-8.0e307)
07:22:49 <lambdabot>  8.0e307
07:22:59 <eric-lavigne> > (8.0e307) + ((8.0e307) + (-8.0e307))
07:23:00 <lambdabot>  8.0e307
07:23:38 <eric-lavigne> > ((8.0e308) + (8.0e308)) + (-8.0e307)
07:23:39 <lambdabot>  Infinity
07:23:47 <eric-lavigne> > ((8.0e308) + (8.0e308)) + (-8.0e308)
07:23:48 <lambdabot>  NaN
07:24:07 <eric-lavigne> > ((1.0e308) + (1.0e308)) + (-1.0e308)
07:24:08 <lambdabot>  1.0e308
07:24:48 <eric-lavigne> > ((8.0e307) + (8.0e307)) + (-8.0e307)
07:24:48 <lambdabot>  8.0e307
07:25:42 <eric-lavigne> 1.0e308
07:25:46 <eric-lavigne> > 1.0e308
07:25:47 <lambdabot>  1.0e308
07:25:50 <eric-lavigne> > 1.0e309
07:25:51 <lambdabot>  Infinity
07:25:59 <eric-lavigne> > 5.0e308
07:26:00 <lambdabot>  Infinity
07:26:05 <eric-lavigne> > 3.0e308
07:26:06 <lambdabot>  Infinity
07:26:14 <eric-lavigne> > 1.1e308
07:26:15 <lambdabot>  1.1e308
07:26:22 <eric-lavigne> > 2.0e308
07:26:23 <lambdabot>  Infinity
07:26:59 <eric-lavigne> > (1.1e308) + (1.1e308) + (-1.1e308)
07:27:00 <lambdabot>  1.1e308
07:27:14 <eric-lavigne> > ((1.1e308) + (1.1e308)) + (-1.1e308)
07:27:15 <lambdabot>  1.1e308
07:27:22 <eric-lavigne> > ((1.1e308) + (1.1e308))
07:27:23 <lambdabot>  Infinity
07:27:51 <oerjan> > "to " ++ (repeat . show) (1/0) ++ " and beyond!"
07:27:52 <eric-lavigne> Interesting. Looks like it is ignoring my parentheses and reassociating on its own.
07:27:52 <lambdabot>  Couldn't match expected type `Char' against inferred type `String'
07:28:07 <oerjan> > "to " ++ (unwords . repeat . show) (1/0) ++ " and beyond!"
07:28:08 <lambdabot>  "to Infinity Infinity Infinity Infinity Infinity Infinity Infinity Infinity ...
07:28:09 <eric-lavigne> > 1.1e308 + 1.1e308
07:28:10 <lambdabot>  Infinity
07:28:44 <vincenz> Pleae use pm?
07:28:51 <oerjan> the code generator is a bit too clever?
07:29:05 <eric-lavigne> oerjan: no such thing :-D
07:29:23 <eric-lavigne> Yes, it is more clever than I expected, but I like that.
07:29:24 <oerjan> clever and wrong, that is
07:30:09 <oerjan> i believe with floating point you definitely don't want the compiler to be too clever
07:30:36 <eric-lavigne> It's also possible that it uses more precision during calculation than during storage.
07:30:48 <oerjan> oh, there's that
07:31:21 <oerjan> indeed i recall it does, in some compilation modes
07:35:25 <eric-lavigne> I am new to Haskell, and I very much appreciate how it handles numbers: no integer overflow, floating overflow and underflow are handled by Infinity and 0, and now I see it getting the right answer when I expect an overflow.
07:37:38 <oerjan> > 1/2 + 1/3 + 1/5 + 1/7 :: Rational
07:37:39 <lambdabot>  247%210
07:37:57 <vincenz> > pi :: Rational
07:37:57 <lambdabot>   add an instance declaration for (Floating Rational)
07:37:57 <lambdabot>     In the expression: ...
07:38:02 <johnnowak> eric-lavigne: What are you doing with such large numbers?
07:38:25 <vincenz> johnnowak: counting peanuts?
07:39:02 <oerjan> > approxRational pi (10^^(-10))
07:39:03 <lambdabot>  312689%99532
07:39:38 <vincenz> > approxRational pi (10^^(-100))
07:39:39 <lambdabot>  884279719003555%281474976710656
07:39:48 <johnnowak> more than 9,223,372,036,854,775,808 peanuts
07:40:08 <vincenz> > approxRational pi (10^^(-1000))
07:40:09 <lambdabot>  884279719003555%281474976710656
07:40:37 <eric-lavigne> Actually, the problem that I have run into more often is very small numbers.
07:40:52 <vincenz> very small quantities of peanuts?
07:41:03 <eric-lavigne> Very small neutron fluxes.
07:41:07 <vincenz> You do know that -very- small numbers are useless since the universe is discrete
07:41:23 <reqamst_> johnnowak: some math algorithms (probably bad algorithms) require HUGE numbers
07:41:25 <vincenz> and -very- large numbers are too, because the universe is bounded
07:41:52 <johnnowak> reqamst_: sure
07:42:29 <eric-lavigne> When calculating the neutron flux across some region, in which some parts have very low flux (I wouldn't mind assuming it to be zero there), I get an underflow in parts of the problem that I don't care about before I get convergence where I do care.
07:43:16 <vincenz> eric-lavigne: perhaps you're using a numerically unstable algo?
07:43:23 <vincenz> Just a thought
07:44:02 <eric-lavigne> Yes I was actually, but it worked well enough when I explicitely forced all values to be at least 1.0e-30 or so.
07:44:38 <reqamst_> johnnowak: for example most pi algorithms
07:45:14 <vincenz> reqamst_: there's more than one way to slice a pie
07:46:56 <reqamst_> Yes, but sometimes you haven't enough time or resources to discover satisfactory algorithm
07:47:04 <oerjan> > (inits &&& tails) (show pi)
07:47:05 <lambdabot>  (["","3","3.","3.1","3.14","3.141","3.1415","3.14159","3.141592","3.1415926"...
07:47:10 <oerjan> bah
07:47:27 <oerjan> > (liftM2 zip inits tails) (show pi)
07:47:28 <lambdabot>  [("","3.141592653589793"),("3",".141592653589793"),("3.","141592653589793"),...
07:47:29 <vincenz> > (drop 1000000 *** drop 1000000) $ (inits &&& tails) (show pi)
07:47:30 <lambdabot>  ([],[])
07:47:37 * vincenz tsks
07:48:40 <vincenz> > drop 1000 $ (liftM2 zip inits tails) (show pi)
07:48:40 <lambdabot>  []
07:48:46 <vincenz> > length $ (liftM2 zip inits tails) (show pi)
07:48:47 <lambdabot>  18
07:48:55 <vincenz> that's pretty pathetic :)
07:48:59 <reqamst_> It's only variable, not function
07:49:02 <oerjan> it was a rather small pie
07:49:16 <reqamst_> @src pi
07:49:16 <lambdabot> Source not found. Sorry.
07:49:25 <oerjan> @src RealFloat
07:49:26 <lambdabot> Source not found. My brain just exploded
07:49:32 <vincenz> reqamst_: pie typically is rather constant :)
07:49:33 <oerjan> @src Floating
07:49:34 <lambdabot> class  (Fractional a) => Floating a  where
07:49:34 <lambdabot>     pi                                                      :: a
07:49:34 <lambdabot>     exp, log, sqrt, sin, cos, tan                           :: a -> a
07:49:34 <lambdabot>     asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh :: a -> a
07:49:34 <lambdabot>     (**), logBase                                           :: a -> a -> a
07:49:34 <vincenz> erm, pi
07:49:43 <vincenz> that being said, nothing stops it from being a thunk ;)
07:50:20 <reqamst_> vincenz: yeah, sure
07:51:52 <reqamst_> 4*(sum (map (fromRational . recip . toRational) [1,5..1000]) - sum (map (fromRational . recip . toRational) [3,7..1000]))
07:51:58 <reqamst_> > 4*(sum (map (fromRational . recip . toRational) [1,5..1000]) - sum (map (fromRational . recip . toRational) [3,7..1000]))
07:51:59 <lambdabot>  3.139592655589775
07:52:11 <oerjan> >_<
07:52:15 <reqamst_> > 4*(sum (map (fromRational . recip . toRational) [1,5..100000]) - sum (map (fromRational . recip . toRational) [3,7..100000]))
07:52:17 <lambdabot>  3.1415726535898063
07:52:30 <oerjan> that algorithm may be famous, but it's also just about the worst
07:52:50 <reqamst_> Example of bad algorithm. X_x
07:53:45 <vincenz> my favourite is
07:53:54 <vincenz> > atan 1
07:53:55 <lambdabot>  0.7853981633974483
07:54:04 <vincenz> it's exact
07:54:52 <oerjan> > atan 1 * 4
07:54:54 <lambdabot>  3.141592653589793
07:55:01 <reqamst_> Nice.
07:55:10 * vincenz quietly whispers about the shiftinig of the problem
07:55:12 <reqamst_> > pi
07:55:13 <lambdabot>  3.141592653589793
07:55:34 <vincenz> @src RealFloat pi
07:55:35 <lambdabot> Source not found. Are you on drugs?
07:55:36 <oerjan> the bad formula comes from the expansion of atan, i think
07:55:37 <reqamst_> That same.
07:55:39 <vincenz> @src pi RealFloat
07:55:39 <lambdabot> Source not found. Just try something else.
07:55:47 <reqamst_> lambdabot, rotfl
07:56:05 <EvilTerran> @vixen reqamst_'s laughing at you
07:56:06 <lambdabot> wait, back up
07:56:09 <loupgaroublond> @src maybe
07:56:09 <lambdabot> maybe n _ Nothing  = n
07:56:10 <lambdabot> maybe _ f (Just x) = f x
07:56:27 <oerjan> vincenz: @src Double pi -- but i doubt it's there
07:56:32 <oerjan> @src Double pi
07:56:33 <vincenz> @src Double pi
07:56:33 <lambdabot> Source not found. stty: unknown mode: doofus
07:56:34 <lambdabot> Source not found.
07:56:35 <b_jonas> is it worse than the sum . map (^4) one?
07:56:39 <vincenz> LOL
07:57:21 <oerjan> b_jonas: what's that?
07:57:32 <b_jonas> moment
07:58:27 <oerjan> you can get a better formula out of atan too, by combining a smaller value with some trigonometry
07:58:37 <oerjan> iirc
07:59:07 <davidL> oerjan: remember yesterday when you said to use [[String]] with (=~) to return all matches? but how can I get a match of only a single group?
07:59:44 <oerjan> davidL: use !! to pick the group you want?
08:00:24 <b_jonas> > sqrt . sqrt . (90 *) . sum . map (^^(-4)) . take 100000 $ enumFrom 1 :: Double
08:00:25 <lambdabot>  3.1415926535895924
08:00:28 <b_jonas> that
08:00:50 <oerjan> square roots are a bit awkward...
08:00:51 <b_jonas> zeta(4) = pi^4/90
08:00:52 <davidL> in my regex I have two groups and [[String]] has three elements
08:01:12 <b_jonas> > pi
08:01:13 <lambdabot>  3.141592653589793
08:01:18 <b_jonas> that's a bit better
08:01:53 <oerjan> davidL: the first element is the whole match, the remaining are the groups, i believe
08:02:11 <davidL> ohh, ok
08:02:31 <davidL> thanks :)
08:02:45 <oerjan> also, i think the [[String]] only has one element, but that element itself has three?
08:02:54 <davidL> yeah
08:03:06 <oerjan> so map (!! 1) or similar
08:03:30 <davidL> why doesn't [String] just return 3 elements?
08:03:45 <oerjan> in case there _is_ no match, it returns an empty list
08:03:49 * ski wonders why not `[(String,[String])]' or something like that ..
08:04:12 <oerjan> ski: there are several options for the result type, it's a class
08:05:04 <oerjan> i suppose a regex engine could return a list of possible matches
08:05:07 <ski> oerjan : ok .. (btw, could you enlighten me about what you're talking about .. some kind of regexp library ?)
08:05:18 <oerjan> ski: Text.Regex.Posix iirc
08:05:29 <ski> ty
08:05:53 <oerjan> which is a special case of the generic Text.Regex which can use various regex engines
08:06:25 <davidL> No instance for (Text.Regex.Base.RegexLike.RegexContext Regex [Char] (String, [String]))
08:07:10 <b_jonas> > sqrt . sqrt . (90 *) . Data.List.foldl' (+) 0 . map (^^(-4)) . take 1000000 $ enumFrom 1 :: Double
08:07:12 <lambdabot>  3.1415926535895924
08:07:44 <b_jonas> > pi - sqrt . sqrt . (90 *) . Data.List.foldl' (+) 0 . map (^^(-4)) . take 1000000 $ enumFrom 1 :: Double
08:07:45 <lambdabot>        add an instance declaration for (Floating ([Double] -> Double))
08:07:53 <b_jonas> > (pi -) . sqrt . sqrt . (90 *) . Data.List.foldl' (+) 0 . map (^^(-4)) . take 1000000 $ enumFrom 1 :: Double
08:07:56 <lambdabot>  2.0067844955229397e-13
08:09:04 <oerjan> davidL: http://www.haskell.org/ghc/docs/latest/html/libraries/regex-base/Text-Regex-Base-Context.html
08:09:06 <lambdabot> http://tinyurl.com/yovda9
08:09:38 <dmwit> sum = foldl' (+) 0
08:09:59 <oerjan> it's not very clearly written :(
08:10:04 <dmwit> (Although it may be specified as foldl in the standard Prelude.)
08:10:53 <oerjan> > sum [1..100000000] :: Integer
08:10:59 <lambdabot> Terminated
08:11:06 <davidL> oerjan: that is useful, thank you
08:11:08 <oerjan> > sum [1..1000000] :: Integer
08:11:08 <dmwit> :t enumFromTo
08:11:10 <lambdabot> forall a. (Enum a) => a -> a -> [a]
08:11:11 <lambdabot>  500000500000
08:11:15 <oerjan> > sum [1..10000000] :: Integer
08:11:20 <lambdabot> Terminated
08:11:25 <oerjan> > sum [1..5000000] :: Integer
08:11:28 <lambdabot>  12500002500000
08:11:45 <oerjan> i thought it could give a stack overflow...
08:11:53 <oerjan> (because of foldl)
08:11:58 <EvilTerran> IIRC, the report defines it as foldl
08:12:02 <dmwit> Also, probably take 1000000 $ enumFrom 1 === enumFromTo 1 1000000
08:12:09 <dmwit> EvilTerran: Yeah, I think foldl' is not H98.
08:12:16 <EvilTerran> but strictness analysis etc may do something clever
08:12:21 <dmwit> Or even better, [1..1000000].
08:12:55 <oerjan> Integers have lousy strictness analysis, as was discussed the other day
08:13:05 <EvilTerran> @src Integer
08:13:05 <lambdabot> data Integer = S# Int#
08:13:06 <lambdabot>              | J# Int# ByteArray#
08:13:07 <oerjan> Ints are much better
08:13:23 <EvilTerran> it may be enough for such a simple case to work, tho
08:30:13 <phlpp> :t (^^)
08:30:14 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
08:34:13 <phlpp> > 5^^3.0
08:34:14 <lambdabot>  Add a type signature
08:34:46 <phlpp> > 5^^3.0 :: Fractional
08:34:47 <lambdabot>      Class `Fractional' used as a type
08:34:47 <lambdabot>     In the type `Fractional'
08:34:47 <lambdabot>     In an...
08:34:55 <phlpp> > 5^^3.0 :: Dobule
08:34:56 <lambdabot>   Not in scope: type constructor or class `Dobule'
08:34:56 <phlpp> :F
08:35:06 <phlpp> aww.. nevermind :>
08:36:59 <earthy> 5^^3.0 :: Double
08:37:07 <earthy> 5^^3.0 :: Double>
08:37:14 <earthy> > 5^^3.0 :: Double
08:37:14 <lambdabot>  Add a type signature
08:37:17 <earthy> sigh.
08:38:14 <maskd> > 5.0^^3
08:38:14 <lambdabot>  125.0
08:52:43 <mmmdonuts> 'Twas the night before Christmas, and all through the channel
08:52:47 <mmmdonuts> Haskell nerds wearing pajamas of flannel
08:52:51 <mmmdonuts> Cozy and warm while the wind outside moaned
08:52:55 <mmmdonuts> They abused lambdabot for reasons unknown!
08:57:15 <vincenz> Where are the monads?
08:57:29 <vincenz> bah
08:57:32 <vincenz> haskell poems without monads
08:58:10 <mmmdonuts> s/moaned/monad/
09:01:07 <byorgey> The nerds happily played with their succs and their preds
09:01:17 <byorgey> While visions of desugaring danced in their heads.
09:02:11 <vincenz> Arrows flew, from left :+: right.
09:02:19 <vincenz> But hindley-milner, made it alright
09:02:41 <Jomyoot> Does Textmate work well with Haskell?
09:04:55 <mrd> Jomyoot: if you can set it up to do 4-space tabstops it should be fine.  maybe even a syntax highlight package for it. maybe.
09:05:08 <mrd> Jomyoot: check out the wiki haskell.org there might be an entry on it
09:05:31 <vincenz> 2-space tabstops
09:05:40 <mrd> yea i use 2-space tabstops also
09:05:53 <mrd> but i figured 4-space was more common
09:06:29 * dmwit rarely ends up using multiples of anything
09:06:58 <Japsu> aaaaaa
09:07:03 <Japsu> -aaaaaa
09:08:43 <Cin> so i've been trying to figure out how i would write this networked multiplayer four-in-a-row game for the past few days, but i'm having trouble figuring out a lot of things
09:09:11 <Cin> i've written a module that works on a four-in-a-row grid. that's all spiffy. and i know how to draw a grid using the gtk2hs library
09:09:36 <Cin> i know that i can store the state of the game in an IORef
09:10:03 <Cin> now i'm wondering how i am to send and receive information from other players
09:11:02 <Cin> using the Network module it looks like i can use the getContents function and parse the data line-by-line in a thread or something
09:11:32 <Cin> but i'm not sure how safe that would be, or how to glue it together. is there some tutorial about a networked game anywhere, heh?
09:13:14 <sclv> Cin: use STM and have distinct listener threads?
09:14:45 <sjanssen> Cin: IORefs aren't thread safe
09:15:08 <byorgey> while on the -cafe, an endless debate / and a new GHC, of version point eight! / With a brilliant old hacker (with parallel arrays) / that I knew in a moment -- must be SPJ!
09:15:46 <sjanssen> so maybe what you want to do is have N threads write requests to a Chan, then have one thread that takes requests from the Chan and updates the game state and GUI
09:16:19 <Cin> ah, hm. i've used channels briefly with mzscheme
09:16:46 <gwern> 'Note to the mailing list: When someone says it is their first week of Haskell, answers should probably include phrases like "pattern match" or "higher order" - not Template Haskell, hs-plugins, HList, GADT's etc!'
09:17:39 <Cin> sjanssen: i'm not sure how thread-safe gtk2hs is. i'll have to find out. but that sounds like a good model
09:28:08 <shapr> Merry Christmas! May all your presents be nifty!
09:28:24 <shapr> For example, someone could buy me gmh's book for Xmas ;-)
09:32:12 <kosmikus> shapr: merry christmas to you, too.
09:32:20 * shapr boings cheerfully
09:32:32 <shapr> kosmikus: What country are you in these days?
09:32:55 <kosmikus> .de currently, .nl generally
09:33:16 <earthy> Frohe Weinachten, kosmikus
09:34:30 <earthy> and merry christmas to all as well :)
09:34:54 <kosmikus> thanks, earthy
09:35:45 <earthy> hm. difference lists in monads are slightly annoying. ;)
09:36:04 <earthy> makes you write stuff like   concat = fmap (foldr (.) id) . join . fmap sequence
09:41:01 <Lycurgus> gmh's book?
09:43:16 <mmmdonuts> http://www.cs.nott.ac.uk/~gmh/book.html
09:43:17 <lambdabot> Title: Programming in Haskell
09:43:29 <Lycurgus> ah.
09:44:31 <Lycurgus> interested that the paper forms are pound denominated but the e form USD.
09:47:19 <Lycurgus> seems odd that shapr as a haskell pro would want an introductory text.
09:47:26 <Lycurgus> s/ed/ing/
09:55:10 <hpaste>  davidL pasted "youtube player, any suggestions?" at http://hpaste.org/4653
10:02:46 <wy> hello!
10:03:05 <wy> @users
10:03:06 <lambdabot> Maximum users seen in #haskell: 434, currently: 364 (83.9%), active: 11 (3.0%)
10:03:24 <shapr> Lycurgus: I want to own one of every Haskell book, and I don't have that one yet :-)
10:03:43 <wy> shapr: Which one? I'm interested
10:03:56 <shapr> wy: I don't yet have http://www.cs.nott.ac.uk/~gmh/book.html
10:03:57 <lambdabot> Title: Programming in Haskell
10:04:22 <Lycurgus> ah, that makes (a kind of) sense.
10:05:41 <shachaf> shapr: You should've said that when grahamhutton was here. :-)
10:06:33 <wy> Is there a better way to write "map (`mod` 3) [i-1, i+1]"? I just want to find the number in [0,1,2] that's not i
10:07:34 <sarehu> if you could use [1,2,3] instead you might be able to use xor
10:08:39 <wy> But the index starts at 0. I guess the best I can do is map (flip mod 3) [i-1, i+1]. Does that look nicer?
10:09:29 <sarehu> > let i = 5 in map ((subtract 1) . (`xor` (i+1)) . (+1)) [1,2]
10:09:32 <lambdabot>  Add a type signature
10:09:48 <sarehu> > let i = 5 in map ((subtract 1) . (`xor` (i+1)) . (+1)) [1,2] :: Int
10:09:48 <lambdabot>  Couldn't match expected type `Int' against inferred type `[a]'
10:09:57 <sarehu> > let i = 5 in map ((subtract 1) . (`xor` (i+1)) . (+1)) [1,2] :: [Int]
10:09:59 <lambdabot>  [3,4]
10:10:01 <sarehu> bah
10:10:11 <wy> haha. That's crazy
10:10:44 <sarehu> > let i = 2 in map ((subtract 1) . (`xor` (i+1)) . (+1)) [1,2] :: [Int]
10:10:45 <lambdabot>  [0,-1]
10:10:47 <sarehu> hrm
10:11:07 <sarehu> oh dumb
10:11:17 <sarehu> > let i = 2 in map ((subtract 1) . (`xor` (i+1))) [1,2]
10:11:18 <lambdabot>  Add a type signature
10:11:23 <sarehu> > let i = 2 in map ((subtract 1) . (`xor` (i+1))) [1,2] :: [Int]
10:11:24 <lambdabot>  [1,0]
10:11:26 <Modius> Is there a Haskell function that takes a list of tuples (key, value) and returns a list of (key, [value, value, value]) ?
10:11:45 <sarehu> > map (map ((subtract 1) . (`xor` (i+1))) [1,2]) [0,1,2] :: [[Int]]
10:11:46 <lambdabot>   Not in scope: `i'
10:12:01 <sarehu> > map (\i -> map ((subtract 1) . (`xor` (i+1))) [1,2]) [0,1,2] :: [[Int]]
10:12:02 <lambdabot>  [[-1,2],[2,-1],[1,0]]
10:12:05 <sarehu> sigh
10:12:51 <sarehu> oh, I'm a complete moron..
10:16:04 <shachaf> > map (fst . head &&& map snd) . groupBy ((==) `on` fst) . sortBy (compare `on` fst) $ [(1,"a"),(2,"a"),(1,"b"),(3,"d")]
10:16:05 <lambdabot>  [(1,["a","b"]),(2,["a"]),(3,["d"])]
10:16:38 <sarehu> :t on
10:16:39 <lambdabot> Not in scope: `on'
10:16:42 <sarehu> ok
10:16:54 <shachaf> on f g x y = g x `f` g y
10:17:10 <sarehu> ok, just wondering if it had some more general signature
11:05:50 <Politics101> Great Youtube Video, this guy should run for president himself!!:  http://www.youtube.com/watch?v=UZAqZUafCdM
11:05:51 <lambdabot> Title: YouTube - Joe Mucci owner of Court.us publicly endorses Mike Huckabee
11:06:22 * shivernz sighs
11:09:07 <zeeeee> anybody able to get missingh built for ghc 6.8? i tried darcs and releases
11:12:52 * dmwit considers the RonPaulT monad transformer
11:16:08 <zeeeee> i'm just starting to use cabal-install, but i can't figure some things out, like: how do i get cabal to install globally?
11:16:49 <sclv> @pl \env -> templ (map ($env) expr) env
11:16:50 <lambdabot> templ =<< flip map expr . flip id
11:18:30 <sclv> @pl \expr -> \env -> templ (map ($env) expr) env
11:18:31 <lambdabot> (line 1, column 45):
11:18:31 <lambdabot> unexpected "\SI"
11:18:31 <lambdabot> expecting variable, "(", operator or end of input
11:18:41 <sclv> @pl \expr -> templ =<< flip map expr . flip id
11:18:42 <lambdabot> (templ =<<) . (. flip id) . flip map
11:18:52 <oerjan> @pl \env -> templ (sequence expr env) env
11:18:53 <lambdabot> templ =<< sequence expr
11:19:14 <sclv> oooh. thank you.
11:19:27 <oerjan> sclv: sequence expr env = map ($env) expr, and seems to @pl better in this case
11:20:03 <sclv> I'm coding in the reader monad but have a hard time seeing all the right abstractions sometimes.
11:20:33 <sclv> so that code actually expresses exactly what I want much more clearly.
11:20:54 <oerjan> :)
11:21:43 <sclv> it was originally (templ =<< expr) but then I made expr into a list, and was trying to figure out how to properly alter the code.
11:22:17 <Politics101> Great Youtube Video, this guy should run for president himself!!:  http://www.youtube.com/watch?v=UZAqZUafCdM
11:22:18 <lambdabot> Title: YouTube - Joe Mucci owner of Court.us publicly endorses Mike Huckabee
11:22:41 <oerjan> > unwords . repeat $ "SPAM"
11:22:44 <lambdabot>  "SPAM SPAM SPAM SPAM SPAM SPAM SPAM SPAM SPAM SPAM SPAM SPAM SPAM SPAM SPAM ...
11:23:12 <sclv> any ideas how to make this nicer: ($ [STR ""]) <$> anonTmpl
11:23:27 <dmhouse> ?type (<$>)
11:23:29 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:23:57 <oerjan> sclv: is anonTmpl a list?
11:24:20 <sclv> a function that takes a list.
11:24:40 <sclv> or rather a GenParser that produces such a function, which is why the fmap is necessary
11:24:41 <dmhouse> In which functor?
11:25:05 <sclv> dmhouse: the parsec parser monad
11:25:07 <dmhouse> Right.
11:25:14 <oerjan> i see.  no sequence trick then.
11:25:38 <dmhouse> sclv: what's STR?
11:25:49 <sclv> dmhouse: a constructor for an adt
11:26:07 <sclv> I'm getting too picky about sectioned $ maybe, but I just tend to dislike it.
11:26:29 <oerjan> well if you prefer flip id...
11:26:35 <sclv> haha no
11:26:44 <dmhouse> Well you can always use (\f -> f foo), which isn't very ugly.
11:27:11 * dmhouse holds the position that a short lambda is often the prettiest way of writing a given combinator.
11:27:29 <oerjan> anonTmpl `ap` return [STR ""]
11:28:53 <dmhouse> (But not really here.)
11:30:41 <sclv> eh. nevermind. that would be prettier if I could use <*>, but the parser doesn't have an applicative instance and I don't feel like writing one
11:31:19 <wy> I just found out that the functions are actually "overloaded" in a OOP sense
11:31:40 <oerjan> an a (b -> c) -> b -> a c combinator appears to be missing
11:31:46 <shachaf> sclv: instance Applicative Parser where pure = return; (<*>) = ap?
11:31:49 <oerjan> even for Applicatives
11:32:59 <hpaste>  zeeeee pasted "any ideas how to fix this build error in the darcs version of missingh?" at http://hpaste.org/4654
11:33:20 <monochrom> yay, the hpaste announce bot is back!
11:33:35 <monochrom> (No, I don't know missingh)
11:33:59 <hpaste>  dmhouse pasted "Celebratory paste!" at http://hpaste.org/4655
11:34:23 <monochrom> haha
11:34:47 <shachaf> @ty flip (fmap . flip ($))
11:34:48 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
11:35:07 <oerjan> zeeeee: seems like higher rank types are not turned on?
11:35:24 <zeeeee> oerjan, how do i enable that (via .cabal)?
11:36:52 <oerjan> no idea about .cabal but maybe {-# LANGUAGE RankNTypes #-} at the top of the source file?
11:38:11 <oerjan> (perhaps Rank2Types is enough)
11:38:43 <shachaf> zeeeee: Extensions: RankNTypes, possibly?
11:40:07 <oal``> merry xmas, people
11:40:17 <oal``> is here anyone with haxml experience?
11:40:21 <oerjan> merry christmas
11:40:28 <zeeeee> oerjan, thanks, that worked
11:41:15 <oal``> i have troubles building it with ghc
11:41:18 <shachaf> zeeeee: Indeed, {-# LANGUAGE ... #-} is probably nicer.
11:41:24 <ndm> @seen malcolmw
11:41:25 <lambdabot> I saw malcolmw leaving #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 4d 1h 31m 57s ago, and .
11:41:50 <oal``> or, to be exact: i have toubles building it under unix and using the source via -i in ghc
11:41:58 <ndm> oal``: it appears the haxml guy isn't on at the moment
11:42:02 <oal``> oh
11:42:06 <oal``> okay
11:42:10 <ndm> oal``: can you build it normally using the make file or the .cabal file?
11:42:24 <oal``> make
11:42:31 <oal``> ./configure && make
11:42:55 <ndm> does it have a .cabal file?
11:43:08 <oal``> moment
11:43:26 <oal``> mm... indeed, it has
11:43:45 <oal``> i'll try it and am back soon
11:43:46 <zeeeee> shachaf, really? why? i actually just now changed it to Extensions should i wouldn't have to wade through all his files
11:44:01 <shachaf> zeeeee: Well, because it works with ghci, for one.
11:44:25 <zeeeee> this strategy is proving indispensable since i've added about 6 other extensions as their build errors have been rearing their heads
11:44:26 <ndm> oal``: do you know how to install things with cabal? runhaskell Setup ... etc?
11:44:28 <zeeeee> :)
11:44:40 <oal``> i'll find it ;)
11:44:53 <ndm> @where cabal
11:44:53 <lambdabot> http://www.haskell.org/cabal
11:45:08 <oal``> i'm struggling through cabal-setup and have already found unmet dependencies
11:45:13 <zeeeee> i'm just starting to use cabal-install, but i can't figure some things out, like: how do i get cabal to install globally?
11:45:13 <oal``> yeah, thanks
11:46:40 <oal``> aaargh! haskell libs are so broken in debian
11:46:52 <oal``> i'll come back as i have fixed it, seems to be my issue
11:50:30 <sclv> ?ty transpose
11:50:33 <lambdabot> forall a. [[a]] -> [[a]]
11:51:03 <sclv> @src transpose
11:51:04 <lambdabot> transpose []             = []
11:51:04 <lambdabot> transpose ([]   : xss)   = transpose xss
11:51:04 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
11:52:08 <Saizan> zeeeee: sudo cabal install --global
11:52:57 <oerjan> > transpose [[(m,n)| n <- [1..m]] | m <- [1..3]]
11:53:00 <lambdabot>  [[(1,1),(2,1),(3,1)],[(2,2),(3,2)],[(3,3)]]
11:53:29 <oerjan> > transpose [[(m,n)| n <- [1..3]] | m <- [1..3]]
11:53:30 <lambdabot>  [[(1,1),(2,1),(3,1)],[(1,2),(2,2),(3,2)],[(1,3),(2,3),(3,3)]]
11:54:28 <zeeeee> Saizan, i tried that, but it just installs to /root/
11:54:35 <zeeeee> /root/.ghc, /root/.cabal
11:57:05 <Saizan> zeeeee: with --global? maybe you need to update cabal-install, it had a bug wrt handling options
11:57:21 <Saizan> zeeeee: or try with sudo cabal --global install
11:57:48 <wy> What's the function that's like unzip, but it turns [[a,b],[c,d],[e,f]] into [[a,b,c],[b,d,f]] ?
11:57:54 <Cale> transpose
11:58:04 <Cale> er
11:58:13 <Cale> well, it doesn't quite do that
11:58:15 <wy> > transpose [[a,b],[c,d],[e,f]]
11:58:17 <lambdabot>   Not in scope: `f'
11:58:26 <Cale> > transpose [[1,2],[3,4],[5,6]]
11:58:28 <lambdabot>  [[1,3,5],[2,4,6]]
11:58:28 <wy> > transpose [[1,2],[3,4],[5,6]]
11:58:29 <lambdabot>  [[1,3,5],[2,4,6]]
11:58:42 <wy> Cale: That's what I want :-)
11:58:46 <Cale> okay :)
12:00:30 <wy> Cale: Two few lines in my code :-)
12:02:47 <hpaste>  lz pasted "Nonogram" at http://hpaste.org/4656
12:03:06 <wy> I just noticed that a lot of things can be done with data types. I made Surface a class in my ray tracer and then made a method called hit, which returns the ray-surface intersection. But actually a data type with variants like Sphere, Box, ... is better
12:03:42 <oerjan> lz: i think you hit hpaste's length limit
12:04:16 <lz> yes
12:04:16 <wy> Is there some general guidance for when-to-use-what?
12:04:33 <oerjan> lz: what's your error?
12:04:40 <lz> but you can see the code at
12:04:41 <lz> http://www.haskell.org/haskellwiki/Nonogram
12:04:43 <lambdabot> Title: Nonogram - HaskellWiki
12:04:56 <lz> one moment
12:05:08 <Saizan> wy: as a first approximation classes are for when you want to be able to easily extends the members
12:06:14 <wy> Saizan: Is that the only difference?
12:07:39 <lz> i am geting  ERROR file:.\41.hs:197 - Improperly terminated string
12:07:51 <lz> zMap f a b = unzip">unzip $ zipWith f a b   i think is the "
12:08:35 <oerjan> that's beyond what you pasted, let me take a look at the wiki version
12:09:01 <lz> ok
12:10:12 <oerjan> hm may be broken markup
12:10:58 <lz> so that means that is somenting wrong in the code right?
12:11:10 <shachaf> Does anyone here feel like writing a bash_completion for cabal-install?
12:11:12 <Saizan> wy: obviusly no, with a sum type you can for example define equality, which you can't in general do between different types of a class
12:11:21 <shachaf> (Or has already done so?)
12:12:00 <oerjan> lz: yep those unzip lines don't make sense
12:12:32 <Saizan> shachaf: there's one in the darcs repo
12:12:48 <shachaf> Oh.
12:12:56 * shachaf feels silly.
12:13:08 <shachaf> Saizan: Thanks. :-)
12:13:32 <shachaf> It doesn't complete packages, though?
12:13:58 <wy> Saizan: I guess type classes are useful when you want to write some code that operates on types that are not defined yet
12:14:04 <shachaf> Oh, too slow?
12:14:17 <Saizan> shachaf: haven't tried it yet
12:14:45 <Saizan> wy: yes, that was one aspect of "easily extend the members"
12:15:28 <oerjan> that's weird, there is no obvious error in the edit area
12:17:39 <oerjan> there is some broken postprocessing happening to that wiki page to introduce links to the functions, i think
12:26:05 <zeeeee> is there any effort on unifying String/ByteString somehow, so as to remove the need for duplicate code?
12:27:59 <oal``> meh. not known to me
12:28:12 <oal``> but you can unify your own code with type classes
12:28:40 <oal``> delcare a class Strings and both types String and ByteString of that class
12:29:00 <oal``> provide uniform interface to both types (yes, it's work!)
12:29:24 <oal``> but then you can use just "Strings a => a" etc
12:29:37 <oal``> just like with Integers in prelude
12:33:30 <oerjan> darn i was just going to tell him how to get the raw text
12:35:52 <geekagent> In doing one of the 99 Prolog problems, I needed to create Lisp style lists, and I realized that they're really just trees because of how I set them up
12:36:12 <ddarius> They are trees.
12:36:53 <ndm> @seen kosmikus
12:36:53 <lambdabot> kosmikus is in #haskell, #darcs, #xmonad, #ghc and #gentoo-haskell. I last heard kosmikus speak 2h 42m 40s ago.
12:37:17 <ndm> \begin{tabular}{l@{text}} doesn't work with lhs2tex
12:37:38 <ndm> it seems that lhs2tex replaces the @{ with other stuff - why, and how do i stop it doing this?
12:38:40 <ndm> ah - found it, must be @@ if preprocessing
12:42:29 <geekagent> ddarius: yeah, but the way I set it up made it obvious. http://hpaste.org/4657, the symmetry shows up.
12:44:57 <ddarius> Usually one thinks of Lisp as only having pairs (conses), but due to dynamic typing you end up with something that looks more like data Value = Atom Atom | Cons Value Value
12:45:20 <sclv> > transpose [[1,2,3], [3]]
12:45:22 <lambdabot>  [[1,3],[2],[3]]
12:45:27 <sclv> > transpose [[1,2,3], [4]]
12:45:29 <lambdabot>  [[1,4],[2],[3]]
12:49:43 <oerjan> sclv: transpose behaves strangely if the length of the rows is sometimes increasing
12:49:59 <sclv> howso?
12:50:02 <oerjan> then it is not its own inverse
12:50:21 <oerjan> > transpose [[1],[2,3]]
12:50:22 <lambdabot>  [[1,2],[3]]
12:50:31 <oerjan> > transpose $ transpose [[1],[2,3]]
12:50:32 <lambdabot>  [[1,3],[2]]
12:50:39 <geekagent> > transpose [[1,2,3], [4], [5,6]]
12:50:40 <lambdabot>  [[1,4,5],[2,6],[3]]
12:50:46 <geekagent> > transpose $ transpose [[1,2,3], [4], [5,6]]
12:50:47 <lambdabot>  [[1,2,3],[4,6],[5]]
12:50:54 <oerjan> in fact then it is not invertible
12:51:07 <sclv> hmm.. i think it'll work for my purposes
12:51:16 <oerjan> the result always has non-increasing row lengths
12:51:25 <EvilTerran> it's invertible for  non-increasing row lengths, likewise
12:51:51 <geekagent> If the lengths are the same, or non-decreasing, then it should be invertible
12:52:00 <oerjan> and of course it is mostly intended for rectangular lists anyhow
12:52:20 * EvilTerran read that as "mosty indented" the first three times
12:52:29 <ddarius> > transpose $ repeat []
12:52:34 <EvilTerran> _|_
12:52:36 <lambdabot> Terminated
12:52:50 <EvilTerran> > transpose [[],[]]
12:52:51 <lambdabot>  []
12:54:00 <sclv> oh wait, no it won't
12:54:15 <oerjan> what do you want?
12:54:52 <sclv> I need a version that can produce an empty "placeholder" to pad out shorter lists
12:57:29 <oerjan> hm...
12:58:40 <EvilTerran> @check (\x -> and (zipWith ((<=) `on` length) x (drop 1 x)) ==> transpose (transpose x) == (x :: [[Int]]))
12:58:40 <lambdabot>  Falsifiable, after 9 tests: [[],[1]]
12:58:59 <EvilTerran> @check (\x -> and (zipWith ((<=) `on` length) x (drop 1 x)) && all (not.null) x ==> transpose (transpose x) == (x :: [[Int]]))
12:59:00 <lambdabot>  Falsifiable, after 11 tests: [[-6,7],[0,2,-6],[7,1,4,-6]]
12:59:06 <EvilTerran> wait
12:59:11 <EvilTerran> @check (\x -> and (zipWith ((>=) `on` length) x (drop 1 x)) && all (not.null) x ==> transpose (transpose x) == (x :: [[Int]]))
12:59:12 <lambdabot>  Arguments exhausted after 224 tests.
13:01:34 <b_jonas> exhausted, yeah
13:02:39 <geekagent> sclv: what about using nothing as a placeholder, and then using (>>= maybeToList) to get rid of the maybes?
13:02:57 <geekagent> or in this case map (>>= maybeToList)
13:03:01 <EvilTerran> @scheck (\x -> and (zipWith ((>=) `on` length) x (drop 1 x)) && all (not.null) x ==> transpose (transpose x) == (x :: [[Int]]))
13:03:06 <lambdabot> Done.
13:03:25 <sclv> hmm... yeah, this is reducible to padding first and then using the built in transpose.
13:04:31 <geekagent> > map (>>= maybeToList) [[Just 1, Just 2, Just 3],[Just 4, Just 5, Nothing],[Just 6, Nothing, Nothing]]
13:04:32 <lambdabot>  [[1,2,3],[4,5],[6]]
13:04:32 <sclv> @src transpose
13:04:33 <lambdabot> transpose []             = []
13:04:33 <lambdabot> transpose ([]   : xss)   = transpose xss
13:04:33 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
13:04:53 <oerjan> :t maybeToList
13:04:54 <lambdabot> forall a. Maybe a -> [a]
13:05:11 <EvilTerran> gods, that last line of transpose is ugly
13:06:59 * EvilTerran seems to recall quite a smart definition based on his "zipAllWith :: (a -> b -> c) -> (a -> c) -> (b -> c) -> [a] -> [b] -> [c]" function
13:07:43 <b_jonas> > catMaybes [Just 4, Just 5, Nothing]
13:07:44 <lambdabot>  [4,5]
13:07:48 <EvilTerran> transpose [] = []; transpose (r:rs) = zipAllWith (:) return id (transpose rs) -- iirc
13:07:55 <geekagent> @src catMaybes
13:07:55 <lambdabot> catMaybes ls = [x | Just x <- ls]
13:08:07 <b_jonas> hmm
13:08:14 <b_jonas> @src [] fail
13:08:15 <oerjan> @undo [x | Just x <- ls]
13:08:15 <lambdabot> fail _      = []
13:08:15 <lambdabot> concatMap (\ a -> case a of { Just x -> [x]; _ -> []}) ls
13:09:04 <EvilTerran> http://hpaste.org/3052 <- zipAllWith
13:09:08 <geekagent> @undo (>>= maybeToList)
13:09:08 <lambdabot> (>>= maybeToList)
13:09:32 <b_jonas> @undo \x -> x >>= maybeToList
13:09:33 <lambdabot> \ x -> x >>= maybeToList
13:09:44 <b_jonas> @undo \x -> do { x; y <- maybeToList y; }
13:09:45 <lambdabot>  Parse error at "}" (column 35)
13:09:45 <geekagent> @src maybeToList
13:09:45 <lambdabot> maybeToList  Nothing   = []
13:09:45 <lambdabot> maybeToList  (Just x)  = [x]
13:09:53 <b_jonas> wtf
13:10:13 <oerjan> @redo  \x -> x >>= maybeToList
13:10:14 <lambdabot> \ x -> do { a <- x; maybeToList a}
13:10:25 <EvilTerran> @help redo
13:10:25 <lambdabot> redo <expr>
13:10:25 <lambdabot> Translate Monad operators to do notation.
13:10:28 <EvilTerran> cool
13:10:34 <b_jonas> @undo \ x -> do { a <- x; maybeToList a}
13:10:35 <lambdabot> \ x -> x >>= \ a -> maybeToList a
13:11:15 <oerjan> @@ @pl @undo \ x -> do { a <- x; maybeToList a}
13:11:16 <lambdabot>  (maybeToList =<<)
13:12:28 <oerjan> @@ @redo @unpl (maybeToList =<<)
13:12:29 <lambdabot>  (\ a -> do { b <- a; maybeToList b})
13:13:09 <oerjan> @unpl (maybeToList =<<)
13:13:10 <lambdabot> (\ a -> a >>= maybeToList)
13:13:40 <b_jonas> @@ @undo @redo @undo @redo \x -> x >>= maybeToList
13:13:40 <lambdabot>  \ x -> x >>= \ a -> maybeToList a
13:13:42 <sclv> good grief this grammar I'm trying to implement has an insane amount of rules.
13:13:54 <b_jonas> sclv: what kind of grammar?
13:14:00 <sclv> http://www.antlr.org/wiki/display/ST/Expressions
13:14:02 <lambdabot> Title: Expressions - StringTemplate - ANTLR Project
13:14:34 <sclv> just when I think I've got it mainly covered, I notice some new "feature" added in v. 3.0
13:14:58 <sclv> e.g., "Applying Alternating Templates To Multi-Valued Attributes"
13:22:14 <sclv> *Main> trans' 0 [[1,2,3],[4],[6,7,8],[9],[10,11,12]]
13:22:15 <sclv> [[1,4,6,9,10],[2,0,7,0,11],[3,0,8,0,12]]
13:22:23 <sclv> its ugly but it works!
13:26:01 <r3m0t> hello. is there a class for things that have inverses?
13:26:13 <hpaste>  sclv pasted "Padded Transpose" at http://hpaste.org/4658
13:26:58 <sebas_> Why is my haskell compiled program so big? 2.8MB for a "hello world"
13:27:38 <sclv> r3m0t: I think conal created a bijection in one of his libraries
13:28:00 <EvilTerran> i've seen class Dual discussed
13:28:02 <sarehu> I only get 417482 for "hello world"
13:29:11 <EvilTerran> (class Dual a where dual :: a -> a {- dual.dual = id -})
13:29:14 <sclv> Dual is in monoid, right?
13:29:20 <geekagent> r3mot: that sounds like a group or a field
13:30:02 <EvilTerran> sclv, ah, that's a different Dual to what i was thinking of.
13:30:06 <EvilTerran> better call mine something else ;)
13:30:13 <geekagent> r3m0t: that sounds like a group or a field
13:30:24 <EvilTerran> geekagent, we heard you the first time
13:30:58 <EvilTerran> but i don't think it is; groups, fields, etc are more to do with binary operators
13:31:20 <EvilTerran> sure, given an identity element of a binop, you can also have an inverse, tho
13:31:47 <EvilTerran> in that case, you've got a group, yes
13:35:48 <sw17ch> So, i noticed Gentoo added 6.8.2 to the unstable amd64 branch recently. I updated and noticed a few packaged broke.. have i missed something obvious?
13:41:25 <shivernz> sw17ch, did you run ghc-updater after?
13:42:02 <sw17ch> shivernz: probably not :)
13:42:13 <shivernz> give that a go :)
13:42:27 <sw17ch> i figured it was something similar... oh yep.. there it goes, everything is broken =)
13:43:05 <shivernz> you'll probably need to unmask some of the packages too. i think i had to aswell
13:43:15 <sw17ch> i know perl has one of those, python, and every one else... just wasn't sure what GHC's was... i guess i could have tried the [program name]-updater model though
13:43:32 <sw17ch> i have quite a few unmasked... i had 6.6.1.. which required quite a few
13:44:06 <shivernz> i have 7 in total. though i haven't installed many 3rd party modules
13:46:29 <sw17ch> me either
13:46:35 <sw17ch> so, hopefully this is okay =)
13:46:57 <sw17ch> hmm... i remember gtk2hs taking a very long time to build...
13:47:55 <sw17ch> well, i'll see how this works. thanks again
13:48:06 <shivernz> np
14:06:03 <sw17ch> hmm... so that ran, but now i'm having an issue finding the parsec libary
14:06:07 <sw17ch> library*
14:11:56 <sw17ch> $ ghc --make [snip] -package parsec -v
14:11:56 <sw17ch> Glasgow Haskell Compiler, Version 6.8.2, for Haskell 98, stage 2 booted by GHC version 6.8.2
14:11:56 <sw17ch> Using package config file: /usr/lib64/ghc-6.8.2/package.conf
14:11:56 <sw17ch> *** Deleting temp files:
14:11:56 <sw17ch> Deleting:
14:11:59 <sw17ch> *** Deleting temp dirs:
14:12:01 <sw17ch> Deleting:
14:12:03 <sw17ch> ghc-6.8.2: unknown package: parsec
14:17:11 <RayNbow> @src iterate
14:17:12 <lambdabot> iterate f x =  x : iterate f (f x)
14:17:31 <RayNbow> lambdabot really makes you lazy :p
14:22:29 <Saizan> sw17ch: ghc-pkg list parsec doesn't give anything?
14:28:05 <r3m0t> > 27 + 8
14:28:08 <lambdabot>  35
14:28:15 <r3m0t> thanks :P
14:31:13 <wy> Is "--\" something special? If \ appears just behind --, it's not considered to be a comment
14:32:06 <SamB> > let a --+ b = a + b in 1 --+ 3
14:32:09 <lambdabot>  4
14:33:14 <wy> SamB: It can be an operator ...
14:34:36 <dmhouse> wy: I think there are only a few characters c such that "--" ++ [c] starts a comment.
14:35:22 <wy> dmhouse: None letters?
14:35:34 <wy> dmhouse: None symbols
14:35:47 <dmhouse> Heh, sorry for the awkward phrasing.
14:36:00 <dmhouse> > let (---) = id in (---) 4
14:36:01 <lambdabot> Unbalanced parentheses
14:36:12 <dmhouse> wy: nope, '-' works.
14:36:22 <wy> dmhouse: It should :-)
14:36:25 <dmhouse> wy: and of course ' ' and '\t' do
14:36:34 <wy> Because some people like ------------------------------
14:36:54 <dmhouse> Yeah, just what I was thinking.
14:37:01 <dmhouse> wy: I imagine all this is in the report somewhere.
14:38:08 <dmhouse> > [(1,2)..(3,5)]
14:38:10 <lambdabot>   add an instance declaration for (Enum (t, t1))
14:38:10 <lambdabot>     In the expression: [(1, ...
14:38:14 <wy> dmhouse: It doesn't matter too much. Normally I just use ' ' after --
14:38:24 <dmhouse> wy: that sounds like a good plan to me.
14:38:39 <hpaste>  sclv annotated "Padded Transpose" with "Fixed (I think), but uglier" at http://hpaste.org/4658#a1
14:39:20 <wy> dmhouse: This time it surprised me because I too quickly added two -'s in front the code
14:39:31 <sclv> I don't like the take n hack, but I don't see any way around it.
14:40:40 <dmhouse> ?hoogle foldr
14:40:41 <lambdabot> Prelude.foldr :: (a -> b -> b) -> b -> [a] -> b
14:40:41 <lambdabot> Data.List.foldr :: (a -> b -> b) -> b -> [a] -> b
14:40:41 <lambdabot> Data.Foldable.foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b
14:45:00 <lz> ?hoogle Nonogram
14:45:01 <lambdabot> No matches found
14:46:33 <loupgaroublond> @src nub
14:46:33 <lambdabot> nub = nubBy (==)
14:46:44 <loupgaroublond> @src nubBy
14:46:45 <lambdabot> nubBy eq []             =  []
14:46:45 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
14:48:11 <loupgaroublond> is that just a filter for uniques?
14:48:47 <dmhouse> loupgaroublond: it's a generalised version of nub, which extracts the unique elements from a list, yes.
14:49:25 <loupgaroublond> dmhouse: thanks :), i wasn't sure what nub was either
14:50:44 <loupgaroublond> actually, is there a function somewhere like flattenPackageDescription that can let you specify which flags should be set?
15:01:32 <gmh33> when running make on GHC does it first build itself then build itself with the fresh build?
15:02:01 <dmhouse> gmh33: if you don't already have an older GHC installed, you probably shouldn't be trying to build GHC.
15:02:13 <gmh33> dmhouse: I have 6.6.1
15:02:28 <gmh33> just curious, since I'm building 6.8.2 at the moment
15:02:49 <dmhouse> Oh, in which case I dunno. Interesting question
15:03:41 <gmh33> :)
15:04:04 <Saizan> yes, there's a stage1 and a stage2 compiler
15:04:34 <Saizan> and stage1 is not a full ghc
15:05:01 <gmh33> ah, that's kind of what I thought
15:05:21 <gmh33> thanks
15:06:04 <loupgaroublond> can you bootstrap GHC without a haskell compiler at all?
15:06:16 <Saizan> yes, with a C compiler
15:07:11 <loupgaroublond> ah, just curious :)
15:09:27 <geekagent>                                
15:09:34 <geekagent> \zzz
15:09:59 <geekagent> 0v                  2
15:13:55 <geekagent> 0v                  2
15:14:47 <EvilTerran> catamorphic typing detected?
15:19:30 <gmh33> loupgaroublond: the catch it that unless you have someone with an identical(?) system it's much harder ;)
15:20:04 <loupgaroublond> gmh33: bootstrapping or package flattening?
15:20:17 <gmh33> bootstrapping
15:21:00 <loupgaroublond> gmh33: i was curious from a distro building point of view though, not a coding and hacking point of view
15:21:44 <gmh33> loupgaroublond: ah, as long as you generate the correct .hc files you don't need a working copy of ghc around
15:22:10 <loupgaroublond> ah
15:22:38 <gmh33> intermediate C files aren't platform independent at all
15:23:46 <loupgaroublond> they look like they could win an obfuscated code contest
15:24:21 <gmh33> isn't that the result of most compilers? heh
15:28:01 <Saizan> well, bootstrapping with C is used to port GHC to new platforms, so i suppose there's something else :)
15:30:17 <gmh33> Saizan: not as far as I can tell
15:30:49 <gmh33> you have to do your best at cross compiling then hack at the RTS
15:31:11 <gmh33> and a few other things
15:37:29 <hpaste>  stribb pasted "fst on a list" at http://hpaste.org/4659
15:38:13 <stribb> anyone care to clue me in what the associated error: list.hs:5:0: Parse error in pattern, means?
15:38:15 <dmhouse> stribb: that's listToMaybe.
15:38:32 <dmhouse> stribb: and you need (x:_) in the pattern
15:38:38 <stribb> aha
15:38:42 <dmhouse> I think.
15:38:54 <dmhouse> > let f x:xs = 4 in f [1..10]
15:38:55 <lambdabot>  Parse error in pattern at "in" (column 16)
15:38:56 <dmhouse> Yep.
15:39:06 <stribb> I *think*, on looking further, I probably just want head
15:39:12 <stribb> but I'm discomfited by its type
15:39:40 <dmhouse> Yeah, it's a partial function.
15:39:54 <stribb> What's one of them?
15:40:19 <dmhouse> stribb: one that gives you an error for certain inputs.
15:40:26 <stribb> only valid for some valid inputs?
15:40:29 <dmhouse> Right
15:40:31 <stribb> ok
15:41:17 <stribb> Maybe it's a philosophical point, but are these idiomatic Haskell?
15:43:04 <dmhouse> stribb: partial functions? Yes, they're used quite a bit, but you have to be careful. They're just more convenient than constant case analysis or pattern matching, but they can lead to completely odd-looking and mostly intractable errors.
15:49:16 <ndm> partial functions are really handy
15:49:16 <lambdabot> ndm: You have 1 new message. '/msg lambdabot @messages' to read it.
15:54:33 <qebab> okay, so I've written my first actual module, and I'm importing it into a Main module I want to compile to try this out. When I :load the main module in ghci it works, but when I try to ghc it -o it it tells me it can not find the module. Is there any way I can specify on the command line what ghc has to search for in order to find it? The module has the same name as the file it is in
15:55:00 <TSC> qebab: Are you using --make ?
15:55:30 <qebab> TSC: ah, I just did man ghc | grep module, I'll try that
15:55:49 <TSC> As in, ghc --make Main
15:55:49 <qebab> yeah, that works, thanks a lot
15:55:54 <qebab> yeah :)
15:55:58 <TSC> You're welcome, and merry Christmas! (:
15:56:25 <qebab> merry christmas to you as well
15:56:52 <qebab> the compose operator is awesome and should be mandatory in every language by the way
15:57:34 * stribb wonders what compose applied to regexes would mean
15:57:41 * allbery_b wonders how much more dangerous php would be with a compose operator :)
15:58:04 <jsnx> it wouldn't make any sense in ruby, shell, perl, php
15:58:07 <jsnx> or java
15:58:10 <qebab> alright, regexes and php are dangerous enough already ):
15:58:11 <jsnx> compose what?
15:58:23 <jsnx> functions aren't values in most languages
15:58:36 <jsnx> so you can't apply any operators to them
15:58:57 <stribb> jsnx: ok but Ruby has named blocks, doesn't it?
15:58:59 <allbery_b> well, actually, perl's list context behaves much like function composition.
15:59:02 <qebab> well, of course it makes no sense when you don't have first-class functions and I probably should have said that, but still
15:59:04 <stribb> You could compose them?
15:59:05 <jsnx> stribb: no
15:59:14 <jsnx> stribb: it does not
15:59:51 <jsnx> stribb: you can take the block passed to a function and give it a local name -- but you can't name a bunch of blocks and pass them around
16:00:20 <jsnx> stribb: there is only ever one block at a time -- *the* block
16:00:21 <stribb> oh right
16:00:34 <jsnx> now, in pyhton, you can name functions
16:00:52 <jsnx> so, python could have a compose that takes two functions and returns a function
16:01:07 <stribb> sure
16:01:12 <jsnx> stribb: python is the closest i can get to haskell in a mainstream language
16:02:10 <EvilTerran> any language with first-class functions could have a compose function defined, tho
16:02:21 <jsnx> EvilTerran: yes
16:02:24 <EvilTerran> not sure what allbery_b means about perl's list context
16:02:32 <stribb> Are Scheme and Lisp too far out for you?
16:02:46 <qebab> Scheme could definitely have a compose
16:02:49 * Vq^ has seen pythonprogrammers reinventing the compose function
16:03:07 <jsnx> stribb: they are no more mainstream than haskell or o'caml
16:03:09 <Valodim_> it's christmas and you guys talk haskell?
16:03:12 <Valodim_> gee :P
16:03:36 <Vq^> Valodim_: of course
16:03:42 <qebab> Valodim_: I've had 18 hours christmas and now I need to relax a little
16:03:45 <qebab> :)
16:03:50 <EvilTerran> but it should be possible to even use (.) as composition in perl, if you use overload "." => sub { my ($f,$g) = @_; return sub { $f->($g->(@_)) } }
16:03:54 <MyCatVerbs> jsnx: I'd call Common Lisp a *tiny* bit more mainstream than Haskell. But both less mainline than OCaML.
16:03:57 <Valodim> :)
16:04:07 <jsnx> MyCatVerbs: fair enough
16:04:09 <EvilTerran> you'd need to bless your functions into the class you did that in, mind
16:04:12 <Vq^> Valodim: besides, not everybody celebrate christmas
16:04:19 <Valodim> kwanza?
16:04:21 <qebab> you "bless" functions in perl?
16:04:31 <EvilTerran> you bless references
16:04:44 <jsnx> by mainstream, i mean: python, perl, php, ruby, CLR crud, C, C++, Fortran and Java
16:04:48 <MyCatVerbs> jsnx: and Haskell ever so slightly more exotic than Scheme, too. OCaML --> Common Lisp --> Bit of a gap here --> Scheme --> Haskell
16:04:50 <qebab> that seems about as insane as most perl code I've already seen
16:04:51 <Vq^> Valodim: perhaps midvinterblot :)
16:04:54 <EvilTerran> in a constructor, you attach a reference to the class with the bless() function
16:05:02 <qebab> Fortran is hardly mainstream anymore though, jsnx
16:05:05 <EvilTerran> Valodim, wintereenmas!
16:05:14 <jsnx> MyCatVerbs: but when it comes to convincing your boss, they are all way in left field
16:05:28 <jsnx> qebab: yeah, but there's still plenty of work in it
16:05:44 <qebab> jsnx: yeah but by that definition COBOL is also mainstream
16:05:48 <MyCatVerbs> jsnx: depends whether you're self-employed. ;)
16:05:54 <jsnx> qebab: yes, i forgot COBOL
16:06:02 <jsnx> MyCatVerbs: i am self-employed
16:06:07 <MyCatVerbs> qebab: indeed. I'd call that a pretty good definition, then.
16:06:27 <MyCatVerbs> jsnx: handy. :)
16:06:37 <jsnx> MyCatVerbs: but the person who cuts my check is unwilling to accept delivery in just any old language...
16:06:44 <Valodim> haha, wintereenmas
16:06:44 <qebab> MyCatVerbs: well I'm still a student so these languages aren't those my friends choose to pick up, hence I have no real knowledge of them :)
16:06:45 <Valodim> geek :P
16:06:51 <MyCatVerbs> (Or just working for fun, or studying. Guess which two categories I fall into? Yay.)
16:07:02 <jsnx> MyCatVerbs: studying?
16:07:12 <MyCatVerbs> jsnx: Both! \o/
16:07:18 <MyCatVerbs> jsnx: (and there was much rejoicing)
16:07:28 <jsnx> MyCatVerbs: lolz
16:07:36 <qebab> rejoice, for very bad things are about to happen!
16:07:58 <qebab> I'm starting to like FP more and more
16:08:05 <qebab> never really touched it much before
16:08:42 <MyCatVerbs> Personally, the thing I'm finding most useful right now? Concurrent Haskell.
16:08:54 <MyCatVerbs> Mental note to hug SPJ and friends.
16:09:20 <qebab> the potential for concurrency was one of the reasons I wanted to learn it in the first place
16:09:46 <kb_> erlang is extremely nice for that
16:09:54 <Valodim> prop though
16:10:06 <MyCatVerbs> kb_: I should look into that too.
16:11:49 <MyCatVerbs> qebab: well, I find the ability really easily to forkIO & forkOS potentially-blocking IO work off into seperate threads (and not have to worry about pissing off the OS scheduler with too many threads, too! All hail green threads!) damn useful.
16:11:52 <qebab> is there something like a string-join in prelude? basically so that join ", " ["foo", "bar", "baz"] => "foo, bar, baz"
16:12:09 <qebab> threading tends to get bloody ugly heh
16:12:23 <Valodim> ++
16:12:26 <lucca> qebab: words/unwords/lines/unlines kinda annoyed me in their lack of generality
16:12:27 <MyCatVerbs> > (concat . (intersperse ", ")) ["foo", "bar", "baz"]
16:12:28 <lambdabot>  "foo, bar, baz"
16:12:36 <qebab> ah, cool
16:13:15 <qebab> lucca: yeah I found those but I often want to split on something and join on something else and that's not always spaces and newlines
16:13:22 <qebab> @hoogle intersperse
16:13:22 <lambdabot> Data.List.intersperse :: a -> [a] -> [a]
16:13:23 <lambdabot> Data.ByteString.intersperse :: Word8 -> ByteString -> ByteString
16:13:23 <lambdabot> Data.ByteString.Char8.intersperse :: Char -> ByteString -> ByteString
16:13:27 <lucca> and not always strings :p
16:13:31 <qebab> that too
16:15:21 <EvilTerran> @hoogle intercalate
16:15:22 <lambdabot> Data.List.intercalate :: [a] -> [[a]] -> [a]
16:15:22 <lambdabot> Data.ByteString.intercalate :: ByteString -> [ByteString] -> ByteString
16:15:22 <lambdabot> Data.ByteString.Char8.intercalate :: ByteString -> [ByteString] -> ByteString
16:16:50 <Japsu> intercalate = concat . intersperse?
16:17:24 <EvilTerran> (concat .) . intersperse, i think
16:17:28 <EvilTerran> ?type (concat .) . intersperse
16:17:30 <lambdabot> forall a. [a] -> [[a]] -> [a]
16:17:39 <Japsu> > intercalate "foo" ["bar", "baz"]
16:17:40 <lambdabot>   Not in scope: `intercalate'
16:17:46 <Japsu> bah
16:18:09 <MyCatVerbs> Perhaps it's new in 6.8?
16:18:19 * MyCatVerbs pokes \bot, pondering what version it's up to now.
16:18:24 <sw17ch> Saizan, this is from a while ago... my ghc-pgk list only produces 11 lines
16:18:30 <sw17ch> and does not contain parsec
16:18:48 <sw17ch> 34 packages
16:19:00 <qebab> before I go and reinvent split symbol sequence, does that exist as well?
16:19:18 <byorgey> MyCatVerbs: indeed, it is
16:19:19 <MyCatVerbs> qebab: split symbol sequence?
16:19:43 <qebab> as in split ", " "foo, bar, baz" => ["foo", "bar", "baz"]
16:19:51 <MyCatVerbs> byorgey: I'm noticing a lot of stuff like that. It's going to make reading Haskell articles a world-class pain in the arse now, because most of the machine I use are still on 6.6.1 ;)
16:19:55 <byorgey> qebab: alas, that does not exist.
16:20:00 <qebab> okay
16:20:04 <byorgey> MyCatVerbs: heh
16:20:20 <qebab> err, yeah and I was pretty unclear when I said symbol heh
16:20:32 <qebab> split substr str would probably be a better description
16:20:44 <MyCatVerbs> byorgey: I'm already seeing things like blog posts defining `on` in the middle of the code just to make sure, since at least 2/3rds of their readers are still on 6.6
16:20:58 <byorgey> MyCatVerbs: yeah, I know what you mean
16:21:07 <MyCatVerbs> qebab: no, that doesn't already exist, AFAIK. If you did implement it, AFAIK people would be grateful. :)
16:21:37 <MyCatVerbs> Well, actually, I have no idea what the ratio is. Haskell's userbase is unusually pointy-headed after all, perhaps most people have actually upgraded?
16:22:46 * EvilTerran has upgraded
16:22:49 <byorgey> the problem with that function is that there are lots of slightly different ways to generalize it, and it isn't clear which is the "correct" one
16:22:57 <byorgey> which is why it's not already in the standard libraries
16:23:13 <EvilTerran> well, the generalisations tend to converge again if you generalise far enough... somewhere around parsec ;)
16:23:39 <EvilTerran> @version
16:23:39 <lambdabot> lambdabot 4p581, GHC 6.6 (Linux i686 2.40GHz)
16:23:40 <lambdabot> darcs get http://code.haskell.org/lambdabot
16:24:25 <OceanSpray> 6.8.2
16:25:08 <MyCatVerbs> EvilTerran: hahaha. I've heard it said that the reason Common Lisp comes with such a ridicuously huge collection of incredibly general-purpose macros defined by the standard is to stop people from *ever* feeling the need to write their own versions of basic functionality, because they'd never ever manage to get anything as comprehensive as the stuff that the compiler packages by default. In this way they prevent a certain degree of wheel-reinventio
16:25:26 <EvilTerran> wheel-reinventi?
16:25:51 <allbery_b> yay irc cutoffs
16:25:52 <EvilTerran> seriously, tho, i do tend to throw parsec at my string-splitting problems
16:27:15 <sw17ch> speaking of Parsec... does any one else notice that it doesn't show up with the gentoo install of 6.8.2?
16:27:23 <sw17ch> or am i just missing something :)
16:28:51 <Saizan> well you can get it from hackage, however :)
16:29:08 <Saizan> sw17ch: tried asking on #gentoo-haskell ?
16:29:37 <sw17ch> well, that would be the intelligent thing to do now wouldn't it... :)
16:29:51 <MyCatVerbs> EvilTerran: understandable.
16:30:18 <MyCatVerbs> EvilTerran: and the convention of sticking ? at the end of functions returning booleans is from Scheme, not Common Lisp, silly. ;)
16:30:34 <EvilTerran> beg pardon?
16:31:20 * EvilTerran knew that, so is confused (clisp uses p instead of ?, iirc)
16:31:32 <allbery_b> Lisp prefers -p, doesn't it?
16:31:33 <allbery_b> heh yes
16:31:49 <MyCatVerbs> EvilTerran: ...I got confused by you saying "wheel-reinventi?" >_>
16:32:01 <EvilTerran> ah. i meant you got cut off there
16:32:12 <EvilTerran> in case there was more to come than "ng"
16:33:18 <ndm> the old lisp joke is to do things like "state of the world p" as a way of saying "how are you?"
16:33:31 <kb_> almost monadic
16:33:54 * EvilTerran is always careful, on irc, to keep his lines short (and his trains of thought sho- ooh, a shiny penny...
16:34:00 <shachaf> ndm: "How are you?" isn't a boolean, though?
16:34:26 <MyCatVerbs> EvilTerran: oh, right. "wheel-reinvention. ;)", sorry.
16:34:31 <kb_> shachaf: indeed, but 'Are you?' is
16:34:33 <MyCatVerbs> (And that was the end of the line.)
16:34:43 <shachaf> (state-of-the-world-p) ;=> nil? :-)
16:34:47 <EvilTerran> ah, okay
16:35:09 * MyCatVerbs thought irssi automatically split lines at the 512-char limit, evidently not. >_>
16:35:11 <ndm> shachaf: no, when people ask me how are you it returns ()
16:35:22 <ndm> (answer is always am fine)
16:35:23 <shachaf> EvilTerran: So short you don't even close your parentheses?
16:35:40 <shachaf> ndm: In Common Lisp, '() is 'NIL, no?
16:35:56 <ndm> shachaf: i reply in Haskell, often lazily
16:36:11 <EvilTerran> shachaf, i figure it'd look wrong, wherever i'd've closed it
16:36:16 <stribb> shachaf: yes
16:36:18 <ndm> my scheme is rusty, and my only lisp is from ACL2, and that was minimal
16:36:43 <EvilTerran> so better to leave it out than put it in the wrong place, imo
16:37:03 <shachaf> Error: Unbalanced parentheses
16:37:35 <EvilTerran> it's to balance out all the ":)"s and whatnot
16:40:08 <Mr_Awesome> who has time to close parenthetical clauses when there are shiny pennies to be had?
16:42:03 <EvilTerran> anywas, this is haskell; i should be able to let the indentation sort it out
16:42:10 <stribb> just bind ] to close-all-sexps
16:45:32 <MyCatVerbs> ndm: the in UK, definately true.
16:46:24 <MyCatVerbs> "Alright?" "Fine." <-- and we accuse the Yanks of being insincere when they say "Have a nice day". Fuck me and my country. :/
16:47:09 <MyCatVerbs> At least it provides a funny way of subverting conversations, by actually giving a meaningful answer to useless small-talk questions like that. Tends to take people aback pretty hard. ^_^
16:47:29 <osfameron> my mum answers "how are you?" with "not very how" when she's in a bad mood
16:48:23 <MyCatVerbs> Heh. Personally, I find "shit" to be the quickest answer to that question that most rapidly converges on the truth. :)
16:48:53 <Valodim> in textual language however, "fu" is even more pregnant
16:49:29 <MyCatVerbs> Not really productive, thouhg.
16:49:30 <MyCatVerbs> *though
16:49:53 <MyCatVerbs> It's just plain hostility, which is something that people automatically know how to deal with.
16:50:20 <MyCatVerbs> Giving an unexpectedly detailed accurate answer to an insincere question puts them off balance a lot more effectively.
16:50:34 <MyCatVerbs> Er, *detailed or accurate
16:51:07 <Valodim> depends on context
16:53:04 <ndm> sometimes people do communicate their mood through the intonation in fine
17:00:46 <radetsky> hey peeps, I'm having trouble building cabal packages. I have the 6.4.1 compiler. Should I upgrade?
17:01:57 <ndm> radetsky: you should definately upgrade your copy of cabal, which you can do without upgrading your compiler
17:02:18 <ndm> radetsky: although if you have no reason to want to stick to 6.4.1, upgrading to 6.8.2 should only bring benefits
17:03:25 <radetsky> the only reason to stick with 6.4.1 is that it is provided by my apt repo
17:03:46 <radetsky> upgrading :: Code -> Work
17:03:57 <Zao> _|_
17:04:12 <ndm> radetsky: which distro?
17:04:22 <radetsky> ubuntu ancient
17:04:39 <ndm> radetsky: upgrading cabal should be a few minutes, and should go well
17:04:52 <ndm> but 6.4.1 is increasingly becoming less tested for newer packages
17:06:20 <radetsky> hrm, I appear to have cabal 1.1.3
17:06:26 <radetsky> is this likely to cause issues?
17:06:42 <radetsky> or am i probably doing something wrong
17:06:43 <ndm> you need Cabal 1.2 at least
17:06:51 <radetsky> roger
17:06:52 <ndm> but you don't need anything to upgrade cabal
17:07:06 <Saizan> since 1.2 the cabal descriptions have a richer syntax
17:07:21 <ndm> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Cabal-1.2.3.0
17:07:22 <lambdabot> http://tinyurl.com/2eey3b
17:07:32 <ndm> grab the repo from there, and install it as you would a normal package
17:07:36 <radetsky> that suggests I need to upgrade
17:07:36 <ndm> then other packages should work
17:07:45 <radetsky> it seemed to be breaking on certain field names
17:07:52 <ndm> you need to upgrade cabal, but not GHC
17:16:46 <radetsky> Saizan, do you know when "build-type" was added?
17:16:53 <radetsky> or anyone, really
17:17:41 <Saizan> no
17:18:56 <radetsky> ok
17:19:03 <radetsky> that's one of the fields that keeps breaking stuff
17:19:10 <Saizan> Fri Jan 12 14:19:59 CET 2007  bjorn@bringert.net * cabal-install.cabal: Added build-type field. Change hs-source-dir to hs-source-dirs (hs-source-dir has been deprecated for some time).
17:19:17 <Saizan> quite recent, it seems
17:19:31 <Saizan> (grepping darcs changes in the cabal repo)
17:19:37 <radetsky> ah
17:20:14 <Saizan> Fri Jan 12 00:30:18 CET 2007  Ross Paterson <ross@soi.city.ac.uk> * add a Build-Type field, and use it in setupWrapper
17:20:49 <Saizan> err, this is the right patch, the former was just a change to cabal-install.cabal
17:33:37 <loupgaroublond> bos, ping
17:54:52 <ddarius> Isn't Andy Gill's "exercise" trivial? http://blog.unsafeperformio.com/?p=14
17:54:54 <lambdabot> Title: 13 Functional Thinking 2b  Deriving an Efficient nub Function 47
17:55:38 <osfameron> would that make it a bad exercise?
17:55:56 <ddarius> osfameron: Yes.
17:58:03 <encryptio> ddarius: define is easy, derive is not. for me, that is.
18:04:54 <wy> To use QuickCheck, do I just need to add "import QuickCheck" to the file I want to check?
18:05:36 <osfameron> I'm not sure I understand what he means by "derive"
18:05:39 <ddarius> wy: You have to write properties ("tests") for it to check.  But yes, except that I think you'd use Test.QuickCheck nowadays.
18:06:13 <wy> ddarius: Ah! That's why it didn't work. Thanks!
18:08:13 <ddarius> osfameron: I'm not sure how he intends for you to go from lists to Sets without some axioms/implementations.  The only approach I see is to view the list implementation as using a list implementation of sets and then to "swap" implementations via data abstraction.
18:08:44 <qebab> it's really quite amazing that, when I get my programs to compile, they always work as expected without bugs
18:09:02 <qebab> in all honesty I'm willing to sacrifice the little sweat to have my programs correct the first time
18:09:48 <qebab> no "oh dear lord where did I dereference free'd memory" anymore :))
18:27:42 <loupgaroublond> how can i figure out where cabal is looking for certain libraries, when it is configruing and building programs?
18:28:32 <davidL> ghc-pkg list
18:29:44 <loupgaroublond> thanks :)
18:44:20 <loupgaroublond> bos, please let me know when you get my latest patch :)
18:44:45 <loupgaroublond> nevermind, he's not online :P
18:44:52 <loupgaroublond> @seen bos
18:44:53 <lambdabot> I saw bos leaving #haskell and #ghc 5h 50m 8s ago, and .
18:45:09 <shachaf> @help tell
18:45:09 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
18:45:18 <loupgaroublond> shachaf: thanks :)
18:45:37 <loupgaroublond> @tell bos please let me know when you get the latest patch i sent you :)
18:45:37 <lambdabot> Consider it noted.
18:47:03 <loupgaroublond> time to see if this works
19:03:12 <ddarius> jukestaposition
19:04:28 <r3m0t> heh
19:12:12 <wy> sigh... the linking problem of gtk2hs still not solved
19:19:52 * ddarius was wondering what the heck a K-monoid was.
19:26:55 <ivanm> ddarius: is that what the KDE devs call monoids? :p
19:27:35 <loupgaroublond> those are QToids, which are really just a cover up for HEMERoids
19:27:43 <r3m0t> >: O
19:28:03 <ivanm> no, no, no... QToids just use the QToolkit...
19:28:11 <ivanm> K-monoids also use the KDElibs
19:53:54 <monochrom> I can't spell Integer. XD
19:55:08 <monochrom> Let k :: m [(Int,Bool)] be a monadic action that returns a list of (Int,Bool)s.
19:55:23 <monochrom> I'm writing this code: (map ((n + ) . toInteger . fst) . filter snd) `fmap` k
19:55:27 <monochrom> Isn't it awful? :)
20:46:43 <Tac-Tics> > [1,2,3] >>= \x -> [x, x*2, x*3]
20:46:46 <lambdabot>  [1,2,3,2,4,6,3,6,9]
20:54:58 <allbery_b> > [1..3] >>= flip map [id,(*2),(*3)]
20:54:59 <lambdabot>   add an instance declaration for (Num ((a -> a) -> b))
20:54:59 <lambdabot>     In the expression: 3
20:55:02 <allbery_b> bah
21:18:37 <OceanSpray> this channel has been unusually inactive for the past few hours.
21:18:46 <OceanSpray> Perhaps because it's Christmas Eve,
21:19:06 <OceanSpray> when respectable programmers and theorists spend time with their families and friends.
21:19:09 <OceanSpray> Aye.
21:20:02 <noblethrasher> ah, first time lurker but I was a little word that this might be a dead channel :)
21:20:19 <noblethrasher> worried rather
21:20:30 <Tac-Tics> it's usually pretty active
21:20:53 <oerjan> It goes in spurts
21:21:02 <OceanSpray> like this little one right now.
21:21:43 <noblethrasher> that is good to know... I've just begun my journey to becoming a hardcore haskeller
21:22:04 <oerjan> > nubBy (((>1).).gcd) [2..] -- obligatory first time lurker demonstration
21:22:07 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
21:24:17 <noblethrasher> that's neat... will it parse and run anyone's code?
21:24:32 <oerjan> single expressions
21:25:04 <oerjan> but yes
21:25:32 <OceanSpray> HardCORE
21:25:39 * ddarius wouldn't be here but his flight got cancelled.
21:26:24 * oerjan heard on the news of an airline that declared bankruptcy, _yesterday_.
21:26:40 <ddarius> noblethrasher: I doubt 344 (which is low) people would stay in this channel and never do anything.
21:26:43 <ddarius> @users
21:26:44 <lambdabot> Maximum users seen in #haskell: 434, currently: 346 (79.7%), active: 6 (1.7%)
21:27:12 <noblethrasher> good point
21:28:30 <noblethrasher> just wanted to get a feel for the place before I start with the newbie questions
21:30:17 <noblethrasher> filter (>5)[1..10]
21:31:19 <noblethrasher> filter (>5) [1..15]
21:31:49 <OceanSpray> we were all noobs once.
21:32:04 <oerjan> initial > obligatory
21:32:15 <OceanSpray> As for me, I'm still one.
21:32:26 <OceanSpray> Let's be FRNDZ!
21:33:09 <oerjan> > filter (>5) [1..15]
21:33:09 <noblethrasher> that sounds like categorically swell idea
21:33:12 <lambdabot>  [6,7,8,9,10,11,12,13,14,15]
21:33:16 <noblethrasher> ah
21:33:21 <noblethrasher> thank you
21:33:58 <oerjan> the > is an abbreviation for @run
21:34:18 <noblethrasher> ok
21:34:45 <oerjan> by someone with a _really_ small and indecipherable handwriting.
21:35:02 <noblethrasher> heh
21:37:12 <noblethrasher> > map (>10) [1..13]
21:37:13 <lambdabot>  [False,False,False,False,False,False,False,False,False,False,True,True,True]
21:38:12 <ddarius> > fix ((0:).(1:).ap(zipWith(+))tail)
21:38:13 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
21:38:51 <oerjan> that's the other obligatory first time lurker demonstration
21:39:19 <noblethrasher> i am duly impressed
21:41:06 <oerjan> > scanl1 (*) [1..] -- for good measure
21:41:07 <lambdabot>  [1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,87...
21:41:19 <Tac-Tics> Haskell is king of the one-liners
21:42:36 <noblethrasher> > zipWith (\x -> cos(x)*cos(x))[1..10][5..99]
21:42:37 <lambdabot>   add an instance declaration for (Enum (b -> c))
21:43:10 <oerjan> need two arguments in that lambda
21:43:17 <noblethrasher> > zipWith (\x y -> cos(x)*cos(x))[1..10][5..99]
21:43:18 <lambdabot>  [0.2919265817264288,0.17317818956819403,0.980085143325183,0.4272499830956932...
21:44:59 <noblethrasher> thanks
21:45:33 <Cale> > zipWith (\x y -> cos x * cos y) [1..10] [5..99]
21:45:34 <lambdabot>  [0.15326333289337704,-0.39957182733611274,-0.7463575749700322,9.510516893444...
21:45:42 <oerjan> > on
21:45:43 <lambdabot>  Add a type signature
21:46:01 <oerjan> > zipWith ((*) `on` cos) [1..10] [5..99]
21:46:02 <lambdabot>  [0.15326333289337704,-0.39957182733611274,-0.7463575749700322,9.510516893444...
21:49:14 <dufflebunk> Trying to configure darcs results in "configure: error: Couldnt figure out how to call GHC.Handle.openFd!"
21:49:31 <dufflebunk> There was a message on the ML that this was fixed, but I still get it when trying 1.1.0pre1
21:50:23 <dufflebunk> although that ML message was from 2005...
21:51:07 <noblethrasher> I'm sure this question gets asked quite a bit... but does anyone have any recommendations regarding resources for understanding monads?
21:52:01 <dufflebunk> noblethrasher: I just did a search and whent down the list until I found one that made sense.
21:52:20 <noblethrasher> yeah, that's pretty much been my strategy as well
21:52:26 <noblethrasher> I may just have to give it time
21:53:28 <oerjan> @go you could have invented monads
21:53:29 <lambdabot> http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
21:53:30 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ...
21:53:36 <noblethrasher> http://www.youtube.com/watch?v=9fohXBj2UEI this may be of use to someone as well
21:53:37 <lambdabot> Title: YouTube - Monads 1
21:54:00 <ddarius> noblethrasher: Read Wadler.
21:54:32 <noblethrasher> thanks for the link, though I've read that one before...
21:55:12 <noblethrasher> thank you ddarius
21:55:17 <gmh33> aww I got a christmas present! ;D
21:55:21 <gmh33> ghc for macosx ppc
21:55:43 <Cale> The Catsters are awesome :)
21:56:27 * dufflebunk attempts darcs 2 instead
21:56:42 <Cale> noblethrasher: I can recommend my tutorials. :)
21:56:47 <gmh33> is 6.8.2 still fubar for osx 10.5?
21:57:10 <noblethrasher> cale: ok, thank you.
21:57:17 <Cale> http://haskell.org/haskellwiki/Monads_as_computation  http://haskell.org/haskellwiki/Monads_as_containers
21:57:33 <Cale> and for a quick intro to IO:  http://haskell.org/haskellwiki/Introduction_to_IO
21:58:10 <ddarius> Cale: They'd be more awesome if the stream of videos was steadier.
21:58:18 <gmh33> noblethrasher: if you want to send me a private message I can try to explain them to you :)
21:58:39 <Cale> http://www.haskell.org/all_about_monads/html/index.html -- this one isn't one of mine, but it has a pretty comprehensive reference of the various monads from the libraries
21:58:40 <lambdabot> Title: All About Monads
21:58:48 <wy> @src (>>)
21:58:49 <lambdabot> m >> k      = m >>= \_ -> k
21:59:07 <wy> @src (>>=)
21:59:07 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
21:59:12 <oerjan> @src Monad
21:59:13 <lambdabot> class  Monad m  where
21:59:13 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
21:59:13 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
21:59:13 <lambdabot>     return      :: a -> m a
21:59:13 <lambdabot>     fail        :: String -> m a
21:59:37 <Cale> and of course, if anything from my tutorials fails to make sense, just ask :)
21:59:42 <wy> Why can't it find (>>=) ?
21:59:50 <oerjan> there is no default for >>=
21:59:51 <Cale> (or in general if you have any questions)
22:00:07 <oerjan> it is part of the minimal requirements for a Monad instance, with return
22:00:10 <Cale> wy: Which bind would it give you?
22:00:20 <oerjan> @src [] >>=
22:00:21 <lambdabot> Source not found.
22:00:25 <Cale> @src [] (>>=)
22:00:26 <lambdabot> m >>= k     = foldr ((++) . k) [] m
22:00:26 <oerjan> @src [] (>>=)
22:00:27 <lambdabot> m >>= k     = foldr ((++) . k) [] m
22:00:38 <Cale> @src Maybe (>>=)
22:00:38 <lambdabot> (Just x) >>= k      = k x
22:00:39 <lambdabot> Nothing  >>= _      = Nothing
22:00:47 <ddarius> @src Cont (>>=)
22:00:48 <lambdabot> m >>= k  = Cont $ \c -> runCont m $ \a -> runCont (k a) c
22:01:05 <gmh33> Best intro to monads(?): http://www.cs.mu.oz.au/research/mercury/tutorial/index.html ;)
22:01:33 <noblethrasher> gmh33: thank you very much.
22:01:53 <ddarius> The best introduction to monads in Haskell are the papers by Wadler.  They are an improvement on all successors.
22:02:24 <gmh33> I think looking at the way Mercury implements IO helped monads click for me
22:02:27 <Cale> ddarius: Apart from the syntax.
22:02:27 <wy> gmh33: What's that language?
22:02:29 <noblethrasher> ddarius: Thanks, I just bookmarked that a few moments ago
22:02:46 <gmh33> wy:  It's a functional imperative language
22:03:02 <ddarius> Cale: That may actually be beneficial.  He laments his earlier paper "Comprehending Monads" for making it seem that monads required special support.
22:03:06 <gmh33> basically prolog + ML-esque type system + functions
22:03:09 <Cale> gmh33: It did? Mercury doesn't use monads for I/O, iirc.
22:03:13 <dufflebunk> I just try to remember that they are functions, not actual values.
22:03:36 <Cale> dufflebunk: what's not an actual value?
22:03:43 <wy> Actually Wadler's first monad paper is quite a good introduction
22:03:49 <gmh33> Cale:  It doesn't, but I think using destructive and unique variables is similar to how monads work behind the scenes
22:04:24 <Cale> gmh33: It's sort of like the "fake" implementation of the IO monad which GHC uses.
22:04:33 <dufflebunk> Cale: monads. As soon as I start thinking about them as values, I get confused since things are no longer functionally transparent
22:04:38 <Cale> (of course, that implementation cheats)
22:04:53 <gmh33> Cale:  aye, but after looking at mercury then looking at a monad tutorial it clicked
22:05:16 <Cale> dufflebunk: Well, for example, a value of type IO String is actually a value, it's just not a String.
22:05:22 <gmh33> that in the background, monads are just balling everything up and sticking a number with it to keep things pure
22:05:34 <Cale> (It's a value which describes some IO action for producing a string)
22:05:49 <dufflebunk> action == function ?
22:05:56 <ddarius> (and at any rate it's the type constructor IO that is (part of) the monad)
22:06:03 <wy> I wonder how the IO actions are finally connected to the real world inside the compiler
22:06:03 <Cale> gmh33: I'm not sure that's the best intuition...
22:06:03 <ddarius> dufflebunk: No
22:06:11 <ddarius> @src IO
22:06:12 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
22:06:19 <Cale> dufflebunk: No, it could be any sort of suitable data.
22:06:35 <Cale> dufflebunk: For example, it might be the abstract syntax tree for a C program which computes a String.
22:06:40 <wy> ddarius: Why is there an extra # before State#?
22:06:44 <ddarius> That's GHC.  Hugs (and HBC, I think) uses a continuation based representation.
22:06:45 <gmh33> Cale: I know, but it helped me "get it"
22:07:06 <ddarius> wy: It's an unboxed tuple, (# .. , .. #)
22:07:18 <wy> ddarius: That's new to me
22:07:28 <Cale> That definition of IO is deceptive.
22:07:32 <ddarius> wy: It's a GHC extension that you usually have no need to care about.
22:07:45 <Cale> The function there isn't really a function, it's typically something impure.
22:07:45 <wy> ddarius: Is it about performance?
22:08:20 <ddarius> wy: Primarily, but the compiler will automatically used them anyway so writing the code manually is rarely a win.
22:08:32 <Cale> I put a definition which provides a better idea of what IO might be like on hpaste
22:08:47 <Cale> (let me find it, it's quite a ways back)
22:09:13 <wy> ddarius: I see there is only two levels of optimization in the compiler. Is there much to be done?
22:09:26 <ddarius> wy: What are you talking about?
22:10:04 <wy> ddarius: -O and -O2... Are there more optimization that can be done?
22:10:22 <jsnx> wy: yes, there are many specific ones...
22:10:54 <ddarius> wy: Those are just convenience flags, and that list is incomplete: there is -O0 and -O3 and I think a space optimizing version too.  Plus, as jsnx said, specific flags tweaking a whole menagerie of things.
22:10:55 <jsnx> wy: also, not all the possible ones are actually implemented yet
22:11:16 <jsnx> ddarius: last i heard, -03 does not do anything
22:12:27 <ddarius> wy: I also don't understand either what you mean by "Is there much to be done?" or why you think there needs to be a new "optimization level" just because more optimizations are added.
22:12:46 <wy> I just hope my small lists and things like v <!> i | i>=0 && i<=2 = [vec3_x, vec3_y, vec3_z]!!i $ v is optimized away
22:13:22 <ddarius> wy: Are you having performance problems?
22:13:36 <hpaste>  Cale pasted "IO" at http://hpaste.org/4661
22:13:46 <Cale> okay, I couldn't find it, so I just retyped it :)
22:13:47 <wy> ddarius: Not yet, because I just started
22:14:11 <Cale> Essentially, the idea is that IO is just a datastructure whose constructors are primitive IO actions.
22:14:13 <ddarius> wy: Most likely your problems are going to be elsewhere.
22:14:22 <Cale> (or ReturnIO/BindIO)
22:15:00 <wy> Cale: I don't quite understand the definition of (>>=) for list
22:15:12 <ddarius> :t flip concatMap
22:15:14 <lambdabot> forall a b. [a] -> (a -> [b]) -> [b]
22:15:17 <wy> @src [] (>>=)
22:15:18 <lambdabot> m >>= k     = foldr ((++) . k) [] m
22:15:30 <Cale> The RTS will just evaluate main in order to determine which constructors it's made up from, and execute the actions described
22:15:53 <Cale> wy: it's equivalent to   xs >>= f = concat (map f xs)
22:16:17 <Cale> I don't understand why it's written that way either.
22:16:30 <Cale> They could at least have used concatMap
22:16:49 <ddarius> @index concatMap
22:16:50 <lambdabot> Data.List, Prelude
22:17:13 <ddarius> @src concat
22:17:13 <lambdabot> concat = foldr (++) []
22:17:29 <oerjan> Cale: the report uses concat (map k m)
22:17:33 <ddarius> foldr c n . map f = foldr (c . f) n
22:19:16 <Cale> gmh33 / dufflebunk: does that picture of IO make sense?
22:19:34 <Cale> (the one I pasted on hpaste)
22:21:26 <wy> Cale: Is list monad ever useful?
22:21:37 <Cale> wy: regularly
22:21:47 <ddarius> wy: List comprehensions map directly to list monad code.
22:22:28 <wy> Is it mainly useful in nested maps?
22:22:32 <Cale> It's even more useful than plain list comprehensions once you involve things like the Control.Monad library and monad transformers like StateT
22:22:45 <Cale> > filterM (const [True, False]) [1,2,3,4]
22:22:46 <lambdabot>  [[1,2,3,4],[1,2,3],[1,2,4],[1,2],[1,3,4],[1,3],[1,4],[1],[2,3,4],[2,3],[2,4]...
22:22:51 <Cale> > filterM (const [True, False]) [1,2,3]
22:22:52 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
22:23:04 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
22:23:05 <lambdabot>  [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2,...
22:23:30 <ddarius> > liftM2 (*) [1,2] [3,5]
22:23:31 <lambdabot>  [3,5,6,10]
22:23:51 <wy> cool
22:24:08 <ddarius> wy: The list monad is a (crappy but convenient) implementation of backtracking search.
22:24:26 <Cale> It's not always crappy, it's often exactly what you want.
22:24:34 <wy> ddarius: why crappy?
22:24:54 <ddarius> wy: Because it is incomplete, inefficient, and inflexible.
22:25:00 <Cale> ddarius: oh?
22:25:09 <Cale> How is it inefficient?
22:25:32 <ddarius> Cale: Incompleteness already makes it potentially infinitely inefficient.
22:25:57 <Cale> hm? Are you just talking about the fact that selecting from infinite lists doesn't work?
22:26:09 <Cale> I suppose it's less efficient than purely using functions, but it's more flexible than that.
22:26:12 <ddarius> Cale: For incompleteness.  I'm not saying it's always inefficient.
22:26:19 <Cale> (that is, a functional encoding of lists)
22:26:50 <ddarius> Cale: I find tree based versions of the non-determinism monad more compelling.
22:26:52 <Cale> Basically, all that's really missing is some mechanism for diagonalisation.
22:27:50 <Cale> Or various potential means for directing the search after the fact, but that's actually pretty rarely needed.
22:30:49 <Cale> State transforming the list monad produces a very handy monad for solving puzzles.
22:31:09 <ddarius> Cale: State transforming a tree monad would do just the same.
22:32:04 <Cale> well, sure, they're the same thing
22:32:20 <ddarius> Cale: Perhaps for a very loose notion of "the same"
22:32:59 <oerjan> tree = free monad of magmas, list = free monad of monoids
22:33:50 <ddarius> oerjan: No quite.  -Non-empty- trees are free magmas and lists are free monoids.  All free algebras give rise to monads.
22:33:54 <Cale> right, modulo associativity, they're the same. Trees just preserve some additional structure which you're usually not all that interested in.
22:33:56 <oerjan> since monoids are magmas, you get a homomorphism from tree monads to list monads
22:36:07 <ddarius> Cale: Puzzles are case where you can be very interested in that additional structure and that extra structure adds flexibility and completeness.
22:36:43 <wy> @src print
22:36:44 <lambdabot> print x = putStrLn (show x)
22:36:59 <Cale> Without meaningful annotations on the internal nodes of the tree (which is quite a different monad), it doesn't seem all that useful to me.
22:52:39 <ddarius> Cale: There is still trimming that is possible with the tree monad that is not with the list monad.
22:53:19 <Cale> Can't you always just take some intermediate list and filter it?
22:53:51 <ddarius> Modulo incompleteness, yes, but the point is to trim stuff -without- having to go through it.
22:56:05 <Cale> hm?
23:33:10 <dufflebunk> hmm, I just can't seem to build darcs. I've upgraded to GHC 6.8.2, I've tried 2.0.0pre2, 1.1.0pre1, and 1.0.9. Any suggestions (other using the binary version)?
23:39:19 <dufflebunk> For version 1, I get a complain during configure: "Couldnt figure out how to call GHC.Handle.openFd!"
23:39:44 <dufflebunk> For version 2, during make I get "Could not find module `Text.ParserCombinators.Parsec'"
23:46:39 <mxc> is this a good place for newbie questions?
23:46:52 <oerjan> yes!
23:47:07 <mxc> well, i'm going through the parser tutorial on the wikibook
23:47:10 <mxc> http://en.wikibooks.org/wiki/Haskell/Practical_monads#Whitespace
23:47:28 <mxc> http://en.wikibooks.org/wiki/Haskell/Practical_monads#Return_Values
23:47:29 <lambdabot> http://tinyurl.com/yog84n
23:47:43 <mxc> exercise #2
23:48:26 <mxc> so i have a parseString function which accepts any string matching many (noneOf "\""")
23:49:03 <mxc> err, char '"' ; many (noneOf "\""); char '"'
23:49:38 <mxc> and the goal is to also accept strings wtih a backslashed quote in the middle
23:49:47 <mxc> so "sdfd\"sdfd" should be accepted
23:50:38 <mxc> i want to do somehting like:
23:51:18 <mxc> many ((char '"' . char '\\') <|> (noneOf "\""))
23:52:00 <oerjan> . is the wrong operator there
23:52:38 <mxc> maybe char '\\' >> char '"' ?
23:52:51 <mxc> i've got a decent ocaml background but am just starting haskell
23:53:02 <oerjan> yep, that should work, mostly
23:53:26 <TSC> Does <|> include a "try"?
23:53:42 <oerjan> no, that's the "mostly" part :)
23:54:19 <oerjan> you need a try on the first, otherwise it will crash on backslash followed by anything other than "
23:57:32 <mxc> got it
23:57:37 <mxc> ty
