00:13:14 <bos> i like having the opportunity to write a section of text entitled "beware of fail"
00:14:17 <kfish> oh noes >>= epic fail!
00:18:01 <Korollary> epic fail!
00:27:08 <glguy> :t let mfix f c = mfix f $ \ x -> f x $ \ y -> c y in mfix
00:27:09 <lambdabot> forall t b b1. (t -> (t -> b) -> b) -> (t -> b) -> b1
00:34:08 <qweqwe> http://hpaste.org/4449
00:35:18 <qweqwe> what is wrong there ?
00:35:42 <glguy> you indented the second line too little
00:35:49 <glguy> it needs to  be lined up with the first thing after the do
00:35:56 <glguy> do   stuff
00:35:59 <glguy>      here
00:37:18 <hpaste>  glguy annotated "(no title)" with "fixed" at http://hpaste.org/4449#a1
00:38:55 <qweqwe> thanks
00:40:17 <qweqwe> is there haskell function as getInt ?
00:40:41 <qweqwe> because i get Undefined variable "getInt"
00:42:20 <Sizur> is it wise to code exclusively with arrows?
00:43:13 <RayNbow> qweqwe, getInt? You want to do I/O?
00:43:52 <qweqwe> yep
00:44:19 <qweqwe> i got it i should get as char and make from it Int
00:44:34 <qweqwe> That how it works ?
00:46:35 <RayNbow> getChar only gets one character, qweqwe
00:46:57 <Sizur> > read "25" :: Integer
00:46:59 <lambdabot>  25
00:48:21 <RayNbow> so qweqwe, you might want to use getLine, split it with words and then parse the first word with read
00:48:35 <qweqwe> there is no build in function as getInt  ?
00:48:55 <RayNbow> afaik, nope
00:49:04 <qweqwe> ok thanks
00:49:42 <Sizur> > map read (words "23 45 65") :: [Integer]
00:49:43 <lambdabot>  [23,45,65]
00:50:08 <Sizur> > map read (words "23 45 65") :: [Float]
00:50:09 <lambdabot>  [23.0,45.0,65.0]
00:51:06 <Sizur> qweqwe: you dont need to state the type in your code as it will be inferred
01:10:33 <qweqwe> http://hpaste.org/4450
01:10:53 <qweqwe> what is it now there ?
01:11:40 <glguy> Ambiguous variable occurrence "getLine"
01:11:40 <glguy> *** Could refer to: Main.getLine Hugs.Prelude.getLine
01:12:00 <qweqwe> yes i see but why ?
01:12:07 <glguy> why what?
01:12:41 <qweqwe> i am doing recaursive call so why it can"t call itself ?
01:12:56 <glguy> Why is "getLine" ambiguous, you mean?
01:13:04 <qweqwe> yes
01:13:07 <glguy> because it could refer to...
01:13:13 <glguy> Main.getLine
01:13:18 <glguy> Hugs.Prelude.getLine
01:13:41 <qweqwe> ahh
01:13:46 <quicksilver> qweqwe: if you want to redefine a prelude function you need to hide the prelude definition
01:13:52 <quicksilver> import Prelude hiding(getLine)
01:15:32 <mauke> oh, haha
01:15:52 <mauke> .oO( and I was wondering what you're all talking about )
01:16:08 <mauke> turns out it's my ignore list
01:16:35 <kuribas> Does something like this exist?  I need a list or stream containing context information for each element (where context is a map from a key to a values), and efficient ways to transform these streams.
01:17:07 <mauke> [(a, Map k v)]
01:17:22 <kuribas> mauke: is that efficient?
01:17:35 <glguy> kuribas, I'm not sure you could be any more vauge...
01:17:38 <glguy> vague*
01:17:55 <mauke> kuribas: yes, it took only a few keypresses to type
01:19:55 <kuribas> When I traverse the stream, it will take a lot memory to update values?
01:20:05 <mauke> what do you mean by "update"?
01:20:09 <mauke> you can't update values
01:22:28 <kuribas> I thought I could give just the information at each point, like (NewValue "key" value), and then be able to traverse the stream more efficiently.
01:23:15 <kuribas> Or is that to unhaskellish?
01:23:27 <mauke> huh?
01:24:09 <quicksilver> kuribas: it's fairly efficient to build new lists from old lists
01:24:13 <quicksilver> which share most of their data, yes
01:24:32 * glguy wonders
01:24:33 <quicksilver> Map.insert has fairly good sharing between newly constructed value and old value
01:24:35 <glguy> ?quote kuribas
01:24:35 <lambdabot> No quotes match. Maybe if you used more than just two fingers...
01:24:54 <quicksilver> but without a little more detail about what you're doing it's hard to give better answers :)
01:24:57 <mauke> ?quote
01:24:57 <lambdabot> Randroid says: I just wrote a monad that does my laundry. It threads it round and round until it's washed. Now I'm going to work on the Dryer monad.
01:25:09 <kuribas> ok
01:26:15 <kuribas> My idea is to represent a musical score in haskell, and to process them.  I need a list of notes with context information, like grouping, slurs, bar lenght, etc.
01:29:12 <quicksilver> kuribas: That sounds reasonable. Of course a list is only really appropriate if you only ever expect to process it linearly.
01:29:16 <quicksilver> That is, from one end to the other.
01:29:31 <quicksilver> Having said that, on lists which are only a few thousands of items long it won't matter.
01:30:00 <kuribas> quicksilver: A few thousands should be alright.
01:30:18 <kuribas> Although some scores can be pretty big (orchestral scores).
01:30:49 <quicksilver> at which point you might try a more efficient structure
01:30:53 <quicksilver> but really that doesn't matter much
01:30:59 <quicksilver> it won't be very hard to switch
01:31:05 <quicksilver> haskell tends to be easy to refactor
01:31:12 <kuribas> ah :)
01:31:25 <quicksilver> so I'd urge you to try the simple data structure first
01:31:27 <quicksilver> i.e. lists
01:31:32 <kuribas> ok
01:33:50 <kuribas> It's not possible to have a different type, depending on the key, right?
01:34:16 <dmwit> Sure.
01:34:35 <dmwit> You just need to be a bit explicit about it, and tag each different value type with a different constructor.
01:34:56 <dmwit> (That's the whole point of the "data" keyword, really.)
01:44:23 <kuribas> If I want to make sure that the value of a key always has the same constructor, I'll have to check for that myself?  For example so that "length" always has a value IntProperty?
01:44:37 <qweqwe> http://hpaste.org/4451 what is wrong with it ?
01:45:49 <glguy> case counts
01:45:53 <Lemmih> kuribas: Say again?
01:45:56 <quicksilver> kuribas: Possibly. Sounds like a bad use of Map
01:46:05 <quicksilver> kuribas: you probably want something a bit more structured
01:46:34 <quicksilver> Lemmih: he is using Map as a kind of property list, and he wants to have some restrictions on what kind of value you get with particular keys.
01:46:50 <quicksilver> You can do interesting tricks with existential types but that may not be the most elementary solution :)
01:46:59 <Lemmih> qweqwe: functions can't be uppercased.
01:48:13 <kuribas> quicksilver: Maybe I could use a large datatype, but can I have an efficient update?
01:48:22 <kuribas> Or do you have something else in mind?
01:49:34 <quicksilver> kuribas: I think you may be worrying about the wrong things
01:49:51 <quicksilver> kuribas: first get a nice, idiomatic, representation of your data as a haskell type
01:49:56 <quicksilver> *then* worry about if it's inneficient :)
01:50:14 <quicksilver> I might imagine something like:
01:50:24 <qweqwe> http://hpaste.org/4453 and what about that IO ?
01:50:53 <Lemmih> qweqwe: Drop the IO.
01:50:55 <quicksilver> data Note = Note Pitch Duration Volume Expression
01:51:26 <quicksilver> where Expression is a kind of catch-all for various annotations
01:51:29 * quicksilver shrugs
01:52:18 <kuribas> That would be [Expression] then.
01:52:42 <adept> kuribas: or type Expression = [ExpToken]
01:53:37 <quicksilver> kuribas: well, or Expression could have a list structure internal to it :)
01:53:46 <quicksilver> kuribas: but, yes, that's the kind of thing I was thinking of.
01:54:04 <quicksilver> A generic Map key value is more like semistructured data
01:54:13 <quicksilver> you have lots of invariants for your code to take care of
01:54:13 <qweqwe> http://hpaste.org/4454 i dropped but it didn"t helped me
01:54:20 <quicksilver> so, it's a weaker type system.
01:54:31 <quicksilver> it's nice to work a bit more with the haskell type system if possibel.
01:54:41 <kuribas> yes
01:56:49 <qweqwe> http://hpaste.org/4454 i dropped but it didn"t helped me
01:57:50 <TSC> qweqwe: reverseStr shouldn't involve IO at all
01:58:05 <qweqwe> yes i know that
01:58:15 <adept> qweqwe: so drop IO from type declaration?
01:58:22 <qweqwe> but if remove it i get  *** Type           : IO String
01:58:22 <qweqwe> *** Does not match : [Char]
01:58:55 <TSC> That's because getInt is wrong, not reverseStr
01:59:32 <TSC> getInt can't be [Char] if it uses IO...
01:59:54 <qweqwe> getInt:: IO [Char] ?
02:00:08 <TSC> What's it supposed to do?
02:00:33 <qweqwe> get a line and retunr an integer
02:00:48 <qweqwe> the int thing i will write later
02:00:51 <ivant> hi
02:00:58 <TSC> Ok, so it's going to return a string
02:01:09 <TSC> Then it should be IO String (which is the same as IO [Char])
02:01:56 <kuribas> quicksilver: can I update a single element in a large datatype?
02:02:23 <qweqwe> i already tried it and it didn"t workeout http://hpaste.org/4455
02:03:55 <Lemmih> qweqwe: do line <- getLine; return (reverseStr line)
02:04:16 <TSC> qweqwe: By the way, you can annotate old pastes instead of making a new one
02:04:17 <Lemmih> qweqwe: There are plenty of tutorials explaining why things are this way.
02:05:06 <quicksilver> kuribas: you can't update anything in haskell. values are immutable.
02:05:09 <quicksilver> kuribas: :)
02:05:32 <quicksilver> kuribas: however, when you create a new value based on an old with everything the same except one part, the common stuff is shared.
02:05:38 <quicksilver> so it works out fairly well.
02:05:42 <kuribas> How do I do that?
02:06:02 <kuribas> Is there syntax for that?
02:06:19 <quicksilver> with record notation there is a special syntax
02:06:25 <quicksilver> foo { bar = 5 }
02:06:34 <quicksilver> the general concept doesnt only apply to record notation though.
02:07:07 <quicksilver> Anyone: Is it possible to identify a Kleisli category as a subcategory of Hask? I can't see how to do it.
02:07:19 <mauke> the general concept is Foo x y z where at least one of x, y, z are already existing data structures
02:07:49 <qweqwe> Lemmih: can you explain what was wrong with how i wrote it ?
02:07:54 <kuribas> quicksilver: oh, I see.  Nice :)
02:09:01 <Lemmih> qweqwe: 'getline' has type 'IO String', 'reverseStr' only works on Strings.
02:09:56 <Lemmih> qweqwe: Therefore, you can't use 'reverseStr' directly on 'getline'. Fortunately, we have a bunch of combinators for manipulating monads.
02:10:59 <Lemmih> qweqwe: (>>=) can pick out the String but only as long as you stay in the IO monad.
02:11:53 <Lemmih> qweqwe: So, getline >>= (\string -> return (reverseStr string))
02:12:12 <scook0> *cough* liftM *cough* :)
02:12:49 <Lemmih> Lets not make things too complicated.
02:13:18 <scook0> yeah, I had a feeling you used (>>=) for a reason
02:13:34 <scook0> it's something Haskellers need to learn about sooner or later
02:16:05 <Lemmih> qweqwe: So, is it clear now?
02:16:37 <qweqwe> not really i am checking google now
02:17:27 <qweqwe> so what the <- operator does ?
02:17:51 <Sizur> do i get any penalty for having a 100k instances?
02:18:15 <Lemmih> qweqwe: It's syntactic sugar for >>=. "do x <- y; return x" === "y >>= \x -> return x"
02:18:42 <Lemmih> qweqwe: If 'y' has type 'IO String', 'x' will have type 'String'.
02:19:41 <qweqwe> it like makes for loop on   getline and takes from the IO Sting  char by char
02:20:29 <qweqwe> ok i got it
02:20:37 <Lemmih> No, 'getline' is not lazy. It doesn't return anything before '
02:20:42 <Lemmih> No, 'getline' is not lazy. It doesn't return anything before '\n' is encountered.
02:21:39 <qweqwe> [x| x <- xs] here it like for loop so how is it we hava a difference ?
02:22:16 <Sizur> can somebody elaborate on the implications of having a 100k instances? will it even compile?
02:22:19 <scook0> qweqwe: in that case the looping behaviour is caused by the list monad
02:22:42 <scook0> but the getLine code isn't in the list monad -- it's in the IO monad
02:24:14 <Sizur> how is polymorphism implemented at runtime?
02:24:40 <scook0> Sizur: I believe GHC uses dictionary-passing for class-polymorphism
02:24:40 <Sizur> opa that was a dum question. it's only polymorphic at compile time
02:24:55 <jsnx> Parsec is not as short as regexen -- but it can do a lot of the same stuff
02:26:47 <scook0> Sizur: polymorphism doesn't necessarily get resolved at compile-time (AFAIK)
02:28:28 <quicksilver> Sizur: true polymorphism is "erased" by the compiler, in effect
02:28:39 <quicksilver> Sizur: ad-hoc class polymorphism is compiled to dictionary passing
02:28:57 <quicksilver> although the compiler can often optimise the dictionary away
02:28:59 <Sizur> and how is the passing implemented? pointers?
02:29:26 <Sizur> pointers to hashtables?
02:30:03 <scook0> I don't believe hashtables are involved
02:30:04 <Sizur> the real question is do i get penalties for insane number of instances
02:30:08 <scook0> (not that kind of dictionary)
02:30:10 <scook0> more like vtables
02:30:22 <scook0> there shouldn't be runtime penalties
02:30:36 <scook0> though don't quote me on that
02:30:44 <Saizan> the typechecker is not tuned for performance.
02:31:04 <Sizur> i guess i'll have to see how far i can go with it
02:31:25 <scook0> Sizur: out of interest, why are you contemplating insane numbers of instances?
02:31:53 <Saizan> yeah, there's often a way to do that inductively
02:32:04 <Sizur> i'm implementing a relational module based on tuple lists
02:32:29 <Sizur> where attribute names are the types
02:32:29 <scook0> eek
02:33:01 <scook0> any reason you're not using HList?
02:33:07 <Sizur> yeah quicksilver expressed his disapproval for this method already :P
02:33:23 <scook0> (heck, I believe strongly-typed relational-DB interfaces was one of their motivating examples)
02:33:37 <scook0> Sizur: that doesn't surprise me :)
02:33:44 <Sizur> scook0: i came up with this idea before i read the hlist paper and i want to try it's implementation out
02:34:03 <scook0> how will you be writing all these instances?
02:34:04 <scook0> TH?
02:34:07 <Sizur> th
02:34:12 <Sizur> almost done
02:37:01 <quicksilver> Sizur: dictionaries are essentially one-off tuples
02:37:13 <quicksilver> Sizur: they are, of course, passed as pointers. Everything is passed as a pointer!
02:37:16 <quicksilver> (almost :)
02:38:06 <Sizur> thanks :) we'll see very soon how this idea fares
02:45:21 <jre2> anyone recommend http://www.amazon.com/exec/obidos/ASIN/0262062178 ?
02:45:33 <jre2> [Essentials of Programming Languages]
02:49:25 <Sizur> another question: is (\(a,b)->a) absolutely equivalent to (\(a,_)->a)?
02:50:12 <Sizur> from the implementation perspective
02:52:52 <qweqwe> if i want to use module Char how i can do it ?
02:54:42 <dblhelix> qweqwe: add "import Char" at the top of your source file (immediately after the module header, if there is any)
02:54:46 <Sizur> qweqwe: import Data.Char
02:55:12 <jsnx> we sure are a polite bunch :)
02:55:25 <quicksilver> Sizur: yes.
03:00:54 <qweqwe> :edit
03:16:45 <SamB_XP> qweqwe: we don't have any sourcecode, silly
03:17:00 <SamB_XP> at least, not that we can find
03:17:27 * quicksilver edits SamB_XP's source code
03:17:31 <SamB_XP> in any case, we probably haven't been built in millenia
03:19:02 <qweqwe> need help can"t see where is the bad layout http://hpaste.org/4457
03:19:33 <Lemmih> qweqwe: Where's the 'else'?
03:19:59 <qweqwe> didn"t wrote it yet
03:20:06 <qweqwe> ahh
03:20:09 <qweqwe> ok got you
03:22:14 <SamB_XP> writing the else branch is mandatory in Haskell, for some unknown reason ;-)
03:23:53 <Sizur> otherwise then clause becomes a side effect
03:27:23 <SamB_XP> Sizur: eh?
03:27:35 <qweqwe> i can"t understand what is problem there ? http://hpaste.org/4458
03:27:53 <SamB_XP> Sizur: I was thinking more like "otherwise, why bother with the if in the first place?"
03:28:40 <SamB_XP> since the then clause is not a side-effect (though it could be an IO type)
03:28:41 <Lemmih> qweqwe: Is '[]' a number?
03:28:45 <Sizur> well, i guess else can be implicit
03:29:04 <SamB_XP> Sizur: was thinking that it would consist of a call to error
03:29:17 <SamB_XP> like for pattern match failure in a case
03:36:04 <Lemmih> qweqwe: Are you following some kind of tutorial?
03:37:13 <qweqw> yes
03:37:56 <qweqw> but there is too match things that new for me that i sometimes forget things that i already learned
03:43:03 <SamB_XP> qweqw: which one?
03:43:48 <deduct> hi
03:46:18 <deduct> when i say let x = 12345*12345, is a thunk stored?
03:46:39 <Lemmih> deduct: Maybe.
03:47:00 <deduct> is that for the compiler to decide?
03:50:43 <deduct> when it's not a thunk, and it's been evaluated to a value, when i pass that value to some function, is that value copied? it seems, to me, that with it being a value rather than an object, haskell could, underneath the "hood", simply pass a "reference" to the storage rather than copying it
03:51:06 <deduct> am i correct at all?
03:51:21 <mwc> deduct: depends. For a large structure, passing  reference to a thunk is faster
03:51:31 <mwc> on the other hand, with an int, putting it in a register is faster
03:51:54 <deduct> ahh, true-- that's where your "maybe" comes from, i suppose
03:52:09 <mwc> of course, GHC doesn't actually use references to the values. Thunks are actually little executable segments.
03:52:17 <deduct> working out 1024*1024 is most likely faster than storing the expression in a thunk
03:52:31 <mwc> so it actually branches to the thunk, which either continues evaluating, or returns the value immediately
03:53:32 <deduct> makes sense to me, somewhat
03:55:33 <quicksilver> deduct: ignoring unboxing, everything is always passed by reference
03:55:38 <deduct> if i have a value, say, a tuple of many elements-- when i "do something" with this value, say, i use `print' on it, the thunk for that tuple is probably evaluated and then the value passed to print... afterwards, if i use this tuple elsewhere, it's no longer a thunk, right? it's a v-value-?
03:55:48 <quicksilver> right
03:55:53 <quicksilver> thunks are only evaluated once
03:56:01 <deduct> quicksilver: ah, right. that's what i meant. okay..
03:56:05 <quicksilver> (unless they're GCed and then later recreated)
03:58:32 <deduct> i was just pondering the advantages to immutable data structures, one of them being if they never change, you can reference them forever..
03:58:41 <deduct> under the hood, that is
03:58:43 <quicksilver> right
03:58:49 <quicksilver> that is absolutely one of the advantages :)
03:58:55 <deduct> hehehe
03:59:05 <quicksilver> you can also share common parts
03:59:09 * deduct ignores the sneering and murmers of "duh"
03:59:17 <deduct> example?
03:59:22 <quicksilver> if data Foo = Foo Bar Baz
03:59:31 <quicksilver> (where Bar and Baz are "big" structures of some kind)
03:59:36 <deduct> right
03:59:40 <quicksilver> then let x = Foo a b
03:59:42 <byorgey> sneering?  perhaps you are thinking of #c.
03:59:53 <quicksilver> let y = (let Foo a b = x in Foo a c)
04:00:02 <quicksilver> now y shares the same "a" as x does
04:00:11 <quicksilver> although it has a different value in the other field
04:00:42 <deduct> ahhh
04:00:48 <deduct> right!
04:01:59 <deduct> so of course a substring of a string would actually use the same space?
04:02:06 <quicksilver> if you use ByteString yes
04:02:24 <quicksilver> if you use an ordinary [Char] then only "sort of"
04:02:30 <quicksilver> the actual characters would be shared
04:02:31 <deduct> heh, i was thinking the same
04:02:35 <quicksilver> so that much would be the same 'space'
04:02:47 <deduct> yeah
04:03:03 <Saizan> wrt list structure you can share suffixes
04:03:37 <deduct> i don't know about suffixes-- is that another word for the head of the list? or..
04:03:42 <Zao> tails.
04:03:47 <deduct> ahhh
04:03:57 <mwc> > Data.List.tails "hello world"
04:03:59 <lambdabot>  ["hello world","ello world","llo world","lo world","o world"," world","world...
04:04:05 * deduct shouts 'prefix' at himself
04:04:12 <mwc> now, that might look like you make N copies of a length n string
04:04:40 <mwc> which uses N*N storage (actually, 1/2 N*N, but who cares)
04:04:59 <mwc> actually, what it did is create a new list of N "references" to each index of the list
04:05:05 <mwc> so 2*N
04:05:16 <deduct> that's so brilliant
04:05:30 <Saizan> ?src tails
04:05:31 <lambdabot> tails []         = [[]]
04:05:31 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
04:06:30 <scook0> and because all the suffixes are immutable, you don't have to worry about somebody else changing them on you
04:07:04 <scook0> on the other hand, if you do
04:07:12 <scook0> > Data.List.inits "Hello, World!"
04:07:13 <lambdabot>  ["","H","He","Hel","Hell","Hello","Hello,","Hello, ","Hello, W","Hello, Wo",...
04:07:26 <scook0> then you *do* get N copies
04:07:53 <scook0> (forgetting about laziness for a moment, of course)
04:08:10 <deduct> hmm
04:08:17 <Syzygy-> Does that mean that it's better, sizewise, to work with tails . reverse than with inits ?
04:09:11 <mwc> ?quickcheck \xs -> tails xs == tails (reverse xs)
04:09:11 <lambdabot> Unknown command, try @list
04:09:25 <mwc> @list
04:09:25 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
04:09:55 <quicksilver> Syzygy-: much better, yes
04:10:06 <Syzygy-> @quickcheck \xs -> map reverse (tails (reverse xs)) == inits xs
04:10:06 <lambdabot> Unknown command, try @list
04:10:06 <mwc> ?check \xs -> tails xs == tails (reverse xs)
04:10:07 <lambdabot>  Add a type signature
04:10:17 <Saizan> well inits can be lazier, so it depends on how you consume it
04:10:19 <quicksilver> deduct: in all cases though the actual characters are , in principle, shared.
04:10:30 <qweqwe> i have problems with that error http://hpaste.org/4459 need some help
04:10:32 <Syzygy-> mwc: That what you're checking is obviously falls. Take xs = [1,2,3]
04:10:41 <quicksilver> deduct: but, the actual "structure" of the list isn't, in the inits case
04:10:44 <quicksilver> (it is in the tails case)
04:10:47 <mwc> Syzygy-: but it's way  too early for me to think about it
04:10:49 <Syzygy-> > tails [1,2,3]
04:10:50 <lambdabot>  [[1,2,3],[2,3],[3],[]]
04:10:51 <deduct> quicksilver: ah, right
04:10:55 <Syzygy-> > tails [3,2,1]
04:10:56 <lambdabot>  [[3,2,1],[2,1],[1],[]]
04:11:00 <deduct> that makes sense, then
04:11:03 <mwc> I'd much rather have lambdabot do my thinking
04:11:05 <quicksilver> Data.Sequence is capable of pretty good sharing for a variety of substring-like operations
04:11:10 <quicksilver> not perfect sharing, but good
04:11:34 <quicksilver> ByteString has perfect sharing :)
04:11:42 <deduct> :D
04:11:42 <mwc> yeah, my intuition was that it wouldn't work
04:11:48 <quicksilver> and is more efficient for big string anyway
04:11:56 <mwc> but I didn't want to figure out why
04:11:56 <quicksilver> a ByteString parser can be lovely
04:12:04 <Saizan> qweqwe: getInt is already of type :: IO Int, so you've to remove that return
04:12:17 <quicksilver> because all your clever parsed tree can refer back to the actual one and only copy of the chars in meory
04:12:21 <quicksilver> zero-copy parsing, in a sense.
04:12:27 <qweqwe> thanks
04:12:30 <hpaste>  scook0 annotated "(no title)" with "need a "do"" at http://hpaste.org/4459#a1
04:13:07 <qweqwe> now i get Does not match : a -> b -> c
04:13:31 <Saizan> quicksilver: are no more referenced portions of a bytestring GCed?
04:13:44 <scook0> qweqwe: did you add the extra do?
04:13:45 * mux wonders why tails1 = init . tails and inits1 = tail . inits aren't already in Data.List
04:14:15 <qweqwe> no
04:14:30 <quicksilver> Saizan: no. strict bytestrings are held in memory all at once
04:14:38 <quicksilver> Saizan: if you want that, you want lazy bytestrings, which are chunked up
04:14:43 <quicksilver> and otherwise almost as good
04:14:55 <scook0> (qweqwe: see my paste)
04:16:17 <qweqwe> so why you left   return  there ?
04:16:42 <qweqwe> as you told getInt already IO int type
04:17:41 <Lemmih> qweqwe: Don't think he did that intentionally.
04:17:59 <qweqwe> :)
04:20:54 <deduct> hehe
04:22:39 <deduct> i read "Gentle" introduction to haskell, up to Monads, cried myself to sleep, then decided to read YAHT, in which i'm up to chapter seven. but Gentle was sure helpful for a more detailed understanding of some of the concepts covered in YAHT, which seem quite fleeting, imho. quite enjoying this book
04:23:16 <hpaste>  Dirkjan pasted "Datatype to fold" at http://hpaste.org/4460
04:25:13 <scook0> the List and Func cases look like they need a recursive foldHT
04:25:43 <byorgey> the "Gentle" introduction isn't actually all that gentle =)
04:25:55 <deduct> haha, tell me about it!
04:25:56 <hpaste>  scook0 annotated "Datatype to fold" with "does this work?" at http://hpaste.org/4460#a1
04:26:26 <deduct> byorgey: gentle compared to reading the report, no doubt :P
04:26:44 <byorgey> deduct: yes, I suppose so.
04:26:51 <dirkjan> scook0, i feel stupid... thnx :D
04:28:13 <deduct> byorgey: if i recall correctly, it professed to be a suppliment to the report, or something. hehe..
04:35:04 --- mode: irc.freenode.net set +o Igloo
04:43:10 <Sizur> well, compilation time definitely slowed down :P
04:44:04 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/4461
04:44:07 <scook0> not entirely unexpected
04:44:10 <scook0> :)
04:45:33 <Sizur> linking too
04:45:39 <Sizur> of course
04:46:24 <scook0> roughly how many instances are you generating?
04:47:07 <Sizur> only 2365 right now
04:48:00 <Sizur> that's all possible projections of up to 6 dimentional relations
04:48:14 <scook0> how many base types?
04:48:26 <Sizur> base types?
04:48:39 <scook0> never mind
04:48:39 <Sizur> i'm doing multiparams
04:48:47 <scook0> they'd be polymorphic
04:48:57 <Sizur>         instance Projection [(a, b, c, d, e, f)] [(f, e, d, c, b, a)] where
04:48:57 <Sizur>             { project r = map (\ (a, b, c, d, e, f) -> (f, e, d, c, b, a)) r }
04:49:18 <scook0> ah, I see
04:49:28 <scook0> lovely
04:49:34 <ttfh> I'm playing around with writing stuff you'd normally use a monad for directly in CPS, So far I've done a primitive "escaping" computation and the classic example of tagging each leaf node in a tree with a unique number, any suggestions on other things to try?
04:49:53 <Sizur> yeah, limiting by tuple order might be a good idea
04:50:39 <Sizur> tuple element order that is
04:51:58 <scook0> are you treating reordering and selection separately?
04:52:21 <Sizur> projection includes reordering.
04:53:06 <Sizur> selection, renaming, and join are 3 more cases
04:59:08 <masta> m00
05:08:06 <Sizur> do we have any contests named "Who Wants to be a Type System Mutilator"?
05:09:51 <osfameron> "Have flashy functors everywhere?  I do!"
05:10:26 <DRMacIver> Does pattern matching on a character compile to just a linear search or something more efficient?
05:10:30 <osfameron> "Who wants the bother of Monadic State?"
05:10:47 <scook0> DRMacIver: wouldn't it be a numeric comparison?
05:11:12 <scook0> "Turing-complete kind system? Yes please!"
05:12:36 <DRMacIver> scook0: How do you mean? Even if it's a numeric comparison a linear search is still potentially not the best approach?
05:13:03 <DRMacIver> (I'm thinking in terms of template haskell generated code, so potentially a very large pattern match)
05:13:26 <scook0> oh, you're talking about *multiple* patterns?
05:13:30 <DRMacIver> Yes
05:13:34 <scook0> never mind then :)
05:13:48 <DRMacIver> It would seem a bit silly to talk about a linear search on only a single pattern. :)
05:14:01 <scook0> hence my confusion
05:14:26 <scook0> don't patterns match top-down?
05:14:36 <Sizur> you see a lot of silly questions here (i've been author of many) so ppl dont assume :P
05:15:23 <DRMacIver> scook0: Yes, but I was vaguely hoping that compiler would be sensible enough to do some reordering when it's provably safe to do so. :)
05:15:40 <DRMacIver> (i.e. given a set of provably disjoint patterns)
05:16:07 <scook0> Sizur: also, silly questions tend to be easier to answer
05:16:19 <scook0> at least in terms of background knowledge required
05:16:55 <scook0> if somebody asks a hard question, the answer is more likely to be "hmm, that's interesting, I don't really know"
05:18:09 <Sizur> now we know the source of quicksilver's knowledge :P constant hanging-out at chat-rooms and reading hard questions
05:18:47 <Plareplane> i have a silly question
05:18:51 <Plareplane> i have a machine with gmp and one without. ghc bin-dist from gmp-less machine works on both; ghc bin-dist from gmp-ful machine only works on gmp-ful machine (ghc-pkg doesn't work properly and packages aren't registered or something). what am i doing wrong?
05:19:25 <Sizur> i have even better question: what is gmp?
05:20:03 <scook0> @go gmplib
05:20:05 <lambdabot> http://gmplib.org/
05:20:05 <lambdabot> Title: The GNU MP Bignum Library
05:29:04 <DRMacIver> Hm
05:29:18 <DRMacIver> I thought I'd read some generated core to see if ghc did anything interesting with pattern matches on strings
05:29:23 <DRMacIver> Then I remembered I couldn't read core.
05:30:57 <matthew_-> there's a wiki page on it
05:33:34 <DRMacIver> Yeah. But I'll have to save reading that 'till later as I'm supposed to be working and have yet to achieve anything today. :)
05:33:52 <matthew_-> you're doing a PhD too?
05:33:58 <DRMacIver> Ha ha
05:33:59 <DRMacIver> no
05:34:38 <DRMacIver> I'm just writing slow GUI apps in Java. :-/
05:35:24 <ricky_clarkson> I'm writing fast ones.
05:35:27 <scook0> well, you certainly picked the right tool for the job :P
05:35:50 <DRMacIver> Heh
05:35:57 <DRMacIver> It's not actually the GUI that slows it down.
05:36:25 <matthew_-> it's the user?
05:36:30 <DRMacIver> It's that it has dozens of checkboxes, checking any one of which basically says "Do some really expensive calculations and invalidate all the ones you've done previously"
05:37:02 <DRMacIver> "And while you're at it, why don't you try to calculate an approximate solution to this NP hard problem. Thanks."
05:37:15 <matthew_-> hmm. that might be a reasonable excuse then
05:37:40 <DRMacIver> Yeah. Although it slows down the GUI too much while it's doing that, which is just bad design on our part. :)
05:38:08 <scook0> multithreading in Java ... fun
05:38:17 <DRMacIver> Yeah.
05:38:24 <scook0> probably more fun than in C/C++, though
05:38:27 <DRMacIver> We don't do *all* the work on the render thread, but we do too much.
05:38:47 <scook0> at least Java has a defined memory model, even if the implementations don't necessarily follow it
05:39:20 <Sizur> finally i get the hang of this th stuff
05:39:40 <matthew_-> the implementations do, in general, follow it. only they often provide stronger semantics than is strictly necessary
05:39:52 <ricky_clarkson> scook0: The implementations that don't follow it are not Java.
05:39:53 <dmhouse> Sizur: hurrah! Which stuff?
05:40:17 <scook0> I think in the early days of the model there were quite a few VM bugs
05:40:33 <scook0> but it's probably fine now
05:40:34 <Sizur> dmhouse: ADT representation of haskell code
05:41:27 <scook0> dmhouse: Template Haskell
05:41:34 <matthew_-> oh yes. there have been many bugs in the spec of the Java memory model as well as in the implementations
05:41:50 <matthew_-> for a long time, even Sun's JVMs didn't get volatile right
05:42:05 <DRMacIver> I was under the impression that was a spec issue
05:42:18 <DRMacIver> In that the JVM specification didn't make strong enough guarantees about volatile to be useful
05:42:31 <scook0> "If the code and the documentation disagree, they're probably both wrong"
05:42:43 <ricky_clarkson> There wasn't a memory model, I think that was the problem.
05:42:49 <ricky_clarkson> Since Java 5 it's pretty well defined.
05:42:56 <Sizur> scook0: just never say that in the #perl channel
05:43:33 <matthew_-> yeah, they've rewritten the section of the JLS on the JMM three times now.
05:56:47 <ricky_clarkson> > let f xs=if (xs==[]) then [] else minimum xs:f (delete (minimum xs) xs) in f [3,5,1,6,2,2]
05:56:47 <lambdabot>  [1,2,2,3,5,6]
05:57:04 <ricky_clarkson> Is that the best sorting I can implement without mutable state?
05:57:30 <opqdonut> no, you can for example code merge sort
05:58:06 <ricky_clarkson> @go mergesort wikipedia
05:58:07 <lambdabot> http://en.wikipedia.org/wiki/Merge_sort
05:58:07 <lambdabot> Title: Merge sort - Wikipedia, the free encyclopedia
05:58:50 <ricky_clarkson> Is the one I showed O(n^2)?
05:58:55 <opqdonut> yeah
05:59:04 <opqdonut> merge is nlogn even for lists
06:01:18 <quicksilver> ricky_clarkson: your one also calculates minimum twice which is inefficient although doesn't make it any worse than n^2 :)
06:01:45 <ricky_clarkson> I will assume that Haskell optimises that out!
06:02:53 <quicksilver> ricky_clarkson: then you will be wrong.
06:02:56 <quicksilver> AFAIK.
06:02:59 * ricky_clarkson puts his fingers in his ears.
06:03:05 <quicksilver> GHC doesn't do any non-trivial CSE.
06:04:55 <dmhouse> > let f [] = []; f (x:xs) = [ y | y <- xs, y <= x ] ++ [x] ++ [ y | y <- xs, y > x ] in f [3,5,1,6,2,2]
06:04:55 <lambdabot>  [1,2,2,3,5,6]
06:05:06 <dmhouse> I think that's pretty much how Data.List.sort is implemented.
06:05:30 <matthew_-> Data.List.sort is merge sort with a long comment in the source code as to why it shouldn't be quick sort
06:05:36 <quicksilver> that's a pseudo-quicksort, dmhouse
06:05:45 <quicksilver> the library uses merge sort
06:06:11 <matthew_-> @src sort
06:06:11 <lambdabot> sort = sortBy compare
06:06:13 <dmhouse> Perhaps that's how the report's sort is defined, then.
06:06:15 <mauke> > let f [] = []; f (x:xs) = [ y | y <- xs, y <= x ] ++ [x] ++ [ y | y <- xs, y > x ] in f [3,5,1,6,2,2,1,1,2,1,10,9]
06:06:16 <lambdabot>  [1,2,2,1,1,2,1,3,5,6,10,9]
06:06:29 <quicksilver> I think the report sort is an insertion sort, actually?
06:06:34 <quicksilver> @src sortBy
06:06:34 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
06:06:52 <matthew_-> yeah, that's prelude isn't it
06:07:13 <ZsoL> @src Prelude.sortBy
06:07:14 <lambdabot> Source not found. You speak an infinite deal of nothing
06:07:44 <quicksilver> matthew_-: the @src database is essentially manual
06:07:53 <quicksilver> matthew_-: but in most cases it's the haskell report definitino
06:08:00 <matthew_-> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Data-List.html
06:08:00 <ricky_clarkson> > sort [1..10000]
06:08:01 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
06:08:09 <ricky_clarkson> > sort [100000..1]
06:08:10 <lambdabot>  []
06:08:11 <matthew_-> and search for "Quicksort"
06:08:17 <dmhouse> mauke: oops.
06:08:20 <ricky_clarkson> > sort [100000,99999..1]
06:08:21 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
06:08:26 <dmhouse> > let f [] = []; f (x:xs) = f [ y | y <- xs, y <= x ] ++ [x] ++ f [ y | y <- xs, y > x ] in f [3,5,1,6,2,2]
06:08:27 <lambdabot>  [1,2,2,3,5,6]
06:08:32 <ricky_clarkson> > sort [100000000,99999999..1]
06:08:34 <dmhouse> > let f [] = []; f (x:xs) = f [ y | y <- xs, y <= x ] ++ [x] ++ f [ y | y <- xs, y > x ] in f [3,5,1,6,2,2,1,1,2,1,10,9]
06:08:35 <lambdabot> Terminated
06:08:37 <lambdabot>  [1,1,1,1,2,2,2,3,5,6,9,10]
06:08:48 <ricky_clarkson> I thought it would give a stack overflow.
06:08:51 <dmhouse> ?fptools Data.List
06:08:52 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
06:09:23 <ZsoL> > let a = a + 1 in a
06:09:23 <lambdabot>  Exception: <<loop>>
06:09:27 <ZsoL> > let a = 1 + a in a
06:09:28 <lambdabot>  Exception: <<loop>>
06:09:30 <ZsoL> hm.
06:09:40 <ricky_clarkson> > let f [] = []; f (x:xs) = [ y | y <- xs, y <= x ] ++ [x] ++ [ y | y <- xs, y > x] in f [1..1000000]
06:09:41 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
06:11:27 <quicksilver> ricky_clarkson: I don't think merge sort will stack overflow
06:11:37 <quicksilver> ricky_clarkson: it only uses log n stack frames...
06:13:11 <ricky_clarkson> Fair point.
06:22:34 <Sizur> maybe i should write a toilet paper about haskell tuple lists implementing relational model
06:23:10 <quicksilver> a toilet paper?
06:23:20 <quicksilver> that sounds like a strange place to write something ineterseting..
06:23:22 <Sizur> together with bechmarks and possible improvements to the polymorphism system as a result
06:23:52 <Sizur> well, that's a perfect place to read something mind-stimulating
06:23:53 <Sizur> lol
06:24:51 <Sizur> even better if you're frustrated at the writing style of the author -- you know what to do next
06:36:02 <ZsoL> lol
06:36:15 <ZsoL> that's a fine idea
06:43:47 <BMeph> Has anyone compiled Haddock with 6.8 yet?
06:44:24 <dcoutts_> BMeph: 0.8 needs patching to build with 6.8
06:44:29 <dcoutts_> or use 0.9 from darcs
06:44:46 <BMeph> Ah, yes, darcs - thank you! :)
06:45:06 <dcoutts_> or the patch is two lines I think...
06:45:44 <dcoutts_> add array, containers, directory, pretty, process to build-depends
06:47:01 <BMeph> I noticed, that there are some "spacing" lines in the file, that ghc was freaking out over.
06:47:20 <dcoutts_> not sure what you mean
06:48:47 <BMeph> Rather, that Cabal was having problems with. Namely, I think there are two build-depends: lines in it. one without the flag check, and one with it.
06:49:32 <BMeph> Still is - setup.exe: haddock.cabal:14: unrecognised field or section: "^ ^ ^ ^ ^ ^ ^"
06:50:09 <allbery_b> that's a darcs conflict marker
06:50:11 <mauke> darcs merge conflict
06:52:20 <BMeph> O RLY?!?
06:52:48 <BMeph> Interesting...I'll try that. :)
06:57:03 <BMeph> Is there a developer version of darcs? Mine says there is no "merge" command. :|
06:57:50 <dcoutts_> BMeph: darcs revert that file
06:58:13 <dcoutts_> BMeph: indeed just 'darcs revert'
06:58:20 <dcoutts_> you don't want any local changes I think
07:02:44 <dcoutts_> BMeph: if you are in the haddock dir, just run darcs revert and it'll prompt you to revert all the local changes, one by one
07:05:14 <dcoutts_> BMeph: btw, it's ok to talk on channel
07:06:39 <BMeph> So, how about that 6.8.2, much smoother, eh? ;)
07:10:19 <BMeph> Ura! Haddock compiled - thank you all for your help! :D
07:13:59 <dcoutts_> BMeph: I didn't send you any privmsg :-) I just addressed you in the channel
07:14:04 <dcoutts_> glad you've got it working
07:14:31 <dcoutts_> JaffaCake: did you ask waern to look at managing the haddock-0.9 release?
07:14:41 <Plareplane> what's the "right" way to build ghc bin-dist from source tarballs and not have the binaries dynamically link against gmp?
07:16:06 <BMeph> dcoutts_: Hm, maybe I have my "stalker" settings active...
07:16:48 * BMeph checks his Chatzilla preferences
07:16:55 <dcoutts_> heh :-)
07:16:59 <esteban2> hello..
07:17:11 <esteban2> is there any function that detects repetition in a list? ive been looking in prelude but i can't seem to find one
07:17:21 <mauke> group?
07:17:33 <dcoutts_> group . sort?
07:17:36 <esteban2> if there isn't i'll have to write my own, but i just want to make sure tehres already one
07:17:37 <esteban2> list sort
07:18:00 <nominolo> @seen kolmodin
07:18:01 <lambdabot> I saw kolmodin leaving #gentoo-haskell 17h 27m 40s ago, and .
07:18:13 <dcoutts_> nominolo: he's suffering hdd failure atm
07:18:37 <nominolo> dcoutts_: do you know if he knows about the fp-hiring event today?
07:18:44 <dcoutts_> nominolo: he does
07:18:45 <mauke> someone with a userid of WURST just uploaded a perl module called Wurst ...
07:19:01 <nominolo> dcoutts_: good.  thx
07:19:04 <mauke> I wonder if hackage gets people like that
07:19:09 <dcoutts_> > let dups = map head . filter ((>1) . length) . group . sort in dups [1,2,4,6,1,4]
07:19:11 <lambdabot>  [1,4]
07:19:28 <dcoutts_> esteban2: like that ^^^ ?
07:19:30 <nominolo> mauke: what does it do?
07:19:36 <mauke> nominolo: I have no idea
07:19:51 <esteban2> dcoutts_: what's group supposed to do? i dont understand that part
07:19:56 <dcoutts_> mauke: presumably it's for making sausage?
07:19:58 <mauke> but it contains code like  sub wurstli_hello { print "wurstli wurstli\n"; }
07:20:05 <BMeph> @src group
07:20:06 <lambdabot> group = groupBy (==)
07:20:11 <BMeph> @src groupBy
07:20:11 <lambdabot> groupBy _  []       =  []
07:20:11 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
07:20:11 <lambdabot>     where (ys,zs) = span (eq x) xs
07:20:16 <dcoutts_> > group [1,1,2,3,2]
07:20:18 <lambdabot>  [[1,1],[2],[3],[2]]
07:20:22 <dcoutts_> esteban2: ^^
07:20:29 <nominolo> mauke: sounds ... awsome
07:20:40 <esteban2> o..
07:20:42 <dcoutts_> esteban2: groups adjacent values that are equal
07:21:11 <dcoutts_> esteban2: so if you want to group all equal values you need to sort first to get equal values next to each other in the list
07:21:37 <mux> > let uniq = map head . group . sort in uniq [1,1,2,3]
07:21:39 <lambdabot>  [1,2,3]
07:21:52 <esteban2> thanks, but i'd need something simpler.. not that i dont like your idea but my haskell course is way too limited that i guess that my teacher wouldn't like me to use stuff we hadn't seen
07:21:59 <mux> > let uniq = map head . group . sort in uniq [1,3,1,2]
07:21:59 <lambdabot>  [1,2,3]
07:22:30 <esteban2> anyway your solution made me have an idea
07:23:13 <BMeph> esteban2: Did it hurt? ;)
07:23:13 <dcoutts_> mux: we should have a standard uniq in Data.List since it's not the same as nub and it can be made a good deal faster than map head . group . sort  just by altering the sort slightly to discard equal values
07:23:20 <esteban2> lol.. no
07:24:09 <quicksilver> dcoutts_: it may be faster to 'sort into a tree' and then just enumerate the tree
07:24:15 <quicksilver> dcoutts_: I'm not sure, without testing it :)
07:24:37 <dcoutts_> quicksilver: I think there's a simple modification of standard merge or quick sort that discards dups
07:24:42 <quicksilver> there is, yes
07:24:52 <mauke> nominolo: http://nopaste.snit.ch:8001/11802
07:25:08 <dcoutts_> quicksilver: some thing like changing one >= for a >
07:25:54 <jedbrown> > Data.Set.toList . Data.Set.fromList $ [1,2,4,3,5,1,3,2] -- performs well?
07:25:56 <lambdabot>  [1,2,3,4,5]
07:26:17 <quicksilver> jedbrown: should perform asymptotically well, yes
07:26:28 <quicksilver> jedbrown: I don't know what the constant factor is like
07:27:25 <BMeph> What does lambdabot use to get those sources?
07:28:34 <dcoutts_> intuitively I've always thought that heap sort would be a good one and it has the bonus of only having to pay O(n) upfront and then log(n) for each element you extract, so good for lazy applications where you may not use the whole result.
07:29:59 <quicksilver> BMeph: a manual process.
07:30:49 <BMeph> quicksilver: As in "it processes a manual," or "someone does it by hand"? ;)
07:31:10 <quicksilver> BMeph: by hand
07:31:25 <quicksilver> BMeph: not entirely, of course. Some of it comes from the haskell report and some from the prelude
07:31:33 <quicksilver> but there is manual oversight involved
07:33:41 <quicksilver> dcoutts_: yes, intuitively I agree :)
07:51:37 <astrolabe> I'm going to be using a strange computer for a couple of weeks, which only has dial-up.  I'm trying to think of everything I need to take on a memory stick to let me code haskell.  My list is 1) my code, 2) ghc installer, 3) ghc manual, 4) the report.  Any other ideas?  Sadly I can't fit you lot onto the stick.
07:52:27 <mauke> text editor, shell
07:52:50 <astrolabe> mauke: thank you!
07:53:05 <doserj> hackage :)
07:53:19 <astrolabe> doserj: hmmmm :/
07:53:25 <BMeph> Haddock? ;)
07:54:36 <astrolabe> :p
08:05:36 <faxathisia> is Agda similar to haskell?
08:08:35 <pejo> astrolabe, yaht possibly?
08:09:22 <njbartlett_> astrolabe: A decent code editor?
08:10:54 <astrolabe> I'm trying to get emacs, but the site seems to be down.
08:11:15 <astrolabe> pejo: I'm used to the report now, so I'm hoping not to need yaht.
08:12:56 <jedbrown> astrolabe: ghc (libraries) source?  Oleg?
08:15:39 <astrolabe> jed: do you have a url for oleg?  is he available as a lambdabot module?
08:15:52 <jedbrown> @quote oleg
08:15:52 <faxathisia> In the type (a -> b) -> c, is a in a negative position, but b and c are in positive positions?
08:15:53 <lambdabot> Pseudonym says: What was considered 100 milli-Olegs of type hackery five years ago is standard operating procedure these days
08:17:21 <jedbrown> astrolabe: I was thinking, a good paper to mull over.  Take your pick: http://okmij.org/ftp/
08:17:21 <lambdabot> Title: This FTP site
08:18:04 <mrd> faxathisia: yes
08:18:36 <faxathisia> where does this positive/negative naming come from?
08:18:44 <faxathisia> like how do you classify
08:18:54 <mrd> i forgot=)
08:19:13 <jedbrown> faxathisia: is that covariant vs contravariant?
08:19:33 <opqdonut> ?quote
08:19:33 <lambdabot> Runaro^BRS says: shapr: A plone replacement? Call it plwn.
08:19:38 <opqdonut> ?quote
08:19:38 <lambdabot> YHC says: There is currently no debugging system available. Please write correct programs.
08:19:42 <opqdonut> ?quote
08:19:42 <lambdabot> Pseudonym says: "Assuming an advanced compiler, your code will be sent to Oleg who will implement it in the type system."
08:20:16 <ale2> hi
08:20:40 <faxathisia> I don't think so
08:21:05 <faxathisia> It could be..
08:21:14 <ale2> I have a problem with forall - can I ask a question?
08:21:34 <faxathisia> ale2: Yes you can
08:21:38 <mrd> ale2: only if you promise to ask a question
08:22:03 <ale2> mySucc :: forall a. (Enum a) => a -> a
08:22:08 <ale2> mySucc x = succ x
08:22:16 <ale2> I think this should work
08:22:21 <mrd> not in haskell'98
08:22:22 <faxathisia> why write forall a.?
08:22:40 <ale2> but ghc 6.6.1 says: wordCount.hs:5:29: parse error on input `=>'
08:22:50 <mrd> you need extensions
08:22:59 <faxathisia> Why would you want forall ..?
08:23:00 <roconnor> I managed to get some VU students in Amsterdam excited about Haskell today.
08:23:09 <mrd> LexicallyScopedTypes or somesuch
08:23:12 <faxathisia> :t let mySucc x = succ x in mySucc
08:23:13 <lambdabot> forall a. (Enum a) => a -> a
08:23:18 <ale2> I need forall on a more complicated example
08:23:23 <faxathisia> ok.. :)
08:23:29 <faxathisia> What is the more complicated example
08:23:34 <mrd> ok, you can ask a question, so long as you promise to listen to the answer
08:24:16 <ale2> the more complicated example is a function which consists of more than one function and needs all the same types
08:24:27 <ale2> should I post the more complicated function?
08:24:30 <mrd> no
08:24:39 <mrd> your answer is you need to enable language extensions
08:24:58 <ale2> what extension I need?
08:25:27 <mrd> ScopedTypeVariables
08:25:30 <mrd> or ExistentialTypes
08:25:44 <ale2> how do I load this?
08:25:44 <faxathisia> jedbrown, wait yes I think that it is
08:26:04 <mrd> either compile with -X<name> or put {-# LANGUAGE <name> #-} at the top of the file
08:26:07 <faxathisia> I was looking at the crap "(Computer Science)" section which confused me
08:26:21 <mrd> http://haskell.org/ghc/docs/latest/html/users_guide/pragmas.html#language-pragma
08:26:22 <lambdabot> http://tinyurl.com/ysbfs7
08:27:31 <mrd> or you can do the catch-all -fglasgow-exts
08:27:56 <ale2> ok it works - thanks
08:27:56 <ale2> it works with ScopedTypeVariables
08:28:07 <faxathisia> ale2: What's the function though /
08:28:08 <faxathisia> ?
08:28:31 <alexj> @seen igloo
08:28:31 <lambdabot> igloo is in #ghc, #haskell and #darcs. I don't know when igloo last spoke.
08:30:19 <mrd> hah
08:30:32 <mrd> Workshop title: Foundations of Object Oriented Languages
08:31:38 <ale2> wow my more complicated example works out of the box (written by myself) the only problem was this forall
08:31:43 <ale2> thanks guys
08:31:48 <_Zaph0d_> (newbie question) f :: a -> [a]; if length f n > 0 then Just f n else Nothing;  -- is (f n) computed twice?
08:32:15 <mrd> ale2: =)
08:32:22 <mauke> _Zaph0d_: that doesn't compile
08:32:25 <ale2> faxathisia - one moment - I will post it sortly
08:32:26 <_Zaph0d_> sry missing parens
08:32:30 <mauke> need parens around (f n)
08:32:30 <_Zaph0d_> I paraphrased
08:32:35 <faxathisia> f = if ... ?
08:32:35 <mauke> _Zaph0d_: and yes, probably
08:32:58 <mauke> ghc doesn't really do CSE
08:33:00 <faxathisia> the function is not of type a -> [a] ...
08:33:16 <mauke> faxathisia: no
08:33:26 <ale2> ok my function:
08:33:30 <_Zaph0d_> I defined f else where but use it in that if statement
08:33:39 <ale2> mapReduce :: forall k1 k2 v1 v2.
08:33:39 <mrd> ale2: wait
08:33:40 <ale2>              Ord k2
08:33:40 <ale2>           => (k1 -> v1 -> [(k2, v2)])
08:33:40 <ale2>           -> (k2 -> [v2] -> v2)
08:33:40 <ale2>           -> [(k1, v1)] -> [v2]
08:33:40 <ale2>           
08:33:42 <ale2> mapReduce mAP rEDUCE =
08:33:44 <ale2>       reducePerKey
08:33:44 <mrd> nooo
08:33:46 <ale2>     . groupByKey
08:33:48 <ale2>     . mapPerKey
08:33:50 <ale2>   where
08:33:50 <mauke> asdf
08:33:52 <ale2>     mapPerKey :: [(k1, v1)] -> [(k2, v2)]
08:33:54 <ale2>     mapPerKey =
08:33:56 <ale2>           concat
08:33:58 <ale2>         . map (uncurry mAP)
08:34:00 <ale2>     groupByKey :: [(k2, v2)] -> [(k2, [v2])]
08:34:01 <ricky_clarkson> asdf:load
08:34:02 <ale2>     groupByKey =
08:34:04 <ale2>           map (\x -> (fst (head x), map snd x))
08:34:04 <mauke> congratulations, no one can read your code
08:34:06 <ale2>         . groupBy (\(a1, b1) (a2, b2) -> a1 == a2)
08:34:08 <ale2>         . sortBy (\(a1, b1) (a2, b2) -> compare a1 a2)
08:34:10 <ale2>     reducePerKey :: [(k2, [v2])] -> [v2]
08:34:12 <ale2>     reducePerKey = map (uncurry rEDUCE)
08:34:20 <mrd> ?paste
08:34:20 <lambdabot> Haskell pastebin: http://hpaste.org/new
08:34:30 <ricky_clarkson> ale2: You made a funny.
08:34:47 <mrd> all your type annotations are unneccessary
08:35:38 <ale3> test
08:35:48 <ale3> ok my connection was away
08:35:54 <mrd> ?paste
08:35:54 <lambdabot> Haskell pastebin: http://hpaste.org/new
08:36:03 <ale3> did you receive the function?
08:36:06 <faxathisia> yes
08:36:07 <mrd> ^ use that
08:36:13 <mauke> scrambled
08:37:07 <ale3> ok I should use hpaste?
08:37:12 <mrd> always
08:37:13 <faxathisia> in future
08:37:22 * ac laughs at ale
08:37:25 <mauke> in future and pasture!
08:37:37 <_Zaph0d_> how would I avoid computing (f n) twice in  - if length (f n) > 0 then Just (f n) else Nothing;
08:37:46 <faxathisia> let fn = f n in ...
08:37:52 <_Zaph0d_> thanks
08:37:59 <_Zaph0d_> would 'where' work as well?
08:38:05 <hpaste>  alex pasted "mapreduce" at http://hpaste.org/4462
08:38:11 * ptolomy regularly has the urge to make Bill Braskey / "Chuck Norris Joke" style statements about Oleg.
08:38:14 <faxathisia> ... where fn = f n
08:38:20 <mrd> ale3: and all your type annotations are unneccessary
08:38:22 <ale3> ah did I?
08:38:23 <_Zaph0d_> cool thanks
08:38:24 <ale3> :-)
08:38:48 <ac> I like it when I fix my type errors my simply removing the annotations
08:38:56 <faxathisia> I find capitalizing like fOOBAR very odd
08:38:58 <faxathisia> what's that called though?
08:39:09 <mauke> caps lock
08:39:11 <ricky_clarkson> cAPS lOCK cASE
08:39:26 <ale3> faxathisia: ok how can I call a map function otherwise?
08:39:27 <mrd> ale3: but if you do want to put type annotations like that you need ScopedTypeVariables so that the inner functions get the correct types
08:39:47 <faxathisia> ale3: I'd call it map
08:39:53 <faxathisia> ale3: or something like tha
08:40:05 <ale3> mrd: yes I like to give the types explizitely
08:40:22 <ale3> fax: but there is already a map function
08:40:29 <faxathisia> ale3: Yes I know that
08:40:39 <mrd> ale3: normally Haskell wraps an implicit "forall" around any free type variables
08:40:49 <ac> Looking at: http://photos1.blogger.com/blogger/3557/910/1600/annotated_monads.1.jpg
08:40:50 <lambdabot> http://tinyurl.com/y8yjpa
08:41:06 <ac> I get Id, Writer, Maybe, and State (I think) but I don't get [] at all
08:41:23 <ac> and I especially don't get the rest of them
08:41:32 <RayNbow> @src seq
08:41:32 <lambdabot> Source not found. My pet ferret can type better than you!
08:41:37 <faxathisia> ac those pics are nice :D
08:41:51 <mauke> needs more StateT []
08:41:54 <ac> with the Maybe picture, the "X" represents Nothing, right?
08:41:54 <mrd> [] is non-determinism
08:42:16 <ale3> mrd: thanks - yes but all my k1, k2, v1 and v2 need to be the same - you know that
08:42:29 <ale3> and for that I like to use the forall
08:42:34 <mrd> ale3: on the inner functions,  yes, which is what the scoped type vars buys you
08:42:38 <ale3> is there another way to do that?
08:42:53 <mrd> besides letting haskell reconstruct all the types?
08:43:11 <mauke> ale3: yes, don't put type declarations on local functions
08:43:17 <mrd> hacky usage of the function "asTypeOf", ech
08:43:23 <ale3> mrd: ok I can try to obmit the types on the inner functions
08:43:51 <mrd> most people stick to top-level type annotations only
08:44:08 <ale3> ok it works
08:44:21 <ale3> I can just comment out the types on the inner functions
08:44:35 <mrd> then the forall is not necessary
08:44:49 <ale3> mrd: yes but for beginners like me - types help to understand whats going on
08:44:52 <faxathisia> @index map
08:44:52 <lambdabot> Data.IntMap, Data.IntSet, Data.Map, Data.Set, Data.List, Prelude
08:44:59 <mrd> sure
08:45:09 <faxathisia> > let map = (+1) in Data.List.map map [5,6,8,7,3,4]
08:45:12 <lambdabot>  [6,7,9,8,4,5]
08:46:08 <ale3> fax: you mean I could qualify the map function and use map for my argument
08:46:37 <faxathisia> ale3: Yeah, or pick another name, or continue to use mAP, whatever you think is best
08:47:03 <Toxaris> > let map = succ in fmap map [5, 7, 8, 7, 3, 4]
08:47:04 <lambdabot>  [6,8,9,8,4,5]
08:47:29 <faxathisia> :t (<$>)
08:47:30 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:47:49 <faxathisia> > let map = (+1) in map (<$>) [5,6,8,4,3,8,7]
08:47:49 <lambdabot>  Couldn't match expected type `[t]' against inferred type `a -> b'
08:48:03 <faxathisia> @src (<$>)
08:48:03 <lambdabot> f <$> a = fmap f a
08:48:09 <faxathisia> ahaha
08:48:13 <faxathisia> > let map = (+1) in map <$> [5,6,8,4,3,8,7]
08:48:13 <Toxaris> > let map = (+1) in map <$> [5,6,8,4,3,8,7]
08:48:13 <lambdabot>  [6,7,9,5,4,9,8]
08:48:13 <lambdabot>  [6,7,9,5,4,9,8]
08:48:15 <faxathisia> doh
08:49:09 <njbartlett_> @seen dcoutts
08:49:10 <lambdabot> I saw dcoutts leaving #gentoo-haskell, #haskell-overflow, #ghc, #haskell and #darcs 3h 54m 21s ago, and .
08:50:31 <ricky_clarkson> If I wanted to sort some list so that odd numbers came first, then after that I don't care, how would that go?
08:50:47 <mauke> :t partition
08:50:47 <faxathisia> sort . filter odd
08:50:47 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
08:50:56 <mauke> > partition odd [1 .. 10]
08:50:57 <lambdabot>  ([1,3,5,7,9],[2,4,6,8,10])
08:51:06 <mauke> > uncurry (++) . partition odd $ [1 .. 10]
08:51:06 <lambdabot>  [1,3,5,7,9,2,4,6,8,10]
08:51:14 <ricky_clarkson> > flatten . sort . filter odd [1..10]
08:51:14 <lambdabot>  Couldn't match expected type `a -> [a1]'
08:51:27 <faxathisia> :t (sort &&& id)
08:51:27 <lambdabot> forall a. (Ord a) => [a] -> ([a], [a])
08:51:39 <faxathisia> Is this misuse of &&&?
08:51:44 <mauke> > uncurry (++) . partition odd $ [10, 9 .. 1]
08:51:45 <lambdabot>  [9,7,5,3,1,10,8,6,4,2]
08:51:47 <faxathisia> because it seems like this is really not what it's meant for
08:51:53 <mauke> > uncurry (++) . first sort . partition odd $ [10, 9 .. 1]
08:51:54 <lambdabot>  [1,3,5,7,9,10,8,6,4,2]
08:51:59 <ricky_clarkson> > sort . filter odd [1..10]
08:51:59 <lambdabot>  Couldn't match expected type `a -> [a1]'
08:52:12 <ricky_clarkson> I see.
08:52:27 <faxathisia> > (uncurry (++)) . (sort &&& id) . (parition odd) [1..10]
08:52:27 <lambdabot>   Not in scope: `parition'
08:52:29 <ricky_clarkson> So you create a list of what you care about, sort that then join them.
08:52:33 <faxathisia> > (uncurry (++)) . (sort &&& id) . (partition odd) [1..10]
08:52:33 <lambdabot>  Couldn't match expected type `a -> [a1]'
08:52:55 <ricky_clarkson> Would doing it with sortBy be faster (as in order, not necessarily raw performance)?
08:52:56 <faxathisia> > (uncurry (++)) . (sort &&& id) . (partition odd) $ [1..10]
08:52:56 <lambdabot>  Couldn't match expected type `[a]'
08:53:00 <Toxaris> faxathisia: (&&&) is meant as a combinator to be used with arrows. (->) is an arrow. where's the misuse?
08:53:28 <faxathisia> Toxaris I dunno it feels a shame I never saw &&& used for anything other than ->
08:53:47 <ari> > (uncurry (++)) . (sort *** id) . (partition odd) $ [1..10]
08:53:52 <lambdabot>  [1,3,5,7,9,2,4,6,8,10]
08:53:54 <Toxaris> faxathisia: have you seen any other arrows at all? if not, this is to be expected ...
08:53:55 <faxathisia> ohh..
08:54:22 <quicksilver> I've seen the Kleisli arrow!
08:54:30 <Toxaris> faxathisia: not that i have, only read about them, but never used a Arrow-based library
08:54:35 <ricky_clarkson> These examples are sorting the right-hand-side too.
08:54:50 <faxathisia> > id [1..10]
08:54:53 <faxathisia> id is sorting :p
08:54:53 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
08:54:53 <Toxaris> > map pred "ipx!up!jefoujgz!b!hspvq!pg!ibtlfmmfst@!jotufbe!pg!ubmljoh!up!fbdi!puifs-!uifz!pomz!dpnnvojdbuf!uispvhi!mbncebcpu"
08:54:54 <lambdabot>  "how to identify a group of haskellers? instead of talking to each other, th...
08:54:59 <byorgey> ricky_clarkson: no they're not, the right-hand side just happens to be sorted.
08:55:06 <ricky_clarkson> > (uncurry (++)) . (sort *** id) . (partition odd) $ [1,2,4,5,3,7,9,3]
08:55:06 <ari> I've forgotten the trick for reporting the arrow combinators' types for the (->) arrow...
08:55:08 <lambdabot>  [1,3,3,5,7,9,2,4]
08:55:14 <faxathisia> ricky see above
08:55:17 <ricky_clarkson> > (uncurry (++)) . (sort *** id) . (partition odd) $ [1,2,4,5,3,7,9,3,2]
08:55:17 <lambdabot>  [1,3,3,5,7,9,2,4,2]
08:55:21 <mauke> > uncurry (++) . partition odd . sort $ [10, 9 .. 1]
08:55:25 <lambdabot>  [1,3,5,7,9,2,4,6,8,10]
08:55:45 <Toxaris> lambdabot has stolen half of my cleverly encoded comment :(
08:55:54 <ari> @remember Toxaris how to identify a group of haskellers? instead of talking to each other, they only communicate through lambdabot
08:55:54 <lambdabot> Nice!
08:56:20 <Toxaris> but ari saved it :)
08:56:29 <byorgey> you have to admit, it's a pretty efficient way of talking about code =)
08:56:32 <faxathisia> @instances Arrow
08:56:33 <lambdabot> (->), Kleisli m
08:56:33 <ricky_clarkson> What's sort *** id doing?
08:56:38 <mauke> @kwote
08:56:38 <lambdabot> Maybe you meant: quote vote
08:56:39 <ricky_clarkson> :t sort *** id
08:56:40 <lambdabot> forall a a1. (Ord a) => ([a], a1) -> ([a], a1)
08:56:49 <faxathisia> @src Kleisli
08:56:50 <lambdabot> Source not found. I feel much better now.
08:56:52 <faxathisia> @src Kleisli []
08:56:52 <lambdabot> Source not found.
08:56:54 <byorgey> ricky_clarkson: applying sort to one side of the tuple, and id to the other side.
08:56:54 <faxathisia> hm..
08:57:11 <byorgey> > ((+1) *** (+2))  (6,6)
08:57:11 <lambdabot>  (7,8)
08:57:11 <Toxaris> byorgey: sure it is, and it's fun
08:57:18 <mauke> @quote
08:57:18 <lambdabot> eyeris says: grr... I hate the way every haskell tutorial brags about how easy strings are to use. They are only easy once you drink the koolaid.
08:57:23 <ricky_clarkson> If there was a 3-tuple, would you use *** twice?
08:57:27 <ricky_clarkson> sort *** id *** sort, etc.
08:57:27 <faxathisia> Kleisli arrows take a monad?
08:57:33 <faxathisia> ricky no
08:57:33 <byorgey> ricky_clarkson: no, it doesn't work like that
08:57:35 <mauke> ricky_clarkson: no, you'd give up
08:57:42 <ricky_clarkson> I see.
08:57:47 * ricky_clarkson gives up in advance.
08:57:53 <ricky_clarkson> Thanks.
08:57:54 <mauke> you can have a tuple inside a tuple, though
08:57:55 <MyCatVerbs> @quote
08:57:55 <lambdabot> cypherx says: Oh god, C++ is like a lamprey in my urethra.
08:57:58 <Toxaris> ricky_clarkson: no, unfortunately not. you would use (a, (b, c)) instead of (a, b, c)
08:58:01 <mauke> f *** (g *** h)
08:58:26 <njbartlett_> Just successfully built Gtk2Hs against the "native" Mac OS port of Gtk. This means we can now use Gtk2Hs without X11
08:58:30 <ari> :t (id *** (id *** id))
08:58:32 <lambdabot> forall a a1 a2. (a, (a1, a2)) -> (a, (a1, a2))
08:58:32 <byorgey> faxathisia: well, Kleisli arrows have type (Monad m) => a -> m b
08:58:40 <byorgey> :t Kleisli
08:58:41 <lambdabot> forall a (m :: * -> *) b. (a -> m b) -> Kleisli m a b
08:58:50 <faxathisia> Kleisli arrow is simply an arrow (ie. in Haskell, a function) a?m b where m is a monad
08:58:51 <faxathisia> ok
08:59:08 <faxathisia> why is there only two arrows?
08:59:15 <faxathisia> @src (&&&)
08:59:15 <lambdabot> f &&& g = arr (\b -> (b,b)) >>> f *** g
08:59:19 <faxathisia> @src (>>)
08:59:20 <lambdabot> m >> k      = m >>= \_ -> k
08:59:21 <faxathisia> @src (>>>)
08:59:21 <lambdabot> Source not found. Maybe if you used more than just two fingers...
08:59:27 <byorgey> faxathisia: well, you can make your own =)
08:59:27 <faxathisia> I guess >>> is defined for each arrow...
08:59:36 <opqdonut> @src (->) (>>>)
08:59:36 <lambdabot> f >>> g = g . f
08:59:38 <opqdonut> :)
08:59:40 <faxathisia> @src arr
08:59:41 <byorgey> faxathisia: yes, >>> is arrow composition.
08:59:44 <ari> @src Arrow
08:59:44 <lambdabot> Source not found. Do you think like you type?
08:59:46 <lambdabot> class Arrow a where
08:59:48 <lambdabot>     arr, pure   :: (b -> c) -> a b c
08:59:50 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
08:59:52 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
08:59:54 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
08:59:56 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
08:59:58 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
09:00:25 <ari> I wonder which ones have default implementations
09:00:31 <faxathisia> @src first
09:00:31 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
09:00:31 <ricky_clarkson> Ok, my problem has one more facet.
09:00:44 <faxathisia> @src (->) first
09:00:44 <lambdabot> first f = f *** id
09:00:57 <faxathisia> huh
09:01:20 <hpaste>  alex pasted "mapreduce2" at http://hpaste.org/4463
09:01:22 <faxathisia> > (first sort) ([5,6,8,7,5,3],[5,6,8,7,5,3])
09:01:23 <lambdabot>  ([3,5,5,6,7,8],[5,6,8,7,5,3])
09:01:32 <byorgey> many of them have default implementations in terms of the others, so you have some choice in terms of which "primitive" operations you have to implement to get an Arrow instance.
09:01:51 <byorgey> IIRC arr, >>>, first is enough to get the rest.
09:01:53 <ale3> I finished my MapReduce example and added a comment in first place
09:01:53 <ari> "The basic arrow class. Any instance must define either arr or pure (which are synonyms), as well as >>> and first. The other combinators have sensible default definitions, which may be overridden for efficiency."
09:01:58 * ari sees
09:02:08 <faxathisia> oh
09:02:11 <faxathisia> this is from the report?
09:02:23 <ari> faxathisia: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Arrow.html
09:02:23 <lambdabot> http://tinyurl.com/2pgvv4
09:02:34 <quicksilver> ale3: groupBy (\(a1, b1) (a2, b2) -> a1 == a2) is "groupBy ((==) `on` fst)"
09:02:34 <byorgey> Arrows aren't in the report, it's just a library
09:02:52 <ale3> quicksilver: thanks
09:02:56 <quicksilver> ale3: similarly, your sort is "sortBy (compare`on`fst)"
09:02:57 <faxathisia> @src on -- has really neat code
09:02:57 <lambdabot> Source not found. You untyped fool!
09:03:06 <quicksilver> (or comparing fst)
09:03:15 <ale3> ok I have to understand the 'on'
09:03:19 <faxathisia> @src on
09:03:19 <lambdabot> (*) `on` f = \x y -> f x * f y
09:03:28 <faxathisia> so much better than djinns definition
09:03:37 <quicksilver> ale3: it meands pretty much what you wrote :)
09:04:07 <faxathisia> > ((==) `on` (`mod` 3)) 7 10
09:04:09 <lambdabot>  True
09:04:13 <qweqwe> what is wrong there ? http://hpaste.org/4464
09:04:15 <ac> it bugs me how elements of a record end up in the global namespace
09:04:18 <ale3> ah the backticks at on are for being a binary operator
09:04:33 <quicksilver> right
09:04:47 <Toxaris> qweqwe: use && instead of and
09:04:48 <quicksilver> qweqwe: and is wrong there.
09:05:02 <quicksilver> ac: you can jsut about everyone else who uses more than one or two record types :)
09:05:11 <faxathisia> You don't have to make an Eq instance..
09:05:19 <quicksilver> ac: erm, you *and* just about everyone else ...
09:05:20 <qweqwe> i am getting Cannot use type synonym in instance head
09:05:29 <quicksilver> that's also true, atually
09:05:31 <quicksilver> ;)
09:05:37 <ac> quicksilver: selecting an element should be the opposite order: record element
09:05:43 <faxathisia> try ((1,2) :: Battleship) == ((1,2) :: Battleship)
09:05:48 <faxathisia> without the Eq instance.. it should work
09:05:55 <quicksilver> haskell98 doesn't let you write instances for type synonyms
09:06:02 <dmhouse> qweqwe: that's precisely it. You can't use type synonyms in instance heads.
09:06:04 <quicksilver> (Int,Int) already has an Eq instance
09:06:13 <quicksilver> ac: ooh, that's absolutely disgusting!
09:06:14 <quicksilver> ac:  :)
09:06:32 <quicksilver> ac: that completely destroys all the uniformity in haskell syntax...
09:06:37 <ale3> hmm which module has "on"?
09:06:41 <faxathisia> @src on
09:06:41 <lambdabot> (*) `on` f = \x y -> f x * f y
09:06:45 <faxathisia> ale3; ^
09:06:51 <dmhouse> ale3: Data.Function
09:06:52 <ac> quicksilver: oh. well i guess I could prefix all my elements with the name of the record
09:06:53 <quicksilver> ac: "record element" means that record is applied to element, so record must have a function type
09:07:03 <dmhouse> qweqwe: you should either 1) declare your Battleship as a newtype, or 2) don't bother, as your definition of (==) is the same as the normal one for (a, a).
09:07:05 <ale3> yes I wrote `on`
09:07:11 <quicksilver> ac: yeah, I end up doing that. Or putting big records in their own modules. or both.
09:07:21 <ale3> but ghci does not know a on function
09:07:24 <quicksilver> ale3: Data.Function but only in 6.8.x
09:07:27 <faxathisia> (*) `on` f = \x y -> f x * f y -- Is there any haskell syntax -not- used in this code?
09:07:27 <quicksilver> erm
09:07:28 <faxathisia> :D
09:07:46 <ale3> oh I have only 6.6.1
09:07:55 <Toxaris> faxathisia: where, let, do, @, !, data, type, newtype, ...
09:07:57 <opqdonut> faxathisia: comprehensions
09:07:57 <quicksilver> ale3: in 6.6 you can define on yourself, or just leave the code how you ahd it ;)
09:08:08 <quicksilver> ale3: there was nothing wrong with your code, I was just telling you out of interest
09:08:15 <quicksilver> that happens to have been observed as a common pattern
09:08:47 <faxathisia> ok
09:09:06 <faxathisia> Does anyone know of some haskell program which is a decent size and uses arrows to good effect?
09:09:25 <opqdonut> someone had basic signal prosessing stuff done with the stream arrow
09:09:34 <opqdonut> discrete convolution for example
09:09:41 <quicksilver> faxathisia: some of conal elliott's stuff is very interesting
09:09:42 <opqdonut> dunno if that's for "good effect"
09:09:49 <quicksilver> It's not real arrows though, if I understand rightly.
09:10:58 <jedbrown> Does it annoy anyone else that Control.Arrow.pure conflicts with Control.Applicative.pure?
09:11:10 <a2dk> I'm sure there's a neater way of doing a list element replace, but I'm a newbie - http://hpaste.org/4465#a1
09:11:12 <a2dk> http://hpaste.org/4465#a1
09:12:21 <dons> faxathisia: the yampa stuff is full of arrows
09:12:39 <opqdonut> yampa?
09:12:44 <faxathisia> http://haskell.org/yampa/
09:12:53 <faxathisia> cool
09:12:58 <dons> and yampa is used for lots of things. Frag, robots, ...
09:13:05 <faxathisia> I gotta goto stops but I'll check it out
09:13:06 <faxathisia> thanks
09:13:08 <ac> it's amazing how much it helps to have old code you've written hanging around for reference
09:13:18 <quicksilver> jedbrown: yes :)
09:13:20 <qweqwe> still i have a problem there http://hpaste.org/4466
09:13:53 <Toxaris> qweqwe: what do you try to do?
09:14:17 <qweqwe> define == to my new type
09:14:25 <dons> ac: i think that's a developer secret :)
09:14:27 <Toxaris> qweqwe: you have no new type.
09:14:40 <Toxaris> qweqwe: only data and newtype define new types, type doesn't
09:14:46 <quicksilver> qweqwe: there error is with your type, not your instance definition, anyway.
09:15:12 <Toxaris> qweqwe: so you can either use type Battleship = (Int, Int) and use the predefined (==)
09:15:41 <njbartlett_> dons: Gtk2Hs now working on native Mac OSX, ie no X11
09:15:42 <Toxaris> qweqwe: or you write "data Battleship = Battleship Int Int deriving Eq" and use the automatically defined (==)
09:16:04 <Toxaris> qweqwe: or you write "data Battleship = Battleship Int Int" and write your own instance Eq Battleship ...
09:16:06 <dons> njbartlett_: i saw! wonderful news!
09:16:13 <dons> njbartlett_: demo, screenshots please :)
09:16:29 <dons> njbartlett_: maybe build the nice gtk clock on gtk2hs ?
09:16:42 <njbartlett_> dons: Well, the screenshots are identical, except for the absence of an X icon in the Doc
09:16:46 <njbartlett_> Dock
09:16:48 <dons> :)
09:17:34 <njbartlett_> dons: I've only got the minimal stuff working so far, ie no Glade, SVG, etc. Working on that next
09:17:49 <dons> njbartlett++ great news.
09:17:58 <quicksilver> njbartlett_++ # agreed
09:17:59 <dons> everyone's using macs now, so we need a good gui story
09:18:04 <a2dk> http://hpaste.org/4467
09:18:16 <a2dk> There's gotta be a tidier way of doing this.
09:18:25 <njbartlett_> dons: Yeah. I think wxHaskell is getting close too... they're updating to the latest version of wxWidgets.
09:18:42 <njbartlett_> And I do prefer the L&F of wxWidgets vs Gtk
09:18:48 <RayNbow> <lambdabot> (*) `on` f = \x y -> f x * f y <-- I didn't know you were allowed to use (*) as a name for a formal argument
09:19:31 <opqdonut> why not?
09:20:00 <quicksilver> a2dk: (x,y,not b) : ps \\ [(x,y,b)]
09:20:05 <fadec> hackage question (building some hackage archlinux packages): What is meant by base, fps (>=0.7) as a hackage dependency - is this referring to ghc?
09:20:05 <quicksilver> a2dk: I guess
09:20:16 <a2dk> Thanks, what is the \\ operator?
09:20:23 <quicksilver> a2dk: set subtraction
09:20:26 <quicksilver> (delete
09:20:27 <quicksilver> )
09:20:38 <quicksilver> actually it's a slightly cooky multiset delete
09:20:47 <quicksilver> but if your lists are actually sets, you can pretend its set delete
09:20:53 <quicksilver> > [1,2,3,4] \\ [2]
09:20:54 <lambdabot>  [1,3,4]
09:21:11 <a2dk> > [1,2,3] \\ [4]
09:21:12 <lambdabot>  [1,2,3]
09:21:35 <a2dk> @src \\
09:21:36 <lambdabot> (\\) = foldl (flip delete)
09:21:56 <hpaste>  jedbrown annotated "Replace list element" with "If maintaining order matters.." at http://hpaste.org/4467#a1
09:22:52 <a2dk> jedbrown: Order doesn't matter but it's still tidier than the original
09:23:10 <jedbrown> a2dk: You could use Data.Map
09:24:00 <Saizan_> fadec: those are haskell packages
09:24:24 <quicksilver> he could
09:24:32 <quicksilver> I quite often use assoc-lists for maps though
09:24:42 <quicksilver> only switching to maps if I prove the that list is too slow
09:24:48 <faxathisia> RayNbow: It's great eh? :D
09:24:51 <quicksilver> which it wont' be, for "solitaire-board-size" problems
09:25:09 <a2dk> it is solitaire board code :)
09:25:40 <qweqwe> http://hpaste.org/4468 so what is the problem here ?
09:25:52 <faxathisia> qweqwe: lol
09:25:55 <monochrom> Lesson learned from today's xkcd.com cartoon: don't ease up on noobs! you catch more flies with vinegar than with honey! XD
09:25:59 <jedbrown> quicksilver: Sure, but the API for maps is much richer.
09:26:08 <quicksilver> jedbrown: I find it more painful, in general :)
09:26:11 <a2dk> mmm balsamic
09:26:17 <quicksilver> jedbrown: not quite sure why.
09:26:26 <faxathisia> qweqwe: You should define your own data type instead of making a synonym
09:26:34 <byorgey> monochrom: hehe, right.  because fruit flies are of course a perfect substitute for human behavior =)
09:26:36 <faxathisia> qweqwe: Do it like, data Batttleship = Ship Int Int -- or something
09:26:41 <faxathisia> Coordinate Int Int maybe..
09:26:42 <a2dk> quicksilver: where do I find assoc-lists?
09:26:42 <monochrom> hahahaha
09:26:44 <quicksilver> jedbrown: of course, if you want union (merge) then yes you really should use maps
09:26:49 <quicksilver> a2dk: you are already using them :)
09:27:05 <qweqwe> but why i can"t use that tupple ?
09:27:06 <quicksilver> a2dk: and assoc-list or alist is an old LISP term for the practice of storing an association as a list of tuples
09:27:13 <faxathisia> qweqwe: because..!
09:27:16 <quicksilver> traditionally 2-tuples, whilst you're using 3-tuples
09:27:20 <faxathisia> qweqwe: the error message
09:27:23 <quicksilver> but the principle is the same
09:27:42 <RayNbow> faxathisia: well, I was confused at first... my brains interpreted (*) as the multiply operator :p
09:27:49 <a2dk> quicksilver: gotcha. thanks.
09:27:59 <faxathisia> RayNbow: Yeah, It's like one of my favorite haskell one liners :D
09:28:20 <byorgey> qweqwe: using a tuple isn't the problem per se.  the problem is that you're not allowed to declare class instances for type synonyms (defined using 'type Foo = Blah').
09:28:40 <byorgey> qweqwe: you could do data Battleship = Ship (Int,Int) if you really wanted.
09:29:02 <jedbrown> quicksilver: non-head updates are much nicer too.
09:29:03 <byorgey> (although I wouldn't recommend it)
09:30:06 <jedbrown> quicksilver: For instance, his function would be (adjust not)
09:30:26 <quicksilver> jedbrown: yes, that's a good point.
09:30:43 <quicksilver> jedbrown: but list comprehensions are quite nice syntax for complex update too
09:31:06 <a2dk> @src adjust
09:31:06 <lambdabot> Source not found. My pet ferret can type better than you!
09:31:22 <faxathisia> Agda syntax looks like haskell!
09:35:28 <qweqwe> can"t i use data Battleship = (Int,Int) ?
09:35:33 <jedbrown> @doc Data.Map -- a2dk
09:35:33 <lambdabot> Data.Map -- a2dk not available
09:35:38 <jedbrown> @doc Data.Map
09:35:38 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
09:35:46 <faxathisia> qweqwe: two people told you.. maybe you should reforumlate your question
09:35:55 <ac> so... I have a list of maps and I want to return a new list of maps where the first map in the list with a given key has that entry updated
09:36:10 <hpaste>  faxathisia pasted "Arrow, -> and Kleisli defs." at http://hpaste.org/4469
09:36:21 <faxathisia> just came across that
09:36:33 <faxathisia> ari ^
09:37:15 <byorgey> qweqwe: no, data declarations require data constructors.
09:37:23 <ac> anyone care to write my function for me? ;)
09:37:45 <faxathisia> djinn!
09:37:49 <byorgey> data Battleship = Ship Int Int   -- 'Ship' is called a data constructor.  It takes two Ints, and produces a value of type Battleship.
09:38:03 <_ry> is there a wishlist somewhere? i want spidermonkey bindings :)
09:38:22 <byorgey> you can then also pattern match on it: e.g. if you have a function f :: Battleship -> Foo, you can say f (Ship x y) = ...
09:38:23 <ac> [Map k a] k a -> [Map k a]
09:38:25 <faxathisia> Arrows are a monad @_@
09:38:37 <monochrom> No, not all Arrows.
09:38:37 <ac> er, "[Map k a] -> k -> a -> [Map k a]
09:38:45 <byorgey> faxathisia: no, all monads are arrows, but not vice versa
09:38:49 <faxathisia> oh
09:38:54 <monochrom> ArrowApp is Monad
09:39:01 <faxathisia> Kleisli arrows are a monad
09:39:11 <faxathisia> (MonadPlus)
09:39:15 <faxathisia> What is ArrowApp ?
09:39:25 <byorgey> mm, maybe it's called ArrowApply
09:39:31 <ac> can I use djinn through lambdabot?
09:39:35 <faxathisia> I thought there is only -> and Kleisli
09:39:41 <faxathisia> ?djinn a -> a
09:39:42 <lambdabot> f a = a
09:39:42 <jedbrown> ac: \f ms k -> let (as,b:bs) = break (member k) ms in as ++ alter f k b : bs
09:39:55 <byorgey> faxathisia: it's another type class.
09:40:03 <ricky_clarkson> @src partition
09:40:03 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
09:40:03 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
09:40:03 <lambdabot>                               | otherwise = (ts, x:fs)
09:40:11 <ac> jedbrown: break was the function I didn't know about that makes it easier
09:40:14 <ricky_clarkson> :t (~)
09:40:15 <ac> jedbrown: thanks
09:40:15 <lambdabot> parse error on input `)'
09:40:22 <quicksilver> faxathisia: Kleisli arrows are a monad?
09:40:23 <faxathisia> ~ is lazy irrefutable pattern matching
09:40:28 <quicksilver> faxathisia: that doesnt' quite make sense...
09:40:30 <ricky_clarkson> No it isn't!
09:40:34 <ricky_clarkson> (sorry)
09:40:40 <quicksilver> faxathisia: Kleisli arrows are related to a monad.
09:40:41 <hpaste>  faxathisia annotated "Arrow, -> and Kleisli defs." with "Kleisli MonadPlus" at http://hpaste.org/4469#a1
09:40:54 <monochrom> Too much rumour flying around. Don't be taken in. Do your own thorough verification.
09:41:17 <jedbrown> ac: You need to modify for when the key is missing
09:41:32 <ricky_clarkson> @where where
09:41:32 <lambdabot>  @where where
09:41:42 <faxathisia> What is the difference between MonadPlus and Monoid
09:41:46 <alexj> @seen igloo
09:41:46 <lambdabot> igloo is in #ghc, #haskell and #darcs. I don't know when igloo last spoke.
09:42:33 <monochrom> You don't see any difference?
09:42:34 <ac> jedbrown: right
09:42:47 <Toxaris> faxathisia: (1) Monoid is about types (kind *), MonadPlus is about type constructors (kind * -> *).
09:42:48 <ac> jedbrown: first I have to figure out exactly how it works
09:43:07 <Toxaris> faxathisia: (2) Monoid is unrelated to Monad, MonadPlus is a subclass of Monad
09:43:27 <faxathisia> wow :D
09:43:35 <Toxaris> faxathisia: (3) MonadPlus has additonal laws dealing with the interaction of the MonadPlus functions and the Monad functions
09:44:15 <jedbrown> ac: oops, s/alter/adjust/
09:44:22 <ricky_clarkson> partition is stranger than I expected.
09:45:22 <Toxaris> faxathisia: the connection is (not literally in Haskell, but in "what it means"): MonadPlus m => Monoid (m a)
09:45:26 <astrolabe> @type partition
09:45:27 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
09:45:34 <astrolabe> how can that be strange?
09:47:09 <quicksilver> faxathisia: (1) MonadPlusses are also Monads.
09:47:17 <quicksilver> faxathisia: (2) the Kind is different
09:47:36 <quicksilver> Toxaris: "in some natural way"
09:47:50 <quicksilver> Toxaris: that is, the implied Monoid is natural over all types a
09:47:53 <qweqwe> i should redifine both < >  or only < ?
09:48:07 <quicksilver> qweqwe: it's enough to define one of them, if I remember correctly.
09:48:14 <qweqwe> ok
09:48:29 <quicksilver> Toxaris: and some compatibility law with the Monad stuff
09:48:35 <quicksilver> Toxaris: which is itself a point of some debate :)
09:48:51 <Toxaris> quicksilver: what is a "natural Monoid"?
09:49:00 <ricky_clarkson> astrolabe: The implementation.
09:49:05 <ricky_clarkson> @src partition
09:49:05 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
09:49:06 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
09:49:06 <lambdabot>                               | otherwise = (ts, x:fs)
09:49:12 <ricky_clarkson> @check \xs -> (partition odd (xs :: [Integer]))==((filter odd xs,filter (not . odd) xs))
09:49:12 <lambdabot>  OK, passed 500 tests.
09:49:47 <jedbrown> ricky_clarkson: that traverses the list twice, though
09:49:52 <faxathisia> thanks a lot everyone
09:49:59 <quicksilver> Toxaris: natural in the type "A"
09:50:00 <faxathisia> I am really understanding some of this better :)
09:50:21 <quicksilver> Toxaris: this means that the implied Monoid instance on (m a) is compatibilit with the implied monoid instance on (m b)
09:50:29 <quicksilver> Toxaris: in the sense that, if you have a function f :: a -> b
09:50:35 <quicksilver> Toxaris: then f commute with mappend.
09:50:49 <quicksilver> Toxaris: that's what categorists would call a naturality property, restated for haskell values :)
09:51:25 <ac> jedbrown: actually I'll just use insert in this case
09:51:26 <faxathisia> I'm reading Arrow.hs it's really cool :p
09:51:49 <monochrom> I like naturality.
09:52:02 <quicksilver> Toxaris: It happens to be a property of polymorphism.
09:52:16 <quicksilver> Toxaris: if you can write a polymorphic funciton :: a -> [a], that is automatically natural in a.
09:52:28 <Toxaris> quicksilver: because there is only one instance MonadPlus m for (forall a . m a)
09:52:30 <quicksilver> since the MonadPlus instance defines mplus polymorphically in a, it will automatically be natural.
09:52:33 <quicksilver> exactly
09:52:44 <quicksilver> this connection between polymorphism and naturality is a very very beautiful thing.
09:53:28 <byorgey> quicksilver: is this connected with Wadler's "Theorems for free"?
09:56:30 <faxathisia> @index Arrow
09:56:31 <lambdabot> Control.Arrow
09:58:39 <quicksilver> byorgey: I'm embarassed to admit I haven't read it.
09:58:52 <quicksilver> byorgey: it's certainly connected in concept, but I'm not sure if it's mentioend in the paper.
09:58:59 <mrd> that's parametricity theorems
09:59:12 <quicksilver> I read a good paper by Robinson which talks about this stuff
09:59:17 <byorgey> quicksilver: heh, ok. =)  I was just reading it this morning.
09:59:19 <quicksilver> I think that was my first introduction to it.
10:00:42 <byorgey> it just strikes me as similar.  using parametricity, he derives theorems for types which look like they have a lot to do with naturality.
10:01:03 <quicksilver> yes, it is closely related.
10:01:03 <byorgey> @free (a -> b) -> [a] -> [b]
10:01:04 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
10:01:12 <mrd> uh oh
10:01:19 <byorgey> @help free
10:01:19 <lambdabot> free <ident>. Generate theorems for free
10:01:24 <byorgey> @free map
10:01:26 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
10:01:37 <mrd> TANSTAAFT
10:02:00 <faxathisia> What's this generating theorems
10:02:31 <faxathisia> @free map
10:02:32 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
10:02:36 <faxathisia> ok so it's not random..
10:03:18 <faxathisia> @free (>>=)
10:03:18 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
10:03:21 <byorgey> faxathisia: no. =)  The idea is that just given the type of a polymorphic function, you can automatically derive a theorem which any such function must satisfy.
10:03:46 <byorgey> I think (>>=) is not polymorphic enough, since it has a type class constraint.
10:04:28 <jedbrown> @free Control.Applicative.pure
10:04:28 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
10:05:08 <faxathisia> @free id
10:05:08 <lambdabot> f . id = id . f
10:05:10 <faxathisia> @free flip
10:05:11 <lambdabot> (forall x. h . k x = p (f x) . g) => h . flip k y = flip p (g y) . f
10:06:38 <mrd> faxathisia: you're familiar with the concept that the type, forall a. a -> a, has only one possible function implementing it (ignoring _|_), that any function with that type approximates the  function id?
10:06:55 <faxathisia> yes
10:07:47 <mrd> instead of considering the implementation, now we're considering the compositional properties of the possible functions
10:08:06 * _|_ breaks the rules
10:08:31 * mrd logically approximates _|_
10:08:57 <tetha> at least they dont deny your existance, like some object-oriented language with voidpointers :)
10:09:10 <mrd> which should be unit pointers!
10:10:15 <tetha> which should be proper polymorphism *coughs*
10:10:34 <mrd> in C's defense, System F didn't exist at the time
10:10:45 * mrd stops defending C
10:10:48 <tetha> mrd: I dont talk about C
10:11:02 <tetha> mrd: C just uses void pointers and doesnt care much about their voidness ;)
10:11:20 <tetha> I rather meant javas Object-type :)
10:11:34 <sclv_> "I will get Peter Quince to write a ballad of this dream: it shall be called _|_'s dream, because it hath no _|_, and I will sing it."
10:11:47 <mrd> java makes puppies cry
10:12:06 <tetha> thus, I am a puppy.
10:12:08 * tetha looks cute
10:19:53 <faxathisia> I guess very few haskell programmers use Agda for some reason?
10:19:58 <faxathisia> if any at all?
10:25:51 <dons> strict String IO on hackage now.
10:35:46 <mdurr> is the best method for parsing binary files using the foreign marshalling packages?
10:37:12 <qweqwe> i wrote some module in some file how i can use it from my present working file ?
10:37:27 <dmwit> import ModuleName
10:37:51 <dmwit> It helps if the file and its module have the same name.
10:38:05 <dons> mdurr: using Data.Binary if possible
10:38:15 <dons> mdurr: since its an awful lot easier and nicer and faster :)
10:38:30 <dons> mdurr: find Data.Binary in the binary package on hackage.haskell.org
10:38:41 <mdurr> yeah I was just trying to avoid the package
10:38:48 <dons> oh, why?
10:39:14 <dons> its really the best way to do binary io. if you must only rely on base, you'll have to simulate it with say, Data.Bits and hmm hGetBuf
10:40:06 <mdurr> yeah I was using data.bits and bytestrings but having problems going from [word8] -> Num a
10:40:12 <faxathisia> ohh! I should have asked for a Galois Haskell Homework Pencil !
10:40:38 <dons> mdurr: oh, [Word8] is also pretty inefficient.
10:40:49 <dons> mdurr: what type of data are you reading from the input file?
10:41:03 <mdurr> its an md3 model file... so mostly signed ints and floats
10:41:33 <dons> ok. so I'd use Data.Binary.Get for that. using direct get and put calls.
10:41:43 <dons> though its simple enough you could just pull them straight out of a bytestring
10:41:49 <glguy> faxathisia, there are galois pencils?
10:41:50 <dons> i'd *not* go via [Word8]
10:41:59 <faxathisia> yes! http://www.haskell.org/haskellwiki/Humor/Homework
10:41:59 <lambdabot> Title: Humor/Homework - HaskellWiki
10:42:01 <dons> glguy: you don't know about the homework pencil?
10:42:12 <glguy> nuh uh
10:42:17 <dons> check out the link :)
10:42:34 <dons> in the early days of the company, homework consulting was one of the main services
10:42:37 <mdurr> k thanks
10:43:04 <dmwit> heh
10:43:10 <dmwit> "How much do you charge for PhDs?"
10:43:45 <ricky_clarkson> We charge £15 entry for PhDs, and £4 for everyone else.
10:43:57 <ricky_clarkson> Gotta keep the scruffies away.
10:44:52 <dmwit> Did I read that right? 15 franks?
10:46:09 <ricky_clarkson> @bab es en libras esterlinas
10:46:09 <lambdabot>   pounds sterling
10:46:33 <ricky_clarkson> @quote communicate
10:46:34 <lambdabot> Toxaris says: how to identify a group of haskellers? instead of talking to each other, they only communicate through lambdabot
10:50:19 <dmwit> ?quote true
10:50:19 <lambdabot> ghc says: You can get a PhD for explaining the True Meaning of this last construct
10:52:28 <BMeph> @seen malcolmw
10:52:28 <lambdabot> I saw malcolmw leaving #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 37m 24s ago, and .
10:56:24 <dmwit> > (chr 0x6d, chr 0x6b)
10:56:26 <lambdabot>  ('m','k')
10:57:14 <dcoutts_> njbartlett_: cool!
11:02:45 <njbartlett_> dcoutts_: Yeah! They fixed the compile problem with glib. Unfortunately I can't get libglade to work, but the base Gtk stuff works, and so does Cairo
11:02:57 <dcoutts_> great :-)
11:03:07 <dcoutts_> njbartlett_: does it seem to work ok?
11:03:19 <dcoutts_> libglade fails to compile or what?
11:03:50 <njbartlett_> dcoutts_: Yeah all the demo apps (that don't using missing stuff like libglade) work exactly as under X. But there's no X icon on the Dock :-)
11:04:05 <njbartlett_> Yeah libglade gives me a build error that's beyond my abilities to diagnose and fix
11:04:05 <dcoutts_> njbartlett_: it's not too much of a problem, we should start supporting the libglade replacement that is in gtk+ 2.12
11:04:06 <mwc> a new gtk2hs `port' in the words?
11:04:10 <mwc> *works
11:04:22 <dcoutts_> njbartlett_: did you need any changes in gtk2hs itself?
11:04:24 <njbartlett_> mwc: I haven't changed gtk2hs at all
11:04:29 <dcoutts_> excellent :-)
11:05:10 <njbartlett_> Got to go, dinner time
11:05:23 <BMeph> dcoutts_: As an interesting coincidence, I just compiled gtk2hs about an hour ago on the WinXP Pro system at work.
11:06:21 <dcoutts_> BMeph: you built it from source?
11:06:42 <BMeph> The worst time I had was convincing pkg-config to look at the config files in the GTK directory. Once I got that right, it went smooth as butter. :)
11:06:42 <dcoutts_> njbartlett_: did you post news of your success to the gtk2hs-users or -devel mailing list?
11:07:12 <dcoutts_> BMeph: would you like to put together some updated build instructions, the current ones on the gtk2hs website are outdated
11:07:22 <roconnor> @seen dons
11:07:22 <lambdabot> dons is in #haskell and #xmonad. I last heard dons speak 24m 48s ago.
11:07:27 <BMeph> dcoutts: gtk2hs, I did. not glib/gtk+ or cairo, though - I love computers, but I don't want to marry one... ;)
11:07:57 <dons> roconnor: yo.
11:08:02 <dons> roconnor: quick though, heading to a meeting..
11:08:07 <dcoutts_> BMeph: sure, starting with pre-built gtk etc. That's what I do for the gtk2hs installers.
11:08:34 <BMeph> dcoutts_: Sure, I'll do that when I get home - which should be in about four-to-five hours.
11:09:10 <roconnor> dons: I taught monads to students in amsterdam in 30 minutes!
11:09:16 <roconnor> dons: as me about it later :)
11:09:19 <dcoutts_> BMeph: great, thanks
11:09:22 <roconnor> ask me about it
11:09:30 <dons> roconnor: awesome :)
11:09:30 <hpaste>  Chris Rathman pasted "constructor shorthand" at http://hpaste.org/4470
11:09:55 <bos> roconnor: please tell!
11:09:56 <BMeph> @remember BMeph I compiled GTK2Hs from source, but not the actual GTK+ or Cairo package. I love computers, but I don't want to marry one. ;)
11:09:56 <lambdabot> Done.
11:10:15 <bos> it's bad manners to quote yourself.
11:10:34 <BMeph> @remember roconnor I taught monads to students in amsterdam in 30 minutes! ask me about it
11:10:35 <lambdabot> Nice!
11:10:36 <CRathman> Does Haskell have a shorthand for constructors like ML?  Vect {x=x, ...}
11:10:50 <roconnor> BMeph: :)
11:11:04 <bos> CRathman: yes
11:11:08 <sek> CRathman, yes, use ; instead of ,
11:11:24 <CRathman> still use the triple dots?
11:11:30 <dcoutts_> sek: huh? ';' ?
11:11:36 <sek> oh, is it not?
11:11:40 <dcoutts_> CRathman: yep, it's a recent addition, the "..." shorthand
11:11:50 <roconnor> bos: I only had 30 minutes, so I didn't really everything.
11:11:58 <dcoutts_> CRathman: you need to specify the language extension to use it
11:12:11 <roconnor> bos: I said that monads were more or less overloaded ;
11:12:26 <roconnor> bos: then I gave several example of different monads with different ; operations
11:12:40 <dcoutts_> sek: it's ','  Constructor { name1 = v1, name2 = v2 }
11:12:46 <CRathman> dcoutts_: I'm using GHC 6.4.2 - is it available there?
11:12:55 <dcoutts_> CRathman: no, 6.8 minimum
11:12:58 <bos> roconnor: cool
11:13:03 <sek> dcoutts_, oh sorry, my memory fails me then, havent used them in a few months
11:13:28 <CRathman> dcoutts_:  thanks.  will see if I can upgrade
11:13:34 <dcoutts_> sek: s'ok it's not a crime to forget syntax :-)
11:13:39 <sek> :)
11:13:42 <roconnor> bos: I mostly focused on two non-determinism examples
11:13:46 <Saizan_> what are the "..." for in haskell?
11:13:57 <bos> roconnor: which ones? list and random?
11:14:06 <roconnor> bos: they didn't fully understand everything, but they were interegued, which is all that I wanted.
11:14:24 <roconnor> bos: I had list, and a non-determinism + state monad
11:14:27 <bos> roconnor: yeah. i'm writing a chapter on monads at the moment myself.
11:14:57 <bos> taking pretty much the same tack, as it happens.
11:15:04 <dcoutts_> Saizan_: it's record punning, it's so that for large records, instead of saying: Foo { foo = foo, bar = bar, baz = baz } you can just say Foo { ... }
11:15:06 <roconnor> but before that I talked about the maybe monad
11:15:15 <roconnor> I showed the code with chained case statements
11:15:28 <roconnor> and said that we could wrap up that chaining in a new ; operation
11:15:30 <dons> Igloo: fwiw, i still get failures building hpc due to -I and -L/usr/local/lib flags not propagating to hsc2hs
11:15:39 <dcoutts_> Saizan_: it's a bit dangerous since what is in scope changes the meaning
11:15:47 <dons> i have to manually set gcc = gcc -I... -L... to get 6.8.2 to build on systems where gmp is in /usr/local/*
11:16:24 <Saizan_> dcoutts_: it sets the fields to values in scope with the same name?
11:16:33 <dcoutts_> Saizan_: yes
11:18:17 <Igloo> dons: Have you filed a bug about it? (with relevant logs etc)
11:19:48 <roconnor> bos: what are you writing?
11:20:15 <bos> roconnor: a book called "real world haskell", with dons and CosmicRay
11:20:29 <Igloo> dons: Also, are you building with Cabal? If so, it sounds more like a Cabal bug to me
11:36:29 <tetha> heh. is it bad to think in haskell while coding java?
11:36:44 <faxathisia> I think so..
11:36:55 <faxathisia> there are a lot of good ideas you can use in java taken from haskell but not everything..
11:36:57 <Nafai> tetha: Only because of the pain it causes you to be coding in Java
11:37:05 <bos> tetha: that's when you switch to scala
11:37:48 * dcoutts_ was just in the pub with the creator of scala
11:37:55 <tetha> faxathisia: well, I can think on a higher level in haskell, thats fairly helpful with this... subsystem that generates sudoku as a side effect
11:38:56 <dcoutts_> Igloo: my guess from dons description is that the ghc build system is not passing on info to Cabal
11:39:26 <dcoutts_> dons: where do you specify -Iblah -L/usr/local/lib etc
11:39:56 <dcoutts_> ie where is the information starting from, so we can trace where it is not being passed on
11:40:27 <Igloo> dcoutts_: I think more things would break if they couldn't find gmp. If it's being built in a GHC tree then it could be the "Setup makefile" to blame
11:40:41 <Igloo> But yeah, without more info it's hard to say what's going on
11:41:37 <tetha> bos: heh, I still have some scala introduction lying around, but atm, I just dont have time to learn new things
11:46:00 <faxathisia> hmf
11:46:01 <faxathisia> data List a = Nil | a : List a
11:46:03 <faxathisia> not legal
11:46:09 * faxathisia uses :::
11:48:39 <ac> I'm writing a very simple Scheme interpreter as an exercise. I have a type for the value of Scheme variables like so...
11:48:42 <ac> Primitive (Env -> [Value] -> (Env, Value)) | Cons Value Value | Expression Expr | Void
11:49:06 <ac> (prepend "data Value = ..." to that
11:49:28 <mrd> why are you distinguishing values from expressions
11:50:06 <ac> in order for primitive functions to be compared, as in "(= + +)", I have to add some sort of ID to the Primitive constructor, right?
11:50:07 <faxathisia> use Cons Value Value | Number Int | Symbol String or something
11:50:09 <ac> mrd: I don't know
11:50:18 <mrd> comparing functions? sounds bad
11:50:41 <faxathisia> oh you'd want Quote Value too I suppose
11:50:43 <faxathisia> then write an eval and apply for every type
11:50:43 <ac> I actually have "data Value = Primitive String (Env -> [Value] -> (Env, Value)) ..."
11:50:58 <faxathisia> the thing like Primitive is very strange...
11:51:05 <ac> faxathisia: Quote Value is in Expr
11:51:20 <faxathisia> you have Expr and Value? o_o
11:51:27 <faxathisia> what's the difference?
11:51:50 <faxathisia> ac: Have you read tis http://mitpress.mit.edu/sicp/full-text/book/book.html ?
11:51:50 <lambdabot> Title: Structure and Interpretation of Computer Programs
11:51:50 <mrd> i would write: data Expr = Abs Expr | App Expr Expr | ... | Var Int -- and use DeBruijn indices
11:52:03 <ac> faxathisia: that's exactly what I'm reading. I'm no chapter 4
11:52:07 <ac> hence the project
11:52:27 <faxathisia> ac: There should be no difference between Values and Expressions
11:52:44 <ac> faxathisia: the difference in my mind was that Expressions are evaluated, and Values are what's stored in frames of the environment
11:52:46 <mrd> and I'd write a function isValue (Abs _) = True; ...; isValue _ = False
11:52:57 <zeeeee> i'm trying to build my app that uses Data.Time, and i listed time >= 1.0 on my cabal dependencies, but i get "HsTime.h: No such file or directory" (using ghc-6.6)
11:52:57 <ac> I was wondering if I should combine those two types
11:53:03 <faxathisia> ac: nah, because scheme is homoiconic they're the same thing
11:53:06 <zeeeee> any ideas?
11:53:20 <ac> faxathisia: right. One of the types of Value is Expression Expr, and that's weird
11:54:28 <ac> what do you call the things between | | in a data type?
11:54:34 <mrd> constructors
11:54:52 <ac> s/types of Value/constructors of Value/
11:55:01 <ddarius> There is a difference between expressions and values.
11:55:15 <ac> ddarius: are you disagreeing with faxathisia?
11:55:17 <mrd> yes, values cannot take an evaluation step
11:55:27 <ac> that is what I was thinking
11:55:29 <ddarius> ac: Yes and with mrd.
11:55:42 <mrd> but for datatype purposes they are Expressions
11:55:51 <SamB_XP> zeeeee: somehow the include file isn't getting installed & you are building with -fvia-C?
11:56:01 <ac> ddarius: do you think Value should be a separate type like I have?
11:56:01 <faxathisia> ddarius: Not in scheme though
11:56:08 <ddarius> mrd: They are special cases of expressions but not the same.
11:56:15 <ddarius> faxathisia: Even more in Scheme than in Haskell.
11:56:26 <faxathisia> That is the opposite of what I think
11:56:30 <faxathisia> Why do you say this?
11:56:40 <ddarius> ac: It's up to you.  It gives you more static guarantees but it can sometimes be more tedious.
11:56:55 <mrd> in your typical untyped lambda calculus you define terms ::= \ x.t | t t | x, and values ::= \x.t
11:57:00 <ac> ddarius: I'm all about making this in a few as lines as possible for understandability
11:57:09 <ddarius> faxathisia: Because it is very common for call-by-value languages to need to distinguish between values and expressions.
11:57:20 <faxathisia> ddarius: not homoiconic ones
11:57:34 <mrd> this is how Pierce does it too
11:57:43 <ddarius> faxathisia: It's not a syntax thing.
11:57:50 <faxathisia> untyped lambda calculus is not the same as scheme though
11:58:06 <ac> yeah, Scheme is a weird list processing beast
11:58:15 <ddarius> "homoiconic" is completely irrelevant (and a pointless term)
11:58:36 <ac> ddarius: it sounds fancy
11:58:46 <ac> ddarius: it makes lispers feel good
11:58:49 <faxathisia> it's relevant..
11:58:52 <faxathisia> It's not about feeling good
11:58:55 <faxathisia> and it's not a lisp thing
11:59:10 <mrd> values are a subset of expressions
11:59:13 <ac> faxathisia: isn't lisp the quintessential homoiconic language?
11:59:17 <ddarius> mrd: I agree with that.
11:59:20 <faxathisia> I'd like to understand though, why you think that values and expressions are separate things in scheme
11:59:44 <ddarius> faxathisia: Because you can't (soundly) beta substitute an expression, you can a value.
11:59:56 <faxathisia> ohh
12:00:06 <faxathisia> well you can write two predicates isExpr isValue which define the relation
12:00:08 <mrd> hmm?
12:00:09 <faxathisia> on a single datatype
12:00:19 <faxathisia> but it makes little sense to define them as disjoint types
12:00:30 <mrd> ddarius: better clarify that
12:00:43 <ddarius> faxathisia: It's the typical trade-off between static guarantees and not.
12:01:34 <ddarius> faxathisia: If you have a betaReduce function it's type is something like Var -> Expr -> Value -> Expr
12:01:36 <mrd> ddarius: what do you mean you can't beta-substitute an expression?
12:01:48 <mrd> t1 [t2 / x]
12:02:04 <ddarius> mrd: (\x.x+x) (2+2) -> (2+2)+(2+2) is not legal in call-by-value languages in general.
12:02:09 <mrd> where the FV(t2) are not captured
12:02:24 <mrd> oh of course, that's why you put an isValue check in
12:02:45 <mrd> even in Twelf that's how you do it.  prove that t2 is a value before applying beta-reduction.
12:02:57 <mrd> you do not separate values into a separate type family from expressions, though
12:03:04 <ac> ddarius: why is that not legal?
12:03:08 <ddarius> mrd: You can, and it's quite common.
12:03:11 <mrd> ac: it wouldn't be cbv
12:03:14 <ddarius> ac: Because that isn't call-by-value.
12:03:28 * ac scratches head
12:03:40 <ddarius> A more pointed case would be (\x.2) (fix id)
12:04:20 <mrd> i still don't see why he should write a separate Value datatype
12:05:00 <ddarius> mrd: It's a trade-off between static guarantees  and a bit of convenience
12:05:03 <faxathisia> he really shouldn't..
12:05:14 <faxathisia> It's not convenience but this is how scheme implementations work
12:05:30 <mrd> there's no type system, so what static guarantees?
12:05:32 <faxathisia> you can do lots of static analysis in various was but interpreting would be done this way
12:05:40 <ddarius> For the implementation.
12:05:44 <ddarius> It has no external impact.
12:05:52 <mrd> and if there was, canonical forms would guarantee that the expression was a lambda
12:06:02 <ddarius> There is nothing wrong with doing this way and nothing wrong with the other.
12:06:35 <faxathisia> I don't see any sense in having Expr and Value types disjoint
12:06:40 <ddarius> Using separate data types makes it possible to avoid certain errors by construction.
12:06:56 <faxathisia> I can understand a distinction between them as a predicate for use in compilation or other analysis though
12:07:13 <ddarius> E.g. if betaReduce :: Var -> Expr -> Value -> Expr then you can't accidentally substitute and expression where you shouldn't.
12:07:20 <mrd> you also have to wrap (Value ...) around every lambda, number, or whatever
12:07:29 <ddarius> mrd: That's the inconvenience.
12:07:38 <ddarius> As I have said repeatedly, it's a trade-off.
12:08:04 <faxathisia> but homoiconic is a useful term..
12:08:11 <faxathisia> How else could you describes lisps and prolog
12:08:22 <faxathisia> I mean is there another term
12:08:30 <ddarius> faxathisia: It has meaning, but what it means is not nearly as significant as people who use it like to believe.
12:09:46 <ac> homoiconicity is only relevant when you use "eval"
12:09:52 <ac> or macros I guess
12:10:03 <ac> both of those can be quite useful though
12:10:16 <mrd> just write a Simply typed lambda calculus interpreter =)
12:10:24 <ac> mrd: me?
12:10:35 <mrd> I think I have about a dozen of those lying around
12:10:37 <ddarius> ac: At best it's a convenience, otherwise it's not very significant.
12:10:58 <faxathisia> ac: Also relevant to the implementation
12:11:00 <zeeeee> SamB_XP, how do i make sure HsTime.h is installed? where would i find it? i thought it would be part of the ghc libs
12:11:01 <ddarius> I have a Prolog interpreter that has a simply typed lambda calculus intepreter as a test program.
12:11:19 <faxathisia> ddarius: Is it online anywhere?
12:11:23 <faxathisia> Would be cool to see
12:12:07 <ac> mrd: would a simply typed \-calculus interpreter be simpler than a Scheme interpreter?
12:12:20 <ddarius> I don't have it online anywhere.  I was considering having it be an example program for a packaged up version of Claessen's(?) Typed Logical Variables.
12:12:25 <faxathisia> ac: Tonnes simpler...
12:12:38 <mrd> ac: definitely
12:12:44 <ddarius> ac: For a very cut-down Scheme interpreter they'd be about comparable.
12:12:51 <mrd> yea Scheme has lots of extra stuff
12:13:00 <mrd> were you planning on implementing call/cc? =)
12:13:08 <ac> yeah, that's what I'm realizing writing this (heck no)
12:13:17 <ddarius> mrd: That's quite easy to add.
12:13:19 <mrd> actually it's not too hard, just write your evaluator in CPS
12:13:36 <mrd> but most people don't bother
12:13:45 <faxathisia> call-with-current-continuation is only easy to implement once you understand it!
12:13:50 <ac> maybe I'll do that as a future exercise
12:13:54 <faxathisia> And I dunno about you but It took a while to get to grips with that
12:13:56 <faxathisia> for me
12:13:58 <ddarius> call/cc is one of the most interesting things about Scheme, otherwise it's pretty mundane.
12:14:10 <faxathisia> hygenic macros are cool too
12:14:12 <mrd> yah, pretty annoying to use i think
12:14:24 <mrd> other than call/cc
12:14:31 <jmacclure> does anyone know why I would be getting undefined references to __DISCARD__ when compiling? google isn't helping...
12:14:33 <faxathisia> if scheme is annoying to use you're programming the wrong program :p
12:14:35 <ac> mrd: macros or Scheme?
12:14:41 <mrd> Scheme
12:14:52 <ac> my big annoyance with Scheme is its lack of types
12:15:12 <mrd> writing complex higher-order functions without types is quite bothersome
12:15:19 <ac> but overall it's a heck of a lot less annoying than most other languages I've had to program in
12:15:31 <ddarius> ac: It's a decent language.
12:16:03 <ac> I wonder how different SICP would be if all the code was Haskell
12:16:29 <Cin> hi. can someone point me to a link or explain why FiniteMap is deprecated?
12:16:30 <faxathisia> ac; It has types
12:16:34 <mrd> Cin: Data.Map
12:17:18 <Cin> mrd: does Data.Map serve as an equivalent replacement?
12:17:22 <mrd> yes
12:17:28 <Cin> okay
12:18:38 <ac> anyway, my original question was if sticking a String in the Primitive constructor made sense
12:19:04 <qweqwe> input a = do xs <- getline
12:19:05 <qweqwe>              if(xs)
12:19:09 <faxathisia> ac: Is Primitive supposed to be all primitve types?
12:19:16 <Cin> ah, it has O(n) map time as opposed to O(n log n) map time of FiniteMap
12:19:23 <qweqwe> if i want to check if xs == [] how i can do it ?
12:19:26 <ac> faxathisia: Primitive is for primitive functions and special forms like define, set!, car, cdr, etc
12:19:35 <byorgey> qweqwe: use null
12:19:38 <byorgey> > null []
12:19:38 <lambdabot>  True
12:19:43 <byorgey> > null [1,2]
12:19:43 <lambdabot>  False
12:20:01 <mrd> > null [1..]
12:20:03 <lambdabot>  False
12:20:12 <faxathisia> ac: Just have evaling a cons do a lookup for all definitions
12:20:15 <byorgey> > length [1..] == 0  -- bad
12:20:17 <lambdabot> Terminated
12:20:22 <faxathisia> ac: Then applying its args
12:20:54 <faxathisia> ac: (evaling a cons doesn't do the lookup directly, but it would cause the CAR to)
12:20:54 <ac> faxathisia: the idea is so that when you write "+", you would see "#<primitive:+>" instead of just "#<primitive>"
12:21:04 <ac> faxathisia: I don't see how that's related
12:22:04 <mdurr> :t toForeignPtr
12:22:05 <lambdabot> Not in scope: `toForeignPtr'
12:22:47 <faxathisia> ac: I was suggesting to remove Primitive, and an alternative
12:23:04 <faxathisia> ac: maybe it's better if you try stuff and see what works though
12:23:06 <ac> faxathisia: oh I see
12:24:09 <ac> faxathisia: I mean I see you're suggesting a change, but I don't quite understand it :-P
12:25:10 <ac> faxathisia: you're saying the values in a frame that are representing primitives would be symbols?
12:25:22 <ac> faxathisia: and then there'd be no Primitive type in Expr
12:25:36 <faxathisia> ac: ah.. sorry you might want Primitives but for a different purpose
12:25:41 <ac> and eval would have a built in map between symbols and primitive functions?
12:25:49 <faxathisia> ac: things like car and cdr are easily implemented, but stuff like IO etc would be implemented in haskell
12:26:19 <faxathisia> ac: in any case when you come across (a b c d) just you'd generally evaluate a,b,c,d in any order.. then apply a to (b c d), since it's a cons
12:26:34 <ac> faxathisia: all the primitives would be implemented in haskell... that's what primitive means to me
12:26:37 <faxathisia> ac: Like you have a Cons type in Expr, and define eval and apply for everything in Expr
12:26:53 <faxathisia> ac: yeah your examples of primitives confused me since i'd implement them in the language :p
12:27:37 <faxathisia> (you could have a CompiledFunction type too, if you compiled defined functions)
12:28:00 <ac> faxathisia: how can you implement things like "define", "apply", "lambda", "set!', etc? Those are what you implement things with
12:28:41 <faxathisia> (define cons (lambda (x y) (lambda (f) (f x y))) (lambda car (cons) (cons (lambda (x y) x)))
12:29:30 <ac> yeah, cons, car, and cdr were bad examples
12:29:40 <faxathisia> anyway, I see what you meant now, sorry for the confusion
12:30:44 <ac> actually, were cons, car, and cdr bad examples? Because the evaluation of Scheme is tied to lists, I think you need to build those in
12:31:14 <ddarius> ac: Scheme evaluation is not tied to lists.
12:31:41 <ac> ddarius: an expression is a list
12:31:54 <faxathisia> (or a number, or a symbol ...)
12:31:54 <ddarius> ac: No it isn't.  It merely has a similar syntax.
12:32:14 <ac> ddarius: ah. yeah, they're not the same in the code I have already
12:32:20 <ddarius> You -can- use lists for it, but there's nothing saying you have to and most implementations do not after parsing.
12:32:48 <ac> right
12:33:39 <ac> it's all becoming rather confusing because I'm using Haskell lists to implement Scheme expressions, which are used to implement Scheme lists
12:34:30 <faxathisia> ac: It's reasonable to represent (a b c) as Cons (Symbol "a") (Cons (Symbol "b") (Cons (Symbol "c") Nil))
12:35:07 <ddarius> Indeed, if you are going for utmost simplicity in the core of the evaluator then Scheme doesn't have lists, it merely has conses.
12:35:23 <faxathisia> List doesn't make sense as a type
12:35:30 <faxathisia> That's just some optimization
12:36:17 <zeeeee> i'm trying to build my app that uses Data.Time, and i listed time >= 1.0 on my cabal dependencies, but i get "HsTime.h: No such file or directory" (using ghc-6.6)
12:36:19 <zeeeee> any ideas?
12:37:22 <mdurr> mmm binary-0.4.1 is reporting syntax error in cabal file
12:39:58 <ac> faxathisia: when you said "it's reasonable to represent (a b c) ..." did you mean for lists in Scheme code, or for exrpessions in the evaluator code?
12:40:11 <faxathisia> both
12:40:21 <faxathisia> since they are the same thing, just that one is quoted
12:40:42 <ac> Ok. Well currently one of my constructors for Expr is "SExpr [Expr]"
12:40:50 <faxathisia> would just get rid of that
12:40:56 <faxathisia> you could add it again and implement it as an optimization later
12:41:02 <ac> interesting
12:41:13 <faxathisia> (if it actually does makes things faster..?)
12:41:33 <ac> faxathisia: it just makes it easier to write Scheme expressions before I get the parser code working
12:42:06 <faxathisia> write a scheme -> haskell IL translator.. it's about 5 lines of scheme code
12:42:27 <faxathisia> or a function to turn [] -> Cons
12:42:34 <ac> faxathisia: oh ok
12:45:29 <mdurr> nevermind I need a newer version of cabal I think
12:57:20 <ac> what are the differences between _|_, (), and Nothing?
12:57:56 <Zao> ac: () is the only value of the type (), Nothing is value of Maybe a.
12:58:08 <Zao> _|_ has something to do with undefined.
12:59:02 <ac> I think I understand () and Nothing just fine, but not undefined
12:59:13 <Zao> () maps to "unit" in some other FP languages.
12:59:25 <zeeeee> the problem was due to a bug in ghc 6.6
13:00:31 <faxathisia> > 1 + undefined
13:00:35 <shachaf> ac: undefined is a value that doesn't return.
13:00:35 <lambdabot>  Undefined
13:00:40 <faxathisia> I think that explains it..
13:00:42 <shachaf> ac: _|_, rather.
13:00:50 <faxathisia> :t undefined
13:00:51 <lambdabot> forall a. a
13:01:07 <faxathisia> ou can implement, my_undefined = my_undefined
13:01:11 <shachaf> ac: undefined, fix id, last [1..], let x = x in x are all _|_.
13:03:00 <ac> shachaf: ok. I believe that's not what "undefined" means in other languages
13:03:08 <ac> JavaScript for example
13:03:20 <ac> There it means basically "no value"
13:03:36 <shachaf> ac: That would probably correspond to Nothing (though that's more explicit).
13:03:55 <shachaf> ac: You can't really do anything with _|_.
13:03:58 <ac> shachaf: yeah, undef in JavaScript should be called Nothing
13:04:31 <shachaf> ac: Non-strictness lets you handle date where you sometimes have _|_, though:
13:04:44 <shachaf> > take 3 (1 : 2 : 3 : undefined)
13:04:45 <lambdabot>  [1,2,3]
13:04:51 <shachaf> > take 4 (1 : 2 : 3 : undefined)
13:04:52 <lambdabot>  Undefined
13:05:03 <faxathisia> > take 3 . map (+1) [1,2,3,undefined]
13:05:03 <lambdabot>  Couldn't match expected type `a -> [a1]'
13:05:07 <faxathisia> > take 3 . map (+1) $ [1,2,3,undefined]
13:05:07 <lambdabot>  [2,3,4]
13:05:57 <pjd> (JavaScript actually makes a distinction between "undefined" and "null", FWIW)
13:06:32 <lament> most languages don't have an undefined, they just crash
13:06:49 <ac> pjd: I guess you're right. JavaScript's null corresponds to Nothing. But then what is undefined for? It's just another value
13:06:52 <shachaf> Zao: By the way, _|_ is also of type (). :-)
13:07:23 <faxathisia> It's a little strange () is also a name for a type
13:07:45 <shachaf> faxathisia: Why? It's just like (a,b).
13:07:52 <faxathisia> > ({--}) :: ({--})
13:07:52 <lambdabot>  ()
13:08:14 <pjd> ac: in JS, unassigned variable declarations start out as "undefined", whereas "null" is something you have to assign yourself
13:08:25 <kpreid> > ({-}.{-})
13:08:25 <lambdabot>  Unterminated nested comment at "({-}...." (column 1)
13:08:34 <shachaf> pjd: Can you reassign undefined?
13:08:58 <faxathisia> that is a weird tokenizer...
13:09:43 <ac> faxathisia: that's a weird token
13:09:52 <pjd> shachaf: i think so
13:10:15 <shachaf> pjd: So it is just another value. :-)
13:10:27 <shachaf> pjd: Which happens to be the default.
13:10:31 <pjd> shachaf: actually, you can reassign the global "undefined" property
13:10:37 <faxathisia> @src undefined
13:10:37 <lambdabot> undefined =  error "Prelude.undefined"
13:10:41 <faxathisia> odd..
13:10:45 <pjd> the undefined primitive value is still distinct
13:11:02 <faxathisia> > let __ = __ in 1 + __
13:11:03 <lambdabot>  Exception: <<loop>>
13:11:03 <pjd> confusingly, "null" is an object, instead of a primitive
13:11:14 <pjd> but you *can't* reassign it, because it's also a keyword, instead of a property
13:11:18 <pjd> go figure
13:11:46 <shachaf> pjd: No, I meant, can you say "x = undefined"?
13:11:50 <ac> pjd: yeah the fact that typeof(null) == Object really irritates me
13:11:52 <shachaf> pjd: (And it looks like you can.)
13:12:15 <qweqwe> y
13:12:19 <ac> I end up saying "typeof(foo) == Object && foo != null"
13:12:24 <pjd> shachaf: well, "var x" and "var x = undefined" both result in x being undefined, but by different routes
13:12:46 <pjd> JS is really wacky
13:13:20 <pjd> (e.g. if you say "undefined = 5" first, then the second x will be 5 instead)
13:13:42 <ac> funny thing about JS is it's very rigoursly defined wackiness. The ECMA spec spells out all of this weirdness to the letter
13:14:17 <pjd> Ministry of Silly Languages
13:15:00 <shachaf> pjd: You can reassign *to* undefined? That's silly.
13:15:14 <pjd> shachaf: that's what i originally meant, yeah
13:15:47 <pjd> in that respect, JS's undefined is actually just like Haskell, in the sense of just being a default binding
13:16:22 <ugu> can't variables start with a capital letter?
13:16:25 <hpaste>  (anonymous) annotated "make me work :)" with "something like" at http://hpaste.org/4436#a1
13:16:27 <pjd> (but not the "undefined" primitive type, though
13:16:29 <pjd> )
13:16:33 <ddarius> ugu: No
13:16:42 <ac> ugu: that's reserved for types, type classes, and type constructors
13:16:48 <pjd> ugu: capitals define data constructors
13:16:58 <pjd> and those things too
13:17:03 <ugu> thanks..
13:20:56 <ugu> one more: if I want a number of variables (e.g. aa_1 = 1, aa_2 = 2, aa_3 = 3) be of type KeySym, how do I define them?
13:21:12 <pjd> shachaf: one more difference between JS and Haskell, though, is that JS lets you do x === undefined :)
13:21:23 <pjd> (and have it return true)
13:21:31 <shachaf> pjd: Yes, undefined in JS has nothing to do with _|_.
13:21:54 <shachaf> pjd: It's also different from { function f() { f(); } f(); }.
13:22:16 <pjd> shachaf: undefined the value, but not undefined the binding :)
13:22:17 <DRMacIver> Conversation over in #scala reminded me of something. I've been thinking recently that tuples of arity > 2 should probably be type synonyms. e.g. (a, b, c) could be a synonym for (a, (b, c)). Is there an obvious reason why this is a bad idea?
13:22:43 <DRMacIver> (My reasoning is that the situation with generic tuple operations seems to be rather sad)
13:22:49 <faxathisia> DRMacIver: Prolog does this
13:23:10 <faxathisia> e.g. (x,y,z) = (X,Y) succeeds with X = x, Y = (y,z)
13:23:25 <ac> ugu: if they're top level variables I think you just have to write out the type for each one (I could easily be wrong though)
13:23:46 <faxathisia> You might prefer to unbox once instead of O(n) though, to access an arbitrary element
13:23:47 <ddarius> DRMacIver: Yes, because they have different meanings in Haskell.
13:24:21 <DRMacIver> ddarius: Well, yes, but that's a non-argument. I'm asking if they shouldn't have different meanings. :)
13:24:23 <ugu> ac: yes, I can write out the type for eachof them, but can I specify them like in c: int a = 0, b = 1;
13:24:30 <faxathisia> DRMacIver: So you'd usually use [a,b,c] instead
13:24:31 <ddarius> DRMacIver: I'm saying they aren't isomorphic.
13:24:32 <shachaf> DRMacIver: I've thought of that before. That'd behave differently with _|_, I suppose.
13:25:00 <hpaste>  jmacclure pasted "build errors" at http://hpaste.org/4472
13:25:20 <pjd> ugu: one way is to use them somewhere that requires type KeySym, and let type inference do the rest
13:25:24 <ddarius> There is no three tuple that corresponds to (x,undefined)
13:25:36 <DRMacIver> ddarius: Sure. But why is that a problem?
13:26:04 <ddarius> DRMacIver: Because that is different semantically.  I can tell the difference between them.
13:26:04 <pjd> ugu: are you sure you don't want a list, though?
13:26:27 <pjd> (or a map)
13:27:15 <ugu> pjd: I'm really not sure what I want - only curious how to do things in haskell
13:27:46 <pjd> ugu: okay;  did what i say about type inference make sense?
13:28:01 <DRMacIver> ddarius: ok. But is it an interesting semantic difference? Suppose I waved a magic wand and rather than having their own datatype constructors all tuples of arity > 2 were suddenly just type aliases and syntactic sugar. Why would this be bad?
13:28:19 <ddarius> DRMacIver: It would break programs.
13:28:34 <ddarius> That's what "different semantics" means.
13:28:41 <DRMacIver> Ok
13:28:50 <DRMacIver> Now let's suppose that my magic wand is equipped with the power of time travel
13:29:06 <shachaf> ddarius: DRMacIver is asking why things didn't work this way in the first place.
13:29:11 <DRMacIver> And upon waving it the new semantics had been enshrined in the Haskell standard since the dawn of time when it was writ in stone by the creator of the universe.
13:29:13 <ugu> pjd: partly, because I don't know how to put them where KeySym is required, since KeySym is needed in M.Map (KeyMask, KeySym)
13:29:17 <DRMacIver> WHy would this be bad?
13:29:19 <ddarius> shachaf: That is perhaps what he is trying to ask.
13:29:23 <DRMacIver> Other than a causality violation. :-)
13:29:36 <mdurr> btw Data.Binary worked wonders
13:29:40 <mdurr> thanks
13:29:50 <faxathisia> DRMacIver: Did you not understand what I said....
13:29:57 <ddarius> DRMacIver: The pragmatic reason is then the one faxathisia said.  There would be O(n) access the the last element.
13:30:00 <pjd> ugu: you can _probably_ just leave out the types
13:30:13 <pjd> can you paste an example?
13:30:16 <pjd> @hpaste
13:30:16 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:30:24 <SamB_XP> DRMacIver: well, bad plot
13:31:47 <ugu> pjd: I thought I can, but it didn't work: I got the not in scope message previously, but only because I referencing to them later, where type could be inferred. thank you.
13:31:48 <ac> ugu: Haskell's type inference is usually smart enough that it can figure out what type an "empty" map is based on later inserts
13:31:55 <DRMacIver> faxathisia: I understood. I just mentally dismissed it with "Oh, that's just a compiler optimisation. ;)"
13:32:19 <ddarius> It would also make products non-commutative.
13:32:24 <faxathisia> DRMacIver: No it's not compiler optimization at all
13:32:45 <faxathisia> (Do you see why not, now?)
13:32:50 <pjd> ddarius: can you elaborate a bit on that?
13:33:06 * ddarius is never going to get through this song.
13:33:25 <pjd> sorry :)
13:33:40 <DRMacIver> Both of these objections can be dismissed with by enlarging the number of tuple types by two anyway. :-)
13:33:40 <ugu> oh, the mistakes.. again: pjd: I thought I can, but it didn't work: I got the not in scope message previously, but only because I didn't reference to them later, where type could be inferred. thank you.
13:33:42 <SamB_XP> the difference between (a, b, c) and (a, (b, c)) has to do with _|_
13:33:46 <ddarius> pjd: His pair type would then be, data Pair a b = Pair a !b (at least if he wanted to be consistent)
13:33:50 <DRMacIver> If you combine them with a tuple that's strict in their right argument the issue goes way
13:34:25 <faxathisia> DRMacIver: "Both of these objections can be dismissed" -- What?
13:34:37 <pjd> ddarius: ah, so non-commutative in the sense that (a,b) is not isomorphic to (b,a) ?
13:34:49 <ddarius> pjd: Exactly.
13:34:53 <faxathisia> A List like [a,b,c,d] or (a,(b,(c,(d,())))) has O(n) access
13:34:53 <pjd> okay, thanks
13:35:06 <faxathisia> An array or tuple like (a,b,c,d) as O(1) access to any element
13:35:17 <faxathisia> It's not a compiler optimization but it's a actual property of the data strcture
13:35:19 <DRMacIver> faxathisia: By adding either an additional type or an additional constructor which is strict in its second argument then a) This becomes isomorphic to the existing tuple and b) The right hand argument can be unboxed into the constructor.
13:35:32 <faxathisia> if you replaced N-tuples with nested 2-tuples you would have one less data type in the language
13:35:48 <pjd> (cue cdr-coding)
13:36:02 <faxathisia> That's obviously not a desirable thing..
13:36:06 <SamB_XP> faxathisia: I though they went at least up to 7-tuples
13:36:22 <DRMacIver> faxathisia: Given how badly higher arity tuples are handled at the moment, I don't think that's obvious at all
13:36:42 <faxathisia> you would have one less data type in the language -- is not desirable
13:37:17 <DRMacIver> Infinity - 1 = Infinity
13:37:28 <faxathisia> No..
13:37:29 <DRMacIver> So you would have the same number of data types in the language, so it's not a problem.
13:37:36 <DRMacIver> (Hey look. I can make stupid arguments too...)
13:37:56 <faxathisia> DRMacIver: You are saying that what I've said is stupid?
13:38:00 <DRMacIver> Yes
13:38:05 <faxathisia> ok I wont talk to you anymore
13:38:10 <DRMacIver> At least the "one less datatype" part is
13:38:15 <DRMacIver> The rest wasn't.
13:38:24 <faxathisia> I don't care, You're rude
13:38:34 <SamB_XP> faxathisia: and you aren't?
13:38:50 <DRMacIver> Fine by me
13:38:53 <pjd> hey, this is #haskell, be nice
13:39:14 * SamB_XP wonders who pjd is addressing
13:39:16 <ac> this has got to be the most intense thing I've ever seen on this channel
13:41:50 <hpaste>  mmorrow pasted "Epic building hpaste, anyone familiar with these errors?" at http://hpaste.org/4473
13:46:16 <zou> Canal question, i installed a package, and it works fine with ghci
13:46:57 <zou> but when i tried to compile it, the compile complained about not being able to link with missing symbols, etc
13:47:11 <zou> so what options should i pass it to ghc ?
13:47:18 <shachaf> zou: --make?
13:47:19 <ddarius> --make
13:47:20 <hpaste>  (anonymous) annotated "Epic building hpaste, anyone familiar with these errors?" with "(no title)" at http://hpaste.org/4473#a1
13:47:35 <shachaf> zou: Or alternatively -package.
13:47:48 <hpaste>  stick_figure pasted "What is the proper usage of modifyIORef and liftM?" at http://hpaste.org/4475
13:48:11 <hpaste>  mmorrow annotated "Epic building hpaste, anyone familiar with these errors?" with "(no title)" at http://hpaste.org/4473#a2
13:50:57 <stick_figure> Can anyone help me with that code on hpaste?  I'm getting a simple type error that makes sense to me, but I'm not sure what the elegant way is to fix it.
13:50:58 <glguy> "epic" is a good adjective in this case
13:51:52 <bos> stick_figure: why are you using IORefs at all?
13:52:06 <stick_figure> Before anyone suggests ripping out all of the IORefs, I'm writing it that way intentionally because I want to do Dijkstra's algorithm.
13:52:34 <stick_figure> It is bass ackward, being imperative in a functional language, but I wanted to see if it was doable.
13:52:47 * glguy doesn't remember using IORefs to do Djikstra's algorithm
13:52:51 <bos> well, your code is clearly ill-typed.
13:52:56 <stick_figure> right
13:52:59 <qweqwe> Index = Just sumNum how i can use the int that i have there ?
13:53:02 <glguy> STArray, maybe :)
13:53:18 <glguy> _i_ndex =
13:53:24 <glguy> case index of
13:53:28 <zou> thanks
13:53:31 <glguy> Just awesome -> f awesome
13:53:34 <glguy> Nothing -> whoops
13:53:47 <qweqwe> thanks
13:53:53 <zou> now another question: i have C::IO ([info])
13:53:53 <stick_figure> glguy, right, I could switch to that array representation of the heap
13:53:58 <zou> and main = C
13:54:07 <stick_figure> glguy, but that wouldn't satisfy my curiosity :)
13:54:07 <zou> it runs fine under ghci
13:54:13 <zou> and shows a list of info
13:54:25 <zou> but with compiled output, nothing is showns
13:54:28 <zou> shown
13:54:42 <bos> stick_figure: you have IORef Heaps jumbled up with Heaps of IORefs
13:54:52 <gwern> so I've been playing with Oleg's zipper fs; to run multiple sessions in the fs, you telnet to it, which I find clumsy and odd. is there any better way to allow simultaneous shell-like access?
13:55:37 * SamB_XP personally is still not at all clear on how the zipper fs works...
13:55:57 <gwern> neither am I, but I want a more convenient interface to it while I explore it
13:56:33 <atp> zou: the type of main is not IO ([a]), it's IO (), so how did you make main = C?
13:56:33 <SamB_XP> what do you mean by more convenient?
13:56:38 <gwern> and the telnet one is awful, no history, no completion, type the wrong button and garbage is printed...
13:56:58 <stick_figure> bos, there's a reason, then I can later gather all of the references and use them to do decrease keys... although actually it occurs to me now that that won't work.
13:57:24 <atp> zou: (not to mention that ([a]) isn't even a type...)
13:57:27 <gwern> SamB_XP: well, I have a little shell written already, and I was thinking that if there were some waay to connect the little shell to it
13:57:27 <stick_figure> bos, I don't have any way to go up the heap.
13:57:35 <gwern> I didn't think going via telnet would work
13:57:52 <atp> gwern: what is this zipper fs you speak of?
13:57:52 * gwern wonders if maybe a pair of FIFOs is the answer?
13:57:55 <bos> stick_figure: well, for example, you can't lift the result of modifyIORef into IO (Heap a) as you're trying to do, because you get a nonsensical type.
13:58:01 <tetha> hm, is there a deeper reason that Ord requires Equality and <= instead of just <?
13:58:16 <zou> atp: i have main = C
13:58:17 <ddarius> atp: THe typo of main (in general) is IO a.
13:58:38 <bos> tetha: it's a total ordering class, not a partial ordering
13:58:40 <atp> ddarius: oh, really?  what is done with the a?  Anything?
13:58:45 <gwern> atp: http://lambda-the-ultimate.org/node/1036
13:58:46 <lambdabot> Title: Zipper-based file server/OS | Lambda the Ultimate
13:58:49 <atp> gwern: thanks
13:58:54 <ddarius> atp: The type tells you what is done with it.
13:59:46 <atp> ddarius: i'm guessing something integral would be the exit code?
13:59:53 <stick_figure> bos, that is the error.  I think I should actually be using bind in some fashion...  liftM doesn't work because modifyIORef is in the IO monad.
14:00:03 <ddarius> atp: Nope.
14:00:17 <atp> ddarius: so, what's the deal?
14:00:27 <SamB_XP> tetha: is there any particular reason that this is inconvenient for you?
14:00:27 <bos> stick_figure: well, i can't tell what your lift is intending to do.
14:00:29 <zou> ddarius: any idea of why this runs under ghci, but nothing is shown with copmiled executable?
14:00:47 <ddarius> atp: Without magic there is only one thing the runtime system can do with an end result of forall a.IO a
14:00:57 <glguy> stick_figure, you don't need IO to create a min-heap
14:01:10 <tetha> SamB_XP: no, Im just wondering about it.
14:01:17 <ddarius> zou: I don't know what "this" is.
14:01:28 <atp> zou: ghci will show the return value of a function, compilation won't do that, off the top of my head
14:01:30 <SamB_XP> tetha: well, I think they picked <= because it might save work
14:01:35 <glguy> so is this just an exercise in using IO or an attempt at implementing the algorithm?
14:01:58 <stick_figure> glguy, both, but I realized there's a flaw in that I can't heap up, I can't do decrease key
14:02:14 <atp> ddarius: well, the curry howard isomorphism would seem to indicate that anything of type forall a. IO a is something akin to IO _|_ ...
14:02:22 <SamB_XP> tetha: if you want to define everything in terms of <, you're free to do so, anyway
14:02:27 <stick_figure> glguy, there's no way to go back up the heap with this representation.  So I may as well start over with an array representation...
14:02:32 <atp> ddarius: but that seems decidedly useless in this particular context ?
14:02:56 <zou> ddarius: i have C: IO ([info]) and main = C
14:03:12 <atp> zou: if you want to print something, you'll need to actually print it
14:03:17 <zou> it works under ghci --shows a list of infos
14:03:35 <zou> but compiled executable didn't show anything
14:03:39 <atp> zou: for example, you could do main = C >>= print
14:03:42 <stick_figure> Thanks for looking at it though.  I'll probably be back later with a different structure. :)
14:03:44 <glguy> stick_figure, you can remove the element altogether and reinsert it in the same asymptotic complexity as a mutable heap-up
14:03:45 <ddarius> atp: I'm not asking how to build such a value, the run-time system is given that value (and potentially for a fixed a), however the "execute function" that is the runtime system must have a type like execute :: IO a -> magic
14:03:52 <tetha> SamB_XP: of course. I just was suspecting some interesting reason behind it. ;)
14:04:23 <atp> ddarius: right, and i thought you were saying that for different a, it behaves differently?  or did i misunderstand?
14:04:32 <SamB_XP> tetha: again, I think it may save some work in comparing product types ...
14:05:21 <stick_figure> glguy, how can I remove it in log n?
14:05:39 <atp> zou: also, in the expression C :: ([a]) the parenthesis are redundant
14:05:47 <ddarius> atp: It doesn't behave differently.  I'm saying that the type already tells you the only possible thing that can be done with the return value, i.e. the only possible way the runtime system can be implemented (in that regard) without magic.
14:05:57 <atp> ddarius: discarded?
14:06:02 <ddarius> atp: Yep.
14:06:08 <glguy> stick_figure, I'd use a finger tree
14:06:29 <stick_figure> glguy, I guess I'll wikipedia that.  Thanks, though, I have to go.
14:06:36 <atp> ddarius: hehe... you have a roundabout question-answering style, but i certainly learn something each time i ask :)
14:06:56 <SamB_XP> tetha: I you may have seen this, but just in case: http://www.haskell.org/onlinereport/basic.html#sect6.3.2
14:06:57 <lambdabot> Title: The Haskell 98 Report: Predefined Types and Classes
14:07:00 <ddarius> atp: Well the upshot of it was, the answer was deducible (assuming no magic)
14:07:20 <ddarius> (Actually, there are two things that could be done, you could seq it and then discard it.)
14:07:25 <tetha> SamB_XP: Ah, I think I understand it. By making EQ a superclass of Ord, I can conclude that every ordered type can be checked for equality. of we didnt do that, we couldnt compare Ords that easy. And once we have ==, >= appears to be easier to use than <. :)
14:07:44 <fadec> Has anyone gotten errors saying a package is hidden while trying to build a package when the package is exposed?
14:08:11 <shachaf> fadec: Which package is this?
14:08:11 <shapr> fadec: If the cabal file does not list that package in the build-depends, it's hidden.
14:08:12 <atp> ddarius: that's true, but since by definition you're at the end of the program's execution, what would seq'ing it buy you?
14:08:28 <atp> ddarius: you'd just be spinning the cpu with no side effects
14:08:29 <ddarius> atp: Of course that's silly, but I'm just saying it is possible.
14:08:36 <atp> ddarius: right
14:08:50 <fadec> package plugins throws an error for Data.Array.Base in package array during build
14:08:57 <atp> zou: did that work?
14:10:59 <ac> aren't values always different from expressions in Scheme? How do you create an expression containing for instance #<void> or #<primitive:+>?
14:11:18 <SamB_XP> ac: consider 1
14:11:18 <atp> SamB_XP: I think also the anticommutativity axiom for posets also assumes that two elements of the set can be compared...
14:11:37 <jre2> :t cycle
14:11:38 <atp> SamB_XP: antisymmetry rather
14:11:39 <lambdabot> forall a. [a] -> [a]
14:12:06 <Syzygy-> atp: For generic posets?
14:12:08 <atp> SamB_XP: no wait, scratch that, it allows us to deduce equality, i had a brain fart :(
14:12:12 <ac> SamB_XP: it's a self evaluating expression. All expressions can be values but not all values expressions
14:12:15 <atp> Syzygy-: ignore me
14:12:27 <atp> Syzygy-: i just said something stupid without thinking about it
14:12:28 <dons> everyone see the job annoucnement today?
14:12:29 <SamB_XP> frankly, I'm not sure there IS a reason...
14:12:33 <qweqwe> http://hpaste.org/4476 what is wrong with it ?
14:12:37 <atp> dons: which?
14:12:39 <dons>   http://article.gmane.org/gmane.comp.lang.haskell.cafe/33377
14:12:40 <lambdabot> Title: Gmane -- Mail To News And Back Again
14:12:49 <SamB_XP> it might just be a case of "had to pick one, it seemed as good as any!"
14:13:21 <shapr> fadec: Can you add array to the build-depends field in the cabal file?
14:13:23 <dons> yay, andrew coppin was here!
14:13:32 <ExSoldier> hey, does anyone know about the turing machine?
14:13:34 <atp> SamB_XP: yeah, it seems frankly silly to make Eq a superclass of Ord the more i think about it
14:13:35 <dons> "I am pleased to report that last night I was on #haskell and I did in
14:13:37 <dons> fact get lots of useful help, from a number of people."
14:13:39 <dons> shapr: ^^ :)
14:13:39 <shapr> dons: That name is familiar, who's he?
14:13:42 <SamB_XP> atp: not really
14:13:49 <ddarius> dons: That's a good thing?  (I'm not saying it's a bad thing, but I don't see anything special about it.)
14:13:59 <SamB_XP> atp: it would be REALLY REALLY annoying if it weren't
14:14:00 <dons> ddarius: well, more of "i told him so." :)
14:14:05 <ExSoldier> hey, does anyone know about the turing machine?
14:14:12 <SamB_XP> more annoying than if Functor weren't a superclass of Monad
14:14:14 <BMeph> fadec: These errors popped up with GHC 6.8.x, because they re-did the base packaging.Just add, e.g. array, to build-depends, and re-compile.
14:14:15 <shapr> ExSoldier: Yeah, I built one in my garage!
14:14:21 <shapr> ExSoldier: But seriously, what's your question?
14:14:29 <qweqwe> http://hpaste.org/4476 what is wrong with it ?
14:14:31 <mauke> unfortunately he seems to send mail from OE. or where are all the J's coming from?
14:14:39 <SamB_XP> shapr: where do you keep the tape?
14:14:42 <dons> shapr: oh, man. it was ac!
14:14:47 <atp> SamB_XP: why's that?
14:14:53 <dons> and *I* was talking to him :)
14:14:55 <ExSoldier> shapr : i gotta introduce something like [001111] and see what i get
14:14:59 <ExSoldier> or something like that
14:15:02 <dons> and even was going to blog about the code.
14:15:05 <dons> since it was so nice.
14:15:12 <shapr> dons: Dude, you're good #haskell advertising!
14:15:30 <shapr> dons: Where's the blog article?
14:15:39 <ac> dons: huh? me?
14:15:48 <shapr> qweqwe: Are you qwe1234 from reddit?
14:16:03 <qweqwe> nop
14:16:07 <dons> ac, was it you I was talking to about loops and java and fusion?
14:16:08 <shapr> That's good to hear.
14:16:12 <dons> or someone else. hmm
14:16:24 <ddarius> dons: Presumably Orphi
14:16:30 <ac> I did talk abotu fusion, but not about java and loops
14:16:45 <qweqwe> shapr: can you help me with the problem
14:16:53 <shapr> qweqwe: Looking at it now...
14:16:58 <dons> ah, orphi.
14:17:01 <SamB_XP> shapr: you had to ask?
14:17:33 <shapr> qweqwe: The first thing to fix is that type names and type constructors in Haskell start with an uppercase letter, and function names start with lowercase letters.
14:17:42 <jre2> @src foldl
14:17:42 <shapr> qweqwe: So you need to change char to Char in the type signature.
14:17:42 <lambdabot> foldl f z xs = lgo z xs
14:17:43 <lambdabot>     where lgo z []     =  z
14:17:43 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
14:18:03 <fadec> shapr: That was the ticket. Thanks.
14:18:12 <shapr> Yay, I answered a question!
14:18:15 <shapr> shapr++
14:18:19 * shapr grins
14:18:35 <SamB_XP> you know that doesn't work, right?
14:18:39 <ExSoldier> could anyone explain me how does the turing machine works?
14:18:41 <SamB_XP> shapr++
14:18:42 <shapr> SamB_XP: Yeah, I know.
14:18:51 <tetha> ah. as someone pointed out, Ord is a total ordering. thus, once I have a relationship <=, this relationship has to fulfill antisymmetry, that is, a<=b and b<=a => a = b; if you use < only, you cant assure this, because those 2 elements could be in an undefined state towards each other. and if ord was no total order, you could now define a sorted collection using it
14:18:52 <SamB_XP> ExSoldier: well, if you can find me a tape for it, yes ;-)
14:18:59 <shapr> ExSoldier: Have you read the wikipedia article? http://en.wikipedia.org/wiki/Turing_machine
14:19:00 <lambdabot> Title: Turing machine - Wikipedia, the free encyclopedia
14:19:01 <tetha> err. not, that is
14:19:23 <ExSoldier> shapr i read it, but i cant still get it
14:19:24 <tetha> because if you want to check a collection for being sorted, you need to compare every element with every other element, and thus, you need a total order
14:19:33 <SamB_XP> tetha: eh?
14:19:36 <qweqwe> shapr: still i have the same error
14:20:09 <shapr> qweqwe: The next thing to fix is to put parentheses around (Just num)
14:20:10 <SamB_XP> @pl (<=) = curry . (not.) . uncurry (>)
14:20:11 <lambdabot> (line 1, column 6):
14:20:11 <lambdabot> unexpected "="
14:20:11 <lambdabot> expecting variable, "(", operator or end of input
14:20:16 <SamB_XP> @pl curry . (not.) . uncurry (>)
14:20:17 <lambdabot> curry . (not .) . uncurry (>)
14:20:26 <SamB_XP> anyway...
14:20:46 <SamB_XP> tetha: I don't see how <= is different from <, really...
14:20:52 <tetha> SamB_XP: keep in mind: during the definition of an order, < describes a relationship, iE a set of tuples
14:21:07 <SamB_XP> tetha: what does that have to do with Haskell
14:21:11 <tetha> and a < b <=> (a, b) \in Set
14:21:24 <shapr> qweqwe: If you have "function (Constructor name) =" that's a shortcut for function arg = unpack <stuff> where unpack (Constructor name) = name
14:21:26 <SamB_XP> perhaps it's just habbitual that (<=) was chosen?
14:21:28 <shapr> qweqwe: Does that make sense?
14:21:43 <tetha> SamB_XP: Ord represents a total Order, those are the axioms of a total order and relationships (and a total order is defined using relationships)
14:21:52 <shapr> qweqwe: Without the parentheses around Just num, split looks like it's getting two arguments, when it's only getting one.
14:22:00 <atp> SamB_XP: that's the thing; if only < were required, then Eq would be needed to fulfill antisymmetry
14:22:49 <qweqwe> ok
14:23:49 <mokus> tetha: additionally, Ord is mapped to machine ordering tests for many types, and providing all the different combinations simplifies the conceptual mapping of functions to their implementations, without having to optimize out definitions like x >= y = (x > y) || (x == y)
14:24:36 <tetha> heh. performance is peeking around the corner :)
14:25:41 <SamB_XP> mokus: well... for that you define ALL the methods
14:25:47 <shapr> qweqwe: Are you learning Haskell for school?
14:25:58 <mokus> right, which Ord allows you to do
14:26:04 <SamB_XP> so it's a moot point what the default methods do then
14:26:21 <mokus> if it was just (==) and (>), that would be logically sufficient, but it wouldn't allow that flexibility
14:26:27 <shapr> ExSoldier: Are taking a computability course or something?
14:26:50 <ExSoldier> shapr : im studying computer engineri
14:26:51 <SamB_XP> mokus: well, those could still be one of the two ways to define an Ord instance...
14:26:52 <shapr> ExSoldier: It might help to learn the lambda calculus, since that's equivalent to a turing machine.
14:27:04 <ddarius> So is python...
14:27:05 <SamB_XP> the other one of course being to define "compare"
14:27:08 <mokus> oh, was this discussion specifically about what's _allowed_ as a default?
14:27:19 <ExSoldier> shapr : i gotta use the turing machine for my exam :(
14:27:29 <ExSoldier> but i think im starting to get it
14:27:32 <shapr> ExSoldier: If you find it easier to see how lambda calculus can compute anything, maybe you could map that understanding onto the turing machine?
14:27:34 <SamB_XP> mokus: tetha was wondering why <= is the default
14:27:35 <tetha> mokus: it origined from me wondering about the selection of ">=", yes
14:27:41 <SamB_XP> er. the one you override
14:27:50 <mokus> ah, I see
14:27:53 <mokus> good question ;-)
14:27:58 <ExSoldier> shapr : ill check it out, thx ^^
14:28:05 <SamB_XP> I guess it's just for hysterical raisons, anyway
14:28:20 <ddarius> Oi, "mapping that understanding" would mean implementing the lambda calculus on a Turing machine (or something that can implement the lambda calculus)
14:28:28 <tetha> hey, I finally understood monads, so I can ask simpler stuff now
14:28:29 <SamB_XP> because I think any other choice would result in identical performance...
14:28:43 <SamB_XP> and whatnot
14:28:49 <ac> ddarius: that would be an interesting exercise, but personally I don't think it would do anything for my understanding
14:29:02 <ddarius> ac: That would be a painful exercise.
14:29:03 <mokus> maybe they did a survey on which ones are most used? :)
14:29:04 <SamB_XP> how about implementing the turing machine in the lambda calculus instead?
14:29:17 <SamB_XP> much much more enjoyable
14:29:25 <ddarius> SamB_XP: That doesn't say anything about the computability of Turing machines.
14:29:48 <tetha> implementing the lambda-calculus on a TM should be pretty easy, using some TM with a tree as its working structure
14:29:49 <SamB_XP> ddarius: we already know that turing machines are turing-complete, though ;-P
14:29:51 <ddarius> s/computability/computational power/
14:30:04 <SamB_XP> tetha: tree?
14:30:16 <SamB_XP> that reminds me of a garbage collection algorithm in TAOCP...
14:30:38 <tetha> SamB_XP: of course, trees. TMs can use pretty much everything as their working structure. you just need to map it to a sequence after that, or find a proof of that
14:31:21 <SamB_XP> tetha: I still haven't figured out where to keep the tape for one, and now you want me to figure out where to put a whole frickin' *tree*?
14:31:56 <tetha> SamB_XP: using the right data structure simplifies things a lot
14:32:00 <SamB_XP> they tell me the universe isn't infinite, too, which makes things especially difficult
14:32:01 <ddarius> SamB_XP: At least trees self-replicate.
14:33:57 <ddarius> @users
14:33:58 <lambdabot> Maximum users seen in #haskell: 440, currently: 422 (95.9%), active: 24 (5.7%)
14:34:34 <atp> not bad, more active than usual
14:42:00 <hpaste>  BMeph annotated "(no title)" with "Did you mean this?" at http://hpaste.org/4476#a1
14:42:40 <qweqwe> http://hpaste.org/4479
14:42:48 <qweqwe> i can"t see the error there
14:43:26 <Lemmih> qweqwe: Haskell is case-sensitive.
14:43:35 <Toxaris> qweqwe: normal functions have to have lower-case names
14:43:49 <Toxaris> qweqwe: try char2num instead
14:45:00 <qweqwe> still i have that error
14:45:42 <monochrom> Is that the full error message?
14:46:07 <Lemmih> qweqwe: Did you save the document?
14:46:38 <qweqwe> http://hpaste.org/4480
14:47:22 <Lemmih> qweqwe: That 'C' looks awfully like an uppercase letter.
14:47:25 <monochrom> I don't know what to say. You haven't followed any advice.
14:47:27 <largos> lispy: you around?
14:48:15 <qweqwe> monochrom:all there now lower cases names
14:48:34 <monochrom> C in Char2num is lower case?
14:49:06 <monochrom> Please just tell me you haven't slept for the whole week.
14:49:25 <qweqwe> i already half asleep it"s here 1:00
14:49:31 <qweqwe> sorry for that
14:49:43 <SamB_XP> qweqwe: perhaps you had better finish the job
14:50:04 <qweqwe> yes it"s my last function before sleep
14:50:24 <SamB_XP> I meant the job of going to sleep, not programming ;-)
14:50:38 <sioraiocht> @src length
14:50:38 <lambdabot> Source not found. Just what do you think you're doing Dave?
14:50:44 <sioraiocht> @src List.length
14:50:45 <lambdabot> Source not found. Sorry.
14:50:50 <sioraiocht> @src Data.List.length
14:50:51 <lambdabot> Source not found. Are you on drugs?
14:50:52 <sioraiocht> srsly?
14:51:12 <ddarius> It's just not there.
14:51:18 <sioraiocht> ?
14:51:26 <sioraiocht> > length [1..5]
14:51:28 <lambdabot>  5
14:51:30 <ddarius> I'm pretty sure it was there before.
14:51:31 <sioraiocht> :(
14:51:48 <sioraiocht> actually, i have a basic question, isn't length implemented as a fold?
14:51:59 <ddarius> sioraiocht: It can be.  It doesn't need to be.
14:52:27 <sioraiocht> foldl (\x y -> x+1) lst
14:52:28 <sioraiocht> right?
14:52:36 <atp> sioraiocht: foldl' might be better
14:52:36 <ddarius> That's one way.
14:52:41 <dobblego> s/lst/0
14:52:48 <sioraiocht> dobblego: right
14:52:52 <monochrom> length is optimized beyond recognition. genericLength is more recognizable.
14:52:53 <sioraiocht> @src foldl'
14:52:54 <lambdabot> foldl' f a []     = a
14:52:54 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
14:53:05 <atp> sioraiocht: otherwise you end up with accumulated thunks
14:53:09 <BMeph> @src genericLength
14:53:10 <lambdabot> genericLength []    = 0
14:53:10 <sioraiocht> ddarius: how else would you do it?
14:53:10 <lambdabot> genericLength (_:l) = 1 + genericLength l
14:53:25 <ddarius> sioraiocht: You could use foldl' as atp suggested or foldr.
14:53:54 <Toxaris> :t sum . map (const 1) -- :-)
14:53:55 <lambdabot> forall a a1. (Num a) => [a1] -> a
14:54:14 <sioraiocht> to put this in context, i'm trying to work on this problem of representing trees in lambda calc, and it suggests doing function that represents a fold on that tree.  I've had many problems with it
14:54:20 * sioraiocht doesn't want the answer.
14:54:26 <sioraiocht> but i'm trying to figure out where i'm going wrong
14:54:48 <ddarius> sioraiocht: That process is called Church-encoding by the way.
14:54:59 <sioraiocht> ddarius: right
14:55:13 <fadec> this is weird - still trying to compile the plugins package on ghc 6.8.1 1 - I get this error "Constructor `STArray' should have 4 arguments, but has been given 3". In ghci STArray has type STArray :: i -> i -> Int -> GHC.Prim.MutableArray# s e -> STArray s i e ... What in the world is going on?
14:55:15 <monochrom> Have you represented cons lists by a fold?
14:55:15 <ddarius> sioraiocht: Untyped lambda calculus?
14:55:19 <sioraiocht> ddarius: aye
14:55:27 <sioraiocht> monochrom: yeah, that was easy...
14:55:59 <atp> catamorphisms are cool
14:56:08 <ddarius> sioraiocht: Church-encoding is mechanical.  If you've done lists then you've done all the necessary basic cases.-
14:56:13 <monochrom> Oh well, I can see how some cannot jump from cons list to tree.
14:56:31 <sioraiocht> ddarius: okay, thanks
14:56:39 <BMeph> fadec: use STArray from Data.Array.ST
14:56:40 <dobblego> ddarius, is it you who much prefers using parentheses over ($) ?
14:56:49 <ddarius> dobblego: No.
14:57:00 <sioraiocht> well monochrom , for a list it's c x (c y (c z nil)) for a list?
14:57:02 <dobblego> ok, someone does; I forget who
14:57:03 <qweqwe> good night
14:57:13 <atp> dobblego: whoever they are, i bet they love lisp :)
14:57:16 <BMeph> fadec: GHC re-did the hierarchy of the libraries, which broke...everything. :(
14:57:34 <ddarius> sioraiocht: The question is how to implement c and nil.
14:57:46 <sioraiocht> ddarius: nil is easy, that
14:57:52 <sioraiocht> is \c \n. n
14:58:03 * BMeph scratches the friendly catamorphism behind the ears
14:58:12 <fadec> BMeph: I must be importing some other STArray. Looks like it came from GHC.Arr
14:59:15 <BMeph> fadec: Correct. That's the "pre-6.8.x" definition. plugins hasn't been worked on since 2005, I believe. :|
14:59:21 <SamB_XP> BMeph: do you have pictures?
14:59:54 * BMeph reaches for a camera. The catamorphism calmly strolls away...
15:00:01 <sioraiocht> but in a list, it's linearly folded, you start at the beginning and fold the first with the indentity, and then that with the seond, etc
15:00:11 <BMeph> SamB_XP: I guess not. ;)
15:00:23 <ddarius> sioraiocht: That's irrelevant.  What is c's definition?
15:01:25 <sioraiocht> ddarius: hrm...
15:01:37 <sioraiocht> ddarius: i thought c was the function you would fold over the three/list
15:01:46 <sioraiocht> *tree
15:01:49 <sioraiocht> am I wrong, there?
15:02:07 * BMeph weeps from rage and despair...
15:02:38 <fadec> BMeph: Ahh. I know just enough haskell to feel like a dog watching TV. If I do get it fixed I'll go about figuring out how to submit to hackage.
15:02:39 <BMeph> Well, it looks like HXT is going to be a bi-ya to get back into order. :(
15:02:48 <ddarius> In c x (c y (c z nil)), c and nil (and x y and z...) are free variables.  What are they bound to?  You gave nil's definition; what is c's?
15:03:05 <BMeph> fadec: Sounds like a weiner. ;)
15:03:33 <sioraiocht> ddarius: it
15:03:54 * SamB_XP laughs himself silly at the lambdacats
15:04:20 <monochrom> I want more lambdacats.
15:04:31 <sioraiocht> ddarius: it must be like... \a. \b. ......
15:04:31 <sioraiocht> hrm
15:04:34 * ddarius doesn't understand this fixation.
15:04:35 <glguy> ?remember fadec BMeph: Ahh. I know just enough haskell to feel like a dog watching TV. If I do get it fixed I'll go about figuring out how to submit to hackage.
15:04:35 <lambdabot> Done.
15:04:35 <dcoutts> SamB_XP: I particularly like the boxed cat that has the uniform representation :-)
15:04:52 <SamB_XP> I really like the xmonad cat myself
15:05:02 <sioraiocht> \a. \b. \f. f a b?
15:05:23 <ddarius> sioraiocht: How will you know when you've got the right answer?
15:05:31 <ddarius> (i.e. how can/would you check?)
15:05:41 <sioraiocht> ddarius: I've no idea :(
15:06:40 <ddarius> @src foldr
15:06:40 <lambdabot> foldr k z xs = go xs
15:06:41 <lambdabot>     where go []     = z
15:06:41 <lambdabot>           go (y:ys) = y `k` go ys
15:06:53 <BMeph> Chat with y'all later - time to go and pay some bills...
15:06:58 <ddarius> inline go and compare the [] case to nil
15:07:13 <sioraiocht> okay
15:11:07 * ddarius wonders if he can write a Church encoding type function with type families...
15:11:20 <sioraiocht> ddarius: if foldr is \k \z \xs, then [] returns z
15:11:27 <sioraiocht> and \c \n. returns n.
15:11:51 <ddarius> sioraiocht: And if you rearrange the parameters...
15:12:48 <dobblego> is finding the greatest prime factor a matter of intersecting the factorisation with the primes and taking the last?
15:13:05 <basti_> i'd suppose.
15:13:19 <ddarius> I'd just factor into prime factors to begin with...
15:13:57 <basti_> usually, the greatest prime factor isnt interesting though, i think the greatest common divisor is far more important
15:15:06 <sioraiocht> ddarius: I guess i"m thick, i'm not quite sure how you mean
15:15:27 <ddarius> \[] c n -> n, nil = \c n -> n
15:15:39 <sioraiocht> ohhh
15:16:25 <sioraiocht> so \xs k n -> k xs n
15:16:34 <sioraiocht> er
15:16:35 <sioraiocht> wait
15:16:36 <sioraiocht> ignore that
15:16:47 <sioraiocht> \xs k z -> k xs z
15:17:08 <ddarius> sioraiocht: Where are you getting that from?
15:18:01 <jre2> basti_: I agree. I just (~15min ago) used the GCD applied to arbitrary rings with a division algorithm in an explaination of implementing subtype polymorphism in an OO language for an exam. ;)
15:18:18 <sioraiocht> my warped twisted mind? i'm assuming that if for [] you would return z, then for [1,2] you would return-----,wait, ou eventually want k 1 (k 2 [])
15:18:32 <basti_> jre2: -g-
15:18:40 <basti_> jre2: and now you're fine again?
15:19:04 <jre2> hah, still working on the exam actually
15:20:27 <jre2> typing programs w/polymorphic type inferencing by hand...so not yet
15:20:34 <SamB_XP> jre2: IRC during exams? wow.
15:20:44 <jre2> it's a takehome exam
15:20:52 <SamB_XP> ah, that explains it
15:21:27 <jre2> it allows the professor to give an exam that won't fit in a standard 3hour setting
15:21:56 <sioraiocht> jre2: what uni do you go to? =p
15:22:00 <jre2> UIUC
15:22:03 <sioraiocht> ?
15:22:13 <jre2> university of illinois in urbana champaign
15:22:18 <sioraiocht> aahhh
15:23:21 <jre2> it's a programming language design course focusing on using a rewrite rule language (Maude) and executable language semantics framework (K) that are being developed here
15:24:49 <jre2> kinda neat.  you define the formal semantics and get a (fast) interpreter and model checker for free.  eventually you'll get a compiler and proof if the grad students keep working diligently
15:35:14 <fadec> atp: are you an atp?
15:35:42 <oerjan> he looks rather big to be a molecule to me...
15:36:01 <monochrom> But too small for an automated theorem prover.
16:02:26 <hpaste>  jmacclur1 pasted "xmonad build errors" at http://hpaste.org/4481
16:08:37 <ac> the problem with defining sub expressions with a Cons and Nil constructor is I can't use Haskell's list functions to define the primitives. What's the advantage to doing this as apposed to making subexpressions simply [Expr]?
16:09:20 <oerjan> in scheme, the tail is also an Expr
16:09:51 <ac> you mean '()?
16:10:21 <oerjan> hm, actually it is probably not a problem
16:10:34 <oerjan> i think you can use [Expr] if you want
16:10:52 <ac> I can't remember who it was, but somebody said "not to bother" with defining subexpressions using lists, and just to use Cons. I don't get that, because it's easier to use lists
16:11:21 <oerjan> well you need to wrap for cdr
16:12:13 <oerjan> i.e. if you use Cons, the cdr will already be an Expr, rather than [Expr]
16:13:08 <oerjan> oh and scheme does allow pairs whose tails are _not_ lists
16:13:15 <ac> oerjan: but this is on the level of the implementation, which has nothing to do with Cons
16:14:13 <ac> Just because expressions as they're evaluated are represented as haskell lists doesn't mean that expressions within the interpreted scheme have to be haskell lists too
16:14:18 <oerjan> if you do not support conses where the tail is a non-list, then [Expr] should at least work
16:14:52 <ac> oerjan: I can always just implement cons, car, and cdr in a "prelude"
16:15:29 <oerjan> no what i mean is if you implement Cons as [Expr], then you cannot have conses with non-list tails
16:15:41 <ac> oerjan: yeah of course, but I wouldn't do that
16:16:43 <ac> there's no reason not to have subexpressions be [Expr], and have a separate Cons constructor. I was just wondering if there's any disadvantage to that as opposed to making all subexpressions Conses
16:16:56 <ac> I mean "there's no reason not to that I can see"
16:17:16 <oerjan> btw the argument list of a lambda is not necessarily a true list.
16:17:29 <ac> oerjan: oh that is a good point. I wasn't thinking about that
16:17:40 <dobblego> where is the instance for Monad ((->) a) located?
16:17:52 <oerjan> dobblego: Control.Monad.Instances/Reader
16:17:59 <dobblego> Control.Arrow?
16:18:01 <dobblego> ah thanks
16:19:15 <ac> oerjan: of course my lambda primitive takes an Expr, so that is something to consider
16:19:52 <ac> oerjan: that's definitely a good reason to do away with [Expr] and have all subexprs be Conses
16:19:54 <Japsu> @mw w00t
16:19:54 <lambdabot> Maybe you meant: . ? @ bf ft id map msg pl rc v wn yow
16:20:02 <Japsu> bah
16:20:19 <oerjan> also it is not difficult to make a function that turns a true Cons list into an [Expr].
16:20:26 <Japsu> (that's merriam-webster's word of the year 2007)
16:20:37 <Japsu> (w00t, that is)
16:20:40 <mux> mmm, bulat doesn't like me somehow
16:20:53 <ac> oerjan: right, which would be quite convenient
16:21:01 <ac> that is what I'll do
16:21:39 <Japsu> (the second is "to facebook")
16:21:47 <ac> it does make the pattern matching for almost all the primitives a lot more awkward though
16:22:17 <ac> all the ones that take more than one argument that is
16:23:04 <oerjan> hm... what if you make Cons an operator?
16:23:15 <oerjan> e.g. :.
16:23:28 <oerjan> (operators starting with : are constructors.)
16:23:32 <ski> `Cons`
16:23:40 <ac> oh I didn't know about that
16:23:59 <oerjan> > (0$0 :)
16:24:00 <lambdabot>      The operator `:' [infixr 5] of a section
16:24:01 <lambdabot>         must have lower precede...
16:24:20 <ac> so if I make a ":." constructor, I can use it like "foo b . c = ..."?
16:24:21 <oerjan> and add infixr 5 :.  so it will be right associative
16:24:37 <oerjan> foo (b :. c :. d) = ...
16:25:04 <ac> oh so you need the ":" too. What's the syntax for adding "infixr 5"?
16:25:15 <oerjan> infixr 5 :.
16:25:16 <ski> infixr 5 :.
16:25:35 <ski> @quote stereo
16:25:35 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
16:25:38 <ac> as a separate line from the data definition?
16:25:44 <oerjan> yep
16:25:45 <ski> yes
16:26:11 <ac> thanks
16:26:13 <ac> thanks
16:27:04 <jre2> @src foldl
16:27:06 <lambdabot> foldl f z xs = lgo z xs
16:27:06 <lambdabot>     where lgo z []     =  z
16:27:06 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
16:29:04 <EvilTerran> ignore the bot, that's horribly
16:29:05 <EvilTerran> *
16:29:06 <EvilTerran> e
16:29:16 <EvilTerran> foldl f e [] = e
16:29:28 <EvilTerran> foldl f e (x:xs) = foldl f (f e x) xs
16:29:58 <oerjan> it's only to avoid repassing f
16:30:02 <ski> (just un-"root optimize" it)
16:32:44 <ac> so now my question is should primitives take lists or cons sells? For example, should "define" be "\env (Sym sym :. val) -> ..." or "\env (Sym sym :. val :. Nil) -> ..."?
16:35:20 <oerjan> i think the first should only be used for actual multiargument things
16:35:30 <oerjan> which define is, isn't it
16:36:39 <dobblego> how do you perform exponentiation on integral types?
16:36:43 <oerjan> *variable argument
16:36:47 <oerjan> ^
16:36:53 <oerjan> dobblego: ^
16:36:55 <dobblego> ah thanks
16:37:50 <ac> oerjan: hmm. I can't think of using define with more than 2 arguments
16:38:30 <ac> oerjan: unless you count the extended syntax of function definitions, which I wasn't going to bother to support
16:38:41 <oerjan> i was thinking of (define (myproc a b c) (first action) (second action))
16:38:42 <ac> oerjan: just "(define foo (lambda ...))"
16:39:04 <ac> :-)
16:39:13 <jre2> can you get lambda bot to get @src print outs in a pm so it doesn't flood chat?
16:39:30 <oerjan> jre2: if you send it pms yes
16:39:34 <jre2> nvm, I typoed the first time
16:39:46 <ac> oerjan: also, lambdas aren't going to support multiple expression bodies, you have to say (lambda (x) (begin ...))
16:41:24 <oerjan> ac: well i would include the Nil in principle, and convert to [] list if that was awkward.
16:42:27 <oerjan> you can also make a higher-order conversion:
16:42:57 <dduncan> hello ... I'm designing a new turing complete programming language for designing and working with truly relational databases, and wish to make the language as pure functional as possible, if not entirely, but it also needs to be easy enough to map to typical programming languages ...
16:43:06 <oerjan> > convertPrim f env asConses = f env (consToList asConses)
16:43:06 <lambdabot>  Parse error at "=" (column 28)
16:43:11 <dduncan> I'll have a few questions for those who know functional languages well ...
16:43:20 <dduncan> as to how to handle certain design issues
16:43:22 <ac> oerjan: right
16:44:15 <ski> (dduncan : truly relational as opposed to pseudo-relational ?)
16:44:18 <oerjan> er why did i put > there... :)
16:44:23 <dduncan> I know I had a good basic question thought up last night, but don't recall it at the moment ... in the mean-time, are there any recommended links for me to look at regarding other attempts to do this
16:44:37 <dduncan> mine is truly relational as per Date and Darwen's D languages
16:44:41 <ski> ok
16:45:00 <dduncan> for reference, http://search.cpan.org/dist/Language::MuldisD/ is what I have so far
16:45:02 <lambdabot> Title: The CPAN Search Site - search.cpan.org
16:45:12 <ac> oerjan: problem with those kind of HOFs is I have no clue what to name them
16:45:22 <dduncan> I mean, http://search.cpan.org/dist/Language-MuldisD/
16:45:22 <lambdabot> Title: Darren Duncan / Language-MuldisD - search.cpan.org
16:45:27 <ac> oerjan: but fortunately their type signature is usually enough
16:45:34 <dduncan> most of it is easy enough to make functional
16:45:41 <oerjan> ac: yeah i didn't really either, did i :)
16:45:51 <dduncan> it is all relational algebra and such things
16:46:01 <dduncan> but there is the particular thing about maintaining state
16:46:12 <ski> dduncan : maybe somewhat relevant is <http://www.cs.mu.oz.au/research/aditi>
16:46:22 <dduncan> thank you
16:47:00 <ac> oerjan: I already have one that takes a "[Frame] -> [Frame]" function and turns it in to an "Env -> Env" function (Env is [Frame] plus a couple more elements) called "fsf2ef"
16:47:06 <ski> dduncan : that is (or was, at least) an add-on to the logic programming language mercury for use with deductive databases ..
16:47:48 <ski> dduncan : .. i mention it to note how one could possibly use a logic-programming-like syntax, instead of SQL-like (or whatever) for a relational language
16:47:49 <oerjan> ac: ouch
16:48:53 <dduncan> my syntax, while one should be able to translate to/from SQL to an extent, is not meant to look like SQL, which is not relational
16:49:06 <ski> ok
16:49:09 <oerjan> ac: withFrames perhaps
16:49:41 <ski> dduncan : what would your syntax look like ?
16:49:41 <ac> much better name
16:49:55 <ski> (dduncan : i.e. what kind of structure ?)
16:50:15 <dduncan> my fundamental language is more AST-based
16:50:33 <ski> right
16:50:42 <dduncan> you do everything by updating the relation-typed system catalog
16:50:54 <dduncan> so all the code looks like relation/table variables
16:51:02 <oerjan> ac: so maybe mine could be withArgList
16:51:14 <dduncan> however, wrappers for it can look like a variety of syntaxes
16:51:53 <dduncan> or should I say, you do all data-definition by updating the system catalog relvars, and you do data-manip by updating or querying user-defined relvars
16:51:58 <dduncan> the relvars being what is persistant
16:52:17 <dduncan> aside from needing something representing the persistant state, it is as functional as possible
16:52:39 <dduncan> my main questions for you don't concern syntax so much as conceptualization
16:53:11 <dduncan> for example, I understand that various functional languages have different approaches for dealing with persistence
16:53:26 <dduncan> I'm trying to figure out how I should best be doing it
16:54:12 <ski> (persistence as in how to keep data after the application has finished ?)
16:54:17 <dduncan> I figured something along the lines of $newstate = updatefunc( $oldstate, $other-args )
16:54:20 <dduncan> yes
16:55:00 <dduncan> it may be tangential to how data files are currently handled in fp
16:55:15 <basti_> dduncan: going further that way would lead to monads
16:55:36 <dduncan> so I might use monads, if applicable, I'm just wondering if that is the best answer
16:55:36 <basti_> monads pass around a token that functions as an invisible external state
16:55:49 <ski> the Clean language has a uniqueness typessystem in which one (conceptually) passes around the current state of the world, getting new states (and old states cannot be reused) .. Mercury does something simialar
16:55:57 <basti_> i think monads cover about 90% of what i think files should do
16:55:59 <basti_> ^^
16:56:28 <ski> Haskell uses the monad abstraction to hide updating of state (amongst other effects), to achieve purity in this way
16:56:52 <dduncan> in my langauge, persistant storage is some abstracted away thing that is external, whether actually a file or some other process doesn't matter
16:57:06 <dduncan> so I'll try looking further into that
16:57:12 <basti_> there COULD be other abstractions than the one of the monoid that might be useful
16:57:20 <basti_> quasigroups could be, e.g.
16:57:51 <basti_> and arrows.
16:58:11 * basti_ speaks the dreaded word and sees the sun cloud and feels the earth shiver
16:59:05 <ski> monads over enriched internal categories !
16:59:48 <basti_> monads on tabasco sauce?
17:00:02 <ski> .. in other news, jobs-in-fp evening was quite interesting
17:00:50 <dobblego> is there a takeLast n xs : Int -> [a] -> [a] function, for example takeLast 2 "abcd" -> "cd"
17:01:01 <dobblego> or must we reverse, take, then reverse?
17:02:09 <mokus> you don't *have* to do it that way - you could use a reverse state monad ;-)
17:03:09 <ski> or traverse to bottom, walk up, and abort when enough elements have been collected
17:03:13 <zou> newbie question: how do you pass some global structure (e.g. a dictionary)
17:03:18 <zou> colors = ["white", "silver", "black", "perl"]
17:03:18 <zou>  
17:03:23 <Botje> takeLast n l = drop (length l - n) l
17:03:38 <zou> i want to use the colors in other functions
17:03:40 <mauke> zou: if it's global you don't need to pass it
17:05:42 <oerjan> > let takeLast n l -> last $ zipWith const (tails l) (drop n l) in takeLast 3 [1..10]
17:05:42 <lambdabot>  Parse error at "->" (column 18)
17:05:49 <oerjan> > let takeLast n l = last $ zipWith const (tails l) (drop n l) in takeLast 3 [1..10]
17:05:51 <lambdabot>  [7,8,9,10]
17:06:26 <oerjan> > let takeLast n l = last $ zipWith const (tail $ tails l) (drop n l) in takeLast 3 [1..10]
17:06:27 <lambdabot>  [8,9,10]
17:06:37 <oerjan> > let takeLast n l = last $ zipWith const (tail $ tails l) (drop n l) in takeLast 0 [1..10]
17:06:38 <lambdabot>  []
17:06:44 <oerjan> > let takeLast n l = last $ zipWith const (tail $ tails l) (drop n l) in takeLast 1 [1..10]
17:06:45 <lambdabot>  [10]
17:06:49 <oerjan> > let takeLast n l = last $ zipWith const (tail $ tails l) (drop n l) in takeLast 10 [1..10]
17:06:50 <lambdabot>  Exception: Prelude.last: empty list
17:06:53 <oerjan> oops
17:06:58 <oerjan> > let takeLast n l = last $ zipWith const (tail $ tails l) (drop n l) in takeLast 9 [1..10]
17:06:59 <lambdabot>  [2,3,4,5,6,7,8,9,10]
17:07:34 <oerjan> > let takeLast n l = last $ zipWith const (tails l) (drop (n+1) l) in takeLast 10 [1..10]
17:07:34 <lambdabot>  Exception: Prelude.last: empty list
17:07:54 <oerjan> slight problem there
17:08:14 <oerjan> anyway, that one is lazy
17:08:23 <mokus> yea, that's a good solution
17:09:01 <mokus> just gotta iron out the edge cases
17:10:36 <ddelony> How well-suited to event-driven programs is functional programming?
17:10:56 <basti_> ddelony: comonads are an image of dataflow programming
17:11:03 <basti_> which is more or less synonoymous i guess
17:11:34 <ddelony> basti_: I haven't gotten that far in the tutorial yet! :-)
17:12:27 <Saizan_> i don't think there's a tutorial on comonads
17:12:37 <basti_> i don't think so either
17:13:23 <Saizan_> however there's a paper/library for unified thread and event-driven programming based on aio
17:13:44 <basti_> yea i think theres a distributive law for monads vs. comonads
17:14:07 <oerjan> > let takeLast n l = last $ zipWith const (tails l) (undefined:drop n l) in takeLast 10 [1..10]
17:14:07 <basti_> which means that you can combine them either way you deem necissairy afaics
17:14:08 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
17:14:13 <oerjan> > let takeLast n l = last $ zipWith const (tails l) (undefined:drop n l) in takeLast 0 [1..10]
17:14:14 <lambdabot>  []
17:14:18 <oerjan> > let takeLast n l = last $ zipWith const (tails l) (undefined:drop n l) in takeLast 1 [1..10]
17:14:18 <lambdabot>  [10]
17:15:54 <ddelony> I'm sorry, I haven't gotten as far as monads either.
17:16:11 <ski> > let takeLast n = (`loop` error "too short") where loop [] k = k n; loop (x:xs) k = loop xs k' where k' 0 = xs; k' n = k (n-1) in takeLast 3 [0..9]
17:16:12 <lambdabot>  [7,8,9]
17:16:30 <basti_> ddelony: you quite a way will go. young yedi.
17:16:45 <ddelony> Yedi?
17:16:50 <basti_> :D
17:16:59 <basti_> jedi?
17:17:10 <basti_> yep jedi.
17:17:19 <ddelony> I like the *idea* of functional programming.
17:17:45 <ski> oerjan : nice ?
17:18:18 <ddelony> I asked about event-driven programming since I'm interested in game design.
17:19:40 <ski> (though i suppose the edges are worng)
17:20:20 <ski> basti_ : distributive which way ?
17:21:11 <basti_> ski: i don't remember exactly, but I'd suppose both ways if you asked me right now
17:23:31 <oerjan>  let takeLast n l = last $ zipWith const (tails l) (undefined:drop n l) in takeLast 5 [1..100000]
17:23:40 <oerjan> > let takeLast n l = last $ zipWith const (tails l) (undefined:drop n l) in takeLast 5 [1..100000]
17:23:41 <lambdabot>  [99996,99997,99998,99999,100000]
17:24:08 <ski> > let takeLast n = (`loop` error "too short") where loop as k = case as of {[] -> k' n; _:as' -> loop as' k'} where k' 0 = as; k' n = k (n-1) in takeLast 3 [0..9]  -- corrected version
17:24:09 <lambdabot>  [7,8,9]
17:24:29 <oerjan> > let takeLast n = (`loop` error "too short") where loop [] k = k n; loop (x:xs) k = loop xs k' where k' 0 = xs; k' n = k (n-1) in takeLast 5 [1..100000]
17:24:30 <lambdabot>  [99996,99997,99998,99999,100000]
17:24:31 <ski> > let takeLast n = (`loop` error "too short") where loop as k = case as of {[] -> k' n; _:as' -> loop as' k'} where k' 0 = as; k' n = k (n-1) in takeLast 5 [0..99999]
17:24:32 <lambdabot>  [99995,99996,99997,99998,99999]
17:24:51 <oerjan> ok so seems efficient enough...
17:25:02 <oerjan> > let takeLast n = (`loop` error "too short") where loop [] k = k n; loop (x:xs) k = loop xs k' where k' 0 = xs; k' n = k (n-1) in takeLast 5 [1..1000000]
17:25:03 <lambdabot>  [999996,999997,999998,999999,1000000]
17:25:05 <ski> oerjan : my first version didn't work in the case the list were empty
17:25:41 <ski> > let takeLast n = (`loop` error "too short") where loop [] k = k n; loop (x:xs) k = loop xs k' where k' 0 = xs; k' n = k (n-1) in takeLast 0 []
17:25:41 <lambdabot>  Exception: too short
17:25:47 <ski> > let takeLast n = (`loop` error "too short") where loop as k = case as of {[] -> k' n; _:as' -> loop as' k'} where k' 0 = as; k' n = k (n-1) in takeLast 0 []
17:25:48 <lambdabot>  []
17:26:11 <oerjan> > let takeLast n = (`loop` error "too short") where loop [] k = k n; loop (x:xs) k = loop xs k' where k' 0 = xs; k' n = k (n-1) in takeLast 5 [1..10000000]
17:26:14 <lambdabot> Terminated
17:26:21 <oerjan> > let takeLast n l = last $ zipWith const (tails l) (undefined:drop n l) in takeLast 5 [1..10000000]
17:26:25 <lambdabot> Terminated
17:27:00 <ski> i suppose it could be more efficient to keep a sized queue of the last seen n elements ..
17:27:06 <oerjan> i have this intuition your version has a space leak but i cannot get it to fail it seems...
17:27:37 <oerjan> since each k contains all the previous ones
17:27:53 <ski> oerjan : yes, i think .. exactly what i was going to say :)
17:29:17 <dduncan> oh, I remembered my question from yesterday ...
17:29:42 <dduncan> I was wondering if, ignoring monads and other tricks, when using plain pure functions ...
17:29:55 <dduncan> are all functions supposed to be deterministic?
17:30:04 <ski> (monads are pure, btw)
17:30:07 <ski> yes
17:30:08 <basti_> "functionally independent"
17:30:15 <mauke> all pure functions are deterministic
17:30:16 <oerjan> dduncan: yep
17:30:50 <oerjan> that's part of the essence of referential transparency
17:31:22 <oerjan> let x = f y in (x,x) is equal to (f y, f y)
17:31:49 <oerjan> in particular the two f y's must be the same
17:32:29 <dduncan> so if you want to, say, define a generic list sorting function, but that some of the input values may not have a natural sorting order, do you need to implement the function in such a way that it will still sort them somehow, just so that repeated invocations would return an identical result list, even if the order isn't practically useful?
17:33:05 <ski> the generic list sorting function can take a comparision function for elements as an argument
17:33:06 <dduncan> for example, doing a linear sort of values representing points in 2-D space?
17:33:12 <oerjan> well yes.  although if your function is purely implemented that will come automatically
17:33:12 <ski> @type Data.List.sortBy
17:33:13 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
17:33:53 <oerjan> dduncan: the builtin sort is stable .. equal elements keep their order in the list
17:34:02 <EvilTerran> dduncan, you'd have to chose an arbitrary ordering for "equal" values
17:34:23 <EvilTerran> wait, no you wouldn't. listen to oerjan, not me.
17:34:24 <dduncan> yes, arbitrary, but it would have to be one that would be deterministic over multiple invocations of a program
17:34:45 <EvilTerran> you couldn't write an algorithm that *wasn't* deterministic, in haskell
17:34:58 <dduncan> I'm thinking for example of turning a set of arbitrary values into a sequence of values
17:35:00 <Toxaris> dduncan: you can't define a non-deterministic behaviour, it's impossible in "plain pure function's" Haskell
17:35:17 <dduncan> okay
17:37:13 <ski> you can however take an extra argument whose raison d'etre is to tell which of several nondeterministic results should be chosen (so-called oracles) .. or you can wrap your nondeterminism in the `IO' monad, and attribute the nondeterministic behaviour to some hidden oracle in the world state telling which variant to choose
17:37:47 <dduncan> sure
17:38:02 <ski> that way, the nondeterminism would be pure
17:38:06 <paczesiowa> shouldn't nondeterminism be wrapped in List monad?
17:38:11 <oerjan> aka random number generators, too
17:38:19 <EvilTerran> different sort of non-determinism, paczesiowa :P
17:38:22 <Toxaris> paczesiowa: that's a different kind of nondeterminism here
17:38:35 <EvilTerran> we're dealing with more "i don't care what happens"
17:38:44 <EvilTerran> rather than "i want to know everything that *could* happen"
17:38:45 <ski> paczesiowa : list monad encodes ordered (and possible duplicated) *angelic* nondeterminism .. dduncan was talking about *demonic* nondeterminism, however
17:38:55 <EvilTerran> heh
17:39:11 <paczesiowa> huh, there's more than one?
17:39:17 <dduncan> I was talking about, I don't care what the result is, as long as it is the same on every attempt, accross multiple program invocations
17:39:25 <oerjan> a demon is just an angel with a narrow view :)
17:39:42 <ski> (`angelic nondeterminism' aka `all-solutions nondeterminism' .. `demonic nondeterminism' aka `committed-choice nondeterminism')
17:40:13 <Saizan_> oerjan: so an angel is just a bunch of demons?:)
17:40:29 <ski> (ok .. so dduncan was talking about some cached variant of demonic, i think)
17:40:48 <oerjan> Saizan_: i would not leap to that conclusion
17:40:51 <dduncan> I also have to deal with with that the same value may have several possible physical representations behind the scenes, but that is abstracted away from users
17:41:22 <dduncan> the practical application of this is ...
17:41:38 <ski> putting 2d coordinates into a linear table ?
17:42:15 <Toxaris> an angel is when you lock up all demons into a single value in the list monad, and then apply (>> return True)
17:42:26 <dduncan> whether, when someone queries the database and asks for rows to come in a sequence (they are naturally represented by an unordered set), but they don't specify an ordering, will the order of the rows I give them be deterministic or random
17:42:37 <dobblego> ?src take
17:42:37 <lambdabot> take n _      | n <= 0 =  []
17:42:38 <lambdabot> take _ []              =  []
17:42:38 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
17:42:48 <dobblego> ?hoogle -> Int -> [a] -> Maybe [a]
17:42:48 <lambdabot> hoogle: unrecognized option `->'
17:42:48 <lambdabot> unrecognized option `- '
17:42:48 <lambdabot> unrecognized option `-I'
17:42:48 <lambdabot> HOOGLE - Haskell API Search
17:42:48 <lambdabot> (C) Neil Mitchell 2004-2006, York University, UK
17:42:50 <lambdabot> [17 @more lines]
17:42:53 <dobblego> ?hoogle Int -> [a] -> Maybe [a]
17:42:54 <lambdabot> No matches, try a more general search
17:43:09 <dduncan> this has a practical affect if they are asking for eg, the first N rows, then which rows they will get
17:43:51 <dduncan> if this can be done deterministically, then the result of getting the first N rows can be determined and used within the same functional expression while that remains pure ...
17:43:57 <segosa> hello haskell persons
17:43:58 <ski> if they're just asking for any N rows (but preferably not computing more than needed) then they get whay they ask for, no ?
17:44:05 <segosa> how are you gentlemen
17:44:47 <dduncan> if it can't, then I would have to get them to ask for the N in a separate expression, then use it in one that is imperatively later, because randomness can not exist between parts of an expression, in my mind
17:45:07 <ski> segosa : what you say!
17:45:13 <dduncan> the other option is to just refuse to get the first N rows in all situations, only when it can be done deterministic
17:45:19 <segosa> you have no chance to survive make your time
17:45:43 <Toxaris> dduncan: there is no such thing as a seperate expression :)
17:45:44 <oerjan> dduncan: it seems this depends a lot on whether your database/unordered set representations can be restructured on the fly
17:46:11 <dduncan> I mean in my language, which is trying to be as functional as possible, but whose "main program" may be imperative
17:46:26 <dduncan> I'm seeing if I can put certain functionality in the functional part
17:46:27 <dduncan> or not
17:47:13 <ski> dduncan : i think the main question is : do you *want* this deterministic functionality for some reason (apart from possible purity in the program) ?
17:47:53 <ski> dduncan : if you make it nondeterministic, then sure one can express that nondeterminism purely (by a monad, e.g.)
17:49:57 <dduncan> purity or predictability is the main reason ... mainly I want that when users express a database query as a function, it always returns the same answer on the same input (and same database state), even if some different answers are non-consequential ... that's more of a purity thing
17:50:21 <dduncan> anyway, thank you for your input
17:52:43 <dduncan> fyi, this is conceptually how my language works now in regards to how to work with a database (about 3 steps) ...
17:53:19 <dduncan> the steps being a sequence in time ...
17:53:25 <dduncan> 1. read database state
17:53:51 <dobblego> dduncan, can I view previous states of the database?
17:53:54 <dduncan> 2. possibly derive new database state from old in a pure functional fashion
17:54:03 <dduncan> 3. write updated state to external
17:54:05 <ski> i would assume that implementing some caching mechanism to give consistent order would be not-so-useful .. either your database representation guarrantees to not change order on its own volition, and then you get deterministic behaviour .. or you don't have that guarrantee, and then you express in the language that this order is nondeterministic .. in both cases the code remains pure
17:54:19 <dduncan> from 1 to 3 is the boundary of a transaction
17:54:35 <dduncan> and between 3 and the next 1, some other process may have updated the database
17:54:49 <ski> (forgot : c.f oerjan's comment)
17:55:04 <dobblego> dduncan, see the IO monad for controlling I/O similarly
17:56:18 <dduncan> if I have to do something else that isn't deterministic, such as user I/O or random numbers or today's date, or non-det sorting, each of those would be an additional step in time, between 1 and 2 or 2 and 3, and there may be multiple #2 interleaved between those
17:56:25 <ski> dduncan : just a suggestion, but it might be useful to learn some basic haskell, including how everything is pure, and also learning the `IO' monad, and why that's pure too
17:56:29 <dduncan> so high level, steps in time, but each step may be pure
17:56:35 <ski> dduncan : as a comparision, i mean
17:56:39 <dduncan> yes
17:57:29 <dduncan> to conclude perhaps, the more actions can be made deterministic, the fewer distinct points in time are needed to do something, which is the root of my questions
17:57:48 <dduncan> I will continue to learn Haskell over time
17:58:09 <dobblego> dduncan, you're solving a problem that Haskell already solves
17:58:48 <ski> (dduncan : if you have two independent nondeterministic sub-problems, then i think you don't need to fix an order of them to run in ..)
17:59:11 <Toxaris> dduncan: the description you give talks about interleaving phases of two different languages (a partly non-deterministic, io capable, and a pure functional). an interesting features of monads in Haskell is that they can "describe" this distinction inside a single language (namely Haskell) in a pure functional fashion. you're talking about embedding a pure language inside an impure one. Haskell expresses impure operations throug
17:59:11 <Toxaris> h pure functions.
17:59:34 <ski> exactly
18:00:00 <Japsu> @karma+ Toxaris
18:00:00 <lambdabot> Toxaris's karma raised to 3.
18:01:36 <dduncan> fyi, my language is more meant to be intermediate, and then I can generate eg either Haskell or Perl or SQL or something else to do the actual work ... so I'm not meaning to reinvent Haskell or what have you, but invent a good domain-specific AST which is host language independent
18:02:43 <dduncan> or also parse database-using or defining code from other languages into it
18:02:57 <ski> (well, haskell isn't relations, so you wouldn't reinvent haskell)
18:03:12 <dduncan> yes
18:03:20 <ski> (s/relations/relational/)
18:03:30 <sjanssen> does anyone know when Control.Applicative was added to base?
18:04:00 <Jiten_> didn't someone mention he's working on a project where they're generating C++ code with Haskell?
18:04:01 <dduncan> but relational is logically pure, like set theory or predicate logic or whatever
18:04:09 <Jiten_> it was maybe a month or two ago
18:04:22 <dduncan> so I think there is some overlap of principles
18:04:32 <Saizan_> sjanssen: somewhere between 6.6 and 6.6.1?
18:04:39 <ski> dduncan : yes, both are declarative
18:04:56 <sjanssen> Saizan_: are you sure about that?  They're not supposed to make API changes in minor versions
18:05:41 <wolverian> I wish dph didn't require you to change your code to use it
18:05:44 <Saizan_> sjanssen: not 100%
18:06:52 <ski> (dduncan : i assume you've seen some logic programming language, like Prolog or Datalog, yes ?)
18:07:55 <dduncan> I've glanced at them, but to be honest most of my relevant experience is with the truly relational data model
18:08:17 <dduncan> I believe that fp has a lot to teach and is the best influence on what I'm doing
18:08:38 <dduncan> where what I'm doing isn't necessarily have to be a particular language paradigm
18:09:19 <dduncan> most other D / relational languages are a lot more imperative in appearance, but I'm trying to swing towards functional ... whether or not it ends up being pure fp or not
18:09:29 <ski> *nod*
18:09:36 <wolverian> oh, hi dduncan :) cool to see you here too.
18:09:44 <dduncan> hello wolverian
18:10:29 <dduncan> note, to the uninitiated, I have been involved in Perl 6 language stuff from its early post Audrey Tang / Haskell days, so most of my Haskell experence comes through that venue
18:10:50 <dduncan> though I've mostly just looked at the source than edited it
18:11:03 <dduncan> wolverian is also over there
18:11:22 <wolverian> I'm mostly looking at you guys doing a great job in the various channels :)
18:11:41 <wolverian> (moose, dbic, perl6, parrot... yow, I wish I was like these guys)
18:11:57 <ski> (window 47
18:12:09 <wolverian> pfft, I have way more.
18:12:26 <shachaf> dduncan: Now I'm going to confuse you and dcoutts even more... :-)
18:12:33 <dduncan> speaking generally, I think my effort to make an industrial-grade D (truly relational) language and implementation should have a large benefit on the computing world in general if successful, ...
18:12:40 <dduncan> and hopefully will supplant SQL for general use
18:13:03 <dduncan> hopefully, Muldis D will become more natural to a Haskell or Perl et al user than SQL is
18:13:15 <EvilTerran> ah, i remember the days when i was so idealistic ;)
18:13:21 <dobblego> me too :)
18:14:06 <EvilTerran> fortunately, that got crushed out of me by the derisive mocking i got (and so rightfully deserved) when i told people i wanted to do research so i could improve the world ;)
18:14:30 <lament> what's wrong with doing research to improve the world?
18:14:42 <SamB_XP> dduncan: one problem
18:14:48 <SamB_XP> there is ALREADY a language called D
18:14:58 <dduncan> I think my chances are more realistic though because, a), I'm not doing it from scratch, but building on solid designs by Darwen and Date (and Codd), and I'm mostly using existing software building blocks, and because I'm providing an easy migration path
18:15:15 <dduncan> and who came up with the name first, I ask you?
18:15:35 <SamB_XP> it's for a language that's supposed to be better than C
18:15:39 <dduncan> I think Darwen and Date's use may predate anyone else's, unless the others go back over a decade
18:15:52 <EvilTerran> research is so people who can't take a real job think they're doing something useful. no-one's gonna change the world, let alone any whippersnapper working on his phd :P
18:16:04 <SamB_XP> it doesn't matter who was first... it matters that the name is recognized
18:16:09 * EvilTerran is joking
18:16:15 <EvilTerran> well, ha-ha-only-serious
18:16:35 <lament> D is a terrible name anyway, you can't google for it
18:16:40 <EvilTerran> .go d
18:16:48 <ski> `Tutorial D' is recognized, no ?
18:16:49 <EvilTerran> ?go d
18:16:49 <lambdabot> http://en.wikipedia.org/wiki/D
18:16:50 <lambdabot> Title: D - Wikipedia, the free encyclopedia
18:16:50 <dduncan> regardless, "D" is just a component of my name ... the full name is "Muldis D" ... just as D and D use "D" in a generic sense, and other languages like "Tutorial D" are ones they actually use
18:16:52 <EvilTerran> ahem
18:16:58 <SamB_XP> EvilTerran: well, the occasional phd thesis is useful...
18:17:05 <SamB_XP> @google d (language)
18:17:06 <lambdabot> http://www.digitalmars.com/d/
18:17:06 <lambdabot> Title: Intro - D Programming Language 2.0 - Digital Mars
18:17:15 <EvilTerran> SamB, see my last comment; I'm not really this disillusioned
18:17:41 <EvilTerran> heck, i'm still an undergrad. being that cynical at this age would be *unseemly*!
18:17:53 <dduncan> "Muldis" is my brand, and the "D" is there because that's what all languages following Darwen and Date's abstract language model can be described as "a D language"
18:18:07 <SamB_XP> shouldn't it be a DD language?
18:18:10 <SamB_XP> or D&D
18:18:14 <SamB_XP> hmm. no. not D&D
18:18:17 <ski> *grin*
18:18:19 <SamB_XP> too confusing with the RPG series
18:18:25 <EvilTerran> also would make it kinda weird that i wholly intend to pursue research when i finish my undergrad degree
18:18:33 <dduncan> all these D's are an interesting coincidence, but the name comes from "data"
18:18:47 <SamB_XP> DDD... no, oops, that ones also taken...
18:18:54 <ski> DoD
18:19:03 <lament> EvilTerran: that's not at all weird, just means you're not good enough to get a real job
18:19:11 <EvilTerran> oh, burn
18:19:24 <SamB_XP> lament: not always
18:19:34 <EvilTerran> lament++ for I am scalded by his devil wit
18:19:44 <EvilTerran> ski, dodo?
18:19:48 <SamB_XP> some people are just too good for a regular job ;-P
18:19:51 <lament> Muldis D sounds too much like Tenacious D
18:19:54 <EvilTerran> ?go dodo programming language
18:19:54 <lambdabot> http://dodo.sourceforge.net/
18:19:55 <lambdabot> Title: Dodo, the programming language
18:19:57 <EvilTerran> poo
18:20:01 <ski> (EvilTerran : Drakar och Demoner)
18:20:08 <dduncan> fyi, "Muldis" means "Multiverse of Discourse"
18:20:38 <EvilTerran> oh, fortune, that dodo language is an abomination
18:20:38 <dduncan> anyone in philosophy should get that reference if you change the first few letters to Uni
18:21:07 <SamB_XP> I would be more likely to see Universal Disassembler or something...
18:21:58 <dduncan> a website of the authors of my primary design source is http://thethirdmanifesto.com/ ... though most
18:21:59 <lambdabot> Title: The Third Manifesto
18:22:12 <BMeph> s/Discourse/Discord/ ;)
18:24:44 <EvilTerran> > unwords . concat . transpose . replicate 5 . words $ "hail eris"
18:24:44 <lambdabot>  "hail hail hail hail hail eris eris eris eris eris"
18:29:19 <ac> oerjan: still around? I have my Expr to [Expr] function defined as so: "expr2List :: Expr -> [Expr]; expr2List Nil = []; expr2List (x :. xs) = x : expr2List xs"
18:29:30 <oerjan> in fact i just returned...
18:29:53 <ac> How would I make it throw an exception if Expr didn't have a Nil? Add a third definition like "expr2List x = Exception ..."?
18:30:05 <ac> That only works if they're matched in order
18:30:28 <EvilTerran> how would it not have a nil?
18:30:40 <oerjan> it will throw an error by default
18:30:47 <shachaf> Is there a function mapWords, that applies its argument on every word?
18:30:49 <ac> EvilTerran: if some evil person didn't put one on the end
18:30:59 <EvilTerran> what would be there instead?
18:31:06 <ac> oerjan: but the error is an obscure "Non-exhaustive patterns in function expr2List"
18:31:15 <EvilTerran> oh, i see. you have other constructors, too
18:31:20 <oerjan> expr2List _ = error "Whatever you want"
18:31:31 <EvilTerran> expr2List _ = error "blahbl- bother. oerjan++
18:31:38 <ac> heh
18:31:40 <ac> thanks
18:31:53 <Toxaris> shachaf: mapWords f = unwords . map f . words?
18:32:10 <shachaf> > unwords (words "a b\nc d")
18:32:11 <lambdabot>  "a b c d"
18:32:11 <EvilTerran> Toxaris, ah, but that won't preserve whitespace
18:32:30 <EvilTerran> shachaf, in short, no, there isn't
18:34:07 <Toxaris> > groupBy (const isSpace) "a b\nc e" -- as a start
18:34:07 <lambdabot>  ["a ","b\n","c ","e"]
18:36:10 <EvilTerran> @let mapWords f [] = []; mapWords f string = before ++ f word ++ mapWords f after where (before,wordAfter) = span isSpace string; (word,after) = break isSpace wordAfter
18:36:13 <lambdabot> Defined.
18:36:43 <EvilTerran> > mapWords reverse " The  quick brown fox jumped over the lazy dog! "
18:36:44 <lambdabot>  " ehT  kciuq nworb xof depmuj revo eht yzal !god "
18:37:10 <EvilTerran> see, with views, that'd be really nice
18:37:34 <EvilTerran> mapWords f (span isSpace -> (before, break isSpace -> (word, after)) = ...
18:38:35 <Toxaris> > groupBy ((==) `on` isSpace) "a b\nc e" -- getting closer
18:38:36 <lambdabot>  ["a"," ","b","\n","c"," ","e"]
18:40:09 * EvilTerran pokes shachaf -- do you see?
18:41:02 <shachaf> EvilTerran: Oh, I was just curious, I don't need it. :-)
18:41:11 <EvilTerran> oh, right, okay
18:41:23 <shachaf> EvilTerran: Views are nice, though. :-)
18:41:36 <EvilTerran> yeah, that's a lovely motivating example for 'em
18:41:59 <oerjan> > let mapWords f = concat . map (\s@(c:_) -> if isSpace c then s else f s) . groupBy ((==) `on` isSpace) in mapWords reverse "a b\nc e"
18:41:59 <lambdabot>  "a b\nc e"
18:42:27 <oerjan> now that was a lousy example :D
18:43:11 <Toxaris> is there no idiom for "every other element of a list"?
18:43:31 <oerjan> > let mapWords f = concat . map (\s@(c:_) -> if isSpace c then s else f s) . groupBy ((==) `on` isSpace) in mapWords " The  quick brown fox jumped over the
18:43:31 <lambdabot>  Improperly terminated string at """ (column 116)
18:43:50 <oerjan> darn irssi's line joining is unpredictable :(
18:44:03 <shachaf> Toxaris: I don't think so (didn't someone ask about this recently)?
18:44:06 <oerjan> > let mapWords f = concat . map (\s@(c:_) -> if isSpace c then s else f s) . groupBy ((==) `on` isSpace) in mapWords " The  quick brown fox jumped over the lazy dog! "
18:44:07 <lambdabot>  Couldn't match expected type `[Char] -> [Char]'
18:44:10 <EvilTerran> > map head . takeWhile (not.null) . iterate (drop 2) $ "The quick brown fox etcetc"
18:44:10 <lambdabot>  "Teqikbonfxect"
18:44:33 <oerjan> > let mapWords f = concat . map (\s@(c:_) -> if isSpace c then s else f s) . groupBy ((==) `on` isSpace) in mapWords reverse " The  quick brown fox jumped over the lazy dog! "
18:44:34 <lambdabot>  " ehT  kciuq nworb xof depmuj revo eht yzal !god "
18:44:54 <EvilTerran> > (\n m -> map (take n) . takeWhile (not.null) . iterate (drop m) 2 4 "The quick brown fox etcetc" -- this is a fairly commonly requested function
18:44:54 <lambdabot> Unbalanced parentheses
18:45:05 <EvilTerran> > (\n m -> map (take n) . takeWhile (not.null) . iterate (drop m)) 2 4 "The quick brown fox etcetc" -- ahem
18:45:06 <lambdabot>  ["Th","qu","k ","ow","fo","et","tc"]
18:45:23 <ac> Yeah, I've wanted that a few times
18:46:42 <EvilTerran> there's a horrible version involving unfoldr, too, but i prefer mind
18:46:43 <EvilTerran> *e
18:46:53 <oerjan> horrible?
18:47:36 <oerjan> > map (take 2) . takeWhile (not . null) . unfoldr (Just . splitAt 4) $ "The quick brown fox etcetc"
18:47:37 <lambdabot>  ["Th","qu","k ","ow","fo","et","tc"]
18:47:58 <shachaf> > map snd . filter fst . zip (cycle [True,False]) $ "The quick brown fox etcetc"
18:47:59 <lambdabot>  "Teqikbonfxect"
18:48:24 <Toxaris> shachaf: I like this
18:48:46 <EvilTerran> > catMaybes . zipWith ($) (cycle [return,fail]) $ "The quick brown fox etcetc"
18:48:46 <lambdabot>  Couldn't match expected type `String' against inferred type `Char'
18:49:03 <EvilTerran> > catMaybes . zipWith ($) (cycle [Just,const Nothing]) $ "The quick brown fox etcetc"
18:49:03 <lambdabot>  "Teqikbonfxect"
18:49:16 <shachaf> > catMaybes . zipWith ($) (cycle [return,const mzero]) $ "The quick brown fox etcetc"
18:49:17 <lambdabot>  "Teqikbonfxect"
18:50:28 <EvilTerran> > unfoldr ((>>) <$> guard.not.null <*> return.splitAt 4) "the quick brown fox etcetc"
18:50:29 <lambdabot>  ["the ","quic","k br","own ","fox ","etce","tc"]
18:50:41 <EvilTerran> oerjan, there's your horrible abuse of unfoldr
18:51:22 <oerjan> beautiful :)
18:52:37 <Toxaris> :t msum . zipWith ($) (cycle [return, const mzero]) -- never use fail
18:52:38 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [a] -> m a
18:52:52 <Toxaris> > msum . zipWith ($) (cycle [return, const mzero]) $ "another quick fox :: String
18:52:53 <lambdabot>  Improperly terminated string at ""anot..." (column 52)
18:52:53 <ac> what the heck is "<$>" and "<*>"?
18:52:56 <Toxaris> > msum . zipWith ($) (cycle [return, const mzero]) $ "another quick fox" :: String
18:52:57 <lambdabot>  "aohrqikfx"
18:53:11 <Toxaris> > msum . zipWith ($) (cycle [return, const mzero]) $ "another quick fox" :: Maybe Char
18:53:13 <lambdabot>  Just 'a'
18:53:53 <Toxaris> ac: <$> is just another name for "liftM" and "fmap"
18:53:56 <EvilTerran> eh. beauty is in the eye of the beholder. right next to the power of petrification. ;)
18:54:16 <Toxaris> ac: and <*> is another name for ap (but more general)
18:54:37 <EvilTerran> f <$> g <*> h = liftM2 f g h
18:54:49 <EvilTerran> ish
18:54:52 <Toxaris> > succ <$> [1, 2, 5] -- <$> is used like this, ac
18:54:52 <lambdabot>  [2,3,6]
18:54:57 <pjd> Toxaris: don't forget liftA :)
18:55:15 <Toxaris> > [succ, pred] <*> [1, 2, 5] -- <*> is used like this, ac
18:55:16 <lambdabot>  [2,3,6,0,1,4]
18:55:31 <EvilTerran> ?type (<*>)
18:55:31 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
18:55:36 <EvilTerran> ?type ap -- compare
18:55:37 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
18:55:42 <Toxaris> ac: but not only on [], but on other functors resp. applicative functors too (that includes all monads)
18:55:58 <ac> cool
18:56:59 <pjd> there's a hierarchy: Monad < Applicative < Functor
18:57:14 <lnxz> quit
18:58:42 <ac> symbolic names are infix, unlessed wrapped in "()", and alphanumeric names are prefix, unlessed wrapped with "``", right?
18:58:49 <oerjan> right
18:59:45 <ac> although Haskell's syntax is pretty clean and simple, it still seems the most perlish language I've learned since perl ;-P
18:59:47 <oerjan> > (`True`)
18:59:47 <lambdabot>  Parse error at ")" (column 8)
18:59:52 <oerjan> hmph
19:00:05 <oerjan> > ( `True` )
19:00:05 <lambdabot>  Parse error at ")" (column 10)
19:00:17 <oerjan> a bug, i think
19:00:28 <shachaf> oerjan: You can't re-parenthesize after adding ``.
19:00:30 <sjanssen> oerjan: no, Haskell syntax doesn't allow that
19:00:38 <oerjan> sure it does
19:00:48 <sjanssen> oerjan: no, it doesn't.  Check the report
19:01:03 <pjd> > map (`elem` [0,2,4]) [1..5]
19:01:04 <lambdabot>  [False,True,False,True,False]
19:01:11 <ac> It would be cool if you could... you could use "(`(`foo`)`)" to emphasize things ;)
19:01:16 <oerjan> that's weird, as sections _are_ allowed
19:01:23 <BMeph> You can't back-quote a value, though, can you? :P
19:01:30 <oerjan> i know you cannot rewrap in ``, though
19:01:55 <oerjan> True is not reserved
19:01:58 <BMeph> s/value/non-function/
19:02:21 <pjd> BMeph: values are 0-parameter functions :)
19:03:05 <BMeph> s/non-function/nullary function/ :P
19:03:35 <Toxaris> > let (?) = 42 in (?) -- but you can have nullary operators
19:03:36 <lambdabot>  42
19:03:57 <kpreid> That's a GHC extension.
19:04:00 <oerjan> oh i see i though ( + ) etc. was under the expression syntax but only left/right sections are
19:04:04 <oerjan> *i thought
19:04:22 <kpreid> Er, wait, or am I thinking of nullary (x ?)
19:04:26 <kpreid> Yeah.
19:07:27 <ac> I just read a wikipedia article that claims typed lambda calculus is not turing complete. Huh?
19:08:30 <oerjan> indeed, you cannot make recursion with just lambdas without a type violation
19:09:13 <ac> oerjan: are you saying that you need pattern matching?
19:09:19 <HeartOfDarkness> something like that couldn't stay if it was false for long
19:09:26 <oerjan> no, not patterns
19:09:32 <oerjan> @src fix
19:09:33 <lambdabot> fix f = let x = f x in x
19:09:33 <HeartOfDarkness> <- "Lycurgus" at wikipedia.
19:09:45 <oerjan> you need something like let
19:10:30 <oerjan> in fact adding just fix is enough to make it turing complete, i think
19:11:39 <dbueno> ac: The typical way to write a recursive function in the pure lambda calculus is via the Y combinator (or something similar), which can't be assigned a type in the simply-typed lambda calculus.
19:12:03 <dbueno> Y is sometimes called the fixed-point combinator, which is what oerjan is referring to, I think.
19:12:28 <oerjan> fix f = (\g g -> f (g g)) (\g g -> f (g g))
19:12:40 <mauke> \g g?
19:12:41 <oerjan> er
19:12:47 <oerjan> fix f = (\g -> f (g g)) (\g -> f (g g))
19:13:21 <oerjan> the expression g g cannot be typed
19:13:55 <mauke> @pl \f -> (\g -> f (g g)) (\g -> f (g g))
19:13:55 <lambdabot> ap (. join id) (. join id)
19:14:07 <mauke> hah
19:14:21 <oerjan>  @pl knows nothing about types
19:14:22 <mauke> :t join id
19:14:23 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a1
19:14:23 <lambdabot>     Probable cause: `id' is applied to too many arguments
19:14:23 <lambdabot>     In the first argument of `join', namely `id'
19:14:29 <ac> what is "@pl"?
19:14:34 <oerjan> @help pl
19:14:34 <lambdabot> pointless <expr>. Play with pointfree code.
19:14:48 <mauke> ac: removes named parameters
19:16:01 <mauke> @pl foo x = sqrt (x + 1)
19:16:01 <lambdabot> foo = sqrt . (1 +)
19:16:07 <Toxaris> > let mapWords f text = zipWith ($) (cycle [Left, Right]) (groupBy ((==) `on` isSpace) text) >>= either f id in mapWords reverse "rehtona xof\n \nsi\tgninnur   dnuora"
19:16:09 <lambdabot>  "another fox\n \nis\trunning   around"
19:16:40 <ac> I'm still baffled by combinators. Every time I look at one my brain returns undefined
19:16:51 <oerjan> ooh i was thinking about Either
19:16:56 <mauke> ac: do you understand const?
19:16:57 <ac> "fix f = let x = f x in x"? That doesn't make sense
19:17:34 <ac> > const 1 2
19:17:34 <lambdabot>  1
19:17:41 <ac> mauke: sure, looks simple enough
19:17:47 <mauke> that's the K combinator
19:18:03 <mauke> now you understand at least one combinator :-)
19:18:07 <ac> mauke: that's how you implement cons and booleans in ,\-calculus
19:18:15 <ac> I was actually talking about fixed point combinators
19:18:40 <ac> didn't know there were multiple types
19:18:41 <mauke> the fix you pasted above does make sense ... if you do it right
19:19:04 <oerjan> ac: that fix also involves laziness
19:19:09 <mauke> you bind x to the result of f x
19:19:25 <mauke> that only works because the binding is lazy, so you can actually use x in its own definition
19:19:39 * Toxaris finds "fix f = result where result = f result" easier to understand. but that's a general preference of where over let on his part
19:20:27 <ac> isn't that the same as id?
19:20:47 <mauke> no, id f = result where result = f
19:21:24 <ac> oh I missed the last "result", which turns f in to a function
19:21:52 <mauke> > let {zomg f = let x = f x in x} in zomg ('!' :)
19:21:53 <lambdabot>  "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!...
19:22:00 <shachaf> Toxaris: How about fix f = f (fix f)?
19:22:15 <mauke> shachaf: this is not enough sharings
19:22:31 <Toxaris> shachaf: I don't think this works as expected
19:22:33 <shachaf> mauke: Yes, but it does look nice. :-)
19:22:42 <ac> shachaf: that looks like an infinite loop
19:22:56 <oerjan> it is denotationally equivalent though
19:22:56 <mauke> ac: laziness turns infinite loops into puppies
19:23:05 <shachaf> > let y f = f (y f) in y ('!':)
19:23:06 <lambdabot>  "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!...
19:23:17 <Toxaris> shachaf: and it is operationally-looking, while my where-version literally contains the fixpoint-equation "result = f result"
19:23:35 <ac> mauke: not "x = x"
19:23:50 <mauke> > let x = x in length [x, x, x]
19:23:52 <lambdabot>  3
19:24:03 <mauke> no problem as long as you don't look at it
19:24:14 <shachaf> Toxaris: OK, that's true.
19:24:16 <scook0> that said, the fact that you can define fix f = f (fix f)
19:24:23 <scook0> means your language already has recursion :)
19:24:36 <mauke> yeah, recursive bindings
19:24:36 <shachaf> scook0: The other form is also recursive.
19:24:53 <mauke> either "fix" or "result"
19:25:19 * shachaf finds using names right before binding them slightly confusing, sometimes.
19:25:39 <ac> in ,\-calculus, why can't you just say "foo = \x.foo x" for recursion?
19:25:46 <shachaf> fix f = last (iterate f undefined)? :-)
19:25:50 <shachaf> ac: No bindings.
19:25:52 <oerjan> ac: technically there is no =
19:26:15 <ac> oh ok, so = is just for the readers convenience
19:26:30 <shachaf> ac: Yes, otherwise expressions would get way too long.
19:26:41 <scook0> ac: yeah, but in that case, the RHS can't refer to the LHS
19:26:51 <scook0> so it adds no expressive power
19:26:54 <mauke> you can treat x = y in z as syntactic sugar for (\x -> z) y
19:27:05 <ac> I see
19:27:11 <mauke> if you do that, it's pretty obvious that y can't use x
19:27:30 * Toxaris finds defining arbitrary looking expressions right before using them slightly confusing, sometimes
19:27:50 <shachaf> Toxaris: That's also true.
19:28:06 <Toxaris> http://haskell.org/haskellwiki/Declaration_vs._expression_style
19:28:38 <scook0> I find that good variable names are key to declaration style
19:29:20 <Toxaris> that's why I've choosen "result" over "x" :)
19:29:34 <shachaf> Declaration vs. expression vs. @pl style. :-)
19:30:11 <oerjan> haskell doesn't really support a pure @pl style though
19:30:38 <scook0> point-freedom isn't free? ;)
19:30:44 <shachaf> oerjan: OK, you can define a few extras for pattern-matching and such.
19:34:49 <Toxaris> who needs pattern matching?
19:37:44 <Toxaris> pure pointfree style would use pointfree type declarations (using type composition and datatype polymorphic programming) with automatically infered folds and selectors
19:38:14 <shachaf> Toxaris: Are we still talking about Haskell? :-)
19:38:50 <Toxaris> shachaf: sure. not any Haskell i've ever written, but some Haskell I've read about
19:39:58 <ac> Toxaris: are you saying you can write Haskell without any variable names?
19:40:52 <Toxaris> ac: what do you mean by "variable names"?
19:40:57 <oerjan> without any argument names
19:41:22 <ac> how? Although it's pointless, I'd like to see an example
19:41:52 <dbueno> (No pun intended? =])
19:42:02 <ac> dbueno: of course the pun was intended
19:42:09 <oerjan> > map (take 2) . takeWhile (not . null) . unfoldr (Just . splitAt 4) $ "The quick brown fox etcetc"
19:42:10 <lambdabot>  ["Th","qu","k ","ow","fo","et","tc"]
19:42:27 <oerjan> no argument names there
19:42:35 <Toxaris> ac: without a library of possible pointful functions, I could go for Church encoding :)
19:43:20 <ac> interesting. But seriously, what is the point?
19:43:25 <shachaf> ac: What program are you thinking of?
19:43:39 <shachaf> ac: For an entire program? Not much.
19:43:52 <shachaf> ac: But for small functions, sure.
19:44:00 <Toxaris> ac: but with a (small) library of pointful functions, data types, type classes and instances, one could write fully pointfree haskell (no lambda expressions, no data declarations)
19:44:02 <ac> I certainly do like leaving out arguments when I don't need them. That's why I like languages like postscript and factor
19:44:29 <ac> what do you mean by "library of pointful functions"? Wouldn't you want "pointless functions"?
19:44:47 <ac> (and Haskell of course)
19:44:57 <shachaf> ac: You need some functions (S,K,fix,IO functions, etc.)
19:45:00 <Toxaris> ac: I want a library of pointful functions to combine them in a pointfree way
19:45:05 <shachaf> ac: To define the program in terms of.
19:46:16 <ac> it never occured to me that one could write an entire program like that
19:46:18 <oerjan> ac: to wrap into functions those pesky pattern matchings that cannot be defined pointlessly.
19:46:59 <ac> thing is, even when I write in postscript I find myself creating arguments using { } thingies
19:47:04 <oerjan> some such functions are already defined
19:47:07 <oerjan> :t either
19:47:08 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
19:47:08 <ac> makes things a hell of a lot less confusing
19:47:13 <mauke> :t maybe
19:47:14 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
19:47:30 <mauke> ac: ooh, do you know unlambda?
19:47:52 * oerjan bounces cheerfully
19:48:02 <oerjan> oh wait, that's shapr
19:48:04 <shachaf> I'd guess not: <ac> I'm still baffled by combinators.
19:48:40 <ac> shachaf is correct
19:48:58 * oerjan cackles evilly instead
19:49:04 <shachaf> ac: Unlambda is a language which has nothing but combinators: Everything is done pointlessly.
19:49:10 <shachaf> @go unlambda
19:49:12 <lambdabot> http://www.madore.org/~david/programs/unlambda/
19:49:12 <lambdabot> Title: The Unlambda Programming Language
19:49:13 <ac> I've heard of it... doesn't it belong in the family of obfuscated languages like brainfuck?... yes it does
19:49:16 <shachaf> @go lazy k
19:49:17 <lambdabot> http://www.lazykbar.com/
19:49:17 <lambdabot> Title: Dude Ranch Vacation at the Lazy K Bar Guest Ranch in Tucson, Arizona
19:49:21 <shachaf> @go lazy k unlambda
19:49:22 <oerjan> o_O
19:49:22 <lambdabot> http://homepages.cwi.nl/~tromp/cl/lazy-k.html
19:49:23 <lambdabot> Title: The Lazy K Programming Language
19:49:35 * shachaf likes Lazy K.
19:52:56 <Toxaris> from that lazy-k page: "It's based on an elegant implementation of the sieve of Eratosthenes using lazy lists". is this a real sieve or just that pseudo-sieve floating around everywhere? ;-)
19:53:39 <shachaf> Toxaris: Do you feel like @unpl-ing it? :-)
19:55:36 <lament> obfuscated languages aren't really a "family"
19:55:40 <lament> they're not genetically related
19:55:58 <ac> lament: they are in the sense that they're inspired by each other
19:56:48 <shachaf> " I might point out that this is over 5 times shorter than the shortest existing Unlambda-in-Unlambda interpreter (which is missing support for several language features) and over 10 times shorter than the only fully-featured Unlambda-in-Unlambda interpreter."
19:57:39 <lament> ac: not sure if that's a useful grouping
19:58:34 <Toxaris> aren't all programming languages inspired by each other in a way?
20:01:46 <lament> i just don't like the label "oh, it's like brainfuck" applied indiscriminately
20:02:19 <oerjan> bah! my unlambda-in-unlambda interpreter is not _that_ much longer
20:02:45 <oerjan> > 8196/3632
20:02:47 <lambdabot>  2.2566079295154187
20:02:50 <Toxaris> I've just read the Lazy K website and come to the half-informed conclusions that it's indeed like brainfuck
20:03:43 <oerjan> lies, i tell you! lies!
20:04:41 <Toxaris> actually, the author uses Brainfuck as motivating example
20:06:36 <Toxaris> but it is not bad to be like brainfuck, of course. brainfuck is a perfectly usable programming language, after all (except that it isn't functional, of course). It's just a bit minimalistic, and the standard library lacks support for gui toolkits.
20:07:07 <lament> but how is it like brainfuck?
20:07:11 <lament> they're nothing at all alike
20:07:59 <ac> hah: "Remove output entirely. You still have a Turing-complete language this way, and it is if anything more elegant. But, as with the equally elegant SMETANA, you can't do anything with it except stare at it in admiration, and the novelty of that wears off after a few minutes."
20:08:12 <ac> (that's option 4 for dealing with the problem of runtime exceptions)
20:09:38 <ac> I like option 2 though. Why wouldn't it be possible to make a representation of all possible functions for input and output?
20:10:00 <lament> removing output is not that bad, since if you have an implementation, you can examine its state
20:10:12 <oerjan> yay! if i remove comments and whitespace mine is just 2013 characters
20:10:12 <lament> this is how it's always done for cellular automata
20:10:15 <Toxaris> lament: Lazy K is like brainfuck in that it captures the "distilled essence" of a programming concept. (structured programming for brainfuck, combinators for Lazy K). It is like brainfuck in that is turing-complete, but not meant for real computer programs. It is like brainfuck in that is minimalistic.
20:11:13 <ac> brainfuck is the only non practical language I've gotten in to. I was satisfied once I wrote an exponentiator function and a quine
20:12:15 <ac> I should say "program" instead of "function", as there are no functions in BF
20:12:16 <lament> Toxaris: all three hold for forth... two hold for smalltalk... :)
20:12:59 <lament> (fine, forth doesn't really capture any distilled essence, so two for each)
20:13:26 <ac> question: would adding pi-calculus semantics to Haskell significantly change the type system?
20:13:37 <lament> (also, brainfuck does not really capture the distilled essence of structured programming)
20:14:05 <oerjan> but but ... it's got loops!
20:14:15 <ac> lament: although I've never studied the formal definition of a turing machine, to me BF captures the essence of a turing machine better than a turing machine
20:14:31 <Toxaris> brainfuck has while-loops, but no gotos
20:14:51 <lament> ac: brainfuck is a lot more sensible than a turing machine
20:14:59 <Toxaris> brainfucks memory-model is turing-machine like, but it's execution model is WHILE-language like
20:15:05 <lament> ie of the two, turing machines are more obfuscated, imo
20:15:42 <ac> lament: yeah, that's the impression I got, hence why I never bothered to look too closely at a TM
20:15:55 <lament> turing machines are a disgrace to CS
20:16:06 <ac> BF should be taught instead
20:16:25 <lament> there's little reason to not just teach lambda calculus
20:16:40 <lament> which is actually not a disgrace :)
20:18:09 <ac> lament: I think BF has its place too. BF was explained to me during (or maybe before) high school, but I couldn't make heads or tails of ,\-calculus until much later
20:18:26 <ac> lament: for me BF was easy enough to grasp in about 5 minutes
20:19:06 <ac> lament: or more like in the amount of time it took to describe the 6 "functions"
20:19:08 <OceanSpray> Why wouldn't this match?
20:19:08 <OceanSpray> Couldn't match expected type `LispEnv
20:19:08 <OceanSpray> 				  -> ErrorT LispErr (ReaderT LispEnv (ContT t IO)) t1'
20:19:18 <OceanSpray>  against inferred type `LispT (Maybe LispVal)'
20:19:38 <OceanSpray> where type LispT a = ErrorT LispErr (ReaderT LispEnv (ContT a IO)) a
20:20:05 <Toxaris> OceanSpray: because the head of the first term is (->) and the head of the other term is ErrorT
20:20:15 <oerjan> OceanSpray: the LispEnv -> part?
20:20:16 <OceanSpray> oh
20:20:18 <OceanSpray> OH
20:20:22 <OceanSpray> man, why didn't I see that
20:20:44 <lament> ac: well sure, i'm just not sure what the educational value is
20:21:03 <lament> just "Something this simple can do anything"?
20:21:05 <ac> lament: it's an easy-to-understand TM
20:21:09 <ac> lament: exactly
20:21:14 <sjanssen> ac: how long did it take you to write anything non-trivial in BF?
20:21:18 <lament> (it's not a TM)
20:21:25 <ac> sjanssen: couple hours
20:21:41 <lament> if you want to emphasize simplicity, there're simpler things than BF
20:21:55 <ac> like what?
20:21:58 <lament> BF does have the advantage that you can actually write stuff in it that does something
20:22:01 <sjanssen> I'd think that lambda calculus would be easier to write actual programs in
20:22:04 <lament> without much effort
20:22:30 <ac> sjanssen: but try adding two numbers togother... then you have to explain church numerals, which are NOT easy for me
20:22:41 <loupgaroublond> is there an easy way to get out of dependency hell when installing packages from hackage?
20:22:55 <ac> loupgaroublond: cabal-install
20:22:57 <sjanssen> loupgaroublond: yes, see cabal-install
20:23:00 <chessguy> 40 hail GHCs
20:23:15 <lament> ac: for example, OISC has one instruction. :)
20:23:36 <loupgaroublond> does it work with the --user option cleanly?
20:23:51 <Toxaris> ac: at the other hand, try defining a struct in BF
20:23:59 <ac> lament: maybe it's for nostalgic reasons, but I think BF is the best simple TM-equivalent (it is, right?) system I've come accross to explain to people
20:24:45 <ac> Toxaris: easy
20:25:06 <loupgaroublond> and for that matter, does the step 'runhaskell Setup.lhs install' do anything specific to that machine, or can the code copied by that command be used for making binary packages?
20:25:11 <Toxaris> the interesting result is that all these systems can compute the same functions, isn't it? so students should learn about more then one system anyway
20:25:37 <ac> Toxaris: yes, I agree totally. I just think brainfuck should be the first for some people (like me)
20:25:54 <sjanssen> loupgaroublond: it registers the package in a database, which you can't exactly copy
20:26:14 <lament> ac: sadly, "nostalgic reasons" are exactly why people even remember turing machines
20:26:14 <sjanssen> loupgaroublond: --user is the default for cabal-install
20:26:21 <loupgaroublond> sjanssen: is there a way to split that step away, so it can be run as a post install script?
20:26:37 <ac> lament: yeah, screw them, they aren't in my generation
20:26:40 <sjanssen> loupgaroublond: possibly
20:26:52 <sjanssen> loupgaroublond: are you looking to make packages for some distribution?
20:27:00 <loupgaroublond> fedora, yes :)
20:27:32 <Toxaris> when looking at language classes, TM make sense. You go from FSM to Stack-Machines to TM
20:27:33 <ac> oerjan: remember my definitios for expr2List?
20:27:44 <sjanssen> loupgaroublond: IIRC, there is a cabal2rpm program by Bryan O'Sullivan (bos on this channel).  You should check that out
20:28:01 <loupgaroublond> sjanssen: will do, thanks :)
20:28:25 <Toxaris> but when looking at computability, lambda calculus, loop/while languages or even primitive recursive functions are so much easier to understand
20:28:27 <oerjan> ac: yes
20:28:46 <bos> @hackage cabal-rpm
20:28:47 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/cabal-rpm
20:28:53 <ac> oerjan: how do I turn that in to "Expr -> [Symbol]" (Sym Symbol is a constructor for Expr)
20:28:59 <lament> aren't language classes a silly chomsky thing? :)
20:29:16 <ac> oerjan: I could just rewrite it and add the extra match, but then I have two functions that are very similar
20:29:27 <oerjan> ac: assuming the subexpressions are all symbols?
20:29:33 <ac> oerjan: right. it would fail if they weren't
20:30:14 <ac> oerjan: obviously this is for evaluating lambda expressions
20:30:46 <oerjan> expr2Syms = map (\e -> case e of Sym s -> s; _ -> error "not a symbol") . expr2List
20:30:54 <Toxaris> (every CS student should write a BF interpreter in Lambda calculus and vice versa to learn wich language is more expressive)
20:31:09 <ac> oerjan: ok that's simple enough. It's essentially a downcast
20:32:53 <OceanSpray> Would I be able to use callCC callCC to get the current continuation?
20:33:03 <chessguy__> sigh
20:33:18 <loupgaroublond> bah, i got into a dependency hell trying to install cabal-install :)
20:33:34 <oerjan> lament: some of the Chomsky classes fit nicely into the complexity hierarchies
20:33:35 <bos> loupgaroublond: cabal-rpm has far fewer deps
20:33:58 <davidL> Which is a more idiomatic way of getting 6 bytes from input (using Data.Binary.Get), doing "getByteString 6" or doing "getWord8" 6 times?
20:34:03 <oerjan> regex = finite space, context sensitive = linear space
20:34:21 <OceanSpray> it seems not.
20:35:00 <bos> davidL: depends on whether you want six bytes or a six-byte string
20:35:05 <ac> loupgaroublond: I've gone through the same thing. It's not TOO bad
20:35:19 <loupgaroublond> ac, nope, just seems like alot, just to get xmonad
20:35:25 <ac> loupgaroublond: I ended up deleting everything and installing my distro's package
20:35:31 <oerjan> OceanSpray: callCC id ?
20:35:42 <oerjan> :t callCC
20:35:43 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
20:35:44 <OceanSpray> hm
20:35:45 <loupgaroublond> ac, which distro?
20:35:56 <ac> loupgaroublond: ubuntu. so unfortunately that limits me to 6.6
20:36:02 <oerjan> callCC return rather
20:36:11 <ac> oh well, I don't _need_ any 6.8 features
20:36:15 <ddarius> :t callCC return
20:36:15 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> m b
20:36:15 <lambdabot>       Expected type: (a -> m b) -> m a
20:36:15 <lambdabot>       Inferred type: (a -> m b) -> m (a -> m b)
20:36:17 <ddarius> No
20:36:21 <OceanSpray> Occurs check: cannot construct the infinite type: a = a -> b
20:36:26 <davidL> bos: it will go in a datatype :: Word8 Word8 Word8 Word8 Word8 Word8 ...so I will have to unpack it if I use the bytestring method, though using getByteString is fewer lines of code
20:36:27 <OceanSpray> eh
20:36:41 <OceanSpray> there's got to be a way to save the continuation.
20:36:53 <loupgaroublond> ac, you're lucky then, because of debian, ubuntu gets far better haskell packages currently
20:36:56 <oerjan> oops
20:37:04 <ddarius> OceanSpray: Of course there is.
20:37:12 <ac> loupgaroublond: whatever you do, don't install one version with your distro package and another version in /usr/local. Something is bound to get fucked up seriously
20:37:25 <OceanSpray> let x = callCC $ \k -> return k
20:37:26 <shachaf> ac: I have no trouble with it.
20:37:27 <sjanssen> davidL: I'd use getWord8 6 times
20:37:28 <OceanSpray> ?
20:37:35 <ac> shachaf: that turned in to a disaster for me
20:37:44 <bos> davidL: well, you'll need to unpack somewhere, so you're not saving anything, just moving code around
20:37:44 <ac> shachaf: I probably did something stupid
20:37:46 <loupgaroublond> ac, it's all going in my home folder for now
20:37:55 <oerjan> OceanSpray: it seems like a typing problem.  try a newtype wrapper
20:38:04 <davidL> sjanssen: why is that? is that faster than using unpack?
20:38:12 * shachaf has 10 versions of GHC installed.
20:38:13 <sjanssen> davidL: what about 'return MyConstructor `ap` getByte `ap` getByte `ap` getByte ..."
20:38:18 <bos> loupgaroublond: i haven't been packaging actively for fedora because of the tiny fedora haskell community
20:38:24 <shachaf> Including distribution packages, binary downloads, and darcs builds.
20:38:26 <sjanssen> davidL: it probably is the same speed
20:38:51 <Toxaris> :t callCC
20:38:52 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
20:38:52 <davidL> sjanssen: oh that's even nicer :) thank you
20:39:18 <loupgaroublond> bos: it'll stay that way unless something gets done about it, Fedora guys are a bit conservative when it comes to cramming things into the distro
20:39:30 <ddarius> sjanssen: Are there applicative instances too?
20:39:36 <shachaf> ac: What was the problem?
20:39:42 <sjanssen> ddarius: I'm not sure
20:39:54 <bos> loupgaroublond: the main problem is lack of a vocal user community. if i thought people would use the packages, i'd do the work.
20:40:17 <oerjan> OceanSpray: because you are returning a continuation to itself, and haskell functions cannot take themselves as arguments without a wrapper
20:40:51 <ac> shachaf: something about one library getting used by both distributions and causing everything to break
20:41:00 <loupgaroublond> bos: well add one to the users then :)
20:41:06 <bos> loupgaroublond: :)
20:41:19 <shachaf> ac: Hmm, what did you use? The 6.8.1 binary .tar.gz?
20:41:46 <loupgaroublond> bos: in any case, if you give me good packages, i'll look them over, and put up a 3rd party repo on fedorapeople, and also submit them for review
20:42:00 <bos> loupgaroublond: are you a reviewer?
20:42:00 <loupgaroublond> if not, i'll have a look at your cabal-rpm thingy
20:42:13 <loupgaroublond> bos, nope, just a dev
20:42:41 <bos> see, the problem is that packages need reviewing, and there aren't enough competent reviewers to go around
20:43:01 <bos> so you package something up, and it sits idle for five months. not very satisfying.
20:43:10 <Toxaris> OceanSpray: can't you simply use (callCC \k -> ...) instead of let k = getCCHack in ... ?
20:43:43 <ac> shachaf: yeah
20:43:51 <Socrates> @pl \f x -> x f x
20:43:51 <lambdabot> join . flip id
20:44:01 <Socrates> @pl \f x -> f x f
20:44:01 <lambdabot> join flip
20:44:08 <loupgaroublond> bos: sure, i'm still not any expert on fedora packages though, i could apply to be a reviewer if you would like, but i can't promise any miracles
20:44:28 <loupgaroublond> cabal install is nice though :)
20:44:32 <bos> loupgaroublond: i think it would be worthwhile. reviewing isn't rocket science :-)
20:44:51 <loupgaroublond> bos, sure, let me see what's involved
20:45:01 <bos> cool
20:45:39 <oerjan> Socrates: those won't be typeable though, since x or f is passed to itself
20:45:51 <OceanSpray> well...
20:47:01 <oerjan> OceanSpray: indeed, callCC $ \c -> ... with the part using c within is the usual way of using it
20:47:22 <OceanSpray> I'm getting a weird type mismatch error when I do that
20:47:24 <oerjan> unless you really need one of the fancy uses with escaping continuations
20:48:11 <OceanSpray> Couldn't match expected type `t -> t1 -> t2 -> t3 -> t4 -> t5 -> Maybe (Maybe LispVal)'
20:48:21 <OceanSpray>  against inferred type `LispT (Maybe LispVal)'
20:48:45 <OceanSpray> there's supposed to be only one maybe, and the callCC mysteriously adds one
20:49:03 <oerjan> paste?
20:49:17 <OceanSpray> ok
20:49:21 <OceanSpray> @hpaste
20:49:21 <lambdabot> Haskell pastebin: http://hpaste.org/new
20:50:33 <hpaste>  OceanSpray pasted "(no title)" at http://hpaste.org/4484
20:51:13 <davidL> is "return MyConstructor `ap` getWord8 `ap` getWord8 `ap` getWord8" (six times) the same as "return MyConstructor liftM6 getWord8 getWord8 getWord8..." ?
20:51:21 <oerjan> ouch
20:51:25 <ddarius> OceanSpray: In general, if you are getting type errors you don't understand, (temporarily) adding type annotations that say what you expect helps significantly.
20:51:47 <OceanSpray> oerjan, what's that mean?
20:51:50 <oerjan> davidL: liftM6 MyConstructor ...
20:52:19 <oerjan> OceanSpray: brain overload? :)
20:52:21 <davidL> oerjan: err yeah, thanks
20:52:37 <OceanSpray> I'm definitely getting that, yes.
20:53:13 <OceanSpray> It's unlikely that average dudes like me will understand this easily.
20:55:13 <oerjan> OceanSpray: anyway your type error seemed to have a long t -> t1 -> t2 -> t3 -> t4 -> t5 -> tail too
20:55:23 <OceanSpray> yes
20:55:51 <OceanSpray> I don't see why it would add the maybe in there
20:56:30 <loupgaroublond> wow, running xmonad didn't actually kick out compiz.... would it be possible to get them to cooperate and run simultaneously?
20:56:37 <oerjan> but that tail is _also_ a mismatch
20:57:00 <oerjan> unless LispT has that form...
20:57:27 <OceanSpray> LispT a = ErrorT LispErr (ReaderT LispEnv (ContT a IO)) a
20:57:44 <oerjan> and it seems to indicate that some function is applied to either far too few or far too many arguments
20:58:24 <oerjan> ooh! found it!
20:58:40 <OceanSpray> wha?
20:58:51 <oerjan> you are missing do after \callCC $ k -> :)
20:59:23 <oerjan> all the rest is treated as one huge expression :D
20:59:40 <OceanSpray> added the do, got
20:59:41 <OceanSpray> Primitives.hs:130:26:
20:59:41 <OceanSpray>     Couldn't match expected type `Maybe'
20:59:41 <OceanSpray> 	   against inferred type `ErrorT
20:59:41 <OceanSpray> 				    LispErr (ReaderT LispEnv (ContT (Maybe LispVal) IO))'
20:59:51 <oerjan> or wait...
20:59:56 <oerjan> maybe i am misinterpreting
21:00:05 <oerjan> :l local
21:00:08 <oerjan> :t local
21:00:14 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
21:00:50 <OceanSpray> I'm using the 'local' function to utilize the environment passed into the function explicitly rather than the one contained in its monad
21:01:10 <oerjan> ok
21:01:56 <davidL> @index liftM6
21:01:56 <lambdabot> bzzt
21:01:57 <oerjan> the current error seems rather simpler, Maybe <-> LispT mismatch
21:02:25 <OceanSpray> yes
21:02:28 <oerjan> davidL: oh, it only goes up to 5
21:02:45 <davidL> I thought I saw up to 12 somewhere :-\
21:03:00 <OceanSpray> Maybe the callCC wants a 'return' in there somewhere?
21:03:35 <oerjan> OceanSpray: you really should try to add some type annotations
21:03:42 <OceanSpray> it keeps on saying:
21:03:44 <OceanSpray>  In the second argument of `local', namely
21:03:44 <OceanSpray> 	`(envInsert "cont" (Procedure (Continuation k)))'
21:03:55 <OceanSpray> why would local take a Maybe monad?
21:08:50 <sjanssen> dons, kolmodin, dcoutts_: where shall I send patches for binary?  Alternatively, make me a member of binary-p :)
21:13:03 <oerjan> OceanSpray: what is the type of envInsert?
21:13:50 <OceanSpray> String -> LispVal -> LispT (Maybe LispVal)
21:16:59 <oerjan> what is the definition of the Proc constructor?
21:18:52 <oerjan> oh!
21:19:24 <oerjan> OceanSpray: evalContent is called with two arguments, but defined with one
21:20:50 <OceanSpray> yeah, I fixed that already
21:21:31 <OceanSpray> same error
21:23:22 * oerjan gives up
21:25:01 <BMeph> I know we have Yi, but is there an attempt as writing an Emacs-style editor in Haskell?
21:28:18 <flux> what is 'emacs style'? I understand Yi had some Emacs bindings too..
21:28:42 <flux> yi didn't have 'eval in current environment', did it?
21:33:33 <BMeph> Hm, I guess I didn't "know" as much as I thought. Okay, I guess the important Q is: is don still fiddling, or overseeing vicarious fiddling, with Yi?
21:35:21 <BMeph> s/don/Jean-Philippe/
21:52:31 <Korollary> BMeph: if I understand correctly, nobody is actively doing anything with Yi. It may not even be compiling.
21:53:22 <BMeph> Likely. Oh, well, I thought I'd ask. Thank you, Korollary. :)
21:55:51 <Korollary> I think for something like Yi, considering it would have to do at least a fraction of what vim/emacs do, it would need several active devs.
22:10:59 <hpaste>  mmorrow annotated "Arrow, -> and Kleisli defs." with "monoid instances" at http://hpaste.org/4469#a2
22:19:51 <OceanSpray> who here is affiliated with Stanford University?
22:21:13 <Korollary> OceanSpray: dmwit goes to SU iirc
22:21:20 <OceanSpray> oh lol
22:21:31 <dmwit> what
22:21:33 <dmwit> Why?
22:21:40 <OceanSpray> oh nothing
22:21:47 <OceanSpray> I just got REJECTED
22:21:53 <Korollary> Ouch sorry
22:21:56 <dmwit> Mmm, sorry.
22:22:06 <Korollary> Let's beat up dmwit
22:22:06 <OceanSpray> oh well.
22:22:14 <dmwit> Should've slipped me a few fivers last week, I could've greased some people up for you. ;-)
22:22:32 <OceanSpray> heh.
22:23:46 <OceanSpray> also, I suddenly see what the error was all along.
22:24:25 <oerjan> ?
22:24:38 <OceanSpray> callCC takes a function that has a return type the same as the a in Cont r a
22:24:38 <oerjan> (and sorry)
22:25:06 <oerjan> yes
22:25:16 <OceanSpray> since I have ContT (Maybe LispVal) a IO,
22:25:30 <OceanSpray> everything in the do after the callCC has to have type Monad a
22:25:34 <OceanSpray> *Maybe a
22:25:57 <oerjan> :t callCC
22:25:58 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
22:26:18 <OceanSpray> :t callCCT
22:26:18 <lambdabot> Not in scope: `callCCT'
22:26:21 <OceanSpray> damn
22:26:31 <shachaf> OceanSpray: callCC works for ContT.
22:26:40 <shachaf> OceanSpray: Notice the (MonadCont m) =>.
22:27:22 <OceanSpray> it seems so,
22:27:35 <OceanSpray> and yet it still requires me to put my stuff into a Maybe
22:28:00 <oerjan> er what is the type of your Continuation constructor?
22:28:12 <OceanSpray> wha?
22:28:22 <OceanSpray> LispT a = ErrorT LispErr (ReaderT LispEnv (ContT a IO)) a
22:28:31 <OceanSpray> that's all I got.
22:28:31 <oerjan> not the monad
22:28:49 <shachaf> OceanSpray: Why do you call that LispT?
22:28:52 <OceanSpray> oh, MY continuation
22:28:53 <oerjan> Continuation ... what?
22:29:07 <shachaf> OceanSpray: It doesn't look like a transformer.
22:29:15 <OceanSpray> Continuation (Maybe LispVal -> Maybe LispVal)
22:29:23 <Morningsickness> ISLE OF MAN - June 1, 2006 - At a press conference today, Canonical CEO and Free Software spokesnigger Mark Shuttleworth announced the immediate availability of version 6.06 of the Ubuntu Linux distribution. The latest version, known by its code name, "The Diaper Drake," includes special features designed to make Linux easier and more comfortable for niggers the world over.
22:29:24 <Morningsickness> "Niggers have always had trouble understanding new technology," Shuttleworth began. "Computers are no exception. Some people have said this is because niggers are dumb, but I believe the real problem is that technology has traditionally been designed for white people. Ubuntu changes all that. It was developed from the ground up with niggers in mind. It will usher in a whole new era of Afro-ergonomic computing."
22:29:34 <Morningsickness> Shuttleworth presented an overview of some of the features users could expect in the latest version of Ubuntu, including an Ebonics-to-English converter, African "tribal beats" sound and desktop theme, and a collection of rap music and gay pornography, "which of course will be encoded using patent and royalty-free formats," Shuttleworth added, smiling. He proceeded to elaborate, but OpenOffice.org Impress crashed at
22:29:34 <Morningsickness> "But this release isn't just about new features," Shuttleworth said, making a quick segue to the humanitarian and ideological concept behind Ubuntu. "This new version brings black men closer together than ever in the spirit of Ubuntu." Shuttleworth then demonstrated the concept of Ubuntu by getting on his knees and sucking a young black boy's erect penis.
22:29:45 <OceanSpray> which produces a LispProc
22:29:54 <Morningsickness> lithp
22:29:59 <Morningsickness> we love to lithp
22:30:00 <oerjan> thank god for /ignore
22:30:19 <Morningsickness> we mexicans will drive you filthy whites and jews into the sea
22:30:21 <OceanSpray> data LispVal = ... | Procedure LispProc
22:30:30 <Morningsickness> we will demographically reconquer the southwest
22:30:30 <OceanSpray> somebody kickban this motherfucker
22:30:45 <Morningsickness> fucking jews you and your spanish and white buddies
22:30:53 <Morningsickness> will end in rivers of blood
22:31:00 <Morningsickness> MEXICANOS AL GRITO DE GUERRA
22:31:06 <Morningsickness> ACERO APRESTAD Y BRIDON
22:31:07 <oerjan> no ops awake...
22:31:16 <Morningsickness> Y SE RETIEMBLA EN SU CENTRO LA TIERRA
22:31:25 <Morningsickness> AL SONORO Y RUGIR DEL CAÑON
22:31:25 <OceanSpray> well, damn
22:31:29 <Morningsickness> vive mexico
22:31:30 <OceanSpray> /ignore it is
22:31:44 <Morningsickness> http://www.aztlan.net
22:31:45 <lambdabot> Title: La Voz de Aztlan
22:31:45 <oerjan> why do you need Maybe in Continuation anyhow?
22:32:03 <OceanSpray> because my procedures can return Nothing.
22:32:21 <OceanSpray> something like (define a 5) doesn't return anything, for example
22:34:19 <oerjan> oh i see.
22:34:39 <oerjan> you need Continuation (Maybe LispVal -> LispT (Maybe LispVal))
22:35:11 <OceanSpray> really?
22:35:17 <oerjan> :t callCC
22:35:18 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
22:35:27 <oerjan> see that m in a -> m b ?
22:35:31 <OceanSpray> yeah, but
22:35:39 <OceanSpray> ok, I'll try that.
22:35:41 <oerjan> you can set b = a, but still need the m
22:37:17 <OceanSpray> Cycle in type synonym declarations:
22:37:18 <OceanSpray>       LispData.hs:77:0-69: type LispM a =
22:37:18 <OceanSpray> 			       ErrorT LispErr (ReaderT LispEnv (ContT (LispM a) IO)) a
22:37:23 <Morningsickness> UNITED MEXICAN TROLLS ON THE ATTACK!!!!!!!!!!!!!!!!    WE WILL RECONQUER THE SOUTHWEST DEMOGRAPHICALLY!!!!!!!  VAYANSE A LA CHINGADA GRINGOS DE MIERDA  SON RATEROS JUDIOS Y NECESITAN VOLVER A EUROPA    GO BACK TO EUROPE THEIVING GRINGOS  FUCCCKING JEWS  WE WILL OUTBREED YOU AND RECONQUER THE AMERICAN SOUTHWEST    6 TROLLS AT THE UNAM IN MEXICO CITY    UNSTOPPABLE
22:37:32 <Morningsickness> UNITED MEXICAN TROLLS ON THE ATTACK!!!!!!!!!!!!!!!!    WE WILL RECONQUER THE SOUTHWEST DEMOGRAPHICALLY!!!!!!!  VAYANSE A LA CHINGADA GRINGOS DE MIERDA  SON RATEROS JUDIOS Y NECESITAN VOLVER A EUROPA    GO BACK TO EUROPE THEIVING GRINGOS  FUCCCKING JEWS  WE WILL OUTBREED YOU AND RECONQUER THE AMERICAN SOUTHWEST    6 TROLLS AT THE UNAM IN MEXICO CITY    UNSTOPPABLE
22:37:34 <oerjan> ouch
22:37:44 <OceanSpray> urgh.
22:38:10 <Morningsickness> I found a very interesting study that indicates that 70% of men begin to have increasing homoerotic fantasies after the age of 50, and that 30% of these contemplate leaving their wives over them.  I am in shock!  http://SexualitySurvey2007.on.nimp.org/ 
22:38:19 <Morningsickness> i am 48 and my wife is worried
22:38:22 <Morningsickness> :o
22:39:33 <oerjan> er what is that ContT (LispM a) ?
22:40:19 <Morningsickness> UNITED MEXICAN TROLLS ON THE ATTACK!!!!!!!!!!!!!!!!    WE WILL RECONQUER THE SOUTHWEST DEMOGRAPHICALLY!!!!!!!  VAYANSE A LA CHINGADA GRINGOS DE MIERDA  SON RATEROS JUDIOS Y NECESITAN VOLVER A EUROPA    GO BACK TO EUROPE THEIVING GRINGOS  FUCCCKING JEWS  WE WILL OUTBREED YOU AND RECONQUER THE AMERICAN SOUTHWEST    6 TROLLS AT THE UNAM IN MEXICO CITY    UNSTOPPABLE
22:40:19 <Morningsickness> United Mexican Trolls On The Attack!!!!    WE WILL RECONQUER THE SOUTHWEST DEMOGRAPHICALLY!!!  VAYANSE A LA CHINGADA GRINGOS DE MIERDA  SON RATEROS JUDIOS Y NECESITAN VOLVER A EUROPA    GO BACK TO EUROPE THEIVING GRINGOS  FUCCCKING JEWS  WE WILL OUTBREED YOU AND RECONQUER THE AMERICAN SOUTHWEST    6 TROLLS AT THE UNAM IN MEXICO CITY    UNSTOPPABLE
22:40:53 <dmwit> Wow, is that... is that spam?
22:41:10 <dmwit> Because he said "lithp" there at a time that actually seemed appropriate.
22:41:27 <ari> I blame the GNAA
22:41:32 <Morningsickness> The San Diego fires were the work of illegal aliens hellbent on destroying the gay niggger ghetto.  "Pennisbird watched with horror as 6 nigggher faggs burnt to death, leaving their black smooth muscula
22:41:32 <Morningsickness> gay niggger ghetto.  "Pennisbird watched with horror as 6 nigggher faggs burnt to death, leaving their black smooth muscular bodies motionless in a puddle of gay nigggher seemen with their oiled frizzy hair up in smoke. The San Diego fires were the work of illegal aliens hellbent on destroying the gay niggger ghetto.  "Pennisbird watched with horror as 6 nigggher faggs burnt to death, leaving their black smooth m
22:41:40 <mdurr> any way to get Data.Binary to read a 32bit float... I even tried reading into significand/exponent after decoding an Int32... no luck
22:41:42 <ari> ... definitely GNAA
22:41:47 <Morningsickness> MEXICANOS AL GRITO DE GUERA
22:41:49 <Morningsickness> GUERRA
22:41:54 <Morningsickness> ACERO APRESTAD Y BRIDON
22:42:02 <dmwit> Looks like this bot has some Google-fu, at least.
22:42:03 <Morningsickness> Y SE RETIEMBLE EN SU CENTRO LA TIERRA
22:42:14 <Morningsickness> AL SONOR Y RUGIR DEL CAÑON
22:42:22 <Morningsickness> vete al a verga dmwit
22:42:22 * dmwit wonders idly how to become a channel op
22:42:26 <Morningsickness> te voy a chingar
22:42:35 <Morningsickness> y meteré mi  verga en tu culo
22:42:52 <OceanSpray> hm
22:42:54 <Morningsickness> hasta que te sanges de tu ano apestoso
22:42:59 <dmwit> ?babelfish es en chingar
22:42:59 <lambdabot> Unknown command, try @list
22:43:21 <OceanSpray> yes, that's ContT (LispM a)
22:43:24 <Morningsickness> yo no uso el pinche babelfish
22:43:24 <oerjan> OceanSpray: you need to decide what type your ContT system should be returning
22:43:27 <Morningsickness> check my ip
22:43:34 <oerjan> and LispM a does not seem reasonable
22:43:38 <Morningsickness> i speak spanish as a first language idiot
22:43:44 <OceanSpray> dang.
22:43:45 <dmwit> Maybe so, but I don't.
22:43:51 <OceanSpray> <oerjan> you need Continuation (Maybe LispVal -> LispT (Maybe LispVal))
22:43:59 <Morningsickness> i am not gnaa
22:44:04 <Morningsickness> UNITED MEXICAN TROLLS
22:44:06 <OceanSpray> that's what I did, wasn't it?
22:44:08 <Morningsickness> TROLES UNIDOS MEXICANOS
22:44:15 <oerjan> i meant to change the Procedure data type :D
22:44:30 <Morningsickness> we will drive all jews and whites into the sea, in rivers of blood
22:44:36 <Morningsickness> we will take back the american southwest
22:44:42 <Morningsickness> and the rest of the continent
22:44:49 <Morningsickness> in the name of the natives
22:44:53 <Morningsickness> mayans
22:44:54 <Morningsickness> aztecs
22:44:56 <mdurr> vas a la otro channel por favor
22:44:57 <Morningsickness> cherokee
22:45:00 <Morningsickness> apache
22:45:15 <Morningsickness> no mdurr...si eres mexicano deberias por lo menos apoyarme
22:45:25 <Morningsickness> podemos expulsar a los judios y blancos rateros
22:45:35 <Morningsickness> pinches judios de mierda
22:45:43 <OceanSpray> I did, but in order to save the function into the Procedure data type, callCC $ \k -> has to yield a (Maybe LispVal) -> LispM (Maybe LispVal)
22:46:03 <dmwit> There's certainly no lack of strong language there.
22:46:06 <Morningsickness> channel es "canal"
22:46:15 <oerjan> huh? it should yield Maybe LispVal
22:46:27 <OceanSpray> I meant for the k
22:46:34 <OceanSpray> I'm trying to save the k here
22:46:44 <Morningsickness> we are already reconquering the us demographically
22:46:49 <Morningsickness> once we are large enough in number
22:46:53 <sorear> I have been summoned?
22:46:56 <Morningsickness> you all will leave or die
22:46:59 <mdurr> no estoy mexicano
22:47:07 <Korollary> sorear: Use the force
22:47:08 <Morningsickness> http://www.aztlan.net
22:47:08 <lambdabot> Title: La Voz de Aztlan
22:47:08 <dmwit> sorear: Yes, please!
22:47:16 <Morningsickness> deberias decir "soy"
22:47:18 <Morningsickness> idiota
22:47:19 <oerjan> did you change anything other than the Procedure declaration?
22:47:28 --- mode: ChanServ set +o sjanssen
22:47:33 --- kick: Morningsickness was kicked by sjanssen (User terminated!)
22:47:53 <OceanSpray> put the ban in kickban
22:47:58 <OceanSpray> YEEEAAAH!
22:47:58 --- mode: sjanssen set +b Morningsickness!*@*
22:47:58 --- kick: Morningsickness was kicked by sjanssen (User terminated!)
22:48:10 <shachaf> sjanssen: Thanks. :-)
22:48:13 * OceanSpray high fives sjanssen
22:48:14 <mdurr> :)
22:48:18 <Korollary> sjanssen++
22:48:19 <dmwit> Thanks much, sjanssen.
22:48:57 <OceanSpray> so anyways
22:49:04 <sorear> So at least three people think I'm an op in #haskell, where I'm not, and people ask if I'm new in #xmonad, where I'm the CHANNEL CREATOR.  Something isn't right here.
22:49:16 <sjanssen> sorear: you're not an op?
22:49:18 <shachaf> sorear: I know you're a lambdabot admin.
22:49:24 * sjanssen tries to figure out how to add sorear
22:49:29 <mdurr> anyway I will leave this Data.Binary for another day, goodnight
22:49:45 <sorear> sjanssen: it probably involves /msg chanserv help access
22:50:15 <dmwit> sorear: Three people? I see only Korollary and I screwing up...
22:50:33 <sorear> dmwit: in #nethack, 22:45 < shachaf> sorear: Any chance you can help in #haskell?
22:50:36 <shachaf> dmwit: I asked in #nethack, where he was active.
22:50:49 <dmwit> oh, heh
22:50:50 <Korollary> I assumed based on someone else's assumption heh
22:51:17 <dmwit> likewise
22:51:23 <shachaf> sorear: Sorry. :-(
22:52:12 -ChanServ(ChanServ@services.)- sjanssen!n=sjanssen@CPE-76-84-191-66.neb.res.rr.com ACCESS [#haskell] ADD sorear 38
22:52:12 <oerjan> OceanSpray: you had something like LispT a = ErrorT LispErr (ReaderT LispEnv (ContT a IO)) a
22:52:29 <OceanSpray> yes
22:52:35 <sjanssen> does anyone have any idea what this 'level' business means?
22:52:39 <sorear> Thank you for the invitation. :)
22:53:02 <sorear> sjanssen: it represents what actions are and aren't allowed
22:53:07 <shachaf> sjanssen: /msg chanserv level #haskell list
22:53:08 <oerjan> the second last a must be replaced by something else - it must be common for all your LispT uses
22:53:12 <tdr> sjanssen your level determines your channel rights
22:53:32 <OceanSpray> ok.
22:53:44 <dfranke> wow, I'm passing (.) as an argument to (.), and it's actually the most clear way to do what I'm doing.
22:53:48 <oerjan> it will be the final result of the runContT
22:54:02 --- mode: sjanssen set -o sjanssen
22:54:03 --- mode: ChanServ set +o sorear
22:54:08 --- mode: sorear set -o sorear
22:54:15 <dmwit> dfranke: Yikes, what's the unclear way? =P
22:54:38 <dfranke> this gives a hexidecimal representation of a ByteString:
22:54:43 <dfranke> toHex :: B.ByteString -> String
22:54:43 <dfranke> toHex bs = B.foldr ((.) . pad) (const "") bs undefined
22:54:43 <dfranke> where pad :: Word8 -> ShowS
22:54:43 <dfranke>       pad w | w < 16    = showChar '0' . showHex
22:54:44 <dfranke>             | otherwise = showHex
22:54:47 <OceanSpray> Maybe ContT (ErrorT (Maybe LispVal)) IO ?
22:55:16 <oerjan> OceanSpray: drop that ErrorT
22:55:28 <OceanSpray> why?
22:55:29 <oerjan> i think Maybe LispVal may serve well
22:55:49 <OceanSpray> But... I need the ErrorT for error reporting
22:56:04 <oerjan> er you are just typoing
22:56:16 <OceanSpray> oh
22:56:30 <OceanSpray> the 'Maybe' is mine, not in the type
22:56:52 <OceanSpray> I was thinking that, maybe, I could use ContT (ErrorT (Maybe LispVal)) IO
22:56:56 <OceanSpray> yeah
22:57:08 <oerjan> your ContT is missing the first argument
22:57:21 <oerjan> or, you are confusing things
22:57:45 <OceanSpray> I'm getting confused, yes
22:58:40 <oerjan> try LispT a = ErrorT LispErr (ReaderT LispEnv (ContT (Maybe LispVal) IO)) a
22:59:43 <oerjan> the ErrorT definitely does not go in the first argument to ContT
23:00:19 <OceanSpray>     Couldn't match expected type `Cont
23:00:19 <OceanSpray> 				    (LispM (Maybe LispVal)) (Maybe LispVal)'
23:00:19 <OceanSpray> 	   against inferred type `LispM (Maybe LispVal)'
23:00:35 <OceanSpray> oh wait
23:00:38 <OceanSpray> that's a different error
23:00:42 <OceanSpray> It works now
23:01:18 <oerjan> it compiles? :D
23:01:22 <OceanSpray> well, no
23:01:37 <OceanSpray> now I gotta figure out how to actually use the continuation
23:01:59 <OceanSpray> it's this part that's giving me the error
23:02:01 <OceanSpray> apply (Continuation cont) (val :/ Null) = withCont (const cont) (eval val)
23:02:44 <oerjan> it could be that making LispM a newtype and deriving the monad classes would simplify error messages...
23:03:16 <oerjan> should val really be evaluated there?  isn't it already evaluated?
23:03:26 <OceanSpray> no
23:04:06 <oerjan> :t withCont
23:04:07 <lambdabot> forall b r a. ((b -> r) -> a -> r) -> Cont r a -> Cont r b
23:04:21 <oerjan> oh
23:04:32 <oerjan> withCont doesn't do what you think
23:04:36 <OceanSpray> ?
23:05:06 <oerjan> it can only apply a pure continuation wrapper, not the one you saved
23:05:18 <OceanSpray> I've been searching online for some documentation that describes withCont's purpose, but to no avail.
23:05:32 <OceanSpray> a pure continuation wrapper, eh?
23:06:51 <OceanSpray> well, now that my continuations are of the type Maybe LispVal -> LispM (Maybe LispVal),
23:07:09 <OceanSpray> I could just call the cont directly, no?
23:07:18 <oerjan> you might
23:08:11 <oerjan> eval val >>= cont might be enough
23:08:20 <OceanSpray> and that's exactly what I have now
23:08:37 <OceanSpray> ...and another error
23:08:42 <OceanSpray> man, these just don't stop coming
23:08:53 <OceanSpray> Primitives.hs:1:0:
23:08:53 <OceanSpray>     Couldn't match expected type `Maybe LispVal'
23:08:53 <OceanSpray> 	   against inferred type `[LispVal]'
23:09:09 <OceanSpray> the weird thing is, all I have on line 1 is 'module Primitives where'
23:09:23 <oerjan> eek
23:11:37 <oerjan> what does the Proc constructor contain?
23:13:05 <OceanSpray> data LispProc = Proc {closure :: LispEnv
23:13:05 <OceanSpray>                      ,arglist :: LispVal
23:13:05 <OceanSpray>                      ,content :: [LispVal]}
23:13:05 <OceanSpray>               | Continuation LispCont
23:13:44 <OceanSpray> where LispCont = Maybe LispVal -> LispM (Maybe LispVal)
23:16:42 <oerjan> well that :1:0 error message is completely useless unless there is more context
23:16:55 <OceanSpray> I know where the error is.
23:17:02 <OceanSpray> @hpaste
23:17:03 <lambdabot> Haskell pastebin: http://hpaste.org/new
23:17:47 <hpaste>  OceanSpray pasted "(no title)" at http://hpaste.org/4485
23:18:33 <oerjan> (btw remember you can annotate)
23:20:42 <oerjan> ok i see nothing wrong there
23:22:31 <OceanSpray> getContent is returning a [LispVal], and apply :: LispM (Maybe LispVal) doesn't seem to like that.
23:23:03 <OceanSpray> curiously, when I write apply :: LispM t, the error message points to line 1
23:23:09 <shachaf> OceanSpray: Is LispM the new name for LispT?
23:23:33 <OceanSpray> but when I write LispM (Maybe LispVal), it points to line 53 instead, where the error really is.
23:23:36 <OceanSpray> shachaf, yes.
23:23:41 <shachaf> OceanSpray: Why not just "Lisp"? State isn't called StateM.
23:24:37 <OceanSpray> well
23:24:40 <oerjan> anyway i'm leaving
23:24:43 <OceanSpray> It doesn't seem right.
23:24:49 <OceanSpray> thanks, oerjan
23:52:52 <zou> any pointers on how to use the state monad?
23:56:00 <sorear> zou: that is the wrong question; you do not ask "How can I use the state monad today?" - instead, ask yourself what your true problem is, and ask how to solve it.
