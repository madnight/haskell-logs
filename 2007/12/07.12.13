00:01:54 <dmwit> zou`: Hmmm, I guess I thought that could be done with permute, but now trying it out, it seems clear that I don't understand how permute works.
00:02:15 <zou`> i tried myself
00:02:27 <zou`> permute behaves a bit different than i thought
00:02:33 <dmwit> indeed
00:03:50 <zou`> one thing that i note is also that each parser in permute can't overlap
00:04:13 <zou`> that is, the year and the mileage parser can't all be checking for digit
00:05:28 <zou`> then the other thought i had is to model the grammar something like
00:06:38 <Sizur> what does the Cxt stand for in TH?
00:06:56 <zou`> (words* | term)* where term = year|make...
00:07:03 <zou`> but that didnt' seem to work either
00:07:55 <dropdrive> Can anyone explain why this is so slow?  replace1 old new xs = let (ls, rs) = break (== old) xs in ls ++ new:(tail rs)
00:08:04 <dmwit> Sizur: Have you looked through the papers and the wiki?
00:08:30 <Sizur> the doc only says data Cxt = [Type]
00:08:36 <Sizur> eh type Cxt
00:08:49 <dmwit> Okay, what more do you need?
00:08:54 <Sizur> not even a short line
00:09:27 <Sizur> my problem is i need to construct an InstanceD and i dont know what needs to go where
00:10:00 <dmwit> dropdrive: Slow compared to what?
00:10:22 <dmwit> dropdrive: Keep in mind that you are replicating the entire list each time you use that function.
00:10:31 <dropdrive> dmwit: So that function replaces the first instance of old by new.  There's the "obvious" way.
00:10:57 <dmwit> obvious, but wrong ;-)
00:11:16 <dropdrive> dmwit: I mean, I've also written it the "obvious" way, which is much faster.
00:11:17 <dmwit> > let replace1 old new xs = let (ls, rs) = break (== old) xs in ls ++ new:(tail rs) in replace1 3 4 [1,2,3]
00:11:20 <lambdabot>  [1,2,4]
00:11:35 <dmwit> bwuh
00:11:43 <dmwit> > break (== 3) [1..3]
00:11:43 <lambdabot>  ([1,2],[3])
00:11:50 <dmwit> Oh, duh.
00:11:54 <Sizur> if i need the result to be "instance C A B where x = x" how would i do that using InstanceD Cxt Type [Dec]?
00:12:32 <dropdrive> dmwit: You're saying that break is duplicating my list?
00:12:52 <dmwit> dropdrive: Well, no, but it is traversing the list twice.
00:13:42 <dropdrive> dmwit: Ah, exactly.  Thanks!  (By the way, is there a haskell-newbie channel?)
00:13:47 <dmwit> break p x = (takeWhile (not . p), dropWhile (not . p)) -- takeWhile and dropWhile each traverse the list until p is satisfied
00:13:58 <dmwit> dropdrive: You're in it. =)
00:14:39 <dropdrive> dmwit: I've read that break only traverses the list once.
00:14:40 <zou`> dmwit: if you found out more about permute or has any more insight on the parsing problem, please let me know(@ zslist at gmail), i'll have to drop off soon
00:14:42 <zou`> thanks
00:14:58 <dmwit> zou`: I haven't any further ideas, sorry.
00:16:38 <Sizur> dmwit: Cxt reduction: InstanceD [Type] Type [Dec] -- what do these Types stand for?
00:16:57 <dmwit> dropdrive: Hmm, that may be true.
00:17:07 <dmwit> dropdrive: I'm not really sure.
00:17:34 <dmwit> Sizur: I dunno, I've never used Template Haskell.  Cxt sounds like "Context", though, could it have to do with class instances?
00:17:59 <wy> Is there any issues about 64bit Linux for Haskell libraries?
00:18:31 <dmwit> Pure Haskell libraries shouldn't have too many problems, but bindings to libraries in other languages could.
00:18:37 <Sizur> yeah but that would mean i cannot have a multiparam classes in th :(
00:18:50 <dmwit> =/
00:19:07 <Sizur> and that's exactly what i need :(
00:21:29 <Sizur> the only other solution would be to do runIO and append strings to my module at compile time :(
00:21:59 <dmwit> You should write to the mailing list.
00:22:02 <Sizur> bye bye type safety
00:24:51 <zou`> dmwit: any where else to ask the parsec permute question? i've posted to ha.haskell newsgroup, but didn't get any response
00:25:21 <dmwit> I'm not really sure.
00:25:42 <dmwit> If you ask here again in a few hours, there may be more people awake to answer you.
00:26:13 <dmwit> You might just get "design your grammar better first" as a response, though. =)
00:26:32 <zou`> that's what i'm afraid :(
00:26:55 <zou`> i tried this afternoon, but not much luck
00:28:50 <dmwit> > let isYear x = let n = read x in (x > 1980 && x < 2007) in filter isYear . words $ "2000 Acura XL roomy interior 20K miles"
00:28:51 <lambdabot>   add an instance declaration for (Num String)
00:29:10 <dmwit> > let isYear x = let n = read x in (n > 1980 && n < 2007) in filter isYear . words $ "2000 Acura XL roomy interior 20K miles"
00:29:11 <lambdabot>  Exception: Prelude.read: no parse
00:29:22 <dmwit> of course
00:29:41 <dmwit> zou`: What about (year | model | make | other)* as a grammar? =P
00:41:41 <hpaste>  Taejo pasted "All permutations" at http://hpaste.org/4429
00:42:15 <Taejo> I'm having trouble quickchecking this: quickcheck generates large lists which take *forever* to permute
00:42:24 <Taejo> permute == generate all permutations
00:42:47 <Taejo> is there any way to cap the size of generated lists?
00:43:11 <dmwit> (==>)
00:43:20 <Taejo> :t (==>)
00:43:22 <lambdabot> Not in scope: `==>'
00:43:32 <Taejo> :t (Test.QuickCheck.==>)
00:43:33 <dmwit> ?hoogle (==>)
00:43:33 <lambdabot> forall a. (Test.QuickCheck.Testable a) => Bool -> a -> Test.QuickCheck.Property
00:43:33 <lambdabot> Did you mean: (==>)
00:43:34 <lambdabot> Prelude.undefined :: a
00:43:34 <lambdabot> Control.Monad.State.Class.get :: MonadState s m => m s
00:46:09 <manu_> Hello, is there a way to pass around the labels of a record as if they were first class ??
00:46:19 <dmwit> nope
00:46:28 <scook0> not with the built-in record system
00:46:45 <dmwit> It's one of the more unfortunate bits of Haskell, in my opinion.
00:46:47 <dmwit> But!
00:46:52 <scook0> you can do that sort of stuff if you're willing to use HList for your records
00:46:58 <Taejo> @instances Test.QuickCheck.Testable
00:47:00 <dmwit> Check out:
00:47:03 <dmwit> http://twan.home.fmf.nl/blog/haskell/overloading-functional-references.details
00:47:05 <lambdabot> Title: Overloading functional references - 21 thoughts, http://tinyurl.com/2ustba
00:47:21 <manu_> scook0 : ok, thanks
00:47:54 <scook0> do look into FRefs/Lenses too; they may be simpler for your needs
00:48:21 <manu_> dmwit : cool, that looks interesting ;)
00:48:39 <manu_> scook0 : FRefs/Lenses ? any pointers ?
00:49:23 <dmwit> FRefs are what I pointed you at.
00:49:37 <dmwit> Lenses you can find with the statistically significant phrase "bananas lenses".
00:50:01 <manu_> ok, thanks guys
00:51:13 <manu_> that bananas paper looks pretty heavy-going !! :)
00:51:38 <dmwit> Yes, it seems quite a bit drier than its title would suggest. =P
01:09:49 <Mitar> is there a way to go over a list (like map) but which would use two consequential values? like on [1,2,3,4,5,6] I would get a result list from [(f 1 2),(f 2 3),(f 3 4),(f 4 5),(f 5 6)]
01:10:11 <dmwit> zip it with its tail
01:10:53 <Mitar> no standard?/
01:11:07 <sjanssen> zipWith is the standard idiom, and it's quite easy
01:11:13 <dblhelix> Mitar: it's almost standard: zipWith f xs (tail xs)
01:11:19 <sjanssen> @type \f xs -> zipWith f xs (tail xs)
01:11:20 <lambdabot> forall a c. (a -> a -> c) -> [a] -> [c]
01:11:37 <Mitar> thanks
01:13:13 <roconnor> @pl  \f xs -> zipWith f xs (tail xs)
01:13:14 <lambdabot> (`ap` tail) . zipWith
01:13:25 <roconnor> @type (`ap` tail)
01:13:26 <lambdabot> forall b a. ([a] -> [a] -> b) -> [a] -> b
01:14:20 <elad`> gl :: IO String
01:14:20 <elad`> gl = do x<-getChar
01:14:20 <elad`> 	if x == '\n' then return []
01:14:20 <elad`> 	else	do  xs <- gl
01:14:20 <elad`> 				return (x:xs)
01:14:25 <elad`> What's wrong with this?
01:14:38 <dmwit> elad`: The first thing wrong with it is that it's pasted in-channel.
01:14:39 <dmwit> ?hpaste
01:14:39 <lambdabot> Haskell pastebin: http://hpaste.org/new
01:14:45 <dmwit> (for the future =)
01:14:57 <roconnor> elad`: probably something to do with indentation :/
01:15:00 <dmwit> elad`: The second thing wrong is the indentation of the else.
01:15:16 <dmwit> It needs to be at least one space more than the if.
01:15:25 <elad`> Oh.
01:15:43 <elad`> ERROR file:.\e.hs:101 - Last generator in do {...} must be an expression
01:15:49 <dmwit> The third thing wrong is that it's not "gl = getLine". ;-)
01:15:50 <elad`> (After fixing the indentation.)
01:16:20 <elad`> dmwit, I'm trying to redefine getLine to see I got it right.
01:16:28 <dmwit> Yeah, I know, I was just teasing you.
01:16:30 <quicksilver> elad`: it may be that your "return" isn't lining up with your "xs <- gl" ?
01:16:35 <roconnor> elad`: do you have return (x:xs) indented?
01:16:49 <elad`> Yes. It's the same place as the do.
01:16:52 <quicksilver> elad`: in general, using real tabs as you appear to be is asking for pain.
01:17:01 <elad`> It gives an error as soon as the if.
01:17:01 <quicksilver> use spaces
01:17:52 <Sizur> quicksilver: are you familiar with th?
01:18:04 <quicksilver> Sizur: no, not raelly
01:19:10 <elad`> Tried that too. Doesn't work.
01:19:10 <elad`> gl = do x<-getChar
01:19:10 <elad`>   if x == '\n' then
01:19:10 <elad`>    return []
01:19:10 <elad`>    else do xs <- gl
01:19:10 <elad`>          return (x:xs)
01:19:25 <glguy> ?seen bos
01:19:25 <lambdabot> bos is in #ghc and #haskell. I last heard bos speak 3h 35m 26s ago.
01:19:59 <quicksilver> elad`: you need the return to line up with 'xs'
01:20:03 <sjanssen> elad`: move 'then' to the same line as 'return'
01:20:05 <quicksilver> elad`: and please stop pasting in the channel? :)
01:20:46 <quicksilver> elad`: oh, and you need the "if" to line up with the "x<-" in the line before it.
01:21:11 <quicksilver> sjanssen: that's not the cause of the problems, though, that's just a style point?
01:21:26 <sjanssen> quicksilver: nah, I just don't get the layout rule :)
01:22:01 <dmwit> Me neither. =P
01:22:20 <allbery_b> doesn't the "else" need to be less indented than the previous "return []"?
01:22:25 <quicksilver> allbery_b: no
01:22:33 <quicksilver> allbery_b: "if" is an expression, it is not layout
01:22:45 <quicksilver> allbery_b: anything which is to the right of the if is just an expression continuation
01:22:53 <quicksilver> allbery_b: and can be indented as much or as little as you like
01:23:00 <allbery_b> ok
01:23:06 <quicksilver> allbery_b: (until you start another layout block inside, like the inner 'do')
01:25:00 <elad`> Thanks!
01:28:53 <elad`> Is there a library function for turning an integer to its corresponding string?
01:29:01 <quicksilver> show
01:29:04 <quicksilver> > show 189
01:29:06 <lambdabot>  "189"
01:29:07 <wy> I wonder if anybody here tried Xen?
01:29:51 <dmwit> elad`: Why restrict yourself to integers? ;-)
01:29:57 <elad`> Thanks
01:32:58 <elad`> I still don't seem to "get it". For example, strlen = putStr (show (length input)) where input = getLine doesn't work for me, and I don't know why.
01:33:13 <elad`> (strlen :: String -> IO ())
01:33:52 <dmwit> Have a look at the type of length:
01:33:53 <dmwit> :t length
01:33:54 <lambdabot> forall a. [a] -> Int
01:33:58 <dmwit> :t getLine
01:33:59 <lambdabot> IO String
01:34:19 <dmwit> getLine returns an *IO* [Char], and length doesn't know what to do with that.
01:34:59 <dmwit> There's a really long list of tutorials online that will explain more about exactly what's going on here, but for starters, you can use a simple rule of thumb.
01:35:40 <dmwit> In "do" notation, anything with return type "IO a" should have some binding, and function calls without an IO in its return type should go in a let.
01:35:50 <dmwit> So, you're "strlen" would become
01:36:09 <elad`> Could you direct me at a good tutorial on this specific subject, preferably a short one?
01:36:15 <dmwit> do { s <- input; let x = show (length s); putStr x } -- for example
01:36:18 <Porges> Mitar: is there a way to go over a list (like map) but which would use two consequential values?
01:36:33 <Porges> Mitar: theres probably a cool way to do it with arrows :)
01:36:35 <dmwit> elad`: I'll point you to three, take your pick of which looks best to you.
01:36:47 <dmwit> http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
01:36:48 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ..., http://tinyurl.com/ecqzl
01:36:58 <Porges> Mitar: there's the "delay" arrow, but it doesn't seem to be in the latest GHC release
01:37:06 <dmwit> http://www.haskell.org/all_about_monads/html/index.html
01:37:06 <lambdabot> Title: All About Monads
01:38:15 <dmwit> http://sigfpe.blogspot.com/2007/11/io-monad-for-people-who-simply-dont.html
01:38:16 <lambdabot> Title: A Neighborhood of Infinity: The IO Monad for People who Simply Don't Care, http://tinyurl.com/yplmwx
01:39:52 <mauke> http://mauke.ath.cx/stuff/haskell/how-to-io.html
01:39:53 <lambdabot> Title: Haskell: How To IO
01:40:48 <quicksilver> ah, I wouldn't read stuff from mauke.cx, he's a known troll
01:40:49 <dmwit> Oooo, nice, and this explanation matches closely to how I think of IO right now.
01:40:52 <quicksilver> oh, there he his :P
01:41:26 <allbery_b> > let f l = zipWith (:) l (tails l) in f [1..10]
01:41:28 <lambdabot>  [[1,1,2,3,4,5,6,7,8,9,10],[2,2,3,4,5,6,7,8,9,10],[3,3,4,5,6,7,8,9,10],[4,4,5...
01:41:42 <mauke> quicksilver: ah, but this is mauke.ATH.cx :-)
01:41:43 <allbery_b> hm, not what I intended.  shuld go sleep or something
01:42:04 <quicksilver> mauke: :)
01:42:14 <quicksilver> mauke: I'd not seen that one before, actually, I like it.
01:42:30 <quicksilver> mauke: although I guess it wouldn't be accessible to everyone.
01:42:31 <allbery_b> @src zipWith
01:42:31 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
01:42:31 <lambdabot> zipWith _ _      _      = []
01:43:07 <mauke> quicksilver: it makes sense when you're coming from OCaml (I hope)
01:43:16 * quicksilver nods
01:43:18 <dmwit> > let f l = replicate (length l) l in f [1..10]
01:43:19 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10],[1,2,3...
01:43:40 <dmwit> ?pl \l -> replicate (length l) l
01:43:40 <lambdabot> replicate =<< length
01:43:44 <dmwit> augh
01:43:50 <allbery_b> > let f l = zipWith (\x y -> [x,y]) l (tails l) in f [1..10]
01:43:50 <lambdabot>      Occurs check: cannot construct the infinite type: b = [b]
01:43:50 <lambdabot>       Expected...
01:43:52 <Porges> someone let me know if they come up iwth a cool arrow solution via lambdabot please :)
01:43:55 <allbery_b> duh
01:44:19 <elad`> Thanks. The one for those who don't care seems to be working right now.
01:44:19 <dmwit> Uh... a cool arrow solution to what?
01:44:35 <allbery_b> <Porges> Mitar: is there a way to go over a list (like map) but which would use two consequential values?
01:45:24 <dmwit> *blink*
01:45:54 <dmwit> Is that a different question from Mitar's?
01:46:28 <allbery_b> hm, I may have bound those wrong
01:46:28 <Sizur> dmwit: to come back to TH. yes, i can express multiparam class instance. i'm just a noob :P
01:46:37 * allbery_b did say he should probbly go bck to bed
01:46:38 <dmwit> Sizur: Ah, great!
01:46:56 <dmwit> Sizur: noobishness is fixable, changing TH might be harder. =P
01:47:12 <quicksilver> dmwit: I think porges was wondering if you could use the delay arrow to give a funky solution to Mitar's question
01:47:18 <quicksilver> dmwit: I may have misunderstood though :)
01:47:31 <dmwit> ah
01:49:38 <elad`> Anyone here knows how to stop notepad++ from using tabs as its auto-indentation thingie? It seems a lot of my errors spring from there.
01:54:09 <mauke> elad`: I don't know but I can tell you how to write Haskell with tabs
01:54:21 <osfameron> elad`: ah! that was always one of my doubts about haskell's whitespace handling, but I'd never heard people complain about getting bitten by it.
01:55:03 <dmwit> osfameron: What's your preferred solution?  (I've heard making '\t' a lexical error as a suggest. ;-)
01:57:21 <osfameron> dmwit: hehe, cute.  My preferred solution is :set expandtab in vim though...
01:57:47 <dmwit> Oh, yes, mine too.
01:58:13 <dmwit> I prefer it so hard that I put it in my .vimrc.
01:58:15 <quicksilver> elad`: yeah, you can indent haskell with hard tabs, but I don't like it.
01:58:26 <quicksilver> the sane way is to put a newline after every layout starting block
01:58:30 <dmwit> I really don't think that's his problem, though.
01:58:32 <quicksilver> (do, let)
01:58:38 <mauke> where
01:58:44 <quicksilver> dmwit: it was one of the problems, I think
01:58:53 <dmwit> It seems like his problem is that hitting the "Tab" key is causing his editor to realign things.
02:01:07 <Sizur> dmwit: i love your idea of making '\t' a lexical error
02:01:54 <Taejo> @src liftM
02:01:55 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
02:02:09 <Taejo> @unsugar do { x1 <- m1; return (f x1) }
02:02:09 <lambdabot> Unknown command, try @list
02:02:14 <Taejo> @list
02:02:14 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
02:02:24 <dmwit> ?undo do { x1 <- m1; return (f x1) }
02:02:24 <lambdabot> m1 >>= \ x1 -> return (f x1)
02:02:31 <dmwit> But...
02:02:35 <Taejo> dmwit: thanks
02:02:47 <dmwit> liftM f m1 -- shorter and more idiomatic
02:03:02 <dmwit> Sizur: I thought it was a pretty good idea when I heard it, too. =)
02:03:08 <Taejo> dmwit: yeah, obviously.
02:03:48 <dmwit> ...oh
02:03:49 <dmwit> heh
02:05:55 <sjanssen> s/liftM/fmap
02:06:00 <sjanssen> liftM is evil!
02:06:13 * dmwit waits for f <*> m1
02:06:32 <mauke> f . m1
02:06:36 <sjanssen> f <$> m1
02:06:51 <mauke> liftA f m1
02:06:55 <quicksilver> #haskell is like a reassuring old man
02:06:56 * dmwit will wait a long time if he is waiting for a wrong answer
02:06:58 * sjanssen is ambivalent about (.)-as-fmap
02:07:04 <quicksilver> always telling the same stories about the war
02:08:30 <mauke> dmwit: pure f <*> m1
02:08:40 <Sizur> quicksilver: lol
02:15:10 <elad`> http://pastebin.com/d367613d2
02:15:21 <elad`> How come this doesn't work for exists 4 t2 ?
02:16:41 <mauke> because t2 isn't sorted
02:16:57 <elad`> Fuck me.
02:17:02 <elad`> How could I be so stupid?
02:17:16 <elad`> Thanks. Jeez...
02:19:07 <joelr1> good morning
02:19:20 <dmwit> Good night.
02:19:45 * dmwit >>> bed
02:20:12 <elad`> By the way, how would you go about implementing a Red-Black tree in Haskell? In a more conventional language, I'd have the node hold a variable declaring its colour. In Haskell, would I be better of creating tree as = Empty | RedBranch | BlackBranch ?
02:21:24 <mauke> I don't know but I'd look how Okasaki does it
02:21:38 <elad`> Who?
02:22:42 <elad`> Oh.
02:23:27 <elad`> Anyhow, different question - I want to set data Tree a = Empty | Branch a, and data Branch = RedBranch | BlackBranch. How do I do that?
02:24:13 <quicksilver> data Tree a = Empty | Branch Branch a a ?
02:24:22 <quicksilver> and Branch defined as you did before?
02:24:34 <quicksilver> assuming you don't mind overloading 'Branch' as both a type and a constructor
02:24:42 <quicksilver> which is quite common but potentially confusing :)
02:24:52 <sjanssen> data Color = Red | Black -- is better, IMO
02:24:52 <quicksilver> clearer might be
02:25:04 <quicksilver> data Tree a = Empty | Branch Color a a ?
02:25:05 * sjanssen takes the wind out of quicksilver's sails :)
02:25:27 * quicksilver synergises sjanssen's new data type seamlessly into what he was already typing.
02:25:46 <quicksilver> actually
02:25:48 <quicksilver> surely it's
02:26:01 <quicksilver> data Tree a = Empty | Branch Color (Tree a) a (Tree a) ?
02:26:04 <quicksilver> or somethign tlike that.
02:26:13 <elad`> http://pastebin.com/d1cb6e213
02:26:25 <elad`> Works, until I uncomment that last line, the one with Red in it.
02:26:30 <elad`> No idea why.
02:26:57 <mauke> your Tree doesn't contain a Branch
02:27:10 <elad`> ?
02:27:25 <mauke> RedBranch is a Branch. you can't put it in a Tree
02:27:38 <quicksilver> you probably want Branch Branch a (Tree a) (Tree a)
02:27:47 <Sizur> @hoogle ([a],[a])->[a]
02:27:48 <lambdabot> No matches, try a more general search
02:27:48 <quicksilver> or, as sjanssen says, a better name :)
02:28:04 <mauke> :t uncurry (++)
02:28:05 <lambdabot> forall a. ([a], [a]) -> [a]
02:28:13 <Sizur> mauke: thanks
02:28:59 <elad`> Branch Branch a (Tree a) (Tree a) ?
02:29:09 <elad`> I don't get it.
02:29:45 <Sizur> :t (++) (curry unzip)
02:29:46 <lambdabot>     Couldn't match expected type `(a, b)'
02:29:46 <lambdabot>            against inferred type `[(a1, b1)]'
02:29:46 <lambdabot>       Expected type: (a, b) -> c
02:30:07 <mauke> elad`: your trees use Empty but you didn't define an Empty type. why?
02:30:54 <elad`> Why should I?
02:31:01 <mauke> exactly
02:31:06 <elad`> ..?
02:31:24 <mauke> the first thing in each branch of a data definition is not a type, it's a constructor name
02:31:36 <elad`> Perhaps the code of the right way to define binary trees could help me?
02:31:37 <quicksilver> elad`: mauke is making you compare Empty and Branch
02:31:43 <mauke> Empty | Branch ... in your case
02:31:48 <quicksilver> elad`: you have two alternatives, Empty and Branch
02:31:55 <quicksilver> elad`: you *also* defined a type called Branch
02:32:01 <quicksilver> but you never defined a type called Empty
02:32:19 <quicksilver> the *lightbulb* moment is when you try to understand why you did the two differently.
02:32:43 <elad`> data Branch = RedBranch | BlackBranch
02:32:43 <elad`>    deriving (Show,Eq)
02:32:43 <elad`> data Empty = Empty
02:32:43 <elad`>    deriving (Show,Eq)
02:32:43 <elad`> data Tree a = Empty | Branch (Tree a) a (Tree a)
02:32:43 <elad`>    deriving (Show,Eq)
02:32:45 <elad`> Then?
02:32:45 <quicksilver> incidentally the code you pasted isn't actually using the Branch type. Although it is using the Branch alternative of the Tree type.
02:32:53 <mauke> elad`: no
02:33:04 <mauke> no one said you should define an Empty type
02:33:21 <elad`> Rather? That I shouldn't define a Branch type?
02:33:25 <mauke> you should try to understand why you didn't need one
02:34:09 <elad`> My problem is this - if I don't define a Branch type, how do I have both red branches and black branches, without duplicate code for each colour of branch?
02:34:21 <elad`> Unless...
02:34:22 <mauke> no
02:34:27 <elad`> Branch Colour ... ?
02:34:34 <mauke> your problem is this: you don't understand the significance of constructors
02:34:45 <elad`> That's one of my problems, I guess.
02:34:57 <mauke> the "Branch" in data Tree a = ... is not the name of a type
02:35:03 <mauke> it's a constructor (i.e. a label)
02:35:42 <elad`> Oh. And when I do function (Branch ...) = ..., it's equivalent to function (n+1) = ..., right?
02:36:12 <mauke> er
02:36:21 <mauke> no, + isn't actually a constructor :-)
02:36:34 <elad`> Similar, though?
02:36:40 <mauke> it's a dirty hack
02:37:31 <elad`> Which is?
02:38:28 <mauke> allowing non-constructors in patterns
02:38:39 <elad`> Ah.
02:38:56 <elad`> Noted. So, what do you think about:
02:38:56 <elad`> data Colour = R | B
02:38:56 <elad`>    deriving (Show,Eq)
02:38:56 <elad`> data Tree a = Empty | Branch Colour a (Tree a) (Tree a)
02:38:56 <elad`>    deriving (Show,Eq)
02:38:58 <elad`> then?
02:39:04 <mauke> I don't know what (n+1) actually desugars to but it's probably something like a' | a' > 0 = let a = a' - 1 in ...
02:39:22 <mauke> elad`: that makes sense and should work
02:39:52 <mauke> (you could actually reuse the name Branch for the data type but that can lead to confusion)
02:40:02 <mauke> and Branch Branch a ... looks stupid
02:45:00 <elad`> How do I define constructors, anyhow? I can just do "whatever :: Empty", and whatever is now all of a sudden a constructor that gives an empty R/B-Tree?
02:45:38 <quicksilver> no
02:45:40 <quicksilver> you can do
02:45:46 <quicksilver> whatever = Empty
02:45:54 <quicksilver> that doesn't make whatever a constructor, though
02:45:56 <quicksilver> it makes it a value
02:45:59 <elad`> Yeah, that's whatI meant.
02:46:14 <quicksilver> constructors are the things int he data declration (R,B,Empty,Branch)
02:46:16 <elad`> I see. But since there's no assignment in Haskell, it's the same thing, ah?
02:46:20 <EvilRanter> data Tree a = Empty | Branch Colour a (Tree a) (Tree a)  -- is the definition of the type and the constructor
02:46:26 <EvilRanter> (s)
02:46:33 <quicksilver> constructors are a little more specific than values
02:46:39 <quicksilver> you can't pattern match directly on a value
02:46:44 <quicksilver> btu you can on a constructor
02:46:50 <quicksilver> foo Empty = "This tree is empty!!!"
02:46:57 <quicksilver> ^^ foo works by pattern-matching
02:47:06 <quicksilver> foo whatever = "This doesn't meant what you think it does"
02:47:20 <quicksilver> ^^ that does *not* use the definition of whatever = Empty :)
02:48:14 <elad`> But "isEmpty createRBTree" does work for me.
02:48:22 <elad`> (whatever = createRBTree)
02:48:26 <quicksilver> yes
02:48:31 <quicksilver> values are fine in expressions
02:48:49 <quicksilver> it is specificall when you define a function by pattern matching that you have to use true constructors
02:49:05 <EvilRanter> or anywhere else you do pattern-matching
02:49:10 <quicksilver> isEmpty Empty = True; isEmpty Branch _ _ _ _ = False
02:49:25 <quicksilver> ^^ there is essentially no way to write "isEmpty" without using pattern matching.
02:49:46 <quicksilver> so you really have ot use the actual symbol "Empty" here
02:50:06 <elad`> I didn't quite get that, but since I'm not sure for how long I'll be able to benefit of your assistance, I'll move on to more pressing issues:
02:50:13 <elad`> How do I override the default show?
02:50:23 <EvilRanter> oh, don't worry about it, quicksilver's *always* in here ;)
02:50:38 <EvilRanter> hm
02:50:42 <Lemmih> elad`: You don't.
02:51:14 <elad`> But what if I want "show" to print my tree to the screen in a more readable fashion?
02:51:22 <quicksilver> stop deriving it
02:51:26 <quicksilver> then you don't get the default
02:51:31 <quicksilver> and you can define your own :)
02:52:10 <elad`> Ah. Well, I'll leave that for last, then, even though it would probably make more sense to do it first, since it makes debugging everything else easier.
02:52:19 <mauke> elad`: just use a different function
02:52:48 <elad`> "In addition, your tree should inherit from the class Show, which has one function: show :: (Show a)
02:52:49 <elad`> => a -> String. The tree created by the line insert 'r' 2 (insert 'a' 1 (insert 'y' 3 (insert 'i' 4
02:52:49 <elad`> createRBTree))) should be presented as:
02:52:49 <elad`> "
02:52:59 <elad`> So I don't think I have a choice.
02:53:02 <quicksilver> ;)
02:53:04 <mauke> yeah
02:53:05 <quicksilver> fair enough.
02:53:10 <mauke> except types don't inherit from classes
02:53:14 <quicksilver> in general, Show should produce valid haskell code
02:53:19 <quicksilver> that's a very useful invariant for it
02:53:36 <quicksilver> you can debug test cases and then copy-paste them into code, to serve as test cases in your test suite
02:53:45 <mauke> > (\x -> case x of 0 -> "zero"; _ -> "non-zero") 42
02:53:49 <lambdabot>  "non-zero"
02:53:56 <mauke> > let wtf = 0 in (\x -> case x of wtf -> "zero"; _ -> "non-zero") 42
02:53:57 <quicksilver> so normally people recommend also implementing a 'pretty_print' or whatever
02:53:59 <lambdabot>      Warning: Pattern match(es) are overlapped
02:54:00 <lambdabot>              In a case alterna...
02:54:07 <quicksilver> for convenience
02:54:20 <mauke> lambdabot :(
02:54:25 <quicksilver> elad`: and that's a very poorly written exercise becase as mauke says, types don't do inheritance in haskell :)
02:58:56 <elad`> Thanks!
02:59:46 <elad`> Merde, I'm supposed to haul ass to the uni right now to work on this with a partner, but if memory serves, there's no IRC client there, and most of what I have learned so far was learned with your help.
03:00:27 <mauke> yeah, we use this channel to store our collective memory
03:03:04 <ivanm> elad`: there's always sites like ircatwork ...
03:04:30 <mauke> http://irssi.org/themefiles/c0ders.png
03:04:56 <elad`> I notice a distinct lack of porn...
03:05:55 <EvilTerran> @yow
03:05:55 <lambdabot> Xerox your lunch and file it under "sex offenders"!
03:10:49 <Taejo> @src mzero []
03:10:49 <lambdabot> Source not found. I feel much better now.
03:10:52 <Dorfl> ircatwork does work
03:10:54 <Taejo> @src [] mzero
03:10:54 <lambdabot> mzero = []
03:10:59 <Taejo> @src [] mplus
03:10:59 <lambdabot> mplus = (++)
03:11:02 <Dorfl> testing
03:12:28 <elad`> mauke, that one's great.
03:13:27 <roger`> hmm, I'm trying to build hdbc-sqlite3 on linux, I grabbed a copy of the .so from sqlite.org, added extra-libs-dirs: . to the cabal, upon building it it says no such file or directory, but if I watch using strace, it shows the sqlite3.so being opened, closed and then continues to search the other library dirs, anyone have any ideas?
03:17:11 <EvilTerran> version?
03:17:44 <EvilTerran> sorry, to be less monosyllabic: might there be a version clash?
03:19:04 <ivanm> EvilTerran: since when has "version" been a monosyllabic word? :p
03:19:15 <roger`> EvilTerran: hmm, what type of version clash? I tested linking the .so I downloaded against a dummy C program, which worked fine
03:19:50 <EvilTerran> ivanm, i said "less monosyllabic"; doesn't mean i was entirely monosyllabic in the first place, just more so
03:19:53 <EvilTerran> :P
03:20:19 <EvilTerran> roger`, i mean the version you've got of hdbc-sqlite3 may be incompatible with your version of the .so
03:20:25 <EvilTerran> i dunno, i'm just speculating
03:21:15 <roger`> EvilTerran: well, I had hoped it would "just work" - the same procedure worked on windows.
03:21:44 <EvilTerran> ha. good luck with that.
03:21:51 <EvilTerran> ( ;) )
03:22:00 <roger`> thanks :)
03:25:55 <harlekin> How can I define a data type "memory" as a list of zeros and ones?
03:26:15 <mauke> type Memory = [Bool]
03:27:05 <harlekin> And how would I define a type Bool by myself?
03:27:12 <EvilTerran> @src Bool
03:27:13 <lambdabot> data Bool = False | True deriving (Eq, Ord)
03:27:22 <EvilTerran> just like that! </tommy-cooper>
03:27:29 <harlekin> Thanks. (-:
03:27:49 <harlekin> But I can't do something like this: type Block = 1 | 0, can I?
03:28:01 <ivanm> > fromEnum True
03:28:03 <lambdabot>  1
03:28:03 <EvilTerran> no, as 1 and 0 are special
03:28:04 <mauke> no, 1 and 0 are not valid constructor names
03:28:14 <harlekin> Okay. Thanks.
03:28:15 <ivanm> use toEnum/fromEnum
03:28:49 <EvilTerran> ... there isn't a Word1, is there?
03:29:11 <mauke> unlikely
03:29:19 <EvilTerran> altho it would be possible to define
03:40:21 <elad`> http://pastebin.com/d302c2c24
03:40:27 <elad`> Doesn't work. How come?
03:40:50 <EvilTerran> what happens instead?
03:41:43 <elad`> Program error: pattern match failure: iSort_v1645 [1,65,2,3,6,3,432,7,4,10] []
03:41:51 <elad`> ( for Main> iSort [1,65,2,3,6,3,432,7,4,10] )
03:42:06 <mauke> elad`: helpr
03:42:18 <elad`> When I deconstruct it into separate functions, it reports a problem with helper.
03:42:22 <elad`> mauke?
03:42:29 <mauke> HELPR
03:42:36 <EvilTerran> 5.   helpr (x:src) tgt = helper src (insert x tgt) where
03:42:47 <EvilTerran> -----^^^^^
03:42:56 <elad`> oh ffs
03:42:58 <elad`> Thanks.
03:43:26 <mauke> you're using hugs, right?
03:44:02 <mauke> ghci reports: *** Exception: irc.hs:4:3-21: Non-exhaustive patterns in function helper
03:44:08 <elad`> Yes. Why?
03:44:22 <mauke> "pattern match failure: iSort_v1645" looks a bit less helpful
03:44:43 <elad`> That does look a tad more helpful.
03:44:43 <EvilTerran> sometimes one interpreter or t'other gives better errors
03:44:56 <EvilTerran> sometimes GHCi's're terrible
03:44:58 <EvilTerran> @ghc
03:44:58 <lambdabot> ghc says: Unexpected kind unification failure
03:45:02 <EvilTerran> @ghc
03:45:02 <lambdabot> ghc says: absApply: Duff function
03:45:04 <EvilTerran> @ghc
03:45:04 <lambdabot> ghc says: Illegal unlifted type argument
03:45:08 <EvilTerran> etcetc
03:45:14 <mauke> I've never seen those IRL
03:45:36 <mauke> I did get the "my brain exploded" one, though
03:45:50 <EvilTerran> i get "the impossible has happened" occasionally
03:46:22 <quicksilver> time for breakfast at milliways!
03:47:37 <hpaste>  gyde pasted "tetravex_trees" at http://hpaste.org/4430
03:47:50 <Gyde> anybody have the time to explain abit about using binary search trees as a implemention of 2darrays?
03:48:38 <Gyde> some more clues can be found at hpaste
03:50:48 <quicksilver> Gyde: I don't often do this, but I suspect you should have a glance over http://haskell.org/haskellwiki/HomeworkHelp
03:52:51 <ttfh> hmm, the jobs-in-fp thing is tempting, maybe I could take tomorrow afternoon of
03:53:58 <ttfh> is manyone here going?
03:54:00 <Botje> Gyde: < is defined for pairs
03:54:18 <Botje> Gyde: so you can build your tree like you normally would, and ignore the fact your keys are pairs.
03:55:14 <Botje> (you DO know how to construct a binary tree, don't you?)
03:56:43 <quicksilver> Botje: I suspect it's supposed to be a quad-tree
03:56:54 <quicksilver> Botje: so the standard < on pairs isn't the right ordering.
03:56:59 <quicksilver> Botje: only guessing though :)
03:57:17 <Botje> he said binary, so i'm taking his word for it :P
03:57:52 <Botje> but yes, partitioning with a quad tree would be a smart thing to do
03:58:22 <quicksilver> ok, but there are binary algorithms which don't use a simple order
03:58:37 <quicksilver> BSP stuff is sometimes binary (hence the B!) but you split in alternate dimensions or something
03:58:41 <quicksilver> or sometimes custom planes
03:58:44 <quicksilver> not my area :)
03:58:49 <quicksilver> http://en.wikipedia.org/wiki/Binary_space_partitioning
03:58:50 <lambdabot> Title: Binary space partitioning - Wikipedia, the free encyclopedia
03:58:59 <Botje> yeah
03:59:12 <Botje> BSPs just split on polygons in your world
04:00:06 <sgillesp1e> good morning
04:00:59 <sgillesp1e> I want to read up on how to implement a type system similar to GHC's
04:01:05 <sgillesp1e> what do you all suggest
04:02:20 <Gyde> Botje, well I could make a tree like a Data type, but im just indoubt about what my tree type should be like
04:03:14 <Gyde> but yes, I have tried makeing a simple binary tree just with numbers and a occurs function
04:04:03 <pejo> sgillesp1e, "Typing Haskell in Haskell"? http://web.cecs.pdx.edu/~mpj/thih/
04:04:04 <lambdabot> Title: Mark P Jones: Typing Haskell in Haskell
04:04:50 <sgillesp1e> awesome
04:05:38 <sgillesp1e> thank you
04:10:15 <elad`> *** Expression    : helper
04:10:15 <elad`> *** Expected type : Ord a => [a] -> a -> a -> a
04:10:15 <elad`> *** Inferred type : Ord Integer => [Integer] -> Integer -> Integer -> Integer
04:10:20 <elad`> That doesn't make any sense.
04:11:22 <mauke> for some reason your helper depends on Integer
04:11:29 <mauke> code?
04:12:42 <elad`> http://pastebin.com/db14e91
04:13:26 <Mitar> showing the Double values makes something like "1.3611085210030946e-3"
04:13:34 <quicksilver> elad`: (x-n)
04:13:40 <quicksilver> elad`: you're subtracting stuff there
04:13:44 <Mitar> how could I show Double like "0.0013611085210030946"
04:13:45 <Mitar> ?
04:13:55 <quicksilver> elad`: that forces it all to be numbers
04:13:55 <EvilTerran> ?hoogle float
04:13:55 <lambdabot> Text.ParserCombinators.Parsec.Token.float :: TokenParser st -> CharParser st Double
04:13:56 <lambdabot> Language.Haskell.TH.PprLib.float :: Float -> Doc
04:13:56 <lambdabot> Prelude.Float :: data Float
04:14:07 <quicksilver> Mitar: showEFloat showFFloat showGFloat
04:14:17 <quicksilver> Mitar: I can't remember which is which but you can try them out :)
04:14:18 <EvilTerran> ah, there they are
04:14:20 <allbery_b> or Text.Printf.printf
04:14:30 <mauke> > Numeric.showFFloat Nothing 1.3611085210030946e-3 ""
04:14:32 <lambdabot>  "0.0013611085210030946"
04:14:40 <elad`> But why wouldn't Num be enough herE?
04:14:45 <elad`> Also, how do I get abs?
04:14:45 <quicksilver> elad`: it would.
04:14:49 <EvilTerran> E is exponential, F is fixed decimal point, G is the other (chosing depending on the number)
04:14:55 <elad`> nevermind, abs is abs
04:14:57 <quicksilver> but hugs defaults to integer.
04:15:04 <quicksilver> when it sees an ambiguous constraint
04:15:08 <elad`> So, hugs is the problem?
04:15:11 <quicksilver> partly
04:15:15 <quicksilver> the other part is your type signature
04:15:20 <quicksilver> you have specified the type signature
04:15:26 <quicksilver> and so it tries to obey
04:15:33 <quicksilver> your type signature says it works for any Ord a
04:15:41 <Mitar> > showFFloat Nothing 1.123
04:15:43 <lambdabot>  <[Char] -> [Char]>
04:15:46 <quicksilver> change that to (Ord a , Num a) =>
04:15:50 <allbery_b> you really want Num a there
04:15:54 <allbery_b> yeh
04:15:58 <Mitar> > showFFloat Nothing 1.123 ""
04:15:59 <lambdabot>  "1.123"
04:16:06 <Mitar> > showFFloat (Just 2) 1.123 ""
04:16:07 <lambdabot>  "1.12"
04:16:08 <allbery_b> @instances Ord
04:16:09 <lambdabot> (), All, Any, Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, Product a, Sum a, [a]
04:16:19 <Mitar> > showGFloat (Just 2) 1.123 ""
04:16:21 <lambdabot>  "1.12"
04:16:29 <Mitar> > showEFloat (Just 2) 1.123 ""
04:16:29 <lambdabot>  "1.12e0"
04:16:35 <elad`> I don't get it. It doesn't work when I specify Num a, it doesn't when I specify Ord a.
04:16:36 <Mitar> what does G do?
04:16:42 <quicksilver> elad`: you need both
04:16:49 <quicksilver> elad`: because, you're using - as well as <
04:16:59 <Botje> Gyde: the tree you wrote should just work if you change it to using pairs, since < is defined for pairs
04:17:03 <allbery_b> G acts like F when it fits, like E when it doesn't
04:17:15 <quicksilver> elad`: or you could just leave out the type signature entirely and see what hugs infers :)
04:17:21 <elad`> What's the syntax for it, and what numbers aren't orderable? Complex ones?
04:17:31 <quicksilver> elad`: (Ord a , Num a ) =>
04:17:33 <mauke> elad`: functions
04:17:43 <Mitar> and what is the default? G?
04:17:43 <quicksilver> elad`: and, yes, of the standard numbers it's the complex ones.
04:17:51 <elad`> Thanks.
04:17:57 <quicksilver> elad`: but you can define more types of numbers if you waqnt :)
04:18:17 <elad`> Naa, thanks, I'm good.
04:19:51 <elad`> Num guarantees subtraction, right?
04:20:07 <byorgey> elad`: yes.
04:20:12 <elad`> What about equality? Does Num guarantee Eq?
04:20:20 <allbery_b> yes
04:20:25 <byorgey> elad`: it... actually does.  unfortunately. =)
04:20:26 <elad`> Thanks.
04:20:32 <elad`> Unfortunately?
04:20:51 <byorgey> well, you can actually imagine numbers which cannot be compared for equality.
04:20:59 <allbery_b> class (Eq a, Show a) => Num a where ...
04:21:05 <mauke> yeah, that sucks
04:21:13 <allbery_b> Double }:>
04:21:22 <quicksilver> it's because of n-patterns
04:21:23 <quicksilver> I suppose
04:21:28 <byorgey> =P
04:21:39 <byorgey> quicksilver: you mean n+k-patterns?
04:21:48 <quicksilver> byorgey: even n patterns desugar to eq
04:21:54 <byorgey> oh, right
04:22:10 <mauke> so?
04:22:15 <quicksilver> f 0 = True -- desugars to f x = (x == fromIntegral 0)
04:22:22 <mauke> just make n patterns require Eq, Num
04:22:23 <Mitar> thanks
04:22:42 <quicksilver> I think it would be cuter to make 0,1,2... genuine constructors
04:22:47 <quicksilver> and permit constructors in typeclasses
04:22:50 <byorgey> :t \0 -> True
04:22:51 <lambdabot> forall t. (Num t) => t -> Bool
04:23:22 <sjanssen> quicksilver: and allow typeclasses with an infinite number of methods?
04:23:37 <quicksilver> sjanssen: well, it would be a special case, obviousl
04:23:49 <mauke> metaclasses!
04:23:51 <quicksilver> sjanssen: we don't generally permit data declarations with an infinite number of constructors, either
04:24:09 <sjanssen> quicksilver: how would I write the source code for a Num instance?
04:24:36 <sjanssen> I think the fromInteger desugaring is much more sane
04:24:46 <quicksilver> sjanssen: not sure, really :)
04:25:22 <quicksilver> sjanssen: it wasn't an entirely serious suggestiong
04:25:39 <quicksilver> although I do think constructors in classes woudl be cute
04:25:59 <sjanssen> yeah, sounds like views
04:27:34 <quicksilver> class Collection a where { Empty :: a .... }
04:27:39 <quicksilver> then you could write
04:27:47 <quicksilver> f Empty = 0
04:27:49 <quicksilver> and infer
04:27:54 <quicksilver> f :: Collection a => a -> Int
04:27:57 <quicksilver> well, that kind of thing
04:28:07 <quicksilver> sjanssen: yes, it is like views
04:33:25 <roconnor> I've never seen any interdisciplinary work between geology and psycology.
04:33:49 <ricky_clarkson> shapr[: Excel is calling you.
04:34:04 <EvilTerran> @remember roconnor I've never seen any interdisciplinary work between geology and psycology.
04:34:05 <lambdabot> Good to know.
04:34:08 <EvilTerran> @yow
04:34:09 <lambdabot> I appoint you ambassador to Fantasy Island!!!
04:36:09 <elad`> Is there some library function for checking that all elements in a list are equal?
04:36:34 <quicksilver> yup
04:36:35 <quicksilver> ==
04:36:35 <quicksilver> ;)
04:36:43 <quicksilver> > [1,2,3,4] == [1,2,3,4]
04:36:45 <lambdabot>  True
04:36:55 <elad`> No, not two lists, one list.
04:36:58 <quicksilver> oh
04:37:02 <yitz> null.tail.group
04:37:06 <elad`> [4,4,4,4] would be mapped to True, [1,2,3] to Fals.e
04:37:25 <mauke> > (null . drop 1 . nub) [4,4,4,4]
04:37:25 <lambdabot>  True
04:37:29 <yitz> > null.tail$group[4,4,4,4]
04:37:29 <lambdabot>  True
04:37:31 <roconnor> > null . tail . group $ []
04:37:32 <lambdabot>  Exception: Prelude.tail: empty list
04:37:37 <mauke> > (null . drop 1 . nub) []
04:37:37 <lambdabot>  True
04:37:40 <yitz> ok,ok
04:37:40 <mauke> > (null . drop 1 . nub) [1 ..]
04:37:41 <lambdabot>  False
04:37:47 <quicksilver> elad`: you have to decide what answer you want for the empty list
04:37:52 <yitz> > null.drop 1$group[4,4,4,4]
04:37:53 <lambdabot>  True
04:37:54 <quicksilver> elad`: but otherwise, yes.
04:38:06 <roconnor> quicksilver: obviously the answer is true.
04:38:10 <yitz> nub is best avoided
04:38:17 <elad`> Sorry?
04:38:30 <quicksilver> roconnor: that does seem the natural answer, yes
04:38:35 <quicksilver> elad`: 'group' is the key part
04:38:37 <roconnor> \x -> and (zipWith (==) x (tail x))
04:38:46 <mauke> yitz: why?
04:38:52 <quicksilver> elad`: 'group' groups up consecutive elements
04:38:54 <yitz> it's O(n^2)
04:39:13 <roconnor> @pl \x -> and (zipWith (==) x (tail x))
04:39:13 <lambdabot> and . ap (zipWith (==)) tail
04:39:15 <mauke> ah, but we don't need the entire result list
04:39:20 <mauke> only the first 2 elements
04:39:21 <quicksilver> yitz: it's O(n*m) where n = num items and m = num different items
04:39:31 <quicksilver> yitz: and that's only if you demand the whole list :)
04:39:35 <roconnor> > and . ap (zipWith (==)) tail $ []
04:39:36 <lambdabot>  True
04:39:39 <roconnor> > and . ap (zipWith (==)) tail $ [1]
04:39:40 <lambdabot>  True
04:39:42 <roconnor> > and . ap (zipWith (==)) tail $ [1,1]
04:39:43 <lambdabot>  True
04:39:45 <roconnor> > and . ap (zipWith (==)) tail $ [1,2]
04:39:45 <lambdabot>  False
04:40:01 <mauke> > and . ap (zipWith (==)) tail $ [1 ..]
04:40:02 <lambdabot>  False
04:40:12 <jre2> is there a good way to reduce "r <- get radius ; mkCircle r" through some syntactic suggar to something more like "mkCircle #radius"?  or is a messy solution such as a preproccessor macro the only real option?
04:40:26 <yitz> quicksilver: ok, that's more detailed. The bottom line is - don't use it unless you know in advance that won't need to do too many comparisons.
04:40:35 <mauke> get radius >>= mkCircle
04:40:54 <mauke> mkCircle =<< get radius
04:41:20 <mauke> a # b = a =<< get b
04:41:43 <roconnor> what is get in get radius?
04:41:58 <quicksilver> jre2: mkCircle =<< get radius, I would normally write.
04:42:07 <quicksilver> roconnor: openGL StateVar, I bet
04:42:23 <quicksilver> roconnor: which is a typeclass around IORef-like things.
04:42:57 <roconnor> oh
04:43:26 <quicksilver> get == readIORef, in the IORef case.
04:43:43 <jre2> it pops up in most state monads
04:44:53 <roconnor> quicksilver: Okay. I'm used to get being get ;)
04:44:56 <roconnor> @type get
04:44:57 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
04:45:02 <quicksilver> yeah
04:45:12 <quicksilver> I think Sven wrote StateVar before the MTL was standard.
04:45:14 <quicksilver> I"m not sure.
04:45:33 <quicksilver> I realised from context it couldn't be that get, though
04:45:38 <quicksilver> although it looks a little like 'gets'
04:45:40 <quicksilver> :t gets
04:45:41 <lambdabot> forall s a (m :: * -> *). (MonadState s m) => (s -> a) -> m a
04:45:49 <roconnor> wow
04:45:54 <roconnor> that looks like a useful function
04:46:07 <roconnor> @src gets
04:46:08 <lambdabot> Source not found. Are you on drugs?
04:46:12 <roconnor> :)
04:46:35 <mauke> gets f = liftM f get
04:46:38 <quicksilver> gets f = f `fmap` get
04:46:57 <mauke> :t asks
04:46:58 <lambdabot> forall r a (m :: * -> *). (MonadReader r m) => (r -> a) -> m a
04:47:20 <roconnor> I should use these more often
04:47:34 <yitz> gets f = get >>= return . f
04:47:57 <mauke> yitz: >>= return . better written as liftM
04:48:07 <yitz> sometimes
04:48:24 <quicksilver> even better written as `fmap`
04:48:29 <quicksilver> and even better still, as <$>
04:48:36 <opqdonut> :)
04:48:36 <mauke> no, fmap requires Functor
04:48:37 <yitz> Here it's better written as "get" :). We're just explaining.
04:48:51 <mauke> and apparently parts of the MTL aren't Applicative
04:48:59 <quicksilver> <$> is not Applicative.
04:49:07 <quicksilver> and requiring Functor is no hardship.
04:49:59 <mauke> > asks ($) (asks show) (asks sqrt 2)
04:50:00 <lambdabot>  "1.4142135623730951"
04:50:32 <opqdonut> :t asks
04:50:32 <lambdabot> forall r a (m :: * -> *). (MonadReader r m) => (r -> a) -> m a
04:51:13 <mauke> asks f = liftM f ask where liftM = (.); ask = id
04:56:57 <dmhouse> Doesn't GHC come with network and mtl any more?
04:57:46 <pejo> dmhouse, it probably depends on your distribution.
04:58:42 <dmhouse> pejo: I downloaded GHC from haskell.org/ghc. Trying to compile a package states "At least the following dependencies are missing: network -any, mtl -any"
04:59:39 <mauke> dmhouse: the source?
04:59:44 <dmhouse> mauke: right.
05:00:00 <mauke> did you get the extralibs?
05:00:28 <dmhouse> Oh, sorry, that was stupid of me.
05:05:08 <moldy> hi
05:05:37 <roconnor> hi
05:13:26 <jre2> how can I / is it possible to define mixfix functions in haskell? ie "if_then_else_(b,e1,e2) = ..." a la Maude
05:13:54 <roconnor> jre2: mixfix?
05:14:37 <roconnor> like a ? b : c  stuff?
05:14:41 <jre2> yea
05:14:48 <roconnor> you can't directly
05:14:51 <sjanssen> jre2: there are some tricks with multiple operators and precedence
05:14:54 <roconnor> but you can use higher order functions
05:15:45 <roconnor> f <$> x <*> y is kinda like a ternary version of liftM2
05:15:58 <roconnor> it's just that the intermediate terms are well typed
05:16:10 <roconnor> so really it is two infix operators
05:17:02 <jre2> roconnor: I'm currently trying to get something like render_as_ ie "render myPointList as Polygon"
05:17:30 <jre2> but obviously making an infix "as" operator would quickly lead to naming conflicts
05:18:00 <roconnor> as isn't a reservered word as far as I know.
05:18:11 <sjanssen> myPointList `renderedAs` Polygon
05:19:20 <jre2> sjanssen: sure, I just mean in general
05:20:02 <roconnor> jre2: there is no general way that I know, but it can often be solved on a case by case basis.
05:20:08 <jre2> like move_to_withFormation_ for move unitList to (x,y) withFormation FlyingV
05:20:32 <roconnor> jre2: render myPointList `as` Polygon  where as = id
05:20:51 <jre2> hah
05:22:03 <roconnor> or maybe as = flip id
05:22:11 <ertai> Does anyone use Yi here?
05:22:17 <roconnor> it all depends on the details of how you make things work.
05:22:37 <roconnor> maybe you have a general polygon function that takes something and draws it as a polygon.
05:26:19 <ivanm> has anyone successfully followed the instructions at http://blog.bytelabs.org/ to get darcs-1.1.0_pre1 to compile with ghc 6.8.1 ?
05:26:20 <lambdabot> Title: blog@bytelabs
05:27:13 <mauke> ghc-6.8.1? that's so yesterday
05:27:46 <ivanm> mauke: heh... ok, make that ghc 6.8.*
05:27:54 <ivanm> happy now? :p
05:28:08 * ivanm is going to bootstrap 6.8.2 tonight
05:29:01 <profmakx> why bootstrap ;)
05:29:26 * profmakx will try getting that darned ghci to run tonight
05:29:28 <ivanm> profmakx: because I'm going to make the x86 binary for Gentoo...
05:29:39 <opqdonut> wow
05:32:25 <profmakx> I was astonished how fast 6.8.2 built for me yesterday
05:33:26 <therp> choosing haskell to interface with databases as _wrong_.
05:33:55 <gbacon> ghc-6.8.1: even the compiler builds faster!
05:33:57 <chessguy> so i'm getting a python cookbook tonight (for free), and planning on translating the examples to haskell, for practice. anyone done anything like this?
05:34:05 <therp> with sqlite I get a parse error at the end of the table, and with mysql it doesn't work at all..
05:35:35 <profmakx> well gbacon, i think it was due to the fact that i bootstrapped 6.8.1 from c-files etc for freebsd7 and that took awfully long
05:36:07 <gbacon> profmakx: what's the harm in a little empty sloganeering? :-)
05:37:35 <profmakx> yeah. the only thing that I really would like to have working is ghci :)
05:41:41 <chessguy> > unwords . reverse . words $ "the quick brown fox jumped over the lazy brown dog"
05:41:43 <lambdabot>  "dog brown lazy the over jumped fox brown quick the"
05:43:17 <dmhouse> > let s = "the quick brown fox jumped over the lazy brown dog" in all (`elem` s) ['a'..'z']
05:43:18 <lambdabot>  False
05:43:51 <dmhouse> > let s = "the quick brown fox jumped over the lazy dog" in dropWhile (`elem` s) ['a'..'z']
05:43:52 <lambdabot>  "stuvwxyz"
05:44:17 <dmhouse> > let s = "the quick brown fox jumps over the lazy dog" in all (`elem` s) ['a'..'z']
05:44:18 <lambdabot>  True
05:44:28 <chessguy> oh, lazy red dog
05:44:34 <chessguy> err
05:44:59 <EvilTerran> jumps, not jumped
05:45:03 <dmhouse> > let s = "jackdaws love my big sphinx of quartz" in all (`elem` s) ['a'..'z']
05:45:04 <lambdabot>  True
05:45:20 <chessguy> @all-dict jackdaw
05:45:35 <EvilTerran> it's a bird
05:45:40 <lambdabot> Plugin `dict' failed with: thread killed
05:45:47 * chessguy kicks the bot
05:46:20 <SamB_XP> wow. my chemistry teacher just sent out an email about her dog...
05:46:28 <dmhouse> > let s = "djs flock by when mtv ax quiz prog" in all (`elem` s) ['a'..'z']
05:46:29 <lambdabot>  True
05:46:31 <chessguy> is it lazy?
05:46:44 <dmhouse> chessguy: no, but it is nonstrict.
05:46:57 * chessguy SO set you up for that :)
05:47:01 <dmhouse> :)
05:47:26 <EvilTerran> > sort "djs flock by when mtv ax quiz prog"
05:47:27 <lambdabot>  "       abcdefghijklmnoopqrstuvwxyz"
05:47:39 <EvilTerran> > sort "jackdaws love my big sphinx of quartz"
05:47:39 <lambdabot>  "      aaabcdefghiijklmnoopqrsstuvwxyz"
05:48:05 <dmhouse> > let s = map toLower "Quartz jock vends BMW glyph fix." in (all (`elem` s) ['a'..'z'], length $ filter isAlpha s)
05:48:08 <lambdabot>  (True,26)
05:48:25 <EvilTerran> oh, come now. that's barely a sentence
05:48:55 <dmhouse> They get even worse if you disallow abbreviations.
05:49:19 <gbacon> when the heck is Ubuntu getting a ghc-6.8 package?
05:49:24 <therp> grrr.
05:49:25 <dmhouse> > let s = map toLower "Squdgy fez, blank jimp crwth vox!" in (all (`elem` s) ['a'..'z'], length $ filter isAlpha s) -- A short brimless felt hat barely blocks out the sound of a Celtic violin. - created by Claude Shannon
05:49:26 <lambdabot>  (True,26)
05:49:50 <therp> therp's thesis number one: improve haskell's error reporting capabilities or haskell will die in the long run
05:50:13 <dmhouse> therp: real programmers don't make mistakes.
05:50:24 <quicksilver> therp: die? surely not.
05:50:32 <quicksilver> therp: not acheive world domination, perhaps.
05:50:32 <chessguy> @type \x y -> all (elem y) x
05:50:33 <lambdabot> forall a. (Eq a) => [[a]] -> a -> Bool
05:50:42 <therp> dmhouse: but external datasets do.. "Exception: Prelude.read: no parse" isn't helpful at all
05:50:56 <tetha> indeed, real programmers just create a different program. only heathens call that "making mistakes"
05:51:01 <chessguy> @type elem
05:51:02 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
05:51:20 <chessguy> @type \x y -> all (`elem` y) x
05:51:21 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
05:51:31 <dmhouse> Who wants Haskell to achieve world domination? Not I.
05:51:32 <chessguy> @pl \x y -> all (`elem` y) x
05:51:33 <lambdabot> flip (all . flip elem)
05:51:43 <gbacon> @botsnack
05:51:43 <lambdabot> :)
05:51:50 <chessguy> @pl \y x -> all (`elem` y) x
05:51:50 <lambdabot> all . flip elem
05:53:04 <chessguy> @type (flip elem) "foo"
05:53:06 <lambdabot> Char -> Bool
05:53:30 <Philippa> therp: so don't use read
05:53:44 <Saizan> it's probably the library
05:54:06 <Saizan> read should be banished from "production" code
05:54:44 <gbacon> saizan: so if you're reading integers from a file, how should they be converted?
05:54:57 <therp> philippa: ah ok, and how do I apply that to HaskellDB?
05:55:04 <EvilTerran> ?type readInt
05:55:08 <lambdabot> forall a. (Num a) => a -> (Char -> Bool) -> (Char -> Int) -> String -> [(a, String)]
05:55:13 <mauke> :t reads
05:55:13 <EvilTerran> ?type readDec
05:55:13 <lambdabot> forall a. (Read a) => String -> [(a, String)]
05:55:14 <lambdabot> forall a. (Num a) => String -> [(a, String)]
05:55:18 <Philippa> therp: mail the maintainer asking them to fix it
05:55:23 <EvilTerran> ?type readHex
05:55:23 <lambdabot> forall a. (Num a) => String -> [(a, String)]
05:55:24 <EvilTerran> etc
05:55:46 <Saizan> gbacon: seen the answers? :)
05:55:47 <therp> philippa: I don't think that will match my objective to finish this analysis by tomorrow 13h CET.
05:55:53 <gbacon> > readDec "123"
05:55:54 <lambdabot>  [(123,"")]
05:56:16 <Philippa> therp: this isn't my problem, thankfully. In the meantime, where's the data coming from?
05:56:33 <gbacon> > readDec "  123"
05:56:34 <lambdabot>  []
05:56:39 <therp> philippa: but it's mine :) and that's the topic for the moment.
05:57:31 <Saizan> > read "   123" :: [(Integer,String)]
05:57:32 <lambdabot>  Exception: Prelude.read: no parse
05:57:35 <Saizan> > reads "   123" :: [(Integer,String)]
05:57:35 <lambdabot>  [(123,"")]
05:58:29 <Philippa> therp: I notice you're not responding to the request for info that might allow someone to actually help you
05:58:42 <gbacon> therp: are you using ghc?
05:59:00 <gbacon> http://cgi.cse.unsw.edu.au/~dons/blog/2007/11/14#no-exceptions
05:59:01 <lambdabot> Title: Haskell hacking
05:59:16 <Philippa> point, GHCi's debugger might be a way to track down where the dodgy data's coming from
05:59:58 <therp> philippa: the point is not about guessing, the point is that Haskell error messages are in general incredibly bad (e.g. Prelude.read). Fortunately I'm quite good at guessing but sometimes I do need help, and whenever that happens I regret the choice "Language=Haskell".
05:59:59 <gbacon> > reads " abc 123 "
06:00:00 <lambdabot>  []
06:00:21 <gbacon> > reads " abc 123 " :: [(String,String)]
06:00:22 <lambdabot>  []
06:00:44 <therp> gbacon: that sounds nice, I'm even using ghci
06:00:50 <therp> gbacon: thanks for the pointer
06:00:55 <gbacon> therp: np
06:01:09 <mauke> > reads " \"abc\" 123 " :: [(String,String)]
06:01:10 <lambdabot>  [("abc"," 123 ")]
06:01:19 <gbacon> mauke: oops, thanks
06:01:27 <mauke> > shows "abc" " 123 "
06:01:28 <lambdabot>  "\"abc\" 123 "
06:01:40 <gbacon> :t shows
06:01:40 <lambdabot> forall a. (Show a) => a -> String -> String
06:02:37 <gbacon> therp: this seems like a library issue, though, not a Haskell issue
06:02:41 <Philippa> quite
06:02:52 <therp> gbacon: true
06:02:56 <Philippa> if you use a compiled language, you can't expect a stack trace every time
06:03:08 <gbacon> I can write a library in any language that allows exceptions to leak
06:03:27 <Philippa> and oh, wait, did I point out that the problem was HaskellDB using read inappropriately? Looks like I did
06:04:33 <gbacon> easy, Philippa :-)
06:05:27 <jimstutt> gbacon: the generic linux 6.8.1 tarball installed fine on gutsy 7.10
06:05:32 <mauke> C++ error messages are even better
06:05:36 <mauke> Aborted
06:06:33 <Philippa> ...must not submit "core dump" lambdacat
06:07:07 <jimstutt> elem('a') in "abad"
06:08:01 <gbacon> jimstutt: I'm sure it does, but that also means building hackage libraries by hand
06:10:36 <BMeph> Ah, the joys of self-updating operating systems... ;p
06:11:55 <jimstutt> gbacon: don't I just know it ;)
06:16:35 <jedbrown> building 6.8.2 docs with 6.8.1, I get `Setup: Haddock's internal GHC version must match the configured GHC version'.  Anyone know how to recover?
06:18:35 <dcoutts> jedbrown: use haddock build with ghc-6.8.2
06:19:03 <dcoutts> jedbrown: oh, no other way around, except that the latter is not possible
06:19:13 <dcoutts> since haddock-2.x needs ghc-6.8.2
06:19:40 <jedbrown> dcoutts: Okay, thanks.
06:19:41 <quicksilver> jedbrown: you have to build ghc-6.8.2 first, before you can build ghc-6.8.2 docs. I believe.
06:19:41 <dcoutts> so you'd have to build the 6.8.2 docs using 6.8.2
06:19:59 <dcoutts> or use haddock 0.9
06:20:17 <Saizan> dcoutts: sure? i've built haddock 2.0 from darcs with 6.8.1 a few days ago
06:20:48 <dcoutts> Saizan: that's what I heard, that haddock 2.x could not be released until 6.8.2 was out due to deps
06:20:54 <dcoutts> Saizan: ask waern
06:21:12 <Saizan> ah, ok
06:25:54 <Saizan> GHCi now treats all input as unicode, except for the Windows console where we do the correct conversion from the current code page. <-- so no more truncating at 8-bit ?
06:26:29 <sjanssen> presumably for GHCI only
06:27:42 <dcoutts> Saizan: it means string literals in ghci are unicode
06:27:54 <dcoutts> putStr etc are all 8-bit truncating
06:28:42 <dcoutts> sjanssen: ghc (not ghci) already treats everything as unicode, so this was just the same treatment for ghci's interactive input
06:28:45 <Saizan> ah, right, didn't pay attention to 'i'
06:30:43 <quicksilver> dcoutts: also means you can let-bind unicode symbols at the prompt, I image
06:30:48 <quicksilver> dcoutts: so not just string lits
06:30:53 <quicksilver> (or could you always do that?)
06:31:25 <dmhouse> Prelude> let hllo = 4
06:31:25 <dmhouse> Prelude> hllo
06:31:25 <dmhouse> 4
06:31:35 <dmhouse> That's pretty cool.
06:31:45 <Taejo> is it possible to define a type for k-ary trees for arbitrary k?
06:31:46 <Lemmih> Does it use iconv?
06:32:04 <quicksilver> Taejo: yes, but you'd represent them as lists
06:32:21 <Taejo> quicksilver: no way to enforce the k-ary-ness?
06:32:22 <dmhouse> Hrm. Doesn't seem to work with all Unicode:
06:32:23 <dmhouse> Prelude> let  = undefined in const 4 
06:32:23 <dmhouse> <interactive>:1:4: parse error on input `'
06:32:35 <quicksilver> Taejo: well you enforce it by abstraction
06:32:47 <quicksilver> Taejo: ensure that all your functions guarantee the invariants
06:32:51 <quicksilver> and don't export the constructor
06:32:55 <Taejo> ok
06:33:06 <quicksilver> but yes, there are static ways to enforce ti too
06:33:10 <quicksilver> you wouldn't enjoy them :)
06:33:14 <Taejo> olegness?
06:33:48 <quicksilver> Branch (Succ (Succ (Succ Zero))) (Cons "a" (Cons "b" (Cons "c" Nil)))
06:33:52 <quicksilver> kind of thing
06:33:55 <quicksilver> not much fun :)
06:36:37 <sjanssen> > let + = undefined in const 4 +
06:36:37 <lambdabot>  Parse error at "+" (column 5)
06:37:05 <SamB_XP> quicksilver: wouldn't arrays be more efficient?
06:37:07 * quicksilver peers at sjanssen suspiciously
06:37:15 <sjanssen> dmhouse: ^^^, your character isn't a lower-case alphabetic character
06:37:22 <dmhouse> sjanssen: ah, good point.
06:37:23 <dmhouse> Prelude> let () = undefined in const 4 ()
06:37:23 <dmhouse> 4
06:37:31 <quicksilver> ah
06:37:38 * quicksilver understand sjanssen 
06:37:44 <SamB_XP> quicksilver: for sufficiently large k, anyway
06:37:47 <SamB_XP> ?
06:37:47 <quicksilver> SamB_XP: sure. maybe. depends what the constraints are.
06:37:59 <Taejo> @src tail
06:37:59 <lambdabot> tail (_:xs) = xs
06:37:59 <lambdabot> tail []     = undefined
06:38:08 <quicksilver> arrays do a lot of copying when you change only one element
06:38:17 <quicksilver> if that's a common operation than Data.Sequence will be faster.
06:38:34 <SamB_XP> quicksilver: true, but you mentioned lists, not data.sequence
06:38:54 <Sizur> @hoogle Enum a => a -> [a]
06:38:55 <lambdabot> Prelude.enumFrom :: Enum a => a -> [a]
06:38:55 <lambdabot> Prelude.repeat :: a -> [a]
06:38:55 <lambdabot> Data.List.repeat :: a -> [a]
06:38:56 <SamB_XP> and I think lists do about as much copying as arrays, on average, for sufficiently hi k...
06:39:23 <quicksilver> SamB_XP: and you mentioned arrays, not data.sequence :)
06:39:33 <quicksilver> SamB_XP: it was a case of point/counterpoint
06:39:35 <quicksilver> ;)
06:39:59 <SamB_XP> quicksilver: yes, I'll admit that data.sequence could be better than both
06:40:16 <SamB_XP> depending on usage
06:40:19 <quicksilver> k-ary trees for arbitrary k is a fairly unusual requirement, I think
06:40:29 <SamB_XP> yes, probably
06:40:42 <dmhouse> *Sigh* anyone compiled HaXml successfully recently?
06:40:59 <SamB_XP> istr seeing up-to-k-ary trees in knuth somewhere...
06:41:10 <malcolmw> dmhouse: I think I got it compiled yesterday
06:41:18 <earthy> dmhouse: Martijn Schrage tends to compile it a lot
06:41:21 <hpaste>  dmhouse pasted "HaXml build errors" at http://hpaste.org/4431
06:42:09 <dmhouse> I'm getting those errors when I try to build it.
06:42:32 <dmhouse> Gah, it was truncated.
06:42:38 <quicksilver> dmhouse: I think you hit the 5k limit ;)
06:42:43 <quicksilver> I see only successes, so far
06:42:58 <vininim> @hoogle (<$>)
06:42:59 <lambdabot> Did you mean: (<$>)
06:42:59 <lambdabot> Prelude.undefined :: a
06:42:59 <lambdabot> Control.Monad.State.Class.get :: MonadState s m => m s
06:43:20 * SamB_XP still wants to know how knuth is supposed to have set computer science back a decade or two...
06:43:25 <vininim> mmm not hoogle...
06:43:30 <hpaste>  dmhouse annotated "HaXml build errors" with "Actual errors" at http://hpaste.org/4431#a1
06:43:36 <int-e> dmhouse: use cabal?
06:43:55 <earthy> ghe. a.out. ghe.
06:43:56 <malcolmw> dmhouse: using "configure; make; make install" is not really supported for HaXml with ghc since 6.6
06:44:12 <dmhouse> malcolmw: oh, that's what the README says still.
06:44:18 <malcolmw> dmhouse: use cabal instead  is the general advice
06:44:32 <quicksilver> SamB_XP: sounds like sour grapes / it's fun to pick holes in famous people, to me
06:45:44 <SamB_XP> quicksilver: I bet there's more to the idea than that
06:46:00 <dmhouse> malcolmw: are you the maintainer?
06:46:07 <malcolmw> dmhouse: yes
06:46:08 <SamB_XP> perhaps bitterness about the semantics of TeX
06:46:17 <dmhouse> malcolmw: with 6.8.2 I think you also need to add 'pretty' to required-modules.
06:46:33 <dmhouse> (I.e., it didn't compile until I did so.)
06:46:47 <dmhouse> Err, sorry, I mean build-depends
06:46:49 <malcolmw> dmhouse: probably.  I haven't installed any 6.8 versions of ghc yet, so have not updated any packages for that
06:47:34 <dmhouse> malcolmw: and containers. Shall I throw together a patch?
06:47:45 <dylan> hehehe
06:47:48 <dylan> 09:47 <cladhaire> I'm the one person here who hangs out in #lua instead of #haskell ;-)
06:48:31 <malcolmw> dmhouse: well, the 1.13 branch isn't really stored in a version control system any more.
06:48:47 <dmhouse> How peculiar. Why not?
06:49:36 <malcolmw> dmhouse: 1.13 was released at the point that I switched from CVS to darcs.  I never expected to return to it, to keep a stable branch alive.
06:50:29 <malcolmw> dmhouse: so there is no tag in either CVS or darcs, telling me exactly what patches were included in 1.13 I'm afraid.
06:50:58 <dmhouse> ?where hlist
06:50:59 <lambdabot> http://homepages.cwi.nl/~ralf/HList
06:51:01 <dmhouse> malcolmw: hmm, okay.
06:51:31 <malcolmw> dmhouse: the development version is now at 1.19
06:51:54 <dmhouse> malcolmw: when will it become stable?
06:53:04 <malcolmw> dmhouse: I don't know.  Could be soonish, depending on whether I think there are any more API-breaking changes to be added.
06:53:06 <dcoutts> dmhouse: have you tried haxml-1.13.3 that malcolmw uploaded the other day?
06:53:17 <jimstutt> dmhouse: HaXml-1.13.3. build ok on 6.8.1 with cabal. Maybe had to add container to build depends.
06:53:37 <dmhouse> dcoutts: I just downloaded the latest stable version listed on http://www.cs.york.ac.uk/fp/HaXml/
06:53:42 <lambdabot> Title: HaXml: Haskell and XML
06:54:09 <dcoutts> dmhouse: try the latest from hackage
06:54:20 <dmhouse> malcolmw: by the way, the 'Downloads' link at the top of that page doesn't work. The anchor should be #downloads instead of #download I think.
06:54:33 <dcoutts> dmhouse: oh, that should be the same
06:55:04 <dcoutts> dmhouse: the 1.13.3 release on hackage includes the deps on pretty and containers
06:55:08 <dcoutts> http://hackage.haskell.org/packages/archive/HaXml/1.13.3/HaXml.cabal
06:55:11 <Sizur> what is a TupleT? how can i construct a type (a,b) in TH?
06:55:26 <dmhouse> dcoutts: hmm, okay, well the version I downloaded seemed not to.
06:57:48 <Saizan> Sizur: guessing: AppT (AppT (TupleT 2) (VarT $ mkName "a")) (VarT $ mkName "b")
06:58:07 <malcolmw> dmhouse: your hpaste definitely says 1.13.2, whilst the download page you mentioned definitely says 1.13.3
06:58:50 <dmhouse> malcolmw: ah, it seems I have both versions and probably jumped into the wrong directory. Sorry.
06:59:01 <dmhouse> malcolmw: are there many other differences between the versions?
06:59:21 <malcolmw> dmhouse: the only diff was to enable it to build with recent ghc
07:00:11 <dmhouse> malcolmw: changing the cabal file, you mean?
07:00:14 <Sizur> Saizan: aha, thanks, that must be it
07:00:31 <malcolmw> (I'd forgotten that igloo already supplied me with the patch for that, leading to 1.13.3)  If I'd remembered, I might have noticed the 1.13.2 version thing.
07:01:28 <Sizur> Saizan: hmm, what would that look like for a (a,b,c)?
07:03:47 <ski> TupleT 3 `AppT` (VarT $ mkName "a") `AppT` (VarT $ mkName "b") `AppT` (VarT $ mkName "c")  -- ?
07:04:38 <dmhouse> Okay, next question :) Anyone successfully built HAppS with 6.8.2?
07:06:19 <dmhouse> After adding a bunch of deps to build-depends, it says it can't find "Data.ByteString.Base".
07:06:30 <dmhouse> Has this module been removed from the bytestring package?
07:06:32 <quicksilver> that has been renamed to Internal
07:06:38 <dcoutts> dmhouse: it got split into two
07:06:46 <quicksilver> although I suspect that may not be the only thiing you have to change...
07:06:51 <dcoutts> .Unsafe for some and .Internal for others
07:06:54 <Sizur> ski: thank you!
07:06:56 <Saizan> dmhouse: which version of HAppS?
07:07:02 <dmhouse> It seems not. 6.8.2 was a big, backward-incompatible change, then.
07:07:32 <dmhouse> Saizan: well I had an old version from darcs sitting around, and I darcs pull'd in that directory, so unless it's changed repository, it should be darcs latest.
07:07:50 <Saizan> dmhouse: heh, changed repositories :)
07:08:10 <ski> Sizur : just guessing .. never used TH ;)
07:08:20 <Sizur> lol
07:08:26 <Sizur> impressive
07:08:48 <Saizan> dmhouse: 0.9.1 is the latest, with several api changes but compiles with 6.8.*
07:08:56 <Igloo> dmhouse: 6.8.1 doesn't have Data.ByteString.Base either
07:08:57 <dmhouse> Woah, I have to do _how many_ darcs checkouts to get HAppS?
07:09:03 * ski tries to recall the defaul associativity of infix operators ..
07:09:08 <gwern> 'First-class functions are the power of Grayskull'
07:09:20 <gwern> dmhouse: around 6 I think
07:09:23 <ski> gwern ?
07:09:32 <dmhouse> Igloo: Okay, 6.8 was a big, backward-incompatible change. I know it should be expected to be, but it's just struck me, that's all.
07:09:39 <gwern> ski: a quote from http://technically.us/code/x/the-awesomeness-of-scala-is-implicit
07:09:39 <lambdabot> Title: Coderspiel / The awesomeness of Scala is implicit
07:09:44 <dmhouse> Igloo: you know how frustrating chasing Haskell dependencies is :)
07:10:05 <dmhouse> gwern: what an awful system.
07:10:15 <Taejo> Don't you love it when the O(N logN) algorithm is easier to code than the O(N^2) one?
07:10:21 * gwern thinks it's supposed to encourage modularity or something
07:10:32 <Saizan> dmhouse: a list of the repos is here http://happs.org/HAppS-Begin/public/index.html
07:11:27 <dmhouse> Yeah, there's a list on http://happs.org, too, but it's still a silly way of doing things.
07:12:06 <dmhouse> You've got to do _six_ different pulls and builds. Then when a new version comes out, you have to do it _all over again_.
07:12:09 <gwern> maybe they should go with the ghc approach; provide a meta-repo if you will with a script in't that pulls all the others
07:12:20 <dmhouse> For goodness' sake, all I want to do is install hpase.
07:12:23 <dmhouse> *hpaste.
07:12:30 <gwern> dmhouse: shell scripts! for all in *; do cd $all && haskell; done...
07:12:41 <Saizan> dmhouse: hah, then you don't want 0.9.1
07:13:00 <dmhouse> Saizan: well I want the latest version anyway for playing around with. But they're not compatible?
07:13:02 <shag> someone knows the module/name of Data.Function.on in GHC 6.6.1?
07:13:51 <Saizan> dmhouse: no, i had ported it to a version of 0.9.1 but then the api changed again
07:14:04 <Saizan> it = hpaste
07:14:09 <quicksilver> shag: it's not there.
07:14:15 <quicksilver> shag: not hard to define, though.
07:14:22 <dmhouse> Bloody hell.
07:14:23 <shag> ok, thanks
07:14:48 <quicksilver> (f `on` g) x y = g x `f` g y
07:15:48 <Saizan> dmhouse: i can give you a link to my repo if it would be of any help
07:16:52 <dmhouse> So if I wanted to install hpaste right now, what would the best approach be?
07:17:44 <Saizan> i think removing the dep on Data.ByteString.Base from 0.8.8
07:18:18 <dmhouse> Right, but that involves rewriting part of hpaste, so is nontrivial, right?
07:18:37 <Lemmih> Use ghc-6.6?
07:18:48 <Saizan> hpaste should compile as it is on 0.8.8
07:20:05 <Saizan> and in happs .Base is used only for some packAddress "foo"# iirc, so you can substitute that safely with .Char8.pack "foo"
07:20:25 <Sizur> > let g n = foldl AppT (TupleT (length n)) (map (VarT . mkName . (:[])) n) in g  "abc"
07:20:27 <lambdabot>   Not in scope: `mkName'
07:21:34 <dmhouse> Saizan: diving through the source changing stuff sounds like more trouble than it's worth. The reason I want a local hpaste is so that I can test my Emacs integration, hpaste.el, without worrying about spamming the hpaste.org server. But perhaps I'll just be careful about how many pastes I use when testing.
07:22:19 <quicksilver> Saizan: (premature optimization)--
07:22:20 <Saizan> fine :)
07:23:33 <Saizan> quicksilver: it seems like that, yes
07:23:44 <dmhouse> Saizan: thanks for you help anyway.
07:26:35 <ski> @type curry (curry . uncurry (.) . (uncurry *** join (***)))
07:26:36 <lambdabot> forall c b c1. (c1 -> c1 -> c) -> (b -> c1) -> b -> b -> c
07:26:38 <ski> @type curry (curry . uncurry (.) . (uncurry *** (uncurry (***) . (id &&& id))))
07:26:39 <lambdabot> forall c b c1. (c1 -> c1 -> c) -> (b -> c1) -> b -> b -> c
07:46:47 <dmhouse> byorgey: http://haskell.org/haskellwiki/Hpaste.el
07:47:07 <byorgey> dmhouse: you fixed it?
07:47:12 <dmhouse> byorgey: yep.
07:47:15 <byorgey> nice, thanks =)
07:47:29 <byorgey> OOC, what was the problem?
07:47:40 <dmhouse> The docs for url-retrieve are incorrect, I think.
07:47:54 <byorgey> ah.
07:48:23 <dmhouse> It states "callback is called when the object has been completely retrieved, with the current buffer containing the object, and any MIME headers associated with it.  It is called as (apply callback STATUS cbargs). STATUS is a list with an even number of elements representing what happened during the request, with most recent events first, or an empty list if no events have occurred."
07:48:35 <dmhouse> That's not actually true: the list doesn't have an even length, it's a list of pairs.
07:48:58 <dmhouse> (Of course this kind of error would be trivial to spot in Haskell as you'd get a type mismatch, but ah well.)
07:50:23 <byorgey> heh, indeed...
08:10:23 <roconnor> I give up on programmers
08:11:27 <roconnor> If I hire programmers, I will require that they say PHP's < test is broken when asked.  That will be my interview question.
08:11:57 <quicksilver> that sonuds like knowing too much about PHP, to me
08:12:13 <quicksilver> i'd rather they said they didn't know if PHP had a < function or whether it was broken :)
08:12:16 <roconnor> quicksilver: well, I will describe PHP's < test without mentioning PHP
08:12:21 <roconnor> and ask if it is broken :)
08:12:37 <quicksilver> oh, Isee
08:12:41 <roconnor> or something like that
08:13:19 <roconnor> basically I want to avoid hiring all those types of people on reddit who defend PHP's < and == by saying that it is documented.
08:13:22 <Zao> roconnor: For extra credit, ask them to emulate it in Haskell.
08:13:30 <roconnor> :P
08:13:51 <edwinb> Just add more ====== until it works. Apparently.
08:13:57 <Sizur> "What?!! you've never implemented anamorphic reactive 'less than' function?!!? Nobody will hire you!!! EVER!"
08:14:00 <roconnor> edwinb: does that work for < ?
08:14:02 <roconnor> <<<<<<<<
08:14:06 <edwinb> you never know
08:14:22 <roconnor> with enough <'s, it becomes transitive.
08:14:53 <roconnor> eventually <<<<<<<< compares pointer positions.  ... wonderful for quicksort :P
08:15:11 <edwinb> Clearly what you want is a language where '>' means 'equals'. It's okay if you document it...
08:15:14 <dylan> what does php's < do?
08:15:37 * byorgey was wondering the same thing
08:15:37 <Zao> roconnor: Do you have any relevant links? It's rather hard to google for non-alpha characters.
08:15:42 <Sizur> it's a symbol for a friendly hug in php
08:16:07 <Sizur> or an attempt at arrows implementation
08:16:20 <dylan> seriously, what's it do? don't make me install php to find out! :(
08:16:35 <roconnor> http://zestyping.livejournal.com/233348.html
08:16:36 <lambdabot> Title: zestyping: Why PHP should never be taught, Part II.
08:17:32 <roconnor> for god sake, if you are going to use a dynamically typed langauge, at least allow hetrogenous lists to be sorted.
08:17:41 <edwinb> that is really weird
08:18:16 <roconnor> edwinb: I would fire anyone who defends that.
08:18:46 <roconnor> ``That must make sorting lists and building search trees a real pain.
08:19:10 <edwinb> I wonder if it's deterministic
08:19:13 <roconnor> aaaaaaaaaahhhh
08:19:17 * roconnor head expodes
08:19:54 <mauke> let me try that in perl
08:20:25 <int-e> roconnor: very nice, thanks
08:21:21 <Sizur> reconnor: but... but, you must make sure 3 year olds can create websites!! :( think of the children!
08:21:26 <roconnor> int-e: there are 3 or 4 reddit threads on this
08:21:41 <roconnor> and the arguing is quite intense
08:21:45 <edwinb> I see that someone thinks the solution is not to write stupid code.
08:21:49 <roconnor> but this should be a no-brainer
08:21:50 <edwinb> If only I'd thought of that!
08:21:52 <roconnor> and that upsets me.
08:21:57 * edwinb decides not to write stupid code in future
08:22:39 <roconnor> edwinb: it's true that the raw examples are arguably stupid, but they miss the larger implications.
08:22:42 <mauke> http://rafb.net/p/rGwAjq37.html
08:22:43 <lambdabot> Title: Nopaste - No description
08:22:46 <roconnor> edwinb: no sorted lists
08:22:51 <roconnor> no binary search trees
08:22:59 <roconnor> everything you take for granted is gone.
08:24:27 <doserj> roconnor: isn't mostly a problem of implicit coercion, i.e., weak typing?
08:25:07 <doserj> (although i really don't understand the results for comparison with unassigned e)
08:25:27 <roconnor> doserj: partly
08:25:33 <edwinb> and that apparently it makes sense to coerce between a boolean and an integer...
08:25:37 * edwinb dons his Type Bigot hat
08:26:36 <doserj> edwinb: that has an old tradition :)
08:26:59 <edwinb> well yes
08:28:39 <quicksilver> doserj: undef promotes to False
08:28:52 <quicksilver> doserj: 1 and -1 both promot to True while 0 promotes to False
08:29:09 <quicksilver> doserj: thus undef < -1, undef < 1, but not (undef < 0)
08:29:57 <doserj> quicksilver: yes. next question: why the coercion to Boolean, and not to integer 0?
08:30:13 <tetha> thus: -1 > undef >= 0? heh.
08:30:20 <quicksilver> I believe undef doesn't promote to integer
08:30:24 <quicksilver> but it will to boolean
08:30:39 <doserj> yeah, seems so
08:31:04 * doserj shrugs
08:31:22 * dylan notes comparing undef in perl yields a warning.
08:31:45 <byorgey> > undefined < True
08:31:47 <lambdabot>  Undefined
08:31:47 <Sizur> > undefined > 0
08:31:48 <lambdabot>  Undefined
08:31:52 <byorgey> hooray!
08:31:56 <sclv_> echo ($undefinedvar - 5); gives me -5 in php.
08:31:57 <mrd> sanity is restored
08:32:02 <Zao> It wouldn't surprise me if the semantics could be changed in php.ini :)
08:32:07 <quicksilver> sclv_: Ah. I'm wrong then :)
08:32:20 <sclv_> I think php's general conversion is everything promotes to everything.
08:32:21 <quicksilver> sclv_: clearly it can promote to 0 in some circs.
08:32:28 <quicksilver> I don't use PHP ;)
08:32:59 <mrd> it should promote integers to lists using some kind of Peano representation
08:33:06 <Sizur> > Just undefined
08:33:07 <lambdabot>  Undefined
08:33:16 <mrd> > isJust (Just undefined)
08:33:20 <lambdabot>  True
08:33:27 <Sizur> nice!
08:33:35 <mrd> Maybe is lazy
08:33:49 <Sizur> > listToMaybe [undefined]
08:33:50 <lambdabot>  Undefined
08:34:01 <mrd> > isJust (listToMaybe [undefined])
08:34:02 <lambdabot>  True
08:34:08 <mrd> it's getting stuck on the Show method
08:34:15 <quicksilver> there are circumstances in which 'undefined' in lambdabot does the wrong thing
08:34:21 <Choko_> quicksilver: maybe it promotes to false, and then promotes to 0
08:34:26 <quicksilver> if you tried that in ghci, you'd get
08:34:35 <quicksilver> Just *** Exception: undefined
08:34:38 <quicksilver> which is more intuitive
08:34:49 <quicksilver> the 'show' can get through the Just before it hits the undefinedness
08:34:52 <mrd> lambdabot is a little too strict
08:35:13 <quicksilver> Choko_: yes, plausible :)
08:35:15 <Sizur> yeah, true, it works
08:35:47 <Sizur> however Just Undefined would be better, i think
08:36:24 <Sizur> no it wont
08:37:03 <Sizur> isJust is perfect in this case
08:37:08 <yitz> >  True > -1
08:37:09 <lambdabot>   add an instance declaration for (Num Bool)
08:38:07 <yitz> OK. Presumably I could do that, and get results similar to PHP. The difference is - I am cooking my own soup.
08:38:26 <tetha> and you do that explicit
08:38:42 <Sizur> laziness :: Maybe Virtue
08:39:49 <Sizur> laziness :: IO (Maybe Virtue)
08:41:26 <chessguy> ok, so here's something i've been kicking around
08:41:43 <chessguy> i want to build up a vocabulary, in chess, for talking about chess positions
08:42:05 <sieni> doesn't it already exist?
08:42:08 <chessguy> like, the primitives might be "A1" (which is a particular square on the board), or "white knight"
08:42:21 <chessguy> sieni, maybe you could let me finish...
08:42:29 <sieni> ok
08:42:34 <chessguy> but i want to be able to combine them too
08:42:56 <chessguy> like "a white knight on f7 that's attacking a black rook on D8"
08:43:23 <chessguy> or just "a black king on an edge square", etc.
08:43:42 <Sizur> @users
08:43:43 <lambdabot> Maximum users seen in #haskell: 432, currently: 410 (94.9%), active: 23 (5.6%)
08:43:46 <Syzygy-> "Scaling Everest was, by far, the most amazing and transformative experience of my life. Unfortunately, this is a thesis on context-free grammars."
08:44:03 <sieni> Syzygy-: <3
08:44:13 <chessguy> but i'm not sure how to go about expressing the primitives in a good way to be able to combine them like that
08:44:38 <mux> Syzygy-: heh, great quote, who is it from?
08:44:47 <Syzygy-> mux: http://adamcadre.ac/07lyttle.html
08:44:48 <lambdabot> Title: The 2007 Lyttle Lytton Contest
08:44:52 <mux> thanks
08:45:04 <byorgey> (white knight `on` F7) `attacking` (black rook `on` D8)
08:45:20 <Sizur> data Square = Sq Coords (Maybe Piece)?
08:45:57 <Syzygy-> Oh dear. Is KTH running the "Write a chess program" Haskell course assignement again?
08:46:17 <byorgey> data Position = PP Piece | PR Relationship Position Position
08:46:26 <chessguy> Syzygy-, i've been interested in chess programming for a long time
08:46:32 <Syzygy-> chessguy: Right.
08:46:35 <dons> ?users
08:46:35 <lambdabot> Maximum users seen in #haskell: 432, currently: 410 (94.9%), active: 26 (6.3%)
08:46:36 <Syzygy-> chessguy: That's alright then.
08:46:52 <Syzygy-> There used to be a Haskell part on the KTH course on programming paradigms in Stockholm a while ago.
08:46:55 <byorgey> attacking :: Piece -> Piece -> Position
08:47:06 <chessguy> byorgey, but the thing is, i want the flexibility to be able to specify a square, or not, or a piece color, or not, or a piece type, or not, or.....etc.
08:47:08 <byorgey> chessguy: I'm just making this up =)
08:47:19 <byorgey> chessguy: ok, I see
08:47:20 <Syzygy-> It'd have an infamous HAskell assignement about writing a graphical chess program which tended to make people hate Haskell with a vengeance...
08:48:12 <byorgey> data Position = P (Maybe Square) (Maybe Piece) (Maybe Color)  -- chessguy?
08:48:52 <chessguy> byorgey, also, i want to eventually run this through a pattern matcher, such that, i can say "if the position matches 'a white knight attacking a black pawn', generate all the legal moves for the knight
08:49:06 <moonlite> Syzygy-: are there any obligatory Haskell for Computer Science or Computer Technology on KTH?
08:49:15 <chessguy> which means returning some kind of hook
08:49:21 <chessguy> like clustering in regexes
08:49:46 <chessguy> byorgey, i don't know, i want to be able to make the patterns arbitrarily complex
08:49:51 <byorgey> hm, so data Position = PR Relationship Position Position | P (Maybe Square) (Maybe Piece) (Maybe Color)
08:50:01 <Toxaris> chessguy: sounds like you want Prolog
08:50:02 <Syzygy-> moonlite: Not certain.
08:50:06 <Syzygy-> moonlite: I doubt it.
08:50:23 <Sizur> chessguy: you dont want to have a relationship in your data as it can lead to errors, it must be calculated
08:50:40 <yitz> chessguy: why not the traditional fp approach: start with a simple underlying model, and write functions to get various views of it
08:50:43 <byorgey> then you could match on (PR Attacking (P _ (Just Knight) (Just White)) (P _ (Just Pawn) (Just Black)))
08:50:46 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/4433
08:50:47 <chessguy> Sizur, i'm talking about expressing patterns
08:51:05 <sclv_> maybe PR Relationship Position [Position]?
08:51:12 <moonlite> Syzygy-: ok. Chalmers is quite a special case in sweden then it seems (jag har snart en civilingenjrstitel frn chalmers)
08:51:15 <byorgey> yeah, maybe
08:51:22 <Syzygy-> Yeah.
08:51:29 <sclv_> So your relationships can be more general than just between two positions.
08:51:35 <Syzygy-> Chalmers also has a very much alive haskell research group
08:52:16 <moonlite> Syzygy-: yep, i've met them all (or at least most of them). :)
08:52:30 <moonlite> gotta go
08:52:48 <quicksilver> chessguy: sound more like predicates than positions
08:52:59 <quicksilver> I'd have [Predicate]
08:53:15 <chessguy> quicksilver, yes, they're position templates, not positions
08:53:20 <quicksilver> and data Predicate = Attacking Piece Piece | InPosition Piece Position | ....
08:53:26 <chessguy> but more complex than predicates
08:53:38 <quicksilver> "more complex than a predicate"?
08:53:43 <quicksilver> that sounds pretty mind-blowing :)
08:54:07 <chessguy> like regexes, they should be able to "return" pieces of the template
08:54:10 <quicksilver> surely given a concrete example of a position, your "template" either "applies to this position" or "not"
08:54:47 <Sizur> what about actually using a regex then on a board?
08:55:08 <Sizur> they are polymorphic here
08:55:20 <chessguy> Sizur, i've thought of that, but it gets messy because the board is so 2D
08:57:27 <quicksilver> chessguy: I still think a predicate is the right way to think about it
08:57:35 <Sizur> i dont understand why not have a list of predicated and fliter against them
08:57:39 <quicksilver> and then you could 'capture' the mentioned pieces too
08:57:41 <Sizur> predicates*
08:58:58 * Toxaris wonders if anyone considered his remark about Prolog (except for quicksilver maybe). chessguy seems to talk about a first-order logic language to express chess positions and parts of chess positions, and inference schemes to express relations between various granularities of such positions.
08:59:05 <Sizur> after all predicate algebra is a logic machine
08:59:37 <Sizur> prolog is experiencing some revival recently
08:59:41 <chessguy> Toxaris, i considered it, but i don't know enough about prolog
08:59:56 <chessguy> (to know whether or not you're right about what i'm looking for)
09:00:16 <Sizur> i know a person implementing an ajax wiki server in prolog
09:00:24 <Toxaris> chessguy: I don't mean you should use Prolog instead of Haskell, of course, I'm thinking more in the direction of a Prolog-like EDSL
09:00:35 <chessguy> i assumed as much
09:02:17 <ertai> @index rawSystemProgramStdoutConf
09:02:17 <lambdabot> bzzt
09:02:30 <sclv_> @go "escape from zurg"
09:02:33 <lambdabot> http://web.engr.oregonstate.edu/~erwig/papers/Zurg_JFP04.pdf
09:02:48 <sclv_> simple logic programming in haskell -- maybe too simple?
09:02:59 <chessguy> Toxaris, what are 'inference schemes'?
09:03:10 <Toxaris> chessguy: I'm not sure wether they are really called like that
09:04:17 <dcoutts> ertai: that's from Cabal, you probably don't want to use it directly as you'd end up depending on the Cabal lib
09:04:33 <ertai> dcoutts: thx
09:05:00 <ertai> I search for a way of making a directory in order to fix a Setup.hs
09:05:23 <dcoutts> ertai: is that the dreaded dist/conftest.c bug?
09:05:36 <ertai> I don't think so
09:05:48 <dcoutts> ertai: what are you trying to fix exactly?
09:06:08 <ertai> that's an install function that forget to mkdir the dest dir in Yi
09:06:39 <Toxaris> chessguy: I mean a rule like: position(whiteking, Pos1) && position(Piece, Pos2) && neighbour(Pos1, Pos2) && blackpiece(Piece) ==> atacks(whiteking, Piece), wich can be matched on a particular position and yields values for Pos1, Pos2 and Piece
09:06:58 <dcoutts> ertai: hmm, well the Utils provides a function for recursively creating directories
09:07:34 <ertai> is there a way to list the contents of a module using LB?
09:07:37 <dcoutts> ertai: Distribution.Simple.Utils.createDirectoryIfMissingVerbose
09:07:47 <ertai> dcoutts: thxs
09:07:47 <dcoutts> ertai: no, that'd be too verbose
09:07:58 <Toxaris> chessguy: this seems to be what you want: you want to express facts about a chess position and rules about how to derive new facts from old facts. then you want to apply approbiate rules to your base facts to arrive at the fact what to do as next step
09:08:20 <dons> "6.8.2 produces binaries 7.5% smaller than 6.8.1"
09:08:27 <dons> "Allocations are down a bit on average in 6.8.2"
09:08:34 <ertai> perhaps hpasting it...
09:08:36 <dcoutts> dons: but still 15% bigger than 6.6.1 :-)
09:08:57 <dons> yeah. but is that just spec constr removing constructor code?
09:08:58 <oerjan> ertai: @docs Module.Name should give you a web link
09:09:10 <pejo> dons, where did you find that text?
09:09:41 <dons> pejo: a trac ticket from simonM
09:09:56 <dons> Igloo:   Technical details of temporary failure:
09:09:56 <dons>   TEMP_FAILURE: Could not initiate SMTP conversation with any hosts:
09:09:56 <dons>   [community.haskell.org (1): Connection refused]
09:10:02 <dcoutts> dons: no, there's some bug that they have not fully identified that was making lots of code bigger with 6.8.x. They applied a partial remedy in 6.8.2 but Simon is still looking for the real cause.
09:10:16 <dons> ah, i didn't know about that.
09:10:32 <dons> dcoutts: how's xmonad going with portage? :)
09:10:33 <oerjan> ertai: also, the interpreter :b commands
09:10:38 <dons> i see our competitors are in portage already :(
09:11:04 <dcoutts> dons: might add cabal-1.2.3.0 soon, we've been applying patches to make existing packages not break when we add ghc-6.8 and cabal-1.2
09:11:17 <dons> very good.
09:11:27 <dons> its not in debian yet either, fwiw. only arch, and netbsd so far.
09:11:48 <dcoutts> they must have many fewer packages to maintain
09:11:56 <dcoutts> we have >50
09:12:01 <dons> yep
09:12:13 <dcoutts> and all broke with 6.8 :-)
09:12:29 <dons> debian is in a similar position. they need to update to 6.8.x first
09:12:33 <dons> slowing things down.
09:12:41 <dons> i just want *one* good ghc to build against :)
09:13:00 <mauke> and in the darkness bind them
09:13:06 <dcoutts> dons: we're doing the opposite, we're updating to cabal-1.2.3 first, then later drop in 6.8 once we're sure everything builds with it
09:13:11 <dons> that's right, mauke
09:13:14 <Igloo> dons: Hmm, ta, restarted
09:13:21 <dons> cheers Igloo++
09:13:29 <sjanssen> dcoutts: I like the sound of that :)
09:13:51 <dons> we could try to talk nomeata into doing that on debian too, i guess.
09:13:53 <ski> chessguy : edge_rule :: if their_king_on_edge and our_king_close then [ mate_in_2, squeeze, approach, keeproom, divide].
09:14:01 <dons> i think he thought it was easier to just go to 6.8.x
09:14:12 <Igloo> Please don't talk him into doing that
09:14:12 <dcoutts> it's not :-)
09:14:21 <sjanssen> I wonder, since Cabal >= 1.2 is only a build dep, could the Debian package work with 6.6?
09:14:39 <sjanssen> or is that against some Debian policy?
09:15:05 <dons> Igloo: oh?
09:15:13 * dcoutts updates another 16 haskell packages in portage
09:15:22 <dons> Igloo: what do you think the best strategy is then, for getting xmonad 0.5 on debian?
09:15:22 <Igloo> dons: It makes things far too complicated
09:15:34 <Igloo> Patience  :-)
09:15:36 <dons> this is what worries me, http://people.debian.org/~igloo/popcon-graphs/index.php?packages=xmonad%2Cstumpwm%2Cawesome&show_installed=on&want_legend=on&want_ticks=on&from_date=2007-11-01&to_date=&hlght_date=&date_fmt=%25Y-%25m&beenhere=1
09:15:41 <lambdabot> Title: popcon graph, http://tinyurl.com/ywh52k
09:16:07 <dons> slow packaging, and expensive installs. so people have more trouble trying xmonad out.
09:16:32 <roconnor> what is awsome?
09:16:40 <dons> a clone of dwm with a config file.
09:16:41 <quicksilver> well the whole configuration-file-is-compiled-in decision was a high-risk strategy dons
09:16:47 <quicksilver> you knew that at the time!
09:16:48 <dons> quicksilver: that's been removed
09:16:57 <quicksilver> oh, really?
09:17:03 <dcoutts> dons: something that'd help distributors is if all the standard packages had releases that worked with 6.8
09:17:03 <Igloo> dons: If you start at 2007-10-01 then the gradient doesn't seem to be affected by the 6.8.1 release or anything
09:17:07 <dons> you no longer compile it in. and incidentally, dwm is very successul, despite requiring compilation
09:17:08 <quicksilver> how does it work now?
09:17:19 <Igloo> dons: awesome just always had a higher gradient
09:17:25 <dons> Igloo: yep.
09:17:34 <Igloo> dons: And people can still install xmonad, right? It just won't be the latest version
09:17:37 <roconnor> dons: what an ugly graph.  they ought to use Haskell Charts!
09:17:42 <dmwit> quicksilver: Recompilation on every run, I think.
09:17:55 <dons> Igloo: right. they don't have the version that doesn't require recompilation
09:17:58 <ertai> @docs Distribution.Simple.InstallDirs
09:17:58 <lambdabot> Distribution.Simple.InstallDirs not available
09:18:00 <dons> which is a key strategic release
09:18:16 <dcoutts> ertai: just check the ghc docs directly, hoogle does not index cabal
09:18:17 <dons> quicksilver: it compiles a ~/.xmonad/xmonad.hs file
09:18:27 <mauke> quicksilver: xmonad is a library. the executable lives in your ~
09:18:31 <dons> which provides a set of arguments to the xmonad library
09:18:32 <dcoutts> ertai: but if you have Qs, do ask
09:18:47 <dons> so you have one gloabl xmonad installed, and little custom ones living in ~/.xmonad/
09:19:05 <ertai> dcoutts: about the CopyDest types
09:19:14 <ertai> dcoutts: what are alternatives
09:19:20 <pejo> dons, does that mean you need a haskell compiler installed to be able to run it?
09:19:29 <dons> pejo: to configure it, yes.
09:19:36 <dons> like needing python to extend vim in python.
09:19:37 <dcoutts> ertai: they're for copying into a temp dir rather than the final install dir
09:19:50 <ertai> dcoutts: ok
09:20:00 <dons> pejo: so that's a runtime dependency on ghc, if you want configuration.
09:20:06 <dcoutts> ertai: if you've used ./configure & makefiles it's like ./configure --prefix=/usr && make install DESTDIR=tmp
09:20:18 <dons> dcoutts, Igloo, quicksilver: did you note the new slogan on haskell.org? :)
09:20:35 <ertai> dcoutts: ok I see
09:20:51 <dcoutts> dons: yeah, it's better, dunno about perfect :-)
09:20:56 <dons> yeah.
09:20:58 <dcoutts> perfect is hard
09:21:19 <Igloo> dons: Can we have it left-aligned?
09:21:28 <ertai> dcoutts: I've to go but I still cannot install Yi, it tries to install w/ making dirs
09:21:33 <dons> oh, not sure. i suppose so.
09:21:47 * dons looks
09:21:57 <dcoutts> dons: yeah, the centring is a bit weird
09:22:23 <dons> it left aligns in w3m, fwiw :)
09:22:33 <dcoutts> heh
09:23:15 <dons> how's that?
09:24:09 <Igloo> Much better. Should there not be a comma after "maintainable", though?
09:24:18 <dons> so i guess i can summarise the xmonad packaging as: cheaper, more reliable access to ghc 6.8, and get xmonad 0.5 in
09:25:01 <dons> Igloo: only if "high quality software" isn't object here.
09:25:21 <dons> commas slow down reading. use less :)
09:25:31 <dons> its critical!
09:25:32 <dons> mwhaha
09:25:36 <abram> how do I number nodes in a tree in a top-down, right-left order? In anything but Haskell, I would create a variable in the above scope and increment it as I construct each node. I could do this using an IORef and add an IO type, but is there an easier way?
09:25:48 * dcoutts jumps as dons thumps the table
09:26:05 <sjanssen> abram: just use recursion
09:26:06 <mauke> State monad?
09:26:09 <Igloo> dons: Well, I think we either need to add a comma there or to remove the one before "correct software"  :-)
09:26:09 <dons> abram: that's a mapAccum or a fold of some sort
09:26:16 <chessguy> Toxaris, ski, i don't so much want to do that as build up a vocabulary so that eventually i can maybe generate strategies randomly
09:26:24 <abram> sjanssen: I am constructing the tree recursively of course
09:26:59 <abram> dons: how would I use them?
09:27:39 <Igloo> Hmm, the left bar has some very odd layout too
09:27:58 <sjanssen> abram: you want to number them pre-order, except right-to-left?
09:28:29 <Igloo> Does HTML allow the dl for GHC/Hugs/nhc98/Yhc to be inside the table cell "Implementations" is in?
09:29:47 <abram> sjanssen: yeah. I can give each node a unique number by passing a current numebr along, and for the left side subtracting 2 ^ (level + 1) and on the right side (2 ^ (level + 1)) / 2, but that's not in order
09:29:57 <Igloo> Using a dl at all seems a bit dubiou to me, actually
09:31:41 <sclv_> abram: you can define the traversal, right?
09:31:43 <sjanssen> abram: there is a fairly simple recursive solution to this, would you rather see the code or work it out for yourself? :)
09:32:01 <abram> sjanssen: I've been trying to work it out myself for the last half hour or so
09:32:03 <sclv_> if so, just use the State monad instead of an IO ref.
09:32:22 <quicksilver> sclv_: or even better the Supply monad ;)
09:32:39 <sjanssen> abram: start with the type "Tree -> Int -> (Tree, Int)"
09:33:14 <sclv_> chessguy: you still neeed relationship primitives, though, right?
09:33:14 <abram> sjanssen: hm interesting. What about these other folks suggesting some sort of monad?
09:33:29 <ski> abram : abstractions
09:33:30 <sjanssen> abram: that is, it takes the Tree to be numbered and the starting index and produces a numbered Tree and the last index used
09:33:40 <chessguy> sclv_, i'm not sure what i need any more
09:33:40 <dmwit> Is there an inverse of ?instances?
09:34:00 <sclv_> Like, you can't randomly generate the notion of "threatens," no?
09:34:02 <ski> (or s/last index used/next index to be used/)
09:34:05 <dmwit> I tried ":i String" in GHCi, but it didn't turn up anything useful.
09:34:14 <chessguy> right
09:34:19 <sjanssen> abram: they're suggesting abstracting out the manual parameter passing in favor of the State monad
09:34:28 <sjanssen> abram: the approaches are the same, essentially
09:35:15 <ski> dmwit : try in Hugs
09:35:32 <quicksilver> absolutely the same, yes
09:35:34 <abram> sjanssen: are you suggesting making a recursive call for each step of creating the tree, or writing a recursive function that takes an unnumbered tree and returns a numbered one?
09:35:46 <oerjan> abram: hm, is the a breadth-first numbering?
09:35:49 <oerjan> *this
09:35:51 <sclv_> abram: which do you want?
09:36:02 <quicksilver> oerjan: yes, it's breadth-first but right-to-left, IIUC
09:36:04 <ski> abram : the latter (unless you prefer the former)
09:36:08 <sjanssen> abram: numbering an unnumbered tree, is that not what you wanted?
09:36:42 <oerjan> because if so i don't think numbering each subtree recursively works obviously
09:37:19 <ski> oerjan : i think "pre-order" implies depth-first
09:37:26 <quicksilver> dmwit: in ghci, :info will show you all the instances of a type.
09:37:44 <quicksilver> dmwit: which is the opposite of @instances in LB, I guess
09:38:00 <abram> sclv_: A tree where the node (or part of each node) is a unique number in a breadth first ordering
09:38:10 <ski> oh
09:38:14 <oerjan> ski: his subtract 2^(level+1) formula does not seem depth-first
09:38:17 <sclv_> dmwit: but it only shows you the instances in the packages you have loaded, as I recall.
09:38:55 <sclv_> abram: first, can you write a breadth-first traversal?
09:39:25 <ski> (oerjan : oh .. i was misled by ".. you want to number them pre-order, except right-to-left?  <abram> sjanssen: yeah. ...")
09:39:57 <dmwit> quicksilver, sclv_: ":info String" gives me just "type String = [Char]", which isn't all that helpful.  ...bummer.
09:40:01 * ski would try something with delimited continautions, for breadth-first
09:41:20 <scandal> @hoogle isSpace
09:41:20 <lambdabot> Data.Char.isSpace :: Char -> Bool
09:41:20 <lambdabot> Data.ByteString.Internal.isSpaceWord8 :: Word8 -> Bool
09:41:30 <abram> sclv_: yeah, I see how to do it now
09:41:55 <dcoutts> gah, we should make that Internal module hidden from haddock/hoogle
09:42:09 <sclv_> dmwit: try :info Char then
09:43:16 <dmwit> Ah, good idea, thanks.
09:44:14 <dbueno> I thought I heard somewhere that GHC can allow newtype'd types to have arbitrary arity?
09:44:14 <dmwit> ?hoogle Char -> Bool
09:44:15 <lambdabot> Data.Char.isControl :: Char -> Bool
09:44:15 <lambdabot> Data.Char.isSpace :: Char -> Bool
09:44:15 <lambdabot> Data.Char.isLower :: Char -> Bool
09:44:23 <dbueno> e.g. newtype Heap a = H Int (IntMap a)
09:45:33 <byorgey> dbueno: how would that work?
09:45:38 <dbueno> Feeding that to GHC says "The constructor of a newtype must have exactly one field."  Was I wrong?
09:46:02 <dbueno> byorgey: I make no claim to understand that ... I really thought I read it, or heard it on this channel.
09:46:14 <byorgey> dbueno: I've never heard or read that anywhere.
09:46:15 <sclv_> dbueno: use a data declaration for that.
09:46:20 <ddarius> The types have always been able to have arbitrary arity, the (data) constructors don't.
09:46:46 <dbueno> I must have misread.
09:46:51 <dmwit> dbueno: What you can do is something like "newtype Triple a b c = Triple (a, b, c)", I think.
09:47:12 <dbueno> Right, with tuples, of course.  Hm.
09:47:15 <byorgey> dbueno: the point of a newtype is that the constructor can be optimized away.
09:47:21 <dbueno> byorgey: Yes.
09:47:31 <pa-ching> Are there any Haskell shells/interpreters that allow you to define functions interactively?
09:47:38 <mauke> pa-ching: ghci
09:47:44 <dbueno> Thanks for the help.
09:47:48 <byorgey> but you can't optimize away the constructor if it contains more than one value.
09:47:58 <pa-ching> Okes... I swear it wasn't happy with simple function definitions before
09:48:01 <pa-ching> Maybe that was Hugs
09:48:07 <sclv_> see e.g. the state monad. newtype State s a = State { runState :: s -> (a, s) }
09:48:08 <mauke> pa-ching: you need "let"
09:48:10 <dmwit> pa-ching: Use "let" in front.
09:48:24 <pa-ching> For which one?
09:48:27 <dmwit> pa-ching: (Which, incidentally, should work in almost any Haskell interpreter.)
09:48:44 <pa-ching> Well I can do lambda functions with let in Hugs yeah
09:48:53 <mauke> dmwit: er?
09:49:02 <mauke> hugs doesn't let you define variables on the fly
09:49:20 <dmwit> Oh, really?
09:49:32 <pa-ching> Oh, hmm.
09:49:35 <dmwit> That's... odd.
09:49:37 <pa-ching> OK, maybe I was using ghci ;)
09:49:47 * dmwit shuts up
09:50:31 <mauke> Hugs.Base> let x = 2
09:50:31 <mauke> ERROR - Syntax error in expression (unexpected end of input)
09:50:50 <mauke> Prelude> let x = 2
09:50:51 <mauke> Prelude> x
09:50:51 <mauke> 2
09:55:04 <dmwit> :t unfoldr
09:55:05 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
09:58:25 <dmwit> ?source Prelude
09:58:26 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
10:10:29 <abram> just out of curiosity, are there versions of (!!) and take that use Integers rather than Ints?
10:10:55 <yitz> abram: @where genericTake
10:10:55 <sjanssen> @hoogle genericIndex
10:10:56 <lambdabot> Data.List.genericIndex :: Integral a => [b] -> a -> b
10:11:14 <yitz> @where genericTake
10:11:14 <lambdabot> I know nothing about generictake.
10:11:33 <dmwit> ?hoogle generic
10:11:34 <lambdabot> Data.Generics.Aliases.Generic :: type Generic c
10:11:34 <lambdabot> Data.List.genericLength :: Num i => [b] -> i
10:11:34 <lambdabot> Data.List.genericTake :: Integral i => i -> [a] -> [a]
10:12:05 <abram> I assume !! and take are a good deal faster than the generic versions
10:16:33 <yitz> abram: they are faster, but often that is not important. more often my reason for not using the generic ones is just because it looks messier.
10:16:42 <ac> sjanssen: so the only way to construct or traverse a tree in breadth first order is to traverse the tree for each level, like so...
10:16:42 <lambdabot> ac: You have 1 new message. '/msg lambdabot @messages' to read it.
10:16:49 <hpaste>  ac pasted "Make a tree with breadth first numbering" at http://hpaste.org/4434
10:16:54 <sclv_> abram: generally, but not always, if you're using !! there's a better way to express what you want.
10:17:04 <dmwit> ?instances Ordering
10:17:05 <lambdabot> Couldn't find class `Ordering'. Try @instances-importing
10:17:30 <sclv_> ?instances Ord
10:17:31 <lambdabot> (), All, Any, Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, Product a, Sum a, [a]
10:17:40 <dmwit> Is there an operation (+) for Ordering so that Eq is the identity?
10:18:08 <oerjan> compare is on one side i think
10:18:29 <dmwit> compare EQ LT
10:18:33 <dmwit> > compare EQ LT
10:18:34 <lambdabot>  GT
10:18:41 <dmwit> > compare LT EQ
10:18:42 <lambdabot>  LT
10:18:48 <dmwit> Nice, thanks.
10:18:49 <ac> sjanssen: is that what you were thinking? That's the basic idea of what I want
10:19:10 <dmwit> > compare GT LT
10:19:11 <lambdabot>  GT
10:19:29 <sjanssen> ac: originally, I thought you were asking for pre-order traversal
10:19:41 <sjanssen> I didn't think much about breadth-first
10:19:46 <dmwit> hmmm...
10:19:50 <ac> what's "pre-order"?
10:19:52 <oerjan> and if you massage the other side a bit...
10:20:42 <dmwit> oerjan: I basically want to do a whole bunch of compares, then "condense" them ala msum as if EQ where mzero and LT/GT sort of "ended" the sum.
10:20:47 <dmwit> (Do you see what I mean?)
10:21:01 <sjanssen> ac: visit the root, visit the left subtree, visit the right subtree
10:21:04 <oerjan> oh ... wait
10:21:41 <oerjan> @instances Monoid
10:21:42 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, Ordering, Product a, Sum a, [a]
10:21:47 <oerjan> ^^
10:22:03 <dmwit> yes
10:22:19 <dmwit> ?index Monoid
10:22:20 <lambdabot> Data.Monoid, Control.Monad.Writer, Control.Monad.RWS
10:22:37 <oerjan> > mconcat [EQ, LT, GT, EQ]
10:22:40 <lambdabot>  LT
10:22:46 <dmwit> Perfect, thanks!
10:22:53 <sjanssen> ac: I think this can be done more efficiently
10:22:56 <opqdonut> mmmh, nice
10:23:37 <ac> sjanssen: and that doesn't work, because it doesn't produce unique numbers :-P
10:23:46 <yitz> regarding the "default method proposal" thread on the cafe, I mentioned (what I think is) an obvious rule for choosing a default method in certain cases when there is more than one. anyone have an opinion on that?
10:25:13 <sjanssen> ac: do you absolutely need breadth-first, or will any unique numbering do?
10:25:31 <oerjan> dmwit: even more, i think compare of two lists is defined that way too
10:25:35 <ac> sjanssen: but it's going in the right direction. I don't actually need breadth first, I was just doing that as an exercise ;-P
10:25:53 <sjanssen> ac: in-order is considerably easier
10:26:25 <byorgey> hm, can't you just say that if a node has label 'n', its children have labels 2n and 2n+1?
10:26:30 <oerjan> > compare [1,2,3,4] [1,2,4,3]
10:26:31 <lambdabot>  LT
10:27:05 <dmwit> ah... hmm
10:27:07 <dmwit> That would make sense.
10:27:25 <oerjan> lexicographical ordering
10:28:12 <byorgey> ac, sjanssen: I missed the beginning of this conversation, what exactly are you trying to achieve?
10:28:26 <ac> byorgey: just a tree with a breadth first numbering
10:28:49 <byorgey> ac: a binary tree, or an n-ary tree?
10:29:36 <ac> byorgey: binary, where each branch has a value. What's the proper way to describe that?
10:30:20 <byorgey> ac: what do you mean, each branch has a value?  you mean it's a full binary tree?
10:31:23 <ac> byorgey: I mean "data Tree a = Leaf a | Branch (Tree a) (Tree a)"
10:31:57 <ac> erhg
10:32:11 <ac> I meant "data Tree a = Leaf a | Branch (Tree a) a (Tree a)"
10:32:35 <byorgey> ac: or maybe data Tree a = Empty | Branch (Tree a) a (Tree a)?
10:32:44 <byorgey> the one you gave can only have an odd number of nodes.
10:32:56 <ac> byorgey: true
10:33:00 <byorgey> at any rate, I think I see what you mean.
10:33:27 <gwern> does anyone know of any packages which do url-escaping? I'd rather not rewrite it if already available
10:33:35 <gwern> escaping/encoding
10:33:40 <paczesiowa> Network.URI
10:34:01 <byorgey> ac: how about this: assign the root node the label 1.  Then recursively assign the labels 2*n and 2*n + 1 to the children of a node with label n.
10:34:25 <byorgey> ac: such a numbering will have holes, but it's guaranteed to give unique labels which are ordered breadth-first.
10:34:36 <titusg> is there a function that applies two functions to one argument then combines the result?
10:34:40 <oerjan> if the tree is not too big i see a way to do it with some knot-tying (which might blow the stack if it's too big)
10:34:41 <gwern> paczesiowa: ah, I see. thanks
10:34:53 <titusg> with a type like f :: (b -> c -> d) -> (a -> b) -> (a -> c) -> a -> d
10:35:05 <ac> byorgey: are you sure it has holes? 2*n+1 and 2*n+2 seems to have no holes
10:35:08 <sjanssen> byorgey: are you sure it will have holes?
10:35:19 <sjanssen> @quote stereo
10:35:19 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
10:35:22 <byorgey> sjanssen: I mean, if the tree is not full, not all the labels will be used.
10:35:24 <conal> ac: also, see http://www.eecs.usma.edu/webs/people/okasaki/pubs.html ("Breadth-First Numbering: Lessons from a Small Exercise in Algorithm Design")
10:35:28 <tetha> The only way of getting a compact breadth-first-numbering (that is, on every level, across every subtree) would be some worklist-based approach and a tail recursive function
10:35:36 <sjanssen> byorgey: agreed
10:35:41 <ac> byorgey: but with my tree that is guaranteed to have both sides, it never has holes
10:35:42 <oerjan> titusg: liftM2 in the -> monad
10:35:56 <conal> ac: better ref: http://citeseer.ist.psu.edu/356396.html
10:36:03 <yitz> @pl \f g h x -> f (g x) (h x)
10:36:03 <lambdabot> liftM2
10:36:36 <byorgey> ac: well, it seems like you're set then.
10:36:49 <byorgey> unless I'm still not understanding what you're trying to do.
10:36:51 <ac> conal: thanks
10:36:52 <titusg> oerjan: thanks!
10:37:23 <byorgey> or liftA2 in the (->) applicative functor.
10:37:53 <yitz> @where liftM2
10:37:53 <lambdabot> I know nothing about liftm2.
10:38:19 <yitz> Well, bot, it's in Control.Monad. Anyway.
10:38:31 <byorgey> @index liftM2
10:38:31 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
10:38:45 <byorgey> yitz: @where is for project websites and things like that.
10:38:50 <oerjan> yitz: @where is a key -> value database we fill in ourselves, it is not based on any actual code
10:38:58 <byorgey> @where xmonad
10:38:59 <yitz> ah ok, sorry
10:38:59 <lambdabot> http://xmonad.org/
10:39:01 <yitz> @bots
10:39:01 <lambdabot> :)
10:39:40 <byorgey> where, index, src, source... hard to keep them straight =)
10:39:48 <oerjan> @src liftM2
10:39:48 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
10:39:51 <hpaste>  dmwit pasted "The Alphanum Algorithm" at http://hpaste.org/4435
10:40:41 <dmwit> In no more than 80 characters per line!
10:40:43 <dmwit> =)
10:41:25 <gwern> odd. escapeURI turns 'barnum & bailey' into "barnum%20&%20bailey", but google seems to escape the spaces as '+'
10:41:52 <dmwit> That would be Google doing non-standard things.
10:43:22 <gwern> R U STALKING ME??!11
10:43:27 <gwern> ack. mischan
10:43:34 <oerjan> YES WE ARE
10:43:35 <yitz> gwern - two different kinds of quoting
10:43:55 <gwern> (I assure you, I only descended to such atrocious English to heighten the comedic effect)
10:44:23 <byorgey> sure gwern, whatever you say ;-)
10:44:24 <gwern> yitz: is it just with spaces that these two kinds differ?
10:44:39 <gwern> byorgey: yes. yes, that is what I say
10:45:03 <gwern> (darn, wikipedia seems to use '+'s too)
10:45:21 <yitz> no. the "+" way is kind of a convention about query strings. there you have to quote & also, for example
10:45:43 <oerjan> wikipedia uses _ in actual article names
10:46:37 <gwern> yitz: oh, search queries are using https://secure.wikimedia.org/wikipedia/en/wiki/Percent-encoding percent-encoding, which is not what Network.URI is doing?
10:46:44 <yitz> but really, for query strings you can do whatever you want if you are writing the script
10:47:02 <yitz> whereas percent quoting is part of the URI standard.
10:47:17 <yitz> @google uri
10:47:18 <lambdabot> http://www.uri.edu/
10:47:18 <lambdabot> Title: Welcome to the University of Rhode Island Website!
10:47:24 <yitz> no, no
10:47:26 <hpaste>  (anonymous) pasted "make me work :)" at http://hpaste.org/4436
10:47:35 <yitz> @google uri rfc
10:47:37 <lambdabot> http://www.ietf.org/rfc/rfc2396.txt
10:47:41 <yitz> bingo
10:47:56 <gwern> tl;dr
10:49:21 <gwern> ok, let me restate my problem - I want to take strings and run searches in firefox on google, wikipedia, and divers other sites. opening firefox is easy enough, and getting the string is handled by xmonad's prompt. I just need to generate the URL. what haskell resources are available for that?
10:50:12 <dons> gwern: so you want to take a query string, and prepend a url to it?
10:50:20 <dons> what's  the input and expected output, and their types, please?
10:51:01 <gwern> dons: I'm not sure prepending is the right operation - I've been looking at google and wikipedia search URLs and they seem to have the escaped string in the middle
10:51:15 <gwern> dons: google :: String -> IO ()
10:51:31 <dmhouse> gwern: do you know query string syntax?
10:51:47 <dmhouse> http://address/page?var1=val1&var2=val2, etc?
10:51:48 <lambdabot> Title: No Forwarding URL
10:51:55 <gwern> dmhouse: no, not really
10:51:56 <dmwit> gwern: You can move the escaped string to the end, I believe.
10:52:07 <dankna> you can, it doesn't care what order the variables are in
10:52:41 <dmhouse> gwern: okay, well everything that comes after the '?' is called the "query string", you pass in key/values pairs, each pair separated by a & and each key separated from its value with a =. The order of the pairs is immaterial.
10:52:49 <dons> gwern: so what's the problem? you want to printf a string?
10:53:10 <dons> i'm unclear what kind of support you want, beyond string concatenation and escaping
10:53:32 <gwern> dons: no, I think proper escaping is enough
10:53:54 <gwern> surfraw which I currently use to do the same thing simply uses a sed call to escape the user input
10:54:00 <dmwit> Note that the usual escaping is fine, as Google/Wikipedia/etc. are supposed to handle that on their end.
10:54:17 <gwern> so eventually it just says ' w3_browse_url "http://www.google.com/${SURFRAW_google_search}?q=${escaped_args}&num=${SURFRAW_google_results}"'
10:54:17 <lambdabot> http://www.google.com/${SURFRAW_google_search}?q=${escaped_args}&num=${SURFRAW_google_results}"'
10:54:50 <titusg> can I use liftM2 with 2 functions (Char -> Bool) and a combining (Bool -> Bool -> Bool)? I get a type error No instance for (Monad ((->) Char))
10:55:05 <dmhouse> titusg: import Control.Monad.Instances
10:55:14 <dmhouse> (Or Control.Monad.Reader IIRC.)
10:55:20 <gwern> but I'd rather not reimplement the sed expression in haskell. it'd look messy for one thing, and I'd neer be able to trust it
10:55:32 <dons> gwern: so you can do the url escaping using Network.URI
10:56:01 <dons> escapeURIString
10:56:05 <doserj> > liftM2 (||) isAlpha isDigit 'a'
10:56:06 <lambdabot>  True
10:56:10 <titusg> dmhouse: thanks :-)
10:56:15 <gwern> dons: I tried that through 'escapeURIString (isAllowedInURI) string' but that seems to not work
10:56:28 <gwern> since spaces, for example, don't get turned into '+'s
10:56:37 <yitz> I'm not sure that is a problem with Google. Try it.
10:56:53 <yitz> (type a URL like that manually and see if Google groks it)
10:57:09 <gwern> and when I tried pasting it into firefox or calling ff from the cli  with the escaped version of 'Barnum & Bailey', it turned into a search for 'Barnum'
10:57:36 <dmwit> gwern: Is the '&' getting escaped?
10:57:52 <dmwit> gwern: It may not be, as '&' is a valid character, but you really do want it to be escaped in this case...
10:58:08 <gwern> hm, 'barnum%20&%20bailey'. doesn't look like it
10:58:20 <dmwit> Yeah, you'll want that to be %26.
10:58:58 <dmwit> You'll also want to make sure that '=' gets turned to %3d.  Dunno if '?' is safe or not.
10:59:06 <yitz> the rfc says:
10:59:09 <yitz> unreserved  = alphanum | mark
10:59:18 <yitz> mark        = "-" | "_" | "." | "!" | "~" | "*" | "'" | "(" | ")"
10:59:53 <yitz> So if you escape everything except those, you should be OK. I think Google is smart enough to handle it if you escape too much.
11:00:21 <bos> @seen cosmicray
11:00:21 <lambdabot> I haven't seen cosmicray.
11:00:28 <yitz> But of course, don't escape the actual delimiters - ?, &
11:00:47 <byorgey> @seen CosmicRay
11:00:47 <lambdabot> I haven't seen CosmicRay.
11:00:56 <byorgey> is it case-sensitive?
11:01:04 <gwern> yitz: so something like 'escapeURIString (const False) "barnum & bailey"' then
11:01:08 * gwern will try that
11:01:38 <yitz> does that escape the '&' ?
11:02:09 <gwern> yitz: "%62%61%72%6E%75%6D%20%26%20%62%61%69%6C%65%79"
11:02:19 <yitz> sure did!
11:03:11 <gwern> yeah :)
11:03:38 <byorgey> shouldn't that be called obfuscateURIString? =)
11:03:39 <yitz> isMark = (`elem` "-_.!~*'(|)")
11:03:52 <oerjan> perhaps isAlphaNum might be an improvement to const False ...
11:04:21 <yitz> escapeURIString (\c -> isAlpha c || isDigit c || isMark c)
11:04:55 <gwern> oerjan: mm. but then wouldn't the user be able to put in odd strings and have them interpreted as part of the URL and not the search? I mean, maybe I'll *want* to google for '?q=' some day
11:05:29 <oerjan> gwern: er i only mean to make digits and letters readable
11:05:30 <dmwit> escapeURIString (any . sequence [isAlpha, isDigit, isMark])
11:06:01 <oerjan> i assume any that is _not_ alphanumeric would still be escaped
11:06:06 <oerjan> *anything
11:06:26 <gwern> oerjan: oh, right, True means 'don't escape
11:06:53 <gwern> @where isAlpha
11:06:54 <lambdabot> I know nothing about isalpha.
11:07:02 <gwern> @hoogle isAlpha
11:07:03 <lambdabot> Data.Char.isAlpha :: Char -> Bool
11:07:03 <lambdabot> Data.Char.isAlphaNum :: Char -> Bool
11:07:21 <dmwit> Whoops, s/any/or/.
11:07:40 <byorgey> dmwit: clever.  I'd never thought of using 'sequence' in the (->) monad before.
11:07:41 <yitz> dmwit: escapeURIString (or . flip map [isAlpha, isDigit, isMark] . flip ($))
11:08:11 <oerjan> byorgey: that seems like a rare use that might actually improve readability
11:08:20 <byorgey> oerjan: exactly.
11:08:35 <gwern> escapeURIString (or . flip map [isAlpha, isDigit, isMark] . flip ($)) "barnum & bailey" -> "barnum%20%26%20bailey"
11:09:09 <yitz> that looks about right
11:09:36 <smack_> > 0.2 + 0.1
11:09:38 <yitz> > escapeURIString (\c -> isAlpha c || isDigit c || isMark c) "barnum & bailey"
11:09:38 <lambdabot>  0.30000000000000004
11:09:38 <lambdabot>   Not in scope: `escapeURIString'
11:09:54 <yitz> > Network.URI.escapeURIString (\c -> isAlpha c || isDigit c || isMark c) "barnum & bailey"
11:09:54 <lambdabot>   Not in scope: `Network.URI.escapeURIString'
11:09:55 <gwern> yitz: same output
11:10:03 <gwern> looks much better imo
11:10:07 <oerjan> @src isAlphaNu
11:10:07 <lambdabot> Source not found. The more you drive -- the dumber you get.
11:10:09 <oerjan> @src isAlphaNum
11:10:09 <lambdabot> Source not found. You type like i drive.
11:10:13 <byorgey> smack_: avoid floating-point numbers if you can. =)
11:10:16 <dmwit> smack_: Aren't floating point numbers fun?
11:10:25 <byorgey> > 0.2 + 0.1 :: Rational
11:10:25 <lambdabot>  3%10
11:10:40 <smack_> dmwit: tons of fun.
11:10:46 <dmwit> > 0.3 :: Rational
11:10:46 <smack_> i think i'm stuck with floating point in this case though
11:10:46 <lambdabot>  3%10
11:10:49 <roconnor> I was working on an implemenation of Riemman integration in Coq, and measure theory just fell out of it.
11:10:49 <dmwit> huh
11:11:11 <oerjan> :t fromRational
11:11:12 <lambdabot> forall a. (Fractional a) => Rational -> a
11:11:25 <byorgey> dmwit: decimal literals get an implicit 'fromRational', just like integer constants get a 'fromInteger'.
11:11:32 <yitz> roconnor: hard to integration without measure theory in there somewhere
11:12:02 <smack_> > (0.4-0.1, 0.2+0.1, 0.3)
11:12:03 <lambdabot>  (0.30000000000000004,0.30000000000000004,0.3)
11:12:10 <yitz> ouch
11:12:12 <roconnor> yitz: the do a pretty good job hiding it in first year :)
11:12:22 * smack_ needs to read some wikipedia
11:12:22 <oerjan> > 1e-10000 :: Double
11:12:23 <lambdabot>  0.0
11:12:23 <byorgey> my eyes!
11:12:25 <monochrom> measure theory comes out of Riemann integration? that's news to me. But if you can do it, amazing!
11:12:31 <oerjan> heh
11:12:42 <oerjan> > 1e10000 :: Double
11:12:42 <lambdabot>  Infinity
11:12:56 <oerjan> > 1e10000000000000000 :: Double
11:13:03 <lambdabot>  ghc: failed with error code 9
11:13:08 <byorgey> ooh, nice error
11:13:28 <oerjan> it apparently tries to calculate the exact rational :)
11:13:35 * dmwit looks up error code 9
11:13:39 <tetha> > 0e100000000 :: Double
11:13:42 <dmwit> "Only idiots use constants bigger than 10"
11:13:45 <lambdabot>  ghc: failed with error code 9
11:14:20 <roconnor> monochrom: well, I probably didn't get all of measure theory.  I haven't seen a sigma-algebra yet.
11:14:36 <roconnor> monochrom: but I found cumlative distribution functions
11:14:51 <roconnor> so I can integrate with respect to delta measure, etc.
11:16:57 <oerjan> dmwit: er, is that the genuine error description? :D
11:17:01 <shapr> ricky_clarkson: Why is excel calling me?
11:17:32 <dmwit> oerjan: No, heh, and I didn't look it up, either. =P
11:18:28 <yitz> roconnor: "f is Riemann integrable on [a,b]  iff M is Jordan measurable, in which case the Jordan measure of M is equal to <integral>" http://mathworld.wolfram.com/JordanMeasure.html
11:18:35 <gwern> shapr: because excel saga is a darn funny series
11:18:35 <lambdabot> Title: Jordan Measure -- from Wolfram MathWorld
11:21:08 * roconnor looks up the Radon-Nikodym theorem
11:22:03 <Mitar> i would like to add a haskell program to my latex report I am writing about it, what is the best way to do this? making \begin{verbatim} \input{Main.hs} \end{verbatim} obviously does not work
11:22:13 <yitz> roconnor: sigma-algebras are needed for Lebegue integration, I don't think you need them for Riemann. But that's not needed for measure theory.
11:22:54 <roconnor> sigma-algebras are not need for measure theory?
11:23:25 <sieni> roconnor: I think you misunderstood whay yitz said
11:23:33 <roconnor> sieni: I think I did
11:23:36 <yitz> well, you use the two together to get Lebesgue integration. (I think, been a long time)
11:23:56 <roconnor> yitz: if I don't need sigma-algebras for measure theory, that would be great :)
11:24:33 <sieni> well, you need sigma-algebras for measure theory, but Riemann integration is not based on measure theory
11:24:39 <yitz> ah, sorry, you do need it. that's the definition of a measure space. oh well.
11:24:59 <roconnor> I made an inverse cumlative distribution function monad by composing my completion monad with a step-function monad.
11:25:10 <roconnor> I wonder if this is related to the probability monad.
11:25:22 <dmwit> Wow, there is no obvious way to find out what GHC error code 9 means.
11:26:06 <stepcut> heh
11:27:06 <oerjan> Mitar: use the LaTeX .lhs format
11:27:18 <Igloo> I suspect that it's really signal 9, which I suspect is SIGFPE on OpenBSD
11:27:23 <yitz> sieni: Riemann integration is a measure, just like Lebesgue integration.
11:27:25 <Mitar> i am reading about literate programming ...
11:27:35 <oerjan> then your file is both legal haskell and latex at the same time
11:27:41 <Mitar> but I would like to have the code and report seperated
11:27:44 <yitz> oh, wait, this is #haskell... sorry
11:27:57 <Mitar> it is not really a documentation
11:28:09 <oerjan> Mitar: you could still \input it
11:28:14 <roconnor> yitz: it's okay, I'm talking about monads :)
11:28:26 <Mitar> yes, but in a verbatim mode?
11:28:35 <Mitar> oh
11:28:38 <Mitar> yes, lhs :-)
11:28:39 <oerjan> also look at lhs2tex, i hear
11:29:30 <Mitar> should I add any package to use lhs file in a input?
11:30:08 <sieni> yitz: I don't think it is
11:30:39 <yitz> Jordan measure
11:30:52 <Mitar> because where it does understand \begin{code} from?
11:31:48 <oerjan> hm, i've never used it myself
11:32:34 <sieni> yitz: how is jordan measure related to riemann integrals
11:32:36 <yitz> Igloo: when I type that at the ghci prompt on Mac OS X (BSD-based), it just hangs
11:33:04 <oerjan> http://haskell.org/haskellwiki/Literate_programming
11:33:13 <sieni> yitz: the difference in riemann and lebesgue integrals is that in riemann integrals you are splitting the domain of the function to intervals whereas in lebesgue integrals you are splitting the range
11:33:45 <yitz> sieni: "f is Riemann integrable on [a,b]  iff M is Jordan measurable, in which case the Jordan measure of M is equal to <integral>" http://mathworld.wolfram.com/JordanMeasure.html
11:33:46 <lambdabot> Title: Jordan Measure -- from Wolfram MathWorld
11:33:46 <roconnor> this Jordan measure looks like what I might be doing
11:34:07 <yitz> sieni: yes, so in either case it is the measure of something.
11:34:35 <sieni> yitz: what "M"?
11:34:50 <doserj> sieni: the area below the graph of f
11:34:51 <byorgey> Mitar: you write a .lhs file with \begin{code} ...  \end{code}, etc., and then run that through lhs2tex, which produces pure LaTeX output.
11:35:11 <byorgey> Mitar: then you can combine that with the rest of your report.
11:35:17 <sieni> ah
11:35:32 <oerjan> Mitar: that page contains several suggestions
11:35:46 <sieni> well, but it's different concept than measurability of functions in the usual sense
11:36:11 <doserj> yes
11:36:55 <Mitar> but it missing examples :-)
11:36:56 <sieni> I mean if Riemann integral was coming from a measure in a usual sense, then all Borel measurable functions would clearly be Riemann integrable
11:37:19 <sieni> But Riemann integral behaves badly with respect to limits
11:37:19 <oerjan> Mitar: section 2.1 is the simplest, just using verbatim
11:37:25 <yitz> That *was* measurable in the usual sense until Lebesgue came along...
11:37:42 <sieni> for example the bounded convergence theorem does not hold for riemann integrals
11:38:01 <sieni> well, I meant to say "dominated"
11:38:06 <sieni> instead of bounded
11:38:21 <yitz> Lebesgue measure is indeed better
11:38:51 <sieni> well, Lebesgue integral is a measure-theoretic integral
11:45:56 <roconnor> unfortnately Lebesgue measure isn't really constructive as far as I know.
11:46:22 <yitz> The Jordan measurable sets do not form a sigma-algebra. Their "completion" to a sigma-algebra is the Borel measurable sets, that is a measure space, but it is not complete.
11:47:26 <sieni> roconnor: well, if you want more constructive measure, then the Borel measure might be an acceptable alternative
11:47:49 <sieni> or maybe not
11:47:53 <roconnor> sieni: hmm
11:48:10 <sieni> ahh, completion of measures, yes
11:48:54 <roconnor> i'm going to need to sit down and figure ou what measures I have.
11:49:04 <sieni> I guess a measure is complete if all subsets of sets with zero measure have zero measure
11:49:05 <zeeeee> i'd like to write a simple high-perf regex-grep-like program for bytestrings, but i'm not sure which option to go with - text.regex seems straightforward to use, but text.regex.posix docs and a blog entry suggest that text.regex.* is slow and refer me to pcre and tre - which i have on idea how to use
11:49:10 <zeeeee> any guidance?
11:49:25 <sieni> and the completion of borel measurability in this sense is the lebesgue measurability
11:50:04 <roconnor> I bet the borel sets are more than enough to do physics.
11:50:35 <dons> zeeeee: they all have the same interface as Text.Regex
11:50:42 <dons> tre is the best performing one though
11:51:00 <doserj> roconnor: well, the borel sets are the constructible ones, or?
11:51:11 <ac> what happened to the Data.Array documentation at haskell.org/ghc/docs/latest?
11:51:41 <dons> ac, it would have moved under the array package namespace
11:52:00 <zeeeee> dons, i'm looking at regex-tre, and it has all these exec* that look nothing like Text.Regex
11:52:20 <sieni> doserj: what about analytic and co-analytic and more generally, projective sets?
11:52:26 <ac> I mean it looks unfinished
11:52:46 <zeeeee> also, the wiki says tre is buggy
11:53:18 <dons> check with the author, ChrisK, if you've got technical concerns. i've used the pcre backend happily, fwiw
11:53:26 <sieni> doserj: projections of borel sets (i.e. analytic sets) are not in general borel
11:53:42 <zeeeee> btw, is regex-posix the same as what gnu grep uses? (i.e., grep is slow?)
11:54:10 <doserj> sieni: hmm...
11:54:15 <dons> zeeeee: yeah.
11:56:30 <titusg> so how is -> a monad? what are bind and return?
11:56:58 <Igloo> Grr, half the services on community have randomly disappeared again
11:57:04 <Mitar> how can I run lhs2tex on normal haskell program?
11:57:07 <bos> titusg: bind is const
11:57:16 <bos> erk, return is const
11:57:21 <opqdonut> ?src ((->)a) (>>=)
11:57:21 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
11:57:24 <bos> my brain, not enough coffee
11:57:26 <opqdonut> ?src (r->) (>>=)
11:57:27 <lambdabot> Source not found. Maybe if you used more than just two fingers...
11:57:31 <opqdonut> gah
11:57:36 <opqdonut> ?src [] (>>=)
11:57:36 <lambdabot> m >>= k     = foldr ((++) . k) [] m
11:57:42 <opqdonut> ?src (->) (>>=)
11:57:42 <lambdabot> f >>= k = \ r -> k (f r) r
11:57:43 <bos> as for bind: f >>= k = \ r -> k (f r) r
11:57:44 <Zao> Mitar: Pipe the code through sed -n -e 's/^/> /p'  ? :)
11:58:31 <MetalJay> hi, i've seen the keyword 'rec' used at times (at least, notepad++ highlights it), but i can't seem to find documentation for it ... what's it do?
11:58:41 * titusg wishes he hadn't asked ;-)
11:58:50 <bos> MetalJay: maybe you're thinking of ocaml?
11:59:32 <bos> MetalJay: "rec" isn't a haskell keyword
12:00:36 <zeeeee> dons, i'm not sure how to contact chrisk
12:00:36 <bos> MetalJay: in ocaml, "rec" after "let" denotes that the let can have mutually recursive bindings, where one variable in the binding group can refer to others
12:00:49 <bos> zeeeee: haskell@lists.mightyreason.com
12:01:33 <bos> zeeeee: sorry, list.mightyreason.com, no "s"
12:02:04 <zeeeee> bos, thankns
12:02:40 <MetalJay> yeah it's Haskell, i'm not talking about let rec
12:02:52 <bos> MetalJay: there isn't a rec keyword
12:03:08 <MetalJay> fiby n = y fib n where
12:03:09 <MetalJay>   fib rec 0 = 0
12:03:09 <MetalJay>   fib rec 1 = 1
12:03:09 <MetalJay>   fib rec n = rec (n-2) + rec (n-1)
12:03:09 <MetalJay>   y f = f $ y f
12:03:26 <bos> there, rec is just a parameter of the function fiby
12:03:36 <bos> sorry, a parameter of fib
12:05:09 <ac> what's the propper way to add a new element on the end of an array?
12:05:42 <bos> ac: ah, a nasty question, that.
12:05:57 <sjanssen> ac: I think the best answer is "don't do that"
12:06:18 <bos> ac: there isn't a good way to do that. arrays are immutable in pure code.
12:06:23 <sjanssen> ac: if you need to repeatedly add an element to the end of a sequence, consider using Data.Sequence instead
12:06:27 <MetalJay> alright, i see that ... so i guess what's confusing me is, what is the rec parameter there for? what exactly is it doing with the fixed-point combinator?
12:07:27 <bos> MetalJay: it's what the y combinator is doing with *it* that counts
12:07:46 <ac> so basically the answer is something like "listArray $ (elems array) ++ new"
12:07:55 <MyCatVerbs> MetalJay: rec takes the argument passed fib when the Y combinator calls it.
12:08:05 <bos> MetalJay: if you look at the definition of y, it's calling fib with a first argument of (y fib)
12:08:14 <sjanssen> ac: yeah, that's probably the best way
12:08:22 <bos> ac: yes, that's the answer, and it should be clear why it blows chunks.
12:08:41 <ac> I think the most propper solution in my case would be to use a sequence until I'm done adding things, and then make an array
12:08:52 <monochrom> You can create a new array of a larger size (doubling the original size is popular), then copy from old to new and add the extra item at the same time.
12:08:56 <ac> because once it's constructed, this array could potentially be indexed many many times
12:09:02 <MyCatVerbs> MetalJay: y (\rec -> ...some code.. ) calls the anonymous function there, with the parameter rec being the function itself. As in, the rec parameter is *yourself*.
12:09:04 <bos> ac: what do you need an array for? you could use a map
12:09:17 <sjanssen> monochrom: that strategy isn't so useful with immutable arrays
12:09:48 <MyCatVerbs> sjanssen: quadruple instead, then. ;)
12:09:49 <sieni> ac: why don't you use a list then, and reverse it before making it an array?
12:10:05 <monochrom> It shouldn't be useless, either.
12:10:47 <ac> sieni: I was thinking I needed to index it in the process of constructing it, but I don't think I do
12:10:51 <bos> monochrom: it's painful. you'd have an array partly filled with undefined values, which the immutable array types don't really support.  so you'd need an array of Maybe a. eee-yew.
12:11:15 <MetalJay> so to use the y-combinator, you need your implicitly recursive function fib to take an argument that the y-combinator can work with?
12:11:35 <monochrom> Oh I see.
12:11:49 <sieni> > listArray (1,5) [1..5]
12:11:52 <lambdabot>  array (1,5) [(1,1),(2,2),(3,3),(4,4),(5,5)]
12:11:58 <sieni> blah
12:12:10 <sieni> > listArray (5,1) [1..5]
12:12:15 <lambdabot>  array (5,1) []
12:12:19 <sieni> :-P
12:12:39 <bos> monochrom: since you'd still have to copy the array to add another element, making it double the desired size wouldn't help; it would just make things slower.
12:13:05 <Sizur> what's up with the need to write point-free functions?
12:13:26 <Sizur> point free notation
12:13:37 <stepcut> it's rather pointless if you ask me
12:13:44 <Sizur> right, but why do I like to do it?
12:13:47 <ac> A sequence, map, or list is the correct option. Not quite sure which yet
12:13:49 <monochrom> Not many people understand this, but I can see point-free functional programming equivalent to imperative programming.
12:13:52 <conal> Sizur: sometimes i get insights in the process.
12:14:02 <sieni> > array (1,5) [(2,1), (1,4)]
12:14:08 <lambdabot>  Exception: (Array.!): undefined array element
12:14:15 <sieni> > array (1,2) [(2,1), (1,4)]
12:14:16 <lambdabot>  array (1,2) [(1,4),(2,1)]
12:15:43 <conal> Sizur: sometimes it clears away lambda noise and makes clearer what the transformation on a function is, giving a higher level view.  see backus's "can programming be liberated ..." paper.  other times, the result is less clear, and i go back tothe pointy form.
12:15:47 <monochrom> Imperative programming is about leaving the state threading implicit. Once in a while you do mention individual variable names and say x:=x+1. But you never mention the complete state: you say x:=x+1 but not x,y,z,t,u,v := x+1, y,z,t,u,v.
12:16:08 <ac> Is Data.Sequence similar to Data.IntMap, but without holes?
12:16:09 <zeeeee> is there a bytestring read/show?
12:16:35 <monochrom> So x:=x+1 is a pointfree way to say \(x, y, z, t, u, v) -> (x+1, y, z, t, u, v).
12:16:43 <bos> zeeeee: yes
12:16:59 <zeeeee> bos, where can i find it?
12:17:02 <Sizur> interesting
12:17:08 <bos> zeeeee: in Data.ByteString?
12:17:22 <monochrom> Pointful functional programming has to do that state-threading explicitly. Now pointfree programming avoids that, and so you get imperative programming again.
12:17:22 <bos> monochrom: yes, that's essentially static single-assignment form
12:17:27 <zeeeee> bos, module bytestring does not export read
12:17:28 <zeeeee> bos, module bytestring does not export show
12:18:09 <bos> zeeeee: maybe it's hidden in .Char8 then
12:18:10 <zeeeee> (not i don't mean for a bytestring to derive Read/Show)
12:18:15 <zeeeee> bos, i also tried char8
12:18:20 <Sizur> nice theory, but all I see is still a pure function
12:19:19 <Sizur> monochrom: so what you are implying is that people like point free notation because subconsciously it is equivalent to imperative style
12:19:21 <monochrom> Note that in real imperative programming, you don't always write explicit x:=x+1. Actually you write a chain of procedure calls, setup(); compute(); output(); which call is supposed to change state.
12:19:25 <bos> zeeeee: i don't know what's going on for you, then. i get the Show and Read instances when i import Data.ByteString
12:19:25 <sjanssen> zeeeee: ByteString doesn't export the read/show functions, those come from Prelude
12:20:15 <zeeeee> bos, i see that too, but my point is, doesn't ByteString deriving Show/Read simply imply that i can render a ByteString as a String? what i'm interested in rendering Read/Show objects as ByteStrings
12:20:26 <bos> oh.
12:20:30 <zeeeee> :)
12:20:31 <monochrom> In pointful function programming I would translate that to output(compute(setup(initial state))). In pointfree functional programming it would be output . compute . setup.  See the latter's blatant equivalence to setup(); compute(); output().
12:20:32 <zeeeee> sorry
12:20:36 <zeeeee> i was not being clear
12:20:43 <bos> there isn't a ShowByteString class, but it would be trivial to write.
12:21:02 <gwern> @pl foo = (\c -> isAlpha c || isDigit c || isMark c)
12:21:02 <lambdabot> foo = liftM2 (||) isAlpha (liftM2 (||) isDigit isMark)
12:21:04 <bos> class ShowByteString where showBS = pack . show
12:21:08 <zeeeee> bos, ah, so ByteString cannot leverage existing Read/Show
12:21:10 <Sizur> monochrom: yeah looks similar, but all three are essentially the same
12:21:12 <conal> monochrom: and some folks use ";" as reverse function application, for that reason.
12:21:15 <bos> zeeeee: sure it can, see above.
12:21:16 <gwern> @pl foo c = isAlpha c || isDigit c || isMark c
12:21:16 <lambdabot> foo = liftM2 (||) isAlpha (liftM2 (||) isDigit isMark)
12:21:37 <conal> monochrom: esp in denotational semantics for sequential imperative languages.
12:21:38 <timthelion> is there some x program which would allow me to register a set of haddock directories, and then search them with a little speedbar triggered by a global hotkey?
12:21:46 <Sizur> monochrom: it does look like sequencing
12:22:02 <monochrom> See also http://www.vex.net/~trebla/weblog/pointfree.html
12:22:03 <lambdabot> Title: The Point of Pointfree
12:22:09 <timthelion> I would want the bar only to be populated with data and function names
12:22:24 <zeeeee> bos, ah, thanks
12:23:22 <Sizur> monochrom: thanks for explaining, I can see what you meant when you said it's imperative equivalent
12:23:25 <monochrom> I like using f;g for g.f too.
12:24:12 <dmhouse> Strict languages can have HOFs, right?
12:24:14 <monochrom> The best functional programming is inspired by imperative programming. The best imperative programming is inspired by functional programming.
12:24:30 <monochrom> Yes, in fact all languages can have HOFs.
12:25:24 <zeeeee> does bytestring have a splitting function ByteString -> ByteString -> [ByteString]?
12:25:47 <zeeeee> i can only find single-char splitters
12:26:35 <MyCatVerbs> monochrom: surely it doesn't count if you're doing it manually, though? x_x
12:27:04 <byorgey> gwern: you didn't like oerjan's trick with sequence?
12:27:40 <monochrom> I don't mean doing it manually. I don't mean all languages have it either. I only mean all languages can have it, you can modify the language to add it.
12:28:21 <bos> zeeeee: you mean split-by-string?
12:28:27 <zeeeee> bos, yeah
12:29:10 <bos> zeeeee: no, but there's another library you can use for that, stringsearch
12:29:21 <bos> @hackage stringsearch
12:29:22 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/stringsearch
12:29:26 <zeeeee> bos, thanks
12:30:36 <zeeeee> how usable is cabal-install?
12:30:38 <zeeeee> currently
12:31:28 <Lemmih> ?users
12:31:28 <lambdabot> Maximum users seen in #haskell: 440, currently: 440 (100.0%), active: 19 (4.3%)
12:32:15 <Saizan> zeeeee: works fine if you build it with an enough recent version of Cabal, i.e. not the one shipped with 6.8.1
12:33:59 <zeeeee> Saizan, ok
12:34:35 <zeeeee> i get a "Excutable stanza starting with field 'flag splitbase description'" error when trying to setup stringsearch
12:35:16 <bos> zeeeee: what version of ghc? 6.6?
12:35:19 <zeeeee> boyeah
12:35:21 <zeeeee> bos, yeah
12:35:35 <bos> zeeeee: you need to install a newer version of cabal, or upgrade to ghc 6.8.2
12:35:45 <zeeeee> bos, ok
12:35:54 <zeeeee> how do i use Text.Regex (in particular splitRegex) with ByteString when it only takes String?
12:36:30 <bos> the regex packages can work with plain ByteString
12:36:44 <bos> newer versions can work with lazy ByteStrings, too
12:37:40 <zeeeee> bos, the latest ghc docs show that splitRegex only works with String. do you mean i should be using text.regex.posix?
12:38:04 <zeeeee> (based on the name 'regex-compat', does that mean new code should avoid using text.regex?)
12:38:15 <bos> zeeeee: yes
12:41:40 <zeeeee> i read that regex's don't need to be compiled because they're memoized. i'm curious how this is possible (on a high level), since =~ is supposed to be pure.
12:42:15 <monochrom> Not all code causes memoization.
12:42:55 <monochrom> Assume a naive compiler. "main = do {print (1+1); main}".  That 1+1 is not memoized.
12:43:24 <monochrom> "main = do {print x; main} where x=1+1"  now that will be memoized.
12:43:25 <zeeeee> monochrom, right, thunk results are saved, but i'm not sure why they're saved in this case because =~ is an infix operation with the "changing argument" being the left operand
12:43:51 <monochrom> Is the regex on the right?
12:43:55 <zeeeee> monochrom, yeah
12:44:01 <zeeeee> i understand that if i do
12:44:11 <zeeeee> f = (=~ "blah")
12:44:28 <zeeeee> actuall, no, i don't understand :)
12:44:53 <monochrom> This will depend on the gory details of =~
12:46:08 <zeeeee> monochrom, i'm not sure i follow - does ghc somehow know how to memoize as much of a function's computation as possible that doesn't depend on a most recent argument?
12:46:46 <monochrom> It sometimes can, through common subexpression elimination. But it is hard to predict.
12:47:15 <zeeeee> monochrom, then it is incorrect to state that =~ will necessarily save the compiled regex?
12:47:47 <monochrom> If someone states that, I want to see proof. :)
12:47:56 <monochrom> It is definitely not obvious.
12:47:57 <zeeeee> (i'm looking at the blog entry on serpentine.com)
12:48:21 <zeeeee> www.serpentine.com/blog/2007/02/27/a-haskell-regular-expression-tutorial/
12:49:22 <zeeeee> (near the bottom)
12:50:13 <Orphi> greetings assorted Haskell peoples
12:50:17 <Orphi> I have a VFAQ
12:50:25 <byorgey> greetings Orphi.
12:50:44 <Orphi> how do I get GHC to spit out the intermediate program representation before and after the optimiser passes?
12:51:03 <Orphi> byorgey: TY :-)
12:51:27 <byorgey> Orphi: that does not count as a VFAQ since I don't know the answer =(
12:51:31 <zeeeee> what is the text.regex.posix equiv of splitRegeX?
12:52:03 <Orphi> byorgey: does that mean that "how do I make my program faster?" is also not a VFAQ? ;)
12:52:17 <byorgey> Orphi: oh, THAT is a VFAQ. =)
12:52:31 <Orphi> byorgey: but you don't know the answer! ;)
12:52:45 <byorgey> yes I do!
12:52:49 <byorgey> take out the slow parts
12:52:53 <Orphi> lol. ok, and...?
12:53:01 <Orphi> 1337!!
12:53:26 * Orphi realises that (1337!!) is a valid Haskell expression...
12:53:50 <byorgey> > (1337!!) [0..]
12:53:51 <lambdabot>  Couldn't match expected type `Int' against inferred type `[a]'
12:54:00 <titusg> Orphi: see profiling in the users guide?
12:54:05 <byorgey> uh, wait, no it isn't =)
12:54:07 <opqdonut> > 3 ! !
12:54:07 * Orphi realises that it is NOT a valid expression since it does not type check
12:54:07 <lambdabot>  Parse error at "!" (column 5)
12:54:14 <opqdonut> > (3 !) !
12:54:14 <lambdabot>   parse error on input `}'
12:54:18 <mux> Orphi: but (!!1337) is valid :)
12:54:23 <Orphi> mux: indeed.
12:54:26 <byorgey> Orphi: maybe check out http://www.haskell.org/haskellwiki/Performance ?
12:54:30 <mux> :t (!!1337)
12:54:31 <lambdabot> forall a. [a] -> a
12:54:32 <lambdabot> Title: Performance - HaskellWiki
12:54:37 <roconnor> what is http://www.haskell.org/static/Haskell.html?
12:54:38 <lambdabot> Title: Haskell - HaskellWiki
12:55:16 <Orphi> mux: but !!1337 is rather bad Eng... wait...
12:55:22 <Orphi> er, nm.
12:55:31 <byorgey> hehe
12:55:36 <Toxaris> :t (1337 !!)
12:55:37 <lambdabot> forall a. (Num [a]) => Int -> a
12:56:01 <Toxaris> instance Num a => Num [a] where fromInteger = cycle . fromInteger
12:56:16 <Toxaris> and then (1337 !!) = const 1337
12:56:20 <Orphi> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs !! 1337
12:56:21 <lambdabot>  1887894200332450578485872635131438888682034332759626203734370221207918536632...
12:56:31 <Orphi> w00t!
12:56:47 <byorgey> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in length . show $ fibs !! 1337
12:56:48 <lambdabot>  280
12:56:55 <Orphi> ouch!
12:57:02 <Orphi> and still GHC finds it in seconds... woah.
12:57:14 <byorgey> meh, 280 isn't that many digits.
12:57:39 <Orphi> there is a faster algorithm - but it doesn't work well with FP arithmetic ;-)
12:58:04 <Saizan> which?
12:58:06 <byorgey> Orphi: there are a lot of faster algorithms, many of which work quite well with FP.
12:58:25 <Orphi> Saizan: there's a closed-form formula for the Nth Fibonacci number
12:58:37 <Orphi> but it stops working for sufficiently large N
12:58:47 <Orphi> or rather, fails due to rounding errors
12:59:02 <byorgey> http://www.haskell.org/haskellwiki/The_Fibonacci_sequence
12:59:03 <lambdabot> Title: The Fibonacci sequence - HaskellWiki
12:59:14 <Saizan> and what's the problem with "FP arithmetic"? that we defaults to bignums?
13:00:02 <Orphi> floating point arithmetic isn't accurate enough
13:00:17 * Orphi finds the relevant chapter in the GHC manual
13:00:19 <Orphi> http://www.haskell.org/ghc/docs/latest/html/users_guide/options-debugging.html
13:00:54 <byorgey> Orphi: the key insight into making that closed form faster is that it involves exponentiation, which can be implemented in better than linear time.  but the same idea can be applied in other forms (e.g. matrix exponentiation, working in Q(sqrt 5), and so on) that don't require floating-point.
13:01:10 <byorgey> see the page I linked above for ideas =)
13:01:25 <Saizan> aaah, FP = floating point, i was reading it as functional programming, and it didn't make sense, sorry
13:01:26 <roconnor> Is it fair to call Galois a consulting firm?
13:01:37 <byorgey> oh, hehe, me too =)
13:01:44 <Orphi> sorry guys ;)
13:02:17 <byorgey> Orphi: re: your question about ghc, have you looked in the ghc documentation?
13:02:37 <Orphi> byorgey: yeah, scroll up a bit. I just found the page.
13:02:46 <byorgey> oh, ok, sorry.
13:02:46 <Orphi> still not 100% sure exactly which flags I want...
13:03:14 * Orphi annoys GHC
13:03:38 * GHC annoys Orphi
13:03:51 <Orphi> o_O
13:04:14 <Orphi> I guess Haskell is a language which really can speak to you...
13:04:22 <Orphi> vixen hello
13:04:27 <monochrom> Just like the evil Ring
13:04:39 <Orphi> ...evil...ring?
13:04:47 <olsner> @vixen what do you think about module systems?
13:04:47 <lambdabot> i dunno, what about?
13:05:18 <olsner> @vixen are you a known bug?
13:05:18 <lambdabot> i think i know
13:05:19 <byorgey> Orphi: I think monochrom is referring to Lord of the Rings.
13:05:39 <Orphi> ah. the One Ring. I see
13:05:39 <gwern> didn't the videotape in the ring speak?
13:06:10 <Orphi> hmm, it's true - GHC *does* annoy me! :S
13:06:27 <Orphi> OK, who knows how to pipe stderr to a file from the Windoze command shell?
13:06:42 <vininim> yay.. 6.8.2 in werewolf real soon now
13:07:35 <Sizur> Orphi: does windoze have pipes?
13:07:50 <sieni> yes
13:07:53 <Orphi> Sizur: I rephrase: how do I redirect stderr to a file ;)
13:07:55 <byorgey> it has fake ones
13:08:14 <sieni> well it has real pipes but nothing comparable to unix domain sockets
13:08:18 <hpaste>  wellwisher pasted "FFI parse error" at http://hpaste.org/4437
13:08:25 <sieni> i.e. windows pipes don't support half close
13:08:38 <Orphi> ah, wait... GHC 6.8.1 adds --ddump-to-file
13:08:38 <sieni> which sucks more than 10000 industrial grade vacuum cleaners
13:09:01 <Orphi> "the only time Microsoft make something that doesn't suck, they'll be making vacuum cleaners"
13:09:20 <harlekin> Orphi: Seems to be the same as in linux shells. program 2> file
13:09:24 <Sizur> het, .net is not that bad
13:09:31 <Orphi> harlekin: TY.
13:09:55 <Sizur> and directx is not bad either
13:10:30 <wellwisher> any help for: http://hpaste.org/4437  ????
13:10:43 <Orphi> hmm, --ddump-to-file doesn't work. using harlekin's suggestion.
13:11:10 <vininim> Sizur: not bad for what?
13:11:22 <Saizan> wellwisher: those #foo symbols aren't haskell, maybe you forgot to run some preprocessor?
13:11:38 <Orphi> you...have...got...to...be...kidding.... it uses BOTH streams??
13:11:41 <wellwisher> o
13:11:44 <Sizur> vininim: compared to other technologies
13:11:48 <Orphi> ok, er... can you redirect both to the same place?
13:12:56 <harlekin> Orphi: Maybe 2>&1 > file?
13:13:10 * Orphi redirects each stream to a seperate file and inspects the damage
13:13:24 * Orphi deletes the compiled program and retries compiling
13:13:35 <Orphi> @yarr
13:13:35 <lambdabot> Aye
13:13:46 <Orphi> yays @ someone agreeing
13:14:18 * Orphi attempts to read Core
13:15:27 <Saizan> Orphi: -fforce-recomp is nice in cases like these
13:15:39 <Orphi> Saizan: TY, noted.
13:16:35 <Orphi> DOH! >_<
13:16:46 * Orphi compiles again specifying correct optimiser settings
13:19:34 * Orphi watches his 4-line program transformed into a 28-line monster Core expression
13:21:24 <mux> > fix ((1:) . scanl (+) 1) !! 1337
13:21:26 <lambdabot>  1887894200332450578485872635131438888682034332759626203734370221207918536632...
13:21:36 * Orphi starts to feel quite dizzy
13:22:15 <Corun> That is the 1337est number ;-)
13:22:29 <Orphi> tidy core is now 4 pages long and growing...
13:22:31 <Orphi> eeps!
13:24:06 <dons> Orphi: check the final result with -ddump-simpl
13:24:22 <Orphi> dons: that's the pass to look at, is it?
13:24:39 <Sizur> how can I compile with --make without generating junk in the current dir?
13:25:45 <Saizan> Sizur: pass -odir and -hidir some other directory
13:26:04 <dons> Orphi: yeah. the final  simplifier result
13:26:31 <Sizur> Saizan: thanks
13:27:42 <Orphi> dons: wow. my 4-line program becomes 2 pages...
13:27:54 <dons> that's probably a good thing :)
13:28:14 <Orphi> dons: I'm merely interested to know whether it has been properly deforested or not.
13:29:41 <Orphi> I (foolishly?) posted a message suggesting that composing functions is a "better" way to program than an explicit loop
13:29:42 <sjanssen> Orphi: try -ddump-simpl-stats and hunt for "fold/build"
13:29:56 <Orphi> and now some guy is saying "yeah, but, it won't be as efficient"
13:29:58 <sjanssen> (assuming we're talking about list deforestation)
13:30:06 <Orphi> and I said "it will optimise to the same code"
13:30:15 <Orphi> but now I need to check that optimistic assertion...
13:30:23 <Orphi> [hmm, maybe talk less? :S ]
13:31:09 * Orphi reads Core slowly
13:31:58 <dons> Orphi: composition if fine for fusible code. (be sure to use -O2)
13:32:28 <Orphi> "longest_word = \x -> case a (Data.List.words x) of {...}"
13:32:33 <njbartlett_> I'm writing a blog post to sort of review the options available for building GUIs with Haskell. Does anybody know if a Qt binding has ever been built?
13:33:14 <Orphi> dons: FWIW, longest_word = fst . maximumBy (\x y -> compare (snd x) (snd y)) . map (\w -> (w, length w)) . words
13:33:31 * sjanssen doesn't see any fusion there
13:33:49 <sjanssen> maximumBy is a foldl, and I doubt words is a good producer
13:33:54 <Orphi> lol @ CoUnsafe
13:34:35 <dons> yeah, you'd need stream fusion here to fuse the map. words and maximumBy into a single loop
13:34:37 <Orphi> sjassen: stream fusion likely to make any odds?
13:34:46 <dons> or you'll have intermediate lazy cons nodes
13:34:54 <sjanssen> dons: does words actually fuse in stream fusion?
13:35:05 * Orphi wishes he could comprehend Core
13:35:06 <dons> checking. pretty sure we have an implementation
13:35:32 <dons> ah, no, only a commented out lines
13:35:42 <sjanssen> Orphi: stream fusion could definitely fuse the maximumBy . map part
13:36:03 <dons> its possible to fuse words too, just not enabled by default
13:36:31 <sjanssen> dons: btw, where is the stream fusion repo nowadays?
13:36:44 <sjanssen> I couldn't find it the last time I tried
13:37:04 * Orphi reads Core output for stream fusion version
13:37:11 <Orphi> well... it looks different. lol!
13:37:12 <mux> :t if'
13:37:13 <lambdabot> Not in scope: `if''
13:37:19 <dblhelix> @seen vincenz
13:37:20 <lambdabot> Last time I saw vincenz was when I left #darcs, #ghc, #haskell and #scala 1m 4d 19m 47s ago, and .
13:37:29 <mux> @let if' b x y = if b then x else y
13:37:31 <lambdabot> Defined.
13:38:00 <mux> > let (?) = if' in (2 > 3) ? "true!" $ "false."
13:38:00 <lambdabot>  "false."
13:39:13 <mux> it's funny, operator default fixity or whatever maeks it necessary to use $, or to add more parens; and using $ is reminiscent of the C ternary operator .. ? .. : ..
13:39:31 <Orphi> er... Test.lvl = GHC.Base.unpackCString# "maximumBy"
13:41:43 <sjanssen> Orphi: probably used in an error message somewhere
13:41:53 <Orphi> sjassen: mmm, k
13:42:16 <Orphi> ah... Test.a = Data.Stream.errorEmptyStream @ ([GHC.Base.Char], GHC.Base.Int) Test.lvl
13:42:56 <Orphi> I'm guessing "x_aeG" is a made-up unique identifier?
13:43:43 <vininim> parsec is removee why?
13:44:43 <Orphi> hey, if I put this Core dump on hpaste, can somebody take a stab at interpretting it?
13:45:08 <sjanssen> Orphi: try reading the -ddump-simpl-stat output
13:45:24 <sjanssen> that will give you a list of rules that fired, which will probably be easier to interpret
13:48:16 <Orphi> 5 RuleFired
13:48:27 <bakert> :type liftM_
13:48:36 <bakert> :t liftM_
13:48:38 <lambdabot> Not in scope: `liftM_'
13:49:15 <sjanssen> Orphi: do any of them sound streamy?
13:49:18 <Orphi> STREAM stream/unstream fusion, length -> fusible, length -> unfused, map -> fusible, maximumBy -> fused
13:49:25 <Orphi> 1 each
13:49:44 <Orphi> lol @ streamy
13:50:08 <dons> awesome :)
13:50:16 <Orphi> dons: is that good?
13:50:20 <dons> how many stream/unstream's ?
13:50:24 <sjanssen> so, 1 occurrence of fusion, and we can tell that it's the "maximumBy . map" part
13:50:29 <vbx> how is everyone doing tonight?
13:50:30 <Orphi> dons: 1 of each of the things I listed.
13:50:31 <dons> that's what i would expect
13:50:39 <dons> so 3 stream/unstream ?
13:50:41 <dons> or 1 stream/unstream
13:50:46 <Orphi> 1 stream/unstream
13:50:49 <dons> ok.
13:51:02 <dons> you'll need 6.8.2 btw, to make it fast
13:51:03 <Orphi> dons: would you like to see the final Core?
13:51:17 <dons> 6.8.1 only shows what would fuse, but it doesn't clean it up properly
13:51:33 <Orphi> oh ok. lol!
13:51:35 <dons> stream-fusion requires 6.8.2 or ehad.
13:51:37 <dons> head.
13:51:44 <dons> i guess the final core looked bad?
13:51:49 <dons> full of Step and so on?
13:51:52 <hpaste>  Orphi pasted "Random Core output" at http://hpaste.org/4438
13:52:05 <dons> oh,
13:52:05 <Orphi> dons: see for yourself.
13:52:20 <dons> looks good!
13:52:32 <Orphi> dons: this *means* something to you? lol
13:52:38 <dons> words, then a nice stream worker
13:53:06 <Orphi> dons: so how much work is this doing to get my answer?
13:53:27 <dons> its removing intermediate list nodes allocated between map and maximumBy, so a single traversal is removed.
13:53:35 <dons> you might see some 5-10% improvement (?)
13:53:47 <dons> can you do a benchmark?
13:53:53 <Orphi> dons: so... it now makes 2 traversals in total?
13:53:54 <dons> i'd then like to check with 6.8.2
13:54:04 <dons> Orphi: yeah, words, then fused maximumBy/map
13:54:29 <dons> with some effort, you could do a single traversal, by fusing words, but that definitely would need 6.8.2
13:54:31 <Orphi> dons: and allocates and deallocates space for each "word" then?
13:54:41 <dons> it creates words nodes lazily, yep
13:54:46 <dons> ?src words
13:54:46 <lambdabot> words s = case dropWhile isSpace s of
13:54:46 <lambdabot>     "" -> []
13:54:46 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
13:54:55 <dons> ?src break
13:54:55 <lambdabot> break p =  span (not . p)
13:54:58 <dons> ?src span
13:54:58 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
13:55:01 <dons> hah
13:55:15 <Orphi> dons: ok. the argument was that the Haskellish function composition would be as efficient as a Java-style "I do everything explicitly in 1 big complex loop"
13:55:32 <dons> yes. that's true to a first approximation.
13:55:35 <Orphi> dons: I still see no reason why it can't be, but it appears it's not quite there just yet.
13:55:52 <dons> and secondly, loops that are too complex to write in a single pass are feasible when composed
13:56:01 <dons> the fusion mechanism will do the transformation for you
13:56:19 <Orphi> dons: well yes, that's exactly it. YOU write nice, maintainable, readable code, GHC writes spaggetti
13:56:30 <dons> right, but that's ok. the sphagetti is quick
13:56:43 <dons> think of it more as instant noodles
13:56:44 <Orphi> dons: and YOU do not need to care about the spagetti
13:57:02 <Orphi> dons: this is the whole idea of why we have compilers :D
13:57:08 <dons> right
13:57:20 <dons> it transforms a nice specification of a loop body as a series of composed operations
13:57:21 <Orphi> dons: presumably for C-like speed, you'd need ByteString anyway tho...
13:57:24 <dons> into a low level loop
13:57:32 <dons> yes, you fuse on bytestrings instead
13:57:38 <dons> which  really could outperform C here
13:57:51 <dons> since a single words/maximum/map in C would be quite involved
13:57:51 <Orphi> and presumably leave Java standing... ;)
13:57:58 <dons> esp. if buffering is taken into accoutn
13:58:46 <Orphi> dons: you have my code [at the top of the paste], are you able to look at the Core output from 6.8.2?
13:58:52 <dons> sjanssen: oh, the stream-fusion repo is still on unsw, iirc.
13:58:57 <dons> looking now...
13:59:22 <dons> (comparing snd) btws
13:59:24 <dons> is nicer :)
13:59:39 <Orphi> :type comparing
13:59:47 <Orphi> gah!
13:59:50 <dons> in Data.Ord
13:59:52 <Orphi> @type comparing
13:59:53 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
14:00:11 <Orphi> interesting. I thought such a function ought to exist...
14:00:53 <Orphi> actually, (a -> b) -> (b -> b -> c) -> a -> a -> c
14:00:55 <Orphi> hmm
14:01:14 <dons> actually, much better code with 6.8.2
14:01:17 <Toxaris> :t on
14:01:18 <lambdabot> Not in scope: `on'
14:01:21 <Orphi> dons: yeah?
14:01:28 <dons> let me post..
14:01:36 <Orphi> kk
14:01:42 <dons> 11 RuleFired 6 SC:$wloop_maximumBy0 1 STREAM stream/unstream fusion 1 length -> fusible 1 length -> unfused 1 map -> fusible 1 maximumBy -> fused
14:01:43 <opqdonut> Orphi: yeah that's a usual idiom
14:02:09 <opqdonut> :t let f `on` g = \x y -> g x `f` g y
14:02:09 <lambdabot> <command line>:
14:02:09 <lambdabot>     Could not find module `L':
14:02:09 <lambdabot>       Use -v to see a list of the files searched for.
14:02:13 <opqdonut> :t let f `on` g = \x y -> g x `f` g y in on
14:02:14 <lambdabot> forall t t1 t2. (t -> t -> t1) -> (t2 -> t) -> t2 -> t2 -> t1
14:02:34 <dons> there's one less loop generated
14:02:36 <opqdonut> well, flipped
14:02:47 <Orphi> dons: so... 2 - 1 = ...1?
14:03:04 <Orphi> > 2 - 1
14:03:05 <lambdabot>  1
14:03:10 <dons> no lazy worker, just M.$s$wloop_maximumBy
14:03:22 <Orphi> dons: so... 1 traversal for the whole thing?
14:03:26 <dons> 2.
14:03:31 <Orphi> ah, ok.
14:03:32 <dons> since words doesn't fuse.
14:03:40 <Orphi> pitty... why is that?
14:03:57 <dons> there's no fusible implementation for words in the current library
14:04:01 <Orphi> right. but there could be one?
14:04:12 <dons> yep
14:04:17 <hpaste>  dons annotated "Random Core output" with "good fusion" at http://hpaste.org/4438#a1
14:04:21 <vininim> @src forever
14:04:21 <lambdabot> Source not found. :(
14:04:22 <Orphi> not written yet? or too hard?
14:04:49 <dons> not written yet.
14:04:59 <Orphi> want me to write it? ;) lol!
14:05:07 <dons> let me give you some timing data..
14:05:13 * shapr pulls out the stopwatch
14:05:21 <Orphi> lol @ shapr
14:05:33 <dons> $ time ./A
14:05:33 <dons> "thyroparathyroidectomize"
14:05:33 <dons> ./A  0.25s user 0.01s system 100% cpu 0.258 total
14:05:39 <dons> with fusion. on the words file
14:06:09 <Orphi> dons: how about with -O0?
14:06:11 <vininim> > timeout 5 (return (forever Just 1))
14:06:12 <lambdabot>   Not in scope: `forever'
14:06:15 <dons> $ time ./B
14:06:15 <dons> "thyroparathyroidectomize"
14:06:16 <dons> ./B  0.31s user 0.01s system 101% cpu 0.317 total
14:06:21 <dons> so about what was expected.
14:06:31 <dons> > 258 / 317 * 100
14:06:32 <lambdabot>  81.38801261829653
14:06:39 <dons> actually, better than expected
14:06:49 <dons> that map was fairly costly, and we get an unboxed threaded accumulator
14:06:53 <dons> stream fusion ftw!
14:06:54 <Orphi> > 100 - 81
14:06:55 <lambdabot>  19
14:06:59 <Orphi> 19% faster?
14:07:06 <dons> well, on one small case :)
14:07:07 <joelr1_> i step away and there are 682 messages on haskell
14:07:12 <joelr1_> #haskell that is
14:07:53 <Orphi> so when some poor **** spends half their life writing stream fusion for ByteString, this will become absurdly fast?
14:08:11 <dons> well, let's see. we have fusible bytestrings already..
14:08:36 * Orphi waits with anticipation
14:09:10 <belegurth> why
14:09:23 <belegurth> I asked why
14:09:23 <Orphi> zed
14:09:27 <dons> 13 RuleFired 6 SC:$wloop_maximumBy0 1 STREAM stream/unstream fusion 1 filter 1 filterList 1 map -> fusible 1 maximumBy -> fused
14:09:36 <dons> $ time ./A
14:09:36 <dons> "thyroparathyroidectomize"
14:09:36 <belegurth> I asked why
14:09:36 <dons> ./A  0.05s user 0.01s system 102% cpu 0.058 total
14:09:38 <dons> :)
14:09:41 <belegurth> I asked why
14:09:49 * Orphi blinks
14:09:49 <dons> haskell ftw!
14:09:55 <belegurth> why?
14:09:57 <Orphi> Haskell is teh 0wnerz
14:10:15 <belegurth> why
14:10:16 <Orphi> dons... that's almost scary!
14:10:16 <belegurth> why
14:10:17 <Orphi> wow
14:10:19 <belegurth> why
14:10:20 <belegurth> why
14:10:25 <dons> belegurth: stop
14:10:27 --- mode: ChanServ set +o dons
14:10:37 <hpaste>  dons annotated "Random Core output" with "bytestring list fusion" at http://hpaste.org/4438#a2
14:11:08 <Orphi> how big is "words"?
14:11:09 <zou> dmwit: i tried various grammars, it didn't seem to work
14:11:31 <kpreid> ah, WP-Gast again
14:11:33 <zou> now i'm wondering if i have to restore to just simple table lookups with keywords, etc
14:11:37 --- mode: ChanServ set +o shapr
14:11:40 <dons> without stream fusion, the bytestring is a little slower
14:11:41 <dons> $ time ./A
14:11:41 <dons> "thyroparathyroidectomize"
14:11:42 <shapr> belegurth: Are you learning Haskell?
14:11:42 <dons> ./A  0.05s user 0.01s system 102% cpu 0.059 total
14:11:45 --- mode: ChanServ set -o dons
14:11:53 <dons> oh, about the same
14:12:12 <zou> anyone has experience with parsec's permute ?
14:12:22 <Orphi> dons: how big is this file you're parsing?
14:12:32 <shapr> belegurth: If you're not on-topic, you get removed.
14:12:32 <dons> Orphi: 1M or so
14:12:39 <dons> that's the dictionary file
14:12:43 * SamB wonders if belegurth is real
14:12:47 <dons> 2.5M
14:12:48 <Orphi> dons: right. so not huge, but big enough to contains a fair few words...
14:12:55 <SamB> belegurth started asking why before anyone said anything
14:13:02 <dons> $ du -hs /usr/share/dict/words
14:13:02 <dons> 2.4M	/usr/share/dict/words
14:13:02 <dons> $ wc -l /usr/share/dict/words  234979 /usr/share/dict/words
14:13:08 <shapr> belegurth: You have thirty seconds to convince me that you're interested in learning Haskell. Your client will self-destruct in 5 ...
14:13:13 <SamB> afaict...
14:13:41 * Botje puts on goggles
14:13:46 <swiert> zou: what do you want to do?
14:13:51 <shapr> belegurth: You're not being convincing.
14:13:57 <dons> shapr: its a bot, i think.
14:13:58 <SamB> anyway, I think belegurth is a bot
14:14:04 <dons> "Java User"
14:14:07 --- kick: belegurth was kicked by shapr (Kicked by shapr)
14:14:08 <SamB> since basically all it said was "why" and "I asked why"
14:14:09 <Orphi> dons: right. so in conclusion, my program can pick out the longest word from a file containing a few hundred thousand words, and it can do it in a few milliseconds flat.
14:14:26 <shapr> Actually, I think belegurth is some n00b using an irc java applet.
14:14:27 <dons> Orphi: yeah. and in one line of code :)
14:14:33 <dons> shapr: ah, possibly
14:14:42 <Botje> don't we <3 n00bs?
14:14:42 <Orphi> dons: so much for "Haskell will never be fast"...
14:14:46 <SamB> shapr: maybe it's a bad AI
14:14:52 <SamB> using a Java applet
14:14:52 <dons> Orphi: well, it was the 90s.
14:14:56 <dons> we had different ideas then
14:14:59 <kpreid> my recollection is there's a common annoyance which spews "why" and has WP-Gast in the user info
14:15:10 <kpreid> don't recall which channels I've seen it in though
14:15:14 <shapr> Botje: Yeah, if they're learning Haskell or something else on-topic.
14:15:15 <Toxaris> how to apply a turing test to a non-cooperating communication partner?
14:15:17 <zou> swiert: i want to parse/extract info from a local for sale ads
14:15:20 <dons> yes. that's a bot we've had before. this =WP-Gast
14:15:23 <shapr> Botje: Otherwise they just distract from the useful part of #haskell.
14:15:32 <Orphi> dons: I still worry somewhat that some trivial C version might go faster...
14:15:36 <dons> Orphi: try it.
14:15:37 <Botje> indeed :)
14:15:39 <zou> swiert: two examples
14:15:41 <Orphi> dons: but then, I don't know C, so I guess I'll never know...
14:15:41 <SamB> Toxaris: well, basically if it doesn't protest it probably isn't self-aware
14:15:42 <shapr> dons: I'd guess that Gast means "guest" in German?
14:15:47 <dons> i don't think its trivial to do this well in C.
14:15:48 <zou> swiert: "Infiniti G35 Coupe 2003 2K UNDER BLUE-BOOK"
14:15:50 <SamB> or at least not able to speak your language
14:16:04 <dons> the buffering is needed, which makes it non-triviel
14:16:12 <Toxaris> shapr: yes it does.
14:16:14 <zou> and "2001 Acura CL with navigation silver exterior and black interior - $8500 "
14:16:27 <Orphi> dons: for reference, what hardware do you have?
14:16:30 <zou> swiret: i want to extract year, make model, and mileage if possible
14:16:36 <swiert> zou: right. so you want to permute parsing a data, make, etc.
14:16:37 <SamB> you know, the turing test only works if both parties can allegedly speak a common language
14:16:43 <dons> Orphi: core 2 duo
14:16:57 <Orphi> dons: sweet.
14:17:02 <Orphi> expensive. but sweet!
14:17:05 <vininim> is works?
14:17:09 <vininim> *it works?
14:17:09 <Eelis> is there a reason why System.Console.Readline does not wrap rl_crlf ?
14:17:13 <swiert> zou: should be possible, if a bit hacky as your grammar isn't very well defined.
14:17:22 --- mode: shapr set -o shapr
14:17:26 <zou> that's the problem i have
14:17:33 <zou> the grammar is not well defined
14:17:39 <SamB> vininim: to whatever extent it works... it depends on a common language
14:17:48 <zou> that's why i was thinking permute
14:18:03 <Orphi> dons: anyway, thanks for all your help tonight.
14:18:09 <Orphi> dons: is there some place I can learn about Core?
14:18:29 <zou> swiert: any insight? i tried permute, it didn't work
14:18:46 <swiert> zou: did you get any sensible results?
14:19:04 <swiert> it shouldn't be too hard to parse a date and some flat text, for example.
14:19:50 <zou> here is my year and milegae parser
14:19:54 <zou> year :: Parser String
14:19:54 <zou> year = lexeme (do {
14:19:54 <zou>   ds <- try (count 4 digit) <|> count 2 digit
14:19:57 <zou>   ;return ds
14:20:00 <zou>   })
14:20:03 <zou>   <?> "error parsing year"
14:20:05 <desp> Can someone here give an opinion on Appel's "Modern Compiler Implementation in ML"?  I thought to buy it, but there are some unfavorable reviews on Amazon.
14:20:06 <zou>  
14:20:10 <zou> mileage :: Parser String
14:20:12 <zou> mileage = lexeme (do {
14:20:15 <zou>   ds <- many1 digit
14:20:18 <zou>   ;try (char 'K') <|> char 'k'
14:20:22 <zou>   ;many1 separator
14:20:22 <zou>   ;reserved "miles"
14:20:25 <zou>   ;return ds
14:20:29 <zou>   })
14:20:31 <swiert> zou: you may want to use hpaste.
14:20:32 <zou>   <?> "error parsing mileage"
14:20:35 <zou> here is the make and model
14:20:48 <zou> what is hpaste -- i'm new here
14:20:52 <byorgey> @hpaste
14:20:53 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:20:56 <byorgey> zou: ^^^ =)
14:21:02 <swiert> http://hpaste.org/new
14:21:22 <swiert> it's frowned upon to flood the channel with too much code.
14:21:28 <zou> ok, thanks
14:21:47 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/4440
14:21:47 <byorgey> but not too much frowning goes on if you're new and didn't know that =)
14:22:02 <SamB> zou: it's a good idea to fill in the nickname and title fields, too ;-)
14:22:26 <zou> ok, so i've pasted the permute parser
14:22:57 * Orphi surmises that dons has wandered off
14:23:31 <zou> i was thinking about a grammar like (year|make|model|milegae|other)*
14:24:08 <SamB> desp: this first review looks favorable to ME ;-)
14:24:24 <Orphi> oh well, I'm off now peeps.
14:24:27 <Orphi> TY for the help...
14:24:35 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/4441
14:24:37 <desp> SamB: :)
14:24:54 <zou> and have the above
14:25:23 <zou> it didn't work either
14:25:28 <SamB> and only 1 in 4 found the second one helpful..
14:25:36 <zou> swiert: any insight?
14:26:30 <swiert> zou: so what goes wrong, exactly? No parse?
14:27:06 <zou> yep, no parse
14:27:09 <zou> *Main> parseTest car "honda great condition 87k miles "
14:27:09 <zou> parse error at (line 1, column 33):
14:27:09 <zou> unexpected end of input
14:27:09 <zou> expecting error parsing year, error parsing mileage, error parsing car model, identifier or error parsing car make
14:27:12 <zou>  
14:28:08 <mwc> @seen dcoutts
14:28:08 <lambdabot> dcoutts is in #haskell, #ghc, #haskell-overflow and #gentoo-haskell. I last heard dcoutts speak 23m 51s ago.
14:28:42 <zou> swiert: is the parser done the right way?
14:29:09 <mwc> so dcoutts, now that 6.8.2 is out, how soon can it get into gentoo? I'm really interested in how the shootout benchmarks will be affected
14:29:09 <SamB> desp: it seems like almost everyone is saying the same thing:
14:29:25 <SamB> it's a good book, but not an introduction to compilers or to ML...
14:29:56 <monochrom> SamB: which book?
14:30:07 <SamB> monochrom: Compiler Implementation in ML
14:30:28 <SamB> er.
14:30:30 <SamB> add a Modern
14:30:46 <dons> so would there be interest in a couple of blog posts about using stream fusion in practice?
14:30:52 <dons> how it works, what to expect?
14:30:57 <dcoutts> mwc: working on it
14:30:58 <dons> beyond just the papers..
14:30:58 <conal> definitely!
14:31:25 <mwc> dcoutts, excellent. /me compares GHC to C, starts pressing reload
14:31:29 <dons> since people seem to keep tossing up problems that are nicely solved using the stream-fusion package. so that suggests experience with it needs to be passed on
14:31:33 <dons> conal: ok.
14:31:39 <swiert> zou: I can't find an obvious fault with it...
14:31:42 <monochrom> It is certainly not intended to teach ML. It assumes ML. But I find it a good compiler book. Probably a reason is I find it succint, right to the mustard, no wordiness. Probably also exactly a reason other people are dissatified, they like long-windedness.
14:31:59 <conal> :)
14:32:20 <mwc> monochrom, another complaint/pro about it I've heard is that it doesn't spend a lot of time discussing deep theoretical things. Just presents an algorithm, a signature, and says go implement
14:32:22 <SamB> well, personally, I think hanging around #haskell is probably a decent introduction to compilers in itself...
14:32:44 <swiert> zou: but I think the real problem is that the language isn't defined well enough. You end up doing natural language processing stuff, which I imagine doesn't sit well with the parser combinator approach.
14:33:14 <mwc> monochrom, Appel was more interested in using it to teach a course than as a reference
14:33:14 <RayNbow> <dons> so would there be interest in a couple of blog posts about using stream fusion in practice? <-- yes, that would be nice :)
14:34:00 <SamB> mwc: hmm, I don't know that I'd want to take his course ;-)
14:34:13 <SamB> but that doesn't mean it isn't a good book
14:34:43 <mwc> I had a buddy who did CS at princeton
14:34:49 <zou> swiert: that's what i'm afraid. so is there a way to just use parsec's tokenizer and write the parser myself? or is there another way to do parsing with haskell?
14:34:56 <mwc> I never asked him if he did compilers with Appel
14:35:14 <mwc> zou, you could break it into words using words...
14:35:21 <monochrom> Yeah. When I wanted to look up generational garbage collection, I opened Appel and found a two-page description. That's enough for my purpose. If I wanted to learn more, it has bibliography and I know where to find more papers too.
14:35:31 <mwc> > words "The quick brown fox"
14:35:32 <SamB> my guess is that most courses don't use it, or it would have worse reviews on amazon ;-)
14:35:32 <lambdabot>  ["The","quick","brown","fox"]
14:35:48 <mwc> SamB, hah
14:35:56 <mwc> I should look up my advisor's book on amazon
14:36:20 <desp> monochrom: That's great.
14:36:20 <zou> mwc: tried that, the probelm is there are cases like "Camery LE"
14:36:31 <mwc> Ouch, 98 bucks.
14:36:44 <zou> mwc: which seems to require look ahead
14:36:55 <desp> monochrom: Do you have any comments about editing or errors?
14:37:12 <monochrom> No.
14:37:33 <mwc> zou, I don't know how you'd handle that
14:38:01 <mwc> you'd have to write a parser that could recognize "Camry LE", "Camery LE" if you want it to be somewhat robust in the face of spelling errors
14:38:19 <mwc> ("Camry" is the spelling in Canada, don't know about elsewhere)
14:38:53 <SamB> monochrom: does that mean you don't remember noticing errors?
14:38:57 <monochrom> I managed to buy my copy when books were cheap. :)
14:39:09 <SamB> when was that?
14:39:11 <swiert> zou: you could hack up something using "words", removing words from the list once you manage to parse a date, for instance.
14:39:21 <swiert> zou: and then try to make some kind of sense of what's left...
14:39:51 <monochrom> I don't remember noticing errors. I am also not comprehensive in reading the whole book.
14:39:57 <zou> mwc: so if parsec isn't the right apporch, what else can you write a parser with
14:40:29 <monochrom> I bought it at least 5 years ago.
14:40:59 <SamB> what do you mean by cheap?
14:41:11 <mwc> zou, I don't think you want to write a parser
14:41:26 <monochrom> Like cdn$70
14:41:27 <mwc> what I mean is that a parser seems the wrong thing to try and solve this
14:41:37 <mwc> parsers are meant for regular languages
14:41:50 <SamB> monochrom: how much was that in USD at the time?
14:41:55 <mwc> zou, I think what you want to do is first make a list of words using words
14:42:07 <monochrom> Most likely us$50-60.
14:42:10 <SamB> oh, but I guess that might not matter...
14:42:14 <zou> swiert: removing the ones that you've parsed?
14:42:22 <mwc> then you could try going over that list and fusing some of the words together if they seem to belong together
14:42:31 <swiert> zou: yes.
14:42:31 <mwc> then when you're done, treat it like a bag of words
14:42:40 <zou> mwc: i've tried that, but hit the problem of like "camery le" or "4 door"
14:43:08 <swiert> zou: I agree with mwc. You're not really parsing a formal language.
14:43:10 <vininim> listenOn (PortNumber 9995) >>= sClose
14:43:24 <SamB> interesting, Amazon lists Webster's Dictionary as a key phrase in the book...
14:43:30 <vininim> now I completly understand Network!
14:44:03 <vbx> did you guys see this video of the haskell game monadius?
14:44:04 <vbx> http://www.youtube.com/watch?v=zqFgQiPKtOI
14:44:04 <lambdabot> Title: YouTube - Monadius Game Play
14:44:08 <mwc> something like: combine (x:y:ws) | isModelName x && isModelTrim y = ((x ++ ' ':y) : combine ws)
14:44:38 * SamB adds the book to his wishlist
14:45:22 <zou> swiert/mwc: a grammar like (year|make|model|milegae|other)*  isn't good?
14:45:59 <zou> :t combine
14:46:01 <lambdabot> Not in scope: `combine'
14:46:32 <mwc> zou, I was giving you an example of what such a function would look like
14:46:48 <mwc> the idea is that you recognize word pairs that should belong together, and fuse them
14:47:35 <mwc> combine (x:y:ws) | isModelName x && isModelTrim y = combine ((x ++ ' ':y)  ++ ws)
14:47:49 <mwc> in case the next word after Camry LE is something like 4-door
14:48:27 <mwc> so the first pass would convert ["Camry", "LE", "4-door"] to ["Camry LE,"4-door"], and thence to ["Camry LE 4-door"]
14:50:18 <hpaste>  Mitar pasted "split line?" at http://hpaste.org/4442
14:52:53 <zou> mwc: what if it's "4 door", i guess i would have to have a corpus for these?
15:00:39 <mwc> I guess so
15:01:04 <mwc> zou, I think you'd want to sanitize some things like "4 door" into a regular form like "4-door"
15:01:37 <mwc> "Camery" -> "Camry", "Acord" -> "Accord", etc.
15:08:33 <Mitar> how can i break a line for lhs2tex?
15:09:15 <swiert> Mitar: can you be a bit more specific?
15:09:27 <Mitar> i have a long line
15:09:27 <Mitar> http://hpaste.org/4442
15:09:47 <Mitar> and it goes over the page border
15:09:55 <Mitar> (i use poly style)
15:10:13 <Mitar> so how can I make it two lines but that it is still idented correclty?
15:10:20 <Mitar> s/ident/indent/
15:10:36 <zou> mwc: how do you sanitize ? i.e., i'd have a data map or table as dictionary, but '4 door' are two words that can't be used as keys
15:12:11 <mwc> zou, you'd write a function that would consume the list and transform recognized patterns that mean the same thing into a 'canonical' form.
15:12:21 <mwc> then you can work from that canonical form
15:13:03 <hpaste>  swiert annotated "split line?" with "(no title)" at http://hpaste.org/4442#a1
15:13:20 <swiert> Mitar: does that look better?
15:16:10 <hpaste>  Mitar annotated "split line?" with "not really" at http://hpaste.org/4442#a2
15:17:50 <swiert> Mitar: try writing it the last way in the code.
15:18:12 <swiert> Mitar: you need to indent by two spaces in order for lhs2TeX to help you with the code formatting.
15:19:03 <Mitar> does not work ..
15:19:31 <Mitar> it reindent everything ..
15:21:27 <Mitar> it works in math mode ..
15:21:34 <Mitar> but in poly it reworks the code
15:22:03 <hpaste>  swiert annotated "split line?" with "(no title)" at http://hpaste.org/4442#a3
15:22:18 <swiert> Mitar: that any better?
15:23:53 <Mitar> sadly ... not
15:24:43 <hpaste>  wellwisher pasted "help defining shiftMyIP" at http://hpaste.org/4443
15:24:51 <wellwisher> ?
15:25:04 <Mitar> aha, it is in manual
15:25:06 <Mitar> i will read that
15:26:16 <Saizan> ?type alloca
15:26:18 <lambdabot> Not in scope: `alloca'
15:26:29 <Saizan> ?type Foreign.Marshal.alloca
15:26:30 <lambdabot> forall a b. (Foreign.Storable.Storable a) => (GHC.Ptr.Ptr a -> IO b) -> IO b
15:27:22 <ricky_clarkson> shapr: You asked me what language you should try next, and what the most commercial language of them all is.. so I said Excel is calling you.
15:27:43 <ricky_clarkson> ..do you understand now?
15:27:54 * ricky_clarkson needs to put shapr in Cont.
15:29:47 * glguy wonders if this conversation that ricky_clarkson is having isn't a bit one-sided..
15:29:57 <Pseudonym> A delimited continuation will slow him down.
15:30:12 <Saizan> wellwisher: something like: unsafePerformIO . alloca $ \ptr -> poke ptr ip >> peek (shiftIP ptr)
15:30:48 <Pseudonym> I've been using Haskell for how long... and I don't understand Saizan's code.
15:31:12 <Pseudonym> Maybe my eyes just glaze over when I see peek and poke.
15:31:32 <hpaste>  Mitar annotated "split line?" with "correct" at http://hpaste.org/4442#a4
15:32:14 <Saizan> ?type peek
15:32:14 <lambdabot> Not in scope: `peek'
15:32:23 <Saizan> ?type Foreign.Marshal.peek
15:32:23 <lambdabot> Not in scope: `Foreign.Marshal.peek'
15:32:31 <swiert> Mitar: but then "samples" and "age_values" won't line up...
15:32:45 <Mitar> true ...
15:32:52 <Mitar> so you have to add two spaces also there
15:33:04 <Mitar> i have been playing just with first let element
15:34:48 <Mitar> is it possible to get line numbering?
15:35:26 <shapr> ricky_clarkson: Ah, yes. But it looks like I'll try C# instead.
15:35:38 <shapr> Hiya TuringTest
15:35:44 * TuringTest waves back
15:35:54 <oerjan> it's a bot!
15:35:55 <shapr> How's code?
15:36:15 <ricky_clarkson> I heard F# is a much more agreeable code.
15:36:16 <ddarius> shapr: C# is not too bad.
15:36:20 <ricky_clarkson> chord
15:36:40 <TuringTest> shapr: I have no time to do much writing of Haskell packages
15:36:41 <shapr> ddarius: That's good to hear.
15:38:44 <ricky_clarkson> glguy: It was a conversation which proceeded very slowly with one side forgetting that it had started.
15:39:37 <wellwisher> how do you convert a UCChar to a Char?
15:39:46 <wellwisher> how do you convert a CUChar to a Char?
15:39:59 <glguy> oh, I see
15:40:04 <ricky_clarkson> @hoogle CUChar -> Char
15:40:05 <lambdabot> No matches, try a more general search
15:40:14 <glguy> how do you convert a CCUhar to a Char?
15:40:22 <ricky_clarkson> @bab es en esCUChar
15:40:23 <lambdabot>   to esCUChar
15:40:23 <vininim> @type  let {tru = \ t -> \ f -> t; fls = \t -> \ f -> f; and = \ b -> \ c -> b c fls;} in and <$> [(tru fls),(fls fls),(tru tru)]
15:40:24 <lambdabot> forall t t1. [((t -> t1 -> t1) -> (t -> t1 -> t1) -> t -> t1 -> t1) -> (t -> t1 -> t1) -> t -> t1 -> t1]
15:40:31 <ricky_clarkson> @bab es en escuchar
15:40:32 <lambdabot>   to listen
15:41:43 <Mitar> how could i get line number in lhs2tex?
15:41:44 <TuringTest> wellwisher: CUCHar is an Enum....
15:41:59 <Saizan> ?ty let {tru = \ t -> \ f -> t; fls = \t -> \ f -> f; and = \ b -> \ c -> b c fls;} in uncurry and <$> [(tru, fls),(fls, fls),(tru, tru)]
15:42:00 <lambdabot> forall t. [t -> t -> t]
15:42:04 <TuringTest> wellwisher: And CUChar is an Integral....
15:43:47 <TuringTest> wellwisher: (toEnum . fromEnum) :: CUChar -> Char
15:44:01 <TuringTest> wellwisher: ALSO (toEnum . fromEnum) :: Char -> CUChar
15:47:16 <conal> thestarslookdown: neat nick.
15:47:49 <thestarslookdown> It's a Rush song.
15:53:50 <vininim> > let {tru = \ t -> \ f -> t; fls = \t -> \ f -> f; and = \ b -> \ c -> b c fls;} in  (\ x -> x True False)  <$> (and <$> [(tru fls),(fls fls),(tru tru)])
15:53:51 <lambdabot>  Couldn't match expected type `(t -> t1 -> t1) -> Bool -> Bool'
16:02:54 <ac> is there a command in ghci to see how many parameters a type class has?
16:03:08 <ac> like ":kind" for classes
16:04:34 <Saizan> ac: :info Class gives you the definition, too
16:06:07 <ac> Saizan: eeks, that dumps all the instances too, which is handy
16:12:14 <hpaste>  wellwisher pasted "Linking error" at http://hpaste.org/4444
16:13:18 <v3cw> Hello, quick question.
16:13:21 <wellwisher> why am i getting this error?
16:13:29 <v3cw> Is there a function to narrow an Integer down to an Int?
16:13:36 <allbery_b> on unixlike systems you generally need -l to come *last*
16:13:38 <v3cw> Can't seem to find one in the docs.
16:13:50 <allbery_b> because it's not so much n option as a macro which expands to a filename which is scanned in irder
16:13:58 <allbery_b> , in the order they're given
16:14:07 <dons> gwern: thanks for cleaning up the ro/haskell mistakes on the main page
16:14:17 <dons> he tends to edit a bit over enthusiastically
16:14:24 <wellwisher> toEnum $ fromEnum ( a:: Integer) :: Int
16:14:39 <allbery_b> so the linker sees the -lbuzz first, decides it doesn't need anything from it *right tne*, goes on to link the other files, then falls over on the missing symbol that should come from -lbuzz
16:14:42 <Saizan> v3cw: fromIntegral
16:14:51 <v3cw> Oh wait, I just saw fromInteger.
16:14:55 <v3cw> Heh.
16:14:58 <gwern> dons: no kidding. I don't really understand why he put it on the mainpage *and* talk
16:15:01 <v3cw> It was right in front of me, too.
16:15:21 <v3cw> Ok, bye.
16:15:23 <dons> gwern: i think he's not very familiar with wikis, or who the readers are
16:16:00 <wellwisher> allbery_b: sounds like thats what it is doing
16:16:05 <gwern> dons: it might be language issues if he's romanian
16:16:18 <allbery_b> so move the -lbuzz to be last, after all the Haskell files
16:16:59 <allbery_b> so it will be scanned after the Haskell files, and ld will have the undefined symbol reference when it scans -lbuzz
16:17:30 <wellwisher> allbey_b: same error
16:17:32 <gwern> http://lists.wikimedia.org/mailman/htdig/wikien-l/2007-September/081128.html <-- you know, I think I am going to pay a lot more attention to Durin's emails from now on
16:17:37 <gwern> gah. mischan
16:17:55 <gwern> (I'm really starting to wonder whether multiple windows in irssi is a good idea)
16:19:40 <allbery_b> hm.  what kind of system is this?
16:20:57 <wellwisher> i am working in windows XP
16:21:07 <wellwisher> ghc 6.8.1
16:21:22 <allbery_b> hrm.  case independent filesystem.  you can't have Buzz.hs and buzz.c because they both produce buzz.o
16:21:37 <allbery_b> (Buzz.o and buzz.o are the same file)
16:22:05 <allbery_b> depending on what order thinsg are done you may end up with the wrong one in the archive
16:22:47 <allbery_b> it is not something I would want to rely upon.  try making it buzzlib.c / buzzlib.o instead and see if it behaves better
16:23:11 <allbery_b> (beyond that, well, I'm not a windows / mingw expert, hopefully someone else here will have ideas)
16:25:08 <wellwisher> yah it was the buzz.o mixup
16:26:34 <mwc> hey, is my fear of ++ irrational?
16:26:49 <dons> yes and no.
16:27:51 <mwc> I tend to build up strings for output using "shows foo . showChar "\t" . shows bar . showChar '\t' $ show baz
16:28:00 <mwc> rather than use ++
16:28:18 <mwc> but I can't give a good reason why ++ should be any worse, given lazyness
16:29:39 <allbery_b> it has to re-traverse the same string every time it (++)s?
16:29:41 <oerjan> if it really wasn't better, then it wouldn't make sense to use it in the Show class...
16:29:49 <dons> dcoutts_: should cc-options and ld-options in a .buildinfo file be propagated to all stanzas?
16:30:40 <sioraiocht> anyone mind answering a question about some basic theorem proving?
16:30:41 <dcoutts> dons: hmm, not sure
16:31:04 <mwc> @src (++)
16:31:04 <lambdabot> (++) []     ys = ys
16:31:04 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
16:31:05 <allbery_b> just ask, if someone has time and an answer they'll jump in
16:31:05 <dons> dcoutts: otherwise, my .buildinfo files for finding C libs on bsd fail to build executable stanzas with linking errors
16:31:21 <clanehin> if it's just a one-line string, "Hey user guy here's some output", go ahead and use ++.  Don't use ++ for any kind of complicated string manipulation algorithm.
16:31:22 <dons> dcoutts:  and i have to manually add cc-options/ld-options to the .cabal file in the right stanza
16:31:25 <mwc> allbery_b, doesn't that mean that it doesn't traverse the entire list?
16:31:29 <mwc> (++) is infixr
16:31:29 <dcoutts> dons: I see
16:31:44 <blackdog> i want to lazily build a memoizing table - is this what tying the knot is about?
16:31:55 <dons> while the buildinfo+configure mechanism inserts CPPFLAGS /LDFLAGS into the buildinfo file, which then works happily when linking libraries
16:31:58 <mwc> so only something like a fold that traverses the entire list would actually trigger that list following
16:32:06 <mwc> otherwise its sitting around as a more or less `inert' thunk
16:32:09 <TuringTest> blackdog: Only if it recursively constructed...
16:32:22 <allbery_b> hm?  xs ++ ys will recurse over all of xs before tacking ys onto the end
16:32:41 <blackdog> TuringTest: yeah, it is. that's what's been breaking my brain
16:32:54 <mwc> allbery_b, only when its forced
16:32:56 <allbery_b> whereas if you use composition in place of a bunch of (++)s you pass over each string once.
16:33:02 <allbery_b> so?
16:33:14 <TuringTest> blackdog: What is it?  Can you describe it on http://hpaste.org ?
16:33:24 <mwc> so if you finally force it by outputting, you have to traverse the entire string once anyways
16:33:26 <allbery_b> xs ++ ys ++ zs will still pass over xs twice, and it gets worse for longer chains.
16:33:37 <mwc> allbery_b, hmmm
16:33:44 <mwc> I'm trying to see that
16:33:47 <mwc> it's infixr though
16:33:50 <allbery_b> (unless laziness causes the end of the string to be dropped)
16:33:52 <TuringTest> allbery_b: xs ++ (ys ++ zs) is fine.
16:33:57 <mwc> xs ++ (ys ++ zs)
16:34:02 <allbery_b> hm
16:34:12 <TuringTest> allbery_b: (xs++ys) ++ zs is poor
16:34:18 <allbery_b> yeh
16:34:30 <allbery_b> guess it depends on how you build up the (++) chain
16:34:58 <allbery_b> a straight xs ++ ys ++ zs will be okay; composing them could force left association
16:35:04 <hpaste>  wellwisher annotated "Linking error" with "Segmentation fault" at http://hpaste.org/4444#a1
16:35:08 <mwc> allbery_b, that's true
16:35:22 <sioraiocht> using the resolution rule, form (A and C), ((not A) or D) to derive (C or D)?
16:35:22 <oerjan> allbery_b: however, isn't that true for . as well?
16:35:53 <blackdog> TuringTest: hold on, i'll clean it up and paste
16:36:03 * TuringTest holds on
16:36:33 <dcoutts> dons: ah, you're probably only filling out the library part of the HookedBuildInfo, you want to fill out the appropriate info for the executables too
16:36:36 <dcoutts> dons: type HookedBuildInfo = (Maybe BuildInfo, [(String, BuildInfo)])
16:36:47 <dcoutts> dons: you're probably only filling out the fst component there
16:36:51 <sioraiocht> wait..ignore that question
16:36:56 <sioraiocht> that's not what i want to ask -_-
16:37:10 * TuringTest is sad that he cannot upgrade to ghc-6.8.x on his powerpc OS X 10.5 computer.
16:37:21 <dcoutts> TuringTest: because?
16:37:41 <TuringTest> dcoutts: It does not really work.  There are all kinds of new and shiny bugs
16:38:01 <dons> dcoutts: what does that map to in a .buildinfo file?
16:38:02 <dcoutts> TuringTest: did no osx person test it before the release?
16:38:16 <TuringTest> dcoutts: The OS X 10.4 works.
16:38:33 <TuringTest> dcoutts: The OS X 10.5 update was right before 6.8.1 was released.
16:38:35 <dcoutts> dons: probably separate stanzas, try filling in a HookedBuildInfo and calling writeHookedBuildInfo
16:38:37 <dons> you sure 6.8.2 powerpc hasn't been fixed?
16:38:53 <mwc> dons, there might not be any PPC OS X user with 10.5 installed
16:38:56 <TuringTest> dons: It has my patch, but I don't think it fixed everything
16:39:34 <TuringTest> Here is a current ghc on 10.5 / powerpc bug: http://hackage.haskell.org/trac/ghc/ticket/1958
16:39:35 * mokus has had no luck with 6.8.2 on ppc
16:39:35 <lambdabot> Title: #1958 (collect2: ld terminated with signal 10 [Bus error]: Building parsec on a  ...
16:39:49 <wellwisher> any help with my seg fault 4444#a1?
16:40:06 <mokus> got it to build, but thing compiled with stage2 ghc-inplace segfault
16:40:17 <mwc> hmmmmm
16:40:18 <mwc> http://darcs.haskell.org:8010/
16:40:19 <lambdabot> Title: Index of /
16:40:25 <mwc> doesn't list what version of OS X we're running
16:40:37 <allbery_b> I have to punt on that, sorry
16:41:06 <hpaste>  blackdog pasted "(no title)" at http://hpaste.org/4445
16:41:56 <blackdog> TuringTest: yeah, am with you there. i have 6.8.1 and am missing ghci pretty badly
16:43:08 <dcoutts> TuringTest: surely ld getting a bus error is a bug in ld?
16:43:10 <TuringTest> The odd thing is that ghc-6.8.1 triggered errors from 'ld' in OS X 10.5 that google showed were unique to ghc.
16:43:28 <mwc> dcoutts, I think you're correct
16:43:40 <TuringTest> dcoutts: I think ghc writes assembly code that is illegal (in some sense).
16:43:51 <mwc> TuringTest, I suspect ghci tickles LD in ways that break it, and apple never tested those corner cases
16:43:58 <dcoutts> TuringTest: does it only happen with -fasm or with -fvia-C too?
16:43:59 <TuringTest> dcoutts: I changes ghc's assembly generation in my patch to fix the previous error
16:44:20 <TuringTest> dcoutts: fvia-C seems to work...
16:44:51 <TuringTest> s/changes/changed/
16:46:02 <sioraiocht> okay, better question---- I have a statement that ends up being A(x1) AND B(x1) after being converted to CNF, that means it can actually be treated as two separate statements for the purpose of resolution theorem proving, right?
16:46:14 <TuringTest> the odd thing is that I don't program in assembly, and I hadn't patched GHC before.  But the ghc source was quite clear and easy to understand.
16:48:04 <TuringTest> mwc: I see a few OS X 10.5.1 that on http://darcs.haskell.org:8010/ that are failing to build HEAD
16:48:05 <lambdabot> Title: Index of /
16:49:29 <njbartlett_> dcoutts: Hi, I've been trying to get that gtk-macosx stuff working with Gtk2hs. Unfortunately not got very far because gtk-macosx itself doesn't build. Somebody broke one of the dependent libraries
16:49:53 <oerjan> blackdog: Maps are finite so you would have to decide on what range you want to memoize
16:50:18 <dcoutts> njbartlett_: ho hum
16:50:39 <dcoutts> njbartlett_: which dependent lib btw?
16:50:44 <njbartlett_> dcoutts: http://developer.imendio.com/node/183
16:50:46 <lambdabot> Title: glib build failure due to gio change | Imendio Developer Pages
16:50:48 <njbartlett_> dcoutts: glib
16:50:51 <dcoutts> ah ok
16:51:08 <blackdog> oerjan: ah, that's a point. i might be better off explicitly memoizing rather than trying to be tricky.
16:51:36 <mwc> TuringTest, I couldn't tell what OS version they were on
16:51:57 <oerjan> blackdog: i thought the trick you wanted _was_ memoizing
16:52:11 <njbartlett_> dcoutts: wxhaskell has started to update to the latest wxWidgets. It now compiles on Mac OS X 10.5... can't run the sample apps yet but compiling is a start :-)
16:52:19 <oerjan> also, it is possible to create infinite Map equivalents, e.g. tries
16:52:21 <TuringTest> I clicked on the system link and saw http://darcs.haskell.org:8010/tnaur%20PPC%20OSX%20stable%202 and http://darcs.haskell.org:8010/tnaur%20PPC%20OSX%20head%202
16:52:47 <dcoutts> njbartlett_: great, I look forward to a release so we can get it into gentoo
16:53:12 <TuringTest> blackdog: One often uses a Trie data structure instead of a map for memoizing things
16:53:41 <blackdog> oerjan: yes. sorry, imprecise. i mean that it would be nice to have a Map interface that would handle any request and do the appropriate amount of work, but if i'm going to have to put bounds on it anyway, i might as well just write a little wrapper to check if the desired key is in the map already
16:54:12 <blackdog> TuringTest: how does that help?
16:54:25 <oerjan> blackdog: as i said, tries can be infinite
16:54:41 <TuringTest> blackdog: It can represent an infinite list of "keys"
16:54:58 <blackdog> ah, ok. haven't used them much before, thanks for the pointer.
16:55:12 <oerjan> unfortunately last i checked there was no _infinite_ trie implementation on hackage
16:55:21 <oerjan> although some finite ones
16:56:20 <TuringTest> I usually just write the specific Trie I need as a special case.  That way I can exploit the structure of the keys.
16:57:01 <blackdog> the structure of my key is just two integers - how would a trie work there? i've only used them for strings.
16:57:26 <oerjan> convert the key to a list first
16:57:38 <oerjan> e.g. show would work fine for Integers
16:57:38 <TuringTest> For example: My regex-tdfa packages generates a DFA from an NFA.  One DFA state is a merging of a set of NFS states.  So I look up the DFA state I need in a specialized Trie where the keys are sorted lists of NFS states to be merged.
16:57:57 <TuringTest> blackdog: What are the bounds of the integers?
16:58:06 <blackdog> unbounded
16:58:22 <TuringTest> Integer -> [Word8] in little-endian order
16:58:25 <bos> TuringTest: are you chris kuklewicz?
16:58:30 <TuringTest> bos: Yup
16:58:34 <blackdog> i would like it to work until i run out of memory :)
16:58:46 <bos> cool! i don't recall seeing you on here before.
16:59:06 <TuringTest> bos: I only show up when I don't want to sleep yet...
16:59:16 <bos> heh
17:03:03 * TuringTest wants to go to sleep
17:03:06 <TuringTest> bye
17:04:22 <glguy> bos, why did mmcgrath produce a different 6.8.2 rpm than you on koji?
17:04:33 <glguy> should I just be using the one with the biggest version number?
17:05:05 <bos> glguy: the ppc build server was broken last night and causing builds to fail spuriously. i assume he just kicked off a new one when he fixed it up.
17:05:20 <glguy> oh, ok
17:05:53 <glguy> so you just publish the .spec file and the build server handles the rest?
17:06:32 <bos> yes
17:10:11 <Liskni_si> hm, if build on koji fails, there should be no reason to bump version to build it again
17:11:07 <bos> it didn't get bumped
17:11:24 <dons> ?where bytestringparsec
17:11:24 <lambdabot> I know nothing about bytestringparsec.
17:11:28 <dons> ?where bytestring-parsec
17:11:28 <lambdabot> I know nothing about bytestring-parsec.
17:11:35 <Liskni_si> oh, ok then :)
17:11:40 <dons> ?where parsec-bytestring
17:11:40 <lambdabot> I know nothing about parsec-bytestring.
17:11:42 <dons> boo
17:11:46 <dmwit> ?go bytestring parsec
17:11:47 <lambdabot> http://www.haskell.org/haskellwiki/Hac_2007_II
17:11:47 <lambdabot> Title: Hac 2007 II - HaskellWiki
17:11:53 <dcoutts> dons: ask xerox
17:11:55 <glguy> oh, maybe I just interpreted what I was looking at incorrectly
17:14:34 <dons> dcoutts: bytestring-readp looks fairly nice, but maybe too high level.
17:14:48 <dons> i want something around Data.Binary in performance, to work with :)
17:14:52 <dcoutts> dons: readp has no error message support
17:14:57 <dons> that too.
17:15:01 <dcoutts> dons: try polyparse
17:15:20 <dons> the code is nice, for readp bytestring.
17:15:39 <dcoutts> dons: that's malcolmw's parser lib, from what he said it sounded like it has nice properties
17:16:06 <dcoutts> dons: the main idea is that you get proper compositional <|> by default unlike parsec
17:16:10 <dons> yeah. ok.
17:16:33 <dcoutts> dons: but unlike readp which has full backtracking <|>, it allows putting in commit or cut points
17:16:48 <dcoutts> dons: so one can start with a correct parser and then performance tune it later
17:16:57 <dcoutts> that's the theory anyway
17:17:01 <dons> mmm.
17:17:38 <dcoutts> where as one can see parsec's approach as being a premature optimization, defaults to 1 char lookahead with try to restore it
17:18:01 <dcoutts> but that looses compositionality and I've seen newbies and experts alike confused by it
17:19:57 <shivernz> what would be the best way to take two lists and generate a new list out of the items in the first list, which doesn'
17:20:02 <shivernz> doesn't exist in the 2nd list
17:20:16 <shivernz> don't*
17:20:26 <dmhouse> > [1..10] \ [2, 4, 7]
17:20:26 <lambdabot>  Parse error at "\" (column 9)
17:20:37 <dmhouse> > [1..10] / [2, 4, 7]
17:20:38 <lambdabot>   add an instance declaration for (Fractional [t])
17:20:38 <lambdabot>     In the expression: ([1...
17:20:44 <dmhouse> Err...
17:20:46 <mauke> > [1..10] \\ [2,4,7]
17:20:47 <lambdabot>  [1,3,5,6,8,9,10]
17:20:54 <dmhouse> Yeah, that one. Can never remember its name.
17:20:59 <Liskni_si> > let a \\\ b = filter (not . (`elem` b)) a in [1,2,3,1,2,3] \\\ [2]
17:20:59 <lambdabot>  [1,3,1,3]
17:21:01 <dmhouse> Odd symbol choice.
17:21:11 <Liskni_si> > [1,2,3,1,2,3] \\ [2]
17:21:11 <lambdabot>  [1,3,1,2,3]
17:21:24 <shivernz> sweet, thanks guys
17:21:24 <lucca> like \ for set difference?
17:21:29 <Liskni_si> \\ is not a set difference.
17:21:30 <lucca> ...kinda
17:21:47 <dmhouse> Hmm, perhaps.
17:22:14 <shivernz> what module implements \\?
17:22:19 <shivernz> doesn't seem to be prelude?
17:22:25 <Liskni_si> Data.List
17:22:37 <shivernz> thanks again
17:24:03 <chessguy> @hoogle (\\) -- this will tell you
17:24:04 <lambdabot> Hoogle Error: Parse Error: Unexpected character '-- this wi'
17:24:07 <chessguy> bah
17:24:12 <chessguy> @hoogle (\\)
17:24:13 <lambdabot> Did you mean: (\\)
17:24:13 <lambdabot> Prelude.undefined :: a
17:24:13 <lambdabot> Control.Monad.State.Class.get :: MonadState s m => m s
17:24:19 * chessguy sighs
17:24:22 <shivernz> lol
17:24:23 <mauke> @hoogle \\
17:24:23 <lambdabot> Hoogle Error: Parse Error: Unexpected character '\\'
17:24:27 <chessguy> hoogle--
17:24:32 <mauke> @index (\\)
17:24:33 <lambdabot> bzzt
17:24:36 <mauke> @index \\
17:24:36 <lambdabot> bzzt
17:24:44 <chessguy> @type Data.List.(\\)
17:24:45 <lambdabot> Couldn't find qualified module.
17:24:46 <mauke> index--
17:24:51 <dmhouse> ?type (Data.List.\\)
17:24:52 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
17:25:07 <shivernz> hurray
17:25:09 <shivernz> dmhouse, wins
17:25:25 <shivernz> no wait... we wanted to know the library first
17:25:45 <dmhouse> http://haskell.org/ghc/docs/latest/html/libraries/doc-index.html :)
17:25:51 <shivernz> :D
17:42:20 <cconnett> has anyone noticed that in ghci 6.8.2, readline counts blank lines in the command history?
17:44:05 <gwern> I just did. huh. that's not good.
17:46:39 <dcoutts> @arr!
17:46:39 <lambdabot> Avast!
17:46:46 <dcoutts> cabal-1.2.3.0 is in gentoo now
17:47:05 <dcoutts> which opens the way for goodies like ghc-6.8.2 and xmonad-0.5
17:47:39 <zeeeee> dcoutts, do you know what the status of things is for ubuntu?
17:48:09 <dcoutts> zeeeee: it tracks the debian stuff slowly, so ask the debian haskell maintainers
17:48:21 <dcoutts> zeeeee: well, actually don't ask them, they're very busy :-)
17:49:49 <dcoutts> zeeeee: ubuntu has quite a big lag time for haskell stuff, they just grab it occasionally from debian. As far as I know, there's nobody who specifically handles the haskell packages for ubuntu.
17:50:20 <thetallguy> dcoutts: we hope to provide more current repositories
17:50:51 <dcoutts> thetallguy: we being?
17:50:58 <thetallguy> http://seereason.org/ubuntu/
17:50:58 <lambdabot> Title: Index of /ubuntu
17:51:15 <dcoutts> ah, a third party repo for ubuntu
17:51:35 <thetallguy> Well, we wrote an autobuilder for debian packages while at Linspire
17:51:42 <thetallguy> we're continuing to maintain it.
17:51:46 <dcoutts> great
17:52:00 <thetallguy> we can build packages against debian, ubuntu or both
17:52:06 <dcoutts> nice
17:52:19 <thetallguy> Last we checked, extralibs wasn't packaged properly
17:52:24 <thetallguy> so we've been waiting
17:52:44 <thetallguy> but we'd ultimately like to have Cabal -> DebSource
17:52:54 <dcoutts> thetallguy: right, that's what we do
17:53:08 <dcoutts> generating .ebuild files from .cabal packages off of hackage
17:53:11 <thetallguy> and just run a nightly build, with dist-$(date) showing up every day
17:53:34 <thetallguy> Do you do it for Debian packages?
17:53:43 <thetallguy> or are you producing another format?
17:53:43 <dcoutts> thetallguy: for gentoo
17:53:46 <thetallguy> ah
17:54:00 <zeeeee> thetallguy, so you are maintaining a repository with the latest and greatest haskell packages? how may i use it? (maybe you can announce this!)
17:54:04 <thetallguy> So, stepcut has looked at this some, but last I talked with him about it there were gaps
17:54:16 <thetallguy> zeeee: that's the theory
17:54:28 <thetallguy> And it's in the HC&A report that I just submitted
17:55:11 <dcoutts> thetallguy: translating conditional dependencies is likely a bit tricky
17:55:11 <thetallguy> We're not quite there yet.  stepcut is spending this month hacking on the autobuilder to get it a bit more functional
17:55:27 <thetallguy> dcoutts: Aye, but we've hacked around that before.
17:55:39 * stepcut hears his name
17:55:42 <thetallguy> at worst you provide the solution you want
17:55:48 <thetallguy> Ah, here's the expert
17:55:57 <dcoutts> if you're generating binary packages you can just resolve all the conditionals first
17:56:25 <dcoutts> for ebuilds we have to translate the conditionals into gentoo's conditional package dep language
17:56:47 <dcoutts> which is a bit more limited than cabal's conditionals language
17:56:49 <stepcut> I have been hesitant to annouce the seereason repository until I update the version policy stuff in the autobuilder
17:58:05 <thetallguy> Yes, that's why I published it in the HC&A report
17:58:28 <thetallguy> Nothing like a user base to spur us forward.
17:58:30 <stepcut> heh
17:58:49 <thetallguy> Actually, I said something like, "we hope to..."
17:58:53 <thetallguy> so people wouldn
17:58:54 <stepcut> yeah, we need to make a bit more documentation for it too -- for example, enough to get david shuffleton started
17:58:58 <thetallguy> t duplicate effort.
17:59:49 <thetallguy> zeeeee, dcoutts: so we're getting there.
18:01:25 <dcoutts> thetallguy: this (semi-)automatic translation of cabal format to native formats was one of the goals of the cabal project, so it'd be useful to have feedback on it. There are a number of projects but I'm not sure of the real status of most of them.
18:02:11 <dcoutts> thetallguy: we tried to design the format/language so that it would translate
18:03:00 <zeeeee> is cabal-install in usable shape? if that works, then i'd probably opt to use that over any distro-specific packaging
18:03:07 <thetallguy> dcoutts: okay.  It's not our primary focus anymore, but it's something that we need as infrastructure, so we'll keep poking at it.
18:03:08 <dcoutts> zeeeee: partially
18:03:47 <dcoutts> thetallguy: well, if you have issues that you think are down to the design etc, voice them on the cabal-devel list
18:04:47 <thetallguy> Will do.  That's why I joined it.
18:05:07 <zeeeee> actually, how does cabal-install interact with distro packaging?
18:05:08 <dcoutts> zeeeee: cabal-install should be pretty good for per-user installs. Though it's obviously less good for packages that need native c libs that you don't have installed. That's where the native package managers are excellent.
18:05:34 <dcoutts> zeeeee: it does not interact with it at all, for global installs it defaults to /usr/local
18:06:16 <dcoutts> it's not at all clear how we should interact with the multitude of native package managers, it's a messy problem
18:06:22 <zeeeee> it is
18:07:26 <christine_c> hello people....
18:07:38 <shapr> Hiya christine_c, are you learning Haskell?
18:08:01 <christine_c> no, im confused with definition of knowledge based system, could anybody explains what are sample application of it?
18:08:07 <christine_c> please
18:09:35 <dcoutts> christine_c: perhaps there's a better channel for a question like that, like some logic programming channel perhaps
18:10:31 <dcoutts> christine_c: or try wikipedia for a starter http://en.wikipedia.org/wiki/Knowledge_based_system
18:10:39 <christine_c> i see, how will enter there will i type #logic
18:11:00 <shapr> christine_c: Probably /join #logic
18:11:24 <ddarius> Or perhaps #knowledgebasedsystems
18:12:05 <christine_c> knowledgebased channel doesnt exist, ok
18:12:30 * oerjan doesn't see a #logic channel listed.  and it wouldn't necessarily be on programming.
18:13:37 <christine_c> what application can we do using haskell? do we have application on it? can it do AI programs
18:13:56 <oerjan> @faq Can haskell to AI programs?
18:13:56 <lambdabot> The answer is: Yes! Haskell can do that.
18:14:17 <ddarius> @faq Can Haskell correct my grammar and spelling?
18:14:18 <lambdabot> The answer is: Yes! Haskell can do that.
18:14:55 <SamB> @faq can haskell murder my dog?
18:14:55 <lambdabot> The answer is: Yes! Haskell can do that.
18:15:07 <blackdog> @faq Can Haskellers be snarky about homework questions?
18:15:07 <lambdabot> The answer is: Yes! Haskell can do that.
18:15:08 <SamB> hmm, I'm not so sure I like that
18:15:25 <ddarius> Hey, I'd like Haskell to be able to do anything.
18:15:25 <blackdog> hm, think i have a type error there :)
18:15:39 <SamB> christine_c: we haven't figured out how to do AI programs at all yet have we?
18:16:09 <oerjan> @vixen Are you an AI program?
18:16:11 <lambdabot> am i a program? huh?
18:16:44 <ddarius> That was quite rude oerjan
18:16:48 <loupgaroublond> @faq can Haskell love me?
18:16:49 <lambdabot> The answer is: Yes! Haskell can do that.
18:16:53 <shapr> @vixen a/s/l ?
18:16:53 <lambdabot> 19/f/California
18:17:03 <blackdog> shapr: you hitting on my girl?
18:17:08 <shapr> ha
18:17:14 <shapr> blackdog: Wassup man?
18:17:25 <christine_c> i see, you can do a lot of haskell, ok, so good luck people
18:17:31 <oerjan> @vixen Sorry
18:17:31 <lambdabot> we get along well, you know?
18:17:32 <blackdog> eh, not much. sitting in a really crap cafe because it has internet access
18:17:34 <shapr> christine_c: Yes, Haskell is beautiful!
18:17:42 <shapr> christine_c: You should try it, it's lots of fun and powerful too!
18:18:07 <shapr> christine_c: Haskell can do any kind of application. But it's better at some types than others.
18:18:22 <blackdog> hm, parallelising memoizing programs is hard.
18:18:48 <christine_c> is it open source? do we have version for XP?
18:18:50 <SamB> shapr: what is a type that haskell is good it?
18:18:51 <shapr> christine_c: Commonly used apps in Haskell are: darcs, a revision control system; xmonad, a window manager; pugs, a perl6 implementation; um...
18:18:54 <SamB> er. s/it/at/
18:19:01 <shapr> SamB: forall a
18:19:15 * SamB was hoping for a marginally more interesting type than that
18:19:40 * SamB is at least glad that shapr used the joke setup properly...
18:19:47 <shapr> I'd say that Haskell has been used for algorithmic flavored math and logic programs more than anything else.
18:20:04 <loupgaroublond> didn't someone right cell phone software in it?
18:20:17 <christine_c> write
18:20:21 <ac> what's the syntax for deriving more than one type class?
18:20:23 <loupgaroublond> write
18:20:25 <loupgaroublond> yeah
18:20:34 <oerjan> ac: deriving (Show, Read)
18:20:35 <Saizan> ac: deriving (Foo,Foo2)
18:21:10 <ac> cool. I was trying "deriving Show, Eq"
18:21:27 <hpaste>  blackdog pasted "bog-ugly, but can you parallelise it?" at http://hpaste.org/4446
18:22:19 <hpaste>  blackdog pasted "bog ugly, but is it parallelisable?" at http://hpaste.org/4447
18:22:57 <blackdog> possibly someone needs to poke me and tell me to do some real work, but can anyone think of a way of parallelising that algorithm?
18:23:14 <sjanssen> blackdog: I think the problem is that you're building the map iteratively
18:23:43 <sjanssen> start with: Map.fromList [(i, solve i) | i <- [low .. high]]
18:24:08 <blackdog> yeah, it was the limited range that was annoying me
18:24:19 <sjanssen> ie. allocate an address for all your thunks up front
18:24:36 <blackdog> how do i paraellelise it once i have it stated that way?
18:24:55 <ac> I have a type like "data Value = Primitive ([Value] -> Value) | Cons Value Value | Expression Expr". Is there a quick way to specify (==) for "Primitive" and use "deriving" for "Cons" and "Expression", or do I have to just create an instance of Eq with all three?
18:25:42 <oerjan> ac: no quick way i think
18:26:41 <sjanssen> blackdog: at each step you choose to either use a coin of a certain denomination, or step to a smaller denomination, yeah?
18:26:56 <oerjan> unless you are willing to use a newtype indirection
18:26:57 <sjanssen> you calculate the cost of both, then choose the minimum
18:27:43 <oerjan> ac: you could make newtype Prim = [Value] -> Value and data Value = Primitive Prim | Cons Value Value | Expression Expr
18:27:47 <sjanssen> let x = choose current coin; y = skip to smaller coin in x `par` y `pseq` minimum x y
18:27:50 <blackdog> sjanssen: um, almost. i want all the ways of making up that sum.
18:27:53 <sjanssen> blackdog: does that make sense?
18:28:04 <sjanssen> blackdog: oh, I'm not actually reading the program :P
18:28:05 <oerjan> but then you would need to unpack the constructor for Prim
18:28:22 <oerjan> er, newtype Prim = Prim ([Value] -> Value)
18:28:36 * SamB wonders why google is showing him this ad:        
18:28:50 <sjanssen> blackdog: all combinations is similar, just use one of the parallel map strategies from Control.Parallel
18:29:12 <blackdog> ok, fair enough. :) how smart is it about not firing off unnecessary sparks? I noticed don had some special purpose code for that
18:29:52 <sjanssen> not smart, but GHC is smart enough to avoid re-evaluating a thunk
18:30:29 <sjanssen> so you'll probably make some redundant sparks, but hopefully not too many?
18:32:52 <ac> oerjan: how would I define Eq on Prim anyway?
18:33:13 <ac> oerjan: It's not necessary, but there's no reason why one shouldn't be able to say "(eq? + +)" for example
18:33:23 <ac> (I'm writing a Scheme interpreter, if you can't tell
18:33:25 <ac> )
18:33:44 <sjanssen> blackdog: this is an interesting problem
18:34:20 <sjanssen> blackdog: I think you want to try the denominations in descending order, to avoid degenerating into an essentially linear program
18:34:21 <blackdog> sjanssen: it's from SICP - decided i couldn't write another rhtml page without going insane :)
18:34:38 <oerjan> ac: instance Eq Prim where f1 == f2 = ...
18:34:41 <sjanssen> blackdog: does SICP do it in parallel?
18:34:46 <blackdog> no
18:34:47 <oerjan> er
18:34:55 <oerjan> ac: instance Eq Prim where Prim f1 == Prim f2 = ...
18:35:00 <blackdog> SICP does the naive recursive algorithm
18:35:04 <ac> huh. my connection just faltered. What's the previous thing I said?
18:35:09 <blackdog> i'm just pushing it way too hard :)
18:35:14 <oerjan> ac: )
18:35:30 <blackdog> worst smiley ever
18:35:50 <ac> oerjan: but there's no instance of Eq for "a -> b"
18:36:09 <ac> and that's the type of Prim
18:37:04 <oerjan> ac: yep so you must decide yourself what == should return
18:37:25 <oerjan> in case you missed it: instance Eq Prim where Prim f1 == Prim f2 = ...
18:39:23 <sjanssen> blackdog: are you familiar with lazy infinite tries?
18:39:49 <oerjan> ac: also if your scheme has mutable data == won't be able to look inside them since it is pure.
18:40:16 <oerjan> but that may not be a problem for eq? iirc
18:53:05 <oerjan> @users
18:53:05 <lambdabot> Maximum users seen in #haskell: 440, currently: 395 (89.8%), active: 8 (2.0%)
18:53:23 <oerjan> ooh
19:01:58 <baobab> hello
19:02:24 <baobab> can someone help me with a (probably silly) problem?
19:03:52 <oerjan> no one will admit it until you say what the problem is :)
19:03:58 <baobab> i'm defining data Jtype = Jclass String | Jarray Jtype
19:04:07 <baobab> yes :)
19:04:27 <baobab> when i try to instance Jtype to Show
19:04:44 <baobab> instance Show JType where
19:04:54 <baobab>  show (Jarray a)  = show a ++ "]"
19:05:00 <baobab>  show (Jclass s)  = "class " ++ s
19:05:12 <baobab> i get a parse error in the last line (Jclass)
19:05:21 <baobab> why?
19:05:46 <oerjan> are they indented the same?
19:05:52 <baobab> yes
19:05:59 <oerjan> and more than instance
19:06:04 <baobab> i get the parse error at the equal
19:06:14 <baobab> what do you mean?
19:06:37 <oerjan> the two last lines indented more than the first
19:06:47 <baobab> yes sure
19:07:12 <oerjan> that _is_ strange
19:07:20 <baobab> :s
19:07:32 <oerjan> !paste
19:07:32 <hpaste> Haskell paste bin: http://hpaste.org/
19:07:40 <baobab> ?
19:07:50 <baobab> what is that?
19:08:32 <oerjan> put your code on there, maybe there is something that is not obvious around it
19:08:48 <oerjan> or something that doesn't show in irc
19:09:06 <baobab> ok
19:13:08 <baobab> thank you vi... i had a tab char not translated to spaces
19:13:22 <baobab> that's what caused the parse error
19:13:23 <oerjan> ah
19:13:28 <sorear> baobab: tabs work fine as long as ts is correctly set to 8
19:13:38 <oerjan> i use :set expandtab
19:13:42 <baobab> thank you anyway oerjan
19:14:10 <baobab> sorear: I set it to 2 spaces
19:14:32 <baobab> I thought that expandtab was on automatically
19:17:16 <SamB> @hoogle getArgs
19:17:17 <lambdabot> System.Environment.getArgs :: IO [String]
19:59:09 <Korollary> goalieca: 0-1 ! (Sharks fan)
20:02:47 <ac> The (write) and (display) functions are sucking my entire eval function in to the IO monad :-[
20:03:29 <ac> please help!
20:03:48 <oerjan> they would tend to do that.
20:04:08 <ac> I can't really see any reasonable way to avoid it
20:04:12 <oerjan> although you could use a writer monad instead
20:04:18 <ddarius> There are things you can do, e.g. using continuation based system.
20:04:24 <goalieca> Korollary, don't worry ;)
20:04:27 <oerjan> providing you don't want any other side effects
20:04:30 <shivernz> if i'm expecting a function to return with: IO [ClockTime], what should my return be an empty list
20:04:54 <shivernz> I can't just do a return (), right?
20:05:01 <oerjan> return []
20:05:07 <ac> shivernz: return []
20:05:11 <ac> oerjan: bleh, beat me to it
20:05:24 <shivernz> thanks :)
20:07:02 <ac> oerjan: so you're saying instead of "eval :: Expr -> Env -> IO Expr" it would be "eval :: Expr -> Env -> Writer Expr"?
20:07:15 <oerjan> Writer String Expr
20:07:36 <ac> oerjan: why not just use IO?
20:07:55 <oerjan> just in case you really want a pure implementation
20:08:10 <m_stone> ac: mainly because it's a sledgehammer.
20:08:35 <m_stone> ac: look, we agree that tracing is a side-effect, right?
20:08:39 <ac> ddarius: what did you mean by continuation based system? Does Haskell even have continuations?
20:08:46 <Korollary> goalieca: 0-2 !
20:08:57 <ac> m_stone: I have absolutely no intention to implement tracing
20:09:03 * goalieca hits head on floor
20:09:04 <m_stone> ac: i.e. that it lets you observe properties of how your program is running that pure programs can fudge.
20:09:39 <mauke> :t callCC
20:09:40 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
20:09:48 <ddarius> ac: In this case, it doesn't matter whether Haskell has continuations (it doesn't, having them would be bad)
20:09:57 <sclv> ?hoogle contT
20:09:57 <lambdabot> Control.Monad.Cont.ContT :: newtype ContT r m a
20:09:57 <lambdabot> Control.Monad.Cont.ContT :: (a -> m r -> m r) -> ContT r m a
20:09:57 <lambdabot> Control.Monad.Cont.runContT :: ContT r m a -> (a -> m r) -> m r
20:10:05 <m_stone> ac: what I mean is that if you're sprinkling 'print' statements and watching them go by, then you're probably enforcing some choices about sequencing of evaluation that could be decided differently in a fully pure setting.
20:10:13 <ddarius> The benefit of this approach is that you can very clearly delimit what you need.
20:10:20 <glguy> mauke, before I signed in to IRC a few minutes ago, i was just explaining that function to my wife :)
20:10:21 <ac> m_stone: I see
20:10:39 <m_stone> ac: (maybe I misinterpreted what you meant by your 'write' and 'display' functions?)
20:10:42 <sclv> ?go cc-delcont
20:10:43 <lambdabot> http://www.haskell.org/haskellwiki/Library/CC-delcont
20:10:43 <lambdabot> Title: Library/CC-delcont - HaskellWiki
20:11:05 <ac> m_stone: you're saying if (write) and (display) don't actually have side effects, you have more flexibility in implementation
20:11:30 <oerjan> ac: anyway while there may be other ways than using monads, monads are probably the simplest way.
20:11:47 <ac> m_stone: What I could do is create a State type for the entire evaluator that has the Environment, stdin, stdout, etc
20:11:52 <m_stone> ac: I'm actually saying that insofar as the point of using monads in haskell code is to control side effects, then you should use the right monad for the job.
20:12:08 <m_stone> there are two reasons for this.
20:12:20 <ac> m_stone: I like that idea a lot, because then every single primitive function could have the same type
20:12:21 <m_stone> (well, many, but the two I care about are:)
20:13:10 <ac> m_stone: before I was thinking that I'd have two types: one for odd ones like (define) and (write) and another type for pure primitives. But if the primitive functions take a state and return a new state, they all could have the same type
20:13:16 <m_stone> first, the IO monad has way too much stuff in it. if all your logic quickly winds up in the IO monad, then you can't make any really strong statements (through the type system) about those functions.
20:13:38 <m_stone> second, there are good reasons why you may want to run the "same" code in different monads.
20:14:30 <m_stone> or rather, why you may want to write code that is parametric over the mechanism that you're using to combine pairs of little actions into big actions (which is all that a monad is, really)
20:14:40 <oerjan> ac: your idea is itself wrapped up in a monad, called State
20:14:49 <m_stone> ac: does that make sense? [there are some handy examples, if they're helpful]
20:15:23 <oerjan> @src State
20:15:23 <lambdabot> Source not found. Take a stress pill and think things over.
20:15:25 <ac> m_stone: I'm not sure if the last things you said make sense, but what you said before definitely convinced me not to put it in the IO monad
20:16:32 <m_stone> ac: this is a really important idea that is worth taking a few minutes to try to understand.
20:16:33 <ac> what do you mean "parametric over the mechanism you're using to combine pairs of actions..."
20:16:33 <oerjan> ac: once you have made your code monadic, it is not that hard to change the monad if you want
20:17:02 <dibblego> ?type foldl
20:17:02 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
20:17:11 <ac> oerjan: I haven't written any monads myself, so I don't understand the implication of "changing the monad"
20:17:12 <m_stone> ac: what does the Maybe monad do?
20:17:30 <dibblego> ?src Maybe (>>=)
20:17:30 <ac> m_stone: makes something optionally nothing
20:17:30 <lambdabot> (Just x) >>= k      = k x
20:17:30 <lambdabot> Nothing  >>= _      = Nothing
20:17:41 <m_stone> ac: what's the point in regarding it as a monad, instead of just thinking of it as a tagging system for values.?
20:17:49 <dibblego> m_stone, have you ever called a function which might return null and if it does, the calling function returns null?
20:17:50 <ac> m_stone: I have no idea
20:17:51 <ddarius> ac: Anyway, you can do something kind of like what is described in here: http://www.cs.nott.ac.uk/~txa/talks/cambridge-06.pdf
20:18:04 <oerjan> ac: well mostly you can just pick monads from the Control.Monad.* hierarchy
20:18:28 <m_stone> ac: well, here's a simplistic example.
20:19:03 <m_stone> ac: suppose I want to unlink all the files in a directory but I know that my unlink operation might fail with permission errors.
20:19:53 <ac> so unlink returns "Maybe Error"?
20:20:20 <m_stone> ...bad choice of example on my part.
20:20:28 <m_stone> shows what happens when you try to think on your feet. :)
20:20:32 <m_stone> anyway, just a sec.
20:21:11 <ac> m_stone: yeah I know exactly what you mean. It's really bad when you're in front of a class :P
20:21:19 <m_stone> suppose unlink returns 'Just <name>' if it succeeds and Nothing otherwise.
20:21:38 <m_stone> so that way we'll know which files we succeeded in unlinking.
20:22:03 <dons> lovely, http://ddvlad.wordpress.com/2007/12/14/a-different-kind-of-obscurity/ :)
20:22:04 <lambdabot> Title: A Different Kind of Obscurity  Another Blog, http://tinyurl.com/2p5vom
20:22:05 <m_stone> now suppose that we want to say that 'the directory-clearing function succeeds if it unlinks all the files in the directory'
20:22:08 <dons> and he thanks #haskell :)
20:22:28 <glguy> moar blags?
20:22:46 <m_stone> ac: clearly we could do this by making a list with all the results and writing a function to look for any instances of 'Nothing'.
20:23:25 <ddarius> dons: Any interesting xmonad buzz out there recently?
20:23:40 <dons> ?users #xmonad
20:23:40 <lambdabot> Maximum users seen in #xmonad: 97, currently: 83 (85.6%), active: 11 (13.3%)
20:23:41 <christine_c> does people know here Constraint Satisfaction Problem?
20:23:46 <m_stone> ac: but maybe we want to fail immediately.
20:23:46 <dons> we reached a new high score :)
20:24:05 <m_stone> ac: (it's a bad example because here, you probably do want to fail lazily rather than eagerly. anyway.)
20:24:07 <dons> ddarius: hmm, other buzz. big community of arch linux / xmonad users
20:24:19 <dons> 0.5 is out, of course, so  we're seeing a spike in activity
20:24:20 <TSC> christine_c: Sure
20:24:25 <dons> and more people picking up bits of haskell
20:24:34 <ac> m_stone: well regardless of when you want to fail, I'm with you
20:24:38 <Korollary> dons: Opinions of people who can use monads don't count. Graph algorithms? Sheesh. I wanna see Haskell under load.
20:24:43 <m_stone> ac: imagine that we're going to go through these files in some specified order, trying to unlink them, and we want the whole computation to fail if any of its sub-parts (the individual file deletion) fails.
20:24:47 <dons> Korollary: :)
20:25:19 <m_stone> ac: one clever way to do that is to write a rule for combining those sub-actions that says 'compute one sub-action. if it succeeds, keep going; otherwise, fail.'
20:25:50 <m_stone> now take a look at dibblego's handy definition of the 'bind' rule for the Maybe monad.
20:25:56 <m_stone> ?src Maybe (>>=)
20:25:56 <lambdabot> (Just x) >>= k      = k x
20:25:56 <lambdabot> Nothing  >>= _      = Nothing
20:26:13 <m_stone> do you see what it's doing?
20:27:01 <ac> ?src Maybe (==)
20:27:01 <lambdabot> Source not found. I feel much better now.
20:27:15 <oerjan> ac: it's the derived one
20:27:23 <christine_c> tsc: is it a good solution to solve time tabling problem using that CSP
20:27:37 <m_stone> recall that, for this conversation, we have (>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b
20:28:15 <dons> ddarius: http://galois.com/~dons/images/hist.png steady growth
20:28:20 <ac> Monad is a type class
20:28:41 <m_stone> that is, (>>=) is a function that takes two arguments, one a 'computation that may fail', and a function from results to computations that may fail, and combines them into a bigger computation that may fail.
20:28:55 <m_stone> ac: do you see how that definition propagates failure?
20:29:33 <ac> m_stone: yeah
20:29:51 <m_stone> ac: how it says: if the first part failed, then the whole thing failed. if the first part was good, return whatever the second part returns when applied to the good result I got from the first part.
20:29:51 <ac> interesting
20:29:55 <pa-ching> ?src with
20:29:55 <lambdabot> Source not found. That's something I cannot allow to happen.
20:30:42 <m_stone> ac: so this is the sense in which monads are rules for gluing pieces together, and the sense in which they define 'notions of computation' (a phrase you should research, if you want the gory details)
20:31:05 <ac> But what's the advantage of being able to change say, a function that takes a Maybe monad to one that takes a List monad?
20:31:05 <m_stone> ac: Anyway, imagine your program took the (>>=) function as an argument.
20:31:13 <m_stone> heh. good question. :)
20:31:39 <ddarius> dons: How's the LOC coming?
20:31:54 <ac> m_stone: which program?
20:31:58 <dons> ddarius: stabilised recently. i wouldn't expect much change now.
20:32:04 <ac> m_stone: a Primitive?
20:32:07 <dons> 1k loc, approx.
20:32:18 <m_stone> ac: I'm trying to figure out how to explain.
20:32:27 <dons> ddarius: using xmonad yet? :)
20:32:36 <goalieca> Korollary, this is bad quality hockey
20:32:56 <TSC> christine_c: You can solve timetabling problems using constraint programming, sure
20:32:58 <dons> and if anyone has any suggestions on how to improve the acceptance of xmonad, i'd be interested.
20:33:09 <ricky_clarkson> Write it in python.  Python gives you wings.
20:33:24 <dons> ah yes. xkcd has been tempted to the dark side
20:33:38 <pa-ching> Make a Wii remote interface
20:33:41 <ddarius> dons: I've been using xmonad since 0.2 or earlier.  It was part of the reason I bothered switching to Linux.
20:33:50 <dons> ddarius: oh, i didn't know!
20:33:56 <dons> are you using 0.5 with a custom config?
20:33:57 <ac> python also makes you grow breasts
20:34:19 <jaredj> ah crap, i wondered what was doing that
20:34:37 <dons> python also makes you sick, http://www.b-eye-network.com/blogs/imhoff/archives/python.jpg
20:34:54 <m_stone> ac: basically, giving yourself the ability to change the monad used to glue together small pieces of your program is much like giving yourself the ability to swap out multiple implementations of the same interface.
20:34:58 <jaredj> ???
20:35:07 <ddarius> dons: I'm using a darcs pull between 0.3 and 0.4.  I didn't really tweak it much, mostly changed keybindings and removed stuff.  That version was already too featureful for me.
20:35:12 <importantshock> dons: what *is* that?
20:35:18 <jaredj> 0.5?
20:35:22 <ac> dons: what IS that?
20:35:24 <jaredj> oo!
20:35:40 <dons> that's a python that ate an alligator and exploded.
20:35:58 <jaredj> ???
20:35:58 <dons> jaredj: xmonad 0.5?
20:36:06 <Korollary> You could say python doesn't scale, then.
20:36:12 <dons> hah
20:36:14 <jaredj> yes, oo, xmonad 0.5, ???, strange picture
20:36:21 <jaredj> too many reptiles, i can't tell them apart
20:36:33 <baobab> i can feel the voodoo in the air
20:36:39 <ac> m_stone: what would be the implementation attached to, for example, Maybe?
20:36:39 <jaredj> and it looks like a reptilian swordfish
20:36:44 <jaredj> just one
20:36:51 <jaredj> with... a goatee
20:36:55 <dons> ddarius: might be worth using 0.5, just for reliability.
20:37:01 <jaredj> and a reptilian baseball cap on
20:37:05 <dons> its functionally identical without configuratoin
20:37:05 <m_stone> dons: how would you succinctly explain the value of being able to change what monad you're using to glue your program together?
20:37:07 <importantshock> dons: epic win.
20:37:12 <ddarius> I'm sure if Haskell ate an alligator he wouldn't explode, though he'd probably take a more prudent course.
20:37:14 <importantshock> python doesn't scale. doesn't mean i don't have to like it.
20:37:23 <importantshock> Haskell would take bites only when needed.
20:37:23 <dons> python often has this problem, http://www.smh.com.au/ffximage/2006/09/08/python_wideweb__470x325,2.jpg
20:37:26 <lambdabot> http://tinyurl.com/2besrr
20:37:43 <Zao> ddarius: If it was a pure alligator consuming function, it couldn't have side effects like that.
20:38:04 <jaredj> importantshock: error: too many negatives, bailing out
20:38:11 <ddarius> Unless it used unsafeExplodeStomach
20:38:18 <importantshock> or an AlligatorRef
20:38:22 <dons> lesson, alligators, of the lambda flavour, are bad for pythons. http://worrydream.com/AlligatorEggs/
20:38:22 <lambdabot> Title: Alligator Eggs!
20:38:24 <importantshock> UnsafeAlligatorRef.
20:38:25 <ac> dons: so python is terribly greedy too?
20:39:04 <dons> awfully eager and greedy
20:39:10 <ddarius> dons: There was some reason I was hesitant to build and install the last darcs pull I had, but I don't remember what it was.
20:39:12 <importantshock> now pypy, that's greedy. sucks up resources like no other.
20:40:59 <ac> I actually have nothing against Python (haven't even used it), but I didn't think that particular xkcd was very funny
20:41:21 <ac> I like Python because it competes with PHP
20:41:54 <goalieca> python is a great language
20:41:56 * ddarius will agree that Python is better than PHP.
20:41:59 <ac> Anything that competes with PHP is my friend
20:42:10 <jaredj> wow this alligator egg thing looks fun
20:42:16 <dons> :)
20:42:28 <jaredj> i'll take python over fortran
20:42:30 <shachaf> jaredj: I wish it was complete.
20:42:38 <jaredj> buh?
20:42:50 <shachaf> (It wasn't the last time I looked, at least.)
20:43:52 <ddarius> shachaf: In what way was it incomplete?
20:44:15 <m_stone> ac: I am unable to construct an example that I find compelling.
20:44:17 <goalieca> scipy is really nicew
20:44:44 <shachaf> ddarius: It wasn't really in a form that I could give someone, and there were a lot of "maybe we could" ideas.
20:44:48 <dons> shachaf: i hear a rumour you might be younger than sorear? another member of our #haskell prodigy club? :)
20:45:15 <ac> how old is sorear?
20:45:23 <importantshock> i'm 19...i started at 17.
20:45:37 <dons> sorear: 16..17 now, I guess?
20:45:40 <sorear> 17
20:45:57 <shachaf> dons: I guess, then, yes.
20:45:59 <ac> bleh. That's about when I graduated from Microsoft QBASIC to C
20:46:00 <goalieca> wow. why waste your youth?
20:46:02 <ddarius> importantshock: Started programming or started Haskell programming?
20:46:15 <dons> shachaf: cool :) don't let school get boring
20:46:18 <ac> Actually, that was about when I went from C to Perl
20:46:27 <goalieca> Korollary, don't even bother...
20:46:28 <Korollary> goalieca: 0-3 !
20:46:29 <importantshock> ddarius: Haskell. Started programming seriously at...hold on...14.
20:46:34 <importantshock> With Python.
20:46:40 <importantshock> Though I had a go with C in the 5th grade.
20:46:49 <dons> though i think dibblego's son has the record for haskell
20:47:08 <ricky_clarkson> I started programming for fun when I was 6.  I've yet to hit 'serious', it's still fun.
20:47:13 * ac feels like a silly and old
20:47:44 <dons> oh ac, don't be that way. time marches on. i'm apparently an old hand now. and shapr's ancient
20:48:00 <goalieca> Korollary, our backup's backup :-)
20:48:03 <dons> ddarius is 47.
20:48:13 * ddarius wonders why "47"
20:48:19 <blackdog> the nature of shapr was ... irrepressible!
20:48:20 <dons> sounded good?
20:48:25 <shachaf> dons: However, sorear's age/haskell expertise is way higher than mine. :-)
20:48:35 <dons> blackdog: for 500 years he was fed iron balls while trapped under a mountain!
20:48:41 <shachaf> (Lower, I mean.)
20:48:49 <importantshock> shachaf: yeah, i was gonna say...
20:48:50 <ricky_clarkson> Every so often, the spaces between nicks and text forms a large parenthesis in #haskell, it's lisp reminding us that it's still there.
20:49:08 <dons> heh
20:49:17 <dons> ricky_clarkson: wow. that's lovely.
20:49:29 <dons> lisp is the absence left by our whitespace?
20:50:51 <blackdog> the music between the notes
20:51:04 <oerjan> @remember ricky_clarkson Every so often, the spaces between nicks and text forms
20:51:04 <lambdabot> Good to know.
20:51:06 <Pseudonym> How old is dibblego's son?
20:51:07 <oerjan>                        a large parenthesis in #haskell, it's lisp reminding us
20:51:13 <dons> Pseudonym: 6 iirc
20:51:14 <ricky_clarkson> oerjan: heh
20:51:15 <oerjan> what the?
20:51:16 <dibblego> Pseudonym, I have 2, 6 and 4 years old
20:51:23 <Pseudonym> The one who used Haskell?
20:51:23 <oerjan> it worked the last time :(
20:51:30 <dibblego> Pseudonym, the 6 year old uses Haskell
20:51:35 * Pseudonym has about three weeks until his youngest turns 6
20:51:38 <Pseudonym> So I don't have long!
20:51:41 <oerjan> @forget ricky_clarkson Every so often, the spaces between nicks and text forms
20:51:42 <lambdabot> Done.
20:51:46 <Pseudonym> To beat the record, that is.
20:51:49 <dibblego> Pseudonym, he was 5 when he started ;)
20:51:55 <Pseudonym> Dammit.
20:52:04 <pa-ching> Hmm... can't seem to turn this imported C function into a FinalizerPtr... weird...
20:52:15 <Korollary> There ought to be a child prodigy in India reading Oleg
20:52:16 <ddarius> The four year old uses Epigram and the two year old Coq.
20:52:16 <dibblego> Pseudonym, just give him/her ghci and some arithmetic; that's how I got started
20:52:24 <ddarius> Korollary: Why is that?
20:52:24 <oerjan> @remember ricky_clarkson  Every so often, the spaces between nicks and text forms a large parenthesis in #haskell, it's lisp reminding us that it's still there.
20:52:25 <lambdabot> Good to know.
20:52:25 <ricky_clarkson> My mum insists I was 5 when I started programming in BASIC.  Source control says otherwise.
20:52:37 <Pseudonym> Well, she knows how to use a calculator, an addiator, and basic stuff on the soroban.
20:52:43 <Pseudonym> So I'm guessing she's old enough for ghci.
20:53:02 <ddarius> Pseudonym: Teach her the guitar instead.
20:53:05 <Pseudonym> Hang on, you used source control at age 5?
20:53:08 <dibblego> Pseudonym, I'd say so, just don't do anything scary and make it look as fun as a calculator
20:53:08 <Pseudonym> ddarius: No.
20:53:16 <Pseudonym> She's currently learning violin, piano and recorder.
20:53:19 <sorear> @quote
20:53:20 <lambdabot> robreim says: Great, now we've got to start an IRC channel for lojban-speaking, haskell-coding anarchists
20:53:22 <m_stone> ac: the best I can do is to point you toward sigfpe's excellent http://sigfpe.blogspot.com/2006/10/monads-field-guide.html
20:53:22 <Pseudonym> Guitar would be a bit much.
20:53:22 <lambdabot> Title: A Neighborhood of Infinity: Monads, a Field Guide
20:53:42 <ddarius> Pseudonym: Piano and violin is acceptable.  Recorder is as well as a special exception.
20:53:42 <Pseudonym> Oh, and she's on her fourth music theory book.
20:53:57 <Pseudonym> She needs to learn breath control on SOME instrument.
20:54:12 <pa-ching> with a function :: Ptr SomeDataType -> IO () is there anything in particular I need to do to make it work as a finalizer for newForeignPtr? Can't seem to find good documentation...
20:54:15 <ddarius> I hate (playing) wind instruments.
20:54:24 <ddarius> Pseudonym: I recommend the ocarina.
20:54:40 <Pseudonym> ddarius: We gave her a choice of what we happen to have lying around.
20:55:02 <Pseudonym> The trumpet and trombone are a bit big for her at the moment.
20:55:11 <Pseudonym> And the banjo needs new strings.
20:55:16 <ac> the only thing I play is the didgeridoo
20:55:17 <ddarius> ooo banjo
20:55:23 <Pseudonym> But we might try her on the uke.
20:55:36 <ac> m_stone: I'll check that out. I've read and liked a couple entries from sigfpe
20:55:43 <ricky_clarkson> dons: http://img168.imageshack.us/img168/4396/deletement4.jpg
20:56:01 <ac> the didge is the ultimate instrument for wind control
20:56:29 <Pseudonym> ac: We have one of those, too, but I never really got it.
20:56:36 <Pseudonym> Mind you, it's about 60 years old.
20:56:46 <Pseudonym> Still in pretty good nick, though.
20:56:57 <ac> Pseudonym: how long is it? Smaller ones are MUCH easier to play for me
20:56:59 <mdmkolbe|work> Is there already an implementation of monadic pattern guards in Haskell?  (i.e. I have a function where which clause is taken depends on part of the state monad)
20:57:00 <Pseudonym> I think you need bigger lungs than a typical 5yo, anyway.
20:57:09 <Pseudonym> ac: Pretty long.  Maybe... 1.5m?
20:57:15 <Pseudonym> A little shorter, perhaps.
20:57:32 <Pseudonym> I did introduce her to the vacuum cleaner pipe, though.
20:59:14 <ac> Pseudonym: I wouldn't recommend a dige for such a young one (at least not that size). It takes a lot of breath to learn
20:59:22 * Pseudonym nods
20:59:52 <dons> mdmkolbe|work: no monadic pattern guards, afaik. just pattern guards.
20:59:53 <ac> Pseudonym: but you should learn how to play it ;)
20:59:59 <Pseudonym> I should.
21:00:10 <Pseudonym> Any suggestions?
21:01:44 <ac> Pseudonym: Sure... It took me an evening or two to get the circular breathing down. Focus on that at first. Once you get that down, practice playing for longer periods, and making fun noises. Once you have a nice array of sounds you can make, practice breathing out while maintaining a tone so you can play specific rythms
21:01:53 <ac> that last is what I'm working on. It's quite difficult
21:02:28 <lament> i'm trying to learn to make some kind of a sound with a flute at the moment
21:02:32 <ac> Pseudonym: the trick to playing a rythm is being able to regulate your breathing independently of what you're playing so you don't run out of breath or hyperventilate
21:02:34 <lament> the flute won't cooperate at all :(
21:02:57 <lament> stupid hard embouchure
21:03:53 <dons> takes a little practice, but once you get it, you can play music on anything
21:04:31 <lament> it's a stupid novelty flute, too, a flautist friend also had problems with it
21:04:41 <ac> Pseudonym: when you say "you never really got it" do you mean you never got a pretty tone out of it (heh)? Or you never got circular breathing?
21:05:02 <Pseudonym> I never got circular breathing, and I never got more than one noise out of it.
21:05:09 <lament> you don't even need circular breathing to play the didgeridoo
21:05:12 <Pseudonym> Well, one type of noise.
21:05:19 <ac> lament: it sure makes it a lot more fun
21:05:26 <Pseudonym> lament: That's like saying you don't need a left hand to play the guitar.
21:05:27 <mdmkolbe|work> thx, dons.  That means I can go implement them ;-).
21:05:40 <Pseudonym> That's strictly true, but it misses the point.
21:05:42 <lament> Pseudonym: well, you don't...
21:05:57 <bos> digeridoos are the category theory of music
21:06:00 <ramza3> general question; I want to parse this simple meta language.  What do you think of it.  It is kind of replacement for XML (for me anyway), attributes are setup like CSS, http://wee-url.com/responder/pastebin/show-paste?n=398
21:06:17 <ac> Pseudonym: there are two keys to circular breathing. The first is learning how to force air from your cheeks while breathing in through your nose. The second part is learning how to play the didge with a small enough volume of air that you can do it with your cheeks
21:07:03 <ricky_clarkson> Bah, that's a hack!
21:07:42 <dmwit> Why?
21:07:50 <dmwit> Seems legit to me.
21:08:04 <ricky_clarkson> Because breathing isn't really done in the mouth.
21:08:08 <ddarius> ramza3: Why not just embed a Lua interpreter?
21:08:15 <ac> Pseudonym: as for getting different noises out of it, that's super easy. You can blow really hard to get the next octive, and you can adjust your lips to get different flavors of sound, and you can just hum or yell stuff while you're playing
21:08:23 <ricky_clarkson> I could hold my breath and mess around with air in my cheeks and still die.
21:08:36 <ramza3> ddarius: I have no idea what lua is
21:08:38 <lament> Pseudonym: shape your mouth as if saying different vowels
21:08:46 <ddarius> @google Lua programming language
21:08:47 <lambdabot> http://www.lua.org/
21:08:48 <lambdabot> Title: The Programming Language Lua
21:09:00 <ac> s/flavors/timbre/
21:09:12 <Pseudonym> Yeah, I understand the theory.
21:09:46 <ramza3> ddarius, if you were developing a meta language, a meta language to replace XML, how would you design. hypothetical, no googling for X language
21:09:47 <lament> the "different vowels" part takes no practice at all, so you should already be able to do it.
21:10:17 <dmwit> ramza3: lisp?
21:11:01 <ac> lament: you play much didge?
21:11:03 <ddarius> ramza3: Why -wouldn't- I use an existing solution?
21:11:21 <ricky_clarkson> ramza3: So obviously lisp it's pretty much a rhetorical question.
21:11:31 <ramza3> ddarius, because you are on the planet mars, there aren't any other solutions.
21:11:50 <lament> ac: not really, i'm just di-curious
21:12:02 <ricky_clarkson> Then you write lisp from scratch.
21:12:12 <ac> lament: heh.
21:12:16 * lament is into wacky musical instruments in general, hence the glass flute he's trying to learn to play right now
21:12:23 <ramza3> ricky_clarkson, lisp is fine and I added s-expressions; but for a language that really isn't turing complete and only used to map to various data structures like maps / lists, I could get more creative
21:12:47 <ricky_clarkson> ramza3: Languages that aren't really turing complete tend to become so.
21:13:07 <ramza3> ricky_clarkson, I am hoping to do this in the next couple of hours and then I am done with it
21:13:19 <ricky_clarkson> On mars?
21:13:38 <dmwit> ramza3: I think there's a bijection between XML and quote-less Lisp...
21:13:40 <ramza3> internet is pretty fast
21:14:27 <ramza3> dmwit, yea, I would end up with s-expressions which would kind of boring for what I want
21:14:49 <dmwit> I don't understand.
21:15:20 <ddarius> dmwit: That's because he's yet to state what he actually wants or what the constraints actually are.
21:15:42 <dmwit> right
21:16:19 <ramza3> ddarius, exactly
21:21:03 <ac> what would be an appropriate type for stdin and stdout? String?
21:21:13 <Pseudonym> FileHandle
21:21:21 <ac> Actually, Data.Sequence would make more sense I think
21:21:23 <Pseudonym> Or Handle.
21:21:31 <ac> Handle?
21:21:35 <dmwit> Handle.
21:21:53 <oerjan> :t stdin
21:21:56 <lambdabot> Not in scope: `stdin'
21:22:02 <oerjan> :t System.IO.stdin
21:22:03 <lambdabot> GHC.IOBase.Handle
21:22:29 <oerjan> ac: but if you mean those in your scheme state, String
21:22:45 <oerjan> cannot use Handle without IO
21:23:02 <ac> oerjan: yeah, I mean for in my MachineState record
21:23:35 <ac> oerjan: wouldn't I want a sequence though? Because when you type things, the characters get added to one side, and when you read things, they get removed from the other side
21:24:05 <dmwit> stdin and stdout are usually different objects.
21:24:45 <goalieca> Korollary, yay!@!!!!
21:25:10 <Korollary> goalieca: Nice block eh?
21:25:31 <ac> dmwit: I was talking about just stdin. Stdout could be just a String I guess
21:25:49 <dmwit> Ah, quite.  Sorry.
21:27:07 * shapr smacks dons with his cane
21:27:58 <shapr> ac: How old are you?
21:28:21 <oerjan> :t interact
21:28:22 <lambdabot> (String -> String) -> IO ()
21:28:29 <dons> oi! mister!
21:28:45 <ac> shapr: 22
21:28:49 <shapr> dons: I'm not ancient! Not yet anyway...
21:28:50 <shapr> Oh
21:28:55 <shapr> Never mind, I'm ancient.
21:29:20 <oerjan> ac: if you use interact, then you can make a function that gets stdin passed in as a String and prints the result to stdout
21:29:59 <shapr> Let's see, I started with Haskell when I was 29...
21:30:00 <ac> oerjan: what are you talking about?
21:30:19 <ac> shapr: how long had you been programming?
21:30:30 <shapr> ac: 18 years at the time.
21:30:55 <shapr> BASIC on a Sinclair Spectrum was my first experience.
21:31:03 <dons> shapr: :P
21:31:12 * dons likes to tease the old timers
21:31:13 <ac> QBASIC on a 486 for me
21:31:20 <shapr> So I've been programming for 25 years now...
21:31:26 <shapr> dons: Are you 25?
21:31:34 <blackdog> shapr: shit, i thought my XT was oldschool
21:31:39 <dons> shapr: 27
21:31:53 <oerjan> ac: if your program is essentially a pure pipe from stdin to stdout, then interact can convert between the handles and String lazily
21:31:59 <Toba_> <sarehu> Ask your doctor if Haskell is right for you. Side effects may include: NOTHING.
21:32:04 <shapr> blackdog: I had an original True Blue IBM PC, and later got an XT. I taught myself x86 asm on an 8086.
21:32:04 <blackdog> ac: 486? I used to dream about having a 486! whippersnapper....
21:32:34 <ac> blackdog: my Aunt gave it to our family when they were in the thousand(s)
21:32:37 <dmwit> 486? Why, you and your Arabic numerals...
21:32:43 <blackdog> i still remember getting in trouble for getting it to randomly insult my little sister. good times.
21:33:01 <goalieca> Korollary, go linden!!!
21:33:04 <shapr> My motherboard came with 128k soldered on, and I bought another 384k in separate chips that I inserted.
21:33:15 <Korollary> !!
21:33:27 <ac> oerjan: what is "interact"?
21:33:33 <oerjan> :t interact
21:33:33 * ac is feeling a little slow
21:33:34 <lambdabot> (String -> String) -> IO ()
21:33:41 <Toba_> <3 lambdabot
21:33:42 <Korollary> goalieca: Cook gets the assist
21:33:46 <shapr> dons: When did you start programming?
21:33:47 <Toba_> :t map
21:33:47 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
21:34:00 <oerjan> @src interact
21:34:00 <lambdabot> interact f = do s <- getContents; putStr (f s)
21:34:06 <chessguy> @quote < 3
21:34:06 <lambdabot> No quotes for this person. Wrong!  You cheating scum!
21:34:12 <shapr> I'm not really sure if any of my early programming experience has any relevance these days.
21:34:13 <dons> shapr: 11, iirc.
21:34:18 <chessguy> @quote heart
21:34:19 <lambdabot> Jerub says: shapr: we have a new manager. she complained of a bad heart when I told her we didn't have revision control.
21:34:30 <Toba_> @quote ghci
21:34:30 <lambdabot> SamB says: fworp: next time, load your shirt up in to GHCi *before* having it printed
21:34:31 <shapr> dons: That's cool!
21:34:45 <shapr> Aww, blackdog bailed out.
21:35:08 <goalieca> Korollary, well our backup's backup fucked up bad.
21:35:11 <chessguy> hmm, i was younger than 11 when i started writing games on my commodore 64
21:35:32 <Korollary> goalieca: bad giveaway
21:35:34 <Pseudonym> How old was I... uhm...
21:35:36 <Pseudonym> 9, IIRC.
21:35:53 <ac> shapr: the Spectrum was from around the same time as the Atari, right?
21:35:55 <Pseudonym> On a COMX-35.  Very obscure machine.
21:36:21 <Toba_> I wish I started programming earlier.
21:36:30 <Toba_> I've only been at it for like 6 years.
21:36:33 <chessguy> @src getContents
21:36:34 <lambdabot> getContents = hGetContents stdin
21:36:37 <shapr> Toba_: It's easy to catch up!
21:36:41 <shapr> Just work hard!
21:36:44 <Toba_> heh, I'm pretty caught up I think
21:36:45 <Pseudonym> If only I'd learned assembler on the COMX, it has the same CPU as the Voyager spacecraft.
21:36:48 <chessguy> Src hGetContents
21:36:51 <Toba_> but I would be more caught up if I started earlier.
21:36:52 <Pseudonym> Lost a potential job there.
21:36:58 <shapr> ac: 1982
21:36:59 <chessguy> @src hGetContents
21:36:59 <lambdabot> Source not found. stty: unknown mode: doofus
21:37:53 <ac> shapr: after I graduated from high school I spent a few hours with a friend's Atari. It was pretty cool. I typed in a program from some book that it came with
21:37:57 <chessguy> Pseudonym, yeah, it would have been fun to work with Janeway, though getting stranded in the delta quadrant for 7 years might've sucked
21:38:18 <oerjan> chessguy: it turns the rest of a handle into a String, reading lazily as needed
21:38:26 <ac> oerjan: but if I use some other structure like Data.Sequence for stdin, it would be trivial to write a new interact
21:38:31 <dons> shapr: one one of these, http://www.allaboutapple.com/museo/pictures/donazioni/apple_iie.jpg
21:38:33 <lambdabot> http://tinyurl.com/y7tu5c
21:38:42 * goalieca gives up
21:38:50 <Korollary> heh
21:39:02 <shapr> dons: Cool, we had those in the computer room in high school. We also had an eight inch floppy drive in a desktop computer. The whole desk was the computer...
21:39:11 <dons> heh cool!
21:39:16 <shapr> I think we had some eleven inch floppies lying around as well.
21:39:19 <Pseudonym> chessguy: Especially when the really interesting stories were still going on back around Earth.
21:39:34 <chessguy> boo!
21:39:49 <shapr> Around that time I dated a girl whose father had some bona fide core memory lying around in the barn.
21:40:23 <ac> We had an Apple II in elementary school. It was used exclusively to play Oregon Trail
21:40:30 <shapr> iirc, it was 256 bits of core memory, and about the size of my palm.
21:40:44 <Pseudonym> We had two PDP-8s in our honours room.
21:40:45 <shapr> Too bad he wouldn't let go of it :-) I tried!
21:40:48 <shapr> Pseudonym: Wow!
21:40:51 <oerjan> ac: except Sequence cannot be filled lazily like a String
21:40:51 <Pseudonym> We offered to make a working one out of them.
21:40:55 <Pseudonym> We were told no.
21:40:56 <shapr> Aww
21:41:03 <ac> oerjan: oh that's right.
21:41:10 <Pseudonym> I'm guessing that if they had a working PDP-8, someone would be expected to use it.
21:41:11 <chessguy> @type getContents
21:41:12 <lambdabot> IO String
21:41:14 <shapr> hah
21:41:19 <Pseudonym> We also offered to get CSIRAC working.
21:41:23 <Pseudonym> We were told _definitely_ no.
21:41:47 <Pseudonym> It doesn't comply with pretty much any modern electrical safety regulation.
21:41:51 <shapr> When I was going to uab.edu they had a Prime mainframe, ever heard of PrimeOS?
21:42:01 <Pseudonym> Oh, I've heard of it.
21:42:02 <chessguy> @type stdin
21:42:03 <lambdabot> Not in scope: `stdin'
21:42:45 <Pseudonym> CSIRAC is distinguished by being the only first-generation computer which hasn't been dismantled.
21:42:48 <shapr> Wow
21:43:07 <shapr> http://en.wikipedia.org/wiki/CSIRAC
21:43:08 <lambdabot> Title: CSIRAC - Wikipedia, the free encyclopedia
21:43:09 <oerjan> :t System.IO.stdin
21:43:09 <lambdabot> GHC.IOBase.Handle
21:43:17 <Pseudonym> We only had it in our building for about nine months.
21:43:20 <shapr> Mercury acoustic delay lines!!!
21:43:22 <Pseudonym> But I've walked through it.
21:43:28 <Pseudonym> Yeah, and it also had... a high-level language!
21:43:46 <dons> '(albeit inoperable)' :(
21:43:57 <shapr> Shades of cryptonomicon.
21:44:39 <Pseudonym> BTW, it's significant that it's a computer that you can "walk through".
21:44:53 <Pseudonym> They don't make 'em like that any more.
21:44:57 <shapr> I'll just walk you through this task.. <evil laughter>
21:45:21 <Pseudonym> I did have a go on the teletype keyboard.
21:45:26 <Pseudonym> Which, of course, wasn't switched on.
21:45:33 <Pseudonym> And I've wielded... the screwdriver!
21:46:04 <Pseudonym> The magnetic drum secondary storage (woo, hard disk!) had such a low-torque motor that it required holding a screwdriver against the drive belt so it could spin up to full speed.
21:46:20 <shapr> wow
21:46:51 <dmwit> Yeah... they just don't make 'em like they used to.
21:47:02 <Pseudonym> Ah, and it was the first digital computer to be used to play music.
21:47:06 <shapr> Yeah, the stone age...
21:47:08 <dmwit> I wish for the old days when we had to hand-crank our engines...
21:47:15 <dmwit> ;-)
21:47:32 <shapr> Yeah, I think kids should learn imperative unsafe languages these days, it build character.
21:47:50 <shapr> Sort of like masochism... builds character.
21:52:15 <thetallguy> shapr: uphill both ways?
21:52:28 <ac> oerjan: what exactly would be advantageous about having a lazy stdin?
21:52:34 <shapr> Right. Walking uphill both ways in the snow builds character.
21:53:04 <ac> When I was a kid I seriously biked upwind both ways in the snow
21:53:51 <ac> but it didn't work
21:54:06 <oerjan> ac: it means the entire rest of your program can be a pure function
21:54:33 <ac> oerjan: it would still be using Data.Sequence
21:55:26 <thetallguy> ac: it also means you can process data incrementally
21:55:28 <dmwit> uphill, in the snow, both ways, in bare feet, to the coal mine (where I had to pay fees just for the privilege of being allowed to work), without breakfast or lunch, and no mother
21:55:31 <dmwit> Did I miss any?
21:56:00 <thetallguy> dmwit: our dad would kill us and dance around our grave singin' Hallelujah
21:56:16 <gwern> 'ghc-6.9.20071201: panic! (the 'impossible' happened)' <-- hah
21:56:19 <dmwit> Ah yes, nothing like a periodic death to bring home just how lucky we were.
21:56:56 <thetallguy> get up at 10:30 at night, 'alf an hour before we went to bed, eat a lump of dry poison
21:57:26 <ac> gwern: hah. So that's where that lambdacat is about
21:57:32 <ac> s/where/what/
21:58:08 <thetallguy> yup
21:58:26 <thetallguy> ghc equiv of kernel panic
21:58:41 <Pseudonym> Even the person who runs lambdacats didn't recognise "my brain just exploded", though.
21:58:57 <thetallguy> sometimes it says `urk'
21:59:08 <thetallguy> also a bad thing
21:59:33 <ac> I thought that particular lambdacat was about side effects
21:59:41 <dmwit> Pseudonym: From \bot, or does it predate even that?
22:00:03 <gwern> your head exploding is obviously not referentially transparent, although shortly thereafter it is transparent...
22:00:05 <thetallguy> It is.  Your code has the side effect of crashing hte compiler
22:00:40 <Pseudonym> dmwit: It was a problem with universal quantification pre-wobbly types, IIRC.
22:00:56 <dmwit> whoa
22:01:03 <dmwit> That sounds both official and amusing.
22:02:57 <ac> well I can't make up my mind on weather I should use a String or a Sequence for stdin. I don't care about performance, but it still bothers me using last every time a char gets bufferred
22:03:11 <ac> *whether
22:04:26 <thetallguy> parameterize the type and speed it up later if you need to.
22:05:32 <ac> thetallguy: good suggestion
22:07:46 <gwern> 'Note, we can cd inside a file! So, cat is just `ls' inside a file' <-- brain asplodes
22:08:02 <shapr> gwern: er, wha?
22:08:02 <gwern> I've been going over Oleg's ZFS for hours, and I still don't get it
22:08:06 <shapr> oh
22:08:25 <luqui> would it violate any of Haskell's "purity" principles to provide a call/cc primitive?
22:08:31 <luqui> (not suggesting it, just curious)
22:08:39 <shapr> I read ZFS when it first came out, not sure how much I remember... do you have any specific questions?
22:08:48 <allbery_b> @index callCC
22:08:48 <lambdabot> Control.Monad.Cont
22:08:56 <gwern> shapr: no, my incomprehension is quite general
22:09:01 <shapr> heh, ok
22:09:01 <luqui> allbery_b, thanks, but I'm just wondeing more about the theory
22:09:02 <smack_> In particular, we can use lambda-terms as our file system: one can cd into a lambda-term in bash.
22:09:13 <gwern> it's also kind of coded oddly, although at least it still compiles and works on 6.8.1
22:09:24 <shapr> C'mon, what's hard about mixing zippers and continuations? (Not that I understood it either, mind you.)
22:09:31 <luqui> i.e. are continuations fundamentally monadic in some way, that they can't be provided purely?
22:09:47 <shapr> I understood some of it.
22:09:53 <gwern> no, they're not just continuatoins, they're delimited contiuations! (which I understand even less)
22:10:08 <shapr> Oh right, I forgot.
22:10:15 <luqui> oh dear, my question seems to be slightly relevant to the current conversation :-)
22:10:22 <shapr> Does that mean someone took some chalk and made marks on your continuations?
22:10:25 <gwern> I mean, I did all the commnads listed in the pp slides, and it is cool to play around with 'commit' and 'refresh'
22:10:33 <shapr> Oh no! TOPIC COLLISION!
22:10:40 * gwern still is confused though
22:10:41 <allbery_b> luqui: monadic does not necessarily mean impure (in fact I think that's only true for IO)
22:10:45 <ac> gwern: Have you ever heard of the Logical File System: LFS?
22:10:49 <gwern> ac: nope
22:11:01 <shapr> gwern: What are you confused about?
22:11:07 <allbery_b> monadic just means the type carries some stuff around for you
22:11:10 <ac> gwern: I found it rather interesting, and it also had the parts of files are also files thing
22:11:14 <luqui> allbery_b, sigh, I mean, continuations without using continuation-passing style
22:11:32 <ac> gwern: but that part was pretty hacked in. Its main claim to fame was that a path was a logical query
22:11:35 <luqui> is there an "evaluation order" implicit in there somewhere or something?
22:11:36 <gwern> shapr: well, to take my first example - what does it even mean to cd into a file or lambda term?
22:11:48 <shapr> It's a zipper, yeah?
22:11:59 <gwern> yeah...
22:12:02 <ac> gwern: so that "/" in a path was the AND operator
22:12:08 <ac> gwern: is that how ZFS works?
22:12:14 <shapr> Can you see how a zipper would be a good way to view a filesystem?
22:12:39 <gwern> shapr: yes, if each item is a directory connected to other directories
22:12:43 * allbery_b is not much of a type wizard, but it seems to him that lazy evaluation is a sort of very simple non-CPS "continuation" mechanism
22:12:53 <shapr> Yeah, and files are just nodes in a tree, yeah?
22:12:58 <ac> gwern: I thought it would be really cool to extend LFS so you can arbitralily nest files, but it sounds like ZFS is already there
22:12:58 <allbery_b> (or a continuation wizard, etc.)
22:13:07 <gwern> although I don't really see how to put files into it unless each direcotry has files as a field or something
22:13:18 <luqui> allbery_b, such that it would not be possible to provide a scheme-style  call/cc (getting the current  continuation of a regular function and passing it) in Haskell.  Or is there no problem with that and Haskell simply chooses not to?
22:13:21 <gwern> shapr: no, files are little discrete blobs
22:13:39 <shapr> Files are discrete blobs in ZFS?
22:13:47 <gwern> their names may correspond to a name in a tree, but the file itself is a real thing
22:13:54 * gwern means real files
22:13:57 <shapr> Oh right
22:14:12 <allbery_b> luqui: so far as I can determine, Cont is generally regarded as a proof that scheme-style call/cc is possible --- it's not generally *used* for anything
22:14:14 <shapr> But "real files" are deceptive in my opinion. The implementation details are not the abstract idea.
22:14:54 <allbery_b> hence my comment about laziness as a sort of continuation mechanism:  call/cc is scheme style, laziness is haskell style to do pretty much the same thing
22:15:00 <gwern> shapr: but the point of a file is that you have 'contents' which are utterly divorced from its name/location/unique-identifier/how-to-find-it/position-in-the-tree
22:15:01 <shapr> gwern: You see how a zipper representing the idea of a filesystem could have files as nodes in a tree, yeah?
22:15:25 <gwern> shapr: no, i understand how directories would work as nodes but I don't see how files could work
22:15:47 <gwern> a file isn't a directory; nodes in a tree are supposed to be the same kinds of things
22:16:03 <shapr> Hm, a directory is a file...
22:16:03 <luqui> allbery_b, heh, I missed your laziness comment because you /me'd it :-)
22:16:20 <gwern> now who is talking about implementation details
22:16:27 <shapr> heh
22:16:49 <luqui> mmmm filesystem comonad...
22:17:12 <luqui> (you'd have to have a polymorphic filesystem for that)
22:17:14 <shapr> I don't remember much about ZFS, but I'd guess each node in the tree can be both a file and a directory. Or maybe just one or the other.
22:17:32 <shapr> What about representing a filesystem with a binary tree?
22:18:16 <gwern> what about it?
22:18:54 <shapr> With a zipper of that you could move down to the nodes on the end, yeah?
22:19:03 <dfranke> *sigh*
22:19:15 * gwern nods
22:19:16 <shapr> dfranke: ?
22:19:19 <dfranke> one more thing to love about MySQL: the wonderfully rigorous documentation.
22:19:21 <dfranke> "The UNIQUE and PRIMARY KEY information is about the same as what you get from the Key_name field in the output from SHOW INDEX when the Non_unique field is 0."
22:19:24 <shapr> gwern: So think of it like that?
22:19:25 <dons> ?users #haskell
22:19:25 <lambdabot> Maximum users seen in #haskell: 440, currently: 380 (86.4%), active: 13 (3.4%)
22:19:28 <dons> oh, um.
22:19:30 <gwern> dfranke: 'about the same'?
22:19:31 <dfranke> does Parsec have an aboutTheSameAs combinator?
22:19:32 <dons> 440 eh?
22:19:38 <shapr> @users
22:19:39 <lambdabot> Maximum users seen in #haskell: 440, currently: 381 (86.6%), active: 13 (3.4%)
22:19:45 <shapr> Way spiffy!
22:19:56 <gwern> shapr: that analogy doesn't really help
22:20:17 <dons> i think we'll make 500 then, by this time next year or earlier.
22:20:50 <shapr> gwern: I dunno :-( It seems intuitive to me. Of course remembering to pay my bills isn't intuitive, so...
22:21:24 <shapr> gwern: A filesystem is just a tree of data. Why treat files and directories differently?
22:21:44 <gwern> shapr: yeah, but you do different thigns with them
22:21:58 <shapr> You do?
22:22:04 <gwern> you don't move a file 'into' another file like you move directories into other directories
22:22:24 <scook0> a filesystem holds files, and other filesystems
22:22:30 <scook0> those "other filesystems" are directories
22:22:36 <gwern> how do you do 'mv foo/* ../bar' inside a file?
22:22:39 <gwern> and so on
22:22:51 <shapr> Bah, implementation details (Means I don't know :-)
22:22:55 <gwern> what would that even mean?
22:23:12 <scook0> you seem to be suggesting "a filesystem is a tree, with data at arbitrary points in the tree"
22:23:12 <ac> gwern: why wouldn't you move a file in to another file?
22:23:32 <gwern> ac: I don't know what that woudl even mean!
22:23:37 <gwern> would it be insertion?
22:23:41 <shapr> Maybe it would mean concatenation?
22:23:42 <ac> gwern: like scook0 says, there's no reason to just stop at one point
22:23:53 <gwern> would it be like concatenating the files and erasing the original with the concatenation?
22:23:56 <ac> gwern: you would be indexing a portion of that file
22:24:08 <gwern> would you insert the second into the middle of the first? or what?
22:24:31 <scook0> you'd have to abandon the notion of a "file" being an uninterpreted blob
22:24:38 <allbery_b> windows has the concept of multi-stream files; OS/400 containers can be both files and directories
22:24:40 <ac> the way I think it would be useful would be to put portions of a file in to various directories so you can categorize things on a finer level than an arbitrary file block
22:25:14 <ac> scook0: I think that would be a good thing. The more structure is available in the file system, the more applications can cooperate
22:25:39 <scook0> there's also the UI angle to consider
22:25:45 <ac> right now, almost all files are useless buckets of bits without a specific application to interpret it
22:26:07 <gwern> ac: would these portions be exclusive to various directories? if so, how is that not an oddly presented bunch of files?
22:26:08 <scook0> ac: the problem with breaking the unix "dumb files" assumption is that you have to be careful when transporting your files
22:26:37 <ac> gwern: I think it would work best with a logical file system, where files can be in many "directories"
22:26:46 <gwern> so kind of like tagging...
22:26:53 <ac> gwern: exactly
22:27:07 <ac> gwern: kind of like XML on a file system level
22:27:17 * gwern isn't familiar with XML sry
22:27:17 <ac> gwern: but not restricted to trees
22:27:45 <ac> gwern: XML is like ugly S-Expressions with some extra semantics for schemas and name spaces
22:27:46 <goalieca> tagging is a dream of mine
22:27:55 <goalieca> but all OS's would have to be portable about it
22:28:08 * allbery_b notes that unix hardlinks already allow you to do the multiple-directory thing, and historically some applications used them that way (notably usenet B/C news and MH for mail)
22:28:08 <goalieca> i can already tag in mac but it doesn't copy to linux
22:29:11 <scook0> goalieca: that's what I was referring to with the "difficult to transport" problem
22:29:49 <scook0> anything more structured than a simple blob gets mangled pretty quickly when you send it through other systems
22:30:25 <scook0> which is a significant barrier to widespread filesystem-metadata adoption
22:30:30 <gwern> a pity more OSs don't have something like FUSE
22:31:08 <shapr> Ah, FUSE fits in here, doesn't it?
22:31:15 <scook0> also a pity there's no good filesystem that works well across all OSs
22:31:29 <ac> FUSE is linux's user file system module, right?
22:31:34 <scook0> yeah
22:31:38 <ac> LFS uses that
22:31:39 <shapr> Yeah, you can view anything as a file/system.
22:31:45 <gwern> then you could optin - on systems with your favorite fancy metadata stuff, run natively, on stupid systems, export your fancy files to text or something and then get back your fancy capabilities by going through a special FUSE-mounted FS which interprets the text
22:32:13 <ac> for a long time I've been toying with the idea of making my home directory some fancy FUSE file system
22:32:21 <ac> that has intelligent tagging and stuff
22:32:24 <gwern> one of the crypto ones?
22:32:34 <ac> and sure, why not crypto?
22:32:56 <ac> but you don't need FUSE for an encrypted file system
22:33:06 <gwern> makes it easier
22:33:58 <ac> I'd better turn in
22:34:15 <gwern> I tried to use the wikipediafs one, but it's just not polished enough to be easier than going through a browser
22:34:32 <ac> I want to play with gmailFS some time
22:34:46 <ac> that cracks me up
22:35:08 <ac> It would be great if it automatically spanned accounts, so you can get more than 2G
22:35:08 <gwern> ac: I did for a while. you have to be careful - google temporarily disables accounts which 'send' too many emails/attachments
22:35:26 <ac> gwern: figures they do something
22:35:49 <gwern> ac: I'm not sure whether it's still as 'inefficient'
22:36:06 <gwern> ac: it's more than 3g these days
22:36:50 <gwern> oh, 5.7 currently
22:36:58 <ac> jesus
22:37:21 <ac> that's got to be accounting for the fact that most accounts don't use more than 100M
22:37:36 <gwern> not too shabby. spend 20 minutes setting up 10 accounts, and you have a handy drive for archiving pictures and documents
22:37:49 <gwern> maybe do another 10 and RAID'em
22:38:06 <ac> yeah that's what I've been meaning to do for about a year
22:38:23 <gwern> of course you'd encrypt them
22:38:30 <gwern> hostile servers and all that
22:42:23 <OceanSpray> :t callCC
22:42:25 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
22:45:22 <ac> 'night PST folks. Bye everyone else
22:45:31 <roger`> google are going to offer storage soon anyway, I think.
23:16:18 <roconnor> @bab nl en vertraging
23:16:19 <lambdabot>   delay
23:31:31 <glguy> :t let mapc f (x:xs) c = f x $ \ x -> mapc f xs $ \ xs -> c $ x : xs in mapc
23:31:32 <lambdabot> forall t a b b1. (t -> (a -> b) -> b) -> [t] -> ([a] -> b1) -> b
23:33:30 <glguy> :t let mapc f (x:xs) c = f x $ \ x -> mapc f xs $ \ xs -> c $ x : xs ; mapc _ [] c = c [] in mapc
23:33:31 <lambdabot> forall t a b. (t -> (a -> b) -> b) -> [t] -> ([a] -> b) -> b
23:33:45 <glguy> much better :)
23:41:36 <glguy> :t let mapc = (seqc .).map ; seqc [] c = c[] ; seqc (f:fs) c = f $ \ x -> seqc fs $ \ xs -> c $ x:xs in mapc
23:41:37 <lambdabot> forall a a1 b. (a -> (a1 -> b) -> b) -> [a] -> ([a1] -> b) -> b
23:41:48 <glguy> :t let mapc = (seqc .).map ; seqc [] c = c[] ; seqc (f:fs) c = f $ \ x -> seqc fs $ \ xs -> c $ x:xs in seqc
23:41:49 <lambdabot> forall a b. [(a -> b) -> b] -> ([a] -> b) -> b
23:42:03 <glguy> ?unmtl Cont b a
23:42:03 <lambdabot> (a -> b) -> b
23:42:48 <glguy> :t sequence :: [Cont b a] -> Cont b [a] -> b
23:42:49 <lambdabot>     Couldn't match expected type `Cont b a'
23:42:49 <lambdabot>            against inferred type `Cont b [a] -> a'
23:42:49 <lambdabot>       Expected type: [Cont b a] -> Cont b [a] -> b
23:43:36 <glguy> :t sequence :: [Cont b a] -> Cont b [a]
23:43:37 <lambdabot> forall b a. [Cont b a] -> Cont b [a]
23:51:20 <glguy> :t let mfix f = f =<< mfix f
23:51:21 <lambdabot> <command line>:
23:51:25 <glguy> :t let mfix f = f =<< mfix f in mfix
23:51:25 <lambdabot>     Could not find module `L':
23:51:25 <lambdabot>       Use -v to see a list of the files searched for.
23:51:25 <lambdabot> forall b (m :: * -> *). (Monad m) => (b -> m b) -> m b
