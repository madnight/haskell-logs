00:06:06 <ddarius> pastorn: yes
00:11:58 <pastorn> i was looking in the log and this caught my eye:
00:12:00 <pastorn>  data Tree a = Empty | Leaf a | Branch (Tree a) (Tree a)
00:12:20 <pastorn> i would do data Tree a = Empty | Node (Tree a) a (Tree a)
00:13:05 <pastorn> i don' know how that which you wrote would work... it seems you would have no real nodes, just elements in the ends
00:14:53 <shachaf> pastorn: Why? Branch (Branch (Leaf 1) (Leaf 2)) (Branch (Branch (Leaf 3) (Leaf 4)) Empty)?
00:15:11 <ddarius> pastorn: My toList' function used the latter type of tree.  My foldTree was just another, particularly nice, example of using the same appending technique.  It is of no use for a BST.
00:15:53 * shachaf must've missed the earlier conversation, sorry.
00:40:36 <gmh33> anyone around that can help with porting GHC?
00:47:02 <xmasZsoL> gmh33, what are you porting to?
00:47:15 <gmh33> mac osx 10.5 ppc
00:47:22 <xmasZsoL> ahh
00:47:31 <xmasZsoL> notme, sorry :-(
00:51:20 <gmh33> np :)
00:52:01 <gmh33> xmasZsoL: just following along the guide
00:52:06 <gmh33> hoping it works
00:52:09 <allbery_b> gmh33: the ppc code generator is broken
00:52:23 <gmh33> allbery_b: thought it was fixed in 6.8.2
00:53:05 <allbery_b> hm, thought someone tried the build and it was still creating bogus code
00:53:39 <gmh33> allbery_b: not sure, but I'm trying it anyways
00:55:19 <gmh33> I probably screwed up though
00:55:22 <gmh33> will have to try again
01:59:19 <ac> hello
02:07:12 <kolmodin> is it possible to set several email addresses in _darcs/prefs/email ?
02:10:42 <dons> kolmodin: not sure... i was wondering this today...
02:10:52 <dons> try it? :)
02:11:30 <ac> so I found out that there IS an OO library for Haskell
02:11:54 <ac> a while back people here seemed to think no such thing existed
02:12:15 <dons> there's a couple of researchy things.
02:12:22 <dons> hlist has been used for oo-ish things
02:12:37 <dons> ac, i think the view is more that its not a practical approach to take in haskell
02:12:48 <ac> oohaskell uses hlist
02:12:54 <kolmodin> dons: sure :) let's see what happens :)
02:15:03 <ddarius> ac: People here are well aware of OOHaskell
02:15:45 <ac> I figured so
02:15:55 <ac> has anybody here used Agda?
02:20:55 <ac> guess not
02:21:09 <kolmodin> breakfast!
02:21:29 <Cin> bacon and egg?
02:21:51 <ac> breakfast sure sounds good. Too bad it's 2am here
02:22:25 <Cin> a true breakfaster knows no, er, time..
02:23:02 <ac> Cin: you mean a true breakfaster knows all time is breakfast time?
02:26:35 <Cin> ac: right! :P
02:28:03 <toad3k> easy question: I can't seem to write this function: iterate (-1) 10
02:28:35 <Cin> what's that supposed to do?
02:28:45 <toad3k> the opposite of iterate (+1) 0
02:28:55 <toad3k> it gets confused because it thinks - is unary
02:29:08 <ari> :t subtract
02:29:10 <lambdabot> forall a. (Num a) => a -> a -> a
02:29:35 <toad3k> ok thanks
02:29:45 <Cin> couldn't one also use (-)?
02:30:00 <toad3k> I couldn't get it to work with any set of parenthesis
02:30:23 <Cin> > iterate ((-) 1) 10
02:30:25 <lambdabot>  [10,-9,10,-9,10,-9,10,-9,10,-9,10,-9,10,-9,10,-9,10,-9,10,-9,10,-9,10,-9,10,...
02:30:43 <scook0> > iterate (subtract 1) 10
02:30:44 <lambdabot>  [10,9,8,7,6,5,4,3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-...
02:30:44 <toad3k> it negates each term
02:31:02 <Cin> > iterate (1 (-)) 10
02:31:03 <lambdabot>        add an instance declaration for (Num ((a1 -> a1 -> a1) -> a -> a))
02:31:07 <scook0> (-x) is a special case
02:31:08 <Cin> ah well
02:31:28 <scook0> it means (negate x) instead of \y -> y - x
02:31:42 <scook0> which is why subtract exists
02:31:56 <Cin> makes sense
02:32:29 <scook0> > iterate (flip (-) 1) 10
02:32:30 <lambdabot>  [10,9,8,7,6,5,4,3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-...
02:32:43 <Cin> heheh
02:33:57 <Cin> yay i'm passing an image to a drawing event by using a closure for the callback. No More Globals
03:53:28 <roconnor> > iterate (subtract 1) 10
03:53:29 <lambdabot>  [10,9,8,7,6,5,4,3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-...
04:16:30 <Jomyoot> is Clean much similar to Haskell?
04:17:11 <ndm> Jomyoot: yes
04:17:12 <lambdabot> ndm: You have 1 new message. '/msg lambdabot @messages' to read it.
04:17:42 <Jomyoot> then what is the point of clean?
04:17:46 <Jomyoot> but i hear it's faster
04:18:15 <ndm> roughly the same speed
04:18:29 <ndm> it does uniqueness types instead of monads
04:18:37 <ndm> only one implementation, not a standard
04:18:42 <ndm> but some cool backend performance stuff
04:19:01 <ndm> the haskell front-end optimiser is probably better, the clean back-end one is probably better
04:20:09 <ddarius> Jomyoot: What is the point of C# given Java?
04:24:57 <roconnor> ddarius: to help make mircosoft money?
04:25:50 <pejo> ddarius, didn't Clean show up earlier than Haskell?
04:25:59 <ddarius> pejo: Indeed.
04:27:14 <pejo> ddarius, so your question should have been "What is the point of Java given C#?". :-)
04:28:16 <ddarius> pejo: Not really as I was supressing that aspect (as Haskell -did- have a point despite extent similar languages).  Either way though works.
04:35:09 <Cin> ddarius: interesting question. .NET's a framework for multiple languages whereas Java is just one language? if that's true then i guess the question is "why not Java instead of c#"? ._.
04:35:43 <kolmodin> dons: I did a simple test with several addresses in _darcs/prefs/email and it worked
04:35:56 <kolmodin> so I added myself too
04:35:58 <kolmodin> dcoutts: and you
04:50:44 <oklopol> learn haskell in you sleep -tapes are a great idea
04:50:47 <oklopol> i'd buy
04:51:09 <Cin> hehehe
04:51:21 <Cin> coding in your sleep. now that's an idea!
04:58:17 <oklopol> i've actually had dreams where i debugged a program
04:58:26 <oklopol> once, i actually finished a whole program in my sleep
04:58:49 <oklopol> was a bit disappointing to find it unfinished in the morning :)
04:59:06 <oklopol> of course i remembered nothing about the actual code
05:14:48 <allbery_b> the more I look at that bytestring thing on -cafe, the more I think the core of it really wants to be MaybeT (State ByteString Int)
05:16:11 <allbery_b> except, of course, (1) no standard MaybeT (2) the tuple is inverted compared to State.  and (3) maybe it should really have been StateT ByteString (Maybe Int) anyway :)
05:43:48 <pejo> Suppose I have two functions that should be equal for all inputs < 1000. Do I need to make a generator to quickcheck them against eachother?
05:45:15 <Igloo> I'd just use a unit test    all (\x -> f x == g x) [1..1000]
05:45:53 <allbery_b> \n -> n < 1000 ==> f n == g n -- ?
05:46:27 <Igloo> Or 999 rather
05:51:04 <pejo> Igloo, that was what I ended up doing.
05:52:10 <pejo> allbery_b, I have no idea what I'm doing, but I tried that too and ended up with a stack overflow and the testing aborted
06:04:40 <Beelsebob> how does one compile ,with PackedString these days?
06:06:43 <allbery_b> install it from hackage?
06:08:11 <Beelsebob> I thought it ,ao bundled with ghc these days?
06:08:34 <Igloo> It's only an extralib now
06:08:42 <Beelsebob> oh, okay
06:09:04 <Beelsebob> no wonder I'm gettimg jcomplaints about the lack of it
06:09:04 <Igloo> And is deprecated, but you probably know that already
06:09:47 <Beelsebob> I didn't... I don't know my way arround what's gone on ,ith it
06:10:15 <LoganCapaldo> ByteString is the new PackedString isn't it?
06:10:22 <allbery_b> ByteString is the preferred replacement, yes
06:10:22 <fasta> How can I build a Haskell program (executed in ghci) that calls other programs that can be interrupted immediately (meaning that it will terminate within 0.5 seconds without starting other programs) while using unsafePerformIO to start said programs?
06:10:23 <lambdabot> fasta: You have 1 new message. '/msg lambdabot @messages' to read it.
06:10:25 <LoganCapaldo> (and red the new black?)
06:10:50 <Igloo> No, PackedString is unicode Char's, ByteString is Word8's
06:11:08 <zx]treads> LoganCapaldo : ha
06:11:30 <Igloo> There has been talk of a ByteString-like packedstring replacement, but I'm not sure if one has appeared yet or not
06:11:33 <LoganCapaldo> So ByteString isn't the preferred replacement, or were just just pointing out differences?
06:11:38 <LoganCapaldo> ah
06:11:57 <Igloo> Well, it's the preferred replacement if you didn't really want more than 8-bit Chars in the first place
06:12:52 <LoganCapaldo> gotcha
06:13:14 <LoganCapaldo> I think I'm gonna try to avoid strings for the rest of my programming career
06:13:28 <Igloo> :-)
06:13:41 <LoganCapaldo> unicode / enocdoings / 8bit chars, null terminated, blergh
06:13:50 <LoganCapaldo> it's a mess out there
06:13:57 <Igloo> If I were you, I wouldn't even acknowledge the /existence/ of time
06:57:37 <duki> hello
06:59:16 <desegnis> Salve.
07:00:04 <toad3k> project euler is fun.
07:00:38 <toad3k> plugging in that number after an hour of working and the anticipation of waiting for the page to load to find out if it was all worth while.
07:06:50 <qebab> project euler is indeed awesome
07:08:59 <qebab> http://paste.lisp.org/display/52976 <= Would anyone mind taking a look at this? I'm having a bit of problems getting things to compile and I know what is wrong, but I have no idea how to fix it ):
07:10:42 <sjanssen> @type sqrt
07:10:43 <lambdabot> forall a. (Floating a) => a -> a
07:10:46 <Saizan> ?type floor . sqrt . romIntegral
07:10:48 <lambdabot> Not in scope: `romIntegral'
07:10:52 <Saizan> ?type floor . sqrt . fromIntegral
07:10:53 <lambdabot> forall b a. (Integral b, Integral a) => a -> b
07:11:03 <sjanssen> qebab: sqrt can only be used on floating point numbers, not integers
07:11:56 <qebab> sjanssen: yeah, I figured that much, but do I then need to say that the function takes a floating point number, or is there some way to cast the parameter to sqrt inside my function?
07:11:57 <davidL> Is it invalid to have field names of a datatype be in all uppercase, for example: data ControlBits = ControlBits { urg, ack, PSH, RST, SYN, FIN :: !Bool } ?
07:12:13 <sjanssen> qebab: instead of "div > sqrt n" consider using "div*div > n"
07:12:29 <qebab> right, that works as well /o\
07:12:36 <qebab> talk about thinking inside the box heh
07:13:24 <filcab42> hi
07:13:40 <qebab> it's probably faster as well, amusingly enough
07:13:49 <sjanssen> and more accurate
07:13:53 <qebab> indeed
07:13:59 <filcab42> how can I do something like: data Atom = LNumber Num | LCharacter Char | LList [Atom]
07:14:04 <sjanssen> davidL: no
07:14:13 <filcab42> Since Num is a type class, I can't use it
07:14:18 <davidL> sjanssen: Why not?
07:14:28 <sjanssen> davidL: them's the rules :)
07:14:30 <filcab42> or should I parameterize the Atom type?
07:14:48 <sjanssen> davidL: they need to be lower case to avoid ambiguity in pattern matching
07:15:14 <sjanssen> filcab42: parameterize, probably
07:15:23 <davidL> sjanssen: thanks
07:15:27 <filcab42> but if I parameterize, I get nonsense like:
07:15:45 <filcab42> Data Atom a = LNumber a | LChar a | LList [a]
07:16:38 <filcab42> if 'a' is a Char, there's no sense in having LNumber a
07:17:18 <sjanssen> filcab42: are you modeling lisp?
07:17:34 <filcab42> I'm trying to learn Haskell by implementing a subset of Lisp, yes
07:17:38 <sjanssen> filcab42: if so, make a numeric type that models lisp's numbers
07:17:42 <filcab42> as you can see, it's in it's beginning :$
07:18:03 <filcab42> but I still have the same problem
07:18:15 <sjanssen> maybe, data LispNum = LFloat Double | LInt Integer
07:18:31 <filcab42> an expression will be a symbol or a string or a number or...
07:19:33 <sjanssen> filcab42: right, we're defining "number" exactly
07:20:17 <filcab42> yes
07:20:53 <filcab42> oh
07:21:07 <filcab42> I wasn't understanding what you point was
07:21:09 <filcab42> thanks
07:21:46 <filcab42> nice
07:21:48 <filcab42> thanks ;)
07:25:42 <qebab> is there a way to tell haskell that I absolutely, positively indeed want to do integer division and it's entirely safe to not have to use the Fractional Integer?
07:26:00 <fasta> qebab: div
07:26:05 <qebab> ah
07:26:06 <qebab> thanks
07:30:38 * Cin pokes qebab
07:31:56 <qebab> Cin: :))
07:31:59 <qebab> what's up?
07:46:10 <vali> hello. does anyone know of any good haskell tutorials based on doing exercises? i feel that i learn better when i have something concrete to work on.. just reading doesn't help me
07:46:37 <vali> like universities with weekly exercises/solutions? i've tried looking for that sort of thing, but i can't find any
07:49:49 <davidL> vali: project euler may be of interest
07:50:31 <fasta> vali: every textbook on Haskell has exercises, however, I believe you only get the basics of Haskell that way.
07:51:33 <Cin> qebab: just reading a tutorial about gtk2hs for a four-in-a-row game i'm writing
07:51:42 <vali> ah, okay. i've read through several haskell tutorials, but i just can't sit down and code anything
07:52:09 <qebab> cool
07:52:22 <qebab> how is haskell for writing GUIs? :o
07:52:35 <qebab> that's traditionally an OO thing as far as I can tell
07:52:39 <davidL> you could also do the exercises from sicp in haskell
07:53:35 <Cin> qebab: it seems pretty good. i don't really know what 'OO' means so i dunno about that
07:54:02 <qebab> Cin: it means object orientation on this side of the internet ;)
07:54:36 <Cin> qebab: can you define object orientation?
07:54:43 <qebab> Cin: No, not at all
07:54:47 <qebab> Cin: can you? :D
07:55:00 <Cin> qebab: no, i just said i don't know what it means :)
07:55:09 <qebab> oh right
07:55:14 <sieni> yeah, oo == imperative programming on steroids
07:55:20 <Cin> haha
07:55:20 <mrd> smalltalk-style OO was traditional for writing GUIs
07:55:25 <mrd> java-style OO is a disaster
07:55:31 <b_jonas> object orientation means too many things
07:55:34 <qebab> java/c++ OO is terrible
07:55:43 <qebab> I want to learn smalltalk at some point
07:55:51 <b_jonas> it means any of the several paradigms which has a concept called "object"
07:56:10 <mrd> my C programs produce "object" files which means C is object-oriented!
07:56:11 <Cin> i guess if for a start you're talking about encapsulation, i think you get that with the haskell module system
07:56:19 <b_jonas> mrd: lol
07:56:28 <b_jonas> well, yes, then it is
07:57:45 <Cin> qebab: other than that i've not done much with it yet! gtk2hs uses the IO monad for all interaction with Gtk. thought by some to be bad but it's quite easy to follow which is good
07:58:53 <qebab> I meant to do it in scheme or cl at some point, but I've only written GUIs in python yet :/
07:58:59 <b_jonas> what kind of interaction with Gtk could you do without IO?
07:59:14 <b_jonas> "interaction" sort of means IO by itself
07:59:34 <qebab> well, displaying GUIs lazily is probably not ideal
07:59:35 <b_jonas> but even without that, I can't imagine what a GUI toolkit like Gtk would provide that's not IO
07:59:53 <desegnis> b_jonas, the IO monad could be abstracted away for the purposes of the UI
07:59:58 <Cin> jonas: true. perhaps i meant manipulation of the GUI. i think there are probably other more functional ways to do it
08:00:14 <Cin> right, what desegnis said
08:00:16 <b_jonas> what do you mean by abstracting away?
08:01:03 <b_jonas> Cin: hmm, you mean like building a larger structure by aggregating widgets?
08:01:04 <desegnis> b_jonas, you have functions (combinators) that describe the UI, and you have some function runUI :: UI -> IO ()  ... or similar
08:01:16 <b_jonas> desegnis: ah yes,
08:01:19 <b_jonas> that could make sense
08:01:32 <b_jonas> I dunno
08:01:38 <b_jonas> I don't really know Gtk much either
08:02:06 <desegnis> b_jonas, there are attempts at such combinator libraries, but rather for the purposes of experiments, nothing really usable
08:02:23 <desegnis> and I think, not for Gtk
08:05:55 <Cin> destroyEvent :: IO()
08:05:55 <Cin> destroyEvent = do mainQuit
08:06:02 <Cin> i wonder why `do' is used
08:06:57 <sjanssen> Cin: if there is no line beneath, the do is redundant
08:07:01 <Cin> hm, i guess to demonstrate that it's an action.. in case IO () isn't enough
08:07:07 <Cin> sjanssen: i thought so
08:17:15 <Cin> :t &&
08:17:17 <lambdabot> parse error on input `&&'
08:17:24 <Cin> :t (&&)
08:17:25 <lambdabot> Bool -> Bool -> Bool
08:17:28 <Cin> awesome
08:19:38 <Zao> :t or
08:19:39 <lambdabot> [Bool] -> Bool
08:20:11 <Cin> yeah i like `or'
08:22:49 <Cin> is at all possible that this code: if or [name == "Simon", name == "John", name == "Phil"]
08:23:16 <Cin> would compile to the same thing as: if name == "Simon" || name == "John" || name == "Phil"
08:23:23 <Cin> hm?
08:23:23 <mrd> @src or
08:23:23 <lambdabot> or    =  foldr (||) False
08:23:26 <mrd> yep!
08:23:29 <Cin> :D
08:24:40 <Cin> writing this looks nicer: if any (== name) ["Simon","John","Phil"]
08:24:44 <Valodim> find (name ==) ["Simon", "John", "Phil"]
08:24:48 <Valodim> haha, yeah
08:24:50 <LoganCapaldo> > let name = "John" in any (name ==) ["Simon", "John", "Phil"]
08:24:52 <lambdabot>  True
08:24:55 <Cin> haha
08:24:59 <Cin> jynx
08:24:59 <Valodim> especially for more than three names
08:25:15 <Cin> right. would it be silly for only three?
08:25:20 <LoganCapaldo> no!
08:25:26 <Cin> like, a tiny tiny performance hit?
08:25:32 <sjanssen> @src elem
08:25:32 <lambdabot> elem x    =  any (== x)
08:25:45 <Cin> oooo
08:26:03 <Cin> even better :P
08:26:13 * LoganCapaldo always forgets about elem
08:27:47 <Cin> :t find
08:27:48 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
08:31:09 <Cin> is there a particular paper, commonly accepted and recommended, about code style? like, i can lay out 'if/then/else' in a few different ways
08:32:47 <Valodim> how do I cast to float? or in particular, make this work:
08:32:47 <Valodim> (/num) . sum asdf
08:33:28 <Taejo> :t fromIntegral
08:33:29 <lambdabot> forall a b. (Num b, Integral a) => a -> b
08:34:27 <davidL> > (/2) . fromIntegral . sum [1..10]
08:34:28 <lambdabot>   add an instance declaration for (Enum (a -> b))
08:34:47 <davidL> > (/2) . fromIntegral . sum $ [1..10]
08:34:48 <lambdabot>  27.5
08:37:58 <noteventime> > [1..]
08:37:59 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
08:38:04 <noteventime> :-P
08:38:19 <noteventime> Just wanted to see what it'd do
08:38:48 <pcmoritz> hi, i've got a question: is it possible to do something like the following:
08:38:50 <pcmoritz>  sets :: (ParsingState -> a) -> a -> ParsingMonad b
08:38:50 <pcmoritz>  sets f value = modify (\s -> s {f = value})
08:39:17 <pcmoritz> ParsingMonad is a MonadState instance...
08:39:39 <pcmoritz> and Parsing state a record
08:39:39 <oerjan> pcmoritz: alas you cannot pass a field as a first class argument
08:39:51 <pcmoritz> that is a pitty...
08:40:05 <oerjan> they just become lookup functions
08:40:51 <pcmoritz> is there another trick to avoid always typing this record-mess?
08:41:06 <oerjan> there is something called functional references
08:41:30 <oerjan> which is essentially constructing first class fields from scratch i guess
08:42:01 <oerjan> a pair of setter and getter is one way
08:42:33 <pcmoritz> i've got many functions like this one:
08:42:35 <pcmoritz> > setInput :: String -> ParsingMonad ()
08:42:35 <pcmoritz> > setInput str = modify (\s -> s {inputString = str})
08:42:36 <lambdabot>   Not in scope: type constructor or class `ParsingMonad'
08:42:36 <lambdabot>  Parse error at "=" (column 14)
08:42:46 <oerjan> btw modify is a method in MonadState
08:42:47 <pcmoritz> oh, sorry
08:42:57 <oerjan> so that part is covered
08:43:07 <oerjan> :t modify
08:43:08 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
08:43:29 <oerjan> you'd just make your ParsingMonad an instance of that
08:43:30 <Saizan> you can write sets :: (a -> ParsingState -> ParsingState) -> a -> ParsingMonad b; sets f value = modify (\s -> f value s); and then use just setters written like upd_Input str s = s{inputString = str}
08:43:36 <pcmoritz> ok, but i can't avoid something like setInput:
08:43:37 <pcmoritz> setInput :: String -> ParsingMonad ()
08:43:38 <pcmoritz> setInput str = modify (\s -> s {inputString = str})
08:44:10 <oerjan> not entirely, no
08:44:11 <Valodim> (/(fromIntegral num)) <- how would I write this cleaner?
08:44:33 <oerjan> Valodim: looks clean to me
08:44:51 <Valodim> no way to do it with . or $?
08:44:55 <Valodim> I tried some, none work
08:45:02 <pastorn> Valodim: do you want to enforce any specific typecasting?
08:45:11 <pcmoritz> ok, thank you :)
08:45:16 <oerjan> er it is already pointfree. do you mean num to be an argument?
08:45:23 <Valodim> num is Int, passing that gives an erro
08:45:23 <Valodim> r
08:45:45 <oerjan> in which case flip (/) . fromIntegral should do
08:45:58 <pastorn> @type (fromIntegral (0 :: Int) )
08:45:59 <lambdabot> forall b. (Num b) => b
08:46:36 <Valodim> it's inside of some context so no point-free :P
08:46:39 <pastorn> @type (/ fromIntegral (0 :: Int) )
08:46:40 <lambdabot> forall a. (Fractional a) => a -> a
08:46:59 <pastorn> heh, divByZero...
08:48:02 <oerjan> pcmoritz: actually i recall some people have used template haskell to autogenerate such things for fields
08:48:26 <pcmoritz> yeah, that sounds great...
08:48:33 <Valodim> (/) $ fromIntegral num
08:48:36 <Valodim> that's what I was looking for :)
08:48:41 <pcmoritz> i have to give TH a try
08:49:16 <oerjan> Valodim: er that will divide num by the next argument, not the other way
08:49:38 <Valodim> ah, yeah I see
08:49:40 <Valodim> dang
08:50:07 <oerjan> if you don't use a section you will need a flip
08:50:33 <Valodim> ok I'll leave it at the first solution then
08:50:41 <oerjan> oh you don't need parentheses in that section
08:50:49 <oerjan> (/ fromIntegral num) is enough
08:51:03 <Valodim> ah
08:51:06 <Valodim> cool
08:51:54 <pcmoritz> btw, is there a specific reason, that record fields are not first class?
08:52:25 <pastorn> Valodim: say we have an infix function <<>> that takes two arguments x & y of types X and Y so that (<<>>) :: X -> Y -> Z
08:52:25 <oerjan> pcmoritz: i guess it's just part of the mess of no one ever agreeing how to improve the record system
08:52:50 <oerjan> h98 just implemented a minimum everyone could agree on, or something
08:53:17 <pastorn> then you have that (x <<>> y) :: Z and ( (<<>>) x y ) :: Z
08:53:37 <oerjan> the communities report mentioned some interesting upcoming things for ghc though
08:53:41 <pastorn> parenthesis around an infix operator makes it prefix :)
08:54:31 <Valodim> I know
08:54:37 * pastorn had the worst time understading wtf was goin on with \x -> map ($ x) (f:fs) )
08:54:44 <oerjan> although i don't think it gave equivalent power to functional references
08:55:43 <pcmoritz> some of this ideas are quite cool: http://research.microsoft.com/~simonpj/Haskell/records.html
09:13:19 <Cale> Haskell 98 doesn't really have a record system so much as it has some handy alternate syntax for algebraic types.
09:26:15 <Saul> Cale: And even the "handy" part can be disputed, I always seem to want to use the same name in various datatypes which won't work
09:27:04 <Cale> Well, allowing you to do that would destroy what I actually most commonly use the syntax for :)
09:27:22 <Cale> (which is to automatically define extractor functions)
09:27:22 <Saul> Seems like with some deeper sugaring you could get the generated accessor functions polymorphic
09:27:46 <b_jonas> Saul: in fact, that's what SML does
09:27:47 <b_jonas> sort of
09:28:10 <b_jonas> SML has no custom fieldnames in defined datatypes, but it has tuples with named elements
09:28:22 <b_jonas> these don't have to be declared as a datatype, they can just be used
09:28:32 <Saul> b_jonas: Ok, well it's seems a little better to me than the way it works now, although full blown records might be even better
09:28:49 <b_jonas> so the extractor function that extracts the field of a given name or number from a tuple is polymorphic
09:29:11 <b_jonas> however, because SML doesn't have a class system, those polymorphic types are a bit strange
09:29:24 <Saul> I can imagine
09:29:38 <b_jonas> it's as if there was a class for every field name
09:30:28 <Saul> Is there a function  of type Either e (a -> b) -> Either e a -> Either e b?
09:30:30 <mrd> thankfully sml doesn't have a class system.  functors are superior.
09:31:26 <b_jonas> @hoogle m (a -> b) -> m a -> m b
09:31:27 <lambdabot> Prelude.asTypeOf :: a -> a -> a
09:31:27 <lambdabot> Prelude.const :: a -> b -> a
09:31:27 <lambdabot> Prelude.seq :: a -> b -> b
09:31:56 <b_jonas> @hoogle m a -> m (a -> b) -> m b
09:31:57 <lambdabot> Prelude.asTypeOf :: a -> a -> a
09:31:57 <lambdabot> Prelude.const :: a -> b -> a
09:31:57 <lambdabot> Prelude.seq :: a -> b -> b
09:31:58 <sjanssen> Saul: sounds like <*>
09:32:05 <Saul> Those aren't very helpful :)
09:32:21 <b_jonas> yep, those are no good
09:32:25 <Saul> sjanssen: Yeah it does, but Either e is not an applicative
09:32:29 <roconnor> @type ap
09:32:31 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
09:32:33 <sjanssen> pssh, it should be :(
09:33:02 <b_jonas> it's got to be some monad function
09:33:06 <roconnor> @type ap
09:33:08 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
09:33:09 <Saul> sjanssen: Yeah but I get it somewhat, since you have to choose which Left to keep
09:33:11 <Liskni_si> @src Prelude.const
09:33:11 <lambdabot> Source not found.
09:33:17 <Liskni_si> @src asTypeOf
09:33:18 <lambdabot> asTypeOf = const
09:33:21 <b_jonas> that's it
09:33:25 <b_jonas> rocconnor wins
09:33:29 <roconnor> \o/
09:33:51 <Saul> roconnor: Ah yeas `ap` will work, since it's te same thing as <*> but for monads
09:34:17 <sjanssen> Saul: there is a good chance you can't use ap here
09:34:32 <roconnor> sjanssen: why not?
09:34:59 <sjanssen> "instance (Error e) => Monad (Either e)"
09:35:07 <roconnor> oh right
09:35:18 <sjanssen> stupid fail
09:35:53 <hnefi> heyall
09:36:08 <roconnor> hi
09:36:26 <hnefi> anyone know how (or where I can find out how) to define Show-routines for my user-defined types?
09:36:35 <hnefi> in GHC
09:37:00 <sjanssen> hnefi: take "deriving Show" to the end of the data declaration
09:37:05 <sjanssen> s/take/tack/
09:37:28 <hnefi> trying it out
09:38:06 <hnefi> that worked. Thanks.
09:38:44 <hnefi> is it possible to alter the way things are printed with Show?
09:38:48 <Saul> hnefi: If at some point that doesn't work, there is a way to manually define it
09:39:07 <Saul> hnefi: Same way
09:39:26 <Saul> instance Show a where
09:39:43 <sjanssen> hnefi: yes, but it isn't typically recommended
09:39:43 <hnefi> I'm afraid you lost me there
09:40:19 <hnefi> how so?
09:40:22 <Saul> Actually I'll paste a piece of code since this is not handy
09:40:30 <hnefi> :P
09:41:24 <sjanssen> hnefi: Show instances should have the "copy paste" property, 'show x' should give valid Haskell source that you can paste into your program
09:41:45 <hnefi> ah
09:42:17 <Saizan> 1
09:42:25 <oerjan> > 1/0 -- fnord
09:42:26 <lambdabot>  Infinity
09:42:28 <sjanssen> in fact, it is probably easier to write your own display function when you want a specific format
09:42:39 <Saul> hnefi: http://hpaste.org/4639
09:43:11 <hnefi> Yeah, I'll do that. Thanks to you both
09:43:17 <Saul> But sjanssen's remarks are valid
09:59:56 <hnefi> is there a concise recursive algorithm for levelorder traversal of a tree?
10:00:32 <oerjan> breadth-first you mean?
10:00:59 * oerjan doesn't know these new technical terms...
10:01:05 <oerjan> or something
10:01:23 <hnefi> yeah
10:01:27 <Saizan> ?type Data.Tree.levels
10:01:29 <lambdabot> forall a. Tree a -> [[a]]
10:01:48 <hnefi> Saizan: ?
10:02:26 <Saizan> if you use the tree in Data.Tree you've it written for you
10:03:01 <hnefi> Yes, but then I'll never learn Haskell ;)
10:03:22 <hnefi> or are you saying it is available in plain text in the modules?
10:03:37 <Cale> The levelorder traversal of a tree is a list of lists whose first element is the single element list consisting of the value at the root, followed by the elementwise concatenation of the levelorder traversals of each of the children.
10:03:47 <oerjan> the source is available
10:04:35 <hnefi> neato.
10:04:53 <oerjan> @docs Data.Tree
10:04:54 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Tree.html
10:05:08 <oerjan> oops, base, probably broken link
10:05:28 <hnefi> yeah
10:05:47 <oerjan> http://haskell.org/ghc/docs/latest/html/libraries/containers/Data-Tree.html
10:05:48 <lambdabot> http://tinyurl.com/2phbrb
10:06:36 <hnefi> much obliged
10:07:00 <Cale> hnefi: You will probably find the Data.List function 'transpose' very useful.
10:07:19 <Cale> If you want, I can paste the solution :)
10:07:40 <hnefi> nah, that's okay thank you
10:08:53 <Cale> > transpose [[[1],[2,3],[4,5,6]], [[7],[8,9]]]
10:08:55 <lambdabot>  [[[1],[7]],[[2,3],[8,9]],[[4,5,6]]]
10:09:03 <Cale> > map concat . transpose $ [[[1],[2,3],[4,5,6]], [[7],[8,9]]]
10:09:04 <lambdabot>  [[1,7],[2,3,8,9],[4,5,6]]
10:11:07 <hnefi> [1] ++ [2]
10:11:20 <hnefi> (+) 1 2
10:11:31 <oerjan> hnefi: need >
10:11:40 <hnefi> > (+) 1 2
10:11:41 <lambdabot>  3
10:11:43 <hnefi> heh
10:11:45 <hnefi> cute
10:24:46 <roconnor> @go194 seconds in minutes
10:24:47 <lambdabot> Unknown command, try @list
10:24:52 <roconnor> @go 194 seconds in minutes
10:24:53 <lambdabot> 194 seconds = 3.23333333 minutes
10:25:35 <roconnor> I can compute Integrals inside Coq!
10:25:40 <roconnor> very very slowly
10:25:55 <oerjan> @quote heat.death
10:25:56 <lambdabot> sorear says: Unfortunatly, Coq *cannot* prove that your program will terminate before the heat-death of the universe. // psnively> Right. That's a software engineering problem, not a computer
10:25:56 <lambdabot> science problem. ;-)
10:26:10 <roconnor> :D
10:31:36 <roconnor> now I need to prove my integrals are correct.
10:31:45 <roconnor> So far I only prove that they produce a real number.
10:33:37 <b_jonas> roconnor: wow
10:34:40 <b_jonas> what kind of functions can you integrate?
10:34:54 <roconnor> b_jonas: any uniformly continuous function.
10:35:11 <b_jonas> cool
10:35:31 <roconnor> b_jonas: well, I inject the uniformly continuous functions into the ``Bounded Functions''
10:35:55 <roconnor> and inject the ``Bounded Functions'' into the ``Integrable Functions''
10:36:08 <roconnor> and I can integrate any Integrable Function.
10:37:08 <b_jonas> so what do you need to prove about them being correct?
10:37:20 <b_jonas> if you have only one way to do integrations that is.
10:38:13 <roconnor> b_jonas: There is an existing definition of integration of continuous functions.  I will prove my new integral yields the same result.
10:38:20 <b_jonas> I see
10:38:26 <oerjan> linearity, boundedness, correctness on constants and translation invariance determines the usual integral, at least in set theory
10:38:34 <oerjan> or so i believe
10:38:34 <roconnor> b_jonas: the existing definition has all sorts of theory about it.
10:38:47 <roconnor> b_jonas: such as the fundamental theorem of calculus
10:38:50 <ramza3> parseTextDocument fs = concat `fmap` mapM readFile fs   ...in this code, it says that fs should be a filepath; I cant use a parse "./name.txt"  ...?
10:38:58 <ramza3> eg , I am getting an error
10:39:05 <b_jonas> ah yes, fundamental theorem of calculus is the right thing to prove
10:39:38 <roconnor> oerjan: indeed, that is a reasonable specification of integral.
10:40:04 <roconnor> oerjan: since I have an existing integral, proving correctness with respect to it is good enough for me for now.
10:41:18 <roconnor> oerjan: what is boundedness?
10:41:34 <oerjan> ramza3: how are you calling it?
10:42:11 <oerjan> roconnor: hm wait
10:42:30 <ddarius> @google "Daniell Integral"
10:42:31 <lambdabot> http://en.wikipedia.org/wiki/Daniell_integral
10:42:34 <oerjan> doesn't quite work for unbounded domain
10:42:46 <ramza3> oerjan, http://hpaste.org/4640
10:42:51 <oerjan> i am thinking compact space
10:43:24 <oerjan> radon measures
10:45:00 <oerjan> ramza3: your function takes a _list_ of filenames, not a single one
10:45:14 <ramza3> dang it
10:45:20 <ramza3> oerjan, ok, thanks
10:47:33 <oerjan> roconnor: boundedness = continuity, in the setting of compact spaces
10:48:20 <roconnor> oh
10:48:21 <roconnor> okay
10:48:43 <oerjan> then the integral is bounded by a constant times the maximal abs. value of the function
10:49:20 <davidL> How do I match everything after "v=" in "bleh123v=foobar" using Posix regular expressions?
10:50:03 <oerjan> v=\(.*\)$ or something close to it
10:50:45 <davidL> are there perl regular expressions in ghc?
10:50:58 * oerjan doesn't have the differences between posix and perl clear
10:51:53 <oerjan> but mostly it's just about twiddling where you put backslashes, isn't it? :)
10:52:11 <b_jonas> oerjan: no, there's a deeper semantic difference too
10:52:58 <b_jonas> about what grouping parenthesis match when there's more than one way to match a regexp to a string
10:53:15 <b_jonas> obviously, there are syntax differences and lots of small things too
10:56:37 <davidL> I can do "foov=bar" =~ "v=.*" but that includes the v= part
10:57:18 <oerjan> davidL: well \( \) for grouping i think
10:57:52 <oerjan> and the result of =~ has a list instance that gives first the whole thing, then the groups, as i recall
10:57:54 <davidL> <interactive>:1:53: lexical error in string/character literal at character '.'
10:58:16 <oerjan> oh you may need to double backslashes
10:58:43 <oerjan> does that help?
10:58:59 <davidL> it doesn't match anything, ""
10:59:19 <dmwit> "\\(\\)" -- this doesn't match?
10:59:27 <oerjan> "v=\\(.*\\)" ?
10:59:52 <davidL> nope
11:00:43 <elliottt> dons: ping
11:04:03 * oerjan looks at a horrible regex 7 manpage
11:04:35 <oerjan> possibly there shouldn't be backslashes anyhow?
11:04:45 <oerjan> try "v=(.*)"
11:05:13 <davidL> ["v=l69Vi5IDc0g"]
11:05:34 <oerjan> no group defined?
11:06:22 <davidL> what do you mean?
11:06:53 <oerjan> if it had worked, i would have expected ["v=l69Vi5IDc0g", "l69Vi5IDc0g"]
11:07:25 <davidL> "foooobarrrv=l69Vi5IDc0g" =~ "v=(.*)" :: [String]
11:07:30 <oerjan> hm wait...
11:07:31 <davidL> ["v=l69Vi5IDc0g"]
11:07:33 <newsham> http://3quarksdaily.blogs.com/3quarksdaily/2007/11/turning-a-spher.html
11:07:34 <lambdabot> Title: 3quarksdaily, http://tinyurl.com/ywkowg
11:07:35 <oerjan> try [[String]]
11:07:51 <davidL> oh, yeah
11:07:56 <davidL> [["v=l69Vi5IDc0g","l69Vi5IDc0g"]]
11:08:01 <oerjan> yay :)
11:08:28 <oerjan> the outer [] is a list of possible matches it seems
11:09:23 <Zao> There's also a match result where you get a tuple of strings being before, match and after.
11:30:35 <cpst> what's the status of exhaustiveness checking for pattern matching of GADTs?
11:43:34 <wy> hello
11:44:19 <oerjan> hi
11:45:18 <wy> Good morning or afternoon?
11:45:41 <oerjan> evening
11:46:39 <wy> Afternoon here :-)
11:47:09 <Vq^> evening √òrjan, good afternoon wy
11:47:40 <wy> hello Vq^
11:51:06 <opqdonut> ¯rjan :D
11:52:28 <Vq^> thats his name mr Opaque Donut :o)
11:53:08 <oerjan> you laughing at my name, hm? hm?
11:53:12 <loupgaroublon1> √ñrjan would be easier to type in
11:53:39 <oerjan> not on my keyboard
11:53:52 <nornagon> mine neither.
11:53:53 <dmwit> Surely opqdonut is just an abbreviation for opqrstuvwxyzdonut
11:54:12 <oerjan> obviously.
11:54:36 <Vq^> it would on mine, but is mr √òrjans name really fully equivalent with √ñrjan?
11:54:58 <oerjan> norwegian vs. swedish spelling
11:55:01 <loupgaroublond> dunno, i never met a swede with the name √ñrjan
11:55:15 <nornagon> > "√òrjan" == "√ñrjan"
11:55:15 * Vq^ has met several
11:55:16 <lambdabot>  False
11:56:13 <dmw> For your typing ease, fellow #haskellers.
11:56:22 <dmw> Now with 40% fewer letters!
11:57:24 <Botje> everybody should change their nicks so the first two letters of their name is unique.
11:58:08 <dmw> > 26*26
11:58:09 <lambdabot>  676
11:58:12 <nornagon> > length ['a'..'z'] ** 2
11:58:12 <lambdabot>   add an instance declaration for (Floating Int)
11:58:13 <lambdabot>     In the expression: (leng...
11:58:17 <nornagon> > length ['a'..'z'] ^ 2
11:58:18 <lambdabot>  676
11:58:18 <dmw> * There are 22760 listed and 18007 unlisted users on 26 servers
11:58:33 <dmw> > logBase 26 22760
11:58:34 <lambdabot>  3.0793316806790445
11:58:35 <Botje> the convention should only apply on this channel, of course.
11:58:37 <nornagon> #haskell: Total of 382 nicks
11:58:48 <nornagon> @users
11:58:49 <lambdabot> Maximum users seen in #haskell: 434, currently: 383 (88.2%), active: 12 (3.1%)
11:58:56 <dmw> We can kick a few people off, then make it three letters. =)
11:59:06 <Botje> I vote vor lambdabot !
11:59:23 <Zao> dmw: Good call :)
11:59:36 * Cin gasps
11:59:37 <loupgaroublond> > length ['a'..'z'] ** 3
11:59:38 <lambdabot>   add an instance declaration for (Floating Int)
11:59:38 <lambdabot>     In the expression: (leng...
11:59:40 <oerjan> poor lament
11:59:50 * qebab throws a stone down Cins throat
12:00:07 <loupgaroublond> > length ['a'..'z'] ^ 3
12:00:08 <lambdabot>  17576
12:00:25 * mmmdonuts hands mm_freak a poisoned donut in order to resolve name clash
12:00:36 <dmw> haha
12:00:40 <oerjan> > length . replicateM 3 $ ['a'..'z']
12:00:41 <lambdabot>  17576
12:01:33 <Botje> oerjan: you don't trust **? :)
12:01:51 <qebab> oerjan: you wouldn't by chance happen to be an √òrjan I know?
12:02:27 <qebab> I feel filthy for checking your hostmask but we appear to be studying at the same university
12:02:40 <oerjan> qebab: well i don't recognize your name...
12:02:58 <qebab> Robin
12:03:11 <nornagon> i don't think oerjan is that rare a name in norway :)
12:03:13 <qebab> I guess if you're the oerjan I know you'd recognise that but chances are small heh
12:03:16 <qebab> it isn't
12:03:34 <benny99>  /usr/lib/ghc-6.6.1/libHSrts.a(Main.o): In function `main':
12:03:34 <benny99> (.text+0x22): undefined reference to `__stginit_ZCMain'
12:03:34 <benny99>  does anybody know that message?
12:03:46 <Botje> try ghc --make
12:03:56 <benny99> I'm trying to compile a simple testprogram using ghc-6.6.1
12:04:17 <benny99> thanks :-[
12:04:31 <oerjan> checked the other day, it's the 151st most common name...
12:04:33 <desegnis> Is Either a coproduct?
12:04:54 <Botje> oerjan: so what's the first? in norway, that is
12:05:12 * oerjan checks
12:05:42 <oerjan> "Jan"
12:06:09 <oerjan> male name, that is
12:06:15 <nornagon> question: how many people do you have to have in a room before the liklihood
12:06:29 <dmw> desegnis: I think Either is just a sum.
12:06:30 <nornagon> er.
12:06:38 <oerjan> nornagon: about 24-25
12:06:55 <FunctorSalad> *g*
12:06:56 <nornagon> question: how many people do you have to have in a room before the likelihood of having an 'oerjan' in the room is more than 50%?
12:07:04 <oerjan> bah
12:07:07 <dmw> desegnis: err... ignore me, I misread
12:08:18 <opqdonut> dmw: heh
12:08:35 <desegnis> dmw: What was it that you misread? Isn't it a sum?
12:08:53 <oerjan> well sums are coproducts, at least in some categories...
12:09:03 <dmw> desegnis: I misread the Wikipedia article on coproducts. =P
12:09:15 <desegnis> dmw, ah
12:09:27 <benny99> ok, I actually try to write my first vehery simple haskell program on my own :) and I got to know, that I really don't know anything =D
12:09:37 <benny99> I want to create something like a very simple calculator
12:09:43 <benny99> that evaluates "2+4*3" into "14" for example
12:09:50 <dmw> benny99: Cool, have you designed the grammar for it yet?
12:10:06 <desegnis> √∏rjan, oh no... yet another similarity of concepts
12:10:35 <oerjan> direct sums, that is
12:10:50 <benny99> Token = Number | Operator --- Number = 0..9 --- Operator = Plus | Minus | Mult | Div | Return
12:10:52 <benny99> something like that
12:11:06 <dmw> Okay.
12:11:11 <benny99> and I now got to know that I know nothing about haskell =D
12:11:13 <dmw> You won't get any precedence, but it's a good starting point.
12:11:26 <benny99> just read and read and... never actually did something different than exercises
12:11:29 <dmw> benny99: Then next thing to look at (for that application) may be Parsec.
12:11:34 <dmw> ?where parsec
12:11:35 <lambdabot> http://www.cs.ruu.nl/~daan/parsec.html
12:11:39 <oerjan> desegnis: well we have injections Left and Right, do they have the universal property?
12:11:46 <benny99> <_<?
12:12:16 <dmw> benny99: Parsec helps you do parsing, which I guess is the first step in evaluating an expression language like that.
12:12:55 <benny99> dmw: sorry, guess that's nonesense here :-[
12:13:09 <qebab> haskell seems closer and closer to lisp every hour I use it
12:13:13 <benny99> I want to write it myself
12:13:13 <oerjan> assuming functions f :: X -> Z, g :: Y -> Z, define fg (Left x) = f x; fg (Right y) = g y
12:13:15 <desegnis> I've got 150 printed pages of German introductory text to category theory here, but it doesn't mention sums in any heading :-(. oerjan, I think so
12:13:15 <qebab> except the syntax
12:13:18 <desegnis> :t either
12:13:19 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
12:13:23 <dmw> benny99: Oh, have you done any parsing/language stuff before?
12:13:35 <benny99> qebab: of course
12:13:56 <benny99> dmw: I did it a year ago in ocaml, but I forgot it completely :-[
12:14:02 <oerjan> then fg has the right compositions, is it unique?
12:14:43 <desegnis> How to examine whether it's unique?
12:14:44 <dmw> benny99: Ah, okay.  If you've done OCaml, then the usual difficulty points probably don't apply.  What's giving you trouble?
12:15:14 <benny99> dmw: well, I didn't look that closely at ocaml -- and I didn't actually do anything in Haskell, just some exercises
12:15:20 <oerjan> ah any other must have the same equations
12:15:35 <oerjan> so it's obvious
12:15:44 <benny99> dmw: I dunno how I should implement that :-[ -- data Token = Number | Operator --- data Number = 0..9 -- or something would not work I guess
12:15:45 <dmw> desegnis: either, maybe, and foldr are closely related. =)  But I guess you know that much already if you're studying category theory...
12:16:08 <dmw> benny99: Aha.  Well, you're close.
12:16:23 <desegnis> @djinn (a -> c) -> (b -> c) -> Either a b -> c
12:16:23 <lambdabot> f a b c =
12:16:23 <lambdabot>     case c of
12:16:23 <lambdabot>     Left d -> a d
12:16:23 <lambdabot>     Right e -> b e
12:16:37 <dmw> benny99: data Token = Number Double {- or whatever -} | Operator String -- you have to contain a type if you want to do anything interesting
12:16:38 <desegnis> @src either
12:16:39 <lambdabot> either f _ (Left x)     =  f x
12:16:39 <lambdabot> either _ g (Right y)    =  g y
12:16:54 <desegnis> lambdabot makes me happy :)
12:17:25 <desegnis> dmw: I'm not really studying CT, just digging into it
12:17:35 <desegnis> oerjan: thanks
12:17:35 <dmw> ok
12:17:51 <benny99> dmw: does "Char" also work ? (Operator is just one Char long)
12:18:03 <dmw> benny99: Sure, of course you need to pick the data types yourself.
12:18:13 <Botje> :t (|||)
12:18:14 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
12:18:18 <dmw> benny99: I was just giving an example of the syntax. =)
12:18:24 <benny99> dmw: data Operator a = IdunnoIwantA a -- ?
12:18:53 <oerjan> desegnis: oh wait a moment
12:19:10 <dmw> benny99: The namespaces for type constructors and data constructors are separate, so this is legal:
12:19:12 <oerjan> desegnis: there is a subtlety for some f,g
12:19:15 <dmw> data Operator a = Operator a
12:19:33 <oerjan> in particular f = g = const a
12:20:26 <oerjan> in that case you can define an alternative fg which doesn't look at its argument at _all_ and therefore has different strictness.
12:20:34 <benny99> dmw: but is nonesense I guess
12:20:39 <dmw> benny99: You could also do "type Operator = Char" for readability, or "newtype Operator = Operator Char" if you want operators and characters to be different to the type system.
12:20:44 <benny99> dmw: data Operator a -- was enough already
12:20:55 <oerjan> so if you include bottoms, Either is not _quite_ a coproduct
12:21:01 <dmw> benny99: No, the "= Operator a" is required.
12:21:13 <dmw> benny99: Otherwise you get a data type with no value constructors!
12:21:17 <ddarius> Either is and isn't a coproduct.  In general, the notion of coproduct captures the notion of "sum", but as oerjan just said, Either isn't the categorical coproduct.
12:21:23 <dmw> benny99: (Which can be useful, but I doubt it is what you want.)
12:21:28 <benny99> dmw: yeah, so I guess I'm not looking for a data type but a type :)
12:23:28 <benny99> well, hm, is there something like "data Operator a = a == + -> Plus; |  -> Minus; else Invalid" ?
12:23:43 <benny99> I really didn't learn anything I guess
12:23:47 <dmw> Wait, what?
12:24:10 <dmw> I think you may be confusing data type declarations with value instantiations.
12:24:21 <benny99> dmw: :-[ ?
12:24:29 <dmw> benny99: For example, you might have this:
12:24:32 <ddarius> benny99: data declarations are like definitions of structs or classes in C/C++.
12:24:46 <Zao> http://www.rubinsteyn.com/template_insanity.html
12:24:47 <lambdabot> Title: Template Insanity
12:24:58 <dmw> data Operator = Plus | Minus | Times | Divide -- declares a data type with four possible values
12:25:09 <benny99> doWhatYouShuold (Operator Plus) = ... -- if I want functions like those, does it make sense?
12:25:18 <dmw> Yes, but it would be
12:25:23 <dmw> doWhatYouShould Plus = ...
12:25:25 <benny99> dmw: I'm sorry :(
12:25:37 <dmw> benny99: Here, "Operator" is the type, but "Plus" is the constructor.
12:25:41 <desegnis> oerjan, I'm unsure if I follow you here. How is the choice of (f = g = const a) related to bottoms?
12:25:53 <dmw> (i.e. "Plus" is a value of type "Operator".)
12:26:04 <benny99> dmw: yeah, makes sense :)
12:26:26 <desegnis> ddarius: ‚Äúsum‚Äù as in data T = A | B ?
12:26:27 <oerjan> desegnis: for that choice you have two different colimits:
12:26:54 <oerjan> fg (Left _) = a; fg (Right _) = a as before, but also fg _ = a
12:26:56 <benny99> parse (Number Double) -- parse Token -- hm :(
12:27:07 <oerjan> they are different if you pass an undefined value
12:27:21 <dmw> benny99: Well... it would be:
12:27:28 <benny99> sorry, bad function name
12:27:32 <dmw> parse (Number n) = {- use n in here -}
12:27:52 <desegnis> oerjan, ah, you mean like computing a from f undefined == g undefined
12:27:55 <dmw> parse :: Token -> something, n :: Double
12:28:16 <benny99> dmw: thanks
12:28:19 <oerjan> no, i mean the actual undefined :: Either X Y
12:28:30 <oerjan> which does not come from either Left or Right
12:29:40 <desegnis> ah. (fg undefined) may be either undefined or a.
12:31:16 <oerjan> desegnis: the same issue for products and (,) i've seen discussed before, and it has the same problem.
12:31:50 <oerjan> i hear early versions of Miranda tried to define (,) "unlifted" to make it the real product
12:32:09 <desegnis> oerjan, I'm tempted to leave bottoms out of my considerations when comparing Haskell and Category theory
12:32:22 <oerjan> heh
12:32:54 <desegnis> I fear that anything may ‚Äúnot quite fit together‚Äù with partial functions messing things up
12:35:48 <benny99> hm, is there a readLn that returns only Strings?
12:35:56 <dmw> getLine
12:36:10 <benny99> thanks :)
12:36:28 <allbery_b> @src readLn
12:36:30 <mdmkolbe|work> Anyone care to explain to me why the MonadError (Either e) instance requires (Error e)?  I don't want Error.  Is there a pre-cooked alternative?
12:36:41 <lambdabot> readLn =  do l <- getLine; r <- readIO l; return r
12:36:59 <dmw> ?src Error
12:36:59 <lambdabot> class Error a where
12:37:00 <lambdabot>     noMsg  :: a
12:37:00 <lambdabot>     strMsg :: String -> a
12:37:10 <oerjan> mdmkolbe|work: because of fail
12:37:11 <allbery_b> @instances Error
12:37:12 <lambdabot> IOError, [Char]
12:37:27 <allbery_b> so your precooked alternative is String
12:37:36 <oerjan> @src Either fail
12:37:37 <dmw> It doesn't seem like a difficult instance to make, though.
12:37:38 <lambdabot> fail msg      = Left (strMsg msg)
12:37:38 * mdmkolbe|work curses fail for the um-teenth time
12:38:12 <mdmkolbe|work> oerjan: thx, that makes sense, though it ends up producing *really* bad error messages
12:38:17 <xerox> any lambdabot admin can have she join #haskell.it please
12:38:26 * dmw now prefers umteenth to umpteenth
12:38:40 <oerjan> umkay
12:40:38 <desegnis> oerjan, bugging you further: But even if the Either value is not necessarily a bottom, and f, g are not necessarily constant functions, the fg morphism may still be (a) Prelude.either, (b) const undefined?
12:40:51 <benny99> @src liftM
12:40:51 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
12:40:55 <wy> Ah. Finished the nondeterminism monad. It's so much nicer than the one I wrote before using call/cc with scheme
12:41:08 <benny99> sorry, where is liftM again?
12:41:25 <dmw> ?index liftM
12:41:29 <desegnis> benny99, Control.Monad
12:41:32 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
12:41:43 <dmw> (So you can look it up in the future. =)
12:41:49 <mdmkolbe|work> http://hpaste.org/4641 <-- example of the bad error messages as a result of needing (Error Integer)
12:43:41 <dmw> How many benny's are there??
12:45:17 <benny91> dmw: 2
12:45:35 <benny91> dmw: I'm benny99, disconnected for some reason :/
12:45:55 <dmw> Yeah, I figured.
12:46:18 <benny91> dmw: got some more time spare?
12:46:31 <dmw> Sure.
12:46:52 <benny91> dmw: interpret :: String -> Double -- interpret evaluates a string to a number (ie "2+2" into 4)
12:47:14 <benny91> dmw: parse :: ??Token?? -> omgIDunno -- I got no idea, I want a function that works like
12:47:40 <benny91> parse (Number n) = ... -- DoNumberStuff
12:47:53 <benny91> parse (Operator o) = ... -- operator stuff
12:48:18 <dmw> Yeah, you need some environment, hey?
12:48:24 <benny91> I guess I'm still confused with classes, types, newtypes, data and constructors :(
12:48:55 <dmw> So, is your question about the LHS or RHS of the =?
12:49:09 <dmw> (The LHS seems perfectly valid already, so I guess you want to know about the RHS?)
12:49:17 <benny91> nope, about "what type should that parse function have"
12:49:28 <dmw> Right.
12:49:43 <dmw> Well, to be clear: you need more information to deal with an Operator, right?
12:49:52 <benny91> parse :: String -> Token :-[ ?
12:49:55 <dmw> i.e. parse (Operator o lhs rhs) -- or something
12:50:22 <dmw> benny91: Probably parse :: String -> [Token]
12:50:24 <benny91> dmw: not yet, I want to keep it as simple as possible first
12:51:29 <benny91> parse :: Char -> Token was enough already I guess
12:51:31 <dmw> Then consume :: [Token] -> Double -- or something
12:51:34 <benny91> is Token a valid Type?
12:51:44 <dmw> benny91: You'll probably need to define it yourself.
12:51:55 <mdmkolbe|work> @source Control.Monad.Error
12:51:55 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/Error.hs
12:52:14 <dmw> benny91: And I doubt parse :: Char -> Token will work for parsing numbers. =)
12:52:15 <benny91> dmw: yeah, I did as "data Token = Number Double | Operator Char" -- thanks so far, got to leave for 5min, sorry :-[
12:52:18 <oerjan> desegnis: const undefined will not work.  the fg function must have the property fg (Left x) = f x; fg (Right y) = g y
12:52:42 <oerjan> that's the categorical diagram
12:53:15 <oerjan> and without bottom values in Either, that defines fg completely in every case
12:54:37 <ddarius> desegnis: (A little late) But Either a b is the sum type of a and b (a+b), data T = A | B would just be 1+1 (or Either () ())
12:59:25 <desegnis> There my teacher goes to sleep :(.  -- ddarius, oh, yes alright
13:01:03 <benny91> dmw: guess you are right ;)
13:01:33 <desegnis> My next question to oerjan would have been how bottom values in Either would fit into the categorical diagram at all, where only the injections point to A+B.
13:01:34 <benny91> dmw: data Machine = curNumber ... -- what do you think about that :) ?
13:02:14 <benny91> hm, maybe a class Calculator would make sense
13:03:20 <benny91> dmw: would it :-[ ?
13:03:25 * benny99 is back
13:05:38 <ddarius> One way of getting to the universal property for + is via adjunction and that can be stated as a natural isomorphism of hom-sets. (Either a b -> c) ~ (a -> c,b -> c)
13:06:23 <Botje> boom.
13:06:38 <dmw> benny99: It could.
13:07:00 <ddarius> So to show that Either a b is the categorical sum a+b, we need to show that there is an isomorphism, i.e. two functions f :: (Either a b -> c) -> (a -> c, b -> c) and g :: (a->c,b->c) -> Either a b -> c and that f . g = id  and g . f = id
13:07:04 <dmw> benny99: It's more likely that you want some kind of State monad, though.
13:07:12 <dmw> benny99: (Have you looked at monads yet?)
13:08:20 <ddarius> The functions are obvious, f e = (\a -> e (Left a), \b -> e (Right b)) and g (l,r) (Left a) = l a; g (l,r) (Right b) = r b
13:09:27 <benny99> dmw: yeah I did
13:09:30 <desegnis> ddarius, adjunctions and hom-sets are some chapters further on :)
13:09:43 <benny99> dmw: yeah, guess that was the right job then, with a "Calculator" as state?
13:10:00 <ddarius> desegnis: That's fine, the upshot is just that you need the two functions f and g and that they are the parts of an isomorphism.
13:10:09 <benny99> dmw: (let's say I want to simulate a calculator)
13:10:22 <ddarius> desegnis: Naturality comes for free (almost) and hom-sets can just be identified with function spaces.
13:10:33 <dmw> benny99: I'm not sure, it really depends on how you decide to do it.
13:10:59 <dmw> benny99: If you're doing a proper in-fix calculator, though, I would assume you'd want to have a proper parse-tree.  In that case, most of this is moot.
13:11:21 <benny99> interpret :: (Calculator c) => c -> String -> Double
13:11:23 <benny99> interpret calc [] = resultOfTheCalc calc
13:11:23 <benny99> interpret calc (cur : rest) = doSomethingWithit
13:11:24 <ddarius> desegnis: It's easy to show that for fully defined values f . g = id and g . f = id.
13:11:25 <benny99> like that :-[ ?
13:11:39 <desegnis> ddarius, wait
13:11:52 <dmw> benny99: That's an okay way to do it, but the State monad would allow you not to have to pass "calc" around all the time.
13:11:54 <desegnis> ddarius, so this is the categorical sum rather than the categorical coproduct?
13:12:07 <ddarius> desegnis: Those terms are synonymous.
13:12:13 <desegnis> ah ok
13:12:16 <benny99> dmw: like you'd do it on a calculator, where a string is the buttons you pressed
13:13:08 <dmw> interpret = foldl' singleStep 0 -- would be my eventual goal
13:14:25 <dmw> singleStep :: Double -> Token -> State Double Double, interpret :: [Token] -> State Double Double
13:14:37 <dons> ?users
13:14:38 <lambdabot> Maximum users seen in #haskell: 434, currently: 384 (88.5%), active: 10 (2.6%)
13:14:38 <dmw> wait, no
13:15:09 <ddarius> desegnis: One case of the proof is f . g $ (l,r) = f (g (l,r) = (\a -> g (l,r) (Left a), \b -> g (l,r) (Right b)) = (l,r)
13:15:16 <dmw> :t mapM
13:15:17 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
13:15:25 <dmw> :t foldM
13:15:26 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
13:15:46 <desegnis> ddarius, I'm not awake enough now to work through all this
13:16:16 <dmw> Yeah, foldM instead of foldl'. =P
13:17:04 <benny99> dmw: ok ;)
13:17:17 <ddarius> desegnis: Well at any rate, I made an unsound step in the last proof, namely eta-contraction.  You really get f . g $ (l,r) = (\a -> l a, \b -> r b) /= (l,r)
13:18:08 <benny99> dmw: ther's something missing anyway I guess
13:18:14 <desegnis> ddarius, so this very step is where your proof comes across the bottoms issue?
13:18:23 <dmw> benny99: Yes, the state might not end up being a Double.
13:18:31 <ddarius> desegnis: Yes.
13:18:41 <dmw> benny99: When I did a simple interpreter, I did RPN, so things were a lot simpler. =P
13:18:50 <ddarius> > \x -> undefined
13:18:50 <lambdabot>  Add a type signature
13:19:04 <ddarius> > (\x -> undefined x) `seq` 3
13:19:05 <lambdabot>  3
13:19:10 <ddarius> > undefined `seq` 3
13:19:11 <lambdabot>  Undefined
13:19:15 <desegnis> ddarius, many thanks. I'll read the log again during Christmas :)
13:22:33 <zeeeee> is there a way to have cabal *always* install profiling libraries, rather than needing to specify -p each time to configure?
13:24:18 <loupgaroublond> zeeeee: a bash macro?
13:26:07 * shachaf decides to look into this problem:
13:26:26 <shachaf> When I runghc Setup configure --user, with any package, it doesn't find any dependencies.
13:26:31 <shachaf> Not even base.
13:26:44 <shachaf> It works if I omit the --user.
13:26:56 <shachaf> Has anyone else had this problem?
13:30:00 <Dsit> http://trade-city.myminicity.com/
13:30:02 <lambdabot> Title: MyMiniCity
13:30:16 <duncan> shachaf: what ghc and cabal versions?
13:30:47 <shachaf> duncan: GHC 6.9.20071213, Cabal 1.3.1.
13:30:56 <shachaf> duncan: But I've had this with earlier versions.
13:31:03 <duncan> zeeeee: with cabal-install it should be possible to put it in the config file, if not file a feature request, it should be easy to implement
13:31:10 * shachaf should probably update again to see if something changed.
13:31:17 <benny99> dmw: sorry, that sounded rude :-[ ... I guess that's what I want :), but could I use a Calculator as State?
13:31:42 <duncan> shachaf: we changed the way ghc-pkg responds to --user --global
13:31:51 <duncan> shachaf: in ghc 6.9 that is
13:31:58 <dmw> benny99: Sure!
13:32:00 <benny99> dmw: and I guess I'm thinking too C++/java-ish if I think about creating a class "Calculator"
13:32:05 <dmw> benny99: What's Calculator?
13:32:13 <desegnis> zeeeee: If there's nothing else to be found, there's always ghc-options
13:32:19 <dmw> benny99: Aaah, are you confusing C++'s class with Haskell's class? =P
13:32:21 <duncan> shachaf: the first go at supporting the new ghc-pkg is in Cabal-1.3.2 I think, so see if that works
13:32:39 <dmw> benny99: In Haskell, "data" is the keyword that defines what is closest to C++'s "class".
13:32:42 <benny99> dmw: several registers, like "data Calculator = CurrentDec | CurrentNumber | Result"
13:32:47 <shachaf> duncan: OK, just pulling.
13:32:52 * shachaf should've tried this first.
13:32:58 <benny99> dmw: and a class is rather a context hm?
13:33:11 <duncan> shachaf: we changed ghc-pkg so that --user lists only user packages and --global list only global ones, rather than --user listing both
13:33:17 <allbery_b> haskell classes are for parametric polymorphism
13:33:19 <dmw> benny99: A class is a set of types.
13:33:38 <dmw> benny99: Along with some operations that those types support.
13:33:42 <benny99> and a type is a "data Type = ... " hm?
13:33:54 <benny99> ok
13:33:57 <shachaf> duncan: OK, thanks, I'll see if this works. :-)
13:34:09 <allbery_b> so for example class Show specifies that member types support an operation "show" which converts a value of that type to a String
13:34:48 <zeeeee> i'll look into cabal-install; up till now, i've been using toast, anybody else using that?
13:34:49 <allbery_b> (expresed as:  Show a => a -> String)
13:35:32 <duncan> zeeeee: toast? what is that?
13:35:49 <duncan> zeeeee: apart from the tasty snack :-)
13:36:37 <zeeeee> duncan, a little-known very handy tool, http://toastball.net/toast/
13:36:38 <lambdabot> Title: toast
13:37:54 <zeeeee> it's for installing software in general (while compartmentalizing for isolation/clean removals, crawling web pages for upgrade, remembering conf opts/logging builds, etc); it supports cabal packages
13:38:44 <shachaf> zeeeee: Why is http://toastball.net/man sent as text/plain?
13:39:00 <zeeeee> shachaf, i don't know..
13:40:52 <qebab> <interactive>:1:0: Not in scope: `ord'
13:41:03 <qebab> can I find ord somewhere?
13:41:14 <ddarius> allbery_b: Haskell typeclasses don't enable parametric polymorphism at all, in fact, they weaken the parametricity of a function that has them in it's type.
13:41:32 <qebab> do I need to import it maybe?
13:41:39 <shachaf> Why does cabal-install depend on HTTP >=3000.0&&<3001.1?
13:41:41 <ddarius> @index ord
13:41:41 <lambdabot> Data.Char
13:42:16 <duncan> zeeeee: looking at the code in there to support cabal, I don't think very much of it
13:42:34 <qebab> ah, thanks
13:43:07 <duncan> zeeeee: as far as I can see it does not do dependency resolution or downloading packages from online repos
13:48:00 <benny99> dmw: --type Calculator a b = ((CurNumber a), (Result b)) ???? noo... hm...
13:48:28 <dmw> type Calculator a b = (a, b) -- ?
13:48:29 <dmw> or:
13:48:44 <benny99> dmw: data Calculator = { CurNumber :: Double, Result :: Double } ?
13:49:04 <dmw> benny99: That would be fine, except for capitalization.
13:49:09 <dmw> curNumber, result
13:49:16 <benny99> ah, of course :)
13:49:18 <dmw> Oh, and you need a constructor.
13:49:30 <benny99> dmw: :(
13:49:32 <dmw> data Calculator = Calculator { curNumber :: Double, result :: Double }
13:49:37 <benny99> thanks :o)
13:49:45 <benny99> is there no shortcut for that?
13:49:50 <benny99> I feel like there was one :(
13:49:58 <dmw> Nope, and I'm glad of it. =)
13:50:13 <dmw> benny99: Though this is (mostly) equivalent:
13:50:18 <dmw> type Calculator a b = (a, b)
13:50:23 <benny99> dmw: guess you are right, I'm killed enough by haskell
13:50:25 <dmw> curNumber (x, _) = x
13:50:30 <dmw> result (_, x) = x
13:50:37 <benny99> dmw: yeah, but that's not that clean =D
13:50:49 <dmw> benny99: Right, and you can't pattern-match on it then.
13:50:50 * earthy hugs comonads for zippers
13:51:14 <sclv> yes but do you ghci them?
13:51:37 <ddarius> "improper priors were blamed for causing a paradox which they did not cause and which was not a paradox."
13:51:45 <benny99> I should revise the state monad
13:52:43 <benny99> wait , is that not already the monad?
13:52:55 <dmw> eh?
13:53:21 <benny99> :/
13:53:34 <benny99> cause it's like IO some kind of world
13:53:38 <benny99> it should be a Monad
13:53:45 <benny99> I guess ¬∞_¬∞
13:53:59 <dmw> State s is a monad, IO is a monad.
13:54:07 <benny99> Calculator is a monad ?
13:54:12 <benny99> should be a monad
13:54:15 <benny99> ?
13:54:17 <ddarius> Calculator doesn't have the right kind.
13:54:23 <ddarius> +even
13:54:28 <benny99> ddarius: :(
13:54:36 <dmw> If you had:
13:54:48 <dmw> data Calculator a = Calculator { curNumber :: Double, result :: a }
13:54:56 <benny99> I have
13:54:57 <dmw> Then, you might be able to start writing a Calculator monad.
13:55:11 <benny99> nope, I don't :-[
13:55:14 <ddarius> dmw: You could, but probably not the one you'd want.
13:55:18 <dmw> But to be a monad, you have to have the right "kind" -- which is a sort of "type system for types".
13:55:19 <benny99> no, I'm not able to
13:55:23 <benny99> instance, derive, something :/
13:55:25 <dmw> ddarius: right
13:55:45 <benny99> dmw: yep, know about kinds
13:55:55 <dmw> ddarius: I assume that would just be the State Double monad, which isn't worth the work of re-implementing. =)
13:56:08 <benny99> I want it perfect :(
13:56:14 <ddarius> dmw: It couldn't possibly be State.  It could be an instance of Writer.
13:56:26 <shachaf> Am I supposed to add ~/.cabal/bin to $PATH?
13:56:33 <benny99> of Writer O_o ?
13:56:51 <dmw> uh... why not?
13:56:59 <dmw> oh
13:57:00 <shachaf> dmw: State is s -> (a,s).
13:57:01 <dmw> right
13:57:01 <benny99> does that make sense?
13:57:23 <Saizan> shachaf: if you install executables as user
13:57:33 <ddarius> benny99: Yes, but it wouldn't do what you wanted it to.
13:57:43 <benny99> ddarius: :/
13:57:48 <dmw> benny99: You probably want the "State Calculator" monad.
13:57:56 <shachaf> Can I get cabal-install to install to ~/bin?
13:58:09 <ddarius> That said, you don't want Calculator to be a monad.  You probably want what dmw said, State Calculator.
13:58:18 <benny99> ddarius: and why :-[?
13:58:32 <ddarius> benny99: Why do you want it to be a monad?  You want a computation whose state is the data held by the calculator type.
13:58:41 <benny99> I'm sorry, but is it not "State Calculator SomeOtherType" then?
13:59:12 <ddarius> benny99: State Calculator is (part of) the monad, State Calculator X is not.
13:59:23 <ddarius> A monad has kind * -> *
13:59:28 <Saizan> shachaf: configure --help lists --bindir=
13:59:40 <benny99> @type State
13:59:41 <lambdabot> forall s a. (s -> (a, s)) -> State s a
13:59:58 <dmw> heh
14:00:05 <ddarius> @instances Monad
14:00:06 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
14:00:24 <dmw> ?src State
14:00:25 <lambdabot> Source not found. Maybe if you used more than just two fingers...
14:00:29 <dmw> ?src StateMonad
14:00:30 <lambdabot> Source not found. You type like i drive.
14:00:37 <dmw> :t get
14:00:39 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
14:00:39 <benny99> :D
14:00:43 <dmw> ?src MonadState
14:00:44 <lambdabot> Source not found. Just what do you think you're doing Dave?
14:00:47 <dmw> bah
14:01:00 <benny99> :D
14:01:18 <benny99> ?src State
14:01:18 <lambdabot> Source not found.
14:01:38 <benny99> ah, wait
14:01:53 <shachaf> @source Control.Monad.State.Lazy
14:01:53 <lambdabot> Control.Monad.State.Lazy not available
14:01:55 <shachaf> @source Control.Monad.State
14:01:55 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/State.hs
14:02:23 <benny99> interpret source = foldM singleStep {- Some Kind of Zero State -} source -- source is a string
14:02:50 <dmw> Looks good, provided you don't want any multiple-character tokens.
14:02:57 <benny99> nope, I don't
14:03:11 <benny99> but I really wonder
14:03:18 <benny99> "where is the monad now" ?
14:03:33 <benny99> singleStep (State Calculator Char) = ... -- huh?
14:03:44 <benny99> sorry for being that stupid, I'll leave for today soon :-[
14:03:55 <dmw> :t foldM
14:03:56 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
14:04:14 <Saizan> is there any documentation on what can be put in .cabal/config ?
14:04:23 <dmw> so, singleStep :: Calculator -> Char -> State Calculator () or so
14:04:35 <duncan> Saizan: only in the cabal-install sources, see Config.hs
14:04:43 <dmw> benny99: That is, singleStep doesn't take an argument of monadic type... it *returns* one!
14:04:48 <Saizan> duncan: thanks
14:04:51 <dmw> This is the magic of the State monad. =)
14:05:14 <Saizan> what's the point of taking Calculator as an argument though?
14:05:21 <dmw> sorry
14:05:40 <dmw> oh, uh...
14:05:45 <kuribas> Is there a prefered style for indenting if then else?
14:05:50 <duncan> Saizan: I'd like to make the config file writer use: "-- blah:" for settings that are not present, so you could see what fields are valid
14:05:57 <dmw> Saizan: Good point, maybe he doesn't need State after all. =P
14:06:09 <duncan> Saizan: patches for that accepted :-)
14:06:13 <benny99> dmw: uhh... wait, didn't I just ask about that :P ?
14:06:42 <benny99> (10:52:42 PM) benny99: wait , is that not already the monad?
14:06:53 <dmw> Ah, is that what you meant?
14:06:55 <dmw> Sorry, then.
14:06:56 <Saizan> duncan: heh :)
14:06:57 <benny99> yep :o
14:07:03 <benny99> dmw: I'm sorry as well :(
14:07:03 <dons> anyone seen this,
14:07:04 <dons>   http://programming.reddit.com/info/63r1y/comments/
14:07:06 <dmw> benny99: Your fault for taking advice from me. =P
14:07:13 * dmw notices that he's lost weight
14:07:13 <dons> join patterns for haskell
14:07:18 <benny99> I'm bad at .. saying what I mean :-[
14:07:22 <dmwit> Fair warning. =P
14:07:38 <benny99> dmwit ?
14:08:49 <benny99> singleStep :: Calculator -> Char -> Calculator -- something more like that
14:09:01 <dmwit> Right.
14:09:04 <dmwit> okay
14:09:20 <dmwit> Then you want a foldl', probably.
14:09:23 <dmwit> :t foldl'
14:09:25 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
14:09:46 <benny99> :t foldl
14:09:47 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
14:09:53 <dmwit> foldl' is strict
14:10:00 <benny99> ah :o)
14:10:34 <dmwit> Generally you want foldl' or foldr, but not foldl or foldr'. =)
14:10:50 <benny99> ok :)
14:11:24 <augustss> does Haskell need join patterns?
14:11:25 <benny99> *tries to remember what strict means... strict functions are those that "do not like _|_" hm?*
14:11:53 <earthy> welll..
14:11:59 <augustss> f is strict iff f _|_ = _|_
14:12:16 <earthy> they *very*much* like _|_. ;)
14:12:21 <dmwit> benny99: Practically speaking, a strict function evaluates something sooner than usual.
14:12:37 <benny99> ah, ok, I guess I remember now :)
14:12:52 <benny99> *remembers that Complex number example*
14:12:58 <augustss> dmwit: well, that's an approximation
14:13:08 <dmwit> Yes, definitely.
14:13:29 <augustss> a strict function need not evaluate its argument at all :)
14:13:44 <benny99> it's approximate enough for the moment :-[
14:13:49 <augustss> but normally they do
14:14:20 <benny99> augustss: (now you did it) when do they not?
14:14:37 <benny99> if the arguments aren't used?
14:14:42 <dmwit> const _|_ -- a strict function
14:14:47 <augustss> benny99: then a reasonable approximation is "a strict function always needs its argument to generate the result"
14:15:02 <earthy> const undefined   *whistle*
14:15:20 <stepcut> dons: heh, I think join rules might be exactly what I need for the program I am working on right now :(
14:15:20 <benny99> ok
14:16:19 <benny99> dmwit: back to my problem :-[
14:16:24 <benny99> if you want to
14:16:25 <dmwit> Yes?
14:17:55 <benny99> dmwit: gnah, I guess I'll try it on my own now first :-[
14:18:29 <benny99> dmwit: but I guess I'll try it tomorrow
14:18:30 <dmwit> Okay, good luck.
14:18:41 <dmwit> I've got to go, but hang around here... everyone wants to help. =)
14:18:44 <benny99> thanks :-[
14:18:47 <FunctorSalad> I'm clueless about haskell, but isn't that strictness condition just what you need to make the product into an actual categorical product? (just read that article why the product isn't quite a product due to probs with _|_)
14:19:04 <benny99> dmwit: or to kick me :-[
14:20:07 <benny99> thanks :); I'm gone for today :o)
14:23:06 <zeeeee> i installed filepath with --enable-library-profiling, but when i try to build my program which depends on filepath with -prof, ghc tells me it can't find the profiling version of filepath
14:23:19 <augustss> FunctorSalad: Haskell doesn't have categorical products
14:23:52 <qebab> how can I tell Haskell that I want to promote an Int to an Integer?
14:23:57 <FunctorSalad> augustss: so something still fails if you restrict to strict functions?
14:24:04 <augustss> qebab: fromIntegral
14:24:16 <qebab> augustss: thanks
14:24:49 <augustss> qebab: it's more general, in this case you could also use toInteger
14:25:52 <Taejo> @localtime Taejo
14:25:54 <lambdabot> Local time for Taejo is Mon Dec 24 00:25:55
14:26:21 <augustss> FunctorSalad: oh, I see what you mean.  yes, if all functions were strict you'd get categorical products.  But then it would no longer be a lazy language :)
14:27:16 <augustss> but lazy I meant non-strict, of course :)
14:28:31 <FunctorSalad> augustss: oh I see, so lazy constructions are considered to be _|_ ? (as I said, I'm obviously new to this ;))
14:31:49 <dons> alpheccar is awesome, http://programming.reddit.com/info/63r36/comments/
14:31:55 <dons> `HTTP content-type comparison at the type level'
14:32:19 <stepcut> dons: agreed.
14:32:22 <daniel_larsson> I liked those posts )
14:32:55 <dons> no one has commented on the strict Integer enumFrom proposal, i note
14:34:24 <fasta> Is there some trick to parse "1 2 3 4 5 6 7" as [1..7] with a read like function? Note, that I know a trivial recursive function that solved the problem otherwise.
14:35:03 <glen_quagmire> [Char] -> [Integer]
14:35:17 <glen_quagmire> ?hoogle [Char] -> [Integer]
14:35:18 <lambdabot> No matches, try a more general search
14:35:36 <fasta> Or I just use Parsec.
14:35:38 <Saizan> map read . words ?
14:36:08 <Saizan> > map read . words $ "1 2 3 4 5 6 7" :: [Int]
14:36:10 <lambdabot>  [1,2,3,4,5,6,7]
14:42:59 <fasta> run (sepBy (liftM read number) space) <- or with Parsec (more complicated)
14:43:39 <sclv> Just only saw this too: http://contracts.scheming.org/
14:43:40 <lambdabot> Title: Composing Contracts
14:44:34 <sclv> Not only cool work but wow, a .lhs in html that includes its own HAppS server built in!
14:45:46 <dons> huh
14:46:04 <dons> um, wow wow.
14:49:11 <sclv> with a googleCharts and graphViz simple api tossed in to boot.
14:49:18 <dons> stunning
14:50:21 <dons> gee, i was going to bundle up a google charts binding too
14:51:09 <dons> is this going to be a TMR article or something?
14:51:30 <dons>  http://programming.reddit.com/info/63r42/details `Composing contracts: literate Haskell with inline webserver, google charts and graphviz! '
14:52:24 <sclv> He apparently gave a talk on this in Nov. to the LISP-NY meetup group.
14:52:35 <dons> ah!
14:52:41 <sclv> oh, sorry, functional-programmers-NY
14:53:00 <dons> @tell swiert looks like a candidate for TMR http://contracts.scheming.org/
14:53:00 <lambdabot> Consider it noted.
15:06:01 <wy> Does Y combinator only work with lazy evaluation?
15:07:00 <ddarius> wy: One version, yes.
15:07:49 <qebab> let digits n = floor (logBase 10 n) + 1 -- is there a good reason why this seems to work for smallish numbers but fail for larger ones? As in, digits (10^100) => 101 which is correct, but digits (10^1000) gives an insanely large number?
15:07:52 <ddarius> By Anton van Straaten, interesting.
15:07:59 <daniel_larsson> What option is needed to support syntax like "data Proxy (a :: * -> *)" ? Compiling syb-with-class (6.8.1) complains about the "*"
15:08:08 <qebab> ah
15:08:14 <qebab> logBase uses floats, is that it?
15:08:18 <opqdonut> yes
15:08:27 <tehgeekmeister> http://hpaste.org/4642 <== apparently hpaste didn't announce it, it's an ugly solution to a project euler problem, i'd like to see how i could make it more elegant/point free
15:08:27 <opqdonut> as that is mathematically correct
15:08:30 <qebab> should've thought about that heh
15:08:31 <wy> ddarius: Is there something works for eager evaluators?
15:09:09 <qebab> does anyone have any other ideas how I could with reasonable efficiency measure the amount of digits in a number of the scale 10^1000 then?
15:09:58 <ddarius> wy: Yes.
15:10:21 <daniel_larsson> tehgeekmeister: pasted my solution
15:10:44 <davidL> sclv: uh, that page is beyond awesome
15:10:49 <wy> ddarius: What's that? Better be simple
15:10:56 <qebab> yeah logBase 10 (10^1000) => Infinity
15:10:58 <ddarius> wy: See Turing's fixed point combinator: http://en.wikipedia.org/wiki/Y_combinator
15:10:59 <lambdabot> Title: Fixed point combinator - Wikipedia, the free encyclopedia
15:11:11 <Valodim> I'd treat the number as a string, make a list of products, and use maximum on that list
15:11:22 <sclv> its' scary mindblowing. i'm going to be learning from that code for a while i think.
15:11:28 <ddarius> wy: You just eta expand a bit more giving fix the type ((a -> b) -> (a -> b)) -> (a -> b) instead of (a -> a) -> a
15:11:38 <sclv> everything is done very cleanly.
15:12:15 <davidL> yes that is how all programs should be made :)
15:12:19 <ddarius> wy: Actually, just look at the discussion of the Z combinator.
15:12:33 <sclv> He's one of the LtU dudes, as I understand it.
15:12:44 <ddarius> Yes.  User number 2.
15:12:56 <wy> ddarius: Thanks.
15:12:57 <ddarius> I believe he hosts LtU currently.
15:13:04 <fasta> He does
15:13:26 <wy> ddarius: Z seems to be simpler than turing's call-by-value version
15:14:02 <tehgeekmeister> daniel_larsson: so basically i just reinvented a lot of prelude/library functions that i didn't know existed and that's what made it ugly?
15:15:51 <ddarius> Wouldn't adding the join calculus to Haskell throw away purity?
15:17:49 <wy> Anyone attended the MPC conference?
15:18:24 <Saizan> daniel_larsson: KindPatterns
15:19:37 <daniel_larsson> tehgeekmeister: I guess that's a fair assessment :). product and maximum you reimplemented verbatim. tails + take 5 is your consec 5 pretty much
15:19:43 <daniel_larsson> Saizan: thanks :)
15:21:19 <tehgeekmeister> daniel_larsson: also, in a rare case (probably not the specific number they posted), wouldn't this be incorrect, as take 5 will return less than five elements for the last few tails, and if all the other sets of 5 consecutive digits had a low product, it's possible that the last four or three digits in the number could have a higher product?
15:21:55 <daniel_larsson> tehgeekmeister: Yes, a good point. It's a bug
15:22:05 <tehgeekmeister> (ah, definitely not this number, as the last digit is 0.)
15:22:15 <daniel_larsson> But yes, in general
15:22:31 <tehgeekmeister> okay, but a simple filter added in there can fix that.
15:22:36 <daniel_larsson> *nod*
15:22:50 <tehgeekmeister> thanks.
15:24:24 <Valodim> sweet, solved 8th euler problem :)
15:24:39 <Valodim> did it the same way that annotation did it, except using drop instead of tails
15:25:00 <wy> ddarius: Still not working
15:26:15 <ddarius> wy: I don't know what you are talking about.
15:30:31 <wy> ddarius: The Z combinator
15:31:37 <ricky_clarkson> @go z combinator
15:31:38 <lambdabot> http://en.wikipedia.org/wiki/Anonymous_recursion
15:32:15 <ricky_clarkson> \g -> g g
15:33:00 <ari> :t \g -> g g
15:33:01 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
15:33:01 <lambdabot>     Probable cause: `g' is applied to too many arguments
15:33:01 <lambdabot>     In the expression: g g
15:34:12 <qebab> anonymous recursion whoa
15:35:16 <wy> I guess it can't be typed
15:35:23 <ricky_clarkson> I like \f x -> f f x
15:35:38 <ricky_clarkson> Is that the same as \g -> g g ?
15:36:05 <ricky_clarkson> wy: It needs infinite types to be typable.
15:36:37 <ddarius> wy: The origins of the type system of Haskell were -specifically- to make such things ill-typed.
15:37:27 <wy> ddarius: I remember it can be typed with some folded types
15:37:42 <ddarius> What is a "folded type"?
15:37:43 <ricky_clarkson> ddarius: Why?
15:37:43 <Saizan> the good old "try to avoid the relevant for of the russel paradox"?
15:37:58 <Saizan> *form
15:38:20 <wy> ddarius: Maybe I recorded wrong. It can be converted into some folded form
15:38:31 <ddarius> Saizan: That's the earliest start (modulo Curry-Howard)
15:38:48 <qebab> (\ is an awesome syntax for writing lambdas ): it almost looks a bit like one
15:38:49 <ddarius> wy: What is a "folded form"?
15:39:05 <ddarius> qebab: That would be intentional.
15:39:18 <wy> ddarius: I forgot. have to review later
15:39:47 <wy> ddarius: Maybe I confused omega with this.
15:40:26 <FunctorSalad> qebab: languages should just support Œª ;)
15:40:37 <qebab> FunctorSalad: my keyboard should support it
15:40:53 <FunctorSalad> xmodmap or scim
15:41:52 <qebab> yeah but that's not as nice as a pretty lambda key on the keyboard
15:41:53 <wy> ddarius: I'm just trying to add if-then-else and recursion into the lambda interpreter I have been playing with
15:42:57 <ddarius> wy: If it's typed then you need to add it as a primitive, either by making a new form (a letrec) or by adding fix :: (a -> a) -> a.  If it's not typed, then the Z combinator should work (and the Y if it is non-strict)
15:43:19 <ddarius> (albeit it would still be inefficient to use them)
15:44:13 <wy> ddarius: I just want to try it, probably together with nondeterminism. There is no practical use of it.
15:47:47 <Japsu> @pl \n -> "po" ++ replicate (fib n) 'k' ++ s where { fib 0 = 1; fib 1 = 1; fib n = fib (n-1) + fib (n-2) }
15:47:48 <lambdabot> (line 1, column 48):
15:47:48 <lambdabot> unexpected "{"
15:47:48 <lambdabot> expecting variable, "(", operator, ":", "++" or end of input
15:47:55 <Japsu> bah
15:55:35 <wy> I pasted the lambda interpreter to: http://hpaste.org/4643. Hope to find why the recursion doesn't work
15:59:37 <sclv> what are the occasions where I would want to use utrecht parsers instead of parsec? simply when i'm worried about efficiency?
16:00:30 <stepcut> sclv: aren't the utrecht ones online (though, I think parsec supports that now too?)
16:00:55 <sclv> so if I wanted to parse a continuous stream, e.g.?
16:01:04 <stepcut> yeah
16:01:36 <stepcut> also, there are somethings that parsec is not very good at parsing (aka, things that require you to use try alot), the uu ones might work better for those
16:02:53 <stepcut> in some cases, different parsec combinators will be able to express the grammar you are trying to parse more 'naturally', meaning your parser code will be easier to write/understand...
16:04:05 <stepcut> perhaps you just trying writing the parser in parsec, and if it seems unduly hard or slow, you use something else
16:04:07 <sclv> parsec's working pretty well for me at the moment. no reason to switch yet. but, maybe just because i'm procrastinating, i'm feeling some wanderlust w/r/t the basic architecture.
16:04:11 <ddarius> wy: Define "doesn't work"
16:05:12 <stepcut> sclv: did you read the paper on the uu parser ? maybe there is some information in there on 'why?'
16:06:52 <sclv> read various things -- not sure which paper in particular?
16:06:56 <ddarius> How do you get the last name Box?
16:07:19 <sclv> I was looking at how EHC used it and got excited about thinking in terms of fancy higher order folds.
16:07:25 <stepcut> sclv: dunno
16:10:54 <wy> ddarius: define?
16:11:51 <wy> ddarius: Why doesn't define work?So I concatenate them together?
16:13:34 <wy> It tried. It doesn't work either
16:14:30 <ddarius> wy: My statement was equivalent to the question: "What do you mean by 'doesn't work'?"
16:14:54 <wy> ddarius: term5 doesn't give a number
16:15:14 <ddarius> What does it give?
16:17:13 <wy> It doesn't terminate. If you are interested, you can try the code :-)
16:17:56 <wy> ddarius: the recursion is not the interesting part. I want to see how does the nondeterminism work when there is also recursion
16:18:09 <ddarius> wy: Your code for Eq is wrong
16:18:54 <ddarius> This was much easier for me to figure out when you told me what the actual problem was.
16:19:00 <wy> ah!
16:19:07 <wy> you found it
16:24:40 <wy> ddarius: It works! Thanks!
16:24:51 <OceanSpray> [karl@da-yu windows]$ wine screw.exe
16:24:51 <OceanSpray> > (+ 1 2 3)
16:24:51 <OceanSpray> 6
16:24:51 <OceanSpray> > screw.exe: <stdin>: hGetLine: end of file
16:24:51 <lambdabot>  Parse error at "<stdi..." (column 12)
16:24:52 <lambdabot>   add an instance declaration for (Num (t -> t1 -> a))
16:24:56 <OceanSpray> yeah, that's weird.
16:25:23 <Saizan> dcoutts: around? is there a reason why some of ConfigFlags' fields don't have a FieldDescr? and so they are not settable in config?
16:28:02 * dmhouse was really confused for a minute while he tried to work out why lambdabot responded correctly to "> (+ 1 2 3)".
16:41:30 <Valodim> hmm
16:41:39 <Valodim> *** Exception: Prelude.read: no parse
16:41:43 <Valodim> what would be possible reasons for that?
16:42:08 <EvilTerran> trying to apply read() to something that won't parse as a value of the type required
16:42:12 <EvilTerran> > read "error"
16:42:13 <lambdabot>  Exception: Prelude.read: no parse
16:42:22 <mauke> > read "12"
16:42:22 <Valodim> that actually happens within "read . reverse . show"
16:42:23 <lambdabot>  12
16:42:37 <mauke> > read . reverse . show 'x'
16:42:38 <lambdabot>  Couldn't match expected type `a -> [a1]'
16:42:41 <mauke> > read . reverse . show $ 'x'
16:42:42 <lambdabot>  Exception: Prelude.read: no parse
16:42:53 <mauke> > read . reverse . show $ 'x' :: String
16:42:54 <lambdabot>  Exception: Prelude.read: no parse
16:42:56 <mauke> > read . reverse . show $ 'x' :: Char
16:42:57 <lambdabot>  'x'
16:43:12 <conal> i'm getting started with Linux, using ubuntu.  is there debian package for recent ghc, preferably 6.8.2?
16:43:12 <Valodim> of an Int
16:43:27 <mauke> > read . reverse . show $ 2.5 :: Int
16:43:28 <lambdabot>  Exception: Prelude.read: no parse
16:43:42 <Valodim> ...?
16:44:46 <allbery_b> ?
16:44:52 <EvilTerran> the ::Int applies to the whole expression
16:44:57 <EvilTerran> > show $ 2.5
16:44:58 <lambdabot>  "2.5"
16:45:01 <EvilTerran> > reverse . show $ 2.5
16:45:02 <lambdabot>  "5.2"
16:45:13 <EvilTerran> > (read :: String -> Int) . reverse . show $ 2.5
16:45:14 <lambdabot>  Exception: Prelude.read: no parse
16:45:56 <Valodim> the show gets an Int
16:46:09 <Valodim> so the string is from an int, reversible and should be readable
16:46:12 <Valodim> only digits in there
16:46:16 <mauke> > read . reverse . show $ 2 :: String
16:46:17 <lambdabot>  Exception: Prelude.read: no parse
16:46:37 <Valodim> > reverse "2"
16:46:38 <lambdabot>  "2"
16:46:50 <Valodim> > reverse . show "2"
16:46:50 <lambdabot>  Couldn't match expected type `a -> [a1]'
16:46:54 <Valodim> > reverse . show 2
16:46:54 <lambdabot>  Couldn't match expected type `a -> [a1]'
16:46:59 <Valodim> > reverse . show $ 2
16:47:00 <lambdabot>  "2"
16:47:02 <EvilTerran> Valodim, read what i said
16:47:06 <EvilTerran> <EvilTerran> the ::Int applies to the whole expression
16:47:16 <EvilTerran> so the show gets a float
16:47:52 <Valodim> I don't get it
16:48:48 <mauke> > read . reverse . show $ -4
16:48:49 <lambdabot>  Exception: Prelude.read: no parse
16:52:31 <dmwit> > read . reverse . show $ 2 :: Int
16:52:32 <lambdabot>  2
16:52:40 <dmwit> Maybe I should read a bit more backlog.
16:53:35 <dmwit> Valodim: Still having trouble?
16:54:11 <shachaf> conal: I don't think there's an easily available one.
16:54:26 <shachaf> conal: I generally use the .tar.gz binaries or compile my own.
16:56:05 <Valodim> dmwit: yep
16:56:16 <dmwit> Do you want to paste some code?
16:56:19 <dmwit> ?hpaste
16:56:20 <lambdabot> Haskell pastebin: http://hpaste.org/new
16:56:22 <Valodim> at it
16:56:56 <dmwit> Oh, I see that mauke suggested an answer: maybe show is getting a negative number.
16:57:03 <dmwit> Valodim: Does that seem possible?
16:57:33 <Valodim> nope
16:57:35 <Valodim> sec'
16:57:45 <Valodim> http://hpaste.org/4644
16:57:48 <Valodim> there you g
16:57:49 <Valodim> o
16:57:57 <dmwit> I wonder what happened to the hpaste bot.
16:57:59 <Valodim> the numbers are most definitely Int and positive
16:58:30 <Valodim> (and I know intrev could be written pointfree, did that for debugging some minutes ago)
16:59:03 <dmwit> Valodim: How about overflow? ;-)
16:59:10 <dmwit> > maxBound :: Int
16:59:11 <lambdabot>  2147483647
16:59:15 <Valodim> hah
16:59:40 <Valodim> :P
16:59:49 <dmwit> You may also be interested in iterate.
16:59:50 <dmwit> :t iterate
16:59:52 <lambdabot> forall a. (a -> a) -> a -> [a]
17:00:00 <dmwit> Could be useful for your "test" function.
17:00:12 <dmwit> (It won't solve the overflow, though, try using Integer instead.)
17:00:30 <dmhouse> > read . reverse . show $ -4
17:00:31 <lambdabot>  Exception: Prelude.read: no parse
17:00:49 <dmwit> > read "4-"
17:00:50 <lambdabot>  Exception: Prelude.read: no parse
17:01:12 <dmhouse> Oh, you already covered that ground.
17:01:39 <wy> anyone has read Bird and Wadler's book "Introduction to Functional Programming using Haskell"? It seems they have another book with similar title but without "using Haskell"?
17:01:42 <conal> shachaf: thanks.  i'll give that a go.
17:01:51 <Valodim> works with integer, thanks
17:04:44 <dmwit> ?seen glguy
17:04:44 <lambdabot> I saw glguy leaving #haskell 1d 16h 38m 48s ago, and .
17:04:52 <dmwit> ?seen hpaste
17:04:52 <lambdabot> I haven't seen hpaste.
17:05:53 <dmwit> ?tell glguy Not sure if you knew / are the right person to tell, but the hpaste bot doesn't seem to be here any more.
17:05:53 <lambdabot> Consider it noted.
17:08:43 <Valodim> what does the hpaste bot do?
17:09:16 <shachaf> Valodim: Announces pastes.
17:09:18 <dmwit> It announces pastes and annotations.
17:10:15 <dmwit> That way everyone can rush to see what dumb mistake the newbie made this time. =)
17:10:16 <Valodim> ah
17:10:23 <Valodim> hehe
17:11:18 <Valodim> yay, another percent euler rating :)
17:25:48 <mightybyte> [xfgk
17:26:58 <Valodim> @pl reversible x = all (odd . digitToInt) $ show (x + intrev x)
17:26:59 <lambdabot> reversible = all (odd . digitToInt) . show . ap (+) intrev
17:27:38 <exDM69> @src
17:27:39 <lambdabot> src <id>. Display the implementation of a standard function
17:27:41 <exDM69> @src id
17:27:42 <lambdabot> id x = x
17:28:54 <exDM69> how stupid of me... I was thinking is there a function that would be equal to all of it's parameters but of course it's not possible
17:29:13 <shachaf> exDM69: What do you mean?
17:29:37 <ricky_clarkson> id x is equal to all its parameters.
17:29:46 <shachaf> ricky_clarkson: But id isn't. :-)
17:29:59 <shachaf> @ty fix const
17:30:00 <lambdabot>     Occurs check: cannot construct the infinite type: a = b -> a
17:30:00 <lambdabot>     Probable cause: `const' is applied to too few arguments
17:30:00 <lambdabot>     In the first argument of `fix', namely `const'
17:30:11 <ricky_clarkson> Equality of functions is a.. strange concept.
17:30:25 <exDM69> I meant something like f a b = a and b
17:30:51 <ricky_clarkson> > let f=(&&) in f True True
17:30:52 <lambdabot>  True
17:31:01 <ricky_clarkson> What do you mean by 'and'?
17:31:09 <dmwit> > let f = (,) in f True True
17:31:10 <lambdabot>  (True,True)
17:31:11 <exDM69> ricky_clarkson: that was the impossible part
17:31:17 <shachaf> exDM69: You can't, in general, have variable-number-of-argument functions in Haskell.
17:31:24 <ricky_clarkson> Impossible to say?
17:31:28 <dmwit> > let f = (,,) in f 3 "hey" 76.5
17:31:29 <lambdabot>  (3,"hey",76.5)
17:32:20 <dmwit> Or maybe you want the non-determinism monad.
17:32:39 <dmwit> > let f x = [x+1, x*2] in [3,30] >>= f
17:32:41 <lambdabot>  [4,6,31,60]
17:33:11 <ricky_clarkson> > let f a b=undefined in f 5 6
17:33:11 <lambdabot>  Undefined
17:33:25 <ricky_clarkson> Given the information so far, that's the best I can do. ;)
17:34:22 <dmwit> > let f = undefined in f 5 6
17:34:23 <lambdabot>  Undefined
17:34:36 <exDM69> nah just forget it, it's not going to happen or even if it did it would be of no use
17:34:37 <dmwit> > let f = undefined in f 5 6 7 -- variable number of arguments!
17:34:39 <lambdabot>  Undefined
17:43:38 <wy> Is red-black tree useful in haskell?
17:44:32 <sarehu> Data.Map is not written with it, according to the last time I checked
17:46:01 <ddarius> wy: Why wouldn't it be?
17:46:31 <davidL> Do type synonyms add any additional bloat to a program besides lines of code? I don't know to what extent I should use them to improve readability.
17:46:42 <pastorn> sarehu: how is Data.Map implemented?
17:48:07 <wy> ddarius: Because I found in some blogs implementing the delete operation is not easy
17:48:26 <ddarius> wy: So?
17:48:28 <sarehu> pastorn: data Map k a = Tip | Bin !Size !k a !(Map k a) !(Map k a
17:48:35 <sarehu> wy: delete is never easy
17:48:44 <wy> ddarius: So I guess we could live without it ;-)
17:49:35 <ddarius> Also blogs are not the best sources of information.
17:49:37 <wy> Just reconstruct a path, I guess
17:49:44 <sarehu> pastorn: the Data.Map doc page has some links at the top for more information
17:49:48 <dons> Data.Map is a sized balanced tree
17:51:52 <wy> How does splay tree perform in a pure functional language?
17:52:24 <SamB> wy: annoyingly
17:52:41 <SamB> it's not very idiomatic
17:53:07 <wy> It sounds very good in a non pure setting
17:53:31 <smtlaissezfaire> How can I define a function in ghci, without loading the function from a file?
17:53:34 <SamB> mostly because you need to thread the tree through lookups
17:53:57 <dmwit> smtlaissezfaire: Use let.
17:54:31 <wy> SamB: I thought that it might make more rotations. Is that true?
17:54:50 <smtlaissezfaire> dmwit: How do I specify the type signature of the function, if I use let?
17:55:01 <dmwit> Same as usual, but use the {;} version of layout.
17:55:02 <Valodim> same way you usually do, nuh?
17:57:19 <wy> SamB: I haven't found it very different from a perfectly balanced tree in implementation
17:59:33 <SamB> wy: I have no idea how it performs, I just know what it would make me do to my code
18:00:01 <smtlaissezfaire> dmwit: So is there is an implicit let being used when I define a function in a file and load up that file?
18:01:02 <shachaf> smtlaissezfaire: Hello. :-)
18:01:13 <ddarius> smtlaissezfaire: Technically, no.  You could think of it that way, but it really doesn't help or hurt.
18:01:20 <smtlaissezfaire> shachaf: Hey - how's it going.
18:01:30 <smtlaissezfaire> Yep - so I decided to give Haskell a spin.
18:01:36 <ddarius> smtlaissezfaire: What's actually happening in GHCi's toplevel will become clear later.
18:02:38 <smtlaissezfaire> Yeah - I figure that's more or less what I don't understand right now.
18:04:18 <smtlaissezfaire> I guess I'm used to ruby's IRB, which acts like Ruby's top level.  I was more or less expecting the same sort of thing from Haskell.
18:05:37 <shachaf> smtlaissezfaire: Not quite, and you also can't define things like data-types.
18:06:07 <shachaf> smtlaissezfaire: GHCi is like do-notation in IO, if you've gotten to that.
18:06:37 <sclv> a library with a haskell splay tree implementation would be nice though, for those cases when it is needed -- i.e., caches, memotables, etc.
18:07:27 <smtlaissezfaire> I've only seen do { ... }.  Not sure if that's what your talking about.
18:08:23 <shachaf> smtlaissezfaire: Yes, it's just about the same thing.
18:12:05 <jimstutt> @seen Valodim:
18:12:05 <lambdabot> Valodim: is in #haskell. I last heard Valodim: speak 17m 2s ago.
18:12:16 <Valodim> ?
18:12:41 <jimstutt> Valodim: ur code has got me foxed.  Fails to parse on 89. Did u find out why?
18:12:53 <Valodim> yeah
18:12:57 <Valodim> it was simply out of range
18:12:59 <Valodim> Int
18:13:07 <Valodim> which probably show-ed "Infinity
18:13:24 <Valodim> > reverse "Infinity"
18:13:25 <lambdabot>  "ytinifnI"
18:13:29 <Valodim> and that can't be read :P
18:14:05 <byorgey> @seen twanvl
18:14:05 <lambdabot> twanvl is in #haskell. I don't know when twanvl last spoke.
18:14:13 <jimstutt> Valodim: still can't see why 89 fails when 100000 doesn't :)
18:14:23 <twanvl> byorgey: I am here
18:14:28 <byorgey> hi twanvl
18:14:42 <Valodim> I don't know
18:14:45 <Valodim> maybe it computes ahead
18:14:47 <byorgey> twanvl: have you considered putting the 'category' library on hackage?
18:15:21 <byorgey> twanvl: I have just started using it in a project I am working on (mostly for the FRef auto-deriving)
18:15:44 <byorgey> twanvl: it's pretty nice =)
18:15:58 <jimstutt> * scratches head - will have to experiment as always! :)
18:17:09 <twanvl> I could put it up there, but it will need some more work first
18:20:19 <byorgey> twanvl: what sort of work?
18:21:50 <twanvl> byorgey: well, mostly the Category* part, many instances are either missing, or are even wrong
18:22:03 <byorgey> oh, I see
18:22:46 <wy> I'm looking at the backwards state monad of Wadler's paper now. It's not very clear to me how the computation can proceed
18:24:05 <byorgey> twanvl: ok, I was just wondering.  I suppose I'll keep using it for now, and if I get ready to release a version of what I'm working on and the Category stuff isn't ready, I can just pull out the FRef parts that I need...
18:24:43 * ddarius dislikes that "Category" class
18:24:59 <byorgey> twanvl: also, if there's anything in particular I could help with, let me know
18:25:05 <byorgey> ddarius: OOC, why?
18:25:20 <wy> weird debugger. sometimes the break points don't stop it
18:25:21 <ddarius> byorgey: It's misnamed.
18:25:43 <byorgey> ddarius: oh, what should it be named then?
18:26:48 <gwern> has anyone here spent any time messing around with roguestar? I saw it mentioned in HCAR
18:29:14 <ddarius> byorgey: It doesn't really have a good name related to category theory.  The things that the 'cat' variable would be instantiated to would be closest to Hom functors.
18:29:57 <byorgey> ddarius: ok, I see.
18:30:14 <Cale> Didn't someone come up with the name "Compositor"?
18:30:22 <Cale> Something like that anyway
18:30:54 <byorgey> ddarius: well, what do you think of the content, disregarding the name?
18:31:18 <byorgey> or maybe "Composable"?
18:31:47 <ddarius> If it has uses it has uses.  I.e. if there are multiple things with only the common trait of being in "Category" then fine.
18:32:12 <wy> Do anyone of you want to share your .emacs? I want to borrow some useful settings
18:32:55 <ddarius> cat: .emacs: No such file or directory
18:33:09 <Cale> hmm
18:33:34 <Cale> I wonder if it could be generalised in the same way that (.) generalises to functor application.
18:36:37 <Cale> hmm, yes, I think it can
18:42:16 <Cale> http://hpaste.org/4646
18:46:24 <ddarius> Cale: It should also generalize in the same way (except Haskell doesn't let you write the convenient type) to contravariant functors.
18:52:51 <wy> I just realized that the debug won't work well if -O2 option is given. I though the interpreter won't optimize the code...
18:57:04 <sclv> speaking of... stuff, does anyone have any good use-cases of where using Data.Monoid is handier than writing the equiv. code without it?
19:00:53 <ddarius> sclv: Presumably you'd want to use it when you want to abstract from the particular monoid.  E.g. Control.Monad.Writer
19:03:00 <ddarius> sclv: It would be handier if there were more "monoid-generic" functions written.
19:04:18 <ddarius> Though Foldable and/or Traversable also the Monoid type class
19:08:59 <Cale> It would also be handier if, for instance, the operations were named zero and (++)
19:09:27 <conal> sure would -- sigh
19:09:43 <conal> "mempty"/"mappend" are so ugly
19:09:54 * conal writes lots of monoid code these days
19:09:55 <Cale> I wonder when we'll get to the point where we've all had enough and fix the Prelude :)
19:10:06 <shachaf> Cale: (++) used to be mplus, right?
19:10:12 <Cale> yeah, that's the other option.
19:10:31 * shachaf thinks Monoid makes a bit more sense.
19:10:49 <conal> does anyone have nice aliases for mempty and/or mappend?
19:11:04 <Cale> I wonder if I should bother posting that generalisation of Compositor to the mailing list.
19:12:15 <sclv> > let foo a b = a ++ (show b); bar a b = (reverse a ++ (show $ b-1)) in mconcat [foo, foo, foo, bar]  "foo" 3 -- ooh mconcat ftw
19:12:16 <lambdabot>  "foo3foo3foo3oof2"
19:13:29 <sclv> ?ty > let foo a b = a ++ (show b); bar a b = (reverse a ++ (show $ b-1)) in mconcat [foo, foo, foo, bar]
19:13:31 <lambdabot> parse error on input `>'
19:13:36 <sclv> ?ty let foo a b = a ++ (show b); bar a b = (reverse a ++ (show $ b-1)) in mconcat [foo, foo, foo, bar]
19:13:37 <lambdabot> forall a. (Monoid ([Char] -> a -> [Char]), Num a) => [Char] -> a -> [Char]
19:16:55 <sclv> :t mconcat
19:16:56 <lambdabot> forall a. (Monoid a) => [a] -> a
19:17:11 <ivanm> @src mconcat
19:17:12 <lambdabot> Source not found.
19:18:26 <shachaf> @ty foldr mappend mempty
19:18:26 <lambdabot> forall a. (Monoid a) => [a] -> a
19:18:32 <sclv> mconcat is a superset of my "catenate" which was "concat `dot` sequence" which in turn was originally " flip . swing (=<<) "
19:18:59 <sclv> I knew there was a reason I was obsessing over how monoids could help me.
19:22:37 <Saizan> swing?
19:25:10 <sclv> swing f c a = f ($ c) a
19:25:30 <sclv> the toying with / actually producing code ratio is way high for me right now.
19:29:54 <ddarius> Tomatoes were believed to be poisonous?
19:32:40 <loupgaroublond> ddarius: yeah, the acids would create poisons out of the pewter people used to eat from, so it was interpreted that they were poison themselves
19:40:00 <Cale> loupgaroublond: I thought that explanation was an urban myth, and the actual reason was that they resembled other plants known to be poisonous.
19:41:22 <loupgaroublond> Cale: maybe, it's hard to know these things for sure sometimes, i'm quoting something i read when i was 4 or 5 years old
19:42:25 <EvilTerran> it is in the nightshade family...
19:43:11 <loupgaroublond> i think the sillier medieval attitude to food was towards potatos anyways
19:51:50 <zeeeee> i installed filepath with --enable-library-profiling, but when i try to build my program which depends on filepath with -prof, ghc tells me it can't find the profiling version of filepath
20:02:38 <zeeeee> argh, sorry--my cabal file said FilePath of yore instead of filepath
20:10:02 <sphynx> hi all
20:10:25 <sphynx> I've encountered such pattern in List monad:
20:10:33 <sphynx> do { x1 <- f x0; x2 <- f x1; x3 <- f x2; return x3; }
20:10:54 <sphynx> Is there some way to generalize this?
20:11:11 <sphynx> Assume I have something more general, like:
20:11:24 <sphynx> do { x1 <- f x0; x2 <- f x1; ... ; xn <- xn-1; return xn }
20:12:19 * jql points vaguely in the direction of foldM
20:12:24 <sphynx> I'd like to have some HO function which I can use as follows :  do { return $ magicFunction n x0 }
20:13:27 <newsham> f x0 >>= f >>= f   ?
20:13:30 <Valodim> for three or so entries you can just bind without do
20:13:38 <Valodim> yeah, that
20:14:06 <sphynx> three - ok, I can just bind manually, but what about n?
20:14:13 <newsham> foldl (>>=) (f x0) [f,f]   ?
20:14:22 <EvilTerran> ?hoogle iterateM
20:14:23 <lambdabot> No matches found
20:14:35 <EvilTerran> wait, of course that wouldn't work
20:14:37 <newsham> foldl (>>=) (f x0) (replicate 2 f)
20:15:27 <sphynx> newsham: hm, interesting, I'll try now
20:15:35 <EvilTerran> ?type \n f x -> foldM (flip ($)) x (replicate n f)
20:15:36 <lambdabot> forall a (m :: * -> *). (Monad m) => Int -> (a -> m a) -> a -> m a
20:16:03 <EvilTerran> ?type \n f x -> foldl (>>=) x (replicate n f)
20:16:04 <lambdabot> forall (m :: * -> *) b. (Monad m) => Int -> (b -> m b) -> m b -> m b
20:17:13 <EvilTerran> ?type \n f x -> foldr (=<<) x (replicate n f)
20:17:14 <lambdabot> forall (m :: * -> *) b. (Monad m) => Int -> (b -> m b) -> m b -> m b
20:17:33 <EvilTerran> ... good. (just checking my brain's still working okay at this hour ;] )
20:18:22 <sphynx> it seems that foldM variant works for me :)
20:18:23 <wy> phew!
20:19:11 <wy> Finally worked out a diagram of the backwards state monad, like designing a circuit...
20:19:33 <sphynx> EvilTerran, newsham : Thanks for help!
20:19:47 <EvilTerran> ... backwards state?
20:19:56 <EvilTerran> sphynx, do you see why that does what it does?
20:20:10 <sphynx> I'm not sure
20:20:18 <EvilTerran> do you know what foldM is
20:20:18 <wy> EvilTerran: I'm working on Wadler's old monad paper these days.
20:20:19 <EvilTerran> ?
20:20:21 <sphynx> If you can explain in detail, I'd be glad :)
20:20:33 <EvilTerran> ?src foldM
20:20:34 <lambdabot> foldM _ a []     = return a
20:20:34 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
20:20:43 <sphynx> foldM - monadic version of foldl, I think
20:20:47 <EvilTerran> yes, indeed
20:21:09 <dmwit> :t replicateM
20:21:10 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
20:21:29 <EvilTerran> foldl is foldM in the Identity monad, modulo newtypes
20:21:34 <dmwit> Hmm, not quite.
20:21:43 <wy> Found a conference named "Functional programming languages and computer architecture". anyone heard of that?
20:22:05 <EvilTerran> so, (replicate n f) makes a list of n copies of f
20:22:59 <sphynx> EvilTerran: So foldM does smth like I need: (f x0 smth >>= \x1 -> f x1 smth >>= \x2 -> .... return xn)
20:23:59 <EvilTerran> yeah, pretty much
20:24:28 <sphynx> But instead of folding this 'smth', we need to fold list of functions - replicate f
20:24:28 <wy> http://tinyurl.com/2hfl6x
20:24:39 <EvilTerran> ?type foldM
20:24:39 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
20:25:43 <newsham> ?src forM
20:25:43 <lambdabot> forM = flip mapM
20:26:05 <EvilTerran> foldM f r0 [x0,x1,...xN] = do r1 <- f r0 x0; r2 <- f r1 x1; r3 <- f r2 x2; ...; f rN xN
20:26:28 <ddarius> :t let f @@ g = \x -> f x >>= g in foldr (@@) return
20:26:28 <lambdabot> forall (m :: * -> *) a. (Monad m) => [a -> m a] -> a -> m a
20:26:30 <noecksit> hello, im not sure im understanding data types, im trying to find the time using "Data.Time.Clock" and am using getCurrentTime
20:27:22 <noecksit> supposedly it returns IO UTCTime, and i take the UTCTime of it using "time <- getCurrentTime", but then im not sure how I can use UTCTime
20:27:38 <EvilTerran> if you prefer, foldM f e [x0,x1,...xN] = e `f` x0 >>= (`f` x1) >>= (`f` x2) >>= ... >>= (`f` xN)
20:28:19 <sphynx> EvilTerran: yeah, I've got it - we haven't lists of x, just r0. So we place in that list functions f and appl it consecutively using flip ($)
20:28:43 <EvilTerran> yeah, in this case f is just flipped application, and all our x#s are f
20:28:44 <noecksit> it says that it has the constructors utctDay and utctDayTime
20:29:05 <noecksit> could i use "Show time"?
20:29:05 <sphynx> ok, thanks. It was a cool way :)
20:29:19 <EvilTerran> =]
20:29:28 <sphynx> EvilTerran: and that way with foldr and >>= is the same? :)
20:29:39 <sphynx> err: foldr and <<=
20:29:57 <EvilTerran> yeah, except it needs an added return if you want the initial parameter to be of type (a) rather than (m a)
20:30:15 <EvilTerran> ?type \n f x -> foldr (=<<) (return x) (replicate n f)
20:30:16 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> (a -> m a) -> a -> m a
20:30:40 * ddarius suspects Veech's thesis can be simultaneously improved and significantly simplified.
20:31:00 <EvilTerran> sphynx, in GHC 6.8, you may be able to do something snazzy and pointfree with <=<, too
20:31:26 <sphynx> Hm, I don't know about this <=< (looks like a fish :))
20:31:29 <EvilTerran> (n f -> foldr (>=>) return (replicate n f)) or something
20:31:33 <wy> Interesting. This 1995 conference has a paper of most of the FP greats today. http://tinyurl.com/34hkhx
20:31:36 <lambdabot> Title: FPCA: FPCA '95
20:32:00 <EvilTerran> (f <=< g) x = f =<< g x
20:32:16 <EvilTerran> (>=>) = flip (<=<)
20:32:38 <EvilTerran> ($) is normal application and (.) is normal composition;l
20:32:52 <EvilTerran> likewise (=<<) is monadic application and (<=<) is monadic composition
20:34:03 <sphynx> EvilTerran: interesting
20:34:26 <EvilTerran> iirc, the associativity laws of monads look quite snazzy with <=<
20:34:53 <EvilTerran> ((f <=< g) <=< h) x = (f <=< (g <=< h)) x -- or what-have-you
20:34:53 <sphynx> forM - is from 6.8 too?
20:34:59 <EvilTerran> don't think so, no
20:35:06 <EvilTerran> it's in Control.Monad
20:36:14 <sphynx> yeah, that way with <=< works too
20:36:18 <sphynx> foldr (<=<) return (replicate 3 (getNextConfigs Human)) $ "----"
20:36:46 <ddarius> Yes.  (<=<) is Kleisi composition (i.e. composition in the Kleisli category) and its associativity is equivalent to the associativity law of monads.
20:37:06 <EvilTerran> yay for un-tested code actually working pretty often in haskell. it's never happen in perl. :D
20:37:16 <EvilTerran> *it'd
20:38:17 <EvilTerran> and now, sleep!
20:39:14 <sphynx> EvilTerran: good night!
20:39:41 <EvilTerran> :)
20:42:29 <dainanaki> i hate how i don't know any of that math stuff about monad associativity laws and whatnot
20:44:03 <Cale> dainanaki: When translated into do-notation it becomes pretty obvious stuff.
20:44:27 <Cale> http://haskell.org/haskellwiki/Monads_as_computation#The_monad_laws
20:44:28 <lambdabot> http://tinyurl.com/39bl37
20:44:37 <ddarius> dainanaki: There is no math beyond the statements themselves.
20:47:57 <noecksit> data types reminds me a lot of structs in C, and multiple constructors in data types reminds me of class overloading in java, could i think of them in that way?
20:48:28 <Cale> The associativity law seems kind of obvious when written in do-notation: it essentially says that you can grab a bunch of lines from the middle of a do-block and put them into a separate do-block which the first do-block then calls, without changing the meaning of the code.
20:49:06 <Cale> It seems simple enough, but, for example, C manages to break this property (due to the fact that there could be a 'return' in the middle of a block, for one)
20:49:41 <mrd> noecksit: you'd be better off thinking of type-safe unions
20:50:00 <Cale> noecksit: They're some combination of structs and (tagged) unions.
20:50:46 <ddarius> There is a nice embedding of algebraic data types into classes and dynamic dispatch.
20:50:57 <Cale> Class overloading seems like it's unrelated to me, but it's been a while since I did a lot of OO programming.
20:52:03 <Cale> I suppose that you do branch on the constructor, rather like different subclasses cause different bits of code to run.
20:52:22 <Cale> But that would be where the similarity ends.
20:52:48 <Cale> The set of constructors is fixed at the point where the datatype is declared.
20:53:27 <Cale> But you can arbitrarily extend the code which branches on the constructors of that datatype.
20:54:02 <Cale> Whereas, in OO, you have a base class, and that's where the basic set of operations gets fixed, though you can have as many subclasses as you'd like.
20:55:32 <ddarius> The traditional duality between OO and FP.
20:56:30 <puusorsa> FIGHT!
20:57:36 <mrd> foop
21:07:33 <puusorsa> ;
21:07:46 <icarroll> {}
21:08:13 <dons> <interactive>:1:0: parse error on input `{'
21:08:18 <icarroll> :)
21:08:47 <davidL> > {}
21:08:47 <lambdabot>  Parse error at "{}" (column 1)
21:09:24 <icarroll> btw, I found a "teh" in the ghc library docs. How do I submit a bug report?
21:09:47 <shapr> icarroll: Patch the darcs repo?
21:10:20 <icarroll> um...
21:10:24 <shapr> Yay for Northern Climates!
21:10:28 <sclv> any good error combinators for parsec floating around?
21:10:36 <icarroll> that's a big heavyweight for just a minor misspelling error
21:10:39 <icarroll> bit rather
21:10:59 <sclv> I have something that's failing in odd cases and I'd like to insert a trace that shows what it's failing on every time its called
21:11:13 <shapr> icarroll: Well, someone else will have to patch it then... and this way you get your name in the contributors, yeah?
21:12:08 <icarroll> :)
21:12:50 <icarroll> shapr: wouldn't someone have to approve the commit anyway?
21:13:05 <shapr> If you send a patch to the ghc list, someone could just apply that patch.
21:13:07 <sclv> debugging grammars is awful
21:13:16 <icarroll> good point
21:14:14 <icarroll> it's still a rather mor involved process than I was hoping for
21:14:16 <icarroll> more
21:14:29 <zeeeee> does anybody happen to have a subRegex for ByteString?
21:16:39 <shapr> icarroll: On the good side, once you've grabbed the repo and become familiar with darcs send, further changes are not involved.
22:00:00 <scodil> is there a way to make State monads strict in the state without redefining >>= to include a seq? I've tried adding strictness everywhere else, but unless i do something like (((>>=) $! a) $! b) i get stack overflows
22:00:14 <scodil> and that unfortunately rules out do-notation
22:00:34 <sclv> sigh. either the try combinator in parsec is less powerful than i thought, or its buggy.
22:00:45 <sclv> either way i'll have to switch to using the lexer at some point.
22:01:15 <sclv> anyone else find this to be the case?
22:01:26 <gwern> is there a ghc option to turn off generation of .hi and .o files?
22:02:03 <dons> gwern: and do what instead?
22:02:05 <dons> just type check?
22:02:19 <dons> -fno-code will just run the type checker (or you can use runhaskell/ghci)
22:02:24 <gwern> dons: only produce a binary
22:02:36 <gwern> ie, specify -o foo, and at the end only have foo
22:02:46 <gwern> and not foo.o, foo.hi
22:02:54 <dons> oh, clean up the .hi and .o's. not that i'm aware of.
22:02:54 <gwern> (let's say you're compiling foo.hs)
22:04:01 <moconnor> does runhaskell compile your script in the background and keep secret object files to speed up subsequent runs?
22:05:21 <dons> nope. i is basically: echo main | ghci -v0
22:05:35 <sclv> gwern -- you can use -odir and -hidir to redirect the output dirs to /dev/null ?
22:05:57 <ddarius> sclv: The try combinator allows arbitrary backtracking and due to the power of Haskell it can parse context-sensitive grammars.
22:06:16 <sclv> ddarius: I'm getting unexpected behavior with it.
22:06:38 <sclv> i.e. I have (try foo <|> bar)
22:06:39 <ddarius> What's the code, what behavior are you expecting, what behavior are you getting?
22:06:52 <sclv> and when foo fails it throws an error instead of going on to try bar.
22:06:53 <gwern> sclv: /dev/null is a file, not a directory no?
22:08:19 <sclv> gwern: ghc docs suggest trying -ohi /dev/null
22:08:34 <sclv> but don't think you can kill the -o files that way now that I think it through.
22:08:42 <sclv> after all, the linker has to use them.
22:09:01 <gwern> sure, but there's no need for them to hang around after the linking
22:09:36 <gwern> 'ghc-6.8.2: -ohi can only be used when compiling a single source file
22:11:39 <ddarius> sclv: Except that it doesn't necessarily go left from right, that should be fine, but I find it far more likely that the bug is nevertheless in your code.
22:12:24 <sclv> ddarius: is there ever any reason where, e.g. (try foo <|> bar) would fail where (try bar <|> foo) succeeds?
22:13:20 <ddarius> sclv: That particular permutation, yes, but I didn't mention that issue because I thought it was relevant to your problem.
22:13:33 <sclv> also, I'm pretty sure that <|> goes from left to right.
22:13:52 <sclv> docs say "the (<|>) combinator is predictive; it will only try its second alternative if the first parser hasn't consumed any input. "
22:14:09 <ddarius> Ah, I thought it wasn't specified.
22:14:15 <sclv> ddarius: where would one work when the other doesn't?
22:15:09 <ddarius> sclv: Since it does go left to right, none.
22:15:24 <ddarius> (except perhaps in a larger context)
22:15:32 <sclv> hmm.. i'm finding lots of places where it does matter.
22:15:47 <sclv> not sure if try is really saving all the state it should.
22:15:48 <ddarius> sclv: It has performance implications I'm sure.
22:16:00 <sclv> right: but i'm talking success or failure.
22:16:23 <ddarius> It can change the overall success or failure if the parse is actually ambiguous.
22:17:28 <Cale> The order in which the options are tried is generally pretty important, since in the end you only get one result from runParser.
22:18:07 <sclv> http://hpaste.org/4647
22:18:32 <sclv> it's part of a bigger thing, so all the code isn't there. but enough to see what's going on.
22:18:51 <Cale> For instance, if you have something like  do { ... } <|> return 0, regardless of failure, that's very different from return 0 <|> do { ... }
22:19:06 <conal> i'm having trouble installing zlib (on ubuntu), as needed by cabal-install.  i get "Stream.hsc:73:18: error: zlib.h: No such file or directory".  any suggestions?
22:19:26 <sclv> the line that fails is:   vals <- around '(' (try (many assgn) <|> anonassgn) ')'
22:19:35 <shachaf> conal: sudo apt-get install zlib1-dev
22:19:43 <conal> shachaf: thx!
22:19:54 <sclv> in the case where it should fall over to anonassgn on "foo('bar')" a trace shows me that the second option is never called.
22:22:15 <conal> uh oh: "Package zlib1-dev is not available, but is referred to by another package. ...
22:22:33 <shachaf> conal: Oops, sorry.
22:23:03 <shachaf> conal: Try zlib1g-dev?
22:23:17 <Cale> sclv: Right, because it successfully matches zero of them.
22:23:29 <Cale> sclv: Perhaps use many1
22:23:40 <sclv> goddamn. good catch!
22:23:41 <sclv> Cale++
22:23:56 * ddarius was too slow.
22:24:11 <conal> shachaf: that one was found.  how did you come up with zlib1g-dev?
22:24:29 <shachaf> conal: sudo apt-get install zlib<tab><tab>, and guess. :-)
22:24:38 <shachaf> conal: Then apt-cache show to verify.
22:24:49 <shachaf> conal: In general, .h files are in -dev packages.
22:24:53 <Cale> More general solution: apt-file search zlib.h
22:24:59 <llimllib> hey all, I have a question about Data.Map.lookup
22:25:19 <conal> shachaf: thanks for the tips!
22:25:25 <llimllib> *Chap1> let f = fromList [(1,1), (2,5), (3,10), (4,25), (5,50)]
22:25:26 <llimllib> *Chap1> Data.Map.lookup 1 f
22:25:28 <llimllib> *Chap1> Data.Map.lookup 1 f :: Maybe Integer
22:25:29 <llimllib> Just 1
22:25:30 <shachaf> Cale: Well, this is usually faster. :-)
22:25:37 <Cale> It appears to be in zlib1g-dev
22:25:42 <shachaf> Cale: Since I already have the apt-get install typed in.
22:26:18 <llimllib> Why didn't I get 1 returned without the :: Maybe Integer, but got Just 1 with it?
22:27:13 <Cale> llimllib: hmm, perhaps it uses the IO monad. Data.Map.lookup has a stupid type.
22:27:55 <Cale> (that is, it has a type which is technically more general than it should really be possible to provide)
22:28:22 <llimllib> *Chap1> :t Data.Map.lookup
22:28:24 <llimllib> Data.Map.lookup :: (Ord k, Monad m) => k -> Data.Map.Map k a -> m a
22:28:43 <Cale> Yes, it's not really reasonable to use *any* monad.
22:29:05 <Cale> Maybe/List/Either should be okay.
22:29:21 <Cale> In general, a monad which supports failure in some fashion will be all right.
22:29:24 <llimllib> so the return value of lookup may be in any monad?
22:29:29 <Cale> yeah
22:29:42 <Cale> 99% of the time, you just want Maybe though.
22:30:14 <Cale> If there were any justice in the world, that would say (Ord k, MonadZero m) => k -> Map k a -> m a
22:30:27 <llimllib> so your recommendation is to just use Maybe Integer
22:30:31 <Cale> yes
22:30:44 <llimllib> so, in the interest of education
22:30:52 <llimllib> *Chap1> :t Data.Map.lookup 1 f
22:30:52 <llimllib> Data.Map.lookup 1 f :: (Monad m) => m Integer
22:31:02 <llimllib> doesn't really tell me anything, right?
22:31:10 <Cale> Sure it does.
22:31:18 <shachaf> llimllib: It tells you that that has type "m Integer", for any Monad m.
22:31:26 <shachaf> @instances Monad
22:31:27 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
22:31:35 <Cale> Try giving it the type signature [Integer]
22:31:45 <shachaf> (That should actually be MonadZero, as Cale says.)
22:32:06 <Cale> Most of those monads won't really work, and will simply crash the program if the element isn't found though.
22:32:13 <llimllib> @shachaf: what should be MonadZero?
22:32:13 <lambdabot> Unknown command, try @list
22:32:19 <Cale> (this is why we should have a MonadZero class)
22:32:37 <llimllib> oh lookup right
22:32:57 <llimllib> and what is the hypothetical MonadZero?
22:33:08 <Cale> class Monad m => MonadZero m where
22:33:26 <Cale>    mzero :: m a
22:34:09 <ddarius> class Monad m => MonadPlus m or class MonadZero m => MonadPlus m ?
22:34:16 <Cale> Presently, mzero is in with mplus in the MonadPlus class.
22:34:40 <Cale> The latter, probably.
22:35:10 <ddarius> I tend to agree, though I can easily create examples that have a mplus but not an mzero.
22:35:40 <shachaf> Cale: Should both MonadOrElse and MonadPlus be MonadZero?
22:36:00 <Cale> shachaf: they should both be subclasses
22:36:26 <shachaf> Cale: That's what I meant, sorry.
22:36:48 <ddarius> MonadOrElse should definitely be a subclass of MonadZero.
22:37:35 <llimllib> So, if the return *were* mzero, how would one use lookup?
22:37:42 <llimllib> (I say, furiously googling mzero)
22:37:45 <Cale> The same way.
22:37:57 <ddarius> :t Data.Map.lookup
22:37:58 <lambdabot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> Data.Map.Map k a -> m a
22:38:03 <Cale> It just wouldn't compile in places where it shouldn't.
22:38:29 <ddarius> > Map.lookup 3 (Map.empty) :: Maybe Int
22:38:30 <lambdabot>   Not in scope: `Map.empty'
22:39:14 <ddarius> > empty
22:39:15 <lambdabot> Terminated
22:39:22 <ddarius> Wunderbar
22:39:31 <ddarius> > Map.lookup
22:39:31 <lambdabot>   Not in scope: `Map.lookup'
22:39:33 <sclv> :t empty
22:39:34 <lambdabot>     Ambiguous occurrence `empty'
22:39:34 <lambdabot>     It could refer to either `empty', imported from Control.Applicative
22:39:34 <lambdabot>                           or `empty', imported from Text.PrettyPrint.HughesPJ
22:39:41 <ddarius> > Data.Map.lookup 3 (Data.Map.empty) :: Maybe Int
22:39:42 <lambdabot>   Not in scope: `Data.Map.empty'
22:39:49 * ddarius gives up.
22:41:06 <sclv> > M.lookup 3 (M.empty) :: Maybe Int
22:41:08 <lambdabot>  Nothing
22:41:56 <sclv> > M.lookup 3 (M.empty) :: (->) Int
22:41:57 <lambdabot>      `(->) Int' is not applied to enough type arguments
22:41:58 <lambdabot>     Expected kind `?'...
22:42:09 <sclv> > M.lookup 3 (M.empty) :: (-> Int)
22:42:10 <lambdabot>  Parse error at "Int)" (column 29)
22:42:21 <shachaf> sclv: (->) something Int.
22:42:35 <shachaf> sclv: Since the monad is (r ->) already.
22:42:59 <ddarius> Or more traditionally, something -> Int
22:43:02 <shachaf> > fail "!" :: Int -> Char
22:43:03 <lambdabot>  <Int -> Char>
22:43:08 <shachaf> > (fail "!" :: Int -> Char) 1
22:43:09 <lambdabot>  Exception: !
22:44:01 <sclv> > (M.lookup 3 M.empty :: (->) Int String) 34
22:44:03 <lambdabot>  Exception: Data.Map.lookup: Key not found
22:44:48 <ddarius> > do True <- False; return () :: Either String ()
22:44:48 <lambdabot>  Couldn't match expected type `t t1' against inferred type `Bool'
22:44:57 <ddarius> > do True <- return False; return () :: Either String ()
22:44:58 <lambdabot>  Left "Pattern match failure in do expression at <irc>:1:3-6"
22:45:15 <sclv> > M.lookup 3 (M.empty) :: Either String Int
22:45:17 <lambdabot>  Left "Data.Map.lookup: Key not found"
22:45:51 <sclv> > M.lookup 3 (M.empty) :: Writer [Char]
22:45:52 <lambdabot>      `Writer [Char]' is not applied to enough type arguments
22:45:52 <lambdabot>     Expected kin...
22:45:57 <sclv> > M.lookup 3 (M.empty) :: Writer [Char] Int
22:45:58 <lambdabot>        add an instance declaration for (Show (Writer [Char] Int))
22:46:21 <sclv> > runWriter (M.lookup 3 (M.empty) :: Writer [Char] Int)
22:46:22 <lambdabot>  Exception: Data.Map.lookup: Key not found
22:46:34 <sclv> lovely.
22:47:05 <llimllib> thanks infinitely much for the help, I'll keep reading as long as you guys keep messing with lookup, but water level passed over my head a few minutes ago : )
22:53:48 <twanvl> > let lookup = M.lookup :: M.Map () () -> M.Map (M.Map () ()) () -> l -> () in         lookup M.empty M.empty lookup
22:53:49 <lambdabot>  Exception: Data.Map.lookup: Key not found
22:55:02 <zeeeee> dons, i'm trying to build h4sh but it complains about regex-compat being hidden even though ghc-pkg lists it as exposed.
22:55:47 <zeeeee> dons, i then tried to add a h4sh to h4sh.cabal, but that's an auto-generated file that gets removed on clean (and it seems i'd need clean to reconfigure)
22:56:00 <zeeeee> *add a regex-compat
22:59:33 <dons> zeeeee: oh, i've not tried to build that in a couple of years
23:03:47 <zeeeee> dons, out of curiosity: did you find something better (either shell/language, cmd line programs, or haskell lib)? do you just do less of that type of scripting nowadays?
23:06:29 <goltrpoat> what was the original double-barrelled cps transform paper?  i keep thinking felleisen, but the only thing i keep coming up with is thielecke's 2002 paper
23:07:38 <goltrpoat> (who doesn't seem to cite whatever it is i'm thinking of)
23:18:07 <shapr> @paste
23:18:07 <lambdabot> Haskell pastebin: http://hpaste.org/new
23:18:11 <shapr> !paste
23:18:11 <hpaste> Haskell paste bin: http://hpaste.org/
23:18:13 <shapr> spiffy
23:42:55 <pa-ching> Is there a Haskell convention for asserting?
23:43:17 <lament> put it in the type system :D
23:43:26 <pa-ching> Eheh.
23:43:39 <pa-ching> Yeah, error, otherwise... return ()?
23:43:50 <pa-ching> Okes, so none is provided?
23:43:52 <oerjan> @hoogle assert
23:43:53 <lambdabot> Control.Exception.assert :: Bool -> a -> a
23:43:53 <lambdabot> Control.Exception.assertions :: Exception -> Maybe String
23:43:53 <lambdabot> Control.Exception.AssertionFailed :: String -> Exception
23:44:00 <pa-ching> Oho, thanks
23:44:10 <pa-ching> Hoogle. Forgot about that site.
