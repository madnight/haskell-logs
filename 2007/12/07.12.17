00:01:57 <bench> sclv/dons, thanks, but (((','), ' ') ==) || ...) doesn't seem to be right either
00:02:48 <sclv> unpl it. (\x -> x == (',',' ') || x == ('.', ' '))
00:07:07 <bench> sclv: what's unpl?
00:07:21 <sclv> the opposite of pl
00:07:27 <sclv> @pl (\x -> x + 1)
00:07:28 <lambdabot> (1 +)
00:07:35 <sclv> @unpl (1 +)
00:07:36 <lambdabot> (\ a -> 1 + a)
00:07:36 <bench> sclv: this sort of works, but still has "baz." at the end
00:07:52 <nanothief> is there a standard function to search for a substring inside a string? eg search "hello world" "worl" --> Just 6
00:08:36 <bench> sclv: pl = curry then?
00:09:08 <shachaf> bench: @pl gets rid of named arguments.
00:09:15 <sclv> pl is a tool in lambdabot that turns a lambda expression into an equiv version without the "points" (i.e. named arguments)
00:09:17 <shachaf> @pl \x y -> 5 * x + y
00:09:17 <lambdabot> (+) . (5 *)
00:09:42 <sclv> it's just for golfing programs into shorter and sometimes more or less readable versions that do the same thing.
00:10:21 <bench> sclv, shachaf, thanks
00:10:32 <shachaf> sclv: Golfing?
00:10:59 <sclv> reduce the number of (key)strokes :-)
00:11:00 <shachaf> @pl \x -> [x,x+1,2*x+3,\y -> y * x^2]
00:11:00 <lambdabot> ap (:) (liftM2 (:) (1 +) (ap ((:) . (3 +) . (2 *)) (return . (*) . (^ 2))))
00:11:51 <tetha> reduce, right. :)
00:12:16 <Liskni_si> @pl (+1)
00:12:17 <lambdabot> (1 +)
00:12:36 <shachaf> @pl f ()
00:12:38 <lambdabot> f
00:12:47 <bench>  (map fst *** map snd) . break (\x -> x== ('.', ' ') || x == (',', ' ')) . ap zip tail $ "foo 12.34 bar, 12,35, baz."
00:12:51 <Cin> does haskell have reals or rationals?
00:12:58 <vininim> > let pm1 n xs = [(head $  drop (n-1) xs)]++(take (n-1) xs) ++ (drop n xs) in sequence (map (foldr (.) id) (filterM (const [True,False]) (pm1 <$> [1..3]))) [1..3]
00:12:58 <lambdabot>  [[1,3,2],[2,1,3],[3,1,2],[1,2,3],[1,3,2],[2,1,3],[3,1,2],[1,2,3]]
00:13:30 <bench> sclv: this doesn't quite work
00:13:41 <vininim> ah.. where is [3,2,1] :/
00:13:54 <jsnx> Cale: i had to go read it :(
00:13:56 <wy> It seems I'm into some intricate dependency chains of Cabal. Any automation avaible?
00:14:03 <jsnx> not sure how to derive it at all
00:14:19 <Cin> ahh
00:14:30 <Cin> disregard that question, found the library for numbers
00:14:39 <sclv> > (\x y -> elemIndex True . map (x `isPrefixOf`) $ tails y) "hello" "and hello"
00:14:40 <lambdabot>  Just 4
00:14:46 <shachaf> @where cabal-install
00:14:47 <lambdabot> I know nothing about cabal-install.
00:14:55 <shachaf> @go cabal-install
00:14:56 <lambdabot> http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
00:14:57 <lambdabot> Title: CabalInstall - Hackage - Trac
00:15:01 <shachaf> @hackage cabal-install
00:15:02 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/cabal-install
00:15:18 <Cale> jsnx: Well, first off, what's the type of return in this monad?
00:15:34 <vininim> humm... I believe a power set is not an enumeration, hence while it doesn't work
00:15:41 <vininim> *permutation
00:15:52 <sclv> nanothief: ^^
00:16:19 <Cin> vininim: it's combinations, isn't it?
00:16:34 <nanothief> sclv: hu? I thought that was the power operator
00:16:37 <sclv> bench: right. it only gives a tuple of the list split at the first comma or period and then the rest of the list. you need to apply it multiple times. see my example with unfoldr above.
00:16:50 <Cin> vininim: i was just talking about the power set to somebody, heh
00:17:04 <sclv> nanothief: sorry. was just pointing you to the example i posted above.
00:17:20 <vininim> I took quiet a while to understand that one-lines heh
00:17:29 <nanothief> sclv: haha ok thanks :P
00:18:20 <sclv> not the most efficient substring search, but certainly easy. i think there was talk of bringing a more efficient algorithm into the next ByteString release?
00:18:40 <Cin> i don't understand real numbers. how do they represent irrational things like Pi and square-root of 2?
00:18:56 <smack_> Cin: not well
00:19:05 <Cale> jsnx: Are you still here?
00:19:09 <sclv> @smack smack_
00:19:10 <lambdabot> Unknown command, try @list
00:19:16 <sclv> @slap smack_
00:19:17 <lambdabot> why on earth would I slap smack_?
00:19:20 <ac> hmm. I just realized (begin x y) is the same as ((lambda (x y) y) x y)
00:19:22 <sclv> @slap smack_
00:19:22 <lambdabot> *SMACK*, *SLAM*, take that smack_!
00:19:27 <sclv> there we go.
00:19:49 <Cale> Cin: How do real numbers represent those things?
00:19:58 <ac> that is true, right?
00:20:31 <Cale> Cin: Well, it depends on what the real numbers *are* -- you can set them up in a few ways, but one common one is as certain sets of rational numbers.
00:21:20 <Cale> Cin: essentially, you use the set of rational numbers which would be less than the square root of 2 in order to represent the square root of 2, for instance.
00:22:08 <Cale> That would be the approach via Dedekind cuts. I can point you at a PlanetMath entry for that if you'd like.
00:22:26 <wy> shachaf: cabal-install failed to configure
00:22:38 * ac removes begin from the primitive functions
00:22:58 <Cale> http://planetmath.org/encyclopedia/DedekindCuts.html
00:22:59 <lambdabot> Title: PlanetMath: Dedekind cuts
00:23:54 <Cin> cale: thanks, i'll look
00:24:16 <Cale> Cin: If you'd like a more involved development of the properties of the real numbers, starting from the axioms which that page shows the construction to satisfy, you should check out the book "Calculus", by Michael Spivak.
00:24:44 <Cin> cale: i have that book, but i am terrible at maths, so i haven't read it
00:25:00 <Cin> cale: i will read this page, however
00:25:06 <Cale> ah, you should definitely check it out -- don't worry about going quickly through it
00:25:23 <bench> sclv: i understand  your unfoldr example, but i'm having troubling tieing it together with the other code
00:25:23 <OceanSpray> isn't it supposed to be defmacro?
00:25:26 <Cale> "Theorem 1" on that page, the least upper bound property, is the key to all the properties that the reals have and the rationals do not.
00:25:43 <wy> conal: TV really depends on lots of things. I haven't figured out how to install it. I'm currently stuck at TypeCompose because it depends on too many things
00:25:50 <bench> maybe that i don't really understand the other code yet
00:25:51 <Cin> cale: ahh, that might help me get an idea about reals
00:26:09 <Cale> For example, the existence of a square root of 2, and the existence of numbers like pi.
00:26:12 <sclv> imagine the other code is just a fancy way of matching on two characters instead of one and performing a break.
00:26:25 <OceanSpray> well, at least it works now
00:26:31 <OceanSpray> on to file IO
00:27:58 <sclv> so maybe write an unfoldr that will take a string and break it on every period. and then drop in the other function instead.
00:28:12 <sclv> or you could use explicit recursion, e.g.
00:28:14 <sclv> @src words
00:28:14 <lambdabot> words s = case dropWhile isSpace s of
00:28:14 <lambdabot>     "" -> []
00:28:14 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
00:29:24 <Cale> In fact, we can use it directly to define the square root of 2. Consider the set of real numbers x such that x^2 < 2. This set is bounded, indeed, if |x| >= 2, then x^2 = |x|^2 >= 4, and so in order to be in this set, |x| < 2.
00:29:49 <Cale> This set is also nonempty, because in particular, 0^2 < 2, so at least 0 is in the set.
00:29:49 <qpu> sclv: does that split a string by spaces into an array?
00:30:13 <Cale> So this set of real numbers must have a least upper bound.
00:30:54 <sclv> > words "these are some words"
00:30:57 <lambdabot>  ["these","are","some","words"]
00:30:58 <Cale> and we could, if we wanted, define that least upper bound as the square root of 2
00:31:30 <Cale> That doesn't show that it has the expected algebraic property, but it does turn out to do it.
00:33:29 <bench> sclv: conceptually, i get it, but i'm having a hard time to get the code right -- since i'm new to haskell, a lot of the typing stuff is still a mystry
00:34:26 <sclv> maybe you could use hpaste and put what you have there, so that you can be more specific?
00:34:32 <bench> unfoldr (\x -> if '.' `elem` x then break ('.' ==) x else x) "foo 12.34 bar, 12,35, baz."
00:35:16 <sclv> :t unfoldr
00:35:17 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
00:35:55 <sclv> you need to give unfoldr a function that conceptually encompasses a standard recursion -- i.e. there is a base case and a recursive case.
00:36:37 <sclv> this is embodied in a return value of Maybe (a,b) -- so you give it a b, and you get either Just (a,b) or Nothing
00:36:59 <sclv> if you get Just (a,b), the a is added to the list, and the function is called again, with b. if you get Nothing, game over.
00:37:26 <Cin> cale: isn't one, at some point, forced to make an approximation, when computing it? i mean, to represent the square-root of 2, wouldn't we have to approximate it?
00:37:42 <sclv> > break ('.' ==) "a.b.c.d"
00:37:43 <lambdabot>  ("a",".b.c.d")
00:37:55 <sclv> > break ('.' ==) "abcd"
00:37:56 <lambdabot>  ("abcd","")
00:38:17 <Cin> cale: i'm curious as to what one gains
00:38:40 <tetha> Cin: hm, couldnt you use some symbolic comparision as well? (given the right circumstances, that is)
00:39:03 <sclv> bench: you also don't need that elem test, because as you can see, you can just test if the second part of the tuple is empty -- i.e. your base case is "" and conceptually you're chopping bits off the front of the string until you're done.
00:39:13 <Cin> tetha: what do you mean by symbolic comparison?
00:39:37 <alexeevg> @seen ndm
00:39:37 <lambdabot> I haven't seen ndm.
00:39:47 <Cin> tetha: i don't know what that is, sorr
00:39:53 <Cin> er, sorry
00:40:26 <tetha> Cin: if you have something like "f(x) = 1 if x == sqrt(2), 0 else", and call f(y), and y is the solution of y^2 = 2, then you can conclude that f(y) will evaluate to 1, without having to compare numbers at arbitrary precision
00:41:51 <Cin> tetha: ahh, i thought you might mean that. i can see how that would be an advantage
00:45:43 <bench> sclv: thanks for the explaination
00:46:01 <bench> sclv: is this closer? unfoldr (\x -> if x == "" then Nothing else break ('.' ==) x ) "a., c"
00:46:14 <bench> though it's still not quite right
00:46:31 <sclv> you need to return a Just
00:46:43 <sclv> i.e. else Just (etc)
00:47:02 <sclv> @src Maybe
00:47:03 <lambdabot> data Maybe a = Nothing | Just a
00:51:54 <bench> sclv: unfoldr (\x -> if x == "" then Nothing else Just break ('.' ==) x ) "a., c" becomes non terminating
00:59:37 <sclv> bench: hmm, looks like break is leaving the period in the front of your recursive case. so you need to break the string slightly differently such that it doesn'
00:59:41 <sclv> t do so.
01:00:24 <sclv> I think the other code for splitting on the period and space works right, but for this case you may want to play around with the different Data.List functions
01:00:42 <sclv> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
01:00:43 <lambdabot> http://tinyurl.com/yhrw65
01:00:53 <sclv> I'm off to bed though now. good luck! :-)
01:01:14 <bench> thanks sclv, you've been great help
01:15:15 <tetha> haha, our design for the software project is successful. we have to draw 2 new "nontrivial sequence charts" (object interaction diagrams), but there are no 2 new "nontrivial sequence charts" for the new functionality
01:16:57 <opqdonut> :D
01:20:40 <tetha> we just need to inherit once and set about 3 parameters for every task
01:30:16 <dcoutts> allbery_b: you were asking about gtk+/gt2hs natively on osx, ask njbartlett
01:30:33 <dcoutts> allbery_b: and gtk2hs does not need opengl bindings since we already have opengl bindings
01:31:21 <dcoutts> allbery_b: but gtk2hs does provide an opengl drawing widget and you can use that with the normal haskell opengl bindings
01:31:25 <dcoutts> I've written several gtk2hs progs that use opengl
01:32:32 <pharm> Q: Say I've got a biggish (recursively defined) datatype & I'd like a new datatype which is just like the old one, but is decorated with some extra data at each node. Is that a template Haskell job, or is there something more focused I should be using?
01:33:27 <scook0> pharm: it would be better to make one a special case of the other
01:33:44 <scook0> e.g. make the annotated structure polymorphic in the annotation
01:33:56 <scook0> and for the unannotated version, make the annotations of type ()
01:34:36 <scook0> this has the additional property that you can use the same code to traverse both structure types, if it's polymorphic enough
01:36:20 <pharm> scook0: That makes sense. I'm trying to do operations on a parsed syntax tree, but I need to do a first pass to collect data before doing a 'compilation' pass. (I can probably fold the two together, but I don't think my brain will cope with that at this point in the process...)
01:37:09 <scook0> I guess the heart of it will be a function :: Tree a -> Tree Metadata
01:37:17 <pharm> Yup.
01:37:25 <pejo> pharm, what are the annotations, compiled code?
01:37:39 <scook0> and as I said, the nice thing is that you can use the same functions to traverse unannotated and annotated trees
01:37:49 <pharm> Collections of unbound names.
01:38:19 <pharm> It's fairly obvious that the two passes can be folded together, but I'm not up to writing that in one go...
01:39:49 <dcoutts> pharm: the other approach is to tag each interesting part of the tree and then use auxiliary maps/tables :: Tag -> Whatever
01:40:51 <pharm> dcoutts: iow, pretag each node with a unique id at creation point?
01:41:03 <dcoutts> pharm: yes, or as a later traversal
01:41:04 <pharm> (point of creation that is)
01:41:09 * pharm nods
01:41:15 <pharm> I'll have a think about it.
01:41:21 <dcoutts> that makes it easy to build up multiple maps and to create and discard them easily without changing the type of the tree
01:41:49 <dcoutts> pharm: ChilliX's CTK (compiler tool kit) and c2hs use that technique
01:42:56 <pharm> Ta everyone.
01:44:07 <pejo> dcoutts, is the CTK intended for teaching?
01:46:16 <quicksilver> pharm: but the Tree a approach is quite popular, too
01:46:27 <quicksilver> pharm: it's explicitly recommended in SPJ's papers on writing compilers
01:50:32 <pharm> My heart leans towards the Tree a approach, whilst my head acknowleges the Tag -> Metadata one :)
01:51:28 <pharm> incidentally, is there a generic name for the function that looks like "f (T a) = a". Some kind of lift I guess...
01:51:31 <pharm> ?
01:51:53 <quicksilver> it's normally called 'unT'
01:52:07 <dcoutts> pejo: not it's not aimed at teaching, it's aimed at making compilers and similar programs easier to write by providing infrastructure
01:54:40 <pharm> hmm. "unSName" seems a little clumsy :)
01:56:20 <quicksilver> the normal idiom is to (ab)use record selector syntax
01:56:29 <quicksilver> data T = T { unT :: foo }
01:56:45 <quicksilver> or
01:56:49 <quicksilver> data T = mkT { unT :: foo }
01:57:03 <quicksilver> then mkT :: foo -> T and unT :: T -> doo
01:57:08 <quicksilver> s/doo/foo/ :)
01:57:12 <pharm> :)
01:58:00 <pharm> eww.
01:58:25 <axm> or s/f/v/ ;)
02:02:58 <pharm> (incidentally, the record syntax is my least favorite bit of Haskell...)
02:03:11 <pharm> (not that I have any better suggestions.)
02:03:14 <quicksilver> it's better than nothing
02:03:30 * pharm nods
02:04:04 <Beelsebob> anyone happen to have seen Malcolm Wallace about?
02:41:34 <Cale> Proper records would be nice.
02:42:14 <mux> record subtyping, mm
02:42:19 <Cale> Daan's proposal looks really good to me, at least semantics wise. The syntax could use some work :)
02:42:37 <quicksilver> Cale: which one is that?
02:43:00 <quicksilver> I think automatic lenses instead of automatic selector functions would be a good step
02:43:04 <quicksilver> and namespacing
02:43:06 <Cale> http://research.microsoft.com/users/daan/download/papers/scopedlabels.pdf
02:43:08 <lambdabot> http://tinyurl.com/392r4k
02:44:11 <Cale> In particular, I like the fact that it lacks lacks constraints.
02:44:45 <Heffalump> aren't lacks constraints important, though?
02:45:13 <Cale> Apparently not. ;)
02:45:50 <Cale> If I recall correctly, each field of these records acts like a stack, so you can always extend a record.
02:46:10 <quicksilver> you are allowed multiple things with the same name
02:46:17 <Cale> right
02:46:20 <quicksilver> { x :: Int , x :: Int } is a valid record
02:46:37 <quicksilver> if you select x you get the first x
02:46:45 <quicksilver> but, if you want the second x you delete the first one first
02:47:02 <quicksilver> (foo - x).x
02:49:59 <quicksilver> Cale: there are a lot of record systems kicking around, have been for years. Why haven't the GHC team felt moved to implement any of them?
02:51:12 <Heffalump> because there's no consensus on what to implement
02:51:27 <Cale> quicksilver: I suppose there hasn't been enough of a push for any one of them. It's one of those things which would be nice, but isn't absolutely essential, and the design space is large and appears to lack local optima
02:51:55 * quicksilver nods
02:52:20 <quicksilver> I wonder if GHC's own code uses much in the way of record types.
02:54:50 <Cale> It uses some, from what I saw.
02:58:34 <JaffaCake> quicksilver: yes, we use records a fair bit
02:59:23 <mux> I'm totally excited by this wildcard patterns for record feature
02:59:37 <mux> I've been needing something like that a fair number of times now
03:00:49 <quicksilver> JaffaCake: I was wondering whether you felt constrained by the kind of thing people lists as the deficiencies of the record system
03:01:15 <JaffaCake> I'd like to reuse label names
03:01:22 * quicksilver nods
03:01:35 <JaffaCake> but I don't particularly feel constrained by the lack of extensibility and subtyping
03:01:50 <quicksilver> the thing that annoys me most is the syntax
03:02:00 <JaffaCake> that might be because I'm not used to having them, and therefore don't tend to think in that way
03:02:12 <quicksilver> ref $~ (\val -> val { foo = (foo val + 1) })
03:02:30 <pejo> JaffaCake, suppose you had subtyping, would you see any use for it then?
03:02:33 <quicksilver> is a pretty verbose way of updating a single field within a record (reference)
03:02:54 <JaffaCake> quicksilver: right
03:03:02 <pejo> Oh, your next comment was apparently along the lines of my question.
03:03:06 <JaffaCake> pejo: nothing springs to mind, in the context of GHC that is
03:03:23 <quicksilver> I don't recall ever wanting subtyping in a real program, either.
03:04:04 <JaffaCake> we tend to use records for large datatypes as a way to document the fields, and get robustness to extension
03:05:02 <quicksilver> in a funny sort of way, that's like subtyping
03:05:04 <quicksilver> but over time
03:05:05 <JaffaCake> extension and subtyping is more important when you're writing a database library, or an XML library, that sort of thing I guess
03:05:06 <dozer> I've wanted extensible records when doing things with statef
03:05:11 <quicksilver> rather than in any one instance.
03:05:38 <quicksilver> you write robust functions which will continue to work in the presence of new fields
03:05:44 <quicksilver> so they work with any supertype
03:05:54 <quicksilver> although you only expect to use at one concrete type in a given compile
03:06:04 <quicksilver> it's still futureproofing against future supertypes
03:06:11 <JaffaCake> right, but we get to recompile - there's no need for the new code to work with the old type
03:06:15 <quicksilver> yup
03:06:59 <pejo> quicksilver, I'm not arguing either way, but I think Jaffacakes comment about not being used to having certain things possibly makes you blind for it is spot on.
03:07:29 <scook0> application domain might be a factor, too
03:07:47 <quicksilver> yes it's true
03:07:50 <scook0> e.g. compiler-ish programs might have less need for it than other apps
03:07:55 <quicksilver> I have a feeling subtyping could be a can of worms, though
03:08:07 <quicksilver> Like, people would use it inappropriately for OO-like features
03:08:11 <quicksilver> which would then not work well
03:08:18 <quicksilver> cos it's the wrong abstraction in fact
03:08:49 <pejo> quicksilver, any feature can be abused.
03:09:42 <quicksilver> yup
03:09:51 <quicksilver> that wasn't an argument against introducing the feature
03:09:53 <quicksilver> just a comment
03:10:13 <quicksilver> still there is such a thing as user-interface, even in language design
03:10:23 <quicksilver> well-designed features encourage you not to abuse them
03:10:41 <mux> I quite liked how B. Pierce gets inheritance in his pet OO language with just record subtyping and existentials
03:10:52 <mux> now I'm not sure it's very useful to have in Haskell
03:10:55 <mux> I mean, record subtyping
03:40:54 <dozer> ok, I downloaded and installed ghc 6.8.2 from http://haskell.org/ghc/download_ghc_682.html
03:41:17 <dozer> the linux (x86_64) binary
03:41:38 <dozer> when I try to build things with profiling, it says it can't find the profiling version of bundled libs
03:41:39 <dozer> e.g.
03:41:53 <dozer> Perhaps you haven't installed the profiling libraries for package hxt-7.3?
03:42:31 <dcoutts_> perhaps it's right?
03:42:40 <dcoutts_> did you build hxt-7.3 with profiling?
03:42:51 <dozer> I didn't build it - it was bundled as far as I know
03:42:56 <dcoutts_> no it's not
03:43:05 <dcoutts_> hxt is separate
03:43:06 <dozer> mm - interesting
03:43:36 <dozer> no - definitely the only things I built where zlib and http
03:43:59 <dcoutts_> what are you building that uses hxt then?
03:44:18 <dozer> some of my own code, and it compiles fine without profiling
03:44:34 <dcoutts_> dozer: ghc-pkg list hxt will tell you if it's installed
03:45:05 <dcoutts_> dozer: you don't get profiling by default for packages you build with cabal, though the core libs all are built with it. If you want to configure a package to build with profiling use: runghc Setup configure -p
03:45:12 <dozer> /usr/local/lib/ghc-6.8.2/package.conf:  hxt-7.3
03:45:33 <dcoutts_> so you did build hxt for ghc-6.8.2
03:45:47 <dozer> I swear I didn't
03:45:47 <dcoutts_> which is interesting since it does not build for 6.8.2 without patching :-)
03:46:00 <dcoutts_> I know since I had to patch it for the gentoo ebuild
03:47:23 <dcoutts_> dozer: so just rebuild hxt with configure -p this time
03:47:47 <dcoutts_> actually assuming it's already installed for non-profiling libs it's possible to build just the profiling ones without re-building the vanilla ones
03:49:07 <dcoutts_> if you configure --disable-library-vanilla --enable-library-profiling
03:50:16 <dozer> yeah, but first I have to track down where the hxt source is on my disk
03:52:06 <dozer> ths is getting stranger - I have source for hxt 7-2, but have hxt 7-3 installed
03:53:58 <dcoutts_> dozer: do you use cabal-install perhaps?
03:54:06 <wy> any good tutorial for gtk and opengl in haskell?
03:54:13 <dozer> no - I only managed to build it for the first time 5 min ago
03:55:51 <dozer> oh, and cabal doesn't have a 'remove' verb
03:59:42 <dozer> http://hpaste.org/4540
04:00:28 <dozer> so would I expect to be seeing foo-profiling-versionNo in there as well as foo-versionNo?
04:06:09 <dcoutts_> wy: there is a gtk2hs tutorial and there are some opengl docs too I think, then there's a couple gtk2hs demos that use opengl which should help
04:06:45 <dcoutts_> dozer: unfortunately nothing records the lack of the profiling versions
04:08:13 <dozer> it seems like profiling is a bit of a 2nd class citizen
04:08:56 <wy> dcoutts_: I got some demos from gtk2Hs, but maybe I need some documentation also
04:09:28 <dcoutts_> wy: see the gtk2hs website haskell.org/gtk2hs/
04:09:33 <SamB_XP> wy: you almost certainly need the gtk documentation
04:10:08 <dozer> if I use cabal install hxt, will it install the profiling versions as well?
04:10:28 <dcoutts_> dozer: only if you use -p or --enable-library-profiling
04:11:44 <dozer> ok, I was confused because -p isn't an option printed out by cabal --help
04:13:26 <dcoutts_> dozer: I think the current version of cabal-install does not expose that option. It's implemented by the command line handing patches I posted yesterday. For now you'll have to do it without cabal-install.
04:18:25 <dozer> dcoutts_ I'm off to lunch now - would you mind walking me through this later this afternoon?
04:18:32 <dcoutts_> np
04:18:48 <dozer> possibly off the main list to avoid spamming ppl :)
04:19:06 <dozer> and I promiss to write it up on the wiki if it looks like it may be a useful experience to share
04:49:32 <DRMacIver> Ho hum. Anyone know much about the theory of regular expressions? Given a NFA for a regexp I'm trying to find a good NFA for its complement. All the existing theory seems to procede via DFAs, which appears to preclude "good" as it can cause an exponential increase in the number of states.
04:50:43 <DRMacIver> (I can probably work this out myself. It doesn't feel like it should be hard. But if there's existing literature I'd quite like to read it. :) )
04:50:50 <quicksilver> that doesn't sound surprising to me
04:51:02 <quicksilver> complement makes the language much harder, doesn't it?
04:51:03 <opqdonut> just add a new goal state q and an epsilon-transition from every non-goal state to it
04:51:17 <opqdonut> and remove goal status from the original goal state
04:51:34 <opqdonut> that is for dfa->complementnfa
04:51:51 <opqdonut> it should work for an nfa too with some assumptions
04:51:58 <DRMacIver> That approach doesn't work for NFA -> complement NFA though does it?
04:52:09 <DRMacIver> I convinced myself that it didn't somehow, but I can't remember how.
04:52:30 <opqdonut> yeah the assumptions you have to make about the nfa to make it work might be too drastic
04:53:01 <DRMacIver> quicksilver: I don't really see why it should make it much harder. I'd expect some non-linear increase in size, but it should be polynomial.
04:53:38 <DRMacIver> opqdonut: If nothing else, it would be very odd that everyone proceeds via a DFA. :)
04:53:48 <opqdonut> true
04:54:14 <DRMacIver> The only hard bit should be working out how to compile
04:54:16 <DRMacIver> oops
04:54:39 <DRMacIver> compile ~(ab) from compilation strategies for a, b, ~a and ~b
04:54:48 <DRMacIver> * should follow from there and all the others are (sortof) trivial
04:56:03 <opqdonut> yeah probably the best way
04:56:40 <opqdonut> err, does that work?
04:57:29 <opqdonut> a~b|~a~b|~ab might not be enough
04:57:34 <opqdonut> to rule out all options
04:58:00 <DRMacIver> No, it isn't. That's why I said it's the hard bit. :)
04:58:00 <opqdonut> think for example ~((aaa)(aaaa))
04:58:20 <opqdonut> you really need to "introspect" both pieces
04:58:29 <dozer> surely in general, the negation of a regex will be an infinite set with 'interesting' shape?
04:58:43 <opqdonut> yeah, tho it is a regex
04:58:53 <DRMacIver> Hm. Does something like ~a(.*) | a|(~b) work?
04:59:28 <DRMacIver> We either match anything that doesn't start with a or does start with a but doesn't end with b
04:59:58 <opqdonut> yeah that might do it
05:00:02 <DRMacIver> Shiny
05:00:10 <DRMacIver> I guess * doesn't follow that readily though.
05:00:18 <dozer> ~a.*|a~b
05:00:26 <opqdonut> how about when there is an x \in ~a so that xy \in a
05:00:41 <opqdonut> then xy would be matched by ~a(.*)
05:00:46 <quicksilver> I thought the compliment of a regular language was not regular
05:00:50 <opqdonut> and have b=epsilon
05:00:51 <quicksilver> but I'm probably confused
05:00:58 <DRMacIver> quicksilver: No, the complement of a regular language is always regular.
05:01:01 <opqdonut> quicksilver: it is
05:01:04 <DRMacIver> quicksilver: It's context-free that doesn't hold for I think
05:01:07 <dozer> mm - you will potentially get into trouble if a is x|y though
05:01:30 <DRMacIver> dozer: Yeah, I already said that expression. :)
05:01:38 <DRMacIver> dozer: Hm. Why is that a problem?
05:01:46 <opqdonut> DRMacIver: couldn't you just do nfa->minimized dfa->new nfa for complement
05:02:36 <dozer> DRMaclver: you have to flip the 'or expression' into an 'and' expression
05:02:37 <DRMacIver> opqdonut: The minimized DFA might have exponentially more states than the source NFA.
05:02:42 <DRMacIver> dozer: Yes, but that's fine
05:03:14 <DRMacIver> dozer: You can get the intersection of two regular expressions x and y for only O(|x| |y|) states
05:03:35 <dozer> DRMaclver: fine
05:03:44 <DRMacIver> dozer: You basically build a NFA whose states are pairs from the NFA for x and y
05:04:16 <opqdonut> "The complement operator is redundant, as it can always be expressed by using the other operators (although the process for computing such a representation is complex, and the result may be exponentially larger)."
05:04:20 <opqdonut> says wikipedia
05:05:02 <DRMacIver> opqdonut: Right.
05:05:28 <DRMacIver> opqdonut: I'm trying to figure out if one can avoid that exponential increase.
05:05:39 <opqdonut> that kinda implies it isn't possible
05:06:00 <DRMacIver> I don't see why
05:06:14 <DRMacIver> Even if I considered wikipedia authoritative. :)
05:06:34 <DRMacIver> I'm not trying to express it in terms of the other operators. I'm trying to add it and find an efficient compilation strategy
05:06:54 <DRMacIver> (I'm going to have to disappear imminently)
05:07:20 <DRMacIver> In fact, now.
05:07:21 <DRMacIver> Bye
05:07:26 <DRMacIver> Thanks for the help everyone
05:08:29 <shag> i have a function foo :: a -> b -> Maybe c and want to combine it with Data.Maybe.maybeToList to get a function (a -> b -> [c]) but i just don't get it ... my best approach was (maybeToList . foo) but then there seem to few arguments.
05:09:12 <mux> generalise your foo function to work with any monad instead of just Maybe
05:09:19 <mux> then you'll get the list form for free
05:09:53 <shag> hm.
05:10:04 <mux> :t lookup
05:10:08 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
05:10:16 <mux> :t Data.Map.lookup
05:10:17 <lambdabot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> Data.Map.Map k a -> m a
05:10:18 <opqdonut> :t (maybeToList .) . foo -- you want this
05:10:19 <lambdabot> Not in scope: `foo'
05:10:21 <opqdonut> woops
05:10:34 <opqdonut> :t (maybeToList .) . (foo::a->b->Maybe c) -- you want this
05:10:35 <lambdabot> Not in scope: `foo'
05:10:38 <opqdonut> gah
05:10:43 <opqdonut> :t (maybeToList .) . (undefined::a->b->Maybe c) -- you want this
05:10:44 <lambdabot> forall a a1 a2. a2 -> a1 -> [a]
05:10:45 <opqdonut> :)
05:11:00 <mux> @src Data.Map.lookup
05:11:00 <lambdabot> Source not found. Just what do you think you're doing Dave?
05:11:01 <opqdonut> with just one . it won't typecheck
05:11:11 <opqdonut> :t (maybeToList) . (undefined::a->b->Maybe c) -- nuh-uh
05:11:12 <lambdabot>     Couldn't match expected type `Maybe a'
05:11:12 <lambdabot>            against inferred type `b -> Maybe c'
05:11:12 <lambdabot>     In the second argument of `(.)', namely
05:11:14 <shag> opqdonut: yes! that's it!
05:11:16 <opqdonut> :)
05:11:28 <shag> thanks :)
05:11:32 <opqdonut> np
05:11:39 <quicksilver> :t (maybeToList .) . (undefined :: a -> b -> Maybe c)
05:11:41 <lambdabot> forall a a1 a2. a2 -> a1 -> [a]
05:11:49 <quicksilver> oh, opqdonut already said that :)
05:11:54 <opqdonut> heh
05:12:00 <opqdonut> ?pl f x y = maybeToList (foo x y)
05:12:01 <lambdabot> f = (maybeToList .) . foo
05:12:02 <quicksilver> shag: composing three arg functions is less elegant
05:12:10 <quicksilver> shag: I often write it explicitly
05:12:20 <opqdonut> or leave one arg in
05:12:21 <quicksilver> \x y -> maybeToList (foo x y)
05:12:24 * mux nods
05:12:31 <osfameron> can't you easily create combinators for those too?
05:12:33 <shag> but that composed function is an argument to fold
05:12:34 <opqdonut> \x -> maybeToList . foo x
05:12:36 <osfameron> like you can for 2-arg functions
05:12:41 <opqdonut> osfameron: of course
05:12:42 <quicksilver> yes, you can, but you have to remember them all
05:12:50 <quicksilver> some people use (.:)
05:13:04 <mux> I was about to mention that
05:13:06 <shag> quicksilver: therefore i cannot yet apply any argument
05:13:17 <quicksilver> shag: that's why the \x y is tehre
05:13:22 <shag> ah i see
05:13:25 <quicksilver> shag: the lamba lets you name unapplied arguments
05:13:27 <shag> (reading too slowly)
05:13:59 <quicksilver> :t let f .: g = (f.).g in maybeToList .: (undefined ::a->b->Maybe c)
05:14:00 <lambdabot> forall a a1 a2. a1 -> a2 -> [a]
05:14:10 <quicksilver> but, I don't really use it often enoguh to want to do that
05:14:33 <mux> now for that particular case I'd just generalise the function to arbitrary monads
05:14:52 <mux> it seems quite natural to do this when you want both Maybe a and [a] as the result
05:14:53 <shag> quicksilver: indeed, that looks much better
05:16:45 <quicksilver> possibly, yes
05:16:54 <quicksilver> although it's arbitrary MonadZeros really
05:17:05 <quicksilver> btu since we live in the world we live in, arbitrary monads will have to do
05:17:09 <shag> MonadZeros?
05:17:50 <shag> well, isn't generalising for arbitrary monads always good?
05:20:02 <mux> quicksilver: *nods*
05:20:24 <mux> using fail and generalising to every monad is better than nothing
05:28:07 <quicksilver> shag: arbitrary monads don't really support failure
05:28:29 <quicksilver> shag: it's an (ahem) "infelicity" of the haskell98 standard that our Monad class has a method fail
05:30:16 <shag> hmm.
05:30:52 <quicksilver> however, Maybe and [a] do support failure very well (being Nothing and [])
05:32:16 <shag> i think i need to read something about how to generalise maybe (or others) to any monad
05:33:11 <opqdonut> just replace Nothing with mzero or fail
05:33:15 <opqdonut> and Just x with return x
05:35:06 <shag> opqdonut: k, i'll try :)
05:36:12 <Sizur> what's causing a conflict here: http://hpaste.org/4541?lines=true
05:37:47 <Sizur> @users
05:37:48 <lambdabot> Maximum users seen in #haskell: 398, currently: 398 (100.0%), active: 8 (2.0%)
05:38:02 <quicksilver> Sizur: well, you say that r1 r2 -> r3
05:38:11 <quicksilver> Sizur: yet you have two isntances with same r1,r2 and idfferent r3
05:38:34 <Sizur> quicksilver: i dotn see em
05:38:43 <Sizur> what lines?
05:39:23 <quicksilver> hmm maybe I misunderstand
05:39:35 <quicksilver> I don't really understand how OverlappingInstances interacts with fundeps..
05:39:52 <Sizur> i dont see there a fundep conflict
05:39:58 <Sizur> it smells to me like a bug
05:40:11 <shag> opqdonut: how do i transform isJust?
05:40:11 <Sizur> it compiles find if i lower the dimensions
05:40:21 <Sizur> fine* (not find)
05:40:29 <quicksilver> hmm does sound a bit buggish then
05:55:06 <Sizur> i definitely don't have duplicate (r1,r2). -- length it == nub $ length it
05:55:45 <Sizur> i mean -- length it == length $ nub it
06:04:16 <daf> howdy
06:20:47 <Sizur> @hoogle isJust
06:20:48 <lambdabot> Data.Maybe.isJust :: Maybe a -> Bool
06:21:24 <BMeph> ¡Hola! ¿Como esta? ;)
06:22:20 <Sizur> mucho mejor
06:24:01 <Sizur> Simplemente usando Google herramientas lingüísticas
06:24:56 <dozer> mm - lunch went on a bit
06:25:14 <BMeph> Si, mucho facíl.
06:26:16 <BMeph> So, Sizur, how is your life made better lately? Other than being able to expand your enjoyment and knowledge of Haskell (and the Google translation tool)? ;)
06:30:23 <Sizur> BMeph: doing ok, will be doing better
06:32:09 <BMeph> Sizur: What -  is there another  module recently adapted to 6.8.2 coming out? ;)
06:33:01 <Sizur> i'm out of the loop
06:34:48 <Saizan_> Sizur: all of those instances conflict. what instance would you pick for join [(Int,Int,Int)] [(Int,Int,Int)]?
06:35:22 <Sizur> Saizan_: i isomorph before a join like that
06:35:51 <Saizan_> that doesn't make the instances legal :)
06:36:10 <Sizur> Saizan_: i have already tested the code
06:36:44 <Saizan_> tested what?
06:37:18 <Sizur> Saizan_: if i compile with lower dimensions, it works fine
06:37:37 <quicksilver> Saizan_: however, he has overlapping instances on
06:37:39 <Saizan_> lower means tuples of size two?
06:37:46 <quicksilver> Saizan_: so some conflict is permissable...
06:38:04 <quicksilver> I don't understand the rules, myself
06:38:22 <Sizur> http://hpaste.org/4541#a1
06:38:30 <Saizan_> well you need them to be in a more specific order, somehow
06:38:36 <Sizur> i can gave complete code if you want to test for yourself
06:39:01 <quicksilver> what you just pasted doesn't contain a conflict, though :)
06:39:14 <Saizan_> heh
06:39:26 <quicksilver> the conflict would be between that and [(a,b,c)] [(a,e,f)], say
06:39:29 <Sizur> code compiles if i limit joins to produce maximum tuples of size 4
06:40:08 <Sizur> Saizan_: right, but if i understood Saizan_'s concern, he meant that a,b,c can all be one
06:40:35 <dozer> ok, I've got further this time with profiling
06:40:45 <Saizan_> Sizur: the point is being able to choose an instance from the arguments of join
06:40:52 <dozer> I managed to build my stuff after "Setup.lhs configure -p"
06:41:08 <Sizur> Saizan_: i have no (r1,r2) duplicates
06:41:33 <Saizan_> Sizur: but they are full of variables that can be unified
06:44:00 <Sizur> http://hpaste.org/4541#a2
06:44:11 <Sizur> ah, it cut
06:44:28 <Sizur> but you get the point
06:44:53 <Saizan_> do you have an instance that looks like [(a,b,c)] [(d,e,f)] [(a,b,c,d,e,f)] ?
06:45:09 <Sizur> no
06:45:22 <araujo> morning
06:46:12 <Saizan_> which point?
06:47:02 <Sizur> this is the same anamorphism. it fails from a higher seed
06:47:05 <quicksilver> Sizur: then it's expected you wont' get conflicts until size 5, I believe
06:47:10 <Saizan_> however restricting the size of the result means that more variables coincides between the arguments, so less unification can be done
06:47:34 <quicksilver> because the first interesting conflict is between (a,b,c) (a,b,d) and (a,b,c) (a,d,e)
06:47:41 <quicksilver> which is, indeed what you showed us :)
06:47:53 <quicksilver> and that has a result type of size 5.
06:47:59 <Sizur> why is it a conflict again?
06:48:11 <quicksilver> I don't claim to understand overlapping instances.
06:48:44 <quicksilver> but (a,b,d) and (a,d,e) are the *same* type, I think
06:48:48 <quicksilver> so that fails the fundep
06:49:10 <quicksilver> (a,b,c) (a,b,d) joins to ive (a,b,c,d)
06:49:21 <Sizur> right
06:49:29 <quicksilver> but (a,b,c) (a,d,e) joints to give (a,b,c,d,e)
06:49:37 <quicksilver> however, (a,d,e) == (a,b,d)
06:49:44 <quicksilver> so those are the same r1 r2
06:49:45 <Sizur> instance (Eq (b, c)) => Join [(a, b, c)] [(d, c, b)] [(a, b, c, d)] where
06:49:46 <Sizur> this is fine too
06:49:47 <quicksilver> but a different r3
06:49:57 <Sizur> aha
06:50:31 <Sizur> (a,d,e) == (a,b,d)?
06:51:03 <quicksilver> yes
06:51:06 <quicksilver> those are the same types
06:51:18 <quicksilver> (a,b,c) == (x,y,z)
06:51:36 <quicksilver> in a polymorphic type, variable names don't matter :)
06:51:45 <Saizan_> well all his tuples have (x,y,z) form
06:52:08 <quicksilver> Saizan_: right, but this is the answer to the question "why do I get no error with result tuple less than size 5"
06:52:17 <quicksilver> because there are no conflicts, for less than size 5
06:52:26 <quicksilver> since he is excluding trivial joins
06:52:44 <quicksilver> if you included the trivial join there would be a much simpler conflict
06:52:51 <quicksilver> (a,b) (a,b) joints to (a,b)
06:52:57 <quicksilver> (a,b) (a,c) joins to (a,b,c)
06:53:05 <Sizur> i guess i have to say "bye bye" to fundeps
06:53:14 <quicksilver> I think so
06:53:26 <quicksilver> you might wish for a system of fundeps which was able to take more into account
06:53:31 <quicksilver> like actual instantiations
06:53:41 <quicksilver> but I suspect there might be good reasons they don't do that
06:54:29 <Saizan_> in the HList paper there's a workaround for such conflicts, but it won't scale to so many instances i think
06:55:01 <Sizur> hlist is on my "next to study" list
06:57:10 <Nafai> Hey byorgey
06:57:16 <byorgey> hi Nafai!
06:57:18 <Nafai> How are the applications coming?
06:57:28 <byorgey> pretty good, actually
06:57:28 <Sizur> when will we already have a real relational system...
06:57:39 <byorgey> I hope to be done today or tomorrow at the latest.
06:57:56 <Sizur> 2050
06:58:00 <byorgey> Nafai: thanks for asking =)
06:59:03 <Saizan_> Join [(a, b)] [(a, c, d)] [(a, b, c, d)],Join [(a, b)] [(a, d, c)] [(a, b, c, d)], this two don't conflict, but i think you'd get an error when using them..
06:59:13 <Nafai> byorgey: Awesome!  I bet that will feel nice.
06:59:18 <BMeph> quicksilver: How is (a,d,e) = (a,b,d) if b and d are different types?
06:59:23 <byorgey> Nafai: you said it!
06:59:43 <benny99> what are fundeps actually :-[ ?
06:59:56 <byorgey> Nafai: my list of projects to do once I'm done with applications is... rather long =D
07:00:11 <Sizur> BMeph: it's across instances, not within the same instance
07:00:12 <Saizan_> BMeph: what says you that they are different types?:)
07:00:49 <dozer> benny99: they close off the type-system in useful ways
07:01:08 <benny99> dozer: :| ?
07:01:13 <BMeph> Sizur: In the instance join (a,b,c) (a,b,d) are the a and b the same types necessarily?
07:01:23 <benny99> dozer: you maybe got a small example?
07:01:29 <dozer> benny99: consider Class Foo a b | a -> b
07:01:35 <Sizur> BMeph: no, but across instances they care
07:01:42 <Sizur> are*
07:02:06 <quicksilver> BMeph: b and d aren't types, though
07:02:08 <quicksilver> BMeph: they're variables
07:02:12 <benny99> dozer: gnah, sorry, I don't even understand that :(
07:02:13 <quicksilver> (uninstantiated variables)
07:02:21 <quicksilver> uninstantiated variables are indistinguishable
07:02:31 <quicksilver> otherwise we couldn't unify [a] with [b]
07:02:36 <BMeph> That doesn't make sense to me. How can they be the same type across instances, but different types in a single instance?
07:02:53 <Sizur> we could state so in the context if it'd be possible
07:02:55 <dozer> lol - benny99: that reads, there is a class called Foo that requires a pair of types, a, b. For each a, there is exactly one possible choice of b.
07:02:55 <quicksilver> they are the same, as far as fundep resolution is concerned.
07:02:57 <Sizur> a/=b
07:03:04 <quicksilver> Sizur: yeah
07:03:06 <quicksilver> Sizur: but we can't ;)
07:03:12 <quicksilver> althouhg, I think technically we can
07:03:18 <quicksilver> maybe, only oleg can :)
07:03:24 <quicksilver> that's definitely a good 250mOleg
07:03:41 <benny99> dozer: ok :)
07:03:43 <quicksilver> BMeph: consider a class Foo, of kind ::  * -> *, like Monad is
07:03:54 <quicksilver> instance Foo ([a])
07:03:57 <quicksilver> instance Foo ([b])
07:04:03 <quicksilver> ^^ these instances are "the same" instance
07:04:14 <quicksilver> even if a and b are different letters
07:04:20 <quicksilver> that is the problem Sizur is having
07:04:38 <benny99> dozer: (damn, I thought that I at least got a "what I should know"-list)
07:04:38 <quicksilver> the point is, forall a . a is the same as forall b . b
07:05:24 <dozer> benny99: I'm attempting to think of a compelling example, and failing
07:05:27 <byorgey> benny99: so in that case, you would not be allowed to have both 'instance Foo Int Char' and 'instance Foo Int Bool'.
07:05:50 <benny99> byorgey: dozer: ah :)
07:05:52 <BMeph> quicksilver: That seems like too simple of a way to explain the conflict, but I understand the principle.
07:06:37 <byorgey> benny99: It helps the compiler, since if it sees something like Foo Int a, it knows the a has to be, say, Char (if you declared instance Foo Int Char).
07:06:46 <benny99> byorgey: understood dozer's explanation already, but what are fundeps now :-[ ?
07:06:46 <dozer> but you could have 'instance Foo Int Char' and 'instance Foo Bool Char'
07:07:24 <benny99> dozer: yep
07:07:25 <byorgey> benny99: fundeps ("functional dependencies") are those things after the | in class declarations.  like | a -> b in dozer's example.
07:07:30 <benny99> dozer: as you wrote ;)
07:07:43 <dozer> benny99: because we know there's a fundep, if we are given 'Foo Int x' we know what x equals
07:08:06 <benny99> and if I do 'Foo Int y' now?
07:08:32 <byorgey> then y must be Char also.
07:08:34 <dozer> well, the y is a free type variable, so as Int defines what the 2nd type is, it can fill in y with a concrete type as well - the same one
07:08:40 <benny99> the compiler tells me, that I was stupid? or does it cause something different to happen?
07:09:05 <byorgey> just because 'x' and 'y' are different names doesn't mean they must represent different types.
07:09:09 <Saizan_> you can't declare instance Foo Int y
07:09:45 <dozer> no, but you could end up with things that shape in guards on signatures
07:09:46 <benny99> so it's a precaution?
07:09:49 <byorgey> Saizan_: right, but if you have some function of type :: (Foo Int y) => blah blah...
07:10:37 <BMeph> I understand that instance " (Eq a) => Join [(a, b, c)] [(a, d, e)] [(a, b, c, d, e)] " is the same as instance " (Eq a) => Join [(a, b, c)] [(a, e, d)] [(a, b, c, d, e)] ".
07:11:16 <BMeph> I just don't see how either one is the same as instance " (Eq a) => Join [(a, b, c)] [(a, b, d)] [(a, b, c, d)] "
07:11:22 <byorgey> benny99: think of it not so much as a precaution, as it is a way to help the type checker.
07:11:50 <benny99> hmk :), thanks
07:12:09 <quicksilver> BMeph: no one is saying they are the same
07:12:10 <BMeph> Is it that it doesn't look at the component types within the tuple, only that they are 3-tuples in general?
07:12:19 <quicksilver> BMeph: wht we are saying is that they violate the fundeps
07:12:53 <quicksilver> BMeph: so "r1" and "r2" are "the same" according to the fundep rules
07:13:16 <quicksilver> (r1 = (a,b,c) in both cases, r2 = (a,d,e) or (a,b,d) resp.)
07:13:53 <quicksilver> so, the fundep resolved, when deciding if "r1" and "r2" are "the same", doesn't take into account whether nor the variables in r1 have in fact been partially unified with the variables in r2.
07:14:00 <quicksilver> I think I understand why this would be.
07:14:15 <BMeph> So, was my last question right, as for how fundeps look at types involving tuples?
07:14:33 <quicksilver> well you have to be very precise about "when it doesn't look at"
07:14:42 <quicksilver> it does look at them, when the instance asks it to
07:14:57 <quicksilver> but what it doesn't do (apparently) is look at the partial unification when checking FDs.
07:15:39 <quicksilver> I think I can explain why, as well
07:15:47 <quicksilver> Suppose in one context, the variables are all distinct
07:15:53 <quicksilver> so it chooses the more general isntance
07:15:59 <BMeph> But it doesn't compare how the interior tuple member types compare between r1 and r2?
07:16:00 <quicksilver> and the type checking proceed with that instance.
07:16:13 <quicksilver> so, we type check our function successfully. Good.
07:16:21 <quicksilver> Now, that function is *used* in a different context.
07:16:28 <quicksilver> In this outer context, some of the variables are, in fact, unified.
07:16:38 <quicksilver> this means that the instance selection was wrong :(
07:16:47 <quicksilver> when checking the innner code, it picked the more general instance
07:16:56 <dozer> so what have I done wrong here? http://hpaste.org/4542
07:17:00 <quicksilver> but then, this inner code was used in a more specific context
07:17:04 <quicksilver> and the instance selection is wrong
07:17:10 <quicksilver> so, this breaks things like "most general type"
07:17:18 <quicksilver> however, this does also suggest the solution
07:17:21 <Saizan_> i don't think the instance resolution is so eager, is it? won't you get an explicit context in the first function?
07:17:34 <quicksilver> Saizan_: you will, if the first function forces it
07:17:43 <quicksilver> Saizan_: the first function might quite explicitly assign to a 4-tuple
07:17:47 <quicksilver> Saizan_: erm, 50tuple
07:17:59 <quicksilver> Saizan_: thus it only type-checks in the presence of the most general instance
07:18:07 <quicksilver> of course, this suggests the solution:
07:18:20 <quicksilver> the solution is to have "NonEquality" contraints in the type inferred
07:18:35 <quicksilver> (that's what Sizur said half an hour ago, but I was too slow to see the relevance)
07:19:00 <quicksilver> if the inferred type had non-equality constraints, then presumably it would blow up if you tried to use it in a context which unified them.
07:19:09 <quicksilver> I believe Oleg has shown this is possible.
07:20:11 <quicksilver> I must qualify that all this is guesswork. I don't really understand the class system in this much detail :)
07:20:17 <quicksilver> But what I've said seems to make sense to me.
07:20:50 <Saizan_> i don't get the "50tuple", but well :)
07:21:06 <quicksilver> Saizan_: type for 5-tuple, sorry.
07:21:30 <dozer> as far as I can tell, I've built my app with profiling
07:21:33 <dozer> but it won't run :(
07:22:18 <BMeph> dozer: -prof is a ghc option, not an RTS option.
07:23:41 <Saizan_> quicksilver: i still think you'd get an explicit context until you've only ground types in that tuples so the instance won't be choosen early
07:23:55 <dozer> BMeph: I get the same message if I run with +RTS -p
07:24:50 <quicksilver> Saizan_: hmm. Maybe you're right.
07:25:17 <BMeph> dozer: But you never ran *ghc* with -prof. That's what you need to do.
07:25:35 <quicksilver> Saizan_: well you can always force instance resolution, it doesn't have to be ground types
07:25:51 <quicksilver> Saizan_: (a >> b) :: [c] -- forces the [] Monad instance
07:25:55 <Saizan_> BMeph: passing -p to configure should do that, or maybe it only works for libries?
07:25:58 <quicksilver> Saizan_: even with c a type variable
07:25:59 <dozer> BMeph: I thought that's what "./Setup.lhs configure -p" did for me
07:26:23 <Saizan_> quicksilver: but that's because the context won't mention c anyway
07:26:49 <quicksilver> dozer: I suspect that just forces profiling libraries to be built
07:26:52 <quicksilver> dozer: not applications
07:27:02 <dozer> oh - that seems like a useability bug, at the very least
07:27:07 <quicksilver> dozer: your libarary evidently was built with profiling (see the _p version)
07:27:12 <dozer> yeah
07:27:17 <quicksilver> I'm only guessing, mind you :)
07:27:31 <quicksilver> I recall some cabal infelicities with single projects which build both libraries and executables.
07:27:33 <Saizan_> dozer: try with --enable-executable-profiling
07:27:41 <Saizan_> also
07:28:13 <dozer> Saizan_ forgive me - what would the complete command-line look like?
07:28:52 <Saizan_> well, ./Setup.hs clean; ./Setup.lhs configure -p  --enable-executable-profiling
07:28:56 <Saizan_> and then rebuild
07:29:01 <Sizur> fundeps and overlaps are not the best buddies ... yet
07:29:39 <Saizan_> heh, associated type synonims won't allow any overlapping for a reason :)
07:30:14 <Sizur> eh?
07:30:35 <quicksilver> Saizan_: On reflection, I don't know the rules about "how long" contexts stay in types
07:30:57 <quicksilver> :t (show (0+[]))
07:31:00 <lambdabot>     No instance for (Num [a])
07:31:00 <lambdabot>       arising from the literal `0' at <interactive>:1:7
07:31:00 <lambdabot>     Possible fix: add an instance declaration for (Num [a])
07:31:18 <quicksilver> ^^ should that have type Num [a], Show [a] => String?
07:31:19 <Sizur> without fundeps all is happy, except i'll have to state the context for every join
07:31:22 <quicksilver> presumably not.
07:31:34 <quicksilver> Sizur: I suspected you wouldn't be able to use fundeps.
07:31:38 <Saizan_> quicksilver: no, because a don't appear in String
07:31:41 <quicksilver> Sizur: but I wasn't sure, and I wanted to see the result.
07:31:55 <quicksilver> Saizan_: is that the rule? all variables must occur? At least one must occur?
07:32:09 <quicksilver> Saizan_: is this in the online report?
07:32:33 <Saizan_> quicksilver: at least a superkey must occur afaiu, but i've not read this anywhere :)
07:33:03 <quicksilver> Saizan_: superkey according to fundeps, you mean?
07:33:09 <Saizan_> quicksilver: yes
07:33:15 <quicksilver> that certainly makes sense
07:33:28 <quicksilver> so without fundeps, it would be "all variables must occur"
07:33:45 <quicksilver> as soon as one variable goes out of scope, it must choose an instance, or complain if it can't.
07:34:28 <Saizan_> yes because an outer context can't give any additional information on that variable, i think
07:35:30 <Sizur> NeT a c, NeT b d etc
07:36:09 <quicksilver> "We say that an expression e has an ambiguous type if, in its type forall u. cx =>t, there is a type variable u in u that occurs in cx but not in t. Such types are invalid."
07:36:09 <Sizur> hmm, something to try out
07:36:30 <dozer> Saizan_ thanks - my app built and ran with profiling this time
07:36:39 <quicksilver> dozer: \o/
07:37:28 <BMeph> dozer: ^_^
07:38:46 <Sizur> quicksilver: why cannot we say a/=b in the context? cannot i simply introduce class NotEq a b?
07:38:57 <Sizur> should be enough for fundeps, no?
07:39:16 <quicksilver> you can
07:39:30 <quicksilver> I believe
07:40:26 <Sizur> can a class be used just as a marker? without any methods?
07:40:35 <nomeata> Igloo: just curious, not trying to be annyoing: anything new about the ghc6.6 packages?
07:42:45 <Saizan_> Sizur: yes
07:43:02 <ricky_clarkson> Sizur: Yes, but an interface is more usual for that.
07:43:04 <EvilTerran> Sizur, you leave off the where{}
07:43:08 <ricky_clarkson> See Serializable as an example.
07:43:14 <EvilTerran> or are you talking about java?
07:43:15 <ricky_clarkson> Sorry, wrong channel. ;)
07:43:25 <opqdonut> :D
07:44:25 <ricky_clarkson> > fix ("new Runnable(){public void run(){"++)
07:44:28 <lambdabot>  "new Runnable(){public void run(){new Runnable(){public void run(){new Runna...
07:45:01 <opqdonut> :D
07:57:49 <Sizur> quicksilver: nope, it does not work. NotEq a b is still the same as NotEq c d
07:59:43 <dozer> is there way in "Setup.lhs configure" to get it to pass --auto-all through?
07:59:52 <dozer> I'm not getting a very informative profiling out at the moment
08:11:12 <mdurr> ok I officially love / am addicted to haskell, do you have hotlines for this?
08:11:27 <Beelsebob> you're already in it
08:11:27 <Beelsebob> :)
08:14:04 <mdurr> turning frames of an MD2 model into io sequences with just a few maps is insane
08:15:05 <Beelsebob> :)
08:15:13 <matthew_-> right. are there people here who know how the ghc runtime for STM works?
08:15:42 <byorgey> mdurr: =D
08:16:29 <matthew_-> in particular, in a real parallel situation, can > 1 transaction be committed at the same time, or does the runtime serialise them all?
08:17:10 <quicksilver> mdurr: yeah. My model loading/drawing code in haskell is insanely easy.
08:17:21 <quicksilver> mdurr: Ok, it was only OBJ, and I'm drawing with renderPrimitive. But, even so.
08:17:43 <quicksilver> mdurr: it's like 1% the length of example C++ code I've seen doing the same job.
08:18:50 <Beelsebob> matthew-_: I believe that as long as you use -threaded to build the final product, it should be able to do it
08:19:33 <quicksilver> matthew_-: I think it permits true concurrency for transactions which do not conflict at all.
08:19:36 <quicksilver> however, I don't know.
08:19:46 <quicksilver> Which is the good STM paper? I should understand this more.
08:21:22 <matthew_-> I would be very interested it how it works out that two transactions cannot interfere with one another.
08:22:05 <matthew_-> s/d it h/d in h/
08:22:20 <Beelsebob> they can
08:22:22 <Beelsebob> that's the point
08:22:35 <Beelsebob> but if they do they go "oh shit", and try again
08:23:06 <Beelsebob> but I know only a very limited amount too
08:23:31 <sjanssen> @google simonpj composable memory transactions
08:23:32 <lambdabot> http://research.microsoft.com/~simonpj/papers/stm/stm.pdf
08:24:05 <matthew_-> Beelsebob: no, that's not the point
08:24:07 <sjanssen> quicksilver: I think this is the "good STM paper"
08:24:34 <matthew_-> that's the 2005 paper
08:25:45 <sjanssen> matthew_-: it says "Post-publication version: August 18, 2006" in big letters at the top ;)
08:25:53 <matthew_-> oh. ;)
08:26:12 <matthew_-> in which case the haskell wiki may need updating: http://www.haskell.org/~simonmar/papers/stm.pdf
08:26:22 <matthew_-> via http://www.haskell.org/haskellwiki/Research_papers/Parallelism_and_concurrency#Lock_free_data_structures_and_transactional_memory
08:26:23 <lambdabot> Title: Research papers/Parallelism and concurrency - HaskellWiki, http://tinyurl.com/yybhes
08:26:37 <quicksilver> sjanssen: thank you very much
08:28:04 <matthew_-> Beelsebob: it's easy enough to have each thread do work and record what they read in parallel, but when it comes to the point of committing, it's not always obvious that two commits can occur at the same time - you have to know in advance that they can't depend on the same shared state
08:29:19 <Beelsebob> matthew_-: true dat
08:29:50 <matthew_-> that paper talks about "concurrent haskell is currently only implemented for a uni-processor..."
08:29:56 <daf> hmm, is there an easy way to do [Maybe a] -> Maybe a, where the result is the first Just x in the list, or Nothing if there wasn't one?
08:30:02 <matthew_-> msum
08:30:46 <mrd> this is the paper on Opportunistic STM: http://portal.acm.org/citation.cfm?id=949343.949340
08:30:50 <lambdabot> Title: Language support for lightweight transactions
08:30:53 <mrd> Harris & Fraser
08:31:16 <daf> matthew_-: magic!
08:31:27 <matthew_-> daf: no, msum ;)
08:31:59 <daf> how is it the generalisation of concat?
08:32:11 <matthew_-> it's not.
08:32:15 <matthew_-> @type msum
08:32:17 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
08:32:40 <daf> “This generalizes the list-based concat function.”
08:32:45 <daf> (http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html#v%3Amsum)
08:32:46 <lambdabot> http://tinyurl.com/y25qsm
08:32:58 <matthew_-> ok, I've never thought of concat like that then
08:33:04 <mdurr> quicksilver: in 150 lines of code I parse an md2, turn it into io sequences for each frame so given a frame number it draws/textures/etc... just no interpolation between frames yet
08:33:05 <Toxaris> daf: msum for the list monad is concat
08:33:17 <mrd> @src [] msum
08:33:17 <lambdabot> Source not found. You untyped fool!
08:33:17 <Toxaris> > msum [[1, 2, 3], [], [4]]
08:33:19 <lambdabot>  [1,2,3,4]
08:33:25 <Toxaris> > concat [[1, 2, 3], [], [4]]
08:33:26 <lambdabot>  [1,2,3,4]
08:33:28 <quicksilver> mdurr: *nods*
08:33:29 <mrd> hey!!
08:33:35 <matthew_-> msum is foldr mplus right?
08:33:35 * mrd :: Fool
08:33:43 <mdurr> quicksilver: only downside is it took longer to write the haskell than the c... but I know c like the back of my hand
08:33:45 <mrd> not untyped!
08:33:50 <matthew_-> so mplus for list must be ++
08:33:58 <Toxaris> @src msum
08:33:58 <lambdabot> msum =  foldr mplus mzero
08:34:04 <mrd> @src [] mplus
08:34:05 <matthew_-> there we are then
08:34:05 <lambdabot> mplus = (++)
08:34:09 <sioraiocht> > msum [Just 1, Nothing]
08:34:09 <mrd> @src concat
08:34:09 <lambdabot> concat = foldr (++) []
08:34:10 <lambdabot>  Just 1
08:34:21 <sioraiocht> > msum []
08:34:22 <lambdabot>   add an instance declaration for (Show (m a))
08:34:26 <mrd> > Just 1 `mplus` Nothing
08:34:27 <lambdabot>  Just 1
08:34:41 <mrd> > msum [] :: [Int]
08:34:42 <lambdabot>  []
08:34:47 <Sizur> > Just 1 `mplus` Just 2
08:34:48 <lambdabot>  Just 1
08:34:57 <Toxaris> > Just 1 <|> Nothing -- I prefer <|> over `mplus`
08:34:58 <lambdabot>  Just 1
08:35:06 <Sizur> Nothing `mplus` Just 2
08:35:11 <mrd> @index (<|>)
08:35:12 <lambdabot> Text.ParserCombinators.Parsec.Prim, Text.ParserCombinators.Parsec
08:35:14 <Sizur> > Nothing `mplus` Just 2
08:35:15 <lambdabot>  Just 2
08:35:15 <quicksilver> msum and mconcat are both generalisations of concat
08:35:17 <daf> ah, so mplus and mzero have been explicitly defined for List and Maybe to do appropriate things?
08:35:21 <quicksilver> in slightly different directiosn
08:35:28 <quicksilver> and join is another generalisation
08:35:36 <Toxaris> daf: yes
08:35:37 <quicksilver> concat turns out to generalise in a bunch of different ways.
08:35:50 <daf> Toxaris: that makes more sense now
08:35:55 <quicksilver> [ [ a ] ] -> [ a ]
08:36:09 <quicksilver> ^ ^ two layers of [ here, and one on the RHS
08:36:18 <quicksilver> you can replace those three []s in various ways with m
08:36:45 <Toxaris> daf: that's the idea of type classes. The class defines the functions (for every MonadPlus m, there is a function mplus of type m a -> m a -> m a) and instances define sensible definitions for these functions (for lists, mplus should be (++))
08:37:15 <daf> Toxaris: I missed the MonadPlus bit
08:37:24 <daf> Toxaris: and thought for a second that it was somehow being derived (!)
08:38:41 <matthew_-> ah ha! 5.4.3 in that last paper: "Non-blocking commit"
08:38:51 <matthew_-> err, s/3/4/
08:39:18 <dozer> is the typeable stuff known to be dog slow?
08:39:52 <nelhage> If I have an enum data type and I want a bunch of metadata associated with each possibility, is there a common idiom? I could of course just write functions for each piece of data that pattern matches, but that seems verbose
08:42:15 <Sizur> i think i simply need a customized permutation function to permute just the types i'm joining on
08:42:15 <byorgey> nelhage: sounds like you want just a simple algebraic data type?
08:42:26 <byorgey> instead of data Enum = A | B | C
08:42:40 <byorgey> you have data Enum = A MetaData1 | B Foo Bar | C ... and so on?
08:44:11 <quicksilver> dozer: shouldn't be, I woudln't think. It's compile-time that the work is done at...
08:45:30 <nelhage> byorgey: What I want is data Enum = A | B | C, and then say, name :: Enum -> String where name A = "object A"; name B = "other object"; name C = "something"
08:45:51 <nelhage> I'm not sure how making it an actual ADT solves that
08:46:00 <byorgey> nelhage: oh, so the type of the metadata is always the same?
08:46:16 <nelhage> yes
08:46:23 <byorgey> and the metadata is constant for each enum value?
08:46:26 <nelhage> Correct
08:46:44 <byorgey> why does a function seem verbose?
08:46:49 <dozer> well, this code is eating 80% of my cpu time: http://hpaste.org/4543
08:46:53 <quicksilver> nelhage: opinions vary. I think name A = "object A"; name B = "object B" is fairly short and neat.
08:47:15 <quicksilver> nelhage: you could tryin instead: names = [(A,"object A"),(B,"object B")]
08:47:16 <byorgey> nelhage: the alternative would be to create a list of pairs, or a Map, and then do a lookup.
08:47:19 <quicksilver> if you prefer.
08:47:38 <matthew_-> or internationalize it and externalise the metadata
08:48:06 <quicksilver> dozer: that's Data not Typeable :P
08:48:20 <nelhage> Alright, thanks, guys.
08:48:23 <dozer> ah... so, is Data dog slow? P)
08:48:30 <quicksilver> dozer: it's possible that the tricks Data does inhibit certainly inlinings/optimisations that we're accustomed to?
08:48:38 <quicksilver> or, it's possible your profiling is confusing ou :)
08:48:41 <nelhage> I'm sadly coming from coding a large project in Java, so my mind is oddly warped right now, and it'll take me a while to get better.
08:48:44 <quicksilver> maybe the CPU time is actually reducing a big thunk.
08:48:58 <quicksilver> and it just gets attributed to findAll because that triggers the reduction.
08:49:01 <byorgey> nelhage: that's ok, Java is a common ailment.
08:49:28 <dozer> quicksilver: I have noticed that my app becomes slower each time I introduce a new call to findAll
08:49:47 <zx]treads> is it better to use list comprehensions where possible?
08:49:56 <zx]treads> http://hpaste.org/4544
08:49:59 <byorgey> zx]treads: better than what?
08:50:08 <byorgey> zx]treads: it's a matter of taste, mostly.
08:50:15 <zx]treads> hmm, ok
08:50:17 <quicksilver> zx]treads: if you find them more readable then yes.
08:50:28 <zx]treads> about performance?
08:50:29 <quicksilver> in that example, I would go with the list.comp
08:50:34 <quicksilver> looks more readable.
08:50:39 <quicksilver> They should compile to the same code.
08:50:47 <byorgey> heh, I was about to say I would go with the filter. =)
08:51:02 <byorgey> except I would write it as filter ((==i) . snd)
08:51:18 <zx]treads> mm, thanks
08:51:31 <Toxaris> nelhage: http://hpaste.org/4545
08:51:40 <byorgey> zx]treads: performance should be the same, I think.
08:51:45 <zx]treads> byorgey: i'll try that, and see how it looks like
08:52:46 <dons> ?yow
08:52:47 <lambdabot> Now I think I just reached the state of HYPERTENSION that comes JUST
08:52:47 <lambdabot> BEFORE you see the TOTAL at the SAFEWAY CHECKOUT COUNTER!
08:52:52 <dons> ?users
08:52:52 <lambdabot> Maximum users seen in #haskell: 415, currently: 413 (99.5%), active: 18 (4.4%)
08:53:10 <byorgey> morning dons =)
08:54:42 <dons> :)
08:58:29 <opqdonut> ?Src maximum
08:58:30 <lambdabot> Maybe you meant: rc src
08:58:34 <opqdonut> ?src maximum
08:58:34 <lambdabot> maximum [] = undefined
08:58:35 <lambdabot> maximum xs = foldl1 max xs
08:59:09 <opqdonut> strict version needed...
08:59:48 <dons> it actually does use a strict one if its given an Int or Integer
09:00:12 <dons> {-# RULES
09:00:12 <dons>   "maximumInt"     maximum = (strictMaximum :: [Int]     -> Int);
09:00:12 <dons>   "maximumInteger" maximum = (strictMaximum :: [Integer] -> Integer)
09:00:13 <dons>  #-}
09:00:17 <dons> poor man's type classes
09:00:35 <dons> strictMaximum []        =  errorEmptyList "maximum"
09:00:35 <dons> strictMaximum xs        =  foldl1' max xs
09:00:54 <dons> website languages are silly: "Disallowed Key Characters$Version"
09:01:05 <dons> says a major news site i just clicked on.
09:15:04 <opqdonut> dons: even from ghci?
09:16:00 <dons> ghci doesn't use rules
09:16:04 <dons> so nope, that won't happen
09:16:10 <quicksilver> well it does in compiled code
09:16:12 <quicksilver> to be pedantic :)
09:16:24 <quicksilver> so you can call the strict one "from" ghci
09:16:28 <quicksilver> as long as it's living in a compiled module.
09:16:57 <dons> well, if it got compiled in to some 3rd module, yeah
09:17:11 <dons> but a call to Data.List.maximum will yield the lazy one
09:18:13 <quicksilver> This is a sometimes-overlooked useful feature of ghci, though
09:18:23 <quicksilver> that except for the actual interpreted module you are currently inspecting
09:18:28 <quicksilver> it will use compiled code
09:18:40 <quicksilver> which is much better than many other repls for other =languages
09:18:44 <opqdonut> dons: yeah, thought so
09:18:59 <opqdonut> (solving project euler stuff in ghci)
09:19:57 <dozer> mm - the example for how to use {-# SCC "name" #-} in the profiling docs could do with a bit of an overhaul
09:20:02 <dozer> and perhaps an actual example
09:23:57 <dons> what are the top 5 libraries we need done for 2008?
09:24:26 <quicksilver> hs-plugins based on ghc-api?
09:24:29 <dons> my suggestions: bytestring-like arrays, bytestring http, bytestring xml, small pcre lib
09:24:32 <dons> quicksilver: we have that now!
09:24:35 <quicksilver> do we?
09:24:43 <dons> Cale sent me patches yesterday
09:24:44 <quicksilver> well that's great. One done already and it's still 2007.
09:24:47 <dons> they're in hs-plugins darcs repo.
09:25:04 <quicksilver> how abot : work, stable release of hs-plugins based on ghc-api?
09:25:05 <quicksilver> :)
09:25:30 <quicksilver> I detect a bytestring bias in your suggestions!
09:25:58 <quicksilver> I'd rather have a bytestring parsing lib, and bytestring xml just layered on that.
09:26:12 <BMeph> Gee, dons, you sure take that bystring stuff personally...;)
09:26:43 <shapr> dons: Yay! Lots of people I know want hs-plugins for 6.8.1!
09:28:23 <BMeph> shapr; Well, too bad. They'll have to settle for having it in 6.8.2. ;)
09:28:42 <quicksilver> dons: if bytestring arrays => fusible arrays, then that would be lovely.
09:28:59 <quicksilver> dons: and a richer array API with zero-copy 'subset' for various kinds of 'subset'
09:29:04 <quicksilver> slices/projections.
09:30:03 <dons> yeah, so i wsa just going to tear out the flat, fusible unlifted arrays from the ndp library
09:30:08 <BMeph> quicksilver: Ooh, slices! :)
09:30:29 <dons> the bytestring bias is because i think a lot of applications aren't feasible without bytestring support for scaling up to large data
09:30:51 <dons> so perhaps if i rephrase: what libs would we need for you to get your job done?
09:31:34 <dons> maybe i should run a poll to find out what we should be hacking on...
09:31:34 <doserj> *one* database lib :)
09:31:40 <dons> doserj: one more?
09:31:51 <dons> or you want to delete 24 of the current 25?
09:31:52 <peportier> Hi !
09:32:07 <byorgey> how about a working GOA?  or is that fixed with the new hs-plugins?
09:32:15 <byorgey> hi peportier!
09:32:24 <dons> would goa help get your job done?
09:33:00 <byorgey> for a suitably liberal interpretation of 'my job', yes =)
09:33:03 <peportier> With a type : data Target a = Invisible a | Visible a   ...
09:33:04 <Nafai> Remind me what goa does
09:33:09 * dons imagine #haskell-industry
09:33:14 <byorgey> Nafai: ghci + lambdabot
09:33:22 <Nafai> Yes, GOA would be nice
09:33:30 <Nafai> Integrated with an editor as well
09:33:33 <peportier> And another type : data Visible a = Cursor a | SimplyVisible a
09:33:39 <Nafai> To make a kick-but Haskell "IDE"
09:34:11 <peportier> I got an error when I try [ Invisible 1, Cursoro 2]
09:34:21 <peportier> I got an error when I try [ Invisible 1, Cursor 2]
09:34:30 <byorgey> peportier: hm, that's confusing having 'Visible' be both a data constructor for Target and the name of another data type.
09:34:45 <byorgey> peportier: maybe that's your confusion.
09:35:14 <doserj> [ Invisible 1, Visible (Cursor 2)]
09:35:31 <byorgey> Cursor 2 is of type Visible Int, whereas Invisible 1 is of type Target Int.
09:35:49 <peportier> Oh yes, it IS my confusion, thank you.
09:38:01 <peportier> And how would you model my problem : a Target could be an Invisible or a Visible which could be SimplyVisible or a Cursor ?
09:41:42 <daf> is there a simpler way to do filter (maybe False (const True))?
09:41:58 <Heffalump> filter isJust
09:42:09 <Igloo> catMaybes is probably what you want
09:42:20 <Heffalump> oh yeah
09:42:36 <BMeph> catMaybes FTW!
09:42:51 <Japsu> @type catMaybes
09:42:54 <lambdabot> forall a. [Maybe a] -> [a]
09:43:00 <daf> Igloo: that is exactly what I want
09:44:20 <dcoutts> dons: I recall that yesterday you were having some problem with Cabal-1.3.2, do you recall what that was?
09:44:42 <dcoutts> dons: I'd like to make sure I'm not breaking things in the 1.3.1, 1.3.2 updates
09:48:47 <scodil> I've got a function that allocates some read-only memory and initializes it. it takes as a parameter a function f, so that element i is initialized with value f i. I'd like to inline f into the body of this function, so constructor specialization can kick in, but to do that I have to inline the whole init function into its caller, which inlines the memory allocation, which is bad. is there any way around this?
09:49:52 <_andre> could anyone give me a hand with the insertProc function at http://hpaste.org/4546 ?
09:50:08 <_andre> i believe i need StateT here but i've never used it so i'm a bit lost
09:50:31 <loupgaroublond> out of curiosity, is there a haskell run time for older palmpilots?
09:50:35 <_andre> the idea is to build a map of process information
09:50:44 <_andre> unix processes, that is
09:51:53 <matthew_-> quicksilver: have you read the paper on STM yet?
09:52:10 <matthew_-> (the "Language Support for Lightweight Transactions" one)
09:54:19 <conal> dons: do you know that the hsplugins won't "darcs get" on Windows?  i don't know if there's any solution.  seems to be a problem of case: "plugins" vs "Plugins".
10:16:13 <BMeph> dons: So, what's the current repo address for plugins?
10:20:53 <gour> dons: i'd like to see some less of http://www.randomhacks.net/articles/2007/03/10/haskell-8-ways-to-report-errors sort
10:20:54 <lambdabot> Title: 8 ways to report errors in Haskell, http://tinyurl.com/2yz77l
10:25:24 <ddarius> :t let cofmap f = (. f); unit = flip id in cofmap unit
10:25:26 <lambdabot> forall a c c1. (((a -> c) -> c) -> c1) -> a -> c1
10:25:30 <monochrom> haskell-cafe has so much traffic, I may want to open another email account just for it! XD
10:26:28 <ddarius> @. djinn type let cofmap f = (. f); unit = flip id in cofmap unit
10:26:29 <lambdabot> f a b = a (\ c -> c b)
10:26:51 <ddarius> @src Cont (>>=)
10:26:52 <lambdabot> m >>= k  = Cont $ \c -> runCont m $ \a -> runCont (k a) c
10:29:26 <sllls> When a line runs to long, what do I do?
10:30:00 <conal> @tell dons do you know that the hsplugins won't "darcs get" on Windows?  i don't know if there's any solution.  seems to be a problem of case: "plugins" vs "Plugins".
10:30:00 <lambdabot> Consider it noted.
10:32:39 <sllls> How do I have one line of code span two lines in the .hs file?
10:33:49 <ddarius> :t let cofmap f = (. f) in cofmap . cofmap
10:33:51 <lambdabot> forall c a b c1. (a -> b) -> ((a -> c1) -> c) -> (b -> c1) -> c
10:37:25 <Saizan_> sllls: just indent the second line more
10:38:51 <Heffalump> conal: do you know what patch causes the problem?
10:39:50 <conal> Heffalump: around 210.  just a minute ...
10:40:46 <conal> Heffalump: do you know what the latest patch is, or how to find out?
10:41:33 <conal> Heffalump: hm.  209 is the latest.
10:41:47 <conal> Heffalump: i'm running a fresh darcs get to see what happens this time.
10:42:24 <conal> the message i got was:
10:42:24 <conal> "realdarcs.exe: ./src/plugins:renameFile: inappropriate type (is a directory)"
10:45:42 <conal> Heffalump: odd.  this time it darcs-getted with no problem.
10:46:19 <conal> @tell dons never mind about the darcs-get problem with hs-plugins & windows.  went away.
10:46:19 <lambdabot> Consider it noted.
10:52:53 <BMeph> Heffalump: You might want to leave another note - I see it saying it builds plugins-1.0, not -1.1 as I saw yesterday. :(
10:54:27 <BMeph> Heffalump: Never mind, I pulled it into another directory. :p
10:57:29 <conal> anyone tried hs-plugins on windows?  i get: c:/ghc/ghc-6.8.1.20071102/lib\base-3.0.0.0/HSbase-3.0.0.0.o: unknown symbol `_WaitForSingleObject'
11:08:01 <dcoutts> @seen bringert
11:08:02 <lambdabot> bringert is in #ghc and #haskell. I don't know when bringert last spoke.
11:11:28 <bench```> can someone explain the error in http://hpaste.org/4548?
11:11:40 <andyjgill> Has anyone here built wxhaskell for osx?
11:12:57 <bench````>  can someone explain the error in http://hpaste.org/4548?     [11:11]
11:12:57 <bench````>  
11:13:20 <dcoutts> andyjgill: did you know that it's possible to build gtl+ and gtk2hs for osx now without using X11 ? :-)
11:13:52 <andyjgill> I heard so.
11:14:10 <andyjgill> But I'm wanting the OpenGL bindings.
11:14:14 <byorgey> @type break
11:14:16 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
11:14:24 <dcoutts> andyjgill: I use gtk2hs with OpenGL all the time
11:14:26 <Toxaris> bench: w :: [Char], but [s] :: [[Char]]
11:14:49 <andyjgill> Are u on a mac?
11:14:55 <Toxaris> bench: maybe you want w : [s] : w1 : dotsplit ...
11:15:01 <dcoutts> andyjgill: no, too expensive :-)
11:15:09 <Toxaris> bench: or some other combination of : and ++ :)
11:15:17 <bench````> toxaris, s = head s2, so i'm thinking that it's a char rather that [[char]]
11:15:31 <byorgey> bench````: hmm, what's the precedence of ++/: ?
11:15:34 <andyjgill> I'm not so bothered by X11, though
11:15:52 <byorgey> bench````: try putting parens around (w ++ [s] ++ w1)
11:15:53 <dcoutts> andyjgill: well that makes it even easier then
11:16:19 <Toxaris> > "a" ++ "b" ++ "c" : ["test"]
11:16:21 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
11:16:25 <Toxaris> > ("a" ++ "b" ++ "c") : ["test"]
11:16:26 <lambdabot>  ["abc","test"]
11:16:27 <bench````> byorgey, that did it, thanks!!
11:16:33 <byorgey> bench````: sure =)
11:17:04 <Toxaris> > ("prefix" : 'x' ++ "postfix") : ["rest"]
11:17:04 <lambdabot>  Couldn't match expected type `[[Char]]'
11:17:13 <Toxaris> > ("prefix" ++ 'x' : "postfix") : ["rest"]
11:17:14 <lambdabot>  ["prefixxpostfix","rest"]
11:17:57 <dcoutts> andyjgill: so gtk2hs includes an OpenGL drawing widget which you can use with the standard Haskell OpenGL package
11:18:35 <andyjgill> Okay. I'll have a look at it.
11:18:41 <dcoutts> andyjgill: so gtk2hs basically takes the place of GLUT
11:18:50 <dcoutts> see the gtk2hs opengl demos
11:19:06 <andyjgill> And I see that macports supports it.
11:19:21 <bench````> byorgey, the code doesn't quite work right, it seems that it only works with the first splitSysmbol
11:19:33 <bench````>  dotsplit dotsplitSymbol "12,600, 4.4. abc, 3.4, 12,600 ,b"
11:19:43 <bench````> ["12,600"," 4.4"," abc"," 3","4"," 12","600 ","b"]
11:20:01 <bench````> where splitSymbol is just an equality test of either '.' or ','
11:20:09 <dcoutts> andyjgill: the annoying thing about macports is that it wants to manage ghc itself, I recommend using macports to install gtk+ but not gtk2hs, so you can use the macport gt+ and the native (non-macport) ghc and then build gtk2hs from source
11:20:37 <bench````> am i doing it wrong with the recursion?
11:20:43 <dcoutts> andyjgill: the latter is easy just: ./configure && make && sudo make install
11:20:48 <andyjgill> ^C....
11:21:13 <byorgey> bench````: I don't know.  I would suggest breaking your function up into smaller pieces.  that way you can interactively try out the individual pieces and make sure they are doing what you expect.
11:21:52 <byorgey> bench````: IMO, any Haskell function longer than 3-5 lines is too long.
11:22:03 <byorgey> bench````: of course there are exceptions, but hopefully you get the idea =)
11:22:50 <b_jonas> byorgey: even if it's a let statement with lots of small helper functions in its body?
11:22:52 <EvilTerran> @paste
11:22:52 <lambdabot> Haskell pastebin: http://hpaste.org/new
11:22:58 <bench````> byorgey, ok, this essentially models the haskell words funciton
11:23:18 <byorgey> b_jonas: *especially* in that case!
11:23:27 <byorgey> b_jonas: you can't test helper functions which are inside a let.
11:23:36 <b_jonas> byorgey: yeah, that's true
11:24:16 <EvilTerran> @seen hpaste
11:24:17 <lambdabot> I haven't seen hpaste.
11:24:44 <EvilTerran> hm. i've got this ugly little parsec parser, and was wondering if there were a better way of presenting it: http://hpaste.org/4549
11:24:46 <doserj> bench```: probably you want to call dotsplit in the else-part, too?
11:25:22 <bench````> doserj, yes, thanks
11:27:05 <byorgey> EvilTerran: can't you do something with 'many'?
11:27:17 <EvilTerran> hm, that's a thought
11:27:44 <byorgey> hm, except you want to discard the comments, so you can't just do many (lexComment <|> lexToken)
11:28:09 <EvilTerran> many (many (spaces <|> lexComment) >> lexToken) --?
11:28:22 <bench````> what's the haskell way of doing oneOf(".,|?"), i want to break a sentence based on those separators
11:28:35 <Toxaris> > last "123" -- instead of (head $ reverse "123"), bench
11:28:36 <byorgey> EvilTerran: that might work
11:28:37 <bench````> do i have to do many (==) tests?
11:28:38 <lambdabot>  '3'
11:28:46 <EvilTerran> @src elem
11:28:47 <lambdabot> elem x    =  any (== x)
11:28:50 <byorgey> bench````: use 'elem'
11:28:58 * EvilTerran tries that
11:29:04 <byorgey> > '3' `elem` ".,|?"
11:29:05 <lambdabot>  False
11:29:08 <byorgey> > ',' `elem` ".,|?"
11:29:09 <lambdabot>  True
11:29:12 <Toxaris> > map (`elem` ".,|?") "123.|?a"
11:29:12 <bench````> byorgey, thanks
11:29:12 <lambdabot>  [False,False,False,True,True,True,False]
11:29:18 <bench````> Toxaris, thanks
11:30:40 <ptolomy> @pl  zipWith (-) acc (scanl1 min acc)
11:30:41 <lambdabot> zipWith (-) acc (scanl1 min acc)
11:31:03 <EvilTerran> "*** Exception: Text.ParserCombinators.Parsec.Prim.many: combinator 'many' is applied to a parser that accepts an empty string."
11:31:21 <EvilTerran> heh
11:33:07 <byorgey> haha, oops =)
11:33:25 <byorgey> hm, nice that it detects that though.
11:33:31 <Toxaris> EvilTerran: maybe you have to change spaces from something like (many (char ' ')) to (many1 (char ' '))?
11:33:57 <EvilTerran> spaces is predefined as (many space); i'm trying (many1 space) now
11:34:02 <EvilTerran> hm, close
11:37:46 <EvilTerran> the problem now is the (many $ many1 space <|> lexComment) is matching at EOF, then the lexToken is failing
11:38:31 <Toxaris> EvilTerran: what about (many (space <|> lexComment))?
11:38:45 <Toxaris> EvilTerran: no need to nest many's
11:39:17 <EvilTerran> space doesn't return a (), so it'd have to be (many $ (space >> return ()) <|> lexComment)
11:39:23 <bobowski> > [1..4]
11:39:25 <lambdabot>  [1,2,3,4]
11:39:28 <EvilTerran> which is a mote tedious
11:40:12 <Toxaris> EvilTerran: skipMany (space <|> lexComment)
11:40:53 <EvilTerran> the types of both sides of <|> have to be the same!
11:40:59 <Toxaris> EvilTerran: hmm ok doesn't help :(
11:41:13 <byorgey> EvilTerran: isn't there a way to match "not eof"?
11:41:13 <EvilTerran>  skipMany ((space >> return ()) <|> lexComment)
11:41:25 <EvilTerran> there's notFollowedBy eof
11:42:10 <byorgey> EvilTerran: in the end, I don't know if this is going to end up being more readable than what you already had =)
11:42:24 <Toxaris> sure it is. "do" in parsers is ugly
11:42:26 <EvilTerran> i'm looking at endBy now
11:42:39 <EvilTerran> Toxaris, there we disagree. i think it's great, where appropriate
11:43:09 <Toxaris> EvilTerran: ok, "do" in parsers is ugly where used to express many by manual recursion
11:43:20 <EvilTerran> yeah
11:43:24 <EvilTerran> ah, there we go
11:43:36 <EvilTerran> lexer' = junk >> (lexToken `endBy` junk) where
11:43:36 <EvilTerran>     junk = skipMany ((space >> return ()) <|> lexComment)
11:44:17 <EvilTerran> the trick is in endBy, as that can have the separator work and the element fail without failing
11:44:22 <byorgey> EvilTerran: nice.  hm, and isn't there something like 'sepBy' so you could just say 'sepBy junk lexToken'?
11:44:31 <byorgey> I am handwaving here but I think something like that exists =)
11:45:01 <EvilTerran> there is sepBy, but (junk `sepBy` lexToken) would give back the results of the junks, not the lexTokens
11:45:37 <byorgey> ok, so I got the order of arguments wrong.
11:45:41 <EvilTerran> and (lexToken `sepBy` junk) has the same problem as the (many) version; junk matches at EOF, then lexToken fails
11:45:54 <Toxaris> there is sepEndBy
11:45:54 <byorgey> ah, ok.
11:46:02 <EvilTerran> and i'd still need the leading junk
11:46:18 <Toxaris> wich may help or not :)
11:46:20 <EvilTerran> Toxaris, yeah, that's only if you need a different end parser than the separator parser
11:46:38 <Toxaris> :t sepEndBy
11:46:39 <lambdabot> Not in scope: `sepEndBy'
11:47:05 <byorgey> well, junk >> (lexToken `endBy` junk) is still quite readable
11:47:45 <Toxaris> EvilTerran: not true. sepEndBy :: GenParser tok st a -> GenParser tok st sep -> GenParser tok st [a]
11:47:49 <EvilTerran> hm
11:48:00 <EvilTerran> "(endBy p sep) parses zero or more occurrences of p, seperated and ended by sep. Returns a list of values returned by p.
11:48:01 <Toxaris> EvilTerran: http://haskell.org/ghc/docs/latest/html/libraries/parsec/src/Text-ParserCombinators-Parsec-Combinator.html#sepEndBy
11:48:02 <lambdabot> http://tinyurl.com/yw73jf
11:48:07 <EvilTerran> (sepEndBy p sep) parses zero or more occurrences of p, separated and optionally ended by sep, ie. haskell style statements. Returns a list of values returned by p."
11:48:21 <EvilTerran> ah, *optionally* ended. that's how sepBy and sepEndBy differ.
11:48:53 <Toxaris> hmm ok but that doesnt matter for you, I assume, since junk can be the empty string anyway
11:48:57 <EvilTerran> Toxaris, http://legacy.cs.uu.nl/daan/download/parsec/parsec.html is rather more useful, and I've had it open for a while
11:49:04 <EvilTerran> I just mis-remembered the purpose of sepEndBy
11:49:12 <nomeata> lambdabot: hi there. anything new?
11:49:12 <EvilTerran> yeah, exactly. i'll stick with endBy; terser. :P
11:49:48 <Toxaris> EvilTerran: your lexer will eat the eof. how can you check that you lexed the whole input file?
11:50:00 <vininim> > "Nothing much, just chilling"
11:50:04 <lambdabot>  "Nothing much, just chilling"
11:50:10 <vininim> :)
11:50:19 <byorgey> wait, so sepBy means it *must* be ended by sep, but sepEndBy means it *may* be?
11:50:27 <byorgey> weird naming convention... =P
11:50:28 <EvilTerran> endBy means it *must* be ended
11:50:35 <EvilTerran> sepBy means it *must not* be ended
11:50:42 <EvilTerran> sepEndBy allows either
11:50:43 <byorgey> oh, endBy
11:50:46 * byorgey misread
11:51:23 <Toxaris> what can I do to integrate parsec documentation with parsec source as shown by hoogle?
11:51:39 <Toxaris> darcs get parsec, integrate documentation, send a patch to someone?
11:51:46 <EvilTerran> Toxaris, i'm not sure how i can be confident that it's parsing the whole file, actually...
11:51:52 <EvilTerran> i think it must, but i'm not sure why
11:52:08 <Toxaris> EvilTerran: normally, you do parseFile = parseIt *> eof
11:52:21 <Toxaris> or <* or >> or whatever ...
11:52:39 <EvilTerran> oh, are Parsec parsers instances of Applicative in the parsec with ghc 6.8? they weren't in 6.6
11:52:53 <Toxaris> instance Applicative Parsec ... is easy enough to write
11:52:54 <mauke> easy to define the instance yourself
11:52:58 <EvilTerran> meh
11:53:04 * EvilTerran tends to use liftM2 const
11:53:05 <byorgey> pure = return; <*> = ap
11:53:10 <EvilTerran> or do notation
11:53:23 <mauke> <* is too useful not to have
11:53:44 <EvilTerran> lexer' = between junk eof (lexToken `endBy` junk) -- ta-dah!
11:54:12 <byorgey> \o/
11:54:18 <Toxaris> EvilTerran: this works?
11:54:19 <mauke> is that junk *> many (lexToken <* junk) <* eof ?
11:54:29 <EvilTerran> indeed, on both counts (i think)
11:54:44 <Toxaris> mauke: with Control.Applicative.many ? ;)
11:55:07 <mauke> unlikely
11:55:46 <EvilTerran> ah, that might explain the lack of Applicative instance. there is a bit of an overlap of function names
11:56:12 <EvilTerran> well, <|> and many
11:57:05 * EvilTerran wonders if the two <|>s could be made the same
11:58:29 * EvilTerran wanders off
12:00:07 <Toxaris> EvilTerran: sure they can. instance Alternative Parser where <|> = Parsec.<|>
12:00:59 <Toxaris> maybe  instance Alternative Parser where a <|> b = try a Parsec.<|> b   if you care about Alternative laws
12:21:53 <zerny> Hello, I just compiled and installed the new GHC and seem to not have the libraries included... The parsec lib is not part of the release I have installed. What could I be missing?
12:22:44 <zerny> This is the first time I have installed ghc from source. Usually I use apt-get.
12:23:16 <Zao> zerny: Did you build with the extralibs tarball as well?
12:24:01 <zerny> I don't think so.
12:24:31 <zerny> >Zao: that would explain the missing extralibs :)
12:24:50 <zerny> Would I need to recompile ghc?
12:25:51 <Saizan_> no
12:26:28 <Saizan_> they are normal cabal packages
12:26:46 <zerny> Saizan_: Great. I found the extralibs. seems the mirror I downloaded 6.8.2 from did not have them, but it is there on the main download page.
12:27:10 <zerny> sorry for the obvious mistake
12:27:19 <opqdonut> ?src sum
12:27:20 <lambdabot> sum = foldl (+) 0
12:27:53 <zerny> Saizan_: I am fairly new to haskell so I would need to look in to how the cabal system works. Thanks.
12:29:39 * BMeph waits for EvilTerran to return, so he can make a "join" ambush...
12:31:40 <zerny> Any shortcut to build and install all the packages in the tar in one go. Or must the configure/build/install be run on each in turn?
12:31:40 <byorgey> BMeph: what is a "join" ambush?
12:33:22 <byorgey> zerny: I think if you don't build them at the same time as ghc itself, you have to build/install each package separately.
12:34:21 <BMeph> ET went to see about making the Parser <|> opeerator act like Applicative's <|>.
12:34:26 <zerny> byorgey: ok. will do. Parsec is running again. Thank you very much for your help.
12:34:43 <BMeph> I want to see if he'll so the same with all the different uses of "join" as a function... ;)
12:35:12 <byorgey> BMeph: hm? what different uses of "join"?
12:36:48 <BMeph> join in the Functor sense, join in the set theory sense, join in the DB sense (or is that also set theory, by way of tuples...)
12:37:04 <byorgey> oh, I see =)
12:39:18 <Itkovian> FYI, http://osteele.com/blog/
12:39:20 <lambdabot> Title: Oliver Steele
12:39:57 <BMeph> I think Sizur was trying the tuple-collapse form of join earlier today
12:40:33 <Toxaris> YAMBE - yet another monad blog entry
12:43:58 <BMeph> Hmm, I wonder...is there a lambdacat picture about the high number of monad tutorial articles?
12:45:41 <olsner> "I can has monad tutorial?"
12:46:03 <olsner> "I can has monads"
12:49:00 <pjd> "i can has nuclear spacesuit"?
12:49:41 <tetha> pjd: "i can has monad to wrap side effects of nuclear spacesuit"
12:54:01 <geezusfreeek> i am pretty sure that join in the relational sense is the same as in the set theory sense
12:54:13 <geezusfreeek> or at least catesian product is
12:54:18 <geezusfreeek> *cartesian
12:54:38 <tetha> for a natural join, this is correct
12:54:55 <pjd> geezusfreeek: there is the somewhat non-trivial chasm between relational theory and relational practice
12:57:59 <geezusfreeek> sure
12:59:24 <tetha> hehe, a good friend of mine uses relational algebra to optimize and document queries in a compiler
13:09:03 <Winterstream> Suppose that one is interested in creating a D-Bus library for Haskell. Then one would need some introspection. Is Template Haskell the only way to do this?
13:09:46 <dons> you'd probably use an exiting one first
13:10:02 <dons> 'existing'
13:10:08 <dons> but what kind of introspection do you require?
13:10:19 <dons> (i'd avoid TH if at all possible)
13:10:57 <Winterstream> Actually, I didn't realize that there is a Haskell Lib. It's not on the D-Bus page :/
13:11:24 <Winterstream> This is cool though
13:11:48 <oerjan> @where hackage
13:11:49 <lambdabot> http://hackage.haskell.org/
13:11:52 <sjanssen> Winterstream: why does it need introspection?
13:12:43 <dons> http://neugierig.org/software/hdbus/doc/ ?
13:12:47 <Winterstream> You don't want to have to specify your D-Bus input/output types explicitly if it's not necessary
13:12:49 <dons> (needs to be uploaded to hackage)
13:12:51 <Winterstream> dons - aye
13:13:02 <dons> Winterstream: hm? no input/output types?
13:13:27 <dons> because dbus messages are untyped?
13:13:42 <Winterstream> No
13:13:45 <Winterstream> They are typed
13:13:49 <dcoutts> there's also a dbus lib by kolmodin
13:13:59 <dons> yeah, i thought kolmodin had done one.
13:14:26 <dcoutts> @tell kolmodin upload your dbus binding! :-)
13:14:26 <lambdabot> Consider it noted.
13:14:45 <dcoutts> dbus has quite a nice little type system
13:15:46 <dcoutts> it's natural to want to do typed conversions between haskell records and serialised dbus messages
13:16:29 <dons> oh, good.
13:16:32 <dons> better than json then
13:17:00 <dcoutts> dons: did you find some problem with the Cabal lib 1.3.2 ?
13:17:18 <dcoutts> you mentioned it in passing yesterday I recall
13:17:20 <dons> dcoutts: only that the api is a little changed in the parts hs-plugins uses
13:17:23 <dons> that's fine though.
13:17:36 <dons> and my old cabal-setup failed
13:17:42 <dons> and had to be rebuilt against the new cabal
13:17:47 <dcoutts> dons: which bit? I'd like to keep most packages building with the 1.3 series
13:17:51 <dons> otherwise, a lot of cabal-install tests worked.
13:17:55 <dons> to do with PackageInfo
13:18:42 <dcoutts> dons: you want to make sure hs-plugins builds with cabal-1.2.x, if it's not possible to make it build with both 1.2 and 1.3 then I'll change 1.3 to make it work
13:19:06 <dons> what do people think of:
13:19:09 <dcoutts> dons: I'm also just merging cabal-setup and cabal-upload into cabal-install
13:19:10 <dons>   always = flip finally
13:19:13 <dons> as in:
13:19:19 <dons>   always (hClose h) $ do ....
13:19:32 <dons> dcoutts: yep.
13:19:44 <dcoutts> having the last arg be the action is usually nicer
13:19:50 <dcoutts> for exactly that syntax
13:20:03 <dons> what's a better name for flip finally ?
13:20:10 <dons> main = do
13:20:10 <dons>     system "find /usr/src -type f > files_to_read"
13:20:10 <dons>     always (removEfile "files_to_read") $ do
13:20:10 <dons>         fs <- lines <$> readFile "files_to_read"
13:20:11 <dons> ...
13:20:43 <Toxaris>   before (hClose h) $ do <something else>
13:20:51 <dons> before? oh hmm.
13:20:57 <dons> so we have: catch / handle
13:21:00 <dcoutts> dons: ask for suggestions on the libraries list
13:21:02 <dons>  and : forM /mapM
13:21:11 <dons> then :  x `finally` y
13:21:24 <dons> so maybe:  y `after` x ?
13:21:29 <dcoutts> before sounds too much like sequencing
13:21:37 <dons> though i like 'always' for its strength
13:21:43 <dons> pretty clear you always want to run this
13:22:02 <Toxaris> but always sounds like multiple times
13:22:15 <dons> like 'forever' ?
13:22:26 <dons> definitely (remove f) $ do ..
13:22:28 <dons> :)
13:22:32 <Toxaris> inAnyCase
13:22:38 <dons> besureto (remove f) $ do.
13:22:48 <dons> noMatterWhat
13:23:01 <dons> doOrDie
13:24:56 <Botje> dontForgetTo
13:26:02 <jimstutt> keep / keepOn
13:27:57 <doserj> withFinally
13:28:31 <scodil> besureto (drink your) $ ovaltine
13:29:34 <Toxaris> invariably (close all file handles) $ read a lot of information
13:30:29 <Toxaris> steady
13:31:09 <Toxaris> anyway
13:31:49 <jsnx> lolz
13:38:31 <dons> dcoutts: wow, mmapFile is a really nice complement to lazy IO :)
13:38:47 <dons> strict mmap a 1G file, but only touch 1 char every 100M, and you'll use only 10 pages on the heap :)
13:38:54 <dcoutts> nice
13:39:08 <dons> all the laziness is pushed into the vm system
13:39:17 <dcoutts> dons: we should have that in the bytestring package really, if we can work out the package deps
13:39:26 <olsner> mmap is lazily evaluated I/O for C :)
13:39:27 <dons> yeah, we have win32 and posix bindings now
13:39:54 <dons> so we could work out a way to make it compile
13:40:31 <dcoutts> dons: though I'm still in two minds about the ForeignPtr stuff, there are lots of performance advantages for small strings if we forgo ForeignPtrs but that would mean no mmap + munmap finaliser
13:45:08 * dons mmaps a 1G file and watches it load lazily
14:19:36 <scodil> i've got an array, and i'm going to mutate it and then compute a value, but afterwards i'm going to undo those mutations and restore the original array. What's a good way to do this in a pure / non-IO monad way?
14:21:53 <oerjan> :t Data.Array.MArray.thaw
14:21:56 <lambdabot> forall (a :: * -> * -> *) i e (m :: * -> *) (b :: * -> * -> *). (Data.Array.Base.MArray b e m, Data.Array.Base.IArray a e, Ix i) => a i e -> m (b i e)
14:22:12 <mauke> STArray
14:22:41 <oerjan> :t Data.Array.ST.runSTArray
14:22:42 <lambdabot> forall i e. (Ix i) => (forall s. GHC.ST.ST s (GHC.Arr.STArray s i e)) -> Array i e
14:23:25 <oerjan> the thaw function makes a mutable copy of an immutable array
14:25:30 <oerjan> after using that, you can mutate the result all you want (in the ST monad say), and the original is still around.
14:25:42 <scodil> ok sure but that's just making a copy
14:26:01 <oerjan> which _is_ the safest way
14:26:26 <oerjan> if you don't have a copy, you need to keep track of all the changes to undo them...
14:26:31 <scodil> yeah
14:26:33 <scodil> that's the goal
14:26:44 <scodil> they're easy to keep track of
14:26:58 <scodil> there's one operation and it is its own inverse
14:27:07 <oerjan> put them in a stack
14:27:10 <oerjan> i.e. a list
14:27:26 <scodil> right. how do I avoid carrying that around? StateT?
14:27:47 <oerjan> yep
14:28:15 <oerjan> actually even Writer could do
14:28:23 <vininim> mmm anyone has experience in using waf with ghc
14:28:26 <vininim> ?
14:28:36 <scodil> so then, since I have an explicit state, the stack, I don't really need the phantom s parameter in ST s, do i?
14:28:52 <scodil> since I'm going to be safely abusing arrays anyway
14:28:55 <oerjan> scodil: you still need a mutable array
14:29:08 <oerjan> and you need either ST or IO for that
14:29:13 <scodil> right, but it may as well be with unsafePerformIO
14:29:34 <mauke> which is basically what ST is
14:29:48 <scodil> yeah i always have trouble with that little s
14:30:02 <mauke> just leave it alone :-)
14:30:10 <scodil> it won't leave me alone
14:30:17 <mauke> NO USER SERVICEABLE PARTS INSIDE
14:30:25 <scodil> "nicht! verboten!" he always tells me
14:30:41 <mauke> yeah, the s makes sure you do things in a safe way
14:30:43 <Japsu> UND WATSCHEN DER BLINKENLICHTEN
14:30:51 <mauke> this requires you do carry the s through all types involved
14:31:04 <mauke> s/do/to/, I think
14:33:31 <njbartlett> @seen Heffalump
14:33:31 <lambdabot> Heffalump is in #haskell and #darcs. I last heard Heffalump speak 3h 54m 40s ago.
14:34:22 <BMeph> @seen Cale
14:34:23 <lambdabot> Cale is in #haskell-overflow, #haskell and #ghc. I last heard Cale speak 11h 39m 32s ago.
14:34:41 <nelhage> Are there any recommended haskell RPC libraries?
14:34:56 <BMeph> Cale: Thanks for the awesome work on hs-plugins! Cale++ :)
14:35:12 <Cale> hi
14:35:15 <Cale> :)
14:35:29 <Cale> No problem. I wanted my lambdabot back :)
14:37:26 <Cale> BMeph: If you know anything about the GHC API, it would be cool if you had a look. I've been feeling somewhat insecure about the way I made the changes, which was basically to replace calls to the Language.Hi stuff to calls into the GHC API and then try to fix the type errors. :)
14:38:03 <Cale> Not a whole lot of thought went into how it actually works :)
14:38:53 <byorgey> Cale: but, if there aren't any type errors, then it must work!
14:38:58 <Cale> hehe
14:39:04 <Cale> Well, that appears to be the case!
14:39:24 <Cale> But there's probably some things which could be handled more elegantly.
14:39:46 <Cale> I'm guessing much more elegantly, since hs-plugins has lots of loading code which I'm sure GHC also has.
14:40:01 <byorgey> probably.
14:41:01 <vininim> > (join.flip replicate "yay") <$> [1..]
14:41:04 <lambdabot>  ["yay","yayyay","yayyayyay","yayyayyayyay","yayyayyayyayyay","yayyayyayyayya...
14:41:54 <vininim> (join . flip replicate "yay") <$> [1..] -- Space around operators please
14:42:11 <mauke> > iterate ("yay" ++) ""
14:42:12 <lambdabot>  ["","yay","yayyay","yayyayyay","yayyayyayyay","yayyayyayyayyay","yayyayyayya...
14:43:00 <dcoutts> @seen bringert
14:43:01 <lambdabot> bringert is in #ghc and #haskell. I don't know when bringert last spoke.
14:43:16 * dcoutts merges cabal-setup & cabal-upload into cabal-install...
14:43:21 <dons> yay!
14:43:28 <dcoutts> and in the darkness bind them
14:43:37 <dcoutts> one cabal tool to rule them all
14:45:33 <nominolo> heh
14:46:45 <dons> nominolo: btw, is your bytestring http repo around somewhere?
14:46:46 <nominolo> yep
14:46:46 <dons> url? :)
14:46:46 <dons> i'm keen to get a standard bytestring-http lib out soon
14:46:46 <nominolo> http://www.dtek.chalmers.se/~tox/darcs/http/
14:46:46 <lambdabot> Title: Index of /~tox/darcs/http
14:46:46 <nominolo> that's the lazy one
14:46:46 <dons> lazy bytestrings?
14:47:00 <nominolo> yep
14:47:02 <dons> is it finished? :)
14:47:06 <nominolo> http://www.dtek.chalmers.se/~tox/darcs/http-strict/ <-- strict
14:47:07 <lambdabot> Title: Index of /~tox/darcs/http-strict
14:47:08 <nominolo> not at all
14:47:13 <dons> ok cool.
14:47:16 <nominolo> the interface is the major problem
14:47:21 <dons> ok.
14:47:40 <dons> i'd love to see say, mmapFile pass chunks through to the network without copying
14:47:59 <nominolo> e.g. fold over chunks, getContents,-style or withFoo-style
14:48:22 <dons> mm
14:48:24 <nominolo> I lean towards the fold
14:48:38 <nominolo> if you want getContents-style you need to back it with a file
14:48:46 <nominolo> which could be done on top, i think
14:48:59 <dons> mm
14:49:03 <nominolo> btw, i still haven't heard back from Galois
14:49:13 <nominolo> but I'll be gone for 3 weeks now
14:49:13 <ddarius> @google Oleg left fold enumerator
14:49:14 <lambdabot> http://okmij.org/ftp/Haskell/fold-stream.lhs
14:49:47 <dons> nominolo: we won't be hiring till next year, afaik. and we've definitely received the application, however.
14:50:21 <nominolo> iow: be patient? :)
14:50:54 <dons> i think so :) nothing much happens in the end of dec.
14:51:15 <ddarius> dons says from long experience
14:51:28 <dons> well, its a good time to do open source
14:52:00 <nominolo> except i'll leave my computer for 2 weeks
14:52:10 <cached> how difficult a transition is it from C-type languages to Haskell?
14:52:45 <dons> cached: C at least has a type system, and is interoperable with Haskell.
14:52:59 <ddarius> cached: Depends on your background.
14:53:10 <dons> however, you have to get used to using higher order functions instead of for/while, and no more mutable, global memory
14:53:12 <nominolo> cached: into non-ideomatic haskell is rather easy
14:53:19 <dcoutts> cached: it depends on how well you can adapt the way you think about solving problems, some people find it difficult to think in any way other than C style imperative
14:53:53 <cached> i'm always up for a thought puzzle, you think haskell will offer that?
14:54:01 <ddarius> Definitely.
14:54:07 <ddarius> One way or another.
14:54:10 <dcoutts> cached: that's not because C style imperative is an easier way of thinking, it's not! it's just that some people cannot change they way they have learned to think about things
14:55:12 <cached> are there any classic programs I should attempt to get myself familiar with Haskell (ie. with C a fibonacci/hannoi program is a good intro to recursion, etc)
14:56:15 <ddarius> If you get to where you understand every version of the factorial function presented here, you'll be in a good position: http://www.willamette.edu/~fruehr/haskell/evolution.html
14:56:16 <lambdabot> Title: The Evolution of a Haskell Programmer
14:56:24 <mauke> hah
14:56:31 <bparkis> well I took my algorithms final today and I did well
14:56:38 <bparkis> but there was one problem that I could not get completely
14:56:40 * byorgey high-fives bparkis
14:56:56 <Saizan_> > fix (\fib -> 1 : 1 : zipWith (+) fib (tail fib)) -- start with fixpoints!
14:56:59 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
14:57:11 <cached> hmm
14:57:14 <bparkis> the problem is, you are given a set of objects, each with size a real number between 0 and 1
14:57:38 <bparkis> and the problem is to pack these objects into the smallest number of bins, where each bin can hold any number of objects so long as their size is <= 1
14:57:49 <vininim> real number is easy
14:57:50 <opqdonut> gah
14:57:52 <bparkis> i mean their combined size
14:58:01 <opqdonut> why is the projecteuler site breaking all the time
14:58:03 <Saizan_> btw, fix "calculates" the least fixed point, is there some useful application of greatest fixed points in lambda calculus?
14:58:14 <cached> Saizan_: i assume that takes the two arrays fib and tail fib (the last part of the fib array?) and adds them together?
14:58:19 <bparkis> exactly solving this problem is NP-complete, but the problem presents an approximation algorithm
14:58:25 <mauke> is this a knapsack
14:58:28 <byorgey> cached: exactly.
14:58:37 <bparkis> somewhat similar to knapsack mauke but not the same
14:58:38 <lucca> lists, not arrays
14:58:42 <byorgey> cached: but they aren't arrays, they are lists
14:58:54 <cached> eh, i was close ;)
14:59:00 <byorgey> cached: i.e. they don't have O(1) random access.
14:59:01 <ddarius> Saizan_: At the value level, greatest fixed points don't necessarily exist/aren't necessarily unique.
14:59:17 <bparkis> because you're not trying to fit as many as possible into one sack, you are trying to fit all of them into as few sacks as possible
14:59:17 <Saizan_> cached: and fib is the list you're currently building by summing those lists
14:59:17 <vininim> I mean, if the objects are not discrete the knapsack is P
14:59:17 <ddarius> Saizan_: At the type level, the correspond to coalgebraic types.
14:59:22 <cached> yep
14:59:22 <byorgey> cached: (such things do exist in Haskell, but often you only need lists.)
14:59:30 <bparkis> anyway the approximation algorithm is, for each object you look at all bins used previously, in the order in which  you created them
14:59:51 <cached> byorgey: is this because we want the fib program to be unbounded?
14:59:58 <bparkis> and put the object in the first bin you see that it will fit in
14:59:59 <Saizan_> ddarius: coalgebraic means?
15:00:09 <bparkis> and if the object fits in no bins, then create a new bin and put the object in that
15:00:13 <byorgey> cached: well, that's one reason.
15:00:34 <bparkis> this approximation algorithm gets within a factor of 2 (it uses no more than twice the number of bins as the optimal solution) and proving that was part A of the problem
15:00:49 <byorgey> cached: even if we only wanted a finite list, there would be no reason to use an array.  unless later on you're going to want fast random access to the computed fibonacci numbers.
15:00:58 <bparkis> part B of the problem, which I did not get completely, was to give an O(n log n) implementation of the approximation algorithm
15:01:19 <ddarius> Saizan_: Uh... that it's a terminal coalgebra... which isn't particularly helpful.  But anyway, the least fixpoint (in a strongly normalizing language) of the list algebra is the type of finite lists whereas the greatest fixpoint is the type of finite or infinite lists.
15:01:36 <bparkis> I said to sort the bins using a binary search tree, so that they are sorted by the amount of space they have remaining
15:01:44 <cached> byorgey: how are lists stored? are they O(n) runtime?
15:02:08 <Philippa_> cached: that's complicated because of lazy evaluation
15:02:08 <bparkis> and for each new object search the binary search tree for a bin with sufficient space remaining, and update the space of that bin, or else if you can't find one then add a new bin
15:02:08 <ddarius> cached: They are singly linked lists.
15:02:21 <bparkis> however this is not exactly what the approximation algorithm said to do
15:02:23 <byorgey> bparkis: but that doesn't preserve the "in the order you created them" thing, does it?
15:02:32 <bparkis> because the order in which you put the stuff in the bins is not the same
15:02:36 <bparkis> yes, that's the problem byorgey
15:02:36 <byorgey> right.
15:02:49 <bparkis> it IS still a factor of 2 approximation algorithm
15:02:53 <bparkis> and it does run in n log n time
15:03:03 <bparkis> but it is not exactly the same algorithm as described in the problem
15:03:46 <Saizan_> ddarius: ah, right, makes sense, so we actually use greatest fixed points when defining recursive types in haskell
15:04:17 <ddarius> Saizan_: Actually greatest and least fixed points coincide in Haskell.
15:04:26 <byorgey> bparkis: I've got to go but I'll think about it on the subway =)
15:04:34 <byorgey> let me know if you figure it out
15:04:37 <bparkis> ok
15:06:46 <ddarius> Saizan_: Anyway, http://citeseer.ist.psu.edu/289250.html is a good read on these topics.
15:06:47 <lambdabot> Title: Calculating Functional Programs - Gibbons (ResearchIndex)
15:07:46 <ddarius> Er this one http://citeseer.ist.psu.edu/503099.html
15:07:47 <lambdabot> Title: Chapter 5: Calculating Functional Programs (ResearchIndex)
15:08:40 <Saizan_> thanks :)
15:09:42 <Saizan_> i'm learning mu-calculus and thus puzzled on this
15:18:19 <moobax> hello all
15:18:53 <laurent__> hi everyone
15:20:19 <laurent__> wow I would not have expected that many people on this channel, does everyone here really program in haskell ? :)
15:20:45 <dons> laurent__: yeah. not everyone is paid to do so, but many are.
15:20:55 <moobax> i can only vouch for myself
15:21:09 <dons> ?users
15:21:10 <lambdabot> Maximum users seen in #haskell: 434, currently: 420 (96.8%), active: 22 (5.2%)
15:21:19 <dons> oh, so only a bit larger than the ruby channel
15:21:31 <dons> poor ruby guys, it must suck to be so unpopular ;)
15:22:12 <laurent__> I kind of felt that functional programming in general was taking off but I wouldn't have thought it would be enough to fill a freenode channel :)
15:22:53 <Jiten> I don't really program in Haskell... yet. I have written a small program though.
15:22:59 <Philippa_> #haskell's long been a good resource
15:23:05 <laurent__> this being said, I am a complete newbie in this area, but this is endearing
15:23:09 <dons> welcome!
15:23:25 <Philippa_> which is part of why it keeps growing - we probably attract a larger proportion of our language's user base than most programming language chans
15:23:29 <dons> yes.
15:23:41 <laurent__> thanks :)
15:24:14 <sjanssen> we are The One True Haskell Channel :)
15:24:43 <Jiten> haskell is a very interesting language :)
15:25:20 <ddarius> @seen lambdabot
15:25:20 <lambdabot> Yes, I'm here. I'm in #friendly-coders, #scannedinavian, #gentoo-haskell, ##logic, #xmonad, #unicycling, #perl6, #parrot, #jtiger, #haskell-soc, #haskell-overflow, #haskell-blah, #scala, #haskell, #
15:25:21 <lambdabot> ghc and #darcs
15:25:22 <thetallguy> one lambdabot to rule them all
15:25:23 <ddarius> "we" is right
15:25:37 <ddarius> thetallguy: Actually there are two lambdabots and other... clones.
15:25:56 <thetallguy> ddarius: let me tell you why that's funny...
15:26:03 <laurent__> written in haskell ?
15:26:09 <ddarius> @version
15:26:09 <lambdabot> lambdabot 4p581, GHC 6.6 (Linux i686 2.40GHz)
15:26:09 <lambdabot> darcs get http://code.haskell.org/lambdabot
15:26:33 <sjanssen> thetallguy: and in the darkness >>= them?
15:26:43 <thetallguy> sjanssen: Huzzah!
15:26:47 * sjanssen is pretty sure he's made that joke in #haskell before
15:26:59 * thetallguy doesn't doubt it.
15:27:05 <laurent__> nice to see a Haskell program dealing with IO :)
15:27:22 <mauke> see also darcs, xmonad
15:27:25 <ddarius> They all deal with IO to some extent.
15:27:51 <laurent__> of course, you have to save those results and load these inputs at some point :)
15:27:55 <Jiten> IO is the part that had me banging my head on the wall the most. More precisely random numbers.
15:27:56 <ddarius> "Haskell: The Language of Choice for Perl Hackers"
15:28:14 <geocalc> haha
15:28:35 <sjanssen> @remember ddarius "Haskell: The Language of Choice for Perl Hackers"
15:28:36 <lambdabot> Good to know.
15:28:51 <laurent__> but, having zero experience in Haskell at all, I keep wondering if the IO part is not painful enough to make Haskell finally not so attractive as it seems ?
15:29:04 <Philippa_> Haskell is the finest imperative language in existance
15:29:16 <sjanssen> @quote darkness
15:29:17 <lambdabot> apfelmus says: Ah, yet another UndeadArray necromancer exhausting his stack of bones. May the forces of light suggest to structure the incantation of darkness?
15:29:20 <sjanssen> @quote darkness
15:29:21 <lambdabot> apfelmus says: Ah, yet another UndeadArray necromancer exhausting his stack of bones. May the forces of light suggest to structure the incantation of darkness?
15:29:41 <geocalc> laurent__=<< it is easy
15:29:55 <Philippa_> ...well, not quite. But the downsides aren't too painful (they're a matter of convention, you get used to it) and the upsides are pretty impressive
15:30:02 <sjanssen> laurent__: IO is not a liability as you might think at a first glance
15:30:03 <trontonic> laurent__: it depends on what kinds of programs you're going to write
15:30:31 <Philippa_> trontonic: what do you have in mind when you say that?
15:30:38 <trontonic> Philippa_: flamewar ;)
15:30:50 <Philippa_> (there are some things that are problematic, but they're problematic in many languages - many others are much easier than might be expected)
15:31:06 <trontonic> Philippa_: no, seriously, I would choose python over haskell for some programs, but not all
15:31:07 <ddarius> trontonic: flamewars are easy to implement, you don't need to do any input, just output.
15:31:35 <trontonic> ddarius: I would say it's the other way around? :)
15:31:45 <Philippa_> trontonic: it helps discussion if you talk about what kinds of program you would choose another language for
15:31:52 <Philippa_> otherwise you're repeating yourself
15:32:18 <trontonic> Philippa_: you're assuming we're in a discussion, I was saying something to laurent
15:32:57 <laurent__> to all: well, my main interrogation is that one : since a Haskell program kind of stores its state on the stack (actually I guess it stores it in the heap and keeps pointer  on the stack but that's an implementation detail), how hard is it to save state at some point, without needing to dump the equivalent of a lisp image ? I'm not quite sure I'm clear there....
15:33:45 <Philippa_> laurent__: Actually the big difference is that what state you have becomes explicit
15:33:52 <Philippa_> so it's usually actually easier to dump it out and restore it
15:34:05 <Philippa_> (assuming you're not suddenly trying to serialise functions)
15:34:12 <ddarius> That said, few languages support that at all.
15:34:27 <ddarius> (which would be rather likely in Haskell)
15:34:29 <Philippa_> trontonic: who I imagine would also benefit from knowing which kinds of program you're talking about
15:34:32 <laurent__> Philippa_:  can you be more .... explicit ? :) i'm not sure I get it
15:34:37 <trontonic> laurent__: my experience with Haskell is that it's not a problem :)
15:34:58 <Philippa_> laurent__: because you don't have 'implicit state' as you would have in an imperative language, if you're doing something state-like there'll be a value you can point to that is 'the state'
15:35:21 <trontonic> Philippa_: if that was the case, I'm sure laurent is more than capable of asking that question or following the sparse lead I gave him/herself
15:35:37 <dons> persitance is easy once you have a single root to all program state
15:35:41 <ddarius> E.g. xmonad has an explicit model of the windows that's a single data structure, not just a bunch of handles or some such
15:37:14 <laurent__> dons: I kind of assumed that, but since I only read about Haskell for now, I have to trust you on that one :)
15:37:29 <dons> @flush
15:37:41 <dons> -- ^ just grabbed all the state in lambdabot and wrote it to disk
15:38:05 <Philippa_> laurent__: if your program has some form of 'main loop' then you'll have a value or tuple of values that's the 'state' that gets passed around the loop...
15:38:05 <dons> anyway, a lot of things become kind of trivial once you're explicit about what state you're using
15:38:57 <conal> does anyone know what could cause the "unknown symbol" problems in hs-plugins on windows?
15:39:11 <noteventime> Can anyone who has solved the second Project Euler problem tell me if this is an acceptable Haskell solution -> http://hpaste.org/4551
15:39:33 <dons> conal: likely hs-plugins is asking for the wrong symbol name on your platform
15:39:50 <laurent__> Philippa_/ dons : yes, I think I understand that, although it seems still strange to pass on a whole bunch of heterogeneous data to pure functions. I guess I'll need to write some code to get it fully.
15:40:24 <ddarius> laurent__: You shouldn't have a "whole bunch" of stuff being passed to a function period.
15:40:40 <Philippa_> ddarius: depends how you view it. I mean, I pass some pretty big structures around
15:41:02 <Philippa_> but it's rare I need more than three parms - in fact it's usually a good sign some set of functions belong in a more helpful monad
15:41:06 <ddarius> Philippa_: And in my view that is "one thing" especially if it is one piece of "state"
15:41:36 <laurent__> ddarius: you mean that these data should be regrouped in for example a list, that would get passed to handling functions ?
15:41:40 <Philippa_> the important bit's making the heterogeneity fit some useful pattern
15:42:13 <ddarius> laurent__: If they belong in a list or some other data structure, sure, but what I mean is your functions shouldn't depend on 347 different pieces of state.
15:42:21 <Philippa_> laurent__: often the structure in question starts to smell a lot like an explicit representation of a heap :-)
15:42:35 <laurent__> oh well, that's obvious. forget my question. if it's the main loop, all the program state is under one main "variable"
15:42:38 <Philippa_> or perhaps of a small collection of heaps and some more 'static' data
15:43:19 <Philippa_> usually. You might justifiably keep a list of 'states' so you've got an undo queue instead though, for example
15:43:46 <laurent__> Philippa_: ah, that was one of my concerns as well :)
15:44:12 <laurent__> Philippa_:  but won't it eat huge amount of memories ?
15:44:17 <moobax> Can anyone help me writing an infinite list? I'm writing an interpreter for a little functional language and I wanted to generate type variable names. What's the coolest way you can think of to make the list [a,b,c,..z, aa,ab,ac..az, ba,bb,bc..bz ...]? I realise that this problem is very nearly encoding in base-26, but not quite...
15:44:18 <Philippa_> depends
15:44:31 <ddarius> laurent__: No unless you are doing it wrong.
15:44:43 <Philippa_> first of all, not as much as you're expecting: structures like lists and trees will 'share' components with their older incarnations
15:45:06 <mauke> moobax: does it have to be exactly those names?
15:45:15 <Philippa_> for example, if you only ever append to a list then your undo list only costs you the new list
15:45:30 <Philippa_> because the older versions are just a few steps along the same set of data
15:45:36 <Philippa_> sorry, only prepend even
15:45:38 <oerjan> > flip map [1..] $ replicateM ['a'..'z']
15:45:41 <lambdabot>  Couldn't match expected type `Int' against inferred type `[a]'
15:45:42 <laurent__> Philippa_: ok, Haskell is clever enough to point to the old data in a sense ?
15:45:54 <oerjan> > flip map [1..] $ flip replicateM ['a'..'z']
15:45:55 <Philippa_> it's not clever enough: it's dumb enough to not avoid doing it :-)
15:45:56 <lambdabot>  [["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s...
15:46:08 <laurent__> :)
15:46:08 <cached> holy crap haskell is nice ;)
15:46:08 <oerjan> > flip concatMap [1..] $ flip replicateM ['a'..'z']
15:46:09 <lambdabot>  ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s"...
15:46:14 <Philippa_> it doesn't need to, because the old data never gets mutated
15:46:48 <Philippa_> secondly, if you've got a problem there are alternative representations. For example, if all your state changes are brought about by invertible commands you can keep the current state and the previous n commands
15:46:52 <laurent__> Philippa_:  Ok got it ! I had forgotten that point.
15:47:25 <ddarius> > let vars = ["a".."z"] ++ join (liftM2 (++)) vars in vars -- /me wonders what this will do
15:47:26 <lambdabot>   add an instance declaration for (Enum [Char])
15:47:27 <Philippa_> if they're not invertible, you might keep the oldest state required for your undo list, all the relevant commands and perhaps a cache of 'more relevant' states
15:47:39 <oerjan> > [1..] >>= flip replicateM ['a'..'z']
15:47:40 <laurent__> Philippa_: yes, that's how we proceed in the software I'm writing
15:47:40 <lambdabot>  ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s"...
15:47:43 <Philippa_> (current and previous being good bets)
15:47:48 <ddarius> > let vars = map (:[]) ['a'..'z'] ++ join (liftM2 (++)) vars in vars -- /me wonders what this will do
15:47:49 <lambdabot>  ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s"...
15:48:00 <ddarius> > let vars = map (:[]) ['a'..'z'] ++ join (liftM2 (++)) vars in drop 26 vars
15:48:01 <lambdabot>  ["aa","ab","ac","ad","ae","af","ag","ah","ai","aj","ak","al","am","an","ao",...
15:48:10 <ddarius> > let vars = map (:[]) ['a'..'z'] ++ join (liftM2 (++)) vars in drop 52 vars
15:48:11 <lambdabot>  ["aaa","aab","aac","aad","aae","aaf","aag","aah","aai","aaj","aak","aal","aa...
15:48:20 <ddarius> No good.
15:48:50 <laurent__> Philippa_: it makes sense, I will sleep much clever tonight :)
15:48:53 <moobax> mauke: I was going to use (  map (\x-> showIntAtBase 26 (['a'..'z']!!) x "") [0..]  ) but that doesn't make the right names
15:49:02 <moobax> ooh wow, that's a lot of responses
15:49:40 <laurent__> I've got to leave, thanks everyone for your helpful answers
15:49:54 <laurent__> I'll certainly come back :)
15:50:25 <oerjan> moobax: better check that they do the right thing at least up to length three...
15:50:37 <oerjan> i think ddarius's had a bug there
15:50:40 <ddarius> @hoogle showIntAtBase
15:50:41 <lambdabot> Numeric.showIntAtBase :: Integral a => a -> (Int -> Char) -> a -> ShowS
15:50:57 <ddarius> oerjan: It doesn't do the "right thing" hence me saying "No good."
15:51:28 <oerjan> > [1..] >>= flip replicateM ['a'..'b'] -- shrink the alphabet a bit for easy checking
15:51:32 <lambdabot>  ["a","b","aa","ab","ba","bb","aaa","aab","aba","abb","baa","bab","bba","bbb"...
15:52:10 <BMeph> Hello again  - what was the problem? :)
15:52:37 <moobax> the list [a,b,c,..z, aa,ab,ac..az, ba,bb,bc..bz ...]
15:52:42 <moobax> :)
15:53:48 <oerjan> > fix (liftM2(:)['a'..'b'].("":))
15:53:53 <lambdabot>  ["a","aa","aaa","aaaa","aaaaa","aaaaaa","aaaaaaa","aaaaaaaa","aaaaaaaaa","aa...
15:53:57 <oerjan> oops
15:56:14 <moobax> [1..] >>= flip replicateM ['a'..'z']   seems to work, that's awesome
15:56:20 <moobax> thanks :)
15:58:39 <moobax> I love Haskell
15:58:46 <oerjan> :)
15:58:57 <moobax> once you get code past the type checker, it works most of the time
15:59:02 <Pseudonym> Haskell loves you too.
15:59:28 <Pseudonym> Remember, time spent getting your code past the type checker is time not spent later getting your code past the debugger.
15:59:41 <moobax> however, is anyone else getting memory leaks in GHCI?
15:59:48 <ddarius> Haskell feeds the plants that are the food that nourishes you.
15:59:59 <oerjan> @remember Pseudonym time spent getting your code past the type checker is time not spent later getting your code past the debugger.
16:00:00 <lambdabot> Done.
16:00:00 <moobax> I left it open for a few hours and I had one at 1GB and one at 500MB
16:00:04 <thoughtpolice> then we have come full circle.
16:00:35 <monochrom> I don't get a memory leak.
16:00:52 <moobax> this is on vista and 6.8.2
16:01:06 <moobax> my computer started thrashing, which is how I noticed
16:01:35 <dons> moobax: it really depends on what you're doing in ghci, i think.
16:01:55 <ddarius> let xs = [0..]; xs
16:02:01 <dons> for example :)
16:02:22 <moobax> Why wouldn't it free the memory though? I'm sure my code doesn't need 1GB
16:02:34 <ddarius> @bug
16:02:35 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
16:02:42 <conal> dons: i have no idea where to start with fixing hs-plugins for windows.  do you know who might?
16:02:48 <dons> hmm. no :(
16:02:59 <dons> we had one person do the port, and they've disappeared
16:03:38 <moobax> oerjan: you'll get a mention in my source ;)
16:03:59 * oerjan had this strange idea that porting hs-plugins to ghc-api should instantly solve all portability problems...
16:04:13 <oerjan> naive, i know
16:04:38 <dons> Cale has done a partial port.
16:04:43 <dons> just the package stuff, afaik
16:04:47 <dons> you could do the full thing
16:04:50 <thoughtpolice> cale only rewrote part of the hi-related stuffs to use the api. so it might be worth saying that part of it is resillient to os's
16:04:57 <dons> and it would be less code, that was more robust, and portable
16:05:11 <dons> since simon m would maintain the windows parts of the ghci loader for us :)
16:06:06 <thoughtpolice> dons: installed 1.1 yesterday; are people aiming for portability before it's uploaded to hackage?
16:06:12 <thoughtpolice> i.e. a 1.2?
16:06:28 <dons> thoughtpolice: yes please.
16:06:32 <dons> that's why i didn't upload it yet
16:06:46 <thoughtpolice> good goal. :)
16:06:47 <dons> it doesn't work on openbsd, for example (or it could be a 64 bit issue)
16:07:01 <thoughtpolice> yes i noticed that with 1.0 on 6.6.1.
16:07:07 <dons> i have 0% of time to work on hs-plugins, though i'm happy to apply patches
16:07:12 <thoughtpolice> failed with unknown symbols (errno__ or something)
16:07:21 <dons> right, that would be libc not being loaded
16:08:29 <thoughtpolice> well, i don't program on windows anymore but i might give a try to fixing something. :) darcs might not be so nice, though...
16:09:15 <Cale> There was a problem with the darcs repository for conal.
16:09:37 <Cale> I had to send him a tar.gz of it. Some case-insensitivity issue.
16:09:53 <thoughtpolice> yeah, i picked up on that yesterday. :(
16:10:09 <thoughtpolice> it's cool. nc is the ultimate poor man's ftp!
16:10:32 <ddarius> Norton Commander?
16:10:38 <Cale> netcat
16:10:42 <Cale> ?
16:11:04 <conal> Cale: oddly, i re-get'd hs-plugins, and didn't have darcs problem.
16:11:18 <Cale> Interesting :)
16:11:25 <thoughtpolice> yes, netcat. :)
16:11:47 <moobax> thanks all, I'm going to sleep. :)
16:11:58 <Cale> My next guess would have been ncftp, but that's an actual ftp client :)
16:12:07 * ddarius knew what thoughtpolice was referring to, though he hasn't thought about Norton Commander in a long long time.
16:12:16 <thoughtpolice> nostalgia?
16:12:20 <thoughtpolice> or hatred?
16:12:26 <ddarius> thoughtpolice: I liked it a lot.
16:12:38 <thoughtpolice> Cale: nc -l -p 2007 < file and nc host port > file are some of my most used commands.
16:12:44 <monochrom> netcat saved my life.
16:12:58 <LoganCapaldo> monochrom: literally?
16:13:18 <monochrom> Indeed, I do nc -l -p 2007 < file and nc host port > file all the time.
16:13:29 <Pseudonym> And that kept the murderer away?
16:13:43 <Pseudonym> Or saved you from electrocution?
16:14:44 <thoughtpolice> it stopped the injection's effects.
16:15:41 <oerjan> it chased away a horde of pedants!
16:15:41 <monochrom> My laptop hard disk was about to fail. I needed an exodus of my files to another computer. The destination is using windows, no easy story for ftpd or sshd (or I'm too lazy and hasty to find one).
16:16:03 <Pseudonym> This included your vital medical records?
16:17:07 <monochrom> So I was wondering, "dumping a file from A to B through the network ought to be a simple task, why no one wrote such a program? all programs written do fancier, bloated things like http..."
16:17:26 <monochrom> Of course, it was written, and it was netcat. :)
16:17:31 <thoughtpolice> i saw no use in netcat
16:17:34 <thoughtpolice> until I found out it could do that
16:17:46 <thoughtpolice> and I have not regretted ever having it installed on any box, *ever*, since.
16:17:48 <Pseudonym> It is useful for debugging UDP applications.
16:17:50 <ddarius> What?! netcat's utility was immediately obvious to me
16:17:57 * Pseudonym has done that
16:18:22 <thoughtpolice> don't rub it in :(
16:18:26 <ddarius> thoughtpolice: Why would you regret installing some software, especially something as small as netcat?
16:18:46 <olsner> netcat | hexdump ;-)
16:19:49 <thoughtpolice> i'm a neat freak when it comes to my files. i delete things and clean up at somewhat random intervals but if its small and I see no use i'm sometimes not hesitant to blast it.
16:20:03 <pjd> ObAlternative: socat
16:20:10 <Pseudonym> Perl's utility wasn't obvious to me until I discovered CPAN.
16:20:11 * LoganCapaldo has regretted software being installed. generally it tends to be softwaere installed by other people.
16:20:14 <Pseudonym> Just saying.
16:20:34 <thoughtpolice> there's also cryptcat but i haven't looked at it in a while.
16:20:38 <ddarius> Perl's utility is still not obvious to me.
16:20:41 <monochrom> Generally "software installed by other people" = viruses installed by other people.
16:21:12 <LoganCapaldo> Well I was thinking my corporate IT overlords as the other people
16:23:18 <monochrom> The utility of those people was not obvious to me once... :)
16:47:22 <Plareplane> I have trouble figuring out the types of simple expressions such as (reverse .) . (++) unless i manually write down the types of the subexpressions and substitute. anyone have advice/tutorials on how to parse types easier?
16:48:24 <dons> use the type checker? :)
16:48:30 <dons> :t (reverse .) . (++)
16:48:31 <lambdabot> forall a. [a] -> [a] -> [a]
16:48:40 <dons> ?unpl (reverse .) . (++)
16:48:41 <lambdabot> (\ d g -> reverse (d ++ g))
16:48:43 <dons> makes it easier
16:48:50 <Plareplane> well, other than calling lambdabot or ghci :)
16:48:54 <dons> so that takes two lists, and returns one.
16:49:20 <Plareplane> for that expression at least, the pointy version is a lot easier to parse for me
16:49:31 <Plareplane> whenever there are multiple . and () involved i just lose it
16:50:08 <dons> definitely.
16:50:13 <dons> avoid dots.
16:50:43 <Saizan_> well dots are nice, best when you're able to use them in sequence like f . g . h $ x
16:51:15 <Saizan_> but (f .) . g is quite simple, you just need to get used to it
16:51:27 <sjanssen> we need an operator for that
16:51:34 <Saizan_> ?type \f g -> (f .) . g
16:51:36 <lambdabot> forall b c a a1. (b -> c) -> (a1 -> a -> b) -> a1 -> a -> c
16:52:02 <Plareplane> for me, . is simple as long as all the functions are single variable ones (pretend that currying doesn't exist). but once there are multiple arguments it gets confusing
16:52:13 <dobblego> Plareplane, you could use the @unpl feature of lambdabot
16:52:15 <dobblego> @unpl (f .) . g
16:52:16 <lambdabot> (\ d i -> f (g d i))
16:52:24 <Plareplane> so maybe i just need to be more comfortable with currying
16:52:49 <sjanssen> Plareplane: I tend to agree
16:53:03 <sjanssen> (f .) . g has too much noise to read quickly
16:54:02 <Plareplane> what would be the "3 variable" version of (f .) . g?
16:54:18 <Saizan_> Plareplane: ((f .) .) . g
16:54:19 <sjanssen> @pl \x y z -> f (g x y z)
16:54:19 <lambdabot> ((f .) .) . g
16:54:28 <Saizan_> and so on
16:55:07 <sjanssen> does anyone have a nice name for \f g -> f (g x y z)?
16:55:10 <Plareplane> ah, that helps a bit in seeing how the . and () nest. but it's line noise!
16:55:58 <Saizan_> sjanssen: (.:)
16:56:22 <sjanssen> Saizan_: any particular reason?
16:56:35 <pjd> sjanssen: it would be really great if you could name them (.), (..), (...), and so on
16:56:38 <sjanssen> too bad .. is taken
16:56:43 <oerjan> as is :
16:56:44 <pjd> yeah
16:56:47 <Saizan_> g gets to point and f one
16:57:08 <Saizan_> *rwo
16:57:20 <Saizan_> .. *two
16:57:23 <pjd> too?
16:58:25 <sjanssen> Saizan_: it doesn't scale up to three arguments (at least without Unicode)
16:58:29 <conal> sjanssen: see "result" in DeepArrow.
16:58:41 <sjanssen> conal: do you give it an operator name?
16:58:45 <conal> i think your function is (result.result.result)
16:59:16 <conal> (result.result.result) f g
16:59:18 <Saizan_> Plareplane: (f .) . g = \x -> (f .) (g x) = \x -> f . (g x) = \x -> \y -> f ((g x) y) = \x y -> f (g x y)
16:59:36 <conal> sjanssen: which for the function arrow is ((.).(.).(.)) f g
16:59:54 <sjanssen> @type ((.).(.).(.))
16:59:56 <lambdabot> forall a a1 b c a2. (b -> c) -> (a -> a1 -> a2 -> b) -> a -> a1 -> a2 -> c
17:00:11 <conal> sjanssen: and you can mix result, first, and second, arbitrarily.
17:00:28 <sjanssen> conal: which module should I be reading?
17:00:31 <conal> @type ((.).first.(.).second)
17:00:32 <lambdabot> forall a d a1 b c d1. (b -> c) -> (a -> (a1 -> (d1, b), d)) -> a -> (a1 -> (d1, c), d)
17:00:41 <conal> sjanssen: Control.Arrow.DeepArrow, i think.
17:00:49 <conal> @wiki DeepArrow
17:00:50 <lambdabot> http://www.haskell.org/haskellwiki/DeepArrow
17:01:41 <Saizan_> however you can write a polymorphic deepcompose but you've to specify types when g result is too polymorphic (i.e. it could be unified with a function)
17:03:23 <BMeph> It's the coconut operator! :)
17:03:36 <conal> sjanssen: if you write "(.).(.).(.)", it looks obscure, but things like "result.first.result.second" are directly written & read as paths into the type structure, saying where you want to edit.
17:04:34 <conal> sjanssen: oh, and btw, you can use fmap instead of (.) or result, which is more general in some ways and perhaps less general in others.
17:05:12 <Liskni_si> @src fmap (->)
17:05:12 <lambdabot> Source not found. Just try something else.
17:05:15 <oerjan> yet another name for fmap...
17:05:16 <SamB_XP> it also looks less like alien boobs
17:05:22 <conal> sjanssen: fmap lets you reach into functors, e.g., to edit the first half of the result of each function in a list
17:05:34 <Cale> (.) makes a great general name for fmap
17:05:52 <BMeph> @src (->) fmap
17:05:52 <lambdabot> fmap = (.)
17:06:01 <Cale> I'm thoroughly convinced of that ever since I translated the fusion law for fmap :)
17:06:41 <opqdonut> fusion law?
17:07:02 <Cale> (fmap f . fmap g) x = fmap (f . g) x
17:07:19 <opqdonut> ah
17:07:34 <dcoutts> @yarr!
17:07:35 <lambdabot> Swab the deck!
17:07:36 * dcoutts recommends everyone grab Cabal HEAD and caba-install and give it a whirl
17:07:40 <Cale> That becomes  f . (g . x) = (f . g) . x
17:07:54 <Cale> Which is exactly what you expect composition to satisfy already.
17:07:55 <Cale> Also,
17:08:11 <Cale> fmap id x = x, turns into id . x = x
17:08:13 <conal> Cale: or fmap (fmap f) (fmap g) = fmap (fmap f g) ?
17:08:23 <SamB_XP> @free (.)
17:08:24 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
17:08:28 <dcoutts> cabal-install should now be the cabal command line UI of choice, never have to fiddle with runghc Setup.hs again
17:08:31 <SamB_XP> arg!
17:08:33 <SamB_XP> @free fmap
17:08:36 <lambdabot> Expected variable or '.'
17:08:39 <Cale> conal: sure
17:08:52 <Igloo> dcoutts: Wasn't the command going to become just cabal?
17:09:09 <dcoutts> Igloo: yes, that's the command name, but not the package name sadly
17:09:09 <Cale> conal: But the observation is that the laws that you expect composition to satisfy are the same as the ones for fmap
17:09:27 <sjanssen> conal: how would you write (\ d g -> reverse (d ++ g)) in pointfree style with DeepArrow?
17:09:49 <Igloo> Ah, OK, I misparsed what you said then
17:10:04 <dcoutts> it's ambiguous :-)
17:10:07 <Cale> conal: My only hesitation with defining (.) as the general fmap originally was that there are laws which we expect composition to obey that I thought perhaps fmap might not, but it turns out that with a proper functor, that's not the case.
17:10:33 <dcoutts> Igloo: now we just need a cabal install --everything-yes-I-am-that-insane flag for hackage QA purposes
17:10:42 <conal> sjanssen: i think it's (result.result) (++)
17:10:53 <conal> sjanssen: i mean (result.result) reverse (++)
17:11:14 <conal> sjanssen: which says: reverse the result of the result of append
17:11:16 <sjanssen> conal: any way to infix-ify that?
17:11:37 <sjanssen> conal: or is that the intended style with DeepArrow?
17:11:44 <conal> sjanssen: reverse `(result.result)` (++)
17:11:54 <conal> sjanssen: if infix were looser
17:12:26 <conal> sjanssen: i don't know how to reconcile infix with compositionality of the binary operators.
17:12:48 <conal> sjanssen: i.e., with the binary operators themselves being composable.
17:13:32 <conal> sjanssen: i'm not sure i expressed that quandry clearly.
17:13:51 <sjanssen> conal: do go on, I'm interested
17:15:12 <conal> sjanssen: if we have a few atomic binary operators like (.) and ($) (and +, *, ...), then i see how to use infix.  but what if we have an *algebra* of such operators?
17:15:52 <conal> sjanssen: if haskell allowed *expressions* between backquotes, we could say "reverse `(result.result)` (++)"
17:16:15 <conal> sjanssen: (or drop the parens, but they might be needed to disambiguate)
17:16:38 <conal> sjanssen: but even that may be uglier than you want.
17:16:51 <sjanssen> conal: I think expressions between `` become difficult for humans to parse
17:17:09 * EvilTerran wouldn't mind being able to say things like `zipWith (+)`
17:17:10 <conal> sjanssen: they may well.
17:17:18 * conal too
17:18:07 <sjanssen> I dunno, I'd almost consider let (<+>) = zipWith (+) in xs <+> ys over that
17:18:47 <conal> sjanssen: i guess you could do that for things like (result.first.result.second)
17:19:04 <conal> oddly, i often use "second f p", but until now i've never thought to use "f `second` p"
17:19:31 <nanothief> do you have to pass any special flags to ghc to use a forall?
17:19:51 <conal> nanothief: yes.  three possibilities, at least.
17:19:57 <sjanssen> nanothief: yes, -fglasgow-exts works if you don't want to find a more specific flag
17:19:57 <conal> ScopedTypeVariables is one.
17:20:11 <monochrom> RankNTypes is another.
17:20:12 <conal> also Rank2Types or RankNTypes, i think.
17:20:27 <monochrom> ExistentialTypes
17:20:38 <nanothief> sjanssen: thats the -fglasgow-exts did the trick
17:20:43 <conal> four, at least.
17:20:43 <EvilTerran> if you had low-fixity operators, say, infixl 1 <|, |>; x <| f = f x; f |> x = f x
17:20:48 <nanothief> s.thats/thanks
17:21:00 <EvilTerran> you could say things like "[1,2,3] <| zipWith (+) |> [4,5,6]
17:21:55 <conal> EvilTerran: i like that trick
17:22:22 <conal> reverse <| result.result |> (++)
17:22:41 <EvilTerran> ` should be a Prelude-defined infix operator :P
17:23:09 <conal> sjanssen: how about "reverse <| result.result |> (++)" ?
17:23:38 <bparkis> does the lack of (easy) imperative updating often cause algorithms to be asymptotically slower in Haskell?
17:23:39 <vininim> is there anything better than read [x] for x::Char?
17:23:41 <conal> sjanssen: and of course you could use briefer synonyms for result, fmap, first, and second.
17:23:53 <vininim> (ie. Char -> Integer)
17:24:11 <TSC> @hoogle Char -> Int
17:24:12 <lambdabot> Data.Char.digitToInt :: Char -> Int
17:24:12 <lambdabot> Data.Char.ord :: Char -> Int
17:24:12 <lambdabot> Data.ByteString.Char8.count :: Char -> ByteString -> Int
17:24:14 <conal> bparkis: deep question.  some algorithms no, and some apparently yes.
17:24:36 <vininim> @hoogle Int -> Integer
17:24:37 <lambdabot> No matches, try a more general search
17:24:45 <TSC> vininim: Maybe digitToInt is what you want?  Do you want to convert '3' to 3 ?
17:24:46 <xEpicFailGuyx> hello
17:24:50 <sjanssen> bparkis: occasionally, usually a logarithmic factor
17:24:52 <monochrom> fromIntegral
17:25:20 <sjanssen> bparkis: though, as they say, forall n, log n < 32 :)
17:25:32 <conal> bparkis: chris okasaki has written a bunch about efficient functional algorithms.  and they have the property of "persistnce", meaning that old versions of data may still be accessed.
17:25:45 <xEpicFailGuyx> Never mind, answered my own question
17:25:49 <EvilTerran> bparkis, alsom in many cases, the apparent increased slowness is in fact an illusion caused by the imperative people claiming that their memory lookup times are O(1) instead of the real O(log n)
17:25:57 <sjanssen> conal: I think that's getting better
17:26:26 <sjanssen> conal: though I think the pattern is used frequently that it's worth a name of its own
17:26:35 <EvilTerran> hm... if you have "infixr 2 <|; infixl 1 |>", you can do stuff like "[1,2,3] <| [4,5,6] <| zipWith3 (,,) |> [7,8,9]"
17:26:41 <EvilTerran> altho it comes out in a bit of a funny order
17:26:58 <conal> sjanssen: do you mean the specific pattern (.).(.) (i.e., result.result)?
17:27:11 <EvilTerran> fmap fmap fmap ?
17:27:21 <sjanssen> conal: yeah, composition where the second function has two arguments
17:27:23 <EvilTerran> call it "fff" :P
17:27:38 <EvilTerran> then we'll look like perl6 :D
17:27:42 <conal> sjanssen: yeah.  pretty common.
17:27:58 <conal> sjanssen: were you looking for something more general, or just (.).(.) ?
17:28:30 <sjanssen> conal: just (.).(.), but generality is no problem
17:28:42 <BMeph> bparkis: Yes, but the lack of strict  evaluation causes Haskell to be asymptotically faster in algorithm generation, thus causing Haskell programs to be a constant factor of the speed of C.
17:29:20 <BMeph> In a sort-of inside joke, it seems that the "constant" factor of speed difference is decreasing. ;p
17:30:37 <BMeph> conal: What does the "Hooters" operator (i.e., (.)$(.)) translate to be?
17:31:09 <Saizan_> ?type (.)$(.)
17:31:10 <EvilTerran> @unpl ((.)$(.))
17:31:10 <lambdabot> forall a b c a1. (a -> b -> c) -> a -> (a1 -> b) -> a1 -> c
17:31:11 <lambdabot> (\ b c e f -> b c (e f))
17:32:38 <wy> Is literate haskell often used? It seems to be good for people who wants to write more documentation than code.
17:33:25 <nolrai> the documentation on the Haskell Hirarcal Libraries at haskell.org seems to be gone. Any one know of anywhere else I can find it?
17:33:31 <esteban2> hello all
17:33:39 <Saizan_> wy: that's the intention, also used for papers with lhs2Tex
17:33:43 <esteban2> question, can you have an optional argument for a function?
17:33:44 <sjanssen> @docs
17:33:45 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
17:33:54 <sjanssen> nolrai: that link works
17:34:20 <Saizan_> esteban2: the common idiom for that is to use a Maybe argument
17:34:21 <wy> Saizan_: That means I can use TeX in the documentation?
17:34:27 <nolrai> sjanssen++
17:35:07 <conal> BMeph: i hadn't seen that one.  i like the list here: http://www.georgehernandez.com/h/xComputers/Communicating/eSpeak/zoldEmoticons.htm (scroll down).  my girlfriend put me onto this ascii art genre.
17:35:08 <lambdabot> Title: Emoticons, http://tinyurl.com/2q77md
17:35:20 <Saizan_> wy: yes
17:35:33 <wy> Saizan_: Are there examples of such a document?
17:35:49 <wy> I'm interested using such a style
17:35:59 <Saizan_> pancito is written like that. iirc
17:36:07 <Saizan_> ?where pancito
17:36:08 <lambdabot> I know nothing about pancito.
17:36:29 <BMeph> conal: It's the first mentioned of the operators in the Pointfree article in the HaskellWiki
17:37:23 <Saizan_> wy: http://www.acooke.org/jara/pancito/index.html
17:37:24 <lambdabot> Title: Jara Software: Pancito: Home Page
17:37:43 <conal> wy: also look through ghc library sources for .lhs files
17:39:29 <wy> Thanks. I still haven't got my sound card to work :-p
17:39:53 <BMeph> conal: Interesting site, but I'm disappointed that they don't have the Haskellers' sign for a bottom (_|_)
17:46:28 <BMeph> wy: Look up Janis Voigtlaender; he does a lot of Tex-based lhs code.
17:59:50 <chessguy> @bot
17:59:51 <lambdabot> :)
18:00:55 <chessguy> @users
18:00:56 <lambdabot> Maximum users seen in #haskell: 434, currently: 396 (91.2%), active: 9 (2.3%)
18:01:06 <chessguy> quiet bunch tonight
18:01:40 <dobblego> RAR!
18:20:48 <nolrai> @pl j f (a,b) = (f a, f b)
18:20:48 <lambdabot> j = (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
18:21:30 <nolrai> ok I am darn shure that theres a better way to do that.
18:21:53 <mauke> :t join (&&&)
18:21:56 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a b (c, c)
18:22:12 <mauke> :t join (***)
18:22:13 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
18:22:35 <mauke> hmm, might be not general enough
18:23:20 <nolrai> @type zipWith
18:23:21 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
18:23:34 <nolrai> @type uncurry zipWith
18:23:35 <lambdabot> forall a b c. (a -> b -> c, [a]) -> [b] -> [c]
18:23:50 <mauke> > join (***) sqrt (2,3)
18:23:52 <lambdabot>  (1.4142135623730951,1.7320508075688772)
18:24:06 <nolrai> @type uncury (zipWith (++))
18:24:06 <lambdabot> Not in scope: `uncury'
18:24:12 <nolrai> @type uncurry (zipWith (++))
18:24:12 <lambdabot> forall a. ([[a]], [[a]]) -> [[a]]
18:27:38 <shachaf> mauke: Why not general enough?
18:27:56 <nolrai> > zipWith (+) [(1,2,3),(1,2,3)]
18:27:57 <lambdabot>   add an instance declaration for (Num (t, t1, t2))
18:27:58 <mauke> > join (***) show (1, 'x')
18:27:59 <lambdabot>   add an instance declaration for (Num Char)
18:27:59 <lambdabot>     In the expression: 1
18:28:35 <nolrai> > zipWith (+) [1,2,3] [1,2,3]
18:28:36 <lambdabot>  [2,4,6]
18:37:17 <wellwisher> Could I get help with http://hpaste.org/4553 ?
18:38:45 <jsnx> so, the Reader Monad is kind of like OO...
18:38:52 <mauke> what the
18:38:58 <jsnx> or, it's kind of like 'methods', i mean
18:39:08 <shachaf> jsnx: In what way?
18:39:22 <jsnx> you can take a struct and make it the context for method execution
18:39:45 <TSC> wellwisher: It's the Read instance you're having trouble with?
18:39:46 <jsnx> right? (i am just learning the Reader Monad)
18:40:12 <shachaf> jsnx: Well, it's just an implicit argument.
18:40:14 <mauke> jsnx: yes, but that's not OO
18:40:26 <jsnx> mauke: it's not *all* of OO, sure
18:40:35 <mauke> it's sort of like member functions work in C++, though
18:40:43 <jsnx> aye
18:40:49 <jsnx> it *reminds* me of OO
18:40:49 <mauke> "lexical tunneling"
18:40:53 <jsnx> lolz
18:41:03 <shachaf> jsnx: Have you looked at State, by the way?
18:41:05 <wellwisher> yes it is the read instance
18:41:08 <mauke> I think I know exactly what you mean
18:41:13 <mauke> I agree :-)
18:41:19 <jsnx> shachaf: yes, earlier
18:41:38 <jsnx> shachaf: forget everything :(
18:41:55 <jsnx> s/forget/forgot/
18:42:19 <shachaf> jsnx: It may make more sense after you've seen Reader. :-)
18:42:50 <shachaf> jsnx: Where (Reader r a) corresponds to (r -> a), (State s a) corresponds to (s -> (a,s)).
18:43:17 <mauke> Reader gives you read access to implicit stuff
18:43:22 <mauke> State allows read/write
18:43:35 <mauke> (guess what Writer does)
18:43:40 <jsnx> mauke: is Reader read only, then?
18:43:48 <mauke> yes
18:43:52 <jsnx> ooh
18:43:58 <mauke> you can only read from the environment; you can't change it
18:43:58 <shachaf> jsnx: As read only as (r ->).
18:44:08 <jsnx> see, that's the kind of OO i like
18:44:31 <mauke> wow, more analogy
18:44:37 <jsnx> hehe
18:44:47 <mauke> 'this' works like an implicit function argument in C++
18:44:52 <sjanssen> there is also 'local', which runs a computation with a different environment
18:44:55 <mauke> and the prototypical Reader instance is (r ->)
18:45:20 <jsnx> i don't grok (r ->)
18:45:24 <jsnx> is that a type?
18:45:29 <mauke> it's a syntax error :-)
18:45:35 <jsnx> lolz
18:45:38 <mauke> it's half of (r -> a)
18:46:06 <jsnx> so, it's just another way to say (r -> a), basically
18:46:12 <jsnx> for any `a`
18:46:23 <shachaf> jsnx: (a -> b) is really ((->) a b).
18:46:31 <sjanssen> jsnx: yes, it's partial application of the (->) type constructor
18:46:36 <shachaf> jsnx: ((->) r) is partially applied.
18:46:42 <TSC> wellwisher: Maybe there's something wrong with your "lex" function, but something like this should work: readsPrec _ s = [IP (map read $ explode '.' s), ""] -- no error checking, though
18:46:56 <jsnx> aye
18:47:15 <mauke> > (do { x <- ask; return (x * 2) }) 21
18:47:16 <lambdabot>  42
18:47:48 <mauke> behold! the 'do' statement assembleth a function
18:47:57 <dobblego> ?type ask
18:47:59 <lambdabot> forall (m :: * -> *) r. (MonadReader r m) => m r
18:48:08 <jsnx> so in English, "Reader is (r ->)" means "Reader is an r to anything else"
18:48:23 <jsnx> ("anything else to be determined later")
18:48:33 <shachaf> jsnx: (r ->) is a MonadReader -- there are others.
18:48:46 <jsnx> shachaf: other Readers?
18:48:46 <shachaf> jsnx: And note that (forall a. r -> a) has a very different meaning.
18:49:02 <shachaf> jsnx: Yes, with an explicit newtype, for example.
18:49:10 <jsnx> shachaf: really? can you explain that? i was starting to think they mean the same thing
18:49:14 <mauke> @instances MonadReader
18:49:15 <lambdabot> r ((->) r), r (ErrorT e m), r (RWS r w s), r (RWST r w s m), r (Reader r), r (ReaderT r m), r (StateT s m), r (WriterT w m), r' (ContT r m)
18:49:49 <shachaf> jsnx: (Ignore all the Ts there except for ReaderT.)
18:49:58 <shachaf> (And RWST, I guess.)
18:50:04 <shachaf> @src Reader
18:50:04 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
18:50:21 <jsnx> @src id
18:50:22 <lambdabot> id x = x
18:50:38 <shachaf> newtype Reader r a = Reader { runReader :: r -> a }
18:50:48 <mauke> jsnx: it works for every type t, but it's a specific t each time
18:50:53 <shachaf> This just has an explicit newtype, so you have to unwrap/rewrap it.
18:51:48 <jsnx> shachaf: when you say unwrap/rewrap, you mean you are defining Reader in terms of itself?
18:52:21 <wellwisher> TSC: i still get the same error
18:52:25 <shachaf> jsnx: The newtype isn't "really" there, it only separates it with a type.
18:52:36 <jsnx> shachaf: woh
18:52:49 <mauke> heh
18:52:50 <shachaf> jsnx: But you have to use a function like runReader to run the Reader.
18:53:06 <jsnx> let's back up a minute
18:53:26 <mauke> jsnx: "newtype" has no runtime effect. it just introduces a new type having the same underlying representation as an existing type
18:53:27 <shachaf> jsnx: newtype is a lot like data in this context, if that helps.
18:53:58 <wellwisher> Could anyone help with http://hpaste.org/4553 ? I am trying to overide the Read instance of a type.
18:54:05 <dobblego> the 'decorator design pattern' it is called in pseudo-science world
18:54:06 <mauke> it's sort of between type and data. closer to data when programming.
18:54:21 <jsnx> mauke: so, in the above declaration: "let us make Reader of r a be a Reader with a runReader :: r -> a"
18:54:43 <mauke> yes
18:54:49 <jsnx> why is the runReader in braces? it looks like a record declaration, sort of
18:54:52 <mauke> it is
18:54:54 <shachaf> It is.
18:54:59 <shachaf> Just a named value.
18:55:06 <jsnx> oh, yes, interesting
18:55:10 <shachaf> You can also write "newtype Reader r a = Reader (r -> a)"
18:55:29 <jsnx> runReader (particular Reader) will extract the function
18:55:39 <jsnx> and then so what?
18:55:55 <jsnx> how does it get applied?
18:56:16 <shachaf> jsnx: If f :: Reader r a, runReader f :: r -> a.
18:56:45 <jsnx> and then, you apply it to an `r`, yes-no?
18:56:49 <mauke> yes
18:56:53 <jsnx> aha
18:56:56 <mauke> it's just a normal function by then
18:57:19 <jsnx> isn't `r` a Reader, too?
18:57:48 <mauke> no, r is any type you want
18:58:00 <jsnx> `r` is what this Reader is a Reader of?
18:58:37 <mauke> yes
18:58:48 <jsnx> so: `Reader r a` is a reader of `r`s that makes `a`s
18:59:06 <mauke> you win!
18:59:21 <jsnx> and you can have a Reader that is just a reader of `r`, while you don't know what `a` is yet
18:59:22 <pjd> r `Reader` a
18:59:29 * pjd ducks
18:59:43 <jsnx> and that is why people say `(r ->)`
18:59:58 <mauke> jsnx: do you know MonadReader?
19:00:04 <jsnx> mauke: know :(
19:00:22 <wellwisher> Could anyone help with http://hpaste.org/4553 ? I am trying to overide the Read instance of a type.
19:00:22 <mauke> it's the general interface supported by every reader
19:00:30 <mauke> @src MonadReader
19:00:31 <lambdabot> Source not found.
19:00:34 <mauke> :(
19:00:38 <jsnx> ;(
19:00:49 * jsnx tazes lambdabot
19:01:08 <jsnx> that'll teach it to leave its paperwork at home!
19:01:38 <jsnx> does using point free form tempt the monomorphism god?
19:01:51 <mauke> class (Monad m) => MonadReader r m | m -> r where ask :: m r; local :: (r -> r) -> m a -> m a
19:02:04 <mauke> that's the interface
19:02:37 <mauke> jsnx: yes
19:03:32 <jsnx> mauke: why is there a pipe in it?
19:03:43 <shachaf> jsnx: Functional dependency.
19:03:46 <pjd> jsnx: that's why you should always wear your amulet of -fno-monomorphism-restriction
19:03:46 <mauke> the m -> r part is a functional dependency
19:03:59 <shachaf> jsnx: It means that for a given m, there'll always be the same r.
19:04:06 <jsnx> pjd: but are the optimization issues actually resolved?
19:04:26 <mauke> what optimization issues?
19:04:27 <shachaf> Since m is actually (Reader r).
19:04:43 <shachaf> You have something like (instance MonadReader r (Reader r) where ...).
19:05:05 <pjd> jsnx: well, if you *want* a monomorphic type, you can always add the declaration anyway
19:05:09 <sjanssen> mauke: the MR exists so certain expressions that "look like constants" will be real constants
19:05:24 <jsnx> mauke: uch pattern bindings have different properties with respect to sharing (they're generally less shared than you want). In especially bad cases, without the MR, it is possible to have programs which run exponentially slower without type signatures than when signatures are added.
19:05:33 <jsnx> s/uch/such/
19:05:44 <jsnx> from: http://www.haskell.org/haskellwiki/Monomorphism_restriction
19:05:46 <lambdabot> Title: Monomorphism restriction - HaskellWiki
19:05:46 <mauke> jsnx: I doubt that
19:06:08 <mauke> it depends on the exact type signature you add
19:06:31 <mauke> sjanssen: but does that apply to point-free definitions of functions?
19:06:41 <mauke> I can see how foo = sqrt 42 might duplicate work
19:06:54 <jsnx> do point free definitions look like constants?
19:07:13 <wellwisher> sjanssen: Could you help me with http://hpaste.org/4553 ? I am trying to overide the Read instance of a type.
19:07:21 <mauke> yes
19:07:25 <sjanssen> mauke: possibly, if one of the functions can benefit from let floating
19:07:35 <mauke> hmm
19:08:13 <sjanssen> it can also be expensive to compute functions
19:08:29 <mauke> I was thinking of things like 'foo = return' vs. 'foo x = return x'
19:09:01 <jsnx> mauke: i think in the latter case, it looks like a constant
19:09:13 <jsnx> but then again, i'm still figuring this out
19:09:14 <monochrom> A function is a constant.
19:09:22 <sjanssen> mauke: yeah, the MR only harms there
19:09:37 <sjanssen> jsnx: no, the first is the one that "looks constant" according to the MR
19:09:49 <jsnx> sjanssen: oh, thanks
19:10:32 <geocalc> in what language whas the first ghc ?
19:10:38 <jsnx> c--?
19:10:46 <mauke> jsnx: haha, no
19:10:55 <jsnx> sjanssen: but does the first one lead to actual sharing?
19:11:02 <mauke> I think it was in haskell
19:11:03 <jsnx> mauke: c++?
19:11:09 <mauke> jsnx: hell no
19:11:16 <jsnx> mauke: really? wow.
19:11:22 <sjanssen> jsnx: no useful sharing in that case
19:11:33 <jsnx> sjanssen: but the second one?
19:11:41 <sjanssen> jsnx: in either
19:11:48 <jsnx> well, yes
19:12:08 <jsnx> sjanssen: but i mean, does the point free form allow for sharing in general?
19:12:37 <sjanssen> jsnx: possibly
19:13:23 <EvilTerran> wasn't the first ghc in interpreted haskell, and used only to compile the second ghc (from the same source, only to binary this time)? ;)
19:13:51 <mauke> I thought they used an existing haskell compiler (hbc?)
19:14:19 <jsnx> sjanssen: is there any difference between point free and pointful, in terms of sharing?
19:14:19 <LoganCapaldo> it's haskells all the way down
19:14:23 <EvilTerran> somewhere along the line, tho, someone wrote a haskell compiler or interpreter in C
19:14:38 <mauke> s/C/Lazy ML/
19:14:39 <jsnx> where does c-- come into all this?
19:14:39 <jaredj> ... that changes login.c
19:14:48 <jsnx> jaredj: lolz
19:14:56 <jsnx> hUnix
19:15:01 <EvilTerran> alternatively, LoganCapaldo may be right, and I'm engaging in grand heresy here <_<  >_>
19:15:06 <jaredj> hEh
19:15:12 <mauke> well, hugs is written in C
19:15:27 <sjanssen> jsnx: I think so, but it really depends on your compiler -- Haskell has nothing to say on the subject
19:15:29 <jaredj> "OBJECTION!"
19:16:00 <shachaf> > fix haskell
19:16:01 <lambdabot>  "GHC"
19:16:08 <mauke> hax!
19:16:12 <pjd> haha
19:16:23 <mauke> > haskell 42
19:16:24 <lambdabot>  "GHC"
19:16:26 <LoganCapaldo> awesome
19:16:33 <mauke> > haskell ()
19:16:35 <lambdabot>  "GHC"
19:16:39 <LoganCapaldo> bet binding ever
19:16:43 <LoganCapaldo> *best
19:16:47 <geocalc> lol
19:16:51 <shachaf> > haskell haskell
19:16:51 <lambdabot>  "GHC"
19:17:03 <LoganCapaldo> buffalo buffalo?
19:17:12 <mauke> buffalo buffalo buffalo.
19:17:43 <LoganCapaldo> hehe
19:18:10 <shachaf> > let ghc = haskell ghc in ghc
19:18:10 <lambdabot>  "GHC"
19:18:43 <jsnx> what is going on here?
19:19:03 <geocalc> "GHC"
19:19:04 <mauke> jsnx: someone defined haskell _ = "GHC"
19:19:26 <shachaf> > haskell jsnx
19:19:26 <lambdabot>  "GHC"
19:19:39 <LoganCapaldo> I challenge one of you geniuses to write a Buffalo class (and any needed instances) such that buffalo buffalo* is a valid haskell expression. You only get bonus points if you don't do buffalo = undefined
19:19:39 <nolrai> @t return (Just 'c')
19:19:40 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
19:19:43 <LoganCapaldo> :)
19:19:53 <nolrai> @type return (Just 'c')
19:19:54 <lambdabot> forall (m :: * -> *). (Monad m) => m (Maybe Char)
19:20:21 <nolrai> > fix fix
19:20:22 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -> a
19:20:22 <lambdabot>     Probabl...
19:20:52 <jsnx> :t fix
19:20:53 <lambdabot> forall a. (a -> a) -> a
19:20:59 <sjanssen> @type let buffalo = fmap in buffalo buffalo buffalo buffalo buffalo buffalo buffalo
19:21:00 <wellwisher> sjanssen: Could you help me with http://hpaste.org/4553 ? I am trying to overide the Read instance of a type.
19:21:00 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
19:21:00 <lambdabot>     Probable cause: `buffalo' is applied to too few arguments
19:21:00 <lambdabot>     In the fourth argument of `buffalo', namely `buffalo'
19:21:42 <jsnx> wellwisher: maybe you are missing an actual `read`
19:21:45 <shachaf> > id id id id id id id id 5
19:21:46 <lambdabot>  5
19:21:55 <mauke> LoganCapaldo: can I use -XFlexibleInstances?
19:21:56 <jsnx> > id id
19:21:56 <lambdabot>  Add a type signature
19:22:02 <jsnx> > id id :: Int
19:22:03 <lambdabot>  Couldn't match expected type `Int' against inferred type `a -> a'
19:22:04 <LoganCapaldo> mauke: definitely :)
19:22:18 <sjanssen> > lex "129.128.127.126"
19:22:19 <lambdabot>  [("129.128",".127.126")]
19:22:28 <shachaf> LoganCapaldo: buffalo = id doesn't count?
19:22:39 <LoganCapaldo> shachaf: I guess so
19:22:40 <sjanssen> wellwisher: I think the above is the root of your issue
19:22:50 <LoganCapaldo> but not very fun <g>
19:23:06 <int-e> > lexDigits "129.128.127.126"
19:23:07 <lambdabot>  [("129",".128.127.126")]
19:23:12 * LoganCapaldo wants to encourage abuse
19:23:25 <sjanssen> @type let { buffalo :: Functor f => (a -> b) -> f a -> f b; buffalo = fmap } in buffalo buffalo buffalo buffalo buffalo buffalo buffalo
19:23:26 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f2, Functor f1, Functor f) => f (a -> b) -> f (f1 (f2 a) -> f1 (f2 b))
19:23:42 <aFlag> I'm always behind on my ghc version :(
19:24:00 <wellwisher> all: i see
19:24:05 <shachaf> LoganCapaldo: Add a constraint, then?
19:24:18 <shachaf> LoganCapaldo: It has to return "buffalo", or at least be a normally-showable type?
19:24:24 <shachaf> That's probably not much harder.
19:24:33 <wellwisher> i chaned it to this but still the same problem: readsPrec _ s = [(IP (readAll (explode '.' s)), s)]
19:25:21 <sjanssen> wellwisher: 's' is the problem there
19:25:35 <sjanssen> wellwisher: read fails unless the result matches the pattern [(x, "")]
19:25:38 <wellwisher> what should it be?
19:26:41 <wellwisher> I see so it should be: readsPrec _ s = [(IP (readAll (explode '.' s)), "")]
19:27:13 <sjanssen> wellwisher: yeah, looks closer
19:36:00 <EvilTerran> what's the type-level fixed-point newtype again?
19:36:28 <EvilTerran> newtype Fix f = Fix (f (Fix f)) --?
19:39:55 <int-e> EvilTerran: yeah
19:39:59 <ptolomy> Should I be reporting it somewhere that my 500-or-so line program is taking 30 seconds to compile on GHC? Or is that to be expected for a relatively complex piece of code compiling with all optimizations turned on?
19:42:02 <TomMD> ptolomy: Does it have large numbers of 'let' statements?
19:42:47 <ptolomy> not really.
19:42:58 <ptolomy> it probably could use some more type annotations, though..
19:43:25 <TomMD> I suppose I would report it if it was a regression or I could narrow it down to a more trivial piece of code.  I'd likely ignore it otherwise, but hey, I'm appathetic.
19:44:20 <ptolomy> I think I'll just blame myself and forge ahead.
19:46:19 <sjanssen> ptolomy: what sort of hardware are you using?
19:46:21 <Brian`> hey.. does darcs work on windows too?
19:47:02 <ptolomy> sjanssen: Macbook..  2ghz, I would guess. Decent ram.
19:47:14 <TomMD> Brian`: To the best of my knowledge - yes.  But I've never used it.
19:47:16 <sjanssen> ptolomy: that does seem like a long time, then
19:47:48 <sjanssen> ptolomy: what version of GHC?
19:48:00 <ptolomy> sjanssen: 6.6
19:48:18 * ptolomy is eagerly awaiting 6.8 on macports.. his interpreter's benchmarks will get a free boost.
19:48:39 <sjanssen> ptolomy: oh, maybe not unreasonable then.  -fvia-c eats up a lot of time
19:56:14 * EvilTerran notes that he's successfully made a completely meaningless SKI calculus in haskell
19:56:33 <EvilTerran> the first line is "newtype Fn = Fn { (?) :: Fn -> Fn }". it's all downhill from tere.
19:57:13 <EvilTerran> I don't think this is going to yield anything interesting on the buffaloes front, tho
19:57:43 * EvilTerran was hoping to make buffalo the X combinator
19:57:51 <EvilTerran> but there's gonna be ?s everywhere
20:00:10 <EvilTerran> and I don't know what to do with all this stuff of type Fn once i've got it =/
20:01:56 <EvilTerran> ~/haskell $ mv buffalo.hs experiments/ski.hs
20:02:01 <EvilTerran> i'll think more about that later ;)
20:17:57 <TomMD> ?users
20:17:57 <lambdabot> Maximum users seen in #haskell: 434, currently: 392 (90.3%), active: 9 (2.3%)
20:19:17 <wy> Is there to get the additive identity of any type of class Num?
20:19:27 <wy> Is there a way...
20:19:30 <EvilTerran> 0 :: YourTypeHere
20:19:47 <EvilTerran> > 0 :: Complex Int
20:19:53 <lambdabot>   add an instance declaration for (RealFloat Int)
20:19:54 <lambdabot>     In the expression: 0
20:19:54 <lambdabot>   ...
20:20:01 <EvilTerran> > 0 :: Complex Double
20:20:08 <lambdabot>  0.0 :+ 0.0
20:20:08 <EvilTerran> > 0 :: Rational
20:20:09 <lambdabot>  0%1
20:20:51 <EvilTerran> etc
20:21:16 <wy> What if the type is a type variable? Can I say 0::a ?
20:21:36 <EvilTerran> if you've got the ScopedTypeVariables extension enabled, yes
20:21:59 <EvilTerran> normally, the compiler'll be able to deduce the right type, and you won't need to make it explicit anyway
20:22:13 <EvilTerran> failing that, there's always asTypeOf
20:22:17 <EvilTerran> @type asTypeOf
20:22:19 <lambdabot> forall a. a -> a -> a
20:22:23 <EvilTerran> @src asTypeOf
20:22:24 <lambdabot> asTypeOf = const
20:22:37 <EvilTerran> > 1 `asTypeOf` 2.0
20:22:38 <lambdabot>  1.0
20:22:43 <chessguy> glguy!!
20:22:51 <glguy> ?yow
20:22:52 <lambdabot> ... or were you driving the PONTIAC that HONKED at me in MIAMI last Tuesday?
20:23:38 <chessguy> miami.....oh, you're THAT guy?
20:24:13 <chadz> > 3.2 - 3.1
20:24:14 <lambdabot>  0.10000000000000009
20:24:20 <wy> Maybe I should make it precise. I was trying to instance Point into Num ;-)
20:24:25 <chadz> why does that precision error occur?
20:24:27 <wy> instance (Num a) => Num (Point a) where
20:24:28 <chessguy> woohoo! floats ftl
20:24:39 <wy> (+) p q  = Point (pointx p + pointx q) (pointy p + pointy q)
20:24:47 <chessguy> chadz, 0.1 can't be accurately represented in binary
20:24:47 <wy> fromInteger x = Point x 0::a
20:24:57 <wy> The last line doesn't work
20:25:34 <chadz> chessguy: the correct answer is printed from a printf in c
20:25:44 <wy> Or maybe I shouldn't instance it as a Num at all?
20:26:03 <chessguy> chadz, C is rounding
20:26:12 <chadz> ah
20:28:04 <chessguy> chadz, try this: double c = 10; while (!(c == 0.0)){ printf("%f",c); c -= 1.0; }
20:28:16 <chessguy> or whatever the equivalent code is that actually compiles
20:28:37 <wy> Anyway I can do without fromInteger. It's useless here
20:28:54 * chessguy hasn't written C in .... a few years
20:29:07 * chessguy thanks his lucky stars
20:33:56 <scodil> is there any support for concurrency in the ST monad?
20:36:22 <EvilTerran> wy, try fromInteger x = Point x 0
20:36:43 <EvilTerran> "foo bar :: Baz" parses as "(foo bar) :: Baz"
20:36:55 <EvilTerran> :: binds looser than everything
20:37:27 <nolrai> > splitAt 2 [1..10]
20:37:30 <lambdabot>  ([1,2],[3,4,5,6,7,8,9,10])
20:37:52 <wy> EvilTerran: It doesn't work because x is inferred as Integer. But Point takes a as input
20:38:46 <EvilTerran> ?type fromInteger
20:38:48 <lambdabot> forall a. (Num a) => Integer -> a
20:39:02 <Brian`> > splitAt 'a' "fjiesafdjf"
20:39:02 <EvilTerran> that's not a particularly great leap of inferrence
20:39:03 <lambdabot>  Couldn't match expected type `Int' against inferred type `Char'
20:39:11 <Brian`> > splitAt 3 "fjiesafdjf"
20:39:12 <lambdabot>  ("fji","esafdjf")
20:39:27 <EvilTerran> surprisingly, yes, the parameter of fromInteger is an integer
20:40:22 <wy> EvilTerran: Seems to be a chicken and egg problem
20:40:37 <EvilTerran> what the devil are you trying to do?
20:41:05 <wy> fromInteger x = Point 0 0 can be used as a place holder
20:41:49 <wy> But maybe Point shouldn't be a Num at all ?
20:43:21 <EvilTerran> fromInteger x = Point (fromInteger x) 0 --?
20:43:35 <nolrai> @ty //
20:43:36 <lambdabot> parse error on input `//'
20:43:41 <nolrai> @ty (//)
20:43:42 <lambdabot> forall i e. (Ix i) => Array i e -> [(i, e)] -> Array i e
20:46:14 <wy> EvilTerran: It works. Thanks!
20:46:27 <EvilTerran> do you understand *why* it works?
20:46:42 <wy> EvilTerran: Yes.
20:46:50 <EvilTerran> good :)
20:47:03 <wy> It called a's fromInteger
20:47:17 <wy> and converted the integer x to a
20:51:24 <wy> It's good that types are inferred for the variables and functions don't need to be prefixed by some class name.
20:53:48 <bos> i have a monad jargon question.
20:54:15 <bos> i've always taken "action" as meaning "a value with a monadic type", but i've never actually seen it defined.
20:54:23 <bos> it seems to be a loose piece of jargon.
20:54:28 <bos> does that sound right?
20:54:50 <EvilTerran> "a value with a monadic type" is right
20:55:08 <shachaf> bos: It does to me.
20:55:43 <EvilTerran> the idea being that the "action" on the left of a >>= is "run" in the process of evaluating it, followed by the "action" on the bind's right
20:55:57 <EvilTerran> but don't think too hard about that ;)
20:56:32 <scodil> how come there's castIOUArray and castSTUArray but no castUArray?
20:56:51 <chessguy> woohoo, haskell advertising in #javascript :)
20:57:04 <chessguy> er, ##javascript
20:59:15 <ddarius> I think it's common for "action" to be used specifically for IO.
20:59:34 <ddarius> But it's a purposely loose word
21:00:50 <bos> yes, exactly.
21:01:04 <EvilTerran> i feel that there's some connection between the concept of "action" and the order of evaluation that's enforced by monads
21:01:23 <EvilTerran> because actions have to happen, while values just... are
21:02:28 <EvilTerran> so it makes sense to talk about the order actions happen in, which doesn't make so much sense in the case of values (semantically, but this is especially apparent in a lazy language)
21:05:23 <scodil> maybe not even the order in which they happen, but rather that the 'happen' at all. rather than just being
21:05:30 <scodil> that they happen
21:05:54 <scodil> i guess thats the same thing
21:06:47 <bench> type confusion: rsp <- UA.get $ head ["url"]
21:06:51 <bench> works
21:07:22 <bench> but if i do urls<-getArgs; rsp<-UA.get $head urls
21:07:50 <bench> i get the following "Couldn't match expected type `[Char] -> t'"
21:08:00 <bench> and inferred type is 'IO ()'
21:09:20 <wolverian> hm, pxsl looks nice, except for the << >>, I want «» :) (re: planet haskell)
21:09:43 <EvilTerran> ?type System.Environment.getArgs
21:09:45 <lambdabot> IO [String]
21:11:54 <bench> evilTerran: i'm just confused about the error message, what's the expected type and inferred type here
21:12:16 <EvilTerran> what's UA?
21:13:19 <bench> UA is import Network.HTTP.UserAgent as UA
21:13:19 <bench>  
21:17:41 <nolrai> how whould one randomly reorder a list in haskell?
21:18:07 <glguy> There isn't a library function to do that
21:18:33 <glguy> but if you write a function to randomly remove and return one element from a list
21:18:38 <glguy> you could call that over and over
21:19:11 <nolrai> ok that will have to do i.
21:19:23 <nolrai> i guess
21:19:56 <TSC> Or you could implement some other shuffling algorithm
21:20:38 <wy> ?type 2.1
21:20:39 <lambdabot> forall t. (Fractional t) => t
21:20:58 <nolrai> oh you know i think already wrote a shufflingh algorithm, and its around here some whare.
21:22:50 <bench> EvilTerran, any insight?
21:23:14 <glguy> http://hpaste.org/4555
21:23:46 <nolrai> @ty sequence $ repeat getRandomR
21:23:47 <lambdabot> Not in scope: `getRandomR'
21:23:48 <EvilTerran> i can't find any docs for that module =/
21:24:02 <nolrai> @ty sequence $ repeat show
21:24:02 <lambdabot> forall a. (Show a) => a -> [String]
21:24:30 <wy> Why isn't the debugger working in my ghci? I tried to set a breakpoint with :break, but it doesn't work
21:24:44 <bench> i got it from http://www.dtek.chalmers.se/~tox/site/http.php4
21:24:45 <lambdabot> Title: Jonas - Haskell HTTP Library Improvement
21:25:56 <EvilTerran> huh. i dunno what's going on, the types look like they should be fine
21:26:49 <bench> yes, that's what's confusing, it compiled fine, only when i run it, i get that error
21:27:11 <ddarius> bench: Huh?  That's a type error.
21:28:05 <wy> I'm continuing a little for my experiment. Why doesn't data S a b = (Point a, Point b) work after I defined Point as: data Point a = Point {pointx, pointy :: a}
21:28:28 <ddarius> wy:  You always need a constructor.
21:28:41 <ddarius> Or perhaps you want a type synonym?
21:29:32 <wy> ddarius: I want to see if "type" is trying to construct a type from a polymorphic type by reducing its arity
21:29:43 <bench> ddarius, yes, loading it into ghci results in no complains
21:29:58 <bench> only when i try run it, i get that type error
21:30:21 <wy> ddarius: Oh I made a mistake
21:30:33 <monochrom> ( ... , ... ) is not supposed to be the syntax on the RHS.
21:30:40 <wy> This works: type S a b = (Point a, Point b)
21:31:01 <wy> So my guess is right :-)
21:31:28 <wy> This is quite consistent
21:32:47 <wy> How can I try those in lambdabot?
21:33:09 <glguy> you can't define new types in lambdabot
21:33:12 <EvilTerran> lambdabot only does expressions, not declerations; you can't
21:33:37 <desp> Does ghci use readline?
21:33:56 <ddarius> desp: Usually.
21:34:15 <dons> dcoutts: i've a cunning scheme for mmap on lazy bytestrings :)
21:34:42 <wy> :kind S gives * -> * -> *
21:34:57 <scodil> what's the story with the Functor instance for tuples? What is that supposed to mean?
21:34:57 <dons> mmap and virtual memory are very interesting things to play with from a lazy, GC'd language
21:36:29 <wy> What are the commands for lambdabot mean?
21:37:08 <EvilTerran> @listr
21:37:09 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
21:37:30 <EvilTerran> you can talk to lambdabot by privmsg if you don't want to disrupt the channel
21:37:32 <ddarius> @instances-importing Control.Monad.Instances MonadWriter
21:37:34 <lambdabot> w (ErrorT e m), w (RWS r w s), w (RWST r w s m), w (ReaderT r m), w (StateT s m), w (Writer w), w (WriterT w m)
21:38:33 <glguy> seems like there have been a couple of blog entries lately about using the Writer Monad as a backtracking monad (they haven't explicitly pointed this out)
21:38:38 <wy> EvilTerran: I'm privmsging him, but he didn't respond to my commands. What's the difference of @ : and > ?
21:38:53 <EvilTerran> are you registered on nickserv?
21:39:01 <wy> yes
21:39:11 <shachaf> wy: > is @run.
21:39:12 <EvilTerran> k. @ and ? are equivalent
21:39:19 <EvilTerran> :k StateT
21:39:20 <lambdabot> * -> (* -> *) -> * -> *
21:39:22 <oerjan> Writer? Backtracking?
21:39:25 <EvilTerran> @kind StateT
21:39:25 <lambdabot> * -> (* -> *) -> * -> *
21:39:25 <shachaf> wy: :t/:k are @type/@kind.
21:39:35 <shachaf> wy: Every command is @/?.
21:39:35 <EvilTerran> yeah, what shachaf said.
21:39:49 <shachaf> (And she's a "her".)
21:40:01 <EvilTerran> @vixen how are you this evening?
21:40:02 <lambdabot> i am wonderful, thanks for asking!
21:40:23 <bench> ddarius, any help on my typing question/confusion?
21:41:23 <wy> Thanks. I finally understand :-)
21:41:30 <ddarius> I suspect that you have some typo/syntax error where you are not applying something to enough values and you are ending in the (r->) monad.
21:43:37 <scodil> so the IArray class doesn't mention the index type, but all of its methods have an (Ix i => ...) constraint. I'm trying to write a custom instance, and I need Num i also, but it won't let me. Is there a way around this?
21:44:19 <oerjan> how are you actually _using_ the Num constraint?
21:44:32 <scodil> 2*i, 2*i+1, etc
21:44:55 <oerjan> i mean, in the array code
21:45:02 <scodil> like that
21:45:02 <bench> ddarius, check http://hpaste.org/4556
21:45:13 <bench> it seems that this shouldn't even compile
21:45:23 <oerjan> are you sure you don't want a tuple index instead?
21:45:38 <scodil> you can't put tuples in unboxed arrays
21:46:00 <scodil> i'm trying to write an adapter than makes an unboxed array of tuples out of a UArray
21:46:19 <scodil> so for (,) indexing is just 2*i,2*i+1, and so on
21:47:13 <wy> Let me do an analogy. Is type class equal to interface of Java?
21:47:16 <sjanssen> scodil: have you considered the DPH approach?
21:47:26 <scodil> sjanssen: no, what's that?
21:47:45 <ddarius> bench: Give debugAutoInfos an explicit type annotation.
21:47:49 <sjanssen> scodil: something like data TupArray i (x, y) = TupArray (UArray i x) (UArray i y)
21:47:56 <TSC> wy: I don't think "equal", but they are similar
21:48:14 <ddarius> Wait, nevermind.
21:48:23 <scodil> ouch
21:48:31 <ddarius> You are trying to apply a string to debugAutoInfos and it's not a function.
21:48:31 <wy> TSC: They define signatures for functions. Has multiple "inheritance", ...
21:48:37 <oerjan> scodil: is _that_ what you are trying to do?
21:48:57 <scodil> uh, in the most near-sighted way, yes
21:49:01 <oerjan> @src Ix
21:49:01 <lambdabot> class (Ord a) => Ix a where
21:49:01 <lambdabot>     range           :: (a,a) -> [a]
21:49:01 <lambdabot>     index           :: (a,a) -> a -> Int
21:49:01 <lambdabot>     inRange         :: (a,a) -> a -> Bool
21:49:01 <lambdabot>     rangeSize       :: (a,a) -> Int
21:49:03 <wy> and if you want to implement it, you must implement all the functions specified
21:49:25 <oerjan> scodil: you are aware you can get from Ix to Int with the index function?
21:51:50 <wy> Sum types are abstract classes, and product types are normal classes...
21:52:20 <bench`> anyone can help me understand the errors in http://hpaste.org/4556
21:53:03 <scodil> oerjan: but how to get back? this is for unsafeArray. If someone calls unsafeArray (l,u) for the tuple array, i need to call unsafeArray (2*l,2*u) on the inner array
21:53:55 <oerjan> scodil: you don't get back
21:54:08 <pjd> wy: type classes (can) come with default implementations, too, so they're more like abstract classes
21:54:12 <oerjan> but usually you don't need to
21:54:18 <scodil> in this case I do
21:54:28 <scodil> unsafeArray takes bounds in Ix form, not Int form
21:54:40 <waterson> would this be an appropriate forum to ask a question about a failed cabal install?
21:54:47 <oerjan> bench`: your debugAutoInfos has no argument, but you are calling it with one
21:55:30 <wy> pjd: Can there be name conflicts?
21:55:45 <pjd> wy: but they're like generic functions, too, in that there's no predefined "instance" object
21:56:02 <pjd> wy: conflicts?
21:56:11 <scodil> There should be an inverseIndex method for Ix
21:56:26 <glguy> > (62/3)^3
21:56:28 <lambdabot>  8826.962962962964
21:56:36 <wy> pjd: I see. Because the functions are in the same name space, there couldn't be any conflicts.
21:57:13 <wy> Thus two classes can't have functions with the same name?
21:57:30 <pjd> oh, sorry, i read misparsed your question
21:57:54 <oerjan> scodil: if (l,u) becomes (2*l,2*u) then you are only getting every fourth spot?
21:57:59 <pjd> yes, that's right
21:58:13 <pjd> modulo imports
21:59:09 <pjd> e.g. you can import Prelude hiding (+), to define your own version
21:59:11 <wy> pjd: Do the implemented class functions usually just call other unimplemented class functions to make some default behavior?
21:59:12 <scodil> oerjan: no, say its complex numbers. I want to map n complex numbers to 2n real numbers. To index the ith complex number I look up the (2*i)th and (2*i+1)th real numbers
22:00:37 <oerjan> you mean complex numbers as _indices_?
22:00:43 <pjd> wy: usually, a type class has a "minimum implementation", which the other methods have default implementations in terms of
22:01:10 <scodil> what? No, the bounds of an array are a tuple, (l,u), l is the lowest index, u is the highest. I'm not talking about 2d arrays
22:01:45 <oerjan> misunderstood
22:03:05 <pjd> wy: for example, the minimal implementation of Ord is either compare or (<=)
22:03:35 <oerjan> wouldn't it be easier to wrap in an extra tuple? say l -> (l,0) for the real part, (l,1) for the imaginary
22:03:45 <pjd> all the other comparisons are defined in terms of them, by default
22:03:51 <scodil> yeah that's a good idea
22:04:08 <pjd> (but you can provide more efficient implementations)
22:04:12 <wy> pjd: So other functions will usually depend on them, or they don't need to exist. right?
22:10:12 <nolrai> @hoogle nub
22:10:13 <lambdabot> Data.List.nub :: Eq a => [a] -> [a]
22:10:13 <lambdabot> Data.List.nubBy :: (a -> a -> Bool) -> [a] -> [a]
22:12:26 <nolrai> is there a reson not to set -fallow-undecidable-instances?
22:12:53 <ddarius> Uh, because you want the type checker to terminate.
22:13:15 <ddarius> Also, unless you know what you are doing such cases usually mean you have an error somewhere.
22:14:43 <nolrai> Ok then, what does "Constraint is no smaller than the instance head" mean?
22:16:53 <oerjan> that's a termination condition.  makes sure that your types don't keep growing while chasing instances, i guess
22:17:55 <oerjan> the constraint is the part to the left of =>, the instance head to the right.
22:18:38 <nolrai> so what does it mean for one to be smaller then the other?
22:19:14 <oerjan> would you mind showing the instance ... where part?
22:19:26 <nolrai> no
22:19:26 <nolrai> instance (MonadTrans mt, RandomMonad rm, Monad (mt rm)) => RandomMonad (mt rm) where
22:19:26 <nolrai>     getRandomR = lift . getRandomR
22:19:30 <nolrai> gha
22:19:53 <nolrai> oh wait it workd
22:20:03 <nolrai> pasting that is.
22:20:57 <nolrai> RandomMonad is my class.
22:21:03 <oerjan> Monad (mt rm) is the same size as RandomMonad (mt rm) (i guess the constraints are all the parts separated by commas there)
22:21:37 <oerjan> except it's strange not to allow that
22:21:48 <oerjan> or, no
22:22:12 <ddarius> I'm surprised that's the first thing it complains about.
22:22:20 <bench`> oerjan, thanks
22:22:42 <nolrai> what else is wrong?
22:22:47 <oerjan> hm do you actually _need_ that constraint? doesn't it follow from the other two?
22:23:00 <nolrai> I think it does yes.
22:23:40 <oerjan> or wait, maybe not
22:24:40 <oerjan> it seems the MonadTrans class is not that strong
22:25:05 <nolrai> I still dont know what it means for a constrant to be the same size as the head, is that talking about the sets that satisfy them?
22:25:28 <oerjan> no, it's the actual type structure
22:25:51 <nolrai>  ?!
22:25:59 <oerjan> it's so the type expressions won't keep growing
22:27:06 <oerjan> Monad (mt rm) = 3 tokens, RandomMonad (mt rm) = 3 tokens, and the same number of each variable
22:28:07 <nolrai> but you can say instance Integral a => MyClass a can't you?
22:28:12 <oerjan> intuitively that is.  i don't know what exact measure ghc uses.
22:28:44 <oerjan> that's a good question, and why i thought it was strange
22:30:19 <oerjan> looks to me like an ugly corner case that _should_ be allowed
22:30:23 <wy> :t ([])
22:30:25 <lambdabot> forall a. [a]
22:31:31 <wy> This one is a little different. It seems to take variable length of arguments, but this is not shown in its type
22:31:59 <oerjan> wy: that's not the [a,b] thing, only [] with no arguments
22:32:03 <ddarius> You can't say instance Monad m => Functor m
22:32:09 <wy> oh, sorry. That's only the empty list
22:32:48 <wy> So [a,b,c] is syntactic sugar ?
22:32:57 <oerjan> yep, = a:b:c:[]
22:33:18 <nolrai> ddarius: so what can i say instead?
22:33:34 <wy> good. consistent again
22:34:38 <ddarius> @source Control.Monad.State
22:34:39 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/State.hs
22:35:01 <ddarius> @source Control.Monad.State.Lazy
22:35:01 <lambdabot> Control.Monad.State.Lazy not available
22:36:32 <ddarius> nolrai: You just can't capture that pattern all in one instance declaration.
22:40:22 <bench`> is there a jason rpc library for haskell?
22:40:54 <nolrai> so how does one break up an instance declartion? or do I have to redeclare it for each Transeformer?
22:43:07 <ddarius> Essentially, yes.  Look at the code in the mtl.
22:43:47 <bench`> or is there a library to serialize a data type using jason format?
22:44:11 <roger`> bench`: json?
22:50:20 <bench`> roger, yes json,
22:52:51 <roger`> bench`: a quick search of the haskell wiki should show what's available
22:53:05 <ddarius> @where hackage
22:53:06 <lambdabot> http://hackage.haskell.org/
22:54:42 <bench``> roger, or is there a lib to serialize any data type in xml format
22:57:44 <roger`> bench``: did you try the one in HAppS-Data?
22:58:15 <bench``> roger, no, is that something separate from Happs?
22:58:33 <roger`> bench``: yes, if you goto the HAppS website it shows the repo for checking out HAppS-Data with darcs
22:59:02 <bench``> roger, is that something you've used?
22:59:24 <roger`> bench``: I've built it and read some of the source briefly, but I've not used it.
23:00:11 <bench``> roger, is that (and happs) the best for building web apps with haskell?
23:00:52 <roger`> bench``: that's a matter of opinion.
23:01:31 <bench``> roger, understand, i'm just wondering which one should i try first
23:02:18 <nolrai> is there a way to allow multiple data types to have fields that are named the same thing?
23:02:23 <bench``> i want to setup a simple server that accepts json/xml rpc and/or web service calls
23:03:01 <oerjan> nolrai: not fields, no.
23:03:16 <roger`> bench``: http://haskell.org/haskellwiki/Applications_and_libraries/Web_programming - start evaluating your options.
23:03:17 <lambdabot> http://tinyurl.com/253xhy
23:05:31 <bench``> roger, thanks
23:05:34 <oerjan> nolrai: you can have a data type that has the common part and takes the rest as a parameter.  but you'll get an extra nested constructor that way.
23:06:33 <oerjan> or you can use class methods in some ways, but those don't give you pattern matching.
23:08:36 <oerjan> also, multiple data constructors of the same type can share fields.
23:10:48 <nolrai> yeah i might just use a class method, but its going to be clunky, this is one place where the OO idea of inheritance would work a lot better.
23:11:19 <nolrai> because it can handel holding the data (not just the functions).
23:11:44 <sclv> why do you need to inherit a data structure!?
23:12:04 <nolrai> because both fleets and planets have owners.
23:12:36 <nolrai> so i want to be able to call there owner the same thing, because it is the same thing.
23:12:59 <nolrai> ^ replace there whith thier
23:13:13 <nolrai> or rather their
23:13:35 <sclv> nolrai: will you ever have any code polymorphic on this -- i.e. where you might be talking about a fleet or a planet but won't know until runtime?
23:14:36 <nolrai> no so i will proboly not use a class, and just call one fleetOwner and another planetOwner, but that's rough. but do-able.
23:15:14 <quicksilver> nolrai: data Entity = Fleet { owner :: Person, ... } | Planet { owner :: Person, ... }
23:15:32 <quicksilver> nolrai: that has owner :: Entity -> Person which works uniformly on Fleets and Planets
23:18:21 <quicksilver> there are other ways of modelling data inheritance, too
23:18:52 <quicksilver> data Planet = Planet {..}; data Fleet = Fleet {...}; data Owned a = Owned Person a
23:19:10 <quicksilver> then Owned Planet is planet with owener, Owned Fleet is fleet with owner and Owned a is polymorphic.
23:19:13 <nolrai> Thats how to do it.
23:19:27 <nolrai> quicksilver++
23:19:50 <nolrai> geting new ways to tranlate thoughts is very nice.
23:19:56 <oerjan> that was my second suggestion.  no one understands me :(
23:20:12 <oerjan> er first actually.
23:20:19 <quicksilver> ;)
23:26:04 <nolrai> I some how read your suggestion backwards, as in i could put the new datatype inside planet and fleet, whitch if im just moving one thing doesnt do anything.  although on looking at them again they realy share three things so i might do that.
23:29:53 <nolrai> why does "type Name = Name" compile?
23:30:29 <oerjan> it does? o_O
23:31:34 <nolrai> no
23:32:02 <nolrai> I must have deleted somthing sence i last compiled.
23:32:14 <nolrai> sorry
