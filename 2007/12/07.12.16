00:00:18 <ac> dons: Yeah I see you could do a lot with xhtml combinators quite nicely
00:00:31 <dons> esp. if you combine them with css
00:00:38 <dons> so that the xhtml just adds css tags to haskell values
00:00:42 <ac> dons: perhaps I should just use xhtml
00:00:44 <dons> but the markup sort of happens on the css side
00:00:49 <Sizur> ac: pageNotFound = renderHtml $ (header $ thetitle << "404") +++ (body $ h1 << "Page Not Found")
00:00:55 <dons> Sizur: :)
00:01:11 <dons> deceptively short
00:01:23 <ac> Sizur: where does the body string come from?
00:01:40 <ac> Sizur: it has to be defined in source somewhere, and Haskell doesn't even have multiline strings as far as I can tell
00:01:53 <dons> it does have multiliine strings :)
00:01:53 <ddarius> Haskell 98 should have included GADTs?
00:02:04 <dons> > "foo /        / bar"
00:02:05 <lambdabot>  "foo /        / bar"
00:02:07 <allbery_b> sure it does.  \(newline)\
00:02:13 <dons> > "foo \n\        \ bar"
00:02:13 <lambdabot>  "foo \n bar"
00:02:16 <ac> don't you have to escape each newline?
00:02:16 <Sizur> ac: it's a function, you can pass it an i18n controller
00:02:26 <ac> Sizur: what's an i18n controller?
00:02:29 <dons> ac, yeah. or use unlines [ "foo", "bar" ]
00:02:32 <dons> so its not a here doc
00:02:39 <dons> but sometimes useful
00:02:56 <allbery_b> someone did some TH to fake heredocs, I think it's on hackage
00:03:04 <wy> What's the name of the function like "assoc" that look up an assoc list?
00:03:06 <Cale> ddarius: No, just the particular feature which is only enabled at the moment if you use the GADT syntax.
00:03:19 <oerjan> :t lookup
00:03:20 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
00:03:23 <bench`> dons: for web integration with apache/lighthttp, what do you use?
00:03:25 <Cale> ddarius: Class restricted data declarations do the wrong thing in H98.
00:03:33 <wy> oerjan: Thanks!
00:04:01 <Sizur> ac: where's what I did for happs: pageNotFound lang req = (header $ thetitle << I18n.pageNotFound lang) +++ (body $ h1 << I18n.pageNotFound lang +++ h2 << show req)
00:04:02 <wy> Actually my questions is that it seems to be more reasonable to return a Maybe type than raise an exception?
00:04:19 <Sizur> I18n here is simply a module with functions
00:04:21 <oerjan> wy: usually yes
00:04:28 <Cale> ddarius: (they do something almost completely useless rather than what anyone would expect them to do)
00:04:34 <allbery_b> or even Monad m => m a
00:04:39 <oerjan> exceptions can only be caught in IO
00:04:53 <ac> Sizur: I'm not familiar with this "I18n" thing?
00:04:58 <allbery_b> (so you can use a list or Either String instead)
00:05:12 <ddarius> Cale: I'm well aware that they are useless, but I'm not sure if they should have been in Haskell 98.
00:05:42 <Sizur> ac: in my case this module simply contains functions pattern matching to language and generating a string
00:05:55 <bench`> Sizur, is happs reasonable to use? i briefly looked at the intro, the example seems complicated -- but maybe it's because i'm a newbie
00:05:56 <oerjan> wy: there are also the Either and ErrorT monads for simulating exceptions in pure code
00:05:56 <ddarius> Of all the Reports, Haskell 98's is the one least likely to make such a change.
00:06:22 <oerjan> if you want something more fine-grained than just simple failure
00:06:30 <Cale> Heh, so since H98 sucks in other ways, it seems consistent that it should suck in that way too? :)
00:06:31 <Sizur> bench`: it's rather noob unfriendly. but once you're over the initials, it's great
00:07:43 <ddarius> Cale: Haskell 98 was much more conservative than the others it seems and adding bounded local existential quantification seems like a big step.
00:07:44 <bench`> Sizur, anyone use it for  production
00:07:56 <Cale> ddarius: No, not existentials.
00:08:00 <ddarius> !paste
00:08:01 <hpaste> Haskell paste bin: http://hpaste.org/
00:08:07 <dons> the fastcgi binding is fine, too.
00:08:10 <Cale> Er...
00:08:27 <Cale> I suppose it's a little like existentials, but I don't think you can actually call it that.
00:08:41 <dons> happs has historically been complicated, but it is a complete framework. i think its getting simpler
00:08:48 <dons> the performance is also good
00:08:55 <dons> much better than ror, for example
00:08:56 <dons> :)
00:08:58 <ac> In case I was misunderstood, when I said "Haskell wasn't the right tool" I just meant "I wasn't comfortable enough with it yet".
00:09:07 * ddarius should look at happs and see what this "complication" is.
00:09:13 <Cale> You still have the type parameter
00:09:14 <Sizur> bench`: depends how you define production. if it's for enterprise integration (for example) then not yet. the api is still a little bit unstable, and that's good, let it grow
00:10:00 <Cale> It's just that you need to store a pointer to the relevant typeclass dictionary along with the data.
00:10:31 <Sizur> bench`: thing is, you can generate website very very quickly with it
00:10:53 <Cale> Which frees the functions which pattern match against that constructor from having to provide the instance themselves.
00:11:02 <ddarius> Cale: You're right, though typing-wise I suspect that even more complicated/inconsistent-seeming/special than bounded local existential quantification.
00:11:49 <Cale> hmm
00:12:03 <bench`> Sizur, is it? the simple example on the happs site  doesn't seem easy/simple
00:12:15 <bench`> dons: is happs really faster than ror?
00:12:31 <allbery_b> ruby is *very* slow
00:12:34 <ddarius> bench`: Why would you think it wouldn't be?
00:12:43 <dons> yeah, compiled native code, type erasure, serious compiler..
00:13:00 <Sizur> http://code.google.com/p/happs/wiki/TheBasics
00:13:00 <lambdabot> Title: TheBasics - happs - Google Code
00:13:16 <dons> there was a set of benchmarks done this week
00:13:26 <bench`> dons: i'm also concerned about it be a complete framework -- database guys have been working at it for the past 30 years
00:13:59 <ddarius> bench`: My understanding is that it doesn't keep you from using databases in the traditional way.
00:14:00 <Sizur> I've compared happs built-in server with jetty. jetty was atleast 2x faster. but remember jetty is only a server and a 10 year old one
00:14:24 <allbery_b> > flip concatMap [(:[]) . head,show . length . drop 2,(:[]) . last] ($ "internationalization")
00:14:24 <bench`> dons: but ror doesn't reinvent db, or web server, etc
00:14:25 <lambdabot>  "i18n"
00:14:37 <bench`> Sizur, thanks for the link
00:14:44 <dons> right. its a different kind of framework
00:14:49 <ddarius> bench`: And that should make it faster?
00:14:53 <dons> i'm not saying its the best model. but its nice for some siutations
00:15:09 <dons> this is the main reason for the performance difference, http://shootout.alioth.debian.org/gp4/chartvs.php?test=all&lang=ghc&lang2=ruby
00:15:10 <lambdabot> http://tinyurl.com/39vxnb
00:15:23 <dons> anything you write in that will have performance issue
00:15:53 <bench`> dons: understood your point
00:15:56 <dons> happs isn't perfect by any means, its rather difficult to compile, last i checked.
00:16:08 <dons> and there's not a lot of apps written for it
00:16:22 * shachaf wonders if there's going to be a presentation related to Haskell in the next LFNW.
00:16:34 <dons> anyway, just another system to throw on the pile of options
00:16:53 <bench`> dons; what are the other options that you consider worth looking at?
00:17:00 <roger`> I compiled HAppS last week in 195 steps (some missteps) http://jottit.com/39hm4/ - sp didn't work at first then I went with cabal
00:17:01 <lambdabot> Title: Home
00:17:49 <bench`> ddarius, my point was that just having the language itself faster didn't mean the framework will be faster
00:18:15 <wy> oerjan: So we only raise exceptions in monads?
00:18:15 <ddarius> bench`: I understand that, you never answered my question though, why do you think it wouldn't be?
00:19:12 <oerjan> wy: the ErrorT/Either/Maybe kind is not the same as the Control.Exception kind
00:19:32 <oerjan> the latter are "real" exceptions, and can be raised anywhere
00:19:34 <ddarius> Of course you still have to catch those in the IO monad so...
00:20:28 <wy> oerjan: I need more context to discuss the topic
00:21:09 <oerjan> @src Either
00:21:09 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
00:21:17 <oerjan> argh!
00:21:27 <ddarius> Yeah, @src seems to have lost a lot of stuff.
00:21:39 <ddarius> @src Maybe
00:21:39 <lambdabot> data Maybe a = Nothing | Just a
00:22:39 <alexj> dons: hope to make the compile process easier first thing next week
00:22:39 <oerjan> wy: the Maybe/Either/ErrorT way is to add an extra constructor to your data type whose values indicate exceptional circumstances in some way.
00:22:47 <allbery_b> wy: we use monads because they allow short-circuiting, so when an "exception" is raised it aborts processing
00:22:52 <Sizur> alexj: great!
00:23:00 <allbery_b> and returns the "exception" immediately
00:23:08 <bench`> ddarius, i haven't looked at the happs' impl, but i doubt that impl of ACID/DB stuff would be faster
00:23:10 <oerjan> such as the Nothing of Maybe, or the Left constructor of Either
00:23:21 <bench`> than traditional DB stuff
00:23:27 <wy> You mean jump through multiple layer of contexts?
00:23:37 <allbery_b> @src Maybe (>>=)
00:23:37 <lambdabot> (Just x) >>= k      = k x
00:23:37 <lambdabot> Nothing  >>= _      = Nothing
00:23:48 <alexj> bench: good reason to be faster because you are not jumping through multiple layers of parse.
00:23:50 <ddarius> bench`: It's an in memory database.  If your stuff fits in memory I suspect it is much faster than a disk-based one.  Further it is custom and tightly integrated which is more benefits.
00:24:05 <allbery_b> so when it sees Nothing (the "exception") it just passes it on instead of performing the next calculation
00:24:07 <oerjan> @instances-importing Control.Monad.Error MonadError
00:24:08 <lambdabot> IOError IO, e (Either e), e (ErrorT e m), e (RWST r w s m), e (ReaderT r m), e (StateT s m), e (WriterT w m)
00:24:17 <alexj> ddarius is better at advocacy than me.
00:24:29 <allbery_b> likewise for Either, a Left is passed on directly by (>>=) bypassing further calculations
00:24:30 <wy> I see it as that for Maybe type, every layer must do a judgement if it's a Nothing, etc... But exception is not judged by each layer
00:24:52 <allbery_b> wy: the point of the monad is that the judgements are done "automatically"
00:25:43 <wy> I see. I need to find a good way to learn monads. I have really understood them
00:25:44 <ddarius> Bah!  If you were to give a denotational semantics of a language with exceptions you'd use something that works out to be exactly like the Either monad (this is how monads entered into programming).  In Haskell, we essentially directly implement the semantics.
00:26:05 <allbery_b> at the end you need to check for a Nothing (or Left x) resukt, but intermediate stps you let the monad deal nstead of having to write your own checking
00:26:09 <wy> Can you introduce an excellent tutorial about it?
00:26:16 <ddarius> @where wadler
00:26:16 <lambdabot> http://homepages.inf.ed.ac.uk/wadler/
00:26:35 <shachaf> > Left 1 < Right 1
00:26:35 <Sizur> wy: there. read 500 pages :P
00:26:35 <lambdabot>  True
00:26:44 <ddarius> Go there, read his papers on monads, particularly "The essence of functional programming" or "Monads for Functional Programming"
00:26:47 <wy> allbery_b: That's a tedious job to write those code
00:26:51 <allbery_b> @go you could have invented monads
00:26:52 <lambdabot> http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
00:26:52 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ...
00:27:12 <ddarius> Both of those are enjoyable, comprehensive, authoritative and well-written.
00:27:28 <allbery_b> wy: right, which is why you use the monad --- which lets all that code exist in a library (the one for Either or Maybe)
00:27:28 <Sizur> completely agree with ddarius
00:27:35 <allbery_b> and applies it automatically
00:28:55 <wy> allbery_b: This is somewhat similar to the Show class. It seems there is some metalevel is producing the code for you?
00:29:15 <allbery_b> the magic of monads is that the code can be produced once and exported as a library
00:29:16 <ddarius> wy: Monads are just library functions.
00:29:24 <allbery_b> as part of the definition of (>>=)
00:29:33 <ddarius> There is no magic at all.
00:29:51 <allbery_b> so as long as you use (>>=) (or do notation, which reduces to the same thing), the library does the exception foo for you
00:30:27 <allbery_b> you might prefer (=<<) which is just (>>=) with the arguments reversed so ti looks more like (.)
00:30:49 <ddarius> (=<<) looks more like ($)
00:30:57 <wy> Thanks. I've read sigfpe's article, but maybe I didn't really applied the ideas. Now I realized in the context of exception, how it works.
00:31:26 <allbery_b> so now it's just function composition, but with exception handling buried in the monadic type's definition of (=<<)
00:31:38 <allbery_b> so you don't have to write it explicitly, it's just there
00:32:33 <wy> I want to read it again and think
00:33:15 <ddarius> wy: Again, I highly recommend Wadler's papers.
00:33:37 <wy> ddarius: I'll read them when their site is up again ;-)
00:33:50 <ddarius> @google "The essence of functional programming"
00:33:51 <lambdabot> http://citeseer.ist.psu.edu/wadler92essence.html
00:33:51 <lambdabot> Title: The Essence of Functional Programming - Wadler (ResearchIndex)
00:35:28 <wy> ddarius: Thanks! Is he a big guy in FP?
00:35:34 <ddarius> Hah
00:35:41 <wy> So many important papers
00:36:17 <Gyde> morning, anybody give a few idears on some optimising of a code I made for a tetravex solver..I put it here http://hpaste.org/4533 with a comment in the middel explaining the parts which I think needs optimising
00:36:48 <ddarius> wy: Philip Wadler is one of the authors of the Haskell 98 Report
00:37:57 <wy> nice paper
00:38:39 <ddarius> In fact, he's one of the editors of the Haskell 1.0 Report.
00:38:49 <wy> The abstract is answer my immediate questions
00:42:47 <wy> This is really a wonderful introduction.
00:44:23 <ddarius> Wadler knows how to write.  The whole paper is fairly entertaining, outright funny at times.
00:45:28 <wy> Thank you so much! I'm also wondering why those things are so related. What's the relationship between them and S5 modal logic... It seems they are telling the same story.
00:47:54 <oerjan> sounds like you want the Curry-Howard isomorphism next :)
00:48:11 <ddarius> wy: Via the Curry-Howard correspondence, monadic terms are proofs of propositions in S5 modal logic.
00:48:59 <wy> And modal logic is describing the possible worlds... so ...
00:49:31 <wy> fascinating topic
00:49:55 <oerjan> so monads are possible worlds of computation...
00:51:53 <wy> oerjan: So "M a" means ...
00:52:49 <oerjan> there is a possibility you might get an a?
00:53:02 * oerjan waves his hands wildly
00:54:00 <wy> Does "M" mean necessarily or possibly?
00:55:11 <scook0> intuitively, "possibly" sounds more likely
00:55:12 <oerjan> don't know, but my intuition is possibly
00:55:35 <scook0> :t (>>=)
00:55:36 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
00:55:59 <scook0> Maybe a -> (a -> Maybe b) -> Maybe b
00:56:20 <oerjan> perhaps comonads are necessity?
00:56:31 <scook0> :t (=>>)
00:56:32 <lambdabot> Not in scope: `=>>'
00:56:36 <scook0> :(
00:57:06 <scook0> w a -> (w a -> b) -> w b is cobind, I think
00:57:11 <oerjan> lessee, the type should be a theorem
00:58:01 <ddarius> wy: lax logic
00:58:03 <oerjan> hm, m a -> (a -> m b) -> m b  could go either way, couldn't it
00:58:24 <ddarius> @google "A Judgemental Reconstruction of Modal Logic"
00:58:25 <lambdabot> http://www.cs.bham.ac.uk/~vdp/publications/IMLA-papers.htm
00:58:36 <oerjan> er wait, no
00:58:43 <Gyde> repost, if anybody got up in the mean time ;) .. good morning, anybody give a few idears on some optimising of a code I made for a tetravex solver..I put it here http://hpaste.org/4533 with a comment in the middel explaining the parts which I think needs optimising
00:58:52 <oerjan> the a -> m b need not be true in _all_ worlds, just this one
00:59:28 <scook0> so a in any world would have to prove b in all worlds
00:59:53 <ddarius> lax logic arises when you have m a be: a is possibly necessary
01:00:12 <oerjan> o_O
01:00:40 <oerjan> that sounds lax yeah
01:01:34 <oerjan> hm, is that because m is the composition of adjoint functors, one representing necessary and one possible?
01:02:15 * oerjan doesn't know if he is making sense
01:02:56 <ddarius> oerjan: The possibility modality isn't (immediately) a functor.
01:03:14 <ddarius> (a -> b) -> Pa -> Pb doesn hold only N(a -> b) -> Pa -> Pb
01:03:36 <oerjan> ah
01:05:13 <oerjan> but N(a -> b) -> Na -> Nb, is N an Applicative? :)
01:05:25 <ddarius> However, the "intermediate" category might be able to be one where, say, all arrows are of the form N(a -> b) in which case it might be able to be done after all.
01:05:44 <oerjan> er wait, no a -> Na
01:06:07 <ddarius> Applicative is short for Applicative Functor.
01:09:01 <arossato> dcoutts: for xmobar -threaded is not needed. it should be useful in multicore systems, though
01:09:01 <lambdabot> arossato: You have 1 new message. '/msg lambdabot @messages' to read it.
01:27:29 <wy> Can monads be implemented as libraries?
01:27:53 <oerjan> @docs
01:27:53 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
01:28:05 <oerjan> look at the section Control.Monad.* :)
01:35:12 <wy> What's the point here?
01:36:03 <wy> Oh I see...
01:36:31 <wy> This is really a big thing
01:36:32 <oerjan> most of those modules contain library defined monads
01:37:16 <wy> continuations, and those crazy systems course headaches
01:43:52 <dcoutts> arossato: ok, great
01:43:52 <lambdabot> dcoutts: You have 2 new messages. '/msg lambdabot @messages' to read them.
01:44:03 <dcoutts> arossato: thanks
01:46:02 <dcoutts> Lemmih: what would you suggest for sdist and foreign bindings?
01:46:38 <dcoutts> Lemmih: I was thinking of allowing wild cards, and also providing a distcheck target that builds using the tarball so you can check if anything was missing
01:49:55 <Lemmih> Perhaps an 'sdist {add|remove} [files]'.
02:04:21 <dcoutts> Lemmih: hmm? how would that work?
02:04:35 <dcoutts> you mean it'd modify the .cabal file?
02:07:33 <Lemmih> Yeah.
02:09:22 <wy> ddarius: Do you have Wadler paper's code? I can't copy it into the editor.
02:14:19 <ddarius> wy: No, but there isn't too much to type and further modernized (but otherwise identical) versions of all the monad implementations are what is in Control.Monad.* (whose source is readily available)
02:15:21 * ddarius hugs Yoneda's Lemma.
02:16:43 <wy> Alright. Maybe I don't need to type it in. Just read
02:18:51 <oerjan> well, except the backward state monad...
02:19:01 <ddarius> True.
02:19:23 * oerjan is reading too
02:19:31 <wy> Hmmm I'd better type it in. It's really a good practice
02:20:00 <ddarius> It's really not a lot a code, so I would recommend it as well.
02:25:25 <wy> Is there a good way to align the ='s nicely?
02:26:29 <oerjan> er, the tab key?
02:27:53 <wy> oerjan: But I can't know how wide the left side is before I finish typing
02:27:54 <Zao> Suitable amounts of spaces inserted by pushing the tab key :)
02:29:02 <oerjan> i see. this is the kind of thing i use vim's rectangular block editing for...
02:31:41 <wy> oerjan: Other characters might prevent you from being able to select the block ;-)
02:32:11 <oerjan> i guess there is no ideal solution
02:32:46 <oerjan> anyway, bus
03:03:13 <tetha> haha, even though its annoying, its fun to hack things together in java, because some things are just miserable: In order to add an element at an arbitrary index into some indexed List, I have to add "null" index - list.size() and then set the index to the wanted element
03:03:50 <tetha> +times before the and
03:12:57 <idnar> tetha: shouldn't you be using a map or something, instead of a list?
03:13:15 <idnar> I mean, you'd basically have to do the exact same thing in Haskell, unless I'm missing something
03:14:01 <tetha> idnar: probably. but still, if that thing is "automatically resizing", I shouldnt need such hacks
03:14:29 <tetha> idnar: this way, I could use regular arrays and have about the same code
03:14:52 <idnar> I don't think that's usually what people mean by "automatic resizing"
03:15:50 <Choko_> tetha: you can use ensureCapasity on arraylists
03:16:19 <tetha> Choko_: I tried, and it does not help (assuming I used it correctly)
03:16:49 <idnar> ensureCapacity doesn't change the size of the list, just the backing storage (I believe)
03:17:56 <tetha> idnar: how would you define some "automatically resizing" array btw?
03:18:57 <pippijn> the 18000th fibonacci number: http://pip.one09.net/files/txt/7d088c3e7eac1f71a9a4d10e77ceae82.txt
03:18:58 <lambdabot> http://tinyurl.com/yw6n2d
03:19:01 <pippijn> haskell is great :)
03:20:00 <idnar> tetha: it expands as you append/insert/remove elements, rather than being a fixed size
03:20:26 <idnar> I think what you want is a "sparse" array
03:20:26 <Gyde> repost: anybody wanna give a few idears on some optimising of a code I made for a tetravex solver..I put it here http://hpaste.org/4533 with a comment in the middel explaining the parts which I think needs optimising
03:22:35 <tetha> idnar: ah, that is a point. ok, with an automatically resizing sparse array, my point is valid, with an automatically resizing compact array. javas implementation is correct
03:40:01 <roconnor> Gyde: what is tetravex?
03:40:11 <Gyde> its a game
03:40:37 <roconnor> have a link to a description
03:40:47 <roconnor> Gyde: I will grab some tea and have a look at your code
03:40:51 <Gyde> some what the not pop smart sudoku ;)
03:41:03 <Gyde> nice thx.. link comming up, secs
03:41:59 <Gyde> http://en.wikipedia.org/wiki/TetraVex
03:43:02 <roconnor> okay, looks nice
03:44:50 <roconnor> Gyde: you are using (0,0,0,0) as a special empty tile?
03:47:12 <Gyde> yes
03:47:58 <roconnor> Gyde: Is this an assignment, or for your own fun?
03:48:28 <Gyde> assignment, thats why some of the types are a bit of, (atleast thats what other people tell me ;)
03:49:59 <roconnor> Gyde: this is why you have written your own catMaybes?
03:50:25 <roconnor> @src catMaybes
03:50:25 <lambdabot> catMaybes ls = [x | Just x <- ls]
03:50:36 <Sizur> can one produce a list comprehension using th?
03:51:13 <Japsu> @type [| [x | x <- [1..]] |]
03:51:14 <lambdabot> parse error on input `|'
03:51:17 <Japsu> bah
03:51:37 <Japsu> lambdabot: recompile yourself -fth
03:51:47 <Gyde> well, it looks like my hugs dosen't have it..
03:52:00 <Gyde> or something, because it didn't work if I didn't write it in ..
03:52:00 <roconnor> Gyde: you need to ``import List''
03:52:03 <Gyde> donnu why
03:52:07 <Gyde> ahh
03:52:09 <roconnor> Gyde: or ``import Data.List''
03:52:13 <roconnor> which is more modern
03:52:35 <Gyde> yes ok, not sure we can import stuff :)
03:52:40 <roconnor> right
03:52:48 <Gyde> we need to understand what we are doing ;)
03:52:52 <roconnor> Gyde: and you can't import Data.Array then :)
03:53:00 <Gyde> is the importet version faster
03:53:07 <Gyde> no I can't :(
03:53:15 <roconnor> Gyde: okay.
03:53:36 <Sizur> Japsu: aha, CompE, thanks
03:53:43 <roconnor> Gyde: then bear in mind as you look at this, it isn't how we'd write haskell in real life.  My maybe it is a good exercise.
03:54:35 <roconnor> Gyde: what sort of assignment is this?
03:55:50 <nanothief> what does the "|" do in this line: class MonadState m s | m -> s where {...}
03:56:05 <Sizur> nanothief: it's a functional dependancy
03:56:36 <Sizur> nanothief: it means that from a particular  'm' there can be only one 's'
03:57:16 <nanothief> Sizur: that makes sense
03:57:17 <roconnor> nanothief: it is used to help the type inference engine.
03:57:18 <desegnis> nanothief: It means that if you have an instance MonadState M1 S1, then you cannot have another instance MonadState M1 S2.
03:57:45 <Gyde> a course named Programming languages in the university
03:58:06 <roconnor> Gyde: what year are you in?
03:58:14 <Gyde> yeah I noticed, none of the code I looks like mine ..
03:58:27 <Gyde> 3 year, its a quarter course, 5 weeks
03:58:44 <roconnor> Gyde: okay, Have you studied Prolog in your course?
03:58:49 <Gyde> yes
03:58:55 <roconnor> Gyde: okay
03:59:06 <Gyde> why?
03:59:25 <roconnor> this is the sort of problem that is solved by doing a backtracking search.
03:59:28 <Gyde> is it semi prolog systax
03:59:37 <Gyde> ?
04:00:11 <roconnor> Gyde: backtracking search means the system tries a solution, moving forward, but if it fails to find a solution, it backtracks and tries another solution.
04:00:18 <Gyde> yes
04:00:20 <Gyde> I know ..
04:00:31 <roconnor> Gyde: Prolog is quite good at this sort of problem...
04:00:31 <Gyde> did the prolog already, I liked that better ;)
04:00:42 <Gyde> yes
04:00:49 <roconnor> Gyde: Haskell's list monad is also very good at solving this sort of problem.
04:01:17 <roconnor> Gyde: Using the list monad would be the typical way to solve this in Haskell...
04:01:19 <Gyde> I don't know about the list monad
04:01:32 <roconnor> Gyde: But you don't know about the list monad.
04:02:09 <roconnor> Gyde: I'm inclided to teach you how to use the list monad.
04:02:19 <Gyde> thx
04:02:19 <roconnor> Gyde: because it would make short work of this problem.
04:02:59 <Gyde> we have abit problem with our running time of 6x6 tetravex aswell
04:03:28 <roconnor> Gyde: The result would be you scraping basically all of your code.
04:03:37 <Gyde> noo
04:03:39 <roconnor> Gyde: alternative we can try to look at what you have right now and make it better.
04:03:52 <Sizur> hey, I'm answering some questions here! heh .. amazing :) (although in a broken english)
04:03:55 <roconnor> and leave learning the list monad for another day.
04:04:05 <Gyde> don't really have time to scrap it all.. 5x5 and smaller are really fast
04:04:16 <roconnor> Gyde: okay
04:04:27 <Gyde> already written most of the report and stuff like that ;)
04:04:28 <roconnor> Gyde: let's look at what you have then.
04:04:34 <Gyde> yeah thx
04:04:47 <roconnor> Gyde: but come back later so we can show you how to do it all proper like ;)
04:04:57 <Gyde> yeah I will ..
04:05:48 <roconnor> Gyde: okay, tell me about tubleFinder.
04:06:02 <roconnor> Gyde: I need to understand what we have here :)
04:06:28 <Gyde> its a function which finds a tuble (int,int) from a number and a dimension (of the tetravex)
04:06:51 <Gyde> so we use it to iterate over the entire grid
04:06:57 <roconnor> what's a tuble?
04:07:09 <Gyde> an index in the grid
04:07:36 <Gyde> like (0,0) is the top left corner and (3,3) would be the right lower corner in a 4x4 tetravex
04:07:44 <roconnor> Gyde: do you perhaps mean tuple?
04:07:56 <Gyde> yea sorry
04:08:03 <roconnor> Gyde: no problem
04:08:04 <Gyde> did I miss spell it, dooh (
04:08:49 <roconnor> @wn tuple
04:08:49 <lambdabot> No match for "tuple".
04:09:06 <roconnor> could be me who can't spell
04:09:19 <benny99> @wn Tuple
04:09:20 <lambdabot> No match for "Tuple".
04:09:45 <roconnor> Gyde: I'm pretty sure that function ought to be simpler than it is.
04:10:04 <roconnor> Gyde: it is supposed to be the opposite of indexFinder, right?
04:10:10 <Gyde> yes
04:10:39 <resiak> so what's the recommended way to install cabal 1.really-new on Debian where it's not been packaged?
04:10:47 <Gyde> but I think thats a pretty fast function, even thoo its not so nice
04:11:07 <roconnor> Gyde: true
04:11:12 <Gyde> running time should still be O(1)
04:12:09 <roconnor> Gyde: you want indexFinder (0,0) (c,d) = 1?
04:12:32 <Gyde> yes
04:12:32 <roconnor> typically we would make it 0.
04:12:36 <roconnor> anyhow
04:13:08 <Gyde> yes, just numerated the gridspots from like 1..n
04:14:31 <roconnor> Gyde: tell me about expand
04:16:45 <Gyde> first of it has the emtpy tree with (0,0,0,0) as all the tiles and a list of tiles to use, then it places each time from the tile list in the (0,0) index making a new list of trees with a different tile in the (0,0) index and a list of the remaning tiles for each of the arrays
04:17:30 <cppiii> first time use irc
04:18:19 <byorgey> welcome, cppiii =)
04:18:40 <cppiii> hi, byorgey
04:20:22 <roconnor> Gyde: sounds good
04:21:54 <Sizur> is projection considered a catamorphism?
04:23:03 <roconnor> Gyde: when you say 6x6 is slow, do you mean slow to find all solutions, or slow to find 1 solution?
04:23:08 <pejo> cppiii, you probably don't want to irc as root by the way.
04:24:23 <Gyde> if I make tiles which gives one solution (ONE!) then it takes 1 sec, if there are many solutions then its takes a long time (1,5 hours) and then it crashes
04:24:35 <roconnor> Sizur: seems unlikely
04:24:48 <Sizur> yeah, it's not unique
04:24:51 <cppiii> sorry, what do mean pejo?
04:25:07 <Zao> Gyde: Thank you for ruining my productivity by mentioning tetravex :)
04:25:12 <roconnor> Gyde: right. ... It crashes?
04:25:31 <Gyde> hehe, yeah it just begins printing out a lot of stuff
04:25:33 <roconnor> Zao: :)
04:25:44 <cppiii> i have installed xmonad on my gentoo... but don't how to setup a dzen bar
04:25:59 <roconnor> Gyde: do you need to produce all solutions, or just 1 solution?
04:26:12 <Gyde> just one ..
04:26:18 <Gyde> but the solver has to be able to find more
04:26:41 <roconnor> Gyde: I don't understand.
04:26:55 <Gyde> I just use head in front of solver..
04:26:55 <desegnis> cppiii: I'd suggest #xmonad, actually.
04:27:11 <roconnor> Gyde: right, you can just use head to find the first solution.
04:27:20 <cppiii> i see, thanks
04:27:23 <Gyde> and the time to run it with head should be like 30 min or so ..
04:27:31 <roconnor> Gyde: when you use head, it still take an hour?
04:27:39 <Gyde> 1,5 hours and then crash
04:27:50 <pejo> cppiii, you should use your regular account instead of root when you irc, in case someone manages to trick your irc-client into doing dangerous stuff.
04:28:00 <roconnor> Gyde: are you using ghc to compile it?
04:28:04 <Gyde> with (5,5) it works perfectly in like few secs
04:28:22 <Gyde> no, im running from hugs, which our teacher will do as well :(
04:28:29 <roconnor> Gyde: I see.
04:28:41 <roconnor> Gyde: okay, I've had a similar problem before.
04:29:11 <roconnor> Gyde: The key to my solution was a well placed sort of the partial solutions.
04:29:29 <roconnor> Gyde: this is so that it searchs the more promising solutions first.
04:29:41 <roconnor> Gyde: of course, this means you need a criterion to sort with.
04:29:50 <Gyde> yeah..
04:29:54 <roconnor> Gyde: I must admit, I don't immediately see such a criterion for you.
04:30:02 <Gyde> noo, I don't either
04:30:10 <Gyde> that would have been nice thoo
04:30:12 <roconnor> Gyde: but if you can find one, it can help finding one soluiton.
04:30:26 <roconnor> (of course finding all solutions still takes the same amount of time)
04:31:28 <roconnor> Gyde: other than that I
04:31:39 <roconnor> Gyde: other than that I'm not sure I have that much more to contribute.
04:31:53 <roconnor> Gyde: there is a lot that could be done to make the code shorter and more Haskelly
04:32:03 <Gyde> ;)
04:32:08 <roconnor> Gyde: but I'm not sure doing so would make things all that much faster.
04:32:09 <Gyde> I bet there is ..
04:32:31 <Gyde> ahh thx for trying, I would like to the monads at some point
04:32:32 <roconnor> Gyde: althought shorter code is easier to inspect and maybe something that is missing would turn up.
04:32:37 <Gyde> ;) but now I just need to running
04:32:50 <Gyde> need to make it work ;)
04:33:02 <roconnor> Gyde: right.  A well placed sort really would have the biggest impact
04:33:30 <Gyde> thx
04:33:56 <roconnor> Gyde: BTW, what is the crash error?
04:34:22 <Gyde> _v1069 instOrd_v28 instOrd_v28) (Ord_v451 (Make.Ord (instEq_v263 (Ord__sc0_Ord instOrd_v28) (Ord__sc0_Ord instOrd_v28)) (instOrd_v262_v1069 instOrd_v28 instOrd_v28) (Ord_v451 (Makk{Interrupted!}
04:34:29 <Gyde> something like that..
04:34:35 <Gyde> and it just goes on forever ..
04:34:41 <Gyde> I can't see where it started
04:34:43 <roconnor> woah
04:34:47 <Gyde> it alreaady ran to far ..
04:35:05 <roconnor> Gyde: so it outputs nothing for 1.5 hours
04:35:14 <roconnor> and then it spews this thing forth?
04:35:22 <Gyde> yeah, and then it outputs that for ever ..
04:35:28 <roconnor> okay
04:36:16 <Gyde> the (5,5) makes like 25 solutions then holds and then it makes the error after like 10 mins.. the other one dosen't make a error at all .
04:36:49 <roconnor> Gyde: same sort of error?
04:36:59 <Gyde> yes,
04:37:29 <Gyde> actually I just pasted the error from the 5x5 because I didn't want you to wait for 1,5 hours making the other error ;)
04:37:43 <roconnor> right
04:38:17 <roconnor> Gyde: there may be other ways of trimming out solutions.
04:38:57 <Gyde> yes?
04:38:57 <roconnor> Gyde: can you rotate these tiles?
04:40:32 <roconnor> you can rotate the tiles?
04:40:42 <Gyde> no ..
04:40:48 <roconnor> okay
04:41:13 <roconnor> so, roughtly speaking, the number of times a number occurs on the left must equal the number of times it occurs on the right.
04:41:22 <roconnor> similarly for up and down.
04:42:28 <sjanssen> @v
04:42:28 <lambdabot> "\""
04:42:29 <Cin> is there a standard function which maps across the tails of a list? i.e. someMap id [1,2,3] => [1,2,3], [2,3], [3]
04:42:43 <roconnor> > tails [1,2,3]
04:42:45 <lambdabot>  [[1,2,3],[2,3],[3],[]]
04:42:51 <Cin> ahh, cheers!
04:44:05 <roconnor> Gyde: since you start filling from the upper corners, only the bottom and right sides of your partial solution are available for placing against
04:44:10 <Zao> Is the solution supposed to be unambiguous or can there be several solutions?
04:44:33 <Zao> I just got a board in Gnome's TetraVex that has (at least) two solutions. :)
04:44:37 <Gyde> yes
04:44:53 <Gyde> roconnor yes, thats right
04:44:54 <roconnor> Gyde: So each number on the right must occur an odd number of times in the remaining tials.
04:45:02 <roconnor> Gyde: or something like that
04:45:23 <roconnor> Gyde: perhaps you can use this property to trim solutions.
04:45:31 <roconnor> Gyde: I'm not sure though
04:45:34 <roconnor> Gyde: just an idea.
04:45:39 <Gyde> yeah..
04:46:46 <Gyde> don't you mean atleast once, not odd ..
04:47:20 <roconnor> Gyde: right
04:47:37 <Gyde> good, might try that out ;)
04:48:22 <roconnor> Gyde: I don't see a way of making your solution faster without making the code a bit more complex. :)
04:49:30 <Gyde> yes
04:49:37 <Gyde> I will try to do that
04:51:13 <roconnor> Gyde: be sure to use revision control in case this doesn't help ;)
04:51:48 <Gyde> yes ofcourse ;)
05:03:18 <Sizur> what would be an antonym of reduction?
05:03:55 <olsner> expansion?
05:04:00 <Sizur> yep! thanks
05:12:43 <nomeata> Igloo: I’m wondering: any news on the ghc6.8 front? People are waiting for the new xmonad in debian.
05:38:56 <Igloo> nomeata: hscolour is in new, and that's a build-dep for ghc6 now
05:39:49 <nomeata> Igloo: great. and what about haskell-utils and extralibs?
05:41:09 <Igloo> haskell-utils I want to make lintian clean. Then I just need to do some testing on an unreg arch
05:42:06 <nomeata> if you can put your beta-packages somewhere, I’d use them to make a 0.5 xmonad package for people to test as well.
05:42:25 <nomeata> (for that, I’d also need the new X11, though)
05:42:33 * Igloo is in the middle of something else right now; will try to get to it today
05:43:55 <nomeata> sure, no hurry :-)
05:44:23 <SamB> nomeata: new X11?
05:44:26 <SamB> you mean Xorg?
05:45:33 <Gyde> hpaste down?
05:46:24 <quicksilver> Gyde: seems to be, yes
05:46:29 <nomeata> SamB: no, the xlibs bindings for haskell
05:46:38 <Gyde> hmm
05:46:45 * quicksilver sends long reply to the MUD author on the -cafe
05:46:48 <Gyde> can I paste like 4 lines here?
05:46:49 <SamB> nomeata: ah, right
05:46:55 <SamB> that makes a lot more sense ;-)
05:47:17 <quicksilver> Gyde: try e.g. http://www.rafb.net/paste/
05:49:35 <Gyde> can somebody check this, just need to put it someother way so the joker thing works, just don't know how atm
05:49:36 <Gyde> http://rafb.net/p/Jl9JTQ91.html
05:51:08 <quicksilver> Gyde: you want to search for any element of the form (_,_,_,c) ?
05:51:17 <Gyde> yes
05:51:50 <quicksilver> @hoogle (a->Bool) -> [a] -> Bool
05:52:05 <Gyde> ehh?
05:52:07 <profmakx> hm
05:52:11 * quicksilver slaps lament 
05:52:12 <quicksilver> eh
05:52:16 <quicksilver> where's my lambdabot?
05:52:22 * quicksilver apologises to lament
05:52:49 <filcab42> hi
05:53:05 <quicksilver> anyhow, the function I was looking for was 'any'
05:53:39 <quicksilver> any (\(_,_,_,xx) -> xx == c) ls
05:53:43 <quicksilver> should be what you want
05:54:24 <Gyde> thx, I knew I had to use lambda, I just don't really get them yet ;)
05:54:40 <quicksilver> the lambda is building the predicate
05:54:45 <quicksilver> function a -> Bool
05:54:53 <quicksilver> which checks "is the fourth element c"
05:54:57 <filcab42> what does the stuff in this lambda parameters mean?
05:55:01 <filcab42> unzip3   =  foldr (\(a,b,c) ~(as,bs,cs) -> (a:as,b:bs,c:cs))
05:55:01 <filcab42>                   ([],[],[])
05:55:01 <filcab42> the tilde and stuff
05:55:04 <filcab42> never seen it
05:55:14 <opqdonut> lazy pattern match
05:55:14 <quicksilver> the tilde is a lazy/irrefutable pattern match
05:56:12 <filcab42> so. it will match the as/bs/cs after doing the fold and arriving at ([],[],[])?
05:57:03 <opqdonut> i think that keeps unzip3 non-strict
05:57:06 <opqdonut> so you can use it on streams
05:57:17 <filcab42> oh
05:57:20 <filcab42> thanks
05:57:25 <opqdonut> as it doesn't try to unpack the tuple that unzipping the "rest" gives
05:58:58 <araujo> morning
05:59:29 <Vq^> evening
06:15:16 * EvilTerran thinks it'd make sense if patterns in lambdas were always irrefutable, seeing as there's only one possible pattern anyway, but oh well
06:15:27 <EvilTerran> i guess this way you have the option, and you wouldn't the other way
06:18:23 <quicksilver> EvilTerran: what do you mean by only one possible pattern?
06:18:44 <EvilTerran> there's never several cases
06:19:02 <EvilTerran> in a normal function, you can have f <this> = <that>; f <hither> = <thither>
06:19:05 <nbarterd> instance Monad ((->) r) -- Defined in Control.Monad.Instances ... what's an example of that?
06:19:06 <olsner> first-class patterns ;-)
06:19:19 <EvilTerran> so refutable patterns are vital
06:19:28 <EvilTerran> but, in a lambda, you can only ever have one branch
06:20:02 <Tobsan> '/win 28
06:20:03 <Tobsan> oops
06:20:08 <EvilTerran> so it doesn't necessarily need to check whether the pattern matches before following that branch
06:20:25 <EvilTerran> like in let{} and where{} bindings and suchlike
06:21:35 * quicksilver nods
06:21:42 <quicksilver> I remember some discussion about this
06:22:00 <quicksilver> wouldn't it be surprising though, if
06:22:11 <quicksilver> (\Left a -> 5) $ Right 4 ==== 5 ?
06:22:24 <quicksilver> that would surprise me :P
06:23:12 <EvilTerran> I subscribe to the school of thought that eliminating bottoms is a "refinement" :P
06:23:32 <EvilTerran> even if the report says they should (may?) be there
06:23:34 <quicksilver> > (\Left a -> 5) $ Right 4
06:23:45 <quicksilver> doh, no bot
06:24:04 <EvilTerran> :(
06:24:52 <olsner> wouldn't you get a runtime exception about failure in an irrefutable pattern?
06:26:52 <doserj> olsner: it is not an irrefutable pattern, so no :)
06:29:10 <quicksilver> olsner: you would get the failure later, when you actually tried to use the value
06:29:18 <quicksilver> and since my example doesn't use "a", it never does
06:29:33 <olsner> ooh, that's slightly evil
06:29:39 <quicksilver> well that's not the way it works :)
06:29:48 <quicksilver> it's the way it would work if lambdas were always irrefutable
06:29:59 <quicksilver> I was giving it as an example of why I don't thnk that's a good idea
06:30:01 <olsner> but would it work like that with (\~(Left a) -> 5)?
06:30:05 <EvilTerran> indeed
06:30:07 <quicksilver> I'm not sure
06:30:45 <quicksilver> yes, it does
06:31:00 <quicksilver> > (\ ~(Left a) -> 5) $ Right 6
06:31:00 <quicksilver> 5
06:31:33 * EvilTerran continues mumbling about refinement
06:32:42 <Gyde> right now my program seems to be running a bit better with help from roconner, but now im running into this: pattern match failure: updateArray2D (Make.Ord (instEq_v263 (Ord__sc0_Ord instOrd_v28) (Ord__sc0_Ord instOrd_v28))) (0,2) (6,3,8,3)
06:33:17 <Gyde> updateArray2D takes 3 arguments, and the last to looks fine.. whats up with the first one?
06:33:47 <quicksilver> I believe that is actually a hidden argument representing the Ord dictionary
06:33:54 <quicksilver> I'm not too familiar with hugs so I'm not sure
06:36:15 <Gyde> hmm
06:38:03 <Gyde> thx anyways..
06:38:22 <Gyde> the error only appars once our array becomes of a certain size
07:55:46 <cognominal> @src ask
07:56:37 <cognominal> @source ask
07:56:50 <Saizan_> ask = Reader id
07:57:13 <oerjan> @src MonadReader
07:57:21 <oerjan> @bot
07:57:23 <Saizan_> but it's a class method, that's the definition for Reader
07:57:53 <oerjan> lambdabot not there at all...
08:08:55 <Mitar> is there a way to call load python module into a haskell? :-)
08:10:00 <sieni> I can't parse that sentence
08:10:20 <pippijn> :-D
08:11:11 <TomMD> @bot
08:11:49 <sieni> Mitar: As far as I can remember, Pyhton has a pretty decent C API which you probably can use
08:19:30 <ricky_clarkson> Am I describing monads but in a roundabout way, in this post?  http://rickyclarkson.blogspot.com/2007/12/functional-way-of-testing-oop-programs.html
08:26:43 <pejo> ricky_clarkson, I don't see why message passing has anything to do with side effects.
08:28:02 <ricky_clarkson> pejo: Because it implies action.  If you look at a definition of a message, it is something sent to request action.
08:30:26 <Saizan_> message passing can be seen as a tight way to encapsulate mutable state, but it's not referentially transparent per se
08:33:38 <ricky_clarkson> pejo: I added a footnote.
08:36:14 <Saizan_> ricky_clarkson: if i've understood your post you've described one of the possible implementation of the IO monad, the one based on a GADT with a constructor for each effect that stores the continuation that needs the result
08:37:28 <ricky_clarkson> I see.
08:38:50 <Gyde> I have a little problem with a type which is not generic in a otherwise, how do I fix this: http://rafb.net/p/WgHutg43.html
08:41:18 <oerjan> Gyde: you might add a default argument to the function, to use when you don't find the index
08:41:59 <oerjan> or you could return a  Maybe a  value
08:42:06 <Gyde> isen't that what I do ..
08:42:19 <Gyde> I tried the maybe, couldn't get it working
08:43:56 <Gyde> I tried the maybe, couldn't get it working
08:44:01 <Gyde> oops
08:44:22 <oerjan> change = p to = Just p, (0,0,0,0) to Nothing and -> a to -> Maybe a
08:46:40 <loupgaroublond> where does cabal fetch download packages to?
08:51:47 <Gyde> but we need the (0,0,0,0) for later use
08:51:51 <Gyde> oerjan
08:51:56 <Gyde> buuhuu :(
08:52:05 <Gyde> do I need to change that then?
08:52:32 <pejo> Gyde, when do you need (0, ..)?
08:52:43 <oerjan> well if you want the function to have a generic type, then you must specify the (0,0,0,0) in the caller instead
08:53:39 <oerjan> with the Maybe type that is as simple as: fromMaybe (0,0,0,0) (readArray2D ...)
08:53:43 <Gyde> in the function calling it, we need it to return (0,0,0,0) because we compared to (0,0,0,0) in a guard
08:54:07 <Gyde> ok
08:54:18 <oerjan> (import Data.Maybe)
08:54:46 <Gyde> we can't import that.. in my assignment :(
08:55:46 <oerjan> oh.  you need to use pattern matching then.  perhaps it is simpler to use a default value in the function.
08:56:30 <Gyde> fromMaybe ls = [x | Nothing x <- ls]    dosen't this work as maybe?
08:56:40 <Gyde> if I just write it myself then its ok
08:56:41 <Gyde> ;)
08:56:52 <oerjan> er that's rather wrong
08:57:15 <oerjan> Maybes have nothing to do with lists
08:57:26 <oerjan> and Nothing doesn't take an argument
08:57:26 <Gyde> ok :(
08:57:38 <oerjan> @src fromMaybe
08:57:45 <oerjan> bah
08:57:50 <Gyde> its just I tried to remake it from this: catMaybes ls = [x | Just x <- ls]
08:58:06 <oerjan> that returns a list though
08:58:21 <oerjan> anyway the pattern match is not so hard:
08:59:00 <oerjan> case readArray2D ... of Just p -> p; Nothing -> (0,0,0,0)
09:02:06 <Gyde> ((case (readArray2D (fst c)) of Just p -> p; Nothing -> (0,0,0,0)) (a,b))  <-- like this?
09:02:46 <oerjan> not quite
09:03:03 <oerjan> readArray2D takes two arguments
09:04:20 <oerjan> and that (a,b) is certainly in the wrong place, what do you want to do with it?
09:04:53 <Gyde> ((case (readArray2D (fst c) (a,b)) of Just p -> p; Nothing -> (0,0,0,0)))
09:05:30 <oerjan> fine (although you can lose at least one set of parentheses)
09:05:36 <Gyde> ok
09:05:56 <oerjan> two actually, case ... of brackets itself
09:14:52 <Gyde> thx, oerjan ..
09:15:01 <bench> is hpaste working?
09:15:09 <oerjan> not last i checked
09:15:13 <Saizan_> no
09:15:17 <Gyde> that works, now my show instance just dosen't wanna work anymore
09:15:23 <Gyde> it can't find the type :(
09:15:58 <oerjan> it complains about ambiguous overloading?
09:16:26 <shachaf> Why is lambdabot gone, by the way?
09:16:31 <Gyde> ERROR "tetra.hs":10 - Cannot justify constraints in instance member binding
09:16:32 <Gyde> *** Expression    : show
09:16:32 <Gyde> *** Type          : Show (Tree a) => Tree a -> String
09:16:32 <Gyde> *** Given context : Show (Tree a)
09:16:32 <Gyde> *** Constraints   : Show a
09:16:53 <Gyde> hpaste and all its stuff is down, including lambda bot
09:16:53 <oerjan> Tree is a class?
09:17:00 <oerjan> oh
09:17:14 <shachaf> Gyde: HPaste and lambdabot aren't related.
09:17:24 <Gyde> well a bit..
09:17:41 <oerjan> er sorry
09:17:41 <Gyde> hpaste annoyses directly here, so lampdabot must know it some how
09:17:55 <oerjan> Gyde: there is a hpaste bot
09:17:57 <Gyde> Tree is a data Type
09:18:11 <oerjan> which is also gone
09:18:50 <Gyde> ahh ok ..
09:19:06 <Gyde> wanna see the show code?
09:19:24 <oerjan> Gyde: did you put deriving (Show) on your Tree data type?
09:19:33 <Gyde> no made one myself ..
09:19:39 <oerjan> yep
09:20:20 <Gyde> like this -> http://rafb.net/p/Lu9Qfo87.html
09:21:19 <oerjan> oh right, you need instance Show a => Show (Tree a) where
09:21:44 <Gyde> hmm
09:22:18 <oerjan> (that's the literal line)
09:22:29 <loupgaroublond> bos: you around?
09:23:16 <Gyde> i just need to add a line in my code saying: Show a => "Show(Tree a) where"   ?
09:23:57 <oerjan> no you need to change your instance line
09:24:00 <bench> extractMisc :: CarInfo->String->CarInfo
09:24:00 <bench> extractMisc p e | e `elem` equipments =
09:24:00 <bench>                     let (d, m) = (equipment p, misc p)
09:24:00 <bench>                     in do p {equipment = (d ++ [e])};p {misc =  m \\ (unwords e)}
09:24:03 <bench>                 | otherwise = p
09:24:07 <bench>  
09:24:10 <Gyde> kk
09:24:13 <bench> sorry for pasting it here, hpaste didn't seem to work
09:24:24 <Gyde> i see now :) thx
09:24:28 <bench> Couldn't match expected type `CarInfo' against inferred type `a b'
09:24:47 <bench> why is inferred type 'a b'?
09:25:01 <Sizur> ugh, irrefutable patterns seem to me rather a for of a hack
09:25:04 <Sizur> form*
09:25:08 <oerjan> bench: do requires monad
09:25:17 <Sizur> @users
09:26:11 <Sizur> oh lambdabot, my lambdabot... come back to me, oh my lambdabot!
09:26:15 <oerjan> i think you want    in p {equipment = (d ++ [e]), {misc =  m \\ (unwords e)}
09:26:23 <oerjan> er
09:26:30 <oerjan> i think you want    in p {equipment = (d ++ [e]), misc =  m \\ (unwords e)}
09:27:10 <shachaf> Cale: Can you invite mbot over here, maybe?
09:27:21 <oerjan> the {... = ..., ...} notation is pure
09:28:45 <oerjan> also, extractMisc p@{equipment=d, misc=p} e | ... and you can drop the let
09:29:00 <oerjan> er, misc=m
09:33:40 <bench> oerjan, ah, good, thanks
09:34:08 <oerjan> er again, there needs to be the constructor between @ and {
09:35:36 <loupgaroublond> bos: unping
09:35:48 <oerjan> hopefully you have only one - sadly the { ... } patterns cannot be used without naming the constructor
09:36:20 <bench> so if I had define CarInfo as monad, then i can use the do notion?
09:36:46 <oerjan> well yes although it seems like a strange thing to do there
09:36:47 <Associat0r> anyone know where the interactive part is in visual haskell?
09:37:02 <oerjan> you never need do with just a single expression
09:37:39 <dozer> bench: that would be sort of like saying you have a virtual machine where every function application is intimately linked to CarInfo
09:37:47 <bench> understood. w.r.t to the constructor comments, can you give an example?
09:38:14 <oerjan> well what is the definition of CarInfo?
09:39:24 <oerjan> the parts inside {} are not so important for this
09:40:24 <oerjan> the main question is what the data constructor is called and if there is more than one
09:42:01 <oerjan> assuming it's CI :
09:43:01 <bench> there is only one constructor
09:43:16 <bench> data CarInfo = CarInfo {year :: String,
09:43:16 <bench>                         make :: String,
09:43:16 <bench>                         model :: String,
09:43:16 <bench>                         trim :: String, -- 4dr EX
09:43:21 <bench>                         engine :: String, -- 4-cyl, V6
09:43:24 <bench>                         driveTrain :: String, -- FWD AWD RWD
09:43:27 <bench>                         transmission :: String, -- auto, 6 speed, 5-speed
09:43:28 <Zao> *cough* hpaste
09:43:30 <bench>                         mileage :: String,
09:43:30 <bench>                         equipment :: [String], -- power window,leather,sport
09:43:33 <bench>                         color :: String,
09:43:37 <bench>                         warranty :: Bool,
09:43:40 <bench>                         history :: String,
09:43:43 <bench>                         misc :: [String]
09:43:46 <bench>                         }
09:43:47 <Botje> bench: please don't paste in the channel. use hpaste.org instead
09:43:51 <bench>                deriving Show
09:43:54 <bench>  
09:44:04 <Zao> Pasting in the channel, the gift that just keeps on giving.
09:44:04 <oerjan> well then, extractMisc p@CarInfo{equipment=d, misc=m} e | e `elem` equipments = p {equipment = (d ++ [e]), misc =  m \\ (unwords e)} | otherwise = p
09:44:33 <Saizan_> or on others pastebin since hpaste is down
09:44:49 <bench> oerjan, thanks,
09:44:50 <oerjan> and for heaven's sake, why did you think i said the parts inside {} weren't important?
09:45:12 <bench> sorry for pasting all that
09:45:17 <bench> hpaste was down
09:45:28 <bench> what are other pastebins?
09:45:47 <Zao> rafb.net/paste, pastebin.com
09:45:53 <Zao> I'm sure there's more hits on google :)
09:50:24 <davidL> Can _ be used in a case statement as an idiom for otherwise? (for example case x of { 2 -> foo; _ -> bar} )
09:50:38 <shachaf> davidL: Not as an idiom.
09:50:50 <shachaf> davidL: otherwise = True.
09:51:18 <shachaf> davidL: It's generally used in guards, as in "f | a = x | b = y | otherwise = z"
09:51:25 <oerjan> otherwise is an expression, _ is a pattern
09:51:30 <shachaf> davidL: But in pattern-matching, you have to use _.
09:51:34 <davidL> shachaf: Don't they both accomplish the same thing?
09:51:45 <shachaf> davidL: No, they're used in different contexts.
09:52:16 <shachaf> I don't think there's any place where either would work.
09:52:34 <davidL> hmm, I guess I must be confused then, I remember seeing it used in a case statement :-\
09:52:46 <shachaf> davidL: Maybe it was in a guard?
09:53:03 <shachaf> case ... of ... | ... -> ... | otherwise -> ...
09:53:06 <oerjan> actually otherwise _would_ work in some places _ should be used, but it would shadow itself...
09:53:23 <shachaf> oerjan: Well, OK.
09:53:31 <shachaf> But for the wrong reason. :-)
09:53:51 <pejo> shachaf, g x = case x of { False -> 7; otherwise -> 9 }
09:54:06 <shachaf> Yes, I understood.
09:54:16 <shachaf> However, you can't say "g otherwise otherwise = ...". :-)
09:54:18 <pejo> I'm just a tad late on the typing, it seems.
09:55:16 <shachaf> > case 0 of { 1 -> "a"; otherwise -> (case 3 of { x | x < 5 -> "b" | otherwise -> "c"}) }
09:55:34 <shachaf> Well, there's no lambdabot, but that should give a type error.
09:56:32 * oerjan notes that all the bracketing in that statement is redundant
09:57:00 <shachaf> oerjan: So? :-)
09:57:20 * oerjan polishes his pedant hat
09:57:26 <shachaf> And it's not a statement, it's an expression. :-)
09:57:42 <oerjan> argh! i knew that would come back to haunt me
10:07:21 <ndm> @karma+ mwc
10:08:05 <shachaf> ndm: lambdabot is gone. :-(
10:18:25 <Sizur> I'm reading meijer91functional. what does || stand for in B -> A||B?
10:18:48 <Saizan_> Either?
10:19:35 <Sizur> B->A or B->B? Or: B->(A or B)?
10:19:41 <Saizan_> that would be the type of Right
10:19:49 <Saizan_> B -> (A or B)
10:19:56 <conal> Saizan_: Either is a good guess from the type.  url?
10:20:28 <Saizan_> Sizur: url?
10:20:43 <Sizur> Saizan_: thanks. it's the classic about bananas and lenses
10:21:18 <conal> (oops -- i got Sizur & Saizan_ mixed up)
10:21:43 <Sizur> http://citeseer.ist.psu.edu/meijer91functional.html
10:22:22 <Sizur> quite an old paper
10:22:27 <Saizan_> Sizur: no, from the use it means (,)
10:22:34 <Saizan_> so "and"
10:22:46 <Sizur> what does that mean?
10:22:59 <Saizan_> (A,B)
10:23:13 <Sizur> Oh!
10:23:13 <Saizan_> a pair with an element of type A and one of type B
10:23:35 <Sizur> I'd never have guessed it. he doesn't introduce this syntax
10:24:25 <desegnis> The ML version would have been A * B, IIRC (mimicking the cartesian product of sets)
10:24:41 <Saizan_> it defines A* = Nil | Cons (A||A*), if you match that with List a = Nil | Cons a (List a) you can see the meaning
10:25:04 <desegnis> ||, on the contrary, seems a rather odd choice to me.
10:25:06 <Sizur> Saizan_: thanks
10:25:40 <sclv> @bot
10:25:46 <lambdabot> :)
10:25:49 <sclv> yay!
10:25:53 <sclv> @yow
10:25:54 <Sizur> I guessed the plurality of the (*), but not the (||) -- was thinking in terms of an OR
10:25:58 <lambdabot> ... the MYSTERIANS are in here with my CORDUROY SOAP DISH!!
10:26:56 <bos> loupgaroublond: finally around
10:27:30 <loupgaroublond> bos: k, which time zone are you in?
10:27:31 <Saizan_> * refers to the canonical syntax of regular expressions, here
10:27:40 <bos> loupgaroublond: california
10:27:59 * loupgaroublond notes that california is not a time zone :P
10:28:12 <loupgaroublond> bos, i'm making some patches for cabal-rpm for the new ghc in fedora 8
10:28:22 <bos> loupgaroublond: cool
10:28:25 <Sizur> and Cons stands for Constructor is my guess
10:28:28 <loupgaroublond> and so that it generates rpms that don't make rpm lint crany
10:28:30 <loupgaroublond> *cranky
10:29:15 <loupgaroublond> bos, i had a question for you though, do you know of a way to get the file manifest of an rpm, in haskell?
10:30:38 <bos> not without shelling out to rpm
10:32:46 <conal> Sizur: i think Cons is a historical term from early Lisp, when cons cells were the only non-atomic data.
10:33:34 <conal> cons cells were used for all kinds of non-atomic data, but later became more specialized to lists.
10:33:40 <conal> (nonempty lists)
10:35:48 <macron> hi everyone, typing "let Just x | x == 0 = Just 0 in x" in ghci gives an infinite loop. Is this a bug?
10:36:17 <shachaf> macron: What do you expect it to do?
10:36:30 <macron> shachaf: return Just 0?
10:36:35 <Sizur> in the beginning of the treatment of catamorphisms, why ⨁ ∈ (A,B->B)?
10:37:00 <Sizur> oh I see
10:37:13 <kosmikus> if at all, it would return 0
10:37:34 <shachaf> macron: Why? Before it can put something in x, it has to check that x == 0.
10:37:36 <Sizur> no actually it's not clear fo rme
10:37:49 <kosmikus> but the point is that the check x == 0 has to be performed before x is available
10:37:54 <kosmikus> so it's not a bug
10:38:09 <oerjan> macron: it's essentially the same as let x | x == 0 = 0 in x
10:38:27 <kosmikus> indeed
10:39:06 <bos> loupgaroublond: thanks for the patch!
10:39:26 <Sizur> ⨁ is a function, why does it lie also on the A set?
10:41:13 <loupgaroublond> bos: it got sent? i have to admit, i was testing an unconfigured mailer
10:41:36 <loupgaroublond> bos: anyways, it's not complete, i still haven't gotten it to stop actually demanding ghc681-base
10:41:53 <bos> heh
10:42:48 <macron> oerjan: hm, ok. I thought pattern bindings and function bindings in let expression were really quite different. I'm rather confused by pattern bindings now..
10:43:20 <oerjan> macron: ok it may not be _exactly_ equivalent
10:43:47 <oerjan> but in both cases the problem is the same - you try to access x during its top evaluation
10:43:49 <byorgey> Sizur: ⨁ isn't a function, it is a pair
10:44:05 <byorgey> which contains an element of type A, and a function B -> B.
10:45:03 <Sizur> wow, I need some serious adjustment for this syntax
10:45:43 * oerjan finds the syntax adjustment mallet. *WHAM*
10:46:08 <byorgey> Sizur: yeah, that paper definitely takes some concentration! =)
10:46:24 <macron> I think of pattern matches as desugaring the above expression to case Just 0 of Just x | x == 0 -> x.
10:46:37 <macron> which does evaluate to 0.
10:46:41 <shachaf> macron: | is still a guard.
10:47:13 <shachaf> macron: It binds the x, but before the pattern can match, it has to check that that x is (==0).
10:47:49 <Associat0r> anyone familiar with this book http://www.amazon.com/Haskell-Logic-Maths-Programming-Computing/dp/0954300696
10:47:51 <lambdabot> http://tinyurl.com/3y6oxo
10:48:06 <Brian`> >pl const (1+)
10:48:15 <shachaf> Brian`: @pl.
10:48:24 <kosmikus> macron: you can have multiple guards even in a pattern binding
10:48:25 <Brian`> @pl const (1+)
10:48:26 <lambdabot> const (1 +)
10:48:29 <kosmikus> macron: let Just x | False = Just 1 | True = Just 0 in x
10:48:32 <Brian`> @pl const . (1+)
10:48:32 <lambdabot> const . (1 +)
10:48:33 <kosmikus> macron: evaluates to 0
10:48:34 <shachaf> Brian`: But it won't change anything -- that's already pointless.
10:48:40 <kosmikus> macron: let Just x | x == 0 = Just 1 | x == 1 = Just 0 in x
10:48:43 <kosmikus> macron: loops ...
10:48:50 <Brian`> @unpl const (1+)
10:48:50 <lambdabot> (\ _ b -> 1 + b)
10:48:59 <Brian`> shachaf, yeah :) you're right
10:50:04 <oerjan> > let Just x | x == 0 = Just 0 | x == 1 = Just 1 in x
10:50:06 <lambdabot>  Exception: <<loop>>
10:52:10 <oerjan> macron: the official translation of let Just x | x==0 = Just 0 in x is let Just x = if x == 0 then Just 0 else error "Unmatched pattern" in x
10:52:17 <Saizan_> Sizur:  ⨁ ∈ A||B->B means  ⨁ :: (a,b) -> b which in haskell you would define as the equivalent a -> b -> b
10:52:51 <macron> oerjan: ah! Now i see what's going on.
10:53:22 <macron> it looks a bit more intuitive to me now than before.
10:54:52 <Sizur> @type curry (undefined::(a,b)->b)
10:54:53 <lambdabot> forall a b. a -> b -> b
10:55:07 <Heffalump> A||B = Either a b surely?
10:55:19 <Sizur> not in 91
10:55:42 <Sizur> 1991
10:55:48 <macron> I thought the match was always done before the guard is checked, but I guess that would mean having to backtrack if the guard fails, something which is not necessary in the translation oerjan mentions.
10:57:28 <Saizan_> Heffalump: heh, i thought so, but this paper define lists as A* = Nil | Cons (A||A*), so it's (,)
10:57:37 <macron> at any rate, thanks guys :)
10:57:40 <Brian`> is point-free function faster than point-full function?
10:58:21 <Sizur> @help
10:58:21 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
10:58:29 <shachaf> Brian`: Why would it be?
10:59:28 <Brian`> shachaf, just wondering. I feel like sometimes point-free function is a lot harder to read than point-full function, so I thought if people prefer point-free function, that must be better in some aspect (i.e. speed)
10:59:49 <shachaf> Brian`: People prefer the ones that are easier to read. :-)
10:59:50 <Saizan_> Brian`: not per se, but if you're completely point free your function is a CAF so it's never evaluated twice (the function, not the result of appling it to values)
10:59:54 <Brian`> @pl \x y z -> f (x y) z
10:59:54 <lambdabot> (f .)
11:00:00 <Sizur> @djinn (a,b)->b
11:00:01 <lambdabot> f (_, a) = a
11:00:04 <shachaf> Brian`: You can always @pl a function too much.
11:00:52 <shachaf> Brian`: But having names where they aren't needed can be annoying.
11:00:53 <Brian`> Saizan_, what is CAF?
11:01:42 <Brian`> shachaf, yeah.. but  (. (f .)) . (.) this kind of function is like impossible for me to understand haha
11:01:47 <allbery_b> constant applicative form
11:01:49 <Saizan_> Sizur: ah, btw my notation was slightly incorrect,  ⨁ :: (a,b) -> b for some particular a and b, not every
11:02:11 <Brian`> allbery_b, thanks
11:04:28 <Sizur> @djinn (a,[b])->[(a,b)]
11:04:28 <lambdabot> -- f cannot be realized.
11:05:29 <conal> djinn doesn't know about list functions.
11:05:55 <Sizur> @type map (\(d,ps) -> map (\p->(d,p)) ps)
11:05:58 <lambdabot> forall t a. [(t, [a])] -> [[(t, a)]]
11:06:13 <shachaf> Sizur: But you can use Maybe instead -- they're pretty much equivalent, for @djinn.
11:06:21 <Sizur> @type foldl1' (++) . map (\(d,ps) -> map (\p->(d,p)) ps)
11:06:22 <lambdabot> forall t a. [(t, [a])] -> [(t, a)]
11:06:51 <oerjan> :t uncurry (map . (,))
11:06:52 <lambdabot> forall a a1. (a1, [a]) -> [(a1, a)]
11:07:30 <Sizur> man... oerjan how long have you been with FP?
11:08:12 <oerjan> 5-6 years since i discovered haskell
11:08:49 <oerjan> although at about the same time i discovered unlambda... it makes things like these look easy :D
11:08:53 <Sizur> \me thinks there's still hope for this 5 month noob
11:09:31 <Cale> Yeah, if you've been using Haskell for less than a year, it's totally acceptable to be uncomfortable with various things :)
11:10:25 <Cale> @version
11:10:25 <lambdabot> lambdabot 4p581, GHC 6.6 (Linux i686 2.40GHz)
11:10:25 <lambdabot> darcs get http://code.haskell.org/lambdabot
11:10:44 <Cale> Hmm... Still not 6.8 :)
11:11:28 <Sizur> :t map . (,)
11:11:29 <lambdabot> forall a a1. a1 -> [a] -> [(a1, a)]
11:11:37 <Cale> I wonder if dons had some trouble getting lambdabot up and running on 6.8.2
11:11:51 <oerjan> well lambdabot was gone here for a while
11:11:58 <oerjan> not that it need be related
11:12:10 <davidL> Does hs-plugins build on 6.8?
11:12:18 <Cale> Yeah, it does now
11:12:31 <Sizur> :t (,)
11:12:32 <lambdabot> forall a b. a -> b -> (a, b)
11:12:51 <Cale> http://code.haskell.org/~dons/code/hs-plugins/
11:12:52 <lambdabot> Title: Index of /~dons/code/hs-plugins
11:12:59 <Cale> That one should
11:13:31 <Cale> I worked on it for the better part of yesterday. It's now using the ghc-api (clumsily), so it'll build and work with 6.8.2.
11:14:47 <shachaf> Cale: Is ghc-api much messier than hs-plugins to use?
11:15:38 <Cale> shachaf: I don't really know, but the API itself is pretty complicated, and I had trouble finding my way around what with there being no haddock.
11:15:56 <davidL> > foldr1 (.|.) $ zipWith (\x y -> shiftL y (x*8) :: Word64) [6,5..1] [42,99,107,12,149,67] -- is there a more idiomatic way to combine a list of [Word8] to form a Word64?
11:15:57 <lambdabot>  11931260445606656
11:16:43 <dozer> I have source under ./apps and ./src but I can only get ghci to pull in dependencies if I'm in the directory where the source is rooted at - not an option here
11:16:43 <Cale> davidL: You'll need a fromIntegral as well, won't you?
11:16:52 <dozer> can I add things to a 'source path' for ghci?
11:17:29 <davidL> Cale: where? It "works" without one
11:17:54 <Cale> davidL: Well, those aren't really Word8's you're passing it.
11:18:01 <mokus> davidL: it won't if you add ::[Word8] to the list
11:18:27 <davidL> oh, err
11:18:41 <davidL> :t shiftL
11:18:41 <lambdabot> forall a. (Bits a) => a -> Int -> a
11:19:25 <davidL> yeah I needed a fromIntegral on the first argument of shiftL, thanks
11:20:16 <oerjan> davidL: i think your lists lack two elements
11:20:57 <davidL> oerjan: they do, I want six Word8's -> Word64
11:21:15 <oerjan> and you want ..1 not ..0 ?
11:22:21 <davidL> you mean to go from 5..0?
11:22:27 <oerjan> yes
11:22:54 <davidL> ah there we go
11:23:11 <oerjan> but i still don't think it quite would type
11:23:48 <oerjan> oh wait forget it
11:24:11 <davidL> it seems to be working now, thanks
11:24:17 <twanvl> > foldl (\x y -> x `shiftL` 8 .|. fromIntegral y) 0 [42,99,107,12,149,67 :: Word8] :: Word64 -- slightly shorter alternative
11:24:17 <lambdabot>  46606486115651
11:41:16 <TomMD> @messages
11:41:16 <lambdabot> You don't have any new messages.
11:51:20 <a2dk> Why are GHCi and Hugs printing '\n' instead of actual newlines?
11:52:44 <dozer> a2dk: I presume because they are calling 'show' which generates a string matching the source-code you'd have to execute to make the data-structure being printed
12:02:38 <a2dk> dozer: Thanks
12:23:19 <antypaladyn> how do haskell and ML differ?
12:27:24 <dons> antypaladyn: ML is older, strict and impure
12:27:32 <doserj> non-strict, pure, type-classes vs. strict, ref's, higher-order modules
12:27:32 <dons> haskell is younger, lazy or strict, pure.
12:27:36 <dons> type classes.
12:27:56 <conal> ML has a more sophisticated module system.
12:28:19 <conal> doserj: "higher-order modules"?
12:28:31 <conal> doserj: oh -- i see the "vs"
12:28:34 <mauke> functors?
12:28:46 <conal> i think so.
12:28:50 <conal> would be nice in haskell.
12:29:20 <doserj> yes
12:29:50 <conal> haskell style favors currying a bit more than ml
12:30:44 <doserj> oh yeah: nice syntax vs. not so nice syntax :)
12:30:49 <conal> ;)
12:31:40 <mauke> and nice type annotations!
12:31:44 <conal> i'm not sure i'd call haskell "pure".  perhaps instead: haskell & ml both support mixed functional/imperative programming, but haskell's type system indicates the presence of side-effects, while ml's doesn't.
12:32:19 <conal> other perspectives?
12:33:32 <pippijn> I like currying
12:34:02 <Cale> conal: Well, it depends on how you think about values in IO
12:34:04 <koala_man> conal: do you mean the IO monad?
12:34:25 <conal> koala_man: yes: ST & IO.
12:34:28 <Japsu> haskell is as pure as it can get while still being useful
12:34:30 <Cale> conal: I personally think of IO values as *descriptions* of actions to be carried out, which are actually themselves pure.
12:35:06 <Cale> (It's just unfortunate that they're also made opaque, though there's no real need for that to be the case)
12:35:08 <conal> Cale: me too.  and yet, one must understand the semantics of IO in order to understand an haskell program using IO.
12:36:01 <conal> one could make the (far-fetched) argument that C programming is pure because one is simply forming strings describing actions.
12:36:08 <pejo> conal, what would be required for a language to be pure, in your opinion?
12:36:12 <Cale> I suppose it all depends on how you break it up. It's almost a philosophical question with no real answer.
12:37:05 <Cale> I tend to think of Haskell as a pure language that has a combinator language for describing impure computation embedded within it.
12:37:10 <conal> pejo: i've been puzzling over this question, and i have no clean & hard line.  For me, the crux is how simple is the semantics.
12:37:31 <conal> Cale: that's how i think of it also.  IO is a DSEL for imperative computations.
12:37:35 <Cale> right
12:38:12 <conal> and, as i said, one could say the same for strings & C computation.  that's why i'm not totally comfortable with saying that haskell programming with IO is pure functional programming.
12:38:25 <Cale> By avoiding thinking about how IO actions are going to be carried out, you're left with a wholly pure language. It's only when you start to think about what the IO actions *do* that you have to think in terms of impure effects.
12:38:50 <Cale> Well, in C you still have assignment and such.
12:38:55 <conal> exactly.  and it's necessary to think about IO actions, in order to understand the semantics of my haskell+IO program.
12:38:58 <pejo> conal, would you say call-by-need lambda calculus has a simple semantics? Or does simple have a specific (other) meaning?
12:39:33 <conal> pejo: do you mean a lambda calculus with no built-in types?
12:39:39 <Cale> conal: Well, exactly how much thinking of that sort is required varies.
12:40:03 <conal> Cale: depending on whether one uses IO or not?
12:40:23 <pejo> conal, hm, yeah, I guess.
12:40:32 <Cale> Well, depending on how you structure the program overall -- how much stuff is done in the IO monad, and how much is separate.
12:41:20 <esap> The problem with IO monad is that it sequences things too much. Not all I/O operations need to be sequenced even if they have side effects.
12:41:38 <monochrom> It is realistic to separate pure calculations from pure interactions in a program.
12:41:43 <conal> Cale: i guess i'd like the *types* of my haskell code to reflect the simplicity & safety of my program.  and IO is such a blunt instrument.
12:41:53 <conal> monochrom: i think so.  that's what TV is.
12:42:02 <Cale> Well, you can sharpen it yourself wherever you think that's needed.
12:42:11 <Cale> It's not so hard to do with the module system.
12:42:18 <Cale> (and newtype deriving)
12:42:31 <conal> monochrom: and that separation gives rise to programs that are much more composable than traditional Haskell IO programs.
12:42:35 <monochrom> The beloved "three-tier" structure of e-business software is about separating calcations from interactions.
12:42:38 <Cale> But that can still be a bit awkward, I admit.
12:43:12 <shachaf> Cale: Why does your hs-plugins depend on Cabal==1.2.3.0?
12:43:25 <esap> monochrom: That's interesting view of 3-tier architecture. I thought there were 3 tiers, not 2 :-)
12:43:26 * shachaf has 1.3 and 1.3.1.
12:43:38 <Cale> shachaf: It was found not to build with 1.3.x. You're free to try and figure out why.
12:43:50 <esap> monochrom: or do you think GUI and storage are both "interactions"?
12:43:55 <conal> Cale: do you know on which platfoms your new hs-plugins works?
12:44:08 <Cale> conal: I'm not sure. So far, linux. :)
12:44:09 <conal> Cale: i'd like to use it for code generation in Eros.
12:44:20 <Cale> conal: It uses the ghc-api
12:44:22 <monochrom> When you give homework to first year programming students, and they hand in code that interleaves input, calculations, and output, and they do this because the language makes it easy to do so, it is really disheartening, because you know that real programs cannot be written like that.
12:44:44 <conal> Cale: where can i find it?  on hackage?
12:44:52 <Cale> http://code.haskell.org/~dons/code/hs-plugins/
12:44:52 <lambdabot> Title: Index of /~dons/code/hs-plugins
12:44:57 <pippijn> monochrom: do you teach MVC explicitly?
12:45:01 <conal> Cale: thanks.
12:45:09 <esap> monochrom: A general-purpose language can't mandate specific architecture.
12:45:18 <monochrom> esap: Yes, I think the "business logic" tier is interacting with both users and storage.
12:46:02 <Cale> conal: Apparently there were problems on OpenBSD, but Don didn't really mention what those were.
12:46:47 <conal> Cale: the previous hs-plugins (not on ghc-api) was broken on windows.  maybe no longer.
12:46:59 <Cale> That would be nice.
12:47:49 <Cale> I wish the GHC people would Haddock-ise the API. Then I'd have a reasonable chance of actually using it the way it was meant to be used :)
12:47:52 <esap> monochrom: well it's true business logic is interacting with users and storage, but that downplays what happens in tiers 1 and 3.
12:48:35 <Cale> Another thing I noticed is that the GHC API severely underuses the potential for hierarchical modules.
12:49:12 <Cale> There's hierarchical structure in the directories of GHC code, but it's not reflected in the module names.
12:49:35 <Cale> Also, there are confusingly shortened names all over the place.
12:49:54 <conal> Cale: spj did say that ghc-api wasn't designed, and that he welcomes suggestions.
12:50:02 <conal> (probably more welcomes help)
12:52:20 <allbery_b> this is a bit surprising:
12:52:22 <allbery_b> > reads "128.2" :: [(Int,String)]
12:52:23 <lambdabot>  []
12:52:44 <Cale> > reads "128a" :: [(Int,String)]
12:52:45 <lambdabot>  [(128,"a")]
12:52:50 <Cale> > reads "128." :: [(Int,String)]
12:52:51 <lambdabot>  [(128,".")]
12:53:01 <Cale> yes, it is a bit surprising :)
12:53:04 <shachaf> > reads "128a2" :: [(Int,String)]
12:53:04 <lambdabot>  [(128,"a2")]
12:53:28 <allbery_b> (I'm parsing dotted quads)
12:53:29 <conal> about "purity" & Haskell IO, can anyone offer a rebuttal to my facetious argument that string-encoded C programming via Haskell is "pure functional programming" (to the extent that Haskell+IO is)?
12:53:37 <wolverian> not really surprising, I think
12:53:54 <shachaf> conal: Where are the functions? :-)
12:54:03 <Cale> conal: Well, you're writing a program which builds a C program, which is itself pure.
12:54:16 <Cale> That is, the program which is doing the building is pure.
12:54:21 <conal> Cale: yes.
12:54:26 <conal> shachaf: why look for functions?
12:54:37 <Cale> So yes, that's still quite possibly pure functional programming :)
12:54:38 <gmh33> where can I grab the .hc files?
12:54:39 <sclv> how are you running the C program?
12:54:51 <shachaf> You said "pure functional". :-)
12:55:00 <conal> sclv: same general answer as running an IO action.
12:55:05 <Cale> The C program it's generating is most likely not pure though :)
12:55:17 * allbery_b falls back to an uglier parsing method :(
12:55:25 <Cale> allbery_b: Try ReadP
12:55:29 <shachaf> Cale: So that's the same as saying an IO action isn't pure?
12:55:41 <Cale> shachaf: when run
12:55:48 <conal> shachaf: i see.  don't you think "functional" is a misnomer.  "value-oriented" is more to the essense of "functional programming".  but if you want functions, use (:) and (++).
12:55:58 <Cale> The action that an IO action describes is most certainly not pure.
12:56:17 <Cale> The IO action value (like the string representing the C program) is itself pure.
12:56:20 <Zao> gmh33: -keep-hc-files when you build? Or are you referring to library files?
12:56:37 <esap> conal: I suppose one ideas of "functional" programming is that functions are values...
12:56:39 <gmh33> Zao: I need some hc files to bootstrap GHC on my computer :)
12:56:50 <sclv> pfp = you can write it in squiggol?
12:56:50 <gmh33> hc files of GHC build
12:56:55 <Cale> !paste
12:57:25 <Zao> gmh33: There is a guide on the wiki that's reasonably accurate.
12:57:28 <Cale> er, hey, what's up with hpaste.org? My browser is failing to connect to it.
12:57:32 <monochrom> http://hpaste.org/
12:57:40 <Zao> Cale: Reasonably down.
12:57:42 <gmh33> the "building/porting" page?
12:57:48 <Zao> gmh33: Aye.
12:57:56 <Cale> grumble
12:57:59 <conal> funny terminology: in "pure object-oriented programming", everything is an object.  but in "pure functional programming", everything is a value, not a function.
12:58:02 <gmh33> I'm looking at it, but it says I need some .hc files
12:58:04 <Zao> I've never managed to complete a crosscompile with it though.
12:58:06 <Cale> I have snippets there which I want :)
12:58:15 <gmh33> oo here's a linke to something else..
12:58:25 <Cale> conal: Did I show you my sketch of the GADT for the IO monad?
12:58:36 <conal> Cale: nope.
12:58:55 <conal> Cale: encoding return & >>= using GADT constructors?
12:58:56 <Cale> okay, then I'll type it up and paste it elsewhere :) It was on hpaste, but that's down apparently.
12:59:02 <Cale> conal: exactly, yeah
12:59:10 <conal> Cale: i've seen it elsewhere.
12:59:19 <conal> Cale: still not compelling, as it doesn't address semantics.
12:59:29 <Cale> and basically all your IO primitives just become constructors
12:59:39 <Philippa> conal: until you introduce IO that's at best convention though - ADTs can be church-encoded, etc etc
13:00:14 <Cale> So you manipulate these IO-values in a pure way, and under evaluation, they're just data, so they're pretty much inert.
13:00:37 <Zao> gmh33: "Make a set of HC files. On an identical system with GHC already installed, get a GHC source tree and put the following in mk/build.mk:" Follow that part in the porting section.
13:00:37 <Cale> But under execution, they're not inert, and that's where you have impure semantics coming into the picture.
13:00:38 <esap> conal: And in non-strict world, "values" can contain unevaluated thunks, which are like functions...
13:00:50 <conal> here's my worry.  the semantic model for IO is huge & intractable.  when i program with IO, I bring that intractable IO semantics into my program's semantics.
13:01:04 <gmh33> Zao: I don't have a system with which to make .hc files
13:01:11 <Cale> conal: But it's separate from the existing semantics of your program.
13:01:17 <Philippa> conal: so presumably you do like everything else and build layers over it where you can't be pure
13:01:23 <Philippa> er, everyone else, even
13:01:23 <Zao> You have to have access to a GHC.
13:01:28 <Zao> Or have someone else do it for you.
13:01:36 <thoughtpolice> gmh33: look at the part "Porting GHC to a new platform," if you're on a system that isn't supported yet you'll have to go that way
13:01:53 <conal> Cale: separating out the intractable IO semantics is why i'm playing with things like TV.
13:01:59 <Zao> That guide is rather inaccurate for at least 6.8.1 by the way.
13:02:06 <Zao> I've never managed to get a crosscompile to work.
13:02:35 <esap> conal: what do you mean "intractable IO semantics"? Aren't normal values intractable as well (try to compute "last [1..]")?
13:02:58 <Cale> conal: There are certainly better possible combinator libraries than our existing one, I'll give you that :)
13:03:08 <thoughtpolice> Zao: neither have I, I've been meaning to give it another shot to port ghc to dragonflybsd but i haven't had time. :(
13:03:22 <Cale> esap: Well, it's easy to see that last [1..] == _|_
13:03:32 <thoughtpolice> i might simply try porting 6.4 and see if that goes any better
13:03:43 <Zao> Hmm, good plan.
13:03:44 <shachaf> thoughtpolice: I thought Dragonfly was still pretty similar to FreeBSD?
13:03:45 <esap> Cale: sure. But in general that's not that easy.
13:03:47 <Philippa> yeah, I'm wondering if conal wouldn't be happiest with a "capability IO" model, with the starting point being a "get me new caps" cap
13:03:50 <Zao> I might give that a crack on my systems.
13:03:54 <conal> esap: exactly.  the semantic domain is much simpler than IO's, which is side-effects on the physical universe.
13:04:06 <Philippa> (then you can cut the bottom off the stack to give you a fixed set of caps)
13:04:23 <conal> Cale: (conal: But it's separate from the existing semantics of your program.) Do you mean that you can usefully & rigorously reason about your IO code?
13:04:29 <Cale> esap: I think he's just referring to the loss of the substitution model.
13:04:41 <esap> conal: Real world is complex. You can't simplify real world without some loss of expressive power.
13:04:52 <thoughtpolice> shachaf: it is; I might try to find the freebsd distribution and go from there but i just haven't had time.
13:05:06 <Cale> conal: I mean that you can still usefully and rigourously reason about the part of the code which is not in IO, even after you've added an IO component to your program.
13:05:13 <Philippa> I always liked the fact that the world-passing IO model actually offers a complete semantic solution for "your substrate just got hit by a meteorite"
13:05:31 <Philippa> (you get back a world with no host system in it and a null answer)
13:05:36 <Cale> heh
13:05:37 <conal> esap: if my goal is to model the real world (universe really), then i agree.  i'm looking for tools that are expressive enough to be useful but still have tractable semantics.
13:05:57 <esap> I do agree that it would be best to distinguish *different* parts of semantic models. But doing that to the whole real world doesn't sound tractable.
13:06:06 <conal> Cale: i see.  the "pure bits" of the program, but not all of it.
13:06:07 <Cale> I don't really like the world-passing model, for the reason that it seems to falter in the face of things like concurrency and nondeterminism. At the very least, they're confusing aspects of it.
13:06:09 <thoughtpolice> Zao: i'd say give 6.4 a shot and hopefully that might go better; i had to use ghc 6.2.2 to compile 6.6.1 on my openbsd box, so it's most likely worth going for.
13:06:27 <Zao> thoughtpolice: Don't bother to look at FBSD 7.0 by the way. The GHC ports port doesn't support 7.0 yet.
13:06:30 <Philippa> esap: saying what you should be able to expect to work if your host system's not malfunctioning is a good start
13:06:30 <Cale> conal: The hope is that this is most of the program, but yes, that's not always the case.
13:06:37 <conal> Cale: agreed.  extremely complex, at best.
13:06:44 <thoughtpolice> Zao: i'll keep it in mind. :)
13:07:20 <Philippa> things like "what I get out of the IORef is whatever I last put in it", or "unless something's really very exceptional indeed, exception handling works thus:"
13:07:44 <conal> Philippa: assuming single-threaded
13:08:11 <conal> in other words, IO programming brings in the semantic nightmares of other forms of imperative programming.
13:08:27 <esap> nondeterminism in concurrency could also be modelled and handled in the semantic model.
13:08:44 <conal> esap: yep.  with the usual complexity.
13:09:15 <conal> btw, i hope no one is hearing me say we shouldn't use IO.  it's a great tool, considering our current understanding.
13:09:25 <Philippa> which is exactly why people build wrapper monads on top of IO that limit us to some tractable subset
13:09:44 <conal> i'm certainly glad to have IO, in order to write libraries that hide IO.
13:09:47 <conal> Philippa: e.g.,?
13:09:53 <esap> conal: Well of course. But it's not that bad really. Well in the worst case you'd need to solve P=NP to model concurrency correctly :-)
13:10:14 <Cale> I think we'll always need something which is somewhat like the IO monad, in that it supports this complicated and hard-to-reason about semantics. But we ought to have other, more refined tools as well.
13:11:07 <Philippa> conal: ST, if you squint. A number of apps have what you might think of as a "command" monad. Admittedly I'm more likely to end up with a StateT IO than something more restricted a lot of the time because I've not been doing anything big enough to be worth the effort otherwise
13:11:16 <conal> Cale: probably so: the IO monad may always be a placeholder for what we don't know how to express purely functionally or what we don't know how to implement reasonably.
13:11:47 * edwardk waves hello.
13:11:54 <Cale> Well, some things just really are that complicated and horrible.
13:12:17 <esap> Yea, everything should be as simple as possible but not simpler.
13:12:26 <conal> Cale: that's a guess, right?  i don't know how anyone could prove such a thing.
13:12:29 <Philippa> conal: STM's another "if you squint" example
13:12:46 <Cale> conal: yeah, I suppose I'm just guessing :)
13:12:56 <bos> i've been working on a short list of widely held misconceptions about monads.
13:13:02 <bos> 1. they're unique to haskell.
13:13:03 <conal> Philippa: perhaps another example is GuiTV, which uses IO internally but presents a much simpler semantics.  and hence is amenable to reasoning.
13:13:05 <Philippa> I hadn't put it explicitly in another monad (but that was a minor refactoring away) but something like a "PageIO monad" was starting to appear in one of my wiki projects
13:13:06 <bos> 2. they're only for IO.
13:13:13 <Cale> conal: But if some system permits you to do everything which IO does, I don't really see how it could admit a better semantics.
13:13:19 <bos> 3. they're for controlling the order of evaluation.
13:13:29 <bos> can anyone else think of some popular howlers?
13:13:39 <Philippa> if you don't insist on having a monad rather than another structure then yampa is definitely an example
13:13:53 <Philippa> bos: "they're this weird category theory thing that nobody understands"
13:13:54 <thoughtpolice> 4. they're really really hard
13:13:59 <Philippa> bos: "they're only for doing imperative stuff"
13:14:05 <fourbissime> hi there. for a small todo app, I have a problem with lazy evaluation when I try to filter out some lines of a file. I overcame my problem by adding a "print" to force evaluation, but that's not exactly clean. So my question is : is there a clean and simple way to force evaluation ?
13:14:07 <edwardk> bos: that you ned a ph.d to understand them
13:14:10 <conal> Cale: so if the domain of discourse happens to be the 2007 Haskell IO monad, then i guess i'd have to agree.
13:14:13 <Philippa> bos: "they force an order of evaluation"
13:14:35 <Philippa> Cale: the capability system I suggested?
13:14:39 <bos> thanks!
13:14:54 <conal> Philippa: do you mean yampa is an example of something with simple semantics that is implemented on top of IO?
13:15:06 <Cale> conal: I mean, if you can accomplish everything which a C program can, then I think you're stuck with a complicated semantics, just because it's hard to describe all the interactions between that stuff.
13:15:23 <Philippa> conal: give or take - in fact it's parameterised on what IO you want it to do, but by the time you've supplied that parameter...
13:16:20 <conal> Philippa: how is yampa parameterized on what IO? and by "IO" do you really mean I/O?
13:16:27 <conal> I/O is much simpler than IO
13:17:28 <Philippa> conal: I mean that the reactimate function takes a couple of functions in the IO monad as parameters and yields an IO action
13:17:33 <Plareplane> @type ($!)
13:17:35 <lambdabot> forall a b. (a -> b) -> a -> b
13:18:00 <OceanSpray> Is there a data type that encompasses all numbers?
13:18:04 <conal> Philippa: oh.  i'd separate out reactimate from the semantics of yampa.  just as i separate out the semantics of print from Int or Bool.
13:18:29 <OceanSpray> a type that derives Ord, Fractional, AND Integral
13:18:32 <Philippa> in which case it's still something layered on IO though
13:18:46 <Plareplane> fourbissime, i don't know if ($!) does what you want
13:18:58 <conal> Philippa: semantically or implementation?  i care more about the former.
13:19:15 <conal> after all, *all* haskell types are implemented via side-effects
13:19:48 <Philippa> when you say "semantically", do you mean specifically the semantics of "the yampa language"? Those just assume signals in and out
13:20:16 <fourbissime> Plareplane: I'm having a look at this.
13:20:20 <timthelion> Hello, I am attempting to upgrade from the debian package ghc 6.6.1 to the latest 6.8.2  I have successfully installed 6.8.2, and everything was going great, untill I needed to install regex-base from hackage.  I get the error upon building this package:
13:20:20 <timthelion> Text/Regex/Base/RegexLike.hs:47:17:
13:20:21 <timthelion>     Could not find module `Data.Sequence':
13:20:21 <timthelion>       it is a member of package containers-0.1.0.0, which is hidden
13:20:22 <conal> Philippa: i mean the semantics of the Yampa types: particularly signal functions.
13:20:28 <Philippa> but it's important that the 'future' input stream can be dependent in some sense on the output stream
13:20:45 <conal> Philippa: that's in the semantics of the user, not of yampa.
13:20:55 <Cale> timthelion: Add containers to the list of packages in the cabal file.
13:21:10 <conal> pointing to IO under the implementation of libraries like Yampa or TV isn't anything different from what's true of Int & Bool.
13:21:25 <Philippa> conal: no. Whether it actually is or not, that's up to the user. The fact it /can/ be IO is important
13:21:41 <Philippa> it's not required to be a 'pure' thing
13:21:52 <shachaf> timthelion: Maybe use a newer version?
13:21:58 <conal> Philippa: what's not required to be pure?
13:22:00 <conal> the user?
13:22:05 <Philippa> the signals
13:22:08 <timthelion> Cale, like add it to Build-Depends?
13:22:31 <conal> Philippa: the signals have a simple, very limiting semantic model.
13:22:31 <Cale> yes
13:22:41 <Philippa> yet it could be more limiting
13:23:02 <Cale> timthelion: It's likely that you also might need array, directory, random, process, etc.
13:23:06 <conal> Philippa: saying that a user signal is impure is like saying that "3+7" is impure because it came from a brain.
13:23:23 <Cale> timthelion: There was a huge split of many libraries out of base, which is why this is happening.
13:24:06 <Philippa> conal: I could pull some library spec out of my arse that required the equivalent of reactimate to take pure parms only /due to restrictions in the language/. For example, I might want to be able to assume that output never ever affects input in some way.
13:24:12 <timthelion> Cale, thankyou, that fixed that issue, and it seems you are correct, now I'm getting a very similar error for bytestring.  Is this a bug? Should I report it?  Or is this simply an oddness with using a very new version of ghc?
13:24:22 <Philippa> that's even not a stupid thing for some termination-like properties
13:24:23 <conal> i don't think there's any precise division between "pure" and "impure".  i'd replace them with the question of how simple or complex is the domain in a denotational semantics.
13:24:45 <Philippa> we effectively do that kind of reasoning when we say that slapping WriterT over something isn't an issue
13:25:16 <OceanSpray> So... I assume there is no such thing.
13:25:18 <OceanSpray> Bummer.
13:25:19 <Philippa> I'd thank you for raising that point initially rather than debating under terms that appear to accept their usage
13:25:42 <Cale> timthelion: It's not a bug, it's just necessary to update packages to deal with the new module split.
13:25:47 <conal> Cale: i got a scary darcs message while getting hs-plugins: "realdarcs.exe: ./src/plugins: renameFile: inappropriate type (is a directory)"
13:26:21 <timthelion> Cale, oh, bytestring and array used to be part of base?
13:26:21 <Cale> conal: That's interesting. Also, the case is incorrect, I think.
13:26:29 <Cale> timthelion: yes
13:27:06 <conal> Cale: case of what?  (probably a windows issue)
13:27:23 <Cale> conal: oh, Plugins is capitalised here. :)
13:27:41 <thoughtpolice> conal: i pulled the dir of code.haskell.org about 20 minutes ago...
13:27:54 <conal> thoughtpolice: what os?
13:27:58 <thoughtpolice> oh wait, windows? can't offer help there. :(
13:28:06 <shachaf> Cale: Maybe it's the case-insensitivity of Windows.
13:28:14 <Cale> conal: I'll grab the current repo and put it in a zip or something.
13:28:46 <conal> Sigh.  btw, this happened on a completely clean "darcs get".
13:28:47 <Cale> shachaf: Could have something to do with it.
13:29:05 <conal> Cale: could there be a "Plugins" *and* a "plugins"?
13:29:15 <Cale> nope, there isn't, I just checked that.
13:29:21 <conal> weird.
13:29:32 <Cale> But yeah, that seems like the sort of error message you'd get if that were the case.
13:29:40 <shachaf> Cale: Maybe it was renamed at some point?
13:29:42 <conal> Cale: more info: "Applying patch 115 of 209... Unapplicable patch:"
13:29:43 <Cale> Or, I suppose it's possible that at some point in time there were.
13:29:52 <Cale> hmm
13:30:58 <shachaf> Yes.
13:31:03 <shachaf> Wed Aug 17 22:05:19 PDT 2005  Don Stewart <dons@cse.unsw.edu.au>
13:31:12 <shachaf>   * Mv plugins -> src
13:31:49 <Cale> conal: What's your preferred archive format? Is .tar.gz okay, or should I make it a zip?
13:32:08 <conal> Cale: either is fine.  whatever is easier for you.
13:32:25 <conal> Cale: still. no darcs will be a problem for me.
13:33:08 <Cale> Yeah, that's irritating. It seems like it should be considered a bug in darcs, if not a bug in Windows ;)
13:33:50 <Cale> http://cale.yi.org/autoshare/hs-plugins.tar.gz
13:33:59 <conal> Hopefully i won't be depending on windows for day-to-day work much longer.  i'd still like to be able to build there also.
13:34:03 <conal> Cale: thanks.
13:34:28 <roger`> case sensitivity is file system specific, if that's the issue.
13:34:41 <roger`> some file systems on windows are not case insensitive
13:34:50 <Zao> NTFS can be made case sensitive.
13:38:48 <bench> i'm trying to read a number like "12,600", and i tried case s of: (xs:',',ys)
13:39:05 <bench> but the case didn't seem to work, is that the right way to do this?
13:40:01 <fourbissime> Plareplane: either ($!) is not what I'm looking for, or I'm not using it right. this code (http://pastebin.ca/819277) won't work when the print is commented out. It tried to insert the $! within the hGetContents line, and into the filter line. had the same result.
13:43:59 <gmh33> alright, I got 6.6.1 to install via binaries :)
13:45:01 <dons> 6.8.2 might be nicer :)
13:46:40 <gmh33> dons:  I'm going to try to bootstrap it now w/ 6.6.1
13:47:02 <gmh33> I was having a hard time getting GHC to work at all, no 10.5 ppc binaries exist for current release :)
13:47:13 <Plareplane> fourbissime, does hPutStr fh $! content do anything? i'm kind of new at this too, you might want to ask someone else :(
13:48:51 <jedbrown> bench: You can't pattern match with (++).  Short of real parsing, you could do   read . filter (/= ',')
13:48:54 <fourbissime> Plareplane: no it doesn't :( but thanks for trying to help me anyways
13:50:17 <conal> Cale: hs-plugins requires Cabal ==1.2.3.0 (exactly)?
13:50:30 <shachaf> conal: At the moment.
13:50:44 <shachaf> conal: It's not difficult to change it to work with 1.3, I think.
13:50:59 <conal> shachaf: thanks.  now i see your earlier remark.
13:51:28 <Cale> conal: It might work with slightly older versions too. Shachaf has a patch for 1.3.
13:51:38 <zeeeee> has there been any work on (very broadly) improving haskell's imperative/io language? haskell is great when io is out of the picture, but for systems programming, scripting, etc., i've gained experience with a variety of issues (e.g.: can't nest io calls in an expression, defaulting to eager evaluation, no sugar for iorefs, library of collections for imperative programming, overhead of the io monad mini-interpreter, etc.)
13:51:39 <shachaf> A "patch". :-)
13:52:36 <conal> shachaf: could i have your patch?  i can try to apply it manually, as my hsplugins darcs repo is busted.
13:53:23 <conal> though i'm not sure it's worth hacking around the broken repo whenever i want a patch.  i wonder if the repo can somehow be fixed.
13:53:32 <shachaf> conal: All I did was <http://pastebin.com/m2df1e3a7>. I have no idea if it works or not (GHC 6.9.20071213, Cabal 1.3.1).
13:53:54 <conal> shachaf: thanks.
13:54:04 <shachaf> lambdabot: <http://google.com/>
13:54:11 <shachaf> lambdabot: http://google.com/
13:54:26 <shachaf> Someone else: http://google.com/
13:54:26 <lambdabot> Title: Google
13:54:35 <shachaf> Someone else: <http://google.com/>
13:54:52 <shachaf> That should be fixed -- "<>" is standard for URLs.
13:55:47 <Heffalump> why does it ignore URLs addressed directly at it?
13:56:00 <shachaf> Heffalump: I suppose it treats them the same way it treats /msgs.
13:56:10 <conal> shachaf: i get "Module `Module' does not export `packageIdString'"
13:56:15 <shachaf> Heffalump: Where it doesn't normally make sense to expand them.
13:56:25 <shachaf> conal: Yes, that's a change in the GHC API since 6.8.
13:56:38 <shachaf> conal: Change it back to "PackageInfo", I guess.
14:00:18 <conal> shachaf: if i upgrade to ghc-6.9, your patch may compile?
14:00:34 <shachaf> conal: Just use PackageInfo instead.
14:00:51 <conal> shachaf: i'm confused.  instead of what?
14:01:23 <conal> shachaf: i switched back to "import PackageConfig (packageIdString)".  now compiles.
14:02:10 <shachaf> conal: Sorry, instead of Module.
14:03:32 <ddarius> zeeeee: That you can't "nest io calls in an expression" is the whole purpose, however you can use liftM*, `ap`, <*> etc to get back a decent syntax; defaulting to eager evaluation (to the extent that that applies) is completely intentional (how many lazy/call-by-name imperative languages are you aware of?); sugar can be done pretty successfully with library functions and there is a preprocessor out there that adds a bit more; a library of emphemeral colle
14:03:32 <ddarius> ctions is not really compelling, even for "imperative" code it's better to use the pure ones if possible and you can always make them "ephemeral" by wrapping them in an IORef; "overhead of the io monad mini-interpreter" what are you talking about?
14:05:00 <conal> hm.  lots of failures in hs-plugins with "make check".
14:05:01 <conal> +c:/ghc/ghc-6.8.1.20071102/lib\base-3.0.0.0/HSbase-3.0.0.0.o: unknown symbol `_WaitForSingleObject'
14:05:05 <conal> +Main.exe: user error (resolvedObjs failed.)
14:05:21 <shachaf> conal: Huh. I didn't get those.
14:05:47 * shachaf wonders if he can blame Windows again.
14:05:52 <conal> shachaf: on what os?
14:06:01 <shachaf> conal: What happens if you compile the original code with Cabal 1.2.3.0?
14:06:09 <conal> yes, probably a windows-specific problem.
14:06:42 <shachaf> Has hs-plugins been used on Windows in the past?
14:06:52 <conal> shachaf: original code with cabal 1.2.3.0 --> "Not in scope: data constructor `InstalledPackageInfo'"
14:07:07 <conal> shachaf: hs-plugins worked on windows, but not recently.
14:07:19 <shachaf> conal: With 1.2.3.0? That's odd.
14:07:33 <conal> shachaf: oh -- wait....
14:07:35 <shachaf> conal: Are you sure that's what it's using?
14:07:59 <conal> shachaf: cabal 1.3.2
14:09:08 <zeeeee> ddarius, i know what you're trying to say re: "the whole purpose", but it's easier to write simple expressions like: f.write( time() + ": " + g.read() )
14:09:46 <zeeeee> ddarius, i meant "haskell does not make it easy to do eager programming" (cf. eager haskell), not "IO operations are sequential and eager, and i don't like that"
14:11:23 <zeeeee> ddarius, i should not have said io monad; i meant monad
14:11:33 <zeeeee> (regarding the interpreter overhead)
14:11:36 <Cale> zeeeee: But what does  f.write( time() + ": " + g.read() ) mean?
14:11:42 <Cale> What happens first?
14:11:50 <Cale> The time() or the g.read()?
14:12:20 <zeeeee> Cale, the language could impose an arbitrary order
14:12:47 <conal> zeeeee: in other words, the semantics is only partly specified.
14:12:53 <Cale> I think it's something which people don't worry about nearly enough.
14:13:19 <monochrom> Haskell makes it difficult to mix up calculations and interactions. I think this is the right thing to do.
14:13:20 <zeeeee> conal, no, i meant the language could say: innermost left-to-right
14:13:33 <conal> zeeeee: oh, i see: it could either way.
14:13:58 <conal> monochrom: right for what?  i.e., what good does it do?
14:14:19 <monochrom> Only quirky sysadmin scripts and first-year homework benefit from mixing up.
14:14:21 <conal> monochrom: (to steer from a religious discussion)
14:14:34 <Cale> zeeeee: The thing I *really* like about the way that Haskell handles IO actions (that is, that they don't automatically execute when passed as parameters to functions), is that it makes it trivial to write your own control structures.
14:14:52 <conal> monochrom: besides the smear, what's the *value* of your preference?  what does it accomplish.
14:14:54 <monochrom> It is right for real programs. Cf. the three-tier discussion we had a few hours ago.
14:15:11 <conal> monochrom: "right" is a religious claim.  i'm looking for something objective.
14:15:18 <Cale> When you pass an action as a parameter, you just pass the action, and not its result, which means that the function which receives it as a parameter can decide how it wants to run the action.
14:15:25 <zeeeee> he probably means 'right' as in 'more explicit, more clear' (but imo, that could be said about (for instance) C's explicit memory layout)
14:15:26 <monochrom> Real programs are structured that way.
14:15:47 <conal> monochrom: and ones that are structured differently are imaginary?
14:16:01 <conal> monochrom: more objective, less evaluative, please.
14:16:07 <monochrom> I allow for sysadmin scripts.
14:16:09 <timthelion> Ok, I am still trying to compile Regex.Base.  Now, I am getting a warning when Building 3 of 4 that
14:16:09 <timthelion> Text/Regex/Base.hs:48:3:
14:16:09 <timthelion>     Warning: The export item `module Text.Regex.Base.Context' exports nothing
14:16:10 <timthelion>  
14:16:26 <timthelion> The install then fails with Setup: Error: Could not find module: Text.Regex.Base with any suffix: ["hi"]
14:16:37 <conal> monochrom: the reason i'm asking for objective is that i believe there really are valuable objective reasons.
14:16:39 <Cale> timthelion: I think the warning is okay.
14:16:44 <conal> monochrom: not just prejudices.
14:16:56 <Cale> timthelion: I believe all that module exports is instances.
14:17:37 <timthelion> Cale, yes, but the install is failing, and regex-compat which requires regex-base is still complaining I do not have it.
14:17:39 <Cale> The later error though is interesting.
14:18:01 <zeeeee> Cale, yeah, haskell is a terrific host language, but i think the cost is at-run-time evaluation
14:18:03 <Cale> It seems to indicate that Text.Regex.Base didn't get compiled?
14:18:12 <Cale> zeeeee: hm?
14:18:33 <timthelion> Cale, yes this is true.  After the warning, 4 of 4 does not get compiled.
14:18:51 <timthelion> That is why I noted the warning.
14:19:03 <Cale> timthelion: oh, perhaps it has some option like -Werror
14:19:42 <conal> does anyone want to offer a reason (not a prejudice) for why to separate out effects from values?
14:19:43 <timthelion> Yes, the Options field in the cabal file has that, should I remove it?
14:19:56 <zeeeee> Cale, e.g., 'unify' is a dsl wrapped up in a monad - the cost is that code now runs through a mini-interpreter (with a conditional switch driver)
14:20:02 <Cale> You could do something like adding  {-# OPTIONS -w #-} to the very top of the Text.Regex.Base.Context module
14:20:04 <zeeeee> vs: metaprogramming, code gen, etc.
14:20:09 <Cale> Or yeah, remove that flag.
14:20:29 <Cale> The warning you're getting is not actually a problem.
14:20:50 <conal> zeeeee: could be that Monad is forcing dynamic analysis where Applicative or Arrow would do more static analysis.
14:21:00 <timthelion> Sucess, thanks!
14:21:08 <monochrom> I don't think citing the three-tier architecture is prejudice.
14:21:16 <conal> zeeeee: just speculation in this example.
14:21:29 <ddarius> zeeeee: The code could also just be written differently (while still using monads).
14:21:40 <Cale> zeeeee: Well, you're still statically compiling the code, so it comes down to how good the compiler is, and how clever your EDSL is.
14:21:45 <conal> monochrom: doing so begs the question.  now i'd like to know what's the value behind the three-tier choice.
14:22:11 <Cale> zeeeee: You can add things like RULES pragmas to instruct the compiler about domain specific ways to simplify code.
14:22:23 <conal> monochrom: or maybe you're making an appeal-to-authority argument.  i don't know.
14:22:29 <Cale> zeeeee: The ByteString library uses this heavily, and it can beat C at various things.
14:22:44 <zeeeee> Cale, bytestring is not implemented in haskell, is it?
14:22:49 <Cale> zeeeee: yes, it is.
14:23:37 <Cale> (Albeit fairly low-level Haskell, but Haskell nonetheless)
14:24:09 <ddarius> (Indeed, ironically, with the FFI libraries Haskell has little need for C.)
14:26:33 <monochrom> I am talking about a lot of programmers interested majorly in getting software done both effectively and maintainably. They did not start with the three-tier architecture. They started with all sorts of traditional and non-traditional approaches, explored and practiced for a long time, using how much trouble they ran into as their metric, and eventually converged to the three-tier idea. So I can't tell you why it is so good,
14:26:33 <monochrom> because I am not one of them, but I can tell you they worked their way to it, and if you want to know why, it is somewhere in their brains.
14:27:53 <conal> monochrom: thanks.  now i understand where you're coming from.  appealing to others' experience & conclusions saves time & effort.
14:29:07 <conal> does anyone else have any ideas about what is gained from separating values & effects, as we do in Haskell?  that separation is one of the major distinguishing characteristics of our language & programming style.
14:29:40 <Cale> I think the ability to design control structures without macros is really nice.
14:30:09 <conal> Cale: the point there is having actions as first-class values?
14:30:14 <Cale> yeah
14:30:55 <Philippa> we get to apply the type system to effects 'for free', and use effects that can't exist together comfortably by separating them
14:31:08 <zeeeee> of course, i'm speaking from the perspective of a user requesting features, and users never know what they want :) i suppose i was mainly wondering if anybody was thinking along those lines (and esp. if they were doing anything about it)
14:31:11 <conal> Cale: yes, that's very powerful.  scheme & ml folks use explicit functions of () instead.
14:31:25 <Philippa> it strongly encourages techniques like monad transformers
14:32:02 <Philippa> which in turn encourages to write code at an even higher level of generality - "works with any combination of effects available such that..."
14:32:49 <conal> Philippa: i think your point is that it's nice to mix effects & type classes.  right?
14:33:46 <conal> once effects are typed values, we can use the language's other wonderful tools, like laziness and type classes.
14:34:29 <conal> interesting.  i hadn't been equating (a) separating out effects & values and (b) effects as first class values.
14:35:52 <conal> i guess that's whatever feature we like (e.g., imperative programming), we want it as a first class value.  so the rest of the language machinery get to apply to it.
14:36:01 <conal> (that's *why*...)
14:37:25 <conal> i was thinking of a different reason: to keep the semantics of Bool, Int, lists, functions, etc, simple.
14:37:46 <conal> since simple semantics ==> tractable reasoning
14:39:15 <conal> in C or ML, the denotational semantics of an expression of type "Bool" involves side-effects.  complex enough with sequential computation, but watch out for concurrency.
14:39:54 <conal> in Haskell, the denotational semantics domain for an Int expression is relatively simple.
14:40:51 <zeeeee> this is the first time i've asked this question, and it comes from the fact that every now and again, i get a bit frustrated at how verbose my haskell systems programming gets - i try to stick with it, but i'm always asking myself "what's the point?" and am tempted to fall back onto loosey goosey scala
14:41:11 <conal> zeeeee: :)
14:41:24 <Philippa> conal: type classes are just a mechanism, any powerful type system has its advantages here. We get regioning cheaply via rank-n polymorphism, for example
14:42:06 <conal> zeeeee: have you asked for help much in getting your haskell systems programming more succinct?
14:43:14 <conal> zeeeee: it takes some time to learn to exploit the tremendous factoring potential of lazy functional programming.
14:43:20 <zeeeee> conal, i think ~2 years ago i had spent a lot of time in #haskell, and lots of folks helped educate me on thinking in haskell, but not much since then
14:43:24 <monochrom> The nature of system programming may imply mixing all the time.
14:43:59 <conal> zeeeee: it may be worth a shot again.
14:44:09 <conal> monochrom: perhaps.  though i hope not.
14:44:16 <zeeeee> conal, no no - i've been using haskell continuously!
14:44:43 <conal> zeeeee: i mean it may be worth asking for help again.
14:44:56 <zeeeee> conal, ah
14:45:35 <dobblego> zeeeee, what is the question?
14:45:37 <conal> zeeeee: you may be in a local minimum -- a worst-of-both-worlds place.
14:46:09 <zeeeee> ok, here's a small(?) program i'm currently working on
14:48:04 <zeeeee> it's a daemon that sits around on a mobile pc that occasionally encounters wifi connections - upon connectivity, this daemon gets a sigusr1 from the network system and tries to http-connect to homebase and mirror a directory of files
14:49:01 <zeeeee> each file may have an on-download trigger, usually doing something like unpacking or setting up something (e.g. reformatting a disk, powering off another attached pc, setting up a root fs)
14:49:14 <zeeeee> (hmm, hpaste.org is down?)
14:49:46 <Saizan_> (yes
14:49:52 <Cale> zeeeee: It seems so, unfortunately.
14:49:55 <Saizan_> ?tell sorear hpaste is down
14:49:56 <lambdabot> Consider it noted.
14:52:02 <zeeeee> the thing that makes this a bit painful is that it has to be resistant to sudden power-offs, must deal with tcp not timing out for hours by allowing itself to be interrupted in those system calls but not others, maintain state about partially completed downloads and partially completed trigger actions, etc.
14:52:43 <conal> zeeeee: wow!  that sounds complicated, indeed!
14:52:58 <zeeeee> restarting itself on getting downloading a new version of itself
14:53:01 <Cale> What is the purpose of this system?
14:53:18 <Cale> Some kind of remote administration?
14:53:20 <zeeeee> Cale, this is to deploy software onto these boxes that are attached to cabs
14:53:25 <zeeeee> Cale, yeah
14:54:05 <dozer> is there a 'how to profile with ghc 6.8.2' page out there somewhere?
14:54:10 <sorear> ?tell shapr kakapo is down
14:54:10 <lambdabot> Consider it noted.
14:54:11 <dozer> google isn't being my friend today
14:54:19 <Cale> dozer: sure, the GHC documentation...
14:54:39 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/profiling.html
14:54:39 * ddarius waits for shapr to @tell someone else something else is down
14:54:40 <lambdabot> Title: Chapter 6. Profiling, http://tinyurl.com/kwh6c
14:54:50 <dozer> thx
14:55:54 <Cale> zeeeee: Hmm... the resistance to sudden power-offs seems like it could be an annoying problem. What happens if the system powers off in the middle of a disk format, for instance?
14:56:13 <zeeeee> Cale, that must be dealt with by replaying
14:56:34 <zeeeee> Cale, such the operations are 'atomic' (in the db sense)
14:56:39 <Cale> Are there differences between the machines that must be maintained, or is the goal to keep them all the same?
14:56:55 <Cale> It might be easiest to just work with disk images all the time.
14:56:57 <zeeeee> Cale, maintaining consistency is actually a goal, yeah
14:57:11 <zeeeee> Cale, we do work with disk images, for the slaves
14:57:11 <zeeeee> so
14:57:19 <zeeeee> these boxes are actually two boxes - a master and a slave
14:57:29 <zeeeee> the slave is where we run interesting experiments on
14:57:46 <zeeeee> the masters download disk images from homebase and put them onto the slave
14:58:03 <dozer> ouch - now it wants profiling versions of all the library stuff
14:58:26 <Cale> dozer: Which you ought to either have, or there should be installable packages for.
15:02:30 <shachaf> conal: Did you get hs-plugins working?
15:03:46 <thoughtpolice> yaya. :) hs-plugins 1.1 == my bot lives again.
15:05:00 <Cale> :)
15:05:43 <dozer> Cale: I installed ghc from the binary snapshot, which apparently didn't include the prof libs
15:05:46 <zeeeee> well, here's some (turbulent) code: http://paste.lisp.org/display/52637
15:05:47 <dozer> is there a quick fix from here?
15:06:12 <Cale> It's a testament to the power of good type systems that I managed to get hs-plugins working with 6.8.2. I don't think I could have managed it in a dynamically typed language.
15:06:30 <Cale> dozer: oh, hmm, that's interesting...
15:06:48 <thoughtpolice> Cale: either way as a user I am happy. :)
15:06:58 <monochrom> You got lots of type errors, and they guided you to fix all compatibility problems?
15:07:30 <andyjgill> I'm trying to use fix, and can not for the life of me find it in the prelude. Any ideas? Or do I just roll my own?
15:07:32 <Cale> monochrom: Well, I needed to drop hs-plugins' own .hi parser and replace it with GHC's.
15:07:36 <jedbrown> Cale: Wasn't the STArray difference the only thing?  (I just built it too.)
15:07:39 <mauke> @index fix
15:07:40 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
15:07:40 <shachaf> andyjgill: Data.Function.
15:07:45 <shachaf> andyjgill: Or Control.Monad.Fix.
15:07:54 <Cale> jedbrown: I ended up making it use the GHC API.
15:08:02 <shachaf> andyjgill: (Data.Function in GHC >=6.8.)
15:08:44 <Cale> I deleted the entire Language.Hi tree.
15:08:53 <andyjgill> Ahh.  Turns out my browser is case sensitive :-) Control.Monad.Fix is the correct one I believe
15:09:14 <andyjgill> We need it to desugar properly.
15:09:26 <shachaf> andyjgill: Desugar?
15:09:30 <shachaf> andyjgill: Do you mean mfix?
15:09:51 <jedbrown> Cale: Ah, cool.  Will you push changes?
15:09:52 <Cale> jedbrown: It might have been the only difference, but the code that was in GHC was sufficiently different, and had a sufficiently different interface that I couldn't be bothered working out exactly what to do.
15:09:58 <conal> shachaf: (conal: Did you get hs-plugins working?) nope.  i'm giving up for now.
15:10:09 <Cale> jedbrown: they're pushed. The code is at http://code.haskell.org/~dons/code/hs-plugins/
15:10:10 <lambdabot> Title: Index of /~dons/code/hs-plugins
15:10:11 <shachaf> conal: Oh. What was the problem?)
15:10:19 <andyjgill> I'm adding a 'use explicit fix-pointing' to HERA, and need to use the official fix. I just could not find it!
15:10:50 <jedbrown> Cale: Right.  Oh, I was still looking at the cse.unsw repo.  Excellent.
15:11:01 <Cale> jedbrown: At least for me, it seemed like I'd have to pull in more and more changes from GHC into hs-plugins if I wanted to just copy and paste code from it.
15:11:15 <Cale> jedbrown: So I decided against that route altogether ;)
15:11:32 <conal> shachaf: +c:/ghc/ghc-6.8.1.20071102/lib\base-3.0.0.0/HSbase-3.0.0.0.o: unknown symbol `_WaitForSingleObject'
15:11:43 <shachaf> conal: Oh, right.
15:11:51 <shachaf> Sorry.
15:12:04 <conal> this kind of thing is way outside of my expertise. :(
15:12:07 <Cale> Of course, the data structures for Modules and Packages and such that the GHC API provides are much richer than the ones which hs-plugins has/had, so it immediately generated lots of type errors.
15:12:23 <Cale> And by the time I'd worked out all those type errors, the library actually worked :)
15:12:30 <jedbrown> Cale: Cool, and I hear you have lambdabot working with 6.8.2 as well.
15:12:35 <Cale> jedbrown: yep
15:12:43 <Cale> mbot in #math is running on 6.8.2
15:13:01 <Cale> mbot: @version
15:13:02 <mbot> lambdabot 4p575, GHC 6.8.2 (Linux i686 2.40GHz)
15:13:02 <mbot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
15:13:02 <lambdabot> mbot: You have 1 new message. '/msg lambdabot @messages' to read it.
15:13:03 <lambdabot> Title: Index of /~dons/lambdabot
15:13:14 <dozer> lambdabot lives!
15:13:21 <monochrom> andyjgill: Where can I find an overview of HERA?
15:13:33 <thoughtpolice> sweet. now I can have GHCi on acid again. :)
15:13:44 <Cale> mbot: @part #haskell
15:13:53 <andyjgill> http://www.unsafeperformio.com/paper.php?id=12
15:13:54 <lambdabot> Title: Introducing the Haskell Equational Reasoning Assistant
15:13:58 <mauke> @version
15:13:58 <lambdabot> lambdabot 4p581, GHC 6.6 (Linux i686 2.40GHz)
15:13:58 <lambdabot> darcs get http://code.haskell.org/lambdabot
15:14:18 <Cale> Hopefully this new hs-plugins will be more resilient to changes in GHC's interface file format.
15:14:32 <Cale> But it's still not using the GHC API very well.
15:14:52 <Cale> I don't really know very much about the GHC API and it seems underdocumented, so I'
15:14:58 <Cale> I'm not really the person to do that :)
15:15:34 <monochrom> Nice nice nice!
15:15:37 <Cale> I'm sure one could simplify hs-plugins way more if one knew what one was doing. :)
15:16:39 <Cale> I was essentially just looking for replacements to hs-plugins' .hi parser in the GHC api and using those instead, but I'm sure there's all sorts of module loading code already in GHC.
15:22:19 <dons> new version of bytestring uploaded, fixes perf regression on lazy bytestrings.
15:22:32 <dons> and takes advantage of the new Chunk representation.
15:23:15 <OceanSpray> can I do something like let c = DataConstructor in ...
15:23:29 <dons> yeah
15:23:35 <OceanSpray> and use c in pattern matching, like case a of (c _) -> ...
15:23:36 <OceanSpray> ?
15:23:40 <dons> no
15:23:44 <OceanSpray> well, damn
15:23:46 <OceanSpray> why not?
15:23:54 <dons> that would bind a new variable 'c'
15:24:04 <OceanSpray> hmm
15:24:14 <OceanSpray> @hpaste
15:24:14 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:24:53 * ddarius reduces a proof of an algebraic geometry result to one of category theory's two word proofs.
15:27:45 <antypaladyn> so wait how do ML n haskell varY?
15:29:03 <EvilTerran> we have laziness, typeclasses, do-notation, and significant whitespace
15:29:31 <EvilTerran> they have parameterised modules
15:30:34 <mwc> EvilTerran, you forgot purity, as a Haskell "has"
15:30:38 <mwc> or an ML "lacks"
15:30:44 <EvilTerran> mm, true
15:30:57 <mokus> yes, purity of essence!
15:31:04 <dozer> but they have 'holier than thou'
15:31:09 <mokus> we have that too
15:31:18 <EvilTerran> they have loads of parentheses
15:31:23 <antypaladyn> ok
15:31:24 <antypaladyn> so
15:31:25 <antypaladyn> uh
15:31:35 <EvilTerran> altho, notably, they don't need parentheses 'round their tuples
15:31:44 <antypaladyn> would you use haskell in your own startup company
15:31:48 <ddarius> They also have a semantics.
15:31:54 <dozer> they can nearly directly import their code into isabell
15:31:55 <ddarius> antypaladyn: People are using Haskell in startups.
15:32:18 <ddarius> Agda
15:52:58 <OceanSpray> Do I just use (==) to compare IORefs?
15:53:23 <Japsu> @src partition
15:53:23 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
15:53:23 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
15:53:23 <lambdabot>                               | otherwise = (ts, x:fs)
15:53:35 <ddarius> OceanSpray: Sure.
15:53:54 <Japsu> what's that ~ thingy? explicitly lazy?
15:54:07 <ddarius> @google site:haskell.org irrefutable pattern match
15:54:08 <lambdabot> http://www.haskell.org/tutorial/patterns.html
15:54:08 <lambdabot> Title: A Gentle Introduction to Haskell: Patterns
15:54:20 <OceanSpray> ok
15:57:09 <Japsu> pattern guards are a glasgow extension?
15:57:25 <Zao> n+1 patterns are.
15:57:26 <SamB> what isn't?
15:57:43 <SamB> Zao: eh? no. those are an icky Haskell feature
15:57:47 <Japsu>     Warning: accepting non-standard pattern guards (-fglasgow-exts to suppress this message)
15:57:49 <gmh33> n+1 is very strange in the programming world
15:57:49 <Japsu>                  Left x <- e
15:58:38 <SamB> things like n+1 might be nice IF there was a general mechanism... but then I hear that there used to BE one... but it's gone now.
15:58:41 <monochrom> n+1 is in haskell 98.
15:58:57 <SamB> I guess it wasn't general enough or something...
15:58:57 <monochrom> Left x <- e is also in haskell 98.
15:59:15 <SamB> monochrom: in what context?
15:59:16 <wy> What's difference between the packages libghc6-gtk-dev and libghc6-soegtk-dev ?
15:59:17 <Cale> SamB: There's n+k, that's slightly more general :)
15:59:34 <SamB> Cale: DOH! not that.
15:59:35 <resiak> what's the point in the irrefutable pattern match in the partition source?
15:59:37 <SamB> I meant views!
15:59:41 <Cale> SamB: There used to be c*n+k patterns, iirc.
15:59:51 <SamB> I heard there were views before
16:00:03 <monochrom> do { Left x <- return (Left 2); ... }
16:00:04 <Cale> I didn't think views were actually implemented.
16:00:04 <kosmikus> views were never implemented in ghc afaik
16:00:13 <SamB> were they in a standard?
16:00:16 <kosmikus> no
16:00:26 <kosmikus> there was a proposal
16:00:40 <SamB> I need to write down when people tell me these things so I can say "You lied to me!"
16:00:46 <kosmikus> I mean, worked out with modifications to the standard etc.
16:01:24 <kosmikus> SamB: http://www.haskell.org/development/views.html
16:01:24 <lambdabot> Title: Views: An Extension to Haskell Pattern Matching
16:02:09 <ddarius> SamB: They were proposed a long long time ago, but never implemented in a Haskell family language if I understand correctly, but some implementation of SML has implemented them.
16:02:30 <nelhage> I think a very early version of ghc may have had them
16:02:56 <SamB> we need to get some historians on the payroll
16:03:06 <SamB> does MS employ historians?
16:03:20 <nelhage> (I'm looking for the reference in ``A History of Haskell'', which is where I seem to recall this from)
16:03:30 <anandrd> What is the best way to get dependent types in Haskell?
16:03:38 <ddarius> anandrd: Use Epigram?
16:03:40 <mauke> call oleg
16:03:46 <kosmikus> anandrd: what do you mean, implement them?
16:04:11 <nelhage> Ah. The original ghc prototype written in LML had views.
16:04:12 <Philippa> what happened to the View Patterns stuff Dan Licata was working on?
16:04:27 <SamB> http://www.cse.unsw.edu.au/~dons/blog/2007/11/03#cat
16:04:28 <lambdabot> Title: Haskell hacking
16:04:31 <ddarius> Philippa: I believe that was implemented or will be, but those aren't views.
16:04:33 <mauke> http://okmij.org/ftp/Haskell/types.html
16:04:34 <lambdabot> Title: Haskell Programming: Types
16:05:11 <anandrd> for example, I want to implement modular arithmetic. My Type class should contain elements of the set Z/pZ and I want it to be in classes Eq and Num.
16:05:12 <wy> ddarius: Any ideas about my question? I need to decide which to install and learn
16:05:22 <ddarius> wy: What question?
16:05:28 <Philippa> ddarius: I know, I just wondered recently and was reminded
16:05:28 <wy> "What's difference between the packages libghc6-gtk-dev and libghc6-soegtk-dev ?"
16:05:37 <ddarius> wy: I've never used either.
16:05:47 <Philippa> it seems to've mostly been decided that views are the Wrong Thing
16:05:59 <SamB> wy: doesn't soegtk depend on gtk?
16:05:59 <Philippa> I'm not awake enough to recount the reasons right now though
16:06:16 <wy> SamB: I don't know. I selected gtk first ...
16:06:26 <ddarius> Philippa: That's my opinion, but those for them don't seem to like our reasons.
16:06:27 <SamB> Philippa: perhaps something to do with being hard to define a nice framework?
16:06:48 <anandrd> for example, I see num X to mean "the elements of type X form a field." So, I want to be able to have num ZmodpZ
16:06:48 <rabbit64> Hi. Don't you know about some kind of source code repository website for haskell (some projects and stuff like that)?
16:06:56 <Zao> wy: soegtk is the "School of Expression" implementation, whatever that is.
16:06:57 <ddarius> My issues are the lack of explicitness, hidden performance costs, and heavy-weightness.
16:07:00 <wy> SamB: You are right
16:07:01 <mokus> i think the 'soe' one is a version designed to work with the 'school of expression' book
16:07:27 <mauke> http://okmij.org/ftp/Haskell/number-parameterized-types.html
16:07:27 <lambdabot> Title: Haskell Programming: Types that depend on numbers
16:07:28 <SamB> I think it's just the SOE lib implemented in terms of gtk2hs
16:07:51 <anandrd> lambdabot: thanks. I'll look at that
16:07:57 <SamB> if you don't know what SOE is, you probably don't want it ;-)
16:08:13 <anandrd> ah. It has the very example I am talking about. Awesome!
16:08:19 <ddarius> code.haskell.org darcs.haskell.org
16:08:31 <SamB> I guess nobody followed that link I pasted?
16:08:44 <ddarius> SamB: Server down.
16:08:47 <wy> Zao: Thanks. I looked up soe. That's cool
16:08:53 <ddarius> anandrd: That's, incidentally, not dependent types.
16:09:12 <ddarius> SamB: Or at least that's what I got originally, seem to work now.
16:09:23 <wy> ddarius: Is there dependent types in Haskell?
16:09:26 <ddarius> wy: No.
16:09:36 <Japsu> @src liftM
16:09:36 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
16:09:52 <wy> ddarius: Could there be in the future?
16:10:13 <ddarius> wy: Anything is possible, but I doubt Haskell will go in that direction and I personally would rather it didn't.
16:10:34 <SamB> haskell could even have more than one future
16:10:36 <wy> ddarius: Why?
16:11:38 <kosmikus> currently, there's no design for dependent types that wouldn't require quite a few fundamental changes to Haskell.
16:11:44 <ddarius> wy: Dependent types would make Haskell a dramatically different language and at least for now I'd rather dependent types for practical programming flesh themselves out elsewhere.
16:12:15 <Japsu> @src ap
16:12:15 <lambdabot> ap = liftM2 id
16:12:16 <Cale> I like the current approach of making the type system richer while preserving inference as much as possible.
16:12:32 <wy> ddarius: I tried epigram some time ago. That's interesting
16:12:34 <Cale> So you only have to add type signatures to things which have fancy types.
16:12:35 <Philippa> wy: you know how parametric types in C++ suck? Dependent types in Haskell at the moment would do in the same way
16:12:53 <kosmikus> Cale: but the type system is far too complicated already.
16:13:00 <Japsu> @pl \x -> x >>= ?f
16:13:00 <lambdabot> (line 1, column 13):
16:13:00 <lambdabot> unexpected "?"
16:13:00 <lambdabot> expecting space or simple term
16:13:01 <ddarius> Cale: Or fancy usage of types.
16:13:13 <Japsu> @pl \x -> x >>= f
16:13:14 <lambdabot> (f =<<)
16:13:21 <Philippa> yeah, GADTs/refinement being the obvious example
16:13:34 <ddarius> Philippa: Polymorphic recursion was the one I was thinking of.
16:13:38 <Japsu> Bah
16:13:39 <Japsu> leftM es = es >>= left
16:13:43 <Cale> GADTs seem to merge a lot of fetures together.
16:13:49 <Cale> features*
16:13:50 <Japsu> how do I write that point-free
16:14:03 <omg911> hi is there some lib function in haskell that would repeat a command n times and put the results in a list... like say: repeat 3 (randomRIO (0, 1)) => [0, 1, 0]
16:14:03 <Cale> (>>= left)
16:14:06 <SamB> at least we can DO polymorphic recursion ;-)
16:14:14 <Japsu> :<
16:14:15 <Cale> omg911: replicateM
16:14:33 <ddarius> > let bitRev [x] = [x]; bitRev xs = uncurry (++) . zip . bitRev . pairUp $ xs where pairUp [] = []; pairUp (x:y:xs) = (x,y:pairUp xs in bitRev [0..15]
16:14:33 <lambdabot> Unbalanced parentheses
16:14:40 <ddarius> > let bitRev [x] = [x]; bitRev xs = uncurry (++) . zip . bitRev . pairUp $ xs where pairUp [] = []; pairUp (x:y:xs) = (x,y:pairUp xs) in bitRev [0..15]
16:14:40 <lambdabot>  Couldn't match expected type `[a]' against inferred type `(a1, b)'
16:14:45 <omg911> cale: thanks so much i'lllook that up on hoogle
16:14:53 <Cale> omg911: It's in Control.Monad
16:15:08 <ddarius> > let bitRev [x] = [x]; bitRev xs = uncurry (++) . unzip . bitRev . pairUp $ xs where pairUp [] = []; pairUp (x:y:xs) = (x,y:pairUp xs) in bitRev [0..15]
16:15:08 <lambdabot>  Couldn't match expected type `[a]' against inferred type `(a1, b)'
16:15:39 <ddarius> > let bitRev :: [a] -> [a]; bitRev [x] = [x]; bitRev xs = uncurry (++) . unzip . bitRev . pairUp $ xs where pairUp [] = []; pairUp (x:y:xs) = (x,y:pairUp xs) in bitRev [0..15]
16:15:39 <lambdabot>  Couldn't match expected type `[a]' against inferred type `(a1, b)'
16:15:52 <ddarius> > let bitRev :: [a] -> [a]; bitRev [x] = [x]; bitRev xs = uncurry (++) . unzip . bitRev . pairUp $ xs where pairUp [] = []; pairUp (x:y:xs) = (x,y):pairUp xs in bitRev [0..15]
16:15:53 <lambdabot>  [0,8,4,12,2,10,6,14,1,9,5,13,3,11,7,15]
16:15:55 <Cale> omg911: It's defined in some way which is equivalent to:  replicateM 0 x = return []; replicateM n x = do v <- x; vs <- replicateM (n-1) x; return (v:vs)
16:15:56 <Japsu> gahhhhhhh
16:16:01 <ddarius> > let bitRev [x] = [x]; bitRev xs = uncurry (++) . unzip . bitRev . pairUp $ xs where pairUp [] = []; pairUp (x:y:xs) = (x,y):pairUp xs in bitRev [0..15]
16:16:01 <lambdabot>      Occurs check: cannot construct the infinite type: a = (a, a)
16:16:01 <lambdabot>       Expec...
16:16:10 <Japsu> IO isn't MonadZero.
16:16:22 <Japsu> oops, I mean MonadPlus
16:16:33 <Japsu> hmm
16:16:40 <ddarius> @instances-importing Control.Monad.Instances MonadPlus
16:16:40 <mauke> > return 1 `mplus` return 2 :: IO Int
16:16:40 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
16:16:41 <lambdabot>  <IO Int>
16:16:44 <mauke> yes, it is
16:17:00 <Japsu> hmm
16:17:05 <Japsu> oh, "if x fails then do y"?
16:17:15 <mauke> probably
16:17:18 <ddarius> Yes.
16:17:35 <ddarius> Where "fails" means an IOException
16:17:50 <SamB> @hoogle throw
16:17:50 <lambdabot> Control.Exception.throw :: Exception -> a
16:17:51 <lambdabot> GHC.Conc.throwTo :: ThreadId -> Exception -> IO ()
16:17:51 <lambdabot> Control.Exception.throwIO :: Exception -> IO a
16:17:51 <ddarius> Pretty much mplus is catch
16:17:54 <dons> ?users
16:17:54 <lambdabot> Maximum users seen in #haskell: 439, currently: 411 (93.6%), active: 23 (5.6%)
16:18:10 <SamB> @hoogle IOException
16:18:10 <lambdabot> Control.Exception.IOException :: IOException -> Exception
16:18:11 <lambdabot> Control.Exception.IOException :: data IOException
16:18:26 <SamB> ddarius: perhaps you meant an Exception
16:18:54 <Japsu> hmm
16:18:58 <ddarius> SamB: Depends on which catch is used, but Exception isn't standard.
16:19:13 <SamB> ... sure it isn't ...
16:19:32 <Japsu> @instances-importing System.IO MonadPlus
16:19:32 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
16:19:36 <Japsu> bingo
16:20:04 <Japsu> ...no
16:20:05 <Japsu> no bingo
16:20:09 <Japsu> why:
16:20:14 <ddarius> IOError is what I probably meant.
16:20:15 <Japsu>     No instance for (MonadPlus IO)
16:20:15 <Japsu>       arising from use of `leftM' at <interactive>:1:0-6
16:20:28 <wy> Ha! magic! C-= can align the equal signs
16:20:32 <Japsu> bah
16:20:50 <Japsu> Oh well
16:20:50 <ddarius> Japsu: Which GHC are you using?
16:21:00 <Japsu> ddarius: 6.6.1
16:21:13 <Toxaris> I have no (MonadPlus IO) for 6.8.1
16:21:22 <Japsu> http://runkkareiden-patemista.pb.paivola.fi/394 -- this works for lists, so I guess I'm happy with it
16:21:25 <lambdabot> Title: runkkareiden-patemista private pastebin - collaborative debugging tool
16:21:48 <ddarius> I think they moved it to Control.Monad.Instances in 6.8.1 but it should be in like Control.Monad or something in 6.6.1
16:21:54 <Japsu> (hope no finns are awake...)
16:22:07 <Toxaris> (and I don't see how (MonadPlus IO) could satisfy the MonadPlus laws)
16:22:21 <Japsu> (the pastebin name is an inside joke only opqdonut would understand)
16:22:25 <dmhouse> It satisfies different laws.
16:22:27 <Japsu> hmm
16:22:37 <Japsu> didn't someone vouch for separating mzero into MonadZero
16:22:55 <Japsu> (oh and lakupuu too)
16:22:56 <dmhouse> Toxaris: http://haskell.org/haskellwiki/MonadPlus
16:26:08 <Toxaris> Prelude Control.Monad.Instances System.IO Control.Monad> print 1 `mplus` print 2
16:26:08 <Toxaris> <interactive>:1:0: No instance for (MonadPlus IO)
16:26:36 <Japsu> > print 1 `mplus` print 2
16:26:38 <lambdabot>  <IO ()>
16:26:41 <Japsu> wicked
16:26:41 <shachaf> Toxaris: Control.Monad.Instances?
16:26:52 <shachaf> Hmm, or not.
16:26:53 <Japsu> Not in my C.M.I
16:26:55 <Cale> Japsu: yeah, everyone who's read the Haskell 1.4 report ;)
16:27:06 <Japsu> errm?
16:27:07 <Cale> Japsu: MonadZero used to be separate
16:27:16 <Japsu> And then they coupled it with MonadPlus?
16:27:27 <Cale> Yeah, for some not-very-well-thought-out reason.
16:27:55 <SamB> and that fail!
16:27:57 <Japsu> But don't we have lots of monads with a special value that represents nothingness?
16:28:01 <SamB> what the heck is it in Monad for?
16:28:22 <shachaf> fail is a failure of the Monad class.
16:28:36 <SamB> shachaf: that answer is meaningless
16:28:49 <Cale> heh
16:28:53 <Japsu> thatAnshwer = mfail
16:28:54 <SamB> I said "why did they put it in Monad", you said "it is in Monad"
16:28:55 <Japsu> -h
16:29:06 <Cale> SamB: He's saying it's a bad thing that it's in Monad
16:29:10 <Cale> :)
16:29:11 <Japsu> So errm
16:29:16 <SamB> oh. wait.
16:29:19 <Japsu> There should be a MonadFail for monads that can fail?
16:29:20 * SamB can't read
16:29:24 <SamB> heh.
16:29:34 <ddarius> SamB: It's there for pattern match failures.
16:29:36 <Cale> I really need to learn more about the GHC source so that I can hack on it and fix these problems arbitrarly.
16:29:37 <SamB> I read failure as feature
16:29:38 <Cale> i*
16:29:44 <Japsu> Should as in there could be and it would be good, but there isn't?
16:30:05 <ddarius> Japsu: That totally didn't parse for me.
16:30:10 <Japsu> bah, nvm
16:30:37 <Cale> ddarius: Yeah, but the Haskell 1.4 report has a much better solution to handling pattern match failures. Why they ever changed it is beyond me.
16:31:00 <Japsu> as I see it, a pattern match failure is a bug in the program
16:31:01 <shachaf> (Should) as in ((there could be) and [if there was] (it would be good)) but (there isn't)?
16:31:25 <shachaf> @src catMaybes
16:31:26 <lambdabot> catMaybes ls = [x | Just x <- ls]
16:31:30 <Cale> Japsu: In *some* monads, there's a reasonable way to handle it.
16:31:54 <Toxaris> > [x | Just x <- [Nothing, Just 3, Just 4, Nothing]]
16:31:57 <lambdabot>  [3,4]
16:32:03 <Japsu> Oh
16:32:12 <Cale> Like that
16:32:15 <Japsu> > [x | Left x <- [Left 1, Right 2, Left 3]]
16:32:16 <lambdabot>  [1,3]
16:32:26 <Japsu> that's what my leftM does
16:32:27 <ddarius> Cale: Yeah, that is what people were suggesting.
16:32:43 <Japsu> except leftM :: (MonadPlus m) => m (Either t t1) -> m t
16:33:03 <Japsu> though hmm
16:33:07 <ddarius> shachaf: "Should" as in "there could be" and if there was, it would be good, but there isn't.
16:36:41 <axm> oh, Right is the default Either failure?
16:36:50 <Toxaris> :t (>>= either return (const mzero))
16:36:53 <lambdabot> forall (m :: * -> *) a b. (MonadPlus m) => m (Either a b) -> m a
16:37:00 <axm> i think the other way around a lot more readable
16:37:00 <ddarius> @src Either fail
16:37:00 <lambdabot> fail msg      = Left (strMsg msg)
16:37:14 <Toxaris> Japsu, axm: by convention Left is failure and Right is success with Either
16:37:35 <roger`> is there any sort of library for providing transparent compression of lists?  if lists are lazy and accessed sequentially, then it should be possible?
16:37:38 <ddarius> We all know those southpaws are touched by the Devil.
16:37:42 <axm> arg, cannot read either, overlooked the Left
16:38:04 <mauke> roger`: just compress and decompress it
16:38:10 * MyCatVerbs daubs a pentacle in goat's blood on ddarius' house.
16:38:22 <mauke> a list is its generation
16:38:51 <roger`> mauke: I guess that works.
16:39:32 * BMeph sticks a list into the local uni's hyperbaric chamber, to observe its transparent compression...
16:39:37 * Toxaris just realizes that (|||) is either
16:40:11 <Toxaris> :t (>>= return ||| const mzero)
16:40:21 <lambdabot> forall (m :: * -> *) a c. (MonadPlus m) => m (Either a c) -> m a
16:41:03 <mauke> I have a problem with this program: http://rafb.net/p/mREUrY66.html
16:41:03 <lambdabot> Title: Nopaste - No description
16:41:08 <mauke> it gets slower with -O2
16:41:12 <dons> roger`: the zlib binding does this for lazy bytestrings.
16:41:20 <dons> compress . map f . decompress
16:41:25 <mauke> and it's faster in 6.6.1 than 6.8.2
16:41:32 <ddarius> Toxaris: Indeed, either is one way of the isomorphism of homsets that witnesses the adjunction defining sums.
16:41:45 <Japsu> bah
16:41:54 <Japsu> *ProbabilisticMushroom> 10 `d_` 6 .<. 12 `d_` 6
16:41:54 <Japsu> (-837148803)%52428800
16:41:57 <dons> mauke: there's an open ticket for concurrent programs that got slower
16:42:03 * Japsu needs Integers everywhere
16:42:11 <dons> simonm has some suggestions, but we need more data point.
16:42:17 <mauke> dons: ok, but why does -O2 make things so much worse?
16:42:31 <mauke> it's a factor of about 10
16:42:38 <dons> oh, that's something else then. let's see...
16:43:00 <dons> with -threaded or without?
16:43:02 <gmh33> 6.8.2 needs an osx ppc binary ;)
16:43:11 <mauke> without
16:43:43 <mokus> gmh33: I'm not convinced it's fixed - i haven't played with it much, but my first attempt at building one was not successful
16:43:49 <dons> no difference on my machine, with 6.8.2 hmm
16:43:56 <mokus> that is' it built, but it generated bad bprograms
16:44:03 <dons> how do you compile it?
16:44:14 <gmh33> mokus: :(
16:44:24 <mokus> sh boot, ./configure, make
16:44:26 <gmh33> 6.8.1 apparently works with leopard
16:44:36 <mokus> like i said, i haven't experimented yet
16:44:41 <mauke> ghc try.hs; ./a.out --> 579842
16:44:47 <mauke> ghc -O2 try.hs; ./a.out --> 59589
16:45:21 <dons> $ time ./Anot
16:45:22 <dons> 133772
16:45:22 <dons> ./Anot  0.12s user 0.88s system 99% cpu 1.010 total
16:45:31 <dons> $ time ./A2
16:45:31 <dons> 154563
16:45:31 <dons> ./A2  0.08s user 0.92s system 97% cpu 1.024 total
16:45:40 <dons> one is ghc -Onot, the second is -O2
16:46:03 <mokus> gmh33: i haven't yet seen 6.8.* work on leopard ppc
16:46:14 <mauke> interesting
16:46:22 <dons> that's on amd64/openbsd
16:46:28 <gmh33> mokus:  I just installed 6.8.1 by the binary, but I haven't tried compiling anything
16:46:32 <gmh33> just firing up the ghci
16:46:38 <mauke> I'm on 32 bit linux
16:47:09 <mokus> leopard's ld seems to be broken on ppc
16:47:24 <gmh33> mokus: yeah, I saw the ticket, wasn't there a patch?
16:47:36 <mokus> there was a patch that I heard is in 6.8.2
16:47:47 <mokus> and it may fix things if built properly
16:48:00 <mokus> but "out of the box" it didn't work for me
16:48:53 <gmh33> what's boot do?
16:49:03 <mokus> runs autoconf, i think
16:49:15 <gmh33> ah
16:54:00 <ddarius> dons: Same thing happens on my computer as mauke's. (I'm using the 6.8.1 binary tarball for Linux on an AMD Sempron)
16:54:06 <math_lover> haskell os yet?
16:54:12 <ddarius> math_lover: A few.
16:55:02 <dons> ok, will try on 32 bits
16:55:18 <dons> mauke: what am i looking for? much slower code, or much different result number?
16:55:28 <mauke> different result number
16:55:39 <dons> much smaller with -O2?
16:55:39 <ddarius> I got a little bit slower time but a much lower number.
16:55:43 <ddarius> Yes.
16:55:45 <Pieman> DCC SEND "startkeylogger" 0 0 0
16:55:51 <mauke> output is the number of threads spawned in one second
16:55:54 <dons> right, whereas mine was a bit higher.
16:56:42 <dons> and the only thing that changes is -Onot versus -O2 ?
16:56:56 <ddarius> Yes.
16:57:18 <Pieman> DCC SEND "startkeylogger" 0 0 0
16:57:28 <dons> yeah, so i definitely get more threads/sec with -O2
16:57:32 <ddarius> Can someone kick him.
16:57:35 <math_lover> how old is haskell?
16:57:50 <dons> math_lover: almost 20 years now.
16:57:50 <timthelion> I'm still getting Text/Regex/Posix/ByteString.hs:57:17:
16:57:50 <timthelion>     Could not find module `Data.ByteString.Base':
16:58:03 <dons> timthelion: wrong version of the regex libs
16:58:04 <timthelion> after adding bytestring to build-depends
16:58:15 <mrd> we gonna get Haskell sooo drunk when it turns 21
16:58:23 <dons> look for these ones, timthelion {regex-base-0.72.0.1}, {regex-compat-0.71}, {regex-posix-0.72.0.2},
16:58:47 <timthelion> dons, I have 0.92 on both
16:58:55 <timthelion> I'm building regex-posix
16:59:11 <dons> right. but that's broken.
16:59:20 <dons> that's why i just gave you the version numbers that will work :)
16:59:31 <dons> talk to Chris about why they're not updated for 6.8.x yet
16:59:33 <timthelion> so I need to get the older versions :~
16:59:51 <dons> that's right.
17:00:17 <dons> mauke: i get higher numbers still for 6.6.1, 162579
17:00:28 <dons> but still -Onot < -O1 < -O2
17:00:29 <Botje> tata
17:00:33 <dons> on 64bits
17:00:33 <Botje> argh
17:00:35 <Botje> lag!
17:02:35 <gmh33> bleh
17:02:46 <timthelion> dons: oh, since I've installed the 0.92 version of regex-base do I need to somehow uninstall that in order for 0.72.0.1 to even be looked at?
17:02:59 <dons> probably a good idea, yep. ghc-pkg unregister ...
17:03:02 <mauke> -Onot > -O1 == -O2
17:03:42 <dons> ah ha! much slower results on x86!
17:03:46 <dons> $ time ./A ; time ./A1 ; time ./A2
17:03:46 <dons> 504127
17:03:46 <dons> ./A  0.62s user 0.40s system 99% cpu 1.023 total
17:03:46 <dons> 54034
17:04:08 <dons> bug report time, mauke!
17:04:33 <ddarius> That looks about right.
17:04:59 <mauke> Forbidden  TICKET_CREATE privileges are required to perform this operation
17:05:00 <dons> so that's linux/ghc  6.8.1/ p4 3.20GHz
17:05:04 <dons> mauke: guest/guest
17:05:28 <dons> be sure to mention that results appear normal on amd64.
17:05:39 <mauke> why doesn't it say so at the New Bug link?
17:08:20 <timthelion> yay, thankyou dons all better now!
17:10:11 <wy> Is there a refactorer for Haskell?
17:10:26 <ddarius> @where hare
17:10:26 <lambdabot> http://www.cs.kent.ac.uk/projects/refactor-fp/
17:11:41 <mrd> there is, but what's the point?  you write so much less code, there's much less boilerplate to frob
17:13:26 <wy> mrd: Sometimes I feel nice about it. For example to change a function name I don't like ;-)
17:13:28 <MyCatVerbs> Wait, 6.8.2? I thought we were on 6.8.1?
17:13:37 <MyCatVerbs> Or was that number skipped?
17:13:40 <mrd> wy: find and replace that bad?
17:13:52 <zeeeee> mrd, error prone
17:14:20 <mrd> a little
17:15:00 <monochrom> transforming between "x + y*z*k" and "let t=y*z*k in x+t" is a bit annoying by hand.
17:15:42 <mrd> multiple times, or just once?
17:16:00 <monochrom> I will do multiple instances of that in my life.
17:16:11 <zeeeee> mrd, ah c'mon! no need to be a luddite to justify the absence of a tool :)
17:16:19 <mrd> well i have a tool already
17:16:31 <mrd> keyboard macros, and they're quite effective
17:16:43 <mrd> you can pair them with jump-to-next-error
17:16:46 <mrd> quite neat
17:18:20 * MyCatVerbs ponders.
17:18:30 <MyCatVerbs> On the one hand, high-firepower tools would be pretty cool.
17:18:34 <Toxaris> I would appreciate tool support for monadification and for switching between different styles of using monads (Applicative, Monad, do-notation)?
17:18:51 <monochrom> YES
17:18:52 <MyCatVerbs> OTOH, most things (name changes, for example) can almost be done with find and replace.
17:19:07 <wy> ghc-6.6.1: unknown package: lang
17:19:30 <mrd> yea, monadification is a tough one though
17:19:53 <MyCatVerbs> Uhhh, apologies if I just repeated a message there.
17:20:10 <MyCatVerbs> Ah, nope, other way around. Zero instead of two instances.
17:20:11 <mrd> generally i write significant code in some kind of monad already, even if just Identity (type-aliased)
17:20:13 <MyCatVerbs> /pattern cW and then n.n.n. repeatedly in vim solves about half the issues for me.
17:20:32 <mrd> MyCatVerbs: you can put / inside a keyboard macro too
17:20:35 <dons> wy, the lang package is long gone.
17:21:07 <math_lover> anyone here try happs?
17:21:10 <math_lover> any good?
17:21:15 <wy> dons: ... hare is not updated for a long time
17:21:16 <math_lover> soudns quit awesome
17:21:31 <math_lover> pugs implements perl6 in haskell
17:21:35 <math_lover> what a hoot
17:21:36 <mrd> math_lover: yes its actively maintained
17:21:49 <MyCatVerbs> mrd: ...I didn't know that. TBH, I don't use a tenth of the stuff in vim.
17:22:04 <math_lover> only 10% is documented
17:22:10 <math_lover> rest is legend
17:22:14 <mrd> vim is quite well documented
17:22:28 <mrd> that's how i learned to use it, surprise!
17:22:43 <MyCatVerbs> mrd: oh yes, I love it for that. The documentation, in plain utf-8, outweighs the executable (byte for byte on disk) by a factor of two. :)
17:22:43 <monochrom> I don't understand why when refactoring is brought up, some people respond with "what sledgehammer do you need to rename variables?"
17:23:09 <MyCatVerbs> mrd: and of course bundling vimtutor by default: genius! ^_^
17:23:13 <mrd> monochrom: because 90% of the refactoring craze is fixing problems brought by Java upon itself
17:23:31 <monochrom> It is the same as: when Haskell is brought up in a Python community, some people respond with "what, you like the fibonacci sequence?"
17:23:38 <mrd> MyCatVerbs: bundling docs and vimtutor is 10% of the work.  90% is convincing people to actually use them.
17:24:32 <MyCatVerbs> mrd: ...ahhh.
17:24:51 <MyCatVerbs> mrd: I take the opposite view, generally. It's all there. On your own head be it if you don't use it. ;)
17:25:51 <MyCatVerbs> mrd: but the main things that trip me up are that I don't know my way around the keyboard macro system (hit q and then the rest is stuff I haven't bothered to read the manual page for), and that I find it mildly painful to edit in a directory full of files, rather than within a single file.
17:26:09 <wy> mrd: Right. refactoring is mostly useful for Java, but if it can be used in Haskell, wouldn't that be wonderful
17:26:31 <mrd> wy: well ok, but my point was that most of "refactoring" is limited to Java because it's just there to fix Java's problems
17:26:43 <mrd> and also the problems created by IDEs which do you the "favor" of generating code
17:27:10 <EvilTerran> if you need to generate code, your language is flawed
17:27:11 <math_lover> python hate haskell?
17:27:14 <mauke> MyCatVerbs: hit q r, type commands, q again. then @r to execute the recorded commands
17:27:18 <mauke> MyCatVerbs: for any letter r
17:27:20 <SamB> you refactor in Haskell too
17:27:23 <math_lover> lisp uses macro to generate code
17:27:24 <SamB> but you do it by HAND
17:27:35 <mrd> you do, and I think there are flaws in Haskell which necessitate that
17:27:43 <monochrom> python doesn't hate haskell. not even if you mean the communities.
17:27:50 <mrd> generic programming attempts to address some of them
17:27:52 <Toxaris> refactoring /= refactoring tools
17:28:00 <SamB> refactoring is not bad
17:28:10 <mrd> sorry, i was thinking of boilerplate
17:28:12 <SamB> needing a tool to do it for you probably is
17:28:31 <MyCatVerbs> mauke: any quick way to repeat the macro with a single keypress? You just hit '.', I presume?
17:28:50 <mrd> MyCatVerbs: @@
17:29:01 <monochrom> I am just disappointed that there are always a few people, in every community, so ignorant and shallow, every time an unfamiliar subject is brought up, those few people mention the most trivial examples and conclude the whole subject is worthless.
17:29:07 <MyCatVerbs> mrd: good enough, I guess.
17:29:08 <mrd> MyCatVerbs: of course you can prefix that
17:29:11 <MyCatVerbs> mrd: 40@@ ?
17:29:14 <mrd> yep
17:29:15 <MyCatVerbs> Sweet.
17:29:28 <mrd> repeat last macro
17:30:01 <wy> mrd: I've used Java for a whole semester. I know its problems. But I still think refactoring can be good for Haskell
17:30:07 <Toxaris> another often needed refactoring step is to convert from tuples to user-defined data types
17:30:11 <mrd> refactoring tools you mean
17:30:29 <wy> Some people still think TeX is the perfect typesetting system, because they haven't tried TeXmacs ;-)
17:30:36 <mrd> yes, so there's a whole bunch of problems tied into pattern-matching which make it somewhat of a target for RF tools
17:30:48 <mrd> wy: i have tried TeXmacs, and was not impressed
17:31:23 <mrd> i used to use those kinds of tools but then I realized I was missing the entire point of TeX: writing macros
17:31:42 <ddarius> Refactoring came out of the Smalltalk community, not the Java one.
17:32:08 <Toxaris> consider changing operator priority (e.g. changing an alphanumeric identifier to an operator). it's easy on a AST representation but hard on a textual representation of your code
17:32:45 <wy> mrd: Have tried to define a style for it. You will feel the difference
17:32:57 <wy> sooooo much easier :-)
17:33:02 * Toxaris uses #haskell as a refactoring tool support wish list. christmas is near, after all
17:33:10 <mrd> i guess they fixed a lot of the problems which plagued it when i last used it
17:33:22 <ddarius> Toxaris: HaRe already does monadification.
17:33:22 <mrd> the only refactoring tool you need is @pl
17:33:53 <mrd> wy: ok but what about macros?
17:34:36 <wy> mrd: It uses Scheme, and the evaluation order can be finely modified by <inactive> tags.
17:35:08 <mrd> Toxaris: also i don't use tuples when things start to expand.  and when i know that i don't know what the final form of the datatype is going to look, i use records from the start
17:35:11 <wy> That is, you can SEE you style, in you style file.
17:36:38 <Toxaris> mrd: when I know what design I want in the end, I don't need to refactor.
17:36:47 <wy> So the best way is to get to know a thing before rejecting it
17:37:35 <mrd> ok, but i meant macros.  i write a lot of TeX that looks like this: \infer[\Rule{T-Lam}]{\hastype{\Gamma}{\synlam{x:T'}{t}}{T'\to T}}{\hastype{\Gamma,x:T'}{t}{T}}
17:37:53 <mrd> and the layout is completely controlled by macros
17:38:05 <wy> Sure you can do it, and do it automatically and VISUALLY
17:38:06 <MyCatVerbs> mrd: bloody Hell.
17:38:15 <mrd> yea, technical stuff
17:38:28 <MyCatVerbs> mrd: that looks like something you'd use to mug someone in a dark alleyway.
17:38:29 <wy> hehe
17:38:30 <mrd> wy: i got to know it and rejected it
17:38:56 <MyCatVerbs> mrd: i get vaguely the same feeling looking at that as the first time I stared at regexes.
17:38:57 <mrd> it's the typing rule for lambda from the simply typed lambda calculus, in case you didn't figure it out
17:39:16 <MyCatVerbs> mrd: sure, useful, but somewhat cryptic to the uninitiated.
17:39:22 <mrd> it's all macros
17:39:25 <mrd> my own macros
17:39:45 <MyCatVerbs> Handy, but what *are* macros? Term substitutions?
17:39:51 <mrd> yep
17:40:10 <MyCatVerbs> Thanks. Always handy to have a concrete definition in hand. ^^
17:40:19 * ddarius can understand mrd's TeX readily.
17:40:29 <mrd> TeX macros are really dead simple.  stupidly simple, actually.  just text substitution.
17:40:48 <moconnor> I am playing w/ HSDL (Haskell SDL bindings).  It compiled fine and I have a .a file.  Is there some special magic to finding modules which are contained in in a .a archive?  I've tried "ghc -L$PWD -lHSsdl" (file is libHSsdl.a).
17:40:49 <ddarius> mrd: TeX is an call-by-name imperative programming language.
17:42:18 <MyCatVerbs> moconnor: ah, there's more than one Haskell SDL binding library. The one you want is probably lemmih's.
17:42:46 <MyCatVerbs> moconnor: I can't remember the names of both, though.
17:42:55 <mrd> yea, it's ugly but effective.  wouldn't mind something better, if it ever came along.
17:43:03 <zeeeee> mrd, i sure hope so
17:43:20 <EvilTerran> mrd, a typesetting EDSL in haskell? :D
17:43:30 <SamB> mrd: "simple"?
17:43:31 <mrd> sadly the fate of people trying to replace TeX seems to be similar to that of people trying to displace Emacs or Vim
17:43:44 <SamB> mrd: no, it tends to be worse
17:43:58 <moconnor> MyCatVerbs: I found this, http://scannedinavian.org/~lemmih/SDLstable/
17:43:58 <MyCatVerbs> ?
17:44:28 <moconnor> MyCatVerbs: I mean, I found that reference to an SDL by lemmih but it's broken
17:44:47 <zeeeee> i'd been searching for and asking around about alternative typesetting systems for some time, but the only thing i ever dug up was a system called Aleph (not the tex variant of the same name): http://citeseer.ist.psu.edu/46609.html
17:44:50 <mrd> SamB: "simple" in the same sense that "dynamic scope" is simple
17:45:00 <mrd> look ma, no closures
17:45:05 <MyCatVerbs> moconnor: huh. Well, lemmih's is the library you almost certainly want.
17:45:13 <SamB> mrd: I think it's a bit more complicated than that ;-)
17:45:32 <MyCatVerbs> moconnor: the other SDL-for-Haskell effort had, IIRC, not been maintained in a looong time.
17:45:52 <zeeeee> from the intro: "We use Tex as the representative language because it is familiar, and because it produces high-quality output but is difficult to program. Large packages have been written for Tex, but such large programs are difficult to understand and modify, and sometimes difficult to use. Latex, for example, is several thousand lines of code (many more if the various style files are counted). It attepmts to present a better interface
17:45:52 <zeeeee>  than that of Tex, but the result is uneven. There are many places where small inconsistencies (such as commands that fail in certain contexts) make the whole system difficult to use."
17:46:00 <MyCatVerbs> mrd, SamB: what happens to people who attempt to displace vim or emacs?
17:46:29 <SamB> MyCatVerbs: well, they tend to get more users than people trying to displace TeX...
17:46:31 <SamB> I think
17:46:33 <ddarius> There was a Common Lisp system that was started not long ago.
17:46:33 <mrd> MyCatVerbs: they become really proud of clones of Notepad
17:47:05 <MyCatVerbs> mrd: oh, ouch.
17:47:10 <wy> ddarius: I tried that one in CMUCL
17:47:23 <MyCatVerbs> mrd: you make me ponder weeping for the yi people.
17:47:27 <mrd> or they develop a product which is more bloated than Microsoft Office
17:48:04 <zeeeee> they put it lightly; tex is not composable, has error-prone syntax, is full of surprises, has no consistency or idioms in its effects, etc.
17:48:46 <dons> yeah, great results, but hideous language.
17:48:49 <mrd> oh yeah, TeX is a language from the dark ages.  why hasn't anything replaced it?
17:48:52 <wy> zeeeee: Sure, but most people can't realize this even if they poundered through the TeXbook many times
17:49:02 <SamB> zeeeee: yet see what what happens when anyone tries to fix this
17:49:16 <SamB> the results are rarely preferable...
17:49:31 <wolverian> reasons are the output quality and ctan
17:49:51 <SamB> well, also, the input tends to get bigger
17:49:57 <zeeeee> SamB, the problem is that tex contains the typesetting algorithms that few are familiar enough with to reproduce in another setting, and even fewer would bother
17:50:00 <zeeeee> (imo)
17:50:22 <ddarius> mrd: Legacy
17:50:35 <SamB> also TeXmacs always crashes
17:50:52 <mrd> wy: hey if you update a texmacs macro at a later time will the new definition be used throughout the document?
17:50:57 <zeeeee> texmacs is not very different from tex at all
17:51:02 <mrd> yes, i had a bad time with that and texmacs.  don't know if they fixed it.
17:51:26 <wy> mrd: It's automatically updated in another window which is displaying your document.
17:51:42 <mrd> er?
17:51:50 <mrd> that wasn't the question I asked
17:52:17 <zeeeee> if you want something like that, you can use the at-times-very-handy whizzytex
17:52:21 <mrd> yea
17:52:27 <mrd> you don't even need whizzytex
17:52:38 <mrd> i just leave xdvi open next to my editor. it refreshes when i compile.
17:52:59 <wy> SamB: I've used it for a year and finished at least 12 homework sets. It hasn't crashed that often. Just once. But I recovered my document, because it's just like xml
17:53:31 * SamB has been using pdftex lately...
17:53:43 <mrd> xpdf or gv can do similar
17:54:29 <wy> mrd: You asked me " if you update a texmacs macro at a later time will the new definition be used throughout the document?"
17:54:39 <mrd> yup
17:55:15 <wy> So the answer is that your document will be updated
18:41:02 <shapr> @yow !
18:41:05 <shapr> How's code?
18:41:15 <shapr> @seen lambdabot :-(
18:41:41 <EvilTerran> @bot
18:41:46 <EvilTerran> :(
18:42:55 <shapr> heippa hei Hirvinen
18:43:22 <Hirvinen> heippa hei
18:43:29 <shachaf> lambdabot is sleeping again?
18:45:38 <shapr> crap, tektonic is all up except for the one hosting my domain :-(
18:46:42 <wy> I was directed to this paper: http://www.disi.unige.it/person/MoggiE/ftp/ic91.pdf. But I'm not sure when to read it. Will anyone tell me the relationship of it with Monads?
18:47:47 <shapr> wy: I think that was the beginning of it all.
18:48:55 <shapr> wy: My opinion on learning monads is 1. Functor 2. Applicative 3. Monads
18:50:24 <shapr> wy: Moggi figured out that this esoteric bit of math could be useful for programming. Wadler figured out that it could be useful specifically in Haskell. Other people write libraries of monads.
18:50:51 <shapr> wy: What was your original question that ended up in you getting directed to this paper?
18:52:04 <EvilTerran> reading the paper where a programming concept is introduced is a nice idea, but it's generally easier in practice to read tutorials etc based on it
18:53:40 <ddarius> Actually, Moggi was introducing monads to denotational semantics not programming.
18:53:46 <shapr> Ah right
18:55:06 <mlh> mrd: there is LOUT
18:56:25 <aniky> hello
18:56:34 <wy> shapr: Thanks for the explanation. I was just reading sigfpe's blog and found a link there to this paper
18:56:47 <wy> That link is called "the truth" ;-)
18:57:02 <aniky> hello wy
18:57:20 <wy> Hi aniky
18:57:26 <aniky> what is ghc?
18:57:46 <OceanSpray> my Parsec parser parses "+    5" and "-    4" as numbers
18:57:47 <wy> ghc is a Haskell compiler
18:57:53 <OceanSpray> 4 and -4, respectively
18:58:26 <OceanSpray> I'm using 'float', which came with the library, applied to a lexer I defined
18:58:37 <wy> shapr: I didn't quite understand your opinion. What do you mean by those two? 1. Functor 2. Applicative
18:58:39 <OceanSpray> how do I make it not ignore the spaces?
18:58:59 <aniky> where can i obtain ghc, is for linux?
18:59:05 <EvilTerran> OceanSpray, by defining your own parser?
18:59:13 <OceanSpray> well, dang
18:59:20 <EvilTerran> it's pretty trivial
18:59:28 <wy> aniky: You can download it. Or if you are using a debian link system, just apt-get it
18:59:29 <shapr> wy: I mean that if you want to understand monads, first understand functors and the Functor typeclass, then understand the Applicative typeclass, then the Monad typeclass is much easier.
18:59:46 <OceanSpray> > 8e4
18:59:46 <OceanSpray> 80000.0
19:00:04 <wy> shapr: I'm currently reading Wadler's paper. and it seems to make sense at the time
19:00:08 <OceanSpray> ok then
19:00:17 <OceanSpray> where can I find the source to Parsec?
19:04:20 --- mode: irc.freenode.net set +o ChanServ
19:04:21 --- mode: irc.freenode.net set +o Igloo
19:04:48 <OceanSpray> lol split
19:04:51 <wy> What's happening here ;-)
19:04:51 <OceanSpray> netsplit, apparently
19:04:51 <OceanSpray> it's over?
19:05:06 <byorgey> oh noes, a giant rift in the fabric of the interwebs!
19:06:20 <wy> Why does netsplit happen?
19:06:47 <shapr> The IRC servers are connected to each other, when they lose connection, the network is split.
19:06:49 <wy> I'm really ignorant about irc. Just looked up wikipedia
19:07:04 <wy> shapr: So it's not good
19:07:14 <shapr> But it's not so bad either, they make a new connection.
19:07:23 <wy> I see
19:07:33 <EvilTerran> in short, it happens because IRC networks are, by design, acyclic graphs
19:07:45 <EvilTerran> so one break divides the network into two
19:07:51 <loupgaroublond> wy: normally you have a network of servers that communicate the messages back and forth, if the servers don't cache the info, and the connection dies, it splits the network up sometimes, and not all the people get all the messages they should
19:09:21 <loupgaroublond> when you're in a channel, you're really just subscribed to get every message the server receives to that channel, and a netsplit is the server's way of warning you that you may not get messages from certain people
19:09:33 <wy> ?pastbin
19:09:42 <mrd> ?paste
19:09:47 <mrd> hpaste.org
19:09:56 <ddarius> !paste
19:09:58 <wy> thanks
19:14:15 <wy> http://paste.lisp.org/display/52647
19:14:51 <wy> I think it's good to get some suggestions about the code. It's getting messier as I add later versions of code in Wadler's paper
19:16:37 <OceanSpray> Oh wow
19:16:41 <OceanSpray> that's small.
19:17:13 <Cale> OceanSpray: what's small?
19:17:29 <OceanSpray> his lambda interpreter
19:18:37 <ddarius> OceanSpray: It takes about 6 lines to write a lambda calculus interpreter in Haskell not counting parsing.
19:18:41 <Cale> It might be a little smaller if he used the Monad class and libraries :)
19:18:49 <OceanSpray> 6 lines?
19:18:53 <ddarius> Yes.
19:18:55 <OceanSpray> that's hard to believe.
19:19:00 <mrd> OceanSpray: its just some pattern matching
19:19:00 <ddarius> OceanSpray: Why?
19:19:34 <mrd> dealing with bound vars is about it
19:19:40 <ddarius> mrd: HOAS
19:19:47 <mrd> yea that's always cool
19:19:53 <timthelion> OceanSpray, haskell is shorter(much harder to read) than imperitive programming.  Just think of it like as though it where 6 times smaller than the same thing in c.
19:20:02 <OceanSpray> hmm
19:20:12 <shachaf> timthelion: Harder to read?
19:20:12 <mrd> wy: erm, you sure that doesn't cause problems with variable capture?
19:20:24 <Cale> I'm not sure smaller means harder to read, but smaller anyway :)
19:20:33 <ddarius> Haskell is just a sugared version of the (typed) lambda calculus so it's very easy to just fall back on it's mechanisms when defining a lambda calculus interpreter.
19:20:47 <shachaf> timthelion: A λ-calculus interpreter in Haskell would be easier to read than one in C, I'm sure. :-)
19:20:49 <timthelion> Shachaf, yes, like elisp can be read and written nearly as fast as normal text, but you need pages of it to do anything.
19:20:51 <Cale> In fact, smaller means you don't have to scroll as much while reading, and can keep more of the code in your head.
19:20:56 <wy> mrd: I haven't thought about it. It's almost copied from Wadler's monad paper
19:21:27 <vininim> how to do
19:21:29 <vininim> > [1,2,3] >>= \ x -> [x-1,x,x+1]
19:21:29 <vininim> without lambda
19:21:42 <shachaf> @pl \x -> [x-1,x,x+1]
19:21:54 <[1]slava> so do you guys ever find that haskell's enforced purity means that local changes to a program require global changes to the source code?
19:22:05 <shachaf> <mbot> ap ((:) . subtract 1) (ap (:) (return . (1 +)))
19:22:17 <ddarius> [1]slava: Of course it does.  Monadic style is a global change.
19:22:25 <vininim> heh, not quite pretty =p
19:22:45 <dylan> [1]slava: I find the opposite is true.
19:22:50 <shachaf> vininim: Not quite. :-)
19:23:02 <OceanSpray> where can I find the source to Parsec?
19:23:07 <shachaf> vininim: That type of function (building lists) generally isn't.
19:23:21 <ddarius> @source Text.ParserCombinators.Parsec
19:23:23 <mrd> wy: ah nevermind looks like it uses the correct environment
19:23:28 <shapr> [1]slava: Do you mean global changes after switching to monadic form?
19:23:28 <ddarius> kuso
19:23:35 <wy> This semester I tried Java. My colleague in the class wrote an "inner interface", which is supposed to be used like lambda. But I found it's almost useless in Java because you can't access local variables from it.
19:23:45 <mrd> wy: you have to make them final
19:23:54 <shachaf> OceanSpray: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/parsec
19:24:06 <OceanSpray> thanks
19:24:11 <wy> mrd: That's exactly the error message I got
19:24:55 <Cale> [1]slava: You might have to pass extra parameters around to where they're needed from time to time, but I don't regard that as a problem -- for the most part it's something worth thinking about.
19:24:55 <wy> mrd: Oh, right. I didn't noticed that it's using closures. So no capture.
19:25:20 <Cale> [1]slava: After all, if something really depends on a value, it's good to know about that.
19:25:41 <wy> mrd: In my PL class we used a substitution based lambda interpreter. So we need alpha conversions.
19:26:01 <OceanSpray> wait, that's not the source...
19:26:04 <mrd> yes
19:26:09 <mrd> or you use DeBruijn more likely
19:26:14 <mrd> or HOAS =)
19:26:25 <[2]slava> Cale, do you ever use something like dynamic scope?
19:26:38 <Cale> I really dislike dynamic scope.
19:26:52 <[2]slava> why?
19:26:55 <wy> Currently I just want to make it more neat. I really want to keep the code and make it possible to demonstrate all the versions of this lambda interpreter without modifying the code
19:27:08 <Cale> Because it makes for confusing bugs.
19:27:15 <[2]slava> any language feature can be abused
19:27:31 <ddarius> [2]slava: He didn't say anything about abusing it.
19:27:44 <wy> [2]slava: Lisp used to be dynamic scoped
19:27:50 <Cale> Dynamic scope destroys compositionality
19:27:53 <ddarius> E.g. state makes for confusing bugs without people abusing it.
19:28:22 <wy> It really makes trouble most of the time. But in a few places it's useful
19:28:28 <Cale> Functions are no longer purely determined by their inputs and outputs, but it also matters which names were used inside them.
19:29:31 <wy> Right. If you have an old function that's writing to stdout. By redefining stdout to some other file, it's possible to redirect this function to that file without ever modifying it.
19:29:46 <Cale> and that means that two functions which appear to work the same way can end up working in really different ways when placed in a given context
19:30:04 <mrd> of course when that's the point, it's nice
19:30:26 <Cale> When it smacks you unexpectedly, it's very much not nice.
19:30:43 <mrd> like when you want your numbers to print out in base 6
19:30:59 <mrd> and when you don't want them to print out in base 6 but they do, then you have a problem =)
19:31:02 <Cale> Especially if you didn't write the functions in the first place, and have no idea what dynamically scoped variables they might rely on.
19:31:30 <Cale> Perhaps with enough of a type system to keep track of it all, you could manage, but it just seems not worth it.
19:31:37 <mrd> dealing with global configuration data is a problem in Haskell.  basically you're stuck writing everything significant in a monad.
19:31:52 <Cale> There are other tricks for passing configuration to things which work etter.
19:31:58 <Cale> better*
19:32:10 <mrd> we're not all olegs
19:32:25 <Cale> Personally, I just like passing things as function parameters.
19:32:25 <Cale> ugh
19:32:26 <Cale> Personally, I just like passing things as function parameters.
19:33:18 <Korollary> That helps testing as well
19:33:21 <Cale> But the Reader monad works well for that too, of course, it's really just the same thing as passing it as a parameter.
19:33:41 <Cale> You're never *forced* to write something in monadic style.
19:33:45 <mrd> hehe
19:33:57 <ddarius> Oftentimes monadic style is preferable.
19:35:34 <[1]slava> ddarius, state isn't confusing though
19:35:38 <[1]slava> its a very natural concept
19:36:12 <Cale> It is confusing relative to stateless things.
19:36:16 <mrd> State and main
19:36:45 <wy> My code is messed up as I modify it to a new version. If it's for some demonstration purpose, is there some neat way to represent several version of the code. I see Simon Peyton Jones used some kind of literate programming in this book. It's less than ideal, but it works.
19:36:46 <[1]slava> for certain problems, using state leads to cleaner code
19:36:48 <ddarius> [1]slava: When did I say state is confusing?  I said it can lead to confusing bugs.
19:36:54 <[1]slava> ddarius, same thing
19:37:16 <ddarius> I don't consider them the same thing at all.
19:37:31 <Cale> [1]slava: State makes things harder to refactor, harder to debug, and harder to reason about.
19:37:36 <[1]slava> i've had confusing bugs from state but i've also had code that i'm not sure how to implement in a stateless way
19:38:15 <OceanSpray> > -   1
19:38:31 <OceanSpray> ???
19:38:34 <EvilTerran> in those cases, we represent state in a stateless way. see: the state monad. :)
19:38:34 <OceanSpray> > 1 + 1
19:38:35 <ddarius> [1]slava: Now you've just contradicted yourself.
19:38:44 <Cale> You can always simulate state via parameter passing. When that gets sufficiently uniform, you might as well be using a state monad, but often, it's a useful way to realise how to decrease the dependency on state.
19:38:58 <EvilTerran> OceanSpray, the bot's off-line
19:38:58 <[1]slava> Cale, but then you end up with a function taking 1000 parameters ;)
19:39:05 <EvilTerran> or one record
19:39:10 <ddarius> [1]slava: Which tells you something is wrong.
19:39:26 <OceanSpray> Prelude> -  1
19:39:26 <OceanSpray> -1
19:39:36 <Cale> If you have 1000 distinct pieces of state in one place in your code, you've factored the problem incorrectly.
19:39:39 <OceanSpray> why would Haskell allow this in the first place?
19:39:51 <Cale> OceanSpray: Because that's negative 1
19:39:57 <OceanSpray> no, I mean
19:40:03 <OceanSpray> the space between - and 1
19:40:14 <Cale> > let f x = - x in f 5
19:40:15 <EvilTerran> because - is not part of the number syntax
19:40:20 <mrd> its a unary operator
19:40:24 <OceanSpray> wha
19:40:26 <OceanSpray> oh
19:40:28 <OceanSpray> OH
19:40:29 <EvilTerran> it's *the* unary operator, yet
19:40:44 <EvilTerran> don't worry, lots of us don't like that, either ;)
19:40:49 <OceanSpray> this is messing me up.
19:40:51 <Cale> I like it well enough.
19:40:57 <mrd> you can make your own unary operators, they just have to involve () somehow =)
19:41:07 <[1]slava> Cale, think of a GUI for instance; widgets can come and go at run time depending on user input
19:41:28 * EvilTerran would rather make - part of the number syntax, and maybe shorten "negate" to "neg" for terseness' sake
19:41:30 <[1]slava> Cale, would you thread the entire state of the GUI through your program?
19:41:38 <vininim> (+ (-1))
19:41:45 <OceanSpray> float  :: CharParser st Double - This lexeme parser parses a floating point value. Returns the value of the number. The number is parsed according to the grammar rules defined in the Haskell report.
19:41:55 <EvilTerran> [1]slava, in the case of haskell, it'd be encoded as IORefs (or equivalent)
19:42:00 <EvilTerran> so... yes :)
19:42:16 <[1]slava> so now everything has an IO type?
19:42:22 <EvilTerran> only the bits that need it
19:42:23 <[1]slava> and all your code is now monadic?
19:42:27 <EvilTerran> no!
19:42:33 <mrd> IO /= monadic
19:42:35 <vininim> there is also research in the GUI field using arrow or something, iirc
19:42:35 <[1]slava> that's the problem -- the IO monad is like a cancer
19:42:41 <mrd> its just one monad of many
19:42:44 <Cale> [1]slava: No, just the bits that deal with modifying and interacting with the GUI
19:42:45 <[1]slava> once it infects one function it infects all callers
19:42:53 <Cale> [1]slava: No, that's totally untrue.
19:42:56 <ddarius> [1]slava: That's because the effects it represents "are like a cancer"
19:42:57 <[1]slava> mrd, he mentioned IORefs in particular
19:42:59 <EvilTerran> it "infects" all callers, yes, but not all callEEs
19:43:02 <Cale> You can call pure code from IO code.
19:43:06 <[1]slava> of course you can
19:43:15 <[1]slava> but if most of your program is IO actions why use a pure language?
19:43:18 <EvilTerran> that pure code isn't "infected"
19:43:19 <zeeeee> [1]slava, in practice, yeah, a lot of the gui code i see is in io
19:43:34 <EvilTerran> if most of your program is IO actions, you're doing it wrong
19:43:43 <Cale> [1]slava: It's not. Typically you have a thin IO shell, and the main part of your program which is actually doing the real work is not in the IO monad.
19:43:44 <ddarius> [1]slava: Because people don't write "GUIs" they write programs with GUIs.
19:44:04 <EvilTerran> there should be a relatively thin layer of mucking about in IO, which only serves to invoke pure code that does most of the work
19:44:08 <[1]slava> sure, but are there even that many GUI applicationsa nd toolkits written in haskell?
19:44:26 <[1]slava> all the examples I've seen (simple OpenGL demos) most of the code was monadic
19:44:26 <Cale> [1]slava: If you're familiar with the model-view-controller pattern from OO design, the "model" is always pure, and usually parts of the view and controller can be pure as well, but they will have some IO in them.
19:44:31 <vininim> (that's what happens when you kill mbot)
19:44:31 <ddarius> [1]slava: More than factor ;)
19:44:50 <[1]slava> ddarius, because 2 > 1? :)
19:45:00 <wy> I wonder if monads are implemented efficiently in the compiler? Because it seems the layers could be deep
19:45:02 <ddarius> [1]slava: There is more than 2.
19:45:11 <[1]slava> haskell has been around for 20 years, i'd expect something like mcclim or gtk+ to exist in the haskell world
19:45:18 <[1]slava> something I can look at
19:45:21 <mrd> gtk2hs
19:45:22 <EvilTerran> there's a gtk binding...
19:45:24 <[1]slava> that's a binding
19:45:30 <[1]slava> I meant a complete toolkit on par with gtk+ or mcclim
19:45:34 <ddarius> [1]slava: Why?  There aren't many GUI toolkits period.
19:45:34 <Cale> [1]slava: There's WxHaskell, Gtk2Hs, a direct binding to X, a Win32 binding...
19:45:37 <[1]slava> or failing that, a non-trivial gui application using some toolkit
19:45:41 <mrd> there's interesting high level toolkits
19:45:49 <EvilTerran> it's significantly higher-level than the C bindings, if that's what you mean
19:45:57 <Cale> I think there's also a Tk binding, but I don't know if that's maintained.
19:46:01 <ddarius> [1]slava: There are definitely GUI applications.
19:46:08 <EvilTerran> it's very dead, iirc, Cale
19:46:09 <mrd> functional reactive stuff
19:46:12 <vininim> if mbot was up, we would all be trying 100 ways of showing [1..5] instead of arguing about pure functiona vs something
19:46:22 <Cale> vininim: mbot?
19:46:26 <[1]slava> is there a production-quality toolkit based around FRP?
19:46:34 <[1]slava> that would free you from the IO monad for sure
19:46:41 <Cale> vininim: We're in #haskell, use lambdabot?
19:46:42 <ddarius> [1]slava: No, but FRP is still research and has no commercial backing.
19:46:43 <[1]slava> gtk2hs and stuff don't seem that interesting
19:46:53 <Cale> oh, is lambdabot dead too?
19:46:56 <mrd> that's because GUI toolkits aren't interesting
19:46:58 <EvilTerran> we have research papers. the GTK folk don't have that. :)
19:47:01 <mrd> what do you expect?
19:47:13 <[1]slava> mrd: unfortunately they're essential
19:47:19 <mrd> well, they exist
19:47:24 <mrd> what are you whining about exactly?
19:47:34 <[1]slava> i'm not whining, just asking some questions
19:47:37 <EvilTerran> @bot
19:47:37 <mbot> :)
19:47:53 <wy> Is there a functional GUI toolkit around?
19:47:59 <zeeeee> i spent some time exploring gui's for haskell a while back, but my understanding always stopped at frp, which is the basis for most of these systems
19:47:59 <ddarius> > [1..5]
19:48:05 <mbot>  [1,2,3,4,5]
19:48:06 <bench> data T = T {date:: String} data S= {date::String} why does this consistute multiple declarations?
19:48:15 <vininim> yatta!
19:48:15 <zeeeee> (the others - wxhaskell, gtk2hs, etc. - are all in io)
19:48:18 <bench> date, that is
19:48:19 <ddarius> bench: Because it is.
19:48:20 <Cale> [1]slava: If you're interested in how to take GUI programming and make it more functional in nature, there are better ideas than the IO monad.
19:48:21 <mrd> bench: you typed 'data' twice
19:48:23 <wy> zeeeee: What's frp?
19:48:29 <zeeeee> wy, functional reactive programming
19:48:34 <Cale> [1]slava: Talk to Conal, he's often around here.
19:48:35 <[1]slava> Cale, sure, that's why i asked about FRP implementations
19:48:41 <bench> hmm, i thought that T is the new data i defined
19:48:44 <bench> and S
19:48:52 <bench> where date is just a field inside T or S
19:49:10 <EvilTerran> "and S"... what?
19:49:13 <Saizan_> bench: yes, but fields are global
19:49:17 <Cale> [1]slava: There's a few of those, in varying states of being maintained. Unfortunately, nothing has really stepped forward and become a standard which we can all rally around.
19:49:20 <[1]slava> Cale, it seems most existing GUI work uses the IO monad which seems awkawrd
19:49:31 <vininim> > [0..4] >>= \ x -> [x+1]
19:49:32 <mrd> bench: the reason is that date becomes a function and it can't have the type T -> String and S -> String
19:49:33 <mbot>  [1,2,3,4,5]
19:49:36 <Saizan_> bench: you don't get a separate namespace for every datatype
19:49:42 <bench> Saizan_, fields are global?
19:49:45 <Cale> [1]slava: Well, even the bindings which use the IO monad have varying levels of abstraction.
19:50:06 <EvilTerran> IO's a bit of a dumping ground for the awkward squad, tbh
19:50:07 <Cale> [1]slava: Direct bindings to C libraries tend to be awful compared to what Gtk2Hs and WxHaskell look like now.
19:50:08 <mrd> bench: now you can make a typeclass with method date and then write an instance for T and one for S
19:50:48 <EvilTerran> bench, fields are functions; they follow the same scoping rules
19:51:37 <wy> Is there a trend of the Haskell community to avoid "success" ?
19:51:39 <[1]slava> one thing I noticed while browsing the haskell library is that there are two types of mutable arrays, one used with the ST monad and the other used with the IO monad. That struck me as totally redundant
19:51:54 <mrd> success must be avoided at all costs
19:51:56 <[1]slava> and EvilTerran is right, the IO monad is a dumping ground for a whole lot more than just IO
19:51:57 <ddarius> wy: No, there is a trend to -want- to avoid success, but then failing.
19:52:22 <mrd> [1]slava: ST can be encapsulated and called from pure code
19:52:32 <[1]slava> so why is there a need for those IO arrays?
19:52:42 <mrd> easier to use, probably
19:52:51 <[1]slava> but its unnecessary duplication
19:52:51 <allbery_b> [1]slava: ...and IO "contains" ST within it
19:52:59 <allbery_b> so it's not really duplication
19:53:03 <wy> ddarius: Can we really success in avoid success? I really want this thing to keep changing ;-)
19:53:16 <mrd> you can write mutable-array generic code
19:53:20 <Saizan_> ST is not h98, right?
19:53:33 <mrd> ST uses existential types which is not h98
19:53:39 <allbery_b> (think of it as IO having an ST hidden inside, so anything available in ST is also available in IO)
19:54:38 <allbery_b> ST is also kinda painful to use, IO is in many ways easier
19:55:05 <[1]slava> and an impure language is even easier! :)
19:55:24 <bench> mrd: can you give a simple example of type class that you referred
19:55:30 <Saizan_> arrays are not cool anyway
19:55:36 <wy> zeeeee: Have you looked at functional reactive animation?
19:55:36 <EvilTerran> only in the short term. us purity purists are suckers for delayed gratification.
19:55:41 <zeeeee> wy, yes
19:56:00 <wy> How was it?
19:56:01 <mrd> class Dateable a where date :: a -> String; instance Datable T where date (T { tdate = d }) = d
19:56:08 <[1]slava> Saizan_, they're so cool that i never need single linked lists :)
19:56:14 <mrd> [1]slava: what can i say, we love pain
19:56:34 <mrd> I write code in Coq for fun
19:56:55 <mrd> haskell is freewheeling by comparison
19:56:58 <ddarius> [1]slava: That there is no reason or sense in ST existing in an impure language is not a benefit of impure languages.
19:57:00 <zeeeee> so the IO array is just there so that you can directly use it from the IO, right? as opposed to constructing and transforming-in an ST monad that uses ST arrays?
19:57:08 <wy> mrd: Is there a theorem prover in Haskell?
19:57:18 <ddarius> mrd: Yarrow is written in Haskell.
19:57:28 <ddarius> I think Agda is too.
19:57:53 <zeeeee> wy, pretty much every one of these projects i tried was dead, unusable/un-compilable, unmaintaned, research, undocumented, etc.
19:58:02 <mrd> yes
19:58:32 <bench> mrd: if i follow your example, i'd still have to have tdate, and sdate -- i.e. name the date field for T and S differently?
19:58:33 <wy> zeeeee: Is yale really inactive?
19:58:54 <mrd> bench: well yes, and then write method date which unifies them
19:59:05 <zeeeee> wy, there was some recent activity on reviving yampa, i believe - i saw a mailing list post
19:59:11 <[1]slava> if a function is redefined in ghci are all callers updated to use the new function?
19:59:21 <mrd> no
19:59:22 <ddarius> No.
19:59:27 <bench> mrd: what do you mean unify them?
19:59:29 <mrd> its not lisp
19:59:36 <ddarius> You don't redefine functions in GHCi, you shadow them.
19:59:38 <mrd> bench: bring them together under one name
19:59:57 <zeeeee> (recently being some time this past year? or last year?0
20:00:24 <wy> zeeeee: I'm been doing graphics this semester. There should be a lot of future of FP in graphics
20:00:59 <wy> mrd: Have you ever used NuPrl?
20:01:13 <mrd> no
20:01:26 <wy> It seems to me it's written in Haskell.
20:01:39 <wy> I found Yarrow too
20:01:40 <[1]slava> ddarius, well that would be a nice application of mutable state ;)
20:01:48 <mrd> i mostly use twelf atm
20:02:13 <EvilTerran> [1]slava, you can get that behaviour, but you have to make its existence explicit
20:02:20 <mrd> which is written in SML.  which is really a better language for these kind of applications, what with the formal semantics.
20:02:26 <EvilTerran> by storing the potentially-changing function in an IORef, say
20:02:42 <[1]slava> so you'd store all your functions in IORefs?
20:02:57 <EvilTerran> wtf? why do you need to redefine all your functions on the fly?
20:03:05 <Saizan_> no, i'd just edit them in the source and reload..
20:03:06 <[1]slava> during development
20:03:13 <[1]slava> so reloading source modifies functions?
20:03:15 <mrd> 'cause he's a lisper at heart =)
20:03:28 <mrd> you can use something like hs-plugins to achieve what you want
20:03:41 <EvilTerran> [1]slava, no, once you've loaded a function into the interpreter once it's set in stone 'til the heat death of the universe. what do you think?
20:03:54 <mrd> he wants to reload while running
20:03:58 <[1]slava> sounds like java :)
20:04:37 <Saizan_> we don't have class loaders.. haskell is mostly run compiled.
20:05:05 <[1]slava> java class loaders allow a limited form of reloading but its more like shadowing
20:05:24 <Cale> hs-plugins can load and unload code on the fly, but the usual caveats apply, like the need to maintain consistent state between versions.
20:05:39 <ddarius> wy: NuPRL is written in Common Lisp and an old dialect of ML.
20:06:08 <wy> zeeeee: Can you point me to the most significant paper of that group?
20:06:21 <bench> mrd: thanks
20:07:05 <Cale> Replacing code while a program is running is overrated. Most of the reason that's a convenient thing to do is because there's a lot of stateful context to manage in the first place. If you're debugging referentially transparent functions, you don't care if you have to reload the file.
20:07:23 <zeeeee> wy, which group? yale's?
20:07:40 <wy> zeeeee: Any group in frp
20:07:57 <wy> ddarius: I can't find its code
20:08:12 <ddarius> wy: It says in the manual what languages it is written in.
20:08:28 <wy> ddarius: Have you tried it?
20:08:32 <ddarius> No.
20:08:39 <Cale> It can cause lots of really strange problems -- for example, where the program is working due to its current state which is actually unreachable due to various bits of code having been replaced.
20:08:48 <loupgaroublond> cale, it's very necessary when restarting xmonad, and you have alot of windows open
20:08:53 <Cale> (So the program no longer works the next time you use it)
20:09:02 <ddarius> loupgaroublond: That's not how xmonad works though.
20:09:05 <wy> I've seen some other people using it. It's interface looks nicer than other proof assistants
20:09:15 <loupgaroublond> ddarius: nope
20:09:52 <zeeeee> wy, that's a good question, i actually have no idea what would be the 'seminal' paper on frp; i was mostly looking at frp as they applied to gui's, and i think frp originated in animation and robotics (which iirc did not turn out well, due to performance issues or real-time issues or something)
20:09:56 <ddarius> loupgaroublond: I just restarted xmonad now and nothing changed at all which supports Cale's statement.
20:10:29 <zeeeee> but as someone else pointed out earlier, conal has been active in a number of the projects in that space, and he is here sometimes
20:10:34 <loupgaroublond> ddarius: maybe i'm just looking at it from the wrong angle
20:10:35 <ddarius> zeeeee: I don't recall any unexpected problems, I think people just moved on.
20:10:42 <wy> zeeeee: Or graphics people don't understand it ;-)
20:10:42 <mrd> he has a paper on it, somewhere i think
20:11:01 <ddarius> @where tv
20:11:02 <mbot> I know nothing about tv.
20:11:09 <ddarius> Stupid mbot.
20:11:21 <wy> ddarius: I still can't get used to xmonad. To me metacity is more vanilla than xmonad ;-)
20:11:25 <ddarius> http://conal.net/
20:11:26 <mrd> http://portal.acm.org/citation.cfm?id=258973
20:11:44 <ddarius> wy: So use metacity, why are you telling me?
20:11:59 <wy> ddarius: Just some random words
20:12:23 <mrd> metacity has all the keybindings like xmonad?
20:12:38 <wy> mrd: Thanks
20:12:56 <zeeeee> ddarius, oh, my parenthesized message was regarding the control applications in robots
20:13:03 <Cale> zeeeee: It seems to work fine for those applications. In fact, there's even a nice proof-of-concept for a first person shooter game written using FRP. (I think Yampa)
20:13:03 <mrd> http://www.haskell.org/haskellwiki/Research_papers/Functional_reactive_programming
20:13:07 <Saizan_> loupgaroublond: xmonad just passes the current state on the command line of the next instance
20:13:07 <wy> mrd: probably not. I've removed the keybindings because lots of them conflict with emacs
20:13:12 <zeeeee> Cale, see my last message :)
20:13:18 <mrd> wy: no they don't
20:13:22 <ddarius> zeeeee: I know, that's what I was responding to.
20:13:28 <mrd> wy: just pick your modifier to be the windows key =)
20:13:51 <Cale> zeeeee: Well, if you can control a few dozen robots in a virtual game world, surely you could do the same with real robots :)
20:14:58 <mrd> nobody can control robots. they will go on a murderous rampage.
20:15:08 <Cale> haha
20:15:13 <zeeeee> it's at times like these when i kinda wish i had a reference handy :)
20:15:30 <Cale> I think that FRP for robotics has always been kind of quiet.
20:15:35 <mrd> http://cs-www.cs.yale.edu/homes/nilsson/Publications/afp2002.pdf
20:15:42 <mrd> arrows, robots and frp
20:15:42 <ddarius> zeeeee: There were definitely expected issues with e.g. real-time processing, but I don't remember them killing any project.
20:15:49 <Cale> So I don't know, maybe there are still people working on it, maybe not?
20:16:38 <Cale> Haskell code generation is getting better these days too, so if anything the potential performance issues are decreasing.
20:16:54 <ddarius> Cale: That's not particularly relevant to real-time.
20:17:19 <SamB_XP> quite so ;-)
20:17:26 <Cale> Well, no, but I'm not sure that I believe you need perfect real-time for everything.
20:17:37 <SamB_XP> of COURSE not
20:17:46 <SamB_XP> that would be flippin' insane
20:19:15 <EvilTerran> just like needing mutable state for everything, then :P
20:19:15 * mrd needs real-time with relativistic precision.  guaranteed simultaneity GC
20:19:39 <SamB_XP> what the heck?
20:19:48 <SamB_XP> simultaneity ?
20:19:56 <SamB_XP> can you get that under relativity?
20:20:13 <EvilTerran> i don't think the concept makes sense under relativity
20:20:30 <ddarius> EvilTerran: It's dependent on the perspective.
20:20:44 <EvilTerran> events that happen simultaneously according to one observer will happen at different times according to another
20:20:44 <mrd> what you think is simultaneous is not really
20:20:58 <mrd> except no one knows really
20:21:27 <ddarius> It's not that no one knows.
20:21:29 <EvilTerran> there's nothing to know; the concept isn't meaningful
20:21:45 <SamB_XP> well, too things can happen simultaneously if they are not instantaneous
20:21:55 <mrd> i didn't say it to make sense
20:22:18 <SamB_XP> in particular, they have to happen at the same time for all possible observers...
20:22:31 <EvilTerran> SamB_XP, i said events, not processes. not sure if it works for processes, i'm too tired and lacking-in-knowledge to work that one out...
20:22:51 <SamB_XP> many events last one or more days ;-P
20:22:59 <EvilTerran> i see your pedantry, and raise you the same again!
20:23:45 <ddarius> SamB_XP: How long they last is dependent on perspective.
20:24:20 * EvilTerran should learn a bit more about relativity at some point. i tend to rely on my twisted intuition about it more than is probably wise.
20:24:21 * SamB_XP doesn't think it matters how fast the observer is traveling...
20:24:28 <zeeeee> ddarius, in practice, issues of efficiency and performance are frequently relevant to real-time systems; media codecs, network filters, stream processors are examples of systems with tightly coupled real-time guarantees and performance
20:24:42 <OceanSpray> what's a function to strip a float of its decimal part
20:24:47 <EvilTerran> (nb, this intuition is completely independent of my intuitions about everything else)
20:24:49 <OceanSpray> not round, just cut off
20:24:53 <ddarius> zeeeee: I didn't say -irrelevant-.
20:24:57 <mrd> @hoogle truncate
20:25:00 <mbot> http://en.wikipedia.org/wiki/Truncate_(SQL)
20:25:00 <ddarius> @src Floating
20:25:00 <EvilTerran> ?hoogle Float -> Int
20:25:00 <mbot> Title: Truncate (SQL) - Wikipedia, the free encyclopedia
20:25:03 <mbot> Plugin `search' failed with: Lib.URL.isTextHTML: getHeader failed
20:25:03 <mbot> class  (Fractional a) => Floating a  where
20:25:03 <mbot>     pi                                                      :: a
20:25:03 <mbot>     exp, log, sqrt, sin, cos, tan                           :: a -> a
20:25:04 <mbot>     asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh :: a -> a
20:25:06 <mbot>     (**), logBase                                           :: a -> a -> a
20:25:09 <ddarius> @src RealFrac
20:25:09 <EvilTerran> hm
20:25:10 <mrd> irk
20:25:10 <mbot> class  (Real a, Fractional a) => RealFrac a  where
20:25:10 <mbot>     properFraction                   :: (Integral b) => a -> (b,a)
20:25:12 <mbot>     truncate, round, ceiling, floor  :: (Integral b) => a -> b
20:25:12 <mrd> there
20:25:15 <mrd> properFraction
20:25:24 <mrd> or truncate
20:25:25 <OceanSpray> wha?
20:25:30 <OceanSpray> > truncate 3.4
20:25:33 <EvilTerran> OceanSpray, probably truncate or floor, depending on what you want to happen to negative numbers
20:25:33 <mbot>  3
20:25:34 <OceanSpray> argh
20:25:37 <OceanSpray> oh
20:25:39 <OceanSpray> there we go.
20:25:42 <EvilTerran> @check \x -> floor x <= x
20:25:43 <mbot>  quickcheck: /usr/lib/ghc-6.4.2/package.conf: openFile: does not exist (No su...
20:25:50 <EvilTerran> forall x. floor x <= x
20:26:02 <EvilTerran> forall x. abs (truncate x) <= abs x
20:26:02 <OceanSpray> which one's more efficient? I mean, negatives won't come into play here.
20:26:09 <mrd> EvilTerran: um, no?
20:26:11 <mrd> er
20:26:13 <mrd> truncate
20:26:22 <OceanSpray> > log 23425
20:26:25 <mbot>  10.061559107106623
20:26:36 <EvilTerran> floor is less characters, and your time is more important than the processor's ;)
20:26:45 <EvilTerran> mrd, what?
20:26:48 <mrd> yea and more characters == more cycles for the processor
20:26:54 <mrd> when the compiler parses it
20:27:00 <OceanSpray> (1 +) . truncate . log 234
20:27:15 <OceanSpray> > ((1 +) . truncate . log) 234
20:27:18 <mbot>  6
20:27:27 <OceanSpray> that wasn't what I expected.
20:27:41 <Plareplane> @type log
20:27:42 <mrd> that's why i use single letter variable names
20:27:44 <mbot> forall a. (Floating a) => a -> a
20:27:45 <mrd> faster parsing!
20:27:51 <Plareplane> what base is that log?
20:27:59 <EvilTerran> e, probably
20:28:00 <mrd> > log 2
20:28:03 <mbot>  0.6931471805599453
20:28:05 <mrd> > log 10
20:28:08 <mbot>  2.302585092994046
20:28:08 <EvilTerran> > log (exp 1)
20:28:09 <OceanSpray> > 1 + (truncate (log 2345))
20:28:12 <mbot>  8
20:28:13 <mbot>  1.0
20:28:16 <OceanSpray> wha
20:28:18 <EvilTerran> e :)
20:28:28 <OceanSpray> oh, that's why
20:28:33 <ddarius> "What base is that log?"  Silly question.
20:28:52 <mrd> > logBase 2 2
20:28:52 <OceanSpray> "Is that a log in your pants or are you just happy to see me?"
20:28:55 <mbot>  1.0
20:28:56 <EvilTerran> > log10 10000
20:28:57 <mbot>   Not in scope: `log10'
20:28:57 <Plareplane> > truncate ((log 234) / (log 10))
20:29:00 <mbot>  2
20:29:03 <EvilTerran> er, ok
20:29:14 <EvilTerran> @hoogle log
20:29:17 <mbot> http://en.wikipedia.org/wiki/Log
20:29:17 <mbot> Title: Log - Wikipedia, the free encyclopedia
20:29:27 * EvilTerran pokes the bot
20:29:30 <ddarius> mbot foils again
20:29:36 <mrd> mbot thinks wikipedia is hoogle
20:29:46 <EvilTerran> it probably thinks @google is @hoogle
20:29:52 <ddarius> There is no probably
20:29:56 <OceanSpray> > 1 + (truncate (logBase 10 2345))
20:29:59 <mbot>  4
20:30:01 <EvilTerran> @foogle google hoogle
20:30:01 <OceanSpray> there we go
20:30:03 <mbot> http://blogoscoped.com/archive/2003_10_20_index.html
20:30:03 <mbot> Title: Google, Foogle, Toogle... | Funny Hats, Mystical Google
20:30:05 <mrd> google, what's that?
20:30:13 <OceanSpray> I just wanted to see how many digits the number has
20:30:21 <OceanSpray> unless, of course, there's already a library function for that.
20:30:33 <ddarius> Why would there be a library function for that.
20:30:34 <ddarius> ?
20:30:38 <OceanSpray> I don't know
20:30:59 <OceanSpray> with a library as big as Haskell's, it's not impossible.
20:31:20 <ddarius> length . show
20:31:23 <EvilTerran> i'd be inclined to divide by ten repeatedly
20:31:30 <OceanSpray> > length 1234
20:31:31 <mbot>   add an instance declaration for (Num [a])
20:31:41 <mrd> EvilTerran: log10 times? =)
20:31:55 <OceanSpray> why divide repeatedly when there's a simple mathematical way to find it?
20:32:09 <EvilTerran> hey, it's a O(log n) solution, and O(log n) is constant, in practical terms :P
20:32:24 <EvilTerran> OceanSpray, because the log function uses floating point, so is inevitably imprecise
20:32:49 <OceanSpray> oh
20:32:52 <OceanSpray> hmm
20:33:18 <EvilTerran> > (floor . logBase 10) (10^6) -- oops
20:33:18 <OceanSpray> > ((1 +) . truncate . logBase 2) 100000000000000000000000001
20:33:20 <ddarius> > (length . show ) $2^100
20:33:21 <mbot>  87
20:33:24 <mbot>  31
20:33:25 <mbot>  5
20:33:31 <OceanSpray> oh wait
20:33:35 <EvilTerran> > length . show $ 10^5
20:33:37 <mbot>  6
20:33:50 * EvilTerran blinks
20:33:57 <OceanSpray> > ((1 +) . truncate . logBase 10) 9999999999999999999999999999999999999999999999999999
20:33:59 <mbot>  52
20:34:01 <ddarius> > 10 ^ 5
20:34:04 <mbot>  100000
20:34:09 <ddarius> That's six digits.
20:34:23 <EvilTerran> > logBase 10 $ 10^6
20:34:25 <mbot>  5.999999999999999
20:34:56 * EvilTerran looks at ddarius, logarithms, the moon, etc
20:35:08 <EvilTerran> never mind, i'm just confused :P
20:35:19 <mrd> > "5."++concat (repeat"9")
20:35:21 <mbot>  "5.9999999999999999999999999999999999999999999999999999999999999999999999999...
20:35:44 <ddarius> > '5':'.':repeat '9'
20:35:44 <EvilTerran> does that (=="6")? :P
20:35:47 <mbot>  "5.9999999999999999999999999999999999999999999999999999999999999999999999999...
20:35:50 <ddarius> EvilTerran: Yes.
20:35:59 <ddarius> Er.
20:36:05 <ddarius> Maybe in PHP
20:36:06 <OceanSpray> you think that there's a chance that ((1 +) . truncate . logBase 10) would give the wrong number of digits for a number?
20:36:08 <mrd> hehe
20:36:08 <EvilTerran> also no, as the computation is _|_ :P
20:36:23 <EvilTerran> OceanSpray, i just gave an example a few minutes ago
20:36:28 <mrd> PHP compares strings as numbers and decides the undecidable
20:36:30 <OceanSpray> where?
20:36:34 <mrd> no wonder webmonkeys love it
20:36:37 <EvilTerran> > map ((1 +) . truncate . logBase 10 . (10^)) [0..]
20:36:39 <mbot>  [1,2,3,3,5,6,6,8,9,9,11,12,12,13,15,15,17,18,18,20,21,21,23,23,24,26,26,27,2...
20:36:50 <EvilTerran> see those duplicates? those are mistakes
20:37:00 <EvilTerran> 0433<EvilTerran> > (floor . logBase 10) (10^6) -- oops
20:37:08 <EvilTerran> 0433<mbot>  5
20:37:17 <OceanSpray> yeah, you have to add 1 to it
20:37:25 <EvilTerran> it's still wrong
20:37:27 <OceanSpray> oh
20:37:28 <ddarius> OceanSpray: The answer is 7
20:37:32 <OceanSpray> dang
20:37:33 <EvilTerran> > length . show $ 10^6
20:37:36 <mbot>  7
20:37:53 <EvilTerran> and *that*'s why i don't want to use the "simple mathematical way"
20:38:05 <OceanSpray> it's SUPPOSED to work, damn it.
20:38:12 <EvilTerran> not in floating point it aint
20:38:15 <Plareplane> floating point never works!
20:38:44 * mrd prefers beer pint math
20:39:22 <conal> zeeeee, wy: looking for info on frp or tv?
20:39:33 <mrd> error increases exponentially =)
20:39:37 <wolverian> would it work with :: Integer?
20:39:47 <EvilTerran> (\x -> length . takeWhile (<x) . iterate (10*) 1) is probably fast enough for most purposes
20:39:53 <EvilTerran> wolverian, no
20:39:55 <wy> conal: Yes
20:39:56 <EvilTerran> ?type logBase
20:39:58 <mbot> forall a. (Floating a) => a -> a -> a
20:40:06 <wolverian> oh, righto
20:40:10 <wolverian> that's awkward
20:40:18 <ddarius> EvilTerran: You could make an instance of Floating for Integer...
20:40:19 <conal> wy: i'm happy to answer any questions.
20:40:27 <EvilTerran> if that version's not fast enough, you could make one O(log(log n)), i think
20:40:38 <EvilTerran> (in case of very large Integers)
20:41:07 <wolverian> it dwims in perl with 'use bignum;', surely haskell can't lose to perl!
20:41:15 <wolverian> (admittedly is slow as fuck)
20:41:17 <EvilTerran> that's not really a loss :P
20:41:24 <wolverian> s/is/it's/
20:41:37 <wy> conal: I don't have many questions because I was introduce to it just a few minutes ago. I want to implement some graphics stuff in a functional language. That's why I'm interested in that. Maybe you could point me to the absolute first thing to read
20:41:43 <wolverian> EvilTerran, ;)
20:41:50 <ddarius> wolverian: What does it do if you don't have 'use bignum;'?
20:41:56 <wolverian> ddarius, same as haskell
20:42:03 <conal> wy: as for "seminal paper" see http://sigplan.org/award-icfp.htm
20:42:05 <wolverian> (i.e. uses floating point)
20:42:23 <wy> conal: Are you Conal Elliott ?
20:42:31 <conal> wy: most accessible intro: http://conal.net/Fran/tutorial.htm
20:42:33 <conal> wy: yep.
20:42:34 <wolverian> (for those interested, bignum overloads all the mathematical operators)
20:42:53 <ddarius> wolverian: So perl loses.  Your code changes meaning just by adding an import.
20:43:13 <wy> conal: Cool! This is really a marvelous channel
20:43:27 <wolverian> ddarius, I don't see the logic there.
20:43:32 <allbery_b> that can happen in Haskell too
20:43:42 <EvilTerran> well, two imports
20:43:44 <conal> wy: i'm still playing with this stuff, so i'd enjoy chatting about what you're up to.  graphics + functional programming is one of my favorite things.  :)
20:44:01 <EvilTerran> import Prelude hiding (<something>); import Foo (<same thing>)
20:44:16 <ddarius> EvilTerran: It's okay if you -explicitly- hide something.
20:44:34 <wolverian> I think it's also okay to -explicitly- enable something.
20:44:46 <allbery_b> that said, there's a convention that lowercase "use" modules are pragmas, which are expected to change the meaning of code
20:45:05 <allbery_b> (but I thought it was BigNum, so not a pragma module)
20:45:23 <conal> wy: see also TV & Eros (on the haskell wiki) for some other current work you might enjoy.
20:45:24 <wolverian> allbery_b, bignum is a pragmata that uses Math::BigInt, ::BigFloat, ::BigRat
20:45:25 <conal> @wiki TV
20:45:25 <mbot> http://www.haskell.org/haskellwiki/TV
20:45:28 <conal> @wiki Eros
20:45:28 <mbot> http://www.haskell.org/haskellwiki/Eros
20:45:28 <ddarius> wolverian: There is a difference between adding and changing.
20:45:30 <wy> conal: I'm fairly new to graphics. This semester we wrote some Monte Carlo renderer in Java. I want to implement some full featured on in FP
20:45:37 <wolverian> ddarius, well, that's true.
20:45:47 <wy> conal: Thanks for the pointers.
20:46:06 <allbery_b> wolverian: ah, ok
20:46:14 <conal> wy: sure.  do you want to do *interactive* graphics?
20:46:16 <wolverian> ddarius, I still don't agree with your point, but I do see your logic, if your premise is that changing the meaning is inherently wrong.
20:46:35 <allbery_b> so for Perl it's sane, since the lowercase name is a warning that it's changing the meaning of something
20:46:41 <ddarius> wy: I think you've already been pointed at http://www.haskell.org/haskellwiki/Applications_and_libraries/Graphics#Ray_tracing
20:46:46 <conal> wy: also see Vertigo
20:46:49 <conal> @where Vertigo
20:46:49 <mbot> I know nothing about vertigo.
20:46:53 <conal> :(
20:46:53 <wolverian> right. I'm definitely not saying haskell should do something like that. that would be insane. :)
20:47:04 <conal> @where+ Vertigo http://conal.net/Vertigo
20:47:04 <mbot> Good to know.
20:47:08 <conal> :)
20:47:16 <conal> where's lambdabot?
20:47:18 <wolverian> perl has the slight disadvantage of not having type inference, too.. :/
20:47:25 <ddarius> wolverian, allbery_b: I don't really have a problem with Perl's behavior (as long as it stays in Perl...)
20:47:29 <wy> ddarius: Thanks! I haven't got that yet
20:47:32 <allbery_b> perl has types?  }:>
20:47:33 <wolverian> ddarius, then we're in violent agreement :)
20:47:43 <wolverian> allbery_b, yes. about eight of them.
20:47:51 <wy> conal: Sure. I'm interested in that too.
20:48:04 <ddarius> wolverian: I wasn't being serious when I said "perl loses"
20:48:14 <wolverian> scalar, array, hash, handle, typeglob, uh oh.. I wonder what I'm forgetting, or if my number was too high
20:48:14 * allbery_b has been doing perl for ~10 years now, and is kidding
20:48:21 <wolverian> ddarius, righto. :)
20:48:29 <wolverian> allbery_b, then please correct me :)
20:48:39 <allbery_b> but reallythere's no distinction within e.g. scalars
20:48:42 <conal> wy: i'd love to resurrect Vertigo, for modern GPUs and cross-platform.
20:48:53 <conal> wy: another fun graphics project:
20:49:04 <conal> @where+ Pajama http://conal.net/Pajama
20:49:04 <mbot> Nice!
20:49:26 <andyjgill>  Hi room.
20:49:27 <conal> @where+ Pan http://conal.net/Pan
20:49:28 <mbot> Done.
20:49:36 <conal> hi andyjgill!
20:49:37 <wolverian> allbery_b, yes. but saying perl doesn't have types is not true. :)
20:49:45 <wy> conal: That's something I was looking for
20:50:19 <wolverian> (it just has two kinds of types, static _and_ dynamic. or, container and value.)
20:50:37 <allbery_b> scalar, list (which is distinct from array although the difference is subtle), array, hash, glob, and then the references can be considered distinct types (or as subtypes of glob; handles are also globs, btw)
20:50:40 <conal> wy: i'm working now on a new version of Pan/Pajama that uses an nifty data representation for infinite & continuous images (and other functions).  currently digressing back into rethinking frp.
20:51:27 <wolverian> I think typeglobs are used to save filehandles (give name to them, that is)
20:51:33 <wolverian> but filehandles themselves have a separate internals type
20:51:37 <allbery_b> a handle is a *foo{IO}
20:51:46 <wolverian> well, yeah.
20:51:49 <wolverian> okay. :)
20:52:08 <conal> wy: and i want to bring all of the functional graphics stuff into Eros so that non-programmers can create composable interactive graphics tools.
20:52:13 <andyjgill> hi conal
20:52:21 <wy> conal: Cool! I should got to know this earlier
20:52:35 <andyjgill> Is there a rule that as soon as you sit down, your kids will act up again?
20:52:49 <monochrom> Yes.
20:52:54 <wolverian> allbery_b, it has to be the weirdest type system I've seen, really.
20:53:04 <ddarius> monochrom: Nah, if there was such a rule, children wouldn't follow it.
20:53:16 <monochrom> There is also a rule that as soon as you don't sit down, your kids will act up again.
20:53:17 <conal> andyjgill: any progress with WxHaskell?
20:53:23 <wolverian> ddarius, brillant! let's make that rule!
20:53:33 <monochrom> Both are derived from the axiom: your kids will act up again.
20:53:50 <andyjgill> Nope. Apart from loading various packages.
20:53:53 <monochrom> p = (q implies p) and (not q implies p). :)
20:54:01 <zeeeee> conal, do you have any examples of 'highly'-data-bound gui's using one of these systems, e.g. a table editor (spreadsheet without the constraints)? a lot of the examples i see in the literature relate to graphics, animation, etc. (vs. data manipulation)
20:54:15 <monochrom> (This requires the law of excluded middle. :) )
20:54:38 <wolverian> monochrom, the middle kid? :)
20:54:43 <andyjgill> As I started hacking, I became aware that we want OpenGL; is this a part of wxhaskell?
20:54:48 <conal> zeeeee: sorry, no 'highly'-data-bound examples.
20:55:04 <wy> conal: Does "tv" mean Tangible Value?
20:55:05 <allbery_b> wxhaskell at least used to have an opengl binding
20:55:10 <conal> wy: yes.
20:55:22 <conal> andyjgill: wxhaskell has a GLCanvas.  there are two examples programs in "contrib"
20:55:30 <conal> andyjgill: that's what i'm using.
20:55:34 <zeeeee> most of the time, when i want to build a gui, it's for data manipulation of some sort - manipulating a database, a table, etc. - this was the context in which i had set out exploring these frp-ish gui systems
20:55:46 <allbery_b> I haven't done much with wxhaskell, I managed to get it to build on OSX but programs crashed on startup
20:55:56 <conal> allbery_b: :(
20:55:57 <wolverian> I looked at grapefruit and ran away screaming
20:55:59 <andyjgill> Ahh. cool. I started looking at the various widgets, and realized that there is a lot there
20:56:00 <allbery_b> (and took out x11.app with them or something like that)
20:56:03 <monochrom> I guess p implies ((q implies p) and (not q implies p)) doesn't require the law of excluded middle. The converse does.
20:56:12 <conal> wolverian: because of the arrows?
20:56:15 <andyjgill> I'm on OSX.
20:56:24 <andyjgill> Perhaps I could connection direct to OpenGL?
20:56:35 <wolverian> conal, didn't get that deep. I just saw the operators and decided it's just too ugly to live. of course, reading the documentation would have helped.
20:56:36 <allbery_b> HOpenGL works
20:56:48 <conal> wolverian: lol
20:57:15 <conal> andyjgill: it's possible.  did you try the recent osx version of wxhaskell?
20:57:25 <allbery_b> someone recently mentioned getting gtk2hs to build with the native gtk binding, but (a) IIRC that lacks a bunch of stuff as yet (b) gtk2hs doesn't have opengl bindings, I think
20:57:47 <andyjgill> I started loading some port bindings, of things that it needed, in background.
20:57:54 <conal> zeeeee: i don't know of any reason frp wouldn't work well in those scenarios.
20:58:00 <wolverian> http://softbase.org/grapefruit/darcs/main/grapefruit-examples/src/Simple.hs the fact that this is "simple" was particularly enjoyable
20:58:14 <wy> conal: I'm interested in Eros and tv
20:58:22 <wolverian> actually, I think it's mostly because of the ()s that look really out of place to me
20:58:27 <conal> wolverian: yoiks!
20:58:50 <conal> wy: great! :)  i'm very excited about both.
20:58:58 <wolverian> <- and -< are also too similar
20:59:09 <conal> wy: have you seen my recent google techtalk?
20:59:22 <wy> conal: I've been always thinking about improve the interface of programming and document writing
20:59:27 <wolverian> of course I can always use ← and whatever the other character is..
20:59:28 <conal> wy: see http://conal-elliott.blogspot.com/2007/11/tangible-functional-programming-modern.html
20:59:45 <zeeeee> conal, that's good to hear - i'd be interested in getting experience building something like this in an frp system to contrast it with my experiences using laszlo and javafx, but i'm (once again, a year later) not sure which system to look at
21:00:29 <wy> I'm viewing it. but I need to get my sound card configured... Just installed a new version of Ubuntu because my old one was pretty broken from my tweaks ;-)
21:00:40 <ac> what's wrong with lambdabot?
21:00:44 <conal> zeeeee: i'm not sure what to recommend.  afaik, there's still some active work on Yampa.  there's a mailing list you could get on to ask some questions.
21:01:05 <zeeeee> conal, yeah, i'm already on that list
21:01:06 <ac> > 1 + 1
21:01:07 <conal> wy: from what you've said about your interests, i think you'll enjoy the tech talk.
21:01:08 <mbot>  2
21:01:21 <zeeeee> conal, watching the namespace debate :)
21:01:38 <ac> is lambdabot now mbot?
21:01:41 <conal> zeeeee: oh yeah -- that.
21:01:58 <conal> zeeeee: i got on something of a crusade there.
21:02:46 <ac> @seen glguy
21:02:46 <mbot> Unknown command, try @list
21:02:47 <allbery_b> lambdabot occasionally locks up for some reason, mbot is standing in until it gets restarted
21:02:52 <glguy> ?
21:03:05 <ac> glguy: dons told me you might have some ideas about templates
21:03:38 <thoughtpolice> is cabal-install relatively stable? (as in i can use it with ghc 6.8.2 and cabal 1.2.3, etc.)
21:04:13 <wy> conal: My idea was that programs can be represented in a much nicer way, and even gurus would like it. Thanks for the pointer.
21:04:41 <conal> wy: anyway, i'm often hanging out in this channel, so please ping me with questions & comments.  as well as more info about what you'd like to do.  maybe we'll find a fun collaboration.
21:05:47 <ac> glguy: I've been experimenting with using Haskell for simple CGI programs. Have any suggestions?
21:05:58 <wy> conal: It's nice to see you here. Surely I'll look more into those stuff. I hope to help you with it.
21:06:00 <conal> wy: one of the key novelties of Eros & TV is that they're based on semantic rather syntactic composition.  i'm not sure that comes through very clearly in the Eros paper.  i make a point of it in the techtalk (video).
21:06:25 <glguy> ac, I think that using a template language to generate the HTML is a good idea
21:06:27 <conal> wy: that'd be great.  i could use the help, and collaboration motivates me.
21:06:37 <glguy> I've been doing some stuff with that at work
21:06:50 <ac> glguy: what kind of template language? Do you have one that compiles to Haskell?
21:07:12 <ac> glguy: typically I use perl for this kind of stuff, but I thought it would be interesting to try Haskell
21:07:35 <glguy> ac, no, its a run-time thing
21:07:53 <wy> conal: It motivates me too :-)
21:08:57 <wy> conal: I'm also interested in making something for interactive academic document writing and drawing, especially for mathematicians.
21:09:16 <conal> wy: neat.
21:09:35 <ac> glguy: I did a very little bit of thinking about a template language that would compile to Haskell, but I couldn't figure out a nice way to deal with including output from functions with IO types
21:10:54 <wy> conal: It has been a tradition that the mathematicians don't like to draw pictures for their books. If a tool can satisfy their needs, it would be great help for the readers.
21:11:16 <ddarius> It's called a scanner.
21:11:25 <conal> ddarius: :p
21:11:49 <wy> ddarius: How many of them are actually using scanners ;-)
21:11:58 <ddarius> Mathematicians definitely like to draw diagrams and I have read papers where there were scanned in drawings.
21:12:04 <andyjgill> Does anyone know if there is a more recent version of wxhaskell than http://darcs.haskell.org/wxhaskell?
21:12:37 <conal> andyjgill: i don't know.  you could ask on the wxhaskell-users list.  btw -- get on that list!
21:12:45 <andyjgill> :-)
21:12:58 <conal> wy: is there anything about your math drawing tool idea that reduces the scope from a general drawing tool?
21:15:45 <OceanSpray> :t convert
21:15:47 <mbot> Not in scope: `convert'
21:16:13 <ddarius> convert :: Heathen -> Mormon ?
21:16:32 <vininim> > sequence ((fmap join (filterM (const [True,False]) (((\ n -> (*) <$> [1..n])) 10))) <$> [1..2])
21:16:33 <mbot>  Couldn't match expected type `a -> Bool'
21:16:35 <wy> conal: It could be general. It will at least support constraints and formulas. It could be integrated into a typesetting system, or the reverse
21:17:45 <vininim> err.. how do I "fmap join" from [[a -> b]] to [a->b] ?
21:18:04 <conal> vininim: just join
21:18:08 <conal> @ty join
21:18:10 <mbot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
21:18:12 <conal> @ty concat
21:18:14 <mbot> forall a. [[a]] -> [a]
21:18:25 <ac> glguy: have you ever thought about doing something like that?
21:18:33 <glguy> compiling to Haskell?
21:18:35 <ac> glguy: yeah
21:18:48 <glguy> Not really, I wouldn't want to incur the overhead
21:18:52 <vininim> I don't want to follow the join direction
21:19:06 <ac> glguy: there'd be slightly less overhead, right?
21:19:22 <glguy> less than what?
21:19:52 <ac> glguy: than processing the template for each request. Unless you're talking about overhead in the development cycle
21:20:28 <glguy> hmm, yeah, if you reparsed the template every time you might pay for it
21:20:46 <conal> wy: sounds pretty ambitious as an engineering project.  is there a nice kernel idea that would make it interesting as research?
21:20:48 <glguy> but I wouldn't want to have to recompile to change templates
21:20:57 <vininim> it's more like  [[(+1),(+2)],[(+1),(+3)]] -> [(+1)$(+2),(+1)$(+3)] not [(+1),(+2),(+1),(+3)]
21:20:58 <glguy> then I might as well use the xhtml library
21:21:03 <sclv> I'm working on a translation of the StringTemplate library now -- have the basics down.
21:21:29 <ac> sclv: translation from what?
21:21:33 <sclv> The concept is that the parsing is done once and "compiled" into a partial function over a map of values passed in.
21:21:48 <ac> sclv: sounds what I wanted
21:21:52 <sclv> ac: it exists for C#, Java, and Perl.
21:22:09 <ac> sclv: how do you solve the IO problem?
21:23:12 <sclv> right now I'm just getting the grammar right -- haven't started building the structures to carry the templates around -- figure I'll end up with a few solutions, one that passes a "group" (StringTemplate term) explicitly, and another built using the unsafePerformIO hack to a top level ref, maybe with some caching parameters.
21:23:29 <sclv> ac: which IO problem?
21:23:51 <wy> conal: I guess most of the ideas are there. Maybe there could be something arise from the engineering. Constraint programming seems to be quite developed, but it's not used in such programs. Maybe some high end CAD systems have it, but I have no access to them yet.
21:23:57 <glguy> > let maxsubstream = drop 2 . scanl max 0 . scanl (\s x -> max 0 (s+x)) 0 in maxsubstream [-1,2,3,-2,3,-9,5,-4,7,2,4]
21:23:59 <mbot>  [0,2,5,5,6,6,6,6,8,10,14]
21:24:41 <sclv> what did you mean earlier by "including output from functions with IO types" earlier?
21:25:01 <ac> sclv: well, the template system I was imagining would be sort of like PHP...
21:25:12 <sclv> oh no!
21:25:18 <ac> sclv: that's probably what my problem was
21:25:38 <wy> conal: I really need to get my sound card configured. Your talk is like slides now ;-)
21:25:43 <sclv> (there is, by the way, an unmaintained but nifty hsp implementation floating around that intersperses haskell with xml)
21:25:53 <conal> wy: yes -- much better with sound.
21:26:02 <ddarius> @google Haskell Server Pages
21:26:04 <mbot> http://www.cs.chalmers.se/~d00nibro/hsp/
21:26:04 <mbot> Title: HSP - Haskell Server Pages
21:26:14 <ac> sclv: but then you're limited to outputting XML
21:26:22 <sclv> ac: StringTemplate is nice because its pure functional (and the author of it is the author of ANTLR, which is an LL parser which he uses, so the grammar is already left-factored for use with parsec, which is nice!)
21:26:23 <conal> wy: about constraints -- fun stuff.  You might enjoy reading about TBAG, a predecessor to Fran.  I used a constraint solver to synthesize continuous behaviors (functions of time).  There are a couple of papers at http://conal.net/papers .
21:27:17 <sclv> ac: a template system like php winds up with the same problem as php, which is to say its automatically becomes an accidentally-designed imperative language
21:27:31 <OceanSpray> how do I get a number 123 from a string "123"?
21:27:32 <sclv> s/its/it/
21:27:43 <conal> wy: better pointer: http://conal.net/tbag/
21:27:46 <mrd> > read "123" :: Integer
21:27:48 <mbot>  123
21:27:53 <ac> sclv: yeah. but I've found it very useful to have ifs, and possibly loops in a template. And if you're going to have those, why not also include the rest of the language?
21:28:00 <OceanSpray> ok thanks
21:28:24 <ddarius> conal: Tangentially, you may find Peter Van Roy's SelfMan project interesting http://www.ist-selfman.org/wiki/index.php/SELFMAN_Project Not so much the what as the how.
21:28:30 <conal> wy: frp was essentially tbag - constraints + functional reactivity.
21:28:40 <conal> ddarius: thanks.  i'll check it out.
21:29:29 <sclv> ac: if you include the rest of the language, why not just write in haskell to begin with?
21:29:44 <ddarius> conal: "Self Management and the Future of Software Design" is probably the best place to get an overview.
21:29:49 <wy> conal: So that's certainly something I will be interested in
21:29:53 <ac> sclv: because writing strings in Haskell source is ugly
21:30:22 <sclv> it would actually be pretty trivial to write a heredoc-syntax preparser for haskell though, which might be all you need?
21:30:35 <ac> sclv: yes, it may very well be all that I need
21:30:55 <sclv> probably a one-liner in sufficiently competent sed :-)
21:32:12 <a2dk> Hi. Why can't I change  mytree n = unfoldTree mkTree n    to mytree = unfoldTree . mkTree ? (unfoldTree from Data.Tree)
21:32:32 <ddarius> a2dk: Because they mean different things.
21:32:33 <ac> sclv: I could just make a new extension name and write it in to the build system
21:33:00 <a2dk> so can I eta reduce mytree n = unfoldTree mkTree n   ?
21:33:11 <ddarius> Yes, to unfoldTree mkTree
21:33:22 <a2dk> oh :/
21:33:25 <conal> wy: in another form, fran was also a microsoft product for a while ("DirectAnimation").  very alien, ahead of its time, and unsuccessful for a few reasons.
21:34:12 <ac> d
21:34:12 <ac>  
21:34:12 <ac>  
21:34:33 <ac> sorry
21:34:55 <conal> ddarius: that paper looks very interesting to me.  thanks!  feedback loops and emergent/organic/chaotic behavior have been tugging at my attention for the last 14 months.
21:34:55 <vininim> > iterate (^2) 2
21:34:58 <mbot>  [2,4,16,256,65536,4294967296,18446744073709551616,34028236692093846346337460...
21:35:14 <ddarius> conal: Indeed, I'm always a fan of feedback loops.
21:35:24 <ddarius> Too much signal processing.
21:36:00 <conal> ddarius: came up for me when i did a weekend workshop on sociocracy.
21:37:26 <dons> interesting, Maybe in javascript, but from a very unhaskelly perspective, http://programming.reddit.com/info/636p4/comments/
21:37:46 <sclv> ac: hmm... actually I wonder if you could just use cpp or cpphs' token stringisation to get what you want even more easily.
21:38:11 <ddarius> "In his spare time he teaches category theory to fourth graders."
21:38:37 <ac> sclv: what's cpphs?
21:38:45 <bos> ddarius: don't we all?
21:38:58 <sclv> http://www.cs.york.ac.uk/fp/cpphs/
21:41:18 <wy> conal: Neat ideas are doomed to succeed sooner or later
21:41:43 <conal> wy: :)
21:43:23 <vininim> > (foldr ($) id [+1,+2,+3]) 1
21:43:23 <mbot>  Parse error at "+1,+2..." (column 16)
21:43:30 <wy> conal: Are you working for Microsoft?
21:44:01 <conal> wy: i left MS Research 5+ years ago.
21:44:32 <vininim> why folding functions with ($) doesn't work?
21:44:47 <zeeeee> conal, oh, what the heck - you're kidding! i used to write a bunch of stuff in ie's directanimation, back when i was starting high school. memories...
21:45:06 <conal> zeeeee: really!  cool. :)
21:45:22 <allbery_b> vininim: sections require parentheses
21:45:23 <ac> sclv: I'm thinking of a simple program that would translate a file to an hs module that exported a single function of type String -> String -> String ... -> Bool ... -> String
21:45:26 <wy> conal: It's interesting that microsoft's recent focus seem to be shifting to FP. Where are you working now?
21:45:30 <a2dk> Trying to learn Data.Tree - why can't I use the traverse function?  ERROR - Undefined variable "traverse"
21:45:37 <conal> directanimation had some beauty and misleading packaging.
21:45:39 <allbery_b> [(+1),(+2),(+3)]
21:45:49 <a2dk> (foldr ($) id [(+1),(+2),(+3) ]) 1
21:46:03 <a2dk> > (foldr ($) id [(+1),(+2),(+3) ]) 1
21:46:04 <mbot>   add an instance declaration for (Num (a -> a))
21:46:21 <conal> wy: yes, it's a pleasant surprise, and somewhat bittersweet, for me to see MS finally interested in FP.  i was a fish out of water there
21:46:49 <conal> wy: i work at home now, living in the woods in central/northern CA.  haven't had a regular job since MS.
21:46:51 <ac> sclv: or maybe even take a whole bunch of files and combine them in to a module that exported one function per file
21:47:07 <ac> sclv: then in your program you could say "import templates"
21:47:24 <wy> conal: That's better :-)
21:47:26 <conal> wy: now mostly FP again, but for a while i did all kinds of other stuff.  see http://conal.net/cv.pdf and http://awakeningcompassion.com .
21:47:56 <conal> wy: yes, i love it.  it's so beautiful & peaceful where i live.
21:48:02 <sclv> ac: so your templates wouldn't have named parameters!? that seems pretty unreadable to me.
21:48:13 <ac> sclv: yes, that is a problem
21:48:25 <ac> sclv: but I like simple solutions
21:48:55 <ac> does Haskell or GHC not have any extension for named parameters?
21:49:14 <ac> I'm not sure how that would reconcile with partial application
21:49:44 <sclv> ac: use a Map.
21:50:02 <allbery_b> or a record
21:50:25 <dobblego> ?hoogle (Maybe a) -> (a -> Bool) -> Bool
21:50:25 <lambdabot> No matches, try a more general search
21:50:26 <mbot> http://en.wikipedia.org/wiki/Boolean_datatype
21:50:26 <mbot> Title: Boolean datatype - Wikipedia, the free encyclopedia
21:50:27 <lambdabot> mbot: You have 1 new message. '/msg lambdabot @messages' to read it.
21:50:27 <lambdabot> Title: Boolean datatype - Wikipedia, the free encyclopedia
21:50:28 <Armored_Azrael> I'm looking for an ext3 haskell library. I can't seem to find one in the HHL...
21:50:35 <sclv> The performance issue will be minimal. (allbery_b: but that would mean exporting a distinct record type for each template which seems even more painful)
21:51:15 <dobblego> ?hoogle [a] -> (a -> Bool) -> Bool
21:51:15 <lambdabot> Prelude.any :: (a -> Bool) -> [a] -> Bool
21:51:15 <lambdabot> Prelude.all :: (a -> Bool) -> [a] -> Bool
21:51:15 <lambdabot> Data.List.any :: (a -> Bool) -> [a] -> Bool
21:51:17 <mbot> http://www.codeguru.com/forum/showthread.php?t=332831
21:51:17 <mbot> Title: CodeGuru Forums - Visual C++ General: What is the difference between 'BOOL' and  ...
21:51:18 <lambdabot> Title: CodeGuru Forums - Visual C++ General: What is the difference between 'BOOL' and  ...
21:51:25 <ac> sclv: the problem with using a map is that limits me to passing in parameters of a uniform type
21:51:37 <ac> sclv: I'm sure Bools would be useful
21:51:43 <ac> sclv: and possibly integers
21:52:01 <wy> conal: Congratulations! You've got freedom :-)
21:52:16 <conal> wy: thanks.  what about you?  student?  cornell?
21:52:30 <sclv> ac: Data TemplateParam = B Bool | S String | IN Int | LI [TemplateParam]
21:52:31 <ac> sclv: though I suppose my "if foo .." syntax could turn in to "if foo == [] then ..."
21:52:37 <wy> conal: Yes...
21:53:17 <allbery_b> Armored_Azrael: "ext3 library"?  why would that be included in the core/standard libraries?  Haskell is not Linux-only.
21:53:46 <allbery_b> (I don't think there are bindings to libext3 on hackage either; don't think anyone has cared before)
21:53:52 <sclv> ac: although, yes, the typical way to represent bools in a template system is just an existence check on a parameter.
21:54:12 <a2dk> Why this error using traverse? http://hpaste.org/4535
21:54:20 <Armored_Azrael> allbery_b: I understand it wouldn't be in the core libraries, I'm questioning if there exists one.
21:54:21 <shachaf> @ty maybe False
21:54:22 <lambdabot> forall a. (a -> Bool) -> Maybe a -> Bool
21:54:24 <mbot> forall a. (a -> Bool) -> Maybe a -> Bool
21:54:26 <sclv> what is the template system for anyeay?
21:54:32 <ac> sclv: cgi programs
21:54:36 <allbery_b> check http://hackage.haskell.org
21:54:37 <lambdabot> Title: HackageDB: introduction
21:56:51 <ac> sclv: so I typical template call might look like "head title" or "message_post author date body blah blah"
21:58:01 <Armored_Azrael> allbery_b: Just checked there, doesn't seem to be anything. Any other ideas? (I suppose I could always use FFI or execute other binaries on the system to accomplish this, but I'd rather not...)
21:58:05 <ac> sclv: though if I used a Data.Map as the parameter it wouldn't look nearly as nice
21:58:37 <andyjgill_> Hey Conal; my wxhaskell install just crashes :-(
21:58:49 <allbery_b> if it's not on hackage, there's a good chance it doesn't exist
21:59:02 <Armored_Azrael> Unfortunate. Thanks anyways.
21:59:25 <shachaf> Cale: You can ask mbot to leave now. :-)
21:59:47 <ac> > 1 + 1
21:59:49 <lambdabot>  2
21:59:50 <mbot>  2
21:59:58 <ac> but now I get helpful answers in stereo
22:00:15 <wy> conal: Is TBAG the most related to constraints?
22:00:45 <sclv> ac: not even message_post $ insert "author" a . insert "date" d . insert "body" b $ empty ?
22:01:53 <ac> sclv: true that is not so bad. Maybe for each template I can have two exports: one with a Map param, and one that took many params
22:02:25 <conal> wy: definitely.  i wanted to do reactivity with constraints also, but i thought i'd better get clear on functional reactivity first and then go constraints.  that was 1994, and i haven't gotten around to it yet.
22:02:28 <sclv> hmmm... you could even write ins = (. M.insert) to improve the syntax further
22:03:37 <conal> wy: TBAG's reactivity was imperative, via assertion & retraction of constraints.
22:07:08 <conal> wy: TBAG (done at Sun Micro) used first deltablue and then skyblue for constraint solving.  those two solvers are domain-independent, and so could be applied to constraints between functions of time (which i doubt had been done before, and perhaps not since).  it worked out nicely.
22:07:30 <ac> sclv: hm. it would be nice if Haskell's syntax was extensible wouldn't it?
22:10:43 <ac> is there a pair operator defined in the prelude?
22:10:56 <allbery_b> meaning?
22:10:59 <allbery_b> :t (,)
22:11:03 <lambdabot> forall a b. a -> b -> (a, b)
22:11:14 <conal> one of the nifty things about tbag is that all tbag models/programs could run multi-user, across a network.  the constraints were broadcast and solved locally.  the multi-user/distributed aspect was completely automatic and didn't influence that model specifications.
22:12:05 <conal> it'd be fun to do something like that again.
22:12:42 <jsnx> what is the platform agnostic way to find the line separator?
22:12:52 <ac> allbery_b: I mean something like "data Pair a b = (:.) a b deriving Show"
22:13:13 <dmwit> ac: What's wrong with a 2-tuple?
22:13:28 <allbery_b> nothing standard, one normally uses 2-tuples
22:13:31 <ac> dmwit: it requires two extra characters
22:14:07 <dmwit> > (length "a :. b", length "(a, b)")
22:14:08 <lambdabot>  (6,6)
22:14:20 <Korollary> @src lines
22:14:20 <lambdabot> Source not found. The more you drive -- the dumber you get.
22:14:24 <zeeeee> i'm writing a simulator; this seems to be another example of how haskell's imperative language could use improvement. for each time step, i mutate portions of some (large) state, but haskell is missing efficient imperative io collections; the explicit ordering of the variable reads for simple expressions would also add to the verbiage.
22:14:35 <jsnx> don't parentheses take up more space than blanks?
22:14:45 <wy> conal: I found cooldraw on their ftp. Is it maintained?
22:14:48 <conal> ac: it sure would be nice to have a standard function, e.g., "pair = (,)", for sections.  i often define one myself.
22:14:52 <dmwit> jsnx: No?
22:15:00 <jsnx> dmwit: teasing :)
22:15:04 <dmwit> :t uncurry id
22:15:14 <lambdabot> forall b c. (b -> c, b) -> c
22:15:20 <andyjgill_> Just listened to the TV guy talk about a small 11.7 earthquake of the oregon coast.
22:15:23 <conal> wy: what's cooldraw?  url?
22:15:32 <conal> andyjgill_: 11.7??
22:15:36 <andyjgill_> Had to listen to it 3 times to check what he said.
22:15:41 <ac> yeah, how can you have a "small" 11.7
22:15:48 <wy> conal: ftp://ftp.cs.washington.edu/pub/constraints/code/
22:15:50 <andyjgill_> He had no idea what he was reading
22:16:00 <andyjgill_> The largest ever was 9.5, in chile
22:16:01 <jsnx> zeeeee: maybe you should completely rethink your simulation
22:16:03 <ac> I suppose if it was a long way off the coast it could FEEL small, but then you'd have a tsunami
22:16:07 <wy> conal: I think that might be some simple drawing tool using those constraint solvers
22:16:10 <andyjgill_> it was a 4.7.
22:16:16 <andyjgill_> at 11 this morning
22:16:25 <jsnx> zeeeee: e.g., don't update state
22:16:26 <dmwit> andyjgill_: hahaha
22:16:40 <jsnx> zeeeee: just prepare to solve for bits and pieces of it on demand
22:17:12 <jsnx> so, what is the cross platform way to get the line separator, e.g. "\n" on unix but "\r\n" on windows
22:17:14 <conal> wy: yeah -- borning & others at UW were doing constraints for drawing.  see also gosling's thesis on "magritte" -- also a constraint-based drawing tool.  was very inspiring for me as a grad student & later.
22:18:02 <jsnx> zeeeee: not saying it's easy...but i don't see why you'd use haskell if you were going to go with a down and dirty stateful sim
22:18:37 <allbery_b> jsnx: you use \n on both, use openBinaryFile to get a Handle that doesn't do newline translation
22:18:43 <allbery_b> @index openBinaryFile
22:18:44 <lambdabot> System.IO
22:18:44 <thetallguy> http://quake.usgs.gov/recenteqs/
22:18:45 <lambdabot> Title: Recent Earthquakes in California and Nevada - Index Map
22:18:57 <jsnx> allbery_b: oh, weird
22:19:02 <thetallguy> We get about 50 1.x per week
22:19:03 <zeeeee> jsnx, i'm not, i'm actually using scala instead; i learned from this mistake in the past. but i guess you missed the earlier discussion here on haskell's imperative programming facilities
22:19:08 <allbery_b> hm?  that's fairly common
22:19:12 <jsnx> zeeeee: oh
22:19:15 <thetallguy> in San Diego
22:19:21 <jsnx> zeeeee: yeah, i just showed up
22:19:40 <allbery_b> for example in C you use \n on both platforms unless you include "b" in the open mode (or O_BINARY for low-level open())
22:19:46 <thetallguy> here's a good little Haskell app to write
22:19:50 <jsnx> allbery_b: so there is no way to do `string ++ lineSep` or something like that?
22:20:05 <jsnx> allbery_b: in C that works?
22:20:05 <thetallguy> scrape that earthquake site and make your screen ripple appropriately
22:20:21 <ddarius> zeeeee: Yes but the common refrain is that Haskell is a functional language not an imperative one.  It's object-oriented and logic programming features could also use improvement but neither of those are going to happen either.
22:20:40 <jsnx> ddarius: i second that
22:20:59 <jsnx> zeeeee: languages that try to do all those things end up real mutts
22:21:05 <ac> now why wouldn't an OO system for Haskell appear? I figure if enough people start using it, it's just a matter of time
22:21:12 <jsnx> (i'm not going to name any names)
22:21:34 <allbery_b> there's O'Haskell but I'm not sure it's being maintained
22:21:40 <ddarius> ac: Because people who use Haskell aren't inclined particularly toward OO.
22:21:55 <ddarius> allbery_b: That died a long time ago and was replaced by Timber which was never publically released.
22:22:01 * BMeph coughs: *cough* PYTHON *cough*
22:22:20 * jsnx tazes BMeph 
22:22:40 * BMeph twitches ungracefully. The cough is gone, which is nice.
22:22:54 <jsnx> haskell doesn't really support the notion of 'object scoped' methods
22:23:04 <wy> conal: I found the paper "Defining Constraints Graphically" by Borning
22:23:38 <jsnx> i guess you could do some syntax transformations, overloading the overloaded dot operator
22:23:51 <jsnx> BMeph: i don't know what your point is?
22:24:28 <jsnx> are you saying that i was saying python is a mutt?
22:25:25 <BMeph> Are you saying that Python isn't?
22:26:04 <wy> conal: All the things are in smalltalk
22:26:18 <conal> wy: oh yeah.  i'd forgotten that.
22:26:49 <conal> wy: oh, i just remembered.  mike gleicher did a bunch of neat work on "differential constraints", including a drawing tool, which i think was called "briar".
22:27:05 <jsnx> BMeph: it wasn't the language i had in mind...
22:27:15 <jsnx> BMeph: it's not so bad for the family it's in
22:27:31 <ac> jsnx: ocaml?
22:27:40 <jsnx> ac: that and scala
22:27:41 <conal> wy: i'd forgotten how into constraints i used to be.
22:27:46 <jsnx> the latter more so, i think
22:27:55 <BMeph> jsnx: Factor? ;)
22:28:03 <jsnx> BMeph: never seen it :)
22:28:38 <BMeph> jsnx: Count yourself lucky. And that's coming from a long-time FORTH programmer. ;p
22:28:59 <conal> wy: see http://pages.cs.wisc.edu/~gleicher/cgi-bin/list.py?ScriptStuff/papers.html .  differential constraints/manipulation is near the end (earliest).  it's mike's grad school work.  (he & i overlapped at cmu.)
22:29:01 <lambdabot> Title: Mike Gleicher's Papers, http://tinyurl.com/2k9m2m
22:30:18 <jsnx> BMeph: i've always been curious about Forth...
22:30:37 <jsnx> BMeph: can you explain what is cool about it?
22:30:41 <zeeeee> jsnx, scala has a world of problems of its own, but i'm currently in #haskell; hence, i whine about haskell :)
22:30:54 <jsnx> zeeeee: sure
22:31:17 <jsnx> zeeeee: can you say more about your sim?
22:31:43 <jsnx> zeeeee: like, what order of derivatives do you have available?
22:33:12 <jsnx> zeeeee: you could probably run the sim in an event driven way
22:33:27 <jsnx> zeeeee: state is calculated on demand from the derivatives
22:33:48 <jsnx> zeeeee: and certain events -- collisions, &c. -- are posted to change the derivatives at set times
22:34:05 <jsnx> zeeeee: but, that's just an idea
22:34:10 <jsnx> i don't write sims or anything
22:34:53 <BMeph> jsnx: It was as understandable and easy to learn as BASIC, and as powerful at data processing as APL. A lot of capability in a tidy package.
22:36:09 <ac> BMeph: how is Factor different from Forth?
22:39:48 <BMeph> ac: I'd have to work with it more to see. The things I've seen about it suggest thatit's much more heavily object-based, and less stack-based.
22:40:11 <BMeph> ac: Well, I'd have to work with it, period, to see. ;)
22:40:13 <zeeeee> jsnx, sure. it analyzes logs from nodes in a distributed system, simulating the state from these events. the state it simulates includes calculating the neighbor sets for an overlay routing scheme, monitoring link state latencies/reachability, maintaining routing tables and membership databases, gathering statistics over streams of finite-duration events (esp. windowed and concurrent events), etc.
22:41:40 <wy> conal: Got a lot to see. My firefox has three rows of tags ;-)
22:42:26 <ac> BMeph: huh, that's not the impression I've gotten
22:44:11 <BMeph> ac: Well, better you than I. I'll look at it some more when I have more free time. For now, my "free" time is more stolen. ;)
22:45:08 <conal> wy: :)  that's a lot of leads!  have fun, and please let me know your impressions.
22:45:52 <wy> conal: Thanks a lot!
22:46:09 <conal> wy: :)
22:46:18 <ac> BMeph: the guy who wrote it hangs out here from time to time
22:47:23 <wy> conal: I tried to add your gtalk and I'm not sure I succeeded because it's a new program I found in Ubuntu
22:48:58 <Cale> zeeeee: That sounds like a lazy functional programming problem to me ;)
22:50:37 <zeeeee> Cale, oh yeah, thanks - it needs to run fast!
22:51:04 <conal> wy: one thing i've been thinking about lately is the idea of "composable programs".  the type of haskell's "main" prevents them from being nicely composable.  TV suggests an alternative, by keeping the interface part and the pure core combined but separable.  composition automatically modifies the interface part, which is not possible in typical IO-style Haskell programming.  i'd like to revive the original beautiful unix vision of
22:51:04 <conal> composable apps, but in a modern, workable way (unlike unix's strategy).  that's what the "modern marriage" google tech talk is about.
22:51:36 <conal> wy: plus erasing the divide beween users & programmers.
22:52:15 <Cale> zeeeee: I wrote a pipeline scheduler in Haskell using the list monad a whole lot, and it was quite fun -- that's kind of like simulating a system. :)
22:52:30 <conal> TV is essentially functional, composable, generalized MVC.
22:52:55 <zeeeee> Cale, what kinda pipeline?
22:53:17 <Cale> zeeeee: Altivec and PPC instruction pipeline.
22:54:17 <wy> conal: I really should get my sound ;-) I think so too. Actually I think haskell could be more interactive, somewhat like lisp.
22:54:20 <Cale> Of course, the demands on performance were low, but the end result did end up being pretty fast.
22:54:53 <Cale> (We cared more about the performance of the resulting code than the performance of the scheduler.)
22:54:53 <wy> conal: Maybe there will be issues about static typing if it's fully interactive
22:55:17 <conal> wy: there are interesting static type issues, indeed.
22:55:25 <ac> conal: I think it would be great to break down the divide a little between users and programmers, but I think it will take a heck of a lot more than a new GUI library
22:55:33 <ddarius> wy: Worse case scenario a system could run the type checker at run-time.
22:55:36 <conal> wy: Eros is statically typed.
22:55:41 <wy> http://www.cs.wisc.edu/graphics/Papers/Gleicher/Thesis/ThesisPics/luxo.jpg
22:55:43 <zeeeee> Cale, i think i saw that paper! yeah, with code gen anything is possible, but that requires... more effort... and more Cale
22:55:44 <lambdabot> http://tinyurl.com/26jsg6
22:55:55 <conal> ac: agreed.  See Eros.
22:56:45 <Cale> zeeeee: Well, I'm just saying that pure functional programming can be a great way to do simulations.
22:57:00 <Cale> Especially so if you need nondeterministic simulation.
22:57:03 <jsnx> zeeeee: so you are grabbing data from the nodes and trying to simulate their future state?
22:57:04 <conal> zeeeee: and with continuous time
22:57:26 <conal> zeeeee: as in FRP
22:57:44 <zeeeee> jsnx, just simulating their state, not really their future state
22:58:14 <jsnx> zeeeee: so, you are grabbing part of their state, and simulating the rest of it?
22:58:32 <jsnx> zeeeee: as you get new data in, you update those parts of the simulation?
22:58:46 <zeeeee> jsnx, right
22:59:14 <sclv> zeeeee: how large are the collections you're working on?
22:59:16 <jsnx> zeeeee: that's a very different simulation than i was thinking about
22:59:40 <zeeeee> sclv, 10^5-10^6
22:59:45 <zeeeee> - means to
23:00:05 <Cale> zeeeee: btw, I think I saw you were complaining about lack of data structures? What kind of data structures are missing?
23:00:07 <conal> @where+ Eros http://conal.net/papers/Eros
23:00:08 <lambdabot> It is stored.
23:00:21 <ddarius> "First introduction: for students (and everybody else). In the study of ordinary differential equations, when you face a Cauchy problem of the form ..."
23:00:25 <sclv> and they're indexed by what?
23:02:04 <zeeeee> sclv, tightly packed int ranges, sparse int ranges, short strings, ...
23:02:41 <sclv> I'd be surprised if you couldn't get pretty good performance out of IntMaps accessed in STM actually?
23:03:06 <Cale> Or just Data.Map
23:04:46 <Cale> A lot of people overlook Data.Map thinking that it couldn't possibly compete with a mutable datastructure, but it's actually quite reasonable.
23:04:46 <zeeeee> sclv, Cale, i went through this fp crisis once before last year, writing a simulator in haskell; i remember data.map not perform well
23:05:07 <jsnx> Cale: i don't think it's unboxed, even...
23:05:09 <sclv> I'm starting to evangelize increasingly frequently about how hashtables, even very nice ones in low-level languages, aren't nearly as efficient as folks imagine.
23:05:25 <ddarius> These authors have an impressive view of "everybody's basic knowledge in mathematics"
23:05:31 <Cale> jsnx: Of course it's not unboxed, it's polymorphic.
23:05:32 <ac> is there a more concise way of saying "map (\(x, y) -> foo x y) zippedList"
23:05:33 <ac> ?
23:05:43 <glguy> uncurry
23:05:51 <nanothief> @pl \(x, y) -> foo x y
23:05:51 <ac> :t uncurry
23:05:52 <jsnx> zeeeee: you might look at the many sub modules of Data.Array
23:05:52 <lambdabot> uncurry foo
23:06:04 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
23:06:30 <jsnx> `map $ uncurry foo # zippedList`
23:06:33 <sclv> zipWith foo . unzip
23:06:39 <zeeeee> jsnx, yeah, i use arrays a lot for dynamic programming - haskell is a magical thing for some problems, you know? :)
23:07:00 <jsnx> zeeeee: you think they aren't good for what you have in mind, though>
23:07:06 <jsnx> s/>/?/
23:08:09 <ac> sclv: ah guess I could just use zipWith. I knew about zipWith, but wasn't thinking about it for some reason
23:08:54 <Armored_Azrael> Anyone know how to get executeFile not to terminate the program upon completion of executing the program it was told to execute?
23:09:10 <shachaf> map (uncurry foo)?
23:09:15 <glguy> fork?
23:09:16 <Cale> that'd be uncurry (zipWith foo) . unzip
23:09:32 <zeeeee> Cale, various simple things like deques, hash sets, etc. fwiw, i don't think this is as annoying (arrays are in theory all that's needed to build everything else, after all) as the imperative language in haskell through which you use these
23:09:41 <sclv> :y zipWith
23:09:47 <sclv> :t zipWith
23:09:50 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
23:09:55 <Cale> zeeeee: I think most people just stick with the pure functional data structures.
23:10:17 <shachaf> > map (uncurry (+)) [(1,2),(3,4),(5,6)]
23:10:17 <lambdabot>  [3,7,11]
23:11:06 <jsnx> zeeeee: can you say more about what you don't like in the imperative language?
23:11:07 <Cale> zeeeee: You typically only take a logarithmic hit in performance, which is essentially part of the constant factor.
23:11:07 <zeeeee> jsnx, right, arrays are not directly applicable for handling this simulator's state. (you can always build on arrays, though - see above comment)
23:11:46 <jsnx> zeeeee: so this sim's state is more like a hash table, i gather?
23:11:56 <sclv> :t (. unzip) . zipWith
23:11:57 <lambdabot>     Couldn't match expected type `([a], [b])'
23:11:58 <lambdabot>            against inferred type `[a1]'
23:11:58 <lambdabot>     Probable cause: `zipWith' is applied to too few arguments
23:12:34 <Cale> :t zipWith zip
23:12:35 <lambdabot> forall a b. [[a]] -> [[b]] -> [[(a, b)]]
23:12:52 <Cale> :t zipWith (zipWith zip)
23:12:53 <lambdabot> forall a b. [[[a]]] -> [[[b]]] -> [[[(a, b)]]]
23:12:54 <zeeeee> jsnx, well, the state is just what i mentioned above
23:13:17 <shachaf> @ty zipWith zipWith
23:13:18 <lambdabot> forall a b c. [a -> b -> c] -> [[a]] -> [[b] -> [c]]
23:13:27 <conal> wy: here's one more thing you may be interested in: Fruit.  it's a "genuinely functional" approach to GUIs that includes a simple semantics for GUIs as pure functions.  http://www.apocalypse.org/pub/u/antony/work/pubs/genuinely-functional-guis.pdf .  people sometimes assume that modeling user interaction (whether textual or graphical) forces one to bring in side-effects.  things like Fruit suggests otherwise.
23:13:28 <lambdabot> http://tinyurl.com/296be3
23:13:57 <conal> (suggest otherwise)
23:14:24 <ac> what has a type of "[a -> b] -> a -> [b]" sort of like the opposite of map?
23:14:32 <Cale> sequence
23:14:53 <jsnx> :t sequence
23:14:53 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
23:14:55 <Cale> > sequence [(+2),(*2),(^2),(2^)] 5
23:14:56 <lambdabot>  [7,10,25,32]
23:15:32 <jsnx> Cale: which monad is that in?
23:15:40 <Cale> m = (a ->)
23:15:50 <Cale> Or, more syntactically correct, (->) a
23:16:07 <jsnx> interesting
23:16:14 <Cale> It's essentially the reader monad.
23:16:20 <Cale> (If you already know what that is)
23:16:26 <jsnx> (no)
23:16:36 <ddarius> @src Reader
23:16:37 <lambdabot> Source not found. :(
23:16:51 <shachaf> Or map ($ x).
23:16:56 <Cale> So basically, in this monad, your "computations" are just functions from a fixed type.
23:17:05 <bench> how do i break a sentence into words separated by '.' or ',' without destroying potential numbers in the it
23:17:27 <shachaf> > map ($ 5) [(+2),(*2),(^2),(2^)]
23:17:29 <lambdabot>  [7,10,25,32]
23:17:31 <wy> conal: Nice!
23:17:46 <Cale> To "run" a computation, you apply the function to the parameter which the whole computation has been applied to. So it's rather like having a computation-global environment.
23:17:48 <sclv> the unwrapped reader monad is crazy confusing at first -- it should be used as an example in more monad tutorials as a sort of "magic" selling point.
23:17:59 <bench> ("this is a test, that has 13,000 words, for chapter 4.4.")
23:18:09 <wy> conal: Is Yale still active in FP?
23:18:15 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
23:18:16 <lambdabot>  ("hello","olleh","HELLO")
23:18:23 <ac> shachaf: map ($ x) makes more sense to me than the signature of sequence
23:18:27 <conal> wy: yes, though most of the FP guys left.
23:18:31 <Cale> check that out for some inspiration on how it works :)
23:18:44 <conal> wy: paul hudak is still there.
23:18:53 <Cale> So first 'id' is applied to the environment "hello", and the result is bound to x
23:19:02 <shachaf> ac: sequence is fine if you replace m a with r -> a.
23:19:11 <wy> conal: Where did they guys go? I'm considering transfer to another place because no one is doing it here
23:19:11 <Cale> and then 'reverse' is applied to "hello" to get "olleh", which is bound to y
23:19:17 <Cale> and so on
23:19:18 <shachaf> @ty sequence
23:19:20 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
23:19:24 <jsnx> Cale: that's neat
23:19:45 * jsnx thinks hard
23:19:45 <shachaf> sequence :: [r -> a] -> r -> [a]
23:19:46 <Cale> Yeah, there are lots of nice consequences in this monad.
23:19:51 <Cale> > join (*) 5
23:19:52 <lambdabot>  25
23:20:10 <ac> shachaf: yeah syntactially that makes sense... I guess
23:20:18 <shachaf> (id is sometimes called ask, by the way.)
23:20:22 <Cale> > ap (,) (^2) 5
23:20:23 <lambdabot>  (5,25)
23:20:36 <Cale> > map (ap (,) (^2)) [1..10]
23:20:36 <lambdabot>  [(1,1),(2,4),(3,9),(4,16),(5,25),(6,36),(7,49),(8,64),(9,81),(10,100)]
23:20:55 <sclv> bench: instead of looking for '.' and ',', maybe you could look for ". " and ", " ?
23:21:08 <ac> > map length ["sequence x", "map ($ x)"]
23:21:08 <lambdabot>  [10,9]
23:21:31 <ddarius> shachaf: And also asks
23:21:40 <jsnx> ac: that is the silliest criterion...
23:21:45 <ac> jsnx: ;-)
23:22:02 <jsnx> count parens twice, cause you have to hit the shift key :)
23:22:03 <Cale> > map length ["sequence", "map . flip ($)"]
23:22:04 <lambdabot>  [8,14]
23:22:46 <shachaf> ddarius: Well, OK, but I meant it in the context of Cale's do.
23:22:51 <jsnx> wo, i just realized there's a shift key on the right side of my keyboard!
23:22:52 <bench> i tried to use break, but that didn't help deal with "4.4" and "13,000"
23:22:54 <conal> wy: mostly, it's the usual thing of grad students finishing.  also, loss of funding for extra staff.  if you're interested, i recommend geting in touch with paul hudak.  he'd be terrific to study under.
23:23:18 <jsnx> bench: just use parsec
23:23:24 <jsnx> bench: writing parsers is fun
23:23:35 <conal> wy: there are also nottingham & chalmers.
23:23:55 <sclv> bench: right, it didn't work because it only tests against a single character. you should be testing for a period or comma followed by a space.
23:24:05 <Cale> jsnx: It's a good exercise coming up with the definitions for return and (>>=) for this monad, by the way.
23:24:11 <wy> conal: Good! I can consider that. But those Europe schools are harder for me to get in because I don't have masters yet.
23:24:14 <Cale> jsnx: You can derive them directly from the types :)
23:24:40 <bench> jsnx, i was hoping for something simpler, such as break/words
23:24:47 <conal> wy: also york.  most lazy functional programming academics are outside of the u.s.
23:25:09 <wy> conal: Because they are lazy ;-)
23:25:56 <jsnx> Cale: okay, i'm going to take a minute and figure this out :)
23:26:02 <jsnx> bench: i gave up :(
23:26:11 <conal> wy: i hadn't heard that it's hard to get into european grad programs without a masters.
23:26:17 <qweqwe> http://hpaste.org/4536 what is wrong there ?
23:27:08 * shachaf actually understood (r ->)'s (>>=) more easily after implementing it in Reader.
23:27:56 <shachaf> The newtype helped separate things, I suppose.
23:28:13 <bench> jsnx, ok, how do you use parsec to accomplish that then?
23:28:55 <sclv> > (map fst *** map snd) . break (((','), ' ') ==) . ap zip tail $ "foo 12.34 bar, baz."
23:28:56 <lambdabot>  ("foo 12.34 bar"," baz.")
23:29:21 <qweqwe> any idea ?
23:29:39 <dons> qweqwe: hmm
23:29:51 <sclv> of course, you need to add a test for a period too, then toss it in an unfold.
23:30:21 <wy> conal: Good. I'll work hard on this topic. Notingham is also doing epigram
23:30:24 <bench> sclv: what is ***?
23:30:36 <sclv> ?ty (***)
23:30:37 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
23:30:37 <dons> qweqwe: i think we need more context for this (and can you load it in ghci for a better type error message?)
23:31:08 <dons> qweqwe: btw, show(y) does nothing in haskell, its the same as:  show y
23:31:18 <scook0> bench: (f *** g) (a, b) = (f a, g b)
23:31:49 <scook0> (though (***) is a bit more general than that, since it can be applied to any Arrow, not just functions)
23:32:00 <qweqwe> dons:http://hpaste.org/4537
23:32:04 <dons> > map (toUpper *** (+1) $ zip "haskell" [2, 4 ..]
23:32:05 <lambdabot> Unbalanced parentheses
23:32:12 <dons> > map (toUpper *** (+1)) $ zip "haskell" [2, 4 ..]
23:32:13 <lambdabot>  [('H',3),('A',5),('S',7),('K',9),('E',11),('L',13),('L',15)]
23:32:23 <dons> now, if only they ran those arrows in parallel...
23:32:43 <dons> anyone want to write a paper mapping yampa onto multicore ? :)
23:32:47 <scook0> qweqwe: does it work if you comment out the type signature of ins?
23:32:54 <qweqwe> yes
23:33:10 <scook0> ah, then I know what the problem is
23:33:21 <qweqwe> shoot
23:33:32 <dons> ah yes :)
23:33:36 <dons> the added context helps
23:33:37 <bench> scook0/sclv, thanks
23:33:41 <scook0> dons: scoped type variables :)
23:33:50 <pejo> dons, you planning to write such a paper?
23:33:55 <dons> the value key in the inner scope aren't the same as the outer scope, qweqwe
23:34:02 <dons> so remove the type signature on the 'ins'
23:34:27 <scook0> qweqwe: basically, the compiler doesn't understand that the "value" and "key" type variables are supposed to represent the same type across both signatures
23:34:32 <dons> you can also bind them with forall, but there's no need to do that here.
23:34:37 <dons> pejo: i've thought about it :)
23:34:51 <OceanSpray> #hpaste
23:34:52 <scook0> I believe it's impossible to express the type of ins in standard Haskell 98
23:34:52 <dons> pejo: since it seems like kinda obvious, and i like the obvious
23:34:55 <OceanSpray> @hpaste
23:34:56 <lambdabot> Haskell pastebin: http://hpaste.org/new
23:35:05 <dons> scook0: yes, i think you're right.
23:35:12 <dons> without some `asTypeOf` trickery
23:35:29 <OceanSpray> http://hpaste.org/4538
23:35:37 <OceanSpray> how do I make this function less ugly?
23:35:38 <scook0> which doesn't really count as "expressing the type", of course
23:35:43 <dons> yep
23:35:52 <Cin> any particular reason why hpaste is used instead of lisp.paste.org?
23:36:03 <OceanSpray> because it's haskell code?
23:36:18 <Cin> quite a poor answer
23:36:20 <dons> let m | sign == '-' = -1  | otherwise   =  1
23:36:21 <dons> ?
23:36:26 <pejo> dons, put me down as enthusiastic supporter, I'll be cheering from the side!
23:36:32 <shachaf> Cin: Any particular reasonto use lisp.paste.org instead of hpaste?
23:36:34 <dons> Cin: we wrote it to serve our needs
23:37:01 <dons> it highlights haskell syntax, in particular, which was the original motivation
23:37:04 <OceanSpray> dons, I don't understand what you've written
23:37:14 <OceanSpray> what does the | operator do?
23:37:19 <dons> OceanSpray: oh, just thinking how to clean up that if -then-else
23:37:31 <shachaf> OceanSpray: Guards.
23:37:34 <OceanSpray> huh.
23:37:36 <dons> ?pretty let m | sign == '-' = -1 | otherwise = 1
23:37:36 <lambdabot> "Parse error" at column 1
23:37:39 <dons> ?pretty let m | sign == '-' = -1 | otherwise = 1 in m
23:37:40 <lambdabot>  let m
23:37:40 <lambdabot>      | sign == '-' = - 1
23:37:40 <lambdabot>      | otherwise = 1
23:37:40 <lambdabot>  in m
23:37:52 <shachaf> OceanSpray: It's syntax, not an operator.
23:37:55 <OceanSpray> oh
23:37:58 <dons> yay syntax
23:38:05 <dons> sugar makes me sweet
23:38:09 <Cin> dons: paste.lisp.org highlights haskell
23:38:18 <dons> Cin, it didn't when we wrote hpaste :)
23:38:28 <Cin> that would be the reason, then
23:38:30 <dons> its also useful, for such a big channel, to have access to our own paste bin
23:38:36 * Cin mumbles blood out of stone
23:38:44 <dons> the other big tipping point was that we relied on lisppaste heavily
23:38:45 <ddarius> Also, hpaste announces to this channel
23:38:48 <dons> and it disappeared for 3 weeks
23:38:50 <OceanSpray> what about otherwise?
23:38:54 <dons> we didn't have access to the src, nor the maintainers
23:38:59 <dons> so we wrote our own to replace it.
23:38:59 <OceanSpray> it doesn't turn blue in emacs, so it must be a function or something
23:39:05 <ddarius> We used to use a wiki page on the old wiki a long time ago.
23:39:07 <shachaf> @src otherwise
23:39:07 <lambdabot> otherwise = True
23:39:11 <OceanSpray> oh
23:39:14 <OceanSpray> huh.
23:39:19 <conal> wy: would you happen to know anything about getting ubuntu 7.10 to find an unsecured wap?  i want to switch from windows to linux, but i'm stuck on the wireless part.  it sees my card but not the wap.
23:39:21 <OceanSpray> why would you need that, then?
23:39:25 <dons> there's 2 or 3 times the number of people in here than in #lisp, so we really reaached the point we needed our own pastebin
23:39:30 <ddarius> OceanSpray: It reads better.
23:39:30 <OceanSpray> can't you just write | True 1 ?
23:39:38 <ddarius> You can, though it would be | True = 1
23:39:47 <OceanSpray> yeah, that's what I meant
23:39:54 <OceanSpray> oh wait
23:39:56 <shachaf> conal: What card do you have?
23:39:58 <sclv> OceanSpray: the fromIntegral stuff looks like it could be maybe factored better?
23:40:12 <OceanSpray> sclv, yeah, but how?
23:40:14 <wy> conal: It seems you have the same setup as mine, without password?
23:40:14 <dons> Cin, so i think from memory the main reason was a) our reliance on a paste bin, and b) lisppaste being unreliable at a key point
23:40:23 <OceanSpray> why doesn't otherwise require a = ?
23:40:29 <Cin> dons: i see
23:40:32 <dons> since its only 500 lines or so of happs in hpaste.org, it wasn't such a big deal.
23:40:35 <ddarius> OceanSpray: It does.
23:40:42 <OceanSpray> whoops
23:40:51 <wy> conal: I know my ESSID, and I just entered it there ;-)
23:41:00 <ddarius> conal: It took some fiddling for me, Feisty was better than Edgy.  I don't know about Gutsy.  I'm also using a laptop though.
23:41:12 <conal> shachaf: it an intel.  looking up specifics on that machine...
23:41:14 <ddarius> (and a secured WAP)
23:41:18 <dons> qweqwe: btw, you can annotate existing pastes
23:41:28 <dons> might be better than creating dozens of anonymous pastes on the same topic :)
23:41:47 <shachaf> Gutsy seems to be much more successful than Feisty (with wireless) to me.
23:42:07 <ddarius> shachaf: I haven't wanted to rock the boat, but I've thought about upgrading for other reasons.
23:42:19 <wy> conal: Sorry I misunderstood. I haven't wap, so I don't know
23:42:24 <OceanSpray> > read "3" :: Rational
23:42:26 <lambdabot>  Exception: Prelude.read: no parse
23:42:30 <OceanSpray> wha
23:42:41 <OceanSpray> > read "3" :: Float
23:42:43 <lambdabot>  3.0
23:42:43 <dons> lisppaste is a bit bloated too, these days. i think we're better off with hpaste.
23:42:45 <OceanSpray> ok
23:42:49 * shachaf ran Gutsya month or two before it was released. :-)
23:43:11 <dons> oh, it even has captchas now :(
23:43:15 <dons> that's no good -- i paste from w3m.
23:43:27 <sclv> OceanSpray: Real is your own constructor?
23:43:30 <conal> does anyone use an open wap with ubuntu gutsy?
23:43:40 <OceanSpray> sclv, yes
23:43:43 <bench> sclv: what is break ((','), ' ') == )
23:43:48 <sclv> what does it take?
23:43:53 <OceanSpray> a Float
23:43:57 <shachaf> conal: I didn't have a problem with it.
23:44:02 <scook0> I wonder if hpaste's "annotate" needs to be more prominent/discoverable/obvious
23:44:05 <sclv> bench: sorry, premature @pling.
23:44:06 <shachaf> conal: #-blah?
23:44:13 <OceanSpray> oh wait
23:44:14 <dons> scook0: oh, good point.
23:44:16 <OceanSpray> a Doubule
23:44:20 <conal> shachaf: you bet.
23:44:20 <dons> its been a while since we thought about ui issues.
23:44:31 <dons> it probably should be clearer -- that's the main thing that goes wrong.
23:44:44 <scook0> dons: I've told people about it many times
23:44:52 <scook0> (though each individual only needs to be told once)
23:45:03 <sclv> @unpl ( (',', ' ') == )
23:45:03 <lambdabot> (\ a -> ((',', ' ')) == a)
23:45:16 <dons> scook0: yeah, me too.
23:45:19 <scook0> the other thing I wish hpaste had is some kind of search
23:45:25 <dons> me too!
23:45:33 <dons> i'd like to export the entire history :)
23:45:38 <scook0> even if it's just a preconfigured google-box
23:45:39 <Associat0r> does anyone know the book, "The haskell road to logic?
23:45:52 <dons> Associat0r: yes, its well regarded
23:46:23 <shachaf> It's not especially about Haskell, though, I think.
23:46:29 <Associat0r> dons can I use it as a substitute for "intro mathematical reasoning"
23:46:34 <dons> http://haskell.org/haskellwiki/Books_and_tutorials/Mathematics
23:46:36 <Associat0r> or "how to prove it"
23:46:49 <dons> Associat0r: hmm. it is used as an intro to comp sci. proofs/reasoning, iirc
23:47:03 <dons> "The purpose of this book is to teach logic and mathematical reasoning in practice, and to connect logical reasoning with computer programming."
23:47:25 <Associat0r> I am mainly a programmer but have no formal education
23:47:31 <Associat0r> but want to learn it by my own
23:47:35 <Associat0r> the math behind it
23:47:39 <dons> yeah, i think it would be good for that purpoose.
23:47:42 <ac> I could say: "findWithDefault (error (key ++ " not found")) key map" right?
23:47:58 <Associat0r> but I want to know if it would be redundant to read the other non computer prove books too
23:48:13 <dons> well, possibly. you might do one at a time :)
23:48:22 <dons> i think 'the haskell road' is a good intro, and focuses on the practical
23:48:26 <dons> you'll have ghci in front of you
23:48:35 <Associat0r> yes
23:49:02 <Associat0r> I have a good experience programming in imperative languages like C/C++ and ASM
23:49:02 <dons> a lot of the code is online too, http://homepages.cwi.nl/~jve/HR/
23:49:03 <lambdabot> Title: The Haskell Road
23:49:20 <bench> sclv: how do you add a test for '.' and unfold?
23:49:25 * dons likes the new haskell.org slogan
23:49:34 <ddarius> dons: Why is that?
23:49:53 <dons> well, its been a week. reading over it still makes me feel inspired to write code
23:49:53 <Cin> what is this construct called? [ x <-[1,2,3] ]
23:49:54 <Associat0r> also what about the other dicrete math books on that page
23:50:08 <dons> Cin: a list comprehension, but that bit in particular is a generator
23:50:10 <Associat0r> dons
23:50:11 <sclv> bench: look at the function for break again. it's testing for a pair of a comma and a space, right? now think how to extend it to test for a period and a space pair as well.
23:50:16 <sclv> ?ty unfold
23:50:17 <lambdabot> Not in scope: `unfold'
23:50:19 <sclv> ?ty unfoldr
23:50:20 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
23:50:31 <dons> > [ x ^ 2 | x <- [1..] , x `mod` 2 == 0 ]
23:50:32 <lambdabot>  [4,16,36,64,100,144,196,256,324,400,484,576,676,784,900,1024,1156,1296,1444,...
23:50:35 <dons> is a comprehension
23:50:39 <dons> or 'list comprehension'
23:50:43 <Cin> dons: ahh, generator, thanks -- iiirc it corresponds to something similar in math?
23:50:46 <dons> the x <- [1..] part is a generator
23:50:56 <dons> set notation?
23:51:06 <Cin> does it?
23:51:22 <dons> set-builder notation, i should say
23:51:36 <shachaf> Sometimes that's written as {x \elem S | P(x) }
23:51:49 <dons> yeah
23:51:49 <Cin> shachaf: is that set notation?
23:51:54 <Cin> er, set-builder notation
23:51:56 <dons> ah see,http://en.wikipedia.org/wiki/List_comprehension
23:51:56 <lambdabot> Title: List comprehension - Wikipedia, the free encyclopedia
23:52:15 <Cin> ahhh, thanks
23:52:31 <dons> funny to find some haskell syntax that actually did come from math :)
23:52:50 <dons> you see people mention that in blogs all the time, the 'math syntax', but it doesn't feel like it day-to-day
23:53:06 <Cin> hehe
23:53:49 <dons> heh, i like how the article on list comprehensions includes lots of examples of code that isn't a list comprehension
23:53:52 <dons> but does the same thing.
23:54:21 <Associat0r> dons  "Discrete Mathematics Using a Computer
23:54:21 <Associat0r> Second Edition"
23:54:27 <Associat0r> how does it compare?
23:54:28 <vininim> lol
23:54:41 <sclv> > unfoldr (\x -> if x < 1 then Nothing else Just (x,x`div`2)) 12
23:54:42 <lambdabot>  [12,6,3,1]
23:54:52 <dons> Associat0r: haven't read that one.
23:55:19 <wy> conal: Is there a package for tv or eros on ubuntu?
23:55:22 <vininim> > foldr (.) id  ((+) <$> [1..10]) 2
23:55:22 <lambdabot>  57
23:55:38 <bench> sclv: i was testing with the | operator, but that didnt' seem to work
23:56:19 <sclv> ?ty (||)
23:56:20 <lambdabot> Bool -> Bool -> Bool
23:56:29 <sclv> bench: single | is typically bitwise, not logical.
23:57:16 <dons> > 1 .|. 7 :: Int
23:57:17 <lambdabot>  7
23:57:33 <dons> > 1 || 7 -- :)
23:57:34 <lambdabot>   add an instance declaration for (Num Bool)
23:57:44 <dons> > 1  | 7 -- nu uh
23:57:44 <lambdabot>  Parse error at "|" (column 4)
23:59:52 <conal> wy: nothing ubuntu- or linux-specific.  see the wiki pages.
