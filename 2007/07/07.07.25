00:00:02 <Pseudonym> And there are a couple of people doing that in Haskell.
00:00:09 <newsham> sounds like collaboration/versioning to me
00:05:29 <glguy> one of the cool things is that Galois doesn't seem to mind pushing libraries out as opensource
00:05:50 <Pseudonym> Well, yeah.  It's not like they have competitors who will pick them up and run with them.
00:05:55 <glguy> so hopefully I'll be able to get the libcurl bindings we use opened up some time soon
00:06:05 <Pseudonym> All their competitors are using horrible impure stuff.
00:06:27 <Pseudonym> Is Fergus still at Galois?
00:06:34 <glguy> I don't think so...
00:06:47 <Pseudonym> Mark Shields was there for a while, too, wasn't he?
00:06:56 <newsham> hrmm.. high assurance software binding to open source C libraries?
00:07:00 <dons> i have a theory that it is important to release libs,  in fact, since you'll end up with more people using haskell (due to good libs), which means more experts, and more galois employees :)
00:07:15 <dons> similar to erlang use due to ericsson provided libs
00:07:15 <newsham> sweet, all I have to do is break libcurl and pwn the galoises
00:07:34 <dons> also, then you get libs written for you
00:07:36 <Pseudonym> More to the point, the more Haskell experts there are, the easier it is to sell your product.
00:07:40 <dons> yeah
00:07:52 <glguy> newsham: darcs is pretty cool, changes can be rolled back :-p
00:08:02 <dons> and one way to do that is to ensure lots of high quality libs, so more projects are produced, and more experts exist.
00:08:43 <glguy> Galois hosts darcs.h.o among others too
00:09:04 <newsham> glguy: i just think its odd that you have a company paying lot of attention, time and money to providing a high assurance implementation, and then using a relatively small library to do web fetches, one of the most dangerous parts of the process in an unproven library written in an unsafe language.
00:09:09 <newsham> irony, no?
00:09:21 <newsham> btw, I break softwares for money.
00:09:54 <glguy> newsham: well... you seem too assume that *everything* has to be high assurance
00:10:16 <glguy> that's insane. you have to segment things
00:10:16 <newsham> glguy: no, and thats a good point.
00:10:41 <newsham> but the less things that are unproven, the better.
00:10:58 <glguy> it is not necessarily easier to prove a haskell program correct than a c one
00:11:08 <Pseudonym> I wouldn't call libcurl unproven.
00:11:17 <Pseudonym> Unproven mathematically, perhaps.
00:11:22 <Pseudonym> But it's really well-tested.
00:11:22 <newsham> just takes a hard to notice off by one in some network processing code to ruin your day and allow arbitrary remote code execution.
00:11:35 <glguy> when the haskell and c programs are designed to be correct
00:11:48 <newsham> pseudo: yah.  and in fairness libcurl seems a lot better than wget, for example.
00:12:30 <newsham> anyway, I just find it ironic.  I hope I didnt offend the project you're working on. :\
00:12:43 <newsham> (if so, I apologize)
00:13:00 <glguy> nope, its just a matter of not being able to explain better to you
00:13:04 <glguy> no ones fault
00:13:09 <newsham> *nod*
00:14:12 <newsham> so with galois sucking up haskell programmers faster than google hires phds, when can we expect world domination?
00:14:29 <Olathe> Tomorrow at three.
00:14:42 <glguy> world domination plans are also not public ;)
00:14:55 <mlh> around afternoon tea time
00:15:34 <glguy> galois hires lots of phds too
00:15:45 <glguy> (not me tho)
00:16:50 <newsham> haskellprogrammers not subset phds not subset haskellprogrammers
00:17:31 <newsham> do you guys use proof assistants?  if so which ones?  any use of any of the programmatica tools?
00:17:56 <newsham> i've been trying to read up on some of this stuff in my spare time (kinda as a hobbyist)
00:18:12 <gchpaco> I can't say as I've ever found them useful, but I am looking into theorem proving as a utility function.
00:18:27 <gchpaco> My favorite is metamath, but that's not a proof assistant per se.
00:18:47 <Korollary> I dabbled in Coq
00:26:22 <ivanm> I'm looking at wanting to learn/use a concurrent functional language for a scientific computing project... any particular suggestions of language/topic/etc?
00:26:43 <gchpaco> You should look at Erlang.
00:26:45 <araujo> hello
00:26:53 <araujo> what is a good synonym for 'module'?
00:27:20 <glguy> Erlang doesn't have a leg up on Haskell in terms of concurrency so much as dynamic code reloading
00:27:26 <gchpaco> Haskell is very nice, but Erlang was built around the idea of lightweight concurrency.
00:27:36 <gchpaco> araujo: unit?
00:28:07 <glguy> Haskell's forkIO creates lightweight green threads
00:28:55 <newsham> http://research.microsoft.com/%7Esimonpj/papers/stm/#beautiful
00:29:04 <gchpaco> glguy: That's part of what makes Erlang interesting, but also the communication and shared memory model is particularly well executed, and the standard library is built around the idea of it.
00:29:36 <dons> gchpaco: haskell was built around lightweight concurrency too, and its faster :)
00:29:54 <dons> ivanm: what kind of scientific computing?
00:30:06 <Korollary> Scientific computing typically requires lotsa speed
00:30:31 <dons> yeah, so that rules erlang out. you might run cluster nodes of combined C/Haskell pieces, though, for example.
00:30:47 <ivanm> dons: pretty much anything,,, its a 4th year scientific computing course (under maths), and I can pretty much pick my project (the course is basically just doing this project)
00:30:49 <newsham> does haskell have a library of concurrency tools like barriers?
00:30:57 <ivanm> I have been looking at erlang...
00:31:00 <dons> yeah, see Control.Concurrent
00:31:15 <dons> ivanm: so, what, matrix processing? can you be more specific?
00:31:27 <dons> for a course, you could use either language. the goal is to learn stuff
00:31:43 <Pseudonym> newsham: What would you need barriers for?
00:31:46 <Pseudonym> In Haskell, I mean.
00:31:50 <dons> if its multicore scientic work, i'd go with haskell, if it was cluster, less-compute-intesnive, distributed systems, i'd look at erlang
00:31:56 <Korollary> There's also Concurrent ML and some lisp variants like Termite, etc.
00:32:12 <ivanm> pretty much anything, though I was thinking of something like simulating an ants nest (so 1 thread per ant or something) or something along those lines, probably more simulation rather than computation
00:32:52 <ivanm> and it'd be just on my laptop, I just want to muck around with something concurrent (the supercomputers only have fortran and C, AFAIK)
00:33:10 <newsham> pseudo: say you're computing on a grid to get the next iteration, you need all yoru thread to do their bit for that grid, and then wait till all are done before moving to the next grid
00:33:13 <dons> if its very thread heavy, then yes, haskell or erlang are the main choices. since you're not even using smp, then hmm, it probably comes down to data structures/speed/
00:33:16 <gchpaco> Some sort of lightweight concurrency model would suit you well, then.  Termite uses Erlang's model for concurrency.
00:33:38 <ivanm> speed isn't my concern/interest, more on learning how to do something concurrently
00:33:45 <gchpaco> I don't think Concurrent ML is as lightweight.
00:33:56 <dons> oh, then maybe you just want a number of different thread abstractions to try out, ivanm ?
00:33:57 <Pseudonym> newsham: Ah.  That's a networking problem.
00:34:04 <ivanm> gchpaco: termite? where can I find it (don't recall seeing it on wikipedia's concurrent programming page...)
00:34:07 <Pseudonym> I thought you were referring to, like, phtreads barriers.
00:34:12 <ivanm> dons: maybe
00:34:14 <newsham> dons: I dont see barrier in Control.Concurrent, but i see a paper that builds them w/ those primitives
00:34:20 <newsham> pseudo: networking?
00:34:23 <dons> so not just say, message passing, but also transactoins, channels, parallel arrays, implicit parallelism that kind of thing
00:34:25 <gchpaco> ivanm: It's a Gambit thing.  Lemme poke around.
00:34:44 <Pseudonym> You're talking about "nodes".
00:34:55 <newsham> pseudo: i mean like a "2d grid" of data, not like a grid of machines
00:34:56 <Pseudonym> In Haskell, to implement that, I'd use something like a Concurrent.Channel.
00:35:08 <dons> ivanm: i'd say then go with haskell, if you're looking to get a feel for concurrent/parallel programming, and a want a range of different abstractions
00:35:09 <newsham> ie. a weather simulation where you have a large array of cells
00:35:11 <Pseudonym> Wait for messages, and when all have reported, go on.
00:35:29 <gchpaco> ivanm: You may find http://pipes.yahoo.com/pipes/pipe.info?_id=4FoSy63t2xGeoiqtCB2yXQ useful if you're interested in Termite.
00:35:31 <lambdabot> Title: Pipes: gambit/termite
00:35:53 <ivanm> dons: OK, I just liked the concept of erlangs light threading + dynamic reloading... so is concurrent in the standard ghc package?
00:36:14 <dons> yeah, see the different libraries, and abstractions, here, http://haskell.org/haskellwiki/Applications_and_libraries/Concurrency_and_parallelism
00:36:17 <lambdabot> Title: Applications and libraries/Concurrency and parallelism - HaskellWiki, http://tinyurl.com/2u95za
00:36:32 <gchpaco> To my knowledge Haskell does not do dynamic reloading.
00:36:38 <dons> sure it does.
00:36:44 <dons> > 1+2 -- how do you think this works? :)
00:36:46 <lambdabot>  3
00:36:49 <glguy> everything I've seen about Erlang has shown that it's strengths are fault tolerance and the ability to reload code on a running system, not performance or language features
00:37:04 * ivanm thought the dynamic loading stuff in erlang worked because of its VM...
00:37:17 <dons> right. so if its not for a big distributed system -- but rather learning about concurrency -- there's no obvious reason to restrict to erlangs model.
00:37:27 <ivanm> glguy: yeah, reading through this erlang book I've borrowed, I keep wishing it had Haskell syntax ;-)
00:37:33 <dons> you want a language with good support for a range of abstractions.
00:37:39 <ivanm> *nod*
00:39:02 <ivanm> gchpaco: is this the gambit you were talking about? http://en.wikipedia.org/wiki/Gambit_%28Scheme_implementation%29
00:39:03 <lambdabot> Title: Gambit (Scheme implementation) - Wikipedia, the free encyclopedia
00:39:10 <gchpaco> ivanm: Yup.
00:39:10 <glguy> Graham Hutton is visiting Galois now, he said that he tells his students that Haskell is like the Formula-1 car of programming languages. Most people don't get to drive them ,but they are on the bleeding edge of technology and advances from them trickle down to the regular cars
00:39:24 <ivanm> heh
00:39:30 <glguy> (amazingly enough they don't just all jump at the chance to learn Haskell)
00:39:45 <newsham> glguy: and no ABS?
00:39:49 <glguy> he said then they shut the door and teach them monads
00:39:49 <newsham> ;-)
00:40:07 <glguy> newsham: maybe because its snowy there? ;)
00:40:11 <ivanm> why shut the door?
00:40:16 <glguy> so they don't run
00:40:20 <glguy> I imagine he was joking
00:40:21 <newsham> arent formula-1 doors welded shut?
00:40:26 <newsham> (do they have doors?
00:40:39 <glguy> I think you just "get in"
00:40:45 <newsham> for added effect he should put his helmet on before the lecture
00:40:49 <slava> lol
00:41:46 <glguy> he could do one of those zefrank intros
00:42:07 <glguy> hey sportsracers, this is the Haskell show with Graham
00:42:13 <Olathe> Heheh
00:43:06 <newsham> so what is the metaphorical burning wreckage?
00:43:30 <glguy> getting kick banned from #haskell?
00:43:43 * glguy sets his new default kick message
00:43:49 <matthew-_> hey, I was thinking. You know how in the language shootout, there are certain issues that stops Haskell doing as well as it should? Eg allocating memory for the tree searches etc? Well why not set up an alternative that has no such restrictions?
00:43:53 <mgsloan> tis funny how the view of size of function defs change when you go to haskell
00:44:13 <ivanm> dons: so how does haskell support dynamic reloading?
00:44:18 <mgsloan> well, the treatement of size that is.  in C++ a 20 line function is measly.  In haskell it's huge
00:44:25 <glguy> matthew-_: that's brilliant ;) someone should have thought of that
00:44:46 <matthew-_> glguy: I'm well known for thinking outside the box like that ;)
00:44:56 <newsham> C and C++ functions tend to be a lot more sparse on the screen as well
00:45:03 <newsham> as compared to haskell or ocaml or lisp or scheme
00:45:11 <glguy> Haskell functions tend to be pretty dense horizontally also
00:45:15 <mgsloan> I guess... mine get pretty damn dense
00:45:24 <glguy> f (g x) $ a $ b . c =<< yo
00:45:35 <ivanm> mgsloan: as in you have to be dense to write something like that? :p
00:45:38 <mgsloan> dense syntactically not semantically ;)
00:45:41 <mgsloan> hah
00:45:43 <ivanm> heh
00:46:05 <glguy> but I think that by allowing you to fit more functions on the screen at one time
00:46:21 <newsham> i wrote some C for the icfp and even though i used some nonstandard layout to keep code short it was still a bit spacious compared with haskell code
00:46:26 <glguy> and by making it so easy to define more functions
00:46:37 <glguy> it naturally follows that people write shorter functions
00:46:38 <newsham> (ie. a lot of short case arms I put on a single line, I defined some small single-line functions as well)
00:46:44 <mgsloan> i probably average around 60-70 chars per line in this one function..
00:46:56 <glguy> and aren't as afraid to use them more liberally
00:47:02 <mgsloan> yeah
00:47:04 <glguy> (That was rather circular, but there is something to it I think)
00:47:06 <newsham> msgloan: in a C program?  souunds like something's wrong :)
00:47:27 <gchpaco> It's very difficult to get denser than Forth code.
00:47:36 <mgsloan> the other thing about the liberty is that you know it won't be horribly inefficient if you have loads of functions, and higher order functions and things
00:48:07 <mgsloan> newsham - heh, perhaps - I've written about 300 lines without compiling..
00:48:08 <newsham> I found the C to be lots of fun, its been a while I guess.
00:48:18 <newsham> ... as long as I can avoid memory management ;-)
00:48:44 <newsham> I think I wrote all of the rna renderer start to finish without compiling it till it was done
00:48:52 <newsham> but then again its not a complex program
00:49:12 <newsham> http://www.thenewsh.com/%7Enewsham/icfp/bmap.c
00:49:34 <mgsloan> gchpaco: APL :)
00:49:42 <glguy> ?seen pjd
00:49:42 <lambdabot> pjd is in #haskell. I last heard pjd speak 2h 26m 52s ago.
00:50:10 <gchpaco> mgsloan: Have you ever seen J code?  It's even worse.
00:50:19 <glguy> *better*
00:50:59 <Pseudonym> Must away.  Nytol
00:52:40 <mgsloan> gchpaco - I'm afraid I haven't.  I don't actually know APL, btw
00:52:55 <mgsloan> just know what it looks like, and the basic computational idea :P
00:52:58 <glguy> ?karma
00:52:59 <lambdabot> You have a karma of 52
00:53:08 <mgsloan> ?karma
00:53:08 <lambdabot> You have a karma of 0
00:53:09 <mgsloan> :(
00:53:11 <mgsloan> ;P
00:53:59 <gchpaco> mgsloan: It's a very elegant language in many ways.  J was trying to be APL in ASCII with some additional higher order operations, and did a bunch of stupid stuff like <. being different from < being different from <: (and when I say different, I mean one of them was a total order, another gave the minimum and I forget what the third was)
00:54:28 <mgsloan> ah :/
00:54:44 <psykotic> and then there's k :)
00:54:59 <glguy> which is a minimalistic, commercial version of J?
00:55:25 <gchpaco> I think so.
00:55:35 <lucca> and then there's lazy-k
00:56:29 <mgsloan> someone should implement a J DSL in haskell
00:56:38 <gchpaco> As a road-not-followed thing it's kind of interesting but my skin crawls off and hides whenever I actually see it.
00:56:58 <mgsloan> might take some TH to do properly
00:57:11 <newsham> but can lazy-k do lolcode?
00:57:37 <mgsloan> I wonder if anyone ever wrote an APL interpreter in APL
00:58:22 <gchpaco> I know they did J in J but no version of APL I've ever seen was exactly "with it" as far as I/O went.
00:58:50 <mgsloan> well, you don't need too much I/O
00:58:51 <glguy> J in J? I think that the word for that is "dedication"
00:58:58 <mgsloan> :)
00:58:59 <slava> heh
00:59:30 <gchpaco> Or perhaps "insanity"
00:59:51 <Korollary> or prison
00:59:52 <mgsloan> probably used a metacompiler
01:04:02 <glguy> grauenwolf's head a splode (I'm reading the comments on the article about currying /= partial application)
01:04:26 <Cale> haha
01:05:39 <glguy> I wonder if a person like him can look back and list "added thousands of ignorant comments to a social bookmarking site" on his life accomplishments..
01:06:14 <Korollary> glguy: I just decided not to reply to his "default print out" suggestion
01:06:48 <glguy> and I can't see why Sun or Microsoft would pay him to bad mouth any developments in programming language design when they fund research in things like scala and f#
01:06:54 <glguy> (and Haskell of course)
01:07:06 <Korollary> Sun or MS would pay him for anything?
01:07:10 <glguy> someone has to
01:07:18 <slava> nobody is paying grauenwolf
01:07:18 <newsham> ms has many tentacles
01:07:19 <glguy> I was trying to think of a generally malicious large corp
01:07:30 <slava> he's just a moron
01:07:30 <glguy> that could absorb the cost
01:07:34 <Korollary> MS can be malicious but they're not dumb
01:07:37 <glguy> he's still alive, so he must be eating
01:07:59 <newsham> korllary: zune?
01:08:02 <Korollary> I'm thinking of your Initech with synergy
01:08:13 <glguy> therefore he can afford the batteries in his walkman to pay the "breathe in breathe out" tape
01:08:19 <Korollary> newsham: nothing dumb about regular failures
01:08:41 <glguy> he can't have a job... he spends all day writing those comments
01:09:04 <Korollary> For every cool product ideas out there, there are 10 product managers totally out of touch.
01:09:30 <glguy> it would appear that he comments roughly on average 2 times an hour
01:09:50 <slava> "I have to admit I always get a bit nervious when people start talking about mathematical theory as a basis of langauge design. It seems to me that too many compromises are made to make the language fit the math when really the math should be developed to fit the langauge."
01:10:20 <Korollary> That's where Turing fucked up, too.
01:10:29 <glguy> I don't understand why you would not only admit that that makes you nervous, but that you don't understand its effect on langauges
01:10:30 <Nopik> hi
01:10:43 <Korollary> My personal fav is qwe1234
01:10:49 <Korollary> That guy is going for a record
01:11:03 <mgsloan> haha
01:11:06 <glguy> I think that qwe1234 is employed by reddit itself
01:11:13 <glguy> and they use him to troll up interest in their site
01:11:38 <Korollary> I will sue their asses for Zoloft reimbursement.
01:12:29 <Korollary> Ever read artima.com? They are hilarious too
01:13:15 <Cale> heh, yeah
01:14:04 <glguy> did the |< < > >| buttons on xkcd change recently?
01:15:05 <Cale> xprogramming.com is also pretty hilarious
01:15:35 <dons> yeah, grauenwolf could have learnt /epigram/ in the time spent commenting on reddit
01:15:46 <glguy> lol, right
01:16:42 <glguy> I'd like to see an example that he's learned anything beyond how to program in new versions of VB
01:16:43 <Cale> He wrote like 5 articles in which he basically failed to write a sudoku solver.
01:16:50 <slava> url?
01:16:52 <glguy> were those the TDD ones?
01:17:02 <Cale> yeah
01:17:05 <Korollary> I doubt some commenters could learn anything in any amount of time.
01:17:17 <glguy> those were pretty bad
01:17:31 <Cale> slava: they're linked from http://www.xprogramming.com/xpmag/index.htm (just search the page for 'sudoku')
01:17:33 <lambdabot> Title: XP Magazine Index
01:17:53 <slava> 'ron jeffries'?
01:18:10 <matthew-_> this is why I don't read such sights. reddit, /., dailywtf etc etc, they're all just demonstrating the depression condition of man kind
01:18:24 <slava> are you sur ethis is grauenwolf?
01:18:25 * matthew-_ kicks himself. sites. not sights.
01:18:26 <slava> its ruby code
01:18:40 <glguy> dailywtf is particularly bad in the comments sections
01:18:54 <Cale> slava: that's not grauenwolf
01:18:56 <glguy> people missing the wtf, coming up with *awesome* work arounds
01:19:12 <Korollary> glguy: that is where dailywtf shines. Unfiltered wtf!
01:19:22 <Cale> slava: It's Ron Jeffries
01:19:30 <slava> who is that
01:19:52 <gchpaco> XP luminary.  I ran into him on the C3 Wiki way back in the day.
01:20:00 <dons> another interesting icfp post, http://stereotype441.livejournal.com/45150.html
01:20:01 <glguy> I tried visiting dwtf... it seemed to actually make me angry... I had to stop
01:20:01 <lambdabot> Title: stereotype441: ICFP: the big post.
01:20:28 <Nopik> Nopik: test
01:20:34 <gchpaco> dwtf is one of those 100% reliable ways of increasing your blood pressure.
01:20:41 <matthew-_> glguy: yeah, unchecked stupidity makes me really enraged. I can't deal with it well at all
01:21:23 <bartw_> c3 wiki ? i thought it was c2 :)
01:21:31 <dons> Cale, interesting team #28 also used some hakell
01:21:37 <hpaste>  desp pasted "glob" at http://hpaste.org/1873
01:21:37 <glguy> that xprogramming.com has a blurb at the top: "How good do you want to be, and when? Let Ron Jeffries, experienced author, trainer, practioner, coach, help your Agile team get to the next level! Bring your project in on time, on budget, fit for purpose!"
01:21:45 <desp> guys
01:21:48 <dons> hehe
01:21:51 <bartw_> clearly i need to blog my icfp results too ;p
01:21:52 <gchpaco> bartw: Could well be.
01:21:55 <gchpaco> Benn a while.
01:21:57 <slava> glguy: as long as said project doesn't involve sudoku solving?
01:22:02 <desp> dons: what do you think of this globbing function?
01:22:02 <glguy> slava: sshhh
01:22:09 <Cale> glguy: just like his sudoku solver :)
01:22:24 <Cale> hehe
01:22:24 <Korollary> Ouch
01:22:29 <glguy> desp: unless you are doing it as an exercise, its been done and is in the MissingH library
01:22:42 <desp> glguy: arg?
01:22:50 <glguy> oh
01:22:56 <glguy> you are talking about a different glob function
01:23:07 <desp> arg.
01:23:10 <glguy> or I've got crossed wires :)
01:23:21 <desp> what's the other glob function about?
01:23:35 <glguy> file path wildcards
01:23:54 <desp> this could possibly be called coalesce
01:23:55 <slava> OH
01:24:19 <matthew-_> desp: didn't bos announce something similar on the haskell@ recently?
01:24:34 <glguy> desp: do you know about $!
01:24:36 <desp> matthew-_: are you talking about file paths?
01:24:40 <matthew-_> yes
01:24:51 <dons> desp, i think , do some statistics, work out what the magic values are, don't like those `seq`s otherwise, probably ok
01:24:53 * matthew-_ reads up, and shuts up
01:25:00 <dons> can you avoid the reverse with a dlist instead?
01:25:17 <slava> i just figured something out.
01:25:20 <desp> @whatis dlist
01:25:21 <lambdabot> http://www.cse.unsw.edu.au/~dons/dlist.html
01:25:32 <desp> @botsnack
01:25:32 <lambdabot> :)
01:25:48 <dons> desp, just a trick to do quick append. you'll want to benchmark though, to really work out what is best
01:25:58 <mgsloan> grauenwolf moping about his state - http://programming.reddit.com/info/2911c/comments/c297uy
01:25:59 <lambdabot> Title: Why getter and setter methods are evil (reddit.com)
01:26:15 <desp> I will; why don't you like those seqs?
01:26:34 <dons> oh that grauenwolf. will he ever learn? :)
01:26:49 <dons> desp: $! or ! patterns would be better. they obscure the algorithm
01:26:54 <glguy> when I brought him up, I didn't figure that Cale would make me think even les sof him
01:27:30 <glguy> I was just planning to vent :)
01:28:08 <Korollary> You elitist bastards.
01:29:00 <glguy>  ?remember Korollary You elitist bastards.
01:29:16 <Cale> haha
01:29:21 <glguy> :0)
01:29:33 <Cale> I don't think it picked that command up though, due to the space :)
01:29:33 <slava> one day i'll write an application or library named 'grauenwolf'
01:29:38 <Korollary> @quote bastard
01:29:38 <lambdabot> No quotes match. Take a stress pill and think things over.
01:29:39 <slava> it seems like such a great name
01:29:42 <glguy> Cale: that was actually intentional :)
01:29:58 <Korollary> I will name a CPP macro after him.
01:30:02 <desp> glguy: I do know about $!, just have no idea how to fit it in there
01:30:27 <glguy> example:
01:30:28 <glguy> zss' `seq` loop xs 0 [] zss' where zss' = ys : zss
01:30:38 <glguy> loop xs 0 [] $! ys : zss
01:31:03 <hpaste>  desp annotated "glob" with "equivalent?" at http://hpaste.org/1873#a1
01:31:28 <glguy> desp: did you know that calling seq on a list only forces the first (:) to be evaluated?
01:31:31 <desp> uh, ignore the preprocessor stuff
01:32:01 <desp> hrm
01:33:50 <glguy> "
01:34:00 <glguy> This image has been appropriated from concepts of the wealthy artisans to feed the artistically poor. In all likelihood, someone might be pissed. Good for them, since Uncyclopedia claims the fair use policy.
01:34:53 <Korollary> That encourages drunken behavior.
01:35:12 <slava> this must be the first time i've ever maxed out all four cpus
01:35:33 <dons> slava: oh?
01:35:56 <dons> i happily thrashed a 16 core machine using 8 simultaneous jhc builds. that was painful
01:36:21 <Korollary> You could probably smell the electricity
01:36:36 <slava> $ uptime
01:36:36 <slava>  4:35  up 3 days,  3:33, 19 users, load averages: 12.38 8.40 4.88
01:36:41 <dons> the room got very hot
01:37:00 <dons> cool. go slava! :)
01:37:01 <Korollary> 19 users on your PC?
01:37:03 <slava> dons: the g5 is making a hell of a lot of noise... it has 9 fans... usually only one or two are running
01:37:18 <dons> huh. 9 fans?
01:37:24 <slava> yup, and liquid cooling
01:37:34 <dons> our giant 16 core thingy has 6 iirc. it sounds like a jet engine though
01:37:41 <dons> we lock it in its own office
01:37:44 <slava> even the 8 core mac pros don't need liquid cooling
01:37:48 <slava> what are the cores? x86?
01:38:19 <roconnor> @type asType
01:38:21 <lambdabot> Not in scope: `asType'
01:38:23 <dons> the original plan was to sit it on my desk. that didn't last long
01:38:26 <dons> amd64s
01:38:31 <dons> 8 cpu, dual core
01:38:32 <glguy> asTypeOf
01:38:32 <roconnor> @hoogle type
01:38:33 <lambdabot> Prelude.type :: keyword
01:38:33 <lambdabot> Network.Socket.Type :: SocketOption
01:38:33 <lambdabot> Language.Haskell.TH.Type :: data Type
01:38:35 <slava> dons: are you using it to run haskell code?
01:38:38 <roconnor> @type asTypeOf
01:38:40 <lambdabot> forall a. a -> a -> a
01:38:45 <dons> yeah, parallel arrays
01:38:53 <slava> how well does it scale?
01:38:56 <slava> any problems with gc?
01:39:06 <dons> gc is more of an issue, but seems to be scaling well so far
01:39:15 <dons> you have to get the linux kernel to do thread affinity right though
01:39:38 <dons> there's a workshop paper with nice scaling graphs. let me see..
01:40:13 <dons> http://www.cse.unsw.edu.au/~chak/papers/CLPKM06.html
01:40:13 <lambdabot> Title: Research Papers of Manuel Chakravarty
01:40:32 <slava> dons: do you know of any sub-turing languages which are not decidable?
01:40:41 <dons> hmm
01:40:46 <slava> do any exist?
01:41:13 <dons> i can't think of one off the top of my head.
01:41:39 <slava> my compiler applies certain rewrite rules to the program and i've found that these rules can express non-terminating computations
01:41:42 <dons> so is factor going multicore now?
01:41:47 <slava> not for a while
01:42:01 <dons> right, so there's lots of research on confluence and termination of term rewriting systems
01:42:44 <dons> ghc's type system rewriting stuff, like associated types, goes to great lengths to terminate (with rules from term rewriting which say exactly what must hold to ensure termination)
01:43:01 <slava> what is -fundecidable-instances?
01:43:36 <dons> yeah, that's a hack to avoid one termiation condition, iirc
01:44:04 <dons> as long as you provide a default instance to fall back on, but you can introduce non-termination in the type check that way
01:44:21 <dons> " Termination is ensured by having
01:44:21 <dons> a fixed-depth recursion stack. If you exceed the stack depth you get a sort of backtrace, and the
01:44:24 <dons> opportunity to increase the stack depth with -fcontext-stackN"
01:44:34 <dons> fun fun typecheck fun
01:45:02 <slava> ok, that _is_ a hack :)
01:45:32 <Korollary> Well, in a sense if you restrict memory, you have a sub-turing language which can loop infinitely.
01:46:08 <slava> but is there a decision procedure?
01:46:18 <slava> even if it requires 2^2^n memory?
01:46:37 <slava> if you have finite memory, there are only finitely many states, right?
01:46:48 <opqdonut> yep
01:49:16 <Korollary> That's hard question
01:50:05 <hpaste>  roconnor annotated "Ropes version 0.02" with "attempt at passing parameters using phantom types" at http://hpaste.org/1869#a1
01:50:12 <Korollary> You wanna read on term rewriting systems and properties which make them normalizing.
01:50:54 <roconnor> Is that the right way to use phantom types to pass parameters?
02:02:00 <psykotic> roconnor, typically. and to call chunkSize you would do chunkSize (undefined :: DefaultSize), for example.
02:02:31 <psykotic> oh wait, your argument to chunkSize isn't a.
02:03:47 <roconnor> append x@(Rope r0) (Rope r1)
02:03:47 <roconnor>   | F.null r0 = Rope r1
02:03:47 <roconnor>   | F.null r1 = Rope r0
02:03:47 <roconnor>   | long x size = Rope $ r0 >< r1
02:03:47 <roconnor>   | otherwise = Rope $ (left |> middle) >< right
02:04:23 <roconnor> long x size = (chunkSize x < size)
02:04:47 <roconnor> I couldn't see a way to get access to an element of type Default Size
02:04:57 <psykotic> use undefined
02:04:59 <dons> `The Haskell talk is packed, so I start along the wall, moving to a desk at the break' -- one blog about SPJs talk
02:05:06 <roconnor> psykotic: yeah, but I need to get to the type.
02:05:25 <roconnor> oh way can I just say (undefined :: a) for a type variable?
02:05:28 <psykotic> yes
02:05:30 <psykotic> (i think)
02:05:32 <roconnor> doh
02:05:55 <psykotic> and why does it work? because your argument in which that is done has that parameter qualified over your type class.
02:06:04 <psykotic> so the dictionary that's needed to make the right chunkSize call is passed implicitly
02:06:16 <Adamant> OS platform of choice in here?
02:06:31 <Saizan> -fscoped-type-variables?
02:06:53 <Adamant> (sorry for the OT, but I am interested in seeing what the Haskell community runs)
02:07:01 <Adamant> OS X and Linux here.
02:07:19 <dons> linux, bsd, macs mostly
02:07:26 <doublef> Adamant: want a flame war;)? FreeBSD-CURRENT here, winxp there...
02:07:26 <ChilliX> Adamant: same
02:07:38 <roconnor> psykotic:
02:07:38 <roconnor>     Ambiguous type variable `a' in the constraint:
02:07:38 <roconnor>       `ChunkSize a' arising from use of `long' at Rope.hs:67:4-27
02:07:38 <roconnor>     Probable fix: add a type signature that fixes these type variable(s)
02:07:46 <Adamant> doublef, I assume people on #haskell are more mature than that
02:07:53 <roconnor> (undefined :: a) doesn't seem to work
02:08:01 <Adamant> I wouldn't ask this on ##c or ##c++
02:08:04 <ChilliX> Adamant: developers surely have got a unix bias
02:08:08 <psykotic> roconnor, let me give you a complete working example, then. hang on.
02:08:08 <Saizan> ?poll-result OperatingSystem
02:08:08 <lambdabot> Poll results for OperatingSystem (Open): Mandriva=1, Zenwalk=1, MacOS=1, House=1, TheWoWIsNowVista=0, Windows=0, DragonflyBSD=0, NetBSD=1, OpenBSD=1, Gentoo=5, Debian=7, Ubuntu=6, FreeBSD=2
02:08:23 <roconnor> doublef: Haskell is just as slow on all systems
02:08:46 <ChilliX> roconnor: hahaha
02:09:39 <mgsloan> the Con Koliveras thing has kinda put me off linux a bit
02:09:54 <doublef> ?vote OperatingSystem FreeBSD
02:09:54 <lambdabot> voted on "FreeBSD"
02:10:01 <doublef> :)
02:10:05 <Cale> Con Koliveras?
02:10:07 <roconnor> doublef: we will build our own OS!
02:10:10 <roconnor> @where House
02:10:10 <lambdabot> http://www.cse.ogi.edu/~hallgren/House/
02:10:32 <mgsloan> Con Kolivas I mean
02:10:59 <Adamant> ?vote OperatingSystem MacOS
02:10:59 <lambdabot> voted on "MacOS"
02:11:00 <Cale> mgsloan: Some kernel patch?
02:11:07 <Cale> ?vote OperatingSystem Ubuntu
02:11:07 <lambdabot> voted on "Ubuntu"
02:11:22 <psykotic> roconnor, hmm, i get the same problem. weird, because i would expect it to be possible: since there is a qualification of ChunkSize a, it should pass in the dictionary (implicitly) needed to make the chunkSize call.
02:11:22 <Saizan> ?vote OperatingSystem Debian
02:11:23 <lambdabot> voted on "Debian"
02:11:28 <roconnor> ?vote OperatingSystem OS/2
02:11:28 <lambdabot> "OS/2" is not currently a candidate in this poll
02:11:29 <psykotic> dons, any help?
02:11:32 <Adamant> :)
02:11:36 <doublef> ;)
02:11:40 <mgsloan> well, he worked for a few years, creating and maintaining a patchset replacing the CPU scheduler with something much better
02:11:40 <bartw_> well you can't expect to go up againt ingo
02:11:47 <roconnor> psykotic: that's okay, what I had before worked :)
02:11:54 <psykotic> roconnor, well, i'm curious. :)
02:12:05 <roconnor> I have to run, let me know how it turns out
02:12:05 <psykotic> obviously there's a gap in my understanding here.
02:12:07 <psykotic> later.
02:12:10 <Adamant> you can expect to go up against Ingo and produce something better, you just can't expect to win.
02:12:10 <mgsloan> gained a devout following among the performance -seeking
02:12:12 <dons> psykotic: hmm?
02:12:16 <bartw_> gettng your patches in is partly about being frinds with the dictator
02:12:27 <mgsloan> yep, which he wasn't
02:12:31 <psykotic> dons: let me paste
02:12:51 <hpaste>  psykotic pasted "the phantom menace" at http://hpaste.org/1874
02:12:55 <Adamant> look at the Execshield nonsense vs. PaX
02:13:03 <mgsloan> some guy that was friends with the dictator basically just wrote his own using the same basic ideas, and that got stuck in
02:13:05 <therp> mgsloan: if LKML would only get 10% of the friendliness of #haskell, world would be great. CK is a good (bad) example for that
02:13:18 <psykotic> dons: based on a question of roconnor--why won't that work? it complains about the 'a' in undefined :: a being ambiguous.
02:13:21 <ChilliX> ?vote OperatingSystem MacOS
02:13:21 <lambdabot> voted on "MacOS"
02:13:31 <bartw_> well ingo does make nice things
02:13:33 <psykotic> dons: it seems like it should be able to select the right instance of chunkSize to call based on the passed in dictionary.
02:13:43 <mgsloan> therp - yeah, they could use it much more too
02:13:57 <dons> f :: forall a. ChunkSize a => ByteStringWith a -> Int
02:14:14 <jbauman> mgsloan: i have to admit i like the elegant simplicity of CFS more
02:14:15 <psykotic> wow, it worked! :)
02:14:19 <mgsloan> If Linus was truely a benevolent dictator, he'd fix it
02:14:28 <dons> f (bs :: ByteStringWith a) = chunkSize (undefined :: a)
02:14:28 <psykotic> dons: oh, because otherwise it isn't lexically visible?
02:14:31 <dons>  is another option
02:14:49 <dons> yeah, I'm not sure what the reason is. ChilliX might know?
02:14:50 <bartw_> so, where do i sign up for icfp the conference ?
02:14:55 <dons> some funny thing about lexically scoped type variables
02:15:03 <mgsloan> jbauman - that may very well be.  I do think its still a bit of a shame though
02:15:22 <Saizan> psykotic: you need forall a. in the f signature to have it in scope
02:15:27 <psykotic> Saizan, i know that now.
02:15:33 <psykotic> Saizan, i'm just curious why it isn't the default.
02:15:36 <mgsloan> I can't imagine that con's code was exactly beautiful.  He was pretty new to coding overall :P
02:15:40 <psykotic> h98 back compat?
02:15:43 <ChilliX> dons: ?
02:15:45 <therp> I promised myself 2 years ago that I will never ever do linux kernel development.
02:15:53 <therp> because of the persons involved..
02:15:57 <dons> yeah, it seems intuitive that since bindings are implicitly quantified, adding 'forall' should help the (undefined :: a)'s to magically work
02:16:21 <dons> ChilliX: oh, lexically scoped tyvars needing explict binding with 'forall' to typecheck, http://hpaste.org/1874
02:16:23 <jbauman> mgsloan: yeah, maybe staircase deadline should have been merged earlier, but CFS seems to have superseded it before it had a chance
02:16:29 <dcoutts> desp: could you help us with testing the ghc ebuild on ppc-macos and building a binary? See us in #gentoo-haskell
02:16:30 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
02:17:25 <dons> ChilliX: btw, had a good thesis write up day today. lots of progress. I think I can get this done! :)
02:17:34 <mgsloan> jbauman - yeah, it could have been merged in ages ago
02:18:42 <Saizan> dcoutts: i've darcs sent my patch for getstatusicon, but in the archives the message looks truncated, let me know if i have to resend it manually
02:18:47 <dons> psykotic: for the full story, check `7.4.10. Scoped type variables' in the ghc user's guide
02:18:51 <mgsloan> I don't know much about either system, but seems that staircase deadline could probably be developed into better things (like CFS I guess)
02:18:52 <psykotic> dons: k, thx
02:18:57 <dons> it has the rules for why you need to bind the tyvars explicitly
02:18:59 <dcoutts> Saizan: ok
02:19:38 <dcoutts> Saizan: looks fine, the sourceforge mail archives are just crap :-)
02:19:55 <Saizan> dcoutts: ok, cool :)
02:21:29 <dcoutts> Saizan: do you want to add a little demo too? partly as a test, partly as sample code for others to read
02:22:18 <dons> dcoutts: so you're not flooded out yet?
02:22:39 <dcoutts> dons: apparently the Thames has not peaked yet :-)
02:22:54 <dcoutts> dons: but no, although I live very near the river we're fine here
02:23:13 <dons> lucky. seems quite a disaster
02:23:27 <dons> ca you use your unicycle in a flood?
02:23:58 <dcoutts> hah, actually we cycled through a foot of flood water yesterday afternoon, just for fun
02:24:13 <dons> i hope your underground office doesn't flood?
02:24:56 <dcoutts> oxford didn't get the really heavy rain, just the Thames gets all the water from the badly affected areas
02:25:20 <dcoutts> so the only flooding is due to the river bursting banks, which it hasn't done much
02:25:26 <dons> mm, so a matter of how far it spreads when the banks have broken. right.
02:25:39 <dcoutts> right, the comlab will be fine
02:26:21 <profmakx> heyho, is there any haskell package that can do the usual computations on finite state automata? like power set construction, minimising and the like?
02:27:33 <dcoutts> dons: I did get trapped in a village in Gloucestershire on Friday night though :-) Was at a wedding. Bride arrived by land rover through over a meter of water and we were all cut off after the service.
02:27:43 <psykotic> profmakx, i think oleg has a lot of code for that in various places. but i wouldn't call it a "package" :)
02:27:59 <profmakx> well, then it will become one during the weekend *cough*
02:28:15 <profmakx> i really want to try rewriting the automatic groups package in haskell
02:28:33 <dcoutts> dons: so we all spent the night in the village hall (with lots of wine and cheese)
02:29:41 <kfish> dcoutts, sounds terrible
02:29:42 <Saizan> dcoutts: ok, i've converted a C demo for testing
02:30:05 <dcoutts> kfish: yeah, being trapped with that much wine is pretty difficult ;-)
02:30:20 <psykotic> it's a rough life. wine AND cheese, how barbaric
02:30:51 <mux> hmmm, wine and cheese.
02:30:56 <dcoutts> we did see lots of search and rescue helicopters buzzing around, so we knew we were rather lucky
02:30:58 <mgsloan> yeh, without computer, yeesh
02:31:22 <mux> there's nothing better than wine and cheese :-)
02:31:27 * mux <- frenchman
02:31:35 <dcoutts> heh heh :-)
02:31:41 <dons> that's dcoutts excuse for why he couldn't work on the icfp paper then: wine and cheese emergency ;)
02:31:48 <dcoutts> dons: yep :-)
02:32:13 <psykotic> mux: the main french thing i miss here (korea) is cassoulet.
02:32:26 <psykotic> mux: i have my french coworker's father ship some cans here every few months, just so i can survive.
02:32:32 <mux> psykotic: heh :-)
02:32:36 <profmakx> when it comes to alcohol i prefer bundaberg over wine any time
02:32:43 <fasta> I have a function set_bar x = modify_bar (\s -> s{bar= x}) and somewhere I do set_bar (error "don't read this") some_object. When I now ask for a part of this some_object later, the error is being called. By laziness I would expect that not to happen. Any idea how I can find why it's getting forced?
02:33:14 <dcoutts> dons: did you see this? http://news.bbc.co.uk/1/hi/uk/6914846.stm
02:33:15 <lambdabot> Title: BBC NEWS | UK | 18th Century convicts go online
02:33:49 <kfish> dcoutts, sorry to be offtopic, but did you get my iconv patches? (about 2-3 weeks ago i think, shortly after you uploaded the library)
02:34:04 <dons> oh, interesting, dcoutts.
02:34:07 <dcoutts> kfish: hmm, not sure that I did, where did you send them?
02:34:42 <kfish> dcoutts, hmm, to @worc.ox.ac.uk
02:35:03 <dcoutts> kfish: try again, I'll tell you if they turn up
02:35:22 <kfish> dcoutts, ok, will do (later, they're on my laptop at home)
02:35:29 <dcoutts> oh ok
02:35:47 <dcoutts> kfish: what were the patches for? what changes?
02:35:58 <kfish> mainly documentation from memory
02:36:17 <kfish> oh, and a demo program that works kinda like iconv(1)
02:36:46 <kfish> and perhaps a man page for that, depending on how bored i was at the time
02:42:25 <kfish> dcoutts, i found it in my outbox and resent
02:42:49 <dcoutts> thanks
02:44:55 <dcoutts> kfish: applied
02:45:00 <dcoutts> thanks :-)
02:45:03 <kfish> cheers :-)
02:46:09 <kfish> is it on hackage?
02:47:36 <kfish> hmm, igloo's got a similar binding on hackage
02:49:23 <dcoutts> kfish: yeah, I had a chat with Igloo and he was happy to have this as a replacement
02:49:33 <dcoutts> though we need to compare apis
02:49:41 <dcoutts> to make sure we're not really loosing things
02:49:49 <kfish> fair enough
02:50:21 <dcoutts> kfish: I'm pretty busy with other things, if you want to take the iconv stuff forward that'd be cool
02:51:11 <kfish> it doesn't seem to need much (ie. it works) but ok, sure
02:51:32 <kfish> i'm pretty keen to use it as i'm working with some japanese text
02:53:03 <roconnor> psykotic: I'm torn between using the forall a. thing and my origninal way
02:53:13 <roconnor> psykotic: my original way is a bit more portable.
02:53:18 <dcoutts> kfish: eg Igloo's one has a mode to ignore conversion errors, and then we should get it on hackage
02:53:29 <roconnor> psykotic: but the forall a. is a bit nicer.
02:53:33 <psykotic> roconnor, i think all practical haskell compilers support the relevant extensions. :)
02:53:37 <kfish> dcoutts, ah right, yeah i wondered about errors ;-)
02:54:02 <roconnor> psykotic: I mean, I need to use MPTC anyways
02:54:25 <roconnor> psykotic: does JHC support this forall stuff the same way GHC does?
02:54:33 <psykotic> i'm 99% sure
02:54:37 <roconnor> cool
02:56:07 <dcoutts> kfish: currently we just fail on InvalidChar, Igloo's code has two modes, one to tell GNU iconv to be more lenient on conversion errors and another to just ignore chars that could not be converted and carry on.
02:56:55 <kfish> dcoutts, ok
02:57:36 <dcoutts> kfish: though of course we also need to keep the mode where we're strict about conversion errors
02:58:21 <dcoutts> kfish: basically, take a look at Igloo's code, it's fairly comprehensive, it's just that it only works on String, not ByteString
02:58:38 <kfish> ok, noted
02:59:22 <kfish> dcoutts, any other issues you can think of?
03:00:50 <dcoutts> kfish: it could be more efficient with fixing up the boundary cases, where a sequence flows over a chunk boundary
03:01:06 <kfish> ok
03:01:14 <dcoutts> kfish: I think at the moment I just append the trailing bytes to the next chunk, but that involves copying the next chunk which is bad
03:02:12 <dcoutts> kfish: my original idea was to copy the trailing bytes plus a few bytes from the next chunk into a temp buffer
03:02:23 <dcoutts> kfish: oh, hmm wait, perhaps I did do that already
03:03:00 <kfish> heh
03:03:08 <dcoutts> kfish: mm, ok looks like I did do that optimisation :-)
03:03:35 <dcoutts> kfish: ok then, the only other thing is to be a tad more efficient with allocating tmp buffers
03:04:19 <dcoutts> kfish: we use alloca about half a dozen times on each call to iconv, we could do it just once, or even keep an arg marshaling buffer around with the iconv monad
03:04:29 <dcoutts> so we allocate it once at the beginning
03:04:46 <kfish> right
03:05:08 <dcoutts> kfish: that would make the code a tad uglier, but possibly a bit faster in the cases where we have lots of shorter chunks
03:05:26 <dcoutts> when we're reading in straight from disk we have very large chunks so it's not a problem
03:05:55 <dcoutts> but if we're writing we're more likely to have shorter chunks
03:06:19 <dcoutts> I suppose it needs measuring/profiling to see if thats worth it
03:09:07 <kfish> ok, noted
03:09:08 <Nopik> if i have monad m a, it means, that m a functions may do many things internally, but the output of computations will be always of type a ?
03:09:08 <kfish> thanks :-)
03:11:02 <Saizan> Nopik: yes, from a foo :: Monad m => m A you'll always get a "result" of type A
03:11:20 <Nopik> ok, thanks
03:11:33 <Nopik> another bit of knowledge matches its place ;p
03:11:56 <Nopik> the bad thing with monad tutorials is that once you get some grasp on them, you should re-read all tutorials again ;)
03:13:48 <Nopik> and, as far as i understand, 'behind' every monad there is (possibly complex) data structure, and monad operations just operate on that structure?
03:14:04 <roconnor> Nopik: sounds right
03:14:06 <Philippa> nearly every monad
03:14:12 <Philippa> in the case of ST and IO, you don't know
03:14:23 <pierre-> hello
03:14:30 <Nopik> yeah, compiler may internall do some tricks to implement IO
03:14:34 <roconnor> The identity monad's data structure isn't particularly complicated ;)
03:14:36 <Philippa> IO could be validly implemented by magic imps, etc etc
03:14:55 <psykotic> but that really shouldn't bother you. if you're programming against an abstract interface in an OOP language, you don't have to constantly worry about how it's implemented. you can just use it according to its specification.
03:14:57 <pierre-> is haskell.org down?
03:15:05 <Nopik> but generally my statement is true, and from teoretical point of view IO could be represented by fairly complex stucture?
03:15:42 <roconnor> @src IO
03:15:42 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
03:15:58 <Nopik> yeah
03:16:07 <psykotic> Nopik, no, because ultimately the guy typing at the keyboard would have to be modelled. RealWorld is just a "token", it doesn't really unfold to any model of the IO environment.
03:16:09 <roconnor> that's GHC's implemenation
03:16:35 <Nopik> psykotic: yes, i know.. this is what i meant by 'complex' structure :D
03:16:52 <roconnor> but as psykotic points out, the problem is just reduced to``What is RealWorld''
03:16:57 <roconnor> @src RealWorld
03:16:57 <lambdabot> Source not found. Where did you learn to type?
03:17:08 <roconnor> Welcome to the RealWorld
03:17:38 <Nopik> anyway, this is the missing bit in all of the tutorials.. once i figured out, that monad is just wrapper for some structure, all things started to be more clear ;)
03:17:49 <psykotic> Nopik, but that's actually misleading.
03:17:59 <psykotic> your understanding shouldn't hinge on there being something "real" underneath.
03:18:09 <Nopik> psykotic: you talk about IO? yes, this is very big simplification
03:18:15 <psykotic> no, not IO, in general.
03:18:22 <Nopik> psykotic: hm, why?
03:18:50 <psykotic> the notion of a monad is just an "interface" satisfying certain laws
03:19:15 <psykotic> what you're talking about is the implementation. it can be useful to know some example implementations to see how the interface could be satisfied, but as a user of the interface you don't really have to know, and thinking about the implementation details can be distracting.
03:19:24 <Nopik> yeah, ok
03:19:35 <Nopik> just most of implementations do have some structure behind ;)
03:20:12 <psykotic> right. except for a few cases, there's no magic involved.
03:20:43 <Nopik> ok, /me continues on tutorials ;)
03:20:51 <vincenz> re
03:21:11 <roconnor> @src ST
03:21:12 <lambdabot> newtype ST s a = ST (STRep s a)
03:21:23 <roconnor> @src STRep
03:21:23 <lambdabot> type STRep s a = State# s -> (# State# s, a #)
03:21:50 <roconnor> IO a = ST RealWorld a
03:26:04 <xerox>  GHC.Exts> :i RealWorld
03:26:04 <xerox> data RealWorld  -- <wired into compiler>
03:28:25 <Cale> GHC has a kinda fake implementation of IO though :)
03:33:35 <opqdonut> Cale: how so?
03:35:39 <Cale> opqdonut: RealWorld is (of course) just a tag which creates the right data dependencies so that things happen in the right order, and then the implementation just does things "unsafely".
03:35:49 <opqdonut> ah
03:35:53 <opqdonut> yeah of course
03:36:14 <vincenz> Cale: pong
03:36:47 <Cale> vincenz: hehe, now I have to remember what it was that I wanted to ask you about...
03:37:00 <vincenz> the monad
03:37:09 <vincenz> isomorphisms
03:37:13 <Cale> hehe
03:37:17 <vincenz> btw, RNAChunk == ?
03:37:27 <Cale> Seq Base
03:37:30 <vincenz> Rna -> RNA ?
03:37:32 <vincenz> oy
03:37:45 <Cale> I tried [Base] -> [Base], but it was a little slower.
03:37:56 <vincenz> alright
03:38:02 <vincenz> odd, cause we're basically just consing
03:38:36 <Cale> I implemented KMP search, but doing some profiling revealed why it didn't really have any effect
03:39:18 <Cale> template/pattern/nat all do a ton of allocation.
03:42:17 <vincenz> KMP?
03:44:30 <xerox> Knuth-Morris-Pratt
03:44:43 <xerox> clever substring search
03:45:02 <paolino> hi , how can I introduce state in this list comprehension, to calcolate the exponential step by step ?
03:45:07 <paolino>                 build ((p,e):r) = [p^ei * s| ei <- [0 .. e] , s <- build r]
03:59:20 <gmosx> hello... everyone?
03:59:41 <gmosx> which library would you suggest for Database programming? HDBC? HSQL? something else?
04:01:35 <Soft-Num> python
04:04:00 <matthew-_> gmosx: I like HaskellDB - I've used it both with HSQL and HDBC
04:04:10 <matthew-_> both work fine for me with postgres
04:04:25 <dons> cool. matthew-_++
04:04:32 <gmosx> hello matthew
04:04:41 <matthew-_> hi gmosx, dons
04:05:10 <gmosx> matthew-_: I would like to try to convert StringTemplate to haskell... as a first experiment in haskell ;-)
04:05:27 <matthew-_> but, my liking of HaskellDB is roughly proportional to my hatred of SQL as a String.
04:05:40 <matthew-_> gmosx: ok, sure.
04:05:58 <gmosx> I hope this will be relatively easy...
04:06:09 <matthew-_> gmosx: I'm sure you'll learn a lot from it. :)
04:06:32 <gmosx> there is a lot to learn... haskell seems kind of alien to me...
04:06:56 <gmosx> matthew-_: are you doing any web development with haskell?
04:07:33 <matthew-_> gmosx: I've done some, yes. hikij.wellquite.org is at the most extreme end, but does use haskelldb under the hood
04:07:49 <matthew-_> I try to stay away from doing websites as I don't find it very interesting
04:11:16 <matthew-_> gmosx: and whilst the functionality of a website is trivial, making it all "pretty" and cross-browser is really hard.
04:11:35 <gmosx> indeed...
04:11:48 <gmosx> I am researching the possibility to use haskell for the backend of a web site...
04:13:07 <matthew-_> yeah, I've not have any problems doing that.
04:13:28 <Syzygy-> Is haskell.org down?
04:13:30 <matthew-_> most websites tend to be really thin layers on top of a database. Haskell's fine for that
04:13:56 <matthew-_> Syzygy-: doesn't seem to work for me.
04:14:10 <Syzygy-> Right. Annoying.
04:14:19 <MarcWeber> Can't access haskell.org either.
04:14:29 <matthew-_> now, if only there was a google cache...
04:14:39 <matthew-_> oh wait! google's not allowed in is it?
04:15:10 <Syzygy-> ?hoogle Num a => [a] -> a
04:15:10 <lambdabot> Prelude.product :: Num a => [a] -> a
04:15:10 <lambdabot> Prelude.sum :: Num a => [a] -> a
04:15:10 <lambdabot> Prelude.head :: [a] -> a
04:15:19 <Syzygy-> product is what it's called. Right.
04:18:48 <Syzygy-> ?hoogle a -> (a,a)
04:18:49 <lambdabot> Control.Monad.RWS.execRWS :: RWS r w s a -> r -> s -> (s, w)
04:18:49 <lambdabot> Control.Monad.RWS.evalRWS :: RWS r w s a -> r -> s -> (a, w)
04:20:11 <ndm> ?djinn a -> (a,a)
04:20:12 <lambdabot> f a = (a, a)
04:20:24 <ndm> there is only one possible realisation of that type
04:20:57 <tora> @type join (,)
04:20:59 <lambdabot> forall a. a -> (a, a)
04:21:37 <opqdonut> ?pl f a = (a,a)
04:21:38 <lambdabot> f = join (,)
04:21:41 <opqdonut> there ya go :)
04:21:45 <ndm> > join (,) True
04:21:46 <lambdabot>  (True,True)
04:21:55 <ndm> @type join
04:21:57 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
04:22:01 <vincenz> ndm: reader monad
04:22:10 <ndm> vincenz: brain exploding...
04:22:17 <vincenz> (r -> (r -> a)) => (r -> a)
04:22:26 <vincenz> (,) = (a -> a -> (a,a)
04:22:29 <vincenz> so join turns this into
04:22:32 <vincenz> (a -> (a,a)0
04:22:34 <ndm> yeah, i guessed the -> Monad was cropping up, it always scares me when it does
04:22:37 <EvilTerran> realisations of a type have to be total functions, right?
04:22:48 <EvilTerran> no _|_s allowed, etc
04:22:54 <ndm> EvilTerran: from djinn, yes, since _|_ is a realisation of everything
04:23:00 <EvilTerran> i thought so =]
04:23:15 <ndm> although you can proven things like head have only _|_ as a realisation
04:23:24 <ndm> for [] lists
04:23:35 <ndm> and you can prove that error only have one realisation, namely _|_
04:24:13 <wolverian> dons, I sent you a patch for S.P.Run; if you don't get it for some reason, poke me :)
04:24:14 <EvilTerran> :t error
04:24:16 <lambdabot> forall a. [Char] -> a
04:25:43 <vincenz> ndm: the reader monad is scary cause it can popup quite subtly
04:25:56 <vincenz> there's no data-constructor to guard you against it
04:27:14 <EvilTerran> @where reader
04:27:15 <lambdabot> I know nothing about reader.
04:29:46 <matthew-_> mmm. what would people suggest for doing FSMs in Haskell?
04:30:42 <ndm> matthew-_: more details, what are you using the FSM for
04:31:01 <ndm> equations and pattern matching can be quite nice for it
04:31:15 <ndm> data States = S0 | S1 | S2
04:31:24 <ndm> then trans S0 'a' = S1
04:31:26 <ndm> etc.
04:33:12 <matthew-_> ndm: yeah, I think I need to think more before bothering you lot.
04:41:24 <wolverian> hrm, is haskell.org down? :/
04:41:31 <opqdonut> seems so
04:43:28 <matthew-_> if you're on debian, file:///usr/share/doc/ghc6-doc/html/libraries/ is likely to have the docs
04:44:08 <EvilTerran> it's resolving, and responding to ping, tho.
04:44:13 <wolverian> well, ubuntu, but good point. thanks :)
04:44:42 <MyCatVerbs> Good afternoon, #haskell.
04:46:08 <matthew-_> MyCatVerbs: damn, it is afternoon already!
04:46:11 <wolverian> oh, ouch, right. gutsy's haddock is broken so I don't have any of the haddock docs :(
04:46:28 <MyCatVerbs> matthew-_: heh, I know that feeling.
04:49:21 <roconnor> Cale: I got the impression that DNA searchs were rare in practice, and on relatively short string.
04:50:10 <Cale> roconnor: yeah
04:50:30 <Cale> roconnor: Or at least rare compared to the number of operations performed.
04:50:36 <benny99> is haskell.org down ?
04:50:50 <roconnor> good,  I never did implement KMP
04:51:20 <roconnor> ... well not last week anyways.  back in my undergraduate days ...
04:51:37 <EvilTerran> @topic-snoc "haskell.org seems to be down, EVERYBODY PANIC"
04:51:38 <lambdabot> I do not know the channel "haskell.org
04:51:39 <roconnor> Mmmm, Data Structures and Algorithms
04:51:42 <EvilTerran> meh.
04:51:49 <roconnor> Althought I think they got rid of that course at U(W)
04:51:52 <benny99> EvilTerran: yeah :O
04:52:22 <EvilTerran> on reflection, i wouldn't be able to do that anyway. permissions etc.
04:53:29 <benny99> any ideas why haskell.org is down ?
04:54:10 <Syzygy-> @topic-snoc #haskell "haskell.org seems to be down, EVERYBODY PANIC!"
04:54:10 <EvilTerran> it resolves and responds to ping, so not routing failure and not power failure.
04:54:17 <roconnor> Haskell is on summer vacation?
04:54:21 <EvilTerran> :D
04:54:30 <roconnor> It's July
04:54:44 <roconnor> Probably in Spain, or France.
04:54:51 <benny99> yeah, probably :p
04:54:53 <Nopik> if there is newtype MyMonad a b c d = { runMyMonad :: (a,b) -> (c,d) }   then can I assume, that the monad 'holds' (a,b)->(c,d) function behind and with runMyMonad m I can extract this function?
04:55:17 <roconnor> ... god I hope it's not in France.  It'll spend a steamy night with OCaml.
04:55:28 <Syzygy-> I wanna see that offspring. :P
04:55:36 <roconnor> I want Haskell to remain pure.
04:55:49 <Syzygy-> roconnor: You really think OCaml carries STDs?
04:55:51 <Nopik> roconnor: it is not in Spain.. i'm here and haskell.org do not work here either
04:55:57 <Saizan> Nopik: yes, except that you've forgotten to add a constructor
04:55:59 <MyCatVerbs> roconnor: "pure" is just pride in being inbred. Mongrelisation FTW.
04:56:08 <Nopik> Saizan: ah, yes, indeed
04:56:12 <Nopik> Saizan: thanks
04:56:20 * Nopik goes for lunch
04:56:40 <xerox> Nopik: try :t runMyMonad on GHCi
04:57:10 <benny99> is there a tutorial-list or something ?
04:57:22 <benny99> using the lambdabot?
04:58:21 * benny99 afk
04:58:40 <Philippa> MyCatVerbs: not in this case
05:00:28 <Philippa> besides, probably the single most obvious candidate feature to adopt from ML turns out to be closely related to one of Haskell's big features anyway
05:00:39 <Philippa> and as for the other... well, you've seen the arguments about record systems, no?
05:01:38 <EvilTerran> which obvious candidate feature would that be? parameterised modules?
05:05:32 <Philippa> EvilTerran: the module system as a whole
05:10:49 <MyCatVerbs> Philippa: ah. I was referring specifically to human reproduction (royal families in particular) rather than referential transparency there. :)
05:12:20 <tuxplorer> Does anyone know of any good haskell book available online in Safari or 24x7 books?
05:12:45 <tuxplorer> The search facility there is too bad..
05:12:49 <roconnor> screw modules, dependent records all the way!
05:13:03 <roconnor> ... which might be the same thing.
05:14:49 <psykotic> MyCatVerbs, we need a type system based on the family values of henry the 8th.
05:16:08 <dolio> Philippa: I've seen arguments that we need better record systems, but never arguments against.
05:16:42 <dolio> It usually seems to be "We need better record systems, like this..." vs. "Yeah, well, that'd be nice." :)
05:17:22 <psykotic> dolio, better in what ways? row polymorphism, that sort of thing?
05:17:59 <dolio> psykotic: Yeah. Stuff like that.
05:18:22 <psykotic> i admit i like the no-frills record system of haskell
05:18:55 <psykotic> in languages like ocaml with very fancy record systems, you quickly get to a point where the record system becomes a massive artifact of technology onto itself
05:18:59 <dolio> Something that's actually an extensible record system, not sugar for defining a few extra functions along with your algebraic data types.
05:19:08 <roconnor> psykotic: like being able to have two records with the same name in the fields?
05:19:33 <psykotic> roconnor, you can, as long as you rename them on import :)
05:19:40 <psykotic> (i think)
05:19:49 <roconnor> psykotic: not defined in the same module...
05:19:57 <roconnor> (i think)
05:20:10 <dolio> I should get around to seriously looking at HList to see how close it gets.
05:20:13 <psykotic> well, a lot of that sort of thing can be done with type classes
05:20:23 <roconnor> pfft
05:20:28 <psykotic> and my point is that i think i ultimately prefer pushing responsibilities to type classes rather than duplicating a lot of stuff in the record system
05:20:39 <psykotic> in ocaml you have so many different subsystems
05:20:51 <roconnor> psykotic: we don't need mdo either, we can just use mfix everywhere.
05:20:55 <psykotic> the fancy pants object system (which no one seems to use), polymorphic/extensible records, polymorphic variants, etc etc
05:21:14 <roconnor> psykotic: lets stay focused on records here.
05:21:15 <roconnor> ;)
05:21:23 <psykotic> i'm just trying to point at a phenomenon
05:21:44 <roconnor> Okay, I agree we should go crazy
05:21:58 <roconnor> I think whatever record system is added should have a syntatic translation
05:21:58 <psykotic> did you leave out a negation? :
05:22:02 <roconnor> like do notation.
05:22:04 <psykotic> right
05:22:06 <roconnor> er
05:22:10 <roconnor> yes I did
05:22:14 <roconnor> we shouldn't go crazy
05:22:35 <psykotic> roconnor, so, something that could be done using TH?
05:23:00 <roconnor> can do notation be done with TH?
05:23:37 <psykotic> something very close, i think, yes
05:23:59 <roconnor> sounds good
05:24:17 <psykotic> anyway. i wonder if there are any record system extension proposals for haskell prime?
05:24:34 <psykotic> the thing you mention about record field clashes is a common thing people mention
05:24:48 <psykotic> most people seem to get around it by using a prefix :)
05:25:03 <roconnor> Yep, it sucks.
05:25:43 <roconnor> not that I know how to do anything better.
05:25:44 <psykotic> remind me how ocaml deals with that? and how does it affect type inference?
05:26:04 <roconnor> I don't know Coq works like Haskell in this respect.
05:26:30 <wolverian> tuxplorer, see haskell.org's books section, I suppose
05:27:28 <Saizan> you can't add synctatic sugar like do-notation with TH, you can only exploit existing ones for different purpouses if you quote that part and give it to a macro
05:28:22 <dolio> Yeah. Adding something like do-notation would require explaining how to parse it to begin with, no? Which TH doesn't provide for.
05:28:33 <psykotic> yeah, hm
05:28:35 <Saizan> exactly
05:28:50 <dolio> Sort of the fundamental difference between TH and Lisp macros. Lisp is trivial to parse to begin with.
05:29:52 <psykotic> but, for example, with do notation one of the main things is translating <- bindings. couldn't you express the name of the bound variable as a string and use TH to turn that into an actual binding?
05:30:22 <psykotic> since it acts as a syntax tree transformer
05:31:33 <dolio> Yeah, you could probably do something like that.
05:31:42 <psykotic> in any case such hacks would be quite unusable. the main purpose of TH seems to be staging and such, not syntax-ish extension (although i've seen a few cases resembling that).
05:33:37 <psykotic> i saw a nice example of that on haskell-cafe recently. i'll try to see if i can find it.
05:33:46 <quicksilver> well you can't add new syntax to lisp with lisp macros either
05:34:02 <quicksilver> it's just that lisp has this simple uniform syntax you can repurpose
05:34:08 <quicksilver> AIUI
05:34:53 <dolio> Yeah. All lisp 'syntax' is made up of some nesting of lists.
05:35:25 <dolio> So in that sense, you can define your own, since all it has to do is parse lists.
05:36:38 <tuxplorer> wolverian: Thanks
05:37:47 <kpreid> dolio: I like to think of it as layered syntax
05:40:30 <dcoutts> seems like a single ip address in Russia is downloading ghc-6.6.1-i386-windows.exe 100's of times and saturating haskell.org's bandwidth
05:40:52 <mux> uh
05:40:59 <dcoutts> anyone know how I temporarily ban an IP address ?
05:41:03 <mux> maybe they have such a huge haskell need
05:41:04 <matthew-_> iptables
05:41:05 <dcoutts> either in apache or iptables
05:41:08 <Syzygy-> dcoutts: What kind of access do you have to it?
05:41:11 <dcoutts> sudo
05:41:12 <xerox> hosts.deny ?
05:41:18 <Syzygy-> For iptables, you match the ip-addy and throw it to DROP.
05:41:24 <Syzygy-> hosts.deny should let you ban it in apache.
05:41:27 <Botje> iptables -A INPUT -s <offending ip address> -j DROP
05:41:32 <matthew-_> iptables -A INPUT -d $theirIP
05:41:34 <matthew-_> -j DROP
05:41:42 <mux> no, -s
05:41:43 <Botje> no, -d is the destination (ie you)
05:41:45 <Syzygy-> matthew-_: Destination ip??
05:41:45 <mux> source ip
05:41:46 <matthew-_> oh, yeah, sorry
05:41:49 <dcoutts> right ok
05:41:52 <dcoutts> will try that...
05:41:54 <matthew-_> Syzygy-: on OUTPUT then! ;)
05:42:33 <matthew-_> dcoutts: if it's apache, you could try setting up mod_throttle
05:42:41 <matthew-_> or you can do rate limiting in iptables itself
05:42:47 <matthew-_> or you could try and do magic with fail2ban
05:43:11 <dcoutts> matthew-_: I'm not really an apache guru, if someone can walk me through it, otherwise I'm happy to use iptables
05:43:31 <Botje> otoh
05:43:44 <Botje> maybe they're giving a class about haskell and everybody's downloading it :)
05:43:56 <dcoutts> any other suggestions before I block that ip with iptables ?
05:44:19 <Botje> look up the IP and see if it's connected to an institution?
05:44:35 <matthew-_> dcoutts: oh, block it, I'll just look up the rate limiting stuff.
05:44:36 <pjd> redirect the IP to a message page?
05:44:39 <Botje> (whois <IP>)
05:44:41 <EvilTerran> Botje, in that case, they should've made a local mirror
05:44:50 <dcoutts> host 212.59.109.41
05:44:50 <dcoutts> 41.109.59.212.in-addr.arpa domain name pointer kns-109-41.kansstel.ru.
05:45:20 <matthew-_> whois on that is useless
05:45:21 <dcoutts> bah, all 151 apache slots are used up still
05:46:13 <Botje> EvilTerran: unfortunately education does not imply clue
05:46:47 <EvilTerran> however, failure to provide a local mirror *does* imply ipbanned, in my book.
05:46:47 <dcoutts> Botje: hmm, that ip is still connecting to apache, lemme check that iptables rule...
05:46:58 <Botje> dcoutts: that will only block new requests
05:47:04 <matthew-_> restart apache
05:47:13 <matthew-_> I would probably try stuff like: iptables -A INPUT -p tcp --dport 80 -m connlimit --connlimit-above 5 -j DROP
05:47:19 <Botje> if you want to block the active requests, add a rule to OUTPUT too or just restart apache
05:47:23 <dcoutts> Botje: but I restarted apache
05:47:36 <Botje> hmm
05:47:52 <Botje> are there any ACCEPT lines above the DROP?
05:47:52 <dcoutts> it's eating up all the apache slots again
05:48:00 <Botje> try inserting it in the front, otherwise
05:48:07 <Botje> same command but with -I instead of -A
05:48:32 <dcoutts> Botje: lemme paste in #haskell-overflow...
05:50:47 <Syzygy-> dcoutts: Add "Deny from 212.59.109.41" to the relevant bits of the Apache conf? You'll want this to live in a <Directory> IIRC
06:16:24 <Nopik> if there is fun = do ... return x; how does compiler know the type of monad returned? it deducts it from return or from expressions in do?
06:17:31 <Lemmih> Nopik: It doesn't necessarily know.
06:18:07 <Nopik> so, when it tries to run it, it checks?
06:18:46 <Lemmih> Nopik: There's no generic way of "running" a monadic action.
06:19:08 <Nopik> heh
06:19:10 <Lemmih> Nopik: See 'runState' and 'runReader' for example.
06:19:56 <Nopik> i am just reading it and i got the questions in the process :D
06:20:07 <opqdonut> but yeah, for monads not requiring any sort of run (IO, [], Maybe, etc) it gets deduced from context
06:20:42 <opqdonut> (return 1,return 1) :: ([Int],Maybe Int)
06:20:45 <opqdonut> > (return 1,return 1) :: ([Int],Maybe Int)
06:20:50 <lambdabot>  ([1],Just 1)
06:20:58 <opqdonut> > (fail "",fail "") :: ([Int],Maybe Int)
06:21:00 <lambdabot>  ([],Nothing)
06:32:11 <Nopik> @src fromJust
06:32:12 <lambdabot> fromJust Nothing  = undefined
06:32:12 <lambdabot> fromJust (Just x) = x
06:32:25 <Nopik> @src Map.lookup
06:32:25 <lambdabot> Source not found. You type like i drive.
06:35:58 <Nopik> ok, another idea in a strive to understand monads :)
06:37:43 <Nopik> lets suppose that in c++ you write template function, obtaining 'this' pointer as a template parameter (i.e. pointer to some object of type T) and does some operation on this pointer
06:38:45 <Nopik> generally applying and calling such function on given object is very similar (or equal?) to making fun = do ... return x;    and then runXxx fun xxx;   ?
06:39:16 <Nopik> i just want to verify if my understanding is correct, and if not, what mistake i do ;)
06:42:53 <dons> hmm, maybe.
06:43:05 <dons> you have an object wrapped up, in the `container' view of monads
06:43:51 <dons> http://sigfpe.blogspot.com/2007/04/homeland-security-threat-level-monad.html
06:43:53 <lambdabot> Title: A Neighborhood of Infinity: Homeland Security Threat Level Monad, http://tinyurl.com/29fzcq
06:44:01 <dons>  is a good guide to a simple C-ish level view of monads
06:44:31 <dons> probably best to get familiar with the Maybe and Either container-like monads, then look at State
06:45:24 <gleb> @src maximum
06:45:24 <lambdabot> maximum [] = undefined
06:45:24 <lambdabot> maximum xs = foldl1 max xs
06:48:58 <Nopik> @src local
06:48:58 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
06:49:23 <Nopik> where is 'local' defined?
06:49:44 <gleb> Control.Monad.Reader, I guess
06:49:49 <Nopik> hm
06:50:06 <gleb> @doc Control.Monad.Reader
06:50:06 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Reader.html
06:50:07 <Nopik> MonadReader
07:01:42 <ski> @type Control.Monad.Reader.local
07:01:44 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
07:02:56 <ski> instance MonadReader r (Reader r)
07:03:02 <ski>   where
07:03:04 <ski>   local f (Reader r_a) = Reader (\r -> r_a (f r))
07:03:09 <ski> something like that
07:03:35 <ski> @src MonadReader
07:03:35 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
07:17:35 <Nopik> ok, i would need some help from you on constructing my own monad (for tutorial purposes only), this may take few minutes
07:17:53 <Nopik> i decided that i will create my own monad to see how it should work
07:17:58 <Nopik> i came up with something like this:
07:18:08 <Nopik> data MyMonad a b c d = MyMonadC { runMyMonad :: (a,b) -> (c,d) }
07:18:28 <SamB_XP_> hmm.
07:18:32 <Nopik> i am not so sure if something like this can be turned out to monad, actually ;)
07:18:40 <SamB_XP_> That can't quite work
07:18:44 <SamB_XP_> try to implement "return"
07:18:59 <Nopik> yeah, actually i tried to implement return and failed :D
07:19:09 <Nopik> but i dont know why ;p
07:19:25 <SamB_XP_> anyway, the issue is that return can't get anything of type c
07:19:46 <benny99> http://www2.lifl.fr/~boulet/formation/CALP/man/monads/html/index.html <-- appears to be a great monad tutorial, if anybody is interested
07:19:48 <Nopik> and d, too?
07:19:52 <lambdabot> Title: All About Monads, http://tinyurl.com/2aswv5
07:19:57 <SamB_XP_> it gets passed something of type d
07:20:02 <upyx> hello
07:20:07 <upyx> i want to learn haskell
07:20:17 <SamB_XP_> upyx: you've come to the right place ;-)
07:20:18 <upyx> i want to do this on os x
07:20:26 <Nopik> SamB: because the last argument of MyMonad is d?
07:20:34 <SamB_XP_> Nopik: yeah
07:20:41 <upyx> how do i do it without sucky graphics libraries SamB_XP_ ?
07:20:48 <Nopik> SamB: so return only gets d? and runMyMonad gets a and b?
07:20:50 <SamB_XP_> upyx: you want graphics?
07:20:54 <benny99> upyx: I recommend the "YAHT" book  -- I liked it :)
07:21:05 <SamB_XP_> Nopik: yeah
07:21:07 <upyx> SamB_XP_ i am interested in gui programming with haskell
07:21:10 <dons> benny99: ah good! we should recommend it to more people :)
07:21:16 <upyx> benny99: i have that, tis good
07:21:19 <benny99> dons: ._. ?
07:21:19 <Nopik> SamB: ok, thanks
07:21:30 <dons> benny99: its good that you found YAHT suitable :)
07:21:39 <benny99> dons: :Z Yeah, hm, ... what else am I supposed to say ?
07:21:50 <Nopik> SamB_XP_: actually, i tried to change that to (a,b,c)->d but failed too.. gonna try again
07:21:50 <SamB_XP_> upyx: there is a package called HOC (a Haskell<->ObjC interface) but I don't think it works very well
07:21:54 <dons> upyx: lots of gui libs on hackage.haskell.org. gtk2hs is the most commonly used
07:22:03 <upyx> SamB_XP_ aint that gtk?
07:22:04 <dons> and yeah, HOC, for Cocoa libs
07:22:05 <SamB_XP_> dons: doesn't gtk suck on OS X still?
07:22:12 <dons> i think its fine, afaik.
07:22:14 <savanni> I haven't found that to be the case.
07:22:15 <profmakx> gtk sucks on windows too
07:22:15 <upyx> SamB_XP_ exactly
07:22:19 <upyx> it sucks everywhere
07:22:21 <upyx> i hate gtk
07:22:23 <savanni> Although, my definition of suck may not be related to yours.
07:22:25 <dcoutts> SamB_XP_: it works, it doesn't look great on OSX yet
07:22:29 <upyx> gnome should move on to something better :s
07:22:31 <SamB_XP_> upyx: it doesn't suck too bad on X
07:22:35 <upyx> well
07:22:39 <SamB_XP_> well, visually anyway
07:22:41 <upyx> ok i might be to harsh
07:22:44 <upyx> too*
07:22:53 <upyx> it sucks to my eyes and that is a valid reason for it to suck
07:22:57 * wli doesn't know the first thing about graphics/GUI/etc.
07:23:01 <savanni> If I were really good, I'd start on QT bindings. :D
07:23:02 <upyx> asides that we only have wx there rigt?
07:23:12 <wli> Well, I know spline crap but not how any of it's used.
07:23:18 <savanni> upyx: OS X also has QT.
07:23:25 <upyx> savanni: only if trolltech desides to do the bindings
07:23:26 <Syzygy-> Anyway - the state of the art seems to be that gtk2hs is one of the better working GUI builders, and there doesn't seem to be much around that deals with OSX-specific GUI issues.
07:23:35 <phoniq> qt on osx rocks
07:23:36 <dcoutts> wli: cairo is pretty nice and does splines and all other vector stuff
07:23:38 <SamB_XP_> upyx: what?
07:23:41 <upyx> so far third - party bindings for qt have failed miserably
07:23:48 <upyx> qt rocks everywhere phoniq
07:23:52 <upyx> anyway my issue is this
07:23:55 <upyx> what must i use
07:23:56 <phoniq> :)
07:23:57 <upyx> in osx
07:23:57 <dcoutts> it's because QT is C++
07:23:59 <SamB_XP_> what bindings?
07:24:00 <dcoutts> so hard to bind to
07:24:09 <upyx> to program guis with haskell
07:24:11 <upyx> that is NOT gtk
07:24:15 <SamB_XP_> oh, that.
07:24:16 <wli> dcoutts: I have a good idea that all the spline stuff is done in libs and not by hand, yes.
07:24:17 <dcoutts> Gtk+ is C and designed for language bindings hence there are lots of them
07:24:17 <upyx> and does not suck
07:24:17 <dons> upyx: available gui libs are on hackage.haskell.org. there's 10 or so choices
07:24:18 <savanni> Ah, yeah.  That could be more a problem with GCC than with QT, though.
07:24:29 <phoniq> dcoutts, what's the issue, the name mangling?
07:24:45 <dcoutts> phoniq: yep, and passing data
07:24:51 <SamB_XP_> yes, whatever else you can say about GTK, it is clearly designed with bindings in mind
07:24:53 <phoniq> ah, QString and all that
07:24:56 <dons> upyx: pick something from this list, http://haskell.org/haskellwiki/Applications_and_libraries/GUI_libraries
07:24:58 <lambdabot> Title: Applications and libraries/GUI libraries - HaskellWiki, http://tinyurl.com/yttdtd
07:25:01 <savanni> upyx: wx is available, but I don't think there is a haskell binding yet.
07:25:10 <dcoutts> savanni: wxhaskell
07:25:16 <upyx> come on, the signal/slot system was first invented by Qt, it does work really well, and monads can replace that in gui programming with quite interesting results
07:25:27 <upyx> but GTK sucks majorly, it is a pain i am not willing to get into again
07:25:28 <SamB_XP_> upyx: hmm?
07:25:29 <upyx> so
07:25:40 * SamB_XP_ is wondering how monads can replace signal/slot
07:25:51 <dcoutts> upyx: the api of gtk2hs and wxhaskell are conceptually very similar
07:25:52 <savanni> dcoutts: sweet... now if only I didn't truly *suck* at gui programming.
07:25:58 <upyx> if you can advise me of a good way to do gui programming with haskell on osx without resorting to gtk, yet having enough features please do
07:26:05 <dcoutts> upyx: you're probably just rembering the pain of doing gui programming in C :-)
07:26:06 <wli> I'd be interested in learning GUI proramming at some point.
07:26:17 <SamB_XP_> upyx: gtk sucks (a) visually, (b) API-ly, (c) ?, (d) all of the above
07:26:17 <wli> Isn't there some Haskell textbook that focuses on GUI stuff?
07:26:18 <upyx> dcoutts: lol
07:26:20 <SamB_XP_> ?
07:26:33 <upyx> if i recall
07:26:39 <SamB_XP_> wli: well, SOE focuses on multimedia.
07:26:52 <SamB_XP_> ... but has no text measuring in it's graphics library!
07:26:53 <upyx> some time ago i saw a proggie by a guy named araujo (omg autocompletion, he is in here!)
07:26:53 <wli> SamB: I should pick that up at some point.
07:26:54 <dcoutts> upyx: signals are easy: onClicked button $ do ...
07:27:00 <benny99> I like GTK :/
07:27:11 <savanni> Oh, hey, I just ordered that textbook. :D
07:27:13 <upyx> well if i recall correctly he did a nice thing for portage
07:27:14 <benny99> dons: I recommend it =P
07:27:20 <upyx> using gtk2hs
07:27:34 <dcoutts> yes he did
07:27:37 <SamB_XP_> upyx: are you going to answer the question?
07:27:37 <upyx> dcoutts: they are easy because they are supposed to work, gtk gives me the chills
07:27:53 * benny99 is gone
07:28:01 <upyx> SamB_XP_ gtk sucks bottom up
07:28:05 <upyx> that covers it for me
07:28:18 <upyx> i am stuck in a dumb windows box right now and i can barely stand it as well
07:28:25 * ozone resists the temptation to say anything
07:28:36 <dons> try ncurses, its great.
07:28:39 <dcoutts> upyx: that code was gtk :-)
07:28:45 <wli> The window manager in Windows is horrible.
07:28:45 <SamB_XP_> upyx: so you think that glib, gdk, cairo, and gtk all suck?
07:28:53 <dcoutts> cairo rocks
07:28:53 <SamB_XP_> wli: indeed it is
07:29:02 <upyx> dcoutts: i know, but it was an example of graphics programming (gui programming to be exact)
07:29:02 <ozone> dons: d00d you should just make some web 2.0 bindsings for haskell that would rox0r!
07:29:10 <dcoutts> gdk is no longer needed for graphics, just window management stuff
07:29:12 <phoniq> tk?
07:29:17 <wli> dons: Yeah, I'm *huge* on ncurses apps runnin under screen.
07:29:28 <upyx> SamB_XP_ you cannot compare the C++/MOC within Qt with the gtk+ mess
07:29:31 <dons> ozone: yeah, totally roxors1!11!
07:29:32 <dcoutts> upyx: well to be precise, it's from gtk2hs hello world
07:29:34 <SamB_XP_> apparantly each application has the WM running in its address space
07:29:45 <SamB_XP_> or something...
07:29:52 <dcoutts> upyx: http://haskell.org/gtk2hs/documentation/#hello_world
07:29:58 <wli> SamB_XP: A cuter trick would be something like SKAS.
07:30:00 <upyx> yeah i saw that as well
07:30:04 <SamB_XP_> upyx: than you have to stop saying they suck
07:30:07 <ozone> dons: also iphone haskell would be nice pls!
07:30:11 <SamB_XP_> er.
07:30:15 <SamB_XP_> it.
07:30:22 <upyx> lol ok
07:30:32 <upyx> they cannot suck because they dont have lips i get it
07:30:38 <SamB_XP_> no...
07:30:50 <SamB_XP_> you just said that you can't compare qt with gtk
07:31:02 <SamB_XP_> so gtk can't very well *suck* compared to qt now can it?
07:31:06 <upyx> yes you cannot compare them because qt is software and gtk is crap
07:31:19 <ozone> upyx: ok, i give in, you can try HOC
07:31:26 <dons> ozone: yeah! in ur iphone i can has lambdas plz?
07:31:29 <phoniq> how's this stuff typically done, are haskell<->C bindings generated automagically?
07:31:29 <upyx> hoc ?
07:31:34 * Syzygy- wishes for less religious fanaticism in here.
07:31:38 <ozone> http://hoc.sf.net/
07:31:40 <lambdabot> Title: HOC: A Haskell to Objective-C Binding
07:31:55 <ozone> you may need to read a book about cocoa first, though
07:32:00 <dcoutts> I'm sure coding with Qt in C++ is great compared to coding with Gtk+ in C, but that's more to do with C vs C++, coding Gtk+ in Haskell is much much better than in C
07:32:04 <ozone> which will keep you busy for a... well, at least half an afternoon
07:32:04 <phoniq> (which would mean there's serious work to do to wrap anything large and C++)
07:32:24 <quicksilver> @remember dons in ur iphone i can has lambdas plz?
07:32:24 <lambdabot> Done.
07:32:25 <ndm> dcoutts, its still about 100 times worse than C# and Visual Studio
07:32:28 <dcoutts> I can't compare to coding GUIs in C++ as I've never done that, but I'd say it's easier in Haskell than Java (AWT)
07:32:30 <ozone> dcoutts: gtkmm vs Qt is about par, for future debates :)
07:32:38 <SamB> dcoutts: I really do wish we had some Qt bindings though
07:32:40 <upyx> ozone: they are not but anyway
07:32:41 <dcoutts> ndm: nooo, C# ? no closures?!
07:32:49 <SamB> dcoutts: wrong you idiot
07:32:49 <upyx> ozone: well it is objective c
07:32:58 * wli ponders screen(1) in Haskell.
07:33:02 <ndm> dcoutts, objects, properties, graphical interface, not written by monkeys on crack, well supported, code completion...
07:33:03 <dcoutts> SamB: what, they do have closures now?
07:33:13 <SamB> dcoutts: or should I say "hiding-under-a-rock-man"?
07:33:16 <upyx> upyx: i will have to sacrifice some cross - platform niceness from some things
07:33:17 <ndm> they do have closures, but you don't need them for writing a GUI
07:33:19 <upyx> but what the hell
07:33:27 <dcoutts> SamB: heh heh :-) yeah that's probably me
07:33:34 <ndm> in fact, VB is 100 times better than Gtk+Hsakell for a GUI
07:33:37 <SamB> ndm: it's nice to know that they *have* them, regardless
07:33:38 <ozone> upyx: you'll need to check out CVS to get it building with ghc 6.6
07:33:42 <dcoutts> ndm: it makes signals much nicer
07:33:50 <SamB> ndm: I hope you mean VB.NET?
07:33:53 <upyx> ozone: have you tried this
07:34:02 <ozone> upyx: not for a while, but yes, i've tried this :)
07:34:12 <ndm> dcoutts, not if you have proper events in your language, and delegates (which is lambda's and closures restricted for events)
07:34:12 <upyx> ozone: impressions?
07:34:27 <ozone> umm
07:34:27 --- mode: ChanServ set +o dons
07:34:30 <ndm> SamB, hell no, VB.NET == C# + syntax changes, I mean real VB 6
07:34:31 --- topic: set to '["The Haskell programming language: I CAN HAS LAMBDAS?","Home: http://haskell.org","Paste: http://hpaste.org","Logs: http://tunes.org/~nef/logs/haskell/","The language of ICFP winners 3 years running"]' by dons
07:34:35 --- mode: ChanServ set -o dons
07:34:37 <SamB> ndm: eeeeeew
07:34:39 <mrd> wow new hwn
07:34:45 <upyx> ozone: i am seriously interested
07:34:45 <ozone> it's written by some guys on crack, but otherwise works, and it appears that some people have written "real stuff" with it
07:34:51 <SamB> hmm.
07:34:52 <SamB> wait.
07:34:53 <ndm> SamB, its popular to say VB is a toy language, but it is great
07:35:04 <SamB> is VB 6 a lot better than VB 5?
07:35:07 <ndm> i have written lots of stuff in VB, its great
07:35:09 <ozone> (which scares me somewhat)
07:35:16 <upyx> ozone: lol
07:35:19 <ndm> no, its identical (modulo one feature, which no one ever uses)
07:35:25 <ozone> upyx: my honest opinion is that if you want to do cocoa though, do it in objective-c
07:35:37 <SamB> ndm: what feature is that?
07:35:41 <upyx> there is a problem though ozone
07:35:43 <ozone> doing it in haskell works, but you put yourself through a lot of practical pain for the bonus of a nicer language
07:36:00 <SamB> ndm: anyway, I think VB would be nice...
07:36:06 <ndm> SamB, something to do with inherivance and variants in arrays or something, sufficiently obscure that no one ever sees or uses it
07:36:11 <upyx> we are going to be stuck in a 32bit cocoa in leopard; can this be a problem with the bindings these guys provide?
07:36:17 <SamB> if it had a better GUI library
07:36:25 * ihope waves dylan_ward
07:36:29 <ndm> the GUI library is pretty good, pretty fully featured
07:36:36 <ozone> upyx: no, cocoa will be 64-bit will leopard.  carbon will be 32-bit.
07:36:38 <ndm> the C# one is quite a bit better though
07:36:40 <SamB> I stand by my claim.
07:36:46 <ozone> s/will/with/
07:36:47 <SamB> it doesn't do layout at all!
07:36:48 <ndm> i stand by my claim too :)
07:36:50 <upyx> ozone: right! sorry
07:37:00 <ndm> yeah, that is unfortunate, but its only layout that is lacking
07:37:13 <upyx> ozone: thanks for the info, i will go check that thing out
07:37:24 <ndm> plus i had written my own layout library for VB, so _my_ copy of VB did layout, even if yours didn't
07:37:36 <SamB> and the UI elements don't want to fit the grid well
07:37:36 <ozone> sure.  i'd highly recommend you read up on cocoa if you don't know it yet; hoc is meant for people who've done cocoa programming before.
07:37:47 <SamB> ndm: okay, now you've got something there
07:37:53 <ndm> i also had stack traces, compiled program debugging and some other VB goodies that no one else had
07:37:56 <ozone> otherwise you will get rather confused at this "interface builder" thing, etc
07:38:01 <wli> I don't get the religion thing. I like other languages, too.
07:38:07 <SamB> maybe I should get my copy installed again then ;-)
07:38:14 <upyx> ozone: i would even learn a programming language written entirely in kanji if it was a way to gt out of the gtk mess
07:38:18 <ndm> those were on my copy only, i wrote the features back in
07:38:24 <SamB> then I could actually learn VB
07:38:37 <ozone> upyx: evidently so
07:38:39 <ndm> nah, now you want to pick C# over VB, VB died, it was good, but C# is better
07:38:45 <SamB> ndm: I'd want to steal your stuff
07:38:58 <ndm> SamB, C# has it all, plus its native so easier to use
07:39:15 <ndm> Borland Delphi had all those features 10 years before C#
07:39:41 <ozone> i have 149 unread articles on planet haskell :(
07:39:46 <fasta> Would you use military typing for something that is always a list containing two FooBars, or one Zork, or one Bleh, or one Foobar?
07:40:25 <dons> fasta: mm?
07:40:36 <dons> use strong types, or the terrorists win
07:40:39 * EvilTerran parse errors
07:40:53 <blackdog> dons: ah, you're up - is there a quick way to install xmonad on openbsd?
07:41:01 <fasta> dons: in such cases do you always go the strong types approach?
07:41:09 <dons> blackdog: via cabal. there's no package that I know of
07:41:13 <blackdog> ok
07:41:14 <dons> you got a ghc 6.6?
07:41:22 <fasta> dons: it seems rather... over kill ... to use it always
07:41:28 <dons> otherwise, i can give you a statically linked binary
07:41:36 <blackdog> think the default is 6.2 :/ might have to do some work before i get it going
07:41:40 <dons> fasta, give it a type, yep.
07:41:41 <blackdog> it's a very spartan *nix...
07:41:52 <blackdog> nah, it's ok. i probably need cabal stuff for HAppS anway.
07:42:34 <ozone> blackdog: are you procrastinating again?
07:42:35 <roconnor> I asked a question on #math, and got reject for asking about homework :(
07:42:43 <dons> roconnor: hah
07:42:51 <wli> roconnor: EfNet #math
07:42:54 <wli> roconnor: ?
07:43:02 <EvilTerran> i take it it wasn't actually homework?
07:43:07 <SamB> blackdog: I finally switched to 6.6 to build xmonad
07:43:35 <roconnor> EvilTerran: I said I was a 29 yr old mathematician who hasn't done undergraduate calculus in 10 years.
07:43:40 <blackdog> ozone: sorta. i want to run a continuous integration box, and i don't have a unix server at the moment (my poor overloaded little g4 doesn't count)
07:43:43 <roconnor> which is true.
07:43:48 <Nopik> ok, why this do not work:  flp :: (a,b) -> c             flp (a,b) = (b,a) ?
07:43:56 * wli graduated 7-8 years ago so...
07:43:58 <EvilTerran> aha. sorry, i don't know who everyone is in here.
07:43:59 <blackdog> so i'm running openbsd in a vmware environment on my windows machine
07:43:59 <Nopik> obviously it cant match (b,a) type to c
07:44:01 <roconnor> sadly my degree in Pure Mathmatics doesn't give me any respect ... on IRC ;)
07:44:06 <wli> roconnor: I can answer such things.
07:44:23 * ndm graduated 3 years ago
07:44:27 <Nopik> but i thought that it should work anyway?
07:44:28 <ndm> (for the first time)
07:44:29 <upyx> roconnor: dont think that logic applies in IRC
07:44:38 <ozone> blackdog: you actually have unit tests? :)  zomgie!
07:44:40 * blackdog graduated in 2001, but he can never really leave...
07:44:51 <EvilTerran> a little google-mining would, however, have suggested that you're PhDing
07:44:52 <roconnor> wli: given f_n -> f and g_n -> g, where everything operates on compat spaces and and converges uniformly.
07:45:02 <roconnor> wli: does f_n o g_n -> f o g
07:45:02 <blackdog> ozone: it's hard. i'm so used to being a cowboy
07:45:08 <Syzygy-> roconnor: It does - but only from parts.
07:45:15 <EvilTerran> Nopik, no, you can't type something as a more general type than it can be
07:45:17 <SamB> I'll need to be 30 before I can say I haven't done undergrad calculus in 10 years...
07:45:19 <wli> roconnor: I don't know offhand.
07:45:21 <roconnor> does f_n o g_n -> f o g uniformly
07:45:29 <upyx> byte all
07:45:31 <upyx> bye*
07:45:32 <wli> SamB: I'm 31.
07:45:42 <upyx> thanks ozone for your advice
07:45:50 <EvilTerran> Nopik, so although
07:45:50 <roconnor> Syzygy-: what do you mean?
07:45:52 <EvilTerran> :t Nothing
07:45:54 <lambdabot> forall a. Maybe a
07:45:54 <Syzygy-> roconnor: Y'know .. one of the reasons I didn't react in #math to that was that I have no idea whatsoever.
07:45:59 <ozone> no problem, don't make me regret it ;)
07:46:02 * SamB is 20 and did DEs in the spring
07:46:03 <EvilTerran> gives "Maybe a", you can still say
07:46:07 <EvilTerran> > Nothing :: Maybe Int
07:46:08 <Syzygy-> roconnor: However, you -do- get respect from a non-zero subset of the Efnet:#math regulars.
07:46:09 <lambdabot>  Nothing
07:46:11 <Nopik> EvilTerran: so, (a,b) will never match c because c could be also [a] ?
07:46:13 <roconnor> wli: heh, on #math I got: <_llll_> other than "this is a question solveable by anyone who knows the definition", i dont have any useful hints
07:46:14 <EvilTerran> but you can't say
07:46:20 <EvilTerran> > Nothing :: Bool
07:46:21 <lambdabot>  Couldn't match expected type `Bool' against inferred type `Maybe a'
07:46:38 <roconnor> Syzygy-: :) I don't think the answer is obvious.
07:46:44 <roconnor> But I do agree it is a decent homework problem.
07:46:52 <wli> roconnor: I suspect it's true but I can't quite see the proof instantaneously.
07:47:05 <roconnor> I just want to know if it is true or not so I don't waste time proving false things in Coq.
07:47:23 <EvilTerran> Nopik, pretty much. if a type has a typevariable in it, it has to be valid for _all_ possible values of that typevar.
07:47:24 <SamB> roconnor: proving... or *trying* to prove?
07:47:56 <roconnor> SamB: :)
07:48:22 <roconnor> wli: I think it is true because the space of functions on compat spaces is compact
07:48:38 <roconnor> wli: and composition is continuous, and hence uniformly continuous
07:49:10 <dcoutts> Saizan: that status icon demo is really cool :-)
07:49:14 <roconnor> wli: I think uniform limits are preserved under uniformly continuous functions... This I am less sure of.
07:49:14 <dcoutts> and really short
07:49:24 <SamB> what does "f_n -> n" mean?
07:49:47 <roconnor> SamB: I mean f_n -> f
07:49:51 <roconnor> sorry
07:50:18 <wli> roconnor: f_n*g_n will converge, but possibly not uniformly... there may be a similar phenomenon involved for composition.
07:50:20 <SamB> er.
07:50:27 <SamB> roconnor: actually that was my typo
07:50:35 <SamB> you said it as f_n -> f
07:50:39 <SamB> and I meant to type that too
07:50:46 <SamB> but I somehow copied the wrong letter
07:51:01 <roconnor> oh, f_n is a sequence of functions that converges to a function f.
07:51:06 <SamB> okay.
07:51:09 <roconnor> and I mean convering uniformly in this case.
07:51:14 <roconnor> converging
07:51:29 <SamB> I don't remember "uniformly". perhaps I never learned it...
07:51:46 <hpaste>  Nopik pasted "Simple monad" at http://hpaste.org/1875
07:51:49 <wli> roconnor: I see something that implies under some condition (boundedness?) that some compositions are uniformly continuous used in an existence theorem for solutions of initial value problems.
07:51:59 <roconnor> wli: I think f_n*g_n converges uniformly. ... I have a Coq proof here, unless I am misreading it.
07:52:16 <roconnor> (given my conditions)
07:52:19 <Nopik> ok, i came up with something like the pasted one... could anyone take a look and tell me how i could access arguments of ff1?
07:52:40 <Nopik> please? :)
07:52:41 <roconnor> SamB: http://planetmath.org/?op=getobj&from=objects&id=3700
07:52:43 <lambdabot> Title: PlanetMath: uniform convergence
07:52:43 <wli> roconnor: Boundedness is required according to the counterexample construction exercise's first part.
07:52:51 <Nopik> i created simple monad, though it is not too useful yet ;p
07:53:10 <roconnor> wli: I'm working in compact spaces, so I have boundedness :)
07:53:23 <SamB> Nopik: nice work
07:53:42 <wli> roconnor: You should have quite a bit to work with, then.
07:53:47 <Nopik> SamB: actually i learned a lot during trying to write this one.. equal to reading 2 tutorials ;)
07:53:50 <SamB> Nopik: it appears to be a kind of reader monad
07:53:55 <roconnor> wli:  indeed
07:54:05 <Nopik> SamB: actually, it started from state monad
07:54:09 <ozone> SamB: that sounds like something that a main character would say in a murder mystery
07:54:13 <SamB> I didn't learn metric spaces
07:54:14 <doserj> roconner, you also assume f_n, g_n to be continuous?
07:54:15 <roconnor> wli: My concern was that http://planetmath.org/?op=getobj&from=objects&id=7215 doesn't mention this theorem
07:54:16 <lambdabot> Title: PlanetMath: limit laws for uniform convergence
07:54:24 <SamB> (in school)
07:54:27 <roconnor> doserj: they are continuous.
07:54:46 <Nopik> SamB: and >>= definition is just copy/paste from State.hs
07:54:47 <roconnor> but maybe PlanetMath isn't as complete as I think.
07:55:04 <wli> roconnor: There's Theorem 3, which is close.
07:55:35 <roconnor> wli: yep, so close it scared me into thinking what I have wasn't true.
07:55:42 <SamB> hmm, so "uniformly" means that you can have one epsilon for the whole range?
07:55:49 <roconnor> otherwise, wouldn't they give my theorem?
07:55:50 <wli> SamB: Yes.
07:55:56 <SamB> makes sense
07:56:01 <Nopik> so, any ideas how i can get this more useful?
07:56:20 <Nopik> i tried things like f <- id inside of do, but it didnt compiled somehow
07:56:31 <SamB> Nopik: well, besides using Control.Monad.Reader.Reader ?
07:57:06 <Nopik> SamB: the ff1.. can i access to its argument inside of do?
07:57:25 <ozone> nytol
07:57:25 <Nopik> SamB: well, i am writing this for educational purposes, i do not want to use anything existing yet
07:57:34 <SamB> hehe yes
07:57:41 <Nopik> SamB: how?
07:57:44 <wli> roconnor: I think the odds are it's just a generalization in a different direction (local compactness on Y vs. compactness everywhere).
07:57:44 <SamB> er.,
07:58:04 <SamB> I meant "yeah I'm sure you didn't really want to use the mtl yet"
07:58:04 <roconnor> wli: good point
07:58:19 <Nopik> SamB: ok ;)
07:58:27 <SamB> Nopik: you need to write a function that will return the arguments
07:58:39 <SamB> you could call it, say, ask
07:58:45 <Nopik> SamB: any examples, please?
07:58:50 <wli> roconnor: A quick mental run-through of the definitions suggests that apart from potential side conditions (which I think you have anyway), it should go through.
07:59:05 <Nopik> SamB: or at least what type signature it should have?
07:59:09 <roconnor> wli: Okay, I'll go for it.
07:59:17 <Nopik> ask :: MyMonad a b c d -> (a,b,c) ?
07:59:34 <SamB> ask :: MyMonad a b c (a, b, c)
08:00:52 <roconnor> wli: I think I have a proof on my whiteboard.
08:01:19 <roconnor> Hmm, it's not quite right yet.
08:01:44 <SamB> hmm.
08:02:29 <SamB> roconnor: I think you may need more than continuity and uniformity ...
08:03:15 <SamB> what is "compat space"?
08:04:02 <wli> compact
08:04:07 <wli> typo for compact
08:04:22 <SamB> ah.
08:04:50 <wli> SamB: Boundedness is there. I'm not sure if further side conditions are needed yet but that one's pretty strong already.
08:04:59 <SamB> that's what I thought when google couldn't find anything for it on planetmath
08:05:04 <SamB> boundedness.
08:05:33 <wli> cf. Heine-Borel; closed and bounded = compact on R
08:06:01 <Nopik> SamB: ah.. thanks
08:06:03 <SamB> yes but is the derivative bounded too?
08:06:10 <Nopik> SamB: yet another piece of knowledge matched its place :D
08:06:35 <SamB> I think the derivative of f needs to be bounded
08:06:51 <wli> SamB: Derivatives don't necessarily exist, but if they do, then it gets really easy.
08:07:00 <SamB> hmm.
08:07:11 <roconnor> My functions are not necessarily differentable.
08:07:39 <cjeris> roconnor: C(X, Y) in the topology of uniform convergence is compact when X, Y are compact uniform spaces?  It's been a long time but I'm not sure I see that
08:08:00 * SamB is confused anywayt
08:08:24 <Nopik> SamB: shouldn't it be something like: ask :: MyMonad a b c d -> MyMonad a b c (a,b,c) ?
08:08:33 <SamB> Nopik: nope!
08:09:15 <Nopik> SamB: so, how should i write definition? just ask = (a,b,c) will tell me that a b c are not in scope?
08:09:15 <byorgey> Nopik: remember, something of type  MyMonad a b c d  already represents a computation.
08:10:11 <byorgey> Nopik: in this case, you want a computation which takes the input (a,b,c) and simply returns them.
08:10:21 <wli> Additional conditions may be required.
08:10:55 <Nopik> byorgey: ask = do return (a,b,c) gives me: a b c not in scope ;)
08:11:29 <byorgey> Nopik: well, that's not the same thing.
08:11:58 <Nopik> hm
08:12:15 <byorgey> Nopik: remember, you defined the type MyMonad a b c d to mean MyMonadC (some function).
08:12:16 <Nopik> MyMonadC $ \(a,b,c) -> (a,b,c) would do?
08:12:19 <Nopik> lets check
08:12:28 <byorgey> Nopik: brilliant!
08:12:37 <roconnor> cjeris: yep, that's what i'm thinking
08:12:50 <wli> |f_n(g_n(x))-f(g(x))| <= e, so you need an N so for all n >= N and all x in dom(g) for it to fly.
08:12:58 <cjeris> roconnor: To get f_n o g_n -> f o g it seems like you may need {f_n} to be equicontinuous
08:13:05 <Nopik> thanks :)
08:13:12 <roconnor> cjeris: :/
08:13:24 <roconnor> unforutunately that sounds plausible.
08:13:43 <roconnor> and that is exactly where I'm having trouble with my whiteboard proof.
08:14:26 <byorgey> Nopik: so now you can say do (x,y,z) <- ask; return (2*x) or something like that
08:14:30 <wli> cjeris: Ah, that's the hole.
08:15:14 <wli> Equicontinuity is stronger than uniform convergence.
08:15:42 <byorgey> Nopik: and as an exercise you can try rewriting that without do notation =)
08:15:50 <Nopik> byorgey: asks seems to work, but return do not
08:15:58 <byorgey> Nopik: what do you mean?
08:15:58 <Nopik> byorgey: i mean return (2*x)
08:16:08 <cjeris> roconnor: unfortunately, can't think off the top of my head of a sequence f_n -> f that converges uniformly to a continuous limit but not equicontinuously
08:16:20 <Nopik> byorgey: i got compile error that type d cant match to a
08:16:44 <byorgey> oh, well, did you give a type signature?
08:17:11 <wli> f_n(x) = x^2/(x^2 + (1-n*x)^2), f_n(1/n) = 1
08:17:55 <wli> f_n(x) -> 0 for fixed x
08:18:04 <wli> voila
08:18:11 <wli> Straight from Baby Rudin.
08:18:28 <wli> (this being on [0,1], sorry)
08:19:10 <byorgey> Nopik: I assume you put my do-block in ff1?
08:19:24 <byorgey> Nopik: in that case there's nothing wrong with return, you just need to think about the resulting type
08:20:17 <Nopik> balodja: ah yes, i had explicit type signature in ff1
08:20:26 <Nopik> erm, stupid nick completion ;)
08:20:32 <Nopik> byorgey:  ah yes, i had explicit type signature in ff1
08:20:39 <cjeris> wli: so it has a hump that gets sharper and sharper and moves to the left as n increases?
08:21:03 <byorgey> Nopik: right.  So what should the new type of ff1 be?
08:21:04 <wli> cjeris: Basically.
08:21:24 <Nopik> byorgey: :t says: MyMonad Integer Integer Integer
08:21:30 <cjeris> that doesn't converge uniformly to anything though - it's not uniformly Cauchy
08:21:30 <Nopik> erm, 4 times Integer
08:21:57 <Nopik> though i still didnt caught the bit with matching types.. for me writing d should do, and bind d to Integer
08:22:43 <byorgey> Nopik: if you have a type like Foo a b c, that means it has to work for _any_ types a, b, c.
08:22:53 <wli> doh, it's only uniformly bounded on a compact set
08:23:08 <byorgey> Nopik: so if the implementation requires that a and c are the same type, the type checker will complain, because it won't work for all types
08:23:47 <Nopik> byorgey: ok, i thought that function definition will be stronger ;p
08:24:56 <byorgey> Nopik: think of types as guarantees, rather than restrictions.
08:25:59 <Nopik> byorgey: yeah, thats the case
08:26:22 <Nopik> ok, but it seems, that my do (a,b,c) <- ask; return a; block is not using >>= at all
08:26:35 <Nopik> now i have to figure out how to use it ;)
08:27:10 <byorgey> Nopik: do blocks always use >>=, unless there is only one line.
08:27:13 <cjeris> roconnor: aha.  in fact, if X is compact and f_n, f: X -> Y are continuous and f_n -> f uniformly, then {f_n} is uniformly equicontinuous.  use an epsilon/3 argument to go from f_n(x) to f(x) to f(x') to f_n(x').
08:27:55 <byorgey> Nopik: do blocks are just syntactic sugar for chaining with >>=.
08:27:57 <Nopik> byorgey: ok, i'll try now to write function 'twice' which will twice a b c , so ask will return bigger values
08:28:07 <Nopik> byorgey: but sometimes they also use >>
08:28:45 <sjanssen> byorgey: that isn't quite right, do blocks use >> when there is no '<-' in a statement
08:28:54 <sjanssen> @undo do a; b; c
08:28:54 <lambdabot> a >> b >> c
08:29:03 <mauke> @src (>>)
08:29:03 <lambdabot> m >> k      = m >>= \_ -> k
08:29:16 <byorgey> sjanssen, Nopik: well, you're right, but >> is basically syntactic sugar for a certain use of >>=
08:29:30 <Nopik> ok, ok
08:29:31 <Nopik> ;)
08:29:48 <sjanssen> byorgey: (>>) isn't sugar -- it's part of the Monad class and thus can be overridden
08:29:56 <Nopik> @undo do (a,b,c) <- ask; return (a+b+c)
08:29:57 <lambdabot> ask >>= \ (a, b, c) -> return (a + b + c)
08:30:02 <byorgey> sjanssen: yes, you're right.
08:30:55 <byorgey> I should know better than to make not-quite-accurate generalizations in #haskell =)
08:31:04 <Nopik> @undo do twice; (a,b,c) <- ask; return (a+b+c)
08:31:05 <lambdabot> twice >> ask >>= \ (a, b, c) -> return (a + b + c)
08:31:12 <Nopik> @undo do (a,b,c) <- ask; twice; return (a+b+c)
08:31:12 <lambdabot> ask >>= \ (a, b, c) -> twice >> return (a + b + c)
08:32:00 <ski> Nopik : @src twice
08:32:16 <Nopik> ski: twice is not written yet ;)
08:32:28 <Nopik> actually i cant figure its type ;p
08:32:59 <byorgey> sjanssen: are there any interesting monads where m >> k is not m >>= \_ -> k?
08:33:10 <sjanssen> byorgey: I can't think of any
08:33:17 <ski> btw, 'do (a,b,c) <- ask; return a' is the same as 'liftM (\(a,b,c) -> a) ask'
08:33:21 <byorgey> sjanssen: ok, just curious
08:33:21 <Nopik> probably like \(a, b, c) -> MyMonad a b c d
08:33:34 <opqdonut> m >> k not being m >>= \_ -> k would be kinda weird
08:33:54 <ski> Nopik : what should 'twice' do ?
08:34:08 <vincenz> twice x = x >> x
08:34:21 <vincenz> or
08:34:30 <byorgey> vincenz: I don't think that's what Nopik had in mind
08:34:37 <vincenz> twice x = x >>= \a -> x >>= \b >>= return (a,b)
08:34:51 <vincenz> twice x = x >>= \a -> x >>= \b -> return (a,b)
08:34:59 <Nopik> no, i meant twice to numerically twice its argument, not apply argument twice
08:35:16 <opqdonut> liftM (
08:35:17 <vincenz> twice = 2 * x?
08:35:21 <opqdonut> liftM (*2) -- ::whistle
08:35:25 <mauke> :t join (liftM2 (,))
08:35:28 <lambdabot> forall a2 (m :: * -> *). (Monad m) => m a2 -> m (a2, a2)
08:35:41 <vincenz> noo
08:35:43 <vincenz> the reader monad
08:35:46 <vincenz> readerT monad even
08:35:47 <mrd> :t join . liftM2
08:35:49 <lambdabot> forall a2 r (m :: * -> *). (Monad m) => (a2 -> a2 -> r) -> m a2 -> m r
08:35:56 <byorgey> Nopik: any ideas what the type of twice should be?
08:35:58 <Nopik> i came up with twice (a,b,c) = do return (2*a, 2*b, 2*c) but it do not work :(
08:36:17 <mrd> remove "do return"
08:36:24 <byorgey> Nopik: but twice isn't a function from (a,b,c) -> something, it should be a monadic action
08:36:29 <opqdonut> or just remove do if you wan't it monadic
08:36:39 <mrd> > (1,2,3) &&& ((2*),(2*),(2*))
08:36:40 <lambdabot>   add an instance declaration for (Num (t -> t))
08:36:40 <lambdabot>     In the expression: 2
08:36:48 <mrd> :t (&&&)
08:36:50 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
08:37:00 <mrd> :t (***)
08:37:02 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
08:37:04 <byorgey> mrd: I think you want >>>
08:37:08 <mrd> blarhg
08:37:11 <mrd> :t (>>>)
08:37:13 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
08:37:18 <mrd> > (1,2,3) >>> ((2*),(2*),(2*))
08:37:19 <lambdabot>   add an instance declaration for (Num (t -> t))
08:37:20 <lambdabot>     In the expression: 3
08:37:22 <Nopik> byorgey: i know, but now i cant figure which type monadic action should have here ;p
08:37:31 <byorgey> mrd: except that doesn't quite work either =)
08:37:33 <opqdonut> > fmap (*2) (1,2,3)
08:37:34 <lambdabot>   add an instance declaration for (Functor ((,,) t t1))
08:37:34 <lambdabot>     In the expression...
08:37:44 <opqdonut> gah, (,,) should be a functor
08:37:46 <opqdonut> > fmap (*2) (1,2)
08:37:47 <vincenz> opqdonut: badly typed
08:37:48 <lambdabot>  (1,4)
08:37:50 <mrd> > (1,2) >>> ((*2),(*2))
08:37:51 <lambdabot>   add an instance declaration for (Num (a -> a))
08:37:51 <lambdabot>     In the expression: 2
08:38:00 <opqdonut> vincenz: ah yes, it'd need to be homogenous?
08:38:02 <ski> opqdonut : a trifunctor !
08:38:02 <vincenz> nod
08:38:13 <opqdonut> nvm then :)
08:38:31 <vincenz> ski: Learn the parlance, that's call "Trinctor"
08:38:36 <byorgey> Nopik: here's a hint: twice as a monadic action doesn't actually return anything, it just has a "side effect"
08:38:43 <EvilTerran> newtype Triple a = (a,a,a) could be a functor...
08:38:50 <vincenz> EvilTerran: eww
08:38:57 <vincenz> newtype Triple a = Triple !a !a !a
08:39:00 <ski> vincenz : according to whom !?
08:39:04 <Nopik> byorgey: so, () is involved somewhere ;)
08:39:07 <vincenz> ski: joke :)
08:39:08 <byorgey> Nopik: right.
08:39:10 <mrd> vincenz: newtype supports ! annotations?
08:39:10 <opqdonut> vincenz: yeah that'd work
08:39:20 <mrd> isn't that pointless
08:39:21 <vincenz> mrd: maybe not, nonetheless, you don't want an extra tuple in there
08:39:23 <vincenz> that's just pointless
08:39:40 <EvilTerran> ah, yes, forgot the constructor. but you can't do what you did there, newtypes can only take one parameter
08:39:41 <mrd> oh anyway the constructor of a newtype can't have multiple arguments. moot.
08:39:45 <ski> vincenz : 'Triple' must have exactly one data argument
08:39:50 <vincenz> ski: true
08:39:55 <vincenz> data Triple a = Triple !a !a !a
08:40:09 <EvilTerran> newtype Triple a = Triple (a,a,a); come runtime, it'll be the same as (a,a,a), it just affects typechecking, instances and whatnot.
08:40:14 <opqdonut> newtype Triple a = Triple (!a,!a,!a)
08:40:21 <opqdonut> yeah :)
08:40:22 * ski ponders newtype Foo = F !Foo
08:40:31 <roconnor> cjeris: I discussed with my advisor, and we cannot do it without equicontity.
08:40:48 <ski> equicontity ?
08:40:50 <EvilTerran> surely the !s aren't relevant to its functorness or whatever...
08:40:55 <roconnor> equicontinuity
08:40:59 <vincenz> EvilTerran: nope
08:40:59 <roconnor> I should slow down tying
08:41:01 <roconnor> typing
08:41:03 <roconnor> ugh.
08:41:05 <ski> roconnor : being ?
08:41:05 <vincenz> ski: oy
08:41:40 <roconnor> ski: all functions in the sequence have the same modulus of (uniform) continuity.
08:42:14 <roconnor> cjeris: I thought that continuous function from a compact space to a compact space were compact.
08:42:22 <roconnor> but this isn't true.
08:42:31 <roconnor> cjeris: only equicontinuous bundles are.
08:42:35 <roconnor> or something like that.
08:42:48 <byorgey> Nopik: wait, silly me, you can't implement twice with your monad =)
08:43:00 * ski tries to recall what 'modulus of continuity' is ..
08:43:48 <Nopik> byorgey: i've figured it out ;)
08:43:58 <cjeris> roconnor: did you see above?  i think you _get_ equicontinuity
08:43:59 <ski> (hm, according to Martin Escardo, compactness means universal-quantifiability ..)
08:44:00 <Nopik> byorgey: though finally i got something that compiles :D
08:44:04 <cjeris> or am i full of it?
08:44:10 <roconnor> cjeris: no I missed it.
08:44:14 <roconnor> Let me look.
08:44:27 <Nopik> byorgey: twice = (10,100,1000)  ;)
08:44:44 <Nopik> byorgey: ok, why i cant modify my monad?
08:44:50 <roconnor> cjeris: hmmm
08:45:00 <byorgey> Nopik: if you want to be able to change the state (like twice), you have to do something like MyMonad a b c d = MyMonadC ((a,b,c) -> ((a,b,c),d))
08:45:07 <ski> Nopik : are you trying to modify your enviroment in the monad ?
08:45:25 <ski> maybe you want something like
08:45:37 <Nopik> ski: i am trying modifying anything ;)
08:45:47 <ski> twice ma = local (\(a,b,c) -> (2*a,2*b,2*c)) ma
08:46:01 <Nopik> ski: i just came up with a monad and now explore its possibilities and learn rules how to use it
08:46:31 <ski> twice :: (Num r0,Num r1,Num r2) => Reader (r0,r1,r2) a -> Reader (r0,r1,r2) a
08:46:37 <cjeris> roconnor: or maybe it's something close-to-equicontinuity-but-not-quite ... you may need to go down further to shrink epsilon, but it still holds for a tail
08:47:05 <ski> Nopik : with environments, you can only modify "downwards", with 'local'
08:47:22 <ski> local :: (r -> r) -> Reader r a -> Reader r a
08:48:18 <ski> so if you do 'local f bar', then you make 'bar' see the environment you get from transforming the current environment by 'f' .. but after this has run, the old environment is back again
08:48:25 <roconnor> cjeris: if we have equicontinuity in the tail then we have equicontinuity, becuase there is only a finite number of functions in the head.
08:48:54 <byorgey> Nopik: 'local' is a method from the MonadReader type class
08:49:06 <Nopik> byorgey: yes, i know
08:49:09 <cjeris> roconnor: no... the problem is the size of the tail can keep shrinking with epsilon
08:49:09 <byorgey> Nopik: ok
08:50:10 <ski> > do {x <- ask; y <- local (^2) $ do {z <- ask; return [z]}; w <- ask; return (x,y,w) } `runReader` 4
08:50:11 <lambdabot>  (4,[16],4)
08:50:25 <ski> Nopik : mayhaps that simple example helps ?
08:50:53 <roconnor> cjeris: what do you mean by size?
08:51:00 <Nopik> ski: actually i am not using Reader monad, so local seems unavailable to me.. or it is?
08:51:11 <roconnor> cjeris: BTW, thanks for you help.
08:51:14 <roconnor> your
08:51:18 <mauke> you'll have to write it
08:51:32 <ski> Nopik : do you have 'Reader' or 'ReaderT' somewhere inside your monad ?
08:51:38 <Nopik> ski: no
08:51:47 <Nopik> ski: and no import
08:51:48 <ski> ok
08:51:59 <ski> what is your monad, then ?
08:52:28 <ski> (i thought you were trying to understand how to use 'Reader')
08:52:33 <cjeris> the epsilon/3 argument may require you to go down further to control the distance from f_n to f, so for fixed epsilon you get "|f_n(x) - f_n(x')| < epsilon for all n > N", but N may grow as epsilon shrinks, which is not equicontinuity
08:52:56 <cjeris> it may be enough to conclude that f_n o g_n -> f o g, but it's not equicontinuity
08:53:02 <roconnor> oh
08:53:09 <mrd> "Haskell: What's in your monad?"
08:53:35 <roconnor> cjeris: I think I understand
08:53:42 <Nopik> ski: right now it looks like this: http://hpaste.org/1876
08:53:44 * roconnor ponders if this is good enough.
08:54:11 <shapr> wargh
08:55:18 <yax1> I'm getting this funny error from ghci : "<no location info>: file name does not match module name `Main'"
08:55:30 <ski> Nopik : ok, that is an environment monad, all right
08:55:38 <yax1> i can't work out where it's coming from
08:55:59 <Nopik> ski: so, i should be able to define my own 'local'?
08:56:00 <Nopik> hm
08:56:11 <Nopik> @type Control.Monad.Reader.local
08:56:14 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
08:56:38 <Nopik> @src Control.Monad.Reader.local
08:56:38 <lambdabot> Source not found. That's something I cannot allow to happen.
08:56:46 * roconnor no longers feels dumb for not knowing this answer right away.
08:57:05 <oerjan> yaxu: sounds like a missing module declaration in a file
08:57:13 <cjeris> roconnor: that's the difference between 'trivial' and 'easy' :D
08:57:26 <ski> Nopik : yes, you should be able to do that .. in fact, you should be able to instance 'MonadReader' yourself, with your monad
08:57:48 <yaxu> oerjan: aha, thanks
08:58:20 <oerjan> yaxu: Main is the default module name if you don't include one
08:58:21 <yaxu> oerjan: oops yes a stray character had appeared at the start of a file
09:03:12 <ski> Nopik : do you want to see a sketch of how to do this ?
09:06:07 <mdmkolbe|work> A brain teaser for those that are interested: Everyone knows how to do Fibonacci numbers in one line of Haskell.  But is there a one (or two) liner for Fibonacci *coding* in Haskell?  http://en.wikipedia.org/wiki/Fibonacci_coding
09:06:09 <lambdabot> Title: Fibonacci coding - Wikipedia, the free encyclopedia
09:07:56 <chrismbrown> beelsebob_: dude?
09:08:06 <beelsebob_> lo
09:08:14 <roconnor> cjeris: I'm fairly convinced this is good enough.
09:08:18 <chrismbrown> you msning?
09:08:27 <beelsebob_> yep
09:08:36 <cjeris> roconnor: yay \o\ \o/ /o/ \o/
09:09:30 <roconnor> cjeris: I claim forall e, exists d, N s.t. forall n>N, forall x x', |x - x'| < d then |f_n x - f x'| < e
09:09:46 <roconnor> basically d is the modulus from f
09:09:58 <roconnor> ie d = mu_f (e/3)
09:10:08 <cjeris> right, that's uniform continuity of f combined with uniform convergence f_n -> f.
09:10:13 <roconnor> and then N is from the modulus of convergende of f_n
09:10:15 <wli> mdmkolbe: Let me give it a shot.
09:10:16 <wli> ghci> let { fibs = 1 : 2 : zipWith (+) fibs (tail fibs) ; fibCode 0 = [] ; fibCode n = let f = last $ takeWhile (<=n) fibs in f : fibCode (n - f) } in fibCode 27
09:10:16 <wli> [21,5,1]
09:10:58 <roconnor> Now given such a d, find an M such that forall m > N |g_m - g| < d
09:11:05 <roconnor> er m > M
09:11:20 <blackdog> cjeris: for a second there, i thought you were throwing the horns with an amazingly flexible hand...
09:11:27 <wli> mdmkolbe: Oh, there's a little more needed I guess.
09:11:47 <roconnor> Now use max N, M to get our tail of f_n o g_n
09:13:13 <roconnor> |f_n o g_n - f o g| <= |f_n o g_n - f_n o g| + |f_n o g - f o g|
09:13:13 <mdmkolbe|work> wli: if you trim the list of fibs with (takeWhile (<= n)), then I think you can make that into just one unfold.
09:13:26 <wli> yeah
09:13:31 <cjeris> roconnor: looks good to me!
09:14:18 <roconnor> |f_n o g - f o g| is less than ... well it can be made small.
09:14:30 <roconnor> oh wait
09:14:35 <EvilTerran> :t mapAccumR
09:14:40 <roconnor> I wasn't suppose do split this
09:14:40 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
09:14:59 <roconnor> consider |f_n o g_n - f o g|
09:15:00 <oerjan> > scanl (flip (:)) [] [1..]
09:15:04 <lambdabot>  [[],[1],[2,1],[3,2,1],[4,3,2,1],[5,4,3,2,1],[6,5,4,3,2,1],[7,6,5,4,3,2,1],[8...
09:16:18 <roconnor> consider |f_n (g_n x) - f (g x)|
09:16:40 <roconnor> (g_n x) - (g x) is less than d.
09:17:25 <roconnor> so |f_n (g_n x) - f (g x)| is less than e
09:17:27 <roconnor> as required.
09:17:39 <roconnor> ... I almost believe that.
09:18:22 <byorgey> roconnor, cjeris: OOC, whatcha working on?
09:18:59 <roconnor> byorgey: if f_n converges to f and g_n converges to g, does f_n o g_n converge to f o g.
09:19:11 <roconnor> byorgey: given that everything is continuous an uniform.
09:19:24 <roconnor> (but not necessarily equicontinuous).
09:19:25 <byorgey> roconnor: ah, ok.
09:19:36 <wli> Compact domains too.
09:19:47 <roconnor> oh right, and compact
09:19:49 <byorgey> roconnor: I know enough to understand the question, but not enough to help =)
09:20:31 <roconnor> cjeris: I'll see if I can convince coq of it's truth.
09:20:38 <roconnor> ... maybe tomorrow.
09:23:01 <roconnor> wli: actually compact might not be necessary if we make everything uniformly continuous.
09:23:24 <roconnor> wli: basically I was assuming compactness to force uniformity.
09:26:55 <mdmkolbe|work> > let { fibs = 1 : 2 : zipWith (+) fibs (tail fibs); nfibs = reverse (takeWhile (<=27) fibs); mfibs = 27 : zipWith (\n m -> if n <= m then m - n else m) nfibs mfibs; ofibs = zipWith (/=) mfibs (tail mfibs) } in ofibs
09:26:56 <lambdabot>  [True,False,False,True,False,False,True]
09:27:16 <wli> mdmkolbe: fibs = 1 : 2 : zipWith (+) fibs (tail fibs) ; fibCode' 0 = [] ; fibCode' n = let { (i, f) = last $ takeWhile ((<=n) . snd) $ zip [0..] fibs } in i : fibCode' (n - f) ; fibCode n = case fibCode' n of { [] -> [1] ; fs@(f:_) -> [if k `elem` fs then 1 else 0 | k <- [f,f-1..0]] ++ [1] }
09:28:12 <koala_man> how can I deal with a date like "Wed Jul 25 18:25:29 CEST 2007"? I just can't figure out how to get a ClockTime or CalendarTime from it, and nothing I can find on System.Time helps
09:30:35 <hpaste>  paolino pasted "stack overflow" at http://hpaste.org/1877
09:31:31 <paolino> I 'm trying to solve problem 14 of eulerproject
09:32:16 <paolino> this time haskell is having some problems with me on the console :/
09:32:59 <paolino> until 400000 itś not stack overflowing
09:34:01 <byorgey> paolino: one thing I can see right away is that maximum is not strict
09:34:02 <oerjan> paolino: does it help if you change to Control.Monad.State.Strict?
09:34:26 <byorgey> paolino: use maximum' = foldl1' max
09:34:47 <byorgey> (you'll have to import Data.List for foldl1')
09:34:48 * paolino tries
09:36:26 <byorgey> paolino: also, run k = iterate rule k
09:36:58 <byorgey> paolino: although I don't think that's causing the stack to blow up, I just thought you might like to know the idiom
09:38:25 <paolino> nothing
09:38:34 <paolino> still stack overflow
09:40:00 <psykotic> paolino, ./prog +RTS -K100M :)
09:40:21 <psykotic> the slacker's solution to all stack woes
09:40:49 <vincenz> psykotic: yeah :)
09:40:57 <byorgey> paolino: also, you may want to look into using some sort of Array rather than a list to store cached values
09:40:59 <vincenz> psykotic: damn, it's impressive how insane power-systems are for data-stores
09:41:04 <vincenz> sounds like some matrix thing
09:41:36 <oerjan> vincenz: er, he is using Data.Map
09:41:44 <vincenz> oerjan: what?
09:41:48 <vincenz> oerjan: I was referring to my comment
09:41:57 <vincenz> which is related to a link I pasted in #oasis
09:41:58 <roconnor> cjeris: boy, this question does make a nice homework problem.
09:42:36 <oerjan> vincenz: i was referring to your comment to paolino
09:42:43 <oerjan> er, wait
09:42:45 <vincenz> oerjan: I never commented to paolino
09:42:53 <oerjan> that was to byorgey
09:43:03 <byorgey> oh, oops, I see, Data.Map it is =)
09:44:04 <oerjan> paolino: i am wondering if that break could be expensive on the stack .. the first part builds some heavy thunks
09:44:29 <oerjan> *could build
09:44:36 <byorgey> maybe make sure rule is strict? would that help?
09:44:46 <byorgey> rule !n | odd n = ...
09:45:04 <oerjan> nah, rule is definitely strict already
09:45:13 <byorgey> oerjan: ok.
09:46:45 <psykotic> roconnor, what was the problem?
09:46:46 <paolin1> damnd gprs
09:47:10 <oerjan> paolin1: did you see my comment about checking out the break?
09:47:16 <roconnor> psykotic:  if f_n converges to f and g_n converges to g, does f_n o g_n converge to f o g.
09:47:18 <paolin1> no
09:47:25 <roconnor> psykotic: given that everything is continuous an uniform.
09:47:34 <roconnor> (but not necessarily equicontinuous).
09:47:36 <psykotic> roconnor, no, it seems clear you need equicontinuity
09:47:51 <roconnor> psykotic: We seem to have a proof without it.
09:47:54 <psykotic> hmm
09:47:56 <oerjan> i think for long lists, computing the first element of a break can be hard on the stack
09:48:12 <oerjan> or perhaps both
09:48:16 <byorgey> @src break
09:48:16 <lambdabot> break p =  span (not . p)
09:48:21 <roconnor> cjeris did most of the smartness
09:48:21 <byorgey> @src span
09:48:21 <lambdabot> Source not found. My mind is going. I can feel it.
09:48:56 <roconnor> psykotic: I'll run it through Coq tomorrow, so we will know better.
09:49:56 <paolin1> oerjan, I was happy to find "break" function, how I change that ?
09:50:02 <oerjan> you can make a tail recursive break if you permit the first element to be reversed.
09:50:37 <cjeris> psykotic: it seems like what you actually need is close to equicontinuity, but enough weaker that you can get it from roconnor's hypotheses.
09:51:30 <paolin1> oerjan, I don't have a background to understand that
09:52:22 <oerjan> break_ p l = br' [] l where br' l1 [] = (reverse l1, []); br' l1 l2@(x:r) | p x = (reverse l1, l2) | otherwise = br' (x:l1) l2
09:52:42 <oerjan> or something close to that
09:53:53 <paolin1> thanks , I try to understand that
09:53:55 <byorgey> paolin1: also, since you don't actually care about the first part of the break, only its length, you might be able to write a specialized version of break which returns the length of the first part together with the second part as a list.
09:54:16 <oerjan> right, you can do:
09:55:04 <oerjan> hm, be careful so the length doesn't get nonstrict
09:56:00 <ndm> hmm, is it just me, or do the views proposals seem "non obvious" - i.e. when i see view code, i can't figure out what it does
09:56:21 <ndm> its entirely possible i may be able to learn what views do, but they don't "snap" like most of Haskell does
09:56:26 <ndm> compared to say pattern guards
09:56:32 <Nopik> ok, i managed to have this:  withMyMonad f m = MyMonadC $ runMyMonad m . f                do (a,b,c) <- withMyMonad (\(a,b,c)->(2*a,2*b,2*c)) $ do a <- ask2; return a
09:56:40 <dcoutts> ndm: and I worry about repeating computations, unlike with case
09:56:42 <Nopik> withMyMonad is just like withReader
09:56:47 <Nopik> but i cant get local working..
09:56:57 <ndm> dcoutts, only an issue if you consider efficiency important
09:57:03 <Nopik> local f m = m . f  but i cant use it at all
09:57:10 <Nopik> how should i use it in my do block?
09:57:12 <dcoutts> ndm: heh, I do. :-) You do too I note.
09:57:44 <ndm> dcoutts, i'm still not sure if i do - I use Hugs all day, and couldn't care less, but if efficiency is not important then chapter 3 of my PhD isn't important either...
09:58:01 <oerjan> what you really would want is something that does both find and findIndex simultaneously...
09:58:08 <ndm> plus i'm now micro-optimising prelude functions, hardly the behaviour of a Hugs user
09:58:35 <dcoutts> ndm: surely that's even more important if you're using hugs ;-)
09:58:58 <ndm> dcoutts, optimising Hugs to call isSpace less is probably irrelevant
09:59:02 <xerox> Nopik: instantiate MonadReader MyMonad
09:59:16 <Nopik> xerox: but i want to do it myself, not using mtl
09:59:25 <Nopik> xerox: just for educational purposes
09:59:33 <ndm> i have actually started unoptimising some Yhc prelude functions, which had special cases added in, to make them more regular
09:59:37 <fasta> Is Hugs still being developed?
10:00:02 <Nopik> byorgey: any idea? :)
10:00:03 <byorgey> Nopik: hm, I don't think local f m = m . f is right
10:00:06 <dcoutts> fasta: no, it's being maintained
10:00:22 <Nopik> byorgey: hm, i took it from MonadReader i think
10:00:41 <byorgey> Nopik: really?  hang on
10:00:44 <Nopik> byorgey: Reader actually
10:00:52 <ndm> unfortunately GHC is the only "alive" Haskell compiler
10:01:25 <fasta> dcoutts: doesn't that mean Hugs will be obsolete when ATs are implemented?
10:01:27 <oerjan> paolin1: breakN p l = br' 0 l where br' n [] = (n, []); br' n l2@(x:r) | p x = (n, l2) | otherwise = n `seq` br' (n+1) r
10:01:41 <dcoutts> fasta: if you think ATs are that important, yes.
10:01:48 <fasta> Well, maybe Hugs is now already.
10:01:53 <oerjan> also, at my previous suggestion the last l2 should be r
10:01:59 <fasta> Considering that my code cannot be handled by Hugs.
10:02:34 <fasta> GHC lifts lots of restrictions (making Haskell practical in the process)
10:02:48 <byorgey> Nopik: oh, I see.  that's the implementation of local for the particular instance ((->) r)
10:03:13 <byorgey> Nopik: that is, any function which takes an r can be considered a simple instance of a Reader monad.
10:03:43 <Nopik> byorgey: hm, ok, got an idea, hold on ;)
10:03:44 <ndm> fasta: i write code in Hugs, my code is perfectly practical
10:03:50 <fasta> ndm: how did you structure your code?
10:03:59 <ndm> fasta: purely functionally
10:04:10 <fasta> ndm: no monads?
10:04:24 <ndm> fasta: some, not massive numbers, the odd state monad here and there
10:04:46 <fasta> ndm: your code is already available, right?
10:04:52 <ndm> certainly no MTL, FD, MPTC
10:05:12 <Nopik> erm, no
10:05:12 <fasta> I am amazed you can actually build something without that.
10:05:22 <ndm> fasta: yep, piles of it http://www-users.cs.york.ac.uk/~ndm/downloads/ - 15 darcs repos on that page
10:05:23 <lambdabot> Title: Neil Mitchell - Downloads
10:05:29 <fasta> Theoretically you can, but practically... well.
10:05:29 <koala_man> is there a strptime equivalent?
10:05:37 <Nopik> byorgey: i still have no idea what is going on here ;(
10:05:45 <ndm> plus there are a few other things not on that page
10:06:05 <fasta> ndm: what's your most complicated code?
10:06:08 <ndm> plus i've done a tiny amount of commercial Haskell programming, which isn't available
10:06:18 <ndm> Catch is ~10,000 lines
10:06:21 <fasta> ndm: I would like to have a look at that.
10:06:23 <fasta> ndm: ok
10:06:24 <ndm> Yhc.Core is huge
10:06:35 <dcoutts> fasta: we did write code for 10 years before and up to Haskell 98 you know :-)
10:06:45 <dcoutts> fasta: ie without MTPC+FD
10:06:48 <ddarius> ndm: You are not alone in disliking views.
10:06:50 <fasta> ndm: not "huge", "complicated".
10:06:58 <fasta> dcoutts: maybe I write more generic code than you
10:07:11 <ndm> fasta: code being complicated is usually a reason to simplify code
10:07:12 <ddarius> fasta: I doubt either of those would be considered "simple"
10:07:13 <savanni> Very quick question: how can I convert from an Int to a Float?
10:07:24 <ndm> @hoogle Int -> Float
10:07:24 <lambdabot> No matches, try a more general search
10:07:25 <glguy> fromIntegral
10:07:31 <savanni> Ah!
10:07:49 <ddarius> For future reference, if the question start "how can I convert..." the answer is fromIntegral
10:08:02 <SamB> ddarius: not necessarily!
10:08:05 <dcoutts> fasta: don't get me wrong, it's great that new language features allow us to write in new interesting styles
10:08:08 <ndm> hoogle on the web gives toEnum
10:08:12 <ndm> which actually works!
10:08:22 <ddarius> SamB: True, but 99 times out of 100
10:08:26 <SamB> true
10:08:43 <savanni> Even if fromInteger also works?
10:08:46 <ndm> toInteger/fromInteger are what i always go for
10:08:51 <CosmicRay> @seen syntaxninja
10:08:52 <lambdabot> I saw syntaxninja leaving #haskell, #darcs, #haskell-blah and #haskell-soc 16h 48m 54s ago, and .
10:08:56 <CosmicRay> doh
10:08:58 <ddarius> An Int is not an Integer.
10:09:00 <ndm> savanni: fromInteger takes an Integer, not an Int, fromIntegral does both
10:09:01 <savanni> I knew about fromInteger but must fromIntegral so far.
10:09:12 <ndm> @type fromInteger
10:09:13 <savanni> Err... s/must/missed/
10:09:14 <lambdabot> forall a. (Num a) => Integer -> a
10:09:16 <ndm> @type fromIntegral
10:09:17 <lambdabot> forall a b. (Num b, Integral a) => a -> b
10:09:21 <glguy> CosmicRay: I todl him yo uwere looking for him
10:09:25 <oerjan> both fromInteger and toInteger are special cases of fromIntegral, not?
10:09:29 <glguy> CosmicRay: he'll be on in a few
10:09:29 <bos> guten fnorgen.
10:09:38 <CosmicRay> whoa
10:09:40 <ndm> oerjan: not toInteger
10:09:41 <CosmicRay> bos!
10:09:44 <SyntaxNinja> I hear someone is looking for me...
10:09:46 <ndm> @type toInteger
10:09:47 <lambdabot> forall a. (Integral a) => a -> Integer
10:09:56 <bos> CosmicRay: yep, got your email
10:10:08 <bos> SyntaxNinja: CosmicRay and i are at lloyd center in portland
10:10:13 <oerjan> ndm: sure it is
10:10:21 <fasta> ndm: Do you also have like... documented what it is you are doing in that code?
10:10:23 <CosmicRay> simonpj too
10:10:29 <SyntaxNinja> lloyd center, or the conference center?
10:10:30 <ndm> fasta: in Catch?
10:10:32 <fasta> ndm: i.e. what its purpose is etc.
10:10:34 <fasta> ndm: yes
10:10:40 <CosmicRay> SyntaxNinja: hotel is at lloyd, convention is at conference center
10:10:45 <bos> SyntaxNinja: um, probably the conference center
10:10:48 <ndm> fasta: http://www-users.cs.york.ac.uk/~ndm/downloads/draft-catch-15_jun_2007.pdf
10:10:50 <lambdabot> http://tinyurl.com/2thgrv
10:10:53 <fasta> ndm: Without any documented purpose it's impossible to read code.
10:10:55 <SyntaxNinja> coolness. we should meet up.
10:10:55 <bos> CosmicRay: where are you?
10:10:59 <bos> yes!
10:11:04 <fasta> ndm: I mean on a module per module basis
10:11:10 <CosmicRay> bos: a few rows in front of the big screen hanging down in the middle
10:11:11 <ndm> not really, no
10:11:12 <Nopik> ok, i'm finishing for today ;p
10:11:13 <ddarius> The documentation format of Haskell: research papers.
10:11:15 * wli is planning to go to the Lloyd Center for unrelated reasons later today.
10:11:18 <Nopik> bye, and thanks for help
10:11:21 <CosmicRay> and man, I'm fired up about STM now.  sounds awesome.
10:11:32 <wli> CosmicRay: STM?
10:11:34 <ndm> each module is one function, each function is documented in teh paper, therefore you can read the paper like module-by-module documentation
10:11:41 <CosmicRay> software transactional memory (there's STM in Haskell)
10:11:49 <SyntaxNinja> CosmicRay: wli, bos: so should we get together tonight?
10:11:55 <bos> SyntaxNinja: +1 !
10:11:57 <fasta> ndm: ok, hmm, I guess that's an academic strategy.
10:11:57 <ddarius> SPJ is giving a talk about it at OSCON (among other things)
10:12:27 <SyntaxNinja> I almost went to oscon, but then I didn't.
10:12:37 <wli> OSCON is pricey.
10:12:40 <CosmicRay> SyntaxNinja: that would be great.  simonpj is doing a bof at 7:30pm tonight but could skip that, or we could go before/after/different day
10:12:41 <SyntaxNinja> ja
10:12:44 <bos> i talked to a few people who went to monday's haskell/xmonad tutorial. they said their brains got very full.
10:12:50 <SyntaxNinja> bof?
10:12:54 <bos> birds of a feather
10:13:04 <glguy> birds of a feather?
10:13:08 <bos> CosmicRay: what's the bof topic?
10:13:10 <CosmicRay> SyntaxNinja: Birds-of-Feather -- ad-hoc things that conference attendees organize.  public is welcome.
10:13:22 <CosmicRay> bos: let me get th elink
10:13:26 <bos> glguy: everybody gets together and pulls feathers off a bird. it's very cruel.
10:13:27 <SyntaxNinja> hmm
10:13:34 <SyntaxNinja> sot he bof is free? maybe I should go?
10:13:44 <SyntaxNinja> birds off a feather
10:13:46 <CosmicRay> http://conferences.oreillynet.com/cs/os2007/view/e_sess/14746
10:13:48 <lambdabot> Title: O'Reilly Open Source Convention 2007 &#8226; July 23-27, 2007 &#8226; Portland,  ...
10:13:49 <CosmicRay> Beautiful Code
10:13:56 <ddarius> "Birds of a feather, flock together"
10:13:59 * wli could show up, but would rather not be disruptive.
10:13:59 <oerjan> @remember bos glguy: everybody gets together and pulls feathers off a bird. it's very cruel.
10:13:59 <lambdabot> Done.
10:14:02 <bos> oh, i hope it's not going to be 60 minutes of secret santas
10:14:04 <CosmicRay> I am not entirely sure if this is happening at the Powell's bookstore at the convention, or at the Powell's store in Pearl
10:14:08 <CosmicRay> but it sounds like the convention
10:14:24 <ddarius> wli: Why do you think you'd be disruptive?
10:14:34 <wli> ddarius: Appearance.
10:14:37 <bos> oh, it's going to be a panel session. forget it, then :-)
10:14:41 <ddarius> wli: Why do you think you'd be disruptive?
10:14:59 <CosmicRay> bos: yeah but Ward Cunningham and Greg K-H will be there ;-)
10:15:00 <bos> wli: you can't possibly look weirder than the rest of the OSCON attendees
10:15:00 <ddarius> (And yes, I have seen a picture of you.)
10:15:05 <wli> ddarius: Well, I'll show up.
10:15:18 <CosmicRay> but that's fine, it's not a huge big deal to me
10:16:31 <CosmicRay> SyntaxNinja, bos: so are you guys both available this evening?
10:16:50 <SyntaxNinja> wli: I wouldn't worry about it.
10:16:55 <bos> CosmicRay: yes, definitely
10:17:03 <SyntaxNinja> CosmicRay: yeah, can be.
10:17:30 <SyntaxNinja> CosmicRay: should I go to the BOF or should we meet up for dinner?
10:17:44 <SyntaxNinja> well, ikt's jst an hour, sounds cool. maybe we should meet at bof and then get dinner
10:18:01 <SyntaxNinja> I can'T tell from the description whether it's at the technical bookstore or elsewhere
10:18:06 <CosmicRay> SyntaxNinja: I'd be fine with dinner before, after, during, or instead of the bof ;-)
10:18:12 <bos> it is at the bookstore, i believe.
10:18:30 <CosmicRay> bos: it says it's at the "technical bookstore"
10:18:36 <CosmicRay> I could just go over and ask.
10:18:46 <bos> likewise. i'm not going to the bof, but i've got no other plans, so my time is free.
10:19:13 <fasta> "darcs one of the most successfull" <- that is a good joke
10:19:13 <CosmicRay> bos: are you still in the keynote?
10:19:17 <SyntaxNinja> yeah, I'm at the bookstore site and it sounds ike it's at the store
10:19:25 <SyntaxNinja> in case you haven't notcied, tehre are 2 powell's stores in the pearl
10:19:25 <bos> CosmicRay: didn't go to the keynotes.
10:19:31 * fasta reading ndm's stuff
10:19:53 <bos> CosmicRay: i'm at the row of tables next to the book sales area
10:20:17 <CosmicRay> SyntaxNinja: what
10:20:31 <CosmicRay> SyntaxNinja: what's good in pearl, restaurant-wise?  I keep hearing about Jake's but that's all I know
10:20:39 <SyntaxNinja> CosmicRay: OK, so how 'bout we meet up for dinner before the bof, then go to the bof together, then maybe get drinks.
10:21:05 <bos> SyntaxNinja: sounds like a plan.
10:21:29 <SyntaxNinja> CosmicRay: I don't know the pearl restaurants too well except for a fancy one... there's a pretty good Peruvian place and a Pho Van, I think.
10:21:44 <CosmicRay> sounds good.  my wife and son are here with me, so dunno if I'll make drinks late but certainly the rest
10:22:15 <CosmicRay> don't let me make y'all go to the bof if you're not interested, it's not a big deal.  but it had simonpj so I just thought hey, may be interesting ;-)
10:22:28 <CosmicRay> rats, I lost track of simon, was going to ask him
10:22:38 <CosmicRay> oh there he is
10:22:58 <CosmicRay> what time are you guys done with work or the sessions you want to go to?
10:23:07 <SyntaxNinja> actually, this place is good: http://www.saucebox.com/
10:23:09 <lambdabot> Title: saucebox :: since 1995
10:23:21 <SyntaxNinja> actually downtown, but really, powell's technical is more like downtown than pearl.
10:23:54 <CosmicRay> sounds interesting
10:23:56 <SyntaxNinja> CosmicRay: maybe we could see how much fun we're having at saucebox and then decide
10:23:58 <SyntaxNinja> it's a bit pricy
10:24:11 <CosmicRay> sounds fine to me
10:24:45 <CosmicRay> is the noise level in there low enough that it doesn't prevent conversation? ;-)
10:25:48 <SyntaxNinja> shouldn't be too bad on a wed, I'd think.
10:25:58 <SyntaxNinja> actually, tha'ts perfect it's like 2 blocks away
10:26:24 <ndm> fasta: comments welcome, although that paper is probably not going to end up getting published in that form
10:26:45 <CosmicRay> bos: you going to simon's talk this pm?
10:26:46 <SyntaxNinja> what time is good? I'm thinking 6:00?
10:26:52 <SyntaxNinja> we might want reservations.
10:26:55 <CosmicRay> that's fine by me
10:27:40 <fasta> ndm: if darcs is one of Haskell's most successfull projects, Haskell is a weak language, considering that darcs is loaded with hard to find bugs.
10:28:01 <ndm> fasta: don't judge a language by a single project
10:28:18 <ndm> fasta: and darcs uses many GHC extensions, do they enable darcs, or hold it back from being more beautiful?
10:28:19 <opqdonut> fasta: loaded? isn't there just one design error?-)
10:28:22 <SyntaxNinja> CosmicRay: should I call? who all is in for saucebox?  wli? glguy? CosmicRay? bos?
10:28:25 <byorgey> @seen Nopik
10:28:25 <lambdabot> I saw Nopik leaving #haskell 14m 6s ago, and .
10:28:26 <ndm> plus Haskell is great for refactoring
10:28:31 <CosmicRay> should I invite simonpj?
10:28:34 <fasta> opqdonut: have you ever seen the darcs BTS?
10:28:38 <SyntaxNinja> CosmicRay: sure.
10:28:52 <roconnor> @type toInteger
10:28:55 <lambdabot> forall a. (Integral a) => a -> Integer
10:28:58 <roconnor> @type fromInteger
10:29:00 <lambdabot> forall a. (Num a) => Integer -> a
10:29:03 <byorgey> @tell Nopik sorry about that, my work internet connection went down again
10:29:03 <lambdabot> Consider it noted.
10:29:04 <opqdonut> fasta: let me check
10:29:08 <roconnor> ah, different constrains
10:29:38 <roconnor> @info Intergral
10:29:38 <lambdabot> Intergral
10:29:52 <CosmicRay> SyntaxNinja: would anyone object if my wife & 9-month-old tagged along?
10:30:03 <roconnor> @info Integral
10:30:04 <lambdabot> Integral
10:30:04 * glguy had an Ultimate frisbee game planned tonight but could put it off
10:30:07 <CosmicRay> dunno if she's interested, but she likes hanging out with people "more geeky" than she is ;-)
10:30:10 <wli> SyntaxNinja: Count me in.
10:30:21 <crazy_coder> who won ICFP ?
10:30:30 <glguy> crazy_coder: unknown
10:30:33 <crazy_coder> haskell again ?
10:30:43 <SyntaxNinja> glguy: don't get me in trouble for pulling you away from frisbee ;)
10:31:00 <DukeDave> Okay, I'm so confused; can anyone point me to a nice GLUT tutorial?
10:31:02 <fasta> ndm: why did you write your own constraint solver?
10:31:05 <glguy> I'll just tell Dana that you required me to come as my project lead
10:31:07 <CosmicRay> I'm going to try to run up and talk to simonpj, i'll be disconnected until 10:45...
10:31:13 <SyntaxNinja> CosmicRay: ok
10:31:17 <fasta> ndm: did you try with existing systems first?
10:31:17 * rho is away: getting ice cream
10:31:21 <SyntaxNinja> CosmicRay: fyi saucebox might not be great for kids, lemmy think some more.
10:31:49 <roconnor> @go GLUT tutorial
10:31:52 <lambdabot> http://www.lighthouse3d.com/opengl/glut/
10:31:52 <lambdabot> Title: OpenGL @ Lighthouse 3D - GLUT Tutorial
10:31:53 * bos foolishly went looking for CosmicRay without knowing what he looks like or where he is
10:31:57 <ndm> fasta: because they don't have the right properties i need, they aren't designed for discrete data types like Haskell
10:32:00 <glguy> @go go gadget arms
10:32:02 <lambdabot> http://en.wikipedia.org/wiki/Inspector_Gadget
10:32:02 <lambdabot> Title: Inspector Gadget - Wikipedia, the free encyclopedia
10:32:36 <bos> CosmicRay: want to meet somewhere specific? :-)
10:32:44 <fasta> ndm: AFAIK, something like Otter can solve your problems.
10:33:47 <ski> inspector gadget, yay !
10:34:07 <ndm> fasta: i'll take a look
10:35:49 <DukeDave> roconnor: I was thinking more, for Haskell?
10:35:51 <hpaste>  desp pasted "ghc-6.6.1 build error" at http://hpaste.org/1878
10:36:57 <SyntaxNinja> do you think 10-12 blocks is too far from powells?
10:39:36 <SyntaxNinja> OK let's take this out of chan.  wli glguy CosmicRay bos andyjgill: /join #haskell-meetup.
10:39:53 <SyntaxNinja> (and anyone else in portland this eve who wants to join)
10:40:20 <glguy> if you cared you'd just /invite us ;)
11:01:06 * Nafai wishes there was a Haskell or FP usergroup in Austin
11:13:24 <cytzol> Is there a way to 'register' something as being installed? I just built happy but ./Setup.lhs configure can't seem to find it
11:13:41 <cytzol> register... I don't know the terminology
11:13:48 <dozer> cytzol: have you done ./Setup.lhs install?
11:13:53 <cytzol> yes
11:14:02 <mdmkolbe|work>  cytzol: is happy in your path?
11:14:13 <mdmkolbe|work> cytzol: (I assume you are on linux)
11:14:30 <sjanssen> cytzol: see configure --help
11:14:36 <sjanssen> especially --with-happy
11:14:53 <sjanssen> cytzol: it should be found automatically if it's in your PATH, though
11:15:23 <cytzol> ./Setup.lhs install puts something in /usr/local/bin/ but nothing....... oh wait
11:16:29 <cytzol> yeah, for some reason that wasn't in path, thanks
11:17:20 <cytzol> didn't realise happy was a binary
11:27:24 <wli> Is x >>= f == join $ fmap f x in general?
11:28:13 <mdmkolbe|work> @type fmap
11:28:22 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:28:43 <wli> @pl \f x -> join (fmap f x)
11:28:44 <lambdabot> (=<<)
11:29:07 * wli takes lambdabot's answer as a yes.
11:29:10 <mdmkolbe|work> wli: there is a formalization of monads in terms of join and (I think) fmap, so I think they are equal in general
11:29:37 <oerjan> indeed, that is closer to the original category theory formulation
11:29:41 <wli> join, return, and fmap.
11:30:10 * wli seems to understand things vastly better in terms of join, return, and fmap.
11:33:58 * rho is back
11:34:06 <byorgey> can anyone think of a nice simple type which is not an instance of Ord?
11:34:55 <byorgey> I'm trying to test something but blanking on something non-Ord to use
11:36:10 <byorgey> ah, Complex works
11:36:34 <wli> A canonical injection, an fmap, and an isomorphism from (M (M x)) to M x.
11:36:36 <roconnor> Int -> Int
11:36:52 <roconnor> IO ()
11:36:56 <roconnor> :)
11:37:32 <EvilTerran> newtype UnOrd a = UnOrd a {- not deriving Ord -}
11:38:09 <roconnor> Does darcs count as a whole tree version control?
11:38:19 <roconnor> can it track movement of code between files?
11:38:30 * roconnor thinks so
11:39:23 <wli> Structure editors are better ideas along those fronts.
11:39:58 <roconnor> wli:  I totally agree
11:40:15 <roconnor> I was thinking distributed version control needs editor support.
11:40:38 <roconnor> and probably languages support too.
11:41:05 <wli> Structure editors track and generate changes in terms of abstract syntax tree transformations.
11:41:08 <byorgey> EvilTerran: heh =)
11:41:12 <roconnor> I need to write my blog post on why Arch sucks.
11:41:49 <malsyned> Is there a perl-compatible regular expression package for Haskell?
11:41:54 <wli> They're not RCS/VCS per se.
11:42:21 <mrd> malsyned: there's a variety of regex packages, some builtin to ghc, some i think as a separate package. see Hackage.
11:43:37 <newsham> goto considered harmful http://xkcd.com/292/
11:43:38 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
11:43:49 <wli> If you were to rename something, it would understand the scope of the variable being renamed etc.
11:44:10 <wli> If you were to add arguments to something it'd know where all its callsites were.
11:44:30 <kolmodin> ?localtime
11:44:33 <lambdabot> Local time for kolmodin is Wed Jul 25 20:35:58 2007
11:44:44 <wli> If you were to add a new constructor for a type, it would know where case statements needing updates are.
11:44:45 <roconnor> maybe even support program transformation... Mmmm
11:44:56 <roconnor> Like ndm's optimization of words.
11:45:00 <wli> roconnor: Not "support," they're defined in terms of such.
11:45:30 <roconnor> basically we all need to be using epigram, ... for many reasons.
11:45:45 <ndm> wli: Catch would do that already
11:45:56 <ndm> roconnor: i am working on something to support program transformation
11:46:07 <ndm> roconnor: http://www-users.cs.york.ac.uk/~ndm/temp/proof.png
11:46:19 <ndm> that is me attempting to prove my words optimisation
11:46:24 <ndm> in the proof tool i wrote
11:46:45 <wli> ndm: I'm not familiar with Catch.
11:47:04 <ndm> @where Catch
11:47:05 <lambdabot> http://www.cs.york.ac.uk/~ndm/projects/catch.php
11:47:10 <opqdonut> is there an alternative to happs? something simpler perhaps (pun not intended)
11:47:17 <ndm> wli: it detects potential pattern match errors in your code
11:47:51 <wli> ndm: Well, that's not quite what structure editors are about.
11:48:41 <wli> ndm: The idea is that changes are defined in terms of higher-level things than text editing, and for things like adding a new case, it prompts the user to go handle every instance where the new case must be handled etc.
11:49:11 <ndm> wli: yeah, its not an editor, its a prover
11:50:04 <wli> There are other things like canned transformations for small pieces of code. In imperative languages, interchanging loops and the like are there.
11:51:21 <opqdonut> ?where hxweb
11:51:21 <lambdabot> http://darcs.haskell.org/~lemmih/hxweb
11:51:24 <mrd> opqdonut: yes there's some other libraries
11:51:30 <mrd> see haskell.org
11:51:33 <wli> Also breaking off snippets of code into their own functions.
11:51:35 <opqdonut> bah, only source
11:51:40 <opqdonut> ?where cgi
11:51:40 <lambdabot> I know nothing about cgi.
11:52:15 <wli> AIUI the Microsoft structure editor(s) literally do highlight, drag, and drop for such.
11:52:38 <opqdonut> and no docs for Network.CGI
11:52:57 * wli is not sure whether it's shipped with Visual Studio or what, though.
11:53:05 <lnagy> Hi!
11:53:31 <byorgey> hi lnagy.
11:53:58 <wli> For Haskell you'd highlight a subexpression and drop it into a where clause or the top level, and would then get prompted for a name.
11:54:21 <lnagy> I'm struggling with a performance problem regarding copying large chunks of elements in an unboxed array.
11:54:40 <lnagy> I would like to get close to the speed of C's memcpy but I simply cannot.
11:54:59 <mrd> @paste
11:54:59 <lambdabot> Haskell pastebin: http://hpaste.org/new
11:55:35 <ndm> wli: the Microsoft structure editors? have you used such things?
11:55:48 <ndm> its certainly not in Visual Studio 2003
11:55:57 <wli> ndm: I've never used it/them. I've only seen demos.
11:56:51 <mrd> lnagy: have you tried unsafeWrite/unsafeRead btw?
11:57:00 <lnagy> Of course :)
11:57:38 <byorgey> lnagy: try veryVeryUnsafePerformMagic.  usually works for me. =)
11:57:56 <lnagy> Also, when profiling, my memcopy function seems to be doing a lot of allocation.
11:58:04 <lnagy> No idea why.
11:58:12 <mrd> got anything to paste?
11:58:17 <lnagy> Yep.
11:58:21 <mrd> [h]paste
11:58:32 <lnagy> memcdec' a1 a2 i1 i2 len = memc (len - 1)
11:58:32 <lnagy>   where
11:58:32 <lnagy>     memc l | l < 0 = return ()
11:58:32 <lnagy>            | otherwise = do
11:58:35 <lnagy>       { unsafeRead a1 (i1 + l) >>= unsafeWrite a2 (i2 + l)
11:58:38 <lnagy>       ; memc (l-1)
11:58:41 <lnagy>       }
11:58:44 <lnagy>  
11:58:48 <mrd> i guess i didn't quite make myself clear
11:58:53 <lnagy> Both arrays are IOUArray Int Int8
11:59:02 <olsner> @paste
11:59:02 <lambdabot> Haskell pastebin: http://hpaste.org/new
11:59:21 <olsner> ^ use that instead of pasting text into the channel
12:00:02 <lnagy> Sorry.
12:00:05 <lnagy> Newbie.
12:00:33 <lnagy> So how do I paste using @paste?
12:00:49 <mrd> visit that url
12:00:59 <lnagy> Ah.  Silly me.
12:01:16 <lightstep> i think unboxed arrays are not so fast in ghc, and there's an alternative array library instead
12:01:29 <mrd> hm. shouldn't it be possible to get a Ptr and use memcpy directly?
12:01:59 <hpaste>  lnagy pasted "(no title)" at http://hpaste.org/1879
12:02:54 <lightstep_> perhaps MutableArray# or MutableByteArray#
12:03:28 <lnagy> Using memcpy would be the best, obviously, but how?
12:03:30 <mrd> there is Data.Array.Base.memcpy which operates on primitive arrays
12:04:14 <sjanssen> @hoogle memcpy
12:04:14 <lambdabot> No matches found
12:04:22 <sjanssen> @hoogle copyArray
12:04:22 <lambdabot> Foreign.Marshal.Array.copyArray :: Storable a => Ptr a -> Ptr a -> Int -> IO ()
12:04:51 <mauke> @hoogle move
12:04:51 <lambdabot> Foreign.Marshal.Array.moveArray :: Storable a => Ptr a -> Ptr a -> Int -> IO ()
12:04:51 <lambdabot> Foreign.Marshal.Utils.moveBytes :: Ptr a -> Ptr a -> Int -> IO ()
12:04:51 <lambdabot> System.Win32.File.moveFile :: String -> String -> IO ()
12:05:19 <mauke> @type Foreign.Marshal.Utils.copyBytes
12:05:21 <lambdabot> forall a. GHC.Ptr.Ptr a -> GHC.Ptr.Ptr a -> Int -> IO ()
12:06:00 <sjanssen> copyBytes == memcpy
12:10:09 <sjanssen> lnagy: that is about the best you can do without getting pretty extreme
12:10:11 <sjanssen> @users
12:10:11 <lambdabot> Maximum users seen in #haskell: 367, currently: 363 (98.9%), active: 20 (5.5%)
12:10:41 <sjanssen> lnagy: memcpy isn't really an option, because the garbage collector can move the data around during the foreign call
12:10:52 <sjanssen> (unless you use StorableArray)
12:11:08 <mrd> hm. it might be better expressed with sequence_. notes in Base.hs seem to indicate it should be optimized as such
12:12:07 <sjanssen> sequence_ shouldn't help much here
12:12:20 <sjanssen> I think those comments are hinting that sequence_ will fuse with [n..m :: Int]
12:12:39 <sjanssen> so you could write it more succinctly, but you'd still have about the same performance
12:14:22 <hpaste>  mrd annotated "(no title)" with "one quick improvement" at http://hpaste.org/1879#a1
12:14:49 <sjanssen> that strictness annotation shouldn't change anything
12:14:51 <mrd> lnagy: you are using optimizations enabled right?
12:15:05 <lnagy> Yes.
12:15:05 <sjanssen> the function is already strict in 'l' due to the comparison with zero
12:15:12 <mrd> ah true
12:15:25 <sjanssen> lnagy: what type of array are you copying?
12:15:35 <lnagy> IOUArray Int Int8
12:15:39 <lnagy> Simplest possible :)
12:16:34 <lnagy> One question though: when I profile it, 90% of time is spent copying the array, and that's fine, but it also uses 90% of allocations.  Why?
12:17:28 <olsner> > undefined == undefined
12:17:33 <lambdabot>  Undefined
12:18:37 <hpaste>  emu annotated "(no title)" with "rewritten with forM_" at http://hpaste.org/1879#a2
12:18:55 <mrd> that's just for the sake of one-lining it =)
12:19:40 <lnagy> Length can be in the millions, isn't that a problem?
12:19:47 <mrd> nope
12:19:53 <lnagy> Why?
12:20:02 <lnagy> You still have to allocate cons cells, right?
12:20:09 <sjanssen> lnagy: there is an allocation of an Int8 when reading from the array
12:20:12 <olsner> wouldn't it be sensible for == to compare thunk pointers first?
12:20:16 <sjanssen> @src forM_
12:20:17 <lambdabot> forM_ = flip mapM_
12:20:20 <sjanssen> @src mapM_
12:20:20 <lambdabot> mapM_ f as = sequence_ (map f as)
12:20:25 <sjanssen> @src sequence_
12:20:25 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
12:20:30 <mauke> olsner: how would you code that?
12:20:45 <mrd> lnagy: it's negligible due to laziness, basically
12:20:47 <sjanssen> lnagy: there aren't any cons cells allocated, because forM_ will fuse with the [n..m]
12:20:52 <olsner> mauke: with magic!
12:21:20 <lnagy> I see.
12:21:24 <sjanssen> olsner: no, because sometimes x /= x
12:21:57 <mrd> lnagy: is your GC time too large a %?
12:22:04 <olsner> oh, you mean things like NaN?
12:22:10 <sjanssen> lnagy: if you want to do this really really quickly, use StorableArray and copyArray
12:22:29 <mrd> lnagy: run your program with +RTS -sstderr
12:22:42 <sjanssen> olsner: yeah, that's one
12:22:48 <mrd> if the GC time % is low, then the allocation probably isn't an issue
12:22:56 <lnagy> Well, yes.  And now I understand why: it allocates a lot of memory while copying and then reclaims it.  Pretty wasteful.
12:23:17 <mrd> generational GC is adept at dealing with that kind of fast allocation and garbage generation
12:23:43 <lnagy> Really?  How about:  total alloc = 45,494,560,684 bytes in (100 secs)
12:24:06 <lnagy> And that's only the beginning.
12:24:32 <olsner> grmbl... perhaps there could be another Eq class for objects that are always equal to themselves, that has the additional perk of being possible to compare by pointer?
12:25:08 <sjanssen> olsner: sure
12:25:14 <mauke> data No; instance AnotherEq No where _ == _ = False
12:25:25 <sjanssen> olsner: oh, there are a couple other tricky cases
12:25:27 <dozer> olsner: how can something not be equal to itself?
12:25:45 <olsner> dozer: NaN /= NaN, for example
12:25:48 <sjanssen> olsner: you've got to be careful when comparing terms that contain _|_, and infinite structures
12:26:08 <mrd> lnagy: what's the %?
12:26:53 <dozer> olsner: ah - I always forget about things like that - I elide it out as a non-value, for which things like Eq don't exist - bug in my brain probably
12:27:25 <lnagy> 93% of allocs
12:27:33 <mrd> lnagy: Data.Array.Storable is probably a good thing to try out.  it's basically the same as IOUArray but it doesn't relocate during GCs
12:27:56 <sjanssen> olsner: in the long run, I think you'll have a hard time finding a useful strategy that doesn't run afoul of _|_ and non-termination
12:27:57 <mrd> lnagy: it should have a breakdown of the time, something like "MUT -- xx%, GC -- yy%"
12:28:01 <olsner> yeah, =='s that were nonterminating could become terminating, I guess... though I'm tempted to say that's a good thing
12:28:29 <sjanssen> olsner: it's very very bad
12:28:55 <sjanssen> olsner: do you want your program's behavior to change depending on the optimization level?
12:28:56 <mrd> lnagy: http://haskell.org/haskellwiki/Arrays covers this and more. it includes an example of memset() and Storables
12:28:58 <lambdabot> Title: Modern array libraries - HaskellWiki
12:29:04 <lnagy> I only use "+RTS -p", is there some other flag?
12:29:12 <mrd> lnagy: -sstderr
12:29:23 <olsner> otoh, if you rely on a terminating == and change something so that you e.g. don't share things you used to share, you've suddenly "bottomed out"
12:29:35 <sjanssen> olsner: what if ghc -O transforms "repeat () == repeat ()" into "let x= repeat () in x == x"?
12:29:57 <mauke> then you use OCaml!
12:30:08 <sjanssen> right
12:30:23 <sjanssen> Haskellers tend to be very resistant to these deals with the devil
12:30:30 <olsner> that'd just make a non-terminating program terminate, right?
12:30:31 <lnagy> Running.
12:30:40 <sjanssen> olsner: yes, but the opposite can happen too
12:30:58 <lightstep> sjanssen, can you give an example?
12:30:58 <sjanssen> olsner: or consider hugs vs. ghc
12:31:33 <sjanssen> olsner: with ghc -threaded, terms can lose sharing due to race conditions too
12:31:55 <mrd> is _|_ the devil?
12:32:12 <sjanssen> lightstep: we have clearly separated immutable/mutable worlds
12:32:55 <olsner> ok, so comparing bottoms would still not work... I think that's fair game ;-)
12:33:03 <sjanssen> lightstep: there's no mutation of immutable values in the language (contrast to OCaml, Scheme, etc.)
12:33:40 <sjanssen> olsner: I think it's better to save these tricks for places where they're clearly safe
12:33:57 <lnagy> Well, I'll try use Storable Array and see what happens.  Thanks for the help.  Bye.
12:34:06 <lightstep> but why require (==) to be stricter than necessary
12:34:11 <sjanssen> olsner: eg. Data.ByteString checks the pointers for equality, because it's finite and has no bottoms
12:35:02 <sjanssen> lightstep: pointer equality breaks referential transparency
12:37:36 <lightstep> really? i know in lisp you can have (eq? x y), and (print x) and (print y) would do different things. but in haskell, everything is immutable, so why is there a problem?
12:38:28 <sjanssen> quick definition from Wikipedia: "An expression is said to be referentially transparent if it can be replaced with its value without changing the program"
12:39:09 <sjanssen> so, in "let x = repeat () in x == x", if we replace both x's with their value: "repeat () == repeat ()"
12:39:43 <sjanssen> if == means pointer equality, we've just changed the meaning of the program
12:39:47 <Cale> http://programming.reddit.com/info/298vf/comments/c299iz -- omwtfbbq! qwe1234 made a post which got a positive score!
12:39:48 <lambdabot> Title: Do faster typists make better coders? (reddit.com)
12:40:16 <lightstep> i didn't think haskell had this level of referential transparency
12:40:29 <|Steve|> > let x = repeat () in x == x
12:40:33 <lambdabot> Terminated
12:41:16 <sjanssen> lightstep: it does.  This is essentially how Haskell evaluators work
12:42:22 <lightstep> ok, so perhaps Haskell isn
12:42:27 <lightstep> t expressive enough
12:42:29 <Cale> lightstep: Pointer equality is also pretty unsafe when you have a garbage collector that can move things around on you.
12:42:44 <sjanssen> yeah, all kinds of race conditions there
12:42:49 <olsner> but if x == x returns True and repeat () == repeat () is _|_ - is True really "different"? given infinite time and space, repeat () == repeat () should return True too
12:42:49 <bct> if i have this: "data Day = Sunday | Monday | ..." how can i write a function that tests if two Days are the same?
12:43:11 <mauke> olsner: I don't think it should
12:43:19 <sjanssen> olsner: no, in Haskell _|_ is _|_
12:43:20 <bct> is "test Sunday Sunday = True; ...; test _ _ = False" as terse as it gets?
12:43:28 <sjanssen> olsner: no matter how much time/space you've got
12:43:31 <mauke> bct: you add 'deriving (Eq)' to the end of the data definition
12:44:07 <bct> oh. for some reason i thought i had to write the Eq function myself to do that
12:44:08 <bct> thanks.
12:44:15 <sjanssen> lightstep: why does referential transparency reduce Haskell's expression?
12:44:30 <Cale> lightstep: You may be interested in this module though: http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Mem-StableName.html
12:44:32 <lambdabot> http://tinyurl.com/zrcmg
12:45:22 <lightstep> since you can't express (\x x -> True)
12:45:41 <lightstep> or another example, haskell forces (||) to be strict
12:45:55 <Cale> lightstep: huh?
12:46:28 <sjanssen> lightstep: I don't think this is a problem in practice
12:46:31 <lightstep> you could imagine a language where (||) would evaluate both arguments in parallel, and return if either returns
12:46:33 <Cale> Of course (||) is going to be at least a bit strict. It does have to actually check what the value of one of its parameters is.
12:47:03 <lightstep> in haskell, the programmer must choose one of the parameters or (||) to be a strict one
12:47:36 <sjanssen> lightstep: of course, we can write this with in IO (with the common threading extension)
12:47:43 <sjanssen> s/with in/in
12:48:15 <Cale> Ah, so you want to be able to see if a thunk has been forced yet or not? That's *really* not referentially transparent, but could be supported in IO, perhaps.
12:48:40 <sjanssen> lightstep: but yes, there's a tradeoff there.  I argue that referential transparency is more useful than observation of sharing in day to day programming
12:48:43 <lightstep> we can also specify _|_ == _|_, which can also be implemented with IO, except it doesn't return in some cases
12:48:56 <mrd> to see if a thunk has been thunk?
12:49:18 <Cale> lightstep: Uh, wouldn't that be messed up though?
12:49:27 <olsner> btw, just for clarification, I'm talking about something like x === y = (ptrEq x y) || (x == y) such that on unshared thunks it still does the right thing, only perhaps having to traverse more data
12:49:52 <Cale> lightstep: Like, if you just happened not to have evaluated the parameters to (==) yet, you'd get true, regardless of whether they were actually equal?
12:50:20 <lightstep> it can also be specified to be referentially transparent, by only returning True when the thunk is fully evaluated
12:50:36 <olsner> lightstep: _|_ == _|_? isn't that the halting problem?
12:50:57 <sjanssen> lightstep: deepSeq evaluation, you mean?
12:51:47 <lightstep> the depth of the evaluation must depend on the strictness of (==) of that type
12:51:51 <lightstep> so it won't work
12:52:51 <lightstep> olsner, no, _|_ is a real member of any haskell type. GHC even detects them sometimes in IO
12:54:00 <sjanssen> olsner: you can solve the halting problem, as long as you understand that it might take an infinite amount of time to give you an answer ;)
12:54:29 <SamB> or you could have a partial solution
12:54:40 <Cale> Semantically _|_ is also used to represent nonterminating and not-yet-evaluated values.
12:55:06 <sjanssen> Cale: huh?  _|_ and thunks are the same thing?
12:57:43 <Cale> Well, you can think of evaluation as refining a value from _|_ upwards toward more defined values.
12:59:39 <Cale> For example, an evaluation step on a value of type [Bool] might produce  _|_ : _|_ and then perhaps _|_ : _|_ : _|_, and then _|_ : True : _|_, as more parts of the structure were demanded. The "real" bottom values are those which simply remain bottom forever no matter how much evaluation you try to do.
13:01:50 <roconnor> @type GT
13:01:52 <lambdabot> Ordering
13:03:47 <Nopik> re
13:03:48 <lambdabot> Nopik: You have 1 new message. '/msg lambdabot @messages' to read it.
13:04:21 <Nopik> byorgey: no problem ;)
13:06:07 * bos met with simonpj for the first time in 15 years this morning
13:06:36 <byorgey> Nopik: =)
13:07:42 * byorgey wishes he could be at OSCON meeting simonpj instead of writing fugly Java code...
13:08:20 <wli> You should see how bad C gets in the legacy code parts of the Linux kernel.
13:08:32 <bos> or pick a driver at random.
13:09:01 <wli> Fortunately I don't have to deal with drivers much, but they're really bad, too.
13:09:26 <byorgey> oh, I'm well aware that the code could be much worse =)
13:09:27 <bos> we were accosted by someone who works for coverity on the way out of the conference hall.
13:09:55 <bos> he was psyched about possibly using the coverity scanner on ghc. i don't think that will go very far, alas.
13:10:19 <byorgey> hehe
13:10:47 <wli> That's one of the stranger things I've heard this week.
13:10:56 <SamB> coverity?
13:11:05 <Nopik> byorgey: any idea how should i implement local for my little monad? :)
13:11:07 <sjanssen> just run coverity on -fvia-c output :)
13:11:20 <AStorm> bos, well, random driver can be ok :P
13:11:20 <byorgey> @go coverity
13:11:22 <wli> Though I'll probably be one of the weird highlights of OSCON as things now stand.
13:11:22 <lambdabot> http://www.coverity.com/
13:11:22 <Cale> I was going to say... coverity works on Haskell code?
13:11:22 <lambdabot> Title: Coverity Incorporated
13:11:29 <AStorm> I actually suggest you take XFS code :>
13:11:43 <AStorm> There aren't many worse than that in the kernel
13:11:46 <bos> Cale: no
13:11:47 <SamB> sjanssen: you'd need an unregisterized build of GHC for that...
13:12:05 <wli> XFS' code is getting cleaner over time, and it is essentially the best-performing fs in the kernel.
13:12:13 <Cale> bos: did he know that GHC was written in Haskell?
13:12:30 <AStorm> wli, essentially still the worst in database workloads, you meant. (though nice in streaming)
13:12:35 <AStorm> :>
13:12:45 <bos> Cale: not before simon told him
13:12:47 <byorgey> Nopik: sure.  First, do you know the type that local should have?  (Hint: it's not quite the same as the standard version from MonadReader)
13:12:52 <Cale> hehe
13:13:00 <wli> AStorm: Not sure what database you have in mind, but anyway.
13:13:12 <Nopik> byorgey: if i know the type, most likely i would be able to write it :D
13:13:13 <bos> although he was very enthusiastic. he downloaded ghc and started building it during simon's talk!
13:13:32 <Nopik> byorgey: i know theory, but it seems, that many things are still beyond my mind
13:13:49 <Cale> bos: I wonder if the video is online anywhere yet :)
13:14:00 <byorgey> Nopik: well, with Haskell, knowing theory is usually a great start =)
13:14:23 <bos> people were very, very excited by the STM talk
13:14:32 <byorgey> Nopik: well let's figure out the type
13:14:35 <Nopik> byorgey: yeah, but without experience it is nothing.. i have learned a lot today by trying to write a monad on my own.. much more than reading last 2 tutorials :)
13:14:44 <bos> i think the tutorial on monday morning left people a bit lost
13:14:44 <Cale> bos: awesome :)
13:14:54 <Cale> (Re: STM)
13:15:12 <bos> simon's giving a talk on ndp in 30 minutes
13:15:19 <byorgey> Nopik: of course experience is still necessary, but with other languages knowing theory often doesn't even help
13:15:38 <ihope> LZW!
13:15:41 <Nopik> byorgey: more or less, yes ;)
13:15:50 <Cale> Soon we'll have all these non-Haskell people getting into monads and trying to figure out how to add abstractions to their language to support them :)
13:16:33 <Nopik> byorgey: if i learn assembler for new family of cpus, i take a book to my home, read it in 1-2 evenings and then start to write.. after some experiments i am able to write something useful, finally ;)
13:16:33 <byorgey> Nopik: ok, so can you describe what local is supposed to do?
13:16:52 <AStorm> wli, MySQL, PostGRESQL and Oracle
13:16:54 <byorgey> Nopik: yup
13:17:22 <AStorm> wli, hmm, there are some archs that are really crusty
13:17:53 <Nopik> byorgey: yeah, lets see.. it should take a monadic computation, a monad and a function f, modify monad parameters by applying f, and then run the computation on new modified monad.. possibly returning () or some actual result
13:18:44 <byorgey> Nopik: ok, but it only takes 2 parameters... a function to modify the environment and a monadic computation
13:18:48 <wli> AStorm: Yes, I'm reputedly the maintainer of one.
13:19:17 <wli> AStorm: Oracle hmm. I don't remember the results too well there.
13:19:30 <byorgey> Nopik: also, it doesn't actually "run" the computation, it just returns a new one
13:19:46 <Nopik> byorgey: ok, thats why it do not require monad as argument ;)
13:20:11 <byorgey> Nopik: right.  So, what is the type of the environment in your monad?
13:20:12 <Nopik> byorgey: so, first half of local definition was ok :) local f m =
13:20:27 <byorgey> Nopik: uh, yes =)
13:20:38 <msouth> is there an efficient optimization of reverse.f.reverse?
13:20:44 <msouth> seems like it would be a common need
13:20:56 <Nopik> byorgey: environment looks like a b c
13:20:58 <msouth> or is it already optimal, I suppose I should ask
13:21:09 * Nopik didnt got solid grasp on this bit yet
13:21:30 <byorgey> Nopik: not quite.  those are the types that make up the environment.
13:21:36 <wli> AStorm: I think it's more to do with the stackspace issue on 32-bit.
13:21:54 <Nopik> byorgey: so, the only type i can imagine is (a,b,c), though i do not know why ;)
13:21:57 <AStorm> wli, uhm, tests were done on 64-bit too
13:21:59 <byorgey> msouth: seems like that depends a lot on f?
13:22:04 <byorgey> Nopik: that's right.
13:22:08 <AStorm> it's just not that friendly to semi-hot files
13:22:20 <Nopik> byorgey: ok, it the only runMyMonad argument
13:22:27 <Nopik> *it is
13:22:31 <byorgey> Nopik: exactly.
13:22:32 <wli> AStorm: I don't know whose tests you're on about.
13:22:36 <AStorm> wli, maybe that was recently fixed
13:22:48 <byorgey> Nopik: so, in local f m, what should the type of f be?
13:22:51 <AStorm> wli, yes, you won't know them - these aren't public
13:23:10 <Nopik> ok, so local :: ((a,b,c) -> (a,b,c)) -> MyMonad a b c -> MyMonad a b c ?
13:23:16 <Nopik> what about return types?
13:23:17 <wli> AStorm: I work for Oracle.
13:23:21 <byorgey> Nopik: almost
13:23:21 <AStorm> the only other gripe I have with XFS is not-too-fast file creation. Other than that, it's great
13:23:29 <Nopik> byorgey: d is missing ;)
13:23:40 <AStorm> wli, so you can benchmark yourself :-)
13:23:45 <wli> AStorm: People will usually tell us these things.
13:23:46 <msouth> Well, I was just playing around to get more familiar with the language and wrote "ltrim" to trim the spaces off the left end of a string, and the most intuitive way I could think of to do "rtrim" (to take them off the right end) was reverse.ltrim.reverse
13:23:55 <byorgey> Nopik: right. =)
13:24:01 <Nopik> byorgey: btw. which country you reside?
13:24:19 <msouth> which I looked at and wondered if it was laughably inefficient
13:24:19 <AStorm> wli, well, I can't, and the guy who was responsible can't either
13:24:19 <byorgey> msouth: maybe check out http://www.cse.unsw.edu.au/~dons/papers/CLS07.html
13:24:19 <lambdabot> Title: Stream Fusion: From Lists to Streams to Nothing at All
13:24:22 <wli> AStorm: We've already done our own tests.
13:24:28 <SamB> msouth: I don't know of any better way
13:24:35 <AStorm> wli, ah, so you should know :-)
13:24:39 <byorgey> Nopik: USA, in Washington, DC
13:24:50 <Nopik> byorgey: hm, i was sure that you are in europe ;)
13:24:59 <byorgey> Nopik: hm, why's that?
13:25:07 <wli> AStorm: ISTR the performance being okay but the stack issue being easily triggerable.
13:25:21 <AStorm> maybe they caught that, I don't know
13:25:21 <Nopik> byorgey: i got the feeling that you have similar timezone
13:25:43 <byorgey> @localtime
13:25:43 <lambdabot> Local time for byorgey is Wed Jul 25 16:24:38
13:25:50 <byorgey> @localtime Nopik
13:25:51 <lambdabot> Local time for Nopik is Wed Jul 25 22:24:45 2007
13:25:51 <Nopik> @localtime
13:25:52 <lambdabot> Local time for Nopik is Wed Jul 25 22:24:46 2007
13:26:13 <byorgey> well, only 6 hours different =)
13:26:13 <Nopik> right now I'm in Spain, though I live in Poland usually
13:27:01 <Nopik> byorgey: ok, let me see if i can write my local now ;)
13:27:39 <byorgey> Nopik: ok.
13:28:26 <Nopik> first attempt failed, but the error message is now much shorter, so this is kind of success :D
13:28:37 <msouth> thanks for your answers samb and byorgey
13:29:01 <SamB> you are welcome
13:29:47 <Cale> msouth: Yeah, lists are only fast on one end -- they're a little like stacks in that regard.
13:29:57 <Nopik> .. and the error was because i wrote only type signature and not the body.. nice ;)
13:30:46 <byorgey> Nopik: yeah, the compiler can't yet deduce code from types =)
13:30:56 <mauke> actually, it can
13:31:00 <mauke> @where oleg
13:31:00 <lambdabot> http://okmij.org/ftp/
13:31:09 <Nopik> byorgey: haskell cant do that? so, why i'm learning it? ;)
13:31:32 <mauke> see http://okmij.org/ftp/Haskell/types.html#de-typechecker
13:31:33 <lambdabot> Title: Haskell Programming: Types
13:31:33 <SamB> Nopik: it would often write the wrong one anyway
13:31:35 <byorgey> mauke: I know about Djinn but I didn't know the compiler could do it
13:32:14 <byorgey> @djinn (a -> b) -> a -> b
13:32:15 <lambdabot> f a = a
13:32:26 <mauke>  "It must be emphasized that no modifications to the Haskell compiler are needed, and no external programs are relied upon."
13:33:04 <Nopik> byorgey: it worked, thanks!
13:33:04 <byorgey> mauke: I should have known Oleg did something like this...
13:33:23 <byorgey> Nopik: hurrah!  can you paste your implementation?  I'm curious to see it
13:33:47 <msouth> Cale: thanks--that's exactly what I was wondering.  If it really was asymmetrical (as you might assume from the constructor of the list), or if it was just me not gettting my head around it.
13:34:02 <hpaste>  Nopik pasted "(no title)" at http://hpaste.org/1880
13:34:08 <hpaste>  lnagy annotated "(no title)" with "Using C's memcpy.  Fast." at http://hpaste.org/1879#a3
13:34:28 <Nopik> byorgey: a lot of non-working code is commented ;)
13:35:07 <Nopik> local turned out to be very similar to ask ;)
13:35:13 <byorgey> Nopik: hm, but that definition of local doesn't use m at all
13:35:43 <Nopik> byorgey: ah, yes.. i was to happy to see that something compile and actually prints something to notice this :)
13:36:24 <Nopik> hmmm
13:36:51 <byorgey> Nopik: you need to produce a computation which will run m in the context of the altered environment
13:36:59 <Nopik> byorgey: yeah
13:39:07 <byorgey> Nopik: hm, also the type is still not quite right
13:39:27 <byorgey> Nopik: the result of local should just be MyMonad a b c d
13:39:30 <Nopik> byorgey: yes, it has to have d on the end.. but my version returns (a,b,c), so i changed it
13:39:35 <Cale> msouth: for that reason, if you need to do lots of short appends to a list, it's often faster to accumulate a function of type [a] -> [a] that prepends some elements to a list. You can 'concatenate' two such functions with (.)
13:39:37 <byorgey> Nopik: ok, good
13:41:03 <CosmicRay> SyntaxNinja: have you made reservations already?
13:41:15 <Cale> msouth: (and then apply it to [] when you're done)
13:43:32 <lightstep> > exp pi - pi
13:43:40 <lambdabot>  19.999099979189474
13:44:26 <byorgey> oh noes, a bug! ;)
13:45:38 <ihope> That's equal to 20 for... er, wait.
13:45:43 * ihope quickly does calculus
13:45:59 <monochrom> It is not 20.
13:46:01 <ihope> For large enough values of pi.
13:47:47 <ihope> Just subtract (exp pi - pi)/(exp pi - 1) from pi to get the new, bigger, better version of pi.
13:47:53 <ihope> Except that's positive, so, um...
13:47:53 <Nopik> byorgey: ok, got this working.. though it seems that one computation is being runned twice
13:48:01 <Nopik> maybe due to >>= definition
13:48:11 <ihope> > let pi = (exp P.pi - P.pi)/(exp P.pi - 1) in exp pi - pi
13:48:12 <lambdabot>  1.5643942518253606
13:48:22 <ihope> > let pi = P.pi - (exp P.pi - P.pi)/(exp P.pi - 1) in exp pi - pi
13:48:24 <lambdabot>  7.139237007045059
13:48:26 <byorgey> Nopik: hm, strange
13:48:32 <ihope> Yes, very interesting.
13:48:37 <Nopik> byorgey: or, i have runned it twice ;)
13:48:46 <byorgey> Nopik: that too. =)  can you paste it?
13:49:05 <ihope> > let pi = P.pi - (exp P.pi - P.pi - 20)/(exp P.pi - 1) in exp pi - pi -- oh, of course
13:49:06 <lambdabot>  20.00000001911943
13:49:20 <lightstep> bug
13:49:21 <lightstep> !
13:49:43 <hpaste>  Nopik pasted "Simple monad with local defined" at http://hpaste.org/1881
13:50:35 <ihope> > let pi 0 = P.pi; pi x = seq (pi (x-1)) (exp (pi (x-1)) - (pi (x-1)) - 20)/(exp (pi (x-1)) - 1) in exp (pi 100) - pi 100
13:50:36 <lambdabot>  NaN
13:50:50 <ihope> > let pi 0 = P.pi; pi x = seq (pi (x-1)) (exp (pi (x-1)) - (pi (x-1)) - 20)/(exp (pi (x-1)) - 1) in exp (pi 10) - pi 10
13:50:51 <lambdabot>  NaN
13:50:55 <ihope> Sheesh.
13:51:00 <ihope> > let pi 0 = P.pi; pi x = seq (pi (x-1)) (exp (pi (x-1)) - (pi (x-1)) - 20)/(exp (pi (x-1)) - 1) in exp (pi 3) - pi 3
13:51:01 <lambdabot>  NaN
13:51:07 <ihope> It converges too quickly!
13:51:37 <ihope> And it's wrong regardless.
13:51:40 <byorgey> Nopik: yes, m is getting run twice in your definition of local.  You are calling f on the output of m rather than using it to transform the environment (input) to m.
13:51:58 <Nopik> byorgey: hm, let me think
13:52:09 <byorgey> Nopik: if I were you I wouldn't try to use do-notation in the definition of local
13:52:22 <byorgey> Nopik: I'm not sure that it's possible, in fact
13:52:35 <fasta> Wasn't liftM2 (,) equivalent to some simpler expression?
13:52:37 <Nopik> byorgey: it is possible, just you get m runned twice :D
13:53:02 <byorgey> Nopik: well, I meant, it's not possible to implement local correctly =)
13:53:13 <Nopik> ;)
13:53:43 <SyntaxNinja> CosmicRay: y0y0
13:53:58 <SyntaxNinja> CosmicRay: join #haskell-meetup
13:54:00 <SyntaxNinja> bos you too
13:54:26 <ihope> > let pi 0 = P.pi; pi x = seq (pi (x-1)) (pi (x-1) - (exp (pi (x-1)) - (pi (x-1)) - 20)/(exp (pi (x-1)) - 1)) in exp (pi 100) - pi 100
13:54:28 <lambdabot>  20.000000000000004
13:54:32 <ihope> The rest is rounding error.
13:54:47 <ihope> > let pi 0 = P.pi; pi x = seq (pi (x-1)) (pi (x-1) - (exp (pi (x-1)) - (pi (x-1)) - 42)/(exp (pi (x-1)) - 1)) in exp (pi 100) - pi 100
13:54:48 <lambdabot>  42.00000000000001
13:55:08 <ihope> Yes, it's a roundabout way of making 20.
13:55:24 <olsner> > 20
13:55:25 <lambdabot>  20
13:55:27 <Nopik> local f m = MyMonadC $ \x -> f x :))
13:55:29 <olsner> my way's shorter!
13:55:44 <byorgey> Nopik: that's what you had before =)
13:55:45 <Nopik> erm, no
13:55:51 <Nopik> again without m :)
13:56:19 <Nopik> it returns 100,200,300 instead of 200,400,600
13:58:40 <Nopik> local f m = MyMonadC $ \x -> (runMyMonad m (f x))
14:00:26 <Nopik> byorgey: this must be correct ;)
14:00:44 <byorgey> Nopik: that's it!
14:01:10 <Nopik> byorgey: phew, it was quite an experience ;)
14:01:18 <byorgey> Nopik: good work =)
14:01:24 <roconnor> bah, I just cannot make a fast DNA interpeter. :(
14:01:28 <Nopik> byorgey: i would not do it without you :0
14:02:08 <byorgey> Nopik: nah, I think you could have, it just would have taken you a lot longer
14:02:29 <Nopik> byorgey: yeah, if i would not give up in the middle ;p
14:02:59 <byorgey> Nopik: well, I'm glad to be able to encourage you, just return the favor to someone else someday! =D
14:03:30 <Nopik> byorgey: sure... im following this policy on other subjects, where i can teach somebody ;)
14:04:09 <Nopik> byorgey: now, with State I could modify 'actual' monad inside of do block, without using local, right?
14:04:26 <Nopik> byorgey: namely, modify environment for remaining part of computation
14:04:47 <Nopik> byorgey: i'll try to add such possibility now, then i'll move to monad transformers :D
14:05:20 <byorgey> Nopik: right.
14:05:46 <byorgey> Nopik: for that you need to have something like runMyMonad :: (a,b,c) -> ((a,b,c),d).
14:06:23 <Nopik> byorgey: .. or a way of deducing new (a,b,c) from d?
14:06:35 <Nopik> byorgey: which is not possible in general case, of course
14:06:44 <ihope> What's this DNA stuff all about?
14:06:46 <mauke> runM :: M a -> (b, c, d) -> (a, (b, c, d))
14:06:53 <mauke> ihope: icfp contest
14:07:12 <ihope> Ah...
14:07:31 <ihope> This? http://www.icfpcontest.org/
14:07:33 <lambdabot> Title: ICFP Programming Contest 2007
14:07:39 <Cale> yes
14:07:40 <byorgey> fasta: well, for the ((->) r) monad and (->) arrow, liftM2 (,) is the same as (&&&), is that what you're looking for?
14:08:07 <fasta> byorgey: I think that's what I vaguely remembered then.
14:08:18 <fasta> byorgey: useless in this case, though. Thanks
14:17:45 <Lamperi> :E
14:21:51 <byorgey> g'night all
14:25:02 <crem_> I'm reading Hal Daume's "yet another Haskell tutorial" and have a question about continuation passing style. Here is example from the tutorial: http://rafb.net/p/7tgjOD73.html.
14:25:04 <lambdabot> Title: Nopaste - No description
14:25:12 <crem_> First parameter which is passed from cfold function into cfold' is a lambda-function with two agruments. But cfold' function wants a function with three parameters. Cannot realize why it works.
14:26:48 <mauke> huh?
14:26:58 <mauke> (\x t g -> ...) takes three arguments
14:27:31 <slava> it takes one argument and produces a function of two arguments :)
14:27:31 <crem_> Ah. I see. Thanks :-)
14:28:16 <crem_> I thought 'x' is the "name of lambda function" and t and g are parameters.
14:28:34 <Botje> crem_: lambda's don't have a name
14:28:52 <crem_> Already realized that. Thanks.
14:29:05 * Botje puts on his captain obvious hat
14:29:54 <Maddas> Botje: No need to, that was already plain to see.
14:30:50 <ricky_clarkson> Is it possible that learning lambdas is better done with untyped languages?
14:30:56 <ricky_clarkson> s/better/quicker/
14:31:15 <Maddas> Learning lambdas?
14:31:25 <ricky_clarkson> Learning about lambda calculus.
14:31:56 <Botje> i'd say that alligator thing is a nice example :)
14:32:06 <Maddas> It doesn't seem impossible, but that doesn't say much ;-)
14:32:07 <Codex_> You don't need a language to learn lambda calculus.
14:32:37 <ricky_clarkson> Botje: I think I understand it and I didn't (immediately) get the alligator thing.
14:32:46 * roconnor tries an DNA machine using Seq Word8
14:32:56 <Botje> well, you're supposed to print out some alligators and eggs and try it for yourself ;)
14:33:03 <SamB> roconnor: how is that bettter than Seq Char?
14:33:10 <ricky_clarkson> Botje: I don't print.
14:33:17 <roconnor> SamB I haven't tried Seq Char
14:33:19 <xerox> how do I build the libraries haddock docs?
14:33:29 <SamB> roconnor: Seq Char would be more convenient
14:33:37 <SamB> xerox: why do you need to build them?
14:33:45 <Nopik> byorgey: state version of my monad works like charm... one i got the 'reader' version working, the state version was amazingly easy to do..
14:33:55 <SamB> try "make docs" or "make haddock" or something, though...
14:33:57 <roconnor> SamB: my original machine used ByteString, so it is all setup for Word8
14:34:06 <SamB> roconnor: oh.
14:34:06 <roconnor> Actually all my code uses Base
14:34:15 <roconnor> so I could change it easily, but why bother
14:34:21 <SamB> you didn't know about Data.ByteString.Word8 ?
14:34:24 <SamB> er.
14:34:24 <xerox> SamB: because there aren't any in the darcs repository, and no, no docs/haddock target in the Makefile, unfortunately.
14:34:25 <SamB> Char8
14:34:27 <SamB> sorry.
14:34:52 <SamB> xerox: you looked in the makefile and didn't find one?
14:35:01 <roconnor> SamB, nope, but it doesn't really matter.  I do a map when I read in the file, and it's Word8 from then on.
14:35:20 <roconnor> So far all my data structures seem to run at roughtly the same speed.
14:35:36 <roconnor> And since it is so slow, I must be doing something else wrong.
14:36:21 <dozer> is it better to say: "allEq1 (x:xs) = all (==x) xs" or "allEq2 (x:xs) = not $ some (/=x) xs"?
14:36:26 <Nopik> ok guys.. when another newbie will get here asking for help in understanding monads, give him advice to write his own monad similar to Reader, implement local, and withMyMonad, then modify it to allow environment modification (i.e. switch from Reader to State)
14:37:01 <roconnor> heh, Seq Word8 is maybe 50% faster than my Seq ByteStream, but boy is Seq Word8 a memory pig :)
14:37:10 <Nopik> i was reading all tutorials about monads before and i did got maybe 50% of necessary knowledge.. but today, during single day i started to write my own monad, and some code which uses it, and i have learned much more than from all those tutorials ;)
14:37:19 <mauke> dozer: null . tail . group
14:37:30 <Botje> dozer: first is clearer. speed doesn't matter i think
14:37:39 <xerox> mauke++
14:38:28 <roconnor> dozer's making a joke, right?
14:39:26 <xerox> anybody on ubuntu has got ghc-6doc installed? do you have mtl docs in file:///usr/share/doc/ghc6-doc/html/libraries/index.html ?
14:39:31 <xerox> ghc6-doc
14:39:36 <mauke> > group []
14:39:38 <lambdabot>  []
14:40:31 <Nopik> next station: monad transformers ;p
14:40:47 <roconnor> xerox: I have ghc6-doc installed
14:40:48 <monochrom> mtl doc is probably in another package. I haven't checked.
14:41:25 <roconnor> But I don't see any mtl docs
14:41:31 <roconnor> however mtl is a separate lib
14:41:37 <xerox> That page is rather incomplete compared to the haskell.org one :-/
14:41:39 <roconnor> so I don't know why it would be in the docs
14:41:41 <xerox> yes, libghc6-mtl-dev
14:42:07 <roconnor> @seen augustss
14:42:08 <lambdabot> I saw augustss leaving #haskell 14h 2m 54s ago, and .
14:42:31 <roconnor> My haskell code is alway slow :'(
14:42:43 <roconnor> But then again, my C++ code was always slow too
14:42:45 <xerox> no docs in /usr/share/doc/libghc6-mtl-dev/ either
14:43:02 <bos> simonpj's talk on ndp was a smash
14:43:09 <glguy> ndp?
14:43:13 <bos> loads of people in the room, very engaed audience
14:43:13 <roconnor> @what ndp
14:43:13 <lambdabot> http://darcs.haskell.org/packages/ndp/Data/Array/Parallel/ http://www.cse.unsw.edu.au/~chak/project/dph
14:43:19 <glguy> oh, those, cool
14:43:28 <xerox> But okay, I can live with that, if I can build the documentation from ghc's darcs repo. But I can't find how to do that either.
14:43:31 <bos> @users
14:43:31 <lambdabot> Maximum users seen in #haskell: 367, currently: 353 (96.2%), active: 19 (5.4%)
14:43:35 <roconnor> glguy: I didn't know either
14:43:43 <mauke> will there be videos?
14:44:08 <diakopter> lambdabot: I'm active, too!
14:44:11 <diakopter> @users
14:44:11 <lambdabot> Maximum users seen in #haskell: 367, currently: 353 (96.2%), active: 19 (5.4%)
14:44:16 <bos> don't know. i didn't look for a cameraperson.
14:44:54 <roconnor> I'm pretty sure that google records all talks everywhere :P
14:45:25 <Cale> mauke: videos of Simon's talks at OSCON will apparently be available
14:45:37 <xerox> Ah, I found a way, runhaskell Setup.hs configure && runhaskell Setup.hs haddock in ghc/libraries/mtl/, altough it isn't very good to browse this way.
14:45:39 <Nopik> diakopter: lambdabot knows better if you are active or not
14:45:50 <diakopter> Nopik: apparently. :)
14:47:27 <xerox> Igloo: how does one build the documentation from the darcs repo?
14:47:59 <Igloo> xerox: The GHC user guide etc??
14:48:04 <Nopik> now, general question.. i have written my monad, then i have written few methods operating on it (like ask, local etc.) (yes i know that they are in mtl, i am doing it for educational purposes).. can i bundle those methods together somehow? like in class or some other structure? or i have to create module and just export those functions from my module?
14:48:21 <xerox> Igloo: in particular the libraries haddock
14:48:38 <diakopter> is the ghc grammar/lexer/parser hookable/overridable at runtime?
14:48:39 <monochrom> You can create MyMonadClass with ask and local as methods.
14:48:43 <Igloo> xerox: autoreconf, configure, then make doc in libraries/
14:49:00 <Igloo> xerox: To be clear, that's: autoreconf, configure, then { make doc in libraries/ }
14:49:36 <xerox> I'm not sure I did autoreconf, but I did configure, and make doc does nothing in libraries/ hmm.
14:49:53 <Igloo> xerox: Did you ./darcs-all get?
14:50:21 <xerox> Yes I did.
14:50:30 <dino-> Are currying and partial evaluation the same thing?
14:51:02 <Cale> dino-: No, but they're related.
14:51:29 <Nopik> monochrom: is this advisable, or general practice is just to left such functions loose?
14:51:54 <Cale> dino-: Currying is the process of converting a function of a parameter a tuple into a function which takes the first component of the tuple and returns a function which takes the rest of the parameters.
14:51:57 <Igloo> xerox: Hmm, running "sh boot" at the root might be necessary, but I don't think so
14:52:02 <dino-> I read this at wikipedia: 'Intuitively, currying says "if you fix some arguments, you get a function of the remaining arguments".'
14:52:13 <dino-> And boy does it ever sound like partial eval. :o
14:52:34 <dino-> Cale: a-la the curry/uncurry functions we have in H.
14:52:39 <monochrom> General practice is to declare ask and local to be methods of MyMonadClass, then declare MyMonad an instance of MyMonadClass, and put your implementation there.
14:52:55 <Cale> Well, curry and uncurry don't in and of themselves do any partial evaluation, right?
14:52:58 <Igloo> xerox: Need to AFK a bit, will look further when I get back
14:52:59 <Cale> @type curry
14:53:01 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
14:53:14 <xerox> Igloo: okay, thanks.
14:53:47 <Cale> However, curried functions make it possible to do partial evaluation.
14:53:53 <monochrom> I am too lazy to correct the wikipedia. But it is wrong.
14:53:58 <xerox> sh boot doesn't work because there is no boot.
14:56:44 <diakopter> anyone have an answer or comment on my question about the ghc grammar/lexer/parser?
14:57:06 <Cale> dino-: Partial evaluation really has more to do with being able to reduce a function somewhat while only knowing some of its parameters.
14:57:47 <Cale> diakopter: hmm, there's a GHC library which provides a lot of that sort of thing
14:58:09 <diakopter> distributed with ghc?  or in hackage?
14:58:11 <dino-> I see. Thank you.
14:58:30 <Cale> http://haskell.org/haskellwiki/GHC/As_a_library
14:58:32 <lambdabot> Title: GHC/As a library - HaskellWiki
14:59:04 <Nopik> monochrom: thanks
14:59:10 <xerox> Aha. It is `make html' to build the doc.
15:00:20 <wli> It's all just f : X -> Y as a subset of X x Y.
15:00:43 <roconnor> you mean adjoint ?
15:01:17 <ddarius> roconnor: (x,f(x)) \is XxY
15:01:58 <roconnor> wli: hmm, I'm not convinced that has to do with currying.
15:02:08 <ddarius> What are we talking about anyways?
15:03:07 <Nopik> in general, having foo :: a -> b  making a function in class, just restricts foo usage (to a being instance of the class), and do nothing else?
15:05:22 <monochrom> That is the pessimistic view. The optimistic view is that it is more relaxed than foo :: MyTypeA -> MyTypeB.
15:05:49 <monochrom> Or more pointedly, foo :: MustBeMyTypeA -> MustBeMyTypeB :)
15:07:27 <Cale> Nopik: Ordinary parametric polymorphism (that is, the use of type variables as in ML) only gives you the ability to operate on structures without regard for what the elements contained in them are.
15:07:39 <Cale> For instance,  length :: [a] -> Int
15:08:02 <Cale> With that type signature, length is not allowed to observe the elements of the list it is given in any manner.
15:08:29 <Cale> However, we might want to be able to write things like a sort function which operates on lists of more than one type.
15:08:48 <ddarius> "might want"?
15:08:59 <monochrom> Yeah, like, I don't want to. :)
15:09:03 <Cale> Of course you can do without, like in ML
15:09:29 <Cale> But to do that, we must give the sort function permission to observe the values of the list somehow.
15:09:53 <Cale> In particular, to determine whether one is larger than another -- which isn't in general possible to do.
15:09:56 <mauke> sort :: (a -> a -> Ordering) -> [a] -> [a]  -- fixed
15:09:57 <xerox> Update on docs: it seems that you can't build docs successfully if you haven't built ghc before. Building ghc now.
15:10:56 <Cale> So the Ord class captures that idea, by allowing you to restrict the type variable to only refer to those types which are ordered.
15:11:08 <Cale> sort :: (Ord a) => [a] -> [a]
15:11:12 <Igloo> xerox: Why not?
15:11:14 <mauke> what's the type of (<) in ML?
15:11:32 <xerox> Igloo: it couldn't find some things, let me see if they are still in the backlog
15:11:39 <Cale> mauke: (<) is accomplished with a non-general hack, I think.
15:11:43 <Igloo> xerox: No boot? You're talking about a GHC HEAD, right?
15:12:28 <xerox> Yes
15:13:00 <xerox> It may be not the very latest darcs, 2 days ago repo perhaphs
15:13:26 <fasta> Igloo: when one responds to a WONTFIX bug, do you see it?
15:13:27 <Igloo> xerox: Then you must have a boot in the root
15:13:29 <ddarius> http://www.standardml.org/Basis/top-level-chapter.html (Overloaded identifiers)
15:13:32 <lambdabot> Title: Top-level Environment
15:13:33 <Igloo> fasta: Yes
15:16:00 <sean_____> mauke: ML's (<) is equivalent to saying 'deriving Ord' after every type
15:16:21 <mauke> but you can't say deriving Ord after every type
15:16:25 <Cale> Nopik: So in some sense, typeclasses give you a bit more freedom to define general functions by saying something about (and thus restricting) type variables.
15:16:33 <ddarius> sean_____: SML's?
15:17:03 <sean_____> ddarius: OCaml's, at least; I'm not sure about the differences between the two (other than the object system)
15:17:12 <Nopik> Cale: ?
15:17:21 <ddarius> SML's seems only defined for "numeric" and "text" types.
15:17:39 <monochrom> Yes.
15:17:45 <ddarius> "a bit more"?  You have a penchant for understating today.
15:17:50 <Nopik> Cale: when i read your last 2 messages, i feel that they are correct, but i do not understand a word from them :)
15:18:26 <Cale> ddarius: In some sense, typeclasses are inessential in that you could just pass around records consisting of the functions they provide.
15:18:40 <Cale> (But that's very ugly)
15:18:44 <Nopik> Cale: or, actually, i see some sense, and it seems that they are correct, but i do not know what are you talking about :)
15:18:54 <fasta> Nopik: if you want to learn Haskell, just build software. It's far more productive then talking about hypothetical problems.
15:18:57 <sean_____> mauke: yes, you can't derive Ord for every type, so if you compare such types (e.g. functions) with OCaml's (<) you'll get a type error
15:19:01 <fasta> than*
15:19:28 <ddarius> Cale: Indeed that's a global transformation (and thus an expressiveness boost a la Felleisen) further in Haskell 98 you can't implement all type classes that way (as a H98->H98 translation).
15:19:39 <Nopik> fasta: but from time to time it is good to talk
15:19:57 <fasta> Nopik: yes, like when you have an actual problem.
15:20:33 <Nopik> fasta: that too.. but sometimes when you learned something you could discuss how to improve your actions
15:20:39 <Cale> Nopik: The key idea is that the type of something represents your knowledge about what it is, and hence the permissions you have for operating on it.  As you make the type of something more general, you lose information about what it is, and so you can't do as much with it.  Typeclasses give you some extra middle ground in between completely knowing the type of something and knowing nothing about it at all.
15:21:24 <ddarius> @free length
15:21:26 <lambdabot> length = length . $map f
15:21:38 <Nopik> Cale: ok, thanks ;)
15:21:40 <fasta> @help free
15:21:41 <lambdabot> free <ident>. Generate theorems for free
15:27:11 <roconnor> @free id
15:27:13 <lambdabot> f . id = id . f
15:27:30 <roconnor> @free return
15:27:32 <lambdabot> Expected variable or '.'
15:27:50 <SyntaxNinja> bos: y0
15:27:57 <SyntaxNinja> bos: see email, and come to #haskell-meetup
15:28:05 <SyntaxNinja> any other Haskellers in Portland tonight too :)
15:28:20 <roconnor> @free runST
15:28:22 <lambdabot> Extra stuff at end of line in retrieved type "Not in scope: `runST'\n\n"
15:28:26 <mauke> @free beer
15:28:28 <lambdabot> Extra stuff at end of line in retrieved type "Not in scope: `beer'\n\n"
15:28:44 <roconnor> @free flip
15:28:46 <lambdabot> (forall x. h . k x = p (f x) . g) => h . flip k y = flip p (g y) . f
15:28:47 <kolmodin> ?localtime araujo
15:28:48 <lambdabot> Local time for araujo is Wed Jul 25 18:21:58
15:28:58 <roconnor> @free const
15:29:01 <lambdabot> f . const x = const (f x) . g
15:29:11 <roconnor> @free fst
15:29:13 <lambdabot> f . fst = fst . $map_Pair f g
15:29:39 <roconnor> @free (.)
15:29:40 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
15:29:56 <roconnor> @free zip
15:29:58 <lambdabot> $map ($map_Pair f g) . zip xs = zip ($map f xs) . $map g
15:30:06 <roconnor> hmm
15:32:19 <mauke> @free o :: (b -> c) -> (a -> b) -> (a -> c)
15:32:19 <lambdabot> g . k = p . f => f . q = f1 . h => g . o k q = o p f1 . h
15:38:18 <xerox> But... the hackaton07 is the same days as AngloHaskell?
15:39:40 <xerox> http://haskell.org/haskellwiki/Hac_2007  http://haskell.org/haskellwiki/AngloHaskell
15:39:41 <lambdabot> Title: Hac 2007 - HaskellWiki
15:40:27 <Lemmih> xerox: http://haskell.org/haskellwiki/Hac_2007_II ?
15:40:28 <lambdabot> Title: Hac 2007 II - HaskellWiki
15:41:05 <xerox> ooops.
15:41:16 <xerox> That makes more sense, thanks Lemmih :)
15:46:29 <Lemmih> xerox: See you at the Hackathon?
15:47:15 <xerox> Lemmih: I'm pondering that, yes (: It would be interesting.
15:48:11 <xerox> Lemmih: what about AngloHaskell?
15:49:54 <Lemmih> Too low code/price ratio for me.
15:51:05 <projectxz2005> hi everyone
15:51:40 <Lemmih> Driking beer with Haskellers is fun but I'm still not rich enough to pay hundreds of euros for the privilege.
15:51:41 <projectxz2005> just wondering if anyone can offer me some help on installing the ghc?
15:51:55 <Cale> projectxz2005: sure
15:51:58 <Botje> someone probably can, what issue are you facing?
15:52:20 <projectxz2005> well i'm on gentoo and it's telling me the package is masked
15:52:41 <Cale> dcoutts: ^^ ?
15:52:49 <projectxz2005> any ideas?
15:53:13 <Cale> (if dcoutts is here, he'll know, he's the gentoo package maintainer, iirc)
15:53:28 <projectxz2005> ah ok thanks
15:53:40 <oerjan> i am sure someone asked about gentoo and masked before somewhere.  perhaps at haskell-cafe.
15:53:42 <Botje> projectxz2005: tried simply unmasking it?
15:53:55 <oerjan> or perhaps here.
15:54:14 <projectxz2005> well i don't know how, other than including the package in package.keywords and that doesn't seem to work
15:54:16 <Botje> (/me has used gentoo since 1.0-rc17 up until ~ a month ago)
15:54:30 <vaste_> @ty (>>=)
15:54:31 <Botje> projectxz2005: try adding it to package.unmask too
15:54:35 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
15:54:44 <projectxz2005> yep no joy there either
15:54:47 <oerjan> @seen dcoutts
15:54:47 <lambdabot> dcoutts is in #haskell-overflow, #haskell and #ghc. I last heard dcoutts speak 5h 23m 25s ago.
15:55:08 <oerjan> @localtime dcoutts
15:55:09 <lambdabot> Local time for dcoutts is Wed Jul 25 23:54:38
15:55:21 <projectxz2005> thanks guys
15:55:34 <Cale> projectxz2005: I'll see if I can find a solution :)
15:55:45 <ricky_clarkson> Lemmih: I don't see a price on the page about it.  Is this the air fare?
15:55:47 <Botje> projectxz2005: can you put the exact error message on a pastebot?
15:55:53 <Botje> hpaste.org or pastebin.com, for example
15:56:03 <Lemmih> ricky_clarkson: Yes.
15:56:09 <monochrom> hpaste.org is prefered
15:57:58 <Cale> projectxz2005: http://haskell.org/haskellwiki/Gentoo might be useful
15:57:59 <lambdabot> Title: Gentoo - HaskellWiki
15:58:34 <projectxz2005> cool thanks.
15:58:41 <Cale> Also, there's a #gentoo-haskell, but I don't know if there's anyone in there who isn't already in here.
15:58:53 <projectxz2005> the problem is on a different mac to the one i'm using now
15:59:22 <projectxz2005> and i'm not really good with pastebots
15:59:57 <Cale> !paste
15:59:57 <hpaste> Haskell paste bin: http://hpaste.org/
15:59:57 <Botje> just copypaste it from the terminal, no biggie
16:00:35 <ricky_clarkson> If that doesn't work, Start->Control Panel->Remote Assist.
16:00:54 <Cale> ricky_clarkson: huh?
16:00:58 <projectxz2005> i'm on a mac!
16:01:11 <Botje> oh, okay then
16:01:16 <Botje> Apple->Control Panel->Remote Assist
16:01:20 * Botje ducks
16:02:19 <monochrom> http://xkcd.com/278/ :)
16:02:20 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
16:03:27 <projectxz2005> err...we don't have control panels!
16:03:38 <projectxz2005> lol
16:03:51 <Cale> projectxz2005: apparently: echo "dev-lang/ghc-6.6.1" >> /etc/portage/package.keywords
16:05:34 <projectxz2005> still saying all ebuilds that could satisfy dev-lang/ghc have been masked
16:05:45 <projectxz2005> i was able to emerge ghc-bin though
16:06:05 <Cale> er... hmm -- packages.gentoo.org lists ghc-6.6 and ghc-6.6.1 as being not available on all architectures. Perhaps they're only in the overlay?
16:06:14 <projectxz2005> and the x11-extras (trying to use xmonad)
16:06:39 <projectxz2005> trying to use the overlay almost made me go crazy :)
16:06:43 <Cale> try that line above, but with the version number removed
16:06:50 <Cale> and see which version you get ;)
16:07:02 <dozer> oh - all, and, or, any aren't defined in terms of Traversable
16:07:48 <Cale> If it's 6.4.x, you might just want to download the generic binary package. There's a lot of new stuff in 6.6.x and the code generation is significantly better.
16:07:49 <dolio> @type Data.Foldable.and
16:07:51 <lambdabot> forall (t :: * -> *). (Data.Foldable.Foldable t) => t Bool -> Bool
16:08:13 <projectxz2005> yeah i might give that a go..
16:08:27 <dozer> dolio: thx - seems i was looking in the wrong place :)
16:09:12 <Cale> projectxz2005: Also, ghc is one of those things where there's almost no point in compiling it yourself. Let someone else heat up their room :)
16:09:32 <Cale> (besides, you need to have a working GHC installation to compile GHC)
16:09:35 <SamB> projectxz2005: unless, of course, you wanna be a compiler hacker
16:09:41 <Cale> right.
16:09:46 <dcoutts> hia oerjan
16:09:51 <projectxz2005> hmm..
16:09:57 <projectxz2005> so how do i get the binary?
16:10:06 <Cale> dcoutts: hey, projectxz2005 is having issues installing ghc on gentoo.
16:10:07 <SamB> projectxz2005: but to do that you have to change the compiler
16:10:52 <projectxz2005> ?
16:10:59 <Cale> projectxz2005: x86 or PPC?
16:11:08 <Cale> err... hmm
16:11:10 <SamB> projectxz2005: s/do that/be a compiler hacker/
16:11:13 <lispy> suppose you have a set of things which potentially interfere with each other, do there exist efficient algorithms to find the (or a?) maximal subset of the ones which don't conflict?
16:11:22 <Cale> http://www.haskell.org/ghc/download_ghc_661.html#x86linux
16:11:23 <lambdabot> Title: GHC: Download version 6.6.1
16:11:46 <oerjan> dcoutts: hi, there's a gentoo ghc discussion going on
16:12:18 <projectxz2005> ppc
16:12:30 <Cale> Oh, that's sad, it looks as if we still don't have linux ppc binaries for 6.6...
16:12:39 <projectxz2005> awh :(
16:12:48 <Cale> heh, so I guess you *could* compile it :)
16:13:02 <projectxz2005> it's saying 'masked by: coruption'
16:13:07 <projectxz2005> when i try to emerge
16:13:11 <Cale> eh, let's just bug dcoutts :)
16:13:16 <projectxz2005> lol
16:13:26 <lispy> mmm...this problem could be exponential time in an exact solution in general
16:14:05 <oerjan> lispy: sounds like an NP-complete kind of problem to me.
16:14:15 <projectxz2005> np-complete
16:14:16 <projectxz2005> ?
16:14:27 <monochrom> lispy: how efficient? yes, it is "independent set" and is np-complete. there are fast heuristics and fast approximations (i.e., not maximal but tries to be large).
16:14:28 <Cale> dcoutts: Any idea about that message?
16:14:31 <fasta> projectxz2005: basic CS concept
16:15:23 <glguy> projectxz2005: an NP-Complete problem is a problem whose solution can be checked in polynomial time, and which can be transformed into any other np-complete problem
16:15:26 <glguy> but
16:15:37 <glguy> is a problem for which there is no know effecient algorithm to solve
16:15:39 <lispy> monochrom: thanks, i'll look and see if 'independent set' is actually my problem...maybe i'm lucky and i have an easier problem here
16:15:40 <glguy> known*
16:15:43 <monochrom> Unfortunately I don't know any heuristics for any np-complete problems apart from SAT itself.
16:16:15 <lispy> wikipedia++
16:16:16 <fasta> monochrom: you know heuristics for SAT?
16:17:11 <Cale> Er, glguy gave a bit of a circular definition -- I think he meant to say "any other problem in NP can be reduced to it".
16:17:21 <benny99> hi
16:17:24 <Cale> hello
16:17:29 <lispy> oh, technically my problem is NP-hardh
16:17:29 <monochrom> Haha, I only know the Davis-Putnam method, if you ask me for actual algorithms. If you ask me for further heuristics but I don't need to describe them, I can point you to several SAT solvers.
16:17:30 <ihope> Ello.
16:17:41 <lispy> er if it's equivalent to independent set that is
16:17:58 <benny99> :-[ this time a very simple question: what must I include for the monadplus ?
16:18:06 <lispy> i have a davis-putnam in haskell somewheres around here
16:18:12 <Cale> benny99: import Control.Monad
16:18:17 <benny99> Cale, thanks :)
16:18:24 <benny99> Cale, btw. I found a great tutorial I guess :)
16:18:35 <lispy> implemented it for a class i took, "NP-Complete and harder problems"
16:18:36 <benny99> Cale, http://www2.lifl.fr/~boulet/formation/CALP/man/monads/html/index.html
16:18:41 <lambdabot> Title: All About Monads, http://tinyurl.com/2aswv5
16:18:48 <benny99> Cale, if anybody is ever again interested :)
16:18:50 <Cale> benny99: oh, yeah, that one is good
16:19:21 <benny99> Cale, though I guess I needed your help to get rid of that tutorial :)
16:19:22 <Cale> benny99: Ignore what it says about 'fail' though, those are evil lies ;)
16:19:30 <benny99> Cale, ._. really ?
16:19:33 <benny99> Cale, why ?
16:20:02 <lispy> hrmm..if i have a maximal (contrasted with maximum) independent set problem then it has a polynomial time solution
16:20:02 <Cale> benny99: I like to pretend that the 'fail' function doesn't exist. It's not really part of the definition of a monad, it's a curiosity of the Haskell 98 language spec.
16:20:16 <oerjan> @where allaboutmonads
16:20:16 <lambdabot> I know nothing about allaboutmonads.
16:20:22 <oerjan> @where all about monads
16:20:22 <lambdabot> I know nothing about all.
16:20:33 <lispy> so the difference here is what, one of uniqueness? the maximum is harder to find than some maxima?
16:20:34 <Cale> @where monads
16:20:34 <lambdabot> http://www.nomaware.com/monads/html/index.html
16:20:50 <benny99> Cale, ah, ok :)
16:21:00 <oerjan> the tutorial is also on haskell.org somewhere
16:21:09 <benny99> Cale, but the tutorial also tells you, that they aren't required etc.
16:21:16 <Cale> ah, okay
16:21:26 <mauke> @where+ monads http://www.haskell.org/all_about_monads/html/
16:21:26 <lambdabot> Done.
16:21:47 <monochrom> "maximum" means largest number of nodes possible.
16:21:55 <Cale> Most monads define fail in such a way to crash the program immediately when you use it, because there's no sensible way to fail.
16:22:02 <lispy> monochrom: what does maximal mean?
16:22:18 <oerjan> lispy: a maximum is just a matter of adding things until you stop, but the result can be pretty bad.
16:22:31 <benny99> Cale, hm.. it says the Maybe monad defines it as Nothing
16:22:38 <Cale> benny99: yeah
16:22:46 <benny99> Cale, and appears on pattern matching for example
16:22:51 <benny99> Cale, that I'm here already
16:22:52 <monochrom> maximal means any proper superset is not an independent set.
16:23:03 <lispy> oh
16:23:12 <Cale> Right, fail is really there so that monad instances can define what happens when pattern matches fail.
16:23:16 <lispy> so  in the maximal there may still be inteferrence?
16:23:25 <monochrom> No interference.
16:23:27 <kjdf> hello
16:23:40 <ihope> > do {[x] <- Just [2,3]; return x} :: Maybe Int
16:23:41 <lambdabot>  Nothing
16:23:49 <ihope> > do {[x] <- Just [2,3]; return x} :: [Int]
16:23:49 <lambdabot>  Couldn't match expected type `[t]'
16:23:54 <kjdf> do I need to import a special module to have (Monad ((->) r)) defined?
16:23:59 <lispy> well, so what i have is a sequnce of patches, and i want to find the biggest subset i can that is conflict free
16:24:04 <benny99> Cale, is the idea of monads the following? It's illegal to define function that return different output on same input. But it's legal to define unlimited many functions. Thous a "do-block" is something like a function-generator. ?
16:24:07 <ihope> kjdf: if you do, I think it's Monad.Reader
16:24:11 <oerjan> lispy: no, but let's say you have an element that interferes with everything else, then that alone is _a_ maximum, but also the worst possible
16:24:14 <lispy> is that a maximum or maximal problem?
16:24:15 <Cale> However, in Haskell 1.4 (the previous spec), there was a better solution to this problem involving a class called MonadZero (which had mzero in it). Haskell 98 merged MonadZero into MonadPlus for some stupid reason, and so they had to change the definition of do-notation.
16:24:29 <kjdf> yes it is, ihope :)
16:24:30 <kjdf> thanks
16:24:35 <ihope> benny99: I don't think I'd describe a monad that way.
16:24:41 <kjdf> how to find such things?
16:24:42 <monochrom> I think oerjan is swapping "maximal" with "maximum"?
16:24:45 <dozer> I may be being dumb again - I can't see an instance of Functor for Set
16:24:46 <benny99> Cale, maybe (wow, great joke here) they "overthought" it
16:24:53 <Cale> benny99: yeah.
16:24:53 <kjdf> other than grepping ghc source
16:24:55 <lispy> oerjan: so in that case, i would want to make everything as conflicting
16:25:06 <lispy> not make, i mean mark
16:25:19 <Cale> benny99: Let's hope it gets changed back in the next spec :)
16:25:24 <ihope> dozer: Set being an unordered list?
16:25:30 <oerjan> monochrom: quite possibly.
16:25:33 <benny99> Cale, :-[ yeah to my definition or to the "overthought" ?
16:25:43 <benny99> Cale, since I'm a newB, I hope they don't ;P
16:26:13 <Cale> benny99: I mean, let's hope they remove fail and go back to the old translation, which was saner.
16:26:20 <oerjan> lispy: no, because there might be _another_ independent set that was maximal, and much larger
16:26:42 <benny99> Cale, yeah, guess I should be able to learn that fast, even as a newb
16:26:43 <oerjan> (yeah, i meant maximal not maximum)
16:26:46 <ihope> benny99: I like to think of >>= as being function application where the argument has some say over what happens.
16:26:51 <Cale> benny99: Monads aren't just a way to get around referential transparency, but you can sort of picture many of them like that.
16:27:02 <monochrom> Let the interference graph be 0-1-2. Those - are edges.
16:27:06 <benny99> ihope, yeah, >>=, but a monad?
16:27:18 <dcoutts> Cale: sorry, missed it, what message?
16:27:21 <monochrom> One non-interfering subset is {1}. Another is {0,2}.
16:27:33 <Cale> projectxz2005: still here?
16:27:36 <dozer> ihope: ok - but all elements of every set larger than 1 must be in Ord, and map is defined on Set
16:27:37 <ihope> benny99: (>>=) :: (Monad m) => m a -> (a -> m b) -> m b--that is, the monad is m.
16:27:46 <lispy> oerjan: it wasn't a question, i was describing my desired behavior :)
16:27:59 <monochrom> {1} cannot be extended. It is very easy to find.
16:28:14 <oerjan> dozer: there is no Functor instance for Set because Set has an Ord restriction on elements
16:28:14 <Cale> dcoutts: Something about being masked -- I gave him the code which a gentoo howto says to unmask the package, but it didn't help.
16:28:14 <dcoutts> oerjan: were you talking about the same issue as Cale and projectxz2005 ?
16:28:14 <monochrom> {0,2} has a larger size. It is harder to find.
16:28:17 <ihope> dozer: if you require elements to be in Ord, then indeed, I don't believe it's a functor.
16:28:32 <ihope> dozer: if you don't, then you can probably functorate it.
16:28:49 <dcoutts> Cale: ok, as in ACCEPT_KEYWORDS="~ppc" emerge ghc ?
16:28:52 <dozer> ihope: kk
16:29:00 <lispy> monochrom: i'm not sure this translation into graph theory captures my problem correctly, so i need to think for a minute
16:29:07 <benny99> ihope, yeah, but I was thinking about the idea of monads
16:29:11 <oerjan> dcoutts: i was just trying to ping you for them
16:29:16 <dcoutts> oerjan: ok
16:29:22 <Nafai> Hi dcoutts!
16:29:27 <Cale> dcoutts: oh, not that -- it was adding a line to package.keywords
16:29:31 <dcoutts> hia Nafai
16:29:34 <Nafai> I've been looking for you :)
16:29:44 <dcoutts> Cale: ok, that's similar but permanent
16:30:23 <benny99> whatever, I'll visit my bed for the next hours :)
16:30:23 <Cale> dcoutts: It was:  echo "dev-lang/ghc-6.6.1" >> /etc/portage/package.keywords
16:30:26 <benny99> Cale, sleep well
16:30:38 <Cale> benny99: g'night
16:30:48 <ihope> (Wow. It's apparently pointless to attempt to tab-complete "benny99".)
16:30:59 <lispy> suppose i have patches B1, B2, A1 and A2 in that order, suppose that i know B1 and A1 conflict but the others do not conflict.  Then I want my algorithm to find the subset, B2, A2
16:31:00 <benny99> ihope, :D
16:31:13 <Cale> ihope: be<tab><tab> works for me
16:31:13 <dcoutts> Cale: hmm, it should be: echo "=dev-lang/ghc-6.6.1 ~x86" >> /etc/portage/package.keywords
16:31:20 <benny99> ihope, sleep well as well :p
16:31:27 <Cale> dcoutts: hmm, okay
16:31:29 <Nafai> I'm wanting to re-do and finish an app I half-wrote in Python and I need to know if: a) Gtk TrayIcon is wrapped in gtk2hs and b) if I can use d-bus (both as a client and server) within Haskell/gtk2hs programs
16:31:36 <lispy> monochrom: but, suppose B1 conflicts with B2, and B2 conflicts with A1, then it should find A2 only
16:31:39 <ihope> Cale: here that just gives "ben" and a list of nicks starting with "ben".
16:31:51 <lispy> i think
16:32:10 <dcoutts> Cale: the general format is <pkg> <keyword>, where pkg can be a version or all, eg =dev-lang/ghc-6.6.1, or merely dev-lang/ghc for all versions, or >= < > etc
16:32:11 <Cale> ihope: ah, X-chat will just cycle through the available ones if there aren't too many
16:32:20 <benny99> ihope, you can still save 1 letter :p
16:32:38 <Cale> projectxz2005: hello?
16:32:39 <ihope> benny99: I can save three letters by hitting tab three times!
16:32:47 <ihope> be<tab>n<tab>9<tab>
16:32:59 <lispy> monochrom: yeah, that's what i want, just A2
16:33:01 <ihope> Er, hmm.
16:34:02 <dcoutts> Nafai: so the tray icon code was added today by Saizan, as for dbus, kolmodin has some dbus bindings
16:34:32 <dcoutts> Nafai: so you'll need the darcs version of gtk2hs for the tray icon stuff
16:34:39 * Nafai nods
16:34:43 <Nafai> I figured that would probably be the case
16:34:59 <dcoutts> it will not be in the 0.9.12 release that will be out in a couple days
16:35:19 <Nafai> That's fine, I'm doing this for a personal app so if I have to use darcs that's fine
16:35:29 <oerjan> lispy: well in that case all you want is the set of elements that don't conflict with anything else, so it's just a filter.
16:35:40 <dcoutts> Nafai: there's a nice demo too
16:35:59 <Nafai> dcoutts: Where are the d-bus bindings?
16:36:30 <dcoutts> Nafai: actually I'm not sure, ask kolmodin
16:37:02 <Nafai> kolmodin: Around? :)
16:37:06 <kolmodin> m.. yes..
16:37:21 * dcoutts drops kolmodin in it
16:37:36 <kolmodin> ug!
16:37:57 <kolmodin> I have made partial pure haskell bindings to dbus
16:38:06 <kolmodin> they are online somewhere... :)
16:38:39 <Nafai> partial :(
16:39:04 <kolmodin> each :( sorry, I get interrupted by reallity
16:39:14 <kolmodin> darcs get http://haskell.org/~kolmodin/code/hdbus/
16:39:15 <lambdabot> Title: Index of /~kolmodin/code/hdbus
16:39:38 <kolmodin> oh noes, those are the old bindings..
16:39:51 <kolmodin> darcs get http://haskell.org/~kolmodin/code/dbus-haskell/
16:39:52 <lambdabot> Title: Index of /~kolmodin/code/dbus-haskell
16:39:57 <kolmodin> those are the latest, pure haskell
16:39:59 <dcoutts> kolmodin: how far did you get? client and server functionality?
16:40:20 <kolmodin> only client :(
16:40:25 <kolmodin> is't really not finished
16:40:34 <dcoutts> kolmodin: you should polish them off some time :-) and inotify
16:40:34 <kolmodin> I hardly think it's usable :( :(
16:40:37 <kolmodin> yeah
16:40:38 <Nafai> D'oh
16:40:52 <kolmodin> so many projects, so little time
16:40:56 <dcoutts> @arr
16:40:56 <lambdabot> Swab the deck!
16:40:57 <Nafai> I need both client and server functionality for my app
16:41:01 <Nafai> kolmodin: Understood
16:41:10 <dcoutts> Nafai: how much time do you have? :-)
16:41:12 <mauke> inotify?
16:41:17 <kolmodin> Nafai: then my lib won't cut it. but I do accept patches
16:41:18 <mauke> I've just written a haskell binding for that
16:41:36 <dcoutts> mauke: you should compare code, take the best bits
16:41:40 <dcoutts> @where inotify
16:41:41 <lambdabot> I know nothing about inotify.
16:41:43 <dcoutts> bah
16:41:44 <mauke> MY CODE IS PERFECT
16:41:56 <Nafai> dcoutts: Uh, a little, but I really don't know Haskell
16:41:58 <dcoutts> mauke: excellent, we'll borrow that than :-)
16:41:59 <Nafai> :)
16:42:12 <mauke> well, it's not as horrible as my first version
16:42:22 <kolmodin> mauke: I can't compete with that :D
16:42:43 <dcoutts> mauke: the main issue iirc was what the user api should look like, use of threads etc
16:42:44 <mauke> the first version used GHC-internal modules
16:43:17 * dcoutts -> sleep
16:43:20 <dcoutts> g'night folks
16:43:38 <mauke> my api is basically create, destroy, addWatch, rmWatch, readEvents
16:43:40 <mauke> no threads
16:44:48 <wolverian> @where hinotify
16:44:48 <lambdabot> http://haskell.org/~kolmodin/code/hinotify/
16:44:53 <kolmodin> dcoutts: good night!
16:48:22 <Nafai> kolmodin: Does your current Test.hs work?
16:48:43 <mauke> kolmodin: did you also hit the problem that inotify instances claim to be directories?
16:49:38 <mauke> makes fdToHandle blow up
16:49:57 <kolmodin> mauke: what? no. noth that I know of
16:50:26 <kolmodin> the problem is that I have basically just developed these libs, not actually used them myself for any project :(
16:50:44 <mauke> same here
16:50:55 <mauke> I like my interface better, though :-)
16:51:03 <kolmodin> I'm sure you do :)
16:51:45 <kolmodin> Nafai: which Test.hs?
16:51:59 <Nafai> In the dbus-haskell directory
16:52:42 <kolmodin> I thought it did, you have problems with it?
16:52:51 <kolmodin> it's really a unfinished project
16:53:13 <Nafai> Maybe I did something wrong but it can't find the library, even though I did the runhaskell configure/make/install bit
16:53:17 <kolmodin> you can see when I last pused patches.. :( buhu
16:53:57 <kolmodin> dbus-haskell is pure haskell, it doesn't use the C lib
16:54:46 <kolmodin> so as long as you managed to install correctly it should give you a very primitive client
16:54:59 <Nafai> Test.hs:8:7: Could not find module `System.DBus.Utils':
16:55:38 <kolmodin> um.. yes. Utils is not part of the dbus-haskell.cabal exposed-modules
16:57:17 <Nafai> Hey CosmicRay how's OSCON/
16:57:18 <Nafai> ?
16:57:45 <CosmicRay> very good.  heard two simonpj talks, for one.
16:57:46 <kolmodin> poke me tomorrow and I might have a look into it.. :)
16:57:57 <kolmodin> CosmicRay: oh happy days! :D
16:58:04 <CosmicRay> indeed ;-)
16:58:04 <Nafai> kolmodin: Okay, will do.  Thanks!
16:58:14 <Nafai> CosmicRay: Do you know if they were recorded?
16:58:24 <CosmicRay> I don't know
16:58:48 <CosmicRay> oscon said that they are not making official recordings, but have granted permission for others to do so as long as the speakers consent
16:58:59 <CosmicRay> but actually one of simonpj's talks was a keynote, which I think they did record
17:02:11 <lispy> oerjan, monochrom: yeah i just talked to droundy s'more and realized it's a different problem than i thought and, it seems like we can estimate the worst case as n^3
17:02:26 <monochrom> nice
17:02:29 <lispy> polynomial-time++
17:02:33 <oerjan> ok
17:02:35 <pastorn> @type maximum
17:02:37 <lambdabot> forall a. (Ord a) => [a] -> a
17:02:48 <lispy> :t maximum -- same syntax as ghci :)
17:02:50 <lambdabot> forall a. (Ord a) => [a] -> a
17:03:08 <monochrom> :type maximum -- different syntax
17:07:54 <ihope> > :t maximum
17:07:54 <lambdabot>  Parse error
17:07:57 <ihope> That still doesn't work.
17:08:38 <lispy> ihope: why do you want to add the ">"?
17:08:57 <ihope> lispy: because some people might assume that's how it works?
17:09:28 <mauke> those people are wrong
17:10:23 <pastorn> @src maximum
17:10:23 <lambdabot> maximum [] = undefined
17:10:23 <lambdabot> maximum xs = foldl1 max xs
17:10:29 <pastorn> thought so
17:11:12 <lispy> ihope: when you make assumptions you make an ass out of you and hmption
17:11:24 <lispy> er, without the h
17:12:12 <ihope> Um, why is maximum [] explicitly undefined?
17:12:19 <ihope> > foldl1 max []
17:12:24 <lambdabot>  Exception: Prelude.foldl1: empty list
17:12:34 <ihope> Actually...
17:12:37 <ihope> > maximum []
17:12:38 <lambdabot>  Exception: Prelude.maximum: empty list
17:12:45 <ihope> Yes, never mind
17:13:44 <Volatile> Surely there is some "reasonable" scientific explanation, after taking a phd or two...
17:14:25 <mm_freak> there was a paper about passing around configurations implicitly via haskell's type system…  does anyone have the URL?
17:15:14 <Philippa> I don't to hand - wasn't it one of Oleg's? If so that should help
17:15:16 <mm_freak> "configurations" or rather "preferences" like command line options and stuff
17:15:45 <mm_freak> i sort of remember to have heard about oleg
17:15:45 <mauke> http://okmij.org/ftp/Haskell/types.html#Prepose
17:15:46 <lambdabot> Title: Haskell Programming: Types
17:16:08 <mm_freak> mauke: thank you
17:23:45 <mauke> wtf. this doesn't make sense
17:24:51 <mauke> my program suddenly dies with "thread killed"
17:25:01 <jbalint> oom?
17:25:12 <mauke> unlikely
17:25:55 <nominolo> maybe it ate too much memory and got killed by the unx scheduler
17:25:58 <nominolo> *unix
17:26:09 <mauke> then it'd just say Killed
17:28:06 <mauke> my program uses multiple threads and calls killThread at one point, but that shouldn't affect the main thread
18:26:00 <dolio> @. pl djinn ((a -> b -> c) -> d) -> ((a,b) -> c) -> d
18:26:01 <lambdabot> f = (. ((. (,)) . (.)))
18:28:49 <Cale> :t (. curry)
18:28:50 <lambdabot> forall c a b c1. ((a -> b -> c1) -> c) -> ((a, b) -> c1) -> c
18:29:01 <Cale> dolio: ^^
18:29:02 <dolio> Yeah, that's what I used.
18:29:10 <dolio>  @pl was no help, though. :)
18:29:13 <Cale> yeah
18:30:40 <oerjan> @. pl unpl (. ((. (,)) . (.)))
18:30:41 <lambdabot> (. ((. (,)) . (.)))
18:30:47 <oerjan> @unpl (. ((. (,)) . (.)))
18:30:47 <lambdabot> (\ e k -> e (\ n d -> k (((,)) n d)))
18:33:13 <oerjan> @unpl ((. (,)) . (.))
18:33:14 <lambdabot> (\ g j d -> g (((,)) j d))
18:33:28 <dolio> @pl \f a b -> f (a,b)
18:33:28 <lambdabot> (. (,)) . (.)
18:33:34 <dolio> @pl \f (a,b) -> f a b
18:33:35 <lambdabot> (`ap` snd) . (. fst)
18:33:51 <dolio> So it doesn't seem to have (un)curry in its list of usable functions.
18:33:52 <oerjan> @unpl curry
18:33:53 <lambdabot> curry
18:35:56 <oerjan> @check (\f a b -> ((. (,)) . (.)) f a b == curry f a b) :: ((Ordering,Ordering) -> Ordering) -> Ordering -> Ordering -> Bool
18:35:58 <lambdabot>  OK, passed 500 tests.
18:38:26 <oerjan> @scheck (\f a b -> ((. (,)) . (.)) f a b == curry f a b) :: ((Bool,Bool) -> Bool) -> Bool -> Bool -> Bool
18:38:28 <lambdabot>   Completed 64 test(s) without failure.
18:39:59 <juhp> hi - just wondering if anyone has built recent ghc on ppc64?
18:40:32 <juhp> any advice on that other than "good luck!"? ;-)
18:40:46 <juhp> suppose I better ask on the ghc list...
18:40:56 <SamB> also wait longer
18:41:00 <juhp> :)
18:41:01 <SamB> and there is a #ghc channel
18:41:02 <juhp> yeah
18:41:04 <juhp> ah
18:41:13 <juhp> thanks - didn't know
18:41:14 <SamB> though it makes sense to ask here as well
18:41:18 <juhp> :)
18:41:24 <juhp> let me try there too
18:42:26 <SamB> and if you ask there, you should expect to wait even longer for a response (however your question will probably be seen for longer)
18:42:32 <blackdog> building ghc on an emulated openbsd box on a windows machine reported not super-fast. film at 11
18:42:33 <juhp> heh
18:42:52 <SamB> blackdog: you TAPED it?
18:43:29 <juhp> SamB: probably I'll send a mail while waiting - more people will see that I guess
18:43:46 <juhp> and ppc64 is obviously not a very popular platform
18:44:20 <SamB> juhp: probably related to apple's switch to x86
18:44:21 <juhp> latest linux build i could find is 6.4.2 for gentoo I think
18:44:50 <juhp> SamB: possibly - also 32bit is preferred on ppc
18:45:10 <SamB> I mean, if they were still doing PPC, probably they'd be selling 64-bit more
18:45:17 <SamB> right?
18:45:26 <juhp> true
18:46:08 <juhp> I think ibm is the main pusher of ppc64 now anyway
18:52:08 <blackdog> SamB: it's giving me a lot of spare time :)
18:52:51 <blackdog> i'm half convinced that the problem is IO - it rarely seems to get over 20% of cpu
18:53:20 <blackdog> although i guess i'm used to my G4, where the disk is not so bad but the cpu is seriously anemic
18:56:00 <Saizan> ?pl (\y ys -> (x:y):y:ys)
18:56:00 <lambdabot> ap ((.) . (:) . (x :)) (:)
18:56:39 <Saizan> ?type (\y ys -> (x:y):y:ys)
18:56:47 <lambdabot> Not in scope: `x'
18:56:56 <blackdog> oh god, we still have perl in GHC? I thought that was diked out ages ago...
18:57:46 <dolio> The evil mangler?
18:58:08 <dons> its deprecated these days. I only use -fvia-C for double/float math
18:58:08 <lambdabot> dons: You have 5 new messages. '/msg lambdabot @messages' to read them.
18:58:13 <dons> -fasm usually wins elsewhere
19:00:25 <blackdog> am just building GHC with no special flags...
19:01:03 <blackdog> dons: parenthetically - openBSD is amazingly spartan. the pain pays off, right?
19:01:20 <Saizan> ghc-6.6 still uses -fvia-C by default, iirc
19:01:25 <dons> blackdog: what do you miss?
19:01:40 <blackdog> apt-cache search
19:01:53 <dons> cd /usr/ports ; make search key=haskell
19:02:12 <blackdog> and gnu tools, but i guess that's just a culture thing - can always pkg_add gmake etc
19:02:15 <blackdog> hm
19:02:20 <dons> yeah, you'll need gmake
19:02:26 <blackdog> they told me not to use ports on #openbsd
19:02:33 <dons> hah
19:02:38 <dons> they're arseholes then
19:02:51 <dons> or where they saying to use binary packages?
19:02:56 <blackdog> well, they said pkg_add is preferred
19:03:10 <dons> yeah. that's true. if you like binaries, grabbing them off the aarnet mirror is easier
19:03:22 <blackdog> oh, that search thing is cool
19:03:23 <blackdog> thanks
19:04:08 <dons> I think the minimalism pays off, in terms of easy to lock down and configure the system
19:04:26 <blackdog> yeah, fair enough.
19:04:37 <dons> you can expect to know precisely what the machine is doing. so if you're into control..
19:04:44 <blackdog> i'm really testing it out to maybe use it as a web server, so it's good to have it locked down.
19:05:00 <dons> yeah, it definitely makes sense for firewalls/webserver/ net visible stuff
19:05:27 <blackdog> so just because something's in ports doesn't mean it has a pkg as well?
19:05:44 <dons> everything in ports should have a package on one of the mirrors
19:05:55 <dons> you can produce a package locally by typing 'make' in the ports directory for that project
19:05:58 <phoniq> so how do you
19:06:00 <phoniq> whoops
19:06:23 <phoniq> trying to put together a simple lookahead assertion in parsec that doesn't consume any input
19:06:32 <blackdog> hm. so where would i get ghc-6.6, then?
19:06:38 <blackdog> there seems to be a port for it
19:07:01 <blackdog> dons: am trying to avoid building where i can - the machine is not the fastest
19:07:17 <dons> oh, there's a port for ghc 6.6 now?
19:07:23 <phoniq> "try p"  will consume input if parser p succeeds...
19:07:24 <dons> cool. so the binary package might be on one of the mirrors
19:07:38 <Saizan> phoniq: have you seen lookAhead? it doesn't consume input if the parser succeed
19:07:39 <dons> they have snapshot builds of the ports tree too, blackdog
19:07:47 <blackdog> yeah, matthias kilian packaged it
19:07:52 <dons> so you might find a ghc package built in the last few days or weeks
19:08:03 <phoniq> Saizan: no, searching....
19:08:15 <Saizan> phoniq: so you may want lookAhead . try
19:08:22 <dons> look on the openbsd mirrors (you know here the packages live?)
19:08:47 <dons> blackdog: does that mean xmonad is in ports now too?
19:08:51 <blackdog> i know where the base stuff is
19:08:57 <phoniq> i dont see lookAhead in the legacy.cs.uu.nl docs, lemme see if this slipped by me in the reference
19:08:57 <dons> i know matthias was thinking about it.
19:09:00 <blackdog> not as far as i can tell
19:09:04 <blackdog> i did search for it:)
19:09:17 <oerjan> phoniq: it doesn't seem to be documented there
19:09:38 <oerjan> you can see it by :browsing the module though
19:09:43 <phoniq> ah ok
19:09:43 <Saizan> phoniq: i think it's been added later, you can find it here http://haskell.org/ghc/docs/latest/html/libraries/parsec/Text-ParserCombinators-Parsec-Combinator.html
19:09:45 <lambdabot> http://tinyurl.com/2jrz2m
19:09:49 <phoniq> i'm not losing my mind
19:10:00 <jfredett> how fast does (++) run on lists? is it O(1)? or O(log n) or what?
19:10:01 <phoniq> ah hah!
19:10:06 <phoniq> thanks
19:10:14 * oerjan didn't about it either :)
19:10:17 <dons> ?src (++)
19:10:18 <lambdabot> (++) []     ys = ys
19:10:18 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
19:10:46 <kpreid> jfredett: O(n) in the size of the first list
19:10:49 <dons> jfredett: its O(n), since it has to traverse the first argument, to attach the second to its end
19:10:50 <jfredett> doh! i should have realized that, so O(n) for strings of length n and m
19:10:51 <jfredett> cool
19:11:03 <jfredett> *thinks*
19:11:05 <kpreid> of course if you only ever access the first element of the result it's O(1)
19:11:13 <jfredett> tru
19:11:14 <jfredett> e
19:11:36 <jfredett> i was just reading about ropes
19:11:44 <jfredett> neat little buggers
19:12:21 <dons> you've seen Data.Sequence?
19:12:38 <jfredett> nope-
19:12:38 <jfredett> /me hoogles data.sequence
19:12:47 <Saizan> jfredett: it's often important to note that ((a++b)++c) is slower than (a++(b++c))
19:13:09 <jfredett> Saizan: makes sense
19:14:34 <jfredett> hoogle doesn't come up with anything for Data.Sequence on hoogle
19:15:00 <dons> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Sequence.html
19:15:02 <lambdabot> http://tinyurl.com/yz86s7
19:15:34 <jfredett> okay, so Sequence == ropes?
19:15:48 <Saizan> finger tree
19:16:04 <dons> sequence is 2-3 finger trees, but ropes might be a degenerated, specialised finger tree -- anyone know the relationship?
19:16:19 <jfredett> :/
19:16:30 <dons> people have suggested that a finger tree of strict bytestrings is very similar to a rope
19:16:39 <jfredett> okay
19:16:48 <jfredett> so Sequence > rope, then
19:16:53 <jfredett> err, >=
19:17:03 <dons> its more general, certainly.
19:17:06 <dons> http://www.soi.city.ac.uk/~ross/papers/FingerTree.html
19:17:08 <lambdabot> Title: Finger Trees: A Simple General-purpose Data Structure
19:17:14 <jfredett> thats what i needed
19:17:23 <dons> `2-3 finger trees, a functional representation of persistent sequences supporting access to the ends in amortized constant time, and concatenation and splitting in time logarithmic in the size of the smaller piece'
19:17:59 <jfredett> hmm, but a rope has constant time concatenation, (at least thats what I understand from this paper
19:18:29 <dons> oh, that's interesting.
19:18:47 <dons> http://www.sgi.com/tech/stl/ropeimpl.html ?
19:18:48 <lambdabot> Title: Rope Implementation Overview
19:18:56 <jfredett> it talks about Splay trees
19:19:07 <jfredett> no- its ropes: an alternative to strings
19:19:14 <jfredett> its on the wiki page for Ropes
19:19:30 <dons> `Concatenation is normally implemented by allocating a new concatenation node, and having it refer to the two arguments to the concatenation operation.'
19:19:49 <dons> so like a (.) list :)
19:20:07 <jfredett> http://www.cs.ubc.ca/local/reading/proceedings/spe91-95/spe/vol25/issue12/spe986.pdf
19:20:09 <lambdabot> http://tinyurl.com/yq85ua
19:20:18 <jfredett> thats the paper i'm muddling through
19:20:30 <dons> is that Boehm, et al?
19:20:39 <jfredett> yes
19:21:45 <jfredett> it seems to me that the structure is effectively: (dunno if this is quite right)
19:21:45 <jfredett> data Rope a = Concat [finite list of a] Rope a Rope a | Nil
19:22:33 <jfredett> so it seems that concatenation is just going "up" one step
19:22:48 <jfredett> no- that structure is wrong
19:23:11 <jfredett> it should be:
19:23:11 <jfredett> data Rope a = Concat (Rope a) (Rope a) | [finite list of a]
19:23:44 <jfredett> anyway, to concatenate, its just creating a new rope a with Concat OldRope1 OldRope2
19:24:09 <jfredett> going from rope to string though must take a while
19:24:23 <kpreid> if you don't rebalance that tree somehow you'll get unpredictable run time for accesses depending on how it was constructed
19:24:27 <jbalint> anybody built gtk2hs? i'm getting a million errors like this http://rafb.net/p/yPSyq945.html
19:24:28 <lambdabot> Title: Nopaste - No description
19:24:35 <jfredett> kpreid: they talk about that in the paper
19:25:01 <kpreid> I'd think you'd want the tree to have at least a cached depth field
19:25:44 <jfredett> kpreid: I dunno, I'm just a mathematician, all this computer stuff is greek to me, I like numbers and stuff :P
19:25:55 <kpreid> ha
19:26:15 <jfredett> I only pretend to be a computer scientist
19:26:24 <jfredett> at heart, I'll never fully comprehend all this stuff
19:27:03 <jfredett> and I'm okay with that, because I still get to play with category theory and stuff
19:27:43 <jfredett> math is like all the fun in CS, union all the fun in every other field, union all the fun intrinsic to only math
19:27:51 <jfredett> its fun stuff
19:28:21 <jfredett> and no nasty stuff "hard" stuff
19:28:34 <jfredett> like worrys about speed and whatnaught.
19:29:27 <kpreid> well, I'd argue that some fun problems are inherently practical ones :)
19:29:39 <jfredett> granted, but I just ignore those
19:29:45 <jfredett> I don't like it when things are practical
19:29:46 <jfredett> :P
19:46:26 <chessguy> 'evening
19:46:26 <lambdabot> chessguy: You have 1 new message. '/msg lambdabot @messages' to read it.
19:46:44 <chessguy> why thank you, lambdabot
19:47:19 * chessguy pets the bot
19:48:32 <dons> ?users
19:48:32 <lambdabot> Maximum users seen in #haskell: 367, currently: 319 (86.9%), active: 10 (3.1%)
19:48:40 <chessguy> @seen SamB
19:48:40 <lambdabot> SamB is in #haskell, #haskell-blah, #haskell-icfp07, #xmonad, #perl6, #oasis and #haskell-overflow. I last heard SamB speak 49m 38s ago.
19:48:58 <SamB_XP_> chessguy: hello
19:49:04 <dons> new high score
19:49:09 <chessguy> SamB_XP_, 'evening
19:49:12 <chessguy> how goes?
19:49:16 <dons> lots of people in the last week. hmm
19:49:42 <SamB> chessguy: wellish
19:49:59 <SamB> I got those gene table pages
19:50:09 <chessguy> oh really?
19:50:12 <SamB> yeah
19:50:15 <chessguy> all of them?
19:50:54 <SamB> uh huh
19:51:04 <chessguy> how?
19:51:30 <SamB> well, it turns out that my compiler was working okay
19:51:56 <SamB> making slightly different, but rather equivalent, code for those examples
19:52:33 <chessguy> er, for the field guide pages you mean?
19:52:38 <SamB> we'll have to watch to make sure we don't interfere with any markers though...
19:52:46 <SamB> chessguy: er, yeah, that
19:53:39 <SamB> anyway, once I got all those pages I tried calling some genes...
19:54:10 <chessguy> wait, so what did you have to do to get those pages?
19:54:24 <SamB> oh yeah
19:54:57 <SamB> at first I tried it by skipping by the offset after the Blue Zone marker...
19:55:19 <SamB> but I got page 8193 when I tried that
19:56:23 <SamB> so I asked if anyone else hadhad that problem, and eventually I learned that the offset is from the *beginning* of the Blue Zone marker
19:57:12 <chessguy> aha
19:58:53 <SamB> I don't really know how the code in the Blue Zone works with that, except that they probably know the exact offset of the Blue Zone from the beginning of DNA
19:59:30 * SamB wonders what color zone the adapter uses to store your DNA?
20:00:13 <SamB> anyway I also managed to pull some documentation pages, impdoc 1-10 and fuundoc 1-3
20:00:41 <SamB> oh, and now I have a make rule for building prefixes with Compiler
20:02:07 <SamB> and comment support to Compiler
20:02:19 <SamB> s/to/for/
20:02:44 <chessguy> nice
20:03:36 <SamB> because I wanted to write comments that say what symbol is being called, since I can't refer to things by name
20:07:57 <chessguy> so what happened when you tried to call some of the genes?
20:08:13 <SamB> some of them did things
20:08:26 <SamB> like, impdoc-background printed a gradiant
20:08:37 <SamB> (I was expecting background information ;-)
20:09:04 <SamB> fuundoc1, fuundoc2, and fuundoc3 printed something that looks like haddock docs for some functions
20:09:12 <chessguy> interesting
20:09:25 <chessguy> can you call 2 different genes at the same time?
20:09:37 <SamB> and impdoc1-10 printed out what I can only think must resemble some other tools autogenerated documentation
20:09:47 <SamB> chessguy: what do you think this thing is? a multiprocessor?
20:09:56 <SamB> look in some .expr files
20:09:59 <dons> 'At this point in time, my advice to new Haskell programmers would be:
20:09:59 <dons> first try Takusen, as long as it can connect to the server you're
20:09:59 <dons> using (and don't hesitate to ask the maintainers and/or haskell-cafe
20:09:59 <dons> questions); then try HDBC, perhaps avoiding the lazy retrieval
20:10:00 <dons> function.'
20:10:29 <dons> says Jeff at Deutsche Bank
20:10:41 <dons> so maybe that should be our recommendation for dbs ?
20:10:48 <Saizan> ?where takusen
20:10:48 <lambdabot> I know nothing about takusen.
20:11:05 <chessguy> @go takusen
20:11:07 <lambdabot> http://darcs.haskell.org/takusen/
20:11:07 <lambdabot> Title: Index of /takusen
20:11:15 <dons> ?where+ takusen http://darcs.haskell.org/takusen/
20:11:15 <lambdabot> Done.
20:11:28 <SamB> chessguy: so did you type make fuundoc{1,2,3}.png impdoc{1,2,3,4,5,6,7,8,9,10}.png
20:12:27 <chessguy> SamB no, i didn't yet. i haven't even pulled your stuff yet
20:13:01 <SamB> I also found a couple of help pages I hadn't seen before
20:13:10 <chessguy> how?
20:13:16 <SamB> well, they were genes
20:13:22 <SamB> with obvious help- names
20:13:32 <SamB> I called them
20:13:40 <SamB> (I called "terminate" after)
20:14:11 <chessguy> ok, it's chewing on those files
20:15:05 <Saizan> dons: it seems slightly harder to build and build programs that uses it, you need the database libs in your path
20:15:35 <chessguy> i'm off to bed for now. i'll check back with you tomorrow. maybe this will be done by then
20:15:42 <chessguy> 'night
20:18:48 <jfredett> Kickass, Haskell Curry was born in Millis.
20:18:52 <jfredett> I've totally been there
20:19:11 <jfredett> (Millis, Massachusetts.)
20:23:11 <sfultong> hmm, 80 miles from here
20:25:55 <dibblego> does OCaml have type-classes or equivalent?
20:26:17 <jfredett> where do you live, sfultong?
20:26:29 * jfredett is in bellingham, MA
20:26:31 <jfredett> :)
20:26:40 <dons> dibblego: it has modules, that type class dictoinaries can be translated to
20:26:59 <dons> in practice, that encoding for overloading behaves like a manually desugared type class implementation
20:27:00 <benomatic> anybody read/have an opinion on Programming in Haskell book (by Hutton), and its ability to get monads through to my tiny brain?
20:27:03 <Cale> dibblego: It has a module system which is powerful enough to be equivalent to typeclasses (in theory). In practice, they're each a bit better at different things.
20:27:20 * sfultong is in amherst, ma
20:27:46 <dibblego> benomatic, it is sitting right next to me; I think the web tutorials are better
20:27:46 <jfredett> coolbeans, I've been up that way too, school up there? zoomass? :)
20:28:23 <dibblego> since O'Caml has type-classes, can I write a type-safe monad bind abstraction?
20:28:31 <benomatic> dibblego: which in particular?  i've been through a couple of them, but am not to the point that i could comfortably open up parsec and write a simple language parser (which is my learning goal)
20:28:56 <sfultong> well... actually, I just finished a CS degree at Umass in Dartmouth... now living with my parents for a bit... hopefully not too long
20:29:09 <sfultong> I like cheap education :-P
20:29:28 <sfultong> ideally, self-education
20:29:35 <benomatic> i also bailed out of the scheme-in-haskell interpreter, since it got over my head about 1/4 of the way in, primarily due to requiring monad usage i couldn't pull off
20:29:44 <dibblego> benomatic, the book has a short paragraph on monads; but really, they are nothing complicated, so maybe that is a good thing
20:30:00 <jfredett> lol, i'm notsomuch right now, WPI == 50k/yr, me == white, male, and not super brilliant, therefore I don't get not scholarship love from WPI
20:30:28 <jfredett> i'm (hopefully) getting into Worcester state this fall, but they seem to be having difficulty with that now
20:30:30 <jfredett> so who knows
20:30:39 <sfultong> grad degree?
20:30:42 <jfredett> maybe I'll just be a self-education bum for a while
20:30:46 <jfredett> undergrade
20:30:50 <jfredett> undergrad*
20:30:56 <jfredett> I'm a youngster
20:31:04 <sfultong> yeah, I'm liking the self-education bum life right now
20:31:20 * jfredett 's not even 20, (one week, :) )
20:31:25 <SamB_XP_> the trouble with that is that your parents expect you to do lots of chores...
20:31:44 <sfultong> well... heh, I actually have got a good excuse for that
20:32:02 <SamB_XP_> broken leg?
20:32:07 <sfultong> heh...
20:32:32 <sfultong> actually, I fell out of the third floor balcony at my old apartment, and got somewhat paralysed
20:32:44 <SamB_XP_> oh
20:32:51 <SamB_XP_> is it permanent?
20:32:51 <sfultong> it's a good excuse to program a lot, and not do chores
20:32:56 <jfredett> oh- that _is_ a good excuse
20:33:17 <jfredett> damn- you could have just played sick or something- no need to paralyse yourself
20:33:29 <jfredett> you've got some commitment man.
20:33:44 <SamB_XP_> *giggles*
20:33:51 <sfultong> some degree of it will always be premanent... but hopefully eventually I'll hobble around on my feet in some form
20:34:02 <sfultong> right now I'm wheelchairing around
20:34:20 <SamB_XP_> but, damn, that's a really good excuse...
20:34:24 <sfultong> yeah, it is
20:34:29 <jfredett> You could be like house
20:34:39 <jfredett> except with computers
20:34:39 <sfultong> yeah, that'd be fun
20:34:51 <sfultong> except I'm not so good with being a bastard
20:34:52 <jfredett> "Lets do a differential diagnosis on this segfault!"
20:34:58 <jfredett> sfultong: I'll do that part
20:35:04 <jfredett> you just do the hard work
20:35:07 <SamB_XP_> calculus on segfaults?
20:35:12 <jfredett> I'll make fun of people
20:35:26 <jfredett> SamB_XP_: why not, we do it on datastructures
20:35:33 * jfredett points at Zipper
20:35:39 <SamB_XP_> but...
20:35:48 <SamB_XP_> segfaults are just... segfaults!
20:35:59 <sfultong> well, I was going to end up working doing web development in C#/.Net.... so I guess I've been saved from that life :-P
20:36:04 <benomatic> dibblego: in reality, it's mostly the notation that confuses me, not the concepts.  the intermingling of $ . <<= etc... is what baffles me a bit... and then combine w/ the do notation.  none of the srcs i've seen so far give good explanation :(
20:36:05 <newsham> do not violate the segments
20:36:12 <jfredett> data SegFault = StopUsingC | YouDolt
20:36:46 <SamB_XP_> sfultong: you could be the token paralytic in some department in some university. they have those, right?
20:37:05 <sfultong> heh, probably
20:38:01 <Cale> benomatic: (.) is function composition, defined as (f . g) x = f (g x)
20:38:26 <sfultong> apparently they had some sort of eccentric old professor at my university that was teaching Haskell, who left my first year, without me meeting him...
20:38:31 <Cale> benomatic: ($) is function application, that is f $ x = f x, but the ($) operator has really low precedence
20:38:40 <sfultong> I had to learn about Haskell on /.
20:38:53 <Cale> (so it's often used to remove parens along with (.))
20:39:11 <Cale> For example,  f . g . h $ x is the same as f (g (h x))
20:39:16 <jfredett> theres only 1 class at WPI that even mentions haskell
20:39:23 <jfredett> I heard about it through Coding Dojo
20:39:24 <jfredett> :)
20:39:37 <Cale> benomatic: Does that help at all?
20:39:41 * phoniq is watching the . $ thing too
20:39:44 <benomatic> yes.  'tis a good start :)
20:40:00 <benomatic> so basically $ just drops the normally high precedence of function application
20:40:04 <Cale> yeah
20:40:14 <benomatic> well, function args is the way we C programmers would say it ;-)
20:40:32 <jfredett> C makes me feel dirty inside
20:40:37 <benomatic> but the f . g . h $ x illuminates nicely
20:40:39 <Cale> Function application binds tighter than any operator
20:40:41 <newsham> ?src ($)
20:40:41 <lambdabot> f $ x = f x
20:40:44 <sfultong> I think it would be kinda neat to have function application have really low precedence...
20:40:48 <sfultong> by default
20:41:08 <phoniq> and it starts from the left, right?
20:41:11 <phoniq> er, correct?
20:41:15 <Cale> yeah
20:41:20 <benomatic> Cale: care to lecture on return next?
20:41:23 <benomatic> :-)
20:41:25 <Cale> f x y z = ((f x) y) z
20:41:29 <Cale> Okay
20:41:35 <jfredett> Yes Dr. Cale, lenlighten us!
20:41:45 <jfredett> s/lenlighten/enlighten/
20:41:47 <Cale> return in Haskell doesn't do what it does in imperative languages
20:42:02 <Cale> It simply builds an action which always returns the given value.
20:42:03 <newsham> unfortunate naming :(
20:42:11 <Cale> It's not *that* unfortunate.
20:42:15 <SamB_XP_> newsham: well unit would be even more confusing
20:42:16 <newsham> I think so.
20:42:25 <SamB_XP_> because it wouldn't even give a clue what was going on
20:42:30 <newsham> return in most languages implies control flow
20:42:43 <SamB_XP_> and this is Haskell's fault how?
20:42:48 <newsham> "wrap" seems to make more sense to me
20:42:48 <benomatic> where an 'action' translates to a specific sequence of events
20:43:02 <SamB_XP_> I think return makes perfect sense as a name...
20:43:03 <Cale> benomatic: yeah. For example, an IO action.
20:43:06 <benomatic> (unlike ordinary code, where ordering is only defined by the compiler)
20:43:10 <newsham> samb: doesnt every function in haskell return something? :)
20:43:26 <SamB_XP_> @let f x = Nothing
20:43:29 <lambdabot> Defined.
20:43:36 <SamB_XP_> that function -- it returns Nothing
20:43:37 <Cale> benomatic: right. Though, even in a do-block, the evaluation order might be different from the order implied by the monad, depending on the monad you're using.
20:43:44 <newsham> nothing is something too :)
20:43:57 <Cale> In IO, the order of execution is basically just what it looks like though.
20:44:39 <benomatic> i think what i need to do is write a file containing all the sets of the equivalent mechanisms...
20:44:50 <newsham> > let wrap = return in wrap 3 :: [Int]
20:44:51 <lambdabot>  [3]
20:44:52 <SamB_XP_> but the order implied by do in *most* monads is actually of more than a little relevance -- though sometimes they'll seem to start at the end...
20:44:57 <newsham> > let wrap = return in wrap 3 :: IO Int
20:44:58 <lambdabot>  <IO Int>
20:45:08 <newsham> it wrapped up my 3!
20:45:15 <Cale> benomatic: So (return x) is just a no-op action that returns x
20:45:41 <benomatic> so return itself isn't somehow strictly correlated w/ monads?
20:45:48 <Cale> Oh, it is.
20:46:00 <newsham> its the action that doesnt do anything except result in the given value
20:46:00 <Cale> return :: (Monad m) => a -> m a
20:46:16 <Cale> By an 'action', I mean a value in some monad.
20:46:34 <Cale> For example, in IO, you have actions like getLine
20:46:42 <SamB_XP_> are there any collections of monadic primitives that don't include "return"?
20:46:46 <cbrad> Perhaps it is useful to remember that a monad is simply an instance of class Monad
20:47:07 <cbrad> The Monad class defines the function return
20:47:23 <newsham> getLine does something (consumes input) as well as returns something (the input it consumed)
20:47:40 <newsham> "return 3" doesnt do anything, but returns something (3)
20:48:07 <Cale> benomatic: Have you learned the basics about how IO works in Haskell?
20:48:25 <benomatic> i did the first time around.  some of it has escaped my brain since i put haskell down for 2 months :(
20:48:31 <Cale> ah, okay
20:48:39 <lispy> > do Just x <- return 5; return x :: [Int]
20:48:40 <lambdabot>   add an instance declaration for (Num (Maybe Int))
20:48:44 <newsham> http://www.haskell.org/haskellwiki/Introduction_to_Haskell_IO/Actions
20:48:47 <lambdabot> Title: Introduction to Haskell IO/Actions - HaskellWiki, http://tinyurl.com/3xxhdp
20:49:01 <lispy> n/m bad example because it doesn't work...
20:49:15 <benomatic> newsham: tnx
20:49:21 <Cale> So in Haskell, computations which do some I/O before returning a value of type t, are represented by (basically inert, opaque) values of type (IO t).
20:49:46 * SamB_XP_ goes for late-night korean soap opera
20:49:47 <Cale> Or just this :) http://www.haskell.org/haskellwiki/Introduction_to_IO
20:49:48 <lambdabot> Title: Introduction to IO - HaskellWiki
20:50:08 <Cale> But I'll probably just say what it says anyway :)
20:50:15 <benomatic> :-)
20:50:17 <Cale> Some examples...
20:50:22 <Cale> getLine :: IO String
20:50:28 <Cale> putStrLn :: String -> IO ()
20:50:51 <Cale> (note that () is a type with only one defined value, called ())
20:50:51 <dons> i like conor. he's got a flair for clarity. http://programming.reddit.com/info/29icg/comments
20:51:12 <dons> ?bot
20:51:12 <lambdabot> :)
20:51:13 <Cale> In a compiled Haskell program, you define an action called 'main'
20:51:34 <Cale> and it's really the only IO action which ever gets executed in a compiled Haskell program
20:51:48 <Cale> Of course, it might be built up from many other actions
20:52:09 <Cale> So, for example, we can write a hello world program:
20:52:09 <newsham> big honking action
20:52:17 <Cale> main = putStrLn "Hello, World!"
20:52:30 <int-e> . o O ( pure little main gets exposed to the cruel real world (or RealWorld# as some people call it) )
20:52:50 <Cale> Ugh, don't talk about the ugly RealWorld hack
20:53:23 <int-e> heh it's not ugly. it's just not a story for newbies :)
20:53:25 <Cale> I'd prefer people to think of values of type (IO t) as simply snippets of executable program code.
20:53:26 <newsham> runState main RealWorld
20:53:40 <jfredett> Only a haskeller can say the words "I occasionally implement type checkers" with such nonchalance. *goes back to reading mailinglist post*
20:54:11 <benomatic> should i simply ignore this RealWorld bit for now? :-)
20:54:17 <Cale> benomatic: I think so.
20:54:41 <Cale> I'd prefer people just regard values of type (IO t) as little blocks of code which are waiting to execute.
20:54:44 <int-e> yes. think of the run time system as an interpreter for IO actions that's given the result of main to run
20:54:45 <dons> jfredett: :)
20:55:00 <jfredett> dons: its true
20:55:08 <Cale> (code that might involve running IO primitives)
20:55:28 <jfredett> i've never heard a C junkie or a Python addict saying "I occasionally implement Type Checkers"
20:55:31 <Cale> *Evaluating* a value of type (IO String), for example, doesn't really do a whole lot.
20:55:59 <jfredett> or a Java-head talking about implementing a theorem prover
20:56:14 <dons> yep, the haskell crowd is an interesting bunch of hackers
20:56:15 <int-e> > print "Hello" `seq` 42
20:56:17 <lambdabot>  42
20:56:31 <Cale> It's only *executing* them, which is something that only the runtime system can do, which performs the effects.
20:56:31 <jfredett> dons: we're not hackers, we're freaking crazy people. :/
20:56:39 <dons> of course, Conor writes theorem-proving type checkers (epigram)
20:56:39 <Cale> benomatic: Does that make sense?
20:56:44 <benomatic> yeah
20:56:51 * jfredett waves hands wildly
20:57:13 <sfultong> jfredett: I've been trying to convince some of my math major friends to embrace haskell, but so far it hasn't worked... any tips?
20:57:22 * jfredett puts on his tin foil hat and returns to hacking away.
20:57:26 <newsham> sfultong: put a lambdabot ontheir channel
20:57:30 <int-e> jfredett: who let *you* out of your padded cell?
20:57:41 <newsham> next time they ask a quesiton about some math thing, make lambdabot answer them
20:57:46 <jfredett> The aliens, Dr. int-e
20:57:50 <newsham> sooner or later they'll get suckered in
20:57:52 <sfultong> crazy is just another word for creative
20:57:53 <jfredett> they don't like water
20:57:56 <jfredett> sfultong: hmm
20:58:05 <jfredett> sfultong: what kind of math do they like?
20:58:09 <Cale> Now, without a way to put smaller actions together into larger ones, you can't really get very far. Perhaps the simplest way to put IO actions together is the (>>) operator, which takes two actions and simply runs one, throws away its result and then runs the second, returning its result.
20:58:22 <Cale> Rather, it produces the action which does that when run.
20:58:28 <sfultong> jfredett: hmm, not sure about that...
20:58:32 <Cale> So for example,
20:58:44 <gaal> I'm getting errors about GNUmakefile when building ghc-head. anyone familiar with this?
20:58:45 <Cale> main = putStrLn "Hello" >> putStrLn "World"
20:58:45 <benomatic> so any sequence of a >> b >> c >> .. >> q would run [a-q], returning result of q?
20:58:52 <jfredett> sfultong: theres a little bit for everyone, really, Differential Datatypes are sure to be interesting to someone who studies Differential Equations/Calculus related stuff.
20:58:54 <newsham> > putStrLn "reading" >> readFile "/etc/passwd"
20:58:56 <Cale> will print "Hello" and "World" on separate lines
20:58:56 <lambdabot>  <IO [Char]>
20:59:00 <jfredett> hell, they're interesting to just about everyone
20:59:05 <int-e> benomatic: when run, yes.
20:59:21 <jfredett> I personally like the algebraic data structures, (I'm a big Algebra guy. :) )
20:59:22 <newsham> (notice lambdabot didnt actually print or read anything, it just combined things)
20:59:23 <Cale> (>>) :: IO a -> IO b -> IO b
20:59:41 <jfredett> I have some posts about peano's axioms on my blog, they probably aren't very good, but they're about type-classes and whatnot
21:00:15 <Cale> Yeah, lambdabot won't actually carry out the execution of the IO actions, it'll just possibly evaluate them a bit (which doesn't have any side effects), and then print a little textual representation.
21:00:55 <Cale> It just prints the type, since you can't actually look inside an IO action to see what it does after the fact.
21:01:04 <benomatic> sensible
21:01:15 <sfultong> jfredett: where @?
21:01:27 <jfredett> http://disparatemathematician.blogspot.com/
21:01:29 <lambdabot> Title: The Disparate Notions of a Lowly Mathematician
21:01:34 <Cale> Now, (>>) is good, but so far there's no way to use the result of the first action to determine what the rest of the action will be.
21:01:35 <jfredett> they're's a few of them
21:01:41 <sfultong> thanks
21:01:55 <jfredett> i've got the last one in the series almost done
21:02:18 <Cale> So we define another operator, called "bind" which is (>>=) :: IO a -> (a -> IO b) -> IO b
21:02:53 * benomatic mentally grunts while trying to read that type
21:03:00 <Cale> If x is an action, and f is a function from possible results of that action to further actions to be done, then (x >>= f) is an action which performs x, passes its result to f and runs the result of that.
21:03:16 <Cale> (Returning the final result)
21:03:29 <brad__> i would like to add a changelog to a cabal tarball. is there a blessed way to do this?
21:03:34 <Cale> This is perhaps a little confusing until you see some examples
21:03:52 <Cale> For example, the program which reads a line from the user and prints it back out might be written as:
21:03:57 <int-e> brad__: hum I guess you could declare it with  extra-sources
21:04:02 <benomatic> intuitively this is still sensible.  feels like unix pipes to me :)
21:04:12 <brad__> thanks int-e!
21:04:13 <Cale> getLine >>= \line -> putStrLn line
21:04:15 <dibblego> @google unix pipes monads
21:04:17 <lambdabot> http://okmij.org/ftp/Computation/monadic-shell.html
21:04:17 <int-e> brad__: assuming you meant the source tarball
21:04:17 <lambdabot> Title: UNIX pipes as IO monads
21:04:17 <Cale> Or simply:
21:04:21 <Cale> getLine >>= putStrLn
21:04:22 <newsham> getArgs >>= (\xs -> putStrLn (head x))
21:04:35 <newsham> is sort of like:  let xs <- getArgs in putStrLn (head x)
21:04:47 <newsham> (which isnt legal haskell syntax)
21:05:24 <newsham> just like:  (\x -> 3 + x) 5    is sort of like let x = 5 in 3 + x
21:05:33 <Cale> Well, it's exactly like  do xs <- getArgs; putStrLn (head xs)  (which is legal Haskell syntax that translates down into what newsham first wrote)
21:05:50 <Cale> Or another example:
21:05:55 <Cale> main = putStrLn "Hello, what is your name?"
21:05:55 <Cale>       >> getLine
21:05:55 <Cale>       >>= \name -> putStrLn ("Hello, " ++ name ++ "!")
21:05:59 <newsham> if you're not used to the lambdas it imght look a little confusing at first
21:06:03 <jfredett> time for foodstuffs, brb
21:06:10 <int-e> brad__: sorry, it's  extra-source-files:
21:06:13 <Cale> oh, yes, I should have checked that
21:06:20 <benomatic> nah, the lambda is fine
21:06:48 <Cale> So does (>>=) make some sense?
21:06:56 <benomatic> yeah.  but i have a query.
21:07:07 <desp> autotools == PURE EVIL
21:07:22 <Cale> You can think of it as just being a variation of (>>) which captures the result of the first action and lets you decide what to do based on it, rather than throwing it away.
21:07:38 <int-e> desp: have you seen libtool?
21:07:39 <benomatic> so when i consider the type of >>=, it's return type is ultimately "m a" or something like that, ultimately meaning that it's of type a, but of a type a that's flagged as impure?
21:07:44 <newsham> (or converse >> is like >>= :)
21:07:45 --- mode: ChanServ set +o dons
21:07:50 --- topic: set to '["The Haskell programming language: we occasionally implement typecheckers","Home: http://haskell.org","Paste: http://hpaste.org","Logs: http://tunes.org/~nef/logs/haskell/","The language of ICFP winners 3 years running"]' by dons
21:07:55 --- mode: ChanServ set -o dons
21:07:55 <desp> int-e: even better?
21:08:06 <Cale> benomatic: An (IO String) is very different from a String
21:08:11 <newsham> beno: its not always "impure", but IO is.
21:08:43 <Cale> benomatic: An (IO String) is a lot more like a representation for a block of code that would produce a string if run.
21:09:08 <Cale> Or, in another monad, say, the list monad, [String] is a list of strings.
21:09:14 <sfultong> so how'd this year's ICFP contest turn out, anyway?  Is there a common consensus on who should be the winner?
21:09:23 <Cale> So it's important not to confuse the two :)
21:09:32 <benomatic> it seems like i should take the eval vs. exec notion further then: basically it feels like each >>= is a residuation of the previous action components
21:09:50 <int-e> desp: actually with libtool the documentation alone is scary - I've never looked at the source code in detail but it must be full of hacks.
21:09:55 <Cale> I'm not sure what residuation means :)
21:10:11 <int-e> desp: besides a 8000 line shell script is scary.
21:10:15 <Cale> But remember that >>= itself builds an action from its parameters.
21:10:15 <newsham> I like to think of an IO String as a program that results in a string. and (>>=) as composing two smaller programs into a bigger one
21:10:15 <benomatic> yeah, it's unusual term, but i dunno an equivalent.
21:10:19 <desp> :)
21:10:40 <newsham> program construction kit
21:10:45 <benomatic> if you're building up ASTs like (+ 2 4), you can execute them, or residuate them and pass them along for later execution/translation
21:11:03 <Cale> ah, yes
21:11:07 <Cale> exactly.
21:11:08 <benomatic> basically symbolically representing something that could be potentially executed
21:11:12 <benomatic> for later use
21:11:21 <dmwit> thunks!
21:11:23 <benomatic> (comes from program analysis world, i believe)
21:11:23 <Cale> Execution of IO actions is never ever caused by evaluation.
21:11:44 <newsham> realMain = runIO main :)
21:12:08 <benomatic> Cale: btw, the list monad comment above threw me off.  lists are monadic types?
21:12:12 <int-e> newsham: you mean unsafePerformIO. But note that even with that definition you need someone to spark it.
21:12:22 <Cale> benomatic: yep :)
21:12:29 <newsham> int-e: ghc = runIO main? :)
21:12:40 <int-e> newsham: I hope not.
21:12:40 <newsham> a.out = runIO main, better.
21:12:45 <Cale> benomatic: The list monad behaves basically identically to list comprehensions, if you know what those are.
21:12:51 <benomatic> yep
21:12:58 <Cale> > do { x <- [1,2,3]; y <- [4,5]; return (x,y) }
21:12:59 <lambdabot>  [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
21:13:02 <int-e> newsham: a.out may work in a Haskell OS :)
21:13:13 <Cale> Or:
21:13:26 <Cale> > [1,2,3] >>= \x -> [4,5] >>= \y -> return (x,y)
21:13:28 <lambdabot>  [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
21:14:01 <Cale> Just so that you don't go off thinking that monads are only for imperative programming :)
21:14:04 <newsham> the combining operations (>>= / >>) are a bit different for [] than for IO
21:14:12 <Cale> yes, very different :)
21:14:26 <int-e> > return 4 :: [Int]
21:14:26 <benomatic> so it seems
21:14:27 <lambdabot>  [4]
21:14:36 <int-e> return is also different :)
21:14:40 <Cale> In fact, they're just ordinary functions -- the only monads which really need to be "built in" are IO and ST
21:14:45 <newsham> the State monad is a little more like the IO monad in its combinations.
21:14:59 <sfultong> > return 4 :: [] (Num a)
21:15:00 <lambdabot>      Class `Num' used as a type
21:15:00 <lambdabot>     In the type `Num a'
21:15:00 <lambdabot>     In the type `[] (...
21:15:07 <newsham> > runState (do { x <- get; put (x+3); return (x-1)}) 5
21:15:08 <lambdabot>  (4,8)
21:15:09 <Cale> (ST is like a restricted form of IO that only gives you mutable cells, but otherwise is pure)
21:15:19 <int-e> @type [4]
21:15:21 <lambdabot> forall t. (Num t) => [t]
21:15:36 <newsham> in the state monad >>= also combines little programs into a bigger program.  this time you use "runState" to run the program
21:15:44 <newsham> (instead of it being implicitely run as "main")
21:15:49 <Cale> Sorry if all this is a little confusing. Let me explain the list monad a bit :)
21:15:57 <Cale> In the list monad, we have:
21:16:00 <Cale> return x = [x]
21:16:09 <benomatic> i was just noting that i'm on edge of drowning in the deep end  :-)
21:16:10 <Cale> and  xs >>= f = concat (map f xs)
21:16:47 <Cale> (Might want to check that this gives >>= the type [a] -> (a -> [b]) -> [b] in the list monad)
21:16:49 <newsham> the combination rule for lists (>>=) iterates over the first list and provides each value as input to the function
21:17:15 <newsham> then collects all the resuls of each function invocation back into a single list
21:17:15 <benomatic> cross products basically
21:17:22 <benomatic> or something more than that?
21:17:26 <Cale> Well, yeah.
21:17:46 <Cale> It gives the Cartesian product rather nicely
21:17:47 <newsham> > do { x<-[1,2,3]; y<-"abc"; return (x,y) } -- cross product
21:17:48 <lambdabot>  [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
21:17:51 <Olathe> Is there a way in ghci to do: data Maybe a = Nothing | Just a ?
21:17:56 <benomatic> and this is all built in to the normal builting [] list type?
21:17:57 <Cale> Olathe: nope
21:18:03 <Olathe> Alright, thanks.
21:18:13 <Cale> benomatic: It's just part of the library.
21:18:26 <int-e> @src [] (>>=)
21:18:27 <lambdabot> m >>= k     = foldr ((++) . k) [] m
21:18:31 <Cale> ugh
21:18:39 <Cale> I'm starting to hate @src
21:18:47 <newsham> beno: notice the similarity to list comprehensions:
21:18:57 <benomatic> so the real question in my head: the cross products part was clear.  the question is why.  is there some way of thinking about what a monad is that means that a list monad would naturally do this x-product stuff, or are those definitions just 'useful'?
21:19:01 <newsham> > [(x,y)| x<-[1,2,3], y<-"abc"]
21:19:03 <lambdabot>  [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
21:19:48 <int-e> hmm. ugly :/ the standard Prelude definition is nicer. (but why doesn't it use concatMap?)
21:20:00 <newsham> beno: they're each useful individually.  having them all defined in the same way (in terms of (>>=) and "return") lets you abstract out patterns and share them
21:20:20 <Cale> benomatic: Well, the list monad is just an example of a monad. To have a monad, you need three things: 1) A type constructor M. 2) A function return :: a -> M a, and 3) A function (>>=) :: M a -> (a -> M b) -> M b
21:20:28 <newsham> for example    liftM f act = do {x<-act; return (f x)}
21:20:30 <Cale> And they have to satisfy a few simple rules.
21:20:33 <sfultong> where does @src pull from?
21:20:44 <newsham> you could have implemented something like that individually for lists and for IO
21:20:49 <Cale> sfultong: Its own database which has been largely constructed from the GHC sources.
21:20:50 <newsham> but abstraction lets you share
21:20:56 <dons> sfultong: from a cached databaes of the standard library
21:21:21 <Cale> benomatic: Do you have any sort of background in functional programming?
21:21:35 <Cale> (Outside of Haskell)
21:21:40 <benomatic> unfortunately no.
21:21:43 <Cale> Okay
21:21:51 <dons> hey everyone, I'm going to try to give an xmonad demo at the haskell workshop. What would people be interested in seeing/reading about?
21:21:52 <brad__> is there a way to specify a numeric Int-like type that is only for positive numbers?
21:21:55 * jfredett coughs: "learn lisp"
21:21:58 <jfredett> :)
21:22:01 <dons> There's a lot of aspects to xmonad: which ones are interesting?
21:22:15 <Cale> Well, something that functional programmers have been doing for a long long time, much longer than playing around with monads, is constructing what are called "combinator libraries"
21:22:38 <benomatic> jfredett: i started learning lisp once, and quickly came to despise a language with a naming scheme as consistent as php's.
21:22:44 <Cale> A combinator library is just a library with an expressive enough API that it becomes like a little programming language unto itself.
21:23:16 <Cale> It will have some primitive computations, and some means of combining them together into more complex ones.
21:23:35 <jfredett> benomatic: heh, lisp is actually remarkably consistent, its the people who build on top of it that aren't
21:24:07 <Cale> For example, a parsing library might have some simple parsers for parsing single characters, tokens, what-have-you, and then some means of combining simple parsers into more interesting ones
21:24:35 <benomatic> Cale: makes sense
21:24:37 <int-e> common lisp has no FFI, end of story. (correct me if I'm wrong)
21:24:38 <Cale> For example, a parser which parses using a first parser and then a second. (the concatenation)
21:25:36 <Cale> It turns out that many such combinator libraries have a common structure, and it's valuable to factor out that structure so we can share code between all the combinator libraries with that structure.
21:25:46 <Cale> This is basically what the idea of monads does for us.
21:26:09 <Cale> So there's a library (Control.Monad) with a whole bunch of control structures that work with other libraries.
21:26:24 <Cale> For example, things like 'foreach' loops.
21:26:30 <Cale> (forM/mapM)
21:26:36 <int-e> I still want to rename "Monad" to "Sequencable" (but by now it'll be confused with Data.Sequence I guess)
21:26:56 <benomatic> am i better off trying to understands the general notion of Monads outside the context of IO?
21:27:09 <Cale> Well, work on both :)
21:27:13 <benomatic> it feels like the two are perhaps too intertwined in my noggin
21:27:24 <Cale> The idea of monads in general is actually too simple to be easily understood.
21:27:29 <sfultong> benomatic: I'd say learn monads separately
21:27:44 <Cale> It's easier to understand lots of examples and then sort out what they all have in common.
21:28:11 <int-e> benomatic: the individual monads have far more differences than they have in common really; the underlying monad structure just allows you to arrange actions in sequence, extracting results from previous actions.
21:28:17 <sfultong> I feel like I understand monads, but I feel like I have a long way to go in understanding how to use them, especially effectively
21:28:36 <Cale> IO is perhaps the hardest individual monad to understand, because it has lots and lots of things in it which most monads don't.
21:28:56 <int-e> on the other hand the IO monad is probably the simplest to just use.
21:29:15 <Cale> Yeah, it's a strange little paradox :)
21:29:21 <newsham> beno: you should probably get comfortable with IO first because thats what you'll need first.  and once you have a intuition for it, some of the other monad things will kind of just make sense
21:29:22 <int-e> because it does something familiar from imperative programming languages (if that's the background where you come from)
21:29:47 <benomatic> so monads are just a primitive for residuated sequencing.  it just so happens that IO is the common use, because IO naturally requires sequencing, and has side effects.
21:30:03 <Cale> a common use, anyway
21:30:28 <Cale> And they're not really a primitive, but an abstraction, I'd say.
21:30:30 <newsham> hmm.. from your earlier description of residuating I think thats not right.  list monads are evaluated immediately
21:30:43 <Cale> Like, 'return' and 'bind' are defined separately for each monad.
21:30:46 <Cale> (overloaded)
21:31:05 <benomatic> is the residuation up to teh definition of the monad library somehow?
21:31:07 <int-e> newsham: the intermediate lists are computed lazily though
21:31:12 <newsham> also its worth noting that monads aren't language builtins (well, except things like IO) but are actually implemented in libraries
21:31:22 <Cale> newsham: Well, they're not, but that's only because almost everything in Haskell is lazy.
21:31:30 <newsham> inte: as are other non-monadic functions
21:31:41 <Cale> benomatic: yes, exactly
21:31:41 <benomatic> perhaps residuated is too strong -- but bundled up to be executed as a whole (ie, the term action?)
21:31:51 <Cale> benomatic: Up to the specific monad you're using
21:32:00 <benomatic> interesting.
21:32:06 <newsham> beno: yah, bundled up sounds good
21:32:18 <benomatic> clarity feels like it's on the near horizon
21:32:26 <benomatic> now i just have to write gobs of code to make it stick
21:33:39 <newsham> you still get to have fun parsing type errors when you get something wrong :)
21:33:58 <int-e> newsham: of course. there's not so much special about monads ... sequencing is just a *very* common structure.
21:34:21 <benomatic> Cale et al: thanks for taking the time.
21:34:35 <Cale> benomatic: No problem, let us know if you have any more questions.
21:34:57 <Cale> benomatic: I really like giving one example of a general monad control structure...
21:35:13 <newsham> lambdabot is great for working through simple examples
21:35:15 <Cale> sequence :: (Monad m) => [m a] -> m [a]
21:35:41 <Cale> If xs is a list of actions, then sequence xs is the action which performs each of them in turn, returning a list of the results.
21:35:51 <Cale> We can write it like this:
21:35:57 <Cale> sequence [] = return []
21:35:57 <newsham> > (do {x<-vals; return (+ 1) x}) [1,2,3]
21:35:58 <lambdabot>   Not in scope: `vals'
21:36:14 <wli> Also note Data.Traversable.sequence
21:36:17 <Cale> sequence (x:xs) = do { v <- x; vs <- sequence xs; return (v:vs) }
21:36:36 <newsham> > let vals = [1,2,3] in do {x<-vals; return ((+ 1) vals)}
21:36:37 <lambdabot>   add an instance declaration for (Num [t])
21:36:44 <Cale> No need to vastly generalise yet :)
21:36:52 <Cale> Simple loops are pretty good on their own :)
21:36:56 <newsham> > let vals = [1,2,3] in do {x<-vals; return ((+ 1) x)}
21:36:57 <lambdabot>  [2,3,4]
21:37:03 <Cale> Or:
21:37:09 <newsham> > liftM (+ 1) [1,2,3]
21:37:10 <lambdabot>  [2,3,4]
21:37:12 <newsham> ?src liftM
21:37:13 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
21:37:33 * wli found it easier to understand the things in terms of fmap/liftM, return, and join as primitives.
21:37:47 <Cale> sequence [] = return [];  sequence (x:xs) = x >>= \v -> sequnce xs >>= \vs -> return (v:vs) -- desugaring the do-notation.
21:38:18 <newsham> > liftM2 (+) [1,2] [3,4]
21:38:20 <lambdabot>  [4,5,5,6]
21:38:21 <Cale> For instance,
21:38:49 <Cale> sequence [getLine, getLine] is an action that will get two lines from the user, returning them in a list of length 2
21:39:04 <benomatic> check
21:39:13 <Cale> From sequence and map, we can easily build a for-each loop.
21:39:19 * wli picked up HSoE and HtCoFP tonight but has doubts he'll get around to reading the things.
21:39:33 <Cale> forM xs body = sequence (map body xs)
21:40:01 <Cale> The loop body is just a function from elements of the list to actions to be performed.
21:40:09 <newsham> > forM [1,2,3} (\x -> print x)
21:40:22 <newsham> > forM [1,2,3] (\x -> print x)
21:40:23 <lambdabot>  <IO [()]>
21:40:58 <wli> There is forM [1..3] print
21:41:06 <dibblego> ?type forM
21:41:08 <Cale> Of course, in cases like newsham's this collects up a list of values we don't care about, so there are modified versions: sequence_ and forM_ which throw the results away.
21:41:08 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
21:41:19 <benomatic> why is that IO[()] -- the () baffles me?
21:41:20 <newsham> forM [1,2,3] print = squence (map print [1,2,3]) = sequence [print 1, print 2, print 3] = ...
21:41:24 <benomatic> s/?/./
21:41:50 <Cale> benomatic: Because each print returns a ()
21:41:58 <Cale> and the sequence collects that result
21:42:06 <benomatic> ah, empty return
21:42:08 <Cale> yeah
21:42:26 <Cale> So you get a list of ()'s which is probably worthless
21:42:33 <newsham> > () : [(), ()]
21:42:34 <lambdabot>  [(),(),()]
21:42:39 <Cale> So that's where sequence_ and forM_ come in.
21:42:54 <dibblego> ?check () + [(), ()] == [(), (), ()]
21:42:54 <lambdabot>  Couldn't match expected type `()' against inferred type `[a]'
21:43:03 <Cale> There's also mapM/mapM_ which are the same as forM and forM_ but with the parameters the other way around.
21:43:15 <newsham> ?src sequence_
21:43:16 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
21:43:17 <int-e> > sequence [[1],[2,3],[4,5,6]] -- figuring out this tells a lot about the list monad
21:43:18 <lambdabot>  [[1,2,4],[1,2,5],[1,2,6],[1,3,4],[1,3,5],[1,3,6]]
21:43:35 <newsham> sequence_ [print 1, print 2, print3] = print 1 >> print2 >> print 3
21:44:01 <Cale> sequence_ [print 1, print 2, print3] = print 1 >> print2 >> print 3 >> return ()
21:44:11 <newsham> yes. my bad.
21:44:12 <Cale> (which is the same)
21:44:21 <mm_freak> i don't understand that paper about implicit configurations =/
21:44:36 <newsham> = forM_ [1,2,3] (\x -> print x)
21:44:52 <newsham> which is like:   foreach x [1,2,3] { print x }   in an imperative language
21:44:58 <dV^> lambda abuse
21:45:07 <newsham> (except no loop-carried values)
21:45:08 <wli> eta reduce please
21:45:31 <newsham> i'm expanding this out to python, i wante the lambda
21:45:37 <benomatic> heh
21:46:15 <newsham> everyone's so pointless
21:46:31 <dibblego> what's your point?
21:46:36 <newsham> x?
21:46:49 <benomatic> the stream of thoughts/examples has been pointed for me :-)
21:46:53 <Cale> Or kind of like ruby's [1,2,3].each {|x| print x}
21:47:28 <newsham> even a closer match
21:47:29 <int-e> I'm still wondering why pointless code has so many dots in it.
21:47:38 <Cale> int-e: hehe
21:47:49 <newsham> a thousand pointless lights?
21:47:51 <wli> sequence [[1,2],[3,4],[5,6]] is more enlightening.
21:47:54 <benomatic> are monads the only way to get that kind of loop?
21:48:18 <newsham> beno: no.  in pure code you can do various kinds of loops too
21:48:20 <benomatic> (that sequence gives you)
21:48:24 <Cale> benomatic: well, no, they're a way to write that kind of loop only once and have it work in all your embedded languages though
21:48:24 <newsham> but you never have a loop that doesnt return a  value
21:48:33 <newsham> (for a pure function that would be truely pointless)
21:48:57 <newsham> foldl and iterate are too good examples of looping with pure functions
21:49:12 <Cale> benomatic: oh, that sequence gives you? I suppose still no, but for that you really do need actions as first class values.
21:49:21 <newsham> and map (which is closely related to forM)
21:49:28 <Cale> (and which don't just run during evaluation)
21:49:45 <newsham> s/too/two/
21:49:50 <Olathe> What is Just defined as ?
21:49:55 <int-e> > replicateM 3 "01"
21:49:57 <lambdabot>  ["000","001","010","011","100","101","110","111"]
21:50:02 <dibblego> Olathe, a -> Maybe a
21:50:06 <int-e> Olathe: hmm? it's a constructor
21:50:09 <Cale> Olathe: data Maybe a = Nothing | Just a
21:50:11 <dibblego> ?type Just
21:50:13 <lambdabot> forall a. a -> Maybe a
21:50:31 <Olathe> So, you could do: data Maybe a = Nothing | Kaboom a ?
21:50:47 <dibblego> Olathe, in another module, sure
21:51:03 <newsham> data PLZ a = AWSUM_THX a | O_NOES String
21:51:07 <Cale> Or  data Maybe a = Foo | Bar a
21:51:08 <Olathe> newsham: Heheh
21:51:14 <Cale> Nothing and Just are just names
21:51:19 <wli> > [length $ sequence $ [[n*(n-1)`div`2+1..n*(n+1)`div`2]|n<-[1..k]]|k<-[1..6]]
21:51:20 <benomatic> i spose it's time to look at parsec, and see if it makes sense :)
21:51:21 <lambdabot>  [1,2,6,24,120,720]
21:51:30 <Cale> benomatic: go for it :)
21:51:52 <wli> > [sequence $ [[n*(n-1)`div`2+1..n*(n+1)`div`2]|n<-[1..k]]|k<-[1..3]]
21:51:53 <lambdabot>  [[[1]],[[1,2],[1,3]],[[1,2,4],[1,2,5],[1,2,6],[1,3,4],[1,3,5],[1,3,6]]]
21:52:01 <Cale> benomatic: With parsec, sequence takes a list of parsers, and gives a parser that parses each of those things in turn.
21:52:03 <Olathe> What about data Maybe a = String | Kaboom a ?
21:52:14 <dibblego> Olathe, it is isomorphic to Data.Maybe
21:52:20 <int-e> Olathe: sure, String isn't even taken as a data constructor yet
21:52:22 <Cale> (returning a list of the parsed results)
21:52:50 <int-e> Olathe: also data Maybe a = Maybe a | CertainlyNot
21:52:50 <benomatic> Cale: that sounds simply too intuitive :)
21:53:05 <Olathe> int-e: How would that work ?
21:53:14 <Cale> benomatic: It's rather satisfying to be able to invent your own control structures when you need them too, though I'll admit most of the common cases are already in Control.Monad.
21:53:26 <dibblego> Olathe, they are just names of functions; they "work" by changing names
21:53:38 <wli> data AtLeastOneOf t t' = Both t t' | OnlyFirst t | OnlySecond t' deriving (Eq, Ord, Read, Show)
21:53:42 <int-e> Olathe: type names and constructors live in different namespaces.
21:53:58 <Olathe> Oh.
21:54:05 <int-e> (I should say 'data constructors' just to be precise)
21:54:28 <benomatic> Cale: thanks again.  it's damned kind of you to take the time.
21:54:35 <Cale> :)
21:54:44 <Cale> You're quite welcome.
21:54:55 <mm_freak> @src length
21:54:55 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
21:54:56 <dmwit> data Either money booze = Left money | Right booze
21:55:14 <dmwit> :t foldr
21:55:16 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
21:55:23 <int-e> Olathe: it's actually common to do that for newtypes, say  newtype State s x = State { runState :: s -> (s, x) }
21:55:24 <newsham> data Either married happy ?
21:55:34 <brad__> cannot i mandate a package version in a cabal file? like time-1.1.1 ? i am seeing errors
21:55:49 <dibblego> data Either withUs againstUs
21:55:51 <benomatic> newsham, int-e and whoever else is lurking in the my scrollback: thanks as well for the supplements and examples :)
21:56:12 <newsham> beno: my pleasure.  happy coding.
21:56:14 <SamB_XP_> Cale: does Control.Monad have (<<=) :: Monad m => m a -> m b -> m a
21:56:16 <dmwit> data Either home here = Left home | Right here -- a pun!
21:56:24 <SamB_XP_> (and that is *not* const!)
21:56:38 <int-e> @type liftM2 const
21:56:40 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m a1
21:56:46 <mm_freak> data AnyModulus a = AnyModulus (Modulus s a)
21:56:53 <mm_freak> Modular.hs:8:40: Not in scope: type variable `s'
21:57:15 <dmwit> data AnyModulus a = forall s. AnyModulus (Modulus s a)
21:57:30 <int-e> @type (<*) -- SamB, this may work actually
21:57:32 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
21:57:33 <mm_freak> Modular.hs:8:20: Not a constructor: `forall'
21:57:38 <dmwit> Also likely is that you're mistaken about what you want.
21:57:47 <dmwit> mm_freak: -fglasgow-exts ?
21:57:49 <SamB_XP_> int-e: What the heck?
21:57:55 <mm_freak> ah
21:57:57 <SamB_XP_> oh. btw.
21:58:02 <int-e> SamB_XP_: because instances of Monad should also be instances of Applicative
21:58:04 <SamB_XP_> > join
21:58:05 <lambdabot>  Add a type signature
21:58:10 <SamB_XP_> hmm.
21:58:14 <mm_freak> dmwit: thanks, that's working
21:58:15 <SamB_XP_> int-e: are they?
21:58:20 <SamB_XP_> why should they be ?
21:58:37 <brad__> anyone know how to mandate a minimal package version requirement in a cabal file?
21:58:38 <int-e> SamB_XP_: probably not all of them but every monad can be made an instance of applicative.
21:58:45 <dons> brad__: yep, pkg>=1.0
21:58:51 <brad__> thanks dons!
21:59:03 <int-e> SamB_XP_: with pure = return and (<*>) = ap
21:59:05 <dons> brad__: http://darcs.haskell.org/~sjanssen/xmonad/xmonad.cabal
21:59:15 <dons> build-depends:      base>=2.0, X11>=1.2.1, X11-extras>=0.2, mtl>=1.0, unix>=1.0
21:59:19 <SamB_XP_> @type pure
21:59:20 <lambdabot>     Ambiguous occurrence `pure'
21:59:21 <lambdabot>     It could refer to either `pure', imported from Control.Applicative
21:59:35 <SamB_XP_> I new it! conflicts!
21:59:39 <brad__> yes dons, i have already tested it out! thanks!
21:59:43 <dons> cool
21:59:48 <int-e> @type Control.Applicative.pure
21:59:50 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
21:59:54 <dons> 2.0 gives you the base library for ghc 6.6., btw. it implies a ghc 6.6 dependency
21:59:54 <brad__> when is xmonad 0.3 coming btw?
22:00:11 <brad__> :)
22:00:13 <dons> i'd imagine hmm, soon. I'm tied up with my phd writeup, and spencer's doing the Summer of Code.
22:00:18 <dons> but we're done with features for 0.3
22:00:23 <dons> so its just a matter of tagging it
22:00:31 <brad__> cool! well thanks!
22:00:40 <dons> and he's gone in a flash
22:00:56 <Cale> benomatic: Something that really impresses me is that monads come from a very new (1950/1960) branch of mathematics called category theory, that is so abstract that even mathematicians call it "abstract nonsense". The idea that category theory would have a practical application outside of pure mathematics so soon is something which I find very amusing :)
22:01:29 <SamB_XP_> Cale: perhaps we should use that to explain monads
22:01:33 <SamB_XP_> "abstract nonsense"
22:01:41 <SamB_XP_> then people will stop trying to understand them!
22:01:52 <int-e> I like 'join': Take a computation that returns a computation, run it, then run the result.
22:02:03 <SamB_XP_> (there really isn't much to understand)
22:02:14 <int-e> SamB_XP_: but you have to understand that first.
22:02:18 <int-e> it's Zen really
22:02:23 <Cale> (On the other hand, it makes sense -- category theory's main purpose within mathematics was in finding the right abstractions for things to use. Computer scientists struggle with exactly that problem all the time.)
22:02:23 <wli> Well, IMHO the stock primitives obfuscate things.
22:02:39 <sfultong> category is seeming to me that it may be the string theory of mathematics...
22:02:46 <SamB_XP_> Cale: ... and giving them the wrong names??? ;-)
22:02:47 <Cale> sfultong: oh?
22:03:08 <jfredett> sfultong: there is not TOE in math, Godel proved that
22:03:09 <jfredett> :P
22:03:12 <benomatic> Cale: unfortunately, i think the subtelties of monads are still lost on me... but it's definitely funny to think that abstract nonsense has practical value
22:03:23 <phoniq> that depends on what you think of string theory...
22:03:28 <benomatic> s/subtelties/subtleties/
22:03:36 <dibblego> Godel
22:03:42 <dibblego> s/Goedel
22:03:44 <SamB_XP_> is Alice in Wonderland abstract or concrete nonsense?
22:03:56 <int-e> SamB_XP_: heresy!
22:03:58 <jfredett> dibblego: spelling schmelling
22:04:04 <SamB_XP_> int-e: what?
22:04:15 <SamB_XP_> int-e: you aren't going to tell me it's not nonsense!
22:04:16 <Cale> Actually, yeah, at first I thought that sfultong's comment was an insult to category theory, now I realise it could just as easily have been a compliment ;)
22:04:16 <sfultong> jfredett: well, I meant in the sense that they're both hyped up, but people well-versed in their respective fields tend to disregard them
22:04:22 <jfredett> I'm american, I'll say it how I want, if you dont like it, your a terrst
22:04:29 <dibblego> you're
22:04:31 <int-e> SamB_XP_: no but I was suggesting that I could :)
22:04:32 <dibblego> :)
22:04:44 <jfredett> dibblego: ur a terrst
22:04:45 <SamB_XP_> int-e: with a straight face?
22:04:49 <int-e> SamB_XP_: hardly.
22:04:58 <SamB_XP_> jfredett: dubya pronounces it better than that
22:05:00 <Cale> sfultong: Well, depends on what you mean by "disregard". Lots of category theory has been blended into mathematics throughout.
22:05:05 <SamB_XP_> you are a word tersed!
22:05:06 <jfredett> thats the point
22:05:19 <Cale> sfultong: Right down to the point that people don't define functions without drawing a little arrow somewhere. :)
22:05:38 <wli> join is better explained as that nesting a monad yields something isomorphic to or canonically embeddable within the original monad. Or otherwise, if you repeatedly apply the type constructor, there's some function that canonically maps the result to a type where the type constructor is only applied once.
22:05:52 <SamB_XP_> Cale: the little arrow is from CT?
22:05:59 <Cale> Yeah f: R -> R
22:06:06 <SamB_XP_> can I get some Silver Points with that arrow?
22:06:07 <Cale> That notation is only 50 years old.
22:06:16 <int-e> wli: try explaining that to a programmer :)
22:06:23 <SamB_XP_> I prefer f :: R -> R
22:06:30 <wli> So for lists, concat, for Maybe, maybe Nothing id, etc.
22:06:31 <SamB_XP_> save : for more important things ;-)
22:06:39 <wli> int-e: See above.
22:06:47 <Cale> SamB_XP_: In mathematics, it's not a problem.
22:06:51 <SamB_XP_> yeah yeah.
22:06:53 <psykotic> join: you run a computation-producing computation, and in turn run the computation produced.
22:07:01 <psykotic> nothing hard about it.
22:07:04 <int-e> psykotic: I said that earlier
22:07:07 <SamB_XP_> mathematicians will put up with an awful lot of implicit, ad-hoc overloading
22:07:10 <Cale> SamB_XP_: Humans are pretty good at disambiguating by context :)
22:07:12 <psykotic> int-e, ah ok
22:07:14 <wli> Describing monads as "computations" is confusing IMHO.
22:07:33 <SamB_XP_> wli: monads aren't computations
22:07:36 <sfultong> yeah, mathematics is WAY too overloaded for me
22:07:38 <Cale> wli: Well, types of computations.
22:07:40 <SamB_XP_> they are ways of computing
22:07:47 <psykotic> wli: thinking about monads in the usual CT is much more misleading than thinking about it in terms of computations.
22:07:51 <jfredett> sfultong: but overloading is the best part of math... :)
22:07:52 <int-e> wli: you need some intuition behind it to explain the stuff.
22:08:08 <psykotic> wli: for haskell purposes, i mean.
22:08:09 * SamB_XP_ shocks sfultong with jigawatts of electricty
22:08:11 <int-e> wli: throwing definitions at people doesn't help them with getting that intuition
22:08:25 <jfredett> 1.21 jiggawatts!
22:08:26 <Cale> Of course, if we're in #Haskell, I'm not going to introduce monads by talking about metric completion.
22:08:28 <wli> int-e: Well, the intuition I've developed after 8 years of biting on granite is what I'm describing.
22:08:43 <Cale> You customise the explanation to the use :)
22:09:07 <psykotic> wli: the CT intuition about monads is best founded in thinking about adjunctions and such, but in haskell that requires pulling in categories that have no manifestation within haskell itself.
22:09:10 <sfultong> jfredett: I meant to say the symbols were overloaded
22:09:16 <SamB_XP_> wli: do you have any advice on how to pick a good dentist?
22:09:23 <Cale> http://www.monad.ca/index.aspx -- hehehe
22:09:25 <lambdabot> Title: Monad Industrial Constructors Inc. - Home
22:09:29 <dons> ha
22:09:41 <dons> i would have sworn monad.ca was a Cale homepage or something :)
22:09:41 <wli> SamB_XP: Word of mouth. ;)
22:09:46 <sfultong> jigga wat?
22:09:48 <psykotic> cale: i remember some guy in a reddit thread once telling (not tongue in cheek, quite seriously, in his ignorance) to check out the "original source on monads", leibniz
22:09:49 <SamB_XP_> hahaha
22:09:54 <jfredett> jigga who?
22:10:03 * jfredett starts rapping
22:10:05 <SamB_XP_> sfultong: never watched Back to Future?
22:10:09 <dons> psykotic: heh
22:10:11 <sfultong> actually, no
22:10:15 <sfultong> I know, I'm weird
22:10:20 <dons> I like my monads with  Industrial Constructors
22:10:21 <Cale> psykotic: yeah, hehe, that usage is not etymologically related.
22:10:23 <SamB_XP_> sfultong: well, that would be why you don't get it
22:10:37 <dons> that web site rocks
22:11:45 <Cale> Today, Monad provides general contracting services in the oil and gas, petrochemical, mining, power, and pulp and paper industries. Annual volumes range from $20 million to $50 million.
22:12:09 <psykotic> those sound like very side-effectful industries
22:12:26 <Cale> hahaha
22:12:37 <dons> http://programming.reddit.com/info/29ire/comments
22:12:37 <wli> Anyway, the way monads make sense to me is (a) Functor / fmap (liftM) -- you can have some analogue of List.map through the structure (b) return -- there is some canonical injection into the structure (c) join -- if your type constructor is C then there's some canonical mapping join :: C (C t) -> C t
22:12:37 <lambdabot> Title: Industrial-strength monad contructors (reddit.com)
22:12:38 <dons> :D
22:13:08 <Cale> dons: haha, beat me to it :)
22:13:21 <dons> you should drop it by -cafe@
22:14:25 <Cale> If they look at their logs, they'll be scratching their heads for quite a while over all the hits from programming.reddit.com
22:14:45 <dons> heh
22:14:46 <psykotic> wli: i find both views useful. the one you describe is more useful when you are dealing with monads with an "algebraic" feel.
22:17:15 <wli> psykotic: I'm not talking about algebra. I'm talking about a presentation that got someone who had a real hard time with monads for a very long time actually able to use them.
22:17:23 <psykotic> wli: okay. whatever works :)
22:17:40 <psykotic> the kleisli view has been way more helpful for me for haskell.
22:19:29 <wli> psykotic: It may *coincidentally* coincide with various abstract things. It has nothing to do with them. Basically, the type of (>>=), Monad m => m a -> (a -> m b) -> m b, is too involved to digest. Breaking it down into fmap/liftM and join get the types down to something digestible.
22:20:15 <psykotic> wli: if you permute the arguments of >>= it's very clear what it does, though.
22:20:22 <psykotic> (a -> m a) -> (m a -> m b)
22:20:33 <Cale> wli: It's not too hard to digest if you're thinking about computations.
22:20:39 <int-e> the type of >>= is just conveniant.
22:20:44 <Cale> wli: It's in fact, very very natural.
22:20:51 <int-e> for computations and threading results from one to the next
22:21:06 <psykotic> err, (a -> m b) -> (m a -> m b)
22:21:24 <int-e> in terms of computations, join is more awkward. not everyone is used to writing interpreters and compilers all the time :)
22:21:24 <Cale> Once you decide that you need a way to sequence computations, and to be able to use results of previous computations to determine what follows, that type falls right out.
22:21:25 <psykotic> which is to say, that it "lifts" terms, to allow them to be composable.
22:21:33 <wli> Cale/int-e: Don't know what to tell you. I failed to develop intuition with (>>=) and (=<<) where fmap and join worked well.
22:21:44 <Cale> wli: I did too. :)
22:21:46 <int-e> wli: use whatever works for you.
22:21:58 <Cale> wli: But I think both perspectives are useful.
22:22:07 <int-e> wli: it took me a while to understand join.
22:22:14 <Cale> I find fmap/join more useful when trying to invent monads.
22:22:16 <opqdonut> join is kinda complicated, yes
22:22:25 <SamB_XP_> @src join
22:22:25 <lambdabot> join x =  x >>= id
22:22:33 <psykotic> cale: yep. and i maintain that join is much useful when you're dealing with monads with an algebraic feel, because in that case it can be regarded as 'erasing the parentheses', 'flattening the structure', etc
22:22:37 <int-e> wli: I also understand why join is more convenient in a mathematical framework
22:22:37 <SamB_XP_> how is that complicated?
22:22:41 <Cale> psykotic: right
22:22:47 <wli> x >>= f = join (fmap f x)
22:22:50 <Cale> psykotic: for combinatorial things, it's great
22:22:56 <SamB_XP_> though I thik that's a funky definition
22:23:03 <SamB_XP_> @unpl join
22:23:04 <lambdabot> (\ b -> b >>= \ a -> a)
22:23:13 <opqdonut> :D
22:23:14 <SamB_XP_> @unpl join p
22:23:14 <lambdabot> (p >>= \ a -> a)
22:23:21 <wli> @pl \x f -> join (fmap f x)
22:23:21 <lambdabot> (join .) . flip fmap
22:23:28 <wli> @pl \f x -> join (fmap f x)
22:23:28 <SamB_XP_> @. redo unpl join p
22:23:28 <lambdabot> (=<<)
22:23:29 <lambdabot> (do { a <- p; a})
22:23:30 <int-e> @type (>>= id)
22:23:36 <lambdabot> forall (m :: * -> *) b. (Monad m) => m (m b) -> m b
22:24:46 <dons> John sez: `In any case, Simon's Haskell talks have really been highlights this week for many' at OSCON. yay1
22:24:59 <Cale> yay!
22:25:05 <Cale> When will the videos arrive?
22:25:30 <dons> no idea yet. but i've seen 5+ blogs already about how great spj's talks have been
22:26:04 <wli> The list and maybe monads are the simplest to look at.
22:26:12 <glguy> hi wli
22:26:17 <Cale> wli: I also like ((->) e)
22:26:23 <wli> re glguy
22:26:30 <benomatic> spj is to haskell as GvR is to python ?
22:26:34 <glguy> back to the digital world  Isuppose :)
22:26:54 <int-e> > join (local (const 3) (+)) 5
22:26:55 <lambdabot>  8
22:27:13 <Cale> benomatic: yeah, except Simon knows what he's talking about, hehe :)
22:27:14 <wli> Cale: That's harder to see in action because it's not of observable type.
22:27:50 <Cale> benomatic: (He's a programming languages researcher who's also responsible for a lot of development in GHC)
22:28:27 <wli> pj-lester-book is a phenomenally good tutorial BTW.
22:28:28 <benomatic> ja, i knew he was heavily involved, but i wasn't sure at all how haskell evolves and is run
22:29:11 <wli> If you want to understand the operational semantics of all this it's really crucial.
22:29:23 <Cale> (I'm just poking fun at GvR because he's managed to say some astonishingly stupid things for someone who is responsible for the development of a successful programming language.)
22:29:45 <int-e> he's just afraid of the pointy ends of lambda.
22:29:54 <wli> I vaguely wish there were a chapter in it for more modern abstract machines like STG, (\nu, G), etc.
22:30:15 <dons> yeah, my theory is that because interpreters are so easy to write, bad languages get big quickly. leading to these huge messes like php
22:30:37 <wli> dons: And perl, python, et al.
22:30:38 <benomatic> Cale: i dunno how brilliant he is, but he's masterful at yoking and directing the energy and effort of the py community
22:30:45 <int-e> dons: the thing is, python is actually quite nice.
22:31:10 <int-e> (in my opinion, ymmv)
22:31:14 <benomatic> php was an avoidable mistake.  they just chose not to.
22:31:35 <psykotic> wli: btw this is easily the most enlightening paper on monads i ever read (but i am weird),
22:31:37 <Cale> Hehe, somehow mIRCScript comes to mind.
22:31:46 <psykotic> Moggi, Notions of computation and monads. http://www.disi.unige.it/person/MoggiE/publications.html
22:31:49 <lambdabot> Title: Eugenio Moggi Publications
22:32:01 <SamB_XP_> Python isn't too bad if you keep your nose out of the dark, evil corners
22:32:14 <psykotic> it's the first paper of his in which he defines a Kleisli triple/monad in terms of a "lifting" * that takes a -> T b to T a -> T b. in his earlier paper on monads he used the join formalism
22:32:17 <int-e> SamB_XP_: hah you can say that about haskell, too
22:32:19 <Cale> If you could define some product of horribleness and popularity, it would be up there.
22:32:43 <Cale> (or at least, it would be, back in 1995 or so)
22:32:44 <dons> data Prod f g x = f x :*: g x is rather lovely
22:33:03 <SamB_XP_> int-e: Python's dark corners aren't always so clearly labeled
22:33:11 <SamB_XP_> and there are a lot more of them
22:33:20 <SamB_XP_> and they weren't placed there on purpose as such!
22:33:30 <int-e> SamB_XP_: I'll say getContents and leave it at that.
22:35:30 <wli> Has anyone else noticed that the readline lib behaves weirdly?
22:36:30 <wli> Like if you hit ^C it doesn't seem to get the signal until you hit return?
22:39:34 <psykotic> cale: have you read that paper i referenced?
22:40:02 <psykotic> cale: there's a really nice intuitive (but convincing) argument that the monad axioms are exactly what's needed to turn programs into a proper category.
22:40:46 <Cale> I think I've glanced at it before, I should probably take a closer look :)
22:46:34 <psykotic> there's a really nice justification for why "programs of type B with a parameter of type A" ought to be interpreted as morphisms A -> T(B): "for their domain there are two alternatives, either A or T(A), depending on whether parameters of type A are identified with values or computations or type A. We choose the first alternative, because it entails the second. Indeed computations of type A are the same as values of type T(A)."
22:48:37 <desp> does anyone know if there can be comments in diff files?
22:49:25 <dons> yeah, above the diff data, usually
22:49:36 <desp> do they need a prefix?
22:49:42 <Pseudonym> diff doesn't make comments
22:49:45 <Pseudonym> Did you mean patch files?
22:50:13 <Pseudonym> Anything that doesn't look like a diff is ignored by patch.
22:50:20 <desp> ah.
22:51:08 <psykotic> cale: and then once you've settled on interpreting "programs of type B with a parameter of type A" as morphisms A -> T(B), the extension operator * : (A -> T(B)) -> (T(A) -> T(B)) is exactly what you need to define a notion of morphism composition in the category of programs; unit/return becomes the identity arrow in that category, and the monadic laws just say that unit/return is indeed the identity in that category, and the composition in the cat is
22:51:08 <psykotic>  associative, etc.
22:51:35 <psykotic> cale: i know you know this argument, but i haven't seen it summarized as elegantly as in this paper. sigfpe has an old blog post that sort of touches on it, but not quite.
22:52:34 <Cale> Yeah, it is pretty nice. :)
22:53:13 <int-e> oh Kleisli arrows.
22:53:22 <psykotic> yep
22:55:24 <Cale> Category theory seems to be a rather good set of tools for finding definitions where you get the sense that it "just has to be this way" :)
22:55:34 <psykotic> exactly
22:56:10 <psykotic> i think beginners often think that you're being arrogant when you say "just write down the obvious commutative diagrams", and so on, but there really is that sort of inevitability to it
22:56:21 <psykotic> you write down some stuff, and you just turn the crank
22:57:48 <psykotic> btw i bet many haskellers are better at many mathematicians when it comes to thinking intuitively and powerfully about naturality arguments, in the guise of parametricity
22:58:24 <psykotic> i remember explaining why the dual functor on the category of vector spaces wasn't a natural construction, and why the double dual functor was, to a haskeller, based on parametricity
22:58:57 <kilimanjaro> whats a natural construction?
22:59:09 <kilimanjaro> i hear this come up in CT talks but I dont know any myself
22:59:24 <psykotic> intuitively, that no "arbitrary choices" are involved.
22:59:29 <kilimanjaro> ahh
22:59:53 <kilimanjaro> dual functor is a map V -> (V -> F) right?
23:00:00 <kilimanjaro> err, in that case I mean
23:00:02 <psykotic> for example, two vector spaces of the same dimension are isomorphic, but generally not naturally so, because the choice of isomorphism involves an arbitrary choice of basis, if you will
23:00:04 <kilimanjaro> F is the field
23:00:08 <psykotic> yes
23:00:36 <psykotic> so what's the double dual?
23:00:54 <kilimanjaro> (V -> F) -> (V -> F) -> F ?
23:01:01 <kilimanjaro> err
23:01:02 <kilimanjaro> V
23:01:05 <kilimanjaro> at the end there I meant
23:01:15 <kilimanjaro> beats me really
23:01:33 <kilimanjaro> double dual is the dual of the dual?
23:01:46 <Cale> yes
23:01:55 <Cale> V** = (V -> F) -> F
23:02:22 <psykotic> and there's a natural map from V to that. you just apply V to the V -> F arg
23:02:54 <psykotic> you usually see math guys write that as v(f) = f(v)
23:02:59 <psykotic> which is a sort of obnoxious notation :)
23:03:10 <Cale> hehe :)
23:03:32 <psykotic> kilimanjaro, anyway, can you see why there isn't a natural map V -> (V -> F)?
23:04:08 <kilimanjaro> the details of the actual mapping are not implied, just the domain/codomain
23:04:18 <psykotic> kilimanjaro, imagine you're coding in haskell. you need a map f v v' = ... :: F. how the hell can you produce something of type F?
23:04:24 <psykotic> well, sine it's a field you can produce something...
23:04:36 <psykotic> because all fields are guaranteed to have certain elements, namely 0 and 1.
23:05:06 <psykotic> and so on
23:05:23 <psykotic> and you can combine them using the field operations. but the point is that now something else comes into play, which is linearity
23:05:43 <psykotic> the point is that you can only conjure up constant functions of that type.
23:05:44 <kilimanjaro> well I was just saying, imagine the construction mapping v to \x -> v*x, you can also do this for v to \x->(-v)*x
23:05:56 <psykotic> but the only constant function that is linear is 0. and that is a pretty fucking boring map, certainly not an iso.
23:06:49 <kilimanjaro> im not sure what you mean by your haskell example
23:07:09 <psykotic> well, think of vector spaces and fields as type classes.
23:07:28 <psykotic> you want to produce a map (VectorSpace V, Field F) => V -> (V -> F)
23:07:43 <psykotic> actually i guess it's (VectorSpace V F, Field F)
23:08:35 <psykotic> the point is, when you use typical program reasoning to try to write out a map of that type, the only thing you can write is a constant-valued function, that spits out the same value of F regardless of the two arguments
23:09:02 <psykotic> but since we also want the map to be linear, the only valid choice in that category (in which all maps are linear) is the 0-valued constant map.
23:09:15 <kilimanjaro> wait you lost me with the "typical program reasoning"
23:09:28 <kilimanjaro> I thought the standard map was v mapped to \x -> v*x
23:09:37 <psykotic> kilimanjaro, okay, simpler example. give me something of type forall a. a -> a
23:09:43 <kilimanjaro> id
23:09:50 <psykotic> give me something of type forall a. a that isn't undefined
23:10:07 <psykotic> (you can't)
23:10:39 <kilimanjaro> ok
23:10:40 <psykotic> give me something of type (VectorSpace v f, Field f) => v -> v -> f that is linear
23:10:59 <psykotic> so how would you start? you write out a stub...
23:11:10 <psykotic> f x y = ... :: f
23:11:13 <psykotic> err, bad name
23:11:18 <psykotic> func x y = ... :: f
23:11:51 <psykotic> if you look at the functions on the two type classes, there is nothing on VectorSpace v f that produces an f as return value
23:12:26 <psykotic> if we were dealing with, say, inner product spaces, there would be an inner product that did that. but we don't have inner products, we just have plain vector spaces.
23:12:42 <psykotic> makes sense?
23:12:46 <kilimanjaro> yes
23:12:51 <loldongs> DCC SEND LOLDONGSLOLDONGSLOLDONGSLOLDONGS 0 0 0
23:12:57 <psykotic> so to produce something of type f you can only use functions on the Field type class
23:13:13 <psykotic> but those don't involve the vectors (the arguments) in any way, so all you can get is a constant function that ignores its two arguments
23:13:23 <kilimanjaro> ok gotcha
23:13:29 <psykotic> and finally, since we want the map to be linear, the only choice is zero :: f
23:13:31 --- mode: ChanServ set +o Pseudonym
23:13:32 <kilimanjaro> sorry I just wasnt thinking about it
23:13:52 <psykotic> so the only possibility for that map is the zero-valued constant map
23:14:05 <psykotic> and that map is "degenerate" in a certain sense, so that it doesn't induce an isomorphism between V and V -> F
23:14:14 <kilimanjaro> right
23:14:17 <psykotic> the conclusion: there is no natural isomorphism between V and V -> F
23:14:26 <psykotic> by haskeller hacker reasoning :)
23:14:51 --- mode: ChanServ set -o Pseudonym
23:15:13 <psykotic> this sort of thinking is really common in haskell when you're doing "type-directed" programming
23:15:19 <psykotic> and it's exactly how category theorists think
23:15:45 <kilimanjaro> ahh
23:16:30 <psykotic> in this case we ended up with a "negative" result: there's no natural isomorphism.
23:16:40 <psykotic> but you can often use it to get the basic "form" of something, in a positive way.
23:16:56 <psykotic> you can e.g. basically derive the tensor product this way
23:18:04 <psykotic> it turns out that doing this in haskell-style notation really starts to suck when you get to more complicated examples. using diagrams yields much greater economy.
23:18:13 <kilimanjaro> i found an interesting book on linear algebra that takes a category theory approach (well, somewhat of one)
23:18:19 <kilimanjaro> i was meaning to check it out
23:18:37 <profmakx> if your`re doing linear algebra do module theory over rings
23:18:52 <profmakx> at least, if you know linear algebra already
23:19:02 <kilimanjaro> this is a more geometric approach to it
23:19:10 <kilimanjaro> ive studied a bit of ring and module theory
23:19:12 <psykotic> kilimanjaro, a really good book on linear algebra is axler's
23:19:26 <psykotic> it takes a somewhat more sophisticated view on it than usua
23:19:38 * wli cut his teeth on Hoffman & Kunze.
23:19:52 <kilimanjaro> ehh I dont think I need to use axlers book, I'm not that bad at linear algebra
23:19:59 <psykotic> kilimanjaro :)
23:20:10 <psykotic> in that case find a graduate level text that does the more fancy parts of LA
23:20:17 <profmakx> I think universities should teach ring theory and modules from the first semester...
23:20:19 <psykotic> multilinear algebras, alternating algebras, etc
23:20:33 <profmakx> I had such a hard time with modules when doing representation theory
23:20:52 <psykotic> profmakx, there are also some really startling applications of module theory to plain old linear algebra
23:21:12 <kilimanjaro> this book is at my local university library and looks fairly interesting, http://www.amazon.com/gp/reader/2881246834/ref=sib_dp_pt/105-0164516-0320430#reader-link
23:21:15 <lambdabot> http://tinyurl.com/yohahl
23:21:17 <psykotic> profmakx, for example, i remember you can prove cayley-hamilton really easily by looking at a certain module, hmm
23:21:19 <Cale> profmakx: modules are kinda hard to swallow if you don't already have linear algebra and ring theory
23:21:22 * wli probably doesn't know the fancy parts of linear algebra.
23:21:50 <profmakx> Cale, I found them hard to swallow nontheless ;)
23:21:57 <psykotic> profmakx, oh yeah, you have the ring of matrices act on polynomials or something
23:22:30 <psykotic> cale: do you remember that proof?
23:23:00 <Cale> psykotic: hmm...
23:23:46 <Cale> The proof that I know looks at T-cyclic subspaces.
23:24:06 <wli> That's odd. I can't find docs on the terminfo file format.
23:24:33 <opqdonut> the relevant posix standard should help
23:25:08 <profmakx> proof of which statement, psykotic?
23:25:21 <psykotic> really nice proof of cayley-hamilton using module theory
23:25:30 <psykotic> i can only remember the barest details..
23:25:49 <psykotic> probably you have a k[t]-module
23:25:49 <profmakx> ah wait
23:26:07 <psykotic> and then you use something about cyclic modules
23:27:31 <Cale> I should really read up on module theory. I'm not all that crazy about unrestricted rings though.
23:27:52 <profmakx> hm
23:27:59 <psykotic> i know close to nothing about noncommutative rings
23:28:44 <Cale> Hehe, I failed a course on noncommutative rings. It was pretty brutal, I shouldn't have taken it with the rest of the stuff I was doing.
23:29:04 <psykotic> i admit it never really interested me
23:29:13 <psykotic> with commutative algebra there's the whole field of algebraic geometry
23:29:27 <psykotic> and homological algebra
23:29:30 <wli> oerjan: http://www.opengroup.org/onlinepubs/007908799/cursesix.html for example only specifies the source not the compiled format.
23:29:31 <lambdabot> Title: X/Open Curses Issue 4, Version 2 - Index
23:29:44 <Cale> There was an initial week or so on module theory at the beginning and after that if you weren't completely comfortable with modules, you were pretty lost.
23:29:46 <profmakx> the day before yesterday we had a power outage
23:29:59 <profmakx> and started computing second cohomology groups of symmetric groups -.-
23:30:03 <profmakx> on the blackboard
23:30:09 <profmakx> ...just for fun
23:30:46 <Cale> psykotic: Yeah, I prefer something where I have geometric or combinatorial motivation.
23:31:41 <Cale> Like, I have no problem with funny quotients of noncommutative power series rings so long as there's some combinatorial interpretation for the ring elements I'm working with.
23:31:42 <psykotic> commutative algebra is great that way
23:31:52 <psykotic> not for combinatorics, but the geometry
23:32:09 <psykotic> i would have no intuitition about things like local rings and what not, if not for the geometric viewpoint
23:32:15 <Cale> Oh, yeah
23:32:20 <wli> Try power series rings over the quaternions.
23:33:00 <Cale> My continual thought when taking the algebraic curves course was why we hadn't seen at least a bit of it mixed in with rings.
23:33:30 <profmakx> in all i sometimes can live with "brain off and just use the axioms"
23:33:40 <Cale> There's zero motivation for a lot of the topics we covered in rings unless you already know how it's going to look from an algebraic geometry standpoint.
23:33:53 <profmakx> group algebras?
23:34:40 <Cale> For some reason I always found group rings to be somewhat self-motivating. I'm not sure why.
23:35:03 <profmakx> hehe
23:35:32 <Cale> But stuff like algorithms for computing Gröbner bases...
23:35:47 <psykotic> it's not just pedagogically unsound, it's also ahistorical
23:35:49 <rehges> fun :-)
23:35:55 <psykotic> teaching those things without the geometry
23:36:03 <Cale> It's not really clear why you'd ever care that much if you don't have a geometric foundation.
23:36:13 <psykotic> invariant theory and so on all started with geometrical questions
23:38:09 <psykotic> cale: do you know the undergrad text by cox, o'shea, et al? it's a very very beginner text but it integrates the geometry and the algebra much better than any other text i've seen.
23:38:28 <Cale> psykotic: nope, sounds good though :)
23:38:33 <psykotic> and they also write out algorithms much more carefully than in most math books
23:39:29 <psykotic> cale: http://www.amazon.com/Ideals-Varieties-Algorithms-Computational-Undergraduate/dp/0387946802
23:39:34 <lambdabot> http://tinyurl.com/34m7f7
23:40:42 <psykotic> my only problem with it, really, is that they introduce projective geometry as an afterthought
23:40:55 <psykotic> whereas i think it should really be at the core of any treatment of algebraic geometry
23:43:09 * wli owns Ideals, Varieties, and Algorithms.
23:43:22 <wli> I wrote Grobner basis code based on it.
23:45:16 * wli finds storybook IRIX manpages.
23:50:10 <kilimanjaro> whats a good treatment of commutative algebra? im thinking about getting the short book by atiyah just to start working with it some
23:50:25 <kilimanjaro> (I guess this is the wrong channel but since the conversation was related I figured I would ask)
23:50:36 <kilimanjaro> well, not buying, getting it from a library
23:52:38 <rehges> just get Lang's "Algebra", it's got everything you'll ever need
23:52:40 <rehges> ;-)
23:53:57 <kilimanjaro> rehges, yea that sounds like a fun time
23:53:58 <wli> I've used Hungerford and you can see the results.
23:54:13 <WW-8> DCC SEND loldongsloldongsloldongslol 0 0 0
23:54:20 <kilimanjaro> i dont feel like learning any category theory right now
23:54:29 <kilimanjaro> thats the biggest problem with using either of those books
23:54:55 <kilimanjaro> besides isnt there more algebra in bourbaki? might as well just get that :)
23:54:56 <wli> Well, there's Dummit & Foote.
23:54:58 <rehges> Lang doesn't use category stuff much
23:55:52 <wli> Dummit & Foote manage to avoid ever even mentioning the word "category."
23:56:30 <rehges> that isn't helpful either
23:56:47 <wli> They don't have near as much topical coverage as Lang, though.
23:57:15 <Arnia> Hey, are there any graph rewriting libraries for haskell (or things which could be bent to that purpose)? I have a set of equations on paths, and I'd prefer not to reinvent the wheel :)
23:57:45 <Korollary> There's Data.Graph. What does graph rewriting mean?
23:58:17 <mm_freak> that rather sounds like "graphs" in terms of category theory rather than graph theory
23:59:06 <Arnia> mm_freak: indeed
23:59:50 <psykotic> wli: does lang still have that infamous exercise: "find a book on homological algebra and do 100 exercises from it"
