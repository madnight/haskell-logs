00:02:34 <glguy> If you make people think they're thinking, they'll love you; But if you really make them think, they'll hate you.
00:04:59 <dons> heh
00:07:11 <ddarius> glguy: What if you make them think -and- give them a puppy?
00:07:29 <glguy> I'm surely not giving them my puppy!
00:07:32 <glguy> :-D
00:07:38 <ddarius> I didn't say your puppy.
00:08:05 <glguy> I know, but my response was just as nonsensical as yours :)
00:09:36 <ddarius> I'd resent that if it were not true... okay no I wouldn't.
00:10:38 <blackdog_> my god, you guys are precise even when you're nonsensical
00:10:58 <Cale> http://www.toothpastefordinner.com/071407/spreadsheet-attack.gif
00:10:59 <wli> Well, I can lift a function like liftEither :: (Either d d' -> r) -> AtLeastOneOf d d' -> AtLeastOneOf r r
00:11:49 <dons> ?join #haskell-hac07
00:12:09 <wli> Or tie two functions together like liftCases :: (d -> r) -> (d' -> r') -> AtLeastOneOf d d' -> AtLeastOneOf r r'
00:13:09 <ddarius> wli: Clearly, (Either d d' -> r) ~ (d -> r, d' -> r) (this is the isomorphism defining Either.
00:13:18 <ddarius> )
00:14:13 <dons> huh, lambdabot's in about 40 channels now on freenode
00:14:18 <wli> Well, I'm trying to massage this into some form where arrows or some higher-level control construct understands it, so the rephrase is meaningful.
00:14:21 <ddarius> 40?!
00:14:31 <ddarius> I thought it was like 10-20.
00:14:33 <wli> (+++) and (|||) seem related.
00:14:45 <ddarius> :t (+++) 
00:14:46 <dons> yeah, lambdabot2 is in all the #haskell.lang chans and some others
00:14:47 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
00:14:48 <ddarius> :t (|||)
00:14:49 <dons> lambdabot is in 20.
00:14:50 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
00:14:53 <dons> ?seen lambdabot
00:14:53 <lambdabot> Yes, I'm here. I'm in #haskell_ru, #thunks, #happs, ##logic, #friendly-coders, #dreamlinux-es, #xmonad, #unicycling, #perl6, #parrot, #oasis, #jtiger, #haskell-soc, #haskell-overflow, #haskell-blah,
00:14:53 <lambdabot> #haskell, #ghc, #gentoo-uy, #gentoo-haskell, #darcs and #scannedinavian
00:15:09 <dons> 21. apparently.
00:15:11 <glguy> 21
00:15:20 <glguy> ##logic?
00:15:20 <dons> so lambdabot can't join any more channels
00:15:30 <glguy> #logic was blocked?
00:15:37 <ddarius> You are only allowed to join so many channels?
00:15:46 <dons> yeah, on freenode, 211.
00:16:07 <dons> so we run two bots now
00:16:18 <mm_freak> that's much…  on most other networks, you can join up to only 10 oder 15 channels
00:16:20 <ddarius> dons: Could we talk to someone to get an exception?
00:16:33 <dons> lisppaste also has the same limit, fwiw
00:17:00 <ddarius> Lord.  Now lambdabot is going to grow distributed features too.
00:17:10 <glguy> botnet :)
00:17:15 <mm_freak> (those abbreviations confuse me all the time…  what does `fwiw' mean?)
00:17:19 <glguy> 1 step away from eggdrop
00:17:24 <ddarius> for what it's worth
00:17:43 <ddarius> mm_freak: But I agree.  Down with netslang.
00:18:21 <mm_freak> ddarius: not necessarily, but there're far too many of 'em =)
00:18:28 <wli> Where Either sits is where AtLeastOneOf wants to sit.
00:18:59 <LeCamarade> IIRC, FWIK, AFAIK, FWIW, OTOH, OMG, THISISCRAZY ... this should stop. The revolution should begin in our hearts.
00:19:33 <ddarius> Yes, start using DWNS!
00:19:37 <LeCamarade> ROTLFMAO, LOL, .... wait.
00:19:49 <LeCamarade> @netslang fwiw
00:19:49 <lambdabot> Unknown command, try @list
00:19:52 <glguy> zomg
00:19:53 <LeCamarade> Idea. ^^
00:19:56 <wli> I guess one could write it Either (Either t t', (t, t')) save for mnemonic value.
00:20:01 <mm_freak> i'd reduce that to IIRC, AFAIK and OMG…  that's so common it's ok
00:20:15 <glguy> imho
00:20:25 <wli> YHBT
00:20:30 <LeCamarade> Someone write a netslang plugin.
00:20:32 <glguy> ymmv
00:20:33 <LeCamarade> Not me. Don't point at me.
00:20:35 <glguy> ianal
00:21:15 <ddarius> We could subvert @fact for this.
00:21:49 <LeCamarade> Yeah. @fact already does it, actually.
00:21:57 <LeCamarade> @dict
00:21:57 <lambdabot> Supported dictionary-lookup commands:
00:21:57 <lambdabot>   all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
00:21:57 <lambdabot> Use "dict-help [cmd...]" for more.
00:22:10 <LeCamarade> @dict imho
00:22:10 <lambdabot> Supported dictionary-lookup commands:
00:22:10 <lambdabot>   all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
00:22:10 <lambdabot> Use "dict-help [cmd...]" for more.
00:22:26 <LeCamarade> ?
00:22:26 <LeCamarade> ,,|,,
00:22:32 <ddarius> @vero imho
00:22:33 <lambdabot> *** "imho" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
00:22:33 <lambdabot> IMHO
00:22:33 <lambdabot>      In My Humble Opinion (telecommunication-slang, Usenet, IRC)
00:22:33 <lambdabot>  
00:22:43 <hpaste>  cdsmith pasted "Using randomRIO corrupts gtk2hs?" at http://hpaste.org/1727
00:22:53 <cdsmith> Can someone take a look at that please?
00:24:13 <wli> Oh, yeah, Monoid for nonempty lists is irritating.
00:24:45 <ddarius> @instances Monoid
00:24:47 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, Ordering, Product a, Sum a, [a]
00:25:05 <ddarius> Wli: Non-empty lists don't form a monoid.
00:25:23 <glguy> because a monoid needs an identity?
00:25:34 <wli> data NonEmptyList t = Singleton t | NonEmptyCons t (NonEmptyList t) deriving (Eq, Ord, Read, Show) ; instance Monoid (NonEmptyList t) where { Singleton x `mappend` xs = NonEmptyCons x xs ; NonEmptyCons x xs `mappend` ys = Singleton x `mappend` (xs `mappend` ys) ; mempty = error "mempty in Monoid instance undefined" }
00:25:47 <ddarius> glguy: Yup. 
00:25:51 <glguy> without an identity, isn't it just a semi-group?
00:25:54 <ddarius> wli: You want class SemiGroup
00:25:58 <wli> ddarius: Yes.
00:26:10 <glguy> and... iirc when you add an inverse you get a group
00:26:12 <glguy> is that right?
00:26:14 <wli> ddarius: Except it doesn't exist.
00:26:24 <ddarius> wli: Neither do NonEmptyLists
00:26:32 <ddarius> glguy: Monoid + inverse = group
00:26:52 <glguy> yeah, I remember Semi-group -> Monoid -> Group
00:26:57 <glguy> I just don't use that stuff enough to be sure about it
00:27:04 <wli> ddarius: There's a difference between lack of generality in std. libs and user-defined types.
00:27:07 <ddarius> The wikipedia page on magmas has a nice little diagram.
00:27:48 <ddarius> wli: I'm not sure that SemiGroups come up enough.  Monoids seem much more common.
00:28:12 <wli> ddarius: How often does the constraint of nonemptiness arise for lists? ;)
00:28:58 <ddarius> wli: Less often than arbitrary lists, and you need to think of more than one (compelling) example.
00:29:14 <dons> yi's keystrokes are a non-empty list
00:29:42 <dons> other kinds of IO can be modelled similarly
00:29:45 <wli> ddarius: I've written enough code to see nonemptiness constraints on lists arise often.
00:29:48 <glguy> a non-empty list? or an infinite list?
00:30:01 <ddarius> wli: I didn't say it didn't arise often.
00:30:12 <glguy> dons: ^^
00:30:23 <dons> oh, we had a non-empty finite list in xmonad 
00:30:30 <dons> there must be at least one layout algorithm defined
00:30:42 <dons> glguy: yeah, my mistake
00:30:58 <glguy> dons: you weren't technically wrong, I was just clarifying
00:31:08 <dons> so we use a GADT List Empty/NonEmpty to enforce that.
00:31:24 <ddarius> Yes, but not even non-empty lists are defined in the standard libraries, so you can't argue that SemiGroup should be from there. (Of course, you -could- argue non-empty lists -should- be in the standard libraries.)
00:31:43 <ddarius> glguy: A stream and a non-empty list is rather different.
00:32:06 <glguy> ddarius: I agree, but I was just saying that it wasn't absurd to call a stream "non-empty"
00:32:27 <glguy> maybe redundant...
00:32:53 <wli> Nonempty lists should probably be there, but there are more semigroup examples.
00:33:04 <ddarius> wli: Of course.
00:33:15 <glguy> Haskell98 doesn't seem sufficiently prepared to represent them, however
00:34:15 <glguy> I don't know off-hand if the standard library is all Haskell98 or not
00:34:18 <glguy> but a lot of it is
00:34:25 <wli> glguy: Well, semigroups are just splitting mempty and mappend in Monoid.
00:34:48 <glguy> I meant to represent non-empty lists effectively
00:35:16 <ddarius> glguy: It's just a data type, though I would be very partial to adding refinement types to Haskell.
00:35:44 <wli> glguy: data NEL t = NEL t [t], data NEL t = NELOne t | NELCons t (NEL t), etc.
00:35:59 <wli> ddarius: What's a refinement type?
00:36:48 <glguy> wli: I agree that they can be represented, just not cleanly
00:37:06 <wli> glguy: What do you have in mind for "cleanly?"
00:37:18 <glguy> not having to special case the last element
00:37:21 <glguy> or the first
00:37:21 <ddarius> @google "refinement types"
00:37:25 <lambdabot> http://portal.acm.org/citation.cfm?id=113468
00:37:26 <lambdabot> Title: Refinement types for ML
00:37:34 <ddarius> @google "refinement type"
00:37:36 <lambdabot> http://citeseer.ist.psu.edu/11736.html
00:37:36 <lambdabot> Title: Practical Refinement-Type Checking - Davies, Pfenning (ResearchIndex)
00:37:43 <ddarius> An overly thorough answer.
00:38:42 <ddarius> But essentially you can declare that some type is the same as another, but uses only some of the constructors (or a subset of the possible values).
00:39:09 <ddarius> One very handy example is having refined "normal form" types of a more general type.
00:39:23 <wli> I run into that all the time.
00:39:29 <ddarius> Currently you'd have to make two different types and convert between them.
00:39:45 <ddarius> Or ignore that bit of static checking.
00:39:57 <wli> I make a different type and convert.
00:41:34 <glguy> I suppose that I like : data NEL t = NEL t [t] 
00:41:48 <glguy> best, because it would be reasonable to recur on
00:42:06 <glguy> You can treat element access uniformly
00:43:33 <wli> It adds the relations bit to the generator and relations formulation of an algebra. That I like very much.
00:44:14 <wli> I first really saw it used in a language in Eiffel.
00:44:39 <glguy> writing it as a cursor wouldn't be so bad either (in certain circumstances) data NEL t = NEL { prevs, nexts :: [t], current :: t }
00:45:54 <wli> glguy: That won't play well with the derived Eq and Ord instances, but does sound useful.
00:46:44 <glguy> but it wouldn't necessarily change their complexity (still O(n))
00:46:52 <glguy> just higher on average
00:47:10 <glguy> (for those typeclasses' operations)
00:48:21 <ddarius> (With refinement types you'd simply have data [a] = [] | a : [a] and refinement NonEmptyList a = a : [] | a : NonEmptyList a
00:48:22 <ddarius> )
00:48:23 <wli> glguy: Rank-ordered trees are good for indexing and can do split/join in O(1) time given appropriate tree structures, so data NEL t = NEL { prevs, nexts :: RankOrderedTree t, current t }
00:50:26 <glguy> Finger trees wouldn't be unreasonable either as implemented in Data.Sequence
00:50:31 <ddarius> dons: We seem to be reasonably good about that.
00:50:35 <wli> glguy: Ergh, O(lg(n)) time, sorry.
00:50:59 <ddarius> A non empty list type should just be a non empty list.
00:51:17 <glguy> the merge and split run in O(log(min(n,m)) and O(log(min(i,n-i))) respectively
00:51:36 <glguy> but they have O(1) access to the outer most elements
00:51:41 <wli> glguy: Sounds like they'd implement efficient cursor movement.
00:51:52 <vincenz> dons++ -- thanks for the logs
00:54:40 <visof> http://www.rsa.com/rsalabs/node.asp?id=2093#RSA2048         can any one help me to understand what is this??
00:54:41 <lambdabot> Title: Home - RSA, The Security Division of EMC
00:55:03 <quicksilver> another view is to say that you don't need refinement types if you have 'Catch'
00:55:08 <quicksilver> that's probably an exagerration
00:55:12 <quicksilver> but it's certainly another path
00:55:54 <ddarius> quicksilver: I really doubt Catch can do most of the things refinement types are capable of.
00:56:25 <quicksilver> well, it can do the 'only uses some of the constructors' part
00:56:43 <glguy> visof: What don't you understand about it
00:56:48 <quicksilver> and it can do 'subset of the possible values' insofar as that is also a property involving only using some constructors
00:57:21 <visof> my english don t help me to understand  what is this?
00:57:27 <visof> can you explain me simply
00:57:29 <visof> ?
00:57:36 <glguy> You factor that number, you got lots of money
00:57:44 <ddarius> quicksilver: The thing is, I want an error if I use too much of the data structure too.
00:58:01 <quicksilver> ddarius: you will get that
00:58:07 <quicksilver> I think
00:58:08 * quicksilver thinks
00:58:29 <quicksilver> I think catch will warn you if you have a branch which isn't reachable
00:58:32 <visof> glguy     define "factor"?
00:58:36 <quicksilver> because you never pass in that (kind of) constructor
00:58:47 <ddarius> If I write a function that makes lambda terms that are supposed to be in normal form but are not, how does that translate to something Catch would catch?
00:58:48 <quicksilver> visof: a and b are factors of c if c = a * b
00:58:49 <visof> glguy give me example
00:59:03 <visof> oh
00:59:05 <glguy> visof: 15 factored is 3 and 5
00:59:05 <ddarius> Or more simply, is supposed to produce only non-empty lists.
00:59:29 <quicksilver> ddarius: it would warn if you then used that in another function which only works on non-empty lists
00:59:45 <ddarius> You conceivably could write a "check" function, apply that, and have it check, but that would be too much work.
01:00:10 <ddarius> I'm also far from certain you could do it in a way Catch would catch in all or most cases.
01:00:18 <glguy> visof: http://en.wikipedia.org/wiki/Fundamental_theorem_of_arithmetic
01:00:19 <lambdabot> Title: Fundamental theorem of arithmetic - Wikipedia, the free encyclopedia
01:00:30 <quicksilver> in most cases you care that it only produces non-empty lists precisely because you intend to use with another function which relies on non-empty lists
01:00:43 <visof> glguy      can you try to solve this problem?
01:00:58 <glguy> visof: did you have a question about Haskell?
01:01:12 <quicksilver> in extremis, you could manufacture an artificial such function, and that would be very like giving a definition of the refinement type ;)
01:01:22 <ddarius> quicksilver: I said that.
01:01:32 <visof> glguy     ok sorry
01:01:42 <quicksilver> ddarius: I know :)
01:01:48 <Cale> visof: It's probably not worth attacking that problem unless you have lots of equipment, or a new theorem about integer factorisation.
01:02:40 <Cale> Besides, I think that contest has been discontinued.
01:02:58 <visof>  cale what are the equipment that help me?
01:03:15 <glguy> Cale: I was thinking maybe +q and move on?
01:03:17 <Cale> visof: Like, a room full of computers.
01:03:27 <dons> visof, this isn't haskell related, but you're in the haskell channel. do you have any question about Haskell?
01:03:52 <visof> dons    sorry
01:04:25 <vincenz> dons: thx
01:04:28 <Cale> visof: There's no point in solving those problems because the contest ended.
01:04:33 <dons> vincenz: no problem.
01:04:47 <dons> vincenz, you got the logs all sorted?
01:04:50 <vincenz> dons: yep :)
01:04:56 <vincenz> karma was given priorly :)
01:05:03 <vincenz> 09:51 < vincenz> dons++ -- thanks for the logs
01:05:11 * glguy wonders what good sorted logs are
01:05:25 <ddarius> Those were a waste of computing resources anyways.
01:05:47 <dons> glguy: `sorted', you don't use that slang? :)
01:06:03 <glguy> we use "sorted out"
01:06:09 <ddarius> glguy: I like my logs to be sorted by time.
01:06:42 <glguy> ddarius: usually that's a consequence of the order that the mesages arrived :-p not due to "sorting"
01:06:45 <dons> as in, "ok, pasta's cooking. sorted. let's eat!"
01:07:01 <vincenz> dons: hmm, well I don't use it in that context either
01:07:02 <ddarius> Wow, I have never seen it used that way.
01:07:16 <vincenz> dons: you need to get your head sorted
01:07:22 <quicksilver> It's certainly a very common slang in south england
01:07:22 <ddarius> There's a roughly similar usage along the lines of "sorted out"
01:07:36 <quicksilver> round where I come from it's pronouned 'sarted', roughly
01:07:38 <vincenz> quicksilver: dons lives in the very far south england
01:07:48 <dons> hah very far south
01:07:50 <quicksilver> or sar`ed indeed
01:07:50 <glguy> lol
01:07:51 <vincenz> :P
01:07:51 <quicksilver> ;P
01:07:53 <glguy> way down under
01:08:11 <quicksilver> one of our offshore prison islands, no doubt!
01:08:13 * quicksilver ducks
01:08:15 * glguy wonders if it is confusing that the sun is upside down for dons
01:08:26 <vincenz> dons: does the toilet swirl the other way?
01:08:39 * dblhelix thinks dons should be used to it by now :-)
01:08:41 <dons> i suspect it was introduced to Sydney by english chefs. hmm
01:09:32 <dons> glguy: hmm. yes. upside down. and the moon. 
01:12:20 <dons> anyway, you guys are at the arse end, looks crowded down there, www.cse.usw.edu.au/~dons/tmp/mcarthur-large.jpg  :P
01:12:35 <vincenz> dons: wrong link
01:12:52 <vincenz> Firefox can't find the server at www.cse.usw.edu.au.
01:12:58 <dons> quote so, :)
01:12:59 <ddarius> dons: I think your server fell off the earth.
01:13:00 <glguy> missing an n
01:13:03 <vincenz> http://www.cse.unsw.edu.au/~dons/tmp/mcarthur-large.jpg
01:13:04 <dons> http://www.cse.unsw.edu.au/~dons/tmp/mcarthur-large.jpg
01:13:10 <vincenz> dons: I always thought that was the more correctw ay of lookinig at the world
01:13:13 <vincenz> dons: you have the base and a few peaks
01:13:36 <dons> all the continents point up.
01:13:46 <vincenz> yes
01:13:55 <vincenz> straight up to the local maxima of insanity
01:14:08 <ddarius> And the "massive" land masses sink to the bottom under their weight.
01:14:10 <vincenz> with the crown-jewel in the center
01:14:23 <dons> exactly.
01:14:24 <glguy> the pacific ocean?
01:14:42 <dons> papua new guinea
01:14:45 <vincenz> dons: I am talking about the crown-jewel of insanity
01:15:10 <dons> so now that's sorted, who's coming to the hackathon?
01:15:18 * dblhelix grins
01:15:20 <glguy> where
01:15:24 <vincenz> dons: wish I could ... but I'm in .gre :/
01:15:27 <ddarius> see I would say "now that that's sorted"
01:15:47 <ddarius> glguy: Freiburg
01:15:49 <vincenz> -e
01:16:13 <dons> glguy: http://www.haskell.org/haskellwiki/Hac_2007_II
01:16:14 <lambdabot> Title: Hac 2007 II - HaskellWiki
01:16:15 <ddarius> .gr isn't far at all.
01:16:18 <glguy> ddarius: that's about 12 miles too far f or me
01:17:08 <dblhelix> freiburg's where it all happens this fall
01:18:03 <glguy> seems like there has been a git storm on reddit today
01:19:03 <vincenz> ddarius: .gr is far
01:19:07 <vincenz> ddarius: in travelling distance
01:19:07 <dons> is git usable? isn't it a file system with some scary patch logic in C? that was prematurely optimised?
01:19:16 <quicksilver> "I attribute the lower success rate on the Rails list to its high volume of traffic and to the flood of technically unsophisticated coders who bringing inadequate backgrounds to the difficult class of model-view-controller projects."
01:19:21 * quicksilver tries not to smirk
01:19:29 <vincenz> dons: I thought so, isn't that why it doesn't work for windows?
01:19:46 <glguy> according to reddit, it was released for windows with mingw
01:19:50 <ddarius> vincenz: Farther than Australia or America?
01:19:58 <dons> quicksilver: hehe
01:20:21 <vincenz> ddarius: ...
01:20:29 <dons> quicksilver: if you've managed to read the whole thing, can you summarise any conclusions that apply to us, for the list? maybe with some recommendations, where relevant?
01:20:48 * quicksilver hasn't got to the conclusions bit yet
01:20:50 <ddarius> dons: I think the Haskell lists do fairly well.
01:20:57 * quicksilver has been too busy smirking at other people's misfortunes
01:20:58 <glguy> quicksilver: what are you reading?
01:21:02 <dons> yeah, -cafe@ is getting frustrating though
01:21:04 <quicksilver> http://praxagora.com/andyo/professional/mailing_list_follow_up/
01:21:05 <lambdabot> Title: How to Help Mailing Lists Help Readers (Results of Recent Data Analysis)
01:21:09 <quicksilver> glguy: dons posted it to the -cafe
01:21:14 <ddarius> dons: I'm pretty sure that that will pass.
01:21:15 <dons> and malcolmw is freaking out ;)
01:21:29 <ddarius> -That- probably won't pass.
01:21:35 <dons> ddarius: maybe its september forever now though.. 
01:21:55 * glguy got pretty tired of Andrew Coppin
01:22:08 <dons> nah, Andrew's fine now, we got hugh perkins to live with  :}
01:22:09 <glguy> and fixed the problem in his mail client
01:22:14 <glguy> oh?
01:22:27 * wli doesn't even read the lists anymore (though is probably still subscribed).
01:22:34 <dons> you don't read -cafe@ obviously, glguy 
01:22:41 <glguy> dons: not regularly enough
01:22:53 <ddarius> dons: LtU took a beating a while ago and mostly recovered though it seems to be in an odd patch right now.
01:23:11 <dons> ddarius: yeah, so they took steps to inform and train all those fleeing reddit ? ;)
01:23:22 <dons> i recall there being some real trolling
01:23:55 <quicksilver> I've seen so many mailing lists in such a terrible state I find it hard to view -cafe as anything less than marvellous
01:24:11 <quicksilver> I'm pretty good at coping with high-volume though
01:24:23 <dons> hmm, good to know.
01:24:29 <vincenz> dons: git has one plus-point: the whole branching thing, but that could be build as a layer on top of darcs
01:24:29 <hpaste>  lokik pasted "yet another embarassing type error" at http://hpaste.org/1728
01:24:33 <ddarius> In my experience, the people who tend to be problems tend not to stay.  Also, often "small" cases get perceived as being bigger than they are or requiring some kind of "response".
01:24:35 <dons> as long as we maintain the charm offensive
01:24:53 <glguy> vincenz: which branching thing?
01:24:53 <lokik_> hmmm
01:24:54 <dons> ddarius: yes, that's true. 
01:25:09 <vincenz> glguy: where when you pull it pulls it into a branch, ditto when pushing, same when you just branch
01:25:37 <glguy> vincenz: instead of using the working copy?
01:25:46 <vincenz> glguy: yes
01:25:48 <ddarius> lokik_: Why are you using return?
01:25:50 <dons> who needs special branch support when you've got first class repos
01:25:52 <vincenz> glguy: I saw some examples on that site that seemed ok
01:25:55 <quicksilver> "Spammers depend not on the wisdom of crowds, but on the gullibility of its least experienced members"
01:26:02 <lokik_> ddarius: what should I use?
01:26:08 <quicksilver> this guy has a good line in soundbites
01:26:11 <vincenz> dons: it's handy when pushing a branch to another place, you don't need to do "ssh, mkdir, darcs init"
01:26:22 <lokik_> ddarius: thanks :)
01:26:26 <ddarius> lokik_: Nothing.  Functions "automatically" return their values.
01:26:30 <glguy> vincenz: that's "darcs put" no?
01:26:34 <dons> vincenz: darcs put 
01:26:35 <lokik_> :D
01:26:54 <ddarius> lokik_: return doesn't mean in Haskell what it means in most languages.
01:27:24 <vincenz> sufffice to say, I found that part appealing
01:27:33 <vincenz> like I said, it can probably be built as a layer on to of darks
01:27:34 <vincenz> darcs
01:27:43 <Syzygy-> Hrm. I think I'm digging myself down into a monad bog right now... I would like to serialize large results and then un-serialize them.
01:28:02 <Syzygy-> So I have done a > writeFile "out.dat" . show . getResults $ parameter
01:28:16 <Syzygy-> Though getting back from there turns out to be trickier.
01:28:21 <Syzygy-> readFile gives me a string alright.
01:28:25 <vincenz> dons: switching to the newest regexp-base seems to not fix the problem I have with eval
01:28:30 <Syzygy-> Or ... IO String to be exact.
01:28:35 <vincenz> I still get the Data.ByteString.last on empty string problem
01:28:41 <quicksilver> Syzygy-: read `fmap` readFile
01:29:30 <Syzygy-> Ah.
01:29:42 <Syzygy-> Yeah ... I kinda managed that just after writing here. *blush*
01:29:52 <Syzygy-> Anything else I want to do needs to live in IO as well, right?
01:29:55 <quicksilver> Syzygy-: or, if you prefer, s <- readFile .... ; let val = read s
01:30:09 <quicksilver> Syzygy-: the fmap trick is merely a cute way of one-lining that
01:30:14 <Syzygy-> Yeah.
01:30:25 <Syzygy-> However, s <- readFile lets me go on using ghci neatly.
01:30:26 * ddarius prefers liftM read readFile
01:30:33 <ddarius> But I guess I'm funny like that.
01:30:44 <quicksilver> I like using liftM or fmap as infix
01:30:57 <quicksilver> because it matches the non-monadic 'shape' of the expression
01:31:06 <quicksilver> Bar $ function
01:31:06 <dons> vincenz: i think its the -posix lib that has to be also updated
01:31:10 <quicksilver> Bar `fmap` function
01:31:22 <quicksilver> ^^ first case, function is pure, second case function is in a monad
01:31:29 <Syzygy-> Hmmmm. I really should go and save down the serialization of some of the larger and more obnoxious calculations....
01:31:32 <dons> vincenz: and you'll also need to ensure you make clean before rebuilding
01:31:41 <Syzygy-> Is there a better way to serialize stuff than the show / read pair?
01:31:54 <ddarius> I view liftM as lifting functions (surprise!) and you can just kind of elide the liftMs getting read readFile.
01:32:00 <quicksilver> Syzygy-: for the purpose of interactive exploration, show/read is pretty good
01:32:10 <Syzygy-> quicksilver: Good, good.
01:32:15 <quicksilver> Syzygy-: for the purpose of speed and efficient storage, Data.Binary is much better
01:32:21 <quicksilver> Syzygy-: but that's going to look fugly on screen :)
01:32:39 <ddarius> So abstract away and call it a day.
01:34:02 <quicksilver> Syzygy-: as for "anything else needs to lve in IO as well"
01:34:08 <ddarius> I think I'm going to sleep another couple of hours.
01:34:10 <quicksilver> Syzygy-: the answer is "not as much as you'd think"
01:34:29 <quicksilver> Syzygy-: somehow your "outer shell" needs to live in IO, so it can do the reading and writing
01:34:42 <quicksilver> Syzygy-: but it's good style, and convenient, to write the rest of your program as pure functions
01:34:51 <Syzygy-> quicksilver: Sure.
01:35:36 <vincenz> dons: I do make clean
01:36:11 <dons> vincenz: what versions of the 3 regex libs are you using?
01:37:19 <dons> regex-posix-0.92? regex-base-0.91 ?
01:38:38 <vincenz> dons: how do I check?
01:38:46 <vincenz> base-0.91
01:38:47 <dons> ghc-pkg list
01:39:01 <dons> regex-posix-0.92 is the key thing though, that's wher ethe bug fix is.
01:39:07 <vincenz> @paste
01:39:07 <lambdabot> Haskell pastebin: http://hpaste.org/new
01:39:14 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/1729
01:39:17 <vincenz> that
01:39:33 * glguy doesn't understand why people keep responding to people like this "Hugh"
01:39:46 <dons> vincenz: ... see above. 
01:39:50 <vincenz> dons: will do
01:39:53 <dons> update regex-posix :)
01:40:13 <dons> glguy: i though, oh yeah, he wouldn't really be insane would he? then by late sunday i gave up and decided that yes, he was.
01:40:27 <quicksilver> Join the campaign for the removal of the @paste command! Free badges for ever campaigner!
01:40:27 <vincenz> glguy: Yeah, I just noticed him.  I have a gmail account that is purely for MLs but haven't read -cafe@ in a while... 
01:40:32 <dons> but, as a bonus, i improved the nsieve-bits program on the shootout by 30% :)
01:40:34 <vincenz> quicksilver: what?
01:40:49 <glguy> People like this just use the mailing as their friend for a few days until they need a new friend
01:40:55 <dons> yeah
01:41:13 <dons> it was frustrating when you'd prepare a good rebuttal, with code, and he'd ignore it entirely  :/
01:41:21 <vincenz> dons: hah, sounds like qwe1234
01:41:43 <dons> anyway, one outcome, http://shootout.alioth.debian.org/gp4/benchmark.php?test=nsievebits&lang=all
01:41:45 <lambdabot> Title: nsieve-bits benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Langu ..., http://tinyurl.com/sxpth
01:41:52 <glguy> Can we stop this rubbish before I unsubscribe? Seriously, get a clue
01:41:53 <glguy> before propagating nonsense across the mail clients of a large audience
01:41:58 <glguy> -- Tony Morris
01:42:00 <glguy> I like him
01:42:10 <quicksilver> vincenz: I'm just being grouchy
01:42:20 <dons> dibblego has a fan :)
01:42:21 <vincenz> quicksilver: sounds painful
01:42:31 <quicksilver> vincenz: @paste + lambdabot response + paste annouince is 3 lines when 1 line woudl be enough
01:42:35 * glguy notices that Jon Harrop managed to find a way to refer to his "case study" in this thread
01:42:37 <quicksilver> how hard is that url to remember ? :)
01:42:47 <dons> glguy: yes, that's not a good sign, is it? ;)
01:42:57 <quicksilver> strikes me as ironic, since the purpose of having a paste bot is to reduce the volume
01:42:58 <vincenz> dons: to install a package in ~/usr   I need to do "runghc Setup.hs configure --user" or something else as ewll?
01:43:04 <dons> yep that's it.
01:43:24 <dons> glguy: we must remember to use TH more often with these bogus benchmarks appear :)
01:43:27 <vincenz> quicksilver: it's not about remembering.  Iit's the fact that I get a free firefox when I click on that link in my terminal.  It's the difference between "click" and, "open firefox, go to address bar, type address, ..."
01:43:31 <dons> any time the value of N is static, use TH!
01:43:52 <vincenz> dons: it still tries to install elsewhere, maybe I need to add --prefix=/home/oasis/usr ?
01:43:54 <quicksilver> vincenz: I know
01:44:04 <dons> vincenz: you'll need prefix settings, too, yes
01:44:07 <quicksilver> vincenz: and that's exactly why people do it, and that annoys me :)
01:44:12 <dons> --help is your friend.
01:44:20 <quicksilver> vincenz: if you just type 'hp' in firefox it will autocomplete the URL for you
01:44:22 * glguy recommends quicksilver use a client with filtering ;)
01:44:24 <quicksilver> or you could make a bookmark
01:44:32 <vincenz> quicksilver: I still need to open firefox
01:44:59 <quicksilver> well, that's true. Most people I know have a web browser running all the time though.
01:45:07 <vincenz> quicksilver: in a separate desktop
01:45:09 <quicksilver> glguy: touche
01:45:21 <quicksilver> Don't get me wrong, this is *not* a big deal
01:45:24 <quicksilver> it's a trivial jibe
01:45:28 <vincenz> quicksilver: I know :)
01:45:33 <vincenz> quicksilver: hence why I'm arguing about it :)
01:45:40 <quicksilver> but is it right to penalise the entire channel, for the deficiencies of your computer setup?
01:45:49 <glguy> ditto ;)
01:45:56 <vincenz> dons: oy, -posix is making lambdabot not compile anymore
01:45:56 <quicksilver> you have the tools to start firefox at a given URL in a single keypress, I'm sure
01:46:02 <quicksilver> most window manageers etc can do that
01:46:09 * Syzygy- suggest a couple of choice /ignore rules to quicksilver 
01:46:11 <glguy> quit complaining about it and filter it out, and @paste is good to have for new members
01:46:37 <lokik_> do data types only hold static information?
01:46:37 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/1730
01:46:41 <quicksilver> I'm primarily complaining out of the self-serving desire to have my argument heard :)
01:46:43 <vincenz> dons: ^^^ 
01:46:45 <quicksilver> not because I actually care much.
01:46:53 * glguy goes off to delete the anonymous pastes
01:46:57 <vincenz> dons: seems trivial, but I just find it odd that suddenly the module-specs change due to a different version of regep-posix
01:47:05 <vincenz> dons: those are mine
01:47:07 <vincenz> erm
01:47:09 <vincenz> glguy: those are mine
01:47:19 <Syzygy-> quicksilver: One problem with that is that actually vocalizing an argument ends up being viewed as of surprisingly high weight.
01:47:33 <dons> vincenz: clean perhaps?sounds like you're munging your build nicely.
01:47:35 <Syzygy-> So by playing out an argument this way, you might end up affecting much more than expected.
01:47:38 <quicksilver> Syzygy-: I did explicitly say twice that I really didn't think it was that important ;)
01:47:50 <Syzygy-> quicksilver: Doesn't stop us!
01:47:57 <vincenz> dons: I always do a make clean, but I'll try again just to ensure
01:48:00 <Syzygy-> What? We need to read all of the text in channel now?
01:48:10 <lokik_> is it possible to set something that is in a data = { [String } sorta deal?
01:48:28 <Syzygy-> (look! look! I used the -c mode in the channel! In a way that's almost productive! Yay me!)
01:48:30 <quicksilver> lokik_: yes
01:48:40 <lokik_> how would I do that?
01:48:43 <glguy> Syzygy-: you did?
01:48:45 <quicksilver> lokik_: although in haskell you don't really "change" anything
01:48:50 <lokik_> asks is to get
01:48:54 <quicksilver> lokik_: you produce a new value based on the old
01:49:04 <lokik_> .ia belief
01:49:13 <Syzygy-> glguy: I emphasized a single word which made sense to emphasize in context, and I didn't use colours, only bold! hHah!
01:49:29 <quicksilver> lokik_: well if you had data Foo = Foo { a :: [String], b :: Int}
01:49:35 <quicksilver> and you have a variable x :: Foo
01:49:39 <quicksilver> and you wanted to change the a component
01:49:41 <glguy> Syzygy-: I figured that much, but didn't see any formatting on your previous messages
01:49:50 <vincenz> o.O ... hugh perkins answers a lot of times in a thread
01:49:51 <quicksilver> you'd do x { a = ["new","value"] }
01:49:52 <Syzygy-> glguy: You didn't? I bolded all.
01:50:05 <glguy> Syzygy-: ahh, i see it now
01:50:10 <quicksilver> dons: hmm well I finished the article. It's a bit short of what I'd called a 'conclusion'.
01:50:13 <glguy> Syzygy-: must be the angle I was looking at my LCD
01:50:23 <Syzygy-> glguy: Bolding too subtle for you? o.O
01:50:32 <glguy> Syzygy-: I adjusted my monitor :)
01:50:53 <lokik_> quicksilver: kk thanks i'll go try it out
01:50:55 <glguy> Syzygy-: now its all better ;)
01:51:18 * glguy takes a break from abusing the emoticons and heads to bed
01:51:28 <quicksilver> that's a great relief to us all :)
01:51:47 <quicksilver> although I fear I'll keep using ** and __ in ordinary text, it just feels easier :)
01:52:01 <quicksilver> but I could see a use for it in syntax/metasyntax
01:52:12 <vincenz> quicksilver: how do you do underline without __
01:52:15 <Syzygy-> I wonder whether the *bolding* measures interact well.
01:52:21 <vincenz> glguy: and how do you inverse?
01:52:31 <quicksilver> the problem is you're confusing the constructor Foo and the function Foo although they do have the same name
01:52:36 <quicksilver> for example
01:53:26 <quicksilver> or do { a <- readFile filename here ; let b = read a; rest of your code }
01:54:17 <quicksilver> dons: that article doesn't really have an exciting conclusion
01:54:18 <vincenz> The function Foo is not possible
01:54:39 <ski> ^B seems to toggle bold, here
01:54:42 <vincenz> Meta-syntactic variables are great to explain newe code to newbies.
01:54:49 <Syzygy-> vincenz: Don't spoil a perfectly decent exposition by facts.
01:54:58 <vincenz> Syzygy-: :)
01:55:05 <quicksilver> dons: it makes the sensible observation that one reason questioners can't use the documentation to answer their question, because they don't have the right mental model
01:55:13 <quicksilver> dons: but it doesn't tell me how you solve that
01:55:44 <quicksilver> Syzygy-: actually, there is a function Foo, if Foo is a constructor. You can't definie initial-cap functions yourself. But the constructor defines one implicitly.
01:56:17 <Syzygy-> quicksilver: So what is the difference between the function and the constructor? That one can be used in pattern matches and the other cannot?
01:56:37 <vincenz> It's the difference between potay-toe and potah-toe
01:56:39 <quicksilver> Syzygy-: yeah
01:56:43 <quicksilver> Syzygy-: it's a fine point
01:56:43 <ski> Foo is a function that is a constructor
01:56:49 <quicksilver> :t Just
01:56:51 <lambdabot> forall a. a -> Maybe a
01:57:01 <quicksilver> Syzygy-: Just clearly is a function; it has a type and you can pass it where a function is expected
01:57:02 <Syzygy-> You say potay-toe, I say "It's a bloody spud!"
01:57:12 <quicksilver> Syzygy-: but it's *also* a constructor because you can use it in a pattern
01:57:24 <quicksilver> which distinguishes it from most other functions :: a -> Maybe a
01:57:31 <vincenz> dons: make clean didn't fix
01:57:43 <Syzygy-> Wouldn't it be neat if you could pattern match on generic function application?
01:58:05 <Syzygy-> Or would that suddenly require insane amounts of intelligence on part of the compiler and result in insanely subtle bugs?
01:58:18 <quicksilver> it would require the function to be invertible
01:58:35 <Syzygy-> Well, yeah.
01:58:43 <Syzygy-> But that can't be -that- uncommon, can it?
01:58:44 <quicksilver> lambda calculus functions are not naturally invertible
01:58:56 <quicksilver> and there's no built-in way to 'tell' yhour langauge that one is
01:58:57 <Syzygy-> It'd be a neat extension to the n+k patterns!
01:59:10 <quicksilver> it's certainly interesting to think about
01:59:16 <quicksilver> is this what views are about?
01:59:27 <Syzygy-> class Invertible where inv :: (a -> b) -> (b -> a)
01:59:55 <vincenz> Syzygy-: that wouldn't work
02:00:07 <vincenz> Syzygy-: too many instances that inhabit any specific (a->b)
02:00:07 <quicksilver> I think this is what views are, at least
02:00:13 <Syzygy-> vincenz: Doh.
02:00:18 <hor> http://koweycode.blogspot.com/2007/07/monomorphism-and-unintentional-fib.html (comments) gives let r () = 25 to bypass monomorphism. What do the brackets mean?
02:00:20 <quicksilver> http://www.haskell.org/pipermail/haskell-prime/2007-January/002006.html
02:00:20 <lambdabot> Title: koweycode: monomorphism and the unintentional fib, http://tinyurl.com/352lah
02:00:21 <lambdabot> Title: [Haskell] Views in Haskell, http://tinyurl.com/22nh4a
02:00:36 <quicksilver> hor: they're an empty tuple
02:00:42 <quicksilver> hor: which is a kind of 'uninteresting' type
02:00:57 <ski> map f [                      ] = [    ]
02:00:58 <ski> map f ((y ! f) : (ys ! map f)) = y : ys
02:01:02 <ski> would be interesting
02:01:13 <quicksilver> hor: functions aren't subject to the monomorphism restriction
02:01:28 <quicksilver> hor: so he makes r into a stupid function which ignores its (stupid) argument
02:01:40 <quicksilver> hor: that's not the recommended way to get around it though
02:01:46 <quicksilver> hor: much better just to give it a type signature
02:01:51 <hor> Ta
02:02:07 <quicksilver> :t let r () = 25 in r
02:02:09 <lambdabot> forall t. (Num t) => () -> t
02:02:37 <vincenz> dons: where is regex' defined?
02:03:47 * vincenz found it
02:03:52 <vincenz> I think there's issues with cpphs
02:04:58 <malcolmw> is that a bug report?
02:07:59 <vincenz> malcolmw: Not particularly
02:08:15 <vincenz> malcolmw: but it's having issues detecting I'm using 6.6.1 in the clauses that say "if  GHC > 606"
02:09:07 <malcolmw> vincenz: ghc does not distinguish between minor revisions.  ghc-6.6 and -6.6.1 will both define __GLASGOW_HASKELL__=606
02:09:32 <vincenz> malcolmw: Ok, thanks
02:10:09 <malcolmw> in theory, there should be no API changes between minor revisions
02:10:19 <vincenz> Maybe it keeps detecting it's still 6.4
02:11:18 <Syzygy-> Gotta love the arXiv: (Co)cyclic (co)homology of bialgebroids: An approach via (co)monads
02:12:03 <wli> Syzygy-: I found a reference to a 1977 paper on monads and parsing of DCFL's.
02:12:42 <ski> DCFL ?
02:12:42 <lokik_>     Couldn't match `ReaderT ANK IO t' against `ANK'
02:12:42 <lokik_>       Expected type: ReaderT ANK IO t
02:12:42 <lokik_>       Inferred type: ANK
02:12:42 <lokik_>     In a 'do' expression: ANK {djuno = x' : sedjuno}
02:12:49 <lokik_> :(
02:12:53 <wli> ski: Deterministic Context Free Language
02:13:20 <ski> lokik_ : mayhaps you want a 'return' ?
02:13:37 <lokik_> maybe
02:13:43 <quicksilver> lokik_: that doesn't look right at all
02:13:46 <ski> (hard to tell without more context .. hinthint)
02:13:47 <quicksilver> lokik_: youre' in a 'ReaderT'
02:13:53 <quicksilver> and yet you're tryign to 'change' the ANK?
02:14:02 <quicksilver> ReaderT is readonly in its environment
02:14:08 <quicksilver> that's its raison-d'etre
02:14:19 <quicksilver> although there is "local" to change the env for a sub-actions
02:14:24 <ski> @type local
02:14:27 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
02:14:30 <lokik_> hmm well now it's giving me different error
02:14:34 <vincenz> quicksilver: errm, not quite right
02:14:42 <ski> !hpaste
02:14:50 <quicksilver> vincenz: which part isn't quite right?
02:14:50 <ski> @hpaste
02:14:51 <lambdabot> Haskell pastebin: http://hpaste.org/new
02:16:24 <quicksilver> vincenz: ?
02:18:15 <wli> Hmm. N queens. Probably more interesting is analyzing a completed game to determine how far back its conclusion was forced.
02:19:53 <dons> lovely, "my thanks to the Data.ByteString.Lazy, Data.Binary,
02:19:53 <dons> and Data.Edison people, who made this rather easy, once I grokked
02:19:53 <dons> unsafeInterleaveIO.
02:19:53 <dons> "
02:20:12 <vincenz> quicksilver: he's not updating, he's simply forgetting "return"
02:20:15 <vincenz> quicksilver: look at the types
02:20:23 <wli> That's got real optimal substructure to it.
02:22:26 <vincenz> dons: I reverted all changes I had made to the code, I have the newest regexp-base and regexp-posix
02:23:54 <hpaste>  vincenz pasted "compile errors" at http://hpaste.org/1731
02:23:55 <lokik_> what does ReaderT do?
02:24:11 <lokik_> oh
02:24:12 <lokik_> wau
02:24:13 <quicksilver> vincenz: I'm disagree
02:24:15 <lokik_> hmmm
02:24:24 <quicksilver> vincenz: 'expected type' was ReaderT ANK IO t
02:24:30 <quicksilver> vincenz: there was no evidence to suggest he wanted to return
02:24:44 <quicksilver> vincenz: I was only guessing, but I thought he was trying to change the ANK
02:24:52 <quicksilver> vincenz: of course, I could be wrong. That's the nature of guesswork :)
02:25:21 <quicksilver> lokik_: if you're tryign to 'change' the ANK that's being passed around, as I suspect, then there are two choices
02:25:32 <quicksilver> lokik_: you could either use local, if it's good enough to change it for a sub-action
02:25:38 <vincenz> quicksilver: and you can 'change' that's what "local" is for
02:25:38 <quicksilver> or you change for ReaderT to StateT
02:25:42 <quicksilver> which is designed
02:25:46 <quicksilver> vincenz: yeah, I did say that :)
02:25:48 <vincenz> oh right, you just said that
02:25:50 <vincenz> ;)
02:26:09 <quicksilver> lokik_: or, you explain a bit more about what you're trying to do and I'll make a better guess :)
02:26:16 <vincenz> dons: regexp-compat was the culprit
02:26:27 <vincenz> dons: and you have a small bug in Lib.Parser
02:29:32 <dons> oh, and regexp-compat? i didn't think we used that?
02:29:45 <dons> ah yes, regex-compat>=0.91, regex-posix>=0.92
02:29:50 <vincenz> dons: the bug in Lib.Parser.hs
02:29:58 <vincenz> dons: GLASGOW_HASKELL > 606
02:29:59 <dons> like i say, you need to update all regex-* libs
02:30:00 <vincenz> instead of >=
02:30:08 <vincenz> it should be >=
02:30:26 <dons> in the generated Parser.hs ??
02:30:30 <vincenz> nod
02:30:33 <vincenz> so in the Parser.y
02:30:54 <vincenz> dons: ok... that fixed that bug
02:31:00 <dons> send a patch then.
02:31:04 <vincenz> but now I get this
02:31:04 <vincenz> 11:30 <@vincenz> > 1
02:31:05 <vincenz> 11:30 < oasisbot>  fd:8: hClose: resource vanished (Broken pipe)
02:31:08 <dons> that code is jsut from haskell-src, iirc
02:31:15 <dons> that means your runplugs isn't built probably?
02:31:35 <vincenz> everything is :/
02:31:37 <dons> the following has to work:
02:31:37 <dons> $ cd lambdabot 
02:31:37 <dons> $ echo 1 | ./runplugs
02:31:38 <dons> 1
02:32:18 <vincenz> oh
02:32:20 <vincenz> ShowFun
02:32:27 <vincenz> I'll remove that just as I did with ShowQ
02:32:39 <dons> well, you could also build them. you're using ./build ?
02:32:42 <mux> I had similar problems until I used the 'build' shell script provided with LB sources
02:32:56 <dons> which you're supposed to use :) see the readme. why doesn't anyone look at it?
02:33:08 <dons> Build with cabal (simple)
02:33:08 <dons>     $ vi Config.hs
02:33:08 <dons>     $ ./build
02:33:08 <dons>     $ ./lambdabot { -e command }
02:33:11 <vincenz> dons: I do use build
02:33:15 <vincenz> dons: showQ and showfun are buggy
02:33:21 <mux> because we have so much faith in Cabal that we think everything just builds this way :-)
02:33:26 <dons> vincenz: use the ./build script
02:33:29 <vincenz> dons: again
02:33:32 <vincenz> dons: I use ./build
02:33:32 <dons> set it executable, then ./build to run it
02:33:34 <mux> it would be nice if the 'build' shell script could be reimplemented with Cabal hooks
02:33:43 <vincenz> dons: I even customized it to do --user so it gets the packages that are locally installed
02:34:06 <dons> hmm. you haven't gone an installed the binaries into --user directories, have you?
02:34:18 <vincenz> dons: I have
02:34:39 <vincenz> ~/usr/bin
02:34:46 <dons> that's not promising.
02:34:46 <vincenz> and then moved State to ~/
02:34:50 <dons> lambdabot won't work that way
02:34:50 <vincenz> and run lambdabot from ~/
02:34:52 <dons> you're on your own.
02:35:03 <vincenz> dons: having a bot that runs from it's compilation dir is ..
02:35:22 <vincenz> less than perfect
02:35:30 <dons> it will only run binaries in ./lambdabot though. as per the script, so if you mess with that, expect things to break.
02:35:36 <mux> I tend to agree, but since it's all you've got for now
02:35:43 <vincenz> dons: no it works fine
02:35:44 <mux> ...or fix it yourself :)
02:35:50 <vincenz> dons: just have to make sure that where you launch it from it has State-dir
02:35:50 <dons> e.g. ShowQ.hs won't be in ~/ for example.
02:36:29 <dons> anyway, its not buggy, you're doing it wrong :)
02:36:45 <vincenz> dons: I'm inistalling it properly
02:36:52 <vincenz> :)
02:37:05 <vincenz> but now that I know I need the raw .hs ile, that might help
02:37:07 <dons> not lambdabot. its special. like firefox or windows.
02:37:11 <vincenz> maybe I can get this to work properly
02:37:18 <dons> see, when you mess with the build systems, you break invariants
02:37:26 <dons> which means you're not allowed to complain to the maintainer about bugs
02:37:27 <vincenz> dons: maybe the invariants are poorly formulated..
02:38:00 <dons> shrug. lambdabot is special. why not just try to build it normally?
02:38:14 <vincenz> cause I want it in ~/urs
02:38:16 <vincenz> usr
02:38:18 <Vq^> does anyone have any pointers/ideas for parsing a language where blocks are separated by indentation (like python)?
02:38:18 <vincenz> like any sane cabal package
02:40:08 <dons> shrug. you get what you pay , or write code for. 
02:40:17 <ibid> Vq^: you could do what haskell does
02:40:37 <dons> $ darcs changes --xml | grep author | grep vincenz | wc -l
02:40:38 <ibid> Vq^: ie. lexer (or a phase between lexer and parser) inserts block tokens based on indentation
02:40:38 <dons>        0 
02:41:01 <vincenz> doesn't matter
02:41:30 <vincenz> Almost got it working
02:41:34 <Vq^> ibid: sounds like a good idea, that would easily allow both styles in the target language as well
02:48:31 <quicksilver> Vq^: I do it as a two-stage parse
02:48:43 <quicksilver> Vq^: first stage is line-by-line, and understand indentation
02:48:54 <quicksilver> Vq^: essentially, that's what ibid is saying, actually :)
02:51:03 <ibid> Vq^: yes, and you can also make the block tokens be "imaginary", that is, nor '{' etc, if you want to avoid that possibility :)
02:51:10 <ibid> Vq^: allows both ways, iow
02:51:47 <vincenz> dons: resetting build to be like the original, I get the following error now: runplugs: Ix{Int}.index: Index (1024) out of range ((0,27))
02:52:14 <|Jedai|> Is there a way to unbox elements in a list ?
02:52:33 <dons> vincenz: probably hs-plugins built against the wrong version of ghc
02:52:39 <Vq^> ibid&quicksilver: thanks, that was the advice i was looking for :)
02:53:11 <ibid> gthboa :)
02:53:11 <dons> hs-plugins needs to be built with the ghc you're using to build lambdabot. so if you installed plugins ages ago, it'll try to use the old ghc, leading to .hi file errors
02:53:28 <vincenz> dons: it's a new one in --user
02:53:33 <vincenz> plugins-1.0
02:53:50 <jedai> Writing it's own UList with strict constructors ? Don't we lose some others optimisations on the side ?
02:55:54 <quicksilver> jedai: you still have the overhead of the links, though
02:56:03 <quicksilver> jedai: normally people who want to unbox go for arrays
02:56:09 <quicksilver> jedai: I'm not sure if UList is an interesting middle ground, or not
02:56:29 <jedai> quicksilver: Yeah, that's fine for me.
02:56:32 <ski> UList ?
02:56:49 <quicksilver> ski: jedai was speculating about a list type with strict constructors
02:56:57 <quicksilver> ski: to try to get the compiler to unbox it
02:58:35 <jedai> quicksilver: For Word8 elements for exemple, I wondered if the compiler would manage to pack them a little tighter or if alignment would just lost the size advantage against a [Int]
02:59:15 <quicksilver> I doubt it will misalign them
02:59:34 <quicksilver> misalignment is a massive speed penalty on the common CPU architectures
02:59:47 <quicksilver> so most compilers go to great lengths to keep fields aligned even if that wastes space
02:59:55 <quicksilver> I'm only guessing though :)
03:00:56 <ski> how would polymorphic functions over 'UList' work ??
03:01:00 <jedai> quicksilver: Ok, you're probably right... Still an unboxed [Int] would spare 4 bytes by element, wouldn't it ?
03:01:02 <ski> s/??/?/
03:01:56 <jedai> ski: Why ? Exactly like polymorphic functions over anything else, why not ?
03:01:59 <ski> hm .. maybe one could have '[] :: # -> *' but still 'reverse :: forall a :: *. [a] -> [a]'
03:02:30 <ski> jedai : what if the unboxed datum takes more place than a typical thunk pointer ?
03:03:06 <jedai> ski : We don't specify unboxing in the language
03:03:41 <jedai> ski: We just specify strictness, and the compiler unbox for correct types (Int for example)
03:04:13 <jedai> ski: typechecking wise, it doesn't change anything
03:04:34 <ski> @kind GHC.Base.Double#
03:04:36 <lambdabot> #
03:05:09 <ski> (but, yes, if you only unbox small-enough datums, it will work)
03:05:25 <jedai> ski: The "problem" is that List aren't strict by default (which is probably a good thing in most case) but that waste space enormously in my specific case
03:05:25 <SimonRC> hmm...
03:05:45 <SimonRC> "Hot swapping is only practical if
03:05:45 <SimonRC> the application already has disciplined use of global state—as is the
03:05:46 <SimonRC> case by default in Haskell programs."
03:05:49 <SimonRC> cool
03:06:00 * SimonRC is readin about Yi
03:06:24 <jedai> ski: _I_ don't unbox anything, it's all a compiler-side optimisation (that it can't do with non-strict field in a constructor)
03:07:05 <quicksilver> jedai: well you can solve your particular problem with seq, I imagine
03:07:52 <ski> jedai : yes :) by 'you' i meant the compiler implementer
03:08:24 <jedai> quicksilver: Really ? My problem is space, not time, will GHC unbox anything if I use seq ? That would be pretty cool I guess
03:09:01 <quicksilver> no, it won't unbox
03:09:08 <quicksilver> but it will stop your space leak
03:09:22 <quicksilver> unless I misunderstood you
03:09:45 <jedai> quicksilver: Ok, I'll try that, thanks
03:10:01 <SimonRC> If a type is defined inside a dynamicly-loaded module, what happens when that module is unloaded while values of the type still exist?
03:10:35 <SimonRC> and can those values be used by the "new" module if you re-load it?
03:10:44 <quicksilver> I didn't know you could unload modules in haskell's dynload stuff
03:11:06 <quicksilver> SimonRC: don't forget, though, that types don't exist at runtime
03:11:12 <quicksilver> SimonRC: all you have a is a little bundle of bits
03:11:51 <SimonRC> quicksilver: In that case, attempting that operation shouldn't type-check, right?
03:12:04 <SimonRC> quicksilver: I *htink* you can
03:12:46 <SimonRC> according to the Yi paper, sec 3.2.2, there is an "unloadPackage"
03:13:09 <quicksilver> SimonRC: sorry, attempting which operation?
03:14:10 <SimonRC> I mean, the type of the new entry-point should fail to match any type defineable by the old module
03:14:25 <SimonRC> ah, waitamo, there is a section that explains all this... Section 3.3
03:14:51 <quicksilver> SimonRC: it sounds like you're thinking in terms of types existing at runtime, still
03:15:07 <quicksilver> SimonRC: at runtime types don't need to exist because we checked them all at compile time...
03:16:30 <SimonRC> (The answer is that the application crashes, apparently.)
03:16:43 <SimonRC> Except, that with dynamic linking, you can't check all the types at compile-time.
03:16:52 <quicksilver> well you sort of can
03:16:58 <quicksilver> each module was type checked when it was compiled
03:17:32 <quicksilver> then presumably the linker does some kind of load-time overall check on the types of symbols it loads
03:17:53 <quicksilver> does Yi use its own loading mechanism, or the same as hs-plugins/ghci?
03:18:15 <quicksilver> (which Yi paper are you reading? icanhaslink?)
03:19:10 <SimonRC> http://www.cse.unsw.edu.au/~dons/papers/yi.pdf
03:19:56 <SimonRC> In that case, the types must exist in some sense at run-time for the linker to check them.
03:20:08 <quicksilver> not attached to values, though
03:20:12 <SimonRC> true
03:20:15 <quicksilver> attached to symbols
03:20:19 <quicksilver> not quite the same thing :)
03:20:21 <SimonRC> yes
03:20:28 <quicksilver> typical programs have orders of magnitude more values than symbols
03:20:40 <quicksilver> C++ just embeds the type info in the symbol name, in a well known if rather ugly hack
03:21:42 <eivuokko> Typically C++ has runtime type information in many forms in final executable.
03:22:24 <quicksilver> yeah, sorry, I didn't mean 'just' to imply that was the only thing C++ did
03:22:48 <quicksilver> however fundamentally C++, like haskell, is a type-erasure system
03:23:01 <quicksilver> although both have ways of instructing the compiler to generate type stub information here and there
03:23:12 <eivuokko> Anyway, ghc embeds a bit type information to values via infotables.
03:23:28 <hpaste>  v0|d pasted "can't compile haxml 1.13.2 with ghc 6.6.1" at http://hpaste.org/1732
03:23:40 <eivuokko> And ghc-api and hs-plugins afaict both use Dynamic to talk between loader and loaded code.
03:23:42 <quicksilver> eivuokko: infotables? what's that?
03:23:48 <v0|d> any idea about my compilation problem?
03:24:06 <SimonRC> like vtables?
03:24:09 <eivuokko> quicksilver, Most importably infotable contains binary layout for gc.
03:24:16 <malcolmw> v0|d: don't use the Makefile - use runhaskell Setup.hs instead
03:25:02 <eivuokko> quicksilver, Afaiu they cannot be currently gc'd, so unloading code isn't really safe unless variable bindins are reset.
03:25:48 <v0|d> malcolmw: ok, let me try.
03:36:36 <nominolo> hm does darcs have lightweight branches?
03:37:17 <quicksilver> it has something called 'partial' branches
03:37:22 <quicksilver> I'm not sure how lightweight they are
03:37:51 <nominolo> atm, i do cd ..; mkdir experimental-branch; darcs pull ../orig-version
03:37:59 <nominolo> there must be something better
03:39:05 <quicksilver> there is, it's called bzr
03:39:06 * quicksilver ducks
03:39:15 <nominolo> i prefer git
03:39:34 <nominolo> but both are not very "haskelly"
03:40:10 <nominolo> i'm really hoping that some of the many SCMs die out soon 
03:40:49 <nominolo> but i don't think this will happen soon
03:42:45 * Grizzy snores and occasionally reads the tutoriial, waiting for ghc to configure in Cygwin.
03:43:16 <quicksilver> nominolo: it's good that they don't; the design space is large and it needs exploring
03:43:42 <nominolo> yeah, i guess
03:44:27 <malcolmw> nominolo: if the two darcs branches are on the same filesystem, they will share the physical files (hard links)
03:44:54 <nominolo> malcolmw: if i use pull?
03:45:04 <malcolmw> nominolo: but I guess you might want a 'darcs get' rather than a 'darcs pull' to initialise
03:45:11 <dozer> No instance for (XmlPickler Char) arising from use of `xpickle' at apps/PrintRule.hs:13:24-30
03:45:23 <dozer> is there a way to get ghc to print out usefull info about this kind of error?
03:45:35 <dozer> what it's giving me now is rather spartan, and not much help
03:45:41 <nominolo> malcolmw: yes. i'll try that next time
03:46:25 <nominolo> dozer: you are calling xpickle on a "Char"
03:46:49 <dozer> nominolo: That's what it says, yes - but the thing I'm feeding it is a complex data structure
03:46:51 <nominolo> there's not much more to say
03:46:57 <nominolo> oh
03:47:16 <malcolmw> dozer: probably your complex data structure contains Chars then
03:47:45 <dozer> nominolo: that's what I'm figuring - but the output isn't giving me a path through the data structure to let me know where that char is
03:48:12 <nominolo> dozer: yeah, that would be nicer
03:48:15 <malcolmw> dozer: Char must be a parameter to the data structure
03:49:26 <dozer> malcolmw: the data structure has chars all over it, as [Char] - I'm guessing one of these isn't being serialzied via xpString
03:50:00 <malcolmw> dozer: so in data T a = ComplexStuff a....   you have instance (XmlPickler a)=> XmlPickler (T a), and probably then a particular value of type T Char
03:51:26 <dozer> malcolmw: yes, that's very very likely - although in some parameterisations it's String and in others its URI, so I guess xpickle is geting used for both somewhere by mistake
03:52:12 <malcolmw> dozer: so maybe you just need to define an instance XmlPickler Char, and be done with it
03:53:21 <dozer> malcolmw: perhaps - I should realy be piping String through xpString, and non-string instantiations through xpickle - I will see what I can hack up
03:57:46 <hpaste>  Grizzy pasted "ghc 6.6.1 fails under Cygwin" at http://hpaste.org/1733
03:58:53 <hpaste>  Grizzy pasted "ghc 6.6.1 fails under Cygwin" at http://hpaste.org/1734
03:59:28 <hpaste>  Grizzy pasted "ghc 6.6.1 fails under Cygwin" at http://hpaste.org/1735
03:59:35 <Syzygy-> ...
03:59:40 <Syzygy-> Grizzy: Once is enough, surely?
04:00:42 <eivuokko> Grizzy, You aren't trying to build cygwin-enabled ghc, are you?
04:00:53 <Grizzy> Sorry, it kept truncating the end.
04:02:17 <Grizzy> It would have been better if it told me how many lines were the limit, or if iit front-truncated the file.
04:04:52 <Grizzy> eivuokko - yes.
04:05:09 <eivuokko> It's not supported.
04:05:33 <eivuokko> Building ghc under Windows is a bit tricky, you might want to check out http://hackage.haskell.org/trac/ghc/wiki/Building
04:06:57 <Grizzy> Could that be announced, on the document that pretends to be Cygwin build instructions, here:  http://www.haskell.org/ghc/docs/5.04.1/html/building/winbuild.html
04:06:59 <lambdabot> http://tinyurl.com/2qet6d
04:07:23 <eivuokko> Tarballs probably have most settings (in regards mk/build.mk etc) done right, but configure probably needs similar settigs as described on a subpage.
04:07:26 <mauke> version 5.04?!
04:07:43 <eivuokko> Heh
04:08:38 <eivuokko> Grizzy, I am not sure where it should be announced, I think ghc webpages said they were looking for cygwin maintainer for a long time.
04:10:00 <eivuokko> If you have mingw installed, you might get away with just ./configure --with-gcc=c:/mingw/bin/gcc.exe --with-ld=c:/mingw/bin/ld.exe or something like that.  Ld might not be needed for 6.6
04:10:24 <eivuokko> (ofc with the right paths to mingw, and paths in nativeish format :) )
04:15:50 <Grizzy> In installing Cygwin, I specified gcc-mingw; I can see the mingw libraries, but is there supposed to be any other command than  "gcc" ?
04:16:28 <opqdonut> cpp probably
04:18:12 <Grizzy> both announce this as their version:  gcc (GCC) 3.4.4 (cygming special, gdc 0.12, using dmd 0.125)
04:18:42 <Grizzy> "cygming" presumably meaning the mingw version?
04:20:36 <Grizzy> I suppose I need to take a .exe to an uncontaminated-by-cygwin system and see if it runs.
04:24:22 <therp> is there a way to create hard links with haskell?
04:25:46 <quicksilver> there must be because darcs does it :P
04:26:12 <malcolmw> system("ln src tgt")
04:26:15 <quicksilver> http://haskell.org/ghc/docs/latest/html/libraries/unix/System-Posix-Files.html#8
04:26:17 <lambdabot> http://tinyurl.com/2c4o79
04:28:37 * wli looks at monadic interpreter papers again
04:57:08 <fxr> hi, where can I find the dependency pretty-any for latest cabal?
04:58:09 <therp> isn't pretty part of the core libraries of GHC? http://darcs.haskell.org/packages/pretty/
04:58:11 <lambdabot> Title: Index of /packages/pretty
05:01:51 <fxr> therp: thanks
05:27:14 * mux gets massively hilighted by the recent haskell-cafe@ post defining a Mux type class
05:27:30 <mux> actually, not a type class
05:27:42 <vincenz> Anyone know how to track down where an exception is coming from
05:28:17 <wli> That's why exceptions are evil.
05:28:24 <quicksilver> mux: yay :)
05:35:29 <wli> /usr/bin/ld: cannot find -lHSreadline_dyn
05:35:31 <wli> Um...
06:05:57 <ivanm> is it just me, or is lambdabot dead?
06:06:54 <Saizan> @bot
06:07:21 <vincenz> @bot
06:07:50 * mux reads a post on haskell-cafe@ with 5-6 layers of case ... of; Nothing -> ...; Just ... -> ... and thinks the guy needs the Maybe monad love
06:09:18 * dolio avoids case at every opportunity.
06:10:30 <vincenz> dolio: upper or lower?
06:10:56 <dolio> @yow
06:11:46 <quicksilver> mux: if it's the post I was thinking of, Claus answered him very well
06:11:54 <quicksilver> with a step-by-step refactoring guide
06:12:14 <Saizan> and it melted to 2 lines of code?
06:13:23 <quicksilver> no, it was a pretty complex piece of code in the first place
06:13:33 <quicksilver> Claus couldn't make the complexity vanish
06:13:40 <quicksilver> but he did solve the indentation problem
06:13:49 <mux> quicksilver: *nods* I have just read Claus' mail
06:13:50 <wli> I get big nasty case statements all the time, but usually over algebraic data types with a number of constructors and some transformation required.
06:20:06 <mux> quicksilver: I think I would have used a newtype for the monad he's using though, so as to simplify the function types
06:22:43 <quicksilver> mux: there's always the question of if it's worth that for a one-off
06:22:56 <quicksilver> mux: in the case of a large program using this monad more than once, definitely
06:23:46 <mux> right
06:26:43 <roconnor> mux: what about a type synonym?
06:29:30 <mux> roconnor: I guess it depends on the context of use of the monad; if he wants to define his own primitives and doesn't want people to use anything else, a "newtype" is required, if not, a "type" is probably sufficient
06:38:32 <roconnor> > cos 10
06:39:00 <wli> What seems to be missing in these type inference algorithms is keeping results around. Type information for inner scopes is needed later, but forgotten as soon as the inner scope is checked or inferenced.
06:41:06 <wli> That appears to make the monadic plumbing somewhat more complex.
06:41:50 <Philippa> I'm not sure I get what you mean
06:42:22 <roconnor> have you see Conor's type checking algorithm?
06:43:03 <wli> Philippa: It seems as if you want the environments that are transient according to the reader monad to persist for later use.
06:43:14 <wli> roconnor: No.
06:43:51 <Shimei> I just voted up a sensible qwe1234 post on programming.reddit. I feel funny.
06:44:15 <wli> Philippa: This is an exercise in fiddling with monads vs. a serious effort to do the thing itself. I wouldn't have trouble brute-forcing it sans monads.
06:44:32 <Shimei> The thread, interestingly enough, is tangentially related to FP too: http://programming.reddit.com/info/270a2/comments
06:44:40 <Shimei> (immutable structures)
06:44:47 <Philippa> I think I've missed half the context, then
06:45:31 <roconnor> wli: I haven't either, but Conor has thought a lot about type checking.
06:45:34 <wli> Philippa: I'm just doing a bunch of programming exercises to familiarize myself better with monads.
06:45:38 <roconnor> Althought in the context of dependent typese
06:47:04 <shapr> Good morning #haskell!
06:47:17 <Shimei> Guten morgen.
06:47:24 <quicksilver> roconnor: sounds like a nasty disease indeed
06:47:41 <wli> Philippa: Monadic interpreters seem to be a sort of bridge of asses for monadic programming.
06:47:46 <roconnor> quicksilver: it's just an infestations of e's
06:47:50 <roconnor> ugh
06:48:09 <roconnor> me and spelling and IRC just don't mix well.
06:48:13 <wli> goddammit /usr/bin/ld: cannot find -lHSreadline_dyn
06:48:33 <Philippa> heh
06:48:46 <Philippa> I'm not sure I see what you'd do with the type info you're complaining about losing, basically
06:48:58 <Philippa> it's not just the type inference algo but the type system that says it can be chucked
06:50:24 <wli> Philippa: So it's gotten away with by not relying on anything more than the yes/no answer.
06:50:38 <shapr> In fact, arrow papers say that monads GC far later than they actually should.
06:50:51 <Philippa> wli: huh?
06:50:56 <Philippa> more context!
06:51:05 <Philippa> shapr: you're throwing around a lot of generalisations there
06:51:16 <shapr> Yeah, true.
06:51:30 <Philippa> YAMPA is in many ways a 'most general case'
06:51:52 <wli> Philippa: The type information inferred can be thrown away because for whatever reason it's not used.
06:52:20 <wli> Though I'm not honestly sure how it's lived without.
06:52:23 <mattam> Philippa: are you saying haskell's type inference algorithm is just a recursive function with boolean codomain ?
06:52:26 <Philippa> wli: yes, but the reason it's not used is a deep property of sane type systems
06:52:37 <mattam> I mean wli
06:53:11 <Philippa> the type of an expression is supposed to contain all the static info about it, you're not supposed to have to then look again at subexpressions for more
06:53:20 <lokik_> hmmm what happens when it says *** Exception: Prelude.(!!): index too large
06:53:32 <wli> shapr: I've heard smoke blown about monadic code involving some sort of speed hit but never took it very seriously myself.
06:53:34 <quicksilver> it means you !!'ed past the end of a list
06:53:38 <mattam> The infer function should return at least a type 
06:53:47 <lokik_> .ua
06:53:53 <shapr> na
06:54:02 <Philippa> wli: it does if the optimiser doesn't optimise it out - which it often does
06:54:52 <Philippa> monads're a great example of a technique that benefits from all-but-rabid inlining
06:54:56 <wli> Philippa: I don't worry about speed much apart from asymptotic orders of growth.
06:55:29 <Philippa> sure. That's a different statement from "I don't take statements about constant factors seriously" though
06:57:41 <mattam> I though the type inference algorithm of GHC would have a set of unification constraints lying around too, isn't it the case ?
06:58:10 <wli> mattam: What kind of unification constraints?
06:58:27 <Philippa> I don't think GHC's implementation is constraint-based (BICBW)
06:58:54 <wli> I've not really heard of constraint-based methods.
06:58:59 <mattam> well, a la HM(X)
06:59:22 <mattam> constraints between type variables and types
06:59:28 <Philippa> HM(X) came significantly after GHC, no? Earlier implementations of HM aren't constraint-based either
06:59:45 <Philippa> you can just do straight-up unification at each step
06:59:55 <wli> mattam: Interesting. What sorts of constraints?
07:00:15 <wli> Philippa: Yeah, I'm not going to do anything too involved.
07:00:18 <Philippa> that's what the X is. There's a good theoretical characterisation of the kinds of constraint systems that work, but I forget what it is
07:00:35 <Philippa> (that is: HM(X) is parameterised on a constraint system X)
07:00:45 <mattam> Yes, but I thought maybe it would be good to work this way when adding typeclasses. 
07:01:19 <mattam> wli: François Pottier has a lot to say about this. It may appear in TAPL too.
07:02:13 <roconnor> wow! my optimization reduced the time to compute test case from 150 seconds to 0 seconds.
07:02:31 <lokik_> hmmm what does     Warning: Pattern match(es) are overlapped In the definition of `kostEcilIste': kostEcilIste (x : xs) = ...
07:02:34 <lokik_> mean?
07:02:57 <Lemmih> lokik_: You probably have a more general pattern above it.
07:03:33 <byorgey> morning all
07:03:52 <hpaste>  (anonymous) pasted "make unique list" at http://hpaste.org/1736
07:03:59 <wli> Hmm. It may not be libHSreadline_dyn* but all libHS*_dyn* that are missing.
07:04:36 <lokik_> i djyst peisted http://hpaste.org/1736  what would i need to change to get it to stop overlapping?
07:04:54 <lokik_> i run into an index too large error not long afterwards during runtime
07:05:10 <byorgey> lokik_: reverse the order of the equations, or change the first one to kostEcilIste [] = []
07:05:17 <Lemmih> lokik_: Change _ to [].
07:05:22 <lokik_> kk
07:05:22 <lokik_> :)
07:05:46 <lokik_> yay :ZD
07:05:52 <byorgey> lokik_: pattern-matching happens in the order the definitions are encountered, so the first one would match everything and the second one would never be matched
07:06:14 <lokik_> .ua discovery
07:06:59 <araujo> morning
07:09:10 <shapr> doi lokik .i do na tavla lojbo vi #haskell
07:10:57 <quicksilver> intersting observation that monads benefit from rabid inlining
07:11:07 <quicksilver> the same is true of dictionary-passing implementations of typeclasses
07:11:11 <roconnor> take it to the lojban haskell chanell
07:11:28 <quicksilver> could it be that all of GHC is predicated around rabid inlining?
07:11:29 <quicksilver> :)
07:11:43 <LeCamarade> Seems these people out-number us.
07:11:46 <LeCamarade> lojban
07:12:06 * LeCamarade shivers in terror
07:12:23 <quicksilver> http://xkcd.com/c191.html
07:12:30 <quicksilver> xkcd has an answer for everything, without doubt
07:12:50 <roconnor> ah, there is an xkcd comic for every occasion.
07:14:42 <EvilTerran> is there a conventional order for the parameters to the node constructor in a leaf-labelled binary tree?
07:15:06 <roconnor> left then right?
07:15:33 <EvilTerran> "Branch a (Tree a) (Tree a)", "Branch (Tree a) (Tree a) a", or "Branch (Tree a) a (Tree a)", i mean
07:15:35 <sjanssen> either "node left right" or "left node right"
07:15:44 <EvilTerran> node first? okay.
07:15:54 <sjanssen> EvilTerran: I've never seen the second option in code before
07:15:58 <EvilTerran> (or rather, "node not last, okay")
07:16:07 <quicksilver> I've used left node right
07:16:11 <quicksilver> I think it's much prettier :)
07:16:24 <quicksilver> makes certain tree-balancing algorithms look nicer, too
07:16:32 <quicksilver> the kind which are defined by 'two-deep' pattern matches
07:16:52 <EvilTerran> i find the first looks nicer in general, altho i haven't written that many tree-balancing algorithms
07:17:19 <EvilTerran> also the first and third options make more sense than the second in terms of currying
07:17:36 <quicksilver> I am tempted to say: node first looks nice for data-driven algorithms node-central looks nice for shape-driven algorithms
07:17:40 <quicksilver> but that's rather glib
07:28:21 <EvilTerran> hm. didn't realise you could extract the type of parameters to a fn to use on expressions within the fn with foo(x :: a) =...
07:29:08 <EvilTerran> that seems like it could be easier than `asTypeOf` in places.
07:29:13 <wli> EvilTerran: Does it work with f (x :: a) (y :: b) :: c?
07:29:17 <Igloo> Is www.haskell.org very slow for anyone else?
07:29:28 <EvilTerran> wli, i don't know, i haven't tried
07:29:42 <EvilTerran> fine here, Igloo 
07:29:48 <Igloo> OK, ta
07:30:00 <shapr> EvilTerran: Phantom types?
07:30:39 <EvilTerran> phantom types?
07:30:52 <quicksilver> EvilTerran: he's wondering why you need asTypeOf
07:30:57 <quicksilver> EvilTerran: phantom types are a common reason
07:31:06 <quicksilver> (to force typeclass resolution)
07:31:25 <quicksilver> personally, yes I prefer type annotations to asTypeOf when it's feasible
07:31:26 <EvilTerran> er. yes, forcing typeclass resolution. i'm fiddling with some concepts from one of Oleg's papers.
07:31:44 <quicksilver> it can be unpleasant if (a) the type is very large or (b) you need a ghc extension to even write the type :)
07:32:00 <EvilTerran> oh, this is all quite GHC extended :D
07:32:11 <quicksilver> yeah, I was speaking in geenral
07:34:24 <Philippa> re earlier: there's info on HM(X) in ATTaPL, TaPL just does plain HM
07:35:03 <quicksilver> Philippa: are there other applications of HM(X), distinct from typeclass stuff?
07:35:28 <Philippa> yes, qualified types're just one possible constraint system
07:35:33 * quicksilver nods
07:35:45 <quicksilver> what other kinds of possibilities would you normally think of?
07:36:28 <Philippa> There aren't many usual examples that aren't also an instance of qualified types
07:36:48 <Philippa> though IIRC some forms of subtyping are possible
07:37:17 <dozer> is there a hxt dev in this room?
07:37:22 <Philippa> RTFLiterature :-) The extended version of the ATTaPL chapter used to be available online and probably still is
07:40:17 <quicksilver> Philippa: fair enough :) was just idle curiousity
07:44:22 <wli> ATTaPL?
07:45:23 <wli> Philippa: F-bounded?
07:45:43 <shapr> advanced topics in types and programming languages
07:45:54 <quicksilver> http://www.cis.upenn.edu/~bcpierce/attapl/
07:45:57 <quicksilver> presumably
07:47:39 <shapr> @where ATTaPL
07:47:47 * shapr pokes lambdabot
07:47:59 <shapr> salut Xabi 
07:48:08 * Nafai bounces
07:48:15 * shapr boings
07:48:20 <Xabi> hello shapr
07:48:33 <shapr> How's code?
07:49:28 <profmakx> clear and concise?
07:49:36 <profmakx> *duck*
07:49:48 <shapr> profmakx: You must be writing Haskell!
07:50:03 <profmakx> well
07:50:11 <profmakx> at least i try to :)
07:50:47 <Xabi> I'm writing actionScript 3 now so => unclear unconcise
07:51:15 <quicksilver> I'd love a haskell compiler targetting the Flash VM + graphics engine
07:51:19 <quicksilver> that would be fun
07:51:33 <shapr> quicksilver: haXe is decent.
07:51:47 <shapr> It's really ~Ocaml but it doesn't suck.
07:52:18 <Xabi> quicksilver: me too :)
07:52:49 <quicksilver> shapr: yeah, I was looking at it the other day
07:52:59 <quicksilver> shapr: I'd still like a haskell->flash compiler though :)
07:53:06 <quicksilver> shapr: among other things, I think it would be great for teaching
07:53:15 <quicksilver> it's really nice if students can put their programs on their websites
07:53:33 <quicksilver> and with some decently high level graphics primitives you could do quite pretty stuff quite easily
07:54:04 <wli> That Pierce book looks good.
07:55:34 <shapr> quicksilver: Yeah, but GoA in a flash interface would be nice too.
07:55:53 <quicksilver> shapr: yes, it would
07:56:05 <quicksilver> shapr: would let us play with other stuff, too
07:56:11 <quicksilver> shapr: 2D graphical Hat?
07:56:27 <shapr> quicksilver: I was thinking of embedding a haXe applet in hpaste pages with the source code loaded so you could eval it directly.
07:56:46 <quicksilver> nice idea
07:57:07 <shapr> For best results, there'd be only one state per page and multiple users could interact with it, that would be really nice for teaching.
07:57:07 <quicksilver> with a REPL
07:57:10 <shapr> Right!
07:57:12 <quicksilver> so you can query stuff
07:57:16 <Nafai> That would be awesome!
07:57:22 <quicksilver> one state per page == more server-side stuff though
07:57:23 <shapr> Of course, you'd *really* want voice based chat for that.
07:57:25 <dkruz> want a FREE iPhone? Go here to Score Yourself a FREE iPhone http://www.YourFreeiPhone.com/index.php?ref=3922029  Super easy.
07:57:29 --- mode: ChanServ set +o vincenz
07:57:30 --- kick: dkruz was kicked by vincenz (vincenz)
07:57:32 --- mode: vincenz set -o vincenz
07:57:34 <shapr> vincenz: smooth
07:57:37 <vincenz> thanks :)
07:57:38 <shapr> You're fast!
07:57:40 --- mode: ChanServ set +o vincenz
07:57:45 --- mode: vincenz set +b *!*=pathfind@66.175.214.*
07:57:45 --- kick: dkruz was kicked by vincenz (vincenz)
07:57:46 --- mode: vincenz set -o vincenz
07:57:49 <vincenz> there we go
07:57:58 <malcolmw> got that scripted?
07:57:59 <shapr> spiffy
07:58:01 <roconnor> vincenz: too late, it's in the IRC logs :(
07:58:09 <roconnor> ;)
07:58:10 * dblhelix hears noise and decides to have a look at #haskell
07:58:10 <vincenz> roconnor: I don't have predictive parsing yet :/
07:58:18 <vincenz> I just have /opme
07:58:19 <shapr> I do wish we could remove lines from the logs.
07:58:21 <dblhelix> ah, well done, vincenz
07:58:36 <quicksilver> shapr: many famous people would agree
07:58:41 <vincenz> opme       /msg ChanServ op $C vincenz
07:58:42 <quicksilver> shapr: Stalin, Mussolini... :)
07:59:24 <SamB_XP> shapr: why?
07:59:27 <roconnor>  want a FREE iPhone? Go here to Score Yourself a FREE iPhone [---REDACTED---]  Super easy.
07:59:35 <vincenz> roconnor: umix :)
07:59:36 <SamB_XP> doesn't the stats program miss them anyway?
07:59:47 <SamB_XP> roconnor: hahahaha
07:59:49 <shapr> SamB_XP: Because spammers announce on #haskell so that google will pick it up.
07:59:59 <SamB_XP> shapr: oh...
08:00:00 <vincenz> spammers should be publicly neutered
08:00:01 <edwardk> wow, i think that was the first ban i've seen done here.
08:00:09 <SamB_XP> I thought you meant the kick
08:00:12 <quicksilver> yeah, it doesn't happen often
08:00:13 <vincenz> edwardk: I've banned others in the past :)
08:00:18 <shapr> Me too!
08:00:18 <vincenz> edwardk: like the alias of master_baiter
08:00:30 <vincenz> b4k4something
08:00:36 <SamB_XP> edwardk: eh, um, we've banned bots before
08:00:47 <SamB_XP> also Smerdyakov
08:00:49 <vincenz> shapr: banning + kicking = fun 
08:00:52 <pesco> o/ shapr
08:00:59 <vincenz> SamB_XP: or palomer
08:01:06 <dblhelix> vincenz: now you're scaring me
08:01:09 <shapr> I banned TLO also.
08:01:15 <vincenz> dblhelix: only when it's required :)
08:01:21 <dblhelix> maybe it's the power going to you head
08:01:27 <pesco> Oh, palomer was banned?
08:01:31 <edwardk> i guess I just haven't been around for it
08:01:36 <vincenz> dblhelix: like a rush of cafeine+sugar :)
08:01:55 <shapr> edwardk: But since you have been around often, bans just aren't common here.
08:01:59 <vincenz> anyways, shapr, opme is a useful script
08:02:03 <vincenz> shapr: if you use irssi
08:02:08 <shapr> Nah, I use ERC
08:02:22 <quicksilver> banning + kicking is fun, even when not required
08:02:23 <dblhelix> what was the deal on palomer? cannot remember him as someone who deserves kicking
08:02:27 <quicksilver> that's exactly the problem ;)
08:02:33 <mnislaih> @palomer
08:02:46 <vincenz> ./kick quicksilver You're right, oops!
08:02:56 <dblhelix> :-)
08:02:56 <mnislaih> where did @palomer go ?
08:03:01 <dblhelix> @seen palomer
08:03:06 <vincenz> @palomer
08:03:10 <vincenz> @bot
08:03:10 <pesco> @bot
08:03:14 <vincenz> noooo
08:03:14 <pesco> :)
08:03:19 <quicksilver> lambdabot: wakie wakie
08:03:21 <mnislaih> "As someone who's studied GADTs, I've never found a use for them."
08:03:48 <dblhelix> vincenz: you haven't kicked lambdabot, have you?
08:03:52 <vincenz> dblhelix: :)
08:03:56 <mnislaih> @palomer
08:03:56 <lambdatntbot> I think vim is good for the rubbish bin
08:04:01 <vincenz> whose is lambdatntbot ?
08:04:02 <mnislaih> :)
08:04:09 <vincenz> I have some issues compiling lambdabot so could use some hlep
08:04:13 <dblhelix> mnislaih: who you're quoting?
08:04:20 <vincenz> @palomer
08:04:20 <lambdatntbot> They're telling you lies!
08:04:21 <vincenz> @palomer
08:04:22 <mnislaih> she's our icfp team bot
08:04:22 <lambdatntbot> Pfft, my type inference algorithm takes hours on a 2 line program
08:04:29 <vincenz> mnislaih: oh which version of ghc?
08:04:35 <vincenz> mnislaih: I'm getting problems in runplugs
08:04:47 <mnislaih> I think it's ghc 6.6. I didn't bother with runplugs though
08:04:50 * Igloo notes the use of bold by a spammer
08:04:51 <vincenz> mnislaih: ah
08:05:06 <mnislaih> dblhelix: palomer 
08:05:08 <mnislaih> @palomer
08:05:08 <lambdatntbot> Pfft, my type inference algorithm takes hours on a 2 line program
08:05:11 <vincenz> mnislaih: I get something about Ix{Int} 1024 out of range for ((0,27))
08:05:33 <SamB_XP> Igloo: won't that lower it's google ranking?
08:05:40 * dblhelix 's still studying how to get his client sending text in bold
08:05:44 <mnislaih> vincenz: I got some issues with some parsing module, but I didn't want to go into the runplugs nightmare
08:05:49 <vincenz> mnislaih: oh that I fixed
08:05:52 <vincenz> mnislaih: it was a small bug
08:05:57 <vincenz> mnislaih: you need >= 606 not > 606
08:06:00 <vincenz> in the #ifdef around pling_name
08:06:03 <mnislaih> yep
08:06:07 <mnislaih> exact vincenz 
08:06:17 <dblhelix> mnislaih: ah, seems pretty harmless, right? no reason for kicking there
08:06:25 <vincenz> Igloo: This is a long shot, but would you have any idea why I'm getting Ix{Int} issues with runplugs?
08:06:39 <Igloo> SamB_XP: No, I don't think so
08:06:50 <vincenz> it's the index function
08:06:54 <Igloo> vincenz: No, sorry
08:06:58 <mnislaih> dblhelix: that's a tale I can't tell! I didn't get to know palomer personally
08:07:11 <mnislaih> (manner of speaking of course)
08:07:12 <vincenz> mnislaih: You have any clue?
08:07:18 <Igloo> And using bold text is more likely to irritate me than make me help you
08:07:21 <mnislaih> vincenz: nope
08:07:28 <mnislaih> something to do with Typeable.h probably ?
08:07:54 <vincenz> ./runplugs ^M  1^M runplugs: Ix{Int}.index: Index (1024) out of range ((0,27))
08:08:04 <vincenz> but there's no reference to index anywhere
08:08:08 <mnislaih> is it still the case that the  Typeable.h that you get installed by ghc 6.6.x is the wrong one ?
08:08:26 --- mode: ChanServ set +ntc
08:08:59 <mnislaih> I heard something about that, vincenz. Google finds this:  http://groups.google.com/group/fa.haskell/browse_thread/thread/9cfee3873d29ac71
08:09:03 <lambdatntbot> Title: hs-plugins on ghc6.6? - fa.haskell | Google Groups, http://tinyurl.com/3b6zf5
08:09:10 <vincenz> mnislaih: hanks
08:09:11 <vincenz> +t
08:09:35 <mnislaih> (but that should be corrected in 6.6.1 hopefully)
08:10:22 * vincenz is using 6.6.1
08:10:53 <vincenz> but it's not a compile issue
08:10:57 <vincenz> or wait, maybe it is
08:10:58 <vincenz> hmm
08:11:43 <vincenz> Igloo: how to deal with http://cvs.haskell.org/trac/ghc/ticket/1106 ?
08:11:45 <lambdatntbot> Title: #1106 (During install, network's Typeable.h clobbers base's copy) - GHC - Trac
08:12:02 <malcolmw> earthy: did your hacking on Hat's parser for rank-2 types work yet?
08:12:31 <Igloo> vincenz: Looks like it's fixed in 6.6.1?
08:13:05 <mdmkolbe|ubuntu> is lambdabot down?
08:13:09 <vincenz> hmm
08:13:13 <vincenz> mnislaih: any other clues?
08:13:18 <vincenz> > 1
08:13:18 <oasisbot>  fd:9: hClose: resource vanished (Broken pipe)
08:13:21 <vincenz> this is what I keep getting
08:13:22 <mnislaih> no, sorry
08:13:24 <vincenz> it's runplugs that's borked
08:13:38 <vincenz> @part
08:13:38 <oasisbot> Plugin `system' failed with: IRCRaised Prelude.last: empty list
08:13:38 <lambdatntbot> Not enough privileges
08:13:42 <vincenz> oy
08:13:44 <vincenz> more issues
08:13:51 <vincenz> @part #haskell
08:13:51 <lambdatntbot> Not enough privileges
08:13:53 <mnislaih> vincenz, we hope to steal lambdabot  during the contest
08:13:59 <malcolmw> @botsnack
08:13:59 <lambdatntbot> :)
08:14:02 <vincenz> mnislaih: I prefer not to, cause we want to have logs
08:14:02 <mnislaih> @part #haskell
08:14:30 <mnislaih> We want to use lambdatntbot for our logs, and lambdabot for > expressions
08:14:44 <vincenz> oh
08:15:54 <mdmkolbe|ubuntu> When is this contest?
08:16:02 <mnislaih> on 2nd thought, are lambdabot logs publicly available ?
08:16:09 <mdmkolbe|ubuntu> @logs
08:16:22 <vincenz> mnislaih: yes
08:16:25 <mnislaih> then if lambdabot is in our channel, everybody can steal our secret plans to win the contest?
08:16:26 <vincenz> mnislaih: and dons can always read em
08:16:31 <vincenz> mnislaih: who's on your team?
08:17:15 <mnislaih> that's timbod, Tillman rendel whose nick I can't remember,  and me
08:24:47 <vincenz> Igloo: oh I think it's because plugins is not suitable for 6.6.1?
08:25:13 <Igloo> vincenz: I don't know anything about plugins, sorry
08:25:30 <vincenz> Igloo: ok, thanks nonetheless
08:25:37 <edwardk> vincenz: what about plugins?
08:26:06 <vincenz> edwardk: it's not working well with 6.6.1, Lemmih suggested I needed to manually patch the parser to fit 6.6.1
08:26:10 <vincenz> edwardk: the issue is that runplugs is borking
08:26:48 <edwardk> ah. i had to stop working it when it broke on windows, i was wondering if it was that issue.
08:26:57 <mnislaih> edwardk: catch and (>>=) are bringing me mad !
08:27:10 <edwardk> mnislaih: heh
08:27:26 <mnislaih> I'm still hacking on it, so we'll see
08:28:08 <edwardk> mnislaih: i think the right answer might be to change the way the exception hierarchy works to fit the type-list parameterized version better so we can get those laws we were talking about the other day
08:28:17 <edwardk> er i still think
08:29:21 <mnislaih> there is no hierarchy yet. It is flat for now. The problem is that I'm not sure I understand the Bind between the exceptions monad and the negative exceptions monad
08:29:31 <edwardk> ah
08:29:33 <mnislaih> i.e., the semantics of the Bind
08:29:46 <edwardk> @type catch
08:30:01 <edwardk> gah lambdabot is pushing up daisies?
08:30:02 <mnislaih> for starters, a straight Bind does not make sense. Bind and catch have similar types, but not the same
08:30:12 <dblhelix> oops -- closed the lit of my ibook
08:30:15 <mnislaih> @type catch
08:30:18 <lambdatntbot> forall a. IO a -> (IOError -> IO a) -> IO a
08:30:35 <edwardk> oh yeah
08:30:41 <edwardk> its not a bind, my bad =)
08:30:45 <mnislaih> my catch looks like : ....long list of constraints.... => IOE a -> (e -> IOE a) -> IOE a
08:31:16 <mnislaih> but the intuition is good, maybe we can define some reasonable semantics for it
08:33:38 <edwardk> something like m l a -> (e -> m l' a) -> m l'' a  where m m' m'' have the right hlists so that l'' = (l \\ [e]) `union` l'   ?
08:34:05 <mnislaih> that's exactly the current catch
08:34:49 <mnislaih> it works, more or less. Sometimes it will need type annotations because of handlers composed of a single return
08:35:04 <edwardk> so, my question is why is it that we presume an IOE rather than a general "E l a", then lift that when we bind it to IO to get an IOE
08:35:44 <edwardk> with a generic Catch class that works like Bind does
08:35:50 <quicksilver> There is a post on -cafe where Janis Voigtlander shows how to extend DLists so that map runs on O(1) time
08:35:55 <quicksilver> does anyone understand this post?
08:36:08 <dozer> mm - I have "Context reduction stack overflow; size = 20" and the output is flip/flopping between trying to validate two instances of the same class
08:36:40 <edwardk> class Catch m m' m'' e | m m' e -> m'' where catch :: m a -> (e -> m' a) -> m'' a
08:36:49 <mnislaih> Wait, I have a generic Catch class with that shape.
08:37:04 <edwardk> ok, i need to review your code again
08:37:29 <mnislaih> there are minor problems with type inference, but it is acceptable
08:38:04 <edwardk> well, the question is what keeps it from inferring? single returns? just add Identity to the Catch class no?
08:38:42 <mnislaih> I hadn't thought of that. Yep, sounds good !
08:38:44 <edwardk> then IOE l a -> (e -> Identity a) -> IOE (l \\ {e}) a works
08:39:23 <mnislaih> gah, exactly
08:39:31 <edwardk> similarly Identity a -> (e -> IOE a) -> ___Identity___ a can even be snuck in there because we know the exception handler will never be invoked ;)
08:39:45 <edwardk> moreover that works regardless of the monad in the second position
08:39:47 <edwardk> so
08:40:11 <mnislaih> this is a whole new order, monad-level programming :)
08:40:12 <edwardk> instance Catch Identity m Identity e where catch x y = x
08:40:34 <edwardk> @pl \x y -> x
08:40:35 <lambdatntbot> const
08:40:44 <edwardk> er, where catch = const
08:42:02 <SamB> mnislaih: you mean higher-order imperatives?
08:42:41 <mnislaih> SamB: what is that?
08:43:09 <edwardk> so, now, the question is, does this allow the same form of transformation that I was able to do to my security monads so we can construct this in normal haskell without my parameterized monad library
08:43:36 <mnislaih> edwardk: the whole point of this is having the exception list float out to the type,
08:43:46 <edwardk> yeah
08:43:59 <mnislaih> There is no way you can do that with a regular monad, right ?
08:44:09 <SamB> mnislaih: well, you know, you can pass monadic actions to functions which use them to construct new actions
08:44:22 <lokik_> I need to use threadWaitWrite :: Fd -> IO () but have no idea how te gete Fd
08:44:28 <lokik_> get the Fd *
08:44:33 <edwardk> well, the idea is to use MTL like 'lift' operations
08:44:38 <mnislaih> SamB: might be, but I don't think so.
08:44:38 <SamB> mnislaih: I think there is
08:44:51 <SamB> mnislaih: but I think you might need trex or similar
08:44:55 <mnislaih> (I was referring to higher-order imperatives)
08:45:18 <SamB> mnislaih: a new and higher order of imperative programming?
08:45:19 <mnislaih> Ah, you are thinking about pulling the exceptions list to a constraint?
08:45:32 <edwardk> subsume :: IOE l a -> IOE l' a where l is a subset of l'
08:45:39 <SamB> mnislaih: I'm talking about *two* things at one time
08:45:41 <edwardk> then just doing an MTL like library over that
08:46:02 <edwardk> its annoying, but it'd be a possibly more 'marketable' version than the fun parameterized one =)
08:46:15 <mnislaih> I need to take a look at the tricks you used for your security monad
08:46:22 <mnislaih> monads
08:46:41 <mnislaih> But that will have to wait until the next week probably !
08:47:08 <edwardk> would it be stepping on your toes terribly to roll the effect stuff into monad-param itself?
08:47:10 <vincenz> mnislaih: ok, fixed that issue, runplugs works
08:47:15 <vincenz> mnislaih: my last issue is basically an hClose thingy
08:47:21 <vincenz> mnislaih: for all my commands, I get an hClose bug
08:47:42 <mnislaih> vincenz: would you mind to send patches my way ?
08:47:53 <mnislaih> I might give it a try after all
08:48:12 <mnislaih> edwardk: what are you thinking of ?
08:48:45 <edwardk> not sure actually
08:49:23 <mnislaih> if you want to add code to monad-param, feel free. But I'm not sure of why you'd want to do that
08:49:26 <edwardk> i'm thinking this might be the 'right' way to implement them for my Abstract prelude, just debating about if its also something that should just be part of the monad-param library so you don't have to grab two packages.
08:49:47 <mnislaih> two packages and cabal-install
08:50:08 <mnislaih> then you can just ask cabal-install to grab one and it will get all the dependencies for you
08:50:15 <edwardk> true
08:50:46 <edwardk> then maybe keeping them modular isn't a bad idea
08:51:13 <edwardk> i'll probably roll up a version for the abstract prelude though
08:51:27 <mnislaih> edwardk: I promise to package this shortly
08:51:29 <edwardk> as soon as i write a preprocessor so I can continue writing it =(
08:52:07 <mnislaih> my HList code is crap though
08:52:22 <mnislaih> it is still too fragile
08:52:32 <edwardk> fair enough. one of the reasons why I wanted to do it in Abstract is that I'm baking in a notion of HList into the prelude
08:52:46 <edwardk> so i can leverage more machinery
08:53:12 <wli> HList?
08:53:24 <edwardk> wli: type-level heterogeneous lists
08:53:28 <edwardk> 'lists of types'
08:53:31 <mnislaih> I'm not sure if that would help. I had to bring in HList because I needed to modify HDel, for instance
08:53:36 <quicksilver> edwardk: ?
08:53:49 <quicksilver> edwardk: HList isn't lists of types, per se. HList is lists of values...
08:53:57 <quicksilver> edwardk: HList types are lists of types, of course...
08:54:11 <edwardk> quicksilver: sure, its just usually used for the list of types =)
08:54:20 <SamB> quicksilver: well if you use undefined for all of the values, you can use it as a list of types ;-)
08:54:23 <quicksilver> HList is really just a bunch of typeclasses around tuples
08:54:30 <quicksilver> which is not to say that isn't useful
08:54:42 <shapr> But it's essentially a bunch of nested tuples.
08:54:53 <edwardk> and a crapload of typeclasses
08:54:56 <SamB> yes but nested tuples are lovely
08:55:11 <shapr> Yeah, but it seems like there should be some real machinery in place of nested tuples.
08:55:26 <SamB> in fact they are so wonderful lisp uses them for almost everything
08:55:33 <SamB> (I think they take it a bit far though ;-)
08:55:34 * quicksilver hands shapr a type-level forklift truck.
08:56:15 <wli> Just make the type sublanguage some sort of Prolog program.
08:56:18 <SamB> shapr: so... would t-rex do any better do you think?
08:56:59 <SamB> incidentally, I think associated types are designed to offer an alternative to type-level prolog
08:57:05 <shapr> I'm not sure. I know that Daan wanted to replace TRex (only in Hugs) in the original version of HaskellDB with nested tuples for GHC.
08:57:05 <quicksilver> wli: the typeclass sublanguage already is a sort of Prolog program, aren't they?
08:57:30 <wli> quicksilver: I'm obviously saying to just dump full Prolog into it.
08:57:37 <quicksilver> oh I see
08:57:42 <wli> SamB: What are associated types?
08:57:45 <quicksilver> it's those damn english quantifiers
08:57:56 <SamB> @google associated types with class
08:57:57 <quicksilver> and their curious behaviour under modalities
08:57:58 <lambdatntbot> http://research.microsoft.com/~simonpj/papers/assoc-types/
08:57:58 <lambdatntbot> Title: Associated types with class
09:00:31 <wli> I wonder how tough it is to add typeclasses to ordinary HM.
09:01:47 <Philippa> the basics aren't too hard. Read "Typing Haskell In Haskell"?
09:02:07 <wli> I've got it floating around somewhere but haven't looked at it in a few years.
09:02:52 <wli> I didn't think of it offhand. Thanks.
09:03:06 <vincenz> > 1
09:03:07 <oasisbot>  1
09:03:11 <quicksilver> yay!!!!!!!
09:03:14 <quicksilver> vincenz++
09:03:15 <vincenz> @join #oasis
09:03:15 <lambdatntbot> Not enough privileges
09:03:17 <quicksilver> (finally)
09:03:29 <quicksilver> vincenz: what fixed it, in the end?
09:03:45 <vincenz> getting the regexp- from hackage
09:03:46 <SamB> why didn't lambdatntbot answer the >?
09:03:53 <vincenz> and getting hsplugins from repo, not hackae
09:03:55 <dblhelix> wli: read mark jones' phd thesis and you know how it's done
09:03:57 <vincenz> (this is for 6.6.1)
09:04:00 <quicksilver> SamB: lambdatntbot doesn't have plugins set up
09:04:15 <quicksilver> vincenz: could you post at least a brief message to the -cafe saying what you needed to do?
09:04:25 <vincenz> quicksilver: alright
09:04:29 <quicksilver> vincenz: I've seen so many people fail to compile lamdabot
09:04:33 <quicksilver> vincenz: and so few succeed :)
09:05:18 <edwardk> wli: the tricky part is that typeclasses interact strangely with some other nice extensions to HM like polymorphic records, etc.
09:06:22 <bluetech> say, if you can't write the type signature for a function, than is it impossible to compile? for example, a function which takes itself as a parameter?
09:06:32 <crazy_coder> hello everyone
09:06:47 <crazy_coder> I was wondering if anyone could help me explain this :
09:07:01 <quicksilver> bluetech: no, but you typically need to mediate with a new type of some kind
09:07:05 <crazy_coder> preorder Nil = []
09:07:06 <crazy_coder> preorder (Node x t0 t1) = x : ((preorder t0) ++ (preorder t1))
09:07:17 <quicksilver> bluetech: recursive types are permitted in haskell, just not 'anonymous' recursive types
09:07:18 <crazy_coder> Why is the time complexity O(n2) ?
09:07:29 <crazy_coder> n2 is n square :)
09:07:30 <wli> edwardk: I fortunately won't be getting into anything of that sort for a student-job monadic interpreter.
09:07:43 <quicksilver> crazy_coder: because the ++ keeps copying its entire left-hand-side
09:07:45 <wli> crazy_coder: More typically it's written n^2.
09:07:57 <quicksilver> crazy_coder: which happens over and over again down both sides of the tree
09:08:00 <edwardk> wli: fair enough =)
09:08:43 <crazy_coder> quicksilver: what do you mean by copying ?
09:09:06 <wli> edwardk: The only thing I really care about is some way to handle IO.
09:09:08 <bluetech> quicksilver: so i thought :) what is the 'standard way' to do anonymous recursion in haskell, than?
09:09:39 <quicksilver> crazy_coder: a ++ b manages to 'reuse' the existing copy of the list b in memory
09:09:45 <quicksilver> crazy_coder: but it has to make a new copy of a
09:09:46 <vincenz> quicksilver: sent
09:09:54 <byorgey> @src (++)
09:09:55 <lambdatntbot> (++) []     ys = ys
09:09:55 <oasisbot> (++) []     ys = ys
09:09:55 <lambdatntbot> (++) (x:xs) ys = x : xs ++ ys
09:09:55 <oasisbot> (++) (x:xs) ys = x : xs ++ ys
09:10:00 <quicksilver> crazy_coder: this is fundamental to how lists work in haskell: they can share tails, but they can't share heads
09:10:10 <byorgey> yikes, two lambdabots!
09:10:25 <mnislaih> @leave #haskell
09:10:25 <oasisbot> Not enough privileges
09:11:45 <vincenz> > 1
09:11:45 <oasisbot>  1
09:11:50 <vincenz> @src (++)
09:11:50 <oasisbot> (++) []     ys = ys
09:11:50 <oasisbot> (++) (x:xs) ys = x : xs ++ ys
09:12:37 <crazy_coder> Ok, Its a bit complicated. I had the basic idea of looking at it as - if there are 2 for loops , it is n^2 complexity :)
09:13:09 <quicksilver> crazy_coder: well that is true as far as it goes, if the loops are nested and both of O(n) length
09:13:18 <crazy_coder> but sill why n^2 and not n^3 ?
09:13:24 <quicksilver> but obviously your preorder function isn't nested
09:13:32 <quicksilver> and neither does it have for loops :)
09:13:46 <crazy_coder> yeah, thats the problem, the nesting is not clearly evident
09:13:56 <crazy_coder> But it is more internal stack stuff
09:13:59 <quicksilver> yup
09:14:10 <quicksilver> you call ++ approximately once for every node in the tree
09:14:17 <crazy_coder> which cant be easily seen if basic of how it works is not understood
09:14:27 <quicksilver> (actually you only call it for non-Nil nodes but that's the same thing)
09:14:35 <quicksilver> so you call ++ O(n) times
09:14:40 <quicksilver> then the question is: how fast is ++ ?
09:14:56 <quicksilver> turns out ++ runs at a speed proportonial to its left-hand-side
09:15:12 <quicksilver> and you call it with all kinds of different sized left-hand sizes
09:15:24 <quicksilver> including, worst case, the left-hand-side being the 'whole left branch of the tree'
09:15:42 <crazy_coder> Oh ok great Thanks
09:16:17 <crazy_coder> So to improve the time complexity I should actually avoid ++  ?
09:16:29 <quicksilver> yes, that's right
09:16:46 <quicksilver> the standard trick is to use function composition instead
09:16:56 <quicksilver> which is a bit surprising until you're used to it, frankly
09:17:15 <quicksilver> preorder Nil = id
09:17:19 <crazy_coder> Ok I'll see how to implement , cause my task is to run it in O(n) time
09:17:35 <quicksilver> preorder (Node x t0 t1) = (x:) . (preorder t0) . (preorder t1)
09:17:38 <pjd> @remember qwe1234 lazy evaluation is a trivial syntactic hack, not a real language feature.
09:17:39 <oasisbot> Not enough privileges
09:18:04 <mnislaih> edwardk: I implemented your suggestions, and indeed, type inference has been restored as expected
09:18:09 <pjd> where's lambdabot?
09:18:15 <quicksilver> this has the magic effect of turning your preorder into something which just calculates a long composition of (:)
09:18:25 <quicksilver> which you then execute by applying it to []
09:20:21 <vincenz> pjd: bbroken
09:20:21 <crazy_coder> quicksilver: what does id do ?
09:20:37 <pjd> vincenz: oh no
09:20:46 * pjd sends a "get well soon" card
09:20:53 <quicksilver> crazy_coder: nothing
09:20:59 <quicksilver> crazy_coder: it's the identity function
09:21:05 <crazy_coder> Is it a monad ?
09:21:08 <quicksilver> nope
09:21:10 <quicksilver> just a function
09:21:13 <quicksilver> > id 4
09:21:14 <oasisbot>  4
09:21:17 <quicksilver> > id "hello"
09:21:18 <oasisbot>  "hello"
09:21:20 <quicksilver> @src id
09:21:21 <oasisbot> id x = x
09:21:21 <vincenz> @users
09:21:21 <oasisbot> Maximum users seen in #haskell: 346, currently: 336 (97.1%), active: 13 (3.9%)
09:21:28 <vincenz> > replicate 346 "lambda-cookie"
09:21:29 <oasisbot>  ["lambda-cookie","lambda-cookie","lambda-cookie","lambda-cookie","lambda-coo...
09:21:44 <quicksilver> crazy_coder: the idea is that preorder now calculates not a list, but a function [a]->[a]
09:21:58 <quicksilver> crazy_coder: which sticks the 'answer' onto the front of the provided list
09:22:11 <quicksilver> crazy_coder: then you give it the empty list [] to start it going
09:27:24 <wli> typehask.ps is rather useful.
09:35:07 <crazy_coder> Thanks :)
09:37:21 <edwardk> mnislaih: nice!
09:50:31 <wli> Dependency analysis for binding groups didn't occur to me. Looks like chopping it up into strongly connected components, modding those out to get a DAG, then typechecking sequentially from its roots.
09:51:47 <SamB> wli: I believe a binding group is just an SCC, if that's what you mean
09:52:20 <SamB> er. probably that apostrophe doesn't go there...
09:52:52 <edwardk> wli: it really helps keep complexity under wraps. I also like the shortcut of just using the type annotations where they are present to break up cycles further.
09:52:56 <wli> SamB: Typehask.ps uses "binding group" to refer to all the bindings in a let/where statement or top-level binding.
10:00:55 <quicksilver> vincenz: nice
10:02:35 <ddarius> SamB: That apostrophe does go there.
10:03:07 <vincenz> quicksilver: worked/
10:09:32 <SamB> ddarius: apostrophes are so confusing
10:10:22 <ddarius> Apostrophes, when they aren't for the possessive case, represent elision.  For, "that's" you are eliding the 'i' in "that is".
10:11:01 <ddarius> (Actually, the elision use overrides the possessive resulting in "its" and "it's".)
10:12:15 <ddarius> (Of course, we don't say "her's" so I it all works out nicely.)
10:12:39 <Syzygy-> ddarius: That'd be she's shouldn't it? I don't see how her's even comes up as a parse option...
10:13:36 * oasisbot kicks Syzygy- for parser-overflow
10:14:03 <Syzygy-> Huh?
10:14:16 <ddarius> Point.  But there is the usage, "the dog is hers" which is ballparkish.
10:14:16 <mrd> were you trying to use as many apostrophes as possible?
10:14:56 <vincenz> hers and his are apostrophe-less
10:15:27 <vincenz> Syzygy-: and That'd be = That would be, not That should be
10:15:32 <vincenz> Syzygy-: so that made your sentence more confusing
10:15:40 <Syzygy-> For using lots and lots of apostrophes, you'd want phonologically written dialect with many elisions and glottal stops. Co'n'ey would be an example, I'd guess.
10:15:43 <Syzygy-> vincenz: Ah.
10:16:04 <ddarius> vincenz: Only for non-Americans.
10:16:18 <Syzygy-> vincenz: I am in principle aware of that'd < that would - but think I had some thought at the back of my head as to why I wanted to continue with should...
10:16:47 <ddarius> Well, I guess the sentence as a whole is confusing.
10:17:22 <ddarius> Syzygy-: Because ending with "wouldn't it?" would have a somewhat different meaning.
10:17:30 <Syzygy-> ddarius: What I wanted to say is that her already takes in the case, and 's from elision wouldn't have a genitive but a nominative, so her's falls out of question.
10:17:42 <Syzygy-> And then I was fishing for confirmation of my opinion at the end.
10:18:04 <ddarius> Syzygy-: I understand and agree.
10:18:41 <Syzygy-> But now. Dinner, and then Harry Potter.
10:18:50 <Syzygy-> On one of the six scheduled sane screenings in town.
10:18:50 <ddarius> Work for me.
10:19:16 <Syzygy-> (original english: three days, two screenings a day - all the rest are with german soundtrack *yech*)
10:21:29 <vincenz> donde estas Syzygy-
10:36:02 <Stinger_> bah whats the lambdabot trigger?
10:36:21 <Cale> @
10:36:40 <Cale> If that's what you're asking...
10:36:50 <Cale> @type length
10:36:52 <oasisbot> forall a. [a] -> Int
10:37:01 <Cale> > length [1,2,3]
10:37:01 <Stinger_> oh oasisbot huh?
10:37:01 <dblhelix> @seen palomer
10:37:02 <oasisbot> I haven't seen palomer.
10:37:02 <oasisbot>  3
10:37:18 <Cale> I guess lambdabot is taking a break :)
10:37:34 <Stinger_> aah good there we go
10:37:36 <Stinger_> thanks :)
10:38:42 <McBee> j@src and
10:38:44 <McBee> @src and
10:38:44 <oasisbot> and   =  foldr (&&) True
10:39:10 <McBee> @src return
10:39:10 <oasisbot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
10:39:47 <dblhelix> @src Monad
10:39:47 <oasisbot> class  Monad m  where
10:39:47 <oasisbot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
10:39:47 <oasisbot>     (>>)        :: forall a b. m a -> m b -> m b
10:39:47 <oasisbot>     return      :: a -> m a
10:39:47 <oasisbot>     fail        :: String -> m a
11:03:11 <hpaste>  slowriot pasted "parse error" at http://hpaste.org/1737
11:04:37 <slowriot> I'm not sure what's wrong with the above code
11:05:05 <oerjan> slowriot: is that if part of a do block?
11:05:10 <slowriot> tyes
11:05:12 <slowriot> yes
11:05:23 <oerjan> then you need to indent the else
11:05:50 <oerjan> in a do block, a new statement starts every time a line is indented the same as the first one
11:06:02 <slowriot> oh
11:06:26 <slowriot> maybe I could just move else up to the line above it
11:06:40 <slowriot> or use case instead
11:07:04 <oerjan> it's been suggested to change this for haskell-prime
11:08:56 <hpaste>  slowriot annotated "parse error" with "like this?" at http://hpaste.org/1737#a1
11:09:38 <oerjan> yeah
11:09:46 <slowriot> I still get a parse error
11:10:18 <slowriot> oh
11:10:19 <slowriot> nevermind
11:10:37 <slowriot> it's somewhere else
11:11:02 <oerjan> btw you can move return (dt, ...) outside the if if you want
11:20:41 <br1> slowriot: Was that HSDL? Is that alive?
11:21:35 <slowriot> brl: I don't think so
11:21:40 <dylan> that's a familiar nick...
11:21:42 <slowriot> brl: yes, it is HSDL
11:21:51 <slowriot> brl: well.... hsSDL actually
11:22:11 <slowriot> brl: I think HSDL became hsSDL
11:22:13 <dylan> moonlite: were you part of the "Creatures" community?
11:22:48 <slowriot> brl: actually, lemmih has updated it recently, so I guess it's kind of alive
11:23:21 <br1> great
11:23:37 <moonlite> dylan: ?
11:23:44 <br1> I thought there was no SDL for askell, since I heard about GLUT, that's much worse.
11:23:49 <moonlite> that would be a no :)
11:24:24 <dylan> moonlite: Just curious. Same ISP and nickname. :)
11:24:42 <moonlite> oh :)
11:25:13 <slowriot> brl: I've been messing around with Yampa and hsSDL.
11:26:18 <vincenz> hey
11:28:13 <jethr0> i'm trying to make an instance of "Num" which is supposed to be variable width. is there a way to type that cleanly without weird "Succ (Succ Zero)" type hackery?
11:29:01 <jethr0> let me rephrase that: the width should be set initially and only "numbers" with same width should be addable/...
11:29:42 <vincenz> jethr0: phantom-types
11:29:53 <vincenz> jethr0: with the SUC SUC crap for width
11:30:34 <jethr0> hmm, i hate that stuff. so, would i have to write SUCC 16 time to represent a width of 16?
11:31:01 <br1> slowriot: I'm not sure about Yampa.  You can't persist your state that way.
11:31:13 <Heffalump> jethr0: you can define aliases for 10, 100 etc
11:31:26 <jethr0> Heffalump: thx, what a relief ;)
11:31:40 <jethr0> br1: well, you kinda can if you put the yampa loop inside the sdl loop
11:32:40 * Heffalump did this recently and had stuff like D10 (D5 ()), IIRC.
11:32:40 <jethr0> s/put ... inside/call ... from/
11:32:54 <slowriot> I don't really have an SDL loop.
11:33:03 <slowriot> Yampa's reactimate is the only loop in my program.
11:33:38 <jethr0> slowriot: k, so how do you handle sdl inputs? bah, it's too long ago that i did anything with yampa and opengl ;(
11:35:08 <slowriot> jethro: Yampa's reactimate takes a 'sense' function. I just call SDL's pollEvent inside the sense function.
11:35:21 <slowriot> jethr0:^
11:35:58 <jethr0> k, i tried it the other way round with opengl. finally i got a bit frustrated with yampa - i guess just a few minutes before i finally "got" it ^_^
11:37:16 <slowriot> jethr0: yampa is kind of frustrating. It needs some more polish and more in-depth tutorials. The documentation they have now is decent, but it still seems like a work-in-progress. (And to be fair, it is one.)
11:38:34 <slowriot> jethr0: At least I think they are still working on it. They haven't released anything in awhile.
11:38:44 <jethr0> slowriot: i tried it a year ago and my progress was beyond SLOW. i guess it's quite far from my programming experience. yampa must be the framework with the steepest learning curve i know
11:39:14 <slowriot> jethr0: yeah, I feel for you.
11:39:22 <jethr0> and i with you *g*
11:39:25 <slowriot> jethr0: anyway, back to hacking
11:40:37 <SamB> you, too, can improve yampa's documentation...
11:41:53 <vincenz> jethr0: you can write combinators
11:41:54 <slowriot> SamB: you're right. I feel that I am still to much of a haskell newb to write anything valuable though.
11:42:18 <vincenz> jethr0: add4 :: a -> Succ (Succ (Succ (Succ a))))
11:42:21 <vincenz> add4 a = undefined
11:42:41 <vincenz> type D16 = ...
11:42:42 <slowriot> SamB: are you involved in yampa, or are you just suggesting that I could independently write tutorials?
11:42:54 <jethr0> SamB: i was actually working on a tutorial for yampa, writing a pong game, but i got frustrated with my progress and then something else came up ;(
11:42:57 <slowriot> sweet... the new input code worked. I almost have pong
11:43:04 <slowriot> woah
11:43:13 <jethr0> hehe, my pong is more or less working as well
11:43:23 <jethr0> but the code is beyond ugly
11:43:28 <slowriot> so is mine
11:43:35 <jethr0> *grins*
11:44:40 <SamB> slowriot: I was suggesting that you could probably submit darcs patches (it does have a darcs repository doesn't it?)
11:45:38 <slowriot> SamB: I believe they are using a private CVS repo.
11:45:46 <SamB> oh, that sucks
11:46:28 <SamB> @seen JaffaCake
11:46:28 <oasisbot> JaffaCake is in #haskell. I don't know when JaffaCake last spoke.
11:46:32 <SamB> oh.
11:47:14 <SamB> JaffaCake: I'm wondering if you have clean archives of jhc@haskell.org, suitable for import into gmane?
11:47:43 <mrd> cdsmith: you know, shim can ask for types of expression in context
11:47:58 <mrd> cdsmith: it's just a matter of picking apart the internal rep
11:48:07 <cdsmith> @where shim
11:48:07 <oasisbot> http://shim.haskellco.de/trac/shim
11:48:27 <mrd> the only thing stopping me from using shim all the time now is that harnessing runStmt is, well, troublesome
11:48:33 <cdsmith> mrd: interesting.  I'll look at it.
11:48:55 <mrd> i took a whack at adding a repl to it, but, eh
12:01:28 <laz0r> mmh, i need some enlightment regarding the do expression... when i write 'do something; somthingElse; ...' then that basicly means that something returns a 'high order function' whose output will be fed as first argument to somethingElse?
12:02:11 <oerjan> laz0r: actually, without a <- the output is just thrown away
12:02:26 <int-e> @undo do something; somthingElse
12:02:26 <oasisbot> something >> somthingElse
12:02:51 <oerjan> @undo do x <- something; somethingElse
12:02:51 <oasisbot> something >>= \ x -> somethingElse
12:03:27 <byorgey> @undo do x <- something; somethingElse x
12:03:27 <oasisbot> something >>= \ x -> somethingElse x
12:03:41 <int-e> laz0r: it depends on the monad what exactly that means; something and somethingElse are monad actions; do something; somethingElse  is the action that runs  something first, then discards the result and runs somethingElse.
12:04:20 <oerjan> http://haskell.org/onlinereport/exps.html#sect3.14 gives the translation rules for do expressions
12:04:21 <oasisbot> Title: The Haskell 98 Report: Expressions
12:04:27 <laz0r> well, when i have a type like (Int -> (Int, a))... and i have functions that return that type, i can string them together in a do expression
12:05:00 <laz0r> of course, first i would have to make that type an instance of monad
12:05:02 <int-e> laz0r: note that the meaning of 'first' and 'then' actually depends on the monad.
12:05:04 <laz0r> right?
12:05:21 <oerjan> laz0r: you also need to map the type in a newtype, for technical reasons
12:05:35 <laz0r> yes, i discovered that too
12:05:38 <oerjan> (which happen to be Control.Monad.State.State)
12:05:45 <oerjan> *s
12:05:59 <Cale> laz0r: That would be roughly like the State Int a type, so yeah.
12:06:19 <laz0r> yes, i know, but i always end up with something that returns (whatever-i-put-in, a)
12:07:01 <int-e> > runState (State (\x -> (x+1, 43))) 23 -- hmm
12:07:02 <oasisbot>  (24,43)
12:08:02 <oerjan> laz0r: if you use only return and >>= then you will not change the state, true
12:08:22 <oerjan> you need to define the state-changing functions specifically for the monad
12:09:15 <oerjan> (equivalently, if you use only do expressions and return)
12:09:24 <laz0r> yes, i think i did that.... i think i'll just paste my sources and have take a look at it... maybe then things will get clearer (for both of us)
12:10:02 <oerjan> ok
12:10:12 <int-e> > runState (do x <- get; put (x+1)) 0
12:10:13 <oasisbot>  ((),1)
12:10:55 <hpaste>  laz0r pasted "warning: might be horrible..." at http://hpaste.org/1738
12:10:58 <laz0r> ok
12:11:03 <laz0r> it is quite alot
12:11:24 <laz0r> and it is probably not the best haskell code....
12:11:29 <laz0r> but it works for me
12:11:48 <laz0r> see, it is meant to construct .dot files
12:12:08 <laz0r> those are used by the graphviz package to construct graphs
12:12:19 <Cale> Label is the same as State Dot
12:12:20 <laz0r> it is an easy markup language
12:12:23 <laz0r> yes
12:12:49 <laz0r> i know, thats what i meant with 'i always end up with a state monad'
12:13:18 <byorgey> laz0r: so why not just use State Dot?  Then you wouldn't have to define the Monad instance yourself
12:13:21 <Cale> If you're using GHC, you could write:  newtype Label a = Label (State Dot a) deriving (Functor, Monad, MonadState Dot), and you wouldn't have to write the monad instance yourself.
12:13:58 <fasta> @pl liftM join
12:13:58 <oasisbot> fmap join
12:14:04 <Liskni_si> what's the definition of the get and put functions?
12:14:05 <Cale> (also, have to turn on -fglasgow-exts for that)
12:14:14 <laz0r> oh, i just didn't know it already existed at first, and when i discovered i thought that doing it myself would maybe teach me more about monads
12:14:42 <oerjan> well as far as i can see the definition of the monad itself is correct
12:14:53 <laz0r> yes, i stole it...
12:15:06 <Cale> Liskni_si: For State, it's just  get = State (\s -> (s,s))  and  put v = State (\s -> (v,())
12:15:11 <laz0r> but i kept reading it, and i think i understand it
12:15:36 <byorgey> laz0r: State is not the easiest instance to start with when trying to understand monads
12:16:12 <byorgey> laz0r: try implementing Monad instances for Maybe and [] (list) too
12:17:07 <oerjan> laz0r: is there some problem with the code?
12:17:21 <Liskni_si> Cale: ah, thx
12:18:26 <SamB> byorgey: won't you get errors about there already being instances for Maybe and []?
12:18:36 <glguy> newtype them
12:18:58 <glguy> or make a data Mebe a = Jist a | Nada
12:19:09 <byorgey> SamB: yeah, what glguy said is what I meant
12:19:17 <byorgey> maybe I should have been more explicit
12:19:48 <fasta> Is there any GHC extenstion that will get as strong as Coq (e.g. that we can define monad as set, etc)?
12:20:07 <laz0r> ok, so, what those sources enable me to do is the following: i can construct a Dot datastructure with 'append' and appendChildren, in a do expression, then just carry on the 'Label Dot' thing, which is a function that takes a Dot and produces a new Dot
12:20:19 <fasta> extension*
12:20:45 <laz0r> and at the end, i'll just put in an empty Dot, and *poof* get the Dot i created in the first place
12:20:58 <laz0r> that must be lazy evaluation magic i guess
12:21:25 <mauke> for State? no, actually
12:21:41 <fasta> Someone said English was verbose the other day... yes, it is.
12:21:57 <int-e> laz0r: note that where you wrote  appendChildren [x] >> appendChildren xs  you could just as well write  do appendChildren [x]; appendChildren xs
12:22:12 <mauke> the State monad just composes transformer functions
12:22:52 <newsham> > do { x <- get; put (x+1); return (x+2) }
12:22:53 <oasisbot>   add an instance declaration for (Show (t t1))
12:22:54 <mauke> you need to supply an initial value at the end because that's what the huge composed transformer is called with
12:23:20 <newsham> > runState (do { x <- get; put (x+1); return (x+2) }) 3
12:23:21 <oasisbot>  (5,4)
12:25:09 <mauke> > (\s -> let (x, s') = (s, s) in let (_, s'') = ((), x+1) in (x+2, s'')) 3
12:25:10 <oasisbot>  (5,4)
12:26:21 <oerjan> laz0r: btw as far as i can see you don't actually use the "ordinary" return value from your monad.  You could just as well have made your types Label () instead of Label Dot.
12:26:40 <mauke> .oO( execState )
12:27:09 <laz0r> oerjan, yes, thats true
12:28:00 <laz0r> is that actually a 'good' way of doing this? i wonder...
12:28:15 <slowriot> how do you do negative literals?
12:28:19 <oerjan> i am wondering if monads are slightly overkill here
12:28:24 <slowriot> -2.0 is getting parsed as (- 2.0)
12:28:50 <laz0r> oerjan, ok, but i wanted to check out monads, quite desperatly
12:29:30 <oerjan> if you don't have use for a return value from a monad, then it is certainly good to make it ()
12:29:40 <laz0r> i might have done this by just 'passing on' the dot datastructure i think
12:29:42 <Cale> slowriot: (-2.0) is (negate 2.0)
12:29:50 <slowriot> okay
12:29:53 <slowriot> thanks
12:31:03 <oerjan> indeed
12:32:45 <oerjan> one change i would make: i would make the appendChildren [x] case into appendChild x, and then use appendChildren l = mapM_ appendChild l
12:33:43 <olsner> a hylomorphism is a fold of an unfold?
12:34:26 <vincenz> yes
12:35:09 <laz0r> oerjan, any technical reasons for that change?
12:35:10 <olsner> (reading the Functional programming with Bananas etc paper)
12:35:40 <laz0r> or is it just the 'coding style' which you would prefer?
12:35:55 <oerjan> laz0r: well, letting higher-order functions do the work
12:36:03 <oerjan> right
12:36:34 <fasta> Does GHC actually care whether I use foldr or my_foldr?
12:36:54 <SamB> fasta: yeah... it has RULES that apply only to foldr
12:37:18 <fasta> SamB: see function equivalence problem, I guess, right?
12:37:31 <SamB> fasta: something like that ;-)
12:38:33 <fasta> And remember: don't use recursion, since it can blow your stack!!!! A highly informed piece of Reddit told me that, so it must be true!!!!!
12:39:01 <fasta> That's also bad for security, and we don't want that, now, do we?!!?!
12:39:06 <SamB> fasta: I don't think haskell implementations are allowed to blow the stack
12:39:23 <fasta> SamB: heh, outside the spec ;)
12:39:49 <fasta> GHC blowing a stack should be bug nr 1, I guess.
12:40:03 <oerjan> > foldr (+) [1..1000000]
12:40:04 <oasisbot>   add an instance declaration for (Num [t])
12:40:08 <fasta> well "overflow"
12:40:12 <oerjan> > foldr (+) 0 [1..1000000]
12:40:13 <oasisbot>  Excuption: stack overflow
12:40:25 <oerjan> Exc*u*ption? :)
12:40:27 <mauke> > error ""
12:40:28 <oasisbot>  Excuption:
12:40:29 <fasta> I am not sure what the formal definition of "blowing the stack" is, but I think the same.
12:41:05 <SamB> the formal definition is probably like "exceeding the alloted stack area"
12:41:37 <SamB> of course, that lacks googobs of context...
12:42:04 <olsner> @help remember
12:42:04 <oasisbot> quote <nick>
12:42:04 <oasisbot> remember <nick> <quote>
12:42:04 <oasisbot> Quote somebody, a random person, or save a memorable quote
12:42:12 <fasta> Is that more than a google?
12:42:20 <fasta> er googol
12:42:40 <SamB> maybe I should say that they are probably not allowed to blow the stack for terminating expressions?
12:42:59 <olsner> @remember oasisbot Excuption:
12:42:59 <oasisbot> Not enough privileges
12:43:17 <mauke> @quite
12:43:17 <oasisbot> Maybe you meant: quit quote
12:43:32 <vincenz> olsner: Oh that's a small change I made
12:43:32 <shapr> @quote
12:43:32 <oasisbot> VirginiaCurry says: "You know, Haskell actually never liked the name Haskell." -- Virgina Curry (Haskell B. Curry's widow)
12:43:37 <shapr> lambdabot: @hello
12:43:38 <SamB> however, I'm fairly certain that Haskell implementations are not allowed to run out of memory either
12:43:42 <shapr> @seen dons
12:43:42 <oasisbot> dons is in #haskell. I don't know when dons last spoke.
12:43:44 <shapr> aww
12:43:44 <vincenz> olsner: I was testing plugs so I changed Exception to Excuption
12:44:02 <olsner> @seen lambdabot
12:44:02 <oasisbot> lambdabot is in #oasis and #haskell. I don't know when lambdabot last spoke.
12:44:10 <fasta> SamB: so, you are saying GHC needs a grey goo module.
12:44:18 <fasta> SamB: I wonder when that comes out.
12:44:23 <SamB> no!
12:44:39 <vincenz> @bot
12:44:39 <oasisbot> :)
12:44:40 <SamB> I'm saying that it's nearly impossible to implement Haskell in a 100% correct manner
12:44:48 <vincenz> @quote oelg
12:44:48 <oasisbot> No quotes match. Have you considered trying to match wits with a rutabaga?
12:44:52 <vincenz> @quote oleg
12:44:53 <oasisbot> Pseudonym says: What was considered 100 milli-Olegs of type hackery five years ago is standard operating procedure these days
12:44:58 <vincenz> @quote imp.*oleg
12:44:59 <oasisbot> No quotes match. Where did you learn to type?
12:44:59 <olsner> not in ImHaskell, Infinite Memory Haskell
12:45:02 <vincenz> @quote import oleg
12:45:02 <oasisbot> No quotes for this person. That's something I cannot allow to happen.
12:45:04 <vincenz> hmm
12:45:07 <vincenz> @quote vincenz
12:45:07 <oasisbot> vincenz says: Binkley: the sex is all in the operational semantics, denotational semantics only deals with love
12:45:12 <vincenz> the quote database is out of date
12:45:21 <olsner> that version will also solve the halting problem in infinite time
12:45:51 <SamB> to implement Haskell, you must use a machine capable of aquiring more computational resources in a reliable way, and of extending the address space in the middle of the computation
12:46:03 <vincenz> welcome to virtual memory
12:46:15 <fasta> vincenz: no, you need grey goo.
12:46:26 <SamB> does gray goo fulfill these requirements?
12:46:30 <olsner> grey goo?
12:46:30 <SamB> what is gray goo?
12:46:42 <mauke> out of control nanomachines
12:47:02 <oerjan> you need the ability to create new big bang singularities.
12:47:02 <olsner> then haskell could truly take over the world!
12:47:02 <vincenz> out of control lambdamachines *cackles*
12:47:28 <mauke> http://en.wikipedia.org/wiki/Grey_goo
12:47:30 <oasisbot> Title: Grey goo - Wikipedia, the free encyclopedia
12:47:34 <fasta> The nano bots had to sprint a whole 2mm recently.
12:48:01 <SamB> no, grey goo is insufficient
12:48:04 <fasta> The ones I need, need to be so smart to build a space craft for themselves.
12:48:07 <vincenz> Imagine if nanobots could harvest energy to turn energy into matter
12:48:12 <fasta> SamB: finite matter?
12:48:12 <SamB> that runs out of resources after consuming earth doesn't it?
12:48:15 <vincenz> then they could feed off the sun until they can invade other planets
12:48:17 <vincenz> then slowly
12:48:19 <vincenz> recharging
12:48:21 <fasta> SamB: no
12:48:24 <vincenz> until they have enough to take over the other stars...
12:49:53 <fasta> Well, probably some mad man is designing one as we speak.
12:50:19 <vincenz> SamB: no, they recharge with solar cells until they have enough energy to create more matter or enough to slowly float away to other constellations
12:50:21 <fasta> Sleep tight ;)
12:50:22 <vincenz> even if the sun died out
12:50:27 <vincenz> given enough time, they could harvest from distant suns
12:50:48 <vincenz> after all they use non-volatile memory, so they can run out of power at any time until they get recharged neough
12:51:28 <fasta> Anyway, such a machine is possible. Building one that doesn't eat _you_ is more difficult.
12:51:50 <vincenz> eat me?
12:51:54 <vincenz> I'll assimilate
12:52:06 <SamB> nobody has explained how they expand the address space while the Haskell program is running
12:52:33 <vincenz> SamB: very carefully
12:53:01 <shapr> @quote
12:53:01 <oasisbot> PaulGraham says: I get the impression that using [Haskell] would feel like reading a novel written by a literary critic.
12:53:23 <fasta> SamB: simply, start at position n , Y, Z in the universe, go one feet left and have address n + 1 there
12:53:46 <vincenz> fasta: one feet?
12:53:52 <fasta> SamB: I am assuming a particular shape of the universe here.
12:53:53 <vincenz> what is the multiple of a feet
12:53:56 <fasta> vincenz: arbitrary
12:54:05 <fasta> vincenz: 1 mm would be fine too
12:54:09 <fasta> vincenz: anything is ok
12:54:17 * vincenz votes for quantumlengths
12:54:31 <fasta> vincenz: sure, since, anything is ok.
12:54:38 <vincenz> if you go smaller, it becomes bigger anyways
12:54:58 <fasta> So, there we have the address space problem solved too.
12:55:09 <fasta> Anything else?
12:55:22 <vincenz> fasta: Volatile?
12:55:28 <SamB> fasta: your machine doesn't sound like it much likes stars
12:55:31 <fasta> vincenz: redundancy
12:55:41 <SamB> also, how do you expand the pointers
12:55:50 <fasta> SamB: "expand pointers"?
12:56:09 <SamB> you were planning on infinitely long pointers?
12:56:44 <mauke> just use a long tape
12:57:05 <SamB> anyway, clearly implementing Haskell is quite impractical
12:57:12 <fasta> SamB: an address would simply be some physical object with a number attached below it
12:57:39 <fasta> SamB: assuming unbounded space in all dimensions, this works.
12:58:14 <fasta> But real grey goo will automatically reconfigure its architecture while it runs.
12:58:30 <fasta> To go around stars, etc.
12:58:34 <glguy> prod
12:58:36 <glguy> ?users
12:58:36 <oasisbot> Maximum users seen in #haskell: 346, currently: 337 (97.4%), active: 12 (3.6%)
12:59:24 * SimonRC puts subtext on te veeeeery iiiiiiinteresting list:  http://subtextual.org/demo1.html
12:59:25 <oasisbot> Title: Subtext demo
12:59:36 <SimonRC> it's ... different
13:00:14 <fasta> I think I saw it, but I put it on my not _that_ interesting list.
13:00:37 <SimonRC> Think "Excel meets self"
13:00:41 <SimonRC> oops
13:00:44 <fasta> Last time I looked there were only toy problems.
13:00:45 <SimonRC> Think "Excel meets Self"
13:00:59 <Cale> I think a few of the opinions of its author are holding it back. The graphical/user interface idea is great, the lack of abstraction sucks.
13:01:00 <SimonRC> yes, but it is a very new thing
13:01:01 <fasta> And toy problems don't count.
13:01:04 <vincenz> subtext = EWW
13:01:13 <vincenz> you can't abstract n subtext
13:01:19 <fasta> SamB: no, it's not new.
13:01:23 <vincenz> seriously, I wonder how much you'd get bogged down
13:01:27 <fasta> SimonRC: no, it's not new.
13:01:32 <fasta> SamB: sorry about that
13:01:38 <vincenz> Cale: excited?
13:01:41 <Cale> If you try doing anything remotely complicated in it, it quickly becomes ridiculously complicated.
13:01:49 <vincenz> lol
13:01:49 <glguy> what is it
13:01:54 <vincenz> "programming suffers from abstraction overload"
13:01:57 <fasta> A bad idea
13:01:58 <SimonRC> The trouble is, my List contains a whole load of crazy stuff that promises to revolutionise the world but is likely to suck in reality
13:02:02 <vincenz> he must really hate DSL
13:02:16 <Cale> vincenz: yeah, he's kind of strange :)
13:02:24 * glguy determines that subtextual.org is a loading graphic
13:02:34 <vincenz> Cale: and the state-threading is seriously verbose
13:02:35 <fasta> glguy: heh
13:02:43 <vincenz> Cale: seriously, I think you get lost in all the pointer crap
13:02:56 <SimonRC> I am glad to report that the IO system of Subtext is even more twisted than monads.
13:03:03 <Cale> vincenz: indeed, you do :)
13:03:14 <glguy> somene provide some background for the people whose DSL isn't fast enough to download this video
13:03:20 <laz0r> is there a list of all existing monads? with their implementation ideally?
13:03:23 <vincenz> glguy: crap
13:03:28 <laz0r> so i could just take a look at them
13:03:38 <bos> @where allaboutmonads
13:03:38 <oasisbot> I know nothing about allaboutmonads.
13:03:40 <vincenz> it's a really poor implementation of a smalltalk kwithout abstractions
13:03:42 <bos> @google all about monads
13:03:43 <fasta> glguy: easy to think it's great, but is crap
13:03:43 <oasisbot> http://www.haskell.org/all_about_monads/html/
13:03:44 <oasisbot> Title: All About Monads
13:03:54 <fasta> glguy: "future work" is to make it work for non-trivial things
13:03:59 <bos> laz0r: see above
13:04:00 <fasta> glguy: we al know that will never help
13:04:05 <fasta> glguy: all*
13:04:09 <laz0r> thanks
13:04:09 <fasta> happen*
13:04:33 <vincenz> Cale: I think this is great for GUI programming :)
13:04:39 * vincenz snickers
13:04:41 <glguy>  and there is nothing new or interesting to be extracted from the approach he takes?
13:04:42 <SimonRC> glguy: Consider how you manipulate numbers in Excel: you see all the intermediates and the input and the output all next to one another....
13:04:47 <vincenz> glguy: no
13:04:59 <Cale> glguy: It's a graphical programming language where you have an expandable tree layout. All computation occurs via copy/reference together with primitive computations.
13:05:16 <SimonRC> glguy: now, do that with a prototype-base system for *everything*, and explicit sharing and non-sharing
13:05:16 <Cale> vincenz: Actually, something like it wouldn't be so bad.
13:05:31 <vincenz> Cale: I know, my snickering was about the fact that "GUI programming" is somewhat of an oxymoron
13:05:41 <vincenz> it's like programming html
13:05:59 <olsner> oh, I saw a post on that subtext thingy on the GCC list (proposing for the nth (n >= 3) time to make GCC into a compile server or something like that)
13:06:05 <vincenz> I wonder how you make new data-types
13:06:13 <Cale> vincenz: It's untyped.
13:06:21 <vincenz> Cale: still, you only have ints and strings
13:06:22 <SimonRC> the only way to re-use things is via the explicit Copy and Link actions that feed new vaules into automatically-snchronised copies of prototype code.
13:06:30 <glguy> heh
13:06:41 * glguy wonders if Johnath Edwards suffers from abstraction overload
13:06:52 <olsner> SimonRC: what's the IO system like in subtext then?
13:06:53 <Cale> vincenz: But of course, you can create some basic template acting as a record type that you copy and use.
13:06:55 <glguy> (rather than programming in general ;) )
13:07:05 <fasta> If I had a 100m^2 screen such a visual programming language would be great.
13:07:15 <SimonRC> olsner: it throws explicit and hypothetical World States around, kinda
13:07:20 <vincenz> Cale: yeah, copy-paste isn't that bad.. especially if it actually forces reuse inside, the little circly things to link though are HORRIBLE
13:07:21 <fasta> But, alas, I have no such screen.
13:07:23 <fasta> Do you?
13:07:34 * glguy does
13:07:34 <SimonRC> and the editing mutation actions are exactly the same as the imperative programming mutation actions
13:07:48 <vincenz> Cale: I don't want to know what it looks like for bigger probgrams... edges all over the place
13:08:09 <fasta> vincenz: that's what your 100m^2 screen is for.
13:08:19 <SimonRC> I would love a spreadsheet that made sharing that easy
13:08:44 <vincenz> "which is possible again, the code is not a text-string, it's a data-structure..."  I wonder what he considers an AST is
13:08:57 <Cale> I would love a Haskell development environment that let me view and operate on the code graphs and watch the reduction.
13:09:04 <vincenz> Cale: that'd be neat
13:09:09 <SimonRC> vincenz: The code is not a tree either, it is a graph, roughly
13:09:18 <vincenz> SimonRC: sure
13:09:33 <Cale> The subtext language is actually not so far from most lazy functional languages, it just has a pretty weak means of abstraction.
13:09:34 <vincenz> Cale: Bbasically he's reinventing some prototype-based language that is really badly formulated and with a poor gui
13:10:01 <SimonRC> from the FAQ: "How will this scale to programs larger than the screen?" "Unknown. Before worrying about programming in the large, there are many issues to resolve first about programming in the small." ....
13:10:07 <Cale> and no type system to speak of
13:10:14 <fasta> SimonRC: see?
13:10:45 <fasta> I wonder what issues there are to resolve for programming in the small?
13:10:57 <shapr> incremental parsers?
13:10:58 <fasta> be resolved*
13:11:15 <fasta> shapr: Uh, they exist already, right?
13:11:32 <fasta> shapr: at least in theory
13:11:35 <shapr> Yeah, but they mostly suck, and are rarely available in standard IDEs.
13:11:45 <shapr> Lots of stuff is available in theory :-)
13:11:52 <shapr> SimonRC: Have you seen Aardappel?
13:11:54 <fasta> shapr: that's a money problem.
13:12:09 <vincenz> HAHA
13:12:10 <SimonRC> actaully, the manipulations preserve syntax-tree validity, so parsers are easy
13:12:17 <SimonRC> shapr: googling now...
13:12:39 <shapr> fasta: Well, if it's not available to me as open source, I don't count it as being available.
13:12:46 <vincenz> "You're probably getting a little dizzy by now, it's good to remember that with practice you can even learn to read pearl."  And this is after he basically just made a function to add two numbers!!
13:12:57 <fasta> shapr: open-source can be bought too.
13:13:00 <vincenz> s/pearl/perl
13:13:03 <shapr> fasta: True that.
13:13:08 <fasta> shapr: it's a bit like HApps.
13:13:15 <shapr> fasta: exactly what I was thinking :-)
13:13:25 <vincenz> Cale: I wonder how dizzy one would get after seeing a compiler 'written' in this language
13:13:42 <SimonRC> Aardappel looks familiar...
13:13:43 <fasta> shapr: Alex * wants to provide some cool service on top of HApps and it is in his interest that the core logic works.
13:13:50 <vincenz> Cale: the issue is he talks too much about "link" and "point" and you completely lose a view of code
13:14:06 <fasta> shapr: the thing on top will probably be so complicated economics tell nobody will do the same.
13:14:22 <fasta> shapr: which is a business plan
13:15:20 <vincenz> Cale: if he wanted to have this all graphical, why does even still use "if" and "else" inistead of using typical diagram flow-graph symbosl
13:16:37 <fasta> Also, free marketing is another reason for open-sourcing part of it, I guess.
13:17:51 <Philippa> vincenz: because he already had text rendering
13:18:02 <Philippa> and because typing symbols is slow
13:18:27 <vincenz> Philippa: it's all just copy paste
13:18:36 <vincenz> drag'n'drop
13:18:52 <vincenz> > let drag'n'drop x y = y x in drag'n'drop 1 id
13:18:52 <oasisbot>  1
13:19:32 <vincenz> I'm surprised you can have ' inside an identifier
13:21:00 <vincenz> Cale: almost like he gets lost explaining his own little example
13:22:26 <shapr> fasta: Even so, no decent incremental parsers that I can see.
13:22:48 <Philippa> vincenz: nope, you label things
13:23:04 <Philippa> the labels aren't "identifiers", they're just comments, but you label them
13:23:10 <fasta> shapr: apparently nobody is interested in them.
13:23:25 <fasta> shapr: otherwise someone would put the $$$ on the table
13:23:27 <vincenz> Philippa: he wants it graphical, plenty of work on that in the past on flow-diagrams
13:23:32 <Philippa> fasta: nope, it's just that they're tricky
13:23:33 <vincenz> Philippa: and they use symbols labels
13:23:33 <fasta> would have *
13:23:46 <fasta> Philippa: tricky to implement?
13:23:56 <Philippa> tricky to even start thinking about adequately
13:23:59 <fasta> Philippa: or do not fit the problem domain after all?
13:24:13 <Philippa> at least if you want to have tolerable performance
13:24:38 <fasta> Philippa: if someone has described precisely how such an algorithm works, one can implement it.
13:24:47 <fasta> Philippa: if nobody did, the theory is not there.
13:24:55 <fasta> Philippa: are you suggesting the theory is not there?
13:25:08 <SimonRC> Philippa: i am glad I am not the only one who seems to "get" it
13:25:20 <Philippa> I'm suggesting that the theory for a sufficiently wide class of languages isn't there
13:25:39 <monochrom> What is being discussed?
13:25:41 <Philippa> SimonRC: Subtext? I got it from the demo vid, I just don't want to try using it
13:25:50 <fasta> Philippa: Haskell is inherently inefficient to parse
13:26:00 <vincenz> fasta: so is english
13:26:07 <fasta> Philippa: so, you could make something that works optimally, but it would still be slow.
13:26:31 <olsner> C++ is probably worse than haskell though
13:26:36 <fasta> vincenz: people expect more from programming tools than from English - Swahili translators
13:26:37 <Philippa> fasta: there's slow and there's slow
13:26:39 <Philippa> 'lo Binkley
13:26:45 <monochrom> Forget parsing. Type inference is exponential or worse.
13:26:48 <Binkley> hi philippa
13:27:06 <SimonRC> Subtext might be an improvement for programmers who have never even *seen* a REPL before...
13:27:13 <fasta> monochrom: yes, that is surely a problem too.
13:27:15 <vincenz> SimonRC: just give them scratch
13:27:22 <vincenz> drag-n-drop all you want, and much cleaner
13:27:24 <fasta> monochrom: something I ignore currently
13:27:36 * SimonRC looks that up too
13:27:39 <monochrom> I like it. It means the type system is very rich.
13:28:01 <SimonRC> Vulpyne: where is "scratch"?
13:28:15 <Philippa> monochrom: FUD. HM's only exponential in one rather unlikely case and behaves linearly otherwise
13:28:17 <fasta> SimonRC: scratch at MIT
13:28:34 <fasta> SimonRC: written in Squeak
13:29:37 <SimonRC> Squeak tends to allow frameworks that allow the young to produce spectacular things quickly
13:29:42 <monochrom> Philippa: right, I do not mean to say it's a problem. I mean to say that all interesting and desirable things in the world are at least exponential, so let's bite the bullet.
13:29:58 <Philippa> and I mean to say your motivation for that's suspect
13:30:23 <Philippa> and no, I'm not happy with parsing being exponential in source length!
13:30:44 <monochrom> It may be just unlikely cases again.
13:31:02 <fasta> But someone somewhere will get these cases.
13:31:14 <fasta> Is it exponential or NP-complete?
13:32:13 <mrd> HM?
13:32:15 <pbx> Hello all. This is a bit of a long-shot, but I'm working through exercises in Hutton's book and I need some kind of mental push on 5.7.5. For those without the book handy, the problem in a nutshell is, rewrite [(x,y) | x <- [1,2,3], y <- [4,5,6]] "using two comprehensions with single generators", using concat and nesting one comp within the other.
13:32:15 <Philippa> monochrom: we're talking about incremental parsing. It needs a fair amount of exploration to get it to behave itself properly even in most cases
13:32:23 <mrd> HM is pspace-complete. i think.
13:33:59 <mrd> pbx: by nested he means [   [  ... | ... ]  | ... ]
13:34:18 <pbx> mrd: OK, that's helpful.
13:34:26 <mrd> that will produce a list of lists, hence the use of concat.
13:35:20 <mattam> Philippa: it seems to work already quite well in the top-down case, as Epigram and Agda demonstrate.
13:35:25 <fasta> > join [[]]]
13:35:26 <oasisbot>  Parse error
13:35:32 <fasta> > join [[]]
13:35:33 <oasisbot>  []
13:35:35 <mrd> the original example is the cartesian product of the two lists, which is usually expressed using "nested-loops" anyhow
13:35:47 <pbx> mrd: Thanks very much, that got me through :)
13:35:57 <Liskni_si> @src join
13:35:57 <oasisbot> join x =  x >>= id
13:36:00 <olsner> > sequence [[1,2,3],[4,5,6]]
13:36:01 <oasisbot>  [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
13:36:45 <mattam> From what I know, Epigram's implementation uses a zipper and was usable (i'm not talking about the 2d thing).
13:37:27 * EvilTerran thinks... for the list monad, join = concat, right?
13:37:45 <monochrom> Yes.
13:38:01 <Liskni_si> it's concat . map id, right?
13:38:09 <monochrom> No.
13:38:20 <Liskni_si> why not?
13:38:23 <pbx> I think my hangup was not letting myself write the inner comp that way because it was obviously incomplete -- whereas I should have been looking at it from outermost in.
13:38:23 <monochrom> Yes.
13:38:26 <EvilTerran> @src [] (>>=)
13:38:26 <oasisbot> m >>= k     = foldr ((++) . k) [] m
13:38:35 <EvilTerran> @src concatMap
13:38:36 <oasisbot> concatMap f = foldr ((++) . f) []
13:39:12 <EvilTerran> so (>>=) = flip concatMap, by my reckoning.
13:39:16 <monochrom> Yes.
13:39:30 <oerjan> map id = id
13:39:45 <pbx> Usually it takes a little longer for my head to implode when I visit this channel.
13:39:48 <EvilTerran> well, map id = id :: forall a. [a] -> [a] -- :P
13:40:12 <monochrom> Yes, it took me a while to simplify map id.
13:40:22 <mrd> much ado about id
13:40:32 <Jaak> > let f `on` g = \x y -> (g x) `f` (g y) in maximumBy (compare `on` snd) . map (id &&& sum) . concatMap (tail . inits) . takeWhile (not . null) . iterate tail $ [-1, 2, 5, -1, 3, -2, 1]
13:40:33 <oasisbot>  ([2,5,-1,3],9)
13:42:45 <oerjan> > comparing
13:42:45 <oasisbot>  Add a type signature
13:42:52 <fmardini> a noob needing help, i just baught SOE and i am trying to get started, i am on osx, and i installed hugs using port, I went on SOE's site and downloaded graphics library but when i do make -C lib/x11 i get ERROR "./Xlib_StdDIS.hs" - Can't find imported module "IOExts"
13:42:59 <Jaak> or, right. comparing
13:43:06 <fmardini> so how can i get this module
13:43:50 <bos> fmardini: don't use it.
13:44:13 <fmardini> bos: what can i use then
13:44:17 <bos> fmardini: there's a module named Graphics.SOE which you should use
13:45:06 <bos> http://haskell.org/ghc/docs/latest/html/libraries/HGL/Graphics-SOE.html
13:45:07 <oasisbot> http://tinyurl.com/ymovqo
13:45:50 <Cale> fmardini: are you using GHC? It comes with the SOE lib. Maybe Hugs does too now, since they share libs.
13:46:16 <fmardini> thanks, yeah i have ghc installed
13:46:35 <fmardini> one more question, in interactive hugs when i say import xxx
13:46:39 <fmardini> it complains
13:46:40 <fmardini> http://haskell.org/ghc/docs/latest/html/libraries/HGL/Graphics-SOE.html
13:46:41 <oasisbot> http://tinyurl.com/ymovqo
13:46:48 <fmardini> unexpected keyword "import"
13:47:05 <Cale> fmardini: Right, because hugs wants expressions or its own commands
13:47:14 <Cale> :also ModuleName
13:47:17 <Cale> will import a module
13:47:23 <Cale> (from the hugs commandline)
13:47:37 <fmardini> Cale: thanks
13:47:51 <oerjan> there was just a question on haskell-cafe where someone couldn't find Graphics.SOE
13:47:52 <Cale> In GHCi, that would be :m + ModuleName
13:48:19 <fmardini> oerjan: i will go check it out
13:48:44 <fmardini> Cale: thanks but when i try to import IOExts i get can't find module
13:48:55 <fmardini> coming from a ruby background is there something similar to gem
13:49:21 <Cale> I'm not sure what IOExts is supposed to have in it -- what does the book want to import it for?
13:49:21 <olsner> why does oasisbot not respond to private messages?
13:49:53 <fmardini> no the make script calls a file that imports it
13:49:58 <Cale> oh, hmm
13:50:16 <Cale> The make script for which stuff?
13:50:57 <fmardini> for graphics lib, right from haskell.org/soe/software.htm
13:51:24 <Cale> fmardini: You don't have to install that, it's included with hugs ang GHCi now.
13:51:27 <Cale> and*
13:51:33 <Cale> :also Graphics.SOE
13:51:48 <Cale> and it should come up
13:51:55 <bluestorm_> hm
13:51:59 <Cale> (or import Graphics.SOE from a haskell script)
13:52:08 <bluestorm_> i read a funny papers some time ago
13:52:20 <fmardini> Hugs> :also Graphics.SOE
13:52:21 <fmardini> ERROR "/opt/local/lib/hugs/packages/HGL/Graphics/HGL/Internals/Types.hs" - Can't find imported module "Graphics.X11.Xlib"
13:52:25 <bluestorm_> about a bijection between binary trees and seven-uplets of binary trees
13:52:36 <Cale> fmardini: ah, hmm...
13:52:42 <bluestorm_> would you remember it, or have the url ?
13:53:10 <Cale> http://citeseer.ist.psu.edu/244533.html
13:53:11 <oasisbot> Title: Seven Trees in One (ResearchIndex)
13:53:14 <bluestorm_> i think i started with a haskeller considerations about structural and surprising theorems
13:53:14 <bluestorm_> hm
13:53:24 <bluestorm_> hey
13:53:30 <bluestorm_> that was this one !
13:53:36 <bluestorm_> thanks, Cale
13:53:44 <Cale> bluestorm_: no problem
13:54:28 <fmardini> btw guys, why is soe page not up to date?
13:54:31 <Cale> fmardini: Unfortunately, I don't have a mac to try it out on. You have GHC installed? Try :m + Graphics.SOE from in ghci
13:54:34 <Cale> and see if that works
13:55:13 <fmardini> Cale: Prelude> :m + Graphics.SOE
13:55:13 <fmardini> Could not find module `Graphics.SOE':
13:55:13 <fmardini>   Use -v to see a list of the files searched for.
13:55:15 <fmardini> :(
13:55:33 <Cale> fmardini: that's odd. Which GHC package do you have installed?
13:55:56 <fmardini> i installed it using port as well, its 6.6
13:56:06 <fmardini> do u recommend compiling from source
13:56:29 <fasta> fmardini: hi, u is not a word
13:56:54 <Cale> fmardini: I try to avoid it
13:57:07 <fmardini> or i could try all this later on my ubuntu desktop
13:57:28 <pbx> fmardini: There's a binary out there as well. That's what I use...
13:57:29 <Cale> There are some binaries on the GHC download page you might try
13:57:32 <hpaste>  ideal-hyip.admi pasted "ideal-hyip.admin" at http://hpaste.org/1741
13:57:43 <Cale> http://www.haskell.org/ghc/dist/6.6.1/ghc-6.6.1-powerpc-apple-darwin.tar.bz2
13:57:44 <oasisbot> http://tinyurl.com/2dx4qd
13:57:55 <olsner> my GHC installation (installed with port on mac os x) has Graphics.SOE
13:58:44 <fmardini> port install ghc took a very long time and i don't think i want to try it again now
13:58:53 <fmardini> i will try the binary
13:59:09 <Cale> I wonder if doing something to randomise the names of the form fields would help prevent hpaste spam.
13:59:14 <erider> when is there going to be a gui interface for haskell? something like Squeak
13:59:26 <fasta> Uhm, why is allM not in the standard libraries?
13:59:42 <fasta> My "Util" module is 450 lines long now.
13:59:53 <fasta> All that stuff should be in the standard libs already.
14:00:18 <monochrom> When the ice caps melt.
14:00:23 <fasta> Cale: no, that doesn't help.
14:00:53 <shachaf> Where is lambdabot?
14:00:57 <Cale> erider: Well, there are some preliminary things along those lines. Not really fully usable for anything serious. Check out vital, perhaps
14:01:53 <byorgey> > let lambdabot = repeat 'z' in lambdabot
14:01:56 <oasisbot>  "zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz...
14:02:35 <shachaf> What happened to lambdabot?
14:03:08 <byorgey> lambdabot seems to be taking a well-deserved nap.
14:03:56 <byorgey> @localtime dons
14:03:58 <oasisbot> Local time for dons is Wed Jul 18 07:03:08 2007
14:07:28 <pbx> Re hpaste spam: how about having the "announce" checkbox default to off?
14:07:55 <pbx> IME the spammers don't do a lot of checking up, they just spew stuff into available forms en masse and hope for the best.
14:08:29 <olsner> >  (maximumBy (compare `on` snd) . map (id &&& sum) . (tails =<<) . inits) [-1, 2, 5, -1, 3, -2, 1]
14:08:30 <oasisbot>   Not in scope: `on'
14:08:47 <slava> can you have a language which is not turing complete, and for which the halting problem cannot be solved?
14:09:22 <slava> or do all sub-turing languages have decision proceudres?
14:09:26 <olsner> @let f `on` g = \x y -> (g x) `f` (g y)
14:09:28 <oasisbot> Defined.
14:09:33 <olsner> >  (maximumBy (compare `on` snd) . map (id &&& sum) . (tails =<<) . inits) [-1, 2, 5, -1, 3, -2, 1]
14:09:34 <oasisbot>  ([2,5,-1,3],9)
14:09:55 <mrd> the halting problem is semi-decidable-complete?
14:09:59 <glguy> use a dynamic programing approach, solve this in O(n) time
14:10:03 <glguy> one pass please :)
14:10:05 <Cale> slava: I'd be surprised if you couldn't.
14:10:31 <slava> Cale: can i describe a simple language i'm trying to find a decision procedure for? (or show that none exists)
14:10:48 <Cale> sure
14:10:54 <edwardk> slava: well, you can have languages that are hard to describe so are practically hard to solve, i.e. you don't know if they are turing complete. =)
14:11:12 <slava> Cale: are you familiar with joy?
14:11:16 <slava> this is a joy subset
14:11:20 <slava> only 3 words
14:11:22 <edwardk> or which lack deterministic behavior and so may not halt, but still can't perform arbitrary computation
14:11:55 <edwardk> slava: also, the #esoteric folks gobble this sort of thing up.
14:12:05 <fasta> slava: http://en.wikipedia.org/wiki/Chomsky_hierarchy
14:12:06 <oasisbot> Title: Chomsky hierarchy - Wikipedia, the free encyclopedia
14:12:07 <Cale> slava: Well, not terribly familiar, but I can try. :)
14:12:09 <fasta> slava: there is your answer.
14:12:31 <olsner> glguy: dynamic!? but haskell is a static language! :P
14:12:47 <slava> Cale: 'pop' removes the top of the stack, 'over' brings a copy of the second stack item to the top (a b -> a b a), 'dip' unquotes the quotation underneath the top of the stack
14:12:49 <edwardk> since pretty much every language they use is maybe-sorta-kinda-possibly-turing-complete-but-they-aren't-sure =)
14:13:05 <slava> Cale: apart from words, the only other terms in the language are quotations containing words and more quotations
14:13:40 <oerjan> i don't see how the Chomsky hierarchy is relevant.
14:13:50 <Cale> oerjan: neither do I
14:13:56 <edwardk> slava: that sounds like one of wolfram's machines actually. in fact there was a similar problem from the 1940s. lemme see if i can find it.
14:13:59 <oerjan> (all but the first is decidable)
14:14:09 <slava> edwardk: you can express any stack permutation with this machine
14:14:10 <monochrom> How do you construct quotations?
14:14:13 <slava> you can't
14:14:17 <slava> that's what makes it less than turing complete
14:14:26 <slava> if you add 'cons', you can express S and K
14:14:29 <olsner> @pl (\f x -> f x x)
14:14:29 <oasisbot> join
14:14:42 <fasta> Are there any languages that do not fit in any of the Chromsky levels?
14:14:51 <fasta> I think not.
14:14:56 <Cale> slava: So any reduction step will either leave the number of quotations the same, or reduce it by one. (including quotations inside other quotations)
14:15:17 <mrd> chomsky "levels" are kinda broad though
14:15:30 <fasta> So.... it is pretty related.
14:15:43 <fasta> Since type 1 grammars are decidable
14:15:44 <edwardk> so the question then is how long can you run before you run until you have to 'burn' a quotation, if thats bounded, then you halt, no?
14:15:45 <slava> Cale: you can express non-terminating programs with this language
14:15:52 <fasta> Answering slava's question.
14:16:00 <Excedrin> fasta: yes, there are
14:16:03 <edwardk> because quotations can have quotations in them?
14:16:10 <Cale> oh, I see
14:16:25 <fasta> Excedrin: do tell
14:16:37 <Cale> Because you can copy quotations with over
14:17:05 <fasta> Excedrin: ?
14:17:15 <Excedrin> fasta: http://www.newyorker.com/reporting/2007/04/16/070416fa_fact_colapinto?cu
14:17:17 <oasisbot> Title: A Reporter at Large: The Interpreter: Reporting & Essays: The New Yorker, http://tinyurl.com/26vxyz
14:17:21 <Excedrin> ack, paste broken
14:17:32 <edwardk> the problem is there is no mechanism given there for introducing the initial set of quotations or is it the 'initial quotation set' plus the 'stack' that acts as your machine's starting state?
14:17:52 <slava> the initial stack is empty
14:18:07 <fasta> Excedrin: omg, why the hell did you send me there?
14:18:07 <sjanssen> what happens if an asynchronous exception is sent to a thread blocked on an empty MVar?
14:18:08 <Excedrin> oh it works anyway :)
14:18:14 <fasta> Excedrin: I read that article already
14:18:23 <Excedrin> alright, then why did you ask that question?
14:18:24 <fasta> Excedrin: and it has _nothing_ to do with what we are talking about
14:18:50 <slava> Cale: if you define three abbreviations,
14:18:52 <slava> dup == [] over [pop] dip
14:18:52 <slava> swap == over [[pop] dip] dip
14:18:52 <slava> i == [] swap dip pop
14:18:56 <slava> then [dup i] dup i does not terminate
14:18:57 <Cale> Excedrin: That is a good article though :)
14:19:08 <slava> because it reduces to [dup i] [dup i] i, [dup i] dup i, and so on
14:19:21 <edwardk> yeah (SII) (SII)
14:19:24 <fasta> Excedrin: if the relation is so "obvious" to you, please elaborate.
14:19:32 <edwardk> more or less
14:19:36 <fasta> Excedrin: I am sure there is no such relation, however.
14:20:12 <slava> edwardk: yup
14:21:00 <fasta> slava: did you read the article?
14:21:04 <slava> yes
14:27:39 <Binkley> ?yow
14:27:40 <oasisbot> Couldn't find fortune file
14:27:45 <Binkley> ;.-(
14:28:01 <glguy> solve = uncurry max . foldr aux (0, 0)
14:28:02 <glguy>   where aux x (current, best) = (max 0 current', max best current)
14:28:02 <glguy>           where current' = current + x
14:28:55 <glguy> or replace uncurry max with snd, and current with current' in the snd part of the result tuple
14:46:49 <cdsmith> How do I answer this request from someone learning Haskell?  Quote: I assume the Haskell team has this somewhere, but it is always good to have a place where people can post ``Hey look at this cool way of doing this'' type of code.  That would be cool to look at.
14:47:14 <Binkley> haskell-cafe or the wiki?
14:47:16 <monochrom> try haskell-cafe first
14:47:29 <Cale> there's http://www.haskell.org/haskellwiki/Example_code
14:47:30 <oasisbot> Title: Example code - HaskellWiki
14:47:35 <Botje> we could start a page "elegant uses of haskell" on the wiki
14:47:47 <Cale> http://haskell.org/haskellwiki/Gallery
14:47:48 <oasisbot> Title: Gallery - HaskellWiki
14:48:18 <Cale> and well, there have been lots of blog articles
14:48:24 <monochrom> How to distinguish Example_code from Gallery?
14:48:31 <Cale> I don't know
14:49:01 <Cale> I think perhaps it's a bit of mess from when things were imported from the old wiki
14:49:12 <nominolo> @info catMaybes
14:49:12 <oasisbot> catMaybes
14:49:18 <nominolo> :t catMaybes
14:49:19 <Cale> :t catMaybes
14:49:22 <oasisbot> forall a. [Maybe a] -> [a]
14:49:22 <oasisbot> forall a. [Maybe a] -> [a]
14:49:50 <nominolo> @hoogle catMaybes
14:49:51 <oasisbot> Maybe.catMaybes :: [Maybe a] -> [a]
14:51:12 <nominolo> fmap (1+) (Just 3)
14:51:20 <nominolo> > fmap (1+) (Just 3)
14:51:21 <oasisbot>  Just 4
14:51:31 <cdsmith> Thanks.  Those are some neat wiki pages.
14:51:48 <cdsmith> Cale, Botje, Binkley, etc: ^^^
14:55:37 <nominolo> @pl \f (l, a) (l', a') -> (l++l', f a a')
14:55:39 <oasisbot> (`ap` snd) . (. fst) . flip flip snd . ((flip . (ap .)) .) . flip flip fst . ((flip . ((.) .)) .) . flip ((.) . flip . (((.) . (,)) .) . (++))
14:55:47 <nominolo> wtf?
14:56:07 <cdsmith> ha!  Yeah, that's a lot simpler. :)
14:56:10 <nominolo> @src (***)
14:56:11 <oasisbot> f *** g = first f >>> second g
14:56:21 <Cale> @src (&&&)
14:56:21 <oasisbot> f &&& g = arr (\b -> (b,b)) >>> f *** g
14:56:42 <nominolo> :t (++) *** (+)
14:56:44 <oasisbot> forall a a1. (Num a1) => ([a], a1) -> ([a] -> [a], a1 -> a1)
14:58:08 <nominolo> :t (uncurry (++)) *** (uncurry (+))
14:58:09 <oasisbot> forall a a1. (Num a1) => (([a], [a]), (a1, a1)) -> ([a], a1)
14:58:27 <Cale> heh
14:58:46 <oerjan> o_O
14:58:54 <nominolo> i guess i'll keep the pointed form
14:59:32 <Cale> I'm a little surprised that there isn't some arrow combinator that does that
15:00:08 <nominolo> a zap over tuples could work
15:00:28 <oerjan> :t zap
15:00:29 <oasisbot> Not in scope: `zap'
15:00:30 <nominolo> where zap is a generalized zip (taking a list of functions)
15:00:55 <nominolo> @where applicative
15:00:55 <oasisbot> I know nothing about applicative.
15:01:49 <nominolo> zap (f:fs) (a:as) (b:bs) = f a b : zap fs as bs
15:02:05 <nominolo> then zip f = zap (repeat f)
15:02:08 <mrd> that new yorker article is a bit screwy
15:02:21 <chessguy> @source Data.Applicative
15:02:21 <oasisbot> Data.Applicative not available
15:02:28 <mrd> is the guy trying to assert that pirada is an undecidable language?
15:02:35 <oerjan> :t zipWith3 ($)
15:02:36 <oasisbot> forall a c d. [a -> c -> d] -> [a] -> [c] -> [d]
15:02:39 <chessguy> @source Control.Applicative
15:02:39 <oasisbot> Control.Applicative not available
15:02:48 <chessguy> @doc Control.Applicative
15:02:48 <oasisbot> Control.Applicative not available
15:02:51 * chessguy sighs
15:02:59 <chessguy> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Applicative.html
15:02:59 <oasisbot> http://tinyurl.com/yyo64c
15:03:07 <chessguy> @where+ applicative http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Applicative.html
15:03:07 <oasisbot> Done.
15:03:15 <chessguy> oh wtf
15:03:18 <chessguy> where is lambdabot?
15:03:21 <chessguy> no wonder
15:03:24 <nominolo> dead
15:03:31 <nominolo> asleep
15:03:31 <chessguy> ?uptime
15:03:32 <oasisbot> uptime: 6h 8m 57s, longest uptime: 9d 2h 23m 6s
15:03:40 <chessguy> @seen lambdabot
15:03:40 <oasisbot> I saw lambdabot leaving #oasis and #haskell 1h 29m 37s ago, and .
15:04:01 <cdsmith> and?  and what?
15:04:01 <nominolo> what's #oasis?
15:04:13 <chessguy> @topic-tell oasis
15:04:13 <oasisbot> Do not know that channel
15:04:16 <chessguy> @topic-tell #oasis
15:04:16 <oasisbot> Discussion channel for the 2007 ICFP Contest | Logs are @: http://www.cse.unsw.edu.au/~dons/irc/oasis/ | Countdown for the 2007 ICFP Contest: http://www.kingsrook.com/icfp/countdown.html | Zenny
15:04:16 <oasisbot> channel about programming languages where *semantics is the issue and *syntax* is ignored | Webpage for Lazy Bottoms Team (Contact vincenz to update): http://homes.esat.kuleuven.ac.be/~cpoucet/
15:04:16 <oasisbot> icfp2007.html
15:04:55 <nominolo> there's a * missing
15:05:10 <Binkley> well, it does say syntax is ignored :-)
15:05:20 <nominolo> lol
15:13:35 <shapr> hi Souwh
15:13:53 <Souwh> Hello shapr
15:14:18 <andersca> hej shapr!
15:17:19 <Cale> :t uncurry (***) . uncurry (***) ((++),?f)
15:17:20 <oasisbot> forall b' c' b'1 a. (?f::b'1 -> b' -> c') => ([a], b'1) -> ([a], b') -> ([a], c')
15:17:41 <Cale> there it is :)
15:18:49 <chessguy> @get-slap
15:18:49 <oasisbot> shapr!!
15:20:53 <hpaste>  glguy pasted "updated max subarray" at http://hpaste.org/1742
15:21:13 <oerjan> :t (uncurry (***).) . uncurry (***)
15:21:14 <oasisbot> forall (a :: * -> * -> *) b c b' c' b1 b'1. (Arrow a) => (b1 -> a b c, b'1 -> a b' c') -> (b1, b'1) -> a (b, b') (c, c')
15:27:29 <shapr> hej andersca!
15:31:08 <nominolo> @seen syntaxfree
15:31:09 <oasisbot> I haven't seen syntaxfree.
15:37:48 * shapr misses lambdabot
15:39:22 <shapr> @users
15:39:23 <oasisbot> Maximum users seen in #haskell: 346, currently: 329 (95.1%), active: 10 (3.0%)
15:39:36 * shapr hugs Souwh 
15:40:19 * shapr hugs bringert 
15:40:23 * shapr hugs pesco 
15:40:28 <shapr> Hugs for everyone who wants one!
15:40:35 * shapr hugs SyntaxNinja 
15:40:47 * Souwh escapes from hug
15:40:55 * shapr hugs ddarius 
15:40:58 <andersca> shapr: I should upload some eurohaskell images to facebook!
15:41:02 <shapr> Yes!
15:41:17 <shapr> Are you a member of #haskell ?
15:41:26 <bringert> shapr: what about ghc? can we have that too?
15:41:29 <andersca> shapr: I am
15:41:50 <SamB> which one?
15:42:15 * SamB is experiencing heavy swapping and can't look at facebook at the moment
15:42:31 <nominolo> why the hug-mania?
15:42:32 <shapr> bringert: Sure, free downloads at haskell.org/ghc !
15:42:46 <bringert> sweet
15:42:48 <shapr> nominolo: Eftersom jag r snll!
15:42:57 <bringert> haskell warez
15:43:22 <nominolo> jaha
15:43:24 <SamB> bringert: it's not warez unless it has pre-publication code in it ;-P
15:43:34 <mcnster> whoa.  330
15:43:40 * shapr has some pre-pub code
15:43:42 <Binkley> ghc is pre-publication
15:43:46 <shapr> y0 mcnster, wassup?
15:43:51 <Binkley> I mean, can you go to Borders and get a book of the sources?
15:43:53 <Binkley> I think not
15:43:54 <mcnster> hi shapr :)
15:44:11 <mcnster> i'm thinking about haskell bindings to Maya...
15:44:18 <shapr> Aztecs?
15:44:30 <bringert> speaking of hugs, years ago there was a poster in the chalmers cs student computer lab building saying something to the effect of "don't do drugs, get high on hugs".
15:44:31 <SamB> Binkley: i mean: code that is discussed in a paper that is about to be published ;-)
15:44:31 <Excedrin> 3d modeling program
15:44:51 <mcnster> hehe.  no the monstrous animation and design suite
15:44:53 <Binkley> It was a poor attempt at humor :-)
15:44:56 <Binkley> bringert: LOL
15:44:58 <andersca> bringert: I remember that
15:45:13 <bringert> I still don't know whether it meant the haskell interpreter, or actual hugs
15:45:13 <SamB> Binkley: which -- mine, or yours?
15:45:18 <Binkley> "Don't do THC, get high on GHC"
15:45:22 <Binkley> SamB: mine
15:45:23 <bringert> haha
15:45:53 <mcnster> uhuh.  thc.  whatever... <big sound of bong hit>
15:45:58 <mcnster> heh
15:46:07 * EvilTerran thinks... a POV-Ray scene transformer written in haskell could be cool.
15:46:34 <EvilTerran> instance Read Scene and Show Scene to generate the appropriate SDL
15:46:34 <mcnster> evil, that would be cool indeed
15:46:35 <SyntaxNinja> thanks shapr!
15:46:39 <SamB> EvilTerran: transformer?
15:47:05 <SamB> wouldn't that need to basically implement POV-Ray's macro language?
15:47:23 <EvilTerran> SamB, convert SDL into Haskell objects, muck about with it, shove it back into SDL. probably not including the macro langauge.
15:47:45 <EvilTerran> alternatively, implement haskell as SDL macros :D
15:47:46 <SamB> what kind of POV-Ray scene doesn't use the macro language?
15:48:05 <EvilTerran> the kind you generate in haskell =P
15:48:10 <SamB> ah.
15:48:28 * EvilTerran has seen some pretty hairy stuff done as SDL macros
15:48:42 <SamB> yes. you can do anything with SDL macros as far as I can tell.
15:49:10 <EvilTerran> well, it's turing-complete, so yes. but that doesn't mean the syntax has to look nice
15:49:59 <EvilTerran> and, iirc, this hairy stuff managed to be pretty elegant to use, it just used some horrifying hacks to get it working
15:50:21 <SamB> so, has anyone written a universal turing machine scene, that renders an animation of the turing machine?
15:50:34 <ddarius> yes
15:50:35 <EvilTerran> being able to express scenes directly as a haskell data structure would be nicer than generating SDL, of course...
15:50:59 <EvilTerran> samB, i made a conway's life scene, and someone's done a turing machine in conway's life, so yeah
15:51:08 <SamB> I've written part of a raytracer that reads scenes in what looks like postscript.
15:51:32 <EvilTerran> (a theoretically perfect TM, at that -- you can have infinite tape in Life)
15:51:36 <SamB> but I didn't figure out how I ought to implement shaders yet
15:51:55 <SamB> EvilTerran: how do you make an infinite tape in life?
15:52:15 <SamB> does it involve an infinite pattern?
15:52:22 <nominolo> just extend it on demand
15:52:35 <SamB> ah. that doesn't sound very easy...
15:52:50 <EvilTerran> well, assuming your representation of Conway's Life is perfect, infinite tape is done by having a c/2 (as fast as possible) puffer leaving a trail of tape behind i
15:52:52 <EvilTerran> t
15:53:18 <EvilTerran> there you go: http://rendell-attic.org/gol/turing_js_r.gif
15:53:35 <SamB> EvilTerran: that sounds like it would waste memory in the host...
15:53:42 <EvilTerran> sorry, the page would be more useful -- http://rendell-attic.org/gol/tm.htm
15:53:42 <oasisbot> Title: A Turing Machine in Conway's Game of Life, extendable to a Universal Turing Mach ...
15:54:48 <EvilTerran> you merely asked if anyone'd done an illustrated TM in POVray. I said yes, citing my conway's life thing as an example. memory consumption is irrelevant ;]
15:55:06 <mcnster> heh
15:55:24 <glguy> Is there a large group of people outside of the 3 people writing on that -cafe thread that thing that there is something wrong with the current haskell community?
15:55:32 <EvilTerran> the conway's life prime filter is a beautiful piece of engineering
15:55:41 <glguy> s/thing/think
15:55:45 <slava> what are they saying about the haskell community, glguy?
15:55:51 <EvilTerran> glguy, i happen to think it's a damn slight better than any other community i've sampled
15:56:00 <SamB> glguy: probably there is something wrong with it
15:56:00 <glguy> yeah, I don't see the big disaster
15:56:19 <ddarius> glguy: no
15:56:20 <nominolo> which thread?
15:56:24 <EvilTerran> but there's always room for improvement. at least until you attain a Socratic Form, anyway. ;]
15:56:29 <SamB> but nothing much comes to mind besides the fact that it is composed of sinful human beings
15:56:39 <glguy> [Haskell-cafe] Maintaining the community
15:56:45 <slava> main issue with the haskell community is that they assume anybody who uses dynamic typing is ignorant of static typing :)
15:56:50 <EvilTerran> *platonic form
15:57:16 <SamB> slava: then why do we go to all this trouble to implement Data.Dynamic?
15:57:39 <ddarius> slava: Most have used dynamically typed language-
15:57:47 <EvilTerran> to prove that, anything they can do, we can do better
15:57:49 <glguy> slava: many are, have you seen all the people that think they need dynamic typing for "exploratory programming"?
15:58:11 <glguy> I hear that over and over on places like reddit
15:58:13 <slava> they'll continue to think that until haskell has a real interactive environment, though
15:58:44 <ddarius> Haskell isn't the only statically typed language.
15:59:27 <LoganCapaldo> it's not?
15:59:30 <LoganCapaldo> dammit
15:59:40 <LoganCapaldo> Why did no one tell me?
15:59:44 * LoganCapaldo weeps
16:01:22 <slava> glguy: i remember you were working on process-stream support for win32 factor, did anything come of that?
16:01:25 <slava> glguy: opening a pipe and all that
16:01:29 <nominolo> hah, Coq is a much better statically typed language!! *flame*
16:02:01 <mcnster> but is it lazy?
16:02:07 <glguy> slava: you are slava_pestov then?
16:02:15 <nominolo> whatever you want it to be
16:02:26 <slava> glguy: yes, and we've talked in #concatenative, and you submitted some patches :)
16:02:27 <glguy> slava: I was going to complain to yo uearlier to stop using his (your) name
16:02:35 <nominolo> but you can't write non-terminating non-co-recursive programs
16:02:46 <mcnster> well then :)
16:02:57 <glguy> slava: no, I didn't get that working. someone else ended up doing some kind of overhaul in the way tha twindows does io
16:03:14 <slava> oh, ok. do you remember the win32 api call to open a pipe?
16:03:24 <glguy> and I haven't been using factor recently because it doesnt work on windows atm
16:03:43 <slava> i believe it does, since nobody reported any problems
16:03:48 <glguy> slava: not specifically, but I do remember that there was a whole MSDN article on exactly how to do it
16:03:52 <slava> ok
16:04:00 <glguy> slava: I tried asking about it in #concatenataive a couple times
16:04:06 <glguy> but no one ever responded
16:04:06 <slava> when was this?
16:04:09 <glguy> so I moved on
16:04:14 <glguy> week or two ago
16:04:17 <slava> i was away
16:04:18 <glguy> 0.89 and HEAD
16:05:07 <slava> glguy: i'll take a look
16:06:03 <glguy> and when I compiled it on my amd64 machine, it locked up my xserver
16:06:09 <glguy> (when I ran it that is)
16:06:14 <glguy> after bootstrapping
16:06:40 <glguy> glad to see you're back. how was your trip? I remember reading on your blog that you left for another country
16:06:45 <glguy> and wouldn't be programming in the meantime
16:06:54 <slava> i went to new zealand for 3 weeks
16:09:55 <slava> glguy: in the logs you say 0.89 crashes during bootstrap but there's actually a binary for windows available
16:10:27 <glguy> slava: the binary goes bonkers on my machine on mouseover events
16:10:37 <glguy> and when typing
16:10:56 <glguy> the autocomplete seems to have some bizare behavior
16:13:29 <mphill22> http://www.haskell.org/haskellwiki/Euler_problems/21_to_30
16:13:30 <oasisbot> Title: Euler problems/21 to 30 - HaskellWiki
16:13:50 <mphill22> can someone run problem 21 and tell me the solution, i dont have a haskell interpreter handy ;o
16:14:28 <glguy> so you could just dump it into Project Euler?
16:14:54 <ddarius> mphill22: Yes you do.
16:14:56 <ddarius> > 3
16:14:58 <oasisbot>  3
16:15:06 <mphill22> if i wanted to steal all the solutions i wouldnt come here asking you guys to compile them for me
16:16:27 <falconair> I am trying to make sense of sigfpe's article on corecursion/codata, is unfold related to corecursion the way fold is related to regular recursion?
16:16:38 <ddarius> Yes.
16:17:26 <falconair> how about codata, the article seems to explain codata as infinite data structures ... but haskell can already do infinited data structures just using data ... no?
16:17:42 <mrd> it mixes the two
16:17:55 <slava> glguy: does your CPU have SSE2?
16:17:57 <pjd> Haskell doesn't make a distinction between data and codata, in this sense
16:17:58 <falconair> you mean haskell's 'data' mixes data adn codata?
16:17:59 <glguy> slava: yes
16:18:09 <slava> glguy: are you sure? did you try the non-sse binary?
16:18:12 <glguy> slava: core2duo
16:18:14 <ddarius> codata does not necessarily mean infinite or even potentially infinite.
16:18:18 <pjd> falconair: have you read the Turner paper he links to, by the way?
16:18:20 <slava> glguy: 32-bit windows?
16:18:21 <pjd> it's pretty accessible
16:18:22 <glguy> yes
16:18:23 <ddarius> codata and data coincide in haskell
16:18:28 <pjd> great read
16:18:39 <mrd> if corecursion is dual to recursion, and codata is dual to data, then what is coffee dual to?
16:18:50 <pjd> cocoffee, obviously
16:18:51 <mrd> i just read the Turner paper today too, it's great
16:19:09 <falconair> pjd: no, i haven't read that, although I started to read "tutorial on co(data) and (co)algebra"...eh, don't remember the actual name
16:19:22 <oerjan> that's a mplicated question.
16:19:28 <pjd> falconair: that's on my to-read list :)
16:20:08 <falconair> according to some papers coalgebra is good for describing concurrent systems...so are the "comonads are good for reactive systems" guys speaking of the same idea?
16:20:20 * EvilTerran boggles
16:20:28 <mphill22> anyone?
16:20:46 <bringert> mrd: how about cocoa?
16:20:54 <slava> glguy: i'll test when i get a chance and get back to you
16:20:56 <mrd> coa from lombia
16:21:06 <EvilTerran> okay, i can grasp comonads (approximately). i'm willing to accept corecursion as a possible concept. but codata? coalgebra? I give up. -.-
16:21:08 <ddarius> comonads and coalgebra are related in the same way monads and algebra are.
16:21:10 <Syzygy-> There was something recently on the archive on using (co)algebras to capture (co)homology using (co)monads - or something like that.
16:21:25 <Syzygy-> I forget the title. But it had an impressive amount of (co)-whatevers listed...
16:21:40 <pjd> EvilTerran: read Turner's paper!  it's great
16:21:47 <mrd> so why are mathematicians prejudiced against cothings?
16:22:06 <EvilTerran> pjd, do you have a link?
16:22:08 <ddarius> EvilTerran: Ever do object oriented programming?
16:22:20 <pjd> EvilTerran: http://www.jucs.org/jucs_10_7/total_functional_programming
16:22:21 <oasisbot> Title: (D. A. Turner) Total Functional Programming
16:22:35 * EvilTerran . o O ( is a comathematician a device for turning theorems into coffee? )
16:22:40 <pjd> also, the sigfpe article in question: http://sigfpe.blogspot.com/2007/07/data-and-codata.html
16:22:41 <oasisbot> Title: A Neighborhood of Infinity: Data and Codata
16:22:47 <falconair> that was an interesting bit of information I read, coalgebra basically defines (idealized) OO!?
16:23:02 <slava> i'm not sure what coalgebras have to do with OO
16:23:03 <oerjan> EvilTerran: no, it's for turning cotheorems into ffee.
16:23:04 <mrd> it helps that i've been doing coq lately, which highlights many of the concepts in that paper
16:23:32 <ddarius> Objects tend to be presented coalgebraically.
16:23:36 <slava> oerjan: it's not clear that the category of cocoffee is isomorphic to ffee
16:23:59 <pjd> EvilTerran: the gist of it is that you can subdivide the concept of "data" into data and codata, with limited operations on each
16:24:35 <ddarius> Calculating Functional Programs also has some good data/codata stuff.
16:24:42 <pjd> such that you can eliminate bottom, and make all functions total
16:24:54 <pjd> (hence the paper title)
16:24:55 <oerjan> slava: bah, it's mpletely coclear.
16:24:56 <ddarius> total/productive
16:25:13 <SamB> EvilTerran: haha comathemetician
16:28:03 <dibblego> ?seen lambdabot
16:28:03 <oasisbot> I saw lambdabot leaving #oasis and #haskell 2h 54m ago, and .
16:28:19 <slava> hi dibblego
16:28:23 <dibblego> hello slava
16:28:51 * shapr mourns the loss of lambdabot
16:28:58 * EvilTerran finishes reading that sigfpe post. wow... that's really rather interesting
16:29:47 <shapr> falconair: Did you ever find out if coalgebra for concurrency is the same as comonads for reactive systems?
16:29:59 <shapr> falconair: I only understand comonads for reactive systems, dunno anything about coalgebra.
16:30:26 <EvilTerran> but what of ncurrency?
16:30:36 * shapr laughs
16:31:19 <pjd> N-currency?  is that like K-algebra?
16:31:26 <falconair> shapr: i didn't get a reply specifically about comonads/reactive systems...but I'll bet they are discussing the same thing.  sigfpe's article mentions comonads, and his description seems similar to what the dataflow guys discuss
16:31:30 <SamB> EvilTerran: is that how you pay for O(n) costs?
16:34:27 <Cale> I suppose to get 'data' in Haskell, you use strictness annotations.
16:34:46 <EvilTerran> or Oleg's compile-time shape enforcement
16:34:46 <cedricshock> I'd like to make a big recursive function that has a time limit on execution, such that when some time is reached it returns the best solution it has found so far. How can I do this. Can I do it in a way that the function doesn't know much about the monad that the time halting condition is coming from?
16:34:57 <Cale> Otherwise, I'm fairly sure you're always getting the greatest fix point.
16:35:52 <Syzygy-> cedricshock: Do you expect every run through the recursion to be costly?
16:35:57 <Cale> cedricshock: Well, you could write an IO wrapper which returns the last element of a list that it can manage to compute.
16:36:17 <SamB> Cale: ???
16:36:19 <Cale> (In the given time frame)
16:36:24 <andersca> shapr: mmm corn!
16:36:34 <Syzygy-> cedricshock: You might just have it keep on returning things, and have a wrapper that either runs out of time and then returns the next computed result, or if there still is time, recurses again
16:36:34 <Cale> SamB: what are those question marks about?
16:36:36 <cedricshock> Syzygy-: Yes, very
16:36:40 <SamB> didn't we have a thread about this on libraries@ anyway?
16:36:45 <SamB> Cale: list?
16:36:52 <Syzygy-> Or if your picky about being finished before, have the wrapper return a cached previous computation.
16:36:54 <Cale> SamB: yeah.
16:37:01 <Syzygy-> NO idea, though, how the wrapper would look.
16:37:09 <pjd> cedricshock: make it compute a list of successive results?
16:37:10 <SamB> Cale: you can write code that does this?
16:37:16 <Cale> Then you write your function such that it emits a list consisting of successively refined solutions.
16:37:28 <pjd> then pull as much of the list as you have time to compute
16:37:42 <SamB> oh...
16:37:45 <Cale> SamB: sure. Its type would be [a] -> IO a
16:37:49 <SamB> I think I'm beginning to see
16:37:57 <cedricshock> Cale, pjd: That's an interesting idea. I'll need to think about it. I have a horrible feeling that the list is going to be huge (It might be the 120000th refinement by the time the timer expires)
16:38:10 <SamB> cedricshock: doesn't matter
16:38:14 <Cale> cedricshock: that's okay so long as the list is properly collected
16:38:24 <cedricshock> The wrapper could probably keep looking further down the list so that all the previous junk is collected.
16:38:30 <pjd> fusion, the universal solution
16:38:45 <pjd> what kind of compution is this?
16:38:53 <oaisfd> can someone do me a big favour and run problem 21 for me http://www.haskell.org/haskellwiki/Euler_problems/21_to_30i dont have access to a haskell interpreter right now
16:38:54 <oasisbot> Title: Euler problems/21 to 30i - HaskellWiki
16:38:57 <SamB> Cale: but the tricky part is writing that function from [a] to IO a
16:39:03 <oaisfd> oops * http://www.haskell.org/haskellwiki/Euler_problems/21_to_30
16:39:04 <oasisbot> Title: Euler problems/21 to 30 - HaskellWiki
16:39:41 <cedricshock> pjd: A greedy-ish depth-first search.
16:40:09 <pjd> of what?
16:40:17 <cedricshock> pjd: Another similar problem would be an iterative deepening search.
16:40:26 <Cale> SamB: It's not *so* bad. It'll just use Control.Exception.evaluate, some timing stuff, and recursion.
16:40:39 <cedricshock> pld: Of states, with an objective and heuristic function.
16:40:43 <Syzygy-> oaisfd: Running....
16:40:49 <pjd> hmm
16:40:49 <Cale> Perhaps slightly more general would be (a -> a) -> a -> IO a
16:40:53 <Syzygy-> See if it ends before I tire and go sleep.
16:41:00 <oaisfd> Syzygy-: thanks mate
16:41:01 <Cale> which applies the supplied function as many times as possible
16:41:09 <SamB> Cale: don't you need two threads and an MVar?
16:41:11 <EvilTerran> Cale, that was what i envisaged initially
16:41:14 <oaisfd> it should only be a few second solution if the person who wrote it isnt an imbecile
16:41:28 <Syzygy-> Then the person probably is an imbecile. It still didn't finish.
16:41:32 <EvilTerran> using two threads and a SampleVar
16:41:43 <SamB> SampleVar?
16:41:44 <Syzygy-> GOA Data.Array> problem_21
16:41:44 <Syzygy-> 31626
16:41:44 <Syzygy-> (53.12 secs, 4033535872 bytes)
16:41:44 <SamB> hmm.
16:41:46 <Cale> SamB: er, I suppose you could.
16:41:55 <Cale> SampleVar would be better, yeah
16:41:56 <SamB> I suppose an MVar is overkill actually
16:41:57 <EvilTerran> @docs Control.Concurrent.SampleVar
16:41:58 <oasisbot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent-SampleVar.html
16:42:03 <oaisfd> Syzygy-: thankyou :)
16:42:09 <SamB> I haven't heeard of SampleVar -- is that IORef in disguise?
16:42:09 <Syzygy-> Now, I sgo sleep!
16:42:18 <oaisfd> goodnight
16:42:26 <Cale> SamB: no, it's like an MVar, but with non-blocking puts.
16:42:28 <cedricshock> Cale: I'm a bit worried about what continuations for an algorithm like this (deep recursion) would look like...
16:42:46 <Cale> (they just overwrite)
16:43:33 <Cale> cedricshock: continuations? Perhaps I don't understand what you mean.
16:44:36 <Cale> You could write the thing in "CPS", by passing in a computation to run on the result after the given time interval
16:45:17 <cedricshock> Cale: I mean the function calls that look like things look like when using continuations... How does the deepest part of the search yield a new value at the outermost function level?
16:45:39 <Cale> By not recursing?
16:45:59 <EvilTerran> cedricshock, could you paste some code?
16:45:59 <cedricshock> Cale: exactly
16:46:13 <EvilTerran> your untimed algorithm or something
16:46:38 <cedricshock> EvilTerran: Nothing to see in the untimed algorithm, it just looks like any old recursive function...
16:47:19 <EvilTerran> could you involve a fix-like function to hijack the attempted recursive call?
16:48:12 <Cale> http://www.haskell.org/haskellwiki/Timing_out_computations -- here's some old code which does it with an MVar. It would probably be cleaner to use a SampleVar.
16:48:12 <oasisbot> Title: Timing out computations - HaskellWiki
16:48:39 <hpaste>  cedricshock pasted "A search algorithm, planned to be rewritten to be more general, allow other interesting things" at http://hpaste.org/1743
16:48:54 <Cale> oh, I suppose it depends on what you're looking for.
16:49:27 <dibblego> ?info Word8
16:49:27 <oasisbot> Word8
16:49:38 <dibblego> bleh
16:49:50 <Cale> dibblego: What are you looking for?
16:49:59 <dibblego> just the qualified module name
16:50:10 <dibblego> got it now, I am lazy :)
16:51:07 <Cale> @docs Word8
16:51:07 <oasisbot> Word8 not available
16:51:14 <Cale> @docs Data.Word
16:51:14 <oasisbot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Word.html
16:51:53 <Cale> @index Word8
16:51:53 <oasisbot> Data.Word, Foreign
16:51:58 <Cale> That's the one :)
16:51:59 <dibblego> ta
16:53:09 <cedricshock> Cale: Just some general class of monad that I can post messages to of type a ought to be able to capture this idea, and some others... I can force my code to go in order (actually I must to do any of these types of things)
16:55:52 <cedricshock> Oh, and a tiny little question: Is there an implementation of a data type that adds a supremum and infimum to an ordinal (not technically a supremum because its not least, just something past the top). I could write this really easily...
16:56:23 <Cale> Oh, actually, that's an interesting idea -- a writer monad using a (value,score) pair monoid, where mappend is essentially "pick the one with maximum score"
16:57:19 <EvilTerran> cedricshock, there isn't, but people seem to suggest it every other day.
16:57:22 <cedricshock> Cale: Ohh, that's even better than my writer with just a value, as it might be parallelizablith.
16:57:33 <Cale> cedricshock: exactly :)
16:57:55 <EvilTerran> it's not really _really_ easy, you have to faff around putting bounds checks on all the numeric class methods
16:58:08 <EvilTerran> it's tedious rather than difficult, i guess.
16:58:22 <chessguy> faff, is that the technical term?
16:58:29 <EvilTerran> also, you'd need to pick overflow behaviour. wrapping? clipping? bottoms?
16:58:43 <EvilTerran> chessguy, now you mention it, yes, it is.
16:58:54 <chessguy> @all-dict faff
16:58:55 <oasisbot> No match for "faff".
16:59:01 <Cale> However, if you want to parallelise it, it's probably better to use something like a wrapper around an MVar as the thing being written to.
16:59:06 <dibblego> @google "faff about"
16:59:07 <oasisbot> http://www.usingenglish.com/reference/phrasal-verbs/faff+about.html
16:59:07 <oasisbot> Title: Faff about - English Phrasal Verb - UsingEnglish.com
16:59:23 <EvilTerran> it's a bit of a britishism, i suspect.
16:59:23 <cedricshock> Cale: It can even eliminate some of the logic that's in the search. Especially if I can /get/ to the value, to use to eliminate branches via heuristics.
16:59:54 <Cale> yeah
17:00:12 <EvilTerran> faff is what you get the manservant to do, y'see.
17:00:14 <chessguy> He told her to stop FAFFING ABOUT and make her mind up.
17:00:14 <cedricshock> Cale: That would be unbelievably awesome on a multiprocessor computer.
17:00:19 <chessguy> that's a great example
17:02:01 <dons> ?yow
17:02:01 <oasisbot> Couldn't find fortune file
17:02:09 <dons> umm
17:02:15 <chessguy> @seen lambdabot
17:02:16 <oasisbot> I saw lambdabot leaving #oasis and #haskell 3h 28m 12s ago, and .
17:02:22 <cedricshock> Cale: Then there's two new problems in writing the code: 1: making sure I don't force branches to need the result of a previous one before exploring it, and 2: encouraging the compiler to get things to explore branches in close to the order that minimizes the branching factor of the search. The second one could be hard.
17:02:34 <dons> bloody url module timing out.
17:02:53 <dons> oasisbot: @part #haskell
17:02:53 <oasisbot> Not enough privileges
17:02:59 <SamB> url module?
17:03:01 <dons> grr.
17:03:13 --- mode: ChanServ set +o dons
17:03:13 <SamB> kickban!
17:03:17 <chessguy> dons, i think you have to say "bot...i am your father!"
17:03:24 --- kick: oasisbot was kicked by dons (dons)
17:03:27 <SamB> well. maybe not kickban...
17:03:27 --- mode: ChanServ set -o dons
17:03:40 <Binkley> @bot
17:03:40 <lambdabot> :)
17:03:54 <dons> ?yow
17:03:54 <lambdabot> The Korean War must have been fun.
17:03:59 <dons> ah, that's better
17:04:11 <dons> ?temp
17:04:12 <lambdabot>   now 10.1, min 7.0, max 10.2, rain 0.0mm, wind 35km/h W
17:04:14 <dons> brr.
17:04:19 <mauke> ?speed
17:04:20 <lambdabot> Maybe you meant: seen spell
17:04:28 <dons> ?vers
17:04:28 <lambdabot> lambdabot 4p534, GHC 6.6 (Linux i686 2.66GHz)
17:04:28 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
17:04:37 <blackdog_> dons: is that sydney?
17:04:40 <dons> yup
17:04:47 <blackdog_> i'm not going outside today.
17:04:54 <dons> good idea.
17:05:07 <SamB> ?help temp
17:05:07 <lambdabot> Local temperature
17:05:21 <SamB> how does it figure out the local temperature?
17:05:25 <mauke> ?position
17:05:25 <SamB> does it take args?
17:05:25 <lambdabot> Unknown command, try @list
17:05:26 <chessguy> @hoogle sort
17:05:27 <lambdabot> List.sort :: Ord a => [a] -> [a]
17:05:27 <lambdabot> List.sortBy :: (a -> a -> Ordering) -> [a] -> [a]
17:05:27 <lambdabot> System.Win32.NLS.sORTIDFROMLCID :: LCID -> SortID
17:05:37 <dons> SamB: statically
17:06:02 <chessguy> by measuring static electricity?
17:06:39 <SamB> ?temp SamB
17:06:40 <lambdabot>   now 10.1, min 7.0, max 10.2, rain 0.0mm, wind 35km/h W
17:07:05 <dons> ?fore 1
17:07:06 <lambdabot>   17
17:07:07 <lambdabot>   7C min, 14C max
17:07:14 <SamB> that should use my domain name to figure out that I live in Upper Darby and tell me the temperature here ;-)
17:07:22 <chessguy> @hoogle a -> b -> Ordering
17:07:23 <lambdabot> No matches, try a more general search
17:07:31 <dmwit> :t compare
17:07:35 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
17:07:42 <chessguy> oh, duh
17:08:08 <cedricshock> Cale: How could I eliminate the IO() from the MVar stuff (i.e. make a class for monads that have the necessary swap and read type things)?
17:08:48 <Cale> cedricshock: well, anything which fails referential transparency like that needs to be in a monad over IO.
17:09:37 <chessguy> > sortBy (\x y -> compare (fst x) (fst y)) $ zip [26,25,..1] ['a','b'..'z']
17:09:37 <lambdabot>  Parse error
17:09:46 <chessguy> > sortBy (\x y -> compare (fst x) (fst y)) $ zip [26,25..1] ['a','b'..'z']
17:09:48 <lambdabot>  [(1,'z'),(2,'y'),(3,'x'),(4,'w'),(5,'v'),(6,'u'),(7,'t'),(8,'s'),(9,'r'),(10...
17:10:08 <Cale> er, of course you could restrict things though
17:10:12 <chessguy> @pl \x y -> compare (fst x) (fst y)
17:10:12 <lambdabot> (. fst) . compare . fst
17:10:17 <Igloo> cedricshock: If you don't mind being stuck in a Monad the whole time then you could use STRef's in the ST monad
17:10:30 <cedricshock> Cale: Ahh, IO is the only thing allowed to fail referential transparency in the whole haskell language? Another library can't come along and do it if it has the appropriate types to get away with it?
17:10:34 <Cale> Igloo: But that doesn't have all the concurrency stuff he wants.
17:10:53 <Igloo> Err, sorry, yes. Read MVar as IORef for some reason...
17:11:01 <dibblego> IO *repairs* referential transparency
17:11:23 <EvilTerran> cedricshock, any other MonadIO can as well, if i understand right
17:11:35 <SamB> It could be an ArrowIO too
17:11:40 <SamB> or anything else built on IO
17:11:49 <chessguy> @join #happs
17:11:49 <lambdabot> Not enough privileges
17:11:55 <dons>  http://programming.reddit.com/info/278t8/comments
17:11:56 <lambdabot> Title: A Lightweight Interactive Debugger for Haskell (reddit.com)
17:12:06 <dons> ?join #happs
17:12:12 <Cale> Well, you can work in restricted monads, but essentially, at some point, there's going to have to be some function M a -> IO a
17:12:24 <Cale> If you want to use the concurrency stuff.
17:12:27 <blackdog_> @vixen
17:12:27 <lambdabot> Beer, it's so much more than just a breakfast drink!
17:12:39 <jedai> cedricshock: IO doesn't really fail referential transparency, it allows to describe side effects in a purely functional language
17:12:39 <SamB> hahaha
17:12:44 <Cale> If you *just* want parallelism, but not concurrency, there are pure parallelism primitives.
17:13:30 <Cale> Yeah, IO lets you describe computations which would fail referential transparency, in a referentially-transparent way :)
17:13:57 <SamB> by having computations instead of impure expressions
17:13:58 <chessguy> dons, when are we going to get our paws on that debugger?
17:14:04 <cedricshock> Cale: I'm going to feel dirty putting IO in an algorithm. I probably shouldn't...   I'm probably going to need concurrency to do anything with timers.
17:14:29 <Cale> cedricshock: No, you just need some way to phrase the pure parts of your algorithm and separate them out.
17:15:12 <Cale> Like, the bit which takes a state and produces a list of possible refinements is still pure.
17:15:21 <Cale> And the weight function is still pure
17:15:24 <dons> chessguy: ghc 6.7
17:15:30 <Cale> and possibly some heuristic details as well
17:16:25 <chessguy> dons, invalid type. Expected type: DateRange; Inferred type: VersionNumber
17:16:45 <dons> http://programming.reddit.com/info/278uu/comments
17:16:46 <dons>   
17:16:47 <lambdabot> Title: Monads for delimited continuations (reddit.com)
17:16:50 <cedricshock> Cale: but the search method taken as a whole won't be. Right now my functions are really things that return search algorithms when given the things you just described.
17:16:51 <Cale> So you have some "driver" in IO, or if you want, a restricted newtype of IO, which pumps things along concurrently, but it just runs a whole bunch of pure stuff
17:18:07 <Cale> As soon as you move from "same result every time" to "possibly different results based on barometric pressure", you need some IO component somewhere :)
17:18:26 <cedricshock> ?temp
17:18:27 <lambdabot>   now 10.8, min 7.0, max 11.0, rain 0.0mm, wind 33km/h W
17:18:47 <SamB> and yes ... before you ask, barometric pressure *can* change your results where timeouts are concerned
17:22:22 <Binkley> ?quote
17:22:22 <lambdabot> DavidAmos says: the real reason for using Haskell is that the code comes out shorter, and is quicker to write, than in imperative languages .. What that means is, I can get much more done when I use
17:22:22 <lambdabot> Haskell
17:22:28 <cedricshock> Cale: It just seems like I should be able to write things that don't fail referential integrity, and then hand them something completely ugly that does, without telling them about it, like the whole IO bind buisiness inside out, but I'm pretty sure I can't.
17:23:19 <Cale> cedricshock: You need to chop things up enough that the 'ugly' thing will know what it's doing.
17:23:35 <Cale> Functions are completely opaque in Haskell, nothing can look inside them.
17:23:46 <ddarius> seq...
17:24:18 <chessguy> @pl \f g xs -> map f (map g xs)
17:24:18 <lambdabot> (. map) . (.) . map
17:24:57 <EvilTerran> cedricshock, you need to split the function somewhere where an intermediate result can be retrieved. this could be relatively non-ugly through appropriate use of do{...}.
17:25:31 <cedricshock> EvilTerran: Yeah, it's time for me to start coding...
17:25:43 <EvilTerran> i love that moment :D
17:26:44 <cedricshock> Why do I think I just stepped all over the prelude :? class (Ord a) => Bounded a where
17:26:44 <cedricshock>   upper :: a
17:26:44 <cedricshock>   lower :: a
17:27:16 <Cale> @type minBound
17:27:18 <ddarius> ?instances Bounded
17:27:19 <lambdabot> forall a. (Bounded a) => a
17:27:20 <lambdabot> (), (a, b), (a, b, c), All, Any, Bool, Char, Int, Ordering, Product a, Sum a
17:27:33 <ddarius> upper and lower are available though
17:28:40 <dons> wow, is Hugh Perkins trolling for C# on -cafe@?
17:28:51 <Binkley> haha
17:29:27 <ddarius> That comment was pointless.
17:29:55 <ddarius> @pl \xs -> map f (map g xs)
17:29:56 <lambdabot> map (f . g)
17:30:06 <ddarius> That's interesting.
17:30:19 <blackdog_> hey, where can i get cabal 1.1.7? cabal-install seems to need it...
17:30:20 <chessguy> @pl \ps -> m e $ m r ps
17:30:21 <lambdabot> m e . m r
17:30:28 <jfredet1> hmm,
17:30:28 <dons> ddarius: huh. that is interesting
17:30:33 <dons> blackdog_: darcs haskell.org/cabal
17:30:36 <jfredet1> it seems the other me is stuck
17:30:45 <sjanssen_> blackdog_: that's the darcs version, IIRC
17:30:55 <dons> ghost?
17:30:59 <jfredet1> yah
17:31:02 <blackdog_> beautiful. thanks.
17:31:13 <chessguy> @type (. map) . (.) . map
17:31:15 <lambdabot> forall a a1 b. (a1 -> b) -> (a -> a1) -> [a] -> [b]
17:31:25 <jfredet1> i didn't notice right away, because the 1 in jfredet1 looks like the t in jfredett
17:31:34 <chessguy> @type map (?f . ?g)
17:31:36 <lambdabot> forall b c a. (?f::b -> c, ?g::a -> b) => [a] -> [c]
17:31:46 <dons> you can kill it with the 'ghost' command to nickserv
17:31:50 <slava> @type \x -> x x
17:31:52 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
17:31:52 <lambdabot>     Probable cause: `x' is applied to too many arguments
17:31:59 <jfredet1> righto
17:32:01 <dons> no types for slava :)
17:32:08 <ddarius> slava has discovered our fatal flaw.
17:32:10 <chessguy> @type map ?e . map ?r
17:32:12 <lambdabot> forall b a b1. (?e::b1 -> b, ?r::a -> b1) => [a] -> [b]
17:32:14 <dons> :t fix
17:32:16 <lambdabot> forall a. (a -> a) -> a
17:32:38 <dons> > fix ("(types "++)
17:32:40 <lambdabot>  "(types (types (types (types (types (types (types (types (types (types (type...
17:33:03 <chessguy> types++
17:33:06 <mauke> > fix ("developers, " ++)
17:33:07 <lambdabot>  "developers, developers, developers, developers, developers, developers, dev...
17:33:16 <Stinger_> heh
17:33:19 <blackdog_> mauke: but where's the dancing monkey?
17:33:24 <chessguy> @quote monkey
17:33:26 <lambdabot> psykotic says:  (:[]) is the happy monkey operator
17:33:37 <dons> ?qyote ninja
17:33:38 <lambdabot> Samus_ says: pokutemon teenage mutant ninja programmer! yeah!
17:33:49 <dons> ?qyote robot
17:33:49 <lambdabot> No quotes match. Maybe if you used more than just two fingers...
17:33:55 <dons> boo
17:34:24 <ddarius> lambdabot suffers from Alzheimer's.
17:34:54 <ddarius>  /nick jfredett
17:35:02 <jfredet1> hrm.
17:35:04 <blackdog_> it doesn't suffer from it, it enjoys every ... uh, where am i?
17:35:16 <jfredet1> working w/ nickserv through gaim seems to not work
17:35:19 <jfredet1> bah
17:36:21 <Cale> gaim isn't really well-suited to IRC, I don't think
17:36:27 <ghost> me neither
17:36:35 <ghost> doh! that wasn't what I meant to do
17:37:27 <dons>  /msg nickserv help ghost
17:38:28 <EvilTerran> i think some clients have /ghost set up to DWYM
17:39:18 <blackdog_> ok, meta-question. When a cabalised program fails to build because of a dependency, where do i search for that dependency?
17:39:37 <Cale> blackdog_: hackage, usually
17:39:37 <blackdog_> (i need pretty-any)
17:39:56 <Botje> you try to install cabal-install and fail horribly.
17:39:59 <dons> ah yes, the infamous `pretty' dep.
17:40:04 <Botje> that's what happened to me, at last
17:40:09 <dons> its on darcs.haskell.org/packages/pretty
17:40:11 <bitwiseshiftleft> hey all.  is there a way to use GADTs with Haddock?  (say, in HEAD?)
17:40:24 <blackdog_> dons: cheers
17:40:33 <dons> with the ghc-haddock version, i think, bitwiseshiftleft . otherwise #cpp around it
17:40:34 <bitwiseshiftleft> or do i need to do the whole cpp/#ifdef _HADDOCK_ hack?
17:40:37 <blackdog_> Botje: that's where i am at the moment, ironically enough
17:40:46 <Igloo> blackdog_: You probably want to delete the dep rather than install the package, though
17:40:47 <blackdog_> cabal-install needs pretty.... :)
17:40:51 <blackdog_> do i?
17:40:53 <blackdog_> ok.
17:41:11 <Botje> meh, while i'm procrastinating sleep:
17:41:21 <bitwiseshiftleft> is haddock-ghc in head, or somewhere else?
17:41:42 <Botje> when I compile my cabalized program with both time and network, I get "PACKAGE_VERSION redefined" errors
17:41:46 <dons> not sure. check the haddock website, it might have info
17:42:18 <bitwiseshiftleft> dons: thanks
17:43:30 <bitwiseshiftleft> yeah, haddock website has nothing
17:43:41 <dons> google for ghc haddock then, perhaps
17:43:49 <bitwiseshiftleft> am, looking through it...
17:44:30 <bitwiseshiftleft> whoa, haddock-ghc was a 2006 SoC project?
17:44:45 <bitwiseshiftleft> ... i'd thought it was more recent
17:45:51 <jfredett> hmm
17:45:58 <jfredett> hah hah! that worked
17:47:37 <blackdog_> ... ok, and directory-any is ... ?
17:47:48 * blackdog_ is almost broken by unchaseable dependencies
17:47:54 <Igloo> blackdog_: Delete it
17:48:38 <cedricshock> Cale: Am I correct in thinking my search engine is going to look something like: (s -> [s]) -> (s -> v) -> IO (MVar (s, v))
17:48:54 <Cale> No reason the IO has to return an MVar
17:49:20 <cedricshock> Cale: How will something that starts the search engine know where to look for the results?
17:49:21 <Cale> (but it might use one internally)
17:50:06 <Cale> Oh, I suppose it could, if you're just talking about the pre-timeout part.
17:50:15 <cedricshock> Cale: No, it's even better for the thing that starts it to tell it WHERE to put the results, so multiple different algorithms could be competing to find the best solution on multiple different processors, and all pruning their exploration spaces by the best results of the other engines.
17:52:58 <chessguy> let id = \x -> x in id id
17:53:02 <chessguy> > let id = \x -> x in id id
17:53:03 <lambdabot>  Add a type signature
17:53:10 <chessguy> > let id = \x -> x in id id :: Int
17:53:11 <lambdabot>  Couldn't match expected type `Int' against inferred type `t -> t'
17:53:19 <EvilTerran> > fix id
17:53:20 <lambdabot>  Exception: <<loop>>
17:53:28 <chessguy> > let id = \x -> x in id id :: Int->Int
17:53:30 <lambdabot>  <Int -> Int>
17:53:35 <chessguy> heh
17:53:56 <Cale> > let id :: a -> a; id x = x in id id
17:53:57 <lambdabot>  Add a type signature
17:54:02 <Cale> > let id :: a -> a; id x = x in id id :: a -> a
17:54:03 <lambdabot>  Add a type signature
17:54:08 <Cale> @type let id :: a -> a; id x = x in id id
17:54:10 <lambdabot> a -> a; id x = x in id id :: forall a. a -> a
17:54:13 <Cale> heh
17:54:17 <cedricshock> This is awesome. An admissible (complete) and an inadmissible search could run at the same time with the same objective, and if the admissible complete search completes you know you have an optimum like you would from an admissible, complete search, even if it took shortcuts that the other search found.
17:55:13 <chessguy> @type fix
17:55:15 <lambdabot> forall a. (a -> a) -> a
17:58:16 <chessguy> the debugger looks really cool
17:58:21 <chessguy> @karma+ ghc
17:58:22 <lambdabot> ghc's karma raised to 6.
17:58:51 <slava> so does the ghc team use darcs now?
17:59:08 <Binkley> slava: of course
17:59:17 <slava> is it painful?
17:59:21 <Binkley> sometimes
17:59:31 <slava> i love darcs but wish it was about 1000 times faster
17:59:44 <mauke> just use git
18:00:37 <slava> i wish 'darcs record' could record several patches at once
18:00:54 <Igloo> The UI to do that would be too painful, I think
18:00:55 <slava> so you could do through all your changes, and sort them between patches
18:02:56 <Toxaris> Igloo: "Should this change be recorded? [yes, no, patch number]"
18:03:00 <Igloo> dons: QuickCheck isn't in (GHC) 6.6.1
18:03:42 <Toxaris> Igloo: with yes == patch 0
18:03:43 <Igloo> Toxaris: I'm not convinced that isn't painful when you have enough patches for it to be useful
18:03:52 <Binkley> yeah, sounds error-prone
18:04:57 <Cale> otoh, if you had a Gtk2Hs interface, you could display the patches in a list view and allow the user to sort them interactively.
18:05:23 <Igloo> Yeah, and give them meaningful names
18:05:37 <Igloo> Oh for darcs-as-a-library
18:08:01 <cedricshock> In pure code, is there any advantage to using lets over calling the same function with the same arguments multiple times? Is there any advantage to explicitly passing these things "pre computed" to functions, rather than doing it again to a variable that can only have been the same thing?
18:08:21 <cedricshock> There shouldn't be, but I don't know how clever the compilers are...
18:08:26 <Binkley> cedricshock: if you use lets, each expression is only evaluated once
18:08:26 <Cale> cedricshock: not wasting time
18:08:43 <Binkley> there's no guarantee that will happen if you inline the right-hand-sides of "let"s
18:08:51 <Binkley> (manually inline, that is)
18:09:12 <cedricshock> Binkley, Cale: Thanks. That's exactly what I needed to know. lets it is!
18:09:46 <Cale> Function parameters which are duplicated in the body are also guaranteed to be evaluated just once.
18:10:02 <cedricshock> Considering some of my /heuristics/ for the current search problem are NP-complete, I really think I should make an effort to compute them only once.
18:10:42 <cedricshock> Cale: But not across the borders of functions? Ok.
18:10:46 <Cale> right
18:11:19 <Cale> if you write  g x = f x + f x, then it will tend to evaluate f x twice, even though for a given invocation of g, it'll evaluate x just once.
18:12:32 <cedricshock> Cale: Thanks. /Lots/ of lets it is.
18:13:39 <Toxaris> cedricshock: or where clauses or clever combinators
18:13:51 <Toxaris> g x = let y = f x in y + y
18:14:01 <Toxaris> g x = y + y where y = f x
18:14:39 <Toxaris> g x = 2 * f x
18:14:45 <mauke> g x = join (+) (f x)
18:14:53 <mauke> g = join (+) . f
18:15:23 <mauke> g = join (liftM2 (+)) f
18:20:59 <ivanm> Hey everyone... I'm talking a Haskell program that I wrote at home (using 6.6 and 6.6.1), and I'm trying to run it at uni where they only have 6.4.2
18:21:23 <ivanm> but it keeps coming up with errors like " No instance for (Monad ((->) Int))" when trying to use either concatMap or bind... any ideas how to fix this?
18:21:37 <mauke> import Control.Monad.Reader
18:21:53 <mauke> wait, for concatMap?
18:22:00 <Cale> Yeah, Control.Monad.Instances isn't available in 6.4.2
18:22:05 <mauke> that's weird
18:22:23 <Cale> concatMap is only for lists
18:22:24 <ivanm> well, that seemed to have worked...
18:22:46 <ivanm> Cale: well, it was a list of Char for that one (i.e. a String)
18:23:07 <ivanm> no, I lie... it was [Int]
18:23:24 <mauke> > concatMap (\i -> [i, i+1]) [2,3,5,8]
18:23:26 <lambdabot>  [2,3,3,4,5,6,8,9]
18:24:27 <ivanm> though another thing I found was that when compiling, it would come up with messages like "Chasing modules from: GenPremCrits.lhs" ... was this removed from 6.6 or something? (I'm using --make as an argument to ghc)
18:26:25 <dons> ivanm, yep, you need to add -v2 (iirc) to get back all the chasing messages
18:27:59 <ivanm> dons: for >= 6.6 ?
18:28:38 <dons> btw, i updated a couple of shootout programs, nsieve also does well now, http://shootout.alioth.debian.org/gp4/benchmark.php?test=nsieve&lang=all
18:28:41 <lambdabot> Title: nsieve benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Language B ..., http://tinyurl.com/ncjpk
18:29:41 <dons> and partial-sums does better than ocaml, http://shootout.alioth.debian.org/gp4/benchmark.php?test=partialsums&lang=all
18:29:44 <lambdabot> Title: partial-sums benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lang ..., http://tinyurl.com/lk8xz
18:30:00 <ivanm> nice!
18:31:39 <dons> ?temp
18:31:40 <lambdabot>   now -, min 7.0, max 12.1, rain 0.0mm, wind 33km/h WSW
18:34:13 <Toxaris> whats the name of "transforming complex into simple expressions by introducing temporary variables" in the context of optimising compilers?
18:34:16 <edwardk> does ghc have a sincos? or is it just the separate sin and cos?
18:34:44 <edwardk> i guess the tuple unpacking would probably cost as much as the separate calls =/
18:34:45 <dons> no compiled op, afaik
18:34:57 <dons> possibly
18:35:01 <Toxaris> like (a + b) + c becomes let x = a + b in x + c
18:35:18 <mauke> sin&&&cos
18:35:27 <drtom> Toxaris: in some contexts this is called a homogeneous form
18:35:39 <edwardk> mauke: yeah but thats not likely to take advantage of fsincos in the implementation or the equivalent on other platforms ;)
18:36:01 <mauke> but it looks cool
18:36:15 <edwardk> =)
18:36:41 * Toxaris likes arrow syntax for the (->) arrow
18:38:56 <edwardk> there doesn't happen to be an 'anonynous reader arrow transformer' does there?
18:39:06 * edwardk starts thinking of other notation to abuse
18:40:31 <edwardk> guess it'd be kinda redundant without a tag
18:41:52 <Toxaris> drtom: thanks. guess i'll call it normalization for now
18:43:25 <edwardk> might work if you had a form of restricted arrows though, coz given a e b, you can always apply reader semantics to a second argument of a pair a (e,r) b and get a reasonable notion of an arrow i guess, seems a bit like tits-on-a-mule otherwise though.
18:45:49 <Saizan> very similar to arrow notation desugaring, it seems
18:46:22 <edwardk> ya, just curious if there were weird things that made sense in that context like lifting the math operations over reader, etc.
18:46:31 <ivanm> with 6.4.2, how can I get it such that when using ghc --make foo.lhs, it compiles it into a file called foo? it even doing -o foo doesn't seem to work...
18:47:54 <edwardk> @type (&&&)
18:47:56 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
18:47:57 <Saizan> you get a.out ?
18:48:28 <edwardk> mv a.out foo # might work in a pinch =)
18:49:20 <ivanm> heh, found out I had an alias hanging around that had the same filename as the script I was trying to write to do it :s
18:49:24 <ivanm> thanks anyway
18:57:40 <dons> ?users
18:57:40 <lambdabot> Maximum users seen in #haskell: 354, currently: 329 (92.9%), active: 7 (2.1%)
18:58:19 <Figs> I have something awful to scare your children away from C++
18:58:20 <Figs> http://rafb.net/p/C7WE8x61.html
18:58:21 <lambdabot> Title: Nopaste - Obfuscated C++ Program (YES, it _CAN_ get worse!)
18:58:24 <Figs> wrote it myself :)
18:58:58 <chessguy_> heh. nice
18:59:02 <chessguy_> what does it do?
18:59:43 <dolio> Holy smokes.
19:00:17 <Toxaris> Figs: but it's not only C++: http://www.haskell.org/haskellwiki/Obfuscation
19:00:18 <lambdabot> Title: Obfuscation - HaskellWiki
19:03:59 <chessguy> heh, this is cool: http://www.haskell.org/haskellwiki/Type_arithmetic
19:04:00 <lambdabot> Title: Type arithmetic - HaskellWiki
19:04:04 <Saizan> anyone knows if you can make a Status Icon with gtk2hs? (aka notification area/system tray icon)
19:05:58 <ddarius> I should rewrite that to use associated type synonyms.
19:23:31 * ddarius considers making a LADSPA binding.  Probably crazy and pointless.
19:23:56 <ddarius> Should be pretty easy though.
19:33:22 <malsyned_> Is there a way to get ghci to load and interpret the source of a module even if an up-to-date object file exists for that module?
19:33:41 <malsyned_> when it loads the object files, I don't have access to non-exported symbols, which is a hassle.
19:34:14 <shachaf> malsyned_: system "rm f.hi"? :-)
19:34:43 <malsyned_> shachaf: well, that method is superior to my previous technique in that I don't have to leave the repl.  but still.
19:35:25 <[1]slava> @seen glguy
19:35:25 <lambdabot> I saw glguy leaving #haskell 1h 1m 19s ago, and .
19:38:08 <shachaf> malsyned_: Hmm, it looks like you want the .o, actually. It's irrelevant anyway. :-)
19:39:14 <malsyned_> shachaf: why irrelevant?  am I misinterpreting what's going on?  Is there a way to sidestep the whole issue that I don't know about?
19:40:01 <shachaf> malsyned_: I mean, my answer won't do you any good anyway.
19:40:08 <shachaf> malsyned_: It's not what you were asking for.
19:40:36 <malsyned_> nah.  although it'll serve my purpose for small projects.
19:47:01 <malsyned_> this can't be a thing that only trips me up, though.  other people don't get annoyed by this?
19:47:17 <Cale> @seen tuomov
19:47:18 <lambdabot> I haven't seen tuomov.
19:48:08 <shachaf> malsyned_: The odd thing is that it needs V.hs anyway.
19:48:40 <dons> been months, Cale.
19:49:20 <shachaf> malsyned_: So it might be best to :def an alias to :! touch f.hs.
19:54:35 <malsyned_> maybe.  I'll poke at it sometime.  thanks.
19:56:54 <shachaf> malsyned_: Why? :def w (\_ -> return ":! touch f.hs\n:r\n") seems to work.
19:57:12 <shachaf> malsyned_: You can add an optional argument if you want it to be more permanent.
19:57:41 <malsyned_> I'm sure it will.  it'll just be a hassle to write something like that for like five modules I'd be working on at once.  It's better than what I was doing.  I'm done hacking for tonight though.
19:57:45 <Figs> ddarius!
19:58:49 <shachaf> Figs: Did Cale ever show you a Haskell version of your parser?
19:58:54 <Figs> no
19:58:56 * shachaf would be curious.
19:59:07 <Figs> I did realize I had some issues with it though
19:59:08 <Figs> :P
19:59:20 <Figs> shachaf, you see my evil C++ program yet?
19:59:51 <shachaf> Figs: The obfuscated one?
19:59:52 <Cale> I was going to show you how to do a naive (functional, but potentially somewhat inefficient) parser combinator library in Haskell.
20:00:08 <Figs> yeah
20:01:20 <Cale> The translation into C++ etc might be somewhat tricky, though doable if you have some translations of functional programming concepts (lazy lists, first-class functions)
20:01:20 <Saizan> malsyned_: you could also build with cabal, or use -hidir and -odir to change the directory where ghc saves the files so that ghci doesn't find them
20:01:36 <Figs> like Phoenix
20:01:37 <Figs> :D
20:01:44 <timthelion> is there a filter function which can output two lists one for true and one for false?
20:01:45 <Figs> (functional programming framework in C++)
20:02:09 <Cale> yeah :)
20:03:02 <Cale> So the basic idea is that a parser for things is a function from strings to lists of pairs of strings and things. ;)
20:03:07 <dolio> > partition even [1..10]
20:03:09 <lambdabot>  ([2,4,6,8,10],[1,3,5,7,9])
20:03:21 <malsyned_> Saizan: thanks, I'll give that a shot too.
20:03:31 <shachaf> dolio: That was the name. I almost remembered it... :-)
20:03:39 <timthelion> dolio: thanks
20:03:45 <Cale> That is, in Haskell type-speak:  type Parser a = String -> [(String, a)]
20:03:47 <dolio> Yeah, I had to look it up.
20:03:49 <shachaf> @hoogle (a -> Bool) -> [a] -> ([a],[a])
20:03:50 <lambdabot> List.partition :: (a -> Bool) -> [a] -> ([a], [a])
20:03:50 <lambdabot> Prelude.break :: (a -> Bool) -> [a] -> ([a], [a])
20:03:50 <lambdabot> Prelude.span :: (a -> Bool) -> [a] -> ([a], [a])
20:03:55 <timthelion> I have a list of Either an error or a file path, and I would like to get from this a list of errors and a list of functions. I think this is the most efficient way of doing that.
20:04:47 <shachaf> > let q = [Left 3, Right 'a', Left 4, Right 'b'] in [(l,r) | Left l <- q, Right r <- q] -- Also works?
20:04:48 <lambdabot>  [(3,'a'),(3,'b'),(4,'a'),(4,'b')]
20:04:52 <timthelion> actually, is there a partition M?
20:04:55 <shachaf> Um, oops.
20:05:12 <shachaf> I should've realized that. :-)
20:05:14 <Cale> Figs: if you're interested in hearing about it now, perhaps #haskell-overflow would be better :)
20:05:44 <timthelion> um, does partition do the inefficient thing and use two passes?
20:05:53 <timthelion> @src
20:05:53 <lambdabot> src <id>. Display the implementation of a standard function
20:06:06 <timthelion> @src partition
20:06:06 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
20:06:06 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
20:06:06 <lambdabot>                               | otherwise = (ts, x:fs)
20:07:11 <timthelion> wow, that's smart
20:15:00 <timthelion> do you have to tell the compiler to moimise(sp) a function?
20:15:09 <ivanm> Just checking: how does ordering of lists work? does foo < bar if at the first place foo and bar differ, foo has a lower value?
20:18:39 <Korollary> @instances-importing Ord
20:18:40 <lambdabot> (), All, Any, Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, Product a, Sum a, [a]
20:18:50 <Saizan> > (repeat 1) < [1..]
20:18:51 <lambdabot>  True
20:19:03 <Saizan> > (repeat 1) < [2]
20:19:04 <lambdabot>  True
20:19:47 <Korollary> Maybe it's similar to ordering on strings
20:20:27 <Saizan> timthelion: compilers don't memoize in general, but monomorphic bindings are shared
20:20:32 <dons> ?src Ord []
20:20:32 <lambdabot> Source not found. Just what do you think you're doing Dave?
20:20:38 <dons> ?src (<) []
20:20:39 <lambdabot> Source not found. I feel much better now.
20:21:17 <Saizan> ?src compare [a]
20:21:18 <lambdabot> Source not found. Just what do you think you're doing Dave?
20:21:33 <timthelion> Saizan: I have a let which references an order n function like 10 times, and I was making sure it wouldn't be 10n
20:21:54 <timthelion> Saizan: one which takes no parameters .
20:22:50 <shachaf> timthelion: I think that depends on the type of the function.
20:24:03 <mrd> @botsnack
20:24:04 <lambdabot> :)
20:24:18 <Saizan> like let val = ...; in <val used 10 times here> ? so val should be evaluated only once if you didn't give it a polymorphic type
20:25:15 <timthelion> it's used before the in
20:26:15 <Saizan> it shouldn't matter afaik
20:27:46 <timthelion> I like how most of my functions are like 20 lines of self referential let and one line after in
20:31:42 <dons> timthelion: heh, maybe you should use 'where' ?
20:31:54 <timthelion> dons: is there a reason?
20:31:55 <dons> timthelion: do you have an example? 20 lines seems longer than typical
20:32:06 <dons> 'where' is considered more declarative
20:32:21 <dons> so slightly better style, i'd be happy to look at the code, if you're up for a code review?
20:33:28 <kfish> dons: there's no physical difference, right? (in the compiled code)
20:33:28 <lambdabot> kfish: You have 1 new message. '/msg lambdabot @messages' to read it.
20:33:40 <kfish> lambdabot: xxx
20:33:57 <dons> no difference in the compiled code. 'where' is sugar for 'let'
20:34:22 <timthelion> dons: I'll give an exceptionally, painfully, long example(not yet compleat or debuged or anything...) http://rafb.net/p/GgAy3422.html
20:34:23 <lambdabot> Title: Nopaste - No description
20:34:37 <dons> hmm, Andrew Copping quote of the month, wrt. "intuitionistic logic":
20:34:39 <kfish> dons: ok cool, i tend to use either where they feel right, but I can't really explain why I'd choose each :-)
20:34:40 <timthelion> that's the main function of my EvenColumns
20:35:00 <dons> On the one hand, it feels exciting to be around a programming language
20:35:00 <dons> where there are deep theoretical discoveries and new design territories
20:35:00 <dons> to be explored. (Compared to Haskell, the whole C / C++ / Java /
20:35:00 <dons> JavaScript / Delphi / VisualBasic / Perl / Python thing seems so boring.)
20:35:00 <dons> On the other hand... WHAT THE HECK DOES ALL THAT TEXT *MEAN*?! >_<
20:35:02 <dons> On the one hand, it feels exciting to be around a programming language
20:35:28 <davidL> Why doesn't "iterate inits [1..5]" work?
20:35:40 <timthelion> dons: I felt that way for a while.
20:35:55 <dons> timthelion: hmm, this code. let's see.
20:35:57 <bos> i think we need a haskell version of twitter, whence we can banish andrew coppin and hugh perkins.
20:36:28 <timthelion> dons: it's literary, there are a bunch of random useless comments
20:36:36 <dons> bos :)
20:36:43 <dibblego> bos++
20:36:46 <Saizan> davidL: because inits :: [a] -> [[a]]
20:37:05 <davidL> Saizan: but iterate is forall a
20:37:13 <Saizan> ?type iterate
20:37:16 <dibblego> ?type iterate
20:37:21 <lambdabot> forall a. (a -> a) -> a -> [a]
20:37:23 <lambdabot> forall a. (a -> a) -> a -> [a]
20:37:25 <dibblego> note (a -> a)
20:37:37 <timthelion> dons, infact I'll have to re-write that function, but it's only going to get longer.
20:37:43 <Saizan> davidL: you can't unify (a -> a) with ([a] -> [[a]])
20:37:47 <kfish> dons: lambdabot has given me the same message the last 3 times i logged in, am i meant to clear my inbox or is she buggily forgetting that she's already told me?
20:37:56 <dblhelix> morning #haskell
20:38:13 <davidL> Saizan: I see
20:38:38 <dons> timthelion: you really need to break out some worker functions there, to the top level
20:38:40 * dblhelix forced the compiler into unifying a and [a] the other day...
20:38:49 <dblhelix> (well, more or less)
20:38:57 <oklopol> > cons 4 [1,2,3]
20:38:58 <lambdabot>   Not in scope: `cons'
20:39:02 <oklopol> heh
20:39:09 <dons> kfish: i think it doesn't clear unless you read the messages. but it could be buggy too :) check the Tell module if you want to fix it.
20:39:17 <timthelion> dons: you think that would make it more readeble?
20:39:20 <kfish> dons: ta
20:39:22 <dons> kfish: you're doing a PhD right? that means you're supposed to be writing patches
20:39:30 <kfish> :-P
20:39:36 <dblhelix> :-)
20:39:50 <timthelion> dons: what would make it more readable would be if I had really known what I was doing when I started writting it.
20:40:07 <oklopol> > (:) 4 [1,2,3]
20:40:08 <lambdabot>  [4,1,2,3]
20:40:26 <timthelion> dons: you think I should figure out each part of MagRow in separate functions?
20:40:34 <oklopol> (my weekly haskell ownage)
20:41:02 <davidL> Saizan: is there a way to rewrite it without using iterate?
20:41:41 <timthelion> is there an offline version of http://haskell.org/ghc/docs/latest/html/libraries/
20:42:07 <Saizan> davidL: what that function was supposed to do?
20:42:07 <dblhelix> timthelion: not on line :-)
20:42:26 <dblhelix> timthelion: but I suppose you mean a .pdf or something
20:43:00 <timthelion> dblhelix: no like a tar.gz for easy dling
20:43:03 <Saizan> http://www.haskell.org/ghc/docs/latest/libraries.html.tar.gz
20:43:04 <davidL> Saizan: do inits n many times
20:43:22 <timthelion> Saizan: thanks
20:43:34 <dblhelix> timthelion: if you install ghc you can get the html tree installed locally too
20:43:59 <Saizan> > map inits (inits [1..4]) -- like this?
20:44:01 <lambdabot>  [[[]],[[],[1]],[[],[1],[1,2]],[[],[1],[1,2],[1,2,3]],[[],[1],[1,2],[1,2,3],[...
20:45:19 <davidL> yeah but how do I do that a 100 times
20:46:01 <Saizan> so you get a 100-deep list?
20:46:28 <davidL> yes
20:49:00 * dblhelix senses some type-class hackery coming up
20:49:10 <Saizan> quite strange thing to want to do, and it's hard to make an iterate-like function because each step would change the type, maybe it's better to use a more hierarchical structure like a tree?
20:49:36 <Saizan> also inits is O(n^2)
20:49:46 <dblhelix> Saizan: that'd be better, I guess
20:50:31 <timthelion> how come there aren't specific string manipulation functions for manipulating file paths in System.Directory? are they somewehre else?
20:51:05 <bos> System.FilePath
20:51:38 <bos> timthelion: it's bundled with ghc 6.6.1
20:52:14 <davidL> Saizan: Data.Tree?
20:52:53 <timthelion> I have here in haddoc a FilePath type, but I don't see any functions like a isPathInOtherPath or cd
20:53:03 <timthelion> as string manipulations
20:53:35 <dons> Cale, looks like SPJs tut will be recorded, bos reckons.
20:54:24 <Cale> dons: cool :)
20:54:33 <Cale> dons: We need more video haskell tutorials online :)
20:54:47 <Saizan> davidL: yes, or a custom one, like data Tree a = Leaf a | Branch [Tree a] so you get the values only on the leafs like in nested lists, but here both Branch [Leaf 1] and Branch [Branch [Leaf 1]] have type Tree Int
20:55:15 <davidL> Saizan: I don't know if this changes the fact that Data.Tree might be better suited for what I need but, I would have concat'd the N-deep list after using init
20:56:15 <Saizan> davidL: that change a lot
20:57:15 <Saizan> > iterate (concatMap inits) (return [1..5])
20:57:16 <lambdabot>  [[[1,2,3,4,5]],[[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5]],[[],[],[1],[],[1...
20:57:41 <Saizan> does that do what you want?
20:57:44 <davidL> ?ty return
20:57:46 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
20:58:13 <Saizan> i could have used (\x -> [x]) instead of return
20:59:07 <bos> @pl \x->[x]
20:59:07 <lambdabot> return
20:59:18 <davidL> Saizan: ah, yes that does work :X
21:00:41 <davidL> thank you
21:03:42 <Saizan> np
21:04:44 <edwardk> has anyone put together a template haskell version of the derivative of a datastructure? something like $(d ''Maybe) or something like that?
21:04:59 <edwardk> for zipper construction and the like
21:06:46 <Saizan> is that so automatic?
21:07:09 <edwardk> i think so, i walk through it fairly algorithmically when i do it
21:07:19 <edwardk> hrmm, testing the idea
21:08:04 <dons> i think Conor's paper has an example of how to do it with generics
21:08:16 <dons> so you could probably try it with TH as well
21:08:18 <edwardk> yeah, but more people know TH =)
21:09:04 <whaleofconfusion> how long does it take to build ghc?
21:09:29 <edwardk> whale: i usually do it overnight =)
21:09:36 <whaleofconfusion> ok
21:09:39 <dons> 4 minutes if you've got 16 cores.
21:09:43 <edwardk> =)
21:09:54 <dons> so between 4 minutes and 4 hours, is typical
21:10:29 <dons> i think the all time record was 61 hours for a 68k 33 Mhz machine.
21:11:50 <timthelion> is ghc really that heavy? emacs builds in 45 minutes here.
21:12:09 <Korollary> apples and oranges when it comes to sources and compilers
21:12:53 <edwardk> that and the whole stage1 and stage2 compile thing, etc.
21:13:35 <edwardk> it gets to the end and then starts singing "lets do the timewarp again!"
21:13:35 * shapr hugs edwardk
21:13:40 <Korollary> ocaml seems to ship bytecode files for the cmpiler in the source distro and then use them to bootstrap.
21:13:44 <timthelion> Korollary: well, it says something about the flexibility of the project.  there are tons of people using the cvs version of emacs and submitting patches, but relatively few running say firefox, or kde from cvs
21:13:46 * edwardk is er.. hugged.
21:14:01 <dons> yeah , you can really get it built quickly if you start with the .c files from a partial build
21:14:03 <hpaste>  dblhelix pasted "arbitrarily nested inits" at http://hpaste.org/1744
21:14:14 <edwardk> shae: what did i do to merit hugging?
21:14:23 <shapr> edwardk: Being smart and SHARING it!
21:14:27 <edwardk> hah
21:14:38 <dblhelix> Saizan: a type-class hack, see http://hpaste.org/1744
21:14:40 <edwardk> did you just read the type-parameterizing thing?
21:15:04 <edwardk> or is this something else i did without knowing it =)
21:15:31 <timthelion> edwardk: kiss the girl on the cheek and get on with it.
21:15:50 <Korollary> dons: maybe it makes sense to have a separate source tarballs for the most popular platforms.
21:16:11 <edwardk> @hpaste
21:16:12 <lambdabot> Haskell pastebin: http://hpaste.org/new
21:16:46 <Saizan> dblhelix: nice, i'd use phantom types for the naturals though
21:17:25 <dblhelix> Saizan: as in gadts?
21:17:27 <edwardk> what is a RecC in template haskell? is that mu? or a record constructor or what?
21:17:40 <shapr> Sounds like it.
21:17:46 <shapr> ye gadts!
21:18:00 <dblhelix> Saizan: yeah, that'd be nicer... you see, I'm such an old-fashioned guy ;-)
21:18:01 <edwardk> tim: =P
21:18:34 <Saizan> dblhelix: no, as in: you only really need their types, so you could define them as void and just use undefined to pass the type :)
21:19:07 <hpaste>  edwardk pasted "TH derivatives so far" at http://hpaste.org/1745
21:19:38 <edwardk> i still need to do the product part and figure out how to handle what i guess have to be record constructors, but it at least builds the right name for the derivative type
21:19:48 <dblhelix> Saizan: but here you need their values to kickstart mapinits
21:20:24 <hpaste>  Saizan annotated "arbitrarily nested inits" with "without values" at http://hpaste.org/1744#a1
21:20:31 <dblhelix> Saizan: as in mapinits five [1 .. 4]
21:20:38 <dblhelix> [[[],[[]],[[],[[]]],[[],[[]],[[],[[]]]],[[],[[]], ...
21:21:13 <Saizan> dblhelix: yeah, but for example you don't need to pattern match (Succ n) in the recursive case
21:21:27 <dblhelix> Saizan: ah, I see, you use lexically scoped type variables --- also nice :-)
21:22:10 <Saizan> they are conveniente, i had to define prev :: Succ n -> n; prev = undefined otherwise :)
21:22:45 <dblhelix> it's more efficient, but, hey, inits still requires O(n^2)
21:23:40 <shapr> aww, andersca left :-(
21:24:05 <shapr> I didn't get to tell him that a worm infected my ... ears of corn.
21:24:42 <hpaste>  dblhelix annotated "arbitrarily nested inits" with "... with GADTs" at http://hpaste.org/1744#a2
21:27:27 <Saizan> dblhelix: what does that give you?
21:28:00 <dblhelix> Saizan: nothing :-)
21:28:16 <dblhelix> but GADTs are just cool
21:28:33 <Saizan> heh :D
21:28:40 <dolio> You should wrap all your regular types in GADTs.
21:28:42 <dolio> Just because.
21:29:21 <dblhelix> Saizan: if it weren't for bottoms, you could preclude non-numeral types from being an index to the type class though
21:30:32 <dblhelix> I also want associated type synonyms, so we could get rid of -fallow-undecidable-instances... I felt dirty writing that one
21:31:12 <dblhelix> and it's only 6.30am here... I should get some breakfast
21:31:36 <shapr> hah
21:32:27 <Saizan> heh, same here, but i've woken up 4 hours ago..
21:33:23 <edwardk> @type foldl
21:33:26 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
21:39:31 <alar> @messages
21:39:31 <lambdabot> You don't have any new messages.
21:39:43 <alar> @seen ivant
21:39:43 <lambdabot> I saw ivant leaving #haskell 13d 13h 17m 7s ago, and .
21:41:20 * SamB wishes Linux measured *disk* time as well as CPU time
21:42:42 <SamB> (it seems like JHC currently uses a lot more of the former than of the latter)
21:47:27 <ekidd> Good night.
21:47:27 <lambdabot> ekidd: You have 1 new message. '/msg lambdabot @messages' to read it.
21:52:01 <glguy> Any ion3 users? Is there a common solution to all window titles in ion3 being "???" ?
21:58:00 <Cale> glguy: hehe, I was looking for tuomov earlier and apparently he hasn't been here for months
21:58:17 <sjanssen> glguy: xmonad
21:58:26 <sjanssen> :)
21:59:20 <Heffalump> the last I remember of him is a long rant on #darcs about Unicode
22:00:13 <glguy> sjanssen: I'm trying that now
22:00:47 <Cale> Apparently he was annoyed at the Arch guys for distributing ion with some patches and decided that we was never going to contribute to open source software again?
22:01:16 <sjanssen> glguy: btw, I just saw a post on the ion3 mailing list about the ??? issue
22:02:07 <shachaf> glguy: Note that in xmonad, you don't see window titles at all (by default). :-)
22:02:08 <SamB> ... a parting gift?
22:02:28 <glguy> Hmm... the darcs sources for xmonad can't compile
22:02:33 <glguy> no instance for Read Rectangle
22:02:37 <shachaf> glguy: You need X11-extras.
22:02:42 <glguy> I have them
22:02:42 <shachaf> glguy: The latest.
22:02:48 <glguy> oh, not hackage?
22:02:50 <SamB> you havve the latestt X11 pacakge?
22:02:55 <shachaf> glguy: And X11.
22:03:02 <glguy> I have the latest on hackage
22:03:03 <shachaf> glguy: >=1.2.1, I think.
22:03:08 <glguy> 1.2.2
22:03:18 <shachaf> glguy: But I think you need darcs X11-extras.
22:03:23 <SamB> apparantly I don't tyype well whhen my computer is swapping heavily
22:03:30 <glguy> X11-extras-0.2 is what i had
22:03:38 <shachaf> glguy: If you use darcs xmonad -- they're developed together.
22:03:42 <glguy> ok
22:03:47 <sjanssen> glguy: we find missing X11 bindings weekly -- so darcs X11-extras is required with darcs xmonad
22:04:13 <shachaf> sjanssen: Is there anything in -extras that shouldn't be in X11?
22:04:42 <SamB> shachaf: probably not
22:04:49 <SamB> except the constant churn I guess ;-)
22:05:47 <glguy>      error: X11_extras_config.h: No such file or directory
22:05:49 <shachaf> Perhaps it should be called X11-unstable (in the Debian sense of the word). :-)
22:05:51 <sjanssen> shachaf: what SamB said
22:05:53 <sjanssen> glguy: README
22:05:56 <glguy> ok :)
22:06:04 <SamB> or X11-missing
22:07:23 <glguy> autoreconf, got it :)
22:09:14 <glguy> OK, and we're off :)
22:09:49 <Saizan> ?seen dcoutts
22:09:49 <lambdabot> dcoutts is in #haskell-overflow, #haskell and #ghc. I don't know when dcoutts last spoke.
22:09:56 <SamB> *I* had to upgrade to GHC 6.6 to build xmonad ;-)
22:10:58 <shachaf> SamB: Is the 6.4 compatibility completely broken now?
22:11:13 <shachaf> SamB: (Not that you shouldn't have 6.6 anyway, of course.)
22:12:00 <glguy> sjanssen: you're right, this fixes my titlebars issue :)
22:12:42 <shachaf> glguy: Note that you can show window title if you want to.
22:12:46 <SamB> well, I don't believe I could get the X11 and X11-extras packages I needed built with GHC 6.4?
22:12:52 <sjanssen> glguy: you might try XMonadContrib.Tabbed
22:12:54 <shachaf> glguy: It just takes a bit of work.
22:13:12 <shachaf> sjanssen: That works too, though I prefer to print the title to dzen.
22:13:21 <glguy> I'm still reading the man page
22:13:53 <sjanssen> SamB: it's probably possible to build with 6.4, you just have to patch up a bunch of trivial things
22:14:06 * SamB doesn't acctually use xmonad, he just wanted to try it ;-)
22:14:07 <shachaf> Does xmobar work with reading stdin, by the way?
22:14:09 <sjanssen> read instance for Map, forM, etc.
22:14:26 <SamB> sjanssen: ISTR something wanting a newer version of base than I had
22:14:36 <dibblego> contains :: (Index c k) => k -> c k -> Bool -- why does GHC infer this type, but if I try to explicitly annotate my function, I get errors?
22:14:52 <SamB> and I didn't want to just hand-hack around it...
22:14:54 <sjanssen> shachaf: no, it's just executing commands (and builtin plugins) periodically
22:15:07 <shachaf> sjanssen: Oh.
22:15:10 <glguy> Installing: /home/emertens/lib/xmonad-0.2/ghc-6.6.1 & /home/emertens/bin xmonad-0.2...
22:15:14 <glguy> *** Exception: /home/emertens/bin/xmonad: copyFile: resource busy (Text file busy)
22:15:14 <shachaf> sjanssen: I need my logHook...
22:15:17 <glguy> should I know what that means?
22:15:23 <shachaf> glguy: You should rm it.
22:15:29 <sjanssen> glguy: Cabal bug -- it can't copy over a running executable
22:15:32 <glguy> oh
22:15:33 <glguy> ok
22:15:33 <shachaf> sjanssen: I could run dzen and xmobar, I guess.
22:15:39 <SamB> hehe
22:16:00 <SamB> glguy: you didn't know that "text file" means "binary executable"?
22:16:25 <glguy> SamB: :) I didn't know that linux cared about files being "busy"
22:16:27 <sjanssen> shachaf: we might be able to convince gattocarlo to allow for that, somehow
22:16:42 <sjanssen> glguy: you can't write to files that are being executed
22:16:48 <timthelion> @src partitionM
22:16:48 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
22:16:52 <SamB> sjanssen: are you sure?
22:16:56 <glguy> sjanssen: sure you can
22:16:57 <sjanssen> Cabal tries to overwrite, rather than unlinking the old file first
22:17:16 <glguy> oh, I suppose I've only tried to move over or copy over
22:17:18 <glguy> not edit..
22:17:20 <SamB> I think I've crashed XMMS by cping new .so files into it's plugin directory while it was running...
22:17:28 <SamB> (over old ones)
22:17:45 <sjanssen> SamB: cp will unlink, then mv the new file over
22:17:57 <SamB> sjanssen: explain how that crashes XMMS
22:18:00 <SamB> hmm?
22:18:05 <sjanssen> SamB: so you'll only see problems if the program opens the .so twice
22:18:49 <shachaf> What is the advantage to xmobar over dzen + simple script?
22:18:58 <glguy> xmobar?
22:19:05 * shachaf thinks all this should be moved to #xmonad...
22:19:14 <shachaf> glguy: I'd recommend trying a dzen first.
22:19:23 <shachaf> glguy: It's probably simpler.
22:19:25 <glguy> dzen is masked on my amd64 arch (Gentoo)
22:20:01 <timthelion> can I put do's inside lambdas like >partition (\f -> do dir <- doesDirectoryExist; dir) [FilePath] in order to get a ([FilePath] [FilePath])?
22:20:26 <glguy> timthelion: yes you can use do in lambda
22:20:33 <glguy> timthelion: no I don't think that is what you want...
22:20:33 <SamB> timthelion: you may certainly pu tdo's inside lambdas
22:20:50 <SamB> why wouldn't you be allowed to do that?
22:21:06 <timthelion> I think I want to write the function so it returns IO ([FilePath] [FilePath])
22:21:07 <SamB> however that code must certainly be ill-typed
22:21:13 <glguy> timthelion: that isn't a type
22:21:23 <sjanssen> timthelion: your example is syntactically valid, but it has a type error
22:21:25 <timthelion> glguy: that isn't?
22:21:25 <SamB> @hoogle partitionM
22:21:26 <lambdabot> No matches found
22:21:43 <timthelion> sjanssen: that's what I thought
22:21:45 <glguy> timthelion: do you mean: IO ([Filepath], [Filepath])
22:22:02 <timthelion> glguy: I'm trying to make a tuple, do I need the coma?
22:22:04 <glguy> yes
22:22:06 <timthelion> ok
22:22:09 <SamB> you want something that would be called partitionM if it existed, I think
22:23:02 <SamB> if it did you would write: partitionM doesDirectoryExist listOfPotentialDirectoryPaths
22:23:03 <timthelion> SamB that's what I thought too, but it doesn't
22:23:42 <SamB> timthelion: so I see
22:23:45 <glguy> timthelion: then you should write that function since that is the appropriate abstraction
22:23:46 <SamB> I'm going to bed
22:23:58 <SamB> get the others to help you with that, if you need it
22:24:27 <timthelion> maybe haskell isn't the best language to be writting a file management and version management system in.
22:24:50 <timthelion> glguy: ever heard of a newb? I wouldn't know where to start playing with that monady stuff
22:25:10 <glguy> timthelion: this is the perfect function to use to learn about them then
22:25:14 <dibblego> irrational fear
22:25:59 <timthelion> dibblego: they called the beast a walderbagle, and I was scarred, but when I saw it, I fainted, walderbagle was far to light a term
22:26:03 <SamB> glguy: I hope you have an implementation in mind before you make promises like that. good night ;-)
22:26:14 <Cale> Or, if you want, I can write partitionM for you :)
22:26:21 <kfish> timthelion, mmm ... bagels
22:26:58 <timthelion> Cale: you want to?
22:27:06 <timthelion> @src mapM
22:27:07 <lambdabot> mapM f as = sequence (map f as)
22:27:13 <shachaf> @src filter
22:27:13 <lambdabot> filter _ []     = []
22:27:13 <lambdabot> filter p (x:xs)
22:27:13 <lambdabot>     | p x       = x : filter p xs
22:27:13 <lambdabot>     | otherwise = filter p xs
22:27:14 <shachaf> @src filterM
22:27:15 <lambdabot> Source not found. Are you on drugs?
22:27:18 <shachaf> Oh.
22:27:19 <timthelion> @src sequence
22:27:19 <lambdabot> sequence ms = foldr k (return []) ms
22:27:20 <lambdabot>     where
22:27:20 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
22:27:29 <shachaf> @index filterM
22:27:29 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
22:27:34 <shachaf> @source Control.Monad
22:27:34 <lambdabot> http://darcs.haskell.org/packages/base/Control/Monad.hs
22:28:46 <timthelion> when I grow up will all these functions have been written and added to the normal libraries?
22:29:58 <Cale> timthelion: quite possibly
22:30:18 <hpaste>  glguy pasted "partitionM for SamB :-p" at http://hpaste.org/1746
22:30:31 <hpaste>  Cale pasted "partitionM" at http://hpaste.org/1747
22:30:37 * glguy goes to compare :)
22:30:40 <Cale> hehe
22:30:44 <Cale> pretty similar :)
22:30:50 <glguy> you cheated! ;)
22:30:57 <glguy> you must have been reading my clipboard
22:31:00 <Cale> heh
22:31:34 <dolio> @. pl undo do { x <- m ; xs <- m' ; return (x:xs) }
22:31:35 <lambdabot> (`fmap` m') . (:) =<< m
22:31:40 <timthelion> wow, damn that's almost the same!
22:31:49 <dolio> @. pl undo \m m' -> do { x <- m ; xs <- m' ; return (x:xs) }
22:31:49 <lambdabot> liftM2 (:)
22:32:03 <dons> good bot
22:32:06 <Cale> timthelion: It's one of those functions which you can tell exactly how to write it based on the name :)
22:32:22 <Cale> timthelion: perhaps someday, lambdabot will be able to do it :)
22:32:37 <timthelion> Cale: s/you/I/
22:32:44 <glguy> Cale: you forgot the Monad m =>
22:32:44 <glguy> ;)
22:32:50 <Cale> glguy: oh, good catch
22:32:59 <Cale> glguy: I didn't actually compile the code :)
22:33:15 <glguy> ditto
22:33:24 <glguy> I knew I'd have to type fast to get it in in time
22:33:25 <timthelion> do I get to call you guys geeks for this?
22:33:34 <glguy> timthelion: no, there is so much more
22:34:00 * timthelion does the same thing on #emacs 
22:34:05 <glguy> keep in mind that partitionM isn't lazy
22:34:13 <glguy> it has to evaluate the whole list to return a result
22:34:17 <timthelion> glguy: I know
22:34:38 <glguy> at least in IO
22:34:47 <timthelion> glguy: I think we'd have other problems if getDirectoryContents returned an infinite list
22:35:07 <glguy> timthelion: lazy getDirectoryContents could be useful if you just wanted the first entry
22:35:20 <glguy> getContents is lazy
22:35:26 <glguy> along with readFile, for example
22:35:51 <timthelion> it's lazy in c aswell :)
22:36:32 <Cale> bash scripting was my first encounter with lazy functional programming :)
22:37:14 <Cale> The original mbot was effectively one long shell pipeline
22:37:39 <Cale> (it became unmaintainable though, so I replaced it with a lambdabot :)
22:37:55 <glguy> hmmm, I seem to be detaching windows in xmonad
22:38:09 <sjanssen> glguy: detaching?
22:38:31 <glguy> floating?
22:38:50 <glguy> I'm looking through the man page, but I think what I need to do is look in the Config.hs
22:38:50 <timthelion> glguy: there's a hotkey to unfloat
22:38:51 <sjanssen> mod-click/drag will do that
22:39:09 <shachaf> glguy: Mod-t to retile.
22:39:11 <sjanssen> mod-t to unfloat
22:39:35 <glguy> oh, cool
22:39:40 <glguy> mod+space does something now :)
22:39:53 <dons> glguy: was that it? accidentally dragging a window into the floating layer?
22:40:04 <glguy> yeah
22:40:14 <dons> cool
22:40:17 * shachaf does that sometimes.
22:40:24 <shachaf> Well... I did, when I was running xmonad.
22:40:35 <dons> you've given up on it?
22:40:40 <shachaf> dons: Not at all.
22:40:43 * shachaf misses xmonad.
22:40:52 <Cale> Oh, cool, xmonad has floating windows now?
22:40:53 <dons> oh, just don't have a chance to use it?
22:40:54 <shachaf> If my computer worked, I'd definitely use it. :-)
22:40:59 <dons> Ca	yeah.
22:41:03 <glguy> in dwm, mod-return would swap a window into and out of the main area
22:41:13 <glguy> is there anything like that
22:41:29 <sjanssen> glguy: see XMonadContrib.DwmPromote
22:41:33 <glguy> ok, cool
22:42:18 <glguy> are floating windows always on top of tiled windows?
22:42:21 * Cale wonders how well xmonad would work in Gnome :)
22:42:40 * shachaf has run various WMs in various occasions, but I've never missed any as much as xmonad. :-)
22:42:49 <shachaf> Cale: I know someone who runs dwm in GNOME.
22:43:13 <glguy> when I ran dwm, you could have multiple workspaces visible at once
22:43:14 <shachaf> He had to make his own equivalent of gaps (for the panel), etc.
22:43:21 <glguy> so if you put your webbrowser on a separate one
22:43:27 <glguy> you could hide it separately
22:43:30 <shachaf> glguy: Not really. :-(
22:43:31 <glguy> is that in the contrib also
22:43:34 <shachaf> glguy: If you mean tagging.
22:43:37 <glguy> yeah
22:43:49 <shachaf> (As far as I know, at least, it might've changed.)
22:43:56 <shachaf> glguy: Did you really use that?
22:44:08 <glguy> shachaf: sure, that way I coudl still see my irssi window
22:44:13 <glguy> but when I wasn't using firefox
22:44:16 <glguy> I'd send it away
22:44:23 <glguy> if I needed it I'd pull it back
22:44:40 <glguy> but it would still be able to see the bottom of irssi, I thought it was nifty at the time
22:44:56 * shachaf ran at 1024x768, so he wasn't generally a user of multiple windows.
22:45:09 <shachaf> Occasionally, of course.
22:45:24 <shachaf> When you need it, tiling is very useful. :-)
22:45:26 * glguy wants more monitors so that he can try the xinerama support
22:45:32 <shachaf> glguy: Are you using a dzen?
22:45:35 <Cale> I'm not sure how much I like the idea of having to tile my windows, since I overlap them on purpose so often.
22:45:47 <glguy> you wouldn't have to
22:45:50 <glguy> you'd just have the option to
22:45:53 <shachaf> Cale: Well, XMonadContrib.Circle overlaps them on purpose.
22:46:07 <shachaf> Cale: And you can always float them.
22:46:18 <Cale> yeah
22:46:27 <sjanssen> Cale: why do you overlap windows?
22:46:54 <Cale> sjanssen: So that I can see changes in one while giving another a larger portion of the screen.
22:47:05 <shachaf> Cale: Why not resize the one instead?
22:47:22 <shachaf> Cale: Also, XMonadContrib.Magnifier might do what you want.
22:47:35 <glguy> where is this xmonadcontrib stuff?
22:47:46 <Cale> For example, I can overlap the top of my webbrowser with the bottom of my IRC client, since it will only cover up the textbox which I'm not using.
22:48:32 <shachaf> Cale: Well, just resize your IRC client to take only a bit of space.
22:48:40 <shachaf> Cale: Instead of overlapping.
22:48:46 <Cale> yes, but then I can't see as much scrollback :)
22:48:48 <shachaf> @where xmonadcontrib
22:48:48 <lambdabot> http://darcs.haskell.org/~sjanssen/XMonadContrib/
22:48:59 <shachaf> Cale: When you want to look at it, resize it to be bigger. :-)
22:49:13 <brad> :q
22:49:18 <brad> sorry, typp
22:49:21 <brad> typo
22:49:28 <shachaf> Cale: That seems like a lot of manual work, but xmonad automates it.
22:50:34 <Cale> What I'd like is a floaty wm which slowly rearranged the windows I wasn't using in the background so as to make them more accessible.
22:50:48 <shachaf> Cale: That's really a big part of it; your windows don't have static sizes in xmonad.
22:50:51 <Cale> (at least, I'd like to try that :)
22:50:59 <shachaf> Cale: They adjust themselves to your need.
22:51:12 <shachaf> Cale: Auto-rearranging/resizing, without the keyboard?
22:51:16 <Cale> yes
22:51:20 * shachaf (thinks he) would hate that.
22:51:31 <shachaf> But I wouldn't know.
22:52:13 <glguy> the colors in run-xmonad.sh make for an interesting xterm
22:52:26 <Cale> I like to have at least a little piece of each window visible so that I can get to it without having to use the taskbar etc.
22:52:39 <glguy> (I know that they are used for the statusbar and clock in that script)
22:52:48 <shachaf> Cale: Xmonad has no taskbar.
22:52:58 <shachaf> Cale: It's just a different way of thinking about your windows.
22:52:59 <Cale> yeah, but gnome does
22:53:13 <Cale> (or it does, optionally)
22:55:52 <Cale> I'm not sure I'd be willing to give up gnome so easily, since it just has too many useful things in it, and nautilus is the first file browser that I've actually enjoyed using over the shell for some things.
22:56:08 <shachaf> Cale: You don't have to give up GNOME.
22:56:13 <Cale> Right.
22:56:24 <shachaf> Cale: Just Metacity. :-)
22:56:27 <Cale> (I know that, I've run Gnome with Enlightenment in the past.
22:56:28 <Cale> )
22:56:50 <shachaf> Doesn't Nautilus take over the root window?
22:56:55 <Cale> yes.
22:56:55 * shachaf isn't sure, actually.
22:57:06 <Cale> Well, I think it's the root window. :)
22:58:09 <glguy> so... to use the XMonadContrib.Circle... the source file just says to include it, is there some trick to enabling it?
22:58:10 <brad> somewhat unrelated question about darcs - i just upgrade my home box to 1.0.9 and my isp uses 1.0.8. i can't seem to push my code anymore. any ideas?
22:58:40 <Cale> hmm, maybe not. Perhaps it's a window that's just really large :)
22:58:52 <shachaf> glguy: It's a layout.
22:59:02 <shachaf> glguy: Add it to your defaultLayouts (is that the name?).
22:59:12 <Cale> I think it just covers up the root window.
22:59:12 <glguy> got it
23:00:52 <glguy> I'll grant that this circle layout is at least weird
23:01:03 * shachaf has never understood that one.
23:01:16 <shachaf> @resolution glguy
23:01:16 <lambdabot> Unknown command, try @list
23:01:20 <Cale> What does it look like?
23:01:23 <glguy> 1440x900
23:01:35 <glguy> Cale: one big window in the middle surrounded by little windows on the edges
23:01:42 <shachaf> Cale: http://xmonad.org/contrib.html
23:01:44 <lambdabot> Title: xmonad : contributed code
23:01:55 <glguy> it wastes the corners of the screen
23:01:59 <shachaf> glguy: Oh, I thought they all had equal sizing.
23:02:05 <glguy> the little ones are all equal
23:02:18 <shachaf> The corners are the best part!
23:02:27 * shachaf crunches on the corner of his screen.
23:02:35 <shachaf> No wonder my computer's not working...
23:03:10 <Cale> Your computer is not a food!
23:03:19 <Saizan> 7/j #emacs
23:03:27 <glguy> noooo, don't do it
23:03:38 <Cale> No drowning!
23:03:52 <glguy> what does: resize viewed windows to the correct size
23:03:53 <glguy> mean?
23:04:10 <shachaf> glguy: Context? Circle?
23:04:15 <glguy> its in the man page
23:04:18 <glguy> mod-
23:04:18 <glguy> n
23:04:28 <shachaf> glguy: It refreshes the windows, I think.
23:04:35 <shachaf> glguy: If they think they have the wrong size.
23:04:39 <glguy> and mod-q doesn't seen to restart xmonad for me
23:04:41 <shachaf> "Nudge", yes?
23:04:46 <shachaf> glguy: How do you know? :-)
23:04:59 <glguy> obviously I replaced the executable
23:05:06 <glguy> and the changes didn't appear
23:05:09 <shachaf> glguy: The restarts are entirely transparent.
23:05:15 <shachaf> glguy: What changes?
23:05:21 <glguy> adding support for circle
23:05:23 <sjanssen> glguy: is xmonad in your PATH?
23:05:33 <glguy> good question
23:05:45 <glguy> nope :)
23:06:21 * shachaf has added (spawn "xrefresh -solid green") or similar to mod-q, just so he'll know it did something.
23:07:07 <shachaf> sjanssen: On contrib.html, s/supportslogging/supports logging/
23:08:48 <sjanssen> shachaf: fixed
23:09:06 <glguy> heh, the restarts really are silent :)
23:09:08 <glguy> and they work now
23:09:22 <shachaf> sjanssen: OK, thanks.
23:10:17 <shachaf> sjanssen: (I hope you don't mind this unrequested proofreading.)
23:10:38 <sjanssen> shachaf: feel free
23:11:05 <sjanssen> get the darcs repo if you really want to go to town :) http://www.cse.unsw.edu.au/~dons/code/xmonad-web
23:11:05 <lambdabot> Title: xmonad : a tiling window manager
23:12:27 <shachaf> sjanssen: I would if I had my computer available. :-)
23:12:35 * shachaf can't even darcs get here.
23:17:03 <shachaf> Is the problem with copying over a running file going to be fixed sometime?
23:18:43 <Saizan> when they decide to drop conformity with windows i think :)
23:19:15 <Cale> which problem is that?
23:19:37 <shachaf> Cale: runhaskell Setup install won't overwrite a running binary.
23:19:45 <scodil> how does upgrading from ghc-6.6 to 6.6.1 affect installed packages? can I just install over 6.6 in the same dir, or do I have to wipe it clean and reinstall everything?
23:19:49 <Cale> How does it tell the binary is running?
23:19:58 <glguy> Cale: linux knows
23:20:06 <shachaf> 01:14 < glguy> *** Exception: /home/emertens/bin/xmonad: copyFile: resource busy (Text file busy)
23:20:18 <Cale> glguy: sure, but you'd have to go out of your way, wouldn't you?
23:20:20 <dons> http://programming.reddit.com/info/27azk/comments
23:20:22 <lambdabot> Title: A neat game with a really neat solution: puzzle fun in Haskell (reddit.com)
23:22:45 * glguy remebers someone coming to #haskell earlier asking for : replicateM 5 $ replicateM 5 $ randomRIO (0,4)
23:23:05 <glguy> andomMat :: IO Matrix
23:23:06 <glguy> randomMat = replicateM 5 $ replicateM 5 $ randomRIO (0,4)
23:23:14 * glguy claims that code in the blog linked by dons ;)
23:23:41 <dons> quite likely it was cdsmith :)
23:23:53 <glguy> that would explain the url
23:25:53 * Saizan would feel bad about typing replicateM 5 twice, join (.) ftw
23:26:24 <glguy> lol, because that would be appropriate in a "let's learn Haskell" blog entry ;)
23:27:30 <Cale> Heh, mentioning the determinant was kind of a big hint, don't you think?
23:27:47 <Cale> hmm...
23:27:49 <Cale> hehehe
23:27:55 <glguy> a system of linear equations??
23:28:02 <Cale> No way!
23:28:06 <Cale> hehe
23:28:22 * glguy wonders how to change the z-order of floated windows
23:28:38 * glguy discovers the dual-purpose of mod-return
23:28:51 <shachaf> glguy: Mod-middle-click?
23:29:09 <glguy> yeah, that works too, but my laptop has only two buttons... so its not as convenient
23:29:20 <glguy> (rather, I didn't think to try that)
23:29:26 <shachaf> glguy: Emulate3buttons.
23:29:36 <glguy> right, pressing both works, I just don't do it much
23:29:45 <shachaf> If the buttons are close to each other, you can press between them.
23:29:50 <shachaf> It works well in some cases.
23:29:54 <glguy> yup, that's what I end up doing
23:30:01 * shachaf thinks all this should really be in #xmonad.
23:30:17 <glguy> because you don't want to pollute #haskell, or to liven up #xmonad?
23:30:47 <scodil> does lambdabot have an echo feature?
23:30:53 <shachaf> @id a
23:30:53 <lambdabot>  a
23:30:55 <glguy> ?read "yeah"
23:30:55 <lambdabot>  yeah
23:31:00 <scodil> there you go
23:31:03 <scodil> echo to #xmonad
23:31:19 <glguy> oh, a relay feature?
23:31:23 <scodil> yeah, that
23:31:41 <glguy> not that I'm aware of
23:32:14 <shachaf> > tails "echo" -- This kind, maybe? :-)
23:32:15 <lambdabot>  ["echo","cho","ho","o",""]
23:32:25 <scodil> cho ho
23:33:05 <glguy> sweet, my cpu is idle 199%
23:33:19 * glguy should start compiling something
23:33:36 <glguy> xmonad is no good at making use of my cpu :(
23:33:47 <scodil> i'm sure that can be fixed
23:33:54 <shachaf> glguy: Use compiz. :-)
23:34:06 <edwardk> anyone here familiar with tango trees?
23:34:18 <edwardk> the data structure not the physical tree =)
23:34:32 <scodil> the names that people come up with for their data structures / algorithms
23:34:35 <scodil> gotta have a snappy name
23:35:05 <edwardk> i'm just looking at them and they seem like a slightly modified second order zipper over a binary tree is all
23:35:52 <edwardk> or maybe where the first order zipper gives a list-like path, then they maintain the list as a tree rather than as a list
23:35:53 <scodil> i look forward to a paper detailing the zipper-tango-foxtrot isomorphism
23:36:00 <edwardk> scodil: =)
23:37:38 <edwardk> http://theory.lcs.mit.edu/~edemaine/theses/dharmon.pdf describes them but the picture on page 3 of http://compgeom.cs.uiuc.edu/~jeffe/teaching/573/notes/03-wilber-tango.pdf makes the zipper analogy leap out at you.
23:38:54 <edwardk> but when you look at them in that context the fact that they work well with data locality and recent references becomes kind of a 'duh' =)
23:38:55 <shachaf> Is it possible to make an Monad instance for lists where liftM2 behaves like zipWith?
23:39:24 <edwardk> hrmm
23:39:25 <glguy> shachaf: You could make an instance of Applicative like that, iirc
23:39:53 <edwardk> m (a -> b) -> m a -> m b works, so yeah, applicative holds
23:39:56 <shachaf> glguy: I meant Applicative, I guess. Though a monad would be interesting.
23:40:13 <shachaf> If it's not a monad, it's also interesting. :-)
23:40:52 <edwardk> i can't think of a meaningful join for the zipWith applicative
23:40:59 <edwardk> so i'd think a monad is out.
23:41:21 <shachaf> @hoogle [[a]] -> [a]
23:41:21 <lambdabot> Prelude.concat :: [[a]] -> [a]
23:41:33 <edwardk> wrong semantics you get back the existing list monad
23:41:43 <edwardk> which is concatMap =)
23:42:48 <edwardk> in fact, there is a ZipList applicative already
23:42:56 <shachaf> There is?
23:42:57 <shachaf> Oh.
23:43:01 <edwardk> which I presume they would have made a monad if they could have =)
23:43:04 <edwardk> @src ZipList
23:43:04 <lambdabot> Source not found. Wrong!  You cheating scum!
23:43:06 <edwardk> gah
23:43:10 <shachaf> Never mind, then. :-)
23:43:12 <edwardk> http://cvs.haskell.org/Hugs/pages/libraries/base/Control-Applicative.html
23:43:14 <edwardk> =)
23:43:16 <lambdabot> http://tinyurl.com/2ebffy
23:44:19 * shachaf was actually curious what a monad would behave like.
23:44:27 <shachaf> I had not thought of an Applicative, which makes more sense.
23:44:48 <edwardk> hrmm, so what interesting restricted applicatives are there?
23:45:20 <edwardk> er restricted like restricted monads i mean, so you can stick typeclass constraints on a and b.
23:45:39 <edwardk> Set and Bag drop out immediately, because they are restricted monads.
23:46:32 <shachaf> Is there anything like Applicative comprehensions, approximately? Would something like that work?
23:46:38 <edwardk> a sorted list rapplicative would also be a sorted list rmonad.
23:46:46 <shachaf> (I.e., that would work like zip for lists.)
23:47:02 <edwardk> shachaf: fraid not.
23:47:21 <shachaf> Oh, well.
23:47:31 <edwardk> Applicative was kind of late to the game =)
23:47:52 * shachaf would like something like list comprehensions, only... Flatter. :-)
23:48:19 <edwardk> well, you can do parallel list comprehensions
23:48:37 <edwardk> > [ (x,y) | x <- [1..4] | y <- [5..6] ]
23:48:37 <lambdabot>  Parse error
23:48:46 <edwardk> no support in lambdabot?
23:49:16 <Japsu> > [ (x,y) | x <- [1..4], y <- [5..6] ]
23:49:17 <lambdabot>  [(1,5),(1,6),(2,5),(2,6),(3,5),(3,6),(4,5),(4,6)]
23:49:23 <edwardk> Prelude>  [ (x,y) | x <- [1..4] | y <- [5..6] ]     ==> [(1,5),(2,6)]
23:49:33 <shachaf> What do those translate into?
23:49:35 <edwardk> the second | makes it a parallel comprehension with zip-like semantics
23:49:53 <Japsu> hmm hmm
23:50:26 <edwardk> shachaf they desugar internally into something like [ (x,y) | (x,y) <- zip [1..4] [5..6] ]
23:50:35 <shachaf> edwardk: Oh. :-(
23:50:38 <glguy> Prelude> [ (x,y) | x <- [1..10], even x | y <- [5..7]]
23:50:38 <glguy> [(2,5),(4,6),(6,7)]
23:50:43 <dons> shapr: hey, did you ever get haskell running on your nokia e70 or what was it?
23:50:48 <glguy> where it gets interesting is the guards
23:50:52 <edwardk> yeah
23:50:54 <dons> i'm looking to get a phone.. pref. one that can do stuff
23:51:09 <glguy> dons: get an iPhone so that John isn't the only one with one
23:51:27 <dons> heh. did you see the great iphone v nokia rant on reddit, gl	?
23:51:37 <dons> gl-slow tab in irssi
23:51:59 <glguy> dons: I sure didn't , was that on the programming subreddit?
23:52:42 <dons> nsfw possibly, http://duggmirror.com/apple/The_iPhone_is_a_piece_of_shit_and_so_is_your_face/?u=iphone
23:52:45 <lambdabot> Title: The iPhone is a piece of shit, and so is your face., http://tinyurl.com/2j9dhu
23:53:16 <glguy> wow
23:53:18 <opqdonut> ahaha
23:53:22 <opqdonut> that's a great one
23:53:27 <glguy> BAMN!
23:53:37 <opqdonut> with all the animated gifs :D
23:54:15 <dons> yeah, it sets a new standard in rant
23:54:18 <scodil> !!1ONE lim x -> 0 .... is classic
23:54:23 <edwardk> heh
23:54:27 <glguy> my laptop is a clock, a chat client, and a lap warmer, all in one!
23:55:04 * glguy is sold on the nokia
23:55:09 <glguy> i just saw the putty terminal
23:55:31 <dons> yeah. that sold me too
23:55:40 <glguy> What that means in non-geek is that my phone is invincible. I can literally do anything
23:55:40 <dons> and shaprs got one ( i think)
23:56:07 <edwardk> "I think I'll take the rest of the afternoon off and copy and paste text on my cellphone because I can."
23:56:24 <glguy>  Screen turns into a smudgy piece of shit after a few minutes of use: CHECK
23:57:42 <glguy> "it's called the Nokia E70, it's the pinnacle of human achievement, and I love it more than my family:
23:58:02 * glguy doesn't need a cool phone because he has a cool puppy
23:58:07 <dons> heh
23:58:29 <glguy> I got the "free" phone from Verizon
