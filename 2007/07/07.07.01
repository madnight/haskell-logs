00:34:43 <greenrd> I did it! I figured out my <<loop>> bug by thinking about it, instead of fiddling!
00:34:47 <greenrd> I must try that more often
00:37:11 <JKnecht> fiddle de Di
00:39:36 <crazy_code2> One question guys : I am getting to do an internship for 3 months at a local Software company
00:40:16 <crazy_code2> The incharge over there has asked to do any project which I am interested in. They will basically guide if I have any problem
00:40:49 <crazy_code2> I have decided to implement an interpreter and do a RSS reader as a project for this internship.
00:41:08 <crazy_code2> Does anyone think it will be a trivial project, should I do something better
00:41:21 <JKnecht> in haskell?
00:41:26 <crazy_code2> yes
00:41:39 <crazy_code2> cause the people at that company do R&D work and are really smart
00:42:07 <JKnecht> not just smart?
00:42:08 <crazy_code2> Or should I do this as a personal project and do something better over ther
00:42:24 <crazy_code2> JKnecht: ??
00:42:31 <greenrd> seems like a mismatch
00:43:03 <crazy_code2> you mean 'R&D' and 'smart'  don't go along ?
00:43:06 <greenrd> no
00:43:20 <greenrd> one is more computer sciency, the other (RSS reader) is more practical
00:43:21 <crazy_code2> ok lets only consider they do R&D work Ok?
00:43:29 <crazy_code2> Oh
00:43:29 <greenrd> what is the interpreter going to be for?
00:43:42 <crazy_code2> Maybe Haskell or Scheme
00:43:56 <crazy_code2> Actually I am from EE background
00:44:00 <greenrd> I see
00:44:13 <greenrd> I don't think an RSS reader is a challenging enough problem
00:44:14 <crazy_code2> So I want to do projects which give me experience all round
00:44:19 <greenrd> it's a pretty simple task
00:44:32 <dons> a haskell interpreter would be a fair bit of work. you'd learn an awful lot.
00:44:46 <dons> rss reader is 50 lines of code
00:45:01 <greenrd> - well, depending on how fancy you make the interface
00:45:01 <crazy_code2> Any suggestions as to what other things I could do
00:45:09 <dons> depending on the gui, yeah
00:45:25 <crazy_code2> yeah, I decided to do RSS reader having a GUI
00:45:27 <dons> crazy_code2: well, what kind of company are you interning at?
00:45:31 <crazy_code2> Is it fair enough
00:45:35 <greenrd> yeah, what industry are they in?
00:45:46 <dons> here's a 50 line rss aggregator, http://cale.yi.org/index.php/HRSS
00:45:48 <lambdabot> Title: HRSS - CaleWiki
00:45:54 <crazy_code2> dons: They work in all fields of engg.
00:46:05 <greenrd> are they a dedicated software development company, or are they in some other industry?
00:46:07 <crazy_code2> Like multi-disciplinary
00:46:08 <greenrd> ok
00:46:09 <dons> do they use some tools internally you could rewrite/
00:46:25 <JKnecht> no. just clarifying the hedge on 'smart' to be 'really'. Check what's out there (hs-wise) if not RSSey, then related. Fit it into what's going in the shop in a neat app concept.
00:46:28 <crazy_code2> They said nothing about that
00:46:53 <dons> often companies have some ad hoc tools that should really be rewritten properly designed -- doing one of those can be rewarding/get you a job :-)
00:47:10 <greenrd> heh, good idea
00:47:26 <crazy_code2> No basically this internship is going to be about learning and not for anything else
00:47:27 <greenrd> or, they can result in "Hey, I can't maintain this! It's in some weird language called Haskell!" ;)
00:47:46 <dons> crazy_code2: so more like the google summer of code?
00:47:46 <greenrd> that's cool of them, crazy_code2
00:47:51 <greenrd> it's a good opportunity
00:47:53 <dons> you just work on some project the community needs/
00:47:54 * JKnecht presumes said shop already using or desiring hs.
00:47:55 <crazy_code2> yes
00:47:56 <greenrd> make the most of it!
00:48:14 <crazy_code2> greenrd: yeah
00:48:18 <crazy_code2> Hope so.
00:48:26 <crazy_code2> So whats the bottomline
00:48:26 <greenrd> I suggest you do something that's so cool it will blow their socks off
00:48:31 <greenrd> hmm
00:48:42 <crazy_code2> Do an interpreter and a RSS reader with GUI ?
00:49:17 <dons> if you're into rss, maybe you could write a really good gui/rss reader. not very technically challenging though. you'd get a good grounding in haskell
00:49:27 <dons> here's the hsakell summer of code ideas,
00:49:27 <crazy_code2> greenrd: yes, thats what I want to do ;)
00:49:30 <dons> http://hackage.haskell.org/trac/summer-of-code/query?status=new&status=assigned&status=reopened&group=topic&type=proposed-project&order=priority
00:49:32 <lambdabot> Title: Custom Query - Haskell.org Google Summer of Code - Trac, http://tinyurl.com/fl2dw
00:49:35 <dons> maybe there's some ideas there
00:49:50 <dons> write a library for parsing and printing C. :-)
00:49:56 <greenrd> crazy_code2: what major software projects have you done in the past?
00:50:17 <crazy_code2> greenrd: The problem is that I have done nothing in the past
00:50:20 <greenrd> ok
00:50:29 <greenrd> how much programming experience then?
00:50:38 <crazy_code2> I don't and won't do something I know I can't and waste this opportunity
00:51:00 <crazy_code2> Like 1- 1 and a half years. Haskell learning for last 10 days
00:51:41 <crazy_code2> Learnt C/C++/Scheme (somewhat)       and HTML and XML./CSS in bits and parts
00:52:00 <greenrd> you might want to look at some of the programming competition sites
00:52:36 <greenrd> they have a good range of interesting problems, although they vary in usefulness - some are toy projects with no real-world usefulness
00:53:03 <greenrd> might give you some more ideas anyway
00:53:35 <crazy_code2> dons: Anything from the SOC projects would be a cool project right ??
00:53:53 <dons> well, they're topics others have thought would be useful or fun to do
00:53:59 <dons> so yeah, mostly.
00:54:04 <dons> some are very hard.
00:54:38 <crazy_code2> Ok thanks. Lets see I'll try my best :)
00:54:42 <dons> some of the library stuff would benefit a lot of people
00:54:52 <dons> you could pick a C library to bind to, then write a haskell program that uses the library
00:56:18 <crazy_code2> what does 'C library to bind to ' mean :( Sorry for being so naive
00:57:57 <dons> oh, if there's a C library that does something cool, you can write a haskell interface to that
00:58:09 <dons> which makes it available to haskell
00:58:18 <dons> then you can write haskell programs that use the C library underneath
00:58:33 <dons> this is good, since you can reuse some big, standard C library
00:58:51 <Svrog> what is the correct way to convert lazy bytestrings to strict ones? pattern match against the LPS constructor and do ByteString.concat?
00:59:32 <crazy_code2> dons : So I will write in Haskell code something similar to the library functions in C? how should one go about it
01:00:24 <dmwit> crazy_code2: That's probably impractical for most libraries; instead, check out the foreign-function interface.
01:00:32 <dmwit> That allows you to call C functions from Haskell code.
01:00:33 <scook0> crazy_code2: not quite
01:00:57 <dmwit> Then, making a binding means making a complete set of FFI calls for that library, so that people can call it straight from Haskell.
01:01:22 <dmwit> It might also mean thinking about how to modify the interface to be more Haskellic.
01:01:26 <dons> yeah, say we wanted to use the big `openssl' library from haskell
01:01:47 <dons> you'd write 'bindings' to the C functions, that then give you a haskell wrapper
01:01:54 <dons> using the FFI: the foreign function interface
01:02:16 <dons> crazy_code2: the key would be to find a C library you wanted to write an app in
01:02:25 <dons> but then write the app in haskell instead, and use your binding to the C library
01:02:30 <dons> so you don't hvae to write in C :-)
01:02:36 <crazy_code2> So I'll have to learn Haskell in depth, FFI and also read and understand some good C library
01:02:51 <dons> that'd be an excellent way to spend the summer, in my view.
01:03:00 <dons> and you'd hvae useful code at the end, that the whole community could use.
01:03:14 <crazy_code2> dons: yes Thanks :)
01:03:16 <dons> its basically the approach the summer of code takes as well: write library, so everyone benefits.
01:03:41 <dons> so, it comes down to picking some library that you want to use
01:03:46 <crazy_code2> dons: So doing this single project would suffice and be really cool right ?
01:03:49 <dons> libxml for parsing rss feeds ... for example :-)
01:04:00 <dons> yeah, you'd write the library binding, and some application in haskell that used it
01:04:17 <crazy_code2> dons: great :)
01:04:43 <crazy_code2> I love the level of thinking you guys have. Thanks It sound really cool
01:04:57 <crazy_code2> I hope I'll be able to do it
01:05:02 <dons> the important thing would be to find something you *want* to use.
01:05:10 <dons> since that gives good motivation to work at it.
01:05:28 <crazy_code2> yes, the motivations the most important thing :)
01:05:30 <dons> e.g. if you wanted to write games, you'd write a binding to some game engine, then a haskell game that used it
01:06:02 <mgsloan> or improve frag ;)
01:08:19 <greenrd> crazy_code2: I hope the company will allow you to release your code to community as open source
01:09:43 <crazy_code2> Sure they will I'll write it myself entirely
01:09:57 <mgsloan> hehe
01:10:40 <mgsloan> Most of the time code you write for a company is owned by the company
01:10:48 <mgsloan> probably not in this case, though
01:10:54 <mgsloan> if its a learning thing
01:11:14 <crazy_code2> oh Ok. But i'll sure they will be happy to open source it too ;)
01:11:26 <mgsloan> in this case, probably
01:12:07 <mgsloan> so, do you actually get to go to the company and such?  I've been working on getting an internshipish thing like that as well
01:13:09 <mgsloan> there's a google thing in the works, but it'd be from home like a SoC
01:13:24 <dmwit> Uhhh.
01:13:29 <dmwit> What package is System.IO in?
01:13:54 <mgsloan> base
01:14:08 <crazy_code2> mgsloan: Actually I haven't got it completely so to say. I and 3 of my friends approached this company, The incharge told us he will have an interview with us on 10th July, he'll select us. I am sure I'll be selected.
01:14:19 <dmwit> ...I'm in big trouble.
01:14:36 <dmwit> "Failed to load interface for `System.IO'"
01:14:38 <mgsloan> ah, I see
01:14:58 <crazy_code2> We have to work for 4 hours. Not compusorly though
01:15:56 <crazy_code2> gtg. Cya later. Thanks for the ideas. I hope I'' live up to the expections :) ;)
01:18:13 <dons> dmwit: sounds not good
01:22:11 <swiert> dmwit: try using --make.
01:35:26 <mgsloan> heh: http://www.urbandictionary.com/define.php?term=monad
01:35:28 <lambdabot> Title: Urban Dictionary: monad
01:36:27 <dons> hah
01:36:40 <dmwit> swiert: I get this on *ghci*. =P
01:36:44 <dons> i think #3 is surely a joke.
01:36:47 <dmwit> I'll reinstall tomorrow, it's probably my fault.
01:37:35 <mgsloan> actually I think #3 doesn't know about real monads.  It's from the microsoft .net shell called "monad"
01:37:42 <dons> yeah
01:37:48 <dons> but funny in a haskell context :-)
01:37:52 <swiert> http://www.urbandictionary.com/define.php?term=haskell
01:37:54 <mgsloan> indeed :)
01:37:54 <lambdabot> Title: Urban Dictionary: haskell
01:37:57 <swiert> Is surprisingly accurate
01:38:06 <mgsloan> haha
01:38:24 <dons> heh
01:39:00 <dons> and, of course, a job advert for janest on the side.
01:39:55 <dons> this fold-your-tshirt thing on reddit is very cute. must use this technique.
01:40:24 <dons> http://fold-your-shirt.com/video/fold-your-shirt.mpg (OT, really about folding tshirts)
01:41:42 <Svrog> how would i go about contributing a library to ghc?
01:42:22 <dons> Svrog: you'd follow the guide here: http://haskell.org/haskellwiki/How_to_write_a_Haskell_program
01:42:23 <lambdabot> Title: How to write a Haskell program - HaskellWiki
01:42:28 <dons> and upload it to hackage.haskell.org
01:42:32 <Svrog> ah
01:42:34 <Svrog> thanks
01:42:58 <dons> the first link mentions how to use cabal, and haddock to automate doc generation. once its on hackage, everyone can find and use it.
01:43:37 <Svrog> yeah i already figured id have to do all that - im using existing ghc libs as reference for how to structure and document things
01:43:47 <ttmrichter> Silly question time: how do I get a cabal project to make a shared library instead of a static one?
01:44:00 <dons> yep. some small ones on hackage are also useful. see the 'dlist' package as an example
01:44:19 <dons> ttmrichter: shared libraries in the unix dlopen style?
01:44:33 <ttmrichter> Yes.  .so files, etc.
01:44:38 <dons> ghc allows dynamically linked libs on certain archs, but its a bit complicated, and not supported by cabal yet, afaik
01:44:46 <ttmrichter> OK.  Not a problem.
01:44:49 <dons> there's a soc project to sort this out. talk to therp.
01:44:52 <ttmrichter> Saves me some doc-diving.
01:45:08 <dons> there's some special docs for dlls on windows
01:45:09 <ttmrichter> Oh, it's not a huge deal.  Knowing it doesn't work that way means I'm spared some research time.  :)
01:45:20 <dons> but on unix, best not to bother if its not critical
01:45:25 <dons> yeah
01:45:35 <ttmrichter> I'm actually very impressed with Cabal's smarts.
01:46:03 <dons> it builds haskell project pretty well, yep.
01:46:09 <dons> way better than the bad old makefile days
01:46:21 <dons> and we've seen an explosion in useful libs, as a result
01:46:22 <ttmrichter> I've made a gonzo-complicated package structure just to fool around with a Cabal project.  It does a very good job at figuring out what I mean without me telling it.
01:46:29 <mgsloan> dyncamically linkage seems like it'd be very hard
01:47:09 <ttmrichter> Oh, is Data.Text.YAML the right namespace for a YAML processor?
01:47:36 <ttmrichter> Or is there a better place in the tree to drop it?
01:48:27 <augustss_> good morning
01:48:43 <dons> Data.Text, no, don't think so.
01:48:50 <dons> what is it , a parser for yaml?
01:49:00 <ttmrichter> Not a parser, no.
01:49:03 <dons> morning augustss_
01:49:08 <ttmrichter> Parser is a small part of a YAML processor.
01:49:29 <dons> ttmrichter: i note the hssyck lib uses Data.Yaml.Syck
01:49:41 <dons> so possibly Data.Yaml.Something?
01:49:44 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HsSyck-0.4
01:49:47 <lambdabot> http://tinyurl.com/yw5adl
01:49:59 <xpika> is there a function to work out the bounds of a list?
01:50:08 <ttmrichter> OK, that sounds plausible.
01:50:10 <dons> 'length' ?
01:50:20 <dons> xpika: or you mean the min and max elements?
01:50:26 <xpika> (\xs->(maximum xs,minimum xs))
01:50:38 <dons> that's it there. :-)
01:50:41 <xpika> seems inefficient
01:50:56 <dons> you could write your own fused version that avoids the traversals
01:51:17 <dons> ?src maximum
01:51:17 <lambdabot> maximum [] = undefined
01:51:18 <lambdabot> maximum xs = foldl1 max xs
01:51:26 <rretzbach1> grandparent s = parent s >>= parent -- Would you use the do notation here too?
01:54:07 <dons> ?let maxmin = \x -> foldr (\a (b1,b2) -> (min a b1, max a b2)) (head x,head x) x
01:54:07 <lambdabot> <local>:15:47:     Ambiguous type variable `a' in the constraint:       `Ord ...
01:54:35 <MarcWebe1> The documentation of happy states that you can't have more than one yacc parsers.. Why is this the case?
01:54:44 <dons> ?let maxmin :: (Ord a) => [a] -> (a,a) ; maxmin x = foldr (\a (b1,b2) -> (min a b1, max a b2)) (head x,head x) x
01:54:47 <lambdabot> Defined.
01:54:52 <dons> > maxmin "haskell"
01:54:53 <lambdabot>  ('a','s')
01:54:58 <TSC> Seems like a good place for an arrow or two
01:55:12 <dons> it does. arrows: the best tuple dsl we've got
01:55:29 <mgsloan> hmm, why is forall required for existential types?  seems to me it could just assume it, as it does in normal func defs
01:55:44 <mgsloan> (assume it when the type var isn't part of the type decl)
01:55:58 <dons> distinguishes a typo, from an explicit local tyvar binding.
01:56:06 <mgsloan> ah
01:56:11 <dons> so that we don't let typos into programs, yielding weird errors :-)
01:56:24 <TSC> :t (***)
01:56:26 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
01:56:53 <mgsloan> well, I must say that for me, GADTs cleared up existential types quite a bit
01:58:10 <mgsloan> I suppose the type for *** gives another example of the usefulness of forall
01:58:26 <mgsloan> (hmm, can you do that!??!)
01:58:34 <mgsloan> I thought kinds never popped up in actual code
01:59:37 <dons> ghc lets you write explicit type variable bindings, and kind annotations
01:59:50 <mgsloan> ah
02:00:53 <dons> so much documentation in the type for (***).
02:00:54 <mgsloan> yeah, actually that's probably not a good example,  as the a :: * -> * -> * business is somewhat implicit in Arrow a, i think
02:01:09 <dons> ?src Arrow
02:01:09 <lambdabot> class Arrow a where
02:01:09 <lambdabot>     arr, pure   :: (b -> c) -> a b c
02:01:09 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
02:01:09 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
02:01:09 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
02:01:11 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
02:01:13 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
02:01:25 <dons> maybe classes should come with kind annotations
02:01:35 <dons> would help with reading new monad transformers
02:01:35 <mgsloan> maybe so
02:01:45 <dons> rather than inferring the kind from the methods of the class
02:01:56 <mgsloan> is it valid syntax?
02:02:00 <dons> class  Arrow (a : * -> * -> *) where ..
02:02:03 <dons> is likely valid in ghc
02:03:00 <mgsloan> class forall (a:: * -> * -> *). Arrow a where
02:03:00 <mgsloan> not this?
02:07:15 <dons> might make 'Arrow a' look like a type application
02:07:43 <dons> actually, kind annotations are needed for the index type family stuff
02:08:07 <dons> class GMapKey k where
02:08:07 <dons>   data GMap k :: * -> *
02:08:07 <dons>   empty       :: GMap k v
02:08:24 <dons> data family Array :: * -> *
02:08:27 <dons> that kind of thing
02:08:28 <mgsloan> ooh, are traits actually implemented?
02:08:34 <dons> http://haskell.org/haskellwiki/GHC/Indexed_types
02:08:36 <lambdabot> Title: GHC/Indexed types - HaskellWiki
02:08:47 <dons> traits?
02:08:50 <mgsloan> sweet
02:09:02 <dons> the above is in ghc head, yeah
02:09:05 <mgsloan> in C++ things like that are called traits
02:09:15 <dons> a whole new world of type indexed type programming
02:09:21 <dons> ah yes.
02:09:27 <dons> its related to C++ template programming, anyway
02:09:31 <mgsloan> yes
02:10:04 <dons> C++ is mentioned briefly in these slides http://programming.reddit.com/goto?id=1z3or
02:10:12 <dons> (on indexed types)
02:10:19 <mgsloan> yes, I believe I saw those slides
02:10:31 <mgsloan> but didn't know that it was actually implemented
02:11:22 <mgsloan> yeah, at the end it says "Class Families: Just an idea at this stage"
02:11:29 <dons> yes, 'trait classes in C++'
02:11:34 <dons> class families are just an idea
02:11:40 <dons> that's class X a where
02:11:46 <dons>         class MyClass
02:11:58 <dons> but associated data and newtypes are in, and type synonyms are almost done.
02:12:21 <mgsloan> ah, hmm
02:12:33 <dons> i'm looking forward  to having a go at rewriting mtl without functional dependencies
02:12:40 <dons> should be lots of fun type tricks we can do now
02:13:00 <mgsloan> yeah, fundeps should be mostly unnecessary
02:13:16 <jre2> dons: mind linking your uni's roll your own mini haskell compiler class again?
02:15:16 <dons> www.cse.unsw.edu.au/~cs3161
02:15:23 <jre2> dons: thanks!
02:15:26 <dons> mgsloan: yeah, they're implemented in terms of type families in ghc now.
02:15:39 <mgsloan> ah, interesting
02:16:21 <mgsloan> will these alleviate the funky cases of fundeps?
02:16:37 <dons> should obsolete them, i suspect.
02:16:58 <dons> fundeps are too hard
02:17:34 <mgsloan> eg,
02:17:34 <mgsloan> class Add a b c | a b -> c where (+) :: a -> b -> c
02:17:34 <mgsloan> instance (Add a b c) => Add [a] [b] [c] where ...
02:17:58 <mgsloan> Last time I tried this, anyway, it was illegal
02:31:44 <mgsloan> Looking at the syntax, I think one issue will be that the synonym/class families is that they look like current syntax
02:32:14 <mgsloan> class Collects c where
02:32:14 <mgsloan>     type Elem c
02:32:41 <mgsloan> well, that one's a bad example
02:33:03 <mgsloan> actually, never mind
02:33:18 <mgsloan> I guess its consistent with current syntax
02:36:44 <dancor> what is the right way to develop if you will eventually be using cabal for distribution
02:36:58 <dancor> do you just keep installing via cabal to run to test?
02:37:20 <dancor> or just build and execute dist/../<executable> (i don't think that works bc of paths)
02:37:33 <dancor> or do you not cabalize until the very end
02:37:43 <kfish> dancor: cabalize early and cabalize often
02:38:00 <dancor> waiting for installs while iterating seems a bit much
02:38:06 <kfish> you can run out of dist if that works for you
02:38:15 <dancor> and if it doesn't :)
02:38:25 <kfish> obviously if your app needs installed data files or something then you need to install
02:40:00 <dancor> yeah.  i guess i'll just make my own secondary build process for iterating if it gets to me enough.  thanks
02:41:17 <dancor> it might be cool to add it to cabal though too
02:41:36 <dancor> well i guess i'm really just talking about prefix=. with no data file copying
02:45:07 <kfish> dancor, i often run out of dist/, but making a little driver file that you can run from ghci is much nicer for trying things out quickly
03:02:50 <Figs> hi
03:03:03 <Figs> have any of you guys used Stratego/XT?
03:03:21 * Figs was wondering if it was similar to the logic behind programming in haskell
03:05:16 <psykotic> as far as i know, stratego is based on a very general notion of term rewriting. so i'd say it's quite far from haskell in most respects.
03:05:37 <Figs> well, I mean, it's designed for a fairly particular purpose
03:05:46 <Figs> but in terms of type transformations in haskell
03:05:52 <Figs> is the logic similar?
03:05:58 <Figs> or are these concepts very different?
03:06:17 <Figs> (I forget what term you guys use... constructors maybe?)
03:07:23 <psykotic> could you be more concrete? maybe give an example? what do you mean by type transformations?
03:09:25 <Figs> not sure if this is right, but something like: foo x y = bar 100 x y
03:10:06 <psykotic> oh, yes, you can define functions by pattern matching in haskell.
03:11:02 <psykotic> but compared to general term rewriting, it's very limited and fundamentally different.
03:11:29 <psykotic> for example, in a term rewriting language you could write something like (x + y) + z -> x + (y + z) as a rewriting rule to apply
03:12:37 <gour> hi, can anyone access http://www.realworldhaskell.org/blog/ site?
03:12:58 <gour> this one is ok http://book.realworldhaskell.org/
03:13:03 <lambdabot> Title: Real-World Haskell
03:13:17 <Figs> it's loading very slowly, if at all
03:13:23 <Figs> doesn't seem to be donig much
03:13:30 <Figs> *doing
03:14:15 <and1> It isn't complete I gues
03:14:28 <gour> i got "Could not connect to remote server" error
03:14:35 <dons> ok, looking into it
03:15:10 <Figs> psykotic: I don't know if I really understand the difference other than very narrow specification of part vs general
03:15:44 <psykotic> Figs, well, it's a little hard to summarize quickly, but one way of thinking about it is that haskell only allows local, context-free rewriting.
03:15:56 <psykotic> you can say what x + y should equal regardless of its context
03:16:07 <Figs> mmm ok
03:16:50 <Figs> is there a way of doing "objects" in haskell?
03:16:51 <psykotic> also, when you define it by pattern matching over x and y, you can only pattern match over _values_
03:16:54 <psykotic> whereas rewriting works in terms
03:17:26 <psykotic> what kind of objects?
03:17:33 <Figs> like, suppose I have something like
03:17:36 <Figs> foo x y z
03:17:46 <Figs> is there a way to get the y?
03:17:57 <psykotic> is foo a type constructor of some sort?
03:18:00 <Figs> yeah
03:18:04 <psykotic> yes of course
03:18:07 <Figs> how?
03:18:17 <Figs> (other than funky list order manipulation)
03:18:37 <Saizan> if you have data Foo a b c = Foo a b c, then you can getY (Foo _ y _) = y
03:18:54 <Saizan> +define
03:19:04 <psykotic> or more commonly you'll just decompose/pattern match over the Foo instance whenever you need to know
03:19:35 <Figs> is there anything in Haskell that isn't a type transformation?
03:19:51 <psykotic> Figs, you really should go and read something about the language first
03:20:01 <psykotic> it seems like you are trying to understand everything in terms of a vastly different language
03:20:17 <Figs> I've done some reading, but the syntax of haskell baffles me, even after reading the tutorials a couple times
03:20:28 <Figs> so I don't get their examples
03:20:37 <psykotic> do you know ML or any other functional languages aside from stratego?
03:20:39 * gour finds haskell syntax very clean
03:20:43 <Figs> I don't know stratego
03:20:47 <Figs> I just stumbled into it today
03:21:01 <psykotic> so what languages do you know well?
03:21:44 <Figs> all imperative based things (C++, and an application specific pascal/C style hybrid)
03:22:34 <Figs> so yes, it is quite different
03:22:36 <psykotic> maybe someone here knows an online-accessible tutorial appropriate to that sort of backgroun
03:22:53 <gour> haskell for C programmers ?
03:23:07 <psykotic> well, imperative programmers
03:23:09 <Saizan> one that explains how to use parentheses too :)
03:23:42 <Figs> geez... I'm looking at the syntax of Stratego... their example looks terrible
03:23:57 <gour> psykotic: i thought about http://www.haskell.org/~pairwise/intro/intro.html
03:23:58 <lambdabot> Title: Haskell for C Programmers
03:24:10 <psykotic> gour, ah right, that might be good
03:24:30 <gour> Figs: pls. see the above url
03:25:05 <Figs> taking a look, thanks
03:25:08 <Figs> :)
03:25:11 <Figs> might be what I need
03:26:42 * gour --> lunch
03:27:43 <Figs> thanks guys, I'll read this and come back later
03:27:45 <Figs> cya
03:43:49 <Figs> what's the best way to read:
03:43:49 <Figs> [ x + 1 | x <- nums ]
03:43:50 <Figs> ?
03:43:56 <Figs> (suppose nums is a list)
03:44:15 <Figs> read meaning, the expression in plain english...
03:44:34 <oerjan> "the list of x+1's, where x iterates through nums"?
03:44:42 <Figs> thanks
03:44:52 <Figs> and something like
03:45:03 <oerjan> (no guarantee on "best", of course :)
03:45:05 <Figs> [ x*x | x <- nums, x<7]?
03:45:35 <oerjan> this could get ugly
03:46:09 <dons> "x+1 for each x in nums" ?
03:46:11 <Figs> I'm guessing it means, the list of x*x's from nums taken if the term is less than 7?
03:46:20 <oerjan> right
03:46:21 <dons> "x*x for each x in nums such taht x < 7"
03:46:55 <Figs> ok
03:46:56 <Figs> thanks
03:47:07 <Figs> the C tutorial is very good so far
03:47:28 <Figs> but either I missed how to read the list comprehension, or it wasn't introduced and it was bugging me :P
03:47:54 <Lemmih> There's no 'madvice' on Linux?
03:48:09 <Figs> bbl
03:48:21 <dons> madvise
03:48:38 <Lemmih> Ah! Thanks.
03:50:52 <Svrog> can all fundeps be converted to indexed types?
03:52:38 <jedai> Figs: In fact the way dons read it is the mathematical way and it's probably one of the "best" (list comprehension are really close to mathematical notations)
03:55:47 <oerjan> curiously if you do that, wouldn't you have to change "let"s in list comprehensions to "where"?
03:57:04 <augustss_> I wish reddit had a feature so you could get a graph of how the points for a submission varies over time.  Just out of curiosity.
04:21:23 <gour> dons: what's wrong with 'realworld' site?
04:27:23 <ivanm> @where realworld
04:27:23 <lambdabot> I know nothing about realworld.
04:27:25 <ivanm> heh
04:31:29 <dons> i've forwarded it to bos for investigation
04:57:06 <gour> dons: ta
04:57:12 <Svrog> would a library for pattern matching on bits be appropriate under something like Data.Bits.Reader?
04:58:42 <MarcWebe1> it just works for most common cases ;)
04:59:06 <MarcWebe1> (cabal) ;)
05:12:23 <nominolo> Svrog: it might be included in the generalized Parsec
05:14:31 <Svrog> hmm.. i suppose it can be argued it's a parser but it's not anywhere near as general as parsec - it started as an attempt to properly get erlang style binary pattern matching in haskell and it's very similar to that
05:15:15 <dons> Svrog: we've thought a bit about Data.Binary.Bits or something
05:15:23 <dons> for a bit-layer parser for Data.Binary
05:15:35 <dons> maybe under Data.Binary.* ?
05:15:41 <Svrog> ah
05:15:53 <dons> note also, there's an existing binary patterns in the erlang style library, using Template Haskell
05:16:05 <dons> and we've got some ideas on how to do it very quickly with Data.Binary too
05:16:17 <Svrog> basically what ive written allows you to write do a :| b :| c <- matchBits (Word32 30 :| Word32 2 :| Int 8) ws; return (a, b, c)
05:16:25 <dons> this http://hackage.haskell.org/cgi-bin/hackage-scripts/package/BitSyntax-0.3http://hackage.haskell.org/cgi-bin/hackage-scripts/package/BitSyntax-0.3
05:16:28 <lambdabot> http://tinyurl.com/2dbzge
05:16:33 <dons> sorry, pasted it twice.
05:16:45 <dons> yeah, that looks nice.
05:17:07 <Svrog> dons: ive seen that BitSyntax and didnt like it - that was actually the reason why i wrote my own version
05:17:39 <dons> the TH is a bit too heavy, i agree.
05:17:44 <dons> one concern is speed.
05:18:01 <dons> we did a lot of work optimising Data.Binary -- you're not basing your stuff on top of that by chance, are you? :-)
05:18:17 <dons> either way, worth talking to dcoutts and kolmodin about how it works
05:18:18 <Svrog> no but i'll definitely have a look at it
05:18:22 <Svrog> i was using bytestrings
05:18:35 <dons> ok. lazy ones?
05:18:40 <Svrog> both
05:18:42 <Svrog> lazy and strict
05:18:47 <dons> that sounds a lot like the Put and Get layer in Data.Binary
05:18:56 <sphynx> hi!
05:18:58 <dons> which is basically a reader and writer for generating and taking apart lazy bytestrings
05:19:01 <dons> hey sphynx .
05:19:07 <Svrog> thats why i was asking earlier about a proper way to convert between lazy and strict bytestrings
05:19:19 <dcoutts> to/fromChunks
05:19:19 <dons> Svrog: ah right, toChunks/concat , fromChunks
05:19:32 <Svrog> don't exactly need that in the library but i was curious about how to do the conversion properly
05:19:34 <Svrog> ah, thanks
05:19:35 <sphynx> What should I use for fast regex matching only (without capture of substrings matched) for ByteStrings?
05:19:38 <dons> but i wouldn't roll another bytestring reader. you could probably build directly on top of Data.Binary.Put/Get
05:19:42 <sphynx> regex.dfa?
05:19:58 <dons> sphynx: hmm, pcre is good. but isSubstring is also ok.
05:20:04 <Svrog> no problem - ill have a look at Data.Binary
05:20:06 <dons> you can also roll your own very fast matcher using isPrefixOf
05:20:22 <dons> (for matching string literals)
05:21:09 <sphynx> dons, but I need to support wildcards, something like "ab*". I think, isSubstringOf doesn't support this, yes?
05:22:02 <dons> right.
05:22:17 <sphynx> dons: I'm using isSubstring at the moments and it is really fast
05:22:17 <dons> one of the regex libs on hackage should do, depending on what C libs you have available
05:22:26 <dons> its not as fast as it should be though :-)
05:22:34 <cinema> dons, are you aware of the problem compiling hs-plugins with Fedora 7 ?
05:22:41 <dons> dcoutts: that's something: isSubstring is too inefficent. a manual loop is isPrefixOf kicks it.
05:22:49 <dons> cinema: nope? using the darcs version?
05:22:55 <cinema> dons, yes
05:23:01 <dons> what error?
05:23:03 <sphynx> dons: but it suits to my efficiency needs perfectly. But I want to add functionality of regex searching..
05:23:04 <cinema> dons, it is in 'configure'
05:23:15 <dons> cinema: oh, something to do with meta chars?
05:23:21 <cinema> dons, the variable 'TOP' is wrongly initialized
05:23:24 <dcoutts> dons: the kmp matcher for isSubstring is woefully under-optimised
05:23:33 <dons> dcoutts: ah yes, you've seen that too :-)
05:23:46 <dons> yes, a manual strict loop is faster than the current impl. we should fix that.
05:23:52 <cinema> dons, with a linefeed or something like that
05:24:03 <dons> cinema: yeah, i thought we'd fixed that?
05:24:08 <sphynx> dons: are you using KMP algorythm for isSubstringOf?
05:24:10 <dcoutts> dons: I've looked a bit at matching algos, we should probably not be using kmp for strict bytestring
05:24:12 <dons> or maybe the fix was broke.
05:24:16 <dons> sphynx: we are, but not a very good one
05:24:30 <dcoutts> dons: on the other hand kmp would be great for streams, where re-winding the stream is hard
05:24:49 <cinema> dons, it doesn't work even with yesterday darcs's version
05:25:04 <dons> cinema: ok, perhaps manually edit the configure.ac to find out what the problem is
05:25:08 <sphynx> and another question about ByteStrings - is there some way to split by ByteString, not by Char?
05:25:18 <dons> cinema: might be this patch:
05:25:18 <dons> Sat Mar 17 09:47:55 EST 2007  Ian Lynagh <igloo@earth.li>
05:25:19 <dons>   * Strip \r's to fix building on Windows
05:25:19 <dons> ?
05:25:22 <dcoutts> dons: for ordinary stuff, the boyer style hashing one is fastest I think, so long as we can implement it well
05:25:33 <dons> sphynx: using a selection function?
05:25:38 <cinema> dons, I'll try
05:25:47 <dcoutts> sphynx: using search for substring and then take & drop, in an unfoldr
05:25:53 <dons> dcoutts: can you put some notes in the todo before we forget?
05:26:25 <sphynx> dcoutts: ahh, ok
05:26:59 <sphynx> dcoutts: I will try to implement
05:27:13 <sphynx> dons: do you mean the same as dcoutts?
05:27:43 <dcoutts> sphynx: see http://www-igm.univ-mlv.fr/~lecroq/string/
05:27:46 <lambdabot> Title: ESMAJ
05:28:04 <dcoutts> sphynx: it's Boyer-Moore I was thinking of
05:28:19 <dcoutts> for strict ByteStrings, for lazy something else might be easier
05:28:27 <dcoutts> something with no or limited backtracking
05:28:50 <dons> dcoutts: btw, any thoughts on other C libs we should be binding streaming stuff too?
05:29:00 <dons> openssl's md5 and sha are rather streamy, i saw.
05:29:04 <dons> that might make one cheap lib.
05:29:11 <dcoutts> mm
05:29:19 <dcoutts> dons: I'm nearly done with iconv
05:29:27 <dons> they actually can take a chunk, give you back a partial hash, and a seed for the next chunk
05:29:32 <dons> perfect for lazy bytestrings. good openssl.
05:29:37 <dcoutts> right, perfect for a foldl
05:29:47 <olsner> wow, that's a hefty list of string matching algorithms.. they should have a link up top for "the fastest one" though ;-)
05:29:50 <dons> yeah, all good libraries are bound to implement FP in the end ;)
05:30:25 <dcoutts> dons: oh, sorry gotta go, I realise I'm late for something...
05:30:32 <dons> ok, see ya.
05:31:26 <dons> yeah, my brute force strict isPrefix matcher is faster than isSubString currently
05:31:30 <dons> :(
05:31:34 <dons> we should kick bringert
05:32:51 <dons> apfelmus: your Dropper looks like a Stream
05:33:19 <apfelmus> it does :)
05:33:23 <olsner> brute force isPrefix, like (map (isPrefix ..) . tails) or something?
05:34:36 <apfelmus> or rather it's an unfold
05:34:40 <dons> data Stream a = forall s. Unlifted s =>
05:34:40 <dons>                           Stream !(s -> Step a s)  -- ^ a stepper function
05:34:40 <dons>                                  !s                -- ^ an initial state
05:34:40 <dons> data Step a s = Yield a !s | Skip    !s | Done
05:34:43 <dons> yes.
05:34:45 <dons> unfold++
05:35:02 <dons> and of course, we'd like to encourage everyone to write list functions with these guys in mind.
05:35:07 <dons> since they're nice and fast in ghc.
05:35:48 <apfelmus> actually, it's a mix of unfoldr and zip
05:36:24 <apfelmus> and does not Yield values
05:36:54 <apfelmus> it consumes them
05:37:08 <dons> yeah
05:37:11 <apfelmus> hm, so it ought to be a fold
05:37:23 <dons> Bail instead of Yield.
05:37:33 <greenrd> I've just had a good idea about mfix
05:37:43 <greenrd> mfixQ :: MonadFix m => (a -> m (a, m (a -> b))) -> m b
05:37:52 <sphynx> hmm. I wonder why maximum is defined like foldl1 max, not foldl1' max..
05:37:52 <greenrd> mfixQ f = (\(a, mf) -> ap mf $ return a) =<< mfix (f . fst)
05:37:55 <apfelmus> dons: not quite. Yield goes on
05:38:12 <greenrd> -- Allows you to queue monadic action functions for postprocessing
05:38:21 <greenrd> -- to avoid introducing looping data dependencies.
05:38:28 <greenrd> does this make sense? will it work?
05:38:41 <dons> yes, its a fold, isn't it. not a list being turned inside out. rather, you're folding it up to a value.
05:38:47 <dons> apfelmus: hence drop' being recursive.
05:39:45 <olsner> am I understanding that Stream type correctly if I say listToStream list = Stream (\l -> case l of (x:xs) -> (Yield x xs); [] -> Done) list?
05:40:02 <dons> yep
05:40:10 <olsner> what's Skip do?
05:40:12 <dons> that's the introduction form for Streams.
05:40:20 <dons> its used to implement filter, and other state transitions.
05:40:52 <apfelmus> dons: yes. just that the value of b is unimportant for acid drops
05:41:39 <olsner> so that's just a convenience so that the stream doesn't have to follow itself to the next unfiltered element?
05:42:15 <dons> olsner: it started like that, but it turns out to be very important to allow a wide range of non-recursive list functions
05:43:13 <dons> olsner: see http://www.cse.unsw.edu.au/~dons/code/streams/list/Data/Stream.hs
05:43:21 <apfelmus> the nice thing about Droppers is that they can be used with take or split, too
05:43:45 <apfelmus> split :: Dropper a b -> [a]Â -> ([a],[a])
05:44:05 <apfelmus> so, once you can drop prefixes, you can also split with them
06:13:09 <sphynx> hm, I asking on #darcs but nobody answers. Problem is following : I want darcs to manage my IM history logs and to merge between two versions - windows logs of gaim and linux logs of gaim. I've created two repos, added log files and reorded changes. Then I'm trying to push initial patch with ~1000 files from linux repo to win repo with ~500 files. This takes a lot of time and it seems that darcs hangs at end...
06:15:03 <sphynx> so darcs is not able to merge 1000 files in reasonable time (10-20 minutes)? :( Moreover: these files is different mainly, so it just needs to add it to repo without any merging at all...
06:15:20 <fasta> sphynx: what makes you think it hangs?
06:15:39 <siti> use git ;)
06:16:00 <sphynx> fasta: it works ~30 minutes..
06:16:13 <siti> git should do it in mins :p
06:16:14 <sphynx> fasta: I think it's too much for such a task, am I wrong?
06:16:25 <fasta> sphynx: I think you are wrong.
06:17:04 <sphynx> fasta: hm.. so what is reasonable time for such task?
06:17:05 <fasta> sphynx: I agree that one would wish things to go faster, but unless you are sure it really is in an infinite loop, it just is slow.
06:17:34 <siti> does darcs use bytestrings?
06:17:36 <sphynx> fasta: Yeah, I'm not sure if it hangs, I just assumed it
06:17:51 <siti> if it completes then it doesn't hang :P
06:18:13 <sphynx> siti: it can compete hours and hours )
06:18:32 <fasta> sphynx: you should check whether the list of open files changes during operation.
06:18:34 <siti> well, I suggest you try git
06:19:10 <fasta> Git worries me, because nobody understands what it does.
06:19:14 <siti> my guess is that darcs uses normal strings which could make it 10-20 times slower (just a guess)
06:19:20 <siti> lol, git rocks :D
06:21:54 <sphynx> fasta: my HDD led doesn't blink, it seems that it loaded all files in memory
06:22:18 <siti> is it 100% cpu?
06:22:18 <sphynx> fasta: it's hard to monitor all the files opened, given by 'lsof' :)
06:22:29 <sphynx> siti: yeah, something like this
06:22:49 <siti> well it's just, darcs is slow...
06:23:29 <sphynx> yup, it seems so :(
06:23:41 <mux> bah, I always get confused with group/groupBy, forgetting I need to sort/sortBy first if I want to group all elements and not just adjacent ones
06:23:43 <fasta> I wonder why exactly that is.
06:23:53 <sphynx> cpu is ~50%
06:24:03 <sphynx> I mean darcs cpu usage
06:24:04 <dons> darcs uses a precursor to bytestrings.
06:24:05 <siti> sphynx: do you have dual cpus?
06:24:09 <fasta> I cannot imagine that being 10x slower is the reason.
06:24:09 <siti> what's the IO wait?
06:24:16 <siti> dons: ok
06:24:24 <ndm> its nothing to do with being slower because of strings etc, its all asymototic copmlexity
06:24:36 <yakov> hi
06:24:39 <sphynx> siti: No, I have Pentium M 1.86 Mhz and 1.30 Gb RAM
06:24:50 <dons> its the complexity, if there's some funny resolution patches to merge, it'll just take forever
06:24:52 <fasta> There is some NP-Complete problem lurking in there, but I don't know the details.
06:25:03 <ndm> darcs should really be ported to FilePath and ByteString
06:25:13 <dons> indeed. lots of work though
06:25:26 <dons> bytestring wouldn't be too hard, and its been proposed a couple of times.
06:25:30 <ndm> or they should have contributed their filepath/bytestring libraries back originally
06:25:46 <ndm> i'm not aware of any libraries we've got back from darcs
06:25:54 <dons> bytestring came from darcs originally :-) fps 0.1 is really just a thinly disguised piece of darcs
06:25:59 <ndm> true
06:26:09 <ndm> but something like Hoogle 4 is 2 libraries already, and counting
06:26:13 * dons `ap` sleep
06:26:21 <ndm> i hope thats the future of Haskell development
06:26:34 <ndm> write libraries which you would like, and release them
06:27:01 <siti> :)
06:29:13 <olsner> it *should* be real easy to change the underlying representation of a string or a file path to a more efficient form.. but something starting out using lists of chars is apparently a real hassle to change to use bytestring
06:29:43 <olsner> seems to me the list type should've been a type class with sugar from the start rather than just a list
06:30:00 <ndm> i strongly disagree, [Char] is beautiful
06:30:28 <ndm> what we really need is Data.String, which has all the ByteString interface but with [Char]
06:30:41 <fasta> If ByteString and String have the same semantics the compiler should optimize
06:30:45 <ndm> then people can slowly move from [Char] to ByteString, slowly using more of the interface, and less direct pattern matching
06:30:51 <fasta> Do they have the same semantics?
06:30:57 <ndm> fasta: not by a long way
06:31:10 <olsner> I'm not really talking about [Char] vs ByteString, rather about the act of converting code from using one to using the other
06:32:03 <bos> moving from [Char] to ByteString is a retrograde move for dealing with text, too.
06:33:40 <emu> [Char] is lazy!
06:34:54 <siti> yeah they are all string types are needed, e.g. bytestring, lazy bytestring, compactstring * (different encodings), string
06:35:04 <siti> but it's a bit messy at the same time...
06:35:35 <mux> and on top of that, it would be nice to have ByteString-like features for any kind of lists
06:36:01 <siti> yep
06:36:08 <siti> especially the split function ;)
06:36:18 <siti> that's a requirement in any language :P
06:37:17 <ttmrichter> Silly question time.  How exactly do I actually use Parsec?  When I try to import it I get: " Could not find module `Text.ParserCombinators.Parsec': it is a member of package parsec-2.0, which is hidden"
06:37:36 <mux> ttmrichter: are you using Cabal to build?
06:37:42 <ttmrichter> Yes.
06:37:54 <mux> if so, you need to add the "parsec" package to the dependencies in your .cabal file
06:38:02 <mux> otherwise, as you can see, the package is hidden
06:38:12 <ttmrichter> Doh!
06:38:47 <ttmrichter> That goes into "other-modules" then?
06:38:56 <ndm> what would be nice is to use String only, and have it automatically optimised
06:39:02 <ndm> but i think thats a "future" thing
06:39:17 <siti> ndm: that would be amazing, but very very difficult I would think
06:39:27 <mux> ttmrichter: build-depends
06:39:35 <ndm> siti: thats why i'm not proposing anyone solve it for a while yet
06:39:43 <siti> :D
06:40:17 <ndm> i don't think the strictness/laziness analysis is powerful enough yet, and even once it is, you'd need some usage analysis that is as yet completely unknown
06:40:48 <ndm> although i hope to beat ByteString at all the benchmarks with [Char] :)
06:40:56 <mux> ttmrichter: and then you need to re-run the "configure" stage
06:40:59 <ndm> (although not in real programs)
06:41:15 <ttmrichter> Ah.  I was just about to ask another dumb question.  Thanks for heading it off, mux.
06:41:54 <ttmrichter> It doesn't seem to like "parsec-2.0", though.  Should it just be called "parsec"?
06:42:03 <ndm> ttmrichter: there are no dumb questions, only dumb software :)
06:42:05 <mux> ttmrichter: it can, if you don't care about the version
06:42:24 <mux> the configure stage will then talk about "parsec-any" or something
06:42:55 <ttmrichter> I prefer the adage "there are no stupid questions, only stupid people" myself, ndm.  ;)
06:42:56 <mux> if you really want 2.0, the syntax is "parsec>=2.0", I think
06:43:24 <ttmrichter> I have no care at all about the version of parsec.  So far, anyway.
06:43:57 <ttmrichter> Thanks for the help.  It's working beautifully now.  The errors I have now are all related to module imports.  (I'm trying to match parsec docs to the reality.)
06:44:07 <mux> you're welcome
06:46:38 <ttmrichter> Is it too late to suggest changes to Haskell'?  ;)
06:46:46 <emu> yes the parsec docs are out of date w/respect to the package names
06:46:58 <ttmrichter> It would be nice to be able to rename an imported symbol that clashes with one I'm defining.
06:47:16 <emu> if you see a package name like ParsecExpr then it's Text.ParserCombinators.Parsec.Expr or somesuch
06:47:34 <mux> ttmrichter: you can import things qualified
06:48:04 <ttmrichter> That would be a tad inconvenient in this case.  I'd have things in parsec like <|> qualified....
06:48:15 <ttmrichter> Parsec.<|> on each choice in a grammar?  :O
06:48:22 <mux> that sure would be inconvenient :-)
06:48:26 <mux> but then you can have aliases
06:48:44 <mux> (<||>) = Parsec.<|>
06:48:51 <mux> or whatever :-)
06:49:36 * mux bbl &
06:49:37 <ttmrichter> Or I can rename my "parse" function to not clash with Parsec's.  I'm funny that way.
06:49:38 <ttmrichter> :)
06:50:13 <ttmrichter> I tend to like to keep my names closely matching the problem domain's, but not at the expense of that level of clashing and renaming and such.
06:50:38 <olsner> I prefer oneOf = foldl1 Parsec.<|> (oneOf is already in use in Parsec, but is used by a few other parser combinator libraries to parse on of a list of alternatives)
06:51:29 <olsner> oneOf is shorter and easier to type than n instances of (<, alt-|, shift->)
06:53:05 <Saizan> ttmrichter: import T.P.Parsec hiding (parse); import qualified T.P.Parsec; parsecParser = T.P.Parsec
06:53:29 <Saizan> parsecParse = T.P.Parsec.parse
06:53:38 <xpika> is anyone here disagree with list comprehension notation?
06:53:45 <xpika> does*
06:53:55 <ttmrichter> OK, that's a good one, Saizan.  Keeps things very clear and minimizes the impact of naming clashes.  Thanks.
06:53:56 <shachaf> xpika: Disagree?
06:54:14 <fnord123> > [ x*x | x <- [1,2,3,4]]
06:54:16 <lambdabot>  [1,4,9,16]
06:54:27 <Saizan> ttmrichter: you can also import qualified T.P.Parsec as P
06:54:28 <fnord123> I don't disagree.
06:54:37 <xpika> isnt the syntax unnessary
06:55:11 <fnord123> compared to map (\x -> x*x) [1,2,3,4] ?
06:55:17 <xpika> yep
06:55:29 <Saizan> xpika: it's handy, especially when do things a little more complex than a map
06:55:36 <Saizan> ?src concatMaybes
06:55:36 <lambdabot> Source not found. Are you on drugs?
06:55:40 <ttmrichter> Yes, it is unnecessary.  But it tastes a whole lot nicer for certain kinds of list generations.
06:55:46 <fnord123> I quite like the syntax. It makes for some sweet snippets imo
06:55:48 <olsner> ?src catMaybes
06:55:48 <lambdabot> catMaybes ls = [x | Just x <- ls]
06:55:56 <Saizan> olsner: thanks :)
06:56:33 <shachaf> xpika: Do you also not like do-notation?
06:56:52 <xpika> shachaf: i prefer >>=
06:58:46 <xpika> although the catMaybes is a good example
06:59:38 <xpika> > [ x | Right x <- [Right 4,Left 3,Right 2]]
06:59:40 <lambdabot>  [4,2]
07:00:03 <Saizan> > [ x | Right x <- [Right 4,Left 3,Right 2], x > 2 ] -- nice guards, also
07:00:06 <lambdabot>  [4]
07:01:14 <Svrog> i think list comprehensions are redundant and no more convenient than the alternatives
07:01:24 <shachaf> @ty isRight -- I don't think there is one?
07:01:26 <lambdabot> Not in scope: `isRight'
07:01:43 <xpika> Saizan: that catMaybe example takes away the need for writing isConstructor functions
07:01:51 <Saizan> > [Right 4,Left 3,Right 2] >>= (\x -> case x of Right a -> a; _ -> []) >>= \x -> guard (x>2) >> return x
07:01:53 <lambdabot>   add an instance declaration for (Num [a])
07:01:54 <shachaf> @let isRight (Right _) = True; isRight _ = False
07:01:57 <lambdabot> Defined.
07:02:05 <Saizan> > [Right 4,Left 3,Right 2] >>= (\x -> case x of Right a -> [a]; _ -> []) >>= \x -> guard (x>2) >> return x
07:02:07 <lambdabot>  [4]
07:06:01 <Svrog> night
07:07:28 <Saizan> http://research.microsoft.com/~simonpj/papers/list-comp/list-comp.pdf <-- a proposal to extend them with sort and group, making them similar to a SELECT statement (with much nicer syntax i'd say :)
07:07:30 <lambdabot> http://tinyurl.com/23vray
07:16:00 <hkBst> @where parsec
07:16:01 <lambdabot> http://www.cs.ruu.nl/~daan/parsec.html
07:18:47 <hkBst> I don't understand why my program won't parse more, http://hpaste.org/1456#a4
07:20:42 <fnord123> what are \v and \f
07:21:06 <hkBst> fnord123: I have no idea :) I copied that from the parsec website
07:21:26 <kpreid> hkBst: what are you using for test input?
07:21:53 <hkBst> kpreid: code = "( some lisp ( with nested list ) code )"
07:22:08 <kpreid> okay
07:22:14 <fasta> How can I make an Arbitrary instance for QuickCheck of a reference based structure, for example a tree based on STRefs ?
07:22:39 <kpreid> you are parsing '(' as a Symbol because it doesn't reject '(', but parseList doesn't match ( followed by whitespace
07:22:58 <fnord123> oh vertical tab and form feed. I don't see you checking for spaces
07:23:02 <kpreid> so (a) have symbol reject '(', and (b) have parseList or parents accept whitespace
07:23:08 <kpreid> fnord123: first character
07:23:10 <fnord123> oh you do and i am blind
07:23:26 <kpreid> s/parents/parens/
07:26:23 <kpreid> hkBst: actually, on second thought: have parseL accept whitespace before its alternatives, and parens accept whitespace between the contents and close paren
07:33:15 <ttmrichter> I have a parsec question: assume I have a parser for "printable characters" and a parser for "blank characters" -- is there an easy way to combine these in a rule for "non-blank characters" such that the character I'm recognizing is in the set of printable characters, but not in the set of blank characters?
07:34:44 <mux> hmm, I wouldn't try to apply both parsers; applying one parser and making sure another one doesn't succeed sounds a bit odd
07:35:13 <ttmrichter> So basically I have to factor these out into test functions and use satisfy?
07:35:14 <mux> I'd just go satisfy (\c -> isPrint c && not (isBlank c))
07:35:22 <mux> heh, bingo.
07:35:39 <ttmrichter> OK.  Thanks.  Again.
07:36:07 <mux> s/isBlank/isSpace/ probably
07:36:27 <hkBst> ttmrichter: oerjan suggested yesterday something like: try ((blank >> fail "something") <|> printable)
07:37:31 <Saizan> that is equal to try printable afaiu
07:41:35 <kmb> Does anyone know if somone has written a haskell parser using parsec?
07:43:20 <olsner> I was under the impression that e.g. ghc used parsec for parsing
07:43:34 <ttmrichter> GHC uses Happy, I think.
07:43:47 <ttmrichter> (At least it wanted Happy to be there when I built it.)
07:43:50 <sphynx> ?docs Data.ByteString
07:43:50 <lambdabot> Data.ByteString not available
07:43:58 <sphynx> ?docs ByteString
07:43:58 <lambdabot> ByteString not available
07:44:02 <sphynx> hmm
07:44:15 <sphynx> ?hoogle Data.ByteString
07:44:16 <lambdabot> No matches, try a more general search
07:44:22 <Igloo> GHC does use happy
07:44:40 <olsner> oh.. I though happy was defunct and incompatible with ghc > 6.4, but perhaps I just ended up with an old release of happy then
07:44:45 <sphynx> Data.ByteString is hidden from lambdabot! :)
07:45:09 <mux> ?where fps
07:45:09 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
07:46:00 <sphynx> mux: thanks! but why so strange?
07:46:21 <sphynx> mux: I mean why ByteString cannot be found directly
07:46:21 <mux> what is strange?
07:46:32 <mux> ah, dunno, I guess noone added that to LB yet
07:46:59 <sphynx> ahh,ok
07:48:08 <ttmrichter> Hmmm...  This leads me to breaking the DRY rule.  The refactoring is going deeper than I though.
07:48:24 <ttmrichter> Anyway, I'm out of here for the night.  Thanks a lot for all the help.  Great, friendly community this is.
07:48:56 <olsner> DRY?
07:49:13 <olsner> nm, google found it ;-)
07:49:30 <mux> ttmrichter: enjoy Parsec :-) it's one of the things that really amazed me with Haskell
07:52:34 <ttmrichter> I've been enjoying Parsec on toy projects already.
07:52:53 <ttmrichter> Little things in GHCi to figure out some of its uses.
07:53:31 <ttmrichter> This is my first big project with it.  It's looking like I'll have a fully-fledged YAML recognizer in place inside of a week.  Which is impressive for a tool I've been toying with for a little bit over a week.  ;)
07:55:11 <Saizan> the only problem is that you need an almost LL(1) grammar, and that means you cannot just combine parsers without knowing how they interact
07:55:13 <gwern> anyone here familiar with HAppS? I'm trying to figure out for https://secure.wikimedia.org/wikipedia/en/wiki/HAppS: what OSs and architectures are supported
07:56:33 <Lemmih> gwern: It runs on pretty much everything GHC does.
07:57:20 <olsner> that LL thing is my major gripe with parser combinators.. there doesn't seem to be a way to automatically perform grammar conversions on the combined parsers (such as constructing [GS]?LR([01])-parsers, or performing left-factoring automatically)
07:57:30 <gwern> Lemmih: pretty much?
07:59:01 <Lemmih> gwern: It has only been tested on three OSes and two architectures.
07:59:50 <gwern> Lemmih: hmm. is there a list anywhere?
08:00:08 <Lemmih> gwern: Not to my knowledge.
08:01:29 <nopcode> is there something like an assert in haskell?
08:01:46 <ClaudiusMaximus> @hoogle assert
08:01:46 <lambdabot> Control.Exception.assert :: Bool -> a -> a
08:01:46 <lambdabot> Test.HUnit.Base.assert :: Assertable t => t -> Assertion
08:01:46 <lambdabot> Control.Exception.assertions :: Exception -> Maybe String
08:01:51 <gwern> QuickCheck maybe?
08:02:32 <nopcode> so the first assert takes a boolean expression and a value and returns the value?
08:03:31 <Lemmih> nopcode: Indeed, and if the bool is False then it throws an exception containing filename and line-number.
08:03:42 <antonio-zen> do you know of any places where PDFs versions of Haskell books are sold?
08:06:44 <antonio-zen> I obviously mean a legitimate purchase, like amazon, o'reilly and so on...
08:07:17 <nopcode> sell.. information? %)
08:09:47 <Tanja> hi
08:21:41 <Saul_> Does anyone know some good OpenGL tutorials?
08:21:59 <nopcode> type Graph v = (Ord v) => Map.Map v [v]
08:22:12 <nopcode> does that type definition look reasoanable?
08:22:26 <nopcode> i haven't used => yet
08:22:36 <nopcode> Saul_: yeah
08:22:47 <nopcode> http://nehe.gamedev.net/
08:22:49 <lambdabot> Title: NeHe Productions: Main Page
08:23:27 <Saul_> I sort of meant in Haskell :P
08:23:53 <nopcode> i doubt that makes a difference
08:24:08 <Saul_> I've been looking around and stuff, but all the tutorials I find are either in C or old
08:24:17 <fnord123> it doesnt make a difference
08:24:17 <nopcode> wrappers for gl in other langugages are usually 1:1
08:24:37 <Saul_> Well it does since the current syntax for OpenGL in Haskell is very different from a direct port
08:24:50 <opqdonut> nopcode: => is meant for type sigs, do you mean Graph v :: (Ord v) => Map.Map v [v]
08:25:34 <nopcode> opqdonut: that'd refer to a function then?
08:25:44 <nopcode> i want to define my type like that
08:25:59 <nopcode> that Graph v only is valid if (Ord v)
08:26:32 <nopcode> makeMap :: (Ord a) => [(a, [a])] -> Graph a
08:26:38 <nopcode> this is what i've got for a function signature
08:26:48 <nopcode> but i want to put the Ord a into the Graph type
08:27:04 <nopcode> so i dont have to add that to every function signature that handles Graphs
08:28:04 <Saul_> I've never seen it done like you want to, but I'm pretty new at Haskell
08:28:36 <nopcode> i started yesterday =)
08:29:11 <Saul_> Let me rephrase btw: Does anyone know of a good Haskell OpenGL tutorial with the most recent syntax?
08:29:37 <Syzygy-> Saul_: I started writing one once
08:29:41 <Saul_> Maybe you shouldn't make graph algorithms on your first day then :)
08:29:49 <Syzygy-> http://blog.mikael.johanssons.org
08:29:53 <lambdabot> Title: Michi&#8217;s blog
08:29:57 <Syzygy-> And someone ported the NeHe tut's to haskell.
08:30:15 <Saul_> Ah I already did that one, thanks though :)
08:30:27 <nopcode> Saul_: well i've done common lisp before ;)
08:30:32 <olsner_> nopcode: afaik, you have to write it like that... or, alternately, don't write the type signature and let haskell infer that a has to be Ord in order to be part of Graph a
08:30:42 <nopcode> olsner_: that doesnt work
08:31:08 <olsner_> okay
08:31:09 <nopcode> graph.hs:18:13:
08:31:09 <nopcode>     No instance for (Ord a)
08:31:09 <nopcode>       arising from use of `makeMapRec' at graph.hs:18:13-35
08:31:10 <nopcode>     Possible fix: add (Ord a) to the type signature(s) for `makeMap'
08:31:12 <nopcode> --
08:31:21 <nopcode> that's why i added the (Ord a) => in the first place
08:31:38 <mwc> This is OT I suppose, but I don't know where else I'd possibly get an answer on this. I just read: ``All expressions in Z notation are typed, thereby avoiding some of the paradoxes of naive set theory.'' I hadn't realized type systems had such power in pure mathematics. Anybody know anything about "typed set theory?"
08:31:46 <Saul_> Syzygy-, Do you have an url for those NeHe tutorials ported to haskell?
08:31:50 <olsner_> oh.. well, I'm pretty new to haskell too ;-)
08:32:09 <nopcode> mwc: omfg =)
08:32:30 <Syzygy-> Saul_: Nope. If I had one, I'd have given it immediately.
08:33:06 <Saul_> Syzygy-, ok, thanks though, I'll look around a bit
08:35:44 <Saul_> Syzygy-, I found it at http://www.codersbase.com/index.php?title=Nehe-tuts&oldid=4120, someone spammed over it though, so this is in the history
08:35:45 <lambdabot> Title: Nehe-tuts - CodersBase
08:36:00 <sorear> (hello.)
08:36:59 <nopcode> ok how do i define a datatype that always has a list of neighbours and sometimes a "color"?
08:37:19 <sorear> mwc: I'm not sure about *exactly* what you were talking about, but one of the first attempts to resolve the naive ST paradoxes was to assign a natural type to every expression
08:37:38 <sorear> mwc: atoms are 0, typeof({ foo}) = 1 + typeof(foo)
08:37:49 <Saul_> nopcode, data Something = Something a (Maybe b)
08:37:52 <mwc> sorear: that's okay, neither was I. I was used to thinking of sets as types
08:37:58 <Saul_> nopcode, I think
08:38:06 <nopcode> Saul_: why "data" and not "type"?
08:38:19 <sorear> mwc: iirc this was used in the principia mathematica (Whitehead&Russel, not Newton)
08:38:33 <nopcode> Saul_: uh wouldnt that be recursive?
08:38:48 <sorear> mwc: sure.  think of Set a as itself a type in this context.
08:39:25 <Saul_> nopcode, data is used for creating all sorts of data structures, while type is used to give a different name to already existing types
08:39:45 <nopcode> hm
08:39:50 <sorear> mwc: the original typed formulation fell flat when Goedel devised his numbering scheme; I don't know if a fixed version exists
08:41:08 <Saul_> nopcode, for example, (Int, Int, Int) is an existing type, which you might want to call Vector3 Int instead (because it's more semantically useful)
08:41:27 <Saul_> nopcode, so you define "type Vector3 a = (a,a,a)"
08:41:44 <Saul_> or "type Username = String"
08:42:15 <nopcode> ic
08:42:24 <Saul_> so basically types are completely unnecessary, but handy
08:42:33 <nopcode> and that doesnt define any constructors right?
08:42:43 <Saul_> While with data, you can define data structures (even recursive ones)
08:42:58 <Saul_> Nope, only data uses constructors
08:43:21 <Saul_> you can used the defined types in the type definitions of functions though
08:43:35 <nopcode> ah ok
08:43:38 <sorear> type DOES define type constructors, though
08:44:17 <Saul_> really?
08:44:43 <Saul_> You can't really make an instance of data with them
08:45:16 <Saul_> you can say that (3,2,1) is an instance of Vector3 Int
08:45:40 <Saul_> But a constructor actually builds an instance
08:46:02 <mwc> well, data constructors do
08:46:08 <mwc> type constructors make a type.
08:46:09 <Saizan> Saul_: type Foo a = ... then Foo is a type contructor
08:46:26 <Saul_> oh ok
08:46:29 <mwc> [] is a type constructor, : is one of its data constructors
08:47:28 <Saul_> isn't the (:) just a function?
08:47:47 <weitzman> In the sense that a constructor is a function, yes
08:47:57 <Saizan> it's something more, you can pattern match on it
08:48:05 <weitzman> But it's a function into an abstract data type whose operations include constructors and pattern matching
08:48:15 <Saul_> ok
08:49:06 <Eelis> isn't (:) special in that one cannot define constructors that are operators in Haskell?
08:49:22 <Saizan> ?src Complex
08:49:22 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
08:49:22 <weitzman> @src []
08:49:22 <lambdabot> data [] a = [] | a : [a]
08:49:54 <Saizan> [] is special, but : not so much, you can define operator contructors that start with :
08:50:07 <mwc> Eelis: It may be a ghc extension, but constructor operators must start with :, and regular operators are forbidden to.
08:50:18 <weitzman> [] is special because of list comprehensions
08:50:28 <mwc> simular to how data constructors must start with a capital, and regular bindings may not
08:50:32 <weitzman> Well, I guess it's a little special anyway
08:50:41 <sorear> mwc: it's in the Report
08:50:41 <weitzman> But you could agree that [] is one token
08:50:44 <weitzman> And then it wouldn't be special
08:51:49 <Eelis> but even if i import Prelude hiding ((:)),  data Foo = Int : Int  does not compile
08:53:43 <Eelis> in fact, that "import Prelude hiding ((:))" part doesn't even compile
08:54:32 <Eelis> as far as i'm concerned, operator : has "special" written all over it
08:54:59 <Eelis> despite lambdabot's deceptions
08:56:12 <sorear> yes
08:56:15 <Tanja> hi
08:56:18 <sorear> : is very special
08:56:29 <sorear> it's not even a valid name!
08:56:48 <Eelis> it seems a shame that they had to make it so special
08:57:01 <sorear> the "definition" of [] is for illustrative purposes only.
08:57:11 <sorear> Hello, Tanja.  Welcome to #haskell!
08:57:50 <Philippa> Eelis: it's special in Haskell 98 but less so in GHC Haskell. And given that it's based on a decades old design decision, it's not too surprising
08:57:56 <weitzman> Shouldn't lambdabot be in charge of greeting all the people that come in and immediately say hello?
08:58:10 <Philippa> no, that just pisses people off
08:58:30 <Saizan> yeah, one of the most annoying things you can find on irc
08:58:32 <Philippa> it's not like the bot'll give a free massage on the way in or something
08:58:35 <Eelis> Philippa: i suppose. will Haskell' be any different in this regard?
08:59:21 <Philippa> Eelis: I don't know, I suspect it'll adopt GHC's approach though
08:59:26 <Saizan> lists have a lot of special syntax anyway, e.g. [a,b..]
08:59:51 <Eelis> Saizan: true, but the translation of [a,b] into (a:b:[]) does not require : to be special
09:00:11 <Eelis> Philippa: i see.
09:00:33 <fasta> I think Test.QuickCheck is not general enough for my needs.
09:01:01 <fasta> I have a recurisve data type where only a certain nesting is allowed.
09:01:12 <Philippa> Eelis: if it helps any, the underlying data constructor is only syntactically special - you could view list patterns as desugaring to hidden ordinary constructors
09:01:20 <Philippa> fasta: GADT time?
09:02:07 <fasta> Philippa: I am not experiences with those
09:02:28 <fasta> experienced*
09:02:42 <fasta> Philippa: can I /msg you for details?
09:03:11 <Philippa> better to carry on the conversation in here
09:03:54 <fasta> Ok, I have a Root, a Node, a Leaf and an Empty constructor.
09:04:00 <sorear> fasta: Just define a custom Arbitrary instance; you don't have to accept any automatic derivation
09:04:04 <Philippa> though tbh I'm a bit tired and don't fancy explaining a new feature - which is pretty much the best reason to talk in here, means others can chip in
09:04:15 <Philippa> fasta: carry on
09:04:19 <fasta> Empty is a valid tree
09:04:30 <fasta> Leaf is only valid as a bottom value of a tree.
09:04:38 <fasta> Root is only valid at the top
09:04:48 <fasta> Node can be placed everywhere else.
09:04:56 <fasta> Philippa: that's the full spec
09:05:03 <sorear> fasta: data syntax?
09:05:30 <sorear> data Tree = Empty | Root [Tree] | Leaf | Node [Tree] ?
09:05:44 <fasta> Oh, right, and they are all references.
09:05:53 <fasta> STRefs
09:06:07 <sorear> ah.
09:06:47 <sorear> quickcheck is only suitable for pure functions unfortunately :(
09:06:51 <sorear> (last I heard)
09:07:05 <fasta> sorear: who told you that?
09:07:17 <fasta> sorear: maybe I did in a moment of ignorance.
09:07:20 <sorear> fasta: I don't remember things like that :)
09:07:40 <fasta> I think I can build a random ST computation.
09:07:51 <oerjan> @src Testable
09:07:51 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
09:07:55 <sorear> Yes you can.
09:08:02 <oerjan> @src Arbitrary
09:08:02 <lambdabot> Source not found. You speak an infinite deal of nothing
09:08:08 <sorear> fasta: But, how do you build a random Tree?
09:08:09 <fasta> But I am not sure whether I can run it then too.
09:08:15 <weitzman> Anything wrong with having different types of rooted and uprooted trees?
09:08:51 <fasta> sorear: http://www.cs.chalmers.se/~rjmh/QuickCheck/manual.html
09:09:03 <fasta> sorear: just in that way, but then in the ST monad.
09:09:10 <fasta> sorear: search for Tree
09:09:32 <fasta> sorear: of course my tree is more complicated, but that's besides the point.
09:09:43 <oerjan> @src ST
09:09:43 <lambdabot> newtype ST s a = ST (STRep s a)
09:10:24 <fasta> But can GADTs do anything for that?
09:12:13 <oerjan> @src STRep
09:12:13 <lambdabot> type STRep s a = State# s -> (# State# s, a #)
09:12:41 <sorear> Probably not more than a smart Arbitrary.  (Also, the code for type classes + GADTs was not implemented in time for 6.6.0)
09:13:46 <fasta> sorear: how would a "smart" Arbitrary work?
09:13:58 <sorear> fasta: By knowing about your type.
09:14:01 <fasta> sorear: AFAIK, I need more than just the size parameter.
09:14:33 <fasta> sorear: In particular, a size of 0 would imply either a Leaf or an Empty.
09:14:48 <sorear> you've left my area of knowledge.
09:15:16 <fasta> sorear: meaning that I am not clear enough or your experience with QuickCheck?
09:15:25 <sorear> the latter.
09:16:41 <fasta> Arbitrary(pun intended) limitations .... :(
09:17:13 <fasta> sorear: what about SmallCheck?
09:17:31 <sorear> I know less.
09:19:17 <fasta> The word Monad is not in the README of SmallCheck, so that is a no .
09:19:42 <fasta> Ok, I will just test something less and maybe write a good solution when I have the time.
09:26:31 <oerjan> perhaps it will be easier to write an Arbitrary instance for St s Tree rather than Tree?
09:26:45 <oerjan> *ST s Tree
09:27:59 <oerjan> then QuickCheck itself may not need to know about monads.
09:30:55 <fasta> oerjan: I was already doing that
09:31:20 <fasta> oerjan: still I think that isn't enough.
09:31:36 <fasta> oerjan: one would need to wrap it in e.g. StateT to get a good result.
09:32:11 <fasta> oerjan: some way there need to be communicated whether we are somewhere in the middle of generating the tree or not when we encounter a size of 0.
09:34:40 <oerjan> er... i don't know the details of QuickCheck, but wouldn't you decide how to divide up size between the branches _before_ recursing into them?
09:35:04 <oerjan> so that you never need to stop in the middle...
09:36:55 <fasta> oerjan: Check the QuickCheck manual, I am doing essentially the same as that, and incidentially as you describe.
09:38:15 <fasta> There is "QuickCheckM", but is not compatible with newer code.
09:41:31 <hkBst> what's the definition of *> and is there also a <* ?
09:41:45 <oerjan> well i don't know why your case doesn't work then.
09:41:53 <oerjan> @src (*>)
09:41:53 <lambdabot> (*>) = liftA2 (const id)
09:42:04 <oerjan> :t (*>)
09:42:06 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
09:42:18 <oerjan> @src liftA2
09:42:18 <lambdabot> liftA2 f a b = f <$> a <*> b
09:42:25 <oerjan> @src (<*)
09:42:25 <lambdabot> (<*) = liftA2 const
09:42:56 <oerjan> wow, @src actually worked!
09:45:00 <oerjan> i guess they run both arguments, but return only one of them
09:45:40 <hkBst> is <$> the same as return?
09:45:49 <oerjan> @src (<$>)
09:45:50 <lambdabot> f <$> a = fmap f a
09:46:03 <hkBst> @src (<*>)
09:46:04 <lambdabot> Source not found. Do you think like you type?
09:46:13 <shachaf> @ty pure
09:46:15 <lambdabot>     Ambiguous occurrence `pure'
09:46:16 <lambdabot>     It could refer to either `pure', imported from Control.Applicative
09:46:20 <oerjan> @src Applicative
09:46:20 <lambdabot> class Functor f => Applicative f where
09:46:20 <shachaf> @ty Control.Applicative.pure
09:46:20 <lambdabot>     pure  :: a -> f a
09:46:20 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
09:46:22 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
09:47:49 <oerjan> @src [] (<*>)
09:47:49 <lambdabot> (<|>) = (++)
09:47:53 <oerjan> argh!
09:48:07 <oerjan> there may be a wildcard problem?
09:48:17 <oerjan> @src Maybe (<*>)
09:48:17 <lambdabot> (<*>) = ap
09:48:48 <oerjan> i think (<*>) = ap is general for monads.
09:49:04 <oerjan> @src Maybe pure
09:49:04 <lambdabot> pure = return
09:49:17 <oerjan> @src [] pure
09:49:17 <lambdabot> pure = return
09:50:10 <hkBst> @src const
09:50:10 <lambdabot> const x _ = x
09:51:40 <bartw> haskell, language of evaluatable ascii art
09:51:48 <hkBst> which of <$> and <*> has higher precedence?
09:52:18 <oerjan> :info <$>
09:52:23 <oerjan> bah
09:52:29 <shachaf> They're both infixl 4.
09:53:10 <hkBst> shachaf: does that mean that  liftA2 f a b = (f <$> a) <*> b   ?
09:53:45 <oerjan> note that f <$> a = return f <*> a, i think
09:53:55 <shachaf> hkBst: That makes sense.
09:54:13 <hkBst> @src fmap
09:54:13 <lambdabot> Source not found. The more you drive -- the dumber you get.
09:54:18 <oerjan> @src Functor
09:54:19 <lambdabot> class  Functor f  where
09:54:19 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
09:54:24 <shachaf> hkBst: Since it's equivalent to liftA2 f a b = pure f <*> a <*> b
09:54:54 <oerjan> er, right
09:55:08 <oerjan> i was mixing monads and applicatives there...
09:56:29 <hkBst> :( does that mean that this is completely unrelated to      a *> b = do { x <- a ; b ; return x }    ?
09:57:44 <oerjan> not completely, if something is both monad and applicative then that should hold (except i think you mean <*)
09:58:40 <chessguy> @src >>
09:58:40 <lambdabot> m >> k      = m >>= \_ -> k
10:00:50 <oerjan> @src liftM2
10:00:50 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
10:01:36 <oerjan> liftM2 and liftA2 should also be the same
10:02:55 <hkBst> then what is the difference between Monads and Applicatives?
10:03:26 <oerjan> monads have more operations, >>= cannot be defined in an applicative
10:03:52 <oerjan> (generally)
10:03:57 <hkBst> @src Monad
10:03:57 <lambdabot> class  Monad m  where
10:03:58 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
10:03:58 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
10:03:58 <lambdabot>     return      :: a -> m a
10:03:58 <lambdabot>     fail        :: String -> m a
10:05:16 <hkBst> then why isn't it   class Applicative m => Monad m      ?
10:05:31 <oerjan> because Applicative is much newer
10:06:21 <shachaf> @ty (>>)
10:06:24 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
10:06:26 <shachaf> @ty (*>)
10:06:28 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
10:07:41 <hkBst> @src (>>)
10:07:42 <lambdabot> m >> k      = m >>= \_ -> k
10:07:58 <oerjan> and for the time being at least, Haskell would require you to write three instances just to use a monad if it did that (Functor, Applicative and Monad)
10:08:54 <shachaf> Of course it shouldn't work that way -- it should be Functor -> Applicative -> Monad.
10:09:12 <shachaf> So all Monads would be Applicatives and Functors. Why isn't it that way?
10:10:55 <oerjan> again, because it would currently require you to write three instances, there is no system for default declarations of superclasses in subclasses
10:11:30 <oerjan> i _think_ adding it would give Haskell multiple inheritance problems.
10:11:47 <hkBst> oerjan: but you have to write those instances anyway if you want them, right? I don't see how it is worse...
10:12:21 <shachaf> TheOtherPrelude (which I haven't really looked into) seems to do it.
10:12:36 <shachaf> http://www.haskell.org/haskellwiki/The_Other_Prelude
10:12:37 <lambdabot> Title: The Other Prelude - HaskellWiki
10:13:00 <oerjan> hkBst: no, because for a monad, fmap f x = x >>= return f, you _should_ only need to declare the latter once, for all monads
10:14:09 <hkBst> the latter being fmap?
10:14:26 <oerjan> er, i mean return . f
10:14:35 <shachaf> oerjan: How would you do that?
10:14:59 <shachaf> oerjan: instance (Monad m) => Functor m where fmap f x = x >>= return . f ?
10:15:23 <oerjan> well, _if_ Haskell supported defaults for superclasses in subclasses, then you could write class Functor m => Monad m where ... fmap f x = x >>= return . f
10:15:58 <oerjan> or perhaps what you said.
10:17:06 <chessguy> hmm
10:17:09 <chessguy> i don't get this
10:17:11 <chessguy> Prelude Data.Array> let arr = array (1,10) [(3,'a')]
10:17:11 <chessguy> Prelude Data.Array> elems arr
10:17:11 <chessguy> "*** Exception: (Array.!): undefined array element
10:17:50 <chessguy> do i have to define an element for every possible index?
10:18:11 <dmhouse> Yes, that's the point of an array.
10:18:19 <dmhouse> If you don't want that restriction, use Data.Map.
10:18:28 <bartw> what is the value of the undefined entries otherwise :)
10:18:37 <oerjan> chessguy: if you are going to look at an element, you need to define it.
10:18:45 <dmhouse> Prelude> :m Data.Map
10:18:45 <dmhouse> Prelude Data.Map> let arr = fromList [(3, 'a')]
10:18:45 <dmhouse> Prelude Data.Map> elems arr
10:18:45 <dmhouse> "a"
10:19:13 <chessguy> oerjan, bartw, i don't expect them to have a value. i would expect elems to not return them
10:19:40 <chessguy> hmm, that's not really what i want either
10:20:10 <dmhouse> Arrays are useful because they correspond pretty much exactly to just contiguous areas of memory. So if you have an array where the elements are of size n, and you want to fetch the mth element, you can just index (n*m) bytes into where the array starts, and return n bytes, which is O(1).
10:21:01 <chessguy> oh, i think i want Data.Map.toList
10:21:38 <dmhouse> chessguy: that takes a Map and converts it into an associative list. If you've just built that Map _from_ an associative list, what's the point?
10:21:43 <dmhouse> Or was this an over-trivialised example?
10:22:02 <chessguy> it was over-trivialized
10:22:06 <dmhouse> Okay.
10:22:08 <oerjan> you _could_ also use Maybe elements, and set undefined to Nothing.
10:22:14 <oerjan> *undefined elements
10:22:23 <dmhouse> oerjan: it's more likely he wants a Map, though.
10:22:41 <chessguy> i think i do
10:22:41 <oerjan> just saying
10:23:13 <dmhouse> Maps are more frequently used than Arrays. Arrays tend to be for high-performance stuff, like an array holding the colour of each pixel in an image and applying transformations to that image. It's very important you get fast lookup, which is what Arrays provide.
10:23:19 <chessguy> hmm, Data.Map doesn't give O(1) access though, does it?
10:23:47 <dmhouse> No, it's O(log n), I think, but that should be good enough, shouldn't it?
10:24:06 <chessguy> you don't even know what i'm doing, do you? :)
10:24:08 <dmhouse> It's got faster update than Arrays (O(log n) vs. O(n) IIRC).
10:24:42 <sjanssen> chessguy: O(log n), for all intents and purposes, is as good as O(1)
10:25:02 <dmwit> One CS professor always used to say, "For all values of n, log n < 30".
10:25:10 <dmwit> =)
10:25:48 <dmhouse> > log (exp 31)
10:25:50 <lambdabot>  31.0
10:26:26 <kaol> > log $ exp 1000000
10:26:28 <lambdabot>  Infinity
10:26:45 <dmwit> :t Infinity
10:26:49 <lambdabot> Not in scope: data constructor `Infinity'
10:26:59 <olsner> :t log
10:27:03 <lambdabot> forall a. (Floating a) => a -> a
10:27:06 * dmhouse is off.
10:27:11 <oerjan> :t 1/0
10:27:14 <lambdabot> forall t. (Fractional t) => t
10:27:34 <oerjan> > 1/0
10:27:36 <lambdabot>  Infinity
10:27:50 <kaol> > 1/(-0)
10:27:52 <lambdabot>  -Infinity
10:28:03 <dmwit> But that doesn't mean (Infinity :: forall t. Fractional t => t).
10:28:32 <sorear> Infinity is show syntax *only*
10:28:39 <oerjan> > 1/0 :: Rational
10:28:40 <dmwit> aha
10:28:42 <lambdabot>  Exception: Ratio.%: zero denominator
10:28:46 <sorear> the equivalent read syntax is 1/0
10:29:05 <oerjan> > read "1/0" :: Double
10:29:07 <lambdabot>  Exception: Prelude.read: no parse
10:29:12 <oerjan> well..
10:29:29 <dmwit> > 1/0 :: Double
10:29:31 <lambdabot>  Infinity
10:29:34 <sorear> ok, read was a bit imprcise there
10:29:41 <sorear> > read "Infinity" :: Double
10:29:44 <lambdabot>  Infinity
10:30:11 <sorear> > (read "NaN" :: Double) == (0/0)
10:30:14 <lambdabot>  False
10:30:42 <augustss_> > 0/0 == 0/0
10:30:44 <lambdabot>  False
10:48:55 <Japsu> @quote stereo
10:48:55 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
10:49:03 <chessguy> @type Infinity
10:49:05 <lambdabot> Not in scope: data constructor `Infinity'
10:54:02 <chessguy> @pl a p s b = i s p b
10:54:02 <lambdabot> a = flip i
10:57:57 <chessguy> @pl m (G b c) = cm (g (G b c))
10:57:57 <lambdabot> (line 1, column 11):
10:57:57 <lambdabot> unexpected "="
10:57:57 <lambdabot> expecting variable, "(", operator or end of input
10:58:38 <chessguy> weird
10:58:52 <chessguy> @pl m x = cm (g (x))
10:58:52 <lambdabot> m = cm . g
10:59:01 <oerjan> the @pl parser is only a part of Haskell.  I don't think it understands datatypes.
11:00:00 <oerjan> or pattern matching.
11:00:34 <oerjan> @pl m (Just x) = x
11:00:34 <lambdabot> (line 1, column 12):
11:00:34 <lambdabot> unexpected "="
11:00:34 <lambdabot> expecting variable, "(", operator or end of input
11:14:12 <dmwit> ?pl let m (Just x) = x in m
11:14:12 <lambdabot> (line 1, column 13):
11:14:12 <lambdabot> unexpected "x"
11:14:12 <lambdabot> expecting operator or ")"
11:17:21 <olsner> I don't think pl does pattern matching
11:17:37 <olsner> ?src fromJust
11:17:37 <lambdabot> fromJust Nothing  = undefined
11:17:37 <lambdabot> fromJust (Just x) = x
11:18:46 <chessguy> @pl f (Just x) = x
11:18:46 <lambdabot> (line 1, column 12):
11:18:47 <lambdabot> unexpected "="
11:18:47 <lambdabot> expecting variable, "(", operator or end of input
11:19:36 <mm_freak> is there any general rule as to how to name custom operators?
11:19:55 <mm_freak> somehow almost all useful operator names are already in use
11:20:22 <chessguy> ywah, the operator namespace is pretty crowded
11:21:21 <mm_freak> yeah, i noticed
11:21:46 <Saizan> well you can just recycle a name from a module you're not going to use
11:22:11 <chessguy> or use a similar name, but add something to it
11:22:16 <mm_freak> but when i want to use that module later, i'm fscked
11:22:55 <mm_freak> hmm
11:22:56 <Saizan> you can always import qualified Foo as F
11:23:43 <mm_freak> then how do i use << from Foo?  F.<< ?
11:23:59 <Saizan> yes
11:24:29 <mm_freak> or i could abuse operators from Num for that, since it's not a Num instance
11:24:54 <Saizan> or you can make it a Num instance?
11:25:05 <mm_freak> that would be pointless
11:25:23 * chessguy resists the urge to make a @pl joke
11:25:30 <mm_freak> it's a tree structureâ¦  nothing you could calculate with
11:25:54 <olsner> chessguy: wasn't that a meta-@pl-joke?
11:25:55 <Saizan> well. if the types fit.. :)
11:26:04 <mm_freak> and i'd like to have some syntactic sugar, similar to lists
11:32:20 <crazy_code2> hello everyone
11:32:26 <Saizan> mm_freak: you could make it an instance of Monad and use do-notation
11:33:02 <Saizan> do-notation is quite similar to list comprehension
11:33:07 <mm_freak> saizan: it's going to be an instance of monad anyway, but i'd like to have something like the cons operator
11:33:24 <mm_freak> it's just that i don't have any idea on how to name it
11:33:47 <Saizan> cons?:)
11:33:57 <mm_freak> :
11:33:58 <mm_freak> ;)
11:34:22 <nopcode> cons for trees? maybe.. root?
11:34:33 <mm_freak> it was just an example
11:35:11 <Saizan> Data.Seq uses :> and <: for head and tail append
11:35:29 <Saizan> |> and <|, rather
11:35:34 <mm_freak> like for b-trees you could think of a syntax like:  < <a> | <<b> | <c>> >
11:36:31 <Saizan> fromTuples (a,(b,c))?
11:37:14 <chessguy> @type =\=
11:37:16 <lambdabot> parse error on input `=\='
11:37:23 <chessguy> @type \=
11:37:25 <lambdabot> parse error on input `\='
11:37:28 <chessguy> grrr
11:37:31 <chessguy> @source Eq
11:37:31 <lambdabot> Eq not available
11:37:36 <chessguy> @src Eq
11:37:36 <lambdabot> class  Eq a  where
11:37:37 <lambdabot>     (==), (/=)   :: a -> a -> Bool
11:37:38 <Saizan> @tpe (/=)
11:37:41 <lambdabot> forall a. (Eq a) => a -> a -> Bool
11:37:47 <chessguy> i can never remember that one for some reason
11:38:44 <mm_freak> hmm
11:38:57 <mm_freak> is there anything special about \ outside of Strings?
11:39:37 <Saizan> > let (\=) = 1 in (\=)
11:39:39 <lambdabot>  1
11:40:11 <mm_freak> k, ty
11:44:01 <ClaudiusMaximus> > (\ a b -> b - a) 21 63  -- \ is used for lambda expressions too...
11:44:03 <lambdabot>  42
11:47:11 <mm_freak> true, but i didn't mean a lone \
11:47:52 <oerjan> > [1..10] \\ [3..6]
11:47:53 <lambdabot>  [1,2,7,8,9,10]
11:48:47 <oerjan> @hoogle \
11:48:48 <lambdabot> Hoogle Error: Parse Error: Unexpected character '\'
11:48:48 <mm_freak> oerjan: that's nothing special
11:48:57 <oerjan> no, exactly
11:49:11 <chessguy> @hoogle (\)
11:49:12 <lambdabot> Did you mean: (\)
11:49:12 <lambdabot> Prelude.undefined :: a
11:49:12 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
11:49:18 <mwc> did you mean @hoogle (\)?
11:49:23 <oerjan> no
11:49:30 <Saizan> @hoogle \
11:49:31 <lambdabot> Hoogle Error: Parse Error: Unexpected character '\'
11:49:36 <Saizan> @hoogle \\
11:49:37 <lambdabot> Hoogle Error: Parse Error: Unexpected character '\\'
11:49:39 <oerjan> i meant if there was a way to find all operators containing \
11:49:47 <Saizan> @hoogle (\\)
11:49:48 <lambdabot> Did you mean: (\\)
11:49:48 <lambdabot> Prelude.undefined :: a
11:49:48 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
11:50:06 <Saizan> gah, bug in the hoogle parser
11:50:13 <mwc> oerjan: not that I know of
11:50:22 <mwc> somebody needs to go beat hoogle with the regex stick
11:51:40 <Saizan> i'd be very surprised if it uses regexes
11:54:30 <Saizan> ?docs Control.Concurrent
11:54:31 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html
11:55:11 <oerjan> ?docs Concurrent
11:55:11 <lambdabot> Concurrent not available
11:59:09 <Saizan> i've a main thread that generates Events that are sent to worker threads using Chans, but i'd like also to share some state, that should be read/write for the main thread, but read only for the workers, any hints?
12:00:14 <Saizan> i've thoght of running the workers in ReaderT (MVar MyState) IO, and provide only a reastricted api
12:01:07 <Saizan> but i feel i'm missing a cleaner solution
12:07:18 <treble> Saizan: if it can only be written by one thread, but read by many
12:07:24 <treble> Saizan: then an IORef would suffice
12:08:29 <treble> ?hoogle atomicModifyIORef
12:08:30 <lambdabot> Data.IORef.atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
12:09:02 <treble> but you wouldn't necessarily need that if only one thread was doing the writing
12:10:09 <treble> alternately, you could use STM and communicate with TVars and TChans
12:27:08 <gwern> so I was trying to use the Control.Parallel.Strategies library. I found some stuff which says I *should* be able to replace a mapM with a parMap, but it doesn't seem to have worked (see http://hpaste.org/1490 for the code), and I get 'Couldn't match expected type `[]' against inferred type `IO''
12:28:12 <shachaf> @ty parMap
12:28:14 <lambdabot> forall b a. Strategy b -> (a -> b) -> [a] -> [b]
12:28:25 <oerjan> @ty mapM
12:28:27 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
12:28:28 <Cale> You need sequence . parMap
12:28:42 <Cale> er
12:28:58 <Cale> :t (sequence .) . parMap
12:28:59 <lambdabot>     Couldn't match expected type `[m a]'
12:29:00 <lambdabot>            against inferred type `[a1] -> [b]'
12:29:08 <Cale> :t sequence . parMap
12:29:12 <lambdabot>     Couldn't match expected type `[m a]'
12:29:16 <lambdabot>            against inferred type `(a1 -> b) -> [a1] -> [b]'
12:29:22 <Cale> oh, forgot about the strategy parameter :)
12:29:35 <gwern> (actual error message for trying with sequence is 'No instance for (Control.Parallel.Strategies.NFData (IO [B.ByteString]))')
12:29:47 <olsner> @pl (\s -> sequence . parMap s)
12:29:47 <lambdabot> (sequence .) . parMap
12:29:47 <Cale> :t let parMapM s f x = sequence (parMap s f x)
12:29:49 <lambdabot> <command line>:
12:29:50 <lambdabot>     Could not find module `L':
12:30:09 <Cale> :t let parMapM s f x = sequence (parMap s f x) in parMapM
12:30:10 <shachaf> @ty \s f l -> sequence $ parMap s f l
12:30:12 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => Strategy (m a) -> (a1 -> m a) -> [a1] -> m [a]
12:30:13 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => Strategy (m a) -> (a1 -> m a) -> [a1] -> m [a]
12:31:01 <Cale> That'll require you to have a Strategy on m a's though.
12:31:40 <Cale> If you're trying to parallelise IO code so that it runs concurrently, you want something more along the lines of forkIO.
12:31:58 <Cale> and the rest of the stuff in Control.Concurrent
12:32:00 <gwern> Cale: yes, but forkIO won't return the results iirc
12:32:05 <pierre-> hello
12:32:15 <Cale> You can arrange thread communication in a number of ways
12:32:20 <gwern> so Parallel.Strategies is not good for IO stuff?
12:32:30 <Cale> Right, it's for pure parallel code.
12:32:36 <gwern> threads scare me, I was hoping to avoid them
12:32:44 <Cale> IO is more complicated, because there are side effects.
12:32:46 <gwern> Cale: gah... does the documentation mention that anywhere?
12:33:29 <Cale> Threads in Haskell are pretty easy, if you know how IO works, it shouldn't be too hard.
12:33:53 <gwern> that's true. in this case there aren't side effects, but fetchArticleText just isn't referentially transparent :)
12:34:18 <Cale> Oh, perhaps you can rig something up with unsafeInterleaveIO.
12:34:24 <Cale> That's a little scary :)
12:34:29 <pierre-> i want to use existential types, but i'm in trouble instancing my type from base class
12:34:55 <gwern> actually, everyone treats unsafeInterleaveIO with such trepidation it almost makes me want to use it
12:35:00 <gwern> which library is it in?
12:35:12 <Cale> System.IO.Unsafe
12:35:22 <oerjan> pierre-: paste your code
12:35:25 * gwern should have just used hoogle
12:35:27 <oerjan> !paste
12:35:35 <olsner> @paste
12:35:35 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:35:42 <Cale> unsafeInterleaveIO is not quite as evil as unsafePerformIO, but it's still evil.
12:36:20 <gwern> I thought interleave used perform?
12:36:30 <Cale> What it does is it takes an IO action and gives you a new IO action which when run, completes instantly, returning a value which will do the actual IO when evaluated.
12:36:39 <Cale> It uses perform internally.
12:36:57 <Cale> But it's a little more safe, because at least you can't break the type system with it.
12:37:04 <treble> !paste
12:37:04 <hpaste> Haskell paste bin: http://hpaste.org/
12:37:56 <gwern> Cale: I saw that warning. I think i'll get interleave a shot
12:37:57 * sorear takes this as a challenge.
12:38:09 <Cale> (With unsafePerformIO, together with IORefs, you can actually write a function  f :: a -> b
12:38:12 <Cale> )
12:38:17 <hpaste>  pierre pasted "existential types" at http://hpaste.org/1491
12:39:02 <sorear> You can do that in pure haskell, thanks to ubiquitous lifting.
12:39:04 <gwern> sorear: pierre, or me?
12:39:20 <sorear> gwern: huh?
12:39:23 <Cale> pierre-: *which* instance of C should "method" refer to in your instance of C for AnyC?
12:39:39 <sorear> @ty let{ cast x = cast x } in cast
12:39:48 <lambdabot> forall t t1. t -> t1
12:39:49 <gwern> sorear: you said you were taking something as a challenge, and I was wondering whether it was what cale/me were discussing or cale/pierre
12:40:07 <sorear> 12:35 < Cale> But it's a little more safe, because at least you can't break the type system with it.
12:40:23 <Cale> sorear: yeah, but this one actually returns non-bottom values :)
12:40:38 <sorear> Every time you add a primitive, you have to re-evaluate the proof of soundness.
12:40:53 <pierre-> Cale: hmm
12:41:05 <sorear> Milner's failed proof is the only way we know that uPIO breaks soundness...
12:41:08 <Cale> pierre-: This is the problem which the compiler is having.
12:42:05 <Cale> pierre-: 'method' could return a value whose type is any instance of C, and AnyC can take any value whose type is any instance of C, so it doesn't know which code to use.
12:42:57 <Cale> er, okay
12:43:54 <gwern> excellent. even taking out the forkIO for debugging, adding unsafeInterleaveIO improves speed by 24% app
12:44:18 <Cale> sorear: That is, we should know that any function of type  a -> b  is bottom, but with unsafePerformIO and polymorphic references, there's one which isn't.
12:44:24 <gwern> dunno how it'll affect memory. negatively, probably, because the request isn't being evaluated until it's forced, right?
12:44:45 <Cale> gwern: yeah
12:45:15 <sjanssen> gwern: you can also see less memory use with unsafeInterleaveIO
12:45:34 <Cale> Er, I thought that's what 'negatively' meant :)
12:45:41 <gwern> sjanssen: what're the heuristics for figuring out which way it will go?
12:45:46 <gwern> Cale: I meant 'negatively
12:45:48 <gwern>  in the moral sense
12:45:52 <treble> is the result bigger than the request
12:45:56 <gwern> as in not good, not the mathematical sense of negative
12:45:57 <treble> that's the heuristic
12:46:04 <Cale> ah
12:46:12 <Cale> treble is right
12:46:35 <gwern> so if result > function, memory usage will shrink?
12:46:41 <Cale> If the expression for computing the result is smaller than the result, then you'll save memory by evaluating it as late as possible.
12:47:14 <gwern> hmm. so the peak memory usage will be less since less stuff is being carted around?
12:47:22 <Cale> Right.
12:47:23 <sjanssen> gwern: you'll especially see improvements when you use unsafeInterleaveIO to stream your data in chunks
12:47:36 <Cale> Like with getContents
12:47:48 <sjanssen> consider: getContents >>= print . length
12:48:08 <sjanssen> because getContents uses unsafeInterleaveIO to yield one character at a time, that takes O(1) memory
12:48:16 <gwern> yeah, I like getContents
12:48:17 <Cale> With lazy IO, your programs don't have to wait for all the input to be in memory all at once, they can start reducing input immediately.
12:48:20 <sjanssen> if it were strict, it'd take O(n) memory
12:48:24 <oerjan> @src hGetContents
12:48:24 <lambdabot> Source not found. Where did you learn to type?
12:50:40 <Cale> http://haskell.org/haskellwiki/Timing_out_computations -- aha, here's a variant I wrote, which instead of mapping over the list, takes the first computed response.
12:50:41 <lambdabot> Title: Timing out computations - HaskellWiki
12:50:48 <Cale> !paste
12:50:48 <hpaste> Haskell paste bin: http://hpaste.org/
12:51:23 <int80_h> test
12:51:37 <sorear> Pong.
12:51:49 <sorear> int80_h: pong
12:53:32 <gwern> interesting. well, anyway I'm done
12:54:23 <hpaste>  Cale pasted "parallel mapM" at http://hpaste.org/1492
12:54:29 <Cale> that ought to do it :)
12:54:58 <Cale> (I just wrote that code into the paste page, I haven't tested it)
12:55:00 <gwern> gah. just when I thought I was done
12:56:24 <Cale> er, sorry, that's a parallel sequence :)
12:57:47 <hpaste>  Cale annotated "parallel mapM" with "correction/completion" at http://hpaste.org/1492#a1
12:58:39 <Cale> Seems like things like this ought to be in the concurrency library, but they're not. Oh well, they're pretty easy to write :)
12:59:26 <Cale> Of course, because the results are returned in a list, you can't actually get at the later ones until the earlier ones have finished.
12:59:41 <gwern> Cale: doesn't look easy to write...
12:59:43 <Cale> So in that sense, it's a little less flexible than unsafeInterleaveIO
13:00:00 <Cale> I'll explain the code...
13:00:22 <Cale> mvars <- mapM (const newEmptyMVar) actions -- this builds a new MVar (mutable variable) for each action in the list
13:01:05 <Cale> the next thing does a mapM_ over the zip of actions and mvars, which forks a new process for each (action,mvar) pair
13:01:19 <gwern> this new learning amazes me, Sir Belvedere
13:01:22 <Cale> all that action does is to execute action and put the result into the mvar
13:01:41 <Cale> results <- mapM takeMVar mvars
13:01:46 <Cale> that just collects the results
13:02:06 <Cale> which are then immediately returned
13:02:30 <gwern> mmm mmm. I don't quite understand but I feel as if I do
13:02:37 <norpan> can't you take the MVars in parallel too?
13:03:13 <Cale> not without doing something like unsafeInterleaveIO.
13:03:51 <Cale> but that is a good idea, you could very well do that, and it would be pretty safe.
13:04:26 <Cale> Trying to access the result before it was computed would block until the mvar got filled by the forked process.
13:05:12 <Cale> I think the only thing I haven't explained about are the characteristics of MVars.
13:05:31 <Cale> Essentially, MVars are just mutable cells, with one difference. They can be empty or full.
13:05:47 <Cale> Trying to read from an empty MVar will block until it's full.
13:05:59 <Cale> Trying to write to a full MVar will block until it's empty.
13:06:43 <norpan> but you can poll them too, can't you?
13:06:48 <Cale> Yes.
13:06:59 <Cale> (but you have to say that you want to do that)
13:07:11 <norpan> of course
13:07:24 <Cale> There's tryTakeMVar and tryPutMVar
13:07:54 <Cale> as well as swapMVar, which swaps out the contents for a new value.
13:08:09 <treble> be careful with isEmptyChan
13:08:27 <treble> err
13:08:29 <treble> nvm
13:08:32 <treble> you aren't talking about Chans :)
13:08:36 <Cale> Oh, taking from an MVar empties it, I should have mentioned.
13:09:24 <Cale> And that's basically all you need to know about it. It's fairly simple and works really nicely for lots of applications, basically saving you from doing explicit locking quite a lot of the time.
13:10:32 <Cale> For more complicated things, there's a new system called STM, which lets you compose transactions on memory, within which you can basically ignore the existence of other threads. :)
13:10:53 <Cale> (and for the most part, things just work)
13:11:27 <Cale> You can't do IO inside a transaction though, because the system needs to be able to roll them back.
13:11:37 <Cale> But there's a projection  STM a -> IO a
13:11:53 <Cale> er, injection :)
13:12:11 <sorear> ...which allows unatomicity!
13:12:27 <sorear> project t1 >> project t2  /=  project (t1 >> t2)
13:12:39 <Cale> right.
13:29:16 <jedai> @source sum
13:29:16 <lambdabot> sum not available
13:29:26 <oerjan> @src sum
13:29:26 <lambdabot> sum = foldl (+) 0
13:29:35 <oerjan> @list src
13:29:36 <lambdabot> source provides: src
13:29:40 <oerjan> @list source
13:29:41 <lambdabot> source provides: src
13:29:48 <oerjan> o_O
13:30:08 <jedai> Thanks, I always forget which works... ^^
13:30:15 <oerjan> is there no limit to the weirdness of this command?
13:30:51 <oerjan> @source Prelude
13:30:51 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
13:31:09 <Cale> http://darcs.haskell.org/packages/base/GHC/Base.lhs
13:32:05 <Cale> http://haskell.org/onlinereport/standard-prelude.html
13:32:06 <lambdabot> Title: The Haskell 98 Report: Standard Prelude
13:32:11 <Cale> (if you want the readable version)
13:32:34 <oerjan> i didn't really want it, i just tried to see if @source did what i thought
13:35:25 <cdtw> One for the floor: every time I think I grasp the elements of style in Haskell, I discover something over the horizon. When I learned to program in Java, Gamma et al Design Patterns was probably my Damascine moment. Is there a similar tome for Haskell which not only explains Monad Transforms etc, but when to use them "stylishly"?
13:36:20 <Cale> http://cale.yi.org/index.php/How_To_Use_Monad_Transformers ?
13:36:23 <Cale> :)
13:36:24 <lambdabot> Title: How To Use Monad Transformers - CaleWiki
13:36:39 <Cale> Well, that explains how to use them stylishly, not really when.
13:36:40 <Figs> is it legal to do something like Func (x:y:rest) = ....?
13:36:48 <Cale> and it assumes you know how to use them
13:36:59 <Cale> (unstylishly)
13:37:00 <cdtw> Ah thank you -- the scope was more general though. Elements of Haskell Style or similar?
13:37:01 <oerjan> Figs: yes
13:37:05 <Figs> ok, thanks
13:37:18 <oerjan> however, the result cannot be polymorphic
13:37:28 <Figs> ?
13:37:30 <Cale> Figs: Though if you use a capital F, that's treated as a constructor.
13:37:39 <Cale> and so that's a pattern binding
13:37:52 <Figs> oh, ok
13:37:58 <oerjan> oh, i thought a constructor was what you wanted
13:37:58 <Cale> oerjan: unless you turn the MR off or provide a type signature :)
13:38:19 <oerjan> Cale: i don't think you can provide a type signature in that case
13:38:24 <Cale> No, you can.
13:38:34 * Figs isn't sure of the difference yet; I was just interested in naming the parts of a list
13:38:43 <Cale> I'm fairly sure, anyway :)
13:38:55 <Figs> is there a way to name the last element in a list?
13:39:16 <oerjan> Figs: not as a pattern but you can get it with last
13:39:19 <Figs> ok
13:39:45 <Cale> Figs: last takes O(length xs) time, so be careful with it
13:40:03 <nominolo> you can use pattern guards
13:40:45 <nominolo> > let f x | omega <- last x = omega in f [1..5]
13:40:46 <lambdabot>  Parse error
13:41:07 <nominolo> requires -fglasgom-exts
13:41:08 <Cale> oerjan: oh, that's interesting, you're right.
13:41:34 <Cale> oerjan: Which is pretty sad, since it has no problem with patterns like 'x'
13:41:43 <nominolo> of, course the more portable way is:
13:41:51 <mgsloan> hmm, what could cause things like this to happen on every ghc compile:
13:41:51 <mgsloan> /usr/local/lib/ghc-6.6/libHSrts.a(Main.o): In function `main':
13:41:51 <mgsloan> Main.c:(.text+0xa): undefined reference to `__stginit_ZCMain'
13:41:51 <mgsloan> Main.c:(.text+0x24): undefined reference to `ZCMain_main_closure'
13:41:52 <mgsloan> ?
13:42:07 <nominolo> > let f x = let omega = last x in omega in f [1..5]
13:42:09 <lambdabot>  5
13:42:33 <cdtw> mgsloan: Trying to compile a program as an executible when it doesn't have a "main :: IO ()" function?
13:42:46 <mgsloan> I've tried reinstalling ghc, but it doesn't fix it.  This happened when I went from dapper -> fiesty
13:42:57 <Figs> closures when used in functional program are only found in 'impure' languages, right?
13:43:00 <Cale> mgsloan: Do you have a main?
13:43:07 <mgsloan> actually, I don't oddly enough
13:43:17 <Cale> mgsloan: That's the problem.
13:43:19 <nominolo> Figs: no
13:43:20 <mgsloan> lol
13:43:34 <Figs> functional programming*
13:43:39 <oerjan> Cale: the motivating example in the report is [(n,s)] = reads t
13:43:42 <Figs> no?
13:43:42 <nominolo> Figs: still no ;(
13:43:43 <mgsloan> I guess its been a while since i've used ghc compilation...
13:43:52 <Cale> Figs: Closures are something which you don't have to worry about, they're handled by the compiler.
13:43:54 <Figs> how do you do closures without state?
13:44:03 <Figs> doesn't make sense to me
13:44:11 <Cale> Figs: closures are just  (code, environment) pairs.
13:44:25 <nominolo> Figs: a closure is the run-time environment of a function
13:44:33 <Cale> Unless you're writing a compiler, you don't have to worry about it.
13:44:35 <nominolo> the variables in it need not be mutable
13:44:35 <mgsloan> well, now I get errors like that, but for QuickCheck, which I am using
13:45:13 <Cale> Even if your (code, environment) pair is immutable, you can always construct a new one with the same code and a different environment, for instance.
13:45:25 <Cale> Or reduced code, and a modified environment.
13:45:33 <Figs> huh
13:45:41 <Figs> that seems kind of funky, but ok
13:45:44 <Cale> So you can evaluate an impure functional language with only immutable data structures.
13:45:48 <mgsloan> math.o: In function `r24q_info':
13:45:48 <mgsloan> (.text+0x3415): undefined reference to `QuickCheckzm1zi0_TestziQuickCheck_zdf17_closure'
13:46:00 <mgsloan> etc many times
13:46:01 <sorear> mgsloan: --mke
13:46:05 <sorear> *make
13:46:06 <Figs> I mean, pure languages don't have closures directly, right?
13:46:11 <nominolo> Figs: consider mkAdder x = \y -> x + y
13:46:19 <sorear> Figs: yes they do! :)
13:46:21 <mgsloan> sorear - ah, thanks
13:46:27 <sorear> Figs: eg, in that error message :)
13:46:29 <nominolo> the returned function has to remembier the value of x
13:46:31 <Cale> Figs: Well, neither to impure ones. Closures are just an implementation strategy for what they really do have.
13:46:38 <Cale> (First class procedures or functions)
13:46:46 <Cale> (not typically, anyway)
13:46:51 <sorear> Cale: You need lexical scoping, too.
13:46:54 <Cale> yeah
13:47:08 <Cale> Well, you can do non-lexical scoping with closures too.
13:47:16 <Cale> You just don't close over everything.
13:48:05 <Figs> hmm, I guess I didn't really think of that as a closure
13:48:05 <Cale> any variable that's dynamic just doesn't end up in the closure which results when you evaluate a lambda
13:48:11 <Figs> but I can see what you mean
13:48:29 <Figs> ok
13:48:39 <Figs> thanks
13:48:50 <Cale> So we don't really talk about closures much, we talk about first-class functions, which we certainly do have.
13:49:15 <Cale> As for mutable variables, we have those too, but only in the scope of particular monads.
13:49:58 <Cale> (and monadic actions are first class, so we get all the same kinds of effects which you can get with first class procedures and mutable state in impure languages)
13:50:41 <Figs> I haven't really gotten to dealing with monads yet, so that statement doesn't make much sense to me
13:50:43 <nominolo> to the compiler, every function value is a closure
13:51:31 <Cale> Figs: Well, given that you seem to know a bit about functional programming, do you know much about embedded domain-specific languages?
13:51:41 <Cale> They're common in scheme and so on.
13:51:43 <Figs> a bit
13:51:47 <Figs> I don't know scheme though
13:51:52 <nominolo> functions that have no free variables just have no values stored apart from the function value
13:51:58 <Figs> but I've done what I think sort of amounts to the equivalent in C++
13:52:18 <Figs> (having not experienced the 'real' thing, it's hard for me to be sure)
13:52:26 <Cale> Basically, they're really good APIs, ones which are powerful enough to express computations in some domain, so that it's like you have a small programming language sitting inside your general purpose one.
13:52:34 <Figs> yes
13:52:42 <Figs> I put a modified version of BNF into C++
13:52:46 <Figs> so you could write things like
13:53:02 * mgsloan shields eyes
13:53:04 <Cale> Monads are just a particular way of structuring those APIs so that you get a common interface of functionality across many such EDSLs.
13:53:32 * int80_h peeks
13:53:38 <Cale> For example, so that you don't have to write a for-each loop in each of your languages, you just pull it out of a library.
13:54:07 <Cale> That's I think the best way for programmers to think about them, anyway.
13:54:08 <mgsloan> I'd like to see a good for each syntax on the IO monad
13:54:14 <Cale> mapM/forM
13:54:25 <Cale> forM [1..10] print
13:54:39 <shachaf> Cale: Wouldn't you use forM_ there?
13:54:46 <Cale> shachaf: right.
13:55:06 <shachaf> Why would you ever use _ functions, by the way? Is it just that they don't build an unnecessary list, or is there another reason?
13:55:14 <Figs> http://rafb.net/p/6VQaAj62.html
13:55:15 <Cale> that's the only reason
13:55:16 <lambdabot> Title: Nopaste - sample embedded BNF in C++ using my library
13:55:41 <Cale> If it's the last action in your chain, you might want forM_ because of the nicer type it'll give you.
13:55:42 <shachaf> Figs: Someone embedded BNF-ish in Haskell.
13:55:59 <Cale> Figs: you'll like Parsec :)
13:56:18 <Figs> never heard of it, but I'll take a look
13:56:30 <Cale> http://legacy.cs.uu.nl/daan/download/parsec/parsec.html
13:56:41 <Figs> what really bugs me about C++ and imperative languages in general is that it's hard to seperate relationships from actions
13:56:44 <Cale> There's a whole tutorial there, you can have a look at the examples :)
13:57:00 <Figs> thanks
13:57:32 <Figs> that sample was from a fairly basic ini-parser I wrote a couple days ago
13:58:22 <mgsloan> I guess you'd have to do something like forM_ xs (\x -> do ...) for a foreach
13:58:27 <Figs> range() works by indicating a range of ascii character values for anyone who's curious
13:58:27 <Cale> yeah
13:58:36 <Cale> mgsloan: It's convenient to use a $ there
13:58:44 <Cale> forM_ xs $ \x -> do ...
13:58:45 <mgsloan> good point
13:59:13 * int80_h hiccups
13:59:42 <Figs> int80_h, take a look at my code, maybe it'll scare the hiccups away :P
14:00:13 <Cale> Figs: So in your case, parsers are values?
14:00:27 <Figs> effectively
14:00:40 <Figs> I can do key.match(some_string);
14:00:56 <Cale> I find it nice that you've chosen the same syntax for combining parsers sequentially as we'd use in any monadic parsing library :)
14:00:58 <Figs> and it will return a result that is comparable as a bool, and has the parts
14:01:15 <Figs> really?
14:01:26 <Cale> Yeah >> is sequential composition in any monad.
14:02:05 <Cale> You'll see that the parsec parsers there use a lot of do-notation, but it's a shorthand for chains of >> and >>=
14:02:15 <Figs> ah
14:02:34 <Figs> yeah, >> seemed the most appropriate thing to use
14:02:41 <Figs> since it sort of indicates 'followed by'
14:02:41 <Cale> >>= is like >>, except that it expects a function as its right parameter, and uses the result of the left computation as the parameter to that function to see what to do next.
14:02:50 <Figs> and has about the right level of precedence
14:03:30 <Cale> So >>= gets used in do-notation whenever you have something that looks like   x <- foo
14:03:32 <Figs> you can take a look at the rest of the project herfe:
14:03:33 <Figs> http://code.google.com/p/libfigconfig/
14:03:34 <lambdabot> Title: libfigconfig - Google Code
14:03:51 <Figs> I think my coding isn't great though; it was sort of hackish, but someone liked it
14:04:14 <Cale> Overall, it's the right idea, I think :)
14:04:28 <Figs> :)
14:05:10 <shachaf> Figs: If you like BNF, look at http://www.ben-kiki.org/oren/YamlReference/YamlReference-0.4.tar.gz /YamlReference-0.4/Text/Yaml/Reference.bnf . It's not (meant to be) efficient, but it looks very BNF-y.
14:05:14 <lambdabot> http://tinyurl.com/25ttre
14:06:12 <Figs> huh
14:06:14 <Cale> Figs: Oh, one other thing I should point out is that Parsec now comes with GHC, and it's moved to Text.ParserCombinators.Parsec, in case you want to try it out.
14:07:08 <Figs> mmm ok
14:07:17 <Figs> I'm not really good enough with haskell yet
14:07:55 <Cale> If you're far enough along to want to be able to do IO, you can steal the same ideas for understanding how IO is done.
14:08:24 <Figs> ok
14:08:31 <Cale> Imagine if IO actions were, like your parsers, just values, and there were some operators for sticking them together into larger IO actions.
14:08:40 <Cale> Well, that's exactly how it works :)
14:09:08 <Cale> In Haskell, a value of type  (IO Integer)  is like a program that, when run, will produce an integer.
14:09:28 <Figs> ok
14:09:51 <Cale> Eventually, you define a main action, and the runtime system and compiler handles actually figuring out what needs to be done.
14:10:20 <Figs> I'm going to have to look into this do notation
14:10:26 <Figs> I haven't learned it yet
14:10:34 <Cale> You have combining functions like >> and >>= that I described above, and the do-notation gives you fairly normal-looking imperative syntax.
14:10:44 <Cale> It's just this:
14:10:57 <Cale> do { x ; <stmts> } = x >> do { <stmts> }
14:11:06 <Cale> do { x } = x
14:11:22 <Cale> do { v <- x; <stmts> } = x >>= \v -> do { <stmts> }
14:11:42 <Cale> do { let <decls>; <stmts> } = let <decls> in do { <stmts> }
14:11:43 <Figs> that's fairly cryptic to me ;)
14:11:53 <Cale> Those are the translation rules into >> and >>=
14:12:05 <Cale> So if you understand what >> and >>= do, you'll understand do-notation.
14:12:06 <shachaf> Figs: (The {}/; are not required; you can use indentation instead, like the rest of Haskell.)
14:12:08 <mgsloan> I'd recommend learning the monad combinators first, how to do IO with them and such
14:12:27 <Figs> alright
14:12:38 <Cale> the (\v -> ...) is a lambda, as I hope you already know :)
14:12:48 <Figs> I understand that, sort of
14:12:52 <mgsloan> learning do notation first kinda mystifies what's going on
14:13:04 <Cale> It's just the function which takes v and returns whatever is on the right of the arrow
14:13:27 <Figs> well, it's things like v <- x that I still haven't quite memorized how to read
14:13:35 <Figs> even though I've looked it up about a half dozen times
14:13:42 <Figs> and was just reading and asking about it yesterday
14:13:43 <Figs> :S
14:13:47 <Cale> At a high-level, that means: "run x and bind the result to v"
14:14:07 <Cale> So if x :: IO Integer, then v :: Integer
14:14:10 <Figs> the way I think I saw it yesterday was in something like
14:14:21 <shachaf> mgsloan: Yes, do-notation for learning IO (e.g., the way YAHT teaches it) is just confusing if you don't understand what it turns into.
14:14:23 <Figs> [foo x | x <- somelist]
14:14:27 <Cale> oh
14:14:32 <Cale> that's a list comprehension
14:14:34 <Figs> yes
14:14:40 <Cale> Which is something "different"
14:14:42 <Figs> I thought it was like, for each x in somelist
14:14:46 <Cale> though later on, you'll realise it's the same
14:14:48 <Cale> yeah
14:14:55 <Cale> That's exactly what it is.
14:15:11 <Figs> I don't really understand how that translates in the v <- x above
14:15:12 <Cale> In fact, list comprehensions are just another way to write computations in the list monad. :)
14:15:25 <Cale> The v <- x above was for do-notation
14:15:32 <Cale> rather than list-comprehensions
14:15:33 <Figs> the <- is different?
14:15:35 <Cale> yeah
14:15:46 <Figs> overloaded operator?
14:15:56 <Cale> Just different part of the syntax tree.
14:15:57 <sorear> no, magic syntax
14:16:12 <Cale> Though by a subtle route, it actually *is* the same <-, but that takes a bit of explanation to see.
14:16:36 <nopcode> re
14:16:41 <oerjan> [foo x | x <- somelist] == do { x <- somelist; return (foo x) }
14:17:06 <Cale> Where the monad being used on the right is the list monad, and x >>= f = concat (map f x)
14:17:13 <nopcode> ok how do i construct a tuple type?
14:17:19 <Cale> (a,b,c)
14:17:26 <nopcode> i mean a type
14:17:37 <Cale> data MyTuple a b c = MT a b c
14:17:57 <nopcode> ah ok
14:18:07 <Figs> I think haskell has most of the things I was talking about with the design of that imperative language I was considering
14:18:19 <Figs> just from a different perspective and with very different syntax
14:18:23 <Cale> :)
14:18:41 <Cale> It really is pretty hard to find language features which you can't embed into Haskell nicely.
14:18:48 <Figs> I mean, ultimately, the type classes seem to be a lot like the interface concepts I was thinking of
14:18:52 <Cale> (with, say, a library)
14:19:03 <Figs> but, that might just be my n00bish mis-interpretation
14:19:03 <Cale> typeclasses are a lot like C++ concepts
14:19:34 <Cale> If those even exist yet :)
14:19:35 <Figs> I think that's also a very similar thing to what I was describing
14:19:39 <Figs> they don't
14:19:45 <Figs> but will
14:19:50 <Figs> in 200x
14:19:50 <Figs> :P
14:19:55 <Figs> where x is probably 9
14:19:58 <Cale> In fact, it should be the other way around
14:20:12 <Cale> C++ concepts were stolen directly from Haskell, and they admit this :)
14:20:17 <Figs> hehehe
14:20:37 <Figs> I don't like C++'s notation for templates
14:20:43 <Cale> Neither do I
14:20:53 <treble> What do C++ concepts give you?
14:20:57 <chessguy> Cale, hmm. care to cite your source?
14:21:01 <sorear> treble: type classes IIRC
14:21:20 <Cale> For most of the applications you really want to use it for, namely, for parametric polymorphism, it's far too verbose.
14:21:25 <sorear> Figs: hehe.  look at GHC's core output -ddump-simpl
14:21:41 <sorear> Figs: explicit instantiation of polymorphic functions a la C++
14:21:54 <Binkley> actually, I asked Stroustrup during a talk he gave whether concepts had anything to do with type classes, and he denied it
14:22:00 <Cale> Binkley: really?
14:22:18 <Cale> Binkley: They cite the original typeclasses paper in their paper, as I recall.
14:22:31 <Binkley> yeah, he said he looked at type classes but the eventual design didn't have anything to do with them, and he said "I talked to Phil Wadler about it and he agreed with me"
14:22:42 <Cale> Oh, that's too bad.
14:22:48 <sorear> Binkley: At the time, did he think templates had anything to do with Damas-Milner parametric polymorphism?
14:23:00 <Binkley> at HOPL, I mentioned this to Phil, who was surprised :-)
14:23:26 <Cale> haha
14:23:35 <Figs> HOPL?
14:23:43 <Binkley> sorear: I don't know...
14:24:38 <Figs> type inference is a much nicer way to go about programming, I think
14:24:42 <Binkley> Figs: a workshop - History of Programming Languages
14:24:45 <Figs> ah
14:25:05 <Figs> here's an article on C++0x
14:25:06 <Figs> http://www.artima.com/cppsource/cpp0xP.html
14:25:07 <lambdabot> Title: A Brief Look at C++0x
14:25:35 <Figs> for those of you who were curious
14:25:48 * sorear confidently predicts that the language to replace C++ will *not* be called C++.
14:25:56 <Figs> :P
14:26:05 <Figs> some people think C++ has already been replaced by java
14:26:14 <Figs> I disagree, but eh
14:26:25 <dolio> There's a big improvement.
14:26:50 <Cale> sigh.
14:27:52 <Cale> I almost don't care anymore what C++ will be replaced with, because in all likelihood, it will not be all that wonderful compared to what *could* have replaced it.
14:28:01 <Figs> :P
14:28:46 <Figs> I hope in college I'll learn something about optomization
14:28:50 <Cale> Otoh, #haskell seems to be consistently over the 300 user mark these days.
14:28:54 <sorear> *We*'ll all be programming in a lambda-calculus language.
14:29:10 <Cale> sorear: exactly
14:29:32 <Binkley> ?quote qwe1234 lambda
14:29:33 <lambdabot> qwe1234 says: oh come on, what do 'functional languages' have to do with lambda calculus?
14:29:41 <Figs> do-statements basically translate imperative type actions into a functional behavior, don't they?
14:29:54 <Cale> The industry is always 25 years behind, with worse syntax than what was available back then.
14:30:02 <sorear> I find it very amusing how Church's abstract nonsense turned out to make for better programming than Turing's real-world metaphors.
14:30:24 <shachaf> Figs: No, they translate at the syntax level.
14:30:29 <Figs> yes
14:30:33 <Cale> Figs: but yeah
14:30:40 <sjanssen> @remember sorear I find it very amusing how Church's abstract nonsense turned out to make for better programming than Turing's real-world metaphors.
14:30:40 <lambdabot> Done.
14:30:45 <shachaf> Figs: (>>=) is the one that does all the work -- and it doesn't have to work with "imperative" actions.
14:30:50 <Cale> they translate an imperative-esque treatment of a computation into a functional one
14:31:06 <Figs> I think there might be a more extensive version
14:31:14 <Figs> I'm going to have to think about this for a while
14:31:19 <Cale> > do { x <- [1..3]; y <- [1..3]; return (x,y) }
14:31:21 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
14:31:33 <Cale> There's no actual side-effects or IO or state going on there
14:31:44 <Cale> Because it's the list monad, which is pure :)
14:31:48 <Figs> eh
14:33:07 <hpaste>  nowhereman pasted "recursion with lists" at http://hpaste.org/1493
14:33:10 <Cale> In the list monad, "assignments" x <- ls, will assign x to values of ls in all possible ways.
14:33:48 <Figs> hmm
14:33:56 <Figs> I'll have to make a joke library one of these days
14:34:01 <nopcode> how do i make a "lookup table" in haskell?
14:34:01 <Cale> Uh, who is nowhereman?
14:34:05 <Figs> where it will impliment most of lisp
14:34:07 <Figs> in C++
14:34:09 <nopcode> a table mapping integers to strings in this case
14:34:09 <treble> :t lookup
14:34:11 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
14:34:13 <mrTime> oh, its me, sorry mess up
14:34:19 <Figs> we'll call it libgreenspun!
14:34:22 <ibid> Cale: john lennon, if you believe some people :)
14:34:25 <nopcode> just a function?
14:34:26 <ibid> "sitting in his nowhere land"
14:34:27 <sorear> who is nowhereman?
14:34:32 <mrTime> right!
14:34:33 <Cale> mrTime: []:xs is a list of lists whose first element is the empty list
14:34:52 <mrTime> that was my intention
14:35:10 <Cale> mrTime: But then [a] is not necessarily a list of lists.
14:35:17 <Cale> So the types don't match.
14:35:22 <treble> > lookup 2 [(1,"one"),(2,"two"),(3,"three")]
14:35:24 <lambdabot>  Just "two"
14:35:41 <ibid> nowhereman: making all your nowhere plans for nobody? :)
14:36:25 <ibid> (do you have a point of view?)
14:36:33 <ibid> bah, should go to bed
14:36:49 <Cale> nopcode: Be warned, association lists are an extremely common source of inefficiency in Haskell programs. If your lists are long, or you have to do lots of lookups, I'd recommend using Data.Map.
14:37:01 <nowhereman> cale: so I have to use the same type in all lines - can't in one pattern matching 'a' be a List and in another line something different?
14:37:22 <Cale> nowhereman: No, unless you use a typeclass, and have instances for each type you want to support.
14:38:07 <Cale> Parametrically polymorphic functions are parametrically polymorphic because they can't actually look at what type of values it is that they're manipulating.
14:38:41 <nowhereman> mmh, ok thats a point
14:39:18 <Cale> (also, with the way that Haskell compilers work, that information is gone by the time the program is running)
14:41:06 <nowhereman> so I guess I need some kind of pseudo-class, which aliases the show-class/function
14:41:23 <Cale> While on the one hand, it seems a little sad to have to introduce more complex code to make things type-directed, it's also the source of lots of guarantees you get from the type system.
14:41:54 <Cale> For example, length :: [a] -> Integer, ensures that when length is passed a list of integers, it can't just hand you the first one.
14:42:16 <Cale> If it's right for one type of lists, it's right for them all.
14:42:40 <Cale> Yeah, you probably actually want your own Show class.
14:42:56 <Cale> Or you want your own list type, with its own instance of Show.
14:43:54 <Cale> One thing you could do is just to newtype the existing list type, and derive all the basic classes (via newtype-deriving as well, if necessary), except Show, which you define yourself.
14:44:11 <Cale> newtype MyList a = ML [a]
14:44:58 <Cale> Well, that would work so long as you don't want *genuinely* different behaviour for nested lists.
14:45:01 <Cale> hmm
14:45:38 <Cale> Oh, you're just indenting them farther, you'll need to do some string manipulation, but that could work.
14:45:51 <Figs> bbl thanks guys
14:46:51 <Cale> Another option is to define such a show function for trees, and a way to turn a list of lists into a tree.
14:47:17 <Cale> In fact, that mostly already exists.
14:48:20 <nowhereman> yes, but I think the conversion into a tree is quite the same problem like the original one
14:48:53 <Cale> Well, if you want it to work with arbitrarily deep nestings, yes.
14:49:53 <nopcode> hmm do you have to use Ints for references in haskell?
14:50:12 <nopcode> i mean, is there a reference type or do you have to build datastructures and use indices?
14:50:22 <Cale> nopcode: There's IORefs and STRefs
14:50:31 <Heffalump> there are reference types inside certain monads (IO and ST)
14:50:36 <Cale> There's also arrays.
14:50:44 <Cale> (but they use indices)
14:50:50 <nopcode> yeah but i mean for a graph for example
14:51:11 <nopcode> to represent the edges
14:51:11 <Cale> Usually for a graph, you'll use an adjacency matrix represented as an array.
14:51:24 <Cale> There are other ways, but that's fairly convenient.
14:51:26 <nopcode> that wouldnt scale ;)
14:51:37 <nopcode> and then you need cardinal indices too
14:52:34 <Cale> There's Data.Graph.Inductive, it uses lists of "contexts", which each consist of a vertex and (some of) its incoming and outgoing edges.
14:53:03 <Cale> It turns out you can define rather nice general operations on graphs represented like that.
14:53:18 <Cale> You can also build graph structures in memory using laziness' sharing.
14:53:28 <Cale> But that's not really useful for manipulation.
14:53:28 <nowhereman> thanks a lot for all the ideas, it's rather late so I'll continue tomorrow, good night :)
14:53:50 <nopcode> mh
14:53:54 <Cale> If you want manipulable graph structures with references, you can use ST.
14:54:41 <Cale> How big are the graphs you're working with?
14:54:53 <hpaste>  Nachen pasted "Nachen" at http://hpaste.org/1494
14:55:11 <Cale> If they're not densely connected, you might try a sparse matrix representation of some kind.
14:55:45 <nopcode> just fooling around
14:56:04 <Cale> Oh, this is good. HPaste is getting spam now.
14:57:16 <sorear> it has been for a while
14:58:10 <sorear> Cale: deleted
14:58:21 * sorear writes a spam detector in irssi highlight rules
14:58:54 <Saizan> isn't better to write that in HAppS and patch hpaste?
14:59:33 <cjay> there is much more spam in the history :/
14:59:43 <sorear> no, because state in haskell sucks badly enough that you fear restarting programs
15:00:10 <sorear> we've been up to paste 2500 before!
15:00:13 <Cale> sorear: hm?
15:00:17 <sjanssen> s/in haskell/in some haskell frameworks/
15:00:19 <sek> % hoogle String -> [Char]
15:00:27 <sorear> s/in some/in all existing/
15:00:45 <sorear> lambdabot does it, happs does it - am I missing any?
15:00:46 <Cale> sorear: doesn't it have a way to record that state to disk?
15:01:18 <Saizan> i never had a problem with my happs app, even killing it badly.. but i don't have so may writes
15:01:22 <sorear> Cale: sure.  then someone does something and Read breaks, reads returns [], the state is reset.
15:01:31 <sek> @hoogle String -> [Char]
15:01:32 <lambdabot> No matches, try a more general search
15:01:35 <Cale> nopcode: iirc, unboxed arrays of booleans are stored packed into bits
15:01:59 <Cale> nopcode: so it would be fairly efficient for quite a while :)
15:02:00 <jfredett> sek: isn't a string just an alias for [Char]?
15:02:05 <Lemmih> HPaste lost its state due to a 'rm -fr * .o'-style mistake.
15:02:25 <sek> jfredett, yeah i was just being a bit daft about something :-
15:02:28 <sorear> Lemmih: Oh?
15:02:33 * sorear feels better
15:02:38 <jfredett> i see.
15:02:52 <sjanssen> sorear: recant, sinner!
15:03:02 <Lemmih> HAppS is very careful about never damaging or losing state.
15:05:13 <Saizan> it doens't even start if it fails reading the state, no?
15:06:01 <sek> how do i read a char? As in (read "5")::Int works, but what about '5'
15:06:13 <sorear> > read "'x'" :: Char
15:06:17 <sorear> sek: ^^^
15:06:17 <lambdabot>  'x'
15:06:17 <Cale> sek: read "'5'"
15:06:17 <shachaf> > read "'5'" :: Char
15:06:19 <lambdabot>  '5'
15:06:20 <hpaste>  jimjack01 pasted "jimjack01" at http://hpaste.org/1495
15:06:24 <sorear> @quote stereo
15:06:24 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
15:06:42 <Cale> or, if you have a String and you want the first character of it, just use head.
15:06:46 <sjanssen> perhaps we need a simple captcha like paste.lisp.org?
15:06:58 <sjanssen> (just a static image that says 'lisp')
15:07:07 <sek> basically i have this: let f 0 = 1; f n = n*(f (n-1)); y=show $ f 100; g= \x -> (read x)::Int in foldr ((+).g) 0 y
15:07:27 <sek> so a list of chars that i would alternatively like to be a list of Strings
15:07:28 <Lemmih> Saizan: Correct.
15:07:33 <sorear> sjanssen: I never could read lisppaste's captcha.  Yes, I can see images.  but lisppaste hides theirs in nonstandard html
15:07:59 <Saizan> ?type map (\x -> [x]) -- sek
15:08:01 <lambdabot> forall a. [a] -> [[a]]
15:08:07 <sorear> besides: ./07.01.17:22:32:36 <glguy> lisppastes captcha was a breaking point and motivation for this for me
15:08:13 <sjanssen> sorear: yeah, just looking at the code now.  They draw the image with divs?
15:08:15 <Cale> sek: While you can do something like what I think you want to do all in one foldr, it'll be clearer if you separate it out.
15:08:24 <sorear> sjanssen: yup.
15:08:32 <sorear> not non-standard, just bad
15:08:34 <sjanssen> sorear: we can do that, just not stupidly
15:08:37 * sorear remebmbers now
15:08:38 <sek> Cale, what function would i need for that?
15:08:52 <sorear> sjanssen: AACK!  please don't clone it!
15:09:00 <Cale> sek: you want the digit sum?
15:09:21 <sek> well essentially yeah, but would ideally like a way of doing the way i've started :D
15:09:31 <sek> i always get tangled in types
15:09:32 <sjanssen> sorear: a simple question (in text) like "What language is hpaste written in?" would work fine
15:09:33 <Cale> sum . map (read . (:[])) . show $ 437218904
15:09:35 <Cale> > sum . map (read . (:[])) . show $ 437218904
15:09:37 <lambdabot>  38
15:10:02 <sek> ah so it's :[] that i'm looking for
15:10:12 <sorear> sjanssen: it is to be noted that every single hpaste spam has had nick == description
15:10:19 <sek> let f 0 = 1; f n = n*(f (n-1)); y=show $ f 100; g= \x -> (read x)::Int in foldr ((+).g.(:[])) 0 y
15:10:23 <sorear> and I do mean every
15:10:29 <sek> > let f 0 = 1; f n = n*(f (n-1)); y=show $ f 100; g= \x -> (read x)::Int in foldr ((+).g.(:[])) 0 y
15:10:32 <lambdabot>  648
15:10:34 <yaxu> spam bots like filling in fields, so you can trap them into identifying themselves by providing a dummy field
15:10:52 <sek> excellent. Thanks Cale sorear Saizan and jfredett :)
15:11:59 <Saizan> or we could simply check for density of links
15:15:48 <Binkley> ?yow
15:15:48 <lambdabot> BARRY ... That was the most HEART-WARMING rendition of "I DID IT MY
15:15:48 <lambdabot> WAY" I've ever heard!!
15:18:59 <sorear> I have 100% of hpaste spam on /hilight now. :)
15:27:46 <Saizan> sorear: you just need to delete the old spam now :)
15:28:04 <sorear> Saizan: What numbers? :)
15:28:50 <Saizan> 1483..1489
15:29:35 <Saizan> no, 1483 is real
15:30:14 <sorear> oops
15:30:27 * sorear checked himself, misremembered, and deleted it
15:31:18 <Saizan> 1481,1472..1479
15:33:25 <sorear> first three pages are clean now
15:34:28 <Saizan> uhm, shouldn't we have the number for each paste, in the list?
15:34:51 <sorear> we do
15:35:27 <sorear> <td><a href="/1491">view</a></td><td>pierre</td><td>2h</td><td>existential types</td><td>0</td>
15:35:50 <Saizan> visible in the rendered page, i mean :)
15:35:53 <sorear> Small Matter Of Scraping (tm)
16:21:45 <int80_h> my_filter :: t -> [t1] -> [a]
16:21:55 <sohail> hey, how do you manage runtime polymorphism in haskell
16:21:55 <int80_h> help me interpret please
16:22:10 <int80_h> what is the expected input for my_filter, what does it look like?
16:23:07 <misterPhyrePhox> hello
16:23:17 <misterPhyrePhox> i was wondering, how are you supposed to write a server using Network?
16:23:34 <misterPhyrePhox> in imperative languages, you can poll the open sockets or spawn a new thread for every connection
16:24:21 <misterPhyrePhox> but i don't see how you could handle multiple connections in haskell
16:24:32 <misterPhyrePhox> or should i reconsider my choice of language?
16:25:05 <sorear> just poll the open sockets or spawn a new thread for every connection
16:25:15 <sorear> both are quite possible in haskell
16:25:29 <sorear> (though the second is rather more convenient)
16:25:42 <int80_h> sorear could you give me an example of the expected input for my_filter that I pasted to the channel?
16:25:48 <mauke> int80_h: that function looks useless
16:25:59 <int80_h> it's an exercise from yaht
16:26:12 <misterPhyrePhox> but i don't see any methods for polling in the Network documentation, nor do i see any libraries for threading
16:26:13 <sorear> int80_h: by parametricity, my_filter always returns [] or bottom
16:26:21 <sorear> int80_h: no matter how you call it
16:26:38 <sorear> @docs Control.Concurrent
16:26:38 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html
16:26:40 <sorear> misterPhyrePhox: ^^^^
16:26:45 <mauke> misterPhyrePhox: http://haskell.org/ghc/docs/latest/html/libraries/
16:26:56 <misterPhyrePhox> oh!
16:26:57 <misterPhyrePhox> i see
16:27:03 <int80_h> could you give me an example of the input it expects? I'm having difficulty with syntax
16:27:06 <misterPhyrePhox> i was searching for "thread"
16:27:07 <misterPhyrePhox> thank you
16:27:08 <dmwit> int80_h: There are no restrictions on t/t1/a?
16:27:16 <mauke> int80_h: it ignores its arguments anyway
16:27:24 <int80_h> really?!
16:27:38 <sorear> int80_h: yup
16:27:40 <mauke> well, what would it do with them?
16:27:55 <int80_h> I will paste the code, hold on
16:28:01 <sorear> int80_h: intuitively, it doesn't have anything it CAN do since it doesn't know enough about the types
16:28:02 <int80_h> it's supposed to be an example of recusion
16:28:04 <sorear> formally
16:28:14 <sorear> @google Theorems for free
16:28:18 <lambdabot> http://www.cs.chalmers.se/~koen/Aafp/free.ps
16:28:23 <mauke> oh, then bottom is entirely possible
16:28:35 <sorear> but even I'm having a bit of trouble understanding the formal explanation :)
16:28:41 <mauke> @free my_filter :: a -> [b] -> [c]
16:28:41 <lambdabot> $map h . my_filter x = my_filter (f x) . $map g
16:30:47 <oerjan> @type (|>)
16:30:51 <lambdabot> Not in scope: `|>'
16:32:21 <hpaste>  int80h pasted "what's the function call look like?" at http://hpaste.org/1496
16:32:57 <mauke> int80_h: that function doesn't have the type you pasted
16:33:29 <mauke> example call: my_filter even [1 .. 10]
16:34:22 <oerjan> int80_h: you are missing a t in the second line
16:35:06 <mauke> oh. haha
16:35:16 <mauke> that's insidious
16:36:42 <int80_h> um...okay this was right from the tutorial
16:36:59 <int80_h> the second vline looks fine to me but i'm learning
16:37:10 <mauke> int80_h: it says filer instead of filter
16:37:12 <int80_h> what shoul it look like then?
16:37:18 <int80_h> grrr heh
16:37:24 <int80_h> insidious indeed
16:42:36 <nominolo> heya ekidd
16:42:47 <ekidd> Heya!
16:43:47 <ekidd> I've been doing some JavaScript hacking lately, trying to get it to behave at least as nicely as Ruby. :-)
16:44:13 <ekidd> I may be back in Haskell land in a couple of weeks, revising a paper.
16:48:34 <chessguy> int80_h, you would call it something like this:
16:48:42 <chessguy> > filter (>3) [1..5]
16:48:43 <lambdabot>  [4,5]
16:48:50 <mauke> > filter even [1..10]
16:48:51 <lambdabot>  [2,4,6,8,10]
16:49:55 <nominolo> ekidd: oh, so your rewriting ruby in javascript, too? ;)
16:50:05 <nominolo> *you're
16:50:16 <ekidd> nominolo: Oh, yeah. Are you? :-)
16:50:32 <nominolo> no steve yegge
16:50:49 <chessguy> javascript is an interesting language
16:50:52 <ekidd> Oh, yeah. But his stuff is all internal and won't run in a browser. :-(
16:51:20 <ekidd> chessguy: It's _almost_ as reasonable as SmallTalk, but you need to hit it with some medium-sized sticks first.
16:51:30 <nominolo> ekidd: right
16:51:49 <chessguy> i'll take your word for that one
16:52:02 <nominolo> ekidd: i guess we'll see the details in your blog sometime?
16:52:16 <ekidd> http://www.randomhacks.net/articles/2007/07/01/ruby-metaprogramming-javascript-rspec-bdd
16:52:18 <lambdabot> Title: Ruby-style metaprogramming in JavaScript (plus a port of RSpec), http://tinyurl.com/2frl9w
16:52:53 <ekidd> nominolo: Do take a look at the interactive spec checker--I'd love to have one for Haskell's QuickCheck.
16:53:21 * ekidd wishes he had time for even more Haskell projects
16:54:56 <nominolo> what are you using at work?
16:55:12 <ekidd> Scheme, which is pretty pleasant.
16:56:10 <nominolo> yeah.  i guess so
16:56:33 <ekidd> I think that we could theoretically use something like O'Haskell, if it were still maintained, but we really need subtyping. So Haskell is out.
16:57:23 <nominolo> i've been programming in CL for money.  but i can't say it was professional -- it wasn't at all!
16:58:43 <int80_h> is there a way to have ghci show me explicitly what is going on with each call to a recursive function?
16:58:53 <int80_h> the way clisp can?
16:59:01 <nominolo> int80_h: no
16:59:11 <chessguy> not reliably
16:59:31 <nominolo> int80_h: there's the interactive debugger ghc HEAD
16:59:47 <nominolo> but it's not as comfortable, either
17:00:05 <chessguy> when's that due out anyway?
17:00:11 <nominolo> int80_h: the problem is, that haskell evaluation works a little different
17:00:21 <chessguy> @where ghc
17:00:21 <lambdabot> http://haskell.org/ghc
17:00:27 <mauke>  my_filter p xs | trace ("my_filter ? " ++ show xs) False = undefined
17:00:27 <nominolo> chessguy: it'll be in ghc 6.8
17:00:34 <mauke> you could make that the first line of my_filter
17:00:36 <chessguy> which is...
17:00:46 <int80_h> hmm okay I know I have fudged this function but I would like a way to think it out rather than have someone show me the right answer
17:00:59 <nominolo> int80_h: a workaround is to use "trace"
17:01:00 <int80_h> my_filter is fine
17:01:10 <int80_h> I am doing a fibonacci function now
17:02:06 <mauke>  fib n | trace ("fib " ++ show n) False = undefined
17:02:11 <nominolo> ekidd: how do you make database access from the client side secure?
17:03:03 <ekidd> nominolo: Well, right now I don't support anything other than subclassing and writing test suites. :-) But yeah, there are some databases in my future plans...
17:05:10 <nominolo> ekidd: do you know john hughes' QC implementation for Erlang?
17:05:23 <ekidd> No, that's cool!
17:05:59 <nominolo> it's not open source, but you might be able to draw some inspiration from it
17:06:48 <nominolo> http://www.cs.chalmers.se/~rjmh/ErlangQC/
17:06:49 <lambdabot> Title: Erlang QuickCheck
17:07:22 <chessguy> why would the haskell-mode for emacs package at http://www.iro.umontreal.ca/~monnier/elisp/#haskell-mode come with a makefile...i don't get it
17:07:24 <lambdabot> Title: Emacs Lisp packages
17:07:45 <ekidd> nominolo: Thanks for the pointer! Did you get my /msg a minute ago?
17:07:48 <nominolo> he's now developing commerciallye, says, it might be his chance to become rich :)
17:08:06 <nominolo> yep
17:10:21 <ekidd> The money is in apps, not test harnesses. :-)
17:43:23 <chessguy> hmm, i can't quite get haskell mode working on xemacs under windows. anyone care to help?
17:45:48 <hpaste>  neotara pasted "neotara" at http://hpaste.org/1497
17:46:57 <chessguy> sjanssen, spam attack on hpaste
17:47:21 <ari> Mmm, silk stockings and Haskell
17:48:05 <dons> fixed, chessguy
17:48:26 <chessguy> danke
17:49:09 <dons> its the same person, someone's doing it manually i think. so we could block the ip
17:53:23 * SamB wonders why hpaste's type is a generalization of fmap's ;-P
17:53:24 <mgsloan> dcoutts - do you know if anyone has written utils for gtk2hs menus (kinda like gtk's Item Factory)?
18:13:17 <hpaste>  Jimmy Hollywood pasted "Jimmy Hollywood" at http://hpaste.org/1498
18:21:14 <araujo> hello!
18:25:03 <araujo> darcs.net down?
18:27:02 <TSC> I get connection refused
18:27:59 <araujo> argh, same here
18:29:12 <araujo> darcs add -r * , will add me only the new files or will also re-add existing files on the repo?
18:30:27 <TSC> Adding a file that's alread in the repo is a no-op, I think
18:30:39 <TSC> So it should add only the new ones
18:32:23 <SamB> TSC: it isn't a no-op -- it's not allowed
18:32:32 <SamB> so darcs add will complain
18:32:48 <TSC> But it won't do anything, and will still add the new ones
18:32:50 <SamB> well, maybe not with -r
18:32:56 <SamB> yes, it will add the new ones
18:39:26 <Saizan> "if I do that I risk castigation from Saizan" <-- i didn't think i could scare dpiponi :D
18:40:33 <Adamant> Saizan will give you hell
19:04:28 <kpreid> Are there any sensible types for which mempty (Monoid) and mzero (MonadPlus) are not the same value?
19:05:13 <Pseudonym> Well, you could have more than one monoid.
19:05:34 <Pseudonym> Any ring, for example.
19:06:22 <kpreid> Let's restrict it to types for which there's only one monoid (ignoring left/right reversals, etc)
19:37:20 <dons> http://programming.reddit.com/info/22r7t/comments
19:37:21 <lambdabot> Title: A type for partial values (reddit.com)
19:52:21 <dons> ?uptime
19:52:21 <lambdabot> uptime: 4d 1h 28m 14s, longest uptime: 1m 10d 23h 44m 29s
20:02:41 <dons> http://programming.reddit.com/info/22rbz/comments :)
20:02:43 <lambdabot> Title: Haskell and mathematics / the mathematics of Haskell (reddit.com)
20:17:22 <chessguy> @pl \x -> (\y -> y < x)
20:17:22 <lambdabot> flip (<)
20:30:26 <hpaste>  Kattz pasted "Kattz" at http://hpaste.org/1499
20:30:59 <chessguy> wow, still no luck banning that guy?
20:35:59 <dons> we've not tried yet. waiting for glguy to appear
20:36:17 <dons> is there any regularity to the posts -- is it a script?
20:36:36 <dons> i'm thinking it must be a simple script, running on a cron joob?
20:36:58 <dons> gone.
20:42:23 <Cale> dons: how about deleting anything which looks like HTML? :)
20:42:24 <Cale> hehe
20:43:01 <kfish> how about dropping pastes that contain <a href="...">, or where the nick doesn't match someone currently on irc (seen by lambdabot ...)
20:43:14 <Cale> that's actually reasonable
20:44:11 <Pseudonym> How about just ignoring reddit since it's a gross time sink with more noise than signal anyway.
20:44:17 * Pseudonym ducks
20:44:51 <dons> Pseudonym: not reddit, we're talking about hpaste.org spam
20:44:57 <Pseudonym> Ah, OK.
20:45:01 <Pseudonym> That makes sense.
20:45:12 <dons> i'd probably start by just blocking the spammers ip
20:45:15 <Pseudonym> Yes, hpastes should really only come from people on IRC.
20:45:25 <dons> then perhaps a captcha:   please infer the type for this expression: ...
20:45:27 <dons> :)
20:45:32 <Pseudonym> LOL!
20:45:42 <Pseudonym> Unfortunately, that's automatable.
20:45:58 <dons> pleaes infer the type for the expression in this image:
20:46:11 <Pseudonym> Please prove that this untyped lambda expression terminates: ...
20:46:24 <dons> heh
20:46:27 <dgriffi3> dons: what about blind folk
20:46:46 <TSC> Audio version
20:46:48 <SamB_XP> Pseudonym: that's a lot easier than proving nontermination...
20:46:49 <Pseudonym> Please infer the type for the expression read out in this audio clip:
20:47:18 <dons> since we've only had 1 spammer, and a couple of abuse cases, i'd think doing the simplest thing that could possibly work fits here.
20:47:28 <dons> blocking the ip. which needs shapr and glguy around.
20:47:34 <bos> http://www.realworldhaskell.org/blog/2007/07/02/a-brief-haskell-book-status-update/
20:47:37 <lambdabot> Title: Real World Haskell » Blog Archive » A brief Haskell book status update, http://tinyurl.com/24plrr
20:47:55 <dons> great work, bos.
20:48:03 <bos> thanks!
20:48:39 <dons> oh, heh, we do have a rather multiculltural docbook setup, don't we.
20:48:41 <Cale> Please come up with some code satisfying this type:
20:49:00 <chessguy> early!
20:49:03 <Pseudonym> Cale: Also automatable.
20:49:04 <chessguy> it's a beautiful word
20:49:05 <chessguy> bos++
20:49:11 <chessguy> cosmicray++
20:49:20 <Cale> and then have something horrible involving lots of fixed points
20:49:20 <Pseudonym> And besides, you can just use "undefined".
20:50:08 <dons> http://programming.reddit.com/info/22rl4/comments hehe
20:50:09 <lambdabot> Title: Real World Haskell book update: Deadlines smashed! Tools written! DocBook tolera ...
20:50:16 <Cale> Okay, a *defined* value.
20:50:27 <Cale> (that's harder to check though :)
20:52:13 <Pseudonym> fix id
20:52:14 <Pseudonym> That's defined.
20:53:17 <Cale> uh, no it's not.
20:54:12 <Cale> If you'd prefer, "defined and evaluates to a value within 1 second" :)
20:54:38 <Pseudonym> Great, so your captcha is vulnerable to a DoS attack.
20:55:04 <Cale> HPaste already is.
20:55:27 <Cale> Unless it's already doing something to limit requests.
20:56:16 <Cale> Of course, I'm not serious about this system anyway
20:56:29 <LoganCapaldo> Cale: you don't think spammers will learn to use djinn? :)
20:56:41 <Cale> LoganCapaldo: djinn can't always infer code.
20:57:00 <Cale> @djinn [a] -> Integer
20:57:01 <lambdabot> -- f cannot be realized.
20:57:37 <LoganCapaldo> Yeah but if you make it too hard the newbs would be able to do it :)
20:57:41 <LoganCapaldo> *won't
20:57:46 <LoganCapaldo> not would
20:58:06 <Cale> Heh, "I could care less".
20:58:24 <Cale> (I really could)
20:59:29 <LoganCapaldo> and I would be sad being unable to paste because I couldn't figure out (Monad m, Arrow a) => m (a b c) -> (b -> m c) -> m c or something :)
21:00:30 <Cale> hehe
21:01:00 <LoganCapaldo> Hmm maybe that's a good thing
21:01:30 <LoganCapaldo> if we make the captchas so hard that by the time you finally manage to paste, you're so good at haskell you don't need help anymore :)
21:01:58 <chessguy> brilliant!
21:02:37 <chessguy> @hoogle a -> [a]
21:02:38 <lambdabot> Prelude.repeat :: a -> [a]
21:02:38 <lambdabot> List.intersperse :: a -> [a] -> [a]
21:02:38 <lambdabot> Prelude.(:) :: a -> [a] -> [a]
21:02:55 <chessguy> > repeat 'a'
21:02:57 <lambdabot>  "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
21:03:04 <shachaf> LoganCapaldo: Can you write such a function?
21:03:30 <Cale> actually, the first thing to try would be adding fields to the form which, when filled in, cause it not to submit
21:03:58 <LoganCapaldo> shachaf: I dunno, I just made up the most bizzare looking thing I could think of
21:04:04 <LoganCapaldo> probably not
21:04:09 <Cale> (especially where such fields are hidden)
21:04:53 <LoganCapaldo> since you can't get a value :: b from anywhere
21:04:59 <dons> yes, captchas could be taken from popular haskell textbooks
21:05:03 <dons> and we remember each user
21:05:06 <Cale> another thing to do is to, when the form is constructed for the user, generate a puzzle for their browser to solve for them using javascript, and which should be able to be solved in a reasonable time frame.
21:05:09 <dons> the more you paste, the harder the problems you have to solve
21:05:41 <Cale> That is, not a user puzzle, but a puzzle for their client.
21:05:48 <chessguy> before long i wouldn't be able to paste anything :(
21:05:52 <SamB_XP> would it be fun to watch?
21:06:13 <sjanssen> Cale: requiring javascript is not so nice
21:06:29 <Cale> Like, computing a discrete logarithm modulo some reasonable number.
21:06:30 <mgsloan> someone should write some javascript that does a tiny bit of SETI computation
21:06:30 <chessguy> bah, most things require js these days
21:06:31 <LoganCapaldo> sjanssen: we could allow people to manually compute it :)
21:06:36 <mgsloan> then stick it on a really popular site
21:07:02 <dons> with titles like 'haskell can't solve this: ...'
21:07:45 <Cale> Yeah, like, <noscript>Compute the discrete logarithm of ... modulo ... <input ..></noscript>
21:08:41 <Cale> (to base ...)
21:10:59 <Cale> Or find a given salt for a string such that the first n bits of some hash are 0.
21:11:14 <Cale> er, find a salt for a given string
21:12:12 <LoganCapaldo> mmm salt
21:14:15 <Cale> Does hpaste have a banned IPs list?
21:14:56 <dons> i think its possible. but we need to talk to glguy
21:17:08 <hpaste>  fashmoney pasted "fashmoney" at http://hpaste.org/1500
21:17:53 <dons> that guy.
21:18:09 <dons> gone.
21:22:01 <araujo> o_0
21:26:22 <mgsloan> hmm, in the haskell docs, this isn't exactly conducive to the separation of Monad and State:
21:26:22 <mgsloan> sequence: Evaluate each action in the sequence from left to right,  and collect the results.
21:29:41 <LoganCapaldo> @src sequence
21:29:41 <lambdabot> sequence ms = foldr k (return []) ms
21:29:41 <lambdabot>     where
21:29:41 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
21:31:18 <mgsloan> > sequence [Nothing, Nothing, Just 2, Nothing]
21:31:20 <lambdabot>  Nothing
21:31:23 <mgsloan> doh!
21:31:23 <ccshan> Hello? Just a quick question: Whatever happened to the Memo module, especially in GHC?
21:31:40 <ccshan> > sequence [ Just 3, Just 2, Just 5 ]
21:31:43 <lambdabot>  Just [3,2,5]
21:32:10 <|Steve|> What does sequence do, exactly?
21:32:26 <Pseudonym> :t sequence
21:32:29 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
21:32:35 <dons> hey ccshan. did it end up in GHC/Weak.lhs? or am i thinking of something else.
21:32:39 <|Steve|> Oh.
21:32:56 <dons> |Steve|: it sequences the evaluation of some monadic actions.
21:33:09 <dons> you could think about it as taking a list of actions, and inserting ';' between them :)
21:33:17 <Pseudonym> > sequence [[1,2],[3,4]]
21:33:20 <lambdabot>  [[1,3],[1,4],[2,3],[2,4]]
21:33:22 <dons> turning it into a single action/code block
21:33:24 <Pseudonym> Useful.
21:33:27 <LoganCapaldo> foldr (;) tee hee
21:33:34 <dons> exactly
21:33:35 <Pseudonym> sequence == transpose
21:33:38 <ccshan> dons: looking... thanks...
21:33:40 <|Steve|> I see.
21:33:41 <dons> ?src seqeunce
21:33:41 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
21:33:47 <dons> ?src sequence
21:33:48 <lambdabot> sequence ms = foldr k (return []) ms
21:33:48 <lambdabot>     where
21:33:48 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
21:33:48 <mgsloan> :)
21:34:03 <|Steve|> Yeah, I saw that, but I didn't really follow it.
21:34:04 <dons> ?src sequence_
21:34:04 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
21:34:13 <BigGayBill> Hello everybody
21:34:15 <dons> since >> really is ;
21:34:19 <BigGayBill> hows everybody here?
21:34:24 <Pseudonym> Super, thanks for asking.
21:34:28 <Pseudonym> You?
21:34:34 <BigGayBill> I was told to come here because I had a question about an old pc
21:34:44 <BigGayBill> I have a Tandy 1000. I want to upgrade the HDD to a 30MB and upgrade the CPU to a 286.. how and where do I get this? I bought a 386 modual and tried to fit it in there but it has too many little needles. How can I weld or smaller pins on it to make it fit?
21:34:49 <LoganCapaldo> yeah. sequence is more like foldr (<-;) or something
21:34:51 <Pseudonym> Unless it's "does hugs run on it", you're in the wrong place.
21:34:54 <BigGayBill> Im doing this because I need to get win 3.11 running on it
21:34:57 <dons> aaaayes, wrong channel.
21:35:07 <Pseudonym> Who told you to come here?
21:35:09 <BigGayBill> well i was told to come here
21:35:12 <BigGayBill> the perl room
21:35:16 <mgsloan> lol
21:35:17 <ccshan> dons: Weak is "useful" for memo, but does not implement memo, thanks...
21:35:19 <Pseudonym> That'd be right.
21:35:36 <dons> ccshan: yes, I do seem to remember a Memo module, is that what you're referring to?
21:35:41 <BigGayBill> well are you people puter nerds? All im asking about is a Tandy 1000
21:35:42 <Pseudonym> Go ask in #lisp. :-)
21:35:46 <Pseudonym> Nah, not really.
21:35:49 <BigGayBill> lisp?
21:35:52 <dons> BigGayBill: yeah, best try #lisp
21:35:56 <Pseudonym> Perl and Haskell have this rivalry thing going on.
21:36:07 <BigGayBill> oh brb my gay skater boy getting rammed by two dongs is almost downloaded
21:36:15 --- mode: ChanServ set +o dons
21:36:18 --- mode: dons set +b *!*=BigGayBi@*.dsl.snantx.swbell.net
21:36:18 --- kick: BigGayBill was kicked by dons (dons)
21:36:20 --- mode: ChanServ set -o dons
21:36:24 <|Steve|> Heh.
21:36:41 <dons> been a while since we had a silly troll. i was wondering what had happened to them.
21:36:45 <LoganCapaldo> Personally, I would've done that a while a go
21:36:59 <mgsloan> aw, I thought he might have been telling the truth too
21:37:01 <dons> that's cuase you're a meanie, language
21:37:04 <dons> LoganCapaldo:
21:37:10 <LoganCapaldo> Clearly :)
21:37:28 <TheBonsai> hi. was BigGayBill here? i.e. is he running through all chans?
21:37:29 <LoganCapaldo> which is why you've got the ops and I don't :)
21:37:33 <mgsloan> would have been pretty funny - inter-programming language-channel shuntage
21:37:33 <dons> TheBonsai: yep.
21:37:43 <TheBonsai> ok. reporting now. what an idiot
21:37:58 <Pseudonym> Haven't seen him on #boost yet, but I guess it's only a matter of time.
21:38:04 <dons> TheBonsai: 14:34 -- mode/#haskell [+b *!*=BigGayBi@*.dsl.snantx.swbell.net] by dons
21:38:35 <sjanssen> which channels is he going through?
21:38:57 <TheBonsai> well, i met him in #bash
21:39:05 <TheBonsai> and i followed his /whois
21:39:08 <TheBonsai> #haskell
21:39:12 <TheBonsai> #kubuntu
21:39:13 <ccshan> dons: yes, the Memo module seems to have gotten less and less supported over time and finally disappeared
21:39:25 <shachaf> sjanssen: He was in #ruby-lang
21:39:27 <dons> ccshan: very strange. worth asking on -cafe@
21:39:47 <mgsloan> huh, hitting all the tech channels
21:40:08 <sjanssen> looks like he's going through the list by population
21:40:12 <mgsloan> disgruntled coder perhaps?
21:40:14 <mgsloan> or that
21:40:20 <ccshan> dons: thanks for the encouragement, i probably will. I'm writing now conversion routines between "Int -> a" and a big infinite binary tree of a's.
21:40:22 <Pseudonym> A drawback of being a popular channel.
21:40:51 <dons> ccshan: ooh, sounds tasty.
21:41:09 <dons> ah yes, that would be the top 20 channels right there.
21:41:19 <dons> perl, kubunut, ruby, haskell, bash.
21:41:28 <Pseudonym> Do you have a list by population?
21:41:31 <Heffalump> and infinite tree indexed by an Int?
21:41:34 <Heffalump> s/and/an/
21:41:40 <TheBonsai> tree?
21:41:41 <TheBonsai> :)
21:41:41 <Pseudonym> Might be worth warning the next few channels.
21:41:50 <LoganCapaldo> he was also in C++ fwiw
21:41:53 <dons> Pseudonym: yeah, http://searchirc.com/search.php?SCHANS=1&SSORT=SIZE&N=freenode
21:41:54 <lambdabot> Title: Search IRC, displaying all channels on freenode
21:42:14 <dons> bash, haskell, kubuntu .. in size order.
21:43:02 <TheBonsai> #apache :) ok bye ;)
21:43:55 <ccshan> Heffalump: well, data NatMap a = NatMap a (NatMap a) (NatMap a)
21:43:55 <ccshan> toNatMap f = NatMap (f 1) (toNatMap (f . double)) (toNatMap (f . succ . double))
21:43:55 <ccshan> double x = x + x
21:44:28 * Pseudonym joins #vim and gets popcorn
21:44:47 * ccshan wishes for not just n+k patterns but also a*n+k patterns
21:44:55 <Pseudonym> We used to have that.
21:45:00 <Pseudonym> Miranda did, anyway.
21:45:19 <ccshan> cool!  i assume you mean Miranda*
21:45:29 <Pseudonym> Yes, that's what I mean.
21:45:55 <Pseudonym> [*] Miranda is a registered trademark of The Evil David Turner Empire who gets upset with people who fail to mention this.
21:46:47 <dons> a*n+k are in gofer too, iirc
21:46:54 <dons> or n*k maybe
21:47:30 <LoganCapaldo> @quote miranda
21:47:31 <lambdabot> JohnPeterson says: [1991] `Miranda' is a trademark of Research Software Ltd. `Haskell' is not a trademark of anyone.
21:47:40 <dons> woot :)
21:47:56 <dons> that's your free software, right there.
21:48:23 <ccshan> wow. i'll just wish for (horner k coeffs)-patterns now. (Here k is a literal. For now.)
21:48:26 <Pseudonym> I don't mind trademarked names.
21:48:28 <Pseudonym> To be honest.
21:48:34 <Pseudonym> But trademarked language names is a bit off.
21:48:42 <Pseudonym> And more to the point, trademarked LANGUAGES is evil.
21:50:42 <Cale> I want rational-combinations-of-trig-functions-patterns
21:52:20 <LoganCapaldo> Cale: I hope you're joking. Either that or I hope I don't understand what you just said
21:52:26 <Cale> I am joking
21:53:06 <Cale> I mean like  f ((cos x + 2 * sin y) / (tan z)) = x + y + z
21:53:19 <Pseudonym> You could do it with views.
21:53:43 <Pseudonym> But it'd look like this:
21:53:48 <mgsloan> what's the best way to take a [Maybe a] and return the first Just?
21:54:06 <Cale> @type catMaybes
21:54:06 <Pseudonym> f e = case trigView e of { Cos x :+ I 2 :* Sin y ... }
21:54:07 <Heffalump> head [x | Just x <- xs]
21:54:08 <lambdabot> forall a. [Maybe a] -> [a]
21:54:13 <mgsloan> Cale - ah, thanks!
21:54:30 <Pseudonym> This is what you need "choose" for. :-)
21:54:32 <Cale> @type fromJust . find isJust
21:54:35 <lambdabot> forall a. [Maybe a] -> Maybe a
21:54:48 <Cale> er...
21:54:56 <Cale> oh, right :)
21:55:01 <Cale> heh
21:55:02 <LoganCapaldo> Cale: heh
21:55:49 <Pseudonym> > foldr mplus mzero [Nothing,Nothing,Just 2,Just 3]
21:55:49 <Cale> So really, you want join . find isJust
21:55:52 <lambdabot>  Just 2
21:56:07 <Cale> > msum [Nothing,Nothing,Just 2,Just 3]
21:56:07 <mgsloan> > (fromJust . find isJust) [Nothing, Nothing]
21:56:09 <lambdabot>  Just 2
21:56:10 <lambdabot>  Exception: Maybe.fromJust: Nothing
21:56:20 <Cale> msum is pretty good :)
21:56:24 <mgsloan> ooh!
21:56:25 <Pseudonym> msum is good, too.
21:56:34 <mgsloan> > msum [Nothing,Nothing]
21:56:36 <Pseudonym> @let choose [] = mzero
21:56:36 <lambdabot>  Nothing
21:56:38 <mgsloan> cool
21:56:39 <lambdabot> Defined.
21:56:46 <Pseudonym> @let choose (x:xs) = return x `mplus` choose xs
21:56:46 <lambdabot> <local>:18:33:     Ambiguous occurrence `choose'     It could refer to either...
21:56:56 <Pseudonym> Damn.
21:57:19 <Cale> @undef choose
21:57:20 <lambdabot> Undefined.
21:57:24 <Pseudonym> @let choose xs' = case xs' of { [] -> mzero; (x:xs) -> return x `mplus` choose xs }
21:57:25 <lambdabot> <local>:1:67:     Ambiguous occurrence `choose'     It could refer to either ...
21:57:35 <shachaf> Cale: @undef doesn't work that way.
21:57:36 <Pseudonym> Hrm.
21:57:44 <Cale> shachaf: oh?
21:57:48 <ccshan> Dylan and I are doing the "Word Numbers" puzzle at http://itasoftware.com/careers/puzzles07.html -- it's a good one for PL people. (Try the unsorted version first.)
21:57:49 <lambdabot> Title: ITA Software - Puzzle Archive
21:57:49 <shachaf> It's confusing with QuickCheck's choose.
21:58:02 <shachaf> Cale: It clears the entire file, not just one function.
21:58:04 <Cale> shachaf: ah, I only intended to clear the bad definition
21:58:16 <Cale> oh, I didn't know that.
21:58:41 <Cale> @let option = msum . map return
21:58:42 <lambdabot> <local>:1:9:     Ambiguous type variable `m' in the constraint:       `MonadP...
21:58:53 <shachaf> Pseudonym: By the way, you can use ; in @let.
21:58:55 <Cale> @let option :: (MonadPlus m) => [a] -> m a; option = msum . map return
21:58:56 <lambdabot> Defined.
21:59:04 <Pseudonym> Ah, useful.
21:59:24 <Pseudonym> > L.option [Nothing,Just 2,Just 3]
21:59:25 <lambdabot>   add an instance declaration for (Show (m (Maybe a)))
21:59:38 <Pseudonym> > L.option [Nothing,Just 2,Just 3] :: [Maybe Int]
21:59:40 <lambdabot>  [Nothing,Just 2,Just 3]
21:59:47 <Cale> It does nothing on the list monad.
21:59:51 <Pseudonym> Yes.
22:00:11 <Pseudonym> Just checking. :-)
22:10:21 <dons> oh, this is super useful, http://www.revfad.com/flip.html
22:10:22 <lambdabot> Title: Flip
22:10:45 <sorear> hello
22:10:51 <dons> uynÂÃy dPo . onso = uo1Âdo ;P o >- [P] >= (o sn1dpPuoo) -- probably doesn't render?
22:11:15 <shachaf> dons: It doesn't handle "l"s... :-(
22:11:32 * sorear xrandr -x -y
22:12:32 <mgsloan> whoah
22:13:01 <dons> ah, quite so. 11ÝsPe
22:13:01 <shachaf> sorear: That's never worked for me.
22:13:32 <shachaf> sorear: I can't do anything more than chane the resolution.
22:14:18 <sorear> shachaf: sure.
22:14:30 <sorear> shachaf: it's quite hw-dependant
22:14:52 <shachaf> sorear: Yes, and I've always had bad luck with video card support.
22:14:58 <sorear> Me too.
22:15:28 <mgsloan> dons, or I mean, suop - that's pretty cool
22:15:46 <dons> yeah, the only thing my laptop can do is xrandr -s
22:15:53 <dons> which works nicely in xmonad, i must say :)
22:16:31 <dons> 640x350 is a bit gross
22:17:48 <shachaf> dons: Are you regretting those huge fonts now? :-)
22:17:50 <mgsloan> isn't really a very good flip function - a proper one would actually be its own inverse
22:18:03 <dons> shachaf: heh
22:18:18 <mgsloan> ÊÉ¥ÉÊ's pÉ¹ÇÊÊÊ Éoo1
22:21:15 * shachaf will settle for â®right-to-left override.
22:21:29 <shachaf> Not that that works on my IRC client.
22:23:53 <shachaf> Does that reverse the text for anyone?
22:24:20 <ccshan> Yes, was that IPA fonts or something? Nice.
22:25:03 <shachaf> ccshan: No, it's the right-to-left override character.
22:25:31 <shachaf> ccshan: Unicode 202E. Those letters aren't reversed, just the words.
22:28:15 <ccshan> shachaf: sorry, i'm confusing mgsloan's text with yours. i see yours is using bidi, but mgsloan's uses IPA characters it seems.
22:28:37 <mgsloan> â®Hmm, kinda fun to type using gaim though
22:29:17 <ccshan> i need to go to bed though, sorry. the infinite binary tree works, but the puzzle solution doesn't.
22:29:19 <shachaf> ccshan: mgsloan used http://www.revfad.com/flip.html
22:29:19 <lambdabot> Title: Flip
22:30:22 <ccshan> I see we're heading towards "ascii" art using Alt-219 and friends
22:30:41 <mgsloan> ooh, unicode art
22:30:56 <shachaf> ccshan: Alt-219?
22:30:58 <sorear> @remember ccshan I see we're heading towards "ascii" art using Alt-219 and friends
22:30:58 <lambdabot> Done.
22:31:02 <sorear> @flush
22:34:08 <mgsloan> heh - http://www.unicodeart.com/gallery/
22:34:09 <lambdabot> Title: &#1160; Unicode art - an extended ASCII art form &#1160;
22:34:52 <mgsloan> would be fun to do a good img -> unicode
22:36:21 <ccshan> The old IBM PC character set contains things like a filled-in block at number 219 (decimal)
22:36:43 <mgsloan> yep
22:36:46 <mgsloan> used for DOS apps
22:37:02 <shachaf> ccshan: Is that what was used for Nethack corridors?
22:37:14 <Pseudonym> I seem to remember a lot of zips with that in it.
22:37:18 <ccshan> I don't think Nethack was tailored for DOS was it?
22:37:35 <shachaf> ccshan: Nethack has an "IBMGraphics" option.
22:38:06 <ccshan> I see. All this is alive and well, along with telnet BBS's, in Big5 and GB encodings.
22:38:17 <mgsloan> at one point I actually used a version of VB with graphics using that charset :)
22:38:19 <shachaf> No, Alt-219 is completely filled in, I was thinking of something else (just checked in dosbox).
22:38:55 <ccshan> Cheers!
22:38:56 <mgsloan> probably thinking of the double line thngs
22:39:08 <ccshan> (still in unicode)
22:39:10 <mgsloan> its got double line horiz/vert, all kinds of corners, and things
23:09:33 <hpaste>  ee82hl pasted "ee82hl" at http://hpaste.org/1501
23:10:20 <Olathe> Wow. Pastebin spam.
23:10:48 <sorear> Olathe: Yup.  And deleted within 30s
23:11:13 <Olathe> The spam has in fact been eaten.
23:11:50 <sorear> I can do it quickly because I've noticed a pattern exclusive to spams so simple it can be coded as a irssi /hilight -regext
23:11:53 <sorear> *regexp
23:12:54 <dons> yes, so someone sat down and wrote a really simple script :(
23:12:59 <dons> where's glguy. i want that ip blocked
23:13:11 <dons> ah ha!
23:13:14 * dons points and waves
23:13:25 <glguy> has he been doing that a lot?
23:13:29 <glguy> more than once?
23:13:35 <dons> yes, about one an hour for 2 days
23:13:43 <glguy> ugh
23:13:46 <dons> i've removed about 5.
23:13:48 <mjk> why is not correct like the following cods
23:13:50 <dons> all the same format.
23:13:53 <glguy> what's he spamming?
23:13:59 <sorear> trash
23:14:04 <dons> html links
23:14:08 <mjk> class Foo a where
23:14:19 <mjk> name :: a -> String
23:14:27 <mjk> instance Foo Int where
23:14:37 <mjk> name a = "MyInt"
23:14:44 <mjk> can anyone help me?
23:15:02 <Cale> mjk: other than indentation, that's fine.
23:15:02 <dons> that looks fine.
23:15:07 <dons> other than indentation, yes.
23:15:09 <glguy> The alternative would be to not display links :)
23:15:21 <mgsloan> you might not need the a ->, if you're always naming types
23:15:27 <dons> this guy seems simple enough that we might just be able to stop his IP, glguy ?
23:15:35 <Cale> glguy: For now, I think just add a banlist.
23:15:50 <mjk> but exec name 12 will report error msg
23:15:51 <sorear> dons: but what ip is he coming from?
23:16:01 <dons> we need to ask someone with access to the server
23:16:11 <Cale> mjk: which error message?
23:16:15 <LoganCapaldo> mjk: you may want exec (name 12)
23:16:15 <shachaf> mjk: Does "name (12::Int)" work?
23:16:19 <Cale> mjk: are you sure that 12 is an Int?
23:16:25 <sorear> you can't find out, because making hpaste record it would incompatibly change the state format :(
23:16:26 <mgsloan> it's probably going to Integer or Num
23:16:30 <Cale> (answer: no)
23:16:42 <mjk> Cale: ERROR - Unresolved overloading
23:16:46 <Cale> mjk: right
23:16:48 <mjk> in WinHugs
23:16:49 <glguy> his IP address is logged
23:16:56 <glguy> I just have to read through the log :(
23:16:58 <glguy> which is verbose
23:17:15 <mjk> LoganCapaldo: yes
23:17:16 <Cale> mjk: So what you need to do is to make it clear that what's being passed is intended as an Int, and not, for example, an Integer, or Float, or Double, etc.
23:17:40 <Cale> One way to do this is to use   name (12 :: Int), as shachaf pointed out
23:17:40 <mjk> shachaf:  name (12::Int) is ok
23:17:59 <Cale> another is just to actually use name in a program where the types are already determined
23:18:28 <mjk> why "name 12")can't exec
23:18:33 * sorear wishes someone (a smart person, ie not him) would figure out a way to make robustly stateful haskell programs
23:18:48 <glguy> ("x-forwarded-for","
23:18:48 <glguy> 24.61.209.38")
23:18:50 <Cale> sorear: Hasn't that been done a whole lot?
23:18:53 <dons> yes, its been giong for around 3 days, now glguy
23:18:56 <dons> good work.
23:19:17 <sorear> Cale: No, everyone seems to have failed.
23:19:46 <Cale> In what way?
23:19:53 <dons> i wouldn't say failed, sorear . we know what to do.
23:19:55 <Cale> and what counts as robust?
23:20:09 <glguy> comcast subscriber in Mass.
23:20:16 <sorear> the programs are impossible to extend reasonably, and sometimes are just forgetful
23:20:33 <dons> versioning is hard, is perhaps a clearer statement.
23:20:45 <mgsloan> hehe, that one haskell tcl interpreter thing should be called gtk: glorious TCL kompiler
23:20:47 <Lamperi> Terve
23:20:48 <dons> but we know how to solve that as well.
23:21:41 <mjk> instance Foo String where
23:21:43 <mjk> name a = "String"
23:21:45 <sorear> they should write it down.  I sure have no clue
23:21:51 <mjk> why is not correct?
23:22:41 <Cale> sorear: Well, the solution would be to define ways to read the old version's configuration data and extend/convert it whenever it's different in a new version.
23:22:50 <Cale> sorear: This isn't a Haskell-specific problem of course.
23:23:00 <dons> yeah, its a solved problem in a wide range of systems
23:23:14 <dons> so, the issue is, writing a nice simple library that does all the dirt for you
23:23:18 <dons> so people don't have to think
23:23:26 <dons> mmm. doesn't mnesia do something like this?
23:23:40 <dons> and yeah, you'll end up with a database-like thing
23:23:46 <Cale> Well, if you change the representation of your state, it's not always trivial.
23:24:04 <dons> right, most systems use composed conversion functoins, iirc
23:24:12 <Cale> Database programs generally break when you change the table format.
23:24:13 <dons> lambdabot does this, in an ad hoc way, for example
23:24:36 <dons> a lovely richly typed versioning system would be icfp worthy, though.
23:24:52 <glguy> dons: his ip address isn't consistent
23:24:59 <dons> oh :/
23:25:01 <sorear> yeah, and dons is the only person who can change lambdabot in format-affecting ways because he's the only one who can convert the state
23:25:16 <sorear> which causes unneeded stagnation
23:25:22 <sorear> ditto for treble/hpaste
23:25:23 <dons> sure.
23:25:35 <Cale> ditto for every live program out there
23:25:42 <glguy> treble is my undercover #ruby-lang name ;)
23:25:44 <Cale> (only not always dons)
23:26:01 <dons> glguy: hah
23:26:14 <dons> Cale: right. ;)
23:26:32 <dons> sorear: get famous, reimplement this, http://citeseer.ist.psu.edu/mattsson99mnesia.html
23:26:33 <lambdabot> Title: Mnesia - A Distributed Robust DBMS for Telecommunications Applications - Mattsso ...
23:26:50 <glguy> check this out, someone asked how to do the Ruby equivalents of : drop 3 :: String -> String
23:27:06 <dons> oh no...
23:27:10 <mgsloan> haha!
23:27:16 <glguy> the answer they settled on was: your_string.gsub('/.{n}//')
23:27:24 <glguy> where n = 3
23:27:30 <dons> urgh
23:27:32 <glguy> I reminded them that your_string[3..-1] worked just fine
23:27:41 <glguy> but it was just embarrassing
23:27:44 <dons> hah
23:27:47 <glguy> the accepted solution was to use a regex
23:28:04 <dons> yeah, that'd be the obvious perl soln too. why aren't substrings first class? strange.
23:28:08 <c> ruby is perl w/ a better object system :)
23:28:10 <sorear> regexes are a panacea!!!
23:28:16 <Japsu> @quote ruby
23:28:16 <lambdabot> emertens says: screw ruby on rails, I'm using snakes on a plane
23:28:22 <glguy> ha, thats me too
23:28:23 <Japsu> no, not that
23:28:27 <Japsu> @quote out-perl
23:28:27 <lambdabot> No quotes match. Maybe if you used more than just two fingers...
23:28:27 <dons> sorear: see also http://citeseer.ist.psu.edu/nilsson96mnesia.html
23:28:28 <lambdabot> Title: Mnesia - An Industrial DBMS with Transactions, Distribution and a Logical Query  ...
23:28:30 <Japsu> :<
23:28:48 <sieni> Japsu: is that a duck emoticon?
23:28:49 <dons> glguy: galois will need an mnesia one day. we shoudl write one :-)
23:28:50 <glguy> Ruby is a cluster-fuck, but I like to know my enemy, so I lurk there some times
23:28:56 <araujo> mm..
23:29:21 <glguy> dons: John was actually pretty excited about Erlang at one point (I'm told)
23:29:26 <araujo> dons, they claim it's because of efficiency
23:29:39 <dons> araujo: what is?
23:29:55 <dons> glguy: oh, interesting. pity about the lack of types. that's a bit of a killer for verification.
23:29:55 <araujo> dons, substrings not being first class
23:30:11 <dons> but a native 'drop' is always going to be faster than the regex versoin
23:30:24 <araujo> they don't listen
23:30:24 <glguy> dons: but, not everything needs to be verified, some things just depend on verified components
23:30:26 <araujo> :-P
23:30:33 <glguy> dons: they don't need to themselves be verified
23:30:54 <dons> true. but there's nothing inherent in mnesia that it couldn't be ported, afaik.
23:30:57 <dons> make a good wiki backend.
23:31:30 <glguy> who knows, maybe we could get funding for such a project
23:31:32 <glguy> :)
23:31:48 <dons> compiled, type checked == fast. STM for locks.
23:31:56 <dons> oh hmm, Pseudonym, you're familiar with this domain.
23:34:32 <Pseudonym> Err... kinda.
23:35:42 <Pseudonym> I don't know if Mnesia supports it or not, but the trickiest bit would be recovery (disk transactions etc).  It always is. :-)
23:35:59 <dons> what about type versioning?
23:36:14 <Pseudonym> You want hot code swapping?
23:37:06 <dons> well, someway to ensure data survives state format changes
23:37:17 <dons> not nec. for hot swapping, but, say, hot restarts
23:37:38 <Pseudonym> Well, it's not hard to make the on-disk representation change-proof.
23:37:43 <Pseudonym> Or at least change-resistant.
23:39:17 <dons> so my suspicion is that an easy, reusable, happs-ish state/db for haskell is a missing piece of functionality
23:39:19 <mgsloan> just make everything in your state, Maybe
23:39:32 <mgsloan> ;)
23:39:37 <Pseudonym> Why?
23:39:52 <dons> we seem to be rewriting such things poorly for each new bigish app
23:39:59 <Pseudonym> Perl doesn't really have it.  I mean, it has a CSV-based relational database, but we know it's crap.
23:40:11 <dons> so there's Read/Show for basic stuff
23:40:16 <mgsloan> to deal with reading old records that don't have a particular member
23:40:17 <dons> and happs has some checkpointing that's fairly good.
23:40:41 <dons> but we'd want a nice drop in library,with a simple interface, maybe using Data.Binary for the hard work
23:40:45 <mgsloan> might want to have some sort of binary serialization lib
23:40:52 <mgsloan> oh, right.
23:40:58 <dons> Data.Binary.encode > robust database
23:41:01 <dons> and back.
23:42:42 <dons> glguy: so what's the plan for the spammer?
23:43:06 <dons> do we just block title==name submissions? (would they bother working around that?)
23:43:21 <dons> add a simple captcha? block the IP range?
23:43:25 <glguy> they bothered to do what they ar edoing now
23:43:37 <glguy> I could block comcast users from massachussets..
23:43:43 <glguy> but that's kind of a big block
23:43:51 <dons> hmm
23:44:26 <glguy> I could block submissions with hyperlinks
23:44:37 * mgsloan imagines some pissed off MIT student occasionally spamming hpaste in between haskell homework assignments ;)
23:45:56 <dons> i think it started with 07.06.27:20:35:14 <hpaste>  Idiots pasted "Idiots" at http://hpaste.org/428
23:46:36 <ttmrichter> What kinds of spamming is going on?  Just community-insulting?
23:46:40 <ttmrichter> Or is it advertising?
23:46:43 <sorear> advert
23:46:58 <sorear> glguy: can we just ignore name = title submissions?
23:47:12 <glguy> sure
23:47:16 <sorear> glguy: they obviously don't know about hpaste, since they wouldn't do that if they did...
23:47:27 <dons> here's the paste log, btw, http://www.cse.unsw.edu.au/~dons/tmp/hpaste.log
23:47:31 <glguy> the IRCops can't tell me if its an IRC user
23:47:35 <dons> scroll down to the last 20 or so items
23:47:48 <dons> starting at Idiots pasted "Idiots"
23:47:50 <glguy> that would violate the spammers anonymimity
23:48:25 <dons> btw, do we have the state for the 72 day period between state restorations?
23:48:35 <dons> it might be fun to try to merge that back into the system sometime
23:48:45 <glguy> I don't know...
23:48:52 <glguy> I still don't know why it was reset
23:49:05 <dons> so it was restet, then restored 72 days later.
23:49:09 <dons> by shapr or someone?
23:49:16 <glguy> yeah
23:49:30 <sorear> glguy: Lemmih says you lost the space because of rm -rf * .o
23:49:36 <sorear> s/space/state/
23:49:50 <dons> lost which state, the missing stuff?
23:49:54 <glguy> I did that or someone did that on accident?
23:49:54 <sorear> yeah
23:50:17 <sorear> glguy: someone
23:50:21 <dons> so we had originally about 1400 posts, then we lost those, then we had about 400 posts inthe last 72 days, now we've lost those, and the original 1500 is restored
23:50:25 <dons> how did that happen?
23:50:34 <sorear> 2007.07.01.15.00.38 < Lemmih> HPaste lost its state due to a 'rm -fr * .o'-style mistake.
23:51:06 <dons> right, but its been restored somehow
23:51:18 <dons> unless i misread 07.01.15
23:51:23 <dons> is that 1st July?
23:51:51 <dons> and that means, we lost the last 400, due to rm -rf . but don't know how the original 1400 were restored (formerly lost?)
23:52:59 <dons> is Lemmih the maintainer now?
23:54:35 <glguy> making changes to hpaste isn't easy, happs has been a moving target and the version of happs on kakapo isn't compatible with the code
23:54:41 <dons> we should move the hpaste repo onto code.haskell.org, too.
23:55:14 <dons> glguy: ah, so they're running an older, or modified happs, wrt. the main repo?
23:55:23 <glguy> older
23:56:06 <glguy> OH, the main site is newer than the hpaste codebase
23:56:08 <glguy> is what I meant
23:56:23 <glguy> main site == kakapo
23:56:36 <sorear> glguy: Obviously we need to move hpaste to community.haskell.org and run it off a user install of happs, so that you can foograde whenever you want.
23:56:47 <glguy> what is code.h.o and community.h.o?
23:56:57 <sorear> glguy: Ping SyntaxNinja (ijones@galois.com iirc)
23:57:10 <glguy> I'll pester him, he's my project lead
23:57:20 <sorear> glguy: community hosting, for live projects like hpaste, hackage, and lambdabot
23:57:27 <sorear> (only one of which is currently there)
23:57:41 <dons> same machine. though not sure if its for running servers
23:57:47 <sorear> "project lead"?
23:57:48 <glguy> I'll ask him at work tomorrow, I don't think he's been on IRC lately
23:57:49 <dons> certainly for hosting projects
23:58:28 <glguy> is it hosted by galois?
23:58:49 <sorear> glguy: on the subject of things to pester ijones about, Binkley's GECOS field still lists "Kirsten Chevalier"
23:59:55 <sorear> @users
23:59:55 <lambdabot> Maximum users seen in #haskell: 354, currently: 294 (83.1%), active: 7 (2.4%)
