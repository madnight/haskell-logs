00:00:17 <RyanT5000> basically, i have a typical OOP hierarchy for usage
00:00:42 <RyanT5000> in most OOP languages you need to know the exact type in any function that instantiates an object
00:00:44 <RyanT5000> which is annoying
00:01:39 <RyanT5000> so i was wondering if a constructor hierarchy could be made - possibly it'd be an inversion of the usage hierarchy, or something like that
00:02:08 <RyanT5000> i was citing IArray as an example of lumping the two things together
00:02:20 <RyanT5000> and it seems to cause problems
00:05:20 <vincenz> carmen: ping
00:05:22 <vincenz> Cale: ping
00:05:24 <vincenz> carmen: sorry
00:05:29 <carmen> pong
00:05:37 <vincenz> carmen: wrong tab-complete
00:10:43 <B4K4p4nTsU> http://liarpedia.org/lol.jpg
00:14:35 <Japsu> (mildly nsfw)
00:18:16 <sjanssen> B4K4p4nTsU: are you a bot?
00:18:29 <B4K4p4nTsU> no
00:18:33 <B4K4p4nTsU> are you?
00:19:30 <quicksilver> yes, he's a bot isn't he?
00:19:59 <vincenz> quicksilver: yes
00:20:03 <quicksilver> with a few simple scripted responses
00:20:08 <quicksilver> someone kick him?
00:20:12 --- mode: ChanServ set +o vincenz
00:20:15 --- kick: B4K4p4nTsU was kicked by vincenz (vincenz)
00:20:16 --- mode: vincenz set -o vincenz
00:20:17 <vincenz> done
00:20:26 <quicksilver> thanks :)
00:21:07 <B4K4p4nTsU> what the hell. i'm not a bot...
00:22:39 <vincenz> alright then, but perhaps warn when posting explicit messages like that, and I'm not sure they fit in this channel
00:22:49 <B4K4p4nTsU> :/
00:22:56 <vincenz> people might be at work.
00:23:14 <quicksilver> and the way you spoke to wli was inappropriate too
00:23:18 <quicksilver> although I don't imagine it bothered him
00:23:36 <quicksilver> this is not your average IRC channel, people are nice here...
00:23:44 <B4K4p4nTsU> and that would make me a bot?!
00:24:10 <quicksilver> there are a number of bots around at the moment with simple scripted responses
00:24:16 <quicksilver> you did an excellent impression of one
00:24:16 <B4K4p4nTsU> and i just said what everyone thought
00:24:26 <vincenz> lets drop it
00:24:39 <B4K4p4nTsU> yeah, i'm going to bed. good night
00:27:30 <dons> hmm.
00:27:59 <dons> vincenz: do I need to do anything?
00:28:10 <vincenz> dons: I'm having lambdabot issues
00:28:18 <vincenz> dons: whenever I try > 1 in the channel
00:28:23 <dons> > 1
00:28:24 <lambdabot>  1
00:28:25 <vincenz> I get an error on LBS.last
00:28:29 <vincenz> I mean on our compile of lambdabot
00:28:33 <dons> oh, yes, you need to update the regex lib
00:28:39 <dons> there was a bug in regex-base 0.9 iirc
00:28:40 <vincenz> ah thanks
00:28:45 <vincenz> that and
00:28:45 <dons> anyway, whatever the latest regex lib on hackage is
00:28:48 <vincenz> Lib/Parser.hs
00:28:53 <vincenz> complains about pling_name and a few otehrs
00:28:54 <dons> oh yes, 6.6.1?
00:28:57 <vincenz> due to wrong cpphs
00:28:58 <vincenz> nod
00:29:06 <dons> yeah, it uses some internals. hmm, haven't looked at that yet
00:29:22 <opqdonut> is there something like an uncurry3?
00:29:30 <vincenz> dons: alright, thanks
00:29:33 <vincenz> I'll try regex
00:29:36 <dons> Cale: interesting newbie error, guy wrote x = do filter odd [1..10] ; map (+1) [1..10] 
00:29:39 <dons> in ghci
00:29:40 <opqdonut> ?pl (\f (x,y,z) -> f x y z )
00:29:41 <lambdabot> (line 1, column 9):
00:29:41 <lambdabot> unexpected ","
00:29:41 <lambdabot> expecting letter or digit, operator or ")"
00:29:41 <lambdabot> ambiguous use of a non associative operator
00:29:42 <dons> :)
00:30:07 <opqdonut> :S
00:30:44 <opqdonut> dons: heh, list monad
00:31:03 <Syzygy-> What did the newbie expect to happen?
00:31:42 <dons> oh, print each list as it went
00:31:56 <Syzygy-> Ah.
00:31:58 <dons> so how do you explain that ... 
00:32:02 <dons> oh, that's the list monad
00:32:05 <dons> the what what?
00:32:07 <dons> monad.
00:32:08 <dons> list.
00:32:09 <dons> oh.
00:32:22 <dons> > do filter odd [1..10] ; map (+1) [1..10] :: [Int]
00:32:24 <lambdabot>  [2,3,4,5,6,7,8,9,10,11,2,3,4,5,6,7,8,9,10,11,2,3,4,5,6,7,8,9,10,11,2,3,4,5,6...
00:32:36 <dons> not [2,4,6,8] :)
00:32:59 <Syzygy-> You could explain it as > concat [map (+1) [1..10] | x <- odd [1..10]]
00:33:03 <mm_freak> oh
00:33:19 <mm_freak> > do putStr "abc" ; putStrLn "def"
00:33:21 <lambdabot>  <IO ()>
00:33:23 <dons> yeah, that's what I did, I showed the desugaring, then the definition of >>=
00:33:30 <dons> and he knows concat/map/filter, so it becomes clear
00:33:32 <mm_freak> > do putStr "abc"; putStrLn "def"
00:33:33 <lambdabot>  <IO ()>
00:33:40 <Syzygy-> mm_freak: Lambda doesn't like IO.
00:33:43 <dons> ?src Monad []
00:33:43 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
00:33:49 <dons> ?src [] (>>=)
00:33:50 <lambdabot> m >>= k     = foldr ((++) . k) [] m
00:33:50 <mm_freak> hmm…  once i tried this, and it yielded a syntax error
00:34:07 <opqdonut> ?pl (\(x,y,z) -> f x y z )
00:34:07 <lambdabot> (line 1, column 7):
00:34:07 <lambdabot> unexpected ","
00:34:07 <lambdabot> expecting letter or digit, operator or ")"
00:34:07 <lambdabot> ambiguous use of a non associative operator
00:34:08 <mm_freak> probably because ; in conjunction with another operator made up a new operator
00:34:13 <Syzygy-> > do x <- filter odd [1..10]; return x+1
00:34:14 <lambdabot>   add an instance declaration for (Num [a])
00:34:14 <lambdabot>     In the expression: (return x)...
00:34:26 <Syzygy-> > do x <- filter odd [1..10]; return x+1 :: [Int]
00:34:26 <lambdabot>   add an instance declaration for (Num [Int])
00:34:26 <opqdonut> ?pl (\(x, y, z) -> f x y z )
00:34:27 <lambdabot>     In the expression: (return ...
00:34:27 <lambdabot> (line 1, column 8):
00:34:27 <mm_freak> syzygy-: i know, just wanted to see if i get a syntax error
00:34:27 <lambdabot> unexpected ","
00:34:27 <lambdabot> expecting letter or digit, operator or ")"
00:34:28 <lambdabot> ambiguous use of a non associative operator
00:34:36 <opqdonut> gah, doesn't pl like tuples?
00:34:37 <Syzygy-> > do x <- filter odd [1..10]; return $x+1 :: [Int]
00:34:38 <lambdabot>  [2,4,6,8,10]
00:34:48 <Syzygy-> Ther we go.
00:34:52 <dons> list monad is fun.
00:35:01 <dons> but that's interesting how easy it was for a beginner to fall into that
00:35:03 <opqdonut> $x ?
00:35:09 <dons> (x+1)
00:35:17 <dons> > do x <- filter odd [1..10]; return (x+1)
00:35:19 <lambdabot>  [2,4,6,8,10]
00:35:23 <opqdonut> ahhh
00:35:26 <TSC> I read it as $x at first too (:
00:35:28 <opqdonut> $ x+1
00:35:43 <opqdonut> but yeah, is there an uncurry3 function?
00:35:51 <TSC> :t uncurry3
00:35:53 <lambdabot> Not in scope: `uncurry3'
00:36:11 <mm_freak> dons: the first time i saw an implementation of `zip' using monadic notation, i was pretty confused
00:36:17 <opqdonut> yeah i know it's not called that :)
00:36:57 <mm_freak> > let myZip xs ys = do x <- xs ; y <- ys ; return (x,y) in myZip [1,2,3] [4,5,6]
00:36:58 <lambdabot>  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
00:37:05 <mm_freak> uhm, not zip
00:37:12 <mm_freak> comprehension
00:43:55 <opqdonut> is there an intersect operation for sorted lists?
00:45:02 <Saizan> mm_freak: liftM2 (,)
00:52:43 <RyanT5000> let's say you have several functions, a -> b -> c, a -> b -> d, a -> b -> e
00:52:53 <RyanT5000> all of them are in a class
00:53:34 <RyanT5000> given no information about those things, is it best to throw them into a single function a -> b -> (c, d, e), and then unpack them in default functions?
00:54:18 <RyanT5000> e.g.: let's say you're implementing a type similar to Map
00:54:23 <RyanT5000> or even []
00:54:32 <opqdonut> depends on how much duplicated work there is
00:54:49 <RyanT5000> opqdonut: right - but what if you don't know that ahead of time?
00:55:00 <RyanT5000> is it ever significantly *worse* to put them together?
00:55:22 <opqdonut> hmm, i guess not b/c of laziness actually
00:55:26 <RyanT5000> right
00:55:29 <RyanT5000> that's what i was thinking
00:55:50 <RyanT5000> but then there's a problem
00:56:03 <RyanT5000> what if you have an algorithm for computing c and d together
00:56:12 <RyanT5000> and an algorithm for computing d and e together
00:56:26 <RyanT5000> and an algorithm for computing them each separately
00:56:47 <RyanT5000> now you can't expose all of them at once
00:57:00 <opqdonut> it depends too much on the semantics and use cases
00:57:02 <RyanT5000> (at once = in a single instance)
00:57:52 <RyanT5000> the main thing is that i was wondering if the class/instance syntax should be extended to support this kind of thing
00:57:59 <RyanT5000> or, something
00:58:00 <RyanT5000> i'm not even sure
00:58:49 <RyanT5000> but basically you ought to be allowed to specify every subset of the set of same-input functions as a group
00:59:42 <RyanT5000> since any subset could have a faster implementation than computing them all separately, or than computing them all as a group
00:59:59 <RyanT5000> (i think that last bit is true, anyway)
01:01:38 <quicksilver> RyanT5000: I don't think that situation is common enough to deserve language support
01:02:00 <quicksilver> RyanT5000: when it occurs you can just write a function which takes as a parameter the 'set of things to calculate'
01:02:26 <quicksilver> RyanT5000: that's my gut reaction, at least
01:05:51 <RyanT5000> quicksilver: i agree with the uncommonness thing, but i'm not sure how one would implement it without (real) dependent types
01:06:14 <quicksilver> RyanT5000: two ways I can think of
01:06:27 <quicksilver> RyanT5000: the simplest is to return a record with slots for all the results
01:06:35 <quicksilver> RyanT5000: but only actually calculate the ones you want to calculate :)
01:06:39 <quicksilver> RyanT5000: leave the other slots empty
01:07:49 <Saizan> have many cases in the class with default implementations? a bit like >>
01:08:11 <RyanT5000> Saizan: yeah, that's the plan
01:09:13 <RyanT5000> but it's hard for me to believe there's nothing better than writing 2^n functions :P
01:09:41 <quicksilver> RyanT5000: that's why my approach is similar
01:09:45 <RyanT5000> hm, i suppose you could have two structures and make entirely too much use of undefined
01:09:47 <quicksilver> RyanT5000: sorry, why my approach is better
01:09:59 <quicksilver> RyanT5000: because you only need to write the cases you actually have good algorithms for
01:10:03 <quicksilver> RyanT5000: not all 2^n :)
01:10:09 <RyanT5000> right
01:10:28 <RyanT5000> but i don't see how you get away from doing the selection at runtime
01:10:37 <RyanT5000> e.g.:
01:10:53 <quicksilver> yes, it would be 'runtime'
01:10:55 <RyanT5000> (Bool, Bool, Bool) -> a -> b -> (c, d, e)
01:11:00 <quicksilver> but that's not as bad as you think
01:11:04 <RyanT5000> yeah
01:11:04 <quicksilver> constants can be inlined
01:11:11 <RyanT5000> how good is the constant inlining?
01:11:13 <quicksilver> and case expressions specialised at compile time
01:11:22 <quicksilver> pretty good
01:11:29 <RyanT5000> i mean, at a certain point it becomes partial evaluation
01:11:30 <quicksilver> dictionaries are passed around as constants anyway
01:11:37 <quicksilver> and they get inlined fine
01:12:04 <quicksilver> the mere fact that "3+4" produces efficient code proves the inliner works :)
01:13:05 <RyanT5000> hm
01:13:24 <RyanT5000> what is it that makes partial evaluation so hard, anyway?
01:14:01 <Saizan> partial evaluation?
01:14:07 <quicksilver> knowing when to stop, basically
01:14:13 <RyanT5000> i.e.: 3+4 inlines to 7
01:14:15 <Saizan> ah, at compile time?
01:14:18 <RyanT5000> yeah
01:14:29 <quicksilver> RyanT5000: 3+4 doesn't inline to 7 in ghc, I don't think
01:14:40 <quicksilver> RyanT5000: but it does at least inline to efficient primops
01:14:44 <mm_freak> ((+) $! 3) $! 4
01:14:45 <RyanT5000> right
01:14:51 <mm_freak> uhm…  no
01:15:12 <quicksilver> mm_freak: ghc does fold simple constants?
01:15:12 <RyanT5000> hm?
01:15:22 <Shimei2> So I got tile working with TclHaskell pretty trivially. So my hello world looks like this: http://tktable.sourceforge.net/tile/screenshots/demo-clam-unix.png (which I'd say it half decent)
01:15:24 <lambdabot> http://tinyurl.com/34yo9h
01:15:27 <mm_freak> quicksilver: i think so…  at least it unboxes them
01:15:37 <mm_freak> so the calculation should be done at compile time
01:16:27 <mm_freak> though the syntax is horrible…  i'd just stick with 3+4 and use -O or -O2
01:16:40 <gour> Shimei2: have you tried gtk2hs?
01:17:29 <Shimei2> gour: Yes, I'm actually writing an application using Gtk2Hs for summer of code. I just wanted to experiment with Tk in Haskell. :)
01:17:38 <Shimei2> Since it was a pity for the library to bitrot away.
01:18:06 <quicksilver> RyanT5000: Ah yes, it will fold some constants, my mistake
01:18:10 <quicksilver> RyanT5000: with -O2, at least
01:18:13 <RyanT5000> hm
01:18:16 <quicksilver> RyanT5000: it doesn't do very much on that front though
01:18:23 <Shimei2> (I'm still very much a gtk newbie though)
01:18:39 <quicksilver> but it *is* good at inlining cases + constant parameters
01:18:50 <mm_freak> ryant5000: with -O2 you can expect all constant expressions to become values
01:19:15 <RyanT5000> mm_freak: what do you mean by "all constant expressions"?
01:19:19 <mm_freak> it works for pretty non-trivial code, too, so it should work for 3+4 as well
01:19:55 <mm_freak> ryant5000: consider a function f, which is used only once in the entire program…  then f is effectively evaluated away
01:20:15 <mm_freak> this is not done, if f uses monads or library calls other than those from the Prelude
01:20:29 <RyanT5000> hm
01:20:47 <quicksilver> mm_freak: erm, what does monads and the prelude have to do with it?
01:20:55 <quicksilver> mm_freak: I'm pretty sure neither of those is a special case...
01:21:02 <gour> Shimei2: oh, great. i'm also preparing to dive into gtk2hs
01:21:10 <mm_freak> quicksilver: good question…  i've just tested it and that seems to be GHC's behaviour
01:21:22 <mm_freak> quicksilver: probably it's the IO monad specifically
01:21:35 <quicksilver> yes, IO specifically I would believe
01:21:43 <RyanT5000> hm
01:22:17 <mm_freak> library calls must be special case (how should the compiler optimize them away without actually executing them?)
01:22:33 <gour> Shimei2: are you working on guihaskell?
01:22:33 <quicksilver> mm_freak: because it has access to their source
01:22:38 <RyanT5000> is there any performance reason, then, to use classes instead of records?
01:22:44 <quicksilver> mm_freak: cross-module inlining does work
01:22:50 <Shimei2> gour: Yes. 
01:23:03 <mm_freak> quicksilver: which doesn't guarantee that the calculation does not take ages
01:23:08 <quicksilver> RyanT5000: no, they both desugar to tuples
01:23:13 <quicksilver> mm_freak: yeah, it has an inlining threshold
01:23:21 <quicksilver> mm_freak: inlining != constant folding though
01:23:33 <gour> Shimei2: great! is your timing ok?
01:23:37 <RyanT5000> quicksilver: i thought classes were static
01:23:40 <quicksilver> but if it inlines something, which then looks like a constant
01:23:49 <quicksilver> RyanT5000: static in what sense?
01:24:09 <RyanT5000> as in, it statically knows which instance to use, so it doesn't need a tuple of anything
01:24:19 <quicksilver> RyanT5000: all I mean is that both classes and records are syntactic sugar, they desugar down to the same sort of code, so there's no a priori reason to choose
01:24:25 <quicksilver> RyanT5000: no, not necessarily
01:24:25 <RyanT5000> hm
01:24:32 <RyanT5000> i didn't realize classes were just sugar
01:24:36 <quicksilver> RyanT5000: you can export a function of type (Num a) => a -> a
01:24:36 <Shimei2> gour: Yeah, I think I'm more or less on schedule. I'm finally grokking ndm's PropLang library (GUI library that wraps around gtk2hs), which is making the code nicer.
01:24:40 <quicksilver> RyanT5000: which is too large to inline
01:24:49 <quicksilver> RyanT5000: then you obviously need the dictionary :)
01:24:57 <RyanT5000> hm
01:25:00 <gour> Shimei2: good luck. guihaskell might evolve in haskell IDE one day ;)
01:25:06 <mm_freak> :k IO
01:25:08 <lambdabot> * -> *
01:25:26 <RyanT5000> why doesn't it specialize?
01:25:26 <quicksilver> mm_freak: I think if it inlines something which then turns out to be a constant, it will happily fold it
01:25:34 <quicksilver> RyanT5000: that's an interesting question
01:25:44 <quicksilver> RyanT5000: I'm not really qualified to answer it, but as far as I know:
01:25:55 <quicksilver> RyanT5000: it doesn't *need* a special rule for specialising class functions
01:25:57 <RyanT5000> specialization seems like it would be often faster (except for code caching issues?)
01:26:03 <quicksilver> RyanT5000: because they desugar to constant tuples
01:26:10 <quicksilver> RyanT5000: and it alreayd knows how to optimise constant tuples
01:26:13 <mm_freak> quicksilver: i've seen GHC do a lot of unboxing, which pretty much convinced me that i don't have to care much about performance
01:26:18 <Shimei2> gour: I hope so. I hear a lot of summer of code projects ended up being abandoned in previous years. That'd be a pity!
01:26:28 <quicksilver> RyanT5000: so class specialization because just a simple special case of a generic optimisation
01:26:38 <mm_freak> i need to say that i always use -O2, though
01:26:52 <gour> Shimei2: right. otoh, many haskell newcomers are asking about IDE
01:27:09 <mm_freak> gour: emacs =)
01:27:12 <RyanT5000> quicksilver: only if it'll generate a separate function for each input tuple
01:27:29 <gour> mm_freak: too late - my soul is sold to vim :-)
01:27:39 * Shimei2 is rather attached to vim too
01:27:39 <mm_freak> hehe
01:27:42 <quicksilver> RyanT5000: the whole function gets inlined anyway
01:27:55 <RyanT5000> no, i mean when it can't inline
01:27:59 <quicksilver> RyanT5000: and then the parameter (the tuple) gets inlined
01:28:03 <Shimei2> If I have some time later, I'm thinking of trying out the plug/socket interface in Gtk. It allows embedding other apps (e.g. emacs/vim) into a Gtk app.
01:28:15 <Shimei2> No sense in re-inventing the good.
01:28:19 <quicksilver> RyanT5000: why would it not be able to inline?
01:28:20 <gour> mm_freak: i use pida (http://pida.co.uk) which embeds vim and emacs (with some patches) too
01:28:22 <lambdabot> Title: PIDA Community loves you!
01:28:34 <RyanT5000> quicksilver: as mm_freak said, might be too big
01:28:44 <RyanT5000> so, let's say we have a degenerate function add = (+)
01:28:52 <mm_freak> dunno, i'm just using plain emacs for almost anything textish
01:28:55 <Shimei2> gour: That's where I got inspiration to use plug/socket, actually. Cool.
01:28:56 <RyanT5000> there's a separate instance of + for each member of Num
01:29:04 <RyanT5000> there could be a separate instance of add as well
01:29:08 <RyanT5000> i'm asking if it does that
01:29:26 <gour> Shimei2: having hida would be great so one can write haskell plugins :-))
01:29:41 <quicksilver> RyanT5000: no, there are never separate instances
01:29:41 <RyanT5000> likewise there could be a separate instance of myArbitraryFunction :: (SomeConstraints a b c) => a -> b -> c
01:29:48 <quicksilver> RyanT5000: (add) would be inlined though :)
01:29:57 <gour> Shimei2: count on me as pre-alpha tester :-)
01:30:27 <RyanT5000> quicksilver: is that just because it's a nice clean rule? there's no reason you *couldn't* specialize, right?
01:30:39 <quicksilver> RyanT5000: they chose not to
01:30:43 <RyanT5000> k :)
01:30:57 <quicksilver> RyanT5000: the argument is, as I understand it, that their general optimise does whole-program transformations
01:31:03 <RyanT5000> (btw, the reason i'm asking so many questions is that i'm thinking of building a language)
01:31:04 <quicksilver> RyanT5000: which supersede specialisation
01:31:08 <quicksilver> so it's really not necessaru
01:31:11 <RyanT5000> hm
01:31:26 <quicksilver> it took me quite a long time to accept this one, too
01:31:45 <quicksilver> if you're building a language I recommend reading some of SPJ's papers
01:31:51 <quicksilver> spineless tagless G-machine, perhaps
01:31:55 <RyanT5000> well i certainly think that specialization is often or maybe even usually good
01:32:04 <RyanT5000> er
01:32:04 <quicksilver> I don't disagree
01:32:05 <RyanT5000> bad
01:32:06 <RyanT5000> lol
01:32:06 <wli> I wrote a G-machine -based interpreter.
01:32:28 <wli> Basically following SPJ's old book word-for-word.
01:32:33 <mm_freak> ryant5000: why should specialization be bad?
01:32:37 <RyanT5000> i wrote a very optimized MD5 in asm once
01:32:46 <quicksilver> mm_freak: generating extra code for no benefit
01:32:48 <RyanT5000> for Pentium 4 M
01:33:03 <RyanT5000> i had macros that could unroll the loop arbitrarily much
01:33:06 <wli> The painful parts were that I basically had to write a linker and things on that order.
01:33:07 <mm_freak> true
01:33:24 <quicksilver> RyanT5000: it's quite difficult to picture the operational semantics of a spineless tagless machine
01:33:27 <quicksilver> (at least I find it so)
01:33:43 <quicksilver> but basically most of the worry cruft around the dictionaries has vanished during the code generation
01:33:53 <quicksilver> one instance of your polymorphic code is enough
01:33:54 <RyanT5000> not unrolled at all was about 20 instructions (for that part)
01:33:59 <RyanT5000> unrolled it was like 700
01:33:59 <mm_freak> ryant5000: that's subjective…  when writing in asm, you can only optimize for certain processors
01:34:08 <quicksilver> the right functions are 'magically' in place at the right times
01:34:19 <RyanT5000> the rolled version was like twice as fast
01:34:22 <mm_freak> and i've often seen GCC to do much better work than me
01:34:27 <RyanT5000> even though the unrolled version had far fewer jumps
01:34:44 <mm_freak> fewer jumps, but probably more cache misses or something
01:34:48 <RyanT5000> exactly
01:34:56 <mm_freak> that's why i wouldn't hand-optimize in this case
01:35:08 <RyanT5000> if you were to have a separate version of every function for every possible set of instances it supports
01:35:18 <RyanT5000> you could easily end up with 100s of versions of a given function
01:35:29 <wli> Nowadays the sorts of things I think would be worthwhile language-wise are basically state machine generators.
01:35:33 <mm_freak> yeah…  you can see this in the GMP sources =)
01:35:47 <RyanT5000> which could put your cache misses through the roof
01:35:49 <wli> Ones not functioning like flex/yacc.
01:36:12 <RyanT5000> it's very hard to tell whether any given specialization should be generated
01:36:15 <wli> Silicon compilers, too.
01:36:39 <mm_freak> quicksilver: if you export functions explicitly, don't the unneeded instances get dropped automatically?
01:37:08 <wli> And maybe a little bit of Prolog-esque bits with Grobner basis and/or linear algebra -based CLP.
01:37:15 <RyanT5000> mm_freak: are you talking about what i said?
01:37:27 <RyanT5000> if so, the thing is that some specializations aren't worth it
01:37:32 <mm_freak> ryant5000: nope, i'm back at instanciating vs. rewriting
01:37:34 <RyanT5000> k
01:37:53 <RyanT5000> and then managing unspecialized --> specialized transitions is tricky
01:38:06 <RyanT5000> evolutionary auto-optimizer? :D
01:38:16 <mm_freak> ryant5000: what did you write that MD5 implementation for, anyway? ;)
01:38:20 <RyanT5000> fun
01:38:20 <RyanT5000> :P
01:38:24 <mm_freak> hehe
01:38:35 <RyanT5000> i had just discovered NASM's macro system
01:38:46 <RyanT5000> it's surprisingly powerful
01:38:56 <RyanT5000> (though nowadays i would just write a haskell program to emit asm)
01:39:26 <mm_freak> it sure is, but still i believe, unless you're a processor guru, C compilers will do a better job than you
01:39:35 <RyanT5000> nah
01:39:53 <RyanT5000> i didn't know very much about optimization (i still don't)
01:39:54 <wli> mm_freak: It depends a lot on the problem domain and also the CPU.
01:40:18 <RyanT5000> iirc, my code was about 10% faster than visual studio's code
01:40:25 <RyanT5000> which, at the time, produced better code than gcc
01:40:36 <RyanT5000> the main thing was that i could use a rotating queue of registers
01:40:42 <mm_freak> wli: yes, it used to be easy to write highly optimized code for 80486…  but today's processors are just too complex, and there are far too many to do it by hand alone
01:40:45 <RyanT5000> instead of having to do a shift
01:41:00 <RyanT5000> it was a Pentium 4 M
01:41:05 <wli> mm_freak: When the optimization problem is focused in very narrow areas, it's still possible, though it's certainly not trivial work.
01:41:09 <mm_freak> i'd rather let GCC generate reference code and optimize that one further, where possible
01:41:24 <RyanT5000> VS got about 1.7 million per second; mine got about 2.0
01:41:46 <RyanT5000> the compiler respects conventions too much :P
01:41:56 <wli> mm_freak: Usually it falls into the domain of bitblitting and such.
01:42:03 <RyanT5000> when you're writing it by hand, you can just pushad at the beginning, popad at the end
01:42:11 <mm_freak> ryant5000: have a look at the mdcrack project…  they have written a pretty fast implementation of MD5
01:42:21 <mm_freak> http://mdcrack.df.ru/
01:42:27 <lambdabot> Title: MDCrack, bruteforce your MD2/MD4/MD5/HMAC/NTLM1/IOS/PIX/FreeBSD and even more ha ...
01:42:36 <wli> RyanT5000: Compilers are actually able to do that sort of thing, but it takes a lot of pain to implement.
01:42:38 <RyanT5000> is it a clever attack?
01:42:56 <RyanT5000> if so it'll be way faster than mine
01:43:05 <RyanT5000> i should dig up that code
01:43:10 <RyanT5000> i have *no* idea where it is though
01:43:10 <wli> RyanT5000: Basically information not normally used as inputs to the compiler are needed.
01:43:12 <RyanT5000> it's probably lost
01:43:14 <mm_freak> no, but i'm approaching 300 million hashes per second on my duron 1.6 ghz
01:43:40 <wli> RyanT5000: It also needs what amounts to whole-program optimization.
01:43:41 <mm_freak> it's not particularly intelligent, just very fast
01:43:42 <RyanT5000> yeah, that's definitely not a straight brute force attack then
01:44:07 <mm_freak> probably they use state saving or similar techniques
01:44:11 <RyanT5000> yeah
01:44:16 <mm_freak> like pre-calculating a few cycles of MD5
01:44:28 <mm_freak> or other phases
01:44:46 <RyanT5000> MD5 is something like 700 instructions; even with simd or something else i doubt you could get it below 100
01:45:03 <wli> RyanT5000: Basically, all you have to know are the entrypoints of the code.
01:45:12 <mm_freak> i doubt that SIMD would be any useful here anyway
01:45:16 <RyanT5000> me too
01:45:38 <RyanT5000> just consider it a 7x "generic cleverness" ratio
01:45:46 <wli> RyanT5000: You need a compatible calling interface there. Everything else is just basic blocks, live variables, and potentially computed jumps/calls.
01:45:52 <RyanT5000> right
01:46:25 <Saizan> ?hoogle Type -> Name
01:46:29 <lambdabot> No matches, try a more general search
01:46:32 <wli> RyanT5000: I'm not entirely sure what's used for computed jump elimination, but there are more issues there with e.g. dynamic linking.
01:47:00 <DRMacIver> Hm. So, I finally got around to watching the K versus Java screencast. Is it just me or is the K code alarmingly readable?
01:47:11 <wli> RyanT5000: So if there's anything like that happening you need enough information to be compatible with the dynamic linking.
01:47:20 <wli> DRMacIver: I've never even heard of K.
01:47:29 <DRMacIver> It's a proprietary language.
01:47:34 <DRMacIver> So that's not surprising. :)
01:47:34 <RyanT5000> wli: yeah, probably
01:47:34 <mm_freak> what would be very useful would be an optimizing byte-code to native-code compiler…  then parsing a language could be separated from optimizing code
01:47:46 <DRMacIver> But it's in a similar family to APL, J, etc.
01:47:52 <mm_freak> for a special simple, but expressive byte code
01:48:10 <wli> DRMacIver: I remember it now. APL redone to remove reliance on the APL keyboard/charset.
01:48:23 <wli> mm_freak: The nature of that bytecode is a serious problem.
01:48:23 <quicksilver> mm_freak: why "byte-code"? why not just "intermediate code"?
01:48:30 <DRMacIver> wli: Well, J is that too. :)
01:48:43 <DRMacIver> wli: K seems tied to a specific family of DB related products I think.
01:48:44 <mm_freak> quicksilver: because it shouldn't be used by humans, but rather by compilers
01:48:58 <quicksilver> mm_freak: right. I'd still call that "intermediate code".
01:49:10 <quicksilver> "bytecode" suggests a particular form that may not be ideal.
01:49:17 <mm_freak> quicksilver: `bytecode' seems to be a pretty common term for such codes
01:49:26 <quicksilver> mm_freak: anyhow, if I understand you correctly, you're describing C--
01:49:35 <wli> mm_freak: The way things seem to be shaking out AFAICT is that there is one IR to represent the programming paradigm and/or language family, and another IR to abstract out machine types/families, then you get an M:N universal compiler problem reduced to categories of machines and categories of languages.
01:49:35 <mm_freak> C-- ?
01:49:39 <quicksilver> yes, C--
01:49:41 <DRMacIver> 'bytecode' suggests to me something that can be executed in a virtual machine without compilation.
01:49:48 <quicksilver> an intermediate language designed as a target for compilers
01:49:48 <DRMacIver> (Although is often JIT compiled really)
01:50:22 <quicksilver> It was designed partly by SPJ
01:50:26 <quicksilver> and GHC uses it, somewhat
01:50:32 <quicksilver> http://www.cminusminus.org/
01:50:35 <lambdabot> Title: C-- Home
01:50:36 <wli> I suggest using infinite temporary three-address code with a type-indexed store.
01:51:07 <mm_freak> wli: basically all programming languages/paradigms translate to imperative code at some point
01:51:26 <RyanT5000> is there a standard Haskell library for generating x86 code?
01:51:31 <quicksilver> RyanT5000: 'harpy'
01:51:35 <quicksilver> @where harpy
01:51:36 <lambdabot> I know nothing about harpy.
01:51:38 <quicksilver> hmph
01:51:38 <RyanT5000> cool
01:51:43 <quicksilver> it's a bit experimental, but it's very cool
01:51:46 <wli> mm_freak: Not true. There are languages and paradigms whose "execution" essentially does things like generating images or circuit designs.
01:51:50 <quicksilver> you can generate + run code at runtime :)
01:51:54 <mm_freak> and now there should be an simple, expressive imperative language that is easy to optimize
01:51:58 <RyanT5000> quicksilver: sweet
01:52:06 <RyanT5000> was that used in last year's icfp?
01:52:10 <RyanT5000> or was it made in response :P
01:52:17 <quicksilver> @where+ harpy http://uebb.cs.tu-berlin.de/harpy/
01:52:18 <lambdabot> Done.
01:52:28 <mm_freak> wli: i'm talking about code destined to be run by a microprocessor
01:52:59 <RyanT5000> quicksilver: are you familiar with last year's ICFP?
01:53:13 <wli> mm_freak: Okay, that's also not entirely true. There are and/or have been non- von Neumann CPU's with stored programs.
01:53:41 <quicksilver> see also: http://augustss.blogspot.com/2007/06/playing-with-harpy-recently-there-was.html
01:53:42 <wli> mm_freak: Especially string processing, but also Japanese Fifth Generation project affairs.
01:53:43 <lambdabot> Title: Things that amuse me, http://tinyurl.com/3dlr2o
01:53:53 <mm_freak> wli: then add: for real-world applications
01:54:25 <mm_freak> or: for the majority of real-world applications, where code efficiency is important
01:54:27 <quicksilver> RyanT5000: well, i've read about it. I haven't attempted to solve it myself.
01:54:29 <wli> mm_freak: If real world includes government/military applications, then the things I told you about are precisely such.
01:54:50 <mm_freak> oh…  then i should look that up
01:55:41 <wli> mm_freak: Vector machines deserve honorable mention here, and they are in routine use (cf. SV2 for a recent instance).
01:55:58 <mm_freak> but regardless of that, the main issue i'm referring to is that there are dozens of languages, architectures and compilers…  the compilers are mostly reinventing the wheel
01:56:09 <RyanT5000> quicksilver: it looks like writing a JIT compiler with harpy would be easier than writing an interpreter in C
01:56:22 <RyanT5000> mm_freak: also, that's called competition :P
01:56:28 <hpaste>  nomeata pasted "iter_inits" at http://hpaste.org/1626
01:56:31 <wli> mm_freak: Well, a universal compiler project has yet to happen.
01:56:31 <quicksilver> RyanT5000: it would be x86 only, of course
01:56:37 <quicksilver> RyanT5000: but it's undeniably cool
01:56:49 <nomeata> Hi. Can the just pasted function be written better, i.e., without (++)[last ..]?
01:56:53 <mm_freak> IMO we should separate the task of optimization from parsing a language
01:57:27 <quicksilver> mm_freak: right, and that's exactly GHC's design
01:57:31 <wli> mm_freak: However, I would suggest a dual IR approach, where there is one set of IR's for different machine types and another set of IR's for different language types.
01:57:35 <RyanT5000> quicksilver: yeah; i hope this year's icfp has a JIT >.>
01:57:41 <mm_freak> quicksilver: yes, it uses GCC for optimized code ;)
01:57:42 <RyanT5000> (this will be my first ICFP)
01:58:03 <quicksilver> mm_freak: it has its own optimisations which make gccs look like child's playthings
01:58:30 <quicksilver> mm_freak: it uses gcc really as a code-generator not an optimiser, and it even post-processes the assembly output of gcc
01:58:35 <mm_freak> wli: IR ?
01:58:42 <quicksilver> Intermediate Representation
01:58:51 <wli> quicksilver: gcc is more about the gruntwork of porting to zillions of cpus than any sort of serious optimization effort.
01:58:52 <mm_freak> ah k
01:59:04 <quicksilver> wli: right. that's what I said, isn't it? :)
01:59:25 <DRMacIver> wli: As I understand it, that's more because GHC generates incomprehensible C than because it couldn't benefit from GCC's low level optimisation. :)
01:59:26 <quicksilver> and the thesis of the C-- lot is that C is a rather bad language for that purpose
01:59:43 <mm_freak> quicksilver: yes, there are basically two optimization phases:  first translate functional code to imperative code, second make this code efficient on today's CPUs
01:59:44 <quicksilver> (separating code generation from optimisation)
02:00:05 <quicksilver> so they designed an intermediate language which was designed to be a good target for high level compilers
02:00:09 <quicksilver> and a good source for code generation
02:00:21 <quicksilver> "portable assembly code" they call it in one of their buzzlines
02:00:41 <wli> It's not what I'd call portable assembly, but anyway.
02:01:24 <mm_freak> well, it's probably some sort of code for a hypothetical turing-complete architecture
02:01:31 <wli> I also think it's the wrong level of abstraction.
02:01:38 <wli> mm_freak: No, it's a "cleaned up C."
02:02:06 <wli> C sits too close to the middle.
02:02:15 <mm_freak> it's questionable whether such a language needs to be aware of the concept of separate `procedures'
02:02:48 <wli> mm_freak: That's one reason why C-- is wrong; the calling conventions etc. are constrained to be like C.
02:03:01 <mm_freak> yes, IMO it shouldn't
02:03:06 <dons> re.
02:03:12 <dons> so have we taken over the world yet?
02:03:21 <mm_freak> dons: not yet, not yet
02:03:22 <dons> evening quicksilver, mm_freak, DRMacIver 
02:03:26 <wli> dons: One matrix at a time.
02:03:27 <dons> must be getting close though!
02:03:30 <mm_freak> good morning, dons =)
02:04:01 <dons> did I mention that today we ran Haskell on the GPU for the first time ? :-)
02:04:08 <mm_freak> dons: #perl has still got more activity =)
02:04:15 <wli> I think I'd use some sort of graph reduction -oriented IR for Haskell.
02:04:28 <dons> Sean Lee, a PhD student here, finished the first binding of zipWith to nvidia GPU code
02:04:41 <dons> so yay for dedicated parallel hardware
02:04:46 <mm_freak> dons: is GPU code really that fast?
02:05:22 <dons> the gpu is, yeah, for map/fold/filter stuff
02:05:31 <dons> 10x faster than the cpu for that kind of thing, at a start
02:05:32 <mm_freak> ah yeah, that makes sense
02:05:51 <dons> you can see it as a dedicated piece of hardware for haskell array combinators :)
02:06:03 <dons> this is how we beat C in the end :)
02:06:05 <mm_freak> hehe
02:06:07 <wli> For x86 what Haskell really wants to do is to use the stack to represent the STG machine directly.
02:06:15 <mm_freak> yeah, C doesn't have such a thing
02:06:15 <quicksilver> wli: I don't understand your point about calling conventions
02:06:16 <dons> fold . map . filter --> fuse to streams --> run on gpu
02:06:40 <quicksilver> wli: C-- doesn't mandate calling conventions, that's up to the code generator...
02:07:29 <wli> quicksilver: Jumps, calls, etc. need not correspond to procedure calls.
02:07:45 <bringert> dons: sounds cool. there is a bunch of people at chalmers interested in that sort of thing. you may want to talk to mary sheeran.
02:08:06 <dons> bringert: oh? gpu stuff in particular, or data parallelism in general?
02:08:32 <quicksilver> wli: C-- permits you direct jumps which do not correspond to procedure calls if you wish
02:08:33 <bringert> dons: both.
02:08:38 <wli> quicksilver: Procedure boundaries for C-like languages don't necessarily map well to the languages.
02:08:51 <dons> bringert: oh, huh. didn't know that. got a url?
02:09:04 <wli> quicksilver: looking
02:09:47 <bringert> dons: I don't think there is anything online. they've just started looking at it, afaik
02:09:51 <DRMacIver> dons: Nice.
02:10:05 <dons> bringert: ah ok, yes, this whole area is moving very fast
02:10:22 <dons> only last year we were writing opengl code, now there's CUDA and we can pretty much generate C for these chips
02:10:53 <quicksilver> dons: I hope some of this stuff makes the transition from 'demo-ware' to real code usable by the masses...
02:11:03 <dons> and today i got to see haskell ffi calls into the gpu for the first time, so its all coming along nicely
02:11:24 <dons> quicksilver: yeah, thing is you'll need a pretty new graphics card
02:11:35 <dons> with one of these many core gpus in them. and a copy of nvcc, the nvidia gpu compiler
02:11:41 <dons> then, with that, you'll be ok.
02:11:47 <RyanT5000> dons: yeah, I was in law school for a year and now there's all this new stuff in Haskell
02:11:49 <dons> it should just be a library, pretty much, for gpu arrays
02:12:12 <dons> quicksilver: e.g. i'd be keen to a real world Data.ByteString.GPU :)
02:12:44 <quicksilver> even better to have a compiler that can make its own decision about when to use the GPU
02:12:52 <bringert> dons: do you have a web page for this?
02:13:01 <quicksilver> and better still to have a RTS that can choose at runtime depending what GPU is found :)
02:13:18 <dons> oh, there's Data.Fixed, mm_freak , how did we not see that?
02:13:21 <dons> bringert: yeah, let me see..
02:14:39 <mm_freak> dons: maybe it sounded too obvious to be possible =)
02:14:52 <dancor> is there a foldr for monads
02:15:28 <dons> bringert: there's a little here, http://www.cse.unsw.edu.au/~pls/projects/ on sean's page, http://www.cse.unsw.edu.au/~seanl/research.html and on and in the abstract for a talk sean gave, http://www.comp.mq.edu.au/~asloane/pmwiki.php/SAPLING/SAPLING071?action=download&upname=lee071.pdf
02:15:28 <lambdabot> Title: Programming Languages & Systems: Projects
02:15:36 <dons> dancor: foldM 
02:15:36 <dancor> @hoogle Monad m => (a -> b -> m b) -> a -> [b] -> m b
02:15:37 <lambdabot> Prelude.foldl :: (a -> b -> a) -> a -> [b] -> a
02:15:37 <lambdabot> Data.List.foldl' :: (a -> b -> a) -> a -> [b] -> a
02:15:38 <mm_freak> dancor: not specifically
02:15:44 <quicksilver> sequence
02:15:45 <quicksilver> mapM
02:15:48 <dons> sequence really, yes.
02:15:50 <dons> ?src sequence
02:15:51 <lambdabot> sequence ms = foldr k (return []) ms
02:15:51 <lambdabot>     where
02:15:51 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
02:15:51 <quicksilver> might be described as 'foldr for monads'
02:16:00 <quicksilver> depends what you want, exactly :)
02:16:03 <quicksilver> mapM_, maybe
02:16:14 <dons> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Fixed.html
02:16:16 <lambdabot> http://tinyurl.com/3bzw9h
02:17:56 <bringert> dons: thanks
02:18:34 <dancor> i think i want..  foldlM f x ys = foldM (flip . f) x ys
02:18:35 <dons> :t div' 
02:18:36 <lambdabot> forall a b. (Integral b, Real a) => a -> a -> b
02:18:43 <dons> hah, we had Data.Fixed in scope all along
02:18:48 <quicksilver> heh
02:19:00 <dons> > 1.1 :: Fixed E6
02:19:01 <quicksilver> but it's clumsy to use, cos of needing instances for your precision
02:19:02 <lambdabot>  1.100000
02:19:10 <dons> > 1.1 + 2.2 :: Fixed E6
02:19:12 <lambdabot>  3.300000
02:19:16 <wli> Hmm, C-- actually looks like it'd be kind of nice to program in vs. ordinary C.
02:19:19 <dons> > 1.1 + 2.2 - 3.3 :: Fixed E6
02:19:21 <lambdabot>  0.000000
02:19:23 <quicksilver> I personally still think Rational is fine, with sufficient care
02:19:46 <dons> apparently though, quicksilver, I'm informed there are legal requirements for fixed precision
02:19:51 <dons> which is local dependent even
02:20:02 <wli> dons: BCD fixpoint even, IIRC.
02:20:07 <dons> and if you're running a bank, you're required to round after a given precision
02:20:23 <wli> dons: In BCD.
02:20:32 <dons> > 1.1 `div'` 2.2 :: Fixed E6
02:20:33 <lambdabot>   add an instance declaration for (Integral (Fixed E6))
02:20:33 <lambdabot>     In the expression...
02:20:46 <quicksilver> dons: right. "with sufficient care" means rounding at the appropriate times
02:20:55 <dons> > 1.1 + 2.2 - 3.3 :: Fixed Micro
02:20:55 <lambdabot>        add an instance declaration for (HasResolution (Fixed E6))
02:20:58 <dons> > 1.1 + 2.2 - 3.3 :: Micro
02:21:00 <lambdabot>  0.000000
02:21:00 <vincenz> dons: whatis Micro
02:21:05 <dons> > 1.1 + 2.2 - 3.3 :: Pico
02:21:07 <lambdabot>  0.000000000000
02:21:07 <vincenz> dons: fixed-point?
02:21:16 <quicksilver> dons: my argument is that you need to understand when to round whichever type you use
02:21:18 <dons> > showFixed ( 1.1 + 2.2 - 3.3 :: Pico )
02:21:18 <lambdabot>  Couldn't match expected type `Bool' against inferred type `Pico'
02:21:29 <quicksilver> dons: and Rational lets you 'intermix' types of different precisions
02:21:30 <dons> > showFixed True ( 1.1 + 2.2 - 3.3 :: Pico )
02:21:31 <lambdabot>  "0"
02:21:34 <dons> > showFixed False ( 1.1 + 2.2 - 3.3 :: Pico )
02:21:36 <lambdabot>  "0.000000000000"
02:21:43 <quicksilver> dons: but if there are legal requirements, I guess...
02:21:50 <mm_freak> does anyone know the cardinality of the set A of all algebraic numbers?  is it |A| = |ℕ| or |A| = |ℝ| ?
02:21:55 <dons> it looks liked Fixed here is really set up for this?
02:22:22 <quicksilver> mm_freak: cardinality? aleph_0, surely
02:22:47 <mm_freak> quicksilver: so the algebraic numbers are countable?
02:23:03 <quicksilver> mm_freak: yes, they're roots of integer polynomials
02:23:07 <quicksilver> so you can count them...
02:24:56 <mm_freak> quicksilver: do you have a real example of a bijection ℕ → A ?
02:25:21 <roconnor> |A| = |ℕ|
02:25:49 <wli> mm_freak: They're denumerable.
02:25:51 <roconnor> because every algebraic number is the root of some rational polynomial/
02:26:00 <quicksilver> mm_freak: just number the polynomials 
02:26:02 <roconnor> and each polynomial has a finite number of roots
02:26:12 <quicksilver> mm_freak: e.g. 2^i . 3^j . 5^k . 7^m
02:26:13 <mm_freak> quicksilver: that's redundant
02:26:21 <quicksilver> where i,j,k,m are the co-efficients
02:26:30 <quicksilver> oh, you want a bijection
02:26:33 <quicksilver> heh
02:26:33 <mm_freak> yes
02:26:39 <quicksilver> well, that's fiddly if you want to be detailed
02:26:51 <mm_freak> i noticed =)
02:27:02 <quicksilver> don't need a bijection to establish cardinality
02:27:05 <wli> mm_freak: The bijection is a little hairy. Essentially they're finite sequences of integers, so you first map them to finite sequences of naturals.
02:27:12 <roconnor> to get a bijection just sieve out the reducable polynomials.
02:27:29 <wli> mm_freak: Then you grade them by height.
02:27:38 <mm_freak> quicksilver: it's plausible, but i'd like a proof, just because it becomes less trivial if you actually _need_ such a bijection
02:27:45 <wli> mm_freak: Where the height of a sequence is the sum of its elements.
02:27:54 <quicksilver> mm_freak: erm, you'd like a proof of what?
02:28:01 <quicksilver> mm_freak: I've given you a proof a bijection exists
02:28:18 <roconnor> quicksilver: the proof isn't constructive :(
02:28:24 <quicksilver> indeed not
02:28:27 <quicksilver> he didn't ask for that :P
02:28:34 <mm_freak> yes, it's plausible, but not enough to be a proof
02:28:47 <quicksilver> no, it is a proof
02:28:53 <wli> mm_freak: Actually, first you map the coefficients to naturals, then you order by length, then by height, then lexicographically.
02:28:59 <quicksilver> it is more than plausible, it is watertight
02:29:15 <quicksilver> if there are injections A -> B and B -> A then they have the same cardinality
02:29:43 <wli> mm_freak: With suc an ordering on finite integer sequence it's then just a combinatorical problem to carry out the bijection.
02:29:48 <roconnor> http://en.wikipedia.org/wiki/Cantor%E2%80%93Bernstein%E2%80%93Schroeder_theorem
02:29:50 <lambdabot> Title: Cantor–Bernstein–Schroeder theorem - Wikipedia, the free encyclopedia, http://tinyurl.com/wwnkt
02:30:02 <mm_freak> wli: maybe the following approach is simpler:  every algebraic number is the smallest root of some rational polynomial
02:30:33 <wli> mm_freak: I'm already assuming that.
02:30:40 <wli> mm_freak: In fact, using it.
02:31:02 <mm_freak> now with polynomial interpolation and a number of fixed other points, maybe you could find such a polynomial
02:31:11 <mm_freak> that would be A → ℕ, but that's ok
02:31:30 <dons> that unicode keeps corrupting my terminal
02:31:35 <quicksilver> mm_freak: how do you know every algebarid number occurs as a smallest root, btw?
02:31:42 <quicksilver> mm_freak: that's plausible but not obvious :)
02:32:01 <roconnor> quicksilver: I don't really find it plausable.
02:32:03 <mm_freak> quicksilver: well…  good question =)
02:32:18 <quicksilver> find me the polynomial of which sqrt(2) is the least root, for example
02:32:23 <mm_freak> it doesn't even have to be the smallest root
02:32:33 <quicksilver> (I'm not claiming it doesn't exist, but I am claiming it's not obvious)
02:32:48 <roconnor> I'll claim it doesn't exist.
02:32:49 <wli> mm_freak: Every algebraic number is the root of a polynomial with integer coefficients. It may be described as a finite integer sequence and a number k : 1 <= k <= deg(p(x)) describing the roots (e.g. dictionary ordering on complex numbers).
02:32:55 <mm_freak> quicksilver: set a fixed point (x,0), where x > 2 and use polynomial interpolation
02:33:10 <mm_freak> well, you'll need three points, so set two of them
02:33:37 <quicksilver> I would pair the algebraics with their minimal polynomials and their 'root number'
02:33:47 <quicksilver> and then sort those lists in some arbitrary but sensible way
02:33:49 <roconnor> root number?
02:33:55 <quicksilver> counting from the left
02:34:00 <wli> mm_freak: Actually a monic polynomial with rational coefficients is better.
02:34:14 <quicksilver> e.g. this is the 5th smallest root of...
02:34:33 <mm_freak> wli: yes, but that's not a surjection, if i understood it properly
02:34:37 <wli> mm_freak: So you get deg(p(x)) rational numbers and a number k : 1 <= k <= deg(p(x)) specifying which root.
02:34:42 <roconnor> quicksilver: the canoncial method of distinguishing roots is by the list of signs of the derivitive of the minimal polynomial at the root.
02:34:53 <quicksilver> roconnor: fine, but it doesn't matter :)
02:34:59 <quicksilver> roconnor: we only need a number here
02:35:06 <quicksilver> roconnor: doesn't matter much where the number comes from
02:35:24 <roconnor> quicksilver: a right, we aren't going to do computations with these repesentations ;)
02:35:29 <quicksilver> mm_freak: polynomial interpolation gives no guarantee not to find a smaller root
02:35:49 <mm_freak> quicksilver: if you give two other roots, then it is
02:36:21 <quicksilver> mm_freak: ah, but it doesn't guarantee rational coefficients
02:36:44 <quicksilver> the coefficients are 'calculated' from the roots you ask for
02:36:51 <quicksilver> since one of the roots you ask for is sqrt(2)...
02:36:59 <quicksilver> in most cases you'll end up with irrational coefficients
02:37:02 <mm_freak> if you constain it to rational coefficients, then that's no guarantee, yes
02:37:16 <quicksilver> mm_freak: we need rational coefficients :P
02:37:21 <wli> mm_freak: Anyway, you can map a monic p(x) to a finite sequence of naturals of length deg(p(x)) using the bijection between the naturals and the rationals, then if k is the number of the roots.
02:37:22 <quicksilver> mm_freak: that's the whole point of algebraic numbers
02:37:46 <mm_freak> hmm
02:37:54 <wli> mm_freak: then if k is the number of the root you get something you can find a bijection to/from the naturals with.
02:38:53 <wli> mm_freak: The next thing you do is to grade the sequences first by their length, then by the sum of their elements, and then use lexicographical ordering.
02:39:21 <mm_freak> wli: i'll check that out
02:39:36 <mm_freak> btw, is there a way to add the roots of two polynomials together, without actually finding them?
02:40:27 <wli> mm_freak: Then you can enumerate them in order. Cast out the instances that aren't irreducible, then you have a lazy list of all the polynomials.
02:40:58 <mm_freak> wli: i'm not going to implement such a thing, it was a purely theoretical question =)
02:41:03 <wli> mm_freak: There are ways to check irreducibility.
02:41:28 <wli> mm_freak: I've had integer sequence numeration problems before.
02:43:05 <quicksilver> mm_freak: there are expressions for the sums of roots yes
02:43:11 <quicksilver> mm_freak: and the products of the roots, indeed
02:43:38 <quicksilver> I certainly dont' recall the details
02:44:31 <wli> mm_freak: A function enumerating the rationals is not so difficult. concat [[(j, i - j) | j <- [1..i], i `gcd` j == 1] | i <- [0..]]
02:44:37 <quicksilver> mm_freak: http://en.wikipedia.org/wiki/Newton's_identities
02:44:38 <lambdabot> Title: Newton's identities - Wikipedia, the free encyclopedia
02:46:08 <wli> mm_freak: Interleave that and the same with numerators negated, prepend 0 to the front, and you have a list of all rationals. The index in the list is the function from rationals to naturals. (listQ!!) is the function from naturals to rationals.
02:46:29 <wli> mm_freak: The same sort of thing is used to enumerate the finite sequences of naturals for polynomials.
02:46:53 <mm_freak> wli: yeah, i've understood it to that point
02:47:12 <roconnor> > [foldr (\b x -> if b then x+1 else (x/x+1)) (0::Rational) y|i<-[0..], y<-replicateM i [True,False]]
02:47:13 <wli> mm_freak: You define a Haskell list that enumerates them all in order, use filter to nuke things that shouldn't be there, and your bijection is defined.
02:47:13 <lambdabot>  Exception: Ratio.%: zero denominator
02:47:20 <roconnor> > [foldr (\b x -> if b then x+1 else (x/x+1)) (1::Rational) y|i<-[0..], y<-replicateM i [True,False]]
02:47:22 <lambdabot>  [1%1,2%1,2%1,3%1,3%1,2%1,2%1,4%1,4%1,3%1,3%1,2%1,2%1,2%1,2%1,5%1,5%1,4%1,4%1...
02:47:45 <roconnor> hmm, not quite right
02:47:46 <dons> anyone know why CAL exists?
02:47:49 <dons> dibblego: around?
02:47:50 <Syzygy-> > do (n,d) <- concat [[(j,i-j)|j<-[1..i],i`gcd`j == 1]|i<- [0..]]; return $ show n ++ "/" ++ show d
02:47:51 <lambdabot>  ["1/0","1/1","1/2","2/1","1/3","3/1","1/4","2/3","3/2","4/1","1/5","5/1","1/...
02:48:07 <dons> we're not heading down the lisp path of a bunch of incompatible clones are we? :/
02:48:15 <roconnor> > [foldr (\b x -> if b then x+1 else (x/(x+1))) (1::Rational) y|i<-[0..], y<-replicateM i [True,False]]
02:48:16 <lambdabot>  [1%1,2%1,1%2,3%1,3%2,2%3,1%3,4%1,5%2,5%3,4%3,3%4,3%5,2%5,1%4,5%1,7%2,8%3,7%3...
02:48:30 <quicksilver> dons: what is CAL?
02:48:50 <dons> http://labs.businessobjects.com/cal/
02:48:52 <lambdabot> Title: The Open Quark Framework for Java and the CAL Language
02:49:10 <dons> ` A lazily evaluated, strictly-typed language called CAL, with many similarities to Haskell'
02:49:13 <dons> for the JVM
02:49:19 <dons> even has functional dependencies
02:49:26 <dons> so i'd call it a haskell clone
02:49:51 <dons> seems a ridiculous amount of effort to go to
02:49:52 <roconnor> Syzygy-: 1/0 ?
02:50:10 <|Steve|> dons: Aren't there already incompatible haskell clones? For example, ghc extensions.
02:50:25 <dons> sure, but we're not forking implementations yet.
02:50:27 <wli> roconnor: You can also enumerate rationals as finite sequences of positive integers.
02:50:42 <wli> roconnor: Corresponding to continued fractions.
02:51:24 <quicksilver> dons: I'm not sure what you mean by 'forking inmplementations'
02:51:25 <roconnor> wli: that is what I have done.
02:51:42 <quicksilver> dons: haskell and ghc have different code, and they compile (slightly) different dialects of haskell
02:51:47 <quicksilver> dons: how is that different?
02:51:57 <roconnor> wli: well, close to it.
02:52:14 <wli> roconnor: I'm not sure what you did works.
02:52:20 <quicksilver> the cute thing about the continued fraction rep is the fact that the irrationals slide in so neatly as the infinite ones
02:52:33 <roconnor> wli: it does.
02:52:38 <quicksilver> gives a very nice picture of the irrationals 'in between' the rationals
02:52:52 <roconnor> I'm working with lists of binary numbers
02:53:19 <roconnor> to convert to the appropriate finite integer sequence do
02:53:33 <dons> quicksilver: they're not even trying to be compatible, or part of the community?
02:53:34 <roconnor> map lenght . group
02:53:40 <roconnor> er
02:53:47 <roconnor> map genericLength . group
02:53:52 <quicksilver> dons: ok, but that's not what you said :)
02:53:57 <dons> maybe if they actually called it Haskell. and were part of the community, it would seem so strange
02:54:00 <roconnor> @type map genericLength . group
02:54:02 <lambdabot> forall i a. (Num i, Eq a) => [a] -> [i]
02:54:22 <dons> but they call it Quark for CAl on JVM or whatever, and don't talk to us, but we do get people on the lists saying they'll stick with CAL because windows support is better.
02:54:29 <quicksilver> dons: the reason it's different is its integrated with the java type system
02:54:31 <quicksilver> I guess
02:54:42 <dons> yeah, you can make impure calls to java, as if they were pure, i think
02:55:09 <wli> roconnor: I'm still with you, though I don't see where you're going with it yet.
02:55:16 <dons> is this like the incompatibe commercial lisps that emerged?
02:55:18 <quicksilver> dons: I would say, on the bright side, at least it's BSD-licensed
02:55:28 <dons> yes, it was binary only, now its open, that's interesting
02:55:44 <quicksilver> and there is an eclipse plug-in, I wonder if it's any good
02:56:04 <dons> the guy on the mailing list just now said he'd stick with CAL because of the eclispe plugin..
02:56:07 <quicksilver> maybe all it requires is someone to make polite advances and try to get a bit more a community/communication tie-up
02:56:27 <roconnor> wli: maybe it is better to explain it the other way.
02:56:41 <roconnor> consider the continued fraction represented by [2,3]
02:57:06 <dons> quicksilver: actually, are these the guys who run the 'haskell in leipzig' meetings?
02:57:16 <fasta> I have a value t m <foobar>, should I just pick a bogus runStateT to run it?
02:57:17 <roconnor> Convert this to a list of binary numbers.  In this case it is [True, True, False, False, False].
02:57:17 <quicksilver> dons: dunno
02:57:29 <roconnor> ie, replicate 2 True ++ replicate 3 False
02:58:05 <dons> oh, that's iba (business architecture), not 'business objects'
02:58:11 <roconnor> in my fold the two True add 1 to the number twice
02:58:13 <dons> http://iba-cg.de/haskell.html
02:58:14 <lambdabot> Title: ||: iba Consulting Gesellschaft - intelligent business architecture:||
02:58:27 <roconnor> corresponding to the 2+ in the continued fraction representation.
02:58:48 <roconnor> ... and now I see that the \x->x/(x+1) is less obvious then I thought.
02:58:54 <dons> oh, i note there was a talk on `CAL Quark' at the last hal meeting..
02:59:03 <roconnor> so you will just have to trust me that it works ...
02:59:13 <dons> ?babel de en Haskell ähnlich (98%) & mit voller Java Integration.
02:59:14 <lambdabot>   Haskell ähnlich (98%) & with full Java integration.
02:59:24 <dancor> dons: i guess they didn't feel like just making ghc output java bytecode?
02:59:29 <wli> roconnor: I'm not a very trusting person... I have to prove things.
02:59:36 <roconnor> wli:  or if you don't trust me, read http://en.wikipedia.org/wiki/Stern-Brocot_tree
02:59:37 <lambdabot> Title: Stern-Brocot tree - Wikipedia, the free encyclopedia
02:59:37 <quicksilver> dancor: the input language isn't haskell
02:59:40 <dons> dancor: yeah, that's a pity :(
02:59:45 <wli> roconnor: I don't have my own domain of holomorphy for nothing. ;)
02:59:48 <quicksilver> dancor: it's very like it, but it has quite a lot of special syntax
02:59:49 <dons> but i guess the hard issue will be libraries for them
02:59:54 <dancor> quicksilver: yeah that's the problem! :)
03:00:00 <dons> if they're not able to use haskell libs directly, CAL will lose
03:00:07 <dons> but they have java  libs. hmm
03:00:08 <quicksilver> "Many of the original insights into lazy functional systems were drawn from implementations of Haskell. Early on, Haskell (HUGS, GHC) was even considered as a starting point for the implementation itself, but a number of requirements made this impractical, so it was decided to let the project emerge and evolve freely following its own design criteria"
03:00:27 <dons> oh, that's an interesting quote.
03:01:27 <wli> roconnor: Duh. Left/right moves in the Stern-Brocot tree. Yes, that will do it.
03:02:02 <quicksilver> dons: slightly different record syntax
03:02:12 <quicksilver> dons: no pattern matching in equations
03:02:22 <dancor> python:ruby::haskell:cal
03:02:25 <quicksilver> (in fact, no multiple equations for one definition)
03:03:04 <allbery_b> java libs are not a panacea, people constantly have to reimplement them to get performance
03:03:24 <roconnor> Hmm, I don't have enough sharing in my enumeration.
03:04:12 <quicksilver> http://en.wikipedia.org/wiki/Quark_Framework
03:04:12 <lambdabot> Title: Quark Framework - Wikipedia, the free encyclopedia
03:04:21 <quicksilver> is an advertisement, essentially, but it's quite good
03:05:00 <roconnor> > let rationals = (1::Rational):concat [[x+1,x/(x+1)]|x<-rationals] in rationals
03:05:02 <lambdabot>  [1%1,2%1,1%2,3%1,2%3,3%2,1%3,4%1,3%4,5%3,2%5,5%2,3%5,4%3,1%4,5%1,4%5,7%4,3%7...
03:05:17 <roconnor> > let rationals = (1::Rational):concat [[x/(x+1),x+1]|x<-rationals] in rationals
03:05:19 <lambdabot>  [1%1,1%2,2%1,1%3,3%2,2%3,3%1,1%4,4%3,3%5,5%2,2%5,5%3,3%4,4%1,1%5,5%4,4%7,7%3...
03:05:22 <DRMacIver> allbery_b: But then they open source them and you can use those libs. :)
03:05:43 <DRMacIver> allbery_b: The library advantage of Java which is often referred to is the open source community far more than the standard libraries.
03:06:12 <roconnor> wli: that's much better and shorter.
03:06:43 <roconnor> maybe we need more monads.
03:07:06 <fasta> What are the conditions for not needing explicit lifting?
03:07:07 <roconnor> > let rationals = (1::Rational):concatMap (\x->[x/(x+1),x+1]) rationals in rationals
03:07:11 <lambdabot>  [1%1,1%2,2%1,1%3,3%2,2%3,3%1,1%4,4%3,3%5,5%2,2%5,5%3,3%4,4%1,1%5,5%4,4%7,7%3...
03:07:15 <RyanT5000> is there any way to make a datastructure that can only hold a DAG?
03:07:40 <quicksilver> > let rationals = (1::Rational):concat [[x/(x+1),x+1]|x<-rationals] in findIndex (==27/51) rationals
03:07:41 <lambdabot>  Just 513
03:07:44 <quicksilver> fun :)
03:08:00 <quicksilver> > let rationals = (1::Rational):concat [[x/(x+1),x+1]|x<-rationals] in findIndex (==50/20) rationals
03:08:02 <lambdabot>  Just 10
03:08:20 <roconnor> > let rationals = (1::Rational):do {x<-rationals; [x/(x+1),x+1]} in rationals
03:08:22 <lambdabot>  [1%1,1%2,2%1,1%3,3%2,2%3,3%1,1%4,4%3,3%5,5%2,2%5,5%3,3%4,4%1,1%5,5%4,4%7,7%3...
03:09:10 <roconnor> meh
03:09:23 <roconnor> maybe the list comprehention with concat is best.
03:09:25 <fasta> In a function f I use mfix, but when I call f in the monadtransformer it needs instances that do not exist, so I would say I need to lift it, but OTOH there should be a way to avoid explicit lifting... how?
03:09:52 <roconnor> quicksilver: :)
03:10:25 <wli> roconnor: Well, easy enough to define a function from integers to rationals, though it's less clear how to invert it.
03:10:41 <wli> roconnor: f 0 = 1 :: Rational ; f n = let { (q,r) = n `divMod` 2 ; x = f q } in if r == 0 then 1 + x else x/(1+x)
03:11:01 <roconnor> @check (\ x-> let rationals = (1::Rational):concat [[x/(x+1),x+1]|x<-rationals] in isJust (findIndex (==x) rationals))
03:11:07 <lambdabot> Terminated
03:11:12 <fasta> Where are the equivalent of Monad m => MonadState s (StateT s m) for MonadFix?
03:11:19 <fasta> equivalents*
03:11:33 <wli> roconnor: planetmath says the elements of the continued fraction are the exponents in the Stern-Brocot tree.
03:11:45 <roconnor> wli: the inverse of the stern-Brocot tree is the trace of the euclidian algorithm.
03:12:02 <wli> roconnor: Same thing.
03:12:34 <roconnor> @scheck (\ x-> let rationals = (1::Rational):concat [[x/(x+1),x+1]|x<-rationals] in isJust (findIndex (==x) rationals))
03:12:35 <fasta> Is it even possible to define (MonadFix m ) => MonadFix (StateT s m)?
03:12:35 <quicksilver> fasta: I see them
03:12:35 <lambdabot>       add an instance declaration for (Serial (Ratio Integer))
03:12:36 <lambdabot>     In the exp...
03:12:47 <fasta> quicksilver: You do?
03:12:50 <quicksilver> fasta: thery are in Control.Monad.State.{Lazy,Strict}
03:12:55 <quicksilver> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-State-Strict.html
03:12:55 <fasta> quicksilver: that would be great. 
03:12:56 <wli> roconnor: 
03:12:57 <lambdabot> http://tinyurl.com/2lytv6
03:13:09 <quicksilver> MonadFix m => MonadFix (StateT s m)
03:13:11 <quicksilver> etc
03:13:48 <wli> roconnor: Well, "trace of the Euclidean algorithm" is kind of vague. 
03:14:50 <fasta> quicksilver: How do you see them in your actual interpreter? 6.7.20070705
03:14:55 <fasta> quicksilver: I use that version.
03:15:34 <quicksilver> *Main> :info MonadFix
03:15:42 <quicksilver> instance (MonadFix m) => MonadFix (StateT s m)
03:15:42 <quicksilver>   -- Defined in Control.Monad.State
03:15:49 <roconnor> wli: indeed, you run the euclidean algorithm using only subtractions and output True or False depending on whether n < m or m > n.
03:16:04 <roconnor> wli:  I guess I should write it out.
03:16:10 <fasta> quicksilver: I don't get that one. 
03:16:18 <fasta> quicksilver: what modules loaded?
03:16:20 <roconnor> gcdtrace n m | n == m = []
03:16:26 <quicksilver> Control.Monad.State
03:16:29 <fasta> quicksilver: Prelude Control.Monad.State Control.Monad.State.Strict>
03:16:38 <quicksilver> very odd
03:16:39 <fasta> quicksilver: I have those loaded
03:16:41 <roconnor>     | n < m = True:(gcdtrace n (m - n))
03:16:48 <quicksilver> I'm only on 6.6 here
03:16:52 <fasta> quicksilver: it is
03:16:55 <quicksilver> but I don't understand...
03:17:02 <roconnor>    | n > m = Falae:(gcdtrace (n - m) m)
03:17:10 <roconnor> @away lunch
03:17:10 <lambdabot> Unknown command, try @list
03:35:28 <wli> Not doing so good.
03:36:26 <wli> For some reason it works for 113/355 but not 355/113
03:45:21 <RyanT5000> so i have a mutator for my object, which is roughly similar to a Map
03:45:58 <RyanT5000> basically it's identical in form to Map.insert
03:46:02 <RyanT5000> @type Map.insert
03:46:08 <RyanT5000> @type Data.Map.insert
03:46:10 <lambdabot> Couldn't find qualified module.
03:46:12 <lambdabot> forall k a. (Ord k) => k -> a -> Data.Map.Map k a -> Data.Map.Map k a
03:46:30 <RyanT5000> so, i'm thinking that it might be more general to declare it as:
03:46:47 <RyanT5000> MonadState m (Map k a) => k -> a -> m ()
03:46:56 <RyanT5000> is there any reason *not* to do that?
03:47:11 <RyanT5000> and then just write insert in terms of it?
03:48:18 <RyanT5000> insert k v = snd . (runState $ insertM k v)
03:48:22 <RyanT5000> (i think that's right)
03:51:09 <Lemmih> RyanT5000: Well, you could say the same thing the other way around.
03:51:54 <Lemmih> RyanT5000: insertM k v = modify (insert k v)
03:52:08 <RyanT5000> hm
03:52:16 <RyanT5000> there's no way to specialize functions like that is there?
03:52:20 <quicksilver> RyanT5000: It's not that useful, IMO
03:52:34 <quicksilver> RyanT5000: because there aren't built-in combinators to 'embed' smaller state in larger state
03:52:56 <quicksilver> although, such things would be useful
03:53:09 <RyanT5000> it'd be really useful if certain things could, e.g., automatically become faster when you use them in ST
03:53:22 <RyanT5000> the specific case i have right now is
03:53:27 <quicksilver> MonadState s m, MonadState r n => (r ->s
03:53:27 <RyanT5000> it's as i described
03:53:32 <RyanT5000> except instead of Map k a
03:53:37 <RyanT5000> i have index value
03:53:41 <RyanT5000> which is in a class
03:53:43 <quicksilver> MonadState s m, MonadState r n => (r -> s) -> (r -> s -> r) -> m a -> n a
03:53:53 <quicksilver> where r is a 'bigger state' than s
03:54:01 <quicksilver> and you provide your own projection + update functions
03:54:04 <RyanT5000> yeah, stuff like that is needed
03:54:13 <Lemmih> RyanT5000: Why would things become faster when you use ST?
03:54:13 <RyanT5000> i'll probably end up writing it
03:54:31 <RyanT5000> i guess they'd require a special datastructure too
03:54:40 <quicksilver> RyanT5000: see my recent email in haskell-cafe where I ramble on at great length about embedding one monad in another
03:54:49 <RyanT5000> class Index index query key | index -> query, index -> key where
03:54:50 <RyanT5000>     insertM :: MonadState m (index value) => key -> value -> m ()
03:54:54 <RyanT5000> that's the situation right now
03:55:41 <RyanT5000> basically i think it would be really cool if ST were an instance of MonadState and this could be taken advantage of by indexes
03:55:53 <RyanT5000> maybe if m were quantified at the class level instead?
03:56:01 <quicksilver> ST is a bit different
03:56:10 <quicksilver> ST lets you make any number of 'fresh' variables
03:56:14 <quicksilver> of any type
03:56:21 <RyanT5000> hm ok
03:56:22 <quicksilver> newSTRef is more powerful than MonadState
03:56:28 <RyanT5000> right
03:56:42 <RyanT5000> what if we had a monad that was like MonadState only, you know, fast, like ST
03:56:42 <quicksilver> you certainly can make STRef an instance of MonadState "with respect to manipulations of one particular variable"
03:56:49 <RyanT5000> right
03:56:53 <RyanT5000> that's what i was thinking of
03:57:09 <quicksilver> but I think you may be under a misapprehension
03:57:10 <RyanT5000> however, your datastructure would have to be made up of STRefs for it to be useful (right?)
03:57:20 <RyanT5000> that's entirely possible :)
03:57:23 <RyanT5000> probable, even
03:57:37 <quicksilver> ST isn't "specially fast"
03:57:47 <quicksilver> the main time ST is fast is in the specific case of very large arrays
03:57:58 <quicksilver> which you don't want to keep copying un-necessary
03:58:06 <RyanT5000> right
03:58:15 <quicksilver> with 'ordinary haskell data' the copying requirements for ST are no better, or worse, than plain MonadState
03:58:23 <quicksilver> actually ST might be worse
03:58:26 <quicksilver> another level of boxing
03:58:31 <quicksilver> although I doubt that's an issue
03:58:41 <RyanT5000> ok but let's say i build up a MutableMap type
03:58:44 <quicksilver> ST is probably less optimisable
03:59:00 <RyanT5000> that uses STRefs as pointers
03:59:06 <quicksilver> (again, see my email for a way to make IO an instance of MonadState, effectively)
03:59:12 <RyanT5000> so now i can build a red-black tree or whatever
03:59:43 <RyanT5000> or are those no more efficient than haskell's Maps?
03:59:57 <quicksilver> probably not :)
04:00:00 <RyanT5000> oh yeah another thing: this might end up interfacing with a MySQL database, or something crazy
04:00:12 <RyanT5000> so it might need to run, meaningfully, in IO
04:00:13 <quicksilver> the advantages of a truly mutable data structure are often overstated
04:00:20 <bringert> what
04:00:24 <quicksilver> that, of course, is different
04:00:30 <bringert> 's with all the german spam lately?
04:00:30 <quicksilver> then it really does need IO :)
04:00:40 <RyanT5000> yeah, that just now occurred to me
04:01:00 <RyanT5000> incidentally, does anyone in here have advice on how to cope with programming in python?
04:01:08 <quicksilver> paracetamol helps
04:01:10 <RyanT5000> i'm volunteering for One Laptop Per Child this summer
04:01:15 <norpan> python is nice
04:01:21 <quicksilver> python's really not that bad, seriously
04:01:26 <RyanT5000> and they're pretty much a python shop
04:01:37 <quicksilver> nice simple syntax, simple object model, simple everything-is-a-dictionary approach to life
04:01:40 <pesco> pfft
04:01:50 <quicksilver> I quite like it as a 'minimal' imperative scripting language
04:02:08 <RyanT5000> yeah; if they were just using it for scripting i'd be happy
04:02:22 <wli> Okay, I can't figure it out right now for some reason.
04:02:25 <RyanT5000> and they've asked me to write a distributed file system
04:02:33 * pesco puts duct-tape over his mouth as a precaution.
04:02:38 <RyanT5000> seeing as they're not paying me, i'm writing it in haskell :P
04:02:42 <quicksilver> :)
04:02:54 <RyanT5000> if they paid me, they could choose
04:03:16 <RyanT5000> speaking of which, i'd love to hear advice anyone has on building a distributed file system
04:03:33 <RyanT5000> i described its basics at http://wiki.laptop.org/go/MeshFS
04:03:34 <quicksilver> "Good luck"
04:03:36 <lambdabot> Title: MeshFS - OLPCWiki
04:03:40 <RyanT5000> (i realize it's off-topic, though)
04:03:50 <RyanT5000> what's the off-topic haskell chatroom here?
04:03:53 <quicksilver> it's not off-topic if you're writing it in haskell
04:03:57 <RyanT5000> that's true! :D
04:04:03 <quicksilver> there is #haskell-overflow
04:04:06 <quicksilver> but it's seldom needed
04:04:14 <quicksilver> and #haskell-blah, I think
04:04:21 <RyanT5000> yeah, that's the one i was thinking of
04:05:15 <pesco> RyanT5000: I think Coda does most things right (except being based on AFS which I distrust personally).
04:06:13 <wli> Let's see if I can even get a list with the things I want in them.
04:06:17 <RyanT5000> ah, it's not that kind of DFS
04:06:32 <pesco> RyanT5000: Oh...
04:06:37 <RyanT5000> it's one of the grokster variety
04:06:49 <pesco> RyanT5000: *shrug*
04:13:29 <RyanT5000> aw, no freenet zealots here?
04:15:21 <roconnor> wli: what doesn't work about 355/113?
04:16:27 <wli> roconnor: My attempt to write the functions.
04:16:41 <roconnor> wli: which functions?
04:16:55 * roconnor can't figure out how to mark myself back.
04:17:00 <roconnor> er himself
04:17:02 <wli> roconnor: The bijections to/from the naturals and rationals.
04:17:15 <EvilTerran> roconnor, /away, no arguments?
04:17:23 <roconnor> EvilTerran: that's what I thought
04:17:34 <roconnor> but it isn't working for me at the moment.
04:17:36 <EvilTerran> some clients have /back, as well
04:17:45 <roconnor> EvilTerran: whew, thanks
04:17:50 <EvilTerran> :D
04:18:18 <EvilTerran> isn't interface consistency GREAT?!
04:18:23 <roconnor> @paste
04:18:23 <lambdabot> Haskell pastebin: http://hpaste.org/new
04:21:04 <wli> roconnor: I think it'd be faster to use the elements of the continued fraction if it can be figured out what on earth to do with them.
04:22:16 * edward1 waves hello.
04:22:32 <roconnor> > subtract 1 5
04:22:33 <lambdabot>  4
04:22:45 <pesco> RyanT5000: Not yet for me, at least. I do like their new darknet approach though.
04:23:03 <wli> I think the empty string maps to 0, f(LS) = 2*f(S) + 1, f(RS) = 2*f(S) + 2, who knows what else.
04:24:40 <Eelis> is there a way to add a ghc shebang line (#!/usr/bin/ghc...) to a Haskell source file, to make it directly executable?
04:26:17 <andun> Eelis: #!/usr/bin/runghc
04:26:35 <andun> (or more generally "runhaskell")
04:26:53 <Eelis> excellent, thanks!
04:39:00 <hpaste>  roconnor pasted "a bijection between natural numbers and rationals" at http://hpaste.org/1629
04:39:21 <roconnor> wli: see that
04:39:57 <wli> doh
04:40:14 <roconnor> wli:  I haven't verified prop_B
04:40:24 <roconnor> No instance for (Arbitrary (Ratio Integer))
04:40:24 <roconnor>       arising from use of `quickCheck' at <interactive>:1:0-16
04:41:06 <roconnor> wli:  I'm assuming that gcdTrace' will be deforested
04:43:04 <roconnor> otherwise replace [] with 0 and (True:) and (False:) with (1+).(2*) and (2+).(2*) respectively
04:44:02 <roconnor> Hmmm, actually some strictness is needed
04:44:22 <roconnor> ah well, whatever
04:46:48 <wli> I think I have something working...
04:47:19 <wli> I've never used QuickCheck before.
04:48:10 <roconnor> In my example you can do run "quickCheck prop_A"
04:48:12 <RyanT5000> has anyone implemented serious relational tables in haskell before?
04:48:14 <roconnor> in ghci
04:48:22 <RyanT5000> (not that mine is planning to be "serious")
04:48:40 <EvilTerran> as in databases?
04:48:42 <RyanT5000> yeah
04:48:57 <wli> RyanT5000: Look for R, R+, R*, X, X*, T, etc. tree implementations.
04:49:01 <EvilTerran> not afaik, but it sounds like an interesting idea
04:49:04 <wli> RyanT5000: In-core and on-disk.
04:49:26 <RyanT5000> hm, those sound way beyond me :P
04:49:27 * EvilTerran envisages a DBE written in haskell
04:49:36 <wli> RyanT5000: I'd love some of that as a LogicT back-end.
04:49:41 <EvilTerran> that'd be cool
04:49:45 <RyanT5000> lazyness + purity = transactions?
04:50:12 <RyanT5000> wait, is that thing i just said actually non-retarded?
04:50:18 <RyanT5000> if you have a queue of pending operations
04:50:25 <RyanT5000> and none of them cancel
04:50:29 <RyanT5000> and you just try to pile them all together
04:50:39 <RyanT5000> will lazy processing be more effective than locks?
04:51:01 <RyanT5000> i guess if you have to do IO in the middle stuff starts getting tricky
04:51:10 <hpaste>  wli pasted "Stern-Brocot representation of rationals" at http://hpaste.org/1631
04:51:40 <EvilTerran> DB transactions could be compared to things in the Maybe monad
04:51:41 <wli> roconnor: The dumber-than-thou approach on my part.
04:52:10 <RyanT5000> EvilTerran: yeah, which is awesome; i'm just thinking about the efficiency here though
04:52:22 <RyanT5000> i mean normally you have to lock all the rows you're updating, right/
04:52:22 <RyanT5000> ?
04:52:24 <roconnor> wli: oh 1/ (1+ (1/ x))
04:52:30 <roconnor> that's what (x/(x+1)) is
04:52:44 <roconnor> that makes sense now
04:52:47 <EvilTerran> yes, or (depending on the granularity of the DBE) the whole table
04:52:48 <RyanT5000> i mean i guess you could try to pile stuff together at the SQL or IL level
04:53:02 <RyanT5000> but if i have something like a Set Row
04:53:13 <RyanT5000> and i want to map two functions over it, each of which is supposed to be a transaction
04:53:33 <RyanT5000> i can just start running the second one on the output of the first before it's computed, thanks to laziness
04:53:42 <RyanT5000> i guess this requires i have everything in memory
04:53:50 <EvilTerran> concurrency is a big part of DBEs, mind, and that makes things complicated
04:54:08 <roconnor> wli: I got my algorithm from Milad Niqui's thesis.
04:54:15 <RyanT5000> yeah, but shouldn't purity actually give us the upper hand on that?
04:54:24 <EvilTerran> yeah, i guess so
04:54:33 <roconnor> wli: I'm not actually smart
04:54:47 <vincenz> roconnor: welcome to the club
04:54:48 <RyanT5000> i mean, throughout all this i'm ignoring disk storage
04:54:56 <RyanT5000> but if you have it all in memory, it seems like haskell could do better than sql
04:55:01 <RyanT5000> hmmm
04:55:19 <roconnor> I suspect that Milad got his algorithm from someone else further.
04:55:21 <EvilTerran> haskell's concurrency uses a stateful monad, tho, so there's a certain amount of impurity involved anyway.
04:55:48 <etnt> RyanT5000: jfyi: erlang has got a heavy duty DBMS called mnesia. it's both disk and in memory
04:56:16 <RyanT5000> haskell can't evaluate pure expressions concurrently can it?
04:56:38 <RyanT5000> i mean, if i evaluate (f x, g y), it can't automatically do that in two threads, can it?
04:56:46 <pesco> RyanT5000: Hm, you might look at Oleg's Zipper-FS for inspiration wrt. how "purely functional" relates to "filesystem"!
04:57:20 <quicksilver> RyanT5000: no, it doesn't
04:57:29 <quicksilver> RyanT5000: if you think about that, that's incompatible with call-by-need
04:57:43 <quicksilver> RyanT5000: demand-driven evaluation means you only evaluate a thunk when you need it
04:57:49 <quicksilver> RyanT5000: and you only 'need' one at a time :)
04:58:23 <quicksilver> RyanT5000: however, if you construct the tuple (f x, g y), and the fork two threads, and one thread 'demands' the f value and the other thread 'demands' the g value
04:58:35 <quicksilver> RyanT5000: then the thunks will, I believe, get calculated in the different threads
04:58:35 <RyanT5000> quicksilver: not quite; at least on a logical level (putStrLn x) needs all the characters in x
04:59:02 <vincenz> pesco: or higher-order zippers
04:59:11 <RyanT5000> you could shove all of the thunks in x into a queue, and each interpreter-thread would take a thunk, evaluate it, and commit it
04:59:14 <quicksilver> that's not demand-driven evaluation, then, is it?
04:59:16 <vincenz> chessguy__: btw, the article has been cleaned up a lot, to clear up the math :)
04:59:21 <quicksilver> RyanT5000: yes but there is only ever one thunk!
04:59:31 <vincenz> RyanT5000: how do you deal with data-dependencies? you need locking
04:59:36 <quicksilver> RyanT5000: in the simple model of lazy evaluation, you naturally only demand one thunk (per thread) at a time
04:59:43 <quicksilver> RyanT5000: so you never get a queue
04:59:50 <etnt> btw, does anyone know if there exist an interface between Haskell and Erlang ? 
04:59:53 <RyanT5000> vincenz: a queue of (Table -> Table)
04:59:57 <quicksilver> RyanT5000: recall that your x is really c : cs
05:00:06 <vincenz> RyanT5000: seems impossible
05:00:11 <quicksilver> RyanT5000: anyhow, I'm partly being pedantic, and partly trying to explain a pedagogical point
05:00:15 <vincenz> RyanT5000: unless you want users to wait very long
05:00:19 <RyanT5000> quicksilver: i understand the idea of curried functions :P
05:00:24 <vincenz> RyanT5000: oyu're basically forcnig everything into a single thread
05:00:25 <quicksilver> RyanT5000: what you *want* to achieve is an active area of research
05:00:32 <quicksilver> RyanT5000: and there is lots of work going on with it
05:00:33 <wli> roconnor: One could consider the continued fraction a run length encoded Stern-Brocot binary representation.
05:00:34 <EvilTerran> i guess if you know in advance that you'll need the entirety of a list, you could force every character in parallel in some way
05:00:34 <quicksilver> RyanT5000: 'NDP'
05:00:37 <RyanT5000> vincenz: but it's lazily evaluated, which i think might make it work
05:00:54 <RyanT5000> quicksilver: ah, i see
05:01:07 <RyanT5000> usually that's what things i want to achieve are :(
05:01:20 <quicksilver> RyanT5000: http://hackage.haskell.org/trac/ghc/wiki/DataParallel
05:01:23 <lambdabot> Title: DataParallel - GHC - Trac
05:01:30 <EvilTerran> (see SPJ's data paralleli- curse, beaten to the punch)
05:01:40 <vincenz> RyanT5000: no it will not... I want to pull data from the table as user, I have to wait until the whole queue is done!
05:01:42 <quicksilver> but I would advise you to think a bit more about demand-driven evaluation in haskell
05:01:44 <vincenz> RyanT5000: every read incurs a force
05:01:56 <quicksilver> which is what makes this 'not as easy as you might think'
05:02:00 <quicksilver> (not the same as impossible, though!)
05:02:20 <RyanT5000> vincenz: hm... what if reads were in the same queue as updates?
05:02:26 <vincenz> RyanT5000: then I have to wait?
05:02:35 <vincenz> RyanT5000: you're basically designin a single-threaded database
05:02:53 <EvilTerran> and a non-transactional one, from the sounds of it
05:02:55 <RyanT5000> you'd only have to wait for the updates submitted prior to your call
05:03:05 <vincenz> EvilTerran: pretty much
05:03:25 <RyanT5000> well, as long as your transaction fits into Table -> (a, Table) :P
05:03:26 <EvilTerran> when someone starts a transaction, no-one else sees any changes they make until they commit it
05:03:30 <RyanT5000> yeah i realize that isn't good enough
05:03:45 <RyanT5000> (well, it's good enough for what i'm doing *now*)
05:03:48 <EvilTerran> you'd have to work that in somewhere
05:03:51 <Igloo> Has the Haskell wiki started logging other people after (I assume) a period of inactivity?
05:04:55 <vincenz> RyanT5000: my point is that you're simply reinventing the single-threaded statemonad
05:05:12 <RyanT5000> vincenz: good point :)
05:05:23 <vincenz> well it's slightly different
05:05:35 <vincenz> but the state-monad is a queue .. of (s -> (a,s))
05:05:39 <RyanT5000> right
05:05:49 <vincenz> sequenced together with >>=
05:06:03 <RyanT5000> the only differences is that the a's could all potentially be going to different threads
05:06:12 <RyanT5000> instead of the subsequent function
05:06:43 <EvilTerran> incidentally, speaking of threads an' that, is it possible to have two threads evaluate things in parallel, then suspend one the moment the other finishes?
05:06:53 <dblhelix> someone know who's responsible for the ghci debugger?
05:07:27 <RyanT5000> EvilTerran: wouldn't that be *literally* creating a race?
05:07:45 * EvilTerran was idly pondering an "asap :: a -> a -> a" function, that forced both parameters in parallel and returned the first to finish evaluating
05:08:08 <vincenz> EvilTerran: that's called 'por'
05:08:08 <RyanT5000> ew
05:08:09 <RyanT5000> :P
05:08:11 <vincenz> in literature
05:08:14 <EvilTerran> (i say "a -> a -> a", there should be IOs in there somewhere)
05:08:26 <EvilTerran> por?
05:08:31 <vincenz> parallel or
05:08:44 <wli> Is there a trick idiom to iterate a function n times?
05:08:49 <EvilTerran> is this defined somewhere?
05:08:57 <DRMacIver> Hm. Can one lift an a -> m b into m (a -> b) somehow? (m a monad)
05:09:00 <EvilTerran> wli, (iterate f !! n)?
05:09:09 <vincenz> > foldl ($) 1 $ take 5 $ replicate (+ 1)
05:09:10 <wli> I guess that'll have to do.
05:09:10 <lambdabot>      Occurs check: cannot construct the infinite type: b = a -> b
05:09:10 <lambdabot>     Probabl...
05:09:13 <vincenz> > foldr ($) 1 $ take 5 $ replicate (+ 1)
05:09:14 <lambdabot>      The section `(+ 1)' takes one argument,
05:09:14 <lambdabot>     but its type `Int' has none
05:09:22 <vincenz> :t foldr
05:09:24 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
05:09:33 <EvilTerran> :t iterate
05:09:35 <lambdabot> forall a. (a -> a) -> a -> [a]
05:09:40 <vincenz> EvilTerran: good point
05:09:48 <EvilTerran> > iterate (+1) 1 !! 5
05:09:49 <lambdabot>  6
05:09:57 <DRMacIver> Hm. No, I guess not.
05:13:18 <DRMacIver> Problem: I have something which I want to be able to represent with a 'lookup' function. But I was also hoping to use it in circumstances where the lookup is read off an IO backed system. I was hoping to represent this with an IO(String -> String) or similar. Is there a good way to do this?
05:13:35 <vincenz> DRMacIver: that doesn't make sense
05:13:43 <vincenz> I think
05:13:52 <vincenz> oh wait, it does, read the whole file
05:13:54 <vincenz> and return it
05:14:00 <vincenz> as a function/map/..
05:14:00 <EvilTerran> drmacIver, if you could, then you could have \action -> do{ fn <- magic action; expression involving ... fn ... }
05:14:04 <RyanT5000> is there any reasonable way to define the type of a table in such a way that the columns are typesafe?
05:14:19 <vincenz> RyanT5000: phantom types
05:14:35 <DRMacIver> vincenz: That's the informal model I'm working on, yes. But I want to do it in a way that doesn't read the whole file into memory (regardless of whether it does it lazily) :)
05:14:37 <EvilTerran> and then "fn" would have a pure type, even tho IO had to be done when it were evaluated
05:14:50 <quicksilver> DRMacIver: no, because a -> m b says that there can be a different computation for each a
05:14:52 <vincenz> DRMacIver: then no...cause you return a pure function and the data in the file might change
05:15:07 <quicksilver> DRMacIver: while m ( a -> b ) says one computation is enough to return a 'total function'
05:15:11 <quicksilver> DRMacIver: for all a
05:15:29 <DRMacIver> vincenz: Yeah. Because there's nowhere at all in the standard Haskell libraries where lazy IO happens. ;)
05:15:32 <quicksilver> DRMacIver: you can write a brute-force transform if 'a' is a finite type, by running all the actions
05:15:47 <DRMacIver> quicksilver: Yeah, I realised that. Hence my "Hm. No, I guess not" afterwards. :)
05:16:22 <quicksilver> I expect you can do it with unsafeInterleave, yes
05:16:30 <quicksilver> you can certainly do it with unsafePerform
05:16:40 <quicksilver> heck, you can make it (String -> String) with unsafePerform
05:16:44 <quicksilver> who needs the IO tag at all?
05:17:33 <DRMacIver> Don't tempt me. :)
05:18:33 <quicksilver> what don't you like about String -> IO String?
05:18:38 <quicksilver> it is the right type, after all...
05:20:45 <DRMacIver> Lack of interchangeability with pure in memory structures and a requirement to thread IO through one of the fundamental operations for the operation despite using what's effectively an immutable disk backed structure.
05:21:11 <quicksilver> if you know it's immutable
05:21:15 <quicksilver> then use unsafeInterleave
05:21:18 <quicksilver> that's what it's for :)
05:21:27 <DRMacIver> ok. :)
05:21:59 <quicksilver> the unsafeInterleave promise says "I, the programmer, certify to the you, the compiler, that it doesn't matter when this IO action is performed, it will return the same result anyway"
05:22:17 <quicksilver> do we actuallyhave these promises documented anywhere? we should.
05:22:39 <Igloo> You also need to promise that it doesn't matter when its side-effects happen
05:23:00 <Igloo> Or even /if/ they happen, if you never demand the value
05:23:00 <quicksilver> that's why it needs to be documented
05:23:08 <quicksilver> because idiots like me will say the wrong thing!
05:23:08 <quicksilver> :)
05:23:18 <quicksilver> Igloo: both of which apply to his immutable file case, though
05:23:20 <RyanT5000> quicksilver: also, it'd be kind of cool if we had a tag that got propagated through the type system that said "this function is unsafe"
05:23:35 <quicksilver> RyanT5000: We do. It's called "IO".
05:23:35 <RyanT5000> or some way to achieve security
05:23:40 <RyanT5000> quicksilver: no no
05:23:40 <quicksilver> ;)
05:24:12 <RyanT5000> some way of programmatically distinguishing readFile from id
05:24:21 <eivuokko> You mean something similar as some languages have for exception specifications?
05:24:22 <RyanT5000> oh wait
05:24:26 <RyanT5000> @type readFile
05:24:31 <lambdabot> FilePath -> IO String
05:24:35 <RyanT5000> nevermind that example :P
05:24:43 <EvilTerran> sounds like Clean's uniqueness types
05:24:45 <RyanT5000> i guess if something takes an IO and doesn't return one that could be a hint
05:24:54 <RyanT5000> basically, hplugin would use this feature
05:24:54 <quicksilver> RyanT5000: I do understand your point. I think that 'IO' serves that purpose though.
05:25:11 <quicksilver> and I think the readFile example was a good one :)
05:25:23 <quicksilver> Now, what you certainly could ask for is a 'finer-grained' IO
05:25:24 <quicksilver> FileIO
05:25:26 <quicksilver> RandomIO
05:25:29 <quicksilver> TCPIO
05:25:30 <quicksilver> etc
05:25:43 <quicksilver> although you can do that with newtype'ing IO
05:25:48 <RyanT5000> yeah but there's a doomsday scenario where a file loaded by hplugin has access to an unsafe function you didn't realize it did
05:25:59 <RyanT5000> and you can't tell
05:26:21 <RyanT5000> basically, if a function is linked against unsafePerform, there's no way to know whether it does IO or not
05:26:32 <quicksilver> yes, that's true enough
05:26:45 <quicksilver> we can restrict this with the import system though
05:27:05 <RyanT5000> yeah, but it'd be nice if you could say "give me everything safe from this module"
05:27:12 <RyanT5000> Data.Array.IArray, for example
05:27:30 <ejt> hi, does anyone know how I can turn an EpochTime into something I can format
05:27:32 <EvilTerran> so you want some kind of annotation to functions that use unsafe*IO?
05:27:41 <RyanT5000> EvilTerran: i think so
05:27:59 <takamura> hi
05:28:02 <RyanT5000> and then you could have a whitelist
05:28:07 <quicksilver> RyanT5000: IArray doesn't have any unsafe exports, does it?
05:28:17 <RyanT5000> i'm not sure
05:28:37 <RyanT5000> of functions that use unsafe* but are themselves safe
05:28:43 <RyanT5000> e.g.: DiffArray stuff, i think
05:28:49 <SamB> it has!
05:28:56 <SamB> @hoogle unsafeArray
05:28:57 <lambdabot> No matches found
05:29:09 <quicksilver> ejt: don't use System.Time, use Data.Time
05:29:12 <SamB> @docs Data.Array.IArray
05:29:12 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array-IArray.html
05:29:15 <quicksilver> ejt: System.Time is broken
05:29:32 <RyanT5000> SamB: no unsafe functions seem to be listed in there
05:29:37 <RyanT5000> but i could've sworn there were some
05:29:40 <fasta> Can I statically guarantee that I won't ever build a reference based tree that contains cycles?
05:29:44 <quicksilver> SamB: I don't see any occurrences of 'unsafe' in that file :)
05:30:00 <RyanT5000> man, what's the deal with IArray anyway?
05:30:07 <RyanT5000> is that the least extensible class ever, or what?
05:30:15 <fasta> RyanT5000: is it already working?
05:30:15 <quicksilver> fasta: if you don't use recursion perhaps?
05:30:22 <SamB> @docs Data.Array.Base
05:30:22 <lambdabot> Data.Array.Base not available
05:30:25 <RyanT5000> fasta: ?
05:30:36 <fasta> RyanT5000: the random stuff
05:30:52 <fasta> quicksilver: how should I build a tree data type without recursion? 
05:30:56 <RyanT5000> fasta: ah, yeah; i just grabbed augusts's MT19937 code and packaged it up
05:31:08 <RyanT5000> well, instanced the appropriate classes
05:31:08 <SamB> class IArray a e where
05:31:08 <SamB>     -- | Extracts the bounds of an immutable array
05:31:08 <SamB>     bounds           :: Ix i => a i e -> (i,i)
05:31:08 <SamB>     unsafeArray      :: Ix i => (i,i) -> [(Int, e)] -> a i e
05:31:08 <SamB>     unsafeAt         :: Ix i => a i e -> Int -> e
05:31:08 <SamB>     unsafeReplace    :: Ix i => a i e -> [(Int, e)] -> a i e
05:31:10 <fasta> RyanT5000: define MT199*
05:31:10 <SamB>     unsafeAccum      :: Ix i => (e -> e' -> e) -> a i e -> [(Int, e')] -> a i e
05:31:14 <SamB>     unsafeAccumArray :: Ix i => (e -> e' -> e) -> e -> (i,i) -> [(Int, e')] -> a i e
05:31:16 <SamB>     unsafeReplace arr ies = runST (unsafeReplaceST arr ies >>= unsafeFreeze)
05:31:18 <SamB>     unsafeAccum f arr ies = runST (unsafeAccumST f arr ies >>= unsafeFreeze)
05:31:20 <SamB>     unsafeAccumArray f e lu ies = runST (unsafeAccumArrayST f e lu ies >>= unsafeFreeze)
05:31:32 <wli> roconnor: I'll have something shorter soon.
05:31:49 <RyanT5000> fasta: a particular Mersenne Twister that has been proven to have a period of (2^19937 - 1)
05:31:58 <SamB> RyanT5000, quicksilver that enough "unsafe"s for you?
05:32:00 <quicksilver> fasta: nod :)
05:32:00 <fasta> RyanT5000: :)
05:32:05 <RyanT5000> which seems like it should be enough :P
05:32:06 <quicksilver> SamB: they're not exported though, are they?
05:32:14 <SamB> quicksilver: of course they are
05:32:24 <ejt> quicksilver: I get the EpochTime as a result of modificationTime <file status>
05:32:25 <RyanT5000> it's a pretty sweet looking implementation, although i didn't bother to fully understand it
05:32:25 <EvilTerran> fasta, if you only want finite trees as well, you might be able to enforce it with some olegian tricks in the typesystem.
05:32:27 <SamB> I have no idea why they aren't also haddocked
05:32:43 <RyanT5000> he makes an array in ST and returns a lazy infinite list fro mit
05:33:03 <fasta> EvilTerran: essentially I want to express that nodes at depth d can only have children that are at depth (n+1)
05:33:17 <fasta> EvilTerran: that should get rid of the cycle, I guess.
05:33:21 <RyanT5000> if i understand correctly, it should result in the thunk basically being a large mutable array, which should make the algorithm very efficient
05:33:22 <quicksilver> SamB: they're not exported in http://darcs.haskell.org/ghc-6.6/packages/base/Data/Array/IArray.hs
05:33:25 <lambdabot> http://tinyurl.com/349jwn
05:33:30 <quicksilver> SamB: unless I'm misreading something
05:33:32 <fasta> EvilTerran: but I have no idea how to express that.
05:33:40 <SamB> quicksilver: apparantly true
05:33:51 <SamB> but from Data.Array.Base they most certainly are exported
05:34:16 <EvilTerran> fast, right. well, i envisage storing the "depth" of a node as a type-encoded integer in the type of the node, and then use fundeps or something to force things to have the right depth relative to each other
05:34:18 <fasta> EvilTerran: (d+1)*
05:34:28 <quicksilver> SamB: but Data.Array.Base is not for user use, as I understand it
05:34:55 <SamB> quicksilver: not unless the user needs really really zippy arrays
05:35:05 <fasta> EvilTerran: so, I should add an extra dummy field containing with that type?
05:35:09 <RyanT5000> quicksilver: the point is still that we're relying on humans to not export something unsafe
05:35:13 <EvilTerran> something like that, yes.
05:35:17 <quicksilver> RyanT5000: true
05:35:24 <fasta> EvilTerran: does that have zero run-time cost?
05:35:26 <EvilTerran> i'll have to chew it over a bit, i'll get back to you =]
05:35:29 <vincenz> RyanT5000: we're also relying on humans to write compilers that are not buggy
05:35:45 <EvilTerran> i'm not sure how exactly it works, merely that it might
05:35:48 <fasta> EvilTerran: also, it should work for STRefs, it's not a "standard tree"
05:35:57 <RyanT5000> vincenz: yeah, i realize that, but the compiler's only written once
05:35:57 <quicksilver> RyanT5000: you're safe if you stay within haskell though :)
05:36:08 <vincenz> RyanT5000: so is the module
05:36:09 <EvilTerran> um
05:36:20 <RyanT5000> yeah, but the compiler can check 40 different modules for safety
05:36:22 <RyanT5000> plus, we have multiple independent compilers
05:36:46 <RyanT5000> so if we really care we can have hugs, ghc, yhc, and nhc all check it (once they support it)
05:36:49 <RyanT5000> and have them vote :)
05:37:07 <RyanT5000> and even that scales to all the modules that are mutually supported
05:37:19 * EvilTerran wanders off to meditate
05:37:27 <quicksilver> RyanT5000: of course, it does ALL those things
05:37:32 <quicksilver> RyanT5000: and it marks the unsafe ones with the holy tag IO
05:37:36 <quicksilver> ... :)
05:37:39 <quicksilver> and we're back to square one
05:37:50 <quicksilver> which is that some people are bending the type system to do other stuff
05:37:50 <RyanT5000> no, it doesn't
05:38:11 <RyanT5000> (unsafePerformIO $ putStrLn "hello") is not marked with IO
05:38:49 <RyanT5000> basically the argument here is "whitelist or blacklist"
05:38:53 <quicksilver> right
05:38:58 <quicksilver> unsafePerformIO is not haskell
05:39:01 <quicksilver> it is incorrectly typed
05:39:09 <quicksilver> and, that's what makes it all break
05:39:09 <RyanT5000> oh whatever, that doesn't mean anything
05:39:15 <quicksilver> it does mean something
05:39:17 <RyanT5000> people writing in haskell can use it
05:39:23 <quicksilver> be a bit more patient with me
05:39:30 <quicksilver> we have a type system which does exactly what you describe
05:39:34 <quicksilver> it's just, we chose to subvert it
05:39:41 <quicksilver> by writing functions with broken types
05:39:47 <RyanT5000> yeah, i agree
05:39:52 <quicksilver> ...which turn out to be operationally convenient
05:40:02 <RyanT5000> but so long as we're doing that, i'd like a way of making it secure
05:40:08 <Philippa> RyanT5000: actually it's worse than that, it entirely breaks the semantics of Haskell
05:40:16 <RyanT5000> and i think a whitelist is way more secure - and convenient - than a blacklist
05:40:28 <RyanT5000> lol i realize that
05:40:33 <SamB> `seq` was pretty bad too...
05:40:48 <Philippa> SamB: seq is just awkward
05:41:02 <quicksilver> I personally have never used any unsafe functions in a real program
05:41:05 <Philippa> it can be given purely functional semantics
05:41:08 <SamB> `seq` breaks so many rules
05:41:10 <RyanT5000> i've never used unsafePerformIO except in CAFs in files whose sole purpose is to save me typing in GHCI
05:41:14 <quicksilver> although I have used some bytestring stuff which is unsafe under the hood
05:41:22 <quicksilver> but I (almost) trust dons to have got that right
05:41:27 <RyanT5000> everything's unsafe under the hood :P
05:41:42 <quicksilver> after all, {RULES} are unsafe too
05:41:44 <SamB> yeah, using your unsafe CPU and all
05:41:45 <RyanT5000> (i know what you mean though)
05:41:51 <Philippa> actually, a lot less is than you might think
05:41:56 <RyanT5000> :P
05:42:10 <SamB> or your unsafe GPU, now, apparantly ;-P
05:42:27 <Philippa> ccall is slightly odd as a primitive, but you can build the entire IO monad on top of it and it's "safe" in that it doesn't screw up the language's semantics
05:42:36 <RyanT5000> well that's the thing: if dons has a bug in his code that can be exploited, your secure container is dead
05:42:52 <RyanT5000> at least with a whitelist you would be forced to explicitly authorize the people who you trust
05:42:58 <Philippa> libraries and trust, what else is new?
05:43:05 <RyanT5000> not much :P
05:43:10 <RyanT5000> i'm just musing
05:43:34 <vincenz> malcolmw: ping
05:43:37 <RyanT5000> i want an environment where i can run untrusted code securely without putting much thought into it :P
05:43:52 <malcolmw> vincenz: pong
05:44:01 <vincenz> malcolmw: oh, vincenz's just my nick :)
05:44:23 <SamB> RyanT5000: a sandbox!
05:44:25 <quicksilver> I don't think Data.Bytestring is unsafe in that sense though
05:44:27 <vincenz> malcolmw: and I wanted to shamelessly plug a link to my blog
05:44:34 <quicksilver> it can break referential transparency, if it has a bug in it
05:44:38 <quicksilver> but I don't think it can break the runtime
05:44:47 <malcolmw> vincenz: want me to edit my blog post?
05:44:53 <fasta> RyanT5000: PLT already contains such an environment
05:45:01 <RyanT5000> SamB: yes, i like sandboxes :P
05:45:01 <vincenz> malcolmw: sure :)
05:45:07 <dcoutts_> quicksilver: if it has a bug in it, it can do almost anything bad :-)
05:45:28 <vincenz> malcolmw: or I can place it in a comment
05:45:36 <SamB> quicksilver: it's as bad as libpng if it has a bug!
05:45:37 <RyanT5000> fasta: i want it for haskell :P
05:45:51 <SamB> or libz
05:46:03 <fasta> RyanT5000: compile Scheme to Haskell :)
05:46:28 <fasta> Or Haskell to Scheme
05:47:15 <RyanT5000> lol
05:47:27 <RyanT5000> i'd rather just trust hplugin
05:47:34 <vincenz> fasta: or assembly to haskell
05:47:49 <SamB> also read "reflections on trusting trust"
05:48:00 <fasta> SamB: me?
05:48:04 <RyanT5000> vincenz: oooh, then i can write a haskell to assembly JIT compiler to go with it!
05:48:04 <SamB> and consider that GHC was recently miscompiling itself 
05:48:11 <SamB> fasta: not you
05:48:20 <malcolmw> vincenz: OK, blog edited, + you made a comment
05:48:21 <RyanT5000> hm
05:48:27 <vincenz> malcolmw: ooh thanks :)
05:49:40 <malcolmw> vincenz: btw, if you pull from the hscolour repo, you will find conflicts, since I needed to re-roll your patch a bit
05:49:58 <vincenz> malcolmw: ok
05:50:08 <vincenz> malcolmw: naminig?
05:50:13 <malcolmw> vincenz: so you might need to unpull, then pull again.  (if you are bothered about keeping up to date anyway)
05:50:33 <vincenz> well I'll prolly have to install it somewhere saner than in the subdirectory of a blogpost
05:51:54 <malcolmw> vincenz: name fixed.  Also, I changed the name of the flag from -lhs to -lit (with a corresponding -nolit)
05:52:43 <malcolmw> vincenz: and all fragments are now partial, since I didn't see how making the first one non-partial could possibly be correct
05:54:01 <RyanT5000> is there any reason to use IArray or even Monad style higher-kind class parameters anymore, given multiparameter classes with fundeps?
05:54:56 <vincenz> malcolmw: makes sense
05:55:14 <RyanT5000> i mean i could always instance Monad (m a) a, right?
05:56:15 <quicksilver> RyanT5000: fundeps are nasty and are going to be removed ;)
05:56:32 <RyanT5000> quicksilver: oh
05:56:38 <quicksilver> I do take your point
05:56:46 <quicksilver> although to me higher-kinded classes make good sense
05:56:52 <quicksilver> ('class families')
05:56:57 <vincenz> malcolmw: I hope the remaining code was clean enough :P
05:57:21 <RyanT5000> how do i express this, then: class Index i q k v; in particular, i don't know what instances will require of v
05:57:34 <malcolmw> vincenz: I tidied a little, but not much.
05:57:53 <RyanT5000> often they'll require Ord, but they might not use it at all or they might need something more powerful than Ord (like a distance function)
05:58:15 <RyanT5000> are associated types in or going in?
05:58:22 <quicksilver> RyanT5000: you can't parameterise classes over classes
05:58:32 <quicksilver> RyanT5000: so there isn't a totally straightforward answer
05:58:41 <RyanT5000> quicksilver: you can, effectively, with the way i've been doing it
05:58:52 <quicksilver> associated types: if anybody actually manages to work out the details, they're expected to go in
05:58:53 <RyanT5000> it just gets required in the instance
05:59:09 <quicksilver> that's not parameterised
05:59:16 <RyanT5000> i didn't say parameterized
05:59:19 <quicksilver> I did!
05:59:29 <Philippa> presumably fundeps aren't going /out/ until ATs are in?
05:59:30 <vincenz> malcolmw: alright
05:59:36 <RyanT5000> right
05:59:43 <vincenz> Philippa: ATs solve fundeps?
05:59:44 <RyanT5000> all i'm asking is what's the kosher way to achieve that
05:59:46 <edward1> *Control.Monad.Parameterized> Just 12 >>= \x -> [x*1,x*2]                     ===> [12,24]     neat my toy parameterized monads work. too bad they seem to have bad type inferrence properties
05:59:54 <vincenz> Philippa: /solve/subsume
05:59:57 <quicksilver> RyanT5000: well, as I said, it's tricky
06:00:10 <RyanT5000> but it's so simple with fundeps :(
06:00:12 <Philippa> vincenz: with the right extensions, yes
06:00:28 <quicksilver> RyanT5000: normally you have to have an extra parameter which is the 'blob' of operations you can do on v
06:00:40 <quicksilver> RyanT5000: or you just defer it entirely until the instance
06:00:41 <Philippa> just use fundeps for now, really
06:00:50 <quicksilver> and it just becomes a 'property' of your instance
06:00:52 <RyanT5000> hm
06:00:58 <RyanT5000> yeah that's how i've been doing it
06:01:05 <RyanT5000> but typically i end up needing to put in fundeps
06:01:12 <RyanT5000> or it complains about my instances being undecidable, etc.
06:01:15 <Philippa> worry about converting when fundeps go - by then, doing it'll be well understood
06:01:18 <quicksilver> fundeps are only ever there to help type inference
06:01:21 <quicksilver> I think?
06:01:32 <quicksilver> can they actually resolve undecidability?
06:01:58 <RyanT5000> actually i'm not sure about that, but i just know that they often get rid of type errors
06:01:59 <Philippa> yes. The question is "which instance do I pick?" - cutting out possibilities you don't want can make it decidable
06:02:17 <RyanT5000> honestly i've never paid that much attention :P
06:02:20 <quicksilver> My understanding was that ATs don't entirely subsume fundeps, but they subsume "the bits people normally use"
06:02:32 <quicksilver> Yeah. I normally leave fundeps out, in a first draft
06:02:43 <quicksilver> then I plug them in only if I discover type inference is needing too many type annotations
06:02:49 <quicksilver> and only then, if I can see an elegant solution :)
06:03:11 <Philippa> quicksilver: there're AT-flavoured extensions that nail the lot AFAIK
06:03:18 <Philippa> though I could be wrong
06:03:36 <quicksilver> Philippa: ah, OK. Maybe I was thinking of a less ambitious proposal
06:03:53 <quicksilver> Philippa: I gather they've turned out harder to implement than expected
06:04:08 <Philippa> I'm probably a bit behind myself, FWIW
06:04:31 <edward1> *Control.Monad.Parameterized> [1,3,4] >>= \x -> Just 23        [23,23,23]     -- now to figure out other weird combinations
06:04:31 <Philippa> that doesn't surprise me :-(
06:06:10 * quicksilver is disappointed that there weren't any interesting comments on his monad-threading post.
06:09:16 <hpaste>  wli pasted "bijection between rationals and integers" at http://hpaste.org/1633
06:10:27 * wli solved that, not that it's what he actually needs to get done.
06:12:10 <edward1> @pl bind m k = Sec . runSec . k $ runSec m
06:12:11 <lambdabot> bind = flip ((Sec . runSec) .) . runSec
06:12:14 <edward1> blech
06:12:48 <vininim> mm this icpfcontest just receives submissions eletronically?
06:13:02 <RyanT5000> vininim: seems so
06:14:35 <RyanT5000> if you have default functions in a class that are mutually recursive, will the compiler warn if you don't override some of them?
06:14:58 <RyanT5000> i.e.: a == b = not (a /= b) ; a /= b = not (a == b)
06:15:18 <EvilTerran> you'll get a loop exception at runtime, iirc
06:15:24 <RyanT5000> lame
06:15:40 <RyanT5000> lame of ghci to not solve the halting problem
06:15:44 <RyanT5000> er, ghc
06:15:46 <RyanT5000> :P
06:15:53 <scook0> it really ought to be at least declarable, though
06:15:59 <RyanT5000> yeah
06:16:17 <RyanT5000> it definitely could check for circular dependencies
06:16:32 <RyanT5000> if you said "these things shouldn't be circular"
06:16:32 <quicksilver> that's a feature
06:16:38 <RyanT5000> really?
06:16:38 <quicksilver> (circular default methods)
06:16:49 <quicksilver> the idea is you can implement whichever is most efficient for your instance
06:16:54 <RyanT5000> ah ok
06:16:55 <quicksilver> you can choose how to 'break the cycle'
06:16:58 <RyanT5000> so it *is* ok
06:16:59 <quicksilver> and have the others filled in
06:17:00 <scook0> sure, but ideally it should warn you if you don't break the cycle at all
06:17:15 <quicksilver> scook0: it doesn't warn you if you type f = undefined...
06:17:17 <quicksilver> (this is the same)
06:17:31 <RyanT5000> surely it wouldn't be a feature if it didn't check for circularity :P
06:17:41 <scook0> quicksilver: sure, it's not detectable in the general case
06:17:51 <scook0> but a heuristic warning would be "nice-to-have"
06:17:57 <quicksilver> maybe it would be nice to catch easy cases
06:18:00 <vininim> ie. deriving and defining one specific case?
06:18:01 <RyanT5000> scook0: yeah it is detectable
06:18:21 <RyanT5000> it doesn't need to detect actual recursion
06:18:27 <RyanT5000> just circular dependency
06:19:00 <RyanT5000> if you assume that default instances should never depend on themselves in a circle
06:19:08 <scook0> is circular dependency guaranteed to actually be a problem?
06:19:18 <scook0> (though if it's an optional warning, that doesn't really matter)
06:19:19 <vininim> well, a == b = not (a /= (b - 1))
06:19:30 <opqdonut> scook0: i think the problem is that ghc can't cope with it
06:19:36 <RyanT5000> yeah i suppose you could put a meaningful function in there
06:20:00 <RyanT5000> scook0: yeah i guess you are right
06:20:28 <scook0> opqdonut: what are you saying it can't cope with?
06:20:29 <RyanT5000> if someone implements a real recursion with a base case, it could be OK, despite the fact that it's a default function
06:20:41 <quicksilver> well yes
06:20:44 <quicksilver> that's the halting problem :P
06:20:55 <quicksilver> that's the point I thought you were just making a few lines up
06:21:21 <vininim> not really
06:21:30 <vininim> halting problem only works for turing complete systems
06:21:31 <scook0> well, the fact that it doesn't seem to have been done yet (even partially) suggests that it's Hard, or at least Nontrivial
06:21:49 <vininim> if a and b is restricted to values and there are some rules in the definitions it might be not turing complete
06:22:09 <vininim> (ie i'm being general and not really adding anythign of value to the discussion =p )
06:22:29 <quicksilver> however, there are no restrictions, and no rules
06:22:35 <quicksilver> any haskell expression is allwoed :P
06:24:32 <scook0> ideally, it should at least be possible to declare what's necessary for cycle-breaking, and have the compiler enforce that on the client -- but I'm not volunteering to implement it ;)
06:24:54 * SamB wonders if GHC currently discovers any <<Loop>> exceptions at compile time
06:24:58 <scook0> (i.e. a compiler-checked version of the documentation that already exists in many cases)
06:25:30 <SamB> scook0: I don't think documentation is going to do the job somehow ;-)
06:25:45 <RyanT5000> have anonymous existentials been added?
06:25:53 <RyanT5000> i know 10 months ago they were being discussed
06:26:02 <SamB> added to what?
06:26:03 <scook0> SamB: isn't that my point?
06:26:12 <RyanT5000> SamB: to ghc
06:26:27 <RyanT5000> they were illegal or there was no syntax at some point, or something
06:26:31 <SamB> RyanT5000: can they be?
06:26:38 <quicksilver> RyanT5000: no, they have not
06:26:43 <SamB> it's not the syntax that is the problem, in my understanding
06:26:48 <quicksilver> and as far as I am aware, there is no proposal to add them
06:26:52 <RyanT5000> ah ok
06:27:00 <quicksilver> SamB: I disagree. in my opinion it is the syntax
06:27:15 <quicksilver> There was a proposal in the original modules paper
06:27:16 <SamB> quicksilver: how would they be implemented then?
06:27:22 <quicksilver> I think it used 'let open s'
06:27:29 <quicksilver> and s becomes your 'existential witness'
06:27:35 <quicksilver> don't have the paper to hand
06:27:47 <quicksilver> SamB: basically existentials currently use the constructor as a 'marker'
06:27:58 <SamB> quicksilver: oh, true...
06:28:01 <wli> roconnor: http://holomorphy.com/~wli/Stern-Brocot/
06:28:02 <lambdabot> Title: Index of /~wli/Stern-Brocot
06:28:02 <quicksilver> SamB: so the type-checker/compiler can enforce the encapsulation
06:28:05 <SamB> okay, so syntax is a bit of the issue
06:28:10 <quicksilver> SamB: in principle you could avoid the constructor
06:28:18 <quicksilver> and just have some 'syntax' which has the same function as the constructor
06:28:25 <quicksilver> to open the existential
06:28:29 <quicksilver> (and, indeed, to close it)
06:29:25 <RyanT5000> i think what i saw was basically a keyword constructor/deconstructor called exist
06:29:34 <RyanT5000> (as a proposal)
06:29:39 <quicksilver> http://hackage.haskell.org/trac/haskell-prime/wiki/ExistentialQuantification
06:29:44 <SamB> so, okay, syntax is an issue. right.
06:29:47 <lambdabot> Title: ExistentialQuantification - Haskell Prime - Trac, http://tinyurl.com/y6bk55
06:29:54 <quicksilver> there some some discussions there
06:29:56 <wli> I'm so lame. I couldn't figure out how the heck to construct a memo table for this garbage.
06:30:00 <SamB> but how would it be represented?
06:32:48 <RyanT5000> incidentally, that last proposal on that page would be confusing as hell to newbs
06:33:07 <RyanT5000> (automatically making an existential datatype named C for each class named C)
06:33:20 <SamB> true
06:33:22 <RyanT5000> they already have a hard enough time understanding the difference between classes and types
06:33:25 <SamB> yeah
06:33:39 <RyanT5000> especially post-OOP-indoctrination
06:33:39 <SamB> you see them saying Num -> Num -> Num enough as it is ;-)
06:33:44 <RyanT5000> yeah
06:34:04 <SamB> it would be nice if that continued to be totally impossible ;-)
06:34:14 <RyanT5000> yeah
06:34:32 <RyanT5000> well they'd start producing totally annoying code
06:35:01 <RyanT5000> even if Num -> Num -> Num were made to work somehow
06:35:06 <SamB> it wouldn't
06:35:11 <RyanT5000> wellllll
06:35:14 <SamB> but having a Num type would not help a bit
06:35:16 <RyanT5000> if everything were existential
06:35:24 <RyanT5000> you could do lots of coercion :P
06:35:42 <SamB> ... you aren't allowed to open two existentials and expect them to have the same type inside ;-)
06:35:46 <RyanT5000> right
06:35:51 <RyanT5000> but you can coerce them both to the same type :)
06:36:01 <RyanT5000> e.g.: fromIntegral
06:36:15 <roconnor> wli: You should be able to natRat ``better''
06:36:27 <roconnor> by finding the largest power of two dividing a number
06:36:27 <RyanT5000> i expect we'd see lots of Integers packaged up in Integrals
06:36:37 <roconnor> and if odd, taking it's bitwise complement
06:36:55 <roconnor> and return  recip of the recursive call
06:42:25 <wli> roconnor: I'm not sure what you mean there.
06:42:33 <SamB> RyanT5000: not with Num you can't
06:43:40 <RyanT5000> SamB: yeah, bad example
06:43:46 <wli> roconnor: I'm not sure of any useful ways to iterate \x -> 2*x + 1 or \x -> 2*x + 2
06:43:59 <wli> roconnor: Never mind, I'm dumb.
06:45:01 <wli> r_{n+1} = 2*r_n + 1 has solution r_n = 2^n - 1, r_{n+1} = 2*r_n + 2 has solution 2^n - 2
06:45:43 <fasta> Is there a way I can only type check the code, but skip the code generation in GHC?
06:46:14 <TSC> -fno-code
06:47:24 <roconnor> TSC: cool!
06:47:56 <vincenz> won't laziness mean that due to the fact we're not generating code, typechecking will not occur either?
06:48:00 <vincenz> :
06:48:02 <vincenz> :P
06:48:06 <wli> woops, r_0 needs factoring in.
06:48:20 <TSC> Printing "no type errors" is a side effect that forces it (:
06:48:44 <vincenz> bah, side-effects
06:48:47 <vincenz> :P
06:50:53 <wli> r_{n+1} = 2*r_n + 1 has solution r_n = (r_0+1)*2^n - 1, r_{n+1} = 2*r_n + 2 has solution (r_0+2)*2^n - 2
06:51:00 <wli> roconnor: Fixed.
06:52:17 <hpaste>  wli annotated "bijection between rationals and integers" with "an improvement on ratNat" at http://hpaste.org/1633#a1
06:52:42 <wli> roconnor: How does that look?
06:55:26 <roconnor> wli: well, it's not what I was getting at, but I'm sure it's great none the less :)
06:55:55 <wli> roconnor: Okay, I'm not sure what you had in mind.
06:58:58 <roconnor> well natRat processes only one bit at a time, while ratNat process alot at once.
06:59:02 <roconnor> it seems unfair
07:00:09 <wli> roconnor: Okay, for the even case it's obvious how to get the transformation done.
07:00:40 <roconnor> wli: for the flip side you need to take the bitwise complement
07:00:57 <wli> roconnor: I don't see how that helps offhand.
07:02:27 <roconnor> flipping the bits make the odd number even
07:02:36 <roconnor> and you can take out a power of two again
07:03:23 <wli> I don't see how that recovers anything meaningful there. There's not a closed form for the linear fraction transformation repeatedly composed that I can tell.
07:03:55 <fasta> Hmm, it appears typechecking takes most of the time anyways.
07:04:38 * LeCamarade is sick of getting this `rigid variable' error.
07:04:56 <LeCamarade> It never seems to make sense at all, ever.
07:05:09 <fasta> Hmm, it appears I just called it wrongly. 
07:05:16 <edward1> does the do-sugar ever actually make use of return?
07:05:18 <fasta> Now, it goes fast :)
07:05:21 <Philippa> LeCamarade: read the 'wobbly types' paper? It might help
07:05:34 <LeCamarade> ,,|,, rigid variable error.
07:05:43 <LeCamarade> Philippa: Link, please?
07:06:02 <Philippa> LeCamarade: I'll only bung "wobbly types" into google. SPJ's one of the authors
07:06:56 <LeCamarade> @gongel wobbly type
07:06:56 <lambdabot> Unknown command, try @list
07:07:11 * LeCamarade goes to browser.
07:07:28 <LeCamarade> Seen it.
07:08:05 <mnislaih> what is the right* way to launch lambdabot via a remote session
07:08:13 <mnislaih> does it have a daemon-like mode ?
07:09:42 <wli> roconnor: hmm, no, it doesn't look like there's an obvious power-of-two simplification to make here. 
07:10:13 <wli> roconnor: if n is divisible by 4 the nextargument is even
07:11:04 <wli> roconnor: if n is divisible by 4 the next argument is odd, rather
07:11:54 <oerjan> edward1: no, see http://haskell.org/onlinereport/exps.html#sect3.14
07:11:55 <lambdabot> Title: The Haskell 98 Report: Expressions
07:12:17 <wli> You need \n -> (n `div` 2) - 1 to produce even numbers up to some point.
07:13:31 <fasta> Failed to load interface for <foobar>. Actually this typechecking feature doesn't appear to work... it only works directly after a build.
07:13:53 <wli> So n/2 - 1 = 2*k, n = 2*k+2
07:14:12 <vininim> uh.. what is the syntax for the bottom value?
07:14:19 <pjd> undefined?
07:14:25 <wli> So n = (k+2)*2^n - 2
07:14:39 <fasta> vininim: undefined or error "undefined"
07:14:48 <pjd> @src undefined
07:14:48 <lambdabot> undefined =  error "Prelude.undefined"
07:15:03 <pjd> undefined = undefined also works
07:15:12 <fasta> pjd: "works"
07:15:15 <oerjan> vininim: any expression which never gives a value, such as those mentioned or perhaps let x = x in x
07:15:18 <pjd> fasta: heh
07:15:35 <vininim> :t undefined
07:15:37 <lambdabot> forall a. a
07:15:56 <vincenz> > fix fix
07:15:57 <vininim> k, thanks
07:15:57 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -> a
07:15:57 <lambdabot>     Probabl...
07:16:15 <oerjan> :t fix
07:16:17 <lambdabot> forall a. (a -> a) -> a
07:16:23 <wli> roconnor: So you find the highest power of 2 dividing n + 2, say 2^m || n where || is where a power is the highest power possible. Then (n `div` 2^m) - 2 is the next argument
07:16:50 <oerjan> > fix id
07:16:52 <lambdabot>  Exception: <<loop>>
07:17:49 <Jaak> > fix fix -- gasp!
07:17:50 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -> a
07:17:50 <lambdabot>     Probabl...
07:18:11 <wli> roconnor: ((n + 2) `div` 2^m) - 2 rather
07:18:32 <wli> roconnor: For the other case it's ((n + 1) `div` 2^m) - 1
07:19:25 <roconnor> wli: I'm suggesting for the othercase you return "recip (natRat (complment n))"
07:19:45 <wli> roconnor: That does not appear to be correct.
07:19:45 <roconnor> wli: but maybe this isn't right
07:19:49 <roconnor> :)
07:19:51 <roconnor> indeed
07:20:12 <roconnor> probably something strinage like (compliment (n+1)) - 1
07:20:15 <roconnor> strange
07:21:28 <wli> More likely you'll need a closed form for repeatedly doing x/(x+1)
07:21:49 <CosmicRay> Igloo: are you here?
07:22:04 <roconnor> wli: nah, some sort of bitwise complement is the way to go :_
07:22:06 <roconnor> :)
07:22:22 <wli> roconnor: It's not going to work.
07:23:33 <wli> roconnor: define the bitwise complement of an arbitrary-precision number, for one.
07:24:01 <CosmicRay> @seen igloo
07:24:01 <lambdabot> igloo is in #happs, #haskell-soc, #darcs, #ghc and #haskell. I last heard igloo speak 2h 1m 1s ago.
07:24:13 <roconnor> wli: hmmm
07:24:15 <CosmicRay> arjanoosting: are you here?
07:24:28 <roconnor> you make a good point
07:25:36 <CosmicRay> @seen arjanoosting
07:25:36 <lambdabot> arjanoosting is in #haskell. I don't know when arjanoosting last spoke.
07:26:45 <pjd> wli: what are you using them Stern-Brocot numbers for?
07:28:10 <wli> pjd:Not sure, really.
07:35:29 <wli> n/2 - 1 = 2*k -> n = 2*k+2 -> r_{t+1} = 2*r_t + 2 -> r_t = (r_0+2)*2^t - 2 -> n = (k+2)*2^m - 2 -> k = (n+2)/2^m - 2, it all works... what went wrong here.
07:43:42 <wli> roconnor: duh,  iterate (\z -> 1/(1+1/z)) x !! n = 1/(n + 1/x)
07:46:09 * ski wonders what wli and roconnor is up to
07:46:31 <wli> ski: Continued fractions.
07:46:43 <wli> ski: http://hpaste.org/1633
07:47:43 <ski> oh, stern-brocot tree
07:48:08 <wli> ski: Bijection between rationals and integers, computed rapidly.
07:48:52 <Igloo> CosmicRay: ?
07:49:41 <roconnor> > let rationals = 1::concat [[x+1,x/(x+1)]|x<-rationals] in rationals::[Rational]
07:49:41 <lambdabot>  Parse error
07:49:46 <roconnor> > let rationals = 1:concat [[x+1,x/(x+1)]|x<-rationals] in rationals::[Rational]
07:49:48 <lambdabot>  [1%1,2%1,1%2,3%1,2%3,3%2,1%3,4%1,3%4,5%3,2%5,5%2,3%5,4%3,1%4,5%1,4%5,7%4,3%7...
07:49:50 <CosmicRay> Igloo: back in a moment, on the phone
07:49:54 <roconnor> ski: :)
07:51:34 * roconnor wonders if Small Check needs this list.
07:53:42 <araujo> morning
07:57:07 <roconnor> @where smallcheck
07:57:07 <lambdabot> http://www.cs.york.ac.uk/fp/smallcheck0.2.tar
07:57:32 <Jaak> > let rats = 1:(rats >>= (\x->[x+1,x/(x+1)])) in rats :: [Rational]
07:57:33 <lambdabot>  [1%1,2%1,1%2,3%1,2%3,3%2,1%3,4%1,3%4,5%3,2%5,5%2,3%5,4%3,1%4,5%1,4%5,7%4,3%7...
07:59:39 <wli> I'm obviously shooting for a higher order of efficiency here.
08:00:43 <roconnor> Jaak: I've toyed with variations like that, but I'm not sure I like any of them better.
08:00:45 <SamB> hmm, where would the modules in the Strafunski StategyLib package go...
08:02:02 * SamB downloaded 4.0 since 5.0 is missing :-(
08:04:05 <Shish> noob question: why does "foo a = a" work, but not "foo a = do // print a // return a"? I'm looking for a way of seeing how far my program has gone through the input file, and printing "I am currently processing <a>" seems like a sensible way...
08:04:23 <quicksilver> Shish: because you've changed the type
08:04:33 <wli> I think I nailed it for the even case.
08:04:40 <quicksilver> Shish: as soo as you put in the do/print, it's gone to an IO type
08:04:40 <ski> @type let foo a = a in foo
08:04:42 <lambdabot> forall t. t -> t
08:04:47 <ski> @type let foo a = do print a; return a in foo
08:04:48 <lambdabot> forall a. (Show a) => a -> IO a
08:05:12 <quicksilver> I'd do your printing out in the enclosing loop
08:05:14 <Jaak> > fix ((1:).(>>=(\x->[x+1,x/(x+1)]))) :: [Rational] -- okay, enough
08:05:16 <lambdabot>  [1%1,2%1,1%2,3%1,2%3,3%2,1%3,4%1,3%4,5%3,2%5,5%2,3%5,4%3,1%4,5%1,4%5,7%4,3%7...
08:05:17 <quicksilver> which is presumably an IO loop anyway
08:05:22 <quicksilver> if it's reaading from a file
08:05:32 <ski> @type let foo a = Debug.Trace.trace (show a) a in foo -- Shish
08:05:32 <roconnor> @bab nl en biefstuk
08:05:33 <lambdabot> forall a. (Show a) => a -> a
08:05:35 <lambdabot>   beefsteak
08:05:50 <wli> Testing for integers up to 2^20
08:06:00 <Shish> I'm calling foo as "map foo <an array of input words>"
08:06:03 <ski> Shish : in case you want this for debugging, i.e. ..
08:06:18 <wli> roconnor: I'll get the odd case nailed down and post.
08:06:26 <ski> interesting how 'rationals' go breadth-first down the tree
08:06:42 <vincenz> roconnor: biefstuk friet
08:06:43 <Baughn> Shish: List, not array. You should read some tutorial about IO, but Debug.Trace.trace would work
08:06:56 <Baughn> ski: Given that the tree is infinitely deep..
08:06:56 <vincenz> roconnor: biefstuk = steak
08:07:15 <roconnor> perfect
08:07:33 <ski> Baughn : .. yes ?
08:08:03 <Baughn> ski: No, just that. If it did depth-first, it wouldn't be useful.
08:08:22 <roconnor> vincenz: they are on sale
08:08:25 <quicksilver> I personally wouldn't recommend Debug.Trace to a new haskell programmer
08:08:29 <quicksilver> (or, actually to anyone)
08:09:17 <CosmicRay> Igloo: still around?
08:09:20 <Igloo> yup
08:09:43 <vincenz> roconnor: spiffy
08:10:06 <Philippa> quicksilver: I've used it and found it helpful in code that wasn't about to go monadic
08:10:25 <CosmicRay> Igloo: great.  I have a problem that is really ticking me off lately.  every time I build a new missingh, I have to rebuild a ton of other packages, and update the dependency info in them for the new package
08:10:33 <CosmicRay> Igloo: can haskell-utils help me at all with this?
08:10:42 <Philippa> however, you have to know what you're doing with it - you have to understand your haskell implementation's execution model
08:10:51 <Igloo> CosmicRay: What do you mean by "dependency info"?
08:11:02 <Igloo> CosmicRay: It doesn't handle version numbers yet, but it will do soon
08:11:14 <Igloo> CosmicRay: But it does handle cabal package deps by package name
08:11:34 <ski> > let positives = [] : liftM2 (\xs x -> xs ++ [x]) positives [0,1] in positives
08:11:36 <lambdabot>  [[],[0],[1],[0,0],[0,1],[1,0],[1,1],[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],...
08:11:44 <ski> > let positives = [] : liftM2 (\x xs -> [x] ++ xs) [0,1] positives in positives
08:11:44 <CosmicRay> Igloo: for the programs or libraries that use missingh, I have to update the build-dep info to make sure that the autobuilders build them only against the new package, and ideally should also update the binary dep info so that all the packages have to be updated at once
08:11:45 <lambdabot>  [[],[0],[0,0],[0,0,0],[0,0,0,0],[0,0,0,0,0],[0,0,0,0,0,0],[0,0,0,0,0,0,0],[0...
08:12:02 <ski> Baughn : i was pondering the difference betwixt those two
08:12:52 <pastorn> @paste
08:12:53 <lambdabot> Haskell pastebin: http://hpaste.org/new
08:13:33 <quicksilver> Philippa: agreed on both counts
08:13:34 <ski> (i.e. associating the appendings the different way, becomes difference between depth vs. breadth)
08:14:01 <Igloo> CosmicRay: I hope to fix that RSN. Currently it generates a dep on libghc6-foo-dev, it needs to generate one on libghc6-foo-dev (= $installed_version)
08:14:02 <CosmicRay> Igloo: what do you mean by handling cabal deps?  Does it automatically put libghc6-blah-dev lines in debian/control based on the cabal deps?
08:14:02 <quicksilver> Philippa: I don't recommend it to new programmers because it requires them to understand model in more detail than they would normally need to, to write the program they're trying to write
08:14:08 <pastorn> :type catch
08:14:09 <Igloo> CosmicRay: Yes
08:14:16 <pastorn> @type catch
08:14:18 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
08:14:21 <CosmicRay> Igloo: argh, phone again...
08:14:40 <pastorn> @hoogle (IOError -> IO a)
08:14:41 <lambdabot> Prelude.ioError :: IOError -> IO a
08:15:35 <Philippa> quicksilver: I think that depends. The recommendation does need to come with a big "but evaluation doesn't necessarily happen when you expect" warning
08:15:47 <quicksilver> Philippa: yeah
08:16:02 <quicksilver> Philippa: I find it's more profitable to put the effort into learning how to use the REPL
08:16:12 <quicksilver> Philippa: to, e.g., evaluate subexpressions selectively
08:16:24 <Philippa> I've had plenty of cause to use the two in tandem
08:16:27 * quicksilver nods
08:17:48 <CosmicRay> Igloo: back.  that's a neat trick.  which program does that?  and where can I read about it?
08:18:08 <CosmicRay> Igloo: I read all three manpages for the programs in the package and I can't figure out really the details of what they do...
08:20:39 <pastorn> how much reflection do haskell have? can i parse a file and withot recompilation have new datatypes?
08:20:57 <CosmicRay> hey bos
08:21:05 <pastorn> (as instances of one already existing datatype)
08:21:18 <hpaste>  wli annotated "bijection between rationals and integers" with "improvement to natRat" at http://hpaste.org/1633#a2
08:21:44 <Igloo> CosmicRay: Read my recent mail to the debian-haskell list
08:21:53 <wli> roconnor: How does that look?
08:21:59 <RyanT5000> pastorn: you can do some things like that, but not in the same way as you would normally do it in a dynamically-typed reflective language
08:22:34 <pastorn> RyanT5000: how do I go about doing this?
08:22:48 <CosmicRay> Igloo: nice.
08:23:17 <RyanT5000> pastorn: e.g.: there's Data.Typeable and Data.Dynamic, which let you deal with dynamic typing; if you dynamically load a library, i presume you can use its datatypes
08:23:56 <quicksilver> pastorn: haskell isn't genuinely reflective, but it has a bunch of remarkably powerful metaprogramming features which give you most of the power of reflection
08:24:12 <quicksilver> you can't quite get away from the underlying facts that the haskell compiler erases types, though
08:24:30 <RyanT5000> i dunno, Typeable comes close
08:24:36 <pastorn> ah, so they're just there for the type-checker?
08:24:41 <RyanT5000> basically
08:24:55 <pastorn> seems reasonable
08:25:10 <SamB> pastorn: but the "typechecker" can give you more than just checked types ;-)
08:25:15 <quicksilver> dynamically loading a library isn't easy
08:25:20 <quicksilver> hs-plugins was not trivial to write
08:25:24 <quicksilver> but, it has been written :)
08:25:29 <RyanT5000> right :)
08:25:34 <quicksilver> it has a reputation as being hard to compiler, though
08:25:55 <quicksilver> basically, you can't "directly" use "new types"
08:26:00 <pastorn> yeah... well i'm working on this thing for work and I'm getting kinda tired of having Strings everywhere
08:26:12 <quicksilver> (because what type would you have given the function that was supposed to be using them?)
08:26:21 <quicksilver> but you can certainly call code which uses them
08:26:56 <pastorn> quicksilver: i was thinking of addingt to something like this
08:27:04 <RyanT5000> quicksilver: btw, it seems that any time you have a function in a class whose type signature doesn't include all the parameters of the class and from that function you call another function in the class, you get an error
08:27:26 <RyanT5000> which fundeps fix
08:27:36 <bos> CosmicRay: hiya
08:27:44 <pastorn> data Foo = Bar A Int | Bar A Int | Bar 'whaddeva' Int
08:28:25 <bos> CosmicRay: are you still planning to go to OSCON?
08:28:34 <CosmicRay> bos: yes
08:28:38 <pastorn> but then i would need to remake all my pattern matching functions...
08:28:46 <quicksilver> RyanT5000: you don't have to add fundeps, though
08:28:51 <quicksilver> RyanT5000: you can just add a type annotation
08:28:59 <wli> roconnor: I'm not entirely sure that using bisection search to find the highest feasible power-of-two divisor of a number is the best way to go about it. I have to wonder if there isn't a Data.Bits function that would be better.
08:29:06 <quicksilver> RyanT5000: (e.g. you can make the function itself polymorphic, if that's your intent)
08:29:07 <ihope> Is there, in fact, an elegant data declaration in Haskell that defines a lambda expression?
08:29:22 <RyanT5000> quicksilver: it isn't
08:29:30 <RyanT5000> it's an update function
08:29:35 <quicksilver> RyanT5000: well basically:
08:29:49 <quicksilver> RyanT5000: in the absence of type classes and higher-rank polymorphism, type inference is complete
08:29:52 <RyanT5000> similar to Data.Map.map (which doesn't depend on the key type)
08:29:52 <quicksilver> RyanT5000: and that's nice
08:29:57 <wli> roconnor: I don't see a ffs-like function, though.
08:30:04 <quicksilver> RyanT5000: certain kinds of polymorphism make type inference fail
08:30:07 <RyanT5000> yeah
08:30:16 <quicksilver> RyanT5000: that doesn't matter, it just means you need to annotate with explicit types
08:30:24 <quicksilver> RyanT5000: normally I'm quite happy to do that, myself
08:30:29 <oerjan> ihope: what do you mean?
08:30:33 <quicksilver> fundeps are just one way of 'giving the type checker another hint'
08:30:39 <quicksilver> so it can do the inference after all
08:31:07 <ihope> oerjan: well, something like "data Term = Apply Term Term | Lambda Integer Term | Variable Integer" allows you to reference variables that don't exist.
08:31:44 <pastorn> RyanT5000: Data.Map is for trees, right?
08:32:04 <oerjan> ihope: so you want a type that only gives closed terms?
08:32:14 <ihope> oerjan: yup.
08:33:28 <quicksilver> ihope: what would you expect the subterms to be?
08:33:33 <quicksilver> ihope: IYSWIM...
08:33:48 <quicksilver> ihope: any structure which is, it self, valid has subterms which aren't valid in isolation
08:33:50 <RyanT5000> god i love haskell's type system
08:34:03 <RyanT5000> i can write code after being awake for 24 hours and still have it be (usually) bug-free
08:34:24 <Jaak> > done -- what's that
08:34:26 <lambdabot>  <[Char] -> Int -> [[[Char]]] -> IO [Char]>
08:34:37 <ihope> Yeah, Epigram-type stuff is certainly more powerful than Haskell in some respects...
08:34:52 <wli> ihope: Cayenne?
08:34:54 <ihope> Epigram isn't Turing-complete or usable or anything, though, I think, so... that's a weakness.
08:35:04 <ihope> Cayenne?
08:35:04 <crazy_coder> hello everyone
08:35:09 <ihope> @index done
08:35:09 <lambdabot> bzzt
08:35:15 <crazy_coder> Is there anything wrong with this : 
08:35:17 <crazy_coder> getNumber :: IO Int
08:35:17 <crazy_coder> getNumber = do
08:35:17 <crazy_coder> 	    putStrLn "Enter the number of sticks to be picked"
08:35:17 <crazy_coder> 	    no <- getLine
08:35:17 <crazy_coder>             return no
08:35:24 <wli> ihope: reputedly "hotter than Haskell"
08:35:43 <crazy_coder> return is exactly below no 
08:35:48 <quicksilver> ihope: even epigram can't solve the problem I pointed out, I don't believe
08:35:59 <sjanssen> crazy_coder: you're missing a do
08:36:06 <quicksilver> how can a term have untyped subterms?
08:36:11 <crazy_coder> sjanssen: where ?
08:36:12 <quicksilver> crazy_coder: indentation error
08:36:14 <ihope> crazy_coder: nothing wrong with it that I can see, but you can replace the last two lines with just "getLine", since that'll automatically return.
08:36:18 <quicksilver> crazy_coder: you're mixing tabs and spaces
08:36:24 <quicksilver> crazy_coder: (don't do that!)
08:36:25 <sjanssen> crazy_coder: actually, that's not quite right
08:36:33 <quicksilver> crazy_coder: you have tab + 4 spaces before 'no'
08:36:40 <quicksilver> crazy_coder: and only spaces before 'return'
08:36:49 <sjanssen> ah, that's the ticket
08:37:11 <crazy_coder> so indentation is one problem.Any others ?
08:37:13 <ihope> quicksilver: have Term : Nat -> *, so Term x is a term with access to x variables.
08:37:17 <sjanssen> crazy_coder: tabs are generally not recommended for Haskell source
08:37:18 <ihope> crazy_coder: I think that's all.
08:37:27 <crazy_coder> So what ever is returned is IO Int
08:37:36 <sjanssen> crazy_coder: there is one other problem
08:37:38 <sjanssen> @type getLine
08:37:40 <lambdabot> IO String
08:37:43 <quicksilver> ihope: ah, ok. I understand what you mean now
08:37:46 <crazy_coder> To get an int out of it, I have to use read , right ?
08:37:46 <sjanssen> crazy_coder: getLine returns a String, you want an Int
08:37:50 <sjanssen> crazy_coder: see readLn
08:37:58 <quicksilver> return (read no)
08:38:01 <quicksilver> should also work
08:38:06 <quicksilver> although sjanssen's advice is good
08:38:08 <ihope> @type readLine
08:38:10 <lambdabot> Not in scope: `readLine'
08:38:14 <sjanssen> @type readLn
08:38:16 <lambdabot> forall a. (Read a) => IO a
08:38:19 <ihope> Huh.
08:38:20 <bos> CosmicRay: what days are you planning to be in portland?
08:38:27 <ihope> Well, that'll read automatically.
08:38:31 <quicksilver> ihope: yes, you can do that in haskell too
08:38:33 <quicksilver> ihope: but it won't be fun
08:38:47 <ihope> quicksilver: the dependent typing thing?
08:41:39 <crazy_coder> so I shouldn't have a putStrLn over there ?
08:41:59 <quicksilver> ihope: yeah, you can encode Term : Nat -> * in haskell
08:42:47 <ihope> crazy_coder: the putStrLn looks fine...
08:43:10 <quicksilver> crazy_coder: nothing wrong with the putStrLn
08:43:15 <wli> Well, if the set is denumerable, you can do arithmetic on the type representation too.
08:43:28 <ihope> When you use tabs consistently, does it work?
08:43:44 <crazy_coder> I don't understand, the return type of getNumber is IO Int, now I have a expression which returns IO () , how is that oK then ?
08:44:19 <ihope> crazy_coder: what's the code now?
08:44:36 <ihope> (Also, use a pastebin: http://pastebin.ca/)
08:44:41 <oerjan> crazy_coder: only the last expression in a do needs to be the type of the whole.  The rest just needs to be in the right monad.
08:45:22 <ihope> And it's pretty obvious when it's not in the right monad :-)
08:45:57 <quicksilver> crazy_coder: it's not returning that line
08:45:59 <ihope> foobar = do putStrLn "Hello!"; x <- getLine; Just x
08:46:11 <crazy_coder> what does it mean by 'it should be in the right Monad ' ?
08:46:12 <quicksilver> crazy_coder: the 'return type' only applies to the last line, which is what you actually return
08:46:18 <crazy_coder> Thats where I am stuck
08:46:23 <quicksilver> crazy_coder: in a 'do' expression you have to use one consistent monad
08:46:25 <quicksilver> in your case, IO
08:46:50 <ihope> crazy_coder: if you're using IO, make sure every expression's of an IO type.
08:46:56 <crazy_coder> Oh.... Now I am getting something...
08:47:09 <crazy_coder> Ok
08:47:11 <ihope> So what's the code and why doesn't it work?
08:47:15 <crazy_coder> I'll pastebin it
08:49:02 <hpaste>  crazy_coder pasted "(no title)" at http://hpaste.org/1634
08:49:03 <crazy_coder> Its not at all good code. I am learning it... So be prepared to watch some ugly code.... :(
08:49:45 <oerjan> crazy_coder: you are still mixing spaces and tabs
08:49:55 <crazy_coder> I am doing it in emacs
08:50:03 <crazy_coder> So it's troublesome
08:50:08 <crazy_coder> one more thing
08:50:18 <|Jedai|> crazy_coder: Are you using the haskell mode ?
08:50:20 <crazy_coder> main =  do 	                       putStrLn "Winner is " ++ (show (pickStick 10 User (read getNumber)))
08:50:26 <crazy_coder> Is the correct thing
08:50:26 <ihope> crazy_coder: one problem is "read getNumber". getNumber is an IO thing, remember, so it should go up top before the putStrLn.
08:50:26 <oerjan> crazy_coder: if you _must_ use tabs then make _sure_ they are 8 spaces wide.
08:50:30 <|Jedai|> It shouldn't mix space and tabs
08:50:47 <ihope> And parentheses go around infix operators.
08:51:06 <crazy_coder> Oh Ok
08:51:08 <jedai> check no nosticks = (and [(no>0),(no<4), ((left nosticks no)>1)]) 
08:51:12 <ihope> a b + c d is (a b) + (c d), not a (b + c) d.
08:51:26 <jedai> left seems a bad name...
08:51:34 <ihope> Yeah, and you're doing a lot of "if this then True else False" which could just be "this".
08:51:54 <crazy_coder> I am using emacs for the first time
08:51:55 <ihope> @type and
08:51:58 <lambdabot> [Bool] -> Bool
08:52:01 <crazy_coder> So not used to it...
08:52:06 <ihope> @type (&&)
08:52:08 <lambdabot> Bool -> Bool -> Bool
08:52:14 <crazy_coder> Ok
08:52:15 <oerjan> :t left
08:52:17 <lambdabot> forall (a :: * -> * -> *) b c d. (ArrowChoice a) => a b c -> a (Either b d) (Either c d)
08:52:27 <ihope> Might be a good idea to do foo && bar && baz instead of and [foo, bar, baz], though both will work.
08:52:31 <crazy_coder> oerjan: This is not the standard left
08:52:41 <crazy_coder> I have defined by own left
08:52:45 <crazy_coder> function
08:52:52 <jedai> changePlayer User = Comp 
08:52:52 <jedai> changePlayer _ = User 
08:53:03 <oerjan> crazy_coder: i know, i just wanted to check if you got any confusion.
08:53:11 <ihope> Oh, right, you're also using guards where you could use pattern matching.
08:53:16 <oerjan> but i doubt you are using Arrows :)
08:53:43 <crazy_coder> Let me clarify one thing, apart from IO, i don't know how to use Monads, arrows
08:53:53 <jedai> crazy_coder: defining your own left don't seems a good idea to me, especially if it's longer than what it replace...
08:54:06 <crazy_coder> It shuld have been sticksLeft
08:54:12 <ihope> Yeah, left = (-)
08:54:15 <crazy_coder> But I was a bit lazy there, sorry
08:55:50 <crazy_coder> Ok , as far as style of programming is concerned I have totally messed it up, I know that, but is it right syntactically ?
08:56:47 <jedai> getNumber :: IO Int
08:56:48 <jedai> getNumber = do
08:56:48 <jedai> 	    putStrLn "Enter the number of sticks to be picked"
08:56:48 <jedai> 	    readLn
08:56:49 <ihope> Tabs and spaces and such?
08:56:51 <crazy_coder> Ok one more thing, If I want to convert IO Int to Int what to do ?
08:57:12 <Philippa> you don't
08:57:18 <jedai> crazy_coder: You can't convert IO Int to Int
08:57:18 <crazy_coder> ??
08:57:19 <Philippa> what you /can/ do is this:
08:57:24 <Philippa> do c <- getChar
08:57:34 <crazy_coder> read c
08:57:35 <Philippa>    putChar (frigWith c)
08:57:39 <Philippa> where c :: Char -> Char
08:57:44 <ihope> crazy_coder: put x <- foo in the do block, then use x instead of foo
08:57:58 <Philippa> what that does is it "binds" the result of getChar to c
08:58:05 <ihope> That's what "do x <- getLine; doSomethingWith x" is doing.
08:58:05 <Philippa> it's only visible in the do block though
08:58:09 <jedai> crazy_coder: In other word you can use the Int you got with a IO Int, but only in the monad
08:58:34 <Philippa> (it's syntactic sugar for something more complicated, but you probably don't want to know now)
08:58:44 <crazy_coder> See that I am using this IO Int as a normal Int  in the function pickStick ..
08:58:52 <Philippa> right. So the IO becomes the "outside" of the program
08:59:11 <crazy_coder> So you mean it is Ok or Is it wrong ?
08:59:24 <Philippa> (er, my type annotation earlier is wrong - it's frigWith that should have type Char -> Char, c :: Char)
09:00:21 <jedai> :t read
09:00:22 <lambdabot> forall a. (Read a) => String -> a
09:00:36 <Philippa> crazy_coder: you did the right thing with no/getline and the wrong thing after that
09:00:39 <jedai> Your (read getNumber) is wrong
09:01:00 <jedai> since read take a String, not a IO a
09:01:44 <vincenz> liftM read getNumber
09:01:51 <hpaste>  pastorn pasted "IOError - how do you do it?" at http://hpaste.org/1635
09:02:00 <Philippa> one way to look at it is that you can't leave the result of an IO action as a "temporary" you're passing in to something that just wants a value
09:02:02 <crazy_coder> Philippa: what no/getLine ?
09:02:08 <Philippa> the ones you commented out :-)
09:02:09 <ihope> crazy_coder: yeah. Use <- to "convert".
09:02:11 <jedai> vincenz: No
09:02:16 <vincenz> jedai: yes
09:02:33 <jedai> vincenz: getNumber is IO _Int_
09:02:38 <vincenz> jedai: ah
09:02:42 <Philippa> vincenz: bad pedagogy right now, anyway
09:02:45 <vincenz> ok, then read was even more wrong
09:02:46 <jedai> vincenz: You don't need read
09:02:50 <crazy_coder> Philippa: So in one way i did everything wrong ;)
09:02:56 <vincenz> jedai: I was just pointing to the monadic pat
09:02:58 <vincenz> part
09:03:02 <pastorn> could someone fluent in IOErrors take a look at my paste, please? The documentation is too much for me...
09:03:09 <Philippa> crazy_coder: this is what being a beginner is about, no? :-)
09:03:19 <crazy_coder> yeah
09:03:20 <jedai> vincenz: Yeah, You would have been right if it was an IO String
09:03:43 <schlupping> hey how to start coding in haskell? is it possible to setup eclipse for coding haskell? what about breaktpoints? will they work?
09:03:43 <schlupping> i read some articles about haskell and i want to try it out :) i'm using windows and have no clue of how to use a unix machine. what compilers for windows are there? or interpreters? what differences do they have? is there something like an API for Haskell? where to find?
09:03:44 <vincenz> jedai: getNumber is not in the std... so I just assumed itw as just a fancy name for getChar or something :)
09:03:50 <crazy_coder> But I am sick of being a beginner, I want to write code that works desperately.......:)
09:04:01 <vincenz> code that works desperately?
09:04:08 <LeCamarade> schlupping: GHC works on Windows as well.
09:04:11 <LeCamarade> @where ghc
09:04:11 <lambdabot> http://haskell.org/ghc
09:04:20 <crazy_coder> vincenz: that works correctly, desperately :)
09:04:26 <vincenz> ;)
09:04:33 <jedai> crazy_coder: Just take it one step at a time, try some tutorials, make some exercices
09:04:38 <Philippa> yep, GHC is fine on windows
09:04:41 <vincenz> crazy_coder: try YAHT, it's a great tutorial
09:04:52 <crazy_coder> greedy code X desperate code
09:04:58 <laz0r> hi, everybody, i am curious about creating an instance... suppose i want to write my own show function for Lists, how would i do that? I tried with 'instance Show [a] where ...', that seems to be the correct way, since hugs comlpains about 'overlapping instances'
09:05:01 <schlupping> i heard about several compilers ... are there interpreters to? .... like java? ....is haskell portable? :)
09:05:18 <schlupping> what about frameworks for haskell?  i am only used to code in java
09:05:30 <laz0r> but... how would i make it non-overlapping
09:05:33 <jedai> crazy_coder: Haskell isn't an easy language, but it's extremely rewarding when you get it !! :-)
09:05:37 <schlupping> so its really not that clear to me how things that could be done in java could be done in haskell
09:05:58 <jedai> schlupping: Hugs is an interpreter, or GHCI
09:06:06 * wli hammers out addition with typeclasses.
09:06:08 <schlupping> whats the difference?
09:06:15 <jedai> schlupping: Well not really but you use them as if they were...
09:06:19 <pastorn> schlupping: if you have a *nix system it is all very easy
09:06:28 <jedai> schlupping: Use GHC, it comes with GHCI
09:06:29 <pastorn> ubuntu 7.04 is nice ande easy
09:06:35 <schlupping> k
09:06:46 <jedai> pastorn: GHC on windows work great
09:06:51 <schlupping> what kind of IDE could i use?
09:07:04 <schlupping> i am used to eclipse
09:07:09 <hpaste>  ihope annotated "(no title)" with "fixed?" at http://hpaste.org/1634#a1
09:07:13 <ihope> See if that works.
09:07:17 <jedai> schlupping: emacs, vim... If you know eclipse, there's a plugin
09:07:28 * pastorn uses a notepad-ish editor with a command prompt
09:07:41 <schlupping> a haskell plugin for eclipse?
09:07:58 <jedai> schlupping: Yes
09:08:02 <schlupping> i would love to learn emacs or vim, but it takes to much time to learn
09:08:06 <ihope> Rather...
09:08:14 <ihope> crazy_coder: see if http://hpaste.org/1634#a1 works.
09:08:20 <pastorn> schlupping: vim took me 2 hours
09:08:21 <laz0r> is the whole idea of writing my own show function for lists even sane?
09:08:31 <pastorn> schlupping: while doing stuff
09:08:35 <schlupping> maybe 2 hours for the very basic things...
09:08:37 <ihope> laz0r: you're writing your own show function for lists?
09:08:38 <jedai> schlupping: eclipsefp
09:08:44 <laz0r> or would it be something that no one really wants to do...?
09:08:50 <laz0r> ihope, i tried
09:08:55 <ihope> laz0r: why are you doing that?
09:08:58 <schlupping> but i want to have many debugging tools
09:09:02 <schlupping> and stuff like that
09:09:05 <laz0r> ihope, i wanted to see if i could
09:09:08 <schlupping> i guess one could do  that in vim too
09:09:15 <schlupping> but i guess its not that easy
09:09:18 <schlupping> if you are new to vim
09:09:19 <jedai> laz0r: It depends, if you want some specific presentation
09:09:28 <pastorn> schlupping: you don't need any debugging at the beginner level
09:09:37 <jedai> laz0r: It's pretty easy to do
09:09:47 <pastorn> all you need is the interpreter; if your code is bad it won't accept it
09:10:00 <laz0r> ihope, i am experimenting with instances, so i thought: i'll just create my own show function for lists, since i considered that 'easy'
09:10:08 <ihope> Ah.
09:10:13 <jedai> schlupping: Most errors are detected in the compiling step, it's one of the advantage of Haskell
09:10:33 <schlupping> but i would like the IDE to underline errors with a red line :)
09:10:37 <Philippa> that, and you can do most of the rest of your debugging in the interpreter
09:10:41 <ihope> laz0r: well, you can't have two instances for exactly the same type/class combination, I think, so you'd have to make your own list.
09:10:42 <pastorn> schlupping: there's always the EASY MODE for vim; "gvim -y"/"evim" which makes it an advanced version of notepad
09:10:52 <schlupping> and paint fancy things all over my code to make it more readable :) ...and i hate console and flags
09:11:02 <jedai> schlupping: eclipsefp probably do that...
09:11:05 <schlupping> i want the IDE to do all that stuff for me :)
09:11:10 <ihope> Your own list type, that is.
09:11:14 <laz0r> ihope, mmmh, yes, thats probably why hugs complains about 'overlapping instances'
09:11:29 <laz0r> ihope, so, the only way around that would be to create my own List?
09:11:33 <schlupping> is it possible to have it all in vim too?
09:11:34 <jedai> schlupping: Forget Haskell then, and use Java (it won't replace your brain but almost...)
09:11:48 <schlupping> no i hate java
09:11:50 <schlupping> :D
09:12:02 <pastorn> hehe, then forget all you know about programmin
09:12:09 <oerjan> laz0r: the simplest would be newtype Mylist a = ML [a]
09:12:13 <pastorn> and IDEs and other blasphemous things
09:12:14 <ihope> laz0r: either your own [] or your own Show.
09:12:22 <schlupping> but eclipse is cool
09:12:26 <jedai> schlupping: Good, then try EclipseFP, though Vim or Emacs are really great when you master them
09:12:26 <Philippa> schlupping: you can run GHCi in its own window, and you can get syntax highlighting in most decent text editors
09:12:31 <schlupping> i dont like java... i tried scheme
09:12:36 <Philippa> I'm using textpad myself
09:12:42 <schlupping> scheme was nice ... but way to many parantheses
09:12:42 <pastorn> schlupping and others, come join #haskell-newb
09:12:47 <schlupping> but beside that... nice
09:12:56 <ihope> schlupping: well, I think Haskell plugins for Eclipse have been mentioned, so... try one of those?
09:14:25 <jedai> laz0r: Why not just writing a showListAsXML for example ?
09:14:50 <jedai> laz0r: Do you really need to use the Show typeclass ?
09:15:12 <laz0r> jedai: no, not really, i am just toying around
09:15:48 <quicksilver> I think he just wants to experiment with implementing a typeclass
09:15:51 <quicksilver> which is fair enough :)
09:15:54 <laz0r> jedai: but that showListAsXML sounds like a more practical thing to do, i think i'll try doing that
09:15:57 <quicksilver> the newtype solution is probably the best
09:16:33 <jedai> quicksilver: If he wants to do that, it's more interesting to try with a hand-made tree
09:17:12 <jedai> quicksilver: You can do a good number of instances on tree
09:18:14 <crazy_coder> ihope: Sorry, I am getting a parse error at num<-getNumber used in the pickStick function
09:18:50 <crazy_coder> I guess <- can be used in  a do block only
09:19:04 <ihope> Yes, only in do blocks.
09:19:15 <ihope> Put a do block there.
09:19:26 <ihope> (And I seem to have used spaces where you had tabs.)
09:19:32 <crazy_coder> but is it ok if it recurses then ?
09:19:42 <crazy_coder> Cause then do must return a type IO a ?
09:21:12 <crazy_coder> recursion will be OK I guess, but then I will require the output to be of type IO Player
09:21:16 <laz0r> ok, some more general things i am curious about: that typeclass instance thing relies on pattern matching, right? whenever i do show [], it recognizes [] as a list and then evaluates the show function from the appropriate instance?
09:21:47 <vincenz> laz0r: it's at compile-time
09:22:03 <vincenz> laz0r: but yes, basically that's how it works
09:22:06 <vincenz> it dispatches on type
09:22:07 <laz0r> ok
09:23:22 <laz0r> compile-time just means it matches the types at compile time, so it doesn't have to do it at runtime? 
09:23:30 <vincenz> right
09:24:16 <quicksilver> laz0r: I don't mean to be pedantic, but that's not pattern matching
09:24:20 <quicksilver> laz0r: that's type inference
09:24:27 <quicksilver> laz0r: (just to help you understand the jargon)
09:24:35 <vincenz> quicksilver: good point
09:24:46 <quicksilver> when you do show [], it infers the type of [] as a list, and then picks the appropriate instance
09:24:47 <jedai> laz0r: pattern-matching is on value, typeclass works on types
09:24:49 <quicksilver> just as you said
09:25:03 <laz0r> ah, ok
09:25:13 <vincenz> laz0r: conceptually you are right, its just a matter of getting the terminology right :)
09:26:32 <wli> Darn, the type-level addition didn't actually work.
09:26:41 <crazy_coder> ihope: Any ideas on how to overcome this problem? 
09:27:00 <wli> I think it used to work.
09:27:26 <ihope> crazy_coder: well, anything that performs IO will have an IO type.
09:28:01 <laz0r> i'll be going for a walk thinking.... will be back later, asking more questions, potentially
09:28:27 <crazy_coder> ihope: it compiled without any errors.
09:28:45 <ihope> crazy_coder: it compiles without errors but doesn't work?
09:28:54 <crazy_coder> ihope: Maybe I can proceed from here on.  Thank you very much
09:29:04 <crazy_coder> ihope++
09:29:08 <GNU\caust1c> are there functions in prelude that read a list of integers from stdin?
09:29:48 <crazy_coder> Thank you everybody
09:29:55 <ihope> GNU\caust1c: a list in list format?
09:30:12 <crazy_coder> I will fix the logic, but now the types have become compatible with each other...... :)
09:30:14 <glguy> good morning
09:30:16 <glguy> ?users
09:30:16 <lambdabot> Maximum users seen in #haskell: 355, currently: 327 (92.1%), active: 20 (6.1%)
09:30:39 <GNU\caust1c> something like [24:12:1566:234]
09:30:46 <crazy_coder> *atleast the types  have become compatible........;)
09:30:52 <pastorn> could someone please h4xx this into working? http://hpaste.org/1635
09:32:53 <Saizan> pastorn: are you checking if a file exist by trying to read it?
09:33:35 <pastorn> yeah, and if i get an error i know it doesn't exist
09:33:43 <pastorn> or is my logic failing me?
09:34:00 <Saizan> i wonder if there's not a more direct way
09:34:02 <pastorn> i don't know how to use IOError at all
09:34:15 <pastorn> hOpenFile might be better...
09:34:19 <pastorn> but i
09:34:37 <pastorn> *but I've never used IO on that low level before...
09:35:24 <hpaste>  Jedai annotated "(no title)" with "(no title)" at http://hpaste.org/1634#a2
09:36:04 <glguy> :t System.Directory.doesFileExist
09:36:06 <lambdabot> FilePath -> IO Bool
09:36:28 <pastorn> glguy: don't be like that...
09:36:39 <glguy> using exceptions like that would be a terrible abuse
09:36:45 <jedai> crazy_coder: look at the code I pasted
09:36:45 <pastorn> ?src doesFileExist
09:36:46 <lambdabot> Source not found. Maybe if you used more than just two fingers...
09:37:10 <pastorn> glguy: i was just guessing my way forward with that
09:37:37 <pastorn> seemed like it would work, so i went for it...
09:37:54 <pastorn> @where System.Directory
09:37:55 <lambdabot> I know nothing about system.directory.
09:38:06 <pastorn> gimme source please LB!!!
09:38:25 <Saizan> bool <- catchJust ioErrors (readFile fname >> return True) (\e -> isDoesNotExistError e) -- just to show how you'd do it
09:38:54 <pastorn> ?type (>>)
09:38:56 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
09:39:21 <pastorn> Saizan: thank you =)
09:41:47 <hpaste>  mnislaih pasted "(no title)" at http://hpaste.org/1636
09:54:20 <chylli> hi. I defined a data type: 
09:54:27 <chylli> data Tuple a b c d = One a | Two a b | Three a b c | Four a b c d
09:54:36 <Cale> yep
09:54:54 <chylli> and write a function :
09:54:55 <chylli> fromTuple (One a) = Left (Left a)
09:54:55 <chylli> fromTuple (Two a b) = Left (Right (a, b))
09:54:55 <chylli> fromTuple (Three a b c) = Right (Left (a, b, c))
09:54:55 <chylli> fromTuple (Four a b c d) = Right (Right(a, b, c, d))
09:55:09 <Cale> mhm
09:55:10 <chylli> but I don't understand the functin fromTuple
09:55:25 <Cale> er, why not?
09:55:54 <chylli> that is the answer on the book. 
09:56:04 <chylli> my own version is like :
09:56:12 <chylli> fromTuple(One a) = a
09:56:27 <chylli> fromTuple(Two a b) = (a,b)
09:56:32 <chylli> but it failed
09:56:39 <Igloo> chylli: What type should fromTuple have?
09:56:46 <Cale> Because  a  and  (a,b) could not possibly have the same type
09:57:02 <chylli> Igloo: any type can be, I think
09:57:21 <Cale> chylli: fromTuple takes a value of type Tuple a b c d
09:57:24 <chylli> Cale: Yes. but I don't know where Left Right come from
09:57:31 <Cale> what type of value should it return?
09:57:33 <vincenz> @src Either
09:57:33 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
09:57:42 <vincenz> data Either a b = Left a | Right b
09:57:50 <Cale> Read the question carefully -- it says that you should use the Either type.
09:58:12 <chylli> yes, but I really dont know how to use it.
09:58:36 <Cale> Well, a value of type Either a b is either Left x for some x :: a, or Right y for some y :: b
09:58:37 <chylli> why the first one is Left (Left a) but not Left (Right a) ??
09:58:48 <Cale> Well, decide on the type first.
09:58:50 <Syzygy-> ?index chr
09:58:50 <lambdabot> Data.Char
09:58:54 <chylli> or anythig else ?
09:59:15 <Cale> fromTuple needs to return a value of one of the types:  a, (a,b), (a,b,c), (a,b,c,d)
09:59:37 <Cale> So, there are a few ways in which we could use the Either type to express that set of alternatives.
09:59:46 <Cale> We could form a chain:
10:00:03 <Cale> Either a (Either (a,b) (Either (a,b,c) (a,b,c,d)))
10:00:09 <chylli> oh,
10:00:20 <chylli> ok
10:00:23 <chylli> thanks very much
10:00:24 <Cale> But, if we want to be more efficient, we'd rather have them in pairs
10:00:32 <chylli> ?
10:00:39 <Cale> Either (Either a (a,b)) (Either (a,b,c) (a,b,c,d))
10:01:03 <chylli> oh, ok, let me think it carefully
10:01:04 <Cale> Which is only a depth-2 tree of possibilities rather than depth 3.
10:01:06 <chylli> thanks very much
10:01:35 <chylli> maybe it will help me if I read next several chapters
10:01:59 <vincenz> Cale: now gimme the second-order zipper in terms of a
10:02:11 <Cale> hehe :)
10:03:52 <Cale> It should be the unit type, I'd think.
10:04:08 <Saizan> btw, do we consider + associative in types?
10:04:17 <Cale> After the first step, you'd be differentiating with respect to constants.
10:04:39 <vincenz> yeah
10:04:40 <Cale> Saizan: up to isomorphism
10:04:48 <roconnor> > let rats = 1:[recip . (+1) . recip, (+1)] `ap` rats in rats::[Rational]
10:04:49 <lambdabot>  [1%1,1%2,1%3,1%4,1%5,1%6,1%7,1%8,1%9,1%10,1%11,1%12,1%13,1%14,1%15,1%16,1%17...
10:04:58 <roconnor> I was afraid of that
10:05:10 <GNU\caust1c> how do i construct a function that reads in 10 integer values and stores them in a list? i cant get it, i always get errors i dont understand :E
10:05:18 <quicksilver> Cale: FSOV efficient
10:05:20 <roconnor> > let rats = 1: map (flip $) rats `ap` [recip . (+1) . recip, (+1)] in rats::[Rational]
10:05:20 <lambdabot>      Occurs check: cannot construct the infinite type: c = (a -> a) -> c
10:05:21 <lambdabot>     ...
10:05:24 <quicksilver> Cale: it doesn't really matter, does it?
10:05:35 <vincenz> Cale: feel like deriving the second-order of N-ary trees? (which contain a double-fix point :P)
10:05:46 <vincenz> you have
10:05:46 <roconnor> > let rats = 1: ((map (flip $) rats) `ap` [recip . (+1) . recip, (+1)]) in rats::[Rational]
10:05:47 <lambdabot>      Occurs check: cannot construct the infinite type: c = (a -> a) -> c
10:05:47 <lambdabot>     ...
10:06:02 <vincenz> mu t. 1 + [mu l.1 +lt]
10:06:18 <vincenz> mu t. 1 + [mu l.1 +alt]
10:06:18 <roconnor> > let rats = 1: [f x|x<-rats, f<-[recip . (+1) . recip, (+1)]] in rats::[Rational]
10:06:19 <wli> roconnor: did you see my update?
10:06:20 <lambdabot>  [1%1,1%2,2%1,1%3,3%2,2%3,3%1,1%4,4%3,3%5,5%2,2%5,5%3,3%4,4%1,1%5,5%4,4%7,7%3...
10:06:25 <roconnor> wli: nope
10:06:32 <vincenz> that's still off
10:06:49 <Saizan> GNU\caust1c: it depends on the format, how are they separed? spaces?
10:06:55 <wli> roconnor: http://hpaste.org/1633
10:07:29 <vincenz> Tree a = mu t. a + [mu l. 1 + l*t]
10:07:32 <Saizan> GNU\caust1c: if you want to read them from stdin you have two distinct problems, 1) get the string in IO 2) parse it with a pure function
10:07:45 <Cale> > let rats :: [Rational]; rats = iterate next 1 where next x = recip (fromInteger n + 1 - y) where (n,y) = properFraction x in rats
10:07:46 <lambdabot>  [1%1,1%2,2%1,1%3,3%2,2%3,3%1,1%4,4%3,3%5,5%2,2%5,5%3,3%4,4%1,1%5,5%4,4%7,7%3...
10:07:47 <GNU\caust1c> i wanted to begin with the easy case, 1 integer per line
10:08:02 <oerjan> :t readLn
10:08:04 <lambdabot> forall a. (Read a) => IO a
10:08:05 <roconnor> wli: :)
10:08:20 <wli> roconnor: How's that look?
10:08:23 <oerjan> sequence [readLn | _ <- [1..10]]
10:08:38 <GNU\caust1c> the target is, that im able to read in files like on spoj.pl in those problems
10:08:56 <roconnor> wli: like a big mess ;)
10:09:18 <oerjan> (actually _ <- is unnecessary)
10:09:19 <GNU\caust1c> didnt know there is readLn, tried to do it with getLine
10:09:47 <wli> roconnor: Well, it does the power-of-two optimizations for natRat
10:09:48 <EvilTerran> oerjan, or sequence $ replicate 10 readLn
10:09:49 <oerjan> or is it? hm.
10:10:00 <EvilTerran> > [() | [1..10]]
10:10:01 <lambdabot>  Couldn't match expected type `Bool' against inferred type `[a]'
10:10:08 <EvilTerran> nope
10:10:18 <oerjan> i see, only in do notation
10:10:20 <EvilTerran> > [() | _ <- [1..10]]
10:10:21 <lambdabot>  [(),(),(),(),(),(),(),(),(),()]
10:10:30 <GNU\caust1c> hmk, thx
10:10:35 <shachaf_> oerjan: There's an implied "guard" in list comprehensions.
10:10:48 <ddarius> vincenz: You might find Thorsten Altenkirch's "Representations of first order function types as terminal coalgebras" somewhat interesting.  Not very related to what you are talking about.
10:10:52 <shapr> yarr
10:10:53 <Saizan> why not just do str <- getContents; return (map read (lines str)); ?
10:10:56 <shachaf_> > [1..10] >> return ()
10:10:57 <lambdabot>  [(),(),(),(),(),(),(),(),(),()]
10:11:00 <shapr> Good morning #haskell!
10:11:13 <EvilTerran> Saizan also has a good idea
10:11:15 <ray> morning
10:11:24 <EvilTerran> altho using readLn may be considered better style by some
10:11:34 <ray> well, "morning" adjusted for time zone
10:11:44 <roconnor> wli: I wonder if it is faster
10:11:46 <Cale> fmap (map read . lines) getContents
10:11:52 <Saizan> ?type readLn
10:11:54 <lambdabot> forall a. (Read a) => IO a
10:13:31 <wli> roconnor: Binary search for the highest power-of-two divisor is largely for want of an ffs in Data.Bits
10:16:02 <ray> does anyone have a good example of a mature haskell program that uses curses-type stuff?
10:16:08 <wli> roconnor: I'd do it with shift and mask operations if there were enough there to do them with.
10:17:13 <sjanssen> wli: ffs?
10:17:53 <Cale> > let rats = fix ((1 :) . flip (liftM2 (flip ($))) [recip . (+1) . recip, (+1)]) in rats :: [Rational]
10:17:55 <lambdabot>  [1%1,1%2,2%1,1%3,3%2,2%3,3%1,1%4,4%3,3%5,5%2,2%5,5%3,3%4,4%1,1%5,5%4,4%7,7%3...
10:17:56 <wli> sjanssen: Find the first set bit.
10:18:32 <sjanssen> wli: oh.  Data.IntMap has an internal routine for that
10:18:37 <wli> sjanssen: It would be a faster way to do what I'm doing in http://hpaste.org/1633#a2
10:18:51 <GNU\caust1c> i still dont get it, how to implement that in my code :(
10:19:10 <Jaak> @type recip
10:19:12 <lambdabot> forall a. (Fractional a) => a -> a
10:19:17 <Jaak> ah
10:19:38 <hpaste>  sjanssen annotated "bijection between rationals and integers" with "highestBitMask from Data.IntMap" at http://hpaste.org/1633#a3
10:19:45 <sjanssen> wli: ^^^
10:20:53 <wli> sjanssen: These require arbitrary-precision integers because they overflow machine integers quite rapidly, so it looks like a no-go.
10:21:14 <sjanssen> oh
10:21:30 <sjanssen> annoying that Integer doesn't support bitSize
10:22:06 <ddarius> :t bitSize
10:22:08 <lambdabot> forall a. (Bits a) => a -> Int
10:22:17 <sjanssen> > bitSize (1 :: Integer)
10:22:18 <lambdabot>  Exception: Data.Bits.bitSize(Integer)
10:22:19 <wli> sjanssen: bitSize . bitReverse would do it, if either existed (never mind for arbitrary-precision integers).
10:22:22 <sjanssen> > bitSize (1 :: Int)
10:22:24 <lambdabot>  32
10:22:56 <ddarius> sjanssen: What should it be?
10:23:21 <sjanssen> ddarius: floor . logBase 2
10:24:14 <ddarius> +1 ?
10:25:01 <ddarius> Anyway I need to leave
10:25:22 <crazy_coder> If in a do block , I use an if  .. then exp, then the return type of  exp must be the same as that of the do block. Am I right ?
10:25:34 <sjanssen> yeah, succ . floor . logBase 2
10:25:59 <sjanssen> crazy_coder: yes, if the 'if' is the last statement in the do
10:26:10 <crazy_coder> Or if it returns, say IO Int, I can have a if .. then putStrLn "Hi"
10:26:29 <wli> sjanssen: If there were a way to form a bitmask, like bit except it sets the first n bits instead of just the n-th, that would also do (subtracting 1 from bit (n+1) is slow).
10:26:29 <crazy_coder> No , the if is somewhere in between 
10:26:49 <crazy_coder> but it may happen that the predicate is true and that is what is actually returned
10:27:51 <wli> sjanssen: Actually it'd probably be faster than exponentiation and division.
10:28:05 <cdsmith> I'm writing a wrapper around libpng and libjpeg, plus a set of image manipulation combinators.  What is a good module name?
10:30:21 <DukeDave> Hey, is 'tl' the Miranda equivalent of 'tail' ?
10:30:24 <xerox> cdsmith: bringert has libGD bindings, that's how he named stuff http://www.cs.chalmers.se/~bringert/darcs/haskell-gd/doc/api/index.html
10:30:25 <Cale> cdsmith: Graphics.Something
10:30:29 <lambdabot> http://tinyurl.com/35x3on
10:31:02 <Cale> cdsmith: Perhaps  Graphics.JPEG, Graphics.PNG, Graphics.ImageManipulation
10:31:20 <cdsmith> Okay, that's a good start, then.
10:32:37 <Cale> DukeDave: probably
10:33:13 <hpaste>  wli annotated "bijection between rationals and integers" with "further improvement to natRat" at http://hpaste.org/1633#a4
10:33:16 <GNU\caust1c> ok, i've got a working function for reading n integers, and returning them in a list, how can i read multiple integers from 1 line?
10:33:24 <cdsmith> Hmm, if libgd does what I want, I might cut back to only part of my own project.  Thanks xerox!
10:33:32 <sjanssen> GNU\caust1c: yes
10:33:39 <sjanssen> GNU\caust1c: you probably want the words function
10:33:41 <xerox> cdsmith: you're welcome! :-)
10:33:59 <GNU\caust1c> ok
10:34:50 <Cale> wli: I haven't looked at that code too hard -- is it intended to produce all rationals, i.e. including 0 and negatives?
10:35:04 <wli> Cale: No, only the positive rationals.
10:35:06 <Cale> okay
10:35:24 <wli> Cale: 0 and negatives are easily handled with this in hand.
10:36:27 <Vulpyne> > let readints n s = take n $ map read $ words s :: [Int] in readints 5 "1 2 3 4 5 6 7 8 9 10"
10:36:29 <lambdabot>  [1,2,3,4,5]
10:37:36 <sieni> Cale: if you have a list of positive rationals e.g. [p 1, p 2, p 3, ...] then you can list all rationals with [0, p 1, -(p 1), p 2, -(p 2), ...]
10:38:06 <Cale> sieni: of course
10:38:19 <wli> Cale: I have more issues with enumerating tuples of integers constrained in various ways at the moment (that is, in terms of explicit, efficient bijections between such and the naturals) than rationals per se, but it's good practice.
10:39:06 <EvilTerran> 0 : concat $ transpose [posRats, map negate posrats]
10:42:35 <Cale> let binary 0 = []; binary 1 = []; binary n = let (u,v) = divMod n 2 in v : binary u; natRat n = foldr (.) id (map ([recip . (+1) . recip, (+1)]!!) (binary n)) 1 in map natRat [1..]
10:42:38 <Cale> > let binary 0 = []; binary 1 = []; binary n = let (u,v) = divMod n 2 in v : binary u; natRat n = foldr (.) id (map ([recip . (+1) . recip, (+1)]!!) (binary n)) 1 in map natRat [1..]
10:42:40 <lambdabot>  [1.0,0.5,2.0,0.3333333333333333,1.5,0.6666666666666666,3.0,0.25,1.3333333333...
10:42:44 <Cale> > let binary 0 = []; binary 1 = []; binary n = let (u,v) = divMod n 2 in v : binary u; natRat n = foldr (.) id (map ([recip . (+1) . recip, (+1)]!!) (binary n)) 1 in map natRat [1..] :: Rational
10:42:44 <lambdabot>  Couldn't match expected type `Rational' against inferred type `[a]'
10:42:48 <Cale> > let binary 0 = []; binary 1 = []; binary n = let (u,v) = divMod n 2 in v : binary u; natRat n = foldr (.) id (map ([recip . (+1) . recip, (+1)]!!) (binary n)) 1 in map natRat [1..] :: [Rational]
10:42:50 <lambdabot>  [1%1,1%2,2%1,1%3,3%2,2%3,3%1,1%4,4%3,3%5,5%2,2%5,5%3,3%4,4%1,1%5,5%4,4%7,7%3...
10:43:44 <wli> Cale: The bijection doesn't work that way. There are recurrence solutions involved, namely to r_{n+1} = 2*r_n - 1 and r_{n+1} = 2*r_n - 2
10:44:01 <Cale> Well, that's one bijection, anyway
10:44:51 <wli> Cale: If you do it the way you are now, inversion is painful if even feasible.
10:45:20 * EvilTerran quite likes the Q -> N injection (n/d) -> 2^n * 3^d
10:45:41 <Cale> Yeah, I'm more used to doing two way injection like that :)
10:46:00 <wli> This thing is hairy continued fraction stuff.
10:46:36 <wli> natRat . ratNat = id and ratNat . natRat = id
10:47:28 <wli> And they're 1:1 and onto.
10:49:14 <wli> Cale: I have tuple enumeration problems of my own.
10:49:50 <crazy_coder> can I putStrLn show([Int]) ?
10:50:06 <crazy_coder> like i want to display the list of integers
10:50:45 <wli> crazy_coder: Yes, putStrLn $ show listOfListsOfInts
10:50:52 <wli> crazy_coder: print also works
10:50:58 <wli> crazy_coder: print listOfListsOfInts
10:51:02 <oerjan> @src print
10:51:03 <lambdabot> print x = putStrLn (show x)
10:51:29 <crazy_coder> > print [1,2,3]
10:51:37 <lambdabot>  <IO ()>
10:51:55 <crazy_coder> print show([1,2,3])
10:52:02 <oerjan> @help run
10:52:02 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
10:52:16 <oerjan>                                              ^^^
10:52:29 <crazy_coder> I didn't understand
10:52:39 <EvilTerran> ?type show
10:52:41 <lambdabot> forall a. (Show a) => a -> String
10:52:44 <crazy_coder> suppose I have a funtion x that returns a list of integers
10:52:46 <EvilTerran> ?type print
10:52:46 <oerjan> lambdabot does not do IO actions
10:52:48 <lambdabot> forall a. (Show a) => a -> IO ()
10:53:01 <EvilTerran> @src print
10:53:01 <lambdabot> print x = putStrLn (show x)
10:53:04 <Vulpyne> print tries to write to the console, but lambdabot just shows the return value from the expression.
10:53:05 <EvilTerran> > show [1,2,3
10:53:06 <lambdabot>  Parse error
10:53:07 <EvilTerran> > show [1,2,3]
10:53:08 <lambdabot>  "[1,2,3]"
10:53:31 <EvilTerran> "show" converts (pretty much) anything to a string
10:53:35 <EvilTerran> it doesn't do IO
10:53:35 <crazy_coder> >putStrLn (show [1,2,3])
10:53:44 <crazy_coder> > putStrLn (show [1,2,3])
10:53:46 <lambdabot>  <IO ()>
10:53:51 <crazy_coder> oh ok
10:53:54 <EvilTerran> putStrLn does IO, but doesn't convert to a string
10:53:56 <wli> What I really need is to generalize Bernstein polynomials in such a way that I can use some analogue of de Casteljau's algorithm.
10:54:15 <EvilTerran> print, as you can see from "<lambdabot> print x = putStrLn (show x)", does both.
10:54:27 <mnislaih> Help! I'm trying to run my own lambdabot here. How do I launch it via a remote ssh session? nohup doesn't seem to work. Does it have some daemon-like mode ?
10:54:51 <vincenz> mnislaih: screen?
10:55:22 <mnislaih> vincenz I only have ssh connectivity 
10:55:49 <wli> Basically I get an an underdetermined linear system for them being partitions of unity and the coefficients of the factors being 1.
10:55:57 <vincenz> mnislaih: screen is purely terminal
10:56:06 <vincenz> ssh -> screen -> lambdabot -> CTRL+A d
10:56:37 <mnislaih> hmm, I don't understand what you mean with screen. Maybe it is some linux admin thing I am not familiarised with ?
10:56:44 <wli> I'm thinking that it can be shored up by making the derivatives partitions of unity as well.
10:56:50 <vincenz> mnislaih: it's just a program
10:56:53 <crazy_coder> Thank you Guys, Its working
10:56:56 <vincenz> mnislaih: it allows you to detach a program and reattach it
10:57:00 <vincenz> mnislaih: just type screen after you ssh
10:57:27 <mnislaih> thanks vincenz, never heard of it before, but apt-get is bringing it
10:58:00 <wli> OTOH it's probably not worth screwing with them.
10:58:09 <crazy_coder> has anyone implemented the minmax algorithm in Haskell ?
10:58:36 <crazy_coder> the algorithm which is used for games like chess, tic tac toe ?
10:59:52 <Saizan> there's a sketch implementation in the "why functional programming matters" paper
10:59:58 <Saizan> @where whyfp
10:59:58 <lambdabot> http://www.math.chalmers.se/~rjmh/Papers/whyfp.html
11:00:38 <Vulpyne> crazy_coder: http://www.steffen-mazanek.de/blog/2007/02/haskell-chess.html
11:00:39 <lambdabot> Title: Informatik-Praxis: Haskell: Chess
11:07:26 <Cale> wli: actually, my bijection is quite easy to invert
11:07:27 <crazy_coder> Ok Thanks guys
11:07:52 <crazy_coder> I'll try to implement, but actually I didn't understand the alogrithm itself
11:08:21 <crazy_coder> Will have to re-read it , wikipedia doesn't explain it clearly :(
11:09:32 <hpaste>  Cale pasted "natural/rational bijection" at http://hpaste.org/1637
11:10:27 <Cale> er, oops :)
11:10:48 <Cale> missed a 'map' :)
11:11:18 <hpaste>  Cale pasted "natural/binary bijection (take 2)" at http://hpaste.org/1638
11:11:54 <Cale> er, rational, of course. I think I need a coffee ;)
11:14:56 <Saizan> is there a human-computable algoriothm to find a minimal cover of the universe given a bunch of sets and properties(like C \subset (AuB)) between them? 
11:15:00 <Cale> wli: is that cool?
11:16:40 <oerjan> Saizan: i would be surprised if that wasn't at least NP-complete
11:17:38 <Saizan> by minimal cover i mean an union of intersection of the given sets or their complements
11:18:50 <oerjan> C union (complement C) is not minimal?
11:19:18 <Cale> Unless the universe is already there :)
11:19:27 <Saizan> right..
11:19:53 <Saizan> i must be looking for something different then..
11:23:51 <Saizan> ah, i want an union of not-overlapping intersections..
11:24:24 <oerjan> C union (complement C) still works :)
11:24:29 <Saizan> yeah..
11:24:41 <oerjan> aka a partition
11:25:31 <byorgey> Saizan: minimAL cover or minimUM cover?
11:25:56 <byorgey> a minimal cover is easy: start with all the sets and delete one at a time until you can't delete any more
11:26:29 <Saizan> the union of the given sets is not U
11:27:03 <Saizan> however i think i want the "maximal" partition, but i'd better clear my ideas more :)
11:27:09 <oerjan> do you want each intersection to involve all the sets?
11:27:20 <byorgey> hm, OK, I don't think I understand the problem then
11:27:43 <Saizan> oerjan: no, i don't
11:27:47 <byorgey> minimum set cover, aka vertex cover, is NP-complete
11:28:03 <byorgey> but it looks like that's not quite what you want (?)
11:28:20 <Saizan> what's the difference with minimal?
11:29:11 <byorgey> usually "minimal" refers to a local minimum, where as "minimum" would refer to a global minimum
11:29:53 <byorgey> so a "minimal" X would be a solution that can't be improved "locally"
11:30:17 <Saizan> i see
11:31:24 <Saizan> however no, it's something different, thanks for helping me understand this ^^
11:33:17 <DukeDave> Hey gang, just crept up on something.. Is it not acceptable to do pattern matching such as (trivially):
11:33:29 <DukeDave> > let foo x x = x in foo 4
11:33:30 <lambdabot>      Conflicting definitions for `x'
11:33:30 <lambdabot>     In the definition of `foo'
11:33:35 <DukeDave> > let foo x x = x in foo 4 4
11:33:36 <lambdabot>      Conflicting definitions for `x'
11:33:36 <lambdabot>     In the definition of `foo'
11:33:51 <oerjan> no. :D
11:33:51 <Syzygy-> DukeDave: foo x x' = x in foo 4 4
11:33:54 <byorgey> DukeDave: yeah, you're not allowed to do that.
11:34:08 <Syzygy-> DukeDave: What do you expect foo 4 5 to do?
11:34:13 <byorgey> you'd have to say foo x y | x == y = x
11:34:20 <DukeDave> Syzygy-: Pattern match failure
11:34:32 <Syzygy-> Yeah, no, that doesn't work that way. :P
11:34:43 <byorgey> > let foo x y | x == y = x in foo 4 4
11:34:43 <DukeDave> byorgey: Roger, I was just hoping for a little more conciseivity ;)
11:34:44 <lambdabot>  4
11:34:48 <byorgey> > let foo x y | x == y = x in foo 4 5
11:34:50 <lambdabot>   Non-exhaustive patterns in function foo
11:35:17 <byorgey> DukeDave: yeah, I know what you mean.  I'm not sure what the rationale for disallowing that is/what would be involved in implementing it.
11:35:22 <DukeDave> Oh boo, that's the first time in weeks I've been disappointed by Haskell semantics ;)
11:35:35 <oerjan> it requires an Eq instance on x, at least
11:35:58 <byorgey> oerjan: good point.
11:36:19 <oerjan> also, it would make \x x -> ... different from \x -> \x -> ...
11:36:38 <oerjan> although that actually already is...
11:37:03 <oerjan> exactly because the first is not allowed.
11:39:02 <Syzygy-> ?seen alpheccar
11:39:03 <lambdabot> I haven't seen alpheccar.
11:39:13 <Syzygy-> Doesn't he hang out here occasionally?
11:50:10 <Saizan> i think i got it: i need all the non-empty intersections of the given sets and their complements expressed with the least number of terms
11:52:50 <oerjan> sounds like disjunctive normal form.
11:53:09 <oerjan> er, not quite
11:53:46 <oerjan> in any case, my guess of "at least NP-complete" remains.
11:54:30 <oerjan> since it sounds rather close to a generalization of SAT.
11:55:01 <Saizan> we start with 2^n intersections in fact
11:55:34 <oerjan> a kind of boolean circuit optimization
11:56:25 <Saizan> yup, i thought i could use karnaugh's maps for this, but didn't quite managed to
11:57:42 <oerjan> determining whether a given intersection is _empty_ is co-NP-complete
11:58:21 <Saizan> co-?
11:58:42 <oerjan> (i.e. determining that it is nonempty is NP-complete)
11:59:00 <Saizan> ah, ok
12:12:02 <sm> g'day all
12:21:31 <shapr> SHAZAM!
12:21:38 <arcatan> KAZAM!
12:22:13 <astrolabe> AZAM!
12:22:47 <Syzygy-> ZAM!
12:22:51 <Syzygy-> Doh.
12:22:53 * quicksilver watches curiously to see if shapr is going to turn into a superhero.
12:23:14 <shaprman> I HAVE COME TO HELP!!!
12:23:40 <shapr> whaat??
12:23:49 * shapr laughs
12:24:06 <astrolabe> has haskell taken over the world yet?
12:24:12 <astrolabe> @stats
12:24:12 <lambdabot> Unknown command, try @list
12:24:19 <astrolabe> @where stats
12:24:19 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
12:24:27 <Syzygy-> Hmmmm.
12:24:39 <Syzygy-> I just got my first request(s) for blog articles. Does this make me officially famous?
12:24:59 <RyanT5000> does anyone know where i can get a codex decryption key for ICFP2k7?
12:25:08 <cdsmith> Syzygy-: Absolutely
12:25:47 <cdsmith> RyanT5000: You mean 2006?  (Not that I'd know anyway.)
12:25:54 <RyanT5000> er, yes, my bad
12:26:07 <RyanT5000> (i've been awake for 27 hours now... it's starting to show)
12:26:36 <cdsmith> Careful.  We've only got a week to catch up on sleep now.
12:26:54 <Syzygy-> cdsmith: You don't need sleep next weekend. 
12:27:15 <RyanT5000> cdsmith: good point :P
12:28:51 <cdsmith> I've never done this ICFP thing before.  I've recruited a team of 4 people; we'll see how it goes, I guess.
12:29:11 <arcatan> that reminds me... I need to sleep, too
12:29:14 <RyanT5000> i've recruited a team of ... 1 other people...
12:29:21 <RyanT5000> which is my girlfriend
12:29:28 <cdsmith> Ryan: better than 0.  Can she program?
12:29:32 <RyanT5000> who learned what typeclasses are a week ago
12:29:53 <RyanT5000> she can kind of program
12:29:58 <RyanT5000> i've been teaching her haskell
12:30:01 <cdsmith> Ah.  None of my team members would learn Haskell.  I don't think there's a single language that we all know.
12:30:10 <RyanT5000> C?
12:30:13 <arcatan> cdsmith: just use Java
12:30:22 <shapr> RyanT5000: Sounds like fun.. I think I'll do the same thing... recruit my girlfriend.
12:30:36 <arcatan> shapr: does she know typeclasses?
12:30:39 <cdsmith> There a re members who don't know C or Java.  If I learned VB, I think that's make one.
12:30:47 <shapr> arcatan: Yeah, she does.
12:31:02 <RyanT5000> i gotta say, the undergraduate programming classes suck
12:31:14 <RyanT5000> cdsmith: wow
12:31:33 <RyanT5000> C is like the latin of 19th century science of programming
12:31:36 <RyanT5000> :P
12:31:41 <cdsmith> Or both Clint and I could learn Common Lisp, I guess.  I know Scheme, so maybe it wouldn't be hard.
12:32:57 <cdsmith> We're betting that the hard part will be finding algorithms... and then on Sunday, we can take whatever language has the most code written in it, and port the rest.
12:40:25 <shapr> bos: Hey, anything new with bytestringparser since January?
12:42:03 <ajay> I'm a new to haskell and I've been reading "The Craft of Functional Programming", I was thinking about actually trying to read some real world code to see if I could make sense of it and I was wondering if someone could recommend one of the applications on haskell.org's application/library database
12:42:36 <Excedrin> anything on Don's blog would be good to read, also xmonad
12:43:43 <shapr> lambdabot's code is exciting!
12:43:43 <ajay> do you have a URL for don's blog?
12:43:46 <shapr> @where dons
12:43:46 <lambdabot> http://www.cse.unsw.edu.au/~dons
12:43:55 <shapr> @where shapr
12:43:55 <lambdabot> http://www.ScannedInAvian.com/hope
12:44:05 <shapr> @where augustss 
12:44:06 <lambdabot> I know nothing about augustss.
12:44:07 <shapr> aww
12:44:22 <shapr> @where bos
12:44:23 <lambdabot> I know nothing about bos.
12:44:26 <shapr> @where Lemmih
12:44:26 <lambdabot> I know nothing about lemmih.
12:45:02 <shapr> Lemmih says he doesn't exist on the web.
12:45:58 <astrolabe> @where+ augustss http://www.cs.chalmers.se/~augustss/
12:45:58 <lambdabot> Done.
12:46:03 <shapr> yay
12:46:23 <astrolabe> was that a coincidence?
12:48:22 <hpaste>  etnt pasted "syntax error" at http://hpaste.org/1639
12:48:40 <etnt> can somebody tell me what I'm doing wrong ?
12:48:59 <etnt> haskell gives me grey hair...
12:49:41 <RyanT5000> why are you using !?
12:49:45 <RyanT5000> '!' ?
12:50:01 <etnt> thats really in the Parsec lib
12:50:08 <etnt> I tried to make a small example
12:50:15 <Cale> etnt: okay, let's look at the types
12:50:21 <etnt> my kode starts at type Token
12:50:31 <sm> it gets easier etnt
12:50:36 <Cale> etnt: It says that it can't match the type Token against the inferred type [a]
12:50:51 <Cale> var is supposed to be a MyParser Pgm
12:51:07 <Cale> which means that it's a function [Token] -> [(Pgm, [Token])]
12:51:34 <etnt> yes
12:51:45 <etnt> I'm listening
12:52:26 <Lemmih> etnt: This doesn't mean what you think it does: '[x:xs] -> ...'
12:52:48 <Cale> but, in the pattern, you're matching the input to var, which is intended to be a list of Tokens, against a list whose sole element is a list, whose first element is (pos, TokenVar v)
12:53:42 <Cale> So you're matching against a list of lists, where you're expecting to match a list of Tokens.
12:54:09 <etnt> hm..wait a minute...
12:54:16 * etnt thinking...
12:54:23 <Cale> Probably what you want is ((pos, TokenVar v) : xs) -> ...
12:55:13 <shapr> Lemmih isn't a web entity.
12:56:31 <etnt> hm...so inp takes a list of Tokens ?
12:58:24 <Cale> inp should be a list of Tokens
12:58:57 <Cale> [x:xs] is a list with one element, which is itself a list
12:59:04 <etnt> wait, you mean that [x:xs] is a list with one element which is a list ?
12:59:07 <Cale> yes
12:59:34 <etnt> ahh...I've mixing up the syntax with Erlang
13:00:04 <etnt> gee, thx!
13:01:14 <etnt> tricky bc the empty list of course needs [] (as in Erlang)
13:02:00 <etnt> cool, it compiled :-)
13:02:33 <Cale> Well, every list is either [], or (x : xs), where xs is another list
13:02:47 <Cale> So really, when you write [x], you're actually writing x : []
13:03:18 <etnt> ok, in Erlang that would have been [x:[]]
13:04:01 <bos> shapr: que?
13:04:22 <bos> @where+ bos http://www.serpentine.com/blog/
13:04:22 <lambdabot> Done.
13:05:54 <ski>   (pos, TokenVar v) : xs -> ...
13:05:57 <ski> works fine
13:06:26 <etnt> ski: yes, that's what I used
13:07:20 <dolio> Anyone know off hand if the HEAD version of haddock understands GADTs and generalized newtype deriving and such?
13:09:35 <waern> dolio: Haddock 2.0 understands GADTs
13:09:59 <dolio> There's a 2.0? :)
13:10:13 <waern> yep, aka haddock.ghc
13:10:57 <waern> unreleased :/
13:11:03 <dolio> Ah, okay.
13:11:03 <waern> needs GHC HEAD
13:11:20 <waern> http://darcs.haskell.org/SoC/haddock.ghc if you want to try it
13:11:23 <lambdabot> Title: Index of /SoC/haddock.ghc
13:11:24 <dolio> I had found an e-mail from February about a SoC project for that. I guess this is it.
13:11:32 <dolio> I wasn't sure what'd become of it, though.
13:11:50 <dolio> I'll give it a try.
13:12:43 <waern> I'm currently working on it :)
13:13:43 <dolio> Ah cool.
13:14:21 <dolio> Well, hopefully it gets merged back some day, since my having it won't do much good for people running 'Setup.lhs haddock' on their own computer. :)
13:15:12 <waern> Yeah. That will have to wait until GHC 6.8 is released  
13:15:27 <dolio> Ah, yeah, true. If it neads HEAD that makes sense.
13:35:46 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/1640
13:40:37 <slowriot> let's say we have an enumerated set defined as a data type (for example: data enumSet = a | b | c | ...)
13:40:58 <slowriot> Is there a way to generate a list of all of the elements in an enumerated set?
13:41:07 <byorgey> slowriot: sure
13:41:23 <dolio> Derive Enum, and then do [a .. z]
13:41:28 <byorgey> slowriot: data enumSet = a | b | c | d deriving Enum
13:41:45 <slowriot> okay, I'll take a look at that.
13:41:46 <slowriot> thanks
13:42:05 <byorgey> you may also want to derive Bounded and Ord while you're at it
13:42:30 <wli> Cale: heh
13:42:54 <Cale> wli: what's funny?
13:42:57 <oerjan> > [minBound..maxBound] :: Ordering
13:42:58 <lambdabot>  Couldn't match expected type `Ordering' against inferred type `[a]'
13:42:59 <wli> Cale: Well, I'd be interested in seeing the proof that it's bijective.
13:43:08 <oerjan> > [minBound..maxBound] :: [Ordering]
13:43:09 <lambdabot>  [LT,EQ,GT]
13:43:28 <dolio> Ah, yeah, there's that, too. You'll need to derive Bounded for that.
13:44:00 <Cale> wli: It's pretty easy by showing that the positive naturals are in bijection with binary strings, in a fairly obvious way, which are in bijection with the positive rationals via the Stern-Brocot tree.
13:44:01 <oerjan> :t [minBound..maxBound]
13:44:03 <lambdabot> forall a. (Bounded a, Enum a) => [a]
13:44:45 <Cale> (which is a binary tree that enumerates rationals)
13:45:21 <wli> Cale: well, I'm thinking about it for a moment.
13:45:35 <Cale> You can encode a path down the tree with a binary string.
13:46:24 <Cale> The bijection of positive natural numbers to binary strings is just by removal of the leading '1'
13:48:42 <slowriot> but you have to define enumFromTo, right?
13:48:56 <quicksilver> slowriot: no
13:48:57 <Cale> Oh, I suppose I'm not *quite* using the Stern-Brocot tree.
13:49:20 <quicksilver> slowriot: it can derive it easily enough
13:49:32 <quicksilver> slowriot: using fromEnum, toEnum, and the obvious enumFromTo on integers
13:49:47 <wli> Cale: Well, you're using a different set of continued fraction transformations, a different set of integer-to-rational transformations, etc., so the Stern-Brocot proofs need recapitulation, which I can't do offhand.
13:52:11 <wli> Cale: Mine would look a lot smaller if they were unoptimized.
13:53:47 <wli> Cale: For instance, like the first version in hpaste entry 1633.
13:58:00 <Cale> http://www.math.upenn.edu/~wilf/website/recounting.pdf
13:58:51 <Cale> There's a proof on the first few pages of that PDF.
14:02:13 <wli> Weird. I don't quite understand the proof.
14:03:22 <shapr> bos: I found http://darcs.serpentine.com/bytestringparser/ 
14:03:23 <lambdabot> Title: Index of /bytestringparser
14:03:32 <Cale> Where do you get stuck?
14:04:12 <wli> Cale: The f(n) = b(n) part.
14:04:39 <Cale> Er, that's past the proof that the tree contains all the rationals.
14:04:56 <Cale> (exactly once)
14:05:58 <wli> Cale: No big deal. I can at least understand that it's a proof of your representation.
14:06:06 <Cale> What part of the proof that f(n) = b(n) do you get stuck on?
14:07:32 <Cale> Basically, they're showing that the function which counts hyperbinary expansions satisfies the same recurrence by explicit bijections.
14:08:31 <Cale> That is, b(2n+1) = b(n) because every hyperbinary expansion of 2n+1 can be bijectively converted into a hyperbinary expansion of n
14:09:19 <Cale> and b(2n+2) = b(n) + b(n+1) because the set of hyperbinary expansions of 2n+2 is in bijection with the disjoint union of the sets of hyperbinary expansions for n and n+1.
14:10:18 <wli> Cale: I'm not sure but I think these may actually be disguised versions of each other.
14:10:41 <Cale> Probably.
14:11:57 <SamB> can't you say that whenever you have a bijection?
14:12:26 <wli> SamB: That's obviously not what I mean.
14:12:41 <SamB> I'm not quite sure what you do mean
14:13:16 <SamB> and I somehow don't think it would help if I knew what a hyperbinary expansion was ;-)
14:13:18 <quicksilver> I imagine wli means there is an obvious direct correspondance between the two bijections
14:13:31 <SamB> oh, there were two of them?
14:13:33 <quicksilver> (bijection between the bijections, perhaps ;)
14:13:37 * quicksilver nods
14:14:17 <bos> shapr: were you looking for a bytestring-aware parser doodad?
14:14:20 <SamB> oh, now I see it.
14:14:46 <wli> A quick check would be to see if the first several elements of the sequence come out the same or predictably similar, for instance.
14:15:03 <SamB> bos: did you see my fledgeling library "parsely"?
14:15:58 <dolio> Heh.
14:16:34 <dolio> I like that name.
14:16:48 <SamB> dolio: yeah, me too ;-)
14:16:57 <Cale> A hyperbinary expansion of n is a partition of n into powers of two, such that each part occurs at most twice.
14:16:59 <slowriot> what does this mean: instance Enum SDLKey Word32 where ?
14:17:06 <bos> SamB: nope
14:17:12 <Cale> (as opposed to at most once, as is the case with binary expansions)
14:17:17 <bos> SamB: what's a parsely?
14:17:19 <bos> @where parsely
14:17:20 <lambdabot> I know nothing about parsely.
14:17:26 <slowriot> I've read the part in yaht about instance declarations, but I don't understand what Word32 is there for.
14:17:27 <SamB> @hackage parsely
14:17:27 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/parsely
14:17:31 <byorgey> slowriot: it's defining SDLKey Word32 to be an instance of the Enum class.
14:17:39 <SamB> ooh, nice, there actually *is* a hackage command
14:18:17 <byorgey> slowriot: I don't know what SDLKey is, but presumably it's something like data SDLKey a = ...
14:18:51 <wli> Odds are my version will bench quite well.
14:18:59 <slowriot> I know of a data SDLKey = in the code, but no data SDLKey a =
14:19:02 <slowriot> maybe I'll grep for it
14:19:17 <SamB> I think I need to revive the StrategyLib library -- and I can't seem to find the 5.0 zip -- and I can't find the license!
14:20:38 <slowriot> byorgey: hmmm... I can't find any declaration like that. As far as I can tell, SDLKey is not parameterized.
14:20:46 <SamB> and I still need to find heirarchical names for at least 19 modules, though I imagine that the FooTheme modules will all end up with the same prefix somehow ;-)
14:21:01 <oerjan> slowriot: in that case that instance declaration seems like a misprint
14:21:02 <byorgey> slowriot: hmm... strange. if there was data SDLKey = ..., saying instance Enum SDLKey Word32 would be an error (a kind error, to be precise)
14:21:35 <SamB> wouldn't it be a case of passing too many parameters to the class anyway?
14:21:41 <oerjan> SamB: the @hackage command is a little deceptive, though:
14:21:50 <oerjan> @hackage WhateverYouWant
14:21:50 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/WhateverYouWant
14:22:03 <Cale> wli: aha, apparently that tree is in fact called the Calkin-Wilf tree.
14:22:04 <SamB> oerjan: yes but I happen to know how to spell parsely
14:22:27 <wli> Cale: Sounds like a different tree altogether, then.
14:22:30 <byorgey> SamB: true, you'd have to say instance Enum (SDLKey Word32)
14:22:37 <SamB> @wiki you are an idiot if you click here
14:22:38 <lambdabot> http://www.haskell.org/haskellwiki/you_are_an_idiot_if_you_click_here
14:23:14 <slowriot> There is also a .hsc file with this: instance Enum SDLKey #{type SDLMod} where
14:23:39 * oerjan fulfils today's idiot quota
14:23:42 <byorgey> wli, Cale: the Calkin-Wilf and Stern-Brocot trees are different, but I seem to recall seeing some sort of correspondence between them somewhere...
14:23:43 <Cale> wli: well, not completely -- each level of the tree is just a permutation of the corresponding level of the S-B tree, corresponding to the binary string reversal of the paths down to the root
14:23:54 <SamB> oerjan: what?
14:23:55 <SamB> we don'
14:23:55 <byorgey> Cale: that's it =)
14:24:02 <SamB> t have no stinkin idiot quota
14:24:08 <oerjan> SamB: i opened it :)
14:24:27 <SamB> well, okay, so maybe I'm the idiot
14:24:42 <byorgey> how can you NOT open a link like that?
14:24:52 <wli> Cale: That reminds me... Data.Bits should really have a bitreversal function.
14:25:27 <Cale> Can most processors do that any more quickly than you could code it by hand?
14:25:37 <SamB> :t testBit
14:25:40 <lambdabot> forall a. (Bits a) => a -> Int -> Bool
14:25:48 <SamB> wli: is that what you meant?
14:25:57 <Cale> I suppose some processors have things like vector permute
14:25:58 <SamB> or did you mean something more like...
14:26:48 <Cale> SamB: as in reversing the list of bits
14:26:54 <Cale> (I think)
14:26:55 <SamB> oh.
14:27:02 <SamB> I misread reversal as retrieval ;-)
14:27:06 <wli> Cale: Yes. It's very useful for FFT's.
14:27:17 <oerjan> > map (testBit 3) [1..]
14:27:18 <lambdabot>  Add a type signature
14:27:22 <Cale> Indeed.
14:27:32 <oerjan> > map (testBit 3) [(1::Integer)..]
14:27:33 <lambdabot>  Couldn't match expected type `Int' against inferred type `Integer'
14:27:49 <wli> oerjan: Probably flip testBit
14:27:54 <oerjan> > map (flip testBit 3) [(1::Integer)..]
14:27:55 <lambdabot>  [False,False,False,False,False,False,False,True,True,True,True,True,True,Tru...
14:28:46 <wli> oerjan: I think that's the same as \n -> (n `div` 8) `mod` 2
14:28:56 <SamB> wli: http://www.jjj.de/fxt/ has some C++ code you could translate
14:28:58 <lambdabot> Title: J&ouml;rg's useful and ugly FXT page
14:29:05 <oerjan> wouldn't using testBit be faster than test division by powers of 2?
14:29:27 <SamB> oerjan: that's slow
14:29:40 <SamB> it's far better to use bitshifts and masks
14:29:47 <oerjan> what?
14:29:51 <oerjan> @src testBit
14:29:52 <lambdabot> Source not found. Wrong!  You cheating scum!
14:30:06 <oerjan> SamB: i mean, since Integer does not have those
14:30:11 <oerjan> (yet)
14:30:13 <SamB> oerjan: oh.
14:30:17 <SamB> um.
14:30:20 <dolio> @src Integer testBit
14:30:21 <lambdabot> Source not found. Wrong!  You cheating scum!
14:30:24 <SamB> hmm.
14:30:38 <SamB> isn't there some way to get a list of Words out of it or something?
14:30:44 <oerjan> (if i have understood the discussion so far)
14:30:46 <SamB> maybe Word32's would be better
14:31:16 <oerjan> @src Integer
14:31:16 <lambdabot> data Integer = S# Int#
14:31:16 <lambdabot>              | J# Int# ByteArray#
14:31:50 <dolio> What would bit reversal be for Integer?
14:32:28 <dolio> for n > 0 you get infinite zeros, and then some stuff? :)
14:32:44 <dolio> And for n < 0 you get infinite ones and then some stuff.
14:34:33 <oerjan> for Integers it would probably be better to combine shift and mask in one, so you don't need to shift the whole number just for a few bits.
14:34:55 <bos> SamB: how does your parsey stuff differ from the rest of the field?
14:34:59 <byorgey> drop ω (bitReverse (-4))
14:36:00 <oerjan> you would want a bitSlice operation.
14:36:39 * byorgey contemplates making a parsing library called "parsimony"
14:37:35 * oerjan contemplates "parsimmon".
14:38:08 <SamB> bos: well, I'm hoping to make it able to allow you to use one of a few different parser implementations
14:38:33 <SamB> and use monad transformers on top of the parser implementations
14:39:00 <oerjan> SamB: not on the bottom? :(
14:43:23 <SamB> oerjan: well I was going to look into that too
14:44:05 <SamB> right now parsely is just a really lame way to use Parsec
14:44:21 <oerjan> :)
14:44:38 <oerjan> SamB++
14:45:12 <byorgey> SamB: how can it be lame with a name like parsely? ;-)
14:45:42 <SamB> at this point, I'd mostly like comments regarding which classes I have methods in and so on.
14:47:56 <SamB> bos: did you say something about having a bytestring-aware parser library, too?
14:48:46 <bos> i took jeremy shaw's one and made it a bit more friendly.
14:49:10 <SamB> it would be nice if someone would try to implement my typeclasses for it just to see how it goes
14:49:17 <bos> but really, parsing bytestrings directly isn't a very good idea.
14:50:13 <shapr> bos: Yeah, I found it but was wondering if there's been any changes since January.
14:50:59 <bos> no.
14:54:08 <sjanssen> bos: why is parsing bytestrings directly a bad idea?
14:54:24 <bos> because they're not text.
14:54:29 <bos> they're bytes.
14:54:36 <shapr> ok?
14:54:40 <shapr> I still don't get it.
14:54:42 <ddarius> bytes need parsing too
14:54:47 <bos> sure.
14:54:59 <bos> but you shouldn't be parsing bytes if you think you're parsing text.
14:55:00 <ddarius> And character conversion is a (simple) case of parsing.
14:55:07 <ddarius> s/conversion/encoding
14:55:12 <bos> indeed.
14:56:45 <_Nucleo> what's the best way to take the last X elements of a list?
14:56:53 <sjanssen> bos: as long as we're lacking a more competent IO system, does it really matter?
14:56:59 <sjanssen> _Nucleo: take X . reverse
14:57:04 <_Nucleo> right now I've got  reverse $ take 9 $ reverse []
14:57:10 <bos> sjanssen: :-)
14:57:24 <ddarius> How does stream fusion fare on that?
14:57:34 <_Nucleo> sjanssen: so I do need to do two reverses?
14:57:36 <sjanssen> actually, I should say "implementation", not "system"
14:57:45 <sjanssen> _Nucleo: if you want them in the original order, yes
14:58:11 <bos> i used to be irritated by the state of I/O, but i decided it wasn't actually all that annoying.
14:58:12 <ddarius> sjanssen: Don't we need some more fiddling even at the "abstract" level.  I.e. it's more than just a poor implementation.
14:58:42 <_Nucleo> ah, okay. Thanks.
14:58:58 <bos> bringert's network-alt library is quite nice.
14:59:06 <oerjan> isn't take X . reverse horribly space inefficient?
14:59:30 <SamB> bos: I don't see the problem if you don't support anything but ASCII anyway
14:59:35 <_Nucleo> so chopping off the first X elements of a list will always be faster than chopping off the last X elements? Given that reverse is O(n)?
14:59:36 <SamB> 'tis a biggish if, but...
15:00:01 <ddarius> _Nucleo: For a singly linked list, yes, not because reverse is O(n)
15:00:46 <sjanssen> ddarius: yeah, a little bit more interface
15:01:06 <dolio> > let last n xs = last' (drop n xs) xs where last' [] xs = xs ; last' (_:t) (_:xs) = last' t xs in last 9 [1..100]
15:01:07 <lambdabot>  [92,93,94,95,96,97,98,99,100]
15:01:41 <sjanssen> I'd like to tag Handles with an encoding, but that doesn't seem to be a popular idea
15:03:35 <dolio> Of course, that's still O(n).
15:08:24 <SamB> ddarius: and you don't think reverse . drop X . reverse is a fairly good way to do it???
15:11:10 <hpaste>  trevor pasted "tail recursive?" at http://hpaste.org/1641
15:14:03 <oerjan> SamB: it uses O(n) memory, while dolio's method only uses O(n) time
15:14:31 <foxy-om> I have a program that surges to a load factor of about 15 and gets killed by the OS, is there a way to prevent the OS (linux) from killing the process?
15:15:42 <SamB> oerjan: I suppose it depends on whether or not the list is used anywhere else
15:16:01 <oerjan> right
15:16:07 <SamB> foxy-om: you need more spoons
15:16:53 <foxy-om> SamB: My computer doesn't have an extendible cutlery interface. 
15:17:01 <oerjan> SamB: although if it is used elsewhere, the reverse method actually allocates it twice
15:17:46 <ddarius> SamB: Huh?
15:18:41 <byorgey> foxy-om: there might be (running it as root might help (?), for instance), but it probably doesn't have much to do with Haskell.
15:20:02 <SamB> oh, wait, reverse doesn't fuse?
15:21:49 <oerjan> well, i suppose take n . reverse _could_ fuse into something like what dolio said.
15:21:57 <flux> foxy-om, a single program (with a single thread) should only be able to increase the load by 1.0 at most - unless it starts trashing the swap and other processes start waiting to get paged in from the swap..
15:22:08 <Binkley> what is this "could"? Look at the Core :-)
15:22:09 <flux> foxy-om, maybe you're running out of memory?
15:22:56 <flux> foxy-om, I can't think of another reason why the OS would kill a process (unless requested to)
15:23:23 <Binkley> on some OSes you can set limits on CPU time and other resources
15:23:30 <Binkley> and a process will get killed if it attempts to exceed those limits
15:23:31 <ddarius> SamB: It may now, but I don't believe it did before.
15:24:27 <ddarius> Given the stream-based definitions of take and reverse, it should be easy to calculate what it should fuse to.
15:24:47 <SamB> apparantly right now it only fuses as a consumer
15:24:51 <SamB> er.
15:25:01 <SamB> by "right now" I mean "soon"
15:25:01 <byorgey> what versions of {GHC,libraries} use stream fusion for lists?
15:25:08 <dibblego> dons, I am now
15:26:14 <ddarius> HEAD I think
15:26:40 <ddarius> Alternatively, dons and dcoutts wrote a stream-based version of Data.List
15:27:40 <byorgey> ddarius: right, my question was in what version of the libraries the stream-based version of Data.List has/will replace the old one.
15:27:50 <byorgey> unless there will always be two versions?
15:31:59 <edwardk> is there any monad anyone can think of satisfying the monad laws where (return x >> return y) /= return y?
15:32:25 <basti_> would that satisfy the monad laws?
15:32:34 <basti_> s/wo/co/
15:32:39 <edwardk> thats my question =)
15:32:59 <basti_> i think not tbh
15:33:09 <edwardk> return is breaking my parameterized monad stuff's type inference properties and i want to see if i can use that fact to fix them
15:34:00 <edwardk> ah hrmm. but return x >>= \x -> return (f x)    could do weird things
15:34:08 <oerjan> return x >>= f = f x
15:34:24 <oerjan> that's a monad law
15:34:25 <edwardk> ah was that in the las?
15:34:30 <edwardk> er haws
15:34:32 * basti_ nods.
15:34:32 <edwardk> er laws
15:34:35 <edwardk> ah good
15:34:37 <SamB> @google monad laws
15:34:38 <basti_> in the things.
15:34:39 <edwardk> forgot that one =)
15:34:39 <lambdabot> http://etymon.blogspot.com/2006/09/monad-laws.html
15:34:39 <lambdabot> Title: Etymon: The Monad Laws
15:34:46 <dufflebunk> I don't know much about monads, but the answer might depend on the definition of =/ ?
15:34:56 <edwardk> that one just has the m >>= return = m
15:35:07 <edwardk> oh i see it way below
15:35:35 <edwardk> nice then my toy fix is completely correct =)
15:35:45 <edwardk> woot
15:37:39 <oerjan> dufflebunk: in that case = means semantic equality, not == from the Eq class
15:37:57 <dibblego> recently, I learned that some people think that a function that may or may not go to the file system to compute its result is "abstraction"
15:39:13 <oerjan> edwardk: there are three monad laws.
15:39:17 <wli> Hmm, I don't seem to be able to feed a strategy to parMap that does anything.
15:39:40 <oerjan> (in terms of return and >>=)
15:41:35 <edwardk> oerjan: i'm looking mostly for consequences of them =)
15:43:07 <edwardk> so, what can be said about, foo >>= return . bar
15:44:34 <oerjan> that is fmap bar foo
15:44:42 <edwardk> nice
15:44:54 <edwardk> oh duh, i just ported that
15:46:58 <edwardk> @type foo >>= bar = fmap (runReturn . bar) foo
15:47:00 <lambdabot> parse error on input `='
15:47:04 <edwardk> er
15:47:11 <edwardk> @pl foo >>= bar = fmap (runReturn . bar) foo
15:47:11 <lambdabot> (line 1, column 13):
15:47:11 <lambdabot> unexpected "="
15:47:11 <lambdabot> expecting variable, "(", operator, ">>", ">>=", "=<<" or end of input
15:47:20 <edwardk> @pl bind foo bar = fmap (runReturn . bar) foo
15:47:20 <lambdabot> bind = flip (fmap . (runReturn .))
15:47:28 <edwardk> sticking to the pointed version
15:47:58 <oerjan> erm...
15:48:27 <edwardk> it makes more sense when you see my (>>=) type =)
15:48:38 <oerjan> foo >>= return (runReturn bar)
15:48:57 <edwardk> class Bind m m' m'' | m m' -> m'' where (>>=) :: m a -> (a -> m' b) -> (m'' b)
15:49:23 <edwardk> what i did was break Return out as a newtype, then i'm plumbing instances for Bind for it, so it doesn't break backwards type inference
15:49:37 <edwardk> relying on the laws to push it down into the respective monads as you start to do interesting things with it
15:50:09 <oerjan> but...
15:50:10 <edwardk> instance Bind Return a a where Return m >>= k = k m, etc.
15:50:16 <oerjan> that _cannot_ work
15:50:34 <edwardk> well, it actually works quite nicely =) its a parameterized monad
15:50:54 <oerjan> say if bar = \x -> [1,2]
15:51:28 <oerjan> while return for lists = ([]:)
15:51:55 <oerjan> so you cannot get return . runReturn . bar = bar
15:51:58 <edwardk> Just 1 >>= \x -> [x*1,x*2]     looks for Bind Maybe [] m and has result type m Int (er the Num equivalent)
15:52:13 <edwardk> return = Return in the newtype
15:52:56 <edwardk> i need it for a form of security monad, i'm just going back and retrofitting all of this to work over existing monads
15:53:16 <oerjan> is this just for one monad?
15:53:43 <dons> `I posted it to Haskell-Cafe and received loads of brilliant responses. Wow, those guys are awesome. I'm definitely going to learn Haskell now.'
15:53:46 <dons> :D
15:53:48 <oerjan> but it is _not_ the case that return . runReturn . bar = bar !
15:54:13 <oerjan> it cannot be, because return can only give part of a monad's values
15:54:25 <edwardk> no, it rebinds the monad sugar, then i lift existing monads into it, but it loses inference for return above, so, i need to use the monad laws to get it back
15:54:30 <edwardk> sure
15:56:13 <edwardk> instance Bind a Return a where foo >>= bar = fmap (runReturn . bar)  foo   knows that the right hand side is a Return a, so it must be the composition of return . bar' for some bar'
15:57:37 <DRMacIver> dons: Yeah. I'm convinced that the incessant niceness is really just a conspiracy to lure people into Haskell. ;)
15:57:48 <oerjan> erm, i'll take your word for it.
15:57:50 <edwardk> DRMacIver: it worked on me
15:58:07 <DRMacIver> edwardk: Had the opposite effect on me actually. :)
15:58:37 <edwardk> oerjan: i'll paste up the version with the Return newtype shortly and you can break it on me ;)
15:59:00 <edwardk> @src Identity fmap 
15:59:00 <lambdabot> Source not found. Are you on drugs?
15:59:02 <oerjan> edwardk: actually what i mean is i'm too tired too decipher it right now
15:59:04 <edwardk> @src fmap Identity
15:59:04 <lambdabot> Source not found. Are you on drugs?
15:59:37 <oerjan> @src Id fmap
15:59:37 <lambdabot> Source not found. You type like i drive.
15:59:50 <oerjan> or not.
15:59:51 <edwardk> fmap f m = Identity (f (runIdentity m))
16:07:17 <dons> bos: good work, http://www.realworldhaskell.org/blog/2007/07/12/haskell-people-and-talks-at-oscon/
16:07:19 <lambdabot> Title: Real World Haskell  Blog Archive  Haskell people and talks at OSCON, http://tinyurl.com/389jwj
16:07:26 <bos> dons: thanks!
16:09:03 <ddarius> DRMacIver: People were nice and helpful to you and you were like "Pssh! I'm not going to learn this language now!"?
16:09:12 <wli> Wow, SPJ is singlehandedly giving 4 Haskell talks.
16:09:17 <DRMacIver> ddarius: Right!
16:09:52 <DRMacIver> ddarius: Nah. People were just really... keen. I found it disconcerting. :)
16:10:05 <matthew-_> who ever decided negative numbers were a good idea?
16:10:10 <matthew-_> they were wrong
16:10:17 <DRMacIver> Totally.
16:10:21 <oerjan> matthew-_: Diophantos
16:10:28 <DRMacIver> Even 0 was a step in the wrong direction.
16:10:34 <matthew-_> agreed
16:10:45 <matthew-_> the fact that signum 0 /= 1 is ridiculous
16:10:50 <wli> Hmm. OSCON's not cheap.
16:10:54 <ddarius> DRMacIver: I'm not understanding what you mean "keen" there.  Also, apparently you're still here...
16:11:23 <ddarius> I don't know.  Mathematics went massively downhill ever since the axiom of infinity was invented.
16:11:57 <DRMacIver> ddarius: Lots of starry eyed enthusiasm. And I gave it a try eventually and decided it was ok after all. ;)
16:12:04 <edwardk> @instances MonadPlus
16:12:05 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
16:12:46 <DRMacIver> ddarius: I'm very hype averse. Every time people get too enthusiastic about a subject I start looking at them suspiciously.
16:13:02 <oerjan> @src mplus IO
16:13:02 <lambdabot> Source not found. That's something I cannot allow to happen.
16:13:24 <ddarius> DRMacIver: That's a waste of time.  Look at what they are hyping skeptically (if you have any reason to).
16:13:53 <ddarius> @src IO mplus
16:13:53 <lambdabot> m `mplus` n = m `catch` \_ -> n
16:15:20 <chessguy> 'evening
16:15:24 <DRMacIver> ddarius: It's mostly an instainctive reaction. :)
16:15:28 <oerjan> o_O
16:15:28 <DRMacIver> Hi chessguy 
16:15:41 <chessguy> !paste
16:15:41 <hpaste> Haskell paste bin: http://hpaste.org/
16:17:15 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/1642
16:17:57 <bos> chessguy: i owe you an email, and i haven't forgotten about it
16:18:21 <chessguy> no problem
16:18:37 <chessguy> i've tried to get some of the tools working, but haven't managed yet
16:19:47 <hpaste>  chessguy pasted "What data structure would you use to manage a collection of these widgets?" at http://hpaste.org/1643
16:20:41 <chessguy> suppose you had a very large number of widgets, and you wanted to be able to quickly get the widgets with a particular shape, or a particular size, or whatever
16:20:53 <chessguy> what data structure would you use?
16:21:09 <oerjan> relational database?
16:22:03 <chessguy> well
16:22:04 <chessguy> ok
16:22:21 <chessguy> but suppose you had to actually implement the relational db
16:23:22 <ddarius> That'd would be fun as heck!
16:24:01 <DRMacIver> chessguy: Is this 'or whatever' intended to be decidable at runtime or is it just some specific property?
16:24:20 <DRMacIver> i.e. do we have a few dozen properties and need to select by any of them?
16:24:35 <chessguy> it doesn't need to be dynamic
16:24:54 <ddarius> What about updating?
16:25:25 <spurion> Good evening!
16:25:43 <spurion> Does anyone understand the significance of this error message:
16:25:47 <chessguy> ddarius, i'm not as concerned with the efficiency 
16:25:50 <chessguy> of updating
16:25:54 <oerjan> well, a map for each possible query, keyed on the result
16:25:57 <spurion> Bad interface file: /usr/local/lib/ghc-6.6.1/imports/GHC/Unicode.hi-boot         /usr/local/lib/ghc-6.6.1/imports/GHC/Unicode.hi-boot: openBinaryFile: does not exist (No such file or directory)
16:26:01 <DRMacIver> I'm struggling to think why the answer isn't just "Keep a bunch of Data.Map instances around". :)
16:26:36 <chessguy> well, i may want to search on multiple keys too
16:26:48 <chessguy> hm, i'm not explaining this very well
16:27:04 <Cale> spurion: I've never seen that before. Let me check if I have that file in my installation.
16:27:14 <spurion> I'm on OS X
16:27:26 <DRMacIver> chessguy: Searching on multiple keys is just searching on single keys then doing an intersection, surely?
16:27:43 <spurion> I've found a small explanation from spj in January, in a patch description
16:27:45 <oerjan> well, you can search the map for the key that is expected to give the fewest matches, then filter the matches
16:27:54 <chessguy> drmacIver, sure, but i'm guessing there are more efficient ways
16:28:16 <Cale> spurion: hmm, no, I don't have any hi-boot files in the corresponding dir, but then again, I'm running a slightly different ghc
16:28:23 <spurion> I have none either
16:28:43 <Cale> spurion: Did GHC ever work, or are you just installing it now?
16:28:53 <DRMacIver> chessguy: Hm. You could do a combination of this and oerjan's suggestion.
16:29:15 <DRMacIver> chessguy: Pick one, lookup on that. If it's 'small enough' just filter the remainder, else pick another and intersect it with what you've got so far.
16:29:20 <DRMacIver> Wash, rinse, repeat.
16:29:44 <DRMacIver> (Explicitly memoising the lengths so you're storing a Map PropertyType (Integer, [Widget]) might be worthwhile)
16:29:55 <SamB> @hoogle IOError
16:29:58 <spurion> cale: I've just realised what's causing it
16:30:00 <lambdabot> Prelude.IOError :: type IOError
16:30:00 <lambdabot> Prelude.ioError :: IOError -> IO a
16:30:00 <lambdabot> System.IO.Error.IOErrorType :: data IOErrorType
16:30:01 <oerjan> er, i don't see how the intersection is more efficient than filtering one map
16:30:05 <SamB> @hoogle try
16:30:05 <lambdabot> IO.try :: IO a -> IO (Either IOError a)
16:30:05 <lambdabot> Control.Exception.try :: IO a -> IO (Either Exception a)
16:30:05 <lambdabot> Text.ParserCombinators.Parsec.Prim.try :: GenParser tok st a -> GenParser tok st a
16:30:13 <spurion> cale: I'd copied some source code, containing this line:
16:30:27 <spurion> import {-# SOURCE #-} GHC.Unicode ( isSpace  ) 
16:30:44 <spurion> and it's the SOURCE pragma that's giving trouble
16:30:50 <oerjan> unless there is some algorithm i don't know (not unlikely)
16:30:59 <SamB> @hoogle IO a -> IO (Either IOError a)
16:31:00 <lambdabot> IO.try :: IO a -> IO (Either IOError a)
16:31:35 <SamB> what happened to IO.try in the great heirarchicalization?
16:31:47 <DRMacIver> oerjan: Hm. Fair point. Maybe there's something sensible you can do if you store this in a Set rather than a List.
16:31:48 <ddarius> @hoogle try
16:31:49 <lambdabot> IO.try :: IO a -> IO (Either IOError a)
16:31:49 <lambdabot> Control.Exception.try :: IO a -> IO (Either Exception a)
16:31:49 <lambdabot> Text.ParserCombinators.Parsec.Prim.try :: GenParser tok st a -> GenParser tok st a
16:32:03 <chessguy> oerjan, no, i said that the intersection is less efficient
16:32:22 <DRMacIver> I think he was talking to me (I suggested a hybrid approach)
16:32:46 <ddarius> If you wanted to go crazy, you could simultaneously index on multiple attributes.
16:32:55 <chessguy> i'd like an arbitrary query to be O(log n) where n is the number of entries
16:33:00 <chessguy> err, widgets
16:33:16 <DRMacIver> Hm. ddarius's idea is a good one if the number of properties isn't too large.
16:33:38 <chessguy> ddarius, how would i go about that?
16:33:52 <DRMacIver> Data.Maps again, using the Ord instance on tuples.
16:34:02 <SamB> hmm, is anyone familiar with StrategyLib?
16:34:30 <chessguy> ddarius, i'm not sure i understand what you mean by "simultaneously index"
16:35:10 <Heffalump> spurion: it's very unlikely you should be doing {-# SOURCE #-} for an external library
16:35:14 <Heffalump> try removing that
16:35:18 <oerjan> chessguy: a key that is a tuple of a subset of your keys
16:35:29 <Heffalump> it's intended to resolve recursive imports
16:35:41 <Heffalump> but that library shouldn't ever be importing your code, so there's no need for it..
16:36:01 <Cale> spurion: what happens if you remove that pragma?
16:36:32 <Cale> spurion: I don't even think the SOURCE pragma is documented.
16:39:11 <dibblego> http://haskell.org/ghc/docs/latest/html/users_guide/pragmas.html doesn't seem to be
16:39:12 <lambdabot> Title: 7.10. Pragmas
16:41:39 <spurion> Cale: if I remove the pragma, all is mostly well. I'd made a copy of ReadP for experimental purposes, but hadn't realised that it has tweaks that expect it to be compiled as part of the system libraries.
16:42:01 <spurion> I also had to import Data.Char (isSpace) instead of GHC.Unicode (isSpace).
16:42:38 <Heffalump> oh, right, I hadn't twigged you were importing GHC.something
16:42:45 <Heffalump> normally you shouldn't do that
16:44:31 <spurion> I hadn't twigged either! It was there when I copied it!
16:49:59 <desp> twigged?
16:52:35 <spurion> http://dictionary.reference.com/browse/twig
16:52:36 <lambdabot> Title: twig - Definitions from Dictionary.com
16:52:53 <edwardk> *Control.Monad.Parameterized> return 2 >>= \x -> return (5*x) >>= \x -> [x,x+1] >>= \x -> if even x then Just x else Nothing   ===> [10]    whoa its actually working
16:52:54 <spurion> sense 2, number 3
16:53:11 <desp> fascinating
16:53:20 <spurion> desp: you asked...
16:53:24 <desp> thank you, although I should've looked it up myself
16:53:42 <dcoutts> @seen cladhaire
16:53:42 <lambdabot> cladhaire has changed nick to clad|away.
16:53:42 <lambdabot> I saw clad|away leaving #haskell 27m 7s ago, and .
16:53:44 <hpaste>  dibblego pasted "funDeps" at http://hpaste.org/1644
16:53:54 <dcoutts> @tell cladhaire congratulations!
16:53:54 <lambdabot> Consider it noted.
16:54:13 <desp> spurion: sorry, didn't mean to appear sarcastic :)
16:54:33 <spurion> desp: np :-)
16:56:20 <spurion> Goodnight!
16:58:34 <hpaste>  dolio annotated "funDeps" with "fundeps" at http://hpaste.org/1644#a1
16:59:12 <dibblego> ah thanks
16:59:16 <dibblego> yes it is later
17:13:29 <dons> ?users
17:13:29 <lambdabot> Maximum users seen in #haskell: 355, currently: 299 (84.2%), active: 14 (4.7%)
17:21:48 <hpaste>  dibblego pasted "runState" at http://hpaste.org/1645
17:23:30 <TSC> dibblego: Remember that a field accessor takes its type as its argument
17:23:56 <dibblego> yeah, I just realised I was looking at it as a type-class
17:27:15 <ajay> I'm trying to find programs to look at to see if I can make sense of them, I looked at some of the programs on Don's blog but none of them really make sense to me. Are there any pages that show how to build an a small tool that does something interesting but explains most of the steps along the way?
17:29:02 <ajay> I don't really have any programming experience at all, but I'm interested in Haskell because it seems to have a lot similar to math, which I study
17:29:19 <EvilTerran> @where tutorial
17:29:19 <lambdabot> http://www.haskell.org/tutorial/
17:29:28 <EvilTerran>  /\ not complete programs, but a good place to start
17:29:42 <puusorsa> having no prior programming experience probably makes learning haskell easier
17:29:57 <ajay> hmm
17:30:02 <edwardk> @hpaste
17:30:02 <lambdabot> Haskell pastebin: http://hpaste.org/new
17:30:06 <dibblego> puusorsa, my observations suggest that is definitely the case
17:30:20 <puusorsa> less stuff to unlearn first
17:30:30 <dibblego> puusorsa, I agree completely
17:30:48 <EvilTerran> i had very little trouble adapting to functional/lazy programming, even tho my prior experience was mostly C, perl, and (*shudder*) VB6
17:31:05 <hpaste>  edwardk pasted "parameterized monad trick" at http://hpaste.org/1646
17:31:20 <edwardk> anyone feel like toying with the monad laws for a minute?
17:31:36 <edwardk> i'm going to write up a blog post about this in a bit, but i wanted some other eyes looking at it
17:32:42 <edwardk> woops it got cut fof
17:33:38 <hpaste>  (anonymous) annotated "parameterized monad trick" with "(no title)" at http://hpaste.org/1646#a1
17:34:17 <edwardk> anyways in ghci that should alow the weird examples i've been pasting into channel today to work
17:35:21 <edwardk> unfortunately, the do-sugar seems to assume that bind has type (...) => m a -> (a -> m b) -> m b where the m's are all the same so the parameterized monad code doesn't work with the do-sugar.
17:37:06 <EvilTerran> could one write some TH or sth to sneak in and desugar do{...}s to this instead of standard Monads?
17:37:28 <edwardk> probably using the same ugly hackery as eric kidd's original restricted monad post
17:37:51 <edwardk> i don't find the >>= \x ->    version of everything to be that abhorrent, but i had assumed it would work with the do-sugar when i was done =(
17:38:39 <dolio> edwardk: Both pastes get cut off at the same point. It restricts the size of each paste.
17:38:43 <edwardk> gah
17:38:49 <edwardk> ok, posting it up to my machine
17:40:21 <edwardk> i wasn't planning on building a darcs repo yet so, i'll just give a quick hackish url http://comonad.com/Parameterized.hs
17:41:37 <edwardk> to use it, theoretically just use the normal monad syntax with 'return' replaced with returnM unless you want to give the return an explicit signature
17:42:49 <edwardk> if you need to force the result to a particular monad use 'go' so it would have been go $ do ...    
17:43:20 <edwardk> because otherwise returnM will drop you in Identity and unless you use particular monadic actions to force a monad specific type you stay there
17:44:15 <edwardk> nice bits are that runs of non-state actions in a state monad don't pass the state around at all, similarly non-IO actions in the IO monad, etc.
17:44:34 <ajay> hmm, the thing is that http://www.haskell.org/tutorial/ doesn't seem to have any exercises which makes it hard to actually understand what they are talking about when I see it in other code
17:44:34 <lambdabot> Title: A Gentle Introduction to Haskell, Version 98
17:44:35 <dibblego> are there plans to ever make lambdabot sane to (attempt to) compile?
17:45:10 <cbrad> trying to compile lambdabot (source from darcs)
17:45:19 <cbrad> Lib/Parser.hs:7920:4: Not in scope: `as_name'
17:45:26 <cbrad> Lib/Parser.hs:7926:4: Not in scope: `qualified_name'
17:45:30 <cbrad> etc
17:45:34 <cbrad> any ideas?
17:45:55 <cbrad> i am using ghc 6.6.1
17:48:06 <EvilTerran> ajay, you could have a flick through http://haskell.org/haskellwiki/Learning_Haskell#Tutorials , too
17:48:08 <lambdabot> Title: Learning Haskell - HaskellWiki
17:48:56 <ajay> hmm
17:49:07 <ajay> some of these look interesting, thanks
17:50:17 <dolio> edwardk: I'm not sure how I feel about all that. :)
17:50:31 <dibblego> @seen dons
17:50:31 <lambdabot> dons is in #haskell-soc, #xmonad, #haskell and #ghc. I last heard dons speak 37m 2s ago.
17:50:40 <dons> is andrew coppin the sign of an eternal september for haskell?
17:50:45 <EvilTerran> np.
17:50:57 <edwardk> dolio: heh
17:51:01 <EvilTerran> andrew coppin?
17:51:12 <dibblego> the Set Theory guy on Haskell-Cafe
17:51:25 <edwardk> dolio: i needed a way to pass around a parameterized monad for other things, the normal instances are just to test the laws
17:51:28 <dons> the um, guy, anyway
17:54:24 <Shimei> An eternal september of one. That is a pretty impressive burden he has. ;)
17:54:49 <dons> I wonder if he is the sign that eternal September has begun
17:54:50 <dolio> He doesn't seem particularly shy about asking questions about, well, any topic on the list. :)
17:55:04 <dolio> And commenting on everything. :)
17:55:05 <dons> and responding with "LOLZ!? !!11!" too
17:55:23 <Shimei> I think that is a good thing. Except for the "LOLZ." Some of the replies to his e-mails have been useful for me anyway.
17:55:25 <Pseudonym> If Haskell is to take over the world, we need to go through the fanboy stage.
17:55:36 <Pseudonym> It's a rite of passage.
17:55:37 <dons> yeah, enthusiasm. hmm
17:55:49 <Pseudonym> And let's be fair.  He seems to have written a LOT of toy code.
17:55:53 <Cale> Please not yet. ($) doesn't have the correct associativity yet ;)
17:55:54 <dons> yes.
17:55:57 <Pseudonym> Which is a rite of passage for a Haskell programmer.
17:56:09 <Pseudonym> Cale: Preach it, brother!
17:56:21 <Shimei> One would hope writing code is a rite of passage for any programmer.
17:56:30 <SamB> how do you tell toy code from serious code?
17:56:32 <dons> i did just suggest to him then to work a bit on signal/noise, politely (I hope).
17:56:35 <dons> its a delicate issue
17:56:39 <Pseudonym> Yeah, but Haskell encourages you to attempt really hard things.
17:56:44 <Pseudonym> Like PPM.
17:56:52 <Pseudonym> Can you imagine a newbie C programmer trying that?
17:56:56 <dons> making the impossible happen, eh? :)
17:56:57 <edwardk> http://comonad.com/haskell/monad-param/dist/doc/html/Control-Monad-Parameterized.html has been built
17:56:59 <lambdabot> http://tinyurl.com/235dzh
17:57:06 <edwardk> baking it all into a darcs repo
17:57:16 <dons> edwardk: going to upload it to hackage to please?
17:57:24 <edwardk> dons: as soon as its a little more stable
17:57:28 <Shimei> Hehe, newbie C programmers drown in pointers.
17:57:30 <dons> i can has comonad?
17:57:35 <edwardk> =)
17:57:36 <dons> sorry :}
17:57:42 <Pseudonym> The Force tells me that Andrew Coppin will be a valuable ally some day, when he can be turned.
17:57:45 * Shimei has had the pleasure of trying to teach high school kids C, or at least attempting
17:57:55 <Pseudonym> He just needs a slight attitude readjustment.
17:58:02 <dons> Pseudonym: there's always the threat of spectacular implosion too.
17:58:05 <Pseudonym> And no, you may not ?quote me on that.
17:58:09 <Cale> edwardk: MonadElse ?
17:58:09 <dons> joelr is an example of that
17:58:23 <edwardk> cale: ?
17:58:25 <dons> fanboy, turned #1 blog citation for haskell's not practical 
17:58:45 <Cale> http://www.haskell.org/haskellwiki/MonadPlus_reform_proposal
17:58:45 <lambdabot> Title: MonadPlus reform proposal - HaskellWiki
17:58:50 * Pseudonym nods
17:59:05 <dons> Pseudonym: did you see my hmm, hopefully cautious, reply just now on the mailing list?
17:59:08 <Pseudonym> The problem here is that his AOL-style replies would be perfectly okay on Usenet.
17:59:10 <Pseudonym> Yeah, I did.
17:59:12 <Excedrin> Cale: I recall that you've mentioned "a . b . c $ d" is better somehow than "a $ b $ c $ d" but I don't really get it, mind restating it?
17:59:18 <Cale> Excedrin: sure
17:59:19 <Pseudonym> I found it gentle enough.
17:59:22 <dons> ok. good
17:59:26 <edwardk> ah yeah, the MonadZero kind of arised from the fact that it had to be split for the same reasons you have to rip apart Return and Bind in a restricted monad
17:59:29 <Pseudonym> Unfortunately, mailing lists are not Usenet.
17:59:36 <Pseudonym> Even though they can sometimes seem like that.
17:59:39 <Cale> (b . c) is going to be a valid expression in that, so is (a . b . c)
17:59:47 <Cale> they'll be well-typed and meaningful
18:00:00 <edwardk> so i don't see a real reason why not to add the MonadOr kind of stuff
18:00:01 <Cale> (b $ c) isn't, and neither is (a $ b $ c)
18:00:12 <B4K4p4nTsU> what happened to xerox/paolo?
18:00:23 <B4K4p4nTsU> why isn't he doing his soc project!
18:00:39 <dons> @seen xerox
18:00:39 <lambdabot> xerox is in ##logic, #perl6, #haskell-overflow, #haskell-blah and #haskell. I don't know when xerox last spoke.
18:00:45 <Cale> Also, if ($) had the opposite associativity, we could deparenthesise more expressions
18:01:06 <Shimei> Pseudonym: I wasn't really around when Usenet was in its prime. What's the attitude difference between them and MLs and IRC?
18:01:08 <Cale> (a strict superset, since we can use (.) in all the cases where we're currently using more than one ($)
18:01:09 <Cale> )
18:01:24 <dons> Cale, perhaps put a module on hackage definining (#) or something for this 
18:01:28 <dons> and see if people start using it :)
18:01:38 <Cale> In particular, things like a (b x) (c y) (d z)
18:01:50 <Cale> Could be written as:  a $ b x $ c y $ d z
18:02:01 <dolio> And you can do things like "a $ b $! c $ d" to strictify selective parameters.
18:02:04 <Cale> yes
18:02:12 <Cale> That in particular would be nice :)
18:02:19 <Pseudonym> Though in that case, a b $! c $ d also works.
18:02:20 <Excedrin> oh! ok, that makes sense. I've run into that before without really understanding why I couldn't use $
18:02:33 <dons> mmm, nice fonts, http://nitens.org/taraborelli/latex
18:02:36 <lambdabot> Title: Dario Taraborelli: The beauty of LaTeX
18:02:43 <Pseudonym> The trouble is that I find myself wanting to strictify leftmost arguments more than rightmost arguments.
18:02:59 <Shimei> dons: I was surprised by #4 on that. Those ligatures are neat.
18:03:03 <Pseudonym> Because, like a good lambda calculist, I tend to use a De Brujin-like ordering.
18:03:31 <ajay> main = do args <- getArgs
18:03:32 <ajay>           args2 <- getArgs
18:03:32 <ajay>           putStrLn ("Hello, " ++ args !! 0)
18:03:32 <ajay>           putStrLn ("Hello, " ++ args2 !! 0)
18:03:36 <Pseudonym> The more "const" an argument is, the further left it goes.
18:03:39 <Cale> dons: yeah :)
18:03:42 <dons> Shimei: is it a feature of XeTeX (interfacing with the mac?) 
18:03:48 <ajay> I'm trying to write a piece of code that takes two arguments from the command line
18:03:55 <Pseudonym> And the more likely it is to be evaluated at the top level, the further right it goes.
18:03:56 <dons> I couldn't tease out how much of that stuff is the XeTeX / mac font package
18:03:58 <Cale> dons: Even just Computer Modern Roman is incredibly beautiful.
18:04:11 <dolio> Pseudonym: Does $! associate left now?
18:04:24 <Pseudonym> dolio: No.
18:04:32 <Pseudonym> f $! g $! x = f $! (g $! x)
18:04:32 <Cale> dolio: No, it's extremely irritating.
18:04:47 <ajay> and then print two lines, saying hello to each of the arguments
18:04:49 <Cale> If you want to strictify multiple parameters, you end up with lots of awkward parens.
18:04:51 <Shimei> dons: I'm not sure. I'm not much of a tex expert myself. I'd never seen them in tetex though.
18:05:04 <ajay> but when I run it, it uses the first argument for both lines
18:05:05 <chessguy> @hoogle prefix
18:05:05 <lambdabot> Distribution.Simple.Configure.prefix :: LocalBuildInfo -> FilePath
18:05:05 <lambdabot> Data.Generics.Basics.Prefix :: Fixity
18:05:05 <lambdabot> Text.ParserCombinators.Parsec.Expr.Prefix :: GenParser t st (a -> a) -> Operator t st a
18:05:13 <dolio> Right, okay, that's what I though.
18:05:31 <dolio> So 'a b $! c $ d' isn't currently right.
18:05:38 <chessguy> @hoogle isPrefixOf
18:05:38 <lambdabot> List.isPrefixOf :: Eq a => [a] -> [a] -> Bool
18:05:43 <Pseudonym> The thing about De Bruijn ordering is important, IMO.
18:05:46 <Pseudonym> Consider:
18:05:47 <Pseudonym> :t foldl'
18:05:49 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
18:05:53 <Pseudonym> foldl op r xs
18:05:57 <Pseudonym> foldl', sorry
18:06:08 <Pseudonym> If you're implementing that, it's the "r" argument that you need to strictify.
18:06:09 <Pseudonym> Not the "xs".
18:06:32 <Pseudonym> foldl' is already strict in the last argument by virtue of having a top-level case match on it.
18:06:32 <chessguy> @type any
18:06:34 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
18:06:36 <dons> ?where+ decimal http://www.n-heptane.com/nhlab/repos/Decimal/
18:06:36 <lambdabot> Done.
18:06:42 <dons> ^^ stepcut's decimal/money lib
18:06:51 <dibblego> Pseudonym, you think r and xs should be switched?
18:06:54 <Pseudonym> stepcut++ -- money!
18:06:57 <Pseudonym> dibblego: No!
18:06:59 <Pseudonym> Definitely not!
18:07:06 <Pseudonym> Induction arguments go last.
18:07:09 <chessguy> @pl \x xs = if (null xs) then False else any (x `isPrefixOf`) (tails xs)
18:07:09 <lambdabot> (line 1, column 7):
18:07:09 <lambdabot> unexpected "="
18:07:09 <lambdabot> expecting pattern or "->"
18:07:12 <Pseudonym> So you can curry them.
18:07:20 <chessguy> @pl \x xs -> if (null xs) then False else any (x `isPrefixOf`) (tails xs)
18:07:20 <dibblego> Pseudonym, then what is your point?
18:07:21 <lambdabot> ap (flip if' False . null) . (. tails) . any . isPrefixOf
18:07:36 <EvilTerran> ?type getArgs
18:07:37 <Pseudonym> foldl' (+) 0 is more useful than \xs -> foldl' (+) xs 0
18:07:38 <lambdabot> Not in scope: `getArgs'
18:07:49 <EvilTerran> ?type System.IO.getArgs
18:07:51 <lambdabot> Not in scope: `System.IO.getArgs'
18:07:54 <chessguy> ugh, isn't this function defined somewhere?
18:07:55 <Pseudonym> But it's the second argument which needs to be made strict, not the third.
18:08:01 <Pseudonym> That's my point. :-)
18:08:12 <Pseudonym> And foldl' isn't an isolated case.
18:08:42 <Pseudonym> When you're making a recursive function, the induction argument should go last for better currying.
18:08:43 <chessguy> @srx isInfixOf
18:08:43 <lambdabot> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
18:08:58 <chessguy> yeah, that would be the one
18:09:05 <Pseudonym> But that's the argument which needs to be strictified the _least_.
18:09:06 <ajay> ?type System.Environment.getargs
18:09:08 <lambdabot> Not in scope: `System.Environment.getargs'
18:09:42 <Cale> In general, you should always order parameters to a function such that they are expected to vary increasingly rapidly.
18:09:58 <Pseudonym> Yeah.
18:10:04 <edwardk> dons: gah to add it to hackage it would appear I need to get a username, etc. for now http://comonad.com/haskell/monad-param/ contains http://comonad.com/haskell/monad-param/dist/monad-param-0.1.tar.gz
18:10:05 <lambdabot> Title: Index of /haskell/monad-param
18:10:05 <Cale> Things which are "almost constants", configuration and such, go first.
18:10:19 <edwardk> i'll send off the email to get a username now
18:11:18 <Cale> I'm not sure I care to have things split up *quite* as much as that.
18:11:21 <dons> edwardk: i can get you a user name
18:12:20 <edwardk> dons: sounds good to me
18:12:31 <dons> privmsg.
18:13:55 <Cale> What's the idea behind having the underlying functor different in each of the parameters and the result of bind?
18:15:01 <Cale> So join :: m (m' a) -> m'' a ?
18:15:40 <dons> Pseudonym: any thoughts on how we can encourage him not to reply with `That almost made sense most of the way through... but... ooouch... x_x' 
18:15:57 <Cale> dons: what's the issue?
18:16:09 <ddarius> dons: Explicitly say that such responses are useless.
18:16:20 <dons> oh, just redirecting A Coppin's energies into more productive avenues
18:16:21 <Cale> heh
18:16:25 <dons> before my inbox explodes
18:16:41 <ddarius> Or more effectively, "Sit down, shut up and read some books, papers and articles."
18:16:49 <ddarius> That should get him to post a whole lot less.
18:16:58 <Pseudonym> dons: I can only think of one thing, and that's set up a web forum.
18:17:10 <dons> hmm, no we don't want to be rude, and he is writing code. we just need to show him that he's expected to search for answers 
18:17:27 <dons> `What the heck is an arrow when it's at home?' for example
18:17:29 <Pseudonym> Oh, I know!
18:17:44 <dons> he should really be here, and i've asked him explicitly twice now
18:17:46 <Pseudonym> How about we encourage the "send replies directly and I'll summarise" model?
18:17:55 <dons> but he replies that its too quiet in here.
18:18:05 <Cale> haha
18:18:06 <Pseudonym> Err...
18:18:09 <EvilTerran> this is the most active IRC channel i'm in...
18:18:13 <Pseudonym> Yeah, because we talk about him!
18:18:14 <ddarius> Pseudonym: I'm pretty sure some people have been replying to him off-list.
18:18:21 <Pseudonym> Yeah.
18:18:26 <Cale> Yeah, me too, by probably about double the traffic
18:18:49 <ddarius> Pseudonym: But he seems (or maybe I'm missing some emails?) to add haskell-cafe back.
18:19:20 <ddarius> All the channels I'm in are mostly full of #haskell people anyways.
18:19:28 <EvilTerran> and if you take signal-to-noise into account, the difference is even more pronounced.
18:20:32 <Pseudonym> As I said, I think I'd tolerate him more if this were Usenet.
18:20:41 <Pseudonym> Where killing whole threads is easier.
18:20:44 <Shimei> I suppose it might be quiet here for certain timezones. I wonder what his is?
18:20:58 <dons> ?seen allbery_b
18:20:58 <lambdabot> allbery_b is in #xmonad, #perl6, #haskell-overflow, #haskell-blah, #haskell and #ghc. I last heard allbery_b speak 14h 55m 51s ago.
18:21:12 <dons> allbery_b: around?
18:21:29 <B4K4p4nTsU> ?seen m4st3r_b41t3r
18:21:29 <lambdabot> I haven't seen m4st3r_b41t3r.
18:21:47 <EvilTerran> what's #haskell-overflow?
18:22:03 <Cale> B4K4p4nTsU: what's the deal with l33t-5p34k nicks anyway? What is this, 1994?
18:22:10 <sm> http://blog.wolfram.com/2007/06/symbolic_programming_computati.html is a rather nice article on mathematica's language
18:22:11 <dons> B4K4p4nTsU: is there any chance you can pick a more intuitive nick? I'm not sure about the others, but it looks almost hostile, which might be miscontstrued. :/
18:22:12 <lambdabot> Title: Wolfram Blog: Symbolic Programming: Computationally Active Language, http://tinyurl.com/ypzoyl
18:22:31 <dons> certainly it led to confusion yesterday.
18:22:42 <sm> can someone say how/if this differs in essence from lisp or haskell
18:22:42 <gmh33> B4K4pantsU = stupid underwear ?
18:22:43 <sm> ?
18:23:12 <allbery_b> dons: yep
18:23:15 <Shimei> It's like Japanophilia + script-kiddy. A marvelous mix. ;)
18:23:16 <ddarius> EvilTerran: It says in the topic.
18:23:17 <Cale> sm: Pretty greatly.
18:23:21 <allbery_b> (scrambling around, but around :)
18:23:22 <dons> interesting, http://logiweb.eu/
18:23:24 <lambdabot> Title: Logiweb home page
18:23:28 <EvilTerran> ddarius, oh, okay.
18:23:30 * EvilTerran /lists
18:24:01 <Cale> sm: It's pretty much an untyped pattern-matching tree-rewriting language.
18:24:05 <dons> allbery_b: so my goal here is to encourage Andrew to not reply with things like `what's an arrow?' or 'my head hurts', since it just creates noise on the list. any thoughts? :)
18:24:15 <dons> oh, interesting: http://logiweb.eu/
18:24:15 <lambdabot> Title: Logiweb home page
18:24:24 <dons> Logiweb is an open source system available under GNU GPL for
18:24:25 <dons>     * Web publication of mathematical definitions, lemmas, and proofs
18:24:25 <dons>     * Verification of formal proofs
18:24:25 <sm> aha.. and with lazy evaluation ?
18:24:28 <allbery_b> heh
18:24:32 <Cale> Well, not completely untyped. It just fails to reduce things if they're the wrong types to evaluate.
18:24:37 <Cale> No, it's strict.
18:24:39 <ddarius> dons: Say that explicitly.
18:24:43 <Cale> But you can do funny things.
18:24:49 <allbery_b> need a haskell-chatter mailing list, maybe?
18:25:06 <dons> no, i think we can just explain he's crossing the boundary a bit.
18:25:11 <ddarius> "Andrew Coppins, replies like 'What's an arrow?' or 'my head hurts' just create noise on the list."
18:25:12 <Cale> Like, for example, you can define a value x such that Cos[x] == 2, and make that part of the definition of x, not of Cos.
18:25:21 <EvilTerran> dons, suggest that the man get a blog. he can link his posts on the mailing list if he must, and that way people can reply to him off-list and still in public.
18:25:22 <allbery_b> the lopsa lists work a bit bettre when the tech talk is on -tech and the noise on -discuss
18:25:40 <dons> ddarius: ok, i think i'll try to be both polite, constructive, and more direct
18:25:44 <allbery_b> that said, it's easier to deal on the list than, say, here :)_
18:25:54 <Cale> And you can do lazy-evaluation-like things by defining special forms.
18:25:55 * EvilTerran is just thinking aloud
18:26:01 <ddarius> Yay more direct!  Life is always easier if you are more direct.
18:26:33 <Shimei> Well, unless you are in politics.
18:26:36 * EvilTerran -> sleep
18:26:38 <sm> I see. they sure seem productive with it..
18:26:38 <Cale> It's also got some really funky stuff in it, like, there's a global writer-monad-like thing.
18:26:54 <Cale> Called Reap and Sow
18:27:03 <ddarius> Shimei: If -everybody- were more direct, it would be true in politics too.  Even now I'm not so sure that it isn't.
18:27:09 <dons> ddarius: i don't like being a the mean parent. :/
18:27:13 <sm> the latest stuff sounds like functional reactive programming (eg conal eliott's stuff ?)
18:27:21 <dons> the kids will run off to mum for support.
18:27:28 <ddarius> dons: You aren't being mean in any way.
18:27:45 <Cale> mm, sort of. It's all very scary though if you look too close :)
18:27:48 <ddarius> Want me to do it for you? (The answer is probably, "no".)
18:27:51 <allbery_b> shimei: seems to me politics would be a lot more bearable if it were more direct
18:27:55 <dons> no. please don't, ddarius :)
18:28:00 <dons> i can play nice.
18:28:24 <Pseudonym> dons: Maybe it'd be better if you did it off-list.
18:28:37 <ddarius> No!
18:28:41 <dons> yes, that's a good point. sometimes i forget about that.
18:28:45 <Pseudonym> You've already sent the one message to the list, so the rest of the list knows someone is taking action.
18:28:52 <Cale> Like, it's a beautiful system, in that it has such a rich set of operations and effects, but it can be really hard to fully understand everything that can go on, and there are very few real guarantees.
18:28:52 <Shimei> allbery_b: Oh, I agree. But the status quo is hard to turn.
18:28:53 <sm> Cale, scary as in unclean ? inconsistent ? or do you mean because it's untyped ?
18:28:55 <ddarius> Well, in that case.  
18:29:03 <sm> aha
18:29:07 <dons> yep. i'll just clarify for Andrew in person what the issue is.
18:29:16 <ddarius> I wouldn't have a conversation about it on list, but I would want the initial email to be on list.
18:29:23 <Pseudonym> Right.
18:29:26 <ddarius> dons: "in person" ?
18:29:27 <Pseudonym> Well, that's already done.
18:29:57 <dons> yes, the public action has occured
18:30:08 <dons> and i'll just elaborate my concerns to him in private
18:30:08 * sm votes for on-list; simpler
18:30:19 <Cale> There are some basic ideas though, which will get you most of the way there for 99% of the code you're likely to write or run into in practice, but the semantics of that last 1% can be completely insane.
18:30:33 <Pseudonym> I wonder if we might need semi-official moderators.
18:30:50 <ddarius> Pseudonym: We have them.
18:30:52 <Pseudonym> A group of people who decide amongst themselves who is going to wield the clue bat with each person.
18:31:06 <Pseudonym> Yeah, but they just de-spam, don't they?
18:31:07 <dibblego> I'm with ddarius - more direct - if I was being a knob head, I'd want someone to say "you're being a knob head" and not morph that reality to appeal to any "feelings" or "political correctness"
18:31:07 <Cale> He's likely to calm down over time.
18:31:15 <Pseudonym> We need official clue installers.
18:31:30 <Cale> I'd probably just ignore the threads, like I've been ignoring most of the threads :)
18:31:31 <ddarius> Cale: People want him to "calm down" now.
18:31:45 <sm> they should speak up :)
18:32:05 <Cale> Every day or two, I just do a "select all -> archive" on anything which I haven't looked at.
18:32:15 <Shimei> dibblego: The trouble is that I think non-knob-heads are the ones who think that. Not that all knob heads don't.
18:32:49 <ddarius> sm: The Haskell community is sometimes "too" nice.  Further, it's best when people with a lot of "street cred" say it.  People with less experience with the community are not.
18:33:02 <Pseudonym> sm: No they shouldn't speak up!
18:33:06 <Pseudonym> That'd be more noise.
18:33:07 <dons> Pseudonym: right, so this is the clue installation phase.
18:33:13 <dons> we have a policy page for the irc channel
18:33:20 <dons> and some other community maintainance issues
18:33:23 * Pseudonym nods
18:33:27 <ddarius> Pseudonym: Part of why having the initial "Shut up" email on list is helpful.
18:33:27 <dons> but perhaps there should be something specific for the mailing list
18:33:29 <dibblego> I think "clue installation" is an optimistic specialisation of the possibilities
18:33:38 <sm> it can be brief.. less noise in the long run imho
18:33:39 <Cale> Data.List.ImpredicativeChurchEncodingOfNuX.OnePlusATimesX -- hahaha
18:33:40 <dons> ddarius: that's occured already. i sent it 30 mins ago.
18:33:41 <Pseudonym> All I'm suggesting is that we have a few nominated people who are responsible for clue distribution.
18:33:45 <dons> Cale: :}
18:33:45 <sm> anyhow.. thanks for the info Cale
18:33:53 <dons> Pseudonym: yes, I think that's a good idea.
18:33:55 <Pseudonym> So taht the poor newbie isn't inundated with possibly semi-conflicting information.
18:33:56 <ddarius> dons: I agree for the most part.  I'm just stating the general fact.
18:34:01 <Shimei> ddarius: I like it leaning that way than off the other way though. I just saw a lisp thread on reddit where a person got called a troll for asking why SLIME is good for step-by-step development.
18:34:02 <dons> we had similar concerns about Bulat a couple of years ago, too.
18:34:17 <Cale> sm: I would *really* love to see a CAS with something like Haskell as the base language.
18:34:26 <ddarius> Cale: Where's that from?
18:34:28 <sm> absolutely
18:34:33 <Pseudonym> sm: Oh, you're working on CAS?
18:34:42 <sm> I'm not
18:34:44 <Cale> ddarius: "Proposal: Data.Stream" on Haskell-cafe
18:34:48 * sm just follows the axiom list
18:34:49 <Pseudonym> Oh, OK.
18:34:57 <Cale> er, no, haskell-libraries, sorry
18:35:00 * Pseudonym is working on symbolic integration at the moment
18:35:26 <Cale> In fact, I'd just like to see GAP reimplemented in Haskell.
18:35:27 <ddarius> Cale: Ah.
18:35:28 <sm> I would love to have some of those function libraries in haskell.. the dirt-simple graphical stuff in particular
18:35:54 <dons> so I'm encouraging him to make replies along these lines, http://www.haskell.org/pipermail/haskell-cafe/2007-July/028613.html
18:35:56 <lambdabot> Title: [Haskell-cafe] Simple newbie question - Int and Integer, http://tinyurl.com/24phax
18:36:20 <dons> and note these
18:36:21 <dons> http://www.haskell.org/pipermail/haskell-cafe/2007-July/028623.html
18:36:22 <lambdabot> Title: [Haskell-cafe] Very freaky, http://tinyurl.com/ysyzkm
18:36:23 <dons> s/not/
18:36:32 <Cale> GAP's base language sucks, but the computational group theory knowledge in that system is so incredibly useful.
18:37:14 <Pseudonym> Yes!  That's a good reply.
18:37:22 <ddarius> I've heard of GAP, but I don't think I ever considered toying with it.
18:39:50 <geezusfreeek> except it is the wrong answer… an Int is only guaranteed to be at least 30 bits, isn't it?
18:42:20 <cdsmith> geezusfreeek: That's really not the point though.  It's not a good idea to discourage people from posting helpful info.  There are more experienced people (sorear in this case) who will catch errors.
18:42:30 <dons> its reasonable, to a first approximation anyway
18:42:46 <geezusfreeek> i agree… i missed the point of saying it was a good reply i guess
18:43:22 <dibblego> the problem with misinformation is how easily it is propagatedf
18:43:34 <geezusfreeek> oh, i didn't really catch that it was corrected immediately
18:44:05 <dibblego> as long as those correcting it are around and are not an isolated minority, things should be fine
18:44:20 <dons> ok, sent my clarification to andrew
18:44:26 <dons> with examples of "good" and "bad" replies
18:44:35 * dons wields clue sticks around
18:44:46 * cdsmith shies back in fear
18:47:44 * shapr puts up the shield of skull density!
18:48:00 <cdsmith> Whew!  Thanks, shapr
18:48:14 <shapr> hiya dankna! How's code?
18:48:19 <cdsmith> I was afraid I'd get a clue if I didn't watch out.
18:48:24 * ddarius is starting to not like firefox.
18:48:25 <dankna> oh, heya shapr!  going pretty well.
18:48:37 <laz0r> quick question: the main differnce between 'data' and 'newtype' is that the former creates an algebraic type? which means basicly that it might be defined recursivly?
18:48:38 <shapr> cdsmith: Yeah, there are far too many clues running around here on #haskell, it's quite hard to stay out of their way.
18:49:08 <dibblego> laz0r, newtype accepts only one constructor with one type allowing certain optimisations
18:49:09 <Pseudonym> laz0r: You can think of "newtype" as an optimised "data".
18:49:27 <Pseudonym> Or you can think of it as a stricter "type".
18:49:28 <shapr> dankna: Written anything nifty lately?
18:49:32 <laz0r> yes, i found that out about a minute ago
18:49:36 <dons> http://headrush.typepad.com/photos/uncategorized/buildingausercommunity.jpg
18:49:39 <lambdabot> http://tinyurl.com/yx8uhc
18:49:40 <laz0r> that newtype only takes one constructor
18:49:48 <Saizan> ddarius: we should write a browser in haskell!
18:49:49 <laz0r> i wondered why
18:50:02 <Pseudonym> laz0r: Because it can be implemented as a no-op.
18:50:10 <shapr> Saizan: Yeah!
18:50:23 <shapr> dons: Whoa that's awesome!
18:50:24 <dankna> well, various stuff for work, but that's in C :) I'm still working on that boardgame-chat program as my project for learning Haskell on.
18:50:24 <dibblego> laz0r, imagine a String that is equal ignoring case; you'd write: newtype CaseInsensitiveString = CIS String then instance Eq CaseInsenseitiveString ...
18:50:39 <dankna> right now I'm bogged down in adding various functionality to the gui that I'd rather leave to later but that it isn't really useful until it's there.
18:50:52 <Saizan> one that doesn't lose my bookmarks and doesn't have hige space leak!
18:50:55 <shapr> dankna: Is there a darcs repo?
18:51:04 <shapr> Saizan: Space leaks never happen in Haskell, no problem!
18:51:18 <shapr> dons: Is that CC? I'd like to steal it for my own blog.
18:51:19 <Pseudonym> shapr: You're SO funny.
18:51:25 <dankna> oh - well, I could push it someplace public, if you wait a second.   you won't be able to run this version unless you're on a Mac, though.
18:51:26 <cdsmith> dons: I definitely like that link.
18:51:41 <shapr> dankna: Aww, I'm x86 linux only.
18:51:45 <Saizan> shapr: you sure?:)
18:52:02 <shapr> Saizan: Er, I think so?
18:52:05 <dankna> nod.  well, I have plans to eventually support that.
18:53:08 <dankna> it's not usable yet anyway, so.
18:54:21 <dons> http://www.cse.unsw.edu.au/~dons/tmp/cafe.png :)
18:54:36 * Saizan wonders how many locs would be a browser with tabs and support for extensions
18:54:40 <Alleria> Totally dumb question -- how do I convert a String into an integer?  read seems to be complaining...
18:54:41 <laz0r> dibblego, the question for me is: would 'data CIS = CIS String; instance Eq CIS where ...' work too
18:54:53 <laz0r> i think it should... but does it?
18:54:54 <dons> shapr: its from 
18:54:55 <dons> http://headrush.typepad.com/creating_passionate_users/2006/12/how_to_build_a_.html
18:54:57 <lambdabot> Title: Creating Passionate Users: How to Build a User Community, Part 1, http://tinyurl.com/y2jvu5
18:55:01 <Saizan> > read "1223" :: Integer 
18:55:03 <lambdabot>  1223
18:55:21 <geezusfreeek> at what point are you no longer considered a newbie or a beginner?
18:55:30 <Saizan> Alleria: read may need you to specify the type, if it's not inferrable from context
18:55:33 <ddarius> dons: The second for Andrew Coppins?
18:55:39 <Alleria> Saizan: ahh, thank you. That was the problem.
18:55:43 <Alleria> I had to feed it the type with a ::
18:55:46 <cdsmith> geezusfreeek: When you see questions that you can answer?
18:55:46 <Igloo> dons: Hmm, good to know it (-cafe traffic) wasn't just my imagination
18:57:40 <laz0r> a
18:57:47 <laz0r> oops
19:00:14 <dons> ddarius: yes, i've sent one in private, one in public, and am preparing a general 'help build the community' mail
19:00:19 <dons> since we hvaen't had one of those for 6 months or more
19:00:55 <dons> there's almost 2000 people on -cafe@ now.
19:01:05 <mm_freak> geezusfreeek: take problems which are trivial in imperative languages, and try to solve them functionally
19:01:21 <dolio> @remember grauenwolf (On predicates and the relational model) The definition of predicate is "the part of the sentence that makes the assertion about the subject." So predicates cannot be 'on' the attributes so much as 'about' the attributes.
19:01:21 <lambdabot> Done.
19:01:31 <mm_freak> if you have no problems doing that, then you can call yourself advanced, but not a professional
19:01:42 <sm> OT: I need help at http://clutu.com/game/779805429
19:01:44 <lambdabot> Title: clutu
19:01:57 <ddarius> geezusfreeek: You should be able to tell.
19:02:38 <mm_freak> yeah, and use functional programming as you're supposed to do
19:03:11 <mm_freak> it's possible to write your code in a pretty much imperative style, even in haskell (though it's just syntactic sugar)
19:03:35 <mm_freak> but real functional programming is expressive, elegant and easy to understand
19:04:37 <dons> who's Paolo's mentor for SoC?
19:05:35 <kilimanjaro> mm_freak, easy to understand has more to do with the author than "functional vs imperative"
19:05:48 <Shimei> dons: The website says Philippa
19:06:53 <mm_freak> kilimanjaro: not only…  in functional programming you define your goal, in imperative programming you define how to approach it, and just give the functions appropriate names
19:07:28 <kilimanjaro> mm_freak, yes?
19:07:57 <dynamix> Im having a tough time identifying the difference between . the function composition operator and the >>= bind operator?
19:08:11 <kilimanjaro> mm_Freak, would you say that recursion defines how to approach a goal
19:08:55 <kilimanjaro> i'd say that good programmers know when to use a particular style
19:09:24 <dynamix> (inc . double)  x or double x >>= inc ? 
19:09:28 <dynamix> for 2x+1
19:11:53 <dankna> since I'm not aware of standard functions called double and inc, I take it these are hypothetical functions?
19:11:56 <ddarius> :t (.)
19:11:59 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
19:11:59 <ddarius> :t (>>=)
19:12:01 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
19:12:53 <dons> just sent of a 'maintaing the community' once-yearly post
19:12:56 <dons> comments welcome
19:13:05 <dankna> (inc . double) x is "normal", having nothing to do with monads; it's the same as inc (double x)
19:13:07 <dons> Philippa: around?
19:13:57 <dons> lispy: btw, is your masters likely to lead to prototype implementations of path theories?
19:14:01 <dons> or direct improvement in darcs?
19:14:35 <Cale> dynamix: >>= is less like (.) and more like the flip of ($)
19:14:36 <mm_freak> kilimanjaro: that's a matter of view, probably…  it's just that it's easier to express things in haskell
19:14:44 <lispy> dons: direct work on darcs
19:14:50 <Pseudonym> Hey.
19:14:53 <Cale> (but it's not the same as that either)
19:14:57 <Pseudonym> Since when has Doug McIlroy been using Haskell?
19:15:01 <lispy> dons: we were doing something with a playground, but realized we just don't have the time
19:15:07 <dons> Pseudonym: oh?
19:15:09 <ddarius> Pseudonym: Since at least 98
19:15:12 <Pseudonym> Woo!
19:15:13 <kilimanjaro> mm_freak, that's a good argument to fall back on, except it's pretty hollow. I'm not saying I disagree with you, but it doesn't sound like you have really thought out what you are talking about
19:15:14 <Pseudonym> That's nice.
19:15:17 <lispy> dons: my masters work is basically just fixing conflicts now
19:15:28 <lispy> dons: but i plan to keep improving darcs after i graduate
19:15:43 <Pseudonym> The man who is responsible for all of those papers on fine-tuning BSD sort implementations also uses Haskell.
19:15:44 <ddarius> Pseudonym: Who is he elsewhere?
19:15:48 <ddarius> Ah.
19:15:56 <Pseudonym> He invented Unix pipes.
19:16:07 <Pseudonym> That's some serious cred there.
19:16:12 <dons> lispy, right, so is it likely you'll be the candidate for `darcs fulltime hacker' in the coming few years?
19:16:23 <Pseudonym> And also implemented the first tr and diff.
19:16:25 <dons> since i think it really does need a phd student with 4 years to dedicate to the project
19:16:28 <Pseudonym> Amongst others.
19:16:32 <dons> Pseudonym: oh wow. didn't know that.
19:16:36 <Pseudonym> Yeah.
19:16:36 <dons> this guy, http://www.cs.dartmouth.edu/~doug/source.html ?
19:16:38 <lambdabot> Title: Source code
19:16:44 <dons> (note haskell source on that page!)
19:16:51 * Pseudonym read a lot of McIlroy papers when implementing database sorting
19:17:24 <lispy> dons: um, phd? i'm starting to hyperventilate...maybe we should change the subject to something less frightening :)
19:17:35 <Pseudonym> Hey, he's got a suffix array implementation there, too.
19:17:42 <Pseudonym> Now why didn't he weigh into the BWT debate? :-)
19:17:42 <dons> well, you'll be doing darcs development for the next couple of years, lispy ?
19:17:44 <dynamix> dons: are you the same id on reddit too?  i read your comments on a thread " what the hell are monads?" trying to get my head around all that stuff
19:17:48 <mm_freak> kilimanjaro: maybe it's because i'm too busy for such discussions…  still IMO in functional programming you're using a style of expressing your problem rather than a expressing its solution
19:18:01 <ddarius> dynamix: Yes
19:18:17 <lispy> dons: i would like to, especially if i could find a job where they let me spend part of my time improving darcs
19:18:31 <dons> dynamix: indeed, that is me 
19:18:34 <ddarius> mm_freak: Ideally.  I think logic languages do a significantly better job about that in many cases.
19:18:38 <dons> dynamix: welcome!
19:18:41 <dynamix> dons: thanks :) for those comments
19:18:46 <kilimanjaro> mm_freak, it depends really on the problem at hand. sometimes programmers are interested in writing code that is inherently imperative, sometimes programmers are interested in solving problems and they find it convenient to use a language like prolog
19:18:55 <ddarius> Oh no. Time is going backwards.
19:19:11 <dons> ddarius: btw, played with LogicT yet?
19:19:24 <ddarius> If you are interested in solving problems you don't use prolog!
19:19:47 <dons> I've got a suspicion we really could own the puzzle one liner problem solving domain with LogicT + Control.Monad, as a more flexible [] monad
19:19:53 <dynamix> i started reading up on haskell only 3 days ago.  so im still kind of slow.  cant beleive i missed all this fun since 2003[ when i first wanted to learn haskell, but had to defer]
19:20:03 <dons> dynamix: heh ah well, you're here now!
19:20:14 <ddarius> dons: I don't think so.  I had an implementation of "Typed Logical Variables" around which gives me logic variables and backtracking and is pretty skippy so I use that when I want it.
19:20:42 <dons> > fix ((1:) . scanl (+) 1) 
19:20:44 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
19:20:48 <kilimanjaro> ddarius, maybe homework problems for a course on prolog. I don't know if that counts :D
19:20:55 <ddarius> dons: I much prefer tree based non-det monads to [].
19:20:55 <dons> ddarius: in haskell?
19:20:59 <Cale> dynamix: I'm cgibbard on reddit, you've probably seen my posts there too, if you've been reading the comments on Haskell articles :)
19:21:04 <Pseudonym> The main thing that LogicT doesn't give you is logic variables.
19:21:06 <ddarius> dons: Yes.
19:21:14 <ddarius> @google "Typed Logical Variables in Haskell"
19:21:16 <lambdabot> http://www.cs.chalmers.se/~koen/pubs/haskell00-typedlp.ps
19:21:28 <dons> oh, so there's a package you should be uploading, ddarius :)
19:21:42 <dons> Pseudonym: do we need a cafe-etiquette guide, do you think?
19:21:55 <Pseudonym> Not yet.
19:21:57 <dibblego> no
19:22:01 <ddarius> Actually, I could do that.  Especially if I still have the code.  I have a cute (pure) Prolog interpreter to go with it.
19:22:05 <gravity> The assault on programming.reddit claims another :-)
19:22:06 <dibblego> that *is* Eternal September then
19:22:19 <Pseudonym> I think what we need is a secret conspiracy.
19:22:27 <dons> gravity: hah. 
19:22:37 <dynamix> Cale: i read only one.  i started with the haskell98-report pdf then figured i need a tutorial, found yaht, got stuck with the bind operator, some how its still not clear to me. of course the types are different , but semantically..
19:22:49 <dons> gravity, this community is rather effective at churning out new research and fun ideas :)
19:22:51 <cdsmith> I dunno.  Some people might want to wait until a week from Monday before uploading libraries that might help others with certain... err... tasks of certain general problem-solving kinds. :)
19:23:00 <gravity> dons: I agree. It's insanely fun to be around :-)
19:23:02 <ddarius> dons: Um.  Since we already have similar things for other fora it may be reasonable for the lists too.  But not quite an "etiquette" guide.
19:23:06 <dons> cdsmith: ?
19:23:15 <cdsmith> (ICFP)
19:23:15 <gravity> I'm a little overwhelmed, since my area of expertise isn't computing, but that's the fun of it
19:23:23 <ddarius> dons: More expectations and community standards/dynamics.
19:23:28 <dons> cdsmith: oh, for the final versions, cdsmith 
19:23:37 <dons> oh, right, sorry :)
19:23:38 <dankna> cdsmith: hah!  I am amused.
19:23:40 <dons> yes, the contest.
19:23:43 <Cale> dynamix: x >>= f is an action that when run, will run the action x, then take the result and apply f to that in order to get another action which it will then run, returning the result of that.
19:24:02 <Cale> dynamix: That's a mouthful, but when you see some examples, it'll hopefully become clearer.
19:24:05 <dons> cdsmith: but it only helps haskell people: which we want to do :)
19:24:08 <Cale> For example...
19:24:17 <Cale> We have getLine :: IO String
19:24:20 <cdsmith> dons: okay.  May all other haskell people come in 2nd. :)
19:24:25 <Cale> and putStrLn :: String -> IO ()
19:24:36 <Cale> So we can write  getLine >>= putStrLn
19:24:48 <Cale> and that's the program which gets a line from the user and prints it back out
19:25:06 <Cale> (when it's eventually run)
19:25:29 <Cale> Do you understand the type annotations I gave there?
19:25:45 <dynamix> Cale: so the way to read that is.. run getLine, give its out put to putStrLn and run putStrLn ?
19:25:50 <Cale> yes
19:25:51 <dynamix> yeah i do
19:26:43 <Cale> A value of type (IO t) is a pretty much an inert value, at least with regard to evaluation, that you might think of as a program that, if it was ever run, it might do some IO before resulting in a value of type t.
19:27:34 <dynamix> so to use bind, both its args need to be actions?
19:27:35 <Cale> There are some primitive values of type (IO t), basic small program pieces, and you can stick them together with things like >>=
19:27:43 <Cale> Its left arg is an action
19:28:01 <Cale> its right arg is a function from results of that first action to further actions to perform
19:28:11 <Cale> It might be easier to start with something like >>
19:28:24 <dibblego> I think it is easier to start with Maybe
19:28:30 <Cale> If x and y are actions, then (x >> y) is an action which performs x and then performs y right after.
19:28:32 <dibblego> rather than the abstraction
19:28:40 <Cale> I'm specifically talking about IO :)
19:28:41 <dynamix> oh yeah thats another thing, in some examples i saw that th eterminal bind is >>
19:29:30 <Cale> In a compiled Haskell program, you're expected to define an action called main, which the RTS will evaluate and execute when the program is run.
19:29:50 <Cale> given that, we can define a "hello world" program:
19:29:59 <Cale> main = putStrLn "Hello, World!"
19:30:13 <Cale> But you need a way to construct more complicated things to do.
19:30:47 <Cale> >> is probably the simplest thing you could possibly do to glue actions together
19:30:55 <Cale> It just does one thing after another:
19:31:05 <Cale> main = putStrLn "Hello" >> putStrLn "World"
19:31:13 <Cale> will print "Hello" and "World" on separate lines
19:31:50 <dynamix> how is that different from say main = do putStrLn "Hello"
19:31:52 <dynamix>                                                                          putStrLn "World"
19:31:55 <Nafai> So I'm almost convinced of the value of static-typing (in a good type system), but not yet by experience, just by reading...
19:31:56 <Cale> It's not
19:32:04 <dynamix> well the indentation is goofed up but you get the point
19:32:11 <dibblego> Nafai, what are you reading?
19:32:12 <Cale> In fact, that do-block is translated into what I wrote
19:32:21 <dibblego> @do putStrLn "Hello" >> putStrLn "World"
19:32:21 <lambdabot> putStrLn "Hello" >> putStrLn "World" not available
19:32:35 <dibblego> @do putStrLn "Hello" >>= \_ -> putStrLn "World"
19:32:36 <lambdabot> putStrLn "Hello" >>= \_ -> putStrLn "World" not available
19:32:40 <Cale> @redo putStrLn "Hello" >> putStrLn "World"
19:32:40 <lambdabot> do { putStrLn "Hello"; putStrLn "World"}
19:32:51 <dibblego> thanks :)
19:32:51 <Cale> there you go :)
19:32:55 <Nafai> dibblego: Just a lot of random links from reddit and the comments.  Also especially cdsmith's essay
19:32:59 <Cale> @undo do { putStrLn "Hello"; putStrLn "World"}
19:32:59 <lambdabot> putStrLn "Hello" >> putStrLn "World"
19:33:10 <Cale> This is handled by the compiler automatically.
19:33:16 <dynamix> neat, now it makes  more sense
19:33:21 <dibblego> dynamix, do is a Haskell keyword that does the translation that you refer to
19:33:40 <Cale> Okay, but with only >>, there's no way to use the result of the first computation in order to decide what should be done next.
19:33:46 <dankna> Nafai: the more I learn about typing, the more I realize that I just don't know whether static or dynamic is better :)  (former Lisp user...)
19:33:58 <ddarius> dankna: Data.Dynamic!
19:34:16 <dankna> amusement.  well, I'll learn that at some point, but I want to get used to the normal Haskell way first.
19:34:18 <Cale> So >>= is a variant of that which instead of an action as its second parameter, instead takes a function from potential results of the first action, to further stuff to be done.
19:34:23 <dibblego> the best argument I have seen against static typing, is solved easily by type-classes; too bad there is *much* more to type systems
19:34:41 <Cale> @undo do { x <- getLine; putStrLn x }
19:34:41 <lambdabot> getLine >>= \ x -> putStrLn x
19:34:48 <Cale> see?
19:35:40 <Cale> So this combined action will run getLine, capture its result into x, and then run putStrLn x
19:35:46 <dynamix> so we save having to use a temp by directly binding it.
19:36:12 <dynamix> oh ofcourse.. the signature of putStrLn is :: String -> IO ()
19:36:16 <Cale> Right.
19:36:35 <dynamix> now i see the right side of a bind has to be a function that performs an action
19:36:55 <cdsmith> dynamix: a function that *returns* an action. :)
19:36:57 <Cale> It's a function that decides what should be done, based on the result of the previous action.
19:37:06 <Cale> yes
19:37:14 <Cale> a function whose result is an action
19:37:28 <sioraiocht> interesting email on haskell-cafe, dons 
19:37:35 <Cale> This is all very meta-programming-ish, which is what makes it confusing the first time.
19:37:47 <dynamix> sorry i meant to say schedules, but returns is what makes sense :)
19:38:15 <Cale> For example, we can design our own looping construct -- it'll take a number and an action and perform the action that number of times
19:38:19 <dynamix> well and the fact that in alleagerness, i read too much in too little time, cramming myself up with lots of examples and tutorials :)
19:38:42 <ddarius> dons: I like the parenthesized "(view of the)"
19:38:54 <cdsmith> no such thing as reading too much... (either that, or I'm in trouble!)
19:39:00 <Cale> loop 0 x = return (); loop n x = x >> loop (n-1) x
19:39:15 <Nafai> dankna: *nods* Python user here, done a bit of Lisp (it used to be my ultimate) and Java at work lately
19:39:18 <ddarius> cdsmith, dynamix: Some things are meant to be read multiple times.
19:39:18 <dynamix> myloop:: (Num a)=> a -> IO () -> IO ()
19:39:27 <ddarius> e.g. Toposes, Triples, and Theories.
19:39:34 <Cale> dynamix: right :)
19:39:40 <dankna> Nafai: oh, nice.
19:40:02 <dynamix> but  IO can be replaced by any other action / Monad i suppose
19:40:14 <Cale> dynamix: Since you can easily write functions that take actions as parameters, you can design any kind of control structure you could ever want (though most of the common ones are already in Control.Monad)
19:40:18 <Cale> yes, absolutely
19:40:21 <cdsmith> ddarius: Yeah, like this ***ing "Proofs and Types" book dons posted to reddit.  I've read chapter 8 four times now, and it sort of makes sense.
19:40:27 <Cale> That's kind of the main point of monads.
19:40:47 <Shimei> cdsmith: I'm trying to read that same book and failing.
19:40:51 <Cale> Is that they effectively let you have little languages embedded inside Haskell all of which share means of combination.
19:40:56 <dynamix> :) geez,  to think i missed all this fun for about 4 years now :)
19:41:05 <dons> ddarius, cdsmith :)
19:41:25 <Shimei> Sequent calculus? *melt* Godel's System T managed to make sense though! Mostly.
19:41:27 <cdsmith> Shimei: And just to rub it in our faces, don posts that comment saying it ought to be taught to all CS undergrads
19:41:38 <Cale> in fact, that loop I wrote is extremely similar in nature to replicateM, the main difference being that replicateM returns a list of the results...
19:41:42 <Cale> @t replicateM
19:41:42 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
19:41:45 <Cale> :t replicateM
19:41:47 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
19:42:00 <ddarius> :t replicateM_
19:42:02 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m ()
19:42:05 <dons> cdsmith: hey, 5 people agreed with me!
19:42:11 <cdsmith> dons: :)
19:42:11 <dons> http://programming.reddit.com/info/247tp/comments/c247z6
19:42:11 <sioraiocht> > replicateM (Just 5)
19:42:12 <lambdabot>  Couldn't match expected type `Int' against inferred type `Maybe t'
19:42:12 <lambdabot> Title: Proofs and Types - a Tutorial (reddit.com)
19:42:14 <Cale> and yes, closer still to replicateM_
19:42:19 <Cale> which throws away the results.
19:42:22 <ddarius> dons: I agree with you and I don't even know what you guys are talking about.
19:42:27 <dons> hah
19:42:28 <Shimei> cdsmith: Actually, I've always wondered why the discrete math/foundations sort of courses never have *anything* about lambda calculus.
19:42:29 <Cale> > replicateM 5 [1,2,3]
19:42:31 <lambdabot>  [[1,1,1,1,1],[1,1,1,1,2],[1,1,1,1,3],[1,1,1,2,1],[1,1,1,2,2],[1,1,1,2,3],[1,...
19:42:33 <Nafai> dankna: I think I might agree with the last paragraph of this comment: http://programming.reddit.com/info/25oqb/comments/c25t8i
19:42:33 <lambdabot> Title: in defense of types (reddit.com)
19:42:36 <Cale> > replicateM 3 [1,2,3]
19:42:37 <lambdabot>  [[1,1,1],[1,1,2],[1,1,3],[1,2,1],[1,2,2],[1,2,3],[1,3,1],[1,3,2],[1,3,3],[2,...
19:42:42 <dons> ?where+ proofsandtypes http://www.cs.man.ac.uk/~pt/stable/Proofs+Types.html
19:42:42 <lambdabot> Done.
19:42:43 <Cale> In the list monad :)
19:42:44 <sioraiocht> > replicateM 5 (Just 5)
19:42:45 <lambdabot>  Just [5,5,5,5,5]
19:42:50 <cdsmith> Shimei: Yes, I agree.  Teach Barendregt's excellent book, for sure.  But this is something else!
19:43:05 <ddarius> Of course I did write this recently: http://lambda-the-ultimate.org/node/2342#comment-34980
19:43:07 <lambdabot> Title: HOPL-III: Statecharts in the Making | Lambda the Ultimate
19:43:25 <Cale> dynamix: So this 'loop' turns into all kinds of other useful operations in other monads.
19:43:28 <Shimei> cdsmith: I'm wondering if part of the problem is the translation. The language is clearly written, but the words don't have meaning!
19:43:31 <dankna> Nafai: I can definitely see that as a possibility.  I think the right way to look at things is that there's a maintainability/performance tradeoff
19:43:52 <cdsmith> Shimei: at least with regards to coherence spaces, I'm rather sure the problem is my brain.
19:43:59 <dankna> static types sometime create additional maintenance overhead by forcing us to change things in more than one place - but if you use them cleverly, you can avoid that, so it's hard to pass a final verdict...
19:44:28 <Cale> dynamix: Perhaps an even better example is sequence. The sequence function takes a list of actions, and connects them together into a single action that returns a list of results.
19:44:35 <Nafai> dankna: I admit a language like Haskell is going to take a ton of work for me to really "get"
19:44:35 <Cale> sequence [] = return []
19:44:37 <cdsmith> Shomei: maybe, though.  I noticed some weird stuff in the material I already know.
19:44:38 <dynamix> surprisingly, most literature on the net start with the assumption  that non eagerness/ lazy evaluation is difficult  but for me the actions, monad part was the toghuest
19:44:45 <dankna> same here.
19:44:51 <Cale> sequence (x:xs) = do { v <- x; vs <- sequence xs; return (v:vs) }
19:44:52 <Nafai> dankna: Whereas when I learned Python, it was like an afternoon
19:45:02 <dankna> hah, yes.  exactly.
19:45:16 <Cale> dynamix: Does that code for sequence make sense?
19:45:20 <ddarius> They also make it easier to change things by throwing type errors where you need to change things.
19:45:51 <ddarius> Nafai: Is FP a more or less completely new paradigm for you?
19:45:56 <dynamix> but now i need to browse through the library to get familiar with whats available.
19:46:14 <Cale> dynamix: With sequence, all kinds of other loops become easy to write, because we just need to work out which list of actions we need to perform.
19:46:20 <dynamix> Cale: yes, but isnt <-x either for  list comprehension or getting the output of an action?
19:46:27 <Cale> dynamix: yes.
19:46:33 <ddarius> dynamix: Many people (perhaps unjustly) find monads to be difficult.
19:46:37 <Cale> Though list comprehensions are another part of the syntax.
19:46:59 <dynamix> so when you say v<-x , should x be an action or a list itself?
19:47:06 <Cale> x is an action.
19:47:23 <cdsmith> Shimei: Did you understand the importance Girard is attaching to whether we need the cut rule in sequent calculus?
19:47:24 <Cale> (in the list monad, that would mean x is a list, in the IO monad, x would be an IO action)
19:47:27 <Nafai> ddarius: It depends on what the definition of FP is...I've done schema and CL programming, used 1st class and lambda functions in Python, etc
19:47:39 <Cale> sequence :: (Monad m) => [m a] -> m [a]
19:47:43 <dynamix> neat:). now you just ensured sequential execution of all actions in a list
19:47:48 <Cale> I should really write down the type signature.
19:48:01 <Cale> yeah
19:48:37 <Nafai> s/schema/scheme/
19:48:40 <Cale> in the list monad, "v <- x" means something along the lines of "pick v from x in all possible ways"
19:48:50 <Cale> So,
19:48:53 <Shimei> cdsmith: I didn't really grok that chapter much. When I read that, I just remembered something I read on -cafe about Prolog's cut operator being strange.
19:48:55 <dynamix> how do you read that though?  sequence takes a list of monad a s, and returns a monad applied to a list of as ?
19:48:58 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
19:48:59 <lambdabot>  [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2,...
19:49:24 <Cale> Sequence takes a list of computations returning values of type a, and produces a computation returning a list of values of type a.
19:49:42 <cdsmith> Shimei: I had not drawn any connection between Prolog's cut and sequent calculus's cut.
19:50:01 <cdsmith> Shimei: I think they are very different things (but what do I know?)
19:50:04 <dynamix> Cale interesting i recently wrote a python script to do that,  i used map and reduce extensively..  it is about 4 lines of code
19:50:28 <sioraiocht> @t sequence
19:50:29 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
19:50:30 <Shimei> cdsmith: I have no idea. I just presumed since Prolog is a logic language. I've only barely looked at prolog.
19:50:32 <Cale> Yes, in fact, in the list monad,  xs >>= f = concat (map f xs)
19:50:34 <ddarius> Nafai: I had done some Scheme and CL programming before Haskell.  It took me about a month before I felt pretty comfortable with Haskell.  (It took me about a week for procedural/OO languages before then.)
19:50:37 <sioraiocht> @ty sequence
19:50:39 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
19:50:59 <ddarius> cdsmith, Shimei: They are very different things.
19:51:19 <Cale> The list monad is essentially the same thing as list comprehensions.
19:51:20 <cdsmith> ddarius++
19:51:45 <dynamix> Cale: but [1,23] is not a an action
19:51:47 <ddarius> cdsmith, Shimei: The Cut rule corresponds to invoking subprograms.
19:51:59 <cdsmith> ddarius: ???
19:52:01 <Cale> dynamix: In the list monad, a list is what we've been calling an 'action'.
19:52:03 <Nafai> ddarius: Yeah, I need to get myself into Haskell so I can get to that point of being "comfortable"
19:52:05 <ddarius> Prolog's cut is a monstrosity that should be beaten to death and burned.
19:52:19 <sioraiocht> > do { x <- [1..5]; y <- [6..10]; return (x,y) }
19:52:20 <lambdabot>  [(1,6),(1,7),(1,8),(1,9),(1,10),(2,6),(2,7),(2,8),(2,9),(2,10),(3,6),(3,7),(...
19:52:50 <Cale> dynamix: There's no one terminology which comfortably stretches over all examples of monads without a little bit of forced generality.
19:53:40 <ddarius> cdsmith: Logically (as opposed to programmatically via CH) cut corresponds to proving something using a lemma (theorem).
19:54:03 <Nafai> ddarius: The problem is finding the time and the projects to do with Haskell
19:54:23 <ddarius> I.e. cut is like (function) application but at a different level.
19:54:27 <cdsmith> ddarius: Because it introduces uses a proposition which doesn't appear as a subexpression of the conclusion?
19:54:37 <Cale> dynamix: Basically, a monad is a type constructor M with operations  return :: a -> M a, and  (>>=) :: M a -> (a -> M b) -> M b, which satisfy a few simple rules.
19:54:45 <cdsmith> s/introduces uses/uses
19:54:52 <ddarius> or logically like modus ponens
19:55:45 <cdsmith> ddarius: Thanks, but I'm not gonna figure this out now.  I'll think on it.  For now, it's almost 11 pm EDT and I have to go update software on a  server in five minutes.
19:55:57 <dibblego> Cale, there is a mistake on http://www.haskell.org/hawiki/MonadState and the page is immutable
19:55:58 <lambdabot> Title: MonadState - The Haskell Wiki
19:56:05 <Cale> dibblego: log in
19:56:08 <ddarius> dibblego: There is?
19:56:23 <dibblego> s/(Branch left' right' rseed)/(Branch left' right', rseed)
19:56:23 <Cale> dibblego: The old wiki is deprecated anyway
19:56:33 <dibblego> still pops up in google though
19:56:35 <Cale> but if you want to change it, you'll need to log in
19:56:40 <dibblego> ok
19:56:52 <cdsmith> dons: anyway, seriously -- thanks for the link to this very frustrating book!
19:57:55 <Cale> dynamix: Let's go over some really basic examples of monads, which should help reinforce the general idea and take away the notion that monads are really just for side effects :)
19:58:08 <Shimei> ddarius: So, is it sort of like a transitive property of proofs?
19:58:32 <Cale> dynamix: still here?
19:58:34 <Shimei> That's what I got out of your description and seeing what Wikipedia says about sequent calculus.
19:58:41 <dynamix> Cale, i ve been copy pasting the conversation, well parts of it, for future referencfe. i suppose the room is logged ?
19:58:46 <dons> yeah
19:58:51 <dons> ?where logs
19:58:51 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
19:58:57 <dibblego> editing that wiki page crashes the server application (Python error)
19:59:20 <Cale> I'm not sure if it's also logged, but #haskell-overflow is quieter, if you'd like to move there.
19:59:22 <dibblego> IOError: [Errno 13] Permission denied: 'data/pages/MonadState/last-edited'
20:00:52 <ddarius> Shimei: Actually yes.  You can make a category of deductive systems and if I recall correctly, cut is composition.
20:01:15 <dons> umm.... http://www.softwaredeveloper.com/features/ghosts-in-machine-071207/
20:01:17 <lambdabot> Title: Ghosts in the Machine: 12 Coding Languages That Never Took Off - Software Develo ..., http://tinyurl.com/24u8dy
20:02:26 <ddarius> dons: This is recent?
20:02:52 <dons> 071207 ?
20:02:57 <ddarius> Even people who -don't- like Haskell don't view it as an "also-ran"
20:03:23 <dons> we have graphs. but i guess anyone can write anything on the intertubes, and compare befunge to haskell. hmm
20:03:43 <Shimei> Poor Algol. Classified together with BF.
20:04:16 <ddarius> Algol, Rebol, and Haskell are the only real general purpose languages there.
20:04:33 <dons> Clean, if anything, would make more sense there
20:04:42 <dons> see, to write this you actually have to do research. ah well
20:04:43 <Shimei> I guess we are all dead to him.
20:04:44 <SamB> um.
20:04:49 <ddarius> And Algol might have died but it gave birth to, well almost all current languages.
20:04:49 <SamB> why would befunge have taken off?
20:04:53 <dons> or Miranda
20:05:03 <SamB> it seems more like a video game than a programming language
20:05:04 <dons> commercial lisp.
20:05:05 <ddarius> Or brainfuck or intercal
20:05:11 <dankna> yeah, I don't think it's fair to call brainfuck a failure, for example.  it succeeded at everything it was trying to do.
20:05:14 <SamB> haha intercal
20:05:17 <Pseudonym> Yeah, complaining about Algol is like complaining about PL/I.
20:05:30 <Pseudonym> Sure it's a dead language, but it's really influential.
20:05:54 <Pseudonym> And when Haskell bites the dust (probably be replaced by a successor), new programming languages will STILL be raiding Haskell for features.
20:06:05 <Pseudonym> Kind of like MULTICS.
20:06:10 <dons> yeah
20:06:17 <LordBrain> hmmm 
20:06:44 <Shimei> That list is rather disappointing though. It doesn't mention malbolge.
20:06:49 <Pseudonym> (The successor might still be called "Haskell", but it may only vaguely resemble it.  Like K&R C vs C99.)
20:06:51 <Shimei> Which truly must be worse than BF or Befunge.
20:07:07 <ddarius> Shemei: Perhaps malbolge succeeded?
20:07:20 <dons> you could make a serious list of languages that wanted to go commercial and failed
20:07:32 <dons> and then discuss why. but that would require thinking.
20:07:40 <ddarius> Pseudonym: I can't predict the future, but I have a feeling that Haskell will not stray too too far from it's roots.
20:07:46 <Pseudonym> "Top 12 languages that I feel superior to."
20:07:53 <Pseudonym> ddarius: Much like C.
20:07:54 <Shimei> Well, I hope the metric isn't productivity! It took 3 years to make "Hello World" in Malbolge, IIRC.
20:08:13 <LordBrain> lol
20:08:27 <dibblego> I think the Sapir-Whorf Hypothesis has more to say about why languages succeeded or failed, than anything
20:08:32 <ddarius> Has someone implemented a Turing complete something in malbolge yet?
20:08:34 <Pseudonym> What's more likely to happen is that Haskell gets features, and old features drop, and you end up with something that's similar, but incompatible.
20:08:46 <Pseudonym> Modern FORTRAN isn't far from its roots, either.
20:08:51 <Pseudonym> But it's not the same language by any means.
20:08:58 <LordBrain> Perhaps we should have haskell tutorials that emphasize quickCheck earlier on
20:08:58 <SamB> Shimei: isn't it part of the "turing tarpit" family of languages?
20:09:01 <pejo> ddarius, research will make progress though, regardless if Haskell follows or not. 
20:09:04 <SamB> or is it not even turing complete?
20:09:16 <ddarius> Pseudonym: Yes, but, for example, one obvious direction for Haskell that I don't think it will go to is dependent types 
20:09:16 <Nafai> dibblego: True, but then doesn't it become a popularity contest?
20:09:21 <dons> type families will be a big change, for exampel
20:09:22 <LordBrain> i want to master quickCheck
20:09:26 <ddarius> Albeit Haskell's successor may be dependently typed.
20:09:28 <Pseudonym> ddarius: Probably right, yes.
20:09:40 <dons> ndp with parallel array comprehensions, if that becomes widely used
20:09:43 <ddarius> pejo: Research goes in many directions.
20:09:54 <dibblego> Nafai, it becomes a religion
20:10:01 <SamB> so have we succeeded then?
20:10:11 <SamB> oh no. If we have succeeded, then we have failed...
20:10:20 <Nafai> ddarius: What does dependently typed mean?
20:10:37 <ddarius> Nafai: See some recent posts on www.lambda-the-ultimate.org
20:10:43 <SamB> HAHAHA matlab!!!!!!
20:10:48 <Olathe> Heh. He called MATLAB user-friendly.
20:11:15 <Nafai> dibblego: And if it is up to Sapir-Whorf will we really break out of the C++/Java mode since they are what's most popular?
20:11:26 <dibblego> Nafai, no
20:11:29 <Pseudonym> This is off-topic, but does anyone here understand what RTS/CTS actually do in a serial connection?
20:11:33 <SamB> I'd far rather use numpy than MATLAB
20:11:42 <SamB> even if MATLAB does come with more algorithms
20:11:48 <Pseudonym> All I found via google was a rant from Henry Spencer about what it's been misused to do.
20:12:17 <SamB> what has it been misused to do?
20:12:32 <Pseudonym> Flow control.
20:12:58 <SamB> in that case I haven't the slightest clue what they could possibly have been intended for!
20:13:00 <shapr> @get-shapr
20:13:00 <lambdabot> shapr!!
20:13:03 <shapr> RECURSION OVERLOAD!
20:13:32 <Pseudonym> Half-duplex modems, apparently.
20:13:37 <Pseudonym> The thing is this:
20:13:47 <Pseudonym> I have a full-duplex device which can talk, but it can't listen.
20:14:02 <Pseudonym> Should I be holding some line (be it CTS, RTS) high or low?
20:14:15 <Nafai> As exciting as all this is, I need to get ready for bed
20:14:27 <Nafai> And then it's back to Java and Python tomorrow :(
20:15:21 <chessguy> you poor soul
20:16:11 <dibblego> Nafai, if Scala called itself Java, everyone would be using it tomorrow
20:16:31 <chessguy> @type bracket
20:16:33 <lambdabot> Not in scope: `bracket'
20:16:47 <chessguy> @hoogle bracket
20:16:47 <lambdabot> IO.bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
20:16:48 <lambdabot> IO.bracket_ :: IO a -> (a -> IO b) -> IO c -> IO c
20:16:48 <lambdabot> Control.Exception.bracket_ :: IO a -> IO b -> IO c -> IO c
20:16:50 <dons> let's call Haskell: Python
20:17:37 <ddarius> Let's not.
20:17:57 <dons> but then we can be pythonic!
20:17:57 <dibblego> Cale, it seems someone updated that error for me, but there is yet another error
20:18:10 <dibblego> s/return Leaf (a,next)/return $ Leaf (a,next)
20:18:24 <dibblego> (or use parentheses for consistency with the other case condition)
20:19:16 <ddarius> dons: Who the hell is this person in the "Ghosts in the Machine" article anyway?
20:19:18 <dibblego> my attempt to correct the error crashes the python web application
20:20:06 <dons> `Software Developer Editors' ?
20:20:22 <dons> http://www.softwaredeveloper.com/
20:20:22 <lambdabot> Title: Software Developer - The Software Developer Industry's Web Resource
20:20:43 <dons> they have white papers.
20:20:48 <ddarius> Surely there is a particular person who wrote the article, but there seems to be no by-line.
20:21:05 <dons> i guess they don't want us to find out ;)
20:21:58 <chessguy> @hoogle runReaderT
20:21:58 <lambdabot> Control.Monad.Reader.runReaderT :: ReaderT r m a -> r -> m a
20:24:48 <dons> interesting, http://programming.reddit.com/info/25ykh/comments
20:24:49 <lambdabot> Title: Haskell for Programmers (reddit.com)
20:25:41 <Steve|Office> Is there a way to have something like: class Foo a b in Haskell? I know that that isn't allowed: "Haskell 98 does not support multiple parameter classes," but is there a way to have the same effect?
20:26:12 <SamB> Steve|Office: you need... multiple parameter type classes
20:26:14 <dons> http://neugierig.org/software/darcs/browse/
20:26:15 <lambdabot> Title: darcs - Repositories
20:26:16 <SamB> ;-P
20:26:18 <dons> hmm, who is this guy?
20:26:36 <dons> haskell-memcached haskell bindings for memcached
20:26:39 <SamB> {-# LANGUAGE MultiParamTypeClasses #-+
20:26:41 <SamB> er.
20:26:49 <SamB> s/\+/}/
20:26:54 <dons> Evan Martin.
20:26:58 <dons> http://neugierig.org/software/darcs/browse/?r=haskell-for-programmers;a=summary
20:27:01 <lambdabot> Title: darcs - haskell-for-programmers, http://tinyurl.com/2ege39
20:29:19 <Steve|Office> SamB: Is that a question?
20:29:58 <SamB> Steve|Office: no, 'twas a lame attempt at a joke ;-)
20:30:08 <Steve|Office> Heh, okay. So no way to do it then?
20:30:33 <SamB> {-# LANGUAGE MultiParamTypeClasses #-} -- <- this part is not a lame attempt at a joke though
20:30:46 <Steve|Office> What is that?
20:30:54 <SamB> it's a LANGUAGE pragma
20:31:28 <SamB> you stick it at the top of a module
20:31:43 <Steve|Office> Oh!
20:32:13 <SamB> I really don't know what's up with the abbreviation
20:33:24 <cdsmith> Hmm... 2 people found my blog yesterday by searching for "programming haskell nomads"  (that's not a typo!)
20:33:46 <dons> do we know Evan Martin?
20:33:48 <SamB_XP_> why were they searching for that?
20:33:49 <dons> http://programming.reddit.com/info/25ykh/comments
20:33:50 <lambdabot> Title: Haskell for Programmers (reddit.com)
20:33:56 <dons> memcached binding looks very useful
20:34:40 <cdsmith> SamB: beats me.  Resurgence of interest in Haskell among pre-agricultural societies, I guess.
20:34:53 <SamB_XP_> hahahaha
20:36:08 <chessguy> dons, looks like he's an ML guy: http://caml.inria.fr/pub/ml-archives/caml-list/2004/05/e9b8a2bf63a227f83b2f8770494f3a72.fr.html
20:36:11 <lambdabot> Title: Archives of the Caml mailing list > Message from Evan Martin, http://tinyurl.com/2n5obp
20:37:26 <dons> http://neugierig.org/ 
20:37:27 <lambdabot> Title: Evan Martin
20:37:33 <dons> `I work at Google on making the search engine find pages better.'
20:37:51 <dons> i've mailed him about the libraries he's got there, and whether they should be on hackage.
20:38:13 <dons> he did announce his dbus bindings last year
20:38:28 <dons> oh, this is evan-tech!
20:39:09 <dons> this guy, http://community.livejournal.com/evan_tech
20:39:10 <lambdabot> Title: evan_tech -- Recent Entries
20:39:34 <dons> http://community.livejournal.com/evan_tech/220036.html
20:39:35 <lambdabot> Title: evan_tech -- powerset
20:41:39 <dons> hey unmarshal 
20:41:53 <dons> we're pondering what Evan is up to :)
20:41:55 <unmarshal> hehe
20:42:09 <dons> i've emailed him about his libraries
20:42:14 <unmarshal> cool
20:42:19 <unmarshal> yeah he has a ton of stuff i haven't seen on hackage.
20:42:28 <dons> also, i think this is his blog, http://community.livejournal.com/evan_tech/220036.html (or one of them)
20:42:30 <lambdabot> Title: evan_tech -- powerset
20:42:36 <dons> eval_tech is fairly well known
20:43:10 <dons> decodePulseLED :: Word32 -> Status
20:43:16 <dons> mm...http://neugierig.org/software/darcs/powermate/PowerMate.hsc
20:44:15 <Steve|Office> In an unrelated question, can I have a class that uses (+) for addition? For example, consider a class for ring operations. (+), (-), (*), and negate make sense but abs, signum, and fromInteger do not really. (Well, I could think of an implementation for fromInteger, in the case of a ring by thinking of the ring as a Z-module...)
20:44:50 <dons> you can hide the prelude (+), yep, or write your own numericprelude
20:45:02 <ddarius> Steve|Office: You don't have to implement the other operations or you can implement them with undefined.
20:45:03 <SamB_XP_> but it would probably be a painful process either way
20:45:50 <Steve|Office> Oh, then that might be the thing to do, thanks.
20:59:22 <dibblego> lambdabot is completely screwed when trying to compile with 6.6.1; which version of GHC am I likely to have most success with? 6.6?
20:59:44 <dons> 6.6
20:59:48 <dibblego> thanks
20:59:59 <dons> by screwed, you mean, missing imports from  the haskell-src package?
21:00:18 <dibblego> yes it fails to compile
21:00:24 <dibblego> after sorting out dependencies
21:00:29 <unmarshal> are there plans to implement a gem's like system for cabal that would handle dependency installation integrating with hackage, etc?
21:00:47 <dons> unmarshal: yes, its in alpha testing currently
21:00:55 <dons> see the cabal-install tool in the current cabal darcs repo
21:00:58 <unmarshal> cool
21:00:59 <unmarshal> thanks
21:01:15 <dibblego> I'm going to start afresh with 6.6 on a vmware image and if it works, I'm going to sell it!
21:01:17 <dibblego> :)
21:01:21 <chadz> oh, that's sexy. i was thinking about that earlier this week
21:02:14 <ddarius> dons: I will, for real, work on packaging the logic vars stuff tomorrow.  It's not much code and it splits out into about four independent things.
21:02:46 <dons> ddarius: ok, that sounds very useful
21:02:53 <dons> do you need  hackage account?
21:03:25 <dibblego> dons, do I want the darcs version or lambdabot 4.01?
21:03:53 <dons> darcs
21:04:07 <dibblego> ok
21:04:11 <ddarius> dons: I will, but I'll make something up and have you and people look at it first.
21:04:28 <wli> ddarius: LogicT?
21:05:04 <ddarius> wli: An implementation (though they probably had one available) of the stuff in "Typed Logical Variables in Haskell"
21:06:10 <ddarius> I'll have to do a lot of checking to see what is packaged, what the licenses are on the small bit of code I use (probably none since it's from papers which means asking the authors).
21:06:46 <ddarius> Hmm.  I wonder if I could completely abstract out the use of Hinze's backtracking monad transformer.
21:07:30 <wli> ddarius: Ah, DFS semantics...
21:14:40 <dons> someone want to sketch out 'Learn Haskell in 10 minutes' ? http://www.poromenos.org/tutorials/python
21:14:42 <lambdabot> Title: Learn Python in 10 minutes | Poromenos' Stuff
21:14:59 <dons> a bit like an elaboration of 'haskell in 5 steps'
21:15:05 <xpika> does anyone know where to find the haskell idiom for nested guards using case _ of  or something?
21:15:25 <cdsmith> dons: I'll work on it tomorrow, if you like.
21:15:27 <ddarius> It's on the HaWiki... somewhere.
21:15:47 <dons> xpika: its in the 'blow your mind' page on haskell.org
21:16:00 <dons> cdsmith: yeah, i think together we could get a reasonable 10 minute tutorial done
21:16:02 <chadz> i think we should avoid throwing up little tidbits and try and throw up more "industrial" examples onto reddit
21:16:08 <dons> cdsmith: if you want to draft it out, i can help fill in bits.
21:16:15 <dons> chadz: agreed, that's useful.
21:16:22 <dons> tidbits appear more regularly though :)
21:16:25 <chadz> ie, bots, parsers, web frameworks, etc.
21:16:40 <cdsmith> dons: okay, I'll do that.  Though I'm about to go to sleep and you're not... so if you do it first, I'll understand. :)
21:16:41 <dons> pretty much any new industrial use with a web presence gets put on reddit too though
21:16:48 <chadz> s.t. we deviate away from the, "haskell's only good for little hacks", since that's all people see
21:16:52 <dons> cdsmith: yeah, i might have a go this afternoon
21:17:27 <dons> chadz: a lot of the commercial / industrial use doesn't have a web presence though 
21:17:31 <dons> not sure what we can do about that
21:17:33 <xpika> dons: thanks
21:17:58 <ddarius> dons: Pretty much anything Haskell gets put on reddit.  ...now I wonder why that is...
21:18:11 <dons> yeah. i've noticed.
21:18:11 <unmarshal> i'm really interested in using haskell to build an agent based modeling framework
21:18:23 <dons> what kind of modelling, unmarshal ?
21:18:28 <unmarshal> economics
21:18:31 <unmarshal> among other things.
21:18:40 <unmarshal> first things first though, i need to learn haskell well enough
21:18:53 <wli> I'm far less ambitious.
21:19:06 <unmarshal> also interested in finding adaptive strategies for internet worm propagation
21:19:09 <unmarshal> through simulation
21:20:59 <sjanssen> dons: did you actually calculate the "you're generating 50% of the traffic on this list" figure? :)
21:22:31 <chadz> i got a kick out of the "HASKELL HANDICAPPED SINCE IT WAS BEATING C" reddit the other day
21:23:12 <dibblego> sjanssen, in uncompressed form :)
21:23:23 <dibblego> per unit of "information"
21:25:49 <chadz> wtf. is backspace and delete switched on solaris machines?
21:26:00 <chadz> i'm about to stab my monitor i'm so frustrated with vim
21:26:23 <wli> chadz: Write a better editor in Haskell?
21:26:39 <chadz> wli: or stab your monitor trying to install yi
21:26:51 <wli> ooh, yi
21:27:35 <wli> Doesn't seem to be apt-get installable.
21:28:03 <dons> sjanssen: no, sorry. i may have overestimated 
21:28:14 <dons> its probably, realistically, around 15-20%
21:28:18 <sjanssen> dons: just curious
21:28:22 <sjanssen> even 15% is huge
21:28:39 <dons> enthusiasm! :)
21:28:48 <setuid_w00t> dons: How much time do you spend on reddit?
21:28:55 <dons> reddit, not much
21:28:58 <chadz> i'm guessing ~2 hrs
21:29:02 <chadz>  /day
21:29:11 <setuid_w00t> dons: well I see a lot of submissions from you
21:29:20 <dons> yeah, 2 a day or so
21:29:32 <dons> but i'm not following threads so much anymore, the noise seems to be getting to high
21:29:38 <chadz> dons of reddit, haskell warrior.
21:29:41 <dons> i have rss feeds though, which helps keep track of what's going on
21:29:45 <setuid_w00t> ahh
21:29:56 <dibblego> dons, why doesn't $LAMBDABOT/Config.hs list the network, channels, etc. for joining?
21:30:05 <dons> dibblego: they go in foo.rc files now
21:30:10 <dons> dibblego: is online.rc in the repo?
21:30:19 <dibblego> ah ok thanks (the README needs updating)
21:30:29 <dons> yeah, feel free to add anything that's missing
21:30:31 <dibblego> yes it is (and online2.rc)
21:31:00 <dibblego> does this mean lambdabot doesn't need recompiling after editing online.rc?
21:31:35 <wli> Oh wow, yi is a full-blown editor project.
21:32:20 <wli> I'd probably rather do something far more minimalistic... like a stripped-down vi.
21:33:06 <dons> wli yi-0.1 is a 90% vi clone
21:33:13 <dons> yi nowdays is more like emacs
21:33:23 <dons> but the version i wrote is just ncurses vi, basically
21:33:48 <ddarius> Yeah, you need to take control of it again or another vimmer.
21:34:05 <wli> dons: Nice, is/was yi-0.1 pty-based vs. GUI?
21:34:05 <dons> you could start with yi 0.1 before the gtk layer was added
21:34:11 <dons> console/curses
21:34:21 <blackdog> i thought the whole point was to write it as a toolkit so you could fashion your own editor...
21:34:29 <dons> indeed, and that's how you get emacs
21:34:33 <wli> dons: I thought of it more as a programming exercise, but there is that. ;)
21:34:45 * ddarius actually hardly uses most of the features of vim or many at all...
21:35:03 <wli> ddarius: I hardly use most of the features of nvi.
21:36:12 * pjd vims with vigor
21:36:23 <wli> dons: I'll see if I can figure out how to fetch version 0.1
21:37:21 <dons> the tarball should be on my homepage
21:37:27 <dons> otherwise, you can unroll the darcs repo back a bit
21:37:34 <ddarius> If vi had multilevel undo I may well be happy with just it.
21:37:39 <wli> dons: Found it.
21:38:08 <dons> yi has multilevel undo :)
21:38:14 <pjd> ddarius: which vi?
21:38:27 <dibblego> dons, how does a typical passwd.rc look?
21:38:48 <cdsmith> @seen ndm
21:38:48 <lambdabot> I saw ndm leaving #xmonad, #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 6h 53m 13s ago, and .
21:38:51 <dons> msg freenode:nickserv identify mypasswd
21:38:54 <dibblego> thanks
21:39:09 <ddarius> pjd: vi, vi!
21:39:19 <Alleria> How do I see the number of reductions in ghci? :set +s doesn't seem to do it
21:39:22 <pjd> the FreeBSD vi does multilevel undo with .
21:40:03 <glguy> is FreeBSD's nvi?
21:40:26 <wli> Mostly I was thinking that nvi is too bloated.
21:40:30 <edwardk> ok, hackaged the parameterized monad stuff, added pretty much the rest of the MTL to it as well
21:40:46 <cdsmith> @tell ndm Maybe a nice test case for catch at http://www.xprogramming.com/xpmag/dbcHaskellBowling.htm.  "And we are left with that rule for x:[], which appears to be redundant, but it's really hard to be sure."
21:40:46 <lambdabot> Consider it noted.
21:41:10 <bockmabe> Hey guys, I want to write a program to parse an assembly code file and glean symbol definitions and then spit out a C .h file, which parsing toolkit would you folks here recommend?
21:41:21 <wli> ghc-6.6.1: unknown package: plugins
21:41:43 <edwardk> http://www.cse.unsw.edu.au/~dons/hs-plugins/
21:41:43 <lambdabot> Title: hs-pluginsDynamically Loaded Haskell Modules
21:42:05 <lambdabot22> Title: hs-pluginsDynamically Loaded Haskell Modules
21:42:16 <cdsmith> lambdabot22?
21:42:19 <dons> bockmabe: how big are the assembly files?
21:42:44 <bockmabe> 26k
21:42:47 <bockmabe> bytes
21:42:54 <dons> oh tiny. ok, parsec then
21:43:08 <dons> let me find some related tools for parsing asm, and generating C..
21:43:36 <bockmabe> cool, thanks dons
21:44:21 <dibblego> cdsmith, sorry, that's me stuffing about
21:44:33 <cdsmith> dibblego: no need for apologies.  I was curious.
21:44:44 <dons> bockmabe: cacheprof is an old haskell tool for analysing cache behaviour from .s files, http://www.cse.unsw.edu.au/~dons/code/nobench/real/cacheprof/
21:44:44 <lambdabot> Title: Index of /~dons/code/nobench/real/cacheprof
21:45:04 <RussellsTeapot> Title: Index of /~dons/code/nobench/real/cacheprof
21:45:15 <glguy> dons: did you have any successes with adding syntax highlighting to ?src?
21:45:20 <dons> haven't tried
21:45:25 <dons> people argued against it
21:45:33 <dons> since it makes the logs unreadable 
21:45:35 <dibblego> ?type map
21:45:35 <glguy> oh
21:45:37 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
21:45:48 <glguy> seems like the logs ought to filter that out..
21:45:56 <RussellsTeapot> forall a b. (a -> b) -> [a] -> [b]
21:45:58 <bockmabe> dons, cool I'll take a look.  I'm just looking for a starting place.
21:46:01 <dons> bockmabe: you'll also want a C data type and pretty printer
21:46:13 <bockmabe> Yeah.
21:46:25 <bockmabe> There must be a few of those.
21:46:25 <dons> for the assembly side, harpy might be useful, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/harpy-0.2
21:46:28 <lambdabot> http://tinyurl.com/ynrb8k
21:46:35 <dons> lets you generate and dissasemble x86 assembly
21:46:45 <RussellsTeapot> http://tinyurl.com/ynrb8k
21:46:52 <dons> RussellsTeapot: @part #haskell
21:47:05 <dibblego> thanks
21:47:32 <dibblego> what attribute does lambdabot have that RussellsTeapot doesn't, that means lambdabot responds to privmsg, but RussellsTeapot doesn't?
21:47:34 <dons> bockmabe: and finally, c2hs contains a full gcc C parser
21:47:36 <dons> ?where c2hs
21:47:36 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/c2hs/
21:48:05 <dons> if you're just doing x86 assembly, harpy might give you the parser (or at least a assembly data type) for free
21:48:17 <SamB_XP_> dibblego: perhaps lambdabot is registered with nickserv?
21:48:28 <dibblego> SamB, RussellsTeapot is too (was - I killed it)
21:48:39 <bockmabe> Yeah, unfortunately I'm guessing noone has written a parser for this assembly :-).
21:48:44 <bockmabe> (in haskell)
21:48:51 <dons> what arch is it?
21:48:53 <dons> not x86?
21:48:57 <bockmabe> PDP-10 ;-)
21:49:01 <dons> ah ha
21:49:06 <bockmabe> hehe
21:49:12 <cdsmith> bockmabe: awesome! :)
21:49:13 <dons> other parser, lexer and pretty printer libs are here, http://haskell.org/haskellwiki/Applications_and_libraries/Compiler_tools
21:49:15 <lambdabot> Title: Applications and libraries/Compiler tools - HaskellWiki, http://tinyurl.com/2p8tax
21:49:21 <SamB_XP_> bockmabe: pitty about that 0
21:49:28 <SamB_XP_> if it was pdp-1 I could help you ;-)
21:49:39 <ddarius> It's probably easier to write an assembly parser than it is to find a library that already does it...
21:49:44 <bockmabe> pdp-1? you mean 11? I don't know that one.
21:49:52 <SamB_XP_> *1*
21:50:05 <bockmabe> ddarius, ya that what I'm hoping.
21:50:08 <dons> yes, in this case i'd just write a parser / pretty printer for pdp-11, then use a C data type and pretty printer set for the .h generation
21:50:08 <dibblego> SamB, it seems my little laptop was overworked; removing all its channels seems to have worked
21:50:10 <SamB_XP_> ... the origin of spacewar and all that?
21:50:32 <dons> regarding generating C from haskell, you could look at http://www.cse.unsw.edu.au/~dons/papers/SCKCB07.html
21:50:33 <lambdabot> Title: Generative Code Specialisation for High-Performance Monte-Carlo Simulations
21:50:46 <bockmabe> Really, spacewar ran on that first.
21:50:50 <bockmabe> Didn't know that.
21:50:55 <skew> what did you use for writing C?
21:51:17 <dons> little DSL for the C syntax we needed
21:51:21 <skew> I don't see Language.C.Pretty (hint hint)
21:51:24 <SamB_XP_> I don't know how well my MACRO-1 works though :-(
21:51:34 <dons> yeah, that's the best thing. start with c2hs's parser, and add a pretty printer
21:51:37 <dons> put it in Language.C
21:51:42 <SamB_XP_> I haven't gotten around to writing a PDP-1 simulator
21:51:49 <SamB_XP_> it has so many switches :-(
21:51:59 <skew> are there any plans for more error handling in Data.Binary?
21:52:00 <bockmabe> dons, cool thanks for all the info. I'll se if I can contribute too.
21:52:23 <bockmabe> SamB_XP_, hehe
21:52:29 <wli>   libghc6-plugins-dev: Depends: ghc6 (< 6.6+) but 6.6.1-2 is to be installed
21:52:34 <skew> I was porting some C serialization code for a savings of about 100x, but couldn't quite get the error handling the same
21:52:35 <dons> it sounds like a very doable project for haskell. should be straightforward
21:52:39 <bockmabe> SamB_XP_, where did you use the PDP-1?
21:52:45 <SamB_XP_> I never did use one
21:53:03 <SamB_XP_> I am only 20!
21:53:04 <dons> skew, hmm, more info?
21:53:16 <dons> so it was 100x faster, but you had to stop due to error handling?
21:53:20 <bockmabe> hehe, I'm only 28 too. Who knew.
21:53:22 <skew> no, 100x shorter
21:53:27 <dons> ah hehe
21:53:34 <dons> how rich was the data you were serialising?
21:53:40 <skew> replacing page-long definitions with different type specializations of things based on read!
21:53:44 <dons> could you just define your own newtype wrappers with arbitrary error handling in them?
21:53:49 <SamB_XP_> dons: oh, typically millionare
21:53:55 <skew> Get doesn't expose much error handling
21:54:07 <skew> it just calls error with a message including the current location
21:54:13 <dons> what kind of error handling do you mean though?
21:54:26 <SamB_XP_> dons: probably some kind of MonadError instance
21:54:29 <dons> you can insert checks into the instance Binary for whatever you want, that's one approach
21:54:45 <SamB_XP_> or something like that
21:54:51 <dons> skew, right, we can't use MonadError/ErroT, because it introduces strict eval
21:54:58 <dons> as it must demand the stream to determine if there was an error
21:55:14 <SamB_XP_> dons: that is one of the BIGGEST problems with Haskell :-(
21:55:33 <skew> well, it sounds like you don't have plans
21:55:33 <dons> um? sounds like hyperbole SamB_XP. do we have time?
21:55:42 <dons> skew: not to modify the underlying layer.
21:55:54 <dons> but it is planned to have checked instances on top
21:55:55 * SamB_XP_ wants to see a solution
21:55:58 <dons> that's what others have done
21:56:33 <dons> skew, i'd be keen to see that you can use this. if you want to take it up, contact me via email (and dcoutts and kolmodin)
21:56:35 <skew> The bit of the format in question was a string of text (length stored earlier), to be parsed as a number
21:56:54 <skew> so a generic parser for that sort of thing with read is easy
21:57:07 <dons> right, so i'd define a newtype wrapper for that, write a checking Binary instance for handling the parse failure with read
21:57:15 <SamB_XP_> skew: you are trying to parse ordinary file formats?
21:57:30 <skew> making a decent message when the parse fails is harder  - I just added a string argument and included it in the error call
21:57:48 <skew> SamB_XP_: no, nothing standard
21:58:05 <SamB_XP_> er, you know, pre-existing
21:58:06 <skew> something like Parsec's <?> "expression" would be nice
21:58:09 <dons> what error handling behaviour do you require?
21:58:45 <skew> actually, that is more about describing the context
22:00:14 <skew> nothing I can't implement myself, with a bit of hacking
22:00:19 <dons> do you have the instance Binary that was troublesome there?
22:01:22 <skew> it's basically get >>= liftM (read . unpack) . getByteString
22:02:23 <skew> except I use reads to catch parse errors, and make many type-specialized versions with more specific names
22:02:52 <skew> it would be nice to say "parse error reading double" or something - which I did by adding a parameter which can be "double" to the generic parser
22:02:56 <dons> reading Int or Integer?
22:03:05 <dons> or other types?
22:03:08 <skew> getByteString takes Int, I think
22:03:25 <dons> i mea, you're not just using `read' to build Int or Integer values?
22:03:32 <skew> no
22:03:37 <dons> `read' is rather inefficient, I guess you know :)
22:03:51 <skew> doubles, floats, word of various sizes
22:03:52 <dons> yeah, so i'd roll a version of `read' that took a type name for the error
22:04:09 <dons> and perhaps build Either a b out of it, to avoid errors?
22:04:10 <skew> so what I was thinking was something like Parsec's <?> would be nice
22:04:20 <dons> what's that do again? 
22:04:26 <skew> tags a production with a name
22:04:36 <dons> yeah, that sounds reasonable
22:04:41 <SamB_XP_> dons: ...
22:04:50 <dons> but you want a richer combinator layer on top of the underlying binary instances
22:05:00 <dons> SamB_XP_: $!%
22:05:11 * SamB_XP_ tries to figure out how dons can forget <?>
22:05:16 <dons> i don't use parsec
22:05:22 <SamB_XP_> ever?
22:05:23 <skew> so if the parse fails when it's expecting something like (satisfy isLower >> many (satisfy (\c -> isLower c || isUpper c || elem c "_$%%^")) <?> "identifier"
22:05:37 <dons> nope. never had to. tend to roll my own instead, or use happy
22:06:02 <SamB_XP_> dons: you haven't lived until you've seen its error messages!
22:06:03 <dons> skew: seems easy enough. but you might want to put a little thought into a proper combinator set for writing richer binary instances
22:06:23 <dons> but the idea, yes, is to layer this on top, rather than modifying Get directly
22:06:35 <skew> yeah, that's a layer on top
22:06:54 <skew> another thing is catching failure and trying to parse something else
22:07:19 <wli> Hmm, how to have a progress meter that says how far along you are in a long map, fold, filter, etc.
22:07:21 <skew> which does require running something strickly
22:09:01 <skew> the only kind of native failure is running off the end of input, I guess, which is what I was looking for
22:09:17 <skew> for reading a list of records that just continues to EOF
22:09:38 <skew> man, I'm being confusing today :(
22:10:07 <skew> So I parsed that by checking isEmpty before each record
22:11:57 <skew> I find it odd that Data.Binary goes to so much trouble to be lazy, that represents lists with length...
22:12:21 <SamB_XP_> that does seem a bit odd :-(
22:12:30 <skew> I'm considering representing different encodings of things with newtype wrappers
22:13:05 <SamB_XP_> and OH NOES IT WOULD WASTE A BYTE PER LIST ITEM NOT TO!
22:13:13 <skew> how about chunks of 10k items?
22:13:37 <SamB_XP_> why not 4000?
22:13:58 <skew> well, whatever
22:14:16 <SamB_XP_> carefully chosen to be slightly less than 4096 ;-)
22:14:18 <skew> you could even use thready tricks to see if it's taking a long time to force list items, and bail earlier...
22:14:42 <skew> with a convention that any non-zero count means at least one more chunk follows
22:14:56 <skew> I don't need that, just one that reads till EOF
22:15:19 <skew> but looking at the originial code it would tolerate some junk at the end that doesn't add up to a full record
22:15:38 <skew> Parsec could also be instructive for their solution to those strictness problems
22:16:31 <Heffalump> 'lo
22:16:32 <skew> Well, maybe I'm just making things up, but the definition of the monad distinguished between immediate failure from failure or success after accepting some characters
22:17:16 <skew> it's like Maybe (Either ParseError a)
22:18:12 <skew> in normal operation you lock into an alternative if it accepts any characters, but the "try" operator introduces backtracking by examining the results more to turn delayed failure into immediate failure
22:18:57 <SamB_XP_> um, I hate to break this to you, but Parsec is *strict*
22:20:12 <skew> so it is - Get would be more involved
22:20:43 <skew> like writing everything against a (MonadState S m) constraint, and swapping in a lazy or strict state monad
22:21:14 <skew> I just know I'm going to break all the careful tuning...
22:21:27 <SamB_XP_> using a lazy State monad can be very confusing ;-)
22:21:51 <SamB_XP_> because a lot of the time you get errors for things that went wrong near the *end* of your computation
22:22:28 <SamB_XP_> when there would have been other errors closer to the *beginning*
22:24:37 <skew> I was fun porting code and turning several pages devoted into interators into
22:24:41 <skew> type Iter = [Item]
22:25:24 <SamB_XP_> why did you bother with that?
22:25:35 <skew> because I could!
22:26:30 <skew> I started with some type signatures. I wasn't sure they were read-only till I actually looked at the implementation
22:28:30 <wli> A version of transpose that works on both finite and infinite lists...
22:30:28 <SamB_XP_> wli: is it especially hard?
22:30:39 <SamB_XP_> it doesn't seem all that hard...
22:30:47 <wli> SamB_XP:  Not sure. Trying now.
22:31:27 <dolio> @src transpose
22:31:27 <lambdabot> transpose []             = []
22:31:27 <lambdabot> transpose ([]   : xss)   = transpose xss
22:31:27 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
22:32:16 <cdsmith> dons: I started writing the "Haskell in 10 mins" thing you proposed, so let me know if you're working on it too.
22:32:28 <dolio> @type let t = foldr (zipWith (:)) (repeat []) in t
22:32:30 <lambdabot> forall a. [[a]] -> [[a]]
22:32:44 <dolio> It's possible that one does. I can't recall.
22:32:50 <dolio> It doesn't work exactly the same, though.
22:33:19 <SamB_XP_> > take 4 $ map (take 4) $ transpose (tails [1..])
22:33:20 <lambdabot>  [[1,2,3,4],[2,3,4,5],[3,4,5,6],[4,5,6,7]]
22:34:19 <SamB_XP_> it looks good to me
22:34:36 <dolio> > let t = foldr (zipWith (:)) (repeat []) in take 4 $ map (take 4) $ t (tails [1..])
22:34:39 <lambdabot>  Exception: stack overflow
22:34:48 <dolio> Ah, well, there we are.
22:35:26 <wli> Must be the unfoldr producing the lists breaking it, then.
22:37:08 <dibblego> what's the issue for lambdabot if "Failed to load interface for `ShowQ':"
22:41:12 <edwardk> @pl foo m f = fmap (runIdentity . f) m
22:41:12 <lambdabot> foo = flip (fmap . (runIdentity .))
22:41:47 <cybercobra> is it possible to have 2 'data's w/ the same constructors?
22:41:57 <ddarius> No
22:41:58 <dibblego> no
22:42:27 <cybercobra> darn. I'm going to have to add prefixes, yech.
22:42:38 <skew> or define them in different modules
22:42:54 <skew> you have to qualify them if you want to use both in the same module
22:43:00 <kfish> qualified imports ftw
22:43:06 <dons> cdsmith: not working on it yet
22:43:12 <dons> do you want to put it on the wiki?
22:43:17 <skew> or read up on row types and add extensible variants to GHC!
22:43:31 <cybercobra> skew: and what's the syntax for qualification?
22:43:47 <skew> it's in the import syntax
22:43:57 <dibblego> dons, why do I get "Failed to load interface for `L':" after copying ShowQ and ShowFun to the lambdabot directory (to remove some other error)?
22:44:00 <skew> oh, that's the more complicated kind
22:44:06 <skew> Module.Constructor
22:44:12 <shachaf> import qualified Module1 as M; import qualified Module2 as N; M.C; N.C
22:44:14 <cdsmith> dons: How would I put something on the wiki?
22:44:17 <skew> leaving out the spaces is important, I think
22:44:33 <cybercobra> skew: awesome. thanks
22:44:43 <skew> import Long.Module.Path as P lets you just say P.constructor
22:44:54 <dons> dibblego: hmm, is L.hs and L.o in the lambdabot directory?
22:45:13 <dibblego> dons, no, but where do they even come from?
22:45:14 <dons> cdsmith: we can just create a new page, haskell.org/haskellwiki/Learn_Haskell_in_10_minutes
22:45:21 <ddarius> skew: Spaces?  What language lets you write Frob . Baz as a qualified name?
22:45:27 <cdsmith> Okay, I'll do that then.
22:45:29 <dons> dibblego: oh, hmm, I think lambdabot's supposed to know how to mess with L.hs
22:45:44 * cybercobra starts modifying his macro engine
22:45:53 <dibblego> dons, so I compile State/L.hs?
22:46:19 <dons> no, that shouldn't be necessary, dibblego 
22:46:39 <skew> ddarius: what language goes out of it's way to exclude it?
22:46:41 <dons> the @define should just build it.
22:46:45 <dons> try @let x = 1
22:47:01 <dibblego> I get the error, without using @let
22:47:12 <dibblego> simply, > [1,2,3] will produce it
22:47:14 <skew> ddarius: the usual lexer + parser arragement will drop the spaces before you even get to the grammar
22:47:29 <dibblego> @let x = 1
22:47:29 <dibblego> <RussellsTeapot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
22:47:30 <lambdabot> <local>:4:0:     Multiple declarations of `L.x'     Declared at: <local>:3:0 ...
22:47:41 <skew> > Just . Just $ 1
22:47:42 <lambdabot>  Just (Just 1)
22:47:45 <skew> > Just.Just $ 1
22:47:45 <lambdabot>   Not in scope: data constructor `Just.Just'
22:47:54 <dons> dibblego: yes, you need a newer regex lib
22:48:12 <dons> dibblego: i use regex-base-0.91
22:48:17 <dibblego> dons, ok thanks
22:48:23 <dons> that's a known bug in the regex lib. 
22:48:25 <ddarius> skew: Java/C# will let you write e.g. java . util?
22:48:29 <dons> we should depend on the newer version
22:48:43 <skew> ddarius: sure
22:49:45 <ddarius> I guess that makes sense as it certainly allows it for member selection notation.
22:51:06 <ddarius> I still want to try it and find out.  I guess that will give me something to do to kill a minute or so at work tomorrow.
22:51:17 <dibblego> yippee! thanks dons 
22:52:22 <dibblego> actually, that only fixed it a bit
22:52:35 <dons> dibblego: hmm?
22:52:41 <hpaste>  dibblego pasted "grr lambdabot" at http://hpaste.org/1647
22:53:07 <dons> did the file L.o and L.hi get built in the lambdabot directory?
22:53:13 <dons> for example, if you @let x = 1 ?
22:53:31 <hpaste>  (anonymous) annotated "grr lambdabot" with "(no title)" at http://hpaste.org/1647#a1
22:53:39 <dons> i do admit i've not been a terribly thorough lambdabot maintainer of late
22:53:55 <dibblego> er I have to rebuild, sorry
22:54:01 <dons> yeah
22:55:36 <dibblego> I still don't have L.o and L.hi, only L.hs
22:56:35 * dibblego clean builds
23:00:43 <dons> it should be created by the 'define' function in Plugin/Eval.hs
23:00:46 <dons> will require a ghc in scope
23:01:02 <dibblego> dons, I have State/L.o and L.hi
23:01:11 <dons> oh, so in the wrong place
23:01:12 <dons> that's interesting
23:01:17 <dons> the renameFile should move it 
23:01:29 <dons> try copying them into the top dir, and then see if that means they'll load
23:01:51 <dibblego> ok
23:02:11 <dibblego> <RussellsTeapot>      Failed to load interface for `LargeWord':
23:03:32 <dons> LargeWord is in scripts/
23:03:38 <dibblego> yep
23:03:41 <dons> should be built by the ./build script
23:03:50 <dons> did you run ./build ?
23:03:56 <dons> it also builds the L.hs stuff
23:04:00 <dibblego> oh
23:04:02 <dons> ah
23:04:10 <dons> look at ./build :)
23:04:21 <dons> Build with cabal (simple)
23:04:21 <dons>     $ vi Config.hs
23:04:21 <dons>     $ ./build
23:04:21 <dons>     $ ./lambdabot { -e command }
23:04:29 <dibblego> sorry
23:04:40 <dons> its ok :)
23:06:17 <wli> let listMod n xs = [[x | (x,m) <- zip xs (cycle [0..n-1]), m == k] | k <- [0..n-1]] in mapChunked n f xs = concat . transpose . parMap (sparking rnf ()) (map f) $ list
23:06:19 <wli> Mod n xs
23:06:26 <wli> That seems to help.
23:14:30 <blackdog_> aw, man. we're getting classed with brainfuck?
23:14:31 <blackdog_> http://www.softwaredeveloper.com/features/ghosts-in-machine-071207/
23:14:34 <lambdabot> Title: Ghosts in the Machine: 12 Coding Languages That Never Took Off - Software Develo ..., http://tinyurl.com/24u8dy
23:15:04 <ddarius> blackdog_: dons mentioned that earlier.  It's ridiculous.
23:15:14 <ddarius> In many distinct ways.
23:15:26 <dons> blackdog_: how did you find that article?
23:15:28 <blackdog_> oops, sorry
23:15:38 <olsner> I want first class pattern matching: (\xs -> if (matches (_,[x,y],Just _) xs) then Just xs else Nothing)
23:15:50 <blackdog_> showed up in my RSS feeds. probably reddit...
23:15:57 <dons> yeah, it came up in my google feed
23:15:59 <kfish> hahaha, what a shitty article
23:16:03 <dons> haven't seen it on reddit though
23:16:08 <dibblego> dons, yay!
23:16:09 <Korollary> It was
23:16:18 <dons> dibblego: working?
23:16:26 <dibblego> dons, yes, thanks
23:16:30 <blackdog_> also: "Coding Languages"?
23:16:31 <Korollary> "Coding language". Wtf
23:16:35 <blackdog_> heh. yes.
23:16:35 <dibblego> er, almost
23:16:36 <olsner> or (\xs -> justMatch (_,[x,y],Just _) xs)
23:17:02 <kfish> haskell doesn't have a "low" adoption rate, it has a "slow" adoption rate; like, say, the rise of the Chinese economy
23:17:30 <dons> http://www.cse.unsw.edu.au/~dons/tmp/cafe.png :D
23:17:42 <Korollary> It should have a low adoption rate.
23:17:48 <ddarius> That is one thing.  People who get into Haskell usually don't leave.
23:18:06 <ddarius> Korollary: The adoption rate is accelerating.
23:18:42 <blackdog_> it's interesting to me what's happening with Ruby and Rails, actually
23:18:44 <Korollary> ddarius: Perhaps. I predict an upper bound, though.
23:18:53 <blackdog_> they seem to be getting overwhelmed by low-skill developers...
23:18:53 <dons> Korollary: did you say you saw this article on reddit?
23:18:58 <Korollary> dons: I think so.
23:19:04 <dons> hmm, i can't find it.
23:19:25 <blackdog_> dons: i think i found it in Startup News on ycombinator...
23:19:29 <dons> ah
23:19:42 <dons> i call PG shennanigans!
23:19:50 <arcatan> hmm, brainfuck hasn't failed
23:19:51 <cybercobra> what's the haskell equivalent of 'nil' ?
23:19:56 <Korollary> []
23:20:22 <dons> yeah, its on ycombinator
23:20:24 <bos> ()
23:20:56 <cybercobra> bos: thanks
23:21:10 <bos> cybercobra: Nothing would be another alternative
23:21:13 <ddarius> arcatan: Algol is dead but is very far from a failure.
23:21:21 <bos> there are many nil-like values
23:21:30 <ddarius> It is possibly one of the most successful languages ever.
23:21:52 <ddarius> False
23:22:25 <ddarius> I had/have massive distaste for nil (and for Lisp "lists" for that matter) in Scheme/CL.
23:22:26 <Korollary> @type ([], (), False)
23:22:27 <shachaf> 0, mzero, mempty
23:22:28 <lambdabot> forall a. ([a], (), Bool)
23:22:32 <shachaf> data Nil = Nil
23:22:38 <bos> mempty, mzero
23:22:55 <shachaf> @instances Monoid
23:22:56 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, Ordering, Product a, Sum a, [a]
23:23:07 <shachaf> @src Monoid mappend
23:23:07 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
23:23:08 <ddarius> Don't forget the empty tree constructor (though mzero covers that)
23:23:34 <shachaf> @src () mappend -- I meant, but I guess it's obvious anyway.
23:23:34 <lambdabot> Source not found. Do you think like you type?
23:23:59 <dons> cdsmith: the tut is looking good
23:24:07 <cybercobra> right, I'll go w/ Nothing so I can use Maybe
23:24:25 <cdsmith> dons: eh.  I'm unhappy with it.
23:24:36 <dons> its a start though
23:24:41 <cdsmith> yup
23:24:45 <dons> so do you want to follow the points raised in the python one?
23:24:54 <dons> basic IO, some basic types, a bit of syntax?
23:25:02 <dons> we'll have to show some full programs
23:25:33 <cdsmith> I'm mixing and matching.  I'll put up the outline I've got, so you can review.  The outline I've got is too much; I'll have to cut like crazy.
23:25:33 <cybercobra> dons: knocking off thinkCspy?
23:26:04 <dons> 'learn python in 10 minutes' actually
23:26:14 <cybercobra> ah
23:26:18 <dons> cdsmith: yeah, i think its important that it be readable in 10 mins :)
23:26:50 <cdsmith> I think 10 minutes is unreasonable for either this or the original Python one.  But maybe some people read fast.
23:27:07 <wli> I'm not a language advocate type.
23:28:02 <Korollary> We have dons already anyway
23:28:27 <ski> MATLAB is user-friendly ??
23:28:51 <dons> Korollary: I want a Haskell job. Seems a good way to ensure there's a chance for a Haskell economy to form. Unless you have better ideas?
23:29:19 <dons> computer programming doesn't have to suck.
23:29:32 <dons> that's my motto :)
23:29:57 <Korollary> I wasn't criticizing you
23:30:03 <cybercobra> @eval data Stmt = ObjectDef String (Maybe Num) [String] [String]
23:30:20 <shachaf> cybercobra: Lambdabot only works with expressions.
23:30:31 <cdsmith> Outline is there; the last half will almost certainly get chopped off
23:30:41 <cybercobra> shachaf: curses!
23:30:51 <cdsmith> but I wanted to list it in case you want to save any of the later pieces
23:31:19 <cybercobra> shachaf: was the (Maybe Num) part correct syntax?
23:31:33 <shachaf> cybercobra: You want (Num a) => Maybe a
23:31:41 <shachaf> cybercobra: Num isn't a type, it's a type class.
23:32:12 <cybercobra> shachaf: what about (Maybe Bool)?
23:32:20 <shachaf> cybercobra: That works, Bool is a type.
23:32:23 <ski> @type Just False
23:32:24 <lambdabot> Maybe Bool
23:32:30 <shachaf> @instances Num -- All of these are types
23:32:31 <lambdabot> Couldn't find class `Num -- All of these are types'. Try @instances-importing
23:32:37 <shachaf> @instances Num
23:32:38 <lambdabot> Double, Float, Int, Integer
23:32:39 <cdsmith> dons: above comments for you; I forgot to address you. :)
23:32:51 <MarcWeber> Do you know wether there is a th printf verison which can be compiled with recent ghcs?
23:33:09 <ski> @index printf
23:33:10 <lambdabot> Text.Printf
23:34:19 <shachaf> MarcWeber: Why specifically TH?
23:35:11 <bos> @seen andyjgill 
23:35:12 <lambdabot> andyjgill is in #haskell and #ghc. I don't know when andyjgill last spoke.
23:35:23 <andyjgill> hi bos
23:35:32 <bos> ah, awake!
23:35:48 <Korollary> @seen andyjgill
23:35:49 <lambdabot> andyjgill is in #haskell and #ghc. I last heard andyjgill speak 25s ago.
23:35:59 <bos> andyjgill: i'm going to be in portland in two weeks for OSCON. want to meet up?
23:36:21 <bos> i'm trying to ensnare simonpj in my devious ways, too.
23:36:28 <andyjgill> Sure.  you want to visit galois, or come over for a drink, or both?
23:36:35 <dons> yeah, with the 4 haskell talks at oscon, galois should pop in :)
23:37:11 <andyjgill> Do you have the titles of the 4 talks, don?
23:37:22 <dons> yep, looking...
23:37:31 <bos> andyjgill: http://www.realworldhaskell.org/blog/2007/07/12/haskell-people-and-talks-at-oscon/
23:37:34 <lambdabot> Title: Real World Haskell  Blog Archive  Haskell people and talks at OSCON, http://tinyurl.com/389jwj
23:37:39 <dons> ah yes.
23:38:01 <bos> andyjgill: i don't think i can make it out to beaverton, but drinks, aye!
23:38:31 <andyjgill> I'm sure I can wander downtown for a beer or two.
23:39:10 <andyjgill> How is the book coming along guys? anything we can do?
23:39:17 <dons> 4 talks from SPJ. he deserves an award.
23:39:26 <bos> although it would be great to get out to the galois offices. i've never met john launchbury, even though i almost went to OGI to do a PhD under him.
23:39:46 <ddarius> Maybe is a massively underused type in other languages.
23:40:22 <Korollary> You gotta exist to be underused, too.
23:40:23 <cybercobra> ddarius: well, it's basically the same as the Null Object design pattern
23:40:31 <andyjgill> Its a short (15 min) tram ride from downtown.
23:40:48 <bos> yeah, i figured it would be on a MAX line.
23:41:06 <Korollary> bool someFunction(int& justResult); // if no result, returns false
23:41:22 <bos> the book's going great, btw. we've got about 5 chapters written so far.
23:41:25 <ddarius> cybercobra: Which is underused as well.
23:41:56 <cybercobra> ddarius: true, but it makes the Maybe concept not quite as underused
23:41:57 <andyjgill> We are right on the max line, like the building 10 feet from the line.
23:42:01 <bos> so we've almost 20% under our belts, after just 6 weeks of plugging at it.
23:42:20 <andyjgill> How are you collaborating? A wiki? A darcs repo?
23:42:33 <bos> which, given that CosmicRay and i both have little kids and no time to write, is kind of amazing.
23:42:36 <bos> darcs, yes.
23:43:27 <andyjgill> Well good luck; its a book I want to see written.
23:43:41 <bos> thanks; we're of the same mind :)
23:45:43 <MarcWeber> shachaf Because the builtin verison doesn't suppport showables, does it?
23:46:11 <MarcWeber> I've seen one dated 2002. So I'll try updating it. Some things have changed.
23:47:48 <dons> yes, the book is one of the pieces of `infrastructure' needed to ensure viability, in my view
23:47:58 <dons> cabal and hackage were other parts of the story
23:48:51 <bos> yep. it's been a huge relief to only be partly responsible for the book, too.
23:49:09 <bos> much less of a slog with the work split up.
23:49:22 <dons> yeah
23:49:55 <bos> night, all
23:50:46 <dons> night bos
23:52:15 <dons> i have a suspicion improving concurrency libs and practices will also be important.
23:52:36 <dons> we need more experience using haskell on multicore machines, to flesh out the libs and idioms a bit
23:53:30 <Korollary> We need big apps
23:54:03 <Korollary> 30+ MB memory footprint
23:54:20 <Korollary> lotsa complexity well handled
23:54:29 <dons> yes. building some big projects
23:54:36 <dons> and having the existing ones better publicised
23:55:59 <cdsmith> dons: The wiki page is all yours for the next eight hours at least.  I hate it, so change whatever you like.  I'll probably be more optimistic in the morning.
23:56:12 <cdsmith> dons: and you're right.  We need whole programs, of course.
23:57:03 <dons> heh ok.
23:57:56 <cdsmith> dons: anyway, with luck I'll be able to add to your "big projects" in Haskell list in a few months. :)
23:58:10 <dons> ooh, sounds promising.
23:58:12 <dons> Korollary: how big, btw?
23:58:20 <dons> +10k  loc, +50k? 100k?
23:58:22 <Korollary> big projects take more than a few months
23:58:24 <DRMacIver> Morning
23:58:35 <dons> lambdabot's 5 years old, and 20k. is it big?
23:58:50 <cdsmith> Korollary: I mean that The project will start in a few months: target release date, August 2008
23:59:09 <Korollary> 20k is small-to-medium imho.
23:59:23 <dons> right, so darcs and pugs are medium 
23:59:30 <Korollary> well, 20k of what, of course. So, it makes more sense to talk in  man-months
23:59:36 <dons> but ghc, bluespec, cryptol are more in the 100k range, so big.
23:59:42 <Korollary> ghc is big.
23:59:51 <Korollary> What are bluespec and cryptol?
