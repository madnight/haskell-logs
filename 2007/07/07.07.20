00:01:21 <pejo> I'm guessing it's Hutton's teaching experience that makes his book so good. Definitely a good idea to document it wli.
00:01:51 <wli> pejo: What's this?
00:02:15 <pejo> wli, 'this'?
00:02:42 <wli> pejo: I'm not familiar with Hutton's book.
00:03:11 <pejo> wli, oh, it's on Haskell programming. Dcoutts wrote a review for The Monad Reader too.
00:03:29 <wli> The Monad Reader sounds interesting.
00:04:10 <pejo> Well worth a read!
00:04:20 <wli> Is it a bok?
00:04:28 <wli> book, rather?
00:04:38 <pejo> @where tmr
00:04:38 <lambdabot> http://www.haskell.org/haskellwiki/TheMonadReader
00:10:16 <wli> I'm tempted to start with something relatively nasty.
00:10:36 <wli> This, of course, incurs the risk of not actually getting it done.
00:16:37 <wli> Solving systems of integer linear equations sounds plausible.
00:17:51 <profmakx> well thats not too nasty
00:18:00 <profmakx> *cough*
00:19:09 <wli> profmakx: It never is until you have to keep track of pivoting. ;)
00:19:32 <profmakx> wli, i was being ironic ;)
00:20:00 <wli> profmakx: Most people don't know the weird gcd bits and syzygy polynomial -like affairs that go on in order to avoid division.
00:21:43 <wli> I'm trying to think of where it's used vs. full-blown integer linear programming (which is much harder and has more canned libraries).
00:22:01 <profmakx> hm
00:22:25 <profmakx> like theorem about finitely generated Z-modules?
00:22:28 <pejo> wli, are there lots of good ilp-libraries out there?
00:22:53 <wli> pejo: Not really, but they exist vs. things for obscure things like this.
00:23:53 <profmakx> it is a hard problem keeping the integers relatively small IIRC
00:24:47 <wli> profmakx: Well, for this it can probably be ignored and the problem sizes kept down to whatever our patience will tolerate.
00:25:08 <wli> profmakx: Well, I guess that's what a lot of the pivoting is for.
00:25:26 <profmakx> hm
00:26:09 <profmakx> one of the assistants talked about it and how its done in GAP
00:26:12 <wli> Move the smallest nonzero in the active submatrix into the pivot position, start crushing things with it, etc.
00:27:06 <wli> Basically like Gaussian elimination except you can't divide.
00:27:21 <profmakx> yea I know how its done
00:27:26 <profmakx> i just never implemented it in code
00:27:32 <profmakx> i just used GAP
00:28:18 <wli> The hard part is tracking the row ops so the right hand sides can be adjusted.
00:29:19 <profmakx> hmmm thinking of it. it might also be harder to solve a system of equations vs. calculating elementary divisors of a matrix
00:29:21 <wli> They don't fit in the lower triangle anymore because you have to have coefficients for both the rows getting combined.
00:31:00 <profmakx> might be an interesting thing to try
00:31:14 <profmakx> because im experimenting with group-theoretic algorithms in haskell
00:31:23 <wli> I remember having to do it by hand in an abstract algebra class.
00:31:32 <profmakx> jup
00:31:55 <profmakx> thats why i brought in the finitely generated Z-modules
00:32:03 <wli> I wrote some permutation calculator but it's rather weak compared to some other things that came out after it.
00:32:46 <wli> Probably the only other algebraic thing of any note was some snippet of really crappy Grobner basis code.
00:34:07 <wli> Well, there was some other garbage about ramifying primes, but that's neither here nor there.
00:34:46 <profmakx> what I really want to do is generalising code for automatic groups to parametrized presentations
00:35:28 <wli> That's far beyond me, though I vaguely recognize what you're on about.
00:35:52 <profmakx> it has got to do with my thesis ;)
00:36:06 <profmakx> i also think its not too popular a field
00:37:03 <wli> Representations aren't so obscure. Automatic groups maybe (I don't recall what they are offhand).
00:37:16 <profmakx> REpresentations are something different
00:37:23 <profmakx> though i dealt with them too before
00:37:44 <profmakx> hm
00:37:54 <wli> I may have absolutely no idea what you're on about, then.
00:38:17 <profmakx> on second thought... a representation is a group-hom from G into a matrix group over some field or ring
00:38:21 <profmakx> in most cases at least
00:38:39 <profmakx> an automatic presentation deals with a monoid homomorphism from a regular language into a group
00:39:13 <quicksilver> i wouldn't call representations obscure; certainly not as a part of group theory
00:39:25 <quicksilver> I think if you study group theory at all they come up pretty early
00:40:06 <wli> They came up for me, though not as early as they should've.
00:40:08 <profmakx> my department does research on repr.-theory so i should not even think of calling them obscure ;)
00:47:42 <wli> Okay, discretely differentiated service vs. aggregate usage.
00:50:40 <wli> Grades of service G_1, G_2, .., G_n, say, each pay a different rate or are granted a different amount of things. All one has are totals.
01:03:14 <zeeeee> is it possible to join a thread?
01:03:38 <zeeeee> *join on
01:08:51 <vincenz> ok
01:09:01 <wli> quicksilver: I never got past the bonehead/weedout abstract algebra classes. I never had any real talent.
01:10:23 <wli> quicksilver: The texts had like one chapter on representation theory, not including the undergrad ones (I've never done any grad study).
01:10:45 <quicksilver> AFAICR the only group theory I did was 4th year
01:10:51 <quicksilver> I never really 'got' it
01:11:04 <quicksilver> although that wasn't necessary to pass :P
01:11:53 <wli> I may have gotten a little further than that, but not by much if so.
01:13:28 <pejo> quicksilver, aren't most of the undergrad courses that way though?
01:15:22 <profmakx> hm
01:15:28 <profmakx> group theory is done in algebra here
01:15:49 <profmakx> well aachen is sort of a "center" for representation theory of finite groups
01:16:15 <quicksilver> pejo: which way?
01:16:26 <quicksilver> Damn, haskell proves slower than python for a parsing problem?
01:16:30 <quicksilver> that really is quite embarassing
01:16:44 <pejo> quicksilver, that you don't really need to 'get' it to pass the course.
01:17:19 <kilimanjaro> what's there to get about group theory?
01:17:22 <quicksilver> pejo: yes :)
01:18:09 <kilimanjaro> its abstract on purpose, so you don't have to understand the concrete examples to prove strong results about them
01:19:04 <profmakx> i dont think that your statement is quite correct kilimanjaro
01:19:31 <profmakx> might depend on the value of "get"
01:19:34 <profmakx> perhaps
01:19:46 <kilimanjaro> what?
01:19:55 <kilimanjaro> ohh
01:19:57 <wli> Purdue's math department has largely been vocational training for EE's and the home of some embarrassing crackpot who claims to have proved the Riemann hypothesis now and then.
01:20:09 <wli> Since the 1970's, that is.
01:21:02 <wli> I think they mostly get by on their (American) football team and their fraternity scene.
01:21:28 <kilimanjaro> i always assumed purdue was a good school, I don't really know why
01:21:49 <kilimanjaro> i dont know anybody who has gone there, and I have never really heard any good things about the school
01:22:05 <wli> kilimanjaro: It inherited a better reputation from a time when it actually was worth a damn.
01:25:20 <wli> The CS department in the last year I was there finally caved to industry and adopted some all-Java curriculum reform and took in some massive number of freshmen who shouldn't have made it past cursory examination (e.g. some totally incapable of speaking English, though they knew enough math I could TA entirely in formulas).
01:26:43 <wli> I'm all for foreign students, but there has to be some basis for communication. This isn't to say the domestic students were any better... their deficits in other areas actually made them worse.
01:27:26 <kilimanjaro> do the professors speak english clearly?
01:27:44 <Shimei> I thought of applying to Purdue. It seems to have a reputation for engineering, undeserved or not.
01:28:06 <Shimei> I'm ending up fleeing to Canada instead. :p
01:28:13 <quicksilver> canada's nice :)
01:29:22 <wli> kilimanjaro: There weren't language issues with profs. It was actually domestic ones doing bad things with the curriculum, pushing to dumb things down, scaring away the technical ones, etc. who were bad. The foreign ones spoke excellent English and were thoroughly technical in contrast to those particular domestic ones.
01:29:37 <kilimanjaro> ahh
01:30:13 <Shimei> I'm puzzled by the whole "let's dumb down CS/math" urge. Of all the people I know who are not going into CS, it's not because it's "hard"...
01:30:16 <wli> kilimanjaro: I sort of got dragged into the pedagogical aspects by virtue of TA'ing for CS.
01:30:26 <kilimanjaro> is it common for american citizens to get a grad assistanceship at a foreign school (canadian for example)?
01:31:33 <wli> kilimanjaro: I don't know. I didn't perform well enough to have any serious opportunities for grad study.
01:31:48 <quicksilver> A lot of the people who apllied to do CS where I used to teach had a very surprising idea of what it might be about
01:32:03 <kilimanjaro> Shimei, yea, I actually decided against CS because it seemed like a lot of time was wasted on systems stuff like teaching kids java
01:32:09 <wli> quicksilver: Like what?
01:32:29 <quicksilver> wli: like it would be something like 'using MS Word only a bit harder'
01:32:31 <Shimei> kilimanjaro: What did you end up studying?
01:33:14 <quicksilver> wli: they found programming a bit of a shock!
01:33:28 <profmakx> hmm
01:33:28 <matthew-_> quicksilver: did they have A-level computing?
01:33:36 <kilimanjaro> Shimei, im a math student
01:33:44 <profmakx> this sounds a bit like how it was here in germany around 2000
01:33:44 <matthew-_> if so, it's not surprising when you look at what's taught in A-level
01:33:55 <Shimei> kilimanjaro: And I think many foreign schools do offer aid. Seems like UBC (Canada) offers a tuition award to all PhD for example: http://www.grad.ubc.ca/awards/index.asp?menu=005,000,000,000
01:33:56 <lambdabot> Title: UBC Grad Studies: Awards and Financial Aid
01:33:59 <pejo> quicksilver, wasn't that more common during the dot-com era though?
01:34:00 <wli> profmakx: This was around 2000.
01:34:05 <profmakx> ah well ;)
01:34:11 <kilimanjaro> Shimei, cool
01:34:26 <profmakx> i thought the rant was about the state of CS applicants in present
01:34:26 <Shimei> kilimanjaro: Ah. I am going through the same dilemma. "Will a CS education actually teach me any neat theory?" Which is why I'm thinking of doing physics too.
01:34:29 <wli> I was a non-crossover double major in CS and math.
01:34:57 <wli> profmakx: I've not set foot on the grounds of a university in 7 or 8 years.
01:35:11 <pejo> Shimei, there's plenty of neat theory in CS, so it must depend on where you take it.
01:36:10 <kilimanjaro> Shimei, well I figure alot of the CS topics I picked up on my own (at least FP, pl theory and anything expected from an undergrad compilers class), so I would personally get less from a CS degree than from math
01:37:23 <kilimanjaro> im not saying i wouldnt benefit from CS classes, but hust not as much, and its probably harder to learn math casually
01:37:58 <wli> profmakx: I've forgotten more than I ever really approximated learning in whatever vodka-soaked delirium I was in while putatively doing an undergrad, so it was all a waste anyway.
01:39:00 <wli> Never mind the other recreational activities (I'm rather hesitant to call it "dating").
01:39:06 <Shimei> pejo: Yes, I'm hoping that I will zoom through everything until I get to interesting 300/400 classes like AI or FP.
01:39:49 <quicksilver> matthew-_: don't make me laugh :P
01:40:02 <quicksilver> pejo: this was a few year post dotcom
01:40:04 <Shimei> Anyhow. Good night #haskell, gotta be healthy for the ICFP.
01:40:12 <quicksilver> pejo: I taught between 2000-2005
01:40:31 <wli> This is not to say I've learned anything since. Seriously folks, I picked up Haskell prior to 2000 and I'm still an utter incompetent at monads 7-8 years later.
01:40:39 <quicksilver> matthew-_: very few of them had computing or maths a levels
01:41:07 <quicksilver> incidentally, I'm not really bemoaning anything, just observing
01:41:08 <wli> That is, if one can claim to have learned Haskell while grossly ignorant of such.
01:41:18 <quicksilver> they were nice guys and most of them got decent degrees
01:42:05 <wli> quicksilver: Well, the students have no idea what they're getting into. I didn't blame them no matter how badly they directly aggravated me.
01:42:13 <Olathe> What's the ICFP channel ?
01:42:20 <quicksilver> #oasis I think?
01:42:30 <Olathe> I mean the one with "haskell" in it.
01:42:48 <wli> Olathe: I'm pretty sure it's #oasis; I've seen it announced a number of times.
01:43:24 <Olathe> Ahh, #haskell-icfp07
01:43:32 <Olathe> #oasis looks good, too. Thanks.
01:43:45 <wli> Olathe: Interesting. I didn't hear about #haskell-icfp07
01:44:17 <wli> Probably just my blindness/idiocy.
01:44:32 <quicksilver> Good luck to any icfp competitors who read this! May the laziest lambda win!
01:45:26 <profmakx> thats why I like haskell
01:45:31 <profmakx> be lazy and proud of it
01:46:41 <wli> I like Haskell because of the aesthetics. There's no real getting past it.
01:47:06 <profmakx> i did not say "that and only that" *g*
01:47:11 <wli> All the fancy features, expressive power, high-level abstraction, and so on are distant seconds.
01:49:18 <profmakx> i yet have to see if the aesthetics carry over if i do something bigger than a few lines of code with it
01:49:36 <doserj> http://www.haskell.org/pipermail/haskell/2004-August/014387.html (cough)
01:49:38 <lambdabot> Title: [Haskell] Re: ANNOUNCE: The Succ Zero International Obfuscated Haskell Code Cont ...
01:51:28 <wli> profmakx: I proposed an algebraic problem I want to get to at some point. That is, classifying a finite magma described by an operation table as a loop, quasigroup, monoid, etc.
01:52:07 <wli> profmakx: I actually proposed it as a _benchmark_ of all things.
01:52:37 <kilimanjaro> magma? why not call it a groupoid?
01:52:58 <wli> kilimanjaro: IIRC groupoids have properties not assumed.
01:53:21 <lispy> oh, has icfp started?
01:53:30 <Olathe> Nope.
01:53:35 <profmakx> not yet ;)
01:53:36 <Olathe> http://www.kingsrook.com/icfp/countdown.html
01:53:43 <wli> kilimanjaro: Magmas are just equipped with a function f : X x X -> X
01:53:55 <wli> kilimanjaro: No conditions whatsoever on it.
01:54:18 <kilimanjaro> ahh
01:55:40 <lispy> this is a terrible weekend for ICFP
01:55:49 <lispy> for me at least :)
02:00:05 <wli> What are applicative functors?
02:05:04 <xerox> Aren't they those that let you do return f `ap` foo `ap` bar ... or f `fmap` foo `ap` bar ...
02:05:30 <wli> They're a dead link in the wikibook.
02:05:40 <xerox> ?docs Control.Applicative
02:05:40 <lambdabot> Control.Applicative not available
02:05:56 <xerox> there are some special names for those combinators
02:06:04 <xerox> ?docs
02:06:04 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
02:06:06 <quicksilver> wli: functors which have `ap`
02:06:22 <quicksilver> wli: i.e. ap : f (a ->b) -> f a -> f b
02:06:28 <xerox> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Applicative.html
02:06:30 <lambdabot> http://tinyurl.com/yrwujr
02:06:46 <quicksilver> wli: actually, functors which have `ap` and also return
02:06:55 <quicksilver> wli: which they call <*> and pure, respectively
02:07:21 <quicksilver> wli: All monads are applicative, but there are strictly more applicatives.
02:07:42 <quicksilver> wli: for example, as well as the 'list monad' applicative for [a], there is the 'zipWith' applicative
02:08:43 <roconnor> Are all comonads applicative?
02:08:50 <roconnor> no wait, of course not
02:09:19 <roconnor> I was thinking zipWith sounded liked a comonadic operatoian.
02:09:20 * wli is still choking too hard on normal monads to get anywhere with comonads.
02:10:07 <roconnor> comonads are just as hard to understand as monads.
02:10:38 <wli> I fully anticipated that.
02:10:42 <Toxaris> you have to co-understand them?
02:10:49 <wli> Probably worse.
02:11:15 <quicksilver> Toxaris: I believe you actually have to over-costand them
02:21:28 * Toxaris reads about comonads
02:25:44 * Toxaris compares the types of bind and cobind
02:27:08 <Toxaris> looks like a monadic action is allowed to return extra information, and a comonadic action is allowed to use extra information
02:27:25 <Toxaris> so a monadic action for the list monad is allowed to return multiple values
02:27:42 <Toxaris> and a comonadic action for the stream comonad is allowed to look ahead in the stream
02:27:57 <opqdonut> what's the type of cobind for a stream?
02:28:30 <Toxaris> i've read http://www.cs.helsinki.fi/u/ekarttun/comonad/
02:28:32 <lambdabot> Title: Comonads and Haskell
02:28:42 <Toxaris> wich is kind of code-only :)
02:29:33 <Toxaris> and it gives something like cobind :: ([a] -> b) -> [a] -> [b] for streams
02:30:37 <opqdonut> oh, i'll read that
02:30:41 <opqdonut> thanks :)
02:31:03 <Toxaris> so cobind for streams is (map f . tails)?
02:31:26 <Toxaris> wich is certainly a usefull function
02:31:42 * Toxaris will learn about comonads right after the icfp contest
02:32:44 * Igloo applies sod's law and deduces that this year's contest will be about comonads
02:33:24 <Olathe> Heheh
02:33:50 * wli boggles at why his all-singing, all-dancing memoizing Bernoulli number code gets its clock cleaned by Oleg's.
02:35:04 <wli> It even uses what should demonstrably be a faster recurrence (due to Ramanujan, of course).
02:40:12 <xerox> anybody knows how to select which plugins to compile with lambdabot?
02:41:07 <alar> @seen dons
02:41:07 <lambdabot> dons is in #xmonad, #haskell-soc and #haskell. I last heard dons speak 4h 49m 35s ago.
02:41:20 <pierre-> xerox: they're listed in Modules.hs
02:41:33 <xerox> Ah, here they are, thanks!
02:42:31 <dons> xerox: edit Modules.hs
02:42:31 <lambdabot> dons: You have 5 new messages. '/msg lambdabot @messages' to read them.
02:42:55 <dons> hi, btw. good to see you're alive!
02:43:10 <xerox> hello :)
02:47:00 <nominolo> !online -> !alive?
02:47:12 <xerox> <-> hehe
02:48:20 <vincenz> dons: we submitted the patches :)
02:50:27 <vaggie> ADEpt & dons: hail Great Knights!
02:51:35 <vaggie> does anyone engaged into ICFPC?
02:51:54 * xerox raises hand
02:52:13 <vaggie> ten minutes remain
02:52:55 <dons> vincenz: i applied them already
02:53:07 <vincenz> dons: Just an fyi :)
02:53:45 <xerox> vincenz: where does \bot announce daarcspatchwatch announces?
02:53:56 <vincenz> xerox: it's specified in the file
02:54:01 <xerox> AH.
02:54:42 <nominolo> icfpc action is at #oasis
02:54:48 <nominolo> kinda
02:55:06 <xerox> vincenz: so you got a message in #lazybottoms-dev? :)
02:55:46 <dons> so are all the haskell teams ready to go!?
02:55:59 <vaggie> nominolo: thanks
02:56:06 <vaggie> nominolo: *** Access to channel #oasis is blocked
02:56:14 <nominolo> wtf?
02:56:47 <xerox> dons we're more of a mixed team, only two of us can Haskell, but if the others use C we can still FFI them :)
02:57:19 <dons> heh
02:57:32 <Toxaris> dons: <thunks> are ready, still unevaluated, though
02:57:42 <ADEpt> vaggie: ??
02:57:45 * Syzygy- seems to have lost his team.
02:57:46 <Lemmih> xerox: What team are you on?
02:57:51 <vaggie> ADEpt: :o)
02:58:02 <dons> Toxaris: good to know.
02:58:08 <dons> get ready to deepSeq them :)
02:58:26 <xerox> Lemmih: pmpm
02:58:27 * blackdog has lost his team too...
02:58:41 <nominolo> vaggie: maybe you have to be identified
02:58:57 * wli is learning about monads.
02:59:10 <vaggie> nominolo: thanks, I'll try now..
02:59:32 <wli> let primes = 2:3:5:[p | p <- [7,9..], all (\q -> p `mod` q /= 0) (takeWhile (\q -> q^2 < p) primes)] in sum (evalState (sequence [bernoulli' (2*p) | p <- take (2^7) primes]) initBernoulliState)
02:59:35 <dons> bloody Jon Harrop is such a weird troll
02:59:41 <xerox> Lemmih: have a great contest :)
02:59:59 <dons> 2 minutes to go!
03:00:22 <vaggie> Good luck! Let's mindpower be within you!
03:00:28 <psi`> to icfp contest?
03:00:54 <dons> 1 minute!
03:01:03 <xerox> Same to you!
03:01:33 <Lemmih> xerox: You too!
03:01:38 <mnislaih> gl all !
03:01:41 <Syzygy-> Task is up!
03:01:50 <dons> go #haskell!!
03:02:25 <dblhelix> good luck to you all! :-)
03:04:46 <chr1s> hf everyone
03:05:31 <wli> For 3*2^5+1 I get 83.98 secs, 4005540536 bytes with chained state where Oleg gets 201.52 secs, 33580808776 bytes
03:05:57 <wli> So I lose for individual Bernoulli numbers but win for aggregates.
03:10:02 <pejo> dons, the 'OCaml for Scientists' guy?
03:10:31 <dons> yeah, trolling everywhere with fakey benchmarks
03:10:49 <pejo> dons, not talking about -cafe now?
03:16:24 <chessguy_> and here i thought it was going to be a SETI binding :)
03:28:20 <chessguy_> looks like dons' bytestrings are going to save the world. or at least a little green alien
03:29:42 <matthew-_> is there a version of bytestring for parsec yet?
03:29:51 <matthew-_> err, the other way round, that should be
03:30:59 <dons> chessguy: yeah, sounds like a useful job .. for lazy bytestrings!! :)
03:31:09 <fasta> Wasn't there some function that deletes all, but one of the same consecutive elements from a list?
03:31:22 <fasta> [1,1,2,2] => [1,2]
03:31:32 <dons> nub
03:31:51 <fasta> dons: something that works in O(n)
03:32:29 <det> Like Unix's uniq?
03:32:35 <dons> map head . group ?
03:32:46 <det> fasta, Sounds like a 3-4 line function.
03:32:51 <fasta> dons: yes, I already thought of that myself
03:32:55 <fasta> det: one line
03:33:00 <fasta> det: see dons
03:33:33 <fasta> I think these kind of semantic operations with a clear purpose should already be in the standard libgs.
03:33:36 <fasta> libs*
03:33:41 <det> not fair, what does group do?
03:33:58 <fasta> > group "missisipi"
03:34:00 <lambdabot>  ["m","i","ss","i","s","i","p","i"]
03:34:08 <fasta> det: well, that
03:34:30 <det> ahh
03:34:56 <fasta> dons: also, nub does something else than  map head . group
03:34:58 <dainanaki> hey I just got ghc set up on ubuntu, but I can't find the APIs... where would they happen to be located?
03:35:09 <fasta> > scheck map head . group == nub
03:35:10 <lambdabot>   Not in scope: `scheck'
03:35:15 <fasta> @scheck map head . group == nub
03:35:15 <lambdabot>  add an instance declaration for (Eq ([a] -> [a]))
03:35:16 <lambdabot>     In the expression: ((m...
03:35:39 <fasta> @scheck \xs -> (map head . group) xs == nub xs
03:35:40 <lambdabot> Add a type signature
03:35:47 <fasta> @scheck \xs -> (map head . group) xs == nub (xs::Int)
03:35:48 <lambdabot> Couldn't match expected type `Int' against inferred type `[a]'
03:35:53 <fasta> @scheck \xs -> (map head . group) xs == nub (xs::[Int])
03:35:54 <lambdabot>   Failed test no. 18. Test values follow.: [0,-1,0]
03:36:01 <fasta> dons: see?
03:36:42 <pejo> dainanaki, 'APIs'?
03:37:20 <dainanaki> well like so i can see what the different importable libraries are and what functions they contain?
03:37:26 <fasta> dainanaki: you mean the API documentation
03:37:29 <dainanaki> yep
03:37:42 <pejo> dainanaki, oh. There's probably a separate documentation package.
03:37:45 <fasta> dainanaki: on Debian that is a another package
03:37:51 <fasta> dainanaki: ghc6-doc
03:38:01 <fasta> dainanaki: no idea about Ubuntu
03:38:07 <dons> dai	http://haskell.org/ghc/docs/latest/html/libraries/
03:38:08 <dainanaki> so where might i find the docs once they are installed?
03:38:35 <pejo> dainanaki, dpkg -l ghc6-doc, if the documentation package is called ghc6-doc.
03:39:01 <dainanaki> oh hey thanks, thats handy
03:39:07 <pejo> Or was it -L? There's a  way to list files in a package atleast.
03:39:15 <fasta> dainanaki: Synaptic can also show that information
03:39:50 <dainanaki> awesome
03:39:51 <fasta> dainanaki: Click right on a package to show more information, then the list of installed files tab
03:39:52 <dainanaki> thanks
03:39:56 <dainanaki> i got it
03:40:47 <vagg>  /usr/share/doc/ghc6-doc/html
03:41:18 <vagg>  /usr/share/doc-base/ghc6-users-guide
03:41:45 <vagg> cewl
03:42:57 <fasta> Haskell is getting popular, we have people saying cewl.
03:47:52 <vagg> :o)
04:05:28 <dainanaki> so would that indicate that haskell has reached absolute popularity when people are like O HAI THIS ARE BE HAZKEL LOL! I R 1337 HAX0R! CURRY!
04:05:30 <dainanaki> ?
04:07:19 <hpaste>  chessguy pasted "off to a good start..." at http://hpaste.org/1786
04:07:33 <chessguy> this is gonna be cake
04:07:42 <fasta> I skimmed the ICFP description, but it seems a bit overly specified.
04:07:56 <chessguy> overly? as in, they gave too much info?
04:08:05 <fasta> chessguy: they even give the exact algorithms
04:08:16 <fasta> chessguy: they even hint at what data structures to use
04:08:17 <chessguy> well yeah
04:08:23 <Syzygy-> fasta: Hint at?
04:08:34 <chessguy> i hardly think it's going to be trivial though
04:08:42 <Syzygy-> I wrote half of that specification straight from the page and down in a Haskell module just by looking at it.
04:08:59 <fasta> chessguy: If you built an interpreter for all the languages in the documents you are already pretty far
04:09:03 <chessguy> i mean, the real issue is the AI you're going to need anyway
04:09:13 <Syzygy-> However, my guess is that the real trickiness starts when you start -doing- things with what they specified, instead of just build the specified algorithms.
04:09:14 <chessguy> fasta, not really
04:09:27 <chessguy> yeah, what Syzygy-
04:09:28 <chessguy> said
04:09:43 <fasta> It seems that the persons with enough computing power win.
04:09:47 <fasta> I.e. Google.
04:10:01 <fasta> They just run it in parallel on 1000 machines and they win.
04:10:03 <Syzygy-> I never got that far, but I suppose that once the parser-and-interpreter is written, you'd want to write a program in this DNA code to set things up so that The Right Things happen.
04:10:09 <chessguy> that's ridiculous
04:10:53 <chessguy> the real meat of the problem is in coming up with a good prefix
04:11:37 <chessguy> which is an AI problem, not a hardware problem
04:12:38 <dons> fasta, nah, its not in the computing power, usually
04:12:45 <dons> but having more compute power does help catch bugs...
04:13:08 <doserj> some teams already dound a prefix that is better than the empty string :)
04:13:09 <fasta> AI is very much a hardware problem
04:13:09 <chessguy> me, i think a good goal is to write the parser/interpreter by the end of the contest :)
04:13:09 <fasta> A universal problem solving machine can already be built today.
04:13:10 <fasta> It's just too slow to be of any practical use.
04:13:34 <chessguy> uh, cite your source?
04:14:30 <fasta> Also, it seems the "pseudo-code" used is _very_ much like Haskell's.
04:14:54 <fasta> Yes, it's something like Pascal.
04:15:05 <chessguy> well now you're just whining
04:15:27 <fasta> I think other years there was less code in the document.
04:15:33 <malcolmw> Algol I think
04:15:40 <fasta> But I am not sure, can anyone confirm?
04:15:49 <malcolmw> wow, 700 teams
04:16:09 <fasta> o.O
04:16:14 <fasta> Wow, that is a lot.
04:16:22 <osfameron> so is it mainly an optimization problem?
04:16:34 <chris2> 24 entries so far
04:16:42 <chessguy> what? there are entries already?
04:16:51 <chris2> just the list
04:16:54 <chris2> http://www.icfpcontest.org/submits/scoreboard
04:16:56 <lambdabot> Title: Scoreboard
04:16:59 <malcolmw> and at least the bottom 4 entries still show 0% survival
04:17:05 <chris2> yes
04:18:26 <chris2> it seems easy to parallelize, but you lots of cpu
04:18:39 <chessguy> hmm. what's to stop people from just repeatedly submitting solutions?
04:18:47 <chessguy> and seeing what score they get
04:19:04 <chris2> :)
04:19:14 <malcolmw> chessguy: there is a delay after submitting until you see the score
04:19:33 <chris2> can't you calculate the score yourself?
04:20:00 <chessguy> well sure, if you build the whole parser and interpreter
04:20:16 <chessguy> and it works :)
04:21:24 <dons> go LazyBottoms
04:21:32 <malcolmw> ooh, the top twenty just changed as I was watching
04:21:52 <dons> PurelyFunctionalInfrastructure sounds like someone we know
04:22:01 <malcolmw> ah, but the order of the top 20 is random
04:22:44 <LeCamarade> What benefit would a mod_haskell give I over a plain .cgi, besides access to Apache facilities (which I abhor, in fact)?
04:22:44 <dons> Nomadic I/O sounds like a haskell team
04:23:12 <LeCamarade> dons: No, nomads usually travel on camels. OCaml?
04:23:15 <chris2> LeCamarade: not having to fork for each request?
04:23:32 <chris2> the caml rider team is pretty obvious
04:23:44 <chrismbrown> is there way --using ghci, or the type-checker within ghc-api-- to infer the type of a locally defined function?
04:24:10 <chrismbrown> viz: :t f.g        (   f x = .... g .... where g = .... )
04:24:30 <LeCamarade> chris2: Not having to fork is almost a negative when I'm using a Haskell CGI. Forking a new process was only bad when the web was in interpretted languages. Haskell has faster startup than parsing a PHP hello-world. :o)
04:24:54 <chris2> mmh
04:25:07 <chris2> maybe there is a fastcgi for haskell?
04:25:09 <dons> 700 teams??!
04:25:15 <dons> that's a bit more than last year
04:25:24 <LeCamarade> chris2: Yes, I'm using fastCGI.
04:25:31 <nominolo> :t read
04:25:36 <lambdabot> forall a. (Read a) => String -> a
04:25:37 <chris2> yeah, that doesnt fork on each request
04:26:22 <chrismbrown> (I'm guessing there isn't, which is quite annoying)
04:26:49 <pejo> LeCamarade, hm. Forking is expensive, regardless of startup time.
04:27:46 <LeCamarade> pejo: Forking is cheaper now than it was in '99. :o)
04:27:52 <LeCamarade> And I am not forking an interpreter.
04:28:13 <LeCamarade> Just a Haskell binary.
04:28:13 <chris2> when you use fastcgi, you dont fork anyway. just for ordinary cgi
04:28:20 <pejo> LeCamarade, what OS are we talking about for starters, and what optimizations to fork() has been made since 99?
04:28:49 <LeCamarade> pejo: Optimisations? Well, like better machines ... :o)
04:30:10 <LeCamarade> Even ordinary CGI is not prohibitive. The interpreted CGI killed it for the rest of us.
04:30:13 <pejo> LeCamarade, by that argument, starting an interpreter is cheaper too.
04:31:07 <LeCamarade> pejo: Yes, but an interpreter is not cheap. I'd never dream of forking perl or awk in a server. Even twice in the same second is murderous.
04:32:13 <chris2> do you think you get >400 req/s with a haskell cgi?
04:32:42 <LeCamarade> chris2: Yes. And handle them gracefully, beautifully.
04:32:49 <pejo> LeCamarade, apache isn't an interpreter, yet you start up a whole bunch of them to be ready in case of a request.
04:33:01 <chris2> what machine, what os?
04:33:08 <LeCamarade> Haskell, when we aren't in the Shootout's rules, is alarmingly-fast ...
04:33:26 <LeCamarade> UNIVAC ... *ducks* :o)
04:33:30 <fasta> dons: how many KLOC Haskell was last years problem?
04:34:43 <LeCamarade> pejo: The tax is, I think, in the invocations. You know, I do not want to base my code on Apache's mods, because that would lock me into Apache. And if the mods don't give me any real advantage, I'm going (fast)CGI.
04:35:15 <chris2> why not write a fast http server in haskell?
04:35:27 <LeCamarade> From what I see, I don't lose any real performance by going CGI. Not in Haskell, anyway.
04:35:37 <pejo> chris2, Marlow et. al has already done it
04:35:45 <chris2> what's the name?
04:35:54 <LeCamarade> chris2: Yes. I was thinking I should just place my code atop HAppS, but I don't know which host I'll have in the end.
04:36:05 <LeCamarade> @where happs
04:36:06 <lambdabot> http://happs.org
04:36:11 <chris2> ah, happs
04:36:27 <bdash> LeCamarade: FastCGI and CGI are rather different, which are you actually talking about?
04:37:14 <LeCamarade> bdash: I'm talking about either, since neither has server-specific bindings, unlike a particular mod.
04:37:40 <LeCamarade> All I want is to do my blog engine and deploy it even on HAppS, if I end up with HAppS in the end.
04:37:42 <dons> fasta, they're typically 3-4k or so
04:37:59 <dons> http://programming.reddit.com/info/27zf8/details :)
04:38:00 <lambdabot> Title: Follow the ICFP contest : the ICFP contest live scoreboard (reddit.com)
04:38:04 <pejo> chris2, http://www.cs.chalmers.se/~bringert/projects.html, search for 'Marlow'.
04:38:13 <lambdabot> Title: Bj&ouml;rn Bringert - Projects & Publications
04:38:21 <chris2> thx
04:38:35 <bdash> LeCamarade: well, you seem to be conflating the two if you think using a CGI has no performance impact
04:38:41 <pejo> chris2, http://www.haskell.org/~simonmar/papers/web-server-jfp.pdf describes it.
04:40:03 <LeCamarade> bdash: It has a performance impact. But it is not prohibitive. I dare say the performance shot got from using a dynamic language is worse under mod_* than that from using a Haskell CGI (plain CGI).
04:40:42 <bdash> LeCamarade: sure, but that's not the statement you made earlier :)
04:40:47 <dons> `The server is temporarily unable to service your request due to maintenance downtime or capacity problems. Please try again later.'
04:40:51 <dons> icfp -- oop
04:40:55 <dons> s
04:41:13 <fasta> dons: it is?
04:41:15 <fasta> dons: not here
04:41:28 <doserj> too many teams abusing the interpreter oracle :)
04:41:30 <dons> 700 teams seems an *awful lot*
04:42:08 <bdash> a bunch of people probably have the auto-refreshing page open in their browser
04:42:34 <LeCamarade> bdash: Oh. But, in short, I am just trying to find out if I lose anything I really need by not using mod_[*|haskell]. Since speed is not an issue - if a Ruby website still works somewhere in the world, a Haskell (CGI-based) one will also still work. :o)
04:44:38 * LeCamarade wants to give Haskell an Erdıs number ... which Haskell hacker has the lowest Erdıs number? .oO0
04:45:18 <Saizan>  Erd√µs ?
04:47:55 <dons> LeCamarade: definitely people with 3, i suspect there's some 2's.
04:48:17 <dons> try the mathy-guys.
04:49:05 <LeCamarade> dons: You're the mathy guy! X^(
04:49:32 <LeCamarade> Saizan: Erdos, if your client doesn't show it good. :o)
04:50:07 <LeCamarade> I'm a stickler for correct spelling and grammar. Lost count of the times I've wanted to backspace over a line I've sent into IRC. :o(
04:50:49 <dons> nah, i think i'm a 5?
04:51:24 <LeCamarade> dons: I'm still at -Infinity. :o)
04:51:29 <jurriaan> I'm a 3.
04:51:48 <jurriaan> But are there any objective criteria for being a Haskell hacker?
04:52:11 <LeCamarade> jurriaan: Maybe one who's hacked the GHC source _hard_.
04:52:11 <dons> you live on #haskell? :)
04:52:20 <LeCamarade> :oD
04:52:26 <jurriaan> This is the first time I visit.
04:52:34 <dons> :) welcome jurriaan
04:52:38 <dons> want to write a paper? :)
04:53:05 <dons> actualy, I wrote a TR with a #3. hmm (I think he has a 3)
04:53:08 <jurriaan> Yeah, why not. I always want to write papers. Often they are about Haskell, even.
04:53:43 <MyCatVerbs> dons: fuck no. I live on #haskell whene'er possible and there's no way I'd dare call myself a haskell hacker. :/
04:54:03 <LeCamarade> But why is it that Haskell's community lives a lot on IRC? It's different in other langs.
04:54:05 <MyCatVerbs> LeCamarade: that or the YHC source, or the Hugs source, or the NHC source...
04:54:06 <dainanaki_> anyone got papers about AI, fuzzy logic, neural networks, genetic algorithms? I'm trying to read up on that
04:54:30 <dainanaki_> in haskell of course
04:54:32 <LeCamarade> MyCatVerbs: The \w?HC source. :o)
04:54:51 <MyCatVerbs> dainanaki_: I reccommend you find a copy of "The New Turing Omnibus", it has quick introductions to a lot of stuff including both neural networks and genetic algorithms.
04:55:04 <dainanaki_> sweet
04:55:07 <MyCatVerbs> (Though most of its examples are written in Pascal-ish pseudocode.)
04:55:36 <dainanaki_> well i guess i could figure out a haskell rewrite of code, but i wanted to see how pros do it
04:55:37 <MyCatVerbs> LeCamarade: ah, I have an idea for one critereon.
04:55:53 <MyCatVerbs> LeCamarade: "anyone who understands more than two thirds of dons' posts"
04:56:13 <LeCamarade> MyCatVerbs: That pushes me out! X^(
04:56:33 <MyCatVerbs> LeCamarade: half, maybe, then.
04:56:52 <dons> MyCatVerbs: my posts??
04:57:12 <MyCatVerbs> dons: progamming.reddit.com
04:58:11 <dons> oh, try psykotic's posts then ;)
04:58:13 <mux> just when I was feeling confident about monads, comonads leap out freom behind a bush
04:58:19 <MyCatVerbs> LeCamarade: and still, wouldn't it be better to use a definition of the word which actually has strong connotations of, "frighteningly damn clever," rather than merely smart?
04:58:35 <MyCatVerbs> s/smart/very smart/
04:58:36 <LeCamarade> :o)
04:58:40 <LeCamarade> =))
04:58:54 <dons> mux, you gotta get some delimited continuations :)
04:59:53 * mux eta-reduces dons :)
05:00:12 <MyCatVerbs> dons: see, both of those words mean something to me, independantly. But you put them together like that and I'm scratching my head.
05:00:23 <ivanm> dons: I woud have expected you would have been hard at work on ICFP, and not wasting time here! ;-)
05:00:26 <LeCamarade> dons spends the day in IRC and at reddit and on the wikis, and then he still turns out an Xmonad. Me, I'm fighting a single type error all weekend. :o( Life ain't fair.
05:00:40 <dons> ivanm: nah icfp paper submission tonight. not doing the contest this year
05:00:47 <ivanm> :(
05:00:56 <pjd> MyCatVerbs: delimited continuations are to full continuations what generators are to coroutines
05:01:05 <ivanm> I had a look at it... would have played with it, but uni starts up again on Monday
05:01:06 * mux wonders if the ICFP'07 contest will be as fun as the ICFP'06 one
05:01:13 <LeCamarade> pjd: Say that again ... :o)
05:01:15 <dons> pjd, nice :)
05:02:27 <earthy> oh, right. ICFP. :)
05:02:38 <MyCatVerbs> pjd: awesome! You just replaced one term I didn't understand with one that I'm slightly shaky about and two that are totally alien to me. :)
05:02:54 <pjd> yay, progress :)
05:04:56 <pjd> MyCatVerbs: if you view continuations as capturing a whole call stack (from the continuation point to the root)
05:05:17 <pjd> then delimited continuations capture only a slice of it (from the continuation point to a delimiter)
05:05:22 <ivanm> OK, so I was looking at the ICFP contest blog, and I came across the boilerplate joke...
05:05:54 <ivanm> so, wtf does boilerplate mean? I remember getting completely confused by it when it came up in haskell-cafe :s
05:06:03 * pjd hopes he's talking sense
05:06:30 * mux is quite sure pjd is talking sense
05:06:31 <dons> ivanm: tedious traversal code for data structures, usually
05:06:46 <mux> only, few people can understand that sense :-)
05:06:46 <ivanm> come again?
05:07:09 <MyCatVerbs> ivanm: grovelling through boring useless data structures to do boring things.
05:07:22 <ivanm> o...k... then...
05:07:24 <MyCatVerbs> ivanm: i.e. 99% of Java code in the universe.
05:07:30 <doserj> think of the code you would have to write if there was no "deriving (Eq)"
05:07:38 <ivanm> ahhh
05:07:49 <ivanm> MyCatVerbs: so why was it brought up on a haskell mailing list? :p
05:07:54 <earthy> okay, the boilerplate joke is very good
05:08:26 <MyCatVerbs> ivanm: dunno, I haven't read that joke. Anyone care to share?
05:08:37 <ivanm> MyCatVerbs: no, I meant your joke...
05:08:48 <MyCatVerbs> I made a joke?
05:09:09 <ivanm> <MyCatVerbs> ivanm: i.e. 99% of Java code in the universe.
05:09:19 <MyCatVerbs> That wasn't a joke.
05:09:19 <earthy> I was wondering what the printed pictures on my office door were... source.png and target.png apparently. :P
05:09:39 <ivanm> the icfp joke... "We will abandon the original topic we had in mind for the ICFP contest (writing generic programs in order to design boilerplates)."
05:09:44 <ivanm> MyCatVerbs: s/joke/comment
05:10:14 <MyCatVerbs> There are a lot of crap APIs written in Java which hence require lots of tedious, mostly useless code to interface to, which is nicknamed "boilerplate".
05:10:53 <ivanm> but what use is boilerplate to haskell?
05:10:59 <LeCamarade> MyCatVerbs: And C# just carried on to perfection.
05:11:03 <MyCatVerbs> Also, doing things like abusing design patterns to fake functional language features like real closures and first-class functions in Java results in huge quantities of rather crap and useless code.
05:11:15 <LeCamarade> A minimum of three objects to read a file ...
05:11:17 <ivanm> since IIRC, there was a lot of boilerplate talk on haskell-cafe not too long ago
05:11:58 <MyCatVerbs> ivanm: well, ideally, it isn't. "Write less, think more!" is right up there in the /topic. :)
05:12:17 <MarcWeber> Applicative data-driven programming, phooey etc.. Where does the module O belong to?
05:12:28 <LeCamarade> readFile == three heavy objects. Each inheriting some. This is amazing.
05:12:58 <MyCatVerbs> MarcWeber: in between modules N and P?
05:13:30 <ivanm> lol
05:14:22 <MarcWeber> instance <each module> Ord ... ;) This would be funny
05:14:22 <pejo> LeCamarade, objects might be fusable though, just like we'd like to remove intermediate lists between functions.
05:15:04 <chessguy> so is there a parsec for ByteStrings?
05:15:42 <Philippa> not currently. xerox's working on a parsec that'll eat them for his Summer of Code project though
05:15:59 <Philippa> (actually, one that'll eat anything you can make behave like a sequence of tokens!)
05:16:05 <chessguy> nice
05:16:12 <chessguy> ?where soc
05:16:12 <lambdabot> http://hackage.haskell.org/trac/summer-of-code/
05:16:44 <LeCamarade> pejo: TextStream t = System.IO.openFile(new Pathname("C:\text.txt"), System.IO.TextReadOnly); t.ReadLine(); ... stuff like that is just not healthy.
05:16:49 <chessguy> mmf, no status report
05:18:04 <LeCamarade> pejo: May work, but I abhor all that contortion, just to do the equivalent of readFile ... so I write my removebiolerplace.cs :o)
05:19:19 <EvilTerran> ?fixity .
05:19:19 <lambdabot> Unknown command, try @list
05:20:39 <EvilTerran> ?infix .
05:20:40 <lambdabot> Prelude
05:20:56 <EvilTerran> hehe. i guess that does look like ?index...
05:21:08 <MyCatVerbs> LeCamarade: .cs?
05:21:56 <LeCamarade> MyCatVerbs: I'm a refugee in the functional world. When the boss enters here, all I'll be able to touch will be C# and Java and friends.
05:22:11 <LeCamarade> :o(
05:22:23 <LeCamarade> Hence my thankfulness to the F# guys.
05:25:14 <MyCatVerbs> LeCamarade: wait, that example to read a text file, was that C# or Java? I couldn't tell.
05:26:05 <pjd> MyCatVerbs: it probably doesn't make a difference!
05:27:03 * MyCatVerbs nods glumly. "That is what I was afraid of."
05:28:28 <hpaste>  EvilTerran pasted "traversing a list-of-lists in (countably in)finite time" at http://hpaste.org/1787
05:28:34 <Saizan> C#, in Java it's worse IIRC
05:29:05 <LeCamarade> C#. Java probably goes even further.
05:29:15 <dons> http://johanjeuring.blogspot.com/2007/07/emorphency.html
05:29:16 <lambdabot> Title: Johan Jeuring's blog: Emorphency!
05:29:19 <dons> for the icfp guys ^^
05:29:49 <EvilTerran> any thoughts on that paste? that zipAllWith function looks to be generally useful, imo
05:30:04 <LeCamarade> Jeuring's been posting a lot on ICFP. (And the coded images) ... is he an organiser? Yes, I think.
05:30:32 <dons> yes.
05:31:14 <earthy> he is the organisation lead
05:31:36 <Saizan> EvilTerran: i've used more than one time a restricted version corrispondig to \f -> zipAllWith f id id
05:31:39 <MyCatVerbs> That bloke is one magnificent ba-lovechild.
05:31:44 <earthy> weirdly enough, the offices here are much more relaxed now than they were wednesday
05:32:13 <dons> earthy: though the website seemed to be done for a little while.  exciting!
05:32:21 <earthy> oh, yeah
05:32:29 <earthy> most of it was already done by wednesdeay
05:32:42 <dons> and 710 teams?
05:32:44 <LeCamarade> Oh. Fine one by Jeuring. :o)
05:32:46 <earthy> no clue
05:32:50 <EvilTerran> Saizan, oh, right. i was thinking this was kind-of-like the maybe and either functions, only zippy.
05:32:55 <earthy> I've only come in half an hour ago
05:32:57 <dons> at least there's 710 on the scoreboard.
05:33:01 <dons> which is truly amazing
05:33:10 <earthy> yeah, that's correct.
05:33:26 <dons> i see lazybottoms is still in the top 20.
05:33:27 <earthy> roughly.
05:33:30 <dons> go lazy bottoms.
05:33:45 <LeCamarade> How many are Haskelling?
05:34:03 <LeCamarade> Hassling, Haskelling, whatever.
05:34:07 <dons> we've got 5 or so teams from #haskell, it seems
05:34:24 <LeCamarade> The page refused to load, you know.
05:34:36 <LeCamarade> Load problems. :o(
05:34:39 <edwardk> what is the contest this year?
05:34:43 * earthy now realises what all that compiler stuff was about ;)
05:34:52 <earthy> edwardk: picture drawing
05:35:03 <earthy> the objective is to modify a picture into a different picture
05:35:13 <earthy> however, the picture is encoded in a weirdish encoding
05:35:19 <chessguy> edwardk, essentially, it's writing a parser and interpreter in a specific language, and then writing a good program in that language
05:35:31 <chessguy> s/in a/for a/
05:35:53 <earthy> and redrawing it is tough
05:35:55 <edwardk> ah
05:36:27 <earthy> chessguy: to me it looked like that was already provided in the assignment text
05:36:42 <chessguy> earthy, "that"?
05:36:46 * earthy could be wrong thoug
05:36:56 <earthy> the interpreter at least
05:37:17 <chessguy> the specification for the interpretation is given, but you still have to implement it
05:37:40 <earthy> true enough
05:37:48 <chessguy> and it's hardly trivial
05:39:08 <dons> sounds like a good job for ... haskell!
05:39:18 <earthy> or C for that matter
05:39:32 <earthy> heck... listen to me :)
05:39:41 <earthy> falling from my faith already :)
05:39:50 <dons> whereas the vm last year really wasn't very good for haskell
05:39:59 <chessguy> dons, the pseudocode is practically haskell already
05:40:23 <dons> i like these language ones
05:40:29 <dons> should have entereed this year. oh well
05:40:42 <earthy> dons: wanna hack a bit and be disqualified? :P
05:40:57 <osfameron> oh, do you have to formally enter beforehand?
05:41:03 <earthy> nope
05:41:15 <dons> oh, i really shouldn't. gotta get other stuff done this weekend. *sigh*
05:41:25 <earthy> dons: I know the feeling *extremely* well
05:41:35 * earthy should get down to true work again
05:41:55 <chessguy> yeah, my real work day just started, unfortunately
05:42:13 <earthy> as did mine (at 2pm...)
05:42:18 <chessguy> i'll probably hack on the parser/interpreter this weekend so that i can at least play with some of the solutions
05:42:29 <chessguy> sounds like good haskell practice anyway
05:43:54 <earthy> good programming practice
05:44:02 <earthy> and much more interesting than my other toy project
05:44:15 <earthy> hm. apples. :)
05:44:36 <chessguy> apples?
05:45:16 <earthy> http://www.keepers-nursery.co.uk/jonagold_variety.aspx
05:45:18 <lambdabot> Title: Jonagold - Apple - Fruit Trees - Keepers Nursery - possibly the largest range of ...
05:46:15 <chessguy> ...
05:46:39 <chessguy> was there some connection between apples and the current conversation?
05:46:43 <dons> oh, we have 2 teams in the top 20 currently
05:46:58 <chessguy> dons, by we, do you mean haskell or #haskell?
05:47:10 <dons> we, #haskell :)
05:48:28 <chessguy> ok
05:48:31 <dons> more hackers per square inch of screen realt estate in this irc channel than anywhere on the intertubes :)
05:49:49 * dblhelix has erd√∂s number 4 and thinks he qualifies as a haskell hacker
05:55:01 <kaol> didn't Haskell Curry coauthor any papers? Surely you could track Haskell numbers, too.
05:56:16 <ddarius> Is there any Galois team?
05:59:12 <araujo> morning
06:01:17 <dons> not this year, ddarius, though a galois teamwon in 01?
06:04:13 <roconnor> @type fromEnum
06:04:15 <lambdabot> forall a. (Enum a) => a -> Int
06:05:11 <earthy> 'Team Canned imitation pork product that is vegan but that a vegan would never eat because both the name is repulsive and the product is disgusting, but mostly because of the name'
06:06:06 <doserj> according to the scoreboard, there seems to be a conical prefix of length 28
06:06:07 <MyCatVerbs> earthy: huh?
06:06:13 <doserj> *canonical
06:06:18 <dons> strange team name
06:06:18 * earthy was reading through the scoreboard
06:07:10 <dons> `The Church of the Least Fixed Point' is a haskell team, as is `LazyBottoms' and `pointless'
06:07:15 <dons> do we have any other tems?
06:07:35 <doserj> 'There is no fixed point'? :)
06:07:52 <dons> sounds like a haskelly team
06:08:01 <dons> so does `Nomadic I/O'
06:08:17 <dons> a true haskell team wouldn't put a / in there
06:08:18 <doserj> PurelyFunctionalInfrastructure
06:13:50 <desp> @hoogle Char -> Word8
06:13:54 <lambdabot> No matches, try a more general search
06:14:08 <desp> @hoogle Integral a => Char -> a
06:14:09 <lambdabot> No matches, try a more general search
06:14:18 <desp> @hoogle Char -> Int
06:14:18 <lambdabot> Char.digitToInt :: Char -> Int
06:14:19 <lambdabot> Char.ord :: Char -> Int
06:14:44 <desp> @hoogle Int -> Char
06:14:44 <lambdabot> Char.chr :: Int -> Char
06:14:44 <lambdabot> Char.intToDigit :: Int -> Char
06:14:44 <lambdabot> Data.PackedString.indexPS :: PackedString -> Int -> Char
06:15:28 <ddarius> :t fromIntegral 'a' :: Integer
06:15:34 <lambdabot>     No instance for (Integral Char)
06:15:34 <lambdabot>       arising from use of `fromIntegral' at <interactive>:1:0-15
06:15:47 <ddarius> :t fromEnum
06:15:48 <lambdabot> forall a. (Enum a) => a -> Int
06:16:12 <desp> aha
06:17:12 <dons> yeah, PurelyFunctionalInfrastructure. hmm. that was the subject of one of SyntaNinja's blog posts
06:17:47 <ddarius> Crouching lambda, hidden Galois team
06:17:58 <opqdonut> :)
06:18:08 <dons> 86 PurelyFunctionalInfrastructure
06:18:45 <dons> `Side Effects May Include...'  could be.
06:19:13 <ddarius> I'm sure there is a heaping pile of them.
06:30:53 <Ataraxia> hi all
06:31:53 <wli> The Church of the Least Fixed Point, heh.
06:32:03 <Ataraxia> @join #gentoo-uy
06:32:03 <lambdabot> Not enough privileges
06:32:06 <Ataraxia> :(
06:32:22 <Ataraxia> some op?
06:32:55 <chr1s> does anybody know how to install the ghc docs? or build them?
06:33:50 <earthy> uhm, download the tarball, untar in the right spot?
06:34:17 <earthy> http://haskell.org/haskellwiki/GHC
06:34:18 <lambdabot> Title: GHC - HaskellWiki
06:34:22 <earthy> and then the download links
06:34:48 <chr1s> I mean from the ghc source distribution, but thanks, that will help too
06:35:03 <earthy> from the source distribution requires haddock
06:35:10 <earthy> so you'd need that first
06:35:57 <roconnor> @hoogle tell
06:35:58 <lambdabot> Control.Monad.Writer.tell :: MonadWriter w m => w -> m ()
06:35:58 <lambdabot> System.IO.hTell :: Handle -> IO Integer
06:36:31 <chr1s> I do have haddock installed
06:36:57 <chr1s> I was looking at http://hackage.haskell.org/trac/ghc/wiki/Building/Docs
06:36:59 <lambdabot> Title: Building/Docs - GHC - Trac
06:37:50 <dons> @join #gentoo-uy
06:38:05 <Ataraxia> thanks dons!!
06:38:13 <dons> :)
06:38:24 <Ataraxia> ;)
06:47:22 <etnt> I tried to install Hat on my Debian machine and got:  warning: can't find GHCi lib HShat.o
06:47:34 <etnt> is that bad... ?
06:47:41 <malcolmw> etnt: it's harmless I think
06:48:20 <malcolmw> the GHCi lib does exist, and is in the right place, but ghc-pkg doesn't recognise it, even though ghci does
06:48:21 <etnt> ok, let's see if I can get it to work...
06:51:32 <etnt> hm...can I run hat from ghci ?
06:51:48 <malcolmw> etnt: unlikely
06:52:36 <malcolmw> etnt: you can try running hat-trans over all your module, then loading them up into ghci, but I wouldn't be sure how to invoke an expression correctly there
06:53:52 <etnt> I get: hat-trans: /usr/include/hat-2.05/Lexer2.hx: openFile: does not exist
06:54:05 <thorkilnaur> chr1s, for building the GHC docs on my Mac, I recall having to install a couple of packages along the lines suggested on ghc/wiki/Building/Docs
06:54:17 <etnt> are there any other trace tool that can be used from ghci ?
06:54:18 <SamB_XP> malcolmw: hey, why do you have an extra copy of HuttonMeijerWallace in HaXml?
06:54:46 <malcolmw> SamB_XP: extra?
06:55:16 <SamB_XP> malcolmw: well what happens if I try to use both HaXml and polyparse in the same program?
06:55:29 <malcolmw> SamB_XP: maybe your version of HaXml dates from before I split out the parser combinators into the separate polyparse package
06:55:38 <SamB_XP> oh.
06:56:16 <SamB_XP> so basically it's only in the unstable version that you've split it out?
06:56:28 <malcolmw> SamB_XP: in fact, I'm not sure I ever released a HaXml since then
06:56:44 <chr1s> thorkilnaur: thanks
06:57:11 <malcolmw> SamB_XP: so yeah, you might want to grab the darcs repo of HaXml if you want to use it together with polyparse
06:57:33 <SamB_XP> at this point it's a hypothetical question
06:58:04 <hpaste>  thorkilnaur pasted "GHC ./configure output relevant to generating documentation" at http://hpaste.org/1788
06:58:56 <thorkilnaur> chr1s, that may tell you something about what is needed, but as you can see, I don't have everything ...
06:59:30 * shapr boings cheerfully
07:00:50 <shapr> Wow, today's xkcd is totally #haskell
07:01:12 <crazy_coder> hi
07:01:19 <thorkilnaur> chr1s, I can only generate the html documentation with that setup, additional things are needed for .ps, .pdf, etc.
07:01:27 <crazy_coder> how to convert [(a,b)] to [a,b] ?
07:01:44 <crazy_coder> list of tuples of say Int to a list of Ints ?
07:01:56 <LeCamarade> > (\(a, b) -> [a, b]) (1, 2)
07:01:58 <lambdabot>  [1,2]
07:02:01 <dons> shapr: the goto one?
07:02:15 <crazy_coder> ok
07:02:19 <crazy_coder> Thanks
07:02:31 <opqdonut> concatMap (\(a,b) -> [a,b]) [(1,2),(2,3),(3,4)]
07:02:35 <opqdonut> > concatMap (\(a,b) -> [a,b]) [(1,2),(2,3),(3,4)]
07:02:36 <opqdonut> bah
07:02:36 <lambdabot>  [1,2,2,3,3,4]
07:02:47 <dons> > concatMap (\(a, b) -> [a, b]) $ zip [1..10] [100.120]
07:02:49 <lambdabot>  [1.0,100.12]
07:02:52 <dons> yeah :)
07:02:57 <crazy_coder> what does concatMap do ?
07:03:05 <dons> it maps, and concats the result
07:03:08 <opqdonut> ?src concatMap
07:03:08 <crazy_coder> ok
07:03:08 <lambdabot> concatMap f = foldr ((++) . f) []
07:03:14 <LeCamarade> The XKCD is bloooooody funny.
07:03:16 <crazy_coder> Thanks
07:03:20 <crazy_coder> :)
07:03:21 <nominolo> @src State guard
07:03:21 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
07:03:23 <dons> LeCamarade: url?
07:03:31 <opqdonut> www.xkcd.com
07:03:32 <dons> do we need an xkcd plugin? :)
07:03:40 <opqdonut> drop the www, even
07:04:17 <dons> a bit dated though. just put a 'i'll just overwrite the value in this variable' ... :)
07:04:37 <thorkilnaur> > concatMap (\(a, b) -> [a, b]) $ zip [1..10] [100..120]
07:04:39 <lambdabot>  [1,100,2,101,3,102,4,103,5,104,6,105,7,106,8,107,9,108,10,109]
07:04:48 <dons> ?pl (\(a, b) -> [a, b])
07:04:48 <lambdabot> uncurry ((. return) . (:))
07:04:51 <LeCamarade> dons: The GOTO one.
07:04:51 <dons> hah
07:04:58 <dons> hey thorkilnaur
07:05:05 <thorkilnaur> Hey dons
07:05:13 <LeCamarade> The truth is what makes it bite pretty hard.
07:06:14 <msouth> in case you don't know this--hover over picture to get a wisecrack/comment based on the comic
07:07:08 <crazy_coder> how to remove repeated element in a list ?
07:07:13 <desp> @hoogle Monad m => (a -> m b) -> [a] -> m [b]
07:07:13 <lambdabot> No matches, try a more general search
07:07:17 <desp> @hoogle Monad m => (a -> m b) -> [a] -> m ()
07:07:17 <lambdabot> No matches, try a more general search
07:07:32 <desp> @type forM
07:07:34 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
07:07:39 <crazy_coder> :t filter
07:07:40 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
07:07:47 <desp> grr
07:08:00 <msouth> crazy_coder: do you mean all repeated elements?
07:08:09 <crazy_coder> msouth: yes
07:08:09 <msouth> I think nub from Data.List does that
07:08:25 <crazy_coder> eg [1,2,3,4,3,2,1] should give [4]
07:08:26 <msouth> > nub "aaabbbbcccc"
07:08:27 <lambdabot>  "abc"
07:08:34 <msouth> ah
07:08:35 <crazy_coder> sorry [1,2,3,4]
07:08:44 <crazy_coder> Oh thats great
07:08:49 <opqdonut> > nub $ cycle [1,2,3]
07:08:52 <lambdabot> Terminated
07:08:53 <msouth> > nub [1,2,3,4,3,2,1]
07:08:54 <opqdonut> ;)
07:08:55 <lambdabot>  [1,2,3,4]
07:11:09 <LeCamarade> > (_'_) -- Tribute to the LazyBottoms. :o)
07:11:10 <lambdabot>  Undefined
07:11:37 * earthy laughs
07:11:39 <dons> :)
07:11:47 <crazy_coder> :)
07:13:29 <crazy_coder> Where is this years ICFP held ?
07:14:10 <mrd> freiburg germany
07:14:33 <dons> huh, so to do global state in erlang, the idiom is to fork a thread, running a loop which stores its state as an argument to the thread. and you get values out of it with message passing (?). state `threads'.
07:15:30 <opqdonut> soounds ugly?
07:15:35 <LeCamarade> dons: You're doing Erlang????????????????????????????????????????????????????
07:15:44 <EvilTerran> why are there two "ghc - 6.6.1-3.fc7.i386" packages on the fedora package manager?
07:15:44 <dons> no, i was just reading a blog post :)
07:15:58 <LeCamarade> Or is it that reddut article?
07:16:01 <LeCamarade> Phew.
07:16:06 <Nafai> Yay the Lazy Bottoms are in the top 20!
07:16:18 <LeCamarade> I thought you'd betrayed the revolution. High-level defections hurt badly. :o)
07:16:24 <EvilTerran> (one starts "ghc", the other "ghc661". otherwise, they're the same)
07:16:27 <dons> sounds like emulating State monad threads :)
07:16:33 <dons> LeCamarade: i like type systems too much
07:16:51 <crazy_coder> Erlang was developed using Haskell right ?
07:16:55 <LeCamarade> SPJ Joins Java Camp, Denounces `Oppressive' Purely-Functional Paradigm.
07:17:03 <EvilTerran> ah, one of 'em says "This package contains all the main files and libraries of version 6.6.1." in the description
07:17:10 <EvilTerran> shurely the other would, too?
07:17:40 <dons> crazy_coder: nope.
07:17:42 <pejo> crazy_coder, there were projects using Erlang before the first Haskell meeting in 87 iirc.
07:17:56 <pejo> Or case studies atleast.
07:18:25 <dons> yeah, otherwise they'd just have used haskell
07:18:25 <crazy_coder> I read somewhere that ericsson developed Erlang using Haskell
07:18:44 <WynandW> Joe mentions Prolog
07:18:49 <WynandW> In his thesis
07:18:50 <pejo> @go Joe Armstrong phd thesis site:sics.se
07:18:54 <lambdabot> http://www.sics.se/~joe/thesis/armstrong_thesis_2003.pdf
07:19:16 <EvilTerran> anyone?
07:20:08 <WynandW> I have a question with a "Not in scope" error for something I'm pretty sure is in scope...
07:21:32 <dons> WynandW: what value?
07:22:18 <WynandW> Well, I'm going through Jonathan's "Scheme in 48 hours" tutorial. With both the implementations of "car" and "cdr", the last patterns looks as follows:
07:22:22 <crazy_coder> whats the difference between recursive function and a tail recursive function ?
07:22:30 <WynandW> car [barArg] = throwError $ TypeMismatch "pair" badArgcar barArgList = throwError $ NumArgs 1 badArgList
07:22:33 <WynandW> oops
07:22:39 <WynandW> sorry for the concatenation
07:22:47 <WynandW> car [barArg] = throwError $ TypeMismatch "pair" badArg
07:22:47 <WynandW> car barArgList = throwError $ NumArgs 1 badArgList
07:23:08 <WynandW> GHC isn't having any of it
07:23:15 <dons> what's not in scope though?
07:23:19 <dons> throwError?
07:23:21 <EvilTerran> s/badArg/barArg/?
07:23:22 <WynandW> scheme.hs:156:48: Not in scope: `badArg'
07:23:22 <WynandW> scheme.hs:157:40: Not in scope: `badArgList'
07:23:42 <dons> bar/bad
07:26:18 <Botje> crazy_coder: tailrecursive runs in constant space. the haskell wiki has an article about it
07:28:31 <jfredett> Yah, so I don't think I am ever going to understand this ICFP thing. Meh, I'll do something else.
07:28:47 <WynandW> Dons, I see now
07:28:49 <WynandW> Thanks
07:28:53 <WynandW> That was quite dumb of me
07:29:06 <dons> jfredett: heh
07:29:12 <jfredett> its no worries though
07:29:13 <jfredett> I'
07:29:21 <jfredett> I'll understand it someday
07:29:55 <WynandW> jfredett, don't you understand why people want to put themselves through it?
07:30:01 <msouth> crazy_coder: there's also this on wikipedia: http://en.wikipedia.org/wiki/Tail_recursion
07:30:03 <lambdabot> Title: Tail recursion - Wikipedia, the free encyclopedia
07:30:23 <jfredett> I understand why people want to do it. It's a terribly interesting problem
07:30:36 <WynandW> Oh, I haven't checked out the current problems
07:30:39 <jfredett> I just lack the Code-fu to fully comprehend how to do it
07:30:49 <WynandW> I did it last year and felt terribly incompetent
07:30:56 <jfredett> I really liked the Cop/Robber program last year
07:31:04 <earthy> that was 2 years back
07:31:07 <jfredett> I didn't get a chance to participate
07:31:09 <jfredett> oh?
07:31:19 <crazy_coder> > 2^1000
07:31:19 <jfredett> I wasn't around for last year either
07:31:27 <lambdabot>  1071508607186267320948425049060001810561404811705533607443750388370351051124...
07:31:34 <earthy> last year was an ancient scroll written in a language for a weirdo computer
07:31:35 <crazy_coder> yow
07:31:38 <WynandW> We cheated at work :). We just did that instead of our work.
07:31:39 <earthy> that you then had to hack
07:31:48 <crazy_coder> I get 0 as a answer
07:31:57 <earthy> wynandw: hey, that's great!
07:31:58 <crazy_coder> how do I overcome that ?
07:32:19 <earthy> crazy_coder: explicitly type it as :: Integer
07:32:29 <earthy> > 2 ^ 1000 :: Int
07:32:30 <lambdabot>  0
07:32:32 <earthy> > 2 ^ 1000 :: Integer
07:32:34 <lambdabot>  1071508607186267320948425049060001810561404811705533607443750388370351051124...
07:32:42 <crazy_coder> Thanks
07:35:25 <desp> > case n of 0 | 1 -> 2
07:35:25 <lambdabot>   Not in scope: `n'
07:35:37 <desp> case 0 of 0 | 1 -> 2
07:35:41 <desp> > case 0 of 0 | 1 -> 2
07:35:41 <lambdabot>   add an instance declaration for (Num Bool)
07:35:42 <lambdabot>     In a pattern guard for
07:35:42 <lambdabot>      ...
07:35:44 <sjanssen> @yow
07:35:44 <lambdabot> UH-OH!!  We're out of AUTOMOBILE PARTS and RUBBER GOODS!
07:35:58 <desp> is there a way to combine two patterns?
07:36:34 <dons> btw, did people see the short motivational SPJ video on ch9? :) http://channel9.msdn.com/showpost.aspx?postid=326762
07:36:36 <lambdabot> Title: Simon Peyton-Jones: Towards a Programming Language Nirvana
07:37:11 <sjanssen> the motivational video where SPJ puts Haskell towards the "useless" end of the scale :)
07:37:19 <sjanssen> an oversight, I'm sure
07:37:21 <dons> damn straight!
07:37:27 <dons> that's got to be motivating!
07:37:30 <dons> prove him wrong!!
07:38:14 <dons> he's using that graph in the xmonad/haskell talk at oscon, btw
07:38:29 <dons> showing the things that move haskell up, bit by bit, towards useful :)
07:39:05 <desp> cough
07:39:08 <desp> just a simple question
07:39:23 <desp> is it possible to combine two patterns that would have the same effect into one?
07:39:24 <dons> lazybottoms and The Church of the Least Fixed Point still in the top 20.
07:39:39 <jfredett> hmm. It seems ICFP is looking for a Genetic Algorithm, literally and figuratively
07:39:42 <crazy_coder> earthy: the problem now is that the function takes only Int and not Integer, changing the function's type requires me to change various things which I don't want to do. Anyway arounf this ?
07:39:46 <dons> desp, patterns, as in pattern matching?
07:39:50 <desp> i.e.  case foo of Pat1 -> eff; Pat2 -> eff
07:39:59 <desp> into something like  case foo of Pat1 | Pat2 -> eff
07:40:06 <dons> right, you want fall-through cases
07:40:27 <desp> so just  Pat1 ->; Pat2 -> eff?
07:41:30 <dons> no. there's tricks with ==, and case. , or leaving it to the default match
07:41:43 <dons> but no neat way i can think of , this late.
07:42:01 <dons> case x of
07:42:04 <dons>     Pat1 <- x || Pat2 <- x -> eff would be cute :)
07:42:14 <sjanssen> dons: who is The Church of the Least Fixed Point?
07:42:17 <desp> ouch
07:42:24 <dons> alar, et al. iirc
07:42:36 <desp> I believe SML and OCaml allow combining patterns
07:42:36 <dons> desp too. aren't you hacking , desp?
07:42:52 <desp> sjanssen: it's me and 5 other guys from my uni :)
07:43:03 <dons> go team desp!
07:43:05 <jfredett> it occurs to me, that ICFP is something thats more or less impossible to do on your own. :/
07:43:09 <roconnor> ugh, I have a feeling my contest code is going to be hard to debug
07:43:19 <dons> jfredett: that seems like a reasonable conclusion :}
07:43:27 <dons> roconnor: no quickcheck?
07:43:29 * roconnor wonders why he is working alone
07:43:47 <roconnor> dons: no testcases
07:43:54 <dons> ah
07:43:55 <roconnor> no properties
07:44:02 <alar> hello dons
07:44:03 <dons> sounds evil
07:44:11 <crazy_coder> whenever we define a function :: Integer -> Integer and not  f :: Int -> Int
07:44:14 <roconnor> dons: 22 page specification
07:44:15 <alar> can you send lambdabot to #haskell_ru?
07:44:17 <alar> please
07:44:25 <dons> oh, isn't lambdabot2 there?
07:44:34 <crazy_coder> Is there any  thing we must do special for Integer type?
07:44:53 <jfredett> not particularly, crazy_coder
07:44:55 <earthy> crazy_coder: nope
07:45:11 <jfredett> you just need to make sure the arguments are pass it are of the same type, like anything else
07:45:33 <alar> thank you very much!
07:45:42 <roconnor> dons: and the specificaiton is imperitive
07:45:47 <earthy> owh, crazy_coder, sorry I missed your question.
07:45:48 <jfredett> Integer and Int are nasty little buggers
07:45:48 <crazy_coder> What would be the downside of using Integer against Int ?
07:45:55 <roconnor> I'm translating it to something a bit more functional
07:46:00 <dons> evil Utrecht! I always knew they were imperative double-agents!
07:46:03 <jfredett> IIRC its a little slower,
07:46:04 <earthy> Int fits in a machine word
07:46:08 <roconnor> crazy_coder: Integer can be somewhat slower
07:46:11 <crazy_coder> earthy: the problem now is that the function takes only Int and not Integer, changing the function's type requires me to change various things which I don't want to do. Anyway arounf this ?
07:46:18 <earthy> yup
07:46:18 <jfredett> however, it also gives you arbitrary precision
07:46:42 <jfredett> Polymorphism? I think you could do Integral a => a -> a
07:47:05 <jfredett> that would, however, give more than just Integer and Int
07:47:07 <Saizan> crazy_coder: it will probably only change type signatures
07:47:09 <jfredett> i'm not sure if it'd work
07:47:11 <earthy> crazy_coder: use  toInteger
07:47:27 <roconnor> @type fromIntegeral
07:47:29 <lambdabot> Not in scope: `fromIntegeral'
07:47:32 <roconnor> @type fromIntegral
07:47:33 <lambdabot> forall a b. (Num b, Integral a) => a -> b
07:47:35 <earthy> @type toInteger (2 :: Int)
07:47:37 <lambdabot> Integer
07:47:41 <crazy_coder> Is there a way to say that : Take an Int as a normal argument, but when given an Integer accept that too ?
07:47:47 <roconnor> > (fromIntegral (5::Integer)):Int
07:47:47 <lambdabot>   Not in scope: data constructor `Int'
07:47:51 <roconnor> > (fromIntegral (5::Integer))::Int
07:47:52 <lambdabot>  5
07:48:02 <earthy> > toInteger (2 :: Int) ^ (toInteger (1000 :: Int))
07:48:03 <lambdabot>  1071508607186267320948425049060001810561404811705533607443750388370351051124...
07:48:07 <LeCamarade> dons: Will someone promise to upload the vid of SPJ's talk?
07:48:09 <chrisamaphone> anyone here doing the icfp contest?
07:48:11 <jfredett> crazy_coder: I think using (Integral a) => a -> a
07:48:14 <jfredett> will work
07:48:20 <earthy> chris: probably :)
07:48:24 <LeCamarade> The tutorial with Xmonad in it?
07:48:26 <crazy_coder> :t toInteger
07:48:27 <lambdabot> forall a. (Integral a) => a -> Integer
07:48:29 <jfredett> chrisamaphone: #haskell-icfp07
07:48:30 <LeCamarade> Someone, please? :o((
07:48:30 <jfredett> :P
07:48:37 <chrisamaphone> jfredett: ah, thanks :)
07:48:46 <jfredett> noonestalking, there, thos
07:48:48 <jfredett> though*
07:48:53 <roconnor> jfredett: should I join that channel?
07:48:54 <crazy_coder> Ok thanks
07:48:56 <crazy_coder> Lets se
07:49:00 <jfredett> why not?
07:49:01 <earthy> crazy_coder: there is a way of saying that yeah. e.g.  f :: (Integral a) => a -> Integer
07:49:03 <chrisamaphone> is there a general channel for the contest?
07:49:18 <jfredett> #oasis, i think
07:49:20 <earthy> #oasis seems to be used
07:49:31 <chrisamaphone> thanks.
07:50:51 <roconnor> I thought #oasis was for the oasis haskell team
07:51:40 <dons> just use #haskell-icfp07
07:51:56 <dons> then you don't have to hang out in the lazy bottoms channel ;)
07:54:50 <WynandW> ha ha
07:59:29 <sjanssen> @useres
07:59:29 <lambdabot> Maximum users seen in #haskell: 362, currently: 352 (97.2%), active: 21 (6.0%)
08:00:36 <roconnor> type DNAMonad = RWS () [B.ByteString] B.ByteString
08:00:53 * roconnor decides to find out just how bad MonadWriter is.
08:02:01 <dozer> Can't make a derived instance of `Typeable (ClassAxiom ...)' (`ClassAxiom' has too many arguments)
08:02:04 <Saizan> roconnor: you forgot lvl!
08:02:11 <sjanssen> how can I tell darcs to suppress detailed info about changes while recording?
08:02:14 <dozer> is there a switch I can throw in ghc to fix this?
08:03:04 <dons> sjanssen: darcs record --all ?
08:03:20 <Saizan> dozer: you need TypeableN maybe?
08:03:26 <sjanssen> dons: thanks
08:03:34 <dons> roconnor: huh, RWS () [B.ByteString] B.ByteString looks *almost* like the Put monad.
08:03:46 <dons> or Put/Get
08:03:46 <sjanssen> I didn't want to wait for 7MB of alien DNA to scroll past while recording my patch
08:03:51 <dons> heh
08:03:55 <ski> dozer : o.O
08:05:15 <mux> dons: does GHC HEAD allows using ByteString through the new IsString type-class so that we don't need to import it qualified ?
08:05:44 <dons> hmm. not sure. sounds dodgy, since the Prelude won't be IsString-polymorphic
08:05:49 <sjanssen> mux: IsString doesn't really help there
08:05:58 <dons> i think it just means you'll be able to avoid 'pack'
08:06:02 <sjanssen> mux: because Data.ByteString.head will still clash with Prelude.head
08:06:02 <dozer> Saizan: do I? I had just been calling `deriving (... Typeable, Data)' - would I need to change this?
08:06:12 <mux> sjanssen: oh yeah.
08:06:22 <mux> damn, it would be good to find a solution to that
08:06:27 <crazy_code1> sorry
08:06:33 <crazy_code1> I got disconnected
08:06:35 <roconnor> dons: what's a Put Monad?
08:06:53 <crazy_code1> Anyones got the answer for my previous question ?
08:06:58 <mux> roconnor: the write monad for Data.Binary, I think
08:07:10 <roconnor> Saizan: I don't need level.
08:07:35 <crazy_code1> > > let splitNumber1 x | (x>=1) = (mod x 10): (splitNumber1 (quot x 10))
08:07:35 <lambdabot>  Parse error
08:07:35 <crazy_code1> 	                             | otherwise = []
08:07:35 <crazy_code1>                                in foldl (+) 0 (splitNumber1 (2^1000 :: Integer))
08:08:33 <roconnor> Saizan: level is for crappy languages that don't support recursion ;)
08:09:09 <dons> so is it a language implementation puzzle, with a big data set?
08:09:35 <dons> good thing we have bytestrings now. UArray Word8 is such a pain.
08:12:01 <xerox> I wonder why I don't have RWS using a darcs ghc build
08:12:24 <dozer> Saizan: so you are saying I need to create and implement Typeable8, Typeable9, ... untill I hit the size my datatype needs?
08:12:33 <dons> xerox: no mtl library?
08:12:55 <Saizan> dozer: Data.Typeable has TypeableN till Typeable7
08:13:06 <xerox> dons: ghc-pkg list has it
08:13:44 <Saizan> dozer: does you datatype have have an higher kind?
08:13:57 <dozer> Saizan: I can see that, but my datatype has 13 of them :(
08:14:51 <dozer> Saizan: so I need instances of Typeable8 ... Typeable13 presumably?
08:16:09 <Saizan> you'd only need an instance of Typeable13, considering the pattern of instance (Typeable(n+1) s, Typeable a) => Typeable(n) (s a)
08:16:48 <sjanssen> dons: this ICFP task is looking like a good job for binary
08:16:51 <dozer> Saizan: will I need all of these clases though?
08:17:06 <sjanssen> I might use: type M a = WriterT Put Get a
08:17:11 <sjanssen> Put is monoid, right?
08:17:17 <sjanssen> a monoid
08:17:20 <dons> yeah, Builder, underneath is
08:17:43 <dons> newtype PutM a = Put { unPut :: (a, Builder) }
08:17:43 <dons> -- | Put merely lifts Builder into a Write monad, applied to ().
08:17:43 <dons> type Put = PutM ()
08:18:02 <dons> a simple wrapper over Builder to get do-notation
08:18:20 <Saizan> dozer: i'm not sure, you might find a better way, in the end you want Typeable (ClassAxiom a1 ... a13) probably
08:20:26 <dozer> Saizan: well, yes - that's exactly what I *do* want. Pitty ghc seems to be stuck at things of arity 7 :(
08:21:34 <WynandW> What!? Did I just read that correctly? Does GHC place a limit of 7 on the arity of anything?
08:22:16 <dons> WynandW: no.
08:22:24 <dons> ?join #haskell-icfp07
08:22:30 <WynandW> Oh. Phew. I was almost very disppointed.
08:22:57 <dons> > let f _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ x20 = x20 in f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 "hey!"
08:23:05 <lambdabot>  "hey!"
08:23:12 <WynandW> he he
08:23:17 <WynandW> Okay. Point made. :)
08:23:42 <Saizan> on functions it doesn't really matter, they all have and arity of 1 :P
08:24:56 <dons> win 11
08:25:10 <WynandW> Onto another topic... I think I "get" Monads now. It took me an awfully long time. Is that the experience of other people here?
08:26:40 <dozer> I can't see from the Typeable documentation how I can manually implement the Typeable class
08:31:47 <sjanssen> dozer: you shouldn't do that
08:32:01 <sjanssen> dozer: use "deriving Typeable"
08:32:39 <dozer> sjanssen: that's what I'm trying to say - ghc won't derive these instances for things of arity greater than 7
08:33:30 <sjanssen> dozer: oh, ouch
08:35:48 <xerox> what's the right way to do Char -> Word8
08:36:24 <EvilTerran> > toEnum (fromEnum "A") :: Word8
08:36:31 <lambdabot>   add an instance declaration for (Enum [Char])
08:36:38 <EvilTerran> > toEnum (fromEnum 'A') :: Word8
08:36:40 <lambdabot>  65
08:36:58 <xerox> thanks.
08:37:03 <EvilTerran> np
08:37:04 <desp> argh
08:37:09 <desp> anyone familiar with Data.Binary?
08:37:18 <sjanssen> desp: yes
08:38:13 <desp> sjanssen: I wish to successively put Chars and get a lazy ByteString
08:38:24 <WynandW> I don't quite get how the karma thing, as explained on haskell.org, works for this channel. If x gives a useful answer, should I type x++ 1?
08:38:52 <desp> sjanssen: I don't quite get how to get an initial empty value
08:39:17 <sjanssen> WynandW: yes, whenever x does something praiseworthy, you can type "x++" without the quotes
08:39:18 <mrd> WynandW: if you wish the person to be reborn in the next life on a higher plane, then say: person++
08:39:30 <sjanssen> desp: you're using the Put monad?
08:39:30 <kaol> @karma person
08:39:31 <lambdabot> person has a karma of 1
08:39:31 <WynandW> mrd++
08:39:39 <WynandW> sjanssen++
08:39:40 <WynandW> :)
08:39:43 <desp> sjanssen: I'd like to, yes
08:39:58 <EvilTerran> do you have to do that at the start of a line, or can it be anywhere as long as it's surrounded by spaces?
08:39:58 <mrd> wooohoo, no frog existence for me
08:39:59 <sjanssen> desp: you don't have to start with an empty value
08:40:34 <mrd> time to start reading this year's task
08:40:43 <desp> sjanssen: but what if I need one?
08:40:48 <sjanssen> desp: runPut (do put 'a'; put 'b'; put 'c')
08:40:59 <sjanssen> that will result in the ByteString "abc"
08:41:03 <desp> ok, that's good
08:41:10 <EvilTerran> ?type runPut
08:41:12 <lambdabot> Not in scope: `runPut'
08:41:15 <desp> any way to result in the empty BS?
08:41:31 <sjanssen> desp: runPut (return ())
08:41:38 <desp> aha
08:41:40 <desp> thanks
08:41:40 <sjanssen> ie. don't run any actions
08:41:48 <EvilTerran> would runPut mzero work too?
08:42:06 <sjanssen> EvilTerran: put isn't in MonadZero
08:42:21 <EvilTerran> ah, okay.
08:42:31 <EvilTerran> @index runPut
08:42:32 <lambdabot> bzzt
08:44:25 <desp> sjanssen: one last question
08:44:33 <sjanssen> actually, I don't think you can give a good definition of mzero for PutM
08:45:11 <desp> sjanssen: I need to collect put actions between successive recursive invocations of my function
08:45:11 <dozer> so should I be editing Data/Typeable.hs to add in the extra definitions I need?
08:45:12 <sjanssen> the only thing that has the right type is "return undefined", but that kinda sucks
08:45:38 <sjanssen> dozer: you might be able to write Typeable8 and so forth
08:45:45 <hpaste>  (anonymous) annotated "words" with "(no title)" at http://hpaste.org/1789#a1
08:46:14 <dozer> sjanssen: yes - I'm assuming they will have to be compiled into that module though?
08:46:35 <sjanssen> dozer: no, you can keep them local to your project
08:46:51 <dozer> sjanssen: so they can go into any old module?
08:46:57 <sjanssen> dozer: you might ask libraries@haskell.org if they'll consider extending the TypeableN instances
08:47:16 <sjanssen> dozer: sure
08:47:29 <sjanssen> desp: collect them for what purpose?
08:47:42 <shazam> ok, someone tell me I'm not going nuts
08:47:45 <shazam> isn't
08:47:46 <sjanssen> desp: if you just need to add them to the stream:
08:47:58 <shazam>       foldl (\sofar lste -> try (lste allNonFree) <|> sofar) (error "fail") [leftrecsDeRecursifiedFree,nonleftrecsFree]
08:47:59 <shazam> the same as
08:48:10 <shazam> try (leftrecsDeRecursifiedFree allNonFree) <|> try (nonleftrecsFree allNonFree) <|> error "fail"
08:48:26 <sjanssen> let putList (x:xs) = (do put x; putList xs); putList [] = return () -- for example
08:48:50 <desp> ok, putlist :: [a] -> Put?
08:48:54 <sjanssen> yeah
08:49:17 <desp> what about something like putList :: [a] -> ([a], Put)?
08:49:40 <sjanssen> where does the resulting list come from?
08:50:02 <desp> just trivially build the list again
08:50:10 <sjanssen> PutM is a Monad, so we'd probably write: [a] -> PutM [a]
08:50:17 <desp> ah ha
08:50:43 <desp> thanks
08:50:44 <sjanssen> type Put = PutM () -- Put is an alias for PutM actions that return no extra output
08:54:43 <desp> hmm
08:55:20 <desp> do you suppose collecting put actions for Chars and then doing a runPut would be faster/better/harder/stronger as compared to collecting Chars in a list and then doing a BS.pack?
08:56:15 <desp> I don't see how, unless the Put monad is somehow very smart
08:56:51 <matthew-_> I think it's meant to be very smart
08:56:58 <matthew-_> it uses BS internally
08:57:11 <desp> ah, hmm
08:59:41 <msouth> a lot of our corporate decisions seem to be internally based on BS, but they don't seem all that smart...
08:59:45 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/1791
08:59:49 <msouth> oh, you guys were talking about something else
08:59:59 <shazam> actually, I pasted that
09:00:07 <shazam> I can't see the difference between the 2 terms
09:01:13 <desp> msouth++
09:01:18 <desp> sjanssen++
09:01:54 <shazam> shouldn't the type of foldl1 be (b -> a -> b) -> [a] -> b ?
09:02:18 <EvilTerran> ?type foldl1
09:02:21 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
09:02:27 <EvilTerran> ?type foldl
09:02:29 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
09:03:15 <matthew-_> shazam: foldl1 applies the function initially between the first and second elems of the list
09:03:19 <matthew-_> which have the same type
09:03:25 <matthew-_> hence the a -> a -> a
09:03:28 <EvilTerran> shazam, as both parameters to the function come from the li- ah, what matthew-_ said.
09:03:31 <shazam> righto
09:03:52 <shazam> anyways, someone help me with my paste!
09:04:08 <shazam> http://hpaste.org/1791
09:04:13 <shazam> it's a simple problem
09:04:34 <matthew-_> @quote stereo
09:04:34 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
09:04:36 <nominolo> :t ap
09:04:38 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
09:05:47 <shazam> hrmph
09:05:53 <shazam> they're obviously different
09:05:54 <shazam> my bad
09:08:05 <chessguy> @type evalState
09:08:06 <lambdabot> forall s a. State s a -> s -> a
09:15:21 <shazam> @type foldr1
09:15:23 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
09:25:35 <istirbu> hello, I have trouble compiling the unix-2.0 package, it gives me an error in the System/Posix/Files.hsc at line 267
09:26:33 <istirbu> it says: Couldn't match expected type `CInt' against inferred type `CMode'
09:26:43 <istirbu> can anyone give me a hint on that?
09:28:27 <LeCamarade> Where can I find a hs-plugins tutorial?
09:34:56 <LeCamarade> *shrug* They are all doing the Competition. :o(
09:35:02 * LeCamarade will be back.
09:35:49 <roconnor> @type maybe
09:35:52 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
09:39:46 <Saizan> > fail "" :: RWS () () () ()
09:39:47 <lambdabot>        add an instance declaration for (Show (RWS () () () ()))
09:40:38 <Saizan> ?index RWS
09:40:38 <lambdabot> Control.Monad.RWS, Control.Monad.RWS
09:40:51 <Saizan> ?docs Control.Monad.RWS
09:40:52 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-RWS.html
09:40:54 <dynamix> ?pl (\(a, b) -> [a, b])
09:40:55 <lambdabot> uncurry ((. return) . (:))
09:52:51 <dynamix> ?pl (\x->x)
09:52:52 <lambdabot> id
09:52:58 <dynamix> ?pl (\x->x*x)
09:52:58 <lambdabot> join (*)
09:54:17 <ddarius> @pl \x -> foldr c n $ map f x
09:54:17 <lambdabot> foldr c n . map f
09:54:28 <dynamix> ?pl (\x->x+x)
09:54:29 <lambdabot> join (+)
09:54:40 <dynamix> ?pl (\x->2*x)
09:54:40 <lambdabot> (2 *)
09:55:03 <dynamix> ddarius: is there a place i can try these without polluting the main chat room ?
09:55:12 <ddarius>  /msg
09:55:26 <dynamix> example plaese?
09:55:45 <ddarius>  /msg lambdabot ?pl \x -> x
09:56:05 <EvilTerran> /query lambdabot, then do the same commands in the msg-window
09:56:37 <dynamix> i guess  ?pl returns the eta reduced equivalent ?
09:57:01 <ddarius> dynamix: @pl compiles your code to combinators
09:58:11 <ddarius> Eta reduction is just the obvious equivalence of \x -> f x and f
09:58:33 <int-e> @pl \x y z -> x z (y z)
09:58:34 <lambdabot> ap
09:59:24 <dynamix> ?pl \a b -> [a,b]
09:59:24 <lambdabot> (. return) . (:)
10:00:02 <dynamix> how could i have come up with this? can you please explain (. return) ?
10:00:22 <olsner> \x -> (x . return)
10:01:13 <ddarius> dynamix: By compilation
10:01:20 <int-e> dynamix: here, return = \x -> [x]
10:01:32 <ddarius> > return 3 :: [Int]
10:01:33 <lambdabot>  [3]
10:02:16 <int-e> (. ([] :)) . (:)  is prettier.
10:02:22 <int-e> err
10:02:30 <int-e> (: []) not ([] :) of course. silly me
10:02:33 <dynamix> the initial . is what i dont get
10:02:40 <Saizan> \a b -> [a,b] = \a b -> a:[b] = a : return b = \a b -> (:) a (return b) = \a -> (:) a . return = (return .) . (:)
10:02:49 <Saizan> err
10:03:13 <int-e> \a -> (:) a . return  = (. return) (\a -> (:) a)
10:03:22 <int-e> it's a slice.
10:03:27 <EvilTerran> ((. f) . g) x y = (. f) (g x) y = (g x . f) y = g x (f y)
10:03:32 <int-e> huh
10:03:40 <int-e> \a -> (:) a . return  = \a -> (. return) ((:) a)
10:04:58 <opqdonut> :t join
10:05:00 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
10:05:16 <opqdonut> :t join (*)
10:05:18 <lambdabot> forall a. (Num a) => a -> a
10:06:44 <dynamix> :t ( ( . f) . g) x y
10:06:46 <lambdabot> Not in scope: `f'
10:06:46 <lambdabot>  
10:06:46 <lambdabot> <interactive>:1:11: Not in scope: `g'
10:07:21 <dynamix> :t ( ( . return) . (:)) x y
10:07:23 <lambdabot> Not in scope: `x'
10:07:23 <lambdabot>  
10:07:23 <lambdabot> <interactive>:1:23: Not in scope: `y'
10:07:29 <dynamix> :t ( ( . return) . (:)) 1 2
10:07:31 <lambdabot> forall a. (Num a) => [a]
10:07:46 <EvilTerran> :t \f g x y -> ( ( . f) . g) x y
10:07:48 <lambdabot> forall b c a a1. (a -> b) -> (a1 -> b -> c) -> a1 -> a -> c
10:08:15 <dynamix> grrrr... im about to pull my hair out
10:09:13 <mrd> @hoogle MaybeT
10:09:13 <lambdabot> Maybe.maybeToList :: Maybe a -> [a]
10:09:32 <olsner> :t on
10:09:34 <lambdabot> Not in scope: `on'
10:09:46 <EvilTerran> consider that (. f) g = g . f; with that in mind, it's possible to translate back-and-forth by hand
10:10:23 <dynamix> (. f ) g is (. f) applied on g
10:11:00 <EvilTerran> yes. which is g . f
10:11:14 <EvilTerran> like (^2) 3 is 3^2
10:11:51 <dynamix> so is . functio nby itlsef like ^ is ?
10:12:29 <EvilTerran> @src (.)
10:12:29 <lambdabot> (.) f g x = f (g x)
10:12:36 <EvilTerran> yes
10:12:41 <olsner> all operators in haskell are also usable as functions by putting parantheses around them
10:12:43 <EvilTerran> ?type (.)
10:12:45 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
10:12:46 <olsner> > (+) 1 2
10:12:47 <lambdabot>  3
10:12:57 <hpaste>  fxr pasted "lambdabot compile error" at http://hpaste.org/1792
10:13:17 <fxr> any patches for this problem?
10:13:24 <dynamix> (+) 1 2 is 1 + 2
10:13:41 <dynamix> (.) f g is f. g?
10:13:44 <EvilTerran> yes.
10:14:04 <EvilTerran> (%) x y = x % y, regardless of what operator "%" is
10:14:07 <dynamix> > return 1
10:14:08 <lambdabot>   add an instance declaration for (Show (m t))
10:14:17 <EvilTerran> @src [] return
10:14:17 <lambdabot> return x    = [x]
10:14:28 <EvilTerran> @src Maybe return
10:14:29 <lambdabot> return              = Just
10:14:37 <EvilTerran> @src Either return
10:14:37 <lambdabot> return        = Right
10:14:43 <dynamix> where can i use return ?
10:14:54 <Syzygy-> dynamix: Whenever you want to get into a monad.
10:14:55 <EvilTerran> return is overloaded; it's a monad thing.
10:15:12 <EvilTerran> (sorry, polymorphic)
10:15:35 <EvilTerran> you can write (\x -> [x]) or (:[]), if you'd rather
10:15:36 <wli> both
10:16:14 <Toxaris> i want to run ByteString stuff in ghci, but it *exits to shell* (!) and tells me about "asyncRead# on threaded RTS"
10:16:25 <EvilTerran> before i got used to the idea of return x :: [a] being [x], i'd put "enlist x = [x]" at the top of my source files
10:17:46 <blsecres> whats the motivation of Map.differenceWith :: (a -> b -> Maybe a) -> Map k a -> Map k b -> Map k a
10:18:09 <blsecres> opposed to Map.differenceWith :: (a -> a -> a) -> Map k a -> Map k a -> Map k a
10:18:31 <dynamix> what does putting that line at the top do ?
10:18:57 <EvilTerran> dynamix, means i can write "map enlist xs", say, and it'd do the same as [[x] | x <- xs]
10:19:33 <blsecres> I can call Map.unionWith (+), but have to call Map.differenceWith ((Just .) . (-)) which doesn't seem symmetric
10:19:34 <dynamix> oh you just defined enlist as a function that takes a value and makes a list out of it :0
10:19:34 <EvilTerran> or, as we were doing here, (. enlist) . (:)
10:19:45 <EvilTerran> yeah
10:21:07 <EvilTerran> ...how does one compare RPMs that're in the F7 Everything repo? anyone know off-hand?
10:21:32 * EvilTerran is trying to work out why there's a ghc-6.6.1-3.fc7.i386.rpm and a ghc661-6.6.1-3.fc7.i386.rpm
10:21:33 <wli> blsecres: it's not symmetric
10:21:56 <wli> blsecres: the types even say so
10:22:11 <blsecres> wli: I know, the question is why are the types different
10:22:43 <blsecres> wli: why not differenceWith :: (a -> a -> a) -> Map k a -> Map k a -> Map k a
10:22:53 <wli> blsecres: it's the keys that determine it not the elements
10:23:42 <sfultong> lambdabot should have a function that shows you what series of monadic transformations it takes to get a given function type...
10:25:17 <blsecres> the keys are all the same type for unionWith and differenceWith, it's the type of the value of the second map that differs and the `With' function returning Maybe a instead of a
10:25:56 * EvilTerran was thinking about something whereby you could give it a list of functions (and their types), and it'd work out how to fit them together. insert/remove (.)s, ($)s, liftMs, and so forth.
10:26:11 <sfultong> yeah, that'd be good
10:26:34 <EvilTerran> probably equivalent to the halting problem, tho ;]
10:26:50 <kpreid> probably usually has more the one answer
10:27:00 <dynamix> EvilTerran: thanks, ill get back to this later today.
10:27:29 <EvilTerran> np.
10:27:48 <EvilTerran> kpreid, indeed. add "const undefined" everywhere 'til it works. ;]
10:28:28 <kpreid> nah, even non-undefined ones
10:29:08 <EvilTerran> i do see what you mean. you'd have to define some sort of metric for picking which one's most likely to be correct
10:29:16 <kpreid> e.g. given return, return, you can produce: return >>= return; return . return; return return; (return .) . return; ...
10:29:28 <kpreid> @type (return .) . return
10:29:30 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => a1 -> a -> m a1
10:31:19 <EvilTerran> maybe take a badly-typed expression to start with, and try to find the least possible change required to make it typecheck
10:31:51 <Saizan> (return .) . return is evil
10:32:08 <EvilTerran> ...i... don't know what that does.
10:32:27 <olsner> :t (return .) . return
10:32:29 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => a1 -> a -> m a1
10:33:01 <Saizan> well the rightmost return takes 2 arguments, find the monad :)
10:33:06 <olsner> so, one of the return's end up in the (-> a) monad?
10:33:25 <Saizan> a ->
10:33:40 <olsner> (not that I actually understand how the (->) a monad works)
10:34:00 <Saizan> basically, it's const
10:34:21 <EvilTerran> ((return .) . return) x y = ((return .) (return x)) y = (return . return x) y = return (return x y)
10:34:32 <olsner> @src (a ->) (>>=)
10:34:32 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
10:34:44 <EvilTerran> @src (->) (>>=)
10:34:44 <lambdabot> f >>= k = \ r -> k (f r) r
10:35:35 <EvilTerran> @src (->) return
10:35:36 <lambdabot> return = const
10:36:00 <opqdonut> @src (->) join
10:36:00 <lambdabot> Source not found. My mind is going. I can feel it.
10:36:10 <Saizan> @src join
10:36:11 <lambdabot> join x =  x >>= id
10:36:27 <opqdonut> ahh, i see
10:38:51 <EvilTerran> incidentally, re "1820 * EvilTerran is trying to work out why there's a ghc-6.6.1-3.fc7.i386.rpm and a ghc661-6.6.1-3.fc7.i386.rpm", the former depends on the latter, and appears to do little beyond symlinking /usr/bin/ghc /usr/bin/ghc661 and so forth
10:39:07 <olsner> @pl (\r -> id (f r) r)
10:39:08 <lambdabot> join f
10:39:22 <olsner> elucidating
10:40:02 <EvilTerran> id (f r) r = f r r, shurely?
10:40:58 <Saizan> yup, he has inlined (->) e >>= inside the definition of join
10:42:16 <olsner> that's exactly what I did, heh ;-)
10:48:06 <dolio> @pl (\r -> ask (f r) r)
10:48:06 <lambdabot> ask =<< f
10:59:29 <glguy> lol... the base pairs are icfp
11:13:53 <asad> :-!
11:17:40 <EvilTerran> dsfargeg
11:18:08 <glguy> English, please
11:18:09 <glguy> ;)
11:19:49 <olsner> dsfargeg's a word!
11:20:32 <glguy> well, it's a YTMND site at least
11:23:41 <glguy> Its seems common to hate on Data.HashTable, but is there anything "wrong" with it as a data-structure?
11:23:52 <glguy> other than that it is mutable and lives in IO
11:24:02 <dolio> I think that's the reason.
11:24:12 <glguy> but if that was what you wanted, then its great?
11:24:33 <dolio> Quite possibly. Can't say I've used it.
11:24:50 * glguy wonders if anyone else wishes that they could set the z-order of their windows like:
11:24:53 <glguy> -|
11:24:55 <glguy> |-
11:25:06 <glguy> such that each window of 4 overlaps one of the others
11:25:31 <monochrom> Data.HashTable is slow
11:26:06 <glguy> so an IORef (Map String a) might be faster?
11:26:20 <monochrom> Yes.
11:26:34 <glguy> because comparison is faster than hashing?
11:26:48 <dolio> Having to provide a (key -> Int32) might be a pain, as well.
11:26:55 <monochrom> Actually, I don't understand why it is slow.
11:27:08 <glguy> maybe because no on euses it so no one optimizes it?
11:27:59 <monochrom> Quite possible.
11:28:46 <desp> sjanssen: poke
11:29:18 * desp needs a little help with PutM
11:29:23 <desp> Data.Binary.Put.PutM
11:29:37 <EvilTerran> glguy, nice idea, but how would it _work_?
11:29:46 <EvilTerran> (re windows)
11:30:08 <glguy> EvilTerran: no idea really, I'm not even sure it is useful, I just think it would be a fun trick
11:30:49 <monochrom> Escher window z-order :)
11:31:07 <EvilTerran> i guess you could make the window ordering a many-to-many relationship
11:31:25 <glguy> windows that would cut through each other would have  to have some kind of hard stop
11:31:29 <glguy> or
11:31:34 <glguy> moving one window could push another
11:31:43 <glguy> for example if you had 4 windows all cross up
11:31:52 <glguy> moving the right most to the left would intersect with the left one
11:32:09 <glguy> since it would be neither above nor below
11:32:15 <EvilTerran> wrt usefulness, it'd be no worse than, say, windows wobbling when you move them, but *that* seems pretty popular.
11:32:21 <glguy> heh
11:32:37 <glguy> yeah, if I could use 3d effects to make the windows knot themselves up like that
11:32:40 <glguy> people would eat it up
11:32:51 <sfultong> wobbling has a use: in induces cheerfulness
11:33:04 <glguy> I'd toss it to the ruby community, andthey'd be so busy trying to untie their windows that they'd stop blogging!
11:33:11 <glguy> imagine the possiblilities here
11:33:18 <EvilTerran> :D
11:34:23 <EvilTerran> although, isn't the z-order used to decide what order to paint everything in?
11:34:33 <glguy> yup!
11:34:47 <glguy> never said that it'd be easy
11:34:55 <EvilTerran> i think you'd probably have to change things in the X source. good luck with that.
11:35:36 <sfultong> well, if windows were planes in a 3rd world, they could have kindof a gradient of z values
11:35:45 <etnt> Hm..I'm getting:  Kind error: `String' is applied to too many type arguments
11:35:56 <etnt> what's a Kind error ?
11:37:14 <EvilTerran> > undefined :: String Int
11:37:15 <lambdabot>      Kind error: `String' is applied to too many type arguments
11:37:15 <lambdabot>     In the ty...
11:37:22 <EvilTerran> > undefined :: Maybe
11:37:23 <lambdabot>      `Maybe' is not applied to enough type arguments
11:37:23 <lambdabot>     Expected kind `?', b...
11:37:36 <byorgey> etnt: do you know what a kind is?
11:38:02 <etnt> hm, not really , something with type classes ?
11:38:28 <hpaste>  desp pasted "why doesn't this type?" at http://hpaste.org/1794
11:38:36 <EvilTerran> etnt, the Kind of a parameterised type is the number of types it takes as parameters (roughly). values must have a type of Kind * (no parameters).
11:38:42 <desp> can someone help me? :)
11:38:49 <EvilTerran> "Maybe" has kind * -> * (one parameter)
11:38:49 <desp> s/type/typecheck/
11:38:51 <monochrom> Looking.
11:39:35 <byorgey> etnt: in other words, Maybe is not a type in and of itself, it is a sort of "type function" which takes one type and produces another
11:39:38 <EvilTerran> so you can't have something of type "Maybe". however, in "Maybe Int", that one type parameter is used, so Maybe Int has kind "*", and you can have values of kind "Maybe Int"
11:39:44 <etnt> Hm, I have a funtion:
11:40:09 <etnt> aaa :: String [String] Integer -> String
11:40:19 <hpaste>  monochrom annotated "why doesn't this type?" with "try this" at http://hpaste.org/1794#a1
11:40:27 <opqdonut> huh, String [String] Integer looks very invalid
11:40:27 <monochrom> desp: try that
11:40:28 <EvilTerran> aaa :: String -> [String] -> Integer -> String
11:40:32 <desp> ack
11:40:48 <etnt> EvilTerran: aaahhggg...
11:41:05 <desp> monochrom: doh, that works :)
11:41:16 <etnt> its sureley one thing reading about Haskell, another to actuallly write code...
11:41:17 <EvilTerran> etnt, putting two types side-by-side separated only by whitespace is like putting two values together - it applies the first to the second
11:41:30 <monochrom> "foo xs' " does not have type [Int]. It has type PutM [Int]. You need >>= or do notation to get it's "answer".
11:41:35 <monochrom> s/it's/its/
11:41:43 <desp> right, right
11:41:47 <desp> monochrom++
11:41:52 <monochrom> Danke :)
11:42:12 <etnt> EvilTerran: thx!
11:42:17 <byorgey> etnt: generally, whenever you have a function which takes multiple parameters, its type will be something like fun :: Param1 -> Param2 -> Param3 -> Result
11:42:39 <EvilTerran> etnt, (->) is right-associative, so that type i had there is the same as String -> ([String] -> (Integer -> String))
11:42:46 <etnt> byorgey: because the currying property I guess ?
11:42:52 <byorgey> etnt: exactly!
11:43:05 <EvilTerran> etnt, ie, given a string, it returns a function that takes a list of strings and returns a function that takes an integer and returns a string
11:43:11 <EvilTerran> (phew!)
11:43:19 <byorgey> etnt: really, there's actually no such thing as functions which take multiple parameters =)
11:43:46 <EvilTerran> saying "foo a b c = ..." is the same as saying "foo = \a -> \b -> \c -> (...)"
11:43:47 <desp> monochrom: can you tell me now how to use runPut on this function?
11:44:07 <etnt> yes, I should know that, but it is easy to forget it... :-)
11:44:10 <desp> monochrom: runPut :: Put -> ByteString
11:44:18 <desp> type Put = PutM ()
11:44:40 <EvilTerran> or "foo a = fooA where fooA b = fooAB where fooAB c = fooABC where fooABC = ..."
11:44:53 <byorgey> etnt: no problem, that's what #haskell is for =)
11:45:52 <etnt> appreciate it!
11:47:26 <aeyakovenko> how come, (return $! [1..]) >>= take 10, works?  i thought $! would force [1..] to evaluate fully
11:48:00 <dolio> Nope.
11:48:04 <EvilTerran> $! only evaluates as far as the outermost constructor
11:48:40 <EvilTerran> i.e. forces it to not *be* _|_. it can still *contain* _|_.
11:48:45 <xerox> dons: rm State/karma is not enough for lambdabot? why does it "urk!" and not load?
11:48:47 <EvilTerran> (or be infinite, or whatever)
11:49:00 <etnt> a newline in a string is that written as: "\n"
11:49:10 <dolio> > return $| rnf $ [1..] >>= take 10
11:49:18 <byorgey> > "345\nabc"
11:49:18 <lambdabot>   add an instance declaration for (Show (m [a]))
11:49:19 <lambdabot>  "345\nabc"
11:49:38 <Eelis> i wish ghc wouldn't warn about unused constructors and record field names for data types deriving Read
11:49:42 <byorgey> > putStrLn "abc\nabc"
11:49:43 <lambdabot>  <IO ()>
11:49:49 <EvilTerran> etnt, yes.
11:49:52 <byorgey> etnt: erm, anyway, yes =)
11:49:57 <EvilTerran> @where report
11:49:57 <lambdabot> http://www.haskell.org/onlinereport/
11:50:00 <sfultong> '\n' : "345"
11:50:03 <sfultong> > '\n' : "345"
11:50:04 <lambdabot>  "\n345"
11:50:05 <etnt> thx!
11:50:16 * desp pokes monochrom
11:50:23 <hpaste>  monochrom annotated "why doesn't this type?" with "example of runPut" at http://hpaste.org/1794#a2
11:51:02 <desp> monochrom: heh, but the foo function was just an illustration of the recursion that I need to use :)
11:51:12 <EvilTerran> etnt, http://www.haskell.org/onlinereport/lexemes.html#lexemes-char
11:51:13 <lambdabot> Title: Haskell 98 Lexical Structure
11:51:28 <monochrom> I don't understand why you must have PutM [Int] rather than PutM ().
11:51:37 <hpaste>  desp annotated "why doesn't this type?" with "actual" at http://hpaste.org/1794#a3
11:51:45 <desp> see this
11:51:47 <aeyakovenko> EvilTerran, any way to force the entire thing to be evaluated?
11:52:02 <desp> type DNA = ByteString
11:52:25 <EvilTerran> aeyakovenko, do you want each value to be evaluated, or merely each constructor in the list?
11:52:35 <aeyakovenko> EvilTerran, each value
11:52:39 <pierre1> ?src concatMap
11:52:39 <lambdabot> concatMap f = foldr ((++) . f) []
11:52:52 <olsner> deepSeq ...
11:52:54 <EvilTerran> ie, should giving it [1,2,undefined,4,5] be a problem?
11:53:08 <EvilTerran> or merely something like 1:2:3:undefined
11:53:10 <desp> monochrom: I need to return the part left after all BS.drops
11:53:14 <aeyakovenko> EvilTerran, yea, it should break if its undefined
11:53:42 <roconnor> is there a MultiSet (Bag) data type, or do I just use IntMap?
11:53:51 <desp> monochrom: I probably should be using a State monad here
11:54:00 <desp> monochrom: but I'm not really comfortable with that yet
11:54:05 <desp> mixing two monads?
11:54:09 <EvilTerran> what about [Nothing,Nothing,Just undefined,Just 1], say? or [[1,2,3],[4..],[]]?
11:54:10 <roconnor> er
11:54:11 <roconnor> Map Int
11:54:30 <hpaste>  monochrom annotated "why doesn't this type?" with "bridging runPut and foo" at http://hpaste.org/1794#a4
11:54:40 <aeyakovenko> EvilTerran, i wont have anything in there thats undefined
11:54:45 <EvilTerran> why do you need to force all the values, anyway, aeyakovenko? it's not really in the spirit of haskell...
11:55:09 <aeyakovenko> EvilTerran, because haskell is leeking thunks somewhere, so my program grows in memory over time
11:55:52 <monochrom> That is preserving old code and still try to runPut it.
11:56:02 <desp> monochrom: that doesn't return the [Int] returned by foo, though
11:56:17 <monochrom> Because runPut doesn't want it.
11:56:38 <EvilTerran> i suspect it might be better to try to track down the specific leaking thunks, rather than forcing *everything*. you might be able to do something with a profiler or debugger, say.
11:56:41 <monochrom> Also, inside foo, you have already called "put" many times. That is the only thing runPut cares.
11:58:05 <aeyakovenko> i am not really forcing everything, just fully evaluating what needs to be evaluated anyways
11:59:02 <dolio> > (return $| rnf $ [1..]) >>= take 10
11:59:13 <lambdabot> Terminated
11:59:41 <sfultong> @type rnf
11:59:43 <lambdabot> forall a. (NFData a) => a -> Done
12:00:53 <hpaste>  desp annotated "why doesn't this type?" with "figured it out" at http://hpaste.org/1794#a5
12:00:58 <desp> monochrom: ^
12:01:00 <desp> monochrom++
12:02:38 <liyang>  /top
12:04:39 <EvilTerran> aeyakovenko, well, see http://hackage.haskell.org/trac/haskell-prime/wiki/deep_seq . the short answer seems to be no, tho.
12:04:42 <lambdabot> Title: deep_seq - Haskell Prime - Trac
12:06:24 <desp> does ByteString.Lazy.Length cache the length, or is it always O(n/c)?
12:06:32 <EvilTerran> if you know all types that'll be involved in the structure, you could construct a class that'd allow deep forcing, and instantiate it to each type
12:09:03 <monochrom> deep forcing is deep magic
12:09:12 <oerjan> ByteString.Lazy.Length? that sounds like an oxymoron.
12:09:28 <desp> well, .length
12:09:31 <desp> not Length
12:09:32 <desp> ;)
12:09:40 <oerjan> still an oxymoron
12:10:06 <desp> why? I would imagine it walks the spine
12:10:25 <desp> but doesn't strictize the whole thing
12:10:40 <desp> but if it walks the spine every time, then it sucks
12:10:47 <desp> and I'll need to cache the length myself
12:11:10 <dolio> How else would it do it? Unless it returns a new ByteString for you to use subsequently.
12:11:30 <desp> it could be dirty inside
12:11:36 <oerjan> but if the ByteString is from a pipe, it cannot possibly avoid reading the whole thing...
12:11:37 <lightstep__> dolio, it can be in a lazy reference in the value
12:11:47 <kaol> would the semantics allow it to return _|_?
12:12:02 <dolio> I suppose, but it's evil enough already, I think. :)
12:12:13 <monochrom> LazyByteString does not cache length.
12:12:21 <shazam>     let a2s y x = try (a2 x y >>= a2s y) <|> return x <-- what does this line mean?
12:12:25 <shazam> the <|> return x bothers me
12:14:27 <oerjan> it means, try parsing a2 x y >>= a2s y
12:14:37 <oerjan> and if that fails, just return x instead
12:14:42 <shazam> gotcha
12:15:00 <shazam> if parsec says: expecting " you silly man", "tom" or "you are "
12:15:11 <shazam> then I'm missing a try somewhere, right?
12:16:01 <oerjan> possibly, unless it really isn't suppose to parse.
12:16:03 <oerjan> *d
12:16:39 <EvilTerran> ...i am immediately intrigued by whatever you're trying to parse.
12:16:53 <shazam> <:O)
12:17:25 <lightstep__> there is probably a bug if only one of them starts with a space
12:17:27 <oerjan> that space in front of you silly man seems suspicious.
12:19:04 <shazam> oh, you silly man shouldn't be applicable
12:19:11 <shazam> I'm looking for "the courageous"
12:19:50 <shazam> the matter of my productions seem to matter
12:19:54 <shazam> yet I'm put tries everywhere!!!
12:21:39 <oerjan> if you solve your problems by sprinkling things you don't understand in arbitrary places, you are probably in trouble.
12:22:17 <hpaste>  shazam pasted "shouldn't <|> be commutative with try?" at http://hpaste.org/1795
12:23:23 <oerjan> well if the first one parses, the second one is never tried, for one thing
12:24:01 <oerjan> so if the failure happens _after_ allNonFree has returned, it will be different.
12:24:16 <shazam> allNonFree is the toplevel production
12:24:32 <shazam> well, allNonFree >> eof is
12:25:02 <shazam> so if _any_ failure happens, it'll happen in allNonFree
12:25:05 <oerjan> also, if the first one never _terminates_, you may have a problem
12:25:24 <shazam> but it does terminate
12:25:29 <shazam> with this:
12:26:06 <hpaste>  (anonymous) annotated "shouldn't <|> be commutative with try?" with "(no title)" at http://hpaste.org/1795#a1
12:28:24 <shazam> so, like, is this possible?
12:29:47 <oerjan> btw by "the first one", i don't mean your first example, but the first half of each example
12:30:18 <shazam> yeah
12:30:58 <oerjan> and i would _expect_ nonleftrecsFree allNonFree not to terminate if it starts by calling allNonFree, and allNonFree starts by calling it
12:31:24 <shazam> but it terminates!
12:31:42 <shazam> with an error
12:31:46 <shazam> termination isn't an issue
12:31:50 <oerjan> well, no way to understand without the whole parser then.
12:32:34 <shazam> but if one passes, the other should pass too
12:32:35 <shazam> no?
12:32:51 <shazam> because of the try
12:33:32 <oerjan> on the face of it, that seems reasonable.
12:33:52 <shazam> yet this is not the case
12:33:58 <shazam> which leaves me scratching my head
12:34:28 <oerjan> possibly your grammar is ambiguous?
12:34:56 <shazam> but that shouldn't matter!
12:35:01 <oerjan> in that case, _both_ branches could parse, but differently
12:35:24 <oerjan> and that means that what happens _after_ a recursive call to one of them will be different
12:35:51 <shazam> BUT, if it fails anywhere, it will be caught by the toplevel try
12:35:52 <oerjan> because the rest of the parse starts at a different point
12:35:53 <sjanssen> desp: you rang?
12:35:54 <shazam> will it not?
12:36:43 <desp> sjanssen: I had a problem with PutM, but I fixed it with monochrome
12:36:52 <desp> http://hpaste.org/1794#a5
12:36:53 <oerjan> it's not the toplevel try that is the problem, but a lower-level one, which succeeds and then can no longer be undone
12:37:33 <shazam>  try (a >>=b) <|> c
12:37:46 <shazam> if a suceeds but b fails
12:37:50 <shazam> is c tried?
12:37:57 <oerjan> yes.
12:38:20 <oerjan> however, in try (try (a <|> b) >>= c) <|> d
12:38:47 <oerjan> if a succeeds but c fails, then b c will never be tried
12:39:30 <shazam> what about
12:39:43 <shazam> try (try (try a <|> try b) >>\= try c) <|> try d
12:39:48 <shazam> err
12:39:50 <shazam> try (try (try a <|> try b) >>= try c) <|> try d
12:40:18 <oerjan> still b c will not be tried if a succeeds
12:40:26 <shazam> oh my
12:40:28 <shazam> oh my my my
12:40:41 <desp> sjanssen: actually, one more problem
12:40:53 <desp> I'm getting linker errors about undefined symbols from Data.Binary
12:41:13 <desp> ah, --make
12:41:35 <shazam> oerjan, so ho could you remove that problem?
12:41:37 <desp> :)
12:41:47 <monochrom> or -package binary
12:42:01 <monochrom> I do swear by --make, however
12:42:14 <shazam> parsec has some really strange semantics:O!
12:42:23 <dolio> Probably: "try (a >>= c) <|> b >>= c"
12:42:29 <oerjan> you might try a parser combinator with fuller backtracking, they are more expensive however
12:42:49 <xerox> buckminster fuller backgrack
12:42:53 <shazam> BUT, can you give me an example where try a <|> b passes but try b <|> a fails?
12:42:54 <oerjan> i think the original parser monads were that way
12:42:59 <xerox> man I'mtired.
12:43:30 <oerjan> i don't think so
12:44:01 <monochrom> String -> [(a,String)] ?
12:44:04 <oerjan> however, they can succeed differently, and so cause failure when inside a larger parser
12:44:36 <shazam> I mean a = try (b a) <|> c a versus a = try (c a) <|> b a
12:44:38 <oerjan> monochrom: yeah
12:45:46 <oerjan> in that case if b and c cannot be confused then there is no ambiguity
12:45:51 <pierre1> ?unpl ((++) . f)
12:45:51 <lambdabot> (\ c -> (++) (f c))
12:46:40 <shazam> oh yes, I see why it doesn't work
12:46:47 <oerjan> but if b = string "x" and c = string "xy", then there may be a problem
12:46:49 <shazam> I removed left recursion like you said
12:47:08 <shazam> wait ,still don't see it
12:47:14 <shazam> oerjan, b and c are functions
12:47:22 <oerjan> i am afraid my method may not be terribly robust in every case :/
12:48:02 <shazam> functions Parser Term -> Parser Term
12:48:27 <shazam> here's a question for #haskell!
12:48:42 <oerjan> well then, b a = string "xy" >> a, c a = string "xyz" >> a
12:49:01 <shazam> and what's the string?
12:49:04 <slowriot> how do you write a pattern match so that matching either of two patterns returns the same result?
12:49:26 <oerjan> xyzx...
12:49:50 <shazam> slowriot, let res x y z = ... in case x of P1 x y z -> res x y z | P2 x y z -> res x y z
12:50:11 <slowriot> shazam: can you do that without writing res xyz twice?
12:50:43 <shazam> slowriot, probably not, not like C++ anyways
12:50:51 <roconnor> @type runSt
12:50:53 <roconnor> @type runST
12:50:53 <xerox> ?source Control.Monad.State
12:50:57 <lambdabot> Not in scope: `runSt'
12:50:58 <lambdabot> Not in scope: `runST'
12:50:58 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/State.hs
12:51:05 <shazam> oerjan, so which fails and which passes?
12:51:16 * oerjan is not sure about this, his brain is not working today
12:52:11 <shazam> for the string "xyzx" ,both seems to fail
12:52:28 <xerox> ?index gets
12:52:29 <lambdabot> Control.Monad.State, Control.Monad.RWS
12:52:42 <Botje> slowriot: you could always (||) the two cases together?
12:53:08 <oerjan> i didn't put in a base case.
12:54:03 <oerjan> sorry, my brain is mush
12:54:13 <shazam> we're so close!
12:55:17 <oerjan> maybe with b a = try (string "xy" >> a) <|> string "z"
12:55:44 <oerjan> then i think "xyz" behaves differently
12:57:00 <oerjan> er...
12:57:05 <slowriot> Botje: bur isn't (||) for booleans?
12:57:09 <shazam> both pass!
12:57:45 <slowriot> Botje: eh... I'll just do it shazam's way
12:58:46 <oerjan> b a = try (string "x") <|> (string "xy" >> a), then
12:59:48 <oerjan> argh!
13:01:17 <shazam> both succeed
13:04:13 <shazam> my argument still holds
13:04:41 <oerjan> oh wait
13:06:31 <oerjan> but, you already must _have_ an example somewhere, that's how this conversation started!
13:07:10 <shazam> heh
13:07:38 <shazam> well, I'm encoding my grammar in data ParseElement = Top | Literal String
13:07:43 <shazam> then I remove left recursion
13:07:52 <shazam> then I combine all the alternatives
13:08:09 <shazam> if parsec kept track of the grammar
13:08:15 <oerjan> can't you print out the transformed grammar?
13:08:30 <shazam> the transformed grammar is of type Parser Term
13:09:09 <shazam> and since parsec _can't_ keep track of fixed points
13:09:10 <araujo> hello!
13:09:31 <shazam> (and I have fixed points everywhere)
13:09:53 <shazam> well, it's [ParseElement] -> (Parser Term -> Parser Term) -> Parser Term
13:09:58 <shazam> so there's two sets of transformations
13:10:19 <oerjan> my brain is _far_ too mushy to work with that.
13:10:56 <desp> hrm
13:11:06 <desp> how to write a function guard that checks if n is even?
13:11:10 <desp> pattern guard*
13:11:18 * oerjan realizes that word may not mean what he thought it does
13:11:26 <shazam> wait, I almost have it
13:11:28 <desp> can I use mod in a guard?
13:11:37 <oerjan> desp: sure
13:11:43 <shazam> desp, you can use anything!
13:11:49 <Saizan> foo n | even n = ,..
13:11:53 <oerjan> desp: also, you can use the even function ;)
13:11:56 <desp> you can use anything on zombo.com!
13:12:01 <Saizan> foo n | mod n 2 == 0 =
13:12:01 <desp> that's good too
13:12:13 <desp> thank you
13:12:46 <shazam> b a = string "xy"  c a = a >> string "yz"
13:13:08 <shazam> now to add a base case
13:13:20 <shazam> b a = string "xy" <|> string "z"
13:13:38 <shazam> b a = string "xy" <|> string "x"
13:14:41 <shazam> oh ,but that's left recursive
13:15:07 <shazam> hmm
13:15:27 <shazam> I'll think about it
13:15:40 <shazam> bbl
13:21:29 <desp> how can I throw an exception with my own string from functional code?
13:21:47 <oerjan> :t throwError
13:21:49 <lambdabot> forall e (m :: * -> *) a. (MonadError e m) => e -> m a
13:22:02 <oerjan> not that way
13:22:12 <dylan> @hoogle error
13:22:13 <lambdabot> Prelude.error :: String -> a
13:22:13 <lambdabot> Control.Monad.Error :: module
13:22:13 <lambdabot> Foreign.C.Error :: module
13:22:22 <dylan> > error "bunnies"
13:22:23 <lambdabot>  Exception: bunnies
13:22:29 <desp> aha
13:22:30 <desp> dylan++
13:23:56 <oerjan> bah, too easy :D
13:28:35 <Figs> hey
13:28:42 <monochrom> There is no bunny. There is no exception. They are all continuations. I'm insane.
13:29:04 <Figs> could someone explain the difference between type constructors and data constructors? It should probably be obvious, but I'm not really getting it.
13:29:13 <shazam> ok, think I got it
13:29:15 <desp> uh
13:29:15 <shazam> ill paste it soon
13:29:22 <slowriot> Figs: Do you know C++?
13:29:25 <Figs> yes
13:29:26 <desp> any ideas why there are \NULs in my ByteString?
13:29:48 <monochrom> data MyType a = CaseA a | CaseB a.  MyType is a type constructor.  CaseA and CaseB are data constructors.
13:30:12 <Figs> ok
13:30:25 <slowriot> Figs: Actually, I may not be able to answer your question as well as others here. Are you asking about the difference between "type Foo = " and "data Foo = " ?
13:30:50 <Figs> well, there's that, but mostly what the terms mean
13:30:53 <slowriot> slowriot: oh... I just read monochrom's statement... I see.
13:31:13 <monochrom> The "type" keyword is not a type constructor.
13:31:14 <slowriot> Figs: type Foo = is kind of like typedef
13:31:26 <slowriot> Figs: Also, what monochrom said.
13:31:50 <slowriot> Figs: "type Foo = ..." is not a type constructor.
13:32:14 <sfultong> > return 5
13:32:18 <lambdabot>   add an instance declaration for (Show (m t))
13:32:21 <oerjan> it's a type synonym
13:32:45 <oerjan> rather confusing to beginners, i guess
13:33:36 <sfultong> type synonyms seem like just so much syntactic sugar
13:33:36 <monochrom> "data", "type", and "newtype" are very close names if you just treat them as English.
13:34:02 <oerjan> type is nearly like a type-level macro definition.  it must be fully applied in every use.
13:34:33 <oerjan> and is expanded before anything else is done with the result (in theory)
13:34:39 <oerjan> so it cannot be recursive.
13:34:44 <sfultong> monochrom: the moral of that is: never treat programming as English
13:34:47 <monochrom> But very long ago I already learned that English words in programming languages have no meaning.
13:35:18 <monochrom> Yes. I had ease programming myself to do that.
13:35:32 <monochrom> I think many people have trouble, however.
13:35:48 <sfultong> especially if they start out in basic...
13:36:12 <SamB> I bet german people have less trouble
13:36:25 <sfultong> why do people think that beginning programmers should be taught languages like basic?  I'd love to teach someone haskell as their first language
13:36:29 <slowriot> the icfp problem looks really interesting, but I don't think I am smart enough to solve it.
13:36:44 <SamB> I haven't gotten to the problem part yet
13:36:49 <slowriot> You have to *read code*...... and figure out what it *does*
13:37:09 <sfultong> reading other people's code? eww....
13:37:14 <slowriot> I know
13:37:16 <SamB> you don't have to read it that much
13:37:34 <SamB> it's like a cross between C and Haskell with views
13:37:35 <dylan> just read the type signatures. :)
13:37:50 <dylan> oh, missed the context.
13:38:07 <shazam> unexpected "y"
13:38:08 <shazam> expecting "yxyz" or "y"
13:38:14 <shazam> I think parsec is on drugs
13:38:20 <slowriot> its not the syntax that's confusing... it's the programs themselves
13:38:26 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/1796
13:38:46 <monochrom> who is anonymous? put up your hand.
13:38:53 <hpaste>  (anonymous) pasted "parsec is borked" at http://hpaste.org/1797
13:39:01 <monochrom> Oh, now it's clear :)
13:39:05 <shazam> it's me!
13:39:53 <SamB> slowriot: at what point do the programs become confusing?
13:41:05 <sfultong> hmm... when they're not written by you?
13:41:14 <kalmar> ?instances Data.Monoid
13:41:16 <lambdabot> Couldn't find class `Data.Monoid'. Try @instances-importing
13:41:23 <kalmar> ?instances Monoid
13:41:24 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, Ordering, Product a, Sum a, [a]
13:41:32 <sfultong> ?instances Data.Mongoloid
13:41:33 <lambdabot> Couldn't find class `Data.Mongoloid'. Try @instances-importing
13:41:35 <kalmar> ?instances-importing Data.Sequence Monoid
13:41:36 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, Ordering, Product a, Seq a, Sum a, [a]
13:41:50 <SamB> kalmar: what are you looking for?
13:42:08 <shazam> yes!!!
13:42:09 <shazam> got it!
13:42:31 <kalmar> SamB: for some reason I missed the listing in docs of instance Monoid (Seq a)
13:42:33 <slowriot> SamB: Well... it's a deterministic program. If someone understands it well enough, they should be able to find an optimal prefix and win the contest.
13:42:52 <SamB> slowriot: ah.
13:42:55 <kalmar> I'm starting icfp late
13:43:01 <kalmar> :/
13:43:03 <SamB> isn't everyone?
13:43:16 <SamB> kalmar: what are you planning to put in your seq?
13:43:23 <SamB> er. Seq?
13:43:27 <hpaste>  shazam pasted "<|> is _not_ commutative" at http://hpaste.org/1798
13:43:31 <kalmar> Is Cs Fs and Ps
13:43:33 <shazam> oerjan, check it out
13:43:44 <kalmar> I think it'll explode
13:43:48 <SamB> kalmar: I already tried that
13:43:51 <kalmar> exploded?
13:44:06 <SamB> I got tired of waiting for Seq.length to finish
13:44:11 <shazam> oerjan, so http://www.cs.york.ac.uk/fp/polyparse/ <--has more backtracking?
13:44:14 <lambdabot> Title: polyparse: alternative parser combinator libraries
13:44:29 <kalmar> (btw kalmar = hyrax42 who used to idle here all the time till he got pissed of with state of IRC clients on OS X)
13:44:31 <SamB> use Data.ByteString.Lazy.Char8
13:44:42 <kalmar> hm that was my second choice
13:44:43 --- mode: ChanServ set +o glguy
13:45:02 <kalmar> was going for monoid ot make it easy to switch types later
13:45:02 <slowriot> SamB: Another option would be to implement it efficiently and then try a bunch of prefixes.
13:45:16 --- kick: shazam was kicked by glguy (Chanserv shows n=palomer as being banned... changing your nick isn't the same as not being banned)
13:45:24 --- mode: glguy set -o glguy
13:45:28 <kalmar> well monoid/foldable combo
13:45:44 <kalmar> and got conufsed by lack of monoid instance for seq
13:45:47 <kalmar> and got here
13:45:55 <SamB> is palomer allowed in other ICFP contest related channels?
13:45:55 <kalmar> (non-lack as it turned out)
13:46:03 <SamB> like #haskell-icfp07?
13:46:06 * glguy has no idea
13:46:19 <sjanssen> glguy: shazam was palomer?
13:46:23 <dylan> who is palomer?
13:46:29 <glguy> a 4 year old troll
13:46:40 <SamB> what breed of troll?
13:46:49 <SamB> newbie eater?
13:46:52 <sjanssen> the whining, refuses to RTFM troll
13:46:58 --- mode: ChanServ set +b *!n=palomer@*
13:46:59 <glguy> the vampiric newbie pestering kind
13:48:46 <kalmar> so sam RNA = [ByteString] is good enough?
13:48:50 <SamB> hmm, does the generalized string syntax allow string literal patterns to be used for other types?
13:48:55 * kalmar piggy backs :o
13:49:08 <kalmar> class IsString?
13:49:28 <SamB> I'm using DList for my RNA
13:49:32 <kalmar> oh hm
13:49:44 <kalmar> I sort of doubt it allows that
13:50:32 <dolio> Anyone writing a Minim interpreter? :)
13:52:18 <SamB> kalmar: doubt what allows what?
13:52:27 <SamB> you can use whatever you want
13:52:32 <SamB> you can use a time machine if you have one
13:52:40 <kalmar> generalised string syntax allows pattern matching on literals
13:52:58 <kalmar> *doubt that ~
13:53:04 <SamB> (if anyone uses one to win an icfp contest, they'll probably disallow it for the next year's if they find out)
13:53:17 <desp> okay
13:53:28 <desp> so it looks like it's unsafe to do  put (foo :: ByteString)
13:53:40 <desp> you have to do putByteString (foo :: ByteString)
13:53:49 <desp> or Shit Will Happen
13:54:10 <desp> i.e. you will get "PI\NUL\NUL\NUL\NUL\NUL\NUL\NUL\STXCF" instead of "PICF"
13:54:37 <desp> and then you will be dumbfounded how in the seven hells did a \NUL get there
13:55:06 <desp> let alone 7 of them
13:55:08 <dolio> Is foo a lazy ByteString?
13:55:11 <desp> hmm, coincidence? I think not
13:55:12 <kalmar> hm
13:55:16 <desp> a strict one
13:55:26 <SamB> that's an int
13:55:31 <SamB> > ord '\ST'
13:55:31 <lambdabot>  Illegal escape sequence
13:55:37 <SamB> > ord '\STX'
13:55:38 <lambdabot>  2
13:55:42 <SamB> it's "2"
13:55:48 <kalmar> for length of the thingy?
13:55:56 <desp> it appears to be, yes
13:56:04 <SamB> length of the second ByteString
13:56:20 <kalmar> inneresting
13:57:44 <sjanssen> desp: it's perfectly safe
13:57:55 <desp> er?
13:58:13 <desp> well, I guess it is safe
13:58:14 <sjanssen> desp: 'put' is for serialization stuff -- so it prints the length so as to allow deserialization
13:58:37 <desp> hmm
13:58:49 <desp> okay
13:59:09 <desp> would be fine to have that in the docs :)
14:00:06 <sjanssen> shame on you for assuming things for undocumented formats :)
14:00:14 <dolio> Isn't put from Data.Binary?
14:00:18 <sjanssen> yes
14:00:27 * desp whips self
14:00:40 <dolio> I.E. "Efficient, pure binary serialisation for lazy ByteStrings"? :)
14:00:55 <SamB> dolio: yes
14:02:15 <desp> that means you serialize *into* a lazy BS
14:02:25 <desp> which I promptly convert to a strict one, for the time being
14:03:43 <roconnor> @type put
14:03:50 <roconnor> @hoogle put
14:03:52 <lambdabot> forall s (m :: * -> *). (MonadState s m) => s -> m ()
14:03:52 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
14:03:53 <lambdabot> Prelude.putChar :: Char -> IO ()
14:03:53 <lambdabot> Prelude.putStr :: String -> IO ()
14:07:58 <kaol> why am I getting errors like "Could not find module `Text.XML.HaXml': it is a member of package HaXml-1.13.2, which is hidden" with ghc? (I have import Text.XML.HaXml in my main module and have import HAppS too)
14:08:16 <sjanssen> kaol: you're using Cabal to build your own project?
14:08:36 <kaol> yes
14:08:49 <sjanssen> you need to put HaXml in the build-depends
14:09:39 <kaol> that did it. thanks.
14:12:22 * kaol is failing with using types
14:14:16 * monochrom loves types
14:14:42 * sjanssen prefers kinds
14:15:36 <dolio> Sort-level programming is the future.
14:17:15 <wli> dolio: Specifying algebras directly in terms of generators and relations?
14:17:55 <jfredett> i like pie. if that counts
14:18:04 <sjanssen> no, it doesn't
14:18:07 <jfredett> :(
14:18:14 * jfredett frowns
14:18:20 <dolio> wli: sort : kind :: kind : type (I think my terminology is correct)
14:18:29 <jfredett> what about pi, i like that to
14:18:41 <sjanssen> ?? : sort
14:18:41 <dolio> wli: So, sort-level programming is what Oleg will be doing when everyone else is doing kind programming.
14:19:02 <jfredett> @quote OlegFacts
14:19:02 <lambdabot> OlegFacts says: Oleg can express any computable function using only the K combinator
14:19:21 <wli> Um, that doesn't mesh with my understanding of sorts.
14:19:53 <sjanssen> wli: it's just another definition of the term
14:19:54 * monochrom loves types, kinds, and all levels up
14:20:23 <wli> Higher-order analogues of typeclasses?
14:20:26 <sjanssen> not "sort these things in order", it's "what sort of thing is this?" (similar to "what type of thing is this?")
14:20:49 <sjanssen> wli: types are classes of values
14:20:53 <sjanssen> kinds are classes of types
14:20:58 <sjanssen> sorts are classes of kinds
14:21:25 <dolio> Yeah, I don't know what goes above sorts.
14:21:29 <jfredett> i thought typeclasses were classes of types
14:21:35 <jfredett> Oleg goes above sorts
14:21:56 <sjanssen> sort : kind :: Oleg : sort
14:22:03 <wli> In universal algebra, sorts correspond relatively closely to types AIUI.
14:22:13 <dolio> I don't know if any languages have more than one sort anyway, so maybe no one's bothered naming above that yet.
14:23:00 <oerjan> are Prop and Type in Coq sorts?
14:23:21 <oerjan> in which case at least one language does.
14:23:32 <wli> My understanding of sorts must be incorrect.
14:23:47 <wli> I have relatively good ideas of what kinds are.
14:23:51 <ihope> Value, type, kind, sort, Oleg?
14:24:35 <wli> So if a sort is a class of kinds, hten what?
14:24:40 <oerjan> http://en.wikipedia.org/wiki/Many-sorted_logic
14:24:42 <lambdabot> Title: Many-sorted logic - Wikipedia, the free encyclopedia
14:24:51 <sjanssen> > "value, type, kind, sort, " ++ fix ("Oleg, "++)
14:24:52 <lambdabot>  "value, type, kind, sort, Oleg, Oleg, Oleg, Oleg, Oleg, Oleg, Oleg, Oleg, Ol...
14:25:16 <monochrom> Just call the whole sequence Oleg0, Oleg1, Oleg2, ...
14:25:16 <ihope> > cycle "Oleg, "
14:25:18 <lambdabot>  "Oleg, Oleg, Oleg, Oleg, Oleg, Oleg, Oleg, Oleg, Oleg, Oleg, Oleg, Oleg, Ole...
14:25:31 <sjanssen> ihope: the fix point is cooler :)
14:25:38 <sjanssen> > fix error
14:25:39 <lambdabot>  Exception: <<loop>>
14:25:43 <sjanssen> aww
14:25:45 <wli> The many-sorted affair usually just refers to having multiple ground types, like Integer, Bool, Double, Char, etc.
14:25:47 <ihope> > map (\x -> "Oleg" ++ show x ++ ", ") [0..]
14:25:48 <lambdabot>  ["Oleg0, ","Oleg1, ","Oleg2, ","Oleg3, ","Oleg4, ","Oleg5, ","Oleg6, ","Oleg...
14:25:58 <monochrom> concatMap
14:25:59 <ihope> > join (map (\x -> "Oleg" ++ show x ++ ", ") [0..])
14:26:00 <lambdabot>  "Oleg0, Oleg1, Oleg2, Oleg3, Oleg4, Oleg5, Oleg6, Oleg7, Oleg8, Oleg9, Oleg1...
14:26:09 <ihope> > concatMap (\x -> "Oleg" ++ show x ++ ", ") [0..]
14:26:10 <lambdabot>  "Oleg0, Oleg1, Oleg2, Oleg3, Oleg4, Oleg5, Oleg6, Oleg7, Oleg8, Oleg9, Oleg1...
14:26:11 <oerjan> obviously we need Oleg_omega etc.
14:26:28 <jfredett> Aleph_oleg?
14:26:44 <ihope> No, Oleg_aleph.
14:26:46 <ihope> :-)
14:26:52 <jfredett> ahh.
14:26:54 * monochrom cringes
14:27:05 <sjanssen> > concat . intersperse ", " . map (("Oleg"++) . show) $ [0..]
14:27:06 <lambdabot>  "Oleg0, Oleg1, Oleg2, Oleg3, Oleg4, Oleg5, Oleg6, Oleg7, Oleg8, Oleg9, Oleg1...
14:27:16 <ihope> Or Oleg_aleph_0, if you don't like calling it aleph.
14:27:27 <wli> I'm relatively sure the many-sorted affair usually just refers to having multiple ground types, like Integer, Bool, Double, Char, etc. This thing about sorts being above kinds sounds wrong.
14:28:18 <oerjan> perhaps it is about multiple ground kinds?
14:28:39 <wli> oerjan: That could make sense.
14:28:43 <oerjan> like ghc's unboxed kinds
14:28:46 <ihope> Multiple ground Olegs.
14:28:58 <wli> oerjan: Unboxed kinds? wtf?
14:29:14 <oerjan> ghc has a special kind for the type of unboxed values
14:29:19 <sjanssen> @kind Int#
14:29:21 <lambdabot> Not in scope: type constructor or class `Int#'
14:29:28 <ihope> @kind GHC.Prim.Int#
14:29:29 <sjanssen> @kind Char
14:29:30 <lambdabot> #
14:29:31 <lambdabot> *
14:29:47 <ihope> You know, if you allow types to be used as values, everybody can have an Oleg easily.
14:29:55 <wli> *Bernoulli> :kind GHC.Prim.Int#
14:29:55 <wli> GHC.Prim.Int# :: #
14:30:05 <dolio> Perhaps the 'sorts are the kinds of kinds' definition comes from a different source than what you're familiar with.
14:30:22 <dolio> Like how there are several different, unrelated definitions of 'functor' out there.
14:30:36 <dolio> Or 'monad'.
14:30:43 <ihope> If an Oleg is a sort of sorts, a sort is a kind of kinds, and a kind is a type of types, does that mean a type is a value of values?
14:31:01 <ihope> Do all type constructor classes' names also have other meanings?
14:31:04 <monochrom> Yes!
14:31:20 <wli> dolio: I must be unfamiliar with this.
14:31:20 <ihope> (And an Ozymandias is a king of kings...)
14:31:37 <wli> ihope: "Look upon my works, ye mighty, and despair."
14:31:40 <ihope> wli: "functor" can mean "function object", "monad" can mean just about anything.
14:31:42 * ihope nods
14:32:11 <ihope> Works? What works? It's a stone in the middle of a desert, isn't it?
14:32:12 <dolio> Yeah, if you ask a Java programmer what a functor is, he's likely to tell you it's an object you use because they don't have higher order functions.
14:32:40 <ihope> (And I've only heard of it from Ozy and Millie.)
14:32:46 <monochrom> ctor, dtor, ftor. any etor?
14:33:18 <oerjan> monochrom: huh?
14:33:37 <monochrom> ctor = constructor, dtor = destructor, ftor = functor.
14:34:03 <ihope> Dr. Ector.
14:34:23 <ihope> (It's really "director". He just read it wrong.)
14:35:05 <monochrom> haha
14:35:18 <ihope> And of course, we have actors, creating a new hole.
14:35:28 <ihope> What's a word beginning in "b" and ending in "ctor"?
14:35:42 <kalmar> benefactor
14:36:27 <ihope> And since "Ector" isn't a real word, we'll have to find a new one.
14:36:37 <Heffalump> bisector
14:36:38 <slowriot> erector... like the toys
14:36:51 <hpaste>  sachu pasted "doubt about monads and I/O" at http://hpaste.org/1800
14:36:51 <dolio> elector
14:36:55 <wli> This is a grep on /usr/dict/words, folks.
14:37:07 <kalmar> wli: takes all the fun out
14:37:48 <jfredett> extractor
14:37:50 <hpaste>  (anonymous) annotated "doubt about monads and I/O" with "(no title)" at http://hpaste.org/1800#a1
14:37:52 <jfredett> and elector
14:37:58 <ihope> Gyractor!
14:37:59 <jfredett> thats all my dictionary has
14:38:27 <ihope> Milky Way Galactor.
14:39:05 <hpaste>  jfredett pasted "Words ending in ctor" at http://hpaste.org/1801
14:39:08 <ihope> i r teh hactor...
14:39:21 <dynamix> what are the pros and cons of using the combinator form instead of a lambda function ?
14:39:25 <wli> $ grep 'ctor$' /usr/share/dict/web2|grep '^b'|xargs echo
14:39:25 <wli> bedoctor benefactor bisector bivector bronchoconstrictor
14:39:28 <sachu> hi. I am having trouble trying to read some data into a mutable field. I have posted my (small) program and the compiler's error message on hpaste : 1800. I am quite new to monads. Could you help me out with this error?
14:39:45 <dynamix> ?pl \a b -> [a,b]
14:39:45 <lambdabot> (. return) . (:)
14:39:48 <dynamix> for example
14:39:59 <ihope> dynamix: the combinator form might be shorter?
14:40:08 <ihope> It is sort of much less clear, though.
14:40:24 <jfredett> sachu: I'm not particularly familiar with mutable stuff, but I'll do what I can
14:40:26 <ihope> sachu: well, isn't main supposed to be of an IO type?
14:40:52 <sachu> i guess it is :-( . let me try changing that
14:41:08 <dynamix> yeah i spent about 15 minutes trying to figure that out, and had to ask for help to get myself around the combinator equivalent.  im glad it all makes sense now.. but why would one want to put future maintaimers of code thru that?
14:41:54 <ihope> Darn. No g*ctor, j*ctor, k*ctor, l*ctor, q*ctor, u*ctor, w*ctor, x*ctor, y*ctor, or z*ctor...
14:41:54 <sachu> ihope: I tried commenting out the line "main = readInput" , but the error persists
14:42:03 <ihope> sachu: what is the error?
14:42:16 <sachu> ihope: I have pasted it along the code, in an annotation
14:42:20 <jfredett> its in the addendum to the code
14:42:23 <ihope> Is it because readFile returns an IO type while newAddress and setStreet don't?
14:43:16 <sachu> ihope: is it the case that every expression (line?) in a "do" must have the same type?
14:43:48 <ihope> sachu: well, they must all belong to the same monad.
14:43:54 <kalmar> SamB: are you finding a purely functional approach to work decently well? or are you using ST/IO?
14:44:47 <ihope> There might be some sort of IOT or STT out there.
14:45:36 <sachu> the report (http://haskell.org/onlinereport/exps.html) doesn't seem to say anything about this. guess this is specified elsewhere. What could I do to make them all belong to the same monad, if I want to read some data from a file into an ST value?
14:45:37 <lambdabot> Title: The Haskell 98 Report: Expressions
14:45:39 <monochrom> bifunctor
14:45:45 <hpaste>  kaol pasted "overeager type inference?" at http://hpaste.org/1802
14:46:06 <oerjan> sachu: it is implicit because otherwise >>= cannot typecheck
14:46:10 <oerjan> :t >>=
14:46:15 <kaol> why does ghc complain if I replace the commented parts into my example?
14:46:15 <lambdabot> parse error on input `>>='
14:46:20 <kalmar> :t (>>=)
14:46:21 <oerjan> :t (>>=)
14:46:22 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
14:46:24 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
14:47:30 <ihope> sachu: use IORefs instead of STRefs?
14:48:43 <oerjan> kaol: replace how?
14:48:45 <monochrom> kaol: you need 2nd-rank polymorphism. I don't recommend worrying about it. It is advanced. OK, maybe not. I'll paste a solution. You can decide whether you want to investigate or forget it.
14:49:40 <kaol> oerjan: s/id/toA/, s/toA B/f B/ and s/toA C/f C/
14:50:07 <mathewm> Anyone have general pointers of Haskell/GHC performance?
14:50:22 <sachu> ihope: let me try that. I am pretty new to monads, and haven't been able to get a good grasp on them yet. Could you tell me what "ST s ()" means in the type declaration for setStreet ? (I adapted the declaration from an example I found online) : setStreet :: Address s -> String -> ST s ()
14:50:25 <Heffalump> faster than a speeding bullet
14:50:38 <oerjan> right, rank 2 then
14:50:49 <sjanssen> mathewm: that is a very broad question :)
14:50:49 <mathewm> after two years of part-time haskell-ing, my programs still tend to crawl and swap and profile as one big CAF
14:51:08 <Heffalump> sachu: ST identifies the monad. () identifies the type of the value produced. Ignore the 's' for now.
14:51:17 <sjanssen> mathewm: http://www.haskell.org/haskellwiki/Performance
14:51:18 <hpaste>  monochrom annotated "overeager type inference?" with "try this" at http://hpaste.org/1802#a1
14:51:18 <lambdabot> Title: Performance - HaskellWiki
14:51:24 <ihope> I have little idea what ST is.
14:51:49 <monochrom> kaol: try that. oops, there are some replacements I haven't done.
14:52:04 <hpaste>  monochrom annotated "overeager type inference?" with "(no title)" at http://hpaste.org/1802#a2
14:52:12 <monochrom> That one is better.
14:53:58 <oerjan> ST is a monad that allows you to use mutable variables internally, but still return a pure result
14:56:38 <|Jedai|> @src readIO
14:56:38 <lambdabot> Source not found. Maybe if you used more than just two fingers...
14:57:28 <oerjan> @where Prelude
14:57:28 <lambdabot> I know nothing about prelude.
14:57:35 <oerjan> @source Prelude
14:57:36 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
14:57:57 <oerjan> |Jedai|: it's there, it's too long for lambdabot to paste
14:58:46 <oerjan> @where prelude
14:58:46 <lambdabot> I know nothing about prelude.
15:00:53 <Eelis> i wish there was a syntactic convenience that let you write "case of ..." instead of "\x -> case x of ..."
15:01:28 <edwardk> eelis: iirc it was one of the proposals for haskell' not sure what they said probably no coz no implementation offers it
15:01:38 <Eelis> interesting
15:02:01 <Heffalump> or (\Foo x -> ... | Bar x -> ...)
15:02:01 <wli> lambda patterns or some such
15:02:05 <Heffalump> but that might be hard to parse
15:02:10 <oerjan> it would do wonders for monadic code
15:02:15 <Heffalump> oh, and I need a few more parens
15:02:22 <dolio> Actually, I think the haskell' proposal is 'case of g1 -> ... ; g2 -> ...' ==> 'case () of _ | g1 -> ... ; _ | g2 ...'
15:02:27 <oerjan> getChar >>= case of ...
15:02:35 <dolio> For a cond-like construct.
15:03:08 <Eelis> dolio: well, i could also use something like that, but it's not really the same
15:03:21 <oerjan> no, i am sure a case of ... == \x -> case x of was suggested
15:03:40 <dolio> Huh, I guess I don't remember that one.
15:03:48 <wli> introduce a lambdacase keyword if all else fail.
15:04:15 <dolio> I do remember multiple case lambdas like Heffalump posted, though.
15:04:15 <Eelis> http://hackage.haskell.org/trac/haskell-prime/wiki/LambdaCase , currently listed as "maybe" for Haskell'
15:04:19 <lambdabot> Title: LambdaCase - Haskell Prime - Trac
15:04:26 <kalmar> ?index toList
15:04:26 <lambdabot> Data.Graph.Inductive.Internal.Heap, Data.HashTable, Data.IntMap, Data.IntSet, Data.Map, Data.Set
15:04:27 <edwardk> yep thats the one
15:04:43 <kalmar> still not up to 6.6?
15:05:07 <edwardk> i think you're thinking of the multiway if proposal
15:05:36 <Eelis> i would be in favor of both the multiway if and the lambdacase proposals
15:05:36 <edwardk> case | pred -> e1; | pred2 -> e2 ...
15:06:18 <dolio> Yeah, I guess I just forgot the syntax of multiway-if. It's been a bit since I looked over them.
15:06:43 <Eelis> multiway if is listed as "probably no", though.
15:06:52 <Eelis> still, there's hope for lambdacase :)
15:07:01 <wli> I don't see the point of multiway if.
15:07:01 <edwardk> I think I have to give up on restricted monads/applicatives/functors for my toy prelude =( they make the type signatures of EVERYTHING else horrific
15:07:32 <fasta> Oh, how I hate buggy compilers!
15:08:00 <fasta> This time it seems the module system is broken.
15:08:34 <wli> Multiway if is kind of pointless if you ask me. I generally do a guarded variable definition for that.
15:08:43 <kaol> those type signatures seem to get quite involved in my code. I think I'll pass on using 2nd rank polymorphism. But at least it's nice to know what the issue is.
15:09:23 <fasta> It can also be a Haskell 98 limitation, but it seems pretty ridiculous.
15:09:48 <fasta> Moving a datatype into a module and then importing it breaks the program.
15:10:00 <Heffalump> so anyone have any idea when H' will actually be done?
15:10:10 <SimonRC> how does one pronounce >>=
15:10:13 <xerox> bind
15:10:14 <wli> blah blah blah z where { z | x < 0 = sqrt (negate x) | otherwise = sqrt x }
15:10:19 <SimonRC> xerox: thought so
15:10:36 <monochrom> fasta: how does it break? are you sure you have exported enough?
15:10:40 <glguy> SimonRC: really greater than or equal to ;)
15:10:47 <SimonRC> heh
15:10:48 <edwardk> simonrc: bind
15:10:49 <fasta> monochrom: yes
15:10:59 <kalmar> is it possible to export modules that were imported qualified?
15:10:59 <kalmar> (with qualification being kept)
15:10:59 <kalmar> xb
15:11:00 <fasta> monochrom: I am making a bug-report
15:11:11 <monochrom> alright
15:11:13 <fasta> GHC isn't tested in any way, so it seems.
15:11:20 <fasta> Only "fib" is tested.
15:12:00 <glguy> wli: well in that case you'd use: z = sqrt (abs x) , but I don't know what this mutliway is you are discussing
15:12:36 <dolio> wli: I guess some people prefer to write stuff more in-line, with if, case and let, instead of where and function definitions. But currently, the latter seems to get more niceties.
15:12:40 <wli> glguy: Contrived example. Basically I use a variable name for the expression that would be the result of a multiway if, and then se pattern guards.
15:13:02 <dolio> wli: So multiway-if and the like try to bring the former style up to the convenience of the latter.
15:13:14 <dolio> Or something like that.
15:13:22 <glguy> multiway if is the : if elseif elseif else ?
15:13:35 <wli> glguy: Basically yes.
15:13:45 <dolio> Well, it's 'case | guard1 -> ... | guard 2 -> ...'
15:13:49 <wli> There was an interesting pattern guard proposal at some point.
15:14:08 <glguy> is there anything shorter than: case () of?
15:14:19 <glguy> when you aren't pattern matching?
15:14:33 <edwardk> glguy: a haskell' proposal uses case | pred -> e1; | pre2 -> e2 ...
15:14:46 <edwardk> to elide the () of and _ before the first |
15:16:03 <wli> Hmm, comma separated patterns are supposed to be in there.
15:16:19 <kalmar> what does case () of get you?
15:16:35 <edwardk> kalmar: you can run a bunch of pattern guards against other variables in scope
15:16:50 <dolio> There were a couple first-class pattern proposals a while back, which could be interesting. I get the feeling they didn't go anywhere, though.
15:17:02 <edwardk> case () of _ | isEven x = ... ; | moonIsFull = ...; otherwise = shoot foot
15:17:02 <kalmar> if there's just the one value matching is pointless no?
15:17:09 <edwardk> er | otherwise
15:17:29 <edwardk> its a way to let you start checking guards
15:17:38 <edwardk> since nothing says guards have to refer to variables in the pattern
15:18:28 <glguy> if condition then True else False
15:18:52 <edwardk> I really just wish we had views
15:19:32 <wli> f env x y | Just u <- env `lookup` x, Just v <- env `lookup` y = u + v
15:19:57 <wli> That's the pattern guard extension.
15:20:00 <edwardk> wli: pattern guards
15:20:02 <edwardk> yeah
15:20:45 <edwardk> makes code a lot cleaner since you can do more before 'committing' by crossing the equal sign.
15:20:46 <wli> dolio: Not sure what a first class pattern is.
15:21:21 <dolio> wli: Well, presumably, you'd be able to assign a pattern an identifier, and manipulate them with functions and such.
15:21:31 <dolio> wli: I forget how that works exactly, though.
15:21:39 <edwardk> dolio: strange, any references?
15:21:52 <edwardk> i found a couple of 'pure pattern calculus papers' but they generally sucked
15:22:04 <wli> http://citeseer.ist.psu.edu/337368.html
15:22:06 <lambdabot> Title: First Class Patterns - Tullsen (ResearchIndex)
15:22:14 <Heffalump> F# has them now
15:22:30 <wli> Now I have to go look up F#
15:22:34 <edwardk> i knew i should have given in and bought that f# book
15:22:35 <dolio> Well, if your haskell' archives go back far enough, search for 'lambda match' and PMC, I think.
15:22:47 <dolio> And, yeah, there was an F# paper not too long ago on their system.
15:22:51 <fasta> monochrom: I made the bug, do you want to check that it really is a bug?
15:23:03 <fasta> It seems Hugs also doesn't like my code.
15:23:12 <monochrom> Is it long?
15:23:19 <fasta> monochrom: no
15:23:20 <wli> "F# is a pragmatically-oriented variant of ML that shares a core language with OCaml."
15:23:27 <wli> http://research.microsoft.com/fsharp/fsharp.aspx
15:23:29 <monochrom> I'm interested. Thanks.
15:23:31 <fasta> monochrom: it fits on one screen and in about 200 chars
15:23:35 <_Nucleo> @src (,)
15:23:35 <lambdabot> Source not found. That's something I cannot allow to happen.
15:23:46 <_Nucleo> is (,) defined internally?
15:24:03 <oerjan> _Nucleo: yep
15:24:51 <fasta> http://paste.debian.net/33097
15:24:55 <fasta> monochrom: ^^
15:24:57 <dolio> edwardk: http://research.microsoft.com/research/pubs/view.aspx?0rc=p&type=technical+report&id=1275
15:24:59 <lambdabot> Title: Combining Total and Ad Hoc Extensible Pattern Matching in a Lightweight Language ..., http://tinyurl.com/yq36ac
15:25:09 <dolio> I think that's the F# pattern paper I read.
15:25:21 <fasta> Why is F# suddently so great?
15:25:34 <Heffalump> well, it works, it has good tools, and good .NET integration
15:25:43 <oerjan> _Nucleo: http://haskell.org/onlinereport/standard-prelude.html has some "pseudo-definitions" for tuples, lists and the like
15:25:44 <lambdabot> Title: The Haskell 98 Report: Standard Prelude
15:25:50 <_Nucleo> ahh, thank you
15:25:56 <fasta> Heffalump: good tools?
15:25:59 <fasta> Heffalump: like?
15:26:03 <Heffalump> but it doesn't have anywhere near the same size of community that Haskell has
15:26:04 <dolio> fasta: It has the particular feature we're discussing at the moment?
15:26:09 <Heffalump> Visual Studio integration (AIUI)
15:26:12 <oerjan> @where+ prelude http://haskell.org/onlinereport/standard-prelude.html
15:26:12 <lambdabot> Done.
15:26:21 <Heffalump> including debugger
15:26:34 <Heffalump> whereas Visual Haskell is incomplete and unreliable and has no debugger support
15:26:42 <oerjan> @where Prelude
15:26:43 <lambdabot> http://haskell.org/onlinereport/standard-prelude.html
15:26:44 <fasta> dolio: I didn't follow the discussion.
15:28:29 <glguy> oerjan: forgot already?
15:28:35 <fasta> Anyone who thinks my code is illegal?
15:28:47 <fasta> And why, in case it is.
15:29:27 <oerjan> glguy: i just wanted to check if @where was case-insensitive
15:29:36 <glguy> oerjan: I'm teasing, of course
15:30:09 <_Nucleo> ...
15:30:23 <_Nucleo> is there a systematic way to "cons" something onto a tuple, then?
15:30:35 <oerjan> _Nucleo: no
15:31:15 <oerjan> but you can sometimes use nested 2-tuples, which is not the same
15:31:49 <_Nucleo> and there's no analogous version of "concat" either, then.
15:31:51 <_Nucleo> I see. Thank you.
15:32:23 <oerjan> there's something related called HLists which i haven't looked much at
15:32:46 <dynamix> threple (x,y) z = (x,y,z)  ?
15:33:03 <dynamix> or \(x,y) z -> (x,y,z)
15:33:08 <dynamix> ?pl \(x,y) z -> (x,y,z)
15:33:08 <lambdabot> uncurry (,,)
15:33:16 <_Nucleo> dynamix: yes, but not a general function that works for arbitrary n-tuples
15:33:37 <glguy> _Nucleo: if you need an arbitrary one you are likely doing something worng
15:33:39 <glguy> wrong*
15:33:45 <oerjan> right... you _can_ define a consing typeclass, but you need to list the sizes you need
15:33:48 <glguy> no absolutely, just likely
15:34:22 <monochrom> fasta: reading http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#sec-kinding "explicitly kinded quantification", though I'm reading between the lines (which may be wrong), it does sound like that automatic kind inference only looks at available code at the time.
15:34:23 <lambdabot> Title: 7.4. Type system extensions, http://tinyurl.com/uxvor
15:34:26 <_Nucleo> glguy: true enough
15:35:06 <fasta> monochrom: In my application not being able to do just this breaks abstraction.
15:35:27 <glguy> fasta: it would be pretty unreasonable for the type of something in a module to be arbitrarily defined by another module that imports it
15:35:27 <dynamix> is there a way to convert a tuple to a list?
15:35:30 <glguy> no?
15:35:44 <glguy> \ (a,b) -> [a,b]
15:35:51 <monochrom> fasta: Thus, in the opening, Hughes wrote "... | Unused (cxt a -> ()) " only because if he didn't, it's legal for a Haskell compiler to assume "cxt :: *"
15:35:57 <dynamix> no generic like nucleo wants
15:36:09 <fasta> glguy: I disagree
15:36:14 <dynamix> in python you can say list( tuple)
15:36:14 <glguy> fasta: ok
15:36:24 <glguy> dynamix: python eschews reasonable types
15:36:26 <dynamix> or the other way to..
15:36:34 <monochrom> Are you willing to use an extension?  "data CompilerBugs s a chain (m :: * -> *) = IReallyHateThose (STRef s (chain s a m))"  inside Nooo.hs works.
15:36:46 <wli> First-class patterns could be interesting.
15:36:47 <dolio> dynamix: Try to work out the type of such a function. :)
15:37:03 <glguy> f :: (a,a) -> [a]
15:37:05 <fasta> monochrom: yes, I am willing to use an extension.
15:37:16 <dynamix> actually imtrying to write one now.
15:37:21 <fasta> monochrom: but these things should just work by default
15:37:26 <_Nucleo> I mean, if elements of the tuple all were of the same type, then use a list anyway.
15:37:51 <glguy> _Nucleo: well... a tuple is useful if it should be a certain number of things of the same type
15:37:51 <fasta> I am merely passing a type through a type constructor (that's what they are meant to do)
15:38:17 <fasta> The fact that it's not a simple type is of little interest to me, and shouldn't be for the compiler.
15:38:21 <monochrom> I feel that it is not a bug since other people seem to accept * as the default kind. You will have to argue at the language spec level, not the implementation level.
15:38:23 <fasta> monochrom: thanks, for looking.
15:38:57 <fasta> monochrom: can't ghc determine the kind it self?
15:39:02 <Heffalump> I don't really understand why kinds wouldn't be inferred like types are.
15:39:09 <fasta> monochrom: or is that incomputable again?
15:39:27 <fasta> itself*
15:39:42 <fasta> Heffalump: the kinds are inferred when they are in the same module
15:40:00 <monochrom> It is incomputable. If you have "data X a = X a" alone, no information says "a" should be * or *->* or ...
15:40:12 <wli> I like the bit about injection and partial projection pairs.
15:40:18 <Heffalump> I guess one problem is that * doesn't include * -> *
15:40:21 <fasta> monochrom: doesn't that depend on use?
15:40:32 <dynamix> _Nucleo:  if we can write recursive patterns or specify tuples through a pattern it woukd be possible, but not now. coz neither is possible
15:40:34 <Heffalump> whereas in types, a would include b -> c
15:40:51 <_Nucleo> ahh, okay
15:40:55 <monochrom> When you compile "data X a = X a" you don't know what will use it. And yet you have to assign a kind.
15:40:57 <glguy> so it comes down to kinds not being polymorphic
15:41:11 <monochrom> Yeah, I guess it comes down to "kinds not polymorphic"
15:41:14 <dynamix> brb
15:41:42 <fasta> Is there any language with polymorphic anythings?
15:42:01 <monochrom> Coq may be. I forgot.
15:42:27 <Heffalump> Cayenne I imagine
15:43:38 <mrd> ugh, _|_ caused by precedence mixup :/
15:43:43 <monochrom> The manual section on explicit kinds saying "On some occasions, it is essential to do so" seems to imply we don't know of a better way.
15:44:14 <Heffalump> surely it just means "in the current implementation of GHC, there are things you can only do with explicit kinds"
15:44:20 <Heffalump> rather than "we know no solution for this problem"
15:45:30 <ddarius> You can "cons" things onto a tuple.  In two distinct ways.
15:45:59 <fasta> In the OhNo case it could have derived that m needs kind * -> *
15:46:13 <monochrom> If it reads other modules.
15:46:23 <fasta> monochrom: no, it is applied to ()
15:46:43 <monochrom> I'm saying when you compile Nooo.hs.
15:47:01 <fasta> monochrom: ok
15:47:10 <monochrom> * is not instantiated to *->*. no polymorphism there.
15:47:20 <_Nucleo> ddarius: how?
15:47:27 <fasta> monochrom: right, I understand the issue now. Thanks for elaborating.
15:47:55 <glguy> so everyone is in agreement?
15:48:04 <monochrom> kind polymorphism should be fun, but I'm not sure what that gets us into.
15:48:32 * glguy doesn't envy the GHC devs jobs of making Haskell work behind the scenes
15:48:44 <Limbic_Region> anyone participating in this year's ICFP contest?
15:48:53 <ddarius> The hard way is HList though at some level it's doing the same thing as the easy way which is simply, tupleCons x xs = (x,xs).
15:49:02 <_Nucleo> Limbic_Region: the Lazy Bottoms are top 20 atm.
15:50:20 <Heffalump> 21 right now
15:50:25 <Heffalump> Frictionless Bananas are top 20
15:50:26 <_Nucleo> ah
15:50:32 <Heffalump> they've got a good record in it, IIRC
15:51:10 <Heffalump> but looking at the scores, none of the positions from 21 down seem to have a realistic solution
15:51:20 <Heffalump> so I suspect most/all of the top ones don't either and it's all just a bit random
15:52:09 <_Nucleo> ddarius: the easy way gets you a nested tuple if xs is already a tuple, right?
15:52:30 <ddarius> Yes, which (modulo bottoms) is isomorphic to a "flat" tuple.
15:52:55 <_Nucleo> I guess nesting two-tuples lets you do clever things with fst and snd
15:53:38 <ddarius> If you abuse type classes enough you can get a type-directed project.  Of course if you do these kinds of things you get HList.
15:53:45 <wli> I wonder what they'll do if all the solutions come out crap.
15:53:59 <ddarius> Watch Endo die a slow and painful death.
15:54:51 <oerjan> ddarius: Endo?
15:55:26 * sm codes along
15:56:27 <oerjan> ah.
15:56:41 * oerjan hadn't looked at the contest page yet.
15:57:00 <fasta> If I store a pointer in a data structure to a function that is the same in all data structures, will the pointer in the data structure be optimized away and the function inlined cross-module?
16:00:01 <ddarius> fasta: That doesn't make much sense.
16:00:32 <Philippa> "if I have a type containing a function value, and it's always the same function value..."
16:00:57 <monochrom> compiler unlikely to notice it's the same one all along
16:01:44 <fasta> Ok, so, how should I make a call back function then?
16:02:16 <int-e> fasta: if it's always the same function why do you need that?
16:02:37 <fasta> int-e: it's the same for a large number of structures.
16:02:47 <monochrom> and if it "may be different in the future", you need to pay the cost of that flexibility.
16:02:47 <glguy> functions don't inline across modules irrc
16:02:47 <fasta> int-e: it doesn't vary during run-time.,
16:02:49 <glguy> iirc
16:02:55 <int-e> if you put it in a type class the compiler may have better luck with inlining or specializing
16:03:35 <int-e> glguy: well, ghc can do it in principle and does for small functions.
16:03:36 <fasta> int-e: I think that's a better solution, yes.
16:03:57 <fasta> That should get rid of the explicit kinds too.
16:06:17 <sm> alright.. time I learned how to use a monad to avoid passing state parameters through everything
16:06:27 <sm> I think I should read about the State monad ?
16:06:43 <ddarius> sm: Well, why do you call them "state" parameters?
16:06:48 <ddarius> Maybe you want Reader?
16:07:02 <monochrom> Yes, the State monad.
16:07:36 <monochrom> "state parameter" because in "s -> (a,s)" s is a parameter too
16:08:02 <ddarius> monochrom: Yes, but I'm not sure if that is what sm means.
16:08:14 * sm thinks
16:08:21 <mathewm> Any way to make the -hc SCC's names longer?
16:09:05 <sm> I want a global variable or two
16:09:12 <monochrom> It is simplest not to second-guess.
16:09:16 <sm> currently I'm passing them as parameters
16:09:23 <sm> and I'd rather not
16:09:43 <ddarius> monochrom: Maybe simplest for me.
16:09:53 <ddarius> sm: State sounds like what you would want then.
16:10:04 <sm> ok, thanks
16:10:22 <sm> I know there are quite a few monads in the zoo so I wanted to check
16:12:20 <sm> hmm, the tempting hoogle State results all link to the same empty module doc
16:12:46 <ddarius> @docs Control.Monad.State
16:12:46 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-State.html
16:13:32 <monochrom> http://en.wikibooks.org/wiki/Haskell/Advanced_monads#The_State_monad  may worth a read
16:13:35 <lambdabot> http://tinyurl.com/j7yww
16:14:14 <mathewm> ddarius: click the link there - the guts are re-exported from other modules
16:14:46 <ddarius> mathewm: I did click the link.  It contains another link that is pretty descriptive.
16:15:11 <jre2> any work on getting haskell to run on a cell phone (or related embedded devices)?
16:15:43 <sm> thanks!
16:15:49 <mathewm> yay me!  3 minutes -> 20 seconds with one '$!' :)
16:15:55 <ddarius> The is/was Haskell on PDA stuff.
16:19:54 <jre2> ddarius: ahah, a little bit of luck and a large number of memory allocation woes
16:21:44 <jre2> seems "zaurus" is the magically search term for embedded haskell, thanks
16:22:01 <jre2> s/magically/magical/
16:25:28 <hpaste>  (anonymous) annotated "frankenstein attempt at HAppS" with "(no title)" at http://hpaste.org/1799#a2
16:25:39 <msouth> sorry
16:25:51 <msouth> discussing that in happs, forgot to uncheck
16:26:18 <stepcut> jre2: I have spent a bit of time trying to get ghc to compile on ARM -- which is the processor in most cell phones
16:26:49 <jre2> stepcut: how's that turning out?
16:27:21 <stepcut> jre2: slow. Compiling GHC under QEMU is slooooow. And I don't have a lot of time to work on it
16:27:57 <stepcut> jre2: i heard a rumor the GHC is adding a plain ANSI C backend to GHC though -- which would make things a lot easier
16:34:04 <MarcWeber> stepcut: Which os?
16:34:50 <MarcWeber> If you are using Windows and need linux there are two alternatives colinux and uml for windows. The first one works great. I don't know much about the second
16:49:08 <SimonRC> @type liftM
16:49:11 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
16:50:43 <stepcut> MarcWeber: linux (specifically Maemo for the Nokia 770)
16:55:21 <nominolo> :t sq
16:55:23 <lambdabot> Not in scope: `sq'
16:55:23 <nominolo> :t seq
16:55:25 <lambdabot> forall a t. a -> t -> t
16:55:31 <SimonRC> @type enumFromTo
16:55:33 <lambdabot> forall a. (Enum a) => a -> a -> [a]
16:56:50 <roconnor> according to my profile report, I'm spending 100% of my time in main
16:57:19 <dolio> Inherited, or 'for real'?
16:57:41 <roconnor> both
16:57:51 <stepcut> roconnor: perhaps everything got inlined ?
16:58:08 <roconnor> my entire DNA simulation program :)
16:58:10 <stepcut> the profile reports are always a mystery to me
16:58:35 <stepcut> typically once I optimize something to a certain point, it just disappears from the report altogether
16:58:46 <stepcut> presumably, because it suddenly started get inlined or something
16:58:51 <genneth> question about sequence: if I have a "return ()" in the middle, does it essentially shortcut the rest of the monadic actions?
16:59:00 <ddarius> genneth: No.
16:59:00 <stepcut> genneth: no
16:59:03 <roconnor> genneth: nope
16:59:07 <genneth> well
16:59:09 <ddarius> return is roughly a nop
16:59:10 <pjd> roconnor: what would you do if the answer was different?
16:59:10 <genneth> that's pretty conclusive
16:59:11 <genneth> :p
16:59:41 <roconnor> pjd: what do you mean.  I would look at the functions that are taking all the time.
16:59:55 <roconnor> My call centers are not being created :(
17:00:41 <iskaldur> can i have some help in simulating a global variable? using the state monad or whatever there is?
17:00:44 <stepcut> genneth: return () would pass () to the next thing in the monadic chain, return () >>= action1,  and action1  would have the type, action1 :: () -> m a
17:01:00 <dolio> I think laziness can cause that sometimes, too. If you have a function that builds a list, and all the elements are thunks that do the interesting work, and then they all get forced in main, main will get the credit.
17:01:12 <pjd> roconnor: oh, i assumed that was the cumulative time
17:01:19 <Saizan> genneth: to shortcut in most MonadPlus you can use mzero, but in IO it raises an exception for example
17:01:27 <iskaldur> (it's not the exact thing i want to do, but say i have three different functions, and i want a counter global variable that keeps track of how often any one of them is called)
17:01:31 <dolio> But I'm not a profiler guru.
17:01:38 <stepcut> genneth: in a do block  do { return () ; action } would be like 'return () >> action'. So, return would try to pass () to action, but >> would just drop the () and call action
17:02:13 <ddarius> return () >>= action = action ()
17:03:22 <genneth> stepcut: i was hoping that wouldn't be the case... but thanks for the explanation; kinda obvious if I'd just thought a little more, or even exprimented :$
17:04:14 <iskaldur> or does anyone have examples of how to use unsafePerformIO and newIORef in a function?
17:04:14 <desp> sigh
17:04:24 <desp> I was asking about this a while ago, but I forgot the answer
17:04:40 <desp> how can I join two pattern matches into one match?
17:05:02 <desp> like  case foo of { Pat1 -> effect ; Pat2 -> effect }
17:05:05 <genneth> so want i'm looking for is a map over a list, where some monadic action might happen, including a general exit from the loop
17:05:15 <desp> into  "case foo of { Pat1 || Pat2 -> effect }"
17:05:45 <desp> it's easy to do in OCaml/SML
17:05:50 <ddarius> genneth: mapM
17:06:29 <genneth> ddarius: but i thought mapM == sequence . map ?
17:06:36 <ddarius> desp: You could do something with pattern guards, but essentially there is no easy way.
17:06:42 <ddarius> genneth: It is.
17:06:45 <desp> ddarius: could you give me a hint?
17:07:02 <desp> I need to match constants only
17:07:10 <ddarius> For constants you can use elem
17:07:11 <ddarius> and a guard
17:07:21 <ddarius> Assuming they are Eqable
17:07:21 <desp> uh.
17:07:40 <desp> @type elem
17:07:42 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
17:08:03 <desp> b | b `elem` [C1, C2] ?
17:08:06 <genneth> ddarius: but i thought sequence couldn't cause the rest of the list to be dropped?
17:08:10 <ddarius> f x | x `elem` [1,2,3] = "foo" | otherwise = "bar"
17:08:18 <desp> right, thanks
17:09:27 <ddarius> genneth: It sequences the actions.  An earlier action can cause the later ones not to be executed.
17:09:52 <genneth> ddarius: how?
17:11:06 <ddarius> genneth: If the monad supports exceptions/failure/jumps, e.g. IO, Either e, Maybe, [], Cont.
17:11:20 <Saizan> > sequence [Just 1,Just 2,Nothing]
17:11:21 <lambdabot>  Nothing
17:11:26 <Saizan> > sequence [Just 1,Just 2,Nothing,Just 3]
17:11:27 <lambdabot>  Nothing
17:11:33 <Saizan> > sequence [Just 1,Just 2,Just 3]
17:11:34 <lambdabot>  Just [1,2,3]
17:11:43 <iskaldur> One last try :) I have myGlobalVar = unsafePerformIO (newIORef 17)
17:11:51 <genneth> right; got it
17:11:52 <genneth> :D
17:11:57 <iskaldur> how do I get the following to work (i just want to update myGlobalVar to 42, and return 42)
17:12:20 <Saizan> iskaldur: you want to update in pure code?
17:12:22 <iskaldur> foo = do{ myGlobalVar <- unsafePerformIO $ new IORef 42; return myGlobalVar } ... but this gives an error
17:12:34 <iskaldur> i just want something that will let me update
17:13:24 <iskaldur> using unsafeperform...or maybe state monad (though i still don't fully comprehend monads, so i'm hoping not :))...or whatever else there is
17:13:56 <Saizan> ok, but are you in IO when you want to update this globalvar?
17:14:23 <iskaldur> saizan: nope
17:15:23 <Saizan> you'll get in a lot of troubles trying to use unsafePerfomIO in that way
17:15:41 <Saizan> so a State monad is better, but it will change the types of your functions
17:16:56 <iskaldur> saizan: can you give me an example? it's been a while since i used haskell, so i've sorta forgotten how to do state monads
17:18:17 <Saizan> ok, say you have foo :: A -> B, you can write countFoo a = do modify (+1); return (foo a)
17:18:20 <oerjan> iskaldur: you want writeIORef myGlobalVar 42
17:18:38 <Saizan> where countFoo :: A -> State Int B
17:19:32 <oerjan> (if you want to use the unsafePerformIO trick, and work in IO)
17:19:54 <Saizan> you've to call countFoo in the State monad though, and when you don't need to count anymore you use runState to get the result and the state
17:20:14 <desp> what can I add to a case statement to easily ignore an unexhaustive warning?
17:20:18 <desp> is there a no-op?
17:20:28 <Saizan> _ -> undefined ?
17:20:31 <oerjan> desp: _ -> error "..." at the end
17:20:43 <desp> undefined, good one
17:21:29 <iskaldur> must think about this for a sec :)
17:23:06 <iskaldur> oerjan: so instead of "myGlobalVar <- unsafePerformIO $ newIORef 42", I do "writeIORef myGlobalVar 42"?
17:23:29 <oerjan> iskaldur: yes, in the IO monad
17:23:56 <_roconnor> crap, all my time is spent in LazyByteString's Concat
17:23:56 <iskaldur> saizan: and what exactly are the troubles with unsafeperformio? what i'm trying to write is a one-time piece of code that i don't really care how messy it is =o
17:25:49 <iskaldur> oerjan: so i have foo = do {writeIORef myGlobalVar 42; return myGlobalVar}...if I want to do 1 + foo (to get 43), how do i extract the Int from foo?
17:26:09 <oerjan> iskaldur: it's a bit fishy, it doesn't fit into Haskell's usual semantics, and you need to add noinline pragmas to prevent bad things from happening when the compiler optimizes your code
17:26:37 <Saizan> iskaldur: that you've to care a lot about strictness and how GHC may end up optimizing your program, inlining or floating constants out can alter the number of times your actions are executed
17:26:37 <oerjan> iskaldur: then you can use modifyIORef or readIORef
17:26:58 <oerjan> @docs Data.IORef
17:26:58 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-IORef.html
17:27:15 <oerjan> iskaldur: look at that ^^^
17:29:15 <oerjan> also, http://www.haskell.org/haskellwiki/Top_level_mutable_state
17:29:16 <lambdabot> Title: Top level mutable state - HaskellWiki
17:30:34 <iskaldur> hmm, thanks :) i guess i'll probably just stick to state monad for now, otherwise confuse myself even more =\
17:30:39 <fasta> Top level mutable state already works in GHC.
17:31:33 <fasta> Using unsafePerformIO in that way doesn't work in 6.7 anymore.
17:32:55 <oerjan> what do you do now?
17:33:56 <fasta> oerjan: Cale posted it on hpaste.org
17:34:15 <fasta> oerjan: I have no interest in looking it up now, (it's late)
17:35:20 <oerjan> was it a long time ago?
17:35:34 <fasta> oerjan: less than a month
17:36:05 <oerjan> hpaste could need a search function
17:36:52 <fasta> oerjan: doesn't google index it?
17:37:02 <ddarius> @google site:hpaste.org Cale
17:37:04 <lambdabot> http://hpaste.org/
17:37:05 <lambdabot> Title: recent - hpaste
17:37:27 <ddarius> Hopefully the other hits are more useful...
17:39:31 <desp> @hoogle unsafePerformIO
17:39:31 <lambdabot> Foreign.unsafePerformIO :: IO a -> a
17:40:02 <oerjan> http://hpaste.org/1595 but i don't see how that is anything new...
17:41:11 <oerjan> i thought you meant ghc had implemented an actual proposal, this looks like it has simply broken slightly the old way of doing it?
17:42:15 <fasta> oerjan: you recommended something that doesn't work anymore.
17:42:48 <oerjan> you said that top level mutable state worked in ghc.
17:43:03 <fasta> oerjan: it does
17:43:13 <fasta> oerjan: it's just not a "proposal".
17:43:23 <fasta> oerjan: more of a more safe way to do a hack.
17:43:44 <fasta> oerjan: real programs don't need top-level mutable state
17:43:56 <fasta> oerjan: it's only useful for debugging things.
17:44:23 <oerjan> that thing Cale posted in what i linked, is supposed to be more safe? i don't see _any_ difference other than being meaninglessly, slightly changed
17:45:30 <fasta> oerjan: unsafePerformIO (unsafeSTToIO (newSTRef False)) <- did you see that?
17:46:03 <oerjan> yes.
17:46:07 <oerjan> that is what i meant.
17:46:47 <desp> sigh
17:47:03 <desp> is there an easy way to profile my Haskell code and see where I'm spending the most time?
17:47:27 <fasta> oerjan: you might not see the difference, but the top code doesn't work anymore and is what you suggested to iskaldur. The bottom code does work.
17:47:46 <Saizan> ?google ghc user manual profiling
17:47:48 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/hp2ps.html
17:47:48 <lambdabot> Title: 5.6. hp2ps&#8211;&#8211;heap profile to PostScript
17:47:55 <oerjan> i don't see _why_ they should make it break
17:48:15 <oerjan> unless they provided something _actually_ better.
17:48:23 <desp> Saizan: thanks
17:48:35 <Saizan> oerjan: it's just that it optimizes more, maybe
17:48:54 <desp> -h<break-down>?
17:49:11 <ddarius> I don't see them explicitly putting a "break unsafePerformIO hack" change into GHC.
17:49:13 <Saizan> desp: i was searching for this: http://www.haskell.org/ghc/docs/latest/html/users_guide/profiling.html
17:49:15 <lambdabot> Title: Chapter 5. Profiling, http://tinyurl.com/kwh6c
17:50:01 <desp>     Could not find module `Data.Binary.Put':
17:50:01 <desp>       Perhaps you haven't installed the profiling libraries for package binary-0.3?
17:50:13 <desp> can I easily build a cabal package with profiling?
17:50:14 <oerjan> on the other hand, it _might_ be that it just breaks for the strange use case in the initial post.
17:50:45 <Saizan> desp: configure -p iirc
17:51:12 <oerjan> which combines several unsafePerformIOs referring to the same variable, and so is not just the usual hack.
17:53:47 <oerjan> hm... yes, i think it actually is reasonable that you have to do something like that.
17:55:00 <oerjan> fasta: i suspect the issue was not really with the unsafePerformIO hack itself, but with combining several referring somehow to the same variable.
17:55:25 <fasta> oerjan: ok, that might very well be true
17:56:00 <fasta> oerjan: but the bottom code is more robust.
17:56:57 <oerjan> probably, since ST _is_ intended to be safely callable within pure code.
17:57:24 <desp> grhm
17:57:38 <desp> Saizan: how can I force it to flush the .prof file?
17:57:46 <desp> it's 0-length
17:59:24 <fasta> oerjan: that ST code can be transformed to IO code again too.
17:59:41 <fasta> oerjan: but you already knew that, probably
18:00:06 <oerjan> yeah, i was looking at the ST page
18:07:44 <desp> never mind
18:07:45 <desp> Saizan++
18:20:29 <dons> so everyone is hammering bytestrings, binary and parser combinators?
18:20:50 <dons> for the icfp contest. good good. i hipeits all working
18:20:58 <dons> hipeits?
18:23:04 <roconnor> dons: I'm spending 85% of my time in Bytestring.concat :(
18:23:42 <roconnor> and 85% of my allocs
18:24:04 <dons> using concat for append?
18:24:09 <dons> lazy or strict bytestrings?
18:24:28 <roconnor> strict
18:24:29 <lispy> ?src copyFile
18:24:30 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
18:24:40 <dons> roconnor: concat on strict bytestrings is O(n)
18:24:48 <lispy> dons: System.Directory.copyFile doesn't use bytestrings!
18:25:16 <roconnor> dons: I'm sure a series of appends won't be better will it?
18:25:29 <dons> roconnor: you probably can switch to lazy bytestrings then, since that would be O(n/c) concat
18:25:35 <dons> or O(c) actually
18:25:41 <dons> which is n/32k
18:25:46 <roconnor> dons: I switched from Lazy Bytestrings
18:26:03 <dons> lispy: hmm? its just CStrings
18:26:06 <roconnor> it reduced my memory consumption from all my memory down to a more reasonable amount.
18:26:43 <dons> roconnor: ok. that sounds right
18:26:50 <dons> concat is usually better that a lot of appends, yes.
18:27:05 <lispy> dons: are you saying you wouldn't expect any improvements for changing it to bytestring?
18:27:19 <dons> lispy: well, bytestrings are sugar of hGetbuf/hPutBuf anyway
18:27:26 <roconnor> I'm not sure how I'm gonna make this faster.
18:27:56 <lispy> wow, the problem description is long
18:28:05 <dons> what's the bottleneck, ro	?
18:28:12 <dons> roconnor:
18:28:18 <desp> how can I force the profiler to dump the .prof? the resulting file is 0-length
18:28:34 <dons> -prof -auto-all ?
18:28:42 <lispy> desp: it has to run to complettion maybe
18:28:45 <dons> and +RT -p
18:28:48 <dons> +RTS -p
18:28:51 <desp> yes
18:28:56 <desp> that creates a 0-length .prof
18:28:58 <roconnor> dons: it appears to be concat I take a bunch of smallish strings, and one big string, and put them together.
18:28:58 <LordBrain> dons, i seem to have lost it, you showed me a monad made of monad transformers which was used in xmonad, along with a nice little image of concentric circles corresponding to the monads being composed..
18:28:58 <dons> yeah, it'll have to run to completion, unless you're using ghc head
18:29:02 <desp> and it runs for a few minutes
18:29:09 <desp> so what do you meant completion?
18:29:14 <Igloo> 6.6* shouldn't need to run to completion
18:29:16 <lispy> it has to terminate normally
18:29:21 <desp> it does
18:29:23 <LordBrain> is that still posted?
18:29:27 <lispy> hmm
18:29:34 <desp> I'll try again, but...
18:29:54 <dons> roconnor: maybe you can use Data.DList to do the concat with (.), before joining them onto the bytestring
18:30:08 <dons> is speed turning out to be the key issue in the contest?
18:30:20 <roconnor> dons: I could, would that be faster?
18:30:38 <roconnor> DList is just List a -> List a?
18:30:47 <roconnor> or does it use bytestrings?
18:30:49 <desp> dons: I probably have a bug
18:31:22 <dons> roconnor: its like a [a], but you could happily use it to build up [bytestring]
18:31:44 <dons> desp: ?
18:32:00 <desp> dons: in other words, speed not key issue
18:32:00 <Saizan> dons: you've to generate a program, and intepreting it seems the only way to see how close you're :)
18:32:02 <desp> bug key issue
18:32:03 <desp> :)
18:32:07 <dons> desp, ok. phew :)
18:32:13 <desp> I think
18:32:25 <roconnor> dons: I don't get it.  If I produce [bytestring] I will still need to call B.concat.
18:32:47 <dons> roconnor: for a lazy bytestring, you can just join the chunks with ++
18:32:58 <dons> so you build up a [chunk]
18:33:18 <roconnor> but then I'll have a lazybytestring.
18:33:28 <dons> yep.
18:33:30 <desp> omg but I'm still not getting a *prof
18:33:40 <desp> and I did get one just a while ago
18:33:50 <desp> I mean, I get an empty *prof
18:33:52 <roconnor> dons: wouldn't my memory issues return in that case?
18:33:54 <lispy> heeh, It is hypothesized that, contrary to life on Earth, the Fuun are a result of intelligent
18:33:57 <lispy> design.
18:34:51 <dons> roconnor: i couldn't say for sure, roconnor. Data.Binary, Lazy bytestrings, DLists are all aproaches that could help if you're doing a lot of concat/append
18:35:20 <desp> dons: I ended up using Data.binary; pretty nice
18:35:32 <desp> but I think the findSubstring really bites
18:36:12 <roconnor> desp: What's in Data.Binary?
18:36:19 <desp> put
18:36:27 <desp> fast appends to a BS
18:36:33 <dons> desp, oh yes, don't use findSubstring
18:36:35 <dons> roll your own
18:36:44 <dons> and when someone has a good bytestring-native 11:35  dons> desp, oh yes, don't use findSubstring
18:36:47 <roconnor> desp: why is it fast?
18:37:00 <desp> dons: actually, I'm calling S.concat . L.toChunks on the lazy bs resulting from Data.Binary; is that ok?
18:37:25 <dons> well, it strictifies it. that should be ok if you don't intend to concat/append/cons on it again
18:37:34 <desp> ack
18:37:49 <desp> roconnor: it appears to use a lazy bs internally to queue writes
18:38:03 <dons> roconnor: Data.Binary is basically another fast way to write chunks onto the end of a lazy bytestring
18:38:42 <ddarius> Is there a decent ropes library anywhere?
18:38:56 <dons> it fills buffers, to become each chunk of the lazy bytestring, with O(1) insert at the end (amortised0
18:39:14 <dons> ddarius: not that I know of.
18:39:25 <roconnor> desp: so you are using lazy bytestrings?
18:39:35 <desp> mostly strict ones
18:39:42 <desp> because I need lengths
18:39:49 <roconnor> desp: how do you get from lazy bytestrings to strict ones?
18:39:59 <desp> strictify = S.concat . L.toChunks
18:40:01 <dons> desp, so you build up a lazy bytestring with Data.Binary, then `S.concat . L.toChunks'
18:40:17 <roconnor> desp: you don't find S.concat slow?
18:40:38 <desp> the one .prof file I did get showed 98% cpu spent in a certain place
18:40:53 <desp> which I strongly believe is due to findSubstring
18:41:03 <desp> I'd verify that, but I can't get another damn .prof
18:41:10 <dons> desp, that sounds plausible. findSubstring is badly implemented.
18:41:21 <dons> i use isPrefixOf in a strict loop usually
18:41:36 <desp> I just did a make clean and rebuild
18:41:38 <desp> all the options are set
18:41:40 <desp> wtf
18:41:44 <dons> you could even call strstr
18:42:32 <lispy> man, i don't think i should try icfp this year, i don't think i have the patience to read though the instructions :)
18:43:25 * dolio chuckles about the latest Jon Harrop benchmark.
18:46:57 <lispy> dolio: what is the thread subject? is it the one about minim?
18:47:12 <dolio> Yeah, but the funny stuff is in the comp.lang.functional thread.
18:47:52 <dolio> The lisp guy appears to have stacked the deck towards lisp, because he made the syntax of the language, essentially, s-expressions.
18:48:11 <dons> he's such an weird spammer, harrop
18:48:17 <lispy> ah
18:48:44 <dolio> Whereas everyone else will have to lex the language.
18:49:01 <dolio> And then, for a while, they were all comparing times from different computers.
18:49:25 <dolio> So, the Qi guy gut 2 seconds, but Jon got 0.1 second, but who knows how their computers compare?
18:49:39 <lispy> oy
18:50:29 <lispy> i'm not sure what to think of Harrop, he seems like a genuiely nice guy, but some of his threads are just....weird
18:50:53 <dolio> And I guess the Qi guy can't get Qi to work with a fast lisp implementation, so he has to use a slow one, and guess what the time in the fast one would be.
18:51:24 <lispy> i saw that, but based on my experiences with clisp and sbcl his guess is quite reasonable
18:52:18 <dons> and harrop is just using it to promote his ocaml book
18:52:43 <lispy> i've done benchmarks before where i told both sbcl and clisp to compile then execute.  And even though clisp finished compiling several minutes before sbcl, the sbcl example finished executing way ahead of the clisp one :)
18:52:56 <dolio> Heh.
18:53:19 <dolio> Yeah, his estimate is probably accurate. It just seems like a comedy of errors.
18:53:29 <lispy> right, it's funny
18:53:56 <lispy> harrops claims of making a mathematica clone bugged m
18:53:59 <lispy> +e
18:54:09 <lispy> they were too outlandish
18:54:20 <dolio> I didn't read closely enough to see what was going on with the mathematica.
18:54:31 <dolio> Did he write an equivalent program in mathematica, or an actual interpreter?
18:54:53 <lispy> supposedly he wrote an interpreter in some insane amount of time, like a a weekend
18:55:19 <lispy> and it was enough of a mathematica clone that they bought it from him
18:55:47 <dolio> Oh, you mean that. Yeah, I don't know what to make of that.
18:56:20 <LordBrain> my understanding is the original scheme48 was made in 48 hours
18:56:52 <LordBrain> something like that anyway
18:57:06 <lispy> fact is stranger than fiction, but i have a hard time with the claim, ya know?
18:58:19 <magnus__> I'm trying to learn to use monad transformers but I'm having some problems.
18:59:20 <magnus__> Is there a way to combine the Maybe monad and the State monad so that State is backtracked if Nothing is returned?
19:00:00 <chessguy> ooh, lazy bottoms got knocked out of the top 20
19:00:47 <dolio> > runStateT (mzero >> put 5 :: StateT Int Maybe ())
19:00:49 <lambdabot>  <Int -> Maybe ((),Int)>
19:00:51 <LordBrain> The Mathematica people bought it from him?
19:00:56 <dolio> > runStateT (mzero >> put 5 :: StateT Int Maybe ()) 1
19:00:57 <lambdabot>  Nothing
19:01:02 <LordBrain> to get rid fo the competition?
19:01:27 <lispy> LordBrain: yes, and who knows, maybe they just wanted to see how he structured it
19:01:37 <dolio> I guess I'm going to have to be more creative...
19:01:44 <monochrom> "StateT s Maybe a" should do.  Note that it also belongs to MonadPlus, you can use mplus to backtrack and try alternatives
19:02:21 <magnus__> > runState (mzero >> (put 5 :: State Int Int))
19:02:22 <lambdabot>  Couldn't match expected type `Int' against inferred type `()'
19:02:39 <dolio> > runStateT ((put 5 >> mzero) `mplus` return 5 :: StateT Int Maybe Int) 1
19:02:41 <lambdabot>  Just (5,1)
19:02:50 <monochrom> > runStateT ((mzero >> put 5) `mplus` (put 6) :: StateT Int Maybe ()) 1
19:02:52 <lambdabot>  Just ((),6)
19:03:11 <monochrom> > runStateT ((put 5 >> mzero) `mplus` (put 6) :: StateT Int Maybe ()) 1
19:03:12 <lambdabot>  Just ((),6)
19:03:27 <magnus__> this is cool but I'm not understanding much :)
19:03:38 <monochrom> You see put 5 is abandoned due to mzero, and the put 6 alternative takes effect.
19:03:59 <dolio> Or, in my case, it's abandoned, and the original 1 is in place.
19:04:33 <magnus__> very nice
19:05:05 <lispy> magnus__: have you read the tutorial that describes how to build an interpreter with loging and exception handling using monad transformers?
19:05:26 <Olathe> Are there any languages that have something like reverse = [a, ..., b] -> [b, ..., a]; palindromize = [a] -> [a], [a, ...] -> [a, ..., a] ?
19:05:34 <magnus__> lispy: no, I don't think so
19:05:37 <Olathe> (where ... means recurse with the elements here)
19:06:33 <lispy> magnus__: i liked it: http://www.cs.tu-berlin.de/~magr/pub/Transformers.pdf
19:06:42 <magnus__> Thanks
19:07:27 <lispy> magnus__: i haven't read this, but it looks promising from the title and being a functional pearl: http://www.cs.rutgers.edu/~ccshan/logicprog/LogicT-icfp2005.pdf
19:08:18 <magnus__> cool, I'll have a look at them when I get frustrated with icfp :)
19:08:47 <lispy> magnus__: indeed, i coludn't even survive the instructions :)
19:12:45 <hpaste>  dons pasted "faster findSubstring?" at http://hpaste.org/1803
19:21:23 <dons> yeah, people using Data.ByteString.findSubstring should probably use http://hpaste.org/1803  :)
19:21:37 <dons> dcoutts: we need to fix  this for bytestring 1.0
19:36:01 <magnus__> If I have this, where do I put in the Maybe?
19:36:08 <magnus__> type GlobalMonad = WriterT Rna (StateT Dna Identity)
19:36:12 <magnus__> type PatternMonad = StateT Int (WriterT Pattern GlobalMonad)
19:37:01 <glguy> ?seen dons
19:37:01 <lambdabot> dons is in #haskell-icfp07, #xmonad, #haskell-soc and #haskell. I last heard dons speak 18s ago.
19:37:04 <dons> yes?
19:37:08 <glguy> :-D
19:47:29 --- mode: ChanServ set +o glguy
19:47:43 --- mode: glguy set -b topaz*!*@*
19:48:12 --- mode: glguy set -bb *!*i=topaz@*.dsl.pltn13.pacbell.net zptao!*@*
19:50:04 --- mode: glguy set -b m4St3R_b41T3R*!*@*
19:51:55 --- mode: glguy set -b *!*@*.magnesium.net
19:52:14 <glguy> (these bans are managed by chanserv, and are stale)
19:54:30 * SamB thinks uade is a very odd program, the way it lives in its own .dir
20:15:51 <HWSOD> \msg NickServ identifiy koklama
20:16:38 <TSC> HWSOD: You might want to try that again
20:18:59 <Olathe> Status windows are nice for avoiding this.
20:19:55 <HWSOD> avoiding what? broadcasting your password?
20:20:36 <glguy> aliases are nice for that
20:20:46 <glguy> actually, if you specify a server password
20:20:53 <glguy> nickserv will use it to authenticate you
20:21:13 <glguy> so you can be identified from the get go
20:21:20 --- mode: glguy set -o glguy
20:22:31 <desp> does anyone have any tips for minimizing ram usage?
20:22:38 <glguy> don't use X
20:23:23 <desp> hh
20:23:24 <desp> ikell program ;p
20:23:32 <desp> in my haskell program ;p
20:23:39 <Olathe> HWSOD: Yes.
20:24:29 <HWSOD> whats a server password?
20:25:01 <Olathe> A password needed when you connect to certain servers.
20:25:54 <HWSOD> hum il have to read up on that.
20:32:42 * glguy is glad that Dell saw fit to include that systray icon that tells me when and where my finger is on the touchpad
20:32:49 <glguy> imagine how lost I
20:32:53 <glguy> could have been without it
20:33:38 <dons> heh
20:34:30 <glen_quagmire> did you read icfp Endo.pdf?
20:34:38 <glen_quagmire> sumerize it for me
20:34:43 <glen_quagmire> hah i'm a bastard
20:35:11 <HWSOD> im working on that too!
20:35:19 <glen_quagmire> i think there is a clue in that name Endo and Arrow
20:35:54 <glen_quagmire> i think all you have to do is to come up with a sequence [ICPF]+
20:36:18 <hpaste>  desp pasted "findSubstringEnd" at http://hpaste.org/1804
20:37:51 <glguy> no telling what your question was, but that can be rewritten: liftM (S.length pat +) (findSubstring2 pat ctx)
20:44:10 <Korollary> I shot Endo.
20:45:39 <Korollary> I decided that his miserable life was not worth sucking the little power Arrow has left.
20:46:21 <glen_quagmire> his dna was 7mb
20:46:25 <HWSOD> is there a way to combine the state monad with a propagating error.  i.e. keep doing state ops untell one results in an error then stop returning the error?
20:47:54 <HWSOD> i should have said then stop and return the error.
20:48:42 <SamB> HWSOD: ErrorT
20:49:25 <dolio> > runState (runErrorT (put 3 >> put 4 >> throwError "Oh no!" >> put 5)) 1
20:49:27 <lambdabot>  (Left "Oh no!",4)
20:54:18 <HWSOD> awsome! Im trying to implement the simulation for the Endo problem.
20:56:44 <glen_quagmire> I'm just doing cat endo.dna | sort | cut ....
20:58:11 <SamB> glen_quagmire: isn't endo.dna a single line?
20:59:28 <glen_quagmire> oh crap
20:59:38 <glen_quagmire> endo will not survive for sure
21:11:43 <sm> lol
21:22:03 <newsham> which version ghci has debugging built in?
21:29:53 <dons> newsham: ghc head
21:31:10 <HWSOD> what kind of debugging is in there?
21:34:41 <brad_> although it is trivial to code up myself, i was wondering if any of the standard libs had a "dos2unix" function (or workalike)
21:36:44 <brad_> the room is oddly silent...
21:37:02 <dons> icfp contest is on this weekend
21:37:13 <dons> i don't know of a dos2unix, but it sounds like filter :)
21:37:24 <SamB> dons: not exactly
21:37:44 <SamB> I guess filter works okay though
21:37:54 <SamB> if you have well-formed input...
21:38:13 <SamB> it turns "foo\r\nbar" into "foo\nbar"
21:38:23 <brad_> yes dons agreed, so far i have been using Data.String's replace
21:38:36 <brad_> SamB - that would be the desired output, right?
21:39:02 <SamB> the first string is input, the second one is output
21:39:16 <Saizan> uhm, what's the third argument to runGetState? runGetState :: Get a -> ByteString -> Int64 -> (a, ByteString, Int64)
21:39:40 <SamB> the, uh, state?
21:39:52 <Saizan> Int64?
21:40:23 <brad_> thanks for the hints guys, bye
21:41:49 <desp> when am I supposed to use $!?
21:41:55 <desp> @type ($!)
21:41:57 <lambdabot> forall a b. (a -> b) -> a -> b
21:42:02 <desp> @hoogle ($!)
21:42:02 <lambdabot> Did you mean: ($!)
21:42:02 <lambdabot> Prelude.undefined :: a
21:42:02 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
21:42:20 <glguy> desp: when you want to evaluate an argument before passing it to a function
21:42:22 <newsham> any recommendations for finding stack overflows in ghc 6.6.2?
21:42:33 <glguy> f $! x = seq x (f x)
21:42:57 <iskaldur_> having some trouble...i'm trying to do: data Foo = Bar, data Foobar = [Foo]
21:43:01 <iskaldur_> why doesn't this work?
21:43:11 <desp> and when do I want to use "bang paths"?
21:43:27 <glguy> 6.6.2?
21:44:31 <iskaldur_> whoops, nevermind
21:45:28 <desp> bang paths?
21:45:57 <glguy> are you asking yourself what you mean?
21:46:21 <desp> I have no idea what this term means
21:46:25 <TSC> Do you mean bang pattern?
21:46:30 <desp> right.
21:46:32 <desp> patterns.
21:46:39 <desp> I've been hacking for 19h now ;)
21:46:52 <desp> dons gave me a few snippets that use tem
21:46:55 <desp> them*
21:46:59 <desp> but I have no idea what they do
21:47:01 <msouth> #haskell, where they'll READ YOUR MIND and answer the question you meant to ask!
21:47:04 <TSC> They're used to force the evaluation of a function's argument, from the callee's side
21:47:04 <msouth> :)
21:47:14 <desp> ah
21:47:30 <TSC> Just another convenience for forcing evaluation
21:47:46 <desp> I find forcing evaluation to be highly inconvenient
21:48:04 <TSC> Yes, that's why there are lots of "convenient" ways to do it (:
21:48:09 <desp> has anyone written a tutorial for dealing with all this pesky laziness?
21:48:16 <desp> I can't get my head around it
21:48:21 <TSC> There are a few pages on the wiki about it
21:48:28 <TSC> I found it very difficult to understand at first
21:48:39 <TSC> I think I am slowly getting it
21:48:45 <|Steve|> Call by name is tricky?
21:48:46 <desp> msouth++
21:48:52 <mornfall> why would anyone force evaluation?
21:49:08 <iskaldur_> question: I'm trying to do   data A = C; data Bar = A | B; type Foo = [Bar]; fun :: Foo -> Foo, fun x = x ++ [C]
21:49:17 <TSC> I didn't learn it properly until I had a program that simply ran out of space, and I had to figure it out or I was stuffed
21:49:26 <desp> yes, that's the point I'm at
21:49:27 <desp> :)
21:49:29 <iskaldur_> and i get an "couldn't match expected type Bar against inferred type A" error
21:49:38 <iskaldur_> how do i fix this?
21:49:47 <TSC> desp: I found GHC's space profiling pretty useful
21:49:53 <desp> indeed, it is
21:51:07 <TSC> iskaldur_: The "A" in "data Bar = A | B" is not the same "A" as "data A = C"
21:51:38 <iskaldur_> tsc: yeah, that's what i was thinking...what can i do to fix it?
21:52:16 <TSC> Maybe your Bar type can be replaced by the standard "Either" type?
21:52:58 <TSC> @type [Left "string", Right 10]
21:53:07 <lambdabot> forall b. (Num b) => [Either [Char] b]
21:53:35 <dons> http://programming.reddit.com/info/287k9/comments
21:53:36 <lambdabot> Title: Peano&#39;s Axioms Part III: Haskell&#39;s Polymorphism at Work (reddit.com)
21:53:37 <iskaldur_> in my actual code, it's more like data Bar = A | B | D | E | F =\, so i don't think i can use an either type (?)
21:54:00 <brad_> i am having a cabal build issue: Could not find module `Data.Time.Format': it is a member of package time-1.1.1, which is hidden. BUT ghc-pkg describe time has "exposed: True"....?
21:54:51 <brad_> and of course the package indeed works after installing it
21:55:08 <brad_> not sure why cabal continues to tell me "time" is not exposed
21:55:50 <TSC> iskaldur_: Try "data Bar = A A | ..."
21:56:04 <TSC> Then "fun x = x ++ [ A C ]"
21:56:17 <TSC> (Then think of some better names)
21:56:53 <dons> brad_: could be time-1.1.1 is hidden though
21:56:54 <iskaldur_> =)
21:57:06 <dons> try exposing it manually (ghc-pkg expose time)
21:58:23 <brad_> i have done this: sudo ghc-pkg expose time, and also sudo ghc-pkg expose time-1.1.1, the problem remains
21:58:34 <iskaldur_> got it, thanks!
21:58:53 <brad_> i wonder if having cabal for ghc-6.6 AND ghc-6.6.1 is creating conflicts?
21:59:06 <brad_> meaning i had a ghc-6.6 prior to installing 6.6.1...
22:01:19 <TSC> iskaldur_: You're welcome
22:12:18 <desp> wish me luck
22:12:31 <desp> time to test lazy bytestrings with length caching
22:12:44 * msouth holds breath
22:12:59 <desp> don't do that :)
22:13:10 <desp> hrm
22:13:13 <desp> still appears to be slow
22:13:36 <desp> I'm probably not evaluating things enoug
22:16:28 <hpaste>  desp pasted "evil" at http://hpaste.org/1805
22:16:43 <desp> does anyone see some obvious evil in that function?
22:17:55 <hpaste>  desp annotated "evil" with "used functions" at http://hpaste.org/1805#a1
22:18:40 <desp> matchReplace' is using up 80+% of both %time and %alloc
22:19:14 <desp> not inherited from the functions used
22:19:31 <desp> wait...no. it is inherited...
22:20:01 <desp> hrm
22:20:06 <jedai> @src unfoldr
22:20:06 <lambdabot> unfoldr f b  = case f b of
22:20:06 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
22:20:06 <lambdabot>    Nothing        -> []
22:20:16 <dons> i'd use ! on the 'i' parameter
22:29:20 <HWSOD> @src runState
22:29:21 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
22:29:27 <HWSOD> @src runstate
22:29:27 <lambdabot> Source not found. My mind is going. I can feel it.
22:34:55 <sm> a simple one.. how do I wait for a keypress ?
22:35:24 <dons> getChar ?
22:38:32 <dynamix> Cale: hi
22:41:02 <dynamix> i somehow lost it again..  (  (. f) . g ) == ?
22:41:24 <dynamix> ( (. f) g ) should be f . g
22:41:30 <dynamix> but what is it with two dots?
22:41:37 <sm> thank you dons
22:43:19 <dolio> ((. f) . g) x ==> (. f) (g x) ==> (g x . f)
22:47:33 <dynamix> thats why its confusing.. there are two params
22:47:49 <dynamix> ( ( . (:[]) ) . (:)  )a b
22:48:12 <dynamix> lets say f = ( :[])
22:48:16 <iskaldur_> hmm...so i have: data Letter = A | B | C. since data Foo = Letter | Foof doesn't work, i have data Foo = Letter Letter | Foof
22:48:17 <dynamix> g = (:)
22:48:36 <iskaldur_> now how do I do data Bar = Letter | Barb? (data Bar = Letter Letter Letter | Barb doesn't work...)
22:48:53 <iskaldur_> and why exactly does data Foo = Letter Letter | Foof work?
22:48:57 <iskaldur_> tsc: still there? :)
22:48:59 <timthelion> is there a specific data type that holds the sub trees, and the children separate? like >data DatedPatchTree = DatedPatchTree FilePath [DatedPatchTree] [DatedPatch] I've made this a [b] [c] type 3 times in the project I'm doing.
22:49:15 <timthelion> for different trees.
22:49:42 <dynamix> and (:) doesnt take two a s it takes an a and a [a]
22:50:22 <scook0> iskaldur_: wait, what exactly are you trying to do?
22:50:29 <Saizan> iskaldur_: data Foo = Letter | .. creates a nullary constructor named Letter of type Foo
22:51:11 <dynamix> ( ( . f) . g ) x y ==>  ( . f) ( g x y) ==> ( g x y). f ?
22:51:11 <Saizan> iskaldur_: instead data Foo = Letter Letter | .. makes a constructor named Letter of type Letter -> Foo
22:51:27 <dons> ?unpl (  (. f) . g )
22:51:28 <lambdabot> (\ d i -> g d (f i))
22:51:28 <dynamix> ( ( . f) . g ) x y ==>  ( . f) ( g x y) ==>  g x y . f ?
22:51:34 <scook0> iskaldur_: i.e. the two occurrences of "Letter" have different meanings
22:51:55 <dons> \x y -> g x (f y)
22:52:01 <dolio> ((. (:[])) . (:)) x y ==> ((x:) . (:[])) y ==> (x:) ((:[]) y) ==> (x:) (y:[]) ==> x:y:[]
22:52:04 <Saizan> iskaldur_: also, we have 2 distrinct namespaces, one for types and one for functions, so you can have one Letter type and one Letter constructor, but they are not necessarily related
22:53:02 <iskaldur_> saizan: i think i see. not well enough to know how to do the data Bar = Letter | Barb, though
22:53:19 <Saizan> iskaldur_: data Bar = Letter doesn't work because there's yet a constructor named Letter for Foo, you can't reuse that name in the same module
22:53:43 <Saizan> iskaldur_: data Bar = LetterB Letter | Barb
22:54:28 <scook0> iskaldur_: is "Barb" supposed to be a type, or a constructor with no arguments?
22:54:37 <iskaldur_> scook0: i guess an analogy is...a fish can be a goldfish or a salmon-- data Fish = Goldfish | Salmon...but an animal can be a fish: data Animal = Fish | Dog...but a piece of food can also be a fish...data Food = Fish | Fried Chicken
22:55:07 <Saizan> iskaldur_: you're mixing types and data constructors
22:55:08 <iskaldur_> scook0: barb is supposed to be a constructor with no arguments
22:55:18 <iskaldur_> saizan: ah, i thought i tried that letterb thing
22:55:47 <iskaldur_> saizan: yeah, i think i only just realized the difference :)
22:55:55 <iskaldur_> (sort of)
22:56:15 <Saizan> iskaldur_: if you define data Animal = Fish | Dog you're defining a value Fish of type Animal, in no way related to the type Fish
22:56:45 <dynamix> dolio: is that becasue the (:) takes only one argument ?
22:56:46 <Saizan> iskaldur_: in a data declaration the first identifier of each alternative is the data constructor
22:57:23 <scook0> and if you try data Animal = Fish | Dog and data Food = Fish | FriedChicken, you'll get an error
22:57:34 <dynamix> im missing soemthing. (:) takes two args right., why did it leave y alone, instead of complaining that it is not a list?
22:57:48 <dolio> (:) takes two arguments, but the way the (.)s put them together shuffles things around.
22:57:57 <scook0> because you've declared two different constructors with the same name (Fish and Fish)
22:58:09 <dolio> I'm going to use return instead of (:[])
22:58:46 <dolio> ((. return) . (:)) x y ==> (((. return) . (:)) x) y
22:59:01 <dynamix> no, actually some one helped me in the morning to figure out that (:[]) is the same as return, and i understand how that can be arrived at
22:59:03 <dolio> So reduce the part with x to see what you get to apply with y.
22:59:34 <scook0> dolio: ah, but (:[]) makes a great emoticon!
23:00:09 <dolio> In the one with f and g, it became (g x . f), where g == (:) and f == return.
23:00:30 <dolio> So in this example, it's ((x:) . return), which you then apply to y.
23:01:00 <dynamix> ah , so when ever there is a functino with two args,  does it make a function with the first arg and apply that to the second?
23:01:08 <dynamix> currying at work?
23:01:26 <dynamix> f a b ==> (f a) b
23:01:27 <dolio> That's the idea, yeah.
23:01:47 <dynamix> now its clear as water, as opposed to mud :)
23:01:53 <dolio> :)
23:02:49 <dynamix> why would one want to use this version as opposed to a lambda which is so much easier to udnerstand :)
23:03:05 <dynamix> \x y -> [x,y]
23:05:30 <iskaldur_> saizan, scook0: thanks for the help :) one more step in understanding haskell
23:06:05 <dolio> dynamix: They probably wouldn't.
23:06:48 <dynamix> some one did today morning
23:06:52 <dynamix> or so i thought,
23:07:12 <brad_> lets say i have a function f, taking args a b c like f a b c. now lets say i have a list l = [a,b,c]. is there an easy way to call f with l, somehow having the list elements mapped to the function args?
23:07:29 <dolio> Well, if you like being all point-free, then the lambda isn't an option.
23:07:47 <dynamix> some one asked a question,  how to get a list of all the elements given a list of tuples.
23:07:50 <dynamix> my solution was
23:08:02 <dynamix>  concat $ map (\(a,b)->[a,b]) $ zip [1..10] [11..20]
23:08:23 <dynamix> ofcourse i didnt post it as some one  had already posted one,
23:08:31 <brad_> dolio - sounds like there is no easy way?
23:08:42 <dolio> > length "((.(:[])).(:))"
23:08:44 <lambdabot>  14
23:09:00 <dolio> > length "(\x y->[x,y])"
23:09:00 <lambdabot>  Illegal escape sequence
23:09:05 <dolio> > length "(\\x y->[x,y])"
23:09:06 <lambdabot>  13
23:09:08 <dynamix> 15
23:09:13 <dolio> Yeah, it doesn't even win at golf.
23:10:00 <brad_> well thanks anyway!
23:10:47 <dynamix> then i saw this gem :)  concatMap ( uncurry ((. return) . (:)) ) $ zip [1..10] [11..20]
23:11:06 <dynamix> thank god i was not driving most of the day after i saw this :)
23:11:56 <dynamix> why would one want to be pointfree ? is there any reason one would want to be? the tutorial have yaht, doesnt give a reason, just tells what it is
23:12:00 <jedai> brad_: You can probably do it with ap ?
23:13:22 <Korollary> dynamix: It's mostly personal stylistic preference.
23:14:27 <dynamix> just style?  :) thank god thats the only thing..
23:14:57 <dolio> > let f a b c = (a,b,c) in foldl ($) f [1,2,3]
23:14:57 <lambdabot>      Occurs check: cannot construct the infinite type: b = a -> b
23:14:58 <lambdabot>     Probabl...
23:15:43 <Korollary> dynamix: Nobody really writes in that style primarily. Sometimes you'll see that you can do it, and will do it because it's less typing.
23:16:59 <Korollary> Especially when you can eliminate a stupid temporary variable.
23:17:13 <dynamix> :) thanks
23:17:14 <Korollary> A variable has to have a good name and sometimes that name is just too long. Heh.
23:18:19 <Korollary> I see that Endo's survival chance > 0% now.
23:22:08 <jedai> dynamix: I like point-free because it can make the intention clearer (in simple cases, not ugly hackery like "concatMap ( uncurry ((. return) . (:)) )"... o_O ).
23:23:14 <jedai> dynamix: It's easier to see how a function work when you expose it as a stack of "filters".
23:23:22 <dynamix> Korollary: are you taking part in the contest ?
23:24:31 <dynamix> yeah some times, thats true, unfortunately this is the first time i saw some one use that outside the only tutorial today in that example
23:25:01 <Korollary> dynamix: I am just an observer.
23:25:21 <dons> it will be interesting to see how all the string/dna munging goes in haskell
23:25:50 <Korollary> dons: yet another icfp with a destructive interpreter eh?
23:25:56 <dynamix> are only " functional " languages allowed? or python , ruby too ?
23:26:01 <dons> well, lots of bytes being copied around
23:26:04 <dons> dynamix: any language
23:26:19 <dons> just functional ones seem to win, something to do with bugs and rapid prototyping and speed , i suspect
23:26:27 <Binkley> dynamix: you don't even have to use a computer :-)
23:26:38 <dons> Korollary: it seems moderately well suited for bytestrings, at least.
23:26:52 <dons> and the haskell teams so far are doing well. i think we've still got 2 teams in the top 20
23:27:04 <Korollary> dons: It's very early anyway
23:27:22 <dons> yes, that's true. not even 1/3rd in
23:27:42 <dons> i'd like to know who ` PurelyFunctionalInfrastructure' is.
23:27:53 <Korollary> I actually don't see why you would submit something till the last minute.
23:28:06 <dons> incremental points are good for moral
23:28:07 <dons> e
23:28:24 <Korollary> your own? You already know how well your result does, don't you?
23:28:48 <dons> probably not till you submit, and get points
23:29:14 <Korollary> Can you not run exec . build and diff the resulting image yourself to compute your own score?
23:29:16 <dons> so we might want to do an analysis after of how well the bytestring and binary stuff faired.
23:29:37 <Korollary> s/./
23:29:39 <Korollary> er
23:29:40 <dons> fared. there's at least some issues with Data.Binary filling lazy bytestrings, that people then want to copy to a strict one.
23:29:42 <Korollary> s/./|
23:29:46 <Thomas2> you're right, incremental points would be good for morale :-)
23:30:17 <dons> so a strict/growing Data.Binary interface might be more efficient for some purpooses
23:30:35 <dons> Thomas2: is there a nicta team?
23:30:42 <dons> i know seafood was looking to compete this year
23:31:05 <Thomas2> dons: yeah, myself, seafood, harvey and 2 others
23:31:11 <dons> cool. what's the team name?
23:31:16 <seafoodX> Synictactic
23:31:22 <Thomas2> ahr, there you are
23:31:29 <seafoodX> (It has NICTA in the middle)
23:31:32 <dons> seafoodX: ocaml or haskell? :)
23:31:37 <seafoodX> OCaml at the mo
23:31:38 <Thomas2> don't ask :-)
23:31:40 <dynamix> must be difficult to compete without a way to locally verify the health of the solution :)
23:31:49 <dons> boo
23:32:19 <seafoodX> dons: I only did it because the Haskell version was taken.
23:32:26 <seafoodX> But then blackdog gave up it seems.
23:32:30 <dons> oh.
23:32:35 <seafoodX> I really WANTED to use Data.ByteString.
23:32:36 <seafoodX> :(
23:32:52 <dons> yeah, at least two teams are doing well so far with bytestrings
23:32:58 <dons> though we do need KMP findSubstring
23:33:10 <seafoodX> True :)
23:33:10 <dons> bytestrings and Data.Binary
23:33:17 <Binkley> dons: there's a Haskell KMP on Oleg's web page
23:33:20 <Binkley> very easy to adapt it to ByteString
23:33:23 <Binkley> that's what I did, anyway
23:33:32 <dons> Binkley: yeah, we've got one in Data.ByteString already, just badly done
23:34:07 <Binkley> dons: ah, not in the version of Data.ByteString in 6.6, i guess
23:34:12 <dons> my naive loop version tends to be pretty fast, fwiw, (its better than the bad KMP in bytestring already), http://hpaste.org/1803
23:34:17 <Binkley> (I don't dare use the HEAD for the ICFP contest :-)
23:34:21 <dons> Binkley: yeah, that one. its just bad.
23:34:29 <dons> i think bjorn never benchmarked it
23:34:39 <dons> since the naive loop above is oh 10x faster anyway
23:34:42 <Binkley> dons: really? what's it called?
23:34:55 <dons> findSubstring
23:35:06 <dons> :t Data.ByteString.findSubstring
23:35:08 <lambdabot> Data.ByteString.Base.ByteString -> Data.ByteString.Base.ByteString -> Maybe Int
23:35:09 <dons> not for lazy bytestrings though
23:35:21 <Binkley> Ah, that explains it
23:35:24 <Binkley> I'm using lazy bytestrings
23:35:37 <dons> things going ok?
23:36:05 <hpaste>  dons annotated "faster findSubstring?" with "naive findSubstring for lazy bytestrings" at http://hpaste.org/1803#a1
23:36:20 <Binkley> things are going pretty well
23:36:25 <Binkley> we're in 22nd place! :-D
23:36:30 <dons> woot!
23:36:39 <dons>  Team PDX yaya!
23:37:18 <dons> cool, that's 4 teams in the top 30 or so then. `The Church of the Least Fixed Point', `Team PDX', `LazyBottoms' and `PurelyFunctionalInfrastructure'
23:37:26 <dons> go #haskell
23:37:53 <desp> uh... StrictSeq.hs:70:59: Not in scope: `!'
23:37:56 <desp> wth?
23:37:59 <dons> -fbang-patterns
23:38:00 <dons> ?
23:38:08 <desp> {-# OPTIONS -fbang-patterns #-}
23:39:17 <AdamantX> omg, did dons just quote Little Jon?
23:40:39 <Glimi> AdamantX, WHAT?
23:41:18 <desp> doh
23:41:25 <desp> there was a spurious !
23:41:31 <desp> too tired %)
23:42:28 <dons> oh, `augustss' is entering too.
23:42:50 <dons> `tnt' is another #haskell team
23:43:40 * glguy determines that the channel is speaking nonsense
23:45:09 <Korollary> unpossible
23:45:31 <desp> is inlining impossible across modules?
23:46:02 <dons> no, with enough {-# INLINE foo #-] and -O2 it will inline fine
23:46:10 <dons> (as long as the inlined function isn't recursive, they never inline, iirc0
23:46:33 <glguy> inlining a recursive function would fall under "unrolling" ?
23:46:41 <desp> :D
23:47:32 <dons> glguy: yeah, things like foldlr will happily inline around their argument
23:47:44 <andyjgill> glguy: GHC turns recursive functions to non-recursive functions, with local recursion, so that inlineing works
23:47:57 <desp> dons: put !s = forM_ [0..(S.length s - 1)] $ \n -> P.put (B.unsafeIndex s n)
23:48:04 * glguy shouldn't ask silly questions with coworkers around :)
23:48:04 <desp> this appears to be incredibly slow
23:48:08 <dons> desp, it looks slow
23:48:17 <dons> you're doing a lot of bounds checks there, one per element
23:48:22 <dons> when really you just want to memcpy
23:48:31 <desp> er
23:48:47 <desp> where am I doing bound checks?
23:48:52 <dons> `put'
23:49:16 <desp> ahrg
23:49:19 <dons> i wouldn't do it that way. have you confirmed anyway if small chunks is the issue ?
23:49:42 <dons> andyjgill: do you know if team `PurelyFunctionalInfrastructure' is Isaac?
23:49:43 <desp> so putWord8 doesn't do bound checks?
23:50:11 <dons> desp, it has to.
23:50:32 <dons> desp, how big is that 's' ?
23:50:47 <andyjgill> I dont think so. When I asked isaac if he wanted to join a team last year, he told me that programming contests are for high school.
23:50:53 <andyjgill> but it might be.
23:50:53 <dons> heh
23:51:07 <glguy> Is anyone from Galois participating?
23:51:31 <dons> i wonder who `Side Effects May Include...' is
23:51:54 <dons> i tried to collect the teams i suspect to be haskell / #haskell teams here, http://haskell.org/haskellwiki/ICFP_Programming_Contest/Teams_2007
23:51:57 <lambdabot> Title: ICFP Programming Contest/Teams 2007 - HaskellWiki, http://tinyurl.com/3dx5mv
23:52:12 <andyjgill> Not that I know of.
23:52:36 <Binkley> Well, Darin M. is on our team :-)
23:53:00 <glguy> if you have a team... what are you doing chatting in here?!
23:53:11 <Korollary> slacking?
23:53:15 <Binkley> I'm waiting for my code to finish running
23:53:16 <Binkley> It's slow
23:53:20 <desp> heh
23:53:23 <desp> tell me about it
23:53:25 <Binkley> and we're working on separate pieces
23:53:25 <dons> desp, so remember, that putLazyByteString and friends don't do any copying, they're O(1)
23:53:33 <desp> dons: right
23:53:46 <dons> so doing that a lot will be fine. *but* then you do this converting back to strict bytestrings, which involves allocating a large array, and copying all the chunks into it
23:53:51 <dons> so there's a tension
23:54:02 <dons> Binkley I think said they're using only lazy bytestrings.
23:54:09 <dons> but then again, desp's team is ranked higher :)
23:54:20 <desp> I have right now two implementations
23:54:23 <desp> one uses lazy strings
23:54:26 <desp> one uses strict strings
23:54:35 <desp> and the strict strings actually manages to finish
23:54:39 <desp> running the self check
23:54:44 <Binkley> dons: what operations would cause the converting to strict strings to happen?
23:54:52 <dons> toChunks
23:55:06 <dons> you'd explicitly decide to copy, flatten and then work with strict bytestrings
23:55:09 <desp> dons: I asked before -- would it be okay for me to call toChunks and make the strict string myself?
23:55:10 <glguy> the contest is "just" to write a prefix that turns the dna into instructions to modify the image?
23:55:17 <dons> if you weren't planning on doing any furthe concats/appends/cons
23:55:25 <desp> dons: or wouldn't it be any better than just calling concat?
23:55:37 <dons> well, that'd just be concat you'd be writing
23:55:41 <desp> Binkley: 30 seconds for self-check on a 1.42 PPC G4
23:56:13 <desp> dons: but the problem with concat is that it's using a ton of memory
23:56:14 <dons> desp, i doubt you can beat concat easily,
23:56:15 <Binkley> hmm, that's a lot faster than my code :-D
23:56:15 <dons>         go []            _   = return ()
23:56:15 <dons>         go (PS p s l:ps) ptr = do
23:56:15 <dons>                 withForeignPtr p $ \fp -> memcpy ptr (fp `plusPtr` s) (fromIntegral l)
23:56:18 <dons>                 go ps (ptr `plusPtr` l)
23:56:29 <desp> but it uses 200 MB of RAM!
23:56:41 <dons> right, you're *copying* the strings each time you do 'concat'
23:56:41 <Binkley> my code uses 500 MB of RAM!
23:56:45 <desp> lol
23:56:54 <dons> we really need kzm on someone's team
23:56:57 <Binkley> Well, ok, I may have fixed that
23:57:00 <dons> with his DNA hacking skillz
23:57:19 <Binkley> I was using lists in one particular place and ByteStrings everywhere else. Switching to ByteStrings everywhere cut down on RAM a ton
23:57:37 <desp> I'm coming to the sad conclusion that I'm going to rewrite it in C++
23:57:37 <dons> desp, so the only optimisation i can think of would be, before you 'put' a bunch of things, to allocate a single strict bytestrings, and fill it directly
23:57:48 <dons> desp, what data structures would change though?
23:57:49 <desp> right
23:57:59 <dons> i can't see how C++ has any advantage here: memcpy is memcpy
23:58:05 <desp> dons: well, I'll probably kill myself trying to emulate abstract data types
23:58:10 <desp> ;p
23:58:31 <dons> so, to allocate and fill a bytestring (avoiding Data.Binary), you'd use unfoldr/unfoldrN or create
23:58:59 <Thomas2> I have to say, it's remarkable how C-leaning the part I implemented was
23:59:02 <dons> maybe you're just supposed to use a better data structure though :)  a trie or something.
23:59:25 <dons> Thomas2: in terms of low level loops, buffer copying and such?
23:59:26 <Thomas2> (RNA->image, lots of arrays, lots of state, fixed storage needed at any point, simple algorithms)
23:59:31 <dons> yeah
23:59:45 <dons> fixed storage is a hint to use strict bytestrings too
23:59:52 <dons> since you can then use:  create n $ \p -> fill p
23:59:54 <desp> yeah, we have that part written in C++ already
23:59:58 <desp> it works fine
