00:05:45 <blackdog_> hey, any HAppS hackers around? i'm getting some weird problems with the Hello.hs example - if i refresh it a couple of times it hangs...
00:08:29 <collinge> hello thorkilnaur we met at hac07 (I'm really Dominic Steinitz)
00:36:17 <wli> Kind of quiet here this time of night.
00:36:20 <dons> ?yow!
00:36:20 <lambdabot> I'm also against BODY-SURFING!!
00:37:34 <Choko_> it's 9:36 am :P
00:39:34 <arcatan> no, it's 10:39 am
00:40:36 <dons> ?time
00:40:40 <lambdabot> Local time for dons is Sun Jul  8 17:40:08 2007
00:40:46 <dons> no, its 5.40pm, clearly
00:41:06 <dons> ?time lambdabot
00:41:07 <lambdabot> I live on the internet, do you expect me to have a local time?
00:58:18 <dons> ?users
00:58:19 <lambdabot> Maximum users seen in #haskell: 354, currently: 303 (85.6%), active: 7 (2.3%)
00:58:31 <DRMacIver> Morning
00:58:43 <wli> re DRMacIver
01:10:19 <pjd> :t let filter' p = (>>= \x -> if p x then [x] else []) in filter' even [1..5]
01:10:22 <lambdabot> forall a. (Integral a) => [a]
01:10:30 <pjd> err
01:10:34 <pjd> :t let filter' p = (>>= \x -> if p x then [x] else []) in filter'
01:10:38 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
01:10:48 <pjd> > let filter' p = (>>= \x -> if p x then [x] else []) in filter' even [1..5]
01:10:50 <lambdabot>  [2,4]
01:11:19 <pjd> the niftiness of monads know no bounds
01:11:41 <pjd> :t let filter' p = (>>= \x -> if p x then return x else mzero) in filter'
01:11:43 <lambdabot> forall a (m :: * -> *). (MonadPlus m) => (a -> Bool) -> m a -> m a
01:12:42 <pjd> > let filter' p = (>>= \x -> if p x then return x else mzero) in filter' even (Just 1)
01:12:44 <lambdabot>  Nothing
01:12:46 <pjd> > let filter' p = (>>= \x -> if p x then return x else mzero) in filter' even (Just 2)
01:12:48 <lambdabot>  Just 2
01:12:50 <pjd> woo!
01:15:16 <dons> hey pjd
01:15:23 * pjd waves
01:20:26 <pjd> :t let filter' p = (>>= \x -> if p x then pure x else empty) in filter'
01:20:30 <lambdabot>     Ambiguous occurrence `pure'
01:20:30 <lambdabot>     It could refer to either `pure', imported from Control.Applicative
01:20:53 <pjd> :t let filter' p = (>>= \x -> if p x then (pure :: Control.Applicative) x else empty) in filter'
01:20:57 <lambdabot> Couldn't find qualified module.
01:21:11 <pjd> :t let filter' p = (>>= \x -> if p x then (pure :: Control.Applicative.pure) x else empty) in filter'
01:21:14 <lambdabot> parse error on input `Control.Applicative.pure'
01:21:31 <pjd> :t let filter' p = (>>= \x -> if p x then Control.Applicative.pure x else empty) in filter'
01:21:33 <lambdabot>     Ambiguous occurrence `empty'
01:21:33 <lambdabot>     It could refer to either `empty', imported from Control.Applicative
01:21:42 <pjd> :t let filter' p = (>>= \x -> if p x then Control.Applicative.pure x else Control.Applicative.empty) in filter'
01:21:46 <lambdabot> forall a (m :: * -> *). (Alternative m, Monad m) => (a -> Bool) -> m a -> m a
01:22:21 <pjd> yay
01:26:39 <pjd> anyone know where i can read more about this?
01:30:13 <dons> about applicative functors?
01:30:37 <dons> there's a great paper: http://www.soi.city.ac.uk/~ross/papers/Applicative.pdf
01:31:01 <pjd> about generalizing filter to monoidal monads, i guess
01:31:20 <pjd> (is that the right wording?)
01:33:37 <collinge> I don't think so. applicative functors aren't necessarily monads
01:34:54 <pjd> well, that was using Alternative and Monad
01:35:08 <pjd> which seems to be roughly equivalent to MonadPlus
01:37:23 <glguy> Applicative Functors provide a subset of Monad's functionality
01:37:33 <crazy_code2> hello everyone
01:37:33 <glguy> the results of the sequenced computations can't rely on each other
01:38:26 <edwardk> @type Control.Applicative.pure
01:38:27 <crazy_code2> Can we have something like data X = Y | Z deriving (Eq,Show)
01:38:31 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
01:38:37 <edwardk> oh, duh
01:38:38 <crazy_code2>                                                                                                          where
01:38:44 <crazy_code2> Oh Sorry
01:39:05 <crazy_code2> I meant to say we use deriving (Eq,Show) and after that where ..........
01:39:17 <edwardk> :t let filter' p = (>>= \x -> if p x then return x else mempty) in filter'
01:39:21 <lambdabot> forall a (m :: * -> *). (Monoid (m a), Monad m) => (a -> Bool) -> m a -> m a
01:39:53 <edwardk> > let filter' p = (>>= \x -> if p x then return x else mempty) in filter' (>= 3) (Just 1)
01:39:55 <lambdabot>   add an instance declaration for (Monoid (Maybe a))
01:39:55 <lambdabot>     In the expression:
01:39:55 <lambdabot>  ...
01:40:03 <edwardk> gah
01:40:28 <edwardk> > let filter' p = (>>= \x -> if p x then return x else mempty) in filter' (>= 3) [1,3,5]
01:40:31 <lambdabot>  [3,5]
01:40:56 <crazy_code2> data AbstractInteger = Zero | Succ AbstractInteger | Pred AbstractInteger deriving (Eq,Show)
01:40:56 <crazy_code2> 		where
01:40:56 <crazy_code2> 			Succ :: AbstractInteger -> AbstractInteger
01:40:56 <crazy_code2> 			Pred :: AbstractInteger -> AbstractInteger
01:41:08 <crazy_code2> I am getting parse error at where
01:41:19 <dolio> > let filter' p = (>>= \x -> if p x then return x else mzero) in filter' (>= 3) (Just 1)
01:41:21 <lambdabot>  Nothing
01:41:57 <Lemmih> crazy_code2: Why do you want the 'where' and the type signatures?
01:42:06 <collinge> crazy_code2: paste your code
01:42:27 <edwardk> dolio: thats what i meant, thanks =)
01:42:31 <crazy_code2> This is my entire code ; i am writing a new type class
01:42:36 <edwardk> i just realized it as i was writing it up
01:42:43 <crazy_code2> * sorry new data type
01:42:49 <edwardk> @type let filter' p = (>>= \x -> if p x then return x else mzero) in filter'
01:42:53 <lambdabot> forall a (m :: * -> *). (MonadPlus m) => (a -> Bool) -> m a -> m a
01:42:57 <crazy_code2> Lemmih: I don;t require these ?
01:43:13 <Lemmih> crazy_code2: Nope.
01:43:15 <crazy_code2> type signatures I mean..
01:43:38 <Lemmih> crazy_code2: Remove all but the first line and you'll be fine.
01:43:40 <pjd> edwardk: interesting;  what's the relation between that and MonadPlus?
01:43:59 <edwardk> pjd: between filter and MonadPlus?
01:44:03 <crazy_code2> Lemmih: So what all can one write after where ..... ?
01:44:13 <opqdonut> :t mempty
01:44:15 <lambdabot> forall a. (Monoid a) => a
01:44:21 <opqdonut> ah, that's for a monoid
01:44:25 <Lemmih> crazy_code2: You can't write a 'where' in that location.
01:44:36 <edwardk> you use mzero, you either pass the value on or you 'stub it out' with mzero.
01:44:45 <dolio> > let guard' p = liftM2 (>>) (guard . p) return ; filter' p = (>>= guard') in filter' (>3) [1..5]
01:44:46 <lambdabot>  Couldn't match expected type `a -> a -> Bool'
01:44:57 <pjd> no, i mean your version with mempty instead of mzero, which puts it under (Monoid (m a), Monad m) instead of (MonadPlus m)
01:45:01 <crazy_code2> Lemmih: Where do I write all the methods for this data type ?
01:45:15 <edwardk> yeah, ideally Monoid and MonadPlus would just kind of merge =) aside from the fact that MonadPlus implies Monad
01:45:19 <dolio> > let guard' p = liftM2 (>>) (guard . p) return ; filter' p = (>>= guard' p) in filter' (>3) [1..5]
01:45:21 <lambdabot>  [4,5]
01:45:22 <crazy_code2> Lemmih:  I am confused
01:45:25 <Lemmih> crazy_code2: Methods are just normal functions.
01:45:35 <pjd> ah, ok, cool
01:46:10 <Lemmih> crazy_code2: data AbstractInteger = Zero | Succ AbstractInteger; isZero Zero = True; isZero _ = False
01:46:14 <pjd> so that's similar to Alternative versus Monoid + Functor?
01:46:23 <edwardk> pjd: MonadPlus m defines a Monoid over m a  forall a, using mempty = mzero, etc.
01:46:45 <edwardk> @src MonadPlus
01:46:45 <lambdabot> Source not found. My pet ferret can type better than you!
01:47:48 <edwardk> though you don't need a full MonadPlus, if there was a 'MonadZero' it would suffice, you only need an identity
01:48:01 <Lemmih> crazy_code2: What are you trying to achieve?
01:48:50 <collinge> @src concatMap
01:48:50 <lambdabot> concatMap f = foldr ((++) . f) []
01:49:01 <edwardk> pjd: yeah pretty much
01:49:08 <pjd> edwardk: in other words, Alternative?
01:49:22 <collinge> :t concat . map
01:49:26 <lambdabot>     Couldn't match expected type `[[a]]'
01:49:26 <lambdabot>            against inferred type `[a1] -> [b]'
01:49:38 <edwardk> pjd: i'm not a huge fan of the proliferation of these classes with the same meaning but different operator symbols ;)
01:49:39 <collinge> :t concat
01:49:43 <lambdabot> forall a. [[a]] -> [a]
01:49:46 <collinge> :t map
01:49:48 <pjd> heh, yeah
01:49:49 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
01:49:51 <pjd> hysterical raisins
01:50:04 <Orphi> :t Data.List.sort
01:50:08 <lambdabot> forall a. (Ord a) => [a] -> [a]
01:50:35 <Orphi> presumably Data.List.sort is a comparison sort? anybody know where I can find a radix sort?
01:50:38 <edwardk> map, fmap, liftM, liftW, (.), or  mappend, mplus, (+) ...
01:51:02 <pjd> :t let filter' p = (>>= \x -> if p x then pure x else mempty) in filter'
01:51:07 <lambdabot>     Ambiguous occurrence `pure'
01:51:07 <lambdabot>     It could refer to either `pure', imported from Control.Applicative
01:51:19 <pjd> :t let filter' p = (>>= \x -> if p x then Control.Applicative.pure x else mempty) in filter'
01:51:23 <lambdabot> forall a (m :: * -> *). (Applicative m, Monoid (m a), Monad m) => (a -> Bool) -> m a -> m a
01:51:47 <pjd> wooh
01:51:47 <wli> Orphi: Radix sorts need to know a bit about the data type's width. They can't really be polymorphic.
01:52:00 <edwardk> at that point in time Applicative is redundant
01:52:03 <edwardk> since pure is just return
01:52:06 <pjd> yeah
01:52:10 <pjd> but that makes me wonder
01:52:14 <edwardk> and Monoid (m a) should be MonadPlus
01:52:18 <Orphi> how about radixSort :: (Ord x) => [[x]] -> [[x]]?
01:52:24 <pjd> can you strip down Monad into something that just provides join?
01:52:41 <edwardk> you can use join and return to define a monad iirc
01:52:48 <pjd> right
01:53:00 <edwardk> or you mean a subclass of it that is just a join operator
01:53:34 <edwardk> class Joinable j where join :: j (j a) -> j a
01:53:36 <edwardk> ?
01:53:47 <wli> Orphi: You need to be able to divide by the radix, to know the radix, and to know in advance precisely how many times to divide.
01:54:00 <pjd> yeah
01:54:09 <Orphi> wli: right, OK.
01:54:16 <pjd> then you get mapping from Applicative, zero and append from Monoid, and join from that thing
01:54:24 <Orphi> wli: so there is no implementation of a radix sort already then?
01:55:04 <pjd> and you can then cleanly combine those base classes together to get Alternative, MonadPlus, and so on
01:55:14 <wli> Orphi: It's not clear to me that the width of Int is specified.
01:55:15 <pjd> or something like that :)
01:55:33 <edwardk> pjd: i'm just looking for minimal feature sets required for generic versions of things for my toy language, where i can cheat and make the dictionary polymorphic in the single parameter typeclass case anyways =)
01:55:34 <wli> Orphi: Things like Word32 would be usable for radixSort.
01:55:51 <Orphi> wli: I actually want to sort a list of [very large] strings...
01:56:12 <wli> Orphi: Not truly possible for strings.
01:56:24 <wli> Orphi: There's no bound on the number of digits.
01:56:46 <edwardk> i do like the observation that filter requires just return and 0 though
01:57:14 <Orphi> no, but you put all the strings that start with "a" in one bucket, all the strings that start with "b" in other bucket, etc.
01:57:28 <Orphi> keep recursing until you have buckets with single elements
01:57:33 <Orphi> join it all back up.
01:57:35 <Orphi> easy. :D
01:58:09 <pjd> edwardk: i stumbled about it more or less by accident
01:58:18 <edwardk> er wait, it needs a monad doesn't it, coz you use >>=
01:58:24 <pjd> yeah
01:58:43 <edwardk> so you need both return and bind, so 'MonadZero' or the equivalent would be minimal
01:58:48 <pjd> hence wondering about a generic class for join
01:59:07 <pjd> yeah
01:59:08 <edwardk> well, join and return together define a monad. so you get nothing more minimal there
01:59:21 <pjd> well, minimal in terms of decomposition
01:59:31 <pjd> into orthogonal base classes
01:59:32 <Orphi> anyway, apparently it appears not to be implemented already, so I'll have to do it myself...
02:00:39 <pjd> i assume there's something in category theory regarding this
02:01:23 <wli> Orphi: The analogue of radixsort for unbounded spaces (e.g. strings) is proxmapsort.
02:01:38 <edwardk> pjd: whereas i'm just trying to find minimal signatures for each type's axiomatic dictionary to have to support each { return : a -> m a; ... }
02:01:53 <collinge> Orphi: what the Monad class doesn't capture is the monad laws
02:02:21 <edwardk> though, i have different constraints on me
02:02:24 <collinge> Orphi: creating two classes is like defining 2 unrelated nat trnas
02:02:44 <collinge> oops trnas should have been trans
02:02:53 <pjd> edwardk: it's cool, regardless :)
02:03:32 <wli> Orphi: Basically you arithmetically encode the things or otherwise map them to floating point numbers and use a priori knowledge of the distribution of sorting key values to define intervals and so on.
02:03:36 <pjd> this was a very pleasant little learning experience
02:04:33 <wli> Orphi: If your strings are of bounded length, you can use radixsort.
02:05:42 <wli> Orphi: Its also possible to use tries or similar trees to tabulate the set of strings in such a fashion that they can be enumerated in order.
02:07:06 <pjd> edwardk: what's the class with ones, again?
02:07:10 <edwardk> i've enjoyed it, mainly because its been an interesting experiment in minimalism. what do you get if you take and try to make the basic functions that everyone learned how to use in haskell and look for what common pieces functionality cuts across them. fmap rather than map or (.),  catamorphisms rather than folds, building (+) over an arbitrary monoid or magma even
02:07:21 <edwardk> with ones?
02:07:26 <pjd> that is, the difference between MonadZero and MonadPlus
02:07:31 <pjd> (i think)
02:07:43 <edwardk> MonadPlus exists, MonadZero would just be mzero, no mplus
02:08:02 <pjd> well, Monoid is the generalization of things with just zero, right?
02:08:11 <pjd> what's the analogue for that with ones?
02:08:41 <edwardk> monoid requires an associative binary operator and zero
02:09:09 <pjd> edwardk: (previous comment) yeah, i'm also interested in that kind of minimalism
02:09:47 <edwardk> well, one doesn't quite fit the mold like you think. you can have something with 'just one' and an associative operator that is 'multiplicative' its just another monoid or group =) but maybe you mean something ring or semi-ring like
02:09:54 <pjd> well, if Monad + Monoid = MonadZero, then Monad + ? = MonadPlus?
02:09:56 <edwardk> so you have both 0 and 1, + and *
02:10:10 <pjd> i think i do
02:10:21 <psykotic> pjd: a monad _is_ a monoid, even without an mzero.
02:10:35 <pjd> it is?
02:10:43 <psykotic> yes, of course.
02:10:48 <psykotic> unit/return is the "identity"
02:11:11 <MarcWebe1> On hackage there are some minor issues (such as FilePath vs filepath) .. Which is the way to fix them? I want to add all packages to the nix distribution system. Who should I contact?
02:11:19 <edwardk> @type (>>)
02:11:28 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
02:11:47 <psykotic> right. so set a = b in the above, and consider the monad laws involving return.
02:12:26 <psykotic> return >> m = m. m >> return = m
02:12:42 <edwardk> not sure i see return working as an identity therem you need to use >>= no?
02:12:51 <psykotic> oh yeah. hmm
02:12:57 <psykotic> i guess there's an asymmetry.
02:13:05 <psykotic> but in any case mzero doesn't make it a monoid.
02:13:17 <pjd> hmm, i think i see, but that would be a monoid in a different "sense" (at a different level?) than Monoid, then, right?
02:13:17 <psykotic> because the mzero "annihilates" a computation it comes into contact with.
02:14:08 <edwardk> mzero doesn't make a monoid, i agree. mzero is the identity of mplus not >>
02:14:11 <psykotic> pjd, but mark that mzero doesn't make it a monoid either, it doesn't satisfy the right equation laws.
02:14:24 <psykotic> you have the right type signatures but that is not at all it takes to make a monoid.
02:15:04 <psykotic> the unit of a monoid must act as an identity or neutral element with respect to the composition operation.
02:15:22 <psykotic> whereas mzero in a MonadPlus is pretty much the antithesis of that, seeing that it annihilates computations it is composed with.
02:15:22 <pjd> right
02:15:29 <edwardk> > [1] `mplus` mzero
02:15:31 <lambdabot>  [1]
02:15:36 <psykotic> oh, you meant with respect to mplus
02:15:43 * psykotic hits himself
02:15:49 <edwardk> =)
02:16:02 <Syzygy-> > mzero `mplus` [1]
02:16:04 <lambdabot>  [1]
02:16:24 <pjd> psykotic: apparently i did :)
02:16:27 <Syzygy-> > [1] `mplus` [2]
02:16:28 <lambdabot>  [1,2]
02:16:30 <pjd> did you look at the filter definition above?
02:16:30 <edwardk> > Just 1 `mplus` mzero
02:16:30 <Syzygy-> Ah.
02:16:32 <lambdabot>  Just 1
02:16:51 <psykotic> pjd: yeah
02:16:56 <Syzygy-> > mzero :: [Int]
02:16:58 <lambdabot>  []
02:18:05 <opqdonut> well mempty==mplus for practically all monads that are instances of MonadPlus and Monoid
02:18:16 <opqdonut> *mempty==mzero
02:18:20 <edwardk> yeah
02:18:23 <opqdonut> weird typo :)
02:18:27 <edwardk> are there any that differ?
02:18:37 <opqdonut> don't come to mind
02:18:42 <edwardk> didn't think so
02:18:58 <edwardk> its kind of like the fmap and liftM thing, in theory they could differ, but in practice they don't
02:19:00 <pjd> i have a feeling they could only differ by breaking their respective axioms
02:19:39 <opqdonut> well the laws of monoid only state that: mplus a mzero == a; mplus mzero a == a; and that's it
02:19:48 <edwardk> nah, for instance for fmap and liftM they CAN actually differ, since there isn't necessarily only one choice
02:20:02 <opqdonut> and there is a wealth of ways to implement monoid
02:20:07 <opqdonut> because monoids are just everywhere
02:20:19 <edwardk> so if mplus and mappend differed, then you might get different mzero and mempty
02:20:50 <opqdonut> yep
02:20:57 <pjd> right, but then you'd probably be implementing different "views"/interpretations (?) of the underlying data type
02:21:06 <opqdonut> yes, exactly
02:21:09 <pjd> so you could swap them around
02:21:22 <pjd> so it's not actually the mzero and mempty that differ
02:21:27 <pjd> if that makes sense
02:21:36 <edwardk> look at the control.applicative for some examples of second-class monoids to play with over common monads iirc
02:21:46 <opqdonut> well, (m,mempty,mappend) is a monoid
02:24:20 <edwardk> anyways, they could differ in detectable ways, i.e. if you have a 'maybe' type with two distinct 'Nothing's, etc. =)
02:24:40 <edwardk> not saying there is a compelling business case for it, but hey
02:37:45 <crazy_code2> Lemmih: hi You are still there ?
02:38:03 <Lemmih> crazy_code2: Yes.
02:38:04 <crazy_code2> Lemmih: Sorry, I got disconnected :(
02:38:58 <crazy_code2> Lemmih: So, I can write methods to the new data type defined, but how am I supposed to put restriction on the use of the constructor
02:39:01 <crazy_code2> eg
02:39:11 <crazy_code2> data AbstractInteger = Zero | Succ AbstractInteger | Pred AbstractInteger deriving (Eq,Show)
02:40:00 <wli> Well, you can get 3 constructors for 0, 2n+1, and 2n+2.
02:40:24 <wli> It doesn't really gain anything theoretical but it'll run a lot faster.
02:40:32 <crazy_code2> I want ensure that an AbstractInteger cannot have both Pred and Succ simultaneously
02:40:43 <Lemmih> crazy_code2: You can't put restrictions on the use of constructors.
02:40:57 <Lemmih> crazy_code2: You can use smart constructors, though.
02:41:06 <pjd> oh!
02:41:14 <pjd> i think i get it
02:41:17 <crazy_code2> In my current data type, I can construct something like Succ(Pred Zero)
02:41:29 <crazy_code2> But I want to make it an illegal operation
02:41:33 <wli> crazy_code2: You want a type for natural numbers first.
02:42:01 <pjd> there's nothing intermediate between Monad and MonadPlus
02:42:07 <crazy_code2> wli: ??
02:42:23 <crazy_code2> Lemmih: what are smart constructors ?
02:42:23 <wli> crazy_code2: data Nat = One | TwoN Nat | TwoNPlus1 Nat
02:43:07 <wli> crazy_code2: THen data Z = Zero | Pos Nat | Neg Nat
02:44:04 <Lemmih> http://www.haskell.org/haskellwiki/Smart_constructor
02:44:05 <lambdabot> Title: Smart constructors - HaskellWiki
02:44:06 <crazy_code2> wli: I can't follow you. Sorry.  But I am solving an assignment problem I found on the net..
02:44:37 <crazy_code2> It mentions in the problem statement certain constraints
02:44:47 <crazy_code2> that I have to implement
02:45:21 <crazy_code2> THe problem is that I haven't quite understood the 'data'  usage in Haskell :(
02:45:34 <crazy_code2> Will have to read it again...
02:45:40 <wli> crazy_code2: Sign and magnitude representation.
02:45:42 <pjd> edwardk: mplus is what corresponds to the join in monad
02:45:48 <pjd> well, msum
02:45:53 <wli> crazy_code2: signs are positive, negative, or zero.
02:46:05 <pjd> (i think)
02:46:39 <wli> crazy_code2: So you need the strictly positive representation first.
02:46:47 <crazy_code2> Lemmih: Ok. This is exactly what I was looking for
02:46:52 <DRMacIver> Hm.
02:46:53 <crazy_code2> Lemmih: wli Thanks
02:47:00 * DRMacIver peers suspiciously at this code.
02:47:20 <DRMacIver> It appears to do things the code doesn't say it does.
02:47:29 <wli> crazy_code2: data N = One | TwoN Nat | TwoPlus1 Nat ; data Z = Zero | Pos Nat | Neg Nat
02:48:37 <wli> crazy_code2: succ and pred are interesting, of course.
02:50:35 <wli> succ Zero = Pos One; succ (Neg One) = Zero; succ (Neg n) = Neg (pred n); succ (Pos n) = Pos (succ n)
02:51:01 <wli> analogously for pred
02:51:19 <crazy_code2> Succ is a data constructor
02:51:35 <wli> crazy_code2: Well, not in this representation.
02:51:53 <crazy_code2> Ok
02:51:58 <crazy_code2> I'll work it out
02:51:59 <wli> crazy_code2: If you do data N = One | Succ Nat then yes.
02:52:15 <crazy_code2> Thanks
02:53:17 <wli> succ One = TwoN One; succ (TwoN n) = TwoNPlus1 n; succ (TwoNPlus1 n) = TwoN (succ n)
02:53:49 <wli> crazy_code2: That's what succ looks like on the binary N like I defined it.
02:55:04 <wli> pred (TwoN n) = TwoNPlus1 (pred n); pred (TwoNPlus1 n) = TwoN n; pred (TwoN One) = One; pred One = error "can't take pred of One"
02:55:58 <wli> I wrote it backward so pattern matching got screwed, but anyway.
02:56:18 <psykotic> pjd: the definition of join doesn't involve mplus. join :: m (m a) -> m a, and you can derive the implementation from that. (>>=) :: m b -> (b -> m a) -> m a. so set b = m a: m (m a) -> (m a -> m a) -> m a. there's only one canonical choice for m a -> m a, up to equality, which is id. so join = flip (>>=) id.
02:56:23 <wli> crazy_code2: With the succ and pred on Z and N then you're home free.
02:57:08 <wli> psykotic: flip (>>=) is (=<<) IIRC
02:57:18 <psykotic> wli: yeah, thanks
02:57:49 <pjd> join = (>>= id)
02:57:50 <pjd> :)
02:58:06 <psykotic> you can your sections
02:58:10 <psykotic> err, you and your sections
02:58:21 <wli> Oh, yeah, sections.
02:58:30 * pjd likes them sections
02:58:31 <psykotic> anyway, mplus is not involved. join essentially just runs the "outer computation", which produces another computation as value which is in turn run.
02:58:36 <pjd> i understand, but i mean a more general correspondence
02:58:39 <psykotic> ah
02:59:04 <pjd> in the context of decomposing whole bunch of MonadPlus and related classes
02:59:10 <pjd> "the whole", even
03:00:04 <DRMacIver> Mm. Yes, I think sections are one of those little things which just make you go "Oh, cute." when you first see them and then a few months later you discover that they completely pervade your code. :)
03:00:28 <psykotic> they are so fiendishly readable
03:00:43 <psykotic> it's a syntax hack that more languages should steal
03:00:57 <pjd> damn, trying to sort these out is making my head spin
03:01:07 <wli> Currying an infix operator is not really all that far out.
03:01:12 <psykotic> i believe ocaml supports "nullary sectioning" whereby an infix operator is treated as a function
03:01:24 <psykotic> using the same syntax as haskell, e.g. (+)
03:01:27 <DRMacIver> wli: Ah, but you've missed the cunning bit. :)
03:01:33 <wli> psykotic: Parens around an infix op are there.
03:01:41 <wli> DRMacIver: Why is it so cunning?
03:01:49 <DRMacIver> wli: How would you write (+1) in a curried manner?
03:01:55 <psykotic> wli: but i don't believe e.g. (1+) works, does it?
03:02:08 <DRMacIver> psykotic: Other way round isn't it?
03:02:14 <wli> DRMacIver: (+1) ... it's kind of obvious.
03:02:33 <DRMacIver> wli: Without sections. :-p
03:02:47 <wli> DRMacIver: You can't. You need some syntax to support it.
03:02:50 <psykotic> \x -> x+1 gets bothersome
03:02:59 <wli> DRMacIver: (\x -> x + 1) is it otherwise.
03:03:08 <DRMacIver> wli: The point is that it's not just currying.
03:03:24 <DRMacIver> If it were just currying you'd only get the equivalent of (+) 1
03:03:33 <DRMacIver> Which is (1+)
03:03:42 <psykotic> you can always flip
03:03:44 <DRMacIver> Yes
03:03:47 <wli> Well, (+) is "nullary sectioning or otherwise syntax support.
03:03:55 <pjd> psykotic: but that's so forthy
03:04:14 <wli> It's dull. Normal functions are prefix operators. Currying them doesn't raise parsing issues.
03:04:23 <DRMacIver> psykotic: flip is significantly less readable than just writing the damn lambdas. :)
03:04:25 <psykotic> pjd, well, you need to get use to it anyway when dealing with infix functions. i don't think using `` just to avoid a flip is a good idea
03:04:37 <psykotic> err, when dealing with regular (non-infix) functions
03:04:50 <psykotic> DRMacIver, often, yes
03:04:53 <pjd> (`foo` x) !
03:05:06 <DRMacIver> Hm. Does that actually work?
03:05:10 <psykotic> it should
03:05:24 <wli> Provided the types work out, yes.
03:05:26 <DRMacIver> ?type let foo bar baz = 1 in (`foo` 2) 3
03:05:28 <psykotic> and that's what i had in mind, and my point was that it's extremely unnatural when foo isn't binary-operator-like
03:05:29 <lambdabot> forall t. (Num t) => t
03:09:36 <DRMacIver> Apparently.
03:09:36 <wli> I should probably use one of those fancy numeric preludes or whatever.
03:09:36 <pjd> (`map` [1..5])
03:09:36 <pjd> heh
03:09:36 <psykotic> pjd: that's not bad actually.
03:09:36 <DRMacIver> pjd: Hm. That's actually a neat trick. I might remember that one.
03:09:36 <psykotic> if you read map as "map over" :)
03:09:36 <psykotic> in scala, where map is a method, that's exactly how you'd write it, sort of.
03:09:36 <pjd> sections triumph
03:09:36 <psykotic> except _.map(1 to 5)
03:09:36 <wli> map should really be a Functor instance method.
03:09:36 <wli> fmap is kind of dumb.
03:09:36 <DRMacIver> I bet it's the standard excuse for not doing sane things.
03:09:36 <DRMacIver> "It would create confusing type error messages"
03:09:36 <wli> DRMacIver: What's that?
03:09:36 <pjd> hindsight is 20/20, and all that
03:09:36 <pjd> if Haskell were started today, there'd probably be a lot less of that kind of duplication
03:09:36 <psykotic> pjd: well, you could make map part of a type class without breaking existing code, i think.
03:09:36 <wli> pjd: That's what new standard library revisions are for, I suppose.
03:09:36 <psykotic> you'd just implement it for lists to have the usual semantics
03:09:36 <wli> psykotic: Nonstandard preludes are out there IIRC.
03:09:36 <psykotic> wli: yeah
03:09:36 <wli> psykotic: I've written things like this actually.
03:09:36 <psykotic> functors are greatly underappreciated
03:09:53 <psykotic> whenever you have a structure containing blarghs and you want to do "deep" replacement, they rock
03:10:08 <wli> psykotic: A Zippable class is handy, too.
03:10:39 <psykotic> by the way
03:11:10 <psykotic> is there a standard pattern for having a type class provide a default, with optional overriding. so for example, for a sort function that might use Eq by default.
03:11:18 <psykotic> i guess usually people just have two different functions
03:12:02 <psykotic> it's easy to remove the redundancy by having the function using Eq pass (==) to the other version, of course
03:12:50 <psykotic> s/Eq/Ord/
03:13:00 <wli> instance Zippable ((->) a) where fzip f g = \x -> (f x, g x); instance Zippable Maybe where { fzip (Just x) (Just y) = Just (x, y) ; fzip _ Nothing = Nothing ; fzip Nothing _ = Nothing } etc.
03:13:29 <ndm> @seen dons
03:13:29 <lambdabot> dons is in #haskell-icfp07, #ghc, #xmonad and #haskell. I last heard dons speak 1h 42m 51s ago.
03:13:40 <psykotic> wli: nice.
03:14:10 <pjd> hmm, no, i was wrong
03:14:15 <psykotic> wli: so fzip :: f a -> f b -> f (a,b)
03:14:54 <wli> psykotic: It's also pretty obvious how to define a Num instance for Num t => t' -> t
03:14:59 <psykotic> i guess some notion of fzip can be made meaningful whenever you have a notion of "substructure" or "shared substructure"
03:15:04 <psykotic> yep
03:15:28 <psykotic> in which case fzip can be defined generically as: "merge pairwise over the greatest common shared substructure"
03:15:29 <desp> what does Type(..) mean in a module's declaration?
03:15:38 <wli> psykotic: instance Functor ((->) t) where fmap f x = f . x
03:15:47 <ndm> desp, I export the data type Type, and all its constructors
03:15:58 <desp> ah
03:16:36 <DRMacIver> wli: a Num instance for Num t => t -> t is nicer. :)
03:16:55 <DRMacIver> Especially if you abstract out + from the Num class into an addable class of some sort.
03:16:59 <ndm> anyone know if nobench is still active?
03:17:25 <DRMacIver> As then you can have an instance for Addable t => t -> t and get some ridiculously readable code for vectors, etc.
03:17:35 <DRMacIver> err. a num instance for etc.
03:18:11 <DRMacIver> 4 (1, 2, 3) + 5 (0, 0, 1) -- Legal code given the right class setup.
03:18:22 <wli> DRMacIver: The arguments of the functions don't need anything remotely numerical. You could, for instance, want to add two functions that numerically characterize strings like the largest expression depth and so on.
03:18:43 <DRMacIver> wli: I'm proposing a different implementation than you have in mind.
03:19:28 <wli> DRMacIver: I've already got code that does that.
03:19:35 <DRMacIver> Where * is . and n is (n*)
03:20:00 <DRMacIver> (Or thereabouts)
03:20:40 <DRMacIver> Oh wait. Do we have an example where there is no one true instance of the type class? ;) </troll>
03:21:07 <psykotic> DRMacIver, if you do that then + and * bear no meaningful relationship
03:21:22 <psykotic> e.g. you have no distributivity
03:21:37 <DRMacIver> Sure you do. Operationally anyway.
03:21:44 <psykotic> if you like * be composition?
03:22:05 <psykotic> let, sorry
03:22:10 <DRMacIver> Yes. Because the underlying operations are already distributive.
03:22:35 <psykotic> your definition of + is just pointwise addition of the underlying number type, right?
03:22:35 <DRMacIver> Hm
03:22:44 <DRMacIver> No, I guess this doesn't work. I was assuming linearity of the functions. My bad.
03:22:52 <psykotic> in that case there definitely is no distributivity, which is the key law that ties together addition and multiplication
03:22:54 <psykotic> right
03:22:58 <wli> Hmm, I seem to need a unary constructor.
03:23:05 <DRMacIver> Not ethat Num instances are not required to be distributive.
03:23:16 <psykotic> right but i would certainly expect it
03:23:36 <DRMacIver> Well, you'd be wrong. ;) Note also that this is distributive on quite a large subset of the type.
03:23:43 <psykotic> * and + have to interact in some meaningful way
03:23:51 <wli> The unary constructor is needed to lift constant methods.
03:23:55 <psykotic> otherwise i don't see how you can meaningful see them as part of the same structure
03:24:04 <wli> pi = unaryCon pi
03:24:31 <wli> That's where floating falls down.
03:24:36 * DRMacIver shrugs
03:24:40 <DRMacIver> These interact in a meaningful way. It just happens to not be distributivity. :)
03:24:45 <psykotic> DRMacIver, can you think of a notion of number in which multiplication does not distribute over addition?
03:24:56 <psykotic> i mean a natural one
03:24:58 <DRMacIver> I believe I just gave you one. :)
03:25:00 <psykotic> even matrices have this property
03:25:02 <DRMacIver> Symbolic algebra is another.
03:25:06 <wli> Of course, you don't really care unless you want to define exp and so on.
03:25:30 <wli> Fractional needs it, too.
03:25:32 <DRMacIver> Also, floating point numbers. ;)
03:25:41 <wli> For fromRational
03:25:57 <psykotic> DRMacIver, but those are somewhat weird in that they're approximations to structures with the properties i mention.
03:26:01 <wli> Num needs it for fromInteger
03:26:27 <DRMacIver> I'm not sure how to discuss this if you're just going to label all my examples as exceptional cases. :)
03:26:37 <psykotic> well, i'm coming at it as a mathematician
03:26:40 <DRMacIver> So am I.
03:26:55 <wli> f * g = fmap (uncurry (*)) $ fzip f g
03:27:01 <psykotic> can you tell me of an instance at which the structure you defined with * as function composition and + as pointwise addition arrises in mathematics?
03:27:07 <wli> That's not likely to do what a lot of people expect.
03:27:18 <psykotic> i'm not being combative, but genuinely i have never seen that
03:27:33 <wli> abs f = fmap abs f ;  signum f = fmap signum f
03:27:49 <wli> So there are pathologies.
03:28:10 <DRMacIver> psykotic: Endomorphisms of a vector space, which is what inspired it in the first place.
03:28:22 <DRMacIver> psykotic: The problem is that you can't restrict these functions to be linear.
03:28:30 <psykotic> right
03:28:32 <DRMacIver> (In Haskell's type system)
03:28:34 <wli> f / g = fmap (uncurry (/)) $ fzip f g -- that will surprise people, too
03:28:42 <DRMacIver> But having invariants the type system can't enforce is not unusual.
03:28:44 <fasta> Can anyone tell me what the :etags is supposed to do?
03:29:16 <psykotic> DRMacIver, i know about endomorphism rings but yes this only works for specific kinds of transformations.
03:29:17 <olsner> :t fmap (uncurry (/)) . fzip
03:29:20 <lambdabot> Not in scope: `fzip'
03:30:01 <wli> olsner: fzip is a member of a typeclass Zippable I've defined as class Zippable f where fzip :: f a -> f b -> f (a,b)
03:30:01 <psykotic> DRMacIver, and endomorphism rings are indeed rings, so you do have distributivity. my example was asking for a case where you have a structure with a multiplication and an addition in mathematics that does not interact distributively.
03:30:06 <fasta> Does it append to an existing TAGS file? Does it overwrite it? Does it recursively get the TAGS for every module in that file?
03:30:16 <psykotic> DRMacIver, and probably there are examples, but i can't think of any. (floating point numbers are a weird implementation hack)
03:30:18 <fasta> Lots of questions, no documentation to look in.
03:30:36 <olsner> oh, so (/) f g x = (f x) / (g x)?
03:30:58 <DRMacIver> Um. no it wasn't. Your question was 12:26 < psykotic> can you tell me of an instance at which the structure you defined with * as function composition and + as pointwise addition arrises i  mathematics?
03:31:02 <wli> olsner: That's how I've got it working for now.
03:31:12 <DRMacIver> So that's what I answered. :)
03:31:34 <DRMacIver> The example of symbolic algebras certainly crops up in mathematics, although probably not anywhere very exciting.
03:31:35 <psykotic> DRMacIver, sorry, my question was unclear. you earlier said that distributivity wasn't a requirement, implying that you knew well that your structure didn't have that property.
03:32:01 <wli> olsner: e.g. (+1)/2 :: forall a. (Num a, Fractional (a -> a)) => a -> a
03:32:06 <psykotic> symbolic algebras? you mean like kleene algebras?
03:32:16 <wli> olsner: (+1)/2 $ 3 == 2.0
03:32:22 <DRMacIver> Just formal algebras of symbols.
03:32:32 <psykotic> so some kind of free structure, right
03:32:38 <DRMacIver> Yeah
03:32:59 <DRMacIver> I guess I'm really interested in the cases where it is distributive. My point about distributivity not being required was not saying that distributivity is not a desirable property, but that a lack of distributitivy in some cases is not a violation of the contract for Num.
03:33:13 <DRMacIver> i.e. it's valid Haskell, even if it might have non-intuitive consequences outside of the area it's intended for. :)
03:33:16 <psykotic> i agree.
03:33:43 <DRMacIver> And the instance I was suggesting is distributive in the cases I want to use it in. :)
03:33:45 <wli> olsner: id*(1-) == \x -> x*(1-x)
03:33:52 <fasta> Never mind
03:34:06 <pjd> wait a minute
03:34:11 <wli> olsner: http://holomorphy.com/~wli/scripts/FunctorAlgebra.hs
03:34:14 <pjd> are Functor and Applicative isomorphic?
03:34:18 <psykotic> just to close, in the case of symbolic algebras, i can easily imagine some kind of term algebra, ala prolog, where you have constant symbols, function symbols, etc. but i can't imagine a structure like that with a distinguished * and + without some kind of distributivity-like interaction appearing.
03:34:56 <DRMacIver> I think it crops up a lot when writing abstract syntax trees which you want to embed in code in a nice manner.
03:34:59 <psykotic> actually i guess i can think of some examples where it isn't quite distributive but there is some distributive-like law.
03:35:00 <wli> psykotic: Non-distributive lattices, nonassociative algebras, etc.
03:35:04 <psykotic> right
03:35:05 <DRMacIver> The symbolic algebra one I mean.
03:35:12 <pjd> pure x = fmap . const ?
03:35:22 <pjd> err
03:35:25 <DRMacIver> So I suppose they tend to 'compile' to something which eventually distributes. :)
03:35:38 <DRMacIver> I'm not sure this is a sufficiently specific distinction to be useful.
03:35:46 <psykotic> i see what you mean, thanks.
03:36:21 <pjd> no, nevermind
03:36:23 <wli> olsner: It needs some subset of -fglasgow-exts -fallow-undecidable-instances -fallow-overlapping-instances -fno-monomorphism-restriction, of course. I've not looked at it in years.
03:36:33 <pjd> i was thinking of monads
03:37:01 <wli> Breaking return off of Monad might be nice.
03:37:27 <wli> It's perfectly useful as an injection.
03:38:05 <pjd> right, that's what Control.Applicative does :)
03:39:15 <edwardk> pjd: yeah but it bundles it with other stuff =)
03:39:35 <pjd> i'm wondering about that at this very moment
03:39:35 <wli> pjd: Ah, my "unaryCon" is essentially "pure", except it's tied to <*>
03:39:49 <edwardk> return on its own is just the other half of a mathematical functor providing a mapping of ob, not just hom for the category
03:39:51 <pjd> what's the essense of <*> ?
03:39:56 <wli> pjd: And a few other things, too.
03:41:40 <wli> pjd: I'm not entirely sure. I've not reverse-engineered what the various methods of Applicative are meant to be just yet.
03:41:47 <pjd> actually
03:41:58 <pjd> does Alternative strictly need to be a subclass of Applicative?
03:43:02 <edwardk> alternative just plays the same role as mzero, mplus or mempty and mconcat, it could be rolled in with all of those
03:43:19 <pjd> right
03:43:46 <pjd> i'm wondering whether Alternative is orthogonal to Applicative
03:44:16 <edwardk> theoretically you don't even need <*> for <|> to make sense, just a way to inject into the structure i.e. 'return' and then <|>, mplus, mappend, whatever just gives you a way to append them
03:45:01 <edwardk> well, ideally, you need the way to 'get in' , so it needs some form of injection like 'pure' or 'return'
03:45:19 <pjd> right, but can it do without?
03:45:26 <edwardk> sure
03:45:42 <pjd> so it's just a subclass in Control.Applicative by accident?
03:45:46 <fasta> Is there a common structure to check for failure? null and isNothing are essentially the same for example.
03:45:47 <edwardk> but as usual in haskell your function signatures will become unusable quickly without a hierarchy of these
03:45:54 <pjd> right
03:46:13 <pjd> ok, this makes sense
03:46:33 <edwardk> basically most of these somewhat arbitrary constraints exist to keep the signatures of your functions palatable
03:46:48 <fasta> Also fail "empty list"::[Int]([]) and fail "Maybe"::Maybe Int (Nothing) have a common "interface".
03:47:12 <wli> class Injective i where { iota :: t -> i t } ; class Projective t where { pi :: p t -> t }
03:47:23 <edwardk> which is needed to keep the ability to figure out the dictionary in question automatically decidable as opposed to using some form of polymorphic record as a dictionary.
03:47:30 <wli> class Projective p where { pi :: p t -> t } rather.
03:48:20 <edwardk> class Returnable and class Extractable maybe to stick to the usual method names for monads and comonads respectively?
03:48:25 <wli> Basically whether there exist canonical injections and projections.
03:48:26 <edwardk> that way you don't have to learn new words
03:49:36 <wli> edwardk: I don't know. Canonical injections (as for coproducts) and canonical projections are more familiar to me than monads or comonads (or Haskell itself, in all honesty).
03:51:11 <edwardk> i'm just loathe to introduce yet another new name for the same thing (return)
03:51:35 <wli> edwardk: And frankly, how do you explain instance Returnable ((->) t) where return = const in such a nomenclature?
03:52:31 <edwardk> well, you can call return 'unit', etc. 'return' is a crappy name, but its useful for the common imperative monad case
03:52:59 <wli> It is useful to distinguish by names the more general from the more specific instances.
03:53:43 <wli> Like transpose from adjoint.
03:54:37 <pjd> wli, edwardk: oh, awesome!
03:54:47 <wli> pjd: What's awesome?
03:55:02 <edwardk> i just want a nice way to specify a lot of interfaces for type classes, where each one constraints some small subset of the methods to exist or have a refined subset type or something if they are both present
03:55:12 <edwardk> er constrains
03:55:16 <pjd> Injective/Projective/Returnable/Extractable
03:56:04 <wli> pjd: Well, if I wanted to be verbose I'd say CanonicallyInjective and CanonicallyProjective and have it multiparameter.
03:56:35 <edwardk> the problem i have with injective and projective as opposed to returnable/extractable, is that when you use them to provide the 'other half of a functor' they seem to imply something about the way the functor maps values between categories (i.e. injectively)
03:57:02 <pjd> right
03:58:02 <wli> pjd: e.g. class Injective i t where { iota :: t -> i t }; Then you can have instance Injective (Either Int Double) Int where iota = Left and instance Injective (Either Int Double) Double where iota = Right
03:58:41 <pjd> hmm
03:58:53 <edwardk> the problem is you can't make polymorphic the injection instances so its not all that useful
03:58:55 <edwardk> i.e.
03:59:21 <edwardk> instance Injective (Either a Int) Int ... and instance Injective (Either Int a) Int.... will conflict and blow up in your face in Haskell
03:59:52 <edwardk> so you have to choose one in the general sense
03:59:55 <DRMacIver> Isn't there an extension to allow that?
04:00:02 <wli> edwardk: There is a lack of a way to constrain types to be unequal.
04:00:04 <edwardk> sure, but now you don't know which one you got =)
04:00:16 <DRMacIver> Oh, I see what you mean.
04:00:21 * DRMacIver misparsed the problem.
04:00:36 <edwardk> wli: disunification is hard =)
04:00:52 <DRMacIver> Solution: The compiler should force you to make an instance Injective Int Int. :)
04:01:26 <edwardk> dr: thats not a terrible solution actually
04:01:36 <DRMacIver> Yeah. I wasn't joking.
04:01:49 <DRMacIver> It's basically allowing multiple dispatch on the kind level.
04:01:58 <DRMacIver> Which is Good. :)
04:02:02 <wli> edwardk: Another way to characterize it would be as coercion.
04:02:06 <edwardk> my way has been to incur a proof burden that the two are observationally equivalent
04:03:16 <wli> Well, instance Injective (Either t t') t doesn't fall down quite so easily.
04:03:23 <edwardk> yeah
04:03:46 <wli> But you can unify t and t' and then say that case has to be declared separately.
04:03:47 <edwardk> i was just going through and trying to figure out if i could construct a rigorous ordering on 'more defined than'
04:03:48 <fasta> Is there some way to make GHCI load source files faster?
04:04:23 <Syzygy-> And for that particular case, there are three different very obvious, and a host of semi-obvious ways to do it.
04:04:35 <DRMacIver> Note that what you have here is basically a multiple inheritance problem.
04:04:43 <wli> Argh, just when I'm heading to the store.
04:04:48 <fasta> E.g. a mode where it does no optimization or something like that?
04:04:49 <edwardk> fasta: make the source files simpler? =)
04:04:53 * Syzygy- wants the diagonals dangit! iota x = Left x + Right x 
04:04:58 <DRMacIver> With the observation "Oh no. Diamonds exist." :)
04:05:08 <Syzygy-> DRMacIver: Hehehe
04:05:22 <DRMacIver> (Which is why I just pulled out my standard MI solution)
04:05:24 <Syzygy-> So we'll prove a diamond lemma and just go on with our lives, eh?
04:05:30 <fasta> edwardk: Disabling all the extensions will probably help, but then it doesn't run anymore, eh.
04:05:35 <wli> In practice what people will probably do is make it default to one canonical injection or another.
04:05:52 <scook0> fasta: if they aren't changing, precompiling to .o might help (iirc)
04:06:06 <wli> e.g. instance Injective (Either Int Int) Int where iota = Left
04:06:14 <fasta> scook0: that only makes them run faster.
04:06:37 <fasta> scook0: IIRC
04:06:45 <DRMacIver> Which reminds me. I really need to figure out how to read C++.
04:07:08 <scook0> fasta: intuitively, I'd expect precompilation to make loading faster, though I've not actually tried it
04:07:09 <edwardk> right now my solution to ambiguous instances is to require them to be passed explicitly. i.e. if i have two different dictionaries for Eq Int, and i want to call sorted : (.by : Ord a) => [a] -> Bool, i can fall back on sorted .by ordering1  or sorted .by ordering2
04:07:43 <edwardk> so if i had two Injections, i can name them inl and inr and forget about the problem ;)
04:08:18 <wli> edwardk: Is this a non-Haskell language?
04:08:23 <edwardk> yeah pretty much
04:08:33 <edwardk> haskell-ish
04:08:54 <edwardk> but very willing to break a lot of eggs
04:09:39 <pjd> what's another name for <*> / ap?
04:10:06 <pjd> (does it have a "proper" category theory name?)
04:10:09 <edwardk> i've had to give up multiparameter type classes, until i figure out a way to infer them
04:10:25 <edwardk> they don't fit into my system well =/
04:11:33 <wli> edwardk: I'd give up type inference altogether for a type system expressing enough math for some sort of dumb math language.
04:12:05 <wli> edwardk: I should probably look into Cayenne.
04:12:05 <edwardk> wli: i'm clinging to type inference by the skin of my teeth ;)
04:12:17 <edwardk> at least just enough of it to be useful
04:13:24 <fasta> Math language?
04:13:28 <fasta> What meaning has that?
04:14:20 <edwardk> my main use for typeclasses at the moment are to build up the numerical tower and monad/functor stuff, for which single parameter type classes seem to have sufficed.
04:14:55 <edwardk> s/are/is
04:15:14 <fasta> Maybe I don't know some tricks, but in my experience Haskell without MPTCs is unthinkable now.
04:15:30 <edwardk> fasta: well, i can typecase, so its not as bad as it seems ;)
04:15:47 <edwardk> you can rebuild them just not using the same syntactic mechanism
04:16:09 <fasta> Some claim fundeps will go away soon; they'd better replace it with something good then, since I like them.
04:16:48 <scook0> fasta: associated types, isn't it?
04:16:50 <fasta> When all the features from GHC work as advertised, it's a nice system.
04:17:09 <scook0> (i.e. the replacement)
04:17:11 <fasta> scook0: yes, since that isn't implemented yet, it doesn't exist.
04:17:24 <edwardk> i don't find that class associated types solve all of the problems i like to use mptcs for cleanly
04:17:58 <fasta> I don't know whether they do, since there is no compiler that can fully handle them.
04:18:45 <fasta> Some development tools can be handy, but otherwise GHC as is now is pretty good modulo bugs.
04:18:49 <edwardk> it seems to me that MPTCs and fundeps cleanly express bijections and more complicated functional dependencies
04:19:18 <fasta> as it is now*
04:21:46 <fasta> If only other compilers could play catchup... (and be apt-get installable)
04:22:56 <pjd> this is interesting; liftM is analogous to merely Functor's fmap
04:23:25 <edwardk> pjd: liftM = fmap = liftW and map and (.) are special cases
04:23:50 <pjd> but liftM2 and depend on Monad
04:24:00 <pjd> yeah
04:24:13 <vermoos> hi there
04:24:24 <vermoos> is there a 'monads for idiots' guide out there?
04:24:44 <edwardk> http://www.haskell.org/all_about_monads/html/index.html
04:24:45 <lambdabot> Title: All About Monads
04:24:57 <DRMacIver> Is there one? There are thousands of the damn things. You can't throw a rock without hitting six analogies for monads. :)
04:25:18 <helmut> There must be a monad like Maybe a where Nothing contains an error message. Could you tell me the name?
04:25:24 <edwardk> i like the all about monads/old nomaware one because its big on examples
04:25:35 <pjd> helmut: Either?
04:25:37 <scook0> helmut: Either String
04:25:46 <edwardk> helmut: the Either SomeError
04:25:50 <edwardk> =)
04:25:54 <helmut> is it already an instance or do I have to declare?
04:26:09 <opqdonut> it is
04:26:11 <fasta> Can I read a number in base 26 easily?
04:26:20 <vermoos> DRMacIver heh, correctamundo! i'm after the simplest
04:26:22 <edwardk> Control.Monad.Error
04:26:57 <edwardk> vermoos: i'd start with the one i linked above
04:27:03 <DRMacIver> vermoos: The simplest is to just write monadic code until enlightenment spontaneously occurs. :)
04:27:13 <DRMacIver> (No, really.)
04:27:18 <vermoos> DRMacIver why do people make up smartarse words like 'monad' anyway?
04:27:20 <edwardk> vermoos: and maybe skim the monads as spacesuits thing to round out your understanding
04:27:38 <apfelmus> > foldl' (\x d -> 26*x + ord d - 64) 0 "FASTA" -- fasta
04:27:39 <lambdabot>  2772797
04:27:41 <edwardk> because then they can claim there is a huge high-falutin backstory to everything they do that goes back to category theory ;)
04:27:46 <DRMacIver> vermoos: Because it originally comes from an obscure piece of category theory. :)
04:28:01 <Philippa> actually I think it's older than that and the category theory usage unifies a few
04:28:06 <edwardk> yeah
04:28:36 <edwardk> too bad there isn't a good link between the modern monad and the leibnizian one =)
04:28:39 <DRMacIver> vermoos: http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html is one of the simplest in my opinion. It has the advantage of a) Also being good and b) Being analogy free. :)
04:28:41 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ..., http://tinyurl.com/ecqzl
04:28:45 <scook0> I'm a fan of the "you could have invented monads" approach
04:28:45 <edwardk> accidental reinvention of words, hrmmf
04:29:17 <scook0> the book I learned monads from did a similar thing
04:29:32 <vermoos> my limited understanding of what monad means is 'atom'
04:29:35 <helmut> opqdonut: when I type :i Either String Int I don't see the instance Monad. what's wrong?
04:29:54 <vermoos> or atom(s)
04:30:09 <edwardk> vermoos: its an accident of naming
04:30:12 <helmut> opqdonut: (in ghci, sorry forgot that detail)
04:30:24 <edwardk> vermoos: that 'atom' definition has to do with leibniz's monadology.
04:30:32 <edwardk> which is unfortunately completely unrelated
04:30:52 <pjd> Haskell monads are basically about structure
04:31:09 <opqdonut> helmut: see Control.Monad.Error
04:31:13 <pjd> they're data structures with certain useful properties
04:31:14 <opqdonut> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Error.html
04:31:15 <lambdabot> http://tinyurl.com/sw72f
04:31:30 <vermoos> edwardk a monad is (sort of) the smallest functioning unit of how an imperitive language works ?
04:31:44 <edwardk> in monadology a monad was supposed to be an indivisible unit of thought or an idea you couldn't parse apart any further so that if you constructed a language out of monads it would be completely unambiguous, and you could then build up a notion of perfectly meaningful discourse. alas, undecidability, Godel, etc. nipped that in the bud
04:31:56 <vermoos> edwardk and it is composed of the 'atoms' of the language (?)
04:32:11 <edwardk> vermoos: the monad we have now derives its name more from 'monoid' than leibniz's philosophy
04:32:18 <pjd> vermoos: it's probably better to consider a simpler structure first: functors
04:32:20 <scook0> "Unfortunately, no one can be told what The [Monad] is. You have to see it for yourself."
04:32:45 <vermoos> pjd i'm coming at it from python, and a bit of prolog
04:33:15 <pjd> if you understand list and map, then you just about understand Functors :)
04:33:32 <vermoos> pjd like in python, you don't bother declaring that a for loop uses iterables, its implicit
04:33:35 <pjd> a list is a functor
04:34:04 <edwardk> the term monad we use comes from the category theoretic monad, which basically says that if you have a category, and a monad on it, then you assert the existence of certain 'arrows'. viewing types as a kind of category, with functions as arrows, this implies the existence and equivalence of certain functions.
04:34:26 <edwardk> so a monad to us, just means that there are certain functions that exist and there are certain laws that say they are equivalent to other functions that exist
04:34:30 <DRMacIver> #haskell has a really funny instance of the standard net feature of a pile on.
04:34:39 <edwardk> so a monad is just a tool that lets us reason about code equationally
04:34:53 <edwardk> dr: heh yeah
04:35:05 <vermoos> edwardk right, so something like 'iterable' in python would have to be explicitly 'declared' in a haskell monad?
04:35:11 <DRMacIver> Normally someone new comes in and asks a (reasonably sensible, but lacking in knowledge) question and loads of people pile on to declare them a stupid newbie.
04:35:23 <DRMacIver> In #haskell everyone piles on to be as helpful as possible, drowning them in good will. ;)
04:35:33 <helmut> uhm. my ghci doesn't know about C.M.Error. do I need external libraries? (debian unstable)
04:36:01 <scook0> helmut: what GHC version?
04:36:05 <vermoos> i thunk i spotted some good will, i did i did!
04:36:06 <opqdonut> 6.6 here
04:36:12 <opqdonut> and C.M.E works
04:36:15 <DRMacIver> vermoos: You can regard iterables as quite a good instance of monads actually.
04:36:33 <Saul_> DRMacIver: Yeah I expierenced that yesterday :)
04:36:37 <pjd> lists :)
04:36:41 <DRMacIver> vermoos: My "What's a monad?" variant basically does something like that. :)
04:36:43 <edwardk> vermoos: well, monads are really general, almost everything turns out to be a monad. so if you think of monads as less of a 'thing' and more of 'set of laws' you can apply to a lot of situations, it might be clearer.
04:37:00 <helmut> ahh. it's a package and it contains Error. my fault
04:37:08 <DRMacIver> (Introduces monads by comparison with scala's sequence comprehensions)
04:37:13 <opqdonut> helmut: :)
04:37:39 <edwardk> that said, you can probably build up a container than holds things, and it'll probably be a monad in some sense, and you can then define a bunch of operations on it that let you iterate or fold over it, and the notions of catamorphisms and folds and things will be useful for that, but they aren't causative, they just happen to be there because of properties of the language
04:39:22 <pjd> vermoos: have you seen the Maybe data type before?
04:39:56 <vermoos> pjd is it a bisturbile cranabolic steroid ;/
04:40:08 <vermoos> pjd actually i have, just didn't 'get it'
04:40:10 <Syzygy-> o.O
04:40:18 <pjd> well, it's quite simple: data Maybe a = Nothing | Just a
04:40:42 <vermoos> | means ?
04:40:46 <pjd> or
04:40:53 <vermoos> doh!
04:41:14 <pjd> so that means it contains either nothing, or one value
04:41:19 <vermoos> so 'Maybe' explicitly declares that a is a variable
04:41:20 <vermoos> ?
04:41:31 <pjd> a type variable, yes
04:41:47 <edwardk> Maybe Int is a type, in that type are values of the form Just 1, Just 3, Just 123891823, and Nothing
04:41:55 <vermoos> and the rh side assigns whatever is in a to a itself
04:42:21 <pjd> hmm, are you familiar with Haskell data type declarations?
04:42:34 <edwardk> now, if i had a function that expected an Int and returned a Bool, there is a natural way to transform that function into one that expects a Maybe Int and returns a Maybe Bool
04:43:04 <vermoos> pjd oh ok its a data type not a monad - a monad would have :: in it ?
04:43:14 <edwardk> i can check to see if I got "Just something", and if so, apply my old function to something and wrap the result in a "Just". and if i got a "Nothing" i can just return "Nothing"
04:43:19 <pjd> right, that's just a data type
04:43:31 <pjd> :: is general syntax for type declarations; it's not a monad thing
04:43:42 <vermoos> pjd all data types are monads, but not all monads are data types
04:43:43 <pjd> (technically, monads in Haskell are a type class)
04:43:44 <edwardk> so if i have, say the function (\x -> x == 2)
04:43:52 <pjd> no, other way around :)
04:43:58 <edwardk> > (\x -> x == 2) 2
04:43:59 <pjd> some data types are monads
04:44:01 <lambdabot>  True
04:44:11 <edwardk> > fmap (\x -> x == 2) (Just 2)
04:44:14 <lambdabot>  Just True
04:44:36 <pjd> (just like some data types are numeric, or comparable;  they're all properties shared by multiple data types)
04:44:44 <Syzygy-> > fmap (\x -> x == 2) [1..]
04:44:46 <lambdabot>  [False,True,False,False,False,False,False,False,False,False,False,False,Fals...
04:46:16 <pjd> vermoos: one way to think of Maybe is as a strictly 0 or 1 element list
04:46:30 <vermoos> haskell is philosophy
04:46:45 <edwardk> vermoos: partly =)
04:47:17 <pjd> when you view it like that, it shouldn't be surprising that you can map a function over it, similar to normal lists
04:47:29 <edwardk> really heavily getting into haskell was the first time i felt like I learned something in computer science in years.
04:47:45 <pjd> edwardk: amen
04:47:46 <DRMacIver> I've been wondering if the fact that Haskell forces you to think about things is actually a good thing.
04:48:02 <pjd> it's a glorious thing
04:48:29 <DRMacIver> I mean, I enjoy it, but that may be strongly correlated with the fact that I don't use Haskell to write really tedious business logic, etc. for work. :)
04:48:58 <edwardk> drmaciver: i like that it elevates the level of discussion. i don't so much like the fact that i can't readily use many of the techniques that make haskell so succinct when at the office though ;)
04:49:09 <pjd> vermoos: care to guess how it would work to map a function over Maybe?
04:49:12 <DRMacIver> edwardk: Yes, that's a definite problem too.
04:49:17 <pjd> (assuming you're familiar with mapping functions over lists)
04:49:52 <DRMacIver> edwardk: Although I've intermittently stolen some ideas from Haskell to use in Java.
04:50:05 <LoganCapaldo> ghc -fvia-Java
04:50:09 <LoganCapaldo> :0
04:50:29 <DRMacIver> LoganCapaldo: The generated Java wouldn't meet our work coding standards. ;)
04:50:31 <wli> JVM back-end or Haskell-to-Java transformations?
04:50:52 <vermoos> pjd map ( (maybe) 99 ) [1..10]
04:50:55 <DRMacIver> (Well, I guess I mostly use it at home anyway)
04:51:22 <pjd> vermoos: nah, i mean with Maybe as the data type, instead of normal lists :)
04:51:34 <edwardk> i've grown to appreciate how nice haskell is by going off and trying to rebuild something like-it but not-it. you realize quickly how sweet a spot in the design space it has hollowed out for itself.
04:51:44 <pjd> what would map double (Just 5) do?
04:51:55 <edwardk> unraveling any one decision leads to having to unravel a LOT of others
04:52:09 <vermoos> pjd would it return Just 10 ?!
04:52:14 <pjd> yep!
04:52:32 <pjd> just like map double [5] = [10]
04:52:33 <edwardk> and map double Nothing?
04:52:52 <vermoos> pjd it's weird how asking (and answering) simple questions can clarify stuff !! :)
04:52:58 <DRMacIver> edwardk: Out of curiousity, how (and why) are you implementing it?
04:53:02 <pjd> :)
04:53:24 <wli> edwardk: In my case I want to build something for students that does step-by-step simplification, sort of like calc101.com, but covering different subject areas. It's been a back burner project for years.
04:53:26 <edwardk> dr: i have an interpreter for enough of the language to bootstrap it and i've been working on building up a compiler in the language itself.
04:53:27 <vermoos> pjd did you know that the 'bandwidth' of the conscious human mind is 1/1000000 th that of the subconscious?
04:53:37 <vermoos> a millionth!
04:54:16 <edwardk> drmaciver: the interpreter is written in haskell, the compiler targets x86-64 assembly right now, but that may change
04:54:52 <Lemmih> vermoos: How do you measure the bandwidth of a mind?
04:54:54 <wli> edwardk: The big issues seem to be that CAS methods emphasize different things and so don't cover the problems very much or very well.
04:55:07 <pjd> vermoos: what do you think about edwardk's "map double Nothing" question?
04:55:46 <edwardk> wli: yeah, before i switched to thinking in haskell i was obsessed with designing a CAS. now i've mostly subsumed those goals with my numerical tower. =)
04:55:54 <vermoos> pjd it would return Just 0 (?)
04:56:07 <wli> edwardk: Probably the two biggest are (a) simplifying radical expressions (b) simplifying algebraically dependent transcendentals.
04:56:14 <pjd> map double (Just 0) would return Just 0 :)
04:56:23 <DRMacIver> edwardk: What's it for? :)
04:56:34 <pjd> think about the empty list;  what happens when you map over it?
04:56:56 <wli> edwardk: I only ever look at it once in every couple of months, so I'm scarcely obsessed. It's also far short of a CAS.
04:57:22 <LoganCapaldo> vermoos, think about what map knows, and what double knows. double only knows it's input, and it can only output based on that input. map only knows about Maybes and how to extract values from Maybe and to put values into Maybe
04:57:52 <edwardk> drmaciver: the language exists primarily for me to explore the neighboring design space around haskell, to see how practical subset types can be with type inference, what a haskell like language with polymorphic extensible records, cases and variants would work like, since i have the subset types to catch the fallout from a lot of that, and what happens when you stick a lot of undecidable features together
04:58:03 <LoganCapaldo> map for instance, cannot create an arbitrary Just <something> value because it can't make up <somethings>s
04:58:15 <wli> edwardk: By and large I've not done much of anything in the way of code. I've largely put thought into algorithms for specific things like radical simplification.
04:58:21 <DRMacIver> edwardk: Cool.
04:59:00 <LoganCapaldo> So if it's Nothing, and that's all map has to work with and double needs some number to work on, than the only possible result for map double Nothing should be?
04:59:02 <edwardk> wli: i actually built a front end for the old CAS efforts as a firefox extension to avoid having to do cross platform gui work for mathematical syntax (i leveraged the mathml support mostly), etc.
05:00:13 <pjd> just remember: map double [5] = [10], map double [] = []
05:00:25 <wli> edwardk: There appear to be unsolved problems in/around radical simplification so I'm using it largely as something to research than implement anything of.
05:00:46 <vermoos> LoganCapaldo a default output of nothing, but not as a calculated result, only because double cannot double nothing (?)
05:00:59 <edwardk> wli: but then my internal world view switched pretty heavily when i flipped from thinking in Hoare triples and separation logic to a drinking the functional kool-aid
05:01:26 <pjd> vermoos: well, it's simply Nothing :)
05:01:39 <LoganCapaldo> vermoos, yes Nothing, not so much because double can't operate on Nothing but because map can't construct a useful vlaue for double to operate on from Nothing :)
05:01:45 <DRMacIver> pjd: just Nothing you might say? ;)
05:02:12 <pjd> No Thing, Just Nothing! :)
05:02:13 <edwardk> @src Maybe fmap
05:02:13 <lambdabot> fmap _ Nothing       = Nothing
05:02:13 <lambdabot> fmap f (Just a)      = Just (f a)
05:02:18 <pjd> there you have it
05:02:29 <wli> edwardk: My major coding efforts tend to center around the Linux kernel.
05:02:41 <pjd> so Nothing is like the empty list: there's no value inside to map, so it just stays the same
05:02:56 <LoganCapaldo> > mzero :: Nothing
05:02:58 <lambdabot>   Not in scope: type constructor or class `Nothing'
05:03:03 <LoganCapaldo> > mzero :: Maybe
05:03:05 <lambdabot>      `Maybe' is not applied to enough type arguments
05:03:05 <lambdabot>     Expected kind `?', b...
05:03:11 <LoganCapaldo> gah
05:03:14 <wli> pjd: It's just a coproduct without a fixpoint.
05:03:17 <LoganCapaldo> > mzero :: Maybe ()
05:03:18 <lambdabot>  Nothing
05:03:26 <pjd> now think about what the "List map" and the "Maybe map" have in common
05:03:28 <edwardk> wli: well, to pay the bills i mostly work on data mining stuff for large government project schedules. we all have to eat ;)
05:03:52 <pjd> they take a data structure and transform the elements using a function, while keeping the "shape" of the data structure the same
05:03:58 <vermoos> pjd, edwardk, LoganCapaldo, DRMacIver thanks everybody, i'm clicking slowly
05:03:59 <DRMacIver> edwardk: Sounds better than mine.
05:04:07 * DRMacIver chants the five days left mantra to calm down.
05:04:23 <pjd> as a quick diversion, without going into detail, think about trees
05:04:26 <edwardk> 5 days left?
05:04:30 <DRMacIver> Yeah
05:04:36 <edwardk> until?
05:04:40 <pjd> can you see how you would map a function over a tree structure?
05:04:47 <DRMacIver> As in "I only have to put up with writing dumb Java web applications at my current job for another 5 days" ;)
05:04:50 <wli> pjd: Apply a fixpoint operator to t' for Maybe (t, t') and you get lists.
05:04:51 <edwardk> ah
05:05:22 <edwardk> wli: i don't think that observation would be very useful to our guest though ;)
05:05:27 <pjd> wli: heavens;  i still need to crack my brain on that kind of thing :)
05:06:36 <mauke> newtype List a = List (Maybe (a, List a))
05:06:48 <LoganCapaldo> wli: Type level fixpoint? Neato :)
05:07:16 <DRMacIver> LoganCapaldo: It's the traditional abstraction for reasoning about recursive types like List. It's just that the language hides it rfom you. :)
05:07:39 <pjd> vermoos: with a tree, you would pretty much do the same thing as with lists: replace the contents of each node with the result of the function
05:07:40 <DRMacIver> Well. s/the/a/
05:07:54 <pjd> so you end up with the same kind of tree, just different node contents
05:08:14 <wli> LoganCapaldo: data Fix f = Fix (Fix f)?
05:08:28 <mauke> newtype Maybe a = Maybe (Either () a)
05:08:32 <edwardk> ListF a x = 1 + a * x      mu ListF a = 1 + a * ( 1 + (a * (1 + ...)))); blah blah blah =)
05:08:51 <pjd> it turns out that you can define this kind of map operation over many data structures:  it's the "functor" i was talking about
05:09:21 <edwardk> and mu or nu determine if you are talking about inductive (data/finite) lists or coinductive (codata/potentially infinite) lists
05:09:22 <pjd> so map is not just a list thing
05:09:36 <edwardk> though in haskell everything is codata so the question is moot
05:09:47 * wli mutters something about similar being the case for zip
05:10:04 <wli> edwardk: On account of laziness?
05:10:08 <edwardk> wli: yeah
05:10:21 <edwardk> wli: and the lack of non-pointed domains
05:10:41 <DRMacIver> Hm.
05:10:41 <pjd> vermoos: now, if you have a handle on functors, you are halfway to monads ;)
05:10:50 <edwardk> wli: nothing ever enforces well-foundedness.
05:10:53 <pjd> all monads are functors
05:10:54 <DRMacIver> That explains the embarassed comment in the comonads paper. :)
05:11:02 <wli> edwardk: I thought there were strict types floating around somewhere. I think ! or # or some such.
05:11:16 <vermoos> pjd fantastic!
05:11:17 <dcoutts> @tell ksfish yes, darcs send any iconv patches to me
05:11:17 <lambdabot> Consider it noted.
05:11:28 <DRMacIver> "Hey, codata lets us build infinite structures, which data doesn't! Err. Except in Haskell. Which is what we're writing about. Umm, yeah."
05:11:31 <dcoutts> oops
05:11:33 <edwardk> wli: sure, but you don't have any way to force that it terminates. you don't know well foundedness, you can spin infinitely during the seq.
05:11:50 <dcoutts> @tell kfish yes, darcs send any iconv patches to me
05:11:50 <lambdabot> Consider it noted.
05:12:02 <wli> edwardk: Well, that's coercion in the wrong direction.
05:12:16 <edwardk> nothing really enforces that something in haskell is either well-founded data or productive codata
05:12:30 <wli> edwardk: There's only an injection from an unpointed domain into a pointed one, but no reverse.
05:12:43 <edwardk> wli: exactly.
05:13:26 <wli> edwardk: You can write a program to work only in unpointed domains though I've no idea how you can generate the roots of the computation via IO.
05:13:51 <pjd> vermoos: oh, and i talked about monads having certain properties;  the same is true of functors
05:14:02 <edwardk> wli: but haskell doesn't generally have a way to say that something belongs to the unpointed one. you can fake it with strict functions but you can still get bottoms, because of general recursion, so you in effect get points again =)
05:14:19 <wli> edwardk: Anyway do you have any idea what a comonad is?
05:14:32 <edwardk> heh, i hope so =)
05:14:45 <edwardk> take a look at the name on http://comonad.com/
05:14:47 <edwardk> =)
05:14:58 <pjd> they're pretty obvious:  one is that mapping the identity function over a structure doesn't actually do anything
05:15:05 <edwardk> if the site is up
05:15:16 <edwardk> that'd be awfully embarrassing
05:15:29 <wli> edwardk: What's a comonad, anyway?
05:15:34 <wli> It's not.
05:15:44 <pjd> it should be easy to see how that property holds for lists and Maybe and so on
05:15:48 <pjd> with me?
05:16:03 <edwardk> bah, i'll have to offload it on my home machine, there have been network connectivity issues there all week
05:16:07 <edwardk> anyways
05:16:10 <scook0> edwardk: it appears the site is _|_ ;)
05:16:19 <wli> edwardk: I have my own vanity domain. ;)
05:16:25 <LoganCapaldo> non-terminating website!
05:16:42 * wli = wli@holomorphy.com
05:16:49 <opqdonut> non-terminating connection, rather :)
05:17:13 <wli> I'm kind of itching to get wordpress or some sort of LaTeX-capable blog bits going at some point if I can ever figure it out.
05:17:15 <edwardk> a comonad is just the categorical dual of a monad. if you want an analogy along the same way that people think of monads think of a comonad as a wrapper with a prize inside that may be valuable. sure you can discard the wrapper and have the candy, but you want to keep it around as long as possible
05:17:16 <LoganCapaldo> hmm yeah I guess a non-terminating website would be a buggy browser. :)
05:17:47 <DRMacIver> edwardk: Analogies suck. Use examples. ;)
05:17:50 <edwardk> so monads give you a way to wrap something in a way you can't get back out, comonads make it easy to extract
05:18:00 <mauke> <script language="javascript">while (1) {}</script>
05:18:07 <pjd> wli: comonads get described as "contexts"
05:18:09 <edwardk> the comonads that i found the most useful don't exist in the haskell category.
05:18:13 <etnt> I've started to read my old SPJ-book about impl.of.func.lang, are there any new books on this topic you would recommend ?
05:18:14 <wli> edwardk: type signature?
05:18:15 <LoganCapaldo> mauke, I _was_ going to say barring javascript
05:18:25 <DRMacIver> edwardk: Hm, such as?
05:18:30 <LoganCapaldo> but I figured I didn't have to. I guess I just asked for that one
05:18:41 <edwardk> if you start with a linear logic, then unrestricted use of a variable is a comonad that permits arbitrary contraction and weakening.
05:18:46 <edwardk> you can show it obeys all the laws
05:19:06 <DRMacIver> I have *no* idea what you just said. :)
05:19:22 <edwardk> wli: of a comonad?
05:19:44 <pjd> wli: if monads "expand" their elements and recombine them in some way
05:19:50 <wli> edwardk: hang on looking for Control.Comonad since I've not got it locally.
05:20:08 <edwardk> class Comonad w where extract :: w a -> a; extend :: (w a -> b) -> w a -> w b; duplicate :: w a -> w (w a)
05:20:45 <edwardk> note everything is just the dual of the Monad functions return, bind and join
05:21:08 <edwardk> you can define it with extract and duplicate or extract and extend deriving the third form
05:21:29 <mauke> duplicate = extend id?
05:21:39 <pjd> wli: then comonads duplicate (uncombine) themselves , and then collapse (unexpand) each of those back into a single element
05:21:43 <edwardk> mauke: yeah
05:22:26 <wli> I don't see Control.Comonad in the std libs yet.
05:22:27 <edwardk> and extend f x = fmap f (duplicate x)
05:22:39 <edwardk> wli: its because people haven't found good uses form them in haskell yet
05:22:44 <DRMacIver> wli: I don't think there's a good general Comonad library for Haskell yet.
05:23:17 <LoganCapaldo> Are Monads CoComonads? :)
05:23:22 <pjd> yep
05:23:23 <mauke> haha, that's like monads backwards in reverse
05:23:23 <wli> Arrows look kind of obfuscated.
05:23:28 <edwardk> i personally think the main reason is that there are so few in the "Hask" category because of the merger of data and codata.
05:24:27 <edwardk> and the fact that its hard to 'put back in the bag' a lot of the things the haskell allows just to permit them via the presence of a comonad.
05:24:32 <wli> arr and pure have the same type signature, for instance.
05:24:50 <edwardk> wli: arr and pure are the same function just different for historical reasons
05:25:01 <DRMacIver> I often import Control.Arrow to (ab)use its instance for functions. :)
05:25:02 <pjd> wli: so where list monad turns each element into a sublist of results, the list comonad *calculates* each element as a result of a sublist of contexts
05:25:09 <pjd> "where the list monad", even
05:25:09 <edwardk> when the paper was first written on them they took one name, when someone later rejiggered them, they chose another
05:25:13 <DRMacIver> But I've not gotten around to actually understanding it...
05:25:21 <edwardk> like how early haskell papers call 'return' 'unit' alot
05:25:22 <wli> pjd: nice
05:25:25 <scook0> DRMacIver: (>>>) and (<<<) are lovely :)
05:25:28 <pjd> wli: think cellular automatons
05:25:37 <DRMacIver> scook0: I think &&& is the one I use the most.
05:26:00 <wli> (&&&) is like my fzip
05:26:02 <LoganCapaldo> Can I travel back in time and ensure that unit ends up being the function name instead of return? :)
05:26:13 <pjd> wli: the tree analogue would be recalculating each node based on its subtree
05:26:14 <edwardk> wli: anyways, are you comfortable with adjoint functors?
05:26:18 <wli> (***) is sort of a dual concept
05:26:54 <DRMacIver> scook0: I don't think I see why >>> and <<< are especially useful...
05:26:58 <wli> edwardk: I can sort of understand what people are saying when they talk about them but I'm no good at using them to prove anything.
05:27:17 <DRMacIver> They're just . and flip (.) aren't they?
05:27:19 <edwardk> "Hom and Prod form an adjunction" which basically is a fancy way of saying you can curry and uncurry. so there is a relationship between (,) and (->). well (->)e is a Monad, and via the adjunction you can show that (,)e is a Comonad
05:27:21 <wli> DRMacIver: (>>>) looks like function composition.
05:28:01 <edwardk> i.f you go look at the class signature above, the definition of it form (,)e becomes obvious
05:28:05 <wli> edwardk: That works.
05:28:20 <edwardk> @djinn (e,a) -> a
05:28:20 <lambdabot> f (_, a) = a
05:28:32 <DRMacIver> wli: Yes, that's what I mean. :) I don't see why they'd be useful except when dealing with non function arrows.
05:28:37 <wli> edwardk: So fzip turns out to be something special.
05:28:44 <scook0> DRMacIver: it's nice for composing Kleisli arrows (i.e. functions into monadic types)
05:28:51 <edwardk> @djinn ((e,a) -> b) -> (e,a) -> (e,b)
05:28:51 <lambdabot> f a (b, c) = (b, a (b, c))
05:28:59 <wli> DRMacIver: I can't think of what a non-function arrow would look like.
05:29:08 <edwardk> @djinn (e,a) -> (e,(e,a))
05:29:08 <lambdabot> f (a, b) = (a, (a, b))
05:29:14 <DRMacIver> scook0: Ah, right. I thought that was a follow on to my using Control.Arrow for its function instance. :)
05:29:24 <scook0> and (>>>) can be infix, which (flip (.)) can't be
05:29:27 <edwardk> and djinn strikes again, deriving for us our comonad =)
05:29:38 <edwardk> fzip?
05:29:39 <EvilTerran> (>>>) and (<<<) are bigger, so may offer visual clarity over (.), too
05:29:43 <scook0> DRMacIver: (>>>) is still good for functions
05:29:50 <DRMacIver> I suppose, yes.
05:30:07 <Philippa> DRMacIver: by "non-function arrows" do you by any chance mean all arrows except the identity arrow?
05:30:17 <DRMacIver> Philippa: Yes. :)
05:30:39 <mauke> non-elephant biology?!?!
05:31:09 <DRMacIver> Philippa: It makes sense given that my part in this discussion was started with my saying that I tend to import Control.Arrow because the operators it exposes are convenient for combining functions.
05:31:10 <EvilTerran> well, all monads are arrows, are they not?
05:31:27 <pjd> EvilTerran: other way around, i think
05:31:33 <scook0> EvilTerran: well, all monads give rise to an arrow
05:31:37 <DRMacIver> (Rather than because I'm actually using arrows as a decent abstraction)
05:31:38 <wli> DRMacIver: Looks like fzip is automatic.
05:31:41 <scook0> not all arrows represent monads
05:31:43 <edwardk> wli: anyways an interesting consequence of the way adjoint functors work is that every time you have a pair of adjoint functors if you compose them one way you get a monad and if you compose them the other way you get a comonad.
05:31:44 <Philippa> EvilTerran's got it right give or take scook0's clarification
05:32:01 <pjd> scook0: oh, right
05:32:07 <EvilTerran> likewise (w/ scook0's clarification) for comonads
05:32:13 <DRMacIver> wli: Indeed. :)
05:32:20 <edwardk> so if you are hunting for comonads, find a pair of adjoint functors, figure out the monad, which you should recognize without much effort and turn around and examine the corresponding comonad
05:32:38 <pjd> edwardk: that sounds like a very nifty trick
05:32:54 <wli> edwardk: And if the category theory is too high-flown, use the currying/uncurrying interpretation.
05:32:57 <DRMacIver> Anyway, this is very interesting, but I'm off to go shopping. :)
05:33:14 <edwardk> wli: yeah. =)
05:33:36 <pjd> i don't suppose there's a short explanation of adjoint functors somewhere?
05:33:48 <edwardk> http://en.wikipedia.org/wiki/Adjoint_functors
05:33:50 <edwardk> =)
05:33:54 <wli> edwardk: I think some of these arrow things can be phrased in terms of paramorphism, hylomorphism, catamorphism, anamorphism, etc.
05:34:23 <edwardk> well, comonads and monads have a nice roll to play in catamorphisms and anamorphisms
05:35:05 <wli> edwardk: ArrowLoop looks pertinent to either paramorphisms, hylomorphisms, or both.
05:35:30 <edwardk> i can parameterize a catamorphism with a comonad and a distributivity law for that comonad over my functor. i can also parameterize an anamorphism with a monad and a distributivity law over the functor.
05:35:55 <edwardk> as special cases of that you get general recursion and general corecursion respectively
05:36:01 <pjd> edwardk: if you don't mind explaining, what's an example of them in Haskell?
05:36:22 <wli> edwardk: Which is sort of obvious because monads inject and never project, and comonads project and never inject.
05:36:41 <edwardk> pjd: of parameterizing a catamorphism with a comonad?
05:36:53 <pjd> no, adjoint functors :)
05:37:02 <edwardk> @type curry
05:37:06 <edwardk> @type uncurry
05:37:10 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
05:37:14 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
05:37:15 <wli> So anamorphisms lead to monads and catamorphisms lead to comonads.
05:37:56 <pjd> edwardk: oh, ok
05:38:07 <LoganCapaldo> oh snap. so type F a b c = (a, b) -> c and type G a b c = a -> b -> c and F and G are adjoint functors?
05:38:25 <fasta> There is no delete_index function for lists?
05:38:35 <pjd> edwardk: are (->) and (,) the functors in that?
05:38:36 <Philippa> is it valid to talk about catamorphisms on infinite objects?
05:38:40 <LoganCapaldo> @type (//)
05:38:44 <lambdabot> forall i e. (Ix i) => Array i e -> [(i, e)] -> Array i e
05:38:45 <edwardk> not sure they 'lead' to in the sense you are getting at, since a catamorphism is just a particular initial f-algebra for instance, but you can use them together in the presence of the law.
05:38:50 <LoganCapaldo> err
05:38:54 <LoganCapaldo> that's not it
05:39:05 <LoganCapaldo> @type (\\)
05:39:08 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
05:39:11 <fasta> LoganCapaldo: that's not it
05:39:13 <Philippa> only if so then a lot of monads are also expressible as (generalised) catamorphisms on GADTs
05:39:18 <LoganCapaldo> fasta, I try
05:39:25 <mauke> @pl \i xs -> let (a, b) = splitAt i xs in a ++ drop 1 b
05:39:26 <lambdabot> (line 1, column 14):
05:39:26 <lambdabot> unexpected "("
05:39:26 <lambdabot> expecting natural, identifier or "in"
05:39:39 <Shine> edwardk: the Wayback Machine has an old version of the commonad.com site: http://web.archive.org/web/*/http://comonad.com
05:39:44 <LoganCapaldo> since I can't understand this category theory nonsense :)
05:39:44 <edwardk> Philippa: hasskell plays kind of fast and loose with catamorphisms
05:40:10 <edwardk> since we don't have a notion of well-founded data
05:40:13 <olsner> someone should re-express all these concepts as programming rather than math - then they might become useful!
05:40:15 <fasta> I am actually a proponent of "fat interfaces" that express one semantic action a data structure.
05:40:17 <Philippa> edwardk: yeah, insofar as all our initial algebras are also final coalgebras
05:40:28 <fasta> Not the interface like in Java, though.
05:40:36 <edwardk> yeah, mu and nu kind of get conflated as a result
05:41:04 <edwardk> lets us have hylomorphisms though
05:41:07 <fasta> Seeing that my "Util" library is almost as large as xmonad...
05:41:24 <fasta> (Util contains everything that should be in the libraries)
05:41:24 <edwardk> Shine: thanks
05:41:31 <Philippa> yep. I'm thinking about whether there're some funky deforestation tricks that can be played with many monad implementations
05:41:58 <Philippa> even if it just makes the style of implementation with an "AST" type involved as cheap as not having one
05:42:12 <Philippa> though I suspect there may be further opportunities in places
05:42:36 <edwardk> Shine: its a little weird without all the latex images =)
05:42:44 <LoganCapaldo> @type \n xs -> map snd . filter ((/= n) . fst) $ zip [0..] xs
05:42:46 <lambdabot> forall a b. (Num a, Enum a) => a -> [b] -> [b]
05:42:55 <LoganCapaldo> err
05:43:40 <LoganCapaldo> oh wait that was right
05:43:50 <LoganCapaldo> I got thrown off by seeing the Enum in there
05:44:30 <LoganCapaldo> > (\n xs -> map snd . filter ((/= n) . fst) $ zip [0..] xs) 3 [4,7,2,-1,6,5]
05:44:34 <lambdabot>  [4,7,2,6,5]
05:45:08 <LoganCapaldo> > (\n xs -> map snd . filter ((/= n) . fst) $ zip [0..] xs) 1000 [1..]
05:45:11 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
05:45:18 <fasta> delete_index i xs = let (left, right) =  splitAt i xs in init left ++ right
05:45:42 <LoganCapaldo> what, I can't write it the stupid way? :)
05:46:10 <Saizan> > let delete_index i xs = let (left, right) =  splitAt i xs in init left ++ right in delete_index 0 [1..5]
05:46:12 <lambdabot>  Exception: Prelude.init: empty list
05:46:32 <LoganCapaldo> > (\n xs -> map snd . filter ((/= n) . fst) $ zip [0..] xs) 0 [1..5]
05:46:34 <lambdabot>  [2,3,4,5]
05:46:42 <fasta> Sure it needs some testing...
05:46:51 <edwardk> wli: anyways, the monadic anamorphism relies on the fact that you have some sort of distributive law that lets you 'push the monad inside' the functor  m (f b) -> f (m b), and that you use it with your function to unroll your value a -> f (m a)  to keep from ever having to actually get to the monad.
05:47:02 <Saizan> > let delete_index i xs = let (left, right) =  splitAt i xs in left ++ (drop 1 right) in delete_index 0 [1..5]
05:47:04 <lambdabot>  [2,3,4,5]
05:47:32 <fasta> No, it doesn't.
05:47:37 <fasta> My indices start at 1
05:47:59 <fasta> But it might be that I should change that, since the rest of the libs start also at 0.
05:48:06 <Saizan> yeah :)
05:48:27 <wli> edwardk: i.e. the implied diagram commutes
05:48:32 <edwardk> wli: yep
05:48:37 <fasta> I wrote it to compare to another structure that has "ranks" and a rank of zero is pretty lame.
05:49:02 <LoganCapaldo> > (\start n xs -> map snd . filter ((/= n) . fst) $ zip [start..] xs) 1 2 [1..5]
05:49:04 <lambdabot>  [1,3,4,5]
05:49:25 <fasta> LoganCapaldo: you don't get extra points for burning CPU cycles.
05:49:43 <LoganCapaldo> good thing I'm not keeping score then
05:49:52 <dnox> well haskell is good at burning cpu cycles
05:50:30 <wli> edwardk: nonempty lists
05:51:06 <edwardk> anyways, i need to get some sleep
05:51:54 <edwardk> night all
05:53:03 <fasta> delete_index i xs = let (left, right) =  splitAt i xs  in left ++ tail right
05:53:41 <LoganCapaldo> > drop 1 []
05:53:43 <lambdabot>  []
05:53:45 <LoganCapaldo> > tail []
05:53:47 <lambdabot>  Exception: Prelude.tail: empty list
05:54:07 <Jaak> > drop 1 []
05:54:09 <lambdabot>  []
05:54:12 <wli> join is a little interesting
05:54:49 <fasta> LoganCapaldo: that only happens when the index doesn't exists.
05:54:59 <fasta> LoganCapaldo: and arguably should give an error then.
05:56:00 <wli> join :: (Monad m) => m (m a) -> m a ; cantor :: forall a. [[a]] -> [a] ; cantor = concat . f where f (x:xs) = [head x] : zipWith (:) (tail x) (f xs)
05:56:38 <wli> I suppose if I put more effort into it, I could get a version of that that works when things are finite, too.
05:56:49 <mauke> hahaha
05:57:07 <LoganCapaldo> fasta, mmm hmm. I can see it going either way for sure. Most likely though you're gonna want to know about deleting non-existant indexes
05:57:07 <mauke> haskell is great :-)
05:57:41 <fasta> LoganCapaldo: yes, both ways have arguments.
05:58:22 <Codex_> wli: cantor = x < 2^x?
05:58:29 <fasta> I wish the Prelude functions were all in type classes by default; e.g. a class Reversable, Null, etc.
05:58:56 <mauke> that leads to interesting type signatures
05:59:00 <fasta> Now, every user is going to make class IsReversable, Reversable, Reversed, etc.
05:59:10 <wli> Codex_: No, it uses one of his diagonalization constructions for the countability of Z x Z.
05:59:26 <wli> Codex_: N x N really.
05:59:39 <fasta> mauke: I know, but generic code always has that.
05:59:54 <fasta> mauke: unless it's something like Scheme
05:59:57 <Codex_> wli: NxN->Y?
06:00:23 <wli> Codex_: No, he constructs a surjective function from N to N x N.
06:00:56 <wli> Codex_: The surjection is pretty much exactly what I've got there.
06:01:49 <wli> take 10 $ cantor [[(i,j)|j<-[0..]]|i<-[0..]]
06:01:49 <wli> [(0,0),(0,1),(1,0),(0,2),(1,1),(2,0),(0,3),(1,2),(2,1),(3,0)]
06:03:02 <Codex_> wli: that doesnt look like diagonalisation :-)
06:03:22 <LoganCapaldo> Traversable and Foldable, etc. are close to generalizing the list functions at least, but I can't find a reverse
06:03:26 <wli> Codex_: It walks the diagonals.
06:03:42 <Codex_> dont you like have to take the diagonal? (0,0), (1,1), (2,2), ... (x,x) ?
06:04:05 <wli> Codex_: It's not the diagonalization argument for nonexistence involved here.
06:04:32 <Codex_> then I have no idea what it is :)
06:04:50 <wli> Codex_: It's the surjection (really bijection) constructed to prove that |NxN|=|N|.
06:06:13 <Codex_> wli: oh that. Basic property of infinite sets. :)
06:08:07 <wli> You can actually get equations for all this.
06:11:53 <wli> There are k+1 pairs (i,j) s.t. i+j=k, so j + \sum_{m=0}^{i+j-1} (m+1) = i + 2j - 1 + (i+j-1)(i+j)/2 gives you an idea of where you start.
06:13:24 <Codex_> wli: it relies on the fact that fibers are finite length?
06:14:22 <wli> You can do similar constructions with hyperplanes (affine spaces of dimension d-1 on N^d) but they're more painful.
06:15:58 <wli> Codex_: More that there are O(n^{d-1}) solutions in nonnegative integers of \sum_t i_t = n.
06:18:51 <wli> \sum_{t=1}^d i_t = n really.
06:21:19 <wli> The way to get it is to sum over choices of i_d, so you get d-1 integers summing to n-i_t for 0 <= i_t <= n. Then you use the expression for the prior dimension and sum it.
06:21:33 <wli> So you're essentially dealing with iterated summation.
06:23:17 <wli> Choosing an appropriate basis for polynomials in n (e.g. C(n,k) for 0 <= k <= deg(p) etc.) then gets you an easy expression.
06:28:29 <wli> For d=2 you can at least figure out which root is negative vs. which is positive. For d=3 it's not entirely obvious which is real, never mind positive or negative, d=4 likewise. d=5 and it's no longer solvable in closed form AFAIK (though it could, in theory, lie within a family of solvable quintics). In any event, even if you can't invert it in closed form, you can get a surjection that's furthermore 1:1.
06:29:09 <wli> That is, from N^d onto N.
06:30:32 <wli> It's still not entirely clear to me how to do the N^d variant or I'd long-since have done it. It doesn't even look doable in the type system.
06:33:04 <wli> I'd basically want grlex on [[...[[(i_1,i_2,...,i_d1,i_d)|i_d<-[0..]]|i_d1<-[0..]]|...|i2<-[0..]]|i1<-[0..]]
06:37:13 <wli> So for [[[(i,j,k)|k<-[0..]]|j<-[0..]]|i<-[0..]] I'd want [(0,0,0),(0,0,1),(0,1,0),(1,0,0),(0,0,2),(0,1,1),(1,0,1),...]
06:45:07 <fasta> @pl (flip a) 1
06:45:07 <lambdabot> flip a 1
06:45:37 <psykotic> wli: btw do you know about using feigenbaum trees for enumerating the rationals? it's a lot nicer than enumerating pairs (m,n) ordered by m+n, using a map to keep track of dupes.
06:46:26 <DRMacIver> I think that's in "Proofs from the Book". :)
06:46:33 <psykotic> yeah probably.
06:46:47 <psykotic> my copy of that is in denmark. i miss it but can't justify buying it again. :(
06:47:01 <psykotic> that also has my favorite proof of the infinitude of primes.
06:47:07 <psykotic> (using euler's product formula for the zeta function)
06:47:18 <DRMacIver> Nonsense. The topological one is far cooler. :)
06:47:35 <psykotic> is that the one dealing with density or something?
06:47:38 <psykotic> i don't recall the details
06:48:24 <DRMacIver> You construct a topology on Z such that all the open sets are infinite and form some union { F_p : p in P } where each F_p is closed. This union is all numbers except {-1, 1}, which isn't an open set, hence the union wasn't closed, hence it can't be a finite union.
06:48:30 <DRMacIver> Therefore there are infinitely many primes. QED. :)
06:48:57 <DRMacIver> I think the topology is the one generated by all infinite arithmetic sequences.
06:49:04 <DRMacIver> And F_p is { pn : n in Z }
06:49:20 * DRMacIver thinks harder.
06:49:23 <DRMacIver> In fact I'm certain of it. :)
06:49:51 <psykotic> so what's the key idea in the proof?
06:50:01 <psykotic> oh, i see.
06:50:55 <psykotic> there are also some cute ideas in analytical number theory for proving this.
06:51:00 <DRMacIver> Key idea: Each F_p is closed. Union F_p is not closed. Therefore P cannot be finite.
06:51:07 <DRMacIver> Yeah. There are all sorts of cute proofs. :)
06:51:08 <psykotic> essentially some very rough bounds
06:51:16 <psykotic> so easy to prove, but sufficient to provide infinitude
06:51:32 <DRMacIver> Even more than of the fundamental theorem of algebra (I think I got up to 7 or 8 different proofs of that before I got bored)
06:51:41 <psykotic> the fundamental theorem of algebra is nice that way, yeah
06:51:49 <psykotic> i guess i only know about four off-hand.
06:51:59 <DRMacIver> I doubt I could reproduce most of those these days.
06:52:08 <psykotic> a simple elementary one, one using galois theory, one using fundamental groups, another using complex analysis (contour integration).
06:52:22 * DRMacIver 's maths is super rusty. :(
06:52:26 <psykotic> actually the elementary one isn't so simple, it's really tedious
06:52:44 <psykotic> very brute force, with a lot of epsilon delta style juggling. ugh.
06:53:05 <psykotic> i remember we were shown it in our first semester as an example of how to prove the result by brute force, so we'd appreciate the more fancy proofs.
06:53:19 <psykotic> actually, i guess the complex analysis proof doesn't use brute force, it uses that theorem about entire functions being constant.
06:53:34 <psykotic> can't remember its name, because my maths is super rusty too :)
06:53:44 <DRMacIver> Liouville's theorem I think.
06:53:50 <DRMacIver> (You mean bounded entire functions)
06:53:55 <psykotic> right, yes
06:54:09 * Syzygy- recently worked through Peter May's proof of the fundamental theorem of algebra.
06:54:15 <DRMacIver> Which one is that?
06:54:19 <Syzygy-> It's one of the fundamental group arguments I've seen.
06:54:20 <psykotic> the fundamental group one
06:54:26 <psykotic> that book of his is unreadable.
06:54:27 <DRMacIver> Ah
06:54:28 <Syzygy-> I think I've seen 2...
06:54:43 <Syzygy-> psykotic: Most of his writing is unreadable. OTOH, the ideas  - once you get hold of them - are FUNKY.
06:54:48 <psykotic> i know.
06:54:54 <psykotic> but honestly, if i was learning about fundamental groups for the first time...
06:55:05 <psykotic> i'm pretty sure i wouldn't want 10 pages of abstract nonsense about orbit categories
06:55:18 <david48> Hi
06:55:25 <Syzygy-> I'd poke people towards Brown instead unless they were deeply embedded in "normal" algebra.
06:55:31 <Syzygy-> Fundamental groupoids!!
06:55:34 <psykotic> hatcher is good for geometric intuitions
06:55:45 <psykotic> but yeah, it's nice that he looks at it as a groupoid.
06:55:50 <psykotic> since that's the natural structure.
06:55:54 <psykotic> (unless your space is pointed)
06:56:14 <david48> Anyone here has some experience with Gtk2Hs ?
06:56:33 <Syzygy-> psykotic: And you tend to only point your spaces if you do groups anyway.
06:56:40 <Syzygy-> Oh - this was #haskell? *hrm* Ooops.
06:56:42 <psykotic> Syzygy-, i heard they actually use that book for the graduate course on algebraic topology at uchicago.
06:56:46 * Syzygy- sincerely thought it was #math
06:56:55 <Syzygy-> psykotic: The Brown book? Respect.
06:56:55 <psykotic> it seems really silly.
06:56:59 <psykotic> oh, no, the may one.
06:57:03 <psykotic> and it's a first algtop course.
06:57:03 <Syzygy-> Oh.
06:57:04 <Syzygy-> Yikes.
06:57:12 <psykotic> i think it's stupid math machismo.
06:57:21 <psykotic> it's like... "class, this lecture we're going to do k-theory."
06:57:25 <psykotic> seems pointless.
06:57:28 <Syzygy-> david48: There are people here with a lot of experience with Gtk2Hs. Alas I'm not one of them.
06:57:44 <Syzygy-> psykotic: So ... you're saying they're doing synthetic alg.top. while they're at it?
06:57:54 <Syzygy-> Or did you use "pointless" in a sane way?
06:57:55 <psykotic> synthetic in what sense? you mean axiomatic?
06:58:02 <psykotic> in the vulgar way :)
06:58:07 <Syzygy-> Ah, right.
06:58:10 <psykotic> not in the abstract nonsense way, haha
06:58:11 <david48> Syzygy: Thanks for replying though :)
06:58:15 <Syzygy-> @pl algebraic topology
06:58:15 <lambdabot> algebraic topology
06:58:45 <Syzygy-> Ummm, should we possibly migrate the topology - lovely as it is - to a more appropriate channel?
06:58:58 <Syzygy-> Or should I start arguing about how to implement it in Haskell, to get back on topic?
06:59:03 <psykotic> i need to do something else anyway, so i won't dirty up the place any longer :)
06:59:10 <psykotic> actually that would be interesting.
06:59:13 <psykotic> have you looked at kenzo?
06:59:30 <Syzygy-> Yeah. Hate it.
06:59:49 <Syzygy-> There's research being done in Spain that's pretty close to my own, which builds on top of Kenzo.
06:59:53 <psykotic> i tried understanding the theory behind the calculational tools, but spectral sequences scare me.
07:00:06 <Syzygy-> I tried to look at it, tried to use it, tried to read it, and I will do anything to avoid ever dealing with it again.
07:00:19 <psykotic> and the code is _horrible_
07:00:21 <Syzygy-> My project for the winter is to duplicate parts of it in Magma, for my thesis.
07:01:25 <psykotic> by the way, sort of related--
07:01:37 <psykotic> do you know of any work done in semi-automated theorem proving/reasoning via diagram chasing
07:01:50 <psykotic> it is so mechanical already that it seems like a proof assistant approach would be really useful/doable
07:01:51 <Syzygy-> Nope.
07:01:58 <Syzygy-> But it sounds like a cool idea.
07:02:35 <Syzygy-> As I learned homological algebra the first time around, we were taught a "meta-theorem": if you can find a chain of arrows, regardless of directions, that lead you from one object to another, then there will probably be a well defined module map there.
07:02:57 <psykotic> i also think something like what i'm describing would be a great teaching tool
07:03:18 <psykotic> when i was learning algtop i was already stumped by all the homological algebra, because until diagram chasing clicks it is a total stumper
07:03:24 <psykotic> and once you get it, you can do it in your sleep.
07:03:52 <psykotic> i'm pretty sure if you woke me up suddenly in the depth of night and asked me to do prove the snake lemma, i could do it, despite being out of math for a long time :)
07:04:22 <pjd> psykotic: are you familiar with Stern-Brocot and/or Calkin-Wilf trees?
07:04:32 <pjd> (regarding enumerating the rationals)
07:04:32 <Syzygy-> The click of diagram chasing is one of my prime descriptions of the rush of understanding: I used to despair for weeks about it, then I read Weibel - who writes it out horribly long - and all of a sudden I just knew how it works.
07:04:34 <psykotic> pjd: err, yes. i said feigenbaum trees but i meant stern-brocot. oops.
07:04:36 <erider> good morning
07:04:46 <Syzygy-> Nowadays, I cannot remember wat it feels like not to know.
07:04:52 <DRMacIver> I'm pretty sure if you woke me up suddenly in the depth of night and asked me to prove the snake lemma, I'd shout "Who the fuck are you and what are you doing in flat?!"
07:05:13 <pjd> oh, sorry, i see you were responding to wli
07:05:13 <psykotic> Syzygy-, i'm trying to remember where i learned it. i think actually in some online lecture notes, where the author wrote out each "snapshot" of the diagram explicitly. it's horrible to convey on a page.
07:05:45 <psykotic> Syzygy-, and i learned it by myself, since i was a freshman at the time. so it was a lot of pain followed by the light of understanding. very awesome feeling, yes.
07:06:34 <psykotic> some linked me to a book that apparently does undergraduate-level algebra from the abstract nonsense angle, using a lot of explicitly drawn out diagram chases.
07:06:42 <psykotic> i expect the book will be 3000 pages long :)
07:06:57 <Syzygy-> psykotic: Riiiiight.
07:07:10 <Syzygy-> At that point, you'll start wanting to build animations...
07:07:31 <psykotic> that's part of what i wanted to do with that diagram chaser program i mentioned.
07:07:50 <Syzygy-> Yah
07:08:39 <dcoutts> david48: did you have a specific question about Gtk2Hs ?
07:08:51 * dcoutts is a Gtk2Hs developer
07:09:02 <david48> dcouts: yes !
07:09:20 <Syzygy-> david48: Seee! I told you there are people here who know it! :)
07:09:21 <david48> I'm writing a question for haskell cafe, with code, I can paste it to hpaste
07:09:28 <dcoutts> ok
07:10:03 <dcoutts> david48: a better list for that Q might be the gtk2hs-users list btw, but you can ask me first I might have a quick answer
07:10:43 <david48> damn, it looks like hpaste is down
07:11:37 <david48> dcoutts: Actually I have many questions. I'm trying to learn Gtk2Hs, and I'm a beginner in Haskell as well.
07:11:43 <david48> first one
07:11:55 <david48> I made a simple program with Glade designer
07:12:03 <david48> in that program there's a textview
07:12:08 <Choko_> psykotic: concrete abstract algebra by niels lauritzen :)
07:12:35 <psykotic> choko: funny, he was my lecturer.
07:12:38 <david48> I want to have a "trace' function that takes a string and writes it to the textview, but I'd like to avoid passing it the textview everytime
07:12:48 <dcoutts> I think there's a lisppaste thing people have been using, not sure of the url, perhaps someone else knows
07:12:56 <david48> I couldn't find a nice way to do it.
07:13:14 <DRMacIver> http://paste.lisp.org
07:13:19 <dcoutts> DRMacIver: thanks :-)
07:13:23 <fasta> Anyone who knows Perl here? I have a exec "ls"; and I would like to pipe that to grep.
07:13:24 <dcoutts> david48: ^^
07:13:34 <dcoutts> fasta: try #perl ? :-)
07:13:56 <Choko_> psykotic: unfortunately was he in USA when i had the algebra course last fall :(
07:14:26 <psykotic> Choko_, you're at aarhus? i heard they screwed up the curriculum there.
07:14:36 <Choko_> yes at daimi
07:14:39 <psykotic> i was a freshman there in, i guess, 2003 or 2004
07:15:08 <david48> dcoutts : http://paste.lisp.org/display/44137
07:15:10 <psykotic> (not at daimi, the math dept)
07:15:32 <psykotic> like, i heard they replaced the first semester course on introductory real analysis by a plug and chug calculus course.
07:15:37 <psykotic> glad i didn't have to be exposed to that crap.
07:16:15 <Choko_> heh it's a calculus for everyone at natural science, it's pretty easy :(
07:16:40 <wli> dumbing down, eh?
07:16:56 <psykotic> yep
07:17:08 <psykotic> that old intro analysis course culled a lot of wimps, i guess they had to change it :)
07:17:13 <psykotic> it was sort of at the level of baby rudin
07:17:23 <psykotic> page 1: axioms for fields. :)
07:17:31 <psykotic> that was the first math course for both computer scientists and mathies.
07:18:21 <pejo> fasta, exec "ls | grep whatever" ought to work, no?
07:18:51 <fasta> pejo: and how do I specify the regexp then? I mean the quoting.
07:18:56 <psykotic> Choko_, do they teach you haskell there for freshmen?
07:18:59 <fasta> pejo: single quotes?
07:19:01 <wli> Arguably things should be getting pushed in the other direction.
07:19:14 <Choko_> psykotic: they did last year
07:19:17 <wli> e.g. trying to get Baby Rudin -level things into HS.
07:19:18 <psykotic> that's nice
07:19:36 <Choko_> but this year vi had scheme and ml at our programming language course
07:19:48 <Choko_> and olivier danvy as lecturer :)
07:19:49 <psykotic> is that a 1st quarter course?
07:20:07 <Choko_> no 4th quarter
07:20:32 <psykotic> it's nice that danvy is still there. they've been losing a lot of their really good PLT over the last years.
07:20:32 <Choko_> but i skipped it the first year and took linear algebra at imf
07:20:37 <wli> AIUI .hu has Baby Rudin -level material in HS.
07:21:01 <psykotic> wli: i don't think that's appropriate for people who are just taking math as a side course.
07:21:20 <psykotic> there should be more focus on big ideas, which doesn't necessarily involve a massive amount of abstraction at the level of rudin.
07:21:27 <psykotic> instead of cookbook methods and calculation.
07:21:48 <david48> dcoutts: I hope the paste is clear enough.
07:21:55 <dcoutts> david48: just reading it
07:21:56 <Philippa> yeah. You need to see that calculation can make the big ideas tick, but that's not the same
07:22:06 <wli> psykotic: Baby Rudin is essentially the level required to get by in any sort of practical application.
07:22:15 <psykotic> wli: not at the level of rigor and abstraction.
07:22:21 <psykotic> the material, sure.
07:23:11 <dcoutts> david48: here's the trick...
07:23:21 <psykotic> and there is much that isn't covered, i think. like, i think it covers differential forms but the coverage is terrible, and i don't think it proves stokes.
07:23:23 <david48> dcoutts: I'm all ears :)
07:23:30 <wli> psykotic: The level of rigor isn't really up for grabs. The level of abstraction is not very high.
07:23:40 <dcoutts> david48: you only use traitement inside main, so definie it inside main, then you have access to all the widgets up created earlier in main
07:23:55 <psykotic> wli: you don't need to know the detailed mechanics of epsilon-delta proofs to work with calculus as a tool.
07:24:16 <dcoutts> david48: remember that you can define functions with "let foo = ..." inside a 'do' block
07:24:42 <EvilTerran> just like you can at the ghci prompt
07:24:45 <david48> dcoutts: doesn't it lead to a HUGE main function it your GUI is large ?
07:24:48 <Philippa> psykotic: seconded, and A level students over here do fine that way
07:25:14 <dcoutts> david48: can do, you can always pull stuff out, but then it means a bit more parameter passing.
07:25:18 <wli> psykotic: Inequational reasoning is essential to essentially anything where approximations are involved.
07:25:46 <dcoutts> david48: one way to reduce that is to bundle many of your widgets into a record and pass just the record, that keeps the number of parameters managable
07:25:52 <basti_> where can i find some examples for the "new" OpenGL binding?
07:26:44 <psykotic> wli: i'm not disputing its usefulness but merely saying that it is not a prerequisite for use here. and in fact i'd recommend a nonstandard analysis proof for pedagogical reasons at this level of sophistication.
07:27:11 <david48> dcoutts: ok. I thought maybe there would be some magic stuff involvings things I don't yet understand  :)
07:27:44 <dcoutts> david48: FP does quite a bit of explicit parameter passing, then the tricks for hiding/managing it are records and monads.
07:28:03 <basti_> ah, got one
07:28:29 <david48> dcoutts: I tried with a state monad, but it ended up with too many liftIO's for my taste.
07:28:36 <wli> psykotic: Perhaps there is an underlying issue behind all this, like mastery of elementary logic (or lack thereof).
07:28:40 <dcoutts> david48: and of course defining functions inside a scope where they have access to the vars you wanted, that's a neat one.
07:28:44 <dcoutts> david48: aye, it would do.
07:29:22 <david48> dcoutts: I'll try to rewrite it as you explained : inside the main scope.
07:29:22 <dcoutts> david48: then one passes the function around rather than the parameters you'd pass to the function
07:29:45 <psykotic> wli: that's debatable. in any case my point is merely that rudin-level abstraction and sophistication is inappropriate at the high school level where you have people who are just taking math because they have to.
07:29:48 <dcoutts> david48: you should see several examples of that in the gtk2hs demos
07:30:19 <EvilTerran> dcoutts, sounds reminiscent of \-calc "data structures" (being functions)
07:30:19 <psykotic> wli: those people need to be convinced that math is useful and worthwhile and you don't do that by taking the approach you propose, imo. focus on big, powerful ideas is the key. look at how well new math worked out :)
07:30:24 <DRMacIver> psykotic: The problem with nonstandard analysis for pedagaolgical reasons is that when you try to take it further you have two options. a) You say "Actually, forget everything I just told you. Let's talk about limits." or b) You cause your students' heads to explode.
07:30:47 <Botje> head asplosion only hurts once ;)
07:30:51 <dcoutts> david48: occasionally it's helpful to have IORefs, but they should be kept to a minimum, and unsafePerformIO is to be avoided if at all possible.
07:31:07 <psykotic> DRMacIver, the way most applied users of mathematics think of limits is much closer to the NSA account than the weierstrass's e-d account anyway.
07:31:13 <psykotic> at least that's my (anecdotal) experience.
07:31:15 * EvilTerran was taught calculus from (informal) limits initially
07:31:18 <wli> psykotic: It sounds really weird to hear Baby Rudin characterized as abstract and sophisticated. Its popularity seems to center around the precise opposite characteristics.
07:31:23 <david48> dcoutts: It didn't feel right, yes. I'd rather not use anything unsafe
07:31:36 <dcoutts> david48: yeah, the name is a good hint :-)
07:31:45 <DRMacIver> psykotic: Perhaps. But my point is that you can't put nonstandard analysis on a formal footing at the level of education you'd normally e.g. do Analysis I at. :)
07:31:58 <psykotic> DRMacIver, you can just do it axiomatically.
07:32:06 <DRMacIver> Hm. I suppose that's true.
07:32:06 <Botje> ?src getContents
07:32:06 <lambdabot> getContents = hGetContents stdin
07:32:11 <Botje> ?src hGetContents
07:32:12 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
07:32:13 <psykotic> DRMacIver, that's how people do it :)
07:32:15 <Botje> boo
07:32:38 <david48> dcoutts: well I have another problem with glade and aboutdialog, so I'll have a look at the demos ( I had forgot about them ) to see if there's something that helps me :)
07:32:39 <monochrom> hGetContents is complicated.
07:32:48 <david48> dcoutts: thanks a lot !
07:32:53 <dcoutts> david48: no probs
07:32:56 <psykotic> DRMacIver, that is the way robinson thought of it, i think. he was a logician after all.
07:33:10 <Botje> monochrom: I just wanted to see how exactly they used unsafeInterleaveIO
07:33:10 <Botje> :)
07:33:25 <DRMacIver> But constructing an actual instance of those axioms is Hard. :) Whileas any reasonably bright first year student can figure out how to construct the reals given their axioms.
07:33:26 <Botje> (for such values of 'they')
07:33:43 <DRMacIver> Anyway, I'm clearly biased. I've always found nonstandard analysis non-intuitive and ugly. :)
07:33:59 <psykotic> wli: i read baby rudin when i was in 9th grade in a few weeks, so obviously i don't think it's too bad. but i know plenty whose heads explode at much milder expositions with much more motivation and examples and diagrams. so i'm being realistic rather than idealistic about it.
07:34:09 <wli> psykotic: NSA has almost no pedagogical value. There's little or no practice with inequalities (which is why epsilon-delta coverage is useful) and the rules/axioms/etc. are too subtle for people with loose grips on logic, algebra, inequational reasoning, etc.
07:34:12 <DRMacIver> (The hyperreals themselves have many cool points, but not as a way of doing basic analysis)
07:34:55 <psykotic> DRMacIver, by the way, they're not an isolated leaf of the tree of mathematical knowledge.
07:35:04 <psykotic> there is e.g. a synthetic account of differential geometry based on NSA.
07:35:16 <DRMacIver> I know. But they're a fairly outlying branch. :)
07:35:17 <psykotic> although clearly it isn't as mainstream as the usual.
07:35:20 <psykotic> oh sure.
07:35:30 <wli> psykotical: There is no royal road to analysis, and the point of doing the analysis is actually for the pedagogical value of the underlying machinery it forces practice using, not the direct use of the material.
07:35:59 <DRMacIver> 'mainstream' isn't interesting to me. No one cares about most of the stuff I'm interested in. :)
07:36:12 <psykotic> wli: but for the people we're talking about, their encounter with mathematics will likely end as soon as they leave high school. so that part of your argument doesn't work. if you're proposing to only expose people planning to do work in mathematics at university to this regiment, sure.
07:36:16 <Syzygy-> psykotic: This is the stuff Anders Kock does? With geometry done over k[x]/(x^2) ?
07:36:21 <psykotic> Syzygy-, yes
07:36:29 <psykotic> he was at my alma mater, the only reason i know about that work, heh
07:36:35 <Syzygy-> Bought the book after reading sigfpe's blog post...
07:36:37 <psykotic> he was a student of lawvere, i think
07:36:39 <Syzygy-> psykotic: Neat.
07:36:48 <Syzygy-> Bound to be, with that subject matter. :P
07:37:17 <wli> psykotic: The point is not to expose people to analysis. The point is to have meaningful tasks to which to apply inequational reasoning (i.e. epsilon-delta proofs) and so on.
07:37:49 <Syzygy-> wli: And if you want to teach inequational reasoning, then doing inequational reasoning really is the best way - I'll give you that.
07:37:52 <wli> psykotic: Why was Latin taught well into the 20th century?
07:37:54 <psykotic> wli: you're still ignoring the fact that perhaps 90% or more of the people in HS who would take a math class won't ever do any kind of real mathematics once they finish HS.
07:38:55 <wli> psykotic: They aren't expected to do real mathematics. They're expected to be able to be competent at inequational reasoning, which is in fact a task so basic it is of practical significance to non-technical endeavors.
07:39:04 <psykotic> wli: for several reasons. one, perhaps the most significant, being founded in elitism. the other (perhaps supporting of the first) was that learning latin grammar sharpened the mind.
07:39:24 <psykotic> or rather that was their theory.
07:39:44 <psykotic> one could perhaps ask whether learning a living language would be time better spent, and the answer is probably yes.
07:40:50 <wli> psykotic: Let's not forget Euclid while we're at it. Anyway, there's more to it than drilling on grammar. A civilization on which you can actually do a full postmortem analysis is involved here.
07:40:58 <Philippa> I get the impression that the overall pattern of latin grammar is worth having some exposure to, but that's about it
07:41:14 <psykotic> Philippa, if you learn e.g. grammar you'll get an appreciation for grammar too.
07:41:17 <psykotic> err, german
07:41:32 <psykotic> english is of course a terrible language to learn for appreciating grammatical subtleties.
07:41:37 <wli> psykotic: Try Russian grammar.
07:41:37 <Philippa> *nod*
07:41:51 <psykotic> wli: i'd rather not. but i think german will do fine for the purpose.
07:41:59 <Philippa> the thing I'm thinking of specifically with latin is its flexibility (so long as you twiddle things right)
07:42:13 <psykotic> right
07:42:18 <basti_> o.0
07:42:25 <Philippa> I don't know german well enough to comment
07:42:31 <psykotic> word order is almost completely flexible because of affix markers
07:42:36 <basti_> latin is more like a turing tarpit no? ;)
07:42:38 <psykotic> (latin)
07:42:52 <wli> The trouble with too recent of events is that in many cases they're still too recent to be able to discern the full effects.
07:42:59 <Philippa> yeah. Haskell has a not unrelated property that I definitely like working with
07:43:07 <psykotic> wli: as for euclid, i think it's a shame that was taken out of most curricula.
07:43:51 <psykotic> it's also hard to appreciate descartes's arithmetization of geometry without knowing synthetic geometry
07:44:17 <psykotic> but especially because it was the one place where most people were exposed to formal proofs, which i suspect is what you had in mind.
07:44:19 <wli> The Western Roman Empire was 1500 dead in 19th-century Anglospheric pedagogy.
07:45:02 <wli> psykotic: The point of it is not geometry (for which there are superior analytical methods), but rather logic, yes.
07:46:10 <psykotic> as for logic, it's also very worrying that nowhere (as far as i know) abductive reasoning, in the form of bayesian probability, is taught at an elementary level
07:46:26 <psykotic> even mathematicians seem generally completely ignorant of it
07:47:00 <psykotic> (generally in the sense of "with few exceptions")
07:47:03 <wli> And the point of Latin is not snobbery about classics, but grinding away at history, linguistics (cognates are everywhere if you're kicking around modern languages simultaneously), comparative culture, and so on.
07:47:19 <kmb> can anyone explain why this works? filterM (const [True,False]) "123"
07:47:25 <psykotic> wli: if you look at the history, you cannot ignore the snobbery.
07:47:42 <psykotic> kmb: it makes a nondeterministic elementwise choice of whether to include or exclude each element.
07:47:51 <wli> psykotic: You can approach a dead culture with a far greater degree of neutrality than ones still extant.
07:48:36 <psykotic> wli: sure. and i appreciate the classics. i've read seneca and virgil and so on. but i think it's simplistic to say that snobbery had nothing to do with the preeminence of latin in western culture and education.
07:49:02 <wli> psykotic: I was speaking of history from 750BC-500AD. The stupid British snobbery is a bad motive for a good thing.
07:49:02 <psykotic> (in more recent times)
07:49:15 <basti_> kmb: its a bit of a stretch to explain that briefly...
07:50:21 <scook0> kmb: are you familiar with the list monad?
07:50:58 <kmb> I guess my primary question is why [True,False] can be accepted as (a -> m Bool)
07:51:01 <wli> psykotic: Well, one shouldn't ignore that there were also Greek camps in many of the boarding school environments, with competition of sorts between the Latin and Greek camps.
07:51:11 <basti_> [ ] is a monad...
07:51:15 <psykotic> wli: it's not just snobbery. look at church doctrine and the philosophers who considered latin (inferior to greek, in turn inferior to hebrew) as among the Three Perfect Languages, for mystical, almost kabbalistic, reasons.
07:51:15 <wli> kmb: const [False,True]
07:51:44 <psykotic> wli: so there's a long history of this. anyway, this is getting disruptive to #haskell i guess. :)
07:52:15 * psykotic disappears.
07:53:37 <wli> That was one Hell of a digression from what was meant to be a one-line comment in favor of trying to ramp up the level of material students went through.
07:55:13 <JKnecht> #linguistics would be an appropos venue.
07:55:40 <wli> JKnecht: It was a bit broader than that.
07:55:45 <basti_> that might disrupt #linguistics then ;)
07:56:00 <syntaxfree> ?seen jfredett
07:56:00 <lambdabot> jfredett is in #haskell-blah, #xmonad, #haskell, #gentoo-haskell and #haskell-icfp07. I last heard jfredett speak 9h 36m 40s ago.
07:56:14 <basti_> imagine, linguists debating the subtilites of fricative glottalisation in swiss german...
07:56:16 <Syzygy-> What was that filterM solution to the powerset function using const [False, True]?
07:56:39 <basti_> filterM (const [True,False]) ...
07:56:43 <syntaxfree> @tell jfredett hey. You can email me at quemseatreve `at' gmail `dot' com or just use ?tell.  I wasn't around when you tried to finger me.
07:56:43 <lambdabot> Consider it noted.
07:57:05 <kmb> basti - ok, given that [] is a monad, the filterM implementation simply evaluates if list elements meet the pass the predicate test.  How does the the  predicated returning [True,False] effect the number of recursions?
07:57:18 <syntaxfree> How do I add myself to the @where database?
07:57:50 <basti_> kmb: via the list monad. in lists, >>= is concat.map
07:58:02 <scook0> kmb: effectively filterM asks if each element should be in the output list
07:58:17 <scook0> and the answer it gets is "both yes and no"
07:58:34 <scook0> so both alternatives get tried at each point
07:58:45 <scook0> and the final result is the list of all possible answers
08:01:23 <basti_> @source filterM
08:01:23 <lambdabot> filterM not available
08:01:30 <basti_> @source Control.Monad.filterM
08:01:30 <lambdabot> Control.Monad.filterM not available
08:01:53 <kmb> ok, but how does the evaluation of (if b then (y:ys) else ys) where b = [True,False] create a branching structure?
08:02:34 <basti_> the branching is the map in Monad [ ]'s >>=
08:03:34 <kmb> could you state that another way?
08:03:54 * basti_ thinks about it
08:04:01 <scook0> whenever you "extract" a value from a list using (>>=), the list monad tries each value in the list
08:04:03 <basti_> i'll try to reformulate it with concatMap
08:04:45 <scook0> the powerset thingy is probably not a very good introduction to the list monad
08:05:16 <DRMacIver> The level of power that the monad instance for List brings occasionally really startles me. :)
08:05:24 <scook0> > [1, 2, 3] >>= \x -> return (x+1)
08:05:27 <lambdabot>  [2,3,4]
08:05:46 <scook0> > [1, 2, 3] >>= \x -> [x+1, x+10]
08:05:47 <DRMacIver> Hm
08:05:48 <lambdabot>  [2,11,3,12,4,13]
08:05:49 <DRMacIver> ?t filterM
08:05:49 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
08:05:53 <DRMacIver> ?type filterM
08:05:56 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
08:06:11 <DRMacIver> ?src filterM
08:06:12 <lambdabot> Source not found. Maybe if you used more than just two fingers...
08:06:32 <scook0> I can't really see a non-mindbending use of filterM for []
08:07:49 <DRMacIver> I don't find the powerset example especially mindbending.
08:08:38 <fasta> I am back from Perl land :)
08:08:47 <fasta> I survived, barely.
08:09:05 <scook0> DRMacIver: maybe that's a sign that your mind is already bent ;)
08:09:05 <basti_> > [True,False] >>= (\x->if x then [[1]] else [[]]) >>= \a -> [True,False] >>= (\x->(if x then [a++[2]] else [a++[]]))
08:09:07 <lambdabot>  [[1,2],[1],[2],[]]
08:09:10 <DRMacIver> fasta: Did they traumatise you with their loose typing discipline and perverse syntax?
08:09:11 <kmb> Ok, I see how '[1, 2, 3] >>= \x -> [x+1, x+10]' works, but how does (if b then (y:ys) else ys) get translated into the use of (>>=)?
08:09:33 <scook0> kmb: it doesn't
08:09:38 <fasta> DRMacIver: they pretty much said "Oh, yeah, I have that problem too with maintaining that and that old script".
08:09:40 <basti_> how about that?
08:09:53 <scook0> the (>>=) has to happen before that
08:09:56 <fasta> DRMacIver: then I checked the docs and it appears they have an excellent quoting mechanism.
08:10:08 <fasta> DRMacIver: it seems they don't know their own language.
08:10:16 <scook0> because b has already been "pulled" out of the monad
08:10:40 <monochrom> The list monad is mind-bending.
08:11:06 <DRMacIver> scook0: I think that's a very plausible explanation.
08:11:06 <Philippa> I don't think it's too much so once you've got past the idea that it's a particularly weird monad
08:11:08 <wolverian> fasta, I see you trolled #perl. naughty you.
08:11:17 <wolverian> fasta, (hint: #php is much funnier)
08:11:18 <DRMacIver> monochrom: Err. So is the fact that I understood monads via List a problem? :)
08:11:32 <monochrom> I'm speaking relatively.
08:11:42 <fasta> wolverian: :D
08:11:49 <Philippa> list isn't obviously a relative of the state monad, which does confuse some people
08:11:54 <fasta> wolverian: I tried to save them, but it was too late.
08:12:19 <scook0> kmb: http://paste.lisp.org/display/44139
08:12:23 <Philippa> (cf Maybe, which looks a little like a monad with a trivial failed/not state and an extra rule that 'stops' on Nothing)
08:12:29 <wolverian> fasta, trolling rarely saves anyone. :)
08:12:52 <scook0> the 'magic' of (>>=) happens at "flg <- p x"
08:13:06 <fasta> wolverian: I can't really point them to "Why FP matters", since I don't buy that argument myself.
08:13:30 <DRMacIver> Hm. What was the argument in "Why FP matter" again?
08:13:35 <wolverian> fasta, what can you point them to?
08:14:02 <sioraiocht> uhh, it's an awesome and easy paradigm to express a lot of complex reasoning?
08:14:13 <fasta> wolverian: nothing, I could give a presentation of an hour why I think Haskell is nice, but nothing more.
08:14:21 <sioraiocht> And if you ever want to do proofs of your source code, ESP for parallel or concurrent applications, it becomes much much easier
08:14:38 <fasta> sioraiocht: I don't buy that proof argument, either.
08:14:41 <DRMacIver> I find the proofs aspect of FP fairly uninteresting.
08:14:51 <DRMacIver> Well, that's not true.
08:15:05 <DRMacIver> I find it interesting. It has little bearing on my decisions to use FP or not.
08:15:20 <Philippa> the informal corrolary affects my decision
08:15:23 <sioraiocht> fasta: fine, but having parallelised code written in C, Java, Pascal, C#, and haskell, I can tell you which one teakes the least amount of time
08:15:34 <Philippa> it's easier to do fast and loose reasoning about whether certain classes of error are likely
08:15:46 <sioraiocht> that's certainly true
08:15:54 <fasta> sioraiocht: you mean C for less than 4 cores?
08:16:00 <sioraiocht> fasta: I mean C for 16+ cores
08:16:11 <DRMacIver> Yes, the ability to eliminate large classes of errors is definitely a factor. :)
08:16:18 <wolverian> fasta, a lot of perlers are familiar with haskell, and do use it. (I mean, the next version is being written in haskell..) perl has lots of things to enjoy, too, so it's more of a widening your horizons thing than ditching perl. particularly for those who are lucratively paid for their perl work. :) and, anyway, there's CPAN, the ultimate argument.
08:16:32 <fasta> sioraiocht: ok, so, you think C is fastest? I thought your argument was that Haskell would be.
08:16:52 <wolverian> fasta, (you probably knew all that already, just stating my opinion in case you thought trolling might work. :)
08:17:16 <sioraiocht> fasta: no, my argument is that the C code, which was pre-written serially by someone else, has been an enormous pain in the ass
08:17:21 <scook0> I suppose it helps that one of the FP arguments is "down with mutable state", and one of the big minefields in concurrency is shared mutable state
08:17:23 <fasta> wolverian: Perl has nice data base tools, but otherwise the libraries really aren't great.
08:17:37 <DRMacIver> scook0: Shared lazy state seems to cause its own problems. :)
08:17:39 <sioraiocht> to find race conditions, loop dependencies, etc.  (the size of this code is nontrivial)
08:17:42 <wolverian> fasta, they are. the problem with CPAN is finding the good stuff from the swamp of crap.
08:17:51 <DRMacIver> Although I don't know the details.
08:18:12 <wolverian> fasta, (but the good stuff is there, and it's not just db interfaces9
08:18:14 <sioraiocht> fasta: haskell is OFTEN faster in concurrency tests than C, if you're interested in that
08:18:15 <wolverian> s/9/)/
08:18:18 <Philippa> wolverian: that's one thing you can say for Haskell, people're pretty picky about the libs they publish
08:18:42 <sioraiocht> Philippa: is that why so few of them have a version number >= 1 =p
08:18:56 <wolverian> Philippa, yeah, though that might also be the smaller userbase affecting it
08:19:01 <fasta> I wish there was a tagging system based on trust for software.
08:19:02 <wolverian> Philippa, (I think it's both)
08:19:08 <Philippa> sioraiocht: yeah, we know what version 1 /means/
08:19:21 <ihope_> Would there, by any chance, be a way to make lambdabot respond to me in a NOTICE rather than a PRIVMSG?
08:19:29 <fasta> E.g. if someone I trust builds software it should be listed, but otherwise, it shouldn't. (and then in some trust network)
08:19:38 <Philippa> wolverian: yep, the smaller userbase is a factor too - I don't think we could expand to perl's size of userbase and retain the culture of correctness though
08:20:03 <wolverian> Philippa, well, I think haskell has better chances for it than perl did.
08:20:38 <Philippa> if you have a perl size userbase, you /will/ have sloppy coders
08:20:59 <Philippa> but yes, I think haskell's likely to hang on to it better so long as the growth rate's not too high
08:21:14 <wolverian> yeah. I'm just talking about the history. perl has a lot of social cruft due to the language not imposing strict policies.
08:21:36 <Philippa> right, whereas we're all about letting the user go for the strict policies they need
08:21:41 <wolverian> (but it's mostly good now; perl5 fixed most of it, it's just been a slow ride for the knowledge to spread)
08:22:13 <wolverian> anyway, they're both very nice languages, I think. :)
08:22:16 <wolverian> gotta go now, cheers.
08:22:23 <Philippa> one of the reasons we don't have so many "straight from CPAN/other lang's lib" ports is that by haskell standards some of the libs involved are just /crap/
08:22:44 <fasta> wolverian: http://search.cpan.org/~bholzman/Tree-RedBlack-0.3/RedBlack.pm <- example
08:22:47 <lambdabot> Title: Tree::RedBlack - Perl implementation of Red/Black tree, a type of balanced tree. ...
08:22:52 <fasta> wolverian: that's an incomplete implementation.
08:23:02 <fasta> wolverian: for an actual application next to useless.
08:23:10 <fasta> wolverian: (I just picked one)
08:23:45 <fasta> wolverian: oh, right, and that's the only one.
08:24:01 <fasta> wolverian: IMO, not worth to be listed in the first place.
08:25:30 <basti_> theres a typo in Opengl
08:25:40 <basti_> a constant is named ContinueExectuion
08:27:37 <fasta> Oh, right, Unicode support is better in Perl too, I guess.
08:37:36 <mm_freak_> i didn't expect that RTS settings make such a difference
08:37:59 <mm_freak_> % time ./test > /dev/null
08:38:04 <mm_freak_> user: 1.800
08:38:12 <mm_freak_> % time ./test +RTS -A8m -H32m > /dev/null
08:38:16 <mm_freak_> user: 0.855
08:38:39 <mm_freak_> test is the quicksort algorithm for Ints
08:42:22 <scook0> perhaps the larger memory sizes make GC or heap resizing unnecessary for your particular program?
08:42:59 <scook0> (just guessing; I have no RTS expertise)
08:43:20 <mm_freak_> scook0: yes, that's its purpose
08:43:41 <mm_freak_> -A8m makes GC happen less often
08:59:00 <fasta> Meh, another compiler bug found.
09:00:52 <fasta> Or is there some new kind of defaulting I don't know about?
09:01:11 <fasta> I have a function b::Int -> Bool, but I can just call it too.
09:01:19 <fasta> I.e. > b does something.
09:01:27 <fasta> I have no idea what it does, but surely, it does something.
09:01:50 <Eelis> > let b = \i -> True in b
09:01:52 <lambdabot>  Add a type signature
09:02:05 <Eelis> > let b = ((\i -> True) :: Int -> Bool)in b
09:02:07 <lambdabot>  <Int -> Bool>
09:02:11 <Eelis> like that?
09:02:33 <Igloo> You also might have made a section if it's in parens, or bird tracks if you're using literate Haskell
09:02:56 <fasta> Eelis: no
09:03:06 <fasta> Igloo: not a section either.
09:03:12 <fasta> Igloo: I will make a report.
09:03:23 <Saizan> ?type (> (undefined :: Int -> Bool))
09:03:27 <lambdabot>     No instance for (Ord (Int -> Bool))
09:03:27 <lambdabot>       arising from use of `>' at <interactive>:1:0-29
09:05:08 <ddarius> :t (> undefined) :: Int -> Bool
09:05:10 <lambdabot> Int -> Bool :: Int -> Bool
09:08:44 <fasta> The behaviour of a locally defined function changes, based on whether I import something or not.
09:09:25 <fasta> It seems to be related to quickcheck/smallcheck
09:10:58 <Igloo> I don't think anything should change, but it can certainly make the difference between compiling or not (instances)
09:17:16 <fasta> Igloo: can I refer to the SmallCheck module in a bug report?
09:17:24 <fasta> Igloo: smallcheck-0.2
09:19:20 <Igloo> If you can make it self-contained then that's better, but yeah, that should be OK too. Please include a link to it
09:19:33 <fasta> @where smallcheck
09:19:33 <lambdabot> http://www.cs.york.ac.uk/fp/smallcheck0.2.tar
09:19:38 <fasta> (just for me)
09:19:46 <Igloo> Oh, it can change, if you have overlapping instances, of course
09:20:02 <Igloo> .tar? That looks suspicious
09:20:16 * Igloo looks around for York people
09:21:43 <fasta> Igloo: can it be the case that SmallCheck exports a show instance for functions which gets evaluated when I evaluate a function that requires more arguments?
09:21:50 <fasta> That must be it I guess.
09:23:21 <fasta> instance (Serial a, Show a, Show b) => Show (a -> b)
09:23:23 <fasta> Right...
09:23:46 <fasta> No, bug.
11:23:06 <etnt> how can I find out where inRange is defined ?
11:23:28 <sjanssen> @hoogle inRange
11:23:29 <lambdabot> Ix.inRange :: Ix a => (a, a) -> a -> Bool
11:25:38 <etnt> cool, but what is lx ?
11:25:42 <etnt> a library ?
11:26:21 <sjanssen> etnt: a module
11:26:43 <etnt> so I can import inRange from lx ?
11:26:56 <etnt> import lx (inRange)
11:26:56 <Jaak> Ix not lx
11:27:17 <Syzygy-> etnt: EYE IX, not ELL IX.
11:27:33 <etnt> heh...ok I see :-)
11:27:48 <Jaak> and yes, import Ix (inRange) should do it
11:28:08 <etnt> ahh..nice that did the trick, thx!
11:28:47 * etnt is following the Hitch-hikers guide
11:29:34 <Cale> Hehe, that Java vs. K screencast on Reddit is pretty amusing. Someone should do a Haskell one. :)
11:30:18 <Syzygy-> Cale: Link?
11:30:25 <Cale> http://programming.reddit.com/info/24hyb/comments
11:30:26 <lambdabot> Title: Java vs K: a screencast (reddit.com)
11:30:32 <Syzygy-> Thanks
11:31:59 <DRMacIver> What does it show, roughly? I don't have flash
11:32:03 <DRMacIver> What is K anyway?
11:32:46 <Cale> The guy simultaneously writes a program in Java and the same program in K.
11:33:05 <Cale> In Java, the program is 30 lines or so, in K it's about 44 characters.
11:33:34 <mm_freak_> what is K ?!
11:33:39 <Cale> It's a programming language.
11:33:45 <mm_freak_> esoteric?
11:33:48 <DRMacIver> Cale: So, "Hello world"? ;)
11:33:49 <chessguy> haha
11:33:57 <chessguy> this screencast is funny
11:34:48 <Cale> DRMacIver: No, it's a program to generate n rooms with k people each and determine how many times there was a pair of people with the same birthday.
11:35:08 <Cale> mm_freak_: no
11:35:47 <Cale> mm_freak_: Though its concrete syntax makes it look slightly like an esoteric language.
11:35:52 <Syzygy-> K is "readable" APL?
11:36:04 <Cale> Well, it's somewhat APLish.
11:36:09 <mm_freak_> well, programming in malbolge must be funny
11:36:25 <mm_freak_> the hello world program in malbolge needed to be bruteforced =)
11:36:29 <Cale> yes
11:36:52 <DRMacIver> Ak. So its a klosed source J? :)
11:37:19 <Cale> I think J is different.
11:37:59 <Cale> but yeah, something like that
11:38:06 <Biagi> http://biagi.miniville.fr/ind
11:38:08 <lambdabot> Title: Miniville
11:38:14 <mm_freak_> cale: well, java is not a language for source code length comparison  it would fail against almost all other languages for short programs
11:38:30 <Cale> Biagi: is that Haskell related, or are you just spamming us?
11:38:53 <DRMacIver> I really do need to learn J or an APL-like at some point, but I should probably start by acquiring a decent level of experience in some non-traumatic dynamically typed language. :)
11:39:13 <Cale> mm_freak_: yeah, but this is especially funny :)
11:39:16 <DRMacIver> (I'm actually quite looking forward to ruby)
11:39:26 <DRMacIver> Cale: But does it scale???
11:39:36 <mm_freak_> cale: let's write a paper about why java sucks bad =)
11:39:36 <Cale> DRMacIver: You should also check out squeak/smalltalk.
11:39:47 <DRMacIver> mm_freak_: Fish, barrel, etc.
11:40:37 <DRMacIver> Cale: I know I should. But I'll be learning Ruby on the job, and I'm learning Haskell off the job, plus I'm supposed to be learning to write Scala properly (though not). Adding another language to the mix is just asking for trouble. :)
11:40:54 <Cale> hehe
11:41:03 <mm_freak_> hehe
11:41:05 <DRMacIver> Oh yes. And I'm supposed to be figuring out how to read C++. Sigh.
11:41:14 <mm_freak_> drmaciver: c++ is easy
11:41:16 <Cale> Ruby is fairly similar to Smalltalk.
11:41:31 <DRMacIver> mm_freak_: I find it totally unreadable. :)
11:41:36 <DRMacIver> Cale: Yeah, I know.
11:41:39 <Cale> C++ is not easy.
11:42:01 <DRMacIver> It has mutable state. How can it be easy? :)
11:42:50 <olsner> C++ isn't really hard, it just has a lot of inane syntax
11:42:59 <Vq^> C++ is hard
11:43:02 <oerjan> @quote+ DRMacIver It has mutable state. How can it be easy? :)
11:43:03 <lambdabot> No quotes match. BOB says:  You seem to have forgotten your passwd, enter another!
11:43:10 <oerjan> @quote-add DRMacIver It has mutable state. How can it be easy? :)
11:43:11 <lambdabot> Unknown command, try @list
11:43:14 <mm_freak_> yeah, it's just the syntax that makes it a bit esoteric  the semantics are pretty easy
11:43:20 <oerjan> @remember DRMacIver It has mutable state. How can it be easy? :)
11:43:21 <lambdabot> Done.
11:43:21 <Cale> @remember DRMacIver It has mutable state. How can it be easy? :)
11:43:21 <lambdabot> Done.
11:43:26 <mm_freak_> at least they're simple
11:43:36 <Cale> mm_freak_: The semantics of C++ are easy?
11:43:45 <DRMacIver> ...
11:43:50 <Cale> Have you seen the spec?
11:43:54 <DRMacIver> C++ has a semantics? When did that happen?
11:44:01 <glguy> C++ has a lot of special cases that you have to "just know"
11:44:06 <olsner> and of course it requires a grip of pointers and mutable state.. that's not necessarily easy, but mostly a matter of groking what the original coder thought
11:44:08 <celtics_fan> lol
11:44:11 <Cale> DRMacIver: Of course it does, just nobody's bothered to write them down formally.
11:44:12 <Vq^> DRMacIver: it's news to me too...
11:44:18 <mm_freak_> glguy: could you name an example?
11:44:21 <DRMacIver> Cale: Yes yes, I know that really. :)
11:44:29 <Cale> Well, on a given machine, at least :)
11:44:33 <DRMacIver> Cale: I'm not quite as stupid as I pretend to be. ;)
11:44:46 <mm_freak_> drmaciver: much more stupid? ;)
11:45:04 <DRMacIver> mm_freak_: Depends who you ask! About half of ##java seem to think so.
11:45:19 <Vq^> DRMacIver: you show yourself in ##java ?!?
11:45:38 <mm_freak_> drmaciver: most people think i'm insane because i switched from C to haskell
11:45:53 <celtics_fan> but are you insaen and happy?
11:46:07 <mm_freak_> celtics_fan: most insanes are happy =)
11:46:08 <Cale> mm_freak_: Those people are ignorant :)
11:46:17 <glguy> mm_freak_: Things like when is the default constructor created, what happens if you try to use exceptions in constructors,
11:46:18 <mm_freak_> in fact _only_ (so-called) insanes are happy
11:46:21 <DRMacIver> Vq^: I program Java to earn my meals. If I'm going to program a language I'm going to do everything in my power to master it. Hanging out in ##java is very helpful for doing so. :)
11:46:26 <celtics_fan> lol
11:46:28 <Syzygy-> mm_freak_: Just tell them abur
11:46:30 <olsner> and C++ declaration syntax can get quite insane... just try to decipher the declaration of an array of function pointers
11:46:34 <Vq^> DRMacIver: i see
11:46:36 <Syzygy-> mm_freak_: Just tell them about Plato and the cave
11:46:42 <celtics_fan> I heard java has a lot of ready to use code
11:46:49 <glguy> mm_freak_: My college used c++ as the primary teaching language, I haven't used it since then
11:46:51 <Vq^> mm_freak_: oh, a fellow C convert :)
11:46:56 <mm_freak_> syzygy-: mostly i show them the two-liner of the qsort-algorithm =)
11:47:25 <DRMacIver> mm_freak_: ##java thinks I'm insane because I like first class functions and referential transparency. #haskell thinks I'm insane because I like objects and first class modules. #sml think I'm insane because I like type classes and laziness... etc.
11:47:34 <mm_freak_> vq^: sure  not that i've abandoned C completely, but for most tasks i switched to haskell
11:47:35 <Vq^> mm_freak_: the primenumber generarators is a pretty good showoff as well
11:48:14 <DRMacIver> No doubt once I've been corrupted by Ruby I'll adopt a similar middle ground between type systems so that both the static and dynamic typing camps can throw rocks at me. :)
11:48:33 <mm_freak_> vq^: most people don't understand it
11:48:52 <mm_freak_> qsort is pretty convincing because in imperative languages it's mostly about a page of code
11:48:56 <Cale> First class modules make quite a lot of sense. The only reason that Haskell doesn't have them is that there hasn't been overwhelming demand for them, and so nobody's bothered to add them to GHC. (Probably because they overlap so much with typeclasses)
11:49:06 <mm_freak_> in haskell it's two lines (one base case, one recursive case)
11:49:07 <Vq^> mm_freak_: doesn't most programers understand primes?
11:49:17 <mm_freak_> vq^: unfortunately not
11:49:22 <Vq^> oh
11:49:31 <Cale> Most *good* programmers understand primes.
11:49:58 <DRMacIver> Cale: Yeah. They really need unifying with type classes in order to be worth adding to Haskell. In more or less the same way that type classes need to be unified with first class modules in order to be worth adding to ML. :)
11:50:03 <Syzygy-> Many good programmers have already drunk the functional koolaid
11:50:13 <mm_freak_> cale: most programmers aren't good
11:50:19 <quicksilver> DRMacIver: the balance of the evidence you presents suggests that, whatever the truth, you are insane
11:50:32 <DRMacIver> Although I think Cayenne has first class modules (which are unified with records) distinct from type classes.
11:50:38 <mm_freak_> IMO most good programmers didn't learn programming in school or college
11:51:27 <DRMacIver> quicksilver: Yes, probably.
11:51:32 <DRMacIver> quicksilver: But that doesn't make me wrong. :)
11:52:08 <glguy> it doesn't help though, when after you show them the short quicksort code you mention that that code is too naive to be actually used
11:52:26 <Cale> mm_freak_: Well, you're not supposed to learn programming in university. You're supposed to learn something like computer science or mathematics. :)
11:52:34 <DRMacIver> @src sort
11:52:34 <lambdabot> sort = sortBy compare
11:52:38 <DRMacIver> @src sortBy
11:52:38 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
11:52:52 <Cale> I suppose community colleges have "How to Program in X" courses.
11:52:58 <DRMacIver> glguy: Seems like the gcode which isn't too naive to actually use is even shorter. :)
11:53:07 <mm_freak_> glguy: well written C++ code is easy to understand  and what happens if exceptions are thrown in a constructor is well defined
11:53:23 <DRMacIver> Cale: Cambridge has two "How to program" courses in its first year CS.
11:53:30 <mm_freak_> but i don't like C++ anyway
11:53:39 <mm_freak_> C is my favorite imperative language =)
11:53:43 <Cale> DRMacIver: Interesting.
11:53:45 <DRMacIver> One is "Principles of computer science" and teaches ML.
11:53:53 <DRMacIver> The other is some nondescript Java course.
11:53:57 <oerjan> DRMacIver: the builtin sort _is_ naive. it isn't even O(nlogn)
11:53:59 <glguy> mm_freak_: I wasn't arguing that the special cases weren't defined
11:54:05 <glguy> mm_freak_: I'm saying there are a lot of special cases
11:54:20 <Cale> DRMacIver: Most of the courses at Waterloo teach concepts, and expect you to pick up whatever language is being used on your own.
11:54:21 <Vq^> Haskell is my favorite language for writing imperative code :o)
11:54:34 <oerjan> (it is however very lazy, someone noted)
11:54:55 <DRMacIver> Cale: I suspect that's a better approach. I think Cambridge doesn't assume much programming familiarity though.
11:54:55 <roconnor> When I was at Waterloo, the Data Structures and Algorithms course didn't even specify a language to use.
11:54:55 <Cale> That said, Waterloo's CS curriculum could probably use some work, at least in the first year or two.
11:55:01 <mm_freak_> glguy: well, when i use C++, mostly i use it only because of classes  i don't use templates, exceptions or such
11:55:05 <mm_freak_> they make code more complex
11:55:13 <Saizan> oerjan: isn't ghc's sort a merge-sort?
11:55:25 <DRMacIver> Cale: I know the maths and science syllabi couldn't assume a decent maths background and suffered for it.
11:55:45 <glguy> Saizan: it is
11:55:45 <Syzygy-> Saizan: No, it's an insertion sort.
11:55:50 <DRMacIver> oerjan: Hm. Ok. I can't be bothered to investigate, so I'll take your word for it. :)
11:55:53 <Syzygy-> We justsaw the source...
11:55:54 <olsner> but C++ templates are turing complete! that's reason enough to abuse them :P
11:56:03 <glguy> Syzygy-: lambdabot's @src sortBy /= ghc's sortBy
11:56:16 <Syzygy-> Ah, ok.
11:56:19 <Saizan> Syzygy-: that's probably from the report
11:56:25 <Syzygy-> Ahhhhh.
11:56:30 <mm_freak_> lol
11:56:33 <Cale> DRMacIver: The Mathematics program at Waterloo is interesting, especially if you take the advanced section (which applies to the first 2 years)
11:56:52 <mm_freak_> lambdabot uses Hugs, doesn't it?
11:57:00 <Saizan> no
11:57:01 <Syzygy-> Does it?
11:57:05 <Saizan> @version
11:57:06 <lambdabot> lambdabot 4p534, GHC 6.6 (Linux i686 2.66GHz)
11:57:06 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
11:57:07 <Syzygy-> Thought so
11:57:11 <opqdonut> me too
11:57:15 <Cale> DRMacIver: They basically tell you to forget everything you learned in highschool and read the first few chapters of Spivak in your spare time, and move on from there :)
11:57:18 <mm_freak_> hmm
11:57:28 <mm_freak_> i thought `forall' is Hugs-specific
11:57:36 <Cale> mm_freak_: GHC
11:57:46 <Syzygy-> Cale: Right!
11:58:51 <DRMacIver> Cale: Nice. :)
12:00:19 <opqdonut> why isn't the type of sortBy sortBy :: Ord b => (a->a->b) -> [a] -> [a]
12:00:24 <opqdonut> that would be more general
12:00:39 <Cale> :t sortBy
12:00:42 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
12:01:06 <Cale> opqdonut: What would the function parameter do there?
12:01:25 <Cale> Do you perhaps mean  sortBy :: Ord b => (a -> b) -> [a] -> [a] ?
12:01:32 <opqdonut> heh, yeah that
12:01:36 <DRMacIver> That seems an odd way to do it.
12:01:40 <oerjan> opqdonut: that is sortBy . on
12:01:49 <olsner> :t on
12:01:52 <lambdabot> Not in scope: `on'
12:01:55 <Cale> Where 'on' is not defined in the libraries.
12:01:59 <opqdonut> yep
12:02:02 <oerjan> except on is very new
12:02:04 <DRMacIver> I use 'ascending' for that function.
12:02:22 <DRMacIver> On grounds that this lets me also define 'descending'. Then I can write things like sortBy $ ascending length
12:02:36 <DRMacIver> err. and descending length
12:02:53 <oerjan> oh, i mean sortBy comparing
12:02:57 <Cale> (f `on` g) x y = g x `f` g y
12:03:07 <opqdonut> yep, i know on
12:03:42 <Cale> :t sortBy . comparing
12:03:44 <lambdabot> forall b a. (Ord a) => (b -> a) -> [b] -> [b]
12:03:55 <DRMacIver> (Yes, yours is better. But mine better complies with my personal fetish of making my code read like english when it doesn't otherwise significantly degrade the quality of the code. :) )
12:03:57 <oerjan> oh, not quite
12:04:03 <DRMacIver> Where is comparing defined? hoogle doesn't have it.
12:04:21 <oerjan> Data.Ord
12:04:44 <opqdonut> :t sort
12:04:46 <olsner> cale: is it actually possible to define a function like that? (f `on` g) x y?
12:04:48 <lambdabot> forall a. (Ord a) => [a] -> [a]
12:04:49 <DRMacIver> Ah
12:04:55 <Cale> olsner: yes, I think so.
12:05:11 <Cale> yes.
12:05:23 <Syzygy-> on f g x y = (g x) `f` (g y)
12:05:28 <olsner> :t let (f `on` g) x y = g x `f` g y in on
12:05:32 <lambdabot> forall t t1 t2. (t -> t -> t1) -> (t2 -> t) -> t2 -> t2 -> t1
12:05:37 <oerjan> olsner: what surprised me more was yesterday someone actually use an operator for the f
12:05:47 <Cale> > let (f `on` g) x y = g x `f` g y in sortBy (compare `on` snd) [(3,4),(12,2),(5,1)]
12:05:51 <lambdabot>  [(5,1),(12,2),(3,4)]
12:06:12 <opqdonut> :t compare
12:06:16 <Cale> > sortBy (comparing snd) [(3,4),(12,2),(5,1)]
12:06:17 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
12:06:19 <lambdabot>  [(5,1),(12,2),(3,4)]
12:06:31 <opqdonut> 2205.48  lambdabot$ forall a. (Ord a) => a -> a -> Ordering
12:06:32 <opqdonut> woops
12:06:33 <kolmodin> @yarr!
12:06:33 <lambdabot> Well me 'earties, let's see what crawled out of the bung hole...
12:06:34 <opqdonut> sorry
12:06:42 <oerjan> :t let ((*) `on` g)) x y = g x * g y in on
12:06:44 <lambdabot> parse error on input `)'
12:06:52 <oerjan> :t let ((*) `on` g) x y = g x * g y in on
12:06:56 <lambdabot> forall t t1 t2. (t -> t -> t1) -> (t2 -> t) -> t2 -> t2 -> t1
12:07:41 <olsner> oh, the first parameter is called (*) ... obfuscated
12:07:50 <Cale> Not terribly so.
12:08:19 <mm_freak_> would you explicitly declare undefined cases?  like:  sqrt x | x < 0 = undefined
12:08:34 <olsner> :t let ((*) `on` (+)) (-) (/) = (+) (-) * (+) (/) in on
12:08:36 <mm_freak_> or just leave patterns non-exhaustive?
12:08:37 <lambdabot> forall t t1 t2. (t -> t -> t1) -> (t2 -> t) -> t2 -> t2 -> t1
12:08:46 <Cale> mm_freak_: not usually, unless I was going to put a call to 'error'
12:08:59 * fasta just wrote an incorrect test
12:09:04 <Cale> sqrt x | x < 0 = error "sqrt: negative argument!"
12:09:05 <oerjan> mm_freak_: it's nice to document so you know you haven't simply forgotten a case
12:09:13 <fasta> And wrongly assumed the program was wrong.
12:09:42 <mm_freak_> and for performance-critical operations?
12:09:59 <fasta> mm_freak_: it should be just a pointer, AFAIK.
12:10:20 <mm_freak_> fasta: ?
12:10:20 <fasta> mm_freak_: (and a tiny bit of memory)
12:10:31 <oerjan> mm_freak_: it will insert a check anyway won't it?
12:10:44 <fasta> mm_freak_: error "foobar" needs to store "foobar" somewhere.
12:10:56 <mm_freak_> well, at some point it has to check the argument, whether it matches the error pattern
12:11:00 <fasta> mm_freak_: and you need the check anyway.
12:11:28 <mm_freak_> fasta: not necessarily  depends on the sqrt implementation
12:11:54 <mm_freak_> some are bottom, if the argument is negative, some will divide by zero, etc.
12:12:01 <fasta> mm_freak_: ok, let me put it differently: the check should be there, unless you want to create a debugging nightmare.
12:12:51 <fasta> mm_freak_: anyway, the question is also meaningless without context.
12:12:55 <mm_freak_> fasta: i'll need high performance code at some points  and even the simplest checks will decrease performance noticably there
12:13:18 <mm_freak_> i thought about writing it in C, but i think, GHC won't produce worse code, if written properly
12:13:26 <fasta> mm_freak_: you can write C like code in Haskell, so yes, it is possible.
12:14:38 <fasta> mm_freak_: Programming it in C gives you a bug-ridden application, whereas GHC gives you a correct application, unless you write a substantial amount in C like code.
12:14:51 <david48> Gtk2Hs / Glade question : is it possible to have multiple windows per Glade file ?
12:15:05 <mm_freak_> fasta: i know C well, don't worry about that
12:15:46 <fasta> mm_freak_: how large is this system going to be?
12:16:06 <mm_freak_> fasta: i'm too new to haskell to be able to estimate it
12:16:19 <mm_freak_> the performance-critical parts are pretty small
12:16:19 <fasta> mm_freak_: How much experience with Haskell?
12:16:29 <fasta> mm_freak_: what is the application anyway?
12:16:50 <mm_freak_> fasta: about two weeks  enough to write larger programs, not enough to call myself a haskell-guru =)
12:17:22 <mm_freak_> fasta: it's a collection of factorization algorithms
12:17:49 <fasta> mm_freak_: no prior experience with other functional languages?
12:17:58 <mm_freak_> i was playing around with trial division, wheel, fermat and ECM for a while, to get to know haskell better
12:18:04 <mm_freak_> fasta: right
12:18:08 <fasta> mm_freak_: since in that case, you'd better be really smart.
12:18:37 <mm_freak_> fasta: IMO haskell isn't difficult  just throw away whatever you've known about programming =)
12:19:35 <fasta> mm_freak_: you know what? ping me again when you application is done in Haskell. Or better: write an experience report to the mailing list.
12:19:40 <fasta> your*
12:19:53 <mm_freak_> fasta: maybe i'll even write a paper about it
12:20:08 <oerjan> mm_freak_: able to throw away whatever you've known == very smart
12:22:02 <fasta> Unless we get neural interfaces that auto rewire the brain, I don't see humans adapt that fast.
12:22:24 <fasta> Children can basically do that, but when you are past 20, that stops.
12:23:12 <mm_freak_> fasta: what was difficult for me was the concept of monads
12:23:44 <mm_freak_> i _am_ a theoretician, but most of what i know, i have learned myself in my spare-time (including even english)
12:23:55 <Syzygy-> mm_freak_: What kind of a theoretician?
12:24:53 <celtics_fan> lol
12:25:02 <mm_freak_> syzygy-: science
12:25:09 <celtics_fan> throw away everything is simpler when you don't know much, like me
12:25:49 <Syzygy-> mm_freak_: That's not especially specific.
12:26:05 <ont> People throw away many things they know by means of disuse.
12:26:24 <mm_freak_> syzygy-: it's as specific as possible  i'm interested in all sorts of science =)
12:27:15 <mm_freak_> ont: i don't  just sometimes i'm out of brain space, so i forget things =)
12:27:56 * ndm suspects Bulat doesn't know sorear very well
12:28:49 <ndm> @seen sorear
12:28:50 <lambdabot> I saw sorear leaving #haskell-icfp07, #ghc, #xmonad, #haskell-overflow, #haskell-blah and #haskell 16h 52m 58s ago, and .
12:29:47 * glguy assumes so comedy on the -cafe
12:29:51 <glguy> some*
12:29:59 <mm_freak_> what is #haskell-blah ?
12:30:09 <fasta> mm_freak_: a secret channel
12:30:17 <ndm> Bulat was making comments about sorear's knowledge of assembly
12:30:35 <ndm> mm_freak_ - haskell people discussing things which aren't Haskell
12:31:48 <mm_freak_> k
12:33:19 * glguy considers the need to handle the BOM in System.IO.UTF8.readFile
12:36:12 <thorkilnaur> mm_freak_, just curious, I know trial division and ECM, what are "wheel" and "fermat" for (integer, I presume) factorization?
12:38:32 <Cale> http://primes.utm.edu/glossary/page.php?sort=WheelFactorization
12:38:33 <lambdabot> Title: The Prime Glossary: wheel factorization
12:39:02 <Cale> http://en.wikipedia.org/wiki/Fermat's_factorization_method
12:39:04 <lambdabot> Title: Fermat's factorization method - Wikipedia, the free encyclopedia
12:41:26 <Cale> Wheel factorisation is basically just specialising the Sieve of Eratosthenes a bit so that you don't even bother considering numbers which are congruent to the first few primes.
12:41:48 <steinhardt> hello
12:41:52 <Cale> hello
12:42:24 <steinhardt> poor Cale
12:42:27 <Cale> oh.
12:42:32 --- mode: ChanServ set +o Cale
12:42:50 --- mode: Cale set +b n=WP-Gast*!*@*
12:43:07 --- mode: Cale set +b *!*n=WP-Gast@*.dclient.hispeed.ch
12:43:08 --- kick: steinhardt was kicked by Cale (Cale)
12:43:15 <Cale> er, right
12:43:39 --- mode: Cale set -b n=WP-Gast*!*@*
12:43:49 <Vq^> ?
12:44:07 <Cale> It's a bot.
12:44:33 <Cale> (google for WP-Gast or Wikipedia-Gast and you'll find logs of it)
12:45:17 --- mode: Cale set +b *!*WP-Gast@*
12:45:22 --- mode: Cale set -b *!*n=WP-Gast@*.dclient.hispeed.ch
12:45:26 <syntaxfree> WP-Gasy?
12:45:55 <syntaxfree> how is it related to Wikipedia?
12:46:16 <thorkilnaur> Cale, thanks
12:46:29 <Cale> I don't know. Perhaps its creator initially created it to annoy people in wikipedia's IRC channel.
12:46:57 <Cale> It asks "why?" and "can I ask a question?" over and over, and randomly insults people who talk.
12:49:09 <DRMacIver> Have you read "When sys admins ruled the world"?
12:49:28 <Korollary> dont they still rule the world?
12:51:00 <DRMacIver> It's an odd story, but what I'm particularly thinking of is the image of the internet infrastructure gradually decaying as no one was around to maintain it, but all the viruses and spam bots carrying on automatically and almost prospering because of the lack of activity trying to stop them. Rather depressing.
12:51:15 <DRMacIver> Err. Above line contains spoilers. Sorry. :)
12:52:24 <mm_freak_> thorkilnaur: the wheel method is an improvement of trial division in that you try only divisors that are more likely prime (e.g. only trying divisors that are 1 mod 6 or 5 mod 6, and trying 2 and 3 specifically)
12:53:09 <mm_freak_> fermat:  take x > sqrt(n), see if x^2 mod n is a perfect square  if yes, then you've just got a congruence of squares
12:53:15 <Cale> DRMacIver: hehe, "WARNING: Spoilers above."
12:53:40 <thorkilnaur> mm_freak_, thanks
12:53:45 <mm_freak_> np
12:53:55 <syntaxfree> HAHAHAH
12:54:20 <syntaxfree> @remember DRMacIver "WARNING: Spoilers above."
12:54:20 <lambdabot> Done.
12:55:13 <Toxaris> seems a bit unfair, given that he didn't actually said this
12:55:36 <Korollary> For those of us that read in a non-sequential manner, I appreciate it.
12:56:22 <syntaxfree> @quote unfair
12:56:22 <lambdabot> No quotes match. My mind is going. I can feel it.
12:56:25 <syntaxfree> @quote
12:56:25 <lambdabot> kilimanjaro says:  the bad kind of laziness is "so they just invent an equivalance class of monotonic continuous functions that `represent' that partial order. but they haven't taken a shower in
12:56:25 <lambdabot> like 10 days!"
12:56:50 <syntaxfree> lambdabot: damn. that's all of economics.
12:57:06 <syntaxfree> calculus over a class of monotonic continuous functions that represent the partial order of preferences.
12:57:09 * syntaxfree dies.
13:00:58 <DRMacIver> Toxaris: I'll cope. :)
13:01:10 <DRMacIver> I consider humour valid grounds for misattribution. ;)
13:01:39 <DRMacIver> (Although I'm getting a little concerned by how often I end up on Lambdabot's quote file...)
13:02:40 <Shimei> So, has anyone been reading slashdot and encountered this today? http://www.itwire.com.au/content/view/13339/53/
13:02:41 <lambdabot> Title: iTWire - Want to be a computer scientist? Forget maths
13:02:54 <DRMacIver> Ho hum. Cayenne still bizarrely fails to compile on my machine. I wonder if I can be bothered to get to the bottom of it.
13:02:55 <Shimei> Apparently someone has written a book about why computer science doesn't need math.
13:03:15 <DRMacIver> Shimei: People have written books about why mathematics doesn't need maths. :-/
13:03:22 <olsner> yes, everything's not algorithms... so where's the news?
13:04:16 <Shimei> Well, it was amusing because what he was writing about seemed to describe arrows or something like that.
13:04:22 <Syzygy-> @quote DRMacIver
13:04:22 <lambdabot> DRMacIver says: It has mutable state. How can it be easy? :)
13:04:24 <Syzygy-> @quote DRMacIver
13:04:24 <lambdabot> DRMacIver says: There is no overkill. Only "open fire" and "I need to reload".
13:04:27 <Syzygy-> @quote DRMacIver
13:04:27 <lambdabot> DRMacIver says: Regular monads are easy.
13:04:30 <Syzygy-> @quote DRMacIver
13:04:31 <lambdabot> DRMacIver says: It has mutable state. How can it be easy? :)
13:04:39 <Syzygy-> What, pray, is a -regular- monad?
13:04:47 <DRMacIver> As opposed to a comonad.
13:04:53 <Syzygy-> Ah.
13:04:55 <Syzygy-> A monad, thus.
13:04:59 <DRMacIver> Yes.
13:05:15 <Syzygy-> Comonadity doesn't, surely, imply monadity, does it?
13:05:16 <DRMacIver> I wasn't the one who called them regular monads. I'm being unjustly taken out of context. ;)
13:05:36 <Saizan> is there a way to make ld use less memory when linking a ghc compiled program?
13:05:55 <quicksilver> taking people unjustly out of context is, presumably, one of the intended uses of @quote
13:05:59 <Syzygy-> DRMacIver: Isn't that what @quote is for?
13:06:00 <DRMacIver> Syzygy-: I'd be amazed if it did.
13:06:04 <DRMacIver> Well, yes.
13:06:07 <Syzygy-> Bah. quicksilver beat me to the punch.
13:06:11 <quicksilver> :)
13:06:17 <olsner> @stereo
13:06:17 <lambdabot> Unknown command, try @list
13:06:24 <DRMacIver> I'm not objecting so much as saying "Hey, you don't need to tell *me*". :)
13:06:31 * quicksilver <-- typing speed evidence of wasted youth.
13:06:58 <DRMacIver> Typing speed evidence of insufficient time spent on the computer for RSI to set in. ;)
13:07:02 <Syzygy-> quicksilver: I got distracted by a severely bad internet connection with my SSH session occasionally lagging between several seconds and several minutes.
13:07:10 <Syzygy-> And a Winamp stealing focus at a bad time.
13:07:12 <quicksilver> :)
13:07:17 <quicksilver> excuses, excuses
13:07:36 <DRMacIver> But as Syzygy- points out, it's rare that typing speed is the limiting factor. :)
13:07:43 <quicksilver> @quote syzygy
13:07:43 <lambdabot> No quotes match. I've seen penguins that can type better than that.
13:07:48 * quicksilver ponders
13:07:49 <Syzygy-> quicksilver: Typing three replies in two different irssi windows before I actually see any kind of update in the window is, in my opinion, a valid excuse.
13:07:53 <Syzygy-> @quote Syzygy-
13:07:53 <lambdabot> Syzygy- says: "Fun" exercise: reimplement plain TeX as a Haskell-embedded DSL... :P
13:07:53 <quicksilver> ;)
13:07:59 <Syzygy-> @quote Syzygy-
13:07:59 <lambdabot> Syzygy- says: "Fun" exercise: reimplement plain TeX as a Haskell-embedded DSL... :P
13:08:07 <DRMacIver> @quote quicksilver
13:08:07 <lambdabot> quicksilver says: igli: in this channel, if in doubt, it's wise to assume that everyone is a genius :)
13:08:08 <Syzygy-> That's IT? Surely not!
13:08:12 <Syzygy-> @quote Syzygy-
13:08:12 <lambdabot> Syzygy- says: Why do I get the feeling that the arrow code was written during "Speak like a pirate day"?
13:08:16 <Syzygy-> Thought so.
13:08:39 <syntaxfree> Syzygy-: simple. There's already a XMLy TeX-based language.
13:08:50 <Syzygy-> syntaxfree: Which?
13:08:56 <syntaxfree> just chunnel through thAT.
13:09:01 <syntaxfree> I don't remember.
13:09:03 <Syzygy-> Please don't say Docbook.
13:09:13 <Toxaris> DRMacIver: depends on the task at hand. For writing Java code, typing speed is the bottleneck
13:09:19 <olsner> isn't TeX just string rewriting?
13:09:37 <Toxaris> olsner: yep, basically
13:09:46 <quicksilver> only in the same sense that propositional logic is just string rewriting
13:09:52 <syntaxfree> Syzygy-: nah, not docbook.
13:09:56 <quicksilver> and all computer programs are just turing machines
13:09:58 <Syzygy-> *phew*
13:10:00 <syntaxfree> some real latex-workalkike which compiled to tex.
13:10:11 <DRMacIver> Toxaris: Depends. At work writing Java the redeploy time is the bottleneck.
13:10:31 <quicksilver> olsner: TeX has a box+flow model too
13:10:40 <quicksilver> and a pagination system
13:10:49 <DRMacIver> But yes, granted. During pure coding activity in Java the typing speed can often be the bottleneck. :)
13:11:12 <quicksilver> which is why java has evolved such impressive IDEs
13:11:18 * Toxaris is searching for the TEXbook
13:11:21 <quicksilver> to help guess what you're tyring to type
13:11:28 <DRMacIver> Indeed. But I'm using one of the less impressive ones at work.
13:11:44 <olsner> I meant in the sense that the primitive is something like \def{command}{replacement}.. but I find it hard to find concrete information dealing with the actual TeX language rather than with the usage of the umpteen megabytes of macro packages available
13:12:10 <DRMacIver> (In fairness, Netbeans is catching up. 6 is almost good when it works. But it touches our work project in inappropriate ways, so I can't use it)
13:12:13 <Syzygy-> olsner: You want to read the TeXbook for that.
13:12:26 <Cheetahfoot> we using anything else while hpaste.org is down?
13:12:26 <Syzygy-> DRMacIver: Ehm...
13:12:47 <DRMacIver> Netbeans is the IDE equivalent of clippy. :( "Hi, skipper! It looks like you're trying to write a webservice! Would you like help with that?"
13:12:52 * Syzygy- shows the dolly to the project. "Will you show me on the dolly where the Netbeans touched you, honey? Will you do that for me?"
13:13:09 <Syzygy-> Cheetahfoot: paste.lisp.org would work...
13:13:41 <DRMacIver> Syzygy-: I could make jokes about IO at this point. But I'm not going to, as that would be in poor taste...
13:13:49 <Cheetahfoot> Syzygy-: thx
13:14:04 * JKnecht doubts the TeX book is online unless Knuth/Addison Wesley released.
13:14:36 <Syzygy-> "New USB device found. I feel violated. I now I consented originally, but I hadn't expected the brutality of your invasion. And now ... well ..."
13:14:41 <Syzygy-> *know
13:14:56 <Syzygy-> Who? Me? One-track mind? Naaaah, I'd never!
13:18:59 * Toxaris has found it's TeXbook, it's a printed copy and wasn't available online
13:19:25 <Toxaris> but it's structured for learning TeX, not for understanding how TeX is implemented
13:19:32 <cedricshock> I must be the worst haskell programmer ever! I managed to make a runtime error: a.out: Prelude.chr: bad argument
13:19:48 <Cheetahfoot> can anyone tell me why i'm getting a "Couldn't match expected type ..." error here?
13:19:57 <Cheetahfoot> http://paste.lisp.org/display/44154
13:20:31 <cedricshock> Cheetahfoot: Can you add the error please?
13:20:39 <EvilTerran> > chr (-1) -- cedricshock, ?
13:20:40 <lambdabot>  Exception: Prelude.chr: bad argument
13:21:13 <glguy> > chr 0x110000
13:21:13 <mm_freak_> New USB device found:  USB keyboard wiretap.  Installing drivers, please wait.
13:21:14 <lambdabot>  Exception: Prelude.chr: bad argument
13:21:18 <glguy> > chr 0x10ffff
13:21:20 <lambdabot>  '\1114111'
13:21:33 <Cheetahfoot> i added the error ...
13:21:56 <glguy> !paste
13:21:59 <Syzygy-> Toxaris: If you want more nitty-gritty than the TeXbook, I believe the canonical way is to read the WEB sources.
13:21:59 <cedricshock> EvilTerran: Thanks. I look to see if I did anything like that. I'm not using the chr function myself...
13:22:08 <glguy> anyone know why hpaste is down now?
13:22:22 <EvilTerran> spam?
13:23:10 <mm_freak_> olsner: TeX or LaTeX ?
13:24:05 <EvilTerran> Cheetahfoot, i suspect that return is confusing things
13:24:05 <mm_freak_> glguy: there are plenty of pasting services
13:24:14 <mm_freak_> nopaste.org, rafb.net, 
13:24:29 <Toxaris> Syzygy: I don't think I want. Just hoped to find some kind of "design document" to estimate how hard an haskell implementation would be
13:24:53 <EvilTerran> Cheetahfoot, wait, why are you using a do there? you do two calculations then discard both their results...
13:24:53 <Cheetahfoot> EvilTerran: well, i would have thought so, too, except the return was an attempt to fix the problem ...
13:25:22 <Cheetahfoot> EvilTerran: Well, I need to return their results at some point ...
13:25:26 <EvilTerran> > do return (error "this is ignored"); [1]
13:25:28 <lambdabot>  [1]
13:25:28 <Toxaris> Syzygy: The TeXbook contains kind of an operational semantic for TeX, so it isn't entirely the wrong place to look, but it is structured for reading, not for looking things up
13:25:30 <Cheetahfoot> EvilTerran: don't I?
13:25:53 <EvilTerran> hm. are you working through a tutorial here?
13:25:53 <Cale> Cheetahfoot: perhaps you're looking for 'let'?
13:25:58 <mm_freak_> cheetahfoot: coming from an imperative language?
13:26:13 <Cale> let x = facts (n `div` (head ...
13:26:14 <Cheetahfoot> mm_freak_: well ... yeah.
13:26:24 <Cale> in ...
13:26:30 <Cheetahfoot> EvilTerran: kind've. solving some problems ...
13:27:03 <Cale> Why don't you pattern match against the list?
13:27:16 <Cale> facts n [] = n
13:27:20 <Cale> facts n (x:xs) = ...
13:27:32 <EvilTerran> @where tutorial
13:27:32 <lambdabot> http://www.haskell.org/tutorial/
13:27:32 <Cale> that way you don't have to use 'head' so much
13:27:38 <EvilTerran>  /|\ that's a good place to start
13:27:39 <Cheetahfoot> Cale: oh. yeah. i could do that.
13:27:41 <mm_freak_> is there any getopt()-like command line parser?
13:27:49 <Cheetahfoot> Cale: although i don't think it'd solve my type problem.
13:27:53 <Cale> Well, right
13:28:02 <Cale> this do block doesn't make any sense
13:28:08 <Toxaris> Syzygy: for example, it isn't clear for me wich operations are language primitives and wich are macros. but I remember that it was clear after reading the TeXbook some years ago. Maybe if I would implement TeX in Haskell, I would read it again
13:28:38 <EvilTerran> Toxaris, that seems a rather extreme solution to that problem. could be fun/educational, tho
13:29:03 <cedricshock> EvilTerran, glguy: I can't find where I could possibly be using a chr(). I have some show(Int)s but that shouldn't be their behaviour. Is there any way I can see where it's happening (like running it in a debugger / interpreter)?
13:29:10 <Cale> Cheetahfoot: do blocks are solely for combining monadic computations
13:29:32 <Cale> Cheetahfoot: if you were going to use one to generate a list, then each line of the do block has to be a list.
13:29:34 <mm_freak_> cale: that's why i asked him  he still thinks imperatively
13:29:47 <Cheetahfoot> Cale: ah. okay. so if i want to do a double recursive block like that, i don't use do?
13:29:48 <EvilTerran> Cheetahfoot, by which Cale means stuff like IO, parallelism, etcetc
13:29:56 <Cheetahfoot> ah. okay.
13:30:00 <Cale> Cheetahfoot: right, not usually anyway
13:30:07 <Cale> Cheetahfoot: you might want to use 'let'
13:30:14 <Cale> let <decls> in <expr>
13:30:21 <Cheetahfoot> Cale: okay.
13:30:21 <EvilTerran> > let x = 1; y = 2 in x + y
13:30:22 <lambdabot>  3
13:30:30 <Cale> Where <decls> is a bunch of declarations, and <expr> is an expression.
13:30:30 <Cheetahfoot> EvilTerran: right.
13:30:33 <EvilTerran> (a ; is like a newline)
13:30:36 <mm_freak_> > let 2+2 = 5 in 2+2
13:30:38 <lambdabot>  5
13:30:41 <mm_freak_> ;)
13:30:46 <EvilTerran> mm_freak_, O.o
13:31:01 * rho is back
13:31:02 <Cale> EvilTerran: it's a redefinition of (+)
13:31:22 <Cale> > let 2+2 = 5 in 1 + 1
13:31:24 <lambdabot>   Non-exhaustive patterns in function +
13:31:28 <Toxaris> EvilTerran: It was Syzygys idea, brought to my by lambdabot's quote archive
13:31:29 <mm_freak_> yes, a redefinition of (+) 2 2, just like if you had added another guard
13:31:45 <Cale> Well, it completely shadows the previous definition.
13:31:57 <mm_freak_> oh, i see  didn't know this
13:32:02 <Toxaris> how to provoke this quote again?
13:32:04 <Cale> So if you try to add any other two numbers, you'll get a pattern match failure.
13:32:16 <sjanssen> > let (2+2) = 5 in 1 + 1
13:32:17 <lambdabot>  Parse error in pattern
13:32:33 <mm_freak_> btw, when shadowing a function, is there any way to access this shadow from the new definition?
13:32:57 <Cale> By qualifying it.
13:33:03 <Cale> > let 2+2 = 5 in 1 Prelude.+ 1
13:33:06 <lambdabot>  2
13:33:09 <mm_freak_> ah k
13:34:01 <cedricshock> > let plus = +, 2+2 = 5 in 3 plus 3
13:34:01 <lambdabot>  Parse error
13:34:43 <cedricshock> > let 1+1 = 7, 2+2 = 5 in 3 plus 3
13:34:43 <lambdabot>  Parse error
13:34:44 <dmwit> mm_freak_: I don't know if this was answered yet, but Hoogle says there's a GetOpt module.
13:35:00 <mm_freak_> btw, shouldn't "(-5) + 2" be evaluated as:  "((-) 2 +) 5"?  how does haskell tell, when an operator is unary or binary?
13:35:16 <EvilTerran> > let plus = (+); a+b = a `plus` (-b) in 4+3
13:35:18 <Cale> mm_freak_: negative numbers are a special case
13:35:21 <lambdabot> Terminated
13:35:23 <ddarius> It treats - as a unary operator.
13:35:44 <mm_freak_> ok, thanks
13:35:45 <EvilTerran> haskell's (-) is a bit of a sore point, i think ;]
13:35:58 <Syzygy-> mm_freak_: (3-) <- subtraction, (-3) <- negation, (subtract 3) <- subtraction
13:36:08 <Cale> I think that what's been done with it is the most reasonable possible thing.
13:36:08 <ddarius> EvilTerran: Maybe, but Haskellers tend to prefer the current situation to the possible alternatives it seems.
13:36:18 <mm_freak_> dmwit: i thought, there might be something in GHC's modules
13:36:36 <Cale> There's a function 'subtract' in the prelude as a sort of apology for the soreness of that point.
13:36:43 <cedricshock> > let plus = (+); 2+2 = 5 in 3 `plus` 3
13:36:44 <lambdabot>   Non-exhaustive patterns in function +
13:36:59 <Cale> cedricshock: let is recursive
13:37:03 <Toxaris> let bindings are mutually recursive
13:37:04 <Cale> > map (subtract 1) [1..10]
13:37:05 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
13:37:19 <Syzygy-> > map (-1) [1..10]
13:37:20 <lambdabot>   add an instance declaration for (Num (a -> b))
13:37:20 <mm_freak_> :t (-3)
13:37:21 <EvilTerran> I personally would rather eliminate the unary operator, add "-" to the numeric syntax, and shorten "negate" to "neg"
13:37:22 <lambdabot> forall a. (Num a) => a
13:37:30 <mm_freak_> :t (\x -> x-3)
13:37:32 <lambdabot> forall a. (Num a) => a -> a
13:37:35 <Cale> EvilTerran: I wouldn't.
13:37:36 <cedricshock> Ahh, so if I wanted to do what mm_freak_ wanted to do with an annonymous function it's take two lets.
13:37:37 <EvilTerran> >map (-1+) [1..10]
13:37:44 <EvilTerran> > map (-1+) [1..10]
13:37:46 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
13:37:51 <ddarius> Me neither
13:37:59 <cedricshock> > let plus = (+) in (let 2+2 = 5 in 3 `plus` 3)
13:37:59 <Toxaris> >let plus = (+) in let 2 + 2 = 5 in 2 `plus` 2
13:38:00 <lambdabot>  6
13:38:06 <Syzygy-> EvilTerran: However, this will trip up early beginners by having things like > (-2)*15 fail
13:38:12 <EvilTerran> meh. i'm a purist rather than a pragmatist in that regard, i guess ;p
13:38:14 <Cale> Living without unary minus is more annoying than any regularity it would add to the language.
13:38:28 <Syzygy-> Toxaris: That's "> " not ">"
13:38:33 <dmwit> I would rather (_) be unary minus, and find a different character for unbound pattern matches.
13:38:44 <ddarius> dmwit: Ugh.
13:38:49 <Cale> _75 looks wrong.
13:38:49 <Toxaris> Syzygy: Yes, seen
13:38:52 <ddarius> Even ML's ~ would be better than that.
13:38:56 <Toxaris> > let plus = (+) in let 2 + 2 = 5 in 2 `plus` 2
13:38:59 <lambdabot>  4
13:39:00 <DRMacIver> I still like ~ for unary minus. :)
13:39:08 <monochrom> heh
13:39:09 <dmwit> Okay, I'd be fine with ~.
13:39:14 <mm_freak_> dmwit: that would look extremely ugly and confusing
13:39:39 <Toxaris> DRMacIver: overloaded with unary negation for booleans?
13:39:42 <dmwit> I don't think it would be that bad.
13:39:54 <DRMacIver> Toxaris: Sounds fine to me.
13:39:59 <Toxaris> and operators starting with ~ being automatically unary
13:40:00 <EvilTerran> Syzygy-, I tend to prefer designing for pros rather than newfies, i guess. add a special case error message if they try to use something of the form (-1) as a function or (- 1) as a number.
13:40:07 <dmwit> The bad aesthetics of the particular character would be totally overwhelmed by the good aesthetics of not having weird special cases.
13:40:15 <DRMacIver> Toxaris: It's even compatible with the natural Num instance for booleans. :)
13:40:17 <Cale> If I had free reign to change Haskell's syntax, I'd do two things. First, I'd flip the associativity of ($), second, I'd change the module path separator to !
13:40:19 <Cale> er, |
13:40:19 <mm_freak_> the current solution is ok, i think  if not, then i'd just define a negation function (neg 3)
13:40:21 <DRMacIver> Hm. No it isn't.
13:40:34 <Cale> (with no spaces around it)
13:40:39 <mm_freak_> > let neg = (\x -> (-x)) in neg 3
13:40:41 <lambdabot>  -3
13:40:41 <Syzygy-> EvilTerran: That, however, makes for bad introduction to languages. I have had experiences where the syntax to do the simplest things is so obnoxious I never get further in the language....
13:40:44 <EvilTerran> > map negate [1..10]
13:40:46 <lambdabot>  [-1,-2,-3,-4,-5,-6,-7,-8,-9,-10]
13:40:51 <Cale> > let neg = negate in neg 3
13:40:53 <lambdabot>  -3
13:40:58 <ddarius> Cale: So you can write Strategy.runStrategy' again?
13:41:12 <Cale> ddarius: hehe
13:41:20 <mm_freak_> cale: i found myself rewriting a lot of functions in the Prelude, because i didn't know of them =)
13:41:21 <Cale> Well, I'd still probably put spaces there
13:41:35 <Cale> mm_freak_: everyone does that as a rite of passage
13:41:39 <ddarius> mm_freak_: That's fairly typical.
13:41:56 <monochrom> I am encyclopedic regarding the prelude.
13:42:00 <EvilTerran> Syzygy-, meh. i wouldn't consider "neg" particularly obnoxious, but i guess you've got to be careful not to alienate newfies _too_ much
13:42:19 <ddarius> mm_freak_: The next step is to rewrite functions that you -do- know simply because you don't realize they are applicable to your problem.
13:42:23 <EvilTerran> Cale, or, in some cases, as a university tutorial sheet
13:42:24 <Cale> I just think that . makes a terribly confusing module path separator when you're qualifying things that are part of a chain of compositions.
13:42:26 <EvilTerran> ;p
13:42:30 <ddarius> mm_freak_: Monadic functions are especially bad about that.
13:42:33 <DRMacIver> As a mathematicain, I find the inability to have decently symbolic prefix functions highly offputing. ;)
13:42:48 <Cale> EvilTerran: newfies? As in people from Newfoundland?
13:42:49 <ddarius> DRMacIver: Use OBJ
13:42:52 <mm_freak_> ddarius: yeah, happened a few times already
13:43:02 <DRMacIver> ddarius: ?
13:43:06 <Toxaris> in such cases I feel stupid at first. then, I feel clever, because I've written a function worth living in the Prelude
13:43:07 <ddarius> @google OBJ3
13:43:11 <lambdabot> http://vl.fmnet.info/obj/
13:43:11 <lambdabot> Title: The OBJ archive
13:43:15 <EvilTerran> Cale, as in a less derogatory word for newbies. or n00bs. or nubs. or whatever you'd rather call them.
13:43:20 <Toxaris> even more so with functions in Control.Monad
13:43:35 <EvilTerran> ...or, depending on your perspective, as in a shorthand for "new users"
13:43:37 <mm_freak_> toxaris: the functions from the Prelude aren't particularly complex to implement =)
13:43:42 <DRMacIver> ddarius: Ooh, that looks neat.
13:43:52 <cedricshock> ddarius: Yeah. I do both of those. Sometimes the only way you'll ever understand something is if you come up with it yourself.
13:43:52 <mm_freak_> but that's ok  rewriting functions means learning
13:44:17 <EvilTerran> short for "new f... f... um, actually, i don't know what the f's for. =/
13:44:19 <Toxaris> mm_freak_: I consider hard to implement functions as bad design
13:44:39 <mm_freak_> toxaris: some problems don't have easy solutions
13:44:40 <ddarius> DRMacIver: You can do all kinds of ridiculous things like, _ _ : Int IntList -> IntList; . : IntList; 0 3 65 3 2.
13:45:21 * EvilTerran wanders off for a bit
13:45:26 <monochrom> @quote Syzygy
13:45:26 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
13:45:28 <monochrom> @quote Syzygy-
13:45:28 <lambdabot> Syzygy- says: "Fun" exercise: reimplement plain TeX as a Haskell-embedded DSL... :P
13:45:37 <monochrom> @quote Syzygy-
13:45:37 <lambdabot> Syzygy- says: "Fun" exercise: reimplement plain TeX as a Haskell-embedded DSL... :P
13:45:55 <Toxaris> mm_freak_: sure, these are hard to decompose into easy to implement functions, or easy to decompose into hard to implement functions.
13:46:01 <DRMacIver> ddarius: IntList worries me. No parametric polymorphism?
13:46:46 <ddarius> DRMacIver: It does support it some way or another.  I've never actually programmed in OBJ.  What it doesn't support (and it thinks it handles better) is higher order functions.
13:46:54 <cedricshock> Is there anyway I can find out the backtrace of a haskell runtime error?
13:47:07 <ddarius> cedricshock: Yes.
13:47:33 <ddarius> @google inurl:haskellwiki -xc
13:47:35 <lambdabot> http://www.haskell.org/haskellwiki/Introduction
13:47:35 <lambdabot> Title: Introduction - HaskellWiki
13:48:28 <ddarius> Hmm, anyways, compile with -prof -auto-all then execute with the RTS option -xc
13:48:34 <DRMacIver> ddarius: What does it have that handles them 'better'?
13:48:59 <ddarius> DRMacIver: Some kind of parametric module thingy.
13:49:02 <Toxaris> mm_freak_: I try to concentrate on the design, wich works fine so far, but I'm not exposed to real-world problems
13:49:17 <_dml> does ghc6 have restricted type synonyms?
13:49:33 <monochrom> probably not
13:49:46 <Cale> restricted?
13:49:51 <DRMacIver> ddarius: Hm.
13:50:12 <_dml> it seems that hugs has them but I can't find anything about their use in ghc
13:50:15 <mm_freak_> toxaris: me neither  programming is a hobby for me, and mostly my problems are theoretical =)
13:50:57 <Cale> oh, no it doesn't
13:51:16 <_dml> ah, thx
13:51:28 <Cale> Normally, you'd use typeclasses for that.
13:51:32 <mm_freak_> _dml, Cale:  what are they?
13:51:38 <Cale> http://cvs.haskell.org/Hugs/pages/users_guide/restricted-synonyms.html
13:51:40 <lambdabot> http://tinyurl.com/yvr54e
13:51:54 <ddarius> DRMacIver: See section 4.7 of the Introduction to OJB
13:52:35 <Cale> er, and/or modules
13:52:58 <_dml> ok, that's do-able, I think
13:53:28 <cedricshock> ddarius: Thanks. I guess I need to fix the makefile for wxhaskell to build profiled versions to be able to do this...
13:55:25 <matthew-_> @hoogle Float -> Word32
13:55:26 <lambdabot> No matches, try a more general search
13:55:33 <matthew-_> and there in lies the problem
13:56:00 <DRMacIver> ddarius: Hm. Link? I can't find "Introduction to OBJ" on the site. There's "Introducing OBJ", is that what you mean?
13:56:14 <monochrom> @type Debug.Trace.trace
13:56:16 <lambdabot> forall a. String -> a -> a
13:56:47 <hiway_syntaxfree> > trace "Hello" 2 3
13:56:49 <lambdabot>   Not in scope: `trace'
13:56:59 <int80_h> I'd like a resource that shows me examples of the type "either"
13:57:00 <hiway_syntaxfree> > Debug.Trace.trace "Hello" 21 3
13:57:01 <lambdabot>   Not in scope: `Debug.Trace.trace'
13:57:16 <Toxaris> is there a naming scheme for list functions generalised to monoids?
13:57:30 <monochrom> You have to try it on your own ghci.  Try: Debug.Trace.trace "Hello" 21.
13:57:36 <Toxaris> like many' = mconcat . many :: Monoid x => Parser x
13:57:53 <Toxaris> or liftM mconcat many
13:57:55 <Cale> int80_h: case parse foo of Left e -> putStrLn $ "Error: " ++ e; Right x -> ...
13:58:10 <glguy> hiway_syntaxfree: String -> a -> a    means: you give a string and an 'a' and you get back an 'a'
13:58:20 <glguy> hiway_syntaxfree: not: give me a String , 'a' and another 'a'
13:58:26 <Cale> int80_h: Basically, a value of type  Either a b  is either of the form Left x for some x :: a, or Right y for some y :: b.
13:58:58 <int80_h> hmm okay
13:59:04 <int80_h> I'll give it a try
13:59:14 <Cale> int80_h: You can use this for returning information about an error, the standard convention being that Left marks an error and Right marks a correct value.
13:59:15 <glguy> Cale: did we have a spammer problem today?
13:59:41 <matthew-_> Given there is Data.Int, which gives nice, fixed size representations of ints, where's the same for floating numbers?
13:59:49 <Cale> glguy: not on hpaste, so far as I know, but there was a quick spam in the channel, and a WP-Gast bot.
14:00:09 <Cale> matthew-_: Data.Fixed
14:00:23 <Cale> matthew-_: However, Double and Float are both fixed size.
14:00:29 <ddarius> DRMacIver: Yes Introducing OBJ
14:00:44 <matthew-_> Cale: exactly!
14:00:49 <matthew-_> I need to write out Floats in standard IEEE fps to a file. Am I just being dumb or is this actually hard?
14:01:10 <DRMacIver> ddarius: Thanks for pointing me to this.
14:01:13 <DRMacIver> @karma+ ddarius
14:01:14 <lambdabot> ddarius's karma raised to 4.
14:01:26 <Cale> matthew-_: fps?
14:01:29 <glguy> > decodeFloat pi
14:01:31 <lambdabot>  (7074237752028440,-51)
14:01:38 <Cale> matthew-_: You need to write them in binary, or as strings?
14:01:39 * glguy doesn't know if that helps, but offers it up
14:01:39 <ddarius> Floating point standard?
14:02:14 <david48> Gtk2Hs question : Is there a way to emit a signal ? I'm searching through all the doc and I can't find
14:02:29 <matthew-_> binary, and yes, floating point standard
14:02:40 <matthew-_> I wonder how the binary module does it...
14:03:29 <Cale> So probably you want to use Binary, if it has support for that.
14:04:39 <matthew-_> well, the annoying thing about Binary is that if you actually care about endianness then you have to do it manually, which depands Words, so I need to get a Float to a Word. You can just do "put", but then you have no control over endianness
14:05:07 <matthew-_> and, unless you do in manually, you get big endianness which isn't what I want.
14:05:28 <Cale> Well, put for Double is just doing  put d = put (decodeFloat d)
14:05:45 <Cale> @type decodeFloat
14:05:48 <lambdabot> forall a. (RealFloat a) => a -> (Integer, Int)
14:06:03 <Cale> So that might not quite be what you want anyway.
14:06:09 <agocorona> What is the best unix for haskell development????
14:06:17 <Cale> One thing you could possibly do is use the FFI libraries.
14:06:18 <matthew-_> indeed, that's not going to be IEEE anyway
14:06:23 <sjanssen> agocorona: some sort of Linux
14:06:27 <glguy> agocorona: you should probably not use unix
14:06:30 <Cale> agocorona: any sort of linux.
14:06:36 <agocorona> I will leave windows due to the lack of ghc support
14:06:43 <matthew-_> Cale: it seems bizarre that this is so much harder than with ints
14:06:44 <glguy> stick with a linux distro or a free,open,net/bsd
14:06:59 <glguy> agocorona: ghc runs on windows
14:07:06 <agocorona> hi
14:07:14 <sjanssen> matthew-_: you need to interface with another program that requires this format?
14:07:23 <Cale> matthew-_: For instance, Float and Double are both instances of Storable
14:07:24 <agocorona> what is the best unix for haskell development?
14:07:42 <Cale> agocorona: We already answered you. :)
14:07:45 <sjanssen> agocorona: you just asked this question, and received three good answers
14:08:21 <agocorona> sorry I lost the answers maybe because my client....
14:08:23 <Cale> oh
14:08:36 <Cale> They're only a few lines back
14:08:39 <glguy> agocorona: GHC runs on windows, linux and *bsd
14:08:50 <matthew-_> sjanssen: I'm preprocessing a large file, and spitting out data that is read straight into memory (from a file) and then opengl gets pointed to it and interprets it
14:08:52 <sjanssen> agocorona: use Linux, whichever distro you feel comfortable with
14:09:04 <agocorona> I just entered and the buffering system has not been developped in Haskell
14:09:34 <int80_h> use a bsd, you will spend more time doing haskell and less time futzing around with Linux Distro Foo
14:09:34 <agocorona> glguy: I know, but that is not the question I asked....
14:09:37 <sjanssen> matthew-_: the simplest way to do this is probably with Foreign.C
14:10:00 <Cale> agocorona: If you're going to be new to unix, I recommend Ubuntu
14:10:06 <agocorona> I have problems with GHC under windows so I want to leave
14:10:16 <Cale> agocorona: It's probably the easiest thing to install and maintain right now.
14:10:20 <int80_h> I rocommend FreeBSD. Ubuntu is the tool of the devil.
14:10:32 <glguy> OpenBSD is nice too
14:10:35 <glguy> ?version
14:10:35 <lambdabot> lambdabot 4p534, GHC 6.6 (Linux i686 2.66GHz)
14:10:35 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
14:10:46 <int80_h> I was scarred by openbsd once, long ago.
14:10:47 <glguy> but lambdabot doesn't run on it anymore
14:10:48 <Cale> BSD is for strange people though :)
14:10:54 * int80_h shudders
14:10:56 <agocorona> thanks Cale. Im a old unix administrator when the Sun OS ran in 2 MB boxes .
14:11:00 <int80_h> haskell is for strange people
14:11:01 <Cale> agocorona: ah, okay
14:11:11 <monochrom> I recommend Ubuntu. BSD has the mascot the Red Devil.
14:11:19 <glguy> Cale: but *OpenBSD* is for people like that a clean integrated os :)
14:11:26 <glguy> Cale: that might be considered strange :-p
14:11:32 <agocorona> what about Mac OS X?
14:11:41 <Baughn> @djinn String -> UTCTime
14:11:41 <lambdabot> -- f cannot be realized.
14:11:53 <Shine> agocorona: what problems do you have on Windows with GHC? I've just installed ghc-6.6.1 on Windows XP and it works without problems
14:11:54 <monochrom> djinn is not your code monkey!
14:12:11 <mm_freak_> what's so great about darcs vs. svn or git?
14:12:12 <sjanssen> agocorona: GHC's support for OS X isn't quite as good as Linux's
14:12:13 <Baughn> Too much to hope for, I suppose. Is there any way to serialize dates in 6.6?
14:12:22 <glguy> agocorona: OS X supports Haskell development well too
14:12:26 <mm_freak_> all haskellers seem to prefer darcs
14:12:27 <agocorona> Shine: Hs-plugins does not work well
14:12:44 <pejo> sjanssen, what's missing in OSX?
14:12:47 <ddarius> vs. svn there are quite a few things.  I know jack about git.
14:12:48 <glguy> mm_freak_: darcs vs svn is easier to answer than vs git
14:12:48 <Cale> mm_freak_: Darcs has a really nice user interface. That's the main reason I use it.
14:13:01 <glguy> mm_freak_: in darcs, you don't like whole files, there is no central repository
14:13:05 * ddarius is with Cale.  darcs is ridiculously easy to use.
14:13:07 <glguy> like/lock
14:13:26 <ddarius> That said, svn is definitely way way better than cvs.
14:13:28 <agocorona> hs-plugins does not work under windows and it is vital for my developments
14:13:34 <Cale> The reason darcs is popular with Haskellers is that darcs is a Haskell program.
14:13:36 <matthew-_> sjanssen: sorry, can you prod me in the right direction more please? I can't see how, once I get a CFloat, I can write it out...
14:13:36 <sjanssen> pejo: I think GHC on Linux just has more testers, so it tends to work better
14:13:47 <mm_freak_> yeah, most RCSes are difficult to use  git is the easiest i know of
14:14:04 <sjanssen> matthew-_: write it to a Ptr, then use hPutBuf
14:14:08 <int80_h> you say that as if Linux is a monolithic OS, and it's not. It's a mad variety of forks.
14:14:17 <agocorona> downloading Ubuntu
14:14:22 <Cale> agocorona: cool :)
14:14:34 <int80_h> and that's reason enough not to want to use it, if you are interested in getting work done
14:14:47 <matthew-_> sjanssen: is that going to be fast enough? I have millions of these to do?
14:15:12 <glguy> int80_h: who says that about linux?
14:15:13 <sjanssen> int80_h: this isn't a real problem, in my experience
14:15:13 <monochrom> I don't follow int80_h's logic.
14:16:01 <sjanssen> matthew-_: it should be fast enough if you batch the writes (do a few thousand at a time)
14:16:45 <agocorona> sjansen, yes. as a Windows user i feel like a second class citizen using GHC
14:17:12 <Shine> agocorona: I've never used this, but installing Linux instead of writing the author pf hs-plugins to fix the problem sounds like a lot of additional work
14:17:16 <matthew-_> sjanssen: right. I'm currently using Put, I guess that's now out the window too
14:17:38 <Shine> the webpage says it supports windows: http://www.cse.unsw.edu.au/~dons/hs-plugins/hs-plugins-Z-H-1.html
14:17:39 <lambdabot> Title: hs-pluginsDynamically Loaded Haskell Modules
14:17:49 <matthew-_> quite why anyone thought that Word should only hold ints...
14:17:58 <agocorona> Shine: I told to Dons but I think he is too busy to try to fix it
14:18:09 <sjanssen> matthew-_: Word doesn't hold ints, it holds Words :)
14:18:34 <int80_h> I'm doing exercise 4.7 from YAHT and I don't know where to begin except by looking at lots of examples of how the either type is used. I appreciate your eralier example Cale but is there a doc available?
14:18:48 <int80_h> the haskellwiki didn't seem to have anything
14:19:09 <monochrom> You could have reinvented the Either type.
14:19:30 <agocorona> Shine: the linker does not link C libraries, so it is not possible to load code that use ByteStrings with hs-plugins under windows
14:19:35 <matthew-_> data.word, documentation. "Unsigned integer types."
14:19:41 <hiway_syntaxfree> Isn't the Either type just a general 2-term sum type?
14:19:48 * bos wonders what ghc will do with a pattern that has 8,000 branches
14:19:53 <agocorona> thats an example
14:20:17 <int80_h> yeah but I need to use it for four possibilities, not two
14:20:32 <sjanssen> matthew-_: I don't understand what your issue is, Word holds unsigned integral things, what else should it hold?
14:21:08 <sjanssen> bos: yikes!  Why do you have code with 8,000 branches?
14:21:20 <bos> i'm being pathologically lazy.
14:21:24 <matthew-_> it's a list of bits. My issue is the difficulty of interpreting those bits as non-integer values and the inverse
14:21:29 <bos> japanese character encoding.
14:21:48 <glguy> bos: this is part of your UTF32 bytestrings?
14:21:53 <bos> obviously, the right thing to do is spit out a static C structure.
14:21:54 <bos> yep.
14:21:59 <monochrom> http://www.haskell.org/haskellwiki/Books_and_tutorials  looks completely wrong.  Also look at the page history!
14:22:00 <lambdabot> Title: Books and tutorials - HaskellWiki
14:22:02 <matthew-_> sjanssen: on the other hand, I'm really tired and probably grumpy as a result of this.
14:22:07 <bos> and then look that up.
14:22:24 <chessguy> is there an existing library for a 2-way Map? where either the key or the value can be used to look up the other
14:22:25 <sjanssen> matthew-_: you don't want the function Double -> Word, you want the function Double -> Put
14:22:30 <chessguy> or an idiomatic way to do it
14:22:34 <glguy> bos: what are you doing with these japanese characters though?
14:22:44 <bos> converting them to and from unicode.
14:22:52 <DRMacIver> Hm
14:22:58 <glguy> bos: what encoding is that?
14:23:02 <bos> it's the Shift JIS encoding.
14:23:11 <bos> it's a one-or-two-byte encoding.,
14:23:25 <sjanssen> matthew-_: the real issue here is that Double is a very opaque thing, with potentially platform specific layout
14:23:32 <sjanssen> bos: why not use iconv?
14:23:41 <bos> iconv is GPLed and unportable.
14:23:48 <DRMacIver> You know the lisp mantra "Code is data. Data is code."? I was wondering: If data is code, is codata de?
14:23:51 <matthew-_> sjanssen: no, I do not want Double -> Put as that says nothing about using IEEE floating point standard
14:24:11 <matthew-_> sjanssen: and indeed, it looks like the instance Put Double and instance Put Float does not use IEEE FPS
14:24:15 <sjanssen> matthew-_: okay, you want Double -> Put with some attached documentation that says it does what you want :)
14:24:15 <agocorona> lazy studets  proceed from the last course down
14:24:22 <david48> Gtk2Hs question : Is there a way to emit a signal ? I'm searching through all the doc and I can't find
14:24:25 <glguy> bos: what all encodings are you going to support?
14:24:40 <matthew-_> sjanssen: sounds about right ;-)
14:24:49 <sjanssen> matthew-_: correct, it doesn't use IEEE.  It's hard to get the IEEE representation out of a Double
14:24:55 <bos> as many as i can get my hands on. i've got46 encodings down so far.
14:25:03 <monochrom> OK, so Mr. Rz9Qca was probably not malicious but just sufferred a buffer overflow problem.
14:25:05 <bos> sorry, 26.
14:25:37 <matthew-_> sjanssen: yup.
14:26:04 <int80_h> Cale can I discuss with you exercise 4.7 in #haskell_overflow?
14:26:39 <int80_h> because I don't think I'll be getting "either" examples any time soon
14:26:58 <glguy> bos: wouldn't it be a lot more efficient to store the mapping in a binary tree, say a Data.Map
14:27:14 <glguy> bos: instead of making GHC do a linear search on a series of case statements?
14:27:42 <bos> i haven't benchmarked the Shift JIS code yet. i'll probably just spit out a static C structure, in fact.
14:28:51 <Baughn> Is it possible to deserialize dates on ghc 6.6? Can I get a time-since-epoch as a simple integer, for example?
14:30:13 <monochrom> int80_h: perhaps you can have two levels of nested Either's.
14:31:05 <int80_h> sure, but I don't know what that looks like. This is why I want to try and grok things via examples. Syntax is still tricky for me.
14:32:16 <monochrom> Either (Either x y) (Either a b).  Sample values: Left (Left True), Right (Left 'x').
14:32:33 * int80_h sighs
14:32:41 <monochrom> What's wrong?
14:33:27 <int80_h> Syntax is still tricky for me, so I can't visualize what I need based on your example.
14:33:42 <int80_h> I'm going to try google again for what I really need
14:34:02 * monochrom sighs
14:35:16 <int80_h> I appreciate your example. It will help me when I can visualize better.
14:36:22 <monochrom> What is visualize? I seriously don't see what it is like.
14:36:56 <int80_h> I mean being able to picture what the code would look like
14:37:16 <int80_h> the specific based from your general example. This is my current difficulty
14:39:51 <cedricshock> int80_h: I'd be happy to help you with sum types in haskell-overflow while I wait for wxhaskell to compile...
14:40:34 <monochrom> A friend asked me to write this function: there are 4 cases, if the parameter is 0, return the boolean True; if 1, return the character 'x'; if 2, return the integer 42; if 3, return ().
14:41:27 <Toxaris> exists x . Int -> x
14:41:39 <monochrom> Now, I can't write a function in Haskell that returns "bool or char or int or ()". But I can return "Either (Either Bool Char) (Either Int ())".
14:41:58 <monochrom> funny :: Int -> Either (Either Bool Char) (Either Int ())
14:42:07 <monochrom> funny 0 = Left (Left True)
14:42:15 <monochrom> funny 1 = Left (Right 'x')
14:42:28 <monochrom> you could probably fill in the other two lines.
14:43:00 <chessguy> monochrom, data Foo = A Bool | B Char | C Int
14:43:07 <geezusfreeek> monochrom: since this sounds like a frivolous exercise, how about a frivolous datatype? data Weird = A Bool | B Char | C Int
14:43:10 <geezusfreeek> gah, beat
14:43:16 <chessguy> haha
14:43:22 <chessguy> @type ()
14:43:22 <monochrom> chessguy, I'm showing specifically nested Either.
14:43:28 <lambdabot> ()
14:43:31 <chessguy> monochrom, oh, ok
14:43:42 <chessguy> monochrom, you didn't say that
14:44:06 <chessguy> > () :: Char
14:44:07 <lambdabot>  Couldn't match expected type `Char' against inferred type `()'
14:44:11 <chessguy> hm
14:44:36 <Korollary> I always wonder about the kind of function that's supposed to receive all those types of values.
14:44:42 <monochrom> It's very hard to talk to context-free people.
14:44:50 <Toxaris> seems like "a friend asked me to write" was the begin-of-tutorial keyword
14:44:50 <chessguy> @kind funny
14:44:52 <lambdabot> Not in scope: type variable `funny'
14:45:37 <chessguy> ok, back to my question: is there an existing library for a 2-way Map? where either the key or the value can be used to look up the other
14:45:42 <int80_h> thanks cedricshock, I'll see what I can do with monochrom's example for now :)
14:47:06 <cedricshock> int80_h: It's a good example.
14:47:24 <fy__> Hi, I'm new nix and haskell. Can anyone recommend a good (familiar) text editor for someone with a windows dev background?
14:47:40 <monochrom> It hurts my heart that hpaste is down.
14:48:01 <chessguy> more spam issues?
14:48:25 <gaal> is ghc head broken? i'm getting this: http://sial.org/pbot/26123
14:48:26 <lambdabot> Title: Paste #26123 from "haskell" at 24.6.169.211
14:48:50 <cedricshock> fy__: What desktop are you using (gnome/kde)? Or if you don't know, what distribution's default setup?
14:49:12 <fy__> Gnome. I'm using Ubuntu.
14:49:16 <littledan> fy__, it wasn't the easiest transition in the world, but I got used to vim pretty quickly from a windows background
14:49:37 <kowey> fy__: for what it's worth, my non emacs/vi(m) friends seem to like the editor Kate
14:49:55 <gaal> alternatively, is there a known-good recent development snapshot I could try ouy?
14:49:57 <monochrom> I use emacs and eclipse.
14:50:40 <cedricshock> fy__: I use gedit (called "Text Editor" in Ubuntu) in gnome or kate/kwrite in KDE
14:51:04 <kowey> (by friends, I particularly meant haskelling friends)
14:51:23 <fy__> Excellent. I'll give all of those a try. I'm a little spoiled from using visual studio.
14:51:40 <cedricshock> fy__: Both behave how you would expect (copy and paste, returns, etc) coming from notepad/write or one of the microsoft editors like VB
14:51:41 <DRMacIver> I don't understand people who claim to be spoiled by visual studio.
14:52:21 <chessguy> VS does have a nice debugger
14:52:30 <DRMacIver> Yes, the debugger is good.
14:53:05 <chessguy> and intellisense is occasionally useful
14:53:11 <DRMacIver> Sure.
14:53:23 <cedricshock> fy__: All 3 of those should highlight syntax for .hs files for you. There's not much reason to use the kde ones when you have all the gnome libraries already in memory, or visa versa.
14:53:26 <DRMacIver> I'm not saying "I don't understand people who claim to be spoiled by IDEs"
14:53:36 <DRMacIver> I'm saying "I don't understand people who claim to be spoiled by visual studio" :)
14:53:45 <monochrom> I don't understand people who are spoiled by debuggers.
14:54:01 <chessguy> ok, well the discussion is getting too pedantic for me then
14:54:01 <monochrom> I mean XD
14:54:16 <chessguy> are 2-way maps really that hard, that there's no idiomatic way to do it?
14:54:21 <chessguy> er. Maps
14:54:28 <DRMacIver> I'm not being pedantic. I'm just observing that visual studio doesn't offer much over a decent text editor, unlike most IDEs.
14:54:39 <Shine> monochrom: is there an Eclipse Haskell plugin for editing, debugging etc.? Google says http://eclipsefp.sourceforge.net/haskell/ do you use this?
14:54:40 <lambdabot> Title: Haskell support in Eclipse
14:54:45 <DRMacIver> Except a bunch of specific tools for MS infrastructure.
14:55:20 <monochrom> I use that. It does not include debugging. There is no Eclipse plugin for Haskell debugging yet.
14:55:42 <Cale> int80_h: sorry, I was away for a moment there
14:55:45 <cedricshock> DRMacIver: I've never used an IDE other than a MS one because It's never been worth my trouble to figure out how to set one up (I've tried to for a few).
14:55:49 <Cale> int80_h: You need some help with Either?
14:55:51 <eivuokko> DRMacIver, May I ask what tasks have you used VS for, to conclude so?
14:55:58 <sjanssen> chessguy: I'd just use data Map2 a b = Map2 (Map a b) (Map b a)
14:56:00 <Cale> int80_h: I suppose we could write some code that used it.
14:56:00 <fy__> cedricshock: Thank you very much.
14:56:28 <chessguy> mmm
14:56:30 <monochrom> chessguy: no, there is no common 2-way Map. Does a pair of Maps manually kept in sync work for you?
14:56:41 <DRMacIver> eivuokko: Mostly just work stuff. ASP.NET rubbish.
14:56:48 <eivuokko> DRMacIver, Ah, if you wanted to write autotools enabled unixy c-program, yea, VS isn't too nice probably.
14:56:53 <chessguy> monochrom, probably
14:57:13 <chessguy> i'm not sure how efficient it is though
14:57:28 <Shine> monochrom: ok, I'll try it, because I'm searching, too, for a better editor than Ultraedit for Haskell, and in theory it could provide some nice editing and refactoring features
14:57:54 <cedricshock> fy__: No problem.
14:58:03 <DRMacIver> eivuokko: No, if I want to do things like 'write code in C#' then I found VS lacked more than basic support for this compared to the equivalent Java tools.
14:58:21 <DRMacIver> Perhaps this is just me not knowing how to find them, but all the other people in my office using it seemed to be under the same impression. :)
14:58:22 <monochrom> chessguy: I think it's as good as it gets.
14:58:39 <chessguy> fair enough
14:58:42 <int80_h> Cale, I'm back and have my first attempt
14:59:05 <eivuokko> DRMacIver, Sounds like half-hearted use of a tool.
14:59:33 <DRMacIver> eivuokko: Certainly possible. But, if so, the tool certainly didn't make it obvious that it offered more than half-hearted features!
14:59:56 <int80_h> Cale, can you join me in Haskell_overflow?
14:59:56 <DRMacIver> eivuokko: Please feel free to give examples of nice features VS offers. :)
15:00:06 <Cale> int80_h: yes, I'm already there
15:00:09 * monochrom trolls about Haskell not making its deep features obvious.
15:01:29 <eivuokko> DRMacIver, I really like the xbox 360/xna deployment stuff ;-)
15:01:41 <monochrom> Why is delimited continuation so hard? :)
15:01:50 <ddarius> monochrom: Answer: It's not.
15:02:08 <DRMacIver> Ok. Good point. The remote deployment stuff is in general quite good.
15:02:13 <eivuokko> DRMacIver, Seriously, I was just interested if you were project lead or something like that who found serious problems with using VS.
15:02:17 <DRMacIver> I prefer to keep that out of the IDE, but that's a matter of preference.
15:02:50 <eivuokko> DRMacIver, I agree that some of the stuff is very very useless unless project is set up to make use of VS features, and editor and debugger are nice, but nothing really special.
15:03:02 <DRMacIver> No, just a user who found the feature set very lacking compared to the equivalent Java tools.
15:03:14 <int80_h> Cale, I don't see you in #haskell_overflow
15:03:28 <ddarius> _ not -
15:03:32 <ddarius> er other way
15:03:47 <monochrom> #haskell-overflow
15:03:49 <Cale> yeah, it's usually with a -
15:04:25 <DRMacIver> eivuokko: It's not so much that it has a lot of useless stuff as that it doesn't have a lot of useful stuff. :) There's a lot of code aware editor features and refactoring support that it just didn't have. I don't remember exactly what as it's been a few months since I've had cause to use it.
15:04:45 <eivuokko> DRMacIver, It's IDE, everythin developement should be in it ;)  Just like most users want to do all their word processing in one program (or rather, interface) ;)
15:05:10 <timbod> syntaxfree: Are you about?
15:05:24 <DRMacIver> eivuokko: Having it accessible through the IDE is good. Having it part of the IDE is not. :)
15:05:31 <eivuokko> DRMacIver, Eh
15:05:57 <eivuokko> DRMacIver, VS in itself is very small without all the preregistered stuff.
15:06:08 <DRMacIver> Oh, I don't care about that.
15:06:17 <DRMacIver> I care about being able to use it independently of the IDE if I need to.
15:06:25 <eivuokko> DRMacIver, Eh...then do
15:06:43 <eivuokko> DRMacIver, You can access a lot of stuff if you really want, through COM interfaces
15:07:01 <ddarius> "through COM interfaces" he says
15:07:02 <DRMacIver> Hm. Fair enough.
15:07:10 <eivuokko> Although, I must admit I can't find how to deploy xbox 360 on commandline.
15:07:19 <eivuokko> *on xbox
15:07:23 <DRMacIver> I've heard horror stories about that, but have no direct experience to comment on it. :)
15:10:00 <sioraiocht> so, how come I get this error when using the -O flag: warning: implicit declaration of function 'newSpark'
15:10:45 <Shine> fy__: Eclipse works on Linux, too, and is very similar to Windows keyboard bindings and the Haskell plugin I've just installed has some nice syntax highlighting and project management
15:12:37 <monochrom> sioraiocht: strange, but looks like it's because the C compiler sees an undeclared C function in the generated code. I think you can ignore it.
15:12:47 <sioraiocht> kk
15:13:13 <Shine> just discovered: it has a function outline window, where you just click on the function name to jump in the editor to the declarition, like in Java
15:13:23 <monochrom> Up to now -O includes translating haskell to C.
15:13:49 <monochrom> You can say -O -fasm to avoid C.
15:14:19 <sioraiocht> ah
15:14:31 <sioraiocht> monochrom: is that so maybe you can do optimisation passes on the C?
15:14:37 <monochrom> Yeah.
15:19:06 <desp> hm
15:19:12 <desp> for CInt -> Int, use fromIntegral?
15:19:14 <fy__> Shine: Thank you, Shine. I'll try that. http://eclipsefp.sourceforge.net/ ?
15:19:15 <lambdabot> Title: EclipseFP - Functional programming support for Eclipse
15:19:18 <desp> > maxBound Int
15:19:19 <lambdabot>   Not in scope: data constructor `Int'
15:19:26 <desp> > maxBound Integer
15:19:28 <lambdabot>   Not in scope: data constructor `Integer'
15:19:31 <desp> er
15:19:35 <eivuokko> desp, Yes.
15:19:39 <desp> > maxBound undefined :: Int
15:19:40 <lambdabot>   add an instance declaration for (Bounded (a -> Int))
15:19:41 <lambdabot>     In the expression:...
15:19:46 <eivuokko> > maxBound (undefined::Int)
15:19:47 <lambdabot>   add an instance declaration for (Bounded (Int -> a))
15:19:47 <lambdabot>     In the expression:...
15:20:00 <desp> hm
15:20:01 <Shine> fy__: yes, this is the plugin I've installed in my Eclipse installation
15:20:29 <EvilTerran> ?type maxBound
15:20:31 <lambdabot> forall a. (Bounded a) => a
15:20:33 <Jaak> @type maxBound
15:20:34 <lambdabot> forall a. (Bounded a) => a
15:20:36 <EvilTerran> heh
15:20:43 <Jaak> > maxBound :: Int
15:20:45 <lambdabot>  2147483647
15:21:06 <Jaak> > maxBound :: Char -- hmm?
15:21:08 <lambdabot>  '\1114111'
15:21:18 <desp> so it does appear to cover CInt
15:21:22 <Shine> fy__: you'll find the installation instruction here: http://eclipsefp.sourceforge.net/downloads.html
15:21:23 <lambdabot> Title: eclipse.org
15:21:23 <desp> good
15:22:07 <desp> it seems odd to me that CStringLen is (Ptr CChar, Int)
15:22:09 <desp> and not CInt
15:22:48 <EvilTerran> > maxBound :: (Int,Char,Bool)
15:22:49 <lambdabot>  (2147483647,'\1114111',True)
15:24:23 <desp> or even CSize
15:24:51 <eivuokko> desp, I think when Foreign was written, designers assumed that it would be used as low-level C, and marshalling being done quite rarely.
15:25:31 <desp> eivuokko: pardon? but look, if I want to peek at a C string, and I know its length, then it's surely expressed in C units
15:26:39 <eivuokko> desp, working with CInt is often quite annoying in haskell as most of haskell libraries use Int rather.  If strings marshalling was rare, you'd be working with that size a lot.  Just as an assumption.
15:27:33 <desp> well, I'm just worried about 64-bit platforms
15:27:46 <desp> is Int always 32-bit signed?
15:28:08 <sjanssen> desp: no
15:28:08 <eivuokko> desp, Not guaranteed to even be 32
15:28:42 <desp> okay, well, I should be asking -- is it guaranteed to be the same size as C int?
15:28:43 <desp> :)
15:28:49 <DRMacIver> Very no
15:28:50 <eivuokko> desp, No.
15:29:02 <DRMacIver> The size of Int should be assumed to be the least convenient number it could possibly be which is not less than 30. :)
15:29:12 <desp> heh
15:29:54 <desp> well, I guess the rare 2GB+ C string will get truncated, then
15:31:49 <syntaxfree> timbod: are you about now?
15:31:51 <syntaxfree> @seen timbod
15:31:52 <lambdabot> timbod is in #haskell. I last heard timbod speak 26m 42s ago.
15:33:26 <desp> syntaxfree: hi
15:33:31 <desp> did you get my message?
15:33:48 <syntaxfree> desP: about not joining? yeah :)
15:33:52 <desp> ok :)
15:34:05 <desp> turns out we're going to have a 5-man team
15:34:07 * DRMacIver reads "Because Int is a subsort of List" and has head explody.
15:34:12 <DRMacIver> On which note it's time to go to bed.
15:39:01 <Shimei> Is it possible to enable profiling within GHCi?
15:39:10 <Shimei> I don't seem to be able to :set -prof
15:39:10 <monochrom> Probably not.
15:40:10 <shachaf> Shimei: "ghc-6.6: --interactive can't be used with -prof, -ticky, -unreg or -smp."
15:40:22 <Shimei> Ah, I see. Thanks.
15:43:42 <chessguy> ermm, am i missing something, or is there not a better way to do this?
15:43:43 <chessguy> left = do
15:43:43 <chessguy>   s <- get
15:43:43 <chessguy>   case (cursor s) of
15:43:43 <chessguy>     (1,y) -> put $ s { cursor = (size s, y) }
15:43:43 <chessguy>     (x,y) -> put $ s { cursor = (x - 1 , y) }
15:44:27 <jfredett> Why is (*) part of the MRD for Num, when (^) isn't?
15:44:33 <Igloo> chessguy: You could go from 0 to size-1, and then used `mod`
15:44:58 <Igloo> jfredett: MRD?
15:45:01 <jfredett> its equally easy to define (*) from (+)
15:45:03 <Igloo> Oh, n/m
15:45:04 <jfredett> Minimum required definition
15:45:27 <chessguy> Igloo, well, i was referring more to the state monad part
15:45:30 <oerjan> chessguy: you may want modifyCursor f s = s { cursor = f $ cursor s }
15:45:39 <Igloo> jfredett: Even for non-integral types?
15:45:44 <sjanssen> chessguy: modify
15:45:51 <jfredett> ahh- thats why
15:45:54 <jfredett> okay
15:46:01 <sjanssen> chessguy: modify $ \s -> case cursor s ...
15:46:26 <chessguy> ah, instead of doing s <- get
15:46:45 <jfredett> maybe I should just write my own typeclass. NumIntegral.
15:46:47 <jfredett> meh.
15:47:01 <chessguy> @type modify
15:47:04 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
15:47:13 <sjanssen> jfredett: why should (^) be part of Num?
15:47:13 <chessguy> so that still needs to take place inside the do, right?
15:47:26 <jfredett> sjanssen: thats my question
15:47:32 <jfredett> it is, but it shouldn't be
15:47:35 <sjanssen> jfredett: it isn't, IIRC
15:47:39 <shachaf> chessguy: Why?
15:47:44 <jfredett> I just pushed my Nat implementation into Num
15:47:51 <jfredett> and it gave me ^ for free
15:48:03 <shachaf> chessguy: left = modify $ \s -> case ...
15:48:05 <sjanssen> jfredett: (^) is not in Num
15:48:05 <jfredett> so I'm assuming that it's push into Num is the reason
15:48:08 <jfredett> hmm
15:48:13 <Saizan> ?info (^)
15:48:14 <lambdabot> (^)
15:48:16 <jfredett> then how'd I get it? :/
15:48:21 <Saizan> ?type (^)
15:48:22 <sjanssen> jfredett: this is just standard Haskell polymorphism
15:48:23 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
15:48:29 <oerjan> @src (^)
15:48:30 <lambdabot> Source not found. I've seen penguins that can type better than that.
15:48:32 <jfredett> ahh, I see
15:48:34 <sjanssen> jfredett: (^) :: (Num a, Integral b) => a -> b -> a 	-- Defined in GHC.Real
15:48:47 <jfredett> so it kind of comes w/ num, but not really, I see.
15:48:49 <oerjan> it didn't find _that_?
15:49:04 <oerjan> @src ^
15:49:04 <lambdabot> Source not found. The more you drive -- the dumber you get.
15:49:07 <sjanssen> jfredett: it works with every Num base and Integral exponent
15:49:16 <jfredett> i get it
15:49:37 <jfredett> its the integral requirement- that'd look kludgey in Num. gotcha
15:49:38 <jfredett> cool
15:51:44 <oerjan> this is ridiculous. @src sortBy returns the sortBy from the report, which someone claimed is _not_ the one used by ghc, but @src (^) does not return the definition from the Prelude?
15:51:55 <sjanssen> @src sortBy
15:51:55 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
15:52:37 <sjanssen> oerjan: @src is manually generated, you'd need to ask dons why it happened this way
15:53:14 <oerjan> sjanssen: if by manual you mean someone did cut and paste...
15:53:26 <sjanssen> oerjan: manually + a script, I imagine
15:55:10 <oerjan> i _suppose_ this is somehow tied to the discussion the other day of how difficult it is to get a list of defined names for a module.
15:55:20 <sjanssen> oerjan: also, (^) is fairly lengthy
15:55:34 <ddarius> oerjan: Feel free to rewrite @src
15:57:19 <oerjan> right, maybe 7 lines is above the limit
15:57:34 <oerjan> @src (^^)
15:57:34 <lambdabot> x ^^ n      =  if n >= 0 then x^n else recip (x^(negate n))
15:57:41 <sjanssen> oerjan: yeah, must be it
15:57:44 <oerjan> @src gcd
15:57:44 <lambdabot> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
15:57:44 <lambdabot> gcd x y = gcd' (abs x) (abs y)
15:57:44 <lambdabot>    where gcd' a 0  =  a
15:57:44 <lambdabot>          gcd' a b  =  gcd' b (a `rem` b)
15:58:01 <oerjan> those two are just nearby
15:58:10 <sjanssen> @src foldr
15:58:10 <lambdabot> foldr k z xs = go xs
15:58:10 <lambdabot>     where go []     = z
15:58:10 <lambdabot>           go (y:ys) = y `k` go ys
15:58:20 <sjanssen> oerjan: this is how I think it happened:
15:58:46 <sjanssen> the state was initially filled with all defn's below a certain length from the Haskell report
15:59:04 <chessguy> hmm. this isn't legal?
15:59:05 <chessguy> right = modify $ \s ->
15:59:05 <chessguy>   case (cursor s) of
15:59:05 <chessguy>     (size s, y) -> s { cursor = (1  ,y) }
15:59:05 <chessguy>     (x, y)      -> s { cursor = (x+1,y) }
15:59:09 <campusblo> hi folks im learning haskell
15:59:21 <chessguy> it doesn't like the "size s" in the first case pattern
15:59:35 <campusblo> why daont the prelude functions ork in ghci or winhugs?
15:59:40 <sjanssen> then somebody added a bunch of actual defn's that GHC uses (with the same length limit), overwriting some Prelude defn's
15:59:44 <oerjan> chessguy: patterns cannot be expressions
15:59:46 <campusblo> im trying to use toUpper and nothing is happening
16:00:09 <sjanssen> oerjan: this is why we have GHC's defn for foldr, the report's version of sortBy, and nothing for (^)
16:00:10 <oerjan> chessguy: use a guard
16:00:19 <chessguy> oh, i can do that in a case?
16:00:30 <sjanssen> campusblo: "nothing"?  Not even an error message?
16:00:39 <Toxaris> campusblo: toUpper isn't a Prelude function as far as i know
16:00:45 <chessguy> @hoogle toUpper
16:00:46 <lambdabot> Char.toUpper :: Char -> Char
16:00:47 <Toxaris> try Char.toUpper in ghci
16:01:00 <campusblo> ok will
16:01:27 <oerjan> chessguy: certainly
16:01:45 <sjanssen> campusblo: the error message should be something like "toUpper not found" -- this shows that it isn't defined in the modules you've loaded so far.  toUpper is defined in Data.Char, so you'll need to load that module
16:02:17 <chessguy> nice
16:02:35 <cedricshock> > Char.toUpper "hEllO"
16:02:36 <campusblo> ok so ill have to load the char module
16:02:36 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
16:02:43 <ddarius> > map toUpper "foobar"
16:02:45 <lambdabot>  "FOOBAR"
16:02:52 <cedricshock> ddarius: Ahh
16:03:01 <sjanssen> campusblo: ":m +Data.Char" in ghci
16:03:15 <campusblo> ok im in winhugs now
16:03:29 <sjanssen> campusblo: ":also Data.Char" in Hugs IIRC
16:04:14 * Toxaris just crashed WinHugs by typing ":also Char"
16:04:59 <campusblo> to load that do i have to do a load?
16:05:20 <sjanssen> campusblo: nah, I think you want to use :also
16:05:29 <campusblo> oh ok
16:05:38 <campusblo> i guess that loads an additional module
16:05:41 <oerjan> sjanssen: wow, i thought you could only load one module in Hugs.  Thanks!
16:05:42 <campusblo> where are they anyway?
16:06:03 <sjanssen> campusblo: what?  The actual sources for these modules?
16:06:10 <campusblo> yeh
16:06:31 <Toxaris> sjanssen: :also doesnt work for me (not that it crashes everytime, it behaves like :l)
16:06:37 <campusblo> ok that worked
16:06:53 <campusblo> now im going to send this to my teacher so im guessing im going to have to copy toUpper
16:07:00 <campusblo> into my code so that everything works
16:07:08 <campusblo> well its part of a bigger program
16:07:14 <Toxaris> in your code (in a file?) you can use import Char
16:07:16 <sjanssen> Toxaris: I'm not a Hugs or Windows expert
16:07:22 <campusblo> oh cool
16:07:30 <campusblo> right right
16:07:35 <oerjan> Toxaris: darn you are right
16:07:39 <campusblo> i should also import prelude right?
16:07:45 <campusblo> or do i not have to do that?
16:07:48 <Cale> The Prelude is always imported
16:07:49 <Toxaris> prelude is automatically imported
16:07:50 <sjanssen> campusblo: nah, that's automatic
16:07:51 <campusblo> ok
16:08:00 <sjanssen> @quote stereo
16:08:00 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
16:08:00 <Cale> Data.Char is the new name for the module
16:08:14 <Cale> Char is the name for the Haskell 98 standard Char module
16:08:15 <ddarius> Ironically, the new non-standard name.
16:08:39 <Cale> Data.Char will probably be the H' standard name
16:08:44 <sjanssen> ddarius: only non-standard because there is no Haskell committee to ratify the extension
16:08:46 <ddarius> It'd better be.
16:09:02 <campusblo> you guys have are always here and helped me before even though you probably dont remember
16:09:05 <Cale> Heh, yeah, or there would be a community vote of no confidence :)
16:09:05 <Saizan> mmh, can you do the equivalent of :m + for a not-installed module in ghci?
16:09:17 <campusblo> im in so much debt to you guys and its a pretty cool channel
16:09:26 <Cale> :)
16:09:26 <ddarius> campusblo: I remember you.  Though, I don't think I helped you.
16:09:30 <campusblo> its nice to know there is somewhere that ppl know the haskell
16:09:32 <campusblo> lol
16:09:38 <campusblo> well i always get help here
16:09:43 <campusblo> hey question
16:09:48 <chessguy> @quote #haskell
16:09:49 <lambdabot> nilsi says: #haskell is better than google
16:09:50 <campusblo> im doing a bunch of languages at shool
16:09:56 <campusblo> we have to do a functional and a bunch
16:10:03 <campusblo> of others
16:10:13 <campusblo> can you guys recommend other languages to know?
16:10:15 <chessguy> sounds like a good program
16:10:17 <campusblo> c#?
16:10:20 <campusblo> java?
16:10:27 <chessguy> not java
16:10:30 <campusblo> lol
16:10:34 <chessguy> python maybe
16:10:34 <Toxaris> campusblo: wich kind of school?
16:10:40 <campusblo> its university
16:10:45 <campusblo> we do haskell
16:10:47 <campusblo> scheme
16:10:51 <sjanssen> campusblo: C
16:10:52 <campusblo> i think we have to do java
16:10:53 <Toxaris> prolog is a must
16:11:05 <campusblo> and then we have to choose one to major in
16:11:10 <chessguy> yes, good to have knowledge of C
16:11:13 <chessguy> maybe even c++
16:11:15 <ddarius> assembly
16:11:19 <chessguy> for the OO concepts
16:11:27 <ddarius> Smalltalk
16:11:31 <campusblo> i think we also can choose to do some assembly stuff
16:11:33 <ddarius> or javascript
16:11:40 <chessguy> perl
16:11:48 <campusblo> but im trying to pick the languages that i want to do
16:11:48 <ddarius> chessguy: The value of perl being?
16:12:06 <campusblo> i figuer questions like this are bound to cause arguements though
16:12:13 <chessguy> perl is a nice quick exists-everywhere language
16:12:14 <ddarius> Not here.
16:12:15 <campusblo> :)
16:12:26 <ddarius> chessguy: Not on Windows.
16:12:36 <campusblo> im thinking of c# as my final language
16:12:46 <campusblo> i hear that c# ppl are in demand
16:12:47 <Toxaris> ddarius: there aren't quick exists-everywhere languages on windows
16:12:56 <dibblego> ?where yaht
16:12:56 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
16:12:58 <ddarius> C# is not that bad and it's getting better, but why "final language"
16:13:14 <campusblo> well it would be the language that i do my final project in
16:13:30 <Toxaris> I try to learn as many "interesting" languages as possible at university
16:13:44 <monochrom> I believe campusblo is going to be promoted to management rank soon. Yay no more programming! :)
16:14:00 <campusblo> we have to do 2 functional , java , one procedural and then choose a language for the project
16:14:08 <campusblo> and one assembly or something like that
16:14:19 <Toxaris> with "interesting" = teaches me a language concept in a pure form
16:14:37 <chessguy> campusblo, then maybe you should wait to choose a language until you've played with all the other kinds
16:14:38 <monochrom> Different people have different interest.
16:14:42 <campusblo> but what happens is the one that we choose for the project will be the one we go really in depth into
16:14:55 <campusblo> so im trying to figure out which one i should get to know very very well
16:15:01 <chessguy> campusblo, is this a single-semester course?
16:15:03 <Toxaris> so (pure) prolog for logic programming, haskell for laziness & pure functional, smalltalk for oo, assembly for low-level, vhdl for hardware description and so on
16:15:11 <campusblo> the final one will probably be a year
16:15:23 <campusblo> well the project will be a year
16:15:28 <chessguy> Toxaris, he ought to get some familiarity with c
16:15:30 <monochrom> "i hear that c# ppl are in demand" is axiomatic, period.
16:16:56 <Toxaris> chessguy: Yes, every programmer should. It was more of a anti-Perl argument... I was exposed to Pascal, c, php, perl, some basic dialect before university
16:17:23 <campusblo> everything else is 1 semester
16:17:30 <campusblo> strangely though haskell is 2
16:17:45 <Toxaris> but c isn't needed for concepts, but for understanding stuff like "this is just as in c" or "syntax is like in c"
16:17:56 <campusblo> but hskell is more taught in a general course and they use haskell to illustrate
16:18:06 <Toxaris> for concepts (that is, procedural programming) i like pascall more
16:18:07 <chessguy> and pointers
16:18:25 <Toxaris> ok, pointers is a c concept
16:18:40 <campusblo> there really is not need for me to choose now but i figure its worth always keeping it in mind
16:19:00 <wli> Assembly language.
16:19:03 <campusblo> cause like for summer i want to start playing with some languages
16:19:28 <campusblo> and im accumulating books etc just so that i have them and can do them in my spare time
16:19:53 <campusblo> i dont want to be the programmer who comes out of school and still doesnt have a clue of real world stuff
16:20:36 <campusblo> i wanna leave and go right into decent work. if you guys know what i mean
16:20:40 <Toxaris> :) now for real world stuff, you should learn Java
16:20:47 <c> ive got very successful programmer friends tyhat dont know what a linked list is
16:20:48 <campusblo> lol
16:20:56 <c> if you can swing JS/css/html and a touch of ruby/php youre fine :D
16:21:26 <campusblo> i see
16:21:41 <wli> Real-world stuff AFAICT is assembly, C, and device driver and other privileged affairs.
16:21:50 <campusblo> ok well im goning to get back to haskell and ill shout you guys when i need to know stuff. im doing a project here on encryption
16:22:08 <chessguy> word
16:22:20 <campusblo> supposed to convert all text to uppercase and match words
16:22:27 <campusblo> to decrypt
16:22:30 <Toxaris> Real-world stuff is everything in IO?
16:23:12 <wli> Toxaris: Very closely tied to hardware.
16:23:18 <campusblo> In this project you will expected to write encryption and decryption functions in Haskell based on shifted (rotational) cryptosystems. As well as decoding with a specified key you will be expected to write functions to help crack a shifted cipher without the key.
16:23:34 <Philippa> wli: rather elitist value of "real-world", that - which isn't to say that it's one that should be ignored
16:24:05 <wli> Philippa: I'm loath to generalize as I don't really seee much else.
16:24:24 <Philippa> campusblo: sounds suspiciously like the coursework gmh gave the year I did Nottingham's FP module
16:24:33 <campusblo> 4.	Write a function crackWithDictionary which takes some ciphertext as an input and uses a dictionary of words (see words.txt file) to determine the best crack at the ciphertext.
16:24:39 <Philippa> then again, I wouldn't be surprised if you're using his book :-)
16:25:03 <cedricshock> Ok. I finally managed to compile my program with -prof -auto-all after recompiling wxhaskell with profiling and shuffling files around by hand.
16:25:24 <Philippa> wli: the problem with all that enterprise crap is that sadly it really is real world. So's all the web app stuff
16:25:49 <cedricshock> How do I use this profiling to see the backtrace of an error like  Prelude.chr: bad argument (which I'm almost certain is originating in wxhaskell)
16:25:51 <wli> Philippa: I've never seen Java or Python or userspace GUI in my industrial practice, so at best I can say nothing about it.
16:26:15 <campusblo> this is the reference book. Menezes, Alfred, et al. Handbook of Applied Cryptography. ISBN: 0-8493
16:26:28 <Philippa> wli: sure, but that's a different statement to "real-world stuff is $shortlist"
16:26:37 <campusblo> but im sure my lecturer pulls the projects out of some book with code yeh phillapa
16:26:49 <chessguy> is it possible to somehow derive Arbitrary for a simple data type?
16:27:10 <chessguy> e.g., i just have this: data Command = Right | Left | Up | Down (Eq, Show)
16:27:10 <chessguy> type Commands = [Command]
16:27:15 <campusblo> phillipa where is this nottingham code?
16:27:23 <wli> Philippa: I misspoke in a way that made it sound exhaustive.
16:27:30 <chessguy> i want to get arbitrary lists of commands.
16:27:39 <Toxaris> about Java: I don't like it for it's horrible syntax, but for a mainstream oo language, it has a nice type systems, there are a lot of research groups working on nice extensions, so for "going right into work as a programmer" after university, I would choose it. (or maybe C#) But I would learn as much other languages as possible before.
16:27:55 <ddarius> cedricshock: Execute the program with +RTS -xc
16:28:13 <Philippa> campusblo: hah. Not helping you with your homework!
16:28:23 <Philippa> besides, it was years ago I did the module
16:28:40 <wli> wrt. enterprise, embedded is so phenomenally vast it's not funny
16:28:55 <ddarius> Embedded is vast.
16:28:56 <cedricshock> ddarius: Thanks. Now to figure out what this mess means...
16:29:13 <Philippa> yeah. There's a rather different culture about the vastness though, no?
16:29:16 <wli> It dwarfs enterprise affairs, it dwarfs the PC installed base, it's borderline pervasive as things now stand.
16:29:18 <ddarius> cedricshock: The output from -xc should be pretty straightforward.  Use, maybe not.
16:29:33 <campusblo> Phillipa no biggie i actually dont mind doing it. ill just come on when i get stuck
16:29:35 <ddarius> It's only going to grow.
16:30:27 <wli> ddarius: I'd qualify that as relative to other fields. There are reasons to expect a general contraction in computing (along with many other things).
16:32:46 <syntaxfree> you know you're screwed up when you find yourself staring at the clock waiting for time for your meds.
16:33:02 <syntaxfree> oops, this isn't #haskell-blah. Uberspazzen blues will continue there.
16:33:26 <jfredett> ,...
16:35:02 <chessguy> if have this: data Command = Right | Left | Up | Down (Eq, Show); type Commands = [Command], is there an easy way to get a random list of random commands, using Arbitrary?
16:35:07 <cedricshock> ddarius: I can't find xc described in the profilling section of the manual. I get a bunch of things in <>s
16:36:01 <Baughn> cedricshock: http://haskell.org/ghc/docs/6.6/html/users_guide/runtime-control.html
16:36:02 <lambdabot> Title: 4.14. Running a compiled program, http://tinyurl.com/2paozb
16:37:24 <ddarius> xc isn't a profiling option
16:37:58 <ddarius> http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html#rts-options-debugging
16:38:00 <lambdabot> Title: 4.14. Running a compiled program, http://tinyurl.com/d7dj4
16:38:12 <ddarius> Ah, Baughn got it.
16:38:35 <Baughn> ddarius: Yes. I was quite surprised it existed, as I had previously been told that getting a backtrace was impossible..
16:39:37 <ddarius> Baughn: Well one problem with it is that it doesn't accurately match the actual control flow.
16:40:09 <Baughn> ddarius: It's a distinct improvement on _nothing_
16:40:12 <ddarius> But usually it's handy
16:40:54 <bringert_> ANN: video module for Hope, see http://hope.bringert.net/entry/23
16:40:56 <ddarius> Baughn: There are actually quite a few debugging approaches for Haskell.  Many that wouldn't be useful in other languages, they just are not well maintained/popularized.
16:41:54 <wli> bringert: Any hope [sic] for a LaTeX module?
16:42:09 <bringert_> wli: if someone writes one
16:42:29 <bringert_> wli: I don't have that itch at the moment, so I probably won't scratch it
16:42:33 <oerjan> chessguy: i think it is something like instance Arbitrary Command where coarbitrary = undefined; arbitrary = oneOf [Right, Left, Up, Down]
16:43:04 <chessguy> oerjan, wouldn't that give me only one of those though?
16:43:54 <oerjan> chessguy: that's the instance for a single command, the instance for Commands is (i hope) derived automatically from that + lists
16:45:05 <chessguy> @hoogle QuickCheck
16:45:05 <lambdabot> Test.QuickCheck :: module
16:45:05 <lambdabot> Test.QuickCheck.quickCheck :: Testable a => a -> IO ()
16:45:14 <oerjan> i am not sure that oneOf takes quite those arguments, though
16:45:38 <Toxaris> it's oneOf [return Right, return Left, ... ]
16:45:41 <Toxaris> I think
16:45:41 <chessguy> For example,
16:45:41 <chessguy> oneof [return True, return False]
16:45:44 <chessguy> yeah
16:46:01 <chessguy> so i don't have to define coArbitrary then?
16:46:01 <oerjan> ok it's a Monad :)
16:46:19 <chessguy> err, coarbitrary
16:46:20 <oerjan> chessguy: only if you want to generate functions taking commands are arguments
16:46:26 <oerjan> *as
16:48:16 <chessguy> @hoogle oneOf
16:48:16 <lambdabot> Text.ParserCombinators.Parsec.Char.oneOf :: [Char] -> CharParser st Char
16:48:17 <lambdabot> Test.QuickCheck.oneof :: [Gen a] -> Gen a
16:48:17 <lambdabot> Text.ParserCombinators.Parsec.Char.noneOf :: [Char] -> CharParser st Char
16:48:44 <wli> Oh, I've used parsec before.
16:49:42 <wli> Hmm. Not sure what these permutation parsers are.
16:50:19 <oerjan> oh wait it's oneof
16:51:11 <oerjan> i wonder if elements does that without return
16:51:26 <chessguy> @hoogle elements
16:51:27 <lambdabot> Test.QuickCheck.elements :: [a] -> Gen a
16:51:27 <lambdabot> Text.Html.getHtmlElements :: Html -> [HtmlElement]
16:51:58 <chessguy> so then how would i get a list of arbitrary lists?
16:52:05 <oerjan> @docs QuickCheck
16:52:05 <lambdabot> QuickCheck not available
16:52:12 <oerjan> @docs Test.QuickCheck
16:52:12 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/QuickCheck/Test-QuickCheck.html
16:52:14 <chessguy> @source QuickCheck
16:52:14 <lambdabot> QuickCheck not available
16:52:41 <chessguy> i've really never understood how quickcheck works
16:52:59 <oerjan> chessguy: i am pretty sure that QuickCheck automatically generates [a]'s once you tell it how to generate a's
16:53:26 <chessguy> but how do i actually get those lists
16:53:52 <oerjan> > generate
16:53:53 <chessguy> e.g., i want to do commandLists :: [[Command]]; commandLists = ...
16:53:53 <lambdabot>   Not in scope: `generate'
16:54:06 <oerjan> oh.
16:54:16 <oerjan> you want generate, i think
16:56:11 <oerjan> http://haskell.org/haskellwiki/Introduction_to_QuickCheck
16:56:12 <lambdabot> Title: Introduction to QuickCheck - HaskellWiki
16:57:55 <oerjan> @source Test.QuickCheck
16:57:55 <lambdabot> http://darcs.haskell.org/packages/QuickCheck/Test/QuickCheck.hs
17:03:20 <wli> Aha, parsing for free-order constructs.
17:04:30 <mm_freak_> is "--*-haskell-*-" a standard-conforming comment?
17:04:40 <chessguy> ugh, i can't figure out how to use generate :(
17:05:04 <oerjan> mm_freak_: no
17:05:13 <Pseudonym> mm_freak: It's a non-standard hack to make Haskell backwards-compatible with legacy editors.
17:05:17 <oerjan> --*- is an operator
17:05:23 <mm_freak_> i see
17:05:27 <chessguy> generate :: Int -> StdGen -> Gen a -> a
17:05:48 <chessguy> i can figure out the Int and the StdGen, but i don't know what it wants me to pass for the Gen
17:06:06 <Toxaris> (arbitrary :: YourType)
17:06:10 <chessguy> something like \x -> x == (x :: [Command])
17:06:11 <chessguy> oh
17:06:47 <Pseudonym> mm_freak: It's for Emacs.
17:07:11 <mm_freak_> pseudonym: yes, and "-- -*-haskell-*-" is pretty ugly
17:07:14 <chessguy> Couldn't match expected type `Command'
17:07:14 <chessguy> 	   against inferred type `Gen a'
17:07:16 <Pseudonym> Right.
17:07:26 <oerjan> > let a --*- b = a+b in 2 --*- 2
17:07:28 <lambdabot>  4
17:07:30 <Pseudonym> Not necessarily any more or less ugly than -- vim: syntax=haskell
17:07:36 <Pseudonym> But at least it's readable.
17:07:50 <Toxaris> chessguy: hmm, maybe (arbitrary :: Gen YourType) 
17:08:16 <mm_freak_> {--*-haskell-*--} works fine
17:08:27 <mm_freak_> uhm
17:08:28 <Pseudonym> That looks oddly like ASCII art.
17:08:41 <mm_freak_> {-*-haskell-*-}  even better =)
17:08:45 <oerjan> mm_freak_: yes, {- is not ambiguous
17:08:50 <chessguy> so i have this:
17:08:50 <chessguy> main = do
17:08:50 <chessguy>   g <- newStdGen
17:08:50 <chessguy>   print $ generate 5 g (arbitrary :: Gen Command)
17:09:11 <chessguy> but it only prints one command, and it's always the same one
17:09:36 <mm_freak_> i could just as well omit the mode completely  emacs recognizes .hs and .lhs automatically
17:09:43 <mm_freak_> but i like being redundant =)
17:09:46 <chessguy> oh, the Int is the seed
17:09:51 <Toxaris> do you really want a random command, or do you want to use quickcheck for checking properties?
17:10:12 <chessguy> the former
17:10:27 <chessguy> actually, i want a bunch of random lists of commands
17:11:16 <chessguy> i'd really like something like generateCommandLists :: Int -> IO [[Command]]
17:11:23 <chessguy> where the Int is the number of lists
17:11:30 <mm_freak_> btw, is there any "multiplicative inverse" operator?  something like (\x -> 1/x)
17:11:40 <oerjan> hm...
17:11:57 <chessguy> @pl \x -> 1/x
17:11:57 <lambdabot> (1 /)
17:12:19 <oerjan> chessguy: ah, you want vector
17:12:42 <mm_freak_> chessguy: a well-known operator that is
17:13:38 <mm_freak_> (\x -> 1/x) would imply a useless multiplication for my Mod type
17:14:20 <dons> moin
17:14:48 <chessguy> oerjan, like print $  (vector 3) :: Gen [Command] ?
17:14:49 <sioraiocht> hrm, haskell is 42nd most popular programming language according to TIOBE
17:14:57 <mm_freak_> gm, dons
17:15:02 * sioraiocht is annoyed that Lua is so up and coming.
17:15:16 <mm_freak_> lua sucks bad  it doesn't even have an integer type
17:15:35 <dons> sioraiocht: yeah, bit silly. we've done a lot of analysis of the number
17:15:37 <sioraiocht> mm_freak_: it's made for embedding programming, and it can be patched to use integer types
17:15:48 <dons> sioraiocht: they google for "haskell programming", and take google's suggested hits
17:15:48 <oerjan> chessguy: print $ generate 5 g (vector 3 :: Gen [[Command]])
17:15:56 <oerjan> i think
17:15:59 <mm_freak_> sioraiocht: according to the homepage it's a general purpose language
17:16:00 <dons> which are wildly inaccurate -- xmonad returns twice as many hits as "haskell programming"
17:16:28 <dons> sioraiocht: see http://cdsmith.wordpress.com/2007/06/18/is-tiobe-fatally-flawed/
17:16:32 <lambdabot> Title: Is TIOBE Fatally Flawed?  Sententia cdsmithus
17:16:40 <sioraiocht> mm_freak_: It can be used as one, but my boyfriend is very involved in the Lua community, it's design is geared toward embedded uses
17:16:44 <dons> basing the whole thing on the google-reported hits is just silly.
17:17:06 <chessguy> oerjan, it's magic!
17:17:10 <sioraiocht> dons: of course, it is what it is--one metric that doesn't really mean anything much ;)
17:17:14 <chessguy> oerjan++
17:17:38 <dons> if only google's results weren't so inaccurate.
17:17:51 <dons> Results 1 - 10 of about 94,100 for xmonad
17:17:57 <ddarius> Hasn't Lua already upped and comed?
17:17:58 <dons> xmonad is in the top 10 programming languages!
17:18:22 <dons> Results 1 - 10 of about 40,400 for "erlang programming"
17:18:26 <dons> poor erlang
17:18:29 <sioraiocht> ddarius: it's usage is very popular in the gaming industry from what I understand
17:18:40 <dons> Results 1 - 10 of about 7,860,000 for erlang
17:19:00 <chessguy> hmm, mostly short lists
17:19:05 <Toxaris> n is the size
17:19:06 <dons> Results 1 - 10 of about 15,100,000 for haskell.
17:19:09 <Toxaris> not the seed
17:19:26 <sioraiocht> dons: haskell isn't an uncommon surname, though
17:19:27 <mm_freak_> dons: try searching for "C" that way  99% of the results would be point-free
17:19:29 <dons> so, everyone use the phase "haskell programming" in public
17:19:36 <sioraiocht> hahah
17:19:39 <cc> whenever i search for jobs for haskell, i get like, restaurant managers whose first name si HAskell. then again i'd rather work at a restaurant than on WoW plugins
17:19:40 <dons> and we'll be in the top 10 by september.
17:19:41 <chessguy> Toxaris, in vector it is
17:19:47 <dons> haskell programming is fun!
17:19:52 <dons> yay for haskell programming
17:19:56 <chessguy> Toxaris, i think it's the seed in generate
17:20:03 <chessguy> Toxaris, i could certainly be wrong though
17:20:06 <Toxaris> look at the source
17:20:22 <chessguy> oh wow
17:20:26 <chessguy> it appears that i am
17:20:38 <chessguy> what a shock
17:21:07 <dons> we just need all the haskell bloggers to use the phase "haskell programming" in their blog text.
17:21:36 <ont_> It's not like there's a huge number of them.
17:22:19 <timthelion> dons you're speaking English right now, haskell can't compeat with myspace unless you get off your but and start socialising in pure functions
17:22:30 <dons> heh
17:22:50 <Toxaris> chessguy: http://paste.lisp.org/display/44167
17:22:54 <andy_t_roo> lol, i should post that to bash.org "timthelion: dons you're speaking English right now, haskell can't compeat with myspace unless you get off your but and start socialising in pure functions"
17:23:00 <dons> ont_: there's a fair few. probably 50 or so. certainly more than the number of xmonad bloggers -- which score twice as many hits..
17:23:13 <mm_freak_> german google reports "C&A" as the first result to "C"  i wouldn't know that C&A wear is written in C
17:24:19 <cedricshock> ddarius, Baughn: Thanks for the manual page. I got distracted by a phone call from my boss. The manual says I get one line per exception of the form <cci ... >, but I got one line with many <cci >s before the text of the exception.
17:24:24 <Baughn> So, to get a proper ranking, haskell should be called H?
17:25:00 <chessguy> Toxaris++
17:25:21 <ddarius> cedricshock: That shoud be the stack trace.
17:25:22 <Philippa> Baughn--
17:25:24 <Philippa> *bad*
17:25:26 <chessguy> i gotta run, back later maybe
17:26:06 <mm_freak_> baughn: then the crossover band "h-blockx" would write their songs in haskell (or H)
17:27:02 * dolio just freed up ~300MB of memory by restarting X. :)
17:27:27 <Baughn> ..well, that's not good
17:27:36 <dons> Andrew Coppin's producing 50% of the traffic on haskell-cafe@
17:27:37 <mm_freak_> dons: X doesn't have all that memory resident
17:27:39 <dons> hmm :/
17:27:59 <ddarius> dons: yeah...
17:28:06 <timthelion> dons: for instance, state that in the future haskell will be top ten like so: then = now \n googleTopTen :: Time -> [String] \n googleopTen t =  "Paris Hilton" : "Hillary Clinton" : "lose 20 pounds" :..."haskell" : []
17:28:26 <cedricshock> ddarius: It seems I'm getting multiple stacks for one exception. It doesn't match the description in the manual.
17:28:57 <timthelion> oops
17:29:13 <timthelion> I need an if t > then then
17:29:36 <Toxaris> timthelion: you need a temporal logic monad
17:30:14 <timthelion> lets write one, and then make everyone talk purely
17:30:21 <ont_> It would be easier to regard the entire thing as inane and not worry about it.
17:30:30 <timthelion> and have lambda bot bug them when they make a mistake
17:31:18 <timthelion> are there optional arguments in haskell?
17:31:42 <dolio> mm_freak_: That was according to 'free' not 'top' or something like it. free does report relatively accurate current usage, doesn't it?
17:31:50 <dons> timthelion: rarely used.
17:32:08 <Baughn> timthelion: Not syntactical, no
17:32:39 <mm_freak_> dolio: which window manager or DE are you using?
17:32:44 <dons> g x (Just n) = f x n
17:32:44 <dons> g x Nothing  = f x 42
17:33:26 <dolio> mm_freak_: KDE. I hadn't restarted X in at least a week, I think, so it's probably not surprising that KDE had caused extra allocated memorty to be sitting around.
17:33:52 <cedricshock> > show(12::Int)
17:33:55 <lambdabot>  "12"
17:34:00 <timthelion> so I have evencolumns which takes magconf cols delta ratio and if magconf is NoMag I ignore delta and ratio, so I was just trying to figure if I could make it nicer for people writing their Config.hs files in xmonad
17:34:05 <mm_freak_> dolio: yes, i'm pretty sure, that wasn't X's fault
17:34:35 <timthelion> dolio: do you have like 2 gigs of ram or something
17:34:37 <Baughn> dolio: When you say 300MB was freed - you mean the "used" column dropped by 300M, right? Not just the free column increasing?
17:34:38 <cedricshock> > "file_" ++ show(12::Int) ++ ".ext"
17:34:41 <dons> timthelion: Nothing/Just x is usually used for this. there's other examples in the Config.hs along those lines
17:34:41 <lambdabot>  "file_12.ext"
17:35:05 <mm_freak_> a lot of memory that X has in its address space is shared memory or mmaps or such
17:36:25 <wli> g x = maybe (f x 42) (f x)
17:38:23 * glguy thinks it would be cool if lambdabot used syntax highlighting for things like @src
17:38:32 <glguy> is the +c mode to block colors in channel?
17:38:46 <dons> yep
17:38:51 <dons> its rather traumatic otherwise
17:39:12 <glguy> is there a list of modes somewhere that I can't seem to find?
17:39:28 <glguy> I found the +q mode, shuts a user up without forcing them to leave
17:40:10 <cedricshock> @src chr
17:40:10 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
17:40:23 <edwardk> from a rampant generalization standpoint, and looking at things from the standpoint of monad comprehensions would there be value to considering generalized 'normal list' syntax? i.e. [a,b] = return a `mplus` return b, and taking the Enum interfaces for the enumFromThenTo sugar and allowing it to run over an arbitrary monad other than [a]?
17:40:44 <dolio> Baughn: Yeah, I mean the used column went from 670 MB to 320 MB.
17:41:09 <slowriot> What are the ramifications of having a persistant data structure with multiple version histories?
17:41:34 <edwardk> class EnumM a m where enumFromToThenM :: a -> a -> a -> m a; ...  or something?
17:41:43 <sjanssen> edwardk: it might confusing that "[a, b]" is the same as "Just a"
17:41:46 <edwardk> not sure how to run the fundeps on that though
17:42:13 <sjanssen> edwardk: 'm' probably doesn't have to be a parameter of the class
17:42:16 <edwardk> sjannsen: just trying to think for other data-structure like monads
17:42:23 <edwardk> sjannsen: yeah
17:42:25 <edwardk> good catch
17:42:34 <sjanssen> class Enum a where enumFromToThenM :: MonadPlus m ...
17:42:44 <cedricshock> slowriot: Slight increase in memory usage, depending on the data structure used. It can be very small for things like balanced trees, and it can be "compressed" into functions that return the spot in the history (with an algebra of changes)
17:43:02 <edwardk> that works, i couldn't implement it in my toy language without that catch =) i don't have MPTCs ;)
17:43:33 <edwardk> the main reason is it removes the 'specialness' of monad comprehensions, then anything done with []'s can be done in all monads (except pattern matching)
17:44:00 <edwardk> i.e. if you accept monad comprehensions its a small step to allow that
17:44:46 <slowriot> cedricshock: are there any positive ramifications? How would you take advantage of multiple version histories?
17:45:06 <oerjan> edwardk: actually you don't need to change the class, you could just change the slice notation
17:45:13 * glguy wonders if this shows up underlined
17:45:29 <oerjan> so it went by foldr mplus
17:45:31 <edwardk> oerjan: yeah, thats what i wanted to do, i wanted to change the slice notation, just like changing the list comprehensions into monad comprehensions
17:45:42 <cedricshock> slowriot: Lots of  positive ramifications.
17:46:12 <oerjan> edwardk: let [a .. b] mean foldr mplus (fromEnum a b)
17:46:17 <edwardk> in my toy language i've already accepted there are a lot of generalizations in the surface syntax anyways. ;)
17:46:42 <edwardk> the only problem there is it prevents efficient implementation on a monad by monad basis though
17:47:03 <oerjan> er.. insert a map return too
17:47:11 <cedricshock> slowriot: With a functional language like haskell if you ever have a "copy" of a piece of data that is non-mutable that data is guaranteed not to change and to be the same as when you got it, so it's very easy to hold on to a point in history, just remember it somewhere.
17:47:36 <oerjan> *enumFromTo
17:48:17 <cedricshock> Whoa. My screen is warping like one of those lens screensavers. Time to drink more water!
17:48:47 <edwardk> yeah [a..b] = foldr mplus . map return $ fromEnum a b
17:48:55 <edwardk> er enumFromTo
17:49:10 <slowriot> cedricshock: heh.. I'm in northwest US.. it's like 65 farenheit here.
17:49:21 <edwardk> i just thought it was a nice little generalization i'd never seen mentioned
17:49:47 <edwardk> with the oleg restricted monad hacks you can then use [] for set notation, etc.
17:49:48 <glguy> slowriot: I'm in the NW US and its 80 :)
17:50:30 <slowriot> glguy: are you in the Seattle area?
17:50:45 <cedricshock> glguy, slowriot: I'm in the NW and it's 87. But my vision is strange 'cause I have a fever.
17:50:56 <slowriot> cedricshock: aww... that sucks
17:51:00 <glguy> slowriot: portland
17:51:07 <edwardk> [1,3,3,2,2] :: Set Int  would give you back fromList [1,2,3] (or some permutation)
17:51:13 <slowriot> glguy: ah, yeah, there are a lot of functional programming people there
17:51:27 <sjanssen> we had a high of 99 F over here
17:51:35 <glguy> slowriot: I see a lot of them at work :)
17:51:36 <slowriot> I am way out on the olympic peninsula. It's actually 63 degrees here. Not kidding.
17:51:50 <edwardk> hence why i want some way to allow for an efficient per monad specialization of it
17:52:54 * wli is in Portland, too.
17:53:31 <oerjan> edwardk: but if you want specialization then you _do_ need the monad in the class parameters
17:53:40 <edwardk> oerjan: yeah =/
17:53:46 <glguy> wli: Hillsboro?
17:53:57 <wli> edwardk: I like the foldr mplus . map return $ enumFromTo a b version.
17:53:57 <edwardk> i think what i'll do is implement it the 'weak' way and see if its useful
17:54:04 <wli> glguy: Yes.
17:54:11 <edwardk> then i'll look at empowering it later
17:54:13 <glguy> wli: I'm next door in Beaverton :)
17:54:35 <wli> edwardk: Is the intermediate list necessary? I wonder.
17:54:55 <edwardk> wli: well, you can just change enumFrom*'s signature
17:55:11 <wli> glguy: It's only a technical designation. It's Tanasbourne.
17:55:59 <wli> edwardk: Woops, there's no Eq instance there to terminate succ etc.
17:56:06 <dolio> edwardk: Seems like you should only need a single parameter type class for it.
17:56:24 <edwardk> dolio: yeah, wow, its haskell-98'ish =)
17:56:56 * wli is unsure of how enumFromTo operates without Eq anyway.
17:57:10 <oerjan> wli: it's a class method
17:57:11 <edwardk> wli: each class supplies its own implementation
17:57:43 <dolio> Doesn't it have a default implementation.
17:57:52 <dolio> Using from/toEnum and int/integer?
17:58:17 <oerjan> dolio: a default derivation, yes, but not in source
17:59:18 <edwardk> enumFrom x = map toEnum [fromEnum x ..]   etc
17:59:26 <wli> My cantor bits were originally devised to instance (Enum t, Enum t') => Enum (t, t')
17:59:36 <edwardk> remember you can convert toEnum and fromEnum back and forth to Ints
17:59:38 <edwardk> and those are ==
17:59:55 <oerjan> dolio: er, i am wrong
18:00:31 <Toxaris> timthelion: temporal logic for pure conversation about Haskell's success story: http://paste.lisp.org/display/44168
18:01:35 <wli> I suppose one could define an Enum instance on Ratio Integer with it, too.
18:05:07 <Shimei> Any Gtk2Hs gurus here? I'm trying to figure out if a MenuItem widgets sub-menu items can be found with castToContainer and containerGetChildren.
18:05:31 <sorear> .
18:06:08 <edwardk> and nicely the default enumFrom, etc versions would just roll the the monad in if the sugar desugared into using the generalized version
18:07:01 <edwardk> also, it doesn't need an mzero, just an mplus, no?
18:07:47 <wli> I wonder how you change the type signatures of builtins like that.
18:08:03 <edwardk> wli: you hack ghc ;)
18:08:30 <wli> I was thinking more specifically.
18:08:38 <oerjan> edwardk: you need mzero for []
18:08:48 <oerjan> oh wait
18:08:56 <edwardk> oerjan: only if they use it no?
18:09:41 <oerjan> edwardk: we forgot an argument to foldr, which must be mzero
18:10:08 <edwardk> i don't need to foldr though.
18:10:17 <dolio> enumFromTo n (n-1) == mzero
18:10:42 <edwardk> dolio: ah yeah i guess i should allow implementations to return empty lists huh? =)
18:10:47 <edwardk> > [1..0]
18:10:48 <lambdabot>  []
18:11:54 <sorear> @seen hpaste
18:11:55 <lambdabot> I saw hpaste leaving #haskell 11h 28m 49s ago, and .
18:16:20 <dolio> edwardk: You could define it such that 'enumFromTo n m == reverse (enumFromTo m n)', but that'd break some use cases of it.
18:17:20 <edwardk> dolio: yeah, not much of a fan of that
18:17:58 <glguy> Does anyone know if GHC 6.6.1 is hard-masked in gentoo because the ebuild doesn't work well?
18:18:01 <edwardk> heh, haskell gets the better end of the deal here with the Set and Bag restricted monad cases though. I'm jealous =)
18:18:07 <glguy> or if its because its just a new version from 6.4.2?
18:18:41 <dolio> edwardk: You'll just have to implement MPTCs. :)
18:18:51 <edwardk> dolio they break the rest of my type system =)
18:19:05 <dolio> Heh.
18:20:41 <edwardk> in exchange i can say things like: class Field f <: CommutativeRing f & Reciprocable {x : f | x /= 0} where forall x. x * recip x %> 1 -- so i guess its not all bad
18:21:13 <wli> Reciprocable? You mean division rings?
18:21:23 <edwardk> i can't figure out how to plumb around all the subset types when i add in MPTCs
18:21:41 * wli notes the quaternions are a noncommutative division ring.
18:22:07 <edwardk> class Reciprocable a where recip :: a -> a     is a cheesy way for me to introduce the same method in both multiplicative groups and later in fields
18:22:22 <edwardk> i mix it in with the intersection type on the interfaces
18:22:26 <jfredett> whats the minimum definition for Enum? it doesn't seem to be in the Haddock docs.
18:23:09 <wli> edwardk: Groups can't have annihilators.
18:23:36 <oerjan> jfredett: fromEnum, toEnum
18:23:45 <oerjan> (it's in the Prelude source)
18:23:51 <jfredett> okay
18:23:53 <jfredett> thanks
18:24:03 <mm_freak_> wli: what is an annihilator?
18:24:10 <oerjan> (which i conveniently looked at 5 minutes ago :)
18:24:32 <wli> mm_freak: A zero-like element. If o is an annihilator then o*x=o for all x.
18:24:38 <edwardk> right-annihilates  e f = forall a. f a e %> e     -- heh in my toy syntax =)
18:25:00 <edwardk> 0 `annihilates` (*)
18:25:48 <edwardk> er where annihilates e f = left-annihilates e f & right-annihilates e f
18:26:01 <wli> The multiplicative structure of a field is tricky that way. Basically a monoid with a unique annihilator.
18:26:49 <Pseudonym> That would be a ring.
18:26:55 <mm_freak_> wli: thank you
18:26:59 <edwardk> wli: yeah, thats why i define its interaction with Reciprocable with the domain restriction.
18:27:13 <oerjan> Pseudonym: only half of one
18:27:31 <wli> A two-step construction on a field with the nonzero elements as a multiplicative group, then when you adjoin an annihilator you get something that's an additive group with the annihilator as the identity.
18:27:36 <edwardk> i had an earlier version of all of this with the non-commutative algebra nonsense, but for now i'm just sticking to pretty much mainstream
18:27:58 <wli> Well, s/field/division ring/
18:28:12 <wli> Impose commutativity on the multiplicative group and it's a field.
18:28:50 <wli> Typecheckers have no way to do anything with that condition, so you might as well just call it a division ring.
18:29:11 <mm_freak_> wli: GF(15) has a submonoid ({0 ... 15},*,1), is 0 the only annihilator there?  (i'm asking because (*3) is 0 for some arguments, but not for all)
18:29:25 <mm_freak_> uhm
18:29:30 <wli> mm_freak: There is no Galois field of order 15.
18:29:38 <edwardk> wli: well, i do incur a proof burden for that even if it only becomes a runtime check if i can't prove it and i'm being paranoid or if i have to quickcheck it to handwave about it
18:29:43 <mm_freak_> yeah, and the submonoid is wrong, sorry
18:29:51 <mm_freak_> wli: Z/15Z has a submonoid ({0 ... 14},*,1), is 0 the only annihilator there?  (i'm asking because (*3) is 0 for some arguments, but not for all)
18:30:14 <wli> mm_freak: Z/(15Z) has a ring of units of order phi(15) = phi(3)*phi(5) = 2*4 = 8 etc.
18:30:43 <wli> mm_freak: 3 is not an annihilator, but you can't get a field of composite characteristic anyway.
18:31:20 <mm_freak_> wli: yes, it wasn't meant to be a field  i just confused the GF notation
18:31:25 <dons> sorear: see this guy on the list using streams, and failing badly. bulat's streams considered harmful, much as hugs is, in my books. its just a distraction, that leads to a poor impression of the state of the libraries. oh well :(
18:32:11 <wli> mm_freak: Here I start with the group of units U, then adjoin the annihilator, then superimpose additive structure.
18:32:14 <dons> sorear: any thoughts on how best we can ensure people use the right libs for these kinds of tasks?
18:33:27 <dons> http://programming.reddit.com/info/24mmr/comments
18:33:28 <lambdabot> Title: A Unix datapipe in Haskell (reddit.com)
18:34:18 <glguy> dons: key them, and require them to ask #haskell to unlock them ;)
18:34:47 <dons> sounds like a plan.
18:34:47 <sorear> dons: what's your take on "anything on hackage should work out of the box"?
18:34:57 <dons> sorear: hmm, given version checks..
18:35:08 <wli> mm_freak: Division by 0 typechecks in such a fashion (essentially you have data DivRing = Zero | NonZero MultGroup)
18:35:17 <dons> there should be a 'needs ghc X, Y or Z' check
18:35:25 <sorear> dons: I mean, HAppS requires you to add -DUNIX to the cabal file if you're using UNIX.  (it doesn't autodetect)
18:35:33 <dons> oh, it should.
18:35:40 <dons> autoreconf for that. simple.
18:36:14 <mm_freak_> wli: it was just the definition of annihilators i was asking for  so (in a commutative monoid) an annihilator is an element A, for which A*X = A for every X ?
18:36:15 <sorear> well, you CAN leave it off, but it will result programs expecting input on stdin and not responding to UNIX signal conventions
18:36:25 <wli> mm_freak: You can force people to check for zero before division in such a fashion.
18:36:36 <dons> i think the happs guys should really check that. a simple configure script
18:36:42 <sorear> I'm wondering if maybe we should disallow any package with a README
18:36:55 <dons> no, that's just silly
18:36:56 <wli> mm_freak: It holds in a commutative semigroup, even.
18:37:12 <wli> mm_freak: And you have right and left annihilators for noncommutative semigroups.
18:37:25 <mm_freak_> k, thank you =)
18:37:33 <sjanssen> sorear: can Cabal configurations handle that?
18:37:43 <sorear> sjanssen: No, because they don't exist.
18:37:57 <sorear> @where lists
18:37:57 <lambdabot> I know nothing about lists.
18:38:10 <sorear> @google site:haskell.org haskell-cafe archives
18:38:12 <lambdabot> http://www.haskell.org/mailman/listinfo/haskell-cafe
18:38:12 <lambdabot> Title: Haskell-Cafe Info Page
18:39:46 <sorear> dons: How would I check this?  I'm thinking of patching happs to auto-detect.
18:40:33 <sjanssen> sorear: right, but it looks like the proposed system can do this cleanly
18:42:17 <sorear> right, but I have to do *something* to make up for my irritated outburst on discovering that -DUNIX was needed! :)
18:42:38 <sjanssen> sorear: they should just make -DUNIX default :)
18:42:40 <wli> mm_freak: It really all starts from magmas, http://en.wikipedia.org/wiki/Magma_%28algebra%29
18:42:41 <lambdabot> Title: Magma (algebra) - Wikipedia, the free encyclopedia
18:42:51 <sjanssen> what sort of nutty people run servers on Windows?
18:43:38 <mm_freak_> wli: interesting, thank you
18:43:40 <sorear> sjanssen: Apparently shapr.  It used to be the default, but there's a shapr-from patch changing that (alone)
18:45:03 <sjanssen> sorear: shapr runs Debian exclusively IIRC
18:45:13 <edwardk> wli: which is where i start my numerical tower =)
18:45:37 <edwardk> class Magma+ a where (+) : a -> a -> a; class SemiGroup+ a <: Magma+ a where | associative (+); ...
18:45:40 <sorear> Wed May 23 12:49:06 PDT 2007  shae@ScannedInAvian.com * remove -DUNIX from the cabal file. If you want to use the POSIX signal handler you can add -DUNIX to ghc-options in HAppS.cabal
18:46:07 <wli> edwardk: I'm not sure how you deal with e.g. commutativity/associativity/etc.
18:46:07 <sorear> of course, this is not mentioned *anywhere* except _darcs/inventory
18:46:15 <sorear> which isn't usually on my reading list
18:47:14 <wli> edwardk: Did you notice the bit where I forced people to check for division by zero via the type system?
18:47:17 <sjanssen> sorear: it isn't even in the README?
18:47:18 <edwardk> wli: subset types incur the proof burden, then i check what i can, and if i can't prove it I insert runtime checks. most of the associativity, commutativity, things are actually cues from the developer to the compiler about possible optimizations that it permits, not so much things to check
18:47:38 * littledan wonders how they came up with all the names in abstract algebra
18:47:50 <wli> littledan: Historical accident.
18:47:57 <sorear> sjanssen: The readme should be called PROPAGANDA - it may be 5 pages of html, but it doesn't give any technical information
18:48:45 <edwardk> compiling in my case is 80% flow analysis and abstract interpretation, 20% type checking
18:50:29 <sjanssen> sorear: that sucks.  They ought to have an INSTALL or something
18:50:33 <jfredett> hmm, I have a data type: data Nat = Z | S Nat, and I want to export the S and Z's from the module, whats the syntax for that? I've already exported Nat, and tried just exporting S and Z, and etc.
18:50:52 <sjanssen> nobody is going to look through the changelog to find -DUNIX
18:50:55 <sorear> (Nat(N,S))
18:51:01 <jfredett> ah, brilliant
18:51:09 <sjanssen> jfredett: or Nat(..) to export all constructors
18:51:19 <jfredett> cool
18:51:24 <edwardk> wli: i'm not going for a proof system like coq, i'm looking for something more usable where a little bit of formality in the specification opens up a lot to the optimizer and a little more in the way of compile-time model checking
18:51:36 <wli> Is there a meaningful example where only a proper subset of the constructors are exported?
18:51:42 <sorear> sjanssen: yeah... can we convince them to change without coming off badly?
18:52:19 <sorear> bah.  /me unpulls alexj's latest patches, since they utterly break the build
18:52:35 <edwardk> wli: say i have some sort of special list type with a recursive constructor, that i don't want to expose, but i'll expose the cons and nil constructors directly
18:52:52 <Saizan> we should also convince alexj to test/build with cabal
18:52:55 <edwardk> the use cases are a little strained ;)
18:53:21 <edwardk> mainly because it only allows partial pattern matching
18:53:29 <sorear> Saizan: Is there any other way to build?
18:53:41 <sorear> Saizan: I don't see any documentation
18:53:50 <Saizan> sorear: he uses searchpath or what is called
18:53:56 <sjanssen> sorear: he probably uses the zany searchpath thing he invented
18:54:03 <sorear> searchpath?
18:54:13 <sjanssen> sorear: see mailing list discussion from about 2 years ago
18:54:15 <wli> edwardk: I can't think of a good case.
18:54:16 <glguy> it darcs gets all the sources
18:54:17 <sorear> @where searchpath
18:54:18 <lambdabot> I know nothing about searchpath.
18:54:31 <gmh33> can anyone help explain this? http://worrydream.com/AlligatorEggs/
18:54:32 <lambdabot> Title: Alligator Eggs!
18:54:33 <glguy> sorear: and then installs them locally to the thing he's building
18:54:45 <wli> For the moment I'm trying to think of how to represent sparse matrices.
18:54:58 <oerjan> gmh33: it's a thinly disguised lambda calculus
18:55:08 <edwardk> wli: well, since you don't have subtypes in haskell, say you start with a type for expressions, then you closure convert and perform other simplifications so that some of the constructors don't occur in user visible code, but you want them to be able to manipulate the remaining fragment of types in the AST, etc.
18:55:32 <edwardk> like i said, use cases are a little strained ;)
18:55:33 <gmh33> oerjan: I got that part, but I don't "know" lambda calculus and am looking for some clarification on a few things :)
18:56:06 <wli> edwardk: Don't subtypes make type inference undecidable?
18:56:57 <wli> edwardk: Well, depending on various (AIUI common) things, of course.
18:56:59 <edwardk> wli: in the most general sense, yeah. but you can still do local type inference, and you can perform hacks like OOHaskell did where they just presume that if you use a recursive function that you use it with the same type in positive and negative position, etc
18:57:05 <gmh33> mostly, why not has question-mark eggs in it's definition :/
18:57:13 <gmh33> and how one deals with those
18:57:30 <edwardk> wli: on the other hand, polymorphic records and variants are decidable and have a subtyping relationship between them, see MLPolyR for an example
18:58:02 <wli> edwardk: Local type inference being where you have signatures for top-level declarations?
18:58:15 <gmh33> or are those just like "wild card" eggs
18:58:35 <oerjan> gmh33: i think those question marks are like an exercise to fill out
18:58:40 <edwardk> in my case the only subtypes i have are in polymorphic records and variants (which are decidable) and in subset types, which can never lead to a bad physical representation, and which tend to be decidable in practice, and which i can always abort and complain, offering to insert runtime checks about.
18:59:06 <gmh33> oerjan: oooooo
18:59:10 <edwardk> er and quotient types, but i'm still on the fence about the ultimate utility of those
18:59:29 <wli> edwardk: I've not heard of those.
19:00:05 <edwardk> take the quotient Parity = Int // (\x y = x mod 2 == y mod 2); even = 0 : Parity; odd = 1 : Parity
19:00:25 <edwardk> then you can always transform a function that returns an Int into one that returns a "Parity"
19:00:35 <edwardk> and you can always transform a function that takes a Parity into one that takes an Int
19:00:43 <Toxaris> gmh33: the question mark eggs are a challenge for you: try to give them meaningfull colors
19:00:44 <edwardk> therefore Int <: Parity
19:01:04 <edwardk> so while subset types let you define an arbitrary subtype of a type satisfying a predicate, quotient types let you define an arbitrary supertype
19:01:24 <Toxaris> gmh33: wich doesn't work because, as stated on the page, the color rule isn't good enough
19:01:35 <wli> edwardk: Modding out a relation seems problematic wrt. choosing representatives.
19:01:41 <edwardk> it gets more interesting if you start to allow their use in the 'wrong' position, so that you can try to check automatically that (+) on addition are parity-preserving so that even + even == even, etc.
19:02:08 <edwardk> wli: the idea is that the representative doesn't matter, so the goal then is to prove that if you use it in the wrong position that the function is equivalence class preserving
19:02:20 <wli> edwardk: Okay.
19:02:24 <gmh33> also, in the "Not" example, the yellow one eats whatever you put to the right of the definition, not the ones in the picture down and to the right of it?
19:02:27 <edwardk> and the other burden is that the relation you take the quotient w.r.t is an equivalence relation
19:03:09 <wli> I'm thinking about how to represent sparse matrices.
19:03:12 <edwardk> wli: anyways the problem is unlike subset types i can't construct a set of runtime checks as to the sanity of a quotient type
19:04:12 <edwardk> i can quickcheck it, i can check some cases for equivalence relations that finitely partition the space, etc. but i can't prove it in general or fall back on a runtime thing without recording as i go, then crying foul when i can show that two things in the same equivalence class yielded inequivalent answers
19:04:25 <edwardk> so i'm not quite sold on their general utility yet
19:04:38 <oerjan> gmh33: right
19:04:38 <wli> edwardk: Gosper arithmetic on continued fractions mod equality of limits. ;)
19:05:15 <edwardk> wli: I'm not designed to handle the esoteric cases, just enough that the  programmer can derive some utility from me nibbling around the edges of undecidability
19:05:42 <Toxaris> gmh33: What should be the result of "Not" eating "True"?
19:06:00 <edwardk> if you want to make a type { x : T | P = NP }, go for it, just don't expect to get a good answer from the type checker at compile time ;)
19:06:16 <gmh33> "False"
19:06:51 <Toxaris> gmh33: yep. Now what color's have to question marks eggs to have to make this possible?
19:07:09 <gmh33> I'm working on that part ;)
19:07:34 <gmh33> or is it just that one has to be green and the other has to be red
19:07:48 <wli> edwardk: Equivalence classes of Cauchy sequences, then.
19:07:53 <Pseudonym> { f : A -> B | f halts for all A }
19:08:47 <Toxaris> gmh33: Not so bad! Wich one is wich?
19:08:49 <edwardk> wli: again, same problem. its Pi_2^0 complete, it won't answer. i'll offer to insert a runtime check, and note that it will probably hoist you into non-termination.
19:08:52 <wli> edwardk: Cauchy sequences in p-adic numbers are representible via type system constraints I believe.
19:09:01 <edwardk> wli: i'm cherry picking the easy stuff =)
19:09:32 <edwardk> wli: its really easy to find cases where this won't work, its also easy to find cases where it will
19:09:35 <gmh33> left is red, right is green :)
19:10:22 <wli> edwardk: I'm thinking it's possible to get "interesting" instances of it.
19:10:35 <edwardk> wli: yeah, thats my goal =)
19:10:54 <edwardk> i need to get farther along in efficiency before most of those become viable though
19:11:08 <Toxaris> gmh33: yep, sounds good
19:11:35 <Saizan> !paste
19:11:35 <hpaste> Haskell paste bin: http://hpaste.org/
19:11:47 <sorear> nice try
19:12:05 <wli> I'm thinking systems of integer linear inequalities may be the way to represent things.
19:12:41 <edwardk> wli: i'm using the octagon abstraction domain when working with integers, the rest of it is done via a cheesy form of abstract interpretation
19:13:32 <edwardk> i track the various associativity, etc properties so that later i can appeal to known unification algorithms for those subsets of operators where possible. since i only care about soundness not completeness i can do a lot
19:15:50 <edwardk> cons a m = return a `mplus` m  ?
19:16:09 <edwardk> on a different topic =)
19:16:31 <edwardk> > let cons a m = return a `mplus` m in cons 1 [2]
19:16:33 <lambdabot>  [1,2]
19:16:57 <edwardk> > let cons a m = return a `mplus m in cons 1 Nothing
19:16:57 <lambdabot>  Parse error
19:17:06 <edwardk> > let cons a m = return a `mplus` m in cons 1 Nothing
19:17:09 <lambdabot>  Just 1
19:17:20 <edwardk> @pl cons a m = return a `mplus` m
19:17:21 <lambdabot> cons = mplus . return
19:17:24 <edwardk> duh
19:18:18 <edwardk> then of course nil = mzero
19:18:46 <glguy> rather than mappend and mempty?
19:19:12 <edwardk> i want to use the monadic version rather than the monoidal one
19:19:20 <edwardk> rolls up nicer
19:19:23 <edwardk> @type mplus . return
19:19:27 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => a -> m a -> m a
19:19:31 <edwardk> @type mappend . return
19:19:34 <lambdabot> forall a (m :: * -> *). (Monoid (m a), Monad m) => a -> m a -> m a
19:19:38 <edwardk> blech
19:19:50 <Shimei> @pl reverse $ takeWhile ((/=)'/') $ reverse "/usr/shared/computers.hs"
19:19:51 <lambdabot> reverse (takeWhile ('/' /=) (reverse "/usr/shared/computers.hs"))
19:20:25 <xpika> has anyone made a live haskell cd yet?
19:20:37 <littledan> haskell isn't an OS
19:20:52 <edwardk> just was thinking about cons and nil for the generalized list notation above
19:20:59 <Pseudonym> Haskell is the greatest OS in existence, after Perl and Emacs.
19:21:16 <edwardk> thats not fair.. emacs really kind of is an OS ;)
19:21:29 <Toxaris> but unlike notepad, it
19:21:49 <glguy> > let f [] acc = acc; f ('/':xs) _ = f xs xs; f (_:xs) acc = f xs acc in f "/usr/shared/computers.hs" []
19:21:52 <lambdabot>  "computers.hs"
19:21:53 <littledan> xpika, you could make a Haskell CD by downloading the GHC installer and burning it onto a CD
19:22:20 <littledan> xpika, what are you thinking of, specifically?
19:22:23 <xpika> littledan: i was reffering to somthing like the Live Pugs cd. a minimal linux with pugs on it
19:22:29 <sorear> nah, just burn 'main=fail""' onto it
19:22:45 <littledan> oh, sorry
19:22:58 <Toxaris> but unlike notepad it's not good as a spreadsheet processor
19:23:14 <sorear> xpika: the linspire crew is using Haskell for all their glue scripts.  maybe that would qualify?
19:23:28 <sorear> Toxaris: funny you should mention that...
19:23:38 <sorear> @go pivotal haskell
19:23:40 <lambdabot> http://www.cs.kent.ac.uk/projects/pivotal/
19:23:41 <lambdabot> Title: Pivotal home page
19:25:07 <Toxaris> sorear: interesting
19:25:29 <xpika> sorear: pivotal wansnt what i was looking for but it does look interesting
19:26:07 <sorear> xpika: I was replying to --> 19:22 < Toxaris> but unlike notepad it's not good as a spreadsheet processor <-- , sorry for the mixup.
19:28:23 <xpika> sorear: thats ok ** compiling hs-plugins
19:28:39 <sorear> xpika: what version of GHC, what version of hs-plugins?
19:28:57 <sorear> xpika: 6.6.x GHC requires darcs hs-plugins
19:31:47 <xpika> sorear: thanks
19:33:04 <xpika> @where hs-plugins
19:33:05 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
19:33:13 <xpika> i cant find the darcs dir
19:33:40 <glguy> ?where utf8
19:33:40 <lambdabot> http://code.haskell.org/utf8-string/
19:33:54 * glguy wonders if that should be changed to point to hackage
19:34:16 <glguy> ?where+ utf8 http://hackage.haskell.org/cgi-bin/hackage-scripts/package/utf8-string-0.1
19:34:17 <lambdabot> Done.
19:34:20 * glguy decides unilaterally
19:34:36 <sorear> glguy: ok, hpaste is in my crontab now (yay!)
19:34:51 <sorear> glguy: kakapo's uptime is 12h... hpaste left 12h ago...
19:34:51 <glguy> for restarts?
19:34:53 <sorear> yeah
19:34:56 <glguy> nifty
19:35:17 <sorear> also, I've hacked hpaste/happs so that you can use start-stop-daemon like any decent UNIX service
19:35:56 <glguy> what did you have to change for that behavior?
19:36:10 <glguy> do you pipe the stdout to a file then?
19:36:40 <sorear> glguy: I removed all your signal handling code, and enabled the happs signal handler
19:36:46 <sorear> -DUNIX
19:36:55 <glguy> s/your/dons :)
19:36:55 <sorear> documented *only* in _darcs/inventory
19:37:41 <glguy> HAppS is one of those things that if you aren't actively developing it, ther eis a lot to miss
19:37:52 <sorear> @ask shapr What is the rationale for making HPaste default to a !UNIX configuration?  Most users seem to be UNIX
19:37:52 <lambdabot> Consider it noted.
19:38:15 <glguy> sorear: I agree with you, but how many HAppS users do you know?
19:38:34 <sorear> @ask alexj Is alex@happs.org still a valid address?
19:38:34 <lambdabot> Consider it noted.
19:38:38 <sorear> glguy: 0 personally
19:39:44 <dons> sorear: ok, so I wrote a demo using zlib and binary to solve the guy's issue with bulat's lib.
19:40:07 <dons> my bet: bulat will say something amusing about how haskell is 100x slower. and Andrew Coppin will reply asking what Data.Binary is.
19:41:12 <sorear> dons: Oh, that reminds me.  In response to Bulat's claim that it was impossible for a library to make [Word8] -> [Bool] fuse, I tried to set up something with D.L.Stream
19:41:26 <dons> should fuse fine.
19:41:45 <dons> why wouldn't it?
19:41:48 <sorear> dons: not much interesting happened until I added a fusable version of [] and uncommented the rules for (:) and concatMap
19:41:58 <sorear> dons: at which point GHC promptly diverged
19:42:01 * glguy wonders if bulat deliberately makes this inciteful statements to drive the state of haskell forward :)
19:42:06 <dons> unfoldlr f . foldr (\a b -> True : b) .  == fusible Word8 -> Bool and back
19:42:13 <dons> sorear: oh, that's interrresting.
19:42:20 <dons> sorear: yeah, (:) ain't no good
19:42:30 <dons> sorear: but you want to use nice fusible combinators, what did you try ?
19:42:37 <dons> glguy: well, hmm. he writes weird code.
19:42:51 <SamB> is [0..7] nice and fusible?
19:42:52 <sorear> dons: concatMap $ \ wrd -> [ wrd .&. 128 /= 0, ...
19:42:55 <dons> this was my reply, anyway,
19:42:56 <dons> http://article.gmane.org/gmane.comp.lang.haskell.cafe/25206
19:42:58 <lambdabot> Title: Gmane -- Mail To News And Back Again
19:43:00 <dons> sorear: oh, concatMap is a bit nasty
19:43:02 <sorear> SamB: Yes, but [0,1,2,3,4,5,6,7] isn't.
19:43:06 <dons> sorear: you need the ghc head with the concatMap patch
19:43:11 <dons> [0..7] will fuse
19:43:18 <sorear> dons: concatMap patch?
19:43:25 <glguy> dons: can GHC transform: f x ++ f y to something like: g x (g y [])
19:43:31 <sorear> glguy: Yes.
19:43:32 <dons> oh, sorry, no. i'm thinking of the concatMap/list comprehensions patch
19:43:32 <SamB> sorear: so why would you have [0,1,2,3,4,5,6,7] instead of [0..7]?
19:43:38 <dons> sorear: concatMap on its own should be ok.
19:43:42 <glguy> sorear: is that default behavior then?
19:43:52 <glguy> or just possible?
19:44:01 <sorear> glguy: Possible, and very easy.
19:44:08 <sorear> glguy: 3 characters on the command line
19:44:10 <edwardk> ugh, i just felt the impact of the lack of MPTCs, they made it through my standard library just fine until i started doing monad transformers, gah
19:44:18 <glguy> -O2?
19:44:25 <sorear> -O .
19:44:33 <sorear> "-O "
19:44:35 <glguy> ah
19:44:37 <glguy> cool
19:44:39 <sorear> need a space :)
19:45:02 <SamB> do they have to be in that order?
19:45:26 <xpika> pivitol wants the old hs-plugins :(
19:46:56 <SamB> hmm, what's with this version: linux-image-2.6.18-4-686 2.6.18.dfsg.1-12
19:47:13 <SamB> is the Linux kernel not DFSG compliant anymore?
19:47:29 <sorear> SamB: Correct.
19:47:35 <SamB> what changed?
19:47:41 <SamB> between -3 and -4?
19:48:01 <sorear> SamB: 802.11b cards and FCC driver licensing restrictions, mostly
19:48:17 <SamB> damn FCC poking their nose where it doesn't belong!
19:48:27 <glguy> dfsg?
19:48:43 <sorear> @google DFSG
19:48:45 <lambdabot> http://www.debian.org/social_contract
19:48:45 <lambdabot> Title: Debian Social Contract
19:48:46 <SamB> it's like the OSD, only it says Debian everywhere
19:49:23 <SamB> anyway, I don't happen to have any 802.11 cards so I guess I don't really mind if they had to remove those
19:49:39 <SamB> in *practical* terms
19:50:09 <Pseudonym> Feel free to fork!
19:50:20 * SamB is trying to decide whether or not it's soon enough to remove the -3 kernel
19:50:25 <SamB> Pseudonym: and get the FCC on my tail?
19:50:40 <Pseudonym> Removing the 802.11 drivers won't bother them.
19:50:52 <glguy> so Debian can't include support for 802.11 wireless cards because of FCC rstrictions?
19:51:00 <SamB> presumably the Debian people already did that!
19:51:18 <SamB> which would be why there is a "dfsg" in this version number
19:51:47 <SamB> glguy: perhaps it only affects WEP, I have no idea
19:52:10 <sorear> glguy: Most of them.  You have to have non-free software *somewhere*, but a few cards have an onboard ROM allowing the kernel to stay untainted
19:52:43 <SamB> hey, nothing wrong with some non-free software on a ROM that comes with the hardware is there?
19:53:04 <SamB> well... as long as it works
19:54:03 <sorear> SamB: AIUI, it's illegal to sell a device that the user can reprogram to jam (cell phones, police band, can't remember which).  So since it would be too expensive to make a card that *physically* can't transmit on those frequencies, you just don't document the internal hardware interface.
19:54:10 <sorear> *big* AIUI there.
19:54:29 <SamB> that sounds about right
19:55:12 <dons> anyone know why people wouldn't know to use Data.Binary and bytestrings when compressing/streaming large amounts of data?
19:55:21 <dons> what can we do to avoid people running off into the wrong libraries?
19:55:33 <dons> and how can we encourage andrew copping to use google?
19:55:37 <Cale> Put Data.Binary in the GHC package?
19:55:59 <dons> in debian et al?
19:56:02 <Cale> yeah
19:56:10 <dons> yeah, that'd be good.
19:56:15 <Pseudonym> What OS is Andrew Coppin using?
19:56:16 <glguy> is there a good way to say: $ install_hackage binary-0.x
19:56:20 <sorear> Pseudonym: Windows
19:56:21 <glguy> and then be done with it?
19:56:22 <dons> Pseudonym: windows, I think.
19:56:24 <Pseudonym> Right.
19:56:32 <Pseudonym> BTW, for the record, I applaud his enthusiasm.
19:56:35 <dons> glguy: there's cabal-install, in cabal darcs.
19:56:42 <dons> Pseudonym: yeah. very enthusiastic. LOL
19:56:45 <Cale> Perhaps we should have 'light' and 'full' distributions of GHC, and if you get the 'full' distribution, it comes with the best of Hackage.
19:56:48 <glguy> dons: and that would solve the same problem?
19:57:04 <sorear> Cale: fyi, your op bit is still set
19:57:09 <Cale> oh, right
19:57:09 <dons> glguy: isn't cabal-install the program you're looking for? or am i misunderstanding?
19:57:11 --- mode: Cale set -o Cale
19:57:35 <dons> Pseudonym: how do we best encourage him to use the available resources though?
19:58:33 <Cale> It would also be nice if instead of producing HTML directly, Haddock produced perhaps XML databases which could be merged into a single table of contents, showing everything that you have on your system.
19:58:36 <sorear> Cale: What I'm going to do (TODO list is very long :( ) is write a http://hackage.haskell.org/aptage/ gateway...  apt-get install libghc6-binary-dev
19:58:46 <sorear> Cale: it already does (ok not xml)
19:58:50 <Pseudonym> What we really need is a mentor.
19:58:51 <sorear> Cale:
19:58:53 <sorear> @docs
19:58:53 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
19:59:00 <Pseudonym> I think.
19:59:14 <Cale> sorear: Isn't that all done statically?
19:59:26 <sorear> Cale: What do you mean statically?
19:59:34 <SamB> so, is there a "best-of-hackage" package?
19:59:40 <Cale> I mean, when you install a new package, its documentation gets added to that list, as viewed on your system.
19:59:42 <sorear> Cale: it generates interface files, then uses the interfaces to generate a ToC
19:59:45 <dons> Pseudonym: he should be here on IRC. I did try to nudge him, but he avoided the hint :(
20:00:06 <dons> since 90% of his questions are FAQ/google worthy. And letting Bulat get to him first is just not helpful.
20:00:12 <Pseudonym> Yeah.
20:00:40 <sorear> Cale: I don't see what you want/
20:01:29 <Cale> sorear: Currently, the documentation is statically generated, which presumably means that haddock has to be run to compile a main table of contents and so on.
20:01:41 <Pseudonym> Maybe we need a Coppin Strike Team, ready to pounce on every question before Bulat gets to them.
20:01:44 <sorear> Cale: Statically is completely meaningless in this context.
20:01:49 <dons> we probably should have 'library of the week' blog posts too.
20:01:58 <Cale> It would be nice to have a table of contents (perhaps a javascript program) which loaded XML data and compiled those indices.
20:02:03 <dons> walking over the best hackage packages, showing how to use them for basic tasks
20:02:12 <Pseudonym> We could put that in HWN.
20:02:15 <dons> yeah
20:02:26 <dons> like this ' Python Module of the Week' thing
20:02:30 <sorear> Cale: On *nix systems, you *always* regenerate documentation when you install packages.
20:02:31 <Saizan> sorear: does the local ToC gets updated when installing a new package's documentation?
20:02:43 <sorear> Saizan: there is none, but it would be trivial
20:02:54 <sorear> Saizan: I'd like to know why Cale thinks it would be hard
20:03:09 <glguy> dons: what do you think the behavior for System.IO.UTF8.getChar should be? if it hits a non-continuation byte, should it try to put it back?
20:03:24 <dons> urgh
20:03:33 <Cale> sorear: I have gtk2hs installed, but file:///usr/share/doc/ghc6-doc/html/libraries/index.html doesn't display it.
20:03:38 <dons> a secret wrapper over a lazy stream, glguy ?
20:03:40 <glguy> dons: in the error case, of course
20:03:51 <sorear> Cale: The documentation index takes long enough to load as it is.  Since I read docs far more often than I install packages, what do you have against generating them at package install time?
20:03:53 <dons> hmm. i'm not sure -- see what others do
20:04:08 <sorear> Cale: Right, because GHC doesn't do what I'm saying.
20:04:12 <Cale> sorear: Oh, that would be fine too, but they should get merged into one index.
20:04:13 <sorear> Cale: Haddock can.
20:04:18 <Pseudonym> What's the type of getChar?
20:04:20 <sorear> Cale: That's *easy*
20:04:27 <glguy> Pseudonym: IO Char
20:04:28 <Pseudonym> System.IO.UTF8.getChar, that is
20:04:30 <Cale> sorear: So it should be doing it :)
20:04:32 <Pseudonym> Right.
20:04:35 <glguy> Pseudonym: it doesn't exist atm
20:04:41 <Cale> I know it's easy :)
20:04:42 <SamB> Cale: like info files, only actually working?
20:04:46 <glguy> Pseudonym: because I didn't know how to handle the exceptional case
20:04:49 <Pseudonym> I don't see the issue here.  It returns the next code point.
20:04:53 <Cale> SamB: yeah
20:04:53 <Pseudonym> Doesn't it?
20:05:00 <glguy> Pseudonym: right, that's the happy path
20:05:03 <sorear> Cale: Write a proposal, send it to the author of cabal-package
20:05:11 <glguy> Pseudonym: but if one of the expected continuation bytes is missing
20:05:20 <glguy> it will find that out by asking for the next starting byte
20:05:21 <Pseudonym> Oh, I see.  If it's a malformed stream.
20:05:24 <glguy> yeah
20:05:34 <Pseudonym> I'd be tempted to make it throw.
20:05:46 <sorear> Cale: *haskell-devscripts
20:05:52 <SamB> it should throw an IOError of some kind
20:05:52 <glguy> and leave the stream in a broken state? :-/
20:06:18 <Pseudonym> The stream surely already is broken.
20:06:36 <SamB> glguy: preferably it would throw something containing the bytes it has already read in trying to read a character
20:06:45 <Pseudonym> Right.
20:06:59 <glguy> SamB: but that would require the handler to knwo about UTF-8
20:07:03 <glguy> is that OK?
20:07:25 <SamB> only if it wants to *do* something about it
20:07:46 <glguy> ?hoogle unGetChar
20:07:47 <lambdabot> No matches found
20:07:59 <SamB> what if it alread read two bytes?
20:08:20 <glguy> in the case of the following stream:
20:08:32 <glguy> (expect 2 more) (cont 1) (new first byte)
20:08:42 <glguy> I'd expect it to leave the stream in:
20:08:45 <glguy> (new first byte) state
20:08:53 <glguy> that's what the current decoder does with a list of [Word8]
20:08:55 <edwardk> how bad would Enum suck if succ and pred returned Maybe a rather than a?
20:08:55 <glguy> in the case of failure
20:09:02 <edwardk> @type succ
20:09:04 <lambdabot> forall a. (Enum a) => a -> a
20:09:23 <SamB> ooh, we should do that with + and - too ;-)
20:09:55 <glguy> safe natural numbers!
20:10:16 <edwardk> > pred False
20:10:19 <lambdabot>  Exception: Prelude.Enum.Bool.pred: bad argument
20:10:24 <edwardk> bah =)
20:10:33 <oerjan> then succ would be an isomorphism on Nat...
20:10:47 <oerjan> no wait
20:10:50 <oerjan> pred
20:10:52 <edwardk> succ is safe on Nat, its just pred that isn't
20:10:55 <SamB> > pred (0 :: Word)
20:10:57 <lambdabot>  Exception: Enum.pred{Word}: tried to take `pred' of minBound
20:11:02 <SamB> aww...
20:11:06 <SamB> > (0-1)
20:11:08 <lambdabot>  -1
20:11:11 <SamB> > (0-1 :: Worsd)
20:11:12 <lambdabot>   Not in scope: type constructor or class `Worsd'
20:11:14 <SamB> > (0-1 :: Word)
20:11:16 <lambdabot>  4294967295
20:11:18 <sorear> On that subject, why isn't this ?
20:11:26 <SamB> why isn't what _|_?
20:11:32 <sorear> > 2000000000 + 2000000000
20:11:34 <sorear> > 2000000000 + 2000000000 :: Int
20:11:34 <lambdabot>  4000000000
20:11:36 <lambdabot>  -294967296
20:11:45 <Pseudonym> > succ True
20:11:47 <lambdabot>  Exception: Prelude.Enum.Bool.succ: bad argument
20:11:49 <SamB> sorear: it's inconvenient
20:11:54 <SamB> also slow!
20:12:23 <SamB> also, Haskell 98 doesn't say that it isn't
20:12:30 <SamB> don't you like nasal daemons too?
20:12:55 <sorear> No, I like a language where even the error messages are standardized. :)
20:12:59 <edwardk> i'm currently playing with my Enum, etc typeclasses to see if they can be made to make more sense and be more general. to that end i broke out succ and pred into separate classes (since in my case there is no real instantiation headache for instantiating a lot of them all at once and to avoid gobbling up names
20:13:04 <edwardk> just trying to figure out the right semantics
20:13:44 <Pseudonym> > succ (2^31-1 :: Int)
20:13:46 <edwardk> the main problem i have is i don't have the bounds and the succ and pred in the same typeclass, so maybe i just need to bite the bullet and merge them
20:13:47 <lambdabot>  Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
20:13:56 <edwardk> then i can add it as a proof burden
20:14:19 <SamB> @type succ
20:14:22 <lambdabot> forall a. (Enum a) => a -> a
20:14:26 <SamB> @type minBound
20:14:29 <lambdabot> forall a. (Bounded a) => a
20:14:43 <SamB> edwardk: ... *we* don't have them in the same class *either*
20:14:46 <oerjan> edwardk: i recall that Clean has one class per method, or thereabouts
20:14:57 <edwardk> oerjan: thats pretty much where i'm going right now
20:15:16 <SamB> oerjan: that would make for some really really long types...
20:15:30 <littledan> if Int has overflow checks, why is Int a separate type from Integer?
20:15:31 <glguy> and would leak details of how an algorithm was implemented
20:15:50 <SamB> littledan: it ordinarily doesn't
20:15:56 <SamB> but succ and pred are wierd like that
20:16:03 <edwardk> samb: i'm thinking MaybeBounded a or something where it stores possibleUpperBound as a Maybe a, then specializing from there to Bounded and Unbounded based on if it always returns Just or Nothing
20:16:20 <edwardk> then i can improve the predicate subtype
20:16:31 <SamB> edwardk: you've totally lost me
20:16:55 <littledan> weird... I assumed it was something like instance (Num a) => Enum a where succ n = n+1
20:17:22 <edwardk> class MaybeBounded a where possibleUpperBound :: Maybe a; class Bounded a where upperBound = fromJust possibleUpperBound;
20:17:31 <ddarius> @src Int succ
20:17:32 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
20:17:58 <SamB> I think Int and so on *derive* Enum...
20:18:06 <oerjan> littledan: H98 doesn't support instances of that form
20:18:11 <sorear> yeah.
20:18:13 <edwardk> then most everything can be made an instance of MaybeBounded. with Nothing for the cases where we know there is no lower or upperbound
20:18:14 <Pseudonym> class UpperBound a f | a -> f where { upperBound :: a -> f a }
20:18:14 <SamB> well, maybe not exactly dervive
20:18:21 <Pseudonym> instance UpperBound Int Id
20:18:28 <Pseudonym> instance UpperBound Integer Maybe
20:18:31 <littledan> oerjan, I'm new to Haskell; what did I do wrong?
20:18:31 <Pseudonym> Maybe not.
20:18:39 <SamB> but I could totally see a little {-! derive Enum !-} fitting in right there
20:18:44 <edwardk> that way i can say that Nats have a lower bound but no upper bound, etc.
20:19:03 <edwardk> (by splitting Bounded up further into BoundedAbove and BoundedBelow)
20:19:04 <sorear> @seen alexj
20:19:04 <lambdabot> I saw alexj leaving #haskell 3d 20h 16s ago, and .
20:19:13 <SamB> edwardk: have you class aliases?
20:19:21 <edwardk> yeah
20:19:26 <SamB> that works nice then
20:19:43 <oerjan> littledan: in H98 (but not more modern versions, the new instance must be for a type with one top constructor and the rest distinct variables - you cannot make an instance for just a type variable
20:19:51 <edwardk> ReturnableFunctor f = Returnable f & Functor f; instance ReturnableFunctor [a] where ...
20:19:51 <oerjan> *versions)
20:21:02 <littledan> are they working on a new Haskell standard? It seems like these extensions keep getting added ad-hoc
20:21:09 <Pseudonym> See, what you actually want here, to get this right, in addition to splitting Bounded into BoundedAbove and BoundedBelow...
20:21:14 <Pseudonym> Is "not" typeclasses.
20:21:25 <Pseudonym> Oleg proposed them, but they were turned down due to the ugly syntax.
20:21:31 <edwardk> littledan: everything i'm doing is decidedly unhaskell. i'll admit ;)
20:21:40 <Pseudonym> You want to say: If a is _not_ a member of typeclass Foo, then...
20:22:19 <oerjan> littledan: a new standard, Haskell-prime is being worked on, yes
20:22:38 <edwardk> pseudonym: i think what works for me is to say that I have a MaybeBoundedAbove instance that is a superclass of BoundedAbove, and include a subtype constraint on BoundedAbove that says that maybeUpperBound always returns Just something.
20:22:49 <edwardk> Pseudonym: so it'll work in my case, just not in Haskell
20:22:58 <Pseudonym> Right.
20:23:04 <SamB> Pseudonym: what ugly syntax?
20:23:11 <Pseudonym> SamB: Can't recall right now.
20:23:34 <SamB> I could see "not (BoundedBelow a)" as part of a very nice looking context
20:24:26 <SamB> is there something wrong with *that* syntax?
20:24:59 <edwardk> SamB i kind of implement my type classes by passing types into a jhc 'E' style intermediate function that accepts types as values, so it wouldn't be a huge diversion to change that to return a Maybe of the dictionary, then you can check it for null, etc.
20:25:19 <edwardk> er check it for Nothing
20:25:35 <SamB> wait, how's it E style if it uses dictionaries?
20:25:56 <edwardk> foo : (Maybe (Monad m)) => a -> m a   ?
20:26:54 <edwardk> well, because its got a PTS in the intermediate representation. JHC forks early based on the type used in a case analysis, thats just an optimization.
20:27:17 <Pseudonym> SamB: I can't recall what was actually proposed.
20:27:33 <sioraiocht> so, ya'll keep talking about them
20:27:37 <sioraiocht> what's an unboxed array
20:27:43 <SamB> now if only I could figure out how to cast values (from/to) their internal unboxed representations (to/from) their foreign call representations...
20:28:03 <Pseudonym> SamB: Though this is cool.  http://okmij.org/ftp/Haskell/isFunction.lhs
20:28:09 <SamB> sioraiocht: you know how arrays work in C?
20:28:22 <ericlavigne> sioraiocht: unboxed means storing a value directly rather than storing a pointer to the value
20:28:25 <SamB> it's... kind of like that ;-)
20:28:41 <edwardk> sioraiocht: most things in haskell get generated lazily right? well, you can store concrete values as well, usually 'unboxed'. an unboxed array is just a c style array where everything in it are values, not possibly thunks that will evaluate later
20:28:59 <sioraiocht> edwardk: ah, but theyre not less safe?
20:29:09 <SamB> sioraiocht: not really
20:29:12 <SamB> they are stricter though
20:29:15 <edwardk> sioraiocht: well, you incur a sort of strictness penalty
20:29:23 <edwardk> so you might bottom out when you wouldn't have before
20:29:25 <Pseudonym> Oh, hang on.
20:29:38 <Pseudonym> I think Oleg's proposal was, basically, a typeclass of the form:
20:29:47 <Pseudonym> (TypeDifferent a b) => ... a b ...
20:29:53 <Pseudonym> Or TypeNotEq
20:30:01 <Pseudonym> Which holds if a and b are different types.
20:30:04 <sioraiocht> edwardk: I meant in terms of like, for example, in C style arrays when you can overflow the stack
20:30:17 <edwardk> sioraiocht: they'll get allocated on the heap
20:30:31 <sioraiocht> oh yeah, duh
20:30:38 <SamB> sioraiocht: you can't overflow Haskell arrays anyway
20:30:47 <sioraiocht> SamB: I didn't think so
20:30:51 <sioraiocht> just checking ;)
20:30:59 <SamB> (modulo bugs that have been fixed ;-)
20:31:00 <edwardk> that and of course we have bounds checking
20:31:15 <edwardk> unless you unsafeWrite them all over the place
20:31:44 <SamB> (before it was possible to allocate an array that was much smaller than it was supposed to be, due to overflow in the size calculation ;-)
20:32:00 <int80_h> listHead Nil = 0
20:32:00 <int80_h> listHead (Cons x xs) = x
20:32:09 <int80_h> this results in the error:
20:32:31 <int80_h> *Datatypes> listHead [1,2,3,4]
20:32:31 <int80_h> <interactive>:1:9: Couldn't match expected type `List t' against inferred type `[a]' In the first argument of `listHead', namely `[1, 2, 3, 4]' In the expression: listHead [1, 2, 3, 4] In the definition of `it': it = listHead [1, 2, 3, 4]
20:32:47 <int80_h> and this is the datatype I defined
20:32:52 * SamB continues to stare at
20:32:57 <Cale> http://programming.reddit.com/info/24hyb/comments/c24ij0 -- hehe
20:32:58 <lambdabot> Title: Java vs K: a screencast (reddit.com)
20:33:05 <SamB> user error (Grin.FromE - Unknown primitive: ("unsafeCoerce",[EVar (436::ELit (Jhc.Basics.()::ESort *))]))
20:33:14 <int80_h> data List a = Nil | Cons a (List a)
20:33:22 <dibblego> computer science is under attack
20:33:23 <Cale> int80_h: The problem is with returning 0
20:33:27 <dibblego> http://www.itwire.com.au/content/view/13339/53/
20:33:28 <lambdabot> Title: iTWire
20:33:35 <dibblego> dons, how will we respond?
20:33:50 <jcreigh> man the photon torpedoes!
20:33:55 <wli> data NEL t = Single t | NELCons t (NEL t)
20:34:07 <littledan> dibblego, just ignore those people
20:34:08 <Cale> int80_h: You actually can't return a sensible value for the head of an empty list, you have to fail by either using the 'undefined' value, or 'error "foo!"'
20:34:24 <dibblego> littledan, but there are lots of them; this page is quite popular
20:34:30 <Pseudonym> dibblego: I have to know what the author means by "computer science".
20:34:47 <SamB> or, in prettier syntax, it doesn't like: <unsafeCoerce v1bits32>
20:34:50 <Pseudonym> I _do_ agree that the algorithm is not fundamental to computer science.  It's a subdiscipline.
20:34:53 <dibblego> I am offended by the potential misleading; I am comfortable in my understanding
20:35:05 <dibblego> Pseudonym, care to publish your thoughts?
20:35:13 <littledan> Pseudonym, yeah, it sounded from that description like he had his own sort of theory for computers that was just different
20:35:24 <oerjan> int80_h: you cannot use [1,2,3,4] syntax for anything but the builtin list type
20:35:38 <Pseudonym> dibblego: I wish I had the time.
20:36:03 <wli> oerjan: Weren't there monad comprehensions going around at some point?
20:36:27 <Pseudonym> Look, I'd have to read the book to understand what this guy is on about.
20:36:41 <Pseudonym> It might be that he's on to something, but just can't explain it well.
20:36:51 <sioraiocht> what do Int#, etc. mean?
20:37:08 <int80_h> oerjan, should I just use (1,2,3) syntax then?
20:37:12 <oerjan> wli: yes, although i don't think they allowed commas
20:37:30 <Pseudonym> I think we know that algorithms are not fundamental.
20:37:33 <Pseudonym> Don't we?
20:37:36 <oerjan> int80_h: you must use something like Cons 1 $ Cons 2 $ Cons 3 $ Nil
20:37:51 <Pseudonym> They're building blocks, but they're built on top of something else.
20:37:54 <SamB> Pseudonym: so what do I do with this Volume 1 here?
20:38:01 <Pseudonym> And higher building blocks are build on top of that.
20:38:11 <oerjan> and you may of course use foldr to turn a list into that: foldr Cons Nil [1,2,3,4]
20:38:19 <Pseudonym> SamB: You read it and cherish it.
20:38:30 <SamB> Pseudonym: do you remember the title?
20:38:33 <littledan> sioraiocht: I think that means an unboxed Int
20:38:33 <Pseudonym> Knuth is an analyst of algorithms.  One of the best.
20:38:35 <Pseudonym> Yes, I do.
20:38:44 <SamB> okay then ;-)
20:38:45 <wli> NELCons 1 $ NELCons 2 $ NELSingle 3
20:38:47 <sioraiocht> littledan: thanks
20:39:00 <sioraiocht> Pseudonym: he also makes pretty text
20:39:05 <SamB> so even if the title is wrong, I should keep the book, you say?
20:39:17 <Pseudonym> "Fundamental algorithms" are algorithms that are fundamental to computer programming.
20:39:22 <int80_h> listHead Nil = undefined
20:39:22 <int80_h> listHead (Cons x xs) = x
20:39:28 <dons> dibblego: http://programming.reddit.com/info/24hwv/comments/c24hxr ;)
20:39:28 <littledan> http://haskell.org/hawiki/UnboxedType
20:39:29 <SamB> oh, true ;-)
20:39:29 <lambdabot> Title: Want to be a computer scientist? Forget maths. (reddit.com)
20:39:29 <lambdabot> Title: UnboxedType - The Haskell Wiki
20:39:36 <Pseudonym> Computer programming is not the whole of computer science.
20:39:39 <int80_h> *Datatypes> listHead Cons 1 $ Cons 2 $ Cons 3
20:39:40 <int80_h> <interactive>:1:9:
20:39:40 <int80_h>     Couldn't match expected type `List a'
20:39:40 <int80_h>            against inferred type `a1 -> List a1 -> List a1'
20:39:40 <int80_h>     In the first argument of `listHead', namely `Cons'
20:39:42 <int80_h>     In the first argument of `($)', namely `listHead Cons 1'
20:39:44 <int80_h>     In the expression: (listHead Cons 1) $ ((Cons 2) $ (Cons 3))
20:39:46 <SamB> Pseudonym: I forgot ;-)
20:39:46 <Pseudonym> Type theorists might never write a single line of code!
20:39:56 <dons> dibblego: the comments on the reddit page for this are useful
20:39:56 <SamB> Pseudonym: how do they test their theories?
20:40:04 <Pseudonym> They prove them correct, duh.
20:40:09 <wli> headNEL (NELSingle x) = x ; headNEL(NELCons x _) = x
20:40:16 <int80_h> SamB, isn't that what grad students are for?
20:40:17 <SamB> and how do they do this without writing proof-code?
20:40:23 <edwardk> gah, the safe version of Succ requires an Eq check =/
20:40:37 <edwardk> and Eq isn't in my requirements list
20:40:53 <wli> edwardk; What are you using as the definition of Succ?
20:40:58 <dibblego> one day we will only be writing type signatures
20:41:14 <littledan> sioraiocht: a much better link: http://www.haskell.org/ghc/docs/latest/html/users_guide/primitives.html
20:41:15 <ddarius> SamB: The same way mathematicians do.
20:41:16 <lambdabot> Title: 7.2. Unboxed types and primitive operations, http://tinyurl.com/y59rbr
20:41:19 <dibblego> I suppose that is what Epigram does? (I've yet to look)
20:41:23 <Pseudonym> OK, now you're just being silly.
20:41:25 <wli> edwardk; Or, rather, as the type to which Succ is being applied.
20:41:40 <int80_h> < oerjan> : I tried what you said and got that error I pasted
20:42:10 <dibblego> dons, nice one :)
20:42:21 <edwardk> wli: well, the idea was to go through and build class MaybeBoundedAbove a where possibleUpperBound :: Maybe a; then say that class BoundedAbove a <: MaybeBoundedAbove a where possibleUpperBound = Just upperBound; upperBound : a; and then to define Succ as a subclass of MaybeBoundedAbove with a limitation that the argument to the succ function can't be the upperBound
20:42:24 <SamB> ddarius: but mathemeticians in general are hopefully much sloppier than type theorists
20:42:35 <SamB> because I *know* mathemeticians in general *are* sloppy
20:42:49 <edwardk> but for that i need a notion of (==)
20:43:05 <Pseudonym> I want to see a compiler which says "the general proof of the type correctness of your program is left as an exercise".
20:43:18 <Saizan> int80_h: you've forgot a Nil, and you've a problem with precedence, function application binds strongly than everything else and is left-associative
20:43:24 <edwardk> Pseudonym: thats kind of my approach =)
20:43:26 <sioraiocht> Pseudonym: you're mean
20:43:33 <oerjan> int80_h: what Saizan said
20:43:39 <wli> edwardk: Mapping to/from the naturals is the only trick I can think of.
20:43:47 <Pseudonym> Or "I saw Oleg in the elevator yesterday, and he said it was type correct".
20:43:57 <Pseudonym> Proof by Eminent Authority
20:44:19 <edwardk> wli: hrmm. succ before was tied to Enum, i could sneak it back in there
20:44:20 <Saizan> int80_h: you need to write listHead (Cons 1 (Cons 2 (Cons 3 Nil))), or with less parenthesys: listHead $ Cons 1 $ Cons 2 $ Cons 3 Nil
20:44:43 <glguy> also, regarding the utf8-string library, I was thinking that it might be useful if the decoder allowed you to specify what to do in the case of an error (error "bad encoding", ( '\xfffd' : ), id)
20:45:04 <int80_h> thanks for your patience guys :)
20:45:08 <Cale> listHead . Cons 1 . Cons 2 . Cons 3 $ Nil
20:45:08 <edwardk> so if I say that MaybeBoundedAbove a and Enum a are part of the interface requirements i think i can do it. since then I have fromEnum and toEnum to go back and forth to Ints
20:45:08 <ddarius> Pseudonym: You mean a C compiler?
20:45:08 <Cale> :)
20:45:11 <glguy> (Python's standard utf-8 decoder lets you pick)
20:45:32 <Pseudonym> :-)
20:45:48 <SamB> Pseudonym: a compiler that rides elevators?
20:45:51 <SamB> with Oleg?
20:46:33 <Pseudonym> ?quote OlegFacts
20:46:33 <lambdabot> OlegFacts says: Oleg does FFI by yelling at Richard Stallman.
20:46:44 <SamB> ?quote OlegFacts
20:46:44 <lambdabot> OlegFacts says: Oleg does FFI by yelling at Richard Stallman.
20:46:51 <wli> edwardk: When an upper bound exists the mapping is reversed and succ x = let m = fromEnum maxBound in case m - fromEnum x of { 0 -> Nothing ; n -> Just $ toEnum $ m - n + 1 }
20:46:52 <SamB> is that all?
20:46:55 <SamB> @quote oleg
20:46:55 <lambdabot> OlegFacts says: Oleg knows the cost of everything *and* the value of everything.
20:47:01 <Pseudonym> ?quote OlegFacts
20:47:01 <lambdabot> OlegFacts says: Oleg's functions infer their own types.
20:47:06 <Pseudonym> ?quote OlegFacts
20:47:07 <lambdabot> OlegFacts says: Oleg wrote a function with type (a -> b) -> [a] -> [b] ...and it wasn't map
20:47:19 <SamB> hmm.
20:47:26 <SamB> I, too, can write such a function!
20:47:40 <Pseudonym> Here it is.
20:47:41 <SamB> I can write \f -> map f . reverse
20:47:44 <Pseudonym> ?quote typechecker
20:47:44 <lambdabot> OlegFacts says: When Oleg writes code, the typechecker asks *him* if it's correct.
20:48:06 <edwardk> wli: yeah i'm writing it up now, and debating about if i should just roll in MaybeBoundedAbove as a superclass of Enum
20:48:13 <SamB> lol
20:48:27 <ddarius> That's a good one.
20:48:44 <wli> edwardk: Well, MaybeBoundedAbove and succ don't play well together.
20:49:22 <wli> edwardk: BoundedAbove and BoundedBelow seem like a useful split, though.
20:49:52 <Pseudonym> ?remember OlegFacts Oleg's type theory proof sketches fill *themselves* out.
20:49:52 <lambdabot> Done.
20:49:56 <edwardk> wli: i have subset types, so my succ : {x  : a | has-successor x} -> a where has-successor y = case possibleUpperBound of Nothing, True; Just x, fromEnum x == fromEnum y
20:50:27 * ddarius tries to remember what a clopen set would look like a la synthetic topology.
20:51:02 <edwardk> and the { | } block would then incur a proof obligation for the compiler to check, probably warn about and then insert a runtime check when it fails to prove it or catch and error at compile time if it can
20:51:06 <sioraiocht> ghc uses pthreads for -threaded, right?
20:51:13 <edwardk> sioraiocht: sorta
20:51:21 <sioraiocht> edwardk: orly?
20:51:56 <Cale> ddarius: Have an interpretation of connected components?
20:52:05 <edwardk> sioraiocht: there is a lot of haskell to haskell threads in that GHC forms separate haskel execution contexts for each thread and you don't really see the haskell  threads running in the same OS thread all the time, etc.
20:52:14 <sioraiocht> riiight
20:53:22 <chadz> howdy all.
20:53:40 <Cale> ddarius: I think perhaps something like that the set is recursive?
20:53:52 <edwardk> ok, so in my toy environment, it would appear to construct an Enum you need to tell the compiler if your type is bounded above or not. thats not so burdensome i guess
20:53:58 <ddarius> Cale: For connected components?
20:54:12 <Cale> ddarius: for clopen
20:54:22 <Cale> A clopen set is just a union of connected components.
20:54:31 <Cale> (which is why I asked)
20:55:20 <Cale> Apparently, a subset U of a data type a is called open if its characteristic function chi_U :: a -> S defined by chi_U(x) = T if and only if x is in U is continuous.
20:56:10 <oerjan> Cale: not _any_ union, necessarily
20:56:25 <Cale> oerjan: right
20:56:40 <edwardk> ah and it lets me tighten the constraints on toEnum and fromEnum nice
20:56:41 <edwardk> ok
20:56:43 <Cale> a disjoint union, certainly
20:57:09 <ddarius> Aren't different connected components already disjoint?
20:57:13 <Cale> and in a Turing complete language, apparently a set of non-divergent elements of Nat is open iff it is r.e.
20:57:39 <Cale> ddarius: er, yeah :)
20:57:49 <ddarius> A function is continuous if it's implementable.
20:58:14 <Cale> Oh, I suppose you could have problems if your union is too large.
20:58:26 <ddarius> Cale: ?
20:58:32 <Cale> Let me think :)
20:58:38 <oerjan> it is useful to consider a set like the Cantor set in which each point is a component
20:58:40 <ddarius> The complete set is clopen.
20:58:55 <oerjan> but only some of the subsets are clopen
20:59:00 <Cale> yeah
20:59:05 <oerjan> (although a dense subset)
21:00:49 <ddarius> I guess if the characteristic function is definable and it's complement is definable then you are set.
21:00:52 * SamB hopes JohnMeachem has some good advice or even assistance for him tommorrow WRT FFI marshalling...
21:01:28 <Cale> ddarius: yeah, so it's something like recursive.
21:01:41 <oerjan> oh, and the single point sets themselves aren't clopen either
21:02:04 <Cale> oerjan: right, they won't be open :)
21:03:31 <Cale> You could also use the example of Y = {1/n : n in N} in the space Y union {0}, which is a disjoint union of connected components, but it's not closed.
21:07:01 <ddarius> Besides trivial examples, what are examples of data types corresponding to topologies with no clopen sets (besides 0 and T)?  Some function types?
21:07:06 <Cale> It's annoying how lots of blogs make code unreadable by clipping off the right edge when lines are too long.
21:07:51 <ddarius> Moral of the story: Don't write long lines.
21:07:52 <Cale> ddarius: hmm, that would mean there are no computable subsets :)
21:10:21 <Cale> Moral of that story being that most interesting datatypes under that topology look really discrete locally.
21:10:41 <Cale> er, hmm
21:10:43 <Cale> maybe not
21:11:15 <wli> Would && and/or || doing parallel reduction suffice to give Haskell full abstraction?
21:11:20 <Cale> For instance, with function types...
21:11:44 <Cale> wli: Full abstraction?
21:12:13 <ddarius> Full abstraction is a relation between a denotational and operational semantics usually.
21:12:36 <Cale> With a function type having infinite domain, you have that singleton sets aren't clopen.
21:13:36 <wli> ddarius: I thought it required the axiomatic semantics to coincide as well.
21:14:04 <ddarius> wli: Actually, I'm pretty tired so you should mostly ignore me.  But one thing is true, you need to specify a semantics.
21:14:16 <Cale> However, with something like Nat -> Nat, you do get clopen sets like {f : f 0 = 0}
21:14:44 <Cale> er, maybe not.
21:14:46 <wli> ddarius: s/coincide/be contained/
21:14:59 <ddarius> Even with say () -> (), if it is const (), I can tell, but if it isn't I can't.
21:15:18 <Cale> right
21:15:32 <Cale> Okay, so function types :)
21:16:09 <wli> I think it's =_{ax} \subseteq =_{den} \subseteq =_{op}
21:16:35 <wli> Containment relations on the equality relations according to the various semantics.
21:17:46 <edwardk> ok, dumb observation, should Enum map from a -> Int or from a -> Nat?
21:17:57 <edwardk> assuming the existence of a native Nat type
21:18:01 <wli> =_{op} = =_{den} sounds nice, too.
21:18:05 <wli> edwardk: Nat IMHO
21:18:22 <edwardk> trying to think if any existing haskell Enum instances would break there
21:18:55 <edwardk> aside from the Enum Int which becomes somewhat awkward in the ensuing encoding
21:19:22 <wli> edwardk: pred = toEnum . pred . fromEnum on types not bounded below (e.g. Integer).
21:19:47 <wli> edwardk: Well, not Integer, but anyway.
21:20:17 <edwardk> wli: well tight now i'm adopting the haskell convention that Enum is a workhorse, so it is tied to the size of Int anyways, so its going to be representable in 32 bits
21:20:47 <wli> edwardk: Oh, the encoding's not hard. enc n | n == 0 = 0 | n > 0 = 2*n-1 | n < 0 = -2*n
21:20:53 <edwardk> sure
21:20:55 <edwardk> but its overhead
21:21:03 <edwardk> this is a fairly common thing =)
21:21:34 <edwardk> i took an intro to math course way back when i realize the two are equivalent ;)
21:23:29 <edwardk> trying to think of what 'unbounded' enums haskell has and if any are useful. Integer doesn't fit into Int to begin with, any others?
21:23:41 <edwardk> @instance Enum
21:23:41 <lambdabot> Maybe you meant: instances instances-importing
21:23:46 <edwardk> @instances Enum
21:23:47 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
21:23:50 <glguy> edwardk: Word's of various sizes
21:24:00 <edwardk> glguy: those are bounded though
21:24:04 <glguy> oh
21:24:11 <glguy> just that their bounds are greater than an Int
21:24:17 <edwardk> just Integer
21:24:19 <edwardk> yeah
21:25:23 <ddarius> @instances-importing Ratio
21:25:23 <wli> edwardk: dec n | n == 0 = 0 | otherwise = let (q,r) = n `divMod` 2 in ((2*r-1)*(q+r)) `div` 2}
21:25:24 <lambdabot> Couldn't find class `Ratio'. Try @instances-importing
21:25:26 <ddarius> @instances-importing Ratio Enum
21:25:27 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering, Ratio a
21:25:31 <edwardk> the only fancy one is Integral a => Enum (Ratio a) that i can see
21:25:45 <wli> edwardk: duh it's wrong
21:26:18 <wli> edwardk: dec n | n == 0 = 0 | otherwise = let (q,r) = n `divMod` 2 in (2*r-1)*(q+r)) }
21:26:23 <edwardk> wli: i know the encoding, its just that its a fairly expensive thing to do to someone who just naively fromEnum's an Int if there is no compelling reason other than 'Nats are sufficient'
21:26:25 <dolio> @seen vincenz
21:26:25 <lambdabot> I saw vincenz leaving #oasis and #haskell 1d 6h 37m 12s ago, and .
21:26:26 <wli> edwardk: ah, there we go
21:26:51 <edwardk> > fromEnum 4
21:26:52 <lambdabot>  4
21:26:58 <edwardk> gives a nice natural result right now
21:27:51 <edwardk> now, that said, it MIGHT be argued as a reasonable way to cast back and forth between signed and unsigned
21:27:53 <wli> edwardk: listQ = [(i,j)|(i,j)<-cantor [[(i,j)|j<-[1..]]|i<-[1..]],i`gcd`j==1] where { cantor = concat . f where f (x:xs) = [head x] : zipWith (:) (tail x) (f xs) }
21:28:12 <wli> edwardk: Then negate numerators, interleave, and adjoin (0,1).
21:28:24 <dibblego> does a source file always export all of its instance declarations?
21:28:42 <blackdog_> can you have multiple haskell threads accessing functions written in C concurrently?
21:28:47 <oerjan> dibblego: yes
21:30:34 <edwardk> so then you'd get fromEnum (-4 :: Int) to return 4294967292 or something, or fromEnum (-4 : Word 8)   to return 252
21:31:36 <wli> edwardk: let listQ = (0,1) : concatMap (\(i,j) -> [(i,j),(negate i,j)]) [(i,j)|(i,j)<-cantor [[(i,j)|j<-[1..]]|i<-[1..]],i`gcd`j==1] in findIndex ((-4,1)==) listQ == Just 18
21:32:17 <wli> edwardk: findIndex (355,113) listQ == 133353
21:33:40 <wli> There should be a faster way to go back and forth between naturals and rationals.
21:37:58 <edwardk> i think i'll stick to allowing Enum to run over Int simply because it simplifies the handling of the various Int16, Int8, cases. they don't need any fancy handling
21:38:14 <dons> blackdog_: yep. (unsafe ccalls)
21:38:37 <blackdog_> dons: ah, so you have to mark them as unsafe?
21:38:37 <wli> Chop things up into {-1,0,1}, (-\infty,-1),(-1,0),(0,1), and (1,\infty), map each pertinent interval to (0,1), then use some sort of graded lexicographical ordering on the elements of the continued fraction?
21:38:41 <blackdog_> that makes sense
21:38:46 <wli> edwardk: How about Integer?
21:38:48 <dons> btw peoples, binary IO, compression, FFI and C: http://haskell.org/haskellwiki/Serialisation_and_compression_with_Data_Binary
21:38:54 <lambdabot> Title: Serialisation and compression with Data Binary - HaskellWiki, http://tinyurl.com/36kj64
21:39:17 <blackdog_> now i just need to make sure my C library is reentrant :)
21:39:22 <edwardk> wli: Integer doesn't fit into the existing handling, and i'm mostly concerned with Enum for the data Color = Red | Green | Blue deriving (Enum) cases ;)
21:40:32 <edwardk> maybe the anal retentive answer would be to say that fromEnum :: Enum a, Integral i => a -> i
21:40:53 <edwardk> and rely on specialization to speed it up
21:41:11 <glguy> > maxBound :: Word512
21:41:18 <lambdabot>  1340780792994259709957402499820584612747936582059239337772356144372176403007...
21:41:22 <glguy> how does one convert a Word512 to a Word1034
21:41:23 <dolio> @tell vincenz I've been fiddling with delimited continuations based on Shift to Control, and think I have finally come across the same problem as before. The obvious 'shift' doesn't type for 'MonadDelimitedCont m => StateT s m'. The difference being that I don't think I'll be able to kludge my way out this time. :)
21:41:23 <lambdabot> Consider it noted.
21:41:24 <glguy> err
21:41:25 <glguy> 1024
21:41:26 <oerjan> edwardk: [-10^10 .. 10^10] ?
21:41:42 <ddarius> :t fromIntegral
21:41:45 <lambdabot> forall a b. (Num b, Integral a) => a -> b
21:42:02 <ddarius> :t fromIntegral :: Word512 -> Word1024
21:42:03 <lambdabot>     Not in scope: type constructor or class `Word512'
21:42:04 <lambdabot>  
21:42:40 <ddarius> Yeah, implementing a delimited control monad transformer is a pain.
21:42:49 <wli> edwardk: The results may be surprising on integral domains with nonzero characteristic or (worse yet) modular rings like Int32
21:43:02 <dons> > maxBound :: Word1024
21:43:09 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
21:43:20 <ddarius> 2^1024-1
21:43:24 <ddarius> > 2^1024-1
21:43:27 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
21:43:33 <dolio> ddarius: Actually, the monad transformer isn't hard (unless what I've written is wrong). The hard part is having other transformers on top of it.
21:43:37 <glguy> > floor (1/0)
21:43:40 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
21:43:50 <edwardk> wli: well, right now i'm just trying to shore up the existing haskell semantics =)
21:44:09 <ddarius> That was unexpected.
21:44:26 <ddarius> Or is it.
21:44:31 <edwardk> wli: Enum is almost invariably used on derived instances and small enumerated types anyways
21:45:01 <ddarius> Anyways, time to dream pleasant dreams.
21:46:05 <mm_freak_> uhm  strange
21:46:07 <edwardk> wli: the integral in that case is the haskell integral, not a good integral-domain type =)
21:46:13 <mm_freak_> but i think, i can reason why
21:46:27 <dons> so this is my "don't whinge, just do it" approach to -cafe@ complaints, http://article.gmane.org/gmane.comp.lang.haskell.cafe/25209
21:46:29 <lambdabot> Title: Gmane -- Mail To News And Back Again
21:47:37 <glguy> ?index Word1024
21:47:37 <lambdabot> bzzt
21:48:06 <dons> i'm hoping we can just say "No, you're doing it wrong. Look here." for these people who head down the [Word8], list-crypto, bulat-code, wrong-way-go-back path in future
21:48:33 <glguy> is Data.LargeWord packaged anywhere?
21:48:37 <dons> its in Crypto
21:48:45 <dons> (probably should be standalone)
21:49:14 <dolio> Huh, you imported two modules as S. I hadn't considered that.
21:49:22 <oerjan> edwardk: [1..] is a frequent Enum use
21:49:41 <edwardk> oerjan: oh yeah, the major use case is for the [] sugar
21:49:48 <Pseudonym> Dammit!
21:49:48 <edwardk> that was what started this whole thing after all =)
21:49:50 <dons> dolio: i usually do that for .Base and .ByteString, since they munge the same type, and you then get the unsafe/fast stuff with the same prefix
21:50:01 <Pseudonym> http://xkcd.com/c287.html -- No solutions!
21:50:02 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
21:50:36 <Pseudonym> Oh, hang on.
21:50:38 <Pseudonym> Duh.
21:51:08 <Pseudonym> Actually, there's one trivial solution.
21:51:14 <Pseudonym> And a not-so-trivial one.
21:51:15 <edwardk> so if we assuming wadler-style views, and the generalized monadplus list sugar, what interesting usecases do we get for allowing the list syntax to be a view so we can use it on the left of the = sign in interesting cases, like taking apart a set or something?
21:51:25 <Pseudonym> 2.15 * 7
21:51:31 <Pseudonym> > 2.15 * 7
21:51:33 <lambdabot>  15.049999999999999
21:51:56 <dolio> dons: Yeah, it makes sense. I guess for some reason, I might have expected that to cause an error (you're trying to call two modules the same thing), but there's no reason to forbid importing multiple modules into some qualified namespace, just as we do with the default one.
21:52:09 <wli> Hmm, it seems like one should be able to do Nat relatively easily.
21:52:56 <wli> data Nat = Nat [Word32]
21:53:04 <blackdog_> dons: what's the bulat-code approach?
21:53:17 <edwardk> i think what i need is a Natural typeclass where i can limit myself to bounded limitations of it though
21:53:28 <dons> blackdog_: oh, he recommends the useless streams lib. leading to pain and suffering, leading to yet more questions
21:53:29 <edwardk> wli: i'm not willing to pay that computational cost for the common enum cases though
21:54:04 <edwardk> right now, Nat = { x : Int | x >= 0 } it doesn't even get the full 32 bit range of the basic Int type
21:54:19 <edwardk> with the idea being that i'd do a Natural to mirror the larger Integer class
21:55:05 <edwardk> then it gets to take advantage of the stupid-fast GMP primitives, not something i cobble together myself
21:56:04 <mm_freak_> ok, i'm completely unable to understand the result of floor (1/0)
21:56:16 <edwardk> > floor (1/0)
21:56:18 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
21:56:28 <glguy> > 2 ^ 2 ^ 10
21:56:30 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
21:56:34 <edwardk> lambdabot found infinity =)
21:56:40 <mm_freak_> yes, but why?
21:57:06 <glguy> mm_freak_: so that it didn't have to return an error
21:57:10 <mm_freak_> it's a finite value, and it looks pretty arbitrary (other than that it is a power of two)
21:57:11 <glguy> :t floor
21:57:13 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
21:57:26 <edwardk> > (1/0)
21:57:29 <lambdabot>  Infinity
21:57:31 <Pseudonym> > floor (1/0) :: Word32
21:57:33 <lambdabot>  0
21:57:38 <Pseudonym> ...
21:57:42 <Pseudonym> > floor (1/0) :: Int
21:57:45 <lambdabot>  0
21:57:47 <Pseudonym> > floor (1/0) :: Integer
21:57:49 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
21:58:04 <Pseudonym> > maxFloat :: Double
21:58:05 <lambdabot>   Not in scope: `maxFloat'
21:58:05 <mm_freak_> well, there is no constructor Infinity  is this actually an exception?
21:58:07 <edwardk> Pseudonym: 2^2^10 mod 2^32 will be 0 =)
21:58:11 <mm_freak_> one that ghci handles?
21:58:12 <blackdog_> dons: fair enough
21:58:20 <blackdog_> actually, i wish i'd seen this a few months ago
21:58:27 <Pseudonym> maxBound :: Double
21:58:31 <Pseudonym> > maxBound :: Double
21:58:32 <lambdabot>   add an instance declaration for (Bounded Double)
21:58:32 <lambdabot>     In the expression: max...
21:58:33 <blackdog_> i was doing exactly this sort of thing, only poorly and non-compressedly
21:58:39 <dons> yeah, we need to write more tutorials for the expanding libs.
21:58:41 <edwardk> > (2 ^ 2 ^ 10 - 1) :: Word32
21:58:43 <lambdabot>  4294967295
21:58:47 <Pseudonym> Curiouser and curiouser.
21:58:48 <edwardk> that would be more useful, no? =)
21:58:57 <dons> and this is a really common pattern. probably should have more support for getting unboxed arrays/Ptrs into lazy bytestrings, and compressed.
21:59:02 <edwardk> > (2 ^ 2 ^ 10 - 1) :: Word16
21:59:05 <lambdabot>  65535
21:59:10 <chessguy> warning: imminent spoiler alert for the new xkcd for today!
21:59:25 * glguy kicks chessguy
21:59:28 <glguy> thanks for the warning!
21:59:35 * chessguy kicks back
21:59:38 <chessguy> hpaste isn't working
21:59:38 <dons> blackdog_: the trick here is to just cast the unboxed ptr to a strict bytestring
21:59:48 <dons> box that (:[]), then compress it lazily as we write it to disk
21:59:49 <glguy> ?seen sorear
21:59:49 <lambdabot> I saw sorear leaving #haskell-icfp07, #ghc, #xmonad, #haskell-overflow, #haskell-blah and #haskell 1h 40m 11s ago, and .
21:59:50 <blackdog_> oh, that's cool
21:59:54 <blackdog_> actually, that'll hepl
21:59:55 <blackdog_> help
21:59:59 <mm_freak_> now how come that floor (1/0) = 2^1024 ?
22:00:07 <blackdog_> can i run parser combinators over bytestrings?
22:00:23 <dons> there's some yeah, but nothing designed from scratch yet to work on bytestrings
22:00:23 <Pseudonym> mm_freak: If I had to guess, it's to do with the representation of infinity in IEEE floats.
22:00:32 <Pseudonym> And I wouldn't guarantee that it would be the same on other architectures.
22:00:38 <dons> ?where bytestringparsec
22:00:38 <lambdabot> I know nothing about bytestringparsec.
22:00:49 <dons> there's one, Paolo was working on it.
22:00:52 <mm_freak_> pseudonym: floor x :: Integral a => a
22:00:57 <chessguy> ok, i'm not going to get any sleep until i figure this out
22:00:58 <chessguy> http://rafb.net/p/MmTmU890.html
22:00:59 <lambdabot> Title: Nopaste - Knapsack problem
22:01:20 <blackdog_> ok, cool. i'll keep an eye out for it
22:01:28 <chessguy> the goal is to find a list of the lists of the give item prices that sum up to the given total
22:01:33 <Pseudonym> chessguy: For a start, use integers.
22:01:35 <chessguy> ghci gives me a stack overflow
22:01:37 <edwardk> > floor (1/0 :: Float)
22:01:39 <lambdabot>  340282366920938463463374607431768211456
22:01:48 <edwardk> > floor (1/0 :: Double)
22:01:50 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
22:01:50 <Pseudonym> > [(a,b,c,d,e,f) | a <- [0..7], b <- [0..5], c <- [0..4], d <- [0..4], e <- [0..3], f <- [0..2], 215*a+275*b+335*c+355*d+420*e+580*f ==1505 ]
22:01:52 <edwardk> yeah
22:01:53 <lambdabot>  [(1,0,0,2,0,1),(7,0,0,0,0,0)]
22:01:59 <Pseudonym> chessguy: Now sleep.
22:02:23 <chessguy> Pseudonym, i pasted that solution on the xkcd forum 30 minutes ago :)
22:02:28 <Pseudonym> :-)
22:02:29 <mm_freak_> pseudonym: ok, but i still can't reason why it's specifically _that_ value
22:02:32 <chessguy> i'm trying to get a guard solution
22:03:03 <mm_freak_> since Double does not even have 1025 bits
22:03:19 <dolio> > properFraction (1/0)
22:03:22 <lambdabot>  (179769313486231590772930519078902473361797697894230657273430081157732675805...
22:03:27 <dolio> There you go. :)
22:04:14 <chessguy> so why do i get an overflow
22:04:14 <oerjan> > 2^1023 :: Double
22:04:16 <lambdabot>  8.98846567431158e307
22:04:24 <oerjan> > 2^1024 :: Double
22:04:26 <lambdabot>  Infinity
22:04:40 <Pseudonym> > 2^1023 :: Double
22:04:42 <dons> ?users
22:04:42 <lambdabot> Maximum users seen in #haskell: 354, currently: 306 (86.4%), active: 14 (4.6%)
22:04:42 <mm_freak_> ah ok
22:04:43 <lambdabot>  8.98846567431158e307
22:04:54 <dolio> > decodeFloat (1/0)
22:04:56 <Pseudonym> I'd say that you're looking at the maximum mantissa.
22:04:57 <lambdabot>  (4503599627370496,972)
22:04:59 <mm_freak_> so Double has an exponent of 10 bits?
22:05:12 <Pseudonym> Aha!
22:05:13 <chessguy> http://rafb.net/p/FHmCrN46.html
22:05:14 <lambdabot> Title: Nopaste - Knapsack problem -- with Ints!
22:05:15 <Pseudonym> OK, THAT makes sense.
22:05:27 <Pseudonym> Basically, decodeFloat is trying to treat Inf sensibly.
22:05:29 <mm_freak_> maximum exponent, not mantissa  that indeed makes sense
22:05:32 <Pseudonym> > decodeFloat (sqrt (-1))
22:05:34 <lambdabot>  (-6755399441055744,972)
22:05:37 <Pseudonym> Same thing.
22:05:48 <Pseudonym> Now that's interesting.
22:05:51 <Pseudonym> And deeply wrong.
22:05:52 <edwardk> mm_freak: sign bit, 53 bits of explicit mantissa, leaves 10 bits left over
22:05:59 <Pseudonym> I'd say this is a bug.
22:06:26 <mm_freak_> edwardk: yes, that explains things
22:06:30 <Pseudonym> :t decodeFloat
22:06:34 <lambdabot> forall a. (RealFloat a) => a -> (Integer, Int)
22:06:37 <Pseudonym> What you want is something like:
22:06:42 <mm_freak_> i don't understand decodeFloat
22:06:47 <mm_freak_> > decodeFloat 1
22:06:49 <lambdabot>  (4503599627370496,-52)
22:06:52 <Pseudonym> data ExpandedFloat = PInf | NInf | Nan | Value Integer Int
22:07:02 <Pseudonym> decodeFloat :: (RealFloat a) => a -> ExpandedFloat
22:07:02 <mm_freak_> is this mantissa and exponent?
22:07:03 <Pseudonym> Or something.
22:07:10 <Pseudonym> mm_freak: Yes.
22:07:17 <mm_freak_> k, then it makes sense
22:07:22 <Pseudonym> 4503599627370496 * 2**(-52)
22:07:25 <Pseudonym> > 4503599627370496 * 2**(-52)
22:07:28 <lambdabot>  1.0
22:07:32 <Pseudonym> Or, alternatively:
22:07:36 <Pseudonym> > 2^52
22:07:39 <lambdabot>  4503599627370496
22:07:49 <Pseudonym> > decodeFloat (sqrt (2))
22:07:52 <lambdabot>  (6369051672525773,-52)
22:07:59 <Pseudonym> > 6369051672525773 * 2**(-52)
22:08:00 <Pseudonym> Right?
22:08:01 <lambdabot>  1.4142135623730951
22:12:45 <dons> here's something fun, http://programming.reddit.com/info/24nv8/comments
22:12:47 <lambdabot> Title: Simply Easy! -- An Implementation of a Dependently Typed Lambda Calculus (reddit ...
22:14:05 <Korollary> Cool
22:14:15 <edwardk> dons: nice
22:16:16 <Korollary> How did they generate the code?
22:16:39 <dons> `automatically generated from the paper sources' :}
22:16:57 <Korollary> So how?
22:17:00 <dons> nice way to write a paper. must remember to do that some how.
22:17:08 <dons> lhs2tex, i'd imagine
22:17:14 <dons> or in reverse
22:17:35 <jfredett> is it possible to have a data type defined like this:
22:17:35 <jfredett> data ZZ = Z | S ZZ | ZZ P
22:17:35 <jfredett> that is, S S S ZZ P P is a valid ZZ? i need to eventually write some "reducing" code which would turn that into S Z, and it'd make things much easier to do it like that.
22:17:43 <Korollary> Maybe they wrote in lhs and used tex and stripped off the comments?
22:19:33 <jfredett> err, that should be S S S Z P P, not ZZ...
22:19:53 <jfredett> i guess I'm kindof looking for data to work like a cfg.
22:20:03 <chessguy> jfredett, you'd have to parenthesize at least, wouldn't you?
22:20:14 <jfredett> maybe thats why its not working
22:20:15 <jfredett> hmm
22:20:36 <oerjan> yeah, put in some parentheses or $'s
22:20:48 <chessguy> ermm, i'm not sure you can have ZZ as both a value and a constructor though
22:20:48 <jfredett> hmm, it doesn't like (ZZ P)
22:20:56 <oerjan> chessguy: you can
22:21:38 <oerjan> jfredett: it thinks ZZ is the constructor and P the contents.  Maybe you want the other way around?
22:22:25 <jfredett> oerjan: actually, the ZZ P was intended, the idea is to create something like:
22:22:37 <jfredett> S S S ... S ZZ P ... P P P
22:22:49 <jfredett> so I can build up a big computation, lazily
22:23:10 <chessguy> heh, flashbacks to formal languages class
22:23:14 <jfredett> and then at the end, pattern match against (x S ZZ P y) ->> (x ZZ y)
22:23:16 <oerjan> jfredett: constructors are _not_ prefixes in Haskell
22:23:30 <jfredett> until y == nil
22:23:40 <jfredett> damn, so I can't use data like a CFG
22:23:42 <jfredett> :/
22:23:47 <jfredett> chessguy: that was my idea
22:23:48 <jfredett> :/
22:23:53 <oerjan> i don't understand how that expression is supposed to be parsed
22:23:53 <chessguy> anyway, bedtime here (geez, almost 1:30 already?)
22:23:55 <chessguy> 'night all
22:24:28 <jfredett> oerjan, whatdya mean, the  S S S ... ZZ P P P ... thing?
22:24:32 <oerjan> yes
22:24:47 <jfredett> err, S S S ... Z P P P ...
22:25:04 <oerjan> oh wait i understand
22:25:07 <jfredett> well, its supposed to be a big thunk of Successors and Predecessors, essentially
22:25:11 <jfredett> is that helps
22:25:27 <jfredett> i'm trying to write the Integers in a Peano-esque style
22:25:29 <jfredett> in Haskell
22:25:32 <oerjan> your problem is that constructors are even less of postfixes, so you cannot use P that way
22:25:39 <oerjan> you must put it in front
22:25:41 <jfredett> right
22:26:42 <jfredett> so data can't handle that- hmm...
22:27:06 <oerjan> btw it would have been ambiguous how S S S Z P P P would parse if it were allowed
22:27:20 <jfredett> whatdya mean?
22:27:30 <jfredett> you mean in my code, or w/ haskell?
22:28:13 <jfredett> ooh! i could probably use a pair for all that... hmm
22:28:39 <oerjan> should it mean S ( S ( S (((Z P) P) P))),  or (((S (S (S Z))) P) P) P, or something else?
22:28:47 <jfredett> or i could just kludge out the lowlevel stuff that will need that.
22:29:09 <jfredett> oerjan, thats true- i forgot they have to be parenthesized. I was thinking of it as a string
22:29:24 <Cale> jfredett: you could make the P's prefix, and that should mean the same thing
22:29:52 <oerjan> data ZZ = Z | S ZZ | P ZZ  is completely legal
22:29:54 <jfredett> yah, but it's not as easy to reduce later,
22:30:15 <jfredett> there, I'd get P S P P S S S P S P S S S ... Z
22:30:34 <Cale> You could get that with your type too.
22:30:47 <jfredett> now I have to walk thru and take out all the instances of P S or S P to reduce it
22:30:54 <Cale> right
22:31:00 <jfredett> your right, Cale
22:31:02 <jfredett> I would
22:31:17 <jfredett> Cale++ for being way more observant than me.
22:31:34 <jfredett> I'd have to send it to temporary things. hmm
22:32:17 <dons> kicking more heads, http://programming.reddit.com/info/24nzn/details
22:32:19 <lambdabot> Title: Understand Type Systems -- Programming in Martin-Lf&#39;s Type Theory (reddit. ...
22:32:27 <dons> crikey. `Lf&#39;s'
22:33:08 <jfredett> heh, crikey... :)
22:33:15 <Cale> jfredett: You could have "smart constructors" which would ensure that only terms of a particular form are created.
22:33:32 <jfredett> GADT's?
22:33:40 <Cale> So applying  s to P (P (P Z))
22:33:55 <Cale> would annihilate one of the P's, for instance.
22:33:59 <jfredett> yah, thats probably what I'm gonna need to do
22:34:12 <jfredett> but the idea was to just build it up lazily, then reduce it at the end
22:34:27 <jfredett> i figured that'd be a cleaner bit of code.
22:34:40 <Cale> dons: Does the 'details' page for a reddit link usually count your own vote?
22:34:48 <dons> i think so?
22:35:01 <dons> they cache things these days, so there can be delays
22:35:09 <Cale> ah, okay
22:35:20 <dibblego> what we voting for today? :)
22:35:59 <Cale> More people should mod up the Java vs. K screencast.
22:36:12 <Cale> I found it entertaining, myself :)
22:36:32 <Cale> and of course, all of dons' links :)
22:36:52 <dibblego> what's the link for that one?
22:37:02 <Cale> http://programming.reddit.com/info/24hyb/comments
22:37:03 <lambdabot> Title: Java vs K: a screencast (reddit.com)
22:37:17 <dibblego> "showing how to solve Birthday problem in both Java and K "
22:37:18 <dibblego> ?
22:37:20 <dibblego> thanks
22:37:31 <Cale> yeah
22:40:05 <dibblego> class Cons c a where
22:40:05 <dibblego>   (.:) :: a -> c a -> c a
22:40:05 <dibblego>   uncons :: c a -> b -> (a -> c a -> b) -> b
22:40:08 <dibblego> is that crazy?
22:42:22 <oerjan> no, it's cata- or hylo- or something -morphic :)
22:42:43 <dibblego> ok, I don't like it when I invent these things without names, so thanks :)
22:43:03 <jfredett> hylomorphic
22:43:24 <jfredett> anamorphic builds a list, catamorphic collapses it
22:43:27 <dibblego> is that its relationship to [] ?
22:43:32 <jfredett> hylomorphic combines the too
22:43:36 <oerjan> are you sure you want a in the class, rather than having the functions polymorphic in it?
22:43:43 <wli> I can't remember the distinction between hylomorphism and paramorphism.
22:43:43 <dons> its a catastrophy. that's how to remember cata- == destory
22:43:48 <dibblego> you're right
22:43:48 <oerjan> *restricted by the class
22:44:50 <dibblego> I am so used to Scala where you cannot do that
22:45:17 <dibblego> or, it is expressed wildly different
22:46:18 <Pseudonym> "kata" actually means "along
22:46:35 <Pseudonym> or down, against, at.
22:46:52 <Pseudonym> Just thought I'd mention it.
22:47:03 <oerjan> those greek prepositions seem so illogical
22:47:20 <oerjan> like they have a vague bunch of meanings
22:47:27 <Pseudonym> It depends on the case that they take.
22:47:39 <Pseudonym> But really, what it means is that there isn't a 1:1 mapping.
22:47:48 <bos> > 1
22:47:51 <lambdabot>  1
22:47:54 <bos> ah.
22:48:00 <Pseudonym> "kata" actually means something that doesn't have a direct mapping into English.
22:48:00 <oerjan> indeed.
22:48:13 <oerjan> bos: why were you wondering? :D
22:48:21 <bos> thought lambdabot was dead.
22:48:35 <oerjan> lambdabot never dies.
22:48:42 <oerjan> though she sometimes sleeps.
22:49:11 <Japsu> what is dead may never die, but through strange eons even death may die
22:49:28 <Japsu> i! i! i lambdabot fhtagn!
22:49:28 * oerjan checks if lambdabot has tentacles
22:49:58 <Japsu> : <- cthulhu
22:50:14 <Japsu> (for the Unicode impaired: that's an Euro sign)
22:50:22 <Japsu> bah
22:50:23 <Japsu> work ->
22:50:29 <lambdabot> Why settle for a lesser evil?
22:50:36 <Japsu> :D
22:50:57 <wli> Yep, Cthulhu for President in 2008.
22:51:10 * lambdabot is the green, sticky spawn of the stars
22:52:03 <lambdabot> Ph'nglui mglw'nafh Lambdabot R'lyeh wgah'nagl fhtagn
22:52:11 <lambdabot> All right, I'll stop now.
22:52:53 <glguy> In a dependently typed lambda calculus, as described in this LambdaPi paper, do you end up with type-checked meta-programming similar to template-haskell but not distinguished from the rest of the program?
22:56:23 <edwardk> glguy: pretty much, the problem is its generally hard to establish a phase distinction to know when you're done compiling =)
22:56:50 <quicksilver> dependently typed doesn't make the names of functions into first class entities though, I don't think
22:56:59 <quicksilver> which metaprogramming normally does
22:58:29 * edwardk wanders off to sleep.
23:03:19 * wli attempts to absorb The Monadic Way
23:03:39 <ttmrichter> wli: Lots of stuff to absorb there.  :)
23:03:50 * ttmrichter is still absorbing it after three months off-and-on.
23:03:57 <wli> Evaluators are sort of limited.
23:04:05 <dons> you must become one with the monad.
23:04:06 <wli> They're also sort of too much at once.
23:04:51 <Pseudonym> Make me a coproduct with everything.
23:04:51 <ttmrichter> You must rule your monads ...
23:05:05 <ttmrichter> "...Or your monads will rule you?  That's what you were going to say.  Right?"
23:05:50 <dons> A Haskellers's strength flows from the Monad. But beware. Anger, fear, side effects. The dark side are they. Once you start down the dark path, forever will it dominate your destiny
23:06:08 <Joplin480> Saying that something is a monad has a lot more to do with how something is said than anything else
23:06:28 <Joplin480> Not all definitions are monads,  however,  most concepts can be expressed as monads
23:07:43 <Cale> Joplin480: um, I'm not so sure about that.
23:08:05 <Pseudonym> There is no dark side of the Monad.  Matter of fact, it's all dark.
23:08:40 <wli> How to do parallel || sounds like a good question.
23:09:30 <Cale> wli: well, you could certainly do it with unsafePerformIO..
23:09:32 <dons> Strong you have become, Pseudonym. I sense the dark side in you.
23:09:40 <ttmrichter> Apropos a recent thread in the cafe, is Haskell always doomed to be a poor performer without soul-destroying twisted code?
23:09:52 <Cale> ttmrichter: not at all
23:10:06 * ttmrichter is happy to hear it.
23:10:13 <wli> Cale: Hmm? I'd think there would be some sort of evaluation monad making it possible without such.
23:10:16 <dons> ttmrichter: not at all. the recent threads having been about implementing crypto and compression algos naively
23:10:17 <Cale> ttmrichter: It's actually usually not so hard to get reasonably performing code without ripping things to shreds.
23:10:30 <timthelion> uh, how do I find the nth element in a list?
23:10:36 <dons> (!!)
23:10:37 <ttmrichter> Dons: make sure there's a GOOD, WELL-WRITTEN chapter in the book on "doing it right the first time", OK?  :D
23:10:40 <Cale> timthelion:  xs !! n
23:10:49 <timthelion> oh, ok
23:10:50 <Cale> timthelion: but try to avoid doing it, if you can
23:11:04 <wli> Cale: Worse comes to worse you can drop all the monadic goodness and just brute-force the evaluator into interleaving the left and right halves of the ||
23:11:04 <ttmrichter> Now that you know how to do it, timthelion?  Don't.  :D
23:11:16 <dons> ttmrichter: yes, this seems to be the most FAQ on the list. I want a big sign I can wave saying "you're doing it the wrong way" as soon as someone starts using [Word8 for *anything*
23:11:41 <Pseudonym> I used that as a typeclass interface for computing CRCs once.
23:12:01 <ttmrichter> The problem, dons, is that Haskell98 has no other way of dealing with it and the stuff in GHC/HUGS isn't ... how shall I put this?  The best-documented stuff in the world.
23:12:07 <ttmrichter> Especially on the visibility front.
23:12:18 <Cale> wli: Well, you could use par
23:12:19 <Pseudonym> class Something where { crc :: [Word8] -> Word32 }
23:12:28 <ttmrichter> Every flippin' tutorial on Haskell uses lists.  EVERY SINGLE ONE!
23:12:37 <Pseudonym> Then, of course, I built a better interface on top of that.
23:12:45 <wli> ttmrichter: What would you rather have them use?
23:12:48 <Cale> wli: but that wouldn't give you shortcutting on both parameters.
23:12:48 <ttmrichter> Despite lists being the one structure that we keep getting told not to use.
23:13:06 <wli> Cale: Shortcutting?
23:13:08 <oerjan> lists are ok if they get fused, i hear
23:13:10 <Pseudonym> ttmrichter: We only tell people not to use lists when they appear in haskell-cafe with an efficiency problem.
23:13:15 <ttmrichter> wli: If the constant advice on haskell-cafe is "don't use lists", then perhaps the tutorials should reflect best known practices rather than theory.
23:13:27 <Pseudonym> If you don't have an efficiency problem, keep using lists.
23:13:30 <dons> lists are fine for many things. as long as they're < 10k
23:13:37 <Cale> wli: True || x = True, without needing to evaluate x
23:13:41 <timthelion> Cale: I have a list like 4 5 6 0 1 2 3 and I want to sort it like 0 16 and the only way I know what 0 is, is because I can determine it's index.
23:13:57 <dons> most efficiency problems seem to be people writing C-like string processing code, on lists, but getting ruby-like performance. which is always shocking
23:14:14 <dons> at least, the recent threads have been this flavour
23:14:37 <timthelion> is there efficient haskell like string processing?
23:14:37 <Pseudonym> Yeah, we didn't tell all the people who wrote Sudoku solvers not to use lists.
23:14:46 <ttmrichter> Well, make sure your book very clearly shows the non-lists approach to common problems then?  Because, as I said, the non-list structures aren't exactly well-advertised.
23:15:12 <Cale> Lists are important, but not really as data structures.
23:15:27 <Pseudonym> Lists are building blocks to build data structures out of.
23:15:34 <dons> ttmrichter: bytestrings. that's the #1 efficient haskell string processing mechanism.
23:15:36 <ttmrichter> Well, in that regard it's like lisp.
23:15:42 <wli> Cale: Well, you'd do something like reduceStep (Or leftExp rightExp) | leftExp == TruthVal t = TruthVal t | rightExp == TruthVal t = TruthVal t | otherwise = Or leftExp' rightExp' where { leftExp' = reduceStep leftExp ; rightExp' = reduceStep rightExp }
23:15:46 <Cale> They're important because they essentially form the basis of all loop-like control structures.
23:15:48 <ttmrichter> Lists in lisp are used to build more complex data structures.
23:16:16 <wli> Cale: Ergh, dispatch on whether t == True or False
23:17:03 <Cale> They're not quite used like in lisp.
23:17:10 <timthelion> dons: um, bytestrings, that doesn't sound very unicode
23:17:29 <wli> Cale: Well, you'd do something like reduceStep (Or leftExp rightExp) | leftExp == TruthVal t = if t == TruthVal True then TruthVal True else rightExp' | rightExp == TruthVal t = if t == True then TruthVal True else leftExp' | otherwise = Or leftExp' rightExp' where { leftExp' = reduceStep leftExp ; rightExp' = reduceStep rightExp }
23:17:57 <wli> Cale: Except what I actually meant to say.
23:18:04 <Cale> wli: are you talking about your own embedded language?
23:18:18 <wli> Cale: No, toy evaluators such as seen in monad tutorials.
23:18:20 <ttmrichter> dons: What is the status of Unicode in Haskell anyway?  (Or anybody else who may be in the know.)
23:18:26 <dons> ?where utf8-string
23:18:26 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/utf8-string-0.1
23:18:36 <Cale> wli: well, that would be similar, yeah
23:18:36 <glguy> timthelion: the Char type can hold any unicode character
23:18:38 <quicksilver> @where compactstring
23:18:39 <lambdabot> http://twan.home.fmf.nl/compact-string/
23:18:52 <ttmrichter> By virtue of two reasons -- one a project that requires unicode and the second the fact I live and teach in China -- unicode is actually an important issue for me.
23:18:57 <timthelion> glguy: but bytestrings would not use char types then
23:19:05 <Cale> wli: you could do something like that. With regard to parallel ||, I thought you were talking about writing a proper Haskell || which did evaluation in parallel.
23:19:09 <dons> Char is unicode-handy, the above lib does String io with preserving utf8. compact-string (untested) provides bytestringy-like api for the same.
23:19:24 <ttmrichter> What about UTF-16 and -32?
23:19:50 <dons> there's loose modules floating around for other encodings.
23:19:55 <wli> One last time: reduceStep (Or leftExp rightExp) | leftExp == TruthVal t = if t then TruthVal True else rightExp' | rightExp == TruthVal t = if t then TruthVal True else leftExp' | otherwise = Or leftExp' rightExp' where { leftExp' = reduceStep leftExp ; rightExp' = reduceStep rightExp }
23:20:16 <glguy> dons: do you think it would be handle to be able to specify the error handling mechanism in the utf-8 decode function?
23:20:21 <glguy> ignore, replace, throw
23:20:32 <dons> hmm.
23:20:39 <timthelion> ttmrichter: those aren't needed for Chinese, utf-16 does Arabic, what's 32 for?
23:20:45 <dons> glguy: only if someone asks for it
23:20:55 <glguy> dons: I just saw that that was available in Python
23:21:16 <dons> ah, that's interesting. you could certainly provide similar apis, if others are already accepted.
23:21:32 <ttmrichter> The full set of unicode code points takes up more than 65536 glyphs.  To get all the code points you need something like 21 bits (can't recall the precise number).
23:21:53 <ttmrichter> UTF-32 is the only encoding that can do all the glyphs without switching into different modes.
23:22:19 <ttmrichter> Each character is 4 bytes wide, though, which is a bit of a down-side.  But some specs mandate it.
23:22:20 <timthelion> ttmrichter: well that's useless, modality is use full and necessary
23:22:42 <oerjan> i recently read that China has its own encoding, which all commercial actors in China (or so) are required to support.
23:22:59 <ttmrichter> It's not useless if you need fast, accurate string processing.  Drop by unicode.org.  They go into deep, deep, deep detail into all the encoding fiddliness.
23:23:11 <ttmrichter> Everybody has their own encoding.
23:23:14 <ttmrichter> Everybody.
23:23:32 <ttmrichter> But the GBxxx encodings are all defined in terms of Unicode codepoint maps.
23:23:46 <ttmrichter> Unicode is the lingua franca for the remaining encodings.
23:23:56 <timthelion> hmm, we should make an encoding that only supports those charicters used in coding haskell
23:24:22 <ttmrichter> Technically that's all possible characters, timthlion.  ;)  What goes in between " pairs, after all?...
23:25:04 <timthelion> should I have said necessary for then?
23:25:30 <scook0> timthelion: isn't that more-or-less all of printable ASCII?
23:26:28 <timthelion> scook0: no, much less than that.  I should assume you need two lowwer case letters, and two upper case. and then a small set of symbols. well you'd also need the letters unsed in keywords
23:26:57 <oerjan> timthelion: er, you need all the letters used in the library functions
23:26:58 <timthelion> *used
23:27:11 <scook0> oh, you mean the *absolute* bare minimum
23:27:17 <timthelion> ya
23:27:38 <scook0> have fun with all your identifiers named "Xxxxxxxxxxxxxxxxx__________"
23:27:41 <timthelion> oerjan: haskell is Turing compliant without its libs
23:27:51 <oerjan> i think you can make do with one upper and one lower case :)
23:28:05 <scook0> "Turing compliant" :)
23:28:07 <timthelion> but what about if then and else?
23:28:57 <oerjan> scook0: no, XxxXXx
23:29:26 <timthelion> scook0: if you where able to do it in a somewhat reasonable manner,it would be the new language written on cell phones, with their limited key count
23:30:00 <scook0> heh
23:30:07 <ttmrichter> You can use predictive entry like T9 (or better) to do mobiles.
23:30:25 <timthelion> with just two letters, you could make 4 billion + names with just 32 character long function names
23:30:38 <oerjan> hm... for Turing completeness you might be able to do with no letters at all
23:30:49 <timthelion> ttmrichter: but there isn't a predictive entry app for coding is there?
23:31:06 <oerjan> using operators instead
23:31:24 <timthelion> oerjan: but how would you do like ycomb without typing fix?
23:31:55 <oerjan> timthelion: you can define fix as an operator
23:31:57 <scook0> oerjan: reminds me of http://www.haskell.org/haskellwiki/Obfuscation
23:31:58 <lambdabot> Title: Obfuscation - HaskellWiki
23:33:25 <oerjan> > let (===)(====)=(====)((====)===) in (===)(1:)
23:33:33 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
23:33:33 <oerjan> er..
23:33:38 <oerjan> oh it worked
23:33:52 <scook0> oerjan: now replace (1:) with church encodings!
23:35:53 <glguy> ?type let f x = x (f x) in f
23:35:56 <lambdabot> forall t. (t -> t) -> t
23:36:08 * glguy is confused now... why is fix defined:
23:36:09 <glguy> ?src fix
23:36:10 <lambdabot> fix f = let x = f x in x
23:36:29 <oerjan> glguy: so that x is shared rather than recomputed each step
23:36:36 <glguy> oh, ok
23:36:46 <oerjan> (that is a weakness of my === above, i guess)
23:37:44 <glguy> heard in #ruby-lang: "manveru, i'd rather go with safe than sexy :P"
23:37:52 <glguy> lol, ruby user considered with safety
23:37:59 <dons> hah
23:38:03 <dons> glguy is evil
23:38:27 <oerjan> in haskell, types can be safe _and_ sexy!
23:38:45 <glguy> dons: someone has to save their souls
23:38:48 <glguy> that can't be considered evil!
23:39:04 <dons> very noble, glguy
23:39:35 <timthelion> my soul has been saved. why do you care about the spares?
23:40:01 <glguy> timthelion: I need an army
23:40:04 <glguy> you are but one soldier!
23:40:21 <dons> ah, thinking ahead, glguy ! we like to see that.
23:40:31 <scook0> > repeat "timthelion"
23:40:33 <lambdabot>  ["timthelion","timthelion","timthelion","timthelion","timthelion","timthelio...
23:40:43 <scook0> voila!
23:41:04 <glguy> lol, scook0 thinks that timthelion is merely a String
23:41:07 <dons> > fix (++ "timthelion") -- oh noes! can't fix timthelion !
23:41:10 <lambdabot>  Exception: <<loop>>
23:41:12 <glguy> You've been objectified
23:41:20 <dons> > fix ("timthelion"++) -- phew, fixed! kthx!
23:41:21 <timthelion> yes but if they used biological warfare, and discoed that I was allergic to milk...
23:41:21 <ttmrichter> timthelion: I suspect it would be relatively trivial to take a large amount of Haskell source code and come up with the tables to do predictive typing for Haskell.
23:41:23 <lambdabot>  "timtheliontimtheliontimtheliontimtheliontimtheliontimtheliontimtheliontimth...
23:41:33 <opqdonut> can i declare a newtype an instance of something?
23:41:38 <dons> yup
23:41:39 <glguy> is discoing like dancing
23:41:43 <opqdonut> ok
23:41:44 <dons> that's what they're good for, opqdonut
23:41:48 <glguy> opqdonut: that's one of the things they are for
23:42:03 <opqdonut> yeah, i just keep mixing type and newtype up :)
23:42:49 <opqdonut> i can't believe my luck
23:42:53 <opqdonut> now i'm coding haskell at work too
23:43:01 <dons> cool!
23:43:11 <opqdonut> genetic algorithms in haskell to be exact
23:43:15 <glguy> I was thinking earlier today that people sould be allowed to +v themselves to declare that they don't think they are haskell newbies. sometimes I don't know what level someone is asking a question on
23:43:32 <opqdonut> this is heaven compared to the c gtk i used to work on
23:43:33 <opqdonut> :)
23:43:34 <ttmrichter> I'm jealous of you opqdonut.  I've never found a workplace that tolerated my interest in anything other than the Hot Language Of The Month.
23:43:55 <opqdonut> well, i'm a trainee in a unit that does open-source stuff
23:44:21 <opqdonut> so they tolerate almost anything, have to with their coder base :)
23:44:38 <opqdonut> hmm, is it in a unit or at a unit?
23:44:50 <ttmrichter> On a unit.
23:44:54 * ttmrichter whistles innocently.
23:45:10 <oerjan> Of a unit.
23:45:24 <ttmrichter> Somewhere in the vicinity of a unit.
23:45:31 <dons> glguy: what's +v ?
23:45:32 <opqdonut> :)
23:45:32 <ttmrichter> Vaguely associated with a unit?
23:45:34 <glguy> You can be a member of a unit, you can be in a unit
23:45:37 <opqdonut> dons: voice
23:45:43 <ttmrichter> Yes.  You are in, or a member of.
23:45:52 <opqdonut> ok, good
23:45:52 <oerjan> Almost but not quite unlike outside a unit?
23:45:54 <ttmrichter> glguy ruined the gag for us, but he's right.
23:45:54 <dons> ah, but it would have no impact in here, other than as a seniority bit
23:46:02 --- mode: ChanServ set +o glguy
23:46:10 --- mode: glguy set +v dons
23:46:14 <opqdonut> dons: exactly :)
23:46:30 <dons> set my bits , will you!
23:46:43 <glguy> dons: it would mean, I don't need the obvious answer :)
23:47:00 <opqdonut> i don't know whether i'm a newbie or not: i've been coding haskell for quite some time but i lack the experience of implementing real projects with it
23:47:00 <glguy> so that people like me don't have to try to remember everyone's skill levels
23:47:12 <glguy> opqdonut: then you could just not set it :)
23:47:15 <glguy> it wouldn't be an insult
23:47:17 <glguy> not to
23:47:21 <opqdonut> yeah, i gues that'll do :)
23:47:28 <opqdonut> *guess
23:47:35 <glguy> just an idea, I don't see it actually coming about
23:47:48 --- mode: glguy set -o glguy
23:48:18 <dons> if you've been here more than a year, you could get +v. but it seems a bit hmm, class ridden ? :)
23:48:37 <glguy> dons: I think that it only becomes elitism if you have to qualify
23:48:39 * dolio needs to stop looking at slashdot articles on programming languages/computer science.
23:48:46 <opqdonut> :)
23:48:52 <glguy> dons: if it is elective, I think it wouldn't be so bad
23:48:55 <dons> glguy: yeah, it would be ok if it was self-set.
23:49:06 <dons> dolio: that can cause serious illness :}
23:49:27 <glguy> dons: I could write a lambdabot module to set it
23:49:30 <dolio> dons: That article referenced on the mailing list was bizarre.
23:49:37 <glguy> and we could give lambdabot permissions to voice people through chanserv
23:49:53 <glguy> (without having +o permissions)
23:50:37 <earthy> hm. I've been programming haskell for some time now, but still I often want the obvious answer. ;)
23:50:39 <glguy> but like I said, just an idea
23:51:41 <dolio> And the slashdot response is always like 50%, "He's right. I hack perl/enterprise Java all day, and I don't use any math!"
23:51:46 <dolio> Or, at least 50%.
23:51:59 <dons> earthy: btw, found an ICFP team yet?
23:52:07 * dons notices funny bits set.
23:52:17 * glguy saw a lot of "I don't know what math is, I can't see how it is relevent"
23:52:19 <earthy> dons: nope.
23:52:25 <Joplin480> I've yet to see a slashdot article about math to get the story even approximately correct.
23:52:30 <earthy> was thinking of going the lightning division on my own
23:52:38 <glguy> which was similar to "i've never used differentiation in my programming, math must not help"
23:52:38 <earthy> btw: I'll probably be disqualified. :)
23:52:40 <dolio> glguy: Yeah.
23:52:43 <dons> earthy: i think you'll need to actively recruit/lobby people
23:52:47 <dons> earthy: hehe :)
23:53:01 <earthy> even though I know about as much as everyone here
23:53:05 <dons> http://haskell.org/haskellwiki/ICFP_Programming_Contest/Teams_2007#Teams_seeking_players
23:53:09 <Syzygy-> earthy: We, the Fiery Newbz are still looking for teammembers. :P
23:53:13 <dolio> I also found a gem of a thread where someone was claiming that there haven't been any significant developments in computer science for over 10 years.
23:53:18 <dolio> Which I find somewhat hard to believe.
23:53:21 <opqdonut> :D
23:53:29 <dons> dolio: wow.
23:53:35 <earthy> syzygy: given our current calendar I doubt I'll be able to make time for the lightning division, let alone take the whole weekend
23:53:38 <Pseudonym> It depends what you call "significant", I guess.
23:53:42 * glguy marvels at how important dons looks with his new prefix
23:53:43 <dolio> It's done. We've figured it all out.
23:53:46 <Syzygy-> earthy: Ah.
23:53:59 <dons> glguy: take it off, i'm feeling awkward
23:54:03 <Syzygy-> earthy: Well, if you end up not having time for the ICFP, I really cannot help you any further. :P
23:54:04 <glguy> :-p
23:54:05 <earthy> (having a pregnant gf around tends to take away some say in one's own calendar ;))
23:54:13 --- mode: ChanServ set +o glguy
23:54:15 <dons> earthy: congratulations!
23:54:16 <dolio> Pseudonym: Well, some guy came back at him and talked about auto-parallelization of programs, and the guy responded with "That's impossible."
23:54:17 --- mode: glguy set -v dons
23:54:18 <Syzygy-> dons is voiced? Wow.
23:54:23 --- mode: glguy set -o glguy
23:54:27 <Pseudonym> LOL!
23:54:29 <Pseudonym> I love it!
23:54:31 <earthy> dons: thanks. :)
23:54:41 <dolio> Pseudonym: And that was responded to with, "there are people a mile away from me doing it as we speak."
23:54:42 <Syzygy-> earthy: Doesn't your gf code Haskell???
23:54:53 <Pseudonym> Woo!  Congrats, earthy!
23:54:54 <earthy> nope. she doesn't code at all
23:55:01 <dons> there's a whole new generation on the way  Bringert's baby, earthy's on the way :) droundy getting married. oh my.
23:55:02 <Syzygy-> Awwww.
23:55:20 <Pseudonym> Must be something recently implemented in the HEAD.
23:55:21 <Syzygy-> dons: For what it's worth, I'm marrying 25.8.
23:55:29 * earthy laughs
23:55:45 <dons> I'm getting married 3.8 :}
23:55:56 <Syzygy-> Ooooh, congratulations!
23:55:57 <dons> it must be the silly season
23:55:59 <Pseudonym> Woo!
23:56:00 <dons> you too!
23:56:25 <Pseudonym> A general congrats to everyone just mentioned and moer so!
23:56:38 <dons> glguy got married just recently too, iirc :)
23:56:43 <earthy> 3.8.7? :)
23:56:50 <earthy> as in: in 4 weeks? :)
23:56:51 <dons> and syntaxninja too!
23:56:55 <dons> earthy: yup
23:57:05 <earthy> well, indeedy a round of congrats to go
23:57:23 <dons> like i say, everyone's growing up. scary.
23:57:26 <earthy> (actually, the pregnancy kinda flew into the 'proposing' and 'planning marriage' bits of life ;))
23:57:33 <dons> heh
23:57:54 <Syzygy-> Been engaged since 2002 - we're marrying now for tax and immigration reasons. :)
23:58:14 <dons> me too! yay! :)
23:58:25 <Pseudonym> Woo!  Tax rebates for everyone!
23:58:29 <earthy> ah, yeah, in .nl we have the tax thing down pat.
23:58:39 <Syzygy-> Being married is A Good Thing if you deal with German public service and taxation. And it looks as if my fiancee is headed for studies in the US, so being spouses is going to be helpful.
23:58:45 <dons> i wonder if earthy gets a baby bonus too?
23:58:49 <Syzygy-> Oh, and I can label my academic publications with a unique name!!
23:59:00 <Syzygy-> Mikael Johansson <= not so unique
