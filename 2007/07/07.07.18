00:02:38 <ski> glguy : mayhap a gonad warmer as well ?
00:03:37 <glguy> ski: no, I use xmonad now
00:03:43 <Cale> heh, The Best Page in the Universe really is quite good
00:04:03 <ski> (glguy : i.e. re the laptop)
00:04:16 <glguy> ski: I'm joking too ;)
00:04:33 <glguy> Cale: well yeah... it is the best page in the universe...
00:05:04 <Cale> I like how typing "best page" into firefox's address bar takes you right there.
00:05:14 <shachaf> Hmm.
00:05:24 <ski> http://www.endoftheinternet.com/
00:05:25 <lambdabot> Title: The End of the Internet
00:05:32 <shachaf> In ZipList, pure x = ZipList (repeat x)
00:05:40 * shachaf didn't expect that, though it makes sense.
00:06:34 <ski> > let (<$>) = zipWith ($) in  repeat (+) <$> [0,1,2] <$> [20,40,30,50]
00:06:38 <Cale> http://www.endoftheinternet.com/referafriend.cgi -- hehe
00:06:42 <lambdabot>  [20,41,32]
00:07:11 <shachaf> ski: Except you want (<*>).
00:07:22 <glguy> > [id] <*> [1]
00:07:23 <lambdabot>  [1]
00:07:24 <shachaf> ski: (<$>) is fmap.
00:07:30 <glguy> <*> is ap
00:07:39 <ski> bah .. i can never remember which strange symbol they used
00:07:44 <shachaf> glguy: Yes.
00:07:49 * ski prefers '`ap`'
00:08:11 * glguy used to check lambdabot for <*> support all the time ages ago
00:08:17 * shachaf preferse '<*>'. :-)
00:08:23 <glguy> now that lambdabot has it... I don't feel as excited as I thought I would
00:08:27 <shachaf> s/se/s/
00:08:44 <ski> if we need an infix symbol, then it should be something with '$' in it, to resemble
00:08:47 <ski> @type ($)
00:08:49 <lambdabot> forall a b. (a -> b) -> a -> b
00:08:52 <ski> @type ap
00:08:55 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
00:09:16 <ski> (also '*' is symmetric)
00:10:13 <Japsu> hmm
00:10:36 <glguy> Huzzah, my video card has semi-decent support now
00:10:43 <Japsu> endoftheinternet.com has a broken formmail script that shows you its source (I tried entering some bogus email addresses there)
00:10:43 <glguy> (in X)
00:10:50 <glguy> with the new i810 driver 2.1.0
00:11:00 <shachaf> glguy: Just in time for your fancy xmonad eye-candy! :-)
00:15:04 <glguy> just in time for things like xrandr to work
00:15:16 <glguy> who knows what will happen when I connect to my dock at work
00:15:35 <glguy> oh, and I don't have to manually edit the source file now
00:15:49 <glguy> previously it would do some kind of scaling on the display all the time even when you didn't need it
00:16:53 <edwardk> ski: right now i'm sticking to `ap` in my toy prelude, i've just moved it into its own class so it can mixin to give applicative
00:17:19 <edwardk> i'm just trying to figure out if there are any cool parameterized applicatives or restricted applicatives
00:17:23 <ski> edwardk : najs :D
00:17:38 <ski> parameterized ?
00:17:41 <ski> transformers ?
00:18:01 <glguy> robots in disguise!
00:18:30 <ski> class Decepticon d where ?
00:18:36 <edwardk> parameterized would be: m (a -> b) -> m' a -> m'' b    in the sense of the version of parameterized monads i've taken on. and restricted would include the names of a and b in the typeclass  class Ap f a b where ap :: f (a -> b) -> f a -> f b
00:19:14 <ski> hrm
00:19:52 <edwardk> the former gives rise to a number of useful 'mixins' about how to apply i would guess, Identity (a -> b) -> f a -> f b  for all functors gives map
00:20:04 <edwardk> or close to it anyways
00:21:01 <edwardk> the latter gives notions like the ability to carry around implicit instances of other typeclasses, like Eq or Ord on a or b.
00:21:10 <cedricshock> Is there a real quick way to get a comparison by a specific element of a tuple or product type to do things like maximum?
00:22:10 <glguy> comparing
00:22:24 <glguy> :t maximumBy (comparing snd)
00:22:27 <lambdabot> forall a b. (Ord b) => [(a, b)] -> (a, b)
00:22:34 <opqdonut> > let (f `on` g) x y = (g x) `f` (g y) in sortBy (compare `on` fst) [(1,2),(3,2),(2,3)]
00:22:35 <lambdabot>  [(1,2),(2,3),(3,2)]
00:22:44 <opqdonut> ?src comparing
00:22:44 <lambdabot> Source not found. stty: unknown mode: doofus
00:22:49 <TSC> (compare `on`) == comparing
00:23:07 <opqdonut> yeah, so i thought
00:24:44 <edwardk> of course, at this point i'm also kind of looking for what uses a useful parameterized, restricted monad would take, but maybe thats a little too out there, and i haven't fully worked out the how-to to mix restricted monads and the nice monad functions in Control.Monad without a ton of typeclass constraints
00:26:15 * ski is not convinced things like 'class Ap f a b' is sane
00:26:58 <edwardk> ski: the restricted ones are a little out there, but I do like the parameterized versions
00:27:22 <cedricshock> > maximumBy (comparing fst) [(1, 2), (5,0), (3,12)]
00:27:23 <lambdabot>  (5,0)
00:27:30 <cedricshock> Awesome. Thanks
00:27:30 <ski> how's the 'm' variants related ?
00:27:31 <edwardk> class Ap f f' f'' | f f' -> f'' where ap :: f (a -> b) -> f a -> f b
00:27:36 <edwardk> still has nice inference properties
00:27:44 <ski> hmhm
00:28:07 <edwardk> i currently have a way to fake a return into that by requiring identity to work, which holds for any valid applicative
00:28:10 <ski> if we had subtyping, would the above be needed ?
00:28:41 <edwardk> I think so
00:28:47 <edwardk> http://comonad.com/reader/2007/parameterized-monads-in-haskell/
00:28:54 <edwardk> is where i did that to monad
00:28:58 <lambdabot> Title: The Comonad.Reader ª Parameterized Monads in Haskell
00:30:11 <edwardk> and used the monad laws to rederive type inference for return and mzero. pepe iborra has a trick for using this to carry an HList of possible exceptions around, and we can use a parameterized catch, which has built in instances to handle 'Identity' pass through the same way
00:30:49 <ski> hrm, HList
00:30:50 <edwardk> so I think having a parameterized 'ap' isn't that much of a stretch, since you could return into it and derive the same semantics necessarily as the fmap by construction.
00:32:04 * dblhelix subscribes to edwardk's blog
00:32:15 <opqdonut> Your views intrigue me and I wish to subscribe to your newsletter
00:32:17 <opqdonut> :)
00:32:44 <edwardk> so a valid signature for catch to take on for a practical case would be:  IOE (FileNotFound :*: TypeError :*: Nil) a -> (FileNotFound -> Identity a) -> IOE (TypeError :*: Nil)
00:32:58 <edwardk> er IOE (TypeError :*: Nil) a
00:33:01 <edwardk> there at the end
00:33:44 <edwardk> which with a generic E monad for non-IO exceptions, can then allow you to parameterize effects, giving you nanevski's modal possibility
00:34:00 <edwardk> in an evil kinda-sorta-monad form
00:34:16 <edwardk> opq, dblhelix =)
00:34:49 <ski> 'IOE' ?
00:34:59 <ski> oh
00:35:00 <edwardk> "IO with tracked exceptions"
00:35:14 <ski> 'JavaIO' ? :)
00:35:47 <edwardk> that could be a particular instances of IOE with an HList enumerating all of the things that Java can complain about randomly to you through the JNI ;)
00:35:55 <edwardk> er instance
00:36:14 <matthew-_> do you really want a list though?
00:36:21 <matthew-_> I'd have thought you'd rather have a set
00:36:31 <edwardk> matthew-_ its treated like a set
00:36:52 <matthew-_> really? so a :*: b :*: Nil == b :*: a :*: Nil ?
00:36:53 <edwardk> its just described in terms of an HList because thats the type machinery we have
00:37:26 <matthew-_> == a :*: a :*: b :*: a :*: Nil ?
00:37:46 <edwardk> no, but (>>=) :: IOE (a :*: b :*: Nil) c -> (c -> IOE b :*: a :*: Nil) -> IOE (a :*: b :*: Nil) works
00:38:07 <matthew-_> ahh, ok
00:38:10 <matthew-_> you must have some funky type classes to allow you to do set eqality on lists
00:38:13 <edwardk> and the latter never occurs because effects occur by inclusion intot he list
00:38:57 <edwardk> i don't think pepe's prototype does yet, but they aren't that hard to define, just slow =)
00:41:36 <matthew-_> yup
00:43:20 <edwardk> the biggest problem with that pseudo-monad stuff there is that ghc forces the do-sugar to be used monomorphically with respect to the monad type across the whole do-block.
00:44:49 <matthew-_> right. I've had cases where the whole monad framework isn't general enough, which becomes a pain when you "fix" it and then can't use do-notation
00:45:26 <edwardk> here as long as Bind m m m is always an instance you can use it but you have to break out to explicit >>='s to change types.
00:46:10 <edwardk> so do x <- Just 12; [x*1,x*2]   won't work, but Just 12 >>= \x -> [x*1,x*2] does presuming an instance of Bind Maybe [] [], which is admittedly rather evil
00:47:05 <opqdonut> would it even be feasible to have do-notation figure out multimonad stuff?
00:47:12 <edwardk> though i like the fact that Bind [] Maybe [] gives back a natural filter, and Bind a Identity a yields fmap and Bind Identity a a yields the other return law.
00:47:37 <edwardk> opq: yeah, the issue is that you can't let return be polymorphic because you can't run typeinference 'inwards'
00:47:44 <opqdonut> yeah
00:47:50 <edwardk> so if return :: a -> Identity a
00:47:52 <edwardk> that is solved
00:48:10 <opqdonut> yeah and then have Bind Identity _ _ instances?
00:48:16 <edwardk> then use generic instances of Bind Identity a a and Bind a Identity a and Bind Identity Identity Identity
00:48:23 <opqdonut> yeah
00:48:26 <edwardk> the last trick is you need something to come out of the identity monad into any other monad
00:48:40 <edwardk> lest things like return 1 >> return 2 not be able to get into your list monad
00:49:10 <edwardk> so i have a final typeclass for Go n m, that says you can promote out of Go Identity m into any monad m, so you can 'go $ do something'
00:49:25 <edwardk> and get back whatever monad you typecheck that with
00:49:40 <opqdonut> yep
00:49:49 <edwardk> same thing works for catch and mzero
00:50:08 <edwardk> and i guess could be made for an explicit mOrElse default
00:50:15 <edwardk> heya mnislaih
00:51:27 <edwardk> i was thinking the 'exceptions' interpretation of IOE is too specific. what if it was 'effects', then you can describe a broader class of things.
00:51:41 <edwardk> using a region is just a region effect, etc.
00:52:19 <edwardk> heck if possible moving 'IO' into a more generic E effect monad would be cool =)
00:52:45 <edwardk> where its just one of the things enumerated
00:53:56 <ski> edwardk : how's 'Bind Maybe [] []' evil ?
00:54:03 <mnislaih> hey edwardk, good morning
00:54:16 <edwardk> ski: i find it fun actually, but its a little weird =)
00:54:32 <edwardk> there are some combinations that aren't immediately clear as to meaning.
00:54:38 * ski wanted something like that in a program
00:55:14 <edwardk> [] IO (ListT IO) works, but IO [] ? do you execute it once or k times, etc.
00:55:25 <edwardk> or did i get that backwards
00:55:47 <ski> (istr 'ListT' is not a monad transformer)
00:56:01 <mnislaih> edwardk: Neat. we should consider keeping effects separate and  stacking several monadic effects
00:56:01 <quicksilver> there's something stupid wrong with ListT
00:56:10 <quicksilver> but it's not a totally daft idea, it's just got a bug in it
00:56:12 <edwardk> listT embeds a list inside the other monad
00:56:37 <dolio> The problem is that it's too strict in the side effects, essentially.
00:56:40 <ski> ('BagT' and 'SetT' would be, though)
00:56:45 <dolio> So it's not associative.
00:56:46 <ski> (iirc)
00:57:11 <edwardk> mnislaih: i think the 'right' idea there is to figure out which ones commute, then to identify the HLists of those, as a form of general coproduct of monadic effects
00:57:36 <edwardk> giving you more or less neil ghani's monadic coproducts for a limited array of effects
00:58:16 <dolio> There's a ListT done right on the wiki that fixes it.
00:58:22 <quicksilver> http://www.haskell.org/haskellwiki/ListT_done_right
00:58:23 <lambdabot> Title: ListT done right - HaskellWiki
00:58:45 <|Steve|> Ugh, coproduct of monadic effects? What is the category in which this coproduct exists?
00:59:14 <ski> the category of monads over Hask, of course
00:59:29 <ski> (or mayhaps some subcategory, thereof)
00:59:51 <edwardk> http://www.informatik.uni-bremen.de/~cxl/papers/icfp02.ps.gz
01:00:16 <edwardk> it'd probably have to be some subcategory of them, not sure all of them stack well
01:00:38 <edwardk> and type checking that would be slooow if it was used a lot i think
01:01:04 <|Steve|> Hmm, probably more than I ever cared to know.
01:01:37 * ski wonders whether one could do an "ListT done right" alternative based on the continuation formulation(s)
01:02:07 <dolio> LogicT is already done right, I believe.
01:02:18 <ski> @index LogicT
01:02:18 <lambdabot> bzzt
01:02:28 <dolio> @hackage logict
01:02:29 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/logict
01:03:05 <edwardk> mnislaih: I think it may be possible to move most of this out from the type of the monad into a typeclass describing the list of effects that a particular effect monad instance can handle, then if we have some sort of value of type Effect (FileNotFound :*: Allocation :*: Nil) e => e a it says that the
01:03:38 <edwardk> monad underlying it can handle injection of those effects, and they must be handled. then we could build a traditional monad transformer delimited effects and tracking them in the typeclass where they won't interfere with typeability of do sugar
01:04:34 <quicksilver> edwardk: incidentally, yes, listT should call IO actions multiple times
01:04:41 <quicksilver> edwardk: that's what it's supposed to mean
01:06:03 <mnislaih> edwardk: where have I seen this trick of moving stuff from the type to the constraints before ?
01:06:08 <edwardk> it was a matter of when composing IO a >>= a -> [b]      vs. composing [a] >>= a -> IO b   is all
01:06:13 <mnislaih> was it in one of Oleg's lightweight .... papers ?
01:06:17 <edwardk> mnislaih: not sure
01:06:37 <edwardk> i'll go back and raid those for ideas then =)
01:06:55 <quicksilver> runListT $ do { a <- ListT . return $ ["hello","world"] ; liftIO $ putStrLn a }
01:06:57 <mnislaih> ok, I'm sure it can be done, but I probably like effects better in the type
01:07:03 <quicksilver> runs the putStrLn twice
01:07:12 <mnislaih> I was thinking of generalizing typechecking of do notation in ghc
01:07:21 <mnislaih> have you tested hugs, by chance ?
01:07:32 <ski> dolio : hm .. interesting ..
01:08:01 <edwardk> mnislaih: well, i'd just like to accumulate a list of 'Effect' effects, so you can readily type returns and subexpressions, and then a 'AllEffects' one that uniquely identifies the monad with its effect list
01:08:30 <ski> (dolio : my 'Logic' do logic variables and implication, so is more specific)
01:09:13 <ski> (oh, and skolems, too)
01:09:37 <mnislaih> edwardk I will give a read to that paper later. But I have to run in a few minutes
01:09:37 <edwardk> quicksilver: i realize it kind of has to to mix those effects, around then i got bored and stopped adding MTL instances, because it wasn't clear how to build up towers of MTL instances in the parameterized setting
01:09:54 <edwardk> mnislaih: haven't tested hugs at all
01:09:59 <mnislaih> btw edwardk I have pushed a wrapping of System.IO
01:10:01 <edwardk> as far as i'm concerned GHC is haskell ;)
01:10:15 <edwardk> ah i'll go look
01:10:16 <edwardk> very cool
01:10:30 <mnislaih> I planned to test some already existing program using System.IOE as a swap-in replacement
01:10:44 <mnislaih> and see how well type inference works
01:10:53 <mnislaih> (modulo do notation)
01:10:56 <edwardk> ah good idea
01:11:09 <quicksilver> edwardk: yeah, the towers can get tiring
01:11:36 <edwardk> the problem isn't so much tiring as they may not have the nice inference properties in my nice flat setting =)
01:11:55 <dolio> ski: Ah. I suppose Logic could be a bad name, since a lot of it is just about non-determinism and nicer combinators for it.
01:12:02 <edwardk> hence why i'm trying to see if a generic 'Effects' tower in a class to one side can give me MTL like mixins
01:13:25 <edwardk> then of course this begs the question of if the same transformation can be applied to arrows. unfortunately for that ghc's proc/do notation is hosed with specific dependencies
01:14:56 <ski> dolio : *nod*
01:16:02 <dolio> I just followed the paper, though. :)
01:16:33 * ski ought to sometime continue working on how Logic project
01:16:39 <ski> s/how/his/
01:18:41 <ski> ?- L = [(_ - 9),(_ - 16)],( member((A-B),L) => square(A,B) ).
01:18:41 <lambdabot> Maybe you meant: . v
01:24:13 <dons> cdsmith: someone dropped 'learn haskell in 10 minutes' by reddit, it hope its ready :)
01:24:53 <dons> http://programming.reddit.com/info/27bpn/details
01:24:54 <lambdabot> Title: Learn Haskell in 10 minutes (reddit.com)
01:28:03 <dons> i'm pretty happy with that, in fact
01:28:08 <dons> thought it took 4 minutes to read :)
01:32:37 <quicksilver> dons: I think that's a nice intro
01:34:20 <dons> yeah, i like it too. cdsmith++ has done a great job
01:34:38 <quicksilver> I did spot a mistake, but I don't have a wiki user to fix it
01:34:46 <quicksilver> missing 'qualified' in import Data.Map as M
01:35:16 * Cale replaces misuses of the word 'statement' with 'expression'
01:35:39 <edwardk> heh, shucks, i'd hoped for about 3 seconds that 'error' could be given a typeclass constraint =)
01:36:56 <quicksilver> he also says "you can return () from a function if you don't want to return anything"
01:37:20 <quicksilver> which, (given that he is constrasting functions and actions there), whilst true, is not very useful
01:38:29 <Cale> there you go
01:40:01 * dblhelix tosses some lambdas over his shoulder... just for good luck
01:42:24 <glguy> http://programming.reddit.com/info/27bgm/comments -- am I missing something obvious or is this blog posting just wrong?
01:42:25 <lambdabot> Title: "Spin Buffers": DO NOT USE (reddit.com)
01:42:33 <glguy> (missing something wrt my comment)
01:46:55 <quicksilver> glguy: yeah, I think the author (of the blog) has just missed the point
01:47:31 <Cale> heh, the source code is in a 101MB zip file.
01:49:23 * glguy should edit his comment to say: "Blogs" DO NOT USE
01:50:39 <glguy> there was another on reddit that was addressing the critical issue of case sensitivity
01:50:55 <glguy> which really, we should  be debating more often
01:50:58 <glguy> static / dynamic
01:51:08 <glguy> inferred / explicit
01:51:16 <glguy> case sensitive / whatever
01:51:23 <ski> Cale : 'command' ?
01:51:45 <Cale> ski?
01:51:52 <glguy> he thinks you are a bot
01:51:59 <ski> * Cale replaces misuses of the word 'statement' with 'expression'
01:52:38 <Cale> ski: The article referred to "case statements" and such.
01:52:46 <ski> ah
02:06:00 <thorkilnaur> 10 minute Haskell: Sections are used (map (+ 2) [1 .. 5] and filter (> 2) [1 .. 5]) without comments, I am not sure what to think of that ...
02:06:48 <dons> that they're intuitive? :)
02:07:23 <quicksilver> yeah, I liked that
02:07:30 <thorkilnaur> That we think they are intuitive, yes, but what will outsiders think?
02:07:37 <quicksilver> I thought they were intuitive and it was fine to introduce them as an example
02:07:46 <quicksilver> IMO that article is really aimed at people who learn by example
02:07:51 <quicksilver> it has many good examples
02:07:59 <quicksilver> if they don't really understand that one, they can always move on
02:08:03 <quicksilver> it's not like it builds on it later
02:12:20 <thorkilnaur> quicksilver, Ok, you are probably right
02:18:53 <zimbatm> hi
02:19:54 <zimbatm> just a little Q : what is the difference between packages wrapped by curly braces and the other in `ghc-pkg list` ?
02:20:56 <dons> do you have an example?
02:21:05 <dons> i don't think i've seen curly braces in ghc-pkg output
02:21:21 <dblhelix> zimbatm: I only know of packages wrapped in parentheses
02:21:39 <dblhelix> (ghc-6.6) for instance
02:21:42 <zimbatm> sorry, I meant parentheses
02:21:45 <dons> oh, () not braces.
02:21:49 <dons> they're `hidden' ones.
02:21:51 <zimbatm> :p
02:21:54 <dons> not curretly exposed
02:22:09 <zimbatm> so it means that they're not available to the compiler ?
02:22:16 <dblhelix> so, you're really not supposed to look through the (...) facade ;-)
02:22:39 <dblhelix> zimbatm: they're available to the compiler, they're not available to the programmer
02:23:01 <dons> they're available, but you have to specify the version number to link against them, or else (for exmple, they might be replaced by a newer version)
02:23:26 <zimbatm> okay
02:24:40 <zimbatm> btw, sorry if I look unknoledgeable. I'm just trying to integrate GHC correctly into the Pardus distro
02:25:12 <dons> no, that's fine. :)
02:25:22 <dons> perhaps look at what people do on gentoo? they have very good integration
02:25:25 <zimbatm> thanks :)
02:25:49 <zimbatm> good idea
02:26:12 <zimbatm> just.. what makes it that a packages gets "parenthezed" or not ?
02:31:37 <dons> zimbatm: see http://www.haskell.org/ghc/docs/latest/html/users_guide/packages.html
02:31:39 <lambdabot> Title: 4.8. Packages, http://tinyurl.com/2bpgem
02:31:40 <dons> for the full story
02:38:03 <mnislaih> everybody interested in parameterized monads, please go to http://hackage.haskell.org/trac/ghc/ticket/1537 and add yourself to the CC list
02:38:04 <lambdabot> Title: #1537 (do notation translation) - GHC - Trac
02:38:17 <mnislaih> let's see if the GHC voting system works as advertised :)
02:48:46 <roconnor> > sin (10^15)
02:48:51 <lambdabot>  0.8582721324763734
02:49:18 <astrolabe> I doubt that that is accurate
02:49:38 <roconnor> 0.8582727931 is a more accurate number
02:49:57 <astrolabe> How do you know?
02:50:09 <roconnor> I wrote a coq program to compute it.
02:50:16 <astrolabe> :)
02:50:49 <roconnor> still, the floating point result is better than I had expected
02:50:59 <roconnor> and faster ;)
02:51:02 <astrolabe> yeah.  me too
02:51:22 <roconnor> takes me 38 seconds on my laptop to get my result.
02:51:38 <roconnor> although if I extracted haskell code and compiled it, I'm sure it would be faster
02:51:40 <opqdonut> > liftM (sin (x)/x) $ reverse [0.01,0.02..1.0]
02:51:41 <lambdabot>   Not in scope: `x'
02:51:47 <opqdonut> > liftM (\x -> sin (x)/x) $ reverse [0.01,0.02..1.0]
02:51:48 <lambdabot>  [0.8414709848078963,0.844470685455071,0.8474462964203778,0.8503976426169586,...
02:51:48 <opqdonut> bah :)
02:52:15 <astrolabe> I don't know how floating point sin works.  Maybe there's a lookup table.
02:52:38 <jethr0> isn't it interpolated from a table?
02:52:56 <roconnor> https://www.haskell.org/haskellwiki/Sinc_function
02:53:51 <jethr0> roconnor: why the https with the broken/unpublished certificate ;)
03:00:28 <roconnor> jethr0: sorry, I followed a google link
03:00:37 <jethr0> np
03:06:05 <roconnor> I thought processors used CORDIC http://en.wikipedia.org/wiki/CORDIC but that doesn't seem to be the case
03:06:06 <lambdabot> Title: CORDIC - Wikipedia, the free encyclopedia
03:12:11 <vincenz> 'lo
03:12:56 <nominolo> @seen earthy
03:12:56 <lambdabot> earthy is in #haskell. I don't know when earthy last spoke.
03:13:15 <nominolo> @localtime earthy
03:13:17 <lambdabot> Local time for earthy is Wed Jul 18 12:12:27 2007
03:38:44 <vincenz> cdsmith: ping
03:43:06 * vincenz wonders why there's no autodefault
03:43:11 <vincenz> instance (Enum a) => (Random a)
03:43:27 <quicksilver> yeah I wondered that
03:43:38 <vincenz> seems rather obvious
03:43:47 <quicksilver> might be to do with the fact you can only have one instance
03:43:49 * vincenz was commenting on cdsmith's blog when I noticed there was no default random instance
03:43:52 <quicksilver> and that might not be the one you want?
03:43:56 <vincenz> quicksilver: sure, if you stick to H98
03:44:06 <vincenz> who does that nowadays?
03:44:23 <quicksilver> well -foverlapping-instances is not, IMO, very widely used
03:45:11 <mauke> do you want to know why h98 doesn't allow that?
03:45:32 <vincenz> mauke: oh right
03:45:35 <vincenz> mauke: no constructor
03:45:42 <vincenz> which might too easily lead to clashes
03:45:42 <quicksilver> ?
03:45:54 <vincenz> quicksilver: normall you should have
03:46:01 <vincenz> instance Foo a => Bar (CONST a)
03:46:10 <quicksilver> absoultely, yes
03:46:16 <vincenz> I didn't have that in my instance of Random
03:46:16 <quicksilver> that was what I was getting at :)
03:46:39 <mauke> and that's because instance Foo a => Bar a is a direct function call :-)
03:46:41 <quicksilver> I note that 'overlapping instances' is marked as 'probably no' for haskell-prime, too
03:46:42 <vincenz> quicksilver: Ah I thought you were just hinting that people might want to customize
03:47:04 <mauke> while instance Foo a => Bar (X a) is structural recursion
03:47:11 * vincenz kicks LaTEX
03:47:15 <mauke> and therefore always terminates
03:48:06 <vincenz> termination is overrated
03:48:31 <mauke> what's the ghc flag? -fallow-undecidable-instances?
03:48:48 <quicksilver> allow-overlapping, allow-incoherent, and allow-undecidable
03:48:55 <quicksilver> are the three IIRC
03:53:33 <opqdonut> -fallow-stupid-instances
04:06:19 <vincenz> -fallow-oleg-style
04:22:58 <quicksilver> -funbox-strict-olegs
04:26:11 <dblhelix> -fwarn-on-obscure-type-class-tricks
04:27:33 <quicksilver> -fuser-is-level-12-type-wizard
04:27:55 <vincenz> -fungi-party-best
04:28:34 <dblhelix> quicksilver: I thought in #haskell we were working with colored belts rather than numeric levels? ;-)
04:28:42 <mauke> -for-great-justice
04:37:16 <pejo> dblhelix, it's much easier to see 11 < 12 rather than green < black though. :-)
04:38:04 <Syzygy-> -fuser-is-oleg
04:38:14 <dblhelix> pejo: of course, but belts are much cooler, don't you think? 8-)
04:38:35 <Syzygy-> dblhelix: In that case, we need the Dan ordering within the belts too, don't you think?
04:39:00 <dblhelix> Syzygy-: of course!
04:39:01 <vincenz> Syzygy-: and the maximum color is the "oleg-colored belt"?
04:39:17 <vincenz> Similarly you have cale-colored belts
04:39:19 <mauke> octarine!
04:39:36 <Syzygy-> Wonder if the belts necessarily need to be a total order.
04:39:39 <vincenz> or more shortly, calered belt
04:39:53 <Syzygy-> vincenz: Bah
04:40:01 <Syzygy-> ?seen syntaxfree
04:40:01 <lambdabot> Last time I saw syntaxfree was when I left #darcs, #dreamlinux-es, #friendly-coders, #gentoo-haskell, #gentoo-uy, #ghc, #haskell, #haskell-blah, #haskell-overflow, #haskell-soc, #jtiger, #oasis, #
04:40:01 <lambdabot> parrot, #perl6, #scannedinavian, #unicycling and #xmonad 13d 11h 38m 40s ago, and .
04:40:08 <Syzygy-> o.O
04:40:10 <vincenz> lambdabot: channel-slut
04:40:41 <pejo> dblhelix, maybe use shields like the Triforce group at Harvard? (The figures from Zelda).
04:41:14 <dblhelix> pejo: haven't seen those, but they do sound cool
04:41:15 <roconnor> @vixen
04:41:16 <lambdabot> Why is magenta on blues clues a boy while blue is a girl? what has this world come to and what is wrong with the government, blues clues should be stopped while its ahead!!
04:41:27 <pejo> dblhelix, www.eecs.harvard.edu/triforce
04:41:57 <pejo> Near the bottom of the page.
04:42:03 * dblhelix laughs
04:42:23 * earthy grins
04:42:31 <earthy> especially the 'tenured grad student' part :)
04:42:55 <roconnor> ugh, when I write my paint program, I'll make changing the aspect ratio of images impossible.
04:44:15 <earthy> miss le Goues' picture did suffer a bit, indeed.
04:45:32 <mm_freak_> exactly 333 non-ops‚Ä¶  we're in half-hell here
04:46:10 <vincenz> mm_freak_: ?
04:46:40 <dblhelix> vincenz:
04:46:42 <dblhelix> > 2 * 333
04:46:44 <lambdabot>  666
04:46:54 --- mode: ChanServ set +o vincenz
04:47:03 <dblhelix> > 2 * 332
04:47:05 <lambdabot>  664
04:47:11 <dblhelix> ah, we're safe again :-)
04:47:57 <mm_freak_> hehe
04:48:02 * vincenz looks for his BIG RED KICK BUTTON
04:48:31 <dons> earthy: coming to the hackathon, btw? :)   (or thinking about it?)
04:48:36 --- mode: vincenz set -o vincenz
04:48:48 <wli> Is the hackathon in Europe or something?
04:48:53 <vincenz> wli: freiburg
04:48:53 <earthy> wli: it is
04:48:57 <mm_freak_> wli: it's in germany
04:48:59 <earthy> freiburg, early october, IIRC
04:49:14 <earthy> thing is just that I'll have a (roughly) 3 week old baby at that time
04:49:19 <vincenz> earthy: no, end of september
04:49:23 <mm_freak_> september
04:49:31 <dons> earthy: ah yes, that might be complicating
04:49:36 <earthy> it's before ICFP?
04:49:41 <Igloo> After ICFP
04:50:19 <wli> Hmm. The nearest event I could plausibly piggyback it onto is Sep. 3.
04:50:28 <mm_freak_> btw, where exactly?
04:50:32 <vincenz> mm_freak_: freiburg
04:50:39 <earthy> it says it'll be october 5-7 ...
04:50:42 <mm_freak_> vincenz: yeah, but where in freiburg?
04:50:47 <vincenz> oh
04:50:50 <vincenz> is it that big?
04:51:13 <Igloo> Probably university building 101, I think, but don't quote me on that
04:51:37 <dons> 101 Igloo ? was that on the sommercampus page?
04:51:42 <Igloo> Yeah
04:51:50 <Igloo> It said most things will be in building 101 IIRC
04:51:52 <mm_freak_> vincenz: it's just that i live pretty near there‚Ä¶  and i don't think that you're gonna hack under an appletree =)
04:52:03 <vincenz> mm_freak_: well it worked for Newton
04:52:26 <dons> it'll be nice weather, and we have wireless, so apple trees could work
04:52:54 <jethr0> *yay*, there is a ghci-based debugger... why didn't anyone tell me? ;)
04:52:56 <earthy> http://www.haskell.org/haskellwiki/Hac_2007_II
04:52:57 <lambdabot> Title: Hac 2007 II - HaskellWiki
04:53:08 <wli> Odds are I could probably find places to stay for free but I wouldn't be able to pick where.
04:53:31 <mm_freak_> University of Freiburg, Freiburg, Germany ‚áê ah
04:53:50 <vincenz> dons: I only wrote that message cause quicksilver asked me to
04:54:03 <wli> I could end up as far afield as Madrid or Moscow.
04:54:42 <mm_freak_> dons: i'd love to come, but there isn't much i could contribute, other than writing beginner tutorials or something
04:54:57 <Igloo> Writing beginners tutorials would be great!
04:55:04 <wli> The exchange rate is pretty bad. Airfare, too.
04:55:06 <nominolo> mm_freak_: sounds not too bad
04:55:07 <HairyDude> is there no portable 'delete' function in the standard libraries?
04:55:11 <HairyDude> for files
04:55:16 <nominolo> you can learn a lot
04:55:19 <mauke> @hoogle removeFile
04:55:20 <lambdabot> Directory.removeFile :: FilePath -> IO ()
04:55:40 <HairyDude> ah, unintuitively in Directory, instead of IO where all the other file I/O stuff is
04:55:43 <dons> btw, in case people didn't see cdsmith's new tutorial, http://www.haskell.org/haskellwiki/Learn_Haskell_in_10_minutes
04:55:44 <lambdabot> Title: Learn Haskell in 10 minutes - HaskellWiki
04:55:51 <mm_freak_> hmm
04:55:54 <mauke> HairyDude: removing files is a directory operation
04:55:58 <dons> http://programming.reddit.com/info/27bpn/details also
04:55:59 <lambdabot> Title: Learn Haskell in 10 minutes (reddit.com)
04:56:27 <mauke> (see also: why you can remove files you can't write to)
04:56:51 <fasta> @pl do a <- b; (return . return ) b
04:56:52 <lambdabot> (line 1, column 10):
04:56:52 <lambdabot> unexpected ";"
04:56:52 <lambdabot> expecting letter or digit, variable, "(", "`", "!!", ".", operator or end of input
04:56:54 <quicksilver> HairyDude: it's a bit odd, I agree, although it suits the unix view
04:57:01 <quicksilver> HairyDude: removing a file is, in fact, a directory operation
04:57:06 <fasta> @pl do a <- b; (return . return ) a
04:57:06 <lambdabot> (line 1, column 10):
04:57:07 <lambdabot> unexpected ";"
04:57:07 <lambdabot> expecting letter or digit, variable, "(", "`", "!!", ".", operator or end of input
04:57:07 <mm_freak_> dons: fine tutorial, but far from complete
04:57:10 <HairyDude> quicksilver: indeed, a windows programmer thinks of it as a file operation
04:57:13 <quicksilver> HairyDude: a directory is just a special file storing its contents, after all :)
04:57:17 <mauke> @. pl undo do a <- b; (return . return ) b
04:57:17 <lambdabot> b >> return (return b)
04:57:32 <wli> Beyond the extreme measures required to get me there in the first place (which all fall through sans corporate sponsorship of the original trip to piggyback it onto) I'd probably be a disruptive presence due to my appearance.
04:57:43 <dons> mm_freak_: oh, i think its fairly complete, for it aims only to reproduce the first 10 minutes of haskell hacking.
04:57:43 <fasta> @. pl undo a <- b; (return . return ) a
04:57:43 <lambdabot> (line 1, column 21):
04:57:44 <lambdabot> unexpected "{"
04:57:44 <lambdabot> expecting variable, "(", operator or ")"
04:57:44 <mm_freak_> actually i don't want to write a `tutorial' in the classical sense‚Ä¶  people should also _understand_ and know how haskell is different from C
04:57:55 <dons> unlike our usual highly technical stuff
04:58:01 <quicksilver> @. pl undo do a <- b; (return . return ) a
04:58:01 <lambdabot> return `fmap` b
04:58:05 <jethr0> fasta: use /msg lambdabot for an exclusive chat with her
04:58:09 * quicksilver wins
04:58:26 * earthy hugs Data.Time.Calendar in the meantime
04:58:45 <earthy> 'hm, how many days would that be exactly...' 'diffDays (fromGregorian 2007 10 05) (fromGregorian 2007 09 20)' 'ah'
04:58:48 <nominolo> mm_freak_: if you're in freiburg anyways i don't see why you shouldn't come over
04:59:12 <mm_freak_> nominolo: i'm in ludwigsburg‚Ä¶  that's about 20 mins via train
04:59:14 <wli> earthy: Careful. "09" may be interpreted as octal(!).
04:59:23 <mauke> > 09
04:59:24 <lambdabot>  9
04:59:29 <vincenz> dons: do we ahve to register for the hackathon?
04:59:31 <mauke> since when is 9 an octal digit?
04:59:37 <wli> mauke: Leading 0.
04:59:39 <quicksilver> wli: in javascript it may :)
04:59:43 <quicksilver> > 077
04:59:45 <lambdabot>  77
04:59:46 <earthy> this is haskell
04:59:47 <roconnor> > 010
04:59:48 <lambdabot>  10
04:59:51 <vincenz> seems so...
04:59:54 * mauke kicks wli in the pit
05:00:03 * quicksilver releases the lambda-lions
05:00:05 <mm_freak_> nominolo: because i don't wanna watch others working all the day
05:00:14 * earthy would never try this in e.g. C. ;)
05:00:21 <earthy> mm_freak_: then work along! :)
05:00:21 <wli> Okay, sorry. Leading zeroes are still "nasty."
05:01:15 <hkBst> >o10
05:01:20 <mm_freak_> earthy: yeah‚Ä¶  i'll need to write something serious, something useful‚Ä¶  and the only thing i could imagine is another tutorial‚Ä¶  now there are thousands of tutorials out there, some mine would need to be way different
05:01:31 <fasta> >0x9
05:01:32 <nominolo> mm_freak_: i guess your train-ride should be free (studententicket?) and watching good hackers is usually very educational
05:01:37 <mm_freak_> some=so
05:01:40 <roconnor> > 0x10
05:01:41 <lambdabot>  16
05:01:42 <fasta> > 0x9
05:01:43 <lambdabot>  9
05:01:55 <earthy> > 0o10
05:01:56 <lambdabot>  8
05:01:57 <earthy> ?
05:01:57 <mm_freak_> nominolo: i'm not a student
05:01:59 <earthy> right. ;)
05:02:04 <quicksilver> cute
05:02:06 <mm_freak_> it's not free, but that's ok =)
05:02:07 <quicksilver> shame we can't do
05:02:11 <quicksilver> > 0b111000
05:02:11 <nominolo> mm_freak_: i see
05:02:11 <lambdabot>   Not in scope: `b111000'
05:02:19 <earthy> 20 minute train rides are not normally expensive either
05:02:19 <hkBst> > o10
05:02:20 <lambdabot>   Not in scope: `o10'
05:02:41 <earthy> if I were just 20 minutes away from freiburg I'd attend, even given that I'll have 2 to 3 week old kid by then
05:02:49 <mm_freak_> earthy: yeah‚Ä¶  should be around ‚Ç¨ [6;10]
05:03:00 <vincenz> dons: Igloo informed me that 6.6.1 and 6.6 have the same version number "606" so I'm not sure it's to cpphs patch the ShowQ stuff
05:03:08 <vincenz> it's .. .possible
05:03:22 * dblhelix should go and program again
05:03:28 <mauke> why doesn't ghc just use the perl numbering scheme?
05:03:31 <earthy> anyway, back to Word and text editing
05:03:40 <earthy> the joys of education ;)
05:03:48 <earthy> and being at the teaching end :)
05:03:50 <nominolo> i'd go, even if just to watch a little.  and maybe you find something to help out with maybe not
05:04:12 <quicksilver> earthy: it's never too early for a young child to attend his first haskell hackathon
05:04:23 <wli> With the exchange rates going crazy etc. transatlantic flights are not exactly trivial burdens.
05:04:29 <earthy> quicksilver: It is too early for a 2 week old to travel 6 hours by train...
05:04:40 <quicksilver> earthy: You get a gold lambda if they write their first monad transformer by six months
05:04:44 <mm_freak_> vincenz: The 3rd Haskell Hackathon will be held over 3 days, October 5-7 2007, ‚Ä¶
05:04:47 * earthy laughs
05:04:53 <quicksilver> earthy: yeah, this was all under the 'if I were 20 minutes' hypothetical
05:04:54 <fasta> How much code gets produces during a hackathon on average per day?
05:04:59 <fasta> produced*
05:05:01 <earthy> quicksilver: exactly
05:05:07 <earthy> fasta: quite a bit
05:05:07 <quicksilver> around 3 hundredweight
05:05:12 <vincenz> mm_freak_: thx, yes, I was incorrect, the conferences prior to that start on 30sept
05:05:18 <earthy> Data.Binary was from early this year
05:05:26 <earthy> IIRC
05:05:35 <fasta> quicksilver: was that for me?
05:05:44 <wli> fasta: By lines of code it won't sound like much, but it never will in Haskell. ;)
05:05:49 <mm_freak_> me too‚Ä¶  last time i was on that page, it was september
05:06:01 <fasta> (oh, I mean per person, btw)
05:06:04 <fasta> wli: I don't agree
05:06:11 <fasta> wli: writing Haskell is _easier_.
05:06:13 <roconnor> ``I consistently fall for the same traps. A distressingly large percentage of my debugging time is spent correcting mistyped identifiers - often not detected until several minutes into a test run. The most common mistyping I make is incorrect capitalisation.
05:06:21 <earthy> fasta: no it isn't
05:06:23 <fasta> wli: when compared to e.g. C.
05:06:23 <roconnor> http://www.codinghorror.com/blog/archives/000458.html
05:06:25 <lambdabot> Title: Coding Horror: The Case For Case Insensitivity
05:06:32 <fasta> earthy: well, _I_ think it is.
05:06:32 <earthy> writing *correct* Haskell is easier :)
05:06:41 <roconnor> Get a static analyser!
05:07:44 <wli> fasta: 10KLOC in Haskell means something vastly different from 10KLOC in C. The coding process is also different. More thought, less scribbling out redundant crap.
05:08:23 <fasta> wli: I know the process for >10KLOC perfectly well.
05:08:30 <fasta> wli: in Haskell, that is.
05:08:34 <fasta> wli: for C, I don't know.
05:08:56 <fasta> wli: but the only simple things I did try in C didn't really come of the ground.
05:09:09 <mauke> wtf. why do I never get bitten by case sensitivity?
05:09:20 <earthy> mauke: because you're used to it
05:09:26 <earthy> plus, haskell's case sensitivity is sane
05:09:30 <earthy> and typed
05:09:44 <mauke> but I also write Perl
05:09:53 <wli> fasta: 10KLOC in C I do relatively routinely. Lots of mindless garbage. I can literally daydream about other things while writing it.
05:09:54 <hpaste>  shillelagh pasted "haskellmode-20070615.ebuild" at http://hpaste.org/1749
05:10:05 * earthy looks at fasta and thinks 'I should know you'
05:10:07 <fasta> wli: can you compare the time it took you to write 10KLOC C VS 10KLOC Haskell?
05:10:21 <fasta> wli: For the same thing
05:10:37 <fasta> wli: so, we are not comparing some hugely complex algorithm in Haskell vs a simple algorithm in C.
05:10:54 <wli> fasta: I'd have to write code for hOp/House to do something comparable.
05:10:55 * earthy smiles at the thought of hammering out recursive descent parsers in C
05:11:20 <earthy> many many lines of code due to the ~10x blowup in linecount
05:11:33 <earthy> ofcourse, with decent parser combinators as in Haskell you don't get any blowup at all
05:11:55 <earthy> so comparing loc for C and haskell just isn't realistic
05:12:29 <hpaste>  dozer pasted "circular reasoning" at http://hpaste.org/1750
05:12:44 <pejo> 10k is insanely much. How big is the Helium compiler for example, or some other fp compiler?
05:13:01 <dozer> I've been trying to reduce my ghc stack overflow problem from yesterday into a simple demo case
05:13:13 <wli> pejo: I've done 100KLOC in C for things that are not all that complex.
05:13:24 <dozer> got down to this in the pastebin - the example with propper names barfs while the one with Foo/Bar doesn't
05:13:37 <dozer> I can't see what's different between the two other than one uses longer names
05:13:58 <pejo> wli, yeah, any subdirectory in Mozilla is 100KLOC too.
05:14:44 <earthy> pejo: Dazzle is 15kloc
05:14:47 <earthy> of Haskell
05:14:58 <earthy> (just an example)
05:15:10 <wli> pejo: Same basic idea. Change some tiny thing that would be handled without noticing by polymorphism in Haskell and you're off on a trek through several million LOC to fix up the 100KLOC that need changing.
05:15:21 <fasta> earthy: and how many manyears got into that?
05:15:51 <earthy> fasta: about 3
05:15:56 <earthy> if that many
05:15:59 <wli> What's Dazzle?
05:16:03 <fasta> earthy: wow, that's long.
05:16:15 <pejo> Dazzle is a tool for editing and analysing Bayesian networks and is being developed at the decision support group of the institute of information and computing sciences of Utrecht University.
05:16:16 <earthy> 2 programmers for 1.5 years
05:16:22 <earthy> roughly
05:16:31 <fasta> I wrote 15KLOC of highly algorithmic code in Haskell in less than 9 months.
05:16:40 <earthy> ah, this was UI code mostly
05:16:58 <earthy> and needed quite a lot of interaction with the intended users
05:17:04 <earthy> that slows things down...
05:17:05 <pejo> A compiler for a functional language can be squeezed into 12k.
05:17:17 <earthy> hattrans is about 10kloc
05:17:19 <fasta> pejo: Isn't GHC 100KLOC?
05:17:20 <wli> Numbers aren't really helped by language facilities.
05:17:45 <wli> You get wrong answers and the type system etc. don't tell you much of anything.
05:17:46 <dozer> my record is 36kloc of Java in 3 weeks
05:18:02 <fasta> dozer: o.0
05:18:12 <dozer> probably worth about 5-10kloc haskell perhaps
05:18:16 <pejo> fasta, it's big, so you're probably right. I woudln't be surprised if hbc is a lot smaller.
05:18:57 <fasta> pejo: but "a compiler" is vastly different from something that is actually production ready.
05:19:14 <fasta> GHC isn't production ready, except possibly for H98 stuff.
05:19:35 <fasta> Then again, maybe Java isn't production ready either ;)
05:19:46 <pejo> fasta, what's missing from GHC for it to be production ready, except maybe documentation?
05:19:58 <fasta> pejo: bugs are still being found
05:20:17 <fasta> pejo: lots of them, btw.
05:20:18 <earthy> and this is different from gcc how? :)
05:20:30 <dozer> pejo: it gives rubbish error reports about classes
05:20:41 <pejo> fasta, by that definition no software out there is production ready, except maybe the stuff that's proven correct.
05:20:46 <fasta> dozer: I don't think the messages are hard to understand anymore.
05:21:08 <fasta> dozer: but if you don't know what is meant _exactly_ then you have a problem.
05:21:34 <dozer> fasta: I had one yesterday that was telling me I needed an instance of XmlPickler Char, but didn't give me any clue about what part of a datastructure was giving rise to this requirement
05:22:09 <fasta> pejo: About a year of no errors being found used by 1000 users would qualify as production ready.
05:22:15 <fasta> pejo: I think that's reasonable.
05:22:16 <dozer> fasta: a path through the inferred class types would have naild it down emediately
05:22:39 <fasta> dozer: there's already a bug opened for this
05:22:45 <dozer> fasta: cool
05:22:49 <fasta> dozer: (by me)
05:23:19 <pejo> fasta, ok, so no software is production ready.
05:23:24 <fasta> dozer: essentially what you want is too use your editor to go through all positions giving rise to a particular constraint.
05:23:32 <fasta> pejo: I disagree.
05:23:46 <fasta> dozer: to*
05:23:53 <earthy> Helium does something quite like that when giving error messages
05:23:56 <fasta> dozer: that needs some compiler support to be efficient.
05:24:14 <dozer> fasta: well, I'd like the compiler to tell me enough info that this is an option, yes
05:24:19 <dozer> anyway, anyone had a sec to look at the code I pasted a mo ago? I can't see why the top two instances of XmlPickler recurse badly, but the bottom two are fine.
05:24:28 <quicksilver> mauke: I'm only ever thrown by inconsistency. getElementById (javascript) bites me every wingle time :)
05:24:46 <mauke> what's inconsistent about it?
05:25:06 <fasta> Is flag order relevant to ghci?
05:25:07 <quicksilver> mauke: Id is most normally written 'ID' even though it isn't really an acronym
05:25:11 <mauke> ah
05:25:20 <fasta> It is in some command, but I don't know whether that is a bug.
05:25:33 <pejo> earthy, aware of any plans to port the Helium infrastructure to GHC?
05:25:56 <fasta> pejo: that would be a corporate project, I guess.
05:26:09 <fasta> pejo: universities are in ivory towers and all that ;)
05:26:20 <pejo> fasta, isn't the error reporting stuff in Helium basically done by one phd student?
05:26:42 <fasta> pejo: It was done by three people, IIRC.
05:26:53 <fasta> pejo: but the error reporting was one guy's phd thesis, yes.
05:28:32 <kallepersson> My pal liber told me to go here and say "fuck haskell". I doubt his seriousness though.
05:28:44 --- mode: ChanServ set +o vincenz
05:29:09 <earthy> pejo: nope. but there are efforts underway here @ Utrecht University to take the insights gained from Helium and incorporate them in a full strength Haskell compiler
05:29:10 <dblhelix> kallepersson: do you know haskell?
05:29:17 <quicksilver> unfortunately, we're just too nice to respond in the way he probably hoped
05:29:20 <quicksilver> oh well
05:29:27 <earthy> (including the type system extensions and such)
05:29:34 <quicksilver> if you want to learn a really cool programming language, though, you've come to the right place
05:29:42 <kallepersson> Oh. Cool
05:29:47 <kallepersson> I'd like that
05:29:54 <fasta> kallepersson: leave while you still can
05:29:58 <kallepersson> Yeah, he wasn't serious or something.
05:30:02 <kallepersson> Really.
05:30:05 <kallepersson> He just dared me to
05:30:05 <fasta> kallepersson: before you know it you know what an endofunctor is.
05:30:08 <vincenz> kallepersson: you'll get hooked
05:30:12 <quicksilver> well this is our link of the day:
05:30:13 <quicksilver> http://www.haskell.org/haskellwiki/Learn_Haskell_in_10_minutes
05:30:14 <lambdabot> Title: Learn Haskell in 10 minutes - HaskellWiki
05:30:16 <kallepersson> Or, first I dared him - but then he dared me back so I did it
05:30:22 <kallepersson> Cool
05:30:28 <kallepersson> BRB in 10 minutes them
05:30:30 <kallepersson> *then
05:30:54 <pejo> earthy, happen to know offhand what type system extensions helium has that haskell doesn't?
05:31:11 <fasta> pejo: None, AFAIK.
05:31:12 <earthy> pejo: Helium doesn't even have everything that Haskell does
05:31:18 <earthy> e.g. type classes. :P
05:31:38 <earthy> (weeelll.... that's not entirely true... but still)
05:32:07 <pejo> earthy, doh, you meant the other way around. Ok.
05:32:26 <fasta> pejo: ?
05:33:35 <mux> haskell without type classes would be like C without segfauls
05:33:56 <malcolmw> Helium uses CHR resolution for type inference, no?
05:34:00 <wli> Anyway, I have to pound out huge volumes of code all the time for work/etc. The great thing about Haskell is that when doing things outside of work I don't have to pound out huge volumes of code for it.
05:34:17 <quicksilver> yeah
05:34:32 <quicksilver> also haskell has a higher 'works-first-time' probability for me
05:34:49 <quicksilver> and a much higher 'works-first-time-you-actually-make-it-compile' probability
05:34:50 <dblhelix> malcolmw: no, not exactly CHR, but it's constraint based, indeed
05:35:02 <mux> Chameleon is CHR based
05:36:42 <dozer> quicksilver: the devil is in getting it to compile that first time :)
05:36:55 <quicksilver> yeah
05:37:04 <dozer> quicksilver: although I'm finding that the type system catches 90% of bugs before I even hit RUN
05:37:05 <quicksilver> that's why the first anecdote is actually more interesting than the second
05:37:24 <quicksilver> dozer: more interesting than that, is that the type system actually catches *design* errors
05:37:44 <quicksilver> dozer: "you can't write this function, because the type doesn't make sense, because you modelled your problem wrongly"
05:37:50 <wli> The reason I like it is that I feel like I'm actually doing intellectual work instead of data entry.
05:37:52 <quicksilver> not always, obviously
05:37:52 <dozer> quicksilver: yeah - been noticing that
05:37:53 <quicksilver> but sometimes
05:38:20 <mux> yeah, I like it when the compiler forces me to do things The Right Way (tm)
05:38:21 <wli> C is a lot of mindless sweeping for things that polymorphism would handle.
05:38:42 <wli> With second-order effects around a lot of other things.
05:39:08 <chessguy> what determines which classes can be used in a "deriving (...)" clause?
05:39:09 <lambdabot> chessguy: You have 1 new message. '/msg lambdabot @messages' to read it.
05:39:18 <quicksilver> chessguy: compiler magiv
05:39:21 <mauke> chessguy: the language definition
05:39:33 <quicksilver> chessguy: derivings require compiler support
05:39:47 <chessguy> it's implementation-specific?
05:39:52 <quicksilver> yes
05:39:57 <quicksilver> it's a kind of metaprogramming
05:40:04 <quicksilver> without a real metalanguage
05:40:08 <chessguy> is there a list somewhere for ghc?
05:40:24 <mauke> .oO( h98 + Typeable? )
05:40:26 <quicksilver> in most cases you can only derive a fixed set, but newtype deriving is an exception
05:40:28 <wli> Eq, Ord, Read, Show, Bounded, Enum, Ix I think.
05:40:36 <quicksilver> Data, Typeable
05:40:51 <chessguy> Arbitrary?
05:40:56 <ddarius> chessguy: In the User Manual
05:41:05 <ddarius> Plus newtype deriving (also covered in the User Manual)
05:41:07 <quicksilver> I don't believe there is deriving arbitrary, no
05:41:28 <quicksilver> chessguy: to derive other classes (Arbitrary, Binary) see DrIFT or Derive
05:41:37 <ddarius> Eventually the deriving mechanism will be supplanted.
05:41:40 <quicksilver> or, of course, TH. If you're hardcore.
05:42:29 <quicksilver> ddarius: by?
05:44:07 <chessguy> oh, interesting. some classes can be derived according to H98
05:44:12 <chessguy> GHC extends the list
05:44:32 <chessguy> "In Haskell 98,
05:44:33 <chessguy> the only classes that may appear in the deriving clause are the standard classes Eq, Ord, Enum, Ix,
05:44:33 <chessguy> Bounded, Read, and Show"
05:44:45 <chessguy> "GHC extends this list with two more classes that may be automatically derived (provided the -
05:44:45 <chessguy> fglasgow-exts flag is specified): Typeable, and Data."
05:45:03 <quicksilver> yes, isn't that what we just told you? :)
05:45:18 <mauke> <wli> Eq, Ord, Read, Show, Bounded, Enum, Ix I think.  <quicksilver> Data, Typeable
05:45:51 <wli> My answers are occasionally correct.
05:46:16 <chessguy> well, i got the impression from what you said that it was entirely implementation-specific. anyway, you were all certainly correct, as usual
05:46:44 <chessguy> @where haxe
05:46:44 <lambdabot> I know nothing about haxe.
05:47:01 <quicksilver> @go haxe
05:47:01 <mauke> oh, I kind of assumed you knew about the derivable classes defined in h98
05:47:03 <lambdabot> http://haxe.org/
05:47:03 <lambdabot> Title: haxe [haXe.org]
05:47:05 <quicksilver> it's there :)
05:47:33 <fasta> @where+ haxe http://haxe.org/
05:47:33 <lambdabot> Done.
05:47:38 <quicksilver> ajb gets the prize for 'maths-geek joke of the fortnight' on -cafe
05:47:48 <quicksilver> it almost made me laugh out loud, in fact
05:47:52 <quicksilver> but I have a twisted mind
05:48:58 * chessguy pokes through his trash looking for it
05:49:18 <kallepersson> @where haxe
05:49:19 <lambdabot> http://haxe.org/
05:49:21 <kallepersson> cool
05:49:25 <ddarius> quicksilver: Something better and/or extensible.
05:49:57 <kallepersson> @where+ php http://php.net
05:49:57 <lambdabot> Done.
05:50:10 <kallepersson> @go php.net
05:50:12 <lambdabot> http://php.net/
05:50:12 <lambdabot> Title: PHP: Hypertext Preprocessor
05:50:14 <jethr0> i'm trying to implement an instance of "Num" using lists of "bits". now, the "number" should have a defined width which would be the length of the list AND should be respected by the compiler to only add/... numbers with same width
05:50:14 <kallepersson> @go php
05:50:16 <lambdabot> http://www.php.net/
05:50:16 <lambdabot> Title: PHP: Hypertext Preprocessor
05:50:21 <kallepersson> @where php
05:50:21 <lambdabot> http://php.net
05:50:30 <quicksilver> kallepersson: you can talk to the bot in private, too
05:50:33 <kallepersson> Wonderful!
05:50:34 <kallepersson> Sorry
05:50:34 <quicksilver> kallepersson: if you're just experimenting
05:50:38 <kallepersson> I am
05:50:43 <dolio> Something like rewrite rules would be nice at least, where a library author could provide methods for deriving their datatypes.
05:50:44 <kallepersson> @where- php
05:50:45 <lambdabot> Maybe you meant: where where+
05:50:47 <quicksilver> @go is short for @google, btw
05:50:49 <lambdabot> http://www.blogherald.com/2005/03/06/a-short-history-of-blogging/
05:50:49 <lambdabot> Title: A short history of blogging : The Blog Herald
05:50:50 <kallepersson> aha!
05:51:08 <chessguy> @help where
05:51:09 <lambdabot> where <key>. Return element associated with key
05:51:13 <jethr0> now, using SUCC and ZERO i have the type level covered and with a parameter width i have the "value" level covered, but is there a way to "synchronize" these two??
05:51:26 <fasta> Uhm, I clicked on a JavaFX link. The source looks like Lisp.
05:51:31 <quicksilver> jethr0: hmm
05:51:38 <fasta> http://metalinkltd.com/?p=139
05:51:39 <lambdabot> Title: Metalink ª JavaFX &#8212; very cool, very slow
05:51:55 <quicksilver> jethr0: normally you use the type level at the value level, too
05:52:57 <vincenz> quicksilver: not perse, that causes unnecessary computation
05:52:59 <jethr0> quicksilver: k, how'd that look? Bit8 = Succ (... Zero ...); bit8 = D 8 :: Bit8
05:52:59 --- mode: vincenz set -o vincenz
05:53:17 <jethr0> something  like that? (warning: meta-pseudo-code)
05:54:28 <Syzygy-> Is there any way of telling, given the size of a file containing "show someLargeEntity" how much memory would be consumed by an "var <- fmap read . readFile "myfile"" ?
05:55:10 <dons> do you need ops, vincenz ?
05:55:34 <ddarius> He was removing op.
05:55:37 <quicksilver> @remember dpiponi Sometimes I wonder if the only difference between mathematicians and computer scientists is the direction of their arrows.
05:55:37 <lambdabot> Done.
05:55:43 <Syzygy-> quicksilver: Hehehe
05:57:46 * quicksilver is very tempted to @remember andrew's reply to that, too, but decides against it.
05:58:10 * jethr0 has a deep scepticism of type level "computations". it seems like an abusive hack of the type checker. but i admit, although the syntax is WAAAY more clunky than it should be, but there's some cool things possible with it
05:58:34 <quicksilver> you can think of them as 'compile-time computation' if that makes you happier
05:59:00 <jethr0> i wish i knew epigram better and it would be more mainstream/usable/tutorialized/...
05:59:05 <quicksilver> but clearly the syntax isn't set up for convenient general computation
05:59:15 <quicksilver> epigram has a pretty helpful mailing list
05:59:31 <jethr0> quicksilver: no, that makes me think of C++ templates and that makes me nautious
05:59:38 <wli> At some point I'll look into making a prime class and an irreducible polynomial class.
05:59:41 <fasta> @hoogle (Monad m1, Monad m) => (t -> a) -> m (Maybe t) -> m (m1 a)
05:59:42 <lambdabot> Did you mean: (Monad m1, Monad m) => (t -> a) -> m (Maybe t) -> m (M1 a)
05:59:42 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
05:59:42 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
06:00:13 <dons> quicksilver: what was the reply?
06:00:19 <jethr0> quicksilver: k, i'm having a really hard time with some of the notations used in "those" circles. but some day i'll get deeper into it, maybe when i've "mastered" haskell *g*
06:00:38 <quicksilver> dons: "..wooooosh... ...and now I know what normal people must feel like when *I* open my mouth. o_O "
06:00:52 <vincenz> quicksilver: link?
06:01:13 <jethr0> quicksilver: do you "use" epigram? do they support more complex functions by now?
06:01:26 <jethr0> haha
06:01:35 <quicksilver> vincenz: http://www.haskell.org/pipermail/haskell-cafe/2007-July/028319.html
06:01:36 <lambdabot> Title: [Haskell-cafe] Clearly, Haskell is ill-founded, http://tinyurl.com/2v3gw6
06:01:41 <quicksilver> jethr0: no, I've only played with it
06:01:45 <jethr0> nice title
06:01:47 <quicksilver> jethr0: and not for a few months
06:01:54 <dons> quicksilver: scary, yes, i recall that one
06:02:18 <quicksilver> if this was a work of fiction, and not real life, I'd call it dramatic irony ;)
06:08:16 <wli> I should probably find a way to phrase my "difficulties" with monads in such a way it's clearer what my "level of sophistication" is.
06:09:06 <MyCatSchemes> Good afternoon, #haskell.
06:09:49 <MyCatSchemes> wli: I find, personally, that, "I HAS NO FCUCKING CLUE, HALP PLZ!?" most concisely and precisely conveys my own level of sophistication. =D
06:09:50 <arcatan> gooooood moorning, haskell!
06:10:38 <oerjan> @bot
06:10:38 <lambdabot> :)
06:11:40 <wli> MyCatSchemes: I'm somewhere in-between, which means that the expert bits fly over my head and the truly newbie bits are too low-level.
06:12:14 <quicksilver> I CAN HAZ MONADIC ENLITENMUNT?
06:12:17 <oerjan> @remember M*********** I find, personally, that, "I HAS NO FCUCKING CLUE, HALP PLZ!?" most concisely and precisely conveys my own level of sophistication. =D
06:12:18 <lambdabot> Done.
06:13:44 <kaol> that's the lolcat monad?
06:13:52 <MyCatSchemes> quicksilver: I love it. :)
06:14:33 <MyCatSchemes> Now we just need a picture of a cat looking stoned with a ,\ shaved into its fur, to stick that caption on.
06:16:39 * ddarius is against shaving cats.
06:16:58 * vincenz is not going to do a play on words on that sentence..
06:18:51 <mauke> @remember f00li5h the practical limitations are endless
06:18:51 <lambdabot> Done.
06:19:38 <MyCatSchemes> ddarius: well, what if we got a pair of horn rimmed glasses and glued cardboard lambdas to the sides?
06:20:01 <MyCatSchemes> Or, painted a white cat's fur with food colouring while it sleeps
06:20:09 <swiert> jethr0: Just out of curiousity, what is it your trying to write?
06:22:30 <fasta> How can I sequence a bunch of computations of type m (Maybe a), s.t. when one of the (Maybe a) is Nothing, Nothing is returned for the complete computation?
06:22:56 <oerjan> i assume you also want the actions after the first Nothing to be skipped? :)
06:22:57 <mux> lift . sequence ?
06:23:09 <MyCatSchemes> I thought that was the whole point of Maybe being a monad?
06:23:18 <mauke> [m (Maybe a)] -> m [a]?
06:23:25 <swiert> fasta: what should it do if they are all Just?
06:23:32 <mux> :t lift . sequence
06:23:36 <lambdabot> forall (t :: (* -> *) -> * -> *) (m :: * -> *) a. (MonadTrans t, Monad m) => [m a] -> t m [a]
06:24:19 <edwardk> :t sequence
06:24:20 <jethr0> swiert: just fooling around. i'm trying to write a solution for the ruby quiz "c style ints". i've got the operations on lists of bits covered and am now trying to make my type an instance of "Num" and "Fractional" to get +,-,/,*,...
06:24:21 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
06:24:24 <mux> :t sequence . lift
06:24:26 <quicksilver> fasta: that's the MaybeT transformer
06:24:26 <lambdabot>     Couldn't match expected type `[]' against inferred type `t m'
06:24:26 <lambdabot>       Expected type: m a1 -> [m1 a]
06:24:39 <quicksilver> fasta: which isn't in the standard library for reasons unknown to me
06:24:48 <fasta> swiert: the intermediate values should be discarded and the final value should be returned
06:25:02 <edwardk> I think the argument was that ErrorT subsumed it, etc. which is bunk ;)
06:25:21 <vincenz> Anyone capable of explaining comonads to me in laymen terms?
06:25:30 <edwardk> fasta and you have a list of those maybes or just want to perform computations in that setting?
06:25:49 <dolio> @type Data.Traversable.sequence
06:25:50 <edwardk> vincenz: think of them as wrappers that you can throw away, but want to keep around if you can.
06:25:51 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Data.Traversable.Traversable t, Monad m) => t (m a) -> m (t a)
06:26:14 <vincenz> edwardk: right, but why?
06:26:20 <fasta> edwardk: the type as above it the type I am interested in
06:26:25 <fasta> edwardk: is*
06:26:27 <vincenz> edwardk: because the wrappers encode extra stuff?
06:26:42 <quicksilver> YACafeQuote "If you're writing device drivers in Visual Basic, you've made a strategic misstep and need to re-evaluate."
06:27:22 <edwardk> vincenz: a monad is easy to inject stuff into (return), a comonad is easy to take stuff out of, but perhaps the wrapper gives you more functionality so you don't want to discard it lightly.
06:27:33 <oerjan> fasta: which type? there are several
06:27:52 <vincenz> edwardk: alright, thanks
06:28:09 <fasta> oerjan: [m (Maybe a)] -> m (Maybe a) for simplicity.
06:28:13 <vincenz> edwardk: just that beyond streams (the typical example) I haven't seen enough other examples so it's hard to abstract and make an intuition
06:28:14 * jethr0 remembers the time when it was easier to use a joystick in basic than in pascal. so basic can't be the _worst_ language for device drivers. the "visual" part would not get used that much, though
06:28:14 <edwardk> at least i find that to be the best intuition for comonads i've been able to come up with
06:28:16 <fasta> I think I will just use MaybeT
06:28:41 <edwardk> vincenz: i find the ((,)e) context comonad to be enlightening because the 'wrapper' is obvious.
06:28:42 <quicksilver> fasta: [m (Maybe a)] -> m [(Maybe a)] is 'sequnce' from MaybeT
06:28:55 <vincenz> edwardk: that's the dual of a reader, right?  How does it work?
06:29:02 <quicksilver> fasta: then, obviously, you can take the 'last' element of that list of results if you want
06:29:05 <vincenz> edwardk: basically you have some extra info yo pass around but when you coreturn you lose it?
06:29:16 * dblhelix 's intuition for comonads stems from attribute grammars
06:29:42 <quicksilver> fasta: actually, I mean [m (Maybe a) -> m (Maybe [a]), sorry
06:29:50 <quicksilver> fasta: my comment still applies though
06:29:53 <earthy> you have an intuition for comonads?!
06:29:56 <earthy> wow. :)
06:30:03 <quicksilver> technically, a cointuition
06:30:03 * earthy still thinks they are magic. :)
06:30:04 <edwardk> start with (e,a), you need 2 operations, the third is derivable. extract, duplicate and extend. extract takes an a out of it. duplicate says given (e,a) you can get (e,(e,a) and extend says given (e,a) and (e,a) -> b you can get (e,b)
06:30:18 <edwardk> vincenz: exactly =)
06:30:23 <earthy> (other than 'synthesized attributes')
06:30:29 <vincenz> edwardk: thanks :)
06:31:28 <edwardk> quicksilver: =)
06:31:32 <jethr0> edwardk: that part i actually understand. the next part is where i always lose. bringing that into my practical world ;(
06:31:57 <vincenz> The problem with cointuition is that as soon as you try to get something out of it, it collapses
06:32:02 <edwardk> jethr0: i find there aren't that many cool comonads left by the time you get into haskell's semantics where data and codata are kind of mushed together.
06:32:26 <vincenz> edwardk: what is codata?
06:32:31 <SamB> whoa. JHC's still where I left it in it's output!
06:32:42 <oerjan> So if you try to get something into intuition, it lapses?
06:32:54 <vincenz> oerjan: :)
06:32:58 <edwardk> if you start with a more restricted logic though, you can usually use comonads to reintroduce the bits you gave up to get the simpler logic, and so you gain the power to track where those features are used.
06:33:00 <jethr0> edwardk: i like the idea of cellular automata and tree attribute synthesis as comonads. but as i said, practically i'm far from ever saying "oh, maybe i could use a comonad here"
06:33:30 <vincenz> anywho
06:33:31 <vincenz> back to useful work
06:33:33 <mux> okay, someone explain me what the hell is codata with respect to data :-) I can't let this pass anymore without knowing
06:33:39 * vincenz could use someone to look over some of his work at some point... 
06:33:45 <edwardk> vincenz: repeat n = n : repeat n is 'productive' codata. its not finite, but it always returns the next constructor when asked
06:34:04 <Syzygy-> mux: sigfpe/dpiponi has a characterization of data being the smallest solution to the corresponding type equation, and codata being the largest.
06:34:08 <ari> mux: http://sigfpe.blogspot.com/2007/07/data-and-codata.html
06:34:09 <lambdabot> Title: A Neighborhood of Infinity: Data and Codata
06:34:12 <edwardk> its sort of the opposite of data where you know you have a finite thing, and you can generate the answer to the whole thing when asked.
06:34:13 <vincenz> edwardk: hmm, I see
06:35:42 <oerjan> sigfpe is dpiponi?
06:35:43 <edwardk> jethr0: i was using a bunch of them to track type system features a little while back, but I found that practically having a whole family of comonads with commutativity laws was less easy to explain to someone than just carrying around everything in a monad with a lattice point describing where you are in the feature-space and what things you are allowed to do to the type.
06:35:47 <edwardk> oerjan: yeah
06:35:49 <mux> thanks
06:36:41 <edwardk> Syzygy-: thats fairly common, mu vs. nu. least vs. greatest fixpoints
06:36:43 <jethr0> so, what you did was a poor-man's-zipper (no offense) instead of the hard to explain comonad shebang, right?
06:36:54 <jethr0> well, maybe not even poor-man's
06:37:10 <fasta> quicksilver: your comment on sequence doesn't apply, right?
06:39:30 <edwardk> well, more of a poor man's ad hoc set of type properties
06:39:45 <quicksilver> fasta: which one?
06:39:52 <gkr> Is there anyfunction that given [(a, 4), (b, 5), (c, 6), (a, 3), (c, 2)] (adds all the elements with the same first component) into [(a,7), (b,5), (c,8)]?
06:40:14 <fasta> quicksilver: since I need a list of functions, sequence doesn't apply, AFAIK.
06:40:57 <quicksilver> fasta: sorry, give me  your type again?
06:41:02 <quicksilver> (the type you want)
06:41:10 <fasta> quicksilver: never mind
06:41:12 <quicksilver> :)
06:41:29 <quicksilver> sequence doesn't apply in itself, but you can certainly apply stuff with it
06:43:01 <SamB_XP> ooh, interesting, apparantly you can sign up for gmail right now...
06:45:04 <dolio> > map (unzip >>> head *** sum) . groupBy (\(a,_) (b,_) -> a == b) . sort $ [('a', 4), ('b', 5), ('c', 6), ('a', 3), ('c', 2)]
06:45:06 <lambdabot>  [('a',7),('b',5),('c',8)]
06:45:24 <oerjan> > Data.Map.toList . Data.Map.fromListWith (+) $ [('a', 4), ('b', 5), ('c', 6), ('a', 3), ('c', 2)]
06:45:24 <lambdabot>   Not in scope: `Data.Map.fromListWith'
06:45:45 <oerjan> huh?
06:45:46 <quicksilver> gkr: oerjan's answer is right
06:46:03 <quicksilver> gkr: but lambdabot doesn't seem to have Data.Map in scope these days
06:46:22 <quicksilver>  Data.Map.fromListWith (+) [('a',4),('b',5),('c',6),('a',3),('c',2)]
06:46:23 <quicksilver> fromList [('a',7),('b',5),('c',8)]
06:46:26 <opqdonut> SamB_XP: yeah, finally open :)
06:46:48 <edwardk> quicksilver: nice, much cleaner than my horrible groupBy, map, sum, etc thing i was working up =)
06:46:50 <opqdonut> stille beta tho
06:46:50 <SamB_XP> opqdonut: "finally"? it's been open before for at least a short period
06:47:04 <opqdonut> well, again :)
06:47:07 <SamB_XP> I signed up with no invite ;-)
06:48:09 <gkr> Thanks oerjan, quicksilver.
06:48:12 <quicksilver> edwardk: fromListWith is a bit obscure :)
06:48:16 <quicksilver> edwardk: it's quite funky though
06:48:35 <quicksilver> :t on
06:48:35 <jethr0> fromListWith is so much nicer than accumArray. i guess i should really use Map more often
06:48:37 <lambdabot> Not in scope: `on'
06:49:00 <quicksilver> Data.Map is key part of many of my programs
06:49:11 <quicksilver> being able to link datums to other datums in arbitrary (strongly-typed) ways
06:49:19 <quicksilver> it's all the power of perl hashes, but with typing!
06:49:21 <quicksilver> what's not to like :)
06:49:39 <SamB_XP> quicksilver: well, you do need an Ord instance ;-)
06:49:51 <oerjan> > Data.Map.empty
06:49:52 <lambdabot>   Not in scope: `Data.Map.empty'
06:50:04 <oerjan> > empty
06:50:05 <lambdabot> Terminated
06:50:08 <opqdonut> i'd like a two-way one-to-one mapping
06:50:12 <oerjan> :t empty
06:50:14 <lambdabot>     Ambiguous occurrence `empty'
06:50:14 <lambdabot>     It could refer to either `empty', imported from Control.Applicative
06:50:18 <opqdonut> keeping two maps is kinda ugly
06:51:19 <quicksilver> SamB_XP: tis true. But often I end up using some kind of identifier whichis often string or numeric
06:51:38 <quicksilver> opqdonut: not very hard to abstract, though, is it :)
06:51:51 <opqdonut> yeah, true
06:51:53 <opqdonut> but still
06:52:06 <fasta> quicksilver: zork:: ST s (Maybe Int);zork = undefined runMaybeT $ lift zork :: ST s (Maybe (Maybe Int)) I need ST s (Maybe Int)
06:52:58 <oerjan> > M.empty
06:52:59 <lambdabot>  fromList []
06:53:02 <oerjan> ah
06:53:07 <quicksilver> fasta: looks like a data-wrapping problem
06:53:26 <quicksilver> fasta: ST s (Maybe Int) 'is' the same type as MaybeT ST s Int
06:53:34 <quicksilver> fasta: but it's missing a (newtype) constructor
06:54:15 <quicksilver> :t runMaybeT
06:54:17 <lambdabot> Not in scope: `runMaybeT'
06:54:27 <SamB_XP> @hoogle runMaybeT
06:54:27 <lambdabot> No matches found
06:54:36 <fasta> runMaybeT :: MaybeT m a -> m (Maybe a)
06:54:37 <SamB_XP> hmm.
06:54:44 <SamB_XP> MaybeT is in the library?
06:54:48 <fasta> SamB_XP: no
06:54:51 <SamB_XP> ah.
06:54:51 <quicksilver> fasta: I think you mean runMaybeT (MaybeT zork)
06:54:56 <quicksilver> fasta: that has your type
06:55:24 <fasta> quicksilver: you mean return zork then?
06:55:47 <fasta> quicksilver: since using MaybeT is using internals ;)
06:56:18 <SamB_XP> so ... no library has Control.Monad.Maybe?
06:56:31 <quicksilver> fasta: no, return isn't the same as MaybeT
06:56:36 <fasta> quicksilver: return was wrong, indeed
06:56:39 <oerjan> @docs MaybeT
06:56:40 <lambdabot> MaybeT not available
06:56:40 <quicksilver> fasta: what I'm really saying is that zork has the wrong type
06:56:50 <oerjan> @docs Control.Monad.MaybeT
06:56:51 <lambdabot> Control.Monad.MaybeT not available
06:56:55 <oerjan> @docs Control.Monad.Maybe
06:56:55 <lambdabot> Control.Monad.Maybe not available
06:56:56 <quicksilver> you want zork to be :: MaybeT ST s Int
06:57:05 <quicksilver> ITS NOT THERE GUYES :P
06:57:07 <quicksilver> stop looking
06:57:09 <quicksilver> it's not in the library
06:57:16 <quicksilver> http://www.haskell.org/haskellwiki/New_monads/MaybeT
06:57:17 <lambdabot> Title: New monads/MaybeT - HaskellWiki
06:57:19 <oerjan> it's got to be SOMEWHERE
06:57:41 <opqdonut> maybe on the INTERNETS
06:57:45 <opqdonut> no, it cannot be!
06:57:50 <opqdonut> oh, surely not!
06:57:51 <dolio> It's in several mailing list posts.
06:57:54 <opqdonut> you must be joking sir!
06:58:06 <oerjan> always sir!
06:58:50 <cedricshock> Is the simple little function that compares by one comparison, and then by another if the first is equal written somewhere already?
06:59:27 <oerjan> cedricshock: tuples compare that way
06:59:50 <oerjan> you can use comparing with a function that turns it into a tuple
07:00:04 <fasta> quicksilver: for zork I could easily change the type.
07:00:32 <fasta> quicksilver: for other stuff that's already written, I can just use zork = old_code with a new type?
07:00:52 <cedricshock> oerjan: Thanks.
07:00:54 <fasta> quicksilver: hmm, well, I don't think that's going to work.
07:01:27 <oerjan> > sortBy (comparing \s -> (toUpper s, s)) "abABCd"
07:01:28 <lambdabot>  Parse error
07:01:42 <oerjan> > sortBy (comparing $ \s -> (toUpper s, s)) "abABCd"
07:01:44 <lambdabot>  "AaBbCd"
07:01:48 <edwardk> ErrorT String works =)
07:02:01 <ptolomy> Recently the Cafe has had people making reference to their "haskell Guru Level"... good idea; I think someone needs to put together a "Haskell Purity Test".
07:02:08 <ptolomy> 1 point if you've used a monad transformer
07:02:21 <ptolomy> 3 points if you have actually used arrows
07:02:28 <ptolomy> 20 points if you are a Simon.
07:02:33 <dolio> edwardk: That paper on monad coproducts was interesting.
07:03:04 <oerjan> how many for being Oleg?
07:03:12 <edwardk> or even 'data Void; instance Error Void where noMsg = undefined; strMsg _ = undefined; type MaybeT a = ErrorT Void a' then just remember that Left Void is 'Nothing' =)
07:03:40 <edwardk> dolio: thanks I think ski turned me on to that originally
07:03:47 <dolio> edwardk: A shame that it doesn't work on continuations, though. Because continuations are awesome.
07:04:08 <oerjan> does using >>> and &&& on (->) count as using arrows?
07:04:25 <jethr0> ptolomy: how many points for being an Oleg?
07:04:31 <opqdonut> well >>> almost does :)
07:04:37 <edwardk> i didn't remember there being a restriction on continuations in that.
07:04:45 <oerjan> :t (>>>, &&&)
07:04:46 <opqdonut> but (&&&) and (***) not imo :)
07:04:47 <lambdabot> parse error on input `,'
07:04:57 <oerjan> :t ((>>>), (&&&))
07:04:59 <lambdabot> forall (a :: * -> * -> *) b c d (a1 :: * -> * -> *) b1 c1 c'. (Arrow a, Arrow a1) => (a b c -> a c d -> a b d, a1 b1 c1 -> a1 b1 c' -> a1 b1 (c1, c'))
07:05:13 <dolio> edwardk: It says they aren't finitary, and their construction only works for finitary monads.
07:05:14 <fasta> quicksilver: The real zork is: zork:: (MonadST s m,  Monad m1) =>  m (m1 Int)
07:05:28 <edwardk> dolio: ah, now i remember
07:05:35 <ptolomy> jethr0: Hmm... for some reason, I imagine Oleg's score being a higher order functor with delimited continuations. It looks like magic, and I'm not smart enough to evaluate it.
07:05:54 <edwardk> hah
07:05:56 <oerjan> actually, >>> is just .
07:06:01 <opqdonut> yeah realised that
07:06:07 <dolio> edwardk: And if you look at their actual code, I can't think of how to write inverse-eta for Cont.
07:06:08 <jethr0> i guess Oleg's score has no value, only a higher-kind type
07:06:11 <edwardk> er flip (.) no?
07:06:16 <fasta> quicksilver: assuming that type cannot be changed, there is no solution other than using MaybeT?
07:06:30 <Syzygy-> I propose sqrt(-1) points for being Oleg.
07:06:42 <roconnor> > sqrt (-1)
07:06:43 <opqdonut> > ((+1) >>> (*2)) 0
07:06:43 <lambdabot>  NaN
07:06:44 <lambdabot>  2
07:06:50 <opqdonut> yeah flipped
07:07:11 <roconnor> > ((+1) <<< (*2)) 0
07:07:12 <lambdabot>  1
07:07:35 <opqdonut> yay
07:07:54 <opqdonut> next we need something that defines ><> and <><
07:08:12 <edwardk> fasta: or just bang out a MaybeT yourself. its all of what 5-6 lines?
07:08:20 <SamB_XP> isn't that a symbol of christianity?
07:08:35 <fasta> edwardk: What do you mean?
07:08:39 <fasta> edwardk: I already have MaybeT
07:08:41 <edwardk> opqdonut:those look fishy
07:08:41 <edwardk> =)
07:08:41 <opqdonut> SamB_XP: could be interpreted as one :)
07:08:43 <oerjan> opqdonut: sounds fishy to me
07:08:46 <Syzygy-> The fishies, yeah...
07:08:48 <SamB_XP> @hackage StrategyLib has a MaybeT
07:08:48 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/StrategyLib has a MaybeT
07:08:53 <opqdonut> ?quote stereo
07:08:54 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
07:08:58 <SamB_XP> but I was unable to find the license for it
07:09:00 <fasta> edwardk: the problem is that I don't want to change existing code.
07:09:05 <jethr0> SamB_XP: not really, i think. somehow the fish has come to symbolize christ, but i'm not sure that was ever made official.
07:09:09 * jethr0 goes to look it up
07:09:15 <roconnor> @stereo
07:09:16 <lambdabot> Unknown command, try @list
07:09:18 <edwardk> fasta: is the existing code monadic?
07:09:19 <SamB_XP> jethr0: "official"?
07:09:23 <Syzygy-> And for the simpler question or more active hours of the day, you get the answers in THX.
07:09:23 <Toxaris> jethr0: it isn't official
07:09:26 <opqdonut> jethr0: it is "official" as in it was a secret sign of the early christians
07:09:27 <fasta> edwardk: yes
07:09:32 <SamB_XP> this symbol has been christian since before official was invented
07:09:39 <vincenz> jethr0: the first roman worshippers used it as secret symbol when they were still persecuted before Caeser Augustus (?)
07:09:42 <fasta> edwardk: it returns m (Maybe foo) essentially
07:09:57 <vincenz> so pre ~380AD
07:09:58 <fasta> edwardk: where m has a few extra constraints
07:10:14 <jethr0> official = condoned/instituted by the pope (for all those catholics out there ;)
07:10:21 <vincenz> hah
07:10:22 <Toxaris> opqdonut: how can a "secret sign" be official?
07:10:29 <vincenz> Toxaris: it's not secret anymore
07:10:33 <opqdonut> Toxaris: yeah
07:10:34 <edwardk> and you just need to >> a bunch of those with MaybeT semantics?
07:10:38 <vincenz> Toxaris: catholics are no longer persecuted by romans
07:10:47 <SamB_XP> fasta: anyway I don't think anyone would be able to tell that you had copped it from StrategyLib and I wouldn't be at all surprised if StrategyLib turned out to be SPL'd
07:11:00 <vincenz> SamB_XP: I patented MaybeT
07:11:04 <jethr0> well, it's not secret any more, is it? there's a jesus-fish-sticker on every odd car in some parts of Germany these days
07:11:08 <fasta> SamB_XP: ?
07:11:15 <SamB_XP> @hackage StrategyLib
07:11:15 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/StrategyLib
07:11:17 <fasta> SamB_XP: I wrote it months ago myself
07:11:24 <SamB_XP> fasta: ah/
07:11:26 <edwardk> what keeps you from just defining (>>.) :: MonadFoo m => m (Maybe a) -> m (Maybe a) -> m (Maybe a)  ?
07:11:28 <SamB_XP> fasta: nevermind then
07:11:34 <fasta> SamB_XP: with some help from someone here.
07:11:39 <SamB_XP> fasta: I didn't realize you had it already ;-)
07:12:09 <SamB_XP> see, the fact that you could make it again is what I meant about nobody being able to tell you had copped it from StrategyLib
07:12:35 <fasta> SamB_XP: also, copyright wise, it's questionable to fall under it.
07:12:47 <SamB_XP> fasta: hmm?
07:12:50 <fasta> SamB_XP: it can be generated by a machine, I think.
07:12:57 <SamB_XP> oh, most probably
07:13:03 <fasta> SamB_XP: no "artistic expression"
07:13:11 <SamB_XP> that's pretty much what I meant by "nobody would be able to tell"
07:13:21 <fasta> SamB_XP: yes, I thought so.
07:14:24 <Toxaris> is there a function Bool -> x -> Maybe x to lift a value into the Maybe monad conditionally?
07:14:51 <opqdonut> huh? lift conditionally?
07:15:07 <opqdonut> ah, so if (p x) then Just x else Nothing?
07:15:22 <Toxaris> I mean (\cond val -> if cond then Just val else Nothing)
07:15:29 <opqdonut> yeah exactly
07:15:38 <Toxaris> to use with unfoldr
07:15:51 <wli> unfoldWhile
07:16:04 <dblhelix> Toxaris: yes it's written \b x -> do {True <- return b; return x}
07:16:27 <SamB_XP> fasta: I wonder if djinn can make it...
07:16:36 <SamB_XP> or what it would take to allow djinn to do so...
07:16:45 <dblhelix> Toxaris: but no standard function, not that I know of anyway
07:16:48 <Toxaris> djin couldn't know what the cond means
07:17:04 <SamB_XP> Toxaris: I was talking about MaybeT, sorry...
07:17:07 <jethr0> opqdonut: would be a nice std function though, i agree
07:17:11 <dolio> @pl \x -> (>> return x) . guard
07:17:11 <lambdabot> (. guard) . flip (>>) . return
07:17:22 <Toxaris> SamB_XP: oh ok
07:17:55 <fasta> runMaybeT(lift Nothing) :: Maybe (Maybe a) <- type defaulting going on?
07:17:57 <SamB_XP> fasta: I mean, clearly you need to at least do the newtype ;-)
07:18:18 <SamB_XP> fasta: not defaulting!
07:18:27 <SamB_XP> @type lift Nothing
07:18:29 <lambdabot> forall a (t :: (* -> *) -> * -> *). (MonadTrans t) => t Maybe a
07:18:35 <dolio> lift Nothing :: MaybeT Maybe a
07:18:37 <oerjan> @pl \cond val -> guard cond >> return val
07:18:38 <lambdabot> (. return) . (>>) . guard
07:18:42 <dolio> You want mzero.
07:18:54 <HairyDude> > replicateM 3 [False,True]
07:18:55 <lambdabot>  [[False,False,False],[False,False,True],[False,True,False],[False,True,True]...
07:18:58 <cedricshock> @hoogle comparing
07:18:58 <lambdabot> No matches found
07:18:59 <HairyDude> brilliant
07:19:15 <SamB_XP> cedricshock: we don't use comparing anymore
07:19:15 <vincenz> > length $ replicateM 3 [False,True]
07:19:16 <lambdabot>  8
07:19:20 <oerjan> @index comparing
07:19:20 <lambdabot> bzzt
07:19:28 <SamB_XP> we now use (compare `on`)
07:19:31 <vincenz> > let pow2 x = length $ replicateM x [False,True] in pow2 50
07:19:35 <lambdabot> Terminated
07:19:38 <SamB_XP> @hoogle on
07:19:38 <lambdabot> Test.QuickCheck.oneof :: [Gen a] -> Gen a
07:19:38 <lambdabot> System.Console.Readline.onNewLine :: IO ()
07:19:38 <lambdabot> Text.ParserCombinators.Parsec.Char.oneOf :: [Char] -> CharParser st Char
07:19:41 <oerjan> cedricshock: it's in Data.Ord
07:20:11 <vincenz> SamB_XP: on :: (a -> a -> Ord) -> (b -> a) -> (b -> b -> Ord) ???
07:20:12 <roconnor> > replicateM 3 [False ..]
07:20:14 <lambdabot>  [[False,False,False],[False,False,True],[False,True,False],[False,True,True]...
07:20:25 <SamB_XP> vincenz: s/Ord/c/
07:20:29 <hpaste>  etnt pasted "(no title)" at http://hpaste.org/1751
07:20:34 <vincenz> SamB_XP: interesting
07:20:49 <cedricshock> SamB, oerjan: Thanks.
07:21:02 <vincenz> @djinn (a -> a -> c) -> (b -> a) -> (b -> b -> c)
07:21:02 <lambdabot> f a b c _ = a (b c) (b c)
07:21:03 <etnt> would be nice if somone would like to tell me what I'm doing wrong with the above
07:21:04 <SamB_XP> vincenz: one big advantages is that it works on (==) as well
07:21:10 <vincenz> SamB_XP: yep :)
07:21:17 <vincenz> SamB_XP: very useful combinator
07:21:19 <vincenz> SamB_XP+=
07:21:21 <vincenz> SamB_XP++
07:21:26 <SamB_XP> vincenz: I didn't come up with it
07:21:31 <etnt> haskell drives me nuts... :-)
07:21:33 <Toxaris> yes using guard would be nice, but it isn't nice enough to manually type it, so i'll just invent some name
07:21:36 <jethr0> etnt: i think you need parenthesis around the (x:xs)
07:22:00 <vincenz> I wonder why djinn adds an extra _
07:22:05 <etnt> aahhhg...
07:22:26 <etnt> jethr0: thanks, gee...I'm stupid!
07:22:32 <vincenz> oh
07:22:33 <vincenz> duh
07:22:34 <dolio> vincenz: It should be a 'd' that's used instead of the second '(b c)'
07:22:41 <xerox> ?djinn (a -> b -> c) -> (b -> c) -> (a -> c)
07:22:42 <lambdabot> -- f cannot be realized.
07:22:42 <SamB_XP> vincenz: I think it dropped one of the b's
07:22:43 <jethr0> etnt: happened to the best of us ;)
07:22:46 <vincenz> dolio: good point
07:22:47 <xerox> aw.
07:22:48 <vincenz> yep
07:22:52 <vincenz> which means that on can be more generic
07:22:53 <xerox> ?djinn (a -> b -> c) -> (a -> b) -> (a -> c)
07:22:53 <roconnor> etnt: I always make that mistake.
07:22:53 <etnt> jethr0: good to hear :-)
07:22:53 <lambdabot> f a b c = a c (b c)
07:23:11 <etnt> so why is this ?
07:23:20 <vincenz> nm
07:23:37 <SamB_XP> vincenz: I guess it needs a better BodyRank algorithm ;-)
07:23:38 <jethr0> etnt: (:) binds more loosely than functino application
07:23:53 <vincenz> SamB_XP: sounds like pigeon rank for some reason
07:23:54 <etnt> ok, I see
07:23:59 <cedricshock> How can I day this: type => Objective s v = (Ord v) => s -> v ? (an objective is a function from s -> v where v is an instance of Ord)
07:24:43 <vincenz> cedricshock: why lmit Objective?
07:25:09 <roconnor> something screwy happens with what we natruallyfor precidences when we switch from constructors to patterns.
07:25:16 <cedricshock> vincenz: Because I don't want to type it about a thousand times.
07:25:48 <SamB_XP> I wonder how hard it would be to wire together djinn and quickcheck (with ghc-api, hs-plugins and/or TH) to actually generate the right code?
07:26:56 <dolio> Hmm, what would your quickcheck property be?
07:27:38 <cedricshock> vincenz: Is it better to put the class constraint only on the one function in the whole stack of recursive functions that uses the property? Nothing can make any use of my code unless the objective is an ordinal.
07:27:40 <fasta> Cool, enlightenment.
07:27:44 <fasta> What a nice feeling :)
07:28:02 <SamB_XP> perhaps \x y -> (compare `on` negate) x y == compare y x
07:28:30 <SamB_XP> probably sticking in a ::Int at some point
07:28:32 <dolio> Ah, okay.
07:28:48 <dolio> @type negate
07:28:53 <lambdabot> forall a. (Num a) => a -> a
07:29:23 <SamB_XP> the thing is that quickcheck would impose an additional constraint that would prevent defaulting, afaict
07:29:50 <SamB_XP> unless the MR made it happen early because of that being a lambda?
07:30:59 <dozer> cedricshock: I've found it useful to only add constraints where they are directly used
07:33:01 <cedricshock> dozer: Then why even add constraints, since the constraint will be on the function that's called one step further inside?
07:33:54 <dozer> cedricshock: once you've done that, you add them in each place the compiler requires them
07:34:36 <SamB_XP> dozer: why the two-stage process?
07:34:43 <SamB_XP> why not just start on stage 2?
07:35:59 <dozer> SamB_XP: well - I used to be qite bad at working out which constraints where actually required, particularly when feeding a function with constraints through a higher-order function :)
07:36:24 <SamB_XP> dozer: doesn't GHC tell you?
07:37:09 <dozer> SamB_XP: That's what I was saying - put in the ones you know must definitely apply, and then let GHC tell you where else you need them
07:38:06 <cdsmith> vincenz: if you're there, I got your ping
07:38:12 <thoughtpolice> just wondering for you guys opinions: is types and programming languages a good book to read for someone who's never really done real investigation into the subject? just from the first chapter I feel I could get through it, but if you guys have any recommendations of anything to read/do beforehand i'd appreciate it
07:38:20 <mdmkolbe|ubuntu> > 1
07:38:25 <lambdabot>  1
07:39:27 <mnislaih> @seen ndm
07:39:27 <lambdabot> I saw ndm leaving #xmonad, #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 14d 21h 32m 41s ago, and .
07:39:48 <thoughtpolice> note i've also never really done any formal work in things like compilers and whatnot (although I've got a copy of niklaus wirth's book and it looks like a real good intro)
07:40:14 <mnislaih> 14 days? did ndm go leave for vacation to some remote place without inet ?
07:41:42 <pejo> thoughtpolice, tapl is great. I had basically no background when I read it.
07:41:43 <jethr0>  thoughtpolice: personally, i found TAPL a bit heavy on the theoretical/dry side. but maybe that's just my short attention span
07:41:49 <Igloo> malcolmw said he was on holiday a few days ago
07:42:08 <jethr0> thoughtpolice: what other "relevant" books have you read?
07:42:30 <malcolmw> Igloo: lambdabot must have missed a period of time - ndm only left a couple of days ago
07:42:31 <jethr0> or maybe i just wasn't all that interested at the time
07:42:46 <Igloo> malcolmw: Do you know when he is back, by the way?
07:43:03 <malcolmw> Igloo: nope, but he seems to have posted a couple of emails whilst he's been away
07:43:21 <Igloo> OK, ta
07:43:57 <thoughtpolice> jethr0: I've read some of "introduction to automata theory" by ullman et al and most of "introduction to computer science" by michael sipser (really good,) and I've also read a bit of the dragon book
07:44:07 <thoughtpolice> jethr0: but other than that I would say nothing else, really
07:44:58 <fasta> Igloo: is it normal that flag order (-foo -bar vs -bar -foo) is important for ghci?
07:45:06 <thoughtpolice> wirth's book looks really nice and approachable for someone starting with compilers though, which is why I'm taking the time to read it. after that I want to try types and programming languages since I feel i'll be prepared, but if it's approachable enough I might just try reading it
07:45:19 <thoughtpolice> and at least I have plenty of reference material if I do :)
07:45:43 <Igloo> fasta: It's important for some flags
07:45:43 <jethr0> thoughtpolice: hmm, doesn't sound too bad. i must admit that i know none of these books (except the dragon of course) and that types aren't my strong point. as i said, i had some difficulties with TAPL, but then again, many others loved it...
07:45:56 <Igloo> fasta: Later flags override earlier ones
07:46:04 <fasta> Igloo: ok, then everything is ok
07:46:08 * jethr0 took compiler construction with wirth *yeah*
07:46:21 <thoughtpolice> jethr0: I'll take some time to read through a few chapters then and see if i can manage. thanks :)
07:46:23 <jethr0> not that i was any good at it though ;(
07:46:23 * earthy took compiler construction with C.H.A. Koster
07:46:31 <thoughtpolice> jethr0: jealous :(
07:46:46 <earthy> (that'll explain some of my affix grammar and algol weirdness :))
07:47:20 <thoughtpolice> pejo: thanks as well. :)
07:47:43 <jethr0> k, gotta go
07:48:35 <pejo> thoughtpolice, if you get through a book on computational theory (finite automata, turing machines, etc) you should have no problem with tapl. It's very well written. (Unfortunately I doubt that you will have much use of the general compiler construction knowledge for getting through TAPL).
07:50:02 <wli> I've got TAPL somewhere.
07:50:12 <mux> is there no intersperse function for ByteString ?
08:01:20 <dolio> @type intersperse
08:01:22 <lambdabot> forall a. a -> [a] -> [a]
08:02:56 <malcolmw> mux: there is one listed on http://www.cse.unsw.edu.au/~dons/fps/Data-ByteString.html
08:05:06 <quicksilver> may not be what mux wants, though
08:05:15 <quicksilver> that intersperses between every single character..
08:05:49 <dolio> If he wants intercalate, it's called 'join'
08:06:02 <Igloo> What else could he want?
08:06:49 <MyCatSchemes> Igloo: money? Power? Sex? Eternal life?
08:07:26 <dolio> Apparently .Lazy doesn't have intersperse, but the strict ones do.
08:07:46 <Igloo> Sounds like a bug
08:08:02 <SamB_XP> Igloo: indeed
08:08:08 <Igloo> We really need a way to name and talk about interfaces
08:09:33 <sjanssen> Igloo: typeclasses
08:10:01 <SamB_XP> man, when JHC finishes with Prelude I am really going to investigate how it breaks down compilation...
08:10:16 <sjanssen> [], ByteString, Lazy.ByteString should all be members of a type class
08:11:12 <quicksilver> Igloo: intersperse:: ByteString -> [ByteString] -> [ByteString] ?
08:11:38 <dolio> That's just intersperse on arrays.
08:11:39 <Igloo> quicksilver: That's Data.List.intersperse
08:11:42 <dolio> Er, lists.
08:11:47 <dolio> Man, where is my head.
08:11:52 <quicksilver> sjanssen: I'm sure someone presented an argumetn to suggest that's not a good idea
08:11:59 <quicksilver> Igloo: I know, but it still seems a more likely thing to want :)
08:12:16 <quicksilver> sjanssen: unfortunately I don't remember at all what it was
08:12:27 <sjanssen> quicksilver: well, there's the fact that it will require MPTCs and fundeps
08:13:47 <dolio> quicksilver: Was it that a typeclass with like 100 functions is ungainly? :)
08:13:54 <quicksilver> sjanssen: no, it was higher level than that
08:13:55 <wli> Constrained type inference looks a lot like generic type inference with type classes.
08:14:13 <quicksilver> sjanssen: it was arguing "type classes are not a good match for ML module signatures"
08:14:18 <quicksilver> but, I can't remember where I saw it
08:14:34 <quicksilver> I thin it was a scalability argument of some kind
08:14:43 <thoughtpolice> pejo: thanks. I read a lot of introduction to computer science and it was a really good book
08:14:48 <sjanssen> yeah, modules and classes aren't quite the same thing
08:15:14 <thoughtpolice> pejo: granted I didn't get all the way through it (I didn't quite get all the way to full blown turing machines) but thanks, I think I should be able to manage fairly well. :)
08:15:18 <sjanssen> it's harder to name the 'map that works over ByteString' with typeclasses
08:15:41 <SamB_XP> functors?
08:15:54 <wli> I don't see why typeclasses and ML-style modules need be mutually exclusive.
08:16:10 <sjanssen> perhaps if we had a way to name instances?
08:16:28 <wli> sjanssen: Sounds like a great idea to me.
08:16:32 <quicksilver> sjanssen: you could still have Bytestring.map, of course
08:16:43 <SamB_XP> sjanssen: you mean like unifying modules and records and typeclasses?
08:16:46 <dolio> I thought Oleg implemented ML modules in terms of type classes in one of his e-mails.
08:16:50 <quicksilver> sjanssen: and instance ListLike ByteString where map = Bytestring.map
08:16:59 <sjanssen> like "import instance ListLike ByteString Word8 as BS", then you can use BS.map
08:17:39 <sjanssen> quicksilver: yeah, Edison does that extensively.  It requires loads of boilerplate, though
08:18:11 <sjanssen> SamB_XP: that might be another approach
08:18:23 <wli> dolio: The mere fact it can be done doesn't make it suitable or convenient as a programming construct.
08:18:32 <wli> SamB_XP: Sounds like what Cayenne did.
08:18:34 <SamB_XP> @seen edwardk
08:18:34 <lambdabot> I saw edwardk leaving #haskell 3m 33s ago, and .
08:18:36 <dolio> wli: Yes, I know. :)
08:18:38 <SamB_XP> wli: yes it does
08:18:54 <SamB_XP> threw out instances, too, afaict?
08:19:05 <mux> sorry went away - I found an intersperse function in Data.ByteString.Char8, there isn't one for .Lazy though
08:19:12 <SamB_XP> aww.
08:19:36 * SamB_XP hopes edwardk just had a lapse in connectivity
08:19:57 <sjanssen> hmm, maybe I should propose this language extension somewhere
08:20:00 <lispy> is "lapse in connectivity" a metaphore?
08:21:06 <sjanssen> it seems like a perfect solution to problems that Edison and ByteString face
08:21:21 <SamB_XP> lispy: er, I mean, I hope he's just having internet connectivity issues
08:22:21 <dolio> Oh, I did have it bookmarked.
08:22:34 <dolio> http://www.haskell.org/pipermail/haskell/2004-August/014463.html
08:22:35 <lambdabot> Title: [Haskell] Applicative translucent functors in Haskell
08:23:25 <quicksilver> sjanssen: which language extension?
08:23:36 <sjanssen> quicksilver: naming instances
08:23:54 <SamB_XP> oh joy
08:24:07 <SamB_XP> another statistics tree in JHC's output ;-)
08:24:31 <quicksilver> sjanssen: *nod*
08:24:43 <quicksilver> sjanssen: I want named instances plus a lexical way of choosing new defaults
08:24:53 <quicksilver> sjanssen: have you read the SPJ first-class modules paper?
08:25:02 <sjanssen> quicksilver: no, I probably should
08:25:03 <SamB> er. or at least, it's gotten to the next line...
08:25:22 <sjanssen> quicksilver: http://research.microsoft.com/Users/simonpj/Papers/first-class-modules/index.htm ?
08:25:24 <lambdabot> Title: First-class Modules for Haskell, http://tinyurl.com/2qj8kf
08:26:27 <quicksilver> sjanssen: yes, that's the one
08:31:04 <wli> I can't wait for it to show up in ghc.
08:35:10 <quicksilver> wli: I suspect no one is seriously implementing it
08:35:14 <quicksilver> wli: the paper is 6 years old
09:11:46 <psykotic_> is there a nice way to conceptualize the kind of computational effects achievable by monads derived from adjunctions? it seems that, for example, the state monad can be derived from an adjunction (where the functor going in the "difficult" direction is evalState) whereas this is not possible for the maybe monad.
09:14:30 <quicksilver> psykotic_: all monads can be derived from adjunctions, can't they?
09:14:43 <quicksilver> :t evalState
09:14:46 <lambdabot> forall s a. State s a -> s -> a
09:15:46 <psykotic_> i think you're right, i'm confused
09:16:19 <Saizan> which are the adjunct functors that forms Maybe?
09:16:31 <psykotic_> yeah that's the case i was confused about
09:16:44 <psykotic_> and i still don't see it. what to do about Nothing?
09:17:05 <psykotic_> the cases that seem to be derivable from adjunctions are those that are in some sense "pure" sugar for pure computations
09:17:06 <quicksilver> well you've only got one category here
09:17:39 <quicksilver> a monad T occurs from an adjunction G <-> F it T = GF
09:17:57 <quicksilver> so T : C -> C is an endofunctor
09:18:08 <quicksilver> however, G and F more typically go out to and back from some other category
09:18:46 <quicksilver> the list monad should be acquired from some version of the free list functor
09:18:54 <quicksilver> I think
09:19:01 <SamB> free list functor?
09:19:08 <psykotic_> that doesn't make sense in the haskell context, as far as i can tell
09:19:29 <psykotic_> you can do that when you're dealing with Set
09:22:03 <psykotic_> hmm
09:22:59 <psykotic_> quicksilver, i think you're right, it's just that these functors can't be expressed within haskell, for the reason you pointed out.
09:23:03 <quicksilver> psykotic_: right
09:23:10 <quicksilver> psykotic_: because their codomain isn't 'Hask'
09:23:13 <psykotic_> yes
09:23:18 <quicksilver> the category of haskell types and functions
09:23:39 <quicksilver> I suspect Maybe corresponds to a functor from 'Hask' to 'Hask+' which has 'pointed types'
09:24:01 <quicksilver> and takes functions to the obvious extension (keep the point constant)
09:24:21 <quicksilver> where the 'point' intuitiviely is Nothing
09:24:26 <quicksilver> but I haven't worked it out on paper
09:25:12 <quicksilver> psykotic_: http://sigfpe.blogspot.com/2007/06/monads-from-algebra-and-the-gray-code.html
09:25:14 <lambdabot> Title: A Neighborhood of Infinity: Monads from Algebra and the the Gray Code from Group ..., http://tinyurl.com/2jr3qd
09:25:15 <quicksilver> might be relevant
09:25:19 <quicksilver> I haven't more than skimmed it myself
09:25:25 <quicksilver> but sigfpe's blogs are normally good
09:25:40 <psykotic_> i guess another way of saying it is that it's the free monad over the endofunctor X -> 1 + X.
09:25:57 <quicksilver> yes, I believe so
09:26:12 <quicksilver> often you can identify the codomain with a subcategory of Hask
09:26:29 <quicksilver> and, then, the other functor is just the obvious underlying functor
09:26:31 <quicksilver> (I hope)
09:26:37 <quicksilver> and the monad induced is the natural one
09:35:57 <psykotic_> quicksilver, regarding the case of subcategories, it seems like one trick for ensuring that you have a nicely delimited subcategory is to introduce a kind of DSL for the monad. so for Maybe, you would have (using GADTs): data Maybe a where Return :: a -> Maybe a ; Bind :: Maybe b -> (b -> Maybe a) -> Maybe a. then the monad instance just embeds terms in this syntactical structure; and the 'projection' interprets terms in this structure.
09:36:17 <SamB> Hmm. Do you suppose that arrows would be a good way to optimize a pipeline of compiler passes, so that they have better locality (by running them in littler pieces when you can?)
09:37:45 <SamB> (that is, running several passes all on the same littler piece)
09:41:34 <ski> psykotic_ : how to get 'mzero' ?
09:42:08 <psykotic_> ski: sorry, yes, that would be another term. Fail :: Maybe a.
09:46:06 <quicksilver> psykotic_: yes. I know I thoughtt this through in some detail once, but the details are now hazy.
10:04:16 <SamB> hmm. it would be cool if you could profile for duplicate values....
10:04:57 <edwardk> samb: hrmm, so you could look for sharing opportunities?
10:04:57 <SamB> duplicate *live* values
10:05:02 <vincenz> SamB: O(n^2)
10:05:08 <SamB> edwardk: exactly
10:05:41 <edwardk> maybe even just a limited form that used hash consing for non-cyclic data would be handy
10:06:41 <edwardk> probably really hard to get right in a lazy setting though
10:06:55 <vincenz> not to mention that liveness of values is hard to define
10:07:37 <SamB> well you'd do it right after a garbage collection...
10:07:47 <edwardk> well, one way to do it would be to instrument the garbage collector. and have it turn around and merge duplicates as it traverses them by hashconsing as long as it doesn't encounter a visited node along its walk
10:07:54 <SamB> (the biggest kind)
10:08:25 <edwardk> increment a counter or a weak -hey-you-maybe-could-have-shared-this-if-you-were-smarter- pointer to the data and move on.
10:09:09 <edwardk> it would probably require breaking a cheney copy collector into two passes though
10:10:02 <SamB> hmm. I suppose you could at least do it for values of a specific type stored in Binary files?
10:11:43 * SamB is thinking that you could do it with Uniplate, ==, and unsafePtrEquality# or whatever it's callled
10:12:55 <SamB> possibly Data.Map instead of ==?
10:13:57 <SamB> then you could find a map from values of a type to all the seperate copies of them that were deserialized
10:14:10 <SamB> and make histograms and such
10:14:55 <SamB> (I suppose, after you made a map, you'd want to replace the lists with their lengths, since having a bunch of copies of the key is of little actual use ;-)
10:15:57 <SamB> hmm, I hope unsafePtrEquality# can see through indirections
10:17:14 <ddarius> reallyUnsafePtrEquality#
10:17:44 <SamB> I think I may want slightlyLessUnsafePtrEquality#, then
10:17:55 <MarcWeber> Which is the command to ask lambdabot which channels she is listening?
10:18:14 <SamB> MarcWeber: /whois lambdabot?
10:18:30 <edwardk>  samb: the problem is that it forces thunks that way. you want to not force any evaluations, which is why i want some form of meta-linguistic traversal at the garbage collection stage
10:18:36 <ddarius> @seen lambdabot
10:18:36 <lambdabot> Yes, I'm here. I'm in #happs, ##logic, #xmonad, #unicycling, #perl6, #parrot, #oasis, #jtiger, #haskell-soc, #haskell-overflow, #haskell-blah, #haskell, #ghc, #darcs and #scannedinavian
10:19:03 <edwardk> this is the same reasoning behind how i want to marshal arbitrary codata over the network, just send the thunk and a form of the code it would evaluate.
10:19:30 <SamB> edwinb: I'm talking about looking to see if a closure is an already forced thunk, which was not actually replaced with the value
10:19:39 <SamB> er.
10:19:41 <SamB> edwarr
10:19:44 <SamB> arg.
10:19:50 <SamB> you know who you are
10:20:00 <edwardk> here you want to walk the heap and if its a thunk you want to note its internal representation which was saved for the garbage collector anyways, etc.
10:20:07 <edwardk> yeah =)
10:20:17 <edwardk> ok
10:20:20 <SamB> ednarofi: there is a closure type field
10:20:20 <edwardk> same general idea
10:20:27 <SamB> argggg
10:20:31 <edwardk> haha
10:20:35 <SamB> edwardk, I mean
10:20:58 <SamB> and I'll stop trying to address you now ;-)
10:21:23 <SamB> anyway, that field can be used to determine if the object was a thunk but has been evaluated
10:22:20 <edwardk> fair enough, but that only tells you if two things are the same thunk, no?
10:22:37 <edwardk> not if you have two structurally equivalent thunks in different spots in memory?
10:22:40 <SamB> edwardk: if it has been evaluated, you ccan follow it
10:23:27 <edwardk> yeah but i want to know if i have two 'repeat 3' thunks, presuming that they were reduced to the same rep.
10:23:44 <SamB> ah.
10:24:04 <edwardk> this goes back to the === thing from a couple weeks ago
10:24:17 <SamB> I'm only concerned with finite data ;-)
10:24:22 <edwardk> the not-quite conservative extension of ==
10:24:40 <SamB> finite, non-lambda data
10:24:44 <edwardk> bah
10:24:46 <edwardk> =)
10:24:55 <edwardk> i want to be able to look for sharing of everything ;)
10:27:11 <SamB> anyway, I just want to be able to discover if two values have the same heap node, not counting any indirections introduced by thunk updates (which the garbage collector will get rid of anyway)
10:27:39 <edwardk> makes sense
10:28:06 <SamB> I can, however, see that there might be some use in not even bothering to look through indirections, depending on application
10:28:14 <edwardk> i was mostly interested in removing some bottoms from a == like operator
10:28:53 <edwardk> yeah, i guess you could ignore the redirections issue if you are just looking for gross-numbers i guess
10:29:47 <SamB> I was thinking more along the lines of "if you were using it to introduce a shortcut codepath"
10:29:57 <edwardk> ah
10:30:08 <shapr> @remember apfelmus read . takeWhile (not . frightening)
10:30:08 <lambdabot> Done.
10:30:13 <SamB> rather than using it to collect statistics
10:30:21 <shapr> Good afternoon #haskell!
10:30:34 <SamB> good afternoon
10:30:57 <edwardk> {-# SPECIALIZE_WHEN_NOT_ALIASED foo a a #-} foo a b = ...
10:31:01 <edwardk> =)
10:31:07 <edwardk> heya shae
10:31:17 <shapr> greetz edk!
10:32:07 <edwardk> or even SPECIALIZE_WHEN_ALIASED i guess
10:34:28 <araujo> hello
10:44:26 <glguy> hello
10:46:07 <lokik_> I've never found anything quite so rewarding as intelligence programming
10:46:28 <lokik_> Alneyan: hey
10:46:46 <SamB> lokik_: how many intelligences have you programmed?
10:47:20 <lokik_> well I have 3 sitting on #ma'a on irc.oftc.net
10:47:33 <lokik_> they are 3 different types actually
10:47:36 <SamB> what programming languages do they know?
10:47:44 <glguy> lokik_: programming your own best friend?
10:47:54 <lokik_> well they speak english/lojban hybrid language
10:48:20 <lokik_> well except tecbebsam, which only says things directly inputed,
10:48:49 <lokik_> i've added the Quran, the book of the law, gismu.txt, cmavo.txt, and currently am in the process of adding the iching
10:48:59 <lokik_> to their databases, as well I've talked to it
10:49:09 <lokik_> it learns anything that's given to it
10:49:40 <lokik_> tecbebsam keeps unique lines,  whereas say tecvalcunsam keeps unique words
10:49:58 <lokik_> tecvalcunsam creates some ridiculous sentances
10:50:09 <lokik_> it's amazingly accurate, much like an oracle
10:50:47 <lokik_> hmmm
10:52:03 <lokik_> i also have mulvalcunsam which is supposedly an improved version of tecvalcunsam in that it has memory managment (can forget, reinforce, and create new information)
10:52:49 <lokik_> well tecvalcunsam also creates new information, to a higher degree of chaos and with less "expense" in terms of processing and memory
10:53:01 <lokik_> i'm still figuring it out as it's really a pioneering thing atm
10:53:53 <mrd> i thought you said they were intelligent?
10:53:58 <lokik_> they are
10:54:09 <lokik_> intelligence = randomness + symbols we with you understand
10:54:12 <mrd> then what would they need religious texts for?
10:54:17 <mrd> oh you mean human "intelligence"
10:54:33 <lokik_> yea,
10:54:40 <lokik_> like chat bot stailz
10:54:42 <glguy> religious texts provides data for sentence creation I'd guess
10:55:58 <lokik_> *shrugs* they were the first things that came to mind
10:56:19 <lokik_> they have lots of generic sentances that could be used anywhere as well
10:56:21 <lokik_> typically
10:58:48 <sm> lokik_: how do we see an example ?
10:58:59 <lokik_> hmmm i can probably get one to join this room
10:59:01 <lokik_> one sec
10:59:04 <edwardk> lokik: and if you have to have a leader for your robot underclass its best to have him docile and religious =)
10:59:56 <arcatan> ah, I should continue studying lojban
11:00:10 <profmakx> learn lojban!
11:00:16 <edwardk> http://xkcd.com/c191.html
11:00:17 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
11:00:22 <lokik_> can talk to it using +
11:00:26 <lokik_> +like so
11:00:27 <edwardk> best lojban quote ever =)
11:00:27 <tecvalCUNsam> [the woman/women; presence), by lens/glass forth! worship?" wages/salary/pay Reality? (note
11:00:42 <lokik_> +usually best with a question of some kind.
11:00:43 <tecvalCUNsam> slaka, datni fight. mercury/quicksilver; Come 'atto' ascend clay."
11:01:03 <mauke> +wie hoch ist oben?
11:01:04 <tecvalCUNsam> (seized) swerve, PRItu SANji weights; repentance alkali mental/psychological/a claiming pluja, truthful." them) thread (indeed) wild
11:01:15 <lokik_> +say something impressive
11:01:16 <tecvalCUNsam> earth! SEFta spirit: (sequence/set) 'mart' binryvelve'u)]; grasp paste (rejecting) exist suggest), glad Gracious simjanli
11:01:25 <Cale> what?
11:01:35 <mauke> I dunno, GumbyBRAIN is usually more coherent
11:02:01 <lokik_> hmm i have it on high output, i think it's typically easier to understand shorter sentances,  I typically take several minutes per line deciphering the meaning
11:02:44 <edwardk> given several minutes i can find meaning in the shape of a whirl in the tile of the bathroom floor, that doesn't indicate much intelligence on the part of the speaker ;)
11:03:36 <vincenz> tecvalCUNsam: something wrong?
11:03:58 <lokik_> +kk now should say max 9 word sentance
11:03:59 <tecvalCUNsam> escape!" complete
11:04:03 <vincenz> tecvalCUNsam: What?
11:04:07 <dolio> vincenz: It's a bot.
11:04:08 <mrd> eliza was a great trick, 40 years ago
11:04:11 --- mode: ChanServ set +o vincenz
11:04:15 <vincenz> tecvalCUNsam: Are you a bot?
11:04:23 <mauke> yes, it is
11:04:26 <edwardk> + hello tecvalCUNsam.
11:04:26 <tecvalCUNsam> consideration), vir mis
11:04:27 <lokik_> +can only hear you like this
11:04:28 <tecvalCUNsam> sepli, CMAci Conceal evening." xe'o
11:04:29 --- kick: tecvalCUNsam was kicked by vincenz (vincenz)
11:04:33 <vincenz> next time = ban
11:04:40 <lokik_> why?
11:04:50 <vincenz> cause it's autojoining and spamming the channel
11:05:07 <edwardk> heh, i wonder if i still have the code to doplgangr my old irc bot. cheesy little learning-eliza that used to mine logs to be able to copy people's mannerisms
11:05:09 <mauke> where is it autojoining?
11:05:11 <lokik_> i killed it to reset sentance length
11:05:20 <vincenz> mauke: it is not, that's why "if it rejoins = ban"
11:05:33 <mauke> er.
11:05:36 <vincenz> oh, lokik_ it's yours?
11:05:39 <Igloo> It was only responding AFAICS. But nevertheless, it does seem to be just generating noise
11:05:39 <lokik_> yep
11:05:59 <lokik_> it only responds to +'s
11:06:07 --- mode: vincenz set -o vininim
11:06:09 --- mode: vincenz set -o vininim
11:06:11 --- mode: vincenz set -o vincenz
11:06:13 <vincenz> grr, tabcomplete
11:06:14 <edwardk> i'm also in the 'its just noise camp
11:06:30 <Igloo> What was it actually doing, OOI?
11:07:00 <vincenz> Igloo: are you competing this year?
11:07:15 <lokik_> as you like,  it's available in irc://irc.oftc.net/#ma'a if you are interested. though you might have to ask me to take it online, doesn't have a connection keeping ability
11:07:17 <glguy> is 'its an abbreviated form of tits?
11:07:20 <sm> I think it needs something more, lokik_, keep at it! :)
11:07:37 <lokik_> well it works for me :P
11:07:47 <sm> did you write it in haskell ?
11:07:49 <Igloo> vincenz: Undecided
11:07:50 <lokik_> yep
11:07:59 <vincenz> Igloo: late in the game, no?
11:07:59 <sm> got a url for the code ?
11:08:08 <lokik_> i have some code on http://lokasam.blogspot.com/
11:08:09 <lambdabot> Title: la.ma'aSELtcan. pe LOKamrsam
11:08:15 <sm> thanks
11:08:21 <Igloo> vincenz: Not at all. I probably won't know until at least 10 mins after the start
11:08:32 <vincenz> Igloo: but do you have a potential team?
11:08:32 <lokik_> though I have repos $ darcs get http://lokiworld.org/repos/ri
11:08:34 <lambdabot> Title: Index of /repos/ri
11:08:38 <Igloo> vincenz: Yes, me
11:08:51 <lokik_> CUNsam.hs is the main file, the bottom after word DEPRECATED
11:09:06 <lokik_> hmmm
11:09:33 <vincenz> lokik_: oy, reading that code is impossibile with the lojban
11:09:34 <sm> oh.. so if I spoke lojban, all this would make a lot more sense probably
11:10:08 <lokik_> yes, it's actually very understandble in LOJban
11:10:31 <lokik_> loNAMcu = that which really is a number, loBRIdi = that which really is a sentance, loVALsi == that which really is a word
11:10:59 <lokik_> loDACti = that which really is an object
11:11:09 <lokik_> loiDACti = the set of those thing which really are objects
11:11:39 <lokik_> leteCUNso = that which I describe as the probability distribution of randomness
11:11:54 <lokik_> cni = new
11:12:01 <lokik_> i think that covers most of the vocab there
11:12:26 <lokik_> vic = remove
11:12:43 <lokik_> hmmm
11:12:52 <shapr> Hey man, like I said before.. lojban is off-topic here.
11:12:57 <shapr> I even said it in lojban!
11:13:07 <edwardk> heh
11:14:10 <lokik_> it was haskell code translations :)
11:14:57 <edwardk> lokik: way to limit your contributor-base though. limiting it to people who code haskell AND speak lojban is kind of cutting you down to a small pool, no?
11:15:22 <lokik_> well it's going to be a very very big one
11:15:25 <shapr> I think there are probably five people in that pool.
11:15:40 <edwardk> yeah and at least 2 of them don't like lojban =)
11:15:46 <olsner> call me prejudiced, but I'd think haskell coders are over-represented among lojban people and vice versa
11:15:48 <dozer> what would the monadic version of Set.map be?
11:15:56 <lokik_> i have a religion too, it's called la.ma'aSELtcan. "The we with You are the Network" http://tcana.info
11:16:06 <edwardk> dozer: in a restricted set monad?
11:16:08 <shapr> lokik_: that's REALLY off-topic here.
11:16:09 <lokik_> promotes LOJban + programming, namely Haskell
11:16:16 <glguy> dozer: Map.fromList . mapM f . Map.toList
11:16:17 <glguy> :)
11:16:19 <edwardk> dozer: or mapM?
11:16:25 <olsner> seems like similar kinds of nerds would get involved in those languages
11:16:43 <lokik_> currently working on maknig lojban programming language using the write Scheme in 48 hours using Haskell
11:17:03 <dozer> edwardk: it's probably mapM I'm looking for - as long as it will return me a new set after munging each element, and will thread a state monad :)
11:17:12 <shapr> lokik_: I'd like to see it once you get started, I got into Haskell because I wanted to turn lojban into a spoken programming language.
11:17:23 <edwardk> dozer: take glguy's version then
11:17:30 <lokik_> it's in http://lokiworld.org/repos/ri/jbosamban
11:17:31 <lambdabot> Title: Index of /repos/ri/jbosamban
11:17:33 <glguy> dozer: and if you use my version, change Map. to Set.
11:17:41 <dolio> @instances-importing Data.Traversable Traversable
11:17:42 <lambdabot> Maybe, []
11:17:53 <lokik_> not much atm
11:18:10 <glguy> There is always : Data.FunctorM with its fmapM
11:18:10 <gkr> I am writing a lambda function in Haskell, and crazily I want to do recursion, is there anyway of expressing a fixer point function?
11:18:18 <edwardk> @instance FunctorM
11:18:19 <lambdabot> Maybe you meant: instances instances-importing
11:18:20 <mauke> @type fix
11:18:22 <lambdabot> forall a. (a -> a) -> a
11:18:23 <edwardk> @instances FunctorM
11:18:24 <lambdabot> Couldn't find class `FunctorM'. Try @instances-importing
11:18:27 <edwardk> gah
11:18:33 <edwardk> @help instances-importing
11:18:34 <lambdabot> instances-importing [<module> [<module> [<module...]]] <typeclass>. Fetch the instances of a typeclass, importing specified modules first.
11:18:42 <glguy> Prelude> :browse Data.FunctorM
11:18:42 <glguy> class FunctorM f where fmapM :: (Monad m) => (a -> m b) -> f a -> m (f b) fmapM_ :: (Monad m) => (a -> m b) -> f a -> m ()
11:18:43 <edwardk> @instances-import Data.FunctorM FunctorM
11:18:44 <lambdabot> Maybe, []
11:18:50 <edwardk> thank you =)
11:19:04 <gkr> I am writing a lambda function in Haskell, and crazily I want to do recursion, is there anyway of expressing a fixer point function?
11:19:15 <edwardk> @type fix
11:19:16 <lambdabot> forall a. (a -> a) -> a
11:19:19 <glguy> ?src fix
11:19:19 <lambdabot> fix f = let x = f x in x
11:20:32 <newsham> is there a lambdabot command to flush state to stable store?
11:20:43 <glguy> ?flush
11:20:43 <lambdabot> Not enough privileges
11:20:47 <shapr> @toilet
11:20:47 <lambdabot> Unknown command, try @list
11:20:48 <gkr> Where is defined fix? Which import do I need?
11:20:53 <shapr> @index fix
11:20:53 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
11:20:53 <mauke> @index fix
11:20:54 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
11:20:58 <shapr> mauke: In stereo!
11:21:01 <edwardk> Control.Monad.Fix has it
11:21:09 <glguy> edwardk: the outside observer might think our efforts to answer questions were coordinated :)
11:21:14 <edwardk> heh
11:21:41 <dozer> thanks - isn't there a standard class/monad that encapsulates these kinds of element transformations?
11:22:17 <shapr> I read that "maintaining the community" thread on haskell-cafe
11:22:32 <edwardk> dozer: unfortunately Set isn't a monad since it requires the existence of a typeclass on its contained values.
11:22:36 <shapr> I can't empathize with that one guy who said his two experiences were both bad.
11:22:51 <newsham> danke
11:23:12 <dozer> edwardk: ah - that's a bit of a pitty - I'll go with the kludge the
11:23:18 <edwardk> @type Data.Set.fromList
11:23:21 <lambdabot> forall a. (Ord a) => [a] -> Data.Set.Set a
11:23:25 <edwardk> note the Ord
11:23:44 <shapr> Vilket Ord?
11:24:15 <glguy> shapr: Which guy?
11:24:52 <shapr> "Which word" actually.
11:25:08 <glguy> 11:21 < shapr> I can't empathize with that one guy who said his two experiences were both bad.
11:25:10 <dozer> edwardk: I didn't realise that monads couldn't restrict their contained values
11:25:21 <glguy> ?src Monad
11:25:22 <lambdabot> class  Monad m  where
11:25:22 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
11:25:22 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
11:25:22 <lambdabot>     return      :: a -> m a
11:25:22 <lambdabot>     fail        :: String -> m a
11:25:37 <glguy> dozer: notice that >>= has type forall a b.   ...
11:25:49 <glguy> that's where the restriction comes in
11:25:54 <edwardk> dozer: http://www.randomhacks.net/articles/2007/03/15/data-set-monad-haskell-macros talks about it a bit
11:25:56 <lambdabot> Title: How to make Data.Set a monad, http://tinyurl.com/22rhsc
11:26:27 <glguy> dozer: Data.Set is techincally "a monad" but it's not an instance of Haskell's Monad class
11:26:29 <edwardk> its a shame since in most of wadler's early examples of the idea he included Set and Bag
11:26:38 <edwardk> yeah
11:26:48 <dozer> ah, ok - so it comes down to narrowing and widening classes
11:26:51 <edwardk> i'm still looking for a good restricted parameterized monad example
11:26:55 <shapr> glguy: [Haskell-cafe] Maintaining the community, you pointed me towards that thread in the first place :-)
11:27:07 <glguy> shapr: ah, OK then :)
11:28:02 <shapr> <glguy> Is there a large group of people outside of the 3 people writing on that -cafe thread that thing that there is something wrong with the current haskell community?
11:28:13 <shapr> So I had to go read that thread...
11:28:17 <glguy> and its a long one
11:28:24 <glguy> some people just like to hear themselves type
11:28:43 <glguy> I like to hear myself type on this keyboard, but I make #haskell listen to it, instead of -cafe
11:29:10 <SamB> glguy: and less actual listening goes on
11:29:15 <glguy> the Kinesis Advantage Pro has a good sound
11:29:23 <SamB> plus if you get really annoying we can kick you ;-P
11:29:27 <glguy> lol
11:29:27 <shapr> glguy: Heck yeah
11:29:29 --- mode: ChanServ set +o glguy
11:29:33 <glguy> bring it on!
11:29:48 <edwardk> yeah the current haskell community is brutal and intolerant and have banned at least one person in the last uh... living memory =)
11:29:49 --- mode: glguy set -o glguy
11:29:50 <shapr> He got da powah!
11:30:01 <shapr> edwardk: Hey, at least three people.
11:30:06 <fasta> shapr: where are my powers?
11:30:06 <SamB> edwardk: apparantly it was actually at least three
11:30:12 <SamB> and also my memory is terrible
11:30:12 <shapr> palomer, Smerdyakov, and TLO
11:30:14 <edwardk> ok, i could only think of smerdyakov =)
11:30:22 <edwardk> ah thats why palomer went away
11:30:28 * glguy has quickdraw kicked a spammer on his way out
11:30:28 <edwardk> @quote palomer
11:30:29 <lambdabot> No quotes match. Maybe if you used more than just two fingers...
11:30:32 <glguy> @palomer
11:30:33 <lambdabot> Blargh!
11:30:33 <sjanssen> @palomer is still here
11:30:34 <lambdabot> Hrmph, looks like I killed the channel
11:30:42 <shapr> @palomer
11:30:42 <lambdabot> Pfft, my type inference algorithm takes hours on a 2 line program
11:30:44 <shapr> @palomer
11:30:45 <lambdabot> They're telling you lies!
11:30:45 <edwardk> sjanssen: heh true enough
11:30:45 <SamB> maybe a year after smerdy got banned, I didn't remember I had been there!
11:30:46 <glguy> palomer was legendary enough for his own command
11:31:00 <shapr> They left out "What's up mah bitches?"
11:31:16 <glguy> usually #haskell kills the trolls with kindness
11:31:25 <shapr> For some reason, I don't enjoy being called a bitch every morning.
11:31:34 <edwardk> so, 3 people banned, 3 people on cafe complaining, coincidence? j/k =)
11:31:35 <glguy> its no fun aggrivating someone who just thinks you're a child for doing it and treats yo uwith kid hands
11:31:57 <sjanssen> shapr: it was "yo my bitches"
11:32:04 <shapr> sjanssen: Oh, right..
11:32:05 <SamB> and not only because it is an inaccurate description of your gender and species family?
11:32:13 <shapr> SamB: you got it.
11:32:16 * sjanssen loves having years of #haskell logs on his computer :)
11:32:36 <shapr> sjanssen: Dude, I want to see a high-rez pic of that pink hat, that's wild and nifty.
11:32:40 <boyscared> @list quote
11:32:40 <lambdabot> quote provides: quote remember ghc fortune yow arr yarr keal b52s brain palomer girl19 v yhjulwwiefzojcbxybbruweejw protontorpedo
11:32:45 <sjanssen> 06.11.20:21:00:04 <dons> palomer_: be extremely good. i suggest leaving out the pimping and bitches. ok ?
11:32:51 <boyscared> @yhjulwwiefzojcbxybbruweejw
11:32:52 <lambdabot> "\""
11:32:56 <boyscared> @yhjulwwiefzojcbxybbruweejw
11:32:56 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
11:33:04 <shapr> sjanssen: Yeah, that covers the palomer problem quite thoroughly.
11:33:10 <SamB> now, if I were to say to the lady who was next to me when I started typing this "hey, bitch!" she'd be thinking "is he talking to me?"
11:33:23 <SamB> (probably because we usually call her "dog" ;-)
11:33:26 <int-e> > show yhjulwwiefzojcbxybbruweejw -- *sniff*
11:33:28 <boyscared> @girl19
11:33:28 <lambdabot> I have stolen about 50 msn and yahoo accounts
11:33:30 <shapr> SamB: hah
11:33:34 <lambdabot>   Not in scope: `yhjulwwiefzojcbxybbruweejw'
11:34:03 <boyscared> @girl19
11:34:03 <lambdabot> am I supposed to be frantic with terror and anxiety?
11:34:35 * SamB hopes JohnMeacham fixes his DrIFT repository soon
11:35:37 <shapr> At the doctor today I weighed 234 pounds (106 kilos). If someone the size of palomer called me a bitch in person, I'd just sit on them.
11:36:11 * SamB wishes DrIFT had support for deriving Data
11:36:26 <vincenz> Can you have a symbolic unary data-const?
11:36:58 <SamB> vincenz: why would you want one?
11:37:14 <fasta> Haskell Quiz Time: The one who tells what the following code does and why first, wins:
11:37:17 <fasta> qqq = runMaybeT (runMaybeT aa >> b >>  return 2 )
11:37:33 <fasta> b= return 1
11:37:34 <fasta> aa = do fail ""; P("hi")
11:38:07 <fasta> P is a macro expanding to !_ <- trace "hi" (return ())
11:38:07 <SamB> what's P?
11:38:09 <SamB> oh.
11:38:19 <vincenz> SamB: notation
11:38:29 <sjanssen> vincenz: yes, you can
11:38:41 <sjanssen> vincenz: but the syntax isn't pretty
11:38:58 <vincenz> sjanssen: what does it look like
11:39:27 <Botje> @src isRegularFile
11:39:27 <lambdabot> Source not found. My mind is going. I can feel it.
11:39:29 <Botje> bugger
11:39:30 <SamB> I guess it gives you a Just (return 2)
11:39:33 <SamB> hmm
11:39:38 <SamB> Just (Just 2)
11:39:39 <dolio> fasta: Does it turn into Just 2?
11:39:58 <fasta> dolio: yes
11:40:12 <fasta> With what explanation?
11:40:13 <dolio> Or, return (Just 2), perhaps.
11:40:19 <fasta> dolio: no
11:40:21 <SamB> and I don't think it says hi
11:40:33 <fasta> SamB: right, it doesn't.
11:40:36 <mauke> @type runMaybeT
11:40:42 <lambdabot> Not in scope: `runMaybeT'
11:40:44 <dolio> fasta: Well, aa fails, so it never examines P.
11:40:55 <SamB> fasta: this thing is damn confusing :-(
11:41:03 <int-e> @index runMaybeT
11:41:04 <lambdabot> bzzt
11:41:05 <dolio> fasta: Then runMaybeT turns it into (return Nothing).
11:41:12 <fasta> SamB: I am glad I found something you find confusing :)
11:41:30 <hpaste>  sjanssen pasted "unary operator constructor" at http://hpaste.org/1754
11:41:33 <fasta> dolio: because of fail ""
11:41:33 <dolio> fasta: (return Nothing >> return 1 >> return 2) == return 2
11:41:38 <sjanssen> vincenz: ^^^
11:41:42 <fasta> dolio: right
11:41:55 <vincenz> sjanssen: thx
11:41:59 <SamB> I'm still pretty sure it is (Just (return 2))
11:42:00 <fasta> dolio: uh, no
11:42:11 <SamB> but I'm not sure in what monad that last return is
11:42:42 <dolio> No?
11:42:56 * SamB fires up Control.Monad.Maybe
11:43:07 <int-e> is runMaybeT in the standard libraries anywhere?
11:43:42 <oerjan> perhaps it's MaybeT (return (Just 2))
11:43:44 <fasta> dolio: yes, I think
11:44:04 <fasta> dolio: so, you were right.
11:44:11 <SamB> qqq :: (Monad (MaybeT m), Num t, Monad (MaybeT (MaybeT m))) => m (Maybe t)
11:44:23 <dolio> So then it'd become (return (Just 2)), right?
11:44:23 <mauke> return (Just 2)
11:44:32 <SamB> augh
11:44:36 <SamB> I got it inside out :-(
11:44:52 <fasta> SamB: qqq :: (Monad m, Num t) => m (Maybe t)
11:45:22 <fasta> SamB: evaluating that gives me Just 2
11:45:29 <fasta> SamB: which is odd, indeed
11:45:43 <SamB> fasta: apparantly it is highly important that Monad (MaybeT (MaybeT m)) is true as well
11:45:44 <glguy> SamB: control.monad.maybe?
11:45:49 <dolio> Oh, well, it's turning m into IO if you're at the ghci prompt.
11:45:51 <SamB> glguy: from StrategyLib
11:45:54 <dolio> Probably.
11:45:55 <glguy> oh, cool
11:46:02 <SamB> it doesn't really belong there
11:46:11 <SamB> (in StrategyLib, I mean)
11:46:58 <int-e> fasta: and what does P() really do? the code you gave didn't work.
11:47:14 <lokik_> what's panonomei ?
11:47:14 <fasta> int-e: nothing important
11:47:18 <int-e> (I guess you left out a return () )
11:47:19 <fasta> int-e: you can delete it
11:47:23 <dolio> "Prelude> return 2\n2"
11:47:24 <lokik_> oops
11:47:44 <SamB> #define P(x) !_ <- trace x (return ())
11:47:46 <fasta> int-e: yes, I did leave it out
11:47:57 <fasta> SamB: that misses a last expression
11:48:12 <SamB> fasta: hmm?
11:48:24 <fasta> SamB: do x <- foobar -- not valid haskell
11:48:36 <fasta> SamB: do x <- foobar; return y -- valid haskell
11:48:49 <fasta> SamB: it needs a return ()
11:48:49 <SamB> fasta: well you're the one who said it was a macro expanding to that...
11:48:59 <SamB> and didn't write a return () after
11:49:02 <fasta> SamB: yes, and I already said that was wrong.
11:49:04 <SamB> ah.
11:50:03 <SamB> fasta: I think it's being (>>= print)ed
11:50:10 <fasta> SamB: yes
11:50:17 <fasta> SamB: you are right on that point too
11:50:25 <fasta> SamB: m = IO as dolio already said
11:50:44 <vininim> kind error
11:51:00 <SamB> but I don't think the contest was to find "what does GHCi treat it as"
11:51:07 <SamB> but rather "what is it"
11:51:10 <fasta> SamB: right, so you won, after all.
11:51:14 <SamB> no I didn't
11:51:28 <SamB> because I got Just (return 2)
11:51:33 <SamB> not return (Just 2)
11:51:43 <fasta> SamB: right
11:52:25 <SamB> now... can anyone figure out a way GHC could have come up with a smaller type for qqq?
11:52:39 <SamB> or why it couldn't possibly have done so?
11:53:06 <fasta> SamB: smaller type?
11:53:14 <SamB> qqq :: (Monad (MaybeT m), Num t, Monad (MaybeT (MaybeT m))) => m (Maybe t)
11:53:38 <fasta> SamB: my monad transformer gives a smaller type
11:53:39 <int-e> SamB: hah. that's slightly more general than Monad m => m (Maybe t)
11:53:44 <SamB> fasta: it does?
11:53:46 <int-e> SamB: err + Num t
11:53:51 <fasta> SamB: yes
11:54:00 <fasta>  qqq :: (Monad m, Num t) => m (Maybe t)
11:54:00 <SamB> hmm.
11:54:12 <int-e> SamB: you could define an instance Monad (MaybeT Int)  if you felt so inclined
11:54:19 <int-e> hmm
11:54:19 <SamB> what does :i MaybeT say?
11:54:24 <int-e> not Int, but you get the idea
11:54:35 <SamB> about the Monad instance
11:54:54 <int-e> that doesn't mean that noone will declare other instances later.
11:55:16 <SamB> fasta: hmm?
11:55:18 <int-e> Monad (MaybeT (MaybeT m)) is superfluous but that is a bit hard to figure out.
11:55:23 <SamB> mine says...
11:55:46 <SamB> instance (Monad m) => Monad (MaybeT m)
11:55:46 <SamB>   -- Defined in Control.Monad.Maybe
11:56:04 <fasta> That's all?
11:56:14 <SamB> I'm particularly puzzled that it doesn't say "overlap okay"
11:56:51 <fasta> SamB: I have monadtrans, monadstate, monadio, functor and the one above.
11:57:01 <fasta> SamB: and monadplus
11:57:02 <SamB> fasta: I have a couple of others...
11:57:11 <fasta> SamB: and a newer compiler
11:57:28 <SamB> and probably would see more if I :m +Control.Monad
11:58:38 <int-e> fasta: did the compiler derive that type? (qqq :: (Monad m, Num t) => m (Maybe t))
11:58:39 <SamB> okay, I've got all of those if I import Control.Monad.RWS (with my older MTL)
11:58:41 <sjanssen> SamB: that isn't an overlapping instance, according to Haskell '98
11:58:57 <fasta> int-e: yes
11:58:58 <SamB> sjanssen: what isn't?
11:59:04 <sjanssen> instance (Monad m) => Monad (MaybeT m)
11:59:09 <SamB> sjanssen: yes
11:59:09 <int-e> fasta: that is strange.
11:59:38 <fasta> SamB: ghci-6.6.1 derives (Monad (MaybeT (MaybeT m)), Num t, Monad (MaybeT m)) => m (Maybe t)
11:59:55 <SamB> fasta: ah,
11:59:56 <fasta> ghci-6.6.1 used inferior technology, so it seems :)
12:00:04 <SamB> 6.6 says exactly the same
12:00:22 <SamB> so the answer is that someone has found how GHC *can* infer a smaller type
12:00:25 <SamB> and implemented
12:00:26 <SamB> it
12:01:19 <fasta> If I had seen this behaviour earlier, I might reported as being a bug.
12:01:35 <fasta> It's not a bug, but it could be better and it has already been done :)
12:01:39 <int-e> hmm. 6.7 does that, right. even if I say -fallow-overlapping-instances. Why is Monad (MaybeT m), Num t  not enough?
12:01:59 <fasta> int-e: ?
12:02:04 <fasta> int-e: what does 6.7?
12:02:10 <SamB> um, hmm, why is the community college sending me this President's Honor List certificate NOW?
12:02:12 <fasta> int-e: my 6.7 does the right thing
12:02:20 <int-e> fasta: derive Num t, Monad m) => m (Maybe t)  as a type
12:02:24 <SamB> the semester was over quite a while ago...
12:02:42 <SamB> int-e: what does :i MaybeT say for the Monad instance?
12:02:44 <int-e> fasta: which with overlapping instances allowed does not seem correct.
12:03:05 <glguy> OpenGL applications seem to lock up my computer :-/ fortunately mpd keeps on chugging
12:03:12 <shapr> yay mpd!
12:03:18 <int-e> instance [overlap ok] (Monad m) => Monad (MaybeT m)
12:03:18 <SamB> int-e: please paste it here?
12:03:22 <SamB> ah.
12:03:28 <shapr> I gave up on xmms and switched to mpd permanently. It's too bad xmms2 wasn't based on mpd.
12:03:44 <SamB> see, my MaybeT doesn't have [overlap ok]
12:03:48 <SamB> because it doesn't need overlap
12:03:49 <Saizan> which client do you use?
12:04:07 <shapr> glguy: I do wish mpd could play single files that it doesn't have indexed, but I do enjoy and use the last.fm integration.
12:04:26 <shapr> Saizan: I use mpc, but mostly via some elisp that I hacked up.
12:04:44 <shapr> Writing a Haskell mpd client is on my list of fun things to do.
12:04:49 <SamB> so, apparantly my typechecker doesn't use lack of "overlap okay" to simplify contexts
12:05:01 <shapr> Saizan: What do you use?
12:05:12 <SamB> mine being the one in ghc 6.6
12:05:16 <Saizan> shapr: mpc too
12:05:28 <SamB> (and ghc 6.6.1's doesn't either)
12:05:42 <Saizan> shapr: i don't like that i've to use grep to find the position of a song in the playlist..
12:05:56 <shapr> Saizan: I agree, but what's better?
12:06:21 <int-e> SamB: I added -fallow-overlapping-instances; it still simplifies Monad (MaybeT m) to Monad m. Do you have any idea why?
12:06:22 <Saizan> shapr: a yet to be written haskell client?
12:06:44 <shapr> works for me.
12:06:44 <Saizan> s/yet/still/
12:06:51 <SamB> int-e: oh?
12:07:07 <oerjan> er...
12:07:21 <SamB> okay now I haven't a clue
12:08:26 <oerjan> data MaybeT m doesn't happen to have a Monad m context?
12:08:38 <vincenz> Cale: ping
12:08:49 <Cale> pong
12:08:55 <vincenz> Cale: not in lb?
12:08:58 <Cale> oh
12:09:02 <SamB> oerjan: would it help?
12:09:08 <Cale> restarted my client, one sec
12:09:24 <shapr> lb?
12:09:29 <oerjan> SamB: i would expect the opposite
12:09:32 <oerjan> if any
12:09:39 <SamB> newtype MaybeT m a = MaybeT {runMaybeT :: m (Maybe a)}
12:09:39 <SamB>         -- Defined in Control.Monad.Maybe
12:09:39 <SamB> instance (Monad m) => Monad (MaybeT m)
12:09:39 <SamB>   -- Defined in Control.Monad.Maybe
12:10:07 <hpaste>  int--e pasted "MaybeT problem: is the type checker oversimplifying here?" at http://hpaste.org/1755
12:10:42 <int-e> oh that's GHCi, version 6.7.20070716: http://www.haskell.org/ghc/  :? for help
12:10:43 <lambdabot> Title: The Glasgow Haskell Compiler
12:11:44 <SamB> int-e: and you are supposed to be able to write a Monad (MaybeT Int) instance?
12:12:22 <int-e> SamB: well, not Int (it has to be a unary type constructor)
12:12:31 <SamB> oh rright
12:12:34 <int-e> *tries*
12:14:09 <oerjan> ah, now that is correct.
12:14:22 <oerjan> runMaybeT (return _) forces m to be a Monad
12:16:01 <oerjan> it's the return that causes it, i think
12:16:03 <int-e> SamB: ah it needs  -XFlexibleInstances too
12:16:28 <int-e> SamB: and with that it derives  (Num t, Monad (MaybeT m)) => m (Maybe t) -- which is what I expected
12:16:29 <SamB> huh
12:16:34 <SamB> how very odd indeed
12:16:47 <SamB> Prelude Control.Monad.Maybe Control.Monad Control.Monad.RWS> :t runMaybeT
12:16:47 <SamB> runMaybeT :: MaybeT m a -> m (Maybe a)
12:17:48 <SamB> oh, the return, right...
12:18:38 <SamB> hmm, no wait, that return is in the (MaybeT m) Monad
12:18:43 <SamB> how does that do anything?
12:19:04 <oerjan> SamB: you have the type for runMaybeT wrong
12:19:06 <vincenz> you need to lift
12:19:12 <vincenz> like an elevator
12:19:14 <SamB> oerjan: do I?
12:19:25 <oerjan> runMaybeT :: m (Maybe a) -> MaybeT m a
12:19:36 <SamB> oerjan: no.
12:19:42 <oerjan> er...
12:19:44 <oerjan> sheesh
12:19:51 <SamB> that's the cotype ;-)
12:20:15 <SamB> (note: that was a joke)
12:20:22 <SamB> (I don't actually know what a cotype may be)
12:20:38 <oerjan> however, the return 2 forces the inner runMaybeT to give a monad
12:21:59 <SamB> hmm. Control.Monad.Maybe has this at the top:
12:22:03 <SamB> {-# LANGUAGE FlexibleInstances, UndecidableInstances #-}
12:23:01 <pjd> SamB: it's what codata has?
12:23:02 <hpaste>  int-e annotated "MaybeT problem: is the type checker oversimplifying here?" with "the mere presence of an instance changes the derived type. weird." at http://hpaste.org/1755#a1
12:23:16 <sm> oops.. perhaps I shouldn't have taken Simon as my wiki username
12:23:43 <sm> how do I get a list of wiki usernames ?
12:23:44 <nominolo> @src on
12:23:45 <lambdabot> (*) `on` f = \x y -> f x * f y
12:23:55 <sm> and how would I change it ?
12:24:01 <SamB> b
12:24:03 <SamB> erg.
12:24:15 <SamB> int-e: I'd holler "bug"
12:24:27 <sfultong> man.... my code is ugly... I just wrote a line that goes "(return . return) x"
12:24:28 <SamB> if an instance changes the derived type
12:24:34 <nominolo> @src comparing
12:24:34 <lambdabot> Source not found. I've seen penguins that can type better than that.
12:24:36 <sm> talk to ashley y, it look slike
12:25:06 <SamB> sm: perhaps not
12:25:12 <SamB> now everyone will think you are super smart
12:25:23 <SamB> and maintain a haskell compiler
12:25:37 <sm> good point, good point
12:25:51 <dolio> int-e: It does that in other cases, too.
12:26:04 <int-e> dolio: no good
12:26:17 <dolio> int-e: For instance, if you don't have Control.Monad.Instances imported, you'll get constraints like 'Monad ((->) e) =>'
12:26:27 <int-e> dolio: that's different
12:26:43 <dolio> I suppose.
12:26:46 <int-e> dolio: the type with the new instance in this case is *more general* than the one derived originally
12:27:25 <pjd> sm: http://haskell.org/haskellwiki/Special:Allpages&namespace=2
12:27:26 <lambdabot> Title: All pages (User namespace) - HaskellWiki
12:27:39 <pjd> that will give you the usernames with pages, at least
12:27:56 <sm> thanks pjd
12:28:35 <int-e> dolio: (but the bug is not as bad as it sounds, it's "just" a bad interaction with overlapping instances. And generally using overlapping instances is just asking for trouble.)
12:29:24 <dolio> int-e: I imagine it's using the fact that if you declare 'instance Monad m => Monad (MaybeT m)', you're not allowed to declare any others, without flags to override that.
12:29:25 <SamB> int-e: but there's little point in having that "overlap ok" flag on an instance if it isn't going to be used...
12:34:28 <int-e> SamB: oh my Control.Monad.Maybe has {-# OPTIONS_GHC -fglasgow-exts #-} at the top, hmm. without that ghc wants -fallow-incoherent-instances if I want to define an  instance Monad (MaybeT Foo)
12:35:02 <hpaste>  jethr0 pasted "type class computation" at http://hpaste.org/1756
12:47:22 <Phillemann> When trying to use "Char.isDigit" the compiler prints: Not in scope: `Char.isDigit'. Do I have to import isDigit in addition to the Char. prefix?
12:47:35 <Botje> any way I can tell Data.Time.formatTime to drop the fractional seconds?
12:47:40 <Botje> Phillemann: how did you import Char?
12:47:41 <vincenz> Phillemann: "import Data.Char"
12:48:03 <Phillemann> Botje: I didn't import it at all, I thought Char. would be enough.
12:48:06 <Botje> Phillemann: if you just did "import Char", you can use "isDigit"
12:48:10 <edwardk> @seen mnislaih
12:48:10 <lambdabot> mnislaih is in #oasis, #haskell and #ghc. I don't know when mnislaih last spoke.
12:48:24 <mnislaih> edwardk: hi
12:48:43 <edwardk> mnislaih: did you see http://www.haskell.org/pipermail/haskell-cafe/2006-December/020630.html ?
12:48:44 <lambdabot> Title: [Haskell-cafe] AT solution: rebinding >>= for restricted monads, http://tinyurl.com/2s24xm
12:49:13 <mnislaih> Yes, I did, but at that time there was no implementation
12:49:16 <edwardk> though, it seems their 'restricted monad' is parameterized, or type-indexed
12:49:20 <edwardk> ah
12:49:24 <Botje> Phillemann: apparently you can refer to it as Data.Char.isDigit if you don't import too
12:49:31 <mnislaih> btw, add yourself to the CC list at http://hackage.haskell.org/trac/ghc/ticket/1537
12:49:32 <lambdabot> Title: #1537 (do notation translation) - GHC - Trac
12:50:03 <mnislaih> edwardk: I haven't given it a second look now that there is a more complete implementation in HEAD. Might be worth it
12:50:47 <mnislaih> But even so, I think monad-param is probably the right thing
12:50:55 <edwardk> its close to the right thing
12:51:04 <edwardk> i still want a way to handle 'restricted' monads as well
12:51:12 <edwardk> monad-param can't do Bags or Sets
12:51:25 <oerjan> Botje: in ghci, but not in files
12:51:48 <edwardk> and the naive extension of it to just implement Oleg's restricted monad hackery leads to the inability to use standard library functions
12:51:53 <Botje> :(
12:52:05 <edwardk> or to specify functions with brief signatures like those
12:52:14 <mnislaih> ah, true
12:52:53 <mnislaih> but maybe it's better to keep these notions separate? Better for the sake of the type inference mechanism at least
12:52:59 <edwardk> but, i'm thinking maybe the witness approach can encode that
12:53:12 <edwardk> well, i'm on the hunt for a useful parameterized restricted monad =)
12:53:17 <mnislaih> which is the witness aproach? the AT approach ?
12:53:19 <oerjan> Botje: i think it is so compilers don't need to parse the entire file to find out which other modules are needed
12:53:27 <edwardk> yeah the class associated type
12:53:40 <oerjan> (to compile first)
12:53:46 <Botje> yeah.
12:54:00 <Botje> oerjan: any chance you know the answer to my formatTime query too ? :)
12:54:05 <mnislaih> edwardk: sounds plausible. I am on my way to IOE'ing xmonad
12:54:16 <edwardk> nice choice =)
12:55:13 <oerjan> Botje: i doubt i know it, but i am fairly good at guessing :)
12:55:57 <Botje> i'm poring over the docs, but can't find anything usable
12:56:17 <Botje> except possibly taking the seconds part of the time structure and printing it myself
12:56:48 <oerjan> Botje: %S
12:56:58 <Botje> yup
12:57:01 <Botje> tried that
12:57:06 <Botje> it includes the fraction
12:57:12 <edwardk> mnislaih: i started the re-encoding of things as a generic effects monad, I'll see if it actually pans out and can type check, but thats one reason why i started looking at other approaches, coz i'm not sure i can maintain type inferability everywhere
12:57:24 <oerjan> that's inconsistent with the docs
12:57:24 <hpaste>  ptolomy pasted "Simple Life" at http://hpaste.org/1757
12:57:47 <Botje> Prelude Locale Data.Time> formatTime defaultTimeLocale "%S" t
12:57:47 <Botje> "41.291073"
12:58:37 <newsham> ?src on
12:58:38 <lambdabot> (*) `on` f = \x y -> f x * f y
12:58:58 <Baughn> I was surprised at just how much work I had to do to get a simple unix timestamp. Shouldn't there be a function for that?
12:59:04 <mnislaih> edwardk: I want to look at your code and look at this trick. Are you preparing a blog post soon ?
12:59:05 <oerjan> Botje: what type is t?
12:59:13 <Botje> t :: ZonedTime
12:59:20 <Botje> Prelude Locale Data.Time> t <- getZonedTime
12:59:37 <edwardk> mnislaih: half of it is in my head right now, as soon as i get somewhere i can sleep, then wake up and code I'll try to bang it out =)
12:59:38 <mnislaih> Did you check Oleg's "static capabilities" paper? is it the same trick ?
13:00:24 <newsham> > sortBy (compare `on` fst) [(1,"hi"), (5, "bob"), (3, "there")]
13:00:25 <lambdabot>   Not in scope: `on'
13:00:37 <timthelion> how do I find out if one string contains another?
13:00:53 <Heffalump> a while back, I remember a module that can detect undefined values being discussed. Anyone remember any details?
13:01:03 <mnislaih> @time edwardk
13:01:05 <edwardk> knowing oleg it probably is the same thing, skimming back through it, i read it quite a while ago and forgot about it
13:01:10 <Botje> find needle haystack = any (needle `isPrefixOf`) $ tails haystack
13:01:15 <edwardk> its 4pm, but i didn't sleep last night ;)
13:01:26 <Botje> that's an easy (ish) way
13:01:33 <mnislaih> stayed up coding ?
13:01:43 <edwardk> coding and talking
13:01:52 <matthew-_> just wondering, the Martin Coxall that's recently been posting to -cafe, does anyone know him? - I know a Martin Coxall and am just wondering if it's the same one...
13:01:56 <mnislaih> someone else stayed up with you ?
13:02:09 <Baughn> timthelion: Text.Regex should be fast-ish
13:02:15 <edwardk> on phone, buddy overseas
13:02:44 <vincenz> edwardk: get skype
13:02:50 <int-e> SamB: http://hackage.haskell.org/trac/ghc/ticket/1549
13:02:52 <lambdabot> Title: #1549 (ghc derives different type signature for equal functions with overlapping ...
13:03:00 <edwardk> vincenz: have it, don't like it ;)
13:03:11 <vincenz> :)
13:04:01 <oerjan> Botje: report a bug
13:05:45 <edwardk> anyways capabilities are kind of like 'coeffects' =) in this setting effects are all the things you need to handle in order to start an action. capabilities give you the ability to do more things.
13:06:32 <fasta> If I have do list<- mapM foobar [a,b]; return (head list) in the ST monad, can I make sure the effects are done lazily too?
13:06:58 <Botje> oerjan: how can I see which version of the lib I have?
13:06:59 <fasta> In the ST monad since foobar is a read only action it can be optimized away
13:07:05 <fasta> Does this actually happen?
13:07:17 <Botje> ghc-pkg list time says I have time-1.0
13:07:19 <oerjan> Botje: don't know
13:08:09 <edwardk> i'm trying to see if a typeclass version of the effect stuff can be done to move it into a normal monad, mostly relying on the ability to try to reify an HList of effects as a monad and reflect a Monad as an HList of the effects it allows.
13:09:17 <edwardk> the one issue with this is that the fundeps don't allow you to note the fact that a monad can handle other effects after the fact, so i need to figure out a way to say that some set of effects can act as a cover for another set of effects.
13:09:33 <mnislaih> edwardk: type-level programming in Haskell is already painful enough, and you are talking about constraint-level programming now
13:09:37 <edwardk> and figure out a confluent way to reduce it
13:10:17 <edwardk> otherwise you'll be limited to using the 'effect' set thats built into the library when using it with the monads defined in the library.
13:10:48 <edwardk> which may not be a bad thing, i don't see a lot of new interesting instances for Maybe thrown around every day.
13:11:48 <mnislaih> I need to see an actual example (hint: blog post :) ) to follow this stuff
13:11:55 <edwardk> heh
13:12:39 <edwardk> i will as soon as i'm no longer at the office watching paint dry (and olap cubes build)
13:13:20 <mnislaih> I'm dropping xmonad as poster example. I'm thinking of cabal-install now
13:13:35 <edwardk> xmonad proved to be too scary?
13:13:53 <mnislaih> they do everything in the X monad, which is a ReaderT StateT IO stack
13:13:56 <edwardk> or just have too many types of exceptions?
13:14:00 <edwardk> ah
13:14:10 <mnislaih> that's going to be too much work :)
13:14:42 <edwardk> and since you have no IOE (HasState s :*: HasEnv r :*: Nil) ...
13:14:49 <fasta> I have two values of type m Int, is there any function to combine those two s.t. when the first calls "fail", the second gets tried, and the entire computation fails when they both call fail?
13:14:58 <mnislaih> not there yet !
13:15:19 <mnislaih> but that sounds like where I'd like to get
13:15:24 <edwardk> > fail "Argh" >> Just 1
13:15:28 <lambdabot>  Nothing
13:15:32 <fasta> It sounds like the list monad, but it's running in runMaybeT already
13:15:43 <edwardk> > fail "Argh" `morElse` Just 1
13:15:44 <lambdabot>   Not in scope: `morElse'
13:16:01 <edwardk> too bad Cale's orElse doesn't exist in the standard library
13:16:02 <oerjan> fasta: mplus
13:16:14 <edwardk> > fail "Argh" `mplus` Just 1
13:16:16 <lambdabot>  Just 1
13:16:16 <fasta> oerjan: I thought of that, but wasn't sure whether it would work.
13:16:29 <oerjan> fasta: it works if your monad is a MonadPlus
13:16:30 <edwardk> > fail "Argh" `mplus` fail "Blech"
13:16:30 <lambdabot>   add an instance declaration for (Show (m a))
13:16:34 <Botje> there, bug reported.
13:16:35 <fasta> edwardk: Just 1 `mplus` Just 3
13:16:38 <fasta> > Just 1 `mplus` Just 3
13:16:39 <lambdabot>  Just 1
13:16:46 <fasta> Ah, ok.
13:16:55 <oerjan> and if it can't be a MonadPlus, then you would have troubles doing it anyway
13:16:59 <edwardk> yeah
13:17:31 <fasta> Wow, this code is _great_
13:17:55 <edwardk> which is something i found amusing about the monad-param stuff, is i get a notion of mzero even when mzero doesn't exist for your monad, most of the time.
13:19:21 <edwardk> unless you attempt to use it in a position that would force it to appeal to the real mzero for your monad that is
13:20:07 <hpaste>  (anonymous) annotated "(no title)" with "ruby ver" at http://hpaste.org/1668#a3
13:22:09 <hpaste>  edwardk annotated "(no title)" with "=)" at http://hpaste.org/1668#a4
13:22:18 <oerjan> edwardk: i had a similar thought about return once
13:23:02 <oerjan> (basically, it was about how to do monads in a dynamically typed language, i haven't seen how it is actually done)
13:23:37 <edwardk> i have been occasionally finding myself in want of a monad-like thing without return.
13:23:41 <oerjan> anyway, most of the time when you use return, you don't really need to know the monad to remove it
13:23:54 <edwardk> yeah i just realize this trick would work really well for my javascript monads.
13:24:23 <edwardk> er just realized
13:24:45 <eivuokko> @paste
13:24:46 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:26:03 * vincenz needs another word for 'State'
13:26:10 <edwardk> hrmm, i wonder if using this trick since it relies only on forward type inference you could get an almost decent monad syntax/inference in c++.
13:26:16 <oerjan> Country
13:26:30 <vincenz> no as in the State of a computer
13:26:39 <oerjan> World
13:26:41 <edwardk> ah no first class functions though
13:26:46 <Vulpyne> Mood!
13:26:50 <ari> State'
13:27:07 <edwardk> so i guess i'd have to stick to doing it in javascript
13:27:09 <hpaste>  eivuokko pasted "Is there nicer way to add typing to bitmasks?" at http://hpaste.org/1758
13:27:23 <eivuokko> Eh, well, truncated.
13:27:46 * SamB wonders who is Travis B. Hartwell
13:27:51 <oerjan> Inventory
13:27:59 <eivuokko> Do you think that's heavy-weight solution or is there nicer bitmask-type in libraries?
13:28:15 <Nafai> SamB: Me
13:31:43 <SamB> curse facebook for not having a "hung out on IRC together" option for "How do you know <this person>?"
13:32:00 <Heffalump> report it to them
13:32:38 <Nafai> SamB: Heh.
13:32:48 <Phillemann> If a function returns ([a],b), does pattern matching occur in the statement (foo : list,bar) = function?
13:32:59 <Phillemann> Ah, I better try that instead of asking.
13:33:00 <Heffalump> yes
13:33:08 <SamB> okay, now who is David Himmelstrup?
13:33:11 <Heffalump> Lemmih
13:33:53 <mnislaih> why would he pick lemmih over purts, or purtslemmih ?
13:35:41 <shachaf> mnislaih: Purts seems less unique, and Purtslemmih seems too long.
13:35:43 <SamB> okay.
13:36:01 <SamB> facebook seems somewhat confused. it seems to think shapr added photos to #haskell before he created it?
13:36:21 <Saizan> ?where facebook
13:36:21 <lambdabot> I know nothing about facebook.
13:36:34 <SamB> @google facebook
13:36:36 <lambdabot> http://www.facebook.com/
13:36:37 <lambdabot> Title: Facebook | Incompatible Browser
13:36:43 <SamB> huh
13:36:47 <eivuokko> heh
13:37:04 <SamB> you'd think they'd support plain-old HTML
13:38:53 <sjanssen> SamB: the times on facebook feed items are frequently off
13:39:16 <SamB> hooray
13:39:24 <SamB> they've implemented -X
13:39:40 <SamB> http://hackage.haskell.org/trac/ghc/ticket/1469 is closed
13:39:41 <lambdabot> Title: #1469 (GHC suggests -fglasgow-exts, and not {-# LANGUAGE #-} pragmas or &#34;Ext ...
13:42:43 * SamB invites ndm
13:43:56 <fasta> How can I make something like this work? foo = if True then fail "" else runMaybeT foo
13:45:14 <SamB> foo = fail "" -- ;-P
13:45:35 <eivuokko> What exactly is your problem?  Looping because of recursive def, infinity type or sensible error message, or something else?
13:45:50 <nominolo> :t fail ""
13:45:53 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a
13:46:22 <fasta> I want to achieve that I can run the current function on two components of the current input, but since these are run in succession, if one fails, the whole computation fails now in MaybeT
13:46:33 <fasta> I want that they both get run
13:46:39 <sjanssen> fasta: that function requires an infinite type
13:46:41 <fasta> mplus is not the right semantics in this case
13:46:59 <fasta> mplus implements "xor" semantics
13:47:06 <fasta> Er "or"
13:47:17 <byorgey> fasta: something involving seq?
13:47:23 <eivuokko> You need to ignore error from the first part?
13:47:24 <fasta> byorgey: no
13:47:30 <fasta> eivuokko: right
13:47:51 <sjanssen> fasta: foo `mplus` return ()
13:47:54 <SamB> is chanserv down?
13:48:09 <fasta> sjanssen: heh, perfect
13:48:32 <fasta> sjanssen: so simple, but I didn't see it.
13:50:45 <jedai> @src nub
13:50:45 <lambdabot> nub = nubBy (==)
13:50:50 <jedai> @src nubBy
13:50:51 <lambdabot> nubBy eq []             =  []
13:50:51 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
13:52:54 <fasta> sjanssen: hmm, I still get infinite types
13:53:28 <sjanssen> fasta: foo = runMaybeT foo -- is your problem
13:53:47 <fasta> sjanssen: not in that example
13:53:58 <fasta> sjanssen: I will paste the actual code
13:54:39 <fasta> sjanssen: oh, I still had some test code uncommented
13:54:47 <fasta> sjanssen: it is working according to expectation
13:54:54 <fasta> sjanssen: thanks for the mplus trick
14:05:32 <fasta> If I don't even care about the Maybe value that gets returned, but I want computation abortion just like MaybeT does when fail gets run what *T do I need for that?
14:08:17 <oerjan> for a list, sequence_
14:09:01 <oerjan> (of actions)
14:12:04 <msouth> is there a way to ask lambdabot where nubBy is defined?
14:12:09 <shachaf> @index nubBy
14:12:09 <lambdabot> Data.List
14:12:15 <msouth> thx
14:12:21 <xerox> ?src nubBy
14:12:21 <lambdabot> nubBy eq []             =  []
14:12:21 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
14:13:04 <xerox> (or ?fptools Data.List IIRC, if you want to actually see the definition.)
14:13:37 <SamB> @source Data.List
14:13:37 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
14:14:24 <shachaf> @help fptools
14:14:24 <lambdabot> fptools <lib>. Lookup url of ghc base library modules
14:14:34 <shachaf> @help source
14:14:34 <lambdabot> source <lib>. Lookup the url of fptools libraries
14:14:50 <SamB> hmm. do they have their helps crossed?
14:14:55 <hpaste>  (anonymous) annotated "(no title)" with "Argh, bruker jo sinustabell" at http://hpaste.org/1668#a5
14:15:01 <shachaf> Isn't that a bit reversed?
14:27:37 <hpaste>  vincenz pasted "ALEX + HAPPY Monad" at http://hpaste.org/1759
14:28:55 <hpaste>  vincenz annotated "ALEX + HAPPY Monad" with "Lexer" at http://hpaste.org/1759#a1
14:35:49 <hpaste>  JAFFE:P annotated "(no title)" with "Hihi, eksempel p√• hva mIRC-scripting kan gj√∏re" at http://hpaste.org/1668#a6
14:36:21 <monochrom> Damn that.
14:40:39 <Shimei> Does anyone else think that the Haskell wiki could be improved with something akin to Wikipedia's portals for topics? I mean something like this: http://en.wikipedia.org/wiki/Portal:Science
14:40:41 <lambdabot> Title: Portal:Science - Wikipedia, the free encyclopedia
14:41:58 <Shimei> I say this because I've noticed that links on the front page, such as "Wiki articles", often just link to alphabetised categories (which are broad but not too helpful).
14:43:06 <Shimei> (I thought that might also quell all the ML posts about how the wiki is hard to browse)
14:51:15 <Phillemann> I've got a string and want to extract a Float value out of it. How do I do that the best way?
14:51:35 <oerjan> > read "2.4" :: Double
14:51:37 <lambdabot>  2.4
14:51:54 <wli> Phillemann: Is read s :: Float or read s :: Double insufficient for some reason?
14:52:00 <Phillemann> oerjan: The string has characters after the number.
14:52:14 <vincenz> > reads "2.4abc" ::
14:52:14 <lambdabot>  Parse error
14:52:16 <vincenz> > reads "2.4abc"
14:52:17 <lambdabot>  []
14:52:19 <vincenz> :t reads
14:52:21 <lambdabot> forall a. (Read a) => String -> [(a, String)]
14:52:26 <oerjan> reads "2.4" "" :: [(Double,String)]
14:52:30 <oerjan> > reads "2.4" "" :: [(Double,String)]
14:52:31 <lambdabot>  Couldn't match expected type `[Char] -> [(Double, String)]'
14:52:42 <vincenz> > reads "2.4abc" :: [(Double, String)]
14:52:42 <oerjan> > reads "2.4" :: [(Double,String)]
14:52:43 <lambdabot>  [(2.4,"abc")]
14:52:44 <lambdabot>  [(2.4,"")]
14:53:03 <Phillemann> Ah, so "reads". Thanks :)
14:53:08 <wli> Phillemann: takeWhile (/=[]) [reads s' | s' <- inits s]
14:53:09 <vincenz> > fst . head . reads $ "2.4abc" :: Double
14:53:10 <lambdabot>  2.4
14:53:18 <oerjan> also has the advantage of dealing with erros
14:53:28 <oerjan> *rs
14:53:57 <kaol> > do [(a,_)] <- (reads "2.4abc") :: [(Double, String)]  ; return a
14:53:58 <lambdabot>  Couldn't match expected type `(Double, String)'
14:54:22 <kaol> > do (a,_) <- listToMaybe ((reads "2.4abc") :: [(Double, String)])  ; return a
14:54:24 <lambdabot>  Just 2.4
14:54:56 <oerjan> > do (a,_) <- (reads "2.4abc") :: [(Double, String)]  ; return a
14:54:57 <lambdabot>  [2.4]
14:55:16 <wli> Phillemann: Sorry, \s -> snd $ partition (==[]) [reads s' | s' <- s]
14:55:29 <glguy> ==[] is null
14:55:40 <vincenz> oerjan: simply
14:55:44 <wli> Phillemann: Sorry, \s -> filter (/=[]) [reads s' | s' <- s]
14:55:52 <vincenz> > liftM fst (reads "2.4abc") :: Maybe Double
14:55:53 <lambdabot>  Couldn't match expected type `Maybe (Double, b)'
14:56:10 <vincenz> > liftM fst $ listToMaybe (reads "2.4abc") :: Maybe Double
14:56:11 <lambdabot>  Just 2.4
14:56:19 <Phillemann> Well, the plain reads is just fine to me. :)
14:56:29 <glguy> [s'' | s' <- s, let s'' = reads s', not (null s'')]
14:56:33 <xerox> wli, if you use not.null instead of /=[] you can avoid an Eq a constraint in the type, if you care
14:56:48 <glguy> in the type of []?
14:56:55 <glguy> oh
14:56:56 <Phillemann> Before that I had a function which just parsed integers and returned a tuple of the parsed number and the rest of the string, but I didn't want to write one for floating point values, so reads is perfect.
14:57:13 <glguy> nvm, i saw
14:57:18 <kaol> @pl (\s -> liftM fst $ listToMaybe (reads s) :: Maybe Double)
14:57:18 <lambdabot> fmap fst . (:: Maybe Double) . listToMaybe . reads
14:58:55 <oerjan> i once thought (:: type) ought to be a legal section
14:59:18 <wli> kaol's is best, but not lambdabot's translation.
14:59:22 <newsham> its too bad lambdabot doesnt let you use some safe forms of IO (ie. RandomRIO)
14:59:36 <oerjan> (desugars to (`asTypeOf` (undefined :: type)))
15:00:07 <oerjan> er, is it?
15:00:20 <oerjan> > (:: Double) 3
15:00:20 <lambdabot>  Parse error
15:00:40 <oerjan> just @pl being forward-looking :)
15:01:30 <wli> readM :: (Monad m, Read a) => String -> m a ; readM s = case (do { (x,t) <- reads s ; ("","") <- lex t ; return x }) of { [x] -> return x ; [] -> fail "Util.readM: no parse" ; _ -> fail "Util.readM: ambiguous parse" }
15:01:50 <wli> This is probably not entirely correct/useful for Philleman's situation.
15:02:47 <wli> I, however, use it often.
15:02:47 <ddarius> asTypeOf
15:03:03 <ddarius> nm
15:04:12 <mnislaih> anyone knows about a separate do-notation desugarer ?
15:04:28 <oerjan> @undo do yes; return 1
15:04:28 <lambdabot> yes >> return 1
15:04:33 <mnislaih> I want to preprocess existing Haskell code to desugar do-notation before feeding it to ghc
15:04:40 <kaol> @src yes
15:04:40 <lambdabot> Source not found. You type like i drive.
15:04:54 <mnislaih> nice
15:04:56 <glguy> like ndm mentioned: ("","") <- lex t; is a really round-about way of saying: all isSpace t
15:05:07 <mnislaih> lambdabot is *all* one need
15:05:08 <mnislaih> s*
15:05:44 <wli> glguy: I cribbed it directly from the source of something involving read/readIO/etc.
15:05:54 <glguy> wli: yeah, that's what he was complaining about
15:06:03 <glguy> that that was how it was implemented in the source
15:06:19 <glguy> I'm not griping at you :)
15:07:06 <wli> glguy: Arguably there should be allowance for nondeterministic monads etc.
15:07:27 <wli> glguy: So in a nondeterminism monad all possible parses are returned.
15:07:49 <glguy> all possible parses means that the parse was ambiguous though...
15:08:06 <glguy> seems like it would be confusing for that to be an error in one monad
15:08:12 <glguy> and acceptable in another
15:08:38 <wli> glguy: Well, in a nondeterminism monad, you don't mind that. In deterministic monads it's more of an error.
15:09:09 <glguy> really what's going on is that its an abuse of the Monad class
15:09:48 <ddarius> glguy: What is?
15:09:49 <monochrom> @where oleg
15:09:49 <lambdabot> http://okmij.org/ftp/
15:10:23 <wli> Could be. I don't care so much apart from having error handling superior to exceptions getting thrown. Ambiguous parses I can't be arsed to deal with in such a context.
15:10:24 <glguy> ddarius: using the fail "" to do mzero's job
15:11:06 <glguy> but this topic is well covered, and I should have left it alone :)
15:11:34 <wli> Well, there is a trichotomy here. Unique, nonexistant, and ambiguous.
15:11:50 <wli> There is no clean expression of that.
15:11:54 * Toxaris tries to install gtk2hs on windows
15:12:20 <oerjan> wli: compare 1 . length :)
15:12:56 <glguy> ew :-p
15:13:17 <Toxaris> i've installed the precompiled gtk2hs for windows, it works with my ghc-4.2, but not with my ghc-6.6. How to setup ghc to use it / gtk2hs to support it?
15:13:43 <Toxaris> ghc-6.4.2 of course
15:13:49 <glguy> length is one of those functions that flags generally bad code ;)
15:13:51 <oerjan> or compare 1 . genericLength :: Nat -> Comparing
15:14:12 <TSC> Toxaris: What version of gtk2hs is it?
15:14:18 <glguy> oerjan: Nat isn't a list ;)
15:14:25 <glguy> but I see the lazy numbers you were going for
15:14:27 <oerjan> er...
15:14:43 <dcoutts> Toxaris: the current version of Gtk2Hs works with GHC 6.6, perhaps you've got GHC 6.6.1 ?
15:14:48 <oerjan> compare 1 . (:: Nat) . genericLength
15:14:48 <Toxaris> TSC: 0.9.11 from http://haskell.org/gtk2hs/download/
15:14:49 <lambdabot> Title: Gtk2Hs ª Download
15:14:52 <wli> oerjan: That's not a monad.
15:15:09 <glguy> oerjan: I'm pretty sure that is invalid syntax
15:15:28 <wli> oerjan: It's sort of a nondeterminism monad where nondeterminism is a "soft error."
15:15:30 <TSC> Toxaris: Hmm, it ought to work.  What does it do when you try?
15:15:36 <oerjan> glguy: i know, but i just suggested it above (after @pl spit it out)
15:15:49 <Toxaris> dcoutts: i've ghc-6.4.2, ghc-6.6 and ghc-6.6.1 installed (all as windows precompiled packages using the provided installers)
15:16:02 <ddarius> let f [] = LT; f [x] = EQ; f (x:xs) = GT
15:16:11 <wli> oerjan: And instead of backtracking, an empty set of choices is a "hard error."
15:16:12 <newsham> whats the way to get from  [pred,succ] to [map pred, map succ] ?
15:16:28 <ddarius> map map
15:16:29 <xerox> newsham, map map
15:16:44 <Toxaris> TSC: the gtk2hs installer says "installing for ghc-6.4.2 in ..." and offers no choice to select another or more
15:16:45 <dcoutts> Toxaris: ok, so Gtk2Hs 0.9.11 works with ghc-6.4.2 and 6.6, but only one of them at once. And for ghc-6.6.1 you'll need the latest Gtk2Hs pre-release
15:17:21 <newsham> why did my brain not know that?
15:17:39 <ddarius> You were thinking too concretely.
15:17:44 <dcoutts> Toxaris: the installer picks which ghc version to use based on the ghc.exe you have in your %PATH% (and if none is in the path then it looks for 6.6 before 6.4.2)
15:17:57 <bringert> @seen dcoutts
15:17:58 <lambdabot> dcoutts is in #haskell-overflow, #haskell and #ghc. I last heard dcoutts speak 13s ago.
15:18:04 <dcoutts> hia bringert :-)
15:18:09 <bringert> hi dcoutts
15:18:14 <monochrom> newsham: don't be too hard to your brain :)
15:18:19 * Toxaris checks his PATH again
15:18:35 <newsham> > map map [pred, succ] `ap` words "this is a test"
15:18:36 <bringert> dcoutts: I seem to remember that you used some xhtml + js slides system. is that correct?
15:18:37 <lambdabot>  ["sghr","hr","`","sdrs","uijt","jt","b","uftu"]
15:18:39 <dcoutts> Toxaris: ghc --version will tell you the version of ghc on your path
15:18:51 <dcoutts> bringert: yep it's called S5 iirc
15:19:00 <Toxaris> dcoutts: is it possible to install one gtk2hs for 6.4.2 and another for 6.6?
15:19:34 <dcoutts> Toxaris: perhaps, you'd certainly have to select different install dirs
15:19:45 <dcoutts> bringert: http://meyerweb.com/eric/tools/s5/
15:19:46 <lambdabot> Title: S5: A Simple Standards-Based Slide Show System
15:19:57 <bringert> dcoutts: great, thanks! I want to make a presentation that has lots of embedded video, so I figured xhtml slides with flash would be the best way to go.
15:19:59 <Saizan> dcoutts: you know if you can make a notification area/system tray icon with gtk2hs?
15:20:57 <dcoutts> Saizan: not immediately, you or we would have to bind the new notification area api in Gtk+ 2.10
15:21:14 <dcoutts> Saizan: but that's not too hard to do
15:21:48 <dcoutts> bringert: sounds sensible
15:22:44 <Saizan> dcoutts: i supposed so, btw how do gtk apps had such an icon prior of 2.10? specific DE apis?
15:22:53 <Toxaris> dcoutts: ok changed PATH before running gtk2hs installer and now it says it'll install for my ghc-6.6.
15:23:21 <dcoutts> Saizan: yes. It's now a FreeDesktop.org standard, and the Gtk+ impl works on Win32 too.
15:24:26 <dcoutts> Toxaris: ok good. And as I said, if you want it for 6.6.1 you'd need the latest beta which is at: http://haskell.org/gtk2hs/gtk2hs-0.9.11.3.exe
15:25:14 <Toxaris> there's an installer for it? I was scared by the info that i have to build gtk2hs myself on the website
15:25:44 <wli> Hmm, all possible substrings is not quite concatMap tails . inits
15:26:02 <dcoutts> Toxaris: it's the installer for the 1st release candidate of the next Gtk2Hs version
15:26:21 <glguy> Does anyone have a recommendation on a flash player for linux on x86_64?
15:26:31 <glguy> (native 64bit)
15:26:42 <dcoutts> glguy: not one that plays most available stuff
15:26:47 <dcoutts> eg youtube
15:26:53 <glguy> I just want something that will chime in gmail
15:27:01 <glguy> I don't care about youtube
15:27:15 * Igloo uses a separate browser in a 32-bit chroot. Also an easy way to stop pages using flash when I don't want them to
15:27:32 <glguy> I have no 32bit support compiled into this install
15:27:33 <dcoutts> I forgo flash
15:27:42 <glguy> I just want gmail chat to chime at me
15:27:46 <ddarius> dcoutts: Seems prudent.
15:28:07 <dcoutts> glguy: does that need flash? I seem to recall it pinging me and I don't have flash
15:28:15 <glguy> dcoutts: it does
15:28:20 <kolmodin> oh?
15:28:32 <glguy> needs flash to make sounds (according to the settings window)
15:28:34 <oerjan> > concatMap tails . tail . inits $ [1,2,3]
15:28:42 <lambdabot>  [[1],[],[1,2],[2],[],[1,2,3],[2,3],[3],[]]
15:28:44 <dcoutts> glguy: perhaps I was thinking of google talk
15:28:47 <ihope> Somebody in some channel some time ago mentioned cotypes. What's a cotype?
15:29:01 <glguy> its not mpletely coclear to me
15:29:06 <oerjan> > concatMap (init . tails) . tail . inits $ [1,2,3]
15:29:07 <monochrom> hahahaha
15:29:07 <lambdabot>  [[1],[1,2],[2],[1,2,3],[2,3],[3]]
15:29:12 <monochrom> Is it codata?
15:29:16 <dcoutts> ihope: probably meaning co-data rather than data
15:29:35 <wli> oerjan: Yeah, that seems to do it.
15:29:47 <oerjan> wli: except [] is missing
15:29:48 <dcoutts> ihope: which technically is defined via functors and minimal or maximal fixpoints, but more intuitively...
15:30:09 <wli> oerjan: That's fine. I don't want it.
15:30:35 <oerjan> > concatMap (init . tails) . inits $ [1,2,3]
15:30:35 <dcoutts> ihope: data is ordinary finite data structures, you know folds over them will terminate, and codata is potentially infinite and built by unfolding
15:30:37 <lambdabot>  [[1],[1,2],[2],[1,2,3],[2,3],[3]]
15:31:13 <Toxaris> dcoutts: ok 6.6 works :) now trying to install the pre-release and failing  with the first setup dialog (wich tell's about wdll paths and stuff). last time, i checked "I will resolve this later", but there isn't such a checkbox now. is it safe to change PATH temporary for the install, and later if i have problems executing my programs?
15:31:18 <monochrom> Alice: "Bob, you should learn Haskell, it's better!"  Bob: "la la la, I am not hearing you."  Alice: "cola cola cola, I am not talking to you!"
15:31:40 <dcoutts> ihope: the natural operation for data is a fold, the natural operation for codata is an unfold, in Haskell the two notions coincide, you can define both in a single type.
15:32:07 <glguy> so it should be cofold?
15:32:07 <ihope> I see.
15:32:13 <ihope> I think.
15:32:19 <dcoutts> ihope: some people think that's a bad thing, that data and codata should be separate (since the proof methods for them are fairly different)
15:32:48 <ihope> I'm all for it, since it sounds shiny. :-)
15:33:02 <dcoutts> Toxaris: should be, yes. Odd that the checkbox is missing though, thanks for reporting that.
15:33:06 <glguy> ugh, di.fm has commercials now... I like free stuff!
15:33:11 <Toxaris> co-data needs co-proofs?
15:33:20 <wli> Now to find all maximal substrings of s for which reads s succeeds.
15:33:20 <ihope> What's a coproof?
15:33:32 <dcoutts> Toxaris: in a sense, proofs using unfolds rather than folds
15:33:46 <monochrom> data is subject to induction proofs. codata is subject to coinduction proofs.
15:33:53 * Toxaris wonders why windows support for changing PATH is so bad
15:34:12 <oerjan> ihope: if it was me mentioning cotypes in #esoteric, then i just got it from a joke in here...
15:34:26 <monochrom> some coinduction proofs are bisimulation proofs.
15:34:29 <dcoutts> ihope: monochrom says it clearest :-)
15:34:51 <dcoutts> @google unappreciated unfold jones
15:34:54 <lambdabot> http://www.amazon.com/Duel-Sun-Jennifer-Jones/dp/6305307083
15:34:59 <dcoutts> hmm
15:35:00 <ihope> oerjan: yup, I think it was.
15:35:22 <dcoutts> ihope: http://citeseer.ist.psu.edu/gibbons98underappreciated.html
15:35:23 <lambdabot> Title: The Under-Appreciated Unfold - Gibbons, Jones (ResearchIndex)
15:35:59 <oerjan> @remember monochrom Alice: "Bob, you should learn Haskell, it's better!"  Bob: "la la la, I am not hearing you."  Alice: "cola cola cola, I am not talking to you!"
15:35:59 <lambdabot> Done.
15:36:49 <monochrom> Thanks. Here is an example to make it more concrete. Let's say someone wants to prove "map id xs = xs". If xs is a finite list, you use induction. If xs is an infinite list, you prove a bisimulation between "map id xs" and "xs".
15:37:08 <ihope> Would induction be stuff along the lines of "(P(0) & all x. P(x) => P(x+1)) => all x. P(x)"?
15:37:45 <monochrom> (P([]) & all x. P(x) => P(y:x)) => all x. P(x)
15:38:04 <monochrom> structural induction over list values.
15:38:20 <ihope> I won't ask about other kinds of induction. :-P
15:38:21 <monochrom> I missed an "all y" there somewhere.
15:38:40 <ihope> What's coinduction, then?
15:38:47 <Toxaris> so coinduction is like induction but without base case?
15:39:06 <monochrom> I have forgotten enough details of coinduction to explain it.
15:39:56 <monochrom> http://www.cs.ru.nl/B.Jacobs/PAPERS/JR.pdf was where I learned it. "A Tutorial on (Co)Algebras and (Co)Induction" by Bart Jacobs and Jan Rutten.
15:40:52 <monochrom> Andrew Gordon also has a tutorial paper on how to do bisimulation proofs for things like "map id xs = xs".
15:41:41 <wli> I think you get a tree like f s = case s of { [x] -> Leaf s ; (_:_:_) -> Branch s (init s) (tail s) }
15:43:26 <monochrom> Godawful, Andrew Gordon is at MSR too?  Is there anyone left?
15:43:43 <Toxaris> dcoutts: ok thanks, temporary changing PATH worked fine.
15:46:52 <Toxaris> dcoutts: but how could i have found the exe you pointed me too myself on the website?
15:47:30 <dcoutts> Toxaris: the first RC was only announced to the gtk2hs-users mailing list, not on the website yet. The final version will go there of course.
15:48:13 <monochrom> http://research.microsoft.com/~adg/Publications/details.htm#fp94  is Andrew Gordon's tutorial on coinduction proofs.
15:48:50 <dcoutts> Toxaris: we don't want to inflict buggy betas on everyone :-) so we only announce them initially to people who've subscribed to the list who are prepared to test and report bugs
15:49:33 <wli> unfoldTree (\s -> case s of { [_] -> (s,[]) ; (_:_:_) -> (s, [init s, tail s]) })
15:50:16 <chessguy> @type unfoldTree (\s -> case s of { [_] -> (s,[]) ; (_:_:_) -> (s, [init s, tail s]) })
15:50:18 <lambdabot> forall t. [t] -> Tree [t]
15:51:58 <wli> Next step is to go through the tree dropping tree nodes with no valid parse beneath them or at them and all tree nodes beneath those with a valid parse.
15:52:24 <chessguy> wli, what are you working on?
15:52:53 <wli> chessguy: Nothing in particular. Just the problem that one guy raised of reading from ambiguous strings etc.
15:53:13 <wli> chessguy: So basically "xyz2.45abc" is the test string here.
15:54:06 <chessguy> and you want to do what with it?
15:56:20 <timthelion> how do multifile projects work in haskell?
15:56:34 <chessguy> timthelion, via imports
15:57:06 <Toxaris> dcoutts: so i hope that the beta isn't too buggy and i don't have to change PATH again to fall back to an older ghc :)
15:57:13 <timthelion> chessguy: so if I import Foo.Go and there is another file in the same dir that provides Foo.Go that file will be loaded?
15:57:30 <chessguy> .Go?
15:57:39 <dcoutts> Toxaris: it should be ok, I don't expect many problems, but thanks for noticing the checkbox issue in the installer.
15:57:51 <timthelion> chessguy: huh?
15:58:00 <chessguy> haskell files should have extensions like .hs or .lhs
15:58:35 <oerjan> timthelion: the module Foo.Go needs to be in Foo/Go.hs
15:58:35 <timthelion> chessguy: well if I have a file that contains the line >module Foo.Go where...
15:58:45 <Toxaris> timthelion: module Foo.Go should live in file Foo/Go.hs or Foo/Go.lhs
15:58:51 <timthelion> ok
15:58:59 <timthelion> and then ghc will find it.
16:08:12 <Nucleo> @src (:)
16:08:13 <lambdabot> Source not found. Where did you learn to type?
16:09:15 <nominolo> @instances Monoid
16:09:16 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, Ordering, Product a, Sum a, [a]
16:09:36 <chessguy> @hoogle (:)
16:09:37 <lambdabot> Did you mean: (:)
16:09:37 <lambdabot> Prelude.undefined :: a
16:09:37 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
16:09:56 <nominolo> @info Monoid
16:09:56 <lambdabot> Monoid
16:10:09 <nominolo> @browse Monoid
16:10:09 <lambdabot> Unknown command, try @list
16:10:10 <wli> unfoldTree (\s -> case s of { [_] -> (s,[]) ; (_:_:_) -> (s, [init s, tail s]) }) is wrong.
16:10:22 <chessguy> @docs Monoid
16:10:22 <lambdabot> Monoid not available
16:10:27 <chessguy> @docs Data.Monoid
16:10:27 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Monoid.html
16:14:07 <hpaste>  slowriot pasted "why isn't the inferred type a Vector2?" at http://hpaste.org/1762
16:15:00 <Alleria_> chessguy: I don't see it in hoogle?
16:15:05 <wli> I basically need (prefix, string, suffix) triples where (prefix, string, suffix) is an ancestor of (prefix', string' suffix') whenever prefix' == prefix ++ crap1, suffix' == crap2 ++ suffix, and string == crap1 ++ string' ++ crap2
16:15:26 <chessguy> @type (:)
16:15:28 <lambdabot> forall a. a -> [a] -> [a]
16:15:43 <Alleria_> ahh, thanks.
16:15:56 <chessguy> it should be in the prelude
16:16:00 <chessguy> @docs Prelude
16:16:00 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
16:16:04 <wli> And each triple only occurs once in the tree/graph.
16:16:09 <ihope> @src Just
16:16:09 <lambdabot> Source not found. It can only be attributed to human error.
16:16:16 <ihope> Yay.
16:16:28 <Alleria_> (:) isn't on that page, chessguy
16:17:06 <monochrom> slowriot: I'm interested in the type of impulseIntegral
16:17:20 <chessguy> hm, indeed it's not
16:17:25 <Alleria_> is it just the return() of the List monad for the first a, ++ [a
16:17:27 <Alleria_> ?
16:17:47 <hpaste>  slowriot annotated "why isn't the inferred type a Vector2?" with "impulseIntegral" at http://hpaste.org/1762#a1
16:18:54 <slowriot> monochrom: there is a lot of context in this code. ^+^ means vector plus vector, .+^ means point + vector, etc....
16:19:10 <chessguy> hmm, i'm not sure (:) can be expressed in terms of other haskell
16:19:28 <monochrom> what about forceField?
16:19:34 <slowriot> I'll paste it
16:20:02 <hpaste>  slowriot annotated "why isn't the inferred type a Vector2?" with "forceField" at http://hpaste.org/1762#a2
16:21:37 <oerjan> slowriot: what is that "rec" keyword?
16:21:39 <monochrom> My last suspect is ((p0 .+^) ^<< integral)
16:21:57 <wli> So when reads fails to consume a suffix then the full suffix can be reconstructed.
16:22:00 <slowriot> oerjan: It corresponds to arrow's "loop". I don't know enough about arrows yet, but I'm trying to learn.
16:22:18 <oerjan> oh.
16:22:21 <chessguy> Alleria_, in the list monad, return a = [a]
16:22:40 <chessguy> (if that's what you're asking
16:23:07 <Alleria_> right, so you take the bare a, call return on it to get [a], and ++ it with the "other" [a] that gets passed in to cons?
16:23:20 <chessguy> it may also help to know that [1,2,3] is the same as 1:(2:(3:[])))
16:23:32 <slowriot> for my purposes rec, lets acceleration and velocity (a and v) be defined in terms of each other.
16:23:48 <chessguy> Alleria_, uh, what other [a]? i don't know what you're talking about
16:23:59 <Alleria_> (:) a [a]
16:23:59 <slowriot> I don't know why I put a comma between let and rec^
16:24:05 <chessguy> 1 : [2,3,4] == [1,2,3,4[
16:24:11 <oerjan> Alleria_: actually : is one of the primitive constructors for lists, it cannot be defined however since it has special syntax
16:24:24 <Alleria_> oerjan: ahh, that clears it up, thanks.
16:24:42 <Alleria_> my home-brew cons function works only for singleton lists. Anything bigger gets me a non-exhaustive match error.
16:25:04 <chessguy> Alleria_, paste it
16:25:05 <chessguy> @paste
16:25:06 <lambdabot> Haskell pastebin: http://hpaste.org/new
16:25:45 <Alleria_> chessguy: it's one line. Simply    cons a [b] = [a] ++ [b]
16:26:14 <Alleria_> which works if [b] is a singleton list. But will not pattern-match for arbitrary length lists.
16:26:26 <chessguy> ah
16:26:29 <oerjan> Alleria_: also, there is a pseudo-definition in http://haskell.org/onlinereport/standard-prelude.html
16:26:30 <lambdabot> Title: The Haskell 98 Report: Standard Prelude
16:26:36 <chessguy> you want cons a b = [a] ++ b
16:26:54 <Alleria_> chessguy: perfect, thank you!
16:27:09 <slowriot> monochrom: too much weird context for you, or are you still working on it?
16:27:13 <Alleria_> and thanks, oerjan
16:27:16 <chessguy> Alleria_, since the type dictates that b is a list already, you don't need the brackets on it
16:27:17 <nominolo> @src mconcat
16:27:17 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
16:27:30 <monochrom> I have run out of ideas.
16:27:31 <nominolo> @src Data.Monoid.mconcat
16:27:32 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
16:27:59 <oerjan> @src Monoid
16:28:00 <lambdabot> class Monoid a where
16:28:00 <lambdabot>     mempty  :: a
16:28:00 <lambdabot>     mappend :: a -> a -> a
16:28:00 <lambdabot>     mconcat :: [a] -> a
16:28:03 <slowriot> monochrom: okay, thanks though
16:28:03 <Alleria_> chessguy: ahh yes. <headslap>
16:29:15 <oerjan> 	mconcat = foldr mappend mempty
16:31:03 <chessguy> i'm not sure you can ever have brackets in a pattern-match other than an empty list. can someone point out another case?
16:33:13 <Toxaris> chessguy: you can
16:33:23 <shachaf> > let f [x] = x in f [5] -- Is this what you mean?
16:33:25 <oerjan> > let [a,b] = "hi" in (a,b)
16:33:25 <lambdabot>  5
16:33:26 <lambdabot>  ('h','i')
16:33:47 <pjd> chessguy: it desugars into (:) (as far as i understand it)
16:33:52 <Toxaris> chessguy: i often use it for quick-and-dirty argument processing in main
16:34:42 <Toxaris> main = do [a, b, c] <- liftM (map read) getArgs; print $ myFunc a b c
16:36:13 <Toxaris> how are smart constructors called in a OO setting? do they correspond to some well-known design pattern?
16:36:22 <chessguy> Toxaris, cute
16:36:53 <dcoutts> Toxaris: factories perhaps?
16:37:35 <Toxaris> smart factory :)
16:50:21 <dozer> there's something wrong when you've been coding haskell for 12 hours streight
16:50:48 <dolio> Or maybe... there's something right?
16:51:02 <dozer> well - it's starting to make sense
16:51:04 <ddarius> You realize that you should have been at work 5 hours ago?
16:51:09 <dozer> not sure if that's a good sign though
16:52:06 <dozer> ddarius: GMT
16:52:12 <dozer> and working from home today
16:52:29 <xelxebar> hello awesome Haskell users - would someone be willing to help me out with the case statement syntax?
16:52:53 <oerjan> certainly
16:52:59 <ddarius> Yes, the online Report.  Or the Gentle Introduction.
16:53:11 <dolio> Well, in that case, there's something very right: you got paid for fooling with haskell on company time. :)
16:53:48 <xelxebar> example:
16:53:49 <xelxebar> case foo of
16:53:49 <xelxebar>     "bar" -> 5
16:53:49 <xelxebar>     "bob" -> 5
16:53:49 <xelxebar>     "cat" -> 5
16:53:49 <xelxebar>     "dog" -> 3
16:54:13 <xelxebar> is there a way to compress the first three alternatives into one?
16:54:47 <dozer> dolio: wish it /was/ just fooling - I've done something like 4k lines of haskell in the past 7 days, and have to have this code running for the boss next Monday
16:54:58 <dolio> You can do 'case foo of { "dog" -> 3 ; _ -> 5 }' but that will match all strings besides "dog".
16:55:08 <oerjan> _ | foo `elem` ["bar","bob","cat"] -> 5
16:55:11 <xelxebar> I was thinking something like this:
16:55:11 <xelxebar> case foo of
16:55:11 <xelxebar>     "bar" | "bob" | "cat" -> 5
16:55:11 <xelxebar>     "dog" -> 3
16:55:11 <xelxebar> though, of course that doesn't work
16:55:58 <Toxaris> would be nice if it would work
16:56:05 <xelxebar> oerjan, what does the _| syntax signify?  sorry if it is a very n00bish question
16:56:22 <dolio> dozer: Ah, well, good luck.
16:56:30 <dozer> dolio: thanks
16:56:43 <Toxaris> xelxebar: _ means "take everything" but  | <cond> means "but only if the condition holds
16:57:04 <dozer> is there a form for crediting #haskell in publications? in the acknowledgements "Thankyou for all the support from users in #haskell at irc.freenode.net" or something?
16:57:25 <dons> dozer: yeah
16:57:59 <xelxebar> oh, duh.  should have remember that.  Thanks a lot!
16:58:11 <ddarius> dozer: And by "yeah" I think dons means "no".
16:58:12 <dolio> xelxebar: More technically, _ is like a regular variable (and matching with a variable in a case automatically succeeds), but _ isn't actually a variable name you can use except in pattern matches (essentially).
16:58:38 <dons> dozer: no, i mean 'yeah', you can just credit the irc channel, its been done before
16:58:46 <dolio> xelxebar: So matching with _ is like throwing the results away.
16:59:30 <dozer> oh - is haskell open-source? is there a prefered licence for contributing haskell code to the world?
16:59:42 <ddarius> Haskell is a language.
16:59:50 <dozer> yeah, but the libs and things
16:59:53 <ddarius> However, BSD style seems to be one of the more popular.
17:00:01 <dolio> > case 5 of r -> "Foo" ; 5 -> "Bar"
17:00:02 <lambdabot>      Warning: Pattern match(es) are overlapped
17:00:02 <lambdabot>              In a case alterna...
17:00:07 <xelxebar> I'm also unfamiliar with the `elem` syntax, namely the backticks.  is `elem` infix notiation for elem?
17:00:15 <dons> exactly
17:00:26 <dozer> xelxebar: yup - put backticks arround anything and it becomes infix
17:00:54 <Toxaris> dozer: really? i thought only variables
17:01:26 <oerjan> xelxebar: actually only single identifiers can be put in backticks
17:01:38 * dozer goes and sits in the corner
17:01:46 <Toxaris> > 1 `const (+) undefined` 2
17:01:46 <lambdabot>  Parse error
17:01:59 <ddarius> dozer, Toxaris: There are tricks to do that.
17:02:04 <Toxaris> is there a good cause for this restriction?
17:02:17 <ddarius> Toxaris: Obviously right off the bat, it is not nestable.
17:03:15 <Botje> @pl \(k,v) m -> insert k v m
17:03:15 <lambdabot> uncurry insert
17:03:20 <xelxebar> thanks!
17:03:21 <Botje> yay! I guessed correctly :)
17:03:47 <ddarius> Botje: Guessed?  After eta-reduction, it's obvious.
17:03:56 <Botje> yes
17:03:56 <jedai> > (> 4) `until` (+ 1) 5
17:03:57 <lambdabot>   add an instance declaration for (Num (a -> a))
17:04:02 <Toxaris> ddarius: tricks? ok, nesting is a problem, so we would need `expr¬¥
17:04:26 <nominolo> :t until
17:04:28 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
17:04:54 <nominolo> uhuh
17:04:59 <Saizan> > (> 4) `until` (+ 1) $ 5
17:05:01 <lambdabot>  5
17:05:21 <jedai> Priority problem :)
17:05:24 <Botje> @pl \(t:ts) m -> foldr (insert t) m ts
17:05:24 <lambdabot> ap (flip . foldr . insert . head) tail
17:05:29 <Botje> O_O
17:05:34 <Botje> that's fucking amazing.
17:05:42 <oerjan> that was a pretty one
17:06:06 <nominolo> nice.  although unmaintainable
17:06:16 <ddarius> It's longer than the input.
17:06:17 <Botje> not to mention longer.
17:06:22 <dons> ?unpl ap (flip . foldr . insert . head) tail
17:06:23 <lambdabot> ((\ l b c -> foldr (insert (head l)) c b) >>= \ e -> tail >>= \ d -> return (e d))
17:06:26 <Botje> what's the semantics of ap in (->) e, again?
17:06:35 <nominolo> ($)
17:06:58 <nominolo> @src (-> e) ap
17:06:58 <lambdabot> Source not found. You type like i drive.
17:07:01 <Botje> but it distributes the arguments, right?
17:07:06 <nominolo> @src ((->) e) ap
17:07:06 <lambdabot> Source not found. Do you think like you type?
17:07:13 <Botje> I know ap == liftM2 id
17:07:15 <ddarius> ap isn't a method of a class
17:07:19 <Saizan> ap f g = \x -> f x (g x)
17:07:20 <ddarius> Botje: Yes.
17:07:26 <ddarius> ap = S
17:07:48 <nominolo> > (+3) `ap` 4
17:07:49 <lambdabot>   add an instance declaration for (Num ((a -> b) -> a))
17:08:05 <oerjan> return = K
17:08:15 <ddarius> ask = I
17:08:18 <nominolo> > ((+3) `ap` (*5)) 45
17:08:18 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -> b
17:08:18 <lambdabot>     Probabl...
17:08:43 <Toxaris> > (+) `ap` )
17:08:43 <lambdabot>  Parse error
17:08:47 <nominolo> > ((+) `ap` (*5)) 45
17:08:49 <lambdabot>  270
17:09:03 * Toxaris should learn typing
17:09:14 <Botje> static or dynamic? *grins*
17:09:50 <Toxaris> :) static is ok, but irc is dynamic, you never know what the other people say in advance
17:09:59 <chessguy> @hoogle sequenceM
17:09:59 <lambdabot> No matches found
17:10:34 <chessguy> @hoogle sequence
17:10:34 <lambdabot> Prelude.sequence :: Monad m => [m a] -> m [a]
17:10:34 <lambdabot> Prelude.sequence_ :: Monad m => [m a] -> m ()
17:10:34 <lambdabot> Language.Haskell.TH.Syntax.sequenceQ :: [Q a] -> Q [a]
17:10:39 <Toxaris> chessguy: sequence is already monadic
17:11:13 <chessguy> ugh, that's not the one i want
17:11:30 <timthelion> is there a library for pulling in a tree structure with all the information about a directory and it's sub directories to be manipulated by pure functions?
17:11:54 <ddarius> > let x -| f = f x; (|-) = id in 3 -| flip (-) |- 5
17:11:55 <chessguy> i can never keep these functions straight
17:11:55 <lambdabot>  2
17:12:27 <Igloo> Well "conflicts" only makes sense for patches in parallel
17:12:29 <Igloo> Ooops
17:12:37 <Toxaris> ddarius: cool!
17:12:40 <chessguy> replicateM is what i was thinking of, in case anyone happens to care
17:12:59 <ddarius> Toxaris: It needs some fixity declarations for better usage.
17:13:05 <chessguy> @hoogle replicateM
17:13:06 <lambdabot> Control.Monad.replicateM :: Monad m => Int -> m a -> m [a]
17:13:06 <lambdabot> Control.Monad.replicateM_ :: Monad m => Int -> m a -> m ()
17:13:16 <ddarius> chessguy: That's what I thought you were thinking of.
17:13:17 <Botje> timthelion: tmoertel did a few articles about printing a directory tree, maybe you could steal that?
17:13:35 <timthelion> Botje: link?
17:13:38 <chessguy> ddarius, good thinking :)
17:13:50 <chessguy> @go haskell blog directory tree
17:13:50 <timthelion> chessguy: unfortunately for you symbol recognition is like the only rote skill that is required for computer programming.
17:13:55 <lambdabot> http://blog.moertel.com/articles/2007/03/07/directory-tree-printing-in-haskell-part-two-refactoring
17:13:55 <lambdabot> Title: Directory-tree printing in Haskell, part two: refactoring
17:14:10 <Botje> yeah
17:14:24 <chessguy> timthelion, that's ok, i'm too dumb to actually be any good at CS anyway
17:14:24 <timthelion> thanks
17:14:25 <Botje> i'm guessing part one and two would be most interesting
17:14:28 <chessguy> it's just fun :)
17:14:38 <MarcWeber> Does the decision to keep one large character array as buffer storage cause a speed penalty? I mean each time you insert a single character you have to move tons of characters following?
17:15:15 <oerjan> chessguy: remember you can search on the type of a function
17:15:44 <chessguy> oerjan, assuming i can actually remember or work out the type of the function i'm looking for
17:15:48 <timthelion> MarcWeber: well, that would be the difference between an array and a list.  emacs deals with that by having arrays for each line, and a list of line. to get maximum speed and memory efficiency.
17:15:58 <chessguy> oerjan, hoogle tends to be pretty picky when searching in that direction
17:16:07 <dozer> today's code compiles
17:16:09 <dozer> time for bed
17:16:42 <oerjan> chessguy: i know, but it is a possibility
17:17:07 <chessguy> oerjan, it was faster to look up some of my other code that caused me to beat my head against the wall similarly
17:17:22 <timthelion> MarcWeber: of course you don't want to keep a list linking every character, because a singly linked list ends up being a 4:1 efficiency ratio on 32 bit systems.
17:18:18 <MarcWeber> timthelion I've forgotten to tell that I'm talking about yi.
17:18:19 <MarcWeber>  _rawmem  :: !(Ptr CChar)     -- ^ raw memory           (ToDo unicode)
17:18:30 <timthelion> chessguy: that's how I do things,  I keep all my code well organized, and then amaze the newbs by writting 30 line bug free samples using copy paste and the kill ring.
17:18:40 <MarcWeber> Then there are some functions imelemented in C to find the start of line n etc ..
17:18:49 <chessguy> timthelion, learn emacs or die!
17:19:00 <MarcWeber> So I no longer wonder why yi dies when opening really large files..
17:19:14 <timthelion> chessguy: no, learn emacs, or fail to live.
17:19:26 <chessguy> true, i guess that's worse
17:20:07 <timthelion> MarcWeber: so is yi simply amazing yet?
17:21:22 <MarcWeber> I'm still trying to understand its code. I think it is if you think about the little manpower behind it..
17:22:51 <timthelion> hmm, I'll have to try it out someday.  right now I'm in a 15 day old emacs session that I hope doesn't crash because I'm re-organizing my home dir and all my paths would get messed up
17:23:48 <sgillespie> hello
17:23:52 <sgillespie> quick question
17:24:13 <sgillespie> specifically, how can I return IO
17:24:23 <chessguy> timthelion, you've had emacs open that long, or actually been runningn something that long?
17:24:39 <chessguy> sgillespie, not so quick :)
17:24:43 <MarcWeber> sgillespie What do you want to do exactly?
17:24:59 <MarcWeber> f = (return "somevalue" :: IO String)
17:25:48 <sgillespie> I really just want to return nothing
17:25:58 <chessguy> @type f = (return "somevalue" :: IO String)
17:26:05 <Saizan> ah, you usually return ()
17:26:05 <MarcWeber> sgillespie: return ()
17:26:06 <lambdabot> parse error on input `='
17:26:37 <MarcWeber> () si a special type to indicate exactly this. This type () has only the value () and nothing else.
17:26:39 <sgillespie> oh right
17:26:42 <ddarius> return undefined, that's a bit closer to actually nothing.
17:26:45 <sgillespie> i forgot the "return" keyword
17:26:53 <ddarius> return is not a keyword
17:27:06 <Toxaris> sgillespie: return isn't a keyword :)
17:27:06 <sgillespie> not a keyword? function?
17:27:13 <ddarius> :t return
17:27:15 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
17:27:34 <sgillespie> who says you don't learn something new everyday...
17:27:47 <Saizan> yes, it's a function, a method of the Monad class actually
17:29:39 <Saizan> sgillespie: in fact it doesn't exit from the current function like in imperative languages, it just wrap your pure value inside a monad, IO in this case
17:31:25 <Nucleo_> is there an easy way to build GoA? "Setup.hs configure" complains about not finding the "arrows-any" dependency
17:31:35 <Saizan> so do return (); otherAction   will also perform otherAction returning its result, rather than ()
17:31:55 <Saizan> Nucleo_: you can get that package on hackage
17:32:13 <ddarius> Or just ignore the dependency I hear.
17:32:35 <Saizan> some distros have binaries for those extralibs packages too
17:33:21 <Nucleo_> Saizan: thank you
17:38:13 * wli tries to figure out what this constraint-based type inference is in case it's an easier way to handle all this crap.
17:51:26 <wli> I guess for straight-up H-M you can just set up a system of unification constraints and go about resolving them after they've been set up in some way so as to produce most general unifiers.
17:51:54 <shazam> hey guys, I have users input a parsec grammar of the form a = ( a >>= \x -> (string "a" >> return (f1 x))) <|> (string "blah" >> a >>= \x -> return (f2 a)) <|> ...
17:52:02 <shazam> unfortunately these grammars might be left recursive
17:52:22 <wli> shazam: I complained about that recently myself.
17:52:37 <shazam> refactoring like so: http://en.wikipedia.org/wiki/Left_recursion
17:52:39 <lambdabot> Title: Left recursion - Wikipedia, the free encyclopedia
17:52:39 <shazam> is impossible
17:52:45 <shazam> because of the return statements
17:53:10 <wli> shazam: My only thought on that front is to plug in a different engine beneath the combinators, one that handles left recursion.
17:53:17 <SamB> hmm... the second hit for my name is on amazon.com, but it's actually *me*
17:53:20 <SamB> how about that?
17:53:35 <SamB> I didn't even have to write a book
17:53:55 <shazam> (typo, should be (f2 x))
17:53:57 <wli> shazam: This is clearly a bit more work than you were hoping for.
17:54:04 <shazam> wli, a different engine might not help
17:54:32 <wli> shazam: My thought was to plug in a GLR engine behind the parser combinators, which would.
17:54:48 <shazam> wli, but we're making use of the haskell = operator
17:55:01 <shazam> we're encoding it into lambda calculus
17:55:05 * SamB is quite proud of the sixth hit
17:55:24 <shazam> a GLR engine needs the grammar in BNF form
17:55:39 <shazam> however, all we can give it is a (possibly infinite) lambda term
17:56:19 <wli> shazam: In that sense it's not as flexible as recursive descent.
17:56:53 <shazam> but, erm, does anyone have any suggestion for automatic refactoring? (considering the grammar is one production and rather simple)
17:57:50 <ddarius> That other Derek Elkins has been busy.
17:57:52 <oerjan> divide it into two terminals, one containing those that don't start with a?
17:58:03 <oerjan> *non-terminals
17:59:36 <shazam> oerjan, so we get two productions: a1 = string "blah" >> a1 >>= (\x -> return (f2 x)) and a2 = ( a2 >>= \x -> (string "a" >> return (f1 x)))
17:59:38 <shazam> then what?
17:59:42 <wli> I've not seriously thought about refactoring like that. GLR is the answer to any/all issues I've got with all this, apart from perhaps a direct attack on context-sensitive grammars.
18:00:25 <shazam> wli, it's a little trickier than that; one approach is to redefine application (see Arrows)
18:02:13 <oerjan> also, you want a non-terminal for whatever comes after the left-recursive a
18:02:45 <wli> shazam: Yeah, you're doing something different from building a parse tree.
18:03:48 <shazam> well, erm, arrows was the hope
18:03:51 <shazam> but nothing came of it
18:04:03 <shazam> oerjan, so what does the grammar become?
18:04:27 <oerjan> lessee..
18:05:54 <oerjan> a1 = string "blah" >> a >>= (\x -> return (f2 x))
18:06:30 <oerjan> a2 x = string "a" >> return (f1 x)
18:07:25 <shazam> then what?
18:07:38 <oerjan> a = foldl1 (>>=) a1 >>= a2
18:07:47 <oerjan> or something like that
18:08:24 <oerjan> er, not that
18:14:14 <anculz> http://rectum.antiville.fr/
18:14:16 <lambdabot> Title: Miniville
18:14:16 <anculz> http://rectum.antiville.fr/
18:14:17 <lambdabot> Title: Miniville
18:14:21 --- mode: ChanServ set +o dons
18:14:22 --- mode: dons set +b *!*i=sponsz@*.fbx.proxad.net
18:14:23 --- kick: anculz was kicked by dons (dons)
18:14:31 --- mode: ChanServ set -o dons
18:15:30 * pjd cooks up Maybe in JavaScript
18:16:07 <oerjan> a2s x = (a2 x >>= a2s) <|> return x
18:16:16 <oerjan> a = a1 >>= a2s
18:16:53 <shazam> wait, I think it can be done with mutually recursion...
18:17:01 <shazam> oerjan, sure that'll work?
18:17:14 <oerjan> i think my last attempt may work...
18:17:20 <oerjan> not sure
18:19:43 <oerjan> that a2s definition is essentially a variant of chainl which allows each parser to use the output of the previous one.
18:20:24 <shazam> that looks insane!
18:22:04 <shazam> ah, righto
18:22:16 <shazam> from what I see, that parser can't fail
18:22:23 <shazam> it just runs in a loop
18:22:26 <shazam> does it not?
18:22:31 <shazam> hrmph, maybe I'm wrong
18:25:09 <dolio> Well, it looks like you're defining a variant of many.
18:25:17 <ddarius> @src many
18:25:17 <lambdabot> Source not found. Take a stress pill and think things over.
18:25:59 <dolio> Which is typically defined something like: 'many p = many1 p <|> return () ; many1 p = p >> many p'
18:26:18 <dolio> Which, if you inline many1, I think you get a2s.
18:27:16 <dolio> Modulo the passing around of results that's in a2s.
18:27:56 <dolio> I guess many(1) usually collects a lits of parses, but I got lazy. :)
18:28:36 <shazam> so how could it be done with many1?
18:30:29 <dolio> Well, I haven't been paying that much attention, but...
18:31:36 <dolio> a2s = many a2
18:31:39 <xpika> is there a parsec for parsing things other than strings?
18:31:42 <oerjan> lost connection
18:31:51 <oerjan> now, a2s /= many a2
18:31:57 <oerjan> *no
18:32:01 <dolio> a2 = string a >> return f1
18:32:05 <oerjan> because it chains the result
18:32:12 <dolio> Er, string "a"
18:32:19 <oerjan> a2s fails when an a2 fails
18:34:02 <dolio> a = a1 >>= \x -> a2s >>= \fs -> foldr ($) x fs
18:34:07 <oerjan> each production of a is either an a1, which does not recurse, or a a2
18:35:16 <dolio> But I was just remarking that a2s looks as correct/terminates just as much as many does.
18:35:53 <shazam> xpika, parsec can parse anything, I think
18:36:11 <shazam> oerjan, righto
18:36:39 <oerjan> but if you expand that, you see that each a is a1 a2 ... a2
18:37:42 <Botje> @pl \k m -> insert k t m
18:37:43 <lambdabot> flip insert t
18:37:56 <oerjan> so that gives the refactoring of the grammar itself - then it is just a question of getting the arguments chained correctly
18:38:21 <dolio> @pl a1 >>= \x -> a2s >>= \fs -> foldr ($) x fs
18:38:21 <lambdabot> (a2s >>=) . foldr id =<< a1
18:38:51 <oerjan> dolio: that is not correct because a2s takes an argument
18:39:05 <oerjan> (passed on from the preceding a)
18:39:49 <dolio> My rewritten version of a2s using many doesn't take an argument.
18:39:49 <oerjan> otoh...
18:40:21 <dolio> It returns a list of functions to be applied to something, instead of applying them as it parses.
18:40:50 <oerjan> yes, that works for shazam's example because the parser action does not depend on the argument, only its result does
18:41:13 <shazam> that's right!
18:41:59 <oerjan> so you can combine results after parsing, which many does fine
18:43:47 <dolio> Incidentally, I think the nice pl for that expression is: "foldr ($) <$> a1 <*> a2s"
18:44:10 <dolio> If you use the many version.
18:44:46 <shazam> okay guys, if you wait 5 minutes I'll write all of this up
18:46:01 <shazam> so the answer is foldr ($) <$> a1 <*> a2s ?
18:46:39 <dolio> If you're looking to reuse as much from Control.Applicative as possible. oerjan's solution seemed fine to me.
18:47:28 <shazam> ok, I'll tell you guys if it works
18:47:28 <shazam> one sec
18:49:17 <oerjan> my version has the advantage, if you need it, that the actual parser used can depend on the argument passed to it.
18:50:25 <dolio> Also, note that I assumed the function was associative. To mimic oerjan's solution exactly, it'd have to be "foldl (filp ($)) <$> a1 <*> a2s" I think.
18:50:43 <shazam> oh wait
18:50:58 <dolio> Wait, no, that doesn't matter.
18:50:58 <shazam> I forgot to mention that I don't have Perser x per say
18:51:12 <shazam> I only have several Parser x -> Parser x
18:51:17 <shazam> and Ijust take their fixed point
18:51:29 <shazam> each Parser x -> Parser x represents an alternative
18:52:00 <shazam> oh wait, that doesn't matter
18:52:10 <mphill22> http://www.youtube.com/watch?v=u_aY7HZvFpQ
18:52:12 <mphill22> RICKRAINROLLED
18:52:28 <mphill22> oops wrong channel lul
18:53:55 <shazam> http://rafb.net/p/HGTEtc68.html
18:53:57 <lambdabot> Title: Nopaste - No description
18:54:03 <shazam> I get a type error
18:55:05 <oerjan> a2 :: Term -> Parser Term
18:55:34 <dons> use hpaste.org, shazam/palomer ;) rafb/lisppaste is deprecated.
18:55:40 <shazam> okay!
18:55:54 <glguy> lol, deprecated
18:56:02 <dons> (it will announce the paste in channel)
18:56:14 <chessguy> obsolete :)
18:56:39 <shazam> oerjan, why that type? I thought a2 represented all the left recursive productions
18:56:41 <xelxebar> :)
18:57:14 <oerjan> shazam: a2 represents what's left of an a production after you remove the initial a
18:57:35 <oerjan> so it takes the argument returned by that a
18:57:42 <shazam> oerjan, ahh, righto!
18:58:17 <shazam> oerjan, does it matter that the resulting production might still be left recursive?
18:59:03 <oerjan> i don't see how it can be
18:59:22 <shazam> a = a >> a >> string "b"
18:59:52 <oerjan> since an a can never start with an a2
19:00:37 * wli fails to figure out what constraint-based type inference means and starts falling asleep.
19:00:58 <shazam> wli, I think it means that you collect equality constraints and then solve at the end
19:01:03 <shazam> instead of solving in place
19:01:10 <oerjan> you must eventually get down to an a1, which is per definition not left recursive
19:01:52 <shazam> and how do I construct this a2s?
19:02:15 <oerjan> you mean a2?
19:02:24 <wli> shazam: The two missing points being how one ensures a most general unifier without some sort of dependency analysis and what it does with type classes.
19:02:30 <shazam> oerjan, err yeah, a2
19:02:41 <wli> shazam: Or if a dependency analysis happens, how it happens.
19:02:58 <oerjan> you take those alternatives in a that start by parsing a left recursively.
19:05:21 <oerjan> you then replace a with (return x) and put \x -> in front (for some unique x)
19:05:39 <oerjan> (only that first a should be replaced)
19:07:29 <shazam> holy crap
19:07:29 <shazam> it works
19:07:33 <shazam> HOLY HOLY CRAP
19:08:01 <oerjan> :)
19:08:06 <monochrom> haskell is amazing
19:08:38 <shazam> I didn't think it was possible
19:09:50 <shazam> this is nuts
19:10:11 <wli> Quick and dirty dependency thought: a type represents the type of some declared variable, so that creates a dependency edge to all types referenced in the body of the definition.
19:12:12 * shazam is flabergasted
19:13:03 <shazam> I don't get how it works though:O
19:13:44 <shazam> the a1 >>= a2s baffles me
19:14:27 <monochrom> Does "do { x <- a1; as2 x }" help?
19:14:37 <oerjan> it means roughly: first parse an a that is not left recursive, then use that a as the left recursive part of the rest
19:15:07 <shazam> what if you have:
19:15:26 <shazam> a1 = string "b" >> a >> "string b"
19:16:06 <oerjan> ok
19:16:28 <oerjan> er, maybe you mean string "b" at the end too
19:16:35 <shazam> err ,yeah
19:17:43 <shazam> err
19:17:44 <shazam> make that
19:18:10 <shazam> a1 = \z -> string "b" >> z >> string "b"
19:18:23 <oerjan> a1 should not take an argument
19:18:27 <shazam> righto
19:18:29 <shazam> ok
19:18:34 <shazam> a1 = string "b" >> a1 >> "string b"
19:18:50 <shazam> pfff
19:18:54 <shazam> a1 = string "b" >> a1 >> string "b"
19:19:06 <oerjan> that's infinite recursion in any case :)
19:19:25 <monochrom> It will always say "parse error".
19:19:30 <shazam> a1 = string "b" >> a1 >> string "b" <|> string "d"
19:19:42 <shazam> a1 = (string "b" >> a1 >> string "b") <|> string "d"
19:20:16 <oerjan> that should be fine, and is not left recursive
19:20:27 <monochrom> That will accept exactly b+db.
19:21:00 <monochrom> x = x >> y   is left recursive.
19:21:03 <shazam> a2 x = a2 >> string "e"
19:21:32 <oerjan> type error!
19:21:40 <shazam> erm?
19:21:53 <shazam> ah, righto
19:22:09 <monochrom> c = (string "" <|> string "a") >> c >> ...  is left recursive too, due to the empty string taking priority.
19:22:37 <oerjan> however, a2 cannot mention itself because it has been constructed from a, which doesn't mention a2
19:22:40 <shazam> a2 x = let a2' = a2' >> string "e" in a2'
19:23:02 <monochrom> That is left recursive.
19:23:10 <shazam> hrmph
19:23:15 <shazam> maybe we should deal with saner primitives
19:23:25 <monochrom> the parameter x doesn't help.
19:23:32 <shazam> that is, elements of  Parse Term -> Parse Term
19:23:44 <monochrom> I don't see a need.
19:23:47 <shazam> which represent the alternatives of the production
19:23:55 <shazam> that's what I'm starting with!
19:23:56 <monochrom> And I don't see how.
19:25:20 <oerjan> in the case of the a2' i would assume you refactor a2' first before using it in a.
19:25:54 <oerjan> if you have mutual left recursion things might get more complicated.
19:26:34 <oerjan> and i barely dare to mention null productions...
19:26:56 <monochrom> I dared. c = (string "" <|> string "a") >> c >> ... :)
19:29:13 <hpaste>  shazam pasted "what we've talked about" at http://hpaste.org/1763
19:29:39 <shazam> so that parses "I am tom you silly man"
19:29:48 <shazam> but does not parse "I am tom the courageous you silly man"
19:30:51 <shazam> it does parse "tom the courageous"
19:32:08 <shazam> [ParseElement] is what I use to encode the grammar
19:32:15 <shazam> there's only one nonterminal, Top
19:32:33 * oerjan is too tired to think.
19:33:01 <shazam> oh no!
19:33:05 <shazam> come back!
19:33:34 <shazam> I didn't even get a chance to thank him
19:37:46 <dmwit> shazam: I bet it parses even-length strings only.
19:37:50 <dmwit> (Just a guess.)
19:38:00 <shazam> :O)
19:38:21 <monochrom> haha, that's interesting :)
19:39:49 <dmwit> Never mind, looking at the code I see that you didn't just pick those strings out of mid-air. =P
19:42:22 <shazam> which strings?
19:45:30 <shazam> there was a typo (which still didn't fix anything)
19:45:35 <dmwit> "I am tom ..." and friends
19:46:05 <MarcWeber> Does anyone know of a rs232 library ?
19:47:28 <hpaste>  shazam pasted "typo fixed" at http://hpaste.org/1764
19:47:39 <shazam> righto
19:48:35 <monochrom> Hey, did you know "annotate"?
19:48:59 <shazam> annotate?
19:49:18 <shazam> you mean, comment?
19:49:40 <monochrom> Click on the "annotate" link to paste an amendment or a correction or ...
19:49:48 <shazam> ah, righto
19:49:56 <shazam> I actually corrected a few typos, though most didn't matter
19:50:07 <hpaste>  Toxaris annotated "typo fixed" with "example" at http://hpaste.org/1764#a1
19:50:20 <monochrom> Helps keep related things together. No big deal if you really want a fresh start. :)
19:51:20 <shazam> gotcha!
19:52:05 <shazam> anyways, I'm off to bed
19:52:13 <shazam> I'll tackle this problem tomorrow
19:55:40 <dons> crikey, http://porg.es/blog/computing-with-xslt  :)
19:55:53 <lambdabot> Title: Computing with XSLT at porges
19:58:40 <dolio> "Since this function involves pattern-matching it is an ideal candidate for implementation in XSLT"
19:58:47 <dolio> I think that might be overstating the case.
19:58:58 <dons> heh
19:59:11 <SamB> @hoogle icfp 2006 xslt
19:59:12 <lambdabot> Hoogle Error: Parse Error: Unexpected character '2006 xslt'
19:59:14 <SamB> @google icfp 2006 xslt
19:59:16 <lambdabot> http://mayah.jp/personal/resume
19:59:17 <lambdabot> Title: Shinya Kawanaka -- MAYAH.JP
19:59:23 * SamB is experiencing heat trouble
20:00:25 <SamB_XP> http://www.network-science.net/icfp2006/code/xml.adv
20:00:27 <lambdabot> Title: code
20:00:45 <SamB_XP> this is a document that favoroubly compares o'cult to XSLT
20:01:04 <SamB_XP> (if you take out that pesky least-needed most-heeded rule)
20:01:08 <sfultong> Am I right to think that Debug.Trace does not work in a return statement?
20:01:25 <SamB_XP> sfultong: not precisely
20:01:33 <ddarius> Debug.Trace.trace works everywhere.
20:01:41 <SamB_XP> it does something, but it would trace sooner if you put it further to the left
20:02:20 <sfultong> well... I'm in a maybe monad, which returns Just a... but I don't get the trace to print out in the return ...
20:02:35 <SamB_XP> maybe
20:02:42 <SamB_XP> that part of the code is short-circuited?
20:02:56 <ddarius> sfultong: The trace message is only outputted when and if the result is evaluated.
20:03:03 <SamB_XP> try the Either e monad instead
20:03:30 <sfultong> but wait... the rest of the do block in the maybe is evaluated
20:03:51 <sfultong> as evidenced by working Debug.Trace output
20:03:56 <SamB_XP> ah.
20:04:08 <SamB_XP> so you must not use the result of that return!
20:04:22 <SamB_XP> also I bet you think return is supposed to skip whatever else is in the do?
20:04:29 <SamB_XP> it isn't and won't ;-)
20:04:52 <SamB_XP> > do return 1; return 2 :: Maybe Int
20:04:54 <lambdabot>  Just 2
20:05:02 <sfultong> right, I got that part at least...
20:05:21 <SamB_XP> > do fail "aaaaaah!"; return 2 :: Maybe Int
20:05:22 <lambdabot>  Nothing
20:05:27 <sfultong> so would ghc evaluate the maybe, but then ... not use it?
20:06:04 <dmwit> No, it likely won't even evaluate it.
20:06:34 <sfultong> yes, so then my problem is not so simple, because it is evaluated
20:06:34 <dmwit> It stores a "thunk" saying how to evaluate it later, if it needs it, then garbage-collects the thunk when it's sure it could never be needed.
20:06:44 <SamB_XP> even if you have a value of type Maybe Int in WHNF, and it turns out to be a Just value, the Int field might be _|_
20:06:47 <Toxaris> > isJust (return $ error "ahhh!")
20:06:48 <dmwit> sfultong: Care to paste it?
20:06:48 <lambdabot>  True
20:06:50 <dmwit> ?paste
20:06:50 <lambdabot> Haskell pastebin: http://hpaste.org/new
20:07:09 <chessguy> @src isJust
20:07:09 <SamB_XP> Toxaris: exactly!
20:07:09 <lambdabot> isJust Nothing = False
20:07:10 <lambdabot> isJust _       = True
20:07:11 <sfultong> dmwit: sure
20:07:30 <chessguy> heh. yeah, it's not Nothin
20:07:32 <chessguy> g
20:07:53 <sfultong> dmwit: wait, can I PM it to you, since it's kinda long... and can you receive PMs from non-registered people?
20:08:07 <dmwit> sfultong: Longer than 5KB?
20:08:10 <SamB_XP> sfultong: paste it on hpaste
20:08:14 <dmwit> Then no, don't PM me.
20:08:21 <sfultong> heheh, not longer than 5K
20:08:29 <dmwit> Yeah, then use hpaste.org.
20:08:41 <sfultong> I'm unfamiliar with hpaste, other than seeing it's output here once in a while
20:08:46 <dmwit> ...
20:08:50 <SamB_XP> sfultong: go to the above URL
20:09:03 <SamB_XP> type things in fields
20:09:09 <sfultong> ah, thanks
20:09:09 <SamB_XP> paste your stuff in the big one
20:09:35 <chessguy> hpaste is a complicated web app :)
20:09:54 <hpaste>  sfultong pasted "(no title)" at http://hpaste.org/1765
20:09:59 <SamB_XP> it's roughly as complicated as a Xmonad ;-P
20:10:09 <Toxaris> chessguy: it doesn't say what it does anywhere
20:10:14 <hpaste>  cdsmith pasted "type class hackery questions" at http://hpaste.org/1766
20:10:26 <cdsmith> any help with the above is appreciated. Thanks :)
20:10:27 <chessguy> @quote complicated
20:10:27 <lambdabot> chessguy says: [<newsham> (if complicatedly is indeed a word)] <chessguy> newsham, if it's not a word, just define it and add it to the language. that's what FP is is all about, right?
20:10:46 <SamB_XP> cdsmith: estimated milliolegs required?
20:10:56 <cdsmith> milliolegs?
20:11:06 <SamB_XP> @quote oleg
20:11:06 <lambdabot> edwinb says: where does 'Oleg cornered me in a pub and explained delimited continuations to me' fit in?
20:11:15 <SamB_XP> @quote oleg
20:11:15 <lambdabot> OlegFacts says: Oleg is a delimited continuation.
20:11:19 <SamB_XP> @quote oleg
20:11:19 <lambdabot> OlegFacts says: When Oleg writes code, the typechecker asks *him* if it's correct.
20:11:44 <cdsmith> I don't know.  This is my first attempt at real type wizardry stuff
20:12:01 <SamB_XP> cdsmith: so why are you using OPTIONS_GHC -X instead of LANGUAGE?
20:12:16 <cdsmith> SamB: Because I don't know what LANGUAGE is
20:12:24 <dmwit> sfultong: What are your symptoms?
20:12:34 <SamB_XP> @google GHC pragmas
20:12:36 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/rewrite-rules.html
20:12:36 <lambdabot> Title: 7.11. Rewrite rules
20:12:43 <SamB_XP> hmm. not quite.
20:12:49 <monochrom> hahahaha great facts about Oleg :)
20:12:57 <sfultong> dmwit: "from source (-1,0) isJust True
20:12:57 <sfultong> "
20:13:21 <SamB_XP> cdsmith: http://www.haskell.org/ghc/docs/latest/html/users_guide/pragmas.html#language-pragma
20:13:24 <lambdabot> Title: 7.10. Pragmas, http://tinyurl.com/y9jo69
20:13:41 <cdsmith> SamB: Ah, thanks much.  I'll change that.
20:13:56 <SamB_XP> cdsmith: that has the advantage of working in a released compiler, too ;-)
20:14:30 <dmwit> :t lookupFM
20:14:39 <lambdabot> Not in scope: `lookupFM'
20:14:45 <dmwit> :t Data.FiniteMap.lookupFM
20:14:46 <sfultong> returns Maybe a
20:14:47 <lambdabot> Couldn't find qualified module.
20:14:49 <chessguy> sfultong, i came in partway through the conversation, what is your problem with the code you pasted?
20:14:56 <dmwit> :t FiniteMap.lookupFM
20:14:57 <lambdabot> Couldn't find qualified module.
20:15:04 <dmwit> ...
20:15:07 <dmwit> ?index lookupFM
20:15:07 <lambdabot> Data.FiniteMap, Data.Graph.Inductive.Internal.FiniteMap
20:15:16 <sfultong> chessguy: Debug.Trace in the return statement doesn't print... but the rest in the maybe monad does
20:15:20 <dmwit> ?hoogle lookupFM
20:15:20 <lambdabot> Data.FiniteMap.lookupFM :: Ord key => FiniteMap key elt -> key -> Maybe elt
20:15:20 <lambdabot> Data.Graph.Inductive.Internal.FiniteMap.lookupFM :: Ord a => FiniteMap a b -> a -> Maybe b
20:15:37 <dmwit> sfultong: Oh, well you're probably not using the result of the function call then.
20:16:13 <sfultong> but then wouldn't the rest of the function not be evaluated?
20:16:15 <dmwit> Specifically, you probably aren't using the result of "moveOverTerrain", somehow.
20:16:32 <sfultong> ok... let me post some more code then
20:16:38 <dons> is a' the type constructor in this OCaml:
20:16:42 <dmwit> sfultong: Not necessarily, it may need to know that it is a "Just", but not what is inside the Just.
20:16:43 <dons> type 'a t = Empty
20:16:43 <dons>            | Node of 'a t * int * 'a * 'a t * int * int
20:16:44 <dons> 'a  I mean.
20:17:02 <dmwit> In which case it would have to evaluate the first one to make sure it wasn't Nothing, and hit the first trace.
20:17:13 <cdsmith> SamB: Hmm. GHC just keeps saying: cannot parse LANGUAGE pragma
20:17:30 <Toxaris> sfultong: every subexpression of every expression is lazily evaluated (or not evaluated), not just whole functions (whatever "whole function" may mean)
20:17:32 <SamB_XP> cdsmith: what does yours look like?
20:17:44 <hpaste>  sfultong pasted "Debug.Trace confusion" at http://hpaste.org/1767
20:18:23 <hpaste>  cdsmith pasted "language pragmas" at http://hpaste.org/1768
20:18:41 <sfultong> I don't believe I only use the "Just" part of that function...
20:19:07 <SamB_XP> cdsmith: it says it can't parse *any* of those?
20:19:34 <cdsmith> Umm, I guess line 1.  I was being silly, and didn't realize it could just not like some of the names.
20:19:39 <dons> http://programming.reddit.com/info/27lin/details  :)
20:19:40 <lambdabot> Title: Computing with XSLT (you can&#39;t escape functional programming) (reddit.com)
20:19:44 <SamB_XP> cdsmith: huh
20:19:58 <SamB_XP> I don't know why it would like something with -X and not with {-# LANGUAGE
20:20:01 <cdsmith> Ah, yeah.  It's just some lines.
20:20:33 <dmwit> sfultong: Hmmm...
20:20:33 <Toxaris> sfultong: the "result" part of that function is named nextMap, and stored in some roomMap field of some st record, but it is *not* evaluated (in the code you show)
20:20:33 <SamB_XP> are they all listed in http://www.haskell.org/ghc/docs/latest/html/libraries/Cabal/Language-Haskell-Extension.html ?
20:20:36 <lambdabot> http://tinyurl.com/2xjyqs
20:20:43 <dmwit> What happens if you switch the "trace" call and the "return" call?
20:21:00 <cdsmith> SamB: TypeOperators and AllowUndecidableInstances.  Ah, no they are not.
20:21:35 <chessguy> sfultong, what is this program anyway?
20:21:37 <SamB_XP> Igloo: do you know what the deal is here? did someone drop the ball?
20:21:44 <ddarius> dons: No, t is.
20:22:08 <ddarius> dons: Remember, *ML is -ugly-.
20:22:19 <sfultong> chessguy: a rogue-like game I'm writing, just to get my haskelling skills up
20:22:23 <cdsmith> Okay, so it didn't need TypeOperators, and I resolved the other.  Back to the original problem, then.
20:22:23 <dons> oh, 'a t --> IntMap a ?
20:22:26 <SamB_XP> I guess GHC 6.8 isn't released yet, so perhaps nobody has dropped any balls yet ;-)
20:22:39 <dmwit> sfultong: Oh, there's another paste.
20:22:43 <dons> ddarius: yes, the syntactic horror
20:23:20 <ddarius> data T a = Empty | Node (T a) Int a (T a) Int Int
20:23:34 <dons> right, so its IntMap :)
20:23:39 <dmwit> sfultong: You realize, of course, that unless you can actually trace these calls all the way back up to something that does I/O on them, GHC is likely to just not evaluate them, right?
20:23:40 <ddarius> If you say so.
20:23:52 <dons> ah not quite, more a specialised Map
20:23:56 <dons> data IntMap a = Nil
20:23:57 <dons>               | Tip {-# UNPACK #-} !Key a
20:23:57 <dons>               | Bin {-# UNPACK #-} !Prefix {-# UNPACK #-} !Mask !(IntMap a) !(IntMap a)
20:24:06 <sfultong> dmwit: yes... this could be a long unraveling...
20:24:11 <dons> data Map k a  = Tip
20:24:11 <dons>               | Bin {-# UNPACK #-} !Size !k a !(Map k a) !(Map k a)
20:24:13 <dons> ^^
20:24:25 <dmwit> sfultong: As a side note, if you're writing this from scratch, I would recommend using Data.Map rather than Data.FiniteMap.
20:24:56 <sfultong> dmwit: ok, how come? actually, I've been using Data.IntMap now that I've discovered it...
20:24:58 * glguy considers posting FLASH WARNINGS in the spirit of othe rpeople's PDF WARNINGS on reddit
20:25:08 <chessguy> @yow
20:25:08 <lambdabot> I hope I bought the right relish ... zzzzzzzzz ...
20:25:28 <dmwit> sfultong: Well, for one thing, the documentation is better. ;-)
20:25:32 <sfultong> heheh
20:25:32 <ddarius> Data.FiniteMap is old if not deprecated.
20:25:50 <ddarius> I thought it was already gone.
20:26:00 <dmwit> I think Data.Map does everything Data.FiniteMap did, at least as fast, and has additional features that FM doesn't have.
20:26:08 <ddarius> glguy: That would be acceptable.
20:26:18 <dmwit> If that's not a good enough reason to switch, I don't know what is.
20:26:34 <Toxaris> sfultong: is this more about getting debug output to work or more about understanding what's going on?
20:27:15 <sfultong> toxaris: well, I like understanding things... debugging is only the process to understanding
20:27:28 <sfultong> I suppose there may be those who debug for the pleasure of debugging
20:28:03 <sfultong> yeah, Data.Map seems MUCH more full-featured
20:28:40 <sjanssen> whyFM wouldFM anybodyFM useFM FiniteMapFM?
20:28:49 <sfultong> unfortunately my code isn't abstracted away from the datatype very much...
20:29:27 <sfultong> sjanssen: because it was the first thing I stumbled upon in the GHC documentation? :-P
20:29:31 <ddarius> All you have to do for the most part is s/FM// and s/FiniteMap/Map
20:29:53 <sfultong> yeah, I suppose it wouldn't be too bad
20:30:01 <sjanssen> sfultong: you might be able to write a very clever search and replace to swap with Data.Map
20:30:12 <sjanssen> the FM at the end of every identifier helps
20:30:12 <sfultong> but laziness is important.... and that's why I'm using haskell
20:31:21 <sfultong> also, although it would probably improve my productivity in the long run, I haven't tried using regexes in search/replace
20:31:39 <hpaste>  Toxaris annotated "(no title)" with "what about this?" at http://hpaste.org/1765#a1
20:32:37 <ddarius> All it would have to be is a list of old-identifier and new-identifier
20:33:46 <dmwit> Toxaris: Have a try at using GHCi, it's more interactive and useful (in my opinion) than trace.
20:34:06 <Toxaris> dmwit: I know :)
20:34:44 <sfultong> Toxaris: thanks, I'm trying that now...
20:34:56 <dmwit> ...sorry Toxaris =/
20:35:19 <sfultong> GHCi has debugging features?
20:35:26 <sfultong> heh... so much I don't know
20:35:58 <dmwit> sfultong: GHCi can evaluate (almost) any Haskell.
20:37:11 <sfultong> well, that's true... unfortunately you can't evaluate states of running programs, or functions in modules that won't load...
20:37:50 <Toxaris> Debug.trace doesn't help with functions that don't load, either
20:37:57 <dmwit> right
20:38:11 <dmwit> And you can comment out offending lines to get "most" of a file loaded.
20:38:42 <dmwit> Copy/paste + experimentation gets me the rest of the way, usually.
20:39:33 <sfultong> oops, just accidentally switched to a different virtual desktop, and scared myself ("where are all my programs??")
20:44:51 <sfultong> well, putting a return () after the trace does force evaluation, but unfortunately it doesn't help me understand what I'm doing wrong...
20:45:00 <sfultong> probably something simple that I'm overlooking
20:45:26 <Toxaris> sfultong: no, putting the trace to the left of the return does force evaluation of the trace
20:46:00 <Toxaris> the () is not evaluated, for example
20:46:24 <sfultong> wait... I think we're agreeing, not disagreeing
20:46:36 <Toxaris> sfultong: yes, may be :)
20:47:43 <Toxaris> sfultong: about not understanding: yep thats the problem, traceM's execution doesn't depend on the execution of the "result", so it doesn't help with understanding when and how the result is computed
20:47:59 <Toxaris> traceM is for understanding the sequence of monadic actions
20:48:04 <SamB_XP> furious agreement is it?
20:48:31 <sfultong> mmm, indeed
20:48:50 <Toxaris> sfultong: so whats the original problem you wanted to solve with these traces?
20:50:05 <sfultong> in a more general sense, the location of the PC on the terrain map is not being updated in my game
20:51:22 <sfultong> well... I think I've found what I did wrong... thanks for the help
20:51:47 <sfultong> just forgot to actually update the right member of my state datastructure
20:52:52 <sfultong> anyone here play nethack or any other rogue-like games?
20:53:24 <Toxaris> you mean, you throw away this map unevaluated instead of storing it in some state record :)
20:53:24 <sfultong> heh, yay! now I get to undebug my source
20:53:34 <sfultong> toxaris: yeah, pretty much
20:54:08 <sfultong> it's amazing how pervasive state-assuming thinking is
20:56:51 <monochrom> undebug?
20:57:16 <sfultong> undebug == remove debugging statements
20:57:25 <sfultong> so that my code looks more shiny
21:06:01 <hpaste>  cdsmith pasted "attempt 2: help with type class hackery" at http://hpaste.org/1769
21:06:27 <cdsmith> Okay, I cleaned it up a bit and solved some of the problem.  Anyone like to take a look?
21:08:03 <xpika_> @pl map ($5) tests
21:08:03 <lambdabot> map ($ 5) tests
21:08:28 <xpika_> @pl (\x-> map ($x) tests)
21:08:28 <lambdabot> flip map tests . flip id
21:10:16 <cdsmith> Hmm.  No one up for type hacking?
21:10:25 <xpika_> @pl  \x -> map (flip map tests . flip id) $ x
21:10:25 <lambdabot> map (flip map tests . flip id)
21:12:53 <xpika_> @pl (\x->x>3&&x<5)
21:12:53 <lambdabot> liftM2 (&&) (> 3) (< 5)
21:13:25 <xpika_> :r
21:13:28 <xpika_> whoops
21:15:39 <brad_> why does the standard lib include Data.Time.Calendar.Easter?
21:16:02 <brad_> i mean, where are the astrology modules?
21:17:08 <dons> it doesn't include that. you mean the 'time' package
21:17:12 <dons> ?
21:17:27 <dons> $ cd ghc/libraries/time/Data/Time/Calendar/
21:17:27 <dons> Days.hs           Gregorian.hs      JulianYearDay.hs  OrdinalDate.hs    WeekDate.hs
21:17:30 <dons> Easter.hs         Julian.hs         MonthDay.hs       Private.hs
21:17:37 <dons> (not the standard library, just another 3rd party package)
21:18:02 <brad_> i thought haskell had a solid approach to "state"...evidently not CHURCH and STATE har har
21:18:12 <dons> haha :)
21:18:26 <brad_> okay i will go back to being a grovelling sycophant now
21:18:34 <dons> its safely partitioned inside a monad. not to worry.
21:18:53 <cdsmith> Does it actually calculate dates of Easter?
21:18:57 <xpika_> > runWriter (tell [4])
21:18:59 <lambdabot>  ((),[4])
21:19:14 <brad_> it tells you things like "Given a year, find the Paschal full moon according to Orthodox Christian tradition"
21:19:46 <cdsmith> Huh.  Interesting.
21:20:09 <brad_> okay at some point i will end up offending someone
21:20:18 <brad_> maybe i had better shut my yap
21:20:27 <cdsmith> by talking about Easter?  I doubt it...
21:20:57 <Toxaris> the Church is a monad? once inside, there's no way out?
21:20:58 <|Steve|> How dare you mention Easter in my presence? I can't handle bunnies laying chocolate eggs!
21:21:20 * glguy isn't religious but is annoyed by people whining about them
21:21:28 <cdsmith> Toxaris: There are ways out of plenty of monads.  runIdentity, runState, etc.  Why not runChurch?
21:21:29 <|Steve|> I don't even want to know what the bind procedure is in the Church monad.
21:21:43 <brad_> oh no steve - i was referring to the apparent deity who was crucified and rose to the heavens three days later - i am referring to the egyptian god horus of course
21:21:45 <sjanssen> brad_: there's got to be some good reason for this module
21:22:11 <brad_> sjanssen - maybe, but it beats me!
21:22:13 <|Steve|> Of course.
21:22:33 <Toxaris> cdsmith: you have to run faster then the priest
21:22:34 <brad_> okay now i am really going to piss someone off
21:22:39 <cdsmith> sjanssen: Sure there is.  I can write a program to remind me to wish Orthodox friends a happy Easter.  I can never remember when their easters are different.
21:24:28 <Toxaris> there's so much talk about how important intercultural whatever is these days, so it can't hurt to be able to translate information to somewhat exotic scales
21:25:32 <xpika_> has anyone written a zipper library?
21:25:35 <brad_> but seriously, how do you use Data.Time.Calendar?
21:25:37 <Toxaris> actually, since you don't have to use it if you don't need it, it can't hurt to have some library
21:25:38 <sfultong> I hope someone develops a metric year... and then uses it
21:25:52 <brad_> i can't even seem to construct the basic type
21:26:05 <brad_> let d = 0 :: Day ???
21:26:16 <brad_> ignore me lambdabot
21:26:58 <xpika_> @let d = 0
21:27:05 <lambdabot> Defined.
21:27:10 <xpika_> L.d
21:27:16 <xpika_> > L.d
21:27:16 <|Steve|> > d
21:27:17 <lambdabot>  0
21:27:18 <lambdabot>  0
21:27:19 <Toxaris> sfultong: i like the concept of relating the passing of time to the passing of seasons
21:27:21 <xpika_> > L.d :: Day
21:27:22 <lambdabot>   Not in scope: type constructor or class `Day'
21:27:42 <dons> > d :: Int
21:27:43 <lambdabot>  Couldn't match expected type `Int' against inferred type `Integer'
21:27:46 <dons> > d :: Integer
21:27:47 <lambdabot>  0
21:28:01 <cdsmith> brad_: Day isn't a synonym for any Num type.  Use (Day x) where x is the Julian day, or (fromGregorian year month day)
21:28:34 <sfultong> well, how many seasons are there?
21:28:41 <sfultong> 2? 3? 4?
21:29:06 <cdsmith> ** Should have said 'ModifiedJulianDay x', not 'Day x'
21:29:23 <sfultong> by temperature and sunlight levels, there would be 3 seasons...
21:29:24 <dons> mmm, hpc movie, tracing haskell, http://movies.unsafeperformio.com/hpctpreview2.mov courtesy andyjgill
21:30:10 <brad_> cdsmith cdsmith - like fromGregorian (2007 1 1) ??
21:30:18 <andyjgill> This is an old, old movie; but a preview of what the GHCi debugger might look like
21:30:35 <Toxaris> sfultong: the passing of seasons is a continuous concept, it's not "summer" or "winter", it's "the moment of the first snow" or "the moment I see this year's first flower"
21:30:42 <cdsmith> brad_: no parentheses, or put them around the whole thing if youj insist on keeping them.
21:30:44 <dons> andyjgill: what's the relationship to the new debugger?
21:30:50 <dons> it will inherit ideas for the ui?
21:30:51 <glguy> dons: this video excites me :)
21:31:04 <sfultong> andyjgill: looks nice, very nice
21:31:07 <dons> yeah, tracing. very cool
21:31:16 <andyjgill> So here is the history.
21:31:18 <brad_> thanks cdsmith, that is why you are paid the big bucks!
21:31:32 <andyjgill> HPC -> HPC tracer (when ticks happen) -> HPC tracer GUI.
21:31:51 <andyjgill> GHCi -> GHCi debugger (using HPC tracer style ticks)
21:31:53 <brad_> i bookmarked your latest haskell blog posting cdsmith, will look at it soon btw
21:32:11 <cdsmith> brad_: no problem.  I'll even give you 25% off my normal fee. :)
21:32:23 <dons> andyjgill: and now we have both a new debugger, and HPC, in ghc head?
21:32:27 <andyjgill> The idea is to take the HPC tracer GUI, and put it in front of GHCi's debugger
21:32:28 <Toxaris> sfultong: the same with time of day, it's not "6:00", it's "time to wake up", from a human's perspective
21:32:36 <andyjgill> Yes, we do.
21:32:37 <sfultong> toxaris: exactly, therefore how does one break a year into discrete parts?
21:32:38 <dons> ah, cool.
21:32:48 <Saizan> do you know how gtk2hs' Graphics.UI.Gtk.Types is generated?
21:33:22 * glguy tried to build ghc-head recently... but the network library (and one other) were in a broken state
21:33:31 <sfultong> toxaris: actually, I've sometimes thought it would be cool to have a varying second length, based on the length of time from sunrise to sunset
21:33:35 <dons> andyjgill: so a cheap ui, using some small toolkit?
21:33:44 <dons> or a standalone gtk thing or some such (with big dependencies?)
21:35:25 <andyjgill> This is a Ajax application.
21:36:12 <dons> oh, ok. that makes it a bit easier  :)
21:36:40 <brad_> i see there is a Data.Map with a function map defined. is this an alias for map in the prelude? or is putting these functions in their own modules part of decomposing the prelude?
21:37:11 <Toxaris> sfultong: like the ancient romans? 12 hours from sunrise to sunset, 4 night watches from sunset to sunrise (is night watch the correct word?)
21:37:25 <andyjgill> Yes, and it allows remote debugging as well.
21:37:29 <|Steve|> It is if you're standing watch.
21:37:35 <dons> brad_: its map for Map structures
21:37:51 <dons> -- | /O(n)/. Map a function over all values in the map.
21:37:51 <dons> map :: (a -> b) -> Map k a -> Map k b
21:37:51 <dons> map f m = mapWithKey (\k x -> f x) m
21:38:08 <dons> use 'fmap' for the common 'map' between [], Maps and other structures in Functor
21:38:10 <Toxaris> |Steve|: I mean the period of time a soldier has to guard something.
21:38:23 <|Steve|> Then yes, that's correct.
21:38:31 <brad_> thanks dons
21:38:33 <Toxaris> |Steve|: thanks
21:38:41 <sfultong> toxaris: I didn't know the romans did it, but it sounds good.... although I'm a fan of using a base 30 number system...
21:40:02 <Toxaris> sfultong: it is very practical for a culture without cheap artificial light
21:41:48 <sfultong> toxaris: hmm... considering we do have cheap, artificial light, I wonder why we don't have a 25 hour day? (that is, hours as they currently are measured)
21:41:50 <brad_> is there a way to stipulate a Float as having a certain precision? i.e. express dollar amounts with only two decimal places?
21:42:15 <brad_> coming back to the Money type discussion on -cafe
21:42:24 <SamB_XP> floats don't even do decimal
21:42:28 <Toxaris> sfultong: you mean a longer day or shorter hours?
21:42:31 <SamB_XP> (in general)
21:42:33 <sfultong> I think I read that humans sleep patterns happen more naturally on a 25 hour cycle
21:42:38 <sfultong> longer day
21:42:56 <brad_> SamB_XP - can you recommend something more appropriate?
21:43:12 <sfultong> brad: make your own float type!
21:43:18 <sfultong> j/k, of course
21:43:25 <SamB_XP> brad_: he only wants fixed point anyway
21:43:39 <SamB_XP> brad_: cents!
21:43:48 <SamB_XP> er.
21:43:55 <SamB_XP> that first brad_ should be a sfultong
21:44:00 <SamB_XP> I may be tired...
21:44:32 <sfultong> tired is an attitude... if you don't believe in it, it won't exist
21:44:41 <SamB_XP> yeah right
21:44:52 <sfultong> heheh
21:44:53 <SamB_XP> If I don't believe in it I'll probably just fall asleep or something
21:45:11 <sfultong> or maybe you'll only think you fall asleep
21:45:30 <sfultong> and instead enter a projection of what your mind expects to happen
21:45:31 <brad_> well i guess having good currency types remains an open issue for haskell
21:46:21 <Toxaris> sfultong: If I don't care about time of day and only sleep when I want, I sleep from 8:00 to 15:00, wich is rather usefull in summer (sleep when it's to hot to work) but not really socially acceptable (sleep when all the other people interact)
21:47:03 <sfultong> neat, I have some naturally nocturnal friends
21:47:58 <SamB_XP> Toxaris: I don't know if I can sleep when its that hot...
21:49:10 <Toxaris> SamB_XP: better then working
21:49:41 <dons> brad_: oh, did you see Data.Fixed ?
21:49:49 <sfultong> if I had no outside constraints on my sleeping schedule, I'd probably sleep very odd hours
21:49:53 <SamB_XP> dons: does that do decimal?
21:50:00 <dons> > pi :: E6
21:50:07 <lambdabot>   add an instance declaration for (Floating E6)
21:50:07 <lambdabot>     In the expression: pi
21:50:07 <lambdabot>    ...
21:50:14 <Toxaris> of course, moste of the time, I can't live like this due to work / uni / other people
21:50:14 <dons> > 42.0002 :: E6
21:50:15 <lambdabot>   add an instance declaration for (Fractional E6)
21:50:15 <lambdabot>     In the expression: 42.0...
21:50:28 <dons> > 42.0002 :: Fixed E6
21:50:30 <lambdabot>  42.000200
21:50:33 <dons> there we go
21:50:38 <dons> SamB_XP: yeah, just set E2
21:50:40 <dons> or E3
21:50:47 <dons> > pi :: Micro
21:50:48 <lambdabot>   add an instance declaration for (Floating Micro)
21:50:48 <lambdabot>     In the expression: pi
21:50:48 <lambdabot> ...
21:50:55 <dons> no, not pi. Floating is weird
21:51:06 <dons> > 1 :: Pico
21:51:08 <lambdabot>  1.000000000000
21:51:14 <dons> brad_: ^^ did you know about this?
21:51:37 <brad_> whoops, sorry dons, i was in another screen
21:51:47 <dons> ?docs Data.Fixed
21:51:47 <lambdabot> Data.Fixed not available
21:51:47 <brad_> i will look up Data.Fixed
21:52:01 <dons> its in the base library
21:52:17 <dons> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Fixed.html
21:52:19 <lambdabot> http://tinyurl.com/yqdcrb
21:52:41 <brad_> cool! i actually have all of the standard docs on my local box, thanks for the url anyway
21:52:45 <brad_> i am looking at it now
21:52:47 <dons> might make sense to add E2 or E3
21:52:59 <sfultong> well, it's sleep time
21:53:00 <dons> :t pi
21:53:02 <lambdabot> forall a. (Floating a) => a
21:53:22 <brad_> yes E2 would more or less be a USD type
21:56:29 <brad_> well thanks for everything folks!
21:56:35 <Saizan> is there a reason for the lack of a Floating instance?
22:11:48 <Heffalump> dons: do you remember someone discussing a library that can check for undefined values?
22:12:10 <hpaste>  xpika pasted "critique please" at http://hpaste.org/1771
22:13:15 <hpaste>  xpika annotated "critique please" with "(no title)" at http://hpaste.org/1771#a1
22:14:06 <dons> Heffalump: undefined , as in 'undefined' ?
22:14:34 <dons> there's StrictCheck and friends for testing bottoms ?
22:18:14 <Heffalump> dons: ah, yes, I think that's what I meant.
22:18:52 * Heffalump finally has something useful to Google :-)
22:19:08 <dons> the main source for that library currently is the 'streams' darcs repo dcoutts and I've been working on
22:19:15 <dons> it has the combined StrictCheck+QuickCheck code
22:19:36 <Heffalump> great, thanks.
22:19:43 <SamB_XP> dons: wasn't there an additional ChasingBottoms repository?
22:20:03 <Heffalump> so here: http://www.cse.unsw.edu.au/~dons/streams.html ?
22:20:03 <dons> here, http://www.cse.unsw.edu.au/~dons/code/streams/list/tests/Strictness/
22:20:03 <lambdabot> Title: Data.List.Stream
22:20:05 <lambdabot> Title: Index of /~dons/code/streams/list/tests/Strictness, http://tinyurl.com/2hsm7g
22:20:20 <dons> SamB_XP: there is, but I'm not sure we use it
22:20:31 <SamB_XP> dons: you did!
22:20:33 <dons> Heffalump: yeah, inside the 'tests' repo for the list lib
22:20:43 <SamB_XP> there were no directions on where to find it either
22:20:53 <SamB_XP> however http://www.cse.unsw.edu.au/~dons/code/streams/
22:20:53 <lambdabot> Title: Index of /~dons/code/streams
22:21:06 <Heffalump> it seems googlable fo
22:21:07 <Heffalump> r
22:21:14 <dons> ah indeed, import Test.ChasingBottoms
22:21:20 <dons> http://www.cse.unsw.edu.au/~dons/code/streams/ChasingBottoms/
22:21:20 <lambdabot> Title: Index of /~dons/code/streams/ChasingBottoms
22:21:34 <dons> yes, our test lib is a layer over the bottom-testing capabilities for that lib, and adding QC stuff for it
22:21:35 <Heffalump> so the stuff in your repo is more up to date than elsewhere?
22:21:35 <SamB_XP> @where ChasingBottoms
22:21:36 <lambdabot> I know nothing about chasingbottoms.
22:21:43 <dons> Heffalump: yeah.
22:21:47 <SamB_XP> @where+ ChasingBottoms http://www.cse.unsw.edu.au/~dons/code/streams/ChasingBottoms/
22:21:48 <lambdabot> Done.
22:22:03 <dons> so you could start with ChasingBottoms from above, and the 'Strictness' stuff in the streams/list lib
22:22:11 <dons> and use that to state QC properties about bottoms
22:22:29 <SamB_XP> Heffalump: probably google knows where to find it from people talking about it on IRC ;-P
22:22:32 <Heffalump> is StrictCheck anything more than QC+ChasingBottoms?
22:22:46 <Heffalump> SamB_XP: :-)
22:22:54 <dons> its another projects, but I've been (sloppily) using it as a synonym for QC+ChasingBottoms
22:23:10 <Heffalump> ok
22:23:18 <dons> there's different Arbitrary instances btw, since you need to write Arbitraries that insert bottoms
22:23:36 <dons> which is what the streams tests repo provides, iirc
22:23:43 <Heffalump> my application is slightly different
22:24:00 <Heffalump> I (probably) don't care about bottom inputs, I just want to check that functions return errors in certain situations.
22:24:06 <Saizan> someone with experience with gtk2hs' build system? how do i tell it that i've added a module?
22:24:21 <Heffalump> I think the existence of your library has destroyed any hope I had of persuading Howard that this is an evil thing to do ;-)
22:24:33 <SamB_XP> Heffalump: why?
22:24:36 <dons> Heffalump: hehe. but I think this is exactly the right thing
22:24:49 <SamB_XP> @google semantics for imprecise semantics
22:24:52 <dons> you want to write properties that test for bottoms given particular inputs.
22:24:52 <lambdabot> http://portal.acm.org/citation.cfm?id=301637
22:24:52 <lambdabot> Title: A semantics for imprecise exceptions
22:24:55 <SamB_XP> hmm.
22:24:59 <Heffalump> it's impure
22:25:01 <SamB_XP> not *exactly* what I had in mind
22:25:09 <Heffalump> the checks for bottoms should live in IO
22:25:15 <dons> it is evil yes.
22:25:30 <dons> but required to make this stuff not be gross
22:25:33 <Heffalump> I reckon QC should just have combinators that allow for IO properties, but only IO properties that catch exceptions
22:25:36 <SamB_XP> Heffalump: show him the part about an infinite loop being allowed to reformat his hard drive, as far as the semantics are concerned
22:25:40 <Heffalump> but I haven't quite figured out the details
22:25:49 <SamB_XP> (your OS hopefully has different ideas, however ;-)
22:25:56 <dons> ChasingBottoms is the evil bit, btw. it defines the 'isBottom :: a -> Bool'
22:26:00 <Heffalump> right
22:26:23 <Heffalump> I think I really want getError :: a -> Either Exception a
22:26:25 <SamB_XP> but it only works on exceptions
22:26:36 <SamB_XP> Heffalump: what?
22:26:38 <Heffalump> but I just wanted to check what other people had done so I didn't miss any details in the implementation
22:26:40 <SamB_XP> that's not sensibel
22:26:48 <SamB_XP> not in general
22:27:13 <Heffalump> why not?
22:27:24 * Heffalump disappears for a couple of minutes
22:27:27 <SamB_XP> see, the denotational semantics are that there is a *set* of exceptions associated with a Bad
22:30:18 <SamB_XP> @google a semantics for imprecise exceptions
22:30:19 <lambdabot> http://research.microsoft.com/~simonpj/Papers/imprecise-exn.htm
22:30:20 <lambdabot> Title: Simon Peyton Jones: papers
22:30:23 <SamB_XP> ah, better
22:30:36 <SamB_XP> Heffalump: use it well!
22:32:02 <Heffalump> SamB_XP: oh, right, yeah
22:32:13 <dons> hmm, why don't we have a standard type, data StricTList a = Empty | Node !a (Strict ...)
22:32:32 <dons> I should add that to the Strict package.
22:32:41 <SamB_XP> the capital T is strictly necessary?
22:32:44 <dons> since we should have used such a type for lazy bytestring spines.
22:32:46 <SamB_XP> (no pun intended)
22:32:58 <dons> @slap SamB_XP
22:32:58 * lambdabot slaps SamB_XP
22:33:05 <brad_> why does    Prelude Text.Printf> printf "%02d" (6::Int)
22:33:10 <SamB_XP> it was an accidental pun!
22:33:19 <brad_> return: 06*** Exception: Prelude.undefined
22:33:21 <SamB_XP> or are you slapping me for nitpicking?
22:33:23 <brad_> ???
22:33:34 <dons> brad_: see the trac, issue. its the defaulting
22:33:39 <dons> > printf "%02d" (6::Int) :: String
22:33:41 <lambdabot>  "06"
22:33:44 <dons> > printf "%02d" (6::Int) :: IO String
22:33:46 <lambdabot>  <IO [Char]>
22:33:50 <dons> add a 'return ()' after
22:34:08 <brad_> thanks dons
22:34:10 <SamB_XP> dons: why does it not use an IsUnit class?
22:34:40 <SamB_XP> (I suppose that wouldn't have defaulting?)
22:35:05 <dons> slapping for making pointless noise, SamB_XP, since we don't have downmods for that.
22:35:16 <SamB_XP> SamB--
22:36:06 * SamB_XP is sorely tempted to make a noise with a lot of ... points in it
22:36:47 <dons> probably you should write some code instead. or perhaps a tutorial on using parsley
22:37:14 <SamB_XP> or sleep!
22:37:21 <SamB_XP> that would probably be a good idea
22:37:25 <SamB_XP> @localtime SamB
22:37:25 <lambdabot> Local time for SamB is Thu Jul 19 01:35:08
22:37:32 <SamB_XP> don't you think?
22:43:54 <dblhelix> morning #haskell!
22:47:58 <glguy> dblhelix: not quite , 2 hrs to go ;)
22:48:53 <Saizan> ?localtime glguy
22:48:55 <lambdabot> Local time for glguy is Wed Jul 18 22:47:54 2007
22:50:01 <SamB_XP> dons: oh, btw, I heard from Ralf Laemmel. He's emailed Joost about StrategyLib 5.0. I told him about the version of StrategyLib I put on hackage, too.
22:50:21 * SamB_XP actually goes to bed now...
22:54:50 <dblhelix> well, glguy, what can I say? you're *way* behing me ;-)
22:54:55 <dblhelix> @localtime dblhelix
22:54:56 <lambdabot> Local time for dblhelix is 2007-07-19 07:54:05 +0200
22:55:13 <dblhelix> /s/behing/behind
22:57:16 <dblhelix> glguy: still coding? or just preparing for a good night's sleep?
23:01:52 <glguy> mostly preparing :)
23:03:09 <dblhelix> glguy: are you going to compete in the ICFP programming contest?
23:06:28 <gmosx> hello!
23:06:39 <dblhelix> hi gmosx
23:07:32 <gmosx> dblhelix: I am looking for a tutorial on creating a simple Haskell/FCGI web application. Does such thing exist?
23:08:35 <dblhelix> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/fastcgi
23:08:39 <lambdabot> http://tinyurl.com/3bgzga
23:08:56 <dblhelix> gmosx: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/fastcgi
23:08:58 <lambdabot> http://tinyurl.com/3bgzga
23:09:50 <gmosx> I know about this package, but as am a newbie I am looking for a tutorial or something to go  along...
23:10:02 <dblhelix> gmosx: not sure how well it's documented though, or whether there's a tutorial
23:10:03 <dblhelix> oh
23:10:14 <dblhelix> gmosx: you're a newbie to haskell?
23:10:29 <glguy> dblhelix: I wasn't planning on it
23:10:37 <glguy> dblhelix: I'd have to go it on my own probably
23:10:44 <dons> i think there's some examples here, http://haskell.org/haskellwiki/Blog_articles/Network
23:10:45 <lambdabot> Title: Blog articles/Network - HaskellWiki
23:10:45 <gmosx> more specifically I am courious if i can use this package to create a haskell fcgi app that listens on a specific port.
23:11:04 <dons> should be pretty straight forward
23:11:30 <gmosx> dons: thanks, I will have a look at this...
23:13:06 <dblhelix> are you participating in the contest, dons?
23:13:38 <dons> not this year, got to get my dissertation written, and this book thing
23:13:49 <dons> so i'm trying to avoid distractions
23:13:50 <dblhelix> all in one weekend? ;-)
23:13:55 <dblhelix> ah
23:17:13 <scook0_> @hoogle IORef
23:17:14 <lambdabot> Data.IORef :: module
23:17:14 <lambdabot> Data.IORef.IORef :: data IORef a
23:17:14 <lambdabot> Data.IORef.atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
23:19:48 <dons> dblhelix: so you think none of the Utrecht haskellers will be around Freiburg after ICFP is over?
23:21:05 <dblhelix> dons: well, we stay until CUFP is over... iirc, we may even miss the last session of CUFP to catch our train
23:21:27 <dons> ah right.
23:21:38 <wli> dons: Got the alternative shootout going yet?
23:21:48 <dons> Utrecht, and their secret haskell libraries and tools and hackers ;)
23:22:01 <dons> wli, heh, no. i did update a couple on the real shootout though
23:22:15 <dons> http://shootout.alioth.debian.org/gp4/benchmark.php?test=nsieve&lang=ghc&id=2
23:22:18 <lambdabot> Title: nsieve Haskell GHC #2 program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Comput ..., http://tinyurl.com/29z5ae
23:22:21 <dons> http://shootout.alioth.debian.org/gp4/benchmark.php?test=nsievebits&lang=ghc&id=0
23:22:24 <lambdabot> Title: nsieve-bits Haskell GHC program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Comp ..., http://tinyurl.com/2xnch4
23:22:26 <dons> http://shootout.alioth.debian.org/gp4/benchmark.php?test=partialsums&lang=ghc&id=0
23:22:27 <dblhelix> amiddelk, Jeroen Fokker, Atze Dijkstra, Doaitse Swierstra, and I will be there from the start of ifl, Bastiaan Heren en Alexey Rodriquez join us for the Haskell Workshop and ICFP
23:22:28 <lambdabot> Title: partial-sums Haskell GHC program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Com ..., http://tinyurl.com/26cegm
23:22:59 <dons> dblhelix: ok, cool. the hackathon is at the same place as IFL, but after CUFP
23:23:32 <dons> wli, i think it will have to wait till i have time, then we set it up on a 16 core box
23:23:40 <dons> maybe even just use the same programs as the existing shootout...
23:25:08 <wli> dons: I think the entire way they're benchmarking is lousy.
23:25:47 <dons> i personally like very tight specs like this, since that avoids going back later when someone works out a better algorithm. but then again, the reuls change on the shootout too often anyway
23:25:50 <wli> dons: There's no problem size, for instance. It's always a single output.
23:25:53 <dons> and they have to put arbitrary limits in
23:26:15 <dons> they do measure problems sizes for different values of N
23:26:58 <wli> dons: Really? I don't see it if so.
23:27:54 <dons> yeah, there's a link there somewhere. they show entries as they change when N grows
23:29:02 <dblhelix> dons: are you going to ifl?
23:30:39 <dons> not sure yet, demands on what galois is doing
23:30:45 <dons> i'd probably end up hacking the whole time anyway ;)
23:31:26 <dblhelix> that's supposed to be your job by then, isn't it? :-)
23:31:44 <dons> yeah. galois hacking
23:31:46 <wli> dons: Okay, they do have something, but it's not very interesting.
23:32:04 <glguy> yeah, hurry up and finish up your thesis and marriage
23:32:10 <glguy> we
23:32:21 <glguy> could use ya sooner than later
23:32:21 <vincenz> glguy: who?
23:32:27 <dblhelix> well, the deadline for ESOP is Oct 4, so I can imagine what I'll be doing in Freiburg
23:32:27 <glguy> dons
23:32:38 <dons> trying to, glguy ! 6 weeks to go :)
23:32:43 <vincenz> dons: you have a fiance?
23:32:54 <dons> i have a finance. i mean fiancee yeah :)
23:33:21 <vincenz> dons: 'grats :)
23:33:21 <glguy> dons is a fiance'
23:34:00 * glguy wonders how to type the e' character
23:34:09 <dblhelix> dons: wow, how many hours are there in a australian day anyway? I never would have thought that you had time to be pleasant company besides all the hacking you do ;-) congrats, anyway
23:34:13 <olsner> √©?
23:34:22 <dons> you can see in this xmonad screenshot, http://xmonad.org/images/screen-dons-floating.png
23:34:23 <glguy> yeah, that
23:34:25 <wli> The closest I know to anything about webmonkeying is some ancient HTML standard. I don't even know CGI, never mind anything more advanced than that.
23:34:26 <dblhelix> /s/a australian/an australian
23:34:34 <glguy> do I need a compose button (x11)
23:34:49 <mgsloa2> dons - the xmonad README has your home dir as the default, rather than $HOME
23:34:54 <glguy> in vim I know: ^K e '
23:35:06 <dons> mgsloa2: i think that's fixed in darcs.
23:35:13 <dons> ah no, fixed now.
23:35:21 <mgsloa2> yeah, i have darcs head
23:36:03 <wli> I did brute-force an extremely crude CGI app once by writing with my nose buried in CGI docs, though.
23:36:22 <vincenz> dons: what does she do?
23:36:27 <vincenz> dons: does she code haskell?
23:37:13 <xpika_> looks like shes the lambdabot
23:37:24 <dons> nah, she works for oxfam, and other NGOs doing event planning and project stuff
23:37:30 <vincenz> dons: spiffy :)
23:37:57 <vincenz> dons: my 'future . maybe $ gf' or 'maybe . future $ gf' (I think those monads are commutative) isn't a geek either.
23:40:08 <olsner> "The registration page will open in July 2007."
23:40:44 <dblhelix> olsner: still plenty of time to open it then
23:40:59 <slava> glguy: i think the windows issue in head was sorted out
23:41:01 <olsner> granted.. but still it's a bit lazy
23:41:05 <dblhelix> olsner: which page are you referring to, anyway?
23:41:19 <olsner> http://proglang.informatik.uni-freiburg.de/IFL2007/registration.shtml
23:41:22 <lambdabot> Title: IFL 2007: Registration, http://tinyurl.com/27mk7w
23:41:33 <dblhelix> olsner: ah
23:41:42 <glguy> slava: I've have to give that a shot later then, I liked messing around with the GUI
23:41:54 <olsner> seems there's about 10 days of continuous haskell-related activity with IFL+ICFP+hackathon
23:42:33 <dblhelix> olsner: don't forget to mention the haskell workshop (!) and cufp
23:42:44 <olsner> what's CUFP?
23:42:56 <dblhelix> commercial users of functional programming
23:43:07 <dblhelix> @where cufp
23:43:07 <lambdabot> www.galois.com/cufp
23:43:47 <wli> What would be the thing to use to write something like the programming language shootout?
23:43:54 <wli> hAppS?
23:44:07 <dons> wli, oh,i'd start with the cvs repo of the current shootout
23:44:18 <dons> and generating everything offline, except for the submission page
23:44:30 <dblhelix> wli: are you planning to write such a site your self?
23:44:50 <wli> dblhelix: It depends on how hard it looks after I look into it.
23:45:01 <dblhelix> :-)
23:46:19 * mgsloa2 thinks maybe the ubuntu X11 packages are not enough for xmonad
23:46:36 <wli> dblhelix: Also whether I ever get around to it. I've got a queue building up.
23:46:48 <dblhelix> wli: sounds familiar
23:47:43 * dblhelix should limit his queue size, it's steadily approximating infinity
23:47:44 <wli> dblhelix: I've also got a day job.
23:48:04 <dblhelix> wli: well, luckily it's part of my day job to queue and dequeue
23:48:20 <dblhelix> wli: I'd be in trouble if my queue gets empty
23:48:42 <slava> upl
23:48:49 <dblhelix> still, if anyone has a cool project to hack on... I'm available ;-)
23:50:26 <Saizan>  dblhelix: i've a project: "explain gtk2hs build system to Saizan"
23:50:55 <dblhelix> Saizan: I guess I should defer you to dcoutts then ;-)
23:51:06 * Saizan feels clueless
23:51:07 <wli> dblhelix: Well, I didn't just want to clone the shootout thing. I wanted relatively detailed plots as N grows (it only shows 3 points or similar), using least squares regression to find constants under the big O()'s, finding correlations between the performance in different benchmarks, and so on.
23:51:32 <dblhelix> wli: wow, already sounds impressive
23:51:47 <dons> sounds like a lot of work ;)
23:51:57 <dons> it has to be almost entirely automated for people not to give up on it
23:52:07 <dons> and with a small set of problems, for the noise to not dominate
23:52:11 <dblhelix> isn't "impressive" a known euphemism for "a lot of work"?
23:52:12 <wli> Well, the plotting as N grows is just a loop.
23:52:27 <dons> isn't that "non-trivia;" dblhelix ?
23:52:31 <wli> Least squares regression is just dumping the results into a least squares solver.
23:52:35 <dons> or is that a synonym for ... "impossible"
23:52:35 * mgsloa2 realizes that the X11/X11-extras are haskell packages
23:52:43 <wli> Finding correlations is dumping results into a statistics package.
23:52:58 <wli> Principal components analysis is dumping correlations into an eigensolver.
23:53:11 <wli> So it's all calling canned subroutines.
23:53:42 <dblhelix> dons: my favorite one is "this is left as an exercise to the reader" for "I've no clue how this should be done or whether it can be done altogether"
23:55:04 <dons> heh
23:55:15 <pejo> dons, people who don't know things can't be done often solve the problem. :-)
23:57:09 * glguy figures out his compose key √ü √© ‚Ç´ -
23:58:07 <glguy> el ni√±o :)
23:58:13 <wli> dblhelix: The real hard parts are the problems. The only obstacle to the web app is my total ignorance of webmonkeying.
23:58:26 <vincenz> wli: I hope you have a seriously powerful box
23:58:30 * dblhelix isn't an expert either
23:58:32 <vincenz> wli: I think you'll need a lot of points
23:58:48 <wli> vincenz: What do you mean?
23:59:16 <vincenz> wli: to get some sort of meaningful curve you'll need quite a few points to not lose out to noise
23:59:27 <dons> i think a new shootout would only be fun if it was multicore
23:59:33 <vincenz> yes
23:59:36 <vincenz> multicore problems ftw
23:59:38 <dons> then it would really be interesting
23:59:46 <vincenz> "how well does it scale to multicore'
