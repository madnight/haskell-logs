00:00:09 <dons> hardware compiler and crypto language compiler, commercial, written in haskell
00:00:20 <Korollary> Ah
00:00:27 <dons> who knows how big the projects at credit suisse or deutsche bank are...
00:00:56 <edwardk> I wrote up an explanation of that parameterized monad package on http://comonad.com/reader/ and updated the version in hackage to clean it up and add more instances.
00:01:12 <dons> edwardk: is that also on planet haskell, btw? your feed?
00:01:18 <edwardk> not at present
00:01:22 <edwardk> not sure who to contact
00:01:25 <Korollary> you got comonad.com?
00:01:28 <edwardk> ya
00:01:50 <Korollary> You are obligated to write a comonad tutorial
00:01:53 <edwardk> hahaha
00:01:57 <dons> and upload the comonad package
00:02:38 <dons> Korollary: for some reason, this guy bugs me, and its the kind of thing we want to refute, as you say, http://www.jerf.org/iri/2007/02/19/2568.html
00:02:38 <edwardk> I'll probably get around to building an updated comonad library at some date
00:02:39 <lambdabot> Title: Big Haskell Projects List - iRi
00:02:54 <edwardk> Heh, he used to work for me
00:03:30 <dons> he's a bit rude in that post. 
00:03:36 <dons> `augustss suggests Bluespec, and later assures me it is primarily Haskell.'
00:03:37 <dblhelix> we should have a poll: what's your favorite comonad? ;-)
00:03:46 <edwardk> Thats just his personality I think.
00:03:57 <dons> `Cryptol: I'm not convinced this is a big project, and I'm a little concerned that there doesn't seem to be any way to obtain the product?'
00:03:59 <vincenz> moin
00:04:03 <dons> for example :/
00:04:28 <dons> and the refusal to visit the haskell 'applications and libraries' page
00:04:44 <dons> hmm, i wonder how big happs is now.
00:05:00 <vincenz> 5 meters
00:05:05 <dons> at least
00:05:42 <vincenz> ask Lemmih ?
00:05:50 <Korollary> dons: That's a weird webpage. Why the hell would anyone care to write that up?
00:05:59 <vincenz> what link?
00:06:02 <vincenz> Ii just joined the convo
00:06:32 <Korollary> vincenz: cnn.com
00:06:42 <dons> oh, he built the list just from comments on reddit,
00:06:50 <dons> http://programming.reddit.com/info/15b2c/comments/c15exk
00:06:51 <lambdabot> Title: Are bugs really important? (reddit.com)
00:07:01 <dons> so not actually doing any research, but he happily links to it
00:07:14 <dons> edwardk: be sure to give him a kick, if you know him :)
00:07:17 <arcatan> doing any work sucks, anyway
00:07:24 <edwardk> dons: haven't talked to him in a year or two
00:07:31 <Shimei> His writing was awfully inflammatory. You'd think it's a poor strategy to encourage language development.
00:08:12 <dons> its also as if he never visited haskell.org :/ sigh. 
00:08:18 <Korollary> dons: In reality you only need to address people with some following. Random Joe's can have their misconceptions as they like them. Otoh, if, say, Yegge writes something uninformed, you may want to correct him because there are people who'd believe him. (They shouldn't, but argh.)
00:08:49 <dons> yes, at least yegge is pro FP methods :)
00:08:53 <dons> random joes have random ideas
00:09:28 <dons> so we need more visibility for commercial, large haskell projects
00:09:33 <dons> the stuff that gets talked about at CUFP
00:09:43 <dons> which really means we need the FP Consortium
00:09:48 <dons> http://cufp.galois.com/ btw,
00:09:49 <lambdabot> Title: Commercial Users of Functional Programming
00:09:56 <Shimei> Say, did anyone read this other reddit link? http://unqualified-reservations.blogspot.com/2007/07/my-navrozov-moments.html <-- an awfully harsh treatment of computer science, dismissing it as a fraud. I wonder how much truth it holds?
00:09:58 <lambdabot> Title: Unqualified Reservations: My Navrozov moments, http://tinyurl.com/3xgvjl
00:10:16 <edwardk> not to go finish up the security parameterized monad that that whole module was made as a prerequisite for
00:10:19 <Korollary> Shimei: That was just drivel. I couldn't finish it.
00:10:20 <edwardk> er now
00:10:28 <Shimei> Korollary: Yeah, I just skimmed it.
00:11:34 <cdsmith> Shimei: Do you you trust someone who couldn't restrain himself from also calling for the abolition of government deep inside the article?
00:11:37 <vincenz> Korollary: what about cnn.com
00:11:48 <Korollary> vincenz: I was messing with you. The real link is http://www.jerf.org/iri/2007/02/19/2568.html
00:11:48 <lambdabot> Title: Big Haskell Projects List - iRi
00:11:54 <Shimei> OTOH, it's interesting that the author had some experience with academia, rather than another self-taught programmer ranting from the sidelines (not that there's anything wrong with being self-taught).
00:12:04 <wli> Shimei: It starts off completely wrong.
00:12:06 <cdsmith> Shimei: I get the distinct impression that he's mainly upset about paying taxes that support academic research.
00:12:39 <Shimei> cdsmith: I was hoping that was hyperbole, because it seemed too ridiculous.
00:12:55 <Shimei> Pseudo-anarchist mumbling, as it were.
00:13:23 <dons> Pseudonym: still around?
00:13:39 <Korollary> I observe that highly critical blog posts gather more attention. Flinging of feces has its fans.
00:13:47 <dons> this was an interesting response I got to my community thingy email earlier today,
00:13:50 <dons> The tone of the ruby-talk mailing list, and the larger Ruby community
00:13:53 <dons> has changed over the last five years.  This is to be expected.  The
00:13:55 <dons> biggest difference may be that, when people are nasty or trolling, "old
00:13:58 <dons> timers" are now less likely to jump in and remind folks that a certain
00:14:00 <dons> decorum is expected.
00:14:05 <dons> The general rule has been, "Matz is nice and so we are nice."  (And matz
00:14:05 <dons> is, indeed, a very nice person. :))  It's a simple guideline that helps
00:14:05 <dons> steer people in a good direction.
00:14:15 <dons> -- sounds almost like "What would SPJ do?" 
00:16:11 <cybercobra> SPJ?
00:16:17 <dons> ?go SPJ
00:16:20 <lambdabot> http://www.spj.org/
00:16:20 <lambdabot> Title: Society of Professional Journalists
00:16:22 <dons> doh
00:16:26 <dons> ?go simonpj
00:16:27 <lambdabot> http://research.microsoft.com/~simonpj/
00:16:27 <lambdabot> Title: Simon Peyton Jones
00:16:30 <opqdonut> :)
00:16:31 <dons> ^^
00:17:26 <dons> ah ,we have replies to the silly ghost in the machine guy, http://www.noulakaz.net/weblog/2007/07/13/why-are-there-so-many-programming-languages/
00:17:30 <lambdabot> Title: Avinash Meetoo: Blog » Blog Archive » Why are there so many programming language ..., http://tinyurl.com/28c6n7
00:18:37 <wli> dons: Yet another right-wing nut.
00:19:38 <vincenz> dons: how do I enable new plugins with tne new lambdabot?
00:20:26 <dons> you add a file, Plugin/Foo.hs
00:20:32 <dons> add it to the modules list in Modules.hs
00:20:35 <dons> and that's it, iirc
00:20:41 <vincenz> dons: DynModules?
00:20:45 <dons> should be written in the docs somewhere
00:20:48 <dons> just copy what the others do
00:21:22 <vincenz> o
00:21:24 <vincenz> k
00:23:39 <vincenz> dons: can it be that some modules taht are included are way out of date?/
00:23:51 <dons> hmm, no?
00:23:54 <dons> why?
00:23:54 <vincenz> DarcsPatchWatch
00:24:04 <dons> oh, just not used. but i'd say it still works
00:24:09 <vincenz> nope
00:24:10 <dons> they're not all enabled by default
00:24:11 <vincenz> @hpaste
00:24:12 <lambdabot> Haskell pastebin: http://hpaste.org/new
00:24:14 <dons> (we used that last year for icfp, btw)
00:24:19 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/1648
00:24:35 <vincenz> dons: It seems to be made for the old framework
00:24:36 <vincenz> ?
00:24:43 <dons> oh, it might be out of date.
00:24:45 <vincenz> oy
00:24:52 <dons> you want it for icfp?
00:24:56 <vincenz> sorta :P
00:25:07 <dons> you'll need to update the Module interface it uses to match the others
00:25:11 <dons> should be fairly simple
00:25:17 <dons> only a few types have changed, iirc
00:25:21 <vincenz> ok
00:25:26 <vincenz> but I have no experience with the LB structure
00:25:32 <dons> there may be other darcs/irc tools these days?
00:25:41 <dons> we wrote that a 2 or 3 years ago, iirc
00:26:40 <dons> you could use darcs2rss, and then an rss bot
00:26:50 <dons> its probably easiest to just fix lambdabot though
00:27:10 <vincenz> hmm
00:30:35 <vincenz> dons: any tips?
00:30:54 <dons> um, look at a current module, and ensure the types in the Module instance match
00:32:26 <vincenz> ...
00:33:44 <dons> all lambdabot plugins implement the Module class
00:33:55 <dons> which has a fixed interface used to talk to the bot
00:34:01 <dons> and all types flow from what can go there.
00:34:12 <dons> so start in instance Module DarcsPatchWatch DarcsPatchWatchState where
00:34:15 <vincenz> but it forks apparently
00:34:18 <dons> and continue till the types match
00:34:21 <dons> that's fine. fork is ok
00:34:21 <vincenz> from DPW -and LB ()
00:34:23 <vincenz> to ModuleT
00:34:28 <dons> just a small thread, and an internal state
00:34:37 <vincenz> I mean... two different types to one type
00:35:21 <dons> that's a type error
00:35:22 <dons> :)
00:35:27 <dons> your job is to find out why
00:35:50 <vincenz> ...
00:36:41 <dons> !!!
00:36:59 <dons> vincenz: are you asking for me to write code?
00:37:01 <vincenz> no
00:37:20 <dons> you could probably *reimplemnt* the module in 6 hours
00:37:28 <dons> tuned for lazy bottoms purposes :)
00:37:31 <wli> dons: There are criticisms of CS with the same conclusion as his but properly justified.
00:38:17 <dons> edwardk: is comonad.com down?
00:42:36 <wli> dons: Is there an autoparallelization -like option floating around?
00:43:29 <dons> wli, for what in particular?
00:43:44 <wli> dons: Array and list operations mostly.
00:43:57 <dons> for lists, there's Control.Parallel.Strategies
00:44:00 <dons> which provide parMap et al
00:44:11 <dons> for arrays, you must use the ndp array library
00:44:19 <dons> which provides transparently parallel arrays
00:44:24 <dons> and parallel array comprehensions
00:44:33 <dons> do you have a few cores spare?
00:44:40 <skew> Control.Parallel isn't quite as simple as just using an option, but you don't have to change your main code much
00:44:42 <vincenz> edwardk: interesting article
00:44:42 <wli> dons: oh, about 4
00:45:01 <dons> yeah, in particular Control.Parallel is a lightweight annotation form of parallelism
00:45:07 <dons> and ndp is even lighter: you just change an import
00:45:22 <wli> Let me see if I can get ndp going.
00:45:28 <dons> its good to use forkIO + the smp runtime a bit to get a feel of how to do this stuff by handl
00:45:34 <skew> with Control.Parallel you leave the definition of a big lazy structure alone, and feed it through a library function that creatively forces it in a few threads
00:45:37 <dons> ie.. write a parallel array map yourself
00:45:52 <dons> using forkIO, and smp, to get a 4x speedup.
00:46:04 <wli> ndp seems to be what I'm after.
00:46:07 <dons> http://haskell.org/haskellwiki/Applications_and_libraries/Concurrency_and_parallelism
00:46:09 <lambdabot> Title: Applications and libraries/Concurrency and parallelism - HaskellWiki, http://tinyurl.com/2u95za
00:46:13 <dons> ndp is still experimental though.
00:46:18 <dons>  i wouldn't use it yet for production code
00:46:23 <dons> but for experiments it would be ok
00:46:36 <dons> whereas Control.Parallel for lists is pretty solid now.
00:46:53 <dons> and forkIO is very reliable, but more tedious
00:47:22 <wli> dons: I'm not too concerned about experimental-ness, mostly clarity/etc.
00:47:39 <dons> then the ndp lib might be woth a try. see the link from the above page
00:47:54 <skew> oh, how's NDP there? Do you still need the raw functions?
00:47:54 <dons> i know at least matrix stuff seems to work -- the benchmarks are in the January status report
00:47:58 <wli> dons: I've cooked up a numerical algorithm and just want a proof of concept.
00:48:04 <dons> skew you import Data.Array.Paralell.*
00:48:25 <dons> and then use map :: (x -> y) -> Dist Array x -> Dist Array y
00:48:26 <dons> for example
00:48:31 <skew> yeah, but flattening and the array comprehensions are not quite together yet
00:48:35 <dons> right
00:48:38 <dons> the flattening is in the head
00:48:41 <dons> or some of it
00:48:44 <skew> so it's not as clear as writing everything up with list comprehensions, say
00:48:48 <dons> wli, yes, you need ghc head for this
00:48:55 <skew> depends what sort of proof of concept you are talking about
00:48:59 <dons> skew, yeah, and you need to ask for array comprehensions
00:49:15 <skew> last I checked, even if you did it didn't hook into the fast NDP implementation
00:49:16 <dons> wli, i'd probably try to do it with forkIO/MVars first
00:49:27 <dons> to get a feel for the smp runtime 
00:49:43 <skew> if you just want to check out an algorithm, you might try it with lists first
00:49:49 <dons> yeah
00:49:55 <wli> dons: I've actually been messing around with things for a few hours.
00:50:22 <skew> if you mean more like proving it's actually practical, then ndp sounds about right
00:50:25 <dons> yes, so you have parallel, strict arrays
00:50:31 <dons> but no syntactic glue/transforms for them yet
00:50:40 <dons> `Both package ndp and the syntactic sugar are already usable, but as we have yet to implement vectorisation, they currently cannot be used together.'
00:50:42 <wli> I've mostly been doing things with lists.
00:50:51 <dons> note rl is comitting the -fvectorise to ghc the last few days
00:51:01 <dons> so getting there. i think the goal is to have mostly working by ICFP
00:52:25 <wli> dons: Sounds like I should use the syntactic sugar to get the writeup in a beautified form and wait for the compiler to interpret it properly for the runtime testing.
00:52:47 <dons> you could do that.
00:53:29 <wli> dons: Well, I'm far enough out from having anything meaningful working the odds are the compiler will get there long before I do.
00:54:05 <wli> dons: Plus I don't really put all that much time into it. I'll probably mostly vanish from the channel for a good long while relatively soon.
00:56:07 <dons> oh? 
00:56:22 <dons> was lambdabot too rude? :)
00:56:48 <wli> dons: No, I'll just sort of lose focus or whatever. Day job etc.
00:56:59 <dons> fair enough :)
00:57:01 <B4K4p4nTsU> wli so you didn't burn out after all?
00:58:02 <dons> B4K4p4nTsU: really, you should change your nick to something more human-friendly, please
00:58:05 <wli> dons: It's really mostly about the algorithm. Haskell's just convenient to do things in userspace with (it's numerical/etc.).
00:58:12 <dons> yeah
00:58:20 <B4K4p4nTsU> dons uh, why?
00:58:26 <wli> dons: Oh, the literate programming bits help with the writeup/etc. too.
00:59:05 <dons> B4K4p4nTsU: because it keeps being misconstrued as semi-hostile, in this channel where many people use real names. we've raised it a couple of times now, and you were even mistaken for a bot yesterday, iirc.
00:59:44 <dons> its a simple thing.
00:59:53 <B4K4p4nTsU> i like my nickname :/
01:00:46 <dons> just letting you know that you might have trouble being taken seriously. its likely others will query the nick again. just so you know.
01:00:57 * shachaf likes being able to use his first name as his nick.
01:01:04 <shachaf> Most people don't get to do that. :-)
01:01:20 <B4K4p4nTsU> dons it's ok. i don't plan on talking in this channel a lot anyway
01:02:06 <dons> btw, why were you asking about <B4K4p4nTsU> why isn't he doing his soc project! ?
01:02:25 <B4K4p4nTsU> that was my impression, since he didn't have a status report in the wiki page
01:02:28 <B4K4p4nTsU> while everyone else did
01:02:28 <dons> oh, i guess you're actually m4st3r_b41t3r et al
01:02:33 <B4K4p4nTsU> yes, i am
01:02:43 <dons> silly nicks :/
01:02:48 <B4K4p4nTsU> >_>
01:03:19 <B4K4p4nTsU> so he's still doing the soc?
01:03:27 <dons> afaik.
01:03:34 <B4K4p4nTsU> glad to hear that
01:03:46 <dons> he's been successful the last 2 years, so I can't imagine a change this time.
01:03:50 <dons> it would be surprising.
01:04:01 <wli> I don't know anything about the SoC.
01:04:02 <B4K4p4nTsU> he wasn't in university the last two years :)
01:04:10 <dons> yeah
01:04:17 <dons> wli?
01:04:23 <dons> but its summer, isn't it?
01:04:26 <dons> so he's not in class anyway
01:04:35 <B4K4p4nTsU> dunno, italian university is strange
01:04:37 <wli> dons: I've never followed it or looked into it.
01:04:44 <B4K4p4nTsU> they have exams in like july
01:04:56 <dons> wli, oh, its a paid way to get 10 or so projects funded, and train up a new set of experts in the community
01:05:01 <B4K4p4nTsU> at least that's my understanding. i never quite go it
01:05:01 <dons> rather good for the haskell community
01:05:08 <dons> oh, that's interesting
01:06:27 <wli> dons: I don't really have the time/energy for side projects of the appropriate form. If what I'm doing now pans out it won't be much more than a numerical analysis paper, if it's even paper-worthy (which it probably isn't).
01:06:44 <blackdog_> hey, how do you search for a function of a given type?
01:06:53 <shachaf> @hoogle a -> [a]
01:06:54 <lambdabot> Prelude.repeat :: a -> [a]
01:06:54 <lambdabot> List.intersperse :: a -> [a] -> [a]
01:06:54 <lambdabot> Prelude.(:) :: a -> [a] -> [a]
01:06:54 <B4K4p4nTsU> hoogle?
01:07:04 <blackdog_> ah, that's the one. cheers.
01:07:10 <wli> blackdog: Induction on the structure of terms.
01:07:36 <blackdog_> @hoogle a -> (a -> a) -> (a -> Bool) -> a
01:07:36 <wli> Never mind.
01:07:37 <lambdabot> Prelude.until :: (a -> Bool) -> (a -> a) -> a -> a
01:07:45 <blackdog_> there we go:)
01:08:23 <wli> until looks suspiciously like fixWhile
01:08:38 <wli> Or what I had as fixWhile.
01:09:21 <blackdog_> @hoogle a -> (a -> a) -> (a -> a -> Bool) -> a
01:09:22 <lambdabot> No matches, try a more general search
01:09:27 <blackdog_> bah. ah well.
01:09:42 <blackdog_> (need to be able to look at the current val and the next one, i think...)
01:09:46 <mauke> let a = (b, b)
01:09:52 <wli> blackdog: Yeah, iterating to convergence.
01:09:58 <DRMacIver> wli: Presumably fixWhile = until . (not.)
01:10:21 <blackdog_> wli: yes, exactly.
01:10:33 <DRMacIver> (i.e. fixWhile iterates while the predicate holds, until iterates while it doesn't)
01:10:50 <quicksilver> blackdog_, wli: that's normally expressed with a zip of vals and (tail vals)
01:11:15 <quicksilver> IIRC there is a running example in 'why FP matters'
01:11:48 <wli> DRMacIver: Actually no, it was (a -> a -> Bool) -> (a -> a) -> a -> a and did a zip internally to pair things for the predicate.
01:11:57 <DRMacIver> I meant operationally. :)
01:11:59 <dons> btw, we should really get this on the wiki, if Evan Martin isn't going to maintain it, http://neugierig.org/software/darcs/haskell-for-programmers/haskell-for-programmers
01:12:05 <lambdabot> http://tinyurl.com/2ezmcm
01:12:30 <DRMacIver> I guess I meant == rather than =
01:13:02 <DRMacIver> (Note: Code only compiles using GHC version omega_1, when they added the halting problem module)
01:14:16 <wli> DRMacIver: fixWhile p f x = let ys = iterate f x in snd . head . dropWhile p $ zip ys (tail ys) -- or similar
01:14:47 <DRMacIver> Sure. I can imagine how it was implemented. :) My point was not an implementation one, but that although the type signatures were suspiciously similar fixWhile and until probably did opposite things.
01:15:09 <dons> blackdog_: you working on some secret haskell project?
01:15:17 <vincenz> fixWhile p f x = let y = iterate f x in takeWhile p y
01:15:18 <wli> I forgot to uncurry p
01:15:22 <vincenz> wli: ^^^
01:15:25 <blackdog_> dons: yah. :)
01:15:31 <blackdog_> not that secret
01:15:34 <wli> vincenz: Not even close.
01:15:46 <dons> url? commercial-in-confidence?
01:15:53 <wli> vincenz: fixWhile p f x = let ys = iterate f x in snd . head . dropWhile (uncurry p) $ zip ys (tail ys) -- or similar
01:15:54 <blackdog_> just getting sick of trying to bind to stupid C libraries when i really only want a simple function...
01:16:03 <blackdog_> it's a bit embryonic at the moment
01:16:04 <vincenz> wli: that seems more complicated than a "fix ... while"
01:16:05 <dons> ok, interesting... 
01:16:12 <dons> c2hs or something like it?
01:16:17 <blackdog_> basically, it's a facebook plugin for doing friend visualisation
01:16:25 <vincenz> (a -> Bool) -> (a -> a) -> a -> [a]
01:16:31 <dons> oh, graphs and data structure stuff?
01:16:45 <Korollary> I visualize all my friends
01:16:52 <blackdog_> dons: the interface to c wasn't the hard part - it's that the actual API offered was sorta crap
01:16:56 <wli> vincenz: You're describing more of an iterateWhile (which I also had something for).
01:16:59 <dons> do the logic in haskell, and some C lib for the graph crunching?
01:17:08 <blackdog_> that's kind of it.
01:17:17 <dons> sounds plausible
01:17:32 <blackdog_> but i'm hacking up a haskell version for the graph crunching as well, just to see if it's less pain than hacking up graphviz
01:17:34 <dons> i've thought it would be interesting to draw trees of connections from facebook or linkedin data
01:17:36 <wli> blackdog: Or use array indices as Fortran pointers.
01:17:44 <blackdog_> dons: that's exactly it
01:18:01 <dons> yeah. that'd be cool
01:18:02 <blackdog_> there's one called friendexplorer that does it already, but it's a pretty crap interface
01:18:12 <blackdog_> i want to be able to navigate the social network
01:18:21 <dons> blackdog_: you could extract graphs from other networks too
01:18:26 <B4K4p4nTsU> friendster?
01:18:27 <dons> find out who's replying to who on the mailing list , for example
01:18:31 <blackdog_> that's true.
01:18:31 <dons> or done research papers together
01:18:37 <blackdog_> nothing really binds it to facebook.
01:18:38 <B4K4p4nTsU> that stuff has already been done
01:18:41 <dons> (citeseer has that raw data)
01:18:55 <vincenz> dons: plenty of books on that
01:19:10 <dons> seriously, B4K4p4nTsU, you need a new nick. you'll get ignored otherwise -- its a /hostile/ nick in this channel
01:19:11 <blackdog_> B4whatever: yeah, i'm not really looking to do research here. just want a cool app that people might use.
01:19:17 <dons> vincenz: yeah.
01:19:24 <vincenz> dons: "small worlds" :)
01:19:39 <dons> blackdog_: i'm listening to the radio now, i note Malcolm Turnbull has a myspace page and a facebook page now..
01:19:44 <B4K4p4nTsU> dons meh, i guess it's the people who ignore me's loss :)
01:19:54 <dons> B4K4p4nTsU: you really should change it
01:20:10 <wli> blackdog: There are graph theoretical affairs involving eigenvalues of things related to adjacency matrices.
01:20:57 <blackdog_> wli: um, could you be more specific? I'm sorry, my finite maths is rustier than i'd like to admit.
01:21:02 <wli> blackdog: http://en.wikipedia.org/wiki/Eigenvector_centrality
01:21:03 <lambdabot> Title: Eigenvector centrality - Wikipedia, the free encyclopedia
01:21:21 <B4K4p4nTsU> http://liarpedia.org/wiki.cgi/Eignevector_centrality
01:21:22 <lambdabot> Title: Eignevector centrality - Lies, Damn Lies and Wikipedia
01:21:37 <B4K4p4nTsU> woops, typo
01:21:49 <cybercobra> liarpedia?
01:22:01 <B4K4p4nTsU> try it out, it's fun.
01:22:22 <vincenz> B4K4p4nTsU: as long as it's not offensive pictures like the other day
01:22:25 <dons> B4K4p4nTsU likes to post links to it.
01:22:33 <mauke> Eigenvector centrality, LLC., most widely known as ESEA, is an American electronic sports company that specializes in hosting semi-organized, non-league pick-up games (PUGs) for the popular game Half-Life: Counter-Strike and Counter-Strike: Source.
01:22:34 <B4K4p4nTsU> dons yeah, i made it!
01:22:42 <mauke> I see what you did there
01:22:57 <B4K4p4nTsU> interestingly, it runs on an http server i wrote in haskell!
01:23:12 <dons> serious? where's the source?
01:23:15 <vincenz> B4K4p4nTsU: Please change your nick, you've been told several times.
01:23:26 <B4K4p4nTsU> dons http://people.freebsd.org/~ssouhlal/stuff/rephttpd-0.4.hs
01:23:44 <mauke> B4K4p4nTsU: broken page title: Exit Strategy %28Charmed episode%29
01:23:50 <mauke> those should be parens
01:23:56 <B4K4p4nTsU> mauke yes, i don't do base64 crap
01:24:02 <mauke> it's not base64
01:24:09 <B4K4p4nTsU> %29 is
01:24:12 <mauke> no
01:24:17 <B4K4p4nTsU> whatever it is, i don't do it :)
01:24:18 <mauke> that's just url encoding
01:24:38 <B4K4p4nTsU> liarpedia is just a simple shell script http://people.freebsd.org/~ssouhlal/stuff/liarpedia.txt
01:25:05 <dons> B4K4p4nTsU: why don't you go back to being reppie or rep?
01:25:18 <blackdog_> wli: thanks, that's an interesting link
01:25:24 <B4K4p4nTsU> i got bored with those nicknames
01:25:31 <blackdog_> i'm not sure i can use the concept, though - i never store the full graph
01:25:45 --- mode: ChanServ set +o vincenz
01:25:49 <blackdog_> (given that it's got millions of nodes, with probably about 100 million edges...)
01:26:04 <dons> B4K4p4nTsU: ok. you have to change your name though. do so now, or you'll be kicked.
01:26:14 <B4K4p4nTsU> i guess i'll be kicked, then
01:26:16 <B4K4p4nTsU> good bye
01:26:18 --- kick: B4K4p4nTsU was kicked by vincenz (vincenz)
01:26:29 <blackdog_> and facebook is a bit stingy about handing out the data anyway...
01:26:29 --- mode: vincenz set -o vincenz
01:26:58 <dons> yeah, silly facebook
01:27:53 <blackdog_> i'm impressed that they're as open as they are. i can sort of understand that they don't want to let people mine it explicitly
01:28:28 <blackdog_> technically, you can get the data out - they have a primitive of the form [(Id,Id)] -> [Bool]
01:28:32 <dons> its not like its their data though. stupid social networking
01:28:37 <dons> we create the content, they profit
01:28:56 <blackdog_> web 2.0 :)
01:29:07 <shachaf> Hmm. I understand that people don't like hard-to-read nicks, but what was the specific reason to get so upset in this case?
01:29:16 * shachaf thinks he's missing something.
01:29:28 <dons> oh, he's been problematic since February
01:29:41 <dons> posting links to offensive content, and using offensive nicks, or semi-hostile ones like this
01:29:44 <vincenz> shachaf: he's had multiple rather offensive nicknames before
01:29:56 <shachaf> Oh.
01:30:01 <ejt> in his behaviour, or just nick choice ?
01:30:03 <shachaf> I guess I hadn't seen that.
01:30:17 <dons> behaviour, and nick. he should revert to 'reppie', his old nick.
01:30:22 <dons> and not post offensive links.
01:30:32 <dons> or use nicks like 'm4ster_baiter' et al
01:30:38 <vincenz> ejt: nikcnames like "master_baiter" and something related to trans, and then posting pictures of women .. peeing public
01:31:29 <dons> interestingly, we thought he was a bot yesterday, which is probably reason enough to act. this is #haskell after all, we want a coherent community. using non-AOL nicks is part of that, and not posting offensive links is definitely part of that.
01:31:38 * vincenz nods
01:32:01 <blackdog_> dons: it's true. but it's also their servers, their code, their hard work... i don't think it's unreasonable to exercise some control of data
01:32:12 <ejt> vincenz: blech
01:32:16 <dons> blackdog_: yeah
01:33:40 <blackdog_> much as it annoys the crap out of me to have to scavenge the data in odd little ways :)
01:34:07 <dons> revolution starts somewhere ;)
01:35:10 <mauke> haskell++  # I think I "get" threads now
01:35:41 <dons> oh, that's interesting mauke :)
01:35:49 <mauke> I have this little program and it uses 8 threads as if it was nothing
01:35:55 <vincenz> mauke: ST?
01:36:09 <mauke> no, IO and STM
01:36:14 <dons> so the threads are easy to manage, you mean?
01:36:25 <mauke> yes
01:36:39 <mauke> I don't really have to "manage" them
01:36:42 <mauke> it just works :-)
01:36:49 <dons> i didn't get threads till I worked out forkIO $ some random code
01:36:58 <dons> and then it was a bit of a realisation: threads don't have to suck
01:37:15 <dons> compare and contrast with java.
01:37:19 <mauke> I have the advantage of not having used threads before
01:37:35 <matthew-_> it's not threads that suck, it's the interactions between them
01:38:14 <blackdog_> i'm still a bit confused as to the different models available - is there a flavour of haskell threads as lightweight as erlang threads, for instance?
01:38:30 <dons> blackdog_: yes, haskell threads by default are light, as erlang.
01:38:31 <dons> but faster
01:38:42 <dons> and you get smp on more than just x86
01:38:53 <blackdog_> ok. so forkIO is a thread primitive, not a process one?
01:39:01 <mauke> right
01:39:03 <dons> that's the basic model: lightweigth thread primitives based on select/epoll
01:39:10 <blackdog_> oh, nice.
01:39:10 <dons> not process threads.
01:39:15 <mauke> you need forkProcess if you want a real fork()
01:39:30 <dons> there's an alternative threading model optimised for linux, using just epoll, which runs up to 10M threads 
01:39:49 <dons> not sure what the upper limit for forkIO threads is currently
01:39:52 <dons> 10k or so has been done
01:40:01 <dons> (lambdabot forks a thread for *each line of text* for example)
01:40:05 <blackdog_> 10k is enough for my purposes, i think :)
01:40:20 <blackdog_> each line of text it reads or writes?
01:40:25 <dons> that it reads
01:40:31 <dons> is handled in its own thread
01:40:48 <dons> there's the lightweight thread benchmark, http://shootout.alioth.debian.org/gp4/benchmark.php?test=chameneos&lang=all
01:40:50 <lambdabot> Title: chameneos benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Languag ..., http://tinyurl.com/lrhoa
01:41:28 <dons> the scaling might be an issue if you needed 1M threads. you'd have to start with the epoll lib
01:41:28 <mauke> btw, here's my program if anyone wants to look at it: http://rafb.net/p/Phsta584.html
01:41:29 <lambdabot> Title: Nopaste - No description
01:42:21 <dons> mauke: oh, that's interesting.
01:42:30 <dons> you're forking threads, and some external processes?
01:42:36 <mauke> yes
01:42:37 <blackdog_> bizarre that apache still uses one process per request... :)
01:42:46 <mauke> the external processes are just `dcop amarok player ...`
01:42:55 <dons> is this an xmonad wrapper?
01:43:05 <dons> blackdog_: yeah.
01:43:09 <mauke> it's a status printer
01:43:12 <mauke> I pipe it into dzen2
01:43:22 <dons> ah right. you're doing the glue in haskell
01:43:24 <dons> instead of shell
01:43:33 <dons> so its a multiplexer thingy?
01:43:59 <dons> this is what I want to play some more with, blackdog_ : http://www.seas.upenn.edu/~lipeng/homepage/unify.html
01:44:00 <lambdabot> Title: Unifying events and threads
01:44:24 <dons> nice little web server, running 10M threads happily
01:44:29 <mauke> yes, it collects xmonad logging output, music player status, upload/download rate, cpu usage, memory usage, and current time
01:44:34 <dons> take that erlang ;) typed, concurrent *and* native code
01:45:01 <blackdog_> very nice :)
01:45:06 <blackdog_> so, hang on
01:45:14 <Korollary> dons: erlang guys want ocaml bindings nowadays
01:45:26 <mauke> the communication with xmonad/amarok is done with my miniplex handles (look for MP.attach in the code)
01:45:27 <dons> Korollary: huh, that's interesting. i noted the ruby/ocaml binding recently
01:45:27 <blackdog_> isn't the standard model doing this already? taking specs in terms of thread code, but executing it in an event loop?
01:45:57 <dons> hmm?
01:46:23 <dons> Korollary: so erlang as concurrency glue for fast nodes in ocaml?
01:46:32 <skew> blackdog_: what was that about just wanting one C function?
01:46:40 <skew> blackdog_: that sounds suspiciously like a nice project itself
01:46:47 <quicksilver> dons: I didn't have internet there for 40 mins, was just reading that haskell-for-programmers guide you linked to
01:46:56 <quicksilver> dons: it's a really nice start, it's a shame it doesn't go further
01:46:57 <blackdog_> one C function?
01:47:05 <quicksilver> dons: shame he didn't know about 'let' in ghci, too :)
01:47:07 <dons> i agree , quicksilver . looks like Evan abandoned it last July
01:47:12 <blackdog_> i was trying to link into GraphViz
01:47:13 <dons> i've emailed him.
01:47:18 <earthy> dons: interesting stuff, that.
01:47:21 <skew> I thought you were perhaps talking about some kind of nice dlopen binding
01:47:22 <dons> we'll see if we can get it on the wikibook or something
01:47:29 <Korollary> dons: http://www.nabble.com/ocaml-dll-in-an-Erlang-runtime-tf3957601.html#a11229785
01:47:31 <lambdabot> Title: Nabble - ocaml dll in an Erlang runtime, http://tinyurl.com/2vggpw
01:47:31 <dons> earthy: the unified threads stuff?
01:47:33 <blackdog_> skew: nah, nothing terribly clever :)
01:47:35 <quicksilver> blackdog_: do your own custom visualation, much more fun :)
01:47:44 <earthy> yup
01:47:50 <quicksilver> blackdog_: for friend networks, it's nice to visualise it as concentric rings around yourself
01:48:00 <dons> yeah, Peng Li is at MSR right now, iirc, working on the threading primitives
01:48:06 <dons> I think there's a HW paper
01:48:08 <blackdog_> i like the 'neato' model that graphviz has
01:48:10 <quicksilver> (and some heuristics to gropu the rings around their own inter-releationships)
01:48:12 <skew> hope they can get the performance up
01:48:15 <blackdog_> uses the force-based springs approach
01:48:26 <blackdog_> i actually don't graph the person you're looking at
01:48:50 <dons> that's a very very interesting link, Korollary 
01:48:54 <blackdog_> it muddies up the other relationships - it's pretty obvious that everyone you're looking at is connected to them, so you might as well leave those links out
01:49:04 <dons> we could use both things: a binding to ocaml, *and* erlang binding to haskell
01:50:55 <dons> hmm, bindings to ocaml or erlang would make great student projects
01:51:58 <quicksilver> dons: a binding which did anything sensible with the type system would be hard, methinks
01:52:10 <quicksilver> dons: hmm. Maybe I overestimate the problems.
01:52:15 <skew> I thought somebody had bits of the erlang distribution protocol
01:52:29 <dons> ocaml/haskell wouldn't be too hard. 
01:52:36 <dons> if things are ever going to line up, its those two 
01:52:36 <skew> except around records
01:52:45 <dons> yeah, there's always parity issues
01:52:50 <skew> objects, rather
01:52:54 <dons> at least we know how to connect modules and type classes
01:52:58 <quicksilver> objects schmobjects
01:53:02 <dons> and mutable stuff can be done as for C.
01:53:05 <quicksilver> nobody cares about that part of ocaml ;P
01:53:11 <skew> I suppose you could use HList
01:53:36 <quicksilver> Just doing the ML fragment of ocaml would be fine ;)
01:53:40 <dons> yes.
01:53:46 <dons> and that's all anyone cares about. :)
01:53:59 <dons> binding to any interresting ocaml libs, and being able to mix and match components in either language
01:54:01 <vincenz> yes, especially the lack of first class data construtors
01:54:07 * vincenz shudders
01:54:16 <quicksilver> vincenz: haskell constructors aren't actually first class, by the way
01:54:21 <quicksilver> that would imply first-class patterns
01:54:23 <quicksilver> which we don't have :)
01:54:26 <vincenz> > map Just [1..]
01:54:27 <lambdabot>  [Just 1,Just 2,Just 3,Just 4,Just 5,Just 6,Just 7,Just 8,Just 9,Just 10,Just...
01:54:31 <dons> erlang <-> haskell might make more sense
01:54:32 <vincenz> instead of
01:54:35 <quicksilver> haskell just defines a function which has the same name as the constructor
01:54:37 <vincenz> map (fn x => Just x) [1..]
01:54:38 <quicksilver> which is convenient
01:54:41 <dons> to get a nice glue for distributed haskell
01:54:41 <quicksilver> (very convenient)
01:54:44 <quicksilver> but still not first-class
01:54:57 <dons> whereas ocaml would be for number crunching, which we thing we can do anyway ;)
01:55:18 <skew> I'd rather rip off the module system entirely
01:55:25 <dons> getting cheap distribution using erlang glue would be useful though. since no one is likely to work on that soon
01:55:31 <wolverian> atlas3 bindings would be nice, and a high level module on top of that
01:55:34 <wolverian> (for number crunching)
01:55:52 <vincenz> quicksilver: i see
01:55:53 <dons> currently to do that you run a single haskell program on each node, and talk via tcp or similar. nice, but needs more lib support
01:55:56 <wli> skew: Yeah, I really wish we had ML-esque modules in addition to what we've already got.
01:56:00 <quicksilver> dons: I thin it would be just as productive to develop a cheap distribution model using erlang as a guide
01:56:11 <quicksilver> dons: instead of actually bridging to erlang
01:56:24 <quicksilver> dons: the latter would be interesting in a kind of 'hmm, that's interesting' way :)
01:56:35 <quicksilver> but the former would be more interesting in a 'I'm going to use that!' way
01:56:37 <wli> wolverian: I don't know. It would sort of be nice to get the parallelism for number crunching via native Haskell implementations.
01:56:48 <dons> yes, given we do already (well, some of us) write distributed haskell nodes (there's even an MPD binding)
01:56:58 <dons> we could probably do that now.
01:57:12 <quicksilver> I used MLj in a research project once
01:57:14 <wolverian> wli, isn't atlas kind of orthogonal to that
01:57:21 <quicksilver> that is an abandoned SML->java bridge
01:57:27 <quicksilver> it was a bit of a revelation to me:
01:57:33 <vincenz> jocaml is spiffy
01:57:33 <dons> let's hope java will die soon
01:57:46 <quicksilver> even though I don't like imperative SML, imperative SML using java concepts is still better than java
01:57:57 <vincenz> dons: well it's a great portable backend (the jvm)...albeit badly designed
01:57:59 <wli> wolverian: I'm not sure. One could in principle use it on blocks etc.
01:58:00 <wolverian> dons, let's not. I don't like the .net languages much better. :)
01:58:14 <vincenz> We need Piskell
01:58:18 <vincenz> to match Jocaml
01:58:22 <wolverian> quicksilver, have you tried scala? 
01:59:47 <DRMacIver> Scala is a very nice replacement for Java. It's not that stellar a language. :)
01:59:51 <wli> vincenz: Targets universally suck. Not enough programming language and/or compiler people hook up with the architecture designers and usually it's too late once they get to the point where feedback is possible.
02:00:15 <quicksilver> wolverian: no. It was a one-off research project
02:00:23 <quicksilver> wolverian: I wouldn't do it again, that way
02:00:35 <quicksilver> wolverian: but we had a requirement for to produce an applet that would run in a web browser
02:00:55 <vincenz> wli: 'targets' /
02:01:01 <vincenz> wli: and yes, that is why I blogged about the problems :)
02:01:03 <quicksilver> wolverian: and I had to write heavy symbolic logic manipulation and I sure as hell wasn't going to do that in java, hence MLj
02:01:08 <vincenz> wli: there should be people looking at both aspects
02:01:18 <quicksilver> dons: It would be really nice to be able to write haskell GUI applications an embed them in web pages
02:01:30 <wli> vincenz: Not likely to happen in the foreseeable future. x86 uber alles etc.
02:01:30 <quicksilver> dons: so it would be nice to be able to compile to either JVM or the Flash VM
02:01:33 <blackdog_> haskell -> js compiler? :)
02:01:39 <vincenz> wli: and?
02:01:48 <vincenz> wli: besides, that is incorrect
02:01:50 <quicksilver> haskell -> actionscript probably better
02:01:58 <quicksilver> actionscript is very similar to JS in structure
02:02:05 <quicksilver> but has a much more powerful/faster graphics layer
02:02:13 <wli> vincenz: Hardware architectures are not going to rediversify anytime in the foreseeable future.
02:02:19 <blackdog_> actionscript is the flash language, right?
02:02:21 <vincenz> wli: you have a very skewed view
02:02:23 <quicksilver> blackdog_: right
02:02:31 <quicksilver> wli: I dispute that strongly
02:02:32 <blackdog_> JS has the advantage of ubiquity...
02:02:43 <skew> wli: oh? It seems to be rather the other way around
02:02:48 <quicksilver> wli: unless you have a different view of 'architecture' and 'forseeable'
02:02:59 <vincenz> anyways
02:03:01 <vincenz> time to do some real work
02:03:01 <skew> wli: all this stuff about many cores and concurrency everywhere seems like big motivation for new languages
02:03:10 <quicksilver> wli: I think the majority of machines will be 4 core within 5 years, and massively multicore (32+) within 10 years
02:03:15 <wli> skew: Languages are fine. I said targets.
02:03:17 <vincenz> quicksilver: sooner than that
02:03:21 <vincenz> quicksilver: in 20 years we'll be manycore
02:03:25 <vincenz> even 15 years
02:03:27 <dons> i thought we had a flash generator already
02:03:29 <quicksilver> where 'multicore' I incldue the hyperthreading stuff
02:03:32 <vincenz> manycore = 100s of ores
02:03:36 <dons> an eDSL for actionscript, anyway
02:03:50 <wli> quicksilver: That's orthogonal to target machine language.
02:03:50 <vincenz> not to mention cores will  become less and less reliable
02:03:52 <vincenz> so you need redundance
02:03:54 <quicksilver> vincenz: well that's broadly compatible with my estimate
02:03:59 <vincenz> wli: and, x86 is but a small market share
02:04:00 <skew> then once you really go for some high-level languages over lots of cores, that seems to open up the architecture a lot
02:04:02 <quicksilver> vincenz: but I was being deliberately conservative
02:04:06 <vincenz> wli: you forget about all the TIs and ARMs
02:04:19 <quicksilver> remember iPods, smartphones, PDAs
02:04:19 <dons> you can buy 16 core desktops at almost commodity rates now
02:04:21 <vincenz> wli: no portable device uses x86
02:04:25 <wli> vincenz: Embedded is not diversifying, though it does have non-x86.
02:04:26 <quicksilver> these outnumber PCs now
02:04:36 <vincenz> wli: do you have anything to back up thos efacts?
02:04:38 <skew> throw in a pentium or two on the die for old-times sake, then crank out a few hundred of some simple efficient core
02:04:44 <quicksilver> wli: I think you have a different definition of 'diversity' to me
02:04:44 <vincenz> wli: like attending conferences where all the major vendors go?
02:04:58 <quicksilver> dons: got any kind of URL or reference for that?
02:05:06 <dons> for the machines?
02:05:09 <dons> yeah, hang on.
02:05:09 <vincenz> (such as DATE or DAC or ISCAS or ISSCC)
02:05:12 <quicksilver> dons: no :)
02:05:17 <quicksilver> dons: the flash/actionscript
02:05:27 <dons> oh, stepcut wrote it
02:05:36 <wli> vincenz: I've attended conferences where CPU vendors present, albeit not embedded CPU vendors.
02:05:38 <dons> so hmm, its either on hackage, or just the mailing list
02:05:50 <skew> About concurrency, we realized the other day that event loop systems over a pile of mutable state are just about a CPS transform away from STM
02:05:52 <quicksilver> ah I find out a ferw links
02:05:55 <dons> not on hackage, check the mailing list
02:06:02 <quicksilver> http://www.mail-archive.com/haskell@haskell.org/msg20064.html
02:06:02 <lambdabot> Title: [Haskell] ANNOUNCE: Haskell SWF generation library
02:06:03 <vincenz> wli: I talkked with a lead scientist at ARM, they were -begging- for a new programming model so they can match their hardware to it
02:06:09 <quicksilver> dons: my google-fu prevalied :)
02:06:28 <wli> vincenz: My day job is kernel hacking. I hear about architecture affairs.
02:06:47 <quicksilver> dons: however, it's an eDSL assembler :(
02:06:50 <vincenz> wli: alright
02:06:51 <quicksilver> dons: that's a bit low level
02:06:52 <skew> implicitly atomic between yield points, and of course all those libs use the cheating STM implementation for a single core with cooperative switching...
02:07:11 <vincenz> wli: I research at imec, which participates heavily in conferences about novel architectures
02:07:14 <quicksilver> dons: Jeremy Shaw == stepcut
02:07:15 <wli> vincenz: Architectures dying off is a daily topic of discussion in kernel programming.
02:07:25 <vincenz> albeit in the embedded domain
02:07:36 <vincenz> where embedded is not just small things but scales up to anything which is not a pc 
02:07:40 <vincenz> (so including pdas, etc
02:07:45 <quicksilver> I think it's quite reasonable to suggest that the x86 architecture will 'survive'
02:07:52 <quicksilver> in the sense that there will be a transition path
02:07:56 <quicksilver> and intel will keep making chips
02:07:56 <vincenz> an architecture is more than the data-path
02:08:02 <quicksilver> but it will have changed so fundamentally
02:08:03 <vincenz> there's the whole NOC framework around it
02:08:09 <quicksilver> that it will no longer be x86 as we know it
02:08:11 <skew> I wouldn't be surprised if your PC kept booting off an x86 core for years to come
02:09:57 <wli> Well, there is a significant component of the rationale for architectural non-diversification centering around resource/economic trends as well.
02:10:25 <vincenz> wli: Yes, fablines are incredibly expensive
02:10:31 <vincenz> (we have one btw)
02:10:36 <vincenz> That being said
02:10:39 <vincenz> current models -do not scale-
02:11:20 <vincenz> that's why most major chip vendors are fabless
02:11:24 <vincenz> and they ask someone else to do it for them
02:11:30 <vincenz> like ...what's the name
02:11:31 <vincenz> TSC?
02:12:11 <quicksilver> @seen stepcut
02:12:11 <lambdabot> I saw stepcut leaving #haskell 3d 16h 5m 42s ago, and .
02:12:32 <vincenz> wli: I'd be interested on your feedback on http://notvincenz.blogspot.com/2007/04/observations-from-date-2007.html
02:12:35 <lambdabot> Title: lambda.oasis: Observations from DATE 2007, http://tinyurl.com/yw4e7z
02:12:59 <skew> So, how small can you make a die before it's just too hard to handle it?
02:13:14 <skew> And what process do you need for that to be plenty powerful to run a high-level language?
02:13:25 <vincenz> skew: why do you want to decrease die-size?
02:13:45 <vincenz> (beyond a certain threshold that is)
02:13:47 <skew> other way around, I've seen claims C will survive in the cheapest embedded systems
02:14:38 <vincenz> wli: tbh, I think the major reason that we'll need different architectures (besides just the meta-architecture around single coreso f the whole NoC network) is reliability
02:16:37 <skew> but it seems like just being able to see and wire up things sets some limits on how small you want to make a die
02:20:15 <quicksilver> dons: hmms. HaXe looks to have drawn quite a bit from haskell, but it's totally imperative.
02:22:19 <skew> @hoogle forkProcess
02:22:23 <lambdabot> No matches found
02:22:29 <mauke> @index forkProcess
02:22:29 <lambdabot> System.Posix.Process, System.Posix
02:27:41 <wli> vincenz: If I'm right about these things, there are a lot of things we need that we'll never get.
02:27:50 <quicksilver> oh, how depressing
02:27:58 <quicksilver> "As a side note, I was going to try Haskell, the allegedly purest functional language, until I read this post (the URL is fixed), and decided not to spend a lot of time with Haskell."
02:27:59 <jethr0> i'm trying to turn to Word8's into one Word16. "shiftL i1 8 + i2" doesn't work though. any suggestions?
02:28:11 <quicksilver> jethr0: i1 * 256 + i2 ?
02:28:25 <quicksilver> erm, (fromIntegral i1)*256 + (fromIntegral i2)
02:28:31 <jethr0> ;)
02:28:35 <quicksilver> tis' actually probably the fromIntegral you were missing
02:28:40 <skew> shiftL should work too
02:28:42 <jethr0> k, thx, i'll try that
02:28:44 <skew> with the fromIntegral
02:28:50 <thorkilnaur> skew, maybe not relevant, but if you plan serious use of forkProcess, you should be aware of http://hackage.haskell.org/trac/ghc/ticket/1391
02:28:52 <lambdabot> Title: #1391 (forkProcess() in Schedule.c with -threaded should initialize mutexes in c ...
02:29:25 <skew> It was mentioned a while ago, and I didn't remember it at all
02:29:37 <skew> mentioned in the channel, that is
02:29:44 <skew> I thought they maybe meant forkOS
02:29:55 <quicksilver> forkOS - OS thread
02:30:01 <quicksilver> forkProcess = true process
02:30:05 <quicksilver> (on a POSIX machine)
02:30:12 <wli> I'm not sure how one would type packing/unpacking primitives.
02:30:18 <quicksilver> not many occasions when you need a true fork, I don't think
02:30:30 <skew> forkOS isn't really an OS thread either
02:30:40 <skew> just looks like it to foreign calls
02:31:08 <quicksilver> yes, good point
02:31:17 <quicksilver> it's an OS thread if/when it needs to be
02:31:30 <mauke> quicksilver: every time you want to start another program
02:32:38 <quicksilver> mauke: well, normally runInteractiveProcess and friends are good enough for that
02:32:53 <quicksilver> mauke: you only need to fork by hand if you need to do custom futzing with fds and so on
02:33:22 <mauke> most of my foreign processes aren't interactive :-)
02:33:44 <skew> are you actually calling exec in the child process?
02:33:51 <mauke> yes
02:34:10 <quicksilver> mauke: well, which is why I said 'and friends'
02:34:41 <skew> what setup do you do before the exec, that you actually need forkProcess?
02:35:10 <mauke> skew: another fork
02:36:18 <skew> so why the forkProcess? it sounds like you shouldn't need it, but if you have to use it then there's probably something tricky I ought to know about
02:36:46 <mauke> I want to start a program without having to wait() for it
02:37:00 <skew> so how does forkProcess help with that?
02:37:52 <mauke> I fork() and immediately waitpid(). the child also fork()s and then _exit()s
02:38:01 <mauke> the grandchild calls exec()
02:38:24 <skew> so you don't get a result back at all?
02:38:28 <mauke> that way I have no lingering child processes to worry about
02:38:39 <mauke> no exit status, yes
02:38:51 <skew> oh, you just want the processes isolated a bit
02:39:01 <dons> quicksilver: oh, yes, joel's blog is used as justify not learning haskell
02:39:26 <quicksilver> dons: yup. Cale actually posted a decent rebuttal and it was fine
02:39:27 <skew> so it's like runCommand, except disowning the process
02:39:29 <quicksilver> Cale++
02:39:58 <quicksilver> mauke: Yes, fair enough. I stand by my initial comment that "normally" you don't need it, although of course you do for that case.
02:40:01 <skew> pity he missed Data.Binary and all that
02:40:08 <dons> yes. :/
02:40:17 <quicksilver> mauke: you could make a good case for System.Process.runDaemonic
02:40:18 <dons> he rolled his own, from a research paper, and it sucked.
02:40:25 <mauke> damn, I can't remember what exactly is wrong with System.Process.run*
02:40:37 <mauke> it had something to do with file descriptors IIRC
02:40:50 <quicksilver> mauke: yes, it's a bit limited if you want to share some FDs and not others
02:40:57 <quicksilver> mauke: but it's OK for most common purposes
02:41:01 <skew> forking first shouldn't help there, or did you actually close things?
02:41:11 <mauke> skew: huh?
02:41:25 <skew> if it was just forkProcess (runCommand "blah"), I think the grandchild still shares your fds
02:42:02 <skew> or was it like forkProcess (mapM_ hClose [stdin,stdout,stderr] >> runCommand "hello")
02:42:46 <quicksilver> skew: I think you're conflating two issues
02:43:04 <quicksilver> skew: one is the double-fork to disown a child, which you really do need forkProcess for
02:43:14 <quicksilver> skew: the other was just muttering about the limited API of runProcess
02:43:16 <skew> I thought I was trying to separate them for something
02:43:19 <skew> ah
02:43:31 <quicksilver> runProcess lets you do some kinds of FD-futzing
02:43:38 <quicksilver> it makes certain permutations impossible
02:43:41 <skew> I thought mauke was saying runCommand was bad in this case and he needed forkProcess because of the fd stuff
02:43:42 <mauke> I remember actual brokenness, not just limits
02:43:51 <quicksilver> oh, really?
02:43:59 <quicksilver> I don't recall that, but my memory is unreliable
02:44:02 <skew> probably that wasn't the meaning
02:44:14 <skew> 02:39 < mauke> damn, I can't remember what exactly is wrong with System.Process.run*
02:44:17 <skew> 02:39 < mauke> damn, I can't remember what exactly is wrong with System.Process.run*
02:44:20 <skew> 02:39 < mauke> damn, I can't remember what exactly is wrong with System.Process.run*
02:44:23 <skew> 02:39 < mauke> damn, I can't remember what exactly is wrong with System.Process.run*
02:44:30 <skew> oops!
02:44:40 <quicksilver> ;)
02:45:07 <skew> that newline clears my typing space, right
02:45:24 <skew> 02:39 < mauke> it had something to do with file descriptors IIRC
02:45:51 <skew> probably what you said - but I think runInteractiveProcess lets you manage the standard fds at least
03:01:56 <quicksilver> dons: are your IRC stats in your timezone, or?
03:02:30 <dons> they're PDT I think
03:03:18 <dons> ?users
03:03:18 <lambdabot> Maximum users seen in #haskell: 355, currently: 313 (88.2%), active: 6 (1.9%)
03:08:23 <kolmodin> @yarr!
03:08:23 <lambdabot> This is the END for you, you gutter-crawling cur!
03:08:26 <kolmodin> good morning
03:08:30 <salz2> /john #perl
03:09:53 <dons> we saw that salz2 ;)
03:12:10 * wli looks at en.literateprograms.org
03:14:57 <wli> en.literateprograms.org appears to have something on enumerating all the rationals.
03:24:48 * quicksilver hands out some slaps on the mailing list
03:25:49 <dons> go quicksilver !
03:26:10 <dons> quicksilver: you might want to check the logs from earlier today
03:26:39 <dons> when we discussed improving Andrew Coppin's responses a bit , by encouraging him to prune the redundant 'ouch' replies
03:26:49 <dons> i mailed him privately about it, and sent one to the list
03:29:59 <quicksilver> :)
03:30:12 <quicksilver> dons: I was actually slapping someone who was suggesting we need to be meaner ;)
03:30:17 <quicksilver> dons: I don't think being meaner is the solution
03:30:38 <dons> yes, i agree with your response.
03:30:41 <quicksilver> dons: andrew's a bit chatty, but it doesn't take me more than 3 seconds to read 'ouch' and move on to the next
03:31:04 <quicksilver> and, to be honest, there has been some interesting ground covered in his threads
03:31:17 <dons> quite so. sometimes he really touches on some interesting things.
03:31:46 <quicksilver> I wish I had managed to generate even a 10th as much discussion in some of the ones I started :P
03:31:52 <dons> heh
03:32:57 <quicksilver> I think my emails are too long and scare people
03:32:59 <matthew-_> I just  subscribe to digest, read the subject lines, and move on
03:33:08 <quicksilver> but then, I like to cover possible questions upfront...
03:33:15 <matthew-_> the questions I've posted seem to get about 2 responses
03:33:15 <quicksilver> s/scare/bore/ ;)
03:34:17 <matthew-_> it's hard to have more mailing lists without explicit elitism
03:34:36 <matthew-_> it's not worked well in other communities, though haskell is a bit different imho
03:35:44 <quicksilver> I can't see logical grounds on which to split the mailing lists really
03:35:58 <quicksilver> almost any split I can think of would either risk the experts leaving the newbie list
03:36:08 <quicksilver> or, the experts all having to subscribe to both lists
03:36:11 <dons> no, it won't happen. 
03:36:12 <quicksilver> so what's the point of that? :)
03:36:22 <dons> we hvae libraries@ anyway , which is a bit more techie
03:37:05 <quicksilver> yeah, but that has a sensibly delineated scope
03:37:50 <matthew-_> I would enjoy a list of just type system discussion though
03:37:55 <dons> it would be interesting to look back at the mailing list threads from say, 5 years ago
03:38:02 <dons> to work out if tech discussion has declined.
03:38:28 <matthew-_> where I can ask bizarre questions about abusing haskell's type system...
03:39:02 <dons> that should happen on the -cafe
03:39:09 <dons> so that newbies can see what they can aspire to
03:39:18 <quicksilver> I agree
03:39:33 <quicksilver> Also, it's quite subjective, but for me haskell-cafe is far from high-volume
03:39:44 <quicksilver> I used to be on debian-devel when it was several hundred a day
03:39:49 <dons> we don't want to split the groups in this table: http://headrush.typepad.com/photos/uncategorized/buildingausercommunity.jpg
03:39:51 <lambdabot> http://tinyurl.com/yx8uhc
03:40:00 <dons> we just want to encourage more people to move up the arrow
03:40:28 <quicksilver> move along the arrow! enter the monad!
03:40:41 <matthew-_> quicksilver: the worst I've ever been on is debian-user
03:40:50 <dons> so i hinted at that, i hope people feel an obligation to dive in and help.
03:41:22 <ndm> i think half the problem has been one specific person starting rather wandering threads, to which there is almost no sensible answer
03:41:23 <lambdabot> ndm: You have 1 new message. '/msg lambdabot @messages' to read it.
03:41:53 <dons> ndm, yes, many such threads, filled out with 'lolz' and 'ouches'. he also has started answering people, so with that energy, i do hope he moves up the arrow
03:41:56 <matthew-_> ahh, improve mailman to detect uncomputable questions ;)
03:42:11 <quicksilver> when I was a student I was on multiple debian and non-debian messages, going through over 500 mails a day, and also regularly reading several newsgroups, presumably at least another 100 messages a day
03:42:14 <dons> anyone see the memcached binding, i linked to in a comment on reddit,.. http://neugierig.org/software/darcs/browse/?r=haskell-memcached;a=summary
03:42:15 <lambdabot> Title: darcs - haskell-memcached, http://tinyurl.com/25z8dc
03:42:18 <dons> ?where+ memcached http://neugierig.org/software/darcs/browse/?r=haskell-memcached;a=summary
03:42:19 <lambdabot> Done.
03:42:20 <quicksilver> and I don't think I spent more than an hour on it...
03:42:25 <ndm> plus he's using the phrase windoze, which pisses me off, since he's demonstrated that he doesn't respect windows and doesn't want to use anything else
03:42:34 <matthew-_> quicksilver: that's impressive - I can spend an hour writing an email...
03:42:35 <ndm> if you don't respect your computer, it will never respect you
03:42:45 <quicksilver> heh
03:42:51 <quicksilver> interesting, ndm
03:42:52 <dons> ndm, yes, I've written to him about AOL speak, and lolz and so on.
03:42:58 <quicksilver> I certainly don't respect my computer
03:43:10 <dons> politely. haven't had a reply yet, but we will see.
03:43:12 <quicksilver> although I imagine I understand it better than most computer users
03:43:17 <matthew-_> a computer's just a giant calculator - what is there to respect?
03:43:19 <dons> its a pity he's ignored my advanced to join irc instead of the mailing list
03:43:24 <mauke> he seems a bit, uh, airheaded
03:44:07 <dons> hard to say. he's also uploaded stuff to hackage already
03:44:19 <matthew-_> I actively respect a lot of engineers and actively disrespect a lot of the politics of Microsoft and Apple, but having seen /many/ flamewars, I avoid posting anything like that...
03:44:21 <dons> could just be online persona he's used to from other fora
03:44:33 <ndm> i don't mind people thinking a particular tool is not the right choice for the job (i.e. windows), but if its entirely within your power to change, and you choose not to, you have to admit that its the best choice
03:44:47 <dons> ndm, btw, did you see the fixed dates for the hackathon?
03:44:51 <dons> they ok with you?
03:44:59 <matthew-_> ndm: resistence to change is a powerful force ;)
03:45:01 <dons> and we get Freiburg beer too :) courtesy Stefan.
03:45:02 <ndm> plus, if you post "can someone please help me on windoze" the answer is "no", - no windows person will, no unix person can
03:45:36 <ndm> dons: after ICFP? yeah, i saw - its a case of negociating funding with my dept, and figuring out what i can pay myself, planes etc
03:45:47 <dons> ok. 
03:45:48 <quicksilver> jerzy++ {- replying to andrew with a zen parable. cute. -}
03:45:49 <ndm> i'll hope to come :)
03:45:56 <dons> i hope stating a couple of days isn't too hard for people
03:46:06 * dons will have a real job then, instead of a student. exciting!
03:46:08 <ndm> i've got 7 solid days of talks
03:46:12 <dons> yeah
03:46:19 <dons> i suggest sneaking off and hacking some code instead ;)
03:46:21 <ndm> i think if it was the day after, i would be dead anyway
03:46:30 <ejt> dons: writing the book ?
03:46:59 <dons> galois.com (more haskell hacking).
03:47:30 <ejt> looks interesting
03:47:37 <ivanm> dons: you're leaving sydanee then?
03:47:47 <dons> yeah
03:47:56 <dons> hmm, so we have this memcached binding, lambdabot, and a 20 node cluster
03:47:58 <ndm> what you doing at galois?
03:47:58 <dons> what can we do ?
03:48:20 <dons> ndm, not sure yet. something haskelly. there's a few projects available. compilers, applications. language stuff
03:48:23 <ndm> sell the 20 node cluster and buy some beer
03:48:34 <ndm> or pay my rent...
03:48:59 <ivanm> heh
03:49:07 <dons> it would pay a fair bit of rent, i'd imagine
03:49:10 <ndm> you could do a super-fast parallel shootout, as someone proposed
03:49:22 <dons> yeah, that's what i reckon. but multicore is better than clusters there
03:49:23 <ndm> compile things with Jhc?
03:49:26 <dons> heh
03:49:26 * malcolmw deletes 600 messages on haskell-cafe from the last 3 days, without reading
03:49:39 <ndm> malcolmw: use gmail, you only have to delete once per thread :)
03:49:41 <dons> malcolmw: hmm :| too much, eh?
03:49:56 <ndm> i've also stopped reading haskell-cafe, other than the ones that particularly draw me in
03:50:04 <dons> malcolmw: i wonder -- do guys like john hughes or spj even comment on -cafe threads now?
03:50:12 <dons> are the old hands already driven off, due to the noise?
03:50:13 <ndm> which is a shame, since usually the good bits occur in completely unexpected threads
03:50:14 <dons> or volume.
03:50:16 <malcolmw> yeah, there is a real danger of clued-in haskell people deserting the list
03:50:19 <ndm> nope, no jh or spj
03:50:22 <matthew-_> I love how SPJ clearly posts with /the/ most broken mail client I've seen - esp in a thread which started talking about mail clients...
03:50:49 <matthew-_> ndm: C-D in mutt will delete the thread
03:50:50 <malcolmw> most academics I know have unsubscribed a long time ago
03:51:04 <Philippa> I read occasionally, but not often
03:51:06 <ndm> dons: i think jh has posted to h', and spj hits ghc-cvs, h' and a few others, and occasionally replies on h-c
03:51:08 <dons> malcolmw: yes, that's a real issue. maybe its too late.
03:51:27 <dons> CR doesn't post. lennart does though.
03:51:29 <Philippa> yes and no. I mean, there's always the upcoming generation to worry about too
03:51:41 <ndm> dons: CR doesn't reply to my emails, i'd be offended if he replied on h-c
03:52:06 * malcolmw thinks the answer is to piss off the newcomers and shrink the community again >:-)
03:52:25 <dons> so is -cafe@ now the '2nd' generation (phd students of the last generation) answering questions for newbies.
03:52:36 <ndm> have a "CAPTCHA" to subscribe, which is a haskell problem
03:52:41 <dons> while the first gen haskell guys aren't on the lists anymore
03:52:44 <Philippa> all too often, yes
03:52:56 <matthew-_> makes it harder to avoid repeating history
03:52:59 <dons> yes
03:53:04 <Philippa> ndm: that's a bit nasty, genuine tech support questions're fair game
03:53:10 <matthew-_> must learn from those who went before us... ;)
03:53:25 <Philippa> I suspect the freaking out about maths is half the problem - how much traffic does that consume these days?
03:53:27 <malcolmw> I've noticed a growing tendency for announcements to go to -cafe instead of haskell@
03:53:37 <dons> yes, since that's where everyone is.
03:53:43 <matthew-_> malcolmw: I thought they should go to both
03:53:48 <dons> 2k people on -cafe@ .. all users.
03:53:58 <Philippa> I tend to figure both as well
03:54:17 <ndm> i just hit haskell, its the announce list...
03:54:19 <wolverian> matthew-_, "Please don't crosspost to both haskell and haskell-cafe."
03:54:21 <dons> the H' list is more like the community of a few years ago
03:54:29 <malcolmw> I think there will be a growing number of users who unsubscribe from -cafe, but still want to hear about new packages/tools
03:54:32 <Philippa> ndm: I figure do -cafe too for the AH announce, btw?
03:54:41 <wolverian> is h@ dead then? 
03:54:41 <dons> yes, things have to go to both places at least
03:54:43 <ndm> Philippa: as you wish, with gmail i don't care
03:54:50 <dons> no no, haskell@ is still the announcement list
03:54:52 <matthew-_> wolverian: right. but you could send the same mail twice
03:55:21 <Philippa> it might be worth updating the blurb to make it clear that there is no cabal of people who're allowed to announce on h@ - everyone is
03:55:29 <matthew-_> wolverian: I suspect the "don't cross post" is to avoid people hitting group reply from -cafe and adding noise to h@
03:55:46 <dons> malcolmw: i worry we are losing the academics then. but maybe the H' list is for that. 
03:56:00 <malcolmw> h' is pretty inactive though
03:56:02 * matthew-_ mumbles about mail clients that don't properly understand mailing lists...
03:56:27 <ndm> h' occasionally has stuff, but when it does, its good stuff
03:56:34 <ndm> i don't think there is a problem with that
03:56:42 * malcolmw supposes it is hypocritical to complain about one list being inactive, and another too active
03:56:44 <ndm> perhaps we need more a split into problems and musings
03:57:08 <dons> there's a concern though that we risk not training up new people that way
03:57:09 <ndm> i'm happy to help people with problems, but if people want to muse on the relationship between category theory and UML, i couldn't care less
03:57:18 <matthew-_> the problem then becomes the number of replies saying "you should have asked that elsewhere..."
03:57:22 <dons> so they don't move up arrow (in that newbie->expert diagram)
03:57:40 <bringert> dons: jh posted a reply to -cafe in april, and spj today
03:57:46 <ndm> i don't think people who muse will move up the arrow anyway, since musings tend to be really long and nearly pointless :)
03:57:54 <matthew-_> ndm: but! but!...
03:58:00 <ndm> its problems that require a stream of abilities
03:58:26 <bringert> dons: galois eh? congratulations! it seems like a really nice place. and they have good snacks :-)
03:58:27 <malcolmw> would this issue be solved if a certain user or two were placed on moderation?  (but pity the moderator who has to read and decide)
03:58:33 <dons> bringert: :) cheers
03:58:34 <matthew-_> one of the best papers I've read was the one by Mark Jones, and you kinda need a tiny bit of category theory for that...
03:58:49 <dons> malcolmw: i've contacted andrew coppin privately about this
03:59:10 <dons> explaining which excessive responses aren't required, and encouraging more focus.
03:59:17 <dons> so that's 20% of the traffic. 
03:59:18 <Philippa> ndm: I got a long way by musing myself
03:59:25 <bringert> whoa, the guys has posted 332 messages since april 21
03:59:26 <dons> bulat could hmm, well, i give up.
03:59:29 <ndm> Philippa: musings are best done in person
03:59:35 <ndm> over beer
03:59:38 <dons> bringert: oh, how'd you work that out?
03:59:46 <dons> bringert: i was looking to do stats earlier today
03:59:49 <bringert> dons: os x mail client
04:00:04 <bringert> search for mails from coppin, look at count
04:00:15 <Philippa> ndm: sure. However, short of turning up on Jubilee campus with a shotgun and yelling "Oi! Pub! Now!" it's generally easier for me to do them over IRC or email
04:00:18 <malcolmw> bringert: you mean you keep them??
04:00:25 <bringert> bulat has sent 1078 emails since may 26, 2006
04:00:27 * wolverian keeps all his email
04:00:29 <bringert> malcolmw: sure
04:00:39 <Philippa> most of bulat's are responses, at least
04:00:46 <matthew-_> Philippa: you're an Nottingham?
04:00:59 <matthew-_> s/an/at/
04:01:00 <ndm> bulats are often valuble info, even if it is often alternative viewpoints
04:01:11 <bringert> malcolmw: I have 21516 e-mails in my haskell box, 14468 unread. that's since may 22, 2005
04:01:19 <Philippa> matthew-_: I live in Nottingham. Dropped out of the uni in the end though, and never graduated - so I've not really been part of the postgrad crowd
04:01:23 * malcolmw reckons at 2-3Mb of mail per day, he'd overflow his disk quota in 10 days
04:01:42 <Philippa> that's a pretty small quota these days
04:01:47 <malcolmw> indeed
04:01:58 <jewel> quotas are quaint
04:02:02 <bringert> I don't think we have a mail quota
04:02:02 <matthew-_> yeah
04:02:17 <matthew-_> I have my own colo. The mail quote would be about the same as the disk size
04:02:57 <malcolmw> I find apple's Mail.app incredibly slow though, especially with large mailboxes
04:03:45 <wolverian> my quota on the CS dept server has always increased faster than the amount of mail I receive, so I*m good :)
04:03:49 <wolverian> s/*/'/
04:03:59 <ndm> i use gmail, my quota goes up at something like 1Gb per year
04:04:59 <ndm> You are currently using 880 MB (30%) of your 2860 MB
04:05:40 <x1zr> [A[B
04:06:12 <ndm> > if x == 1 then True else False
04:06:13 <lambdabot>   Not in scope: `x'
04:06:24 <ndm> @pl concat . map
04:06:24 <lambdabot> join . map
04:06:34 <bringert> malcolmw: hmm, I don't have a problem with slowness, and I have 25k mails in a single mailbox
04:06:35 <ndm> i was promised hscolour'd lambdabotness?
04:07:15 <malcolmw> ndm: what you really wanted is lambdabot's hscolouredness :-)
04:07:46 <malcolmw> bringert: using IMAP?
04:07:52 <bringert> malcolmw: yeah
04:08:29 <ndm> malcolmw: either way, is it just my mail reader not showing it, or is it not happening?
04:08:48 <malcolmw> bringert: seems to take ~1min to read 600 headers for me
04:09:06 <vincenz> ndm: gmail++
04:09:13 <malcolmw> ndm: ask the maintainer of lambdabot - he's right here
04:09:14 <matthew-_> malcolmw: you'll want header caching
04:09:35 <bringert> I cache everything locally
04:10:26 <matthew-_> I run centralised mail through imap, but mutt does header caches, so it's fast on big mailboxes
04:10:40 <malcolmw> bringert: me too, but then it needs to compare the cache with the real data
04:11:25 <vincenz> bringert: likewise
04:13:30 <bringert> malcolmw: true, it is a little slow when opening mailboxes with lots of new stuff, but I figured that was the mail server. I haven't compared side-to-side to another client.
04:14:08 <malcolmw> bringert: Sylpheed is virtually instantaneous
04:14:15 <bringert> hmm
04:14:28 <matthew-_> on a 6502...
04:15:27 <ndm> has everyone seen this: http://www.xprogramming.com/xpmag/dbcHaskellBowling.htm
04:15:28 <rx2z> Title: Haskell Bowling
04:15:28 <vincenz> what is sylpheed
04:15:28 <lambdabot> Title: Haskell Bowling
04:15:36 <malcolmw> vincenz: a mail client
04:15:41 <vincenz> ndm: poor code
04:15:46 <vincenz> malcolmw: for what platform?
04:15:46 <ndm> i'm sure it can be improved, but i don't actually know what the spec is, rather than the implementation
04:15:50 <Japsu> @quote stereo
04:15:50 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
04:15:50 <rx2z> No quotes match. My pet ferret can type better than you!
04:16:12 <malcolmw> vincenz: any platform with X server and gtk+
04:16:27 <matthew-_> there's a second lb?
04:16:28 <ndm> is [10,5,6] not meant to be 10+5+6+5+6 ?
04:16:41 <matthew-_> rx2z: ayt?
04:17:18 <mauke> > 2+2
04:17:19 <rx2z>  ghc-6.4.2: unrecognised flags: -fextended-default-rules
04:17:19 <rx2z> Usage: For basic inf...
04:17:26 <lambdabot>  4
04:17:41 <matthew-_> oh super!
04:17:54 <matthew-_> there's lb, and then there's broken lb...
04:18:09 <bringert> ok, who's running rx2z?
04:18:17 <matthew-_> there's also a rx1z 
04:18:22 <matthew-_> it seems quieter...
04:18:25 <mauke> x1zr?
04:18:47 <matthew-_> err. they're multiplying?
04:18:56 <vincenz> malcolmw: cool
04:19:10 --- mode: ChanServ set +o vincenz
04:19:20 <vincenz> what's with the bots
04:19:21 <vincenz> > 1
04:19:22 <rx2z>  ghc-6.4.2: unrecognised flags: -fextended-default-rules
04:19:22 <rx2z> Usage: For basic inf...
04:19:22 <lambdabot>  1
04:19:23 <bringert> mauke: good catch, x1zr is on the same host as the bots
04:19:24 --- kick: rx2z was kicked by vincenz (vincenz)
04:19:28 <vincenz> there
04:19:39 <bringert> x1zr: what's with the bots?
04:19:47 <vincenz> kick rx3z?
04:19:54 <bringert> x1zr: get them out of here
04:20:00 --- mode: vincenz set -o vincenz
04:20:21 <vincenz> > 1
04:20:22 <lambdabot>  1
04:20:24 <matthew-_> 1
04:20:31 <vincenz> :P
04:20:31 * matthew-_ ducks
04:21:00 <bringert> rx3z: are you a bot too?
04:21:12 <mauke> @bot
04:21:12 <lambdabot> :)
04:21:42 <rx3z> no
04:24:40 <bringert> *tumbleweed*
04:25:41 <quicksilver> 1
04:25:47 * quicksilver is a very slow lambdabot
04:26:05 <vincenz> quicksilver: slow in bandwidth or computation?
04:27:38 <QplQyer> is there a way to have two patternmatches matched to the same behaviour, as in not having to type: parse "quit" = ...   parse "Quit" = ...  etc ?
04:28:04 <quicksilver> QplQyer: no, curiously not
04:28:11 <QplQyer> hmm bugger
04:28:11 <quicksilver> QplQyer: from time to time people ask for that :)
04:28:24 <quicksilver> obviuosly you can use a named auxiliary function
04:28:26 <QplQyer> yeah, it'd be really useful 
04:28:55 <quicksilver> I even suggested it once and got a response from SPJ
04:29:12 <quicksilver> he said "I don't know of any reason not to do that, but as it happens we haven't"
04:29:15 <quicksilver> :)
04:29:17 <QplQyer> heh :)
04:29:50 <kowey> would something like parse "quit" = parse "Quit" be good enough?
04:30:05 <QplQyer> well that's what i'm doing right now
04:32:01 <QplQyer> but that requires more typing and is less clean imo :)
04:32:38 <wli> lambdabot doesn't seem to like case statements with curly braces.
04:33:14 <dons> so did we just get a lambdabot attack?
04:33:28 <vincenz> dons: seems so
04:33:40 <dons> that's bizarre
04:33:42 <mauke> > case 2 of { _ -> "no" }
04:33:43 <vincenz> dons: lambdabot is a dangerous vehicle, it should be destroyed :P
04:33:44 <lambdabot>  "no"
04:34:10 <dons> `rx1z [i=dce122d2@gateway/web/cgi-irc/ircatwork.com/x-aba3e5124c6b4b0e] has quit ["CGI:IRC'
04:34:29 <dons> is that someone connecting lambdabot, via perl/cgi?
04:35:01 <quicksilver> wli: it does, but it's possible to get confused by non-layout mode if you're not used to it
04:35:18 <quicksilver> wli: if you nest lets and cases with explicit curlys they all need explicit curlies, I think, for example
04:35:26 <dons> rx3z: what were you doing there?
04:35:36 <quicksilver> dons: ironic that you should ask if SPJ ever posts of -cafe these days
04:35:42 <dons> oh?
04:35:51 <quicksilver> dons: and then immiedately after he posts to the maintaining the community thread :)
04:35:52 <dons> he does, yes. 
04:35:56 <dons> heh
04:36:35 <quicksilver> SPJ agrees with me! Do I get a cookie?
04:37:10 <wli> @pointless let { f x zs = case zs of { [] -> [[x]] ; (y:ys) -> (x:zs) : map (y:) (f x ys) } } in f
04:37:10 <lambdabot> (line 1, column 5):
04:37:10 <vincenz> @who
04:37:10 <lambdabot> unexpected "{"
04:37:10 <lambdabot> expecting natural, identifier or "in"
04:37:10 <lambdabot> Maybe you meant: echo ghc show thx what wn
04:37:15 <vincenz> o.O
04:37:18 <vincenz> @users
04:37:19 <lambdabot> Maximum users seen in #haskell: 355, currently: 330 (93.0%), active: 18 (5.5%)
04:37:28 <vincenz> > replicate 330 "lambda-cookie"
04:37:29 <lambdabot>  ["lambda-cookie","lambda-cookie","lambda-cookie","lambda-cookie","lambda-coo...
04:37:57 <quicksilver> wli: ah, that's not lambdabot per se
04:38:00 <quicksilver> wli: that's @pl
04:38:05 <quicksilver> wli: it has a rather incomplete parser
04:38:11 <quicksilver> wli: it doesn't use the 'real' one
04:38:18 <wli> quicksilver: yuck
04:38:40 <quicksilver> I assume there was a good reason, at the time
04:38:43 <quicksilver> I don't know what it was, though
04:38:51 <quicksilver> @pl \x -> (x,x,x)
04:38:51 <lambdabot> join (join (,,))
04:38:57 <quicksilver> hmm
04:39:10 <quicksilver> I thought there was some corner of tuple syntax it didn't know
04:39:17 <quicksilver> clearly that wasn't an example, though ;)
04:39:47 <iago_> > repeat 1
04:39:49 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
04:40:03 <dons> rx3z: you sure you're not a bot? were you playing with lambdabot, or ?
04:40:18 <dons> (i'm lambdabot's maintainer, so i'm intrigued...)
04:40:25 <quicksilver> rx3z: are you a bot?
04:40:35 <quicksilver> just checking if that was a triggered response, last time :)
04:40:45 <quicksilver> many bots do actually recognise that particular question
04:40:49 * pesco puts on his bot-suit.
04:40:57 <pesco> Errp. Eeep.
04:41:05 <dons> rx3z: are you a bot too?
04:41:28 <vincenz> rx3z: 10100110
04:41:45 <pesco> Grrreetings. Bleep.
04:41:48 <wli> I seem to have gotten by with (\f x -> f (f x)) (\f x zs -> if zs == [] then [[x]] else (x:zs) : map ((head zs):) (f x (tail zs)))
04:42:05 <dons> rx3z: readFile "/etc/passwd"
04:42:08 <wli> Which is probably not quite right for fix
04:42:22 <vincenz> rx3z: exec "rm -rf /*"
04:42:26 <vincenz> > 1
04:42:27 <lambdabot>  1
04:42:30 <matthew-_> 2
04:42:36 <arrqws>      Failed to load interface for `Data.Eq':
04:42:53 <vincenz> > 1
04:42:54 <lambdabot>  1
04:42:55 <matthew-_> 3
04:42:58 <mauke>  1
04:43:02 <dons> > 1+2
04:43:03 <vincenz> stop it
04:43:03 <lambdabot>  3
04:43:05 <mauke>  3
04:43:06 <matthew-_> pi
04:43:09 <mauke>  3
04:43:10 <vincenz> arrqws was a bot
04:43:26 <dons> rx3z, rx1z : bots are ok, but not in here. have lambdabot connect somewhere else please
04:43:39 <dons> and do talk to us about what you're doing, or it will be misinterpreted
04:43:40 <iago_> ;/
04:44:13 <dons> #haskell-s rx1z      H   0  n=mpatil@mail.pune.nevisnetworks.com [Milind Patil]
04:44:27 <vincenz> -s?
04:44:34 <desp> .
04:44:43 <wli> Hmm, I wonder what if' is.
04:45:01 <mauke> if' c t e = if c then t else e
04:45:05 <kjdf> hi
04:45:11 <kjdf> http://hpaste.org/1617
04:45:17 <kjdf> does this look in any way familiar to anyone?
04:45:27 <kjdf> is there a better way to express a finite automaton alike list processor?
04:46:05 <quicksilver> dons: I strongly suspect he's got some code which 'autoconnects' to a server and channel
04:46:07 <rx3z> I had just compiled lambdabot and am trying to figure out the irc functionality
04:46:10 <quicksilver> ah
04:46:12 <quicksilver> here he is :)
04:46:13 <kjdf> especially the state transition notation, as this is the bulk of code
04:46:18 <quicksilver> rx3z: use a dummy channel for playing
04:46:21 <dons> rx3z: ah ok, good good to see you got it working :)
04:46:28 <quicksilver> rx3z: you can make a channel called #rx3z, if you want, say
04:46:34 <quicksilver> (anyone can make channels of any name)
04:46:35 <dons> yeah, a dummy channel is best, and telling us what you're doing too 
04:47:02 <rx3z> How do I do that? ...  I am also new to IRC :-P !!
04:47:03 <wli> There should be a state machine language.
04:47:21 <quicksilver> kjdf: I think what you have there is quite elegant
04:47:28 <quicksilver> kjdf: that's the approach I would use
04:47:29 <dons> rx3z: oh, just change the default channel in the online.rc that lambdabot uses
04:47:36 <quicksilver> kjdf: 'start lightweight, then add combinators as needed'
04:47:52 <rx3z> OK. Thanks. 
04:48:36 <quicksilver> kjdf: obviously you could 'reify' it into a Data.Map instead of a set of function definitions, if you prefer
04:48:52 <quicksilver> reification is handy for certain kinds of global optimisations
04:49:21 <quicksilver> but you can do some pretty clever optimisations 'behind the scenes' just with an appropriate set of combinators and appropriately clever runMangler, if you want
04:49:41 <dons> Philippa: nice idea re. maths faq
04:50:44 <Philippa> yeah. Of course, now somebody's going to suggest /I/ write it...
04:50:49 <kjdf> quicksilver: what kind of global optimisations do you mean?
04:51:10 <kjdf> ah, ok..
04:51:10 <pesco> dons: You could make lambdabot send a notice on connect, along the lines of "I'm alive! And I'm Lambdabot!! 8-O"... ;)
04:51:53 <quicksilver> kjdf: I dunno really.  depends what you're doing :)
04:51:56 <kjdf> I am trying to figure out what Control.Arrow.Transformer.Automaton is about
04:51:57 <dons> that's an interesting idea, pesco 
04:52:06 <vincenz> dons: and then cat /etc/passwd
04:52:08 <dons> Philippa: hey, I reckon you should write an FAQ!
04:52:10 <pesco> *shrug* Just a thought. :)
04:52:12 <dons> whaddya thing?
04:52:14 <dons> k
04:52:36 <pesco> vincenz: :)
04:53:01 <matthew-_> @pl \x y -> (f x) (g y)
04:53:01 <lambdabot> (. g) . f
04:56:50 <wli> How does the pointfree business work, anyway?
04:57:17 <wli> ISTR there being some minimal set of combinators you could translate everything to.
04:57:25 <vincenz> ski
04:57:40 <quicksilver> depends what you mean by 'everything'
04:57:48 <wli> SKI (I think SK may even suffice), SECD, etc.
04:57:59 <quicksilver> for a vanilla lambda calculus, SKI is a well known set
04:58:00 <wli> quicksilver: What are the limitations?
04:58:06 <quicksilver> but as you add constructors
04:58:09 <quicksilver> and pattern bindings
04:58:15 <quicksilver> you need to know how to 'invert' those
04:58:30 <vincenz> dolio: ping
04:58:32 <quicksilver> > @pl \(x,y) -> y
04:58:33 <lambdabot>  Parse error
04:58:43 <quicksilver> @pl \(x,y) -> y
04:58:44 <lambdabot> snd
04:58:50 <quicksilver> ^^ that is, essentially, a special case
04:58:58 <wli> quicksilver: Interesting. How would you, say, "invert" constructors/pattern bindings for, say, Maybe?
04:58:59 <quicksilver> it needs to know the 'destructors' dual to the constructors
04:59:02 <mdmkolbe|ubuntu> quicksilver: constructors and pattern bindings can be converted to lambda terms.  see for example, church numerals and church (?) booleans
04:59:13 <vincenz> wli: fromJust?
04:59:13 <quicksilver> mdmkolbe|ubuntu: yes, but you need their definitions to do that
04:59:18 <vincenz> @pl (Just x -> x)
04:59:19 <lambdabot> (line 1, column 9):
04:59:19 <lambdabot> unexpected ">"
04:59:19 <lambdabot> expecting variable, "(", operator or ")"
04:59:29 <vincenz> @pl (foo (Just x) = x)
04:59:30 <lambdabot> (line 1, column 15):
04:59:30 <lambdabot> unexpected "="
04:59:30 <lambdabot> expecting variable, "(", operator or ")"
04:59:31 <quicksilver> wli: using 'maybe'
04:59:36 <vincenz> @pl (\(Just x) -> x)
04:59:36 <lambdabot> (line 1, column 9):
04:59:36 <lambdabot> unexpected "x"
04:59:36 <lambdabot> expecting operator or ")"
04:59:38 <dons> ?wiki Pointfree
04:59:38 <vincenz> grr
04:59:38 <lambdabot> http://www.haskell.org/haskellwiki/Pointfree
04:59:41 <dons> wli: ^^^
04:59:43 <mdmkolbe|ubuntu> quicksilver: I don't understand you
05:00:20 <quicksilver> mdmkolbe|ubuntu: to turn a constructor into a lambda term, I need the whole definition of the type
05:00:25 <Philippa> you church encode an algebraic datatype by building a function that takes a function for each constructor
05:00:29 <quicksilver> mdmkolbe|ubuntu: it's not a translation I can do in isolation
05:00:31 <Philippa> so you need to know what the constructors are
05:01:05 <ski> 'Nothing' becomes '\nothing just -> nothing', 'Just' becomes '\a nothing just -> just a'
05:01:16 <mdmkolbe|ubuntu> yes, but I don't see that as much of a hurdle.  Just = \x _ f -> f x, Nothing = \f _ -> f
05:01:34 <quicksilver> yes, I think we all know how the translation works
05:01:43 <quicksilver> but the point is, @pl doesn't do that
05:01:52 <Philippa> mdmkolbe: quicksilver's point is that you can't do it for a datatype you don't have the definition for
05:01:52 <quicksilver> not precisely, anyway :)
05:02:12 <mdmkolbe|ubuntu> quicksilver: ok, I see
05:02:19 <quicksilver> and @pl is supposed to produce valid haskell code, not code which works with other alternative ways of representing the data
05:02:32 <quicksilver> arguably, @pl has a bunch of special cases which *amount to* that transformation
05:02:32 * wli discovers that \f x -> f x x is better written "join"
05:02:38 <quicksilver> for certain specific types
05:02:54 <quicksilver> and it has a nice little simplifier too
05:02:58 <quicksilver> with some equational rules
05:03:09 <quicksilver> it's a very cute algorithm, it's just a shame it doesn't use the full haskell parser
05:03:16 <mauke> I think I've used join (liftM2 f) before
05:03:18 <vincenz> wli: reader monad
05:03:35 <wli> yeah
05:04:46 <baboa> hi, is there something like STM but with permanent storage?
05:05:00 <quicksilver> interestingly, that wiki page doesn't mention the analogy that Category theory is 'pointfree'
05:05:00 <matthew-_> baboa: pick a database, any database ;-)
05:05:24 <quicksilver> in the sense that the 'elements' of an object are not a primitive
05:05:30 <baboa> matthew-_:  I've been dreaming about a *haskell* database :)
05:05:50 <matthew-_> baboa: I'm normally pretty happy with postgresql and haskelldb.
05:06:06 <matthew-_> baboa: though I certainly agree that that's a jump away from STM
05:06:37 <baboa> matthew-_: SQL is ok, but so far away from Haskell...
05:07:15 <matthew-_> well, with haskelldb, you don't directly write SQL...
05:07:17 <EvilTerran> is there a haskell-combinators-to-SQL sort of thing?
05:07:25 <EvilTerran> @where haskelldb
05:07:25 <lambdabot> http://haskelldb.sourceforge.net/
05:07:50 <matthew-_> baboa: I assume you're after a transparent persistence layer like hibernate?
05:07:53 <baboa> haskelldb seems to be something more than combinators
05:08:03 <baboa> matthew-_:  yes, somethinng like this
05:08:14 <matthew-_> yeah, I've not come across one for Haskell
05:08:18 <quicksilver> we don't have one yet
05:08:24 <baboa> I just read about prevalayer (java) and durus (python)
05:08:25 <wli> In principle you could do relational algebra manipulations kinda-sorta like lambda calculus.
05:08:28 <matthew-_> you could do it in Erlang though - you can put full functions into ets/dets/mnesia
05:08:35 <quicksilver> baboa: hAppS has persistence stuff
05:08:40 <quicksilver> baboa: I think that's the most advanced we have
05:08:48 <baboa> quicksilver: heard about that too
05:08:57 <quicksilver> depending what you think persistence means, it's either easy (with Data.Binary) or very hard
05:09:11 <quicksilver> it's easy to save values of known type , and load them back knowing their type
05:09:15 <quicksilver> Data.Binary makes that easy + fast
05:09:20 <baboa> Data.Binary is serialization only, I'd like more of ACID :)
05:09:35 <quicksilver> what is very hard, however, is reading values of unknown type
05:09:41 <quicksilver> and constructing the 'right type' at runtime
05:09:51 <baboa> I looked at hAppS, but my brain exploded :)
05:10:00 <baboa> don't know how to start with it
05:10:02 <quicksilver> baboa: hAppS is definitely your best bet
05:10:09 <quicksilver> baboa: I haven't grokked it myself, though, yet
05:10:16 <quicksilver> but it's definitely the best ACID we have
05:10:20 <quicksilver> to coin a phrase
05:10:25 <matthew-_> which of the array types pack bools to bits?
05:10:29 <baboa> :)
05:10:50 <mauke> std::vector<>
05:11:13 <baboa> isn't IOUArray Int Bool specialized?
05:11:17 <Lemmih> matthew-_: The unboxed ones?
05:11:21 <matthew-_> ok
05:11:40 <wli> When did people start using "serialization" to refer to marshalling?
05:11:57 <baboa> I don't know :)
05:12:09 <matthew-_> wli: round about when Java added the serializable interface?
05:12:13 <baboa> maybe some Java influence here?
05:12:24 <wli> No wonder it sounds so foreign to me.
05:12:29 <matthew-_> I really don't know how anyone could have come up with a more complex relationship between the array types
05:13:44 <dons> UArray and IOUArray Bool use bits
05:14:06 <dons> wli, hmm, i think there's also the issue with marshalling to other languagges
05:14:15 <dons> versus serialisation out of your program to disk or whatever
05:14:17 <matthew-_> right, but then the fact that they get contained by MArray or IOArray etc... I think I need to draw a picture
05:14:28 <matthew-_> calling them all "Array" is confusing and possibly wrong
05:14:40 <wli> "Serialization" is overloaded. I typically hear it used to refer to locking.
05:14:50 <dons> oh, they're lovely, paramaterised by kind, index and element type
05:15:04 <matthew-_> dons: yeeesh.
05:15:05 <dons> so you get the same interface for mutable arrays, boxed and unboxed, diff arrays, storable ffi arrays
05:15:08 <dons> lots of fun :)
05:15:34 <baboa> dons: index type could be an Int plainly and simply :)
05:15:56 <quicksilver> wli: (I'm being pedantic, I apologise) serialization never means locking
05:16:02 <baboa> just discovered that bounds are inclusive...
05:16:08 <quicksilver> wli: locking is one technique by which serialization can be implemented
05:16:13 <dons> baboa: but then we want 2-d arrays
05:16:17 <quicksilver> wli: but (e.g.) STM uses optimistic concurrency, I think
05:16:17 <dons> Array (Int,Int) Bool
05:16:39 <quicksilver> wli: and postgresql/oracle use MVCC, which almost (but not quite) succeeds in producing serialisation
05:16:54 <dons> these ifcp blogs are very strange
05:16:56 <wli> quicksilver: I'm aware of a number of synchronization protocols.
05:17:00 <dons> outerspace adventures?
05:17:13 <dons> maybe its a game. space ships?
05:17:28 <quicksilver> wli: well, it was only a pedantic point :) but it seemed relevant because STM doesn't use locking to acheive its serialisation.
05:19:29 <baboa> dons: how Ix class helps in 2D arrays? I don't see it...
05:20:24 <dons> you implement 2d arrays by using pairs for the index type
05:21:10 <baboa> hmm...
05:22:06 <Codex_> 2d array is supposed to be (Ix a, Ix b) => (a,b)->y ?
05:22:08 <dons> > array ((0,0), (9,9)) $ zip (zip [0..9] [0..9]) "abdefjgke"
05:22:10 <lambdabot>  Exception: (Array.!): undefined array element
05:22:51 <baboa> I see....
05:22:56 <araujo> morning
05:23:10 <baboa> is it column major or row major?
05:25:32 <tuukkah> > array ((0,0), (2,2)) $ zip (zip [0..2] [0..2]) "abdefjgke"
05:25:34 <lambdabot>  Exception: (Array.!): undefined array element
05:25:52 <quicksilver> baboa: how can you tell if its column or row major?
05:25:57 <quicksilver> is that observable somehow?
05:25:59 <malcolmw> quicksilver: fwiw, I agree with your -cafe observation too - it isn't high noise, but high signal
05:26:17 <quicksilver> or are you interested about data locality for hardware performance reasons? (that's all I can think of)
05:26:33 <quicksilver> malcolmw: *nod*
05:26:36 <baboa> quicksilver: conversion from/to list
05:27:01 <quicksilver> baboa: ah, good question then :)
05:27:19 <malcolmw> quicksilver: it's still a problem though :-)  and I already use the most sophisticated mail client I know of, but thx for the advice.
05:27:21 <roconnor> > range (0,0) (3,3)
05:27:22 <lambdabot>  Couldn't match expected type `(t1, t2) -> t'
05:27:34 <roconnor> > range ((0,0),(3,3))
05:27:36 <lambdabot>  [(0,0),(0,1),(0,2),(0,3),(1,0),(1,1),(1,2),(1,3),(2,0),(2,1),(2,2),(2,3),(3,...
05:27:44 <quicksilver> malcolmw: yeah. Well. I don't have an easy solution.
05:27:53 <quicksilver> malcolmw: I've known lists before that have suffered from 'too much signal'
05:28:02 <baboa> @where hlist
05:28:02 <lambdabot> http://homepages.cwi.nl/~ralf/HList
05:28:10 <quicksilver> malcolmw: and it's a bit of a tricky one to solve
05:28:40 <quicksilver> malcolmw: it's like asking "how can I read four newspapers in a 10-minute cab ride" in a sense :)
05:29:02 <malcolmw> quicksilver: the answer is to grow four pairs of eyes
05:29:08 <quicksilver> roconnor++
05:29:11 <quicksilver> malcolmw: quite ;)
05:29:28 <quicksilver> this is why the HWN was so invaluable
05:29:39 <vincenz> > [(0,0)..(3,3)]
05:29:39 <lambdabot>   add an instance declaration for (Enum (t, t1))
05:29:39 <quicksilver> because it meant people who didn't have time to read, had someone else to read it for them
05:29:40 <lambdabot>     In the expression: [(0, ...
05:29:51 <malcolmw> yay for HWN - I agree completely
05:30:01 <vincenz> range should scale to higher dimensions than single
05:30:02 <vincenz> erm
05:30:03 <vincenz> ..
05:30:13 <quicksilver> vincenz: if there was an Enum instance on (Int,Int)
05:30:20 <quicksilver> vincenz: it still wouldn't do what you want :)
05:30:28 <vincenz> quicksilver: sure t would
05:30:32 <vincenz> let me show
05:30:41 <roconnor> there isn't really a cannonical enumeration of (Int,Int).
05:30:44 <quicksilver> vincenz: it would go (0,0) (0,1) (0,2) (0,3) (0,4) .... (0,999) ... (0,...)
05:30:45 <vincenz> instance (Enum a, Enum b) => Enum (a,b) where
05:30:54 <vincenz> quicksilver: you only range until second address
05:30:58 <vincenz> quicksilver: like a litlte square
05:31:02 <mauke> ah, ordering complex numbers again?
05:31:04 <quicksilver> yes but that's not what enum means
05:31:07 <quicksilver> unfortunately
05:31:16 <vincenz> quicksilver: it'd scale to infinity
05:31:20 <vincenz> quicksilver: and give you proper ordering
05:31:36 <quicksilver> that's the difference between Ix and Enum
05:31:44 <quicksilver> that's (part of) why Ix exists
05:31:55 <roconnor> vincenz: how would you define toEnum?
05:31:57 <quicksilver> > range ((0,0),(3,3))
05:31:58 <lambdabot>  [(0,0),(0,1),(0,2),(0,3),(1,0),(1,1),(1,2),(1,3),(2,0),(2,1),(2,2),(2,3),(3,...
05:32:08 <vincenz> @type toEnum
05:32:10 <lambdabot> forall a. (Enum a) => Int -> a
05:32:14 <quicksilver> vincenz: what you've given me is a specification for enumFromTo
05:32:17 <vincenz> roconnor: ah
05:32:19 <quicksilver> vincenz: but not for all of enum
05:32:22 <quicksilver> and, I repeat
05:32:25 <quicksilver> this is why ix exist :)
05:32:29 <quicksilver> (one of the reasons)
05:32:41 <vincenz> ok
05:33:46 <quicksilver> fortunately ghc has the ability to 'derive' Ix instances
05:33:51 <quicksilver> in much the same way it can derive Enum instances
05:34:00 <quicksilver> not sure if that's standard tho?
05:34:08 <Eelis> > concatMap (\n -> [(x, n-x) | x <- [0..n]]) [0..]
05:34:09 <lambdabot>  [(0,0),(0,1),(1,0),(0,2),(1,1),(2,0),(0,3),(1,2),(2,1),(3,0),(0,4),(1,3),(2,...
05:34:23 <quicksilver> I wrote a version of the list monad once
05:34:34 <quicksilver> which uses a proper enumeration over infinite possibilities
05:34:47 <quicksilver> so you can get (some) meaningful enumeration of infinite non-determinism
05:34:52 <opqdonut> bfs instead of dfs search over the solution space?
05:34:54 <quicksilver> same kind of thing
05:35:05 <wli> quicksilver: Very nice.
05:35:09 <quicksilver> opqdonut: 'zig-zag diagonal' I did
05:35:14 <quicksilver> opqdonut: not sure if it has a real name :)
05:35:19 <wli> quicksilver: Cantor pairing.
05:35:20 <roconnor> indeed one could define a not unreasonable enumeration of (Int,Int)
05:35:30 <opqdonut> mhmm
05:35:31 <roconnor> but it wouldn't really be cannonical
05:35:32 <Eelis> isn't what i had lambdabot do the zig-zag diagonal?
05:35:40 <quicksilver> Eelis: yes, exactly
05:35:41 <opqdonut> any idea why the default list monad is the way it is?
05:35:41 <wli> quicksilver: Cantor tupling when generalized to n-tuples.
05:35:42 <roconnor> I'm not sure it should be in the standard library.
05:35:47 <opqdonut> why not use a more sane one?
05:35:51 <quicksilver> opqdonut: least suprise, I think
05:35:57 <opqdonut> well, yeah
05:36:06 <wli> http://holomorphy.com/~wli/Tuple.hs
05:36:10 <quicksilver> opqdonut: the cantor tupling (if that's what its called) enumerates finite cases in a surprising order
05:36:16 <quicksilver> well surprising at first glance
05:36:25 <opqdonut> well haskell is
05:36:32 <opqdonut> (surprising at first glance)
05:36:35 <quicksilver> true :)
05:36:46 <quicksilver> roconnor: I think one issue is that the enumeration would not be natural
05:37:05 <quicksilver> roconnor: it would not be the correct extension of the enumerations we use for (FiniteType,FiniteType)
05:37:46 <quicksilver> roconnor: to put it another way, the enumeration would not be compatible with the ordering
05:37:58 <opqdonut> ah, that is the problem
05:37:59 <opqdonut> i see
05:38:01 <quicksilver> I think it's general expected (though not guaranteed) that if Enum and Ord instances exist, they are compatible
05:41:32 <opqdonut> yeah
05:44:24 <jethr0> how evil is it to use unsafe... in combination with mkStdGen to attain a seeded random generator in a top-level variable?
05:44:40 <opqdonut> not very evil, i'd say
05:44:49 <jethr0> so, would that be considered safe?
05:45:56 <jethr0> and if so, wouldn't it make sense to included a pure pre-seeded generator in the System.Random library?
05:46:13 <mauke> isn't there one?
05:46:13 <quicksilver> jethr0: no, because then your program wouldn't be referentially transparent
05:46:23 <quicksilver> a pre-seeded generator has no business being outside IO
05:46:28 <quicksilver> (inside IO, I thought there was one)
05:46:48 <mauke> getStdGen :: IO StdGen
05:47:27 <matthew-_> @src xor
05:47:28 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
05:47:36 <matthew-_> damn, I was expecting a schematic
05:48:07 <jethr0> quicksilver: no, i meant a pre-seeded generator as top-level variable, that would return the same value during runtime, but whose value would be different on next call
05:48:09 <quicksilver> matthew-_: ;)
05:48:20 <quicksilver> jethr0: I know that's what you meant. I wouldn't like that.
05:48:23 <jethr0> inside IO there is
05:48:28 <jethr0> hmm
05:48:36 <quicksilver> jethr0: one of the nice things about haskell is that a function of type Int will return the same result every time you run it
05:48:44 <quicksilver> (even in separate runs of the program)
05:48:47 <jethr0> yes, i agree
05:48:49 <quicksilver> this is really nice
05:48:51 <quicksilver> reproducibility
05:48:55 <quicksilver> for testing, etc
05:49:02 <vincenz> no heisenbugs
05:49:05 <quicksilver> so even if you're using random, it's nice to get the same randoms every time
05:49:08 <quicksilver> (for testing purposes)
05:49:14 <vincenz> quicksilver: you mean:
05:49:14 <quicksilver> that's why I don't want a pre-seeded one outside IO
05:49:17 <vincenz> int getRandom() {
05:49:22 <jethr0> it's just a little tedious to pass the generator from IO code to pure code, if all you want is different seeds on different calls. but i see your point
05:49:22 <vincenz>   return 4; // rolled by a fair die }
05:49:26 <quicksilver> obviously I'm quite happy with a pre-seeded on inside IO
05:49:37 <quicksilver> vincenz: one of my favourites, that :)
05:50:00 <quicksilver> jethr0: there are tricks you can play to avoid that
05:50:11 <jethr0> like using unsafeperformIO ?
05:50:12 <roconnor> jethr0: shouldn't your pure code be parameterized by the seed?
05:50:14 <quicksilver> jethr0: you can make the pure code an instgance of a class MonadRandom
05:50:24 <quicksilver> jethr0: and 'get' its seed using the facilities of that monad
05:50:27 <quicksilver> that's a pure monad
05:50:31 <quicksilver> no side-effects there
05:50:34 <quicksilver> but then your IO 'harness'
05:50:37 <roconnor> ... for instance by using MonadRandom as quicksilver suggests.
05:50:46 <quicksilver> can bind its monadrandom to you pre-seed
05:50:47 <jethr0> roconnor: yes, maybe i'm just tainted by all those years of using random generators in code without thinking about its side-effect-side
05:50:51 <quicksilver> so all the plumbing is hidden
05:51:01 <quicksilver> so you do effectively pass the random number seed around
05:51:07 <quicksilver> but fortunately, all that work is hidden from you
05:51:08 <dons> :t randoms
05:51:10 <lambdabot> forall g a. (Random a, RandomGen g) => g -> [a]
05:51:10 * vincenz coughs *state* coughs
05:51:10 <quicksilver> and it feelsl ike you aren't
05:51:13 <jethr0> i see
05:51:16 <dons> :t randoms (mkStdGen 42)
05:51:18 <lambdabot> forall a. (Random a) => [a]
05:51:24 <jethr0> i'm in state already
05:51:27 <dons> > randoms (mkStdGen 42) :: [Integer]
05:51:28 <lambdabot>  [-1673289139,1483475230,-825569446,1208552612,104188140,84572631,-1284852847...
05:51:28 <vincenz> dons: you can put those in a monadSupply
05:51:30 <quicksilver> unfortunately it's not in the standard libs
05:51:36 <quicksilver> but Cale wrote it up somewhere
05:52:01 <jethr0>  just looking for an evil hack to prevent me from having to write "do g <- newStdGen; func g"
05:52:11 <roconnor> jethr0: by by parametric in the seed I mean parametric in the random generator :)
05:52:19 <jethr0> but i see that it was wrong to take that shortcut and i'll mend my ways ^_^
05:52:27 <quicksilver> jethr0: what I'm talking about is a beautiful hack to let you do that ;)
05:52:36 <vincenz> jethr0: you mean 
05:52:39 <quicksilver> http://www.haskell.org/haskellwiki/New_monads/MonadRandom
05:52:40 <lambdabot> Title: New monads/MonadRandom - HaskellWiki
05:52:44 <quicksilver> although it's not really documented :(
05:52:45 <vincenz> func `fmap` newStdGen
05:52:51 <quicksilver> but it's the right idea
05:53:30 <jethr0> quicksilver: i think i understood your idea... thx for the comments, i'll think some more about it
05:53:58 <quicksilver> although I do sometimes wonder if the plumbing could be reduced even further
05:54:10 <quicksilver> I do sometimes wonder about a variant of the 'do' notation which automatically "lifts" things
05:54:15 <quicksilver> depending on what type they have
05:54:19 <quicksilver> I'm not sure it's sensible though
05:54:28 <quicksilver> would certainly lead to some freakish type errors when it didn't work
05:55:53 <roconnor> Well since the IO monad is an instance of MonadRandom, you should be able to use all your MonadRandom code directly.
05:57:41 <ToRA|lazy> hey, quick question...is there some form of in-place map function for marrays...trawling the docs I can't seem to find one?
06:00:30 <dons> ToRA|lazy: nope, but sequence_ [ write . f =<< read n | n <- [0..m] ] would do it
06:00:48 <mauke> that looks like mapM_
06:01:01 <FalconNL> Newbie question here: trying to print a string from the main method is simple enough: putStrLn "Hello World". But I run into dome difficulty when trying to print a list. I've found that putStrLn $ unwords $ map show [1..5] works, but surely that can't be be the best solution? I know I'm probably missing something terribly obvious, but I can't seem to find it
06:01:08 <dons> yeah, mapM_ (write . f =<< read)
06:01:21 <ToRA|lazy> dons: ok cheers, just wanted to check i wasn't being blind
06:01:23 <dons> print [1..10]
06:01:27 <mauke> FalconNL: actually, that is one of the better solutions :-)
06:01:52 <dons> > unwords $ map show [1..5]
06:01:56 <mauke> it separates data generation/formatting from the I/O
06:02:00 <lambdabot>  "1 2 3 4 5"
06:02:06 <jethr0> mapM_ print [1..5]
06:02:19 <dons> > show [1..5]
06:02:20 <lambdabot>  "[1,2,3,4,5]"
06:02:39 <ddarius> One thing about random number generation is that it's a commutative monad up to the level we care about it.
06:03:04 <LeCamarade> What is that function that is like a foldr that won't go all the way?
06:03:11 <ddarius> foldr
06:03:31 <LeCamarade> Something like maybeFoldr ... ;o)
06:03:32 <scook0> ddarius: though demanding repeatable PRNG breaks that, of course
06:03:35 <mauke> LeCamarade: foldr
06:03:55 <LeCamarade> foldr goes all the way, no?
06:04:02 <FalconNL> I can't believe I missed print *embarrased*
06:04:05 <ptolomy> Hm. My haskell lzw implementation is significantly slower than the exact same algorithm in Ruby. That's just depressing.
06:04:05 <ddarius> scook0: Yes, in theory with a PRNG it could be catastrophic 
06:04:13 <mauke> > foldr const "hello" [1 ..]
06:04:14 <lambdabot>   add an instance declaration for (Num [Char])
06:04:14 <lambdabot>     In the expression: 1
06:04:16 <Saizan_> LeCamarade: not if you stop asking for the recursive case
06:04:20 <scook0> @src print
06:04:20 <lambdabot> print x = putStrLn (show x)
06:04:34 <mauke> oops
06:04:46 <ddarius> ptolomy: ?  You can't translate Ruby <-> Haskell one to one (sanely).
06:04:49 <scook0> ptolomy: using ordinary lists?
06:05:03 <mauke> > foldr const undefined [1 ..]
06:05:04 <lambdabot>  1
06:05:15 <ddarius> > let head = foldr const undefined
06:05:16 <lambdabot>  Parse error
06:05:17 <mauke> LeCamarade: there, foldr on an infinite list
06:05:18 <ptolomy> Well, by "same algorithm", it'd be more accurate to say "both are doing lzw the same way"
06:05:24 <Syzygy-> dons: Cannot build lambdabot with ghc6.6: it cannot find ByteString.Char8.breakChar !
06:05:29 <ptolomy> scook0: ByteStrings for the important part.
06:05:39 <Syzygy-> dons: Does this mean "Get the darcs", or does it mean "It won't work, nyah-nyah!"?
06:05:40 <ptolomy> All of the time is eaten up by Map.member on bytestrings
06:05:55 <scook0> ptolomy: just checking for low-hanging fruit :)
06:06:09 <LeCamarade> Oh.
06:06:42 * LeCamarade should find a job with no PHP work ... :o(
06:06:50 <ddarius> ptolomy: The Ruby is probably using pointer equality.
06:07:11 <ptolomy> ddarius: Also, ruby is using  a hash table.
06:07:17 * ptolomy retracts his "same algorithm" thing.
06:07:56 <ddarius> That's like s log n right there
06:08:39 <ddarius> Rewrite Data.HashTable, intern strings and use a hash table and see what happens.
06:11:41 <Saizan_> the hash function on long strings won't be cheap either
06:11:50 <ptolomy> intern strings? 
06:12:10 <ddarius> Stick them in a hash table and give back a pointer to the hash table entry.
06:12:12 <roconnor> http://www.geometricalgebra.net/
06:12:13 <lambdabot> Title: Geometric Algebra For Computer Science
06:12:15 * roconnor boings
06:12:46 <ddarius> roconnor: The "object-oriented" seems to be a red-herring mostly; a good thing.
06:13:23 <roconnor> ddarius: Yeah, I hope that is just there to help sell the book and has nothing to do with the content.
06:13:32 <ptolomy> ah right. That's what intern strings are. I'm familiar with that idiom from ocaml.
06:13:33 <vincenz> dons: I installed regexp-base...from hackage...still the same problem on Eval
06:13:35 <roconnor> ddarius: have you see this book?
06:13:36 <ddarius> roconnor: Read the sample chapter.
06:13:54 <ddarius> roconnor: I considered buying it a little bit back, but I decided against it.
06:14:14 <ddarius> Not enough content that I don't have a decent handle on.
06:14:31 <ddarius> Instead I got "Categories for the Working Mathematician"
06:14:45 <roconnor> ddarius: I would consider using it for a course in Computer Graphics, but I haven't read it yet. :)
06:15:34 <ddarius> roconnor: The book is probably pretty good, but GA is -definitely- the way to go for that (if you don't mind being non-mainstream, but for great benefit)
06:16:35 <ddarius> roconnor: Leo Dorst's site has a lot of decent papers on GA for CG and I think David Hestene's does too.
06:16:46 <ddarius> (rather "has a few too")
06:17:10 <ddarius> Most of the content of Dorst's book is available on his site in paper form.
06:17:29 <ddarius> Or at least that appears to be the case.
06:17:43 * wli discovers mapAccumL/mapAccumR
06:18:11 <ddarius> :t mapAccumL
06:18:11 <roconnor> I'm going to try to get the university to buy the book.
06:18:13 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
06:18:16 <roconnor> that's what I ususally do.
06:18:35 <Philippa_> GA is at least known of in graphics, too - hell, I first saw it mentioned on flipCode
06:18:44 <ddarius> Jaap Suter?
06:18:58 <Philippa_> I forget who posted about it first - Tim Sweeney's a fan too
06:19:20 <quicksilver> wli: isnt that just mapM in the state monad, unrolled?
06:19:32 <wli> ddarius: Wonderful for dynamic programming. The accumulator is your memo table, etc.
06:19:41 <ddarius> For comprehension at least (but with Jaap Suter's Clifford library even fairly efficiently) GA is the way to go even to explain typical CG techniques.
06:19:51 <wli> quicksilver: probably, yes... I need to get a better grip on the state monad.
06:19:55 <ddarius> quicksilver: Yep.
06:20:01 <Philippa_> yeah, it struck me that way from what reading I did - it's just been a while since I did it
06:20:32 <ddarius> It's ridiculous how it massively simplifies and clarifies -everything- it's applied to.
06:21:37 <edwardk> the plucker visibility problems that I worked on in my first thesis can be realized quite nicely in geometric algebra.
06:21:54 <jethr0> how did printing a number in binary work again?
06:22:07 <dons> one of the AtBase functions in Numeric
06:22:08 <ddarius> :t showBinary
06:22:08 <jethr0> and for hex, i'm not too fond of showHex. what would you suggest? printf?
06:22:08 <quicksilver> :t showIntAtBase
06:22:11 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
06:22:11 <lambdabot> Not in scope: `showBinary'
06:22:15 <wli> jethr0: unfoldr in a pinch
06:22:26 <dons> or unfoldr if you like elegance :)
06:22:30 <jethr0> wli: i'm happy to use a library function ;)
06:22:41 <edwardk> The biggest problem that most people have with GA is it is hard to visualize something both area-like and vector-like. few people have good intuitions for it.
06:22:54 <ddarius> edwardk: What the heck?
06:23:05 <jethr0> that's not elegance, that's not-invented-here for anything but a quiz solution for print numbers in binary
06:23:08 <edwardk> ddarius: ?
06:23:09 <ddarius> What's both "area-like and vector-like"?
06:23:17 <edwardk> ddarius: in geometric algebra?
06:23:29 <dons> > let step 0 = Nothing ; step i = Just (fromIntegral i, i `shiftR` 1) in unfoldr step 1232
06:23:31 <lambdabot>  [1232,616,308,154,77,38,19,9,4,2,1]
06:23:36 <ddarius> For the 3D GA, everything is easily visualizable.
06:23:42 <edwardk> ddarius: when you have both a vector and a bivector components to a multivector
06:24:26 <ddarius> Anyway, I have to go. Now
06:26:59 <jethr0> "printf "%x" (200 :: Integer)" prints the solution and then dies with "Exception: Prelude.undefined". huh?
06:27:30 <mauke> jethr0: that's because you used the IO return type and then looked at the result
06:27:32 <Igloo> Use   printf "%x" (200 :: Integer) :: IO ()
06:27:49 <mauke> even better, :: String
06:28:24 <mauke> (200 :: Integer) is redundant
06:29:01 <Igloo> Technically, but defaulting is evil, so I'd put it in personally
06:29:55 <jethr0> k, thanx
06:31:23 <SamB_XP_> > printf "%x" 200 :: String
06:31:25 <lambdabot>  "c8"
06:31:46 <SamB_XP_> oh, but that's that aggressive defaulting...
06:32:04 * SamB_XP_ doesn't think that really usually
06:33:07 <SamB_XP_> er, works
06:33:24 <quicksilver> Igloo: I don't understand that undefined result jethr0 got?
06:33:54 <SamB_XP_> quicksilver: try printf "hi!" >>= print
06:34:02 <mauke> there's an IO a instance for PrintfType and it ends with return undefined
06:34:07 <SamB_XP_> er.
06:34:07 <quicksilver> oh
06:34:14 <quicksilver> well that's a bit weird
06:34:15 <vincenz> mauke: 1cool
06:34:15 <SamB_XP_> or maybe >>= putStrLn
06:34:18 <vincenz> mauke: 0cool
06:34:21 <vincenz> mauke: how do you reset a color?
06:34:22 <Syzygy-> Seee! -c wasn't such a bad idea anyway!
06:34:35 <quicksilver> mauke: that sounds like a harmful instance to me
06:34:35 <etnt> isn't is possible to post to the cafe-mailing list via gmane ?
06:34:37 <Syzygy-> vincenz: Repeat the allocation.
06:34:39 <mauke> vincenz: ^O
06:34:40 <edwardk> always wondered why it was IO a and not IO ()
06:34:45 <vincenz> 0foo
06:34:47 <vincenz> 0foobar
06:34:48 <Syzygy-> mauke: ^O doesn't work reliably.
06:34:53 <mauke> :(
06:35:01 <Syzygy-> vincenz: Do ^B at the beginning -and- the end of your bolding.
06:35:06 <Syzygy-> foobar
06:35:12 <vincenz> foo
06:35:17 <vincenz> Syzygy-: oh, I was using color
06:35:22 <vincenz> ^C0
06:35:27 <Syzygy-> Then repeat that.
06:35:31 <Syzygy-> 0foo0bar
06:35:33 <Syzygy-> No.
06:35:40 <Syzygy-> 0foobar
06:35:42 <Syzygy-> Bah.
06:35:45 <vincenz> :)
06:35:50 <vincenz> 3foo
06:35:51 <mauke> edwardk: instance Foo (IO ()) is not valid h98 AFAIK
06:35:52 <Syzygy-> And ^O doesn't really reset, even though it claims to.
06:36:12 <quicksilver> mauke: hmm that's a good point
06:36:21 <ndm> are there any hackage stats, like how many people use a particular package?
06:36:26 <SamB_XP_> mauke: neither is Text.Printf, technically ;-)
06:36:28 <quicksilver> mauke: then again, neither is instance Foo String
06:36:36 <mauke> yes, exactly
06:37:05 <SamB_XP_> what I mean is that "module Text.Printf" is not valid Haskell 98
06:37:37 <edwardk> mauke: oh yeah, forgot about haskell 98 for a minute ;)
06:38:28 <SamB_XP_> printf doesn't use "instance Foo String"
06:38:54 <mauke> instance (IsChar c) => PrintfType [c]
06:38:56 <SamB_XP_> I suppose they could use the same trick to fake "instance Foo (IO ())"
06:39:00 <dons> f x 05| y 05<- x 05= x 10`k` y
06:39:15 <dons> its a pity we can't use colour. oh well
06:39:26 <SamB_XP_> dons: ... we can't?
06:39:41 <vincenz> 2d3o4n5s 6i7s 8l9e10e11t
06:39:46 <SamB_XP_> you seem to have just proved the contrary to *me*
06:39:47 <dons> !!! we can't!
06:40:06 <dons> to *you* but not to *me*
06:41:25 <roconnor> oooh, is lambdabot going to colourize our haskell terms?
06:41:33 <quicksilver> we wanted to 
06:41:38 <quicksilver> but we were told we couldn't
06:41:52 <malcolmw> what would be wrong with emboldening and underlining instead of colours?
06:41:57 <SamB_XP_> oh, is that what he meant by "use colors"
06:41:57 <quicksilver> the big kids said they'd beat us up if we did :(
06:42:33 * vincenz beats quicksilver 
06:42:42 <Syzygy-> What big kids?
06:42:45 <Syzygy-> Huh?
06:42:46 <SamB_XP_> I was all ready to paste a partial screenshot into MS paint
06:42:47 <Philippa_> vincenz: I couldn't see the d in "dons is leet" there, btw
06:43:24 <vincenz> dark blue
06:43:31 <malcolmw> you mean dons is d-leet-d ?
06:43:32 <Syzygy-> vincenz: Philippa_s point exactly.
06:43:46 <vincenz> Syzygy-: I was just being an diot
06:43:47 <vincenz> +i
06:43:59 <Syzygy-> vincenz: Nonono, it works well without the i too. :P
06:44:02 <vincenz> I wasn't making a deeply philosophical point about color usage
06:44:15 <Syzygy-> dons: Poke!
06:44:25 <Philippa_> vincenz: you weren't intentionally, anyway :-)
06:44:41 <vincenz> Philippa_: ooh, I am a idiot-savant philosopher?
06:44:47 <vincenz> that can't type... +n
06:44:54 * vincenz hires a new typist
06:44:54 <Philippa_> half right ;-)
06:46:20 <SamB_XP_> Philippa_: you mean he just can't type?
06:46:50 <quicksilver> Syzygy-: we had a discussion
06:46:56 <quicksilver> Syzygy-: we didn't exactly reach a consensus
06:47:05 <quicksilver> Syzygy-: but suffidcientlyly many people objected to colours
06:47:15 <quicksilver> Syzygy-: that it seemed reasonable to 'leave the status quo'
06:48:07 <SamB_XP_> personally, I see the main problem as being that lambdabot can't colorize what *I* say ;-P
06:48:54 <mauke> 07pe05rs08on09al03ly10,, 11I 12se02e 06th13e 04ma07in05 p08ro09bl03em10 a11s 12be02in06g 13th04at07 l05am08bd09ab03ot10 c11an12't02 c06ol13or04iz07e 05wh08at09 *03I*10 s11ay12 ;02-P
06:48:55 <malcolmw> SamB_XP_: but of course, ghci can
06:48:59 <mauke> ^ like that?
06:49:10 <SamB_XP_> mauke: I meant more like...
06:49:18 <dons> heh
06:49:20 <SamB_XP_> > printf "%x" 200 :: String
06:49:22 <lambdabot>  "c8"
06:49:34 <sieni> wtf, I thought I had disabled colorization, grr...
06:50:23 <Igloo> The channel was +c a while ago...dunnot why it was changed
06:50:26 <dons> no, its not disabled. its not scripted though either.
06:50:40 <dons> glguy suggested we see if it is useful
06:50:46 <quicksilver> Igloo: it was changed as a deliberate experiment
06:50:51 <Igloo> It's mostly useful to spammers
06:51:05 <quicksilver> Igloo: it has been suggested that colour, and especially underline and bold, can be helpful in programming discussion
06:51:13 <dons> forM_ 05[06105..061005] print 02-- nice
06:51:21 <dons> but oh well, people have broken clients
06:51:25 <SamB_XP_> blech!
06:51:31 <SamB_XP_> I don't like your choice of color
06:51:32 <dons> like SamB_XP_. but he's just noisy
06:51:37 <dons> its not my choice. its yours.
06:51:41 <quicksilver> Igloo: to, e.g. distingusih meta syntax from syntax, and such like
06:51:41 <sieni> quicksilver: underline and bold are different from actual colours
06:51:41 <dons> vim .Xresources
06:51:53 <quicksilver> sieni: indeed they are, but the discussion is related
06:52:11 <dons> so likely we'll see very small use of bold/italics
06:52:13 <sieni> quicksilver: somewhat, yes
06:52:14 <dons> and not much colour
06:52:26 <quicksilver> sieni: in particular, they both require that +c was removed
06:52:26 <Igloo> quicksilver: I understand, but it's also a favourite tool of spammers
06:52:28 <SamB_XP> like, doesn't +c strip out bold and underline too?
06:52:44 <quicksilver> Igloo: we don't appear to suffer too much from that, though
06:52:46 <sieni> quicksilver: ahh, yes
06:52:51 <quicksilver> Igloo: unless we count mauke ;)
06:53:12 <sieni> quicksilver: I hope that irssi has a way of filtering colours and not underlining and boldface
06:53:12 <mauke> hey, at least I used the pretty rainbow script
06:53:23 <malcolmw> blimey the colours look just awful in the logs
06:53:36 <dons> malcolmw: as ascii gunk?
06:53:41 <malcolmw> yup
06:53:45 <dons> ungreppable gunk too
06:53:52 <SamB_XP> what's cmeme's website again?
06:54:12 <dons> did people see this tutorial that appeared on reddit today,
06:54:13 <dons>   http://neugierig.org/software/darcs/haskell-for-programmers/haskell-for-programmers
06:54:14 <malcolmw> yup, mostly numbers intercalated with the characters
06:54:16 <lambdabot> http://tinyurl.com/2ezmcm
06:54:21 <dons> seems to be getting good reviews from non-haskellers
06:54:29 <dons> we should hmm ... put it on the wiki
06:54:43 <quicksilver> sieni: I would think most clients enable you to turn off colours. Apparently that's not good enough.
06:54:56 <quicksilver> sieni: either people don't want to have to do that, or people use clients without that feature
06:55:13 <dons> `intercalated' is used more often in #haskell conversation than in any other place or time in the history of this planet. :)
06:55:59 <SamB_XP> dons: that's because it's so damn useful
06:56:37 <SamB_XP> in the old days, they didn't have to talk about it -- they just did it. Also they had to use a lower-order version because they had to handle the last two items specially.
06:56:38 <vincenz> dons: I intercalated to work yesterday
06:57:00 <dons> sound painful
06:57:09 <SamB_XP> vincenz: you were concatenated between the items of a list?
06:57:19 <SamB_XP> a list of lists, no less?
06:57:20 <vincenz> SamB_XP: yes, work, work, and more work
06:57:29 <earthy> dons: that tutorial was quite nice indeed
06:57:32 <SamB_XP> that sounds more like interspersed to me
06:57:45 <earthy> and formatted in something resembling markdown, IIRC
06:57:53 <earthy> so should be relatively easy to add to the wiki
06:57:56 <vincenz> SamB_XP: My mind was at the end of the day :/
06:58:00 <dons> yes, he appears to have a GenHtml.hs script in the same repo
06:58:17 <dons> just waiting to hear back from the author -- it looks like he worked on it last July, and hasn't touched it since
06:58:29 <earthy> it looked familiar at least
07:01:22 <syntaxfree> I'm having the recurrent Navarro migratory crisis.
07:01:29 <Syzygy-> syntaxfree: Eyo!
07:01:36 <Syzygy-> syntaxfree: Take a look at fierynewbz.info
07:01:47 <syntaxfree> Syzygy-: did you get the email about the fusion proposal?
07:01:53 <Syzygy-> Ummm, yeah.
07:02:01 <syntaxfree> can I finish this rant, then we talk ICFP?
07:02:04 <Syzygy-> Don't know anyone in the proposal though, which makes me sceptical.
07:02:05 <Syzygy-> Sure.
07:02:06 <vincenz> Syzygy-: what's fierynewbz.info
07:02:11 <syntaxfree> I'm having the recurrent Navarro migratory crisis.
07:02:16 <Syzygy-> vincenz: Team webpage + team domain.
07:02:21 <dons> crikey. you've got a website set up for the contest team?
07:02:30 <Syzygy-> vincenz: What, doesn't your team have a domain name of your own???
07:02:36 <Syzygy-> dons: Ummm... yeah?
07:02:38 <syntaxfree> It's the crisis that made the Navarros from Navarra, Basque country leave their home and go to Aragon, the richest kingdom in christian Iberia in the 12th century.
07:02:42 <dons> cool!
07:02:54 <dons> yeah, makes vincenz look like a lazy bum
07:02:54 <Syzygy-> dons: It's just a vanilla wordpress installation right now, but....
07:03:04 <vincenz> Syzygy-: I can't reply :(
07:03:06 <syntaxfree> It's the crisis that made some Navarros go from Spain to Latin American in the 16th and 17th centuries.
07:03:16 <vincenz> dons: we are :)
07:03:18 <vincenz> dons: "lazy bottoms"
07:03:19 <syntaxfree> It's the crisis that made my dad leave Bolivia and come to Brazil.
07:03:33 <vincenz> bum = bottom in english
07:03:35 <syntaxfree> it's the "WHAT THE FUCK AM I DOING IN THIS BACKWARDS-ASS COUNTRY???" crisis.
07:03:40 <dons> heh
07:04:01 <syntaxfree> I was rejected for yet another job. Hell, I was the most qualified.
07:04:32 <syntaxfree> I didn't want to leave this place. My dream was renting a flat in my own city, set out on my own, drink with the few friends I've got, etc. 
07:04:50 <syntaxfree> but, god, I'm being underutilized.
07:04:55 <chylli> Question: is _ a special variable name or just a common variable name like x when making pattern match in function difination ?
07:04:58 <syntaxfree> SO, who wants to give me a job? :D
07:05:02 * kfish pours syntaxfree some hard liquor
07:05:13 <vincenz> > iterate syntaxfree liquor
07:05:14 <lambdabot>   Not in scope: `liquor'
07:05:24 <dons> chylli: its a bit special
07:05:25 <malcolmw> chylli: it's special
07:05:26 <cdsmith> chylli: it's special; it means "I don't care".
07:05:26 <mauke> chylli: it's special
07:05:32 <mauke> QUADROPHONIC
07:05:36 <dons> > let f _ _ _ 1 = 1 in f 1 2 3 4
07:05:37 <lambdabot>   Non-exhaustive patterns in function f
07:05:42 <dons> > let f _ _ _ x = x in f 1 2 3 7
07:05:43 <lambdabot>  7
07:05:55 <syntaxfree> > iterate (map (\x->"give"++x++"some liquor")) "syntaxfree"
07:05:56 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
07:05:58 <dons> mauke: new record!
07:05:59 <malcolmw> drop3 . take 4 . iterate reply
07:05:59 <chylli> thanks
07:06:00 <cdsmith> chylli: Unlike ordinary variables, you can use it multiple times; and the compiler won't warn about unused parameters if you turn that warning on.
07:06:04 <vincenz> chylli: it can match multiple things and the compiler won't mind if they are different types
07:06:11 <mauke> > let f _ = _ in f 'x'
07:06:11 <lambdabot>  Parse error in expression
07:06:11 <vincenz> chylli: you can't bind multiple things to other variables
07:06:16 <cdsmith> @quote stero
07:06:16 <lambdabot> No quotes match. This mission is too important for me to allow you to jeopardize it.
07:06:20 <vincenz> > let f x x = x in f 1 2
07:06:20 <lambdabot>      Conflicting definitions for `x'
07:06:21 <lambdabot>     In the definition of `f'
07:06:23 <syntaxfree> @quote stereo
07:06:23 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
07:06:23 <cdsmith> @quote stereo
07:06:24 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
07:06:30 * Lemmih grins.
07:06:31 <cdsmith> Ha!
07:06:32 <syntaxfree> that is the Master Quote.
07:06:34 <quicksilver> meta-stereo
07:06:35 <chylli> thanks very much
07:06:37 <dons> heh
07:06:41 <syntaxfree> we should have a @stereo for it.
07:06:44 <dons> yeah
07:06:44 <chylli> are there other special variables like it ?
07:06:49 <dons> chylli: no.
07:06:55 <quicksilver> I wouldn't really call it a variable
07:06:55 <syntaxfree> anyway, I need some help around a lot of things.
07:06:59 <quicksilver> I'd call it special synta
07:07:01 <quicksilver> syntax
07:07:01 <syntaxfree> Applying for programming jobs in the US.
07:07:17 <cdsmith> syntaxfree: how soon?
07:07:26 <dons> i thought you were an economist, syntaxfree ? :)
07:07:30 <kfish> as the advertisements say, "you deserve _, because you're special"
07:07:42 <dons> you've seen the error of your ways? 
07:07:46 <syntaxfree> yeah. 
07:07:47 <syntaxfree> :)
07:08:13 <syntaxfree> I'm actually confused between finishing my masters' or just leaving NOW, moving OUT, LEAVE LEAVE LEAVE THIS BACKWARDS-ASS COUNTRY.
07:08:22 <dons> maybe take it to -blah though, syntaxfree :)
07:08:27 <dons> a bit OT.
07:08:29 <syntaxfree> sorry. I'm deranged.
07:08:33 <dons> yes!
07:08:33 <syntaxfree> I'll take it there.
07:08:58 <syntaxfree> sorry about the misplaced rant. I'm out of control.
07:09:05 <dylan> syntaxfree: what country?
07:09:21 <syntaxfree> dylan: I will keep it on #haskell-blah ;)
07:09:56 <Syzygy-> syntaxfree: Migration isn't that bad. I've done it twice already.
07:10:16 <vincenz> Syzygy-: how do you keep your context? or do you serialize the full closure?
07:11:06 <Syzygy-> vincenz: Well, intra-process communications, repeated temporary migrations and several open pipes seem to solve most of the more obvious problems.
07:11:31 <vincenz> Syzygy-: so who do you leave behind as communication process? do you dump your gf each tmie?
07:12:03 * vincenz moves to #oasis as he's violating his own principles
07:14:16 <vincenz> syntaxfree: remove your name from the looking memebers on the haskell.org page on ICFP since you're in a team now?
07:14:44 <vininim> Is there any clever way to limit Integer to a range in a data?
07:16:13 <EvilTerran> vininim, sadly not. i think you have to newtype, and re-implement all the number-related classes etc as passthroughs
07:16:21 <EvilTerran> (with range limits)
07:16:48 <|Steve|> What's the difference between newtype and data?
07:16:58 <quicksilver> bottoms
07:17:03 <vincenz> lazy ones
07:17:13 <vininim> mmm.... range checking in a couple of places might be better =P
07:17:14 <syntaxfree> vincenz: true.
07:17:15 <sek> has anyone built ghc-6.6.1-i386-apple-darwin ? I'm getting a dyld error about it not being able to find GNUreadline, even though i installed it. http://www.haskell.org/pipermail/glasgow-haskell-users/2007-May/012576.html which is meant to give instructions isnt helping me
07:17:16 <lambdabot> Title: ghc-6.6.1 Mac (Darwin) Binary Dists, http://tinyurl.com/2hya9r
07:17:30 <quicksilver> well newtype has a restricted form (one constructor, one field)
07:17:30 <EvilTerran> newtype Foo a = Foo a -- Foo undefined === undefined
07:17:41 <quicksilver> and it doesn't lift
07:17:42 <EvilTerran> data Foo a = Foo a -- Foo undefined /=== undefined
07:17:59 <EvilTerran> also newtype deriving doesn't work on datas
07:18:08 <roconnor> And patterns for newtype don't force evaluation.
07:18:52 <scook0> isn't there a no-overhead guarantee for newtypes? (or is that just an assumption?)
07:19:00 <vincenz> scook0: yes no extra pointer
07:19:10 <|Steve|> Oh.
07:19:22 <vincenz> (cause a null would give you an extra undefined)
07:19:38 <roconnor> scook0: well, Haskell doesn't have operational sementics, but yes there is a no-overhead guarantee :)
07:19:54 <rashakil> sek: It's hard to remember -- but I think I had it installed somewhere, but it was in the wrong place... so I move it somewhere else.  HTH :-/
07:20:14 * roconnor wonders about JHC
07:20:42 <sek> rashakil, i called make install for GNUreadline so it should have sorted it self out
07:21:15 <sek> the instructions on the website dont make any sense since i can't find this config.mk file which i am meant to edit
07:21:31 <quicksilver> roconnor: haskell has some operational semantics in its definition
07:21:34 <|Steve|> sek: Have you considered using macports to install readline?
07:21:36 <quicksilver> roconnor: just not a complete one
07:21:45 <roconnor> quicksilver: really?  That sucks
07:21:59 <sek> |Steve|, it's installed via fink, but it needs a newer version that the one on fink i think
07:22:01 <roconnor> quicksilver: do you have an example?
07:22:09 <matthew-_> > or []
07:22:10 <vininim> @src zipWith
07:22:10 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
07:22:10 <lambdabot> zipWith _ _      _      = []
07:22:11 <lambdabot>  False
07:22:13 <sek> and the one on darwin-ports is the same as that on fink
07:22:27 <|Steve|> One thing to keep in mind is that fink installs in /sw so make sure you have the appropriate -I and -L.
07:22:54 <sek> |Steve|, good point, ill look into it, even though i think ill still have issues with the versions
07:23:09 <|Steve|> Yeah, probably.
07:23:34 <quicksilver> roconnor: well, non-strictness is specified IIRC
07:23:45 <sek> fink got me into all this trouble in the first place, by not setting up some shared libraries for ghc properly =/
07:23:53 <|Steve|> Well, I just did the most pointless thing ever. I wrote a quine in C that doesn't contain any semicolons. Now I think I'll go to sleep.
07:23:55 <quicksilver> roconnor: ~-patterns are essentially operational
07:25:33 <sjanssen> quicksilver: don't ~-patterns have a simple syntactic transformation?
07:25:57 <pitecus> I've got this program:
07:26:00 <pitecus> import qualified Data.ByteString.Char8 as B
07:26:00 <pitecus> main = fmap (length . B.lines) B.getContents >>= print
07:26:23 <dcoutts_> sjanssen: yes, into let
07:26:25 <pitecus> It gives a different answer if I change ByteString to ByteString.Lazy
07:26:29 <sjanssen> case x of ~p -> e; becomes case x of y -> let p = y in e
07:26:35 <pitecus> That looks like a bug no?
07:26:57 <dcoutts_> pitecus: yes, there's a bug in Lazy.lines, it collapses blank lines
07:26:58 <sjanssen> pitecus: yes, that does look like  a bug
07:27:04 <EvilTerran> the different bytestrings have subtly different semantics for lines, iirc.
07:27:29 <mauke> \cC(?:01|1(?!\d))(?!,(?!01|1(?!\d)|14)\d)(?:,\d\d?)?
07:27:33 <quicksilver> sjanssen: hmm yeah. But the mere fact that those two are different alludes to something about the operational semantics of case and let
07:27:38 <quicksilver> sjanssen: or so it seems to me
07:27:40 <dcoutts_> EvilTerran: subtly different semantics eh? :-) is that like "unintended feature" ? :-)
07:27:56 <pitecus> is that gonna get get fixed?
07:27:58 <quicksilver> dcoutts_: haskell programs don't have bugs. Just subtle semantics.
07:28:13 <dcoutts_> heh, it's a bug, and it was my fault. I wrote that function.
07:28:23 <sjanssen> @remember quicksilver haskell programs don't have bugs. Just subtle semantics.
07:28:23 <lambdabot> Done.
07:28:34 <dcoutts_> pitecus: in the next release, yes.
07:28:41 <pitecus> ok thanks
07:28:54 <EvilTerran> i haven't read the spec for "lines", i don't know if the skipping or retaining of newlines is documented.
07:29:35 <EvilTerran> s/documented/defined/. if it isn't, it'd just be my "subtly different semantics". otherwise, yeah, it's a bug :P
07:30:24 <Syzygy-> WHOA!
07:30:40 <Syzygy-> All of a sudden, the case that I thought would take a couple of days calculated, got done in ~1000s.
07:30:56 <quicksilver> always a nice surprise
07:31:10 <Syzygy-> Ayup
07:31:19 <Syzygy-> Now, I only hope that it ends up being .. y'know .. correct too.
07:31:34 <Syzygy-> It has a bloody good chance of being, but ... 
07:32:21 <DRMacIver> You wrote it in Haskell. Haskell code doesn't have bugs, surely? :)
07:32:57 <Syzygy-> DRMacIver: Well .. there is the matter of understanding what that bloody throwaway comment after Definition 4 in The Seminal Paper actually was supposed to mean.
07:33:08 <scook0> DRMacIver: you have to enable them with -fbugs
07:33:18 <quicksilver> Syzygy-: ah. that's not a bug, though
07:33:24 <quicksilver> Syzygy-: that just having written the wrong program :)
07:33:34 <Syzygy-> @remember scook0 (on bugs in Haskell) DRMacIver: you have to enable them with -fbugs
07:33:35 <lambdabot> Done.
07:33:38 <Syzygy-> quicksilver: Ayup.
07:33:47 <Syzygy-> Do note that I never mentioned bugs.
07:34:00 <Syzygy-> I only said I hoped that the program I'm currently running really is correct.
07:34:44 <quicksilver> :)
07:36:56 <Nafai> Morning!
07:37:36 <campusblo> hello folks
07:38:22 <campusblo> so i have a function that i want to map over a list
07:38:33 <campusblo> only problem is that the function takes two inputs
07:39:09 <campusblo> no i can easily map a function that takes one impup over a list. but how do i do it with two?
07:39:09 <nomeata> campusblo: so do you want to map it over two elements of the list? or two lists?
07:39:25 <mauke> or do you want to fix one argument?
07:39:27 <nomeata> campusblo: it might help if you give us the type of the fuction and of the list
07:39:42 <nomeata> > map (+) [1..10] -- does not work
07:39:43 <LeCamarade> campusblo: Make a lambda that takes one element. Use that to call the two-arg one.
07:39:44 <lambdabot>  [<Integer -> Integer>,<Integer -> Integer>,<Integer -> Integer>,<Integer -> ...
07:39:56 <nomeata> > map (1+) [1..10] -- does work
07:39:58 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
07:40:05 <LeCamarade> > map (\x -> x + 2) [1 .. 5]
07:40:06 <lambdabot>  [3,4,5,6,7]
07:40:12 <LeCamarade> > map (+ 2) [1 .. 5]
07:40:13 <campusblo> nometa im not sure how to answer you
07:40:13 <lambdabot>  [3,4,5,6,7]
07:40:18 <campusblo> ok one sec
07:40:24 <mauke> > sequence (map (+) [1..10]) 1
07:40:25 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
07:40:26 <campusblo> ill paste the function
07:40:34 <mauke> nomeata: see? it does work!
07:40:34 <nomeata> campusblo: then give us more information about the promlem you want to solve
07:40:40 <nomeata> mauke: :-)
07:40:48 <nomeata> mauke: but not as intended by the haskell beginner
07:41:03 <mauke> who knows, maybe he's crazy
07:41:05 <vininim> mmm so I guess I can't define semantics for data constructors
07:41:37 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/1649
07:41:48 <nomeata> >  map ($1) (map (+) [1..10]) -- same crazyness monadless
07:41:48 <campusblo> ok i just pasted it 
07:41:49 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
07:42:08 <EvilTerran> > foldr1 (+) [1..10] -- nomeata, ?
07:42:09 <lambdabot>  55
07:42:15 <campusblo> its a program to code text 
07:42:28 <vincenz> mauke: sequence is in the reader monad
07:42:32 <mauke> toUpper/isLower/isSpace can be replaced by import Data.Char
07:42:34 <campusblo> crackbruteforce is supposed to code the text with several different keys
07:42:57 <campusblo> yeh mauke i know that. i just put them in there for now 
07:43:02 <nomeata> campusblo: try zipWith
07:43:09 <nomeata> eh, no
07:43:12 <mauke> campusblo: map (decryptbf text) [1..26]?
07:43:13 <Syzygy-> campusblo: map (decryptbf text) [1..25]
07:43:15 <Syzygy-> *26
07:43:17 <nomeata> what they say :-)
07:43:26 <Syzygy-> mauke: Darn you for typing quicker!
07:43:29 <Syzygy-> @quote stereo
07:43:29 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
07:43:35 <mauke> Syzygy-: copy/paste ftw!
07:43:49 <Syzygy-> Bah!
07:44:02 <campusblo>  campusblo: map (decryptbf text) [1..26]? tried that and it didnt work but it could have been a mistake i made in the syntax 
07:44:17 <quicksilver> campusblo: well it doesn't have the return type you want
07:44:30 <quicksilver> campusblo: it will just return [String]
07:44:40 <quicksilver> campusblo: i.e. all the results of the 26 calls to decryptbf
07:44:42 <campusblo> oh right thats the next problem
07:44:47 <campusblo> thats what i want to return
07:44:51 <campusblo> the string and the integer used
07:44:55 <mauke> map (\i -> (i, decryptbf text i)) [1 .. 26]
07:45:10 * nomeata wonders why he even starts typing... :-)
07:45:13 <campusblo> so when i run the program with a 1 i want the 1 returned as well as the string in a tuple
07:45:16 <campusblo> just like that 
07:45:24 <mauke> map ((,) `ap` decryptbf) [1 .. 26]
07:45:26 <quicksilver> or, zip (map (decryptbf text) [1..26]) [1..26]
07:45:43 <quicksilver> campusblo: mauke's first answer is probably the most sane though :)
07:45:56 <mauke> [(i, decryptbf text i) | i <- [1 .. 26]]
07:46:24 <quicksilver> yes, that's quite nice, too
07:46:28 <campusblo>  [(i, decryptbf text i) | i <- [1 .. 26]] looks like it should work
07:46:39 <mauke> join (zip . map (decryptbf text)) [1 .. 26]
07:46:44 <Syzygy-> WOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO!
07:46:44 <vininim> @paste
07:46:44 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:46:45 <Syzygy-> Loading package goa-3.0 ... linking ... done.
07:46:45 <Syzygy-> GOA> 
07:46:47 <vincenz> > map (id &&& (+1)) [1..26]
07:46:49 <lambdabot>  [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,12),(12,...
07:46:49 <Syzygy-> Boooo-yah!
07:47:00 <vincenz> > map (id &&& (decriptbf text)) [1..26]
07:47:01 <lambdabot>   Not in scope: `decriptbf'
07:47:21 <campusblo> decriptbf is commented out
07:47:26 <campusblo> i think decrypt can be used too
07:47:39 <hpaste>  vininim pasted "data constuctor" at http://hpaste.org/1650
07:47:43 <quicksilver> campusblo: well you have 5 or 6 answers now, pick your favourite
07:47:51 <campusblo> lol ok thanks
07:47:53 <campusblo> ill try them 
07:47:57 <campusblo> thanks a lot folks
07:48:12 <scook0> hmm, is there a name given to (id &&&) ?
07:48:25 <mauke> yes, ap (,)
07:48:30 <nomeata> :t (id &&&)
07:48:32 <lambdabot> forall a c'. (a -> c') -> a -> (a, c')
07:48:38 <mauke> :t ap (,)
07:48:40 <lambdabot> forall a b. (a -> b) -> a -> (a, b)
07:48:45 <nomeata> @fre (a -> c') -> a -> (a, c')
07:48:45 <lambdabot> Maybe you meant: free freshname
07:48:49 <nomeata> @free (a -> c') -> a -> (a, c')
07:48:49 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
07:48:58 <nomeata> @djinn (a -> c') -> a -> (a, c')
07:48:58 <lambdabot> Cannot parse command
07:48:58 <lambdabot> f :: (a -> c') -> a -> (a, c')
07:48:58 <lambdabot> f a b = (b, a b)
07:49:12 <mauke> @free foo :: (a -> c') -> a -> (a, c')
07:49:12 <lambdabot> g . h = k . f => $map_Pair f g . foo h = foo k . f
07:49:15 <nomeata> djinn is pretty darn cool
07:50:08 <mauke> vininim: that looks like a definition of the top-level variable x
07:50:11 <quicksilver> vincenz: what you are doing there, is defining 'x'
07:50:19 <nomeata> so djinn just proved is logic statement: (A -> B) -> (A -> (A â§ B))
07:50:26 <vincenz> quicksilver: thanks :)
07:50:29 <Syzygy-> Ok. I have GOA, and lambda and stuff. How do I convince it to actually ... y'know ... do something when I ask ti to hoogle?
07:50:36 <quicksilver> vincenz: oops, danmn tab complex
07:50:39 <quicksilver> vincenz: sorry :)
07:50:45 <vincenz> ;)
07:51:16 <wli> http://holomorphy.com/~wli/happy/Happy.hs <-- my non-monadic solution to the happy number problem.
07:51:31 <Syzygy-> More particularily, how do I get hold of a hoogle database?
07:52:17 <sakhnik> @help
07:52:18 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:52:24 <sakhnik> @list
07:52:24 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
07:52:58 <sakhnik> @type map
07:53:00 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
07:53:44 <vininim> wow.. in what syntax rule my snippet is defining x?
07:54:02 <nomeata> @djinn (a -> b) -> (c -> d) -> Either a c -> Either b d
07:54:03 <lambdabot> Cannot parse command
07:54:03 <lambdabot> f :: (a -> b) -> (c -> d) -> Either a c -> Either b d
07:54:03 <lambdabot> f a b c =
07:54:03 <lambdabot>     case c of
07:54:03 <lambdabot>     Left d -> Left (a d)
07:54:05 <lambdabot>     Right e -> Right (b e)
07:54:16 <quicksilver> vincenz: it's pattern binding
07:54:19 <quicksilver> vincenz: sorry!
07:54:23 <quicksilver> vininim: pattern binding
07:54:28 <quicksilver> vininim: like this :
07:54:29 <nomeata> @djinn ((a -> b), (c -> d),) Either a c) -> Either b d
07:54:30 <lambdabot> Cannot parse command
07:54:30 <lambdabot> Cannot parse command
07:54:39 <quicksilver> > map (\Just x -> x) [Just 1, Nothing]
07:54:39 <lambdabot>      Constructor `Just' should have 1 argument, but has been given 0
07:54:40 <lambdabot>     In t...
07:54:43 <nomeata> @djinn ((a -> b), (c -> d), Either a c) -> Either b d
07:54:43 <lambdabot> Cannot parse command
07:54:43 <lambdabot> f :: (a -> b, c -> d, Either a c) -> Either b d
07:54:43 <lambdabot> f (a, b, c) =
07:54:43 <lambdabot>     case c of
07:54:44 <lambdabot>     Left d -> Left (a d)
07:54:45 <lambdabot>     Right e -> Right (b e)
07:54:49 <quicksilver> > map (\(Just x) -> x) [Just 1, Nothing]
07:54:50 <lambdabot>   Non-exhaustive patterns in lambda
07:55:35 <mauke> vininim: let Test x = Test 42  -- binds 42 to x
07:55:41 <nomeata> thatâs a proof of ( (A â B) â§ (C â D) â§ (A â¨ B) ) â (C â¨ D)
07:56:28 <scook0> @type (+++)
07:56:30 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
07:56:56 <nomeata> @djinn (a -> a) -> a
07:56:56 <lambdabot> Cannot parse command
07:56:57 <lambdabot> -- f cannot be realized.
07:57:05 <mauke> who broke @djinn?
07:57:12 <vininim> is there any problem (with regards to referential transparency, type safety) in aditional semantics to constructor beside boxing?
07:57:15 <nomeata> aldaddin?
08:01:27 <wli> How do you fiddle with a function f so as to make foldl f into a foldr?
08:02:13 <vincenz> wli: try the other way
08:02:15 <vincenz> foldr into a foldl
08:02:36 <wli> vincenz: Well, it's not commutative.
08:02:41 <vincenz> I know
08:02:45 <vincenz> my point is that foldr is lazy-observant
08:02:47 <vincenz> foldl is not
08:02:50 <vincenz> so you'll end up with a really big thunk
08:02:53 <vincenz> a REALLY big one
08:03:13 <SamB> vininim: I'm not sure what you mean
08:03:14 <wli> Yes, that's why I want to transform the foldl which gives right answers into a foldr.
08:03:29 <vincenz> wli: foldl is inherently not lazy-observant..
08:03:33 <sjanssen> I'm fairly certain that you can't express foldr in terms of foldl
08:03:42 <wli> sjanssen: Yuck.
08:03:42 <sjanssen> you can write foldl in terms of foldr
08:03:49 * vincenz nods
08:03:51 <vincenz> probably
08:03:59 <vincenz> wli: foldl should be banned
08:04:02 <vincenz> foldr and foldl'
08:04:23 <wli> Better to just reverse the list?
08:04:27 <vincenz> > foldr (:) [] [1..10]
08:04:35 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
08:05:06 <vincenz> wli: probably
08:05:09 <sjanssen> @type \f z l -> foldr (\x xs y -> xs (f y x)) id l $ z
08:05:11 <lambdabot> forall a a1. (a1 -> a -> a1) -> a1 -> [a] -> a1
08:05:13 <SamB> why are we telling wli how it isn't possible to do the opposite of what he wants to do?
08:05:32 <sjanssen> wli: there is foldl in terms of foldr
08:05:34 <vincenz> SamB: we are not, we are saying you can't express foldr in foldl.  
08:05:48 <vincenz> SamB: which is what he asked for
08:05:52 <SamB> he said...
08:06:01 <vincenz> "have an f... to make foldl f be like a foldr
08:06:02 <SamB> <wli> How do you fiddle with a function f so as to make foldl f into a foldr?
08:06:05 <vincenz> or... express foldr in terms of foldl
08:06:15 <sjanssen> wli: why do you want to turn a foldl to a foldr?
08:06:19 <vincenz> SamB: yes, reread it again 
08:06:20 <vininim> SamB: a data declares a constructor wich basically just 'boxes' a type. I'm wondering how things like range check in a constructor parameter influence the type system, ie why you can't do stuff like I want. =p
08:06:34 <wli> sjanssen: foldl sucks. I dredged up a sort I could reverse the sense of elsewhere.
08:07:53 <sjanssen> wli: well, given that "foldl f z xs :: a" , then "foldr (flip f ) z xs :: a"
08:07:53 <SamB> wli: did you not mean that you want to rewrite "f" (say, as "f'") so that you can change all occurences of "foldl f" into occurences of "foldr f'"?
08:08:12 <wli> SamB: Basically.
08:08:18 <sjanssen> wli: so you can mechanically make foldrs out of foldls, but they don't always make sense afterwards
08:09:27 <vincenz> sjanssen: if you don't care about associativity :)
08:09:37 <SamB> it seems that I was right in my interpretation of what he wanted...
08:09:55 <vincenz> SamB: no... he wants to have an f... so he gets a foldr from a foldl.  That's "Expressing a foldr in terms of a foldl and some custom logic"
08:10:10 * shapr boings furiously
08:10:15 <vincenz> which is not possible unless you don't care about associativity
08:10:34 <vincenz> (well not possible is a big statement, you -can- reverse...)
08:10:37 <Nafai> Morning shapr!
08:11:26 <vincenz> foldr f = foldl (flip f) . reverse
08:11:27 <shapr> hiya Nafai! Are you training up for your Haskell job?
08:11:47 <arcatan> our daily morning shapr
08:11:49 <vincenz> wli: so if you don't want to reverse, f has to be associative
08:12:17 <shapr> hyvÃ¤Ã¤ huomenta arcatan ! Mitta?
08:12:29 <arcatan> mitta?
08:12:29 <wli> vincenz: I fixed it by other means.
08:12:36 <vincenz> wli: how did you do it
08:12:37 <shapr> arcatan: Mitta kuluu?
08:12:39 <vininim> okay
08:12:44 <SamB> wli: foldl f z xs = foldr (\b g a -> g (f a b)) id xs z
08:12:48 <SamB> fyi
08:12:48 <arcatan> shapr: hyvÃ¤Ã¤, kiitos
08:12:51 <wli> vincenz: Changing the sense of comparison in a sort.
08:12:54 <vininim> my question boils down to "is Dependent Types" possible in Haskell? 
08:12:55 <vincenz> wli: ah cool
08:13:05 <Nafai> shapr: Heh!  I wish!  Busy doing Java / Python at the moment, really wanting to get time in for Haskell
08:13:06 <quicksilver> vininim: in most cases, yes but ugly
08:13:17 <arcatan> shapr: playing with my tin whistle
08:13:27 <shapr> arcatan: Sounds like fun. Is it a USB tin whistle?
08:13:34 <shapr> Nafai: Make some time!
08:13:53 <shapr> arcatan: Hey, I learned Finnish in Tornio, mitta kuluu is one word too many.
08:14:10 <arcatan> there are usb tin whistles?
08:14:21 <shapr> I wouldn't be surprised...
08:14:23 <arcatan> shapr: (it's "mitÃ¤ kuuluu", btw)
08:14:36 <vincenz> arcatan: nowadays there's probably even usb-towels
08:14:43 <vincenz> "autodry in half the time!"
08:14:45 <shapr> My Finnish is leaving me, I only get to practice Swedish these days.
08:15:01 <shapr> arcatan: Talar du ocksÃ¥ Svenska?
08:15:33 <arcatan> shapr: ja, litet
08:15:56 <Nafai> shapr: I'm becoming more convinced the more I read that I should
08:16:04 <shapr> Nafai: Do it!
08:17:00 <shapr> arcatan: Too bad I never learned much Finnish... I wish I'd had more of a chance. Tornio people aren't very social. Many of them were more xenophobic than social.
08:17:23 <vininim> @src Integral
08:17:23 <lambdabot> class  (Real a, Enum a) => Integral a  where
08:17:23 <lambdabot>     quot, rem, div, mod :: a -> a -> a
08:17:23 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
08:17:23 <lambdabot>     toInteger           :: a -> Integer
08:17:30 <arcatan> shapr: why were you in Tornio, anyway?
08:17:37 <shapr> I met a woman on ICQ...
08:17:50 <Nafai> shapr: Just gotta find something to work on :)
08:17:57 <arcatan> oh
08:17:58 <shapr> Nafai: lambdabot?
08:17:59 <tommyd> shapr: those things tend to happen =)
08:18:14 <vininim> mm i could derive Integral, overload toInteger and spout it everywhere in code.. (ugly :/)
08:18:33 <shapr> arcatan: The really embarassing part is that I met a woman on ircqnet, ICQ's short-lived IRC service. That's pretty geeky.
08:18:57 <vincenz> shapr: met as in... with potential future avenues?
08:19:07 <SamB> shapr: they had their own irc network to go with ircq?
08:19:08 <shapr> Met as in, spent seven years living with.
08:19:21 <tommyd> hehe
08:19:22 <shapr> SamB: Yup
08:19:47 <tommyd> my wife and I met in a chatroom four years ago
08:20:02 <tommyd> and now we're married for over a year and have a little son
08:20:15 <shapr> nice!
08:20:42 <tommyd> where are the times where you met girls in bars or some other kind of socialized area?
08:21:04 <tommyd> anyways, heading off to my family now, have a nice weekend
08:21:07 <quicksilver> I wouldn't want to go out with the kind of girl you'd meet in the kind of bar that would let me past the front door.
08:21:08 <shapr> Hey, I met my current girlfriend three years ago at midsommarafton.
08:21:21 <quicksilver> (to paraphrase groucho marx rather liberally)
08:21:47 <arcatan> yay for traditional ways
08:21:48 <Nafai> I met my wife at church but we never really talked, but we hooked up because she found me on a social networking site and we started talking on AIM
08:21:55 <shapr> Nafai: Cool!
08:22:19 * shapr waves to tommyd 
08:22:34 <vininim> http://www.haskell.org/haskellwiki/Smart_constructor
08:22:35 <lambdabot> Title: Smart constructors - HaskellWiki
08:22:51 <Nafai> shapr: Is lambdabot hard to set up?
08:22:59 <shapr> It can be.
08:23:04 <shapr> But that's something you could work on ;-)
08:24:09 <arcatan> where's all the pear juice...
08:24:11 <shapr> Nafai: One easy way to get into Haskell might be to grab some of the libraries that aren't yet in Hackage and fix 'em up.
08:24:26 <shapr> Nafai: What sort of code do you do for fun?
08:25:13 <Nafai> Nothing lately, so I'm open :)
08:26:15 <Nafai> Most of the code I've written "for fun" in the past year or so has been stuff that I've needed for my blog or for my chat set up or little utilities for my desktop
08:26:22 <quicksilver> my most serious outstanding issue is that I'm scared of cabal
08:26:37 <shapr> quicksilver: It's really easy, go for it!
08:26:45 <quicksilver> I've had so many bad experiences in the past with 'other' packaging systems which subvert/ignore my OS's native packaging system
08:26:51 <quicksilver> that I'm convinced it will piss me off
08:26:54 <quicksilver> so I don't dare try it :)
08:27:05 <shapr> quicksilver: And if you have any problems with cabal, feel free to blame me in part.. I encouraged Isaac to start that whole project when we shared a hotel room in 2003.
08:27:06 <quicksilver> I fear it will make me fall out of love with haskell.
08:27:22 <quicksilver> shapr: I don't know Isaac at all, so can I blame you entirely?
08:27:25 <shapr> Isaac did all the work, I just try to take credit!
08:27:33 <shapr> quicksilver: Sure, fine by me :-)
08:28:41 <shapr> Ok, time for work...
08:28:42 * shapr &
08:29:19 <Nafai> So I'm trying to explain static typing to a friend and he says that worrying about types gets in the way of how he solves problems
08:29:35 <Nafai> I told him that those who like languages like Haskell use types as their means of solving problems
08:29:37 <hpaste>  Syzygy- pasted "Why do I get an exception with !! ?" at http://hpaste.org/1651
08:29:51 <Nafai> I know I've read something to that effect somewhere...but where is a good example of that?
08:29:58 <Syzygy-> I would imagine that in the pasted code, the if-then-else makes sure I never go for the !! without being able to.
08:30:15 <Syzygy-> But it throws me an exception, even though I make sure that the condition should trigger.
08:30:58 <quicksilver> Syzygy-: could it get called with a negative number, perhaps?
08:31:21 <Syzygy-> I call it with 0.
08:31:33 <quicksilver> that's OK
08:31:33 <Syzygy-> Oh, wait....
08:31:41 <Syzygy-> Yeah, then I should land in the trace.
08:31:56 <Syzygy-> Or, to be specific, I call it with 0 and (1,[[1]],[[1]])
08:32:17 <quicksilver> Syzygy-: shouldn't that be i+2?
08:32:23 <Syzygy-> It probably should, yeah.
08:32:36 <quicksilver> or, at least i+1
08:32:59 <quicksilver> no, i+2 I think
08:33:02 <Syzygy-> I want to be able to do !!i and !!i+1
08:33:07 <Syzygy-> so i+1 isn't enough.
08:34:02 <quicksilver> write, but you have i-2
08:34:07 <quicksilver> I think you want i+2 not i-2
08:34:23 <quicksilver> s/write/right/
08:36:18 <xtacy[]> hi, I am a newbie. I wrote main = putStrLn "Hello world" in my first program, but I guess I need to `include' some file to get it working. What is it? The haskellwiki didnt have anything...
08:36:26 <xtacy[]> Prelude has it, i suppose?
08:36:30 <mauke> you don't
08:36:34 <mauke> that's a complete program
08:37:19 <quicksilver> xtacy[]: the Prelude is imported by default, so your program was complete
08:37:24 <xtacy[]> oh, it works now, looks like I made a mistake :)
08:37:26 <quicksilver> :)
08:37:43 <xtacy[]> wow, this community seems to be very active indeed
08:38:52 <sjanssen> @users
08:38:52 <lambdabot> Maximum users seen in #haskell: 355, currently: 345 (97.2%), active: 17 (4.9%)
08:39:10 <quicksilver> @losers
08:39:11 <lambdabot> Maximum users seen in #haskell: 355, currently: 345 (97.2%), active: 17 (4.9%)
08:39:20 <quicksilver> hmm that's a very high loser/user ratio
08:39:29 <quicksilver> why don't more *winners* use haskell?
08:39:40 <tuukkah> @winners
08:39:41 <lambdabot> Unknown command, try @list
08:39:49 <lightstep> @lusers
08:39:49 <lambdabot> Maximum users seen in #haskell: 355, currently: 344 (96.9%), active: 18 (5.2%)
08:39:52 <tuukkah> totally unknown
08:40:56 <oerjan> @supers
08:40:56 <lambdabot> Maximum users seen in #haskell: 355, currently: 343 (96.6%), active: 19 (5.5%)
08:41:20 <tuukkah> my client says the current user count is 341...
08:42:11 <kfish> tuukkah, lambdabot has a bug where it runs 5 minutes ahead of realtime
08:42:16 <quicksilver> kfish: ;)
08:42:31 <HairyDude> I have a class Memoizable a (f :: * -> *) | a -> f, and instance (Memoizable a f, Memoizable b g) => Memoizable (a :+: b) (FProd f g) (where FProd :: (* -> *) -> (* -> *) -> * -> *). Apparently this instance violates the coverage condition, but I can't see how - surely it only gives one f for each a?.
08:43:07 <hpaste>  wli pasted "happy number module" at http://hpaste.org/1652
08:43:26 <matthew-_> HairyDude: can you paste the code?
08:43:30 <HairyDude> ok
08:43:56 <quicksilver> kfish: oh, by the way, you blogged about tagsoup
08:44:02 <kfish> quicksilver, yeah
08:44:06 <quicksilver> kfish: I managed to write some tagsoup code which does 'streaming modification'
08:44:13 <quicksilver> kfish: isntead of just data mining
08:44:26 <quicksilver> kfish: takes HTML and 'tidies it up' by removing some tags and converting others
08:44:38 <kfish> ah nice
08:44:44 <quicksilver> kfish: basically it tidied up the output of MS Word Save as HTML, added the right semantic markup around it
08:44:44 <hpaste>  HairyDude pasted "instance violating coverage condition?" at http://hpaste.org/1653
08:46:30 <matthew-_> HairyDude: sorry, but what is :+: ? I've never seen it before. Some type constructor?
08:46:59 <kfish> quicksilver, henning theilemann is interested in that side of things too, he has a tagsoup-based parser for wraxml
08:47:13 <HairyDude> matthew-_: it's a representation of a disjoint union type on the value level, from Data.Generics
08:47:19 <matthew-_> ok, tnx
08:47:47 <mauke> wait, like Either?
08:48:03 <HairyDude> mauke: basically, yeah
08:48:16 <HairyDude> mauke: it's isomorphic to Either
08:48:47 <kfish> quicksilver, http://darcs.haskell.org/wraxml/src/Text/XML/WraXML/Document/TagSoup.hs
08:48:49 <lambdabot> http://tinyurl.com/3yypyr
08:50:02 <matthew-_> HairyDude: I can't see why it doesn't like that
08:50:20 <matthew-_> does it go away if you allow undecideable instances?
08:50:27 <kjdf> is it possible to write a function f :: ([a] -> [a]) -> (a, ([a] -> [a])
08:50:49 <kjdf> ([a] -> [a]) -> [a] -> (a, ([a] -> [a])
08:50:55 <HairyDude> matthew-_: it gives other errors, but the complaint about the coverage condition goes away
08:51:03 <kjdf> that'd take 2 arguments - list processing function, and a list
08:51:22 <quicksilver> kjdf: well there isn't a complete function of that type
08:51:25 <matthew-_> HairyDude: I would suggest, allowing undecideable, fixing the other issues and then trying to take it off
08:51:34 <oerjan> kjdf: your type only has one argument
08:51:43 <HairyDude> right
08:51:46 <quicksilver> kjdf: but if you assume the result is unempty, yes, it's possible
08:51:47 <matthew-_> HairyDude: IME, undecideable instances don't normally cause problems
08:51:50 <quicksilver> oerjan: he pasted a correction
08:51:57 <quicksilver> oerjan: presumably the second is what he meant
08:51:57 <oerjan> er, right
08:52:24 <kjdf> well, I didn't finish what would it do...
08:52:35 <HairyDude> matthew-_: what's wrong with having a turing-complete type system eh? :)
08:52:48 <matthew-_> HairyDude: some of us rather like it actually ;)
08:52:57 <kjdf> ftail f xs
08:53:11 <kjdf> would return first element of (f x)
08:53:18 <matthew-_> HairyDude: it's only really incoherent instances that get you into trouble quickly
08:53:39 <kjdf> ok
08:53:43 <kjdf> that makes no sense :)
08:53:43 <quicksilver> kjdf: sure, that's just ftail f xs = head (f xs)
08:53:51 <quicksilver> funny choice of name though :)
08:54:08 <quicksilver> looks like you wanted to return the function too
08:54:23 <kjdf> I was looking for a way to extract "state" of the mapping function
08:54:27 <quicksilver> :t let ftail f xs = (head (f xs),f)  in ftail
08:54:29 <lambdabot> forall t a. (t -> [a]) -> t -> (a, t -> [a])
08:54:35 <kjdf> if it was composed from a couple of mutually recursive ones
08:54:39 <quicksilver> slightly more general than the type you asked for
08:54:46 <quicksilver> thanks to the magic of H-M inference
08:54:52 <kjdf> so I could do something with partial result, then resume computation
08:55:05 <kjdf> but that's probably worst way to do it :)
08:55:06 <quicksilver> you don't normally need to be that clever
08:55:15 <quicksilver> lazy evaluation does all that, behind the scenes, automatically :)
08:56:39 <quicksilver> kjdf: the answer is: yes, you can write that function, but you can't guarantee it will work right, because you can't be *sure* that 'f' runs in such a way that the first element is computed before the others.
08:56:47 <quicksilver> kjdf: however, you don't even need to worry
08:57:09 <kjdf> what I want is some sort of list processor combinator
08:57:13 <quicksilver> kjdf: because if 'f' does behave in that way, then haskell automatically makes results available to you when they're ready, and doesn't make you wait for the whole computation
08:57:30 <kjdf> that enables/disabled underlying list processing function and switches to identity
08:57:40 <kjdf> upon seeing some predetermined input
08:57:43 <vininim> arrows?
08:58:14 <kjdf> I wish I knew, vininim ;)
08:58:15 <kjdf> maybe
08:58:28 <kjdf> I'm pretty new to this 'haskell thing'
08:58:37 <kjdf> I guess it is time to read up on arrows.
08:59:05 <scook0> the nice thing about arrows
08:59:11 <scook0> is that even if you never use them
08:59:22 <scook0> you still get nice combinators like (>>>) and (&&&)
08:59:33 <kjdf> what do they do?
08:59:35 <HairyDude> hrm... I can't even find where (:*:) is defined
08:59:42 <HairyDude> ?hoogle (:*:)
08:59:43 <lambdabot> Did you mean: (:*:)
08:59:43 <lambdabot> Prelude.undefined :: a
08:59:43 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
08:59:52 <quicksilver> kjdf: I think everything you want is automatic with haskell's lazy evaluation
09:00:03 <quicksilver> kjdf: I don't think you need to do anything clever at all, to achieve that
09:00:05 <HairyDude> that "did you mean" isn't very useful
09:00:07 <oerjan> HairyDude: i don't think hoogle tackles operators containing *
09:00:24 <HairyDude> ?hoogle (:+:)
09:00:24 <lambdabot> Did you mean: (:+:)
09:00:24 <lambdabot> Prelude.undefined :: a
09:00:24 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
09:00:27 <oerjan> ?hoogle (**)
09:00:28 <lambdabot> Did you mean: (**)
09:00:28 <lambdabot> Prelude.undefined :: a
09:00:28 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
09:00:29 <shapr> HairyDude: I'm pretty sure that's an HList combinator.
09:00:31 <mauke> ?hoogle :*:
09:00:32 <lambdabot> Hoogle Error: Parse Error: Unexpected character ':*:'
09:00:40 <mauke> ?hoogle :+:
09:00:41 <lambdabot> Hoogle Error: Parse Error: Unexpected character ':+:'
09:00:41 <shapr> HairyDude: Where did you see it?
09:01:47 <HairyDude> shapr: http://www.haskell.org/ghc/docs/latest/html/users_guide/generic-classes.html
09:01:48 <lambdabot> Title: 7.13. Generic classes, http://tinyurl.com/33xvg5
09:03:40 <HairyDude> well fixing the other problems hasn't made the coverage condition complaint go away
09:03:54 <quicksilver> I don't know the relationship between Generics and Data.Generics
09:04:11 <cdsmith> I'm writing a description of using Hackage and Cabal, and it's occurred to me... shouldn't someone write some shell scripts to automate this?
09:04:16 <HairyDude> oh, just Generics, didn't notice that :)
09:04:17 <cdsmith> Or do they exist?
09:04:53 <shapr> cdsmith: To automate what?
09:05:08 <shapr> cdsmith: cabal-install grabs a package and all of its deps from hackage.
09:05:18 <Nafai> Man, I want to play with lambdabot but I have to work :(
09:05:22 <cdsmith> wget, tar xzf, runhaskell Setup [configure/build/install]
09:05:33 <cdsmith> shapr: okay, maybe that's what I'm looking for
09:05:42 <mauke> @vixen play with me
09:05:42 <lambdabot> just talking with you gives me a major hardon!
09:05:45 <shapr> cdsmith: darcs get --partial http://darcs.haskell.org/cabal-install
09:05:47 <lambdabot> Title: Index of /cabal-install
09:06:13 <shapr> cdsmith: For cabal-install cabal-setup and friend, you *really* want --partial, since they were forked off of cabal proper.
09:06:18 <shapr> The whole project history is huge.
09:06:29 <mauke> 8000 threads!
09:06:30 <HairyDude> I have a feeling Generic = Data.Generic
09:06:34 <cdsmith> shapr: Okay, thanks.
09:07:29 <HairyDude> Prelude> :m + Generics
09:07:29 <HairyDude> Could not find module `Generics':
09:07:29 <HairyDude>   it is a member of package ghc-6.6.1, which is hidden
09:07:50 <quicksilver> HairyDude: but Data.Generics doesn't have the generic typeclass stuff
09:07:54 <quicksilver> HairyDude: as far as I know
09:08:11 <quicksilver> HairyDude: Data.Generics is all about type metaprogramming, but doesn't have specific tools for derivations
09:08:14 <quicksilver> or maybe I missed it
09:08:29 <HairyDude> using -package lets me use Generics at least
09:08:47 * wli starts seeing monads.
09:08:50 <Igloo> Data.Generics exports what Generics used to
09:09:11 <shapr> wli: Oh, you got one?
09:09:15 <wli> If there's some argument you're passing around to every function in your program, you've got a monad somewhere.
09:09:28 <shapr> yup
09:09:51 <quicksilver> Igloo: I don't see it
09:09:56 <mauke> duh. (->) arg is an instance of Monad :-)
09:10:01 <Igloo> quicksilver: Don't see what?
09:10:06 <quicksilver> Igloo: I don't see the write-your-own-deriving stuff; :*: and :+:
09:10:15 <wli> Is there some way to get the list of loaded modules abbreviated or not printed on the command line in ghci?
09:10:22 <quicksilver> mauke++ # appropriate use of bold
09:10:37 <HairyDude> quicksilver: hmm, I see :*: and :+: in Data.Generics
09:10:51 <vincenz> wli: :show modules
09:11:03 <Igloo> Prelude> :i (Data.Generics.:+:)
09:11:03 <Igloo> data (GHC.Base.:+:) a b = GHC.Base.Inl a | GHC.Base.Inr b
09:11:41 <vincenz> Igloo: these exist for most "algebraic" formulas for types?  That's quite interesting cause Conor McBride refered to a way to automatically derive those using a typeclass
09:11:42 <Syzygy-> @karma
09:11:43 <lambdabot> You have a karma of 1
09:11:52 <vincenz> Syzygy-++
09:11:55 <Syzygy-> Hmmm. Didn't I have more oncE?
09:12:05 <Syzygy-> Or did my enthusiasm for colours get me down-karmaed?
09:12:05 <mauke> @karma Syzygy
09:12:05 <lambdabot> Syzygy has a karma of 0
09:12:12 <Syzygy-> WHOA!
09:12:16 <vincenz> @karma Syzygy- 
09:12:17 <lambdabot> Syzygy- has a karma of 2
09:12:20 <vincenz> @karma syzygy
09:12:21 <lambdabot> syzygy has a karma of 0
09:12:22 <Syzygy-> Ah.
09:12:24 <quicksilver> HairyDude: I was just browsing the haddock
09:12:30 <HairyDude> @karma Syzygy
09:12:31 <lambdabot> Syzygy has a karma of 0
09:12:31 <quicksilver> HairyDude: maybe they aren't documented?
09:12:46 <oerjan> @karma syzygy- 
09:12:47 <lambdabot> syzygy- has a karma of 0
09:13:12 <Syzygy-> Talk about tab-completion being necessary....
09:13:21 <Igloo> vincenz: You need -fgenerics and to explicitly ask for the instances to be generated, but yeah, they work for any algebraic datatypes
09:13:34 <vincenz> Igloo: Is there a mu type?
09:13:37 <HairyDude> quicksilver: they seem not to be, though they've been there since ghc 5
09:13:39 <wli> Okay, how do I get the current :load in the prompt, but nothing else?
09:13:53 <Igloo> vincenz: I'm not familiar with the details
09:14:00 <vincenz> Igloo: I'll take a look, thanks for the pointer
09:14:54 <quicksilver> HairyDude: maybe there's a haddock bug about operators with : in their names or something :)
09:15:04 <HairyDude> heh, possibly
09:15:39 <Igloo> The onld generics stuff is hidden from haddock
09:15:45 <Igloo> s/onld/old/
09:16:23 <HairyDude> old?
09:16:26 <quicksilver> Igloo: is it no longer considered useful?
09:16:35 <quicksilver> Igloo: to be able to derive classes that way?
09:16:43 <hpaste>  kjdf pasted "(no title)" at http://hpaste.org/1654
09:16:46 <HairyDude> it would certainly be useful for what I'm trying to do
09:16:52 <quicksilver> maybe Derive and DrIFT and friends are seen as replacements?
09:17:01 <kjdf> quicksilver: could you take a look at what I pasted?
09:17:04 <vincenz> Igloo: It'd be nice to have all types defined in terms of these primitives with surface-level data-constructors, but also with access to the pure algebraic formulation
09:17:17 <Igloo> quicksilver: I'm not sure if it can do anything that the new Data.Generics stuff (SYB) can't
09:17:19 <scook0> wli: have you tried :set prompt?
09:18:23 <quicksilver> Igloo: oh, just writing class instances using the SYB stuff
09:18:28 <quicksilver> Igloo: I guess I wasn't thinking very clearly
09:18:37 <quicksilver> Igloo: the problem is, the new SYB stuff has such horrible names :)
09:18:38 <kjdf> I am looking for any way to make this kind of resumable list processors
09:18:53 <quicksilver> Igloo: and the old pattern-matching over :+: was much more superficially attractive
09:19:22 <quicksilver> kjdf: but listproc{1,2} already switch between themselves when they see a 0
09:19:31 <quicksilver> kjdf: I don't understand how onoff is supposed to help?
09:20:12 <kjdf> no, they don't switch, they only switch on 1
09:20:27 <kjdf> is it possibly without intruding too much into the inner function?
09:20:28 <Igloo> quicksilver: horrible names?
09:21:11 <kjdf> and onoff "turns them off" for a while and uses identity
09:21:15 <wli> scook0: I've done :set prompt, but there's no documentation on the format you use to get various things.
09:21:20 <kjdf> well
09:21:22 <kjdf> should,
09:21:34 <kjdf> as in the desired output below
09:21:46 <scook0> wli: the GHCi docs only mention %s and %%
09:21:58 <wli> scook0: Which ghci docs?
09:22:10 <scook0> wli: http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-commands.html
09:22:12 <lambdabot> Title: 3.6. GHCi commands, http://tinyurl.com/ytkpuj
09:22:43 <HairyDude> seems to me like using DrIFT requires learning a whole new directive language, while SYB is just a library
09:23:02 <wli> sc00k0: Thanks. Doesn't look like there's a way to only list the loaded files.
09:23:20 <quicksilver> Igloo: gmapQ, gmapMp, gfoldl
09:23:30 <quicksilver> Igloo: mkT.. I could go on :)
09:23:37 <Igloo> Fair enough
09:23:44 <quicksilver> HairyDude: SYB is actually a compiler extension :)
09:23:46 <Lemmih> Igloo: Available for some tech support?
09:23:54 <Igloo> Lemmih: What's up?
09:24:00 <Lemmih> Igloo: Shae and I are trying to build 'default'.
09:24:01 <quicksilver> HairyDude: although in principle you could derive the instances of Data yourself, and then it would be just a library. But that would be painful.
09:24:18 <HairyDude> quicksilver: well deriving support is, but it's more orthogonal for the programmer to use it than DrIFT
09:24:54 <quicksilver> HairyDude: I guess that's fair comment.
09:25:04 <quicksilver> HairyDude: Uniplate is just a library, and has IMO nicer syntax
09:25:10 <quicksilver> HairyDude: of course, it is strictly less powerful
09:25:19 <quicksilver> but it's nicer for its use-case
09:25:26 <quicksilver> IMO
09:25:37 <HairyDude> I really should get round to reading that blog post on Uniplate
09:25:51 <chylli> when I import FiniteMap, I got an error: 
09:25:51 <chylli>     Could not find module `FiniteMap':
09:25:51 <chylli>       it is a member of package ghc-6.6, which is hidden
09:25:51 <chylli> Failed, modules loaded: none.
09:26:03 <chylli> whats the problem ?
09:26:10 <mauke> why do you need FiniteMap?
09:26:16 <oerjan> chylli: FiniteMap has been replaced by Data.Map
09:26:25 <chylli> oh
09:26:26 <chylli> thanks
09:26:42 <chylli> because I'm reading yet another tutor
09:27:17 <mauke> ah
09:28:23 <quicksilver> damn
09:28:28 <quicksilver> bitrot in the tutorials ;(
09:28:50 <scook0> quicksilver: 'tis the price of progress
09:29:32 <matthew-_> mmm. I wonder how many tutorials will break when we get a heirarchy of number classes that don't suck
09:30:27 <scook0> matthew-_: hopefully you should be able to link against package haskell98 and have everything still work
09:30:31 <quicksilver> matthew-_: EVERY LAST ONE!
09:30:34 <scook0> though that doesn't fix the underlying problem
09:30:52 <quicksilver> matthew-_: in fact, even entirely unrelated C# and erlang tutorials will break! mwahahahah
09:31:13 <matthew-_> heh. Nah, there is the burgeoning industry of Monadic Tutorial Writers most of which never mention numbers
09:31:28 <scook0> quicksilver: that's what happens when you unsafePerformIO ;)
09:34:19 <glen_quagmire> is there an easy way to read/understand type?    apply f x = f x;   :t apply (t -> t1) -> t -> t1.    I tried to understand it as ((t -> t1) -> (t -> t1))
09:34:52 <glen_quagmire> i don't know how to read that type
09:34:55 <mauke> yeah, that's id where a = t -> t1
09:35:14 <mauke> given a function t -> t1, return a function t -> t1
09:35:50 <quicksilver> glen_quagmire: given a function, takes a function
09:35:53 <glen_quagmire> but apply takes 2 parameters
09:35:59 <mauke> not really
09:36:04 <quicksilver> glen_quagmire: read it like this then:
09:36:05 <mauke> all functions take exactly one argument
09:36:15 <quicksilver> given a function (t->t1), and a value t, produce a result t1
09:36:21 <dozer> :t curry zip
09:36:25 * shapr boings
09:36:27 <scook0> glen_quagmire: it's the "magic" of curried functions and partial application
09:36:28 <quicksilver> both readings are correct
09:36:29 <lambdabot>     Couldn't match expected type `(a, b)' against inferred type `[a1]'
09:36:30 <lambdabot>     Probable cause: `zip' is applied to too few arguments
09:36:50 <mauke> glen_quagmire: apply = \f -> \x -> f x
09:37:02 <Syzygy-> shapr: I was forced (kinda) to introduce Data.Map, and rewrite a few things based in fundamental misunderstandings of the relevant paper,but I'm pretty much done now.
09:37:03 <glen_quagmire> addThreeItems :: (Num a) => a -> (a -> (a -> a))    Given any Numeric a, return a function that takes a Num and returns a function that takes a Num that returns a Num
09:37:14 <glen_quagmire> I understand addThreeItems' type
09:37:15 <dozer> :t uncurry zip
09:37:17 <lambdabot> forall a b. ([a], [b]) -> [(a, b)]
09:37:42 <dozer> :t map (curry zip)
09:37:44 <lambdabot>     Couldn't match expected type `(a, b)' against inferred type `[a1]'
09:37:44 <lambdabot>     Probable cause: `zip' is applied to too few arguments
09:37:56 <mauke> you can't curry zip; don't try
09:37:57 <dozer> :t map (uncurry zip)
09:37:59 <lambdabot> forall a b. [([a], [b])] -> [[(a, b)]]
09:38:21 <dozer> no mauke, but my tired fingers don't seem to know that
09:39:11 <mauke> dozer: the correct response would have been "POTATO MEN"
09:40:09 <mauke> http://sixsixfive.com/323.html
09:40:10 <lambdabot> Title: Untitled Document
09:40:52 * HairyDude wishes Haskell had an explicit type fixpoint :)
09:41:03 <HairyDude> s/fixpoint/& operator/
09:41:27 <quicksilver> explicity & operator meaning what?
09:41:35 <nopcode> you only need fixpoint in fast code
09:41:38 <nopcode> ;)
09:41:40 <quicksilver> oh, explicit type fixpoint operator?
09:41:45 <shapr> Syzygy-: So the math guys didn't have any trouble with your Haskell section?
09:41:57 <oerjan> :t zip curry
09:41:59 <lambdabot>     Couldn't match expected type `[a]'
09:41:59 <lambdabot>            against inferred type `((a1, b) -> c) -> a1 -> b -> c'
09:42:12 <mauke> quicksilver: & expands to the text matched by the whole regex
09:42:14 <dozer> :t curry Map.insert
09:42:16 <lambdabot> Couldn't find qualified module.
09:42:16 <EvilTerran> HairyDude, that's a very odd regex format. did you perchance mean "\0" rather than "&"?
09:42:18 <Syzygy-> My advisor hasn't read it yet. Gonna prod him beginning .. well .. now.
09:42:28 <quicksilver> data NotList a b = Nil | Cons a b
09:42:29 <mauke> EvilTerran: who uses \0?
09:42:30 <EvilTerran> mauke, which regex system is this?
09:42:33 <dozer> :t curry Data.Map.insert
09:42:35 <lambdabot> forall a b a1. (Ord (a, b)) => a -> b -> a1 -> Data.Map.Map (a, b) a1 -> Data.Map.Map (a, b) a1
09:42:39 <HairyDude> EvilTerran: erm, & is perfectly normal
09:42:41 <quicksilver> data List a = TypeFix NotList a
09:42:46 <malsyned> Is there a way to make a list of objects which are in the same class, but not necessarily of the same type?
09:42:49 <EvilTerran> \0 is sed, i thought.
09:42:49 <quicksilver> HairyDude: like that?
09:42:51 <HairyDude> EvilTerran: POSIX afaik
09:42:58 <quicksilver> mauke: yes.
09:42:59 <dozer> malsyned: yes - you need a forall type
09:43:00 <mauke> EvilTerran: I know it from vim, so it's probably also in vi and ex
09:43:03 <EvilTerran> i may be mistaken.
09:43:24 <HairyDude> EvilTerran: pretty sure sed understands & as well
09:43:28 <dozer> :t [Integer i => i]
09:43:30 <malsyned> dozer: can you show me what one of them would look like?
09:43:30 <lambdabot> parse error on input `=>'
09:43:35 <mauke> malsyned: that's known as existential types
09:43:48 <EvilTerran> \1 .. \9 for submatches, \0 for the whole match, i thought... ah well, ignore me.
09:43:59 <HairyDude> [pwb@rhuidean haskell]$ echo foo bar baz | sed 's/bar/&&/'
09:43:59 <HairyDude> foo barbar baz
09:43:59 <HairyDude> [pwb@rhuidean haskell]$ 
09:45:14 <mauke> malsyned: http://haskell.org/haskellwiki/Existential_type
09:45:15 <lambdabot> Title: Existential type - HaskellWiki
09:46:28 <oerjan> dozer: :t take an expression, not a type
09:46:31 <shapr> YOW! I'm having an existential crisis!
09:46:33 <oerjan> *takes
09:46:44 <oerjan> @yow
09:46:45 <lambdabot> My mind is a potato field ...
09:46:53 <HairyDude> damn, newtype deriving doesn't work on recursive types
09:47:48 <HairyDude> and also won't make MPTCs
09:48:02 <HairyDude> (ok, so I don't know how it would, but...)
09:48:31 <malsyned> OK, so "[1 :: Float, 2 :: Double] :: (Floating a) => [a]" is an error.  What's the right way to write it?
09:48:47 <oerjan> HairyDude: i've seen newtype deriving MPTCs discussed as a problem somewhere
09:48:53 <mauke> malsyned: see above
09:49:04 <mauke> you need to make a new type that hides the differences
09:49:18 <oerjan> malsyned: first, you define an existential datatype for the elements
09:49:23 <HairyDude> :t [1 :: Float, 2 :: Double]
09:49:25 <lambdabot>     Couldn't match expected type `Float' against inferred type `Double'
09:49:25 <lambdabot>     In the expression: 2 :: Double
09:49:55 <HairyDude> :t [1 :: Float, 2 :: Double] :: [forall a. Floating a => a]
09:49:57 <lambdabot>     Couldn't match expected type `a' (a rigid variable)
09:49:57 <lambdabot>            against inferred type `Float'
09:50:01 <HairyDude> bah :)
09:50:07 <oerjan> data AnyFloating = forall a. Floating a => AF a
09:50:26 <mauke> :t [1, 2] :: [forall a. Floating a => a]
09:50:28 <lambdabot> [forall a. Floating a => a] :: [forall a. (Floating a) => a]
09:50:35 <mauke> that works but it means something different
09:50:37 <HairyDude> aah
09:50:40 <oerjan> HairyDude: that's a universal type, not existential
09:50:45 <mauke> now every list element must be fully polymorphic
09:51:03 <quicksilver> HairyDude: erm? newtypes can't be recursive?
09:51:26 <HairyDude> quicksilver: no, ghc's newtype deriving doesn't work on recursive newtypes
09:51:27 <oerjan> (now you can just do [AnyFloating])
09:51:39 <quicksilver> HairyDude: what's a recursive newtype?
09:52:30 <HairyDude> quicksilver: ok, so it's really corecursive
09:53:02 <HairyDude> the one I have is newtype Nat    = Nat { fromNat :: Unit :+: Nat }
09:54:03 <HairyDude> actually, that's not corecursive
09:54:27 <HairyDude> though it works as a terminal coalgebra
09:54:31 <oerjan> newtype Func = Func (Func -> Func)
09:54:45 <HairyDude> not that such a value would be useful
09:54:48 <mauke> hello, lambda
09:54:58 <oerjan> (untyped lambda calculus)
09:55:36 <mauke> call (Func f) = f
09:55:41 <HairyDude> oerjan: yeah, that's one as well
09:56:27 * rho is away: thinking
09:58:23 <oerjan> now if you derived Monad for that...
09:58:34 <oerjan> er...
09:58:35 <malsyned> is there a way to define a new datatype from the ghci prompt?  just starting a line with 'data' doesn't do it, and 'let data' doesn't work either.
09:58:47 <oerjan> (wrong kind)
09:58:57 <gattocarlo> It's just me or there's a lag when posting to haskell-cafe ?
09:58:57 <oerjan> malsyned: no
09:59:10 <oerjan> you need to load from a file
09:59:25 <quicksilver> HairyDude: weird. I didn't think that was possible.
09:59:40 <HairyDude> quicksilver: why wouldn't it be?
09:59:50 <quicksilver> dunno really
10:00:02 <quicksilver> I just assumed that since newtypes are really just 'new names' for old types
10:00:07 <quicksilver> that they couldn't be recursive
10:00:39 <HairyDude> quicksilver: nah, they're more an efficient algebraic data type that can only have one constructor and one field
10:00:51 * quicksilver nods
10:01:09 <sjanssen> quicksilver: I was surprised when I learned that too
10:01:19 <HairyDude> i.e. it goes from data to newtype rather than type to newtype :)
10:01:24 <sjanssen> newtype Huh = Huh Huh -- is a bit odd :)
10:01:29 <HairyDude> heh
10:01:57 <cdsmith> sjanssen: and can't have any values except _|_, right?
10:01:58 <HairyDude> sjanssen: that's one of those types that's only inhabited by _|_
10:02:02 <sjanssen> cdsmith: right
10:02:27 <mauke> wait, so fix Huh == undefined?
10:02:27 <oerjan> Huh Huh you said _|_
10:02:30 <glen_quagmire> is there a difference between t and a in types?
10:02:43 <glen_quagmire> t -> t1     vs.    a -> b
10:02:46 <sjanssen> glen_quagmire: no
10:02:46 * cdsmith wonders if it's an undecidable problem whether a type is inhabited by real values
10:02:50 <mauke> glen_quagmire: they're just variables
10:03:00 <glen_quagmire> thank you
10:03:02 <mauke> glen_quagmire: that's like asking about the difference between i and j in C :-)
10:03:16 <HairyDude> can you define a type with lambdabot?
10:03:30 <glen_quagmire> The "a" here in the type is like the "t" we saw in type classes, but without a constraint. 
10:03:41 <glen_quagmire> I was a little bit confused reading that in tutorial
10:03:43 <quicksilver> glen_quagmire: the inferrer gets 'hints' on what letter to use based on what letters you chose (or the Prelude chose) for the underlying stuff
10:03:46 <scook0> mauke: well, there is a precedent in Fortran...
10:03:53 <oerjan> HairyDude: i don't think so
10:03:55 <quicksilver> glen_quagmire: that's why they sometimes come out different
10:04:01 <quicksilver> glen_quagmire: it renames when it has to, of course
10:04:12 <glen_quagmire> i see
10:04:20 <quicksilver> :t mapAccumL
10:04:22 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
10:04:28 <oerjan> although you would think you could do something similar to @let, which just appends to a file iiuc
10:04:38 <quicksilver> that's an unusual example, in that the author chose a multiple-character type variable name
10:04:40 <ari> cdsmith: http://en.wikipedia.org/wiki/Curry-Howard_correspondence#The_type_inhabitation_problem maybe
10:04:41 <quicksilver> 'acc'
10:04:43 <lambdabot> http://tinyurl.com/yol7mf
10:04:44 <quicksilver> most of the time people don't
10:04:46 <HairyDude> @eval newtype Huh = Huh Huh
10:04:57 <mauke> @help eval
10:04:57 <lambdabot> eval. Do nothing (perversely)
10:05:01 <HairyDude> ah
10:05:15 <quicksilver> as long as it does it perversely!
10:05:21 <cdsmith> Oh, right.  Duh.  I clearly wasn't thinking.
10:05:26 <glen_quagmire> oh 
10:05:34 <cdsmith> ari: thanks
10:05:54 <glen_quagmire> cdsmith wrote lambdabot?
10:06:00 <cdsmith> no
10:06:12 <cdsmith> dons, I think
10:06:17 <HairyDude> @help define
10:06:18 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
10:06:23 <HairyDude> hm
10:06:48 <sjanssen> @let newtype Huh = Huh Huh -- this is the way to do it, but it is not allowed
10:06:48 <lambdabot> Invalid declaration
10:07:34 <cdsmith> glen_quagmire: correction, Andrew J. Bromage originally wrote lambdabot.  Don is it's current maintainer
10:08:29 <cdsmith> s/it's/its/
10:08:38 <scook0> and I'm sure the plugins have many different underlying authors
10:09:21 <glen_quagmire> i see
10:09:51 <glen_quagmire> ?hoogle mapAccumL
10:09:52 <lambdabot> List.mapAccumL :: (a -> b -> (a, c)) -> a -> [b] -> (a, [c])
10:09:52 <lambdabot> Data.List.mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
10:10:18 <gattocarlo> sorry if I repeat, but oviously I cannot test: is anyone experiencing lags when posting to haskell-cafe'?
10:11:48 <cdsmith> glen_quagmire: I did write a path to a couple plugins, though.  If you want to admire me, I have no problem basking in the glory. :)
10:11:55 <cdsmith> *patch
10:12:00 <arcatan> how do I put pixels with Haskell SDL binding from Hackage?
10:12:10 <HairyDude> looks like generics can't do MPTCs either
10:12:26 <glen_quagmire> :t [(+), (-)]
10:12:28 <lambdabot> forall a. (Num a) => [a -> a -> a]
10:13:09 <glen_quagmire> hrm but i can't evaluate [(+), (-)]
10:13:22 <mauke> you must be doing it wrong
10:13:23 <HairyDude> that is, with class Foo a b | a -> b you can't do instance Foo Something b and have it figure out what b should be
10:13:24 <glen_quagmire> a = [(+), (-)] goes through
10:13:53 <glen_quagmire> oh i think it just can't show it
10:14:01 <glen_quagmire> No instance for (Show (Integer -> Integer -> Integer))
10:14:01 <cdsmith> That would make sense
10:14:06 <mauke> yeah
10:14:14 <cdsmith> Yep.  It doesn't know how to print a function
10:14:39 <oerjan> HairyDude: http://haskell.org/haskellwiki/Safely_running_untrusted_Haskell_code lists "using newtype recursion to have the typechecker not terminate" as an exploit of lambdabot.  So allowing type declarations is not currently safe.
10:14:41 <lambdabot> Title: Safely running untrusted Haskell code - HaskellWiki, http://tinyurl.com/3alo2u
10:14:49 <HairyDude> oerjan: aah, right
10:15:11 * HairyDude decides to have a look at associated types
10:15:53 * shapr joins the Association of Types
10:16:00 <cdsmith> HairyDude: They're sorta cool, except associated type synonyms aren'
10:16:04 <cdsmith> tt implented
10:16:08 <cdsmith> bleh!
10:16:29 <HairyDude> not really a problem, I can make do with data/newtype I think
10:16:44 * cdsmith fires his typist again
10:17:20 <HairyDude> argh, this will involve compiling ghc :/
10:17:33 <cdsmith> HairyDude: Really?  I find them 100 times as interesting with type synonyms.
10:18:29 <HairyDude> cdsmith: why's that?
10:19:11 <cdsmith> HairyDude: It just seems that every time I try to think of a use, I turn out needing type synonyms for it.
10:19:13 <kaol> > let [a] = [(+), (-)] in a 1 2
10:19:15 <lambdabot>   Irrefutable pattern failed for pattern [a]
10:19:17 <HairyDude> actually newtype would be perfect - data just introduces unnecessary overhead
10:20:06 <oerjan> > do a <- [(+), (-)]; return (a 1 2)
10:20:08 <lambdabot>  [3,-1]
10:20:46 <mauke> hrhr, I'm sending data through a chain of 18000 threads
10:20:48 <mauke> haskell is fun :-)
10:21:15 <mauke> (also, slow (for some reason))
10:21:30 <oerjan> > [(+) (-)] `ap` [1] `ap` [2]
10:21:31 <lambdabot>   add an instance declaration for (Num (a -> a -> a))
10:21:32 <lambdabot>     In the expression: 1
10:21:41 <oerjan> > [(+), (-)] `ap` [1] `ap` [2]
10:21:43 <lambdabot>  [3,-1]
10:22:13 <Syzygy-> > [(+),(-)] `ap` [1]
10:22:15 <lambdabot>  [<Integer -> Integer>,<Integer -> Integer>]
10:23:09 <SamB> mauke: I heard that MVars are slow
10:23:17 <SamB> mauke: why are you using so many threads anyway?
10:23:42 <mauke> to see how many threads I can start before the program goes down
10:23:46 <SamB> ah.
10:24:14 <mauke> and as long as you don't use more than, say, 2000 threads/MVars, everything is fine :-)
10:24:29 * rho is back
10:25:56 <SamB> how are you doing, Ï?
10:28:06 <shapr> I'm FINE!
10:29:01 * HairyDude notes that the ghc wiki describing how to build ghc assumes you're using a unix-like OS
10:29:07 <HairyDude> (not that that affects me, since I am)
10:29:49 <HairyDude> sorry, the one that says how to get the sources
10:43:10 <arcatan> hmmmph, why my code sets wrong SDL video mode...
10:44:30 <arcatan> whoops, it's just a bug in my code
10:51:26 <dozer> > do { name <- ["matt", "kai"] ; greeting <- return $ "hello " ++ name ; altered <- return $ do { g <- greeting ; return $ Data.Char.toUpper g} }
10:51:26 <lambdabot>  Parse error
10:51:47 <dozer> > do { name <- ["matt", "kai"] ; return $ "hello " ++ name }
10:51:49 <lambdabot>  ["hello matt","hello kai"]
10:52:57 <dozer> do { name <- ["matt", "kai"] ; greeting <- return $ "hello " ++ name ; altered <- return (do { g <- greeting ; return $ Data.Char.toUpper g}) }
10:53:28 <dozer> > do { name <- ["matt", "kai"] ; greeting <- return $ "hello " ++ name ; altered <- return $ do { g <- greeting ; return $ Data.Char.toUpper g} ; return altered }
10:53:29 <lambdabot>  ["HELLO MATT","HELLO KAI"]
10:53:31 <shachaf> dozer: Instead of x <- return y, you can use let x = y.
10:54:35 <dozer> shachaf: assuming y doesn't do anything monadic
10:54:49 <quicksilver> dozer: it can't, if comes after 'return'
10:54:56 <dozer> dho!
10:55:22 <shachaf> > do { name <- ["matt", "kai"]; return (toUpper <$> "hello " ++ name) }
10:55:23 <lambdabot>  ["HELLO MATT","HELLO KAI"]
10:55:49 <arcatan> what's <$>
10:55:57 <shachaf> arcatan: It's just fmap.
10:56:05 <dozer> yeah, except I need something more of this form as I'm really trying to thread a statefull errorful evaluation in the list monad
10:56:08 <shachaf> arcatan: Another name, from Control.Applicative.
10:56:11 <glen_quagmire> ?Eq
10:56:11 <lambdabot> Maybe you meant: . bf faq ft id pl rc v wn
10:56:19 <arcatan> yeah
10:56:50 * shapr throws sticks at garbage collection
10:57:08 <arcatan> garbage collection eats them
10:57:10 <quicksilver> although, some would say, it's a better name
10:57:13 <arcatan> garbage collection looks hungry
10:57:25 <arcatan> oh wait, collection, not collector
10:57:43 <roconnor> > sin (1/10);
10:57:43 <lambdabot>  Parse error
10:57:45 <roconnor> > sin (1/10)
10:57:46 <lambdabot>  9.983341664682815e-2
10:58:14 <roconnor> sin 1
10:58:20 <roconnor> > sin 1
10:58:21 <lambdabot>  0.8414709848078965
10:58:37 <roconnor> > sin 10
10:58:39 <lambdabot>  -0.5440211108893698
10:59:17 <oerjan> > map (sin . (10^)) [-10..10]
10:59:18 <lambdabot>  Exception: Prelude.^: negative exponent
10:59:27 <oerjan> > map (sin . (10^^)) [-10..10]
10:59:28 <roconnor> yay my coq program to compute sine works!
10:59:28 <lambdabot>  [1.0e-10,1.0e-9,1.0e-8,9.999999999999982e-8,9.999999999998333e-7,9.999999999...
10:59:45 <roconnor> although checking the answer is a bit weird becuase I proved that it works.
10:59:58 <quicksilver>  :)
11:00:07 <oerjan> @quote knuth correct
11:00:07 <lambdabot> No quotes match. Listen, broccoli brains, I don't have time to listen to this trash.
11:00:14 <sjanssen> ha, now everybody is going to add "sorry for contributing to the noise" to their Haskell mailing list posts :)
11:00:52 <quicksilver> @remember knuth I have not tested this code, only proved it correct.
11:00:52 <lambdabot> Done.
11:01:32 <cdsmith> @quote proved
11:01:32 <lambdabot> greentea says: it's actually been proved that there a situations in which we can't know whether a person's stupidity will ever terminate.
11:01:42 <roconnor> quicksilver: when I ran my first version that was proved correct, it produced a stack overflow :)
11:01:44 <cdsmith> @quote proved it correct
11:01:44 <lambdabot> No quotes for this person. This mission is too important for me to allow you to jeopardize it.
11:01:53 <cdsmith> eh
11:02:00 <quicksilver> @quote knuth correct
11:02:00 <lambdabot> knuth says: I have not tested this code, only proved it correct.
11:02:08 <cdsmith> Ah, ok
11:02:08 <sjanssen> @quote proved.it.correct
11:02:08 <lambdabot> knuth says: I have not tested this code, only proved it correct.
11:02:14 <oerjan> quicksilver: it _would_ have been polite to actually quote him correctly.
11:02:25 <quicksilver> oerjan: apologies, you're welcome to correct it
11:02:43 <oerjan> i can only add a quote, not remove one
11:03:49 <glen_quagmire> ?hoogle [Char] -> [Char] -> Int
11:03:49 <lambdabot> No matches, try a more general search
11:04:12 <oerjan> @remember knuth Beware of bugs in the above code; I have only proved it correct, not tried it.
11:04:12 <lambdabot> Done.
11:04:12 <quicksilver> I don't have the original to hand, but I don't think I have misrepresented the spirit of the quotation 
11:04:38 <oerjan> (directly from http://www-cs-faculty.stanford.edu/~knuth/faq.html)
11:04:39 <glen_quagmire> I'm trying to implement countSubStr where countSubstr "abc" "abcabc"  evaluates to 2
11:04:39 <lambdabot> Title: Knuth: Frequently Asked Questions
11:06:42 <oerjan> > takeWhile (not . null) . iterate tail $ "abcabc"
11:06:47 <lambdabot>  ["abcabc","bcabc","cabc","abc","bc","c"]
11:07:08 <roconnor> > lasts "abcabc"
11:07:09 <lambdabot>   Not in scope: `lasts'
11:07:18 <roconnor> > tails "abcabc"
11:07:20 <lambdabot>  ["abcabc","bcabc","cabc","abc","bc","c",""]
11:07:31 <roconnor> > init . tails $ "abcabc"
11:07:32 <lambdabot>  ["abcabc","bcabc","cabc","abc","bc","c"]
11:07:37 <oerjan> > length . filter ("abc" `isPrefixOf`) . tails $ "abcabc"
11:07:39 <lambdabot>  2
11:07:53 <glen_quagmire> hah
11:09:19 <glen_quagmire> ?isPrefixOf
11:09:19 <lambdabot> Unknown command, try @list
11:09:25 <glen_quagmire> ?hoogle isPrefixOf
11:09:25 <lambdabot> List.isPrefixOf :: Eq a => [a] -> [a] -> Bool
11:09:53 <oerjan> @pl \s l -> length . filter (s `isPrefixOf`) . tails $ l
11:09:53 <lambdabot> (length .) . (. tails) . filter . isPrefixOf
11:10:25 <glen_quagmire> ?hoogle tails
11:10:26 <lambdabot> List.tails :: [a] -> [[a]]
11:10:26 <lambdabot> Text.PrettyPrint.HughesPJ.TextDetails :: data TextDetails
11:10:55 <shachaf> glen_quagmire: You can use @ty if you just want to find out the type of a specific function.
11:11:41 <glen_quagmire> > (\y -> (\x -> length . filter (x `List.isPrefixOf`) . List.tails $ y)) "abcabc" "abc"
11:11:42 <lambdabot>  2
11:11:54 <glen_quagmire> @ty tails
11:11:56 <lambdabot> forall a. [a] -> [[a]]
11:12:08 <glen_quagmire> no i wanted to see what packages it blonged coz it didn't compile
11:12:23 <shachaf> glen_quagmire: Oh.
11:12:26 <shachaf> @index isPrefixOf
11:12:26 <lambdabot> Data.List
11:12:56 <shachaf> I guess it doesn't matter, but @hoogle sometimes gives too many (irrelevant) answers.
11:13:54 <crazy_coder> hello everyone
11:14:32 <crazy_coder> Finally I have started to understand monads, and the real power of haskell :)
11:15:00 <glen_quagmire> hrm List.tails and Data.List.tails both work
11:15:04 <matthew-_> so I hope everyone's detoxing from coffee this week so that it's really effective next weekend for the icfp prog comp.
11:15:30 <Vulpyne> I have a relatively simple program that uses the pcap library to log packets and then spit them out to a DB. It's been dying mysteriously though: http://hpaste.org/1656
11:15:46 <Vulpyne> The weird thing is, it only prints part of the error message before it exits, apparently with no error like a core dump.
11:15:47 <oerjan> glen_quagmire: List is the old name of the module from Haskell 98
11:15:59 <glen_quagmire> oh i see thanks
11:16:03 <oerjan> i think Data.Lists includes some more functions
11:16:04 <Vulpyne> Anyone have an idea of what could cause something like that?
11:16:09 <oerjan> *Data.List
11:16:42 <oerjan> (the new-style modules often do)
11:16:44 <Vulpyne> Oh, and the last output always ends with a backslash.
11:17:05 * shachaf wonders why people say "understand monads".
11:17:18 <CosmicRay> gtk2hs is so awesome.
11:17:20 <oerjan> shachaf: hubris?
11:17:24 <shachaf> I think the problem is not so much with the general concept of a monad as it is with the uses of specific ones.
11:17:26 <CosmicRay> haskell has got to be the best language for doing gtk 
11:17:47 <matthew-_> CosmicRay I rather like doing opengl in haskell ;)
11:17:57 <crazy_coder> glade helps a lot....
11:18:08 <CosmicRay> crazy_coder: yeah
11:18:18 <CosmicRay> matthew-_: heh, I haven't had the need
11:18:18 <tuukkah> can you define your own gtk objects in haskell?
11:19:08 <CosmicRay> tuukkah: I dunno, haven't had the need for that either
11:19:17 <CosmicRay> I'm new to gtk, too.  learning it as I go along.
11:19:44 <tuukkah> i'm just saying gtk might be better suited for pygtk
11:19:59 <tuukkah> haskell would need something more... functional
11:20:37 <jfoutz> haskell hoc his pretty nice to on the mac.
11:20:41 <shachaf> tuukkah: He didn't say GTK was the best graphics toolkit for Haskell, he said that Haskell is the best language for using GTK. :-)
11:21:02 <jfoutz> and, you can define your own objective-c objects in haskell.
11:21:06 <Vulpyne> Does anyone have an idea regarding my question?
11:21:44 <tuukkah> or gtk2hs is good for most apps but in haskell i'd expect a library that is good for any app no matter how advanced
11:22:54 <jfoutz> Vulpyne: my wild guess is, the log is getting ready to show a value that requires calling into the SQL binding, i'd guess the binding is not handling some error condition and segfaulting... but that's just a guess.
11:23:26 <Vulpyne> jfoutz: Hmm, but it didn't segfault.
11:23:37 <tuukkah> Vulpyne, you can try to run your app under strace and ltrace for some hints
11:23:53 <jfoutz> Vulpyne: could there be an exit() in the code?
11:24:17 <Vulpyne> jfoutz: Nope. It loops forever.
11:24:29 <Vulpyne> It generally runs for a day or so before it dies, also.
11:24:39 <Vulpyne> The string it was printing out was the text of the SQL statement it tried to execute.
11:24:48 <Vulpyne> And it only prints out about half of that and then exits. 
11:25:39 <oerjan> Vulpyne: perhaps the remaining part somehow throws a new error when it's evaluated?
11:25:43 <Vulpyne> I tried reversing the order of some of the debug stuff it prints in the error, but I can't understand how it dies in the middle of displaying the string.
11:25:51 <tuukkah> Vulpyne, what do you get for return code?
11:26:12 <Vulpyne> tuuk: Ah, I forgot to check that, but I will have to next time. Thanks.
11:26:27 <Vulpyne> oerjan: Wouldn't that result in some output, or would it just exit with no message?
11:26:51 <oerjan> i don't know.
11:26:57 <oerjan> just guessing :)
11:27:08 <tuukkah> Vulpyne, do you have an idea what should come next in the printout?
11:27:11 <Excedrin> Vulpyne: is there anything in the system log?
11:27:18 <tuukkah> '>'?
11:27:20 <etnt> is it possible to extract some sort of intermediate representation from ghc ?
11:27:54 <bos> has anyone posted to a blog about anglohaskell yet?
11:27:57 <jfoutz> i think the "s" string could be concated from earlier values so you get up to the "\" part of the string, then the concat needs to be evaluated.
11:28:18 <Vulpyne> Excedrin: Nothing interesting in the system log.
11:28:21 <jfoutz> and the tail of the concat dies somehow.
11:28:35 <Vulpyne> tuukkah: Well, it was printing out an INSERT, so there should have been at least a closing quote and parenthesis.
11:29:07 <Vulpyne> jfoutz: Hmm, that could be.
11:29:50 <tuukkah> Vulpyne, there's a closing quote already on the first line of s?
11:30:43 <Vulpyne> tuukkah: I'm not sure what you mean? there's an opening quote, but after the SIP backet body there should be at least a ')
11:31:24 <Vulpyne> The \ makes it seem like there was a value it wanted to escape, but then it died.
11:32:11 <oerjan> > error "test"
11:32:13 <lambdabot>  Exception: test
11:32:35 <oerjan> > error $ "test" ++ error "ing"
11:32:36 <lambdabot>  Exception
11:33:25 <tuukkah> Vulpyne, sorry, i didn't notice the line was longer than fit on screen
11:33:47 <Vulpyne> Oh, no problem.
11:33:50 <tuukkah> Vulpyne, but does it make sense in your app to have something there that should be escaped?
11:33:56 <fasta> Why is the order of arguments of modifySTRef as it is?
11:34:07 <fasta> It seems nobody thought about it?
11:34:17 <oerjan> :t modifySTRef
11:34:19 <lambdabot> Not in scope: `modifySTRef'
11:34:25 <sjanssen> @type Data.STRef.modifySTRef
11:34:26 <lambdabot> forall s a. GHC.STRef.STRef s a -> (a -> a) -> GHC.ST.ST s ()
11:34:34 <sjanssen> @type Data.IORef.modifyIORef
11:34:36 <lambdabot> forall a. GHC.IOBase.IORef a -> (a -> a) -> IO ()
11:34:48 <oerjan> @type modify
11:34:49 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
11:34:56 <fasta> If it would have reversed arguments one wouldn't need to use flip all the time. 
11:35:18 <fasta> (sure, one can define a "myModifySTRef", but that's besides the point)
11:35:40 <cdsmith> Hmm.  In HList, haddock dies on "type e :*: l = HCons e l"  Anyone know a work-around.
11:36:10 <fasta> cdsmith: huh
11:36:17 <fasta> cdsmith: is that valid HaskelL?
11:36:23 <fasta> cdsmith: Haskell*
11:36:35 <cdsmith> Yeah.  :*: is a good type name
11:36:37 <sjanssen> cdsmith: haddock's parser doesn't cover much beyond Haskell '98
11:36:45 <fasta> cdsmith: since when?
11:36:55 <sjanssen> cdsmith: correction, it is valid -fglasgow-exts Haskell
11:36:58 <cdsmith> fasta: looking it up...
11:37:29 <cdsmith> Oh.  So I should stop trying to build haddock, then?
11:37:50 <cdsmith> err, use haddock, I mean
11:37:59 <sjanssen> cdsmith: you might look into haddock.ghc
11:38:10 <fasta> cdsmith: maybe there is a flag that does non-Haskell 98
11:38:46 <cdsmith> Hmm.  Maybe I should just change my shell script to let my flag packages not to build haddock for.  That sounds easier.
11:38:58 <dolio> @where haddock.ghc
11:38:58 <lambdabot> I know nothing about haddock.ghc.
11:39:02 <Vulpyne> tuukkah: Sorry for the slow response. Since it's logging SIP packets, there's a fairly decent chance there will be characters that need to be escaped.
11:39:07 <fasta> cdsmith: GHC has documentation
11:39:08 <dolio> @where+ haddock.ghc http://darcs.haskell.org/SoC/haddock.ghc/
11:39:09 <lambdabot> Done.
11:39:14 <Vulpyne> It would be a really bad security hole not to escape them.
11:39:26 <fasta> cdsmith: so, one would expect your software can work too. 
11:39:30 <Vulpyne> But I don't think it's the escaping that could fail that way, the escape function is really simple.
11:40:30 <cdsmith> dolio, sjanssen: Is haddock.ghc relatively stable, do you know?  If it's SoC then it would be pretty new.
11:40:43 <sjanssen> cdsmith: it is SoC from last year
11:40:51 <cdsmith> Oh!  Okay, cool.
11:40:53 <dozer> mm - I'm a bit stuck now
11:41:03 <sjanssen> cdsmith: it may still be quite rough, I've never tried it
11:41:22 <cdsmith> Well, I'll find out then.
11:41:35 <fasta> Still contains lots of bugs (reading the TODO)
11:41:41 <dozer> I have a function in State s a, and within that function drop into StateT s [] b
11:42:03 <dozer> but within the StateT s [] b do-block, I can't use the getFoo state functions defined on State s a
11:42:23 <dolio> cdsmith: It compiles for me, but I haven't gotten to trying it yet.
11:42:32 <dolio> cdsmith: It requires HEAD ghc, though.
11:42:46 <cdsmith> dolio: No problem.  I've got HEAD.
11:43:11 <shachaf> dozer: What do the functions look like? Do they use the a at all?
11:43:14 <sjanssen> dozer: why are you functions defined on 'State s a' instead of 'MonadState m s => m s a'?
11:43:29 <shachaf> @instances MonadState
11:43:30 <lambdabot> s (ContT r m), s (ErrorT e m), s (RWS r w s), s (RWST r w s m), s (ReaderT r m), s (State s), s (StateT s m), s (WriterT w m)
11:43:44 <dozer> sjanssen: Ah - I will try that instead
11:44:10 <dozer> sjanssen: I should MonadState everywhere, or in the getters only?
11:44:30 <sjanssen> dozer: it's your call
11:44:46 <sjanssen> MonadState will allow for better re-usability
11:44:49 <oerjan> Vulpyne: i had an idea.  Change your code to use a seq to force the error message before passing it to fail.
11:44:57 <dozer> probably because the docs here didn't say anything useful: http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-State.html#t%3AMonadState
11:44:59 <lambdabot> http://tinyurl.com/yy4aqu
11:45:23 <oerjan> that way, you should see the actual error causing the abort, i hope.
11:45:52 <oerjan> (force the entire message, e.g. using length)
11:46:01 <cdsmith> Ah, dang.  Now runhaskell Setup haddock fails with a usage message.
11:49:15 <fasta> sjanssen: what do you think about the modify* issue?
11:50:05 <sjanssen> fasta: (flip modifySTRef) seems better to me
11:50:15 <sjanssen> it might be too late to change, though :(
11:50:38 <fasta> sjanssen: that's what I thought. 
11:50:45 <fasta> sjanssen: I don't think it's too late to change.
11:50:59 <fasta> sjanssen: it just requires a source code transform tool. 
11:51:05 <sjanssen> fasta: it will break every piece of code that uses modifySTRef
11:51:06 <dolio> Just change it whenever someone builds the typeclass for generic refs. :)
11:51:21 <sjanssen> dolio has a good idea
11:51:29 <fasta> There's already a RefMonad
11:51:30 <sjanssen> kill two birds with one stone!
11:51:41 <fasta> I don't know how that works, by heart, though.
11:51:44 <sjanssen> fasta: from Bulat's ArrayRef lib?
11:51:53 <fasta> sjanssen: no, from some lame article. 
11:52:00 <fasta> sjanssen: a "functional pearl"
11:52:14 <fasta> sjanssen: totally not worth that name
11:52:27 <dolio> I thought there was some problem with making the typeclass, but I can't remember what it is.
11:52:40 <fasta> dolio: GHC extensions, IIRC.
11:52:50 <fasta> dolio: it's not Haskell 98. 
11:52:55 <dolio> Well, that's true.
11:52:56 <sjanssen> dolio: you need fundeps
11:53:03 <dolio> ST isn't Haskell 98, either.
11:53:07 <sjanssen> but ATs make it much nicer
11:53:59 <sjanssen> class MonadRef m where type Ref m; readRef :: Ref m a -> m a; ...
11:54:21 * shapr throws redexs at lambdabot
11:54:26 <shapr> redices?
11:54:50 <dolio> redexen?
11:55:43 <fasta> Next candidate....
11:55:57 <ibid> redexes i'd say
11:56:04 <fasta> Bingo
11:56:06 <dolio> Apparently AT synonyms are done now, too, which is good news.
11:56:16 * shapr cheers furiously
11:57:01 <ibid> why does that make me think of "green ideas sleep furiously"? (and i'm missing one word in that)
11:57:50 <pjd> ibid: s/^/colorless /
11:58:03 <ibid> thanks
11:58:04 <glguy> 5colorless?
11:58:05 <glguy> :)
12:00:37 <dozer> http://www.haskell.org/hawiki/MonadState seems to have the MonadState type parameters one way arround in the PossibleImplementation and the other way in the NestedMonad example
12:00:37 <lambdabot> Title: MonadState - The Haskell Wiki
12:04:04 <shachaf> dozer: :i MonadState -- in GHCi?
12:07:06 <allbery_b> well, that was ... ineffective
12:07:38 <cdsmith> Has anyone got haddock.ghc to work with Cabal?  If not, I really don't want to spend all day being the first one to blaze this trail.
12:11:26 <waern> cdsmith: It needs special support.. I once created a patch for that but it was never applied and now it's too old
12:11:43 <waern> cdsmith: I'll probably submit a new one some day :)
12:12:22 <cdsmith> waern: okay.  Any tips on where to start.  I found the place in Distribution/Simple.hs where the arguments are passed.  Do I just need to change that?
12:13:27 <waern> Well... there's a bit more to it
12:13:51 <cdsmith> More than it's reasonable for me to do?
12:14:05 <waern> my patch checked if the haddock version is >= 2.0 and then went with this code path
12:14:36 <waern> you also have to pass all the ghc compilation arguments to haddock 2.0 
12:14:55 <cdsmith> But the haddockVersion var comes from haddock --version, which still reports 0.8 for me.
12:15:08 <cdsmith> Oh, okay.  That does seema  little more involved, then.
12:15:29 <cdsmith> Maybe not.  I wish I knew more about cabal.
12:15:55 <waern> it's not *that* complicated. if you want to do it, I can send you my patch
12:16:08 <cdsmith> Yes, please do.  I will take a crack at it.
12:16:22 <waern> hm, haddockVersion should report 2.0 if you've installed haddock.ghc
12:16:32 <titusg> I remember the question on haskell-cafe but I don't remember the answer...are SPJs talks at OSCON going to available on video?
12:16:40 <cdsmith> I haven't checked; just read the code... so maybe I'm wrong.
12:16:52 <waern> cdsmith: email?
12:17:00 <cdsmith> cdsmith@twu.net
12:17:06 <waern> thanks
12:17:12 <cdsmith> thank you.
12:21:29 <titusg> they sound like really interesting talks, especially the tutorial on xmonad
12:23:17 <waern> cdsmith: sent
12:23:27 <cdsmith> waern: very much appreciated.
12:28:21 <pejo> Does anyone happen to sit on any references on "most specific generalization" between two terms? It's known from term algebra. 
12:30:01 <waern> cdsmith: I should tell you that currently haddock doesn't work due to GHC API changes
12:30:09 <waern> cdsmith: but I'm working on it
12:30:52 <cdsmith> waern: Awww.  Well, thanks for letting me know.
12:33:11 <Heffalump> pejo: look up work by Adam Bakewell from FLOPS 1998
12:33:41 <Heffalump> also, I think Igloo's PhD thesis had to deal with a problem like that
12:34:00 <shapr> Yay code!
12:34:40 <Igloo> pejo: "Least general antiunification" might be what you want
12:36:45 <pejo> Igloo, ah, get stuff by Leuschel then. Seems reasonable, thanks. 
12:36:51 <pejo> Heffalump, with Runciman?
12:37:25 <Heffalump> pejo: yes
12:37:36 <shapr> Has Runciman always been a bodybuilder? He's one of the few FPers I'd be terrified to meet in a dark alley.
12:37:39 <pejo> Heffalump, thanks. 
12:37:49 <shapr> Well, ChilliX too
12:38:11 <shapr> Oh, and ndm does lots of judo..
12:38:17 <shapr> FPers are scarier than I thought...
12:39:01 <shapr> I could fall on someone while riding my unicycle and squish them... but that's not so dangerous.
12:42:19 <dr_strangelove> h <- connectPop3 "my.mail.server"     fails with: ***Exception: Data.ByteString.last: empty ByteString
12:42:25 <dr_strangelove> any ideas?
12:44:37 <Saizan> ugh, ugly, from which package?
12:45:29 <dr_strangelove> Saizan, HaskellNet.POP3
12:45:54 <dr_strangelove> how can I print the stack trace?
12:46:50 <Saizan> compile with -prof -auto-all and run with +RTS -xc
12:47:15 <dr_strangelove> hm I didn't compile HaskellNet with profiling support ..
12:47:59 <Saizan> doesn't cabal add profile support by default?
12:48:22 <shachaf> Saizan: I don't think so.
12:48:41 <shachaf> Saizan: You have to runhaskell Setup configure -p, I think.
12:49:27 <Saizan> shachaf: yeah, you're right
12:51:49 <fasta> What is a .pptx file? 
12:52:04 <fasta> http://www.cs.kuleuven.be/~toms/Research/talks/Tyfuns.pptx
12:52:13 <fasta> More importantly: how can I open it?
12:54:01 <Saizan> it's a renamed ppt?
12:54:27 <pejo> It's a zipfile with a bunch of xml-files in it. 
12:55:35 <fasta> pejo: I need Office2007 to see it?
12:55:47 <fasta> i.e. not on Linux?
12:56:29 <pejo> fasta, http://support.microsoft.com/kb/924074 has updates for previous versions of powerpoint. 
12:57:32 <fasta> pejo: thanks, but I am not _that_ interested. People should just distribute in open formats. 
12:57:35 <pejo> What an annoying thing. I have no idea, sorry.
12:58:19 <pejo> fasta, it's not available in the google and "view as html" by chance?
12:58:55 <fasta> pejo: I didn't try, but I am fairly unforgiving in this area.
12:59:20 <fasta> pejo: I am willing to ask on an IRC channel about the format, but that's as far as I go. 
13:00:24 <fasta> Since I'd expect a substantial part of the Haskell community also uses *nix based systems, I'd expect that the information in those slides will become available in a different format.
13:00:41 <cytzol> Setup.hs: cannot satisfy dependency arrows-any
13:00:51 <cytzol> I thought ghc always has arrows?
13:01:08 <fasta> cytzol: libraries split-up?
13:01:24 <SamB> cytzol: some genius(es) decided to unbundle many of the packages
13:01:31 <cytzol> gah
13:01:40 <SamB> fasta: isn't that where you break up base into little tiny pieces?
13:02:10 <fasta> SamB: right, I also don't think it was a very smart move. 
13:02:19 <cytzol> I have various files with "Arrow" in their name that I don't know what they do
13:02:30 <fasta> SamB: a bit too early, I guess. 
13:02:44 <dr_strangelove> ok, the "stack trace": <HaskellNet.POP3.strip,HaskellNet.POP3.response,HaskellNet.POP3.connectStream,HaskellNet.POP3.connectPop3Port,HaskellNet.POP3.connectPop3,HaskellNet.POP3.CAF>pop3: Data.ByteString.last: empty ByteString
13:02:45 <shachaf> cytzol: What are you building? Lambdabot, maybe?
13:02:50 <cytzol> yup
13:02:56 <fasta> Well, _I_ don't have a problem with it anymore. 
13:02:59 <dr_strangelove> is the error in the fist or the last function?
13:03:08 <shachaf> cytzol: I just took the dependency out of the .cabal and it worked.
13:03:09 <SamB> well maybe they were trying to light a fire under those who's job it is to *get* ready?
13:03:11 <fasta> But if you are on Windows, I can expect you might find some problems.
13:03:13 <jfoutz`> fasta: if it makes you feel better, i've got the latest powerpoint, and it dosn't work for me either. 
13:03:30 <fasta> jfoutz`: heh
13:04:07 <cytzol> shachaf: that seems to work, thanks. how odd.
13:04:32 <Saizan> ?hackage arrows
13:04:32 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/arrows
13:04:43 <Saizan> ^^ if you want the arrows package
13:09:48 <fasta> SamB: tons of complaining users might help, yes. 
13:10:05 <fasta> SamB: if we can forward such questions to that entity :)
13:10:36 <SamB> I think portions of that entity (a) reside here and (b) don't much enjoy things as they are either ;-)
13:16:02 <cdsmith> @where hs-plugins
13:16:03 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
13:19:52 <cdsmith> No darcs for hs-plugins?
13:20:33 <cdsmith> never mind; found it
13:22:59 <fasta> <interactive>: exception :: GhcException <- WTH?
13:25:26 <cytzol> you broke i!
13:25:27 <cytzol> it
13:27:24 <dmead> oh oh oh it's maaaagiiccc
13:27:27 <dmead> you knowwwowowowowwwwwwwwwww
13:30:06 <nominolo> :t exception
13:30:09 <lambdabot> Not in scope: `exception'
13:30:40 <nominolo> :t error
13:30:42 <lambdabot> forall a. [Char] -> a
13:35:23 <fasta> cytzol: I know, I tend to have that affect on systems.
13:37:23 <fasta> er effect
13:41:03 <fasta> Hmm, logically, the universe should be exploding.
13:41:29 <fasta> ... until I find out why the universe is right :)
13:41:42 <nominolo> it's not right
13:41:49 <nominolo> it's one of many
13:42:00 <nominolo> we just happen to live in that one
13:42:08 <cytzol> there has to be something fundamentally wrong with it.
13:42:18 <fxr> nominolo: which one?
13:42:26 <Excedrin> who was it who said that logging is fundamentally flawed the other day?
13:42:36 <nominolo> the one in the middle
13:43:02 <nominolo> and all others are circling around us
13:43:08 <nominolo> no, wait ...
13:43:16 <fxr> nominolo: thus the universe is divisible?
13:43:28 <nominolo> why?
13:43:51 <fxr> nominolo: if there is a middle of universes, it should be divisible by 2
13:44:26 <nominolo> well i guess so.  so the number of universes cannot be a prime
13:44:46 <nominolo> though, i guess it's a vector space anyways
13:45:13 <fxr> nominolo: ... if there is a middle of all universes.
13:45:36 <nominolo> well, you asked, so i came up with an approximate number
13:45:54 <nominolo> er -number
13:46:29 <nik7> helllo
13:46:41 <nominolo> @yow
13:46:41 <lambdabot> I know things about TROY DONAHUE that can't even be PRINTED!!
13:46:48 <nominolo> @yarr
13:46:48 <lambdabot> Har de har har!
13:46:52 <HairyDude> hm, my new ghci (HEAD from yesterday) doesn't do the ascii art "GHCi" thing at the top
13:46:52 <nik7> how to test wheter 5 / 2 is a integer or a float?
13:47:02 <nominolo> :t 5 = 2
13:47:04 <lambdabot> parse error on input `='
13:47:08 <nominolo> :t 5 / 2
13:47:09 <lambdabot> forall t. (Fractional t) => t
13:47:17 <fxr> nominolo: maybe the universe is some kind of hypermachine
13:47:27 <nominolo> @instances Fractional
13:47:29 <lambdabot> Double, Float
13:47:42 <nominolo> nik7: it's a float
13:47:55 <nominolo> use div if you want integer
13:48:01 <nominolo> > 5 `div` 2
13:48:03 <lambdabot>  2
13:48:29 <nik7> nominolo, well, I need '/' because then I have to decide what the next step...it depends wheter it's an integer, or a float..
13:48:36 <nominolo> fxr: hypermachine?
13:48:43 <fasta> nik7: you miss a point
13:49:08 <nominolo> nik7: ah so you want to know if there was a remainder?
13:49:08 <fxr> nominolo: a turing machine with some states and an oracle
13:49:12 <fasta> nik7: a value has only _one_ type. 
13:49:30 <fasta> nik7: so, your question had zero meaning to begin with. 
13:49:54 <nik7> hm...I need something like that: if is_integer(5/2) then foo else bar
13:50:00 <nominolo> fxr: nah, i don't believe in knowing the furure.  too many paradoxes
13:50:11 <fasta> nik7: no, you don't need something like that.
13:50:22 <fxr> @where+ hypercomputation http://de.arxiv.org/abs/math.LO/0209332
13:50:22 <lambdabot> Done.
13:50:29 <cytzol> nik7: Do you mean specifically 5 and 2 or any numbers?
13:50:32 <nominolo> > 5 `rem` 2
13:50:34 <lambdabot>  1
13:50:39 <lightstep> @type mod
13:50:39 <nik7> any numbers
13:50:44 <fasta> fxr: does that contain anything that's beyond pure theory?
13:50:52 <lambdabot> forall a. (Integral a) => a -> a -> a
13:50:55 <cytzol> oh.
13:51:05 <fasta> fxr: I know some theory about hypercomputation, but I know of zero evidence that it exists.
13:51:15 <nominolo> nik7: if 5 `rem` 2 /= 0 then ...
13:51:17 <fasta> fxr: most "evidence" is hand-waving.
13:51:59 <nominolo> dpiponi: wave please
13:52:05 * dpiponi waves
13:52:09 <nik7> ah thanks...
13:52:11 <nominolo> thank you!
13:52:27 * dpiponi looks around confused
13:52:36 <therp> woot, I approximately understand the monadic fix-point operator mfix. 
13:52:39 <nominolo> you just provided evidence that hypercomputation exists
13:52:50 <fxr> fasta: well you're right, but it's a very nice paper.
13:53:05 <glguy> mfix is a wonderful abstraction
13:53:09 <glguy> or at least
13:53:10 <HairyDude> cdsmith: ah, I see what you mean about associated type synonyms
13:53:11 <glguy> it enables them
13:53:20 <fasta> glguy: right
13:53:23 <nominolo> dpiponi: don't have to understand ;)
13:53:29 <fasta> glguy: mdo helps a lot, though.
13:53:57 <dpiponi> Tell me I don't have to understand something doesn't work very well :-)
13:54:10 <dpiponi> s/Tell/Telling/
13:54:21 <nominolo> 22:50 <     fasta> fxr: most "evidence" is hand-waving.
13:54:25 <glguy> fasta: I tend to use mdo instead of mfix, but since mdo is just sugar, I give mfix the credit :)
13:54:41 <nominolo> and: 22:50 <     fasta> fxr: I know some theory about hypercomputation, but I know of zero  evidence that it exists.
13:55:06 <therp> I would be unqualified to code the monadic fix-point operator (at least I feel like ATM), but I was surprised that I can use it.. I actually canceled my date to work on that.
13:55:31 * fasta wonders whether actual evidence would show up on the news...
13:58:08 * HairyDude wishes he had left himself time to do the code for his dissertation using associated types instead of manual instances.
13:58:32 <HairyDude> the code looks almost identical to the specification
13:58:48 <Heffalump> you're happy to use 6.7 then?
13:59:30 <HairyDude> no reason why not, just so long as I mention the fact it's not really standard
14:00:00 <glguy> 6.8 is coming up fast
14:00:17 <Heffalump> what is the dissertation for?
14:00:30 <Heffalump> it is indeed (yay)
14:00:37 <Heffalump> it looks like it'll be really nice
14:01:59 <HairyDude> Heffalump: BSc (undergrad)
14:02:25 <HairyDude> Heffalump: long since handed in and marked. I graduate next week
14:03:10 <Excedrin> dons: this web server is pretty neat
14:04:29 <Heffalump> ah, right
14:07:02 <jfoutz`> web server?
14:08:17 <Excedrin> http://www.seas.upenn.edu/~lipeng/homepage/unify.html
14:08:18 <lambdabot> Title: Unifying events and threads
14:10:01 <jfoutz`> wow. 
14:11:48 <fxr> Excedrin: isn't it too fast :)
14:12:57 <Excedrin> yes, I think it is... obviously we can't use this
14:13:56 <fxr> Excedrin: why?
14:15:12 <Excedrin> well, by "we" I meant "the company I work for"... it's because we're stuck in the 1980s technology wise
14:15:43 <jfoutz`> sooo, smalltalk and lisp?
14:15:58 <Excedrin> that's way too high-tech
14:18:42 <EvilTerran> cobol?
14:19:00 <Excedrin> this is a fun game :)
14:19:36 <EvilTerran> ooh, i know! punch cards!
14:20:27 <EvilTerran> no, don't tell me, that's still too modern. you just told Ada Lovelace what to do, amirite?
14:20:33 <Excedrin> thousands of telephones and operators madly hammering away entering orders while a dot matrix printer churns thru reams and reams of paper
14:24:22 <HairyDude> hmm, why aren't there Show instances for Unit, :+: and :*: ?
14:25:09 <MarcWebe1> What does the I# mean in alex generated source? # means try to put this var into registers directly or something like that.. But when using ghci I can't do a :t I#
14:25:15 <Shimei> http://programming.reddit.com/info/262d3/comments/c265v8 <-- This is an interesting point. I wonder how psychologically appealing Haskell is syntactically.
14:25:16 <lambdabot> Title: Ask Reddit: Why no love for Tcl? (reddit.com)
14:25:44 <bos> MarcWebe1: it's an unboxed integer.
14:25:56 <bos> well, it's actually the box for an unboxed integer.
14:26:34 <MarcWebe1> Why does'nt ghci know about it?
14:26:50 <bos> because ghci can't use unboxed values directly.
14:27:16 <MarcWebe1> Oh. It does'nt know about Int either?
14:27:38 <bos> Int is boxed.
14:28:20 <sjanssen> MarcWebe1: use -fglasgow-exts
14:28:33 <sjanssen> MarcWebe1: you'll also need to load GHC.Prim
14:29:02 <bos> interactively, you can :set -fglasgow-exts
14:29:50 <matthew-_> yay, so maintaining the community has become SMTP vs NNTP. Interesting.
14:29:57 <sjanssen> actually, the module is GHC.Base
14:29:57 <Igloo> Use GHC.Exts, not GHC.Prim
14:30:17 <sjanssen> matthew-_: yeah, doesn't everyone know you can use both?
14:30:24 <SamB> matthew-_: what?
14:30:35 <MarcWebe1> Its really funny. I've been working with ghci over a year and I haven't noticed the result of :t String till now
14:30:39 <SamB> matthew-_: gmane is not against the use of SMTP
14:30:44 <SamB> in fact, gmane *uses* SMTP
14:30:55 <sjanssen> SamB: see the recent thread on haskell-cafe
14:31:16 * SamB goes to gmane.comp.lang.haskell.cafe
14:32:19 <sjanssen> SamB: it turned into the annual "We should be using mailing lists/forums/newsgroups instead!" argument
14:32:29 <MarcWebe1> sjanssen: Is there any reason why you can't use two modules?
14:32:49 <sjanssen> MarcWebe1: I don't follow
14:33:06 <sjanssen> MarcWebe1: I thought I# was defined in GHC.Prim, but it's actually in GHC.Base
14:33:20 <MarcWebe1> sjanssen: Sorry. I have used the wrong context
14:34:01 <etnt> I tried to post to the cafe-list via gmane, the post never showed up
14:35:13 <etnt> anyone knows if it should be possible to post to that mailing list via gmane ?
14:35:25 <matthew-_> yeah, it's meant to be a two-way gateway
14:35:48 <etnt> it was the first post from me and I didn't get the verification mail from gmane as is usual
14:36:39 <JohnMeacham> @seen SamB
14:36:39 <lambdabot> SamB is in #haskell-overflow, #perl6 and #haskell. I last heard SamB speak 5m 23s ago.
14:37:00 <SamB> JohnMeacham: yes?
14:37:50 <hpaste>  dozer pasted "ghc error?" at http://hpaste.org/1658
14:38:19 <dozer> is this something I've done wrong, or has ghc got all spangley?
14:38:21 <JohnMeacham> ah, I was wondering if you could unrecord then rerecord the first 4 and the 6th patches you sent me, since some of the later ones redo work from the previous ones and they all logically implement a single change.
14:38:52 <JohnMeacham> it really helps with conflict resolution, and it would remove the potential conflict on Grin/Val
14:39:18 <SamB> JohnMeacham: I was going to do that before expecting them to be added to the repository
14:39:24 <JohnMeacham> (basically, a single patch that implements the final version of your foreign exports)
14:39:44 <JohnMeacham> ah. okay. cool. 
14:39:50 <jfoutz`> dozer try --make, perhaps?
14:40:48 <dpiponi> "No-one has ever conducted cognitive studies about Perl's readability." Ha!
14:41:01 <dozer> ok, --make worked - what is the difference between what I typed and the --make version?
14:41:09 <SamB> JohnMeacham: do you have any idea why grin is dropping unused arguments?
14:41:31 <dozer> dpiponit: perl is a write-only language :) not sure cognitive studies are worth the effort
14:41:41 <dpiponi> I bet nobody has done cognitive studies into the smell of...well, you know what I'm going to say
14:41:51 <SamB> dpiponi: I bet you are wrong
14:41:53 <sjanssen> dozer: --make tells GHC to locate and link libraries
14:42:03 <SamB> I'm pretty sure they would have done exactly that by now
14:42:15 <sjanssen> dozer: you could also have used '-package mtl'
14:42:31 <dozer> ah, suddenly it is all clear - pitty ghc didn't complain about this more directly
14:42:43 <dpiponi> SamB: Depends on what your subconscious selected to replace the "..."
14:43:00 <SamB> well, my subconcious suggested "poo"
14:43:09 <JohnMeacham> SamB: it should be, there is a dead vars analysis. or do you mean the 'world' argument?
14:43:20 <dpiponi> SamB: Well I was thinking dog poo.
14:43:31 <JohnMeacham> I guess it would be good to not drop arguments of anything that is exported huh.
14:43:39 <SamB> JohnMeacham: yes it would ;-)
14:44:13 * qwr thinks how poo and dog poo types would relate...
14:44:30 <JohnMeacham> in Grin/DeadCode there is a 'removeDeadArgs' routine. it should be simple to filter out the dead args before calling it.
14:44:47 <SamB> JohnMeacham: hmm?
14:44:50 <JohnMeacham> but the world argument should go away of course.
14:45:40 <SamB> foreign export dropStablePtr :: StablePtr () -> Int -> IO Int
14:45:40 <SamB> dropStablePtr x m = return m
14:46:10 * SamB says something silly to set off the code
14:46:18 <SamB> that turns into this Grin:
14:46:28 <SamB> fFE@.CCall.dropStablePtr :: bits<ptr> bits32 -> [bits32]
14:46:29 <SamB> fFE@.CCall.dropStablePtr p0 w28 = do
14:46:29 <SamB>   return w28
14:46:48 * SamB doesn't see any World argument in that Grin
14:46:53 <JohnMeacham> oh, that is the routine that is removing unused arguments.
14:47:01 <JohnMeacham> oh. yes. you shouldn't if everything is working right.
14:47:13 <SamB> yeah I didn't expect one
14:47:18 <JohnMeacham> there were bugs before that sometimes left them in, I thought maybe you saw one or something.
14:47:31 <SamB> Grin is monadic anyways ;-)
14:47:41 <SamB> but later it becomes...
14:47:49 <SamB> fFE@.CCall.dropStablePtr :: bits32 -> [bits32]
14:47:49 <SamB> fFE@.CCall.dropStablePtr w28 = do
14:47:49 <SamB>   return w28
14:48:46 <JohnMeacham> yeah. 'Grin.DeadCode.removeDeadArgs' is what is doing that. it is passed in a list of unused args, so just filter out any unused args on exported functions before that is called.
14:48:49 <dpiponi> Anyone have any thoughts on this code: http://hpaste.org/1657 
14:48:53 <dpiponi> I'm thinking someone must have done this before - interleaving lists and IO so you can makes streams of input data.
14:49:20 <dpiponi> But as there's no Prelude support (and the standard ListT is broken) I guess not.
14:49:36 <SamB> JohnMeacham: hmm. I forget how to tell if it is exported...
14:49:47 <dpiponi> Would it make sense to flesh it out into a proper library?
14:49:56 <SamB> where "it" is "a function"
14:50:39 <dpiponi> (It was in response to Lazy Lists and IO in cafe)
14:52:09 <SamB> JohnMeacham: it seems to be passed a list of *used* args, actually
14:53:00 <JohnMeacham> it would be in the grinEntryPoints map. it might be easier just to do it in the  analysis phase.
14:53:35 <nominolo> dpiponi: that looks like the code from the wiki
14:53:46 <nominolo> ListT done right or se
14:53:48 <dpiponi> Look past the bit that's in the wiki
14:53:58 <dolio> dpiponi: the type of runListT' reminds me a lot of msplit from LogicT.
14:54:49 <dpiponi> I didn't do the ListT bit. I was wondering if people would like to see the job finished with things like fold, filter and othe rlist commands made to work with ListT.
14:56:13 <dpiponi> It seems to me that making a list of input values is the most natural thing in the world, and yet it's a pain in the *** to do in Haskell. Seems like a big functionality hole to me. (Pun not intended.)
14:56:21 <SamB> JohnMeacham: I don't understand all this "fixer" stuff
14:57:23 <JohnMeacham> SamB: it is just a fixpoint analysis. one of literally 5 I have implemented for jhc, (fixpoint analysis is so useful), but none of which I am fully happy with. well, some do general constraints, some need monotonic functions, etc...
14:58:14 <SamB> JohnMeacham: well, that much I can see...
14:58:24 <SamB> I can also see that it has virtually no documentation :-(
14:58:41 <SamB> or, well, maybe more further down
14:58:43 <JohnMeacham> but the easiest thing to do, would just be to add a list of arguments to the usedArgs set passed to removeDeadArgs
14:58:59 <wli> A prioritizing version of LogicT might be interesting. Like weighted fairness vs. total equality.
14:59:53 <MarcWebe1> SamB: Have a look at the fix implementation for monad IO while reading haskell OO ;) Then you'll get an idea.
14:59:58 <JohnMeacham> like, just union it with something like: Set.fromList [ (n,i) | (n,_) <- Set.toList entryPoints, i <- [0 .. numberargs n] ]
15:00:15 <JohnMeacham> but... like.. not buggyp
15:01:01 <SamB> you mean "(not . buggy)"?
15:01:14 <SamB> buggyp is lisp ;-P
15:04:59 <mdmkolbe|ubuntu> How many different monoids exist for any particular finite number of objects?
15:05:26 <mdmkolbe|ubuntu> (In this case objects are distinguishable from each other)
15:05:43 <mrd> monoids over what operation?
15:06:01 <mdmkolbe|ubuntu> mrd: you get to pick the operation
15:06:20 <dpiponi> dolio: I think you're right. Looks to me like a full implementation of ListT would have a method like msplit
15:06:33 <mrd> i guess the number of different ways you can arrange a multiplication table, with the condition that you need an identity element
15:06:35 <mdmkolbe|ubuntu> mrd: or rather, each monoid for each operation counts to the total
15:07:12 <mdmkolbe|ubuntu> mrd: don't forget the associativity constraint
15:07:20 <mrd> aye
15:07:23 <mrd> hmm
15:07:59 * SamB is tempted to unsafeCoerce grinFunctions to a list of pairs so that he can use the lookup function on it...
15:11:30 <dolio> dpiponi: Yeah, I think msplit is "ListT . lift . runListT'"
15:11:48 <HairyDude> interesting... Eq seems to default to ()
15:11:50 <ClaudiusMaximus> hmm, lhs2TeX indents the last line of my code by way too much when i use a figure with \centering
15:13:33 <dolio> dpiponi: This ListT and LogicT might be about the same, with the former implemented with lazy lists underneath, and the latter implemented with continuation passing.
15:14:14 <dpiponi> dolio: I think LogicT has some extra stuff it does too, like maybe something approximating prolog's cut. But I'm not sure.
15:14:40 <hpaste>  HairyDude pasted "Eq defaults to ()" at http://hpaste.org/1659
15:15:07 <SamB> JohnMeacham: hmm, yes, roughly that works.
15:15:16 <dolio> dpiponi: Yeah, but that can (and is) all be implemented in terms of msplit.
15:15:26 <HairyDude> oops, the definition should include an "and", but it shows the (to me) odd behaviour
15:15:29 <SamB> though it seems easier to just go through all the functions and check each one for being an entry point
15:15:52 <SamB> both from an ease-of-coding and a computational complexity point of view
15:17:20 <dpiponi> dolio: Hmmm...although that's probably not what it's designed for, LogicT probably solves the input as stream problem.
15:17:53 <dpiponi> dolio: And just as you can write fold, filter etc. using head/tail, I expect you can write versions using msplit.
15:18:03 <mdmkolbe|ubuntu> @where LogicT
15:18:04 <lambdabot> I know nothing about logict.
15:18:21 <wli> LogicT is the killer monad. ;)
15:18:26 <dolio> @hackage logict
15:18:26 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/logict
15:18:55 <SamB> JohnMeacham: hmm, but I'm getting a C compiler error :-(
15:19:19 <dpiponi> wli: I have to admit, I've never used LogicT myself.
15:19:41 <wli> dpiponi: I'm still trying to get my head around monads.
15:19:41 <mdmkolbe|ubuntu> LogicT is the depth first equivalent of ListT?
15:20:11 <dolio> Yeah, possibly. Although I couldn't figure out how to write Foldable and Traversible instances for LogicT when I was packaging it up. Only for the base monad.
15:20:14 <wli> mdmkolbe: No way, it's queued and fairly.
15:20:46 <mdmkolbe|ubuntu> wli: ?
15:20:58 <dolio> And there was a converstaion with Oleg on the mailing list that you might not be able to do foldr with a transformer, or something.
15:21:18 <dpiponi> dolio: Ah, I might have seen that discussion go by on haskell@ I didn't understand what it was about, But maybe I do now.
15:22:15 <SamB> JohnMeacham: hmm. For some reason it seems to have decided that since the argument variable is unused, it doesn't need to be declared or defined... I guess that will work when I figure out how to generate a C-level stub...
15:22:33 * mdmkolbe|ubuntu looks at the source and sees what wli means
15:23:37 <dolio> mdmkolbe|ubuntu: It provides extra combinators over just 'mplus' and (>>=) for fair choice and stuff.
15:24:17 <dolio> For instance, if 'm1' is a computation that can backtrack an 'infinite' number of times without succeeding, but m2 succeeds...
15:24:30 <dolio> 'm1 `mplus` m2' won't succeed.
15:24:46 <dolio> But 'm1 `interleave` m2' from logict will.
15:24:58 <dolio> Because it chooses fairly from both branches.
15:25:06 <wli> dolio: But who would bother with the unfair parts?
15:25:10 <kosmikus> ClaudiusMaximus: \arrayhs
15:25:32 <dolio> wli: Yeah, I wondered at first why you wouldn't just define (>>=) and mplus fairly...
15:25:44 <wli> dolio: I'm still wondering, actually.
15:25:50 <dolio> wli: But I think if you do that, it violates expected laws on (>>=) and mplus.
15:26:01 <wli> dolio: How's that?
15:26:12 <dolio> Like, (a `mplus` b) >>= k == (a >>= k) `mplus` (b >>= k)
15:26:34 <dolio> Although maybe that still holds, I'm not sure.
15:26:49 <wli> I'm pretty sure it does.
15:26:58 <ptolomy> Is there a list somewhere that is like a "Haskell Libraries Hitlist"... of bindings and basic libraries that would be useful but nobody has gotten around to creating?
15:27:05 <wli> dolio: I think it's the nonterminating case that violates them.
15:27:30 <Saizan> ptolomy: there's a wanted libraries page on the wiki
15:27:47 <ptolomy> Ooh.
15:27:52 * ptolomy missed it somehow.
15:28:08 <dolio> wli: Yeah, maybe that would still hold. I guess I'm still not sure why they didn't just implement things fairly straight off, then.
15:28:17 <Saizan> ptolomy: it has not so much content, though
15:28:28 <dolio> wli: Other than that (>>=) and mplus are still used in some of the definitions of other things.
15:29:55 <dolio> You can also define fair combinators for [], which the library does, but they wouldn't correspond to the current Monad instance for [].
15:30:17 <wli> ptolomy: Quadratically constrained quadratic programming, Karush-Kuhn-Tucker, Broyden-Fletcher-Goldfarb-Shanno, Nelder-Mead, Gauss-Kronrod-Patterson, Hermite interpolation, Thiele interpolation, n-th degree spline interpolation, etc.
15:31:17 * ptolomy weeps.
15:31:40 <wli> ptolomy: The parallel array combinators help. ;)
15:32:59 <glguy> looking at Associated Types with Class it seems like this would be a godsend to have as a standard feature. Are there any particularly devastating consequences to using ATs outside of non-portabilty?
15:33:10 <wli> ptolomy: Heck, a quick and dirty biconjugate gradient on sparse matrices would be pretty slick.
15:33:45 <ClaudiusMaximus> kosmikus: huh?
15:34:23 <kosmikus> \begin{figure}\centering\arrayhs\begin{code}...\end{code}\end{figure}
15:35:10 <JohnMeacham> SamBQ it might be dropping things with numerical value '0', which is only used is a variable is not going to be used.
15:35:13 <jre2> is it possible to add a constraint to a type, like ChessBoardLength :: int 0<n<8 ?
15:35:17 <ClaudiusMaximus> kosmikus: ah ok, will try it
15:35:46 <ptolomy> To be honest, I was thinking more along the lines of "stuff that would make it easier to write code that interacts with the world outside of the haskell compiler".. bindings to existing libraries, basic protocols, helpers for common application/systems programming tasks, that sort of thing. 
15:36:38 <ClaudiusMaximus> kosmikus: perfect, thanks - i guess this is mentioned in the manual which i didn't read, heh
15:36:42 <wli> ptolomy: Oh, of course. Bindings for Linux kernel aio and epoll might help.
15:36:52 <dolio> wli: Testing it out, it seems that (m1 `interleave` m2) >>- f /= (m1 >>- f) `interleave` (m2 >>- f)
15:37:02 <dolio> Although, I just found a bug. :)
15:37:35 <wli> ptolomy: Multidimensional search structures would be good, also external data structures and algorithms (i.e. ones on disk, like on-disk B+ trees).
15:37:56 <EvilTerran> jre2, short of creating a newtype around the type, and writing all the instances again, no
15:38:08 * ptolomy wonders how often library and languages choices in Haskell have to be made between the one that is theoretically pure and the one that is ugly but more "practical"..
15:38:33 <wli> ptolomy: Multidimensional search structures are a big big deal.
15:38:52 <EvilTerran> "ghc -fpragmatic" vs "ghc -fpurist"? ;]
15:38:55 <jre2> EvilTerran: do you know where I can look to find out how to do it if I decide to though?
15:39:23 <EvilTerran> jre2, i don't think it's ever been done, particularly, i'm afraid
15:39:44 <ptolomy> wli: Mutlidimensional as in... multiple indexes?
15:39:52 <jre2> ah, nevermind then. I'm not that brave...yet
15:39:53 <wli> ptolomy: Basically they're search trees where you have entries like Record { x, y :: Integer } and can get O(lg(n)) queries of the form a <= x && x <= b, c <= y && y <= d
15:40:02 <Saizan> wli: there's a paper + code that requires aio, something about the event-driven model
15:40:58 <ptolomy> wli: Out of curiosity, are you aware of any existing implementations for that sort of thing in any language?
15:41:18 <wli> ptolomy: Yes, C.
15:41:43 <ptolomy> wli: Link?
15:41:46 * ptolomy googles.
15:42:03 <wli> ptolomy: ftp://ftp.kernel.org/pub/linux/kernel/v2.6/
15:43:01 <jfoutz`> jre2: you could do something like data Col = A | B | C | D | E | F | G | H deriving (Eq, Ord, Enum, Show)
15:44:09 <jre2> jfoutz`: yea, that's what I did for a simple case.  I was just wondering what to do if I wanted to make a 100x100 board (which I'll need to for a tactical AI combat contest soon)
15:44:14 <jfoutz`> jre2: if you play with it a bit, i'm sure you could come up with some pawn to E5 kind of semantics
15:44:38 <ojacobson> stupid newbie moment, can anyone help me figure out why my code produces "Unresolved overloading" for one specialization of a function and no others?
15:44:47 <ojacobson> http://pastebin.ca/618371
15:44:48 <EvilTerran> jre2, do you really need to enforce these bounds so vigorously?
15:45:02 <ojacobson> (Probably atrocious style.  I literally picked it up at 3 this morning.)
15:45:18 <EvilTerran> i think it remains an unsolved problem precisely because it's easier to do without.
15:45:23 <jre2> EvilTerran: no, but I figured it might be more elegant if I could, so I'd search around to see if its feasible
15:45:24 <Heffalump> ojacobson: look at the type of simplify
15:45:30 <jfoutz`> jre2: template haskell could help with that, but i think the code would be cleaner with some other implementation.
15:45:38 <ojacobson> Should be Expr a -> Expr a
15:45:53 <ojacobson> hugs says: simplify :: (Integral a, Fractional a) => Expr a -> Expr a
15:46:03 <Heffalump> oh, wait. I'm confused.
15:46:15 <Heffalump> I don't understand why defaulting doesn't apply.
15:46:21 <ojacobson> if I comment out all specializations for Pow, I get...
15:46:36 <ddarius> jre2: There are plenty of ways of handling it, but it's more of a pain than it's worth.
15:46:40 <ojacobson> simplify :: Fractional a => Expr a -> Expr a
15:46:55 <EvilTerran> yeah, you could create a TH template to the effect of using the decleration $(intSubset "ZeroToEight" [0..8]) and then using toEnum and fromEnum to get at members for it
15:47:20 <Heffalump> ojacobson: and then does it work?
15:47:24 <jre2> ah, that does sound less clean
15:47:27 <Heffalump> oh, wait, I see
15:47:27 <ojacobson> Except for simplifying Pow expressions, yes
15:47:28 <ojacobson> mostly
15:47:28 <jfoutz`> jre2: a nicer way might be to have a cell type, and just permute the 9 cases of board squares.
15:47:36 <Heffalump> it can't default (Fractional a, Integral a)
15:47:49 <Heffalump> but it can default (Integral a) which is what Lit 2 ^/ Lit 3 is
15:48:03 <ojacobson> How did you work that out?
15:48:10 <Heffalump> actually, Fractional a, Integral a isn't even possible
15:48:19 <Heffalump> because I have a vague understanding of the defaulting rules
15:48:24 <ojacobson> hmm
15:48:33 <ojacobson> google is, I suppose, over there and I can look this up myself :)
15:48:58 <EvilTerran> jre2, there may even be some olegian approach that shuns TH, using type-encoded numbers in its place
15:49:01 <ojacobson> Broader question: any suggestions on reducing the amount of duplicate crap in there?
15:49:01 <jre2> yea, I the only situation I really have (now) is a problem with is placing a piece with board!!x!!y (since it could be out of bounds, I have to Maybe it, which starts cluttering my code)
15:49:05 <EvilTerran> but that's not really neater
15:49:16 <dolio> jre2: Oleg's made plenty of mailing list posts about type-level naturals, which might help you.
15:49:18 <Heffalump> the "unresolved overloading" has nothing to do with defaulting. It's just unsatisfiable.
15:49:28 <EvilTerran> jre2, is the Maybe monad of use here?
15:49:30 <jfoutz`> jre2: data Square Piece = NW P | N P | NE P | W P | C P | E P | SW P | S P | SE P
15:49:46 <jfoutz`> you could even give each square pointers to it's neighbors
15:49:47 <ojacobson> Heffalump: interesting, if I take the first "simplify (Pow (Lit a) (Lit b))" and make a new function foo out of it
15:49:49 <ojacobson> that function works fine
15:49:54 <dolio> jre2: I'm sure there's been at least one with a type like "Modulo n" which is the type of integers modulo some 'n'.
15:50:02 <Heffalump> it'll be the combination of operations you are using
15:50:03 <glguy> ojacobson: change the rule to use **
15:50:04 <ojacobson> if I add just that one and try using simplify (Lit 2 ^/ Lit 3) I get that error
15:50:11 <Heffalump> ah, right, glguy has found it
15:50:13 <ojacobson> glguy: ok, I'll try that... expn?
15:50:17 <glguy> ojacobson: simplify (Pow (Lit a) (Lit b)) = Lit (a ** b)
15:50:17 <Heffalump> using ^ will force things to be Integral
15:50:22 <jre2> alright, thanks for the advice
15:50:22 <ojacobson> oho
15:50:23 <glguy> ^ is too restrictive
15:50:24 <Heffalump> but using / will force things to be Fractional
15:50:50 <ojacobson> glguy: perfect - it works brilliantly
15:51:07 <ojacobson> that even made sense to me once Heffalump pointed out the type of (^)
15:51:41 <glguy> ojacobson: remember that ^ is only for non-negative powers
15:51:53 <ojacobson> Yeah... I was looking for general exponentiation of two numbers
15:52:10 <glguy> ^^ is for all integral powers
15:52:22 <glguy> and ** is for fractional powers
15:53:00 <jfoutz`> > 2.1 ** 2.1
15:53:02 <lambdabot>  4.749638091742242
15:53:16 <ojacobson> That un-broke another function.  Eeeenteresting.
15:53:47 <ojacobson> (I have another module that uses Expr to do symbolic derivatives...  derive = simplify . fderive stopped working when I added the broken definition to simplify
16:02:30 * Nafai tries to figure out how to get lambdabot going
16:05:34 <Laney> I'm trying to install HaXML on windows, using the .bat file, but am getting this error message: http://hpaste.org/1660 - can anyone help with it?
16:06:50 <Heffalump> any reason you're not using Cabal?
16:07:22 <Heffalump> I don't know about that error, but I do know that I've installed it on Windows using Cabal without any problem like that.
16:07:22 <shachaf> Nafai: Going?
16:07:55 <Laney> Heffalump: I guess not, but the README told me to use the bat file.
16:08:25 <cdsmith> Laney: Yeah, I fought with the README instruction, too;  finally I used Cabal, and it worked.
16:08:35 <Nafai> shachaf: built and running locally
16:08:47 <cdsmith> Laney: So I'd ignore the README, if I were you (or me)
16:08:51 <shachaf> Nafai: What's the problem?
16:09:10 <shachaf> Nafai: You should use the darcs version, if you aren't.
16:09:11 <Laney> cdsmith: Will it cause any problems if i just install over the top with Cabal then? It seems to have copied most of the files over to ghc
16:09:22 <mdmkolbe|ubuntu> heh, I just discovered the warning monad.  Is it already known?  (After a certain number of warnings it throws an error.)
16:09:25 <cdsmith> Laney: Probably not, but there's only one way to know for sure
16:09:35 <Laney> Right. Let's try then.
16:10:15 <shachaf> Nafai: I also had to remove arrows as a dependency from the .cabal file.
16:10:22 <shachaf> Nafai: Before running ./build.
16:10:23 <Nafai> shachaf: I am.  Just starting out.  I'm looking at Config.hs...what's fptools?
16:10:37 <Igloo> Anything talking about fptools is probably out of date
16:13:25 <shachaf> Nafai: Unfortunately I'm not at the computer I installed lambdabot on.
16:13:32 <shachaf> Nafai: But I don't remember having trouble with that.
16:13:48 <Nafai> Ok
16:14:30 * shachaf darcs gets it anyway.
16:15:23 <Nafai> I'm building on Ubuntu...know what I need to satisfy the binary>=0.2 dependency?
16:15:36 <shachaf> @where binary
16:15:36 <lambdabot> http://www.cse.unsw.edu.au/~dons/binary.html
16:16:39 <Laney> Urgh bugs. Now I'm getting this one http://hackage.haskell.org/trac/hackage/ticket/143 :( Does anyone know of a workaround?
16:16:40 <lambdabot> Title: #143 (Cannot execute ar.exe on Vista) - Hackage - Trac
16:17:18 <Laney> "Switch to Linux" not an option, yet. ;)
16:17:42 <Igloo> Laney: What version of GHC?
16:17:52 <Laney> Igloo: 6.6.1
16:17:59 <Igloo> Hmm, not sure then
16:18:13 <Laney> Pretty much exactly the same as that report. Even the same ghc path, spooky.
16:18:20 <Heffalump> can you fix the permissions on the binary?
16:19:04 <Laney> I think it's a problem with how cabal checks whether a binary is executable, not with my permissions - I can run it just fine from the commandline.
16:20:35 <Heffalump> nonetheless, can you change them somehow so that cabal is happy?
16:20:43 <Laney> I don't see how
16:21:03 <Laney> According to that report it's checking for a flag which doesn't exist
16:21:52 <Heffalump> ah, ok
16:22:20 <Heffalump> "Vista doesn't have this bit set" implies that it exists but isn't on by default
16:23:16 <mdmkolbe|ubuntu> What is the easiest way to check if one number is an exact power of another?
16:23:27 <Heffalump> take logs?
16:23:45 <mdmkolbe|ubuntu> Heffalump: I thought of that, but I'm woried about round off errors
16:24:16 <Heffalump> have you checked if they'd actually be a problem over the range of numbers you care about?
16:24:39 <Heffalump> I can't see any alternative to repeated division, otherwise.
16:25:07 <mdmkolbe|ubuntu> Heffalump: I'd have to test floating point equality if I did logs, which is always iffy
16:25:10 <ddarius> Repeated multiplication surely.
16:25:29 <Heffalump> (more efficiently, make a list of squares of the lower number, and then divide them out from the bigger number)
16:26:15 <ddarius> Square lower number repeatedly until it's bigger, then linearly search the powers from the previous power up until it's equal or bigger.
16:27:23 <Heffalump> the linear search is unnecessary
16:27:37 <ojacobson> Apparently I can read the manual and still not understand it...  what's wrong with this file?  http://pastebin.ca/618425
16:27:59 <ojacobson> According to the Haskell report that should be okay... its example is structurally identical, as far as I can see
16:28:02 <Heffalump> you can just divide out the largest square that will divide out and then repeat the processs (using your previously computed list of squares this time)
16:28:16 <ddarius> Heffalump: Good call.
16:28:35 <Heffalump> ojacobson: your indentation looks odd to me
16:28:37 <ddarius> I thought there was a better way, but I was going for reasonable and quick (to implement).
16:28:40 <mdmkolbe|ubuntu> I'm looking for a golfer's solution
16:28:49 <ojacobson> Heffalump: default tab indent (using spaces, I checked) with emacs haskell-mode
16:28:52 <Heffalump> what's a golfer's solution?
16:29:00 <Heffalump> I wouldn't trust haskell-mode.
16:29:00 <wli> heh, I implemented bisection search after a fashion
16:29:04 <cdsmith> @where generic-xml
16:29:04 <lambdabot> I know nothing about generic-xml.
16:29:07 <ojacobson> Heffalump: well shit.  :/
16:29:09 <Heffalump> ojacobson: put the imports on column 0
16:29:26 <mdmkolbe|ubuntu> Heffalump: ever heard of "perl golf"?  You try to write the program in the fewest number of strokes.
16:29:28 <ojacobson> huh.
16:29:29 <ojacobson> Good to know.
16:29:33 <Heffalump> mdmkolbe|ubuntu: ah, right.
16:29:52 <Heffalump> well, make a lazy list of all powers and search for your number, stopping when you get too big.
16:30:18 <ojacobson> http://www.haskell.org/onlinereport/modules.html has the imports indented, which is why I was confused
16:30:19 <lambdabot> Title: The Haskell 98 Report: Modules
16:30:20 <Heffalump> bigger == last (takeWhile (<=bigger) [smaller^n | n <- [1..]])
16:30:23 <Heffalump> or something like that
16:30:28 <Heffalump> ojacobson: does it work without them indented?
16:30:31 <Heffalump> I was just guessing
16:30:37 <ojacobson> Heffalump: well, it loads
16:30:38 <ddarius> f l h = until (<=l) (`div` l) h == l 
16:30:41 <Heffalump> it may be that you need to indent format the same level as you indent the imports.
16:30:42 <ddarius> :t until
16:30:50 <ojacobson> there's evidently some other problem, evaluating format X spits an error
16:30:50 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
16:30:53 <Heffalump> but usual style is not to indent anything
16:31:01 <wli> Heffalump: http://hpaste.org/1633/4/plain
16:31:04 <Heffalump> what's in Express?
16:31:11 <ojacobson> Same as you saw before
16:31:25 <ojacobson> http://pastebin.ca/618371  (except with simplify fixed)
16:31:25 <Heffalump> what's the error you get?
16:31:33 <ojacobson> Format> format X
16:31:33 <ojacobson> ERROR - Unresolved overloading
16:31:34 <ojacobson> *** Type       : PrintfArg a => [Char]
16:31:34 <ojacobson> *** Expression : format X
16:31:39 <ddarius> > let f l h = until (<=l) (`div` l) h == l in f 3 81
16:31:40 <lambdabot>  True
16:31:42 <ojacobson> Format> :type format
16:31:42 <ojacobson> format :: PrintfArg a => Expr a -> [Char]
16:31:46 <ddarius> > let f l h = until (<=l) (`div` l) h == l in f 3 812
16:31:47 <lambdabot>  True
16:32:28 <Heffalump> oh, right, it doesn't know what type X should be
16:32:34 <Heffalump> cos for that constructor, the a is a phantom type
16:32:41 <Heffalump> try (X :: Expr ())
16:33:06 <ojacobson> Or qualifying X
16:33:14 <ojacobson> Format> format Express.X
16:33:19 <wli> ojacobson: What is this for, anyway?
16:33:26 <Heffalump> qualifying X won't help
16:33:36 <ojacobson> wli: learning.  I'm doing some simple (ish) rule-based stuff just to get acquainted.
16:33:58 <ojacobson> wli: starting with a half-assed symbolic derivative of an expression
16:34:31 <wli> I just did something of this sort myself for no obvious reason.
16:34:44 <wli> Well, actually, to see where monads would be useful when I'm not using them.
16:34:48 <mdmkolbe|ubuntu> > let f l h = until (<=l) (`div` l) h == l in f 2 11
16:34:50 <lambdabot>  True
16:35:05 <ddarius> @src until
16:35:05 <lambdabot> until p f x | p x       = x
16:35:06 <lambdabot>             | otherwise = until p f (f x)
16:35:16 <ojacobson> (fun haskell-mode quirk: M-x comment-region; M-x uncomment-region screws up the indenting by one space.)
16:35:28 <ojacobson> (bug report sent)
16:35:55 <wli> ojacobson: I was inspired by a post on hpaste.org doing something similar. I think he called it the "Harrop challenge."
16:36:05 <ojacobson> wli: ?
16:36:08 <wli> ojacobson: http://holomorphy.com/~wli/Challenge.hs
16:36:37 <mdmkolbe|ubuntu> @index (%)
16:36:37 <lambdabot> Data.Ratio
16:36:38 <ojacobson> wli: ...huh.  A few more lights just came on in my head thanks to that.
16:37:50 <ddarius> It truncates to l.
16:37:57 <sjanssen> @yow!
16:37:58 <lambdabot> Somewhere in suburban Honolulu, an unemployed bellhop is whipping up a
16:37:58 <lambdabot> batch of illegal psilocybin chop suey!!
16:38:26 <ddarius> Yay shrooms
16:39:25 <ojacobson> wli: so what's the challenge part?
16:39:35 <ojacobson> wli: this is clearly a response :)
16:39:38 <wli> ojacobson: Basically you distribute operations to get a sum of products and pull all divisions out into affairs with common denominators and collect all like terms. Then your normal form is a ratio of multivariate polynomials with integer coefficients with no repeated monomial summands and a leading rational coefficient.
16:39:56 <wli> ojacobson: I have no idea. I just thought about normal forms for these sorts of expressions.
16:40:30 <ojacobson> wli: the normal form part is insanely great and shows me how little I really know about haskell (not to mention how much I've forgotten of algebra >_>)
16:41:10 <wli> ojacobson: You can probably ignore the Grobner basis part unless you're dead set on dividing out common factors.
16:42:11 <ojacobson> syntax -- what's that $ in "normRaw e = snd . head . dropWhile (uncurry (/=)) $ zip es (tail es)" doing
16:42:31 <wli> ojacobson: It actually shows how little I know about Haskell myself; there are better ways to do these things.
16:43:42 <wli> ojacobson: basically it's snd ( head ( dropWhile (uncurry (/=)) (zip es (tail es) ) ) )
16:44:26 <ojacobson> wli: any hope of a more direct answer?  I grokked that tree out of it (eventually) but I don't understand what $ means.
16:44:27 <dmwit> \es -> head (dropWhile (== head es) es)
16:44:54 <dmwit> wait
16:44:59 <Pupeno> Hello.
16:45:02 <wli> ojacobson: Iterating to convergence.
16:45:04 <dmwit> Hi Pupeno!
16:45:22 <wli> ojacobson: zip es (tail es) pairs up each element of es with its successor.
16:47:10 <wli> ojacobson: dropWhile (uncurry (/=)) drops the elements of that list of pairs while they're not equal, or otherwise, until the element and its successor are the same.
16:47:22 <dmwit> :t foldr
16:47:25 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
16:47:56 <wli> ojacobson: Once they're the same it means you can't reduce it anymore.
16:48:18 <ddarius> @src ($)
16:48:18 <lambdabot> f $ x = f x
16:48:49 <wli> There should actually be a way to do all this in terms of general rewrite rules.
16:49:47 <dmwit> > let converge xs = fix (\f (x:y:rest) -> if x == y then x else f (y:rest)) in converge [1,2,3,3,3,3,3]
16:49:49 <lambdabot>  <[Integer] -> Integer>
16:49:51 <ojacobson> wli: ok, I think I've soaked up as much as I'm going to for now.  Ow.  Thank you.
16:50:10 <wli> ojacobson: Feel free to use what I wrote if it comes in handy at all.
16:50:26 <ojacobson> wli: Mainly for staring at and going "...how did he think of this?!"
16:50:36 <ojacobson> wli: I don't have the functional language thought patterns in place yet
16:51:07 <wli> ojacobson: There are no mindbending monads and the constraints on the form of the expression at each stage of normalization are nailed down with types restricting how they can be formed.
16:51:16 <dmwit> > let converge = fix (\f (x:y:rest) -> if x == y then x else f (y:rest)) in converge [1,2,3,3,3,3,3]
16:51:18 <lambdabot>  3
16:51:26 <dmwit> > let converge = fix (\f (x:y:rest) -> if x == y then x else f (y:rest)) in converge [1,2] ++ repeat 3
16:51:27 <lambdabot>   add an instance declaration for (Num [a])
16:51:27 <lambdabot>     In the expression: 2
16:51:42 <dmwit> > let converge = fix (\f (x:y:rest) -> if x == y then x else f (y:rest)) in converge ([1,2] ++ repeat 3) -- I'm a bit rusty
16:51:43 <lambdabot>  3
16:51:55 <dmwit> Whee!
16:52:51 <dmwit> > let converge = fix (\f (x:y:rest) -> if x == y then x else f (y:rest)) in converge [1,2,3,3] -- hmmm...
16:52:53 <lambdabot>  3
16:52:57 <dmwit> o good
16:54:01 <monochrom> @remember wli There are no mindbending monads
16:54:02 <lambdabot> Done.
16:54:15 <ojacobson> heh, no letters added
16:55:42 <dmwit> > let converge (x:y:rest) | x == y = x | otherwise = converge (y:rest) in converge [1,2,3,3] -- more readable than fix
16:55:43 <lambdabot>  3
16:56:44 <wli> dmwit: \f x -> until (uncurry (==)) (\(_, x) -> (x, f x)) (x, x)
16:57:13 <wli> dmwit: \f x -> snd $ until (uncurry (==)) (\(_, x) -> (x, f x)) (x, x)
16:57:51 <dmwit> wli: That assumes the list was generated by an iterate-alike. ;-)
16:58:09 <dmwit> And may I humbly say that I find it a helluva lot less readable.
16:58:13 <wli> dmwit: It generates the list.
16:58:15 <dmwit> Which is why I started with it anyway.
16:58:20 <dmwit> wli: Exactly.
16:58:28 <dmwit> But if your list isn't generated that way, you're stuck.
16:58:36 <dmwit> i.e. if the list comes from IO?
16:58:46 <dmwit> Dunno for sure, I don't have a use for it in mind.
16:58:52 <dmwit> You're the one what posted the function. =)
16:59:03 <wli> I iterate to convergence. Newton's method, for example.
16:59:34 <dmwit> ok
16:59:56 <dmwit> So this is the function you use now?
17:02:44 <Nafai> Yay, I got lamdbabot working
17:03:05 <Saizan> i think there's a monad where you can tranform an arbtrary list in a f-like function, Cont maybe?
17:03:21 <ddarius> "f-like"?
17:07:16 <Pupeno> I am reading the "You could have invented mondas" blog post, and it defines writes bind f' . g' as f'*g'. Is there any reason to use the second way of writting it?
17:10:22 <ddarius> Pupeno: It's compact and actually a fairly good way of thinking of "bind" in some contexts.
17:10:38 <ddarius> :t (=<<)
17:10:40 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
17:10:43 <wli> > let { newt f f' x = let g (x, y) = let x' = x - (f x) / (f' x) in (x', f x') in snd $ until (\((x, _),(y, _)) -> abs (x - y) < 1.0e-14) (\(_, x) -> (x, g x)) ((x + 1, f $ x + 1), (x, f x)) } in newt sin cos 3.5
17:10:44 <lambdabot>  (3.141592653589793,1.2246063538223773e-16)
17:10:47 <dons> http://haskell.org/haskellwiki/Haskell_Cafe_migration
17:10:50 <lambdabot> Title: Haskell Cafe migration - HaskellWiki
17:10:55 <ddarius> Now view that as (a -> m b) -> (m a -> m b)
17:10:58 <dons> for those who are happy to have their mailing list work moved to the wiki freely.
17:11:04 <dons> please add your names to the above page!!
17:11:06 <Nafai> Hi dons
17:11:07 <ddarius> woot
17:11:07 <monochrom> I think you mean "it writes bind f' g' as f'*g'"? Anyway as ddarius says it's compact. I also add that infix notation is sometimes nice.
17:11:30 <ddarius> Oh wait, I was thinking of a different notation.  Yeah, that's sigfpe wierdness.
17:11:49 <Pupeno> ddarius: and when it says "unit * f = f * unit", then it means "bind unit . f = bind f . unit" ?
17:12:01 <monochrom> The f'*g' notation is also present in old academic monad papers e.g. Moggi's.
17:12:05 <wli> I never use Newton's method nakedly like that, of course.
17:13:22 <ddarius> monochrom: Are you sure Dan's version is?  What I was originally thinking was the f^* corresponding to (f=<<) which is quite common in more "theoretical" papers.
17:14:06 <monochrom> It has been a while. I am not sure. Sorry.
17:14:41 <LoganCapaldo> hello haskellians!
17:15:06 <Nafai> Hello LoganCapaldo 
17:15:28 <LoganCapaldo> I've not been here in a while.
17:15:46 <ddarius> Shame on you.
17:15:54 <LoganCapaldo> What new and exciting things have happened in the world of #haskell?
17:16:13 <LoganCapaldo> ddarius, I had to like start work and junk. It's been consuming a lot of my time :)
17:18:28 <SamB> JohnMeacham: oh, yes
17:18:33 <SamB> that's true
17:18:38 <SamB> it is 0
17:19:06 <ddarius> LoganCapaldo: Excuses, excuses.
17:23:45 <LoganCapaldo> @bot
17:23:45 <lambdabot> :)
17:31:35 <wli> Slightly better is...
17:31:39 <wli> > let { solve f f' a b = let g (a, b, f_a, f_b) = let { x = (a+b)/2 ; y = f x ; x' = x - y/(f' x) ; (c, f_c) = if a < x' && x' < b then (x', f x') else (x, y) } in if signum f_c == signum f_a then (c, b, f_c, f_b) else (a, c, f_a, f_c) in until (\(a,b,_,_) -> abs (b - a) < 1.0e-14) g (a, b, f a, f b) } in solve sin cos 3.0 3.5
17:31:43 <lambdabot> Terminated
17:32:03 <wli> Strange. Convergence was instant here.
17:32:38 <ddarius> > (signum, abs)
17:32:39 <lambdabot>  (<Integer -> Integer>,<Integer -> Integer>)
17:32:58 <wli> ddarius: defaulting
17:33:18 <ddarius> wli: ?  
17:33:31 <ddarius> As far as your code is concerned the default would be Double.
17:33:34 <wli> ddarius: lambdabot gave you bad types.
17:33:44 <ddarius> > sequence
17:33:45 <lambdabot>  Add a type signature
17:34:11 <ddarius> wli: There are some functions that behave weird because of naming conflicts.
17:36:11 <wli> To truly fix that thing you've got to keep track of which of the bounds you adjusted last.
17:46:17 <Binkley> ?quote
17:46:18 <lambdabot> "no says: hacerle caso a br1"
17:47:03 <hpaste>  wli pasted "Newton's method" at http://hpaste.org/1661
17:53:08 <dons> ?users
17:53:09 <lambdabot> Maximum users seen in #haskell: 355, currently: 306 (86.2%), active: 8 (2.6%)
17:57:03 <Pupeno> If, according to "You could have invented mondas",  |   bind f' . g'  | can be written as |  f'*g'   |, when it says "unit * f = f * unit", then it means "bind unit . f = bind f . unit" ?
17:59:19 <monochrom> Yes.
17:59:34 <hpaste>  wli pasted "Bernoulli numbers lacking dynamic programming" at http://hpaste.org/1662
18:00:08 <ddarius> dons: I'm hacking the code into a more modularized state, but I'll probably not show anything tonight.
18:00:56 * wli tries to figure out how to shove memo tables into a state monad.
18:01:29 <Pupeno> Then I may be doing something wrong, because unit makes sense in the the "debuging world", that is, on the monadic functions or however they are called... and f is not on that world. Hard to explain in only a couple of lines. Can anybody help me a bit here?
18:02:19 <Saizan> in unit * f, f is a debugging function
18:02:58 <Pupeno> Saizan: like f' and g'?
18:03:02 <Saizan> yes
18:03:36 <Pupeno> then f is being used like a variable and not like the function f... it would have been easier to understand if it said f', don't you think?
18:03:37 <dons> ddarius: ok.
18:04:36 <Saizan> Pupeno: yeah, surely
18:05:40 <Saizan> Pupeno: however f is often used for "whatever function fits here"
18:06:03 <Pupeno> Saizan: indeed... but it confused me :(
18:06:26 <wli> Okay, a -> m b is what's trying to do the memoized computation. It can't see the memo table, which is attached to the arg it wants of type m a. (>>=) wraps the thing with a memo table check and lookup and dumps the result into the memo table as-needed in tandem with the result.
18:09:32 <dolio> wli: Wouldn't the dynamic programming module work easier?
18:10:02 <wli> dolio: Bernoulli numbers are useless; this is clearly pedagogical.
18:10:03 <dolio> wli: Isn't 'aux' only called with each (n,m) pair once in a dynamic programmed situation?
18:11:02 <wli> dolio: I was going to memoize the binomial coefficients, the auxiliary function, and the Bernoulli numbers themselves.
18:11:55 <dolio> Well, choose is easy to memoize, since it only depends on itself.
18:12:05 <dolio> Via knot tying/that module.
18:12:46 <wli> dolio: My thought was to drill monads into my head by having everything be the state monad.
18:13:19 <dolio> Well, if the exercise is to learn monads, go ahead.
18:14:04 <ddarius> dolio: Mutually recursive knots perhaps even indirected through a structure are quite possible.
18:14:28 <wli> ddarius: I have specific needs for such things.
18:14:35 <Cale> @seen dynamix
18:14:36 <lambdabot> I saw dynamix leaving #haskell 51m 3s ago, and .
18:14:55 <wli> ddarius: Which is why I'm doing pedagogical drills to work up to it.
18:15:18 <ddarius> wli: You've looked at TyingTheKnot on the old wiki?
18:15:31 <wli> ddarius: No, URL?
18:15:39 <ddarius> @oldwiki TyingTheKnot
18:15:39 <lambdabot> http://www.haskell.org/hawiki/TyingTheKnot
18:15:40 <dolio> ddarius: Yeah, I was just thinking that the type of memoFix wouldn't generalize as nicely as fix.
18:15:58 <dolio> ddarius: You'd have to write tupled versions for mutually recursive functions, no?
18:16:45 <ddarius> dolio: If you wanted to use a fixpoint operator.  Is that a requirement (I haven't been paying that much attention)?
18:17:30 <dolio> ddarius: No, but I pointed him to a module a night or two ago that had a fixpoint operator, and was thinking in terms of that.
18:22:03 <wli> gah wtf is a tilde pattern?
18:23:06 <ddarius> http://www.haskell.org/tutorial/patterns.html section 4.4
18:23:07 <lambdabot> Title: A Gentle Introduction to Haskell: Patterns
18:23:08 <Binkley> wli: it does lazy pattern matching
18:23:31 <Binkley> the value being matched isn't evaluated until one of the variables in the pattern is demanded
18:24:51 <wli> Irrefutable, too. Sounds like a feature I'll never use.
18:24:56 <Binkley> I've never used it
18:25:19 <ddarius> It's not necessary but very handy for circular/stream-based programming
18:26:37 <ddarius> I don't use it often, but I'm glad it's there.
18:27:03 <audreyt> it's the moral counterpart to bang patterns -- both are useful, though rarely needed, tools
18:28:03 <Pupeno> What is a "conceptually randomized function" ?
18:29:04 <Binkley> Pupeno: context?
18:29:38 <Pupeno> Binkley: "You could have invented monads", http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
18:29:40 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ..., http://tinyurl.com/ecqzl
18:31:05 <Binkley> Oh -- he's just saying that although you could think of such a function as taking a random number as an argument, you'd write it in Haskell in a different way
18:31:28 <Binkley> er, rather, you'd think of it as generating a random number without taking an extra argument
18:40:19 <Excedrin> > 1%2 * 1%2 -- is there a good reason why the precedence of % is low?
18:40:20 <lambdabot>   add an instance declaration for (Integral (Ratio t))
18:40:44 <ddarius> Excedrin: Just use /
18:41:30 <wli> I can't quite figure out what the appropriate definition of (>>=) would be, in part because there doesn't appear to be any obvious way to use the record fields.
18:41:53 <Excedrin> is there a way to produce Ratio results with (/) ?
18:42:02 <ddarius> > 1/2 :: Ratio Int
18:42:04 <lambdabot>  1%2
18:42:04 <wli> :t 3/5 :: Rational
18:42:06 <lambdabot> Rational :: Rational
18:42:48 <Excedrin> ok, what's the purpose of (%) ?
18:42:49 <LoganCapaldo> > 1/2 :: (Num a) => Ratio a
18:42:49 <lambdabot>        add (Integral a) to the expected type of an expression
18:42:49 <lambdabot>     In the expr...
18:43:10 <LoganCapaldo> > 1/2 :: (Integral a) => Ratio a
18:43:11 <lambdabot>  1%2
18:43:46 <LoganCapaldo> well you don't have to add (as many) type annotations with %
18:43:50 <LoganCapaldo> :t %
18:43:52 <lambdabot> parse error on input `%'
18:43:57 <LoganCapaldo> :t (%)
18:43:59 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
18:44:02 <LoganCapaldo> :t (/)
18:44:04 <lambdabot> forall a. (Fractional a) => a -> a -> a
18:45:06 <wli> instance Monad BernoulliState where
18:45:06 <wli>         return x = BernoulliState { bernoulliTable = empty
18:45:06 <wli>                                   , auxTable = empty
18:45:06 <wli>                                   , binomialTable = empty
18:45:06 <wli>                                   , bernoulliResult = x
18:45:08 <wli>                                   }
18:45:10 <wli>         bs >>= f = bs { bernoulliResult = bernoulliResult $ f (bernoulliResult bs) }
18:45:40 <Excedrin> are they the same under the hood?
18:45:58 <Excedrin> I guess I should read the report...
18:45:59 <LoganCapaldo> @src Ratio (/)
18:46:00 <lambdabot> Source not found. Are you on drugs?
18:47:11 <LoganCapaldo> well I think 2/1 :: Ratio is more like fromIntegral (2 :: Ratio) / fromIntegral (1 :: Ratio)
18:47:25 <LoganCapaldo> (excuse my abuse of types please)
18:47:41 <LoganCapaldo> err
18:47:48 <LoganCapaldo> my parens are all wrong in that example
18:48:05 <LoganCapaldo> (fromIntegral 1 :: Ratio) / (fromIntegral 2 :: Ratio)
18:48:42 <LoganCapaldo> So like 2/1 :: Ratio is more like (2%1) / (1%1) than 2%1
18:48:43 <ddarius> LoganCapaldo: Which is hardly a problem.
18:48:56 <LoganCapaldo> ddarius, no it's not a problem
18:49:15 <ddarius> % is presumably the smart constructor for :% (since Rationals are more than pairs (or perhaps less than is appropriate))
18:49:24 <ddarius> :t :%
18:49:26 <lambdabot> parse error on input `:%'
18:49:27 <LoganCapaldo> I'm just trying to address the "under the hood" bit
18:49:30 <ddarius> :t (:%)
18:49:32 <lambdabot> Not in scope: data constructor `:%'
18:49:40 <ddarius> :t Ratio.(:%)
18:49:41 <lambdabot> Not in scope: data constructor `Ratio'
18:49:42 <lambdabot>  
18:49:42 <lambdabot> <interactive>:1:6: Not in scope: data constructor `:%'
18:49:42 <LoganCapaldo> ddarius, it's not exported (of course) :)
18:50:02 <Excedrin> so just out of curiosity, why is % such low precedence?
18:50:08 <LoganCapaldo> 2/1 and 2%1 get you to the same place, but not necessarily by the same route
18:50:40 <Excedrin> > 12%8 + 12%8
18:50:42 <lambdabot>  3%1
18:51:05 <Excedrin> > 12%8 * (12%8)
18:51:06 <lambdabot>  9%4
18:51:49 <Excedrin> I suppose 7 is where it should be :)
18:51:50 <HairyDude> memo_example.hs:33:0:
18:51:50 <HairyDude>     No instances for (Show (g a), Show (f a))
18:51:50 <HairyDude>       arising from the 'deriving' clause of a data type declaration
18:51:50 <HairyDude>                    at memo_example.hs:(33,0)-(34,16)
18:52:01 <HairyDude> strange, that declaration doesn't have a deriving clause
18:54:10 <wli> Now I'm not all that sure what to do with it.
18:58:51 <LoganCapaldo> > (12*12)%(8*8)
18:58:53 <lambdabot>  9%4
19:00:23 <ddarius> :t (Ratio.:%)
19:00:25 <lambdabot> Not in scope: data constructor `Ratio.:%'
19:00:52 <Cale> > 743892032981043209473981019281%2468539318440089
19:00:54 <lambdabot>  301349072070329%1
19:01:30 <ddarius> Where'd those numbers come from?
19:02:10 <Cale> The numerator was mostly random
19:02:22 <ricky_clarkson> DRMacIver: You keep showing up in the comments for things I read.
19:02:34 <ddarius> Read other things.
19:02:42 <ricky_clarkson> I'm trying.
19:02:58 <monochrom> Cale is everywhere.
19:03:05 <ClaudiusMaximus> i have a combinator for naming functions:  cF2F :: String -> (F->F) -> IO () ; and i want to enable stateful functions like cF2F' :: String -> (s,((s,F)->(s,F))) -> IO () ; but the type system hates me :(
19:03:15 <monochrom> You have to read C# things to avoid Cale. :)
19:03:42 <ddarius> I don't run across Cale too often in the things I read.
19:03:48 <Cale> monochrom: haha
19:03:58 <ClaudiusMaximus> i get weird errors like "type is insufficiently polymorphic"
19:04:20 <ddarius> And by "too often", I mean "pretty much at all"
19:04:33 <Cale> I even go through google blog search and pick up random bloggers saying "I tried Haskell last weekend" and so on, and leave a remark for them to come here. :)
19:04:44 <Binkley> You're like the Kibo of Haskell
19:04:48 <Cale> heheh
19:04:54 <Cale> Kibo is awesome
19:04:57 <LoganCapaldo> Cale is a whirling tornado of Haskell blog commentaration
19:05:03 <ddarius> "I went to Haskell, Texas" "Come visit #haskell!"
19:05:08 <ricky_clarkson> "I tried Haskell, or was it Pascal?"
19:05:09 <Cale> haha
19:05:11 <monochrom> @remember Cale I even go through google blog search and pick up random bloggers saying "I tried Haskell last weekend" and so on, and leave a remark for them to come here. :)
19:05:11 <lambdabot> Done.
19:05:37 <LoganCapaldo> Is there really a Haskell, TX? I hope so
19:05:45 <ddarius> @google "Haskell, TX"
19:05:48 <lambdabot> http://www.co.haskell.tx.us/
19:05:58 <Binkley> there's a Haskell Street in Oakland
19:06:17 <Binkley> in Berkeley, I correct myself
19:06:24 <monochrom> ClaudiusMaximus: stateful functions? (s,F)->(s,F)?
19:06:32 <ClaudiusMaximus> monochrom: yeah
19:06:37 <ricky_clarkson> A land of no side-effects and where an invisible entity, known as the Compiler, picks on your grammar.
19:06:53 <LoganCapaldo> http://maps.google.com/?q=Haskell,%20Haskell,%20Texas,%20United%20States
19:06:55 <lambdabot> Title: Google Maps, http://tinyurl.com/36puag
19:07:00 <monochrom> Then (s,((s,F)->(s,F))) does not look like (s,F)->(s,F)
19:07:13 <ClaudiusMaximus> monochrom: the first s is the initial state
19:07:17 <LoganCapaldo> So can we have some kind of Haskell conference there?
19:07:31 <ricky_clarkson> Oh look, a lambda farm.
19:07:45 <Binkley> we'd have to go to Texas for that
19:07:52 <Cale> It has such imaginative street names.
19:07:55 <ddarius> Only 140 miles away.
19:08:01 <dons> google blog search is great
19:08:04 <monochrom> With the given information and desire, there should be no problem.
19:08:04 <ClaudiusMaximus> it works if i have just one type of s in the code, but as soon as i try to use it twice it explodes
19:08:12 <ClaudiusMaximus>   cF2F' c "z" (0,\(s,f)->(f,s))
19:08:12 <ClaudiusMaximus>   cF2F' c "zz" ((0,0),\((s,s''),f)->((f,s),s''))
19:08:32 <ClaudiusMaximus> ^^ that makes the compiler angry
19:08:33 <ddarius> Binkley: I wouldn't go to Texas for that and I'm already in Texas.
19:08:42 <Binkley> haha
19:08:46 <ricky_clarkson> dons: I have a blog alert on my name, and get shite about Ricky Martin and Kelly Clarkson.
19:08:52 <dons> this is the url I use, http://www.google.com.au/blogsearch_feeds?hl=en&c2coff=1&lr=lang_en&safe=off&scoring=d&q=haskell+programming+OR+language&ie=utf-8&num=50&output=rss
19:08:53 <lambdabot> http://tinyurl.com/33fgh4
19:08:57 * LoganCapaldo wonders if there are any Indian restuarants in Haskell
19:09:16 <dons> also http://programming.reddit.com/search.rss?q=haskell&s=new is good
19:09:28 <dons> http://lambda-the-ultimate.org/node/feed
19:09:36 <Binkley> there was an Indian restaurant in Berkeley called Curry in Hurry that had to change their name for legal reasons
19:09:38 <ddarius> LoganCapaldo: If by Indian you mean Native American, probably not.  If you meant India, I can almost guarantee you a no.
19:09:42 <Binkley> and they put up a sign asking for suggestions for new names
19:09:46 <Binkley> I suggested "Curry and Uncurry"
19:09:51 <dons> heh
19:09:53 <monochrom> What is that c? Your type signature says the first param should be string, why is "z" not the first param? Sorry for cross-examining you but that's what a compiler does too, except I elaborate.
19:10:04 <dons> http://haskell.org/haskellwiki/Haskell_Cafe_migration
19:10:05 <lambdabot> Title: Haskell Cafe migration - HaskellWiki
19:10:10 <dons> so given the list of mailing list `ok' people
19:10:18 <dons> are there any memorable posts from the past we should raid?
19:10:25 <ddarius> dons: Almost certainly.
19:10:45 <dons> Jerzy's zen post recently was a candidate for the humour section
19:10:47 <ClaudiusMaximus> monochrom: c is a record with all the combinators in; i have similar stuff with different numbers of inputs and outputs
19:10:47 <ddarius> Why is the order different?
19:10:51 <dons> Claus Reinke's written some great things
19:10:58 <dons> one about mutable variables springs to mind
19:11:02 <dons> sigfpe too
19:11:11 <ddarius> I have a really old one about ShowS
19:11:22 <monochrom> So the type signature of cF2F' is knowingly wrong?
19:11:39 <ddarius> monochrom: It's more challenging that way.
19:11:41 <ClaudiusMaximus> monochrom: yeah, i simplified for irc...
19:11:49 <ClaudiusMaximus> sorry
19:11:52 <monochrom> OK. I'll pick on something else...
19:12:05 <monochrom> \(s,f) -> (f,s)  is very disturbing.
19:12:37 <ddarius> :t snd &&& fst -- bothers me every time
19:12:41 <lambdabot> forall a b. (a, b) -> (b, a)
19:13:03 <ClaudiusMaximus> basically i'm trying to have functions with state, and each function has it's own type of state, eg "z" has state F, and "zz" has state (F,F)
19:13:40 <LoganCapaldo> :t curry $ flip (,)
19:13:42 <lambdabot> forall a b a1. a -> b -> a1 -> (a1, (a, b))
19:13:45 <monochrom> You want a repository of functions, but they have different types?
19:13:51 <Cale> :t uncurry (flip (,))
19:13:53 <lambdabot> forall b a. (a, b) -> (b, a)
19:14:06 <LoganCapaldo> why do I always get curry and uncurry backwards?
19:14:10 <ddarius> dons: http://www.haskell.org/pipermail/haskell-cafe/2003-June/004473.html
19:14:11 <lambdabot> Title: powerset, http://tinyurl.com/3bn7b3
19:14:32 <ClaudiusMaximus> well, it gets even more complicated at this point, i think i should paste the code...
19:14:44 <ddarius> That said I think I already put a similar discussion on HaWiki a long long time ago.
19:15:26 <fizzbuzz> @pl \x y -> x y
19:15:26 <lambdabot> id
19:15:30 <monochrom> It takes advanced techniques to have a repository of things having different types. And which advanced technique to use depends sensitively on what you are willing to give up.
19:16:06 <fizzbuzz> @pl \ n d -> mod n d==0
19:16:07 <lambdabot> flip flip 0 . ((==) .) . mod
19:16:07 <ddarius> Sanity for you or sanity for your users.
19:16:35 <monochrom> Haha, naw, I only mean how much information you're ready to kiss good-bye.
19:16:55 <dons> ddarius: so the issue would be deciding what current pages get elaborated with this info
19:17:04 <LoganCapaldo> :t ((== 0) .) .) mod
19:17:06 <lambdabot> parse error on input `)'
19:17:12 <dons> hmm, we could also stick them on the 'blog post' categories
19:17:23 <LoganCapaldo> :t ((== 0) .) . mod
19:17:24 <dons> if we don't want to create new pages for self-contained posts
19:17:25 <lambdabot> forall a. (Integral a) => a -> a -> Bool
19:17:45 <ddarius> dons: Since finding this stuff can be a pain, a To Integrate page (or maybe just a page of Good Mailing List Posts) may be prudent.
19:17:53 <LoganCapaldo> I guess pl doesn't speak sections?
19:17:59 <ddarius> With a link to the archive.
19:18:36 <fizzbuzz> parens were unbalanced
19:18:51 <LoganCapaldo> I know
19:19:11 <LoganCapaldo> I was wondering why @pl spat out that flip flip 0 ... ridiculousness
19:19:29 <Pupeno> dons: maybe it would be good to add a footer to the mailing list: "Found this mail useful? http://haskell.org/haskellwiki/Haskell_Cafe_migration"
19:19:30 <lambdabot> Title: Haskell Cafe migration - HaskellWiki
19:19:50 <dons> ddarius: yes, i'm imagining we just plug them under the existing blog articles categories, for small things
19:19:52 <fizzbuzz> oh, right
19:19:55 <dons> larger things go on a 'to integrate' page
19:20:04 <dons> and either get a page of their own, or merged in somewhere relevant
19:20:19 <dons> Pupeno: good idea
19:20:38 <dons> i think when signing up for haskell-cafe@ you should agree to licensing your submissions...
19:20:49 <dons> that seems logical these days. 
19:21:00 <ddarius> dons: Not unreasonable, but what about everyone already signed up?
19:21:23 <dons> yeah. IANAL
19:21:45 <monochrom> Don't you hate the limitations of current notions of fair use. :)
19:22:38 <dons> considering all mailing list material is archived on haskell.org anyway, right next to the wiki repo
19:22:50 <dons> and we're simply mv foo.mail ~/wiki/new_page
19:22:52 <dons> ..
19:23:35 <dons> the boundaries are rather blurred here
19:23:50 <dons> since the wiki is only one step up from say, gmane's view of the mailing list
19:24:00 <dons> adding the ability to edit text after the fact
19:24:53 <ddarius> Linking to the email archive would be quite all right (and is already done quite a bit on the wiki)
19:25:32 <Binkley> yeah, that seems like a good solution. just link to mailing list posts instead of copying them
19:25:42 <dons> the good stuff needs copying though
19:25:58 <dons> its not first class while its in the archive
19:26:12 <ddarius> dons: I agree, but at the least we can index the good stuff for now.
19:26:17 <Pupeno> it probably needs copying and refactoring.
19:26:34 <Pupeno> and once it is copied it is liked to be improved, while that's impossible in the mailing list.
19:27:08 <dons> yep. and for those who've put their name up, we can pull the text in
19:27:14 <dons> oleg's stuff is a similar case.
19:27:26 <dons> not clearly licensed on his ftp site.
19:27:32 <dons> so i tend to create a page, then link to his page.
19:27:41 <hpaste>  ClaudiusMaximus pasted "is sanity an option?" at http://hpaste.org/1663
19:29:17 <SamB> dons: where do I put my name in ? not that I'm liable to say much worth copying
19:29:47 <seanmce> does anyone mind commenting on a java framework I'm working on with some ideas that I got from haskell?
19:29:48 <dons> http://haskell.org/haskellwiki/Haskell_Cafe_migration
19:29:49 <lambdabot> Title: Haskell Cafe migration - HaskellWiki
19:30:06 <dons> seanmce: sure! do you have the design written up somewhere?
19:30:19 <seanmce> Here's a sample: http://dbapi.cvs.sourceforge.net/dbapi/java-hweb/src/hweb/example/BookmarksServlet.java?revision=1.3&view=markup
19:30:22 <lambdabot> Title: SourceForge.net Repository - [dbapi] View of /java-hweb/src/hweb/example/Bookmar ..., http://tinyurl.com/2syd2c
19:30:23 <SamB> dons: is there some blanket place I can put my name where you can copy anything not nailed down?
19:30:27 <kfish> dons: what about stuff written on IRC, or hpaste? ;-)
19:30:37 <Cale> ClaudiusMaximus: That certainly looks complicated -- could you explain a bit more about what the overall goal is?
19:30:39 <dons> yes, hpaste is another example
19:30:49 <dons> i've written e.g. bytestring / C demos on hpaste
19:30:53 <dons> it would be nice to import anything you do there
19:31:09 <dons> maybe i should revise the page to give blanket approval for all media controlled by haskell.org :)
19:31:10 <ClaudiusMaximus> Cale: embedding Haskell into an object oriented program written in C
19:31:21 <ddarius> Yes, quick.  Make explicit the licensing of all public Haskell fora.
19:31:21 <Binkley> haskell.org controls the horizontal, haskell.org controls the vertical
19:31:38 <SamB> ClaudiusMaximus: I know exactly what your problem is ;-P
19:31:52 <ClaudiusMaximus> SamB: heh
19:31:55 <ddarius> dons: You can't do that now without talking to the people who've already put their names on the list.
19:32:01 <dons> i know. hmm
19:32:02 <ddarius> In theory.
19:32:13 <dons> perhaps we should revise it just a bit?
19:32:23 <dons> and contact people -- they're all here anyway
19:32:29 <Cale> ClaudiusMaximus: Embedding as in runtime code generation?
19:32:33 <ddarius> Yeah, it should be easy enough to talk to the people.
19:32:34 <SamB> ClaudiusMaximus: do you know exactly what your problem is?
19:32:37 <dons> and things like hpaste should state that you've handed over copyright tothe code
19:32:40 <SamB> dons: you could put a heading further down
19:32:47 <kfish> ie. raise the licensing approval to a polymorphic type?
19:32:50 <SamB> and have people move their names down to another list
19:32:52 <Cale> ClaudiusMaximus: Or is it okay to have to write Haskell code separately and compile it with GHC first?
19:32:52 <sjanssen> dons: do you really want to do that?
19:33:04 <sjanssen> dons: what if I want to paste a short snippet of ghc (GPL licensed)
19:33:12 <Binkley> ghc is actually BSD licensed :-)
19:33:13 <SamB> dons: I think it should be a checkbox
19:33:15 <sjanssen> oh
19:33:39 <sjanssen> Binkley: okay, assume some snippet of GPL code
19:33:57 <Binkley> yeah, the point is that you might want to paste code that you aren't the copyright holder for
19:34:34 <ClaudiusMaximus> Cale: hmm.  not sure, but i have something working now that uses hs-plugins at runtime to load new scripts, i'm trying to make it so that those scripts aren't so verbose and repetitious
19:34:52 <Cale> I think it's simplest just to have pasters own the copyright on their pastes, but they give hpaste.org the right to display the paste.
19:35:34 <Cale> (well, assuming that they are the copyright holders in the first place)
19:35:42 <Binkley> let's just declare the Haskell community a lawyer-free zone, that would be easiest :-)
19:36:19 <SamB> Binkley: I think there might be laws against that
19:36:37 <SamB> lawyers unfortunately being the people who make laws...
19:37:22 <Binkley> heh
19:37:58 <dons> http://haskell.org/haskellwiki/Haskell_Cafe_migration
19:37:59 <lambdabot> Title: Haskell Cafe migration - HaskellWiki
19:38:51 <dons> sjanssen: its just that if you post something without a clear license, to hpaste, the mailing list, or other haskell media, it can be treated as `simple permissive license'
19:38:55 <dons> and its strictly opt-in
19:38:58 <Korollary> parts of hierarchical libs have GPL licenses iirc
19:39:31 <Binkley> I'm not sure it's kosher to change what you're agreeing to by signing on the wiki page after people have already signed it
19:39:43 <Binkley> *edits wiki to say 'Sign this if you agree to give Binkley your firstborn'* :-)
19:39:44 <dons> yes, hence we're contacting those people now. like you Binkley !
19:40:08 <dons> we have a chance now to include hpaste, which we meant to originanly. so may as well
19:40:17 <dons> since these opportunities don't come up very often
19:40:21 <Binkley> personally, I give consent for my various witty remarks to be used anywhere on these here interwebs
19:40:27 <dons> cool :)
19:40:28 <SamB> I'm glad that it says "your contributions"
19:41:04 <|Steve|> Just these? What about other interwebs?
19:41:34 <dons> kfish, Binkley, ddarius, cdsmith , allbery_b : is the new clause ok? http://haskell.org/haskellwiki/Haskell_Cafe_migration
19:41:35 <lambdabot> Title: Haskell Cafe migration - HaskellWiki
19:41:41 <dons> (basically covers hpaste too)
19:42:05 <dons> is the wording ok?
19:42:09 <Binkley> it's all good
19:42:11 <dons> Cale too, opinions?
19:42:20 <SamB> it means what it should, maybe some clarification would be good
19:42:33 <dons> can you elaborate SamB ?
19:42:35 <SamB> perhaps "but not limited to" would be in order
19:42:47 <Cale> Meh, it's cool. If I put anything in any of those places, I'm not likely to care how people use it at all.
19:43:18 <SamB> as well as remarking that if I paste a snippet out of a GPL'd program, that doesn't magically become SPL'd...
19:43:20 <kfish> dons: yeah, cool
19:43:26 <Cale> So long as they don't end up losing money over bugs in my code and then trying to sue me ;)
19:43:38 <|Steve|> Is there a reason that licenses always HAVE THE FINAL BIT OF TEXT IN ALL CAPS?
19:43:40 <kfish> dons: though it nearly sounds like something rupert murdoch would write ;-)
19:43:49 <dons> yeah, just thought that :)
19:43:51 <SamB> |Steve|: for emphasis
19:44:14 <dons> all your code belongs to MegaCorp^h^h^h happy haskell.org
19:44:19 <kfish> dons: the open-ended definition of "haskell.org media" is a bit ...
19:44:22 <Cale> YOUR CODE IS NOT MERCHANTABLE!!!11  DO NOT WANT!!!11
19:44:25 <|Steve|> Is it less legally binding if they write like they aren't 13 year olds with thesauruses?
19:44:46 <Binkley> the other lawyers would laugh at them on the playground otherwise
19:44:49 <SamB> dons: it seems a bit silly to list the new wiki, given the notice at the bottom
19:44:58 <SamB> "Recent content is available under a simple permissive license"
19:45:00 <ddarius> dons: I think it would be helpful to add the "if not explicitly licensed otherwise" statement somewhere.
19:45:23 <ddarius> Though in practice I don't see that ever being an issue for me.
19:45:25 * Cale edits the simple permissive license to reassign all rights to him.
19:45:36 <SamB> Cale: you ... can't do that!
19:45:55 * ddarius edits the SPL to say that you agree not to edit the SPL.
19:46:02 <SamB> actually I seem right? unless you have special rights...
19:46:24 <Cale> I don't, of course :)
19:46:28 <SamB> there ain't no edit link on it
19:46:37 <allbery_b> ==ddarius, otherwise... seems to me if you post something publicly and don't explicitly copyright it you are more or less releasing control over it.  (as distinct from rights)
19:46:44 <cdsmith> dons: yeah, it's fine
19:46:50 <SamB> allbery_b: more or less...
19:46:52 <kfish> fwiw, i permit you all to buy a round of beer
19:46:53 <allbery_b> (and, well, if you don't want the world to read it, *don't post it*)
19:46:58 <SamB> we are trying for "more" ;-)
19:47:03 <Binkley> allbery_b: copyright doesn't require you to explicitly claim copyright
19:47:18 <allbery_b> binkley: I know, but still.
19:47:27 <ddarius> Clearly if I didn't want them to read it, I wouldn't post it, but what if it were part of some otherwised licensed project of mine?
19:47:49 <SamB> yes, that point does require clarification
19:47:59 <kilimanjaro> "Accordingly, computer scientists commonly choose models which have bottoms, but prefer them topless."
19:48:00 <allbery_b> ideally posting publicly cedes copyright to the "owner" of the public resource (in this case the haskell community) --- but that is kinda hard to formalize into law
19:48:06 <dons> ddarius: ok. 
19:48:13 <allbery_b> I mean, who swould stand for said community in court, if necessary?
19:48:19 <SamB> kilimanjaro: how is that different from regular guys?
19:48:24 <wli> Hmm. I can't figure out what to use as the get function for the MonadState instance.
19:48:38 <ddarius> dons: I'm not really worried about this actually being the case for anyone.
19:48:40 <Cale> 25057 cale      18   0  401m 231m  27m S  0.0 22.9 172:56.56 firefox-bin -- nope, no memory leaks there
19:48:40 <kilimanjaro> SamB, exactly :)
19:48:42 <allbery_b> copyright is kinda disjoint with reality
19:49:05 <dons> ok. added the 'and not specificailly licensed' clause. 
19:49:08 <|Steve|> And disjoint with licensing.
19:49:09 <kilimanjaro> Cale, it's not considered a leak until it breaks 600mB
19:49:10 <dons> which has been discussed a few times
19:49:26 <SamB> kilimanjaro: that's very arbitrary
19:49:27 <Cale> kilimanjaro: hehe
19:49:56 <allbery_b> but in any case if I say something in a reasonably public forum, the only things I ask are (a) attribution and (b) don't edit to change its meaning without contacting me.
19:50:03 <ddarius> SamB: No it's not.  That's why it's funny.  It's a reasonable, dead serious statement.
19:50:07 <SamB> allbery_b: even code?
19:50:19 <allbery_b> I don';t normally "say" code
19:50:41 <SamB> yes, but you might *contribute* it
19:50:46 <SamB> how do I use bold anyway?
19:50:46 <dons> allbery_b: are you happy with the expanded permission?
19:50:53 <allbery_b> in any case, code does follow different rules.  assume BSD license if not explicit :)
19:50:56 <allbery_b> dons: sure
19:50:57 <dons> good, that just leaves sorear and conor 
19:51:10 <SamB> allbery_b: assume SPL, you mean?
19:51:48 <allbery_b> ...not that I necessarily have anything useful to contribute to the haskell community given that I'm still learning myself (and not planning to write yet another monad bad analogy...)
19:51:50 <SamB> I guess it would have to be (exists a. SPL a => a)
19:52:15 <Binkley> I would say that *not* writing another monad bad analogy is a way of contributing to the community :-)
19:52:25 <ojacobson> Monads are chunks of procedural logic where each statement-analog may not be procedural
19:52:27 <SamB> Binkley: and to think!
19:52:27 <ojacobson> right?
19:52:35 <SamB> I copied that onto the Haskell wiki *months* ago!
19:52:47 <SamB> *without asking permission*
19:52:50 <SamB> so sue me!
19:52:59 <Binkley> ONOEZ
19:53:25 <dons> ojacobson: hmm. I probably wouldn't put it like that. some specific monads let you write chunks of code in an imperative fashion
19:53:42 <dons> others let you write chunks of code in a Prolog-like backtracking search fashion
19:53:52 <ojacobson> dons: ooo
19:54:11 <dons> my favourite view is that monads let you `reprogram' the ';' operator of imperative programming, to do all sorts of interesting effects
19:54:38 * dolio should put together logict-0.2.1
19:55:01 <SamB> so, does anyone know anyone who knows what StrategyLib is?
19:56:34 <allbery_b> (this kind of thing isn't especially new to me btw, I've already given permission for stuff I say in #lopsa to be used, since I often field lots of interesting sysadmin-related questions --- perfectly reasonable to me that someone might want to save the answers...)
19:56:36 <dons> SamB: see the paper from ICFP (or HW) last year (or the year before)
19:58:12 <mm_freak> hmmâ¦  `factor' in C is still much faster than my own factorizer, using exactly the same technique
19:58:52 <mm_freak> it needs about 380 ms, while the haskell equivalent needs about 1800 ms
19:58:56 <SamB> dons: I don't know what names the modules ought to have ...
19:58:56 <dmwit> ?hoogle (a -> b) -> (a -> m b)
19:58:57 <lambdabot> No matches, try a more general search
19:59:05 <wli> dons: I think of them like the implicit predicate arguments in DCG's.
19:59:09 <mm_freak> http://streitmacht.eu/test.hs
20:01:10 <dons> the thread on `money types' is another that should be summarised on the wiki
20:01:12 <dons> ddarius: ^^
20:02:03 <dons> mm_freak: you want some help optimising it?
20:02:26 <mm_freak> dons: yeah, some ideas
20:02:28 <dons> mm_freak: first off, how are you compiling that code?
20:02:33 <soduko> hi, is Cale  in today?
20:02:37 <soduko> uh oh..
20:02:46 <mm_freak> with GHC, using -O2
20:02:57 <dynamix> msg NickServ IDENTIFY marirs
20:02:57 <allbery_b> @seen Cale
20:02:57 <lambdabot> Cale is in #haskell, #haskell-overflow, #ghc and #oasis. I last heard Cale speak 13m 30s ago.
20:03:05 <allbery_b> ooooops///
20:03:08 <dons> mm_freak: what's an example input that gives a noticeable slowdown?
20:03:22 <mm_freak> dons: 1958361962210867
20:03:33 <mm_freak> that's 34199611 * 57262697
20:03:44 <dons> ok. I'm looking at the code now.
20:04:06 <mm_freak> or more generally:  a composite number with few prime factors
20:04:15 <ddarius> dons: ?
20:04:20 <dons> yes, so 1.9s on this machine. 
20:04:27 <dons> now let's see if we can't improve that
20:04:37 <dons> ddarius: oh, the `money type' thread should go on the wiki :)
20:04:51 <hpaste>  dynamix pasted "(no title)" at http://hpaste.org/1664
20:05:38 <mm_freak> dons: i'm concerned about the `where m = div n f' part
20:05:42 <Cale> allbery_b: hi
20:05:54 <Cale> dynamix: hi
20:05:58 <mm_freak> it looks like it's evaluating this before doing anything else
20:06:14 <dons> ah ok. let's see...
20:06:58 <wli> Maybe I'm better off just passing the state as an arg to State
20:07:00 <Cale> It might be worthwhile writing a proper integer square root algorithm?
20:07:05 <mm_freak> dons: but when i remove the where clause and write "div n f" explicitly in the first recursive case, then the whole thing gets even slower
20:07:31 <dynamix> Cale: hi, i just pasted my attempt at the monad solution..  for nested lookup
20:07:32 <mm_freak> cale: that's slower
20:07:44 <dynamix> Cale: http://hpaste.org/1664
20:08:07 <Cale> dynamix: okay...
20:08:22 <dynamix> Cale: should we go to the overflow room?
20:08:24 <mm_freak> one bottleneck is that i don't check the argument n for primality
20:08:25 <Cale> sure
20:08:25 <dolio> wli: I'd recommend that over implementing a custom state monad.
20:09:02 <dolio> wli: Then use 'gets <selector>' to get the right map, if you only want one.
20:09:12 <Pupeno> Why can't I turn      func2' f g l = filter f $ map g l      into    func2' f g = filter f $ map g   ?
20:09:15 <dons> slightly stricter 'factors' seems to help generate a proper unboxed worker,
20:09:17 <dons>   factors !n !s !f x@(w:ws)
20:09:20 <dons> {-# OPTIONS -fbang-patterns -O2 -fvia-C -fexcess-precision -optc-O2 -optc-ffast-math -optc-march=pentium4 #-}
20:09:38 <wli> dolio: looks like it, yeah.
20:09:39 <dons> but nothing dramatic. I think you'll need to look at better algorithms first off
20:09:45 <SamB> dons: what if he doesn't *have* a P4?
20:09:49 <dons> it would be interesting to see the C.
20:09:56 <dons> SamB, he'll come to your house, and beat you up!
20:09:57 <mm_freak> hmm
20:09:58 <mm_freak> let me try
20:10:05 <SamB> dons: but mine is only 1.7 GHz
20:10:31 <Saizan> Pupeno: because ($) :: (a -> b) -> a -> b, and filter f  wants an [a] not a [a] -> [a]
20:10:35 <dons> mm_freak: often translating the C directly gives the best results i these low level cases
20:10:42 <dons> since you really want to generate pretty much the same code
20:10:49 <dons> and for example, avoid building lazy lists
20:11:00 <dons> when all you want to do is produce 2 Word64s at the end
20:11:19 <Saizan> Pupeno: you have to use (.) :: (b -> c) -> (a -> b) -> a -> c
20:11:31 <mm_freak> dons: which lazy list should i avoid?  the wheel or the result?
20:11:33 <Saizan> ?type \f g -> filter f . map g
20:11:34 <lambdabot> forall a b. (b -> Bool) -> (a -> b) -> [a] -> [b]
20:11:43 <dons> mm_freak: btw, http://www.cse.unsw.edu.au/~dons/code/nobench/spectral/primes/
20:11:43 <lambdabot> Title: Index of /~dons/code/nobench/spectral/primes
20:11:46 <mm_freak> i thought, the wheel is no performance problem
20:11:53 <dons> is a collectoin of other prime sieves of various kinds
20:12:04 <SamB> okay, now that I've implemented "foreign import dynamic" and reimplemented "foreign export" (I'm not sure how well implemented it could have been before, considering the apparant lack of type information...), I wonder how I'd have to go about implementing "foreign import wrapper"
20:12:06 <dons> a few wheel sieves, and some others. might give some hints
20:12:39 <mm_freak> dons: i know there are better algorithms, but it's code performance i want to improve, not algorithm performance
20:13:02 <mm_freak> and let me say, it's already pretty fast
20:13:11 <mm_freak> just not as fast as it _could_ be
20:13:13 <dons> where's the C code you're emulating?
20:13:39 <SamB> it's sure to be far more involved...
20:14:00 <mm_freak> dons: it's the `factor' program from the core utils
20:14:05 <mm_freak> it uses exactly the same algorithm
20:14:17 <dons> oh, you could manually do the worker / wrapper wheel argument split
20:14:19 <mm_freak> an array of summands building up a 2*3*5 wheel
20:14:21 <dons> that's a redundant test. let's see.
20:14:30 <dons> do you have the .c file online somewhere?
20:14:31 <SamB> I bet it'd need an extra-special primitive
20:14:54 <mm_freak> gimme a sec
20:15:29 <Pupeno> And now why can't I turn          func2 f g = (filter f . map g)      into          func2 f g = (filter f . map) g    ?
20:16:11 <dons> yes, that fixes things a bit
20:16:15 <dons> down to 1.6s
20:16:45 <mm_freak> dons: what did you do?
20:16:59 <Saizan> Pupeno: because the first is (filter f) . (map g), and because fo the type of (.)
20:17:08 <hpaste>  dons pasted "move empty list check out" at http://hpaste.org/1666
20:17:11 <dons> ~^^
20:18:07 <dons> hmm, is 'f' even used . that's a bit weird
20:18:28 <mm_freak> ahâ¦  pretty interesting
20:18:36 <mm_freak> yes, f is the factor to check against
20:18:40 <dons> yes, faster again
20:18:58 <dons> you're initial f=0 value is unused though
20:19:01 <ojacobson> Saizan: (.) is (a -> b) -> (b -> c) -> (a -> c), right?  (Noob, learning, trying to remember everything)
20:19:06 <dons> you just set it to '2' first time around
20:19:06 <ojacobson> :t (.)
20:19:07 <Saizan> Pupeno:  (.) :: (b -> c) -> (a -> b) -> a -> c, f . g = \x -> f (g x) so  \x -> filter f (map x) is a type error because map x is not of type [a]
20:19:12 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
20:19:17 <Pupeno> so, if I had a (.) equivalent, with signature (b -> c) -> (a -> x -> b) -> a -> x -> c, then I could do it?
20:19:18 <ojacobson> Saizan: damn, I was close
20:19:42 <hpaste>  dons annotated "move empty list check out" with "uneeded argument" at http://hpaste.org/1666#a1
20:19:43 <mm_freak> dons: true, in the outer factors function, it's not used
20:19:52 <mm_freak> actually it just needs a number and produces a list
20:19:59 <Saizan> Pupeno: exactly, but it happens that you can write that using multiple (.)
20:20:00 <dolio> @type (.) . (.)
20:20:02 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
20:20:14 <Saizan> as dolio spoiled to you :)
20:20:21 <dolio> Oh, sorry.
20:20:25 <dons> yes
20:20:45 <Pupeno> ojacobson: if it had the signature you first proposed, then f (y x) should we written (y . f) x, which may be counter intuitive.
20:20:56 <ojacobson> Pupeno: agree
20:21:19 <brad_> offhand comment - haddock, very touchy
20:21:19 <Pupeno> ojacobson: the function is intuitive, but the signature isn't.
20:21:27 <SamB> hmm, so, what should I do with JHC now that I've implemented foreign export and foreign import dynamic? note: I'd rather prefer it not involve *using* either of them
20:21:36 <brad_> so much it wants escaped, so much it chokes on
20:21:55 <Saizan> Pupeno: let comp2 = (.) . (.) in filter f `comp` map would work, but tou can write it in a nicer way with a section: (filter f .) . map
20:22:27 <Saizan> s/comp2/comp/
20:22:44 * dolio isn't sure how much 'nicer' that is in practice. :)
20:22:54 <hpaste>  _dml pasted "monadic parser" at http://hpaste.org/1667
20:23:06 <Saizan> it's still quite readable :)
20:23:19 <_dml> any ideas why my word' always outputs '[]'?
20:23:20 <SamB> brad_: at least it seems to report source positions
20:23:22 <mm_freak> dons: i get a syntax error at "!n", and it doesn't recognize -fbang-patterns
20:23:23 <dolio> Clearly we should all be using Oleg's polyvariadic function composition. :)
20:23:23 <Pupeno> Saizan: for you.
20:23:33 <dons> mm_freak: oh, you've got an old ghc?
20:23:41 <SamB> it would be nice if it could continue and report more errors, though
20:24:16 <mm_freak> % ghc --version
20:24:16 <mm_freak> The Glorious Glasgow Haskell Compilation System, version 6.4.2
20:24:17 <Saizan> Pupeno: yeah, at first it was just line noise for me too, both types and manual expasion helps understanding, though
20:24:33 <mm_freak> version 6.6 is masked in the portage tree, i.e. marked as unstable
20:24:48 <dolio> SamB: It is a bit of a pain if you have a large comment block. It doesn't report the position within the comment, just the end.
20:24:56 <dons> mm_freak: ok. you can either grab ghc 6.6 or 6.6.1, or 
20:24:57 <dons> factors' n s f x@(w:ws)
20:24:57 <dons>   | n `seq` s `seq` f `seq` False = undefined
20:24:57 <dons>   | f > s        = [n]
20:25:06 <SamB> @let boobies = (.) . (.)
20:25:09 <dons> add that '`seq` clause, which provides strictness hints to the compiler
20:25:09 <lambdabot> Defined.
20:25:09 <SamB> :t boobies
20:25:11 <lambdabot> Not in scope: `boobies'
20:25:19 * SamB wishes that were implemented
20:25:22 <dons> ghc 6.6.x will do a better job optimising the code anyway
20:25:27 <dons> so it would be worth upgrading
20:25:33 <mm_freak> dons: ok, thanks
20:25:44 <SamB> :t (.) . (.)
20:25:46 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
20:26:22 <hpaste>  norgul pasted "(no title)" at http://hpaste.org/1668
20:26:29 <monochrom> Opening your computer to debian/unstable is highly recommended for getting ghc debs.
20:26:54 <dons> mm_freak: probably should combine the div and mod ops 
20:26:54 <SamB> dolio: oh?
20:26:56 <Pupeno> monochrom: you can "get" unstable debs without running a unstable distro.
20:27:15 <mm_freak> dons: i've split it into factors and factors', and added the seqs, but it's just as fast as before
20:27:15 <Pupeno> is   func3 f l = l ++ map f l    convertible to point-free?    I believe it is not.
20:27:16 <SamB> Pupeno: you can open your computer to them without making them the default, too
20:27:20 <monochrom> Although, I don't take that advice myself. I use the "generic binary" and put it in /usr/local.
20:27:35 <monochrom> Yeah, I left the meaning of "open" open. :)
20:27:40 <mm_freak> dons: can't combine them efficiently
20:27:42 <SamB> % cat /etc/apt/apt.conf
20:27:46 <SamB> Apt {
20:27:46 <SamB>   Default-Release "testing";
20:27:46 <SamB> }
20:27:59 * SamB notes that this is a somewhat abbreviated listing
20:28:08 <dons> mm_freak: yes, I note divMod slows it down a bit
20:28:10 <dons> :t divMod
20:28:12 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
20:28:14 <Pupeno> SamB: Doesn't that fail until you have one package wich depends on one package which and so on untill you touch libc, or glib, or something basic and kaboom!
20:28:26 <mm_freak> dons: yes, because the div is just needed for the first recursive case
20:28:30 <SamB> Pupeno: huh?
20:28:34 <mm_freak> otherwise only mod is needed
20:28:36 <Pupeno> sorry.
20:28:46 <Pupeno> SamB: Doesn't that fail until you have one package wich depends on one package which and so on untill you touch libc, or glib, or something basic and kaboom!
20:28:53 <monochrom> I think we're all in agreement.
20:28:56 <Pupeno> s/fail/work/
20:29:01 <SamB> ah, better
20:29:23 <mm_freak> m = div n f `seq` div n f
20:29:25 <SamB> of course it can't work miracles
20:29:26 <mm_freak> doesn't help either
20:29:47 <monochrom> It can't fail miracles either.  (duck)  :)
20:29:56 <Pupeno> SamB: in my experiencie, if you recompile the debs, you get better resoults... or maybe I've just used Gentoo for too long.
20:30:16 <SamB> but actually installing libc from unstable does *not*, contrary to popular belief, make your computer go *boom*
20:30:17 <monochrom> Gentoo is mind-polluting.
20:30:54 <monochrom> I have this funny intuition that Gentoo advocates are assembly language programmers.
20:31:01 <hpaste>  dons pasted "tunign a bit (1.58s)" at http://hpaste.org/1669
20:31:03 <dons> mm_freak: ^^ that's using ghc 6.6 (which might be relevant here)
20:31:33 <Saizan> ?type ap (++) . map
20:31:34 <lambdabot> forall b. (b -> b) -> [b] -> [b]
20:32:00 <mm_freak> dons: interesting ideaâ¦  i'll check that out
20:32:02 <Pupeno> SamB: the problem is, any dependency that has enough dependencies will make half of your computer upgrade... everytime I've tried it detroyed the installation.
20:32:03 <Saizan> > (ap (++) . map) (+1) [1..3]
20:32:04 <lambdabot>  [1,2,3,2,3,4]
20:32:18 <SamB> Pupeno: really?
20:32:31 <SamB> you must have tried it with the wrong packages
20:32:57 <SamB> actually probably the worst time I had was upgrading to Xorg 7, and I think that was in *testing*
20:33:12 <monochrom> Perhapd ghc6* and libghc6-* behave better.
20:35:37 <JohnMeacham> SamB: what does actuallySpecializeE do? as in, what does actually refer to?
20:35:39 <mm_freak> dons: is the MTL part of ghc 6.6 ?
20:36:00 <SamB> JohnMeacham: it specializes an expression from one type to another type
20:36:32 <dons> mm_freak: its a library, usually comes by default (but its on hackage.haskell.org if you need it)
20:36:34 <monochrom> mm_freak: No. Look for libghc6-mtl-* or something that says both libghc6 and mtl
20:36:35 <dons> ?hackage mtl
20:36:36 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mtl
20:36:44 <JohnMeacham> okay. I thought I already had a routine to do that, or was it not appropriate?
20:37:01 <SamB> you had a routine, specializeE, that says *how* to do it
20:37:05 <mm_freak> i'm asking because ghc-6.6 blocks the mtl package
20:37:10 <mm_freak> in gentoo
20:37:27 <monochrom> will ghc-6.6.1 be better?
20:37:30 <JohnMeacham> ah. I see. it is a wrapper around it.
20:37:33 <JohnMeacham> cool.
20:37:40 <mm_freak> monochrom: actually i mean 6.6.1
20:37:52 <mm_freak> [ebuild     U ] dev-lang/ghc-6.6.1 [6.4.2] USE="doc -binary% -ghcbootstrap% (-X%*) (-openal%*) (-opengl%*) (-test%)" 29,760 kB 
20:37:55 <mm_freak> [blocks B     ] >=dev-lang/ghc-6.6 (is blocking dev-haskell/mtl-1.0)
20:37:56 <monochrom> Alright. I admit failure.
20:38:07 <JohnMeacham> SamB: cool! thanks for all your work. 
20:38:16 <mm_freak> monochrom: no my failure, since i was not precise enough
20:39:01 <monochrom> mtl-1.0 sounds old. mtl-1.0.1 is around spreading around.
20:39:22 <SamB> JohnMeacham: you're welcome. I was taking a break from trying to figure out the design for my PDP-1 emulator ;-)
20:39:27 <mm_freak> yeah, i'll check if upgrading mtl fixes it
20:40:56 <mm_freak> yes, it does
20:41:04 <JohnMeacham> ooh. jhc needs a PDP back end.
20:41:11 <monochrom> Yippee!
20:41:14 <SamB> not for the PDP-1 it doesn't.
20:41:31 <SamB> can JHC deal with a three-character limit on symbols?
20:42:28 <JohnMeacham> I'll work on it... 
20:42:55 <mm_freak> now using bang patterns makes the code completely unportable
20:43:05 <SamB> (or 18-bit ones' complement arithmatic?)
20:43:12 <monochrom> haha
20:43:13 <SamB> (or a 4096 word memory?)
20:43:42 <SamB> JohnMeacham: perhaps you should simply port it to pre-ANSI C
20:44:03 <dmwit> AWESOME
20:44:04 <SamB> with no automatic inlining
20:44:12 <dmwit> WASH stores its persistent data in /tmp
20:44:20 <SamB> dmwit: ... okayt
20:44:31 <dmwit> yeah
20:44:33 <SamB> /var would be better
20:44:39 <dmwit> No kidding!
20:44:47 <geezusfreeek> wow
20:45:05 <dmwit> Especially since that thing gets nix'd every time the compy goes down.
20:45:26 <dons> mm_freak: but yes, i'd also look at an int sqrt. that conversion to Double seems wasteful
20:46:30 <SamB> JohnMeacham: now here's something to puzzle you:
20:46:46 <mm_freak> dons: that's how i would do it in C, because it then needs only three instructions, namely FILD, FSQRT and FIST
20:47:04 <mm_freak> while the integer-sqrt would need a complete algorithm
20:47:11 <SamB> how would we add "foreign import wrapper" support?
20:50:24 <SamB> the easy part is dynamically generating stubs that would hold a StablePtr to the wrapped function, and pass that along with the other arguments to (a C function which would apply all of the arguments to the function refered to by the StablePtr)
20:50:51 <SamB> the hard part is making such a C function :-(
20:51:27 <JohnMeacham> SamB: yeah. I don't think that can easily be done portably.
20:51:47 <SamB> JohnMeacham: notice that I had the non-portable part down as the *easy* part
20:52:30 <SamB> actually I could cop a program from qemu to help with that...
20:52:46 <JohnMeacham> well, you would just need one for each set of types used i think...
20:52:56 <SamB> one what?
20:53:03 <SamB> oh, wrapper?
20:53:04 <SamB> yeah.
20:53:30 <SamB> but I'm thinking the hard part is figuring out how to represent the wrapper function...
20:53:31 <JohnMeacham> but yeah, it would have to be a little self-modifying code.
20:54:17 <JohnMeacham> so you would need a little machine specific wrapper that throws an extra argument onto the stack. shouldn't be too hard, but you would need machine specific bits.
20:54:20 <SamB> I'm thinking it would require at least a primitive, possibly a language construct
20:54:28 <JohnMeacham> the trampoline paper for gcc would show how.
20:54:51 <SamB> I was thinking that a machine-specific wrapper that throws an argument onto the stack would be the nice way
20:55:15 <SamB> but it only works for purely stack-based calling conventions
20:55:22 <SamB> but anyway that part isn't what bothers me
20:55:58 <JohnMeacham> yeah, but you can allocate the trampoline on the heap just as well. but it can't reference anything in the stack, which makes for tricky region inference. I am in no hurry to support them.
20:56:00 <SamB> the part that bothers me is how you represent this in E and in Grin
20:56:26 <JohnMeacham> Oh, just a primitive should do. it would have to take and return a world argument. 
20:56:34 <SamB> oh, region inference eh?
20:56:41 <JohnMeacham> anh you would want to pass in a fully deboxed version of the function.
20:56:58 <SamB> yes.
20:57:05 <araujo> hello
20:57:12 <dmwit> Hiya!
20:57:37 <SamB> is grin higher-order then?
20:57:44 <JohnMeacham> but in the end, it will just end up being a closure. there is a grin primitive for that, though, I have not used it for anything yet.
20:58:16 <JohnMeacham> no. but there won't be a need, it would end up being a partial application node, not a first class function.
20:58:18 <jre2> any suggestions for how to go about debugging a problem with my stm based server?
20:58:40 <SamB> ah. fine.
20:58:46 <brad_> i have a hackage question: i am exposing a new toplevel name for my package Finance.Quote.Yahoo. is this such a big deal? i am getting a warning check from the hackage checker
20:59:18 <SamB> anyway, making a fully deboxed version of the function should be no problem ;-)
20:59:38 <SamB> I mean that's what I *just did*
20:59:59 <JohnMeacham> yeah. and the deboxing should all be visible in core, so it can be optimized away.
21:01:19 <JohnMeacham> translating to grin will  be tricky, actually, you probably don't want to use the grin closure mechanism, you would just need to generate an appropritae C stub. 
21:01:32 <SamB> so, do you think using a StablePtr would be useless?
21:01:54 <JohnMeacham> and have a small C function that allocates the trampoline, that you call like any other C function.
21:02:17 <SamB> yeah, I could cop that from GHC
21:02:24 <JohnMeacham> hmm.. well, stableptrs don't mean a lot at the moment, but they will once better garbage collectors are implemented.
21:02:40 <JohnMeacham> if I recall, the ghc implementation is needlessly complex. 
21:02:48 <SamB> hmm?
21:03:00 <SamB> okay, hugs then, but they seem to have only a few platforms supported...
21:03:11 <SamB> or make my own
21:03:25 <SamB> but that would be only for Intel
21:03:38 <SamB> (and AMD I guess ;-)
21:05:04 <JohnMeacham> well, in any case, it can be improved later.
21:05:25 <SamB> anyway I'm going to want to think about this for a while before I start trying to write any more code
21:05:28 <JohnMeacham> but the machine specific bits should be really small, like a couple instructions.
21:05:46 <SamB> yeah.
21:07:43 <mm_freak> dons: now implemented integer-sqrt
21:07:45 <mm_freak> still the same
21:07:55 <dons> code somewhere?
21:07:58 <dons> `I can safely conclude with 99%+ certainty that Haskell is hot air. It is no different than the Segway, or parallel computing'
21:08:01 <dons> hehe
21:08:12 <mm_freak> the sqrt should not make much difference anyway, because it's only used once for each factorization, of which there are as many as there are factors
21:08:17 <mm_freak> yes, sec
21:08:18 <Binkley> dons: where's that from?
21:08:27 <mm_freak> http://streitmacht.eu/test.hs
21:08:41 <dons> Binkley: oh, i'm hesitant to say, since i don't want to invoke the full wrath of #haskell on the poor guy
21:09:15 <dons> i like the touch at the end to add ` or parallel computing'.
21:09:17 <Binkley> haha
21:09:29 <dolio> Yeah, that's going nowhere.
21:09:59 <dons> mm_freak: ok, looking. 
21:10:03 <dons> i think we can do something here. 
21:10:09 <mm_freak> dons: as said, the sqrt function (should) be only used three times
21:10:22 <ddarius> Not like that OO, not at all.  Just look at where object-orientation has brought us.
21:10:24 <dons> mm_freak: also, you over parenthesise a bit :)
21:10:29 <mm_freak> once for factoring N, then for factoring N/P, and finally for factoring 1 =)
21:10:41 <mm_freak> dons: yeah, let me fix it
21:11:20 <dons> Binkley: the other good sign is the `arbitrary certainty precision' 
21:11:27 <mm_freak> fixedâ¦  just reload =)
21:11:28 <dons> that's always a sign of something funny going on
21:11:33 <dons> 99%+ 
21:11:42 <Binkley> yeah
21:11:57 <Binkley> he's admitting he could be wrong! it's just very, very unlikely
21:12:09 <dons> the LaTeX guy on reddit a couple of days ago was better though, `99.92897523498% of people will never, in their entire lives, have to print something at a quality nearing that of commercial publishing houses'
21:12:14 <dons> that's some precision he's got !
21:12:30 <dons> you have to bow down to such precision
21:12:32 <Binkley> coincidentally enough, I just saw that comment
21:12:38 <ddarius> @google Dunning-Kruger
21:12:39 <lambdabot> http://en.wikipedia.org/wiki/Dunning-Kruger_effect
21:12:40 <lambdabot> Title: Dunning-Kruger effect - Wikipedia, the free encyclopedia
21:12:53 <Binkley> reddit users make Jesus cry
21:12:58 <dons> they do
21:13:06 <ddarius> That's why I'm not one.
21:13:09 <dons> ddarius: good call.
21:13:17 <Binkley> ?quote qwe1234
21:13:18 <lambdabot> qwe1234 says: i can program in assembly as well as i can program in c++
21:13:26 <ddarius> Apropos
21:14:53 <dons> btw, i heard back from Evan Martin, the guy who wrote the `haskell for programmers' draft tutorial
21:15:09 <dons> he seems reasonably interested in getting it on the wiki.
21:15:43 <dons> this is the haskell effect for language designers: `if they can be trained to substantially improve their own skill level, these individuals can recognize and acknowledge their own previous lack of skill'
21:16:08 <dons> i feel like yelling that at people who want to design their own scripting language. don't do it! we don't need more rubys and perls.
21:16:43 <dolio> You mean the 'what would you put in a language' story?
21:16:43 <kfish> so, who here likes (n+k) patterns?
21:17:01 <Binkley> now, now, everyone should get a chance to reinvent the wheel
21:17:17 <dolio> You should tell them to put dependent types in their language.
21:17:19 <dons> well, just that language design is really hard to get right. pretty much anything you can write will be bad, unless you school yourself a bit.
21:17:29 <mm_freak> binkley: but they shouldn't pollute the internet with their `work'
21:17:46 <Binkley> Heh, well, keeping the Internet free of pollution is kind of a lost cause :-)
21:17:52 <dons> our industry makes it too easy to get hacks into the mainstream
21:17:58 <markw2> Hi, I get "\driver\package.conf.inplaceonf as c:\Software\haskell\ghc\ghc-6.6.1" when trying to run stable version of Yi. Can anyone help?
21:18:07 <hpaste>  georgex pasted "Generating random numbers. This doesn't work." at http://hpaste.org/1670
21:18:09 <mm_freak> binkley: probably much worse than the real world =)
21:18:12 <jre2> would doing "forkIO $ forever $ atomically $ myFunc srcTChan destTChan" likely cause problems (say, myFunc reads src, does minor edit, and writes to dest)?
21:18:45 <jre2> (forever m = m >> forever m)
21:18:52 <sjanssen> jre2: it might cause lots of conflicts/retries across transactions
21:19:04 <sjanssen> depending on myFunc, and what other threads are doing
21:19:36 <ddarius> kfish: No one, and I'm stick to that.
21:19:46 <wli> It's a bit of a mess right now, but ...
21:19:54 <wli> http://holomorphy.com/~wli/Bernoulli.hs
21:19:59 <georgex> I can't compile this http://hpaste.org/1670 with ghc. Any ideas?
21:20:28 <sjanssen> georgex: can you describe what goes wrong?
21:20:31 <wli> I should write a caching monad so space is controllable.
21:21:18 <ddarius> I should write a gravity monad so space-time is controllable.
21:22:37 <wli> ddarius: Um, this isn't science fiction. It's the same thing as a tabulating monad for dynamic programming, except the table has a limit, which when exceeded, triggers the reclamation and/or overwrite of table entries.
21:22:49 <hpaste>  jre2 pasted "stm issue" at http://hpaste.org/1671
21:23:15 <georgex> sjanssen: I get the error     Ambiguous type variable `a' in the constraints:
21:23:16 <georgex>       `Show a' arising from use of `print' at pi.hs:6:3-7
21:23:16 <georgex>       `Random a' arising from use of `randoms' at pi.hs:5:12-22
21:23:16 <georgex>     Probable fix: add a type signature that fixes these type variable(s)
21:23:26 <ddarius> To all, for future reference if you take me as more than whimsical, you are wrong.
21:23:30 <sjanssen> georgex: ah, ghc doesn't know what type of random things to generate
21:23:49 <hpaste>  sjanssen annotated "Generating random numbers. This doesn't work." with "fixed?" at http://hpaste.org/1670#a1
21:23:56 <sjanssen> georgex: see the annotation
21:23:57 <georgex> sjanssen: oh I see. Like numbers, strings, etc
21:24:05 <sjanssen> 'zactly
21:24:37 <jre2> sjanssen: would you happen to know and be able to tell me why http://hpaste.org/1671 would cause problems?
21:25:58 <georgex> sjanssen: that fixed it. If I want numbers between 0 and 1, do I have to use the hack of setting the type to :: Float and then divide by the biggest Float available?
21:26:17 <sjanssen> georgex: no, there's randomR IIRC
21:26:20 <jre2> sjanssen: I know the threads are retrying too often (it quickly stops processing, then app terminates due to detecting being indefinately blocked.  I'm just not sure why / how to fix it
21:26:36 <dons> mm_freak: what does this do?
21:26:37 <dons> isqrt' n x = case div (div n x + x) 2 of
21:26:37 <dons>                x -> x
21:26:37 <dons>                o -> isqrt' n o
21:26:43 <dons> those 'x' and 'o' bindings overlap
21:26:48 <sjanssen> georgex: and there's a Random instance for Double
21:27:24 <sjanssen> jre2: is acceptd terminating?
21:27:32 <georgex> sjanssen: let me try this out
21:27:43 <dons> wow, Finance.Quote.Yahoo 0.1
21:27:55 <dons> brad++
21:28:07 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Finance-Quote-Yahoo-0.1
21:28:10 <lambdabot> http://tinyurl.com/3cevhd
21:28:20 <mm_freak> dons: it's the babylonian sqrt method
21:28:36 <mm_freak> they overlap, because `case' has no `otherwise'
21:28:41 <dons> mm_freak: no, i mean the 'x' and 'o' arms are useless here
21:28:45 <dons> it will always match 'x'
21:28:54 <mm_freak> nope, x is a function argument
21:29:00 <dons> that's a new binding of the variable 'x' in the first branch of the case
21:29:02 <hpaste>  wli annotated "Bernoulli numbers lacking dynamic programming" with "Bernoulli numbers with dynamic programming" at http://hpaste.org/1662#a1
21:29:06 <jre2> sjanssen: no, it listens on a socket forever
21:29:06 <dons> it shadows the isqrt parameter 'x'
21:29:20 <mm_freak> dons: but then it wouldn't work
21:29:25 <wli> heh, hpaste.org cut me off
21:29:45 <jre2> sjanssen: I thought of forking that as well, but then the main thread ends and the entire app terminates immedately
21:29:55 <dons> mm_freak: 
21:29:56 <dons> isqrt' n x = case div (div n x + x) 2 of
21:29:56 <dons>                 o | o  == x   -> x
21:29:56 <dons>                   | otherwise -> isqrt' n o
21:29:57 <dons> you mean?
21:30:13 <georgex> sjanssen: ::Double worked perfectly but I wonder how come that with Int I got huge numbers and with Double I only get numbers between 0 and 1?
21:30:16 <mm_freak> yeah, that's what i mean
21:30:24 <dons> 'case' binds new variables in its branches, it doesn't match implicitly on variables already in scope
21:30:29 <dons> (you'd get a warning with -Wall)
21:30:59 <mm_freak> hmm k
21:31:11 <mm_freak> then this might be a reason for it being so slow
21:31:20 <sjanssen> georgex: that looks like the default range, use randomR to ask for a different range
21:31:32 <sjanssen> georgex: eg. randomR (1, 10)
21:31:59 <dons> http://programming.reddit.com/info/269tl/comments
21:32:00 <lambdabot> Title: Finance.Quote: Haskell library for accessing Yahoo! Finance (reddit.com)
21:32:36 <georgex> sjanssen: in other words. Whoever defined the function randoms, decided that if a double is passed, this will be a sensible default from 0 to 1, and if you need something different you can use randomR. Is ths correct?
21:32:44 <mm_freak> dons: reload
21:32:56 <sjanssen> georgex: yes, so it seems
21:32:59 <mm_freak> i've fixed it
21:33:13 <sjanssen> georgex: it may or may not be defined in the Haskell '98 spec, not sure
21:33:23 <dons> mm_freak: from http://streitmacht.eu/test.hs ?
21:33:50 <mm_freak> yes
21:34:02 <georgex> sjanssen: yep. I've checked the prelude. And it says: "For fractional types, the range is normally the semi-closed interval [0,1).". 
21:34:13 <mm_freak> i've fixed it and beautified the code a little
21:35:23 <georgex> I love Haskell. Everything is so logical.
21:35:48 <hpaste>  (anonymous) annotated "stm issue" with "(no title)" at http://hpaste.org/1671#a1
21:36:06 <ddarius> > let undefined = undefined in undefined :: a -> b
21:36:13 <lambdabot>  Add a type signature
21:36:29 <mm_freak> > let 2+2 = 5 in 2+2
21:36:31 <lambdabot>  5
21:36:35 <dons> :)
21:36:37 <mm_freak> pretty logical =)
21:36:41 <dons> very!
21:37:37 <mm_freak> dons: is there any way to restrict `where' to a single guarded equation?
21:37:56 <ddarius> Use let
21:38:02 <mm_freak> other than writing a new definition, that is
21:38:18 <mm_freak> ddarius: i need to use it _in_ the guard
21:38:35 <ClaudiusMaximus> > let frob f s l = let l' = zipWith f (s:map fst l') l in map snd l' in (frob (\x y -> (y,x)) 0 [10..20], frob (\(x,y) z -> ((y,z),x)) (0,0) [10..20])
21:38:36 <lambdabot>  ([0,10,11,12,13,14,15,16,17,18,19],[0,0,10,11,12,13,14,15,16,17,18])
21:38:41 <mm_freak> both in the guard and in the result
21:39:27 <ClaudiusMaximus> i feel like i'm getting somewhere, but where, i don't know
21:40:02 <dons> mm_freak: you can use 'let', but since its lazy, it shouldn't be computed unnecesarily anyway.
21:40:42 <mm_freak> dons: where is lazy enough not to compute anything, when an earlier guard already matched?
21:41:04 <dons> it'll only be computed when it is actually required
21:41:06 <mm_freak> s/where/`where'/
21:41:09 <dons> i.e. if the branch that needs it is executed
21:41:13 <dons> same with 'let'
21:41:16 <mm_freak> k
21:41:21 <mm_freak> ty
21:41:59 <dons> now, where was that C code again?
21:43:04 <sjanssen> o noes!  not C code!
21:43:19 <Saizan> lolcode?
21:43:49 <sjanssen> plz
21:43:59 <dons> i can has C codez?
21:44:02 <mm_freak> dons: completely forgot that, sorry =)
21:44:07 <mm_freak> just a second
21:46:29 <mm_freak> the C code isn't optimized very well, my own version was even faster
21:46:32 <mm_freak> http://streitmacht.eu/factor/
21:46:33 <lambdabot> Title: Index of /factor
21:46:49 <dons> ok, i just want to check what operatoins are used
21:46:54 <dons> factor.c ?
21:46:58 <mm_freak> but still it's about five times as fast as the current haskell version
21:47:04 <mm_freak> factor.c
21:47:05 <dons> yeah, we should be able to do a bit better.
21:47:15 <mm_freak> the operations used get optimized by GCC
21:47:21 <mm_freak> division becomes right-shift, and so on
21:47:37 <mm_freak> (does haskell do such optimizations?)
21:47:45 <dons> some yes. 
21:47:49 <dons> and then others get passed to gcc
21:48:14 <mm_freak> yeah, GCC does the dirty low-level work, but i guess GHC doesn't want to depend on GCC forever =)
21:48:37 <dons> oh, actually, use -fasm !
21:48:43 <dons> its about 0.4s faster here
21:48:48 <dons> $ time ./A 1958361962210867             
21:48:48 <dons> [34199611,57262697]
21:48:48 <dons> ./A 1958361962210867  1.37s user 0.01s system 98% cpu 1.395 total
21:48:53 <dons> stupid gcc ;)
21:49:12 <mm_freak> interestingâ¦  but first i'll wait for ghc-6.6.1 to finish =)
21:49:16 <dons>  ghc -O2 test.hs -o A  -fasm 
21:50:09 <mm_freak> what do you think about the lazy list `wheel'?  should we replace that by something strict and finite?
21:50:20 <dons> nah, i think that's ok.
21:50:27 <dons> it's probably coming down to the Word64 operations
21:50:49 <mm_freak> yeah, that's why i've done it that way
21:51:10 <dons> yep
21:51:57 <dons> you can use -ddump-simpl
21:51:58 <mm_freak> btw, does `cycle' do anything special, other than append itself to its argument?
21:52:01 <dons> to see what code ghc turns it into 
21:52:02 <dons> ope
21:52:05 <dons> ?src cycle
21:52:05 <lambdabot> cycle [] = undefined
21:52:05 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
21:52:13 <dons> just builds a little circular structure
21:52:34 <mm_freak> yeah, my question was whether it does any optimizations
21:52:49 <mm_freak> like rewriting and stuff
21:53:18 <dons>     1 fromIntegral/Word64->Int
21:53:18 <dons>     3 negateInt#
21:53:19 <mm_freak> unfortunately i don't have the library sources at hand
21:53:27 <dons> it does a couple of conversions there, then lower level stuff
21:53:33 <dons> cycle doesn't do anything other than the above
21:53:42 <mm_freak> k
21:54:02 <mm_freak> ah kâ¦  i really like the idea about lazy lists
21:54:14 <dons> they're nice here, aren't they.
21:54:17 <mm_freak> at first i wanted to implement isqrt with a list, too
21:54:39 <mm_freak> the algorithm version that is, not the `sqrt' wrapper
21:54:53 <georgex> I've a list xs of tuples (x,y) and I want to count how many tuples in my list satisfy my function doSomething(x,y). What's the right way of doing this in Haskell?
21:55:15 <dmwit> Sweet!
21:55:23 <dmwit> WASH is fun.
21:55:31 * shapr waves the HAppS flag!
21:55:37 <dmwit> georgex: length . filter doSomething
21:56:04 <dmwit> shapr: I looked at HAppS, too, I've nothing against it. =)
21:56:25 <mm_freak> i'd question thatâ¦  is (length . filter) as efficient as writing a simple recursive function?
21:56:33 <dons> mm_freak: one issue is that on 32 bit machines Word64 operations are often C FFI calls into gmp
21:56:50 <dons> mm_freak: not quite, it won't fuse generally. 
21:56:51 <mm_freak> dons: ohâ¦  that's pretty bad
21:56:56 <mm_freak> factor.c just uses unsigned long long
21:57:05 <dons> case {__ccall stg_eqWord64 GHC.Prim.Word64#
21:57:05 <dons>                 -> GHC.Prim.Word64#
21:57:05 <dons>                 -> GHC.Prim.State# GHC.Prim.RealWorld
21:57:05 <dons>                 -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Prim.Int# #)}_a2fw
21:57:08 <dons> for example, to do ==
21:57:27 <dons> yes, there's an open ticket for better Word64 support in the runtime, on 32 bit machines
21:57:36 <mm_freak> dons: once i've written a collection of basic factoring algorithms using GMP in Câ¦  for 64 bits i could boost the speed by about 500% by not using GMP
21:57:45 <dons> huh
21:58:05 <dons> they're ccalls, let me check if they use GMP though
21:58:06 <shapr> dmwit: yay!
21:59:27 <dons> mm_freak: ah, htey're not gmp calls
21:59:28 <dons> StgBool stg_gtWord64 (StgWord64 a, StgWord64 b) {return a >  b;}
21:59:28 <dons> StgBool stg_geWord64 (StgWord64 a, StgWord64 b) {return a >= b;}
21:59:28 <dons> StgBool stg_eqWord64 (StgWord64 a, StgWord64 b) {return a == b;}
21:59:34 <dons> but they are FFI calls to C.
22:00:01 <dons> on 64 bit they're primops though
22:00:28 <dons> section "Word64#"
22:00:28 <dons> 	{Operations on 64-bit unsigned words. This type is only used 
22:00:28 <dons> 	 if plain Word\# has less than 64 bits. In any case, the operations
22:00:28 <dons> 	 are not primops; they are implemented (if needed) as ccalls instead.}
22:00:31 <dons> says the ghc primops list
22:00:37 <mm_freak> dons: with a 64 bit argument it needs 240 ms, with a 65 bit argument it already needs 1220 ms
22:00:48 <mm_freak> both of them contain the same 24 bit factor
22:00:51 <dons> yeah, so that's gmp versus ccall ?
22:00:57 <mm_freak> yes
22:01:04 <dons> using Integer or Word64 , you mean?
22:01:06 <mm_freak> for 64 bit it uses a special non-GMP version
22:01:11 <mm_freak> it's in C
22:01:14 <dons> ah ok.
22:01:25 <dons> yeah, if you switch to Integer for the Factor type, it should then always call into gmp
22:01:31 <dons> which then might use its 64 bit form
22:01:32 <mm_freak> you may want to have a look at the source code
22:02:29 <mm_freak> dons: using Integer for Factor slows it down to 5100 ms here
22:02:38 <dons> yes, i'd imagine it would
22:02:45 <dons> that's the ccall versus gmp calls. 
22:02:48 <mm_freak> from slightly less than 2000 ms using Word64
22:02:52 <mm_freak> yeah
22:03:02 <dons> so we want to find the difference between primop types (like Word32) and ccall types, like Word64
22:03:14 <dons> and then, if Word64 is bad, put in a bug report asking for primops
22:03:33 <mm_freak> Word64 should be a primop actually, since C has a native type for that
22:03:36 <mm_freak> unsigned long long
22:03:53 <dons> right, ghc could do it directly as for other primitive types
22:03:59 <dons> the lazy approach is to compile it to an FFI call
22:04:14 <dons> but that costs performance, due to ccall overheads 
22:04:21 <mm_freak> yeah
22:04:38 <dons> you might be able to get numbers for factoring Word32-sized values
22:04:53 <mm_freak> 1989424823
22:05:06 <mm_freak> that's two 16 bit factors
22:05:33 <mm_freak> dons: http://ertes.de/genp/
22:05:35 <dons> yes, definitely slower switching to Word64 from Word32
22:05:35 <lambdabot> Title: Ertes: genp
22:05:49 <mm_freak> my little prime number generator
22:05:53 <dons> useful !
22:07:10 <mm_freak> it uses GMP, but i'm pretty sure you have it installed =)
22:15:37 <hpaste>  dons pasted "current code" at http://hpaste.org/1672
22:17:41 <mm_freak> fineâ¦  but GHC is still compiling
22:19:12 <dons> :)
22:20:38 <mm_freak> GHC 6.4 didn't take so long =)
22:21:54 <georgex> aren't . and $ interchangeble more often than not?
22:22:15 <dolio> That's an illusion. :)
22:22:37 <georgex> for example length . filter or length $ filter return the same result
22:23:39 <ddarius> georgex: Nope.
22:24:01 <davidL> is there a darcs repository of the equivalent to Debian's libghc6-haskell-src-dev?
22:24:17 <|Steve|> georgex: Both give me a type error.
22:24:38 <SamB_XP> @google "haskell-src"
22:24:41 <lambdabot> http://www.cs.chalmers.se/~d00nibro/haskell-src-exts/
22:24:41 <lambdabot> Title: Haskell-Source with eXtensions
22:24:44 <SamB_XP> hmm.
22:25:00 <SamB_XP> That is probably not exactly what you wanted.
22:25:35 <mm_freak> georgex: they are completely differentâ¦  it's incidental that you can interchange them in your example
22:26:06 <qwr> :t (.)
22:26:08 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
22:26:08 <qwr> :t ($)
22:26:10 <lambdabot> forall a b. (a -> b) -> a -> b
22:26:43 <SamB_XP> some wish to change the associativity of $ so that this apparant interchangability no longer exists -- you'll have to use as many .s as possible then.
22:26:54 <davidL> I'm looking to satisfy the dependency haskell-src-any
22:27:07 <dons> that's the haskell-src lib, available from hackage
22:27:09 <dons> or most package systems
22:27:13 <dons> ?hackage haskell-src
22:27:13 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/haskell-src
22:27:18 <davidL> thanks dons
22:27:34 <georgex> which one should I use in my example, the composition function?
22:27:48 <davidL> debian's package is broken =\
22:28:11 <SamB_XP> davidL: has the bug been reported?
22:28:33 <dons> mm_freak: so regarding your factor program, its doing a few things different to C (the lazy list, while C has a static bound on the number of factors), and Word64 isn't optimised very well
22:28:34 <davidL> SamB_XP: I have no idea.
22:28:48 <dons> we could probably make a case for a bug report/feature request for primops for Word64 on 32 bit machines
22:29:00 <dons> other than that, not much else springs to mind
22:29:19 <dons> the code is reasonably fast, but there's some limits here getting down to C, without exactly duplicating the C using unboxed operations, which is ugly
22:29:31 <SamB_XP> davidL: have you checked the bts?
22:30:21 <SamB_XP> dons: you could try to compile it with JHC?
22:32:21 <davidL> SamB_XP: yeah, it's known: http://packages.qa.debian.org/h/haskell-haskell-src.html
22:32:23 <lambdabot> Title: Overview of haskell-haskell-src source package
22:34:59 <Cale> It would be neat if HackageDB also provided a mechanism for browsing the source of the packages.
22:35:26 <SamB_XP> Cale: it will probably happen soon after the Haddock is autogenerated
22:35:42 <Cale> cool :)
22:35:54 <jre2> are there any existing implementations of a full fledged actor system over stm? (A student of Agha's is asking me)
22:36:26 <SamB_XP> since it's a lot easier to make the changes to haddock and/or it's invocation than it is to set up a secure sandbox for documentation generation ;-)
22:38:00 <Cale> jre2: I haven't heard of anything like that, though it ought to be doable, I'd think.
22:38:52 <dons> jre2: hmm, i've not heard anything. it has been discussed a few times
22:38:57 <dons> would be *very* welcome , I think
22:39:01 <dons> and make a great student project
22:39:55 <jre2> ah. we were curious if anyone had made an attack on handling pattern matching the mailboxes and handling migration
22:40:15 <dons> I think malcolmw has looked a little at this stuff
22:40:21 <dons> not in the context of STM
22:40:27 <dons> but just actors and types in haskell
22:40:52 <dons> so there's likely been research on typed haskell actor implementations, but nothing with STM.
22:41:01 <jre2> alright
22:41:17 <dons> this might be relevant (not sure) http://www.cse.unsw.edu.au/~chak/haskell/ports/
22:41:17 <lambdabot> Title: The Haskell Ports Library
22:41:53 <dons> i should package that with cabal.
22:42:10 * dons does so
22:42:44 <kfish> dcoutts, dcoutts_, around?
22:43:04 <mutjida> hello. i'm trying to find an old haskell-cafe thread about valid haskell (ghc) functions for which it is impossible to write a type signature. does anyone remember this thread?
22:44:49 <dons> mutjida: hmm, i think we made a wiki page for it
22:45:09 <dons> http://haskell.org/haskellwiki/Untypeable_Haskell_98
22:45:11 <lambdabot> Title: Untypeable Haskell 98 - HaskellWiki
22:46:08 <ojacobson> hmm
22:46:23 <ojacobson> are random-ish unicode symbols valid infix operators in haskell?
22:46:24 <mutjida> dons: thanks. but i think i recall seeing functions for which no type signature can be written even with ghc extensions...
22:46:26 <ojacobson> Â± etc
22:46:33 <davidL> dons: fps>=0.7 shouldn't be a dependency for lambdabot if using ghc-6.6 correct?
22:46:39 <dons> davidL: correct
22:46:44 <dons> use the .cabal.6.6 file
22:47:13 <Cale> That was also brought up in the Haskell 98 discussions, but, iirc, there wasn't much consensus on what to do about it at the time, and it was considered rare enough that they didn't fix it.
22:49:22 <|Steve|> Can someone remind me why the forall a is needed? Isn't the type variable implicitly over all types a?
22:49:40 <davidL> hmm, .cabal.6.6 wasn't in the 4.0.1 package--I'll try darcs instead
22:49:49 <dons> oh, yes, please do use the darcs version
22:49:55 <|Steve|> The \Lambda a. a->a in pl papers (at least the ones I've been forced to read).
22:50:04 <Cale> |Steve|: using the forall will locally bind that type variable
22:50:06 <davidL> 537 patches :)
22:50:25 <Cale> So 'a' will denote that type in all type signatures in the where clause, etc.
22:50:56 <|Steve|> Oh. That's quite handy. I wanted that yesterday but didn't know how to get it.
22:51:41 <|Steve|> I had a type signature in a where clause and it was failing because it was too general or something but I wanted the a to be the same as in the main function. If that makes any sense.
22:51:53 <Cale> yes, that's exactly what that's for
22:52:26 <|Steve|> Is that going to be in a later version of the standard?
22:52:35 <|Steve|> Is there going to be another version of the standard?
22:52:55 * SamB_XP wonders what the deal with http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=427323 is
22:52:57 <lambdabot> Title: #427323 - haskell-haskell-src: FTBFS: unmet build dep ghc6 - Debian Bug report l ...
22:53:34 <georgex> GHC is now complaining about print (4 * inside / total) in regards to
22:53:42 <SamB_XP> Igloo: ?
22:53:52 <georgex> Fractional Int 
22:53:56 <Cale> |Steve|: Haskell' is coming up. Perhaps it will be in that.
22:54:22 <jfredett> georgex: use div
22:54:30 <kfish> ojacobson, random unicode, no :-(
22:54:32 <jfredett> 4 * inside `div` total
22:54:33 <|Steve|> Haskell' being a new language altogether or just a new name for Haskell0x?
22:54:41 <jfredett> you might need to parenthesize too
22:54:44 <georgex> jfredett: thanks. Could you tell me why / is not good?
22:54:55 <jfredett> / is defined as non-integer division
22:55:00 <mm_freak> dons: the C-version has a static bound, because obviously an N bit number cannot have more than N-1 factors
22:55:05 <jfredett> div takes to integers to one integer
22:55:18 <jfredett> / takes to floating numbers to one number, haskell doesn't overload /
22:55:26 <mm_freak> we could switch form the list to a mutable array
22:55:26 <SamB_XP> |Steve|: it just means "the next version of Haskell"
22:55:32 <jfredett> one number -> one floating number
22:55:45 <SamB_XP> what was the one before 98?
22:55:59 <georgex> ok, so I have an integer and an integer and I want the exact division as a float
22:55:59 <|Steve|> SamB_XP: Okay. Just so long as we don't end up with Haskell'', Haskell''', Haskell^{(4)}, ...
22:56:20 <mm_freak> dons: but IMO the difference would be neglible
22:56:27 <georgex> e.g. I've 3/2 I want 1.5 not 1
22:56:29 <SamB_XP> |Steve|: I'm hoping we go back to version numbers with the next standard
22:56:40 <Saizan> georgex: then you have to convert your integers with fromIntegral
22:56:40 <jfredett> then you should do "4 * (fromIntegral inside) / (fromIntegral total)
22:56:41 <jfredett> "
22:56:42 <mm_freak> dons: consider that the list is only extended when a factor is found
22:56:45 <|Steve|> Years are always nice.
22:56:48 <SamB_XP> i.e. Haskell 2.0 or something...
22:56:59 <Cale> |Steve|: We might even go back to proper numbering and call it Haskell 1.6 :)
22:57:06 <SamB_XP> or 1.6
22:57:15 <SamB_XP> Cale: the last one was 1.4?
22:57:15 <Cale> 2.0 is too big a jump, I think
22:57:20 <jfredett> fromIntegral "lifts" an integer type to a kind of "generic" type which can handle /
22:57:23 <georgex> jfredett, Saizan: so fromIntegral will make a float from Integers?
22:57:24 <Cale> 1.4 was before '98
22:57:28 <SamB_XP> okay then.
22:57:33 <Cale> so '98 would be 1.5 :)
22:57:33 <georgex> jfredett: thanks
22:57:34 <jfredett> those are seriously dangerous uses of the term lift and generic
22:57:36 <SamB_XP> 1.6 sounds about right then ;-)
22:57:49 <ojacobson> 1.6 would be parallel with java :V
22:57:56 <Cale> I think we need a code-breaking 2.0 at some point :)
22:58:00 <jfredett> georgex: once you get a grasp for the typeclass system, and how to move around in it
22:58:05 <jfredett> its really quite liberating
22:58:23 <jfredett> theres a nice diagram for the number-typeclass tree on the wikibook
22:58:39 <SamB_XP> if they know what's good for them, they'll call it 1.6 so we don't have to call the one after that Haskell' too...
22:58:49 <jfredett> I actually have a post or two on my blog now about type classes, they're very handy.
22:59:28 * SamB_XP heads off to bed
22:59:49 <kfish> ojacobson, http://hackage.haskell.org/trac/haskell-prime/wiki/UnicodeInHaskellSource
22:59:52 <lambdabot> Title: UnicodeInHaskellSource - Haskell Prime - Trac, http://tinyurl.com/yfvxzv
23:00:08 <dons> mm_freak: yeah, its not the list so much as the Word64 inefficiencies
23:00:14 <ojacobson> kfish: thanks
23:00:18 <hpaste>  ClaudiusMaximus annotated "is sanity an option?" with "stateful functions using threads" at http://hpaste.org/1663#a1
23:00:57 <mm_freak> dons: yep, mainly Word64 is responsibleâ¦  are you going to bug-report this?
23:01:30 <dons> ?bug <-- go for it
23:01:31 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
23:01:46 <dons> you'll need to provide a program, and some numbers on how bad word64 ccalls are costing us on 32 bit
23:01:50 <dons> to really motivate it
23:02:20 <|Steve|> Ohh, I like the new NumericClasses. (I'm reading about Haskell'.)
23:03:42 <jfredett> there restructuring the numeric classes?
23:03:43 <jfredett> :)
23:04:07 <jfredett> link?
23:04:08 <|Steve|> I'm glad the proposed rings have units.
23:04:26 <jfredett> rings? :)
23:04:38 <dons> ?hoogle addFinalizer
23:04:38 <|Steve|> http://hackage.haskell.org/trac/haskell-prime/wiki/NumericClasses
23:04:38 <lambdabot> System.Mem.Weak.addFinalizer :: key -> IO () -> IO ()
23:04:40 <lambdabot> Title: NumericClasses - Haskell Prime - Trac
23:04:42 * jfredett 's math sense is tingling
23:05:13 <jfredett> *twitch*
23:05:20 <jfredett> happy. Groups, Rings, Math. Yay.
23:06:33 <|Steve|> And the fromInteger makes perfect sense since any ring is a Z-module in the obvious way.
23:07:16 <jfredett> hmm, if I wanted to exclude a module from being imported, eg exclude the prelude from being imported, is that possible? 
23:07:20 <jfredett> if so, whats the syntax?
23:09:52 <ClaudiusMaximus> jfredett: this works with ghci:
23:09:54 <ClaudiusMaximus> module Hiding where
23:09:54 <ClaudiusMaximus> import Prelude()
23:10:02 <jfredett> okay
23:10:19 <jfredett> thats what I thought- but I'm not at a computer w/ ghc on it
23:10:20 <hpaste>  georgex pasted "The Pi that wasn't Pi" at http://hpaste.org/1673
23:10:55 <jfredett> alright, goodnight people
23:13:23 <dons> get your distributed haskell abstractions here, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/ports-0.4.3.1
23:13:25 <lambdabot> http://tinyurl.com/2rpq37
23:13:26 <dons> :)
23:13:33 <georgex> the results of my Pi program are always off by a huge margin. They are practically random numbers. This can be caused by only 2 things. Either I'm missing something in my program or Haskell random generation is awful. I assume Haskell is right and my code is awful.
23:13:52 <scook0> georgex: not sure if it's a problem, but your xs and ys seem to be drawn from the same list of random numbers
23:14:27 <georgex> scook0: I tried two different ones, and I got the same results.
23:16:40 <mm_freak> dons: yeahâ¦  first i'll optimize what's possible in the factorizer, then i'll post it
23:18:30 <dons> ok good.
23:18:50 <mm_freak> as soon as GHC is ready =)
23:20:15 <mm_freak> dons: would you use bang patterns (i.e. force GHC upon users) in public projects?
23:21:33 <sjanssen> mm_freak: if that was the only GHC extension I'm using, then I'd avoid them
23:22:00 <mm_freak> sjanssen: they're pretty useful though
23:22:05 <sjanssen> if you're already using newtype deriving, or some other GHC specific feature, I'd leave the bang patterns in
23:22:09 <sjanssen> mm_freak: certainly
23:22:29 <sjanssen> mm_freak: however, much of their use is superstitious
23:22:53 <sjanssen> you can usually whittle it down to two or three key places -- then you can just use seq
23:22:58 <mm_freak> sjanssen: of course, but they make tail-recursive code very pleasing to the eye
23:22:59 <hpaste>  georgex annotated "The Pi that wasn't Pi" with "The Pi that wasn't Pi" at http://hpaste.org/1673#a1
23:23:37 <dons> mm_freak: yeah
23:23:46 <dons> i'd use them :)
23:23:56 <dons> since no one is going to do fast factoring in hugs anyway
23:24:00 <mm_freak> they show you just where exactly strictness is enforced, whereas with seq the user would have to read the actual definition
23:24:06 <dons> exactly
23:24:08 <mm_freak> true =)
23:24:11 <dons> they're a lot lighter and more flexible
23:24:22 <sjanssen> mm_freak: have you seen the seq guard idiom?
23:24:49 <mm_freak> sjanssen: something like "| par1 `seq` par2 `seq` False = undefined" ?
23:24:53 <georgex> anyone can help me determine what's wrong with my program? The same program in a procedural language gave me 4 digits of precision.
23:24:57 <sjanssen> mm_freak: yep, that one
23:25:01 <dons> we should write some more distributed haskell programs, now the ports library is revived, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/ports-0.4.3.2 :)
23:25:03 <lambdabot> http://tinyurl.com/3ceejs
23:25:03 <sjanssen> mm_freak: ugly, but gets the job done
23:25:08 <mm_freak> sjanssen: it works, but it's ugly
23:25:39 <mm_freak> is that `comparison' actually done in code?  it's a guard after all
23:26:03 <sjanssen> mm_freak: ghc is smart enough to drop the | False branch
23:26:16 <dons> yeah, its just a strictness hint to the optimiser
23:26:20 <dons> entirely compiler-time only
23:26:24 <mm_freak> k
23:26:26 <dons> but ! is better
23:26:29 <sjanssen> they're effectively the same as bang patterns when you get to code generation
23:27:02 <mm_freak> still ! is prettierâ¦  i'll use them for private code at least
23:28:00 <sjanssen> mm_freak: btw, "fast factoring" certainly has more reason to use GHC specific features
23:28:29 <mm_freak> sjanssen: "really fast factoring" is done in C anyway, using GMP low-level functions
23:28:33 <sjanssen> as dons says, none of the other compilers are really worth optimizing for at this time
23:28:59 <dons> and you may as well do the inner loop directly in C here anyway, in my view
23:29:24 <dons> though given non-ccall Word64s, ghc would be viable
23:29:27 <mm_freak> dons: would make sense, but i'm testing haskell performance, not C performance =)
23:29:33 <dons> its only what, 4-5x out now, even with bad Word64s?
23:29:54 <sjanssen> I wonder why GHC uses FFI to add Word64s?
23:29:56 <mm_freak> yeah
23:30:00 <dons> laziness, sjanssen :)
23:30:15 <dons> they're done purely as a library call from GHC.Word
23:30:21 <dons> into the base library longlong.c 
23:30:34 <dons> so no need to modify the compiler or native code gen, with a dozen new primops
23:30:46 <dons> and i think simon assumes we'll all be on 64 bit machines soon enough anyway
23:30:53 <dons> mm_freak: got a 64 bit machine handy?
23:31:04 <|Steve|> I do.
23:31:10 <dons> constrasting the running time on such a machine would make clear the different between `native' word64, and ccals
23:31:10 <mm_freak> Word64 has pretty few uses anyway, so i think that it wouldn't be worthwhile to add the primops for it
23:31:14 <mm_freak> dons: nope
23:31:22 <ojacobson> wli: awake?
23:31:34 <davidL> what is fptoolsPath :: FilePath ?
23:31:58 <ojacobson> "fptoolsPath has type FilePath"
23:32:02 <mm_freak> dons: native uint64_t is just as fast as native uint32_t
23:32:02 <sjanssen> davidL: in what context?
23:32:10 <mm_freak> (or should be)
23:32:16 <davidL> sjanssen: what should it be?
23:32:22 <Saizan> georgex: i think you want zip (randoms gen1) (randoms gen2) instead of your list comp
23:32:23 <dons> right, we want to quantify precisely what the ccall cost is 
23:32:36 <mm_freak> uint64_t in C isn't native, unless you have a 64 bit machine, but it's not translated into library calls either
23:32:54 <sjanssen> davidL: I dunno, only you can tell me the context that you've seen it :)
23:33:09 <davidL> sjanssen: oh, it's part of lambdabot's Config.hs
23:33:25 <Saizan> > ((zip [1..3] [4..6]),[(x,y)| x <- [1..3], y <- [4..6]]) -- georgex, see the difference?
23:33:27 <lambdabot>  ([(1,4),(2,5),(3,6)],[(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)])
23:33:34 <sjanssen> davidL: oh, it wants a pointer to a GHC and associated libs checkout
23:34:00 <dons> you can leave it blank though
23:34:04 <dons> since no one uses the @code plugin
23:34:43 <georgex> Saizan: with zip I get a 2.8 result all the time (not always the same value, always in the neighbourhood of 2.8)
23:34:45 <Saizan> georgex: also there's no point in using getStdGen twice, gen1 and gen2 will be the same seed, use newStdGen
23:35:00 <davidL> well whenever I send a command to lambdabot it says: Failed to load interface for `ShowQ':
23:35:44 <Japsu> georgex: *Pi Control.Monad> take100_ makeRandomPoints
23:35:45 <Japsu> [(0.3213647277609829,0.3213647277609829),(0.3213647277609829,0.4622271570754766),(0.3213647277609829,0.9537356918337139)
23:35:52 <Japsu> your points are on the y=x line
23:35:58 <Japsu> oops no wait
23:35:58 <Japsu> nvm
23:36:24 <georgex> Saizan: thanks, let me see this
23:37:35 <mm_freak> consider this code:  smul' x y = seq p p   where p = x*y
23:37:55 <sjanssen> mm_freak: that seq is useless
23:37:58 <mm_freak> will (smul' 1 x) be calculated at run-time, or will it just simplify to x ?
23:38:10 <mm_freak> sjanssen: hmm?  doesn't it make the calculation strict?
23:38:12 <sjanssen> seq p p === p
23:38:28 <sjanssen> forall p
23:38:54 <georgex> I've fixed it :D
23:39:03 <mm_freak> sjanssen: the point is that the calculation should be strictâ¦  isn't that the case?
23:39:19 <Saizan> seq p p means "force p when you force p"
23:39:22 <sjanssen> mm_freak: the calculation was already strict (because * is strict)
23:40:27 <ojacobson> the letter $ is nigh-ungoogleable... where in the wiki would I look for "what does $ do and how do I use it"?
23:40:42 <Saizan> ?src ($)
23:40:43 <lambdabot> f $ x = f x
23:40:44 <mm_freak> huh?  so the addition in "length l xs = if xs == [] then l else length (l+1) (tail xs)" is strict?
23:41:03 <mm_freak> i used to write:  (length $! (l+1) (tail xs)
23:41:27 <mm_freak> i used to write:  (length $! (l+1)) (tail xs)
23:41:29 <|Steve|> ojacobson: It's just function application but with a low precedence.
23:41:32 <ojacobson> Saizan: so it's an infix version of "apply function"?
23:41:36 <sjanssen> mm_freak: ((+) x y) is strict in x and y
23:41:37 <ojacobson> aha, precedence
23:41:38 <Saizan> yup
23:41:46 <shachaf> mm_freak: Not important at the moment, but use null xs, not xs == [].
23:41:49 <hpaste>  georgex annotated "The Pi that wasn't Pi" with "We made it! But still less accurate then Ruby :(" at http://hpaste.org/1673#a2
23:42:01 <sjanssen> mm_freak: so when the result of the expression is demanded, the results of 'x' and 'y' are demanded too
23:42:08 <mm_freak> shachaf: makes sense, yeahâ¦  thanks
23:42:29 <sjanssen> mm_freak: however, the length code you've shown is *not* strict in the parameter, nor the (l+1) expression
23:42:32 <Saizan> ojacobson: you use it when you want to save parentheses, as in (f . g) x === f . g $ x
23:42:41 <ojacobson> Saizan: yeah, the penny dropped
23:42:48 <ojacobson> (and as with most haskell pennies, turned on a shitton of lights)
23:43:38 <shachaf> Saizan: I don't like that example. (f . g) x y =/= f . g $ x y
23:43:45 <georgex> could you comment on the style of the code here http://hpaste.org/1673#a2 and tell me, if possible, what would be a reasonable explaination to why the randomness in Haskell seems to produce worst results than (say) Ruby?
23:43:48 <sjanssen> mm_freak: strictness is the demand of a function on its arguments
23:43:51 <mm_freak> sjanssen: how come?  it seems to sum up the 1s along the wayâ¦  without the $!, it seems to create a long list of "1 + 1 + 1 + ...", until the base case is reached and then sum them up (just as intended)
23:44:33 <sjanssen> mm_freak: the problem isn't that "(l+1) isn't strict" -- expressions don't really have strictness properties.  The problem is that length is not strict in the first argument
23:45:04 <ojacobson> Saizan: I would've grokked f $ x y = f (x y) much faster personally
23:45:18 <ojacobson> s/Saizan/shachaf
23:45:49 <mm_freak> sjanssen: i don't really understand
23:45:58 <Saizan> well i just used the most common situation where i use it :P
23:46:07 <sjanssen> mm_freak: you've observed the behavior of that length code correctly
23:46:15 <shachaf> Saizan: I most commonly use it in that situation too.
23:46:21 <sjanssen> it will build up a big chain of (1 + (1 + ...))
23:46:47 <Cale> ojacobson: generally ($) is just used to eliminate parens on either side of it, sometimes this is clearer, once you know about it.
23:46:55 <mm_freak> yeah, unless you use $! for the recursive call
23:46:56 <shachaf> mm_freak: Your problem is with seeing why seq x x === x ?
23:47:17 <Cale> ojacobson: I recommend against using multiple ($)'s where function composition (.) is more appropriate though.
23:47:17 <|Steve|> What is $!?
23:47:24 <Cale> |Steve|: strict application
23:47:27 <shachaf> |Steve|: Strict ($).
23:47:33 <mm_freak> shachaf: i don't see why there is no difference between "seq (x*y) (x*y)" and "x*y"
23:47:36 <|Steve|> @src ($!)
23:47:37 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
23:47:41 <Cale> f $! x = x `seq` f x
23:47:42 <dons> ?src $!
23:47:42 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
23:47:43 <ojacobson> Cale: is ($) a b perverse?
23:47:47 <|Steve|> (No, I call myself a computer scientist.)
23:47:55 <mm_freak> it's supposed to calculate (x*y) before evaluating (x*y)
23:48:07 <mm_freak> so it isn't calculated somewhere outside of smul'
23:48:10 <shachaf> ojacobson: ($) is also called id.
23:48:18 <Cale> ojacobson: Somewhat though partially applying ($), like ($ 0) isn't so bad.
23:48:27 <sjanssen> mm_freak: they're always semantically the same
23:48:38 <mm_freak> sjanssen: semantically yes, but not computationally
23:48:39 <ojacobson> Cale: let me make sure I got that
23:48:40 <Cale> ($ 0) is the function which applies its argument to 0
23:48:48 <ojacobson> Cale: ($ 0) (1+) = 1?
23:48:51 <Cale> yes
23:48:51 <sjanssen> mm_freak: yes, computationally it depends
23:49:07 <shachaf> mm_freak: The problem is that it only does that "pre-calculation" once it reaches the seq.
23:49:15 <mm_freak> ok, so is there a computational difference between "seq p p   where p = x*y" and "x*y"?
23:49:15 <shachaf> mm_freak: And so would use the value anyway.
23:49:22 <Cale> It's often handy in higher-order functions
23:49:28 <sjanssen> mm_freak: with GHC, seq (x*y) (x*y) will do two multiplications, but (let p = x*y in seq p p) will do one
23:50:00 <mm_freak> sjanssen: why does it do two multiplications?  aren't they translated to the same thunk?
23:50:06 <ojacobson> Cale: that's...  wow, I'll have to digest that
23:50:19 <shachaf> > map ($ 2) [(+3),(*2),(+1)]
23:50:20 <lambdabot>  [5,4,3]
23:51:14 <sjanssen> mm_freak: computational differences depend on compilation strategy, of course.  But no, there is no computational difference in between (seq p p where p = ...) and (p where p = ...) in GHC, assuming no inlining takes place
23:51:32 <sjanssen> mm_freak: GHC generally doesn't do common subexpression elimination
23:51:39 <Cale> ojacobson: You'll often see f (g (h x)) written something like f . g . h $ x
23:51:40 <mm_freak> consider that one:  "len l xs = if null xs then l else len (add' 1 l) (tail xs)   where add' x y = seq (x+y) (x+y)"
23:51:53 <Cale> ojacobson: simply because Haskellers like to try to avoid parens.
23:51:54 <ojacobson> Cale: I'm looking at that right now in wli's code
23:52:01 <ojacobson> With a small twist
23:52:02 <shachaf> ojacobson: That calls each function in the list with the argument.
23:52:03 <mm_freak> will that build up a long list of "(add' (add' (add' (add' ... ))))" ?
23:52:04 <sjanssen> mm_freak: ie. in (seq (x*y) (x*y)), (x*y) will not be the same thunk
23:52:09 <ojacobson> normRaw e = snd . head . dropWhile (uncurry (/=)) $ zip es (tail es)
23:52:09 <ojacobson> 	where
23:52:10 <ojacobson> 		es = iterate normRaw' e
23:52:18 <Cale> yeah, like that
23:52:20 <ojacobson> Â±indents
23:52:23 <shachaf> ojacobson: Or more accurately, it calls ($ 2) with each function in the list.
23:52:42 <mm_freak> sjanssen: ah rightâ¦  i've read it in the FAQ
23:52:48 <ojacobson> shachaf: Yeah, I think I see it now
23:52:49 <sjanssen> mm_freak: your 'len' function is the same as your 'length' function earlier
23:53:15 <shachaf> > sequence [(+3),(*2),(+1)] 2 -- Also works, but ignore it for now. :-)
23:53:16 <lambdabot>  [5,4,3]
23:53:21 <sjanssen> mm_freak: with the side effect that GHC might do twice as many additions due to the lack of CSE
23:53:32 <davidL> whenever I try to do evaluate an expression lambdabot throws Failed to load interface for `ShowQ', any idea why?
23:53:33 * Cale loves the ((->) e) monad.
23:53:48 <mm_freak> yeahâ¦  but what about the additions themselves?  when will they be evaluated?
23:54:08 <mm_freak> outside of the function or in the recursive case?
23:54:40 <sjanssen> mm_freak: (seq (x+y) (x+y)) places a demand on (x+y) when the result of (x+y) is demanded
23:54:50 <Cale> mm_freak: (+) in Haskell, on all the existing numeric types, is already strict, so there's no point in defining add'
23:55:22 <sjanssen> mm_freak: which is clearly redundant, they're the same expression, so the seq is useless
23:55:27 <mm_freak> cale: if that weren't the case, would it be calculated directly or on demand (i.e. outside of len)?
23:55:40 <Cale> mm_freak: The problem with things like length with an accumulator isn't the strictness of (+), it's that demand for that parameter isn't generated in the first place.
23:55:59 <Cale> Once demand is generated, it'll be passed all the way down.
23:56:07 <sjanssen> mm_freak: your add' function changes exactly nothing
23:56:10 <Cale> and all the (+)'s will happen at once
23:56:17 <mm_freak> ok
23:56:28 <Cale> The problem is with length/foldl itself.
23:56:55 <ojacobson> would foldr avoid the problem?
23:56:57 <Cale> Since it doesn't generate any demand for that parameter until the very end.
23:57:02 <Cale> Nope
23:57:05 <ojacobson> thought not
23:57:06 <Cale> but foldl' would
23:57:19 <Cale> foldr helps when you want to be lazier, which is actually pretty often
23:57:36 <Cale> I'd say about 75% of my folds are foldrs
23:57:37 <mm_freak> cale: i'm trying to understand where exactly strictness makes a differenceâ¦  suppose (+) weren't strictâ¦  how could i define a strict version of (+) ?
23:58:04 <sjanssen> strictPlus x y = x `seq` y `seq` lazyPlus x y
23:58:20 <Cale> yes
23:58:30 <mm_freak> sjanssen: then it's strict in its arguments, right?
23:58:47 <sjanssen> mm_freak: right, that is the only real strictness
23:58:54 <Cale> then, when evaluation of strictPlus x y was demanded, x and y would be demanded before lazyPlus x y was returned
23:59:08 <mm_freak> k
23:59:25 <ojacobson> @src (@)
23:59:25 <lambdabot> Source not found. My pet ferret can type better than you!
23:59:29 <Cale> So even if lazyPlus didn't need y, say, you'd still evaluate y to the top-level constructor
23:59:30 <ojacobson> damn.
23:59:33 <mm_freak> but the addition itself is not strict, i.e. i couldn't write a length function with it, without $! on the accumulator, right?
23:59:33 <shachaf> ojacobson: It's syntax.
23:59:50 <ojacobson> shachaf: context -- 
23:59:50 <sjanssen> mm_freak: correct
23:59:51 <shachaf> > let { f l@(x:xs) = (l,x,xs) } in f [1,2,3]
23:59:52 <ojacobson> normRaw' e
23:59:52 <ojacobson> 	= case e of
23:59:52 <ojacobson> 		n@(RawNat _) -> n
23:59:52 <lambdabot>  ([1,2,3],1,[2,3])
23:59:53 <ojacobson> ...
