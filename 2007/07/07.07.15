00:20:38 <cognominal_> where is <- documented?
00:21:45 <oerjan> @where report
00:21:45 <lambdabot> http://www.haskell.org/onlinereport/
00:21:59 <oerjan> (section on expressions)
00:23:05 <oerjan> in particular, do expressions and list comprehensions
00:23:07 <cognominal_> thx, google does not help much on searching non alphabetic strings
00:25:50 <pejo> In latex, is there an easy way to have a tabular or similar that is multicolumn at the top but not at the bottom?
00:27:39 <wli> Hmm, BinaryNumber.hs ...
00:27:45 <oerjan> pejo: \multicolumn, perhaps
00:27:49 <|Steve|> Apart from using \multicolumn on all of the lines  you mean?
00:28:10 <oerjan> http://www-h.eng.cam.ac.uk/help/tpl/textprocessing/teTeX/latex/latex2e-html/ltx-268.html
00:28:13 <lambdabot> Title: Help On LaTeX \multicolumn, http://tinyurl.com/2vks9w
00:28:20 <pejo> Steve, yeah, something like that. 
00:29:07 <|Steve|> Not that I know of.
00:30:28 <pejo> Or a tabular in the tabular. Mmm. 
00:30:35 <pejo> oerjan/Steve, thanks.
00:32:43 <stefanha> Is it possible to use Text.Regex with Data.ByteString.Lazy?
00:48:26 <wli> Hmm, BinaryNumber.hs ... how to check for primality
00:57:26 <|Steve|> peralta's primality test.
01:29:53 <DRMacIver> Morning
01:31:43 <yaxu> good morning, i'm trying to find how to find a string 'halfway' between two other strings
01:32:00 <yaxu> according to levenshtein distance
01:32:18 <yaxu> so the string most similar to two other strings
01:32:29 <yaxu> does that have a name?
01:32:42 <DRMacIver> Hm. No clue. :) 
01:32:57 <DRMacIver> Let me go get some coffee and then I'll take a look...
01:33:19 <yaxu> enjoy :)
01:35:04 <yaxu> i think i can work it out i think, i'm just wondering if it's a common problem with a name
01:35:11 <yaxu> that i can google for :)
01:35:30 <kaol> is there a function that takes an URI (as a String or as something from Network.URI) and returns the query part as a Map String String? uriQuery in Network.URI only returns everything after (and including) the ? as a String
01:38:59 <DRMacIver> yaxu: Certainly not that I'm aware of, but it's not something I know significant amounts about. :)
01:40:45 <edward2> @pl witness m k = PredLevel $ witness m $ runPredLevel . k
01:40:45 <lambdabot> witness = fix (((PredLevel .) .) . flip flip (runPredLevel .) . ((.) .))
01:40:48 <edward2> blech
01:41:27 <edward2> @pl foo m k = PredLevel $ witness m $ runPredLevel . k
01:41:27 <lambdabot> foo = (PredLevel .) . (. (runPredLevel .)) . witness
01:41:33 <edward2> a little less blech
01:42:30 <crazy_coder> hello everyone
01:43:20 <crazy_coder> if I have a string say "xyz4" , "xyz4"!!3 gives '4' right ?
01:43:35 <TSC> > "xyz4" !! 3
01:43:43 <lambdabot>  '4'
01:43:52 <crazy_coder> If I want a int 4 , and not char 4, is there a std function I can use ?
01:44:02 <TSC> @hoogle Char -> Int
01:44:03 <lambdabot> Char.digitToInt :: Char -> Int
01:44:03 <lambdabot> Char.ord :: Char -> Int
01:44:11 <edward2> > ord '4' - ord '0'
01:44:13 <lambdabot>  4
01:44:14 <edward2> =)
01:44:23 <TSC> Ugh, no
01:44:24 <xerox> > read '4' :: Int
01:44:25 <lambdabot>  Couldn't match expected type `String' against inferred type `Char'
01:44:36 <xerox> Well, that anyway :)
01:44:36 <edward2> > digitToInt '4'
01:44:38 <crazy_coder> Char.ord ("xyz4"!!3)
01:44:38 <lambdabot>  4
01:44:57 <edward2> ord gives you the unicode codepoint, digitToInt is what you want
01:45:00 <crazy_coder> > digitToInt ("xyz4"!!3)
01:45:02 <lambdabot>  4
01:45:08 <crazy_coder> Oh Ok
01:45:20 <crazy_coder> Is digitToInt included in prelude ?
01:45:24 <TSC> Yes
01:45:29 <crazy_coder> Thanks 
01:45:30 <crazy_coder> :)
01:46:01 <TSC> Wait
01:46:07 <edward2> import Data.Char
01:46:07 <TSC> You mean the Prelude module?
01:46:22 <crazy_coder> its not included in prelude module,
01:46:23 <edward2> its not in the prelude iirc, it was in Char originally
01:46:35 <edward2> so it should be in Data.Char these days
01:46:37 <TSC> I meant it's in base; it's not in Prelude
01:46:44 <crazy_coder> Ok
01:46:48 <ojacobson> Is Char in haskell a character (regardless of what its unicode code point is) or is it some arbitarily-small fixed-size int like in other languages?
01:46:51 <crazy_coder> So import Data,Char
01:46:57 <crazy_coder> Data.Char
01:47:20 <DRMacIver> ojacobson: I think it's the latter. I wouldn't swear to it though.
01:47:36 <DRMacIver> ojacobson: As I understand it, Haskell's unicode support doesn't really work yet. 
01:47:53 <TSC> The documentation says it's Unicode
01:47:58 <DRMacIver> Really?
01:48:03 <DRMacIver> Ok. Ignore me. :)
01:48:30 <TSC> "The character type Char is an enumeration whose values represent Unicode ... [etc]"
01:48:39 <edward2> ojacobson: its basically a 32 bit int right now with the intention that a Char should represent a unicode codepoint (and hence only the first 21 bits or so should be use)
01:48:42 <edward2> er used
01:48:53 <ojacobson> sou.  Thanks.
01:49:14 <edward2> that said most implementations just print out the values mod 256 ;)
01:49:37 <edward2> so the IO libraries are largely not-Unicode friendly
01:59:37 <oerjan> yaxu: i am pretty sure the string half-way between two strings won't be unique.
02:01:48 <xerox> Anybody knows how to fix "Symbol's function definition is void: inferior-haskell-type" on C-c C-t in Emacs haskell-mode?
02:01:55 <oerjan> for example, between "abcd" and "efgh", any of "abgh", "afch", "ebch" would be equally valid
02:02:24 <oerjan> (and more)
02:03:50 <integral> change the question to be how to enumerate all those strings...
02:04:43 <pejo> xerox, is your load-path correct?
02:04:53 <xerox> Maybe (load "/path/to/haskell-mode/haskell-site-file") isn't enough for initialization.
02:06:10 <xerox> pejo, it does not look into subdirectories? I'll add it manually.
02:07:36 <dons> ?users
02:07:36 <lambdabot> Maximum users seen in #haskell: 355, currently: 305 (85.9%), active: 12 (3.9%)
02:08:50 <pejo> xerox, I have no idea about this, but my .emacs contains a (setq load-path (cons "~/.elisp/haskell-mode-2.1" load-path))
02:09:12 <pejo> (And then your mentioned line with load).
02:10:04 <xerox> Found on emacswiki, this adds all the subdirectories (progn (cd "~/elisp") (normal-top-level-add-subdirs-to-load-path))
02:11:03 <oerjan> i'm not an emacs user, but won't that have the side effect of changing your local directory?
02:11:12 <TSC> Yeah, I'd change it back afterward
02:11:37 <xerox> oerjan, yes it does :)
02:15:52 <dons> you know what''s interesting about the latest tiobe rankings, http://www.tiobe.com/tpci.htm -- F# is ranked higher than OCaml
02:15:54 <lambdabot> Title: TPCI - TIOBE Programming Community Index
02:16:12 <dons> buzz buzz
02:17:08 <yaxu> oerjan: you mean there could be more than one string halfway?  yes i agree
02:17:26 <oerjan> yaxu: in fact there may be exponentially many
02:17:48 <oerjan> er wait
02:18:35 <yaxu> oerjan: if the edit distance between A and B is 6, i only want the strings 3 edits away from both A and B
02:18:40 <oerjan> for the example i gave, n over n/2, which i think is exponential or so
02:19:33 <oerjan> because for the half-way point, you can choose any n/2 from one string.
02:20:17 <yaxu> oh i didn't see your other messages, i see your point
02:20:59 <dons> yaxu, hi, btw. how's (live) code? :)
02:21:01 <oerjan> > let n `over` k = product [1..n] `div` product [(k+1)..(n-k+1)] in [(2*n) `over` n|n <- [1..]]
02:21:03 <lambdabot>  [1,8,180,8064,604800,68428800,10897286400,2324754432000,640237370572800,2211...
02:21:30 <yaxu> oerjan: for my purposes the two strings will be quite similar though
02:22:30 <yaxu> dons: good thanks, we're having a livecoding festival in north of england next week
02:24:16 <yaxu> dons: i haven't spent much time on livecoding myself recently, although am hoping to get funding for full time PhD research which will give me a lot more time for such fun things
02:25:15 <eivuokko> dons, I have sighted quite many posts about F# on Microsoft forums, and there's atleast one beginner book for it already, iirc.
02:25:32 <Igel> hello
02:25:55 <Igel> i want to generate a haddock documentation, that references external haddocks
02:26:01 <eivuokko> dons, There's some people coding xna stuff with F# for xbox 360 as well, not sure if that matters for tiobe index really, tho.
02:26:08 <Igel> i found the -i option
02:26:25 <Igel> but i don't know, where to find these interface files
02:27:34 <Igel> the idea is to deliver the documentation of a project that has links to other documentations on the internet
02:27:51 <Igel> so that the same html works on other computers as well
02:28:03 <dons> eivuokko: very interesting. i guess microsoft, if anyone, can get a language adopted
02:28:18 <dons> http://programming.reddit.com/info/26i0c/details
02:28:19 <lambdabot> Title: The Haskell monomorphism restriction and the unintentional fib (reddit.com)
02:28:26 <Igel> (e.g. mtl shall not be referenced in /usr/share/doc, but on www.haskell.org/...)
02:29:22 <dblhelix> morning #haskell
02:29:27 <dons> morning dblhelix !
02:30:44 <eivuokko> dons, Yeah.  I think I saw F# in only one "officially supported" list for some technology, tho.
02:31:29 <wli> Is this the bit about Haskell becoming the next Visual Basic?
02:31:50 <eivuokko> dons, But Microsoft, or so it seems to me, has been now driving the multiple languages-systems strongly, so python and ruby have got a lot of attention.
02:32:15 <dons> hopefully a bit more .NET support for ghc (currently being worked on) can help 
02:32:31 <eivuokko> Is there a status report on .net stuff?
02:32:43 <dons> yeah, let's see if I can find it..
02:33:00 <dons> we have a (top!) student, aja, here working on the .NET FFI.
02:33:06 <eivuokko> Meh
02:33:16 <eivuokko> .net ffi = interoperability?
02:33:24 <dons> so that'll probably be the resulting library for now.
02:33:24 <dons> you'l
02:33:32 <dons> l be able to use .NET libs, and call either way
02:33:41 <eivuokko> Cool libraries from .Net, but no embedded devices etc -.-
02:33:42 <hpaste>  wli pasted "quick and dirty p-adics based on BinaryNumber.hs" at http://hpaste.org/1690
02:33:53 <dons> yeah, probably
02:34:05 <dons> you can use haskell as just another language with the libs you've got on windows
02:34:44 <eivuokko> Gotta try to put it to use anyway, can't allow more Windows stuff bitrot.
02:35:39 <hpaste>  opqdonut pasted "qsort optimization" at http://hpaste.org/1691
02:35:55 <opqdonut> weird that it isn't faster, just less allocative
02:48:17 <crazy_coder> how to resolve ambiguous occurance of 2 function names, one defined in prelude and other user defined ?
02:48:32 <crazy_coder> We have to use the . right? 
02:48:55 <matthew-_> yes
02:49:03 <matthew-_> or hide one of them
02:49:11 <matthew-_> do you actually need both?
02:49:17 <crazy_coder> What should be before the . ? 
02:49:26 <crazy_coder> Name of the included module ?
02:49:27 <matthew-_> the module name
02:49:30 <matthew-_> and you must use
02:49:33 <kowey> to make this convenient, you could import the Prelude hiding the function, and then import qualified Prelude as P
02:49:36 <matthew-_> import qualified Foo.Bar as Baz
02:49:48 <matthew-_> then Baz.wibble will call wibble in module Foo.Bar
02:49:56 <crazy_coder> but we never import prelude
02:50:02 <matthew-_> it's implicit
02:50:10 <matthew-_> if you make it explicit then you can hide functions
02:50:21 <crazy_coder> So here I have to do import qualified prelude as pre       for eg
02:50:45 <matthew-_> err, I wouldn't do a qualified import of the prelude
02:51:09 <crazy_coder> I want to use the prelude function in certain cases
02:51:12 <matthew-_> as then you'll have to prefix every function call to a function in prelude with pre.
02:51:23 <crazy_coder> Oh ok
02:51:28 <crazy_coder> Then it should work
02:51:28 <matthew-_> ok, you cat also import the same module twice
02:51:40 <matthew-_> one "qualified" and one not
02:51:42 <crazy_coder> Thanks
02:51:56 <matthew-_> then, just use the qualified version to avoid the ambiguite
02:51:59 <matthew-_> -e+y
02:52:07 <matthew-_> sorry, I'm not explaining this very well at all
02:53:15 <crazy_coder> When I import it as qualified, I have to use pre . (every single prelude function)
02:53:23 <crazy_coder> Is there anyway around this ?
02:53:28 <matthew-_> yes
02:53:32 <matthew-_> import it twice
02:53:35 <crazy_coder> Ok
02:53:40 <matthew-_> once as qualified, once without
02:53:42 <matthew-_> crazy_coder: see http://www.haskell.org/onlinereport/modules.html#import
02:53:42 <lambdabot> Title: The Haskell 98 Report: Modules
02:53:51 <kowey> but the one without must hide the function in question
02:54:49 <crazy_coder> can we hide classes ?
02:55:38 <Saizan> yes
02:55:40 <matthew-_> you can hide anything that is exported from the module in question
02:55:48 <crazy_coder>  thanks
02:55:49 <crazy_coder> :)
03:18:32 <DRMacIver> Hm.
03:18:36 <DRMacIver> My C-fu is far too weak. :-/
03:21:20 <TSC> Hmm?
03:21:53 <|Steve|> I wouldn't go to ##c, if I were you.
03:22:10 <DRMacIver> I've done it before. I found them unexpectedly helpful actually.
03:22:16 <|Steve|> Really?
03:22:22 <|Steve|> I was there for a bit, their ops are trolls.
03:22:28 <|Steve|> One guy's good, one's a massive dick.
03:22:34 <DRMacIver> Yes. I might have just been lucky though.
03:22:36 <|Steve|> It was about the opposite of #haskell.
03:22:43 <DRMacIver> Sounds like ##java. ;)
03:22:53 <|Steve|> Hmm, I'm told I need to watch the rest of this movie. bbl.
03:22:58 <DRMacIver> Have fun. :)
03:23:36 <DRMacIver> (What prompted the comment is that I'm playing with QDBM and am having a bizarre issue when dynamically linking the libraries - works fine if I statically link. Looks like it just can't find the library when I try to run it, but I really have no idea how all of this stuff fits together so I'm a bit of a loss as to what to try)
03:24:45 <TSC> ldd?
03:26:33 <DRMacIver> ?
03:26:58 <TSC> In Linux, link it dynamically and then run ldd on the executable
03:27:17 <dblhelix> it takes quite some time to stay up-to-date on haskell-cafe these days
03:27:24 <TSC> It will say whether it knows where to find the dynamic libraries
03:27:31 <DRMacIver> Ahh. Thanks.
03:27:52 <DRMacIver> Ok, it's complaining about a missing library. Now for the really stupid question: How do I tell it where to look for libraries? :)
03:27:58 <TSC> ldconfig
03:29:54 <DRMacIver> Yay! Works. Thank you. :)
03:30:10 <TSC> You're welcome
03:30:35 <TSC> I learnt this shared library stuff trying to make Quake 2 run on the uni lab computers (:
03:30:39 <DRMacIver> Sorry for the stupid question. As I said, I'm very clueless about this sort of thing. :)
03:31:36 <DRMacIver> (This is even on topic really! I'm planning to try to use qdbm via the FFI as I want to play with some reverse text indexing and figured I'd be better off using one that someone had already spent a hell of a lot of time optimising)
03:35:25 <|Steve|> Gah. I _really_ enjoyed that movie, right up until the end.
03:35:38 <DRMacIver> What was the movie?
03:35:54 <|Steve|> Prestige.
03:38:11 <DRMacIver> Hm. Not heard of it.
03:38:14 * wli fails to get Dirichlet series multiplication going.
03:38:17 <DRMacIver> But I don't watch many movies. :)
03:39:57 <fasta> How can I tell myghci to load modules X,Y and Z at startup? I can simply make a module and load that, but can this be done also in another way?
03:40:31 <TSC> Maybe put some commands in .ghci?
03:40:40 <TSC> :m + Module1 Module2 ...
03:41:00 <TSC> Yeah, that seems to work
03:41:11 <fasta> TSC: can I give ghci another file to interpret?
03:41:25 <TSC> As in "ghci somefile.hs"?
03:41:37 <fasta> TSC: as in .otherghci
03:42:16 <TSC> Oh
03:42:38 <TSC> I'm not sure about that
03:42:51 <xpika> @src lex
03:42:51 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
03:43:19 <fasta> TSC: I will just go for the module approach
03:46:32 <xpika> what would be the preferred way to obtain the number in the number in a string like "abcd1001xyz"
03:47:52 <TSC> Depends on the general format
03:48:00 <fasta> > isAlpha "9"
03:48:01 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
03:48:06 <fasta> > isAlpha '9'
03:48:07 <lambdabot>  False
03:48:11 <fasta> > isAlpha 'a'
03:48:12 <lambdabot>  True
03:48:27 <fasta> xpika: using that
03:48:39 <fasta> xpika: and dropWhile and takeWhile
03:48:49 <TSC> What about filter?
03:49:13 <TSC> > filter isDigit "abcd1001xyz"
03:49:15 <lambdabot>  "1001"
03:49:16 <fasta> TSC: that's even better
03:49:35 <TSC> Assuming there's only one group of digits in there
03:50:50 <olsner> > groupBy isDigit "abcd1001xyz"
03:50:51 <lambdabot>  Couldn't match expected type `Char -> Bool'
03:51:01 <olsner> :t groupBy
03:51:03 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
03:51:36 <olsner> > filter (isDigit . head) $ groupBy ((==) `on` isDigit) "abcd1001xyz"
03:51:37 <lambdabot>   Not in scope: `on'
03:52:51 <olsner> blargh! something like that I think should be workable, returning a list of all-number parts of the string
03:54:17 <DRMacIver> I think the preferred way is "use parsec"
03:54:34 <TSC> Maybe a regexp
03:54:39 <DRMacIver> Noooo
03:54:45 <TSC> Maybe not then (:
03:55:01 * DRMacIver gives TSC conditioning therapy involving perl, parsec and a big stick.
03:55:23 <olsner> Clockwork Perl
03:55:51 <TSC> 'Some people, when confronted with a problem, think “I know, I’ll use regular expressions.” Now they have two problems.' ?
03:56:12 <TSC> For such a simple example it should be safe enough
03:56:23 <DRMacIver> That's where the danger lies!
03:56:29 <TSC> Yes, I know
03:56:30 <wli> So much for that. It gets wrong answers. :(
03:56:47 <DRMacIver> I mean, were this Java or Perl or the like I would agree with you that a regexp is good enough for this case.
03:57:05 <|Steve|> I made it to the Monad chapter in yaht and frankly, it falls apart there.
03:57:09 <DRMacIver> But this is Haskell. We have parsec. You should be using parsec. :)
03:57:25 <fasta> DRMacIver: for something as simple as this?
03:57:37 <DRMacIver> fasta: Why not?
03:57:55 <DRMacIver> parsec isn't exactly heavy weight.
03:57:59 <fasta> DRMacIver: the parsec equivalent will use the same level of abstraction. 
03:58:03 <fasta> DRMacIver: i.e. a filter
03:58:27 <fasta> DRMacIver: it only will be called satisfyList or similar
03:59:03 <xerox> > reads "1001xyz" :: [(Int,String)]
03:59:04 <lambdabot>  [(1001,"xyz")]
03:59:34 <fasta> > reads "xadas10002121dfddf" ::[String, Int, String]
03:59:34 <lambdabot>  Parse error
03:59:42 <fasta> > reads "xadas10002121dfddf" ::[(String, Int, String)]
03:59:43 <lambdabot>  Couldn't match expected type `(String, Int, String)'
03:59:58 <Saizan> ?type reads
04:00:00 <lambdabot> forall a. (Read a) => String -> [(a, String)]
04:00:14 <fasta> Oh, I thought it was a bit more advanced. 
04:00:30 <DRMacIver> fasta: Mm. This is admittedly a matter of choice for a problem this small, but I think the parsec one would be clearer, and that it would get you into good habits for when the problem set became more complicated rather than trying to extend one's earlier code.
04:00:30 <wli> Never mind, I get right answers.
04:00:44 <wli> Garbage in, garbage out, etc.
04:00:47 <DRMacIver> fasta: The "noooo" was in response to using regexps, not doing it with filter.
04:00:59 <fasta> DRMacIver: yes, there can be said something for that.
04:01:19 <fasta> DRMacIver: sometimes I even use strings function when I am working with parsec. 
04:01:27 <olsner> parsec's top-level interface is kind of complicated though.. runParser :: Parser t s a -> s -> SourceName -> [tok] -> Either ParseError a
04:01:28 <fasta> DRMacIver: e.g drop 2 for example
04:01:35 <TSC> > head $ (filter (not . null) $ map reads (tails "abc1001xyz") :: [[(Int, String)]])
04:01:36 <lambdabot>  [(1001,"xyz")]
04:01:40 <olsner> needs about 4 lines of boilerplate just to get into the parser
04:01:54 <fasta> DRMacIver: and lines etc.
04:02:04 <DRMacIver> olsner: Hm. Good point.
04:02:33 <olsner> most of times you basically just want run :: Parser t a -> [t] -> Maybe a
04:03:01 <DRMacIver> Anyway, this is really just me being traumatised by the recent code I was exposed to as the result of people not doing things properly. :)
04:04:05 <DRMacIver> fasta: Yeah, I guess I can see the appeal in doing that. Maybe if I'd written more parsing code in Haskell than I have I'd relax my position. ;)
04:05:46 <wli> Interesting thing just happened. ghci just spawned a *zillion* threads.
04:07:07 <wli> Dirichlet series appear to be very slow methods of computing number-theoretic functions.
04:07:26 <olsner> are there any nice unparser libraries for haskell? something like a parser combinator library you can also run backwards?
04:07:37 <olsner> unparse :: Parser tok a -> a -> [tok]
04:07:46 <Syzygy-> > filter (not . null) . map reads . tails $ "abc123def456ghi1001xyz" :: [[(Int,String)]]
04:07:48 <lambdabot>  [[(123,"def456ghi1001xyz")],[(23,"def456ghi1001xyz")],[(3,"def456ghi1001xyz"...
04:07:50 <wli> olsner: I think they're usually called pretty printers.
04:09:22 <psykotic> has anyone tried writing a generic function for 'tying knots' using SYB or something like that?
04:10:24 <|Steve|> I know what AYB is, but what is SYB?
04:10:38 <psykotic> scrap your boilerplate
04:10:43 <fasta> psykotic: how "generic" must it be? mfix and fix seem to work nicely as is. 
04:10:47 <DRMacIver> Some of Your Bases
04:10:52 <|Steve|> Heh.
04:10:52 <psykotic> fasta: i mean when you have a level of indirection.
04:10:54 <olsner> > (map fst . concatMap reads . groupBy (\x y -> isDigit x == isDigit y)) "abc1001xys123asdf567g"
04:10:56 <lambdabot>  [1001,123,567]
04:11:32 <psykotic> fasta: imagine you have a structure with labeled nodes and labeled "edges". you want to "tie the knots" so that the labeled edges are replaced with actual references to the corresponding labeled nodes. that's the usual Tying The Knot trick, and i'm trying to see if there's a way to express it generically using SYB.
04:15:23 <olsner> @pl (\s -> (f s) ++ " "++(g s) ++ ((f.g.h) s))
04:15:24 <lambdabot> liftM2 (++) f ((' ' :) . liftM2 (++) g (f . g . h))
04:15:56 <olsner> instant obfuscation ;-)
04:16:07 <|Steve|> Heh.
04:16:16 <|Steve|> @unpl  liftM2 (++) f ((' ' :) . liftM2 (++) g (f . g . h))
04:16:16 <lambdabot> (f >>= \ b -> (\ q -> ' ' : ((g >>= \ k -> (\ t -> f (g (h t))) >>= \ j -> return (k ++ j)) q)) >>= \ a -> return (b ++ a))
04:16:25 <|Steve|> Heh, that's no better.
04:16:38 <dolio> @pl \a b c d e f g -> b c (f,g) a e d
04:16:40 <lambdabot> (((flip . ((flip . (flip .)) .) . flip . (flip .)) .) .) . flip (flip . ((flip . (flip .)) .) . flip flip (,) . (((.) . (.)) .))
04:16:50 <|Steve|> heh.
04:16:53 <|Steve|> That's so terrible.
04:16:57 <xpika__> > parse (do{many1 letter;x<-many1 digit;return x}) "" "abcd1001xyz"
04:16:58 <lambdabot>   Not in scope: `digit'
04:18:03 <dolio> Yes, well, if you ever need to write a function that randomly shuffles arguments around, clearly variables are the way to go. :)
04:18:05 <xerox> ?pl \x -> you x off
04:18:06 <lambdabot> flip you off
04:18:43 <|Steve|> Heh.
04:20:59 <Syzygy-> ?pl \x -> the x bird
04:21:00 <lambdabot> flip the bird
04:21:29 <psykotic> richard bird? :)
04:26:26 <xerox> ?pl \x y -> flop y x
04:26:26 <lambdabot> flip flop
04:26:39 <wli> For prime Dirichlet series this thing spends almost all its time working with zeroes. Oh well.
04:26:42 <|Steve|> Heh.
04:27:00 <|Steve|> Is that a D-flip flop?
04:35:06 <wli> maximizing a + b : a, b >= 1 and a*b <= n seems to give n
04:35:17 <wli> n + 1 rather
04:35:53 <|Steve|> So it would seem.
04:36:23 <DRMacIver> Isn't that obvious from considering the continuous case?
04:36:27 <TSC> Seems right
04:36:39 <|Steve|> I thought that was the continuous case.
04:36:46 <TSC> You're trying to minimise the product, and multiplying by one will do that
04:36:48 <wli> DRMacIver: I'm not feeling confident in my grasp of the obvious today.
04:37:06 <wli> |Steve|: It's not but I'm using it to establish conservative bounds.
04:37:19 <|Steve|> ah
04:37:51 <wli> Okay, it's a little faster now.
04:38:20 <DRMacIver> Any local extrema have to occur when a = b. This will obviously be maximised when making a and b as large as possible, so a = b = sqrt(n). This gives 2sqrt(n), which is less than n + 1 (well, at most n + 1 when n = 1). So this line gives minima and maxima have to happen at the boundaries.
04:38:33 <DRMacIver> </hand waving>
04:38:55 <wli> DRMacIver: I tried using that and got wrong answers. :(
04:39:30 <wli> DRMacIver: (a+b)^2 <= 4*n broke. :(
04:44:53 <benny99> why does yaht promise a pong-game in Chapter8 and then suddenly starts talking about something different and does not come back to the game :'( ?
04:45:18 <Botje> it is a silly game.
04:46:18 <benny99> I want it anyway, since chapter8 promised it
04:46:27 <benny99> whatever :(, I'm going to read 9
04:47:24 <|Steve|> Heh.
04:47:28 <|Steve|> I noticed that too.
04:47:35 <|Steve|> I'm on chapter 9, but I decided to drink instead.
04:47:41 <|Steve|> It makes more sense.
04:49:40 <benny99> :-/ drink instead ?
04:49:52 <|Steve|> I'm watching Highlander.
04:50:03 <benny99> ah :)
04:50:08 <|Steve|> But yes, drinking made more sense than monads.
04:50:14 <benny99> ._. ?
04:50:26 <|Steve|> That's chapter 9.
04:50:33 <benny99> I'll read that chapter now, maybe they make sense to me
04:50:41 <benny99> yeah, read the first page already :p
04:50:45 <|Steve|> Parts of it makes sense.
04:50:48 * benny99 is gone for ~30min
04:51:07 * benny99 is back for ~1min :Z
04:51:14 <benny99> what does augment do again ?
04:51:20 <|Steve|> >>=
04:51:31 <benny99> >>= ? ah
04:51:48 <|Steve|> I'm not sure I understand it well enough to explain. Plus, you know, booze.
04:51:53 <benny99> it concernates (spelled incorrectly ?) the results huh ?
04:52:07 <benny99> yeah
04:52:32 <|Steve|> :t (>>=)
04:52:34 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
04:52:38 <|Steve|> It does that.
04:53:16 <wli> Alrighty, there we go.
04:53:53 <|Steve|> Where the hell did his sword come from? Out of his pants?
04:54:26 <benny99> |Steve|: probably, got some in my underwear, too :>
04:54:35 * benny99 is gone for ~30min
04:55:18 <Botje> benny99: please turn that off :/
04:55:35 <|Steve|> They're doing a lot more flipping than I ever did when I learned to fight with a sword...
04:55:41 * |Steve| goes away and stops being OT.
04:56:09 <wli> What's the limit on the number of lines in a code snippet for hpaste.org?
04:56:20 <cbtf> @dict OT
04:56:20 <lambdabot> Supported dictionary-lookup commands:
04:56:20 <lambdabot>   all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
04:56:20 <lambdabot> Use "dict-help [cmd...]" for more.
04:56:49 <cbtf> @jargon OT
04:56:50 <lambdabot> *** "OT" jargon "Jargon File (4.3.1, 29 Jun 2001)"
04:56:50 <lambdabot> OT // [Usenet: common] Abbreviation for "off-topic". This is used to
04:56:50 <lambdabot>    respond to a question that is inappropriate for the newsgroup that the
04:56:50 <lambdabot>    questioner posted to. Often used in an HTML-style modifier or with
04:56:50 <lambdabot>    adverbs.
04:56:52 <lambdabot>  
04:57:05 <benny99> didn't knew that either
04:57:11 <cbtf> lambdabo++
04:58:07 <Heffalump> wli: 5K of text, IIRC (as opposed to a number of lines)
04:58:09 <|Steve|> @cbtf++
04:58:10 <lambdabot> Unknown command, try @list
04:58:32 <benny99> main = -- note the lack of a "do"
04:58:32 <benny99>   readFile "somefile" ‘augment‘ \s ->
04:58:32 <benny99>   putStrLn (show (f s))
04:58:32 <benny99> sorry -- is somebody able to explain what is happening :( ?
04:58:40 <hpaste>  wli pasted "quick and dirty Dirichlet series" at http://hpaste.org/1692
04:59:18 <TSC> benny99: augment is just (>>=) ?
04:59:24 <cbtf> @help karma
04:59:24 <lambdabot> karma <polynick>. Return a person's karma value
04:59:30 <benny99> TSC: yeah
04:59:47 <benny99> TSC: at least the book says so
04:59:50 <TSC> benny99: It looks like it's reading a file, applying f to its contents and printing the result
05:00:04 <benny99> and what is f :| ?
05:00:17 <TSC> Some function on a string
05:00:22 <benny99> some function the author didn't mention ?
05:00:22 <TSC> f :: String -> a
05:00:27 <benny99> ok, thanks :)
05:00:28 <TSC> I guess so
05:00:43 <TSC> Try adding to the file something like "f = reverse"
05:00:47 <|Steve|> The book gets a bit sketchy there.
05:01:07 <TSC> Or f = map toUpper
05:01:32 <cbtf> Steve, save me reading the logs: What book?
05:01:38 <benny99> |Steve|: yeah... the first 7 chapters were superb
05:01:48 <benny99> cbtf: YAHT
05:01:53 <cbtf> hmm
05:01:55 <|Steve|> benny99: Yeah.
05:02:13 <benny99> the first 7 chapters I though I was reading the best programming book ever, but then :<
05:03:04 <benny99> omg ...
05:03:31 <|Steve|> 8 was alright.
05:03:32 <benny99> I just wrote "/msg me if anything importants happen, I'm gone" ... whatever, you recieved it also now :p
05:03:35 <|Steve|> 9 went down hill fast.
05:03:48 <wli> |Steve|: Which book is this?
05:03:55 <benny99> wli: yet another haskell tutorial
05:04:00 <|Steve|> yes
05:04:13 <cbtf> @where yaht
05:04:13 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
05:10:37 <benny99> a >> x = a >>= \_ -> x <--- I'm dumb huh? what does this do?
05:11:01 <|Steve|> It ignores it's input.
05:11:17 <benny99> I'm dumb :(
05:11:39 <sphynx> hi
05:11:59 <sphynx> I wonder why lambdabot can't pl such expression: \[x,y] -> (x,y)
05:12:06 <sphynx> ?pl \[x,y] -> (x,y)
05:12:06 <lambdabot> (line 1, column 2):
05:12:07 <lambdabot> unexpected "["
05:12:07 <lambdabot> expecting pattern
05:12:27 <DRMacIver> sphynx: It uses its own parser rather than a standard Haskell one, and has a few problems as a result.
05:13:21 <sieni> benny99: It basically means that a is run for its side effect and the return value is ignored
05:13:22 <sphynx> hm.. maybe anyone could help with pl instead of lambdabot? :)
05:13:42 <wli> Hmm.
05:13:42 <benny99> what would ?[1..] do :Z ?
05:13:52 <|Steve|> > [1..]
05:13:54 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
05:14:05 <benny99> sieni: understood :)
05:14:12 <benny99> ah :)
05:14:21 <xerox> How do you gather source information so to make C-c M-. bring you to the source of some definition in haskell-mode?
05:14:25 <DRMacIver> sphynx: head && (head.tail) will almost do what you want.
05:14:27 <DRMacIver> err
05:14:31 <DRMacIver> head &&& (head.tail)
05:14:55 <sieni> benny99: like printf() in C returns the number of charaters written. How often do you use that? :-)
05:14:58 <DRMacIver> ?pl x:y:[] -> (x, y)
05:14:58 <lambdabot> (line 1, column 8):
05:14:58 <lambdabot> unexpected ">" or "-"
05:14:58 <lambdabot> expecting variable, "(", operator, ":", "++" or end of input
05:15:02 <DRMacIver> ?pl \x:y:[] -> (x, y)
05:15:02 <sphynx> DRMacIver: is it some arrow expression? I didn't look at arrow yet..
05:15:02 <lambdabot> (line 1, column 6):
05:15:02 <lambdabot> unexpected "["
05:15:02 <lambdabot> expecting natural, identifier, "_" or "("
05:15:08 <DRMacIver> Hm
05:15:15 <xerox> parens
05:15:17 <DRMacIver> sphynx: Yes, but you don't need to know much about arrows to use it.
05:15:27 <benny99> sieni: I didn't even knew that :D
05:15:46 <sphynx> ?pl \(x:y:[]) -> (x,y)
05:15:46 <lambdabot> (line 1, column 7):
05:15:46 <lambdabot> unexpected "["
05:15:46 <lambdabot> expecting natural, identifier, "_" or "("
05:15:48 <benny99> know
05:15:52 <DRMacIver> sphynx: For functions f, g we basically have (f &&& g) x = (f x, g x)
05:15:58 <DRMacIver> ?pl \x:y:_ -> (x, y)
05:16:17 <benny99> he killed lambdabot :'(
05:16:31 <lambdabot> ap ((`ap` tail) . (. head) . (const .) . (,) . head) tail
05:16:32 <lambdabot> Plugin `pl' failed with: IRCRaised thread killed
05:16:53 <sphynx> DRMacIver: OK, I'll try to use &&&
05:17:08 <DRMacIver> sphynx: Note that this matches a larger set of patterns than yours.
05:17:26 <sieni> benny99: also the return type of a might be e.g. IO (), so you don't need to use the return value for anything, since you already know what it is (i.e. ())
05:17:31 <sphynx> DRMacIver: this also matches longer lists?
05:17:36 <DRMacIver> Yeah
05:17:48 <araujo> morning
05:17:49 <sphynx> DRMacIver: It's mot a problem here, so all is ok
05:18:57 <wli> :q
05:19:12 <benny99> sieni: yeah, understood already ^^, in the book it's mentioned as "then"
05:19:22 <benny99> sieni: but thanks again
05:20:27 <DRMacIver> sphynx: Familiarising yourself with what the Arrow stuff does for its function instance is probably a good idea if you want to write lots of pointfree code. :)
05:23:06 <olsner> is there any reason why 'if' has to be built-in? unless I'm missing something, if True t f = t; if False t f = f; should be equivalent, right?
05:23:29 <DRMacIver> Yes.
05:23:34 <Lemmih> olsner: It's just syntactic sugar.
05:23:46 <DRMacIver> It's because they wanted people to be able to write 'if ... then ... else' 
05:24:04 <olsner> okay
05:24:06 <DRMacIver> Lemmih: I'm not sure I agree with that. It's more like syntactic tar. ;)
05:24:19 <|Steve|> It's better than scheme's (if ...)
05:24:21 <sphynx> DRMacIver: but I think Arrow stuff is a bit hard to understand even than monads ) And I'm not so good at monads yet
05:24:31 <sphynx> hm.. strange things happen
05:24:32 <xerox> Does C-c M-. work in your Emacs' haskell-mode, bringing you to the source of the identifier at point? 
05:24:42 <wli> So I've got what I think can use a writer monad.
05:24:44 <DRMacIver> sphynx: Well don't try to grok arrows. Just find out what the combinators do for functions. :)
05:24:47 <sieni> |Steve|: well, but in scheme you need `if' as a special form, since scheme is strictly evaluated
05:24:54 <olsner> if/then/else reduces the number of parantheses in conditionals I guess
05:25:02 <sieni> |Steve|: in Haskell if-then-else is just a regular function
05:25:11 <DRMacIver> sieni: No it isn't.
05:25:14 <sphynx> > split ':' . pack . last . words $ "  private var _id:String;"
05:25:15 <lambdabot>   Not in scope: `pack'
05:25:29 <DRMacIver> sieni: It should be, but it's not. :)
05:25:45 <sphynx> well, this code returns ["_id","String;"]
05:26:03 <sphynx> then I try to use head &&& (head . tail)
05:26:06 <sieni> DRMacIver: well, it has a special syntax, but doesn't need any special rules for evaluation
05:26:07 <olsner> If haskell had sugar for keyword parameters, if/then/else could be a regular function with the same syntactic sugar
05:26:19 <DRMacIver> > head &&& (head . tail) $ ["foo", "bar"]
05:26:20 <lambdabot>  ("foo","bar")
05:26:33 <DRMacIver> sieni: Right. But you can't treat it as a function.
05:26:45 <sphynx> head &&& (head . tail) . split ':' . pack . last . words " private var _id:String;" returns something strange
05:26:50 <DRMacIver> sieni: You can't do things like 'map if', etc. it's not first class.
05:26:54 <|Steve|> :t (&&&)
05:26:56 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
05:27:01 <sphynx> *Main> head Control.Arrow.&&& (head . tail) . Data.ByteString.Char8.split ':' . Data.ByteString.Char8.pack . last . words $ "  private var _id:String;"
05:27:04 <sphynx> (' ',"String;")
05:27:06 <DRMacIver> sphynx: You might have a precendence problem there. Try introducing brackets until it makes sense. :)
05:27:58 <sieni> @t if'
05:27:58 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
05:28:15 <sieni> @type if'
05:28:17 <lambdabot> Not in scope: `if''
05:28:24 <sphynx> DRMacIver: really, I've added brackets to( head &&& (head.tail))
05:28:34 <sphynx> DRMacIver: and all works ) thanks!
05:28:43 <DRMacIver> No worries. Glad I could help. :)
05:29:53 <wli> Basically a linear algebra -type thing that needs to log certain things it's doing to the matrix so the solution vector and right-hand side vector can be properly adjusted.
05:30:09 <sieni> But you can define a function if' of type Bool -> a -> a -> a, which works just like if-then-else
05:30:57 <HairyDude> hrm... the DrIFT examples import a load of libraries at the top level, which ghc can't find
05:31:35 <HairyDude> what is ParseLib2?
05:31:49 <HairyDude> oh, it's in the DrIFT source
05:31:50 <earthy> hm.
05:32:26 <earthy> isn't there an option to cabal's Distribution.Simple.defaultMain that will install docs for you??
05:34:09 <HairyDude> seems to me like the DrIFT distribution in ubuntu universe needs to be accompanied by a doc package containing most of the source...
05:36:10 <sieni> > zipWith3 (\x -> case x of {True -> const; False-> flip const}) [True, False] [3, 4] [5,6]
05:36:11 <lambdabot>  [3,6]
05:36:44 <benny99> bye :)
05:49:43 <dangb> how does STRef work? 
05:50:26 <sieni> dangb: work in what sense?
05:50:57 <olsner> dons: beautiful post! "wrong kind of bracket" ;-)
05:51:08 <dons> heh
05:51:12 <dons> sssh!!
05:51:22 <dangb> I'm having trouble finding the place where the implementation of some of the functions are
05:51:40 <dons> which functions, dangb?
05:51:57 <Lemmih> ?src writeSTRef
05:51:57 <lambdabot> writeSTRef (STRef var#) val = ST $ \s1# ->
05:51:57 <lambdabot>     case writeMutVar# var# val s1#      of { s2# ->
05:51:57 <lambdabot>         (# s2#, () #) }
05:52:07 <Lemmih> That should clear things up.
05:52:15 <dons> heh
05:52:18 <dangb> dons: sorry, I just realized that I should check GHC.STRef ...
05:52:50 <dons> yeah, those low level things are in GHC.*
05:53:00 <wli> Hmm, I'm not entirely sure what's going on with writer monads. It looks vaguely like you have to pass it some sort of monoidal aggregate.
05:54:47 <wli> Like, say, a list.
05:56:49 <dangb> I get some weird letter of which I don't know the name right where the backslash for a lambda function should be, should this happen? If yes, what's its name?
05:57:41 <kaol> most probably it's a lambda. As in the greek character.
05:58:44 <dangb> yes, but it doesn't look like a lambda at all, which encoding should I use?
05:59:17 <Saul_> http://haskell.org/hoogle/?start=0&q=html <- These links don't seem to work, does anyone know where I can get the docs?
05:59:18 <lambdabot> Title: html - Hoogle
06:00:32 <chris2> is there an epigram version for gnu emacs?
06:01:01 <earthy> saul: http://www.haskell.org/ghc/docs/latest/html/libraries/html/Text-Html.html
06:01:03 <lambdabot> http://tinyurl.com/2qgf4r
06:01:28 <wli> Hmm, I wonder if mapIndices is a more intelligent way to swap rows and columns that copying data elements.
06:01:33 <dangb> I mean the encoding for the irc client
06:02:42 <wli> I'll stick to stupider-than-thou for now.
06:02:43 <Saul_> earthy: Yeah I already found it, there is also an xhtml version
06:02:47 <sphynx> I have a problem with BS.interact... It seems that it works for me only for last line of the stdin
06:02:54 <Saul_> earthy: thanks though
06:02:59 <sphynx> Could this be issued by the BufferingMode?
06:06:01 <hpaste>  sphynx pasted "ByteString.interact problem" at http://hpaste.org/1694
06:07:13 <dangb> ?src writeMutVar#
06:07:13 <lambdabot> Source not found. stty: unknown mode: doofus
06:07:39 <sphynx> Could anuone take a look?
06:09:56 <hpaste>  desegnis pasted "SHA1" at http://hpaste.org/1695
06:12:48 <desegnis> I implemented SHA1, and if I did benchmarking correctly (not quite sure), it is faster than Crypto's. But still purely functional
06:13:22 <desegnis> Does anyone bother to confirm that it really performs better?
06:13:37 <desegnis> See http://hpaste.org/1695
06:14:21 <hpaste>  fasta pasted "Needs a Failure class?" at http://hpaste.org/1696
06:14:54 <dons> desegnis: cool!
06:14:59 <dons> good work, i knew it was possible :)
06:15:17 <dons> a pure bytestring SHA1 should zip along, I think.
06:15:42 <desegnis> dons, did you check that it is better?
06:16:08 <fasta> Anyone willing to look at my paste?
06:16:14 <dons> no, bit ate here, desegnis 
06:16:19 <dons> /late/
06:16:32 <dons> drop it by haskell-cafe@ perhaps
06:17:23 <oerjan> @src MonadError
06:17:23 <lambdabot> class (Monad m) => MonadError e m | m -> e where
06:17:23 <lambdabot>     throwError :: e -> m a
06:17:23 <lambdabot>     catchError :: m a -> (e -> m a) -> m a
06:17:27 <sphynx> dons, could you please tell how I should use BS.interact? It seems its behavior differs from standard interact
06:17:48 <desegnis> dons, maybe. I didn't so far because somebody posted another implementation there some days ago which is even faster. though not really nice (mutable state etc)
06:17:49 <sphynx> even BS.ineract id works unexpectedly for me
06:18:09 <int-e> sphynx: it reads the whole input before processing anything
06:18:54 <sphynx> int-e: Ahh, so it's not processed line by line like interact from String?
06:19:07 <dons> oh, you're using the strict bytestring?
06:19:12 <int-e> I'd expect Data.ByteString.Lazy.interact to work better, but don't know how much better it is.
06:19:16 <dons> yeah, its goign to strictly read input, then process it :)
06:19:45 <sphynx> dons: Yeah I'm using Data.ByteString.Char8
06:19:46 <oerjan> fasta: what is the type of action?
06:20:15 <fasta> oerjan: it evaluates to some monadic value
06:20:42 <oerjan> fasta: taking B 1 as input, e.g.?
06:20:48 <int-e> Ah it even builds single character chunks. So it should work just as well as Prelude.interact does.
06:21:04 <fasta> oerjan: Int -> m a
06:21:26 <fasta> oerjan: the action might be printing it for example
06:21:35 <fasta> oerjan: that would be Int -> IO()
06:22:01 <fasta> oerjan: I think it's simply a matter of using mzero
06:22:12 <fasta> oerjan: do you agree?
06:22:23 <oerjan> fasta: actually you need a class for getting the Int's out
06:23:11 <fasta> oerjan: if the list contains only monad values (which it does), one can use bind or <-, right?
06:23:16 <sphynx> int-e: could you please take a look at http://hpaste.org/1694
06:23:40 <sphynx> int-e: it still doesn't work even after I changed to Data.ByteString.Lazy.Char8
06:23:55 <oerjan> fasta: neither K nor A are monads, they have the wrong kind
06:24:31 <fasta> oerjan: right, and indeed they aren't in my program.
06:24:45 <sphynx> int-e: 'BS.interact id' works with hSetBufferingMode stdin Buffering, but my (generateGet . getVar) doesn't
06:24:57 <sphynx> and I have no clue why 
06:25:06 <oerjan> perhaps you mean something like data K a = K | Z a | R a ?
06:25:24 <fasta> oerjan: no, I don't.
06:26:00 <fasta> oerjan: data K s = K | Z s Int | R Int <- it's like this
06:26:14 <fasta> oerjan: s is the state thread parameter
06:26:42 <oerjan> fasta: you don't need a Failure class, you need a class that picks out the elements that are Int's
06:26:58 <oerjan> *picks out the Int's
06:26:58 <int-e> sphynx: I think your processing is to blame. try BS.interact (BS.unlines . map (generateGet . getVar) . BS.lines) (which is not as lazy as it could be but at least produces the expected output)
06:27:19 <fasta> sphynx: Seeing that code makes me think you use the wrong tool for the job
06:27:47 <olsner> it's basically a sed script ;-)
06:28:24 <int-e> sphynx: interact always operates on the complete input, it is not line based at all.
06:29:06 <oerjan> once you have that, you just get f a l = mapM a (extractInts l)
06:29:08 <sphynx> olsner: Yeah, it's like sed )
06:30:12 <sphynx> int-e: Yeah, I was wrong in thinking that interact is line-based
06:30:16 <sphynx> thanks for help
06:32:31 <sphynx> I'm just trying to write in Haskell most of the tools I need just to improve my skills
06:32:40 <olsner> I'm thinking that using normal String with ++ would make the generate{Get,Set} functions nicer, and by the looks of it that program wouldn't be used on particularly large data sets anyway
06:33:22 <Botje> sphynx: one way of de-uglifying it would be to use a foldr BS.append
06:33:25 <int-e> sphynx: I'd probably use  BS.concat [a, b, c]  instead of  a `BS.append` b `BS.append` c
06:34:11 <sphynx> olsner: I've used ByteString cause there is a ready 'split' function :)
06:34:53 <fasta> oerjan: It aren't only Ints, but otherwise, yes. 
06:35:42 <olsner> ah, yes.. perhaps that function doesn't readily exist for lists
06:36:27 * Botje votes for a split :: String -> String -> [String] in the prelude
06:36:58 <fasta> Is it possible to build a function that selects one element from a list for which a condition holds, but it could return any such element? 
06:37:45 <Baughn> fasta: Define "any"
06:37:51 <fasta> e.g. f (< 5) [1..7] could return 1 or 2 or 3 or 4 
06:37:58 <int-e> fasta: with that specification, what's wrong with returning the first one?
06:38:01 <oerjan> fasta: any particular reason not just to return the first?
06:38:09 <hpaste>  sphynx annotated "ByteString.interact problem" with "A bit fixed and working var2property" at http://hpaste.org/1694#a1
06:38:11 <oerjan> (as head . filter p does)
06:38:14 <fasta> int-e: I guess I meant "all" then
06:38:25 <int-e> fasta: now you have a filter ;)
06:38:51 <int-e> fasta: randomness isn't pure; so you'll have to pass some randomness source into the function.
06:38:52 <Baughn> > filter (< 2) [1..4]
06:38:53 <lambdabot>  [1]
06:38:54 <sphynx> I've changed to BS.concat like int-e suggested and introduced data type for VarDef :)
06:39:04 <int-e> fasta: or cheat and ask for trouble with unsafePerformIO
06:39:14 <Baughn> fasta: Or have it return IO a
06:39:25 <fasta> int-e: well, it can return only one, but it should be able to return anyone of them. 
06:39:38 <fasta> int-e: I meant this as a semantics question
06:40:03 <Baughn> fasta: So you do want it to return a random match?
06:40:03 <fasta> int-e: since it might be the case that such a pick_one function could work faster when order is not specified.
06:40:12 <fasta> Baughn: not random
06:40:19 <int-e> fasta: it still isn't pure; if the function is evaluated twice (and the run time system is allowed to do that even if it's shared) then it'll have to return the result. so any randomness it includes must come from its inputs.
06:40:20 <fasta> Baughn: arbitrary
06:40:37 <Baughn> fasta: So just return the first match?
06:40:59 <int-e> (of course if the type is IO a you get the whole RealWorld as a source of randomness)
06:41:01 <fasta> Baughn: imagine computing the property for every element takes 100 seconds. 
06:41:15 <fasta> Baughn: I mean for some elements
06:41:17 <Baughn> fasta: Right, so just return the /first/ match, and stop computing there
06:41:20 <int-e> fasta: simple. shuffle the list, then look for the first matching element
06:41:31 <fasta> Baughn: and suppose for some elements it might take less time. 
06:41:43 <int-e> fasta: but you still need a source of randomness for shuffling
06:41:50 <oerjan> fasta: i suppose you want to do some kind of parallel or heuristically ordered filtering
06:41:54 <fasta> Baughn: if they all could be evaluated in parallel and the element that returns first is returned the computation runs faster
06:41:54 <Baughn> fasta: ..sort it according to time first, /then/ return the first matching element?
06:41:55 <olsner> fasta: so you want to e.g. spawn threads and take the result that arrives first?
06:42:08 <Baughn> fasta: Doing it in parallel doesn't seem like the best way
06:42:08 <fasta> olsner: right
06:42:22 <fasta> Baughn: it depends on what machine you have. 
06:42:35 <fasta> This is about semantics
06:42:39 <Baughn> fasta: And how many elements. Let's say you have a quad-core machine, and 100 elements..
06:42:53 <fasta> Baughn: then you could do 4 elements at a time for example.
06:43:06 <Baughn> fasta: If they by happenstance all take the same time to evaluate - 1 second - then doing it in parallel would finish after 25 seconds
06:43:14 <fasta> Baughn: I have no idea whether that's actually better, but that's besides the point. 
06:43:33 <Baughn> fasta: Whereas if you do 4 at a time, that would likely be far faster, since it would hit a match before finishing all of them
06:43:57 <Baughn> fasta: Which is a general rule, actually - you don't want more computation threads at a time than you have CPUs. Usually.
06:44:07 <fasta> Baughn: ?
06:44:44 <Baughn> fasta: You have 4 cores, so you can evaluate 4 elements a a time; trying to do /more/ at a time just makes evaluating each one slower
06:44:50 <int-e> right. one computation per CPU is the best; keeping the CPUs busy is good but you also want the individual computation results as soon as possible, so more parallelism will only hurt (because it'll slow down computations)
06:45:00 <fasta> Baughn: yes, that's what I said.
06:45:01 <dons> matthew-_: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/sessions-2007.7.15 
06:45:03 <lambdabot> http://tinyurl.com/2ty3tq
06:45:07 <dons> looks intriguing!
06:45:23 <oerjan> fasta: doing this efficiently would depend on knowing as much as possible about the cases - are there fast checks to find more promising ones first, and so on
06:45:23 <Baughn> fasta: So you'll want to read the -N parameter to the RTS, probably.
06:45:43 <dons> matthew-_: you writing a paper on this? or documentatoin of any kind..  ? :)
06:45:44 <fasta> Baughn: you miss the point
06:46:08 <olsner> AFAICS such a thing could only be pure if all filtered elements are guaranteed to be equivalent/equal
06:46:09 <fasta> Baughn: the point is that a function that simply does filter and selects the head has the order specified.
06:46:33 <fasta> Baughn: but I want to leave the order _unspecified_.
06:46:56 <Baughn> fasta: Strictly speaking, you can't do that; it must be deterministic
06:47:11 <Baughn> fasta: You can still do 4 at a time, though
06:47:38 <Baughn> fasta: And you can perfectly well decide the order on a case-by-case basis, by analyzing the input
06:48:10 <int-e> fasta: as I said before randomness is impure. can't be done, nada. you can work in IO, you can shuffle the list before filtering, you can give a RandomGen instance as a parameter, or you can try to use the list itself as a source of pseudo-randomness.
06:48:25 <fasta> int-e: this isn't about randomness
06:48:31 <olsner> the interface of the function can leave the order unspecified, but a pure function would always have to have some deterministic chooser
06:48:31 <int-e> fasta: yes it is
06:48:48 <int-e> fasta: nondeterminism then.
06:48:53 <fasta> int-e: ok
06:48:59 <Baughn> fasta: You can't use the exact timings of evaluation as a source of randomness either
06:49:32 <Baughn> fasta: If you evaluate 4 at a time, then check each of them for a match, you /must finish all 4/ before you can return one, even if the first to finish matches
06:49:53 <fasta> Baughn: no, you must not finish all 4
06:49:57 <Baughn> fasta: That is, of course, only true for pure code
06:50:09 <fasta> Baughn: how do you get that weird idea/
06:50:22 <Baughn> fasta: The function must be deterministic, and the order of completion might be down to chance
06:51:15 <fasta> What exactly would be the problem in using unsafePerformIO?
06:51:29 <Baughn> fasta: Well, because then it wouldn't be deterministic
06:51:32 <eivuokko> dons, (or anyone else) I am looking (haven't tested) the DList code, and somehow I can't see how using it would be as elegant as ShowS etc - what makes up for not having (.) for concat?  `append` doesn't strike me fun thing to write again and again.  Am I missing something?
06:51:45 <fasta> Baughn: I don't care about determinism.
06:51:45 <Baughn> fasta: You can only use unsafePerformIO in cases where apparently impure code in fact is pure after all. This isn't.
06:51:58 <int-e> If the evaluation happens to be sparked twice then you'll get inconsistent results.
06:51:58 <fasta> Baughn: ok
06:51:58 <Baughn> fasta: Do you care about your program not crashing or getting the wrong results?
06:52:09 <fasta> Baughn: it are not wrong results. 
06:52:24 <fasta> Baughn: the specification of the program is that it can return _multiple_ results.
06:52:37 <olsner> eivuokko: you could always replace the `append` series with foldr/foldl on append and a list
06:52:37 <Baughn> fasta: If you really want to do this, just avoid unsafePerformIO by keeping the entire computation in IO
06:53:11 <Baughn> fasta: Misusing unsafePerformIO is undefined behaviour. You don't want to go there.
06:53:41 <dons> eivuokko: hmm? its a synonym for ShowS
06:53:56 <eivuokko> dons, Not the darcs version?
06:54:12 <dons> oh, you just mean you can't use (.) directly to append 
06:54:19 <eivuokko> Yes.
06:54:26 <dons> right, its a "proper" api. the internals are hidden
06:54:40 <eivuokko> Yeah, I appreciate that.
06:55:09 <fasta> Baughn: but how would what I said work in the IO monad then?
06:55:12 <dons> i'd probably rebind `append` to some 1-char symbol if I was using it a lot
06:55:18 <eivuokko> Heh
06:55:40 <Baughn> fasta: When the first computation to match finishes, it can simply abort the others. That's nondeterministic behaviour, but that's fine in IO.
06:55:43 <dons> (#) = append wouldn't be too bad.
06:56:04 <fasta> Baughn: so, one would have a list of computations, all with callbacks to abort. 
06:56:25 <Baughn> fasta: Well, throwTo or thereabouts
06:56:42 <eivuokko> dons, Ok.  I was just wondering if there as some obvious mean to use nicely via class instances it has.  Or something.
06:56:56 <xerox> ?type (Data.Sequence.><)
06:56:57 <dons> eivuokko: only if Monoid defined ++
06:56:58 <lambdabot> forall a. Data.Sequence.Seq a -> Data.Sequence.Seq a -> Data.Sequence.Seq a
06:57:03 <fasta> Baughn: I currently use continuations to implement "break" semantics, should I better use exceptions?
06:57:19 <dons> eivuokko: possibly use concat [ x, y, z] ?
06:58:00 <Baughn> fasta: Exceptions are easier. Continuations, though...
06:58:00 <eivuokko> dons, Yeah.  oerjan suggested something along those lines as well.  I guess I am just too used to (.)
06:58:10 <Baughn> fasta: That sounds like you've got concurrency now, but not parallelism
06:58:52 <fasta> Baughn: I don't find continuations difficult
06:59:18 <fasta> Baughn: I use the ContT monad pretty often.
06:59:33 <Baughn> fasta: You might find them to be slow. If you're using continuations for multitasking, the implication is that you're only using one CPU.
06:59:52 <fasta> Baughn: I am not using them for multitasking
07:00:04 <fasta> Baughn: I can indeed imagine there are some primitives for that.
07:00:14 <fasta> Baughn: this is unrelated to the previous discussion
07:00:42 <Baughn> fasta: I am confused. You wanted to do multiple computations at once, right?
07:02:07 <fasta> Baughn: right, and that discussion was over, AFAIK, but you can more precisely say how the abortion would go. 
07:02:58 <Baughn> fasta: It depends on exactly how you implement the computation. If you use parallelism primitives, then exceptions are indeed the way to go, and you must stick the whole thing in IO. There might be a different way, however..
07:04:06 <Baughn> fasta: Remember, for pure code, the whole thing has to be deterministic. That's incompatible with using exceptions, but it is /not/ incompatible with continuations
07:04:21 <fasta> Still, I believe that the semantics of selecting one element from e.g. a list should be allowed to return whatever element. 
07:04:38 <Baughn> Nope, has to be the same element every time
07:04:53 <fasta> It's still "pure" in my opinion. 
07:05:13 <oerjan> fasta: but not referentially transparent :)
07:05:38 <fasta> oerjan: it is in a more general sense 
07:05:38 <eivuokko> dons, Oh, well.  I'll try to give DList a whirl somewhere to get a feel for extra-package/clarity ratio.  Thanks for suggestions, and packaging it up in the first place.
07:05:51 <fasta> oerjan: it still returns <an element with a property>
07:06:00 <fasta> oerjan: so, one can still reason about it.
07:06:15 <fasta> oerjan: so, for every sane value of ref. transp. it is.
07:06:21 <Baughn> fasta: GHC reasons based on that element always being the same one
07:06:41 <oerjan> fasta: referential transparency means that you can copy the defining expression for a name into each use of it
07:07:20 <Baughn> fasta: Though I haven't used continuations in Haskell, it should be possible to break the computations down into tiny pieces that execute concurrently. You could then get a deterministic return value that still doesn't fully compute all N elements, since it'll stop invoking the other computations when one finishes
07:07:28 <Baughn> fasta: Problem is, it'll likely have a giant overhead
07:07:42 <oerjan> if e is non deterministic, then e == e is no longer always True
07:07:44 <Philippa_> fasta: it certainly isn't purely a function
07:08:45 <fasta> oerjan: I would argue that once a selection has been made that one is fixed. (compare with quantum collapse)
07:09:20 <fasta> oerjan: implementing such semantics into a compiler would not be difficult and would still be referentially transparent. 
07:09:29 <fasta> (in this more general sense)
07:09:41 <Baughn> fasta: What happens if the compiler decides to execute it twice?
07:10:00 <Baughn> fasta: It doesn't automatically memoize every function, see - that would be insane
07:10:21 <Philippa_> I think fasta's proposing something akin to logic variables
07:10:28 <Baughn> fasta: THough, come to think of it, you could get around it yet again by memoizing it yourself
07:12:25 <fasta> Philippa_: I never liked logic programming, but maybe I should do it more. 
07:12:57 <ihope> Logic programming? Isn't that where you pretty much describe the problem and let the compiler/interpreter do all the work?
07:13:24 <olsner> that's the popular one-sentence summary yes ;-)
07:13:46 <Baughn> It's also amazingly wrong, but..
07:13:46 <Tykom> the prelude docs say there's an instance of Functor for pairs, e.g. instance Functor ((,) a), however i try performing fmap id ('a','b') and get errors saying there's no instance for Functor ((,) Char) - should i be importing some other module? i can find no info on where else to look
07:14:24 <olsner> isn't logic programming similar to the type system in haskell?
07:14:50 <fasta> Logic programming with cuts is functional programming
07:14:59 <ihope> Baughn: it is?
07:15:17 <fasta> So, Logic programming seems strictly more general. 
07:15:27 <ihope> fasta: logic programming with cuts?
07:15:36 <fasta> ihope: see Prolog
07:15:54 <Baughn> ihope: It suggests that a problem description is /enough/
07:16:10 <oerjan> Tykom: Control.Monad.Instances, i think
07:16:21 <fasta> I don't think one can write every program in an asymptotically optimal way in Prolog without cuts.
07:16:49 <dons> isn't logic programming just functional programming in a search / unification monad? :)
07:17:02 <ihope> Give me a language where there's an expression evaluating to the first odd perfect number.
07:17:17 <ihope> dons: search/unification monad?
07:17:29 <LoganCapaldo> @go LogicT
07:17:33 <lambdabot> http://www.capegateway.gov.za/eng/directories/public_entities/403/116452
07:17:34 <lambdabot> Title: LOGICT
07:17:34 <ihope> Depends on how smart the compiler/interpreter is!
07:17:35 <dons> like LogicT
07:17:36 <Philippa_> head (filter isOdd) perfects where ...
07:17:37 <oerjan> ihope: Haskell? assuming one exists.
07:17:52 <ihope> ...Well, where there's a *nice* expression doing that.
07:17:56 <LoganCapaldo> that doesn't seem like the right link
07:18:15 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/logict
07:18:25 <dons> ` continuation-based, backtracking, logic programming monad.'
07:18:37 <dons> all your paradigms belong to us!
07:19:18 <oerjan> head [n| n <- [3,5 ..], sum [m | m <- [1,..,n-1], n `mod` m == 0] == n]
07:19:19 <Tykom> oerjan:  that's the place, thanks
07:19:25 <ihope> Give me a language where there's a function that supposedly states whether or not two given lambda expressions are equivalent :-)
07:19:44 <Tykom> sadly there's no link between the prelude docs and that bit of info that i see :(
07:19:49 <ihope> Two given expressions, rather, I guess.
07:19:58 <fasta> ihope: that's not difficult
07:20:06 <dons> ihope, equivalent up to what?
07:20:07 <fasta> ihope: it only is not efficinet
07:20:13 <fasta> ihope: efficient*
07:20:16 <EvilTerran> > let perfect x = sum (facts x) == x; facts x = filter ((0==).(x`mod`)) [1..x-1] in head $ filter perfect [1,3..]
07:20:20 <lambdabot> Terminated
07:20:35 <ihope> dons: extensionally equivalent or some such.
07:20:57 <dons> not alpha equivalent then :) i had a one liner ready 
07:21:24 <ihope> Would that say \x -> const x 3 is not the same as \x -> x?
07:21:49 <dons> yeah, structural == up to renaming.
07:21:51 <EvilTerran> there could be a certain amount of reduction to canonical forms, i guess
07:21:59 <ihope> If you can't tell the difference by applying free variables all over the place, it's equivalent.
07:22:42 * ihope writes something formal in a made-up language that resembles Haskell
07:22:45 <EvilTerran> but there are necessarily limits. you can reduce the halting problem to the equivalence problem, iirc.
07:22:51 <ihope> Yes, you can.
07:23:35 <oerjan> (remove 2 commas)
07:23:45 <|Steve|> ihope: Your nick makes me hungry.
07:23:51 * ihope feeds |Steve| pancakes
07:23:52 <ari> Haskell's been rewriting my brain again
07:23:56 <|Steve|> Indeed.
07:24:07 <ihope> |Steve|: want eggs with that?
07:24:13 <ari> I'm reading C functions returning foo* as Maybe foo
07:24:14 <EvilTerran> pankeggs?
07:24:15 <|Steve|> Yes please.
07:24:22 * ihope feeds |Steve| eggs
07:24:37 <|Steve|> Heh. Awesome. Now, I want a real ihop.
07:24:37 <andun> ?pl \x xs -> f x : xs
07:24:38 <lambdabot> (:) . f
07:24:57 <ihope> IHOPE: International House of Pancakes and Eggs.
07:25:01 <dons> ari, that's cool :)
07:25:04 <LoganCapaldo> ari: I know what you mean
07:25:34 <|Steve|> Why Maybe foo?
07:25:58 <fasta> |Steve|: null pointers
07:26:13 <|Steve|> But what about (foo *)4?
07:26:32 <|Steve|> It's not null, but it's not valid (for most architectures).
07:26:39 <|Steve|> Well, most OS, I suppose.
07:27:19 <ari> |Steve|: Which is why I Don't Do It, Then :p
07:27:34 <|Steve|> I see.
07:27:55 <|Steve|> I still have a hard time thinking in Haskell a lot of the time.
07:28:26 <ihope> Actually, this is starting to look like Epigram.
07:28:28 <|Steve|> When it comes to math, it's easy. When it comes to data structures, I'm not convinced that functional languages are a good choice, at least not pure functional ones.
07:28:38 <olsner> ari: or [foo] (which for the Just foo | Nothing case is the same :P)
07:28:57 <LoganCapaldo> My thinking in haskell problems often amount to I get this strong desire for objects (in the OO sense), even pure functional immutable ones.
07:30:16 <LoganCapaldo> I find myself wanting something between Monads (really big abstraction) and ADTs (really small abstraction)
07:30:24 <|Steve|> LoganCapaldo: Tried ocaml?
07:30:58 <dons> LoganCapaldo: existentials perhaps?
07:31:15 <LoganCapaldo> dons: Yeah those are close,  but a lot of work to get them set up
07:31:20 <dons> no!
07:31:32 <dons> data E = forall t . C t => E t
07:31:39 <ihope> App (App t u) v reduces to App (Reduce (App t u)) (Reduce v), App (Var l) t reduces to App (Var l) (Reduce t), App (Lam l t) u reduces to something a little bit complicated.
07:31:42 <dons> there's your object, C is its interface
07:31:59 <wli> ihope: What's this?
07:32:07 <|Steve|> Ugh. I was trying to explain ADTs to my students but one of them just didn't get it at all. I swear, I wasn't that dumb when I was in college. =
07:32:08 <Philippa_> dons: the boxing's a pain in the arse though
07:32:09 <|Steve|> =\
07:32:10 <ihope> wli: lambda calculus.
07:32:12 <dons> GADTs also fit in here
07:32:29 <ihope> Didn't... get ADTs?
07:32:43 * ihope ponders
07:32:45 <wli> Ooh, Fourier-Motzkin elimination looks like what I really want.
07:32:46 <LoganCapaldo> dons: You have all the pieces for sure, but you have to put them together yourself, which has its ups and its downs
07:32:51 <|Steve|> He didn't get anything. This was in "Advanced Datastructures." He didn't know what a map was.
07:33:05 <Philippa_> ah. You got a blagger, then
07:33:33 <ihope> So annoying that an intuitive grasp is required to work with stuff.
07:34:11 <|Steve|> lordrat?
07:35:14 <profmakx> O.o
07:35:20 <profmakx> is there +C on freenet?
07:35:39 <profmakx> freenode -.-
07:35:40 <|Steve|> what does it do?
07:36:06 <profmakx> it prohibits CTCP to the channel
07:36:16 <profmakx> but i don`t know if its there on freenode
07:36:19 <|Steve|> Ah.
07:36:30 <|Steve|> --- C :is unknown mode char to me
07:36:36 <|Steve|> I'm going to guess no.
07:36:51 <ihope> Well, there's a user mode +C that does that, but no channel mode.
07:36:54 <profmakx> pity
07:37:01 <ihope> ...well, lemme look again.
07:37:09 <Philippa_> FWIW, I generally read mass-versioning a chan as a prelude to attempting to exploit people's clients
07:37:22 <ari> lordrat: Find out anything interesting?
07:37:40 <Philippa_> there aren't many other good reasons to do it, and they're all ones you can announce first
07:37:59 <profmakx> well he got "bite my shiny metal ass" from my client -.-
07:37:59 <|Steve|> I wouldn't want 309 people's version info.
07:38:06 <|Steve|> Heh.
07:38:09 <lordrat> opps... It was wisible at the channel?
07:38:22 <|Steve|> Every client reported it.
07:38:23 <EvilTerran> mine says "xchat 2.6.4-1 Unicos/Ic [AMD Opteron 96*2.6GHz]" at the moment
07:38:29 <|Steve|> --- Received a CTCP VERSION from lordrat (to #haskell)
07:38:29 <ihope> lordrat: did you CTCP VERSION this channel?
07:38:46 <Philippa_> lordrat: funny, that. Yes, people's IRC clients tell them about CTCP requests. How much of a newbie are you?
07:38:50 <ihope> Well, if you send a message to a channel, people in the channel tend to receive it.
07:39:02 <ihope> And a CTCP request is a message.
07:39:18 <|Steve|> I've never actually seen someone send a ctcp to a channel.
07:39:25 <int-e> depending on the client people see that or not
07:39:28 <|Steve|> Hell, I didn't know you could.
07:39:30 <lordrat> I thought it is server command sorry for all
07:39:44 <EvilTerran> (unfortunately, mine isn't actually honest =[, but ah, I can dream...)
07:40:17 <|Steve|> I have no idea what mine says, but I'm not particularly worried about it. "Oh noes! People know what version of xchat I'm running!"
07:40:31 <Philippa_> |Steve|: an awful lot of IRC clients have been exploitable in the past
07:40:35 <EvilTerran> I know someone on another network who has somewhere in the region of 50 responses to CTCP VERSION set up, so if someone versions them, they get buried in meaningless responses.
07:40:40 <ihope> Well, there is a reason CTCP is called client-to-client protocol.
07:40:51 <|Steve|> Heh.
07:40:51 <ihope> Ooh, fun.
07:41:04 <EvilTerran> such things as ataris, games consoles, specific models of toaster, etc
07:41:15 <LoganCapaldo> Mmmm toast
07:41:22 <Philippa_> so if someone knows what version you're running they may be able to run code on your box as the user your client runs at
07:41:49 <|Steve|> There was a story I heard about a guy stalking some other guy in the cs dept at my school so he put multiple hundreds of gigs of garbage into his .plan file so when he got fingered, it spammed the guy.
07:42:04 <EvilTerran> hehe
07:42:12 <|Steve|> Philippa_: Thankfully, I don't run xchat as root.
07:42:14 <olsner> ln -s /dev/random .plan
07:42:29 <|Steve|> I saw someone running an irc client from his office at the JPL as root...
07:42:41 <Philippa_> yeah. Bad enough to get your own userspace trashed though
07:42:46 <|Steve|> True.
07:43:14 <Philippa_> and there're high odds on windows users running as a superuser on their own box
07:43:23 * EvilTerran wonders if he could set up xchat to nmap anyone who VERSIONed. i'd not do anything with it, but if it made their firewall go "zomgportscan", that's good enough for me.
07:43:30 <lordrat>  sorry, but /version sounds like it cat tell me version of IRC server.. no version of clients of connected people... sorry once again
07:44:14 <int-e> /quote version  should work
07:44:22 <|Steve|> I'm not sure I can bring myself to finish this drink.
07:44:26 <EvilTerran> lordrat, you're told the server info before the MOTD as you connect.
07:44:48 <EvilTerran> * Welcome to the freenode IRC Network EvilTerran
07:44:48 <EvilTerran> * Your host is brown.freenode.net[brown.freenode.net/6667], running version hyperion-1.0.2b
07:45:34 <lordrat> replicate 100 "I will read info before trying any commands ever"
07:45:35 <geezusfreeek> one night when i lived on campus at my university my network activity was going slower than usual, and eventually i discovered that some other computer was repeatedly trying to send some sort of random crap to a particular port on my machine. i forget what the port was for now, but it was something stupid. anyway, i fixed the problem by assuming the "attacker" had something running on that port and using a couple of piped netc
07:46:00 <EvilTerran> "piped net"...?
07:46:02 <|Steve|> piped net?
07:46:05 <|Steve|> net cat?
07:46:10 <geezusfreeek> *piped netcats to forward everything right back at his machine
07:46:10 <ihope> Truncated?
07:46:15 * |Steve| is good.
07:46:17 <geezusfreeek> yeah, truncate, sorry
07:46:58 <geezusfreeek> being on a university network is always fun
07:47:06 <|Steve|> Yes, yes it its.
07:47:11 <|Steve|> I used to get 4.8 MB/s from Apple.
07:47:42 <ihope> That's rather a lot.
07:48:00 <EvilTerran> the bandwidth from mirror.ac.uk is fantastic from within JaNET, unsurprisingly
07:48:00 <geezusfreeek> they eventually lowered the cap so low at my dorms that it would take 10-15 seconds to load google
07:48:07 <geezusfreeek> i moved to an apartment the next semester
07:48:22 <|Steve|> ihope: I loved it.
07:48:23 <ihope> That's rather not a lot.
07:48:30 <|Steve|> The real world sucks.
07:48:36 <LoganCapaldo> "Caps drive student out of dorms! News at eleven!"
07:48:42 <geezusfreeek> ha
07:48:49 <|Steve|> I saw real world, yet I'm still in school. Gah.
07:48:54 <|Steve|> Say*
07:49:02 <LoganCapaldo> Sorry I've only had 1/8th of a cup of coffee so far
07:49:25 <|Steve|> 1/8" of horrible booze left.
07:50:22 * LoganCapaldo hopes me and |Steve| are in different time zones
07:50:41 <|Steve|> Yeah, I'm 3 hours behind.
07:51:44 <|Steve|> Ugh. That was horrible. I'm going to bed.
07:54:18 <fasta> Is there an align block function in Emacs?
07:55:14 <psi> align region?
07:55:40 <psi> i sometimes use align-regexp
07:56:16 <fasta> hmm, it appears there is indent-region
07:56:24 <fasta> But it is completely broken.
07:57:45 <psi> ok, align doesn't indent. it can be used to line up =, for example.
07:59:16 <psi> indent-region probably doesn't work because of haskell-mode's uncommon indentation strategy
08:00:00 <LoganCapaldo> Does haskell-mode actually auto-indent? That's pretty impressive.
08:00:03 <xerox> the haskell-mode page on the wiki seems to be saying that you can indent region "sensibly@
08:00:16 <int-e> LoganCapaldo: it gives several options per line.
08:00:43 <fasta> LoganCapaldo: I have seen upto 10 possibilities
08:00:44 <LoganCapaldo> int-e:and you cycle thru them?
08:00:49 <fasta> LoganCapaldo: with TAB
08:01:08 <LoganCapaldo> not bad
08:01:10 <int-e> LoganCapaldo: yes. afaik indent-region always picks the first, so that will not give any usable results.
08:02:11 <LoganCapaldo> I needs to force myself to pick up emacs. Maybe I'll do all my haskell diddling in it from now on
08:03:25 <psi> how long has the darcs webpage been down?
08:03:39 <fasta> I would like to have something like TeXMacs
08:03:54 <fasta> but then something that actually works perfectly. :)
08:04:10 <LoganCapaldo> That would be cool
08:04:10 <fasta> (as said before: I want a pony :) )
08:04:35 <fasta> I wonder how difficult it would be to make something like that.
08:04:42 <psi> texmacs has always been überslow when i've tried it.
08:05:07 <fasta> Crushing the "competition" wouldn't be that hard, since there are no systems that do this currently (that I know of)
08:05:42 <mm_freak> dons: pretty interesting, thanks…  but considering the rapid information flow in here, you'd better query me next time, saving me a lot of scrolling work =)
08:06:18 <fasta> I wanted to use the "plot" function of TeXMacs, but I never got it to plot anything.
08:06:52 <LoganCapaldo> fasta, that function actually causes TeXMacs to plot the overthrow of the world.
08:06:58 <LoganCapaldo> ;)
08:07:14 <fasta> Some software takes longer to understand then to write I guess. 
08:07:19 <mm_freak> dons: btw…  i figured out myself that the first sieve presented in there is not the sieve of eratosthenes…  a short look at the list comprehension already shows that fact (the `mod')
08:07:34 <fasta> er than*
08:10:44 <fasta> I am really starting to hate Haskell mode, though.
08:11:06 <fasta> Jumping to an error often jumps to the wrong location.
08:11:30 <dons> mm_freak: also, you might be interested in a little prime 'N' sieve I worked on today,  (scroll down to bitwise prime sieve, http://haskell.org/haskellwiki/Prime_numbers)
08:11:31 <lambdabot> Title: Prime numbers - HaskellWiki
08:11:51 <dons> besides being fast, it shows how to run the prime sieve at compile time 
08:12:19 <psykotic> fasta: really? and you haven't changed the buffer in the mean time?
08:12:29 <fasta> psykotic: no
08:12:46 <fasta> psykotic: It seems to happen only during long edit sessions
08:13:12 <mm_freak> dons: now that's very interesting…  i'll look it up
08:13:41 <mm_freak> dons: i was considering an implementation of the sieve of atkin, and compare the performance to some well known implementation in C
08:14:18 <dons> these bitwise sieves run very nicely in ghc, for some reason.
08:15:02 <wli> bitwise sieve?
08:15:30 <dons> just counting primes under a given N, via a bit array
08:16:29 <wli> Is there something of a contest for the fastest algorithm?
08:17:41 <waern> cdsmith: ping
08:18:06 <cdsmith> waern: pong
08:18:25 <msouth> Hi, I'm working through the newbie exercises in the wikibook beginner track and have written "myCons thing list = thing:list".  I can see that it has the same type as (:) with :t (:).  I'm wondering if there is a way to know if myCons is exactly the same as cons.  Can you ask the interpreter to tell you that somehow? 
08:18:32 <waern> cdsmith: just wanted to tell you that if you pull the latest GHC changes, haddock.ghc will work
08:18:46 <cdsmith> Cool.  I noticed you'd committed a change.  Thanks!
08:18:50 <fasta> msouth: no
08:18:58 <cdsmith> Maybe I'll be able to build haddock for HAppS again. :)
08:19:17 <waern> cdsmith: Tell me if you encounter any problems
08:19:32 <EvilTerran> msouth, no, the interpreter can't tell you anything about the internal workings of a function after it's been defined.
08:19:38 <cdsmith> waern: Will do.  It may be a few days before I can try it, though.  I'm away from my Linux system.
08:20:13 * wli looks for less newbie exercises.
08:20:34 <waern> cdsmith: ah okay, well I'm just happy somebody uses it :)
08:21:41 <cdsmith> waern: I'm surprised more people don't use it, actually.  A number of libraries don't seem to work with the main haddock.
08:22:04 <fasta> cdsmith: it's called package or die, I think
08:22:23 <cdsmith> fasta: ???
08:22:34 <fasta> cdsmith: haddock is packaged.
08:22:39 <fasta> cdsmith: haddock.ghc is not
08:22:44 <cdsmith> Ah, I see.
08:22:46 <msouth> thanks.  but that seems a little strange--the whole language seems to be so...mathematical?  It seems like it would be able to look at two functions and know if they are always going to do the same thing.  Maybe that's a colossally stupid idea :).
08:22:59 <waern> fast: yes, that's the main reason
08:23:01 <fasta> msouth: there is no math in Haskell, next question
08:23:11 <cdsmith> msouth: That's a theoretically very hard question.  Impossible to answer, in general.
08:23:13 <fasta> msouth: just some names that are used from math. 
08:23:13 <mauke> msouth: actually, that's very hard to do in general
08:23:35 <cdsmith> mauke: At least we agree with each other! :)
08:24:22 <Heffalump> it's undecidable, not just "very hard" :-)
08:24:28 <geezusfreeek> if that was possible, we would have compilers that can rewrite our algorithms
08:24:29 <fasta> Wasn't the halting problem decidable for data on a finite machine? 
08:24:50 <cdsmith> fasta: Oh yeah, of course.  But not practically.
08:24:52 <Heffalump> fasta: well, if you have a bigger machine to simulate it on, yes
08:25:32 <Heffalump> f n = if n == 1 then 1 else if n `mod` 2 == 0 then f (n `div` 2) else f (3 * n + 1)
08:25:36 <Heffalump> does f == const 1 ?
08:25:38 <fasta> So, if we all join together resources, we can make one big machine and add it to Haskell' ;)
08:25:57 <fasta> Oh, right, and you need to have patience too :)
08:26:00 <fasta> A lot of it.
08:26:34 <mauke> Heffalump: yes
08:26:38 <int-e> Heffalump: you don't need a much bigger machine. (twice as much memory is enough.)
08:26:41 <wli> You could do it on a slower machine provided you've got external storage and enough patience to keep it going potentially longer than you'll live.
08:26:42 <mm_freak> dons: i've never messed around with unsafe things too much…  which sieve is it?
08:28:19 <wli> These numerical types are interesting.
08:28:42 <wli> That is, the type-level numbers.
08:28:47 <msouth> ok, thanks--I don't have any computer science training, so a lot of those terms are vague notions to me.  But I think I get the point.
08:28:56 <olsner> how to you use Data.Binary getters to do something like parse a bytestring into a list of Word64's? or parse a structure consisting of fields of various types?
08:29:14 <olsner> *how do you
08:29:44 <wli> e.g. Oleg's BinaryNumber.hs
08:30:23 <olsner> oh, Get's a monad instance
08:30:28 <wli> I'm wondering if there shouldn't be syntactic sugar.
08:30:36 <wli> olsner: Where are you seeing this Get?
08:30:45 <olsner> http://www.cse.unsw.edu.au/~dons/binary/Data-Binary.html
08:32:27 <wli> I wanted it for index variables of some sort, but Fourier-Motzkin elimination appears relevant to typechecking/type inference with those sorts of types, too.
08:34:12 <wli> Mostly you'll get inequalities of the form n_1 <= n_2
08:41:58 <ihope> What, again, is a good way to nicely handle a terminal window with Haskell?
08:42:14 <ihope> Doing what ANSI term codes do?
08:42:20 <dons> curses?
08:42:28 <dons> ?where hscurses
08:42:28 <lambdabot> http://www.informatik.uni-freiburg.de/~wehr/haskell/
08:42:34 <dons> ?where hmp3
08:42:34 <lambdabot> http://www.cse.unsw.edu.au/~dons/hmp3.html
08:42:43 <ihope> Does that go well with Windows?
08:42:53 <dons> don't think so
08:43:10 <dons> not sure.
08:43:38 <DRMacIver> I'm always surprised at how badly Haskell often plays with windows (although I've never tried it myself, so maybe the problems are overstated)
08:45:16 <ihope> Well, I'm under Windows right now...
08:47:54 <dons> termio seems rather platform dependent...
08:48:39 <desegnis> DRMacIver, the fact that ncurses does not go well with Windows isn't actually related to Haskell. same problem with other languages
08:49:12 <dons> people don't write a lot of console apps for windows :)
08:49:46 <ihope> PuTTY cheats. :-)
08:50:10 <Heffalump> it's not really very pleasant
08:50:22 <ihope> I guess they found Windows' console too hard to use or something, so they used a different one.
08:50:33 <ihope> Why is Windows that way?
08:50:46 <slowriot> Is there a way to derive a data type after it has been declared?
08:50:51 <Heffalump> it's just completely different to UNIX in APIs and look and feel
08:50:54 <benny99> could somebody kick my ass, I'm demotivated for some reason :(
08:50:55 <Heffalump> and much more GUI focused
08:50:56 <mauke> slowriot: no
08:51:18 <dons> benny99: pleaes write a library TODAY!
08:51:22 * ihope kicks benny99's so-called bottom
08:51:22 <dons> come on SLACKER!
08:51:29 <dons> how's that?
08:51:33 <benny99> thx, that really helped :)
08:51:38 <dons> good!
08:51:41 <mauke> I've written a library; now what?
08:51:49 <dons> mauke++ karma!
08:51:50 <benny99> gnaah... I'm reading and reading, but I want to actually program something in Haskell :(
08:51:57 <dons> u has a karma. now do something 
08:52:11 <dons> benny99: what kind of projects interest you?
08:52:24 <dons> you could fix the 64 bit FFI bug in Frag
08:52:42 <dons> write a better version of the sum-file naive benchmark for the language shootout
08:52:53 <dons> package up the comonad tarball library, and cabalise it
08:53:13 * dons looks at other things on his todo list of reasonable ease   
08:53:13 <benny99> I'd like to write a little parser for effects -- or for simulation
08:53:13 <benny99> like a file
08:53:13 <benny99> [Cube]
08:53:13 <benny99> size=20
08:53:13 <benny99> weight=100kg
08:53:14 <benny99> pos=(10.0,10.0,10.0)
08:53:16 <benny99> and the program creates it
08:53:28 <dons> ok, parsec + opengl :)
08:53:33 <wli> dons: Any suggestions for exercises for programmers at/around my level?
08:53:49 <dons> project euler?
08:53:52 <benny99> wli: there are 100 on the haskell.org page :)
08:53:57 <benny99> dons: project euler?
08:54:00 <dons> wli, you should just write libraries as exercises
08:54:02 <wli> benny99: Which page?
08:54:08 <dons> oh, that's a mathy contest haskell does pretty well at
08:54:10 <benny99> wli: wait a sec
08:54:14 <benny99> wli: dunno your level
08:54:15 <wli> dons: Any particular suggestions for libs?
08:54:16 <dons>  you get to learn the language, and solve math problems
08:54:24 <dons> wli, the comonad lib would be one easy one to do
08:54:33 <dons> its mostly written, needs polishing and uploading
08:54:39 <dons> want the url?
08:54:45 <dons> and .. you get to play with comonads!
08:54:50 <dons> all the kids LOVE comonads
08:54:57 <benny99> dons: what is parsec? what are comonads :'(
08:55:00 <fasta> wli: Hmm, are you asking for doing free work? 
08:55:05 <benny99> dons: I guess I should read YAHT first huh?
08:55:11 <dons> parsec is a parser library for haskell, benny99 
08:55:15 <benny99> dons: without having read that I'm nothing I guess :(
08:55:21 <dons> comonads are a cool inside-out monad abstraction  
08:55:35 <dons> yeah, YAHT would be a good place to start on your quest for nirvana
08:55:37 <Heffalump> but what do they *do*?
08:55:41 <benny99> dons: :D
08:55:50 <benny99> dons: I'm level 9 already ... chapter 9
08:56:02 <dons> Heffalump: I think sigfpe worked out some things that could be done in them
08:56:03 <fasta> wli: if you want to build something usefull: build a Test monad + TestT
08:56:06 <dons> DFAs? 
08:56:11 <benny99> dons: I seriously should stop playing old rpgs when I'm frustrated
08:56:51 <benny99> how can I tell the lambdabot to search for something?
08:56:56 <benny99> @99 Exercises
08:56:56 <lambdabot> Maybe you meant: . bf ft id pl rc v wn
08:57:02 <dons> wli, http://www.cs.helsinki.fi/u/ekarttun/comonad/   and  http://www.eyrie.org/~zednenem/2004/hsce/
08:57:03 <lambdabot> Title: Comonads and Haskell
08:57:12 <dons> bundle it. add cabal, play with it till it works, upload to hackage
08:57:17 <EvilTerran> benny99, depends what you're after
08:57:20 <EvilTerran> @where tutorial
08:57:21 <lambdabot> http://www.haskell.org/tutorial/
08:57:26 <dons> you'll be sigfpe's comonad hero
08:57:30 <benny99> EvilTerran: those 99 exercises for wli
08:57:30 <EvilTerran> @hoogle (a -> b) -> [b]
08:57:31 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
08:57:31 <lambdabot> Control.Parallel.Strategies.parMap :: Strategy b -> (a -> b) -> [a] -> [b]
08:57:31 <lambdabot> List.unfoldr :: (a -> Maybe (b, a)) -> a -> [b]
08:57:44 <EvilTerran> @where 99
08:57:44 <lambdabot> I know nothing about 99.
08:57:50 <benny99> 100 maybe?
08:57:53 <dons> wli, oh, write some documentation for Control.Parallel.Strategies
08:57:57 <benny99> @where 100
08:57:57 <lambdabot> I know nothing about 100.
08:57:59 <benny99> :'(
08:58:08 <benny99> @where lambdabot
08:58:09 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
08:58:11 <dons> ?google 99 exercises haskell
08:58:13 <lambdabot> http://haskell.org/haskellwiki/99_Haskell_exercises
08:58:13 <lambdabot> Title: H-99: Ninety-Nine Haskell Problems - HaskellWiki
08:58:18 <dons> ^^ solve those :)
08:58:19 <benny99> wli: there :)
08:58:26 <dons> report back when you're done.
08:58:27 <benny99> dons: did you write the lambdabot?
08:58:36 <dons> some of it.
08:59:04 <benny99> dons: :) I like that bot
08:59:31 <dons> its a good bot :)
08:59:40 <dons> I wrote 984 patches for it
08:59:42 <benny99> dons: I also like the dbot :)
08:59:44 <benny99> dons: what :D
08:59:56 <DRMacIver> Heffalump: From what little I understand of it, the answer is really "Stuff Haskell already does because it doesn't distinguish between data and codata" :)
09:00:12 <olsner> what's codata?
09:00:32 <benny99> dons: hm, I also like mathematics, but I'm a 17-year-old noob :( you don't know any problems I could solve using haskell?
09:01:00 <mauke> benny99: write an interpreter
09:01:13 <DRMacIver> <Vague I don't really understand it answer>Roughly, data is finite, codata is infinite. So finite lists are data and streams are codata. Haskell's lazy lists can be both data and codata.</etc>
09:01:17 <benny99> mauke: for algebra?
09:01:19 <wli> dons/benny99: The 99 problems sound good.
09:01:31 <benny99> maybe I should solve some of them
09:01:53 <mauke> benny99: your choice. you could make it run "2+2", or you could implement a complete programming language
09:02:06 <benny99> and read that yaht tutorial, but it's dry after you read ~130 pages :(
09:02:17 <benny99> mauke: I'll start with something easy then :)
09:02:37 <dons> there you go, commits to lambdabot broken down by contributor, http://www.cse.unsw.edu.au/~dons/tmp/x.png
09:02:42 <benny99> but I suppose I'll need the knowledge about monads anyway huh?
09:02:49 <mauke> not necessarily
09:02:57 <benny99> dons: you won :)
09:03:18 <mauke> lambdabot contributed code to itself?
09:03:26 <dons> apparently..
09:03:35 <mauke> scary
09:03:36 <dons> like my darcs2pie script?
09:03:47 <fasta> dons: is that number of commits?
09:03:54 <dons> yeah
09:04:08 <dons> 46 comitters since 2004
09:04:24 <wli> dons/benny99: Problems 90-99 look most relevant to me.
09:05:15 <geezusfreeek> who is the one with fifth most commits? either something got out of alignment on the chart or there is a name missing
09:05:25 <dons> someone without an email address
09:05:27 <dons> let me see..
09:05:50 <geezusfreeek> i'm thinking it may just be a bad rendering is all, out of alignment
09:06:10 <dons> no, the script justrips out emails, and counts them, but someone doesn't have their address in the patch
09:06:19 <geezusfreeek> ah
09:08:05 <ihope> Is there a nice way to get at the Windows API in GHC?
09:09:15 <ihope> System.Win32?
09:09:18 <DRMacIver> desegnis: Yeah, I know. It was more a case of that reminding me how often I'd heard about things not working well under windows than thinking that was a Haskell specific problem.
09:14:22 <desegnis> right, DRMacIver
09:17:34 <DRMacIver> Hm. I have an evening free which I didn't expect to. I should probably attempt to write some code.
09:18:08 <DRMacIver> Oh, FFI question. There are various tools for generating a Haskell interface from a .h file, right? Which are the favoured ones?
09:18:21 <Alleria> I've a conceptual question on bind and >> for sequencing:
09:19:00 <Alleria> I understand how bind basically chains / nests a series of "actions"... and that they happen in sequence because the "final" action needs input from the previous one, and so on...
09:19:25 <Alleria> but with >> having type ma -> mb -> mb and "throwing away" the input...
09:19:39 <quicksilver> it doesn't throw away its input
09:19:54 <quicksilver> it throws away the *result* of the first action
09:20:00 <Alleria> right
09:20:03 <quicksilver> but it still carries out the "monadic computation"
09:20:11 <quicksilver> (exactly what that means depends on the monad)
09:20:15 <Alleria> and typically with >>= you take the result of the first action, and feed into the second
09:20:22 <Alleria> so the second can't execute until the first is done.
09:20:26 <quicksilver> but speaking loosely you'd say that the "side-effects" are still performed
09:20:46 <Alleria> but with >> if the second action doesn't actually 'depend' on anything from the first, how is sequencing maintained?
09:20:53 <quicksilver> it isn't
09:21:00 <quicksilver> (or, not necessarily)
09:21:12 <Alleria> so action1 >> action2 >> action3 isn't guaranteed to happen "in sequence"
09:21:31 <Alleria> although action4 >>= action 5 >>= action6 will sequence?
09:21:33 <quicksilver> people overemphasise the extent to which monads sequence operations
09:21:46 <quicksilver> and, they confuse the issues a bit
09:22:02 <quicksilver> monads sequence the side-effects, by definition
09:22:17 <quicksilver> but, in isolation that's actually something different from haskell expression evaluation
09:22:20 <benny99> Alleria: they must be commutative
09:22:29 <quicksilver> the IO monad sequences side-effects strictly
09:22:35 <quicksilver> not all monads are so exact
09:22:45 <quicksilver> it's possible to write a completely lazy state monad
09:22:57 <quicksilver> in a completely lazy state monad, the only possible side-effect is modifying the state
09:23:01 <quicksilver> and if you never examine the final state
09:23:09 <quicksilver> the modifications will actually never happen
09:23:22 <quicksilver> haskell is still demand-driven non-strict at the end of the day
09:23:35 <Alleria> I ... see
09:24:23 <Alleria> even with the IO monad, I often didn't quite understand ...
09:24:34 <quicksilver> I'm sorry
09:24:40 <Alleria> for example, if putStrLn returns IO ()...
09:24:41 <quicksilver> I'm afraid I haven't made things clearer
09:24:48 <quicksilver> I find this one a bit hard to explain
09:25:03 <Alleria> it seems as though it doesn't even need to perform the side effect of printing my string in order to give back the IO ()?
09:25:13 <quicksilver> no, that's absolutely right
09:25:22 <quicksilver> that's an important observation to hold tight
09:25:29 <EvilTerran> if the side-effects are actually run, they will happen in the right order. but they won't necessarily be run.
09:25:35 <Alleria> because no matter what string I print, it gives back IO ()
09:25:35 <quicksilver> it doesn't ahve to do *anything* at all, to return the IO () to you
09:25:46 <Alleria> So it's like f(1/0) == 2
09:25:47 <quicksilver> but, that IO () is a complicated object
09:25:53 <geezusfreeek> the IO monad is special though
09:25:56 <Alleria> always evals to 2, without ever giving a divide-by-zero?
09:25:59 <quicksilver> geezusfreeek: no, it's not. 
09:26:06 <quicksilver> geezusfreeek: (not in this respect)
09:26:17 <quicksilver> Alleria: that IO () package you have is a set of instructions
09:26:23 <quicksilver> Alleria: but they aren't executed, yet
09:26:27 <quicksilver> Alleria: they're just passed around
09:26:30 <quicksilver> (no side-effects yet)
09:26:42 <quicksilver> it's only when you make that IO () part of your 'main' aciton
09:26:46 <quicksilver> directly or indirectly
09:26:54 <quicksilver> it's *that* that forces the side-effects to occur
09:27:14 <quicksilver> outside of the unsafe functions, there's nothing 'inside' haskell you can do to make IO 'happen'
09:27:24 <geezusfreeek> ah, yes, better explanation that the direction i was going to go in
09:27:27 <quicksilver> IO 'happens' when it gets linked into your main action, directly, or indirectly
09:27:31 <Alleria> quicksilver: okay, so say, main gets evaled...
09:27:40 <quicksilver> so, the run-time-system actually "does" the IO
09:27:44 <quicksilver> required to run the main action
09:27:46 <Alleria> and main is just the line putStrLn "hello world"
09:28:06 * quicksilver nods
09:28:22 <quicksilver> then the run time system (the RTS) has this little "package" of instructions, of type IO ()
09:28:24 <Alleria> so in that case, putStrLn could still feel free to return IO () without ever printing a thing.
09:28:48 <quicksilver> IO () is more complicated than you imply
09:28:57 <quicksilver> that 'IO ()' which putStrLn actually returns
09:29:04 <quicksilver> looks something like this:
09:29:21 <quicksilver> IO [ MAGIC_RUNTIME_DIRECTIVE_PRINTLN "hello world" ]
09:29:22 <olsner> desegnis: I've been hacking on your SHA1 - got quite a bit (about 4x) by using ByteString (almost) everywhere possible (instead of converting to [Word8] before doing the actual work)
09:29:29 <quicksilver> which is a pure structure
09:29:32 <quicksilver> which the RTS executes
09:29:39 <olsner> but still no funky mutable stuff!
09:29:42 <Alleria> I see
09:29:42 <quicksilver> and when the RTS executues it, the print actually happens
09:30:11 <Alleria> I think I'm starting to understand what you mean
09:30:46 <quicksilver> so putStrLn is a pure function, which returns a bunch of "low-level instructions"
09:30:49 <Alleria> MAGIC_RUNTIME_DIRECTIVE_PRINTLN then in turn evals to ()
09:30:52 <quicksilver> it doesn't execute them, it just returns them
09:30:58 <Alleria> Ahh, I see. :)
09:30:59 <Alleria> very cool
09:31:04 <quicksilver> then the RTS chooses to execute them
09:31:19 <quicksilver> of course, to be honest, this isn't *actually* how the ghc RTS does it ;-/
09:31:22 <quicksilver> but, it could be
09:31:23 <quicksilver> it's a model
09:31:28 <Alleria> and finally, executing those low-level instructions yields ()
09:31:33 <quicksilver> and it is roughly how one of the early RTSes worked
09:31:35 <quicksilver> yeah, that's right
09:31:51 <Alleria> I see. So putStrLn doesn't immediately *know* 'I always return ()'
09:31:53 <Alleria> rather:
09:32:04 <Alleria> it just so happens that the low level instructions HAPPEN TO always returns ()
09:32:05 <Alleria> right?
09:32:42 <campusblo> hi
09:32:44 <quicksilver> not necessarily
09:32:50 <quicksilver> the input instructions, for example 
09:32:53 <campusblo> can anybody tell me how to map a list over a list?
09:32:54 <quicksilver> return what they read :)
09:32:59 <quicksilver> :t getLine
09:33:03 <lambdabot> IO String
09:33:26 <quicksilver> Alleria: so getLine returns [MAGIC_RUNTIME_READ_STRING_FROM_INPUT]
09:33:31 <quicksilver> Alleria: and that's where >>= is clever
09:33:41 <desegnis> olsner, very good. that's what I am doing right now :)
09:33:46 <quicksilver> Alleria: >>= says 'use the thing returned by the last magic directive as input'
09:33:55 <quicksilver> campusblo: sure, but I'm not quite sure what you mean
09:34:01 <campusblo> lets say i want to add [1,2,3] to [4,5,6] so i want to add 1 to each then 2 then 3 then total the results
09:34:04 <quicksilver> campusblo: can you be a bit more specific
09:34:04 <Alleria> *nods*. So it feeds the thing that is returned as the input into the next thing...
09:34:21 <quicksilver> campusblo: the easiest way is with a list comprehension
09:34:25 <quicksilver> Alleria: yes, exactly
09:34:30 <quicksilver> Alleria: this is the magic of monads
09:34:32 <Alleria> and I think I understand that part of >>=.
09:34:39 <Alleria> Getting back to >>, however...
09:34:54 <quicksilver> > [ x+y | x <- [1,2,3], y <- [4,5,6] ]
09:34:56 <lambdabot>  [5,6,7,6,7,8,7,8,9]
09:34:56 <Alleria> putStrLn "foo" >> putStrLn "bar" prints 'foo' and then 'bar'
09:35:07 <Alleria> or is that NOT guaranteed?
09:35:09 <quicksilver> campusblo: like that
09:35:19 <quicksilver> Alleria: yes, because it actually returns a composite action like
09:35:20 * wli attacks Sudoku
09:35:23 <campusblo> (1+4+1+5+1+6) + (2+4+2+5+2+6) etc
09:35:29 <quicksilver> Alleria: [MAGIC_PRINT "foo", MAGIC_PRINT "bar"]
09:35:40 <quicksilver> Alleria: and then the runtime executes those instructions (strictly in order)
09:35:55 <olsner> desegnis: actually, not 4x (that was measured before enabling optimizations when compiling) .. the version on hpaste goes in about 2m17s on my test file, while my modded version goes in about 1m
09:36:00 <campusblo> quicksilver i want the result added up
09:36:01 <Alleria> oooh, because >> is defined as something along the lines of \_ -> whatever...
09:36:05 <campusblo> and is there a way to do it using map?
09:36:10 <olsner> gnu coreutils sha1sum does it in 3s
09:36:12 <Alleria> but the "\_" still has to happen
09:36:16 <EvilTerran> campusblo, so you want to pair them up, find the sum of each possible pair, and total the results? then sum [ x+y | ...]
09:36:39 <EvilTerran> you can do it using map, but it'd be much neater using list comprehensions
09:36:43 <campusblo> yes EvilTerran
09:36:43 <quicksilver> Alleria: yeah, that just means we're ignoring the result
09:36:49 <quicksilver> Alleria: and () isn't a very interesting result
09:36:49 <campusblo> oh ok
09:36:53 <int-e> dons: what program are you using to generate pie charts?
09:36:56 <quicksilver> Alleria: so normally you ignore the ()s
09:37:09 <dons> i'm using piechart.c and a sed script
09:37:20 <Alleria> I see
09:37:23 <Alleria> thank you :)
09:37:30 <quicksilver> C and sed? heresy!
09:37:33 <Alleria> this is going to take some thinking through :)
09:37:42 <quicksilver> Alleria: it takes a while to sink in, yeah
09:37:48 <campusblo> ok so how do i do it using list comprehension?
09:38:17 <xerox> campusblo, you use parallel list comprehensions
09:38:32 <Alleria> quicksilver: by the way, does lambdabot have a desugaring command for do-notation?
09:38:36 <campusblo> whats that?
09:38:40 <SamB> xerox: which are an extension
09:38:44 <Alleria> I find it much easier to understand when I actually look at the lambdas that get generated
09:38:45 <campusblo> xerox whats that ?
09:38:50 <EvilTerran> xerox, i don't think that's what he wants
09:38:52 <xerox> > [x+y | x <- [1,2,3] | y <- [4,5,6]]
09:38:52 <lambdabot>  Parse error
09:39:01 <EvilTerran> seeing as he's after the cartesian product
09:39:04 <SamB> xerox: see, I told you they were an extension
09:39:08 <EvilTerran> not the zipping
09:39:28 <quicksilver> @undo do { x <- a; y <- b; c x y }
09:39:28 <lambdabot> a >>= \ x -> b >>= \ y -> c x y
09:39:31 <xerox> that's not what he's looking for either
09:39:32 <quicksilver> Alleria: there :)
09:39:38 <EvilTerran> > [(x,y) | x <- [1,2,3], y <- [4,5,6]] -- can you adapt this to do what you want, campusblo?
09:39:38 <campusblo>  > foldl + [ x+y | x <- [1,2,3], y <- [4,5,6] ]
09:39:40 <lambdabot>  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
09:39:40 <Alleria> quicksilver: thanks! Much obliged!
09:39:47 <ddarius> (>>) does not need to be defined as ... >>= \_ -> ...
09:39:52 <campusblo> ok that didnt work
09:39:59 <EvilTerran> no space before the >
09:40:10 <xerox> > map (uncurry (+)) $ liftM2 (,) [1,2,3] [4,5,6]
09:40:11 <lambdabot>  [5,6,7,6,7,8,7,8,9]
09:40:12 <campusblo> > [ x+y | x <- [1,2,3], y <- [4,5,6] ]
09:40:13 <lambdabot>  [5,6,7,6,7,8,7,8,9]
09:40:22 <quicksilver> ddarius: it needs to be isomorphic to it, though, does it not?
09:40:24 <EvilTerran> parenthesise the + for foldl. also you need an initial value for fold.
09:40:33 <campusblo> > foldl + [ x+y | x <- [1,2,3], y <- [4,5,6] ]
09:40:34 <int-e> dons: thanks
09:40:34 <lambdabot>  Couldn't match expected type `(a -> b -> a) -> a -> [b] -> a'
09:40:39 <EvilTerran> or just use sum instead of foldl (+) 0
09:40:45 <xerox> ah!
09:40:55 <ddarius> quicksilver: It needs to be semantically equivalent to it.
09:40:58 <campusblo> > foldl (+) [ x+y | x <- [1,2,3], y <- [4,5,6] ]
09:40:59 <lambdabot>   add an instance declaration for (Num [t])
09:41:07 <EvilTerran> ?type foldl (+)
09:41:09 <lambdabot> forall a. (Num a) => a -> [a] -> a
09:41:22 <EvilTerran> campusblo, you need an initial value for the fold functions
09:41:57 <EvilTerran> @src sum
09:41:57 <lambdabot> sum = foldl (+) 0
09:42:06 <campusblo> > foldl (+) 0 [ x+y | x <- [1,2,3], y <- [4,5,6] ]
09:42:08 <EvilTerran> campusblo, alternatively, you want that /\
09:42:08 <lambdabot>  63
09:42:12 <desegnis> olsner, I've got now pad, blocks, splitn working on ByteStrings. I'm wondering whether there's a way to convert a ByteString into [Word32] without first unpacking to [Word8]
09:42:13 <campusblo> ah ok
09:42:13 <ddarius> I would've just looked at the State monad. put 3 >> put 4 will always result in the state being 4 and it's not because (>>) is defined as >>= \_ ->
09:42:15 <campusblo> thats it there 
09:42:35 <campusblo> thanks folks
09:42:47 <EvilTerran> @where tutorial
09:42:47 <lambdabot> http://www.haskell.org/tutorial/
09:43:49 <olsner> desegnis: you can do some nice stuff with Data.Binary.Get
09:44:41 <desegnis> olsner, thank you, I'll look into that
09:44:50 <olsner> actually, I should hpaste what I have now
09:48:00 <hpaste>  olsner annotated "SHA1" with "ByteString stuff" at http://hpaste.org/1695#a1
09:49:05 * desegnis is comparing
09:52:29 <quicksilver> ddarius: eh? in the state monad, >> is defined as >>= \_ -> 
09:55:28 <ddarius> quicksilver: Yes, but that's not why put 3 happens before put 4
09:55:40 <ddarius> Even if you defined (>>) directly it would still be the case.
09:56:23 <quicksilver> ddarius: in a fully lazy state monad put 3 wouldn't 'happen' at all
09:56:29 <quicksilver> btu I think I'm missing your point
10:00:24 <campusblo> so i have the following list comprehension 
10:00:27 <campusblo> elementNum st text = lengthS [ elemTrue x y | x <- splitWords  st ,  y <- splitWords text ]
10:00:38 <campusblo> however elemTrue returns a list 
10:01:09 <campusblo> and lengthS wants to work on a list not a list of lists 
10:01:29 <campusblo> is there anyway to express this so that lengthS geta list and not a list of lists?
10:02:05 <quicksilver> I have no idea what your code does, but [z | x <- splitWords st, y <- splitWords text, z <- elemTrue x y ]
10:02:10 <campusblo> anybody understand what i just wrote?
10:02:15 <quicksilver> will 'unwrap' one more level of listiness
10:02:34 <quicksilver> or you could just use 'concat', which is the same thing
10:03:38 <campusblo> concat is like ++ right?
10:03:54 <mm_freak> campusblo: nope
10:04:06 <mm_freak> concat [a,b,c] = a ++ b ++ c
10:04:19 <mm_freak> it concatenates a list of lists
10:04:31 <campusblo> ok i see it here 	
10:04:31 <campusblo> Prelude> concat [[1,2,3], [4], [], [5,6,7,8]]
10:04:31 <campusblo> [1, 2, 3, 4, 5, 6, 7, 8]
10:04:37 <desegnis> olsner, great! I have taken getWord32be (and modified to my taste, i.e. getWord32be :: ByteString -> Word32) and gained performance. Thank you for helping!
10:05:02 <campusblo> but what i have is this [[1,2,3,4,5]]
10:05:11 <campusblo> and i want to take off the brackets
10:05:16 <campusblo> the outside ones
10:05:23 <olsner> desegnis: np, 'twas fun
10:05:26 <mm_freak> use `head'
10:05:31 <mm_freak> > head [[1,2,3,4,5]]
10:05:33 <campusblo> ah
10:05:39 <lambdabot>  [1,2,3,4,5]
10:05:40 <campusblo> thats a great idea mm_freak
10:05:46 <campusblo> i should have thought of that 
10:05:48 <mm_freak> campusblo: it's obvious =)
10:06:11 <campusblo> ok thanks
10:07:22 <shachaf> campusblo: Why not use concat here, though?
10:07:35 <shachaf> > concat [[1,2,3,4,5]]
10:07:37 <lambdabot>  [1,2,3,4,5]
10:07:40 <mm_freak> shachaf: because it's overkill
10:07:55 <shachaf> mm_freak: It's safer -- what if the list is empty?
10:08:01 <mm_freak> i'd just use `head' if it's guaranteed to have a single element
10:08:16 <mm_freak> uhn…  what is concat [] actually?
10:08:18 <mm_freak> > concat []
10:08:19 <lambdabot>  []
10:08:23 <shachaf> @src concat
10:08:23 <lambdabot> concat = foldr (++) []
10:08:23 <mm_freak> ah k
10:08:54 <shachaf> campusblo: How are you making that list?
10:09:02 <mm_freak> shachaf: using concat in this case has both advantages and disadvantages
10:09:17 <mm_freak> if the list is empty, then `head' will fail, which may be desired or not
10:09:22 <shachaf> mm_freak: That's true, of course.
10:09:32 <shachaf> mm_freak: The question is what campusblo really wants.
10:09:44 <mm_freak> yeah
10:10:09 <quicksilver> since he was using a monad comp anyway
10:10:17 <quicksilver> erm list comp
10:10:23 <campusblo> what i really want is to perform two functions over each other
10:10:23 <quicksilver> he might as well list comp that last bit too
10:10:28 <quicksilver> as in my first reply
10:10:36 <campusblo> one sec let me see ifi can describe this i might need to past
10:10:40 <campusblo> @paste
10:10:40 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:10:41 <mm_freak> campusblo: `over' each other?
10:10:49 <mm_freak> k
10:10:57 <shachaf> quicksilver: Yes, that makes it even clearer.
10:12:00 <slowriot> is writeIORef O(1)?
10:12:10 <hpaste>  campusblo pasted "(no title)" at http://hpaste.org/1698
10:12:59 <shachaf> campusblo: splitWords is called words, I think.
10:13:01 <shachaf> @ty words
10:13:03 <quicksilver> slowriot: yeah, I think
10:13:03 <lambdabot> String -> [String]
10:13:07 <shachaf> > words "abc def"
10:13:08 <lambdabot>  ["abc","def"]
10:13:14 <shachaf> @src words
10:13:14 <lambdabot> words s = case dropWhile isSpace s of
10:13:15 <lambdabot>     "" -> []
10:13:15 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
10:13:44 <slowriot> quicksilver: is there a way to find out other than looking at the source code?
10:14:14 <campusblo> ok so now 
10:14:16 <sjanssen> slowriot: what else could it be?
10:14:16 <campusblo> heres the thing 
10:14:35 <mm_freak> campusblo: so where exactly is the problem?
10:14:41 <campusblo> elemtrue gives a list 
10:14:46 <shachaf> campusblo: Why are you making your own isUpper and such rather than importing?
10:15:09 <campusblo> for testing 
10:15:17 <slowriot> sjanssen: It could be O(n), where n is the size of the data recorded. In a purely functional environment, you should only have to record the location of the data, though. I'd rather know the complexity than be required to guess it.
10:15:31 <quicksilver> slowriot: it does no copying
10:15:34 <sjanssen> slowriot: I'm fairly certain it's O(1)
10:15:40 <campusblo> ERROR file:.\encryptbak.hs:11 - Type error in application
10:15:40 <campusblo> *** Expression     : elemTrue x y
10:15:40 <campusblo> *** Term           : y
10:15:40 <campusblo> *** Type           : [Char]
10:15:40 <campusblo> *** Does not match : [String]
10:15:43 <quicksilver> slowriot: it just stores a reference to the existing data
10:15:49 <sjanssen> slowriot: the IORef just stores a single pointer to the data
10:15:57 <campusblo> elemNum takes in 2 strings
10:15:57 <quicksilver> slowriot: (which it may not even calculate, so the data may still be an unevaluted thunk)
10:16:10 <slowriot> okay, thanks
10:17:12 <mm_freak> shachaf: learning haskell means reinventing the wheel pretty often
10:17:13 <campusblo> what i basically want is for one elemNum to take 2 strings and tell me how many times words in string  x occur in string y
10:17:36 <campusblo> so 
10:17:46 <mm_freak> campusblo: i'd write a function `isPrefix xs ys', which checks whether xs is a prefix of ys
10:17:58 <quicksilver> you don't need to write that function
10:17:59 <mm_freak> then write a function `isSublist', which uses `isPrefix'
10:18:03 <quicksilver> it's in the standard libs :P
10:18:05 <SamB> it's surprising how often your wheel is compatible with the old one, though ;-)
10:18:06 <quicksilver> :t isPrefixOf
10:18:08 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
10:18:08 <mm_freak> quicksilver: he's learning
10:18:12 <quicksilver> oh, I see
10:18:15 <quicksilver> fair enough then
10:18:33 <quicksilver> yes, I agree it's a good exercise to write that functoin
10:19:00 <campusblo> elementNum "the fat fat cat"  "the fat" should give a result of 3
10:19:32 <mauke> that's a weird interface
10:20:43 <campusblo> you guys get what im trying to do?
10:21:05 <mm_freak> campusblo: why 3 ?
10:21:13 <mm_freak> what's the purpose of elementNum ?
10:21:14 <campusblo> because fat appears twice
10:21:19 <campusblo> and the appears once 
10:21:21 <mm_freak> ah
10:21:29 <mm_freak> so you're writing a word counting function?
10:21:34 <campusblo> yes
10:21:44 <mauke> > let elementNum a' b' = let {a = words a'; b = words b'} in length $ filter (`elem` a) b in elementNum "the fat fat cat"  "the fat"
10:21:46 <lambdabot>  2
10:21:48 <mm_freak> i'd recommend the second argument to be a list of lists, i.e. something like [String]
10:22:16 <mauke> > let elementNum a' b' = let {a = words a'; b = words b'} in length $ filter (`elem` b) a in elementNum "the fat fat cat"  "the fat"
10:22:17 <lambdabot>  3
10:23:37 <campusblo> I can't use $ 
10:23:50 <campusblo> or {
10:23:57 <campusblo> actually i have never seen those before 
10:24:07 <mm_freak> $ is just argument passing
10:24:11 <mm_freak> f $ x = f x
10:24:25 <tero-> I have a problem with Haskell socket server. Windows clients tend to kill the server when they close the connection. has anybody experienced anything similar?
10:24:29 <mm_freak> but with a lower precedence, so you could write:  f $ 1+x = f (1+x)
10:24:36 <tero-> I have installed SIGPIPE handler but it doesn't help
10:24:52 <campusblo> i pretty much have it in what i wrote except elemtrue nees a string and a list 
10:24:53 <tero-> installHandler sigPIPE Ignore Nothing 
10:25:06 <campusblo> and i cant figure out why the list comprehension wont give me that 
10:25:23 <mm_freak> campusblo: you're doing too much in a single function
10:25:23 <mauke> campusblo: { } are just syntactic sugar for indentation :-)
10:25:34 <mm_freak> split it up into multiple functions for now
10:25:52 <campusblo> ok
10:25:54 <mauke> tero-: how does the server die?
10:25:59 <tero-> mauke: silently
10:26:06 <mauke> what's the exit status?
10:26:20 <tero-> a sec. I'll check
10:26:48 <tero-> 256
10:27:00 <mauke> whoa
10:27:02 <tero-> so hGetLine says end of file
10:27:14 <tero-> and then my exception handler fires
10:27:24 <tero-> after that thread blocked indefinitely and nothing
10:29:05 <tero-> ah. the exit status is in fact 1
10:29:49 <mauke> sounds like an exception
10:31:16 <tero-> those threads that operate with sockets are wrapped inside catch-function
10:31:46 <tero-> though I wonder if hClose could thrown an exception as well
10:52:38 * Cale wonders if anyone has designed a parallelised implementation of Knuth's Algorithm X.
10:54:48 <hpaste>  desegnis annotated "SHA1" with "Complete version with improvements. Code copied from Data.Binary, so there is no dependency on that " at http://hpaste.org/1695#a2
10:54:52 <Cale> I suppose it's fairly clear how that might be done.
10:56:28 <Cale> Does this have anything to do with the sha1 code which was on the mailing list?
11:04:34 <wli> Well, I've got a moderately original method of solving the sudoku problem. I'll have to write it up when I get back.
11:09:00 <desegnis> Cale, no, but I've read that thread too, I think. I'll look how this code compares with the code on the mailing list
11:10:04 <tero-> I traced the bug to isEmptyChan
11:11:12 <tero-> never knew that it could throw an exception
11:13:04 <Lemmih> tero-: What exception does it throw?
11:13:11 <tero-> thread blocked indefinitely
11:15:35 <desegnis> this is nice. the SHA1 code on the mailing list uses unsafe* functions, but my implementation is faster. this is not the whole picture, though
11:21:38 <mauke> http://83.181.88.246/tmp/miniplex/dist/doc/html/ - comments?
11:21:53 <mauke> i.e. is this readable, understandable, etc?
11:26:16 <Heffalump> it lacks an overview
11:26:30 <Heffalump> what's the mechanism? Apparently some kind of socket-based thing, since you mention SIGPIPE.
11:26:47 <mauke> yes
11:27:18 <Heffalump> and why is a Sink a broadcaster and a Source a receiver?
11:27:39 <mauke> er
11:28:03 <mauke> why not?
11:28:40 <mauke> Sink swallows things, Source emits them
11:30:35 <Cale> I suppose the difference between this an a Chan String is that this gives tags to the channels?
11:30:47 <Cale> and*
11:31:36 <mauke> Chans are restricted to a single process
11:31:38 <Cale> Ah, the pipes are in a standard location so you can communicate between multiple programs
11:31:45 <mauke> yeah, exactly
11:34:47 <Heffalump> yes, Sinks swallow things. So why are they broadcasters?
11:35:38 <mauke> from the perspective of the program using the Sink, the message is gone forever
11:36:06 <mauke> do you have a better name for the types?
11:36:16 <wli> Okay, it looks like if this idea is correct it is relatively unique.
11:37:55 <mauke> what, my module?
11:38:16 <wli> No, the sudoku algorithm I'm cooking up.
11:38:39 <Cale> wli: What's the algorithm?
11:40:09 <glguy> SyntaxNinja: good morning
11:40:24 <wli> Cale: It seems to rely heavily on intersections of rows and blocks.
11:40:47 <wli> Cale: And columns and blocks.
11:41:06 <glguy> and rows and columns?
11:41:56 <SyntaxNinja> 'morning
11:42:01 <wli> glguy: Not so much. The intersections of the linear bits with blocks partition them into disjoint sub-regions.
11:42:02 <glguy> coming to the game tonight?
11:42:12 <SyntaxNinja> glguy: ja.  what time is it again?
11:42:19 <glguy> starts at 6
11:42:25 <SyntaxNinja> coo
11:42:53 <SyntaxNinja> for those few people on this channel that don't work at Galois... one advantage of working here is that you can be a part of one of the best soccer teams ever to compete in Portland oregon
11:43:01 <SyntaxNinja> did I say the best? i meant the worst.
11:43:31 <glguy> I'd probably just go to the practices if the team didn't need a sub :)
11:44:04 <wli> glguy: It's kind of related to "grid analysis" or the "generalized method rule" from http://www.stolaf.edu/people/hansonr/sudoku/explain.htm#grids
11:44:05 <lambdabot> Title: Sudoku Assistant -- Solving Techniques
11:44:39 * SyntaxNinja is finally running debian sid on his laptop again
11:44:42 <SyntaxNinja> forget this 'stable' stuff.
11:44:51 <jethr0> SyntaxNinja: i was thinking of applying for an internship at galois. any chances?
11:45:08 <wli> glguy: Mostly I thought of it in terms of relations.
11:45:26 <SyntaxNinja> jethr0: yes, chances.  depends on timeline.
11:45:37 <SyntaxNinja> heya wli long time no see.
11:45:41 <Igloo> SyntaxNinja: Heh, so you lasted what, 3 months after the release?  :-)
11:45:43 <wli> re SyntaxNinja
11:45:54 <SyntaxNinja> wli: you still around pdx?
11:46:06 <wli> glguy: Bear in mind I've not written it yet.
11:46:16 <wli> SyntaxNinja: Yeah, I'm still here.
11:46:56 <hpaste>  mdmkolbe|ubuntu pasted "Why are haskell scopes defined this way?" at http://hpaste.org/1699
11:47:29 <mdmkolbe|ubuntu> I was supprizes that the haskell scoping rules don't allow this.  Is there a good reason? http://hpaste.org/1699
11:47:41 <sjanssen> mdmkolbe|ubuntu: pattern guards don't extend to where, because where scopes over all the guards
11:47:42 <glguy> SyntaxNinja: he's actually not that far from where I live
11:47:52 <sjanssen> mdmkolbe|ubuntu: what if that guard doesn't succeed?
11:48:29 <glguy> mdmkolbe|ubuntu: a where clause is in scope over ALL guards
11:48:45 <mdmkolbe|ubuntu> sjanssen: so are you saying that I could write 'foo x | Just y <- x = z | Nothing = z where z = 3'?
11:48:46 <glguy> mdmkolbe|ubuntu: so bindings in an individual clause are not in scope
11:48:48 <SyntaxNinja> glguy, wli: we should get sushi this week.
11:49:01 <glguy> every week is a good week for sushi :)
11:49:01 <sjanssen> mdmkolbe|ubuntu: correct
11:49:28 <mdmkolbe|ubuntu> sjanssen: then I guess that makes sense
11:49:37 <glguy> mdmkolbe|ubuntu: and the guards require a boolean
11:49:45 <glguy> "Just y " doesn't work
11:50:02 <sjanssen> glguy: pattern guards, they're a GHC extension
11:50:18 <wli> SyntaxNinja: Okay.
11:50:22 <glguy> sjanssen: is that what the <- is in this case?
11:50:29 <sjanssen> glguy: yeah
11:50:34 <quicksilver> I thinke that 'where' also scopes over *all* the declarations in a let ... in .. where ..
11:50:40 <quicksilver> which is handy, if I'm right
11:50:52 <glguy> where is part of a declaration
11:50:58 <quicksilver> erm, let ... where .. in ...
11:51:03 <quicksilver> yeah, that's what I meant :)
11:51:06 <thorkilnaur> mdmkolbe|ubuntu, See http://hpaste.org/1700
11:51:07 <mdmkolbe|ubuntu> Ok, so do I just change the where to a let or is there some way to trick the where to only scope over that one guard
11:51:22 <quicksilver> mdmkolbe|ubuntu: using a let is probably the simplest
11:51:24 <glguy> mdmkolbe|ubuntu: you'd want it to be a let inside the case
11:51:38 <thorkilnaur> mdmkolbe|ubuntu, (grep rts_mainLazyIO in GHC patches)
11:51:59 <wli> glguy: It's more like I'm looking at chunks of the grid defined by constraint interrelations and finding the possibilities for chunks of the grid at a time.
11:52:48 <glguy> the linked article seemed like an interesting approach
11:52:59 <mdmkolbe|ubuntu> thorkilnaur: thx, that particular question is now resolved.  (it seems that rts_mainLazyIO isn't used anymore, and rts_evalLazyIO is used instead).  But grepping the patches is a nice trick that I'll keep in mind for next time.
11:53:37 <wli> glguy: The first step after singletons is coordinate triples like ((i, j), (i, j+1), (i, j+2)) where i `mod` 3 == 0 && j `mod` 3 == 0.
11:54:09 <wli> glguy: Or ((i, j), (i+1, j), (i+2, j)) where i `mod` 3 == 0 and j `mod` 3 == 0.
11:54:31 * mdmkolbe|ubuntu 's wireless keeps droping and the ISP requires a manually started VPN over the wireless so he can't keep the connection up very long
11:55:18 <wli> glguy: Break up the grid into those (one direction at a time), enumerate the possibilities for them, check constraints.
11:55:33 <holst> is it simple to do "parsers" in Haskell?
11:55:43 <wli> holst: Yes.
11:55:49 <mdmkolbe|ubuntu> holst: yes, see parsec
11:55:52 <mdmkolbe|ubuntu> @where parsec
11:55:53 <lambdabot> http://www.cs.ruu.nl/~daan/parsec.html
11:55:58 <mauke> Heffalump: http://83.181.88.246/tmp/miniplex/dist/doc/html/Miniplex.html - is this overview ok?
11:55:58 <glguy> wli: is this method known to produce faster results? or are you implementing it as a curiousity?
11:56:10 <holst> thanks guys, ill check them out immediately =D
11:56:18 <thorkilnaur> mdmkolbe|ubuntu, Yes, I guessed that rts_mainLazyIO wasn't used any more. But interesting that it is still referred for PAR or GRANSIM (or some such). The patch grep trick is Igloo's.
11:56:41 <wli> glguy: I have no idea. It was just what I came up with when I thought about solving it before looking at how everyone else did.
11:57:27 <wli> glguy: It gets hairier doing whole rows/columns/blocks at a time.
11:58:45 <wli> glguy: NFI if it's even correct yet.
11:59:44 <glguy> SyntaxNinja: have you done any of those courses where you ride your bike on logs and narrow elevated paths?
12:00:58 <SyntaxNinja> glguy: no, nothing like that.
12:02:00 <glguy> they keep showing that on OPB, looks like fun (once you are good at it)
12:02:25 <SyntaxNinja> glguy: is it cyclocross? what kind of bikes are they using?
12:02:45 <glguy> looked like mountain bikes, I think
12:02:55 <glguy> its more of a techincal course than a race
12:04:07 <SyntaxNinja> sounds fun :
12:05:55 <antonio-zen> what do you guys think about "The Haskell Road to Logic, Maths and Programming"?
12:05:59 <jethr0> did the wiki just go down?
12:06:15 <wli> glguy: What I came up with is definitely not the way any human would ever go about solving it.
12:06:19 <SamB> jethr0: no
12:06:22 <SamB> it's still up
12:06:23 <wli> antonio-zen: I've never seen it.
12:06:36 <jethr0> i'm having trouble loading a page... well, maybe it's just me ;)
12:06:57 <liber> Can I use filter to filter out the char \n? 
12:07:03 <jethr0> for me it seems to be down...
12:07:04 <liber> from a string
12:07:08 <SamB> I just reloaded http://haskell.org/haskellwiki/Haskell_Cafe_migration twice
12:07:09 <jethr0> liber: yes
12:07:09 <lambdabot> Title: Haskell Cafe migration - HaskellWiki
12:07:16 <liber> jethr0: how?
12:07:21 <glguy> :t filter
12:07:23 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
12:07:25 <jethr0> > filter (/='\n') "hello\nworld"
12:07:26 <antonio-zen> This is the book on Amazon: http://www.amazon.com/Haskell-Logic-Maths-Programming-Computing/dp/0954300696 (no referral id of course)
12:07:26 <lambdabot>  "helloworld"
12:07:30 <lambdabot> http://tinyurl.com/3y6oxo
12:07:35 <glguy> liber: filter keeps anything that statisfies the predicate
12:07:49 <glguy> and removes elements that don't
12:07:51 <SamB> antonio-zen: haven't read it
12:07:59 <jethr0> liber: ^^^
12:08:00 <liber> glguy: I know, but iäm new to this and a bit uncertain of the syntax
12:08:04 <liber> thx jethr0
12:08:08 <jethr0> np
12:08:10 <antonio-zen> SamB: thanks. Has anyone read it?
12:08:27 <glguy> liber: if you wanted it ot be more explicit, you could write: filter (\x -> x /= '\n')
12:08:33 <wli> glguy: I think it may be related to subset elimination most of all.
12:08:36 <jethr0> > concat . lines $ "hello\nworld"
12:08:37 <lambdabot>  "helloworld"
12:09:13 <glguy> wli: the only sudoku strategy I've implemented was "brute force" :)
12:09:59 <SamB> antonio-zen: two people have reviewed it on amazon...
12:10:44 <antonio-zen> SamB: I've seen those reviews but I was trying to gather further feedback given that it appears to be relatively unproven in the Haskell community
12:11:35 <SamB> I might have read a blog entry about it once
12:12:05 <mm_freak> > words "a b c d"
12:12:07 <lambdabot>  ["a","b","c","d"]
12:12:17 <mm_freak> that's useful
12:12:25 <mm_freak> > words "a b…\n c   d…"
12:12:26 <lambdabot>  ["a","b\8230","c","d\8230"]
12:12:46 <mm_freak> > words "a\r\nb"
12:12:48 <lambdabot>  ["a","b"]
12:12:48 <sioraiocht> @src words
12:12:48 <lambdabot> words s = case dropWhile isSpace s of
12:12:48 <lambdabot>     "" -> []
12:12:48 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
12:12:58 <mm_freak> \t break
12:13:01 <mm_freak> :t break
12:13:03 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
12:13:06 <sioraiocht> @src break
12:13:06 <lambdabot> break p =  span (not . p)
12:13:14 <sioraiocht> @src span
12:13:14 <lambdabot> Source not found. I feel much better now.
12:13:25 <sioraiocht> @stabface lambdabot
12:13:25 <lambdabot> Unknown command, try @list
12:13:26 <SamB> here's a book review... http://www.cs.vu.nl/~ralf/JoLLI06/
12:13:28 <lambdabot> Title: Book review "The Haskell Road to Logic, Maths and Programming"
12:13:40 <antonio-zen> SamB: I was looking for the blog entry you mentioned. it is sad how the 5th link or so, is a full copy in pdf (illegal)
12:13:52 <SamB> ooh, nice
12:14:03 <LoganCapaldo> @type (\p s -> (takeWhile p s, dropWhile p s)
12:14:04 <lambdabot> parse error (possibly incorrect indentation)
12:14:07 <LoganCapaldo> @type (\p s -> (takeWhile p s, dropWhile p s))
12:14:09 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
12:15:46 <SamB> antonio-zen: wait, where did you find an alleged PDF of the book?
12:15:55 <glguy> antonio-zen: the first .PDF link I saw on Google was not a PDF of the book
12:16:16 <glguy> it was a review and a sample chapter
12:16:25 <wli> glguy: It's just weird and different. It's based on looking at states for whole regions at a time vs. placement of numbers.
12:16:37 <SamB> the only PDF link I've found so far was the same review I just gave you a link to, though a different PDF...
12:16:41 <antonio-zen> glguy, SamB: searching 'the haskell road math' on google, yields a 6th link with the full pdf :(
12:18:11 <antonio-zen> glguy, SamB: it's actually the 7th link here: http://www.google.ca/search?hl=en&client=firefox-a&rls=org.mozilla%3Aen-US%3Aofficial&hs=pio&q=%27the+haskell+road+math%27&btnG=Search&meta=
12:18:13 <lambdabot> Title: &#39;the haskell road math&#39; - Google Search, http://tinyurl.com/3dlvk2
12:19:39 <antonio-zen> I feel it is unfair for the authors, given that they have not intentionally published it for free as a pdf
12:20:53 <glguy> I've never really enjoyed reading a .PDF
12:21:14 <glguy> I usually buy a book i'm interested in or borrow it from a library or friend
12:21:20 <glguy> (after seeing it in pdf format)
12:22:30 <antonio-zen> glguy: I agree, reading a pdf is not too handy. I like the option of buying the combo pdf + printed book whenever this is possible.
12:22:50 <antonio-zen> glguy:  in fact, with a pdf I can easily search or copy a snippet
12:23:00 <SamB> I don't really think the authors have much to worry about...
12:23:29 <antonio-zen> SamB: agreed, I think it's just the principle. 
12:24:17 <SamB> I mean, okasaki has most of his book online and that doesn't seem to be a problem for him... why, I bet it increases sales...
12:25:00 <glguy> besides, if the author was worried about making money , they'd write books for a more popular language ;-)
12:25:24 <glguy> The ones that people learn to be trendy and with hopes of making a quick buck
12:26:58 <SamB> I think I'm more likely to buy a book after I know what's in it than before, if it's any good
12:27:13 <SamB> I, too, don't much like reading things out of PDFs
12:29:40 <SamB> hmm, they ought to have .lhs files for each chapter online ;-)
12:30:05 <Daniel`> ?
12:30:22 <glguy> !
12:31:15 <SamB> they say that they have written the book in a literate programming style, and that each chapter is a Haskell module...
12:32:04 <mm_freak> what's pretty nice about haskell (or GHC) is that it even parses LaTeX correctly
12:32:14 <SamB> mm_freak: ... not exactly
12:32:30 <SamB> well. depends on the tool maybe...
12:32:35 <mm_freak> \begin{code} ... \end{code}
12:32:42 <SamB> yes, that does indeed work
12:33:31 <SamB> but for some reason some of the packages for using lhs with LaTeX don't let you just run "latex Foo.lhs"
12:34:18 <mm_freak> it must have the usual .tex extension, i guess
12:34:40 <SamB> mm_freak: that's not it at all
12:35:26 <SamB> the .tex extension is only the default extension for TeX programs
12:35:47 <SamB> (documents?)
12:36:18 <mdmkolbe|ubuntu> in there a standard uninterleave function ([a] -> ([a], [a]))?
12:36:26 <SamB> have you ever run "latex docstrip.dtx"?
12:36:41 <SamB> you might want to try it sometime ;-)
12:37:00 <Heffalump> mauke: oh, I see (re Sink/Source)
12:37:03 * Heffalump reads the docs
12:37:04 <mm_freak> samb: what is .dtx ?
12:37:19 <SamB> mm_freak: you should find out if you ever try it
12:41:26 <Heffalump> mauke: yes, looks good
12:49:40 <ihope_> @type interleave
12:49:42 <lambdabot> Not in scope: `interleave'
12:49:56 <ihope_> @type Data.List.interleave
12:49:58 <lambdabot> Not in scope: `Data.List.interleave'
12:52:40 <ari> @type intersperse
12:52:42 <lambdabot> forall a. a -> [a] -> [a]
12:53:41 <ihope_> > intersperse ' ' "Hello, world!"
12:53:43 <lambdabot>  "H e l l o ,   w o r l d !"
12:54:43 <kaol> > head $ intersperse undefined "hello"
12:54:45 <lambdabot>  'h'
12:55:40 <Syzygy-> > take 2 . intersperse undefined $ "hello"
12:55:41 <lambdabot>  Undefined
12:55:46 <glguy> > last $ intersperse undefined "hello"
12:55:47 <lambdabot>  'o'
12:56:18 <Syzygy-> glguy: That works by not evaluating anything more than the "skeleton" of the list while traversing it, does it?
12:56:32 <glguy> yeah
12:56:59 <Syzygy-> > (!!8) . intersperse undefined $ "hello"
12:57:00 <lambdabot>  'o'
12:57:07 <Syzygy-> > (!!7) . intersperse undefined $ "hello"
12:57:08 <lambdabot>  Undefined
12:57:25 <Syzygy-> > intersperse undefined $ "hello"
12:57:26 <lambdabot>  Undefined
12:57:37 <EvilTerran> > [undefined, undefined, undefined, True, undefined] !! 3
12:57:38 <lambdabot>  True
12:58:14 <Botje> > 5+undefined
12:58:16 <lambdabot>  Undefined
12:58:25 <Botje> > 5+undefined == undefined
12:58:26 <lambdabot>  Undefined
12:58:32 <Botje> boo
13:02:05 <Daniel4> Can I build a function which returns a function which returns true if a variable is built with a certain constructor? For example, (\constr -> (\var -> case var of constr _ -> True; otherwise -> False)) (Just) (Just 1) should return True.
13:02:44 <Heffalump> Daniel4: no
13:02:59 <mauke> no first class constructors
13:03:15 <Heffalump> you would first have to make an isFoo function that was specific to a given constructor
13:03:20 <Heffalump> and then pass that as a parameter
13:03:24 <EvilTerran> you can fake something for any given type
13:03:52 <SamB> you can even fake it for many types with Data.Generics...
13:03:54 <Heffalump> oh, also, you can play tricks with Typeable
13:03:58 <Heffalump> yeah, that
13:04:02 <SamB> Heffalump: you mean Data
13:04:17 <Heffalump> I'm not sure what I mean :-)
13:04:49 <Daniel`> So I can never pass the constructor in as a plain argument because they are not "first class"?
13:05:10 <mauke> you can pass the constructor but it'll turn into a plain old function
13:05:18 <SamB> Daniel`: they decay to functions when you try to pass them around, yes
13:05:29 <mauke> just like C!
13:05:33 <Daniel`> then I can't use it for pattern matching.
13:05:38 <mauke> exactly
13:05:43 <EvilTerran> data Foo a = Bar | Baz a | Eek (a,a); sameConstFoos :: Foo a -> Foo b -> Bool; sameConstFoos Bar Bar = True; sameConstFoos (Baz _) (Baz _) = True; sameConstFoos (Eek _) (Eek _) = True; sameConstFoos _ = False
13:06:07 <SamB> mauke: except in C s/data constructor/array/ and s/function/pointer/
13:06:17 <mauke> yep
13:06:28 <mauke> also, functions
13:06:38 <SamB> huh?
13:06:44 <Daniel`> Thanks guys! This is my first time using irc and it's been great!
13:06:51 <EvilTerran> then you could do "sameConstFoos (Baz undefined)" or "sameConstFoos (Eek undefined)" or whatever
13:06:55 <thorkilnaur> Donald E. Knuth, 1977, quoted from memory: "If you use a trick twice, it's a technique." (c.f. Igloo's GHC patch grep trick.)
13:07:05 <SamB> functions don't decay, they just have auto-&
13:07:06 <mauke> C functions are so second class you can't do anything with them (besides having them turn into function pointers)
13:07:14 <mauke> SamB: what's the difference?
13:07:33 <kaol> > unfoldr (\x -> case x of [] -> Nothing ; (x:xs) -> Just (x,(drop 1 xs))) $ intersperse undefined "hello"
13:07:35 <lambdabot>  "hello"
13:07:45 <SamB> in assembler, everything works that way...
13:07:49 <Japsu> @type undefined
13:07:51 <lambdabot> forall a. a
13:15:20 <fasta> First control flow use of maybe monad :)
13:17:34 <kaol> > unfoldr (\x -> case x of (x:xs) -> Just (x,(drop 1 xs)) ; _ -> Nothing) $ drop 1 $ intersperse undefined "hello" -- why not a list of undefineds?
13:17:36 <lambdabot>  Undefined
13:17:50 <SamB> so, um, I'm bored...
13:22:03 <kaol> @src undefined
13:22:03 <lambdabot> undefined =  error "Prelude.undefined"
13:22:23 <liber> Has there been any obfuscated haskell code competition?
13:22:35 <SamB> there was one
13:22:43 <SamB> but it doesn't seem to have recurred?
13:22:44 <Heffalump> there've been at least two
13:22:46 <Heffalump> perhaps three
13:22:52 <SamB> oh, two or three?
13:22:54 <SamB> hmm.
13:22:58 <kaol> I thought @pl was it
13:22:58 <arcatan> recursive obfuscated haskell code competition, hmm
13:23:08 <liber> lol
13:23:39 <kaol> @pl unfoldr (\x -> case x of [] -> Nothing ; (x:xs) -> Just (x,(drop 1 xs)))
13:23:40 <lambdabot> (line 1, column 29):
13:23:40 <lambdabot> unexpected ">"
13:23:40 <lambdabot> expecting variable, "(", operator or ")"
13:23:46 <Heffalump> augustss ran one in the 90s at some point. Then shapr ran one a few years back, not being aware of augustss's one. Then I think there may have been a second in shapr's series.
13:26:05 <chadz> @src printf
13:26:05 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
13:26:38 <chadz> how does printf support variable parameters ?
13:26:53 <mauke> magic
13:26:56 <SamB> @source Text.Printf
13:26:56 <lambdabot> http://darcs.haskell.org/packages/base/Text/Printf.hs
13:26:58 <mauke> actually, type classes
13:27:13 <SamB> mauke: the difference being?
13:27:33 <SamB> chadz: anyway, that's the source...
13:27:55 <dr_strangelove> did the semantics of ByteString.inits and ByteString.isPrefixOf change recently?
13:28:11 <SamB> dr_strangelove: was it wrong?
13:29:11 <dr_strangelove> I'm trying to get started with the HaskellNet.POP3 library
13:29:48 <sjanssen> dr_strangelove: I don't think they've changed recently
13:29:54 <dr_strangelove> It can't work with the current "inits" and "isPrefixOf" functions
13:30:59 <sjanssen> dr_strangelove: what sort of behavior are you seeing?
13:31:45 <dr_strangelove> connectPop3 fails because BS.last is called on empty string
13:32:13 <dr_strangelove> I had to insert a reverse in front of BS.inits to get it running
13:32:49 <dr_strangelove> and the isPrefixOf function is called twice with flipped parameters
13:34:25 <dr_strangelove> is currently somebody working on HaskellNet?
13:35:39 <kaol> @hoogle String -> Int
13:35:43 <lambdabot> No matches, try a more general search
13:36:28 <dr_strangelove> @hoogle String -> a
13:36:29 <lambdabot> Prelude.error :: String -> a
13:36:29 <lambdabot> Debug.Trace.trace :: String -> a -> a
13:36:29 <lambdabot> Prelude.fail :: Monad m => String -> m a
13:37:05 <chadz> ?hoogle untilM
13:37:05 <lambdabot> No matches found
13:37:07 <mauke> @type read
13:37:12 <lambdabot> forall a. (Read a) => String -> a
13:38:30 <kaol> > (read "123")::Int
13:38:31 <lambdabot>  123
13:38:42 <kaol> > (read "nan")::Int
13:38:43 <lambdabot>  Exception: Prelude.read: no parse
13:39:03 <dr_strangelove> > (read "NaN")::Int
13:39:04 <lambdabot>  Exception: Prelude.read: no parse
13:39:20 <kaol> how about something that returns a Maybe Int?
13:39:39 <ihope_> @type reads
13:39:41 <lambdabot> forall a. (Read a) => String -> [(a, String)]
13:39:53 <ihope_> > reads "36" :: Int
13:39:53 <lambdabot>  Couldn't match expected type `Int'
13:40:00 <ihope_> > reads "36" :: [(Int, String)]
13:40:01 <lambdabot>  [(36,"")]
13:40:08 <ihope_> > reads "blah" :: [(Int, String)]
13:40:09 <lambdabot>  []
13:40:14 <ihope_> > reads "36 people" :: [(Int, String)]
13:40:16 <lambdabot>  [(36," people")]
13:41:19 <ihope_> maybeRead x = case reads x of [(r,"")] -> r; _ -> error (x ++ " does not parse")
13:41:32 <ihope_> @hoogle String -> Maybe a
13:41:33 <lambdabot> No matches, try a more general search
13:41:57 <ihope_> @hoogle Read a => String -> Maybe a
13:41:57 <lambdabot> No matches, try a more general search
13:42:24 <ihope_> Wait, did I just give you a maybeRead that doesn't return a Maybe? :-P
13:42:41 <ihope_> Anyway, there it is if anybody wants it.
13:43:11 <kaol> > do a <- listToMaybe (reads "36" :: [(Int, String)]) ; return $ fst a
13:43:12 <lambdabot>  Just 36
13:43:20 <kaol> > do a <- listToMaybe (reads "nan" :: [(Int, String)]) ; return $ fst a
13:43:21 <lambdabot>  Nothing
13:43:42 <ihope_> Hmm, that's nice.
13:44:17 <sjanssen> listToMaybe isn't quite the same thing
13:45:02 <sjanssen> do a <- listToMaybe (reads "1 invalid" :: [(Int, String)]) ; return $ fst a
13:45:17 <sjanssen> > do a <- listToMaybe (reads "1 invalid" :: [(Int, String)]) ; return $ fst a
13:45:18 <lambdabot>  Just 1
13:45:59 <int-e> > do a <- listToMaybe (reads "1 invalid" :: [(Int,  String)]) ; guard . null . snd $ a; return $ fst a
13:46:00 <lambdabot>  Nothing
13:46:28 <int-e> (this is still flawed)
13:47:13 <kaol> > do (a,"") <- listToMaybe (reads "1 invalid" :: [(Int, String)]) ; return a
13:47:14 <lambdabot>  Nothing
13:47:20 <kaol> > do (a,"") <- listToMaybe (reads "1" :: [(Int, String)]) ; return a
13:47:22 <lambdabot>  Just 1
13:47:25 <int-e> > read "1 "
13:47:27 <lambdabot>  1
13:47:31 <int-e> > do (a,"") <- listToMaybe (reads "1" :: [(Int, String)]) ;  return a
13:47:32 <lambdabot>  Just 1
13:47:36 <int-e> > do (a,"") <- listToMaybe (reads "1 " :: [(Int, String)]) ;  return a
13:47:37 <lambdabot>  Nothing
13:48:58 <kaol> I'm not really out to get a Maybe version of read. The first listToMaybe version is good enough for my purposes.
13:49:12 <Liskni_si> > (read "1 invalid") :: Int
13:49:14 <lambdabot>  Exception: Prelude.read: no parse
13:50:34 * kaol suspects that he's overly fond of using do notation with Maybe
14:00:20 <campusblo> hi folks 
14:00:25 <campusblo> im getting the following error in hugs
14:00:34 <campusblo> *** Type           : [(Integer,[Char])]
14:00:34 <campusblo> *** Does not match : [(Int,String)]
14:00:39 <campusblo> is that possible?
14:00:49 <int-e> Int and Integer are different types
14:01:15 <campusblo> and what about string and [Char]
14:01:21 <campusblo> ?
14:01:21 <int-e> they're the same
14:01:24 <campusblo> ok 
14:01:28 <campusblo> thanks
14:01:30 <int-e> @src String
14:01:31 <lambdabot> type String = [Char]
14:02:10 <kaol> @type (fromIntegral (123 :: Int), 123 :: Int, 123)
14:02:12 <lambdabot> forall b t. (Num b, Num t) => (b, Int, t)
14:04:15 <fasta> How do you navigate large code bases like e.g. GHC's?
14:04:30 <campusblo> I dont have the word integer anywhere in my code though 
14:04:48 <campusblo> where would it get integer from? the result of a function?
14:05:00 <sjanssen> campusblo: probably numeric defaulting
14:05:30 <campusblo> so should i change int  to integer?
14:05:42 <campusblo> would that solve the problem?
14:05:55 <sjanssen> campusblo: it might
14:06:10 <campusblo> ok ill try that 
14:10:30 <Lamperi> 8)
14:15:39 <campusblo> pattern match failure
14:15:47 <campusblo> its the same thing right?
14:16:08 <campusblo> *** Type           : [(Integer,[Char])]
14:16:08 <campusblo> *** Does not match : [(Int,String)]
14:16:25 <campusblo> when i change Int to Integer i get a pattern match failure
14:16:30 <campusblo> yuck
14:16:40 <kaol> perhaps you could use fromIntegral
14:16:41 <campusblo> what would cause that?
14:17:37 <campusblo> ok ill try that
14:28:58 <DRMacIver> Hm. hpodder seems rather nice.
14:29:31 <DRMacIver> And it's good to see random tools out there written in Haskell - I picked it up not even realising it was a Haskell program. :)
14:30:40 <DRMacIver> (Admittedly I only discovered that it was a Haskell program because it broke and complained about HDBC, but that's a separate issue. :) )
14:32:12 <kaol> the h prefix was not clue enough? ;-)
14:33:48 <DRMacIver> There are only 26 letters in the alphabet. Of these I doubt more than 20 are commonly found as prefixes. If Haskell had a 5% market share in the available toolset I'd be rather impressed. ;)
14:33:56 <DRMacIver> </bogus reasoning>
14:34:50 <kaol> just a matter of time...
14:44:55 <jcreigh> DRMacIver: the same thing happened to me with hpodder. I only realized it was written in Haskell after seeing it on Hackage.
14:52:01 <jethr0> @seen
14:56:32 <Cale> Man, there are some really long and boring threads on haskell-cafe at the moment :)
14:57:04 <SamB> they say that you can ignore those if you use NNTP
14:57:17 <Cale> I use gmail, it works fine :)
14:57:27 <allbery_b> you can ignore them with reasonable imap clients too.  like I do :)
14:57:27 <bos> wow, we're going to have to rename haskell-cafe to haskell-teeming-chat-factory soon
14:57:56 <allbery_b> (not so much with haskell-cafe as with some other mailing lists I'm n.  you haven't seen noise yet)
14:57:58 <Cale> I don't really mind, I just find it funny what people choose to go on about.
14:58:00 <bos> it's getting near time for me to switch back to gnus
14:58:14 <bos> allbery_b: i read several kernel mailing lists; about 1500 messages a day :-)
14:58:42 <ddarius> Cale: Such as?
14:58:47 <ddarius> (Not that I disagree.)
14:59:49 <bos> nntp?
15:00:01 <Cale> ddarius: This 100 message thread titled "In place modification"...
15:01:04 <allbery_b> it turned into 6 or 7 not closely related threads
15:01:14 <allbery_b> not obviously closely related, at least
15:01:30 <kaol> I'm having trouble with using implicit parameters. I'm not quite sure what to ask, though... anyone have an example of their use with let?
15:01:44 <bos> kaol: implicit parameters are widely unused
15:02:00 * allbery_b thought they were scheduled to go away
15:02:07 <LoganCapaldo> What are implicit parameters?
15:02:20 <ddarius> Currently, that thread is mostly hughperkins and Sebastian Sylvan going around in circles.
15:02:21 <Cale> LoganCapaldo: basically, the reader monad without the reader monad.
15:02:30 <EvilTerran> ?type ?x + ?y
15:02:32 <LoganCapaldo> Cale, oooooook
15:02:33 <lambdabot> forall a. (?x::a, ?y::a, Num a) => a
15:02:37 <kaol> I was trying to use them like in the runServerParts example at http://haskell.org/haskellwiki/HAppS_tutorial
15:02:38 <Cale> Like that ^^
15:02:39 <bos> kaol: you'd be best not to use them
15:02:41 <lambdabot> Title: HAppS tutorial - HaskellWiki
15:02:41 <LoganCapaldo> What does the syntax look like?
15:02:49 <EvilTerran> logan, what i just did
15:02:54 <LoganCapaldo> aH
15:02:57 <LoganCapaldo> weird
15:03:14 <EvilTerran> the implicit params are attached to an expression as part of the type
15:03:40 <LoganCapaldo> so ?x + ?y is a way of writing \x y -> x + y ?
15:03:43 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#implicit-parameters
15:03:46 <lambdabot> Title: 7.4. Type system extensions, http://tinyurl.com/uxvor
15:03:51 <EvilTerran> LoganCapaldo, not exactly
15:04:17 <LoganCapaldo> oh lordty
15:04:18 <Cale> LoganCapaldo: sort of, but you can thread those parameters implicitly up through arbitrarily many other functions
15:04:21 <bos> ah, cale pasted the URL i was about to paste
15:04:22 <LoganCapaldo> it's with-open-file
15:04:27 <LoganCapaldo> isn't it?
15:04:34 <kaol> I should write that example to amend the request to include the data that's passed via implicit parameters in it. If only I knew how.
15:05:03 <EvilTerran> i can't remember how to set them off hand...
15:05:32 <ddarius> LogonCapaldo: The parameters are passed the same way the type class dictionaries are.
15:05:38 <ddarius> They propagate the same way.
15:05:41 <LoganCapaldo> this is bizzare. I think i'll just calmly forget I ever saw them and hope I don't run in to them in real code
15:06:11 <ddarius> That's the appropriate response.
15:06:32 <Cale> Yep.
15:06:58 <Cale> You can also be glad that you'll actually never run into linear implicit parameters, since they've been removed from GHC.
15:07:10 <ddarius> Yay
15:08:09 <|Steve|> Implicit linear parameters? Is that implicit parameters that are linear or parameters that are implicitly linear?
15:08:24 <|Steve|> As we all know, linear types can change the world.
15:08:51 <Cale> |Steve|: It's basically the state monad implicitly threaded through your computation.
15:09:15 <|Steve|> That sort of makes sense.
15:09:19 <EvilTerran> state? someone said reader a minute ago
15:09:23 <int-e> Cale: not reader?
15:09:25 <ddarius> A bit better behaved than that.
15:09:27 <kaol> hmm. it wasn't that hard to not use implicit parameters after all.
15:09:33 <ddarius> THoat was for implicit parameters.
15:09:44 <int-e> @type Control.Monad.Reader.local
15:09:46 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
15:09:55 <sjanssen> kaol: yes, implicit parameters probably don't belong in a tutorial setting like that
15:10:06 <EvilTerran> ddarius, do you have a link for these linear implicit parameters?
15:10:13 <Cale> int-e: ah, in that sense, yeah, I suppose you could look at it that way
15:10:18 <ddarius> Check the old GHC User Manual's.
15:10:24 <EvilTerran> okies
15:11:26 <int-e> Cale: for me the state monad would support changing the implicit argument by calling another function, and that's not possible.
15:12:03 <Cale> Yeah, I suppose it's more restrictive than the state monad, but the translation to the reader monad is sort of funny.
15:13:45 <int-e> > runReader (do v1 <- local (const 23) ask; v2 <- ask; return (v1, v2)) 42
15:13:46 <lambdabot>  (23,42)
15:14:05 <int-e> bindings to the implicit arguments would look like that local call here, I suppose
15:14:05 <ddarius> int-e: The point is that they are linear so there is no way to 'call another function' with it.
15:14:27 <SamB> wasn't the reason for the removal the fact that they were not implemented correctly?
15:14:36 <Cale> http://www.haskell.org/tmrwiki/FunWithLinearImplicitParameters -- also see this :)
15:14:37 <lambdabot> Title: FunWithLinearImplicitParameters - TmrWiki
15:15:04 <Cale> (though the evil that happens there also involves unsafePerformIO and unsafeCoerce#
15:15:54 <LoganCapaldo> I wish those functions had more entertaining names
15:16:21 <LoganCapaldo> iAmAPoopyHeadAndWantToMuckWithTheTypeOfThisValue
15:16:56 <LoganCapaldo> actMoreLikeAnIckyLanguageBy
15:18:16 <mrd> witness my pitiful attempts at creating a world entirely out of lambdas: http://mapcar.org/haskell/LambdaWorld.jpg
15:18:59 <LoganCapaldo> you'd think you'd have a lambda cube, and not a lambda sphere
15:19:39 <mrd> hm, lambda cube. not a bad idea.
15:19:46 <mrd> i have a lambda sphere elsewhere, but decided to mix it up
15:19:52 <int-e> ddarius: afaik implicit args and linear implicit args are two different extensions.
15:20:33 <fasta> mrd: xmonad?
15:20:37 <mrd> naturally
15:21:02 <liber> nOOb question: Can I return multiple values from a function?
15:21:10 <LoganCapaldo> liber: no. yes.
15:21:10 <mrd> liber: tuple
15:21:18 <EvilTerran> > (\x -> (x+1, x*2)) 3
15:21:26 <lambdabot>  (4,6)
15:21:47 <EvilTerran> > let (x,y) = (4,6) in x + y -- getting them out of the tuple again
15:21:49 <lambdabot>  10
15:21:56 <shachaf> > (+1) &&& (*2) 3
15:21:57 <lambdabot>   add an instance declaration for (Num (b -> c'))
15:22:09 <shachaf> > (+1) &&& (*2) $ 3
15:22:10 <lambdabot>  (4,6)
15:22:31 <mauke> > liftM2 (,) succ (join (+)) 3
15:22:32 <lambdabot>  (4,6)
15:22:47 <liber> mrd: i guessed that :)
15:22:54 <EvilTerran> i don't think these things are appropriate for answering a known "noob question" ;]
15:22:58 <liber> thx
15:23:07 <LoganCapaldo> They don't even answer the question
15:23:15 <mauke> my answer was not only inappropriate, it was also completely useless!
15:23:35 <LoganCapaldo> Mine might have been more useless
15:23:40 <LoganCapaldo> all wishy washy
15:23:51 <shachaf> > let { f x r = r (x+1) (x*2) } in f 5 (\x y -> x + y)
15:23:52 <lambdabot>  16
15:24:01 <mauke> oh, continuations
15:24:03 <LoganCapaldo> heh
15:24:08 <LoganCapaldo> CPS++
15:24:24 <mauke> > let { f x r = r (x+1) (x*2) } in f 3 (,)
15:24:25 <lambdabot>  (4,6)
15:24:40 <shachaf> mauke: I was going to use (,), but I thought there wasn't much point. :-)\
15:24:51 <mauke> shachaf: that's the point!
15:24:53 <shachaf> s/.$//
15:25:00 <mauke> complex non-solutions to trivial problems
15:25:08 <shachaf> mauke: Exactly.
15:25:15 <mrd> ... in stereo
15:25:25 <mauke> liber: sorry
15:25:34 <liber> what?
15:25:53 <mauke> this channel has become very silly
15:25:57 <shachaf> liber: Ignore us here in the corner. :-)
15:26:19 <liber> Weill. I did, until you highlighted me :)
15:26:53 <mauke> oh. carry on, then
15:27:03 <EvilTerran> iirc, one of my early experiments with \bot turned into a competition to determine increasingly convoluted ways of expressing (repeat 1)
15:27:21 <shachaf> EvilTerran: What was the winner?
15:27:24 <ddarius> What you're supposed to do is say the answer is tuples and then proceed to demonstrate with Church-encoded tuples.
15:27:37 <liber> The question was whether i could return two values. I had already figured that I could use tuples. I don't need a whole page with suggestions :)
15:27:38 <EvilTerran> shachaf, i think there was something involving unfoldr that was quite scarey
15:27:54 <mrd> you don't "need", but that's the point =)
15:28:02 <liber> =)
15:28:15 <mauke> liber: the real answer is that you can't return two values but you can combine multiple values into a single value
15:28:23 <SamB> liber: you could use unboxed tuples
15:28:24 <mauke> tuples is one way
15:28:28 <SamB> but that would be a bad idea
15:28:44 <EvilTerran> > unfoldr (const . Just . flip (,) () $ 1) ()
15:28:49 <liber> Well. Its kind of a noob project. Don't confuse me...
15:28:56 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
15:29:14 <liber> I'll go with tuples...
15:29:16 <mauke> > iterate( fmap fix return ) 1
15:29:17 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
15:29:45 <EvilTerran> of course, there's easy ones like [1,1..], let x = 1:x in x, fix (1:), etc, too
15:29:52 <shachaf> > fix (1:) -- This may not be very complicated, but it's a bit odd that it's the first thing I think of, even before (repeat 1)
15:29:53 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
15:30:24 <mauke> > join div `liftM` [1..]
15:30:37 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
15:30:41 <EvilTerran> > join (iterate . const) 1
15:30:42 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
15:30:59 <|Steve|> How does that differ from iterate 1?
15:31:01 <|Steve|> > iterate 1
15:31:02 <lambdabot>   add an instance declaration for (Num (a -> a))
15:31:09 <EvilTerran> it's iterate (const 1) 1
15:31:09 <|Steve|> Oh, I see.
15:31:10 <mauke> 1 is usually not a function
15:31:26 <|Steve|> > repeat 1
15:31:27 <EvilTerran> mauke, :D
15:31:27 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
15:31:29 <|Steve|> There we go.
15:31:45 <shachaf> > iterate id 1 -- Why const?
15:31:46 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
15:32:04 <mauke> shachaf: that's essentially my first solution
15:32:06 <|Steve|> I think repeat is the way to do it.
15:32:49 <mauke> > liftM (liftM length) group [1..]
15:32:50 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
15:32:51 <shachaf> mauke: Oh, sorry, I missed that one.
15:33:01 <allbery_b> > [1,1..]
15:33:03 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
15:33:10 <int-e> > fix (1:)
15:33:12 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
15:33:35 <jcreigh> um, yes, there are many ways to make an infinite list repeating the same element...
15:33:42 <kaol> > fix (:1)
15:33:43 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
15:33:43 <lambdabot>       Expected...
15:34:22 <ddarius> To paraphrase mauke: 1 is usually not a list
15:34:24 <shachaf> jcreigh: Infinitely many ways. :-)
15:34:32 <msouth> Is the haskell wikibook the state of the art in user-editable introductions to haskell?
15:34:59 <msouth> the one at http://en.wikibooks.org/wiki/Haskell
15:35:01 <lambdabot> Title: Haskell - Wikibooks, collection of open-content textbooks
15:35:39 <liber> msouth: you also have: http://en.wikibooks.org/wiki/Haskell/YAHT
15:35:41 <lambdabot> Title: Haskell/YAHT - Wikibooks, collection of open-content textbooks
15:35:48 <liber> oops
15:36:21 <liber> it was on the first page :) Missed that
15:36:38 <msouth> ah, I just got a message on wiki telling me about #haskell-books
15:36:47 <msouth> I'll join there, thanks for the link liber
15:36:52 <EvilTerran> > join (zipWith (-) . tail) [1..]
15:36:53 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
15:37:22 <mauke> nice
15:37:24 <DRMacIver> ddarius: Although it could be. :) There are interesting reasons to make it one.
15:37:25 <msouth> i had started through YAHT as a pdf and had some suggestions, so it's nice to have that link.
15:37:33 <SamB> wiki has messages?
15:37:48 <DRMacIver> (But they're probably better suited to newtyping List first)
15:37:48 <msouth> apparently
15:38:56 <msouth> I got an automated message on my first edit, and then the Kowey sent me a personalized one just now.  Appeared as "you have a message" at the top of the next page I viewed.
15:40:17 <McBee> :t fix
15:40:19 <lambdabot> forall a. (a -> a) -> a
15:40:37 <EvilTerran> @src fix
15:40:38 <lambdabot> fix f = let x = f x in x
15:40:41 <shachaf> fix f = let x = f x in x -- fix f = f (fix f)
15:41:04 <EvilTerran> fix (1:) = (let x = 1:x in x)
15:41:04 <shachaf> fix f = f (f (f (f (f (f (...
15:41:54 <EvilTerran> it's got a more general theoretic use, as it allows one to express what would be a recursive algorithm without actually recursing
15:42:32 <EvilTerran> > fix (\f x -> if x == 0 then 1 else x * f (x-1)) 6
15:42:34 <lambdabot>  720
15:42:41 <shachaf> > fix (\f x -> if x == 0 then 1 else x * f (x-1)) 5
15:42:42 <lambdabot>  120
15:42:44 <mrd> may cause plenty of ordinary cursing though
15:42:46 <shachaf> EvilTerran: Too late. :-)
15:42:46 <EvilTerran> lol wut
15:42:56 <EvilTerran> @quote stereo
15:42:56 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
15:43:31 <shachaf> EvilTerran: You know C_ale hates that. It makes his IRC client beep.
15:43:47 <EvilTerran> oh. sorry C*le!
15:44:22 <Olathe> Is the beep in majestic stereo ?
15:44:39 <EvilTerran> heh
15:47:00 <shachaf> Olathe: Regarding a question you had quite a while ago in #ruby-lang , which a thread on haskell-cafe recently reminded me of -- yes, haskell can figure out that foldr (+) 0 (repeat 1) is infinite (That is, > any finite number), given a "sufficiently lazy number type".
15:48:06 <msouth> SamB: to follow that up, looks like it's just something special that happens when someone adds a comment to your user talk page.
15:48:16 <SamB> msouth: ah
15:48:23 <EvilTerran> "sufficiently lazy" being "can partially evaluate a number just far enough so as to work out a comparison"
15:48:24 <Olathe> shachaf: Oh, OK.
15:48:25 <EvilTerran> ?
15:48:30 <SamB> that was the only thing I could think of ;-)
15:48:55 <shachaf> Olathe: So yes, http://foldr.com/ would actually work. :-)
15:48:56 <lambdabot> Title: foldr.com
15:50:05 <shachaf> By the way, there's also a foldl.com, and I'd say foldl'.com also works -- it returns _|_, just like it's supposed to. :-)
15:50:46 <ihope_> foldl.com is easier to use.
15:51:08 <shachaf> ihope_: Yes, less mouse-moving.
15:51:22 <shachaf> ihope_: Parentheses are thinner.
15:51:47 <ihope_> ( is less than 1+(
15:51:52 <ihope_> Lengthwise, that is.
15:52:04 <shachaf> ihope_: Of course, you can use the keyboard, which would be even faster. :-)
15:52:25 <ihope_> How do I do that?
15:52:44 <EvilTerran> > fix $ \s -> "1+("++s++")"
15:52:52 <lambdabot>  "1+(1+(1+(1+(1+(1+(1+(1+(1+(1+(1+(1+(1+(1+(1+(1+(1+(1+(1+(1+(1+(1+(1+(1+(1+(...
15:53:13 <Botje> Can i turn the ParseError from Parsec into a string easily?
15:53:18 <shachaf> ihope_: Well, I'm not using my own computer at the moment, but on this one, shift-tab, enter, shift-tab, enter, seems to work.
15:53:20 <ihope_> > cycle "1+("
15:53:20 <Botje> (or something fail will accept?)
15:53:22 <lambdabot>  "1+(1+(1+(1+(1+(1+(1+(1+(1+(1+(1+(1+(1+(1+(1+(1+(1+(1+(1+(1+(1+(1+(1+(1+(1+(...
15:53:26 <shachaf> Botje: Doesn't "show" work?
15:53:36 <ihope_> Ooh, that's nice.
15:53:37 <jfredett> does it derive show?
15:53:50 <jfredett> ihope, thats not the same string
15:53:51 <SamB> shachaf: it would work even better if you registered it but had it resolve to a non-existant computer or something
15:53:57 <Botje> ..
15:53:59 <Botje> so it does
15:53:59 <ihope_> jfredett: it isn't?
15:54:00 <SamB> unfortunately you can't do that...
15:54:02 <jfredett> nope
15:54:03 <Botje> I feel stupid now
15:54:06 <shachaf> ihope_: Yours doesn't close the parens at the end. :-)
15:54:09 <Botje> thanks! shachaf++
15:54:11 <ihope_> jfredett: where are they different?
15:54:16 <jfredett> the former has closing parens
15:54:20 <ddarius> jfredett: They are bisimilar.
15:54:23 <ihope_> jfredett: where?
15:54:31 <mauke> at the end
15:54:31 <Botje> (and jfredett, but shachaf was first :)
15:54:35 <ihope_> (Am I being nitpicky?)
15:54:43 <ddarius> ihope_: No, you are correct.
15:54:44 <jfredett> in the fix \s -> 1 ++ "(" ++ s ++ ")" 
15:54:46 <shachaf> ihope_: At the end, of course!
15:54:48 <jfredett> right at the end
15:54:55 <ihope_> (Rather, un-fun?)
15:55:04 <mauke> 1 ++?
15:55:08 <shachaf> 1-0.99999999999999999999999999999999999... -- has a 1 at the very end.
15:55:19 <jfredett> err, "1", by bad
15:55:39 <ihope_> > fix (\s -> "(" ++ s ++ s ++ ")")
15:55:41 <lambdabot>  "(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((...
15:55:43 <mauke> shachaf: my computer says 0.99999999999999999999999999999999999 is actually 1
15:55:54 <shachaf> mauke: Who's talking about computers?
15:55:54 <jfredett> so does math
15:55:56 <ihope_> I say 0.999... is actually 1.
15:56:05 <jfredett> 0.999... = 1
15:56:06 <ddarius> mauke: You're computer is wise beyond its years.
15:56:10 <ihope_> In math, 0.99999999999999999999999999999999999 != 1.
15:56:19 <ihope_> 0.99999999999999999999999999999999999 terminates after about thirty places :-P
15:56:26 <jfredett> true that
15:56:29 <Olathe> Yeah, but what does math know ?
15:56:37 <mauke> hmm, 0.9999999999999999 is still 1
15:56:39 <shachaf> jfredett: It is /= 1 just as much as EvilTerran's version had closing parens.
15:56:40 <jfredett> Olathe: more than you or I
15:56:47 <Olathe> Oh.
15:56:53 <jfredett> shachaf: wha?
15:57:12 <shachaf> jfredett: 1 - 0.999... has a 1 at the "end".
15:57:19 <jfredett> no it doesnt.
15:57:23 <ihope_> Indeed. The difference between 0.999... and 1 is where repeat '(' ++ repeat ')' has closing parentheses.
15:57:24 <jfredett> by substitution
15:57:33 <shachaf> jfredett: Just like EvilTerran's fix had closing parens at the "end".
15:57:34 <ddarius> Actually, if we used the same coalgebraic approach, I believe 0.9... would not be the same as 1.0
15:57:40 <ihope_> Coalgebraic?
15:57:41 <jfredett> 0.999..., (the infinite sequence of nines)
15:57:45 <jfredett> is equal to 1
15:57:55 <mauke> > 1/3 + 1/3 + 1/3 :: Rational
15:57:57 <lambdabot>  1%1
15:58:02 <ihope_> What's the coalgebraic approach?
15:58:06 <jfredett> not the same. infinity is a tricky object
15:58:16 <jfredett> ihope_: a bat,
15:58:21 <puusorsa> infinitely tricky
15:58:22 <jfredett> oh- you said coalgebraic
15:58:24 <shachaf> jfredett: And repeat '(' ++ repeat ')' is not equal to repeat '('?
15:58:28 <jfredett> not nonalgebraic
15:58:46 <jfredett> what do you mean?
15:58:56 <ihope_> <ddarius> Actually, if we used the same coalgebraic approach, I believe 0.9... would not be the same as 1.0
15:59:03 <shachaf> jfredett: How are they different?
15:59:06 <ihope_> ddarius: what meant you?
15:59:10 <jfredett> the string generated is the same as fix \x -> "(" ++ x ++ ")"
15:59:30 <shachaf> jfredett: What, "syntax error"? :-)
15:59:34 <jfredett> obviously its not equal to the string fix \x -> "(" ++ x
15:59:42 <ddarius> ihope_: Which part are you questioning most, coalgebra in general or which coalgebraic approach or why they would be different?
15:59:42 <mux> > let inc = Endo (+1); inc2 = Endo (+2) in appEndo (mconcat [inc,inc2,inc,inc]) 3
15:59:43 <lambdabot>  8
15:59:46 <shachaf> > fix $ \x -> "(" ++ x ++ ")"
15:59:47 <lambdabot>  "(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((...
15:59:51 <shachaf> > fix $ \x -> "(" ++ x
15:59:52 <lambdabot>  "(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((...
15:59:57 <jfredett> but they aren't the same
15:59:59 <shachaf> jfredett: What's the difference?
16:00:03 <ihope_> ddarius: how the coalgebraic approach makes 0.999... not equal 1.
16:00:06 <jfredett> the former has )'s
16:00:09 <jfredett> the latter doesnt
16:00:13 <shachaf> jfredett: At the "end"?
16:00:21 <jfredett> actually, in the middle
16:00:22 <ihope_> Infinite strings do not have ends.
16:00:52 <ihope_> If you append one infinite string onto another, you get the first, because the second is never reached.
16:00:54 <jfredett> the former is _defined_ to have )'s the latter is not- thats not an issue of algebra.
16:01:04 <ddarius> ihope_: If we were to view numbers as an infinite sequence of digits, then [1,0...] is not bisimilar to [0,9...]
16:01:17 <jfredett> ihope_: no, you get the catenation of two infinite strings, which is infinite
16:01:22 <jfredett> you may only _see_ the first
16:01:26 <jfredett> but the second is still there
16:01:39 <ihope_> ddarius: indeed, 1.000... and 0.999... are different decimal expansions.
16:01:49 <shachaf> jfredett: And 1 - 0.999... is not _defined_ to be 0.000...1 (with a 1 at the end)?
16:02:03 <Olathe> The end ?
16:02:08 <SamB> shachaf: what end?
16:02:10 <shachaf> Olathe: Exactly. :-)
16:02:20 <shachaf> s/end/"end"/
16:02:21 <jfredett> shachaf: right, its proven to be 0.
16:02:36 <LoganCapaldo> jfredett, if I give you an infinite string s2, without my telling you is there any way for you to distinguish between s2 = s1 ++ ")" and s2 = s1 ?
16:02:48 <ihope_> jfredett: I guess it depends on whether you pay attention to more than just the constructors.
16:02:59 <jfredett> 0.999... is shown to be 1, so its not a matter of definition, like the string example
16:03:04 <jfredett> different bird entirely.
16:03:18 <jfredett> LoganCapaldo: sure, if i had an infinite amount of time
16:03:27 <mux> > let mul2 = Product 2; mul3 = Product 3 in getProduct (mconcat [mul2,mul3,mul2]) * 3
16:03:29 <lambdabot>  36
16:03:31 <LoganCapaldo> you sure it works like that?
16:03:38 * LoganCapaldo is asking in earnest
16:03:44 <LoganCapaldo> Cause I'm not
16:03:49 <SamB> jfredett: so what is last (cycle "ox")?
16:03:59 <jfredett> there isn't one
16:04:01 <jfredett> its infinite
16:04:14 <jfredett> but, the information is still there
16:04:19 <jfredett> its just not accessible
16:04:24 <ddarius> Not extensionally
16:04:37 <int-e> I think  fix (\x -> "(" ++ x ++ ")") leaks memory
16:04:48 <jfredett> well- who needs extensionality?
16:04:53 <ihope_> Meh, it just depends on whether you pay attention to more than the constructors when defining equality.
16:05:17 <ddarius> jfredett: We do because we can't access the definition of a value programmatically.
16:05:22 <ihope_> If you do, good for you. They're not the same. If you don't, good for you. They are.
16:05:32 <jfredett> right, so the problem is the computer, not the math
16:05:56 <jfredett> the math says that fix \x -> "(" ++ x ++ ")" is different than fix \x -> "(" ++ x
16:05:58 <shachaf> jfredett: "Programatically" -- that doesn't mean the computer, does it?
16:06:09 <jfredett> well, the problem is the program
16:06:18 <ddarius> A mathematical definition would be worse.  The most natural one, infinite lists being terminal coalgebra does lead them to being the same.
16:07:05 <jfredett> i'm not sure I'll buy that- My ZFC Set theory is rusty, but if I understand the AoC right, I should be able to choose the set containing the last symbol of either string
16:07:18 <ihope_> Um...
16:07:21 <jfredett> so therefore, I could choose to see the "end" of and "infinite" list
16:07:31 <ihope_> The axiom of choice doesn't say that infinite lists have ends.
16:07:52 <jfredett> it says I can choose any element of from a set to make a new set
16:07:54 <jfredett> IIRC
16:07:54 <ddarius> Which is to say, that set may be empty.
16:08:02 <SamB> jfredett: what the heck math says that?
16:08:06 <msouth> 1.0... and 0.9... are two distinct ways of pointing to the same location on the number line
16:08:09 <jfredett> some silly math
16:08:29 <jfredett> never liked AoC myself. or all of set theory for that matter
16:08:35 <ihope_> The axiom of choice says that for every set S, there is a function with domain S that returns an element of its input set.
16:08:38 <Olathe> There's not a problem with that.
16:08:45 <SamB> yeah.
16:08:47 <ihope_> Alternatively, it says that every set can be well-ordered.
16:08:51 <SamB> lists aren't sets!
16:08:52 <Olathe> It's just that you can't choose something that doesn't exist.
16:09:01 <ddarius> Alternatively, every epi is split.
16:09:10 <jfredett> I don't pretend to be an authority on this stuff, but it's hard for me to believe that those two strings are equal
16:09:22 <Olathe> You can't say that a nonexistent thing is part of a list somehow and then choose it.
16:09:23 <ddarius> jfredett: As coalgebras, they are.
16:09:39 <jfredett> right- and for all practical purposes, they are
16:09:44 <jfredett> but the definitions are different
16:09:46 <Olathe> You need to have a definition of string.
16:09:51 <jfredett> and when definitions are different,
16:09:59 <ihope_> jfredett: are you having trouble believing that there's some reasonable way of calling them equal?
16:10:01 <jfredett> I have a hard time believing they're the same object
16:10:13 <SamB> jfredett: it doesn't necessarily mean a thing when definitions are different
16:10:16 <jfredett> ihope_: FSV of equal, I'd call anything equal
16:10:16 <ihope_> That's as far as you need to go.
16:10:21 <SamB> > let x = 1 + 1 in x
16:10:22 <lambdabot>  2
16:10:25 <ihope_> jfredett: "FSV"?
16:10:27 <SamB> > let x = 3 - 1 in x
16:10:28 <ddarius> jfredett: I can give two different definitions of the same thing (the number one say), would you then say 1/=1?
16:10:29 <lambdabot>  2
16:10:29 <jfredett> for some value
16:10:43 <ihope_> jfredett: yes, but I did say "reasonable".
16:10:50 <DRMacIver> This seems like a very odd conversation.
16:11:03 <jfredett> ddarius: SamB: the problem is that the definitions are too close- my brain doesn't want to separate them
16:11:03 <LoganCapaldo> DRMacIver, I like it :)
16:11:05 <ihope_> "foo" and "bar" are what I'd call "obviously different".
16:11:05 <Olathe> I think it's a very even conversation.
16:11:11 <Philippa_> ddarius: 1 /= 1 for differing values of 1?
16:11:19 <jfredett> as you could with 1+1 == 3-1
16:11:36 <ihope_> repeat "a" isn't "obviously the same as" repeat "a" ++ repeat "b" to me, nor are they "obviously different".
16:11:49 <jfredett> ihope_: that I'll but
16:11:50 <jfredett> buy*
16:12:01 <jfredett> i mean, for all practical purposes, they're the same
16:12:03 <ihope_> That's all you need to buy, really. The rest is up to definition.
16:12:08 <SamB> I still want to know what last (cycle "xo") is ;-)
16:12:12 <int-e> ihope_: hmm but if you look at the second element of these lists you'll see that they're different. you can observe the difference easily.
16:12:17 <ddarius> Philippa_: I could pull it off in Haskell, but for differing definitions of 1.
16:12:21 <jfredett> you could *never* access the repeat b part
16:12:26 <shachaf> SamB: Wait, (cycle "ox") or (cycle "xo")? :-)
16:12:31 <ihope_> For some reasonable definitions of equality, they're different.
16:12:34 <int-e> ihope_: sorry
16:12:38 <SamB> shachaf: well, I don't care which you find
16:12:38 <DRMacIver> Well, in Haskell, the two lists are not equal anyway.
16:12:41 <ddarius> jfredett: What's an impractical purpose for which they are different?
16:12:49 <DRMacIver> And also [1..] /= [1..]
16:13:04 <int-e> ihope_: don't know why but I missed a 'repeat'.
16:13:09 <DRMacIver> But you've probably covered this point. :)
16:13:13 <SamB> if you find the answer to one, I can convert it to the answer to the other one just by switching 'o' and 'x' in the answer
16:13:17 <ddarius> Yes, they may be different under pointer equality (or maybe not).
16:13:18 <ihope_> Indeed, within Haskell, repeat "a" and repeat "a" ++ repeat "b" can't be compared to be different.
16:13:19 <shachaf> SamB: Well, for the first it's 'o', for the second it's 'x'. Obviously. :-)
16:13:27 <jfredett> ddarius: mine? :P
16:14:05 <LoganCapaldo> last (cycle "ox") == ['o', 'x'] -- hooray non-determinism! :)
16:14:19 <ihope_> LoganCapaldo: you mean "lasts"? :-)
16:14:27 <ddarius> LoganCapaldo: Oh?  Not ['x','o']
16:14:36 <ihope_> Hmph.
16:14:48 <ihope_> lasts (cycle "ox") = {'o', 'x'}
16:14:59 <int-e> LoganCapaldo: please provide a proof that these are the only possibilities ;)
16:15:00 <ihope_> Now give Haskell an unordered set datatype.
16:15:01 <LoganCapaldo> ddarius, it doesn't matter, it's a set that just happens to be written as a list since we can't have Monad Set :)
16:15:47 <ihope_> @hoogle queue
16:15:48 <lambdabot> Data.Graph.Inductive.Internal.Queue :: module
16:15:48 <lambdabot> Data.Queue :: module
16:15:48 <lambdabot> Data.Queue.Queue :: data Queue a
16:16:02 <ihope_> @docs Data.Queue
16:16:02 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Queue.html
16:16:06 <ddarius> LoganCapaldo: But nevertheless, a set is not a list.
16:16:19 <LoganCapaldo> ddarius, nevertheless it was a joke :)
16:17:02 <ddarius> ihope_: Look at the work on quotient types using containers by Thorsten Altenkirch and co.
16:17:23 <|Steve|> A set is an ADT. A cons list is one possible implementation, not a very good one.
16:17:48 <ddarius> |Steve|: As I mentioned on LtU recently, sorted lists do make a decent set implementation.
16:17:54 <jfredett> A set is not a list. a multiset is a kind of list
16:18:00 <ddarius> A multiset is a bag.
16:18:03 <jfredett> a set is different
16:18:05 <|Steve|> LtU?
16:18:07 <jfredett> multiset == bag
16:18:10 <jfredett> different names
16:18:11 <jfredett> same thing
16:18:12 <ddarius> www.lambda-the-ultimate.org
16:18:26 <jfredett> i like multiset better.
16:18:47 <LoganCapaldo> I like unibag
16:18:49 <jfredett> set has no repeated elements, a list can have repeated elements.
16:18:54 <DRMacIver> ddarius: Hm. How? Sounds like it would have nasty inefficiencies.
16:18:55 <ddarius> A multiset is a list where the order does not matter, a set is a multiset where the multiplicity does not matter.
16:19:01 <|Steve|> A sorted list would work fine, you can binary search it. Typically hashtables and binary search trees (like red black trees) make better sets.
16:19:21 <jfredett> i dunno
16:19:26 <jfredett> my brain hurts
16:19:27 <DRMacIver> Binary searching is much easier if you have random access. :)
16:19:28 <LoganCapaldo> it's pretty hard to efficient binary search a cons list I think. I could be wrong
16:19:38 <|Steve|> You're not.
16:19:52 <|Steve|> O(n) lookup for a set isn't reasonable.
16:20:15 <ihope_> type Set a = a -> Bool
16:20:32 * ihope_ bows
16:20:35 <LoganCapaldo> Mmm ihope_ for the win
16:20:37 <DRMacIver> ihope_: It's always tempting, but it has a number of problems. :)
16:20:56 <LoganCapaldo> Is it constant time? Is it log n? Is it exponentional? We'll never know! :)
16:21:04 <|Steve|> How does one deal with large data structures in Haskell?
16:21:06 <ihope_> data Set a = Set (a -> Bool) (Set a -> Bool) -- the second one is equality
16:21:08 <ihope_> :-P
16:21:35 <int-e> |Steve|: buy more memory ;)
16:21:53 <|Steve|> I meant in terms of changing the structure, adding or removing elements.
16:22:02 <ihope_> Okay, now. Say a world is a collection of agents. An agent is a thing that can be invoked. When it is invoked, it can modify the world however it likes.
16:22:14 <|Steve|> Haskell doesn't have any sort of adopt/focus constructs, does it?
16:22:25 <jcreigh> what are adopt/focus constructs?
16:22:30 <DRMacIver> |Steve|: There are good purely functional datastructures which let you do a lot of datasharing, so you typically only change O(log(n)) with each update operation.
16:22:31 <int-e> |Steve|: well, Data.Map is a tree for example.
16:22:51 * LoganCapaldo is expecting someone to use the Z-word any minute
16:22:53 <ihope_> How do you let agents communicate?
16:22:59 <ihope_> LoganCapaldo: zipper?
16:23:10 <Philippa_> hmm. Talking of LtU, I wonder if Peter McArthur's in here?
16:23:19 <LoganCapaldo> ihope_, shh! I'm trying not to commit to answer! ;)
16:23:28 <jcreigh> ooh, clever.
16:23:30 <|Steve|> Hmm, DRMacIver what about structures with amortized constant time operations like hashtables?
16:23:35 <ddarius> Philippa_: And speaking of that, I would be interested in slides or what have you from your talk.
16:24:16 <Philippa_> ddarius: I'll make sure to release them - assuming I get them done at all! If everyone's unlucky they'll get stuck with just the sight of me cribbing off my PDA...
16:24:22 <jcreigh> |Steve|: well, Data.HashTable is in IO, I believe.
16:24:32 <int-e> |Steve|: you can use them in the IO or ST monad. destructive updates are sort of impure (although linear types offer a different solution)
16:24:49 <DRMacIver> |Steve|: For updates, not really as far as I know. You can access arrays monadically and then have them be pure after the monadic update. Finger trees (Data.Sequence) have amortized constant time append at both ends, but not insert.
16:24:58 <|Steve|> Oh to answer adoption/focus were ways of making nonlinear types linear and vice versa, sort of.
16:25:03 <int-e> (but linear types aren't implemented for Haskell afaik)
16:25:18 <DRMacIver> Eep, late.
16:25:21 <DRMacIver> I'm off to bed,
16:25:22 <|Steve|> You could have nonlinear elements of linear structures and linear elements of nonlinear structures. I read a few papers about it.
16:25:28 <jcreigh> ah, sorry, but: What's a linear type?
16:25:38 <|Steve|> One that is used exactly one time.
16:26:01 <mauke> think RealWorld
16:26:11 <|Steve|> int-e: Right, destructive updates are impure, so how does one do it in Haskell?
16:26:20 <|Steve|> How does being in the IO or ST monad change anything?
16:26:38 <LoganCapaldo> IORefs and STRefs let you have destructive updates
16:26:39 <int-e> |Steve|: sort of like thaw and freeze for arrays? (thaw = create a mutable copy of an array to be used within a monad. freeze = create an immutable copy of the array to be used in pure code)
16:27:14 <shachaf> |Steve|: "Linear types" is how Clean does things, right?
16:27:15 <int-e> |Steve|: you have destructive updates in the ST and IO monads. ST code can be executed from pure functions.
16:27:29 <|Steve|> From what I've seen monads aren't anything special. They're just a type class as far as I can tell.
16:27:42 <jcreigh> |Steve|: yeah. Plus the do-notation sugar.
16:27:47 <int-e> |Steve|: yes but the IO and ST monads *are* special
16:27:47 <|Steve|> Right.
16:27:48 <ddarius> |Steve|: ST and IO are the special things in this case.
16:27:58 <|Steve|> Ah, so Haskell lies, it isn't really pure.
16:28:06 <|Steve|> I'm not sure about Clean.
16:28:10 <ddarius> |Steve|: It does, but not (too much) about that.
16:28:20 <int-e> |Steve|: well, lies - the interface is pure.
16:28:28 <shachaf> |Steve|: Have you done any IO in Haskell?
16:28:39 <LoganCapaldo> and there are ways you can imagine ST being implemented to make it pure
16:28:41 <|Steve|> Just the stuff in yaht.
16:28:48 <LoganCapaldo> (not that it's actually implemented like that)
16:28:50 <Philippa_> |Steve|: it's certainly possible to give ST a pure semantics, and depending on how picky you are the same can be said for IO
16:28:54 <ddarius> LoganCapaldo: Using unsafeCoerce...
16:29:03 <int-e> |Steve|: an absolutely pure language wouldn't allow any interesting programs; you could, with some luck, distinguish terminating from nonterminating programs. and no more.
16:29:27 <int-e> oh right. you could implement ST inefficiently but in a pure way.
16:29:31 <ddarius> Bah non-termination is an effect.  Let's get rid of that.  Then you can write interesting things.
16:29:33 <LoganCapaldo> ddarius, well now haskell is telling the truth about purity but lying abotu type safety? :)
16:30:02 <|Steve|> int-e: I thought that's what it was doing (inefficient), I had no idea it was special.
16:30:36 <|Steve|> So the charge that monads are "just a way to have side effects" is somewhat accurate.
16:30:57 <LoganCapaldo> I dunno about the "just" in that sentence
16:30:58 <kilimanjaro> monads are a way to structure code
16:30:59 <int-e> |Steve|: well that's only part of the truth. they have other uses.
16:31:07 <ddarius> No, they are not "just" that.  Further they encapsulate them.
16:31:08 <|Steve|> Hence the "somewhat."
16:31:31 <int-e> |Steve|: really monads are just a way to arrange actions sequentially (for whatever notion of 'sequential' is appropriate for a given monad)
16:31:35 <kilimanjaro> There is a compelling reason to use monads even in completely pure situations, just because they provide a mechanism for modularising change
16:31:43 <ddarius> |Steve|: Monads have been used in languages supporting side-effects.
16:32:01 <Philippa_> then there's using monad transformers to play semantic lego...
16:32:05 <|Steve|> No doubt they have other uses.
16:32:20 <jfredett> is optimus prime a monad transformer?
16:32:29 <ddarius> (We won't even go into mathematics...)
16:32:38 <jcreigh> @remember jfredett is optimus prime a monad transformer?
16:32:38 <lambdabot> Done.
16:32:42 <|Steve|> I wrote some haskell that could likely have benefited from understand and using monads. But I didn't so I had to thread my state through all of my calculations.
16:32:42 <jfredett> lol
16:32:52 <LoganCapaldo> He's an autotransformer. He transforms himself not monads
16:33:04 <|Steve|> Why won't we go into mathematics?
16:33:09 <int-e> |Steve|: yes, the State monad could probably help you with that.
16:33:34 <LoganCapaldo> random thought: I imagine that there are monad transformers that are also monads
16:33:46 <|Steve|> Well, the project is done. My conclusions: From the point of view of primality testing, PRNGs are good enough, even horrible ones.
16:33:49 <ddarius> |Steve|: Because you probably don't care how monads are used in universal algebra, logic, topology, lattice theory and so forth.
16:34:02 <Philippa_> |Steve|: because most of us're functional programmers and logicians-in-FP-drag rather than mathematicians, and there're monads all over maths
16:34:15 <|Steve|> ddarius: You'd be wrong. Which sort of lattice theory? Point lattices or posets?
16:34:27 <ddarius> LoganCapaldo: Possibly, but I very much doubt in the way you intend.
16:34:31 <|Steve|> They were never covered in my intro to CT.
16:34:40 <ddarius> |Steve|: I meant posets.
16:34:46 <|Steve|> Ah, less interested in posets.
16:34:51 <LoganCapaldo> ddarius, well i was thinking in "bizzaro math way, that I don't know how it would look"
16:34:58 <|Steve|> But logic sounds fine.
16:35:19 <ddarius> |Steve|: Posets are actually rather relevant to computer science.  Actually all of those were.
16:35:37 <shachaf> Has anyone written any monad transformer transformers? I think somebody may have mentioned them when xmonad was considering using a UserT.
16:35:59 <ddarius> Just what we need, 4-category theory applied to Haskell.
16:36:09 <int-e> shachaf: hmm? what would they do? monad transformers are already stackable
16:36:16 <|Steve|> ddarius: Indeed. They were used in PL and compilers quite a bit. But that's not my area of CS. Point lattices are.
16:37:06 <shachaf> int-e: Well, they wanted to have type X = SomethingT (OtherT (StateT s (UserT IO))), where you define your own transformer.
16:37:14 <kilimanjaro> Is that even really an area of CS? Are you not just some math guy in disguise?
16:37:27 <shachaf> int-e: To let you keep your own state, as well as do some other things.
16:37:29 <int-e> shachaf: so define type X a = SomethingT (OtherT  (StateT s (UserT IO)))
16:37:36 <|Steve|> kilimanjaro: Yeah it falls under theory.
16:37:40 <int-e> shachaf: so define type X a = SomethingT (OtherT  (StateT s (UserT a)))
16:37:49 <|Steve|> And yes, I am a mathematician in disguise. Not a very good one, but I'm trying.
16:37:51 * LoganCapaldo after googling
16:38:06 <LoganCapaldo> Looks like point lattices would be applicable to bitmap displays for one thing
16:38:07 <kilimanjaro> |Steve|, is it for cryptography? What do you actually care about lattices for? Just curious, I'm naive when it comes to that sort of stuff
16:38:08 <int-e> shachaf: or rather, newtype that. then you can make it an instance of MonadTrans
16:38:25 <ddarius> It would have applications to cryptography.
16:38:30 <|Steve|> kilimanjaro: Lattices do have uses in crypto. I like the more complexity theoretic aspects.
16:38:46 <shachaf> int-e: Yes, it was a newtype. Hmm, and would that be enough?
16:38:56 <int-e> shachaf: hmm. ok, again: newtype X m a = SomethingT (OtherT (m a))
16:38:59 <|Steve|> Still, I was reading a paper about ideal lattices which was very algebraic on Thursday (the last time I was in my office).
16:39:14 <int-e> shachaf: X m is a monad, X is a monad transformer.
16:40:03 <int-e> shachaf: assuming you provide the corresponding class instances. deriving Monad  should just work; you'll have to define the monadtrans instance yourself.
16:40:23 <ddarius> The first thing that comes to my mind when seeing point lattices is modular forms.
16:40:28 <shachaf> int-e: And if you wanted UserT to be both StateT and ReaderT, how would you do that?
16:40:57 <shachaf> int-e: You'd make m be UserMonad, where it's normally IO but the user can wrap it?
16:41:34 <shachaf> int-e: No, that doesn't make sense.
16:41:53 <int-e> shachaf: I'd guess a typical signature would then be   doSomething :: (MonadIO m) => X m Bool
16:42:17 <ekidd> Good evening!
16:42:17 <lambdabot> ekidd: You have 1 new message. '/msg lambdabot @messages' to read it.
16:42:40 <zeeeee> i can't figure out which standard library function(s) to call to just do some regex substitutions...any hints?
16:42:48 <shachaf> int-e: That seems like it overcomplicates things when you want to use the monad.
16:43:01 <LoganCapaldo> @docs Text.Regex
16:43:01 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Text-Regex.html
16:43:15 <LoganCapaldo> err
16:43:34 <zeeeee> LopanCapaldo: i only found =~ in Text.Regex.Posix.Wrap, but that's for matching
16:43:42 <int-e> shachaf: well, but that's caused by turning a simple monad into a monad transformer.
16:43:56 <zeeeee> LoganCapaldo: also that's been moved to regex-base
16:44:08 <shachaf> int-e: Yes, but why would you want that?
16:44:14 <LoganCapaldo> http://www.haskell.org/ghc/docs/latest/html/libraries/regex-compat/Text-Regex.html
16:44:16 <lambdabot> http://tinyurl.com/2ub2m7
16:44:26 <LoganCapaldo> I think you want subRegex
16:44:29 <int-e> shachaf: but the point is: composing several transformers on top of each other and creating a new transformer that way is already possible; you don't need monad transformer transformers for that.
16:44:30 <shachaf> int-e: (I can see why you want it, but wouldn't using monad transformer transformers make it simpler?)
16:45:16 <int-e> shachaf: (btw, I still don't know what monad transformer transformers would actually be)
16:45:59 <ekidd> Things which can only be said on #haskell, part 1. shachaf: "wouldn't using monad transformer transformers make it simpler?" :-)
16:46:31 <ddarius> ekidd: Nah.  That's got to be at least in the teens.
16:46:33 <shachaf> ekidd: I mean, for the user of the monad, not for the implementor. :-)
16:47:00 <mauke> @quote
16:47:01 <lambdabot> spj says: it looks like hopscotch! (referring to a funny notation for lists)
16:47:20 <zeeeee> LoganCapaldo: thanks. i was looking in the wrong place (regex-base). there's a bewildering amount of regex libraries available
16:47:40 <shachaf> int-e: Well, you'd have IdentityT, and then you'd add more: (StateTT s IdentityT) IO would be similar to StateT s IO.
16:47:48 <shachaf> int-e: Would that not work?
16:47:59 <ddarius> We can't win.  ("You don't have any libraries" "There're a bewildering amount of libraries")
16:50:31 <zeeeee> ddarius: yes you can; a good start would be in the docs
16:51:24 <int-e> shachaf: while it's currently StateT s (IdentityT IO a)  where a is the type argument that you left out. I'm not sure if that works (there are problems with partial applications of type synomyms IIRC), I also don't see much of a simplification.
16:51:46 <jcreigh> zeeeee: http://www.serpentine.com/blog/2007/02/27/a-haskell-regular-expression-tutorial/
16:51:48 <lambdabot> Title: teideal glic deisbhéalach  Blog Archive  A Haskell regular expression tutoria ..., http://tinyurl.com/2xtgpw
16:52:13 <int-e> shachaf: but feel free to try and prove me wrong :)
16:52:29 <shachaf> int-e: The point is that your functions would end up looking like :: IO ().
16:52:35 <shachaf> int-e: Wouldn't they?
16:53:20 <jcreigh> zeeeee: (however, I don't know of an easy way to do a replace in the standard lib...)
16:53:41 <zeeeee> jcreigh: already saw that. no mention of substitution/replacement, only a comment that said "lack of a regex replace in the new API" which only adds to the confusion
16:53:56 <shachaf> jcreigh: Maybe you know more about this?
16:54:08 <jcreigh> shachaf: or maybe I don't. :)
16:54:12 <shachaf> jcreigh: Were you part of that discussion? I only saw potions of it.
16:54:21 * shachaf quaffs discussion.
16:54:47 <shachaf> (s/potions/portions/, of course.)
16:55:22 <jcreigh> Don't drink the blue ones; They always hurt you in "Prince of Persia"
16:55:54 <Cale> zeeeee: you can use (String, String, String) as your match type, which gives you the text before, the matched part, and the text after the match
16:56:10 <LoganCapaldo> and then you recurse
16:56:17 <LoganCapaldo> and then you recurse recurse
16:56:39 <glguy> ?jargon recursion
16:56:40 <lambdabot> *** "recursion" jargon "Jargon File (4.3.1, 29 Jun 2001)"
16:56:40 <lambdabot> recursion n. See {recursion}. See also {tail recursion}.
16:56:40 <lambdabot>  
16:56:47 <Cale> zeeeee: If you need to use the subgroups to determine what to replace with, use the type (String, String, String, [String]) which will give you a list of all the subgroups matched as well.
16:58:54 <Cale> I wonder if the regex lib is available in lambdabot...
16:59:08 <Cale> "bar" =~ "(foo|bar)" :: String
16:59:12 <Cale> > "bar" =~ "(foo|bar)" :: String
16:59:16 <lambdabot>   Not in scope: `=~'
16:59:29 <zeeeee> Cale: are you talking about the =~ functions?
16:59:31 <Cale> yes
16:59:35 <zeeeee> (i'm exploring as much as i can/anticipating libs before next weekend :)
17:03:10 <int-e> shachaf: Hmm. You'd still have to lift IO actions into your monad to use them wouldn't you? So I expect the difference in amount of code between a monad transformer (used on a user provided monad) and a monad transfromer transformer (used with a user provided transformer which is applied to the IO monad) to be small.
17:04:34 <shachaf> int-e: But a function that doesn't use any part of the transformer (say, refresh :: IO ()) wouldn't need any extra, would it?
17:05:59 <shachaf> int-e: That is, functions that use a part of UserT would have to, say, add (MonadIO m) =>, but functions that don't (part of the regular code, that assumes IdentityT) wouldn't.
17:06:04 <shachaf> int-e: Or would they?
17:09:42 <int-e> shachaf: hmm. this is all too vague. I'd like to stop here unless there's a concrete code example to discuss.
17:13:32 <shachaf> int-e: Probably, yes. :-)
17:13:37 <shachaf> int-e: I was just wondering.
17:14:06 * shachaf probably has no idea what he's talk about. :-)
17:14:10 <shachaf> s/k/king/
17:46:13 <ddarius> There you go Philippa
17:46:36 <Philippa_> ?
17:46:40 <Philippa_> ah
17:46:47 <PeterMc> Hi there, Philippa.
17:46:55 <Philippa_> hi
17:47:46 <PeterMc> Had much response to the lambda-the-ultimate announcement?  (Apart from me wondering about Haskell vs. Asperger's Syndrome, that is.)
17:48:03 <dolio> This Hugh Perkins fellow is quite something.
17:48:24 <Philippa_> it's tricky to know what's specifically in response to the LtU announcement rather than other ones - nothing else on the site itself
17:48:35 <dons> dolio: :/
17:49:05 <PeterMc> Scary, innit!
17:49:19 <PeterMc> Trying to organise something, I mean.
17:50:12 <dolio> I wonder what SuperO does for a high level prime sieve.
17:50:23 <Philippa_> heh, yeah. ndm's been a big help though, and thankfully the 'established' tradition is such that doing everything ad-hoc and at the last minute^W^W^W^Won demand is what's expected
17:54:18 <dolio> If 'print . length . words =<< getContents' can beat C, maybe a lazy list prime sieve can beat a C# loop. :)
17:58:06 <EvilTerran> probably not a list as such. the O(n) lookup complexity would sting.
17:59:55 <dolio> Well, I haven't looked at what they're doing with it closely, but I think they're traversing it once to see how many primes are below a certain value...
17:59:56 * EvilTerran was thinking about a lazy data structure of the form 'array (0,1) ... : [array (2^i,2^(i+1)) ... | i <- [0..]]' a while ago. that might suit itself to that sort of thing.
18:00:04 <ddarius> EvilTerran: But you don't "lookup" stuff in that case.
18:00:09 <dolio> So the O(n) may be moot.
18:00:26 <EvilTerran> hm. i don't know what algorithm you're thinking of exactly, so i can't say.
18:01:03 <EvilTerran> (that thing i just mentioned needs a '-1' inserted somewhere, and probably arranged a bit differently at the start, but you get the idea)
18:03:01 <hpaste>  int-e pasted "something like this? (for EvilTerran)" at http://hpaste.org/1701
18:03:40 <int-e> (this uses exactly such a data structure to memoize a recursive function on natural numbers)
18:04:37 <EvilTerran> looks about right. am i right in thinking that yields O(log n) lookup time?
18:04:44 <int-e> yep
18:04:56 <EvilTerran> spiffing
18:05:09 <|Steve|> There was an efnet math problem posed a while back about finding a function f such that for all natural number f(f(n)) = h(n) where h(n) was something like n^2 - 19n + 99. Is there anyway to speed this up, it gets extremely slow: http://pahtak.org/~steve/f.hs
18:05:59 <|Steve|> Oh, g is the function, not h. and I got it right.
18:08:26 <dolio> I can't seem to connect...
18:08:40 <|Steve|> Oh, yeah, bit torrent is killing my connection.
18:08:44 <|Steve|> I'll paste on hpaste.
18:08:48 <dolio> :)
18:09:42 <PeterMc> I can't get through to pahtak.org either.
18:09:55 <int-e> I could but it took ages :)
18:10:11 <|Steve|> _Something_ just really hates bit torrent. It's either my router or my ISP.
18:10:23 <|Steve|> I pasted on hpaste, we'll see if it times out or not.
18:10:58 <shachaf> |Steve|: (By the way, you can use "case comparse x y of LT -> ...; EQ -> ...; GT -> ..." instead of comparing up to three times.)
18:11:40 <ddarius> where comparse = compare
18:11:43 <|Steve|> Good point. I wrote this some time ago. I only learned about case recently.
18:11:53 <shachaf> ddarius: Uh, yes. :-)
18:12:15 <shachaf> |Steve|: The important thing is compare, not case.
18:12:33 <campusblo> hi is there a function that will tell you the position of an element in a list ?
18:12:45 <shachaf> |Steve|: You can always say "f (compare x y) where f EQ = ...;..."
18:12:47 <|Steve|> I don't think the numbers are getting large enough that doing the comparison is actually a bottleneck.
18:12:59 <campusblo> eg positionNum 6 [1,2,3,6,7] = 4
18:13:03 <ddarius> Bah, where is ordering :: Ord a => a -> a -> b -> b -> b
18:13:13 <TSC> campusblo: elemIndex
18:13:32 <TSC> > elemIndex 'e' "hello"
18:13:33 <shachaf> |Steve|: (Which is why I only said this incidentally, in parentheses.)
18:13:34 <lambdabot>  Just 1
18:13:34 <|Steve|> Heh, timed out.
18:13:35 <hpaste>  Steve pasted "f.f = g" at http://hpaste.org/1702
18:13:38 <campusblo> in the prelude?
18:13:41 <|Steve|> There we go.
18:13:41 <PeterMc> The download from pahtak.org worked this time.
18:13:45 <PeterMc> Now what?
18:13:48 <shachaf> campusblo: In Data.List.
18:14:02 <campusblo> ok thanks
18:14:03 <shachaf> campusblo: Why would you need it to be in the Prelude?
18:14:10 <|Steve|> Meh, it might get pasted twice.
18:14:23 <campusblo> i just wanted to know where it was. 
18:14:35 <ddarius> @index elemIndex
18:14:35 <lambdabot> Data.List
18:14:59 <shachaf> @hoogle a -> [a] -> Int
18:14:59 <lambdabot> No matches, try a more general search
18:15:02 <shachaf> @hoogle a -> [a] -> b
18:15:03 <lambdabot> Prelude.foldl :: (a -> b -> a) -> a -> [b] -> a
18:15:03 <lambdabot> Prelude.foldr :: (a -> b -> b) -> b -> [a] -> b
18:15:03 <lambdabot> Data.List.foldl' :: (a -> b -> a) -> a -> [b] -> a
18:15:09 <ddarius> @hoogle elemIndex
18:15:09 <lambdabot> List.elemIndex :: Eq => a -> [a] -> Maybe Int
18:15:09 <lambdabot> Data.List.elemIndex :: Eq a => a -> [a] -> Maybe Int
18:15:21 <campusblo> how would i import that into a file im working on?
18:15:29 <ddarius> import Data.List
18:15:32 <shachaf> campusblo: "import Data.List".
18:15:58 <ddarius> Haskell and it's cryptic naming... </prick>
18:16:09 <campusblo> so ill just copy that and put it at the top of the file
18:18:08 <campusblo> ddarius why do i get the word "just" when i use that elemIndex function? 
18:18:19 <campusblo> i can't use that
18:18:26 <campusblo> the just i mean
18:18:29 <shachaf> campusblo: What if the element isn't in the list?
18:18:31 <ddarius> > elemIndex 3 [1,2]
18:18:31 <|Steve|> > elemIndex 5 [1,2,7,9]
18:18:33 <lambdabot>  Nothing
18:18:34 <lambdabot>  Nothing
18:18:36 <shachaf> > elemIndex [5] [1,2,3,4]
18:18:37 <lambdabot>   add an instance declaration for (Num [t])
18:18:37 <lambdabot>     In the expression: 4
18:18:40 <shachaf> > elemIndex 5 [1,2,3,4]
18:18:41 <lambdabot>  Nothing
18:18:43 <|Steve|> > elemIndex 7 [1,2,7,9]
18:18:45 <lambdabot>  Just 2
18:18:59 <|Steve|> It's the Maybe datatype.
18:19:13 <|Steve|> data Maybe a = Nothing | Just a -- Something like that.
18:19:31 <campusblo> ok 
18:19:35 <shachaf> |Steve|: Just like that. :-)
18:19:41 <campusblo> @paste
18:19:41 <lambdabot> Haskell pastebin: http://hpaste.org/new
18:20:01 <|Steve|> Whee.
18:20:19 <shachaf> @instances Ord
18:20:20 <lambdabot> (), All, Any, Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, Product a, Sum a, [a]
18:20:34 <EvilTerran> > () >= ()
18:20:36 <lambdabot>  True
18:20:37 <EvilTerran> heh
18:20:43 <|Steve|> @instances Monad
18:20:45 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
18:20:51 <ddarius> @src () compare
18:20:52 <lambdabot> compare () () = EQ
18:21:14 <shachaf> > Nothing `compare` Just 5
18:21:16 <lambdabot>  LT
18:21:22 <shachaf> > Just 3 `compare` Just 5
18:21:23 <lambdabot>  LT
18:21:43 <|Steve|> Nothing is less than Just 5?
18:21:54 <shachaf> @src Maybe compare
18:21:54 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
18:22:04 <ddarius> It's derived.
18:22:10 <TSC> Nothing is probably the minimum for all Maybe types
18:22:19 <|Steve|> Odd.
18:22:20 <dolio> > Nothing < Just undefined
18:22:22 <lambdabot>  True
18:22:27 <hpaste>  campusblo pasted "aaaarrgggggh" at http://hpaste.org/1703
18:22:37 <campusblo> so what's wrong with that?
18:22:41 <campusblo> why do i get that error?
18:22:51 <ddarius> > [Nothing..] :: Maybe Int
18:22:52 <lambdabot>  Parse error
18:22:53 <ihope_> > Just undefined < Just undefined
18:22:54 <lambdabot>  Undefined
18:22:55 <ddarius> > [Nothing ..] :: Maybe Int
18:22:56 <lambdabot>  Couldn't match expected type `Maybe Int'
18:23:05 <ddarius> > [Nothing ..] :: [Maybe Int]
18:23:06 <lambdabot>   add an instance declaration for (Enum (Maybe Int))
18:23:06 <lambdabot>     In the expression: [...
18:23:09 <ddarius> Darn
18:23:24 <ihope_> > [minBound..] :: [Int]
18:23:25 <lambdabot>  [-2147483648,-2147483647,-2147483646,-2147483645,-2147483644,-2147483643,-21...
18:23:29 <dolio> > minBound :: Maybe Int
18:23:30 <lambdabot>   add an instance declaration for (Bounded (Maybe Int))
18:23:30 <lambdabot>     In the expression...
18:23:54 <ihope_> When can you derive Enum?
18:24:01 <Cale> campusblo: postitonNum
18:24:13 <campusblo> oh
18:24:16 <campusblo> lol
18:24:17 <campusblo> ok
18:24:25 <campusblo> im tired
18:25:20 <campusblo> i thought i was going crazy. nevermind me
18:26:01 <Cale> positionNum x = maybe 0 (+1) . elemIndex x
18:26:12 <|Steve|> Does haskell guarantee tail recursion like scheme does?
18:26:22 <TSC> campusblo: Compiling with warnings on would help to find errors like that
18:26:47 <SamB> |Steve|: not that I know of
18:26:51 <Cale> |Steve|: I don't think the Haskell standard says anything at all about evaluation.
18:26:54 <SamB> but it would be stupid not to implement it
18:27:23 <|Steve|> So an conforming implementation could stack overflow on a simple read-eval-print loop?
18:27:33 <campusblo> TSC im in hugs
18:27:42 <geezusfreeek> |Steve|: i'm pretty sure that writing a tail recursive function can still help you to avoid a space leak in most cases
18:27:45 <TSC> Hugs doesn't have warnings?
18:27:58 <campusblo> and the good news is im done a project im working on
18:28:00 <campusblo> yay!
18:28:03 <SamB> TSC: hugs doesn't compile ;-)
18:28:26 <campusblo> well more or less done
18:28:58 <SamB> |Steve|: it would be shunned
18:29:42 <SamB> they don't write "don't be stupid" anywhere in the report either, you know ;-)
18:30:13 <|Steve|> geezusfreeek: Well, what if you did something like: main = do { line <- getLine; if line == "" then return () else do {putStrLn line; main } }
18:30:39 <|Steve|> And it did that as function calls?
18:30:53 <SamB_XP> |Steve|: no big deal
18:31:05 <Cale> |Steve|: Well, strictly speaking, I think all stack overflows sort of violate the semantics of the language already.
18:31:37 <geezusfreeek> i'm pretty sure most implementations would garbage collect most of the old trash there
18:31:39 <Cale> After all, they sort of make values into _|_ which shouldn't be _|_.
18:31:40 <ddarius> As does running out of memory...
18:31:45 <Cale> right
18:31:59 <|Steve|> geezusfreeek: There is no garbage, it's all on the stack if it's doing function calls.
18:32:19 <ddarius> |Steve|: Not true at all.
18:32:27 <ddarius> Necessarily.
18:32:31 <geezusfreeek> are thunks done on the stack? (i don't know much about haskell implementations)
18:32:32 <SamB_XP> |Steve|: the Haskell standard, like the C standard, does not say anything about this matter
18:32:46 <SamB_XP> ... that doesn't stop a good C compiler either...
18:32:47 <|Steve|> The scheme standard does.
18:33:00 <|Steve|> But in C, I can write a loop. I can't in haskell.
18:33:04 <Cale> |Steve|: The Haskell standard doesn't say anything about the order of evaluation, or how an evaluator might even work. It just says what programs mean.
18:33:14 <|Steve|> I _have_ to use recursion.
18:33:20 <SamB_XP> C doesn't have a stack any more than Haskell has
18:33:30 <ddarius> |Steve|: You can safely assume that all implementations do tail call optimization.
18:33:32 <SamB_XP> anyway, as I said, we would *shun* any implementation that got it wrong
18:33:34 <Cale> |Steve|: It's safe to use recursion, because any *sane* implementation will do tail recursion optimisation.
18:33:44 <|Steve|> Okay.
18:33:58 <SamB_XP> after all, the report doesn't say "don't be stupid" either ;-)
18:34:02 <|Steve|> Fair enough. It just seems like it's something that should be in the language given that there are no looping constructs.
18:34:09 <ddarius> You'd think.
18:34:24 <SamB_XP> ddarius: it would be too hard to say
18:34:36 <Cale> Given that the language spec doesn't specify what order expressions are reduced in, it's sort of meaningless to even talk about the stack.
18:34:37 <geezusfreeek> i don't know, i always thought it was kind of pointless to put implementation details into a language spec
18:34:39 <Cale> What stack?
18:34:50 <SamB_XP> C doesn't have a stack, why should we?
18:35:08 <ddarius> SamB_XP: You'd more talk about space rather than stack.
18:35:27 <Cale> You might just have an implementation which works by treating the program as a big graph and doing matching and reduction on that in a semi-random order.
18:35:39 <SamB_XP> I don't believe that the report *ever* mentions space
18:35:44 <|Steve|> You're right, the c99 standard doesn't use the word stack once.
18:36:55 <SamB_XP> now, of course, it's less stupid to leave out tail-call optimization in a C compiler since, as you say, you can loop in C
18:37:16 <|Steve|> The c++98 standard does mention stack unwinding.
18:37:53 <SamB_XP> C++ is a bit of a different beast
18:38:22 <|Steve|> It never refers to a call stack though.
18:38:40 <SamB_XP> it might have been a slip-up ;-)
18:38:55 <|Steve|> What might have been a slip up?
18:39:07 <SamB_XP> using the word stack in "stack unwinding"
18:39:24 <|Steve|> They use it 7 times.
18:39:44 <SamB_XP> or maybe they couldn't come up with a better term...
18:39:51 <|Steve|> And say stack is unwound twice more and stack shall not be unwound once.
18:40:07 <|Steve|> But they're talking about object destruction.
18:40:20 <SamB_XP> anyway, the stack doesn't actually need to be a conventional stack
18:40:29 <|Steve|> "The process of calling destructors for automatic objects constructed on the path from a try block to a throw-expression is called "stack unwinding."
18:42:10 <SamB_XP> anyway, C++ is a bit different I think
18:42:17 <SamB_XP> since it has those pesky destructors
18:42:19 <|Steve|> The c++ standard is way to long. 776 pages.
18:42:29 <|Steve|> too*
18:42:38 <|Steve|> I no speak the English.
18:43:02 <SamB_XP> um, that's no excuse! I speak english and I still make mistakes like that ;-P
18:43:41 <|Steve|> It was a joke since apparently I failed in that sentence.
18:44:02 * SamB_XP was somewhat kidding too
18:47:56 <Baughn> This is why IRC should have humor tags
18:48:43 <SamB_XP> </joke>
18:49:59 <msouth> so I could tell if "stack is unwound twice more and stack shall not be unwound once." was a reference to the Holy Hand Grenade?
18:51:17 <|Steve|> It wasn't.
18:51:31 <|Steve|> I was reading off stats about the standard.
18:51:32 <Baughn> "Once shalt thou free objects. Objects shall be freed once, and one shall be the number of the freeing."
18:51:52 <Baughn> I'm going to have to remember that one, for a channel where it actually fits
18:52:06 <|Steve|> Heh.
18:52:20 <SamB_XP> why doesn't it fit here?
18:52:32 <SamB_XP> we can even free *functions* here
18:53:07 <dons> have people see http://leiffrenzel.de/eclipse/cohatoe/ ?
18:53:08 <lambdabot> Title: Cohatoe - Contributing Haskell to Eclipse
18:53:31 <Baughn> SamB_XP: I'm thinking up a.. poem?.. that explains malloc/free in a rememberable way
18:53:42 <Baughn> Remembrable?
18:53:56 <SamB_XP> memorable
18:54:16 <Baughn> I prefer remembrable.
18:54:16 <msouth> "mnemonish"
18:54:42 <dons> http://programming.reddit.com/info/26nde/comments
18:54:43 <lambdabot> Title: Cohatoe: Extending Eclipse in Haskell (reddit.com)
18:55:23 <cytzol> :r
18:55:26 <cytzol> whoops
18:55:33 <geezusfreeek> :)
19:03:17 <hpaste>  int-e annotated "f.f = g" with "using Data.Set as a priority queue" at http://hpaste.org/1702#a1
19:03:37 <EvilTerran> hm. GHC's postfix operator support doesn't seem to extend to type constructors.
19:04:15 <dons> http://programming.reddit.com/info/26nfh/comments
19:04:16 <lambdabot> Title: An introduction to unit testing in Haskell with HUnit (reddit.com)
19:04:34 <int-e> |Steve|: see annotation. it's quite a bit faster
19:05:21 <sjanssen> dons: psssh, unit tests are just zero arity quickchecks :)
19:05:38 <|Steve|> int-e: Looking.
19:05:45 <geezusfreeek> sjanssen: what about for effectful code?
19:05:59 <dons> sjanssen: I agree :)
19:06:07 <sjanssen> geezusfreeek: that might be another story.  I'm partly joking
19:06:09 <dons> geezusfreeek: we can do that in QC these days too
19:06:11 <|Steve|> Well, once the stupid page loads anyway.
19:06:15 <geezusfreeek> dons: orly?
19:06:18 <dons> see swiert's HW paper
19:06:26 * geezusfreeek peeks
19:07:13 * geezusfreeek is searching and not finding
19:07:31 <dons> let's see..
19:08:10 <dons> http://programming.reddit.com/info/26nge/comments
19:08:11 <lambdabot> Title: Beauty in the Beast: testing impure code with QuickCheck (reddit.com)
19:08:21 <dons> hang on, got to fix that
19:08:22 <dons> its a pdf
19:09:12 <int-e> |Steve|: the Queue type implements a queue made up off finitely many, sorted, infinite lists. the nextQ function is badly named - what it does is pick the next number (starting from m) that is *not* in the queue.
19:09:24 <dons> http://programming.reddit.com/info/26ngk/comments
19:09:25 <lambdabot> Title: Beauty in the Beast: checking IO, state and concurrent code with QuickCheck (pdf ...
19:09:40 <geezusfreeek> dons: thanks
19:09:48 <|Steve|> Okay.
19:10:38 <dons> sjanssen: we could take a similar approach to QC X11
19:10:54 <sjanssen> dons: that would require a purely functional spec of an X server
19:10:56 <dons> (a data type for X11 operations, form a monad, test that purely, evaluate it it to actually execute the actions)
19:11:00 <sjanssen> I imagine
19:11:00 <dons> yes :)
19:11:06 <|Steve|> Ugh, the page hasn't loaded yet. I'm going to put some laundry in and then look.
19:11:49 <dons> yes, just have to write down the dX server semantics
19:11:50 <dons> then its easy
19:13:22 <|Steve|> You have an embedded delete character in there.
19:14:27 <|Steve|> (Between the d and the X.)
19:20:04 <SamB_XP> |Steve|: perhaps he thought he'd deleted the d?
19:22:43 <dons> bad wifi, control chars not getting escaped by a bit too much latency
19:26:31 <|Steve|> 0x7f is typically a forward delete though.
19:27:03 <|Steve|> 0x08 is backspace.
19:27:36 <glguy> > "\x7f"
19:27:43 <glguy> ?bot
19:27:43 <lambdabot> :)
19:27:44 <lambdabot>  "\DEL"
19:28:03 <glguy> > "\8"
19:28:04 <lambdabot>  "\b"
19:28:10 <glguy> > "\x08"
19:28:11 <lambdabot>  "\b"
19:28:24 <|Steve|> int-e: I have to admit, I don't quite know what this is doing.
19:31:39 <int-e> |Steve|: it's the same algorithm as yours really, except for two major differences: a) instead of removing entries from a list of candidates ([12..]) it keeps a list of forbidden candidates; secondly these lists are stored in a Queue (basically getting O(log m) instead of O(m) processing time per element for merging m infinite lists)
19:32:16 <glguy> what algorithm is this?
19:32:19 * glguy came in a bit late
19:32:27 <|Steve|> Ah. I'm amazed you could even follow the algorithm.
19:32:46 <|Steve|> glguy: It's a construction for a function f such that f . f = n^2 -19n + 99 for all natural numbers n.
19:32:48 <int-e> |Steve|: well I did that problem of the day, too. my haskell version was worse than yours actually ;)
19:32:55 <|Steve|> Heh, okay.
19:33:13 <|Steve|> I didn't actually solve the problem. TRWBW did. I just implemented it.
19:33:26 <int-e> well I did it the same way :)
19:33:40 <|Steve|> It took him about half an hour to explain it to me. Then he solved it some other way that I didn't follow.
19:34:04 <necroforest> Is there anything like arrays in haskell? Or do you have to access things sequentially in lists?
19:34:10 * bos loves conor mcbride's Punter -> (String -> Punter)
19:34:48 <|Steve|> necroforest: There are arrays.
19:35:37 <int-e> |Steve|: anyway it eats a crazy amount of memory now but is fast enough to verify that f . f = g for 1..500 in 12 seconds here
19:36:22 <|Steve|> More memory than mine?
19:37:13 <int-e> |Steve|: I'm not patient enough to test that :)
19:37:40 <|Steve|> heh
19:38:32 <hpaste>  int-e annotated "f.f = g" with "a strategical `seq` cuts memory usage by a factor of 4" at http://hpaste.org/1702#a2
19:39:14 <campusblo> hi folks. I wrote a program to crack code which takes strings as input
19:39:19 <int-e> (if you're building a huge list, make sure that all list elements are fully evaluated)
19:39:29 <campusblo> only problem is that its cant get around a " in the string
19:39:37 <campusblo> anybody have any suggestions for that?
19:39:50 <campusblo> i can get around everything else
19:40:00 <oklopol> get around it?
19:40:07 <dons> `to crack code' ?
19:40:11 <campusblo> oh 
19:40:12 <glguy> > " a b \" c d " -- is this related?
19:40:14 <lambdabot>  " a b \" c d "
19:40:20 <campusblo> its a ceaser cipher
19:40:30 <glguy> the " stays a "
19:40:46 <bos> i think a ceaser cipher would be defined as \_ -> []
19:41:00 <oklopol> campusblo: what do you mean you can't around a " in a string?
19:41:10 <dons> do you mean you can't pattern match on " ?
19:41:17 <campusblo> it creates an encrypted or decrypts messages by shifting all letters a certain number of letters down the alphabet
19:41:19 <dons> > '"' == 'x'
19:41:21 <lambdabot>  False
19:41:24 <campusblo> yes okpool
19:41:37 <campusblo> if i put a " the string terminates
19:41:42 <oklopol> ah
19:41:43 <campusblo> and i get an error
19:41:43 <oklopol> \"
19:41:46 <oklopol> escape it
19:41:54 <oklopol> \" where you want the "
19:42:20 <campusblo> but thats still 2 characters
19:42:25 <oklopol> unless i'm confusing languages here, i shouldn't be teaching on this channel, but the other way around :)
19:42:29 <campusblo> i think it would still terminate
19:42:34 <campusblo> lol
19:42:37 <oklopol> campusblo: that will mean "
19:42:42 <oklopol> it's a way to get a " in a string
19:42:48 <campusblo> oh ok
19:42:57 <oklopol> read up onescape sequences
19:43:01 <campusblo> ill try it 
19:43:01 <oklopol> *on escape
19:43:06 <campusblo> will do
19:44:24 <dolio> campusblo: Is Haskell your first language?
19:44:35 <campusblo> yes
19:44:44 <dolio> Nice.
19:44:48 * glguy points out that he solved campusblo's problem before he knew what the problem was :)
19:45:03 <ddarius> Lucky you.
19:45:37 <campusblo> i guess. but why do you say that ddarius?
19:45:41 <glguy> Haskell it is terrible first language, you won't bother to learn any others ;)
19:45:56 <jfredett> tru that.
19:45:59 <SamB_XP> glguy: but then what will you write in it?
19:46:00 <glguy> Most people start on an imperative language, and get all sorts of bad habits
19:46:04 <dolio> Heh. He can always go on to Coq/Epigram.
19:46:08 <SamB_XP> anyway, you'll then want to learn C
19:46:09 <ddarius> There are many worse languages to start learning programming on (though in my opinion there are better ones too)
19:46:12 <chrisamaphone> sml, twelf :)
19:46:18 <oklopol> glguy: i did too, i just don't like giving advise until i'm sure :)
19:46:24 <ddarius> Yarrow or Agda.
19:46:56 <campusblo> well cool. i like haskell. 
19:47:04 <glguy> oklopol: You should try to give advice early and often
19:47:06 <SamB_XP> I didn't make it to the end of the agda tutorial
19:47:11 <campusblo> and i hear functional programmers make the big bucks
19:47:18 <dons> yeah, twelf or epigram would make strange first languages
19:47:18 <jfredett> ddarius: I like Scheme for a first language, Haskell for the real work
19:47:20 <SamB_XP> oh no!
19:47:26 <glguy> oklopol: there was a thread on the mailing list about how we need to transition people into "answering questions" sooner to keep the community going
19:47:28 <SamB_XP> he's in it for the money!
19:47:31 <campusblo> scheme is the next languae i do
19:47:33 <SamB_XP> kick him quick
19:47:42 <|Steve|> campusblo: Heh. Big bucks. =)
19:47:45 <jfredett> Scheme < Haskell, in terms of power and hardness to learn.
19:48:02 <jfredett> i guess difficulty is what i meant.
19:48:04 <ddarius> jfredett: Scheme is one of the languages I would recommend as better, though it could still be a better starting language that it is.
19:48:07 <|Steve|> Scheme is easier to learn. Side effects, consistent syntax.
19:48:09 <glguy> You can express more programs in Scheme than Haskell though
19:48:30 <campusblo> i see. i guess ill see next semester
19:48:31 <chrisamaphone> uh, they're both turing complete.
19:48:33 <|Steve|> I wouldn't expect to make money writing scheme though...
19:48:45 <glguy> Haskell's type system eliminates programs that are otherwise valid in some cases
19:48:48 <int-e> glguy: how many countable infinities are there?
19:48:58 <glguy> int-e: relatively more :)
19:49:10 <jfredett> glguy: yes, but those programs are most often not needed.
19:49:13 <glguy> chrisamaphone: we tend to leave the turing complete argument at the door
19:49:25 <campusblo> i hear you. i think we learn on these then we have to choose a language. right now im thinking C# and Java
19:49:31 <oklopol> glguy: you are saying there are problems haskell can't solve and lisp can? :)
19:49:33 <dons> given unsafeCoerce#, they accept the same set of programs 
19:49:33 <ddarius> Actually, Scheme is ridiculously powerful.
19:49:46 <chrisamaphone> glguy: fine, you can argue in terms of more expressive power, but saying one can write "more programs" than the other is false.
19:49:50 <campusblo> so scheme is lisp?
19:49:53 <jfredett> I agree its quite powerful, but that power is often less accessible
19:49:56 <ddarius> Last I checked Scheme code didn't parse as Haskell or vice versa.
19:49:56 <jfredett> campusblo: yes and no
19:49:59 <chrisamaphone> dymanic languages are embeddable in static type systems.
19:50:17 <glguy> to set some sort of starting point, I love Haskell and use it as my primary language at work :)
19:50:19 <chrisamaphone> *dynamic
19:50:24 <campusblo> I see ppl reccomending lisp all the time
19:50:28 <glguy> I'm just defending the other languages since no one else was :)
19:50:29 <|Steve|> Scheme is a lisp.
19:50:33 <geezusfreeek> glguy: where do you work that you get to use haskell?
19:50:37 <glguy> Galois
19:51:09 <ddarius> Scheme has a lot of good introductory resources and is a rather nice language.
19:51:12 <jfredett> IMO, Scheme and Haskell are useful in different situations
19:51:29 * |Steve| is teaching Scheme. It's a bit of a joke.
19:51:31 <jfredett> and that set is mostly disjoint
19:51:39 <int-e> > (map ((+) 2) ([1,2,3]))
19:51:40 <|Steve|> I don't really know that much scheme. If my students know n, I try to know n+1.
19:51:41 <lambdabot>  [3,4,5]
19:51:46 <ddarius> jfredett: Not my experience at all.
19:52:13 <|Steve|> (map (lambda (n) (+ n 2)) '(1,2,3))
19:52:41 <oklopol> lose the ,
19:52:58 <glguy> isn't 1,2,3 a symbol?
19:53:12 <jfredett> its a symbol for a list
19:53:17 <oklopol> i don't think a number can start a symbol
19:53:22 <ddarius> '(1 2 3)
19:53:27 <|Steve|> oops, yeah.
19:53:28 * glguy fires up DrScheme to find out
19:53:31 <jfredett> '(1 2 3) is the list (1 2 3)
19:53:44 <|Steve|> guile> (map (lambda (n) (+ n 2)) '(1 2 3))
19:53:44 <|Steve|> (3 4 5)
19:53:49 <glguy> > '(1,2,3)
19:53:49 <lambdabot>  Improperly terminated character constant
19:53:49 <glguy> (1 ,2 ,3)
19:53:58 <glguy> is what DrScheme returned
19:54:07 <|Steve|> As was pointed out, lose the commas.
19:54:13 <jfredett> bah, we need mzbot in here too.
19:54:16 <int-e> uh does scheme have the , unquote character?
19:54:19 <oklopol> does lambdabot do lisp?
19:54:22 <glguy> |Steve|: I'm not concerned with correcting your example :)
19:54:29 <glguy> |Steve|: I was wondering how that actually parsed
19:54:29 <ddarius> jfredett: You'd think, but it actually doesn't come up that often.
19:54:30 <jfredett> or at least a Lisp> for Lambdabot
19:54:37 <dons> oklopol: no, because we can't analyse it for safety
19:54:40 <|Steve|> Ah.
19:54:43 <dons> which we can do with haskell
19:54:49 <dons> > readFile "/etc/passwd"
19:54:51 <lambdabot>  <IO [Char]>
19:54:52 * glguy high fives haskell
19:54:54 <ddarius> jfredett: You can write one with @let
19:55:12 <glguy> dons: the safety check is just a more complicated version of:
19:55:23 <glguy> > unsafePerformIO (putStrLn "this")
19:55:24 <lambdabot>   Not in scope: `unsafePerformIO'
19:55:34 <jfredett> ddarius: hmm. I'll have to do that sometime.
19:55:36 <glguy> You'd just have to take stuff out of scope, and kill off intern or something
19:55:43 <glguy> and eval
19:55:56 <dons> more than that, we only show types from a given class
19:56:13 <dons> so the type checker rules out side effects. that's the strong weapon we use
19:56:21 <ddarius> jfredett: I wrote a Joy interpreter in a mostly pure untyped lambda calculus interpreter that I had written as a plugin for lambdabot.
19:56:25 <dons> the other stuff, a trusted base, timeouts and other things , are sugar after that
19:56:37 <campusblo> can i do this  | x == '\"' = '\"'
19:56:38 <glguy> dons: I understand that aspect of it, but you fill the holes by not importing certain functions
19:56:47 <ddarius> campusblo: Yes.
19:56:52 <dons> right. nothing that hides an effect inside a pure value
19:57:06 <campusblo> to keep the quote in the string
19:57:13 <campusblo> ok cool ill test it now
19:57:17 <glguy> campusblo: '\"' and '
19:57:21 <glguy> '"' are the same
19:57:26 <glguy> (saves you a character ;) )
19:58:05 <oklopol> because " inside a '' doesn't end the string and thus needs no escaping from
19:58:12 <ddarius> "not importing <things>" is the key to security anyways.
19:58:34 <int-e> > ['\34', '\x22', '\"', '"']
19:58:35 <lambdabot>  "\"\"\"\""
19:58:44 <campusblo> ERROR - Syntax error in input (unexpected `;', possibly due to bad layout)
19:58:48 <glguy> > fix show
19:58:50 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
19:58:57 <oklopol> > 1
19:58:59 <lambdabot>  1
19:59:02 <oklopol> hihi
19:59:19 <glguy> ?vixen Have you met oklopol?
19:59:20 <lambdabot> yeah, i'm ok
19:59:34 <oklopol> ? :I
20:04:38 * glguy wonders if Haskell's type system could be implemented in Lisp using macros...
20:05:00 <ddarius> glguy: Of course it can.
20:05:17 <glguy> without having to change too much of the lisp code at least
20:05:31 <SamB_XP> oh, probably not ;-)
20:05:56 <ddarius> So your question is is typical Lisp code reasonably typeable in a H-M style type system?
20:06:21 <glguy> I suppose it is
20:06:52 <thorat> it's going to take a few milliOleg's of macro hackery
20:07:19 <ddarius> thorat: No, you just implement the type checker exactly as you would normally.
20:07:49 <dons> `Personally, I don't really classify CL as an FP language' -- i've been saying that for years :)
20:08:04 <ddarius> dons: What about Scheme?
20:08:05 * glguy saw that on reddit
20:08:24 <dons> I'd say if its not pure by default, its not functional. but that might be a little controversial
20:08:35 <Cale> It seems that preventing I/O from occurring in pure code in CL would be tricky to accomplish with just macros.
20:08:36 <dons> you have to have (.) anyway
20:08:55 <Cale> CL makes it too much of a pain to write higher order functions
20:08:56 <thorat> ddarius: ok, I thought glguy meant a similar approach to Kanren
20:09:34 <ddarius> dons: ?
20:09:46 <Cale> You have to quote things in funny ways, and use funcall/apply to call functions passed as parameters. That tends to make uses of functional programming less casual.
20:10:09 <ddarius> The lack of TCO is one of the bigger issues for me.
20:10:15 <Cale> Oh, that too.
20:10:18 <ddarius> But I don't consider TCO an FP thing.
20:10:19 <glguy> CL doesn't require tail recursion optimization either, right?
20:10:43 <Cale> glguy: Many implementations don't support it.
20:10:52 * glguy wasn't paying attention when he typed that
20:10:56 <dons> ddarius: did you see this thread, http://groups.google.com/group/comp.lang.lisp/msg/43090ddeeb50051c?dmode=source
20:10:59 <lambdabot> Title: New Computer Language Shootout? - comp.lang.lisp | Google Groups, http://tinyurl.com/2uhxva
20:11:04 <dons> (besides being started by Jon Harrop... :/ )
20:11:19 <dons> it makes a good case for why you never see lisp papers at ICFP :)
20:11:23 <ddarius> dons: Unless it happened several years ago, I haven't been following c.l.l (or any newsgroups now)
20:11:33 <Cale> The fact that Haskell isn't required to have TCO doesn't bother me, since it's defined at a completely different level of abstraction from that.
20:11:49 <ddarius> Cale: And the fact that it is effectively required anyways.
20:11:56 <Cale> yeah
20:12:16 <Cale> at least, if you're doing anything like an ordinary implementation of it
20:15:31 <dancor> can i somehow get   Just 1 + Just 2 = Just 3   and   Nothing + Just 4 = Nothing   to work
20:16:02 <shachaf> dancor: Use fmap (<$>).
20:16:10 <ddarius> dancor: Make Maybe an instance of Num.
20:16:18 <int-e> > liftM2 (+) (Just 1) (Just 2) -- hmm
20:16:19 <shachaf> dancor: Or liftM2, I guess.
20:16:26 <lambdabot>  Just 3
20:16:34 <dancor> cool
20:16:42 <shachaf> int-e: Yes, liftM2 is probably better in this case.
20:17:01 <dons> > liftM2 div (Just 1) (Just 0)
20:17:02 <lambdabot>  Exception: divide by zero
20:17:14 <dons> div should be in Maybe :)
20:17:22 <ddarius> I'd rather it not.
20:17:28 <int-e> > (+) <$> Just 2 <*> Just 3 -- or Applicative (as shachaf also suggested)
20:17:30 <lambdabot>  Just 5
20:17:34 <ddarius> Though I guess I could just throw a fromJust on it.
20:17:50 <dons> unsafeDiv for things other than Rational
20:20:48 <glguy> dons: Haskell is the most referenced nick?
20:20:52 <glguy> I suppose that is my fault?
20:21:23 <shachaf> glguy: Were you Haskell at one point?
20:21:24 <dons> yeah :) told you so.
20:21:24 <dons>  
20:21:44 <glguy> shachaf: yeah , I registered that at one point for fun
20:23:11 <glguy> shachaf: according to the whowas, so were you :)
20:23:27 <shachaf> glguy: Just for a moment. :-)
20:24:12 <glguy> that way I could nickserv ghost someone that used the nick to do stuff like
20:24:29 * Haskell is strongly typed for weak minds
20:24:56 <shachaf> What does "strongly typed" mean, anyway?
20:25:23 <glguy> doesn't automatically coerce types, generally
20:26:25 <glguy> I believe that "weak typing" is used to describe things like: "2" + True = 3
20:28:14 <ddarius> Usually it's a bit stronger than that, that you can't apply a function to a type that does not support it, i.e. unsafeCoerce 3 5
20:28:39 <ddarius> I.e. that the type system is sound
20:28:50 <ddarius> For statically typed languages.
20:29:40 <oklopol> > "2" + True
20:29:41 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Bool'
20:30:02 <oklopol> > "2" + True /= 3
20:30:02 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Bool'
20:30:13 <glguy> (+) :: Num n => n -> n -> n
20:30:29 <glguy> the two addends need to have the same type
20:30:34 <oklopol> yeah, i'm just playing around :)
20:30:42 <oklopol> > "23"+"44"
20:30:43 <lambdabot>   add an instance declaration for (Num [Char])
20:30:43 <lambdabot>     In the expression: "23" + ...
20:30:48 <oklopol> > "23"++"44"
20:30:49 <lambdabot>  "2344"
20:30:56 <siti> > 1/2.0 ;)
20:30:56 <lambdabot>  Parse error
20:30:59 <siti> > 1/2.0
20:31:01 <lambdabot>  0.5
20:31:06 <glguy> oklopol: through a gross instance definition "1" + "2" could work
20:31:18 <dolio> > let a + b = read a Prelude.+ fromEnum b in "2" + True
20:31:19 <oklopol> can you show me? :)
20:31:20 <lambdabot>  3
20:31:27 <shachaf> oklopol: Not in lambdabot.
20:31:40 <oklopol> i c
20:31:41 <shachaf> oklopol: But "instance Num String where (+) = (++)" should work.
20:32:28 <Figs> hi
20:32:30 <glguy>   a + b = show $ readInt a + readInt b
20:32:41 <shachaf> Figs: Hello.
20:32:43 <Figs> hi
20:33:13 <Figs> http://rafb.net/p/krffm450.html <-- some real evil :)
20:33:14 <lambdabot> Title: Nopaste - No description
20:33:45 <Figs> a math expression parser that I *think* does order of ops correctly as it builds the tree
20:33:52 <shachaf> Figs: Wasn't that your C++ thing?
20:33:57 <Figs> it's build on it
20:34:09 <Figs> this is what I'll test my rewrite with
20:34:17 <Figs> it's not done yet
20:34:21 <Figs> so this won't work in all cases
20:34:34 <shachaf> Figs: Now try it in Haskell and see how much better it is. :-)
20:34:39 <Figs> hehe :P
20:34:42 <ddarius> I wonder how close to Tcl we can get if we just start making String an instance of everything.
20:34:50 <Figs> I figured out something interesting
20:35:01 <Figs> that you guys can probably give me some perspective on
20:35:12 <Figs> My parser is very easily extensible, so
20:35:16 <Figs> I can write things like
20:35:31 <Figs> (or will be able to)
20:36:03 <ddarius> What algorithm does it use to parse?
20:36:21 <Figs> regex equalnumb = (S[0] << *A) >> repeat(B,count(S[0],A)) >> repeat(C,count(S[0],A)); //etc
20:36:43 <Figs> which would match something like AAABBBCCC
20:36:48 <Figs> AAAABBBBCCCC
20:36:49 <Figs> etc
20:37:00 <dancor> > printf "hi"
20:37:00 <lambdabot>  Add a type signature
20:37:08 <shachaf> > printf "hi" :: String
20:37:10 <lambdabot>  "hi"
20:37:17 <dancor> > printf "%.2f" pi
20:37:18 <lambdabot>  Add a type signature
20:37:21 <shachaf> dancor: Lambdabot can't print to stdout.
20:37:22 <dancor> man
20:37:28 <shachaf> > printf "%.2f" pi :: String
20:37:30 <lambdabot>  "3.14"
20:37:38 <glguy> printf could return a function, an IO action, or a String
20:37:42 <glguy> you always have to specify
20:37:47 <dancor> shachaf: then why did yours work
20:37:54 <ddarius> Figs: The order of operations is right, but you can't write 3+4+5 without parentheses.
20:37:59 <shachaf> dancor: I told it that it was a String.
20:38:02 <ddarius> :t printf
20:38:04 <lambdabot> forall r. (PrintfType r) => String -> r
20:38:09 <shachaf> dancor: Keep in mind that printf is a bit magical.
20:38:16 <Figs> ahh, I did miss something then
20:38:26 <glguy> @instances PrintfType
20:38:28 <lambdabot> Couldn't find class `PrintfType'. Try @instances-importing
20:38:42 <dancor> is there a less magical way to get  printf "%.2f" x :: String
20:38:44 <ddarius> Similarly for *
20:38:56 * dancor isn't really into magic
20:39:07 <shachaf> dancor: Not THAT magical.
20:39:12 <ddarius> dancor: It's just normal type class resolution
20:39:17 <Figs> http://rafb.net/p/NGVY1D91.html
20:39:19 <Figs> is that better?
20:39:20 <lambdabot> Title: Nopaste - No description
20:39:27 <ddarius> But check out the stuff in Numeric perhaps?
20:39:31 <glguy> (PrintfArg a, PrintfType r) => PrintfType (a -> r)
20:39:31 <glguy> PrintfType (IO a)
20:39:31 <glguy> IsChar c => PrintfType [c]
20:39:44 <shachaf> dancor: It's just that a normal function in Haskell has a fixed number of arguments.
20:40:11 <shachaf> dancor: Using type-classes, printf can work around it, because it knows how many arguments to expect (from the format string).
20:40:13 <dolio> > showFFloat (Just 2) pi ""
20:40:14 <dancor> shachaf: so why doesn't printf take [Dynamic]
20:40:14 <lambdabot>  "3.14"
20:40:20 <glguy> :t printf "" :: Int -> String
20:40:22 <lambdabot> Int -> String :: Int -> String
20:40:24 <dancor> oh
20:40:25 <ddarius> Figs: Can your parser handle that?  And I believe 2+3+4*1 won't parse.
20:40:37 <ddarius> dancor: Because this is Haskell.
20:41:03 <dancor> do you mean Haskell :: ProgrammingLanguage
20:41:15 <dancor> bc otherwise i will give you a meaningless error message
20:41:27 <shachaf> dancor: No, printf is a special case.
20:41:38 <shachaf> dancor: Normally the types can be inferred.
20:41:48 <Figs> 2+3+4*1 should parse fine
20:41:51 <glguy> printf just doesn't have defaulting
20:41:57 <dolio> > let c = 299790000 in showEFloat (Just 4) c ""
20:41:58 <lambdabot>  "2.9979e8"
20:42:02 <glguy> while Num and Floating do
20:42:08 <Figs> oh
20:42:10 <Figs> hmm
20:42:13 <Figs> no
20:42:28 <ddarius> Figs: It will be addterm(2+3)+error(4*1 doesn't parse as number)
20:42:37 <glguy> printf is the standard case, Num and Floating are special cases
20:42:57 <Figs> ok, that's resolveable though by adding one more case
20:43:06 <shachaf> glguy: I didn't mean defaulting, I meant "your types not being inferred easily". :-)
20:43:21 <ddarius> Figs: You don't need this many cases, further will your parser handle left recursion?
20:43:33 <ddarius> shachaf: No worse than Read.
20:43:51 <glguy> shachaf: I was saying that the type of   7   can not be inferred easily, that the reason you don't have to specify is defaulting
20:44:13 <glguy> and that since PrintfType isn't special cased, you ave to specify
20:44:19 <Figs> http://rafb.net/p/J8YNus24.html
20:44:20 <lambdabot> Title: Nopaste - No description
20:44:25 <shachaf> ddarius, glguy: You're right, I guess lambdabot specificaly is a bad place to test this.
20:44:42 <Figs> ddarius, give me an example, and I'll think about it
20:44:53 <shachaf> dancor: Normally, from the context (e.g., a do block), the type of printf can be inferred.
20:45:02 <Figs> I'm not sure exactly what you mean.
20:45:17 <oklopol> A = A | B; is left recursion
20:45:19 <oklopol> err
20:45:24 <oklopol> A = A >> B;
20:45:30 <Figs> hi oklopol :)
20:45:32 <oklopol> and hi Figs
20:45:33 <oklopol> :)
20:45:36 <dancor> > printf "%.2f" ((fromIntegral 4) / (fromIntegral 6) :: Float) :: String
20:45:38 <lambdabot>  "0.67"
20:45:47 <dancor> that's what i had to do in my context
20:45:53 <ddarius> If you use recursive descent, you have a problem.
20:46:09 <shachaf> dancor: What was your context?
20:46:14 <Figs> It's doing recursive descent right now, I think.
20:46:19 <Figs> so probably not.
20:46:20 <dolio> The fromIntegrals there should be redundant.
20:46:22 <shachaf> dancor: You don't need those fromIntegrals.
20:46:37 <ddarius> Then things like multerm and addterm won't terminate.
20:46:44 <dancor> CM.liftM2 (divF) justMyIntA justMyIntB
20:46:56 <dancor> which is later Show-n
20:47:15 <shachaf> dancor: (You generally don't need to qualify Control.Monad, by the way.)
20:47:27 <dancor> shachaf: i like to qualify everything
20:47:29 <ddarius> shachaf: s/generally/usually
20:47:51 <shachaf> ddarius: Yes, sorry. :-)
20:48:02 <Figs> hmm, I don't know how hard it would be to fix that
20:48:05 <Figs> :P
20:48:18 <Figs> it could be simple, or it could be very difficult
20:48:21 <dancor> and without the fromIntegral's i gett a "Couldn't match Float" blahblah
20:48:36 <shachaf> dancor: That shouldn't happen.
20:48:42 <Figs> the simple case would involve rewriting by_ref and operator >>
20:48:44 <shachaf> dancor: Are the 4 and 6 hard-wired like in your example?
20:48:46 <glguy> dancor: you don't need fromIntegral for literals
20:48:53 <Figs> well, a seq object
20:48:55 <dancor> they aren't literals
20:48:57 <glguy> dancor: but you do for values in your code
20:49:01 <dancor> 20:46 < dancor> CM.liftM2 (divF) justMyIntA justMyIntB
20:49:26 <glguy> shachaf: that's why :)
20:49:50 <shachaf> glguy: Yes, I guessed that myself. :-)
20:49:55 <ddarius> Figs: You can use a different algorithm in which left-recursion is not a problem, require that left-recursion not be there, or "preprocess" the grammar to detect it and rewrite it.
20:50:23 <Figs> the easiest solution would be to change the behavior of the search, I think
20:50:35 <shachaf> dancor: Can you @paste with some more context?
20:50:54 <ddarius> Just name the printf expression and give it a type.
20:51:26 <Figs> actually
20:51:33 <Figs> hmm
20:51:38 <dancor> i think i see now that i will always need the :: Float and the :: String for my context
20:51:51 <dancor> and i'm going to start the lengthy process of getting-over it now
20:51:59 <shachaf> dancor: How are you using the printf?
20:52:04 <Figs> do you have the name of another algorithm I can use?
20:52:05 <hpaste>  aeyakovenko pasted "fast sha1" at http://hpaste.org/1704
20:52:39 <ddarius> Look up LR parsing or if you want to be very friendly GLR parsing.
20:53:37 <Figs> well the thing I need to be careful of is to keep it extensible
20:54:04 <Figs> since that's the real power: it's easy to write a new parser type
20:54:04 <ddarius> > let printFloat :: Float -> String; printFloat = printf ".2f" in printFloat 3
20:54:06 <lambdabot>  Exception: Printf.printf: formatting string ended prematurely
20:54:18 <ddarius> > let printFloat :: Float -> String; printFloat = printf "%.2f" in printFloat 3
20:54:20 <lambdabot>  "3.00"
20:54:51 <Figs> I could number the rules and keep track of the parents and detect infinite loops, couldn't I?
20:55:25 <ddarius> Figs: Completely new?  Wouldn't most be compositions of primitive parsers?
20:55:36 <hpaste>  dancar pasted "shachaf: printf needs lots of :: Love" at http://hpaste.org/1705
20:55:40 <Figs> most probably, but like my repeat example
20:55:53 <Figs> I could just easily do something like
20:56:11 <mm_freak> > div 15 (fromIntegral (3::Int))
20:56:12 <lambdabot>  5
20:56:19 <Figs> regex bothways = (S[0] << pattern ) >> '|' >> reverse(S[0]);
20:56:23 <mm_freak> will this be translated into a long-short-division?
20:56:41 <mm_freak> i.e. mpz_tdiv_q_ui instead of mpz_tdiv_q
20:56:58 <dancor> oh interesting, hpaste truncates without telling where it will
20:57:21 <dancor> i should have been counting
20:57:37 <dolio> Actually, on the 'new' page it says it 'truncates after 5k'.
20:57:49 <dancor> hence should have been counting
20:57:51 <shachaf> dancor: You can simplify toDay to use pattern matching (unrelated).
20:57:52 <ddarius> Is that characters or bytes?
20:57:53 <dolio> Although, I suppose it could warn you if you try to post something big.
20:58:20 <SamB_XP> I think it should truncate on 1kloc or something
21:00:00 <Figs> you heard about the 500 mile email problem before?
21:00:26 <hpaste>  dancor pasted "shachaf: the end of my printf example" at http://hpaste.org/1706
21:00:34 <Figs> http://www.ibiblio.org/harris/500milemail.html :)
21:00:35 <lambdabot> Title: The case of the 500-mile email
21:00:47 <dancor> shachaf: ok i'll do that
21:01:27 <Figs> ddarius, do you have any idea how I can check for infinite cycles?
21:01:40 <shachaf> dancor: You're not using divF at all.
21:01:45 <Figs> (when it is not so obvious as A = A|B?
21:01:53 <Figs> like for example...
21:01:54 <shachaf> dancor: Where are you planning to use it?
21:02:01 <Figs> A = B|C
21:02:03 <dancor> shachaf: http://hpaste.org/1706
21:02:08 <Figs> B = C|D
21:02:17 <Figs> C= A
21:02:27 <shachaf> dancor: Yes, I see that.
21:02:35 <oklopol> Figs: if the string isn't consumed at all during a loop
21:02:36 <shachaf> dancor: You're defnining it but never using it.
21:02:43 <oklopol> then you have an infinite loop
21:03:17 <dancor> shachaf: second post (1706 not 1705) 4th line from the bottom is:                (i, CM.liftM2 (divF) (CM.liftM2 (-) (Just nowTime) t)
21:03:19 <oklopol> in case your system is as flexible as i think it is, you'll get to undecidability and have to have a timeout.
21:03:27 <Figs> I could just allow a "time out" of 10 hits to the same pattern with the same string length input
21:03:32 <hpaste>  aeyakovenko annotated "fast sha1" with "(no title)" at http://hpaste.org/1704#a1
21:03:46 <shachaf> dancor: Oh, sorry, I thought I was looking at 1706.
21:04:00 <shachaf> dancor: Generally, you can annotate a post.
21:04:12 <Figs> or check against the string passed :)
21:04:33 <hpaste>  aeyakovenko annotated "fast sha1" with "5k limit on hpaste sucks" at http://hpaste.org/1704#a2
21:04:35 <shachaf> dancor: putStrLn . show is called print (unrelated).
21:04:56 <Figs> hmm, actually
21:05:00 <Figs> if it hits the same one
21:05:04 <Figs> without changing the length
21:05:08 <Figs> then it's failed right?
21:05:15 <Figs> because it will NEVER change the length?
21:05:33 <oklopol> Figs: yes
21:05:35 <Figs> of course, this means that I need to give each regex an ID
21:05:43 <Figs> but that's not too hard really
21:06:28 <oklopol> yes, but the problem is even if it's not tc and it's always decidable, it still might take weeks to match something if set up correct
21:06:39 <oklopol> so the id wont save you all the time
21:06:42 <oklopol> so make a timeout
21:06:48 <Figs> and to make sure I haven't gone in a loop, I just need to have a simple test on each forwarding to make sure that the id of the instance isn't already in a list of ids
21:06:49 <oklopol> as well i mean
21:07:23 <Figs> no one would wait weeks anyway ;)
21:07:32 <Figs> and it would be very hard I think
21:07:36 <hpaste>  glguy annotated "fast sha1" with "5k limit because hpaste is for snippets" at http://hpaste.org/1704#a3
21:07:40 <Figs> to set it up to take weeks
21:07:45 <Figs> unless you can think of an example
21:08:01 <Figs> I mean, there are plenty of stupid things you can do
21:08:03 <oklopol> Figs: yes, but my point is it's better if it's automatically terminated than that the user will have to terminate it
21:08:09 <Figs> but you'll run out of stack first
21:08:12 <oklopol> by force
21:08:16 <oklopol> yeah
21:08:47 <Figs> my regex parser shouldn't have to deal with time
21:08:52 <Figs> that is illogical
21:08:55 <ddarius> @google detecting left recursion
21:08:57 <lambdabot> Plugin `search' failed with: IRCRaised Lib.URL.isTextHTML: getHeader failed
21:08:58 <Figs> what if it's running in another thread
21:09:07 <ddarius> wtf?
21:09:08 <Figs> and someone pauses the thread while waiting for the user to input something?
21:09:20 <oklopol> Figs: indeed, i meant the kinda thing you said yourself, a match limit
21:09:23 <chessguy> @go 3 parsecs in miles
21:09:23 <lambdabot> 3 Parsecs = 5.75205844 x 10^13 miles
21:09:24 <Figs> yeah
21:09:29 <Figs> as soon as you hit one recursion
21:09:31 <ddarius> wtf?
21:09:33 <chessguy> @go recursion
21:09:33 <ddarius> @google detecting left recursion
21:09:33 <Figs> it will recurse again
21:09:35 <lambdabot> http://en.wikipedia.org/wiki/Recursion
21:09:35 <lambdabot> Title: Recursion - Wikipedia, the free encyclopedia
21:09:36 <lambdabot> http://home.earthlink.net/~ltrammell/tech/recurs1.htm
21:09:36 <lambdabot> Title: Detecting left recursion
21:09:40 <chessguy> heh
21:09:49 <ddarius> Whatever.
21:10:07 <chessguy> ddarius, you must have caught google napping :)
21:10:10 <shachaf>  @ty (/)
21:10:26 <ddarius> chessguy: Again!
21:10:40 <chessguy> shameful
21:10:51 <shachaf> @botsnack
21:10:51 <lambdabot> :)
21:11:04 <shachaf> @ty (/) -- Oh, extra space
21:11:06 <lambdabot> forall a. (Fractional a) => a -> a -> a
21:11:13 <chessguy> @quote extra.space
21:11:13 <lambdabot> souwh says: <shapr> hm, I have extra spaces there. \n <souwh> oooh, those can be saved and reused later!
21:11:56 * shachaf stashes space in the Haskell code corner.
21:12:19 <chessguy> and on that note...
21:13:07 <ddarius> Indeed.
21:17:10 <Figs> wow long load times
21:17:43 <shachaf> Figs: For what?
21:18:54 <Figs> home.earthlink.net .../ example from ddarius's search
21:19:07 <shachaf> Oh.
21:19:18 <Figs> see? forgotten about it already :D that long ago.
21:19:43 <shachaf> Figs: First I thought you meant hpaste, then I thought you meant GHC or some other Haskell program.
21:20:18 <shachaf> Figs: It loads instantly for me, though.
21:20:55 <Figs> :S
21:20:58 <shachaf> Figs: Have you done anything with Parsec yet, or is this only about your C++ parser?
21:21:09 <Figs> only about C++ right now
21:21:32 <Figs> so far this channel has been the most helpful :)
21:22:09 <Figs> ergh
21:22:16 <Figs> this hurts my head :P
21:23:23 <shachaf> Of course #haskell is more helpful than ##c++ about C++... :-)
21:23:51 <Figs> well, I was talking about #linguistics
21:24:28 <Figs> they helped me a bit earlier, but they were offtopic for the last while
21:24:41 <Figs> and have been fairly quiet
21:24:48 <Figs> (I probably just picked a bad time :P)
21:25:42 <shachaf> Figs: How can you be off-topic in #linguistics? They were probably just showing you some examples of colloquial English. :-)
21:26:08 <Figs> you can be. :)
21:26:39 <Figs> but it's ok
21:28:20 <Figs> hmm, I guess I should make left-recursion a silent problem
21:28:44 <Figs> since obviously if you have left-recursion, it's a dead end.... that goes on forever
21:28:58 <Figs> and you can just go up and try the next branch
21:29:26 <brad_> can someone provide a short, direct answer for what monad transformers (MaybeT) are, and where i would want to use them? i'm reading http://en.wikibooks.org/wiki/Haskell/Monad_transformers but it seems to not explane the motivation too well 
21:29:28 <lambdabot> Title: Haskell/Monad transformers - Wikibooks, collection of open-content textbooks
21:29:57 <brad_> whoops, explane/explain...me kan spell!
21:30:09 <shachaf> brad_: Have you used State yet?
21:30:26 <dolio> Monad transformers let you augment one monad with the capabilities of another.
21:30:32 <brad_> shachaf: not explicity, i have read about them a bit
21:30:43 <dolio> Without having to rewrite them from scratch.
21:30:45 <oklopol> Figs: left recursion isn't a "bug" in a regex, it's just hard to parse
21:31:00 <dolio> So, state is 's -> (a, s)'
21:31:02 <Figs> oklopol, if it goes on forever, it would count as a bug in my book.
21:31:03 <oklopol> i mean, hard to match
21:31:10 <dolio> And environment is 'r -> a'
21:31:14 <oklopol> Figs: it doesn't necessarily go on forever
21:31:25 <Figs> in the cases I'm talking about as bugs, it could
21:31:36 <Figs> A = A|T
21:31:41 <dolio> So, if you want state and environment, you could write a type 'newtype StateEnvironment r s a = SE (r -> s -> (a, s))'
21:31:43 <Figs> would go on forever in my parser
21:31:47 <oklopol> well, that's obviously a bug, yeah
21:31:59 <Figs> actually, it's A = by_ref(A)|T
21:32:00 <Figs> but meh
21:32:00 <oklopol> but the state system would handle that easily
21:32:01 <bos> is there a way to recover a real url from the clickthrough that reddit obfuscates with?
21:32:03 <dolio> Or you could use 'ReaderT r (State s) a'
21:32:15 <Cale> brad_: My take on it is that monads are, at least as far as programming is concerned, sort of like special-purpose programming languages. Monad transformers are things which construct new such programming languages from existing ones by adding features.
21:32:16 <dolio> Which stacks environment on top of state.
21:32:18 <bos> i find myself stymied every time i want to bookmark a pdf from reddit.
21:32:27 <Figs> oklopol: what state system?
21:32:29 <brad_> ah, thanks guys!
21:32:46 <oklopol> Figs: the one for noticing infinite loops
21:32:51 <brad_> it almost seems like monad transformers are a mechanism to do monad composition? or should i not abuse the term composition?
21:32:56 <Figs> the one I'm trying to figure out how to write :)
21:32:58 <shachaf> bos: Go to reddit.com/info/<id>/comments
21:33:07 <oklopol> heh
21:33:10 <brad_> thanks cale, that is a good explanation
21:33:13 <oklopol> it shouldn't be that hard
21:33:19 <bos> shachaf: exactly what i wanted, thanks!
21:33:19 <dolio> brad_: Yeah. It's like composition.
21:33:24 <Figs> it is
21:33:34 <Figs> the problem is a bit hard to explain
21:33:43 <Figs> you see, I expect this parser to be expanded on endlessly
21:33:48 <Cale> The word "composition" gets my hopes up in ways that makes me not want to use it here, but yes.
21:34:00 <Figs> composition?
21:34:01 <Figs> :P
21:34:09 <shachaf> bos: (Why do you want this, by the way?)
21:34:12 <Figs> oh
21:34:14 <Figs> never mind
21:34:32 <brad_> thanks for the info guys! you are helpful as always. take care!
21:34:46 <Figs> oklopol: I can extend my parser to do things most normal parsers don't really allow
21:34:56 <Figs> like reversing strings
21:35:04 <bos> shachaf: i bookmark the occasional reddit article in delicious
21:35:14 <oklopol> Figs: can you parse code with it? :)
21:35:17 * bos has a few hundred haskell links in his delicious stream
21:35:27 <Figs> if I can solve this problem, you can do a lot with it
21:35:35 <dancor> is there a not for Ordering
21:35:35 <shachaf> bos: Why not just go the reddit URL? It redirects anyway.
21:35:52 <Figs> I'm trying to impliment exhaustive backtracking which is why this is just now becoming a problem 
21:35:58 <dancor> and why does @hoogle Ordering -> Ordering show me things for a -> a
21:36:12 <shachaf> @hoogle Ordering -> Ordering
21:36:12 <lambdabot> No matches, try a more general search
21:36:21 <Figs> oh, crap :S
21:36:26 <dancor> http://haskell.org/hoogle/?q=Ordering%20-%3E%20Ordering
21:36:27 <lambdabot> Title: Ordering -> Ordering - Hoogle
21:36:32 <bos> shachaf: i don't like the obfuscation and indirection
21:36:36 <dancor> i didn't realzie that was diff from @hoogle
21:36:39 <dons> after that silly thread last night about bit sieves, i updated the shootout entry, runs rather well! http://shootout.alioth.debian.org/gp4/benchmark.php?test=nsievebits&lang=all
21:36:41 <lambdabot> Title: nsieve-bits benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Langu ..., http://tinyurl.com/sxpth
21:37:14 <Figs> M = (T >> M) is ok, for example, since it will always pull of a T
21:37:17 <Figs> or fail
21:37:29 <Figs> *off
21:37:47 <shachaf> bos: How is it more obfuscated to go through the reddit link?
21:37:56 <Figs> but, M = M|T is bad
21:38:01 <bos> because i can't see what it's pointing at?
21:38:09 <Figs> M = T|M is bad too
21:38:10 <shachaf> bos: Why not?
21:38:15 <dons> reddit hides links
21:38:30 <bos> for example, if i'm bookmarking a paper on wouter swierstra's home page, i can't see that in the url on delicious.
21:38:37 <bos> all i see is a reddit link.
21:39:01 <shachaf> bos: If I go to http://programming.reddit.com/goto?id=26nfh , it redirects me to the real URL.
21:39:02 <lambdabot> Title: Getting started with HUnit
21:39:07 <dons> authors should be encouraged to create .html pages for their papers
21:39:11 <bos> shachaf: yes, but it's a redirect!
21:39:13 <dons> ?go Stream Fusion
21:39:14 <lambdabot> http://www.cse.unsw.edu.au/~dons/papers/CLS07.html
21:39:14 <lambdabot> Title: Stream Fusion: From Lists to Streams to Nothing at All
21:39:16 <shachaf> bos: And then I can just copy that one.
21:39:18 <dons> like that, imo.
21:39:29 <bos> shachaf: doesn't work if it's a PDF
21:39:44 <bos> dons++
21:39:51 <Figs> hmm
21:39:57 <shachaf> bos: Oh.
21:40:04 <Figs> what about M = M>>T
21:40:57 <Figs> it would be a bug eh
21:40:58 <dolio> Figs: Isn't M = M>>T an infinite string of Ts?
21:41:14 <Figs> basically, it'd turn into that, I think
21:41:27 <Figs> not really what I meant though
21:41:47 <dolio> If it were M = M>>T | e then it'd be T*.
21:42:10 <Figs> yeah
21:42:27 <shachaf> bos: I guess that might be the easiest way, then.
21:42:34 <Figs> basically that'd be M = opt(by_ref(M) >> T);
21:43:07 <Figs> which could be legal
21:43:16 <Figs> ie, TTT
21:43:55 <Figs> let's see... what'd happen though?
21:44:08 <Figs> it tries to grab a by_ref(M) >> T...
21:44:19 <Figs> the M will recurse and no change to input
21:44:23 <Figs> at that point it should fail
21:44:26 <Figs> go back up
21:44:32 <Figs> then see a T
21:44:35 <Figs> grab the T
21:44:39 <Figs> and head out
21:44:44 <Figs> but
21:44:51 <Figs> that's not what it really means, is it?
21:48:47 <dancor> > let notComp x = case x of EQ -> EQ; LT -> GT; GT -> LT in (notComp . compare) 4 5
21:48:48 <lambdabot>  Couldn't match expected type `Ordering'
21:49:06 <dancor> > (id . compare) 4 5
21:49:07 <lambdabot>  LT
21:49:24 <dolio> ((notComp .) . compare)
21:49:42 <dolio> Of course, flip compare gets the same effect, I think.
21:50:43 <Jicksta> hey guys
21:50:55 <dancor> oh flip compare, brilliant
21:51:02 <shachaf> Jicksta: Hello.
21:51:09 <Jicksta> has anyone seen a comparison of the concurrency features in Haskell versus Erlang?
21:53:02 <dons> Jicksta: good question
21:53:07 <Cale> Jicksta: That would be useful, actually.
21:53:23 <Jicksta> yeah. I'm very, very curious myself
21:53:42 <dons> speedwise, compiled haskell concurrency seems to be a bit faster, but erlang supports distributoin better. erlang uses message passing a lot, haskell has Chans, Parallel hints, parallel arrays, STM and other things.
21:54:14 <dons> the only speed benchmarks we know of are the two shootout benchmarks on concurrency
21:54:25 <siti> I think ghc needs a parallel GC
21:54:32 <Jicksta> does Haskell have an analog to Erlang's reloadable code?
21:54:39 <siti> and haskell needs more standard libraries for concurrency, some things are missing
21:54:46 <dons> Jicksta: yeah, but its more experimental, and not as pervasive as erlangs
21:54:52 <dancor> dolio: i thought (f . g) x was the same as f (g x), e.g. http://www.cs.arizona.edu/~collberg/Teaching/372/2005/Html/Html-12/index.html
21:54:54 <lambdabot> Title: CSc 372 - Comparative Programming Languages 12 : Haskell -- Composing Functions, http://tinyurl.com/36kn42
21:54:56 <dons> siti, oh, what kinds of things?
21:55:00 <shachaf> dancor: It is.
21:55:13 <shachaf> dancor: But (f . g) x y isn't the same as f (g x y)
21:55:16 <dolio> dancor: Yes, but (f . g) x y /= f (g x y)
21:55:26 <dons> erlang doesn't support large strings and binary files very well, we found out last week
21:55:35 <dons> while ghc haskell can process terabytes happily.
21:55:49 <Jicksta> hehe. I saw that on Dzone too
21:55:49 <siti> dons: e.g. splitting a job in to many threads with load balancing etc.
21:55:54 * shachaf was under the impression Erlang had good support for binary files.
21:55:58 <siti> I will try and get some code to show you an example
21:55:59 <dolio> Essentially, you need a (.) for each argument of g, I think.
21:56:00 <shachaf> I thought I'd heard that somewhere.
21:56:05 <dons> shachaf: it has good support for pattern matching on binary
21:56:07 <Jicksta> and someone actually retorted, claiming Erlang actually did handle those well
21:56:15 <Jicksta> not one to call the shot -- it's not an issue I'd deal with often
21:56:16 <dons> but loading large binary files into memory seemed to bang out at 300M on a recent thread
21:56:35 <dons> its certainly has bit patterns, which are more flexible that pattern guards  and Data.Binary
21:56:55 <dons> I suspect Data.Binary is faster than erlang though, for streaming binary data
21:57:09 <dolio> dancor: I've seen something that will let you do (f `comp` g) for g of more than one argument, but it involves some serious type hackery.
21:57:34 <Jicksta> it seems to also depend on the algorithm (and knowledge of Erlang under the covers)
21:57:40 <dons> definitely
21:58:03 <dons> here's a generic speed benchmark, http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=ghc&lang2=hipe
21:58:05 <hpaste>  siti pasted "nice thread function" at http://hpaste.org/1707
21:58:05 <lambdabot> Title: Haskell GHC benchmarks | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lang ..., http://tinyurl.com/28d6h2
21:58:11 <dons> so you can pretty much expect ghc to always be faster.
21:58:14 <Jicksta> for example, it's more efficient to store bytes into an array, and then reverse and convert it to binary at the very end...
21:58:20 <dolio> dancor: That is, the same 'comp' works for gs of various number of arguments. You can, of course, make comp1 comp2 ... without type hackery.
21:58:22 <dons> but whether its as  easy to reload code, distribute across many cluster nodes and so on
21:58:41 <Jicksta> instead of composing binary objects together...
21:58:51 <Cale> For shared-memory concurrency, GHC is getting quite good.
21:59:27 <dons> so HIPE erlang is around the speed of GHC on concurrent stuff , for sequential stuff its far behind, is probably what we could conclude from the shootout
21:59:31 <Cale> It'll be interesting to see how the data parallelism stuff goes if/when they end up adding support for distributed computation.
21:59:33 <dons> i think that would be fairly uncontroversial
21:59:49 <dons> Cale, yeah, there's other distributoin stuff already (e.g. the `ports' library)
22:00:14 <dons> we've written a few things to  run on the linux cluster here, a parallel monte carlo simulator, made up of tiny haskell nodes, for example
22:00:30 <dons> Jicksta: so what particular things were you looking at?
22:00:38 <Cale> dons: heh, I see you updated it just today?
22:00:44 <dons> yesterday, yep
22:01:16 <Jicksta> well, I have a hackery project coming up that requires dumbfounding speed...
22:01:27 <dons> do you have a lot of cores to play with?
22:01:31 <Jicksta> basically serving as a TCP proxy for a certain VoIP-related protocol
22:01:49 <dons> doesn't erlang only run in SMP on x86 too?
22:01:50 <Jicksta> not immediately...
22:02:17 <Jicksta> Erlang doesn't require SMP to my knowledge
22:02:20 <dons> so you need low level protocol parsing, binary data streaming
22:02:26 <Jicksta> nope
22:02:28 <Jicksta> plain text protocol
22:02:36 <dons> yeah, they tend to distribute separate erlang nodes
22:02:38 <Jicksta> proxying lines of text, actually
22:02:48 <Jicksta> the command delimiter is \n
22:02:53 <dons> so just fast strings? with the optoin to do things concurrently in the future?
22:03:16 <dons> Haskell bytestrings are much much faster than strings in erlang, if that's relevant.
22:03:20 <Jicksta> right... the idea is the switch/PBX connects to the proxy at localhost...
22:03:35 <Jicksta> the proxy then tries to find the best candidate to proxy the call handling to...
22:03:47 <dons> you might have libraries for some of the telecoms stuff already in erlang though, not sure.
22:03:51 <Jicksta> if the thing to which it's proxying goes down, it recovers cleanly and connects elsewhere
22:04:15 <Jicksta> well, there is a LGPL package that's similar to what I'm describing
22:04:22 <dons> it does sound like an erlangy job then : fault tolerant reloading, that kind of thing. 
22:04:24 <Jicksta> not so much a proxy -- more like a full app server
22:04:46 <dons> you probably could get a faster system in ghc haskell, though. so its a matter of how much you like haskell, i suspect :)
22:04:54 <Jicksta> hehe
22:05:02 <Jicksta> well, I certainly respect Haskell... never used it before
22:05:15 <Jicksta> I've been dabbling with Erlang and do enjoy it
22:05:25 <dons> well, its similar to erlang, nicer syntax, native code compilation, good concurrency
22:05:29 <Jicksta> though, if Haskell makes that case that it's 50% faster or something it'd justify using it instead
22:05:45 <dons> I think 50% faster for string processing would be not unreasonable
22:05:49 <dons> if the strings were big enough
22:05:50 <Jicksta> Erlang is compiled too by the way...
22:05:55 <Jicksta> not sure if it's native code or bytecode
22:06:07 <dons> yeah, i know, (see the benchmark link i posted)
22:06:22 <dons> but these dyamically typed languages suffer since they're hard to compile efficiently
22:06:31 <dons> and you insert all these runtime checks into the code, slowing things down
22:06:39 <Jicksta> yeah
22:06:43 <Jicksta> though look at smalltalk  :)
22:06:53 <dons> smalltalk and SBCL are rather good, yeah
22:06:53 <Jicksta> something like 40% the speed of Java.
22:07:02 <Jicksta> and five times faster than Python
22:07:02 <dons> java's slow though :)
22:07:08 <dons> pythons really slow :)
22:07:11 <siti> dons: that's what I was about to say ;)
22:07:24 <Jicksta> well, I'm a Ruby developer -- I know what slow code's like  :)
22:07:26 <dons> we tend to compare Haskell against C, for some reason
22:07:34 <Jicksta> sometimes it just doesn't f'ing matter, honestly :)
22:07:38 <dons> yeah
22:07:41 <Jicksta> except in cases when you're making a proxy, for example  :)
22:07:47 <dons> but you think performance will be important for this project?
22:07:57 <Jicksta> yeah, definitely
22:08:01 <siti> ghc is much much faster (will in my testing) when the minimum heap size is increased for the GC
22:08:27 <dons> avoiding GC is always good
22:08:28 <Jicksta> what does Haskell concurrency look like?
22:08:36 <dons> there's several forms
22:08:41 <siti> forkIO ;)
22:08:42 <Jicksta> in Erlang we just spawn a process, giving it a function
22:08:45 <dons> explicit threads, implicit threads, transactoinal memory
22:08:49 <dons> yeah, that's the basic form
22:08:51 <dons> :t forkIO
22:08:53 <lambdabot> Not in scope: `forkIO'
22:08:56 <dons> :t Control.Concurent.forkIO
22:08:58 <lambdabot> Couldn't find qualified module.
22:09:04 <Cale> :t Control.Concurrent.forkIO
22:09:05 * siti hits lambdabot
22:09:05 <dons> :t Control.Concurent.forkIO
22:09:07 <lambdabot> Couldn't find qualified module.
22:09:07 <lambdabot> IO () -> IO GHC.Conc.ThreadId
22:09:09 <Jicksta> does Haskell have green threads?
22:09:18 <Cale> *cough* two r's :)
22:09:21 <dons> lightweight threads, that will use other cores if you have them
22:09:33 <Jicksta> cool
22:10:08 <dons> see haskell versus erlang benchmarks here: http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=ghc&lang2=hipe
22:10:10 <lambdabot> Title: Haskell GHC benchmarks | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lang ..., http://tinyurl.com/28d6h2
22:10:46 <Jicksta> looking at that now...
22:10:47 <Cale> To go along with that basic form of concurrency, there are two systems for thread communication which are currently in GHC.
22:10:48 <dons> ?docs Control.Concurrent
22:10:48 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html
22:11:01 <dons> is the low level concurrency layer, good to get the best performance
22:11:22 <Jicksta> hmmm
22:11:33 <Cale> The first, which is simpler, is based on something called an MVar, which is a mutable cell that can be empty or full. Reading from an empty MVar or writing to a full one blocks.
22:11:43 <dons> there's lots of concurrency demos and so on haskell.org too, fwiw
22:12:05 <Cale> In terms of that, there are various simple structures like channels, quantity semaphores and so on
22:12:19 <Cale> Then there's a transactional thread communication library called STM
22:12:41 <Cale> STM actions mutate shared thread variables and act as if they occur atomically.
22:12:45 <Cale> and you can compose them
22:13:06 <Jicksta> well, since I've no immediate use for concurrency, perhaps the best solution would be to implement a very efficient Haskell proxy and, in the future as necessary, implement the concurrency
22:13:15 <Jicksta> so, I have to ask...
22:13:33 <Jicksta> are there any other languages that you may recommend that're faster than Haskell?
22:13:37 <dons> if you're just reading text data off a socket, yeah, i'd expect ghc to win.
22:13:47 <dons> hmm, ocaml is a good one, otherwise you're down to C or C++
22:13:55 <Cale> Or Clean, perhaps?
22:14:03 <dons> pretty dead project though
22:14:06 <Cale> hmm
22:14:10 <Jicksta> well, I'm staying away from C/C++
22:14:16 <Jicksta> not my idea of a high level language  :)
22:14:47 <dibblego> I know someone who is *convinced* that C is a high level language
22:14:53 <dons> right. Haskell or OCaml then. for text processing off sockets, I'd probably go with Haskell, because of bytestrings.
22:14:55 <Jicksta> oh, me too
22:15:03 <siti> well "high" is relative
22:15:09 <Figs> C and C++ are mid-level languages
22:15:17 <Jicksta> I was with Mark Spencer once and he exclaimed to me seriously "You know what I love about C? It's just so simple"
22:15:24 <dibblego> siti, that's my point as well, to no avail
22:15:24 <Cale> If you're going to use Haskell, you probably want to give yourself at least a little time to get accustomed. :) Even though lots of stuff should be familiar from Erlang, there will also be quite a lot of new ideas, I suspect.
22:15:48 <Adamant> using C is pretty simple. being correct with C is a fair bit harder
22:15:58 <Jicksta> right
22:16:05 <dons> that's true. you would want to learn it , write other programs, before betting the company on your haskell skillz :)
22:16:08 <Jicksta> well, at any rate I won't be doing much of the coding myself...
22:16:09 <siti> Jicksta: is he the guy that wrote asterisk? or am I getting confused?
22:16:09 <weitzman> Jicksta: SML compiled with MLton is pretty fast
22:16:15 <shachaf> Cale: Is Clean generally faster than Haskell?
22:16:24 <Jicksta> likely be pulling in a developer from the community for consulting work
22:16:33 <dons> shachaf: the Clean compiler seems to be rather good, yep.
22:16:36 <Cale> shachaf: It has a rather fast IO system, from what I've seen.
22:16:38 <Jicksta> siti: author of Asterisk, Gaim, L2TP, and others
22:16:42 <siti> ok
22:16:43 <Jicksta> CTO of Digium
22:16:48 <dons> shachaf: there is also a haskell to clean translator, but its about half and half there. some things get faster, others get slower
22:16:56 <Jicksta> "creator" I should say
22:17:14 <Cale> shachaf: unfortunately, not a very abstract IO system -- you pass the 'world' around explicitly.
22:17:16 <Jicksta> looking at the OCaml benchmarks
22:17:21 <siti> Jicksta: I have heard rather bad things about the asterisk code :p I have had a look at some modules and well... it's crazy
22:17:23 <shachaf> dons: Are the languages that close?
22:17:37 <dons> Jicksta: that's a good idea. if you're looking to do this stuff commercially, talk to the Haskell companies (like Galois) or seek consultants on the mailing list
22:17:40 <shachaf> Cale: Yes, that's about all I know about it. :-)
22:17:45 <dons> shachaf: indeed, clean is really a `fork' of haskell
22:18:00 <dons> well, its a fork that never merged back in. and then the community around it died
22:18:11 <weitzman> Jicksta: Plus MLton supports continuations, if you're into that kind of thing
22:18:13 <shachaf> dons: So they forked Haskell and took monadic IO out?
22:18:18 <shachaf> dons: Why?
22:18:31 <shachaf> dons: Just for performance, or for other reasons too?
22:18:34 <Jicksta> weitzman: no need whatsoever for continuations for this project...
22:18:38 <shachaf> dons: (Or is this an earlier Haskell?)
22:18:54 <dons> its  earlier. it didn't get merged into haskell , when all the other lazy pure research languages did
22:19:06 <dons> though the authors were on the original haskell comittee
22:19:22 <dons> its about 5 years older than ghc
22:19:23 <Cale> Haskell 1.0 didn't have monadic IO yet, iirc.
22:19:31 <Jicksta> found an interesting comparison... D is even faster than OCaml
22:19:43 <dons> oh, D yes, that's another option. C++ improved
22:19:58 <weitzman> Jicksta: Some people like having "cool" theoretical features around even if they serve no purpose
22:20:00 <dons> not really the same kind of language as erlang, haskell or ocaml though. so depends on what you like
22:20:14 <Jicksta> right
22:20:28 <shachaf> Isn't D a much lower level than O'Caml?
22:20:34 <dons> yes.
22:20:35 * shachaf has not looked much into it.
22:20:43 <dons> its a C++-ish 
22:21:00 <Jicksta> yeah. kinda takes features from C++ and Objective C
22:21:02 <dons> but designed, rather than growing in a bucket of primordial language soup
22:21:18 <Jicksta> though, they have the most retarded marketing... they say they match the productivity of Ruby
22:21:26 <dons> heh
22:21:30 <Jicksta> clearly they have NO IDEA what Ruby is beyond its name...
22:21:36 <glguy> lol, the productivity of ruby
22:22:53 <dons> Jicksta: do let us know how you go, and what you decide upon.
22:23:04 <Jicksta> I have a few months to make any decisions
22:23:05 <dons> if you pick haskell, there's people around here who'll happily help, or point you to consultants.
22:23:18 <dons> ah good. so you can get a feel for the design space
22:23:18 <Cale> Jicksta: and make sure you hang around here lots if you're learning Haskell, since we like beginners :)
22:23:26 <Jicksta> hehe  :)
22:23:33 <Jicksta> glad to see Haskell community is so supportive :)
22:23:34 <Heffalump> especially with sugar on ;-)
22:23:51 <bos> the guy behind D has an ... interesting personality.
22:24:26 <Korollary> and almost a total lack of familiarity with non-algol syntax languages
22:24:59 <bos> well, that could describe about 99.5% of programmers :-)
22:25:15 <Korollary> it shouldnt describe language designers
22:26:06 <Cale> "Note: all D users agree that by downloading and using D, or reading the D specs, they will explicitly identify any claims to intellectual property rights with a copyright or patent notice in any posted or emailed feedback sent to Digital Mars."
22:26:08 <weitzman> D has some language design ideas that are pretty interesting regardless
22:26:19 <Cale> That's a confusing remark :)
22:26:36 <dancor> in general is something like   mapM_ putStrLn ls   or   putStrLn $ unlines ls   better
22:26:50 <dancor> do you pay per io start
22:27:04 <Cale> dancor: I'd expect them to be similar.
22:27:04 <dancor> or are they the same
22:27:20 <shachaf> dancor: (You'd use putStr in this case, though that doesn't answer your question.)
22:28:01 <shachaf> dancor: How big is the list?
22:28:50 <dancor> shachaf: no matter, for any particular case i can just test it.  i was just wondering about paying per io
22:29:43 <dancor> another q: "why" can't i have   (++ "  " ++)   for   (\ x y -> x ++ "  " ++ y)
22:29:50 <dancor> but e.g. (*) is ok
22:29:54 <Cale> dancor: Well, mapM_ has a little more structure to it than just a plain putStr, so it's possible that you pay a little more.
22:30:55 <bos> dancor: the syntax for (*) is special.
22:31:06 <bos> to write what you want, you'd need to do this.
22:31:14 <bos> @pl (\ x y -> x ++ "  " ++ y
22:31:14 <lambdabot> (line 1, column 25):
22:31:14 <lambdabot> unexpected end of input
22:31:14 <lambdabot> expecting letter or digit, variable, "(", operator, ":", "++" or ")"
22:31:14 <Cale> @pl (\ x y -> x ++ "  " ++ y)
22:31:15 <lambdabot> (. ("  " ++)) . (++)
22:31:17 <bos> @pl \ x y -> x ++ "  " ++ y
22:31:17 <lambdabot> (. ("  " ++)) . (++)
22:31:24 <bos> @quote stereo
22:31:24 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
22:32:03 <bos> dancor: writing something like ("foo"++) or (++"foo") is called a section, and it's special, too.
22:32:04 <dancor> lolbdabot
22:32:38 <dancor> we should add ++"a"++ to the special things
22:32:43 <Figs> bbl
22:32:49 <bos> so (++) by itself is special, and ("foo"++) and (++"foo") are special, but those are the only special building blocks you get for this purpose. it doesn't generalise.
22:33:13 <bos> dancor: but the specialness isn't limited to the (++) operator.
22:33:16 <dancor> > (++"a"++"b") "c"
22:33:18 <lambdabot>  "cab"
22:33:31 <Cale> heh
22:33:37 <shachaf> > ("a"++"b"++) "c"
22:33:38 <lambdabot>      The operator `++' [infixr 5] of a section
22:33:38 <lambdabot>         must have lower preced...
22:33:43 <bos> you can have a section with a missing parameter on the left, or on the right, but not both.
22:33:47 <dancor> omg
22:33:49 <shachaf> It's just because ++ is infixr.
22:34:09 <dancor> how dare ("a"++"b"++) not work
22:34:13 <Cale> (++"a"++"b") = (++("a"++"b"))
22:34:23 <Cale> because ++ is right associative
22:34:33 <opqdonut> and (++) is not a section but a "functionized" version of ++ in essence
22:35:00 <Cale> You have to write (("a"++"b")++) if you want that
22:35:05 <dancor> is this a case where the arbitrarity of the result to the uninitiated is important for some coding safety
22:35:10 <dancor> or is it just completely insane
22:35:19 <dancor> and now all of you are too for being like "this is fine"
22:35:54 <Cale> Well, sections are hard to read when they get too complicated anyway
22:36:41 <shachaf> dancor: It makes sense, because the "new parens" in (++"a"++"b") are added as (++{"a"++"b"}), but in ("a"++"b"++) They're added as ("a"++{"b"++)}.
22:36:42 <Cale> (++) is deceptive too, because it's an associative operator
22:37:20 <dancor> shachaf: oh have no doubt that it makes sense, but so does perl
22:37:27 <Cale> > (3/7/) 5
22:37:29 <lambdabot>  8.571428571428572e-2
22:37:53 <shachaf> > ((3/7)/5)
22:37:54 <lambdabot>  8.571428571428572e-2
22:37:55 <Cale> > (3/7/) 1 :: Rational
22:37:56 <lambdabot>  3%7
22:38:14 <Cale> > (3/(7/1)) :: Rational
22:38:15 <lambdabot>  3%7
22:38:20 <Cale> heh, bad example
22:38:28 <Cale> > (3/(7/2)) :: Rational
22:38:29 <lambdabot>  6%7
22:38:42 <Cale> > (3/7/) 2 :: Rational
22:38:43 <lambdabot>  3%14
22:38:50 <shachaf> > (/7/2) 3
22:38:51 <lambdabot>      The operator `/' [infixl 7] of a section
22:38:51 <lambdabot>         must have lower precede...
22:39:05 <shachaf> > (\x -> x/7/2) 3
22:39:06 <lambdabot>  0.21428571428571427
22:39:09 <Cale> > (/(7/2)) 3
22:39:11 <lambdabot>  0.8571428571428571
22:39:50 <Cale> Which one would you expect (/7/2) 3 to mean? 3/7/2 or 3/(7/2) ?
22:40:14 <bos> march the 7th 2002!
22:40:25 <dancor> :: unsafeDateCoerce
22:40:25 <shachaf> Cale: It's infixl, so I'd say the first one.
22:40:25 <bos> ahem. sorry.
22:40:59 <shachaf> bos: No, 2nd of July, year 3.
22:41:00 <Cale> It would be doable, but I think it's sort of tricky to the point where it's worth making people write a lambda.
22:41:40 <shachaf> @pl \x -> x/7/2
22:41:40 <lambdabot> (/ 2) . (/ 7)
22:41:47 <shachaf> That's also pretty clear.
22:42:04 <Cale> People have also wanted funny syntax with "blanks" to avoid lambdas, but I don't think it's worth it.
22:42:29 <Cale> Like, lambda is there for a reason, after all :)
22:42:37 <shachaf> Cale: You mean in that "burn" language?
22:43:24 <shachaf> Cale: The "Business Objects Gem Cutter" email on -cafe is the only one I've seen.
22:43:27 <Cale> I mean like  (foldr (:) _ xs)  to mean  (\z -> foldr (:) z xs)
22:44:00 <shachaf> Cale: That's quite ambiguous.
22:44:17 * shachaf would probably not like that.
22:44:20 <Cale> yeah, there are lots of problems with stuff like that
22:44:46 <edward2> cale: do you think that rebinding Eq, And, Or, etc. so that you can say things like filter (isAlpha || isDigit) "foo12" would be too scary to end users? I already let you add functions etc, so it seems like the next logical step
22:45:14 <Cale> There were long discussions about things like that on -cafe a while back and the consensus was basically that they're too tricky.
22:45:19 <shachaf> filter (liftM2 (||) isAlpha isDigit) ['a','1',' ']
22:45:21 <shachaf> > filter (liftM2 (||) isAlpha isDigit) ['a','1',' ']
22:45:23 <lambdabot>  "a1"
22:45:25 <edward2> cale: =/
22:45:38 <Cale> edward2: sorry, that wasn't to you
22:45:39 <edward2> shachaf: yeah i know
22:45:43 <edward2> cale: whew =)
22:46:01 <edward2> shachaf: its just in my toy prelude i'm going with the most general type signatures for everything =)
22:46:24 <Cale> edward2: Well, go for it and see :)
22:46:41 <Cale> edwardk: Your monad stuff is already pretty scary :)
22:46:47 <edwardk> its already in, i just thought i'd check and see if there was some great moral reason others could think of against it ;)
22:46:50 <edwardk> heh
22:47:01 <shachaf> Cale: Which "monad stuff"?
22:47:04 <edwardk> the version i'm currently inclined to include is just generalized, not parameterized
22:47:10 <edwardk> shachaf: http://comonad.com/reader
22:47:24 <lambdabot> Title: The Comonad.Reader
22:47:25 <Cale> The strange  join :: m (m' a) -> m'' a  thing
22:47:28 <edwardk> type-parameterized monads by just letting the monad type vary
22:47:57 <edwardk> class ... => Bind m m' m'' where (>>=) :: m a -> (a -> m' b) -> m'' b
22:48:38 <edwardk> my current prelude just uses the oleg trick though, because it preserves type inference while the type-parameterized version requires the occasional 'go' to be inserted
22:49:20 <edwardk> that and mixing type-parameterized and generalized monads yields a LOT of typeclasses. to the point where you'd need template haskell to practical define an instance =)
22:49:44 <edwardk> which i'm actually kind of considering at this point given where my numerical type hierarchy has gone
22:49:54 <Cale> Hehe, I have the small satisfaction that I actually came up with Oleg's trick a while before him, but I didn't post it, because I thought it was too ugly.
22:50:05 <edwardk> fair enough
22:50:18 <Cale> Well, depending on whether he posted his trick immediately, of course :)
22:50:36 <edwardk> i just wish GHC's do sugar wasn't monomorphic in the monad type
22:51:06 <Cale> mm... I kind of think it makes sense for it to be
22:51:18 <edwardk> given the current implementations, sure =)
22:51:59 <Cale> You want to permit things like using STM actions as IO actions, right?
22:52:08 <edwardk> it kind of mucks up my examples like do x <- [1..]; y <- if even x then Just x else Nothing      mixing monad cases
22:52:22 <shachaf> edwardk: On that post, you have:
22:52:24 <shachaf> class Bind m m' m'' | m m' -> m'' where (>>=) :: m p a -> (a -> m' a) -> m'' a
22:52:29 <edwardk> er
22:52:41 <edwardk> i mucked up that version, it should be p p' p'' | p p' -> p''
22:52:55 <edwardk> i backed into it from the actual version, i'll fix
22:53:07 <edwardk> and whoa that one is messed
22:53:11 <Cale> Perhaps it would be better to have a class that defined how to lift one monad to another, and allow do-notation to insert lifts when appropriate instances of that class were available?
22:53:36 <Cale> The open-class problem is a little unsettling in that regard though.
22:53:53 <edwardk> what i'm currently using for my security monads which i'll blog up in a day or two as soon as i get all the lattice product stuff done is class Rebind m m' m'' ...   so that the normal monad sugar is untouched.
22:54:17 <edwardk> its not as fun, but it has the right properties and doesn't need ghc's behavior to change to be useful
22:54:36 <Cale> How does that work?
22:54:44 <edwardk> the rebind stuff?
22:55:27 <edwardk> one sec
22:55:33 <edwardk> i'll clean something up and you can peek
22:56:29 <edwardk> http://comonad.com/haskell/security-policy/src/Control/Monad/Security.hs
22:56:31 <lambdabot> http://tinyurl.com/3atx79
22:56:37 <edwardk> its not quite ready to check out
22:56:51 <edwardk> 'SecurityLattice' is the 'Rebind' in question
22:57:39 <edwardk> where I treat monads as security levels, with a meet-semilattice between different monads in a policy, and rely on the control over the export of the policy type to keep people from extending and subverting the policy
22:58:18 <edwardk> http://comonad.com/haskell/security-policy/test/Policy.hs   shows the current version in practice
22:58:46 <edwardk> what i'm doing now is defining various semilattice products to make it easier to actually define policies
22:58:59 <Cale> Who are you working for? :)
22:59:05 <edwardk> no one, its my own toy
22:59:22 <Cale> ah, "If I told you, I'd have to kill you", would be more interesting :)
22:59:37 <edwardk> I do work for a Raytheon subcontractor doing defense work though during the day though =)
22:59:43 <Cale> :)
22:59:52 <Cale> canHasStdio :)
22:59:57 <edwardk> =)
23:00:19 <edwardk> http://comonad.com/haskell/security-policy/test/Main.hs shows the actual kind of code that would use that policy
23:00:39 <edwardk> i was planning on blogging this up this weekend, but i haven't had time to resolve all of the 'how-to-cut-down-boilerplate' issues yet
23:01:14 <edwardk> so it'll probably be Tuesday before i get a nice writeup
23:01:34 <Cale> I wonder how well class aliases would help.
23:01:48 <Cale> Someone really really ought to implement them already :)
23:02:08 <edwardk> well, its one reason why my prelude is so much easier in my language than haskell
23:02:23 <edwardk> because dictionaries there are just polymorphic records, so you can define them all in one go usually
23:02:34 <edwardk> here it gets piecemealed when i break them apart
23:03:49 <edwardk> anyways, the basic idea is you can dump the policy into one module or package and never expose it, then the way the rest of the system is designed without cheating with unsafe tricks you can't access the data in a higher security level, so you get a form of security monad, except with compile time checks using the parameterization trick from the other day
23:04:15 <Cale> Speaking of potential defence contracts for Raytheon, have you seen that google video presentation on electrostatic containment fusion reactors?
23:04:17 <bos> i wonder where ABC got its use of the offside rule from. none of the original ABC papers is online, so i can't see if ISWIM is cited.
23:05:14 <edwardk> the only worries I can think of are Bjorn's standalone deriving clauses since i use newtypes everywhere so all the monads self-erase, various IO cast hackery, and the unsoundness of data families and newtypes. In the absence of those it appears to be impossible to subvert the type system to get at the data.
23:05:23 <edwardk> not yet
23:05:41 <shachaf> Why do people call ((->) e) the Reader monad, instead of the ((->) e) monad?
23:05:52 <shachaf> Isn't Reader the Reader monad?
23:05:53 <Cale> shachaf: they're isomorphic
23:06:14 <bos> because ((->) e) is hard to pronounce, and the two are the same thing.
23:06:39 <shachaf> Cale, bos: OK, it makes sense.
23:06:52 <shachaf> (Why can't it be called the (e ->) monad, by the way?)
23:07:04 <Cale> We should really allow sections for infix type constructors
23:07:18 <Cale> But that's something which was left out of the syntax
23:07:24 <edwardk> er and that version there won't compile because the test is broken, as it was written before i transformed policies into monads themselves in order to define lattice sums.
23:07:42 <edwardk> you can't construct partial infix applications at the type level shachaf, thats basically why
23:08:11 <shachaf> edwardk: It's just a matter of syntax, though.
23:08:20 <edwardk> not entirely because its not symmetric
23:08:35 <shachaf> edwardk: What do you mean?
23:08:44 <edwardk> you can define the functor (e->) but not the contrafunctor (->a)
23:09:07 <edwardk> because the latter isn't just 'partially' applied, its applied to a later argument.
23:09:24 <edwardk> so fully supporting it, would extend what the type system can do
23:09:37 * shachaf also wants flip and friends on the type level, though. :-)
23:09:56 <Cale> shachaf: You probably want type lambdas, but they really make type inference hard.
23:10:03 <edwardk> sure, one of the things i want in my toy language, the problem is they play hell with type inference and typeclasses, etc.
23:10:16 <shachaf> Cale: Yes, I do, and yes, I'd guess they would. :-)
23:10:34 <edwardk> basically you lose a lot of the benefits of haskell typeclasses with them =/
23:10:38 <dblhelix> shachaf: be careful what you ask for: we do not want to find ourselves lost in a system that requires higher-order unification ;-)
23:10:46 <edwardk> i can't seem to figure out how to get MPTCs to survive in their presence
23:11:36 <edwardk> actually there was a good paper on a limited form of them by neubauer and thiemann i think
23:11:46 <edwardk> http://citeseer.ist.psu.edu/neubauer02type.html   <-- ahh there it is
23:11:48 <lambdabot> Title: Type Classes With More Higher-Order Polymorphism - Neubauer, Thiemann (ResearchI ...
23:12:11 <Cale> Basically, the Haskell approach has been to extend things in ways which are mostly conservative, but which allow for fancy types, with an attempt to minimise the additional type signatures you have to use to get them.
23:12:18 <edwardk> showing how to deal with a limited form of inference by making a deterministic choice for flex-flex.
23:12:19 <dblhelix> edwardk: the problem with introducing a limited form of type lambdas is that you have to be very careful to keep the language understandable
23:12:24 <edwardk> yep
23:13:08 <shachaf> Why limited? Let's have a full Haskell on the type level! :-)
23:13:23 <edwardk> in my case i kind of let the type-level functions have their wicked way then build up typeclasses off of the fully reduced forms
23:13:24 <Cale> shachaf: I think Cayenne might do that
23:13:33 <dons> shachaf: makes the types too hard
23:13:36 <edwardk> shachaf: again, my goal more or less
23:13:38 <dons> and you can't do inference anymore
23:13:47 <dblhelix> there are nights that I don't sleep too well wondering if a language with gadts, mptcs with fds etc. is still suitable for novice programmers
23:14:00 <dons> fds, no.
23:14:12 <dons> gadts don't seem too bad
23:14:13 <edwardk> you can do inference, but its tricky to get the staging right  and you need a form of pointedness in the type checker to guarantee termination
23:14:15 <Cale> gadt's aren't so bad
23:14:24 <dblhelix> ASTs are a lot better indeed, especially for novices
23:14:51 <dons> i suspect associated types will be newbie friendly, in comparison to FDs
23:14:57 <dblhelix> still, what I like about Haskell 98 is that is can still envision it as the first programming language one learns
23:15:08 <dons> since its obvious how to add extra types to your class, and have themvary on a per-instance basis
23:15:21 * shachaf definitely counts as a novice. :-)
23:15:21 <Cale> dblhelix: Well, novices manage to learn perl.
23:15:34 <Cale> (somehow)
23:15:39 <dons> what novices don't know won't hurt them more than once a week, eh? :)
23:15:43 <dblhelix> Cale: why are you trying to depress me? ;-)
23:16:03 <Cale> hehe
23:16:03 <edwardk> My current approach is if the function is unpointed then you can use it at the type level, if it isn't the typechecker will give it a window in which to run speculatively to a normal form, and if it fails I give up Cayenne style.
23:16:05 <dblhelix> dons: I used to think that too... and maybe I still do
23:16:17 <dons> dblhelix: seen the hackathon page yet? (or did i mention that already?) 
23:16:22 <dons> http://haskell.org/haskellwiki/Hac_2007_II
23:16:24 <lambdabot> Title: Hac 2007 II - HaskellWiki
23:16:37 <Cale> dblhelix: What do you think of the idea of 'language levels'?
23:16:42 <dblhelix> dons: I've seen it... still can't make it though
23:16:58 <edwardk> where polymorphic unpointed total functions can in general be used in what i would have to call a "poly-sorted" fashion.
23:16:58 <dblhelix> Cale: we've been seriously considering it to be incorporated in helium
23:17:04 <dons> we need someone from Utrecht ! :)
23:17:13 <edwardk> problem is i lose phantom types =(
23:17:16 <dons> you guys still write haskell, right? :)
23:17:25 <dons> can't let chalmers take over everything
23:17:27 <dblhelix> dons: afaik all the utrecht guys are leaving after cufp
23:17:48 <dblhelix> most of us arrive before ifl already, you know
23:17:50 * shachaf wishes more (any) Haskell-ish events were around here.
23:17:51 <dons> yeah
23:18:01 <shachaf> I guess Oregon counts as pretty close.
23:18:06 <Cale> I think it might be worthwhile have a -101 flag in GHC. While we're at it, let's provide for multiple base libraries, so that progress can be made while retaining compatibility.
23:18:12 <Cale> to*
23:18:25 <dblhelix> dons: we still write haskell, indeed
23:18:47 <dons> just teasing. ;)
23:18:55 <dblhelix> I know
23:18:56 <Cale> Southern Ontario needs more Haskell events :)
23:18:57 <dblhelix> :-)
23:19:12 <shachaf> Cale: Are you sure having separate libraries is a good idea?
23:19:25 <bos> heck, we can't even manage any haskell events in the san francisco area, and we have about a dozen haskellers here.
23:19:38 <Cale> shachaf: Well, it's better than being stuck with the Haskell 98 prelude forever.
23:19:41 <dons> we'll have to do something about that, bos. 
23:19:46 <shachaf> Cale: A "learning mode" is one thing, but actually using Haskell with two very different libraries is another.
23:19:47 <dblhelix> shachaf: helium already has two preludes: one with overloading, one without
23:20:09 <dblhelix> but admittedly, in some cases having two preludes also adds to the confusing
23:20:17 <dblhelix> it's really hard to get these things right
23:20:18 <shachaf> Cale: For example, if fmap was called map in one but not the other, it would break a lot of code.
23:20:27 <shachaf> Cale: And that's just a simple example.
23:20:34 <Cale> There's a fundamental conflict of interest between providing compatibility and developing the language.
23:20:43 <Cale> shachaf: Of course, that's the point.
23:20:53 <Cale> shachaf: Provide compiler flags to choose.
23:20:59 <dblhelix> jurriaan is sliding towards empirical research more and more... just to find out what is effective and what is not when teaching haskell to undergraduates
23:21:11 <shachaf> Cale: But what if one piece of code does one thing and another does another?
23:21:35 <shachaf> It'd be like working with multiple browsers...
23:21:59 <Cale> Well, you just agree to version things.
23:22:20 <shachaf> Cale: (I do think it's a good idea, though, if it can be made to work.)
23:22:38 <Cale> If I want to write in Haskell 2 and you want to write in Haskell '98, then maybe we can't load each other's modules.
23:22:50 <Cale> But then again, perhaps something could be made to work.
23:23:06 <Cale> Still, kind of doubtful that the classes would work out.
23:23:58 <Cale> We'll likely need something soon along these lines anyway if Haskell 98 is going to co-exist with Haskell'.
23:24:30 <shachaf> How big a change is Haskell'?
23:24:57 <Cale> Not big relative to stuff already in GHC, but I'm fairly sure some breakage is being considered.
23:25:10 <Cale> It's supposed to mostly be a subset of what's already in GHC.
23:25:22 <shachaf> Will it have MonadZero/monad comprehensions?
23:25:36 <Cale> So no new fancy untested record system, for instance.
23:25:42 <Cale> I don't think that's been decided.
23:25:51 <Cale> But it would be nice.
23:26:00 <Cale> I really hope it has MonadZero.
23:26:52 <Cale> Personally, I think we should do one major world-breaking change and not too far into the future, because Haskell is getting more popular, and this sort of thing only gets harder and harder to do.
23:26:55 <shachaf> Will map/fmap/(.)/mapMaybe/(<$>)/etc. be consolidated?
23:26:55 <opqdonut> monad comprehensions <3
23:27:19 <opqdonut> shachaf: consolidated how?
23:27:28 <shachaf> opqdonut: They're all the same function.
23:27:33 <Cale> Then again, major world-breaking changes might be just the thing to bring popularity down ;)
23:27:44 <opqdonut> shachaf: yeah they're all fmap :)
23:27:53 <opqdonut> i think the multiple names aren't a problem
23:28:06 <Cale> I think we should keep (.) and map, but have them both mean fmap.
23:28:13 <shachaf> opqdonut: Will they all have type (Functor f) =>, at least?
23:28:26 <Cale> Simply because sometimes you want infix and sometimes you want prefix.
23:28:50 <shachaf> Will the class hierarchy be Functor => Applicative => Monad?
23:29:03 <Cale> shachaf: I think these are all unresolved questions.
23:29:06 <opqdonut> that'd be nice
23:29:29 <shachaf> Cale: These are just various changes I've heard rumors of, that would be nice to see.
23:29:57 <Cale> In the current draft, it looks like the Monad class hasn't been touched.
23:30:16 <Cale> neither has Functor
23:30:25 <opqdonut> where is the current draft?
23:30:31 <Cale> http://darcs.haskell.org/haskell-prime-report/report/haskell-report-html/index.html
23:30:34 <lambdabot> Title: The Haskell Prime Language Report, http://tinyurl.com/2pdmj9
23:31:34 <shachaf> Hmm, are all the modules still flat (Monad instead of Control.Monad)?
23:32:24 <sjanssen> I don't think the report has been changed much at all
23:33:31 <Cale> aha
23:33:34 <Cale> http://hackage.haskell.org/trac/haskell-prime/wiki/Status%27
23:33:35 <lambdabot> Title: Status' - Haskell Prime - Trac
23:33:50 <Cale> That lists the Definitely-in and Probably-in changes.
23:34:01 <Cale> Mostly pretty uncontroversial stuff :)
23:34:21 <edwardk> cale: i'm currently just using (.) in my toy prelude
23:34:54 <edwardk> @type <$>
23:34:54 <Cale> edwardk: The trouble comes when you want to write map f in the middle of a chain of compositions
23:34:56 <lambdabot> parse error on input `<$>'
23:35:00 <shachaf> @ty (<$>)
23:35:02 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
23:35:07 <shachaf> (<$>) = fmap
23:35:19 <edwardk> er yeah =)
23:35:22 <Cale> stuff . (f .) . otherStuff looks kind of strange
23:35:24 <shachaf> @src (<$>)
23:35:24 <lambdabot> f <$> a = fmap f a
23:35:31 <Cale> or you could do  (.) f
23:35:35 <Cale> but that's also ugly
23:35:39 <edwardk> ok, i can accept map as a prefix .
23:35:43 <Cale> Sometimes you really want the prefix one.
23:36:24 * shachaf sees how code could get confusing if (.) is fmap. You'd have to be careful...
23:36:36 <edwardk> i rather like the resulting code though
23:36:56 <shachaf> edwardk: Yes, it's nice.
23:37:31 <edwardk> ok, map is in my toy prelude but its explicitly defined outside of the Map typeclass so it has to mean the same as (.)
23:38:10 <shachaf> edwardk: Map = Functor?
23:38:36 <edwardk> (Map and Functor are currently separate) Map is the restricted version class Map f a b where (.) :: (a -> b) -> f a -> f b
23:38:47 <edwardk> so you can do restricted-functor tricks
23:39:40 <Cale> There are also very strange things which can happen due to associativity.
23:39:44 <edwardk> i may roll it back together
23:40:04 <Cale> But it is a cool thing. :)
23:40:08 <shachaf> Cale: I hadn't thought of that. fmap isn't associative, is it?
23:40:17 <Cale> shachaf: not at all
23:40:23 <edwardk> thats what parens are for =)
23:40:32 <Cale> But (.) for the (e ->) functor is.
23:40:35 <shachaf> Cale: Yes, that wouldn't make any sense. :-)
23:41:26 <edwardk> the lack of associativity for fmap is the first good reason against joining everything that looks like it together that i've seen.
23:41:46 <Cale> yeah, it's the only one I could come up with
23:41:52 <shachaf> edwardk: I'd agree.
23:42:18 <Cale> Certainly at *least* map should be functor application
23:42:41 <dolio> @quote bulat
23:42:41 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
23:42:44 <Cale> Function composition and functor application are basically the two most important operations in functional programming.
23:42:59 <opqdonut> and they can be viewed as the same operation, right?
23:43:06 <edwardk> yeah
23:43:07 <Cale> While it's *really* nice that they can be seen as the same thing, one wonders if they're too important to be unified.
23:43:15 <edwardk> right now i think i'll leave them conflated though
23:43:21 <opqdonut> Cale: yeah it could be confusing
23:43:21 <dolio> @remember bulat instances are standard answer. they are as viruses, imperceptibly filtering through any import lists :)
23:43:22 <lambdabot> Done.
23:43:41 <opqdonut> > fmap (+1) (+2) $ 0
23:43:43 <lambdabot>  3
23:44:19 <opqdonut> ghci throws me a     No instance for (Functor ((->) a))
23:44:33 <edwardk> opqdonut :m + Control.Monad.Reader
23:44:51 <opqdonut> ah, Reader defines all those ((->) r) instances?
23:44:54 <shachaf> edwardk: Not Control.Monad.Instances?
23:45:12 <edwardk> er. oh yeah did it move?
23:45:56 <edwardk> looks like its there now
23:46:06 <shachaf> Can someone give me an example of a mostly-trivial comonad (Identity is completely trivial, but anything else, like the [] or Maybe monads)?
23:46:19 <edwardk> shachaf ((,)e)
23:46:37 <edwardk> extract (e,a) = a
23:46:47 <edwardk> duplicate (e,a) = (e,(e,a))
23:47:00 <dons> shachaf: http://www.eyrie.org/~zednenem/2004/hsce/Control.Comonad.html
23:47:19 <dons> some here too http://www.cs.helsinki.fi/u/ekarttun/comonad/
23:47:19 <lambdabot> Title: Comonads and Haskell
23:47:28 <edwardk> extend ea@(e,a) f = (e,f ea)
23:48:18 <Cale> Oh, one thing I should point out to everyone about monad comprehensions. If they get added, I think they really ought to have a new kind of defaulting, like that for the Num class.
23:48:31 <shachaf> Cale: For lists?
23:48:36 <Cale> Right.
23:48:37 <Figs> hi
23:48:38 <Figs> me again
23:48:43 <shachaf> Cale: That makes sense.
23:49:04 <edwardk> if monad comprehensions go in, i think the same flag should let you use more general [foo..bar] enums for arbitrary MonadPlus instances ;)
23:49:05 <Cale> Their removal last time was due to the fact that students would type in monad comprehensions which you couldn't actually tell were list comprehensions and get confusing errors.
23:49:16 <Figs> I have more weird left-recursion
23:49:24 <Cale> edwardk: This is something that I'm actually not too keen on, for some reason.
23:49:29 <Nopik> hi there..
23:49:38 <Nopik> i have small problem installing libraries
23:49:39 <shachaf> Figs: When will you rewrite all this in Haskell? :-)
23:49:47 <Cale> edwardk: Lists are very very special in a way that MonadPlus instances aren't necessarily.
23:49:48 <Figs> when I understand haskell
23:49:48 <edwardk> its consistent with the changing of [...] to support arbitrary monads
23:50:00 <Cale> edwardk: That's true.
23:50:05 <Nopik> i wanted to use gd library.. its setup says that DAta.Binary.Base cannot be found.. i figured out that fps library do have this...
23:50:07 <Figs> believe me, it's not much fun writing this in C++ :)
23:50:16 <Figs> but I need to make progress
23:50:20 <Nopik> then i setup configure/build/install fps library, all of it went correctly
23:50:20 <shachaf> @where binary
23:50:21 <lambdabot> http://www.cse.unsw.edu.au/~dons/binary.html
23:50:31 <Nopik> now gd still says that Data.ByteString.Base cannot be found
23:50:32 <edwardk> and could make for some really nice Set comprehensions =)
23:50:34 <Cale> edwardk: However, it's easy enough to write  option = msum . map return  and use that :)
23:50:39 <edwardk> when you add in restricted monads
23:50:57 <Cale> edwardk: I really wish there was a better way to do restricted monads.
23:50:59 <Nopik> run setup with -v reveals the ghc command which it is using
23:51:03 <Figs> I think I might have a weird scheme that would allow me to switch what type of parser I am using
23:51:12 <Figs> basically, let's say I have a pattern like
23:51:14 <Cale> edwardk: Without the loss of naturality guarantees.
23:51:21 <edwardk> well, one reason why i like the excessively general versions of things is they don't require a degree in advanced mathematics to understand what they do when they work =)
23:51:22 * shachaf wonders if monad comprehensions should use some other syntax than [], which feels like lists.
23:51:23 <Figs> M = ref(M)|E >> T
23:51:24 <Nopik> when i run the command manually, i get the same error.. but it includes -hide-all-packages argument.. when i remove it, it works
23:51:27 <Nopik> but not from setup
23:51:35 <Figs> err
23:51:39 <Nopik> any ideas?
23:51:40 <Figs> M = (ref(M)|E) >> T
23:51:43 <Figs> make it more clear
23:51:46 <Nopik> or should i use the binary library?
23:52:06 <edwardk> shachaf: everything else is taken =/
23:52:13 <shachaf> Nopik: What program are you using, that depends on the library? (And which version of GHC?)
23:52:19 <Cale> edwardk: Er, except that, let's say you have a monad instance which doesn't obey the monad laws -- those can be *really* confusing.
23:52:22 <Figs> if you were trying to do ETTTTT.... it would basically fail
23:52:30 <Figs> it'd just match ET
23:52:37 <edwardk> shachaf: i ran into the same issue in my toy language. i had no symbols left in the ascii character set, so i started having to reuse notations
23:52:52 <shachaf> edwardk: Unicode to the rescue!
23:52:54 <Nopik> shachaf: i am trying to install gd library (as i want to use it in my own programs), ghc 6.4.2
23:53:10 <shachaf> Nopik: GHC 6.6 might make it easier, if you can do that.
23:53:13 <Cale> edwardk: To see this, you only need to consider what happens when the monad laws fail. :)
23:53:13 <edwardk> cale: well the writer should be shot, then strung up as an example to all those who profane the monad laws =)
23:53:18 <Figs> but you could say, enable for that pattern a specific type of rearrangement
23:53:25 <Figs> like
23:53:30 <Cale> edwardk: I think losing naturality could be even worse.
23:53:35 <Figs> check_left( sequential_pattern )
23:53:40 <edwardk> unless it breaks it only in minor ways like Data.Set ;)
23:53:46 <Cale> edwardk: Imagine a 'bind' that did something different for Integers :)
23:53:53 <Nopik> shachaf: i'll see if my distro includes it ;p
23:53:59 <Figs> that would start from the end of the string working <--- to match the string in reverse
23:54:01 <shachaf> Nopik: Which distribution?
23:54:08 <edwardk> cale: data families probably already have that for you ;)
23:54:16 <Figs> until it gets one that goes to the start of the string or fails
23:54:35 <Nopik> shachaf: gentoo
23:54:44 <Figs> shachaf, does that make sense?
23:54:57 <shachaf> Nopik: I'm sure you'll fine it.
23:55:07 <shachaf> Nopik: Might take a while to compile, though.
23:55:09 <Cale> edwardk: hmm... I somehow doubt it's possible to write an instance of Monad for data families as it stands
23:55:22 <shachaf> s/fine/find/ -- I find it surprising that I did that.
23:55:43 <Figs> the alternative is to check right recursion first
23:55:47 <Figs> and then check left recursion after
23:55:56 <edwardk> even so if its imposible to write directly, i think its possible for it to delegate some aspect of a computation to something that involves them
23:55:56 <Nopik> shachaf: yeah, i tried to compile ghc 6.4.2, but given up and installed precompiled version.. now i see that precompiled is available for 6.4.2 only, and 6.6.1 is available in sources, but marked as unstable.. lets try
23:56:00 <Figs> or pray I can think of a way to translate one into another
23:56:01 <Figs> :)
23:56:15 <shachaf> Figs: Why are you asking me?
23:56:40 <Figs> I thought you knew?
23:56:57 <shachaf> Figs: Knew what?
23:57:04 <Figs> what I'm doing :P
23:57:42 <shachaf> Figs: Probably not... Do you have a latest-and-greatest @paste?
23:58:01 <Figs> I don't have any recent pastes
23:58:04 <Cale> edwardk: data instances are always monomorphic applications of the type constructor, right?
23:58:15 <Figs> unless you want me to call up my math example from earlier
23:58:50 <shachaf> Figs: What are you trying to do now?
23:59:10 <Figs> I'm trying to figure out how I can make things like
23:59:17 <Figs> M = (M|E) >> T
23:59:18 <Figs> work
23:59:25 <quicksilver> Cale: is it right that a given 'Applicative', if it is in fact a monad, is uniquely so? I.e. at most one bind definition can be compatible with a given <*> definition?
23:59:27 <edwardk> i'm not so well acquainted with them, i just remember some weirdness about using them to delegate out special handling of different particular cases
23:59:35 <Figs> which is equivalent to E >> T*
23:59:37 <Figs> err *T
23:59:56 <edwardk> quicksilver: there are multiple valid applicative instances for list
