00:00:25 <wli> Multicore is not so interesting from the webapp perspective but it's a more interesting form of result.
00:00:26 <vincenz> it's a shame that nowadays multicore systems are not representative of the future :(
00:00:34 <vincenz> shared memory will not last long
00:00:39 <vincenz> and the concept of NoC isn't in systems yet
00:00:40 <wli> vincenz: NUMA?
00:00:48 <wli> vincenz: NoC?
00:00:49 <dons> you hvae some inside information, vincenz ?
00:00:59 <dons> i think we might have NUMA for a while yet.
00:01:35 <wli> We'll have NUMA until it gets to the point where it's too nasty for operating systems.
00:01:51 <vincenz> Sorry
00:01:52 <vincenz> ssh lag
00:01:54 <vincenz> dons: yes I do
00:01:57 <vincenz> dons: I remember at imec, remember?
00:02:09 <vincenz> Networks on chip are the future
00:02:14 <vincenz> and shared memory is not a scalabble model
00:02:21 <wli> vincenz: My more interesting ideas are probably the sorts of problems to attack.
00:02:33 <wli> vincenz: It is. There are such things as cache directories.
00:02:36 <vincenz> for networks on chip they're reinventing network protocols as you want guaranteed worst time delivery and stuff like that
00:02:54 <vincenz> wli: cache coherency will bite you
00:02:55 <mgsloa2> I agree
00:02:57 <wli> vincenz: What doesn't scale are operating systems. The hardware scales just fine, when constructed non-idiotically.
00:02:59 <vincenz> wli: especially when your cores are far away
00:03:07 <pejo> There's a fair amount of research conducted on real time networking stuff though, not a new problem.
00:03:09 <vincenz> like opposite sides of the die
00:03:14 <vincenz> pejo: NoC are a new domain
00:03:19 <vincenz> pejo: and only popped up like 5-6 years ago
00:03:24 <vincenz> there was a talk about the history of em at DATE
00:03:37 <wli> vincenz: Cache directories, blah blah blah. It's all rather dull and long-since worked out.
00:03:43 <mgsloa2> I think you can structure an operating system such that it works quite well on a network
00:03:45 <vincenz> wli: again, no, doesn't scale
00:04:01 <|Steve|> mgsloa2: Like Medusa?
00:04:01 <vincenz> wli: Besides I'm talking close memory, I'm not talking harddrives
00:04:04 <vincenz> I'm talking L1 and L2
00:04:18 <wli> vincenz: It does scale. SGI has been routinely building such systems since the early 1990's.
00:04:39 <wli> vincenz: The hardware does fine. Operating systems do not.
00:05:07 <mgsloa2> |Steve|: I'm thinking more of a desktop OS
00:05:33 <vincenz> wli: for multicore?
00:05:45 <vincenz> wli: or multichip?
00:06:05 <wli> vincenz: Largely multichip. Multicore has been integrated smoothly into them.
00:06:10 <vincenz> wli: the communication bottleneck of 100 cores on a root-bus accessing main memory = high
00:06:30 <vincenz> you want a spread memory architecture
00:06:36 <vincenz> which means not all address space is accessible by all chips
00:06:45 <|Steve|> mgsloa2: I'm not sure what how you'd classify medusa (apart from an old OS experiment).
00:06:56 <vincenz> (well they might obviously shadow... to reuse the actual addresses, but data will not be same(
00:07:01 <wli> NORMA is ancient; the Intel Paragon did such in the multichip context.
00:07:10 <mgsloa2> |Steve|: ah, well, I don't know much about it
00:07:40 <|Steve|> I just looked up a summary of it from my grad OS class (I kept my notes online for some reason).
00:07:44 <wli> The operating system burden is incredible, though. I'm not sure it actually helps anything.
00:08:14 <wli> My thought is that there are just plain limits as to what can be usefully constructed.
00:09:43 <vincenz> wli: you read my blog article?
00:09:54 <mgsloa2> My idea is that responsibility is distributed among probably heterogeneous modules, and they are interlinked on the network.  The main uniting tech would be a protocol for capability querying and transfer.
00:10:24 <vincenz> wli: and I've just taken a look at a presentation of the NORMA system, not sure that still holds in modern day memory architectures, the penalty is much higher
00:10:34 <vincenz> so I'm not fully convinced but I'll have to mull about it a bit more
00:10:42 <vincenz> wli: feedback on http://notvincenz.blogspot.com/2007/04/observations-from-date-2007.html welcome
00:10:44 <lambdabot> Title: lambda.oasis: Observations from DATE 2007, http://tinyurl.com/yw4e7z
00:11:53 <wli> vincenz: FWIW I suspect even 256 cores is not so big a deal, apart from actually getting it all crammed into a module. 2-level hierarchical NUMA with 16-way branching factors is not even interestingly difficult to get to perform in the multichip context.
00:12:33 <vincenz> wli: most likely it will not be that architecture
00:12:37 <vincenz> most people were going for tile-based approach
00:12:45 <vincenz> each tile has a core, some custom hardware and some memory
00:12:49 <vincenz> and you have a mesh between those tiles
00:12:55 <vincenz> (and obviously you have your main memory)
00:13:35 <wli> Multichip doesn't start to get difficult until > 256 AIUI.
00:13:49 <vincenz> I think that number is rather arbitrary :)
00:13:58 <wli> I highly suspect multicore works relatively analogously.
00:14:07 <slava> i need one of  those 256 cpu machines to make darcs fast enough
00:14:21 <vincenz> wli: multichip was interesting for embarassingly parallel problems
00:14:34 <vincenz> wli: manycore will have to solve problms that are not embarassingly parallel if we want to continue scaling
00:14:38 <wli> vincenz: Experience from Linux kernel bugs/etc.
00:15:07 <wli> I don't do much hacking on them directly.
00:15:45 * vincenz is interesting to see what will hpapen
00:15:49 <vincenz> we're still in multicore region
00:15:54 <vincenz> manycore will be rather different...
00:16:07 <slava> will darcs still take 10 minutes to push 3 patches?
00:16:09 <vincenz> (not to mention the whole concept of failing nodes..)
00:16:16 <vincenz> slava: ask on #darcs?
00:17:00 <wli> vincenz: See kernel/profile.c in the 2.6.22 Linux kernel for an example of a method required to get a 512 CPU machine to boot, and compare to the same implementation in 2.4.x
00:17:57 <vincenz> wli: it's more than just having many cpus, the communication infrastructure is going to fundamentally change
00:18:08 <vincenz> wli: not to mention that cores won't be as reliable as cpus
00:18:37 <vincenz> but thanks for the pointer
00:18:42 <wli> vincenz: It has quite a bit to do with communication between CPU's.
00:18:52 <wli> vincenz: I wrote the new version. ;)
00:18:58 <vincenz> wli: my point is, the systems I'm talking about aren't out yet :)
00:19:49 <mgsloa2> One big issue, of course, is security and logging
00:20:10 <mgsloa2> lets say you're running untrustworthy code on a module, etc, etc
00:20:29 <mgsloa2> So really you need to do this stuff all VM/JIT
00:21:50 <vincenz> wli: btw, one thing that I think will happen is that eople will have to accept to have more runtime system in the hardware.  People used to not want virtual memory "cause it's slow", I think if we go to manycore, people will have to accept another layer of something
00:22:04 <vincenz> wli: not sure whta that something will be, could be hardware transactional memory, or something else
00:22:49 <vincenz> wli: shall we move to #oasis, since this is a bit OT?
00:23:02 <vincenz> wli: while we might not agree on all points, I find your povs interesting
00:23:16 <glguy>  doesn't much matter... you arne't interupting anyone
00:23:28 <pejo> vincenz, how long ago was it that people didn't want virtual memory?
00:24:06 <vincenz> pejo: quite a while?
00:25:43 <vincenz> before my time :)
00:26:18 <vincenz> anyways, my view is mostly from the embedded system (no, not the little things in your car to make your window move, more like pdas, cellphones, etc)
00:26:26 <vincenz> though you see that the two worlds are merging
00:26:38 <vincenz> (heh. intel says "TI is running behind", TI says "Intel is running behind" ) :P
00:27:01 <vincenz> (I mean intel got lame into the energy game and the multicore game, multicore's been a reality for a while in embedded systems, more specifically heterogeneous)
00:27:25 <Cale> Morning! :)
00:27:29 <vincenz> hey cale
00:27:30 <glguy> agreed!
00:27:40 <vincenz> s/lame/late
00:28:51 <Cale> I'm surprised at the lack of implementations of visual unix shell scripting tools. It seems like such an obvious thing to do, and has been done repeatedly for audio.
00:29:55 <wli> vincenz: It's also notable that I did cpumask_t (changing the type of a CPU bitmap from unsigned long to struct { unsigned long [...] }). Granted, I wasn't the first to do it, but I was the first to do the gruntwork of sweeping all arches.
00:29:58 <dons> anyone got haskell running on their phone or pda?
00:30:39 <vincenz> wli: *nods*
00:30:46 <vincenz> wli: no idea what cpumask_t does :)
00:31:05 <mgsloa2> Cale - indeed
00:31:12 <wli> vincenz: It's a data structure representing sets of cpus.
00:31:16 <mgsloa2> of course, something more haskell would be more fun
00:31:45 <vincenz> wli:  I see
00:31:52 <wli> vincenz: It meant mainline Linux was at long last able to run on > 64 CPU's.
00:31:58 <dons> did oh, yes, shapr has a nokia 770, and syntaxninja has a nokia 800, which stepcut got ghc compiling for at one piont
00:32:01 <vincenz> wli: :)
00:32:41 <wli> vincenz: I'm *that* wli.
00:32:58 <vincenz> Which one?
00:33:05 * vincenz isn't a linux head
00:33:13 <wli> vincenz: The Linux one.
00:33:15 <vincenz> I like coding on algorithmics, never been a systems person :)
00:33:26 <vincenz> for me, if the oso works, I'm happy :)
00:36:14 <wli> For me, Linux is a job.
00:36:21 * vincenz nods
00:36:31 <wli> The example I just gave is one where in Haskell it'd be totally trivial.
00:37:38 <pejo> wli, you need a job hacking House. :-)
00:37:43 <wli> Changing out the representation of a data structure isn't even remotely interesting in anything but languages like C, and it can be made uninteresting then.
00:39:07 <wli> pejo: Interesting as it sounds, I'm sort of used to the lifestyle this allows me.
00:42:42 <wli> I can see why I might be able to make a valuable contribution to House, of course.
00:42:59 <wli> The bulk of the work I've done in Linux is tracking down and fixing space leaks.
00:43:03 <zeeeee> was `forever' introduced recently into the ghc codebase (post-6.6)?
00:43:54 <zeeeee> i guess it was...i'm looking at it in the darcs source, but it's not in my 6.6.1.
00:45:42 <vincenz> @hoogle forever
00:45:42 <lambdabot> No matches found
00:45:55 <vincenz> forever = sequence_ . repeat
00:45:55 <vincenz> ?
00:46:03 <vincenz> :t sequence_ . repeat
00:46:05 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
00:46:10 <zeeeee> yeah, that's what i do now
00:48:32 <Cale> 6.8 will be nice, I think :) Lots of rather good stuff has been put into HEAD.
00:48:36 <wli> Hmm, GADT's look very interesting.
00:49:18 <wli> I've still not dredged up any useful information on constraint-based type inference.
00:49:54 <zeeeee> i wonder what's new in it
00:51:21 <zeeeee> i miss hwn
00:51:32 <ivanm> dammit, I enabled the pretty symbols for haskell code in emacs, and now my code is borked :s
00:51:39 <Cale> Well, there's the new debugger, and some rather nice type system extensions
00:52:11 <zeeeee> oh god how could i forget about the ghci breakpoints
00:52:18 <Cale> Basically, it's possible to get class restrictions to mean what everyone has always wanted them to mean in data declarations.
00:53:13 <Cale> and indexed data types
00:53:33 <Cale> (data families)
00:54:08 <vincenz> Cale: you mean AT?
00:54:27 <Cale> AT is closely related. I think it's the same mechanism underneath.
00:54:56 * vincenz nods
00:55:40 * dblhelix really looks forward to having ATSs
00:56:21 <Cale> I wish I had a multi-core system so that I could really properly look forward to the data parallelism stuff :)
00:57:07 <zeeeee> data parallelism? you mean 'had a gpu'?
00:57:15 <Cale> no
00:57:23 <Cale> It's for SMP machines
00:57:32 <zeeeee> oh, interesting
00:57:43 <mgsloa2> If I was a billionaire... I'd probably hire a load of people, and endeavor to make a modular, manycore computer with functional tendencies
00:57:49 <Cale> http://haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
00:57:50 <lambdabot> Title: GHC/Data Parallel Haskell - HaskellWiki
00:58:12 <zeeeee> do you have any pointers for the type system extensions?
00:58:38 <dons> it maps onto gpus though, too
00:59:07 <Cale> dons: is there a real plan to implement support for using GPUs to do Haskell computation?
00:59:35 <Cale> http://hackage.haskell.org/trac/ghc/wiki/TypeFunctions
00:59:36 <lambdabot> Title: TypeFunctions - GHC - Trac
00:59:51 <Cale> http://haskell.org/haskellwiki/GHC/Indexed_types
00:59:52 <lambdabot> Title: GHC/Indexed types - HaskellWiki
00:59:52 <pejo> wli, do you mean HM with constraint solving instead of unification?
01:00:30 <vincenz> ooh
01:00:31 <vincenz> typefunctions!
01:00:38 <vincenz> I've been drooling over those since a while
01:00:48 <Cale> vincenz: They're the same thing as ATs :)
01:00:50 <vincenz> didn't know they existed
01:00:53 <vincenz> I mean
01:00:55 <vincenz> sometimes you just want to do
01:01:02 <vincenz> type Foo a = X $ Y $ Z a
01:01:46 <dons> we're running haskell on the gpu now (you need a new nvidia card though)
01:01:47 <Cale> Oh, I'm not sure anything like that will be valid.
01:01:51 <dons> the first function was zipWith (+)
01:02:04 <mgsloa2> vincenz - i dunno if it's straight dependent types..
01:02:09 <Cale> dons: that's pretty cool
01:02:17 <vincenz> dons: spiffy
01:02:28 <dons> so i'm not sure if it will make it past being a researchy branch of ghc though
01:02:38 <dons> you also need nvcc, the nvidia CUDA compiler
01:04:09 <Cale> type family Add :: * -> * -> *
01:04:09 <Cale> type instance Add Zero     y = y
01:04:09 <Cale> type instance Add (Succ x) y = Succ (Add x y)
01:04:11 <Cale> :)
01:04:39 <ivanm> where can I find unlit? isn't it released with 6.6.1?
01:05:24 <dons> that's your type functions right there :)
01:05:34 <dons> oleg will love it
01:05:43 <vincenz> Cale: seems like a type class
01:05:54 <pupeno_> Is there a specific name to tests that reproduce a single bug, designed to ensure that a bug doesn't re-appear.
01:05:55 <dons> lifted one level
01:06:00 <vincenz> dons: in what sense?
01:06:01 <Cale> vincenz: yeah, people have been simulating this with fundeps for a while
01:06:09 <vincenz> Cale: you don't even need fundeps for that
01:06:24 <dons> vincenz: you're defining new types, rather than values, in the `instance'
01:06:25 <Cale> You do if you want type inference to work
01:06:44 <vincenz> dons: right, but that can be desugared to type-defs and instance-defs no?
01:06:57 <dons> nope.
01:07:30 <dons> its not sugar, they had to modify core's type system to handle it
01:07:36 <vincenz> hmm
01:07:40 <dons> but GADTs and FDs are now in terms of these guys
01:07:41 * vincenz doesn't quite see it yet
01:07:55 <Cale> It would look something like  class Add x y z; instance Add Zero y y; instance (Add x y z) => Add (Succ x) y (Succ z)
01:08:04 <vincenz> Cale: right
01:08:12 <Cale> actually,  class Add x y z | x y -> z
01:08:19 <vincenz> and then
01:08:22 <vincenz> data Zero = Zero
01:08:23 <dons> yeah, there may be a way to simulate that simple one (and there always is with enough FDs)
01:08:26 <vincenz> data Succ x = Succ x
01:08:28 <dons> but its not sugar, in practice
01:08:37 <vincenz> dons: ok
01:08:46 <vincenz> dons: then I might need to find a more complex example to grok it :)
01:08:50 <dons> `can be desugared to type-defs and instance-defs' + with enough FDs
01:08:50 <zeeeee> i need to learn about all these advanced topics in the haskell type system someday
01:10:10 <jethr0> huh, was the old wiki killed on haskell.org?
01:10:23 <Cale> jethr0: I think so.
01:10:33 <Cale> jethr0: It was deprecated for around a year.
01:10:38 <jethr0> ;(
01:10:46 <jethr0> i know
01:10:46 <zeeeee> doh
01:11:17 <wli> pejo: Yes, HM with constraint solving instead of unification.
01:11:20 <dons> most the material has gone to the new wiki
01:11:22 <Cale> http://hackage.haskell.org/trac/ghc/wiki/Status/April07
01:11:24 <lambdabot> Title: Status/April07 - GHC - Trac
01:11:29 <dons> there's a page on the new wiki listing what things haven't yet been moved
01:11:37 <Cale> that page seems to have really useful links on it for learning the new type system extensions
01:11:41 <pejo> zeeeee, personally I'm waiting for the Real world haskell book instead.
01:11:44 <zeeeee> i always found useful stuff on hawiki... least it's still on archive.org
01:11:52 <Cale> also, the bugs/day chart is amusing :)
01:11:58 <zeeeee> cool
01:12:19 <Cale> that is, the extensions which are new in 6.7/6.8
01:12:56 <jethr0> i'm really looking forward to try out the new ghci-based debugger
01:13:03 <pejo> wli, have you seen Baastiaan Heeren's thesis? http://people.cs.uu.nl/bastiaan/phdthesis/
01:13:06 <lambdabot> Title: Top Quality Type Error Messages
01:13:31 <Cale> I like the painting :)
01:13:32 <pejo> wli, there should be enough there to atleast get you started.
01:13:40 <wli> pejo: Not yet.
01:18:16 <ivanm> dons: is there any particular reason why lambdabot doesn't seem to be on the #gentoo-haskell channel anymore?
01:19:11 <Saizan> dcoutts: ping
01:20:41 <Cale> Haha...
01:20:43 <Cale> *** Type : [Token] → [((Type → Int → [([Char], (Type, Int, Int))] → Int
01:20:43 <Cale>  → Int → [(Int, (Bool , Int))] → (Doc, Type, a, b, [c] → [Level], [S] → [S])) → Type →
01:20:43 <Cale> d → [([Char], (Type, Int, Int))] → Int → Int → e → (Doc, Type, a, b, f → f , [S] → [S])
01:20:43 <Cale> , [Token])]
01:20:43 <Cale> *** Does not match : [Token ] → [([Char ] → Type → d → [([Char], (Type, Int, Int))]
01:20:44 <Cale>  → Int → Int → e → (Doc, Type, a, b, f → f , [S] → [S]), [Token])]
01:21:14 <Cale> (an example from that thesis)
01:21:37 <Jaak> not as bad as C++ template error messages, tho'
01:24:33 <pejo> That's a really poor excuse for having bad error messages though. If we worry about mainstream adoption of fp, that is definitely one of the problems we need to tackle.
01:27:30 <vincenz> dons: ping
01:27:32 <Jaak> ofcourse
01:27:45 <vincenz> dons: apparently the mailserver failed when I did darcs send... can I still resend and emit as patch?
01:29:40 <dblhelix> is it reasonable to only expect a kind error when you actually write an explicit type?
01:29:54 <dons> vincenz: just attach it and send that.
01:29:57 <dblhelix> I'd say yes
01:31:04 <ivanm> dons: is there any particular reason why lambdabot doesn't seem to be on the #gentoo-haskell channel anymore?
01:32:43 <vincenz> dons: sent
01:36:48 <kaol> how would I turn a function that takes n arguments into a function that takes a list with n elements as its argument? If this were lisp, I would get that for free.
01:37:29 <mauke> all functions take exactly one argument :-)
01:37:49 <ivanm> lol
01:38:05 <Lemmih> kaol: Usually you don't wanna do that.
01:38:31 <mauke> also, what kind of function takes n arguments of the same type?
01:38:32 <Saizan> foo' [a,b,c] = foo a b c
01:38:46 <kaol> I have a db query that returns a list and I'm trying to feed that to a data constructor
01:40:00 <mauke> :t foldl id
01:40:02 <lambdabot>     Occurs check: cannot construct the infinite type: a = b -> a
01:40:02 <lambdabot>     Probable cause: `id' is applied to too many arguments
01:40:26 <vincenz> dons: how do I transform a string "the name of a channel" into a Nick?
01:40:50 <kaol> there's got to be an easier way for this, instead of writing it all by hand
01:41:42 <Saizan> i think there are only harder ways
01:41:50 <jethr0> kaol: maybe using "scrap your boilerplate", but i'm not sure
01:42:49 * kaol looks into template haskell
01:44:47 <jethr0> buhu, my TH tutorial just went the way of the old wiki ;(
01:45:26 <wli> I was wondering where the TH tutorial went.
01:46:05 <jethr0> is there an accepted way to move articles from the old wiki to the new
01:46:11 <jethr0> thank god for archive.org
01:46:59 <jethr0> oh, no, but i guess archive.org hasn't mirrored the wiki-source-code for the page ;(
01:47:30 * jethr0 is *very* unhappy
01:47:52 <kaol> @hoogle [a] -> (a -> b) -> c
01:47:56 <lambdabot> Prelude.foldr :: (a -> b -> b) -> b -> [a] -> b
01:47:56 <lambdabot> Prelude.foldl :: (a -> b -> a) -> a -> [b] -> a
01:47:56 <lambdabot> Data.List.foldl' :: (a -> b -> a) -> a -> [b] -> a
01:49:23 <ivanm> @ask dons is there any particular reason why lambdabot doesn't seem to be on the #gentoo-haskell channel anymore?
01:49:23 <lambdabot> Consider it noted.
01:52:38 * kaol wrote Foo l!!0 ... l!!11 after all
01:53:24 <vincenz> dons: which is the new monad? LB or ModuleT?
01:55:25 <quicksilver> kaol: if it's a common requirement, I'd probably write a helper function mkFoo [a,b,c,d,e,f,g,h,i,j,k,l] = Foo a b c d e f g h i j k l
02:09:41 <Cale> dons: are you up?
02:12:55 <kaol> mkFoo12 f (x:xs) = mkFoo11 (f x) xs -- but I still feel that I shouldn't need to do stuff like this
02:14:00 <jgraves> Hi guys, I've got a wierd question.
02:14:23 <Saizan> ?paste
02:14:23 <lambdabot> Haskell pastebin: http://hpaste.org/new
02:14:40 <jgraves> Was it always the case that if I wanted to import a module 'Foo' that it had to be in a file called Foo.hs ?
02:14:55 <Cale> jgraves: yes
02:15:10 <jgraves> I was working on a project that had all the files in lowercase names.  And it used to compile... but today it doesn't.
02:15:31 <dons> Cale: ?
02:15:31 <lambdabot> dons: You have 4 new messages. '/msg lambdabot @messages' to read them.
02:15:57 <Cale> dons: vincenz and I are playing with DarcsPatchWatch...
02:16:23 <dons> oh yeah, got it working?
02:16:25 <jgraves> It could have been because the files were on a FAT filesystem, which is case insensitive...
02:16:26 <hpaste>  Saizan pasted "type hackery for kaol" at http://hpaste.org/1773
02:16:49 <Cale> There's an operation which seems to want to run in a separate thread, but it's in the DPW monad.
02:17:36 <dons> sounds like the kind of thing you'd fork, I guess. i've not looked at the code, nor written it
02:17:48 <dons> io $ forkIO $ runMyFunMonad ...
02:17:53 <vincenz> dons: ooh
02:17:54 <dons> something like that, to get it forked and running
02:19:01 <Cale> Yeah, we need to run the module's monad.
02:19:24 <Saizan> kaol: do you like it more? *Main> splice [1,2,3,4] (+) :: N Int
02:19:24 <Saizan> N 3
02:19:32 <Saizan> oops
02:19:35 <Cale> (which is a ModuleT)
02:21:21 <vincenz> dons: we need the opposite of 'io'
02:21:47 <Cale> Where is runModuleT  -- it doesn't seem to exist?
02:21:49 <dons> doesn't it have some run function? how did they do it previously?
02:21:57 <dons> why not just rewrite it from scratch? :)
02:22:04 <Cale> They used the lbIO hack.
02:30:45 <wli> pejo: Good stuff.
02:32:23 <wli> Looks like I'm right about them uniformizing things somewhat.
02:32:38 <vincenz> dons: tell me if you have issues with the rather trivial patch :)
02:32:44 <Cale> dons: what would you do if you had a ModuleT computation that had to run every so often without being triggered by a user command?
02:32:54 <kolmodin> ?localtime
02:32:58 <lambdabot> Local time for kolmodin is Thu Jul 19 11:25:22 2007
02:34:01 <dons> Cale, I thought there was a forkIO lifted already.
02:34:07 <kolmodin> would it be possible to get lambdabot back in #gentoo-haskell, please? she ran away :)
02:34:28 <dons> ah, maybe we ran out of channels
02:34:41 <vincenz> dons: there's a forkLB
02:34:47 <vincenz> dons: but no fork that is lifted too the moduleT level
02:34:50 <Cale> dons: Oh, so we can just run a loop forever? :)
02:35:21 <kolmodin> she also ran away from #kedja @ quakenet a month ago or so
02:35:27 <vincenz> smokebreak
02:35:28 <kolmodin> she is very naughty :)
02:36:51 <roconnor> @vixen naughty
02:36:51 <lambdabot> who?
02:36:56 <roconnor> @vixen
02:36:56 <lambdabot> you know what? if we'd known it was going to be like this we'd have picked our own goddamn cotton!
02:37:06 <roconnor> @vixen
02:37:06 <lambdabot> ain't it just like a man?
02:37:15 <Adamant> @vixen dance
02:37:15 <lambdabot> Fuck me like im a school boy
02:37:41 * roconnor wonders if vixen is feeling okay.
02:37:53 <mauke> @quota
02:37:54 <lambdabot> DougalStanton says: I'm beginning to wonder if Simon is less a name and more a title, meaning "strong in the lambda force" or somesuch. Let's hope they don't go over to the dark side ;-)
02:38:16 <Adamant> @typecheck Linux
02:38:16 <lambdabot> Unknown command, try @list
02:38:42 <Adamant> they need to add that command
02:39:37 <roconnor> @type Linux
02:39:39 <lambdabot> Not in scope: data constructor `Linux'
02:40:04 <Adamant> very apropos
02:40:06 * wli tries to figure out how to use GADT's for a specific piece of code.
02:40:48 * roconnor has only used GADTs for typed terms.
02:42:33 <wli> roconnor: This probably applies, then.
02:43:33 <hpaste>  wli pasted "How would I use GADT's for this?" at http://hpaste.org/1774
02:46:10 <roconnor> data Expression t where
02:46:23 <fasta> In foobar in runMaybeT foobar, I make a call to a function that is only defined in MyMonadT, do I have to explicitly lift or is there just some instance that I need s.t. I get the lifting for free? MyMonadT derives: (Monad, Monoid, MonadCont, MonadTrans, MonadFix, Functor, MonadPlus)
02:46:27 <roconnor> Numeral :: Integer -> Numeral Integer
02:46:53 <roconnor> ero
02:47:01 <roconnor> Numeral :: Integer -> Expression Integer
02:47:24 <roconnor> Variable :: Identifier -> Expression t
02:47:37 <wli> Well, I also need it parametrized on the type used for variables, so Expression t Integer
02:48:19 <wli> There is a plot to cram more information where variable names live.
02:49:05 <roconnor> wli:  often I put the context in the type of expressions.
02:49:47 <roconnor> data Value x g t where
02:49:47 <roconnor>  VVar :: Value (t,x) g t
02:49:47 <roconnor>  Succ :: Value x g t -> Value (a,x) g t
02:49:47 <roconnor>  Lambda :: Value (a,x) g b -> Value x g (a -> b)
02:49:53 <wli> I want to do that separately.
02:50:02 <roconnor> Ignore the g parameter, I use that for something else.
02:50:12 <roconnor> wli: why?
02:51:44 <wli> roconnor: Mostly just more information about what is happening.
02:56:55 <xelxebar> does anyone know of a function like readOct but can handle floats?
02:57:19 <xelxebar> does anyone know of a function like readOct but can handle floats?
02:58:03 <roconnor> > read "0.005" :: Float
02:58:05 <lambdabot>  5.0e-3
02:58:30 <roconnor> > readFloat "0.005"
02:58:31 <lambdabot>  [(5.0e-3,"")]
03:01:19 <xelxebar> okay roconnor, but readFloat is strictly base 10
03:01:29 <xelxebar> i need something more flexible in terms of bases
03:01:34 <roconnor> you want to read floaing point in octal?
03:01:43 <xelxebar> yup
03:02:04 <roconnor> okay, but that is almost certainly not a standard library function
03:02:20 <xelxebar> okay, I can manually implement it
03:02:25 <xelxebar> thanks
03:02:42 <roconnor> > readOct "10"
03:02:44 <lambdabot>  [(8,"")]
03:03:21 <xelxebar> > readOct "10.14159"
03:03:22 <lambdabot>  [(8,".14159")]
03:03:33 <xelxebar> that would be nice :)
03:04:00 <roconnor> xelxebar: do you want to handle 123e-05 in octal?
03:04:16 <roconnor> with octal exponents?
03:04:48 <xelxebar> hmmm, I hadn't thought about it
03:05:08 <quicksilver> octal floating point
03:05:11 <xelxebar> yes
03:05:12 <quicksilver> that's pretty exotic :)
03:05:32 <roconnor> @src readFlost
03:05:32 <lambdabot> Source not found. Do you think like you type?
03:05:34 <roconnor> @src readFloat
03:05:34 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
03:05:38 <roconnor> @src Numeric.readFloat
03:05:38 <lambdabot> Source not found. I feel much better now.
03:05:43 <roconnor> damn it
03:06:01 <xelxebar> grrr
03:06:27 <xelxebar>  readFloat     :: (RealFrac a) => ReadS a
03:06:27 <xelxebar> readFloat r    = [(fromRational ((n%1)*10^^(k-d)),t) | (n,d,s) <- readFix r,
03:06:27 <xelxebar>                                                        (k,t)   <- readExp s] ++
03:06:27 <xelxebar>                  [ (0/0, t) | ("NaN",t)      <- lex r] ++
03:06:27 <xelxebar>                  [ (1/0, t) | ("Infinity",t) <- lex r]
03:06:29 <xelxebar>                where 
03:06:31 <xelxebar>                  readFix r = [(read (ds++ds'), length ds', t)
03:06:33 <xelxebar>                              | (ds,d) <- lexDigits r,
03:06:35 <xelxebar>                                (ds',t) <- lexFrac d ]
03:06:37 <xelxebar>                
03:06:39 <xelxebar>                  lexFrac ('.':ds) = lexDigits ds
03:06:41 <xelxebar>                  lexFrac s        = [("",s)]        
03:06:43 <xelxebar>                  
03:06:45 <xelxebar>                  readExp (e:s) | e `elem` "eE" = readExp' s
03:06:47 <xelxebar>                  readExp s                     = [(0,s)]
03:06:49 <xelxebar>                  
03:06:51 <xelxebar>                  readExp' ('-':s) = [(-k,t) | (k,t) <- readDec s]
03:06:53 <xelxebar>                  readExp' ('+':s) = readDec s
03:06:55 <xelxebar>                  readExp' s       = readDec s
03:07:10 <roconnor> perfect
03:07:20 <roconnor> you just need to change readDec to something more general
03:07:25 <roconnor> maybe make it a parameter
03:07:48 <roconnor> maybe you need to change lexDigits to throw aways 9 and 8's.
03:08:22 <xelxebar> good idea
03:09:19 <roconnor> > show (-1/0)
03:09:20 <lambdabot>  "-Infinity"
03:09:25 <xelxebar> lexDigits        :: ReadS String 
03:09:26 <xelxebar> lexDigits        =  nonnull isDigit
03:09:26 <xelxebar> could become. . .
03:09:26 <xelxebar> lexDigits        =  nonnull isOctDigit
03:09:35 <roconnor> > read $ show (-1/0) :: Double
03:09:36 <lambdabot>  -Infinity
03:09:44 <xelxebar> hahahaha
03:10:10 <fasta> In foobar in runMaybeT foobar, I make a call to a function that is only defined in MyMonadT, do I have to explicitly lift or is there just some instance that I need s.t. I get the lifting for free? MyMonadT derives: (Monad, Monoid, MonadCont, MonadTrans, MonadFix, Functor, MonadPlus)
03:10:22 <Jaak> @paste
03:10:23 <lambdabot> Haskell pastebin: http://hpaste.org/new
03:10:48 <vincenz> @hoogle forkIO
03:10:48 <lambdabot> Control.Concurrent.forkIO :: IO () -> IO ThreadId
03:10:52 <fasta> If I just do runMaybeT(put 1), it Just Works
03:11:10 <fasta> I would want the same for MyMonadT which is just a newtyped StateT
03:12:40 <vincenz> @hoogle modifyMVar
03:12:41 <lambdabot> Control.Concurrent.MVar.modifyMVar :: MVar a -> (a -> IO (a, b)) -> IO b
03:12:41 <lambdabot> Control.Concurrent.MVar.modifyMVar_ :: MVar a -> (a -> IO a) -> IO ()
03:12:42 <vincenz> @hoogle modifyMVar_
03:12:42 <lambdabot> Control.Concurrent.MVar.modifyMVar_ :: MVar a -> (a -> IO a) -> IO ()
03:14:21 <xelxebar> n00b question:  what is the ReadS type?
03:14:23 <Saizan> fasta: don't you need to derive MonadState?
03:14:25 <quicksilver> fasta: you need a MonadState instance for MyMonadT then
03:14:35 <fasta> quicksilver: I have that instance
03:14:40 <quicksilver> not in the list you showed me
03:14:40 <fasta> quicksilver: it's just not derived
03:14:42 <mauke> xelxebar: type ReadS a = [(a, String)]
03:14:43 <quicksilver> ah
03:14:52 <fasta> quicksilver: that's true, I was being incomplete again, sorry.
03:14:52 <quicksilver> then 'put' should just work
03:14:52 <xelxebar> oh, thanks
03:15:04 <fasta> quicksilver: well, "put" does work
03:15:19 <fasta> quicksilver: but not the MyMonad specific operations.
03:16:13 <xelxebar> why does that have it's own type?  I don't really understand the logic of one tuple inside a list
03:16:17 <fasta> quicksilver: essentially newtype Bar extrastate = StateT (MyState extra) ...
03:17:04 <fasta> quicksilver: when I explicitly add lift before that operation it does work.
03:17:15 <fasta> @where monad transformers
03:17:16 <lambdabot> I know nothing about monad.
03:17:33 <Saizan> which operation?
03:17:42 <quicksilver> fasta: ah, are there two State monads in the tower?
03:17:56 <vincenz> dons: might have it working :)
03:18:02 <fasta> quicksilver: no, you know what, I will stop letting you guess and show it.
03:19:31 <xerox> xelxebar, it's a list of tuples
03:20:05 <hpaste>  fasta pasted "(no title)" at http://hpaste.org/1775
03:20:12 <fasta> quicksilver: there is it
03:20:16 <dcoutts> @seen dons
03:20:16 <lambdabot> dons is in #xmonad, #haskell-soc and #haskell. I last heard dons speak 45m 48s ago.
03:21:38 <fasta> quicksilver: The function I want to run in the runMaybeT has type :: (Show a, Show b, Gr g, Monad m) => EdgePosition -> GraphMonad (g a b) s m ()
03:21:54 <quicksilver> fasta: so the problem is you can use 'put' in GraphMonad, but not in MaybeT GraphMonad ?
03:22:13 <fasta> quicksilver: Disregard "put"
03:22:27 <fasta> quicksilver: I am interested in running the function with the above type
03:22:58 <quicksilver> yes, you have to explicitly lift that function
03:22:58 <fasta> quicksilver: GraphMonad should actually be called GraphMonadT, but that's a beauty thing.
03:23:11 <fasta> quicksilver: why?
03:23:20 <quicksilver> or you do the typeclass trick
03:23:33 <fasta> quicksilver: What is the "type class trick"?
03:23:33 <quicksilver> which would involve maybe a typeclass called 'MonadGraph'
03:23:42 <quicksilver> working in a similar way to MonadState
03:23:52 <quicksilver> permitting you to change the signature of that function slightly
03:24:12 <quicksilver> from GraphMonad... to (MonadGraph m) => m ()
03:24:21 <quicksilver> (lots more parameters really)
03:24:29 <quicksilver> g a b and s in some order :)
03:24:35 <fasta> quicksilver: ok, I see.
03:24:56 <quicksilver> that's the reason all these 'MonadFoo' typeclasses exist
03:25:01 <quicksilver> to let you use things without explicit lifts
03:25:16 <quicksilver> it's all slightly unsatisfactory to be honest :(
03:25:30 * wli gets this vague idea he's got quite a bit of math going on.
03:25:52 <Saizan> and then you need an instance MonadGraph m => MonadGraph (MaybeT m) where
03:25:54 <vincenz> dons: ping?
03:26:05 <quicksilver> yeah, excatly as Saizan says
03:26:08 <fasta> Saizan: yes, I understood that.
03:26:37 <fasta> Wouldn't it be possible to automatically generate MonadGraph?
03:27:20 * shapr throws tired lambdas
03:27:34 <quicksilver> generating MonadGraph involves making a list of all the 'primitives' your monad uses
03:28:08 <fasta> quicksilver: that's simply walking over the call graph of the entire program and taking the ones that don't use anything else.
03:28:17 <fasta> quicksilver: that's doable.
03:28:20 <jethr0> is there a way to turn echoing off with getChar?
03:28:37 <jethr0> ah, hSetHandle...
03:29:31 <quicksilver> fasta: yes, I agree
03:29:35 <quicksilver> fasta: it's an interesting topic
03:29:45 <quicksilver> fasta: in the sense that's it's all a bit ugly and boilerplate-ish
03:29:52 <quicksilver> fasta: and clearly some automation would help a lot
03:31:41 <fasta> quicksilver: does anyone working on compilers also care about this?
03:32:04 <quicksilver> I'm not sure. I suspect some other people must be aware of the issue and care about it :)
03:33:57 <quicksilver> fasta: the person to talk to would be Cale
03:34:04 <quicksilver> Cale: about?
03:34:08 <Cale> hm?
03:35:09 <fasta> Cale: I bumped into some boiler-plate code problem, and quicksilver thinks you have something to say on the topic. Scroll back when interested.
03:35:53 <quicksilver> Cale: short version: create new monad transformer, you have to also create a MonadFoo typeclass + 1 million instance promotions
03:35:56 <Cale> Automatically generating typeclasses?
03:36:07 <quicksilver> Cale: to specify which other transformers your transformer can be lifted through
03:36:16 <Cale> Oh, I actually don't like those automatic instance promotions :)
03:36:16 <quicksilver> (if you want to avoid lots of explicit 'lift'ing)
03:36:59 <Cale> Really, in most cases it makes more sense to write the instances when you construct your new monad.
03:37:18 <Cale> (with lots of lifts, sure, but not so many that it's a problem)
03:37:29 <Cale> (and they're all in one place)
03:37:54 <jethr0> is there a way to do clearscreen somewhere in System.IO. or a haskell binding to readline/...?
03:37:54 <fasta> I think adding extra syntax to the language is a bad idea.
03:38:00 <Cale> The way that the mtl is currently designed doesn't scale, because there's a quadratic expansion in code as you add more classes.
03:38:26 <fasta> Cale: quadratic? Why?
03:38:58 <Cale> fasta: To lift the operations for each monad transformer through all the others.
03:39:32 <Cale> (well, maybe not *all* the others, in some cases it doesn't make sense, but every one that's possible)
03:39:48 <fasta> Cale: you mean that calling a function f in a monad transformer m at depth d takes time O(d)?
03:39:57 <fasta> Cale: where's the extra factor coming from?
03:40:02 <quicksilver> no, quadratic in programmer work
03:40:05 <Cale> no, quadratic in the amount of code you have to write
03:40:07 <quicksilver> not runtime
03:40:17 <quicksilver> (hopefully) all the lifts get inlined to nops anyway
03:40:25 <quicksilver> they're mostly just unwrapping newtypes which is a nop
03:40:47 <Cale> This makes it easy to use monad transformers 'raw', but it doesn't scale so well.
03:40:50 <fasta> Cale: Ok, how is is quadratic in the amount of code one needs to write?
03:41:08 <Cale> Well, just look at all the instance declarations in the mtl modules
03:41:11 <fasta> is it*
03:41:35 <vincenz> Cale: woot
03:41:37 <Cale> For each MonadX class, there's instances for each YT monad transformer
03:41:41 <Cale> vincenz: awesome :)
03:42:10 <fasta> Cale: ok, and is there another library that doesn't have that limitation?
03:42:46 <Cale> no, but you could just decide not to write them :)
03:43:07 <Cale> That basically forces people to use newtypes and write the lifting instances they actually want.
03:43:52 <Cale> dons: We got DarcsPatchWatch working :)
03:44:02 <vincenz> butt-uglily but yes :)
03:44:03 <mnislaih> Cale: cool !
03:44:08 <vincenz> I should move forkForeverLB to LBSTate
03:44:08 <mnislaih> Cale: where ?
03:44:28 <mnislaih> any repos I can steal patches from ?
03:44:34 <Cale> mnislaih: Currently just in our branch of lambdabot.
03:44:35 <pejo> Cale, is that for mailing all commits somewhere?
03:44:35 <mnislaih> just in time for the contest !
03:44:44 <Cale> pejo: IRC commit watching.
03:44:56 <Cale> mnislaih: exactly
03:45:25 <Cale> fasta: Probably at some point in the future, there will be a language extension which handles the creation/composition of monads.
03:45:33 <mnislaih> Cale, now I see that you are in a team too. Are you keeping those patches as a strategic advantage ?
03:46:13 <Cale> mnislaih: I don't know. Personally, I wouldn't mind if they went back into the main lambdabot repo right away :)
03:46:27 <vincenz> Cale: I can send a patch
03:47:03 <vincenz> .. to dons
03:47:10 <Cale> fasta: There are patterns which people are forming with regard to the construction of monads via transformers which indicates that there's probably room for language support of some kind. It's still not clear that monad transformers are the best way to go though.
03:47:37 <fasta> Cale: yes, "co-products" are another option too, IIRC.
03:47:49 <fasta> Cale: but I forget all that algebra stuff when I am not using it.
03:48:03 <Cale> I'm not sure how automating the construction of coproducts is even supposed to work.
03:48:06 <fasta> Cale: I do use carrier types in my programming, but that's about it.
03:48:26 <Cale> Basically, monad transformers are already kind of pushing it with regard to automated construction of programming languages :)
03:48:42 <fasta> I wrote an algebra that worked for purely functional code and for code in MonadST s m
03:48:55 <fasta> I found that pretty cool :)
03:49:16 <Cale> Was it you that ran into that funny problem with stack overflows and monad transformers?
03:49:24 <fasta> No
03:49:40 <Cale> There are a few combinations of monad transformers that look kind of sensible, but produce ridiculous code.
03:49:49 <Cale> (even with just the MTL stuff)
03:50:59 <Saizan> are you talking about RWS?
03:52:23 <pastorn> can someone please tell me where i can read about all the diffirences between type and newtype (and data)
03:52:43 <Cale> Saizan: It might have had something to do with RWST
03:52:44 <pastorn> with nice examples and stuff =)
03:53:17 <Cale> pastorn: basically, type declares aliases for the same type, which are interchangeable as far as the type system is concerned
03:53:34 <pastorn> Cale: yes, that i know
03:53:42 <Cale> pastorn: newtype defines a new type in the type system, but at runtime, the implementation is the same
03:53:44 <pastorn> and data constructs new types
03:53:58 <pastorn> ehm...
03:53:58 <Cale> yes
03:54:14 <pastorn> so newtype is like data... but...?
03:54:21 <vincenz> pastorn: but without an extra bottom
03:54:27 <vincenz> newtype Foo a = Foo a
03:54:28 <Cale> With data, you get actual data constructors that exist in memory as real things.
03:54:35 <vincenz> _|_ === Foo _|_
03:54:45 <pastorn> oh, okay
03:54:47 <Cale> With newtype, the "data constructors" are boiled away by compilation
03:55:00 <pastorn> saves memory :D
03:55:09 <vincenz> and an extra pointer indirection
03:55:13 <vincenz> cause every extra bottom is a pointer :)
03:55:13 <Cale> yeah, but it has slightly different semantics
03:55:25 <Cale> as vincenz sort of pointed out there
03:55:36 <Cale> With data Bar = Bar Integer
03:55:45 <Cale> Bar undefined is not the same as undefined
03:55:51 <dozer> should I use template haskell, or is there a better option?
03:56:10 <vincenz> dozer: kind of hard to answer without knowing what it is you're trying to do :)
03:56:10 <shapr> dozer: Use TH!
03:56:19 <pastorn> Cale, vincenz: cool, thanks =)
03:56:46 <jethr0> shapr!
03:57:05 <dozer> vincenz: a load of classes that encapsulate tree-rewriting rules where the tree is represented as mutually recursive data declarations (more than one kind of data)
03:57:12 <Cale> pastorn: (obviously, because the first one has a little structure with a pointer to an undefined value, whereas the latter is just the undefined value, and the difference can be detected by pattern matching)
03:57:14 <dozer> one class for each rewrite rule
03:58:06 <dozer> vincenz: and most instances of these classes do nothing other than transform each part of the data structure using the same typeclass and reconstruct themselves, so they are booring to write
03:58:25 <vincenz> dozer: have you looked at ComposOp from bringert??
03:58:46 <dozer> vincenz: no - googling now
03:59:09 <vincenz> or one of the SYB papers? (though I personally prefer composOp)
03:59:44 <Cale> yeah, this does sound like a job for Data.Generics.
04:00:12 <Cale> I don't think I've heard of composOp
04:00:29 <vincenz> I like composop
04:00:32 <vincenz> in fact I liked it so much
04:00:37 <vincenz> I invented higher order composops
04:00:43 <vincenz> composop2 composop3 ...
04:04:34 <vincenz> and you only need to define one
04:04:38 <vincenz> you get all the lower order ones for free
04:06:41 <waern_> what about uniplate?
04:07:06 <waern_> isn't it better than composOp in most cases?
04:08:20 <dozer> ok - I'll have a play with each of these and get back to you later :)
04:08:50 <vincenz> waern_: I disagree
04:09:53 <mnislaih> vincenz: what advantage does composOp hold ?
04:10:08 <vincenz> mnislaih: it's more strongly typed
04:10:41 <mnislaih> but it is quite more strongly boilerplate'd too
04:10:43 <fasta> Cabal should list the number of users of a package, btw.
04:11:04 <mnislaih> fasta: that's a good suggestion for hackage
04:11:16 <fasta> Uh, right, it's hackage.
04:11:28 <vincenz> mnislaih: I disagree
04:11:35 <mnislaih> there is someone working on the new web version of hackage, nominolo
04:11:42 <mnislaih> wrong, it's someone else
04:11:51 <fasta> vincenz: about this?
04:11:57 <vincenz> fasta: about what he said to me
04:12:03 <fasta> vincenz: ok
04:12:12 <mnislaih> vincenz: you need to rewrite all your datatypes using a specific GADT encoding, don't you ?
04:12:22 <mnislaih> afaik uniplate does not require that
04:12:24 <vincenz> mnislaih: hmm?
04:12:25 <vincenz> no you don't
04:12:46 <fasta> An algoritmic complexity number on the tests for the package is also a good indicator
04:13:03 <fasta> To see that also non-trivial things were tested.
04:13:05 <mnislaih> vincenz: oh, then I must be confused. nevermind
04:14:07 <vincenz> mnislaih: basically it's when your datatype is a functor
04:14:12 <vincenz> mnislaih: and I then extend it for higher order funtors
04:14:27 <vincenz> (like ... in an AST you might have
04:14:36 <vincenz> AST v t ... v = type of identifiers, t = type of types
04:14:40 <vincenz> (so you can attach information to them
04:14:50 <Cale> http://www.notablogtm.com/wp-content/uploads/2007/07/lolcat_bible_sml.jpg -- haha
04:14:52 <lambdabot> http://tinyurl.com/2xxwea
04:15:05 <Cale> "I can has light"
04:15:10 <fasta> Cale: Is it easy to extract given GraphMonadT GraphMonad?
04:15:11 <vincenz> lolbibble?
04:15:48 <Cale> fasta: extract what?
04:15:56 <vincenz> mnislaih: oh right, yes
04:16:02 <vincenz> mnislaih: it's useful to do that GADT encoding you mentioned
04:16:04 <vincenz> mnislaih: apologies
04:16:09 <vincenz> mnislaih: but I don' think it's required
04:16:11 <fasta> Cale: I.e. given an implementation for *T get *
04:16:43 <Cale> yes
04:16:43 <mnislaih> vincenz: on second thought, I'm not sure that the GADT encoding implies more boilerplate anyway, so nevermind
04:16:52 <fasta> Cale: composing with the Identity monad works, but that's only for running it.
04:16:55 <Cale> fasta: Apply the transformer to Identity
04:17:00 <vincenz> mnislaih: basically you want everything in one data type, so you can traverse through all of it, a way to do this is through GADT
04:17:05 <Cale> fasta: newtype it
04:17:06 <vincenz> mnislaih: but for simple data types, you don't need GADTs
04:17:16 <fasta> Cale: ok
04:17:35 <Cale> newtype GraphMonad a = GM (GraphMonadT Identity a)
04:17:43 <vincenz> mnislaih: in that sense, I think uniplate is a simplified version as it's unityped
04:18:01 <Cale> runGraphMonad (GM x) = runIdentity (runGraphMonadT x)
04:18:07 <Cale> roughly
04:18:21 <Cale> (you might need some additional parameters of course)
04:18:37 <vincenz> mnislaih: otoh, uniplate is H98 compliant
04:20:26 <wli> What I'm really looking for is some less repetitive way to dangle some repository of extra information off each tree node.
04:20:47 <mnislaih> vincenz I would claim the opposite: composOp is the simplified version, as it is uni-datatyped :)
04:21:24 <mnislaih> uniplate actually extends to multiple types I believe, but the basic formulation certainly is unityped
04:21:30 <wli> The dumb, repetitive way is to add yet another type parameter to the type and give each constructor a field for that new parameter.
04:21:39 <vincenz> mnislaih: composop is not unityped
04:21:44 <vincenz> mnislaih: case in point is a GADT
04:22:04 <vincenz> it has explicit foralls
04:22:12 <mnislaih> wii they do something like that in finger trees
04:22:31 <mnislaih> I don't remember how it worked exactly, but they store a 'cache' in the tree nodes
04:22:32 <vincenz> wli: yeah I know, annoying as hell
04:22:43 <dozer> my datastructures are very definitely not uni-typed and can not be
04:25:09 <xelxebar> what does @ signify? as in [(cs,t) | (cs@(_:_),t) <- [span p s]]
04:25:49 <vincenz> xelxebar: binds cs to the value that (_:_) matched
04:28:50 * wli memoizes his nasty recurrence naively.
04:29:17 <vincenz> there should be alet type
04:29:19 <vincenz> a let type
04:29:26 <vincenz> type Exp a b c d e f = ...
04:29:29 <vincenz> data Exp a b c d e f = ...
04:29:38 <vincenz>    lettype Exp' = Exp a b c d e f in
04:29:43 <vincenz>    Add Exp' Exp'
04:29:47 <vincenz>   Mul Exp' Exp'
04:29:49 <vincenz> ..
04:32:37 <crazy_coder> hello everyone
04:33:00 <crazy_coder> which is the std function which gives maximum element of a list ?
04:33:11 <crazy_coder> > max [1,2,3]
04:33:12 <lambdabot>  <[Integer] -> [Integer]>
04:33:28 <Lemmih> > maximum [1,2,3]
04:33:29 <wli> crazy_code: maximum
04:33:29 <vincenz> > maximum [1.10]
04:33:29 <lambdabot>  3
04:33:30 <lambdabot>  1.1
04:33:38 <crazy_coder> Ok Oh Thanks
04:34:00 <crazy_coder> One more thing, I have function  f :: Int -> [Int] -> [Int]
04:34:17 <crazy_coder> Now I give an Int and a list of Int to the funtion f
04:34:37 <vincenz> max $ f a l
04:34:45 <vincenz> sorry
04:34:46 <crazy_coder> I want that the list of integer (2nd argument) is calculated lazily
04:34:48 <vincenz> maiumum
04:35:01 <crazy_coder> *to be calculated
04:35:03 <vincenz> crazy_coder: huh?
04:35:12 <vincenz> crazy_coder: you mean your input?
04:35:17 <crazy_coder> yes
04:35:30 <crazy_coder> It must be evaluated.
04:35:35 <vincenz> then I don't get your question
04:35:41 <crazy_coder> Ok
04:35:47 <crazy_coder> I'll explain it
04:35:50 <Lemmih> crazy_coder: Everything is evaluated lazily in Haskell.
04:35:54 <vincenz> ^^^
04:36:18 <crazy_coder> I have a funtion getPrimeFactors :: Int ->[Int]->[Int]
04:36:32 <crazy_coder> Now the list of Integers I provide is list of Prime numbers
04:36:58 <crazy_coder> But it is not necessary for me to calculate the entire list of prime numbers to get the result
04:37:10 <vincenz> crazy_coder: if you do it the straight  forward way
04:37:12 <vincenz> it'll be lazy
04:37:21 <vincenz> seems like you want
04:37:55 <vincenz> > let getPrimeFactors a l = filter ((== 0) . (mod a)) l in getPrimeFactors 21 [1,3,5,7]
04:37:55 <crazy_coder> I wanted to know if $ or . or anything helps in achieving this
04:37:56 <lambdabot>  [1,3,7]
04:38:04 <vincenz> crazy_coder: it's all lazy
04:38:16 <vincenz> crazy_coder: just don't use something that requries the last element of your list first
04:38:20 <vincenz> (like foldl)
04:38:35 <Lemmih> crazy_coder: They have no impact at all.
04:38:38 <crazy_coder> Oh ok
04:39:13 <crazy_coder> I am using pattern matching  (x:xs) for this list
04:39:42 <vincenz> @paste
04:39:42 <lambdabot> Haskell pastebin: http://hpaste.org/new
04:39:48 <Cale> crazy_coder: Pattern matching against (x:xs) will force the evaluation of the list up to determining that it's of the form (x:xs), but not more than that.
04:39:54 <Lunar^> I can't remember, is there an "average" function (:: Num a => [a] -> a) in the standard library?
04:40:00 <Cale> Lunar^: no
04:40:16 <Lunar^> Cale: ok
04:40:21 <Cale> Lunar^: It'd be (Fractional a) => [a] -> a, anyway, I'd think.
04:40:33 <Lunar^> right
04:40:39 <Lunar^> my Haskell is really rusty
04:40:46 <crazy_coder> Ok Thanks
04:40:51 <vincenz> WD40 will help
04:40:54 <crazy_coder> I'll paste it later
04:40:56 <crazy_coder> Thanks
04:41:22 * wli has to figure out at some point how to set up the linear equations for his Hermite-Lagrange basis, then solve them.
04:41:39 <vincenz> wli: I think there's functions for that in the std library :P
04:42:03 <wli> vincenz: Not really.
04:42:11 <timbod> @seen jfredett
04:42:11 <lambdabot> jfredett is in #haskell-blah, #haskell and #haskell-overflow. I don't know when jfredett last spoke.
04:42:44 <wli> vincenz: This is rather evil stuff.
04:43:07 <nominolo> @hoogle partition3
04:43:07 <roconnor> @bab en nl measure
04:43:08 <lambdabot> No matches found
04:43:08 <lambdabot>   maatregel
04:43:47 <ClaudiusMaximus> > let factors n = map fst . filter ((== 0) . snd) $ zipWith (\a b -> (a, b `mod` a)) [1..] (replicate n n) in factors 60
04:43:48 <lambdabot>  [1,2,3,4,5,6,10,12,15,20,30,60]
04:43:49 <vincenz> wli: it was a lame joke
04:44:17 <wli> What'd be nice is a partitioning function that takes a function mapping elements to bins, and then does sortBy and groupBy and so on.
04:46:23 <MyCatVerbs> wli: I'd prefer a solution to the halting problem, myself.
04:46:43 <vincenz> MyCatVerbs: preferably in polynomial time
04:47:12 <MyCatVerbs> vincenz: I have an idea for how you could do it in O(1).
04:47:23 <wli> partitionX f = map (\ys -> (fst $ head ys, map snd ys)) . groupBy ((. fst) . (==) . fst) . sortBy ((. fst) . compare . fst) . map ((,) . f)
04:47:31 <vincenz> MyCatVerbs: without -fimport-parallel-universes?
04:48:21 <MyCatVerbs> Nah, easier.
04:48:37 <roconnor> parallel universes?
04:48:45 <roconnor> woah
04:48:45 <wli> partitionX f = map (\ys -> (fst $ head ys, map snd ys)) . groupBy ((. fst) . (==) . fst) . sortBy ((. fst) . compare . fst) . map (\x -> (f x, x))
04:48:58 <vincenz> roconnor: it's GHC 7.2 extension
04:49:09 <MyCatVerbs> vincenz: you construct a Turing-complete machine for which the Chaitin constant just -happens- by sheer coincidence to be something that can be calculated. Say, 1/pi.
04:49:10 <roconnor> sounds quantum
04:49:19 <vincenz> roconnor: no that's GHC 7.1.2
04:49:53 <roconnor> I thought the Chaitin constant was uncomputable.
04:49:57 <MyCatVerbs> vincenz: once you have that in hand, you write a simulator in that for a Turing machine that's easy to implement a solution to any problem for.
04:50:09 <roconnor> oh
04:50:21 <roconnor> but it still may be equal to 1/pi
04:50:27 <roconnor> even if it is uncomputable.
04:50:34 <roconnor> ... hmm
04:50:36 <vincenz> MyCatVerbs: why 2 turing machines?
04:50:40 <vincenz> 1/pi is not calculatable
04:50:49 <vincenz> O(inf)
04:50:57 <MyCatVerbs> roconnor: that's the trick. The (impossible) first step is that you get lucky enough to accidentally come up with a Turing-complete machine for which the Chaitin constant just -happens- to be equal to some number which is trivial to compute.
04:51:15 <vincenz> MyCatVerbs: I fail to see the need of the simulator
04:51:25 <MyCatVerbs> vincenz: just for convenience.
04:52:11 <doserj> MyCatVerbs: with the same probability for success, you could just guess randomly in the first place...
04:52:18 <MyCatVerbs> vincenz: it's not neccessary, of course, but if the impossible machine happens to be a real pain in the arse to program for, it'd be easier to phrase your programs in, say, untyped lambda calculus.
04:52:28 * vincenz guesses MyCatVerbs terminates
04:53:25 <MyCatVerbs> vincenz: and you don't need to calculate 1/pi to infinite precision, just to the level of precision corresponding to the binary digit which encodes your particular problem's Turing machine. Pi being cheap to approximate, that'd be easy.
04:53:31 <roconnor> 1/e would be easier to compute. :P
04:53:39 <Cale> roconnor: Well, being equal to 1/pi would make it computable, so you probably can't prove that :)
04:53:58 <MyCatVerbs> roconnor: fair enough, use that instead, then. ^^
04:54:13 <wli> vincenz: Anyway, what I've done is cooked up a way to construct piecewise rational functions of minimal degree types which are some number of times continuously differentiable.
04:54:53 <vincenz> wli: I'm not a math head :|
04:55:02 <Cale> The funny thing about real numbers is that their existence can be intimately tied to the properties of the underlying set theory in ways that you usually wouldn't expect.
04:55:08 <roconnor> MyCatVerbs: 2/3 would be even easier to compute.
04:55:18 <vincenz> roconnor: I prefer 'i'
04:55:23 <wli> vincenz: They're like something in graphics except they're the "real deal."
04:55:35 <wli> vincenz: How about the Cauchy principal value of i^i?
04:55:48 <MyCatVerbs> roconnor: yes, but a rational number would be no damn fun at all.
04:56:01 * wli likes using 1+i as the radix for number systems, too.
04:56:11 <Cale> wli: e^(-pi/2) ?
04:56:18 <wli> Cale: Yes.
04:56:26 * roconnor doesn't like using exponents with complex numbers.
04:56:53 <wli> roconnor: I just wave the magic "Cauchy principal value" wand and most issues there disappear.
04:57:09 <roconnor> @go Cauchy principal value
04:57:10 <vincenz> wli: that's not 1+i, that's 1+i/sqrt(2)
04:57:11 <lambdabot> http://mathworld.wolfram.com/CauchyPrincipalValue.html
04:57:11 <lambdabot> Title: Cauchy Principal Value -- from Wolfram MathWorld
04:57:24 <vincenz> oh wait
04:57:26 * vincenz misread
04:57:30 * vincenz shuts u
04:57:31 <vincenz> p
04:58:01 <fasta> MonadState SomeState Control.Monad.Identity.Identity is non-sense, right?
04:58:02 <Cale> i^i is real :)
04:58:07 <wli> vincez: I'm not sure in what extension there is a prime that ramifies into (1+i)/sqrt(2); I'd expect that to be a unit.
04:58:20 <Cale> fasta: yes.
04:58:26 <wli> Cale: Well, it's multivalued.
04:58:31 <Cale> wli: of course
04:58:34 <wli> All its values are real.
04:58:48 <wli> I said "Cauchy principal value" to narrow it down a bit.
04:59:48 <Cale> Do you mean 'principal value' in the usual sense? I understand 'Cauchy principal value' to refer to a sort of integration process.
05:00:31 <Cale> (I think you just want to take the principal branch of the log)
05:01:15 <wli> Cale: The integration process is usable to define the functions.
05:01:27 <Cale> ah, okay
05:02:02 <wli> f(\zeta)/(\zeta - z) etc.
05:02:24 <vincenz> i^i is surprisingly small
05:02:37 <wli> ca. 0.2 IIRC
05:02:51 <vincenz> > i ^ i
05:02:56 <lambdabot>   Not in scope: `i'
05:03:10 <vincenz> > (0 |+| 1)  ^ ( 0 |+| 1)
05:03:11 <lambdabot>   Not in scope: `|+|'
05:03:13 <vincenz> hmm
05:03:21 <Cale> Normally I just define exp with the power series expansion and then define log as a right inverse to it.
05:03:21 <vincenz> > (0 :+ 1)  ^ ( 0 :+ 1)
05:03:22 <lambdabot>        add an instance declaration for (Integral (Complex t))
05:03:22 <lambdabot>     In the expr...
05:03:26 <vincenz> > (0 :+ 1) ** ( 0 :+ 1)
05:03:27 <lambdabot>  0.20787957635076193 :+ 0.0
05:03:39 <Cale> and perhaps Log as the relational inverse
05:04:10 <wli> Probably wilder is my Dirichlet series module.
05:04:20 <fasta> No instance for (MonadGraph
05:04:20 <fasta> 		       (Control.Monad.Cont.ContT
05:04:20 <fasta> 			  ()
05:04:21 <fasta> 			  (Omega.GraphMonadTypes.GraphMonadT
05:04:34 <fasta> Cale: is that the explosion you were talking about?
05:04:42 <Cale> fasta: part of it :)
05:04:55 <Cale> fasta: Cont is one of the harder ones
05:05:10 <wli> RealFloat seems to be required for Complex t
05:05:22 <wli> That makes Gaussian integers a bit tough, don't you think?
05:05:44 <quicksilver> maybe make Gaussian integers a newtype over a pair of rationals
05:05:47 <Cale> wli: A really good idea is to define a type for monoid rings. That saves a lot of time defining instances of Num.
05:06:01 <etnt> anyone read the Hutton book? do you recommend it?
05:06:19 <wli> Cale: Yeah, I've got various hacks around things for all this.
05:06:51 <Cale> etnt: I haven't read it, but heard it's a rather good treatment for beginners.
05:07:38 <wli> quicksilver: That would be Q(i); Gaussian integers would be over a pair of integers.
05:08:03 <Cale> etnt: You might be interested in this review http://www.cs.nott.ac.uk/~gmh/coutts.pdf
05:08:14 <quicksilver> wli: type
05:08:17 <quicksilver> wli: typo :)
05:08:22 <quicksilver> wli: I meant to type 'integrals' :)
05:09:15 <wli> quicksilver: Now Z[(-d)^(1/2)] for d such that it forms a unique factorization domain is interesting to define in terms of those type-level binary numbers.
05:09:31 <etnt> Cale: ok, thx!
05:09:51 <wli> quicksilver: Heck, I've not figured out how to ensure the things are prime just yet.
05:09:53 <fasta> *** Exception: No match in record selector Var.tcTyVarDetails
05:09:58 <fasta> Meh, another compiler bug.
05:10:19 <Cale> etnt: another route is to just hang around here and ask lots of questions, and it's pretty easy to get people to give you tutorials on stuff :)
05:10:31 <wli> Forget the Jugendtraum etc.
05:10:49 <Cale> fasta: which compiler is that? :)
05:11:04 <wli> Time to hit the store.
05:11:13 <fasta> Cale: 6.7.20070712
05:11:20 <Cale> fasta: ah, okay
05:11:27 <Cale> It's allowed to have bugs then :)
05:11:36 <fasta> Cale: no, doubt 6.6.1 has it too.
05:11:45 <dcoutts> etnt: yes, definitely recommend it (I wrote that review Cale pointed you at)
05:12:18 <fasta> Cale: how should that class declaration for MonadGraph look like?
05:12:41 <fasta> Cale: I think it should have MonadState in the context
05:12:47 <Cale> fasta: I don't know what the operations of MonadGraph are
05:13:15 <Cale> What is a graph monad?
05:14:03 <fasta> Cale: http://pastebin.ca/626106
05:14:38 <etnt> dcoutts: great, I've ordered it :-)
05:14:43 <Cale> Isn't that just MonadState in disguise?
05:14:49 <fasta> Cale: almost
05:14:57 <Cale> What's the difference?
05:14:59 <fasta> Cale: "put" puts the state, not the graph
05:15:17 <Cale> So it's a StateT over State?
05:15:45 <fasta> Cale: GraphMonadT is a newtyped StateT.
05:15:47 <Cale> or a state with a pair for the state type?
05:16:10 <Cale> Which monads are you planning on transforming?
05:16:51 <fasta> Cale: MaybeT, ContT
05:17:05 <fasta> Cale: those are the ones were working before I tried to add MonadGraph
05:17:25 <Cale> hmm
05:17:43 <Cale> So you want failure, continuations, and two kinds of state.
05:18:19 <fasta> Cale: http://pastebin.ca/626111
05:18:56 <fasta> Cale: there is the existing type. Originally all operations where written against that structure, but I would like automatic lifting, so I need MonadGraph
05:19:08 <fasta> were*
05:19:23 <fasta> Cale: that type shouldn't be changed
05:19:50 <timbod> Pre-contest question - is there an easy way to set darcs up to send patch commit notification emails?
05:20:25 <timbod> I found this: http://lists.osuosl.org/pipermail/darcs-users/2005-May/007564.html ,but it seems complex.
05:20:27 <lambdabot> Title: [darcs-users] darcs wrapper for email notification on remote push over ssh, http://tinyurl.com/ysb9fq
05:21:10 <Cale> timbod: vincenz and I fixed up a darcs IRC notifier for lambdabot this morning, probably it will get into the main branch soon.
05:21:37 <Cale> (not that that's quite the same:)
05:22:34 <timbod> mnislaih was already trying to get such a thing going for our lambdabot. Can you share a patch yet?
05:23:10 <Cale> vincenz: still about?
05:23:46 <Cale> cpoucet: hi, timbod would like a copy of our patches to lambdabot
05:23:59 <cpoucet> Cale: I emailed it to dons
05:24:04 <Cale> ah, okay
05:24:17 <Cale> So it should be in the general darcs repo soon :)
05:24:28 <vincenz> whoops
05:25:27 <fasta> Cale: do you understand the problem?
05:25:29 <Cale> fasta: In my experience, automatic lifting is only particularly convenient if you're using the monad transformers without newtyping the result.
05:25:40 <Cale> I'm not sure I completely understand the problem...
05:26:08 * jethr0 is not so sure how he feels about newtype'd monad stacks. should i generally do that?
05:26:20 <vincenz> yes
05:26:23 <Cale> jethr0: yes
05:26:47 <fasta> Cale: I want that when "put" is executed only "other state" is remembered.
05:26:56 <jethr0> ;(. another thing to get used to. *yeah, "learning" is fun*
05:27:09 <fasta> Cale: That was already working.
05:27:14 <Cale> jethr0: It's usually easier to manage.
05:27:24 <fasta> Cale: but.. I just want to have it generalized to MonadGraph
05:27:39 <jethr0> i think there's example somewhere in the wiki. any ideas where that was? i think it was by cale, no?
05:27:47 <fasta> Cale: and MonadGraph needs to support the operations as pasted and the MonadState functions.
05:27:59 <Cale> jethr0: http://cale.yi.org/index.php/How_To_Use_Monad_Transformers
05:28:05 <lambdabot> Title: How To Use Monad Transformers - CaleWiki
05:28:05 <jethr0> thx
05:29:23 <Cale> fasta: okay. So your problem is in writing an instance of the class for a ContT transformed monad?
05:29:26 <timbod> cale: thanks - I'll keep my eye out for the patch.
05:29:29 <fasta> Cale: no
05:30:14 <fasta> Cale: Isn't it possible to make the connection between MonadState and MonadGraph?
05:30:25 <fasta> Cale: such that I automatically get those instances?
05:32:04 <Cale> "MonadGraph also should support the MonadState operations." -- what exactly does this mean? You want MonadGraph to be a subclass of MonadState?
05:32:29 <fasta> Cale: yes
05:32:42 <Cale> You can't have it so that writing an instance of MonadGraph automatically gives an instance of MonadState
05:32:58 <Cale> But you can insist that an instance of MonadState gets written.
05:33:13 <Cale> class (Monad m, MonadState s m) => ...
05:34:40 <Cale> Well, maybe you could write a general instance if you turned on enough compiler extensions.
05:35:14 <fasta> Cale: I want to store two pieces of information: the graph of type graphtype and otherstate of type otherstate. But GraphMonadT is newtypes as newtype GraphMonadT graphtype m result
05:35:18 <Cale> in particular, those strange typeclass extensions -fallow-*-instances extensions.
05:35:35 <Cale> er, that was awkwardly phrased, but you know what I mean :)
05:36:10 <Cale> fasta: right.
05:36:27 <fasta> newtyped*
05:36:36 <Cale> So you want an instance (MonadState s m) => MonadState (GraphMonadT g m a) where ...
05:36:38 <Cale> ?
05:36:43 <Cale> er
05:36:48 <Cale> instance (MonadState s m) => MonadState s (GraphMonadT g m a) where ...
05:37:50 <fasta> instance (Monad m) => MonadState state (GraphMonadT (GraphState graphtype state) m) where
05:37:56 <fasta> Don't I need an instance like that?
05:38:15 <Cale> uh, maybe?
05:38:23 <Cale> It depends on what you want get and put to do.
05:38:43 <fasta> I want put to put only the state there, and not the graph type.
05:38:56 <fasta> So, it only changes part of the GraphState
05:39:20 <Cale> yeah, if GraphMonadT is responsible for both types of state, then that looks about right
05:39:28 <fasta> Really, the problem is only to generalize what I had and to put it into a class MonadGraph
05:40:13 <fasta> But I don't have a clear idea how this MonadGraph class should like s.t. I don't need to write all kinds of ContT instances.
05:41:56 <fasta> Logically, since modify_graph has type (graphtype -> graphtype) -> m (), it seems that graphtype needs to be a class parameter. From that it follows that other_state also needs to be different parameter, but then it doesn't seem to map on GraphMonadT, since that combines the two into one.
05:45:14 <fasta> instance (MonadState (GraphState graphtype s) m) =>  MonadGraph (GraphMonadT (GraphState graphtype s) m) graphtype s where
05:45:24 <fasta> Cale: I think that is the correct instance.
05:46:24 <kjdf> hi
05:46:43 <kjdf> is there a way to call c varargs functions using GHC's foreign interface?
05:46:53 <kjdf> namely I am interested in linux ioctls
05:47:04 <Saizan> fasta: i think that means you have two GraphStates in the resulting monad
05:47:40 <fasta> Saizan: uhm, right
05:48:07 <mauke> kjdf: I don't think so :/
05:49:58 <Cale> kjdf: You can call them in fixed ways, but actual variadic usage doesn't seem possible.
05:50:51 <Cale> kjdf: So you could produce a bunch of wrappers around ioctl easily, but nothing completely general.
05:50:54 <fasta>     No instance for (MonadGraph
05:50:54 <fasta> 		       (Control.Monad.Cont.ContT
05:50:54 <fasta> 			  ()
05:50:55 <fasta> 			  (Omega.GraphMonadTypes.GraphMonadT
05:51:04 <fasta> Ok, now I am back where I started.
05:51:06 <mauke> Cale: AFAICS you'd have to write the wrappers in C
05:51:15 <kjdf> ok, I am doing this right now
05:51:26 <Cale> mauke: really? Can't you just assign a suitable Haskell type?
05:51:27 <kjdf> but I didn't like carrying c blobs alongside
05:51:46 <mauke> Cale: vararg functions can use a different calling convention
05:52:05 <mauke> calling it through a wrong type can cause UB
05:52:05 <jethr0> @paste
05:52:05 <lambdabot> Haskell pastebin: http://hpaste.org/new
05:52:10 <Cale> fasta: You don't have an instance of MonadGraph for ContT, that's what I asked about before.
05:52:38 <hpaste>  jethr0 pasted "struggling with monadT newtype" at http://hpaste.org/1776
05:52:46 <fasta> Cale: right, but since, it's so very much the same as MonadState, isn't there some simple way to use that one?
05:53:04 <Cale> fasta: I don't understand what you mean.
05:53:25 <jethr0> grr, now the newtype is mostly working, but the call from "queens" to "newQueen" fails because "newQueen" doesn't have type "StateT a () b" *grr*
05:54:10 <fasta> Cale: MonadGraph should be a subclass of MonadState, so it should simply use MonadState's ContT stuff.
05:54:15 <Cale> jethr0: You might have to wrap some of your primitive operations in the newtype constructor.
05:54:35 <Cale> fasta: That doesn't make sense.
05:54:54 <quicksilver> jethr0: you've written 'queens' as a StateT action
05:55:02 <quicksilver> jethr0: and put QQ on the outside
05:55:14 <quicksilver> jethr0: it would make more sense to write queens as a QQ action
05:55:23 <Cale> fasta: If you just want an instance of MonadState, you probably already have it, but that's not what it's complaining about.
05:55:25 <quicksilver> jethr0: and then it would have the right type to 'call' newQueen
05:55:37 <jethr0> quicksilver: i'm trying to do that. this was my quickfix for the compile error ;) *sighs*
05:56:01 <quicksilver> jethr0: the problem was probably that you didn't have a MonadState instance?
05:56:04 <Cale> fasta: It's complaining that it doesn't know how to, say, modify_graph, in a ContT ...
05:56:06 <quicksilver> jethr0: and so it complained about 'get' ?
05:56:12 <jethr0> quicksilver: but then it says: "QQ is not an instance of MonadState". so do i have to lift the "get" or wrap it, or what
05:56:18 <jethr0> right
05:56:26 <quicksilver> jethr0: derive monadstate
05:56:29 <Cale> fasta: The instance for MonadState doesn't say how to do that, and it can't read your mind :)
05:56:48 <fasta> Cale: hmm, ok, well, I think I was in a bit of a complaining state.
05:56:56 <fasta> Cale: thanks, that gives some motivation
05:56:58 <jethr0> it's not auto-derivable. deriving it myself kinda defeats the purpose of newtyping the stack, doesn't it?
05:57:16 <quicksilver> jethr0: it is derivable
05:57:22 <quicksilver> jethr0: (in ghc)
05:57:24 <jethr0> Cale: i thought haskell was a DoWhatIMean language
05:57:28 <quicksilver> jethr0: with newtype-deriving
05:57:42 <jethr0> Can't make a derived instance of `MonadState (QQ a)'
05:57:43 <jethr0>       (even with cunning newtype deriving:
05:57:45 <jethr0>        `MonadState' does not have arity 1)
05:57:52 <Cale> MonadState s
05:57:59 <vincenz> jethr0: obviously, you need a state type
05:58:01 <vincenz> QQ s a
05:58:06 <Cale> You have to specify the state type in your deriving clause
05:58:17 <quicksilver> deriving MonadState a
05:58:18 <jethr0> obviously! *starts to cry*
05:58:20 <quicksilver> as it happens :)
05:58:27 <jethr0> k, i can see that
05:58:30 <quicksilver> vincenz: he does. QQ a b, it is :) he just missed the a
05:58:38 <jethr0> yuchu
05:58:48 <vincenz> oh :)
05:59:02 <vincenz> Cale: get your skype fixed
05:59:07 * vincenz flicks his whip
06:01:33 <jethr0> since when do benevolent dictators have whips?
06:06:23 <fasta> Cale: with the newtyped GraphMonad(not GraphMonadT) can I write an instance for MonadState for that one and then use that on in GraphMonadT?
06:06:34 <fasta> one*
06:28:36 <EvilTerran> hurrah! i've converted someone who'd never even heard of Haskell to xmonad :D
06:29:48 <MyCatVerbs> EvilTerran: pre-built binary?
06:30:06 <EvilTerran> actually, he says he prefers the darcs one
06:30:32 <MyCatVerbs> Oh, rocking out. Whassa difference?
06:30:48 <EvilTerran> "the darcs version has nifty stuff like a floating layer, logging hooks for putting your workspaces on a status bar, and other things"
06:30:52 <EvilTerran> (says he)
06:30:56 <fasta> Cale: I found the solution
06:31:29 <MyCatVerbs> fasta: ephedrine dissolved in ether?
06:31:41 <etnt> EvilTerran: what is need to try it out, install and "exec xmonad" in ~/.xinitrc ?
06:32:15 <opqdonut> "if you're not part of the solution, you're part of the mixture"
06:32:15 <EvilTerran> i don't remember off-hand, i'm afraid. sounds plausible.
06:32:28 <EvilTerran> opqdonut, precipitate, shurely?
06:32:35 <opqdonut> oh, yes
06:32:44 <opqdonut> couldn't remember the exact fom :)
06:32:45 <opqdonut> +r
06:32:54 <fasta> I don't see why people recommend "exec"
06:33:04 <fasta> It's premature optimization
06:33:08 <opqdonut> meneither
06:33:12 <dcoutts> @seen dons
06:33:12 <lambdabot> dons is in #xmonad, #haskell-soc and #haskell. I last heard dons speak 3h 58m 44s ago.
06:33:18 <opqdonut> gah, this ssh la is killing my typing
06:33:21 <EvilTerran> instance ChemistryGeek EvilTerran -- ;]
06:33:25 <vincenz> dcoutts: you competing?
06:33:26 <opqdonut> *lag
06:33:30 <dcoutts> vincenz: nope
06:33:33 <vincenz> :|
06:33:57 <MyCatVerbs> Competing?
06:34:09 <fasta> Who is competing?
06:34:15 <fasta> MyCatVerbs: ICFP
06:34:29 <MyCatVerbs> Ah.
06:35:05 <fasta> MyCatVerbs: that substance is illegal in my country
06:35:15 <fasta> MyCatVerbs: at least not freely available
06:35:19 <MyCatVerbs> Ephedrine?
06:35:21 <MyCatVerbs> Or ether?
06:35:26 * MyCatVerbs would hope only the former.
06:35:31 <fasta> MyCatVerbs: the former
06:35:55 <fasta> I don't like the attitude of makinge everything illegal.
06:35:59 <fasta> making*
06:36:10 <MyCatVerbs> Though I think the Yanks send FBI agents around to spy on you if you buy enough ether.
06:36:30 <fasta> Laws aren't made for rational people and all that.
06:36:37 <MyCatVerbs> Solvents being useful for purifying cocaine, etc.
06:36:53 <MyCatVerbs> fasta: people aren't, generally speaking, rational.
06:37:04 <fasta> MyCatVerbs: neither are computers ;)
06:37:06 <jethr0> making all solvents illegal would make non-water-based painting a lot harder
06:37:08 <vincenz> unless they are mathematicians
06:37:16 <SamB_XP> MyCatVerbs: are they at least real?
06:37:33 <fasta> MyCatVerbs: as an approximation some small percentage of humans are.
06:38:31 <MyCatVerbs> fasta: this is true. I was referring specifically to the general case there.
06:39:04 <fasta> If you want to get completely negative, a human is an every changing finite state machine.
06:39:13 <fasta> er ever*
06:39:18 <MyCatVerbs> SamB: unfortunately, it seems so.
06:39:43 <MyCatVerbs> SamB: (frankly, I think the world would be a much nicer place if some of its inhabitants were soley imaginary).
06:39:52 <SamB_XP> I'm just glad they aren't quaternians or hypercomplex!
06:43:56 <fasta> Arg, now I get overlapping instances.
06:44:28 <fasta> I need to be able to write an instance for the non-transformer version of GraphMonadT
06:44:44 * wli slapped a quaternion module on hpaste.org recently.
06:48:09 * wli is about to struggle with mutable arrays.
06:53:08 <fasta> Hmm, I don't like programming infrastructure.
06:53:15 <fasta> But it works :)
06:53:30 <fasta> It needs -X=AllowOverlappingInstances, though.
06:55:46 <vincenz> 20h..
06:56:07 <fasta> vincenz: countdown?
06:56:12 <vincenz> jah
06:56:21 <fasta> vincenz: who is on your team?
06:57:19 * jethr0 .
06:58:02 <vincenz> fasta: check link in topic?
06:58:09 <Lemmih> fasta: I am. And that guy and that guy. *points around the channel*
06:58:15 <vincenz> adept, cale, jethr0, lemmih, psykotic, vincenz and zeeeeee
06:59:34 <fasta> vincenz: I didn't see the topic. Now, I have. Thanks
07:00:07 <sfultong> some day I hope to consider myself good enough to be in ICPF
07:00:18 <sfultong> *ICFP
07:10:16 * fasta sees dcoutts says something good came from Gentoo. Who would have thought *that*?
07:10:26 <dcoutts> oi!
07:10:29 <dcoutts> ;-)
07:11:07 <dcoutts> fasta: Gentoo's Haskell team have done quite a lot of good work testing and improving things for everyone, not just for Gentoo users
07:11:22 <fasta> I want such a tool for Debian too!
07:11:28 <fasta> And a pony!
07:11:47 <dcoutts> fasta: as it happens, you don't need one (such a tool, perhaps you do need a pony)
07:11:51 <sfultong> talking about gentoo's haskell team... when is ghc 6.6 going to be unmasked?
07:11:57 <Igloo> What tool is this?
07:12:00 <dcoutts> sfultong: ask kolmodin
07:12:05 <fasta> dcoutts: What's the team? I know you are on it, but who's the rest?
07:12:18 <dcoutts> fasta: debian doesn't need one since they only use binary packages
07:12:21 <fasta> dcoutts: I don't need such a tool?
07:12:24 <fasta> dcoutts: Yes, I do.
07:12:45 <fasta> dcoutts: something like that anyway
07:12:48 <dcoutts> so their repos of binary packages are always consistent, they rebuild deps when necessary
07:12:57 <sfultong> @seen kolmodin
07:12:58 <lambdabot> kolmodin is in #xmonad, #haskell and #darcs. I last heard kolmodin speak 4h 37m 29s ago.
07:13:02 <kolmodin> hey
07:13:16 <fasta> dcoutts: when I install edison from darcs for ghc-6.7 and install a new 6.7 I need to rebuild it by hand
07:13:17 <dcoutts> can we get lambdabot back into #gentoo-haskell btw? we miss her
07:13:24 <sfultong> kolmodin: ghc 6.6 unmasked?
07:13:27 <dcoutts> who is a lambdabot admin round here?
07:13:30 <dcoutts> @seen sorear
07:13:31 <lambdabot> Last time I saw sorear was when I left #darcs, #dreamlinux-es, #friendly-coders, #gentoo-haskell, #gentoo-uy, #ghc, #haskell, #haskell-blah, #haskell-overflow, #haskell-soc, #jtiger, #oasis, #parrot,
07:13:31 <lambdabot>  #perl6, #scannedinavian, #unicycling and #xmonad 14d 14h 12m 7s ago, and .
07:13:31 <vincenz> dcoutts: me
07:13:36 <vincenz> @join gentoo-haskell
07:13:36 <kolmodin> no. we'll go for 6.6.1 right away :)
07:13:37 <dcoutts> vincenz: please? :-)
07:13:40 <vincenz> dcoutts: but I think she's overchanneled
07:13:43 <vincenz> dcoutts: that's why she isn't there
07:13:44 <fasta> dcoutts: If I could simply register the darcs dir of edison, that wouldn't be necessary.
07:13:49 <sfultong> kolmodin: ok, that's good as well
07:13:54 <quicksilver> overchanneled?
07:13:58 <kolmodin> I'm currently updating the ebuild with some new ideas dcoutts had last night
07:14:03 <vincenz> dcoutts: she there now?
07:14:09 <dcoutts> vincenz: not yet
07:14:13 <dcoutts> vincenz: so we should run our own you mean?
07:14:22 <vincenz> I can make her leave another channel..
07:14:42 <quicksilver> when does the contest start?
07:14:47 <vincenz> in < 20h
07:15:03 <dcoutts> vincenz: oh, so it's a freenode limit on number of channels one can join?
07:15:03 <vincenz> dcoutts: suggestions?
07:15:08 <vincenz> dcoutts: yes
07:15:15 <vincenz> dcoutts: or I can give you oasisbot
07:15:21 <dcoutts> what is #jtiger ?
07:15:24 <vincenz> no idea
07:15:31 <vincenz> http://jtiger.org/
07:15:32 <lambdabot> Title: JTiger Unit Testing Framework for Java 2 Standard Edition 1.5
07:15:39 <dcoutts> vincenz: all I know is that we use lambdabot extensively in #gentoo-haskell
07:15:39 <vincenz> @leave jtiger
07:15:44 <vincenz> @join gentoo-hashekkl
07:15:48 <vincenz> @leave gentoo-hashekkl
07:15:50 <vincenz> @leave gentoo-haskell
07:15:56 <vincenz> @seen lambdabot
07:15:56 <lambdabot> Yes, I'm here. I'm in #happs, ##logic, #xmonad, #unicycling, #perl6, #parrot, #oasis, #jtiger, #haskell-soc, #haskell-overflow, #haskell-blah, #haskell, #ghc, #darcs and #scannedinavian
07:16:06 <quicksilver> good luck to all contestants!
07:16:07 <LeCamarade> vincenz: Man, change keyboards. :o)
07:16:10 <vincenz> @part #jtiger
07:16:13 <vincenz> @seen lambdabot
07:16:14 <lambdabot> Yes, I'm here. I'm in #happs, ##logic, #xmonad, #unicycling, #perl6, #parrot, #oasis, #haskell-soc, #haskell-overflow, #haskell-blah, #haskell, #ghc, #darcs and #scannedinavian
07:16:19 <vincenz> @join #gentoo-hashekkl
07:16:24 <vincenz> LeCamarade: it's my typist
07:16:26 <LeCamarade> :-o
07:16:26 <kolmodin> vincenz: close.. :)
07:16:29 <vincenz> doh
07:16:31 <LeCamarade> =))
07:16:33 <vincenz> @part #gentoo-hashekkl
07:16:35 <LeCamarade> :-D
07:16:37 <vincenz> @join #gentoo-haskell
07:16:37 <kolmodin> :D
07:16:38 <quicksilver> it's a jewish lolcat
07:16:39 <LeCamarade> Hahahaha
07:16:41 <vincenz> @seen lambdabot
07:16:41 <lambdabot> Yes, I'm here. I'm in #gentoo-haskell, #happs, ##logic, #xmonad, #unicycling, #perl6, #parrot, #oasis, #haskell-soc, #haskell-overflow, #haskell-blah, #haskell, #ghc, #darcs and #scannedinavian
07:16:41 <dcoutts> vincenz: yay! thanks
07:16:42 <quicksilver> icanhazshekel?
07:16:42 <kolmodin> thanks :)
07:16:44 <vincenz> dcoutts: welcome
07:17:00 <quicksilver> s/jewish/israeli/ I guess
07:17:15 <fasta> dcoutts: In what language is the gentoo tool build?
07:17:53 <dcoutts> fasta: kosmikus based it on a similar tool by the python team, so it's in python (but then the portage API itself is in python so that makes sense)
07:17:54 <vincenz> dcoutts: I'd move oasisbot to #oasis, but people want logs, and the logs from oasisbot aren't public (#oasis is again the general icfp discussion channel this year)
07:18:13 <dcoutts> vincenz: ah
07:18:33 <vincenz> anyways, jtiger seemed way off
07:18:40 <dcoutts> fasta: it's not applicable to a non-gentoo system at all
07:19:15 <dcoutts> fasta: the idea is, the implementation isn't
07:19:22 <fasta> There should be some micro payment system.
07:19:44 <vincenz> dcoutts: shame you guys can't compete this year
07:20:51 <roconnor> are doubles bigger on 64 bit machines?
07:21:12 <nopcode> of course not, ieee
07:21:16 <kolmodin> sfultong: so.. we'd like to test a little more wrt upgrading 6.4.2->6.6.1.. and some new features of our ebuild. after that it will be unmasked
07:22:15 <dcoutts> vincenz: it's exhausting
07:22:21 <vincenz> dcoutts: true, but fun
07:22:25 <fasta> Hmm, a >1700 lines diff is not a standard way to work with darcs, is it?
07:23:29 <fasta> Are you using a darcs mode in Emacs?
07:23:32 <SamB_XP> fasta: it depends on what it is you are doing
07:23:43 <sfultong> kolmodin: great, do you need other testers?
07:23:50 <SamB_XP> if you are adding >1700 lines of code, there's no real problem
07:24:23 <fasta> SamB_XP: I rewrote a terrible algorithm partially and refactored it such that I don't need to lift stuff anymore.
07:24:40 <fasta> SamB_XP: i.e. something analogous to MonadState was introduced
07:25:04 <SamB_XP> fasta: did you also change the whitespace?
07:25:12 <kolmodin> sfultong: sure :)
07:25:14 <fasta> SamB_XP: no
07:25:29 <SamB_XP> who's repository are you hacking on?
07:25:34 <SamB_XP> your own?
07:25:36 <fasta> SamB_XP: my own :)
07:25:39 <kolmodin> sfultong: we coordinate in #gentoo-haskell
07:25:41 <SamB_XP> well don't worry then
07:26:04 <fasta> I should spend some more time on working on other peoples code, I guess.
07:26:26 <fasta> I have this crazy idea that that is a lot harder.
07:26:44 <roconnor> @where smallcheck
07:26:44 <lambdabot> http://www.cs.york.ac.uk/fp/smallcheck0.2.tar
07:26:53 <roconnor> tar!
07:27:37 <wli> Does mapArray operate in-place?
07:28:06 <SamB> wli: I hope it will fuse
07:28:11 <Saizan> how should i write the .cabal file for a small program that have a bunch of non-hierarchical modules? cabal complains that it's a library and it can't build it correctly
07:28:24 <wli> I'm going to guess I at least need a variable for it.
07:28:34 <SamB> Saizan: put a blank line before the stanza describing the program
07:29:34 <Saizan> SamB: it's yet there
07:29:38 <roconnor> @type mapArray
07:29:40 <lambdabot> Not in scope: `mapArray'
07:29:48 <roconnor> @hoogle mapArray
07:29:48 <lambdabot> Data.Array.MArray.mapArray :: (MArray a e' m, MArray a e m, Ix i) => (e' -> e) -> a i e' -> m (a i e)
07:30:28 <mauke> wait, mapArray can't work in-place
07:31:04 <fasta> mauke: it might work in place
07:31:21 <mauke> if you restrict the function to (e -> e), yes
07:31:38 <wli> do { m <- newArray ((1,1),(n,n)) 0 ; m <- mapArray (...) m ; ... }
07:31:40 <fasta> mauke: but only after it has been determined that it's not used anywhere else and with your condition.
07:31:48 <wli> mauke: That's guaranteed.
07:31:56 <fasta> But probably compilers aren't that smart.
07:32:52 <roconnor> mauke: why do we have to restirct to (e -> e)
07:33:02 <roconnor> mauke: arrays are boxed
07:33:22 <mauke> you can't change the type of a variable
07:33:30 <roconnor> the elements of arrays are boxed.
07:33:34 <roconnor> they are just pointers
07:33:41 <mauke> and typed
07:33:46 <Philippa> mauke: yeah, but it's different if it's used linearly
07:33:49 <quicksilver> you could reuse the 'array spine'
07:33:50 <roconnor> the type isn't stored at runtime (usually)
07:33:55 <Philippa> that is: if the old array is clearly /gone/ then go ahead
07:33:57 <quicksilver> although I don't know how big a win that would be
07:34:08 <quicksilver> it's not as if spines are all that expensive to allocate
07:34:10 <quicksilver> maybe, though
07:34:11 <wli> What I really need is something like transformArray :: MArray i e m => MArray i e -> (i -> e) -> [i] -> m (MArray i e)
07:34:32 <wli> feh
07:34:43 <roconnor> @instances MArray
07:34:44 <lambdabot> Couldn't find class `MArray'. Try @instances-importing
07:34:55 <roconnor> Are UArrays MArrays?
07:34:56 <Saizan> SamB: removing hs-source-dirs and so copying the sources in ./ worked
07:35:29 <mauke> do { r <- newIORef 42; x <- readIORef r; modifyIORef r show; y <- readIORef r; return (x, y) }
07:35:32 <wli> transformArray :: MArray a e m => a i e -> (i -> e) -> [i] -> m (a i e)
07:35:49 <wli> or transformArray :: MArray a e m => a i e -> (i -> e) -> (i,i) -> m (a i e)
07:36:12 <roconnor> @hoogle modifyIORef
07:36:13 <lambdabot> Data.IORef.modifyIORef :: IORef a -> (a -> a) -> IO ()
07:36:13 <lambdabot> Data.IORef.atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
07:36:19 <xerox> maybe i -> e -> e
07:36:44 <roconnor> mauke: okay, I see your point.
07:39:36 <SamB> wli: why do you need that?
07:40:06 <wli> SamB: To fill in a matrix more conveniently.
07:40:31 <wli> I wonder if mapM or mapM_ will do.
07:40:41 <wli> (and if so, which of the two)
07:40:53 <SamB> mapM_ should do nicely
07:41:03 <SamB> IMO
07:41:09 <wli> Sounds like a plan.
07:41:41 <SamB> hmm.
07:41:44 <SamB> actually...
07:42:22 <wli> m <- mapM (blah blah blah writeArray blah blah) [indices] just to be safe?
07:43:13 <SamB> wli: how is that safer than mapM_?
07:43:19 <SamB> and what are you going to do with the m?
07:43:51 <SamB> personally, I generally write purely functional code and (so far) hope for the best
07:43:54 <wli> SamB: It probably needs to be a foldM but clobber the variable named m representing the matrix.
07:44:07 <savanni> Hey, quick question here, and not about the haskell language...
07:44:23 <SamB> savanni: you want to know what videogame to play next?
07:44:37 <savanni> The fa.haskell newsgroup appears to also be the haskell-cafe mailing list.  Does anybody know if it is possible to post to the newsgroup and not the mailing list?
07:45:12 <SamB> why would you want to do that?
07:45:13 <savanni> Not that I'm wanting to *exclude* the mailing list, I just want to know if I need to be subscribed to it in order to post, but I want to read on the newsgroup and not in my eamil.
07:45:31 <wli> Trick #2 here is that I've got additional state beyond the matrix itself, namely a memo table for computing the elements thereof.
07:45:33 <savanni> (maybe I'm making this too complicated?)
07:45:40 <SamB> I don't think you need a subscription to post
07:46:04 <SamB> your posts might wait in the mailman moderation queue though
07:46:24 <int-e> wli: mapM_ will do
07:46:25 <SamB> but soon someone will probably exempt you from that
07:46:28 <savanni> Hmm... that would put more load on the moderator, so maybe I should subscribe but not have delivery.
07:46:40 <savanni> Okay, I can work with that.  Thank you!
07:47:08 <SamB> does haskell.org provide that option?
07:47:14 <SamB> subscribing with no delivery?
07:47:15 <Philippa> IIRC it does, yeah
07:47:18 <savanni> (as for what video game to play next, I am severely restricted by the hardware and software at my disposal)
07:47:19 <SamB> that would be ideal
07:47:20 <int-e> wli: the IO and ST monad introduce artificial data dependencies to force sequential execution of the actions.
07:47:22 <savanni> Dunno, but I'll find out.
07:47:38 <SamB> you could play ZZT, then
07:47:40 <savanni> (and even more restricted by the time available to me)
07:48:08 <SamB> oh. perhaps a curses minesweeper then ;-)
07:48:14 <savanni> hah!
07:48:23 <crazy_coder> what is the std function which gives the last element of a list ?
07:48:24 <int-e> wli: at least as they're implemented in ghc.
07:48:26 <savanni> I could try coding a curses minesweeper in Haskell...
07:48:29 <crazy_coder> like head ?
07:48:31 <SamB> crazy_coder: last ;-)
07:48:32 <sfultong> savanni: nethack or ADOW
07:48:39 <MyCatVerbs> sfultong: ADOW? ADOM?
07:48:40 <wli> int-e: Is that good or bad?
07:48:43 <crazy_coder> > last [1,2]
07:48:44 <lambdabot>  2
07:48:52 <sfultong> errr.. that one with the M
07:49:07 <crazy_coder> SamB ok Thanks
07:49:19 <int-e> wli: hmm? it's good I think - these monads are meant for sequential execution after all.
07:49:19 <SamB> you're welcome
07:49:29 <savanni> Okay, thank you all.  Disappeaoring again.
07:49:48 <int-e> wli: when you write do print "a"; print "b"  you want 'a' to be printed before 'b'.
07:49:56 <Philippa> savanni: why not stay around? I mean, aside from the sheer volume of traffic in chan?
07:50:26 <savanni> sheer volume of traffic. I never read backscroll on because I just cannot keep up.
07:50:33 <wli> int-e: This probably doesn't have quite as much sequential dependency apart from accumulating the memo table.
07:50:49 <savanni> And I feel bad going too idle on a channel for too long.
07:51:24 <Philippa> ah. About 90% of the nicks in here're idlers anyway, so nobody here'll mind
07:51:27 <int-e> wli: if you just want a memo table, is Data.Array + lazy evaluation good enough?
07:51:28 <mauke> savanni: haha, why?
07:51:34 <wli> int-e: It'd be easy to chop it up into several independent components, though (one for each group of rows).
07:51:35 <mauke> idling is expected
07:51:40 <savanni> mauke: kinda feel like dead weight.
07:51:57 <savanni> I know, weird concept on the internet.
07:51:57 <wli> int-e: The memoization I've got handled elsewhere. The array itself is not a memo table.
07:52:07 <Philippa> hell, I'm mostly idle and I'm organising a haskell event over the summer
07:52:33 * SamB named his Windows computer "deadweight"
07:52:52 <MyCatVerbs> Philippa: where to?
07:52:53 <wli> int-e: The individual array elements are computed from a recurrence where numerous repeated sub-computations would occur without a memo table.
07:53:05 <MyCatVerbs> Philippa: Heck, what about? When? Details, please?
07:53:27 <Philippa> @wiki AngloHaskell
07:53:27 <lambdabot> http://www.haskell.org/haskellwiki/AngloHaskell
07:53:47 <SamB> why does all the good stuff have to happen in the UK?
07:54:12 <Philippa> because UK people get round to organising good stuff?
07:54:13 <vincenz> they're still miffed about all the tea
07:54:14 <MyCatVerbs> SamB: because it always used to be in the US, now we're taking advantage.
07:54:18 <MyCatVerbs> I mean, uh.
07:54:21 <ari> Maybe there's something about Brits and Haskell in general?
07:54:32 <pejo> SamB, Glasgow, MSR, Nottingham, Oxford.. I see a pattern.
07:54:33 <Philippa> admittedly the concentration of people and the size of the UK help somewhat
07:54:36 <MyCatVerbs> ari: a couple of universities teach it, AFAIK.
07:54:50 <MyCatVerbs> ari: (mine does ¬¬)
07:54:57 <Philippa> yeah, I got taught it at Nottingham back in 2001
07:55:19 * Igloo points at Freiburg
07:55:29 <MyCatVerbs> I got, er, exposed to it in my first year here at Bristol, just this last year. And pretty much immediately hooked.
07:55:47 <pejo> Igloo, clearly that's not in UK. :-)
07:55:49 <SamB> pejo: don't they have an MSR in canada too?
07:55:50 <Philippa> Igloo: true, and I really should've shown to the previous hackathon but for my budget
07:55:52 <MyCatVerbs> So, is it possible to get trains to anywhere near Cambridge?
07:55:55 <Igloo> pejo: That's my point...
07:56:00 <Philippa> MyCatVerbs: like Cambridge itself?
07:56:09 <crazy_coder> MSR is microsoft Research ?
07:56:14 <Philippa> crazy_coder: yep
07:56:16 <pejo> SamB, that does entirely different things, yeah.
07:56:25 <MyCatVerbs> Philippa: well, taxis can be damn expensive, I definately wanna come to. Hence, trains?
07:56:29 <int-e> wli: I think mapM_ will do what you want except maybe that it isn't as parallel as it could be; I don't know of an easy way to make it run in parallel.
07:56:33 <crazy_coder> Philippa: you work for microsoft ?
07:56:35 <Philippa> the cab to MSR from the station shouldn't be too horrible
07:56:38 <Philippa> crazy_coder: I don't work
07:56:47 <SamB> the lead developer for ZSNES works at the MSR in canada
07:56:54 <MyCatVerbs> Philippa: what's the train station called, please?
07:56:58 <Philippa> Cambridge
07:57:02 <Igloo> I think taxi from teh station to MSR is about 8UKP, but don't quote me on that
07:57:08 <Igloo> You can also take busses
07:57:13 <MyCatVerbs> Ah, good 'nuff.
07:57:17 <Philippa> yeah, possibly slightly less - I paid about 8 from a bit further up the road
07:57:25 <wli> int-e: That's fine. The real CPU burn here will be solving the equations, not setting them up.
07:57:28 <MyCatVerbs> Busses... but can I take token rings?
07:57:30 <crazy_coder> what do you do at this event ?
07:57:32 <Philippa> it's even walkable for plenty of people
07:57:41 <MyCatVerbs> Philippa: define "walkable?"
07:57:51 <Philippa> crazy_coder: RTFWiki? There'll be talks on the Friday and plenty of socialising
07:58:02 <MyCatVerbs> Philippa: (my definition is, "within an hour on foot, including the time it takes to get lost at least once")
07:58:13 <Philippa> so long as you jotted down directions you'll be fine then
07:58:19 <MyCatVerbs> Ahahahahaha.
07:58:20 <crazy_coder> Webcast it ! I'll watch it over the net ;)
07:58:21 <MyCatVerbs> Fuck no.
07:58:34 <MyCatVerbs> I can get lost anywhere.
07:58:50 <wli> int-e: This is sort of a preliminary. The real meat here will be a system of quadratics.
07:58:51 <Philippa> can you get lost with a map and visible road names?
07:59:15 <Philippa> I intend to download a few screenfulls off the web onto my zaurus beforehand...
07:59:33 <crazy_coder> zaurus ?
07:59:39 <MyCatVerbs> Philippa: I has no Zaurus. And I usually manage to do something really stupid even with google maps printouts on hand.
07:59:55 <MyCatVerbs> Philippa: e.g. I've done wrong postcode and ended up halfway into a mess of industrial estates before. :)
08:00:08 <Philippa> crazy_coder: nice clamshell PDA w/a decent 640x480 screen
08:00:17 <Philippa> runs linux. I've got GHC running on mine :-)
08:00:21 <MyCatVerbs> Who'd've thought mapping programs would be so uppity about a 4 or a 3? :)
08:00:34 <MyCatVerbs> Philippa: I am so damn jealous. If those weren't so damn expensive...
08:00:57 <MyCatVerbs> What's the battery life on 'em, please? Eight hours?
08:00:58 <roconnor> Philippa: nice, can you place King's Quest on it?
08:01:02 <Philippa> yeah. I got mine mildly cheaper - a friend was going to Japan for business and as he'd been pimping the damn things at everyone I figured he could pick one up :-)
08:01:16 <Philippa> MyCatVerbs: About that, IIRC. You can underclock, too
08:01:18 <roconnor> er play
08:01:34 <Philippa> roconnor: IIRC you can get SCUMMVM working
08:01:35 <MyCatVerbs> roconnor: it's an Xscale chip, could hundred MHz.
08:01:53 <MyCatVerbs> Not *much* RAM, but enough. 64MBish, I think?
08:01:57 <Philippa> yeah, 64MB
08:02:03 <roconnor> 100 MHz sounds fine
08:02:05 <wli> int-e: I don't quite have a subdivision algorithm for these things yet.
08:02:11 <MyCatVerbs> roconnor: I think it's two or three.
08:02:11 <roconnor> and 640KB is enough for anyone
08:02:14 <Philippa> plus you can always turn on swap
08:02:26 <Philippa> I've got a half gig swap partition on mine
08:02:33 <MyCatVerbs> Doesn't that murder the flash card?
08:02:38 <wli> swapping to flash?
08:02:54 <Philippa> I've got one of the HD models
08:03:15 <MyCatVerbs> It's a good thing you can't see faces over IRC, I just went bright green.
08:03:22 <vaste_> how would i go about parsing a 2gb xml in haskell?
08:03:23 <Philippa> yeah, it does bad things to flash over time, but if you used an SD card for swap on an older model it wouldn't be that horrific a cost
08:03:25 <MyCatVerbs> (Also, I'm ugly as sin and you don't wanna be burdened with that.)
08:03:32 <crazy_coder> mobile phones have 200 MHz processor I read somewhere
08:03:49 <Philippa> MyCatVerbs: last model Sharp ever produced, unfortunately :-(
08:03:57 <MyCatVerbs> vaste_: step one, find the person who put it into XML format and beat their head in.
08:03:59 <MyCatVerbs> Philippa: :(
08:04:25 <MyCatVerbs> Philippa: notice how electronics companies always stop producing the things that people actually *want*? And also refuse to sell them outside of Japan? :(
08:05:17 <vaste_> or is haskell really unsuited for such a task?
08:05:19 <wli> MyCatVerbs: It's well-known that you've got to move to Japan if you want consumer electronics.
08:05:44 <MyCatVerbs> wli: true dat.
08:05:51 <Philippa> vaste_: it depends on the parsing libs, and I don't know how many people in here know them
08:06:04 <Philippa> if you've got enough RAM to throw at the problem it'll work fine
08:06:47 <MyCatVerbs> Methought it was bindings to one of the C XML parsing libraries, so more or less the same as any other language?
08:06:57 <vaste_> isn't it kinda hard to get haskell to release and gc the beginning of the file?
08:07:52 <MyCatVerbs> vaste_: only if there are references hanging around to it that don't need to be. Same as any GC'd language.
08:08:33 <vaste_> i mean, say i create some parsed datastructure in the beginning of the parsing
08:08:39 <vaste_> but don't use it until the end
08:09:05 <vaste_> won't haskell delay parsing until the end, keeping the whole file in memory?
08:09:09 <MyCatVerbs> Then you're going to need to hang on to it no matter what programming language is in use.
08:09:43 <int-e> vaste_: it still depends. if your parsed structure contains copies of the file contents then the file contents can go away. you have to be a bit careful about laziness there.
08:10:05 <malcolmw> vaste_: if your use of the XML data is basically linear (streaming), then HaXml-1.17 can do lazy parsing of Gb files, no problem
08:10:24 <MyCatVerbs> It won't -neccessarily- have to read the file in at all until you actually use that datastructure, then it gets parsed and... bleh. It depends on all the specifics.
08:11:16 <vaste_> well, i meant it used the structure parsed in the beginning of the file in the end of the same file
08:12:09 <MyCatVerbs> Then it would've already done that parsing in order to have reached the end of the same file.
08:12:37 <MyCatVerbs> In the process of which it'd probably have discarded its last reference to the beginning of the file, and hence would be able to GC it.
08:13:14 <MyCatVerbs> (And it'd just still have the data structure from the start still hanging around, but would possibly be able to reclaim space from the file itself.)
08:13:50 <vaste_> but would it really perform the actual parsing?
08:14:06 <vaste_> wouldn't it rather just keep the unparsed contents until it's used in the end?
08:14:34 <malcolmw> vaste_: the data has to be really parsed, if the system is to know where it ends and the next data begins
08:15:35 <MyCatVerbs> vaste_: parsers, by their nature, can't ever work on the end of a file without munching the start of the file first.
08:16:13 <malcolmw> vaste_: but whether you can effectively select the initial portion of the resulting data structure, discard the middle, and keep only the end, is a different question
08:17:45 <vaste_> hm, say that the data is a huge String
08:18:09 <vaste_> and i want to parse it on the fly, so to speak
08:19:19 <lispy> ?src System.Directory.copyFile
08:19:19 <lambdabot> Source not found. Maybe if you used more than just two fingers...
08:19:30 <MyCatVerbs> Then most of the sane ways of writing it would naturally tend to discard the portion of the file that's been used, and wouldn't read any of the file in at all until you started using the data structures that your parser outputs.
08:22:12 <vaste_> i guess what i'm basically worried about is that there'll be some 'take 17 middleOfHugeGiganticString' left unevaluated
08:22:39 <crazy_code1> how to convert [[a]] into [a] ?
08:22:45 <Cale> crazy_code1: concat
08:23:09 <crazy_code1> > concat [[1,2,3],[4,5,6]]
08:23:10 <lambdabot>  [1,2,3,4,5,6]
08:23:13 <crazy_code1> ok
08:23:15 <crazy_code1> Thanks
08:23:17 <crazy_code1> great
08:23:20 <Cale> no problem
08:23:28 <vincenz> lol
08:23:35 <vincenz> join; q; a; quit
08:24:00 <quicksilver> ircleech :)
08:24:21 <vincenz> just like a lolcode program
08:24:24 <vincenz> CAN I HAS SOLUTION
08:24:27 <vincenz> KTHXBYE
08:24:27 <shazam> hrmph
08:25:06 <shazam> Cale, I've been working on the grammar refactoring problem
08:25:14 <shazam> to be able to handle left recursion
08:25:47 <shazam> and I'm a little stuck
08:25:49 <Cale> Ah, palomer. Some other people have been interested in left-recursion lately too. :)
08:26:10 <shazam> but I'm _very_ close
08:26:24 <vaste_> so, after parsing the huge string somehow, e.g. tokenizing, it'd just leave tiny string copies, possibly waiting to be parsed?
08:26:52 <shazam> this is how I'm going about it
08:27:14 <shazam> I have these functions Parser x -> Parser x
08:27:25 <shazam> you can take the union of two of them
08:27:29 <shazam> or the fixed point of them
08:28:05 <shazam> so a grammar: a = a | a 'b' is really
08:28:43 <shazam> a = fixed point of ((\z -> z) union (\z -> z 'b'))
08:29:10 <shazam> (bear with my notation)
08:29:35 <shazam> so given an element Parser x -> Parser x, the fixed point represents the final production
08:29:44 <shazam> and the union represents <|>
08:29:55 <Saizan> (a non-terminal  a = a | a 'b' gives an infinite recursion)
08:30:02 <shazam> Saizan, righto
08:31:19 <shazam> hmm, maybe I should write some haskell code to exemplify all of this
08:31:22 <shazam> brb
08:35:45 <hpaste>  shazam pasted "exemplifying my parser" at http://hpaste.org/1777
08:37:21 <mlguy> would anyone care to explain to a newbie the appropriate use of hpaste.org?
08:38:29 <shazam> ,type >>=
08:38:33 <shazam> ,t >>=
08:38:41 <shazam> man, what's the bot's name again?
08:39:17 <gkr> @type >>=
08:39:18 <lambdabot> parse error on input `>>='
08:39:20 <gkr> lambdabot
08:39:25 <doserj> @type (>>=)
08:39:25 <gkr> @type (>>=)
08:39:27 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
08:39:28 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
08:39:30 <gkr> Oops!
08:39:59 <EvilTerran> @quote stereo
08:40:00 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
08:40:10 <mlguy> @type fmap
08:40:12 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:40:34 * shazam goes and thinks about it some more
08:41:33 <EvilTerran> mlguy, if you want to ask about something, and have more code to show than would comfortably fit in one line in IRC, you can paste it in hpaste with your freenode nick and check the announce box, and then we'll leap to your assistance.
08:42:14 <vincenz> with emphasis on leap
08:42:28 <vincenz> #haskell people are karma-sluts
08:42:47 <EvilTerran> if you don't check the announce box, you can also use it to get your haskell HTML-ified without having to install anything ;]
08:43:10 <vincenz> EvilTerran: ooh, never thought about that usage
08:54:27 <ihope> What do you call something like ?x?
08:55:28 <Olathe> A guy with hooks for hands.
08:55:31 <EvilTerran> implicit parameter?
08:55:36 <ihope> Yes, that.
08:55:55 <ihope> @type \x -> let ?y = 3 in x
08:56:01 <lambdabot> forall t. t -> t
08:56:15 <ihope> > (\x -> let ?y = 3 in x) ?y
08:56:15 <lambdabot>  Parse error
08:56:22 <ihope> Mmh.
08:56:28 <ihope> @type (\x -> let ?y = 3 in x) ?y
08:56:30 <lambdabot> forall t. (?y::t) => t
09:15:35 <shapr> Good morning #haskell!
09:15:49 <vincenz> hullo shapr
09:15:57 <lispy> Good morning Mr. shapr
09:16:29 <shapr> Hello Monsieur Poucet
09:16:34 <shapr> Greetz Mr Dagit
09:19:19 <arcatan> gooooooood moooorning, #haskell
09:20:25 <arcatan> although it's evening here. mooooorning just sounds better than eeeevening
09:21:17 <xDie> @slap
09:21:17 <lambdabot> why on earth would I slap
09:21:22 <xDie> :'(
09:21:31 <xDie> lambdabot, i miss you
09:21:34 <xDie> :(
09:23:01 <wli> Kick ass. I think I've got the matrix set up. Now for the day job.
09:23:18 <arcatan> one cannot be told what matrix is
09:24:59 <dcnstrct> has anyone here compiled any of their haskell apps to run on the PStripple ? I found this ppu-gcc package from the Barcelona Super Computer Center.  I want to try cross-compiling with this.  Has anyone tried it and did you run into any snags ?
09:26:24 <Cale> dcnstrct: PStripple?
09:26:58 <dcnstrct>  Play Station III
09:27:33 <dcnstrct> it uses the Cell Broadband Engine
09:27:59 <Cale> ah, yeah.
09:28:13 <Cale> I don't know.
09:28:52 <Cale> http://www.haskell.org/pipermail/glasgow-haskell-users/2007-January/011841.html
09:28:54 <lambdabot> Title: Running GHC on the IBM Cell, http://tinyurl.com/3a4tqz
09:29:59 <Cale> http://www.haskell.org/pipermail/glasgow-haskell-users/2006-December/011810.html -- here's where the thread starts
09:30:00 <lambdabot> Title: Running GHC on the IBM Cell, http://tinyurl.com/2v9o6z
09:32:32 <dcnstrct> thnx a ton
09:34:58 <Cale> hmm, actually doesn't seem like there's too much there
09:35:19 <Cale> It seems like the Cell would be quite an effective machine to run Haskell code on.
09:36:54 <dcnstrct> yea I completely agree.
09:39:33 <Cale> I wonder if you could easily get HECs running on each of the SPEs independently. I don't really know too much about the low-level details of the GHC runtime.
09:49:29 <malcolmw> the problem with the SPEs is that they have a local code-store, and local memory. so you have to do some pretty interesting compilation tricks to use them
09:54:43 <svm_invictvs> Eelis: YO!
09:59:42 <araujo> hello
10:00:09 <jethr0> anyone know any nice set of programming problems like haskell-quiz, 99problems, ...
10:00:39 <jethr0> small problems that are still not trivial to solve or at least require some thought or advanced concepts to do nicely in haskell
10:00:40 <jethr0> ?
10:01:06 <wli> jethr0: I'm sort of coming up with some for myself.
10:01:35 <Botje> jethr0: have you checked the ACM archive?
10:01:51 <Botje> http://acm.uva.es/problemset/
10:01:52 <lambdabot> Title: online-judge.uva.es - PROBLEM SET ARCHIVE
10:02:10 <Botje> I started with haskell by trying to solve problems from there
10:02:25 <jethr0> i have had some looks at it in the past. many of the problems seemed quite difficult though when i last looked ;)
10:02:31 <jethr0> i'll try again
10:02:43 <glguy> Does anyone know when the abuse happened that got the +c back so I can read about it in the logs?
10:02:48 <jethr0> no, wasn't this page, thx
10:03:11 <jethr0> +c?
10:04:21 <glguy> jethr0: it's the irc mode that disables colors in a channel
10:05:04 <jethr0> ah
10:08:00 <malcolmw> bold
10:08:06 <Eelis> svm_invictvs: yo indeed.
10:08:28 <ddarius> glguy: The addition of IRC color codes to HsColour perhaps?
10:09:56 <malcolmw> we had a bold spammer yesterday (or was it Tue?) whom vincenz kicked
10:12:49 <SamB_XP> malcolmw: *groan*
10:15:47 <vincenz> malcolmw: I'm effective like that :)
10:16:16 <wli> I really don't like that problem set archive.
10:18:08 <wli> I like bigger, more "open" problems.
10:20:58 <vincenz> wli: like icfp :)
10:21:41 <wli> yes
10:24:24 <nominolo> @src IO mplus
10:24:24 <lambdabot> m `mplus` n = m `catch` \_ -> n
10:32:55 <Cale> @src IO mzero
10:32:55 <lambdabot> mzero       = ioError (userError "mzero")
10:32:58 <Cale> ugh
10:33:56 <br1> there's also projecteuler.net, for programming problems
10:38:08 <SamB> http://dir.gmane.org/gmane.comp.lang.haskell.jhc has a lovely graph, doesn't it?
10:38:11 <lambdabot> Title: Gmane -- Mail To News And Back Again
10:38:43 <crazy_coder> hi
10:38:51 <SamB> hello
10:39:07 <SamB> what may we help you with on this horrid afternoon?
10:39:15 <crazy_coder> :)
10:39:18 <crazy_coder> Nothing
10:39:31 <crazy_coder> I always come in to ask my doubts
10:39:34 <SamB> well, you see, it's ... a thing
10:39:40 <SamB> that represents *no* thing
10:39:57 <crazy_coder> But unfortunately I don't have any now
10:40:01 <crazy_coder> heh
10:40:23 <crazy_coder> I am doing very simple Haskell stuff
10:40:39 <crazy_coder>  check this out http://projecteuler.net
10:40:40 <lambdabot> Title: Project Euler
10:40:50 <SamB> I just started on that myself
10:40:58 <crazy_coder> Its so simple in Haskell
10:41:23 <crazy_coder> No IO / Monad stuff required till now. Thank God! :p
10:41:33 <littledan> maybe the first 20 are easy to do in a sufficiently high level language, but after that it gets pretty tricky
10:41:38 <shachaf> crazy_coder: You haven't been using list comprehensions?
10:42:00 <crazy_coder> I have. The first one I posted I didn't use
10:42:00 <SamB> I've done 1-5, 8, 11-12, and 15
10:42:13 <shachaf> crazy_coder: There you go. "Monad stuff". :-)
10:42:17 <littledan> well, maybe not 'easy' but doable
10:42:22 <SamB> shachaf: those aren't yet monad stuff -- again
10:42:35 <crazy_coder> I did first 8 today
10:42:35 <shachaf> SamB: Well, OK, but they are in principle.
10:42:41 <crazy_coder> leaving the 3rd
10:42:50 <SamB> I mean... niether Haskell 98 nor Contemporary Haskell supports monad comprehensions
10:43:32 <littledan> why aren't list comprehensions not supported as "monad comprehensions"? Would that just make typing too difficult or something?
10:43:41 <SamB> see, I did those ones because I don't remember a better algorithm for primes than the basic seive
10:43:54 <crazy_coder> list comprehension is pretty simple
10:44:01 <SamB> well, and because they looked fun
10:44:02 <shachaf> littledan: Too confusing for users, from what I understand.
10:44:09 <crazy_coder> hence it cannot be categorized as a monad ;)
10:44:25 <shachaf> crazy_coder: Monads are "pretty simple" too.
10:44:30 <shachaf> crazy_coder: The basic concept, I mean.
10:44:44 <crazy_coder> Yeah they are when you are 50 yr old Haskell programmer ;)
10:44:57 <SamB> I thought the reason that monad comprehensions aren't supported was, uh, related to the difficulty of doing it with the Haskell 98 classes
10:44:58 <shachaf> crazy_coder: Some individual ones can be trickier, sometimes.
10:45:05 <littledan> shafchaf, it's easy to say that once you've already learned what they are.
10:45:09 <crazy_coder> Just kidding, look at Dons
10:45:42 <SamB> I'm 20 and I think monads so simple that they defy explanation
10:45:57 <shachaf> littledan: Nothing is simple when you haven't learned what it is.
10:45:59 <SamB> insert "are"
10:46:04 <alar> @seen dons
10:46:04 <lambdabot> dons is in #xmonad, #haskell-soc and #haskell. I last heard dons speak 8h 11m 35s ago.
10:46:20 <SamB> crazy_coder: you don't think dons understands monads? you think dons is 50? what?
10:46:22 <crazy_coder> SamB: Cool dude! Where do you study ?
10:46:33 <SamB> crazy_coder: study?
10:46:44 * vincenz is 50
10:46:51 <crazy_coder> dons said he was doing Masters in CS
10:47:08 <crazy_coder> And according to me he is quite a master in Haskell
10:47:16 <SamB> oh, you mean dons isn't 50 but he does know monads?
10:47:21 <crazy_coder> yeah
10:47:24 <SamB> now if only he could comprehend them
10:47:32 <shachaf> @quote endofunctor
10:47:32 <lambdabot> psykotic says: [monads aren't hard] they're just monoids on the category of endofunctors over some category, what's the big deal?
10:47:56 <crazy_coder> SamB: you said you were 20. So I asked where you study ? Which Univ ?
10:48:08 <shapr> crazy_coder: Hey, it only took me five years of spare time to go from zero to spiffy with Haskell.
10:48:17 <SamB> crazy_coder: ah. I thought were implying that I would be learning Haskell in school ;-)
10:48:17 <shapr> Actually, to go from zero to Haskell employed =)
10:48:29 <SamB> crazy_coder: I'm going to be going to Widener University in the fall
10:48:45 <crazy_coder> SamB : where is it ?
10:49:06 <SamB> it's in southe-east pennsylvania
10:49:31 <SamB> I believe it's in Chester
10:49:33 <crazy_coder> I am 20 too. But very pathetic at Haskell. But I want to learn. Maybe an year later, I will start understanding stuff
10:50:08 <shapr> It just takes time.
10:50:11 <SamB> if you like list comprehensions you have already started
10:50:12 <shapr> I'm 35!
10:50:19 * wli tries to think of good problems.
10:50:27 <shapr> wli: I liked your benchmark ideas.
10:50:27 <shachaf> SamB: Do you know anyone who doesn't like list comprehensions?
10:50:36 <SamB> shachaf: actually... no!
10:50:43 <shapr> What about monad comprehensions?
10:50:56 <crazy_coder> actually i do understand basic monads
10:50:59 <SamB> shapr: too little data
10:51:07 <wli> shapr: Yeah, but those are for bencmarks, not pedagogical.
10:51:14 <crazy_coder> But not in a position to do cool things with it
10:51:15 <crazy_coder> :)
10:51:17 <SamB> wli: huh?
10:51:31 <SamB> crazy_coder: have you looked at the MTL?
10:51:32 <wli> SamB: http://holomorphy.com/~wli/shootout.html
10:51:33 <lambdabot> Title: Programming Language Shootout Thoughts
10:51:39 <shapr> wli: I think there could be some relation.
10:51:49 <SamB> I'd suggest installing the library source code, actually
10:51:53 <crazy_coder> samB: what is MTL ?
10:51:54 <shachaf> crazy_coder: See? The problem isn't with understanding the concept of a monad, it's with specific ones, in Haskell.
10:52:06 <SamB> there's a *reason* why there is a debian package of the library source code
10:52:13 <shapr> wli: In fact, the benchmarks for those sorts of problems would be a neat way to compare/contrast languages.
10:52:37 <shachaf> I just use apt-get source lighc6-mtl-dev, I don't install the sources as a package.
10:52:48 <shapr> UTSL!
10:53:16 <SamB> shachaf: well the package isn't for building anyway
10:53:54 <byorgey> crazy_coder: MTL = Monad Transformer Library
10:54:19 <SamB> perhaps the package no longer exists
10:54:23 <shachaf> crazy_coder: So, other than the list monad, which have you used? Identity, Maybe?
10:54:25 <crazy_coder> Sorry. I haven't.
10:54:31 <SamB> but it was clearly for reading
10:54:37 <crazy_coder> Identity, Maybe, IO
10:54:44 <SamB> some of the files were gzipped, and I think it was under /usr/share/doc
10:54:46 <wli> shapr: Something like LPS would make a good macrobenchmark.
10:55:22 <SamB> crazy_coder: try State
10:55:25 <shachaf> crazy_coder: Reader/(e ->)?
10:55:27 <shapr> wli: Most of the macrobenchmarks you describe would be informative.
10:55:36 <crazy_coder> SamB:yeah got stuck over there
10:56:08 <wli> shapr: I'll try to think of more.
10:56:13 <crazy_coder> shachaf:
10:56:15 <crazy_coder> ??
10:56:27 <SamB> I used StateT Char IO in my translation of the C reference implementation of Unlambda
10:56:38 <shachaf> crazy_coder: Have you used the Reader/((->) e) monad, I mean?
10:56:43 <crazy_coder> No
10:56:54 <crazy_coder> never seen that before :(
10:57:02 <shachaf> @source Control.Monad.Reader
10:57:02 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/Reader.hs
10:57:08 <crazy_coder> I need a lot of hard work ;)
10:57:10 <SamB> the only impurity seemed to be in the input, output, and a single "char" variable...
10:57:24 <SamB> crazy_coder: what's hard about State?
10:57:32 <crazy_coder> SamB: are you really 20 ?
10:57:39 <SamB> last I checked
10:57:54 <SamB> yeah, it's definately not past my birthday yet ;-)
10:57:57 <crazy_coder> Don't know, I got bored actually, can't see any implementation of ut
10:58:07 <crazy_coder> *it
10:58:09 <SamB> @hoogle State
10:58:10 <lambdabot> Control.Monad.State :: module
10:58:10 <lambdabot> Control.Monad.State.State :: (s -> (a, s)) -> State s a
10:58:10 <lambdabot> Control.Monad.State.State :: newtype State s a
10:58:19 <SamB> @source State
10:58:19 <crazy_coder> Yeah wait
10:58:19 <lambdabot> State not available
10:58:25 <SamB> @source Control.Monad.State
10:58:26 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/State.hs
10:58:43 <crazy_coder> Here is my problem, I remember - the state is represented by   (s -> (a, s))
10:58:49 <crazy_coder> How is it like that ?
10:58:52 <crazy_coder> a tuple?
10:59:00 <crazy_coder> where did that come from ?
10:59:07 <SamB> oh, the state is just represented by the s
10:59:24 <shachaf> crazy_coder: A function with state is a function that gets a state, and returns some value and a new state.
10:59:25 <shapr> crazy_coder: think of one of those solar powered calculators with an M+ button
10:59:28 <crazy_coder> I read in wikipedia, it had analogy with a ticket
10:59:31 <SamB> that type there is the implementation type of a State action
11:00:09 <crazy_coder> I have to supply a funtion which does  (s -> (a, s)). Right ?
11:00:15 <SamB> it takes a state and transforms it to a new type (as well as a value)
11:00:22 <SamB> crazy_coder: you just write some monadic code
11:00:37 <SamB> using the get and put functions
11:00:40 <SamB> @type get
11:00:42 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
11:00:45 <SamB> @type put
11:00:47 <lambdabot> forall s (m :: * -> *). (MonadState s m) => s -> m ()
11:01:01 <shachaf> > runState 5 (do { x <- get; put (x + 1); return 'a' })
11:01:02 <lambdabot>   add an instance declaration for (Show (t Char))
11:01:08 <SamB> > runState get 1
11:01:10 <lambdabot>  (1,1)
11:01:17 <shachaf> > runState (do { x <- get; put (x + 1); return 'a' }) 5
11:01:18 <lambdabot>  ('a',6)
11:02:08 <crazy_coder> ok Thanks
11:02:43 <dozer> is there an idiot's guide to template haskell?
11:02:56 <dozer> I;ve not found anything yet that goes through it slowly enough for me to understand what's going on
11:03:01 <SamB> dozer: idiots are expected to just rape&paste
11:03:20 <SamB> @google template haskell
11:03:22 <lambdabot> http://www.haskell.org/th/
11:03:22 <lambdabot> Title: Template Haskell
11:03:22 <dozer> SamB_XP: but some of us aspire to passing ourselves off
11:03:39 <shachaf> When I first read that part of the Wikibook, it made no sense at all. Now that I understand it more, it would probably make sense... :-)
11:03:51 <SamB> dozer: you may wish to peruse http://www.haskell.org/th/papers.html
11:03:52 <lambdabot> Title: Template Haskell papers
11:04:13 <crazy_coder> SamB: you read technical papers ?
11:04:37 <dozer> hum, I've read all of that, and not found anything that actually explains how to do things without expecting me to know everything first :/
11:04:43 <SamB> crazy_coder: some of them have a highly tutorial flavour
11:05:03 <SamB> dozer: you read all the papers?
11:05:14 <crazy_coder> SamB: I meant it is great you do. :)
11:05:28 <dozer> SamB_XP: ah - no, not the papers - was assuming they where technical in nature
11:05:40 <SamB> dozer: isn't that something you want?
11:06:01 <dozer> SamB_XP: no - i want to know how to do it, not the theory
11:06:26 <wli> shapr: I just added macrobenchmark #9
11:06:37 <SamB> dozer: I Think you should at least look at them
11:06:44 <crazy_coder> I agree with dozer. Sometimes one can;t learn without the knowledge of its use
11:06:44 <SamB> I don't think there's much theory to it anyway
11:06:48 <dozer> SamB reading the 2nd one now
11:07:22 <SamB> the papers might be somewhat innacurate in the details, but they should get you on the right track
11:08:48 <shapr> wli: That's pretty macro
11:08:54 <shapr> wli: Sounds like a mini-icfp problem too.
11:09:04 <shapr> wli: Maybe we should run mini-icfp contests on IRC
11:09:11 * SamB really can't see them bothering to do a semantics for much of TH, since it's mostly some datatypes and a few monadic functions that you can use, with some snazzy syntax
11:09:44 <wli> shapr: Yeah, it's pretty high-end.
11:10:20 <wli> shapr: There's an element of realtime response to it.
11:10:56 <shapr> Sounds like a nifty RTS game challenge.
11:11:22 <wli> shapr: Or something the DoD would post as a challenge.
11:11:27 <Nafai> shapr: mini-icfp contents would be fun
11:11:37 <Nafai> shapr: It would be a great way to learn and get feedback
11:12:25 <SamB> Dungeons of Doom?
11:12:27 <wli> shapr: Efficiency of computation comes into it by means of realtime constraints on decision-making.
11:13:18 * edwardk waves hello.
11:14:07 <wli> SamB: Controlling a system of unmanned vehicles in pursuit of a target with the goal of presenting targeting opportunities to remote operators.
11:15:19 <wli> Maybe if it were slightly generalized you could have the implementations fight each other.
11:18:44 <shapr> wli: That's an interesting point.
11:19:09 <shapr> wli: Yeah, fighting each other would be great fun, that's a whole ICFP right there :-)
11:19:11 <wli> shapr: The simulation environment sounds tough. I just made it another problem and threw in graphical rendering atop it. ;)
11:20:37 <xelxebar> > 1/1000000000000000000000
11:20:39 <lambdabot>  1.0e-21
11:21:00 <xelxebar> >sqrt 2
11:21:07 <shachaf> xelxebar: You need a space.
11:21:10 <shachaf> > sqrt 2
11:21:11 <lambdabot>  1.4142135623730951
11:21:21 <sfultong> I think a haskell version of c-robots would be great... I dunno how it would work, though
11:21:26 <crazy_coder> > [(a,b) | a<-[1..], b<-[1..] ,(a+b==100) ]
11:21:27 <xelxebar> ah, thanks
11:21:30 <lambdabot> Terminated
11:21:38 <wli> sfultong: c-robots?
11:21:52 <shapr> Hey, is there some easy way to do interactive evaluation of javascript in a browser?
11:21:53 <crazy_coder> can anyone help me with this
11:22:09 <crazy_coder> The above piece of code
11:22:10 <shapr> Sort of like doing C-x C-e at the end of parens in emacs? (/ 24 2.2)
11:22:12 <jethr0> dozer: or try my (now dead) TH tutorial: http://web.archive.org/web/20060615162944/http://www.haskell.org/hawiki/TemplateHaskellTutorial
11:22:17 <lambdabot> Title: TemplateHaskellTutorial - The Haskell Wiki, http://tinyurl.com/3dt7rb
11:22:25 <sfultong> wli: you program a robot in c that runs around a virtual environment and tries to kill other programmed robots
11:22:29 <shachaf> crazy_coder: That tries to go through the entire [1..] before ever getting to 2.
11:22:32 <jmelesky> shapr: javascript has an 'eval', so you could eval the contents of a text box, i imagine
11:22:45 <shapr> jmelesky: Yeah, just wondering if firefox 2.x has something that makes that easy.
11:22:57 <crazy_coder> shachaf: Oh I see
11:22:57 <sfultong> http://en.wikipedia.org/wiki/Crobots
11:23:16 <jmelesky> shapr: perhaps the javascript: pseudo-URIs are still implemented
11:23:22 <shapr> Ah, possibly so...
11:23:23 <jethr0> crazy_coder: but if the sum should be 100 then you don't really need to run to infinity, do you?
11:23:31 <xelxebar> > [(a,b) | a<-[1..], b<-[1..] ,(a+b==100) ]
11:23:33 <wli> sfultong: I'm apparently suggesting a vastly more realistic problem.
11:23:35 <lambdabot> Terminated
11:23:37 <shachaf> crazy_coder: What are you trying to do?
11:23:42 <shapr> Now I just have to remember how to write something simple in javascript...
11:23:44 <jethr0> > [(a,b) | a <- [1..100], b <- [1..100], a+b == 100]
11:23:45 <lambdabot>  [(1,99),(2,98),(3,97),(4,96),(5,95),(6,94),(7,93),(8,92),(9,91),(10,90),(11,...
11:23:56 <wli> xelxebar: Try [(a,b) | a <-[1..100], b <- [1..100], a + b == 100]
11:23:58 <jmelesky> shapr: just tried Camino on OSX, and it has javascript:, so i imagine firefox does, too
11:24:02 <crazy_coder> jethr0: I want all combination of tuples which satisfy the condition a+b==100
11:24:30 <wli> crazy_coder: You need a >= 0, b >= 0 too, of course, or there will be infinitely many.
11:24:30 <sfultong> wli: sounds good, although the virtual environment in such a game could be made fairly realistic...
11:24:33 <jethr0> i know ;)
11:24:34 <crazy_coder> jethr0: what if i don't know about 100
11:24:40 <shachaf> > [(x,y) | x <- [1..99], y <- [1..99], x + y == 100]
11:24:41 <lambdabot>  [(1,99),(2,98),(3,97),(4,96),(5,95),(6,94),(7,93),(8,92),(9,91),(10,90),(11,...
11:24:57 <shapr> jmelesky: Yup, it works here, thanks!
11:25:05 <shachaf> > [(x,y) | x <- [1..], let y = 100 - x] -- ?
11:25:06 <lambdabot>  [(1,99),(2,98),(3,97),(4,96),(5,95),(6,94),(7,93),(8,92),(9,91),(10,90),(11,...
11:25:14 <doserj> > [(a,100-a) | a <- [1..]]
11:25:15 <lambdabot>  [(1,99),(2,98),(3,97),(4,96),(5,95),(6,94),(7,93),(8,92),(9,91),(10,90),(11,...
11:25:19 <wli> sfultong: Well, there'd be no human players.
11:25:34 <shapr> I suspect most human players would get creamed anyway.
11:25:51 <crazy_coder> Yeah Thanks
11:25:58 <crazy_coder> gave me some good ideas
11:26:02 <crazy_coder> :)
11:26:07 <jmelesky> shapr: glad to help
11:26:43 <wli> More like (0, 100) : concat [[(a, 100 - a), (-a, 100 + a)] | a <- [1..], but anyway.
11:28:58 <wli> shapr: There isn't really even an effective way for human players to participate given that each program controls a system of assault vehicles, presumably cooperating and communicating faster and more effectively than human controllers could ever do.
11:29:18 <crazy_coder> The fact that haskell evaluates lazily makes me always work with infinite lists  :)
11:29:32 <shapr> wli: Yeah, but combining the two systems would really get the DoD excited.
11:29:54 <shapr> wli: That is, make the system more an enabler and leverage the human 'intuition'
11:29:55 <jethr0> crazy_coder: that's absolutely ok. just in this special case it needs some more care
11:30:14 <wli> shapr: Which two systems? Human control and unmanned piloting?
11:30:38 <shapr> Yeah
11:31:00 <wli> shapr: I suppose that consists of the presentation of targeting opportunities.
11:31:15 <crazy_coder> I almost forgot my question, does list comprehension automatically do the combination required ?
11:31:35 <EvilTerran> > [(i,n-i) | n <- [0..], i <- [0..n]] -- every pair of natural numbers
11:31:37 <lambdabot>  [(0,0),(0,1),(1,0),(0,2),(1,1),(2,0),(0,3),(1,2),(2,1),(3,0),(0,4),(1,3),(2,...
11:32:13 <EvilTerran> crazy_coder, what do you mean?
11:33:11 <crazy_coder> like has it the inbuilt property to combine both lists in all possible ways to satisfy the given constraints
11:33:16 <shapr> wli: It sounds like a really fun RTS game.. write your own strategy automation, then compete against others.
11:34:13 <crazy_coder> Ok nm I get it
11:34:17 <wli> shapr: I was thinking of Core Wars, but apparently C-robots is closer.
11:35:30 <JohnMeacham> hmm.. anyone here have enough darcs-fu to help fix up a corrupt repo?
11:35:50 <Excedrin> wli: are you guys talking about ORTS?
11:35:56 <Philippa> this is why you need to keep your repos in a version control system ;-)
11:36:07 <wli> Excedrin: I've never heard of ORTS.
11:36:35 <Excedrin> oh, it sounds like what you're talking about
11:37:07 <Excedrin> I've coded some RTS AI (not in ORTS though) and there's definitely room for a human+AI sort of cyborg
11:37:50 <wli> Excedrin: ORTS might be a good engine for the AI players.
11:39:52 <wli> Excedrin: I sort of based it on quasi-scifi descriptions of future use of unmanned assault vehicles, except I threw the twist of assault vehicle heterogeneity into it.
11:40:21 <Cale> crazy_coder: It just tries all possibilities. You could think of it as a bunch of nested loops if you want.
11:40:39 <shapr> ORTS looks nifty.
11:40:47 <Cale> It would be rather cool to have list comprehensions which were smarter about the order in which options were tried.
11:40:56 <shachaf> Cale: It is a bunch of nested loops, isn't it?
11:41:08 <Cale> shachaf: depending on how you look at it, yes
11:41:14 <wli> Excedrin: The quasi-scifi descriptions largely involved squadrons of identical unmanned vehicles.
11:41:24 <Cale> shachaf: Or a bunch of concatMaps
11:41:40 <EvilTerran> Cale, you mean like using the zigzag thing i mentioned above?
11:41:43 <shachaf> Cale: Well, isn't a concatMap a loop?
11:41:47 <Cale> EvilTerran: yeah
11:41:52 <vincenz> Cale: gimme your skype account :)
11:42:00 <crazy_coder> @src concatMap
11:42:00 <lambdabot> concatMap f = foldr ((++) . f) []
11:42:09 <Cale> shachaf: maybe once it's compiled
11:42:40 <dblhelix> less than sixteen hours remaining...
11:42:40 <shachaf> Perhaps a loop specifically means using a variable.
11:42:43 <wli> Excedrin: And mostly aerial at that (unmanned nautical and ground vehicle control appears to suffer from obstacle avoidance and terrain/etc. coping issues).
11:42:57 * shachaf thinks of a loop as something that repeats something.
11:43:41 <jethr0> shachaf: you mean like recursion ;)
11:43:45 <shapr> wli: That might be fun to leave out of the base game, that is, write your own terrain avoidance.
11:43:59 <Excedrin> wli: I saw an interesting unmanned 6 wheel atv on discovery, they showed it driving around and it seemed to do alright
11:44:29 <wli> shapr: Terrain navigation and obstacle avoidance were supposed to be a big part of the problem.
11:44:51 <shapr> Sounds very cool
11:45:05 <Cale> shachaf: That definition of concatMap there isn't even explicitly recursive.
11:45:17 <wli> Excedrin: Things have improved on that front recently, though AIUI they're still not great with moving obstacles -- esp. dodging ones trying to ram them.
11:45:31 <shachaf> Cale: I know, but it does use a fold, which is.
11:45:51 <shachaf> I guess loop means something more specific than I though.
11:46:00 <dblhelix> shapr, wli: reminds me about the problem described in hudak and jones' "Haskell is better than C++, Ada, etc." or something
11:46:32 <shapr> dblhelix: Yeah, I agree.
11:48:03 <wli> dblhelix: I've not seen/heard of that.
11:48:30 <dblhelix> wli: it's very worthwhile... does not take long to read it
11:48:52 <wli> dblhelix: Is it an online paper, dead tree book, or what?
11:48:59 <shachaf> @source Control.Monad.State
11:48:59 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/State.hs
11:49:11 <dblhelix> wli: see
11:49:20 <dblhelix> @google haskell too good for it's own good
11:49:22 <lambdabot> http://xoltar.nfshost.com/old_site/
11:49:22 <lambdabot> Title: Xoltar.org - Bryn Keller
11:49:31 <dblhelix> mmm... not that one
11:49:41 <dblhelix> wli: http://people.cs.uu.nl/stefan/blog/00009.html
11:49:42 <lambdabot> Title: Personal Web Pages of Stefan Holdermans: &#8216;Too Cute for Its Own Good&#8217;
11:49:51 <Excedrin> http://haskell.org/papers/NSWC/jfp.ps
11:49:54 <Excedrin> it's this one afaik
11:50:06 <shachaf> @google haskell too good for its own good
11:50:07 <lambdabot> http://people.cs.uu.nl/stefan/blog/00009.html
11:50:07 <lambdabot> Title: Personal Web Pages of Stefan Holdermans: &#8216;Too Cute for Its Own Good&#8217;
11:50:12 <wli> dblhelix: I've already read it.
11:51:24 <dblhelix> wli: now I've collected two statements from you that together allow me to deduce falsum
11:51:40 <wli> dblhelix: ?
11:51:45 <dblhelix> at least, if I admit the law of the excluded middle -)
11:52:24 <dblhelix> wli: first you said "I've not seen/heard of that" and then "I've already read it"
11:52:28 <wli> dblhelix: Your description of the paper was insufficient to remind me of it.
11:52:42 <wli> dblhelix: I noticed different aspects of it.
11:52:44 <shapr> ORTS looks like a lot of fun for mini-icfp contests.
11:53:02 <dblhelix> wli: okay then :-)
11:53:13 <dblhelix> you see, I'm easily confused
11:53:51 <dblhelix> as someone who works with constructive logics (well, more or less), I shouldn't depend on the law of the excluded middle anyway ;-)
11:53:51 <wli> dblhelix: The nautical vehicle tracking system there didn't involve unmanned vehicle control, sensor input, or (IIRC) targeting.
11:54:08 <dblhelix> wli: true
11:54:27 <dblhelix> it reminded me of it, I didn't think it was a perfect match ;-)
11:54:33 <wli> dblhelix: I think it didn't include pursuit, either.
11:55:47 <dblhelix> wli: you win
11:55:54 <Excedrin> there's a fun game called Mind Rover that deals with navigation and sensor input and targeting and stuff
11:56:15 <Excedrin> but it's based on connecting "wires" and stuff; it's non-programming
11:56:16 <wli> It was a really crude problem, something more worthy of projecteuler or those acm things. It even excluded geodesy and radar/satellite line-of-sight affairs.
11:57:06 <Philippa> Excedrin: bear in mind you're in a chan for a language whose basic execution model is graph reduction - let and case and bindings are all just connecting "wires"...
11:57:34 <Excedrin> yes, well, it's based on graphically dragging wires from sensors to motors and things like that
11:57:42 <wli> I'm frankly surprised the paper authors didn't say something about it being difficult to take seriously.
11:58:01 <Excedrin> it would be a good intro to functional programming if they exposed the underlying stuff a little more
11:58:34 <wli> Excedrin: Well, do you know how to do the reduction bits on expression trees?
11:58:49 <wli> Excedrin: Now memoize.
11:58:58 <Excedrin> it has a lot of good ideas for robot competitions though, one is a pair of hovercrafts in a circle attempting to push each other out (hover-sumo)
11:59:25 <Excedrin> it has races on a few different tracks and robot vs robot fights as well
12:00:59 <wli> Excedrin: I proposed teams of unmanned assault vehicles controlled by communicating instances of the submitted program.
12:01:16 <shapr> Sounds like fun
12:02:08 <shapr> Excedrin: I loved mind rover, I have that for linux.
12:02:18 <wli> Excedrin: I believe that is different in character from most of these things (e.g. competitors control single robots, etc.).
12:03:11 <Excedrin> wli: ya, I'm only mentioning a few existing things that I haven't seen mentioned (I saw corewars and c-robots)
12:03:12 <wli> Excedrin: The heterogeneous mixture of assault vehicles furthermore makes it different from anything I've seen the DoD propose.
12:04:28 <wli> Excedrin: It's "ambitious" relative to reality.
12:04:53 <Philippa> the DoD don't want the coders determining battlefield roles
12:05:25 <wli> Philippa: The goal was defined as presenting targeting opportunities to remote operators.
12:07:06 <wli> There are obviously some concerns there, like sufficiently lengthy windows of opportunity for humans to respond.
12:11:55 * dblhelix regrets it that the Applicative class does not contain functions such as many etc. as default methods
12:12:08 <dblhelix> @src Control.Applicative.Applicative
12:12:08 <lambdabot> Source not found. I've seen penguins that can type better than that.
12:12:16 <dblhelix> @src Applicative
12:12:16 <lambdabot> class Functor f => Applicative f where
12:12:17 <lambdabot>     pure  :: a -> f a
12:12:17 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
12:13:11 <dblhelix> less than 15 hours... :-)
12:15:11 <vaste_> hm, how does the lazy parser of HaXml work?
12:15:39 <vaste_> do I just call xmlParse from ParseLazy instead of Parse
12:15:42 <vaste_> ?
12:24:18 <jedai> @src minimum
12:24:19 <lambdabot> minimum [] = undefined
12:24:19 <lambdabot> minimum xs = foldl1 min xs
12:24:27 <EvilTerran> hm... it's generally considered better to use foldl' over foldl -- what about scanl?
12:24:50 <sjanssen> @hoogle scanl'
12:24:51 <lambdabot> No matches found
12:25:04 <EvilTerran> sjanssen, that's what i thought, but as the bot says, there's no such thing
12:25:32 <sjanssen> EvilTerran: the strictness is probably less important for scanl
12:25:59 <EvilTerran> ...can you say why?
12:26:00 <jedai> EvilTerran: Where you would use foldl in others strict language, in Haskell you're better off with foldr or foldl'
12:26:24 <sjanssen> because the user can always force parts of the accumulator by forcing elements in the returned list
12:26:32 <EvilTerran> jedai, i know that. i said that a minute ago, in fact. i'm not asking about foldl, i'm asking about scanl.
12:26:54 <EvilTerran> sjanssen, i think i see...
12:27:22 <jedai> EvilTerran: scanl generate a list, so you can take parts of it and benefits from the laziness where foldl is often calculating a single value that you use or not.
12:27:25 <EvilTerran> actually, i guess that scanl is supposed to consume O(n) memory affects the importance of the matter, as well
12:27:36 <sjanssen> \f z ys -> foldr (\x xs -> x `seq` (x:xs)) [] (scanl f z ys) -- should be the same as scanl'
12:27:51 <sjanssen> oh, that too
12:28:10 <jedai> EvilTerran: So using foldl' make sense since it's a all or nothing business and foldl' will be faster than foldl
12:29:27 <EvilTerran> right.
12:30:18 <edwardk> dblhelix: which ones would you like to see applicative contain?
12:33:43 <dblhelix> edwardk: many and many1, for starters
12:33:56 <dblhelix> @src many
12:33:57 <lambdabot> Source not found. Are you on drugs?
12:34:02 <edwardk> @type many
12:34:11 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f [a]
12:34:27 <dblhelix> lambdabot used to be such a polite gal
12:34:45 <SamB> @hoogle on
12:34:46 <lambdabot> Test.QuickCheck.oneof :: [Gen a] -> Gen a
12:34:46 <lambdabot> System.Console.Readline.onNewLine :: IO ()
12:34:46 <lambdabot> Text.ParserCombinators.Parsec.Char.oneOf :: [Char] -> CharParser st Char
12:34:57 <edwardk> @src Control.Applicative.many
12:34:57 <lambdabot> Source not found. Take a stress pill and think things over.
12:35:50 <oerjan> many and many1 are in Parsec
12:36:26 <dblhelix> oerjan: obviously not the ones that operate on applicative functors in general ;-)
12:36:52 <oerjan> indeed, they look more like something for MonadPlus
12:37:03 <SamB> eh?
12:37:12 <shachaf> @src many
12:37:12 <lambdabot> Source not found. Wrong!  You cheating scum!
12:37:21 <oerjan> i think Parsec's many and many1 could be generalized to MonadPlus
12:37:34 <SamB> I have many in my Parsely typeclass...
12:37:53 <SamB> I guess it can be defined with nothing but MonadPlus though
12:37:53 <dblhelix> many p = (:) <$> p <*> many p <|> pure []
12:38:13 <edwardk> how does that differ from some?
12:38:20 <dblhelix> many1 p = (:) <$> p <*> many p
12:38:22 <oerjan> :t \p -> (:) <$> p <*> many p <|> pure []
12:38:24 <lambdabot>     Ambiguous occurrence `pure'
12:38:24 <lambdabot>     It could refer to either `pure', imported from Control.Applicative
12:38:26 <edwardk> ah i see
12:38:30 <oerjan> er
12:38:31 <SamB> ack!
12:38:32 <edwardk> the definitions are written funny
12:38:36 <oerjan> :t \many p -> (:) <$> p <*> many p <|> pure []
12:38:38 <lambdabot>     Ambiguous occurrence `pure'
12:38:38 <lambdabot>     It could refer to either `pure', imported from Control.Applicative
12:38:45 <int-e> @type Control.Applicative.many
12:38:47 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f [a]
12:38:50 <dblhelix> with f <$> p = pure f <*> p
12:39:05 <edwardk> :t \many p -> (:) <$> p <*> many p <|> Control.Applicative.pure []
12:39:07 <lambdabot> forall a (f :: * -> *). (Alternative f) => (f a -> f [a]) -> f a -> f [a]
12:39:19 <dblhelix> and there you are
12:39:37 <shachaf> Why isn't pure called return?
12:39:47 <edwardk> > let many p -> (:) <$> p <*> many p <|> pure [] in many 1
12:39:48 <lambdabot>  Parse error
12:39:51 <edwardk> er
12:39:54 <shachaf> Is it just because Applicative is new?
12:40:01 <oerjan> because return is taken by Monad
12:40:16 <dblhelix> @type fix (\many p -> (:) <$> p <*> many p <|> pure [])
12:40:18 <lambdabot>     Ambiguous occurrence `pure'
12:40:18 <lambdabot>     It could refer to either `pure', imported from Control.Applicative
12:40:21 <edwardk> > let many p = (:) <$> p <*> many p <|> pure [] in many 1
12:40:22 <lambdabot> Terminated
12:40:24 <int-e> unlike return, pure is more often used with functions
12:40:42 <dblhelix> @type fix (\many p -> (:) <$> p <*> many p <|> Control.Applicative.pure [])
12:40:44 <lambdabot> forall a (f :: * -> *). (Alternative f) => f a -> f [a]
12:40:45 <edwardk> schachaf: its because applicative isn't a superclass of monad
12:42:11 <edwardk> i just realized i don't really understand optional some or none in Control.Applicative
12:42:47 <shachaf> @ty Control.Applicative.some
12:42:49 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f [a]
12:43:39 <edwardk> er optional some or many
12:44:55 <xelxebar> wow, reading the Prelude can be very educational
12:45:02 <edwardk> how are they used?
12:45:14 <shachaf> xelxebar: Which part, in this case?
12:45:20 <shachaf> edwardk: For parsing? :-)
12:45:21 <xelxebar> though it makes me feel like my code is horrible in comparison
12:45:22 <int-e> edwardk: they make sense if you build a parser (say, String -> (String, a)) and make it an instance of Applicative.
12:45:41 <edwardk> int-e: yeah, i'm just trying to think of them in other contexts
12:45:47 <int-e> edwardk: I'm not sure if they're ever useful in other contexts
12:46:12 <dblhelix> edwardk: in parsing, for instance: (:) <$> symbol 'a' <*> many1 (symbol 'b')
12:46:15 <xelxebar> no part in particular - I was just reading readFloat in Numeric - oops, not in Prelude
12:46:49 <int-e> edwardk: with some slight permutation, many 1 could produce [[],[1],[1,1],[1,1,1],...] for lists. (but right now it's defined for parsers, hence greedy, and tries to produce the infinite list [1,1,...] first)
12:47:02 <int-e> edwardk: err many [1] of course
12:47:04 <xelxebar> but reading that lead me to the Prelude, naturally.  does it make you feel like your code is not near as beautiful?
12:47:18 <shapr> Yeah, the Prelude is elegant.
12:47:36 <int-e> edwardk: basically you'd have to swap the arguments to <|> to get that effect
12:48:08 <jethr0> shapr: well, apart from the well-known improvabilities (like using Int instead of Integral, ...)
12:49:42 <dblhelix> mmm... it seem that the checkers problem is solved: http://www.cs.ualberta.ca/~chinook/
12:49:44 <lambdabot> Title: Chinook - World Man-Machine Checkers Champion
12:49:56 <roconnor> Example of an applicative functor that isn't a monad?
12:50:44 <oerjan> @src Applicative
12:50:45 <lambdabot> class Functor f => Applicative f where
12:50:45 <lambdabot>     pure  :: a -> f a
12:50:45 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
12:51:03 <dblhelix> roconnor: the parser combinators of swierstra and duponcheel
12:51:09 <shachaf> roconnor: ZipList is one I recently came across.
12:51:12 <shachaf> @src ZipList
12:51:13 <lambdabot> Source not found. The more you drive -- the dumber you get.
12:51:25 <shachaf> @source Control.Applicative -- Here.
12:51:26 <lambdabot> Control.Applicative -- Here. not available
12:51:29 <shachaf> @source Control.Applicative
12:51:30 <lambdabot> Control.Applicative not available
12:51:38 <shachaf> @where applicative
12:51:38 <lambdabot> I know nothing about applicative.
12:51:53 <shachaf> @where+ applicative http://darcs.haskell.org/packages/base/Control/Applicative.hs
12:51:54 <lambdabot> Done.
12:51:59 <dblhelix> @src Applicative
12:51:59 <lambdabot> class Functor f => Applicative f where
12:52:00 <lambdabot>     pure  :: a -> f a
12:52:00 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
12:52:00 <vincenz> o.O
12:52:02 <vincenz> shachaf: why?
12:52:09 <vincenz> @source Control.Applicative
12:52:09 <lambdabot> Control.Applicative not available
12:52:15 <vincenz> o.O
12:52:20 <shachaf> vincenz: Someone else did that before, I think, and lambdabot forgot it.
12:52:23 <vincenz> oh
12:52:31 <shachaf> vincenz: (Maybe it was oasisbot at the time?)
12:52:36 <vincenz> perhaps
12:53:30 <edwardk> hrmm
12:53:48 <int-e> edwardk: but even with that change it's useless for lists: many [1,2] produces the same result as many [1] then.
12:54:21 <edwardk> i'm just trying to understand what it means in the 'general' non-parser sense
12:55:40 <roconnor> It's a containor such that a containor can be applied to a containor of objects?
12:55:41 <dblhelix> edwardk: I'm sure there some relation between applicative functors with choice and free monoids ;-) and I'm sure you'll tell me all about it tomorrow
12:55:45 <oerjan> many makes sense for a consumer, not a producer
12:56:14 <xelxebar> has anyone here used the "Write Yourself a Scheme in 48 Hours" Haskell tutorial?  Is it a good introduction?  Any criticisms?
12:56:18 <edwardk> heh
12:57:02 <edwardk> oerjan: yeah i think its that choice of perspective that i'm having the problem with
12:57:11 <oerjan> many $ do c <- getChar; guard (c/='\n'); return c
12:57:46 <yakov> hello
12:58:16 <xerox> xelxebar, yup, and this is a good implementation http://mumble.net/~campbell/tmp/Scheme.hs
12:58:28 <shachaf> yakov: Hello.
12:59:29 <moltarx> xelxebar: yes, the tutorial cleared up a lot about parsec for me
12:59:33 <edwardk> oerjan: yeah i've used the combinator in parsec, etc. i just never really thought through its mechanics in an applicative sense
12:59:38 <xelxebar> xerox, but from looking at the Prelude / Numeric code, I feel like mine is much less pure-functional-y
13:00:13 <oerjan> edwardk: that was an attempt at an IO example, btw
13:00:47 <xelxebar> I agree about the parsec, moltarx, but as a general introduction into Haskell/functional programming?  Maybe it's just the fault of my bad code
13:00:58 <edwardk> oerjan: ah good point
13:01:11 <oerjan> (don't know if it works)
13:01:24 <moltarx> i didn't come to it as a first introduction to haskell, so i'm not sure about it being a good general intro
13:03:16 <xelxebar> well, moltarx, since you came to it with more experience, do you think that it helped you improve your haskell a bit?
13:03:26 <shachaf> xelxebar: Well, it assumes you know Scheme already.
13:03:27 <moltarx> oh certainly :)
13:03:29 <xelxebar> granted, it's a fun project regardless
13:03:50 <moltarx> yes, it was a very useful tutorial.  i recommend it to people quite frequently
13:04:11 <xelxebar> hmmm, the intro claims that it isn't necessary, and I haven't found it too much hindering (granted, more reading is required)
13:04:59 <xelxebar> good!  it's nice to hear that I haven't spent hours to waste
13:05:27 <xelxebar> thanks
13:07:37 <edwardk> right now i'm just trying to use the monad laws to transform liftA* to liftM* so they make sense to me
13:08:40 <oerjan> @src liftA3
13:08:40 <lambdabot> Source not found. Take a stress pill and think things over.
13:09:11 <edwardk> liftA3 f a b c = f <$> a <*> b <*> c
13:09:16 <oerjan> finally lambdabot gives the correct advice :)
13:09:25 <desp> hrm
13:09:27 <edwardk> which is f `fmap` a `ap` b `ap` c
13:09:44 <desp> can someone tell me what to tell my Windows-using friend who asks how to install a Cabal package?
13:09:51 <edwardk> which is
13:10:03 <edwardk> return f `ap` a `ap` b `ap` c  i guess
13:10:16 <edwardk> which is equivalent to liftMn through the return f `ap`... interpretation
13:10:16 <edwardk> ok
13:10:17 <edwardk> =)
13:10:19 <vincenz> edwardk: well, depending on associativity :)
13:10:23 <edwardk> yeah
13:10:53 <moltarx> desp: i usually install cabal packages on windows using msys
13:11:14 <desp> moltarx: can you point me to some guide I could give my friend?
13:11:32 <moltarx> well, the installation of msys isn't too bad
13:11:52 <Excedrin> is there a "Haskell way" to do distributed computing?
13:11:58 <moltarx> honestly, i'm not sure if it was necessary.  i'm just more comfortable in a *nix environment :)
13:12:00 <dblhelix> < 14 hours remaining
13:12:05 <desp> well, so do I
13:12:19 <glguy> dblhelix: shouldn't you be sleeping?
13:12:31 <glguy> dblhelix: to extend the amount of time you can stay awake?
13:12:34 <moltarx> although, i'm fairly sure you should be able to just do runghc Setup configure etc, in a windows cmd shell
13:12:41 <moltarx> let me give that a try
13:13:19 <edwardk> excedrin: its kind of in the works. As I understand it, DPH is currently designed around one machine, but i seem to recall peyton jones saying that chakravarty and those had started developing in that direction using MPI.
13:13:36 <dblhelix> glguy: sleeping? the whole st team in utrecht haven't sleep for months! we had a contest to prepare!
13:14:32 <glguy> I expect to work on the contest problems, I just won't be competing
13:14:51 <edwardk> I don't know yet if I'll be working on the contest or work stuff this weekend
13:15:19 <moltarx> desp: i had some trouble building hs-plugins because it couldn't find sh
13:15:28 <moltarx> you'll probably end up needing msys or cygwin.
13:15:33 <edwardk> so, optional is fmap Just v `mplus` Nothing ?
13:15:44 <desp> moltarx: mm. thanks
13:15:56 <Excedrin> edwardk: I mean for things that aren't really parallel; example, I was considering writing a host monitoring tool that pulls down a config and checks stuff periodically and ships the results off to some central box
13:16:00 <visof>  hello
13:16:36 <edwardk> excedrin: ah so not beowulf cluster stuff =)
13:16:53 <visof> i see  word but i couldn t understand  it meaning   it s "foo"  what is the meaning of it?
13:17:16 <edwardk> foo?
13:17:24 <visof> ya
13:17:27 <edwardk> foo is just a nonsense word used as a place holder
13:18:06 * shachaf never uses "foo".
13:18:21 <jethr0> shachaf always uses "bar"
13:18:30 * shachaf never uses "bar" either.
13:18:33 <vincenz> quux
13:18:42 <jethr0> good old quux
13:18:54 <vincenz> edwardk: it's a meta-syntactical identifier :)
13:18:54 <jethr0> quine
13:19:09 <visof> shachaf       what are you use?
13:19:34 <shachaf> visof: Normally "xyzzy" or "plugh", when I need something like that.
13:19:47 <vincenz> what's up with "xyzzy"?
13:20:01 <shachaf> vincenz: What do you mean?
13:20:13 <vincenz> where does it come from
13:20:21 <jethr0> it's the (26^2-1)th variable after "xyz"
13:20:29 <shachaf> @google colossal cave adventure
13:20:29 <lambdabot> http://www.rickadams.org/adventure/
13:20:30 <lambdabot> Title: The Colossal Cave Adventure page
13:20:35 <shachaf> @google zork
13:20:38 <lambdabot> http://en.wikipedia.org/wiki/Zork
13:20:38 <lambdabot> Title: Zork - Wikipedia, the free encyclopedia
13:20:47 <mauke> @google xyzzy
13:20:49 <lambdabot> http://xyzzy.com/
13:20:49 <lambdabot> Title: XYZZY
13:22:10 <visof> how many functional programming languages are?
13:22:29 <vincenz> visof: are you a bot?
13:22:37 <shachaf> visof: What do you mean by "functional"?
13:22:42 <jethr0> vincenz: is that a turing test question?
13:22:48 <vincenz> jethr0: are you a bot?
13:23:12 <jethr0> do you often wonder whether i'm a bot?
13:23:37 <shachaf> @vixen Are you a bot?
13:23:37 <lambdabot> no, why? do i seem "botty"?
13:23:46 <visof> shachaf   didn t you understand my question?
13:24:13 <shachaf> visof: What makes you think I didn t you understand your question?
13:24:17 <jethr0> @vixen are you a bot?
13:24:17 <lambdabot> no, why? do i seem "botty"?
13:24:20 <jethr0> bah
13:24:31 <shachaf> visof: "Functional" can have various meanings.
13:25:01 <visof> shachaf how?
13:25:13 <vincenz> shachaf: indeed, that is why they often say "java is nwo functional"
13:25:16 * vincenz snickers
13:25:51 <shachaf> vincenz: Well, what do you mean when you say "functional"?
13:25:58 <shachaf> s/vincenz/visof/
13:26:15 <jethr0> if gosling and steel had gotten their way, java might have even become kinda functional ;(
13:27:56 <visof> is functional programming technique foe coding programs ?
13:27:57 <oerjan> http://en.wikipedia.org/wiki/List_of_functional_programming_topics#Languages
13:27:59 <lambdabot> http://tinyurl.com/2dec4d
13:28:37 --- mode: ChanServ set +o glguy
13:29:56 <jethr0> visof: what exactly would you like to know? you question tend to be hard to answer
13:30:06 <glguy> bot troll or oblivious?
13:30:15 <vincenz> 2/3
13:31:42 <jethr0> who would write such a weird bot. i mean response from the channel is good, but it's kinda well-tuned to functional language channels, no?
13:31:57 <kpreid> visof: it's not a technique for programming; it's a structure of programs
13:32:53 <visof>  kpreid what about oop?
13:33:08 <kpreid> The same is true of OOP.
13:34:09 <jethr0> functional programming puts functions on center stage, similar to the way OOP puts an emphasis on objects
13:34:53 <vincenz> glguy: 2
13:35:28 <visof> is oop be invented  before  functional programming or what?
13:35:35 --- mode: glguy set +b *!*n=visof@196.218.142.*
13:35:35 --- kick: visof was kicked by glguy (Maybe we can are having been talking later)
13:35:40 <vincenz> visof: please go to wikipedia
13:36:02 <vincenz> reminds me of McBride's article on -cafe@
13:36:11 <mattam> Anyone familiar with submitting a final paper to sigplan ?
13:36:29 <jethr0> no, functional programming is way older (lisp, 1960s) and OOP was made popular around the 80s with smalltalk
13:36:49 <glguy> jethr0: I fixed the glitch
13:36:55 * jethr0 wonders from when meta-object-protocol is
13:37:38 <jethr0> hehe
13:38:19 <jethr0> nothing like a little traffic in the channel ^_^
13:38:35 <vincenz> glguy: I thought he was already fixed and you caused an exception to stop his infinite loop
13:40:16 <McBee> @src dropWhile
13:40:16 <lambdabot> Source not found. Where did you learn to type?
13:40:29 <fasta> Hmm, it seems the error messages got slightly improved. It shows parenthesized expressions now. Or was it that way before too?
13:40:40 --- mode: glguy set -b *!*n=visof@196.218.142.*
13:41:02 --- mode: glguy set -o glguy
13:41:47 <McBee> @type dropWhile
13:41:49 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
13:41:55 <McBee> @src dropWhile
13:41:55 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
13:41:58 <oerjan> dropWhile p []       = []
13:41:58 <oerjan> dropWhile p xs@(x:xs') | p x       = dropWhile p xs' | otherwise = xs
13:42:31 <McBee> oerjan•._.·´¯·-> thx
13:42:46 <oerjan> (irssi removed the line breaks before the tabs???)
13:42:46 * glguy sighs
13:42:57 <glguy> oerjan: it was still valid syntax
13:43:07 <oerjan> yeah :)
13:43:20 <glguy> oerjan: you have irssi?
13:43:21 <foo32> why do i be kicked?
13:43:25 <oerjan> yep
13:43:39 <shachaf> Is there a version of takeWhile that keeps the first element that the function returns False for?
13:44:01 --- mode: ChanServ set +o glguy
13:44:03 <Igloo> No, but with span you could write your own
13:44:10 --- mode: glguy set +b %visof!*@*
13:44:20 --- mode: glguy set -o glguy
13:44:54 --- mode: ChanServ set +o Igloo
13:45:07 --- mode: Igloo set +b *!*@196.218.142.218
13:45:10 <shachaf> Igloo: Oh, I'd forgotten about span. That's like takeWhile + dropWhile, right?
13:45:13 <shachaf> @ty span
13:45:15 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
13:45:18 --- mode: Igloo set -b %visof!*@*
13:45:34 <glguy> Igloo: that's a +q, he can join and listen, just cna't talk or switch nicks
13:46:03 <glguy> if you are just going to ban, we should add it to chanserv
13:46:11 <Igloo> What's a +q? The %?
13:46:13 <vincenz> visof: Go to wikipedia
13:46:25 <glguy> Igloo: I believe so , you add it with /mode +q
13:46:28 <glguy> it's the quiet mode
13:46:38 <Igloo> I don't really mind what is done, anyway, but it should use the IP rather than the nick
13:46:44 <glguy> agreed
13:46:52 --- mode: Igloo set -b+b *!*@196.218.142.218 %*!*@196.218.142.218
13:47:50 <SimonRC> is there a way I can get the emacs mode to show me the inferred type of a variable?
13:50:23 <EvilTerran> @src sequence
13:50:23 <lambdabot> sequence ms = foldr k (return []) ms
13:50:23 <lambdabot>     where
13:50:23 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
13:50:36 <EvilTerran> surely k = liftM2 (:) ?
13:50:50 <fasta> SimonRC: only for top-level bindings
13:51:00 <glguy> EvilTerran: yes
13:51:14 <fasta> instance (MonadState s (m s)) => MonadState s (MaybeT (m s)) <- can this instance be defined?
13:51:21 <fasta> Oops
13:51:21 <glguy> ?. pl undo \ m m' = do { x <- m; xs <- m'; return (x:xs) }
13:51:21 <lambdabot> (line 1, column 21):
13:51:21 <lambdabot> unexpected "{"
13:51:21 <lambdabot> expecting variable, "(", operator or ")"
13:51:34 <glguy> ?. pl undo \ m m' -> do { x <- m; xs <- m'; return (x:xs) }
13:51:34 <lambdabot> liftM2 (:)
13:51:49 <EvilTerran> is there a reason why the @src doesn't reflect this?
13:51:55 <SimonRC> fasta: bah
13:51:56 <fasta> I meant MonadState s (MaybeT m)
13:52:09 <SimonRC> Something spiffy like F# has would be nice
13:52:14 <glguy> EvilTerran: probably because people that don't know how sequence is implemented wouldn't know how liftM2 works
13:52:43 <EvilTerran> @src liftM2
13:52:43 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
13:53:01 * EvilTerran shrugs.
13:53:27 <oerjan> EvilTerran: perhaps because sequence is in Prelude but liftM2 isn't
13:53:40 * glguy likes oerjan's reason better
13:53:44 <EvilTerran> ahh. that one makes sense. =]
13:53:57 <glguy> but @src isn't just raw source code from GHC
13:54:04 <glguy> @src is a teaching tool
13:54:04 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
13:55:42 <Excedrin> shouldn't @src pull from the report, instead of ghc sources?
13:55:58 <oerjan> although as i recall, the Prelude does import some things from other modules
13:56:12 <jethr0> ghc sources are the new report *ducks*
13:56:51 <SamB> Excedrin: my understanding is that the database is hand-built
13:57:38 <oerjan> carefully hand-sewn with only the finest bits and bytes
13:57:44 <fasta> It's quite odd that the people hammering on formal correctness don't even know how their language is supposed to function.
13:58:01 <SamB> yes it is
13:58:32 <fasta> I think it is important to know what compilers should do for Haskell 98.
13:58:38 <mux> @src [] guard
13:58:38 <lambdabot> Source not found. Maybe if you used more than just two fingers...
13:58:53 <shachaf> @src guard -- Not in a type class.
13:58:53 <lambdabot> Source not found. The more you drive -- the dumber you get.
13:58:55 <glguy> guard isn't monad specific
13:58:59 <shachaf> @src guard
13:58:59 <lambdabot> guard True  =  return ()
13:58:59 <lambdabot> guard False =  mzero
13:59:00 <SamB> I wonder if we would be able to *read* a denotational semantics for Haskell anyway?
13:59:02 <mux> ah right
13:59:06 <mux> @src [] mzero
13:59:06 <lambdabot> mzero = []
13:59:14 <mux> fine, as expected :)
13:59:19 <fasta> SamB: It can be an operational semantics too.
13:59:34 <fasta> SamB: as long as someone proved it to be correct.
13:59:42 <mux> @type mzero
13:59:42 <fasta> SamB: with a proof assistant.
13:59:44 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
13:59:53 <mux> I thought guard was using MonadFail
13:59:58 <SamB> fasta: how do you prove it correct?
14:00:09 <fasta> SamB: Something like Coq.
14:00:20 <fasta> SamB: I am sure there are people capable of doing that.
14:00:22 <SamB> what does it mean for the semantics to be correct?
14:00:53 <fasta> SamB: ok, then some weaker condition.
14:00:54 <mattam> The semantics of what ?
14:01:25 <wli> SamB: Soundness and completeness.
14:01:38 <SamB> mattam: he is proposing that there should be a formal semantics for Haskell
14:01:40 <wli> SamB: Computational adequacy.
14:01:55 <SamB> hmm, what is "completeness"?
14:02:00 <Excedrin> what is semantics
14:02:27 <SamB> Excedrin: well, it's a kind of formalism that tells you what programs are supposed to do
14:02:38 <fasta> wli: hmm, yes, it should be possible.
14:02:53 <glguy> ML has this, no?
14:02:58 <mattam> Oh. People are already striving to give a mechanized proof of Standard ML.. which was designed with formal semantics in mind :) So don't be expecting it too soon
14:03:04 <SamB> apparantly they have a formal semantics
14:03:18 <glguy> formal semantics aren't great for a language that wants to stay *agile*
14:03:22 <SamB> I'm not sure
14:03:23 <mattam> They have one on paper yes.
14:03:35 <glguy> Haskell is supposed to be a test bed for new language ideas
14:03:36 <SamB> anyway, we have a lot of micro-semantics'
14:03:36 <Excedrin> hahaha agile
14:03:46 <SamB> Excedrin: seriously
14:03:47 <Excedrin> oh, you're not joking
14:04:00 <fasta> glguy: if everything compiles to Haskell 98 in the end, it seems like a good idea.
14:04:05 <glguy> fasta: but it doesn't
14:04:19 <SamB> fasta: it compiles to a host of different languages
14:04:27 <fasta> glguy: still, even in my programs I like to have a contract.
14:04:40 <mattam> I'm sure there are kind-of-semantics for every extension, what would all these papers be about otherwise :) ?
14:04:46 <SamB> by which I mean somewhere between a half dozen and, oh, twenty?
14:04:52 <fasta> mattam: all those papers are full of bugs.
14:04:59 <mattam> Probably.
14:05:00 <wli> SamB: Soundness and completeness are a lookup sort of thing. Axiomatic semantics vs. denotational vs. operational etc.
14:05:20 <SamB> JHC uses E (A Pure Type System) and GRIN...
14:05:24 <fasta> mattam: it is next to impossible to take an article and implement a system out of it without thinking about it.
14:05:39 <mattam> Indeed.
14:05:39 <SamB> GHC uses System F_c right now
14:05:45 <SamB> and STG
14:05:47 <SamB> and CMM
14:06:01 <SamB> (Cmm?)
14:06:17 <oerjan> C--
14:06:18 <SamB> I've no idea what hugs uses...
14:06:48 <mattam> But going the "elaboration" way were you prove everything correct is a LOT of work. Maybe not worth it considering the use of these extensions.
14:07:00 <mattam> s/were/where/
14:07:04 <wli> I can't quite tell how many degrees of freedom higher-dimensional continuity constraints consume, but it all seems to work out.
14:07:46 <SamB> fasta: how are you expecting to take an article describing an extension and fit it into an existing system without thinking?
14:08:03 <fasta> SamB: I was not talking about the extensions.
14:08:24 <fasta> SamB: It holds for vanilla Haskell 98
14:08:58 <mattam> Is there a model of Haskell with seq anyway ?
14:09:14 <SamB> explain what a model is?
14:09:35 <fasta> He means denotation semantics, and I think there is.
14:09:40 <mattam> I mean which respect the reduction.
14:09:42 <fasta> denotational*
14:09:42 <dblhelix> mattam: there is, I am trying to remember it desperately
14:09:52 <mattam> Indeed, a denotational one.
14:10:18 <mattam> Like domain theory and the like.
14:10:22 <SamB> is a model like the small langauges they have in some of these papers, like the paper on eval/apply vs. that other technique?
14:10:29 <mattam> I'm guessing it's ugly.
14:10:43 <dblhelix> mattam: i'm not sure, but perhaps it's in thomas streicher's book
14:10:52 <mattam> ok
14:10:58 * wli is guessing Haskell's loaded up with enough features to make it equivalent to the Riemann hypothesis or some such.
14:11:05 <dblhelix> @google "Domain Theoretic Foundations of Functional Programming"
14:11:08 <lambdabot> http://www.worldscibooks.com/compsci/6284.html
14:11:08 <lambdabot> Title: DOMAIN-THEORETIC FOUNDATIONS OF FUNCTIONAL PROGRAMMING
14:11:37 <mattam> SamB: can be. For example you can interpret simply-typed lambda calculus in other languages, that gives them a model.
14:13:01 <mattam> that gives _it_ a model
14:14:06 <mattam> At least knowing that everything GHC does works in System F plus coercions is good enough.
14:14:31 <mattam> Why would you need more ?
14:14:55 <Heffalump> Doaitse Swierstra has an example of a program he wants to write that GHC can't represent in System F. I dunno if it works in FC.
14:15:27 <dblhelix> Heffalump: I've been working on that program... I managed to find a workaround
14:15:41 <dblhelix> I haven't thought of an System FC translation though...
14:15:56 <fasta> dblhelix: where is that program that GHC can't represent in System F?
14:16:14 <dblhelix> fasta: I do not have it anywhere on line
14:16:17 <Heffalump> it was on some mailing list some months ago
14:16:32 <dblhelix> the trick is that there a value of type forall a. exists b. ...
14:17:22 <dblhelix> and you want to *first* unpack the existential and then use the resulting skolem to instantiate the universal type
14:17:48 <dblhelix> it kind of boils down to a restricted form of fixed point computation on the type level
14:18:35 <dblhelix> on moral grounds :-), I tend to think that ghc is right in rejecting the program
14:19:04 <mattam> Seems weird.
14:19:20 <dblhelix> however, there are days that I wake up and think we're not that unreasonable in our desire to have this program pass the type checker
14:19:23 <mattam> What are his grounds for saying it should be accepted ?
14:19:28 <dblhelix> it is guaranteed to be type-safe
14:19:49 <dblhelix> however, so is if False then 'c' else 42
14:19:57 <mattam> Would it typecheck in Coq ?
14:20:04 <dblhelix> mattam: no
14:20:18 <EvilTerran> dblhelix, i think, for problems like that, we have unsafeCoerce# ;]
14:20:22 <dblhelix> okay, wanna see the program?
14:20:35 <dblhelix> EvilTerran: we end up using unsafeCoerce# at some point
14:20:55 <dblhelix> EvilTerran: now, we use the workaround, which is trivial but tedious
14:21:16 <mattam> Yes!
14:21:26 <dblhelix> data T a = forall b. D ((b -> a) -> (b, Int))
14:21:45 <dblhelix> runT :: (forall a. T a) -> Int
14:22:22 <dblhelix> runT t = case t of T g -> let (_, n) = g id in n
14:22:26 <fasta> Can anyone explain the rules for overlapping instances shortly?
14:22:50 <fasta> If it just matches the most specific instance available, I am happy.
14:23:08 <dblhelix> mattam: of course, that's not the real propgram;  this is just a nice contrived example that shows the issue
14:23:27 <dblhelix> think about it, I'll show you the work around in a minute
14:24:25 <mattam> data T a = forall b. ... is different from data T a b = ... ?
14:24:43 <dblhelix> mattam: very much!
14:24:57 <dblhelix> mattam: the b is existentially quantified
14:25:03 <mattam> Ok
14:25:34 <dblhelix> in the type that is, in the type of the data constructor it's universally quantified---hence, the forall
14:25:51 <dblhelix> interestingly, the program is accepted by both hugs and ehc
14:26:08 <Saizan> fasta: that's what it'll do, if there's one
14:26:20 <mattam> I'm trying to write it in Coq.
14:26:23 <dblhelix> futhermore, we can type the example using the constraint-based techniques that underlie for example helium
14:26:25 <Heffalump> the hugs typechecker might just be wrong, though
14:26:33 <fasta> Saizan: what a practical system :)
14:26:38 <dblhelix> Heffalump: define 'wrong'
14:26:49 <fasta> dblhelix: uhm, that program doesn't work here.
14:27:03 <dblhelix> fasta: where's here? which compiler
14:27:07 <fasta> dblhelix: Not in scope: data constructor `T'
14:27:21 <dblhelix> fasta: I'm sorry... that should be a D
14:27:22 <fasta> dblhelix: You made a typing error, I guess
14:27:25 <Heffalump> IM that it may accept badly typed programs too
14:27:28 <fasta> dblhelix: Yes, I saw that.
14:27:32 <Heffalump> I have the impression it's not very robust
14:27:44 <dblhelix> Heffalump: define badly typed ;-)
14:27:55 <Heffalump> things that go wrong at runtime
14:27:56 <mattam> (forall a : T a) -> Int really ?
14:28:04 <dblhelix> mattam: yes
14:28:14 <dblhelix> Heffalump: in this case, it won't go wrong at runtime
14:28:23 <pejo> glguy, why would a operational/denotational semantics prevent people from trying out new things?
14:28:37 <Heffalump> dblhelix: I know. I'm just saying I wouldn't trust hugs not to be accepting it by accident.
14:28:43 <dblhelix> I can see that you're eager to learn about my workaround ;-)
14:28:45 <mattam> (forall a. T a) -> Int really ? What's a value of type (forall a. T a) ?
14:28:47 <dblhelix> Heffalump: okay
14:29:01 <dblhelix> mattam: you've a rank-2 type there
14:29:05 <glguy> pejo: it would just get out of date and be useless
14:29:14 <dblhelix> it's a type function, more or less
14:29:22 <fasta> dblhelix: Inferred type is less polymorphic than expected, do you get that too?
14:29:27 <mattam> then it is a function which for any a gives you a T a.
14:29:31 <dblhelix> fasta: in ghc, yes
14:29:48 <dblhelix> mattam: it's a function that produces a T a for every type a
14:29:58 <mattam> And you're actually doing case on this _function_
14:30:21 <mattam> I guess it's implicitely instantiated then
14:30:29 <dblhelix> mattam: no, I'm calling the function and then do case analysis on it
14:30:41 <dblhelix> on its result that is
14:30:55 <mattam> With which argument ?
14:31:17 <pejo> glguy, so the semantics changes every now and then as it is right now?
14:31:21 <dblhelix> mattam: the type that we are yet to obtain from unpacking the existential
14:31:28 <mattam> You're doing case t of where t : (forall a. T a).
14:31:30 <mattam> !
14:31:44 <ari> Does anybody happen to know if there's a way to pan sounds in Haskore?
14:31:47 <mattam> ok... that's definitely crazy.
14:31:47 <glguy> pejo: this isn't my argument, its just one of the reasons it hasn't been pursued
14:31:49 <laz0r> hi, there #haskell
14:32:13 <laz0r> i've been recently playing with the state monad, maybe you remeber
14:32:18 <dblhelix> mattam: if I'm writing the type arguments explicitly I'd write case t [B] of ...
14:32:33 <dblhelix> mattam: so I first apply the type function and *then* do the case analysis
14:32:38 <mattam> B is not in scope...
14:32:44 <mattam> Is it ?
14:33:04 <fasta> dblhelix: I find "type function" confusing. It simply generates for every value of type a, a value of type T a
14:33:08 <laz0r> and now, i have found a solution thats much easier for simple things, i just use an infinite list!
14:33:27 <laz0r> shouldn't become a problem should it?
14:33:40 <fasta> dblhelix: a type function would be e.g. something in Template Haskell that given a type would return another type.
14:33:42 <dblhelix> fasta: in System F it's more like a type function, but okay, I do not want to confuse you---this is complicated in its own right
14:34:01 <fasta> dblhelix: right, in System F.
14:34:08 <dblhelix> fasta: let's not argue on terminology (it's late here ;-))
14:34:16 <laz0r> i mean, lazy evaluation does the trick, the list is always evaluated 'as far as needed' right?
14:34:17 <glguy> laz0r: if you have some code you want looked at you could
14:34:18 <glguy> !paste
14:34:19 <hpaste> Haskell paste bin: http://hpaste.org/
14:34:25 <dblhelix> @localtime dblhelix
14:34:26 <lambdabot> Local time for dblhelix is 2007-07-19 23:33:35 +0200
14:35:23 <hpaste>  laz0r pasted "using infinite list instead of state monad" at http://hpaste.org/1778
14:35:24 <fasta> dblhelix: sure, but I like to make things precise and eliminate jargon
14:35:32 <laz0r> so, there, thats it
14:35:51 <laz0r> ok... maybe this isn't so spectacular.. but for me it is right now :)
14:36:00 <glguy> laz0r: do you know about zipWith?
14:36:02 <glguy> :t zipWith
14:36:11 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
14:36:52 <dblhelix> fasta, Heffalump, mattam: but well, that's the program... yes, we're definitely crazy... but this came up in practice :-)
14:36:59 <laz0r> glguy, i knew zip, but not zipWith
14:37:08 <hpaste>  glguy annotated "using infinite list instead of state monad" with "using zipWith" at http://hpaste.org/1778#a1
14:37:16 <mattam> fasta: (forall a. T a) takes a type to a type right ?
14:37:29 <laz0r> i tried with zip, but that produces [(a,b)], and that didn't fit
14:37:44 <glguy> laz0r: why didn't it?
14:37:58 <mattam> a function of this types takes a value of any a to a value of T a though.
14:37:59 <glguy> laz0r: you would then have: f (i,l) = show i ++ " : " ++ l
14:38:18 <mattam> dblhelix: Still, [B] is not in scope.
14:38:29 <laz0r> glguy, ah... ok
14:38:40 <laz0r> i couldn't match the tupels
14:38:43 <dblhelix> mattam: that's the whole issue... so, indeed, in System F, this would not work
14:38:44 <glguy> laz0r: did you look at the annotation I posted to hpaste?
14:38:56 <laz0r> but now that i see this... it is obvious
14:39:18 <laz0r> now im looking
14:39:53 <fasta> dblhelix: it's not very surprising that one can find "problems" in these systems.
14:40:14 <glguy> laz0r: just as an exercise, do you know how to write "lineNumbers" without naming "s"
14:40:20 <glguy> laz0r: using the (.) operator
14:40:28 <dblhelix> fasta: I'm not claiming that
14:40:56 <hpaste>  mattam pasted "runT in Coq" at http://hpaste.org/1779
14:41:02 <laz0r> what do you mean with 'without naming'?
14:41:06 <fasta> dblhelix: When you want to encode a proof of a sufficiently complex program in a certain way, things will blowup sooner or later.
14:41:23 <glguy> laz0r:  (f . g) x = f (g x)
14:41:35 <fasta> dblhelix: I know you were not claiming that.
14:41:37 <mattam> That's one try, obviously I had to instantiate t to make it typecheck.
14:41:41 <glguy> so instead of f x = g (h x), you can have: f = g . h
14:41:41 <shachaf> laz0r: lineNumbers = ...
14:41:55 <mattam> But i'm not sure my "T a" definition is equivalent to the Haskell version.
14:42:11 <laz0r> i would think something like (\x -> ...) but... i have no idea
14:42:18 <glguy> laz0r: in your case, like shachaf said, you could write lineNumbers = , without the s parameter, using (.)
14:42:38 <reffie> anyone know if there's an ICFP irc channel?
14:42:43 <fasta> reffie: #oasis
14:42:44 <glguy> lineNumbers x = unlines (zipWith f [1..] (lines s))
14:42:49 <glguy> oops: x -> s
14:42:51 <reffie> thanks
14:43:04 <glguy>  which matches the pattern f (g x) -> f . g
14:43:12 <glguy> (twice)
14:43:32 <glguy> so you can write: lineNumbers = unlines . zipWith f [1..] . lines
14:43:35 <dblhelix> mattam: mmm... perhaps I should have written (a -> b) (b -> a)
14:43:49 <EvilTerran> is there a nice way of writing (map tail . filter (not.null))?
14:43:49 <dblhelix> mattam: eh... (a -> b) instead of (b -> a) that is
14:43:49 <fasta> Where is the overlapping instance flag needed?
14:43:56 <mattam> Hmm ?
14:43:56 <fasta> At the module that uses it?
14:44:07 <dblhelix> mattan: lemme check... (did I mention it's late here?)
14:44:08 <laz0r> mmmh
14:44:09 <fasta> Or in the defining module?
14:44:23 <EvilTerran> all modules where the overlapping instances are in scope, iirc
14:44:51 <EvilTerran> so the defining module _and_ anywhere that imports anything relying on that instance
14:45:11 <dblhelix> mattam: no, it's (b -> a), but I really need id there, not (const 0)
14:45:16 <EvilTerran> or alias ghc=ghc -fglasgow-exts
14:45:31 <EvilTerran> ;]
14:45:40 <Saizan> no
14:45:53 <Saizan> it's only needed in the module that define the overlapping instance
14:46:02 <mattam> Hmmm
14:46:07 <dblhelix> mattam: but I can imagine that, you'll have troubles with (a -> b) and any proof as well
14:46:52 <fasta> EvilTerran: you need more than -fglasgow-exts
14:47:17 <fasta> All the usefull stuff needs -fallow-undecidable-instances -X=AllowOverlappingInstances -fglasgow-exts
14:47:25 <EvilTerran> sorry, yes, you're right. but you can see where i'm coming from, i see.
14:47:30 * dblhelix yawns
14:47:33 <mattam> Yes. There's no way b unifies with a anyway.
14:47:53 <dblhelix> mattam: you can proof it in coq with id as well...
14:48:11 <dblhelix> mattam: the workaround is to introduce an addition inductive type:
14:48:17 <mattam> Passing id is saying that a = b, no ?
14:48:25 <dblhelix> mattam: yes
14:48:41 <EvilTerran> Saizan, okay. i stand corrected.
14:48:46 <mattam> So you have to coerce with an equality at some point.
14:49:04 <dblhelix> data TT a = forall c. DD ((forall b. ((b -> a) -> (b, Int)) -> c) -> c)
14:49:20 <dblhelix> now, define from :: T a -> TT a
14:49:47 <dblhelix> then, define runTT :: (forall TT a) -> Int
14:50:00 <dblhelix> and have runT t = runTT (from t)
14:50:06 <dblhelix> easy as pie!
14:50:18 <dblhelix> no, really, it's tedious, but it works
14:50:23 <mattam> Hmm.
14:50:53 <mattam> So forgeting about the out-of-scope B it works the way you just described ?
14:50:58 <mrd> gah icftp starts at 6am local time
14:51:00 <mrd> icfp
14:51:06 <dblhelix> mattam: yes
14:51:29 <dblhelix> it works in ghc and it's valid in system f as well as the calculus of inductive constructions
14:51:42 <mattam> Man that's a mind-blogging definition :)
14:51:56 <ddarius> What?
14:52:15 <mattam> Do you have any intuitions on why it works ?
14:52:41 <dblhelix> mattam: TT describes any possible use of T
14:53:00 <mattam> Yes, it looks like an eliminator.
14:53:06 <dblhelix> in general T is consumed by a function that uses it to produce a value c
14:53:40 <dblhelix> now if I've a value forall a. TT a, then I can use it to construct a value of type
14:54:02 <dblhelix> forall b. (b -> b) -> (b, Int)
14:54:15 <mattam> btw, i don't think the (b, in (b, Int) is needed.
14:54:38 <dblhelix> mattam: no not really, we do not use it in this example
14:54:58 <dblhelix> anyway, I'm a bit tired :-)
14:55:23 <dblhelix> just a bit more than 12 hours before the start of the contest
14:55:28 <mattam> Okay. I'll bother you later then.
14:55:49 <mattam> And still a documentation commit to do... :)
14:56:24 <dblhelix> mattam: expect a paper that uses a program like this soon ;-)
14:58:05 <dblhelix> mattam: drom me a lambdabot message as soon as you find a nicer solution ;-)
14:58:11 <dblhelix> /s/drom/drop
14:58:21 <dblhelix> or send me an e-mail
14:58:56 <mattam> I'll find you :-) I'm already googling you
14:59:41 <dblhelix> ouch
14:59:54 <dblhelix> don't believe everything that's out there
14:59:57 <mattam> Oh damn, are you an organizer this year ?
15:00:09 <dblhelix> yes, 12 hours to go :-)
15:00:24 <mattam> Well, good luck anyway :)
15:01:06 <dblhelix> mattam: thanks
15:01:15 <dblhelix> goodnight #haskell!
15:01:42 <Saizan> night!
15:08:10 <EvilTerran> hm. is there a library fn (\f e xs -> if null xs then e else f xs)?
15:08:39 <mauke> that looks weird
15:09:06 <EvilTerran> ?type maybe
15:09:08 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
15:09:14 <mauke> I'd have expected something like \e f xs -> case xs of [] -> e; h : t -> f h t
15:09:15 <EvilTerran> like that, but for functions
15:09:21 <mauke> and I don't think it exists
15:09:25 <mauke> foldr is similar, though
15:09:32 <EvilTerran> s/functions/lists/
15:13:26 <quicksilver> thats a "non-recursive catamorphism for []"
15:13:33 <quicksilver> and it's not in the standard library, no
15:13:46 <shachaf> quicksilver: So a catamorphism is a function like maybe/foldr/either/etc.?
15:13:48 <ddarius> maybe . listToMaybe
15:13:50 <quicksilver> although mauke's version would be more normal
15:13:53 <ddarius> Very roughly.
15:13:58 <shachaf> ddarius: No, that disregards the rest of the list.
15:14:04 <quicksilver> shachaf: yes
15:14:08 <ddarius> ah
15:14:15 <quicksilver> shachaf: a catamorphism is the 'opposite', loosely, to a constructor
15:14:23 <quicksilver> (well, to all the constructors at once)
15:14:27 <shachaf> quicksilver: So THAT'S what it means... :-)
15:14:48 <wli> Well, there are paramorphisms and hylomorphisms.
15:14:49 * shachaf was wondering both what a catamorphism was and what that type of function is called. :-)
15:14:52 <ddarius> quicksilver: A case analysis function is not a catamorphism (for recursive types).
15:15:21 <quicksilver> ddarius: I have seen it called such; I think the terminology is rather relaxed
15:15:43 <ddarius> quicksilver: The terminology being used laxly does not mean it is lax.
15:16:42 <wli> I think paramorphisms are like mapAccumL, hylomorphisms like foldr, but I'm not 100% sure.
15:17:27 <ddarius> A hylomorphism is foldr . unfoldr
15:17:35 <wli> No... hylomorphisms are setup and teardown in one.
15:17:40 <wli> Yeah.
15:17:53 <wli> cata . ana = hylo
15:17:57 <vaste_> phew, I finally managed to get HaXml to parse a large file lazily
15:18:00 <dolio> And don't forget zygomorphisms.
15:18:34 <dolio> Oh, and histomorphisms.
15:18:35 <vaste_> turns out only manyFinally had been made lazy enough, not many1 -_-
15:18:42 <wli> dolio: I've not heard of those.
15:18:53 <ddarius> @google "Recursion Schemes from Comonads"
15:18:55 <lambdabot> http://cs.ioc.ee/~tarmo/papers/nwpt00.ps.gz
15:18:59 <dolio> http://www.eyrie.org/~zednenem/2004/hsce/Control.Recursion.html
15:19:26 <dolio> That has all sorts of fun ones.
15:19:28 <HairyDude> grarrr, Map t isn't a monad
15:19:50 <oerjan> @instances-importing Data.Map Monad
15:19:51 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
15:19:53 <dolio> Some of which I haven't actually seen in any papers. But that's probably my fault.
15:20:00 <HairyDude> cos it needs Ord
15:20:15 <dolio> HairyDude: What does 'return a' mean for maps?
15:20:21 <dolio> Which key does it use?
15:20:31 <HairyDude> hmm, good point
15:20:39 <mauke> ALL OF THEM
15:20:45 <dolio> Hah.
15:21:03 <dolio> Now that would be efficient.
15:21:18 <mauke> Map.lookup is a monad, kind of
15:21:22 <wli> dolio: I've never seen or heard of a number of these.
15:22:11 <ddarius> apo is the dual of para
15:22:27 <wli> I can't smoke out what that means.
15:23:11 <HairyDude> suppose you could make a comonad out of it
15:26:28 <dolio> wli: I think the only extra one I've heard of in there is zygo, which is, I believe, in Bananas in Space. I don't know where exactly histo and apo were introduced.
15:28:29 <wli> I mostly write to the ML subset of Haskell. :(
15:28:31 <HairyDude> well if you could do 'return (k,a)' you could make it a monad, but sadly you can't do something like data Map (k,a) = ... and then do instance Monad Map where return = uncurry singleton
15:29:35 * wli has fond memories of writing in the fully functorial style.
15:30:00 <Philippa> wli: all the *morphisms're doable in the ML subset, they're just operations on algebraic datatypes you can build from case analysis
15:30:02 <_Stinger_> anyone got a good tut on comonads
15:30:50 <wli> Philippa: Yeah, there are just odd new *morphisms floating about I've never seen before.
15:31:17 <dolio> I guess I'm wrong about zygo. I don't see it in Bananas in Space. I guess I don't know where I'd heard of it before. :)
15:31:37 <mauke> @where evolution
15:31:37 <lambdabot> I know nothing about evolution.
15:31:38 <wli> That was mostly a reply to the monad/comonad business.
15:31:45 <shachaf> Why is there an RWS? If you have the S part, why do you need R?
15:32:02 <nominolo> @where creationalism
15:32:02 <lambdabot> I know nothing about creationalism.
15:32:03 <mauke> shachaf: for immutable/local state
15:32:08 <nominolo> *phew*
15:32:26 <shachaf> mauke: What do you mean?
15:32:50 * wli has enough trouble with just the State monad as it is.
15:32:59 <mauke> e.g. you could have a fixed symbol table in the R and mutable variables in the S
15:33:12 <mauke> in an interpreter, I mean
15:33:23 <slava> glguy: you said 0.89 would go nuts when you moved the mouse or typed keys, does this mean it opened error popups, or was there a repainting issue?
15:33:41 <slava> glguy: because i just upgraded my linux box from debian 3.1 to 4.0 and i have a repaint issue
15:33:46 <shachaf> mauke: Hmm, OK, I guess.
15:33:48 <slava> could be the same one
15:33:49 <glguy> repainting
15:34:00 <slava> glguy: like only the gadget at the mouse would paint, and the rest would be black?
15:34:13 <glguy> it would flicker between two paintings
15:34:19 <slava> glguy: the ui clips the gl viewport to only repaint necessary regions, and it seems that on some systems it does this wrong and clears the whole screen anyway
15:34:20 <glguy> stuff would jump around
15:34:24 <glguy> wildly
15:34:33 <slava> ok
15:34:40 <glguy> it was painting too much.. not too little :)
15:34:56 <slava> flickering as if double buffering was off, or more like corruption?
15:35:19 <glguy> slava: flickering like it was confused..
15:35:29 <glguy> not like it was slow to repaint
15:35:58 <slava> i guess repainting part of the gl viewport is not as easy as i thought it was
15:36:20 <slava> if you're still interested in getting it working and want to test a workaround later, come ping me on #concatenative
15:36:22 <slava> i have to go now
15:37:28 <glguy> kk
15:38:48 <HairyDude> @google haskell comonad
15:38:49 <lambdabot> http://www.haskell.org/hawiki/CoMonad
15:38:53 <HairyDude> that gives a 404
15:39:28 <monochrom> hawiki was hidden away a few days ago.
15:39:58 <pjd> monochrom: has all the content been ported?
15:40:02 <pjd> or what?
15:40:29 <monochrom> The content is still saved somewhere, just inaccessible.
15:40:43 <monochrom> No, the content has not all been ported.
15:41:52 <monochrom> I wish I knew an alternative source of comonads.
15:42:53 <pjd> http://del.icio.us/tag/comonads ?
15:42:56 <lambdabot> Title: Pages tagged with "comonads" on del.icio.us
15:43:08 <oerjan> you can read google's cached page
15:43:26 <HairyDude> I could just read the paper, I printed it out the other day :)
15:43:46 <HairyDude> (for a completely different reason)
15:43:57 <Cale> Comonads! Get your comonads here!
15:44:04 <ari> This is funky. Ever since the last time somebody mentioned lazy naturals on cafe I've been seeing all sorts of places to use them in...
15:44:11 <HairyDude> Cale: onna stick or inna bun?
15:44:52 <Cale> bun, with sauerkraut
15:45:35 <Cale> Functorial sauerkraut
15:46:44 <pjd> lazy naturals?
15:46:45 <HairyDude> mmm, functors for breakfast
15:46:51 <HairyDude> I like mine naturally transformed
15:47:15 <monochrom> @remember HairyDude mmm, functors for breakfast. I like mine naturally transformed
15:47:15 <lambdabot> Done.
15:47:37 <wli> *** Exception: index out of bounds
15:48:05 <wli> That could get interesting.
15:48:35 <Cale> *** Exception: index in bounds, but I'm just being a dick.
15:48:47 <wli> I'm sure.
15:50:57 * ddarius thinks writing a very cut-down vim in C# is going to be easier than he thought.
15:51:16 <Cale> Why are you doing that?
15:51:55 <ddarius> Cale: Because I'm pretty sure I technically am not allowed to install something like vim on my work computer, but I can make projects in C#.
15:52:09 <monochrom> Probably because C# 5.0 will have syntactic support for zippers.  (duck)
15:52:11 <Cale> heh
15:52:29 <Cale> We'll let you run arbitrary code, as long as it's written in C#.
15:52:59 <monochrom> Alonzo Church was a genius.
15:53:19 <ddarius> As the sysadmin for our closed development network, it wouldn't really benefit me to make a virus or some such.
15:53:23 <monochrom> Give me a lambda, and I will install Linux for you.
15:53:29 * wli ponders how to figure out where out-of-bounds array accesses are coming from.
15:53:47 <ddarius> wli: The same way you find out where any exception is coming from.
15:53:56 <Cale> wli: Try compiling with -prof -auto-all and running the program with +RTS -xc
15:54:16 <wli> There isn't a main yet, though I suppose I can arrange one.
15:54:44 <slava> you mean ghc doesn't retain debug info for exception traces by default?
15:54:45 <slava> tsk, tsk
15:55:10 <ddarius> slava: Exception traces don't really mean the same thing in a lazy language...
15:55:16 <slava> i understand
15:55:25 <ddarius> And it doesn't even retain them not-by-default.
15:55:26 <pjd> ddarius: you're the sysadmin, but you're not allowed to install Vim?
15:55:28 <SamB> it really messes up optimization
15:55:41 <ddarius> pjd: Able to, and allowed to are different things.
15:55:49 <pjd> yes
15:55:56 <pjd> i meant allowed :)
15:56:34 <wli>       Perhaps you haven't installed the profiling libraries for package base?
15:56:36 <ddarius> It's (the network) technically not supposed to have any outside software on it.
15:56:38 * Cale scowls at ddarius' micro-managing higher-ups
15:56:46 <SamB> ddarius: quick!
15:56:50 <glguy> the #haskell ops aren't *allowed* to mass kick #haskell, similarly ;)
15:56:53 <SamB> delete the operating systems!
15:57:23 * pjd imagines a network without outside software
15:57:29 <glguy> though installing vim doesn't seem tantamount to mk
15:57:37 <shachaf> ddarius: Are you not allowed to run any binaries that aren't C# or preinstalled?
15:57:44 <Cale> It'd be pretty sweet to be running all in-house OSes.
15:57:55 <monochrom> wli: If you don't mind annotating by hand, Control.Exception.assert displays lines numbers.
15:57:58 <glguy> Cale: until you had to use it for something ;)
15:58:03 <pjd> glguy: it sounds more like not allowing your builder to use a hammer
15:58:30 <ddarius> shachaf: We're not supposed to be downloading crap from the internet and installing it on our computers.
15:58:31 <glguy> ok, I concede, that's lame
15:58:33 <SamB> I don't remember windows coming with any development tools
15:58:59 <wli> <Data.Sequence.CAF>hermite: index out of bounds
15:59:00 <Cale> Notepad!
15:59:00 <shachaf> ddarius: Use a CD. :-)
15:59:05 <pjd> Cale: doesn't C# itself count as outside software (or are you working at Microsoft)?
15:59:15 <ddarius> shachaf: I can't bring a burnt CD into work.
15:59:19 <Cale> pjd: You mean ddarius
15:59:23 <wli> Informative? Maybe.
15:59:24 <pjd> err, s/Cale/ddarius/
15:59:46 <Cale> ddarius: Are furbies allowed in?
15:59:48 <ddarius> pjd: There's a base of stuff.
15:59:53 <ddarius> Cale: Definitely not.
15:59:54 <SamB> Cale: notepad doesn't compile or run programs
16:00:05 <ddarius> Cale: And I'm actually being dead serious there.
16:00:07 <shachaf> SamB: Neither does vim. :-)
16:00:16 <pjd> ddarius: military?
16:00:23 <ddarius> pjd: Bingo
16:00:31 <Cale> hehe
16:00:56 <shachaf> SamB: (Fine, I guess it can run them, and that includes running a compiler.)
16:00:59 <pjd> how far into the "we don't exist" scale? :)
16:01:19 <SamB> well they've got the "not invented here" down pat
16:01:44 <ddarius> pjd: I require a badge to get into my building, but not to get out.  Other buildings I have access to require it to get out.
16:02:46 <SamB> pjd: there seems to be little justification to your not being allowed to install vim if you don't even need a badge to get out...
16:02:58 <SamB> er.
16:03:00 <SamB> ddarius:
16:03:19 * SamB is glad pjd just did the same thing
16:04:00 <ddarius> I doubt my supervisors would say no for security reasons.
16:04:48 <pjd> what reasons, then?
16:04:59 <SamB> are they emacs users?
16:05:36 * pjd chortles
16:06:16 <ddarius> It wouldn't be worth the trouble.
16:07:02 <pjd> replacing notepad seems worth the trouble
16:07:11 <ddarius> I don't develop in notepad.
16:08:03 <pjd> well, avoiding re-implementing a Vim-alike should surely be worth the trouble
16:08:40 <ddarius> It's not like I have to.
16:09:39 <shachaf> ddarius: But you're going to (maybe). Doesn't that imply a fair amount of trouble?
16:10:25 <ddarius> shachaf: For me, not for them (and that's even assuming I'd look at it as trouble).  It's not like I would be able to neglect my duties to do it.
16:11:33 <wli> Wrong answers...
16:13:25 <monochrom> use notepad to write javascript, then use IE to run.
16:14:06 <Olathe> Use Notepad to write a resume.
16:14:11 <Cale> Also, isn't there a windows scripting host you can use?
16:14:12 <monochrom> You can easily bootstrap your own Haskell interpreter that way.  (duck)
16:14:41 <shachaf> ddarius: Isn't there a vi in javascript? Would you be able to use that?
16:15:04 <monochrom> See what I started. HEE HEE HEE
16:18:15 <EvilTerran> huh.
16:20:08 <Cale> EvilTerran: Trying to understand what's going on may affect your parents' credit rating.
16:20:47 <SamB> Cale: what?
16:20:52 <EvilTerran> i wasn't referring to whatever's going on in here. i just had a minor epiphany regarding my current pet problem
16:22:24 <Cale> SamB: Just being silly :)
16:27:12 <ddarius> shachaf: I'm not sure.
16:27:25 <ddarius> Probably not as far as rules go.
16:27:51 <pjd> EvilTerran: now you're going to have to explicate
16:29:41 <EvilTerran> I'm fiddling with different ways of implementing a fn stripe :: [[a]] -> [a]; stripe xss = [xss !! i !! (n-i) | n <- [0..], i <- [0..n]]
16:30:38 <EvilTerran> (approximately)
16:31:11 <EvilTerran> this being a way of traversing the cartesian product of two lists in countable time even if one or both of the lists is infinite
16:31:46 <oerjan> well, i guess you know !! is usually to be avoided
16:31:56 <EvilTerran> yes, quite.
16:32:04 <EvilTerran> @paste
16:32:04 <lambdabot> Haskell pastebin: http://hpaste.org/new
16:32:48 <hpaste>  EvilTerran pasted "stripe" at http://hpaste.org/1780
16:32:55 <EvilTerran> that's what i've got ATM
16:33:44 <EvilTerran> but i'm trying to work out if there's any asymptotic complexity gains to be had, and if there's a nice way of expressing it with implicit recursion
16:35:53 <hpaste>  slowriot annotated "why isn't the inferred type a Vector2?" with "fixed" at http://hpaste.org/1762#a3
16:35:58 <slowriot> oops
16:36:02 <slowriot> I meant to uncheck announce
16:36:11 <slowriot> just pretend I didn't announce that
16:38:00 <monochrom> hehe
16:39:37 <Nafai> Interesting...SPJ called Haskell "useless" in an interview on Channel 9
16:40:05 <nominolo> huh?
16:40:56 <Nafai> http://channel9.msdn.com/showpost.aspx?postid=326762
16:40:58 <lambdabot> Title: Simon Peyton-Jones: Towards a Programming Language Nirvana
16:41:00 <EvilTerran> @pl \row stripes -> f row ([] : stripes)
16:41:01 <lambdabot> (. ([] :)) . f
16:41:42 <Nafai> Though he later recants and say that Haskell is improving :)
16:43:34 <DukeDave> Hey gang, I have a cryptic question: A long time ago in a book I can't recall there was an exercise I believe about shopping lists and a function which took an item,  e.g. "apple" and returned a price, e.g. 0.50, so getPrice :: String -> Double
16:43:35 <oerjan> f seems fairly close to zipWith (:)
16:43:58 <EvilTerran> oerjan, except i want the length to be that of the longer input, not the shorter one
16:44:14 <DukeDave> For getPrice there was a discussion of two implementations, one using lists and another using I think lambdas
16:44:28 <DukeDave> Can anyone suggest how the lambda version might work?
16:45:28 <shachaf> DukeDave: Lamdas? What do you mean?
16:45:32 <oerjan> DukeDave: giant case expression
16:45:37 <EvilTerran> well, using a function directly, you could say getPrice "apple" = 0.50; getPrice "ibm" = 0.35; etc
16:46:48 <DukeDave> I did warn it was cryptic :)
16:47:23 <monochrom> I don't see how lambda helps.
16:47:30 <DukeDave> My memory is very hazy unfortunately, but the upshot was you could keep 'adding' items to the list
16:47:55 <oerjan> EvilTerran: i mean that zipWith (:) would work for the case where the list actually is infinite in both dimensions
16:47:58 <DukeDave> With some function which took  the old function, and a new String/Float price
16:48:05 <EvilTerran> would getPrice actually be :: PriceList -> String -> Double, DukeDave?
16:48:17 <EvilTerran> oerjan, yes, but i'm trying to write something that works for finite _and_ infinite lists
16:48:27 <DukeDave> EvilTerran: Well that was one implementation, but they had another which worked differently
16:48:35 <DukeDave> The 'list' one was something ala:
16:48:50 <mauke> DukeDave: add :: String -> Double -> (String -> Double) -> (String -> Double)
16:49:05 <EvilTerran> (where you define PriceList to be an appropriate type, either [(List,Double)] or (String -> Double)
16:49:08 <mauke> add k v f = \x -> if x == k then v else f x
16:49:28 <EvilTerran> ...by the first i mean  [(String,Double)], obviously.
16:50:09 <DukeDave> > getPrice x xs = [price | (x, price) <- xs] [("apple", 0.50), ("pear", 0.40)] "apple"
16:50:09 <lambdabot>  Parse error
16:50:21 <DukeDave> > let getPrice x xs = [price | (x, price) <- xs] in [("apple", 0.50), ("pear", 0.40)] "apple"
16:50:22 <lambdabot>  Couldn't match expected type `t1 -> t' against inferred type `[a]'
16:50:28 <shachaf> > let extendGP s p o = \x -> if x == s then p else o x in extendGP "apple" 0.50 $ extendGP "pear" 0.25 $ extendGP "pair" 1.00 $ undefined
16:50:29 <lambdabot>  <[Char] -> Double>
16:50:30 <DukeDave> > let getPrice x xs = [price | (x, price) <- xs] in getPrice [("apple", 0.50), ("pear", 0.40)] "apple"
16:50:30 <lambdabot>  Couldn't match expected type `(t, t1)' against inferred type `Char'
16:50:40 * EvilTerran blinks
16:50:42 <shachaf> > let extendGP s p o = \x -> if x == s then p else o x in (extendGP "apple" 0.50 $ extendGP "pear" 0.25 $ extendGP "pair" 1.00 $ undefined) "apple"
16:50:43 <lambdabot>  0.5
16:50:50 <DukeDave> Ooh, mauke that looks like it might be it
16:51:48 <shachaf> DukeDave: Is that what you mean?
16:52:15 <EvilTerran> DukeDave, i think what you were trying to write there should be written "getPrice x xs = fromJust (lookup x xs)"
16:53:29 <DukeDave> EvilTerran: That is much nicer yes :)
16:53:38 <DukeDave> shachaf: Just processing :)
16:54:21 <shachaf> DukeDave: "s" -> "string", "p" -> "price", "o" -> "original", if that helps.
16:54:26 <EvilTerran> or, alternatively, head [price | (x', price) <- xs, x == x']. in what you wrote, the second "x" would merely replace the first, not check for equality
16:55:33 * edwardk waves hello.
16:56:21 <edwardk> I just realized you could auto-lift arithmetic, order and boolean operations over any applicative, not just over monads, since it only needs lift.
16:57:00 <edwardk> then ZipList would lift your operation to element by element in the same position, etc.
16:57:22 <mauke> oh, will we get instance (Applicative m, Num a) => Num (m a)?
16:57:37 <chessguy> hm, sounded to me like SPJ was referring to pre-monadic haskell when he called it "useless"
16:57:54 <EvilTerran> oerjan, it occurs to me i could do something horrible like "takeWhile isJust $ zipWith (liftM2 (:)) (map Just row ++ repeat Nothing) (map Just stripes ++ repeat Nothing)"
16:58:01 <edwardk> well, yeah for a more generalized form of Num. AddMonoid a, Applicative m, etc.
16:58:04 <Nafai> chessguy: Yeah...I made that comment before I had finished watching the video :)
16:58:07 <EvilTerran> (but not exactly that)
16:58:10 <chessguy> and even then only to make a point
16:58:22 <SamB> wasn't GHC originally written in pre-monadic Haskell?
16:58:49 <mauke> the important part is that (1 2 3) compiles
16:59:01 <Nafai> I don't really know Haskell or completely understand monads just yet and that sounds painful and impossible
16:59:07 <edwardk> mauke: heh
16:59:29 <dibblego> is there a good paper that clearly points out that destructive updates leads to non-decomposable software? I have my own methods of demonstrating this, but I'd like to see others
16:59:50 <slava> hey dibblego
16:59:56 <dibblego> hello slava
16:59:56 <nominolo> any work on semantics?
17:00:08 <SamB> dibblego: well, I can point you to the Python C API documentation...
17:00:23 <nominolo> contextual equivalence, etc
17:00:30 <dibblego> SamB, I think that would be preaching to the choir, or offending a religion; neither of which is the intention :)
17:00:45 <edwardk> mauke: i guess it would at that point, treating 1 as a doubled reader
17:00:55 <mauke> right!
17:01:03 <edwardk> though i think it does right now in my setting using the reader monad
17:01:07 <chessguy> @type let 1 = (+) in (1 2 3)
17:01:08 <SamB> dibblego: I meant, notice how the functions that return or accept objects all have rules about who ends up "owning" the object?
17:01:16 <lambdabot>     No instance for (Num (a -> a -> a))
17:01:16 <lambdabot>       arising from the literal `1' at <interactive>:1:4
17:01:30 <dibblego> SamB, I can see that, but it seems a lot of people cannot
17:01:36 <chessguy> > let 1 = (+) in 1 2 3
17:01:37 <lambdabot>   add an instance declaration for (Num (t -> t1 -> a))
17:01:37 <lambdabot>     In the expression:...
17:01:39 * EvilTerran would like a "zipAllWith :: (a -> b -> c) -> (a -> c) -> (b -> c) -> [a] -> [b] -> [c]", or somesuch.
17:01:50 <mauke> *Main> (1 2 3)
17:01:50 <mauke> 1
17:02:01 <chessguy> > (1 2 3)
17:02:01 <lambdabot>   add an instance declaration for (Num (t -> t1 -> a))
17:02:01 <lambdabot>     In the expression:...
17:02:05 <chessguy> ?
17:04:02 <edwardk> mauke: yep
17:04:21 <mauke> chessguy: instance (Num a, Monad m, Eq (m a), Show (m a)) => Num (m a) where
17:05:08 <edwardk> yeah, thats why i ts so much nicer when you break out the individual operations from Num, so you don't need a spurious Eq or Show instance.
17:05:34 <oerjan> chessguy: when you do 1 = ... you are not actually defining 1, you are only pattern matching against it
17:06:26 <edwardk> you have to define fromInteger to get 1 to do what you want, and -fno-implicit-prelude, or make a fake Num instance with it defined
17:08:27 <mwc> Hey, how can one pass arguments to GHC for a cabal package? I need to build everything with -pgmc=/usr/bin/gcc3
17:08:30 <oerjan> (in fact i think let 1 = ... is a runtime no-op)
17:08:48 <mwc> configure --help doesn't mention anything about respecting any env-vars
17:09:23 <mauke> adding the flag to ghc-options: is considered dirty, I guess
17:11:55 <mwc> mauke: yes, but I suppose it's the best way to do it for now eh?
17:12:10 <mauke> dunno
17:15:00 <Saizan> is there a way to build an app with ghc on debian and use it on freebsd? i get ELF interpreter /lib/ld-linux.so.2 not found\n Abort trap: 6
17:16:44 <SamB_XP> Saizan: well, apparantly your freebsd system is missing the ELF interpreter /lib/ld-linux.so.2
17:18:33 <Igloo> The normal Linux emulation stuff ought to work
17:18:39 <Saizan> yeah, not that i've a clear idea of what it is, some sort of shared lib? do you think that i can solve that without root privileges?
17:18:45 <Igloo> But you can't cross-compile to make a FBSD executable
17:18:52 <SamB_XP> Saizan: it's a loader
17:18:53 <mauke> it's the runtime loader
17:19:31 <Saizan> Igloo: so you mean that the linux emulation is broken on this machine?
17:19:43 <SamB_XP> Saizan: no.
17:19:50 <SamB_XP> it's just emulating a Linux machine that doesn't work
17:19:55 <SamB_XP> ;-P
17:19:59 <oerjan> Igloo: you're op'ed
17:20:00 <Saizan> :P
17:20:14 * Igloo knows nothing about Linux emulation on FBSD, other than that it exists
17:22:18 <wli> My basis functions are handing back garbage.
17:24:49 <dibblego> @join #jtiger
17:24:49 <lambdabot> Not enough privileges
17:24:52 <dibblego> get stuffed
17:26:26 <jsnx> Saizan: there's some trickiness with FreeBSD linux compatibility
17:26:44 <jsnx> for example, all the libs for linux are under /usr/compat/linux
17:27:11 <jsnx> (or ate least they were, over a year ago, when I still used FreeBSD)
17:27:23 <Saizan> ah, so i'd have to change /lib with  /usr/compat/linux ? and how?
17:27:49 <jsnx> Saizan: well, it should be done for you, using an ld aliasing command
17:28:04 <jsnx> that is specified in come config file I can't remember the path to
17:28:47 <jsnx> maybe /etc/ld.conf
17:29:49 <desp> @hoogle sleep
17:29:49 <Saizan> so if it doesn't work it's the configuration that's wrong?
17:29:49 <lambdabot> System.Win32.Process.sleep :: DWORD -> IO ()
17:29:53 <desp> @hoogle delay
17:29:54 <lambdabot> Control.Concurrent.threadDelay :: Int -> IO ()
17:29:54 <lambdabot> Network.Socket.NoDelay :: SocketOption
17:29:54 <lambdabot> System.Win32.File.mOVEFILE_DELAY_UNTIL_REBOOT :: MoveFileFlag
17:30:00 <jsnx> I'm pretty sure that's the case
17:30:09 <jsnx> just a sec, let me check the docs
17:30:14 <Saizan> thanks
17:32:30 <jsnx> Saizan: [ http://tinyurl.com/2n5j9x ]
17:32:32 <lambdabot> Title: linux
17:32:50 <jsnx> "it is com- mon to execute the following commands to prepare the system to correctly run Linux executables
17:32:54 <jsnx> "
17:34:06 <hpaste>  desp pasted "time difference" at http://hpaste.org/1781
17:34:15 <edwardk> @seen mnislaih
17:34:15 <lambdabot> I saw mnislaih leaving #haskell-blah, #oasis, #haskell and #ghc 53m 33s ago, and .
17:34:26 <Saizan> jsnx: where?
17:35:24 <Saizan> jsnx: ah, seen, thanks
17:36:59 <EvilTerran> @pl \x y -> [x,y]
17:36:59 <lambdabot> (. return) . (:)
17:37:24 <chessguy> http://wm.microsoft.com/ms/msdn/visualcsharp/anders_2007_01/Anders_0001.wmv
17:37:26 <lambdabot> http://tinyurl.com/2zmdle
17:37:35 <chessguy> is it just me or is he pretty much just talking about haskell?
17:37:56 <ddarius> chessguy: The C# people are very likely very aware of Haskell
17:38:07 <chessguy> ddarius, no doubt
17:38:19 <chessguy> i just don't see what LINQ has that haskell doesn't
17:38:35 <ddarius> A large userbase?
17:38:38 <EvilTerran> ?type intersperse
17:38:43 <lambdabot> forall a. a -> [a] -> [a]
17:38:50 <chessguy> really?
17:39:37 <Binkley> visual basic is a really popular programming language; if you can sneak in some Haskell-like features, that's a lot easier than convincing everyone to switch to Haskell :-)
17:40:04 <newsham> I think I started a haskell/purity/monads flame war on #oasis
17:40:06 <newsham> :)
17:40:50 <Nafai> What's #oasis for?
17:41:21 <Binkley> Nafai: originally it was for a particular ICFP contest team, now it's kind of random
17:41:32 <desp> Nafai: #hydration
17:41:34 <Nafai> Cool
17:41:34 <Binkley> or for random PL talk, anyway
17:41:39 <Nafai> Sounds fun!
17:41:54 <Binkley> It's not as busy as this channel :-)
17:41:57 <newsham> icfp starts in a few days
17:42:01 <newsham> so the topic is again icfp
17:42:12 <Nafai> Wish I could do icfp
17:42:13 <desp> in a few hours, actually
17:42:15 <Binkley> tomorrow, more precisely
17:44:10 <ddarius> Binkley: One last year?
17:44:28 <Binkley> ddarius: I think so
17:52:16 <jsnx> Saizan: any luck?
17:52:55 <Saizan> jsnx: no, no such file or directory.. i'm going to ask the admin tomorrow
17:54:11 <newsham> 9hrs and 6 min: http://www.kingsrook.com/icfp/countdown.html
17:59:10 <jsnx> Saizan: it's been a long time for me, honestly, I barely remember
17:59:14 <jsnx> Saizan: good luck!
18:00:24 <shapr> I wish I were on a team this year.
18:00:38 <Nafai> shapr: Next year!
18:00:42 <shapr> Yes, next year!
18:00:48 <Nafai> And maybe next year I'll know Haskell well enough to participate!
18:00:54 <newsham> no its fine, go hang out w/ your gf, shapr.
18:01:47 <shapr> newsham: Hey, she's a gorgeous blonde blue-eyed Swedish woman... code just can't compete...
18:01:52 <Binkley> while the rest of us hang out with our boyfriend, Haskell Curry
18:02:09 <newsham> no thats fine, we dont care.. :(
18:02:20 <Nafai> shapr: It's nice to see your priorities are in order :)
18:02:48 <shapr> Nafai: Heck yeah!
18:03:27 <dufflebunk> shapr: We don't believe you. We require pictures.
18:05:06 <dons> cool, another ONLamp article about haskell, http://programming.reddit.com/info/27ucu/comments
18:05:07 <lambdabot> Title: Introduction to Haskell, Part 2: Pure Functions (reddit.com)
18:06:46 <Binkley> "The $ operator is a little bit of syntactic sugar" -- :-(
18:07:31 <wli> The 1998 ICFP page is down.
18:07:43 <oerjan> well it is, except for being completely definable
18:07:44 <SamB> oh no
18:08:09 <Binkley> "syntactic sugar" usually refers to constructs that can't be defined in the language
18:08:11 <SamB> oerjan: syntactic sugar need not be a language construct
18:08:21 <SamB> Binkley: too
18:08:39 <Binkley> that's not how I usually see it used
18:08:59 <Binkley> well, maybe Ruby programmers use it differently
18:09:16 <Nafai> chessguy: Actually SPJ and Wadler actually wrote a paper on something LINQ has that Haskell currently doesn't: http://research.microsoft.com/Users/simonpj/papers/list-comp/index.htm
18:09:17 <SamB> probably because they can't define any?
18:09:18 <lambdabot> Title: Comprehensive Comprehensions, http://tinyurl.com/ysr3n8
18:09:42 * cpage dislikes the phrase "syntactic sugar", as it is often used with the implication that syntax is unimportant
18:09:47 <Nafai> He mentioned it in this interview: http://channel9.msdn.com/showpost.aspx?postid=326762
18:09:48 <lambdabot> Title: Simon Peyton-Jones: Towards a Programming Language Nirvana
18:10:04 <wli> What's LINQ?
18:11:06 <chessguy_> Nafai, interesting
18:11:13 <chessguy_> wli, http://wm.microsoft.com/ms/msdn/visualcsharp/anders_2007_01/Anders_0001.wmv
18:11:16 <lambdabot> http://tinyurl.com/2zmdle
18:11:45 <chessguy_> and http://msdn2.microsoft.com/en-us/netframework/aa904594.aspx
18:15:17 <Binkley> ?quote
18:15:17 <lambdabot> shapr says: You know what they say in Britain, no rest for the wicket.
18:18:03 <shapr> @quote Binkley
18:18:03 <lambdabot> Binkley says: I never metasuperhuman I didn't like
18:24:18 <ddarius> I poo on Comprehensive Comprehensions
18:25:00 <Binkley> harsh!
18:28:33 <dons> http://programming.reddit.com/info/27w79/comments
18:28:35 <lambdabot> Title: Parsing, CFGs, and Type Hacking (reddit.com)
18:29:09 <wli> Looks kind of blank.
18:29:43 <chessguy> dons, did you see the new SPJ video?
18:30:20 <chessguy> dons, this one: http://channel9.msdn.com/showpost.aspx?postid=326762
18:30:21 <lambdabot> Title: Simon Peyton-Jones: Towards a Programming Language Nirvana
18:30:26 <dons> ooh
18:30:40 <Nafai> Nice little short video
18:30:46 <ddarius> Yay short
18:31:05 <Nafai> I sure hope he's right about the Haskell moving up the usefulness continuum
18:31:42 <wli> dons: ooh, LR parser combinators?
18:32:21 <dons> ah, looks a bit like the slides he's giving at OSCON..
18:32:53 <wli> Kind of sad about OSCON. I'm right in town and won't be going to any of it.
18:33:25 <Nafai> dons: Do you know if that talk will be recorded?
18:34:22 <dons> yeah, it should be
18:34:31 <dons> get some upmods on ya! http://programming.reddit.com/info/27w8n/comments
18:34:32 <lambdabot> Title: Towards a Programming Language Nirvana : Simon Peyton-Jones [Video] (reddit.com)
18:35:21 <ddarius> What?  "Programming Language Nirvana" and "Simon Peyton-Jones" doesn't immediately command plenty of upmods?
18:35:44 <wli> I need to get wordpress (and esp. the LaTeX bit) working at some point.
18:36:10 <newsham> dons: i like the grammar syntax.
18:36:22 <newsham> what kinda of parse engine do you intend to build?
18:36:43 * wli scratches his parser combinator project as it would otherwise duplicate effort.
18:36:43 <dons> oh man, Hugh Perkins spamming our job offers on the mailing list now too :/
18:37:00 <dons> newsham: ?
18:37:12 <dons> that's cdsmith's article
18:37:40 <newsham> oh, cdsmith's article
18:37:40 <shapr> Any tips for gettin a Creative Zen music player talking to Linux?
18:37:48 <chessguy> wli, you mean triplicate? :)
18:37:59 <dibblego> someone should make a song about Perkins and Coppins
18:38:38 <wli> chessguy: Heck I don't know. I was just annoyed to no end with the left recursion nonsense.
18:39:58 <ddarius> dibblego: Why?
18:40:13 <dibblego> because it almost rhymes, that's why! and that's a good reason
18:40:52 <shapr> Verdict: don't get Creative Zen music players, they don't talk to Linux.
18:41:25 <newsham> heh "inferred execution" (linq video)
18:41:34 <newsham> MS just reinvented laziness
18:41:58 <dons> ok, i replied to Hugh personally, telling him not to spam the list with noise
18:42:40 <newsham> they make it sound like a huge innovation too
18:42:42 <ddarius> deferred
18:42:59 <ddarius> newsham: The host has a way with words.  A horrible way.
18:43:19 <ddarius> Later on they belatedly start saying, "Hey, I didn't invent this stuff!"
18:43:33 <dynamix> are you talking about MS ?
18:44:16 <dibblego> newsham, I recall when Java had invented this great concept too, and it worked for them; maybe they are learning from past lessons
18:44:25 <newsham> http://wm.microsoft.com/ms/msdn/visualcsharp/anders_2007_01/Anders_0001.wmv
18:44:27 <lambdabot> http://tinyurl.com/2zmdle
18:44:58 <newsham> its almost like coroutines never happened :)
18:45:51 <dibblego> who took #jtiger out of lambdabot's join list
18:45:52 <dibblego> ?
18:48:21 <dynamix> is there a haskell-quiz?
18:48:27 <dynamix> like ruby-quiz?
18:48:58 <dynamix> http://www.rubyquiz.com/
18:48:59 <lambdabot> Title: Ruby Quiz
18:50:37 <dons> yeah, on haskell.org
18:50:39 <dons> search for 'Quiz'
18:50:44 <dons> ?go Haskell Quiz
18:50:46 <lambdabot> http://www.haskell.org/haskellwiki/Haskell_Quiz
18:50:46 <lambdabot> Title: Haskell Quiz - HaskellWiki
18:53:29 <dynamix> cool
18:53:53 <dynamix> dons, what is a good way to practice eta reduction?
18:57:58 <sgillespie> hello
18:59:06 <sgillespie> how can I do a calculation, throw it away and return nothing?
18:59:06 <monochrom> Like (\x -> f x) = f ?
18:59:31 <ddarius> "practice eta reduction" ?
18:59:54 <ddarius> sgillespie: computation `seq` Nothing
19:00:06 <sgillespie> awesome
19:00:26 <monochrom> Perhaps "nothing" means ()
19:01:09 <ddarius> Perhaps nothing means undefined.
19:01:35 <shapr> hiya sgillespie
19:01:43 <araujo> hello
19:02:06 <shapr> Hey, I'm going to the panhandle of Florida this weekend, south of Alabama...  Any #haskellers in that area?
19:02:38 <mwc> I thought Texas had the pan handle
19:02:46 <ddarius> Damn, shapr you're in Alabama right now?
19:02:52 <shapr> Yeah, why?
19:03:01 <shapr> Are you nearby?
19:03:09 <ddarius> I may have reasons to go to Alabama in the not distant future.
19:03:16 <shapr> Near Birmingham?
19:03:33 <ddarius> However, I'd probably be too... distracted to meet up with you.
19:03:40 <sgillespie> shapr: I'm on the other side
19:03:42 <sgillespie> jax
19:03:49 <ddarius> If Birmingham is near Montgomery which I doubt.
19:04:02 <newsham> "who are you sir?" "butler lampson"
19:04:02 <shapr> Montgomery is about an hour southeast of Birmingham.
19:04:12 <newsham> how insulting.. you dont ask lampson who he is :)
19:04:34 <dons> shapr: did you ever get hsakell on your nokia?
19:04:38 <ddarius> About a hundred miles away.
19:05:01 <shapr> ddarius: If you'll be there over a weekend I'll visit.
19:05:13 <shapr> dons: No, got distracted. stepcut got most of the way into that though.
19:05:53 <shapr> dons: Just requires compilation, no serious hacking required. I have a "state of ghc 6.5 on N770" email from stepcut if you want me to forward it.
19:06:55 <shapr> ddarius: I'll bring my unicycle and get pix of you riding it :-)
19:06:58 <monochrom> Is N770 a cell phone?
19:07:11 <shapr> Then I'll add you to the #haskell gallery of functional programmers riding unicycles on Facebook.
19:07:29 <ddarius> Oh joy.  I've never ridden a unicycle.
19:07:31 <shapr> monochrom: Nah, it's an internet tablet... totally different profile.
19:11:00 <gravity> I love my 770, but I have no idea what I'd do with haskell on it
19:12:22 <ddarius> God damn I've been here long.
19:12:54 <monochrom> Me too.
19:13:25 <araujo> shapr, got ghc working on the n770?
19:14:40 <sgillespie> i find that if i do something like this...
19:14:44 <sgillespie> (evalExp ast) `seq` return ()
19:14:52 <sgillespie> the first is not run
19:15:05 <monochrom> It depends on context.
19:15:35 <dolio> It will only be run if the 'return ()' is used for something.
19:15:35 <sgillespie> I obviously don't understand what I'm doing :(
19:15:59 <monochrom> self-contained, reproducible experiment to show your observation plz
19:16:04 <ddarius> Maybe you wanted (>>)
19:17:52 <sgillespie> >> does seem to be what I wanted
19:18:00 <sgillespie> but lets say I have
19:18:12 <ddarius> "calculating" triggers "expression" in my mind.
19:18:21 <sgillespie> (evalExp ast) >> return ()
19:18:25 <sgillespie> and...
19:18:35 <sgillespie> evalExp :: Exp -> Either Int (IO ())
19:18:51 <sgillespie> then I get...
19:18:54 <sgillespie> Couldn't match expected type `IO a' against inferred type `Either Int (IO ())'
19:19:15 <newsham> what do you want to happen?  run the IO when its returned?
19:19:19 <ddarius> Presumably you want to execute the return IO action (when one is returned)?
19:20:12 <monochrom> Hate to ask the universally applicable question, but what are you doing?
19:20:17 <sgillespie> http://rafb.net/p/Oo2aT591.html
19:20:18 <lambdabot> Title: Nopaste - src/ScEval.hs
19:20:19 <newsham> case evalExp ast of (Left x) -> printf "error %d!" x; (Right act) -> act    ?
19:20:43 <sgillespie> Its supposed to evaluate a very simple AST
19:21:11 <newsham> it doesnt really 'evaluate' it, it returns the action or an int
19:21:32 <ddarius> either (printf "error %d!") id $ evalExp ast -- yay confusing newbies!
19:21:34 * wli grinds out an O(n!) non-monadic brute-force n-queens at the ghci prompt.
19:21:49 <monochrom> I think "Either Int (IO ())" is a bad idea. It's over-complicating.
19:22:08 <newsham> hmm.. it seems like your Left is an integer value (of evaluation) and your Right is a print statement
19:22:14 <newsham> yah overly complicated.
19:22:44 <newsham> but you could use the case liek above (except its not "error %d" its just print x)
19:23:23 <oerjan> also, make the ; a |
19:23:28 <newsham> here's what I would do if I was writing this.  take Print out of Exp.  make another data type Stmt and Print Exp being a statement
19:23:35 <ddarius> That makes things simpler, either print id $ evalExp ast
19:23:35 <oerjan> er wait
19:23:40 <oerjan> (ignore me)
19:24:04 <newsham> then have an evalExpr that returns an Int, and a runStmt which is IO
19:24:16 <sgillespie> ahh, interesting
19:24:18 <sgillespie> sounds much better
19:24:37 <ddarius> That statically keeps you from writing things like Plus (Print 3) 4
19:24:57 <newsham> you can also write these directly (without a case) as   evalExp (Plus x y) = ....
19:25:06 <newsham> evalExp (Minux x y) = ....
19:25:47 <monochrom> I have a way to keep "Print Exp" where it already is. But evalProg's type should be [Exp] -> IO Int, and evalExp's type should be Exp -> IO Int
19:26:57 <sgillespie> that was my initial thought, but i thought it seemed kinda messy
19:27:18 <wli> Is it 92 solutions for n = 8, and 724 solutions for n = 10?
19:27:23 <ddarius> newsham's approach seems like the best.
19:27:29 <sgillespie> indeed
19:27:35 <newsham> or you could make Print Exp return IO Int and have evalExp always be IO Int
19:27:49 <newsham> (ie. print prints and returns the value)
19:27:58 <ddarius> Like trace
19:28:07 <monochrom> evalExp (Print x) = do { y <- evalExp x; print y; return y }
19:28:16 <monochrom> evalExp (Int x) = return x
19:28:17 <monochrom> etc.
19:29:12 <wli> It's a lot more obvious to me how to write it in Prolog than in a nondeterminism monad.
19:29:36 <ddarius> Well if I'd get off my lazy ass, you could have the best of both worlds.
19:30:55 <ddarius> I have an implementation of a monad that gives you Prolog style logic vars and an implementation of a pure subset of Prolog in that.
19:30:55 <newsham> lazy bottom?
19:31:07 <SamB> ddarius: are you on the team then?
19:31:23 <ddarius> SamB: What?
19:31:38 <newsham> the lazy bottoms?
19:31:49 <wli> ddarius: Well, that would be great if I could figure out how to use the monads in the first place.
19:32:20 <ddarius> newsham, SamB: That would be far too productive.
19:32:36 <SamB> ddarius: but you said you had a lazy ass
19:32:42 <SamB> so you should be on the team!
19:32:59 <ddarius> !paste
19:32:59 <hpaste> Haskell paste bin: http://hpaste.org/
19:33:32 * ddarius wishes his Mic In was at least 44100 hz.
19:38:44 <hpaste>  ddarius pasted "not prolog fun" at http://hpaste.org/1782
19:42:57 <wli> heh
19:43:23 <desp> ddarius: interesting
19:43:38 <chessguy> @type free
19:43:40 <lambdabot> Not in scope: `free'
19:45:56 <gravity> There's surprisingly little documentation on dealing with exceptions
19:46:30 <ddarius> In Haskell98 there are IOErrors and there are exceptions.  There is nothing you can do about exceptions.
19:46:40 <ddarius> In GHC there is more that you can do.
19:46:42 <SamB> ddarius: I didn't know Haskell 98 had exceptions
19:46:48 <SamB> I thought it had _|_s
19:47:54 <magnus__> @hoogle a->(a->Bool)->(a->Bool)->Bool
19:47:55 <lambdabot> No matches, try a more general search
19:48:33 <magnus__> @pl \x f g -> f x && g x
19:48:33 <lambdabot> ap (flip . (((.) . (&&)) .) . flip id) (flip id)
19:48:38 <magnus__> yuck
19:48:59 <chessguy> @pl \x -> f x && g x
19:49:00 <lambdabot> liftM2 (&&) f g
19:49:13 <magnus__> cool
19:49:20 <chessguy> @bot
19:49:20 <lambdabot> :)
19:49:21 <mwc> SamB: there are exceptions in monads, specicially the IO one
19:49:32 <mwc> SamB: it's kinda hard to do exceptions right in a lazy language
19:49:33 * ddarius doesn't know why he didn't use exists rather than free >>=
19:49:59 <wli> Exceptions suck bigtime.
19:50:34 <wli> You can't really narrow down where they came from unless you're doing everything in the IO monad to begin with.
19:51:55 <shapr> ddarius: Why did you say you've been here long?
19:52:00 <shapr> aww
19:52:05 <mwc> wli: I was just thinking about that
19:52:19 <shapr> ddarius: wah!
19:53:17 <shapr> ddarius: Why did you say you've been here long?
19:54:29 <jsnx> does haskell work on vista?
19:54:42 <shachaf> jsnx: Haskell?
19:54:47 <jsnx> ghc
19:54:54 <jsnx> that's what i meant
19:54:55 <shachaf> jsnx: Oh.
19:54:58 <SamB> it should!
19:55:05 <SamB> if it doesn't SPJ is in trouble, eh?
19:55:08 <shachaf> jsnx: I think it had some problems, but generally worked.
19:55:15 <shachaf> @google ghc vista
19:55:17 <lambdabot> http://www.highlands.edu/irc/webtools/Vista2.htm
19:55:17 <lambdabot> Title: Vista
19:55:38 <Binkley> jsnx: yes, it works
19:55:49 <jsnx> Binkley: you've tried it?
19:55:58 <Binkley> jsnx: no, but I read the mailing lists
19:56:42 <jsnx> Binkley: oh, okay
19:59:06 <timthelion> um, how does one use Data.Tree?
19:59:36 <ddarius> shapr: I've known you since 2002
20:00:03 * ddarius doesn't like Data.Tree
20:00:11 <ddarius> But what is your question?
20:00:59 <timthelion> well, if I have a Tree, how do I get a list of the roots children?
20:01:08 <ddarius> children
20:01:16 <ddarius> @src Data.Tree.Tree
20:01:16 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
20:01:23 <timthelion> I didn't see any usefull functions in haddoc
20:01:26 <ddarius> I knew that that wouldn't work.
20:01:34 <ddarius> Look at the definition of Tree.
20:01:36 <sjanssen_> @src Tree
20:01:37 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
20:01:40 <ddarius> @docs Data.Tree
20:01:41 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Tree.html
20:01:54 <ddarius> subForest there we go
20:02:45 <ddarius> Wow.  Data.Tree is useless for more reasons than I thought.
20:03:00 <SamB> ddarius: is it now?
20:03:10 <ddarius> Yes.
20:03:15 <SamB> I think it just isn't useful unless you want exactly that kind of tree
20:03:17 <wli> ddarius: Hmm, the cited Prolog code is not quite how I'd do it in Prolog.
20:03:32 <wli> ddarius: SWI Prolog seems to give wrong answers for it.
20:04:35 <timthelion> well, how do I find out if an element of subforest, is a node or a tree?
20:04:59 <ddarius> timthelion: They're all trees
20:05:12 <ddarius> But a leaf is Node Whatever []
20:05:19 <timthelion> so it's the end of the line when subforest is null
20:06:21 <timthelion> why didn't they do a list like [Foo] where data Foo = Node a | Tree b [Foo] ?
20:06:38 <timthelion> or am I confused about how datatypes work?
20:08:00 <sjanssen> timthelion: that isn't quite valid
20:08:07 <sjanssen> timthelion: 'a' and 'b' have to come from somewhere
20:08:22 <timthelion> sjanssen: what do you mean?
20:08:31 <SamB> ddarius: what would you prefer?
20:08:39 <sjanssen> timthelion: a and b are type variables, but they're not coming from anywhere
20:08:53 <sjanssen> timthelion: data Foo a b = Node a | Tree b [Foo a b] -- is okay
20:09:02 <timthelion> sjanssen: ah, yes, I see
20:09:30 <timthelion> sjanssen: could you do data Tree a b = Node a | Tree b [Tree a b]?
20:09:35 <ddarius> SamB: To start, an empty case.
20:09:46 <ddarius> Some more functions would probably also be nice.
20:09:57 <sjanssen> timthelion: yeah, that's okay because type names and constructor names occupy a different namespace
20:10:15 <SamB> oh, hey
20:10:24 <SamB> that Tree is just like the one I keep defining
20:11:17 <sjanssen> timthelion: your definition is quite different from Data.Tree
20:11:37 <sjanssen> timthelion: your type stores one type of data at the leaves, and another type in the internal nodes
20:11:42 <timthelion> sjanssen: yes it is, but it seems more obvios
20:11:57 <sjanssen> timthelion: why is it more obvious?
20:12:09 <timthelion> sjanssen: then could I have Tree a [Tree]
20:12:14 <timthelion> sjanssen: I don't know
20:13:10 <timthelion> sjanssen: unless subForest is a name everyone who has taken a data structures class knows, it seems like a terrible choice
20:13:34 <sjanssen> timthelion: you aren't required to use subForest
20:13:42 <sjanssen> you can always pattern match against it directly
20:13:59 <sjanssen> case someTree of (Tree x ts) -> stuff with x and ts ....
20:14:38 <sjanssen> timthelion: subForest is a bit of awkward name, 'children' would be nicer IMO
20:14:58 <dons> http://img264.imageshack.us/img264/1397/lispnd7.png
20:15:04 <dons> i think we could do a cute one of that for haskell
20:15:16 <timthelion> and also, in Data.Tree, I don't see where Forest is defined, I mean, to me, Tree looks like a tuple that contains one element of type a which is gotten with rootLabel and another of type a which is gotten with subForest
20:15:16 <dons> about how people just see "white space" with nothing to hang their eyes on
20:15:28 <dons> and maybe, what the haskeller sees, with clear, obvious blocks
20:15:28 <ddarius> wli: It seems to work in my Prolog interpreter (it produces powersets not powerlists), and the algorithm is going for simplicity.  It's just an example to compare to the Haskell.
20:15:44 <wli> ddarius: Which interpreter?
20:15:55 <mwc> dons: be sure to use >>=, that's the most intimidating operator of them all
20:15:59 <ddarius> wli: The one I implemented with that library.
20:16:10 <Binkley> dons: or you could have some monadic code with a picture of a warm, fuzzy thing for what the Haskeller sees :-)
20:16:14 <wli> Okay.
20:16:26 <ddarius> timthelion: It's a type synonym, type Forest a = [Tree a]
20:16:27 <mrd> hey dons, are you still interested in that presentation DSL you proposed?
20:16:29 <dolio> That lisp is kind of hard to read with all the parens removed.
20:16:30 <dons> Binkley: heh
20:16:34 <ddarius> mrd: Yes.
20:16:43 <dons> mrd, oh, you mean the one for beamer?
20:16:46 <mrd> yea
20:16:47 <dons> yes, very.
20:17:14 <mrd> i was doodling some ideas earlier, if you wanted to comment
20:17:33 <timthelion> ddarius: that seems to be outsourcing the info I need to gleem an instant understanding of Tree
20:17:41 <dons> bit busy today, but if you send me a link / email
20:17:58 <ddarius> timthelion: I don't like Data.Tree
20:18:02 <timthelion> what I have decided to use is >data DatedDirectory = FilePath [DatedDirectory] [DatedFile] >data DatedFile = FilePath ClockTime
20:18:02 <timthelion>  
20:18:35 <ddarius> timthelion: Except the compiler will yell at you for that.
20:18:35 <sjanssen> timthelion: that definition isn't valid
20:18:35 <mrd> does unsw email still work
20:18:45 <timthelion> because that way, I can search my subdirs and be less than n in a child search
20:18:57 <timthelion> really?
20:19:10 <ddarius> You can't reuse constructor names.
20:19:19 <sjanssen> timthelion: you're making two 'FilePath' constructors
20:19:26 <shachaf> timthelion: Try data DatedDirectory = DD ...
20:19:36 <sjanssen> you probably mean to have FilePath be a component in the data type, not the constructor name
20:19:39 <shachaf> timthelion: You need a constructor.
20:19:41 <ddarius> Or you are missing constructor names.
20:19:52 <timthelion> then I am confused
20:19:55 <timthelion> FilePath is a type
20:19:55 * ddarius thinks the latter.
20:19:56 <dons> mrd, yep.
20:20:11 <sjanssen> timthelion: yeah, but the syntax doesn't want a type there, it wants a constructor name
20:20:20 <shachaf> data DatedDirectory = DatedDirectory FilePath [DateDirectory] [DatedFile]
20:20:29 <timthelion> oh, OK
20:20:31 <ddarius> Also use newtype.
20:20:39 <timthelion> why?
20:20:51 <mrd> actually, you can just save this url: http://mapcar.org/~mrd/HasPoint.hs
20:20:58 <sjanssen> timthelion can't use a newtype here
20:21:05 <sjanssen> because there are two components to the type
20:21:10 <timthelion> ok,
20:21:25 <shachaf> And also because it is recursive.
20:21:29 <ddarius> Er ignore that last part.
20:21:33 <sjanssen> timthelion: newtype is just an optimization that you don't need to worry about right now
20:21:39 <sjanssen> shachaf: recursive newtypes are okay
20:21:50 <shachaf> sjanssen: They are?
20:21:57 <shachaf> sjanssen: Oh, I didn't know that. :-)
20:22:08 <timthelion> sjanssen: do you realise how baffling all this syntactic bureaucracy is?
20:22:29 <sjanssen> timthelion: I don't think it's all that baffling :)
20:22:32 <shachaf> data Dated = DFile ClockTime | DDir [Dated] -- ?
20:22:34 <sjanssen> timthelion: how are you learning Haskell?
20:22:56 <shachaf> timthelion: This isn't syntactic.
20:23:10 <timthelion> sjanssen: well, I read 2 chapters of YAHT, decided that the book wasn't really worth reading. then I started hacking
20:23:28 <ddarius> I don't think it's syntactic bureaucracy.
20:23:46 <monochrom> Haha syntactic bureaucracy. Great term.
20:23:49 <sjanssen> timthelion: what was wrong with YAHT?  If it was too slow, you might try the gentle intro
20:24:09 * ddarius likes the Gentle Intro.
20:24:28 <sjanssen> timthelion: a good tutorial should put you on more solid ground with these fundies
20:25:00 <sjanssen> ddarius: me too.  That's how I learned
20:25:09 <sjanssen> it really shouldn't be called "gentle" though :)
20:25:27 <SamB> "brutal" then?
20:25:28 <timthelion> the problem with YAHT is that it spends a lot of time on concepts, and then tells you to go write something bassed on those concepts, when it hasn't really told you how to write the syntax, and then you spend your time strugling with ghci and its (to-a-newby-unhelpfull) errors
20:25:38 <mrd> it's gentle if you are familiar with fp =)
20:25:42 <monochrom> "brutal", "boot camp"
20:25:52 <shachaf> One tutorial is never enough for me. I always read bits and pieces from different ones.
20:26:01 <mrd> the sadomasochistic approach to haskell?
20:26:02 <monochrom> The boot camp worked for me.
20:26:26 <ddarius> The Gentle Intro was nothing like boot camp.
20:26:27 <SamB> I think I may have used "a gentle introduction", but I can't remember!
20:26:32 <monochrom> Then, for monads, I went ahead to Wadler's papers and eventually Moggi's papers.
20:26:50 <SamB> I'm sure I read a lot of papers though
20:27:02 <SamB> now I'm like an addict or something
20:27:07 <monochrom> Moggi's papers worked for me.
20:27:25 <ddarius> SamB: Yeah... that happens.
20:27:26 <monochrom> If you don't read a paper for a day, you'll start sniffing? :)
20:27:32 <SamB> not exactly
20:27:39 <shachaf> I didn't really like the bits of YAHT that I read, though. It treats IO and do-notation as too "magical", in my opinion.
20:27:54 <ddarius> monochrom: You start reading papers on how to make full-text databases to store your papers.
20:28:06 <dons> oooh....Meijer_Peyton-Jones_Language_MSRCam2007.wmv
20:28:10 <dons> grr. wrong link
20:28:14 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HsOpenSSL-0.1
20:28:18 <lambdabot> http://tinyurl.com/2xwetd
20:28:20 <dons> a new openssl binding
20:28:35 <wli> I've not exactly focused on Haskell, but it's been about 10 years since I picked up the ML subset thereof and I've still not figured out monads. Pass the dunce cap my way.
20:28:41 <monochrom> Anyway, there are many choices. http://en.wikibooks.org/wiki/Haskell is worth trying.
20:28:43 <lambdabot> Title: Haskell - Wikibooks, collection of open-content textbooks
20:28:52 <ddarius> monads are almost within the ML subset of Haskell
20:29:02 <ddarius> Haskell is almost an ML subset.
20:29:31 <wli> No idea what to tell you. I never wrote monadic anything in Standard ML.
20:29:37 <wli> Or OCaml for that matter.
20:30:04 <ddarius> You've probably written things in Haskell that you haven't in ML.  Monads are not special.
20:30:38 <Shimei> I've read ML programmers talking about using monads, but then I think "But I've never seen any standard libraries related to monads at all!"
20:30:43 <dons> if you ever threaded a bunch of state around an ML program, you could have used a monad to avoid that.
20:30:52 <SamB> ddarius: how long do you wager it will be before he figures out there isn't anything to figure out?
20:30:59 <wli> The only thing that seems to make them special is that I can't seem to figure them out.
20:31:14 <dons> the problem is the missing do-notation, and overloaded >>= operator in ML
20:31:32 <shachaf> wli: What can't you figure out about them? Is it the general concept, or specific ones?
20:31:38 <wli> SamB: It's been long enough. I'll probably die having never made effective use of them.
20:31:40 <ddarius> Yeah, the lack of typeclasses is the big issue that makes it only "almost" in the ML subset.
20:31:46 <mrd> frankly, i don't know how people get by without typeclasses
20:31:48 <ddarius> Do-notation isn't that big a deal.
20:31:51 <wli> shachaf: It seems to be that I'm not able to use them effectively.
20:32:03 <SamB> wli: what do you know about monads?
20:32:13 <wli> shachaf: I have no idea what specifically to ask about any of it.
20:32:18 <shachaf> wli: Have you used Reader/State?
20:32:26 <mrd> it's just a way to pass information implicitly
20:32:35 <wli> shachaf: Mostly state, though awkwardly.
20:32:56 * ddarius thinks it's time for him to walk away and read his book.
20:33:01 <wli> I've got this idea about implicit arguments somewhere floating around.
20:33:16 <shachaf> wli: Try reimplementing Reader or State.
20:33:19 <SamB> I never learned ML and I've probably been using Haskell for about four years?
20:33:35 * shachaf did that today for the first time.
20:33:36 <mrd> for example, with IO, it used to be that was done by making main :: [Input] -> [Output].  but then you have to pass Input everywhere and collect Output from everywhere.  Monads just abastract away that annoyance by hiding the details of passing the input and collecting the output.
20:33:40 * SamB waits for someone to correct him
20:33:44 <shachaf> It was shorter than I though. :-)
20:33:48 <SamB> but I've no trouble with monads
20:33:49 <shachaf> s/\./t./
20:33:51 <monochrom> The last chapters of "ML for the working programmer" by Lawrence Paulson are full of monads. They contain a theorem prover (or checker) project. Thus, there are parser combinators, and you can see who is >>= there. Then, there are substitution combinators, and you who is >>= there.
20:34:22 <timthelion> now in haskell 98 we have all the funky IO monady stuff already? or is 98 old?
20:34:23 <sjanssen> monochrom: does the author point out the monadic structure?
20:34:26 <dblhelix> morning #haskell!
20:34:27 <monochrom> No.
20:34:32 <dblhelix> 6.5 hours to go :-)
20:34:35 <wli> monochrom: I have that book readily at hand.
20:34:43 <SamB> timthelion: the IO monad is older than Haskell 98
20:34:53 <Shimei> I think my ML problem stems from picking up "Practical OCaml" and subsequently selling it rather than reading a classic. :\
20:34:54 <SamB> We had it for at least the previous version of Haskell as well
20:34:55 <ddarius> mrd: That perspective completely falls apart for Maybe, [], Either e and others.
20:35:01 <SamB> though I wasn't around back then
20:35:15 <timthelion> SamB: then why is it still treated as this newfangled weird thing that is talked about in mathematics papers?
20:35:21 <dons> so any last teams that need to form for ICFP?http://haskell.org/haskellwiki/ICFP_Programming_Contest/Teams_2007
20:35:23 <lambdabot> Title: ICFP Programming Contest/Teams 2007 - HaskellWiki, http://tinyurl.com/3dx5mv
20:35:27 * ddarius thinks his ML problem stemmed from being blinded by some source code.
20:35:37 <SamB> timthelion: who treats it that way?
20:36:01 <timthelion> SamB: well, most people onhere say they don't get it yet
20:36:01 <ddarius> No mathematician talks about the IO monad.
20:36:03 <mrd> ddarius: not really.  if you're working in Maybe, you would normally have to take care of wrapping and unwrapping (case statements galore) Maybe values.  the monad hides all that nonsense.
20:36:04 <dblhelix> me and my team are ready for it!
20:36:18 <dons> sjanssen: we'll have to have a go at ICFP one of these days :)
20:36:33 <wli> monochrom: Oh dear. I'm sure it's there, but interpreting it that way is probably more difficult than the basic exercises or whatever I need to do.
20:36:35 <sjanssen> dons: yeah, that'd be fun
20:36:46 <sjanssen> I'm moving during ICFP this year
20:36:48 <ddarius> mrd: There is no information being passed implicitly.
20:36:49 <dino-> @seen msouth
20:36:50 <lambdabot> msouth is in #happs and #haskell. I last heard msouth speak 2h 10m 50s ago.
20:36:51 <SamB> dons: I'm planning to try after the contest is over, if I like the problem ;-)
20:36:59 <mrd> lambdabot is leading a team?
20:37:00 <dons> heh, good plan, SamB
20:37:05 <mrd> that's the winner
20:37:15 <SamB> that's what I did last year
20:37:16 <mrd> @pl win icfp2007
20:37:16 <lambdabot> win icfp2007
20:37:17 <Binkley> @solve-icfp-contest-problem
20:37:17 <lambdabot> Unknown command, try @list
20:37:19 <Binkley> Darn.
20:37:22 <SamB> I still have more work to do if I want to win!
20:37:25 <Shimei> dons: I am defecting to the #nethack crowd for the duration of the ICFP. :p
20:37:40 * SamB is assuming that "winning" means gaining root
20:37:46 <dons> Shimei: boo!
20:37:50 <mrd> people want 5 people on a team? seems a bit large.
20:38:00 <Binkley> SamB: that would be last year's problem :-)
20:38:05 <SamB> Binkley: yes
20:38:10 <Binkley> mrd: 5 wouldn't have been too many for the problem last year
20:38:12 <SamB> Binkley: as I said, I still need to win that game
20:38:18 <ddarius> If you get root on the right machine...
20:38:21 <Binkley> SamB: you could spend a lifetime working on that game
20:38:23 <Binkley> well, ok, I could
20:38:36 <SamB> I'd probably do better now that I have more RAM
20:39:00 <timthelion> are the problems data intensive?
20:39:02 <Binkley> Bah. When I was starting out we had 64 KB of RAM and we had to toggle it ourselves with a penlight.
20:39:12 <mrd> icfp contest starts at 6am my time, which means i won't see the problem for +6hrs after it starts :(
20:39:12 <Binkley> timthelion: are there problems that aren't?
20:39:19 <SamB> timthelion: advent is a real RAM whore
20:39:25 <sjanssen> timthelion: last year's problem required a lot of system power at times
20:39:36 <SamB> among other things
20:39:38 <timthelion> sjanssen: hmm,  so did sun win?
20:39:54 <SamB> timthelion: what? sun microsystems wasn't competing
20:39:58 <SamB> I believe Google won
20:40:00 <timthelion> oh
20:40:10 <sjanssen> well, guys who work at Google
20:40:23 <Binkley> now if all of Google formed an ICFP contest team, that would be a sight
20:40:23 <dons> ?remember Binkley Bah. When I was starting out we had 64 KB of RAM and we had to toggle it ourselves with a penlight.
20:40:24 <lambdabot> Done.
20:40:24 <mrd> hm, NITWIT sounds like a good team for me
20:40:25 <SamB> they nominated 2d as their language of choice
20:40:28 <sjanssen> timthelion: well, the contest wasn't really about intensive data crunching
20:41:01 <sjanssen> timthelion: it centered around running an OS on an emulator you've written -- some of the programs in the OS take lots of system resources
20:41:22 <sjanssen> timthelion: partly because of the strange architecture of the emulated machine
20:41:28 <Binkley> yeah, our team wrote an emulator in Haskell and one in C and we ended up having to use the C emulator :-(
20:41:30 <ddarius> Bah, make a native code compiler for it!
20:41:30 <timthelion> sjanssen: hmm, that sounds hard.
20:41:53 <SamB> timthelion: it was a damn simple architecture
20:42:07 <SamB> I'm surprised they didn't make you write any code for it though
20:42:14 <SamB> since that would be a total PITA
20:42:21 <SamB> it has wierd instructions
20:42:29 <sjanssen> timthelion: you might take a look at last year's contest -- it was loads of fun
20:42:39 <SamB> yes, you can still "register"
20:42:40 <timthelion> ok
20:42:44 <SamB> or rather again
20:42:46 <dblhelix> Binkley: same for out team
20:42:57 <dblhelix> /s/out/our
20:43:06 <sjanssen> SamB: meh, all the FP hackers would write compilers targeting the UM
20:43:07 <timthelion> I doubt I'd win writting in elisp if it's data-intenisive
20:43:10 <SamB> that was one of the few things I accomplished before last year's deadline
20:43:19 <sjanssen> ICFP winners eat compilers for breakfast
20:43:23 <SamB> though admittedly I was out of the house a fair amount of last year's contest
20:43:59 <SamB> sjanssen: but it would be much more productive to target RML or o'cult
20:44:01 <timthelion> wait, would winning get me into caltech?
20:44:03 <SamB> or 2d
20:44:11 <Binkley> timthelion: no
20:44:17 <timthelion> darn
20:44:25 <SamB> Binkley: are you sure?
20:44:27 <Binkley> :-)
20:44:35 <sjanssen> I'm sure it'd look good on an application
20:44:37 <SamB> has anyone tried that tack before?
20:44:45 <edwardk> last year's contest rocked
20:44:47 <Binkley> SamB: programming contest winners are a dime a dozen for a place like Caltech
20:44:49 <dynamix> sorry i had left for dinner. eta reduction , is like you say remove unnecessary params
20:45:00 <Binkley> and unless you got lucky, admissions people wouldn't realize that the ICFP contest was special
20:45:01 <jfredett> Category theory is awesome.
20:45:03 <sjanssen> edwardk: yeah, let's hope this year's is at least half as good
20:45:05 <SamB> Binkley: what other programming contests are there?
20:45:17 <ddarius> jfredett: Yes it is.
20:45:17 <Binkley> SamB: well, there's the ACM competition, though that's usually for undergrads
20:45:25 <Binkley> I'm sure there are crappy contests for high school students
20:45:27 <edwardk> i'm debating about trying to compete this year, or trying to actually get something done over the long weekend.
20:45:33 <SamB> never really heard of the ACM one
20:45:40 <Binkley> SamB: it's pretty established
20:45:47 <Binkley> but it's not nearly as fun as the ICFP contest!
20:45:49 <jfredett> ACM competition sucks ass. :/
20:45:51 <SamB> well, okay, it seems kinda boring sounding
20:45:54 <Binkley> yeah
20:45:55 <jfredett> they wouldn't let me use lisp
20:45:55 <edwardk> yeah i don't think i was ever eligible to compete in the ACM one.
20:46:01 <monochrom> "internet problem solving contest". programming optional.
20:46:02 <brad_> in ghci, if i invoke many modules with :m, the cursor goes waaaay over to the right, any way to mitigate this?
20:46:02 <SamB> just because it says "ACM" in the name it sounds boring
20:46:03 <Binkley> when I did it you could only use Java, C or Pascal
20:46:04 * sjanssen is still considering entering the lightning round and then moving to a new apartment a few hours after that is over
20:46:07 <timthelion> jfredett: wtf?
20:46:12 <jfredett> and they certainly wouldn't let me use Haskell.
20:46:27 <jfredett> its Java, C, C++ now
20:46:30 <SamB> jfredett: what in the world are they afraid of?
20:46:34 <Binkley> ?remember SamB [on the ACM programming contest:] just because it says "ACM" in the name it sounds boring
20:46:34 <lambdabot> Done.
20:46:37 <jfredett> Lisp, apparently
20:46:41 <Binkley> SamB: it's not a matter of fear. they have autograder scripts
20:46:45 <edwardk> samb: having to support it in their environment ;)
20:46:51 <SamB> oh.
20:46:52 <Binkley> and presumably, people reading your code as a backup measure
20:46:58 <jfredett> I dunno
20:46:59 <Binkley> So they can't support everything
20:47:02 <SamB> the ICFP contests seem not to have much trouble with that anymore
20:47:08 <Binkley> with ICFP they just look at the output; they don't care about your code
20:47:11 <msouth> brad_: you can set the prompt
20:47:13 <SamB> yeah
20:47:15 <msouth> :help I think
20:47:15 <sjanssen> jfredett, SamB: they need to be able to supply a consistent environment where they can run your code
20:47:16 <jfredett> the issue is they are grading code
20:47:21 <brad_> msouth - how do i do that?
20:47:24 <Binkley> you could solve the problem by hand, with no programming, for all the ICFP organizers would caer
20:47:25 <jfredett> not uberness.
20:47:33 <sjanssen> this isn't possible to provide for every language
20:47:39 <sjanssen> jfredett: they don't grade code at all
20:47:41 <msouth> brad_: try :help, I'll look and see if I can remember, I did it playing around
20:47:42 <jfredett> Lisp should be a part of any consistent environment
20:47:48 <sjanssen> they only grade results of programs
20:47:49 <brad_> okay thanks msouth!
20:47:52 <SamB> they went through the hell of supporting all the languages enough times to realize "this is bunk! we'll just make them run the programs on their own damn machines!"
20:48:07 <msouth> brad_: :set prompt "foo> "
20:48:07 <jfredett> i dunno
20:48:22 <SamB> Binkley: I don't think that's allowed for adventure
20:48:24 <brad_> msouth - :set prompt "> "
20:48:33 <brad_> thanks for the pointer!
20:48:49 <SamB> (You *know* you aren't supposed to look at the UM for that one ;-)
20:48:56 <monochrom> A potential ICFP outcome will be "Brainware is the language of choice of discriminating hackers"? :)
20:49:00 <msouth> np, it was serendipitious that I had just run into it.
20:49:27 <Binkley> SamB: well, I solved about half of adventure by hand
20:49:29 <Binkley> NOT RECOMMENDED
20:49:33 <Binkley> Then I realized
20:49:39 <SamB> ah.
20:49:44 <sjanssen> jfredett: it's a slippery slope.  Once they provide Lisp, do they provide Haskell?  O'Caml? Python? Scala? Prolog? Epigram? ...
20:49:44 <jfredett> adventure?
20:49:46 <SamB> well, I mean, you have to write a UM
20:49:48 <SamB> to run it in
20:49:50 <Binkley> "Oh hay, there's a reason why they gave this problem in a *programming contest*"
20:49:52 <SamB> or you are breaking the rules
20:49:54 <Binkley> Well, of course you need a UM
20:50:09 <Binkley> but you don't need a program to start solving the adventure game itself
20:50:11 <SamB> the other parts you don't need to use a UM to be following the rules for
20:50:17 <Binkley> until you get to the point where your brain explodes, anyway
20:50:26 <shapr> ddarius: five years isn't that long!
20:50:31 <SamB> I said "to be following the rules for"
20:50:37 <SamB> not "to actually do anything"
20:50:44 <jfredett> sjanssen: i suppose
20:51:00 <monochrom> Perhaps I should build an Analytic Engine for the next ICFP.
20:51:02 <ddarius> I really want to win an ICFP contest by pure brain sweat now.
20:51:02 <SamB> I was merely pointing out that manually executing adventure was *not* permitted
20:51:12 <jfredett> that'd be awesome. ddarius
20:51:45 <ddarius> What -do- they say in that case?
20:52:08 <monochrom> <monochrom> A potential ICFP outcome will be "Brainware is the language of choice of discriminating hackers"? :)
20:52:18 <ddarius> Yes, but I don't like that.
20:52:18 <SamB> well, Project Euler has an option for "Pencil and Paper" as your favorite language
20:52:23 <wli> My brain exploded a long time ago, which is why I'm lingering about being useless and endlessly stuck on problems people who started long after me solved long ago.
20:52:23 <sjanssen> ddarius is the tool of choice for discriminating hackers
20:52:32 <monochrom> hahaha
20:52:36 <SamB> probably they let you make up your own name for not using a programming language
20:52:40 <edwardk> do type families work in ghc yet, or is it still just data families?
20:53:02 <SamB> The Human Brain is the tool of choice for discriminating hackers
20:53:05 <ddarius> edwardk: HEAD?
20:53:19 <ddarius> I was thinking "One's brain ..."
20:53:27 <SamB> ddarius: that works
20:53:41 <edwardk> ddarius: if it needs to be HEAD so be it, just curious if i waste the evening installing it if i can use type families
20:53:46 <sjanssen> ddarius: it isn't just anyone's brain that solved the contest, though
20:54:10 <ddarius> sjanssen: Well it was the tool of the hacker.
20:54:14 <monochrom> Yeah, you have to use ddarius. Accept no substitute.
20:54:23 <SamB> I didn't know he was edible
20:54:33 <monochrom> Next time when you build a Frankenstein, make sure you use ddarius's. :)
20:54:33 <Binkley> Braaaaaaiiiiiiiiinz
20:54:51 <Binkley> the fuel of choice for the discriminating zombie
20:54:53 <SamB> monochrom: I'll keep that in mind for the next time, then
20:54:55 * ddarius hides his Frankenstein away.
20:55:22 <monochrom> Oooohhh the secret is out! ddarius has a Frankenstein to write all his Haskell code!
20:55:35 <shapr> I'd like to make some robot mugs and sell them on the internet... Drink from your own automated Frankenstein!
20:55:39 <ddarius> That would explain my productivity.
20:55:57 <sjanssen> Frankenstein is the tool of choice for discriminating madmen
20:56:06 <monochrom> hahahaha
20:56:50 <sjanssen> this can be our new catchphrase
20:56:50 <timthelion> OK, I like Gentle Intro,  it uses the word pedagogical
20:57:00 <sjanssen> X is the tool of choice for discriminating Y
20:57:12 <sjanssen> put it on some lolcat images, and we're set
20:57:34 <shapr> I like lolcat images.
20:57:49 <mwc> timthelion: I stll like gcc for its use of -pedantic
20:58:01 <ddarius> "pedagogy" is important for pedagogy.
20:58:25 <Binkley> I CAN HAS REFERENTIAL TRANSPARENCY???
20:58:32 <sjanssen> haha
20:58:43 <sjanssen> @remember Binkley I CAN HAS REFERENTIAL TRANSPARENCY???
20:58:43 <lambdabot> Done.
20:58:48 <sjanssen> @flush
20:59:12 <Binkley> Thank you, thank you, I'll be here all night
20:59:28 <timthelion> what is @flush?
20:59:45 <sjanssen> timthelion: writes lambdabot's state to disk
20:59:53 <timthelion> oh, ok
20:59:55 <sjanssen> which doesn't always happen when there's a crash
20:59:56 <dino-> @help flush
20:59:56 <lambdabot> flush. flush state to disk
21:00:01 <timthelion> so it's like serialize instance
21:00:03 <Binkley> Now take a picture of a cat reading the Haskell 98 report and we'll be all set
21:00:22 <edwardk> dino: just turn the handle
21:00:25 <sjanssen> does anyone have both a cat and a copy of the report?
21:00:25 <timthelion> Binkley: are you a standup?
21:00:33 <Binkley> timthelion: right now I'm sitting down
21:00:38 <Binkley> sjanssen: I have the report but no cat
21:00:42 <Binkley> I have a rabbit, though
21:00:49 <ddarius> I could get access to a cat, but no report.
21:00:58 <edwardk> has a cat, has a printout of the report somewhere, have crappy camera skills ;)
21:01:02 <Adamant> Binkley looks like a carrot
21:01:08 <Binkley> Adamant: heh
21:01:19 <timthelion> Binkley: I have an old black cat, often mistaken for a goth sketch, which would be rather cheep to ship, as the dieing thing ways no more than 4 pounds.
21:01:23 <Binkley> no, I look like buckwheat
21:01:45 <Binkley> timthelion: I'm not sure the cat would survive the postal system, then :-)
21:02:06 <timthelion> Binkley: ya, probably would die of hunger.
21:02:50 <timthelion> wait, weighs
21:05:15 <timthelion> so why is it that a program can crash when I div n 0?  it seems that div should be forced to return a value for every Integer as it takes Integer
21:05:44 <Binkley> timthelion: what value do you suggest for (div n 0)?
21:05:51 <timthelion> Nothing?
21:05:53 <Binkley> by the way, this isn't a Haskell issue or a programming issue at all
21:06:10 <timthelion> Binkley: how so?
21:06:13 <Binkley> timthelion: so you think div should have type Num -> Maybe Num
21:06:15 <Binkley> ?
21:06:19 <timthelion> yes
21:06:19 <Binkley> it's a mathematical issue
21:06:24 <dolio> Haskell isn't a total language.
21:06:27 <shachaf> @ty div
21:06:29 <lambdabot> forall a. (Integral a) => a -> a -> a
21:06:35 <Binkley> before people knew what an electronic computer was, dividing by zero was ill-defined
21:06:45 <shachaf> (Integral a) => a -> a -> (Maybe a) -- ?
21:06:48 <Binkley> er, I meant Num -> Num -> Maybe Num
21:06:52 <Binkley> modulo class constraints
21:07:01 <timthelion> but it seems strange that a haskell program is capable of crashing while working in a pure realm.
21:07:17 <Binkley> timthelion: purity doesn't mean all functions are total
21:07:22 <ddarius> It can.
21:07:38 <ddarius> timthelion: Do you want Turing completeness or not?
21:07:45 <Binkley> you can write a program that loops infinitely without using side effects, easily enough
21:07:49 <timthelion> Binkley: it just seems sad that we are so close, yet we are not there with haskell
21:08:01 <shachaf> @ty head -- Do you object to this too?
21:08:02 <Binkley> and from a semantic point of view, looping is the same as crashing with an error
21:08:03 <lambdabot> forall a. [a] -> a
21:08:04 <msouth> [1..]
21:08:06 <timthelion> Binkley: but that isn't crashing
21:08:08 <Binkley> timthelion: close to what? :-)
21:08:29 <Binkley> from the perspective of formally reasoning about programs, both a crash and an infinite loop are divergence
21:08:30 <dolio> I'm not sure I like 'div n 0 = 0' in Total Functional Programming, either.
21:08:47 <shachaf> dolio: You definitely wouldn't want that.
21:08:50 <Binkley> Like ddarius said, you can take Turing-completeness or leave it
21:08:50 <stepcut> div n 0 = _|_
21:08:52 <timthelion> Binkley: making a programming languaprov enhich you have large bodies of code which are prooven to take structure a and return structure b
21:09:03 <stepcut> hrm
21:09:06 <msouth> whatever div n 0 returns, 0 is definitely not what I want it to be
21:09:07 <dolio> shachaf: Well, that's what he suggests. :) There's probably something better to do than that, though.
21:09:09 <timthelion> Binkley: oh wait
21:09:26 <msouth> stepcut: is that the kronecker(sp) delta function?
21:09:27 <timthelion> Binkley: I guess you're right, an infinite loop does not return structure b
21:09:31 <shachaf> dolio: No, he suggests returning Maybe.
21:09:46 <Binkley> timthelion: well, a function that always diverges can be said to have any return type
21:10:19 <timthelion> Binkley: but having xmonad go away when I div by 0...
21:10:30 <stepcut> msouth: no -- just bottom, but I think total functional programs don't have bottom
21:10:33 <ddarius> We could have div require a proof that it's argument is non-zero.
21:10:51 <timthelion> ddarius: how would that work?
21:11:08 <stepcut> timthelion: perhaps integers are just the wrong type of number to use in xmonad
21:11:19 <Binkley> timthelion: yes, but if div returned Nothing for 0 as the second argument, what do you think xmonad should do if it tries to divide by 0?
21:12:35 <dolio> shachaf: "In the same spirit any built in operations must be total. This will involve a some non-standard decisions - for example we will have 0 / 0 = 0" Which, I guess, is slightly different.
21:12:36 <timthelion> Binkley: well, specifically, it should not be possible to have that dead end, the programmer should be *forced* by a type of Maybe to consider the 0 case
21:12:38 <ddarius> timthelion: See Coq, or Epigram, or Twelf, or Isabelle.
21:13:00 <Binkley> timthelion: That's what I mean
21:13:08 <Binkley> you are writing code in xmonad that calls div...
21:13:09 <timthelion> ddarius: I'm already 16, I can't spend my entire life reading papers which I do not understand
21:13:10 <shachaf> > 5 / 0
21:13:11 <lambdabot>  Infinity
21:13:12 <Binkley> what do you write for the Nothing case?
21:13:18 <dolio> shachaf: Maybe he changed that in a version of the paper I don't have, though.
21:13:31 <msouth> what if (sorry if this is stupid newbie) the second argument was from a type class that included all the integers but zero?
21:13:36 <shachaf> dolio: Sorry, I though you meant timthelion when you said "he".
21:13:37 <Binkley> timthelion: I'm 26 and I still read a lot of papers I don't understand :-)
21:13:40 <timthelion> Binkley: well, I'm going to write something, I'm going to have to write something
21:13:43 <Binkley> msouth: Now you're getting somewhere
21:13:49 <ddarius> timthelion: I didn't start reading papers I didn't understand really until 17.  Anyways, none of those are papers.
21:13:49 <hpaste>  wli annotated "not prolog fun" with "SWI Prolog powerset" at http://hpaste.org/1782#a1
21:13:53 <shachaf> dolio: I must've missed some context.
21:13:55 <dolio> shachaf: Ah, no. I meant the author of Total Functional Programming.
21:13:56 <Binkley> not necessarily a class, though
21:14:20 <Binkley> timthelion: yes, but what do you write? What *do* you write?
21:14:51 <Binkley> Sure, you can write: error "tried to divide by zero"
21:14:56 <Binkley> but that's no improvement
21:15:06 <timthelion> Binkley: I ended up writing a div' which returns 0 for div by 0
21:15:14 <Binkley> timthelion: you don't want that
21:15:27 <Binkley> if 1/0 = 0, then 1 = 0
21:15:31 <Binkley> and we all vanish in a puff of logic
21:15:49 <msouth> or we all become the pope
21:15:53 <Binkley> sweet!
21:16:01 <dino-> As someone who has forgotten much of what little math I ever had, I'm slightly surprised that the "integers greater than 0" isn't known by some identifier in math.
21:16:02 <timthelion> Binkley: I did for my purposes, which row am I on?, there are 0 enough windows to fill up one row, therefore I am on the 0th row
21:16:21 <msouth> dino-: naturals I think is defined that way
21:16:26 <Binkley> timthelion: but what does your program mean if your division function returns 0 for (div 1 0)?
21:16:38 <shachaf> msouth: Naturals is 0+.
21:16:41 <Binkley> if you want a different function than divide, call it something else
21:16:43 <TSC> dino-: Or sometimes "positive naturals"
21:16:44 <msouth> but a lot of times you'll just see Z with a + superscript meaning positive integers
21:16:47 <Binkley> there's no problem with that
21:16:48 <timthelion> dino-: or counting numbers
21:16:49 <shachaf> s/0\+/[0..]/
21:17:52 <msouth> shachaf: well, different disciplines define differently: http://en.wikipedia.org/wiki/Natural_number
21:17:54 <lambdabot> Title: Natural number - Wikipedia, the free encyclopedia
21:18:08 <hpaste>  ddarius annotated "not prolog fun" with "straight haskell" at http://hpaste.org/1782#a2
21:18:13 <timthelion> Binkley: I was just a bit offended that instead of ensuring that I had a result it just whent poof, I mean in C you can't have an if statement that returns a value yet have the main body not do so.
21:18:17 <desp> is there a difference between Word8 and CChar?
21:18:28 <shachaf> msouth: Oh.
21:18:34 <shachaf> msouth: Never mind, sorry.
21:18:37 <msouth> I always heard it defined as not including zero--but to a computer scientist there could be nothing more natural than starting to count with zero :)P
21:18:46 * wli attempts to figure out how to do N queens and such with the list monad.
21:18:57 <msouth> shachaf: no, you were also correct.
21:19:01 <msouth> by same article
21:19:08 <shachaf> msouth: Yes, but you were correcter.
21:19:16 <Binkley> timthelion: I'm not sure what you mean by that, but I guarantee you that if you divide by zero in C, your program will go poof
21:19:22 <shachaf> And I was the (mistaken) corrector. :-)
21:19:32 <msouth> well, in this channel, it's the other three disciplines that rule I think.
21:19:37 <msouth> lol
21:19:45 <dino-> The corrector of least correcness.
21:19:49 <dino-> ^t
21:19:53 <timthelion> Binkley: consider char foo(n, a) {if (n > 0) {return n/a;} } doesn't compile, yet div n a will,
21:19:56 <Nafai> Any gtk2hs users/devs around?  Is there an easy way to see what parts of the gtk api are wrapped in the current darcs?
21:19:56 <Binkley> desp: I think that's machine-dependent
21:20:07 <Binkley> I mean, you *could* have an architecture where a char isn't 1 byte
21:20:16 <timthelion> Binkley: you see, I think that the compiler has a duty to ensure all forks have return values
21:20:31 <Binkley> timthelion: char foo(n, a) { return n/a; } will certainly compile
21:20:38 <Binkley> except that the return type isn't char
21:20:49 <dolio> wli: ddarius' original prolog doesn't actually generate a powerset list. It just succeeds with all subsets, which is sort of like generating the powerset. Hence the difference from yours.
21:20:52 <Binkley> timthelion: good luck with that if you're compiling a Turing-complete language
21:21:00 <msouth> timthelion: but in my opinion, the mistake is that you sent zero as the second argument
21:21:16 <timthelion> Binkley: but if you have the if statement around it then the compiler wants the seccond return statement
21:21:24 <msouth> which is why I suggested making a div' that would not let that happen
21:21:33 <dolio> wli: In Haskell, the two merge, since a non-deterministic computation in the list monad is a list of the successes.
21:21:39 <wli> dolio: Point.
21:21:53 <Binkley> timthelion: sure, and you can write div n a = (if n /= 0 then n/a else error "you are dumb") in Haskell
21:21:56 <Binkley> same thing
21:22:00 <msouth> because you want it to stop you from making mistakes, not ignore your mistakes for you in a special way that it would be a mistake for you to forget to consider.
21:22:08 <ddarius> dolio: Ah, that would explain the confusion.
21:22:11 <wli> dolio: Well, anyway.
21:22:13 <Binkley> er
21:22:17 <Binkley> (if a /= 0..., I meant
21:22:58 <msouth> but I don't know enough to know how hard it would be to define that type and what the implications would be.
21:23:13 <timthelion> Binkley: having a pure function have the ability to fork off into oblivion is blasphemy to the pure world.
21:23:36 <shachaf> timthelion: Do you object to the function "head"?
21:23:37 <Binkley> timthelion: I'm not sure what you mean by "fork off into oblivion"
21:23:48 <shachaf> > let x = x in x -- Oblivion?
21:23:49 <lambdabot>  Exception: <<loop>>
21:23:50 <Binkley> Like I said, you can write a pure function that loops infinitely more easily than falling off a log
21:23:54 <timthelion> Binkley: it's unpure and for no good reason, and it doesn't hold to it's type. div should, if nothing else, return IO num
21:23:54 <Binkley> Like that one.
21:24:03 <edwardk> so, playing with the reader monad instances for FromInteger, I'm wondering if a 'wrong' but more intuitive definition for a numeric function makes sense. class (FromInteger a, MulMagma a) => FromInteger a -> a where fromInteger x y = x * y     or something like that, so (1 2 3) = 6 rather than 1.
21:24:07 <Binkley> timthelion: purity doesn't have anything to do with totality
21:24:13 <ddarius> > let undefined = undefined in undefined.
21:24:14 <lambdabot>  Parse error
21:24:15 <ddarius> > let undefined = undefined in undefined
21:24:16 <edwardk> and you get weird things like 2 x + 1
21:24:17 <lambdabot>  Exception: <<loop>>
21:24:31 <dibblego> @join #jtiger
21:24:31 <lambdabot> Not enough privileges
21:24:45 <Binkley> Anyway, I think this is what should happen if you try to divide by zero:
21:24:46 <glguy> lambdabot is maxed out on channels anyway
21:24:49 <Binkley> http://xkcd.com/c292.html
21:24:50 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
21:24:57 <timthelion> shachaf: what is wrong with head, if I give it a null list, it returns [] no?
21:24:58 <dibblego> so that's why someone took it off #jtiger
21:25:04 <shachaf> > head []
21:25:04 <Binkley> > head []
21:25:05 <lambdabot>  Exception: Prelude.head: empty list
21:25:06 <lambdabot>  Exception: Prelude.head: empty list
21:25:10 <Binkley> ONOEZ IMPURITY
21:25:13 <shachaf> timthelion: How could it?
21:25:17 <shachaf> @ty head
21:25:19 <lambdabot> forall a. [a] -> a
21:25:24 <shachaf> [] is not a.
21:25:32 <edwardk> anyways it would break the perfect symmetry between reader and normal use, but its a nice sugar if nothing else
21:25:40 <glguy> ?quote beware
21:25:40 <lambdabot> Cale says: Beware of the function [a] -> a. For it may contain trappes and sprynges of great variety and harm.
21:25:59 <dino-> msouth: I'm not exactly sure either. But looking at how Int is defined in the Prelude, I want to say something about instancing Bounded with the right value for minBound
21:26:02 <Binkley> @Cale++
21:26:02 <lambdabot> Unknown command, try @list
21:26:03 <timthelion> shachaf: then yes, I object, I think exceptions are bad. they are a thing which can be avoided.
21:26:06 <Binkley> @karma+ Cale
21:26:06 <lambdabot> Cale's karma raised to 47.
21:26:14 <glguy> @karma @Cale
21:26:14 <lambdabot>  @Cale has a karma of 0
21:26:31 <Binkley> timthelion: well, head is a bad example since, IMO, you shouldn't be using it
21:26:47 <Binkley> But you still haven't explained to me how you would write a div function that doesn't raise an exception when the second arg is zero
21:26:53 <dibblego> timthelion, exception is early failure for a type error or non-terminating function
21:27:07 <shachaf> I agree about head, but I thought I'd mention it.
21:27:14 <timthelion> Binkley: I guess that is my quip, that exceptions are necessarily not with the spirit of haskell.
21:27:20 <Binkley> timthelion: why?
21:27:31 <Binkley> sometimes exceptional things happen
21:27:34 <Binkley> sometimes your disk fills up
21:27:37 <dibblego> timthelion, do you propose we abolish head :: [a] -> a and instead head' :: NonEmptyList a -> a -- data NonEmptyList a = Single a | Cons a (NonEmptyList a)
21:27:37 <Binkley> or your network connection goes down
21:27:38 <wli> Binkley: data MyInt = NegInt PosNat | Zero | PosInt PosNat
21:27:44 <Binkley> or velociraptors eat your MMU
21:28:02 <dino-> We have other stuff that fails catastrophically at runtime.
21:28:04 <dino-> > head []
21:28:06 <lambdabot>  Exception: Prelude.head: empty list
21:28:19 <ddarius> I've had velociraptors eat my MMU before.  Oddly, I didn't get an exception for it.
21:28:20 <timthelion> Binkley: because, looking at the code, you do not see that there is another case which you have to take into account, you are not forced to take things into account, you are not forced to write typesafe code as it where, you can give bad values
21:28:40 <wli> Binkley: div :: MyInt -> MyInt -> Maybe MyInt
21:28:51 <timthelion> dibblego: exactly
21:28:52 <Binkley> timthelion: yes, but what code would you write to handle the zero case?
21:28:58 <Binkley> wli: see above
21:29:07 <timthelion> Binkley: I would write something!
21:29:13 <ddarius> Having div return Maybe is tantamount to having it throw an exception (albeit much better behaved).
21:29:14 <timthelion> Binkley: that is of no importaince
21:29:35 <Binkley> data MyInt = NegInt PosNat | Zero | PosInt PosNat -- sure, but I'm not sure all computations you'd want to do are such that you can statically guarantee that you never pass 0 to div
21:29:43 <Binkley> timthelion: I think it's very important
21:29:45 <timthelion> Binkley: whether it be a dialog telling the user they made a mistake, or wether it would be a special case, I would have to write something
21:29:56 <wli> Binkley: cf. div :: MyInt -> MyInt -> Maybe MyInt
21:30:00 <Binkley> timthelion: do you think "divided by zero" is a helpful error message for the user?
21:30:28 <Binkley> if you're trying to divide by zero, it means the programmer made a mistake
21:30:37 <timthelion> Binkley: not when the program is crashed, and their work is gone, NO!
21:30:51 <Binkley> error messages are only useful to users when they tell the user what they can do to fix the problem
21:31:13 <dino-> Apologies if this has been covered, but there's also the possibility of checking the denom for 0-ness in an if or case around that div.
21:31:14 <timthelion> Binkley: and the whole idea of haskell is to make it very hard for the programmer to mess up
21:31:15 <ddarius> Hmm...
21:31:22 <dino-> As disappointed as that may make us to write.
21:31:24 <Binkley> timthelion: that's the point. If the program crashes and I lose my work, I don't really care if it was because of divide-by-zero, cosmic rays, etc.
21:31:32 * ddarius ponders an operating system with multi-level undo.
21:31:44 <Binkley> timthelion: unfortunately, no programming language can make it impossible for humans to make mistakes
21:32:11 <dolio> Binkley: The issue is, the type of 'div' could easily force you to handle the 0 case, and never forget, but it doesn't.
21:32:17 <ddarius> If you give programming languages laser cannons, I think they may make a good shot at it.
21:32:26 <dino-> Not unlike : foo [] = ... -- Don't use head here!
21:32:28 <timthelion> Binkley: but haskell can do a better job, it can illiminate one of the main sources of bugs. it can eliminate exceptions through monadyness, and it is a great sadness that it does not!
21:32:43 <dino-> or something
21:32:46 <Binkley> timthelion: I don't think monadic IO can eliminate exceptions
21:33:06 <Binkley> dolio: I'm arguing that dividing by zero is almost always an unrecoverable error
21:33:15 <Binkley> and no one has given me any evidence that that's not the case :-)
21:33:21 <wli> Of course they can't be eliminated. But you can sure cut them down quite a bit.
21:33:30 <dynamix> how do you restrict an Int to 0-255 ?
21:33:35 <msouth> ddarius: was your point that you could make it impossible for humans to make mistakes by virtue of obliteration of humans by laser cannon?  or did I overinterpret?
21:33:39 <Binkley> dynamix: Word8
21:33:46 <timthelion> Binkley: yes it can, it can have multiple levels of Either, getFileContents :: FilePath -> Either [Byte] FileNotFound
21:34:00 <dynamix> i mean Int, to avoid buffer overflows
21:34:01 <Binkley> timthelion: that's just a form of exception handling
21:34:11 <dynamix> or rollaroud etc..
21:34:12 <Binkley> returning (Right FileNotFound) is just another way of signalling an exception
21:34:17 <Adamant> dynamix, Haskell is bounds checked, IIRC
21:34:20 <ddarius> msouth: Do you have another interpretation?
21:34:33 <timthelion> Binkley: but it exception handling with reverence for the context.
21:34:39 <Binkley> monads don't stop you from calling getFileContents on a filename that doesn't exist
21:34:40 <dynamix> thanks guys
21:34:47 <Binkley> I'm not sure what "reverence for the context" means
21:34:58 <dino-> Binkley: Which is also what checking ahead of time before the div is, another form of exception handling. I can agree with that.
21:35:00 <timthelion> Binkley: but it forces you to write SOMETHING in the case that the file does not exist
21:35:10 <dynamix> lets say it is 333
21:35:13 <msouth> ddarius: actually at first i thought "because they would threaten us into doing it right?", to tell the truth.  then I saw the more elegant solution.
21:35:23 <dynamix> i mean restrict an Int to be within 0-333 ?
21:35:25 <ddarius> msouth: Well said.
21:35:26 <Binkley> timthelion: sure, but it's misleading to say it "eliminates exceptions"
21:35:49 <Binkley> dino-: so what would you do in your code to handle the Nothing case, if div returned a Maybe Int?
21:36:02 <timthelion> Binkley: you can make a programming language that does not have the abuility to stop, and die. because a function was given an invalid parameter
21:36:18 <glguy> dynamix: there is no type that allows for an arbitrary range like that
21:36:24 <SamB> timthelion: you must mean RML
21:36:40 <Binkley> timthelion: if you can't write programs that terminate with an error, then it's not a very useful language
21:36:41 <ddarius> timthelion: Stop and die is usually what you want to do.  All you do is make the programmer have to write "Stop and die" in many cases.
21:36:55 <Binkley> ddarius: exactly. That's what I was trying to say
21:37:04 <dynamix> glguy: can i specify it as an enum ?
21:37:10 <SamB> timthelion: it was featured in last years ICFP contest
21:37:10 <ddarius> Binkley: I know.
21:37:13 <msouth> the thing is, I don't want all the overhead of making div "safe" and head "safe" and all that in the standard definitions--if you have something that needs it write the safe versions that initialize the core reactor shutdown sequence when it happens.
21:37:15 <dynamix> and still treat it as Int mixing with other values?
21:37:17 <Binkley> part of language design is deciding what errors you should force the programmer to handle, and which ones are always going to mean "stop and die"
21:37:21 <glguy> dynamix: no
21:37:27 <Binkley> there are no absolutes
21:37:47 <msouth> absolutely no absolutes?
21:37:49 <Binkley> dynamix: you can make it an instance of Num
21:37:50 <timthelion> Binkley: For-instance, one might have file FileNotFound = do putStr "file not found" \n promtForFileName  file a = a
21:37:53 <Binkley> All generatlizations are false
21:38:00 <glguy> what's that?
21:38:11 <Binkley> timthelion: yes, because a file not existing is an error you would probably want to handle
21:38:13 <sfultong> all generalizations are true
21:38:18 <Binkley> say, by prompting the user for another filename
21:38:38 <Binkley> OTOH, division by zero doesn't allow for a meaningful error message to the user, unless perhaps it's a calculator app and the user manifestly divided by zero
21:38:44 <Binkley> Or something like that.
21:39:14 <msouth> the times when it's meaningful to the user are not the default times.
21:39:28 <dolio> Binkley: I guess I agree. To get real benefit, what you'd probably want is a type that could never be zero that you'd use whenever you divide, which would avoid programmer errors. And then you'd only check for 0 in places where you're taking input, which can't be statically checked. Or something like that.
21:39:39 <msouth> whereas for the file not found that is by default a user dealwithable exception
21:40:04 <dynamix> Binkley: instance Num MyInt where
21:40:11 <dynamix> Binkley: what goes after that?
21:40:17 <Binkley> dolio: Maybe
21:40:22 <ddarius> Indeed. The whole point is often these cases aren't supposed to -ever- occur.  There's no thinking "what should I do if...".
21:40:24 <timthelion> Binkley: most of the time, when you look to use a function, you look at the typedef and then you know what you have to deal with, if nothing else, the typedef shounld list the exceptions that the function might throw
21:40:31 <Binkley> But I'm not convinced that you can statically check everything
21:40:49 <ddarius> Binkley: You clearly can't.  Just write an interpreter.
21:40:59 <Binkley> Well, right
21:41:13 <ddarius> timthelion: Java did that.  People didn't like it.
21:41:19 <timthelion> ddarius: why not?
21:41:33 <ddarius> It's a pain and it increases coupling.
21:41:41 <timthelion> ddarius: that's because java overused exceptions to the nth,
21:41:57 <ddarius> Which is what you are suggesting.
21:41:57 <timthelion> I think exceptions are just plain evil
21:42:14 <SamB> usually a file not existing is an error you want to handle by crashing, actually
21:42:15 <Binkley> timthelion: how do you think errors should be handled, then?
21:42:31 <timthelion> I think that the output of a function should represent the posible mutations of the input
21:42:31 <Binkley> SamB: do you want emacs to crash if you try to open a file that doesn't exist?
21:42:40 <glguy> Binkley: by winding your error handling deep into the normal control flow
21:42:41 <timthelion> SamB: really?
21:42:42 <SamB> Binkley: no. but emacs is an exception ;-)
21:42:48 <ddarius> Is emacs a representative program?
21:43:06 <SamB> timthelion: what do you expect a compiler to do if you try to compile a file that doesn't exist?
21:43:08 <timthelion> SamB: that is MOST CERTAINLY not true when writting applications,
21:43:25 <SamB> personally I find TeX's behaviour to be extremely irritating
21:43:31 <timthelion> SamB: print file not found and exit, but that is a cli program.
21:43:49 <glguy> exceptions are an abstration and quite useful when used correctly
21:43:50 <msouth> samb: suppose I specify a config file and it doesn't exist, I don't want to be prompted for the correct one?
21:43:58 <glguy> C's return value hell is no home for me
21:44:13 <msouth> or at least notified why the program is exiting?
21:44:13 <SamB> timthelion: and most aren't?
21:44:19 <SamB> msouth: well sure
21:44:53 <timthelion> SamB: and even cli programs usualy SHOULD deal with those, say a compiler has done a bunch of compiling, and has put a bunch of meta files everywhere, and it can't find an include, so it crashes, but it SHOULD delete the meta files.
21:44:59 <SamB> Prelude> readFile "/not/there"
21:45:00 <SamB> *** Exception: /not/there: openFile: does not exist (No such file or directory)
21:45:10 <Binkley> timthelion: yes, and how do you implement that behavior?
21:45:12 <Binkley> with an exception handler!
21:45:15 <Binkley> see, exceptions are useful
21:45:16 <msouth> and "printing file not found" is not crashing, it's handling the exception and exiting
21:45:23 <mrd> no, with a finally handler
21:45:29 <SamB> timthelion: bracket is good for those
21:45:55 <dino-> I'm reminded by this of recent reading about strong/not-strong typing where the author talked about how Data.Map.lookup is a "magical" function..
21:46:01 <timthelion> Binkley: no, you implement that behavior with a monad, and you have to satisfy all the possible mutations of that monad or else your damn thing won't compile.
21:46:08 <dino-> lookup :: (Monad m, Ord k) => k -> Map k a -> m a
21:46:27 <dino-> That monad could be Maybe (simple checking for "null"), or an exception handling mechanism.
21:46:46 <ddarius> dino-: If we had type Id a = a instance Monad Id where ... that would be ideal.
21:46:46 <Binkley> timthelion: that doesn't make sense
21:46:53 <timthelion> Binkley: how so?
21:46:57 <Binkley> I don't know what "mutations of a monad" are
21:47:04 <shachaf> ddarius: You can't do that, though. :-(
21:47:08 <timthelion> Binkley: well, Just or Nothing
21:47:27 <timthelion> Binkley: you have to deal with both, or pattern matching will not be fulfilled.
21:47:33 <Binkley> timthelion: returning a Maybe type is a form of exception handling
21:47:35 <Binkley> or at least, it can be
21:47:37 * shachaf wishes it was possible.
21:48:07 <msouth> timthelion: the language will let you do that, though, right? (I'm a newbie, I could be missing something)
21:48:14 <timthelion> Binkley: yes, it is an exception for the handling of which is forced. the program is forced to handle the exception
21:48:23 <Nafai> :(
21:48:33 <Nafai> Doesn't look like gtk.StatusIcon is supported in gtk2hs
21:48:47 <timthelion> msouth: it does, but there are certain functions such as head, that instead of returning Maybe crash, when you give them an empty list
21:49:04 <SamB_XP> dcoutts: do you have any help for Nafai ?
21:49:05 <Binkley> timthelion: sure, but you were saying before that you didn't like exceptions
21:49:10 <Binkley> and anyway, the program isn't forced to handle it
21:49:20 <Binkley> you can write a program with an incomplete pattern match and it'll compile
21:49:23 <Binkley> not that it's a good idea
21:49:28 <timthelion> Binkley: I don't like the kind of exception that makes the program go poof
21:49:41 <dolio> timthelion: You should use Epigram.
21:49:56 <SamB_XP> timthelion: what about the kind that goes around in circles?
21:50:03 <Binkley> timthelion: yes, then program in Epigram :-)
21:50:10 <Binkley> or SQL
21:50:21 <ddarius> Or Haskell's type language.
21:50:21 <SamB_XP> (Epigram isn't supposed to have either of those)
21:50:29 <msouth> but if you change head, doesn't that make it dramatically less convenient to do things with head?
21:50:30 <Binkley> ddarius: oops...
21:50:34 <SamB_XP> ddarius: Haskell's type language can easily go around in circles...
21:50:48 <ddarius> Only with extensions.
21:50:48 <timthelion> Binkley: technically, div has the type Num -> Num -> IO Num, because one option is that if Num is 0, it could print "divided by zero" and exit, and printing "divided by zero" is interaction with the outside world
21:51:03 <wli> I've officially turned into Forrest Gump.
21:51:28 <dolio> timthelion: div does not have that type, because Haskell's denotational semantics would include bottom.
21:51:31 <dons> win 4
21:51:34 <ddarius> wli: I'm sure your father is upset.
21:51:35 <SamB_XP> timthelion: _|_ is not restricted to IO
21:51:36 <timthelion> wli who me/
21:51:40 <dolio> timthelion: It just so happens that GHC does something nice when it encounters a bottom.
21:51:42 <timthelion> what?
21:51:53 <Binkley> timthelion: yes, what SamB said
21:52:01 <Binkley> think about the type of the "error" function
21:52:09 <shachaf> timthelion: If div x 0 = div x 0, then it would have the same effect.
21:52:12 <Binkley> though I guess you probably don't like "error"
21:52:15 <shachaf> timthelion: Never return.
21:52:27 <Binkley> But... it's the runtime system that prints "divided by zero", not the program
21:52:32 <SamB_XP> how about this one?
21:52:33 <Binkley> so there is nothing impure about the program
21:52:34 <shachaf> timthelion: undefined or error "string" are a friendlier version of that.
21:52:38 <dolio> Or, a certain type of bottom, at least.
21:52:40 <SamB_XP> > let undefined = undefined in undefined
21:52:41 <lambdabot>  Exception: <<loop>>
21:53:10 <dino-> msouth: I think this is the rationale in Java where so many things throw the types of exceptions that you absolutely must deal with in try/catch blocks.
21:53:19 <shachaf> > let error x = error x in error "This is equivalent to the regular error, except it pretends to do something."
21:53:22 <dino-> Seems to wear people down.
21:53:23 <SamB_XP> you want the typesystem to assign that a type with IO in it because it loops in a runtime detectable fashion?
21:53:23 <lambdabot> Terminated
21:53:29 <timthelion> Binkley: I don't care that we can't eleminate infinite loops, I care that there is something that we can eliminate and we don't!
21:53:41 <Binkley> timthelion: you haven't explained how we would eliminate it
21:53:47 <mrd> we can eliminate infinite loops
21:53:53 <mrd> total functional programming!
21:54:09 <SamB_XP> timthelion: but we can't. we are far too lazy.
21:54:54 <timthelion> Binkley: well, we can eliminate the risk of having a program that doesn't do the logical thing in the case of an error, by making it so that instead of having errors, we had it so that there was one more thing the program had to deal with.
21:55:06 <timthelion> SamB_XP: I am not:)
21:55:19 <Binkley> timthelion: but making the program deal with it doesn't help, because it's going to error out anyway, except in a few rare cases
21:55:25 <Binkley> and in those cases, the programmer can handle it
21:55:26 <SamB_XP> timthelion: go use ML then
21:55:27 <timthelion> maybe I'll rewrite the haskell libraries without use of the error function
21:55:29 <ddarius> If you don't get rid of infinite loops, then there's little reason to get rid of exceptions.
21:55:29 <Binkley> we want to design for the common case
21:55:34 <timthelion> :t error
21:55:36 <lambdabot> forall a. [Char] -> a
21:55:39 <msouth> not being lazy, perhaps you're industrious enough to write haskell' ...
21:55:41 <Binkley> timthelion: try it and come back when you're done :-)
21:55:48 <Binkley> be sure you can bootstrap GHC
21:56:09 <SamB_XP> Binkley: hahahahahaha
21:57:31 <timthelion> ML is often referred to as an impure functional language, because it permits
21:57:31 <timthelion> side-effects,
21:57:32 <glguy> unhandled exceptions already terminate the program, why would you bother rewriting the libraries to terminate on failure?
21:57:41 <timthelion> sounds like exactly what I don't want
21:58:03 <SamB_XP> timthelion: yes but it isn't lazy
21:58:09 <timthelion> glguy: I wouldn't. I would re-write the functions to make enforced handled functions
21:58:23 <Binkley> what is an "enforced handled function"?
21:58:29 <timthelion> SamB_XP: I don't have anything against lazyness
21:58:35 <glguy> timthelion: you'd have to rewrite the whole language to do forced total pattern matching...
21:58:40 <ddarius> timthelion: Actually you do.
21:58:43 <SamB_XP> timthelion: please
21:58:45 <timthelion> Binkley: div :: Num -> Num -> Maybe Num
21:58:48 <SamB_XP> go try to write some RML code
21:58:49 <mrd> haskell' isn't going to come out because its lazy?
21:58:55 <SamB_XP> come back when you are sane again
21:58:55 <timthelion> that is enforced
21:59:07 <glguy> ok... moving on
21:59:12 <Binkley> timthelion: ok, sure. Like I said, rewrite all the libraries like that and come back when you can write any useful program in the language
21:59:18 <SamB_XP> mrd: it won't come out 'til we demand it
21:59:24 <Binkley> and if you give up on that, go read an introduction to "denotational semantics" :-)
21:59:27 <SamB_XP> and even then it will only be in WHNF
21:59:43 <monochrom> I like that :)
21:59:44 <SamB_XP> Binkley: don't be so hard on him
21:59:44 <mrd> not if you hit bottom
21:59:45 <dolio> I think removing error from the standard libraries would mostly involve simply deleting functions.
21:59:55 <Binkley> SamB: why not? everyone should learn denotational semantics
21:59:57 <Binkley> including me
22:00:06 <dolio> Since a lot of the ones that aren't total simply wouldn't be useful if they were made total.
22:00:10 <SamB_XP> no I meant that first part
22:00:38 <Binkley> SamB: well, the only way I think timthelion would be convinced it's not a good idea is to try it :-)
22:00:41 <monochrom> People should not have opinions.
22:00:48 <Binkley> and I don't think it would take very long
22:01:00 <SamB_XP> Binkley: I have a better idea
22:01:05 <Binkley> o rly?
22:01:46 <SamB_XP> timthelion: come back when you have root: http://www.boundvariable.org/task.shtml
22:01:50 <lambdabot> Title: ICFP Programming Contest, 2006 : Contest Materials and Task
22:02:00 <Olathe> Has that started ?
22:02:03 <dolio> He left already.
22:02:04 <mrd> 5 hrs
22:02:07 <SamB_XP> Olathe: that's from 2006
22:02:11 <Binkley> Olathe: it was last year's contest
22:02:17 <Olathe> Oh.
22:02:21 <mrd> everyone should be sleeping in preparation for the contest
22:02:22 <Olathe> I was getting all excited.
22:02:23 <SamB_XP> @tell timthelion come back when you have root: http://www.boundvariable.org/task.shtml
22:02:23 <lambdabot> Consider it noted.
22:02:37 <Binkley> Olathe: you can still solve it if you want :-)
22:02:52 <SamB_XP> Olathe: it's actually pretty fun
22:02:57 <Olathe> I did that last year, I think (was it the interactive fiction one ?)
22:03:08 <Olathe> I didn't solve all the puzzles, but it was pretty neat.
22:03:09 <SamB_XP> Olathe: it had lots of stuff
22:03:10 <Binkley> part of it was interactive fiction
22:03:12 <glguy> monochrom: I don't think it was about him having an opinion so much as poorly defending a seemingly absurd one, for a prolonged time
22:03:12 <mrd> 36 hours of constant coding is great stuff
22:03:24 <SamB_XP> I was suggesting the IF puzzles to him to convince him of his folly
22:03:34 <Olathe> I made a sort of crappy JIT compiler for x86.
22:03:42 * Binkley isn't superhuman enough to code for 36 hours straight
22:04:06 <SamB_XP> because I thought the part where (- redacted -) would show him the error of his ways
22:04:08 <mrd> after 36 hours you reach enlightenment
22:04:36 <mrd> the code writes you
22:05:27 <mrd> the best i've achieved is 18 hours
22:06:07 <SamB_XP> mrd: or you could just use the ol' time machine to go to soviet russia
22:06:20 * kig reached RSI after 18 hours
22:06:24 <monochrom> If you practice type-oriented programming, the code writes you in just five minutes.
22:06:25 <mrd> and that was in C++
22:06:39 <Binkley> you mean RSI isn't enlightenment?
22:07:10 <shachaf> Speaking of interactive fiction, Enlightenment is fun. :-)
22:07:17 <shachaf> One room.
22:08:57 * wli suspects he's degenerated to sub-freshman level.
22:08:59 <kig> it enlightened me from the computer for a month or two
22:09:09 <wli> N queens is not this hard.
22:10:09 <Olathe> N-queens is easy.
22:11:24 <mrd> n-SAT is hard
22:22:08 <wli> I gave up on the monad and just wrote it out.
22:23:00 <shachaf> wli: Monad?
22:23:07 <wli> shachaf: For n queens.
22:23:26 <mrd> the monad hiding in the closet which comes out at night and terrorizes children
22:23:45 <wli> I may be thirtysomething but I'm thoroughly terrorized.
22:23:50 <shachaf> wli: Which monad?
22:23:51 <mrd> (it always returns before daybreak)
22:24:02 <wli> shachaf: Nondeterminism and/or list.
22:24:29 <mrd> list is fun.  but it will probably give you exponential-time solutions.
22:24:46 <wli> mrd: Well, my first take was O(n!).
22:25:04 <wli> mrd: This latest is a bit faster, albeit nothing remotely monadic.
22:25:27 <Olathe> wli: Are you generating all solutions or do you just want one ?
22:25:35 <mrd> i learned a lot by taking code after the fact and transforming it
22:25:48 <mrd> plus, you can compare it to your original for testing purposes. perhaps with QuickCheck.
22:26:25 <wli> I did that.
22:26:42 <wli> The original was queens n = [queens | queens <- map (zip [1..n]) (perms [1..n]), all (\((rank,file),(rank',file')) -> rank + file /= rank' + file' && rank - file /= rank' - file') [(q, q') | q <- queens, q' <- queens, q < q']]
22:27:20 <mrd> thats monadic
22:27:29 <dolio> If you're using list comprehensions, you're (essentially) using monads.
22:28:00 <mrd> the List monad and list comprehensions are different syntax for the same thing.
22:28:43 <wli> I'm not sure I can take that as a meaningful solution, though.
22:29:00 <mrd> [ (q,q') | q <- queens, q' <- queens, q < q' ]  ===  do q <- queens; q' <- queens; guard (q < q'); return (q,q')
22:29:32 <jsnx> mrd: can you explain that?
22:29:39 <mrd> which part?
22:29:47 <wli> That guard thing throws me immediately.
22:30:03 <mrd> remember that the "q < q'" part in the list comprehension is called a 'guard'?
22:30:29 <mrd> the guard function performs the same task.  it throws away the current branch if the guard is not satisfied
22:30:31 <jsnx> mrd: oh, wait, i understand now
22:30:32 <shachaf> > do { x <- [1,2,3]; y <- [4,5,6]; guard (x*y == 8); return (x,y) } -- jsnx: Monad!
22:30:33 <mrd> @type guard
22:30:35 <lambdabot>  [(2,4)]
22:30:35 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
22:30:47 <mrd> @src MonadPlus
22:30:47 <lambdabot> Source not found. Wrong!  You cheating scum!
22:30:57 <mrd> @src [] mplus
22:30:57 <lambdabot> mplus = (++)
22:31:00 <mrd> @src [] mzero
22:31:00 <lambdabot> mzero = []
22:31:34 <mrd> @src guard
22:31:34 <lambdabot> guard True  =  return ()
22:31:34 <lambdabot> guard False =  mzero
22:31:35 <jsnx> mrd: the '===' is here read as 'is equivalent to'
22:31:40 <mrd> jsnx: yes
22:31:45 <jsnx> mrd: great
22:31:52 <mrd> guard True ... do nothing
22:31:59 <mrd> guard False ... abort
22:32:17 <shachaf> In the list monad, return x = [x] and l >>= f = concat (map f l)
22:33:08 <mrd> wli: so, as in a non-deterministic turing machine, you can consider many branches of choices at once.  some of the branches end in accept, some end in reject, perhaps.
22:35:20 <wli> mrd: It's still rather far from what I'd consider effective use of monads.
22:35:57 <wli> e.g. the following is incomprehensible to me and I'm unable to produce anything of its kind: queen i j = do { free <- get ; guard (free i j) ; put (\x y -> y /= j && x+y /= i+j && x-y /= i-j && free x y) ; return j } ; queens n = evalStateT (sequence [msum (map (queen i) [1..n]) | i <- [1..n]]) (\_ _ -> True)
22:36:43 <Binkley> wli: use the pastebin :-)
22:36:44 <Binkley> @paste
22:36:45 <lambdabot> Haskell pastebin: http://hpaste.org/new
22:37:51 <wli> http://hpaste.org/1784#a1
22:38:32 <mrd> heh
22:38:36 <wli> I'm checking my answers against it, if that means anything.
22:38:41 <mrd> sure
22:38:45 <SoulChild> Hi can someone tell me what's wrong with this little programm:
22:38:47 <SoulChild> reihe 0 = 1
22:38:48 <SoulChild> reihe n = (((-1)^n)*(1/(n^2)))+reihe(x-1)
22:38:48 <mrd> interesting way of chaining things along
22:39:16 <SoulChild> *x=n
22:39:39 <mrd> wli: so do you see that it is using a State monad combined with a List monad? (I presume)
22:39:45 <wli> Well, I basically hacked mine to death, so I barely understand what's going on even in what I wrote.
22:39:55 <SoulChild> i am getting this message: ERROR - Unresolved overloading
22:40:10 <wli> mrd: I noticed a StateT thing in there. Some sort of monad transformer business I'm totally clueless about.
22:40:11 <mrd> SoulChild: try giving it an explicit type signature
22:40:33 <SoulChild> mrd: ohh i can't,... i am not very experienced in haskell
22:40:34 <shachaf> wli: It keeps a function in the state.
22:40:40 <wli> My grip on ordinary monads is tenuous at best. Monad transformers? Forget it.
22:40:40 <mrd> wli: it means they want to use state and list at the same time
22:40:44 <TSC> SoulChild: What type is n supposed to have?
22:40:46 <shachaf> wli: Otherwise it's a list monad.
22:40:46 <Binkley> wli: the StateT thing just says, "Give me a monad and a state type"
22:40:49 <SoulChild> TSC int
22:40:59 <Binkley> "and I'll give you a new monad that has the given state type, and does everything the other monad does, too"
22:41:16 <Binkley> only if you want to invoke the other monad's operations, you have to wrap them in a call to lift
22:41:34 <TSC> SoulChild: And what should the function return?
22:41:39 <wli> Which whoever this person was never did.
22:41:50 <SoulChild> TSC: Float
22:42:14 <mrd> SoulChild: also, where is (x-1) coming from?
22:42:28 <SoulChild> mrd: should be (n-1)
22:42:28 <wli> I see a rather mysterious sequence [msum (map (queen i) ...
22:42:29 <mrd> wli: well lets take it apart
22:42:32 <mrd> aha
22:42:39 <mrd> where i was going to start =)
22:42:55 <TSC> SoulChild: reihe n = (((-1)^fromIntegral n)*(1/(fromIntegral n^2))) + reihe (n-1)
22:42:57 <mrd> @src sequence
22:42:57 <lambdabot> sequence ms = foldr k (return []) ms
22:42:58 <lambdabot>     where
22:42:58 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
22:42:59 <mrd> hmm
22:43:06 <SoulChild> TSC thanks i ll try
22:43:17 <wli> sequence :: [m t] -> m [t]
22:43:22 <mrd> well, it means: do x1 <- firstThing; x2 <- secondThing; ....; return [x1,x2,...]
22:43:35 <TSC> SoulChild: I've just added fromIntegral infront of some of the ns
22:44:02 <mrd> do a list of things in order and return the results
22:44:09 <TSC> To allow them to be converted into Floats, for the calculation
22:44:10 <wli> mrd: threading implicit args through for state monads
22:44:29 <mrd> sure
22:44:40 <mrd> but also collecting all possible results for the list monad
22:44:46 <mrd> @src msum
22:44:47 <lambdabot> msum =  foldr mplus mzero
22:44:56 <SoulChild> TSC great, it works
22:45:03 <TSC> Great!
22:45:07 <wli> mplus == (++) for lists
22:45:11 <mrd> right
22:45:24 <mrd> so really this is like concat
22:45:43 <wli> msum (map ( ... == concatMap
22:45:47 <mrd> but it "means", "try the things in this list"
22:45:51 <shachaf> > msum [[1,2,3],[4,5,6]]
22:45:53 <lambdabot>  [1,2,3,4,5,6]
22:46:09 <pastorn> ?src msum
22:46:10 <lambdabot> msum =  foldr mplus mzero
22:46:19 <pastorn> ?src mplus
22:46:19 <lambdabot> Source not found. I feel much better now.
22:46:29 <wli> The sequence has to be acting on the state vs. the list.
22:46:31 <pastorn> ?type mplus
22:46:32 <shachaf> @src MonadPlus
22:46:33 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
22:46:33 <lambdabot> Source not found. My pet ferret can type better than you!
22:46:39 <mrd> queen i 1 `mplus` queen i 2 ...
22:46:57 <mrd> the 'guard' above goes along with this use of mplus
22:47:28 <mrd> basically it will only collect the results which pass the guard
22:47:29 <wli> Not sure what the guard does. The type doesn't tell me much.
22:47:43 <mrd> guard causes the non-deterministic machine to reject if the test fails
22:48:21 <mrd> (reject that branch of computation)
22:48:57 <wli> I don't get how we can return () in one place and return an int in another.
22:49:08 <mrd> return does not act like it is an imperative language
22:49:13 <mrd> it does not transfer control
22:49:22 <shachaf> wli: This is in a do.
22:49:23 <mrd> it's kinda bad name.  better think of it as 'wrap'
22:49:41 <shachaf> > do { return (); return 'a'; return 5 } :: Maybe Int
22:49:42 <lambdabot>  Just 5
22:50:09 <shachaf> > return () >> return 'a' >> return 5 :: Maybe Int
22:50:10 <lambdabot>  Just 5
22:50:11 <mrd> wrapped (), wrapped 'a', wrapped 5.  the last expression gets returned: wrapped 5.
22:50:31 <wli> You can't do if ... then return () else return 5
22:50:45 <wli> s/return// if need be
22:50:48 <shachaf> > return () >>= (\_ -> return 'a' >>= (\_ -> return 5)) :: [Int]
22:50:50 <lambdabot>  [5]
22:50:54 <mrd> wli: guard always returns ()
22:51:14 <wli> mrd: It's the conditional voodoo.
22:51:26 <shachaf> @ty mzero
22:51:28 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
22:51:48 <shachaf> wli: For any a, including (), mzero is :: m a.
22:51:54 <mrd> wli: guard is like doing:  do { ...; if test then return () else mzero; ...; return result }
22:52:04 <shachaf> wli: So return () :: m () and mzero :: m () have the same type.
22:52:14 <wli> mrd: somehow it sneaks mzero in there, okay
22:52:18 <mrd> @src guard
22:52:19 <lambdabot> guard True  =  return ()
22:52:19 <lambdabot> guard False =  mzero
22:52:33 <shachaf> @src [] mzero
22:52:33 <lambdabot> mzero = []
22:52:45 <wli> Aha, it only returns () if it *SUCCEEDS* then
22:53:05 <mrd> @src [] return
22:53:06 <lambdabot> return x    = [x]
22:53:15 <shachaf> > [(x,y,z) | x <- [1,2,3], y <- [], z <- [4,5,6]]
22:53:16 <lambdabot>  []
22:53:19 <shachaf> > [(x,y,z) | x <- [1,2,3], y <- [()], z <- [4,5,6]]
22:53:19 <mrd> yes. because mzero == abort the computation.
22:53:20 <lambdabot>  [(1,(),4),(1,(),5),(1,(),6),(2,(),4),(2,(),5),(2,(),6),(3,(),4),(3,(),5),(3,...
22:53:23 <wli> mzero is an empty list of ()'s
22:53:32 <shachaf> See, return mzero is just [()].
22:53:43 <shachaf> So it's the difference between one element and zero elements.
22:53:45 <mrd> and mzero is the empty list
22:53:48 <shachaf> s/return //
22:53:56 <shachaf> I mean...
22:54:02 <shachaf> return () is just [()].
22:54:12 <mrd> wli: if you stuck "foo <- []" in the middle of your monad it would have the same effect as mzero.  no choices, therefore you cannot proceed.
22:54:19 <wli> Whenever you hit zero elements the concatMaps you chain things with all have 0 elements.
22:54:40 <wli> I think (>>=) is concatMap or flip concatMap or some such.
22:54:45 <mrd> yes
22:54:51 <glguy> the flip one
22:55:03 <shachaf> Since [] is :: [a] for any a, it's also :: [()].
22:55:11 <shachaf> So they have a matching type.
22:55:39 <pastorn> @hoogle MonadPlus
22:55:40 <lambdabot> Control.Monad.MonadPlus :: class Monad m => MonadPlus m
22:57:28 <wli> So the way nondeterminism works is filtering and concatMap and once some "branch" (it all looks flat in reality) hits an empty list it gets "backtracked."
22:57:47 <Cale> wli: yes
22:57:52 <wli> Basically by vanishing from the worklist.
22:58:02 <wli> Okay, this I can understand.
22:58:04 <Cale> wli: It simultaneously looks like a tree and a flat list
22:58:45 <wli> Okay, now I have to find a different problem to put it into practice.
22:58:56 <Cale> In fact, it looks like a tree working its way down to a list, and some of the branches don't make it
22:59:24 <wli> Cale: From the graph reduction / spine unwinding POV sure.
22:59:33 <Cale> yeah
23:19:42 <glguy> welcome back!
23:24:08 <hpaste>  zeeeee pasted "how do i interleave io writes?" at http://hpaste.org/1785
23:25:04 <zeeeee> i guess i don't understand how to force the sequence_ while not having it hold up all other IO
23:26:02 <glguy> zeeeee: you mean like: forkIO?
23:26:48 <hpaste>  zeeeee annotated "how do i interleave io writes?" with "a simpler version, with no sequence_" at http://hpaste.org/1785#a1
23:26:49 <SoulChild> !haskell
23:27:54 <zeeeee> glguy: do i really need to start another system thread to do this?
23:28:23 <zeeeee> (imagine the second putStrLn is actually an hPutStrLn to a log file, so that i'm writing my output to both stdout and a log)
23:29:12 <Binkley> forkIO doesn't start an OS thread
23:29:32 <zeeeee> whoops, i misread that
23:29:43 <zeeeee> ok, so threads are the answer?
23:30:20 <zeeeee> should i be streaming my inputs/outputs via a Chan?
23:30:35 <zeeeee> i just thought there is a lighter-weight approach
23:32:25 <zeeeee> i'd like to write an interact, but where inputs and outputs are logged
23:34:34 <lispy> isn't the point of interact that your action is pure code?
23:34:49 <lispy> or do you mean re-write interact to do this automatically?
23:35:00 <zeeeee> lispy: latter
23:35:43 <lispy> ah, that could be cool
23:35:47 <lispy> ?src interact
23:35:47 <lambdabot> interact f = do s <- getContents; putStr (f s)
23:36:16 <lispy> not much code to change :)
23:36:24 <zeeeee> lispy: i apparently need threads
23:36:58 <zeeeee> indeed, i just wrote it with threads, and it works...just wondering if i could do this without them
23:38:51 <zeeeee> i guess the question boils down to whether i can prevent putStrLn from blocking other IO operations (unsafeInterleaveIO seems to make it not print altogether)
23:40:00 <lispy> are you logging to network sockets or something? and why is it okay for logging to be out of sync with the surrounding IO?
23:40:15 <zeeeee> lispy: no, in the example i was just logging to stdout again
23:40:22 <zeeeee> but in reality i will be logging to a file
23:40:25 <zeeeee> shouldn't matter
23:40:45 <zeeeee> lispy: i'm not sure what you mean 'out of sync with the surrounding io'
23:40:57 <lispy> i would think in the most advanced case all you'd want at most is a timeout on the logging so that if it can't log you don't wait forever
23:41:29 <lispy> in all the cases i'm thinking of you want the logging to by synchronous with the IO that your interact is dealing with
23:41:53 <lispy> you read a line, log it, transform it, log it and then print it
23:42:23 <lispy> i'm not creative enough to imagine allowing it in a different sequence (hence, what use is threading)
23:42:41 <zeeeee> lispy: i think you're misunderstanding...if you compare the behavior of the third annotation with the others, you'll see what i was looking for / what the first two were doing instead
23:43:01 <hpaste>  zeeeee annotated "how do i interleave io writes?" with "with threads, works" at http://hpaste.org/1785#a2
23:43:06 <zeeeee> er second annotation, third paste
23:44:30 <zeeeee> putStrLn is blocking, unlike writeChan and getContents
23:45:04 <Cale> The reason that you don't see the effects of the action wrapped by the unsafeInterleaveIO is that you're throwing away the result of that computation.
23:45:38 <lispy> :t (>>>)
23:45:49 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
23:46:22 <Cale> unsafeInterleaveIO specifically takes an action and turns it into one which does nothing but immediately returns a result such that the evaluation of that result will cause the original action to be performed.
23:46:22 <zeeeee> lispy: i like left-to-right instead of (.)'s right-to-left... i like pipes :)
23:46:22 <Cale> If you throw that away, the attached action never be run.
23:46:22 <Cale> will*
23:46:22 <wli> Oh dear... arrows. Give me a few more years before I get to those.
23:46:22 <zeeeee> Cale: should i force it with seq?
23:46:25 <dolio> It'd need to be more like "mapM_ (unsafeInterleaveIO . putStrLn) output" anyway, wouldn't it?
23:46:33 <wli> I've got a day job and a social life. It'll be a while.
23:46:36 <zeeeee> wli: i don't know arrows either, really...but >>> has proven very handy
23:46:36 <Cale> You could, but it wouldn't really serve a purpose.
23:46:52 <zeeeee> Cale: so it is impossible to interleave putStr?
23:46:59 <zeeeee> i mean, without a separate thread
23:47:06 <lispy> so is >>> the opposite order of (.)?
23:47:10 <zeeeee> lispy: yeah
23:47:14 <lispy> foo . bar == bar >>> foo
23:47:27 <Cale> I'm trying to understand what you want to achieve. You could just start up another thread and print a bunch of output concurrently with your main thread.
23:48:08 <zeeeee> Cale: that's exactly what i ended up doing
23:48:08 <Cale> The result would be a random interleaving of the output of both threads.
23:48:08 <zeeeee> Cale: in this case, yes, since i'm printing to stdout in both threads
23:48:13 <zeeeee> Cale: but what i will ultimately do is log to a file in one, and write to stdout in the other
23:48:39 <lispy> why do you need threads to do that?
23:48:44 <zeeeee> it's just that writeChan does not block in a similar way, so i thought there might be some way to get putStr to behave similarly
23:49:05 <zeeeee> lispy: that's my question, i guess...tell me how to do it without threads
23:49:24 <lispy> where "it" = logging to both the screen and a file?
23:49:39 <zeeeee> lispy: yeah
23:50:17 <Cale> Er, just print the messages in turn to the log and stdout?
23:50:17 <zeeeee> Cale: that would require explicit prints for each line/char/(some arbitrary self-chosen unit), wouldn't it?
23:50:21 <lispy> and if you want to prepare for the worst case with logging you could try to catch any exceptions and also add a timeout on the write
23:50:22 <Cale> yes
23:50:31 <zeeeee> Cale: i'm striving for higher-level here :)
23:50:46 <jsnx> zeeeee: how would you like it to work?
23:51:24 <Cale> But what good is a log that doesn't reflect the current progress of the computation?
23:51:24 <Cale> If you just want to always log everything, you could write a version of putStrLn which did that.
23:51:36 <lispy> (or use tee)
23:51:52 <Cale> yeah, or use tee :)
23:51:55 <zeeeee> lispy: tee doesn't support timestamping
23:52:03 <zeeeee> at least not mine
23:52:20 <lispy> fair enough, but i'm sure there is a gnu tee or at least open source version :)
23:53:26 <lispy> but, back to the point, i agree with Cale, he's been more eloquent, but those are the points i was trying to make too
23:53:26 <zeeeee> ok
23:56:48 <lispy> i tihnk there are things you could do to hide the targets (the log files)
23:56:59 <lispy> or you could process them in a list (maybe use mapM_)
23:57:10 <lispy> that way you could have an arbitrary number of them
23:58:23 <lispy> i think arbitrary is my favorite number
23:58:42 * wli should write down what he goes through during the learning process.
23:59:07 <wli> I think state monads are still fresh enough in my mind for it, too.
