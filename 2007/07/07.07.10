00:03:36 <JohnMeacham> Hello.
00:03:36 <lambdabot> JohnMeacham: You have 2 new messages. '/msg lambdabot @messages' to read them.
00:14:00 <dons> plan for hackathon at ICFP/Freiburg this year: http://haskell.org/haskellwiki/Hac_2007_II
00:14:01 <lambdabot> Title: Hac 2007 II - HaskellWiki
00:14:26 * wli derives a recurrence for the matrix entries he needs.
00:14:26 <dons> i wonder if i can get apfelmus to attend and write code for us.
00:18:38 <mm_freak> which exception does `read' throw, when the input is invalid?
00:19:25 <opqdonut> ?src read
00:19:26 <lambdabot> read s = either error id (readEither s)
00:19:42 <mm_freak> hmm
00:19:48 <opqdonut> just your run-of-the-mill error
00:19:56 <dons> use reads to wrap your own monad-fail version
00:20:00 <dons> :t reads
00:20:03 <lambdabot> forall a. (Read a) => String -> [(a, String)]
00:20:41 <dons> readM :: (Monad m, Read a) => String -> m a
00:20:42 <dons> readM s = case [x | (x,t) <- {-# SCC "Serial.readM.reads" #-} reads s    -- bad!
00:20:45 <dons>                , ("","")  <- lex t] of
00:20:47 <dons>         [x] -> return x
00:20:50 <glguy> :t readIO
00:20:50 <dons>         []  -> fail "Serial.readM: no parse"
00:20:51 <dons> ignore my SCC pragmas ;)
00:20:52 <lambdabot> forall a. (Read a) => String -> IO a
00:20:53 <dons>         _   -> fail "Serial.readM: ambiguous parse"
00:20:56 <glguy> ?src readIO
00:20:56 <lambdabot> Source not found. Are you on drugs?
00:21:24 <dons> readIO is much the same, but with ioError
00:21:43 <dons> readIO s        =  case (do { (x,t) <- reads s ;
00:21:44 <dons>                               ("","") <- lex t ;
00:21:44 <dons>                               return x }) of
00:21:44 <dons>                         [x]    -> return x
00:21:44 <dons>                         []     -> ioError (userError "Prelude.readIO: no parse")
00:21:47 <dons>                         _      -> ioError (userError "Prelude.readIO: ambiguous parse")
00:21:54 <glguy> :t lex
00:21:56 <dons> hmm. we really should ditch readIO, and just have readM
00:21:59 <lambdabot> String -> [(String, String)]
00:22:36 <glguy> what does ("","") <- lex t enforce?
00:22:43 <glguy> rather than (x,"") <- reads s
00:22:53 <dons> that there's no left over tokens or unparsed stuff
00:23:07 <glguy> ?src lex
00:23:08 <lambdabot> Source not found. Wrong!  You cheating scum!
00:23:09 <dons> > reads "'x' 'y'"
00:23:10 <lambdabot>  []
00:23:19 <mm_freak> i've read in GHC's user guide, that `read' is inefficient and makes binaries huge…  is this true?  are there alternatives?  (i don't feel like writing a parser for this)
00:23:24 <opqdonut> > lex "'x' 'y'"
00:23:26 <lambdabot>  [("'x'"," 'y'")]
00:23:26 <sjanssen> > lex "     "
00:23:28 <lambdabot>  [("","")]
00:23:37 <dons> mm_freak: its ok. it doesn't make them huge, it does add hmm 50k
00:23:38 <sjanssen> glguy: it must allow for spaces at the end
00:23:41 <glguy> sjanssen: so, "allow trailing white space"
00:23:43 <glguy> sjanssen: ok, cool
00:23:46 <dons> for String parsing, its simple and easy
00:24:50 <opqdonut> can i get more fine-level profiling then the module-level stuff -p offers?
00:25:10 <mm_freak> handleJust errorCalls (\e -> putStrLn "test" >> exitFailure) (interpretOptions defaultOpts opts)
00:25:13 <opqdonut> also: is array lookup expensive
00:25:20 <mm_freak> doesn't work…  it simply doesn't catch the error
00:25:23 <dons> opqdonut: ?
00:25:27 <dons> its O(1)
00:25:39 <opqdonut> yeah, so i'd guess
00:25:49 <glguy> my puppy is adorable :) when he comes up to me while I'm sitting to get his belly rubbed, he stands on his back legs, and balances himself with one paw on my chest
00:25:50 <dons> its usually just a pointer dereference with bounds checks
00:25:52 <Cale> opqdonut: you can add cost centres wherever you like
00:25:59 <opqdonut> how do i do that?
00:26:15 <dons> main = print $ {-# SCC "this expr" #-} 1 + 2
00:26:16 <mm_freak> opqdonut: read the GHC user guide…  it's pretty easy
00:26:17 <glguy> then if I scratch his back he just kind of leans back into it
00:26:17 <Cale> {-# SCC descriptive_name_of_expression #-}
00:26:26 <Cale> er, yeah
00:26:49 <Cale> the quotes are needed
00:27:13 <Cale> also, note that -auto-all will add SCC's to all your top-level declarations.
00:28:06 <opqdonut> ahh!
00:28:15 <opqdonut> that was the thing i was missing :)
00:29:50 <mm_freak> even `handle' completely ignores `read' errors…  what's wrong?!
00:30:27 <mm_freak> read errors for Int that is
00:31:21 <mm_freak> aaaaaaah…  my mistake…  man, am i dumb…
00:33:48 <dons> what are these characters you type, mm_freak:â¦' ?
00:34:11 <opqdonut> hmmm, what prelude data structure would you recommend for two-way lookups
00:34:27 <dons> two Maps? or [(a,b)].
00:34:28 <opqdonut> atm i'm using an array and the reverse lookup (search) is killing performance
00:34:38 <opqdonut> yeah thought about two maps
00:34:43 <opqdonut> or an array and a map
00:34:46 <dons> yeah
00:34:53 <dons> esp. if reverse lookups are rare
00:35:07 <dons> (then you'll only generate the bits of the Map you need)
00:35:09 <mm_freak> dons: utf-8
00:35:13 <opqdonut> reverse lookups are about as common as forward lookups
00:35:21 <opqdonut> s/forward/normal/
00:35:26 <mm_freak> dons: http://streitmacht.eu/scrshot.png
00:35:36 <Cale> We really need an efficient relation data type in the libraries.
00:36:12 <opqdonut> dons: would you say [(a,b)] would be usable with list lengths of about 40
00:36:22 <dons> ah mm_freak  I see :)
00:36:37 <glguy> dons: what irc client do you use?
00:36:41 <dons> opqdonut: 40, I'd imagine so. but you said Arrays are already too slow?
00:36:41 <Cale> opqdonut: yes, though if you have lots of lookups to do, it still might hurt a bit
00:36:56 <dons> so other O(n) structures wouldn't be suitable
00:37:02 <dons> glguy: irssi, no utf8
00:37:08 <dons> bytestring land ;)
00:37:10 <glguy> openbsd's xf86 package comes with uxterm, and irssi supports utf-8
00:37:19 <glguy> you use bytestrings in irssi?
00:37:22 <opqdonut> well the problem is i have quite many of these 40-ish arrays
00:37:39 <opqdonut> and reverse lookup is taking most of my execution time
00:38:00 <dons> glguy: yeah, i'm using urxvt and uxterm, but irssi doesn't handle unicode either, out of the ports tree
00:38:11 <dons> oh, maybe its my font now.
00:38:23 <glguy> dons: do you use the default iso8859-1 fixed font?
00:38:31 <dons> i am currently, in uxterm
00:38:33 <glguy> iso10646-1 of the same font is quite complete
00:38:42 <dons> let's try that
00:39:03 <opqdonut> where can i find the time constraints of the Array operations?
00:39:10 <opqdonut> isn't bounds O(1)
00:39:12 <glguy> you also might have to set: LANG=en_GB.UTF-8 (I don't know if you use US, GB, AU...)
00:39:23 <Cale> 日本語
00:39:35 * glguy sees the pretty asian letters
00:39:40 <mm_freak> me too
00:39:48 <glguy> double wide :)
00:39:55 <Cale> ：）
00:40:20 <glguy> is that a triple-wide colon?
00:40:28 <glguy> oh
00:40:29 <mm_freak> but what i like much more about utf-8 is it's math side:  √2 ≈ 1.4142135623730950488, 2 ∈ ℝ
00:40:30 <glguy> nvm
00:40:37 <dons> glguy: -misc-fixed-medium-r-normal--0-0-100-100-c-0-iso10646-1 ?
00:40:37 <glguy> there is a space over your nick :)
00:40:52 <mm_freak> lim(x → 0) 1/0 = ∞
00:40:53 <glguy> dons: I don't know about those zeros
00:40:56 <Cale> Yeah, ∫f(x)dx
00:41:10 <mm_freak> hehe
00:41:14 <mm_freak> ϕ(15) = 8
00:41:23 <Cale> (α -> β -> β) -> β -> [α] -> β
00:41:41 <glguy> dons: I don't have access to xfontsel atm to check
00:41:51 <glguy> but the rest looks familiar
00:41:52 <mm_freak> naïve: ℜ(3 + 4i) = 3
00:42:08 <glguy> xterm has a -fn flag, or a XTerm*font:   (in ~/.Xresources)
00:42:20 <sjanssen> dons: you can also use nice xft fonts in urxvt
00:42:21 <mm_freak> i'm using the Gagarin font…  it's pretty beautiful
00:42:25 <Cale> I have my keyboard set up such that pressing both alt keys at the same time puts me in Greek mode, and use SCIM for typing mathematics and Japanese.
00:42:56 <Cale> Also, Caps Lock is compose :)
00:43:07 <mm_freak> i'm just using xmodmap to bind some of the characters i use frequently to certain keys
00:43:18 <sjanssen> URxvt*font: xft:Bitstream Vera Sans Mono:pixelsize=12
00:43:28 <Cale> It would be nice to know how to edit compose bindings.
00:43:36 <mm_freak> #define URXVT_FONT xft:Gagarin:pixelsize=10:semicondensed
00:43:46 <Cale> I should really figure that out sometime.
00:43:52 <glguy> does this look like a ellipsis? 
00:44:02 <Cale> glguy: no, though mm_freak's did.
00:44:05 <mm_freak> glguy: nope
00:44:08 <glguy> …
00:44:09 <glguy> that?
00:44:11 <Cale> yes
00:44:13 <mm_freak> mine does: …
00:44:17 <mm_freak> just like my m-dash: —
00:44:26 <Cale> ­—
00:44:31 <dons> sjanssen: do you need to set any LANG settings? or other UTF8 stuff?
00:44:31 <Cale> Compose - - -
00:44:33 <glguy> —
00:44:45 <dons> since i'm using urxvt, URxvt*font: xft:Bitstream Vera Sans Mono:style=Roman:pixelsize=16
00:44:48 <glguy> Cale: your em-dash is two parted :)
00:45:02 <Cale> glguy: hmm, interesting :)
00:45:07 <Cale> It doesn't appear like that to me.
00:45:12 <glguy> Cale: looks like a regular dash and then an emdash
00:45:13 <sjanssen> dons: I've got LANG=en_US.utf8 in .zshrc
00:45:23 <sjanssen> dons: that is probably required to make irssi speak UTF-8
00:45:26 <Cale> Curious :)
00:45:29 <mm_freak> i used to use “real quotes”…  but unfortunately many fonts don't display them correctly
00:45:42 * glguy has LANG=en_US.UTF-8  do those translate to the same thing?
00:45:57 <sjanssen> glguy: they must
00:46:02 <mm_freak> sjanssen: it isn't
00:46:11 <Cale> mm_freak: You can still use ``TeX quotes''.
00:46:15 * glguy would love to have -misc-fixed-*-*-*...-*-iso10646-1 on his windows box
00:46:17 <mm_freak> you just need to tell irssi that it's in a UTF-8-capable terminal
00:46:19 <dons> setting locale failed. somethings not quite right.
00:46:29 <mm_freak> cale: that's what i do for ‘single quotes’ =)
00:46:54 <glguy> .. /set term_charset UTF-8
00:47:10 <glguy> is a way to force it
00:47:16 <glguy> but not needed if things are set up correctly
00:47:28 <mm_freak> here are my settings:
00:47:29 <mm_freak> 210 094633 recode_autodetect_utf8 = ON
00:47:29 <mm_freak> 210 094633 recode_fallback = ISO-8859-1
00:47:29 <mm_freak> 210 094633 recode = ON
00:47:34 <mm_freak> 210 094647 term_charset = UTF-8
00:47:43 <sjanssen> dons: what does putStrLn "\226\128\166" output?
00:47:52 <sjanssen> rather, how does it display
00:48:16 <glguy> ?read "\226\128\166 "
00:48:17 <lambdabot>  …
00:48:41 <dons> sjanssen: a couple of funny things, same as 'â¦'
00:48:53 <sjanssen> so urxvt isn't expecting UTF-8
00:49:26 <sjanssen> dons: it should be a single character that looks like ...
00:49:30 <opqdonut> agh, can't use map
00:49:59 <opqdonut> at least not in the naive way, i need to have multiple results for reverse lookip
00:50:01 <dons> sjanssen: yeah, i see from the screenshot
00:50:02 <opqdonut> *lookup
00:50:38 <glguy> opqdonut: what problem are you trying to solve specifically?
00:51:18 <glguy> you have a 1 -> N relationship? and you need to perform a lookup in both directions?
00:51:19 <mm_freak> dons: maybe my .Xresources file helps
00:51:29 <mm_freak> http://streitmacht.eu/Xresources
00:51:45 <glguy> to reload an .Xresources: xrdb -l ~/.Xresources
00:52:31 <opqdonut> glguy: yeah, a 1<->N mapping with lookup in both directions
00:52:45 <mm_freak> glguy: -l is default anyway
00:52:52 <mm_freak> just: xrdb < ~/.Xresources
00:52:52 <glguy> opqdonut: so just maintain two Data.Map.Map s?
00:52:59 <glguy> opqdonut: Map a b    and   Map b [a]
00:53:06 <opqdonut> atm i'm implementing a (Array index val,Map val [index])
00:53:12 <opqdonut> yeah, guess i could make them both maps
00:53:27 <sjanssen> dons: so "LANG=en_US.utf8 urxvt" still doesn't work?
00:53:45 <glguy> adding an element to two maps is still O(log n) :)
00:54:34 <opqdonut>  well the point is the structure is pretty immutable
00:55:32 <yakov> hi
00:55:51 <quicksilver> sjanssen: you still about?
00:55:56 <sjanssen> quicksilver: yep
00:56:07 <quicksilver> sjanssen: ok, pasting my version
00:56:33 <hpaste>  quicksilver pasted "callbacks in a custom monad" at http://hpaste.org/1592
00:56:52 <glguy> ﴾test﴿
00:56:59 <quicksilver> sjanssen: I haven't done the type-class hackery needed to abstract out the monad
00:57:06 <quicksilver> sjanssen: it's very concrete in this example
00:57:33 <hpaste>  quicksilver annotated "callbacks in a custom monad" with "oh, and the output" at http://hpaste.org/1592#a1
00:59:47 <glguy> what does the IORef plumbing buy you?
01:00:07 <quicksilver> glguy: the ability to use a custom monad for your program
01:00:15 <quicksilver> glguy: and still export plain IO () callbacks
01:00:22 <quicksilver> glguy: to use with a C library that has callbacks
01:00:25 <quicksilver> (e.g. gtk2hs)
01:00:28 <sjanssen> quicksilver: of course we have trouble if the callback is asynchronous
01:00:31 <dons> sjanssen: perl: warning: Setting locale failed yeah :/ my openbsd is too old i suspect
01:00:42 <quicksilver> sjanssen: yes, big trouble then :)
01:00:44 <glguy> how old is too old?
01:01:00 <quicksilver> sjanssen: well asynchronous is OK as long as its strictly single threaded
01:01:11 <quicksilver> sjanssen: but asynchronous in multiple threads is no good
01:01:14 * vincenz found a cool data structure in haskell :)
01:01:38 <quicksilver> sjanssen: e.g. gtk2hs has a single-threaded event handler I believe
01:01:49 <quicksilver> sjanssen: and one can consider using MVars instead of IORefs...
01:02:19 <sjanssen> quicksilver: but what happens with the caller of usesCB reads the IORefs before the action actually runs?
01:02:26 <sjanssen> s/with/when
01:03:12 <quicksilver> sjanssen: it can't. the IORefs are 'local'
01:03:18 <quicksilver> sjanssen: they only exist in the scope of that \x ->
01:03:46 <quicksilver> still it's really a single-threaded paradigm, definitely
01:03:59 <quicksilver> StateT and friends have a distinctly 'single-threaded' feel to them
01:04:10 <sjanssen> right
01:04:33 <quicksilver> if it was just a ReaderT of course it wouldn't matter a jot
01:04:47 <sjanssen> you can't express threading (with the associated non-determinism) in the pure StateT
01:04:54 <quicksilver> so the readerT version would work ok even in a multi-thread/async setting
01:05:12 <quicksilver> sjanssen: still, synchronous callbacks are a useful subcase
01:05:19 <sjanssen> right
01:05:20 <quicksilver> sjanssen: you get them in the 'iteratee' pattern
01:05:35 <sjanssen> 'alloca' is a synchronous callback
01:05:37 <quicksilver> callback for each row of the database fetched, or something
01:05:38 * quicksilver nods
01:05:51 <quicksilver> :t alloca
01:05:53 <lambdabot> Not in scope: `alloca'
01:06:08 <sjanssen> :t Foreign.alloca
01:06:11 <lambdabot> forall a b. (Foreign.Storable.Storable a) => (GHC.Ptr.Ptr a -> IO b) -> IO b
01:08:08 * quicksilver nods
01:08:11 <quicksilver> yes, it would work for that
01:08:24 <quicksilver> it's a lexical solution, fundamentally
01:08:46 <quicksilver> give your callback lexical access to some 'blob' of monad state which enables it to reconstruct the custom monad
01:11:56 <Saizan> uhm, i wonder if i can use this to share an environment between threads, which the main one writes and the others read
01:13:09 <quicksilver> Saizan: that's actually easier
01:13:21 <quicksilver> Saizan: the only reasno this was hard was to allow it to work with external libraries
01:13:27 <quicksilver> (libraries which don't know about your custom monad)
01:13:56 <quicksilver> if you just want to share an environment between threads, then an IORef should be enough
01:14:04 <quicksilver> IORefs are safe if only one thread writes, I believe
01:15:45 <Saizan> they don't give a strong semantic about which state of the env is seen by the threads in each moment
01:27:16 <hpaste>  sjanssen pasted "WithT: final solution to the alloca/callback problem?" at http://hpaste.org/1593
01:27:43 <sjanssen> quicksilver: http://hpaste.org/1593 seems powerful enough to do both alloca and callback style operations
01:28:03 <glguy> hpaste is pretty powerful
01:28:14 <glguy> :-p
01:28:34 <opqdonut> what is the alloca/callback problem?
01:28:54 <opqdonut> and what is WithT :)
01:29:00 <sjanssen> @type alloca
01:29:03 <quicksilver> sjanssen: hmm intersesting
01:29:03 <lambdabot> Not in scope: `alloca'
01:29:09 <sjanssen> @type Foreign.alloca
01:29:11 <lambdabot> forall a b. (Foreign.Storable.Storable a) => (GHC.Ptr.Ptr a -> IO b) -> IO b
01:29:32 <sjanssen> opqdonut: alloca temporarily allocates some memory, then runs your IO action
01:29:56 <sjanssen> opqdonut: we want to use arbitrary monad transformers rather than fuddy-duddy IO
01:30:16 <opqdonut> oh okay
01:30:19 <hpaste>  quicksilver annotated "callbacks in a custom monad" with "type class version" at http://hpaste.org/1592#a2
01:30:48 <quicksilver> sjanssen: there's a type class version of my solution
01:30:58 <quicksilver> sjanssen: although I didn't parameterise over IO, just over the 'outer' monad
01:31:20 <quicksilver> and I didn't bother with the fundeps because I don't like fundeps much :P
01:33:58 <quicksilver> sjanssen: trying to understand why your version doesn't need IORefs for the state instance
01:37:31 <sjanssen> quicksilver: "forall b" is the key
01:37:45 * quicksilver nods
01:37:55 <quicksilver> I just tried your version with my example code
01:38:02 <quicksilver> (showing the state incremented during the callback)
01:38:05 <quicksilver> it works, of course
01:38:06 <sjanssen> quicksilver: that lets you extend the action with the plumbing needed to return modified state
01:39:33 <quicksilver> do {stateact ; extend usesCB stateact ; stateact }
01:39:38 <quicksilver> ^^ this works :-)
01:42:13 <quicksilver> sjanssen: but what if I want to 'extend' an action which isn't polymorphic?
01:42:24 <quicksilver> sjanssen: usesCB :: IO () -> IO Int, say
01:42:25 <sjanssen> that is a bit of a problem
01:42:56 <quicksilver> it seems like you're promising not to use the result of the action
01:46:00 <quicksilver> sjanssen: (forall b. (a -> m b) -> m b) <---- isn't this type a bit like "a"
01:46:34 <quicksilver> sjanssen: if you have a recipe to go, uniformly for any b, from (a->mb) to mb, then surely what you actually have is the parameter a ?
01:48:53 <sjanssen> I might need to change the type to (forall b. (a -> m b) -> m (x, b)) -> (a -> t m c) -> t m (x, c)
01:49:38 <quicksilver> that looks plausible, maybe
01:49:47 <sjanssen> still isn't quite flexible enough, I think
01:50:04 <sjanssen> (forall b. (a -> m (x, b)) -> m (x, b)) -> (a -> t m c) -> t m (x, c)
01:50:37 <quicksilver> what is the point of the quantified b? what's it ensuring?
01:50:58 <sjanssen> we can't know the type of b because it depends on the monad
01:50:59 <Saizan> that you can have your runTrans return your desired "state"
01:51:09 <sjanssen> for (StateT s), b == s
01:51:23 <sjanssen> for (ReaderT r), b is essentially ()
01:52:12 <Saizan> why not use a MPTC?
01:52:46 <sjanssen> Saizan: I'm trying not to leak those details if possible
01:53:51 <quicksilver> ah, right
01:59:20 <Saizan> so the problem is when the handler of the callback is not polymorphic enough in the return type, but in this case you need an IORef to get the 'state' out, i think
01:59:40 <quicksilver> well my solution used an IORef
01:59:45 <quicksilver> but sjanssen's seemed cleverer :)
02:01:17 <sjanssen> quicksilver: can your system do "usesCB :: IO () -> IO Int"?
02:02:27 <dons> hmm, if foldr is that natural catamorphism for lists, what do we give to a head/tail inspection?
02:03:05 <dons> f :: (a -> b) -> ([a] -> b) -> [a] -> b -- that guy.
02:03:07 <dons> dibblego: around?
02:03:41 <sjanssen> dons: a shallower catamorphism?
02:04:01 <dons> yeah, specifically non-recursive ones.
02:04:22 <dons> which are useful since they're always inlinable.
02:04:32 <quicksilver> sjanssen: yes
02:05:24 <Cale> dons: hmm, might be worth calling that 'list'
02:06:03 <dons> yes, i think i've suggested that in the past.
02:06:07 <sjanssen> what is the reasoning that the catamorphism on lists is "deep"?
02:06:56 <mgsloan> hmm, I think neil mitchell may have made a little typo in his blog.. maybe even a reasano
02:07:32 <Cale> Because capturing patterns of recursion is more interesting than just pattern matching.
02:08:46 <mgsloan> http://neilmitchell.blogspot.com/2007/07/equational-reasoning-in-haskell.html  (second snippet, first s should be string)
02:08:49 <lambdabot> Title: Neil Mitchell's Haskell Blog: Equational Reasoning in Haskell, http://tinyurl.com/37aez6
02:09:15 <mgsloan> even then, to do the equational reasoning you'd have to expand dropWhile
02:10:16 <wli> I use snd . head . dropWhile (\(x,y) -> abs (x - y) > 1e-14) $ zip zs (tail zs) where zs = iterate f x quite often.
02:11:09 <dons> these non-recursive (shallow) catamorphisms, wrapped in unfoldrs are interesting -- with a rewrite rule ghc will fuse such loops for free.
02:11:10 <wli> It sort of makes me wish an "iterate to convergence" combinator were floating around somewhere.
02:11:28 <wli> dons: Yeah, I'm a big fan of unfoldr, too.
02:11:58 <mgsloan> wli - you could make it into a function
02:12:09 <mgsloan> call it converge
02:12:10 <wli> mgsloan: I did, I called it "fixWhile"
02:12:15 <mgsloan> ah, good
02:12:30 <wli> mgsloan: I just can't be arsed to import my lib that has it.
02:13:04 <mgsloan> right, but in either case it should be a function
02:13:06 <Saizan> mgsloan: the first s is a pattern of the case .. of construct
02:13:13 <wli> I've got various other goodies, like the cantor pairing list function, twine/twine3, etc.
02:14:10 <Saizan> mgsloan: ah, no, wrong snippet, my bad ^^
02:14:10 <mgsloan> Saizan - it's case dropWhile isSpace s of
02:14:11 <wli> twine f g (x:xs) = f x : twine g f xs ; twine _ _ [] = []
02:14:15 <mgsloan> ah
02:15:30 <wli> intertwine = ((concat.).) $ flip $ zipWith (flip (:) . (:[]))
02:16:39 <wli> fixWhile p f x = snd . head . dropWhile (uncurry p) $ (dup $ zip . tail) . iterate f $ x
02:16:41 <sjanssen> dons: unfoldr (list ((Just . ) . (,)) Nothing)?
02:16:59 <sjanssen> dons: erm, the rule is that thing = id?
02:17:32 <sjanssen> where list f z [] = z; list f z (x:xs) = f x xs
02:18:24 <dons> sjanssen: well, i *think* you can do a simple stream fusion with 'list' and unfoldr. the bodies of stream-fusible defintiions are all are an unfoldr data type wrapping a non-recursive case analysis
02:18:32 <Cale> twine f g = zipWith ($) (cycle [f,g])
02:19:13 <dons> you'll need a rewrite rule to collapse consecutive unfoldrs, and common up the lists
02:19:34 <vincenz> Cale - The enumerator of mini patterns
02:19:58 <wli> Cale: I'm not sure cycle existed when I wrote it.
02:20:14 <Cale> When'd you write it?
02:21:09 <sjanssen> dons: are you reinventing destroy/unfoldr?
02:21:12 <wli> Cale: The datestamp says 2003 but I'm pretty sure it's more like 2000 or 2001 and the date stamp is due to an update for some compiler update breaking it.
02:21:43 <wli> Cale: It may, in fact, predate 2000 though I'm not 100% sure.
02:22:39 <Cale> cycle is in the Haskell 98 and 1.4 preludes.
02:22:42 <wli> 7 or 8 years and I'm getting totally left behind.
02:23:01 <wli> Cale: It didn't predate 1.4 so I'm off-base.
02:23:14 <wli> H98 would've had to be a couple of years late.
02:23:16 <dons> sjanssen: yep that's it. but with the perspective of streams -- i.e. that non-recursive bodies are the key to getting any fusion from the result.
02:23:17 <Cale> and 1.3 :)
02:24:04 <wli> Cale: I know all about zipWith ($) so I'm pretty sure it had to do more with not liking intermediate lists.
02:24:31 <Cale> yeah, that is an issue
02:26:03 <Cale> It was also in the 1.2 report, but the 1.0 report seems to have an almost blank page where PreludeList should be
02:26:19 <Cale> Kind of fun seeing how far back things go :)
02:27:11 <wli> So, one thing I notice in all these monad transformer -based interpreters is that there are certain IO nasties they don't seem to handle.
02:27:26 <dons> Cale, so i have a conjecture: almost all fun puzzles are solvable in less code in Haskell, due to the list monad. (we've seen two examples this week). To really steal the rug out, we need monad comprehensions too, to avoid icky filterMs and such.
02:27:41 <kral> ahoy
02:27:47 <Cale> dons: essentially, yes
02:27:50 <Cale> kral: hello
02:27:57 <dons> Cale, so list monad (hm... or maybe Logic) for solving puzzles questions in less code than anyone else -- its the new Haskell niche
02:28:01 <wli> Yeah, I want monad comprehensions back.
02:28:22 <wli> dons: ooh logic monad comprehensions would rock my world
02:28:36 <dons> yeah, that's 3/4 prolog right there -- with good syntax
02:28:38 <Cale> Actually, hmm, would monad comprehensions replace filterM?
02:28:52 <wli> ISTR the syntax didn't actually allow it.
02:28:53 <vincenz> dons: I get to speak in front of the local IEEE student branch about haskell \o/
02:28:53 <Cale> I suppose we could generalise the boolean conditions
02:29:03 <Cale> That is, support something like guardM
02:29:07 <dons> i suspect some of the uses of monadic stuff inside or outside list comprehensions could be floated out to a single monadic comprehension
02:29:17 <dons> vincenz: woot!
02:29:36 <dons> monad comprehensions just use the normal syntax, wli.
02:29:39 <dons> but with sexier types.
02:29:42 <Cale> guardM :: (MonadZero m) => m Bool -> m ()
02:30:01 <mgsloan> in my opinion, if do notation applies to all monads, comprehension notation should apply to all monads
02:30:02 * vincenz thinks nunmber types should be split up, if anythign
02:30:05 <dons> hmm, maybe we should start a wiki page for these puzzle-one-liners-solved-with-the-list-monad
02:30:08 <wli> So I'm wondering whether these monad tranformer things actually allow an interpreter to do IO on a program's behalf because thus far the examples don't seem to do such.
02:30:10 <Cale> That way you could encapsulate filterM nicely
02:30:15 <vincenz> mgsloan: it used to be that way
02:30:33 <wli> dons: I remember something strange like when monad comprehensions used to exist they didn't allow commas.
02:30:34 <dons> wli, isn't that exactly what they can do?
02:30:36 <mgsloan> makes sense
02:30:45 <dons> wli, EvalT IO
02:30:53 * vincenz wonders why monad comprehensions were removed in the first place
02:31:02 <dons> errors were confusing from comp1A
02:31:07 <wli> dons: Okay, next up is how to handle signals.
02:31:42 <Heffalump> you can do everything with do notation anyway
02:31:43 <Cale> In fact, it was removing monad comprehensions that was the source of almost all Haskell 98's ugliness relative to 1.4.
02:32:08 <Cale> There was a slippery slope effect which caused lots of other damage.
02:32:36 <Cale> Including MonadZero being merged into MonadPlus, and fail being added to Monad.
02:32:37 <wli> What kind of monad do you use to deal with getting smacked in the face by e.g. SIGPIPE or SIGALRM?
02:32:44 <Cale> wli: IO
02:32:54 <dons> register handlers in IO
02:33:15 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Posix-Signals.html
02:33:17 <lambdabot> http://tinyurl.com/2esvkl
02:33:20 <wli> This doesn't sound like it has an obvious translation to the monad transformer -based interpreter.
02:33:31 <Heffalump> I put some complicated tower of monad transformers into lambdabot to handle signals and exceptions and stuff.
02:33:40 <Heffalump> I'm not sure if someone has ripped it out yet.
02:33:50 <dons> we added more layers actually
02:33:56 <Cale> hehe
02:34:03 <dons> newtype LB a = LB { runLB :: ReaderT (IRCRState,IORef IRCRWState) IO a }
02:34:03 <dons>     deriving (Monad,Functor,MonadIO)
02:34:10 <dons> instance MonadReader IRCRState LB where
02:34:17 <dons> instance MonadState IRCRWState LB where
02:34:22 <dons> instance MonadError IRCError LB where
02:34:22 <Heffalump> oh, you split up RState and RWState
02:34:24 <wli> Well, the thought here is that when the SIGPIPE comes in you have to pass it along to the interpreted program somehow.
02:34:27 <dons> data IRCError = IRCRaised Exception | SignalCaught Signal deriving Show
02:34:28 <dons> :)
02:34:33 <Heffalump> I think the rest of it was mine.
02:34:35 <vincenz> dons: out of curiousity, I compiled lambdabot on Lemmih's box... nothing really works except logging
02:34:40 <vincenz> dons: to give you one example
02:34:47 <vincenz> 11:34 < vincenz> @leave
02:34:47 <vincenz> 11:34 < oasisbot> Plugin `system' failed with: IRCRaised Prelude.last: empty  list
02:34:48 <dons> Heffalump: yeah, there's a bit of threading and modules stuff on top of that now too
02:34:55 <dons> lbIO :: ((forall a. LB a -> IO a) -> IO b) -> LB b
02:34:55 <dons> lbIO k = LB . ReaderT $ \r -> k (\(LB m) -> m `runReaderT` r)
02:34:56 <vincenz> dons: and > fails silently, as well as all other commands
02:34:57 <dons> and glue code
02:35:35 <wli> Well, I think I'm on about a little more than the usual bit involving surviving signals.
02:35:38 <dons> Heffalump: all the fun stuff is in the modules now, which are stacked over your basic IRC monad
02:35:42 <dons> newtype ModuleT s m a = ModuleT { moduleT :: ReaderT (MVar s, String) m a }
02:35:44 <dons> that stuff
02:35:46 <dons>     deriving (Functor, Monad, MonadTrans, MonadIO, MonadError IRCError, MonadState t)
02:36:08 <dons> needs a rewrite from the ground up.
02:36:10 <dons> :}
02:36:12 <Cale> wli: Well, you have to be doing some work in IO somewhere, so perhaps you just set your handler to mark some flag such that on the next reasonable opportunity, the interpreted program has its signal handler interpreted.
02:36:29 <Heffalump> I think the static separation between code which expected to be connected and code which didn't was probably a mistake.
02:36:38 <Heffalump> it's neat, but overcomplicated for what it buys
02:36:39 <Cale> wli: If I understand at all what you mean.
02:36:51 <dons> Heffalump: yep.
02:36:54 <wli> Cale: yes, now how on earth that gets done with one of these monadic interpreter thingies is the question
02:37:20 <Cale> wli: Is the monadic interpreter written in a monad over IO?
02:37:24 <dons> Heffalump: and just the basic impurity of the core. we should have built up a more abstract layer that was QuickCheckable
02:37:37 <dons> which specified the IO that needed to occure
02:37:39 <Heffalump> how would that work?
02:37:50 <dons> the usual tricks involve interpreter-like systems
02:38:09 <dons> so you QC your AST, encoding some semantics for the ops of the irc `interpreter'
02:38:20 <Heffalump> fair enough
02:38:24 <dons> a bit like how xmonad uses a pure structure to encode all the X11 goodies
02:38:34 <Cale> wli: Or is it pure?
02:38:36 <wli> Cale: It can be if necessary. All that really matters is that the super-condensed monad transformer tricks can be used somehow. IOW I'm attempting to follow the monadic interpreter tutorials.
02:38:43 <Heffalump> not sure that's worth the effort in LB's case, but perhaps it is
02:38:45 <Cale> wli: If it's pure, how does the interpreted language do IO?
02:38:51 <Heffalump> a proper spec of how it interacts with IRC would be nice
02:39:18 <Cale> wli: Basically, the signals should be treated in a similar way to however your interpreted program gets its input.
02:39:41 <Heffalump> or as asynchronous exceptions within the interpreted program
02:39:51 <dons> the new raganworld post is intriguing. http://weblog.raganwald.com/2007/07/can-your-type-checking-system-do-this.html
02:39:53 <lambdabot> Title: raganwald: Can your type checking system do this?, http://tinyurl.com/2o6998
02:40:33 <dons> a dynamic lang guy making a plea to his comrades to check out real type systems/
02:41:03 <wli> Heffalump: Asynchronous exceptions are no problem provided there's some super-fancy way to make it all magically happen with a monad transformer.
02:41:27 <dons> "Of course there is the problem of determining whether that particular String was untrusted, or not. I recommend wrapping the input String into an UntrustedString object and passing that around, and modifying Sanitizer interface to deal with UntrustedStrings." hah!
02:42:04 <Heffalump> wli: take a look at the lambdabot source, then
02:42:08 <wli> I see in these papers that they get all sorts of things automatically happening by just slapping on a monad transformer.
02:42:10 <Heffalump> that tries to do that kind of thing
02:42:21 <wli> Heffalump: Okay.
02:42:23 <Heffalump> monad transformers aren't magic
02:42:31 <Heffalump> they just provide a layer of abstraction that can be useful
02:42:37 <dons> wli, have you read the 'monad transformers for building interpreters' paper?
02:42:48 <wli> Heffalump: Well, the "magic" part is that the code comes out unbelievably short.
02:42:50 <Heffalump> provides better modularity
02:42:58 <Heffalump> sure, but you still have to do the work somewhere
02:43:00 <wli> dons: Which one? There are so many...
02:43:13 <dons> Steele.
02:43:18 <dons> http://www.swiss.ai.mit.edu/~dae/related-papers/steele.ps.Z
02:43:20 <Heffalump> and sometimes the mental overhead of that short code removes the value
02:43:23 <Heffalump> but I like them.
02:43:34 <dons> oh, probably Jones' is better these days
02:43:37 <dons> Monad Transformers and Modular Interpreters
02:43:37 <dons>     Sheng Liang, Paul Hudak, and Mark P. Jones
02:43:51 <dons> yes, i think we'd recommend the latter now.
02:43:52 <wli> dons: Steele I don't remember very well but I'm pretty sure I've seen it before.
02:44:01 <vincenz> dons: does conor mcbride use irc
02:44:04 <wli> dons: Okay, I'll go for the latter, then.
02:44:12 <Heffalump> vincenz: don't think so
02:44:12 <dons> vincenz: don't think so.
02:45:02 <vincenz> Alright, thanks
02:45:10 * vincenz had an epiphany the other day
02:45:15 <vincenz> dons: higher order zippers
02:45:23 <vincenz> my blog article on it is nearly finished
02:45:28 <vincenz> just have to add some spiffy figures to make it clearer
02:45:41 <dons> you've read olegs stuff on generalised zippers?
02:45:48 <wli> dons: Asynchronous exceptions appear to be a lacuna in the literature.
02:45:49 <vincenz> dons: I'll look
02:46:02 <vincenz> dons: a first-order zipper gives you O(1) mutatio
02:46:08 <vincenz> dons: a second-order zipper gives you O(1) splicing
02:46:09 <vincenz> !
02:46:41 <dons> hmm, seems intuitively plausible.
02:47:04 <vincenz> yes
02:47:08 <vincenz> but it wasn't clear to me until I tried it out
02:47:16 <vincenz> yesterday I wondered what a second-derivative of a data-type meant :)
02:47:24 <vincenz> so I did it on list, and it seems splicing
02:47:36 <vincenz> so now I'm doing the binary tree one (which is a bit nastier) and then I'll add some figurs
02:47:53 <mgsloan> hmm, raganwald rather overlooks type inference in that post
02:47:55 <wli> vincenz: Category theory can define analogues of integrals too IIRC, coends I think they're called.
02:48:09 <vincenz> wli: interesting
02:48:39 <vincenz> dons: any link to the zipper stuff? afaik, the only zipper stuff oleg has is ZipperFS
02:49:22 <dons> mgsloan: its very high level, and a bit disjointed. is the main thrust to distinguish light/deep properties, and how testing only gets the light ones?
02:49:25 <mgsloan> http://okmij.org/ftp/Computation/Continuations.html#zipper
02:49:26 <lambdabot> Title: Continuations and delimited control
02:49:33 <vincenz> mgsloan: those are still first-order zippers
02:49:37 <dons> (giving wrong-number-of-arguments to a function as an examples!)
02:49:46 <vincenz> (aka, first derivatives)
02:50:06 <mgsloan> vincenz - indeed, but that was the thing dons was talking about
02:50:13 <mgsloan> oleg's generalized zippers
02:50:14 <vincenz> mgsloan: ah, thanks :)
02:50:21 <mgsloan> they aren't higher order, but they're fun
02:50:25 <vincenz> So afaik, this is the first mention of a second-order zipper :)
02:50:41 <mgsloan> yeah, your stuff sounds fun as well
02:50:42 <dons> vincenz: ah yes. now do check Conor's papers then :)
02:50:50 <dons> or mail him
02:51:05 <dons> since its surprising this hasn't been talked about before
02:51:17 <mgsloan> maybe the next post can be generalized higher-order zippers
02:51:23 <dons> do the math, and work out what structures we get for free from each step up
02:51:34 <vincenz> dons: I am doing so
02:51:42 <vincenz> I've done the list one, which is
02:51:52 <vincenz> data DDLIst a = Prev [a] [a] [a] | Next [a] [a] [a]
02:51:59 <vincenz> as for a binary tree
02:52:10 <vincenz> t'' = 2*t*t'* p + t^2 * p'
02:52:33 <wli> dons: I've seen enough monadic interpreter papers that I'm pretty sure there are very few or no demonstrations of dealing with asynchronous exceptions.
02:52:34 <mgsloan> dons - yeah, perhaps neglecting inference was on purpose, for the sake of looking at it deeper than syntax
02:53:13 <wli> So I probably have to work out how it's done myself.
02:53:30 <mgsloan> vincenz - so this would be like the zip equivalent of a zipper :)
02:53:33 <dons> mgsloan: i note he doesn't talk about proofs
02:53:37 <mgsloan> (as opposed to map)
02:53:45 <vincenz> mgsloan: It's a zipper of a zipper
02:53:59 <vincenz> > type Zipper2 d2 a = Zipper (Zipper d2) a
02:53:59 <lambdabot>  Parse error
02:54:03 <vincenz> where d2 = second derivative
02:54:26 <vincenz> data Zipper d a = Zipper a (d a)
02:54:43 <vincenz> I'll have the blog soon
02:55:39 <wli> It'd help if I could get a LaTeX-capable blog going.
02:55:50 <mgsloan> oh, hmm.  I thought it was a zipper with multiple zip trails
02:56:19 <mgsloan> I suppose it still is either way you express it... maybe
02:59:14 * mgsloan has an idea:
02:59:18 <mgsloan> unzippers!
02:59:29 <wolverian> that's hot
03:00:18 <opqdonut> ?pl sequence . replicate
03:00:18 <lambdabot> sequence . replicate
03:00:25 <mgsloan> indeed
03:00:26 <opqdonut> is there a shorthand for that?
03:00:42 <mgsloan> cycleM perhaps..
03:00:51 <mgsloan> > cycleM "foo"
03:00:55 <lambdabot>   Not in scope: `cycleM'
03:00:59 <mgsloan> guess not
03:01:31 <opqdonut> ah, replicateM
03:01:37 <opqdonut> :t replicateM
03:01:40 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
03:01:40 <mgsloan> ahah
03:01:43 <opqdonut> ?src replicateM
03:01:43 <lambdabot> replicateM n x = sequence (replicate n x)
03:01:45 <opqdonut> :)
03:02:24 <hor> Has the Haskell "Weekly" News been discontinued? Last ediiton was 2 months ago :-(
03:02:32 <mgsloan> > zipWith (==) (replicateM "foo") (cycle "foo")
03:02:34 <lambdabot>  Couldn't match expected type `Int' against inferred type `[Char]'
03:02:41 <vincenz> http://notvincenz.blogspot.com/2007/07/higher-order-zippers.html
03:02:43 <lambdabot> Title: lambda.oasis: Higher Order Zippers
03:07:22 <mgsloan> vincenz - you need latex for your blog
03:08:00 <mm_freak> @src cycle
03:08:00 <lambdabot> cycle [] = undefined
03:08:00 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
03:10:13 <mgsloan> vincenz - seems to lapse back into the mu l.1+a*l stuff too (says it will gloss over this, then doesn't :) )
03:10:19 <dons> hor, it hasn't , but i'm super busy
03:10:35 <mm_freak> how can i force a finite list to be evaluated only once, as soon as possible?  like a list of primes, which is used often
03:10:58 <dons> mm_freak: float it out to the outermost level possible
03:11:02 <dons> then just refer to its name
03:11:03 <wli> Declare it globally.
03:11:15 <dons> haskell won't recompute it
03:11:20 <mgsloan> though a list of primes is infinite ;)
03:11:30 <dons> `finite list'
03:11:30 <mm_freak> k
03:11:43 <mm_freak> mgsloan: _a_ list of primes, not _the_ list of _all_ primes ;)
03:11:47 <dons> :)
03:11:48 <wli> It works for infinite lists, too, though they tend to leak.
03:11:48 <mgsloan> hehe
03:12:04 <mgsloan> yeah, infinite lists would work just as well, I'd think
03:13:40 <mm_freak> for fast prime checking against the first few primes, should i implement it as a list of primes directly, or rather as a bitfield in haskell?
03:13:45 <mm_freak> in C i'd prefer the bitfield
03:14:05 <wli> You can do bitfields in Haskell, too, though they are a bit awkward.
03:14:21 <dons> IOUArray Bool is a bitfield
03:14:26 <Cale> You could use an unboxed array of bool...
03:14:27 <Cale> yes
03:14:39 <mm_freak> dons: interesting, thank you
03:14:45 <mm_freak> i used to use Data.Bits
03:14:48 <Cale> dons: Not just IOUArray, but UArray as well, no?
03:14:57 <dons> yeah, all unboxed Bool arrays
03:15:21 <Cale> You probably don't need the mutable interface if it's an array representing primes :)
03:15:36 <dons> you might find a new prime though!
03:15:41 <dons> and then you'll have to set that bit ;)
03:15:56 <dons> best to plan to scale
03:17:49 <araujo> morning
03:18:07 <wli> Cale: He will if he's sieving.
03:18:47 <mm_freak> cale: i'll be calculating the list of primes at program startup
03:18:58 <quicksilver> you can use IntSet
03:18:59 <Cale> Right, that's what I figured.
03:19:01 <quicksilver> that's almost a bitmap
03:19:04 <mm_freak> using SoE or SoA…  likely SoE will suffice
03:19:35 <dons> mm_freak: actually, there's already a fast bitwise nsive .. on the shootout
03:19:52 <Cale> Oh, you need a list of primes, or an array from integers to booleans for deciding if the number is prime?
03:20:11 <mm_freak> dons: there are hundrets of them…  i'm going to implement my own, since i'm still learning =)
03:20:32 <dons> oh, just that you might find it instructive, since its pretty fast
03:20:37 <Cale> If you're doing it at program startup, you can probably afford to do something slow to generate the table.
03:21:09 <mgsloan> does ghc ever eval such things compile time?
03:21:14 <Cale> no
03:21:19 <mm_freak> cale: i need to try dividing a number by the first few primes, before i pass it on to miller-rabin
03:21:19 <mgsloan> pity
03:21:22 <dons> inside $() ii does :-)
03:21:36 <Cale> yeah, you can tell it to with Template Haskell.
03:21:36 <mgsloan> hah
03:21:42 <dons> if tricked some C programmers a few times with that old ploy ;)
03:22:02 <dons> just don't mention the compile times
03:22:03 <Cale> mm_freak: Okay, so a list of primes is actually probably appropriate.
03:22:15 <Cale> mm_freak: Lists are things that you 'loop' over.
03:22:22 <Cale> (in order)
03:22:27 <dons> http://shootout.alioth.debian.org/gp4/benchmark.php?test=nsievebits&lang=ghc&id=4
03:22:29 <lambdabot> Title: nsieve-bits Haskell GHC #4 program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 C ..., http://tinyurl.com/2fjnzl
03:22:53 <dons> competitive (1.8x the optimised C version)
03:23:10 <dons> http://shootout.alioth.debian.org/gp4/benchmark.php?test=nsievebits&lang=gcc&id=2
03:23:12 <lambdabot> Title: nsieve-bits C gcc #2 program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Compute ..., http://tinyurl.com/345o5h
03:23:16 <mm_freak> cale: yeah…  the other alternative is to just use a wheel
03:23:29 <Cale> That's exactly the sort of program you'd only see at a speed contest.
03:23:30 <dons> hmm, we probably could just roll our own version of that C one.
03:23:34 <dons> C's good for bit fiddling
03:24:24 <mm_freak> you can't outperform a well written C prime sieve in haskell =)
03:24:35 <Cale> mm_freak: Not yet.
03:24:54 <mm_freak> cale: not ever, because you can touch the bleeding edge with C
03:25:16 <quicksilver> mm_freak: we have haskell programs which outperform C programs :)
03:25:20 <Cale> mm_freak: It's incredibly impractical to do many sorts of optimisation in C.
03:25:21 <wli> It depends on whether the compiler can grind the machine code down to something equivalent or faster (and you can get faster than C, i.e. assembly).
03:25:46 <mm_freak> quicksilver: that's most likely because the C programs are not written well (in terms of performance)
03:26:27 <quicksilver> the examples I'm thinking of it's mostly because we can outperform stdio
03:26:36 <wli> There are some programs for which it's not possible to write an operational equivalent to the C program because ghc can optimize out the whole bloody thing.
03:26:42 <mm_freak> cale: very well performing C code is still easier to understand for me than well performing haskell code
03:26:56 <quicksilver> but in principle there could be cases where we could vectorize code for a high end FPU which the C compiler can't do (not enough type information)
03:26:56 <mgsloan> more like it'd be insane to hand write the C code that would beat ghc in these cases
03:26:57 <wli> quicksilver: Yeah, stdio is a dog.
03:27:03 <Cale> mm_freak: Well, look at the ByteString library.
03:27:20 <dons> you can outperform C, when the compiler can analyse the haskell code better than the C counterpart can.
03:27:37 <quicksilver> (and act on that analysis!)
03:28:08 <mm_freak> however…  currently C code written with speed in mind usually performs much better than haskell code
03:28:13 <dons> we slaughtered gcc and icc with a bit of specialisatoin in the polymer simulator project
03:28:17 <wli> dons: In theory a Haskell autoparallelizer should be able to utterly massacre a C autoparallelizer.
03:28:18 <Cale> C is a low level language which means that the programmer provides more specifics about what's going on, but less intent to the compiler. Smart compilers need information about intent in order to do really good optimisations.
03:28:30 <dons> just involves reasoning at a level not feasible for the C programmer or compiler
03:28:41 <mm_freak> wli: i can't imagine a C auto-parallelizer to be possible
03:28:56 <Cale> mm_freak: Consider a language which knows about matrices, vs C.
03:29:00 <dons> wli, right, already does so. see the graphs in the last DPH paper
03:29:02 <wli> mm_freak: Possible and implemented well over a decade ago.
03:29:12 <dons> on 2 cores you're already leaving the best effort C program in the dust
03:29:21 <dons> just by using [: f x | x <- xs :]
03:29:37 <Cale> and suppose that in the course of inlining some matrix computations, the compiler comes upon the code: matrixMultiply(A, inverse(A))
03:29:39 <dons> (i.e. a language which knows about matrices :)
03:29:46 <dcoutts_> mm_freak: I used to work at Cray where they have an auto-parallelising compiler, they reckoned for average numerical C code they could get a 4x parallelisation and more like 10x or more for ordinary Fortran
03:29:57 <Cale> in C, the compiler sees those functions as masses of loops
03:30:06 <mm_freak> well, theoretically a haskell compiler should be able to create lightning fast code, but we're not there yet
03:30:15 <mm_freak> and that won't change too soon
03:30:21 <Cale> in the high-level language, the compiler can replace that code with the identity matrix.
03:30:32 <dons> mm_freak: it is here for a reasonable set of programs though
03:30:39 <wli> mm_freak: Autoparallelization OTOH is already happening as dons has noted.
03:30:42 <Cale> mm_freak: It is changing quite rapidly
03:30:51 <mm_freak> cale: in C the programmer knows when to replace it, and does that manually =)
03:30:59 <dons> there's really nothing magic about compiling haskell to the same kind of code as gcc  produces
03:31:02 <Cale> mm_freak: no, there are cases where you *cant*
03:31:05 <Cale> can't
03:31:07 <dons> its the stuff after that that is fun
03:31:22 <wli> dons: Yeah, it's just investing the manpower.
03:31:25 <Cale> mm_freak: In particular, when you're calling library functions.
03:31:57 <Cale> mm_freak: To optimise various combinations of library functions, you have no recourse but to tear the code apart and lose all abstraction.
03:32:01 <dons> that's a good point Cale. no library domain-specific optimisations. no whole program compilation
03:32:07 <mm_freak> see, the big problem about fast haskell code is:  the faster the code, the more esoteric its source
03:32:20 <Cale> mm_freak: That's not necessarily true.
03:32:23 <dons> mm_freak: that's what libraries and rewrite rules are for.
03:32:36 <mm_freak> cale: not necessarily, but very often
03:32:51 <Cale> mm_freak: It's true of the Shootout problems, because people have bothered to write low-level code there, which you can do if you really want to.
03:32:52 <dons> yeah, as for optimised code in most languages
03:32:53 <mm_freak> dons: and you'd need to do that for every specific problem
03:33:03 <quicksilver> mm_freak: ah, but that's the clever bit
03:33:03 <wli> dons: I suspect Haskell may be the first high-level language to have enough manpower invested in it and an unscrewedup-enough design to reach performance parity with lower-level languages.
03:33:14 <quicksilver> mm_freak: you don't, you just need the libraries to be like that
03:33:16 <Cale> mm_freak: no, you can design high-level optimisations into your libraries.
03:33:21 <dons> wli, i think ocaml and clean are also already there.
03:33:26 <quicksilver> mm_freak: anyone can use ByteString in a very high level way
03:33:31 <Cale> (In Haskell, or at least GHC)
03:33:32 <quicksilver> mm_freak: and benefit from the fusion
03:33:39 <mm_freak> dons: optimized C code isn't as bad in that part
03:33:57 <dons> yeah, in C all code is already obfuscated :)
03:34:02 <Cale> mm_freak: There's a way to tell the haskell compiler that  map f . map g = map (f . g), for example.
03:34:07 <dons> no:  print . sum . map read . lines
03:34:11 <Cale> and turn two loops into one.
03:34:51 <Cale> and you can do this for your own library functions
03:34:51 <mm_freak> cale: and that's specific
03:34:53 <wli> dons: ocaml is pretty good but there are some attenuation factors still there vs. actual parity. I don't know much of anything about Clean. I thought the "big hope" on that front was region analysis to cut out GC.
03:35:20 <mgsloan> cale - ooh, how does one do that?
03:35:22 <mm_freak> example:  for the SoE i'm currently implementing, i need a function which sets every Nth bit to zero
03:35:25 <Cale> mm_freak: You can do it quite generally. Look at the stream fusion stuff that's being used in ByteString and the new data parallelism stuff.
03:35:35 <Cale> mgsloan: RULES pragmas.
03:35:43 <mgsloan> mm, cool
03:35:47 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/rewrite-rules.html
03:35:49 <lambdabot> Title: 7.11. Rewrite rules, http://tinyurl.com/y7rk9g
03:36:07 <mm_freak> since there is no insanely-optimized and ready-to-use function of that kind, i need to optimize it myself
03:36:17 <dons> one useful trick is to use rules to specific first-order optimised variants for higher order library functions
03:36:21 <mm_freak> there are thousands of such little problems, and you can't generalize it a lot
03:36:26 <dons> so the user might get a 'memchr' call if they use f (=='x')
03:36:41 <dons> that's a simple way to keep your api down, and improve the user's code, with rules
03:36:56 <mgsloan> indeed
03:37:09 <mgsloan> that's pretty sweet. I didn't know ghc had it
03:37:37 <mm_freak> don't get me wrong…  haskell code is beautiful…  much more beautiful than any other language, and it's reasonably fast =)
03:37:49 <mm_freak> but currently you'll need C to get to the bleeding edge
03:38:04 <quicksilver> I still dont' accept that
03:38:04 <dons> if your type is in Functor
03:38:09 <dons> toss in a rule for fmap f . fmap g
03:38:10 <quicksilver> you need assembly to get the bleeding edge
03:38:25 <quicksilver> C only gives you whatever limited part of your CPU instruction set your compiler writer chose to give
03:38:26 <Cale> mm_freak: Getting C to have incredible performance on trivial programs is easy. Getting it to have good performance on nontrivial programs is hard.
03:38:26 <wli> Looks like ghc massacres C on cheap concurrency.
03:38:31 <quicksilver> and most C compilers are buggy, too :P
03:38:35 <wli> By a factor of 14.7
03:38:35 <mm_freak> quicksilver: usually the C compiler produces better code than you
03:38:42 <mgsloan> dons - no polymorphic rules?
03:38:46 <dons> wli, also on binary trees too, iirc?
03:38:47 <quicksilver> not if you care about optimisation, it doesn't
03:39:03 <dons> we used to have C beat on about half the shootout programs
03:39:09 <mgsloan> oh, nevermind
03:39:09 <dons> not sure what its like now
03:39:11 <quicksilver> even on really simple functions, it adds quite un-necessary extra instructions
03:39:14 <wli> dons: yeah
03:39:19 <quicksilver> frame pointers which aren't needed
03:39:23 <mm_freak> quicksilver: but the compiler will spill out code for particular platforms
03:39:28 <quicksilver> un-necessary copying of values which are never modified
03:39:36 <dons> even on summing integers from a file, haskell+bytestrings beats gcc
03:39:36 <quicksilver> well, I don't dispute *that*
03:39:40 <wli> dons: woops, I was comparing to C++/g++
03:40:03 <Cale> Also, I think if you are really extremely serious about performance, what you should be doing is a combinatorial search over families of programs at the machine level.
03:40:03 <mm_freak> there certainly are places where haskell code performs better
03:40:16 <dons> Cale, yeah. FFT-style.
03:40:17 <mm_freak> but just because the C programmer didn't care mainly about speed
03:40:19 <Cale> Which of course, is exactly the sort of thing which you should use Haskell for.
03:40:25 <Cale> mm_freak: Heard of FFTW?
03:40:34 <mm_freak> cale: nope
03:40:41 <wli> dons: meteor-contest isn't looking very good.
03:40:50 <Cale> It's the "Fastest Fourier Transform in the West"
03:40:54 <dons> wli, i don't think anyone's tried that one. probably jsut a naive entry?
03:41:06 <Cale> It's a C program that gets written by an O'Caml program.
03:41:24 <wli> dons: Probably, yeah.
03:41:30 <Cale> It does better than basically any other FFT out there.
03:41:54 <dons> ah yes, i see we're beating C only on 2 benchmarks now, and the fast lines sum programs got removed
03:41:56 <wli> http://shootout.alioth.debian.org/gp4/benchmark.php?test=meteor&lang=ghc&id=3
03:41:58 <lambdabot> Title: meteor-contest Haskell GHC #3 program | Gentoo : Intel&#174; Pentium&#174;&nbsp; ..., http://tinyurl.com/2vnldx
03:42:04 <dons> concurrency and binary tree allocation
03:42:05 <Cale> dons: yeah, I think that's unfair.
03:42:07 <mm_freak> cale: is there anything special about it being generated by ocaml?
03:42:09 <wli> dons: Fast lines sum?
03:42:27 <Cale> mm_freak: well, yeah. That's where all the interesting work is.
03:42:38 <dons> bytestrings were just destroying all comers, http://shootout.alioth.debian.org/gp4/benchmark.php?test=sumcol&lang=ghc&id=0
03:42:40 <lambdabot> Title: sum-file Haskell GHC program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Compute ..., http://tinyurl.com/327qll
03:42:41 <mm_freak> k, maybe i'll look it up
03:42:43 <Cale> mm_freak: They're using a code generation monad
03:42:52 <dons> that's a 10 instruction asm loop  in the end :)
03:43:03 <mm_freak> cale: how large is the C code?
03:43:13 <bdash> 22:42 < Cale> mm_freak: They're using a code generation monad
03:43:15 <Cale> mm_freak: depends on the FFT size you're generating
03:43:20 <dons> gcc is about 3-4x slower there, ah well.
03:43:31 <mm_freak> ah k
03:44:02 <kfish> mm_freak, http://www.fftw.org/fftw3_doc/Generating-your-own-code.html
03:44:02 <lambdabot> kfish: You have 1 new message. '/msg lambdabot @messages' to read it.
03:44:05 <lambdabot> Title: Generating your own code - FFTW 3.1.2
03:44:15 <mm_freak> well, i'll proceed with my primality tester =)
03:44:17 <kfish> @botsnack
03:44:17 <lambdabot> :)
03:44:18 <wli> dons: "NOT ACCEPTED: should use built-in line-oriented I/O functions rather than custom-code"
03:44:41 <dons> yeah.
03:44:44 <dons> i.e. move it into a library
03:44:46 <dons> stupid rules
03:44:50 <mm_freak> (it really sucks that i simply can't use mpz_probab_prime_p())
03:44:50 <mgsloan> will ghc infer rules from other rules? perhaps it does not need to
03:44:53 <Cale> mm_freak: Basically, if you *really* care about performance these days, you're not programming in C directly or even assembly directly.
03:45:14 <wli> dons: Maybe automatic transformation of all the line-oriented IO into ByteString -based IO?
03:45:19 <Cale> mm_freak: You're writing programs in high-level languages that do combinatorial searches over spaces of assembly programs.
03:45:26 <Cale> (or C programs)
03:45:29 <dons> wli, or just provide 'withlines' in Data.ByteString :)
03:45:46 <dcoutts_> dons: what would that do?
03:46:06 <psykotic> cale: that only works for very tightly delimited programs, like FFTs.
03:46:11 <dons> dcoutts_: didn't malcolm or ross suggest it? it was the fast lines fold parameterised by its body
03:46:19 <quicksilver> take a ByteString -> ByteString function and apply it to each line of a big ByteString
03:46:22 <dons> dcoutts_: but of course, what we want is to generate those loops from ghc.
03:46:22 <quicksilver> presumably
03:46:37 <Cale> psykotic: usually inner loops which are going to run a long time are of that variety.
03:46:48 <psykotic> cale: that's very domain specific.
03:46:54 <dons> psykotic: yeah, for non-tightly delimited ones, use your high level language to generate specialised C instead. :)
03:46:59 <psykotic> cale: i work on games, which are very performance intensive.
03:47:13 <psykotic> cale: our profile is very flat. there aren't any inner loops to optimize to magically get big speed ups.
03:47:14 <dcoutts_> dons: hmm, yes we don't quite get that yet using fold . lines since we build the intermediate list
03:47:26 <dons> i hate lines
03:47:37 <dcoutts_> dons: we might be able to do that with the unified streams stuff for lists & bytestrings
03:47:51 <dcoutts_> ie fuse foldr . lines
03:48:01 <dons> we should check that.
03:48:24 <wli> I work on kernels, where depending on the workload, one thing or another will get pounded like a wild monkey.
03:48:28 <psykotic> cale: the commentary to '90% of the runtime is spent in 10% of the program' is that when you can consume as much cpu time as the cpu can dish out, very quickly that no longer holds true.
03:48:41 <psykotic> cale: because you optimize the cases where it does hold true, so they quickly vanish.
03:49:13 <wli> The trick with kernels is that the 10% of the program where 90% of the runtime is spent varies depending on what userspace is doing.
03:49:22 <psykotic> yeah, kernels are a different bag.
03:49:34 <dons> Cale, what we need to really own this space is a DSL for generating C, and another for manipulating assembly (harpy might be there for the latter, c2hs could be torn up for the former)
03:49:51 <wli> So there's a lot of reshuffling where the runtime goes, and not a whole lot of guarantee of global forward progress or Pareto improvement or whatever.
03:49:52 <dons> then you'd just write your C program searcher fairly directly in the EDSL
03:50:05 <dons> opening up massive performance to the masses
03:50:19 <Cale> I'm mostly looking at this from the perspective of programs which are going to sit there and run for a month, and you'd rather they take a week and don't mind spending a few hours compiling to get that.
03:50:43 <wli> The kernel runs for years on end. ;)
03:52:02 <psykotic> cale: right, hence my comment that it's very domain specific. not all consumers of high performance have those characteristics.
03:52:18 <mgsloan> or things that 1000s of people will be using
03:53:01 <kfish> dons: a combinatory DSL to manipulate turing machine code? 1337
03:53:23 <wli> psykotic: In the kernel you need multiple objective optimization techniques.
03:53:27 <Cale> kfish: to manipulate C code
03:53:34 <psykotic> wli: such as?
03:54:06 <wli> psykotic: I don't know what exists combinatorially. In floating point you basically have these cones of Pareto descent.
03:54:08 <psykotic> oh, another thing specific to games--the way in which performance is measured is very different from most applications. it's much closer to soft real time systems. traditional profiling techniques can be fairly useless.
03:54:29 <wli> psykotic: And end up with a "tradeoff surface."
03:54:37 <psykotic> for example, you can have a function that causes a very localized spike in the frame time, causing visible chugging... but it won't show up anywhere in the top 100 on the profile, because it's overall time is very low.
03:55:01 <psykotic> so you need to have real time instrumenting with various filtering techniques for tracking spikes and such
03:55:06 <wli> psykotic: Similar in-kernel.
03:55:17 <wli> psykotic: Except vastly more ad hoc.
03:55:21 <psykotic> yeah i can imagine.
03:56:04 <mgsloan> basically, in the long run, somehow, we need ways to tell haskell how to optimize
03:56:22 <mgsloan> that are more better than -O2, etc
03:56:54 <psykotic> wli: for soft real time things?
03:57:06 <wli> I don't think we're out of the basics woods yet, in all honesty. When parity with ocaml and Clean happens then we need fancy things.
03:57:08 <dons> kfish: oh, yeah, well, just code generation + search :)
03:57:22 <psykotic> wli: it seems a lot of OS design these days is targetted at scenarios where a good amount of things are running at the same time, which is very different from games.
03:57:34 <wli> psykotic: Well, no, what happens are "stalls" of various sorts, or latency blips that aren't really realtime at all but violate operational constraints.
03:57:42 <Cale> dons: see, this ties in with that whole 'list monad niche'
03:57:47 <dons> yeah!
03:57:58 <Cale> dons: Finding fast programs is just another puzzle game.
03:58:11 <wli> psykotic: In a number of instances the "stalls" aren't even hitting the CPU, they're things like sleeping locks and they only hit one process out of zillions.
03:58:16 <dons> quite so. ah, its all connected :)
04:00:51 <wli> psykotic: In some cases, things go to sleep waiting for a bit to get unset in a status flags word for a single page.
04:01:03 <wli> psykotic: And for some reason or other they take too long.
04:01:38 <wli> psykotic: Maybe once in a blue moon it'll take a couple of minutes for no obvious reason.
04:02:20 <psykotic> sounds painful to deal with
04:02:40 <wli> You don't do kernel programming if you don't like pain.
04:03:04 <wli> This is the low-level assembly and C stuff on the bare metal. Bondage and discipline programming.
04:03:41 <dons> its interesting that no one has got close to haskell in the chameneos benchmark in the last 2 years, http://shootout.alioth.debian.org/gp4/benchmark.php?test=chameneos&lang=all
04:03:43 <lambdabot> Title: chameneos benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Languag ..., http://tinyurl.com/lrhoa
04:03:45 <dons> lots of threads
04:04:02 <psykotic> wli: i unfortunately have to do a good amount of that too, because of consoles.
04:04:06 <dons> so instead they disable counting of concurrency benchmarks on the main shootout page
04:04:13 <dons> typical... (grumble)
04:04:17 <Cale> dons: Well, D is kind of close
04:04:29 <psykotic> wli: except i have it worse because sony's ps3 tools are basically useless. :)
04:04:43 <Cale> but still, that's a half-second gap
04:05:02 <Cale> between the two haskell programs and D.
04:05:14 <dons> yeah, D has come out of nowhere there.
04:05:24 <wli> That meteor thing is an open question.
04:06:54 <hpaste>  Nestor_the_Inve pasted "Nestor_the_Investor" at http://hpaste.org/1594
04:06:55 <Cale> I wish the language shootout guys would label the rejected entries with the reasons for their rejection.
04:09:06 <wli> http://www-128.ibm.com/developerworks/java/library/j-javaopt/
04:09:07 <lambdabot> Title: Optimize your Java application's performance
04:09:15 <dons> the rules for pretty much every benchmark where haskell has previously come first have been changed over the years. it gets tedious :/
04:09:37 <dons> @tell sorear hah, they defeated your spam detection by chance
04:09:37 <lambdabot> Consider it noted.
04:09:47 <Cale> They seem to have pretty strange rules.
04:09:59 <quicksilver> dons: how does the spam detection work?
04:10:10 <wli> Maybe someone should run an alternative language shootout page.
04:10:32 <dons> quicksilver: name==title
04:10:37 <quicksilver> dons: heh
04:10:42 <Cale> I don't really understand why they don't just rely on correct output for a given input.
04:10:42 <quicksilver> dons: but this one's name was too long
04:10:46 <dons> yeah :)
04:10:55 <kfish> we need a mad-max style, winner takes all shootout
04:11:05 <Cale> If they want you to compute things a certain way, get the programs to output intermediate results.
04:11:09 <dons> Cale, the binary tree one for example: they changed it to require strict trees
04:11:09 <quicksilver> Cale: they have some intention to argue about testing 'standard ways to do things'
04:11:19 <dons> after someone complained they couldn't get that good performance in C.
04:11:33 <Cale> heh
04:11:36 <dons> so you have to code in a non-standard way. that's dumb.
04:11:37 <Cale> that's so stupid
04:11:56 <wli> The natures of the problems are also questionable.
04:12:01 <dons> fast C is rarely questioned, fast Haskell attracts rules changes all the time
04:12:43 <wli> Frankly I'd think former ICFP contest problems are often good for these sorts of things.
04:13:21 <Cale> Yeah, there should be a language shootout with all the ICFP problems in it, except maybe that last ICFP.
04:14:16 <Cale> Well, perhaps one could pull out some of the puzzles there :)
04:14:17 <wli> Also, since it's a language shootout and not the ICFP, other contests would be good, too.
04:14:21 <kfish> it'd also be interesting to see the benchmark results on a machine with more processors/cores
04:14:29 <Cale> yes
04:15:08 <Cale> Run all the tests on something like an 80-core processor, so failure to parallelise will basically kill you :)
04:15:45 <dons> 4 cores would be enough there
04:16:08 <dons> you'd just have to stop using most languages
04:16:10 <dons> it would be super cool
04:16:20 <dons> maybe i should host that shootout on the 16 core box :)
04:16:27 <Cale> :)
04:16:33 <wli> dons: Sounds like a good idea.
04:17:13 <wli> I can't make heads or tails of the puzzle.
04:17:31 <dons> it would really show how infeasible parallelising legacy imperative languages would be
04:19:59 <Cale> When should data parallelism be in full force in Haskell? GHC 6.8?
04:20:43 <dons> hmm. i think that's what they're pushing for.
04:20:51 <dons> roman's committing directly into the head branch now
04:21:26 <wli> Okay, I understand the simplified version actually used in the problem.
04:22:07 <dons> http://programming.reddit.com/info/025153/comments vincenz is productive
04:22:09 <lambdabot> Title: Higher Order Zippers (reddit.com)
04:23:25 <wli> Partition a patch of hexagonal tiles into 10 contiguous regions of 5 tiles each such that there's a 1:1 mapping between regions and a set of preassigned shapes.
04:24:55 <vininim> mmm can that be reduced to graph colouring? =p
04:25:08 <quicksilver> Cale: where is the data parallelism stuff documented?
04:25:20 <wli> vininim: Basically. There's already a working solution, but it's 22 times slower than C++.
04:25:23 <quicksilver> Cale: in particular, how do you assign sparks, aside from the list case everyone always shows?
04:25:35 <wli> vininim: http://shootout.alioth.debian.org/gp4/benchmark.php?test=meteor&lang=ghc&id=3
04:25:37 <lambdabot> Title: meteor-contest Haskell GHC #3 program | Gentoo : Intel&#174; Pentium&#174;&nbsp; ..., http://tinyurl.com/2vnldx
04:25:39 <Cale> quicksilver: are you talking about par?
04:25:52 <Cale> quicksilver: I'm talking about parallel arrays
04:25:58 <quicksilver> I don't know what I'm talking about :)
04:26:04 <Cale> http://haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
04:26:05 <lambdabot> Title: GHC/Data Parallel Haskell - HaskellWiki
04:26:13 <quicksilver> thanks
04:26:42 <dons> quicksilver: the array combinators fuse to parallel code
04:26:49 <dons> and you also get parallel comprehensions
04:27:02 * quicksilver nods
04:27:04 <dons> so your: fold . map . filter
04:27:12 <dons> is 3 parallel ops
04:27:18 <dons> which then fuse into 1 fast parallel op
04:27:24 <wli> vininim: I don't have very many ideas as to how to do that.
04:28:09 <dons> this actually shows us how to do parallel bytestrings too
04:28:16 <dons> we've just got to work out if that's useful
04:28:46 * edward1 is hunting for rampant generalizations that can be made to prelude functions.
04:28:48 <edward1> I started bundling up a bunch of the ones we'd been kicking around here into an alternate prelude last night. not sure if it will all work together in the end, but hey
04:28:56 <lassoken> How would you implement simple monte-carlo program from Structure and Interpretation of Computer Programs, Section 3.1.2, in Haskell? That is presented as a motivation to introduce assignment into language so surely some of you has thought about it.
04:29:28 <dons> lassoken: the usual way?
04:29:46 <dons> what data structures do you want?
04:30:10 <dons> a very haskellish way might involve Random moads, perhaps some parallel monte carlo tricks
04:30:14 <Cale> lassoken: A random generation monad.
04:30:29 <Cale> http://www.haskell.org/haskellwiki/New_monads/MonadRandom
04:30:30 <lambdabot> Title: New monads/MonadRandom - HaskellWiki
04:31:07 <Cale> That monad lets you generate random values without giving you general state.
04:31:20 <wli> Okay, one thought I have is that if you have some fast way to check if tiled regions are disjoint, you could do more.
04:31:23 <edwardk> so far i've got the restricted monad trick, map as (.), generalized enumFrom*, cons using mplus . return, and I've collapsed the numerical tower to something a little more mathematical, so that list append can just be a (+) monoid.
04:31:31 <vininim> freenode is not liking my connection lately
04:32:08 <lassoken> thanks
04:32:25 <wli> edwardk: Order and/or lattice -theoretic (&&), (||), (<=), (>=), etc.
04:32:31 <vininim> annoying connection
04:33:02 <dons> edwardk: you actually going to hack this up as a prelude for people to import?
04:33:04 <edwardk> wli: i've been thinking about it. in particular splitting Ord up so you can start with a preorder or partial order.
04:33:12 <dons> might be fun. we have -fno-implicit-prelude for a reason, after all :)
04:33:16 <wli> edwardk: I've done it before.
04:33:25 <wli> dons: Except integer literals are fscked.
04:33:37 <edwardk> dons: well, yeah. right now I have 'Chapter1' with Chapter1.Monad.Restricted, Chapter1.Math, ...
04:33:40 <dons> wli, why?
04:33:51 <dons> its string literals you can't overload :)
04:33:55 <wli> dons: The builtin Num instance gets used no matter what.
04:33:56 <dons> until now.
04:34:08 <edwardk> basically I figured I should try out a lot of the generalizations I've been using in my toy language in Haskell to check their sanity.
04:34:17 <dons> hmm, really? that doesn't sound right, wli.
04:34:18 <vincenz> dons: what is the link for the icfp teams seeking members?
04:34:24 <wli> dons: Do -fno-implicit-prelude and check the type of an integer literal.
04:34:28 <dons> in the topic, vincenz
04:34:41 <vincenz> ah, thanks
04:34:55 <wli> brb got to get to the store
04:34:56 <edwardk> fromInteger should be rebindable
04:35:11 <opqdonut> ?src fromInteger
04:35:11 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
04:35:12 <edwardk> I need to check of enumFromTo rebinds
04:35:16 <dons> A.hs:3:14: Not in scope: `fromInteger'
04:35:16 <dons> A.hs:3:15: Not in scope: `+'
04:35:17 <dons> A.hs:3:16: Not in scope: `fromInteger'
04:35:39 * vincenz 's client doesn't show full topic
04:35:40 <edwardk> so that [foo..bar] can be resugared into something other than a list
04:35:48 <vininim> =O
04:35:54 <quicksilver> vincenz: type '/topic' to see it, probably
04:36:02 <vincenz> quicksilver: I did :) Just explaining why I didn't know :)
04:36:06 <quicksilver> ah :)
04:36:23 <edwardk> any other restricted monads people can think of?
04:36:43 <edwardk> it'd be a shame to go through all the trouble of breaking monad into itty bitty pieces for just Set ;)
04:37:01 <dons> "You may want to define your own numeric class hierarchy. It completely defeats that purpose if the
04:37:04 <dons> literal "1" means "Prelude.fromInteger 1", which is what the Haskell Report specifies. So the
04:37:07 <dons> -fno-implicit-prelude flag causes the following pieces of built-in syntax to refer to whatever is in
04:37:10 <dons> scope, not the Prelude versions"
04:37:11 <Cale> oh, that technique is annoying
04:37:23 <dons> `the standard Prelude Eq class is still used'
04:37:41 <Heffalump> oh, he left
04:37:44 <Heffalump> I wanted to say something.
04:37:49 <dons> but it does seem to use whatever fromInteger -> N is in scope
04:37:50 <Cale> Because it loses naturality guarantees that you'd otherwise have gotten from the type system.
04:38:11 <Heffalump> Cale: sure. It depends what you want.
04:38:32 <Heffalump> doing embedded languages, you often want to do a lot of things your own way
04:38:58 <dons> "Be warned: this is an experimental facility, with fewer checks than usual. Use -dcore-lint to
04:39:01 <dons> typecheck the desugared program."
04:39:39 <Cale> It would be really nice to have some way to specify in your instance that the monad is only a monad over a class-restricted subcategory of the category of Haskell types.
04:40:47 <vininim> mmmm I tried googling for this, but not found a trivial example of type inference not halting with ghc extensions
04:41:39 <Cale> I can give a trivial example of type inference taking a lot of time and memory.
04:42:41 <vininim> like?
04:43:24 <Cale> :t let f x = (x,x); f1 x = f (f x); f2 x = f1 (f1 x); f3 x = f2 (f2 x); f4 x = f3 (f3 x) in f4
04:43:39 <lambdabot> thread killed
04:43:44 <Cale> :)
04:44:23 <opqdonut> how does that take a lot of time and memory?
04:44:32 <opqdonut> s/how/why/
04:44:39 <Cale> opqdonut: think about what the type of f4 is.
04:44:40 <opqdonut> because of x being polymorphic?
04:45:01 <opqdonut> yeah but whouldn't deriving the type of f4 be quite straightforward?
04:45:06 <quicksilver> f4 has type  a -> (a,... 16 times ... a) doesn't it?
04:45:11 <Cale> no
04:45:19 <Cale> :t let f x = (x,x); f1 x = f (f x); f2 x = f1 (f1 x); f3 x = f2 (f2 x) in f3
04:45:22 <lambdabot> forall t. -> ((((((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))), (((((t, t), (t, t)), ((t,
04:45:22 <lambdabot>  t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))))), ((((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t,
04:45:22 <lambdabot> t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))), (((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t,
04:45:22 <lambdabot> t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))))), (((((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t,
04:45:24 <lambdabot>  t), (t, t))))), (((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))))), ((((((t, t), (t, t)), (
04:45:25 <quicksilver> ah no, it's nested
04:45:27 <lambdabot> (t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))), (((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t,
04:45:30 <lambdabot>  t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))))))
04:45:42 <opqdonut> woah, okay didn't realize it blows up that fast
04:45:50 <quicksilver> and you're doubling up each time
04:45:56 <opqdonut> no, more
04:45:56 <quicksilver> I think I read f3 x = f2 (f x)
04:46:02 <quicksilver> not f3 x = f2 ( f2 x)
04:46:04 <quicksilver> IYSWIM
04:46:15 <opqdonut> yeah
04:46:38 <quicksilver> :t let f x = (x,x); f1 x = f (f x); f2 x = f1 (f1 x) in f2
04:46:40 <lambdabot> forall t. -> ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))
04:46:49 <dons> that's rather stressful for my machine, btw.
04:46:53 <quicksilver> sorry :)
04:47:05 <opqdonut> :)
04:47:11 <dons> who needs non-termiation when you've got a DoS anyway
04:47:17 <Cale> right
04:47:20 <vininim> hah
04:47:31 <quicksilver> DoS? but it terminates it after 3 seconds?
04:47:35 * vincenz wishes his client had search capabilities
04:47:40 <Cale> Well, the other one doesn't.
04:47:44 <vininim> just wondering, I was read "but ghc extensions breaks the termination guarantee"
04:47:45 <vincenz> @tell mgsloan Thanks for the input :)  I plan to clean it up soon
04:47:46 <lambdabot> Consider it noted.
04:47:48 <vininim> *always
04:47:49 <opqdonut> anyone know an example of non-terminating type inference?
04:47:49 <dons> quicksilver: if leavs ghc running though. lambdabot just gives up on it :}
04:47:57 <dons> opqdonut: recursion with newtypes
04:47:59 <quicksilver> dons: ah. D'OH!
04:48:11 <opqdonut> dons: newtype A = A ?
04:48:21 <dons> nah, you have to try a bit harder, opqdonut
04:48:29 <Cale> dons: That one ought to finish reasonably quickly though, under a minute for sure.
04:48:31 <opqdonut> ok, let me think :)
04:48:35 <dons> ?src fix -- think about this
04:48:35 <lambdabot> Source not found. You speak an infinite deal of nothing
04:48:36 <vincenz> newtype A a = A (A a)
04:48:40 <dons> ?src fix
04:48:40 <lambdabot> fix f = let x = f x in x
04:48:57 <Cale> I might be able to get it to run your system right out of memory though, if I kept going :)
04:49:17 <dblhelix> newtype F a = F (F a -> F a)
04:49:19 <vininim> get a limit on the bot user =p
04:49:31 <vininim> *pam limit
04:50:24 <hpaste>  fasta pasted "Global variables do not work consistently?" at http://hpaste.org/1595
04:51:16 <fasta> This should be the right way to use quick and dirty global variables, AFAIK.
04:51:24 <Lemmih> fasta: Use NOINLINE and disable cse.
04:51:28 <dons> oh, silly me. what was i thinking. the recursion with data types breaks the *inliner* , not good old h98.
04:51:45 <opqdonut> oh okay
04:51:46 <fasta> Lemmih: Is cse disabled by default?
04:51:49 <dons> getting the type checker to not terminate involves stepping out a bit
04:51:51 <vininim> *Main> :t F
04:51:52 <vininim> F :: (F a -> F a) -> F a
04:51:57 <fasta> Lemmih: This is just in ghci.
04:51:58 <Lemmih> fasta: No.
04:52:07 <fasta> Lemmih: Ok
04:52:12 <fasta> Lemmih: thanks
04:52:51 <opqdonut> dons: can't figure it out
04:53:45 <dons> newtype Fix a = Fix (a (Fix a))
04:54:22 <fasta> {- NOINLINE -}
04:54:23 <fasta> debug_var = unsafePerformIO(newIORef False)
04:54:35 <Lemmih> fasta: {-# NOINLINE debug_var #-}
04:54:47 <fasta> Lemmih: ok
04:54:56 <dons> fasta, btw, such code is evil.
04:55:38 <fasta> dons: Until there is TestT, I do it this way.
04:55:54 <fasta> dons: I only use it to quickly enable and disable test code.
04:56:25 <fasta> dons: I need to select the right piece of debugging output I want to see.
04:56:35 <fasta> dons: AFAIK, there are not other solutions.
04:56:56 <opqdonut> dons: how can i observe that breaking the inliner?
04:56:58 <fasta> dons: I could write an output filter I suppose, but that only works for text.
04:57:00 <dons> yeah, i understand. this is a cheap way to do that.
04:57:17 <dons> vincenz: btw, i find the grey on grey code very difficult to red
04:57:18 <dons> read
04:57:18 <vincenz> dons: I take it you liked the article?
04:57:24 <fasta> Lemmih: it's still not working.
04:57:25 <vincenz> dons: I'll try to alter my template
04:57:38 <dons> vincenz: would you try hscoloured output on a white background?
04:57:40 <Lemmih> fasta: It should.
04:57:45 <dons> http://cgi.cse.unsw.edu.au/~dons/blog/2007/05/17#xmonad_part1b_zipper
04:57:46 <lambdabot> Title: Haskell hacking, http://tinyurl.com/ysnplo
04:58:10 <dons> (as an example of an easier colour for code)
04:58:12 <fasta> Lemmih: I see one problem.
04:58:52 <vincenz> dons: not sure how easy that'd be with google bloger
04:58:53 <fasta> Lemmih: no, that's not it either.
04:59:03 <vincenz> dons: I have my original post-entry as one .lhs file, html markup and all
04:59:03 <Lemmih> fasta: Paste the code?
04:59:11 <vincenz> that way I can darcs-save em
04:59:33 <vincenz> dons: this better?
05:00:29 <hpaste>  fasta annotated "Global variables do not work consistently?" with "Current code" at http://hpaste.org/1595#a1
05:00:59 <fasta> Lemmih: I didn't include code to use it, since trivial code does work.
05:03:01 <Lemmih> fasta: debug_off, debug_on and read_debug_var will probably not work.
05:03:08 <dons> yeah, a bit , vincenz.
05:03:16 <fasta> Lemmih: right, they don't.
05:03:33 <fasta> Lemmih: and why wouldn't they?
05:04:04 * vincenz switches to dark red
05:04:50 <Saizan> fasta they are CAF so they will be evaluated only once, i think
05:04:56 <vincenz> Does HsColour work with .lhs sources/
05:05:00 <Lemmih> fasta: 'unsafePerformIO (writeIORef debug_var False)'  ==  '()'. GHC is optimising 'debug_off' to () after it has been invoked.
05:05:25 <fasta> Saizan: in a previous version of GHC this did work.
05:05:39 <Lemmih> fasta: Forcing 'debug_*' to be inlined might work.
05:05:50 <vininim> wryyy, enumerations should be instance of Eq by default
05:06:00 <wli> I thought of another problem with the shootout.
05:06:27 <wli> The problems are essentially statically defined.
05:06:29 <Lemmih> fasta: What you're doing is quite a bit more evil than just a plain global mutable variable.
05:06:30 <Saizan> or just add dummy parameters so they can't be "memoized"?
05:06:34 <vincenz> malcolmw: ping
05:06:41 <fasta> Lemmih: it is?
05:07:12 <fasta> Lemmih: reading, writing, why is that evil? Because of the bang-patterns?
05:07:29 <wli> You should have a family of problems indexed by the natural numbers where n is the input and f(n) is output somehow.
05:07:46 <wli> Or otherwise some sort of nontrivial dependency on input.
05:07:47 <Saizan> is evil because you read-write unsafely, not just creating the ref unsafely
05:07:58 <Lemmih> fasta: Your functions are critically dependent on the execution order and inlinings of the program.
05:08:22 <wli> I'd suggest, for instance, outputting cos(2*pi/p) for primes p where p-1 is 3-smooth.
05:08:25 <fasta> Lemmih: I force executing order in the ST monad, and using !_
05:08:34 <fasta> Lemmih: execution*
05:08:45 <wli> Sorry, in terms of radicals.
05:08:48 <fasta> Lemmih: and yes, you are right, that's a bit evil.
05:08:57 <Lemmih> fasta: Great, don't use unsafePerformIO, then.
05:09:06 <Cale> fasta: why not just use an STRef?
05:09:27 <fasta> Cale: STRefs need to be passed around.
05:09:31 <Lemmih> fasta: Use unsafeIOToST.
05:10:00 <fasta> Lemmih: why would that avoid the earlier problems?
05:10:08 <Lemmih> fasta: Yes.
05:10:25 <Cale> fasta: because the IO operations would be properly sequenced in the ST monad.
05:11:22 <fasta> Cale: is this "guaranteed" to work for years to come?
05:11:37 <fasta> Cale: or is this still a hacky solution?
05:11:45 <Cale> More guaranteed, but still hacky.
05:11:48 <fasta> Cale: well, it's a bit hacky.
05:12:03 <fasta> Cale: ok, well, it should only need to work for a few months.
05:12:36 <Cale> Whenever you use the unsafe operations you should think of it as if you're writing hooks into the compiler or run-time.
05:13:01 <vininim_> !seen vininim
05:13:27 <fasta> Cale: you mean that it's not portable? (I know that)
05:14:00 <Cale> well, yes, and that how it works might be subtly affected by how the compiler works
05:14:03 <fasta> @seen vininim_
05:14:03 <lambdabot> vininim_ is in #haskell. I last heard vininim_ speak 1m 2s ago.
05:14:20 <quicksilver> Cale: I prefer to think of using the unsafe operations as sullying my good name and disgracing my family
05:14:24 <Cale> heh
05:16:43 <malcolmw> vincenz: pong
05:16:50 <vincenz> malcolmw: is hscolour line-based?
05:17:10 <malcolmw> vincenz: no, it treats the whole file as haskell
05:17:24 <vincenz> malcolmw: How hard do you think it would be to make it be able to treat .lhs files properly?
05:17:27 <Saizan> ndm: is Data.Derive.Functor supposed to be broken?
05:17:30 <malcolmw> vincenz: so .lhs will come out with odd colours in the middle of the commentary
05:17:52 <malcolmw> vincenz: not hard, I suppose
05:18:00 <ndm> Saizan: no, do you mean broken "won't compile" or "produces the wrong output"
05:18:24 <malcolmw> vincenz: could use the standard unlit line classifier, then just colour each literate line as a comment
05:18:34 <Saizan> ndm: the latter
05:18:56 <opqdonut> Saizan: example?
05:19:05 <vincenz> malcolmw: but then only the haskell-sections should be wrapped with <pre> </pre>
05:19:15 <Saizan> ndm: generic_instance doesn't consider the possibility of constructor classes, so you get instance Functor (Maybe a) where..
05:19:25 <malcolmw> vincenz: oh I see, yes that's a good idea
05:19:37 <vincenz> malcolmw: basically leave literate lines untouched
05:19:55 <Saizan> ndm: after soving that i get wrong code in fmap, like data Foo a = N | J a gives fmap f (J a) = J (id a)
05:19:58 <ndm> Saizan: feel free to submit a patch, i don't have the slightest idea what Functor should do...
05:20:31 <fasta> debug_var = unsafeIOToST(newIORef False) <- how do I read this somewhere else?
05:20:42 <vincenz> malcolmw: I take it that would require quite a drastic change to the code structure?
05:20:46 <bluestorm_> @src ap
05:20:46 <lambdabot> ap = liftM2 id
05:20:51 <malcolmw> vincenz: not really
05:21:01 <ndm> Saizan: i'm just digging up the guy who submitted that deriving, if you can report the bugs to him (and CC me), he will have a much better idea of what to do
05:21:29 <ndm> Saizan: twanvl -at- gmail -dot- com, name of Twan
05:21:41 <vincenz> malcolmw: oh right, this can be at the driver level, instead of going into hscolour, with repeated calls, where the second, third, fourth are always partial
05:21:59 <fasta> read_debug_var =unsafeIOToST( readIORef (runST debug_var))
05:22:03 <Saizan> ndm: ok, how should we call a variation of generic_instance that takes the class arity so it doesn't fill the constructor with too much typevars?
05:22:04 <fasta> Ok, that appears to work
05:22:06 <Cale> There ought to be only one reasonable thing to do. Basically, the function has to get applied to every value whose type is that of the type parameter, throughout the data structure.
05:22:14 <fasta> (well, it compiles, at least)
05:23:18 <malcolmw> vincenz: yes, it is an outer-level change - recognise a .lhs, find the code parts, and pass each in turn to the colouring function, with the partial flag
05:23:36 <vincenz> malcolmw: ok, thanks
05:23:42 <vincenz> malcolmw: right now I kiss and just use a flag
05:23:47 * vincenz isn't too familiar with your code yet
05:24:20 <vincenz> the problem is splitting and then after resplicing together
05:24:25 <malcolmw> a cmdline flag is probably useful anyway
05:24:58 <wli> There's another thing: a larger collection of benchmarks, along with statistical analysis on things (e.g. principal component analysis, independent component analysis, mutual information, etc.).
05:24:59 <malcolmw> see the cpphs package for an implementation of the Unlit line-classifier
05:25:01 <vincenz> [Either String String]
05:25:20 <vincenz> ok
05:25:53 <malcolmw> vincenz:  http://www.cs.york.ac.uk/fp/cpphs/cpphs/Language/Preprocessor/Unlit.html
05:25:56 <lambdabot> http://tinyurl.com/2s2sak
05:26:15 <ndm> Saizan: i'm not sure i entirely understand what this new generic_instance does - can you give an example of a data type, what generic_instance gives, and what your new one gives?
05:26:23 <ndm> Saizan: its a while since i touched Data.Derive ;)
05:26:29 <vincenz> malcolmw: (to eliminate the literate comments from the program text.)
05:26:46 <wli> I mean, seriously, how are you supposed to make heads or tails of umpteen benchmarks?
05:27:03 * vincenz rips some code
05:27:13 <vincenz> (like inlines)
05:27:28 <fasta> malcolmw: you wrote that Unlit code?
05:27:37 <malcolmw> vincenz: not to eliminate exactly.  if you replace the 'unclassify' function with something that spits out comment lines unchanged, but passes code lines through hscolour
05:27:45 <vincenz> I will
05:27:50 <vincenz> I'll use [Either String String]
05:27:56 <vincenz> then map only the right ones :)
05:28:10 <fasta> malcolmw: how much experience with Haskell did you have when you wrote that?
05:28:12 <malcolmw> fasta: came originally from the Haskell 1.0 report i think
05:28:24 <fasta> malcolmw: ok, that explains a lot.
05:28:48 <malcolmw> fasta: what do you think is wrong with it?
05:28:55 <fasta> malcolmw: I am not saying it's "bad", just that it looks like what first years students would write.
05:29:51 <fasta> malcolmw: modulo the comments on reduced laziness.
05:29:58 <dons> fasta, you mean, straightforward?
05:30:11 <malcolmw> fasta: well I can't think of any nice folds or higher-order goodness to throw in
05:30:24 <fasta> dons: maybe, it just reminds of other code I have seen.
05:30:30 <vincenz> stuff like ((x:y):xs)
05:30:33 <vincenz> iso (x:y:xs)
05:30:46 <Cale> vincenz: hm?
05:30:50 <Igloo> They aren't the same
05:31:00 <Igloo> x:y:xs == x:(y:xs)
05:31:07 <ttmrichter> The wiki page at http://www.haskell.org/haskellwiki/Prime_numbers refers to an "idiom" and points to ShowS and DList as other examples of it.  I don't get it.  At all.  What's the idiom?
05:31:08 <lambdabot> Title: Prime numbers - HaskellWiki
05:31:26 <dons> ttmrichter: using function composition to do append in O(1)
05:31:36 <vincenz> doh!
05:31:40 <vincenz> Igloo: correct
05:31:59 <Cale> er, except that it can't be that
05:32:08 <vininim_> mmm what was that list processing function akin to *** arrow?
05:32:12 <Cale> That's what I thought it was as well
05:32:23 <ttmrichter> dons: I'm still lost.  Is there a more ... pedagogical explanation out there somewhere?  The code is utterly opaque to me.
05:32:49 <Saizan> ndm: generic_instance "Functor" (dataDefOf ''Maybe) [] body ~~> instance Functor (Maybe a) where $(body), newgeneric_instance "Functor" 1 (dataDefOf ''Maybe) [] body ~~> instance Functor Maybe where $(body), so generic_instance c = newgeneric_instance c 0, however it's better if i write this in a mail, maybe :)
05:33:45 <ttmrichter> dons: For example the "merge" and "diff" functions have no terminating conditions.  I assume they're present to work only on infinite lists, so it's not a functionality problem, but it is a comprehension problem while trying to figure them out.  :)
05:33:59 <jethr0> vininim: huh? zip?
05:34:07 <Cale> ttmrichter: Perhaps the "idiom" is "using lazy evaluation"? I don't get it either.
05:34:16 <jacquesmerde> can someone recommend a ghc slackware package?
05:34:18 <vininim> zipWith
05:34:19 <vininim> yes
05:34:26 <ndm> Saizan: i guess so, and cc Twan - I'm happy to accept whatever is best for the functor stuff, i don't use it, but it will obviously benefit everyone the better it is
05:34:27 <vininim> thanks
05:34:37 <ttmrichter> Cale: You have no idea how relieved I am to hear that.  :)
05:34:40 <dons> ttmrichter: http://www.cse.unsw.edu.au/~dons/code/dlist/Data/DList.hs perhaps?
05:34:42 <jethr0> vininim: from that description i would have never guessed i'd be correct ;)
05:35:00 <dons> but that's not the same as the 'lazy' thingy with primes on that page
05:35:04 <dons> which is just weird. :)
05:35:06 <Cale> ttmrichter: I don't really understand how that code and DList/ShowS are at all similar.
05:35:08 <ttmrichter> dons: I've got that page open.  It's more code.  It's just as opaque to me.  I don't see anything there that's an "idiom".
05:35:18 <ttmrichter> What Cale said.
05:35:29 <ttmrichter> Not that I can actually *FIND* ShowS source....
05:35:31 <dons> append xs ys = DL (unDL xs . unDL ys)   is the idiom
05:35:34 <Cale> ttmrichter: ShowS and DList share an idiom
05:35:53 <ttmrichter> Well, I'm sure I'd be able to see that if I could find ShowS source.  :D
05:35:55 <Cale> ttmrichter: That idiom is the replacement of lists by functions which prepend things to lists.
05:36:00 <dons> type ShowS = String -> String
05:36:15 <ttmrichter> I know the TYPE of ShowS.  That I found in seconds.  :)
05:36:20 <hpaste>  fasta annotated "Global variables do not work consistently?" with "With unsafeIOToST it still doesn't work" at http://hpaste.org/1595#a2
05:36:25 <Cale> ttmrichter: You can "concatenate" two such functions efficiently with function composition.
05:36:25 <ttmrichter> It's the implementation I can't find.
05:36:48 <Cale> ttmrichter: as opposed to using xs ++ ys which takes O(length xs) time
05:37:17 <Cale> 'concatenation' of functions [a] -> [a] is just composition, which happens in constant time.
05:37:31 <fasta> It's better to code against an ADT.
05:37:37 <Cale> For instance, the algorithm
05:37:57 <Cale> data Tree a = Leaf a | Branch a (Tree a) (Tree a)
05:37:59 <fasta> Lemmih: ^^
05:38:01 <ttmrichter> OK, so the idiom in ShowS and DList is the use of functions instead of lists to fake out their concatenation in more efficient time?
05:38:12 <Cale> inorder (Leaf a) = [a]
05:38:18 <fasta> ttmrichter: yes
05:38:28 <Cale> inorder (Branch x l r) = inorder l ++ [x] ++ inorder r
05:38:31 <fasta> ttmrichter: although I have no idea what you mean by faking.
05:38:49 <ttmrichter> This brings me back to that Primes function (which *IS* impressively fast).  Where is the composition going on there?
05:38:53 <Cale> suffers from a problem where left-leaning trees are going to cost a lot to inorder
05:39:02 <Cale> So to fix that:
05:39:13 <Cale> inorder' (Leaf x) = (x:)
05:39:28 <Cale> inorder' (Branch x l r) = inorder' l . (x:) . inorder' r
05:39:39 <Cale> inorder t = inorder' t []
05:39:46 <opqdonut> Cale: nice
05:40:00 <Cale> which avoids the costly (++) operations
05:40:17 <Cale> That's not happening with the primes code.
05:40:50 <ttmrichter> Cale, fasta: OK, I see what you mean here.  "faking" is possibly the wrong word here.  "Deferring" is perhaps a better choice.
05:41:22 <ttmrichter> This lazy evaluation is severely straining the limits of my poor brain.  :)
05:41:42 <fasta> Cale: could you respond to the unsafeSTToIO thing?
05:42:05 <ttmrichter> So, yeah.  I'm even more mystified by the primes code -- both what the "idiom" is and how it works.
05:42:09 <fasta> Cale: I already solved it, but I would like to hear it from you too.
05:42:24 <ttmrichter> I'll slog away at the second part of the problem myself -- understanding how it works.  I've been instrumenting it like crazy.
05:42:35 <ttmrichter> And I'll just assume for now I'm too blind to see the idiom.
05:42:37 <fasta> ttmrichter: you should grab a piece of paper and do evaluation manually.
05:42:43 <fasta> ttmrichter: or google the logs
05:42:51 <fasta> ttmrichter: this is a FAQ
05:43:00 <ttmrichter> The logs of ... ?
05:43:09 <fasta> ttmrichter: or this IRC channel
05:43:13 <fasta> ttmrichter: of*
05:43:35 <ttmrichter> So that particular primes code is a FAQ?  :O
05:43:41 <ttmrichter> Pretty damned specific FAQ.  :D
05:44:13 <fasta> ttmrichter: the world is full of people with a desire to know how it works.
05:44:27 <chessguy> bos, ping
05:44:29 <opqdonut> where is this primes code?
05:44:34 <ttmrichter> http://www.haskell.org/haskellwiki/Prime_numbers
05:44:36 <lambdabot> Title: Prime numbers - HaskellWiki
05:44:43 <opqdonut> thanks :)
05:44:48 <ttmrichter> No probs.
05:44:56 <ttmrichter> fasta: How many people wind up understanding it?
05:45:06 <vininim> [] ++ ys = ys; (x:xs) ++ ys = x:(xs ++ ys); ?
05:45:09 <fasta> ttmrichter: I don't keep score.
05:45:16 <ttmrichter> (And how many people would mind me butchering up that code on the Wiki to actually explain it so it doesn't become a #haskell meme?
05:45:25 <fasta> ttmrichter: do you care what other people understand?
05:45:48 <ttmrichter> If 0.1% of those attempting to understand something succeed, my odds of success are very low.  I'm a dullard, you see.
05:46:11 <fasta> ttmrichter: you shouldn't ask, you should just do the evaluation by hand.
05:46:19 <fasta> ttmrichter: that provides much more insight
05:46:27 <chessguy> @src (++)
05:46:27 <lambdabot> (++) []     ys = ys
05:46:27 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
05:46:28 <vincenz> malcolmw: this won't be the most well-designed code
05:46:42 <chessguy> ding ding ding, we have a winner!
05:46:50 <malcolmw> vincenz: I can clean it up afterwards if I don't like it
05:47:02 <chessguy> hey vincenz, very interesting blog today on higher-order zippers
05:47:17 <vininim> ah, I'm no beginner, that is probably set to stone in my head, even though I had to think about it =P
05:47:19 <fasta> @where vincenz
05:47:20 <lambdabot> http://www.esat.kuleuven.ac.be/~cpoucet/
05:47:38 <Cale> ttmrichter: I've never heard anyone ask about that primes code before, but the (++) -> (.) thing is common.
05:47:40 <ttmrichter> Googling for the #haskell log has proven -- well, less than helpful.  Any other useful terms beyond "#haskell" and "log"?
05:47:47 <Cale> fasta: I'll have a look
05:47:50 <vincenz> chessguy: thanks
05:48:00 <chessguy> vincenz++
05:48:04 <vincenz> :)
05:48:14 <vincenz> it's not finished yet
05:48:18 <fasta> Cale: I think I understand the issue myself, but I wonder whether you understood the implications of your suggestion.
05:48:21 <malcolmw> ttmrichter: http://ircbrowse.com
05:48:23 <vincenz> I might need to add some diagrams to make it more digestable towards the end :/
05:48:25 <vincenz> and finish the tree
05:48:32 <Cale> fasta: how are you running runST on debug_var?
05:48:39 <Cale> err...
05:48:45 <chessguy> vincenz, you might want to say from the outset that you don't mean "higher order" in the same sense as "higher order functions"
05:48:55 <fasta> Cale: ?
05:48:58 <vincenz> chessguy: hmm, good point
05:48:58 <vininim> @src zipWith
05:48:59 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
05:48:59 <lambdabot> zipWith _ _      _      = []
05:49:01 <chessguy> (unless there's some correlation i don't know about)
05:49:05 <vincenz> though the type is simply Zipper (Zipper d) a
05:49:09 <Cale> fasta: doesn't that give an error?
05:49:16 <malcolmw> ttmrichter: also, in the header of the channel, it says Logs: http://tunes.org/~nef/logs/haskell/
05:49:18 <lambdabot> Title: Index of /~nef/logs/haskell
05:49:18 <vincenz> but yes, probably a wrong terminology
05:49:20 <fasta> Cale: the trace does
05:49:25 <fasta> Cale: but otherwise, no
05:49:29 <Cale> oh, no, it doesn't because that's an IORef
05:49:37 <chessguy> well, it's not *wrong*
05:49:46 <fasta> Cale: the trace needs a (return ())
05:49:46 <chessguy> a higher-order derivative makes sense
05:49:54 <vincenz> malcolmw: doh, one small issue... encoding the '>' in a language independent way :/
05:49:56 <Cale> You need to create the IORef and put it at top-level like usual.
05:50:04 <vincenz> malcolmw: when re-inserting it at the end
05:50:19 <Cale> er, or it could be an STRef, even.
05:50:41 <fasta> vincenz: Huet didn't invent the zipper
05:50:54 <ttmrichter> They want registration to search logs?  :O
05:50:58 <ttmrichter> That is ... very odd.
05:51:03 <Cale> debug_var = unsafeIOToST(newIORef False) -- this is still a computation which creates an IORef.
05:51:06 <fasta> vincenz: it is a very old technique based on pointer reversal.
05:51:09 * ttmrichter makes another fake Internet identity.
05:51:36 <vincenz> fasta: oh, thanks, that's just the first referencee I found ottomh
05:51:46 <malcolmw> vincenz: why are you re-inserting the bird track > chars?  why not just leave them to hscolour to escape/not as appropraite?
05:51:52 <chessguy> hm, i thought Huet invented it too
05:51:55 <fasta> vincenz: if you had actually read the article you would see that :)
05:52:08 <fasta> vincenz: although, I don't think he mentions "pointer reversal".
05:52:10 <vincenz> fasta: I read it a long while ago
05:52:17 <vincenz> malcolmw: I want my blog entries to be copy-pastable .lhs code
05:52:18 <fasta> vincenz: ok
05:52:25 <Cale> http://tunes.org/~nef/logs/haskell/
05:52:25 <lambdabot> Title: Index of /~nef/logs/haskell
05:52:34 <Cale> er, oh :)
05:52:35 <Cale> hehe
05:52:46 <vincenz> malcolmw: and I don't want them to mess with hs-colour?
05:52:47 <Cale> already suggested
05:52:48 <fasta> vincenz: I can now actually see your code with this new style
05:52:52 <fasta> vincenz: nice
05:52:53 <vincenz> malcolmw: or hscolour is simply token based?
05:52:59 <malcolmw> vincenz: but hscolour will change > into &gt; for you
05:53:15 <vincenz> malcolmw: so it's purely token based?
05:53:21 <malcolmw> vincenz: yep
05:53:28 <vincenz> alright, that simplifies things :)
05:53:37 <vincenz> but this assumption should be noted down in case it ever changes ;)
05:53:41 <vincenz> cause this might break things
05:53:50 <vincenz> fasta: great :)
05:53:50 <fasta> Cale: have an idea already?
05:55:04 <oerjan> hm... coloring patterns different from expressions, say.
05:55:49 <desp> hi
05:55:53 <vincenz> oerjan: for instance
05:56:02 <vincenz> oerjan: or type-expressions different than terms
05:56:06 <desp> can someone tell me exactly what causes ghc to break with a <<loop>> exception?
05:56:27 <vincenz> desp: an infinite loop
05:56:34 <vincenz> oh, ghc? o.O
05:56:37 <oerjan> desp: when an expression is to be evaluated, ghc puts a "black hole" in it
05:56:40 <oerjan> i think
05:56:59 <desp> vincenz: well, a ghc-compiled program
05:57:04 <oerjan> and if it somehow cyclically reaches that expression again before it is evaluated, <<loop>> is raised
05:57:17 <mehrheit> > undefined
05:57:19 <lambdabot>  Undefined
05:57:22 <vincenz> malcolmw: success
05:57:26 <hpaste>  Cale annotated "Global variables do not work consistently?" with "try this." at http://hpaste.org/1595#a3
05:57:28 <desp> oerjan: so -- if the value of an expression depends on the expression itself
05:57:31 <desp> > x = x + 1
05:57:32 <lambdabot>  Parse error
05:57:40 <desp> > let x = x + 1
05:57:41 <lambdabot>  Parse error
05:57:44 <desp> er.
05:57:45 <mehrheit> > let x = x in x
05:57:47 <lambdabot>  Exception: <<loop>>
05:57:50 <desp> right
05:57:53 <fasta> vincenz: GHC can find some cases.
05:57:57 <oerjan> desp: yes
05:58:00 <fasta> vincenz: Hugs is smarter
05:58:07 * malcolmw looks forward to receiving vincenz's patch
05:58:29 <Cale> fasta: try that?
05:58:47 <fasta> Cale: if it works, it's a better solution that I had.
05:59:14 <fasta> Cale: Mine was to turn the unsafeSTToIO to unsafePerformIO for debug_var
05:59:22 <fasta> Cale: which I tested that works..
05:59:54 <fasta> Cale: are you sure you need the unsafeSTToIO in debugVar?
06:00:04 <fasta> Cale: never mind
06:00:08 <fasta> Cale: yes, you do./
06:00:13 <Cale> fasta: Basically, unsafePerformIO . unsafeSTToIO is like runST, but circumvents the type system.
06:00:47 <desp> is there a way to trace the evaluation process?
06:00:55 <EvilTerran> ?type trace
06:00:57 <lambdabot> Not in scope: `trace'
06:00:59 <Cale> desp: Debug.Trace.trace
06:01:06 <vincenz> SUCCESS!
06:01:11 <vincenz> malcolmw: http://notvincenz.blogspot.com/2007/07/higher-order-zippers.html
06:01:12 <lambdabot> Title: lambda.oasis: Higher Order Zippers
06:01:19 * quicksilver ponders a DMCA for the type system
06:01:20 <Cale> desp: will let you stick little messages in to be printed when the things they tag are evaluated.
06:01:38 <quicksilver> Cale: I'm conducting a citizen's arrest for unauthorised type system circumvention. You have the right to remain silent.
06:01:43 <Cale> heh
06:01:45 <desp> Cale: thanks
06:01:52 <desp> quicksilver: :)
06:01:57 <Lemmih> Cale: Why use an STRef instead of an IORef?
06:02:02 <EvilTerran> @docs Debug.Trace
06:02:03 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Debug-Trace.html
06:02:17 <Cale> Lemmih: because it makes the rest of the operations cleaner when he's already coding in ST?
06:03:06 <quicksilver> Cale: did you read my / sjannsen's attempts to 'conceal' custom monads into pure IO callbacks?
06:03:16 <Cale> no
06:03:19 <vincenz> malcolmw: how do I send you the patch?
06:03:21 <Cale> what's that all about?
06:03:51 <malcolmw> vincenz: darcs record; darcs send
06:03:57 <vininim> identation + labeled fields = woot
06:03:59 <Cale> Trying to embed arbitrary monads in IO? :)
06:04:03 <quicksilver> Cale: yes
06:04:14 <quicksilver> Cale: so that you can use callbacks in lirbaries which don't know about your monad
06:04:29 <Cale> I don't think you can do that universally, but you can probably do it for a fairly good class of monads.
06:04:32 <quicksilver> Cale: (obviously you can't do it for arbitrary monads, but its feasible for state-like)
06:04:43 <malcolmw> vincenz: not forgetting, you might need a darcs add if you threw in the unlit module
06:04:46 <Cale> The list monad in particular seems tough ;)
06:04:46 <Lemmih> Cale: Using 'unsafePerformIO . unsafeSTToIO' seems more hackish to me.
06:04:53 <vincenz> malcolmw: no I just modified HsColour.hs
06:04:54 <vininim> who are the k&r of haskell? I need some inspiration for beautifying my code in 80 char wide terminal =)
06:05:04 <quicksilver> Cale: yes, anything which duplicates the current continuation is out :)
06:05:06 <quicksilver> Cale: http://hpaste.org/1592
06:05:12 <vincenz> quicksilver: I was thinking the same thing... a language that allows you to write d(T)/dX :)
06:05:34 <quicksilver> Cale: and sjanssen's http://hpaste.org/1593
06:05:35 <Cale> vincenz: the only problem I found with that is getting good names for the constructors :)
06:05:43 <vincenz> Cale: yah :)
06:05:50 <vincenz> Cale: especially what they mean o.O
06:05:59 <vincenz> it was non obvious until I mathematically transformed the formula
06:06:02 <vincenz> and replaced p' by p
06:06:09 <vincenz> (cause they're iso)
06:07:35 <Cale> vincenz: It's funny how everyone now credits Huet for this idea. :) I wonder if he independently discovered it or if he knew that it's existed in algebraic combinatorics for a long time now. :)
06:07:54 <vincenz> malcolmw: sent
06:08:04 <quicksilver> Cale: of course, it would be 'nice' if libraries were written over MonadIO, not plain IO. But they aren't.
06:08:12 <quicksilver> Cale: and, AFAIK, the FFI "can't be".
06:08:16 <opqdonut> ?src Data.Array.bounds
06:08:17 <lambdabot> Source not found. Do you think like you type?
06:08:38 <malcolmw> vincenz: received
06:08:41 <EvilTerran> ?src bounds
06:08:41 <lambdabot> bounds (Array l u _) = (l,u)
06:08:57 <Cale> quicksilver: however, one thing which will probably be happening soon is that FFI will allow you to use newtypes of IO in FFI.
06:09:17 <Cale> Which is rather nice for restricted operations.
06:09:21 * quicksilver nods
06:09:25 <opqdonut> thanks EvilTerran
06:09:31 <quicksilver> that's a great thing
06:09:34 <opqdonut> ?src inRange
06:09:34 <lambdabot> Source not found. stty: unknown mode: doofus
06:09:36 <dons> i think that's already allowed, Cale
06:09:36 <quicksilver> don't think it helps in this case though, does it?
06:09:44 <EvilTerran> np
06:10:56 <hpaste>  vininim pasted "(no title)" at http://hpaste.org/1596
06:11:15 <vininim> suggestions on indentation? ;)
06:12:39 <hpaste>  quicksilver annotated "(no title)" with "this perhaps?" at http://hpaste.org/1596#a1
06:12:48 <quicksilver> vincenz: guards often read better than ifs
06:13:14 <vincenz> quicksilver: ?
06:13:26 <vincenz> quicksilver: ah wrong tab-complete :P
06:13:34 <quicksilver> vincenz: doh
06:13:39 <quicksilver> vininim: guards often read better than ifs
06:13:59 <scook0> vininim: consider pulling some of those subexpressions out into a "where"
06:16:06 <hpaste>  quicksilver annotated "(no title)" with "update notation, maybe" at http://hpaste.org/1596#a2
06:16:19 <quicksilver> vininim: that removes some of the noise
06:16:22 <desp> looks like lazy evaluation hath risen to bite me in the arse
06:16:31 <Cale> desp: hm? :)
06:16:44 <desp> Cale: I can't figure out what's causing the <<loop>>
06:17:01 <desp> and I suspect it's due to my subconscious strictness
06:17:01 <Cale> Oh, can I see?
06:17:13 <Cale> No, if you get that, it's an infinite loop in any language.
06:17:26 <desp> hrm, but really
06:17:30 <SamB_XP_> desp: did you get +RTS -xc to work?
06:17:37 <Cale> That kind of loop is the sort where in order to evaluate x, you must first evaluate x.
06:17:47 <Cale> yeah, you should try that
06:17:57 <Cale> Compile with -prof -auto-all
06:18:03 <desp> yeah, I have located the exact bit of code that causes the <<loop>>
06:18:08 <Cale> and then run the program with the options +RTS -xc
06:18:10 <desp> problem is, it doesn't look as a loop at all
06:18:13 <desp> yep, did that
06:18:17 <Cale> can you paste the code?
06:18:26 <EvilTerran> vininim, inside changeifn, the (n) is (i) and (dx) is (-n)? i'm confused...
06:18:27 <Cale> http://hpaste.org/new
06:18:44 <SamB_XP_> ah. you might want to consider having GHC show you the final Core code...
06:18:49 <dons> i have a theory: sophisticated type systems prevent lisp-like community fracture
06:18:59 <dons> since its just too expensive to reimplement haskell 40 times
06:19:18 <Cale> dons: Just wait until I start my left-associative-($) faction! Mwahahaha!
06:19:19 <shapr> Good morning #haskell!
06:19:29 <SamB_XP_> who cares if we do reimplement haskell 40 times?
06:19:37 <dons> all the popular languages have very few implementations, meaning they avoid incompatible branches
06:19:40 <ricky_clarkson> dons: Just wait for sophisticated pluggable type systems. ;)
06:19:41 <dons> C++, python, perl
06:19:48 <SamB_XP_> so long as we get our libraries to work on most of them
06:20:02 <hpaste>  jethr0 annotated "(no title)" with "hmmm" at http://hpaste.org/1596#a3
06:20:09 <dons> while things like prolog or lisp stagnate once effort goes into implementing all the variants
06:20:13 <hpaste>  desp pasted "loopy loop" at http://hpaste.org/1597
06:20:15 <ricky_clarkson> C and FORTRAN had lots of implementations, afaik.
06:20:16 <dons> divide and conquer
06:20:17 <Cale> We should really do at least one more big change at some point
06:20:19 <quicksilver> dons: we do have at least four independent implementations
06:20:28 <quicksilver> dons: which pretty impressive
06:20:33 <dons> indeed.
06:20:37 <SamB_XP_> quicksilver: what's the fourth one?
06:20:37 <vininim> hahaha EvilTerran , I have a scoped mind, n in the let/where is not the same as n in the function argument xD~
06:20:38 <quicksilver> (and yet, they haven't fractured much)
06:20:43 <SamB_XP_> oh, hugs?
06:20:44 <dons> and they're not trying to fork
06:20:44 <desp> Cale: this code is part of the libcurl bindings, and might seem a bit impenetrable out-of-context...
06:20:50 <quicksilver> SamB_XP_: ghc, hugs, n(y)hc and jhc
06:20:59 <dons> whereas lisp/scheme is more like clean/ocaml/haskell all being considered "the same"
06:21:04 <desp> Cale: but you can check out the bindings project from darcs at http://varsztat.com/projects/curl/
06:21:07 <lambdabot> Title: Haskell bindings for libcurl
06:21:10 <EvilTerran> vininim, i'd be inclined to not bother passing those two as parameters to changeifn
06:21:23 <dons> so: make you language sufficiently complex that its too hard to reimplement and change all the prelude names
06:21:31 <ndm> i now have an example where C code runs slower than Haskell code!
06:21:38 <quicksilver> ndm: nice, what does it do?
06:21:39 <dons> yay, ndm :)
06:21:42 <desp> Cale: and the bug is pinned down in the very latest patch
06:21:43 <ndm> both optimised low-level versions
06:21:47 <matthew-_> ndm: did you insert sleep statements in the C code though?
06:22:02 <desp> SamB_XP_: how can I get GHC to show me the final Core code?
06:22:13 <ndm> quicksilver: word counting: print . length . words =<< getContents
06:22:39 <Cale> desp: Okay, what creates that multiVar?
06:22:43 <vininim> EvilTerran: why?
06:22:48 <jethr0> quicksilver: haskell is 20 years old, lisp is 50 years old. and ghci has loads of features onknown to the other implementations, so that's a form of fracturing as well unless all the other implementations follow at some point
06:22:50 <ndm> matthew-_: no, the C code can't express two tight loops with transitions between them easily, whereas the Haskell optimises it out of a nested linked list :)
06:23:06 <ndm> @paste
06:23:06 <lambdabot> Haskell pastebin: http://hpaste.org/new
06:23:23 <hpaste>  ndm pasted "C word counting" at http://hpaste.org/1598
06:23:30 <ndm> thats the C word counting version
06:23:36 <dons> ndm, yeah, concatMap/list comprehensions is great for tight loop tricks
06:23:39 <EvilTerran> vininim, well, seeing they don't change between invokations of the function, it seems unnecessary. also my way reduces the number of variable names floating around, which I like.
06:23:44 <matthew-_> ndm: there are lots of people working on loop fusion for C and C++
06:23:59 <ndm> the inefficiency is that the 1-bit last_space  variable is a variable, not stored in the program counter
06:24:12 <dons> its just really hard, matthew-_ , since you've got to first identify what combinator each loop represents
06:24:14 <ndm> matthew-_: the C one has been manually loop fusioned already
06:24:17 <jethr0> sorry, 10 years not 20
06:24:22 <SamB_XP_> jethr0: ... the other option is for ghc to drop features ;-)
06:24:26 <dons> once you've named them, you've then got to do an effect analysis
06:24:34 <ndm> dons: this is the standard words function, so a break/dropWhile/case thingy
06:24:34 <dons> and then *once* you've got all that, you're where haskell starts
06:24:39 <dons> which named loops, that you know how to fuse
06:24:45 <vininim> they do change, i "iterates" over [1..] and n is the heap where the move is applied
06:24:48 <SamB_XP_> jethr0: you think haskell is from '97?
06:24:49 <quicksilver> ndm: is this a supero demo? or ghc's optimiser?
06:24:58 <ndm> quicksilver: supero, then ghc -O2 -fasm
06:25:06 * quicksilver nods
06:25:11 <jethr0> k, from 1990 then
06:25:17 <EvilTerran> vininim, but i have too little context to rewrite it to show you exactly what i mean. my choice of variable names would probably make no sense. ;]
06:25:55 <SamB_XP_> desp: I don't rememeber exactly :-(
06:25:56 <dons> ndm, might also be profitable to crank up specConstr
06:25:57 <jethr0> SamB_XP_: my point really was that comparing one of the oldest languages with a rather young one in "fracturation" was kinda unfair
06:26:02 <desp> SamB_XP_: ok
06:26:06 <quicksilver> jethr0: it's a fair point
06:26:07 <SamB_XP_> I wish they had an option called -ddump-final-core
06:26:11 <ndm> dons: nope, thats with supero firing, there is no data left by that stage
06:26:16 <SamB_XP_> even if it did alias another option
06:26:17 <ndm> SamB_XP_: -ddump-simpl
06:26:49 <vininim> EvilTerran: it's a nim game, that function is just return a list with the nth element changed with dx, nothing really exotic :)
06:26:55 <ndm> dons: would be more profitable to fix the heap checks (they are in the wrong place), eliminate the stack checks, and fix the strictness analyser
06:26:57 <SamB_XP_> and, who knows, maybe they'll add another stage to GHC some day!
06:27:03 <desp> what the hell.
06:27:16 <dons> ndm, yes. push them on this.
06:27:17 <desp> did I corrupt my darcs rep somehow?
06:27:23 <SamB_XP_> desp: oh dear :-(
06:27:32 <dons> we need the heap/stack checks lifted out for bytestrings, ndp, all the fast stuff
06:27:35 <SamB_XP_> copy it and do a "darcs repair"
06:27:55 <ndm> dons: i've reported them all, its scary that this benchmark is 10% faster than C AND it has the extra obviously redundant heap checks, AND it has missed the strictness
06:27:57 <dons> ndm, we used -O2 -fasm -fliberate-case-threshold100 -fdicts-cheap -fno-method-sharing -fmax-simplifier-iterations6
06:28:08 <dons> but that's programming ghc's optimiser
06:28:10 <dons> you're doing your own
06:28:19 <ndm> dons: all irrelevant for me, i think, since Supero does all those tricks and many more on its own
06:28:29 <desp> "Applying patch 6 of 10... darcs: Couldn't read patch Sun Jul  8 03:28:14 CEST 2007  ..."
06:28:37 <desp> how does this happen?
06:28:37 <ndm> its only the Core -> CMM side of things i want beefing up, strictness, heap checks etc
06:28:45 <SamB_XP_> ndm: so what did you do about IO?
06:28:54 <ndm> SamB_XP_: thats using getchar for IO
06:29:21 <dons> the correctness/strictness aspect worries me a little, ndm. i hope you're thinking about that with these aggressive optimisations.
06:29:30 <hpaste>  EvilTerran annotated "(no title)" with "probably how i'd do it" at http://hpaste.org/1596#a4
06:29:36 <dons> think about the bug reports we get with fusion messing with strictness, floating effects around and so on
06:29:39 <SamB_XP_> so you aren't mutilating the IO monad code?
06:29:45 <ndm> dons: don't worry, its all covered - the correctness and strictness are both done automatically, and 100% safe
06:30:22 <ndm> dons: unlike your stream/unstream, i don't have to write any library specific code, so there is less "human work" in it, beyond the initial rules
06:30:47 <ndm> if i get it wrong, it will be on a spectacular "nearly all the time" level, so should be easier to spot
06:31:07 <ndm> but i have considered all these things, and my PhD will have a proof that the strictness/laziness/sharing/semantics are all preserved
06:31:39 <SamB_XP_> and then 60 years later someone will discover an error in the proof, right?
06:31:58 <quicksilver> getContents >>= countwords --- with ndm's optimisations, this will launch the USB nuclear missiles!
06:32:20 <ndm> my internal examiner is a semantics expert, there is nearly no chance i'd manage to slip an incorrect proof past him
06:32:47 <vininim> that does sound like "BD+ will be unbreakable for the next 10 years" =p
06:33:23 <desp> sigh...
06:33:30 <ndm> there is a difference between "i use formal semantics" and "this encryption is unbreakable, even when given the key, algorithm and data"
06:33:34 <SamB_XP_> desp: you can't read the core?
06:33:45 <desp> SamB_XP_: I can't un-fubar my darcs rep
06:33:54 <SamB_XP_> oh, right :-(
06:34:04 <SamB_XP_> darcs repair was no help?
06:34:22 <desp> and I fubared it myself
06:34:27 <vincenz> the problem with encryption is that you can always use a side-attack based on the implementation even if the semantics are robust :(
06:34:34 <desp> I thought I could edit the patch description in the inventory file
06:34:40 <SamB_XP_> eeeeeek
06:34:41 <desp> since it looks like plain text
06:34:41 <vincenz> you can't formally prove the absence of those
06:34:43 <desp> ;p
06:34:56 <SamB_XP_> you might be able to fix it
06:34:57 <desp> and the text is apparently hashed into the patch name
06:35:21 <desp> yeah, if I could remember the exact wording I used before ;p
06:35:28 <SamB_XP_> do the patch files have descriptions in them...?
06:35:31 <desp> or if someone knows how darcs hashes the text
06:36:10 <ndm> vincenz: the problem with encryption is that there is no way to prove the semantics are robust
06:36:30 <Saul_> Is there an easy way to pattern match a character as being one of a set?
06:36:32 <vincenz> ndm: so even worse :)
06:36:44 <EvilTerran> vininim, did you see my annotation to your paste?
06:36:47 <SamB_XP_> yeah, you can't crack an optimizer ;-)
06:37:00 <Igloo> Can I do strikethrough text on the Haskell wiki?
06:37:20 <Saul_> For example, if the char is a letter?
06:37:23 <ndm> you can do HTML can't you?
06:37:39 <quicksilver> Saul_: Data.Char.isLetter
06:37:39 <SamB_XP_> > isAlpha '1'
06:37:44 <quicksilver> :t isLetter
06:37:48 <lambdabot> Char -> Bool
06:37:48 <lambdabot>  False
06:37:49 <Igloo> Ah, yes, thanks
06:38:00 <Saul_> ok thanks
06:38:14 <SamB_XP_> > filter isAlpha ['\0'..]
06:38:15 <lambdabot>  "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\170\181\186\192\193\19...
06:38:16 <Saul_> And you can use that in the left hand side of function definition?
06:38:23 <SamB_XP_> > filter isLetter ['\0'..]
06:38:24 <lambdabot>  "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\170\181\186\192\193\19...
06:38:33 <desp> SamB_XP_: good call, thanks. fixed it
06:38:36 <quicksilver> Saul_: you can't do it in a pttern, but you can on a guard
06:38:51 <Saul_> Ok I'll use some guards then, thanks
06:38:56 <SamB_XP_> @hoogle diff
06:38:57 <lambdabot> Data.Array.Diff :: module
06:38:57 <lambdabot> Time.diffClockTimes :: ClockTime -> ClockTime -> TimeDiff
06:38:57 <lambdabot> Data.IntMap.difference :: IntMap a -> IntMap b -> IntMap a
06:38:58 <quicksilver> Saul_: f x | isLetter x = "it was a letter!"
06:39:48 <SamB_XP_> > filter isLetter ['\0'..] `difference` filter isAlpha ['\0'..]
06:39:49 <lambdabot>   Not in scope: `difference'
06:39:53 <SamB_XP_> aww.
06:40:14 <quicksilver> :t (\\)
06:40:16 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
06:40:22 <vininim> oh i get what you mean (30 minutes later, regarding a subject already cast into void)
06:40:34 <SamB_XP_> > filter isLetter ['\0'..] \\ filter isAlpha ['\0'..]
06:40:36 <lambdabot>  ""
06:40:55 <desp> I notice that the patches I unrecorded are still there in the darcs rep -- how can I get rid of them?  darcs optimize doesn't.
06:40:55 <vininim> @src (\\)
06:40:56 <lambdabot> (\\) = foldl (flip delete)
06:41:37 <SamB_XP_> desp: darcs revert?
06:41:54 <SamB_XP_> or you mean the files are there?
06:41:59 <desp> just the files
06:42:07 <desp> in the patches dir
06:42:21 <SamB_XP_> if so, do a darcs get of your repository before trying to delete those files
06:43:27 <desp> SamB_XP_: ack, thanks!
06:43:32 <desp> SamB++
06:44:24 <vininim> @src flip
06:44:24 <lambdabot> flip f x y = f y x
06:44:50 <SamB_XP_> hmm, I actually meant "it would be nice to have a backup before you potentially screw things up because you are in an alternate timeline where you didn't unrecord those patches"
06:44:59 <vininim> does ghci has something like lambdabot @src ?
06:45:06 <SamB_XP_> it has :i
06:45:15 <SamB_XP_> which has a tendancy to tell you where something is defined
06:45:16 <desp> SamB_XP_: well, I did unrecord those patches
06:45:30 <desp> it's just like the files were left behind
06:45:58 <dmwit> What's the "fix" version of factorial?
06:46:01 <desp> I did a record using a new DARCS_EDITOR, which didn't work out properly and didn't enter a long description, so I unrecorded directly afterwards
06:46:03 <SamB_XP_> desp: well, sometimes funny things happen, especially when your darcs repo was just narrowly un-corrupted ;-)
06:46:10 <desp> :)
06:46:21 <desp> ok, the rep is back to normal and online...wheww
06:46:33 <SamB_XP_> now remember to keep two copies ;-)
06:46:42 <SamB_XP_> one to work in, and one to go on the net
06:46:54 <bluestorm_> @src liftM
06:46:54 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
06:46:58 <Saizan> > let fac = fix \f n -> if n == 0 then 1 else n * f (n-1) in fac 5
06:46:58 <lambdabot>  Parse error
06:47:01 <desp> I just have to remember not to commit at 4 AM
06:47:02 <desp> :)
06:47:05 <SamB_XP_> or that
06:47:11 <Saizan> > let fac = fix (\f n -> if n == 0 then 1 else n * f (n-1)) in fac 5
06:47:13 <lambdabot>  120
06:47:32 <SamB_XP_> and keep your nose out of _darcs when you aren't fully awake and haven't backed up your repository immediately before
06:48:19 <dmwit> Saizan: thanks
06:48:27 <dmwit> Something to do on the subway to work. =)
06:48:50 <dmwit> :t fix
06:48:52 <lambdabot> forall a. (a -> a) -> a
06:49:23 <Saizan> fix f = f (fix f) -- my preferred definition
06:49:25 <dmwit> Oh, wow.  That is diabolical!
06:49:27 <SamB_XP_> desp: a good way to remember not to commit is to be asleep
06:49:46 <desp> :)
06:51:03 <SamB_XP_> just wait until you start using --partial, then your repos will probably become corrupt *without* it being your fault
06:55:38 <hpaste>  EvilTerran annotated "(no title)" with "vininim, or to change things completely..." at http://hpaste.org/1596#a5
07:05:47 <Saul_> stripThe ('T':'h':'e':' ':xs) = xs
07:05:54 <Saul_> Is there a prettier way to do this?
07:08:13 <quicksilver> funnily enough, that was discussed just recently
07:08:41 <quicksilver> not really, not
07:08:44 <Saul_> And how do you return the empty char (I mean '', but then compilable)
07:08:47 <jethr0> stripThe xs = if isPrefixOf "The" xs then drop 3 xs else xs
07:08:52 <jethr0> but it's not prettier at all
07:09:02 <quicksilver> Saul_: tehre is no empty char
07:09:03 <jethr0> ups, missed the space
07:09:06 <quicksilver> Saul_: what do you mean?
07:09:12 <vininim> mmm how do I get out of a monad?
07:09:19 <quicksilver> vininim: depends on the monad
07:09:20 <jethr0> nooooooo
07:09:21 <SamB_XP_> Saul_: what is this "empty char" thing?
07:09:33 <vininim> anonymous monad
07:09:33 <Saul_> jethr0: That isn't prettier indeed
07:09:48 <quicksilver> strip s xs | s `isPrefixOf` xs = drop (length s) xs
07:09:51 <fasta> vininim: cool, you found a new concept.
07:10:01 <quicksilver> vininim: you can't
07:10:09 <Saul_> I have a function that converts a Char into another Char, but possibly returns no Char
07:10:10 <quicksilver> vininim: there is no generic way to get out of a monad
07:10:17 <fasta> vininim: or more concrete: what are you talking about?
07:10:19 <quicksilver> Saul_: then it probably wants to return Maybe Char
07:10:52 <vininim> I though only IO monad did that
07:10:55 <jethr0> Saul_: not even C is evil enough to have an empty char!
07:11:03 <Saul_> quicksilver: If I cons a Maybe Char to a String, does that work?
07:11:10 <quicksilver> Saul_: no
07:11:17 <quicksilver> Saul_: but it's not hard to do it right :)
07:11:36 <jethr0> Saul_: use maybe
07:11:39 <jethr0> :t maybe
07:11:40 <ndm> grr, read :: Int -> String _should not_ have the libraries running a Haskell lexer!
07:11:40 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
07:11:42 <mrd> actually a Maybe Char and a [Char] are pretty closely related
07:11:54 <quicksilver> case c of Just x -> x : l | Nothing -> l
07:12:09 <quicksilver> 'maybe' is just the generic case expression
07:12:21 <quicksilver> use it if you think it's more convenient but it's often less clear
07:12:27 <jethr0> true
07:12:34 <EvilTerran> > (\x | True -> x)
07:12:34 <lambdabot>  Parse error
07:12:42 <Saul_> I don't think it's better with maybe
07:12:43 <vininim> fasta: not anonymous, generic infered/base Monad m
07:12:48 <EvilTerran>  /\ I thought you could have a guard on a lambda?
07:12:52 <quicksilver> vininim: there is no way out
07:13:07 <fasta> vininim: right, I knew you meant that, but it's better to use good terminology.
07:13:27 <quicksilver> vininim: that is (somehwat) the point
07:13:29 <EvilTerran> vininim, because not all monads can be gotten out of (see IO), there can be no standardised way of doing it
07:13:31 <jethr0> EvilTerran: *yuch*, guards on lambdas...
07:13:35 <fasta> vininim: as quicksilver says, there is no way out.
07:13:35 <Saul_> I basically had this filter on strings, but I figure it would be prettier to instead use a Char version and then use foldr for the string version
07:13:40 <EvilTerran> jethr0, it has its uses...
07:13:47 <EvilTerran> anyway. is it not allowed?
07:13:51 <quicksilver> vininim: a monad might contain no values, or multiple values, or various side effects before the value is calculated
07:14:05 <quicksilver> EvilTerran: you need to shove a 'case' in there
07:14:21 <EvilTerran> I'm sure i've done it before... oh well. fnord.
07:14:22 <Saul_> It would've worked pretty well if I didn't sometimes not return a Char
07:14:29 <ndm> read s          =  case [x | (x,t) <- reads s, ("","") <- lex t] of
07:14:41 <quicksilver> Saul_: Maybe Char is a good solution to that
07:14:48 <scook0> Saul_: you can use listToMaybe to turn a Maybe Char to a string
07:14:52 <ndm> is ("","") <- lex t just a really bad way of saying all isSpace t ?
07:14:57 <scook0> uh, sorry, maybeToList
07:15:01 <quicksilver> or you can use catMaybes
07:15:05 <quicksilver> to turn you list of 'maybes' into a string
07:15:12 <quicksilver> depending which way around you want to write it
07:15:23 <Nucleo> is there a better idiom than length $ takewhile <predicate> <list> for finding the position of the first 'matching' element in a list?
07:15:33 <quicksilver> Nucleo: findIndex
07:15:36 <Saul_> Ok I'll try that, thanks
07:16:54 <quicksilver> Nucleo: I assume you mean length $ takeWhile <opposite predicate>
07:16:55 <quicksilver> Nucleo: :)
07:17:14 <Nucleo> quicksilver: thanks much
07:17:26 <Saul_> :t foldr
07:17:28 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
07:18:10 <EvilTerran> incidentally, i'd be inclined to just generalise that prefix problem to something like
07:18:11 <EvilTerran> stripPrefix ps xs = foldl' (\(x:xs) p -> if p == x then xs else undefined) xs ps
07:18:36 <EvilTerran> (that lambda would've been (\(x:xs) p | x == p -> xs) if lambdas could have a guard)
07:20:30 <wli> Okay, I put some thought into what a shootout should look like.
07:22:33 <vincenz> hmm
07:23:23 <hpaste>  Saul_ pasted "Slugify function" at http://hpaste.org/1600
07:24:05 <vininim> if I derive a instance of a monad, I can do pattern matching like you can with Just,Nothing constructors?
07:24:08 <Saul_> quicksilver and scook0: Thanks for your help, the paste contains the final result
07:24:17 <quicksilver> Saul_: foldr ((:). ..) [] is a common pattern
07:24:20 <quicksilver> Saul_: it has a name :)
07:24:28 <quicksilver> Saul_: it's called 'map'
07:24:42 <Saul_> Uh, of course it is :P
07:24:50 <sioraiocht> LOL
07:24:52 <quicksilver> Saul_: slugify = catMaybes . map slugifyChar
07:25:03 <quicksilver> nice, though :)
07:25:16 <quicksilver> I'm impressed by anyone who can think in terms of (:).
07:25:22 <oerjan> vininim: if it is a data type you have access to the constructors of
07:25:47 <Saul_> quicksilver: Thank you
07:25:53 <quicksilver> vininim: specific monads contain various tools to 'unwrap' them
07:25:59 <quicksilver> vininim: in general you don't need to, though
07:26:05 <quicksilver> vininim: you just return results 'in the monad'
07:26:13 <quicksilver> (and leave the "unwrapping" to the caller)
07:26:30 <SamB> quicksilver: well, for everything except IO eventually you *do* need to unwrap it...
07:26:38 <hpaste>  Saul_ annotated "Slugify function" with "Small revision, using map" at http://hpaste.org/1600#a1
07:26:57 <Saul_> quicksilver: Here's the new function
07:26:57 <quicksilver> SamB: not necessarily. A list may be exactly what you want, say. So you may never unwrap the list monad as such.
07:27:14 <SamB> hmm.
07:27:25 <quicksilver> Saul_: looks good
07:27:35 <sproingie> pattern matching unwraps a list monad, no?
07:27:38 <SamB> I suppose it depends what you mean by "unwrap"
07:27:43 <vininim> in my case I just don't want to ptrStr =p
07:27:44 <oerjan> vininim: or do you mean like do "test" <- Just x; return x, which returns Nothing or Just "test" ?
07:27:58 <sardello> i need help with the Win-Program of haskell. Why cant i use "="
07:28:05 <Saul_> quicksilver: thanks (both for the compliment and your help)
07:28:15 <vininim> I mean f (Just x) = x; f Nothing = 0;
07:28:15 <sardello> must i load something?
07:28:20 <sioraiocht> @src sequence
07:28:20 <lambdabot> sequence ms = foldr k (return []) ms
07:28:20 <lambdabot>     where
07:28:20 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
07:28:22 <EvilTerran> umm
07:28:22 <SamB> sardello: you mean you have an interpreter running in windows?
07:28:25 <vininim> unwrapping
07:28:33 <sproingie> sardello: if it's ghci, use 'let'
07:28:37 <SamB> you could actually use "let x = 1" or something
07:28:40 <sioraiocht> > sequence [Just False, Just True]
07:28:41 <lambdabot>  Just [False,True]
07:28:49 <sproingie> i dunno if hugs does top-level lets
07:28:50 <sioraiocht> > sequence [Just False, Just True,Nothing]
07:28:51 <lambdabot>  Nothing
07:28:53 <sioraiocht> ???
07:28:58 <sioraiocht> how's that work?
07:29:01 <EvilTerran> sproingie, it doesn't
07:29:02 <SamB> sproingie: oh, true
07:29:06 <vininim> i'm just trying to be clever in ghci for visualizing the behaviour of my functions =P
07:29:25 <sardello> i use ghci, in example i write x = 2... "parse error on input "=""
07:29:30 <SamB> vininim: do you have a run function?
07:29:49 <EvilTerran> sardello, try "let x = 2"
07:29:51 <sardello> thanks
07:30:00 <hpaste>  dolio annotated "Slugify function" with "alternately, eliminate the middleman" at http://hpaste.org/1600#a2
07:30:31 <sardello> and where can i store files and load this?
07:31:31 <vininim> mmm not really
07:32:08 <oerjan> sioraiocht: it's equivalent to do x <- Just False; y <- Just True; z <- Nothing; return [x,y,z]
07:32:27 <oerjan> since there is a Nothing there, the whole becomes Nothing
07:32:41 <sioraiocht> erm
07:32:51 <sproingie> sequence is like folding >>
07:32:53 <sioraiocht> I understand conceptually, but how does sequence express that/
07:33:16 <sioraiocht> @src sequence
07:33:17 <lambdabot> sequence ms = foldr k (return []) ms
07:33:17 <lambdabot>     where
07:33:17 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
07:33:32 <sioraiocht> > return [True, Nothing]
07:33:33 <lambdabot>  Couldn't match expected type `Bool' against inferred type `Maybe a'
07:33:39 <quicksilver> it's like folding >> and collecting all the results into a list
07:33:42 <sioraiocht> kk
07:33:54 <quicksilver> note that ';' is really >>
07:33:57 <quicksilver> (or >>=)
07:33:57 <vininim> i'm just digging around in ghci with "return test >>= \ x -> return (move x move1) >>= \ x -> return (move x move1)"
07:34:06 <sioraiocht> oh yeah
07:34:07 <sioraiocht> !
07:34:09 <sioraiocht> lol
07:34:22 <EvilTerran> (\m m' -> do x <- m; xs <- m'; return (x:xs)) (Just True) [Just False, Just True]
07:34:27 <EvilTerran> > (\m m' -> do x <- m; xs <- m'; return (x:xs)) (Just True) [Just False, Just True]
07:34:28 <lambdabot>  Couldn't match expected type `Maybe [Bool]'
07:34:43 <EvilTerran> > (\m m' -> do x <- m; xs <- m'; return (x:xs)) (Just True) (Just [True, False])
07:34:44 <lambdabot>  Just [True,True,False]
07:35:02 <EvilTerran> > (\m m' -> do x <- m; xs <- m'; return (x:xs)) Nothing (Just [True, False])
07:35:03 <lambdabot>  Nothing
07:35:50 <sioraiocht> > sequence [[1,2,3],[4,5,6]]
07:35:51 <lambdabot>  [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
07:35:53 <sioraiocht> tee hee, neat
07:36:28 <oerjan> vininim: that line doesn't tell which Monad it is, so it won't work alone
07:37:55 <sioraiocht> @src >>=
07:37:55 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
07:37:59 <sioraiocht> @src >>=)
07:37:59 <lambdabot> Source not found. I feel much better now.
07:38:01 <sioraiocht> @src (>>=)
07:38:02 <lambdabot> Source not found. Where did you learn to type?
07:38:06 <sioraiocht> @src [] (>>=)
07:38:06 <lambdabot> m >>= k     = foldr ((++) . k) [] m
07:38:53 <sek> @src Set (>>=)
07:38:53 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
07:39:04 <vininim> lol
07:39:28 <sek> @src fromList (>>=)
07:39:28 <lambdabot> Source not found. I feel much better now.
07:39:31 <Nopik> hi there
07:39:39 <Saul_> Nopik: Hello
07:39:56 <malcolmw> hmm, writing recursive shell functions in bash seems to give me "fork: Resource temporarily unavailable" quite a bit :-)
07:40:24 <oerjan> sek: the extra first argument to @src should be a type constructor
07:42:19 <oerjan> also, @src has large holes in its sources :)
07:43:17 <sek> i was playing around trying to do something like
07:43:20 <Nopik> i have function returning IO [Integer].. i want to do something on integers e.g. map (2+)... how to do that?
07:43:22 <sek> > (singleton 1) >>= ((++) [2])
07:43:29 <lambdabot>   Not in scope: `singleton'
07:43:33 <sek> but obviously i'm using the wrong function
07:43:48 <sek> (++) isnt for the Set monad is it
07:43:57 <Nopik> i tried to apply >>= somehow, but failed ;p
07:43:58 <oerjan> Nopik: liftM (map (2+))
07:44:02 <vincenz> there is no set monad
07:44:06 <oerjan> (needs Control.Monad)
07:44:10 <Nopik> thanks
07:44:35 <sek> ah ok, it's just a data constructor
07:44:57 <sek> i thought it may have been some sort of generalisation of []
07:45:24 <mauke> Nopik: do { ints <- someFunction; return (map (2+) ints) }
07:45:31 <sek> > [[1]] >>= ((++) [2])
07:45:33 <lambdabot>  [2,1]
07:45:44 <oerjan> > Data.Set.union
07:45:46 <lambdabot>  <Set Integer -> Set Integer -> Set Integer>
07:46:00 <oerjan> sek: try that
07:46:10 <sek> thanks that works
07:46:25 <SamB> wow, that's strong defaulting
07:46:27 <EvilTerran> > [[1]] >>= (2:) -- sek
07:46:28 <lambdabot>  [2,1]
07:46:45 <oerjan> :t Data.Set.union
07:46:47 <lambdabot> forall a. (Ord a) => Data.Set.Set a -> Data.Set.Set a -> Data.Set.Set a
07:48:29 <vininim> :t f fn = \ x -> return (fn x)
07:48:31 <lambdabot> parse error on input `='
07:48:47 <sek> so is Set meant to be a non-monadic implementation of sets?
07:48:52 <vininim> uhh.. nevermind
07:49:22 <oerjan> sek: it cannot be monadic because the elements have an Ord context
07:49:32 <vininim> :t let f fn = \ x -> return (fn x) in f
07:49:33 <sek> ahh
07:49:34 <lambdabot> forall t a (m :: * -> *). (Monad m) => (t -> a) -> t -> m a
07:49:54 <sek> oerjan, i should have resorted to the definition of the word set before asking :)
07:49:58 <sek> thanks
07:49:58 <oerjan> apparenly there is no decent Haskell set monad
07:50:01 <EvilTerran> :t \fn x -> return (fn x) -- vininim
07:50:02 <lambdabot> forall t a (m :: * -> *). (Monad m) => (t -> a) -> t -> m a
07:50:11 <Nopik> ok, now, how to putStrLn a type IO [Integer] ?
07:50:31 <EvilTerran> vininim, "f = \x -> EXP" is the same as "f x = EXP", in general
07:50:44 <mauke> Nopik: do { ints <- whatever; putStrLn (show ints); }
07:50:57 <ski> whatever >>= print
07:51:05 <ski> @src print
07:51:05 <lambdabot> print x = putStrLn (show x)
07:51:10 <sek> > (IO [1,2,3]) >>= putStrLn
07:51:11 <lambdabot>   Not in scope: data constructor `IO'
07:51:18 <jethr0> can't do IO
07:51:23 <EvilTerran> > (return [1,2,3]) >>= putStrLn
07:51:24 <lambdabot>   add an instance declaration for (Num Char)
07:51:24 <lambdabot>     In the expression: 3
07:51:27 <ski> @help run
07:51:27 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
07:51:31 <sek> ok return will work:)
07:51:34 <EvilTerran> > (return [1,2,3]) >>= putStrLn . show
07:51:36 <lambdabot>  <IO ()>
07:52:15 <vininim> mmm there ought to be something already defined like that
07:52:40 <Saul_> :t filter
07:52:40 <sek> could you force return [1,2,3] to be of type IO [Int} someway simple?
07:52:41 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
07:52:50 <EvilTerran> sorry, yes, s/putStrLn . show/print/
07:53:00 <jethr0> do {xs <- (IO [1,2,3]); print xs}
07:53:05 <EvilTerran> > return [1,2,3] :: IO [Int]
07:53:07 <lambdabot>  <IO [Int]>
07:53:22 <oerjan> vininim: (return .)
07:53:32 <EvilTerran> vininim, defined like what?
07:53:33 <sek> > (return [1,2,3])::(IO [Int]) >>= putStrLn
07:53:33 <lambdabot>  Parse error
07:54:00 <mauke> sek: no need for explicit type annotations there
07:54:05 <mauke> putStrLn forces it into IO
07:54:05 <EvilTerran> > (return [1,2,3] :: IO [Int]) >>= print -- sek
07:54:07 <lambdabot>  <IO ()>
07:54:26 <Saul_> :t Map.filter
07:54:28 <lambdabot> Couldn't find qualified module.
07:54:29 <sek> i see
07:54:35 <Saul_> :t Data.Map.filter
07:54:37 <lambdabot> forall a k. (Ord k) => (a -> Bool) -> Data.Map.Map k a -> Data.Map.Map k a
07:54:52 <EvilTerran> but, as mauke says, you don't need to explicitly type it IO.
07:54:53 <vininim> > liftM (+1) (Just 0)
07:54:55 <lambdabot>  Just 1
07:54:57 <vininim> bleh
07:55:05 * vininim hides in shame
07:55:10 <Saul_> Ok small question, why is the Map filter requiring that k derives Ord?
07:55:23 <mauke> s/derives/implements/
07:55:41 <Saul_> Ok small question, why is the Map filter requiring that k implements Ord?
07:55:58 <EvilTerran> @docs Data.Map
07:55:58 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
07:56:11 <EvilTerran> everything Map requires ordered keys
07:56:12 <mauke> because Set needs Ord to balance the tree
07:56:25 <ski> @type Data.Map.empty
07:56:27 <lambdabot> forall k a. Data.Map.Map k a
07:56:32 <pyCube_> hey.. new to haskell.. playing with xmlrpc stuff.. one of the methods should return a list of strings, but i dunno to to define that in haskell
07:57:10 <jethr0> ["hello", "world"]
07:57:26 <vincenz> @localtime jethr0
07:57:27 <lambdabot> Local time for jethr0 is Tuesday, July 10, 2007 4:56:53 PM
07:57:28 <oerjan> actually Map.filter probably _doesn't_ need Ord
07:57:35 <oerjan> in principle
07:57:47 <vininim> method :: ArgumentType -> [String]
07:57:50 <hpaste>  dolio pasted "A set monad." at http://hpaste.org/1603
07:57:55 <Saul_> EvilTerran: Well it makes sense in most cases, since it's stored as a binary tree, but in the case of filter, you need to traverse the entire tree anyway
07:57:59 <EvilTerran> pyCube_, reading up on some Haskell fundamentals is strongly advised before trying anything funny like xmlrpc
07:58:26 <pyCube_> EvilTerran: i am..
07:58:33 <EvilTerran> oh, okay. ignore me then.
07:59:04 <quicksilver> Saul_: I imagine it uses Map.insert to build the 'new' map
07:59:07 <quicksilver> Saul_: and that needs Ord
07:59:36 <EvilTerran> or it needs to delete elements, in which case Ord may be needed to maintain balance
07:59:49 <Saul_> quicksilver: ah that makes sense, thanks
08:00:19 <quicksilver> actually it uses merge
08:00:24 <quicksilver> but that's effectively teh same
08:00:33 <quicksilver> (merge needs Ord to rebalance)
08:00:47 <Saul_> Yeah insert would probably make it O(n log n)
08:01:21 <oerjan> why should rebalancing require Ord?  Makes no sense?
08:01:57 <quicksilver> oerjan: oh. actually merge doesn't need Ord.
08:02:14 <Saul_> oerjan: Because the tree is a binary tree, which means that eveything smaller than the root is on the left branch and everything bigger is on the right
08:02:32 <quicksilver> join does
08:02:40 <quicksilver> but even that type sig may be in error
08:02:57 <oerjan> Saul_: but it already knows the order from the order in the original unbalanced tree
08:03:13 <quicksilver> yes, it is
08:03:16 <norgul> how can i check if an element in a list is itself a list?
08:03:29 <quicksilver> join uses balance, bin, insertMin and insterMax
08:03:30 <mauke> norgul: you look at its type
08:03:35 <quicksilver> none of those have Ord constraints
08:03:45 <norgul> but how
08:03:47 <quicksilver> so actually join doesn't need an Ord constraint (although it has one)
08:03:53 <quicksilver> norgul: you always know
08:04:00 <quicksilver> norgul: because you're in a strong typed language :)
08:04:01 <mauke> with eyes
08:04:11 <quicksilver> norgul: and so you know what type you're working over
08:04:12 <Saul_> oerjan: I don't think the type system is that smart
08:04:20 <norgul> huh
08:04:22 <quicksilver> Saul_: it is, actually
08:04:30 <quicksilver> norgul: unless your function is polymorphic
08:04:37 <quicksilver> in which case you're not "allowed" to know if it's a list or not
08:04:46 <Saul_> quicksilver: I'm probably misunderstanding something then
08:04:49 <quicksilver> since your function is supposed to work 'uniformly' over all types
08:04:57 <quicksilver> http://darcs.haskell.org/ghc-6.6/packages/base/Data/Map.hs
08:04:59 <oerjan> Saul_: but the algorithm can be
08:05:01 <quicksilver> Saul_: look in the source
08:05:10 <quicksilver> Saul_: some of those functions don't have Ord constraints
08:05:20 <quicksilver> some of them have ord constraints but don't actually *need* them
08:05:36 <quicksilver> in particular, I claim that 'join' has an Ord constraint but never uses it, so it could be removed
08:05:48 <quicksilver> and then you could remove the Ord constraint from filter,  as you suggested
08:06:00 <Saul_> Ok, but if they use compare (or another Ord function) they will need it, and I imagine that rebalancing takes a couple of those
08:06:07 <quicksilver> however, there isn't any particular point in doing this :)
08:06:19 <quicksilver> Saul_: nope, 'balance' doesn't use Ord
08:06:28 <quicksilver> balance :: k -> a -> Map k a -> Map k a -> Map k a
08:06:30 <Saul_> How do I view the source?
08:06:32 <quicksilver> ^^ no constraint
08:06:37 <quicksilver> Saul_: I just pasted the URL
08:06:45 <quicksilver> or you just click 'source' in the docs page :)
08:06:46 <dolio> You can certainly do without it, as the ordering of the elements is already encoded in the structure of the set.
08:06:50 <Saul_> Oh sorry, didn't see it
08:06:52 <Saul_> thanks
08:06:56 <norgul> ok
08:07:18 <quicksilver> dolio: omitting the constraint doesn't actually save anything, though, does it?
08:07:41 <quicksilver> dolio: since it's a very easy optimisation to remove unused (dictionary) parameters...
08:07:45 <EvilTerran> given that you can't put anything into this set you're mucking about with without the Ord constraint...
08:07:46 <dolio> quicksilver: Other than finger milage? :)
08:08:06 <quicksilver> I suppose it's a slightly stronger invariant on the function, too
08:08:11 <Saul_> quicksilver: Ah I see, it uses some internally kept data for balance
08:08:11 <quicksilver> which might be interesting academically
08:08:27 <quicksilver> Saul_: well the bins know how big they are
08:08:33 <quicksilver> Saul_: and of course they're stored in order anywhere
08:08:43 <quicksilver> Saul_: so you can just 'rotate' elements between tree branches
08:08:49 <quicksilver> without disturbing order
08:08:50 <dolio> quicksilver: I wouldn't be sad if Set turned into a GADT, so that Ord constraints were only needed for insert and fromList.
08:09:01 <dolio> Although, that'd make it pretty unportable.
08:09:10 <quicksilver> dolio: I wouldn't be sad, because it would be pretty.
08:09:18 <quicksilver> dolio: but woudl it actually have any real benefit?
08:09:21 <quicksilver> other than prettiness?
08:09:28 <pjd> where are range literals documented?
08:09:36 <pjd> can you get descending ranges?
08:09:37 <dolio> quicksilver: It'd be one step towards making it monadable.
08:09:47 <quicksilver> > [3,2,...]
08:09:47 <lambdabot>  Parse error
08:09:51 <quicksilver> > [3,2,..]
08:09:52 <lambdabot>  Parse error
08:09:54 <quicksilver> > [3,2..]
08:09:59 <lambdabot>  [3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,...
08:10:07 <quicksilver> pjd: yes, but you need to get the syntax right :)
08:10:08 <oerjan> @where report
08:10:09 <lambdabot> http://www.haskell.org/onlinereport/
08:10:15 <quicksilver> which apparently takes me three tries
08:10:26 <pjd> what if you want to start from a variable? :)
08:10:31 <quicksilver> that works fine
08:10:32 <pjd> [n..0]
08:10:44 <mauke> [n, n-1 .. 0]
08:10:47 <quicksilver> let n = 4 in [n,(n-1)..]
08:10:48 <EvilTerran> > let (x,y,z) = (10,8,1) in [x,y..z]
08:10:49 <lambdabot>  [10,8,6,4,2]
08:11:08 <quicksilver> @info Enum
08:11:08 <lambdabot> Enum
08:11:12 <quicksilver> @src Enum
08:11:13 <lambdabot> class  Enum a   where
08:11:13 <lambdabot>     succ                     :: a -> a
08:11:13 <lambdabot>     pred                     :: a -> a
08:11:13 <lambdabot>     toEnum                   :: Int -> a
08:11:13 <lambdabot>     fromEnum                 :: a -> Int
08:11:15 <lambdabot> [3 @more lines]
08:11:17 <quicksilver> @more
08:11:17 <lambdabot>     enumFrom                 :: a -> [a]
08:11:19 <lambdabot>     enumFromThen, enumFromTo :: a -> a -> [a]
08:11:20 <pjd> hmm, ok, i actually have an expression
08:11:21 <lambdabot>     enumFromThenTo           :: a -> a -> a -> [a]
08:11:32 <quicksilver> pjd: it desugars to those last few, if you're interested
08:11:33 <pjd> so a let?
08:11:55 <pjd> quicksilver: oh, ok, that's useful to know
08:11:58 <oerjan> pjd: you don't need a let that was just to get the example working
08:12:13 <pjd> oerjan: for sanity, i mean :)
08:12:46 <EvilTerran> > [ 1+2+3, 2*2 .. (-3)^3 ]
08:12:48 <lambdabot>  [6,4,2,0,-2,-4,-6,-8,-10,-12,-14,-16,-18,-20,-22,-24,-26]
08:13:14 <mauke> > takeWhile (>= 0) . iterate pred $ 2^5 - 3*4
08:13:16 <lambdabot>  [20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0]
08:13:25 <EvilTerran> you can use arbitrary expressions in those things
08:13:28 <shapr> Has anyone used cron to darcs pull their repos?
08:13:36 <mauke> you don't even need [..] :-)
08:13:38 <oerjan> > ['a'..'z']
08:13:40 <lambdabot>  "abcdefghijklmnopqrstuvwxyz"
08:13:46 <pjd> EvilTerran: yeah, but i don't want to repeat the whole expression
08:13:46 <quicksilver> pjd: this is why haskell reocks more than more things
08:13:53 <quicksilver> pjd: it's almost fully 'compositional'
08:13:58 <Saul_> quicksilver: Apparently (catMaybes.map slugifyChar) can be rewritten to (mapMaybe slugifyChar)
08:14:03 <quicksilver> pjd: you can put expressions anywhere
08:14:11 <pjd> yep
08:14:21 <Igloo> shapr: I have
08:14:34 <shapr> Igloo: Do you have a working crontab entry I could use?
08:14:47 <quicksilver> Saul_: interesting, I've not used that one
08:14:53 <oerjan> shapr: you're op'ed
08:15:10 <shapr> oh yeah, spammer..
08:15:11 --- mode: shapr set -o shapr
08:15:41 <Igloo> shapr: I used    24 5 * * * ~/private/darcs/update.sh
08:15:56 <Igloo> shapr: The latter being a script that updates every darcs repo in a certain directory
08:19:31 <Saul_> Is there any way to make a type class derivable for any datastructure?
08:19:37 <mauke> no
08:19:41 <shapr> Igloo: Is your shell script smart enough to send an email with lines like "Repo foo had 9 new patches" ?
08:19:48 <Saul_> :(
08:20:29 <Igloo> shapr: No, I use it for backups, so didn't want mails all the time. Only when something went wrong.
08:20:49 <Saul_> mauke: So deriving class types is only possible for the prelude class types?
08:21:10 <mauke> Saul_: only for some of them
08:21:20 <mauke> ghc can also derive Typeable
08:21:30 <EvilTerran> you could write some templatehaskell to do a similar job
08:21:44 <Saul_> mauke: that's not very haskell-like
08:21:50 <EvilTerran> data Foo = Foo ...; $(deriveMyClassFor Foo)
08:22:43 <Saul_> EvilTerran: That looks a little too scary for me at the moment
08:22:46 <EvilTerran> i think that should be possible. it might have to be $(derivingMyClass [d| data Foo = ... |])
08:23:19 <mauke> it is scary
08:23:27 <oerjan> isn't there a Data.Derive module?
08:23:32 <Igloo> $(deriveMyClassFor ''Foo) is possible
08:23:52 <quicksilver> Saul_: there are all kinds of automatic derivers
08:23:58 <quicksilver> Saul_: at least three I'm aware of
08:24:07 <quicksilver> @where derive
08:24:07 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/derive
08:24:14 <quicksilver> ^^ that's one of them
08:24:44 <quicksilver> I really should write a blog article on the dangers of metaprogramming
08:24:49 <EvilTerran> Igloo, ah, yes, that'd what i meant initially. i wasn't sure if you could get enough info about the datatype from its symbol to be able to derive appropriately
08:24:50 <quicksilver> unfortunately I don't have a blog :(
08:24:55 <mauke> :t Map.lookup
08:25:04 <lambdabot> Couldn't find qualified module.
08:25:18 <oerjan> :t Data.Map.lookup
08:25:22 <lambdabot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> Data.Map.Map k a -> m a
08:26:01 <quicksilver> Using Monad m => for 'operation which can fail' will damage your crops and permanently impair your fertility.
08:26:27 <Rebooted> quicksilver: one of the things I want to try to do is port Principles of AI Programming to Haskell and see how much of the code truly requires macros
08:26:40 <quicksilver> Rebooted: that would be very interesting indeed
08:26:54 <Saul_> quicksilver: It would be nice if it was a standard feature
08:26:59 <quicksilver> Rebooted: and, for the parts that really do require macros, what type system extensions you'd need to do without :)
08:27:06 <quicksilver> Saul_: deriving?
08:27:31 <Saul_> yeah
08:27:44 <quicksilver> Saul_: well, it's not quite that straightforward
08:27:50 <quicksilver> you've just written a totally custom typeclass
08:27:56 <EvilTerran> the thing about writing your own derivations is that it requires examination of the "data ... = ..." line
08:27:57 <quicksilver> only you know what it means
08:28:06 <quicksilver> how should one derive new instances for it?
08:28:21 <EvilTerran> which puts it into the domain of metaprogramming, somewhat.
08:28:25 <quicksilver> this is, in anything but the most trivial case, an exercise in metaprogramming.
08:28:33 <quicksilver> haskell, per se, has no metaprogramming.
08:28:36 <quicksilver> There's template haskell.
08:28:41 <quicksilver> which will always be possible.
08:28:47 <EvilTerran> there's GHC's newtype deriving, which is also worth being aware of.
08:28:50 <quicksilver> Or there are various packages which hope to make it 'simpler' than TH.
08:29:38 <mauke> > (3 -) 1
08:29:40 <lambdabot>  2
08:30:30 <Saul_> Well thanks for the info, I'll just leave it for the moment (too much of a newbie to futz with it)
08:30:43 <quicksilver> :)
08:30:59 <Rebooted> Generic Haskell lets you write code dependent on the structure of datatypes, I guess subsuming deriving
08:31:07 <quicksilver> right
08:31:10 <quicksilver> and uniplate too
08:31:10 <Rebooted> so maybe SYBP would work
08:31:15 <Rebooted> ah
08:31:21 <quicksilver> these are other metaprogamming techniques
08:31:25 <quicksilver> (and very handy they are too)
08:31:39 <quicksilver> basically, they reduce the compiler support to 'deriving Data'
08:31:57 <quicksilver> and then you can (sometimes) write an instance for (Data a) => MyClass a
08:32:20 <quicksilver> so the compiler in some sense derives a 'complete metaprogramming typeclass'
08:32:32 <quicksilver> frmo which you can extract the little bits of metaprogramming you need in your case
08:32:43 <quicksilver> (it's not really complete, of course)
08:35:43 <mauke> > let padTo n = reverse . take n . (++ repeat ' ') . reverse in padTo 6 "3.14"
08:35:44 <lambdabot>  "  3.14"
08:36:56 <mauke> is there a better way to write that?
08:37:01 <smkl> how long does it take to build ghc (approximately)?
08:37:10 <sioraiocht> smkl: Eternity
08:37:12 <mauke> a few hours
08:37:23 <Igloo> On a fast machine doing a complete, standard build, about 2 hours
08:37:29 <vininim> fast enough for me to not realize
08:37:32 <JaffaCake> smkl: from a few minutes to a couple of hours, depending on build settings
08:37:39 <vininim> (while doing other stuff, off course)
08:37:58 <quicksilver> mauke: I've written that 100 times
08:38:12 <smkl> ok, i'm building it from darwinports
08:38:23 <mauke> > replicate (-4) 'Z'
08:38:25 <lambdabot>  ""
08:38:33 <quicksilver> mauke: although I normally just write padTo n s = (replicate (length s - n) ' ') ++ s
08:38:43 <mauke> exactly :-)
08:39:11 <quicksilver> JaffaCake: 8 hours on my 800 Mhz iBook :(
08:39:17 <JaffaCake> ouch
08:39:19 <mauke> wait, that looks wrong
08:39:41 <mauke> quicksilver: n - length s?
08:39:42 <Igloo> quicksilver: How much RAM?
08:41:03 <mauke> > Numeric.showFFloat (Just 2) 3
08:41:04 <lambdabot>  <[Char] -> [Char]>
08:41:51 <oerjan> > Numeric.showFFloat (Just 2) 3 ""
08:41:52 <lambdabot>  "3.00"
08:42:50 <wli> padTo n = head . dropWhile ((<n) . length) $ [Numeric.showFFloat (Just k) x "" | k <- [1..]]
08:43:16 <JaffaCake> wli: Text.Printf?
08:43:16 <EvilTerran> > printf "%6s" "3.14" :: String
08:43:17 <lambdabot>  "  3.14"
08:43:23 <JaffaCake> there you go
08:43:45 <wli> Jaffa: Maybe that would help except format string processing is nasty.
08:44:23 <mauke> Text.Printf is semibroken
08:44:29 <wli> Well, maybe it can be partially evaluated but anyway.
08:44:33 <wli> mauke: How so?
08:44:55 <mauke> > printf "%.*f" 2 3 :: String
08:44:56 <lambdabot>  Exception: Printf.printf: bad formatting char *
08:45:11 <mauke> > printf "%*.*f" 0 2 3 :: String
08:45:13 <lambdabot>  Exception: Printf.printf: bad argument
08:45:23 <mauke> wait, that was supposed to work
08:45:36 <mauke> > printf "%*.*f" 0 2 (3::Double) :: String
08:45:37 <lambdabot>  "3.00"
08:45:49 <wli> mauke: I don't remember what %*.*f does.
08:46:03 <quicksilver> Igloo: erm, it had 0.75 G IIRC. It's not the one I have now.
08:46:05 <mauke> * tells it to get a number from the argument list
08:46:12 <wli> mauke: ah, right
08:46:33 <mux> > printf "%.*s" 4 "haskell"
08:46:34 <lambdabot>  Add a type signature
08:46:35 <Igloo> hmm, OK
08:46:40 <mux> > printf "%.*s" 4 "haskell" :: String
08:46:41 <lambdabot>  Exception: Printf.printf: bad formatting char *
08:47:05 <quicksilver> I always saw Text.Printf as a cute hack
08:47:09 <mux> mm, this should work
08:47:10 <quicksilver> rather than a serious interface proposal
08:47:15 <quicksilver> maybe I was wrong :)
08:47:23 <mauke> mux: that case is simply not handled in the parser
08:47:28 <mux> ok
08:47:55 <quicksilver> the haskelly-way to do it would be formatting combinators not a nasty format string
08:48:07 <quicksilver> not sure if one of the prettyprint libraries has something
08:48:52 <wli> I seem to get away with using the ShowS bits in a pinch.
08:49:00 <mauke> if the haskell way turns out to be anything like C++'s iostreams, it is FAIL
08:49:45 <quicksilver> mauke: I'd hope we can learn from that mistake :)
08:50:02 <SamB> mauke: it's not *usually* imperative
08:50:04 <quicksilver> mauke: we have a considerably better type system (cheap anonymous tuples really help for this kind of stuff)
08:50:14 <Saul_> The Map datatype is pretty cool, every operation I make up for my Wiki system is just a one-to-one mapping so far
08:50:30 <SamB> though JHC has an imperative prettyprinter for it's C output
08:50:43 <SamB> but that has to do newsyms ;-)
08:50:47 <wli> quicksilver: Text.Show seems to be the Haskelly way.
08:51:27 <mauke> wli: how do you do printf "%5.2f" with Show?
08:51:28 <SamB> I thought the haskell way was rather more like HughesPj
08:51:33 <SamB> @hoogle HughesPj
08:51:34 <lambdabot> Text.PrettyPrint.HughesPJ :: module
08:51:54 <wli> mauke: showFFloat I think is missing some args there.
08:52:37 <mauke> ok, now printf "%5.2f(%5.2f) %5.2f" x y z
08:53:48 <SamB> actually, ShowS *is* DocLike...
08:53:58 <SamB> instance DocLike ShowS where
08:53:58 <SamB>     a <> b = a . b
08:54:22 <SamB> that's from John Meacham's Doc repository
08:54:44 <wli> mauke: Odds are one will have to cook up something in terms of floatToDigits
08:55:08 <mauke> eww
08:55:59 <quicksilver> Saul_: yes, Map is really handy in 'stateful' things like a wiki
08:56:09 <quicksilver> Saul_: everything ends up being a mapping of 'name' to 'content'
08:56:12 <quicksilver> FSOV content
08:56:21 <crazy_coder> hello everyone
08:56:36 <Saul_> quicksilver: Yeah pretty much
08:56:56 <quicksilver> wli: text.show doesn't do general padding + alignment
08:57:22 <crazy_coder> when ever we use the do statement, the return type of every command must be the same as the return type of the function in which do is used. Right ?
08:57:37 <mauke> crazy_coder: no
08:58:03 <dcoutts_> only the final statement (which might be a return)
08:58:11 <crazy_coder> If I have f :: String -> IO ()
08:58:30 <mauke> e.g. I'm writing a function whose type is IO String
08:58:34 <crazy_coder> then I can't define f s = putStrLn s
08:58:39 <mauke> but internally it uses a do statement whose type is Maybe [Double]
08:58:50 <mauke> crazy_coder: why not?
08:59:03 <dcoutts_> @type putStrLn
08:59:05 <lambdabot> String -> IO ()
08:59:14 <dcoutts_> crazy_coder: therefor yes, you can.
08:59:19 <crazy_coder> and then followed by it , call the function y :: Int->Int
08:59:53 <crazy_coder> Like after putStrLn s , in the next line of the do block, I call y
09:00:06 <crazy_coder> y number = number +1 eg
09:00:26 <mauke> not directly
09:00:26 <crazy_coder> The problem is that I want to do something like this
09:00:39 <wli> There should really be more state for tabular output so things are aware of column boundaries, radix point alignment, left/right justification within the column, etc.
09:00:57 <crazy_coder> The first command follows the type correctly, but the second one has return type something else
09:00:58 <wli> There's probably some kind of monad you can define for that.
09:01:22 <crazy_coder> And it is necessary for me to call this second function compulsorily.....
09:01:38 <oerjan> crazy_coder: if you want the whole to be IO (), just add a last line return ()
09:01:42 <crazy_coder> Can I use return somehow. to overcome this problem
09:01:44 <vininim> @src sequence
09:01:44 <lambdabot> sequence ms = foldr k (return []) ms
09:01:44 <lambdabot>     where
09:01:44 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
09:02:24 <crazy_coder> Ok, but if I have something like IO String, then  ?
09:02:39 <oerjan> then you must find some string to return
09:02:40 <crazy_coder> will return() work over there too ?
09:02:47 <crazy_coder> Oh Ok
09:02:49 <wli> wtf is ribbon length?
09:03:24 <ptolomy> I'm trying to make a monadic version of 'compose' (or better yet, the equivalent of "(iterate i f)!!i".. but I'm not having much luck. It seems likely that it is an already written and often used function, so I thought I'd see if anyone here knows where I could find it.
09:03:45 <crazy_coder> whats the use of $ ??
09:03:56 <quicksilver> crazy_coder: it's just function application
09:04:05 <quicksilver> crazy_coder: but the tricky part is, it has lower 'precedence'
09:04:13 <quicksilver> crazy_coder: so "f $ x" is just "f x"
09:04:18 <mauke> f $ g $ h $ x == f (g (h x))
09:04:26 <quicksilver> crazy_coder: but "f $ n+1" is "f (n+1)"
09:04:27 <hpaste>  Saul_ pasted "Which one is better?" at http://hpaste.org/1604
09:04:37 <quicksilver> crazy_coder: so it's used when you have a long line, to save on ()
09:04:43 <Saul_> So which one is better? :)
09:04:52 <Saul_> Or should I just provide both?
09:05:02 <quicksilver> Saul_: that depends what you want :)
09:05:23 <quicksilver> Saul_: I'd incline towards the Maybe version, personally
09:05:47 <crazy_coder> Ok.Thanks
09:05:53 <ptolomy> So really, I'm looking for a function for applying a monadic function to something N times, then getting the result.
09:06:04 <quicksilver> ptolomy: iterateM, iirc
09:06:07 <quicksilver> :t iterateM
09:06:13 <lambdabot> Not in scope: `iterateM'
09:06:17 <quicksilver> hmm or maybe not
09:06:23 <Saul_> Well the thing is I'm going to need to be able to delete pages as well (of course very wiki like, so it should still exist in the database, maybe even be resurrectable)
09:06:28 <ptolomy> Yeah, I expected that to exist too..
09:06:58 <oerjan> ptolomy: foldr (=<<) x (replicate n f)
09:07:33 <quicksilver> I'm surprised there isn't an easier way
09:07:35 <Saizan> ?type \f a n -> sequence . take n . iterate f $ a
09:07:37 <lambdabot> forall (m :: * -> *) a. (Monad m) => (m a -> m a) -> m a -> Int -> m [a]
09:07:42 <oerjan> er maybe foldl
09:07:45 <quicksilver> "easier" == without explicitly using fold
09:07:58 <Saul_> So I should return a blank page with the history of the deleted page if one of those is queried, so I might as well return a blank page if the page never existed
09:08:55 <wli> BTW is there a way to avoid implicitly exporting instances yet?
09:08:56 <Saizan> ?type \f a n -> liftM last . sequence . take n . iterate (f =<<) $ a
09:08:58 <lambdabot> forall (m :: * -> *) b. (Monad m) => (b -> m b) -> m b -> Int -> m b
09:09:16 <ToRA> @type replicateM_
09:09:17 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m ()
09:09:28 <quicksilver> ToRA: that doesn't "funnel the results"
09:09:31 <ToRA> does that help?
09:09:32 <quicksilver> ToRA: through to the next action
09:09:32 <ToRA> ok
09:09:43 <Saul_> quicksilver: There might be an alternative to that too though :|
09:09:50 <pjd> oerjan: that should be (>>=) too, right?
09:09:56 <quicksilver> Saul_: it depends if this API is high level or low level, I guess
09:10:09 <quicksilver> Saul_: if it's high level, then it might make sense to return the default page
09:10:11 <mauke> > splitAt (-1) "abc"
09:10:13 <lambdabot>  ("","abc")
09:10:13 <oerjan> pjd: with foldr, =<<
09:10:26 <quicksilver> Saul_: if it's low level its caller might want ot explicitly know it wasn't found
09:10:26 <Saul_> It's kind of low level
09:10:33 <quicksilver> Saul_: this is a classic API design :)
09:10:39 <oerjan> i think some care is needed if it is not to use much stack
09:10:39 <pjd> ah, right
09:11:13 <Saul_> quicksilver: But the empty page is also unique enough to show the page doesn't exist
09:11:34 <quicksilver> maybe
09:11:41 <quicksilver> but what if a page gets created and never edited
09:11:47 <quicksilver> doesn't it still look like the empty one then?
09:12:06 <Saul_> Well a page won't actually get stored if that is the case
09:12:34 <quicksilver> then that's probably OK :)
09:12:42 <quicksilver> I'm just saying, you have to ask yourself these questions.
09:12:48 <Saul_> If you add a page, a blank page with a first revision is added to the wiki
09:13:04 <Saul_> I know, but it helps to have a second opinion :)
09:14:52 <Saul_> I guess I'm not schizophrenic enough to hold that dialog with myself :P
09:14:52 <mauke> @pl \s -> (init s, last s)
09:14:52 <lambdabot> liftM2 (,) init last
09:15:09 <wli> I can't quite smoke out what Text.PrettyPrint is capable or incapable of.
09:15:17 <vininim> @src dfs
09:15:17 <lambdabot> Source not found. Wrong!  You cheating scum!
09:15:49 <ptolomy> oerjan: That was what I was looking for, thanks! (I changed 'x' to '(return x)', but that's just a result of how I'm using it). Seems like it should be standard somewhere.
09:15:52 <ptolomy> eep. boss.
09:16:20 <oerjan> @pl \f g x -> f x >>= g
09:16:20 <lambdabot> flip . ((>>=) .)
09:16:33 <oerjan> darn, he left
09:17:13 <sorear> @users
09:17:13 <lambdabot> Maximum users seen in #haskell: 354, currently: 335 (94.6%), active: 27 (8.1%)
09:17:46 <oerjan> x >>= foldr (flip . ((>>=) .)) return (replicate n f) should be better
09:18:18 <oerjan> :t \f x -> x >>= foldr (flip . ((>>=) .)) return (replicate n f)
09:18:24 <lambdabot> Not in scope: `n'
09:18:34 <oerjan> :t \n f x -> x >>= foldr (flip . ((>>=) .)) return (replicate n f)
09:18:36 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> (a -> m a) -> m a -> m a
09:21:14 <mauke> @src State
09:21:14 <lambdabot> Source not found. It can only be attributed to human error.
09:21:58 <oerjan> @source Control.Monad.State
09:21:59 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/State.hs
09:28:59 * desp pokes sjanssen, oerjan
09:29:00 <edwardk> back
09:29:12 <sjanssen> desp: hmm?
09:29:16 <desp> I need to write a simple test case for this, but so far it appears that a <<loop>> was caused by 1. calling a C function inside a withMVar; 2. calling a Haskell callback from inside the C function; 3. attempting to access the MVar from inside the callback
09:29:38 <desp> Cale++ has been so kind to unravel the bug with me for the past several hours
09:30:49 <edwardk> so, hrmm, what other generalizations of prelude functions can people think of? going back and wrapping up the generic list functionality into a library is next on my agenda
09:31:48 <sorear> yay!
09:31:51 <quicksilver> desp: that's an interesting one
09:31:58 <quicksilver> desp: I'd not have managed to guess that one ;)
09:31:58 <edwardk> sorear: ?
09:32:06 <mauke> (.) = map = fmap
09:32:13 <sjanssen> desp: oh, <<loop>> is a bit of a surprising result
09:32:14 <edwardk> mauke: already in
09:32:22 <mauke> :)
09:32:32 <sorear> edwardk: Spam filter tweak successful.
09:32:32 <sjanssen> desp: but it certainly makes sense that will break somehow
09:32:44 <pjd> oerjan: iterateM f x = scanl (>>=) x (repeat f)
09:32:59 <edwardk> its currently one step better than that even, given a class Map f a b where map :: (a -> b) -> f a -> f b, so it can be used over restricted monads
09:33:05 <edwardk> er s/map/(.)
09:33:28 <sorear> also, I can upgrade a running hpaste with ./publish in my hpaste source dir :)
09:33:31 <sjanssen> sorear: the spammer's intelligence improved?
09:33:37 <edwardk> right now it all compiles, it'll probably break when i add more restricted monads though
09:33:40 <desp> sjanssen: yes, it threw me off so much I didn't notice that the code should deadlock
09:33:42 <pjd> > let iterateM f x = scanl (>>=) x (repeat f) in iterateM (\x -> [x,x]) [5]
09:33:43 <lambdabot>  [[5],[5,5],[5,5,5,5],[5,5,5,5,5,5,5,5],[5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5],[5,...
09:33:55 <wli> edwardk: Lattices/Posets/Preorders for the comparator operations, a float-showing operation with an additional argument for maximum number of significant digits besides just the one for the number of digits past the decimal point.
09:34:06 <sorear> sjanssen: No, just dumb luck; "Nestor_the_inv" /= "Nestor_the_investor" due to early truncation
09:34:23 <sjanssen> ah, tricksy
09:34:33 <pjd> edwardk: you have filter, right? :)
09:35:23 <edwardk> pjd: i have the filter from the other day, partially generalized
09:36:06 <edwardk> wli: still working on what damage i can do the Ord class. ideally you'd start with preorder, then partial, then total.
09:37:09 <edwardk> wli: the show extensions for float i'll pass on unless you can provide me code i can just plug in. ;)
09:38:53 <edwardk> i broke (+) out into AddMagma, zero into AddMonoid and (-) and negate into AddGroup, though I may split (-) from that so you can have a (-) quasiloop without negation for things like Set, which lack an inverse but have a reasonable notion of -.
09:39:05 <pjd> edwardk: have you looked at related list functions?
09:39:23 <edwardk> pjd: yeah. cons = mplus . return. nil = mzero, etc =)
09:39:27 <quicksilver> edwardk: is it really worth breaking out as far as magmas?
09:39:28 <pjd> elem, partition?
09:40:06 <edwardk> quicksilver: i did it to break out (+) as a separate operator. calling it a magma just made it formal.
09:40:08 <pjd> hmm, maybe not partition
09:40:15 <oerjan> pjd: that definition will be stack-efficient only for monads that evaluate from the back, though.  See my alternative definition which works for monads that evaluate x first.
09:40:16 <quicksilver> edwardk: fair enough
09:41:20 <edwardk> i do enforce the a -> a -> a signature on (+) though, since otherwise there are things that are typeable now that would cease to be so, with limited fundep feedback between the different args etc. had to do that to the entire numerical tower, as much fun as allowing something more general would have been
09:41:33 <pjd> oerjan: which definition?
09:42:19 <oerjan> \n f x -> x >>= foldr (flip . ((>>=) .)) return (replicate n f)
09:42:21 <edwardk> i initially wanted to go with (+) : a -> b -> c; where a b -> c, a c -> b, b c -> a, so that you could use the (+) at the term level for type level addition.
09:42:34 <pjd> oerjan: ok, but that's with an n
09:42:49 <oerjan> pjd: both of mine were
09:43:03 <pjd> right; i was trying to mirror iterate
09:43:10 <oerjan> since that seemed what ptolomy asked for
09:44:37 <pjd> i'm not sure i understand "monads that evaluate from the back" :)
09:44:43 <edwardk> it would have made for some nice witnesses for type level arithmetic, but seems a little too messy to permit in practice since you can't rely on the fact that a + b :: Int implies a and b are both Int.
09:45:17 <oerjan> pjd: there are some monads that evaluate x >>= f starting with f rather than x
09:46:06 <oerjan> Reader and lazy State, i think
09:46:36 <pjd> what does that imply?
09:47:48 <oerjan> it means that it may be more efficient to do (((...(x >= f) >= f) >>= f)...) rather than x >>= \t -> f t >>= \t -> f t ...
09:48:01 <oerjan> and reverse for other monads, such as IO
09:48:15 <sorear> haskell doesn't have a specified evaluation order :)
09:48:24 <sek> i'm trying to compile something and i'm getting "/usr/bin/ld: can't locate file for: -lHSparsec". I located the library in /sw/lib/ghc-6.6 and added this to $LD_LIBRARY_PATH but its still not working. Any suggestions? Thanks
09:48:43 <oerjan> sorear: you know very well what i mean
09:48:50 <Igloo> sek: Are you using ghc to link?
09:48:59 <sorear> sek: -optl-L/sw/lib/ghc-6.6 - LD_LIBRARY path is for the dynamic linker
09:49:10 <edwardk> hrmm, so adding restricted monads, generalizing out lists, numerics, generalized enum, what else does the prelude cover? IO, show/read?
09:49:18 <sek> Igloo, i'm just following instructions and running runhaskell Setup.hs build
09:49:18 <Igloo> sek: You shouldn't need any extra options if the package is installed properly
09:50:03 <sek> sorear, can i pass that to runhaskell ?
09:50:17 <edwardk> igloo: do you know if the enumFromTo* functions will bind to a more general Enum class if you -fno-implicit-prelude ?
09:50:36 <edwardk> for the [foo..bar] sugar
09:50:38 <sorear> edwardk: they will even if you don't
09:50:47 <edwardk> sorear: ah really? nice
09:50:51 <sorear> edwardk: oh, for the sugar -fno-implicit-prelude is needed
09:50:52 <oerjan> For simplicity you can replace that with: for some monads x >>= f is strict in x, for some it is strict in f.
09:51:04 <Igloo> I'm not sure OTTOMH
09:51:10 <edwardk> wasn't sure, coz those weren't specifically mentioned in the -fno-implicit-prelude docs
09:51:25 <sorear> oerjan: Are there any monads where x >>= f isn't strict in f?
09:52:05 <oerjan> sorear: Maybe, []
09:52:17 <sorear> > Just 1 >>= undefined
09:52:18 <lambdabot>  Undefined
09:52:24 <sorear> > Nothing >>= undefined
09:52:25 <lambdabot>  Nothing
09:53:28 <pjd> oerjan: ok;  but i'm not sure i understand how that affects those functions' efficiency
09:54:11 <oerjan> pjd: if the monad is strict in x, then (((((x >= f)>>= f)>>= ...) needs to delve deep into it before it can evaluate anything
09:54:36 <oerjan> while x >>= \t -> f t >>= ... might simplify fast
09:54:49 <vininim> 0 0 1           I take entire C heap and win. I also die and lose.
09:55:01 <oerjan> and reverse if it is strict in f
09:55:01 <edwardk> is there a Data.Bag or something like that? or is it just assumed you use []? the original wadler papers liked to talk about a Bag Monad, which wasn't implementable as a Haskell Monad because of the constraint on the containable types, that becomes writable as a restricted monad though.
09:55:11 <vininim> I wonder how people let that go for so long in a wikipedia article
09:56:53 <oerjan> edwardk: you can use Data.Map x Int(eger)
09:57:33 <edwardk> oerjan: mapping elements to themselves?
09:57:54 <oerjan> edwardk: mapping elements to their number of occurrences
09:58:01 <edwardk> ah
09:58:03 <edwardk> nice
09:58:07 <sek> sorear, should i be adding this in the .setup-config file maybe?
09:58:28 <edwardk> sold, wrapped up in a nice little newtype bow that doesn't suck
09:58:47 <sorear> sek: No, you should figure out what was messed up when you were installing GHC.  And then as a last resort add it to the .cabal file.
09:59:27 <sek> i tried adding it to the cabal file as well, in the Ghc-options. Let me try again
09:59:42 <sek> I think it may well be conflicting versions of ghc
10:01:58 <Heffalump> edwardk: I was going to say before you left earlier that embedded languages are often a reason to want a restricted monad
10:02:21 <Heffalump> for example if your monad can only work over the domain of the embedded language
10:04:35 <edwardk> heff: yeah
10:05:56 <edwardk> so, with that you get restricted monad transformers, no? BagT and SetT?
10:06:07 <edwardk> just continuing the model above
10:06:48 <wli> edwardk: Augmenting the pretty printing combinators with support for tabular formatting.
10:06:57 <edwardk> gah, Data.Map takes its arguments in the wrong order to be used as an 'unmarked' monad like the anonymous reader and Set monads can be.
10:07:16 <edwardk> wli: supply me code, and it goes in. ;)
10:07:26 <edwardk> wli: otherwise i strictly generalize ;)
10:07:33 <wli> edwardk: I've got numerical affairs to deal with.
10:08:18 <oerjan> edwardk: another bag implementation is a -> Int(eger), although that is useless for traversal
10:08:43 <edwardk> hrmm. kind of like the implicit Set specified by a -> Bool ?
10:08:47 <oerjan> right
10:09:18 <wli> edwardk: I've still not worked out closed forms for certain coefficients in the system of linear equations in my rational Hermite interpolants.
10:09:20 <edwardk> so how would you use that bag or set as a monad?
10:09:41 <edwardk> wli: what are you using them for?
10:09:47 <oerjan> in those cases it is the return operation that becomes problematic, it requires Eq
10:09:58 <Saizan> edwardk: have you code for MonadTrans that goes with restricted monads? with instances for standard MonadT like StateT?
10:09:59 <oerjan> i think
10:10:19 <oerjan> maybe there are problems with >>= too
10:10:23 <edwardk> oerjan: i can force requirements, remember i allow for constraints, like Ord or Eq, thats fine. its just a matter of enumerating the things to pass through, no?
10:10:25 <quicksilver> @seen sjanssen
10:10:25 <lambdabot> I saw sjanssen leaving #haskell and #xmonad 14m 34s ago, and .
10:10:33 <quicksilver> bah timing
10:10:38 <edwardk> >>= needs some way to enumerate elements as near as i can tell
10:10:48 <oerjan> yeah
10:11:08 <edwardk> Saizan: working on that. i'd need them to get BagT and SetT, until i realized those would exist i hadn't felt the need
10:11:11 <wli> edwardk: Interpolation. Polynomials suck, but I've not seen code for the analogue of Hermite interpolation for rational functions.
10:11:28 <sorear> aren't bags just the free module monad over the semiring Nat?
10:12:08 <edwardk> sorear: so you're saying there is a more general monad that could be dropped in?
10:12:09 <wli> sorear: I thought they were sets with multiplicities.
10:12:39 <wli> sorear: Which AIUI is not quite a free module as N is not a group.
10:13:05 <oerjan> edwardk: can your language have a class type?  If you can parametrize Functor etc. over the class constraint you would maybe get arbitrary categories.
10:13:08 <edwardk> newtype Bag' t a = Bag' (Data.Map a t); type Bag a = Bag' Int a  ?
10:13:12 <sorear> edwardk: well, unfortunately dpiponi's module monad is Eq-restricted too :(
10:13:29 <jethr0> @seen lemmih
10:13:29 <lambdabot> lemmih is in #haskell. I last heard lemmih speak 4h 8m 43s ago.
10:13:30 <Saizan> edwardk: i'm worried that the third monad law won't hold for things like StateT Int Set, because you get diffrent results depending on when you remove duplicate elements, but i'd have to test
10:13:51 <edwardk> oerjan: well, in my language case classes are just records and can be explicitly passed in. but in this case, i'm actually working on a toy prelude reimplementation in haskell for a lot of this stuff
10:14:37 <edwardk> right now i remove elements every >>= iirc, i just pretty much stole Eric Kidd's version of Set.
10:15:17 <edwardk> sorear: hrmm. i remember seeing something about that, i just forgot who wrote it
10:15:33 <oerjan> sorear: bags are just the commutative monoid monad, i think
10:15:41 <sorear> edwardk: dpiponi, known elsewhere as sigfpe
10:15:49 <edwardk> yeah
10:16:30 <wli> A free monoid, not a free module.
10:16:47 <jethr0> someone using xterm under mac os x here?
10:16:49 <wli> Free commutative monoid, that is.
10:17:18 <Maddas> jethr0: sometimes, why?
10:17:19 <edwardk> oh yeah the stuff that was working in dioids or whatever for shortest path computation, good catch
10:17:43 <jethr0> Maddas: mine doesn't display underscores "_" and i'm having a hard time googling for a fix. any ideas?
10:18:02 <wli> Well, if there's a path, they're not free.
10:18:02 <Saizan> edwardk: yes, but with (m >>= f) >>= g  you remove them differently than with m >>= (\x -> f x >>= g), you can surely get different result with a weird Ord instance, not sure if StateT can help too :)
10:18:10 <Maddas> jethr0: no idea, sorry -- never had any problem like that
10:18:16 <oerjan> although a commutative monoid is probably the same as a "module" over Nat.
10:18:19 <jethr0> Maddas: hehe, thx though
10:18:38 <desp> quicksilver: I prepared a small example demonstrating the odd behavior: http://varsztat.com/bug/
10:18:40 <lambdabot> Title: Index of /bug
10:18:52 <edwardk> hrmm, so if the operation isn't Ord-preserving?
10:18:57 <wli> oerjan: It's analogous to a module, but I don't know of any name for it.
10:19:01 <edwardk> er Eq preserving
10:19:08 <edwardk> ?
10:19:38 <sek> blast! How can i make ghc-pkg not try to add an entry in /usr/lib/ghc-6.4/package.conf ? The 6.6 user manual mentions the -hide-all-packages which doesnt seem to be supported in 6.4, and also the -ignore-package <package>   doesnt seem to do what i want
10:19:49 <Saizan> edwardk: yes, if g is such that  x == y =\=> g x == g y
10:20:19 <sek> (the problem being i dont have permission to edit that file)
10:20:44 <wli> oerjan: I'm wildly guessing semimodule when the scalars are a semiring.
10:21:24 <edwardk> that is a breakage i'm willing to accept with the caveat that you need a 'tight' notion of equality and to only inspect in an equality preserving manner. if == implies observational equivalence its safe. its just the corner cases of things like -0 vs. 0 in floats or hand-defined Ord's which have broad notions of equality
10:21:56 <edwardk> in my toy language that becomes an issue to check with a quotient type. i can't do anything about it here in haskell-land.
10:23:46 <Saizan> edwardk: yes, very reasonable, but what about g _ = get >>= \x -> put (x+1) >> return x  in StateT Int Set?
10:24:35 <Saizan> edwardk: actually i wonder if something like that would cause problems
10:24:40 <Saizan> or not
10:24:50 <edwardk> not sure, StateT is in general safe, no?
10:24:58 <oerjan> wli: wikipedia calls that a monoid, under http://en.wikipedia.org/wiki/Module_(mathematics)#Generalizations
10:24:58 <Heffalump> I can't see how that could cause problems
10:25:01 <edwardk> not sure i see how Set can break it
10:26:49 <edwardk> ok, so Set(T?) and Bag(T?) are only correct insofar as operations respect ==
10:27:25 <wli> oerjan: Well, they're isomorphic to commutative monoids. I'm apparently wrong about there being a distinct term for modules with semirings for scalars.
10:27:32 <edwardk> which makes sense given that they are limitations of monads to a tighter space than the space of all functions, its just not checkable in haskell that things preserve ==
10:29:30 <edwardk> and we can add dpiponi's dynamic programming/semiring/dioid monad
10:29:38 <edwardk> other restricted monads of interest? =)
10:30:50 <edwardk> i tried to figure out if parameterized monads would fit in, but they appear to blow up just like the refactored (+) : a -> b -> c with a b -> c, a c -> b, b c -> a, you wind up with cases where you can't infer the types from the outside in or the inside out.
10:31:37 <Saizan> parametrized monads?
10:32:36 <edwardk> i.e. if we have MyParamMonad p a >>= MyParamMonad p' b   and the result is of type MyParamMonad p'' b, with fundeps relationg p p' p''. there are a number of parameterized monads involving delimited continuations and things in a couple wadler papers
10:32:55 <edwardk> but they appear to have bad properties from a type inference perspective
10:33:43 <edwardk> since i need to be able to go from p -> p' p'', p' -> p p'', p'' -> p p'  in order to maintain existing monad typability, not just p p' -> p'', ...
10:36:17 <Saizan> i see, so it becomes a type annotation hell?
10:37:26 <edwardk> aha, i think i have an idea
10:37:52 <edwardk> parameterized monads in the former sense aren't possible, but parameterized monads in the latter sense can be combined with the restricted monad information
10:37:58 <edwardk> hrmm
10:38:13 <edwardk> fundeps can relate p p' p'' and a and b, as well
10:38:17 <edwardk> so something like
10:39:39 <edwardk> class (Return m p a, Return m p' a) => Bind m a b p p' p'' | a b p -> p' p'', a b p' -> p p'', a b p'' -> p p' where (>>=) :: m p a -> m p' b -> m p'' b
10:39:44 <edwardk> whee
10:39:44 <SamB> n[y]hc has some crazy near-monads
10:39:49 <sorear> sek: I have twelve versions of GHC installed, and they All Just Work.  merely having 6.4 and 6.6 on the same system does not explain your problem.
10:40:08 <SamB> sorear: which 12?
10:40:19 <edwardk> when you could do things like accumulate a parameter of say, an HList of all the result types or something assuming you can prove the monad laws
10:40:42 <edwardk> or a security tag at the type level rather than the term level
10:41:04 <sorear> stefan@stefans:/usr/local/src/hpaste-devel$ dmenu_path | grep '^ghc-6' | pr -T -w80 -4
10:41:08 <sorear> ghc-6.4.2	    ghc-6.7.20070213	ghc-6.7.20070402    ghc-6.7.20070518
10:41:10 <sorear> ghc-6.6.1	    ghc-6.7.20070223	ghc-6.7.20070413    ghc-6.7.20070601
10:41:13 <sorear> ghc-6.7		    ghc-6.7.20070323	ghc-6.7.20070502    ghc-6.7.20070612
10:41:20 <edwardk> monad laws would probably have to be witnessed modulo some notion of equality though to get the bidirectionality needed though like with Bag and Set
10:43:00 <shapr> Yay, first hackage upload.
10:43:02 <edwardk> anyways in most cases the above signature can be hidden behind a Monad class which admits only p = p' = p'' = Void (no parameter) and admits instances for all a and b (no restriction).
10:44:18 <edwardk> instance Monad m => Return m a b Void Void Void where (>>=) = (>>=!) or whatever you tag the unrestricted version of >>= as
10:44:44 <edwardk> not sure what parameterized monads make sense though
10:44:50 <sorear> shapr++
10:46:31 <fbuilesv> how can I ask GHCi which function has the signature "something"?
10:46:44 <fbuilesv> not ghci but lambda-bot,sorry.
10:46:58 <shachaf> @hoogle a -> [a]
10:46:58 <lambdabot> Prelude.repeat :: a -> [a]
10:46:58 <lambdabot> List.intersperse :: a -> [a] -> [a]
10:46:58 <lambdabot> Prelude.(:) :: a -> [a] -> [a]
10:47:06 <wli> ooh pi calculus
10:47:06 <fbuilesv> thank you.
10:47:33 <shachaf> fbuilesv: Also see http://haskell.org/hoogle/ .
10:47:34 <lambdabot> Title: Hoogle
10:48:21 <wli> edwardk: Oh, ultimately I want to use these rational function affairs to replace cubic splines.
10:48:38 <fbuilesv> :O nice, ff plugin :D
10:48:47 <wli> edwardk: Because polynomials suck.
10:48:57 <edwardk> so, it would appear that the above definition would build up a parameterized monad, where the constraints on p p' p'' would force the particular implementation to either do nothing or build up something like the free magma, in which case you'd only be able to legally reduce it with an operation on types that was associative if you want to respect the monad laws.
10:49:55 <sjanssen> darcs.net seems to be down, anyone know where I can find darcs binaries for Windows?
10:50:21 <wli> edwardk: I had deducing properties such as cancellativity, associativity, etc. for finite magmas from their operation tables as an alternative language shootout problem suggestion.
10:50:43 <edwardk> ah cute
10:51:46 <edwardk> heya dave
10:51:53 <Dave_Herman> hey, ed
10:52:17 <vincenz> Hey Dave_Herman
10:52:21 <Dave_Herman> howdy
10:52:47 <edwardk> any luck moving the reference implementation to a better sml implementation?
10:52:59 <Dave_Herman> I've been busy with a popl paper lately
10:53:02 <edwardk> ah
10:53:17 <Dave_Herman> unfortunately it looks like mlton didn't buy us much performance
10:53:19 <vincenz> Dave_Herman: ouch
10:53:25 <edwardk> a shame
10:53:36 <vincenz> Dave_Herman: good luck on the popl one, I hear it's tough ;)
10:53:40 <Dave_Herman> thx
10:53:41 <wli> edwardk: My thoughts on an alternative language shootout are floating around http://holomorphy.com/~wli/shootout.html
10:53:42 <lambdabot> Title: Programming Language Shootout Thoughts
10:53:45 <edwardk> but then its just kind of a simple interpreted version of the semantics, no?
10:53:52 <Dave_Herman> yes
10:53:55 <vincenz> Dave_Herman: actually, now that you're here...
10:54:00 <Dave_Herman> to some degree, you can't make algorithmically slow code fast
10:54:03 <Dave_Herman> no matter how good the compiler
10:54:13 <edwardk> yeah
10:54:31 <Dave_Herman> I have a dumb ghc installation issue
10:54:39 <vincenz> Dave_Herman: You mention in one of your articles that a continuation is basically a zipper.  Today I was playing around with higher-order zippers and was curious how that'd related to continuations (for instance, are delimited continuations second-order zippers, cause you can splice out part of the controlflow?)
10:55:04 <vincenz> s/related/relate
10:55:16 <Dave_Herman> I'm not familiar with higher-order zippers
10:55:35 <vincenz> Dave_Herman: http://notvincenz.blogspot.com/2007/07/higher-order-zippers.html
10:55:36 <lambdabot> Title: lambda.oasis: Higher Order Zippers
10:55:40 <vincenz> Dave_Herman: the epiphany came last night :)
10:55:46 <edwardk> vincenz: oleg has a bunch of papers on continuations as zippers and vice versa
10:55:54 <vincenz> edwardk: only first-order zippers
10:56:01 <Dave_Herman> in my mind, the relationship between continuations and zippers is thru evaluation contexts
10:56:19 <edwardk> the stack is the zipper itself
10:56:21 <edwardk> yeah
10:56:34 <vincenz> let Zipper d a = Zipper (d a) a where d is the derivative of a functor.  Then zipper2 = Zipper (Zipper d2) a where d2 is the second derivative
10:56:35 <edwardk> the head of the stack is the hole in your context
10:56:39 <vincenz> You get O(1) splicing instead of O(1) mutation
10:56:55 <vincenz> (well and you get O(1) mutation as well)
10:57:07 <Dave_Herman> brb
10:57:15 <vincenz> edwardk: delimited continuations take part of the controlflow (from a begin and end) and then splice it out and reify it
10:57:40 <edwardk> makes sense, if only because i've been using a lot of delimited continuations of late
10:57:48 <edwardk> gah, meeting time, bbin a couple hours
11:00:26 <sek> sorear, if i'm editing the cabal file and adding something like you recommended, -optl -L/sw/lib/ghc-6.6 , then -lHSparsec would look for libHSparsec.so no? I have an HSparsec.o file in sw/lib/ghc-6.6
11:01:30 <Dave_Herman> I've installed the head ghc 6.7 and my regexes stopped working
11:01:44 <Dave_Herman> can anyone tell me the magic incantation I need for compatibility regexes?
11:02:04 <Dave_Herman> vincenz: your blog post looks interesting
11:02:14 <vincenz> Dave_Herman: thanks :)
11:02:22 <vincenz> I Want to see how this relates to DCs
11:02:23 <Dave_Herman> I remember reading about derivatives of types
11:02:45 <Dave_Herman> I think Huet has some heavy-duty stuff on zippers and continuations
11:03:00 <vincenz> Yep, but I fear they all only went first-order zippers
11:03:54 <Dave_Herman> vincenz: I think this was the one I saw:
11:03:54 <Dave_Herman> http://www.citeulike.org/user/dherman/article/169628
11:03:55 <lambdabot> Title: CiteULike: Linear Contexts and the Sharing Functor: Techniques for Symbolic Comp ...
11:04:11 <sorear> sek: You don't have parsec properly installed.
11:04:23 <vincenz> Dave_Herman: I'll take a look, I don't have that article yet, thanks :)
11:04:23 <sorear> sek: The .o files are for GHCi *only*
11:04:46 <Dave_Herman> alas, I haven't had time for reading like this in quite a while
11:04:46 <sorear> sek: Why don't you have a libHSparsec.a file somewhere?
11:05:13 <sek> sorear, i dont seem to have it no
11:05:27 <sek> sorear, this is attributed to fink's installing techniques
11:05:34 <sek> or do i need an extra library for parsec
11:05:58 <sek> fink lists ghc, ghc-dev and ghc-prof
11:08:47 <sek> crap, sorear has left me!=/
11:10:34 <Dave_Herman> how do I install regex-compat?
11:10:34 <sek> odd, i do seem to have Parsec installed since the modules are all there
11:11:12 <byorgey> sek: on Debian/Ubuntu, parsec is in a different package, I don't know if that carries over to fink
11:11:40 <sek> byorgey, Prelude> :m +Text.ParserCombinators.Parsec
11:11:40 <sek> Prelude Text.ParserCombinators.Parsec>
11:11:54 <sek> but no libHSparsec.so file
11:12:17 <bos> it would be libHSparsec.a
11:12:34 <sek> byorgey, i thought parsec came by default with the latest versions of ghc
11:12:45 <sek> bos, that is missing too
11:13:38 <vincenz> Dave_Herman: the hackage package is not working?
11:13:42 <wli> I appear to have parsec.
11:13:57 <sek> anyone else on a mac with ghc 6.6 installed via fink?
11:13:57 <Dave_Herman> vincenz: I don't know how to install hackage packages
11:14:07 <vincenz> Dave_Herman: ok, you downloda the .tgz from hackage
11:14:08 <vincenz> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/regex-compat-0.90
11:14:10 <lambdabot> http://tinyurl.com/39hwsy
11:14:18 <Dave_Herman> and untarball into ghc/Haskell ?
11:14:29 <vincenz> then it should be "runghc Setup.hs configure" "runghc Setup.hs build"  "runghc Setup.hs install"
11:14:35 <vincenz> unless README says differently
11:14:42 <vincenz> last one you might want to sudo
11:14:51 <Dave_Herman> do this from a tmp directory?
11:14:54 <vincenz> yep
11:14:57 <Dave_Herman> ok
11:14:58 <Dave_Herman> thx
11:15:14 <vincenz> Dave_Herman: http://www.haskell.org/haskellwiki/How_to_install_a_Cabal_package
11:15:15 <lambdabot> Title: Cabal/How to install a Cabal package - HaskellWiki
11:15:23 <Dave_Herman> thx
11:15:25 <vincenz> np
11:15:32 <Dave_Herman> I have to manage dependencies manually, right?
11:15:35 <fbuilesv> sek: I'm using binary distribution on 10.4.9 without any issues, why'd you install over fink?
11:15:45 <sek> fbuilesv, god knows
11:15:47 <vincenz> Dave_Herman: yes
11:15:51 <Dave_Herman> vincenz: ok
11:15:55 <fbuilesv> hah
11:15:58 <sek> fbuilesv, you have libHSparsec.a ?
11:16:08 <fbuilesv> I'll tell ay on a sec, let me boot it up
11:16:22 <sek> ah dont worry
11:16:27 <sek> i need to shoot off in a couple of minutes
11:16:37 * vincenz wonders if anyone knows the derivative of a^x as taylor expansion as it's been too long, preferably without any / and ln
11:17:08 <vincenz> or maybe it's just not possible to derive function types
11:17:14 <wli> vincenz: d/dx = ln(a)*a^x, so you're going to get ln(a)
11:17:49 <vincenz> wli: hmm :)
11:17:51 <vincenz> been too long
11:17:58 <vincenz> maybe I should just find the meaning of 'ln' in discrete mathematics
11:18:19 <wli> vincenz: Exponential types probably have a derivative that's not analogous to the continuous case.
11:18:28 <dpiponi> vincenz: This is my favourite subject at the moment, trying to find meanings for transcendental functions as types!
11:18:51 <vincenz> dpiponi: I want to derive the first-order zipper of ContT
11:18:57 <vincenz> in terms of 'a'
11:19:02 <dpiponi> ln is kind of like ring buffers
11:19:12 <vincenz> circular list?
11:19:16 <fbuilesv> sek: Yes, it's there
11:19:26 <wli> vincenz: The analogue of e is probably Bool
11:19:28 <sek> fbuilesv, ah thanks! in what directory?
11:19:43 <dpiponi> Yes, something like that. But it's difficult to give precise meaning because you need quotions.
11:19:44 <vincenz> wli: Bool is 1+1
11:19:47 <dpiponi> quotients
11:19:54 <fbuilesv> ghc/lib/i386-apple-darwin/
11:20:06 <vincenz> dpiponi: what about subtraction?
11:20:10 <sek> fbuilesv, ok, thanks again. I'll delete the fink version and go about manually
11:20:21 <Dave_Herman> does cabal not work with cygwin?
11:20:39 <Dave_Herman> Setup.hs: C:\: createDirectory: permission denied (Permission denied)
11:20:43 <fbuilesv> sek: I'm actually starting to wonder if this one was the binary or source code compiled, but each one of those two should work without needing fink.
11:20:44 <wli> vincenz: I'm saying that if the analogous derivation for types will probably have Bool be the base of its natural logarithm and/or exponential.
11:20:52 <vincenz> wli: oh right
11:21:07 <wli> vincenz: I'm guessing something like (d/dx) Bool^x = Bool^x
11:21:25 <dpiponi> -log(1-x)=x+x^2/2+x^3/3+...
11:21:43 <Saizan> Dave_Herman: cabal works from bare cmd.exe if you have runghc in %Path%
11:21:44 <wli> vincenz: Whatever type t has (d/dx) t^x = t^x will be the base of your logarithm.
11:21:51 <dpiponi> But I never got anywhere with powers. And log(x) is completely different to log(1-x).
11:22:02 <vincenz> dpiponi: I was thinking a -> b = a^b => (a->b)' = b*a^(b-1)?
11:22:08 <vincenz> shall we move to #oasis? so people can get help here?
11:22:19 <dpiponi> Yes, but '-1' is a problem.
11:22:25 * vincenz ndos
11:22:25 <wli> dpiponi: Do continued fractions mean anything in your arithmetic?
11:22:49 <oerjan> vincenz: you need to use the multivariable chain rule
11:22:57 <dpiponi> You mean applied to types? I never thought of that. Hmmm...
11:23:03 <vincenz> `ap` #oasis (it's a bit OT)
11:23:08 <shapr> dpiponi: What's a quotion?
11:23:13 <xerox> (I think it's fine here.)
11:23:18 <dpiponi> quotient
11:23:19 <vincenz> xerox: last time we got yelled at :)
11:23:22 <shapr> oh
11:23:32 <sfultong> I am trying to do more point-free programming, but it seems like it's only effective with f = (a -> b) ... any more arguments in a function, and it makes it difficult
11:23:53 <bos> @users
11:23:53 <lambdabot> Maximum users seen in #haskell: 354, currently: 351 (99.2%), active: 15 (4.3%)
11:23:59 <wli> sfultong: There are tricks for dealing with that, and helper combinators, too.
11:24:13 <sjanssen> xerox: does cabal-install work on Windows?
11:24:15 <Saizan> ?type \f g -> (f .) . g -- you might need to use this
11:24:17 <lambdabot> forall b c a a1. (b -> c) -> (a1 -> a -> b) -> a1 -> a -> c
11:24:19 <sfultong> wli: cool, can you point me in the right direction?
11:24:21 <shapr> dpiponi: This was the only use of quotions I could find that sort of matched what you were saying - http://pvs.csl.sri.com/mail-archive/pvs-help/msg00967.html
11:24:22 <lambdabot> Title: Re: [PVS-Help] quotient constructions in PVS
11:24:24 <xerox> sjanssen: it should, I think
11:24:26 <dpiponi> wli: it's card to make sense of continued fractions applied to types. We have something like x-> 1/(1-x) (that's the list functor) but not x->1/x
11:24:44 <dpiponi> wli: So maybe you could get somewhere with that.
11:24:52 <wli> sfultong: In a pinch lambdabot can convert things to point-free style for you.
11:25:20 <vincenz> dpiponi: anyways x^n/n! makes sense to me now... you have a tuple of n 'x's but you divide by the permutation
11:25:20 * Dave_Herman whimpers pitifully
11:25:40 <shapr> Dave_Herman: No Linux box handy?
11:25:42 <wli> dpiponi: x -> 1/(1-x) is fine, now how about 1/(1-x/(2-x/(3-x/(4 - ... ?
11:25:45 <Dave_Herman> shapr: no
11:25:58 <Dave_Herman> does cabal just not work in windows?
11:26:02 <glen_quagmire> is there "zip"ed version of ghc so that i can carry it around in USB thumb drive?
11:26:11 <oerjan> sfultong: check out lambdabot's @pl command
11:26:12 <bos> Dave_Herman: it ought to, at least in principle.
11:26:16 <dpiponi> vincenz: Yup. x^n/n! is an unordered n-tuple. x^n/n is an n-element circular list. But I don't know how to make this rigorous, so to me it's just informal for now.
11:26:21 <Dave_Herman> everything ought to work in principle :)
11:26:22 <Saizan> Dave_Herman: i've never had problems with cabal on windows, but i wasn't using cygwin
11:26:35 <Dave_Herman> Saizan: you ran from cmd.exe ?
11:26:44 <vincenz> dpiponi: right as long as you're just dividing by numbers it's reasonable :)
11:26:47 <wli> dpiponi: You can break continued fractions down as sequences of linear fractional transformations.
11:26:48 <Saizan> Dave_Herman: yes
11:27:43 <Dave_Herman> Saizan: no luck, same error from cmd.exe
11:28:01 <vincenz> dpiponi: oooh $(x^2) = x^3/3... the context of a circular ring of 3 elements is a tuple (obviously :))
11:28:05 <dpiponi> wli: so you're thinking of getting transcendental functions by means of continued fractions?
11:28:15 <wli> dpiponi: Yes.
11:28:24 <Saizan> @paste
11:28:25 <lambdabot> Haskell pastebin: http://hpaste.org/new
11:28:32 <dpiponi> vincenz: So -log(1-x) gives circular lists in general
11:28:36 <Saizan> Dave_Herman: can you paste it?
11:28:49 <Saul_> :t Data.Map.adjust
11:28:51 <lambdabot> forall a k. (Ord k) => (a -> a) -> k -> Data.Map.Map k a -> Data.Map.Map k a
11:28:52 <vincenz> dpiponi: interesting
11:28:57 <oerjan> vincenz, dpiponi: i think maybe you want to avoid functions with discontinuities in 0
11:29:01 <dpiponi> wli: I'm not sure it would work, but it's such a cool idea it's worth a try
11:29:16 <dpiponi> oerjan: Yes, they need to be analytic at zero
11:29:22 <hpaste>  Dave_Herman pasted "cabal error" at http://hpaste.org/1606
11:30:01 <Saizan> Dave_Herman: maybe you need admin privileges?
11:30:04 <dpiponi> vincenz: Here's a fun example that gives a familiar type.
11:30:09 <Dave_Herman> I am an administrator
11:30:10 <wli> dpiponi: Well, there's always 1/(1-x/(1-x/(1- ...) which of course gives the golden ratio at x = -1 (whatever that is wrt. types).
11:30:23 <dpiponi> vincenz: (1-sqrt(1-4x))/(2x)
11:30:30 <vincenz> o.O
11:30:39 <dpiponi> vincenz: Nice exercise: what is the type in conventional language?
11:30:47 <wli> dpiponi: Catalan numbers?
11:30:49 <vincenz> well it's a solution of a fixpoint equation
11:31:36 <vincenz> though I don't see it
11:32:29 <wli> 1/(1-2xt)^2 = 1/(1-4x) ?
11:32:55 <dpiponi> wli: yes
11:33:10 <vincenz> xt^2 +1 =
11:33:10 <vincenz> t
11:33:14 <vincenz> binary tree
11:33:45 <vincenz> data Tree a = Top | Node a (Tree a) (Tree a)
11:33:51 <vincenz> s/Top/Leaf
11:34:09 <dpiponi> vincenz: yes, and the coefficients in the Taylor series are the catalan numbers which have a million applications in combinatorics
11:34:18 * vincenz has no idea what  catalan number is :/
11:34:29 <dpiponi> http://mathworld.wolfram.com/CatalanNumber.html
11:34:30 <lambdabot> Title: Catalan Number -- from Wolfram MathWorld
11:35:11 <dpiponi> So there's a nice overlap between type theory and combinatorics
11:35:30 <sjanssen> xerox: are there any plans to do a release of cabal-install?  Has there been an official release in the past?
11:35:41 <wli> dpiponi: What kind of type would t^2 = 4x^3 - g_1 x - g_2 be?
11:35:59 <vincenz> wli: where is 't'?
11:36:30 <sjanssen> xerox: it'd be really nice to have some cabal-install binaries available on hackage.haskell.org
11:36:38 <wli> dpiponi: Are there diffeq's over types that make any kind of sense?
11:36:39 <Dave_Herman> sjanssen: yes
11:36:42 <dpiponi> wli: elliptic functions generally don't have nice integer coefficients
11:36:45 <Dave_Herman> I am completely stuck
11:36:56 <glen_quagmire> found it it's in main site
11:37:00 <wli> dpiponi: Where do integer coefficients come in?
11:37:00 <njbartlett> @seen Heffalump
11:37:00 <lambdabot> Heffalump is in #haskell-blah, #haskell and #darcs. I last heard Heffalump speak 1h 12m 2s ago.
11:37:04 <sjanssen> Dave_Herman: stuck on what?
11:37:11 <dpiponi> wli: yes. Just the ordinary equations for zippers can be interpreted as differential equations
11:37:22 <Dave_Herman> I'm trying to use the latest HEAD ghc, and it's failing to install cabal packages
11:37:34 <dpiponi> wli: 'cos it's hard to make sense of a type like x^2/7+x^3/22
11:37:46 <sjanssen> Dave_Herman: it complains about modules being hidden/missing?
11:37:53 <vincenz> dpiponi: once we can do reals, let's move to complex numbers ;)
11:37:53 <Dave_Herman> y
11:38:01 <Dave_Herman> sjanssen: I'm using Text.Regex
11:38:15 <Dave_Herman> so I tried installing required packages, and I got: http://hpaste.org/1606
11:38:18 <sjanssen> Dave_Herman: there was a major package reorganization recently -- it will be finished after 6.8
11:38:32 <sjanssen> Dave_Herman: you really should be using a released version if at all possible
11:38:40 <dpiponi> vincenz: let me see if I can find a link to one of my favourite papers related to this topic...
11:38:51 <Dave_Herman> I was trying to use indexed types
11:38:57 <Dave_Herman> only available in 6.7 as I understand
11:38:57 <sjanssen> Dave_Herman: oh, permission denied might be another thing
11:39:07 <sjanssen> Dave_Herman: I know nothing about Windows
11:39:09 <Dave_Herman> sjanssen: but I'm administrator
11:39:10 <dpiponi> vincenz: Found it. This is interesting and I'm sure has a deep connection with type theory. http://front.math.ucdavis.edu/9405.5205
11:39:13 <lambdabot> Title: Front: [math.LO/9405205] Seven Trees in One
11:39:18 <Syzygy-> Hey dpiponi
11:39:38 <Syzygy-> You're awake at decent times too!? *boggle*
11:39:38 <Dave_Herman> sjanssen: from what I can guess, it looks like it's trying to create a directory that already exists (C:\)
11:39:46 <dpiponi> Hi Syzygy
11:40:06 <dpiponi> Syzygy: I'm at work, taking a little tea break
11:40:11 <vincenz> dpiponi: my math-fu is not so strong, my background is EE, not CS, all CS stuff is self-taught from papers
11:40:17 <Syzygy-> Ah
11:40:54 <dpiponi> vincenz: Buried in that paper is something really easy to understand. But it's buried under lots of math.
11:40:58 * vincenz nods
11:41:33 <dpiponi> vincenz: If T is the type of binary trees then there is a simple isomorphism T^7 -> T.
11:41:50 <vincenz> is 7 special?
11:42:12 <dpiponi> vincenz: Yes. This kind of exact isomorphism is very rare between types.
11:42:34 <vincenz> sounds interesting, I'll read it in more detail later :)
11:43:15 <dpiponi> vincenz: I'll have to implement the code for it some time.
11:43:31 <vincenz> @src Cont
11:43:32 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
11:43:55 <wli> dpiponi: So a power series for a type needs to be the generating function of an integer sequence? Ordinary or exponential?
11:44:39 <dpiponi> wli: ordinary, though if you can define quotient types (and there are papers on these, I think) it'll extend to exponential generating functions
11:46:37 <Dave_Herman> sjanssen: it must be a bug in recent versions, it worked with a month-old GHC
11:46:40 <dolio> @yow
11:46:41 <lambdabot> HELLO KITTY gang terrorizes town, family STICKERED to death!
11:47:17 <dpiponi> wli: positive integers of course!
11:48:31 <wli> dpiponi: Well, if integer division works, then you're home free.
11:49:33 <dpiponi> wli: But it doesn't! x^n/n! makes sense, it's just an unordered n-tuple. But x^3/7 makes no sense. That's why exponential generating functions make sense, you can divide by n!, but no more.
11:51:14 * Dave_Herman gives up
11:51:21 <wli> dpiponi: How about Newton series \sum_n c_n \binom{x}{n} ?
11:52:46 <wli> dpiponi: If integer multiplication makes sense and multiplication/division is cancellative, then x^3/7 = 6! x^3/7!
11:53:05 <oerjan> perhaps (x^n+x^m)/(n!+m!) makes sense?
11:53:35 <sjanssen> Dave_Herman: you might consider bringing it up on glasgow-haskell-users@, just to be sure it's fixed by the next release
11:53:48 <crazy_coder> How to check it there is atleast an element in the list satisfying a certain predicate ?
11:53:48 <Dave_Herman> sjanssen: thanks
11:54:11 <vincenz> dpiponi: any idea on how to integrate a fix-point ?
11:54:11 <dpiponi> wli: the idea with x^n/n! is that you alow the group Sn to act on n-tuples to remove the ordering. But what is the action of S7 on 6!x^3 ???
11:54:30 <dpiponi> vincenz: what does that mean?
11:54:39 <vincenz> well the integral of x^2 = x^3/3
11:54:44 <vincenz> so the context for x^3/3 = x^2
11:54:50 <Saizan> crazy_coder: any predicate list
11:54:55 <vincenz> but the integral of [a] = mu x.1+ax...
11:54:59 <dpiponi> oerjan: it probably does. Sounds like a nice exercise for someone :-)
11:54:59 <sjanssen> hmm, where can I find a tar for Windows that supports -z?
11:55:00 <wli> dpiponi: Point, it may be required that the denominator of x^n be <= n
11:55:00 <vincenz> I guess I could expand
11:55:03 <Saizan> > any (==10) [1..10]
11:55:04 <lambdabot>  True
11:55:10 <crazy_coder> Saizan: using listAssert ?
11:55:26 <vincenz> oerjan: it doesn't
11:55:37 <vincenz> oerjan: x^n + x^m is either n xs or m xs
11:55:43 <dpiponi> wli: I think the denominator needs to divide n! to have any chance of making sense of it
11:55:44 <vincenz> you can't divide either those by the sum coefficient
11:56:13 <Dave_Herman> sjanssen: it might be this: http://hackage.haskell.org/trac/ghc/ticket/1490
11:56:15 <lambdabot> Title: #1490 (Install with Cabal broken on Windows) - GHC - Trac
11:56:28 <oerjan> vincenz: you don't divide each, you divide the whole
11:56:48 <oerjan> using a group that permutes them all.
11:56:51 <sjanssen> Dave_Herman: yeah, almost certainly
11:57:20 <Dave_Herman> I suppose there's no other way to use indexed types but just to wait till these bugs get fixed
11:57:26 <oerjan> although it may be significant that such a group cannot be polymorphic functions. hm.
11:57:29 <dpiponi> vincenz: a list of x's is 1/(1-x). The integral is -log(1-x)
11:57:40 <dpiponi> (I should say *an* integral)
11:57:55 <oerjan> the integral should be an anti-zipper?
11:57:56 <crazy_coder> Saizan: I actually want to check if 0 is a member of the list or not
11:57:58 <vincenz> right, you have the constant
11:58:03 <vincenz> oerjan: yep
11:58:08 <vincenz> well not quite
11:58:16 <vincenz> a zipper is a*d  where d is the derivative
11:58:16 <crazy_coder> I read it somewhere, but I don't remember it now ...
11:58:18 <dpiponi> vincenz: you get a list by making a hole in a circle. Kinda intuitive :-)
11:58:32 <vincenz> dpiponi: yeah, it just has to come to you :)
11:58:49 <byorgey> crazy_coder: Saizan showed how up above.  In your case you want any (==0).
11:58:51 <vincenz> just like giving meaning to my DDTree :)
11:58:53 <wli> dpiponi: A list of length n is equivalent to an n-tuple in this accounting. Hmm.
11:59:00 <vincenz> I had to rework my equations a bit to get something sensible
11:59:00 <byorgey> crazy_coder: you could also say 0 `elem` list
11:59:10 <Saizan> crazy_coder: isThereAZero xs = any (==0) xs, will give True if 0 is a member of xs
11:59:12 <dpiponi> vincenz: I already knew about the bursting circle thing
11:59:35 <crazy_coder> Thanks
11:59:38 <dpiponi> vincenz: Yes, a*d/da is an especially interesting operator
11:59:53 <Saizan> crazy_coder: yeah, in this case elem is what you want
12:00:02 <oerjan> @src elem
12:00:02 <lambdabot> elem x    =  any (== x)
12:00:21 <wli> dpiponi: d/d(log(x))
12:00:28 <wli> dpiponi: d/d(log(a)) rather
12:00:33 <vincenz> dpiponi: the curious thing is, for the second deriv, it's:   a*a*d^2/da^2 instead of a*d/da(a*d/da)
12:00:43 <vincenz> you don't derive the zipper, just the derivative
12:00:45 <vincenz> and add an extra element
12:00:51 <wli> I wonder why not elem = any . (==)
12:00:55 <dpiponi> vincenz& wli: I've played with both of those things
12:01:19 <dpiponi> voncenz: here's an interesting operator 1+a+a*d/da+a*d/da*a*d/da+...
12:01:25 <mrd> :t elem
12:01:27 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
12:01:41 <vincenz> dpiponi: I take it the '+a+' is off?
12:01:41 <mrd> :t let elem = any . (==) in elem
12:01:43 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
12:01:43 <dpiponi> vincenz: It's the 'list of holes' operator
12:01:56 <dpiponi> vincenz: yes, typo
12:01:56 <vincenz> dpiponi: got any written stuff on this?
12:02:09 <dpiponi> vincenz: no!
12:02:10 <wli> dpiponi: 1/(1-(d/da)), and d/d(log(a)) is the shift-by-one operator on exponential generating functions.
12:02:26 <dpiponi> vincenz: I know one other person has been thinking about this stuff, let me find the link
12:02:36 <wli> dpiponi: e^(d/da) is also frequently examined.
12:02:56 <dpiponi> wli: e^(d/da) is the shift operator. It has a really nice meaning in types!
12:03:06 <vincenz> dpiponi: I was just curious if the second-order zipper was novel or not :)
12:04:30 <dpiponi> vincenz: I've thought about it, but didn't go as far as you in working out the details.
12:04:59 <vincenz> the spiffy thing was when I found out I got splicing for O(1) :)
12:05:06 <vincenz> what is the meaning of e^T?
12:05:15 <wli> dpiponi: I wonder if D/(e^D-1) makes any sense.
12:05:35 <vincenz> oh, nm, just taylor expand it
12:05:44 <vincenz> 1+d/da + d^2/da^+..
12:05:44 <dpiponi> wli: The Euler-Maclaurin sum operator!
12:05:46 <wli> (D = d/da)
12:06:01 <oerjan> vincenz: it should be something whose zipper is T' e^T
12:06:18 <dpiponi> wli: I'd kill for an interpretation of that operator in types!
12:06:21 <wli> dpiponi: Well, I usually call it the exponential generating function for Bernoulli numbers.
12:06:43 <vincenz> oerjan: good point :)
12:06:48 <wli> dpiponi: Well, -D \sum_n e^{n D}
12:06:57 <dpiponi> vincenz: http://jcreed.livejournal.com/1048690.html
12:07:01 <vincenz> it's a shame we can't do this in haskell
12:07:13 <vincenz> data D F a = d(F)/da
12:07:25 <vincenz> where F is a functor
12:07:30 <dpiponi> wli: I have this obsession with -1/12 which I'm sure you'll recognise is a very special number
12:07:55 * pjd discovers Andrew Löh's papers
12:08:04 <pjd> err, Andres
12:08:24 <oerjan> dpiponi: referring to the 1 + 2 + 3 + ... series?
12:08:26 <dpiponi> wli: if D/(e^D-1) made sense on types, then I'd have a type interpretation for -1/12 and I'd be very happy
12:08:37 <dpiponi> oerjan: among other things
12:09:01 <dpiponi> oerjan: John Baez has been looking for a categorical interpretation and I think that would give a type interpretation
12:10:25 <dpiponi> oerjan: 1+2+3+... is a completely reasonable type. So is there some way of looking at it that means -1/12?
12:10:52 <vincenz> dpiponi: 1+2+3 = 6
12:11:12 <vincenz> data 6 = 1 | 2 | 3 | 4 | 5 | 6
12:11:17 <vincenz> so 1+2+3.... = N
12:11:18 <wli> \sum_n n*r^n = 1/(1-r)^2
12:11:34 <vincenz> or I'm missing something?
12:11:40 <dpiponi> vincenz: If you haven't come across it, there's a 'trick' for summing 1+2+3+4+... and getting -1/12. It actually has meaning in the context of physics...
12:11:41 <wli> Take the limit as r -> 1- and so much for Abel summation.
12:11:49 <vincenz> o.O
12:12:25 <dpiponi> vincenz: Similar tricks make sense in the context of types so it's not all that crazy!
12:12:29 <wli> There are summation processes that will give you weird answers like that.
12:12:47 <dpiponi> wli: Borel summation. Guess who wrote the wikipedia entry :-)
12:13:04 <vincenz> dpiponi: any good book treating all this stuff?
12:14:15 <dpiponi> vincenz: Not really. These is all kinda folk theorem stuff. You'll find 1+2+3+4+...=-1/12 in String Theory books. Or in John Baez's "This Weeks Finds"
12:14:35 <vincenz> dpiponi: alright, thanks.  What about just discrete mathematics?
12:14:48 * vincenz has some books on category theory, but nothing on discrete mathematics
12:14:59 <dpiponi> vincenz: Try reading up on generating functions
12:15:27 <dpiponi> vincenz: There's generatingfunctionology by Wilf. Has great stuff in it but I think it overcomplicates some stuff.
12:15:43 <vincenz> dpiponi: I meant more in the sense of the differential operators and such on discrete numbers (like for instance typeS)
12:16:09 <wli> I'm a big fan of generatingfunctionology and actually think it skimps on too much.
12:16:12 <dpiponi> vincenz: If you read about generating functions every page will scream 'types' at you. And differential operators play a big part.
12:16:19 <vincenz> dpiponi: ah alright :)
12:17:04 <dpiponi> vincenz: The correspondence between types and generating functions isn't exact. In some ways that makes it more interesting.
12:18:03 <wli> dpiponi: x^n/n! seems to say something; could \binom{x}{n} mean something?
12:18:05 <dpiponi> vincenz: skim the beginning of http://www.math.upenn.edu/~wilf/gfologyLinked2.pdf
12:18:20 <byorgey> vincenz: Knuth et al. "Concrete Mathematics" has some good stuff on generating functions, and some stuff on differential operators in the chapter on hypergeometrics
12:18:31 * vincenz nods
12:18:41 * vincenz was just trying to get a strong foundation in discrete mathematics in general :)
12:19:30 <byorgey> vincenz: well, then read all of "Concrete Mathematics" =)
12:19:47 <vincenz> byorgey: ok, thanks for the tip :)
12:20:13 <wli> A lot of discrete math is passing back and forth between the discrete and continuous domains.
12:20:31 <dpiponi> vincenz: Concrete mathematics is quite good. It does have a particular direction it focuses on so it's not a general purpose discrete math course.
12:20:32 <vincenz> My reading stack can be classified as:
12:20:40 <vincenz> data Read book = Read book (Read book)
12:20:56 <vincenz> notice the absence of a bottom
12:21:09 <Japsu> :D
12:21:33 <vincenz> dpiponi: hmm, I see.  Anything more generic, like a good undergrad/grad foundational book
12:22:02 <oerjan> vincenz: very productive codata, there
12:22:18 <dpiponi> vincenz: Unfortunately, mathematicians do discrete math but it's spread over many courses: mainly group theory
12:22:30 <vincenz> oerjan: anything starting with the letters 'co' is not yet in that stack :/
12:23:29 <DRMacIver> I had to work really hard to not play smug functional programmer earlier. :)
12:24:00 <DRMacIver> I was helping a colleague out with a problem, and he kept running into difficulties fixing it because of accidental side effects in methods he was calling.
12:24:20 <byorgey> hehe
12:24:38 <wli> x*x is a product, so x + x is a coproduct, and so x^k/n : k!=qn yields qx^n/n!, which seems to be the q-fold coproduct of unordered n-tuples of x, provided that cancellation laws hold for numerators and denominators.
12:24:45 <byorgey> DRMacIver: I have that problem a lot, too.
12:24:58 <DRMacIver> (This was particularly offensive because the method had a name which suggested it was referentially transparent)
12:25:05 <DRMacIver> byorgey: Mutable state or not being smug? :)
12:25:14 <byorgey> DRMacIver: both
12:25:17 <vincenz> DRMacIver: you mean it didn't start with "unsafeXXX"
12:25:38 * dpiponi ends tea break
12:25:44 <vincenz> dpiponi: take care
12:25:55 <wli> You can try to _define_ cancellation that way, but I don't think that works.
12:25:56 <Syzygy-> ciao dp
12:25:59 <byorgey> vincenz: hm, that's a good idea!  From now on I will just name all methods in my code at work starting with "unsafe"
12:26:35 <DRMacIver> vincenz: Right. :) (No, it was called getFoo for some value of Foo)
12:26:48 <byorgey> ugh.
12:27:38 <vincenz> byorgey: what language?
12:27:48 <byorgey> vincenz: Java
12:27:55 <wli> Cancellation works when it's complete, e.g. n!-fold coproducts of x^n/n!
12:28:05 <vincenz> byorgey: so 105% of the methods will start with unsafe?
12:28:15 <byorgey> vincenz: exactly.
12:28:30 <byorgey> vincenz: maintaining lots of poorly written Java, no less
12:28:35 <vincenz> yay for tab-complete in eclipse :P
12:28:35 <wli> vincenz: What exactly does the derivative of a type represent again?
12:28:37 <esap> 105%? does that mean some methods have 'unsafe' twice? :-)
12:28:41 <Excedrin> if you translate math to ascii, do people sometimes use things like P^m to mean probability of m?
12:28:41 <vincenz> wli: the context
12:28:45 <byorgey> vincenz: well, yes, that is nice =)
12:28:46 <vincenz> wli: a zipper
12:28:56 <wli> vincenz: Sounds like I've got reading to do.
12:28:57 <vincenz> byorgey: I mean...with all methosd starting with unsafe
12:29:03 <vincenz> wli: read my blog :)
12:29:06 <oerjan> wasn't there a function starting with "reallyUnsafe"?
12:29:09 <byorgey> vincenz: oh, haha =)
12:29:10 <vincenz> wli: http://notvincenz.blogspot.com/2007/07/higher-order-zippers.html
12:29:11 <esap> unsafeGetUnsafeXCoordinate()
12:29:12 <lambdabot> Title: lambda.oasis: Higher Order Zippers
12:29:24 <DRMacIver> @hoogle reallyUnsafe
12:29:25 <lambdabot> No matches found
12:29:33 <byorgey> Excedrin: I've never seen that, but maybe
12:29:41 <DRMacIver> oerjan: APparently not. :)
12:30:00 <dolio> oerjan: reallyUnsafePointerEq
12:30:05 <oerjan> Excedrin: P(m) is what i learned, iirc
12:30:16 <Excedrin> ok, thanks
12:30:46 <dolio> Oh, I guess it's '...PtrEquality#'
12:31:23 <bringert> shapr: seen this: http://hope.bringert.net/entry/23 ?
12:31:28 <oerjan> DRMacIver: it's just so unsafe hoogle doesn't dare to show it
12:33:10 <DRMacIver> Hm. Actually a lot of the unsafe functions don't show up on hoogle, do they?
12:33:13 <DRMacIver> @hoogle unsafePerformIO
12:33:13 <lambdabot> Foreign.unsafePerformIO :: IO a -> a
12:33:21 <DRMacIver> @hoogle unsafeCoerce
12:33:22 <lambdabot> No matches found
12:33:38 <wli> vinenz: Wow, that's awesome.
12:33:49 <dolio> DRMacIver: many of them are in modules that hoogle doesn't index.
12:33:51 <dolio> GHC.*
12:34:32 <bringert> shapr: I'm telling you since you're the only user (that I know about anyway)
12:34:44 <dolio> vincenz: Almost done implementing delimited continuations? :)
12:34:57 <wli> Hmm, if I want polymorphic Gaussian elimination (or anything else) I appear to have to write it myself.
12:35:43 <vincenz> dolio: been busy :)
12:35:55 <vincenz> dolio: but good point
12:36:13 <vincenz> dolio: though now that I have second-order zippers... I want to play with them a bt longer, to see if a DC will automatically fall out of the fold
12:37:02 <DRMacIver> dolio: Ah
12:37:04 <dolio> Yeah, I was curious if you could combine Oleg's generic zippers with your second order zipper.
12:37:19 <kosmikus> pjd: you discover my papers? :) what are you discovering?
12:37:44 <vincenz> dolio: I'll think about it tonight
12:37:46 <vincenz> that being said
12:37:49 <vincenz> it's 11pm and I need food
12:37:56 <vincenz> cya tomorrow (no internet at app )
12:38:06 <dolio> Although, I'm not sure Oleg's generic zippers have quite all the functionality of a specific zipper.
12:38:11 <dolio> You can't go backwards, I think.
12:38:15 <dolio> All right. Later.
12:38:22 <pjd> kosmikus: oh, hello :)
12:38:25 <vincenz> going backwards = tough in the presence of side-effects
12:38:28 <pjd> "A Principled Approach to Version Control"
12:39:31 <DRMacIver> Also tough in the absence of eyes on the back of your head.
12:39:34 <kosmikus> pjd: ah, that's a bit of a sad story.
12:39:41 <mrd> vincenz: simple in the presence of a time-machine!
12:40:24 <vincenz> mrd: good point
12:40:30 <vincenz> and I say that non-humourously
12:40:40 <vincenz> o.O
12:40:41 <vincenz> woah
12:40:45 <vincenz> I have to get home and think in this
12:41:13 <DRMacIver> Let us know yesterday how it goes. :)
12:41:16 <vincenz> there might be a way to get a time-machine
12:41:19 <vincenz> no seriously
12:41:26 <vincenz> just delay all the stuff until you get to the present
12:41:36 <pjd> kosmikus: how so?
12:41:45 <vincenz> when you're guaranteed you can no longer go to the past
12:42:02 <mrd> ie. don't do anything ever (my solution)
12:42:04 <vincenz> or said otherwise, transform your stream until you get something that does not go into the past
12:43:45 <mrd> on the plus side, requiring time-machines for Haskell I/O will make understanding category theory and monads seem trivial by comparison
12:43:46 <kosmikus> pjd: oh, it was rejected badly from the conference we submitted it to, and that somewhat discouraged us, so we stopped working on it again.
12:44:16 <Heffalump> what did they say?
12:44:22 <pjd> bummer :/
12:44:36 <oerjan> i would strongly advise against this, as it will ultimately end up with someone causing Haskell never to have been invented.
12:44:39 <kosmikus> well, I'm not sure it's good to discuss this in public
12:44:47 <kosmikus> but it got very bad reviews
12:45:02 <mrd> oerjan: perhaps Haskell will become its own creator?
12:45:42 <oerjan> At least this should be delayed until the type system can guarantee the safety of the procedure.
12:45:57 <mrd> at the very least, recursive types
12:46:10 <kosmikus> Heffalump, pjd: the funny thing is that most Haskell people who've read it seem to like it, whereas people more of an SCM background seem not to like it at all. but it is an SCM paper, not an FP paper.
12:46:22 <kosmikus> Heffalump, pjd: as a consequence, I don't really know what to do with it.
12:47:41 <Heffalump> kosmikus: hmm, I vaguely recall not liking it very much either when I read it, but I have a memory like a sieve so I'm just reading it again to try to remember why.
12:47:43 <oerjan> mrd: i think that might actually require anti-recursive types.
12:48:03 <kosmikus> Heffalump: yes, you didn't like it much. you're an exception ;)
12:48:12 <mrd> {-# OPTIONS -fblow-your-mind #-}
12:48:12 <Heffalump> most SCM people don't really get darcs either, IME, so it doesn't surprise me much that they wouldn't like your paper either
12:48:29 <wli> I'm kind of surprised no one's written Gaussian elimination for integral types yet.
12:48:39 <kosmikus> Heffalump: we got relatively positive feedback when Wouter talked about it at Fun in the Afternoon though
12:48:59 <Heffalump> did Igloo look at it?
12:49:06 <oerjan> mrd: isn't that already on by default?
12:49:12 <Heffalump> (or anyone else who's spent a lot of time looking at darcs conflicts stuff)
12:49:29 <kosmikus> it's not really supposed to solve darcs conflicts
12:49:59 <Heffalump> no, but thinking about those gives one a unique perspective on the difficult problems of SCM
12:50:05 <kosmikus> Igloo has listened to the talk, and I remember he was a bit sceptical as to the practicability of the approach, but liked it in principle
12:51:20 <kosmikus> Heffalump: I know lots of things that are wrong with the paper, btw. So I certainly don't think it's perfect in its current form. But somehow I have the feeling that even if we'd rewrite it, it would get rejected again.
12:51:20 <pjd> kosmikus: some time ago i was working on some ideas for a version control system, and what hooks me is that i became convinced that patches must be associated with an extent, in addition to their contents
12:51:36 <shapr> bringert: Wow, that's cool! I was just wishing for such a thing yesterday!
12:51:55 <Heffalump> pjd: what's an extent?
12:52:01 <bringert> shapr: now you can fulfill your lifelong dream of builing a youtube clone.
12:52:12 <shapr> bringert: If only I had the bandwidth :-)
12:52:12 <wli> pjd: IMHO the killer is semantic information.
12:52:21 <pjd> Heffalump: same as the paper's extension, if i'm not mistaken
12:52:40 <pjd> wli: which kind?
12:52:58 <wli> pjd: suppose you commute patches... you can require the diffs not clash, and that the result compiles, but you can't figure out whether things will run.
12:53:07 <bringert> shapr: dreamhost gives me 2 TB / month. and flv video is surprisingly compact
12:53:34 <kosmikus> wli: the point the paper tries to make is that you are relatively flexible in how you define the concept of "diff".
12:53:37 <pjd> wli: the extent idea is part of the solution to that
12:54:01 <shapr> bringert: Does hope include support for {mov,wmv} -> flv ?
12:54:03 <kosmikus> wli: you can encode much more in a diff than just textual difference
12:54:09 <Heffalump> ah, right
12:54:11 <pjd> it represents the "impact" of the patch, beyond just the actual diff
12:54:37 <wli> But is what you need to know representible?
12:54:44 <pjd> so it's sort of like taking the usual fuzzy n-lines boundary of contextual patches, and making it explicit
12:55:09 <kosmikus> wli: maybe not everything. but certainly a lot more than current vc systems do track.
12:55:15 <wli> pjd: How about patches as operators on syntax trees?
12:55:18 <Heffalump> from a quick scan, I can't figure out if your model supports cherry-picking and the like.
12:55:25 <pjd> wli: same thing, different medium
12:55:33 <bringert> shapr: whatever ffmpeg supports. I call it in an external process.
12:55:55 <kosmikus> Heffalump: there's no reason why it wouldn't.
12:56:03 <wli> pjd: Hmm... I'm not so sure. Once you've got the syntax analyzed you can start playing with semantics.
12:56:09 <bringert> shapr: I've ony tried the avi that my Ixus produces, but I think ffmpeg supports lots of formats
12:56:30 <Nopik> monads do define >>= and return, right? so in do .... return ... is return some key word or just call to the monad 'lift' function?
12:56:33 <pjd> wli: well, it's not the VCS's job to do anything semantic
12:56:41 <pjd> it just works with whatever you specify
12:56:46 <kosmikus> the problem with the paper is that the choice of representation (as sets) is somewhat ad-hoc
12:57:04 <oerjan> Nopik: just a call
12:57:23 <Nopik> oerjan: thanks.. it just struck me.. yeah, this explains a little :)
12:57:25 <kosmikus> we're not consequent. on the one side we don't want to talk about a concrete implementation, on the other hand the implementation is chosen such that there's a chance to implement it.
12:57:42 <swiert> kosmikus: I had some ideas about how to fix that...
12:57:53 <kosmikus> but it also poses somewhat vague restrictions on what you can express, and it's not clear if the restrictions imposed by the representation are reasonable.
12:57:57 <wli> pjd: Maybe VCS is the wrong way to go about it.
12:57:58 <kosmikus> swiert: I know.
12:58:09 <kosmikus> swiert: you told me once.
12:58:13 <Heffalump> ok. So I think my problem is that you don't really either pose or solve any interesting problems.
12:58:18 <Heffalump> s/problem/issue/
12:58:39 <Heffalump> the idea of an extension is interesting though
12:58:48 <swiert> Heffalump: That's a bit harsh.
12:59:00 <swiert> We can give precise conditions under which patches commute, for instance.
12:59:01 <kosmikus> I think the idea was to give a formal foundation for a system of which darcs would be an instance.
12:59:15 <swiert> Or describe when patches conflict.
12:59:34 <kosmikus> darcs doesn't really have a formal foundation even though it pretends to.
12:59:36 <bringert> shapr: updated http://hope.bringert.net/entry/23 with a caveat
13:00:25 <Heffalump> swiert: are your conditions that both compositions exist?
13:00:34 <swiert> Heffalump: yes.
13:00:37 <Heffalump> (sorry, just jumping around at the moment rather than reading it through)
13:01:14 <Heffalump> but you explicitly don't consider changing representations, right, even though your patches are quite concrete in the sense of applying to specific things?
13:01:15 <shapr> bringert: A totally free flv player should be easy to write with haXe.
13:02:18 <kosmikus> Heffalump: you shouldn't need to change representations.
13:02:29 <DRMacIver> I was going to comment on how popular the "Haskell faster than C" thread on redit was, but iI see it's just some troll. :)
13:02:45 <kowey> (this is not a complaint or anything, but maybe the #revctrl people might be interested in this discussion, dunno if it's 'safe' to have it there, though)
13:02:55 <shapr> bringert: I wrote 'my own' crappy flash mp3 player with haXe, it was pretty simple.
13:03:02 <Heffalump> kosmikus: why not? It's not just an efficiency thing, it's actually a semantic issue (IMO)
13:03:20 <Heffalump> kowey: based on past experience, I'd rather have it here :-)
13:03:28 <kowey> heh :-)
13:03:41 <wli> pjd: Maybe the source should be represented at a database of syntactic constructs, then a patch can refer to object ID's for the syntax subtrees to be made into holes to be filled with replacements, along with their replacements.
13:03:47 <kosmikus> Heffalump: you'd only need to change representation if you add new patch types.
13:03:50 <kowey> actually, that's not a knowing smile, but i'll just imagine
13:04:00 <kosmikus> Heffalump: I agree this would be desirable, but darcs certainly can't do it either.
13:04:01 <Heffalump> I think Haskell people can bring an approach to bear on this problem that really could help solve it properly, that that crowd wouldn't appreciate unless we could present it as a finished thing.
13:04:15 <Heffalump> kosmikus: I don't follow. Don't you have renames and things?
13:04:32 <Heffalump> ah, no.
13:04:35 <kosmikus> yes, but why would that require changing the representation?
13:04:38 <pjd> wli: right, but i think the concrete representation is orthogonal to the issues of changes, conflicts, merging and so on
13:04:44 <Heffalump> oh, no you do
13:04:51 <Heffalump> s/no/yes/
13:05:28 <Heffalump> errm, because a change before the rename is different to a change after the rename
13:05:41 <kosmikus> swiert, could you fill in for me? I find this discussion really interesting, so I don't want it to die, but I actually have to pack boxes for my move ...
13:05:54 <kosmikus> so I can have a look at it every few minutes, but I can't really type all the time ;)
13:06:03 <swiert> kosmikus: No problem.
13:06:16 <Heffalump> heh, it's not ideal for me either, but perhaps if we delay it we'll never have it..
13:06:54 <kosmikus> :)
13:07:45 <pjd> swiert: i'm still working into the paper, but do you discuss handling merging?
13:08:45 <swiert> pjd: as in merging of branches?
13:08:49 <Heffalump> oh, wait, I see, you handle renaming by giving files unique IDs
13:08:56 <pjd> yes
13:08:56 <Heffalump> ok, so my argument doesn't work in your calculus.
13:09:12 <wli> pjd: There are reasons why you do such things. Instead of just detecting renames, you can detect other sorts of transformations, such as eta reduction or common subexpression elimination via let.
13:09:16 <Heffalump> But it's essential for darcs to work sanely, because even if you give files unique IDs, you can't do that to each fragment of a file.
13:09:39 <kosmikus> Heffalump: yes, exactly my point. and yes, we also give unique IDs to lines ...
13:09:51 <swiert> pjd: We don't really deal with that explicitly, but avoid the problem entirely in the same way darcs does.
13:09:53 <pjd> wli: right, but that's a function of creating the patch, not managing it
13:10:06 <Heffalump> and then how would you handle token replace?
13:10:18 <pjd> i'm a strong disbeliever in token replace :)
13:10:24 <pjd> swiert: darcs does cherry-picking and such, doesn't it?
13:10:42 <pjd> maybe "branch merge" is a bit vague
13:11:00 <Heffalump> swiert: I dispute that claim, because without doing commutation as darcs does, you really are completely side-stepping the problem. Darcs doesn't actually avoid it, since it does have to do some work to merge.
13:11:03 <pjd> in darcs terminology, it might be repository merging
13:11:06 <wli> pjd: Only by convention.
13:11:10 <pjd> basically, what happens when you push/pull
13:12:04 <swiert> pjd: "that's applying a patch" in our terminology.
13:12:10 <Heffalump> kosmikus: darcs might get single line edits too in the future. Those are completely describable in darcs as it stands without extensions to the framework, I believe.
13:12:19 <swiert> pjd: we describe when that can be done and when conflicts might happen.
13:12:20 <Heffalump> (single line edit = editing the characters on a line)
13:12:53 <swiert> Heffalump: "commutation as darcs does" - as in commuting patches changes the patches themselves?
13:13:01 <Heffalump> swiert: yes
13:13:23 <shapr> bringert: http://code.google.com/p/flivpee/
13:13:24 <lambdabot> Title: flivpee - Google Code
13:13:43 <swiert> Heffalump: Sure. My point is that we don't deal with explicit branches a la CVS, subversion, etc.
13:14:04 <pjd> i ask because the idea i was working on was to use the C3 merge algorithm as an alternative to commutation
13:14:25 <Heffalump> ok, fair enough
13:14:56 <bringert> shapr: the online demo doesn't seem to work in Safari
13:15:07 <pjd> (the "C3" algorithm being the one coined by Dylan, to merge inheritance hierarchies)
13:15:28 <bringert> shapr: oh it does, just a weird UI
13:15:31 <swiert> pjd: In the context of darcs?
13:15:34 <wli> pjd: You can do a lot more commutations when you understand the patches as program transformations. You can try to figure out how to commute a common subexpression elimination with a beta reduction instead of screwing with strings and text.
13:15:56 <pjd> swiert: not as such
13:16:39 <wli> pjd: So the representation matters a lot.
13:16:57 <JohnMeacham> mrfl
13:17:03 <swiert> pjd: I don't know much about the C3 merge algorithm.
13:17:33 <swiert> pjd: I think I may have seen an e-mail by Dylan (Thurston?) at some point, but I've forgotten any technical contents.
13:17:35 <pjd> swiert: if you're interested, http://www.webcom.com/haahr/dylan/linearization-oopsla96.html is very readable
13:17:36 <lambdabot> Title: A Monotonic Superclass Linearization for Dylan
13:18:01 <swiert> Ah. Wrong Dylan.
13:19:03 <pjd> the core idea is very simple: basically, merging a set of partial orders into a consistent linear result
13:20:04 <scs> Hmm... anyone here use HOpenGL on FreeBSD?
13:20:39 <scs> Programs compile correctly, but the window is blank, no background or nothing.. just the window managers border.. etc.
13:21:08 <mrd> might be a screen update issue
13:21:24 <scs> I've tried different WM's as well.
13:21:33 <swiert>  pjd: I'm not sure if posets where exactly the right intuition for repositories.
13:21:43 <scs> And example code from certain places to make sure it wasn't my code.
13:21:43 <swiert> *were
13:21:46 <mrd> no i mean, you're forgetting to refresh the screen
13:21:52 <scs> I know what you mean.
13:21:56 <Heffalump> pjd: so what do you do when there is no linearization?
13:22:04 <mrd> i wish i could remember better. i've seen similar issues.
13:22:14 <kosmikus> Heffalump: single line edits are something like "replace the 4th character on line 7 which currently is a 'c' by an 'A'" ?
13:22:14 <scs> But certain examples should work fine
13:22:17 <Heffalump> in Dylan, they just give up.
13:22:20 <Heffalump> kosmikus: yes.
13:22:31 <pjd> Heffalump: require the creation of a patch that resolves the conflict
13:22:42 <kosmikus> Heffalump: then it would probably be possible to add to our system without an additional representation change as well.
13:22:52 <Heffalump> kosmikus: by adding IDs to each character?
13:22:53 <bringert> shapr: I also found http://flowplayer.sourceforge.net/ and http://code.google.com/p/flvplayer/
13:22:54 <lambdabot> Title: Home of FlowPlayer, the free Flash video player for the Web
13:22:54 <Igloo> My main memory of the Fun talk is that it wasn't obvious to me that you could necessarily implement your approach in a way that doesn't blow up (time-wise) for some uses
13:22:59 <kosmikus> Heffalump: because if lines have unique IDs, positions in lines trivially have unique IDs as well.
13:23:02 <Igloo> Which is exactly the problem darcs has
13:23:22 <Heffalump> kosmikus: oh, it also includes "delete one character at position 7 and insert two instead"
13:23:25 <pjd> swiert: neither am i, but that's why i want to see how far it goes :)
13:23:27 <Heffalump> so you need to ID each character
13:23:40 <kosmikus> Heffalump: ok, so that's more of a problem and would require a representation change
13:23:43 <swiert> Igloo: You're right. We need to experiment more with a toy implementation.
13:23:49 <Heffalump> anyway, I think token replace complicates things yet mote.
13:23:53 <Heffalump> s/mote/more/
13:24:07 <kosmikus> Igloo: one of the plans we had was to implement the approach
13:24:14 <Igloo> swiert: Is it actually provably exponential in the worst case?
13:24:23 <swiert> pjd: For example, a patch can occur more than once in a repository.
13:24:28 <Heffalump> pjd: so where do you get the ordering of direct superclasses from?
13:24:42 <Igloo> Or NP complete, or whatever I mean
13:24:43 <fasta> What problem are you trying to solve?
13:24:53 <swiert> Igloo: Quite possibly.
13:24:59 <fasta> (besides "SCM")
13:25:13 <kosmikus> Heffalump: I think there was a way to solve token replace if you absolutely want it, but it's too long ago. I'd have to reread the paper myself.
13:25:18 <fasta> Or even "distributed SCM"
13:25:31 <Igloo> fasta: distributed SCM
13:25:39 <fasta> Igloo: ^^
13:25:43 <pjd> Heffalump: most basically from patch overlap (that is, the "footprint" of a patch specifies which previous patches it depends on)
13:25:54 <fasta> Igloo: that's way too vague to discuss, imho.
13:26:23 <Heffalump> ok, I think what would make me most interested in your approach, is if you could define a formal model with unique IDs all over the place and the like, and no representation changes, and then refine it into something more efficient.
13:26:32 <fasta> Unless you specify further what kinds of things this SCM should do there is no basis to discuss an implementation.
13:26:43 <Heffalump> pjd: ok, but how do you define the order those patches should be listed in?
13:26:57 <fasta> (Or even a "theory")
13:27:17 <Heffalump> fasta: the main core of the discussion is kosmikus and swiert (and Daan Leijen)'s draft paper on the subject.
13:27:32 <Heffalump> As a sideline, I'm also discussing an alternate approach to commutation with pjd.
13:27:34 <kosmikus> Heffalump: I agree that would be interesting.
13:27:40 <pjd> Heffalump: recursively, more or less
13:27:45 <bringert> shapr: here's another one: http://sourceforge.net/projects/webflv
13:27:46 <lambdabot> Title: SourceForge.net: FLV Video Player with Web UI
13:28:26 <Heffalump> pjd: no, that's how linearization uses the local ordering. I want to know how to define the local ordering.
13:28:29 <bringert> shapr: I won't have time to play with these for a while, but in the long run, Hope should use a free player
13:28:40 <fasta> I don't know, but it seems unlikely that two people working on it for a few months completely solve the problem.
13:28:57 <Heffalump> fasta: who are you referring to?
13:29:16 <Heffalump> I don't think anyone was claiming that kosmikus et al have solved it. But research proceeds in small steps.
13:29:24 <fasta> Heffalump: any two people(in this case swiert and Daan)
13:29:33 <pjd> Heffalump: no, i mean each patch only specifies the ordering it requires
13:29:46 <kosmikus> fasta: as Heffalump said, no one has claimed to have solved it completely
13:29:48 <Heffalump> pjd: ok, but how does it pick it?
13:30:27 <pjd> most basically, by footprint
13:30:35 <pjd> wait, i think i see what you mean
13:30:38 <Heffalump> kosmikus: I guess my other question is whether your formalisation actually does allow a reasonable set of things to commute.
13:30:49 <swiert> Heffalump: I'd expect so.
13:31:05 <swiert> Being able to compose both ways corresponds exactly to being "independent"
13:31:21 <pjd> in Dylan, the local ordering is always a flat linear list, but yes, that imposes more ordering than you might want in a patch context
13:31:29 <Excedrin> I'm not good at Math, does the image of math notation here match the code? http://hpaste.org/1607
13:31:53 <dylan> Aaah! stop talking about my local ordering!
13:32:05 <newsham> anyone doing icfp contest this year?
13:32:17 <Heffalump> ok. I take it back, I like your paper :-)
13:32:18 <pjd> so what i had in mind is a slight generalization of a list of sets, as the local ordering
13:32:28 <pjd> "the slight", even
13:32:39 <kosmikus> dylan: you're not ordered locally? ;)
13:32:46 <kosmikus> newsham: yes, me :)
13:32:55 <Igloo> kosmikus: lol
13:32:58 <dylan> kosmikus: No, I'm randomly ordered.
13:33:00 <Heffalump> s/doing/competing in/ ;-)
13:33:16 <pjd> it's a simple modification to the C3 algorithm, as implemented in Dylan
13:33:20 <Heffalump> I'm still trying to work out if I can afford the time :-(
13:33:49 <Heffalump> pjd: also, what do you do with the linearization once you have it?
13:34:05 <pjd> apply the patches in that order :)
13:34:25 <Heffalump> ok, so how do you ensure that they actually make sense in that order?
13:34:52 <kosmikus> if someone here has a /. account and would like to post about the icfp contest, we'd really appreciate it, btw. we tried to submit a message ourselves and had it rejected.
13:35:09 <Excedrin> could any math wiz take a look at my paste please?
13:35:13 <Igloo> kosmikus: Was there a rejection reason?
13:35:17 <kosmikus> Igloo: no
13:35:27 <Igloo> Odd. It's been on before a number of times IIRC
13:35:35 <pjd> Heffalump: a combination of C3's consistency itself, and forbidding overlapping extents
13:36:04 <Heffalump> pjd: ok, I don't understand what problem you are trying to solve here.
13:36:08 <kosmikus> Igloo: yes, I know. I was surprised myself.
13:36:14 <fasta> kosmikus: I think you need to submit it as OMG LOLZ PONY ICFP!!
13:36:31 <kosmikus> Igloo: but then again, I don't really understand how /. works. I don't have an account myself. I just read it.
13:36:38 <kosmikus> fasta: lol
13:36:51 <newsham> kosmikus: what about digg?
13:37:08 <kosmikus> newsham: it's been on reddit and LtU
13:37:12 <Heffalump> Having an account may help.
13:37:25 <Heffalump> I could submit the same text as you did, if you like.
13:37:26 <pjd> Heffalump: it's more following an interesting idea than trying to solve a specific problem
13:37:27 <kosmikus> Heffalump: yes, sure, but I also didn't submit it myself.
13:37:28 <therp> kosmikus: I have an account..
13:38:25 <pjd> the main promise is to make commutation implicit, by not over-specifying the patch order
13:38:38 <sfultong> @pl x -> (x,x)
13:38:39 <lambdabot> (line 1, column 3):
13:38:39 <lambdabot> unexpected ">" or "-"
13:38:39 <lambdabot> expecting variable, "(", operator or end of input
13:38:48 <sfultong> @pl (\x -> (x,x))
13:38:49 <lambdabot> join (,)
13:38:56 <Heffalump> you can't make commutation implicit without also not changing patch representations ever
13:39:04 <kosmikus> Heffalump, therp: I'm trying to get the text that was submitted from niksnut (Eelco Dolstra)
13:40:39 <pjd> Heffalump: you might not have to change patches directly, when you can modify and add to the patch sequence
13:40:45 <sfultong> @type join (,)
13:40:50 <lambdabot> forall a. a -> (a, a)
13:40:55 <Heffalump> how do you merge without changing patches?
13:41:00 <therp> the knot-tying operator for monads is scary.
13:41:07 <pjd> but that's getting ahead of myself
13:41:53 <sfultong> why does join work on monads, yet they disappear when join is composed with other things?
13:42:08 <Heffalump> yet what disappear?
13:42:21 <sfultong> the monad, I mean
13:42:27 <pjd> Heffalump: analogously to a subclass inserting a mixin between two parent classes, in the inheritance context
13:42:34 <oerjan> sfultong: because (,) is only in one monad
13:42:50 <Heffalump> pjd: hmm. Not convinced.
13:43:00 <oerjan> er, or is it?
13:43:07 <sfultong> I'm not used to functions being instances of monads
13:43:10 <pjd> Heffalump: right, needs more work
13:43:28 <oerjan> yes.
13:43:45 <oerjan> sfultong: it's in Control.Monad.Instances
13:43:51 <sfultong> ah, thanks
13:44:01 * Heffalump disappears for a bit
13:45:17 <ednarofi> JOIN #haskell
13:47:51 <sfultong> @pl (\x -> x + x)
13:47:51 <lambdabot> join (+)
13:48:33 <sfultong> (join (+)) 4
13:48:41 <sfultong> > (join (+)) 4
13:48:46 <lambdabot>  8
13:48:59 <sfultong> hmm, ghc 6.4 complains about this
13:49:26 <pastorn> @src join
13:49:26 <lambdabot> join x =  x >>= id
13:50:31 <oerjan> sfultong: have you loaded Control.Monad.Instances?  Or maybe 6.4 is too old for that?
13:50:37 <pastorn> howcome "rd = read :: Int" doesn't work but "rd x = (read x) :: Int" does?
13:51:14 <sfultong> oerjan: yeah, it doesn't seem to have it
13:51:20 <Syzygy-> pastorn: Because read isn't of type Int.
13:51:20 <Syzygy-> pastorn: Because read isn't of type IntIt's a function.
13:51:31 <Syzygy-> Gnnn.
13:51:37 <oerjan> pastorn: read :: String -> Int
13:51:42 <pastorn> oh, right...
13:51:50 * Syzygy- doesn't like having several seconds lag on his ssh session....
13:51:54 * pastorn feels sillyi
13:53:20 <fasta> [e1, e2] <- replicateM foobar -- it would be nice if this worked
13:53:54 <oerjan> :t replicateM
13:53:56 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
13:54:08 <fasta> Don't explain why this doesn't work, I know that already
13:54:27 <fasta> This is something that I would find _usefull_.
13:54:40 <fasta> useful*
13:55:37 <oerjan> it might be possible to do one of those type class list tricks
13:55:59 <fasta> It wouldn't be that difficult to add it to Haskell. One typeclass and a simple change to the parser.
13:56:07 <oerjan> (e1, (e2, ())) <- replicateM' foobar
13:56:54 <fasta> oerjan: hmm, that is an idea too, but the nesting is annoying.
13:57:16 <fasta> oerjan: in that same way one can do Two e1 e2 <- replicateM' foobar
13:57:21 <fasta> oerjan: etc.
13:57:55 <oerjan> e1:-e2::e3 <- replicateM' foobar
13:58:34 <fasta> oerjan: is that :- intentional?
13:58:45 <oerjan> need some way to detect the end
13:59:50 <oerjan> since it cannot know that e3 /= f:-g
14:00:10 <Saul_> I've hit a bit of a snag with my wiki project, can anyone help?
14:00:31 <oerjan> er, :: is not available
14:00:56 <Saul_> The problem is that I have these wikis of various types, like Wiki Integer Integer and Wiki String String
14:01:55 <Saul_> However when a user types in an url, it will be something like "pagetype:pagetitle"
14:02:17 <Saul_> How do I make a collection of these different Wikis in a generic way?
14:02:42 <desp> Saul_: you could use existential types, which are a bit of a pain
14:03:07 <desp> or maybe HList, I think
14:03:15 <Saul_> desp: Can you give me an example?
14:03:21 <desp> Wiki Integer Integer, though?
14:03:33 <desp> that sounds rather odd
14:03:47 <desp> http://haskell.org/hawiki/ExistentialTypes
14:03:47 <Saul_> Yeah that's not very useful, but that's just for testing
14:03:48 <lambdabot> Title: ExistentialTypes - The Haskell Wiki
14:04:36 <desp> there's more at your friendly google search results page
14:04:37 <desp> ;)
14:04:43 <Saul_> Wiki a b means that the wiki contains a's which can be diffed and patch with type b
14:04:55 <Saul_> s/patch/patched/
14:05:14 <desp> I thought wikis generally contain text
14:05:26 <Saul_> Well that's why I'm making this :)
14:05:46 <Saul_> Hoepfully you will be able to use any Haskell type
14:06:08 <Saul_> You already can actually, there is just not much of a frontend yet
14:07:35 <oerjan> @remember andrewcoppin Peano integers are like Church numerals, but less scary.
14:07:36 <lambdabot> Done.
14:07:38 <Saul_> desp: Thanks for your help, I'll read up on existential types and Hlists now
14:07:46 <desp> yw
14:07:47 <sfultong> @pl (\f x -> maybe [] (uncurry (:) . join . (id, f )) (f x)
14:07:48 <lambdabot> (line 1, column 56):
14:07:48 <lambdabot> unexpected end of input
14:07:48 <lambdabot> expecting variable, "(", operator or ")"
14:07:59 <sfultong> @pl (\f x -> maybe [] (uncurry (:) . join . (id, f )) (f x))
14:07:59 <lambdabot> (.) =<< maybe [] . ((uncurry (:) . join) .) . (,) id
14:08:02 <olsner> what's the difference between peano integers and church numerals?
14:08:35 <oerjan> church numerals are one particular implementation of peano integers
14:08:35 <olsner> peano = sets of sets, church = functions on functions?
14:12:45 <ednarofi> JOIN #haskell
14:15:01 <shapr> ednarofi: I think you already made it here.
14:17:55 <dancor> is 'The Lambda Shell' usable as an actual shell or just a tool for ppl doing crazy theoretical cs
14:18:04 <dancor> i still can't tell
14:18:27 <Syzygy-> shapr: Did you get around to reading?
14:19:26 <ednarofi> shapr: thanks. (I'm new to irc (and #haskell))
14:19:43 <shapr> Syzygy-: I got partway into it earlier today, but I didn't hit the Haskell chunk. I'll do it now.
14:20:36 <Syzygy-> Thanks!!
14:20:39 <shapr> Section 4, yeah?
14:21:06 <shapr> Do you want me to report spelling errors also?
14:21:11 <Syzygy-> Comments in a query - I'm not certain I will be awake for very much longer.
14:21:11 <Syzygy-> Comments in a query - I'm not certain I will be awake for very much loMost probably, yeah.
14:21:14 <Syzygy-> Cannot remember the numbering. LaTeX does all those things for me.
14:21:23 <Syzygy-> Sure, please do.
14:21:47 <Syzygy-> (it's so weird getting comments on these things with page number and line number. NO correlation to what it looks like in an editor)
14:22:16 <shapr> Well, if you had it in a darcs repo...
14:28:05 <Toxaris> anyone using eclipseFP for Haskell development?
14:28:54 <Toxaris> how to automatically recompile the application before "Run as Haskell Application" the resulting exe?
14:29:28 <monochrom> It's very hard. You must change the source code files to force a rebuild.
14:29:49 <Toxaris> that's what I'm doing atm
14:30:20 <monochrom> I have played with it but I don't use it for real due to these build limitations.
14:30:51 <Toxaris> I change SomeModule.hs, save, it compiles fine, I change Main.hs (space, backspace) save, and run the resulting executable
14:31:52 <fasta> Java has deep-copies built-in, right?
14:32:32 <oerjan> no touch command?
14:33:16 <monochrom> Some Java collection libraries have deep copy methods for explicit use.
14:33:38 * glguy often finds himself wishing that vim had a "drawer" where I could browse the files in the project directory
14:33:57 <ihope> I'm being haunted by some post somebody made some long time ago in some forum that said roughly, "Stay away from functional programming languages unless you want your head to explode, or have some strange obsession with artificial intelligence."
14:33:58 * glguy has trouble keeping in the third person
14:34:43 <Toxaris> ihope: head explosion once a week is good for cleaning up thought processes
14:34:45 * monochrom ate my lunch
14:34:46 <fasta> monochrom: ok, so I cannot create an arbitrary reference based structure and expect the copy method(IIRC) to exist?
14:35:00 <oerjan> glguy: have you tried :view on a directory?
14:35:06 <ihope> It makes me want to argue with someone about functional programming.
14:35:12 <monochrom> fasta: Right.
14:35:41 <julian_> Hi
14:35:41 <lispy> ihope: so you're saying they're a good troll? ;)
14:35:49 <fasta> monochrom: why is there so such functionality(I am of course interesting in Haskell support)?
14:35:59 <monochrom> ihope: you can try to post that to haskell-cafe and see how people answer it :)
14:35:59 <glguy> oerjan: I have
14:36:09 <fasta> monochrom: It doesn't seem like an incomputable function.
14:36:12 <julian_> I'm reading about Reader monad
14:36:23 <olsner> sounds like something people would say back when functional programming was synonymous to lisp
14:36:37 * fasta trolled #debian 
14:36:39 <glguy> oerjan: I like a text terminal based editor... I don't like the text base file listings though when I just want to browse
14:36:44 <fasta> I got compliments :)
14:36:52 <monochrom> fasta: I don't know.
14:36:58 <julian_> this example works well?
14:36:59 <ihope> lispy: well, the forum was actually completely unrelated to programming, and the person the advice was given to was completely new to programming, I think.
14:37:10 <julian_> eval (Var v) = asks (fromJust . lookup v)
14:37:10 <julian_> eval (Lambda v e) = do env <- ask; return $ \v' -> local (const (v,v'):env) (eval e)
14:37:10 <julian_> eval (App f x) = do env <- ask; f' <- eval f; f' (local (const env) (eval x))
14:37:22 <fasta> monochrom: to copy a tree based on 4 constructors it costed 13 lines.
14:37:29 <fasta> monochrom: that's not that bad, though.
14:37:34 <pjd> ihope: argh.  giving programming advice should require a license
14:37:36 <matthew-_> so what flags to ghc are known to break ffi stuff?
14:37:39 <sfultong> I wonder what it would be like to learn a functional language as your first language
14:37:43 <glguy> there is a stronger connection between lisp and functional programming, and even that isn't really a connect
14:37:46 <fasta> pjd: PHP is tha best!
14:37:50 <glguy> ion
14:37:55 <fasta> pjd: so much powder!
14:37:56 <glguy> errr
14:37:56 <monochrom> I do not know how many Java programmers want to copy ever.
14:37:58 <glguy> lisp and AI
14:38:41 <kosmikus> therp: ping
14:38:50 <glguy> I need to come up with a way that I can drop a file on an icon in windows
14:38:56 <glguy> and have it open in my vim terminal on linux :)
14:39:04 <glguy> (they both have access to the same files)
14:39:09 <sfultong> @pl (\x l -> map (\(a, b) -> (a - x, b)) l)
14:39:09 <lambdabot> map . (`ap` snd) . (. fst) . ((,) .) . subtract
14:39:21 <ihope> pjd: given all the rumors and legends floating around, people should need licenses to believe things.
14:39:56 <monochrom> People should need licenses, period.
14:40:16 <glguy> does anyone know of something like emacs-server/client for vim?
14:40:27 <ihope> I imagine somebody once said "You know, I imagine we only use about ten percent of our brains", and now I'm guessing at least ten percent of people believe it.
14:40:29 <monochrom> I don't think it exists for vim.
14:41:34 <monochrom> They only use 1% of their brains. They use their spinal cords much more.
14:41:35 <quicksilver> sjanssen: about?
14:41:41 <Cale> Heh, Azureus claims to be downloading this torrent at 980 KiB/s. My connection is only supposed to be about 1/3 as fast as that.
14:41:48 <sjanssen> quicksilver: yes
14:41:59 <glguy> Cale: sounds like you should call your ISP and complain :)
14:42:03 <glguy> I demand slower service!
14:42:04 <Cale> glguy: heh
14:42:06 <quicksilver> sjanssen: have been thinking about your withT
14:42:20 <fasta> Cale: I once downloaded something at 1TB/s, IIRC.
14:42:21 <quicksilver> sjanssen: the problem is, it modifies the callback
14:42:27 <fasta> Cale: or so Firefox claimed.
14:42:27 <monochrom> When someone says "recursion is slow" or "haskell is inefficient" or "no one uses unicode" you can be sure he/she is only using his/her spinal cord to write that. :)
14:42:38 <therp> kosmikus: pong
14:42:43 <Cale> I'll see what the average rate was when it finishes.
14:42:43 <quicksilver> sjanssen: it requires a polymoprhic callback and instantiates it to the type of its choice
14:42:59 <cjeris> monochrom: clearly the solution is to remove said spinal cord... SUB-ZERO WINS... FATALITY
14:43:01 <quicksilver> sjanssen: and, it requires co-operation from the 'callback-using-action'
14:43:11 <quicksilver> sjanssen: it requires that that action 'return' the output from the callback
14:43:29 <kosmikus> therp: the text that niksnut submitted to /. is here: http://hpaste.org/1608
14:43:52 <therp> kosmikus: this is already submitted?
14:44:02 <Cale> It really does appear to be going extremely fast.
14:44:15 <kosmikus> therp: yes, it was, but it was rejected according to niksnut
14:44:33 <monochrom> Cale is always boasting his fast connection. :)
14:44:45 <kosmikus> therp: would you consider submitting something similar again?
14:44:45 <Cale> yeah, but this is strange.
14:45:00 <sjanssen> quicksilver: right, that's the major obstacle
14:45:39 <Cale> monochrom: Usually I'd do that when I was in Waterloo, since I had a really good ISP there who was undercutting the major ISPs by a lot. :)
14:46:15 <therp> kosmikus: sure, I don't care about my /. karma at all. what would be a good subject? "Test your coding skills: ICFP07 Programming Contest"?
14:46:18 <RyanT5000> > elemIndex False $ map (fst . random . mkStdGen) [0..]
14:46:20 <lambdabot>  Just 53668
14:46:25 <RyanT5000> is there a reason for that?
14:47:00 <RyanT5000> i.e.: that the first 53668 StdGens all generate a True as their first Bool?
14:47:18 <quicksilver> sjanssen: that means the libhrary function can't call the callback more than once, ofr example
14:47:28 <RyanT5000> (in case it's relevant: 32 bit Ubuntu on Core 2 Duo)
14:47:28 <kosmikus> therp: feel free to choose anything you like. what you suggest seems fine
14:47:38 <quicksilver> sjanssen: (well, not and have the monad threaded correctly)
14:47:51 <monochrom> therp, kosmikus: "put your code where your mouth is"
14:47:59 <kosmikus> therp: also, if you want to change the text or write something different, that's absolutely fine -- well, as long as you write something positive :)
14:49:19 <therp> kosmikus: done
14:49:33 <RyanT5000> who's in charge of System.Random?
14:49:44 <RyanT5000> and where's the bug tracking system for that?
14:49:58 <RyanT5000> (i've never submitted a Haskell bug before, i'm happy to say)
14:50:13 <pjd> glguy: :h clientserver
14:51:29 <Toxaris> I need a general memoization function, have read "Stretching the storage manager: ..." (SPJ & Co) and "Memo functions, polytypically" (Hinze) and am not sure how to proceed now. Is there some library building on top of one of these ideas? or some standard idiom I could build upon?
14:51:40 <glguy> pjd: beautiful :)
14:52:10 <kosmikus> therp: thanks a lot
14:54:47 <matthew-_> wow, -O2 and -fvia-C seem not to play nice
14:54:48 <therp> hm, I'm not going to understand why this knot-tying combinator does not work...
14:54:57 <therp> good night, everyone.
14:55:36 <RyanT5000> > map length $ group $ (map (fst . random . mkStdGen) [0..] :: [Bool])
14:55:46 <quicksilver> sjanssen: so, I'm tidying up my version
14:55:46 <lambdabot> Terminated
14:55:56 <RyanT5000> > take 100 $ map length $ group $ (map (fst . random . mkStdGen) [0..] :: [Bool])
14:56:00 <lambdabot> Terminated
14:56:06 <RyanT5000> > take 20 $ map length $ group $ (map (fst . random . mkStdGen) [0..] :: [Bool])
14:56:10 <lambdabot>  [53668,53668,53668,53669,53668,53668,53669,53668,53668,53669,53668,53668,536...
14:56:19 <RyanT5000> does that look wrong to anyone else???
14:56:38 <Heffalump> @type mkStdGen
14:56:40 <lambdabot> Int -> StdGen
14:56:46 <monochrom> That is bad.
14:56:59 <Heffalump> @type random
14:57:00 <quicksilver> sjanssen: anyhow I'm writing it up, I'll post to -cafe when I've tidied it
14:57:01 <lambdabot> forall g a. (Random a, RandomGen g) => g -> (a, g)
14:57:27 <sjanssen> quicksilver: yes, I'd like to see some discussion on -cafe about it
14:57:41 <sjanssen> quicksilver: Oleg might come along and tell us how to do it right :)
14:57:43 <RyanT5000> so it seems that the bools alternate every [53668, 53668, 53668, 53669]
14:57:57 <quicksilver> sjanssen: I've got instances for reader, writer and state Ts, so far
14:58:07 <Heffalump> that does seem odd.
14:58:12 <quicksilver> sjanssen: I think I have a meaningul one for MaybeT
14:58:28 <quicksilver> sjanssen: and I think that's the best I can do. listT and ContT are out.
14:59:20 <RyanT5000> where could i find the code for mkStdGen?
14:59:43 <sfultong> @src mkStdGen
14:59:43 <lambdabot> Source not found. Just what do you think you're doing Dave?
15:00:02 <Toxaris> http://darcs.haskell.org/ghc-6.6/packages/base/System/Random.hs
15:02:20 <quicksilver> oh that's odd. There isn't a MaybeT
15:03:10 <oerjan> RyanT5000: i am not sure that's really bad.
15:03:37 <Toxaris> > take 20 $ map length $ group $ (randoms $ mkStdGen 0 :: [Bool])
15:03:38 <lambdabot>  [3,2,4,1,1,4,1,1,2,4,1,1,1,1,2,1,1,1,1,5]
15:04:02 <RyanT5000> the first output of a random number generator should not be strongly correlated with its seed
15:04:05 <RyanT5000> (imho)
15:04:10 <oerjan> it just means that the initial seed should be chosen randomly
15:04:29 <oerjan> er...
15:04:38 <RyanT5000> at least, if it is, it should be documented
15:04:39 <oerjan> yeah, that did sound wrong :)
15:05:05 <RyanT5000> ideally, if i use seed 0 and seed 1, i shouldn't be able to see any correlation between the two
15:05:44 <RyanT5000> i mean, clearly if *all* their outputs were correlated we'd have a problem, right?
15:06:06 <augusts> RyanT5000: the Haskell random number generator needs an overhaul.  feel free to make a new one
15:06:14 <RyanT5000> i think i will
15:06:59 <RyanT5000> what should it be based on? as usual i'm tempted to do something like an SHA512 for every number
15:07:14 <quicksilver> haskell.org down? or my internet dodgy?
15:07:34 <oerjan> quicksilver: your internet
15:07:34 <RyanT5000> it's up
15:07:40 <quicksilver> hmph
15:07:46 <augusts> RyanT5000: the Mersenne twister is good
15:08:22 <augusts> RyanT5000: just don't invent your own.  Unless you're an expert. :)
15:08:49 <RyanT5000> augusts: right
15:08:50 <fy__> quicksilver: I can't access it either.
15:08:58 <RyanT5000> that's why i usually do overkill
15:09:06 <quicksilver> it's possible to 'promote' any State s a action into a generic MonadState s m => m a action
15:09:09 <RyanT5000> if i have to invent my own
15:09:16 <quicksilver> does that promotion have a name?
15:09:18 <augusts> well, overkill doesn't mean it's good
15:09:25 <quicksilver> fy__: ah, intertubes in a mess perhaps
15:10:05 <shapr> I'm having trouble accessing lots of stuff.
15:10:35 <RyanT5000> augusts: actually, i think it'd be better then Mersenne to use SHA512, at least for crypto
15:10:37 <RyanT5000> it'd be slow, though
15:10:47 <RyanT5000> looks like the choices are Blum Blum Shub
15:11:05 <RyanT5000> and Mersenne Twister
15:11:05 <augusts> RyanT5000: on what do you base your statement?
15:12:17 <augusts> the Mersenne twister has a property that could come handy for a Haskell generator.  you can sort of split it the way haskell nees
15:12:25 <pjd> > map (fst . (randomR (0,3)) . mkStdGen) [0..]
15:12:31 <augusts> at least you can fast forward it
15:12:33 <lambdabot>  [1,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1...
15:12:52 <RyanT5000> augusts: you know, you're right; i can only prove it in reverse :P
15:12:52 <pjd> > map (fst . (randomR (0,4)) . mkStdGen) [0..]
15:12:53 <lambdabot>  [0,2,1,0,4,3,2,1,0,4,3,2,1,0,4,3,2,1,0,4,3,2,1,0,4,3,2,1,0,4,3,2,1,0,4,3,2,1...
15:12:55 <RyanT5000> which would make it hard to implement
15:13:12 <RyanT5000> i'll make Blum Blum Shub for now
15:13:32 <RyanT5000> i'd rather the default be cryptographically secure
15:13:59 <augusts> we should have several generators
15:14:02 <RyanT5000> yeah
15:14:06 <RyanT5000> i'll write Mersenne Twister if i have time
15:14:16 <RyanT5000> those two should be enough for most usage
15:14:36 <Igloo> augusts: Hmm, and given any generator must by cyclic, you can't do better than to get sizeof(internal state) random bits and fastforward that amount, can you?
15:15:23 <augusts> no, but far from all generators can fast forward
15:15:32 <RyanT5000> yeah, BBS can't
15:15:37 <RyanT5000> at least, i think it can't
15:15:44 <RyanT5000> oh wait
15:15:44 <Igloo> Sure, I was just thinking about whether that was enough to implement the Haskell spec
15:15:45 <RyanT5000> yeah it can
15:15:59 <RyanT5000> in fact, you can generate arbitrary BBS values
15:16:32 <RyanT5000> what properties do we care about with split?
15:16:32 <augusts> the haskell spec is terrible.  from an implementation view, I mean.  the splitting is not something well studied
15:17:38 <augusts> the report states some properties
15:18:56 <pjd> is there any interface to system randomness?
15:19:14 <pjd> for the IO monad?
15:19:19 <augusts> Not a standard one from Haskell
15:19:35 <Vulpyne> System.Random?
15:19:36 <augusts> it's platform dependent
15:19:44 <augusts> it would be nice to have one
15:22:49 <Vulpyne> Ahhh, you meant like /dev/random and such.
15:23:07 <RyanT5000> do we have a good way of getting quasirandom large primes?
15:23:20 <quicksilver> in most cases you don't use /dev/random for "all your randomness"
15:23:28 <quicksilver> you just pull a "large random seed" from it
15:23:44 <augusts> exactly
15:23:55 <pjd> Vulpyne: yeah
15:23:58 <RyanT5000> actually, random would be good enough
15:27:34 <fasta> RyanT5000: I am interested in that too
15:28:13 <fasta> RyanT5000: I have done some research into it.
15:28:17 <RyanT5000> how so?
15:28:27 <fasta> RyanT5000: libGSL should be called
15:28:37 <RyanT5000> libGSL?
15:28:54 <SamB> @tell sorear that I just submitted a Jhc patch he might like to jhc@haskell.org
15:28:55 <lambdabot> Consider it noted.
15:29:14 <fasta> RyanT5000: it contains the Mersenne twister
15:29:35 <RyanT5000> ah
15:29:40 <RyanT5000> has it got Blum Blum Shub?
15:29:45 <oerjan> SamB: i doubt that will come out of lambdabot grammatically correct
15:29:47 <RyanT5000> i kind of want to implement that now :P
15:30:15 <edward1> back
15:30:20 <fasta> RyanT5000: What do you mean?
15:30:22 <SamB> oerjan: I can't stop using English grammar with that command
15:30:24 <RyanT5000> "distinguishing from random data is as hard as integer factorization" sounds really sexy
15:30:36 <RyanT5000> :P
15:30:47 <edward1> is there a template haskell implementation in anything other than ghc?
15:30:59 <SamB> I'd sooner submit a lambdabot patch to make it come out nicely than remember not to use a complete sentance for that
15:31:10 <fasta> RyanT5000: ?
15:31:37 <SamB> edward1: not yet afaik
15:31:42 <RyanT5000> Blum Blum Shub is another PRNG
15:31:57 <Toxaris> SamB: eliza-style rewriting?
15:32:15 <edward1> k, so the irony is that using CPP is more portable than templatehaskell? =)
15:32:17 <SamB> Toxaris: hmm.
15:32:44 <SamB> I guess you might need that.
15:32:46 <oerjan> Toxaris: based on lambdabot's usual polite style :D
15:32:59 <SamB> who knew that eliza could be *useful*?
15:33:14 <SamB> so... how does lambdabot know gender?
15:33:39 <fasta> RyanT5000: I know, but that's not what I mean.t
15:33:42 <fasta> RyanT5000: meant*
15:33:48 <oerjan> edward1: did you see the recent thread on lambda the ultimate about dependent types?
15:33:52 <Toxaris> SamB: "Hey sorear, SamB told me something about his father, but I didn't understand what he means"
15:34:12 <RyanT5000> fasta: I mean, I feel like implementing BBS
15:34:23 <fasta> RyanT5000: do it! ;)
15:34:29 <edward1> oerjan: which one, the how to build a compiler for them one?
15:34:31 <fasta> RyanT5000: and then send me the tested code :)
15:34:35 <RyanT5000> yep
15:34:51 <edward1> oerjan: rather hoiw to use them as an intermediate language in a compiler?
15:34:51 <RyanT5000> wikipedia only has links to 2 implementations
15:34:54 <RyanT5000> one of which is in java
15:35:00 <fasta> RyanT5000: broken link
15:35:02 <fasta> RyanT5000: I checked.
15:35:10 <RyanT5000> ah
15:35:20 <RyanT5000> so another implementation won't hurt anything
15:35:25 <RyanT5000> especially if it's in Haskell :P
15:35:26 <fasta> RyanT5000: If you don't implement it in Haskell, I will to down that route, I guess.
15:35:32 <edward1> oerjan: you realize that JHC has been doing that for a while now and that Jan Willem Roorda has a nice paper on Henk 2000 which is basically the same general idea thats probably 7 years old now and even written in Haskell =)
15:35:36 <oerjan> edward1: the "Simply easy!" thread
15:35:39 <fasta> RyanT5000: but it requires me to trust that other programmer.
15:36:06 <RyanT5000> fasta: lol
15:36:25 <RyanT5000> you can implement it too, and we can check our implementations against each others' :P
15:36:48 <edward1> oerjan: http://people.cs.uu.nl/johanj/MSc/jwroorda/ take a look at that its about 7 years old and also does a pure type system (dependent types and all that) in Haskell
15:36:49 <lambdabot> Title: Pure Type Systems for Functional Programming
15:36:53 <fasta> RyanT5000: I can implement a lot, but I only live a certain amount of time.
15:37:00 <SamB> JHC has a wierd macro system
15:37:19 <fasta> RyanT5000: unless medicine advances :)
15:37:20 <RyanT5000> fasta: yeah :P
15:37:25 <RyanT5000> i was kidding
15:37:29 <edward1> it was the most useful 'functional' introduction to dependent types I found. I found it useful to learn that before cutting my teeth on Yarrow or coq.
15:37:42 <edward1> and its a general PTS implementation so you can extend the sort set.
15:38:41 <edward1> slightly different emphasis than the recent LTU thread though.
15:38:43 <fasta> RyanT5000: ok, so when is it done? ;)
15:39:02 <augusts> Implementing PTS type checking is easy
15:39:20 <edward1> augusts: exactly =)
15:39:40 <fasta> RyanT5000: oh, well, that algorithm doesn't look that complicated.
15:40:06 <augusts> I have one as well :)  http://darcs.augustsson.net/Darcs/PTS/
15:40:07 <edward1> i find PTS's to be a lot easier to understand than the more complicated system F variants, because so many things collapse into one.
15:40:08 <lambdabot> Title: Index of /Darcs/PTS
15:40:51 <edward1> lennart: yeah i think I raided yours for ideas already =)
15:41:23 <fasta> RyanT5000: still, if you implement it, post a message to Haskell Cafe and post it on Hackage.
15:41:52 <edward1> if not, its going into my list of 'other PTS implementations' to play with
15:44:23 <RyanT5000> fasta: yeah, i'll have that done by tonight
15:44:44 <RyanT5000> what's a good library for manipulating large primes?
15:44:49 <RyanT5000> i need something like:
15:44:50 <edward1> hrmm, ok, next generalization on the list from earlier.. with (+) (*) etc no longer requiring the silly Num classes etc. instance AddMagma a t => AddMagma (b -> a) t where f + g = \x -> f x + g x   ... etc, works without having to hack Show and Eq instances
15:45:21 <fasta> RyanT5000: there's the "crypto" library.
15:45:38 <RyanT5000> well i'm trying to use Codec.Encryption.RSA.NumberTheory right now
15:45:38 <fasta> RyanT5000: but I don't know whether it helps
15:45:46 <edward1> @pl liftF2 h f g x = h (f x) (g x)
15:45:46 <lambdabot> liftF2 = liftM2
15:45:49 <edward1> duh
15:46:03 <RyanT5000> but it crashes with "Prelude.^: negative exponent" whenever i do anything interesting
15:46:25 <RyanT5000> and it seems to be totally undocumented
15:47:07 <fasta> The Java crypto stuff is/was closed source too.
15:47:11 <RyanT5000> lame
15:47:22 <fasta> I mean the stuff from Sun.
15:47:29 <oerjan> RyanT5000: are the exponents somehow defaulting to Int?
15:47:40 <fasta> I thought Java was fully "Free".
15:47:41 <RyanT5000> oerjan: i'll check
15:47:53 <fasta> Must be some marketing trick they pulled on me :/
15:48:27 <RyanT5000> oerjan: not externally
15:48:33 <RyanT5000> isPrime :: Integer -> IO Bool
15:48:39 <RyanT5000> why is that IO, anyway?
15:48:50 <RyanT5000> i guess it predates ST?
15:49:07 <fasta> RyanT5000: it uses random numbers
15:49:13 <fasta> RyanT5000: and a bad interface
15:49:13 <RyanT5000> fasta: ah, ironic
15:49:25 <fasta> RyanT5000: it's not an algorithm
15:49:27 <etnt> I have scanner output like: [TokenInt 42,TokenEq,...] now to operate on this with the Parsec lib, do I need to define an instance of Monad ?
15:49:34 <etnt> I'm confused...
15:49:36 <fasta> RyanT5000: it's a heuristic too, I guess
15:49:43 <RyanT5000> i'm going to laugh really hard if i end up using a PRNG in the initialization function of my PRNG
15:49:44 <fasta> RyanT5000: not 100% sure, though.
15:49:56 <fasta> RyanT5000: but I expect they implemented the simple algorithm.
15:50:23 <oerjan> etnt: no
15:51:00 <oerjan> etnt: you need to use the token or tokenPrim functions for your terminals checking
15:51:04 <RyanT5000> lol
15:51:09 <RyanT5000> yes, it is a fairly bad algorithm
15:51:26 <RyanT5000> it does the rabinMillrePrimalityTest 5 times
15:51:29 <RyanT5000> there's a little comment saying
15:51:34 <RyanT5000> "Do this 5 times for safety"
15:51:41 <RyanT5000> i love hard-coded stuff like that
15:51:52 <RyanT5000> no one could *ever* need a prime more secure than *5* tries
15:52:37 <augusts> having in IO is terrible too.  it should take a seed, or an PRNG
15:52:42 <RyanT5000> yeah
15:52:44 <etnt> aha. I see...any pointers where to find examples ?
15:52:48 <RyanT5000> oh wait my bad
15:53:02 <RyanT5000> the rabin miller primality test takes arguments for how many iterations to do
15:53:11 <ericlavigne> I am new to Haskell, and it looks to me like Haskell's feature of memoizing all functions would cause the equivalent of a memory leak in long-running applications such as web servers. Do Haskell web servers need to rebooted every hour/day or so to reclaim memory?
15:53:13 <RyanT5000> oh wait, that's just the first stage of it
15:53:18 <RyanT5000> i'm totally confused by this guy's design, lol
15:53:32 <SamB> ericlavigne: where did you read about it memoizing everything?
15:53:41 <SamB> it doesn't memoize everything
15:54:01 <SamB> not in the usual sense, anyway
15:54:28 <ericlavigne> I am only familiar with one sense of the word. Lots of examples strongly imply memoization, but I haven't seen that word used.
15:54:32 <edward1> ericlavigne: it doesn't memoize everything
15:55:00 <edward1> it took me a while to realize there was a difference too
15:55:04 <ericlavigne> It automatically memoizes sometimes, and there are rules for determining when?
15:55:13 <oerjan> etnt: i don't know any documentation other than the main page at http://legacy.cs.uu.nl/daan/download/parsec/parsec.html
15:55:19 <augusts> it especially doesn't memoize functions
15:55:27 <fasta> RyanT5000: hmm, that *does* sound funny.
15:56:04 <augusts> ericlavigne: it doesn't really memoize anything.  thinking of it that way is misleading
15:56:19 <edward1> eric: the idea is it doesn't evaluate the arguments to functions until they are evaluated, not that it remembers the results from previous invocations of a function and substitutes them directly for the answer, there is a difference.
15:56:21 <RyanT5000> ericlavigne: it kind of memoizes the result of global constants
15:56:46 <augusts> If you write 'int i = 2+3;' in C would you say that not computing 2+3 every time you use i is memoization?
15:57:00 <RyanT5000> so if you declare a very long list, e.g.: naturals = [0..]
15:57:16 <RyanT5000> and then you cause it to build that long list out a very long way
15:57:22 <oerjan> etnt: perhaps you can find something here: http://haskell.org/haskellwiki/Blog_articles/Parsing
15:57:23 <lambdabot> Title: Blog articles/Parsing - HaskellWiki
15:57:33 <RyanT5000> e.g.: evaluating (take 1000000 naturals)
15:57:37 <fasta> RyanT5000: are you saying that memory will never be returned?
15:57:45 <RyanT5000> yeah, i'm pretty sure it won't
15:57:46 <fasta> RyanT5000: That seems unlikely.
15:57:50 <SamB> well, for some reason okasaki uses "memoization" to mean the way a thunk's values i remembered, when once computed
15:57:55 <SamB> s/i/is/
15:57:59 <augusts> CAFs are GCed
15:58:01 <edward1> eric: so f x = x + x, will evaluate x to its value, then use that value twice rather than evaluate it twice, but it doesn't build up the memo table of 'if i called this function with 12 earlier it returned 409, so when you call it again, here is 409.
15:58:14 <fasta> SamB: to confuse the rest of the world, surely.
15:58:36 <etnt> oerjan: ok, thx!
15:58:41 <SamB> fasta: or because he couldn't come up with a better term
15:58:41 <RyanT5000> augusts: yeah, but let's say you expand the CAF to a million, then you only ever use the first 1000 after that
15:58:46 <SamB> can you?
15:58:53 <ericlavigne> For example, in a fibonacci function, defined in the naive way, Haskell will automatically avoid doing the extra calculations. This looks like memoization to me.
15:58:58 <RyanT5000> i suppose it doesn't matter whether it's a CAF in that circumstance
15:59:21 <edward1> eric: actually if you implement it the naive way, it will do extra calculations unless the inliner is being particularly smart that day
15:59:23 <augusts> RyanT5000: if the lift from 1000 and forward is still reachable from the code it will be retained
15:59:32 <RyanT5000> augusts: right
15:59:33 <augusts> but if it's not, it will be GCed
16:00:01 <augusts> "lift"?  I've started lisping when I type...
16:00:30 <ericlavigne> Okay, sounds like I was more confused than I thought. Back to the books. Thanks.
16:00:30 <RyanT5000> but in some circumstances it'd be nice if stuff got partially garbage-collected (not that i'm saying this is possible)
16:00:30 <augusts> Doing GC of CAFs is a major pain, btw
16:00:45 <RyanT5000> basically, replace the 999,000 extra things with a thunk
16:01:02 <RyanT5000> (de-evaluate them, if you will)
16:01:05 <fasta> augusts: why?
16:01:06 <Saizan> augusts: any chance we could have weak references? so that you can GC the referenced value and thanks to purity reconstruct it when needed?
16:01:10 <augusts> RyanT5000: it wouldn't be very hard to do.  then question is when to do it
16:01:17 <RyanT5000> augusts: right
16:01:19 <edward1> eric: that said, if you implement it with the a list, and walk down the list defining values in terms of previous values on the list the simple zipWith way that you sometimes see it, thats quite different than f 0 = 1; f 1 = 1; f x = f (x -1) + f (x - 2)     that won't memoize anything
16:01:47 <RyanT5000> augusts: although then wouldn't you have to keep the thunk around all the time, too?
16:01:49 <augusts> Saizan: yeah, some kind of weak reference might be possible
16:01:55 <edward1> the list zipWith trick has a list of thunks, those thunks will only get forced once and it calculates each in its place on the list, quite different in terms of how its implemented.
16:01:58 <RyanT5000> that seems like a lot of wasted spacde
16:02:35 <ericlavigne> so if I write "f 0 = 1; f 1 = 1; f x = f (x -1) + f (x - 2)" that will be an extremely slow way of doing the calculation?
16:02:41 <edward1> yeah
16:02:43 <edward1> but
16:02:59 <augusts> RyanT5000: yes, I think this thunk inserting would have to be under programmer control, somehow
16:03:04 <edward1> > let fib = 1 : 1 : zipWith (+) fib (tail fib) in fib
16:03:05 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
16:03:10 <edward1> thats really fast =)
16:03:40 <EvilTerran> linear rather than exponential time
16:03:49 <augusts> but we can do better :)
16:03:50 <RyanT5000> augusts: yeah; maybe it could have a syntax similar to strictness, only much uglier
16:03:53 <edward1> each value in the list will only get evaluated once, and depends only on the values earlier in the list
16:03:53 <ericlavigne> and then fib is a list rather than a function?
16:04:08 <RyanT5000> (well, only uglier if are allowed to provide your own heuristic)
16:04:14 <spurion> Umm, anyone want to help me avoid reinventing the wheel?
16:04:27 <sjanssen> spurion: sure, shoot
16:04:38 <spurion> I can't find a parser library that does what I want, but I can't imagine it hasn't been done either :-)
16:04:54 <spurion> Imagine I'm sitting on a network socket, listening
16:05:03 <spurion> bytes arrive now and then
16:05:10 <spurion> and I want to parse the stream of bytes
16:05:14 <edward1> so the 'list' acts as a sort of temporary memoization table. now. if i make that list a global constant or a 'CAF' as people refer to them here it'll never get garbage collected in most implementations, so any part of it that i ever use will remain in memory. giving you the sort of leak you described
16:05:31 <spurion> but I don't want to wait before I start parsing - I don't know how long I'll have to wait because it depends on what's in the message
16:05:44 <edward1> > let fib = 1 : 1 : zipWith (+) fib (tail fib) in fib ! 32
16:05:45 <lambdabot>  Couldn't match expected type `Array i e'
16:05:47 <edward1> er
16:05:53 <edward1> > let fib = 1 : 1 : zipWith (+) fib (tail fib) in fib !! 32
16:05:54 <lambdabot>  3524578
16:06:07 <hardhard> hey
16:06:29 <spurion> So I need a parser that takes a byte and gives me either failure, or a new parser and possibly some output.
16:06:33 <hardhard> how do I read midi signals from midi keyboard and write some midi events to midi device/?
16:06:54 <edward1> that looks at one element 32 nodes down the list, which needs the answer from the nodes 30 and 31 nodes down the list, so it looks at the 30th, which needs the 28th, etc. until it gets an answer, but then when the 31st needs the 30th, whoa its already there,
16:07:11 <augusts> hardhard: open /dev/rmidiN
16:07:13 <augusts> on NetBSD
16:07:27 <hardhard> i want some portable thingy
16:07:32 <ericlavigne> edward1: this makes sense to me now. thanks.
16:07:33 <hardhard> that runs on windows/mac/linux
16:07:33 <spurion> I was looking at ReadP, 'cos it almost does what I want
16:07:50 <hardhard> can GHC compile c codes?
16:08:03 <hardhard> maybe portmidi wrapper
16:08:05 * hardhard googles
16:08:08 <augusts> It can invoke, gcc, yes
16:09:05 <edwardk> hrmm i wonder with that parameterized restricted monad hack from earlier if something like that peyton jones/wadler paper on query comprehensions for order by and group by could be done using the monad sugar
16:10:09 <Saizan> spurion: i think you have to separate the "fetch bytes from network" and "parse messages" part
16:10:15 <augusts> spurion: I can imagine you could use parsec if you interface to it at the right level.  but I'd have to check
16:10:25 <edwardk> because you could accumulate a list of types passed with >>= then maybe force them to take the right shape. it definitely appears that some sort of OLAP sugar would work, which is cool in its own right.
16:10:58 <augusts> spurion: the tricky part is that you want to produce output before you've seen all the input
16:10:59 <spurion> Saizan/augusts: I'm quite happy to sit in a loop, reading a few bytes and poking them into my parser
16:11:10 <hardhard> I downloaded zip version of ghc, it's 333MB uncompressed. are there some stuff that I can take out so that i can make it as light as possible
16:11:32 <spurion> Basically, each byte can move the parser from state to state and sometimes a state transition will also cause some data structure to pop oup.
16:11:34 <spurion> out.
16:11:35 <hardhard> i want to put ghc into usb drive and carry it with me
16:11:53 <hardhard> erlang can fit 5MB
16:12:04 <hardhard> alright got to go. i'm on public station
16:12:06 <spurion> This is essentially how ReadP responds to each byte of its input string
16:12:27 <spurion> but it doesn't expose any functions that allow you to feed it slowly - you have to give it a whole string.
16:12:50 <dons> hardhard: perhaps stick nhc98 on the usb key then?
16:12:59 <Saizan> well you can "fake" a whole string with laziness
16:13:18 <spurion> Not if I have to do IO in the middle :)
16:13:20 <dons> hardhard: also, you can get it down to about 5M without docs, profiling, and most libraries
16:13:34 <Toxaris> spurion: hGetContents does IO in the middle, too
16:13:36 <dons> see the freebsd bootstrap version
16:13:48 <RyanT5000> Toxaris: do people actually use that?
16:14:52 <Toxaris> RyanT5000: I don't know. I use readFile, wich is build upon it, I believe.
16:14:54 <oerjan> spurion: i have pondered the exact same problem before.  The only Haskell parsing library i found that might do it is Happy.
16:15:09 <Saizan> spurion: how hard is to check when you have a whole message? if there's some sort of signaling byte you can buffer until you get it
16:15:17 <oerjan> (it allows you call the lexer in a monad)
16:15:21 <spurion> It did occur to me that one could write a parser that took (f :: IO Char) instead of String, but you'd have to do something mildly funky to implement lookahead :)
16:15:56 <RyanT5000> spurion: well it could take Monad m => m Char
16:16:07 <spurion> Toxaris: hGetContents wouldn't help - it returns IO String, but no parser libraries deal with IO.
16:16:11 <RyanT5000> would that work automatically with Strings too?
16:16:24 <RyanT5000> i have a very poor understanding of the list monad
16:16:28 <Saizan> spurion: you can just lift the parser library into IO
16:16:32 <oerjan> spurion: essentially you want a monad _transforming_ parser library, which as far as i know doesn't exist
16:16:51 <monochrom> hardhard: I bought a 256MB usb drive for $0. That is, list price $20, rebate $20.
16:16:58 <Toxaris> spurion: but it returns magic IO string wich is lazily read
16:17:00 <spurion> oerjan: that's what I suspected. I'm *just* *about* grasping monads at the moment.
16:17:12 <spurion> Saizan: how would I lift my parser library into IO?
16:17:22 <spurion> Given that it already operates on String?
16:17:28 <oerjan> alternatively, a continuation passing one.
16:17:35 <spurion> Yes.
16:17:40 <Toxaris> spurion so (hGetContents handle >>= parseString) should read only when data is processed by parseString
16:17:56 <spurion> oerjan: AFAICT, ReadP is implemented in an essentially continuation-passing style
16:18:03 <Saizan> spurion: if you have a function parse :: String -> Foo, then you can write do string <- hGetContents handle; return (parse string)
16:18:10 <Toxaris> or (hGetContents handle >>= return . parseString) if parseSTring is not monadic
16:18:12 <shachaf> On http://haskell.org/haskellwiki/Curry-Howard-Lambek_correspondence , shouldn't (.) be :: (b -> c) -> (a -> b) -> (a -> c)?
16:18:13 <lambdabot> Title: Curry-Howard-Lambek correspondence - HaskellWiki
16:18:16 <oerjan> spurion: hm.
16:18:16 <spurion> oerjan: that's what made it an interesting candidate for adaptation to allow partial input.
16:18:32 <shachaf> It looks like ghci agrees with me.
16:19:03 <spurion> Saizan: that's all very well, but it will fail if it runs out of Chars before the parser is satisfied.
16:19:19 <Saizan> spurion: no, it will just wait :)
16:19:45 <Toxaris> Saizan: what should it do instead?
16:19:54 <Toxaris> ehm, meant spurion
16:20:03 <spurion> Saizan: Oh, I didn't think of that. Well, I guess that would work but it does feel as lovely.
16:20:08 <spurion> doesn't, I mean.
16:20:28 <Saizan> spurion: there are some problems with lazy IO wrt exceptions
16:20:49 <spurion> If my hypothetical parser runs out of input, it should return a new parser with which to continue parsing once new input arrives.
16:20:58 <Saizan> spurion: a safer solution is probably to use a Chan, from Control.Concurrent.Chan
16:21:39 <Saizan> spurion: "runs out of input" because it's not yet arrived or because the connection died?
16:21:41 <spurion> Saizan: but a Chan would still require some sort of monadic thing to extract data, wouldn't it?
16:21:52 <spurion> Saizan: runs out of input because it hasn't arrived yet.
16:22:20 <Saizan> spurion: in that case with hGetContents your parses will just wait for the rest of the input
16:22:31 <Toxaris> spurion: so you would like to explicitly controll the progress of the parser?
16:22:37 <spurion> Saizan: it's true, but I can't do anything fun in the mean time :)
16:22:46 <spurion> Tox: essentially, yes.
16:22:56 <spurion> All I want to check is that nobody's got a parser that does this already.
16:23:23 <spurion> And that I'm not overlooking some cunning trick involving probably lifting.
16:23:38 <Toxaris> as with data Parser result = Char -> (Maybe result, Parser result)
16:24:03 <spurion> 'cos I reckon I can adapt ReadP to my needs relatively quickly but I might not be seeing a good reason why it hasn't already been done.
16:24:30 <spurion> Tox: Yeah, that's pretty much the kind of signature I'm thinking of.
16:24:37 <edwardk> @paste
16:24:37 <lambdabot> Haskell pastebin: http://hpaste.org/new
16:24:54 <spurion> It's also worth noting that I'm not expecting any ambiguity.
16:25:11 <shachaf> Currying is transforming a function :: (a,b) -> c to a function :: a -> (b -> c) . Is there some equivalent for functions :: a -> (b,c) (i.e., for return types)?
16:25:13 <spurion> So it would be okay to emit a result as soon as it's available - it won't contradict some later result.
16:25:17 <hpaste>  edwardk pasted "is it me or is enumFrom* not obeying the -fno-implicit-prelude?" at http://hpaste.org/1609
16:25:58 <pyCube> hmm..  i really like haskell, but its can be frustrating as hell at first
16:26:17 <pyCube> its the "simple" things that get me
16:26:17 <spurion> pyCube: same here
16:26:19 <Vulpyne> It makes my brain explode.
16:26:27 <spurion> "simple"?
16:26:37 <pyCube> i just want to do something for each item in a list.. except its not a list, its an IO thingy
16:26:38 <dmwit> shachaf: (fst .) and (snd .) ?
16:26:51 <Saizan> edwardk: the error?
16:26:56 <edwardk> fmap foo (yourIOlist)
16:26:57 <Vulpyne> pyCube: Is it IO [blah]?
16:27:11 <pyCube> Vulpyne: yes
16:27:28 <hpaste>  (anonymous) annotated "is it me or is enumFrom* not obeying the -fno-implicit-prelude?" with "(no title)" at http://hpaste.org/1609#a1
16:27:30 <spurion> Okay oerjan, Toxaris, Saizan &c thanks for your help
16:27:35 <spurion> I shall see how I get on.
16:27:37 <shachaf> dmwit: I mean, one function that somehow returns multiple values without using a tuple.
16:28:01 <Vulpyne> pyCube: It's helped me to think of x <- monadicthing as stripping the monadic type off and putting it in x.
16:28:25 <SamB> actually, that IO [a] isn't a list at all. it's an action that, if run, will return a list
16:28:30 <edwardk> its invoking the one from the prelude as well
16:28:44 <Toxaris> shachaf: "somehow"?
16:28:54 <edwardk> probably time to take off the kid gloves and figure out how to patch it, eh?
16:28:56 <dmwit> shachaf: Records, and continuations, and the State monad, and...
16:29:02 <edwardk> bah
16:30:02 <shachaf> dmwit: Well, currying doesn't involve anything like that, I was wondering if there's some way to make it work for returning multiple values. It doesn't really make sense, but I was curious if there's something I wasn't thinking of.
16:31:10 <Saizan> edwardk: http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#rebindable-syntax <-- [a..] is not listed as rebindable
16:31:12 <lambdabot> Title: 7.3. Syntactic extensions, http://tinyurl.com/y6v6by
16:32:38 <edwardk> yeah, i know, but its consistent with the -fno-implicit-prelude behavior for everything else thats sugared
16:32:57 <edwardk> and things like the arrow syntax don't say they rebind, but do
16:33:20 <Saizan> Arrow notation (see Section 7.7, “Arrow notation ”) uses whatever arr, (>>>), first, app, (|||) and loop functions are in scope. But unlike the other constructs, the types of these functions must match the Prelude types very closely. Details are in flux; if you want to use this, ask!
16:33:45 <edwardk> ah i must have read it a list from somewhere else missing it
16:35:06 <shachaf> pyCube: The IO monad may not be the best one to learn about monads from -- I'd suggest starting with simpler ones.
16:37:40 <pyCube> dunno
16:37:58 <edwardk> that also might explain some of the typing problems i had with trying to rebind the arrow notation for limitations like Read/Show, etc.
16:38:17 <RyanT5000> august: is this yours? http://www.augustsson.net/Darcs/MT/MersenneTwister.hs
16:38:25 <RyanT5000> augusts: , rather
16:38:58 <fnord123> If you were designing a data type for a remote resource, would you hide the data transfer in the laziness of the library? or would you have an explicit 'go get this data' funciton?
16:39:35 <fnord123> e.g. HAMXL uses 'readDocument' and that retrieves remote documents.
16:39:37 <augusts> yeah, that's mine
16:40:28 <RyanT5000> augusts: mind if i just package that up with the appropriate instances and submit it as System.Random.MersenneTwister.MT19937?
16:40:46 <RyanT5000> of course i'll leave your attribution in
16:40:48 <augusts> please do.  i never got around to the packaging
16:41:11 <RyanT5000> any improvements (afterthoughts, etc.) i should make before doing so?:
16:41:25 <RyanT5000> i'd rather not understand everything you're doing with ST if i can avoid it :P
16:42:05 <augusts> well, it was written to generate a stream of random numbers.  so it might need changes to perform reasonably
16:42:09 <spurion> RT5000: but then how will you know if it works?
16:42:29 <RyanT5000> spurion: i'll try it :P
16:42:37 <spurion> lol
16:42:40 <RyanT5000> and trust augusts :P
16:42:50 <RyanT5000> actually, i'm going to compare it to some other implementation
16:42:55 <augusts> oh, it works
16:42:58 <spurion> I suppose you could run it in parallel with .... exactly :)
16:43:13 <augusts> i've compared it with a C version
16:43:17 <RyanT5000> ok
16:43:26 <RyanT5000> lol yes i could run 4 of them in parallel
16:43:32 <spurion> (and the C version was known good)
16:43:39 <RyanT5000> to solve the byzantine generals problem
16:43:54 <spurion> will have to look that one up
16:46:36 <RyanT5000> it's really the most ridiculous overkill imaginable
16:46:54 <RyanT5000> that would basically be if all 4 algorithms were part of a distributed system
16:47:00 <RyanT5000> and any one of them could be a traitor
16:47:07 <RyanT5000> and they all had to be able to find the traitor
16:47:12 <RyanT5000> independently
16:47:20 <RyanT5000> (it's for distributed systems)
16:48:52 <spurion> ah
16:50:36 <RyanT5000> augusts: how do i do the split?
16:55:09 <augusts> I dunno
16:55:51 <augusts> that's what sucks about the Haskell API.  No one knows how to split well
16:55:51 <Cale> http://programming.reddit.com/info/24p8z/comments/c259hg -- hehe (if you don't understand this comment, see the parent)
16:55:52 <lambdabot> Title: Multi-Threading Strategies for Game AI (reddit.com)
16:58:08 <RyanT5000> lol
17:02:02 <Pseudonym> Oh, man.
17:03:22 <Pseudonym> The one on the right is QFT.
17:03:37 <RyanT5000> > foldl1 min $ take 1000000 $ [1000000,999999..]
17:03:39 <lambdabot>  1
17:03:53 <RyanT5000> huh... that stack-overflows in ghci
17:04:12 <Pseudonym> Well, quantum mechanics, QFT, standard model.
17:04:31 <glguy> http://programming.reddit.com/info/24p8z/comments/c24u5k
17:04:32 <lambdabot> Title: Multi-Threading Strategies for Game AI (reddit.com)
17:04:35 <glguy> thanks for the PROTIP
17:06:09 <Cale> dons: around?
17:09:16 <RyanT5000> does haskell-mode have autocompletion?
17:09:23 <RyanT5000> i'm getting rather tired of typing MT19937 :P
17:10:00 <RyanT5000> (not really, but i do wonder if it has that feature)
17:10:56 <dons> Cale?
17:11:14 <ClaudiusMaximus> > foldr (\x l -> (x - head l) : l) [0] [1,6,3,5,2]
17:11:16 <lambdabot>  [-5,6,0,3,2,0]
17:11:37 <augusts> RyanT5000:  what about M-/
17:11:40 <dons> Cale, nsieve was changed because ghc bit packs Bool arrays
17:11:51 <RyanT5000> augusts: cool :P
17:11:55 <dons> lots of others have been changed over the years as well
17:11:57 <RyanT5000> is that the usual command in emacs?
17:12:08 <augusts> it's not mode specific
17:12:11 <Cale> dons: ah, you found out already what I was interested in :)
17:12:27 <RyanT5000> augusts: oh, what's it doing then? just completing based on any word in the document?
17:12:31 <Cale> Do you want to make a comment to that effect, or should I just edit mine?
17:12:34 <augusts> yes
17:12:40 <dons> Cale, but i really wouldn't hack on the shootout guys. they try.
17:12:51 <dons> the point is that the haskell entries are a bit out of date now.
17:13:55 <augusts> RyanT5000: but it searches in a clever way
17:14:15 <augusts> in all buffers
17:14:17 <dons> Cale, more interesting is http://www.haskell.org//pipermail/haskell/2006-June/018127.html
17:14:17 <lambdabot> Title: [Haskell] Comments from Brent Fulgham on Haskell and the shootout
17:14:30 <RyanT5000> augusts: ah, that's really cool; thanks
17:18:19 <xpika> how can i glob a directory in haskell?
17:18:57 <dons> use one of the directory globbing libraries?
17:19:06 <dons> or just roll your own with System.Directory
17:19:51 <dons> Prelude System.Directory> getDirectoryContents "/"
17:19:54 <dons> [".","..","home","tmp","usr","var","bsd","bsd.rd","altroot", ...
17:20:40 <spurion> Goodnight!
17:21:57 <Saizan> xpika: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/FileManip-0.2 <-- this one, maybe
17:22:00 <lambdabot> http://tinyurl.com/2j23hf
17:22:35 <RyanT5000> System.IO> readFile "/etc/passwd"
17:22:42 <fnord123> Goodnight!
17:22:58 <RyanT5000> aw
17:23:22 <glguy> RyanT5000: you actually have to paste you rpassword file for us
17:23:31 <RyanT5000> hm?
17:23:31 <Binkley> be sure to decrypt it too
17:23:38 <glguy> RyanT5000: unless your irc client is broken :(
17:23:41 <dons> > readFile "/etc/passwd"
17:23:43 <lambdabot>  <IO [Char]>
17:23:46 <dons> damn type system
17:24:05 <glguy> RyanT5000: I thought you were trying to paste like dons was :)
17:24:21 <RyanT5000> glguy: oh, i didn't notice that dons was pasting :P
17:24:38 <RyanT5000> i thought it was a new extension to lambdabot
17:24:48 <RyanT5000> the bad kind, lol
17:25:47 <RyanT5000> my brain has become part lambdabot - whenever i see a >, i think it's a haskell expression i should evaluate :P
17:26:08 <Binkley> I wonder what happens when you read emails with quoted text :-0
17:26:08 <niclasw> does anyone know if it is possible to do minimal matches with the Regex library?
17:26:21 <RyanT5000> Binkley: lol
17:26:32 <RyanT5000> i never understand those >:-/
17:26:49 <Binkley> :-)
17:29:31 <dons> niclasw: its just posix regexes, so only if you can do it in posix anyway
17:29:44 <dons> niclasw: you might want regex-pcre perhaps? on hackage.
17:30:38 <niclasw> dons: thanks, i'll try that. i got errors compiling patterns like "start(.*?)stop"/
17:30:55 <glguy> doesn't MissingH have a glob library?
17:31:18 <glguy> niclasw: (.*?) doesn't make sense, does it?
17:31:35 <RyanT5000> not to me
17:31:48 <niclasw> does regeps ever?
17:31:52 <RyanT5000> yeah
17:31:54 <RyanT5000> usually
17:32:01 <glguy> niclasw: what are you attempting to express?
17:32:05 <basti_> .*? might be "anything, but dont munch maximally"
17:32:29 <basti_> that is, the regex up there would match startsajfdkslfdstopstop
17:32:51 <glguy> what sort of extension does that use?
17:32:52 <niclasw> exactly. it should be that at least.
17:32:59 <basti_> thats perl syntax.
17:33:37 <dons> yeah, that ? and the lack of \( \) looks like pcre syntax
17:33:59 <niclasw> i see. i thought it was extended posix. my bad.
17:34:38 <xpika_> @pl getDirectoryContents "."  >>= \x -> return (filter (isSuffixOf ".gif") x)
17:34:39 <lambdabot> filter (isSuffixOf ".gif") `fmap` getDirectoryContents "."
17:37:07 <xpika_> nice
17:37:32 <xpika_> is there a way to write a monad such that it can be called many times but only executed the first
17:38:15 <ddarius> xpika_: You could use a state monad to make a monadic action that would do that in the obvious way.
17:38:18 <glguy> man... the trolls are out in full force today on reddit
17:38:52 <Binkley> ?quote qwe1234
17:38:52 <lambdabot> qwe1234 says: c++ is the way it is for a very, very good reason.
17:38:59 <ddarius> Not so much on LtU.  Multiple Thorsten Altenkirch references though.
17:40:00 <dons> glguy: its one of those days
17:40:15 <dons> i recommend using  the 'report' button, to avoid entirely killing off the community
17:40:22 <dolio> glguy: I suspect 'X is faster than C in this benchmark' stories attract a lot of whining in general. :)
17:40:34 <dolio> Unless 'X' is Fortran or assembly.
17:40:39 <dons> yeah, ndm could have been a bit more diplomatic. its probably not harmful though
17:41:14 <dons> and there's no surprise really , that strongly typed compiled functional languages beat C sometimes. ocaml, clean, haskell all do, fairly regularly. big deal.
17:41:55 <dons> though there is a camp that says that compiler optimisation innovation ended in 1978
17:44:01 <glguy> its a good thing people have been upmodding system administration blogs and new product announcements
17:44:16 <glguy> I wouldn't know where to find information on that stuff otherwise
17:44:21 <Binkley> haha
17:44:22 <dons> heh
17:44:35 <dons> yeah, that is a relief.
17:44:37 <dolio> Is the '7 things Ghandi said' still high on there? :)
17:44:53 <glguy> some of these article I look at and wonder "who are the 15 idiots that modded this up? are they maybe just bots?"
17:45:06 <dons> at leats with ICFP, IFL, HW and CUFP coming up
17:45:11 <dons> we'll have 50 or so papers to talk about
17:49:12 <Cale> dons: did you see my sarcastic comment to sbrown?
17:49:58 <ddarius> reddit: Where #haskellers balance out their excessive helpfulness.
17:50:00 * glguy images the people with 123.. on their reddit nicknames did that because that's how high they learned to count, and they are really impressed with that
17:50:03 <glguy> so they show everyone
17:50:07 <glguy> imagines*
17:50:11 <blackdog_> is cabal-get ready for primetime yet? am getting a bit sick of chasing deps...
17:50:12 <newsham> did you know that discrete math is a bad thing to base computer programs on?
17:50:38 <ddarius> continuous math ho!
17:50:39 <dons> blackdog_: try it out. there's no reports of bad things, but not a lot of users
17:50:45 <monochrom> I knew that intuition is a bad thing to base computer programs on.
17:50:48 <Cale> Goto has been found to not be dangerous.
17:50:59 <basti_> discrete math gives you the ability to calculate the characteristic polynomial of a datatype
17:51:04 <Cale> apparently, according to sbrown123
17:51:06 <blackdog_> dons: you fill me with confidence :)
17:51:14 <basti_> i don't have a clue what that might be good for, but it sure sounds impressive
17:51:16 <dons> just telling it like it is.
17:51:21 <dons> should work, pretty simple program
17:51:59 <newsham> whats your datatypes eigenvalue?
17:52:15 <dons> Cale: :)
17:53:58 * Cale tries to come up with some argument for GOTO which mixes in ideas from Intelligent Design.
17:54:10 <Cale> Something about "Irreducible Complexity"
17:54:33 <newsham> look at how complex the control flow is.  it must have been intelligently designed.
17:58:09 <newsham> increased funding for faith-based programs leads to dramatic increase in usage of GOTO?
17:58:39 <Binkley> would Jesus write for loops?
17:59:22 <newsham> no, his operators work as if a day was like a thousand years and a thousand years was like a day
17:59:29 <newsham> obviously some sort of vector processing unit
17:59:49 <Binkley> so that's why his code always gets the time zones wrong
18:00:02 <newsham> that, and he's still on the mayan calander
18:00:08 <dolio> Clearly, Jesus writes all control flow straight in callCC.
18:01:31 <basti_> ...
18:01:48 <newsham> callcc jesus || goto hell;
18:02:49 <ddarius> cute
18:03:32 <dolio> Delimited continuations would be better than GOTO, as well. The Dybvig ones have 4 individual operators you can mess with, rather than 1. :)
18:03:35 <Saizan> i don't know if the weirdiest moment of this channel was now or some hours ago when they where talking about the interpetation of trascendental functions as types..
18:04:16 <Saizan> :D
18:04:21 <newsham> this prob isnt even in the top 10.
18:04:29 <Binkley> Well, what *isn't* a type?
18:05:11 <Saizan> Binkley: what's the equivalent of log(a) in an haskell datatype?:)
18:05:26 <Binkley> I don't know, but I'm sure Oleg would
18:06:26 <newsham> so there are aleph1 types now?
18:06:44 <Binkley> you need a special GHC flag
18:06:58 <newsham> will I need more memory?
18:07:07 <wli> Saizan: Hey, continued fractions as types are cool!
18:07:09 <Binkley> only a countably infinite amount
18:07:27 <newsham> i'm still running ghc on a finite state machine
18:08:23 <Saizan> wli: many weird things are cool :)
18:16:34 <ddarius> Well, what's a data type that satisfies, DT = T?
18:18:52 <monochrom> Where can I read the Dybvig delimited continuation?
18:19:29 <dolio> http://www.cs.indiana.edu/~sabry/
18:19:30 <lambdabot> Title: Academic Page for Amr Sabry
18:19:57 <dolio> "A Monadic Framework for Delimited Continuations" on that page.
18:20:10 <monochrom> whee. thanks a bunch.
18:20:26 <dolio> Oops, you'll have to click "Research" I guess. Didn't realize it used frames.
18:21:17 <monochrom> It's ok.
18:25:07 <iseff> is there a preferred method for transforming from ByteString -> String
18:25:18 <iseff> it seems this would be an easy/common thing to do, but i can't seem to find it
18:25:36 <iseff> (use case: taking ByteString from body of HAppS reqest and parsing it using HaXml)
18:26:42 <dons> iseff: Data.ByteString.unpack
18:27:01 <dons> but avoid moving to String whenever possible, its expensive in comparison to keeping it as bytestrings.
18:27:07 <dons> :t Data.ByteString.Char8.unpack
18:27:15 <lambdabot> Data.ByteString.Base.ByteString -> [Char]
18:27:32 <iseff> aah, doh, that was simple! thanks, dons
18:27:46 <dons> we need a bytestring xml parser.
18:27:56 <iseff> yeah, that'd be very nice and helpful
18:28:01 <monochrom> I wish I could read papers while taking showers. :)
18:28:10 <Shimei> With ReadWriteMode, will writing to the file overwrite the file like WriteMode will?
18:28:15 <dons> monochrom: now that would be cool
18:28:18 <Binkley> monochrom: that would be a long shower
18:28:20 <dons> project onto the shower door?
18:28:21 <Binkley> or maybe a short paper
18:28:55 <dons> btw, i'm not sure if people saw, but the icfp 07 papers lists is out, http://lists.seas.upenn.edu/pipermail/types-announce/2007/000568.html
18:28:57 <lambdabot> Title: [TYPES/announce] ICFP07 Accepted Papers, http://tinyurl.com/2fecdq
18:29:00 <dons> just not on the icfp website
18:29:03 <dons> lots of goodies in there
18:29:45 <ricky_clarkson> monochrom: Have baths instead - less splashing.
18:29:56 <ricky_clarkson> I was watching the SICP lectures in the bath earlier.
18:30:56 <augusts> dons: heading over here soon?
18:31:50 <dons> augusts: yep. sep 1. (to the US).
18:32:29 <dons> augusts: btw, we're trying to arrange another hackathon during the ICFP period, if you're interested, http://haskell.org/haskellwiki/Hac_2007_II
18:32:31 <lambdabot> Title: Hac 2007 II - HaskellWiki
18:32:45 <dons> most likely at the same time as IFL
18:33:17 <augusts> possibly
18:46:56 <xpika> hoogle filterM
18:46:59 <xpika> @hoogle filterM
18:47:00 <lambdabot> Monad.filterM :: Monad a => (b -> a Bool) -> [b] -> a [b]
18:47:00 <lambdabot> Control.Monad.filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]
18:47:00 <lambdabot> Data.Graph.Inductive.Query.Monad.graphFilterM :: GraphM m gr => (Context a b -> Bool) -> GT m (gr a b) [Context a b]
18:48:20 <dolio> @yarr
18:48:20 <lambdabot> I'll crush ye barnacles!
18:48:28 <Binkley> ?yow
18:48:28 <lambdabot> Yow!  I threw up on my window!
18:48:32 <xpika>  getDirectoryContents "." >>= filterM doesDirectoryExist
18:49:14 <dolio> Anyone have an example memorized of where Cont backtracks over a side effect with a transformer layered on top?
18:50:22 <dolio> In that it undoes said side effect?
18:53:05 <Nucleo> Looking at the prelude functions, how do mod and rem differ?
18:53:19 <dons> :t mod
18:53:21 <lambdabot> forall a. (Integral a) => a -> a -> a
18:53:27 <dolio> -1 `mod` 5
18:53:35 <dolio> > (-1) `mod` 5
18:53:37 <lambdabot>  4
18:53:39 <dolio> > (-1) `rem` 5
18:53:40 <dons> ?check \a b -> let _ = a :: Int ; _ = b :: Int in  mod a b == rem a b
18:53:40 <lambdabot>  -1
18:53:42 <lambdabot>  Exception: divide by zero
18:53:51 <Nucleo> I ... see
18:53:51 <dons> ?check \a b -> b > 0 ==> let _ = a :: Int ; _ = b :: Int in  mod a b == rem a b
18:53:52 <lambdabot>  Falsifiable, after 13 tests: -1, 3
18:54:03 <dons> behaviour in the presence of negative numbers :)
18:54:07 <dons> ?scheck \a b -> b > 0 ==> let _ = a :: Int ; _ = b :: Int in  mod a b == rem a b
18:54:08 <lambdabot>   Failed test no. 10. Test values follow.: -1, 2
18:54:11 <Nucleo> dons: ahh, okay. Thanks much.
18:54:24 <dons> ?scheck \a b -> a > 0 && b > 0 ==> let _ = a :: Int ; _ = b :: Int in  mod a b == rem a b
18:54:25 <lambdabot>   Completed 169 test(s) without failure.  But 133 did not meet ==> condition.
18:54:30 <dons> ?check \a b -> a > 0 && b > 0 ==> let _ = a :: Int ; _ = b :: Int in  mod a b == rem a b
18:54:31 <lambdabot>  Arguments exhausted after 315 tests.
18:54:43 <chessguy> @seen bos
18:54:43 <lambdabot> bos is in #haskell-soc, #haskell and #ghc. I don't know when bos last spoke.
18:54:47 <dons> ?check \a b -> a < 0 && b > 0 ==> let _ = a :: Int ; _ = b :: Int in  mod a b /= rem a b
18:54:48 <lambdabot>  Falsifiable, after 0 tests: -1, 1
18:54:55 <chessguy> 'evening ya'all
18:54:55 <Nucleo> For positive numbers though, I can use either?
18:55:04 <dons> yeah, see above `rem` is faster.
18:55:14 <Nucleo> ahh, k
18:55:32 <Nucleo> Thanks
18:55:42 <dons> ?check \a b -> a > 0 && b > 0 ==> mod a b == rem (a :: Int) (b :: Int)
18:55:43 <lambdabot>  Arguments exhausted after 281 tests.
18:55:50 <dons> ?check \a b -> a > 0 && b > 0 ==> mod a b == rem (a :: Integer) (b :: Integer)
18:55:51 <lambdabot>  Arguments exhausted after 304 tests.
18:56:04 <dons> ?check \a b -> a > 0 && b > 0 ==> mod a b == rem (a :: Word256) (b :: Word256)
18:56:04 <lambdabot>        add an instance declaration for       (Arbitrary (LargeWord.LargeKey W...
18:56:07 <dons> doh
18:56:58 <dolio> Huh, I guess Cont will undo WriterT, but not StateT.
19:00:36 <monochrom> StateT has been implemented so that StateT s (Cont ...) behave like ContT (State s ...)
19:01:31 <chessguy> @where rwh
19:01:31 <lambdabot> is http://www.realworldhaskell.org/blog/
19:01:56 <dolio> I guess that's handy.
19:02:21 <monochrom> i.e., "instance MonadCont m => MonadCont (StateT s m)" is written so that when you "long jump" the jump target gets the state value of the jump source.
19:03:13 <dolio> Same with ReaderT, I see.
19:04:00 <dolio> I guess Writer is the anomaly, especially since you can't layer ContT on it.
19:04:02 <mightybyte> I'm trying to decide on a Haskell web framework to use for a site I'm developing.  So far I've looked at HSP, WASH, and HAppS.  Can anyone tell me about the relative maturity/suitability of those projects or others that I may have missed?
19:04:16 <dons> WASH and HAppS are used in practice
19:04:23 <dons> HAppS is complex, but actively maintained
19:04:29 <dons> WASH is nice and theoretically sound
19:04:43 <dons> the braintreehemp.com.au site is running in wash, hpaste.org runs in happs
19:04:53 <dons> HSP i think is hmm, deprecated.
19:05:02 <chessguy> mightybyte, rumor has it that HApps is about to get a major facelift
19:05:10 <mightybyte> Ok, that's great information to start with.
19:05:20 <dolio> Or, I suppose there's no such distinction with ReaderT.
19:05:21 <chessguy> no real details on what all that entails
19:05:24 <dons> if its a simple site like braintreehemp, apache + wash might be easy
19:05:41 <dons> otherwise, more complex things, happs would be better. and you'll get support from #happs and the happs devs.
19:05:52 <chessguy> dons, i know WASH has its own server, is it not any good?
19:06:04 <mightybyte> Ahhh, what about database interfacing?
19:06:05 <dons> ah yes, it does. a version of the HWS iirc
19:06:23 <chessguy> WSP
19:06:38 <dons> mightybyte: happs tends to use internal haskell types , and serialises them (e.g. Data.Map). otherwise, you can interface to any db you want with hdbc or the other db bindings
19:06:43 <mightybyte> Are either of those preferable for a database-heavy app?
19:06:46 <chessguy> ah yes: "An extended version of Simon Marlow's webserver (hws) that runs WASH modules as servlets."
19:06:50 <dons> possibly wash, mightybyte
19:07:06 <monochrom> "instance MonadCont m => MonadCont (ReaderT m)" is written such that when you long jump, the jump target's ReaderT environment is determined by static scoping rather than the jump source.
19:07:11 <dons> but check with the happs guys about that. i know they do sometimes suggest happs can be used well without any database
19:07:24 <mightybyte> Interesting
19:07:40 <dons> happs does have the benefit of commercial backing, and active developers
19:07:59 <dons> so in the long run it might be a better bet - /me speculates
19:08:29 <dons> whereas WASH is good for simple stuff, but you'll need to fix any bugs yourself. (the braintreehemp devs found that)
19:08:33 <mightybyte> Yeah, but with happs you have to use their application server instead of being able to go with the old standby of Apache?
19:08:58 <glguy> using HAppS for a database heavy application would probably be tedious
19:09:08 <dons> that's my suspicion too, glguy
19:09:18 <dons> mightybyte: glguy wrote hpaste.org in happs, so he might have some recommendations
19:09:28 <glguy> that's my recommendation :)
19:10:00 <mightybyte> Heh
19:10:02 <Binkley> while we're on the subject of web stuff, is there an RSS parsing library in Haskell?
19:10:09 <glguy> I'd say that HAppS' active development is both an advantage and disadvantage at this point.
19:10:11 <Binkley> (I see an RSS-feed generating library on Hackage, but no parser...)
19:10:18 <mightybyte> Yeah, I can see that.
19:10:20 <glguy> the disadvantage is that its a moving target
19:10:24 <mightybyte> Right
19:10:29 <glguy> the advantage is that they are actively improving it
19:11:03 <dolio> Oh, actually...
19:13:06 <hpaste>  dolio pasted "Cont amusement" at http://hpaste.org/1610
19:13:28 <mightybyte> Is there any web page (maybe on the wiki) that summarizes the information in the responses I just got?
19:13:46 <Shimei> Say, what's a good way to force readFile to evaluate strictly? Can I do that?
19:13:47 <mightybyte> I didn't see anything jump out at me.
19:13:54 <Shimei> I'm trying to avoid file locking problems.
19:13:58 <Binkley> mightybyte: you could add one to the wiki :-)
19:14:18 <mightybyte> Binkley: Yeah, I'm thinking about that.  Just wondering if I would be duplicating anything.
19:14:43 <Binkley> mightybyte: be bold... worst-case, you're duplicating something and someone will eventually fix it
19:14:46 <monochrom> Binkley: http://cale.yi.org/index.php/HRSS is somewhat both a parser and a generator, since it's an aggregator.
19:14:48 <lambdabot> Title: HRSS - CaleWiki
19:14:48 <Binkley> better to have the information there :-)
19:15:05 <Binkley> monochrom: thanks, I'll check it out
19:15:23 <Cale> Well, it just generates HTML instead of proper RSS, but could easily be adapted for that.
19:15:43 <Cale> I mostly wrote it to learn the basics of HXT.
19:17:23 <monochrom> All the better, it only parses RSS, exactly what is sought :)
19:19:44 <dolio> There's something cute about 'run my continuation in a local environment.' :)
19:20:21 <monochrom> Heh
19:20:39 <ddarius> dolio: What is it?
19:20:50 <dolio> ddarius: http://hpaste.org/1610
19:21:01 <glguy> dolio: so that's the way to implement State in terms of Reader on Cont then ? :)
19:21:43 <ddarius> dolio: What is the cute thing?
19:21:52 <dolio> ddarius: Were you the one arguing with me that it was hard to remember how Cont affects other monads? I stand corrected, it is.
19:22:08 <ddarius> dolio: Um, I don't think so...
19:22:37 <monochrom> Forget remember. It's hard to predict too! ;)
19:22:55 <dolio> ddarius: Oh, I don't know. Perhaps you'd prefer 'evil' to 'cute'?
19:23:29 <glguy> is that the case for all monads, the the effects only bubble outwards?
19:23:40 <glguy> where outwards means "away from the base monad"
19:24:48 <monochrom> ContT r (Reader ...) is a bit of a surprise to me.
19:25:25 <glguy> err, I suppose I mean they bubble down towards the base monad
19:25:32 <glguy> and the effect isn't realized until you "run" it
19:25:33 <dolio> Actually, I guess that is the same case as WriterT.
19:25:49 <dolio> Cont can undo the 'local' and 'tell', but ContT cannot.
19:26:31 <xpika> @hoogle IO Bool -> IO () -> IO ()
19:26:31 <lambdabot> No matches, try a more general search
19:26:34 <dolio> But ContT (State s) and State s (ContT) are the same.
19:26:43 <dolio> Or something like that.
19:26:49 <monochrom> Yes.
19:27:09 <xpika> what do you use to match IO Bool?
19:27:21 <glguy> ?
19:27:21 <xpika> instead of if else
19:27:26 <dolio> @hoogle when
19:27:26 <lambdabot> Monad.when :: Monad a => Bool -> a () -> a ()
19:27:27 <lambdabot> Control.Monad.when :: Monad m => Bool -> m () -> m ()
19:27:33 <ddarius> You run it and then match the result.
19:27:43 <monochrom> do {x <- (m :: IO Bool); if x then ... else ... }
19:27:44 <glguy> xpika: you need to bind >>= to get to the Bool
19:27:49 <glguy> xpika: and then use if then else
19:28:29 <dons> kolmodin, dcoutts: perhaps our UArray binary instances could be a bit smarter -- they serialise via [elem] currently :/
19:28:35 <glguy> when and unless are monadic versions of if them else which only include the True and False branches respectively
19:33:39 <SamB> dons: the problem with that being that it doesn't give a size hint?
19:34:01 * sjanssen smells xmonad talk
19:34:39 <SamB> dons: Array has that problem too ;-P
19:35:32 <SamB> sjanssen: actually I was talking about presumed Binary instances for UArray
19:35:45 <sjanssen> ah :)
19:35:49 <SamB> <dons> kolmodin, dcoutts: perhaps our UArray binary instances could be a bit smarter -- they serialise via [elem] currently :/
19:35:53 <sjanssen> s'okay!  I can but in on that too
19:36:10 <SamB> I also butted in
19:36:21 <sjanssen> I propose adding putList :: [t] -> Put to the Binary class
19:37:12 <sjanssen> the same trick is used in Read/Show to achieve specialization on [Char]
19:37:58 <SamB> > read "['a','b']" :: String
19:37:59 <lambdabot>  "ab"
19:38:06 <SamB> whoah, neat
19:39:03 <sjanssen> SamB: huh.  I wouldn't expect that to work
19:39:17 <SamB> sjanssen: I bet it doesn't work in Jhc
19:39:25 <SamB> I have no idea if it is standard or not
19:40:38 <sjanssen> SamB: it isn't in the report.  Hugs doesn't do it
19:41:01 <SamB> GHC is crazy like that, huh?
19:41:23 <SamB> maybe it's left over from an older version of Haskell...
19:41:37 <SamB> I bet this isn't standard either
19:41:48 <SamB> > read "0x12345678"
19:41:49 <lambdabot>  305419896
19:42:11 <SamB> but I'd be happy if it was ;-)
19:45:33 <dons> SamB: hmm?
19:46:02 <dons> so its hmm, fast haskell day on reddit, eh?
19:46:13 <SamB> dons: what was that you were saying about [elem]
19:46:16 <SamB> and why's it bad?
19:46:35 <dons> you've got your data packed in memory, then you convert it to a list, take its length, and serialise that
19:46:40 <dons> so its going to cost you.
19:46:46 <SamB> oh, right, taking the length
19:47:09 <SamB> well, you could do rangeSize . bounds
19:47:13 <SamB> for the length
19:47:21 <SamB> that should be pretty good then
19:47:26 <sjanssen> yeah
19:47:26 <RyanT5000> is there any reasonable way to get the size of a GHC executable down?
19:47:40 <dons> RyanT5000: strip/split objs
19:47:51 <RyanT5000> ok
19:48:02 <SamB> ... you do remember that probably the packed data will need different packing/endianness anyway unless you are dealing with UArray Word8
19:48:08 <SamB> er.
19:48:13 <SamB> UArray i Word8
19:48:26 <dons> SamB: right. but we should loop'n'swap rather than go via lists
19:48:38 <dons> since serialising large unboxed arrays *should* be efficient
19:49:42 <sjanssen> dons: after removing the 'length' call on the list, going via lists shouldn't be that much of a problem
19:50:28 <SamB> dons: what's wrong with the list ? the lack of a size hint?
19:50:42 <SamB> otherwise you should be good to go with your list fusion...
19:50:49 <dons> sjanssen: yeah, that'd be the first thing to do
19:50:56 <sjanssen> dons: remember that mapM_ is a good consumer
19:50:57 <dons> sjanssen: but it means avoiding the list instance anyway
19:50:58 <RyanT5000> how big is the GHC runtime?
19:51:08 <SamB> dons: oh, sure, avoid the list instance ;-)
19:51:16 <RyanT5000> a stripped/split executable for me right now is 0.5 MB
19:51:22 <SamB> you don't need to store the length of the array again anyway do you?
19:51:46 <dons> SamB: yes you do.
19:52:06 <SamB> dons: is there something wrong with using the bounds?
19:52:42 <dons> that's the first thing the array instances should do.
19:52:43 <SamB> well... I suppose you've already set a format though...
19:52:59 <SamB> so I guess you do need to store the length again anyway
19:53:03 <dons> less talk, more code!
19:54:38 <SamB> I wrote some, uh, JHC code today
19:55:26 <SamB> it creates a dot file of the module dependancy graph (for the haskell sources to be compiled)
19:56:24 <SamB> the point being to visualize any cycles in your dependancy graph
19:57:06 <SamB> the hard part was figuring out how to get the graph out of the graph form...
19:57:26 <SamB> oh, and it looks like I have to rework my "foreign export" implementation a good deal...
19:57:44 <sjanssen> dons: just sent you a patch, double check it, in case I'm crazy
19:57:45 <kilimanjaro> jhc is the whole program compiler?
19:57:55 <chessguy> dons, can i privmsg you a question about rwh?
19:57:57 <SamB> kilimanjaro: ... something like that
19:58:11 <kilimanjaro> SamB, well what do you think of it as?
19:58:31 <SamB> it does do whole-program optimizations
19:58:35 <dons> thanks sjanssen
19:58:39 <dons> sjanssen: yep, doing so.
19:58:45 <SamB> but hopefully it can throw out parts of your program first ;-)
19:58:47 <dons> chessguy: of course. don't guarantee to answer immediatley though.
19:59:31 <kilimanjaro> SamB, cool. I've played around with both Stalin and MLton a bit
19:59:35 <kilimanjaro> I'll have to check out jhc
19:59:43 <dons> sjanssen: and the 'get' instances need tweaking too
19:59:47 <SamB> kilimanjaro: it isn't really usable yet ;-)
20:00:07 <sjanssen> dons: I think the gets should be okay
20:00:19 <sjanssen> dons: the format didn't change, and I don't know how I'd do it differently
20:00:36 <kilimanjaro> SamB, I wouldn't use it for anything important. It's not like I have *that* much free time on my hands
20:01:03 <dons> sjanssen: oh, you just write the length twice?
20:01:06 <dons> and we ignore it on the 'get' anyway
20:01:17 <kilimanjaro> I just wrote some little numerical programs and checked out how fast they could get optimized in a high level style vs me writing it custom in C
20:01:26 <kilimanjaro> mainly out of curiosity more than anything
20:01:30 <sjanssen> dons: I just stuck with the format, didn't wanna break serialization
20:02:01 <dons> sjanssen: i don't follow: we do 3 'puts', but 2 gets.
20:02:09 <dons>     put a = do
20:02:09 <dons>         put (bounds a)
20:02:09 <dons>         put (rangeSize $ bounds a)
20:02:09 <dons>         mapM_ put (elems a)
20:02:09 <dons>     get = liftM2 listArray get get
20:02:18 <sjanssen> dons: the second get :: [a]
20:02:24 <sjanssen> it does two gets
20:02:33 <sjanssen> should probably be more explicit about that, though
20:02:48 <dons> ah, it pretends we used the list instance to write
20:02:52 <dons> yes, I see.
20:03:27 <dons> ok, that'll do.
20:04:46 <timthelion> no it won't ,nothing but the best will do!
20:05:24 <SamB> perhaps do bnds <- get; xs <- get; return (listArray bnds xs)
20:06:07 <SamB> dons: and no it doesn't pretend that
20:06:26 <SamB> it just knows the format...
20:07:36 <dons> SamB, that doesn't make any sense.
20:07:40 <Saizan> well it uses the list instance to read
20:07:58 <dons> we write our own instance out, and use the list instance to read back. that's faking a list write.
20:08:14 <SamB> dons: okay, I see what you mean
20:08:15 <sjanssen> SamB: we are using special knowledge of the list instance
20:08:16 <SamB> yes it is
20:08:29 <SamB> because that is the way it was encoded before
20:08:33 <sjanssen> it is probably better to be explicit in this sort of code
20:08:48 <sjanssen> (where a change to the [] instance could break array serialization)
20:09:11 <SamB> sjanssen: well it would also break @vixen
20:09:18 <SamB> @vixen do you like it when we break you?
20:09:19 <lambdabot> sure, i definitely don't hate
20:09:33 <SamB> ... okay apparantly @vixen likes being broken
20:09:51 <sjanssen> dons: binary should have a compatibility suite
20:09:56 <sjanssen> @seen kolmodin
20:09:56 <lambdabot> kolmodin is in #friendly-coders, #xmonad, #darcs, #gentoo-haskell and #haskell. I last heard kolmodin speak 5h 1m 32s ago.
20:11:01 <dons> sjanssen: you'll have to tweak your patch -- i already tested and pushed the last one , with comments.
20:12:04 <sjanssen> @tell kolmodin have you considered a compatibility suite for binary?  Serialize a hunk of data, then make sure that newer versions of binary can still read and write it
20:12:05 <lambdabot> Consider it noted.
20:12:16 <sjanssen> dons: no problem
20:12:23 <ddarius> @vixen works again?
20:12:24 <lambdabot> no
20:12:26 <ddarius> Hah
20:12:40 <mm_freak> which Ix type should i use for best IOUArray performance?  Int?
20:12:42 <chessguy> @vixen
20:12:43 <lambdabot> Does your mommie know you're here, little naughty boy?
20:13:02 <sjanssen> mm_freak: use zero-indexed Int
20:13:36 <mm_freak> sjanssen: that is?
20:13:37 <dons> mm_freak: definitely Int, then you get unchecked read and writes if you want them
20:13:44 <mm_freak> ah ok
20:13:56 <sjanssen> mm_freak: later, when you're confident your program is correct, it will be easy to switch to unchecked reads for speed
20:14:03 <mm_freak> dons: unchecked in that a buffer overflow may occur?
20:14:10 <SamB> mm_freak: if you want!
20:14:19 <mm_freak> k
20:14:34 <sjanssen> dons: unchecked means reading and writing from arbitrary addresses, yeah
20:14:35 <mm_freak> well, i'm a C programmer, so i'm pretty careful about array bounds =)
20:14:40 <dons> mm_freak: in that it won't throw  an exception if you're wrong.
20:14:52 <dons> which is great, since usually you try not to write code that depends on wrong indexes
20:14:54 <ddarius> Bah! Prove that it can't happen in the type system then you don't need no stinkin' runtime checks.
20:15:00 <dons> heh
20:15:10 <SamB> ddarius: tis hard!
20:15:20 <dons> not too hard, just a little bit hard
20:15:21 <SamB> er... s/tis/'tis/
20:15:38 <dons> its dependent types 1O1.
20:15:43 <SamB> dons: depends what you are doing
20:16:07 <SamB> for instance, sometimes it's virtually impossible, just about equivalent to the halting problem
20:16:17 <Saizan> can Catch catch it?
20:16:29 <ddarius> It's easy to make it equivalent to the halting problem.
20:16:38 <SamB> Saizan: Catch knows, what, negative, zero, one, and more than one?
20:17:14 <crazy_coder> Is it necessary that whenever we use the do statement, that the output has type IO XYZ     ?
20:17:21 <ddarius> no
20:17:45 <Saizan> the output must have type m XYZ where m is a Monad
20:17:47 <ddarius> It must have type m XYZ for some Monad m (arguably)+
20:18:09 <crazy_coder> ok
20:18:15 <ddarius> :t do 2
20:18:18 <lambdabot> forall (t :: * -> *) t1. (Num (t t1)) => t t1
20:18:25 <SamB> +<-what's the squiggly fine print that goes with this +?
20:18:32 <crazy_coder> This must be the type of final statement of do , or all statements must have this type ?
20:18:48 <ddarius> SamB: Actually that was a typo.
20:19:01 <SamB> okay how about this "arguably" here
20:19:03 <SamB> what is that for
20:19:10 <monochrom> :type do { [1,2,3] }
20:19:22 <monochrom> @type do { [1,2,3] }
20:19:24 <lambdabot> forall t. (Num t) => [t]
20:19:24 <ddarius> monochrom: Yeah, but that's actually okay.
20:19:32 <ddarius> :t do 'a'
20:19:34 <lambdabot>     Couldn't match expected type `t t1' against inferred type `Char'
20:19:34 <lambdabot>     In the expression: 'a'
20:19:54 <ddarius> crazy_coder: All ish.
20:20:09 <ddarius> SamB: According to the Report, do x ~> x
20:20:18 <Saizan> crazy_coder: in do z <- foo; let x = quuzx; bar;  both foo and bar must have type m a with the same m, x can have any type
20:20:22 <SamB> ddarius: oh, true ;-)
20:20:24 <SamB> I remember that now
20:20:41 <SamB> so did they fix that GHC bug yet?
20:21:33 <crazy_coder> Saizan: Ok so in otherwords , when we use let, we can actually not bother about the type , right ?
20:22:06 <ddarius> SamB: Um... it's not a bug worth fixing.
20:22:08 <Saizan> crazy_coder: wrt do-notation, yes
20:23:15 <Saizan> crazy_coder: note that let merely defines a name for an expression, it doesn't perform any related side-effect
20:23:45 <SamB> ddarius: I suppose it *would* be easier to just make sure Haskell' does what you would expect ;-)
20:24:03 <SamB> ddarius: though actually I think it would be easy to fix...
20:24:21 <ddarius> It is likely easy to fix, but I don't think it's actually a problem in practice.
20:24:32 <SamB> *probably* it isn't
20:24:32 <crazy_coder> Saizan: Just like a let statement, is there anything else that one may use ?
20:24:42 <SamB> since probably a GHC user would have noticed by now
20:24:46 <SamB> and it would have been fixed
20:24:58 <Saizan> crazy_coder: for what?
20:25:08 <SamB> if any code generator depended on it being implemented as the report says...
20:25:45 <ddarius> If a code generator wrote do E for some E that doesn't have a monadic type then it should be smacked.
20:25:59 <Saizan> however do should introduce a Monad m => context at this point, you only get confusing error messages right now
20:26:23 <ddarius> Arguably that's not standard.
20:26:41 <SamB> I believe hugs implements it correctly
20:26:45 <SamB> JHC likely does too
20:27:12 <SamB> (I expect that it corresponds with desugaring before typechecking instead of after ;-)
20:27:29 <crazy_coder> Saizan: Using a let statement, I can put in code that has no side effect, Is there something similar
20:27:36 <SamB> what?
20:27:43 <SamB> hugs does it wrong?
20:27:45 * SamB is confused
20:29:24 <Saizan> crazy_coder: mmh, i'm confused, don't you just use let? the last expression has to be of type m a anyway, if you're trying to escape from the IO monad desist, because you can't :)
20:31:06 <crazy_coder> Saizan: :) Till I learn it, i have to....... else I keep getting parse errors :(
20:31:57 <SamB> crazy_coder: you just don't want to write IO code?
20:31:59 <Saizan> can you paste the code?
20:32:27 <SamB> try "main = print (1+1)"
20:34:11 <crazy_coder> I will, but not now, let me try it, I just don't want you all to give me quick solutions. I won't learn anything then....Thanks
20:34:37 <crazy_coder> SamB: what I am writing now requires only IO and some logic......
20:35:20 <crazy_coder> SamB: i can somehow get the logic right, but making it work is a bit tough, I am trying
20:36:13 <monochrom> do { x <- readLn; let y = f x; print y }
20:37:40 <crazy_coder> the above code is very standard, found in all books, its pretty easy to see how do works here , but when writing code yourself, sometimes it gets confusing........
20:49:38 <MarcWeber> CMod CInt .. When did this change?
20:52:26 <dons> ?users
20:52:26 <lambdabot> Maximum users seen in #haskell: 355, currently: 313 (88.2%), active: 11 (3.5%)
20:52:30 <dons> hey.
20:52:44 <ddarius> When was their a big jump in the number of people?
20:53:05 <dons> hmm starting around September last year
20:53:12 <Pseudonym> Eternal September
20:53:13 <dons> we rapidly went from 200 to 300 by December
20:53:18 <dons> zactly
20:53:25 <ddarius> dons: No, no.  I mean from 300ish to 350?
20:53:38 <dons> 350 in a bout May, iirc
20:55:25 <dons> actually, 07.06.27
20:55:35 <MarcWeber> This has broken more than 10 hackage packages..
20:55:52 <dons> this time last year we had 230
20:55:58 <dons> MarcWeber: ?
20:56:05 <dons> oh, the CInt thing. hmm
20:56:24 <dons> 06.10.09 250.
20:56:32 <dons> 06.12.18 300
20:56:43 <dons> 07.06.27 350
20:57:19 <glguy> idling in #haskell is for people with too much time on their hands
20:57:36 <MarcWeber> I'll try a simple sed command.
20:57:36 <MarcWeber> Or I'll hack cabal to do this.
20:57:44 <ddarius> glguy: I'm betting most of the people who are idled aren't actually at the computer.
20:58:16 <Excedrin> idlers suck am i rite guys?
20:58:56 <RyanT5000> is the winning implementation of ICFP 2006 available?
20:59:11 <ddarius> www.icfpcontest.org
20:59:35 <RyanT5000> i didn't see it there
21:00:25 <glguy> ddarius: I was making an attempt at irony or something related
21:06:27 <dons> MarcWeber: I think this makes a good case for testing hackage packages before GHC releases go out.
21:14:39 <hpaste>  int80_h pasted "Revege of Yaht Perplexity." at http://hpaste.org/1611
21:16:47 <brad_> can someone tell me why "runhaskell Setup.lhs haddock" is choking on this line: "Build-Depends:base, Network.HTTP, Network.URI"
21:16:48 <Sgeo> !fact Goldilocks
21:17:07 <ddarius> ?fack Goldilocks
21:17:07 <lambdabot> I know nothing about goldilocks
21:17:57 <dons> brad_: Network.HTTP, Network.URI aren't packages
21:18:01 <dons> that's the 'network' package
21:18:23 <brad_> dons - ah! thanks.
21:18:56 <brad_> dons - is this not maybe a bug? shouldn't we marshall by module name and let the package manager figure out what installed it?
21:19:16 <brad_> seeing as exposed-modules is a cabal field?
21:19:25 <wli> I wrote down some thoughts on language shootouts.
21:20:44 <brad_> well in any case thanks for the advice and assistance! i should have my hackage package up soon(ish)
21:20:50 <int80_h_> anyone have any ideas on my code errors?
21:20:53 <brad_> take care!!
21:23:16 <monochrom> There are no code errors.
21:24:03 <int80_h_> why won't it compile the?
21:24:05 <int80_h_> then?
21:24:34 <monochrom> I mean I haven't read your paste.
21:24:53 <int80_h_> oh would you then?
21:24:59 <monochrom> I am reading now.
21:25:07 <int80_h_> yippee!
21:26:33 <monochrom> listFoldl f a Nil = a  ?
21:26:39 <monochrom> Does that make more sense?
21:28:01 <brad_> another cabal question:
21:28:04 <brad_> i run
21:28:06 <brad_> runhaskell Setup.lhs build
21:28:11 <brad_> on a package i am building
21:28:13 <brad_> and i am told:
21:28:23 <brad_> Could not find module `Network.HTTP': it is a member of package HTTP-3000.0.0, which is hidden
21:28:35 <brad_> so i do:
21:28:37 <brad_> ghc-pkg expose HTTP-3000.0.0
21:28:39 <brad_> and get:
21:28:46 <brad_> ghc-pkg: cannot find package HTTP-3000.0.0
21:28:54 <brad_> but i did install it from hackage....
21:28:56 <monochrom> You need to download and install the HTTP package.
21:29:09 <int80_h_> monochrom, loooking it over
21:29:20 <monochrom> Interesting. "ghc-pkg list" what does that say?
21:29:52 <int80_h_> monochrom, that's what I meant, thanks
21:29:53 <brad_> here are the last two lines:
21:29:55 <brad_> /home/brad/.ghc/i386-freebsd-6.6.1/package.conf: HTTP-3000.0.0
21:30:08 <brad_> so i have it installed, but in my "local" dir
21:30:23 <int80_h_> still getting same error monochrom
21:30:23 <brad_> there are lots of package in /usr/local/lib/ghc-6.6.1/package.conf:
21:31:10 <monochrom> int80_h_: I have this question about the second line. Where is the recursion? :)
21:31:10 <brad_> should i try installing HTTP into the central lib location, not my home dir?
21:31:10 <int80_h_> [thom]     Oh, davek already said Floods. He always pre-steals  my jokes.
21:31:11 <int80_h_> [davek]    Locusts
21:31:11 <int80_h_> [dsj]      airplane about to crash on it..
21:31:11 <int80_h_> [rfrank]   oooooh
21:31:13 <int80_h_> [thom]     I'd probably stay for frogs.
21:31:16 <int80_h_> [wonko]    what about when the underpants gnomes tell you to  in your dreams?
21:31:18 <int80_h_> [davek]    I understand some cultures think locusts are delicious
21:31:21 <int80_h_> [thom]     Cicadas are supposed to be pretty nice.
21:31:23 <int80_h_> [thom]     I've never met an underpant gnome in my dreams.
21:31:26 <int80_h_> [davek]    If I ever do I'm blaming wonko
21:31:28 <int80_h_> oops im sorry
21:31:45 <int80_h_> *Datatypes> :l DT.hs
21:31:45 <int80_h_> [1 of 1] Compiling Datatypes        ( DT.hs, interpreted )
21:31:45 <int80_h_> DT.hs:62:0:
21:31:45 <int80_h_>     Warning: Pattern match(es) are overlapped
21:31:45 <int80_h_>              In the definition of `listFoldl': listFoldl f a (Cons x xs) = ...
21:31:47 <int80_h_> Ok, modules loaded: Datatypes.
21:31:58 <int80_h_> that's the error
21:32:21 <sjanssen> int80_h_: that's just a warning
21:32:30 <monochrom> brad_: Sorry, I have no experience with local package installations, so I can't tell.
21:32:48 <brad_> okay monochrom, maybe i will try installing HTTP without --user and see what happens
21:33:00 <brad_> thanks anyway!!
21:33:02 <int80_h_> hmm
21:33:27 <monochrom> int80_h_, sjanssen: with the first line being "listFoldl f a Nil = a", there is no way we can get an overlapped pattern with the second line.
21:33:52 <sjanssen> brad_: does the package have HTTP in the build-depends?
21:34:00 <brad_> ah! i think you just have to pass --user to ghc-pkg expose!
21:34:08 <brad_> if you installed it as --user
21:34:16 <sjanssen> brad_: you shouldn't have to do any of that
21:34:23 <sjanssen> brad_: what are you trying to build?
21:35:00 <brad_> sjanssen - i am trying to build my own library which is a trivial and idiotic wrapper to Network-HTTP, which provides "head", "get" and supports redirects
21:35:11 <sjanssen> brad_: add HTTP to build-depends
21:35:28 <brad_> yes sjanssen, i have it in there
21:35:39 <sjanssen> oh, odd
21:36:04 <int80_h_> *Datatypes> listFoldl (+ 2 (Cons 1 $ Cons 2 $ Cons 3 $ Nil))
21:36:04 <int80_h_> <interactive>:1:10:
21:36:04 <int80_h_>     Occurs check: cannot construct the infinite type: t = List t1 -> t
21:36:04 <int80_h_>     Probable cause: `+' is applied to too many arguments
21:36:04 <int80_h_>     In the first argument of `listFoldl', namely
21:36:06 <sjanssen> brad_: did you run configure before it was in build-depends?
21:36:06 <int80_h_>         `(+ (2 ((Cons 1) $ ((Cons 2) $ ((Cons 3) $ Nil)))))'
21:36:09 <int80_h_>     In the expression:
21:36:11 <int80_h_>         listFoldl ((+ (2 ((Cons 1) $ ((Cons 2) $ ((Cons 3) $ Nil))))))
21:36:14 <int80_h_> *Datatypes>
21:36:17 <int80_h_> erm
21:36:23 <brad_> hmm, cabal still cannot find HTTP after i exposed it
21:36:30 <brad_> i have rerun configure and build steps
21:36:35 <brad_> oh well :(
21:36:36 <Saizan> brad_: rerun configure?
21:36:39 <monochrom> int80_h_: OK. Then you should consider again this:
21:36:45 <int80_h_> *Datatypes> listFoldl (+ 2 (Cons 1 $ Cons 2 $ Cons 3 $ Nil))
21:36:51 <monochrom> <monochrom> int80_h_: I have this question about the second line. Where is the recursion? :)
21:37:07 <dons> you know, we really could concentrate peoples minds with a many core shootout
21:37:22 <int80_h_> xs is passed back to erm...
21:37:40 <monochrom> to the wrong guy.
21:38:27 <monochrom> The "infinite type" error is due to xs passed to the wrong guy.
21:38:40 <int80_h_> I changed it to
21:38:51 <int80_h_> listFoldl f a (Cons x xs) = listFoldl (f a xs)
21:39:07 <monochrom> insufficient number of parameters on the right hand side.
21:39:19 <monochrom> (and when do you use x?)
21:39:32 <Saizan> (and xs is still passed to the same wrong guy)
21:39:52 <int80_h_> you use x when you want the first element in the list. It's Car
21:39:59 <int80_h_> right?
21:40:04 <int80_h_> and xs is Cons?
21:40:36 <Saizan> xs is cdr in lisp, i think
21:40:44 <monochrom> If the input list is Cons 1 (blah blah), then x is 1, xs is blah blah
21:41:08 <monochrom> Cons is always Cons.
21:41:49 <monochrom> You match Cons 1 (blah blah) to Cons x xs. Cons to Cons, 1 to x, blah blah to xs.
21:41:49 <int80_h_> [1 of 1] Compiling Datatypes        ( DT.hs, interpreted )
21:41:49 <int80_h_> DT.hs:62:0:
21:41:49 <int80_h_>     Warning: Pattern match(es) are overlapped
21:41:49 <int80_h_>              In the definition of `listFoldl': listFoldl f a (Cons x xs) = ...
21:41:49 <int80_h_> Ok, modules loaded: Datatypes.
21:42:02 <int80_h_> listFoldl f a x = a
21:42:02 <int80_h_> listFoldl f a (Cons x xs) = listFoldl f a xs
21:42:19 <monochrom> Sigh. listFoldl f a Nil = a.  how many more times should I repeat it?
21:42:29 <ddarius> int80_h_: It's not best-match first, it's first listed match first.
21:42:56 <sjanssen> monochrom: more times!
21:43:07 <int80_h_> sorry monochrom
21:43:36 <sjanssen> or, perhaps, numtimes n = 1 + numtimes (n-1); numtimes 0 = 0 -- :)
21:43:40 <ddarius> Aleph_Naught!
21:43:45 <int80_h_> okay I changed it
21:43:45 <dobblego> > "listFoldl f a x = a" == "listFoldl f a Nil = a"
21:43:46 <lambdabot>  False
21:44:05 <int80_h_> listFoldl f a Nil = a
21:44:05 <int80_h_> listFoldl f a (Cons x xs) = listFoldl f a xs
21:44:08 <int80_h_> is that right?
21:44:12 <dobblego> no
21:44:26 <monochrom> The second line doesn't use x. That should be fishy.
21:44:57 <int80_h_> Cons x on the right
21:45:06 <int80_h_> does that not mean I am using x?
21:45:07 <monochrom> What do I use listFoldl for?  I probably use it to add up numbers.
21:45:15 <dobblego> you're not using x on the right side of the definition
21:45:29 <dobblego> you've only defined it as an argument on the left side
21:45:47 <monochrom> How do I use listFoldl to sum up numbers?  I probably write it as listFoldl (+) 0 (Cons 1 (Cons 2 Nil)).
21:45:53 <dobblego> this fact should arouse suspicion that your definition is incorrect
21:45:54 * ddarius has no idea what mental model int80_h_ is using for pattern matching.
21:46:39 <monochrom> If I evaluate that, what should the computer do?  The first step probably should go like: listFoldl (+) 0 (Cons 1 (Cons 2 Nil)) = listFoldl (+) (0+1) (Cons 2 Nil)
21:46:41 <dobblego> listFoldl f a (Cons x xs) {- x is an argument -} = listFoldl f a xs {- but you never use it; *suspicion* -}
21:47:07 <ddarius> Yes, I give const the evil eye every time I see it.
21:47:09 <ddarius> @src const
21:47:09 <lambdabot> const x _ = x
21:47:14 <ddarius> Grr.
21:47:17 <dobblego> haha :)
21:47:33 <Saizan> ddarius: at least const uses _ !
21:47:51 <ddarius> @. djinn type const
21:47:54 <lambdabot> f a _ = a
21:48:08 <dobblego> int80_h_, ddarius' point is that this reasoning does not apply to all functions, but it at lest does to left folding
21:48:17 <dobblego> *least
21:48:27 <int80_h_> thanks guys. I will ponder this on my way home
21:48:29 <ddarius> Actually, I was mostly just being an ass.
21:48:36 <Shimei> GUI development with Glade is so horrible. Why is the world so cruel?
21:48:45 * Shimei wonders how feasible a Qt Haskell binding would be
21:48:52 <ddarius> Shimei: Don't use Glade.
21:49:24 <bos> what's wrong with glade? actually, don't answer that. it's pretty awful.
21:49:33 <bos> Qt would be a royal pain.
21:49:42 <bos> haskell has no C++ FFI.
21:49:55 <bos> and Qt is an enormous sprawl of C++.
21:50:03 <ddarius> bos: Not even.
21:50:15 <ddarius> What is that thing called, moc?
21:50:22 <bos> right.
21:50:31 <bos> i didn't want to bring that up :-)
21:50:51 <bos> but i would estimate Qt bindings as requiring about two years of full-time work for one person.
21:51:04 <Shimei> How does Qt/Ruby do the bindings? Just brute force and lots of work?
21:51:10 <SamB_XP> or pyqt?
21:51:22 <bos> pyqt has taken years of work.
21:51:23 <Shimei> s/Qt/PyQt/
21:51:25 <sjanssen> bos: there are C bindings IIRC
21:51:33 <SamB_XP> or perhaps we should ask if Eiffal has bindings?
21:51:34 <sjanssen> part of the KDE project, or something
21:51:49 <hpaste>  monochrom annotated "Revege of Yaht Perplexity." with "desired behaviour" at http://hpaste.org/1611#a1
21:51:57 <Shimei> (BTW: The thing that prompted me to complain about glade is that the builder has frozen on me... argh!)
21:52:10 <ddarius> Shimei: Write your own.
21:52:26 <ddarius> (A bit of a chicken and the egg problem though)
21:52:52 <brad_> errrr, i am still trying to get cabal to recognize HTTP...i have installed HTTP as both --user and in the global pkg dir, i have "exposed" them both and checked that the modules are exposed with "describe", but i still use Network.HTTP in my own module and build with cabal
21:52:55 <Shimei> Yeah. I really want a Qt binding, really. Or maybe a good Tk binding if Tk's theming is good enough now.
21:53:03 <SamB_XP> and then there's your "which XML toolkit shall I use?" problem, too
21:53:09 <brad_> Could not find module `Network.HTTP': it is a member of package HTTP-3000.0.0, which is hidden
21:53:46 <SamB_XP> Shimei: tk has theming besides "what colors do you want our 95/motif-esque GUI in?"
21:54:08 <Shimei> Apparently there are Gtk-style/XP-style themes too.
21:54:16 <brad_> even --force does not help
21:54:52 <Saizan> brad_: you haven't mentioned the thing you really need: do you have HTTP in build-depends?
21:55:23 <Shimei> Tk theming: http://tktable.sourceforge.net/tile/screenshots/windowsxp.html
21:55:24 <lambdabot> Title: Tile: Windows XP screenshots
21:55:26 <brad_> i was told to include it as "network", here is the line:
21:55:28 <brad_> Build-Depends:       base, network
21:55:54 <brad_> should i list it explicitly saizan?
21:56:01 <Saizan> brad_: network is just for Network.Socket et. al. Network.HTTP is in the HTTP package
21:56:37 <Saizan> so yes, you've to list HTTP
21:56:41 <brad_> YES!
21:56:45 <brad_> you are correct saizan
21:56:48 <brad_> thank you
21:57:02 <brad_> sorry if it seemed i was getting frustrated and a little crabby
21:57:06 <Saizan> packages are collections of modules regardless of any hierarchy :)
21:57:46 <brad_> i wish that were changed..the package manager should know what packages modules are in
21:57:57 <sjanssen> brad_: it's an intentional choice
21:58:00 <glguy> it does
21:58:14 <sjanssen> brad_: we want accurate info in build-depends so your users know what to install
21:58:29 <SamB_XP> sjanssen: perhaps he justs wants more helpful error messages?
21:58:43 <sjanssen> SamB_XP: yeah, that oughta be fixed
21:58:47 <brad_> well i would say Build-Depends: should only list module names
21:58:56 <brad_> resolving those names i would leave to the package manager
21:59:07 <SamB_XP> brad_: oh, no, we don't want that
21:59:08 <brad_> well i should shut my mouth its clear i am just confused
21:59:10 <glguy> then you wouldn't know what packages to install!
21:59:12 <Saizan> brad_: a module names doesn't help your user finding which package it should install
21:59:35 <brad_> saizan - a proper cpan-like repl would know how to deal with this - why not just say:
21:59:44 <brad_> hackage> install Network.HTTP
21:59:45 <SamB_XP> also, what if there are different packages with modules of the same name in them?
21:59:51 <sjanssen> brad_: there can also be some overlapping between module names
22:00:07 <brad_> SamB_XP - isn't that a problem in any case?
22:00:10 <SamB_XP> surely not a happy circumstance, but one that will happen
22:00:32 <SamB_XP> brad_: only if you try to use both packages in one program/package...
22:00:45 <Saizan> i wonder, what if i need to use both?
22:00:57 <SamB_XP> Saizan: then you DO have a problem :-(
22:01:25 <brad_> i guess i am a bit miffed at having to track package names, oh well
22:01:43 <SamB_XP> there are a lot less of them than module names
22:01:47 <sjanssen> brad_: tracking module names would be longer, anyway
22:01:59 <SamB_XP> and I think GHCi should be able to help?
22:02:24 <brad_> well in any case i am closer now to having my package ready
22:02:29 <brad_> thanks to this helpful crew!
22:03:03 <brad_> thanks to everyone for helping me
22:03:10 <Saizan> it's common to struggle with build-depends the first time, should we have this written somewhere?
22:03:20 <brad_> i appreciate you letting me interrupt with questions
22:03:38 <glguy> yes, lets get back to our off topic conversation :)
22:03:39 <SamB_XP> what were you interrupting?
22:03:57 <brad_> hopefully not much sam
22:04:04 <Saizan> brad_: this channel is here to answer questions basically :)
22:04:15 <brad_> okay well i best be off to finish my hackage work
22:04:16 <dons> brad_: please, ask away!
22:04:19 <SamB_XP> Saizan: also to ask them !
22:04:26 <brad_> thanks again, bye for now!
22:04:46 <glguy> oops , he got away
22:05:07 <SamB_XP> at least he got away with an answer ;-)
22:05:35 <dolio> I thought we were here to discuss category theory and abstract algebra.
22:05:56 <ddarius> That's why I'm here.
22:06:06 <dolio> And how that relates to getting better-than-C performance. :)
22:06:17 <SamB_XP> heh
22:06:27 <sjanssen> I think we need to stop comparing to C
22:06:38 <sjanssen> let's make some pretty charts showing how GHC is faster than Ruby
22:06:39 <SamB_XP> sjanssen: what do you want to compare with?
22:06:41 <ddarius> Yes!  Let's beat assembly!
22:06:46 <SamB_XP> ... Ruby?
22:06:48 <SamB_XP> why?
22:06:58 <SamB_XP> ddarius: assembly is really slow usually
22:07:11 <sjanssen> SamB_XP: it has a really crappy implementation -- it's like shooting fish in a barrel
22:07:35 <SamB_XP> sjanssen: well, even if it was a fairly nice implementation, I wouldn't expect it to be exactly fast
22:07:36 <ddarius> It'd be difficult to make a good implementation of Ruby.
22:07:43 <SamB_XP> so that's exactly why I ask "why?"
22:07:54 <scs> SamB_XP: assembly is'nt slow...
22:07:57 <ddarius> I don't know.  Self was fairly skippy.
22:08:02 <SamB_XP> true.
22:08:14 <SamB_XP> Psyco doesn't do too badly either, does it?
22:08:26 <thoughtpolice> hopefully ruby 2.0 will increase code quality to some extent
22:08:28 <dolio> We should go after lisp. Make up a bunch of benchmarks that show Haskell is better, and then post it on comp.lang.functional/lisp and spark a 200+ post thread.
22:08:30 <SamB_XP> Self has never been particularly skippy on x86 though :-(
22:08:31 <dons> its around hugs' speed, SamB_XP
22:08:32 <sjanssen> SamB_XP: because we can make pretty charts that show Haskell at 300% faster, rather than matching or slightly losing to C
22:08:36 <thoughtpolice> and rubinius is looking okay but I haven't tried any builds
22:08:40 <glguy> ruby 1.x came into existence by coincidence
22:08:48 <glguy> after years of coding it just happened to be
22:08:48 <ddarius> Don't you lose some of the functionality using Psyco or at least it doesn't really optimize code that's not nice well?
22:08:51 <dons> sjanssen: i agree re. C
22:09:05 <dons> Haskell is competing for Ruby/Python guys (and OCaml.. .but *ssh*)
22:09:11 <wli> Comparisons between compiled and interpreted languages aren't all that meaningful.
22:09:19 <thoughtpolice> glguy: monkeys at a terminal?
22:09:21 <SamB_XP> ddarius: you do lose some slight functionality and/or don't get optimizations for nasty code
22:09:23 <Shimei> JRuby might be interesting to look at.
22:09:27 <dons> comparisons between tools you can use use right now are useful though
22:09:35 <ddarius> The people who use ruby don't care about performance...
22:09:44 <Pseudonym> Grrrrr.
22:09:50 <glguy> or correctness
22:09:50 <thoughtpolice> jruby is even slower than stock C-ruby
22:09:53 <glguy> but code-coverage
22:09:55 <Pseudonym> Sorry, the word "performace" is thrown around like it means only one thing.
22:10:00 <thoughtpolice> it merely fills a gap
22:10:06 <SamB_XP> oh, you mean because they might in theory *compete*
22:10:15 <wli> If you're going to compare vs. an interpreter #!/usr/bin/haskell-interpreter is the appropriate comparison.
22:10:15 <Pseudonym> And that annoys me.
22:10:35 <SamB_XP> wli: oh? why?
22:10:45 <SamB_XP> let me know when you find a Ruby compiler
22:10:50 <SamB_XP> or a Python compiler
22:10:55 <wli> SamB_XP: There are Haskell interpreters.
22:10:56 <dons> wli, no, you want to compare the main language implementations
22:11:05 <dons> if they can't get their act together, too bad.
22:11:20 <SamB_XP> you can compare interpreter vs. interpreter, or fastest vs. fastest
22:11:31 <ddarius> Yes, but it's bloody obvious to "everybody" that comparing to ruby is shooting fish in a barrel.
22:11:33 <glguy> interpreter vs interpreter doesn't mean anything
22:11:36 <dons> most widely used vs most widely used
22:11:42 <jcreigh> why *can't* you compare compiled vs. interpreted? Why do interpreters get a free ride?
22:11:52 <glguy> no one says "I'm going to use the GHC interpreter for this project because ruby doesn't have a compiler"
22:11:54 <SamB_XP> glguy: it might mean "okay so this is how much time you'll waste playing with code"
22:12:04 <dons> the case we want to make is that haskell is a better choice for jobs people use python for
22:12:27 <SamB_XP> remember the *purpose* of GHCi
22:12:38 <SamB_XP> it is: to be *interactive*
22:12:40 <ddarius> dons: Then, it would seem that speed is not the issue that makes python the "better" choice.
22:12:40 <SamB_XP> not to be *slow*
22:13:03 <wli> Pseudonym: Well, properly done, one would break down "language performance" using something like principal components analysis or indepedent components analysis or something on that order into multiple axes.
22:13:06 <glguy> python peole like python because they think that its easy to read and write
22:13:11 <glguy> they want "simple solutions"
22:13:16 <glguy> they don't want monadic abstrations
22:13:23 <dons> they want to build bigger, cleaner systems than they used to in perl or java
22:13:36 <ddarius> They do?
22:13:38 <sjanssen> ddarius: sure, but if we can show that Haskell has the same or less development time, and runs quicker as a side effect?
22:13:41 <SamB_XP> so basically we are obligated to show that Haskell has at least comparable performance and cleaner code
22:13:43 <wli> dons: I'm not so sure of that, either.
22:13:49 <Pseudonym> wli: Some Linux kernel hackers used to mean that "performance" meant the amount of work that could be done just prior to overload.
22:13:57 <Pseudonym> Thankfully, they've grown up now.
22:14:01 <ddarius> sjanssen: Then you need speed -and- development time, and even then...
22:14:20 <dons> but yes, we need to stop comparing against C
22:14:28 <glguy> and hype, you have to feel like you are super leet because you are using the language
22:14:29 <wli> Pseudonym: That is a performance metric, essentially workload capacity.
22:14:34 <dons> the language decisions are between things like: ruby, erlang, haskell, Java
22:14:35 <glguy> at least if we want to get these converts
22:14:40 * Sgeo should learn C eventually :/
22:14:48 <ddarius> Sgeo: Why?
22:14:48 <Pseudonym> wli: Correct.  but it's only one performance metric.
22:14:53 <wli> Pseudonym: There are, of course, others.
22:15:04 <Sgeo> C = often used language i.e. NETHACK uses it
22:15:13 <Pseudonym> And it's arguably a useless one if everything thrashes just AFTER the overload point.
22:15:19 <Shimei> Python's mantra is "one way to do it" which seems to go against Haskell's core.
22:15:20 <Pseudonym> My point is that "performance" means many things.
22:15:32 <ddarius> Sgeo: As is perl, ruby, java, python, fortran, cobol, delphi, etc.
22:15:34 <SamB_XP> Pseudonym: what is "overload"?
22:15:39 <Shimei> Sgeo: Well, that's from 1985...
22:15:43 <ddarius> Modulo nethack
22:15:43 <wli> Pseudonym: It's essentially an algorithmic scalability metric.
22:16:01 <Shimei> (and NH source is naaaasty)
22:16:06 <Pseudonym> As people have pointed out, I'll try algorithms in Haskell that I wouldn't dare attempt in C.
22:16:07 <crazy_coder> hello everone
22:16:07 <Sgeo> How many jobs can I get knowing just Python?
22:16:16 <Pseudonym> That itself is a performance metric.
22:16:24 <ddarius> Sgeo: How many jobs do you need?
22:16:27 <scook0> Shimei: most of it is not so bad if you're just diving for spoilers
22:16:31 <crazy_coder> For changing the state of a variable, one has to write a monadic function , right ?
22:16:33 <SamB_XP> you don't write algorithms in C do you?
22:16:35 <scook0> though I've never tried actually hacking it
22:16:36 * glguy really doesn't want a bunch of people flooding the Haskell community because it looks like an easy paycheck
22:16:40 <wli> Pseudonym: That's a linguistic performance metric vs. a program performance metric.
22:16:58 * Sgeo is going to need some job during/after/before college
22:17:00 <wli> glguy: Ultimately the goal is to make ourselves obsolete.
22:17:06 <Pseudonym> SamB: It can mean many things, but it could mean, for example, the point where more tasks want to use the CPU than there is CPU to go around.
22:17:11 * Sgeo graduated from High School recently >.>
22:17:22 <SamB_XP> glguy: you can learn edwardk's language!
22:17:23 <ddarius> Sgeo: Yes, but you only need one (or so) at a time.
22:17:30 <Saizan> glguy: with a bit of irony, given that you have an haskell work?:D
22:17:39 <glguy> Saizan: but I didn't learn haskell to get that job
22:17:45 <glguy> I got that job because I learned Haskell
22:17:47 <wli> glguy: e.g. the language is so powerful in the hands of experienced programmers that far fewer programmers are needed.
22:18:20 <glguy> wli: my goal is to stay ahead of that curve, and be one of the programmers taking other people's jobs then :)
22:18:34 <glguy> wli: fortunately, there is always more work to be done
22:18:38 <SamB_XP> I am happy by the way Haskell seems to repulse those who do not enjoy thinking
22:18:38 <glguy> always more money to be made
22:18:42 <wli> glguy: Perhaps I should've qualified it with "to accomplish a given task."
22:18:50 <ddarius> Actually the work to be done is growing quicker than the number of workers.
22:18:52 <Shimei> What happens when you have a language of the few used by the many employed by management?
22:18:59 <glguy> wli: life hasn't gotten slower as we have become more efficient
22:19:16 <Sgeo> SamB_XP, thinking about how to get it to work in the language? >.>
22:19:24 <ddarius> Shimei: Contradiction in terms?
22:19:49 <SamB_XP> Sgeo: I don't know what it is
22:20:03 <Sgeo> it = tasks
22:20:06 <wli> I'm wondering if this execution model is hosed or something.
22:20:34 <wli> Probably yes, but the monadic interpreter redux isn't my highest priority.
22:20:35 <dons> glguy: want to help run a multicore shootout?
22:20:42 <crazy_coder> hello ,   For changing the state of a variable, one has to write a monadic function , right ?
22:20:44 <crazy_coder> pls
22:20:48 <crazy_coder> heh
22:20:51 <dons> we'd get to build up our multicore skills, and poke fun at all the other languages
22:20:53 <wli> dons: I had thoughts there: http://holomorphy.com/~wli/shootout.html
22:20:54 <lambdabot> Title: Programming Language Shootout Thoughts
22:20:54 <SamB_XP> crazy_coder: "state"?
22:21:22 <glguy> dons: I could help. I think it will be important to make sure that the project is not about competing with Haskell
22:21:35 <glguy> dons: but is about benchmarking all languages against each other
22:21:35 <crazy_coder> SamB_XP: state meaning in terms of mutable variables
22:21:51 <monochrom> monad is one choice. arrow is another. you can also just write f :: MyState -> MyState from old state to new state.
22:21:53 <SamB_XP> crazy_coder: have you got a mutable variable?
22:21:53 <dons> glguy: yep.
22:21:55 <ddarius> Why?  What do we care?  Haskell v. All Comers
22:22:06 <glguy> dons: in order to encourage participation, so that people don't feel like thye are juts contributing to a haskell project
22:22:07 <dons> we really want to start hammering the haskell smp support more -- that would be one goal
22:22:17 <glguy> ddarius: to encourage participation
22:22:17 <dons> just as the shootout sorted out string/regex/array handling
22:22:26 <crazy_coder> SamB_XP: donno. How to check that ;P
22:22:34 <Shimei> ddarius: Well, yes, but what I was asking is if a language that obsoletes us can get "popular" (since that's the theme it seems)
22:22:37 <SamB_XP> crazy_coder: well, what type does it have?
22:22:45 <dons> wli, yes, that seems reasonable
22:22:53 <dons> a distillation of what is good about the shootout
22:23:24 <ddarius> Shimei: Yes, because as glguy said, there's always more work to be done.
22:23:32 <edwardk> @pl f g x = (f x, g x)
22:23:32 <lambdabot> f = fix (liftM2 (,))
22:23:40 <wli> dons: There may be more to say there, e.g. about verifiers vs. reference implementations.
22:23:49 <wli> dons: And validity testing.
22:23:53 <crazy_coder> SamB_XP : Its of type [(String,Player)]    , where data Player = User | Comp | Nil   deriving (Eq,Show)
22:23:53 <dons> dibblego, that's not quite right, your last comment. 'alloc' can be used, for example
22:23:54 <ddarius> I'm not actually sure that an explicit "Haskell v. All" -wouldn't- draw more participation.
22:23:54 <edwardk> ah duh
22:24:03 <edwardk> @pl foo f g x = (f x, gx)
22:24:04 <lambdabot> foo = const . flip flip gx . ((,) .)
22:24:07 <edwardk> blech
22:24:10 <SamB_XP> crazy_coder: that's not a mutable variable -- it's a list!
22:24:16 <edwardk> @type (&&&)
22:24:18 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
22:24:28 <edwardk> @type (***)
22:24:30 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
22:24:48 <crazy_coder> SamB_XP: what I want to do is that I want to change the content of the list, so that from that time onwards it is the modified list
22:24:52 <SamB_XP> ddarius: yeah, just post it on reddit and everyone will come swarming to see who can outdo Haskell ;-)
22:24:53 <ddarius> f &&& g
22:25:09 <SamB_XP> crazy_coder: you can't change the list ;-)
22:25:36 <edwardk> ddarius: yeah, was blanking on it for a sec.
22:25:44 <crazy_coder> SamB_XP : Not even using monadic functions ?
22:25:47 <monochrom> crazy_coder: there is always a way of stopping thinking in terms of changing the list.
22:25:56 <edwardk> @pl foo f (x,y) = (f x, f y)
22:25:56 <lambdabot> foo = (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
22:26:12 <wli> dons: It's notable that the linear algebra calls based on FFI affairs aren't parallelizable.
22:26:13 <glguy> What you have to realize is that there is no spoon
22:26:22 <ddarius> edwardk: The arrow combinators are not part of the basis pl compiles to.
22:26:27 <crazy_coder> monochrom: I agree.....
22:26:29 <brad_> sadly i have returned with more cabal questions!
22:26:30 <edwardk> @type join f (&&&)
22:26:32 <lambdabot> Not in scope: `f'
22:26:34 <edwardk> er
22:26:38 <ddarius> :t (***)
22:26:40 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
22:26:47 <wli> dons: So it actually makes sense to write native linear algebra computation affairs.
22:26:50 <ddarius> :t join (***)
22:26:51 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
22:26:53 <edwardk> @type flip (&&&)
22:26:55 <brad_> i have put haddock docs in my module, they did not get put in the tarball!
22:26:55 <sjanssen> wli: why can't they run in parallel?
22:26:55 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c' -> a b c -> a b (c, c')
22:27:00 <edwardk> @type join (&&&)
22:27:01 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a b (c, c)
22:27:13 <edwardk> @type join (***)
22:27:15 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
22:27:15 <brad_> is it incumbent on users to use the haddock tool to extract these docs?
22:27:19 <edwardk> thats what i wanted
22:27:20 <edwardk> =)
22:27:24 <Sgeo> argh I should go to sleep now >.>
22:27:27 <wli> sjanssen: The underlying C code is single-threaded, so if you just plug a matrix into it all it will do is run on one CPU.
22:27:31 <RyanT5000> how do i add a type signature for a function in a where statement
22:27:35 <SamB_XP> @pl \f (x, y) -> (f x, y)
22:27:35 <lambdabot> (`ap` snd) . (. fst) . ((,) .)
22:27:40 <edwardk> for lifting magma operations on a and magma operations on b to magma operations on (a,b)
22:27:46 <Saizan> brad_: they just have to runghc Setup.hs haddock
22:27:47 <SamB_XP> @pl second
22:27:47 <lambdabot> second
22:28:01 <wli> sjanssen: Sorry, underlying *Fortran* code.
22:28:08 <brad_> ah thanks Saizan!
22:28:11 <glguy> RyanT5000: the same way you do it at the top level
22:28:19 <sjanssen> wli: oh, right.  You could run several FFI'd calls simultaneously though
22:28:24 <RyanT5000> glguy: right, but it says it can't match certain type variables
22:28:25 <monochrom> RyanT5000: Just do so on another line with the same indentation.
22:28:28 <glguy> RyanT5000: however, sometimes, due to polymorphism, you can't type something without scoped type variables
22:28:32 <RyanT5000> right
22:28:33 <ddarius> @pl fraggle
22:28:33 <lambdabot> fraggle
22:28:35 <RyanT5000> that's the problem
22:28:46 <SamB_XP> RyanT5000: try `asTypeOf`
22:28:53 <SamB_XP> sometimes that helps
22:29:01 <wli> sjanssen: True enough. I'm not sure how the data parallel bits interact with all that.
22:29:09 <glguy> GHC has a scoped type var extension as well
22:29:29 <ddarius> www.sac-home.org
22:29:37 <wli> How do you do the data parallel and/or autoparallel stuff anyway?
22:29:38 <RyanT5000> basically, i'm making an array in a where
22:29:45 <RyanT5000> and so i need to tell it to make it be an Array
22:29:49 <RyanT5000> as opposed to "something"
22:29:53 <RyanT5000> so that it can find the instance
22:30:16 <ddarius> You can use asTypeOf as SamB_XP mentioned.
22:30:26 <monochrom> Array in particular doesn't need that, if you just import Data.Array and not Data.Array.IArray.
22:30:34 <RyanT5000> alright
22:30:40 <SamB_XP> ddarius: I don't know if that will help much
22:30:47 <RyanT5000> is asTypeOf just (flip const)?
22:30:51 <RyanT5000> oh wait
22:30:52 <ddarius> SamB_XP: I think it can always work for H98 stuff.
22:31:01 <ddarius> :t asTypeOf
22:31:01 <RyanT5000> except declared to be a -> a -> a
22:31:04 <lambdabot> forall a. a -> a -> a
22:31:05 <ddarius> Yes
22:31:06 <SamB_XP> I suppose you could make a toplevel polymorphic dummy array
22:31:19 <Saizan> RyanT5000: it's not flipped
22:31:41 <glguy> :t 5 `asTypeOf` (undefined :: Int)
22:31:43 <lambdabot> Int
22:31:46 <ddarius> SamB_XP: There are entertaining times where you use "circular" code just to get a type var.
22:31:59 <monochrom> > 5 `asTypeOf` (undefined :: Int)
22:32:00 <lambdabot>  5
22:32:24 <dobblego> :t asTypeOf
22:32:26 <lambdabot> forall a. a -> a -> a
22:32:46 <glguy> > let asTo :: a -> a -> a; asTo x y = x in 5 `asTo` (undefined :: Int)
22:32:47 <lambdabot>  5
22:32:51 <dobblego> > 5 `asTypeOf` (undefined :: String)
22:32:51 <glguy> :t let asTo :: a -> a -> a; asTo x y = x in 5 `asTo` (undefined :: Int)
22:32:53 <lambdabot>   add an instance declaration for (Num String)
22:32:53 <lambdabot> a -> a -> a; asTo x y = x in 5 `asTo` (undefined :: Int) :: Int
22:33:07 <dobblego> > (5 :: Int) `asTypeOf` (undefined :: String)
22:33:08 <lambdabot>  Couldn't match expected type `Int' against inferred type `String'
22:34:08 * glguy wants to take milk to work tomorrow so he can say, "It's so damn hot! Milk was a bad choice..."
22:34:08 <dobblego> does asTypeOf do anything more than using :: Type ?
22:34:17 <monochrom> No.
22:34:19 <glguy> dobblego: no, but :: Type is't Haskell98
22:34:23 <dobblego> ah right
22:34:24 <ddarius> glguy: Wtf?
22:34:34 <RyanT5000> ah, that works well
22:34:39 <dobblego> it's bloody freezing here
22:34:41 <SamB_XP> glguy: it is!
22:34:42 <glguy> ddarius: we are having a "heat wave" here in portland
22:35:00 <glguy> SamB_XP: not in the context of: x = 1 :: Int
22:35:17 <glguy> is it?
22:35:26 <glguy> dobblego: also, you might not know the type
22:35:26 <SamB_XP> glguy: I think it is
22:35:33 <SamB_XP> if you add parens it should be
22:36:25 <glguy> I can't check for myself right now (don't have access to my browser), but I'm not certain enough to disagree with you :)
22:37:05 <wli> Control.Parallel.Strategies is somewhat enlightening.
22:37:20 <glguy> we don't have A/C in our apartment, most places in Portland don't, apparently
22:37:24 <ddarius> :t let f g x = r where r = g x in f
22:37:26 <lambdabot> forall t t1. (t -> t1) -> t -> t1
22:37:38 <wli> glguy: Yeah, it really pissed me off that I had to get a window A/C unit.
22:37:39 <ddarius> :t let f g x = r where r = g (x `asTypeOf` r) in f
22:37:41 <lambdabot> forall a. (a -> a) -> a -> a
22:37:50 <glguy> wli: we just have the windows open
22:37:58 <glguy> wli: I should buy a fan or something
22:38:05 <monochrom> f :: Num a => a -> a; f x = 5 `asTypeOf` x.  Note that you cannot write (5 :: a).
22:38:45 <wli> glguy: I'd be dead of heat stroke in under 24 hours.
22:38:51 * glguy reveals that the milk quote was from "Anchorman"
22:39:07 * ddarius doesn't remember it.  A good thing.
22:39:42 <glguy> I watched it a couple times so that I wouldn't!
22:39:48 <wli> An analogue of parListChunk for parArr looks like it would help.
22:40:12 <glguy> at work the A/C was turned on full blast, I had to put on my fleece
22:40:16 <ddarius> glguy: That sounds like a bad way to not remember something.
22:41:02 <SamB_XP> ddarius: I think he wanted to not *forget*?
22:42:14 <glguy> wli: are you exagerating? or do you have a medical condition?
22:42:20 <ddarius> SamB_XP: Now that's just silly.  Why would anyone want to not forget that movie except by never seeing it in the first place.
22:42:25 <wli> glguy: Both.
22:42:47 <glguy> is your medical condition "too many computers in one room"?
22:42:48 <ddarius> He has a medical condition where he exaggerates things.
22:42:52 <glguy> :)
22:43:06 <wli> gluy: No.
22:43:07 <dobblego> I had a girlfriend like that
22:43:15 <wli> ddarius: No.
22:43:15 <glguy> dobblego: too many computers?
22:43:17 * ddarius should be getting "Categories for the Working Mathematician" in a few days
22:43:31 <dobblego> ne, a "a medical condition where [the subject] exaggerates things"
22:43:44 <dobblego> *no
22:43:54 <glguy> *nay
22:43:59 <glguy> would have been cool too
22:44:26 <dobblego> just wanted to disambiguate "not equal" :)
22:44:56 <wli> Let's say you're doing conjugate gradient on sparse matrices and wantto use Control.Parallel ...
22:45:09 <glguy> "nay is for norses" (glguy on scandinavians)
22:46:43 <edwardk> hrmm i'm currently carrying around an IsExact, IsApproximated, IsTruncated term in all my numerical classes, i.e. class (MathAssumption t => AddMagma a t | a -> t where (+) :: a -> a -> a  -- does it seem like that would be better off just moved to something over a instead rather than 'per operation group'?
22:47:30 <edwardk> the only case i could think of against moving it would be if (+) yielded exact answers and (*) yielded approximate or truncated ones, but thats not very convincing to me
22:48:13 <SamB_XP> edwardk: ... you aren't actually expecting advice are you?
22:48:26 <edwardk> (in the above IsExact is things like Rational and Integer, which faithfully reproduce OrderedField and OrderedIntegralDomain semantics , on the other hand, IsApproximated is for things like Float and Double
22:48:33 <dons> wli: the parArr stuff is in the ndp package
22:48:51 <edwardk> IsTruncated is for things like Int where its faithful as an orderedintegraldomain up to overflow
22:49:51 <SamB_XP> I notice all of those examples are extremely tame
22:49:53 <edwardk> i've been trying to balance purity of algebraic form against the reality of the fact that hardware numerical types have like  no algebraic laws to speak of
22:50:08 <edwardk> samb: sure
22:50:39 <wli> Basically your "matrix" is something like a Map (Int, Int) Double (possibly with multiple indices so you can smoke out elements a given row or column) and you want to do all the <row, col> inner products in parallel.
22:50:52 <ddarius> hardware integer types are fairly nice.
22:50:52 <sm> urk.. where is http://haskell.org/ghc/docs/latest/html/libraries/base/Text-Regex.html ?
22:50:54 <lambdabot> http://tinyurl.com/2z87jz
22:50:58 <dons> wli, seen the parallel arrays paper?
22:51:02 <wli> edwardk: Oh, the numerical types behave like Z/(2^n Z)
22:51:05 <edwardk> ok, [a] is an IsExact AddMonoid, Foo a t => Foo (b -> a) t for al the numerical types
22:51:16 <SamB_XP> wli: not Float and Double ;-)
22:51:16 <wli> dons: No, sounds like a good idea to look at.
22:51:36 <edwardk> wli: yeah, but people still go through and pretend Int is an integral domain using div and divMod, etc =)
22:51:45 <wli> Well, floating point is barely even commutative.
22:51:58 <wli> Forget associativity/etc.
22:52:12 <dons> wli, http://haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
22:52:13 <lambdabot> Title: GHC/Data Parallel Haskell - HaskellWiki
22:52:19 <edwardk> wli: despite the fact that Int has zero divisors
22:52:50 <edwardk> wli: sure, so any numerical type that 'IsApproximate' basically says you get the right 'shape' of the operators but you can't perform any algebraic simplification.
22:54:20 <wli> edwardk: You can still do some, there are just lots of restrictions, sadly all type-specific.
22:54:45 <SamB_XP> wli: well, that effectively means they should be left to the code generator...
22:54:50 <wli> dons: That looks really hot.
22:55:03 <edwardk> wli: yeah i know basically you can safely collapse identities, almost anything else may add NaNs =)
22:55:19 <SamB_XP> @vixen do you like hot?
22:55:19 <lambdabot> sure, i definitely don't hate
22:55:23 <SamB_XP> @vixen hot
22:55:23 <lambdabot> help help!
22:55:29 <SamB_XP> @vixen higher-order
22:55:30 <lambdabot> yeah?
22:55:40 <edwardk> or overflow/underflows
22:55:42 * SamB_XP wonders if that registered as "hi"
22:55:44 <glguy> @vixen So how about ruby?
22:55:44 <lambdabot> good question
22:56:11 <wli> edwardk: Bounds checks, checks for zero divisors, etc. are needed before making various simplifications.
22:56:20 <glguy> @vixen Which is better between emacs and vim?
22:56:20 <lambdabot> good question
22:56:28 <dons> http://programming.reddit.com/info/25c85/comments
22:56:29 <lambdabot> Title: "In a concurrent world, imperative is the wrong default": Data Parallel Haskell  ...
22:56:31 <edwardk> anyways i think i'll move the 'assumption' piece out of the numerical types and into its own type that says what you can assume
22:56:32 * glguy remembers vixen being more entertaining previously
22:56:51 <edwardk> er s/type/class/
22:57:03 <wli> dons: The pdf link there is broken.
22:57:12 <SamB_XP> @vixen do you like haskell?
22:57:13 <lambdabot> church is my favourite computer scientist.
22:57:21 <SamB_XP> @vixen who are you?
22:57:22 <lambdabot> what do you mean, i'm me!
22:57:31 <SamB_XP> @vixen aslp
22:57:31 <lambdabot> 19/f/California/No pics
22:57:35 <dons> wli, works for me.
22:57:41 <wli> edwardk: Also, division by zero divisors is feasible.
22:57:58 <dons> wli, which link?
22:58:22 <Pseudonym> @vixen Church was an idiot.
22:58:22 <lambdabot> i find it hard to masturbate when the lights are on.
22:58:35 <Pseudonym> @vixen Church did too, oddly enough.
22:58:35 <lambdabot> Tell me truthfully what the nastiest thing you have ever done.
22:58:42 <dons> good old vixen
22:58:56 <wli> dons: http://dataparallel.googlegroups.com/web/UNSW%20CGO%20DP%202007.pdf
22:58:57 <Korollary> @vixen I ported a haskell program to C
22:58:57 <lambdabot> church is my favourite computer scientist.
22:58:58 <lambdabot> http://tinyurl.com/2tan8z
22:58:59 <edwardk> hrmm, so what would be a better namee for a separate typeclass about what you can assume about the faithfulness of a mathematical type to the expected algebraic semantics? I'm calling it a MathAssumption right now, but that sucks
22:59:18 <SamB_XP> @vixen church
22:59:18 <lambdabot> tell me more about yourself.
22:59:22 <SamB_XP> @vixen church is cool
22:59:22 <lambdabot> cool cool
22:59:38 <dons> wli, http://dataparallel.googlegroups.com/web/UNSW%20CGO%20DP%202007.pdf
22:59:39 <lambdabot> http://tinyurl.com/2tan8z
22:59:40 <SamB_XP> @vixen I am an idiot
22:59:40 <lambdabot> where can I a see a picture of you?? URL??
22:59:59 <dons> definitely works for me, wli.
23:00:00 <SamB_XP> @vixen http://localhost/
23:00:00 <lambdabot> should i go there?
23:00:34 <wli> dons; Weirdly it works through tinyurl so I care no more.
23:00:36 <edwardk> i almost want to say AlgebraicSemantics
23:01:11 <SamB_XP> @vixen AlgebraicSemantics
23:01:11 <lambdabot> underneith the top layer I'm completely bear (no bra or panties)
23:01:29 <Korollary> Bears wear panties?
23:01:37 <edwardk> lambdabot seems to like it
23:01:42 <SamB_XP> @vixen panties?
23:01:42 <lambdabot> i prefer to go without panties or bras :)
23:01:44 <ddarius> Korollary: Apparently not
23:01:47 <SamB_XP> @vixen panties?
23:01:47 <lambdabot> underneith the top layer I'm completely bear (no bra or panties)
23:01:49 <ddarius> Me too.
23:01:58 <SamB_XP> @vixen algebra
23:01:59 <lambdabot> i prefer to go without panties or bras :)
23:01:59 <glguy> underneith?
23:02:04 <edwardk> ah, 'Alge-bra-icSemantics'
23:02:05 <SamB_XP> ... okay...
23:02:10 <SamB_XP> AH!!!!
23:02:11 <edwardk> sometimes she's a little random ;)
23:02:22 <SamB_XP> @vixen semantics?
23:02:22 <Korollary> @vixen brass balls?
23:02:22 <lambdabot> underneith the top layer I'm completely bear (no bra or panties)
23:02:22 <lambdabot> i think you know the answer to that one, silly
23:02:25 <wli> edwardk: consider what happens when the least residue of the divisor is less than |R|/char(R)
23:02:42 <SamB_XP> @vixen am I cool?
23:02:43 <lambdabot> how cool?
23:02:49 <SamB_XP> @vixen are you cool?
23:02:50 <lambdabot> yeah, i think i'm cool
23:02:57 <edwardk> wli: sure, floats suck =)
23:03:07 <SamB_XP> @vixen is dons cool?
23:03:08 <lambdabot> how cool?
23:03:09 <glguy> @vixen do you suck floats?
23:03:09 <lambdabot> yes i do
23:03:17 <SamB_XP> @vixen do you read?
23:03:17 <lambdabot> maybe. do you?
23:03:22 <SamB_XP> @vixen yes
23:03:22 <lambdabot> i guessed that
23:03:25 <SamB_XP> @vixen no
23:03:25 <lambdabot> i didn't think so
23:03:31 <SamB_XP> @vixen I don't know
23:03:31 <lambdabot> well find out then
23:03:37 <SamB_XP> @vixen do you know?
23:03:37 <lambdabot> yeah, i know
23:03:39 <wli> edwardk: Floating point is kind of hopeless.
23:03:43 <SamB_XP> @vixen what do you know?
23:03:43 <lambdabot> yeah, i know
23:03:49 <SamB_XP> @vixen shut up
23:03:50 <lambdabot> enough of this!
23:04:07 <SamB_XP> @vixen do you enjoy fp?
23:04:07 <lambdabot> yes i do
23:04:15 <SamB_XP> @vixen do you enjoy pain?
23:04:16 <lambdabot> i do occassionally, i guess
23:04:23 <SamB_XP> @vixen do you enjoy spanking?
23:04:23 <lambdabot> yes i do
23:05:00 * glguy kicks lambdabot and SamB_XP to #teen_chat
23:05:18 <SamB_XP> glguy: ... b.b.but I'm 20!
23:05:31 <wli> dons: Well, that pretty much answers how to do sparse stuff.
23:05:53 <glguy> SamB_XP: :( but I haven't kicked anyone in ages
23:06:31 <SamB_XP> @vixen do you like lambda calculus?
23:06:31 <lambdabot> sure, i definitely don't hate
23:06:40 <SamB_XP> @vixen what do you think of pure type systems?
23:06:41 <lambdabot> any type will due
23:06:59 <SamB_XP> @vixen are you higher-order-typed?
23:06:59 <lambdabot> i truely am
23:07:12 <glguy> truely?
23:07:36 <SamB_XP> well... she keeps her database in function form internally. does that count?
23:08:53 <wli> dons: I'm having enough trouble setting up the equations that this probably won't come into play for a while.
23:09:13 <glguy> SamB_XP: I mean s/truely/truly :)
23:09:44 <SamB_XP> glguy: ... oh
23:09:53 <SamB_XP> in that case..
23:09:57 <SamB_XP> due?
23:10:36 <mauke> @vixen do u haet pizza?
23:10:36 <lambdabot> maybe. do you?
23:10:52 <mauke> @vixen no i loev pizza
23:10:52 <lambdabot> i didn't think so
23:11:26 <dolio> @. vixen vixen
23:11:26 <lambdabot> yeah, i know
23:11:52 <SamB_XP> @vixen
23:11:52 <lambdabot> do you trust the government?
23:11:54 <SamB_XP> @vixen
23:11:55 <lambdabot> i understand
23:11:56 <SamB_XP> @vixen
23:11:57 <lambdabot> help help!
23:11:59 <SamB_XP> @vixen
23:11:59 <lambdabot> I will NOT be ignored...
23:12:02 <SamB_XP> @vixen
23:12:02 <lambdabot> Prolly
23:12:07 <SamB_XP> @vixen
23:12:07 <glguy> @. vixen . vixen vixen
23:12:07 <lambdabot> I am on the net too much. I should do a net anonymoouse group. online of course.
23:12:07 <lambdabot> a lot of people like that
23:12:15 <dons> i liked it better when vixen was disabled
23:12:26 <ddarius> You mean broken?
23:12:28 <dolio> Yeah.
23:12:32 <SamB_XP> dons: isn't this the off hours anway?
23:12:40 <SamB_XP> dons: we will tire soon enough
23:12:51 <glguy> andyjgill: hello
23:12:57 <ddarius> It is the off hours for me, auf Wiedersehen.
23:13:09 <andyjgill> hi glguy, just a bit of late night hacking?
23:13:13 <SamB_XP> it always seems a bit dead at this time of night
23:13:23 <SamB_XP> @localtime glguy
23:13:24 <lambdabot> Local time for glguy is Tue Jul 10 23:12:48 2007
23:13:40 <SamB_XP> @localtime dons
23:13:41 <lambdabot> Local time for dons is Wed Jul 11 16:13:06 2007
23:13:43 <SamB_XP> @localtime ddarius
23:13:50 <glguy> andyjgill: just a bit of entertainment whilst I read: Logic in computer science: modelling and reasoning about systems :)
23:13:50 <Olathe> @localtime Olathe
23:13:51 <lambdabot> Local time for Olathe is Wed Jul 11 01:15:15 2007
23:14:41 <wli> `code' is not defined;
23:14:41 <wli> perhaps you forgot to include "lhs2TeX.fmt"?
23:14:47 <wli> Hmm, what do I do about that?
23:16:09 <glguy> include it? :)
23:16:34 * glguy hasn't used lhs2tex in a while, but remembers you have to mention that file in your source file
23:16:54 <SamB_XP> is the syntax %&lhs2TeX
23:16:55 <SamB_XP> ?
23:17:36 <wli> %include lhs2TeX.fmt I think.
23:17:56 <SamB_XP> um, I doubt that very much ;-)
23:18:03 <SamB_XP> % normally being comment syntax
23:18:14 <wli> It's apparently an lhs2TeX directive.
23:19:07 * glguy thinks that the Galois soccer team will only serve to raise our insurance rates...
23:19:15 <glguy> My ankle has been sore since the last game
23:20:58 <wli> ! LaTeX Error: File `stmaryrd.sty' not found.
23:23:22 <dons> glguy: hehe
23:23:36 <xpika> @where flags
23:23:36 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/flag-reference.html
23:23:46 <wli> tetex-math-extra is needed
23:24:33 <wli> texlive-math-extra rather
23:24:46 <wli> missing dependency in the lhs2TeX package.
23:25:29 <SamB_XP> well, use your bug reporting program to report the bug!
23:25:49 <wli> It's a bit worse than that it seems.
23:26:00 <Olathe> Flux capacitor activated !
23:27:24 <pjd> SamB_XP: PyPy!
23:27:26 <edwardk> > signum (1 :+ 3)
23:27:27 <lambdabot>  0.31622776601683794 :+ 0.9486832980505138
23:27:43 <edwardk> weird. its just a unit value indicating direction? not -1,0,1?
23:28:12 <mauke> > abs . signum $ 1 :+ 3
23:28:13 <lambdabot>  1.0 :+ 0.0
23:28:21 <oerjan> edwardk: it's z divided by its absolute value
23:28:47 <_roconnor> > signum 0
23:28:48 <lambdabot>  0
23:29:20 <oerjan> > let z = (1 :+ 3) in (abs z, signum z, abs z*signum z)
23:29:21 <lambdabot>  (3.1622776601683795 :+ 0.0,0.31622776601683794 :+ 0.9486832980505138,1.0 :+ ...
23:29:22 <edwardk> ok, so i should be able to implement that in anything with abs and (/)
23:29:49 <_roconnor> oerjan: unless z is 0
23:29:55 <edwardk> looks like it needs to go in its own class though, since i'm not sure that everything that has an absolute value has a meaningful sign
23:30:18 <wli> Looks like lhs2TeX is broken for me. :(
23:30:38 <edwardk> since i currently don't require Eq comparability for numerical types, so you may not be able to test if an element is 0 to give a signum anyways
23:30:58 <oerjan> > let z = (1 :+ 3) :: Complex Float in (abs z, signum z, abs z*signum z)
23:31:00 <lambdabot>  (3.1622777 :+ 0.0,0.31622776 :+ 0.94868326,1.0 :+ 3.0)
23:33:08 <edwardk> @type (\\)
23:33:10 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
23:34:28 <crazy_coder> Is it necessary that a user defined data types is also a monad ?
23:34:46 <RyanT5000> crazy_coder: depends on what you're trying to do with it
23:34:51 <dons> no :) very few are actually monads.
23:35:07 <crazy_coder> sorry got disconnected
23:35:10 <wli> I think texlive is incompatible with it somehow.
23:35:10 <RyanT5000> crazy_coder: depends on what you're trying to do with it
23:35:20 <RyanT5000> but very rarely do users make monads
23:36:46 <crazy_coder> like (m a), here in wikipedia m is said to be a container, but where does m come from ?
23:37:23 <RyanT5000> the container metaphor is useful for explaining monads, but that doesn't mean that every container is a monad
23:37:34 <oerjan> crazy_coder: essentially you take the full datatype of the value and strip off the last argument
23:37:34 <RyanT5000> check out the interface, for example, of Data.Map
23:37:52 <RyanT5000> have you learned how to use IO?
23:38:01 <mauke> crazy_coder: depends on the context
23:38:35 <crazy_coder> Still learning
23:38:49 <edwardk> @type (^)
23:38:51 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
23:38:52 <edwardk> @type (^^)
23:38:52 <oerjan> so if your value is say Maybe Int, then m = Maybe and a = Int
23:38:53 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
23:39:21 <edwardk> so the former is definable on anything with a (*) the latter requires (/) ?
23:39:32 <oerjan> edwardk: yep
23:39:36 <edwardk> k
23:39:48 <oerjan> edwardk: the first must have nonnegative exponent
23:39:49 <crazy_coder> oerjan: Ok So now if I defined data X = Y Int | Z Char, then m=X   and a=Y Int ?
23:39:51 <edwardk> baking in some more general utility functions into the hierarchy
23:39:59 <glguy> someone mind throwing a multibyte UTF-8 char at me?
23:40:01 <mauke> crazy_coder: no
23:40:29 <oerjan> crazy_coder: no.  The full type is only X.  Y is a _data_ constructor, not a type.
23:40:41 <edwardk> ok, so if i relax that slightly and say that you can define it on anything with a multiplicative magma as long as you pass it a positive argument, and use it over any multiplicative monoid for non-negative?
23:40:41 <mauke> crazy_coder: but you could do data X a = Y a | Z Char; then m=X and a=Int would work
23:40:48 <RyanT5000> crazy_coder: a monad has to be a container type, but it *also* has to obey certain rules
23:40:55 <RyanT5000> most user datastructures don't obey those rules
23:41:20 <edwardk> hrmm, bah, looks like i'm going to push it into monoid, there is a 'how to define this thing once and for all' problem typical of haskell
23:41:43 <crazy_coder> ok, so a monad is certainly a data type , but not all data types are monads (those who don't follow the rule)
23:42:03 <RyanT5000> right
23:42:05 <crazy_coder> btw, what are the rules then ?
23:42:14 <mauke> it must implement Monad
23:42:20 <glguy> left identity, right identity and associativity
23:42:23 <mauke> minimal definition: (>>=) and return
23:42:25 <crazy_coder> *implement* >
23:42:31 <crazy_coder> Oh Ok
23:42:32 <mauke> yeah, and your implementation should be "sane"
23:42:47 <oerjan> edwardk: semigroup if you exclude exponent 0 as well
23:42:47 <RyanT5000> if you look up class Monad, which is in Control.Monad, you'll see the rules
23:42:52 <RyanT5000> are you familiar with hoogle?
23:43:04 <crazy_coder> it should be an instance of which class ?
23:43:06 <mauke> crazy_coder: http://haskell.org/haskellwiki/Monad_Laws
23:43:08 <lambdabot> Title: Monad laws - HaskellWiki
23:43:12 <glguy> ?src Monad
23:43:12 <lambdabot> class  Monad m  where
23:43:13 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
23:43:13 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
23:43:13 <lambdabot>     return      :: a -> m a
23:43:13 <lambdabot>     fail        :: String -> m a
23:43:21 <crazy_coder> RyanT5000: yeah, somewhat
23:43:24 <glguy> ?instances Monad
23:43:25 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
23:43:30 <oerjan> edwardk: (otherwise you need to distinguish left and right folding versions)
23:43:38 <edwardk> yeah
23:43:57 <RyanT5000> other point: why is fail defined the way it is?
23:44:01 <crazy_coder> Ok So now I get it a little.... Thanks
23:44:08 <RyanT5000> is it just an anachronism?
23:44:15 <Pseudonym> No, it's for pattern matching.
23:44:19 <Pseudonym> It's for when pattern matching fails.
23:44:22 <mauke> RyanT5000: hysterical raisins
23:44:27 <crazy_coder> Can't we do something like data X = M | P    deriving (Maybe) ??
23:44:34 <mauke> crazy_coder: no, Maybe is not a class
23:44:35 <RyanT5000> yeah, but String?
23:44:37 <RyanT5000> come on
23:44:49 <edwardk> i think i may want to rely on associativity and try to have it do a faster version by default the painfully slow fold hurts =/
23:44:50 <mauke> IIRC it used to be MonadZero
23:44:56 * wli discovers inconsistent texlive packages and pushes his disk space to the limit to update them.
23:44:57 <Pseudonym> > do { Nothing <- [Just 4]; return () }
23:44:58 <lambdabot>  []
23:45:02 <RyanT5000> besides, pattern matching can fail within a pure function
23:45:09 <Pseudonym> > do { Nothing <- Just (Just 4); return () }
23:45:10 <lambdabot>  Nothing
23:45:17 <Pseudonym> Hmm.
23:45:19 <Pseudonym> Bad examples.
23:45:22 <Pseudonym> In retrospect.
23:45:27 <crazy_coder> data X = M | P    deriving (Monad) ??
23:45:30 <RyanT5000> well, that's my point
23:45:36 <opqdonut> yeah, fail "aasf" is Nothing in the maybe monad
23:45:37 <mauke> crazy_coder: you can't derive Monad
23:45:41 <edwardk> not sure the barrier to explanation for .^ vs. ^. isn't higher than their utility they fail the standard library test
23:45:42 <glguy> crazy_coder: You don't derive Monad though
23:45:47 <mauke> crazy_coder: and that won't work anyway because X has the wrong kind
23:45:53 <Pseudonym> You can newtype-derive Monad.
23:46:03 <opqdonut> > do { Left x <- [Right 2]; return x }
23:46:04 <lambdabot>  []
23:46:05 <glguy> Pseudonym: You are getting *way* ahead thought :)
23:46:11 <opqdonut> > do { Left x <- Right 2; return x }
23:46:12 <lambdabot>   add an instance declaration for (Num (Either t t1))
23:46:13 <glguy> though*
23:46:17 <Pseudonym> :-)
23:46:20 <opqdonut> gah
23:46:22 <mauke> crazy_coder: all instances of Monad must take a type argument
23:46:39 <opqdonut> yeah, only bad examples come to mind :)
23:46:42 <RyanT5000> Pseudonym: it seems like fail should either be (:: m a) or (:: m ())
23:46:46 <RyanT5000> @type fail
23:46:48 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
23:46:57 <crazy_coder> Ok Thanks
23:47:00 <opqdonut> > do { Left x <- Right Right 2; return x }
23:47:01 <lambdabot>  Couldn't match expected type `t2 -> t t1'
23:47:01 <RyanT5000> that String just isn't doing it for me
23:47:10 <opqdonut> RyanT5000: it's for an error message
23:47:17 <RyanT5000> yeah, i know that's what it's "for"
23:47:23 <opqdonut> i think it's actually a pretty nice feature
23:47:39 <opqdonut> it isn't really that pure or abstract as the rest of Monad but hey
23:47:41 <RyanT5000> why should "strings" exist at all in such important things
23:47:49 <opqdonut> we're working with real programs here :)
23:48:03 <RyanT5000> if you want a monad with a failure that takes a string, you can easily enough make one
23:48:10 <glguy> RyanT5000: so that it can say: this failed because of pattern matching
23:48:27 <glguy> RyanT5000: debugging a Haskell program is tricky enough :)
23:48:27 <Japsu> @source Num
23:48:27 <lambdabot> Num not available
23:48:29 <Saizan> > do 1 <- Right 2; return ()
23:48:30 <lambdabot>  Add a type signature
23:48:31 <RyanT5000> glguy: but there are so many monads in which that isn't reasonable!
23:48:42 <Saizan> > do 1 <- Right 2; return () :: Either String Int
23:48:42 <Japsu> @index Num
23:48:43 <lambdabot> Prelude
23:48:43 <lambdabot>  Couldn't match expected type `Int' against inferred type `()'
23:48:43 <RyanT5000> e.g.: Maybe, [], i don't even know what else
23:48:54 <glguy> RyanT5000: for example?
23:49:05 <Pseudonym> Ryan: To be honest, most Haskellers are a little uneasy about fail, even though the reasoning behind it is sound.
23:49:26 <RyanT5000> i think having a fail :: m a makes some sense
23:49:36 <glguy> that's called mzero
23:49:37 <Pseudonym> :t mzero
23:49:39 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
23:50:05 <RyanT5000> glguy: no it isn't; fail shortcircuits the rest of the procedure
23:50:15 <RyanT5000> mzero is monad-identity
23:50:16 <Saizan> RyanT5000: mzero too :)
23:50:33 <Pseudonym> No, return is the identity.
23:50:34 <Saizan> mzero >>= f = mzero
23:50:41 <Pseudonym> mzero cancels.
23:50:43 <RyanT5000> oh really?
23:50:51 <glguy> Pseudonym: mzero = fail "mzero"
23:50:54 <Pseudonym> return x >> m = m >>= return = m
23:51:03 <RyanT5000> ok that makes more sense
23:51:03 <glguy> err
23:51:03 <Pseudonym> That's the identity for bind.
23:51:09 <glguy> RyanT5000: ^^ :)
23:51:27 <Pseudonym> mzero is a left-zero.
23:51:28 <RyanT5000> nevertheless, i think Strings should stay far away from core features
23:51:40 <Pseudonym> mzero is also sometimes a right-zero.
23:52:06 <Saizan> m >> mzero?
23:52:24 <Pseudonym> Saizan: lift (putStrLn "Woo!") >> mzero /= mzeri
23:52:32 <Pseudonym> mzero should be that last thing
23:52:35 <Saizan> well it's a zero for mplus, but there is the identity
23:52:55 <Pseudonym> It's the identity for mplus.
23:53:50 <Japsu> @pl \x -> fromInteger (x - 1)
23:53:51 <lambdabot> fromInteger . subtract 1
23:55:45 <dancor> setup: cannot satisfy dependency pretty-any
23:56:04 <dons> pretty is only in darcs atm :/
23:56:07 <edwardk> ok, here is a question, is there a term for the sort of 'not-quite-integral-domain' you get from the Naturals, where you have a reasonable notion of divMod, but addition isn't a group because you lack negative numbers?
23:56:40 <dancor> dons: how do i find it
23:57:10 <dancor> normally i can find things using the internet
23:57:18 <edwardk> maybe i should #math that
23:57:31 <dons> dancor: darcs get http://darcs.haskell.org/packages/pretty/
23:57:32 <lambdabot> Title: Index of /packages/pretty
23:57:53 <oerjan> RyanT5000: if fail didn't take a String then any generic monad code would have to throw away the reason for pattern match failure, which would be bad when used in IO.  in theory, don't know if the string is actually giving useful information.
23:58:06 <oerjan> (doesn't seem to in Hugs)
23:58:11 <dancor> httphttphooray
23:58:25 <opqdonut> :
23:58:26 <opqdonut> D
23:59:40 <dons> we haven't seen many irc trolls recently
23:59:52 <glguy> *knock on wood*
23:59:55 <RyanT5000> oerjan: class DescriptiveFailureMonad m where
23:59:55 <RyanT5000>     fail :: String -> m a
23:59:55 <dons> i wonder if freenode has been cracking down on the few that caused all the problems
23:59:56 <antonio-zen> dons: I heard that Haskell is slow
23:59:59 <dons> ha
