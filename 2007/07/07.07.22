00:01:42 <crazy_coder> I am trying out one of the tutorials : what does this mean -- If you run this and telnet to localhost 6000 you should be able to see it work  - -- how to telnet to localhost ??
00:02:42 <ddarius> telnet localhost 6000
00:03:44 <crazy_coder> why do i get Trying ::1...
00:03:44 <crazy_coder> telnet: connect to address ::1: Connection refused
00:03:44 <crazy_coder> telnet: Unable to connect to remote host: Connection refused
00:03:58 <falconair> I just noticed that dons updated the haskell ports library to GHC 6.6.1, a couple of months ago I looked at the library and it looks interesting for building network apps (it is basically erlang in haskell, no?) ...
00:04:14 <falconair> was it updated for a specific project?
00:04:58 <ddarius> falconair: It supports distributed networking using a message passing system...  Erlang is quite a bit more than that though and would have a totally different feel.
00:05:35 <ddarius> crazy_coder: Are you running the program?
00:05:44 <crazy_coder> yes
00:06:04 <crazy_coder> but i can't connect to other ports either
00:06:15 <crazy_coder> *neither
00:06:49 <ddarius> crazy_coder: You can use netstat to see what ports are listening and if the program is listening.
00:08:02 <ddarius> Do netstat --listening\
00:09:09 <crazy_coder> ok
00:09:48 <crazy_coder> should I run the program and then do this
00:10:10 <ddarius> Yes, and see if you see it in the list and verify that it is on port 6000.
00:10:27 <ddarius> The program should be running in the background.
00:10:48 <falconair> there is also a Stream package in hackage, Part of its description is: "Streams are infinite lists".  Lists in haskell can already be infinite, what is the reason for this Stream class?  A quick look at the api shows that there is a Stream instance of class Applicative ... is that the only thing that differentiates a Stream from a List?
00:11:13 <crazy_coder> I aborted the running program. When i rerun it, i get an exception  Exception: bind: resource busy (Address already in use)
00:12:03 <crazy_coder> and its not on the list
00:12:51 <ddarius> falconair: Is the type data Stream a = Cons a (Stream a) ?  If so, then it can -only- be infinite.
00:13:01 <pejo> falconair, Stream has a third constructor named "Skip", which somehow makes it change state.
00:13:20 <ddarius> That stream library?
00:13:30 <ddarius> @hackage stream
00:13:30 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/stream
00:13:43 <pejo> Maybe not that one. I assumed it was the stuff by dons/dcoutts/Leichinsky.
00:13:57 <crazy_coder> should I restart ?
00:14:06 <crazy_coder> restart Linux that is
00:14:17 <fax> yes
00:14:26 <falconair> pejo, I don't see a Skip function in the library
00:14:28 <crazy_coder> Ok. bbl
00:14:47 <ddarius> falconair: Okay, it's (exactly) like I described.
00:15:04 <pejo> falconair, hm. That one is by W. Swierstra, so my answer is wrong I guess.
00:15:05 <falconair> ddarius: yeah, it is just Stream a = Cons a (Stream a) ... so this is the 'codata' idea then?
00:15:44 <ddarius> falconair: Yes and no.  Sometimes you just want a stream, not a list.  However, it is also nice to distinguish between codata and data uses.
00:18:28 <pejo> How inconvenient to have the same name for two different things.
00:18:42 <falconair> btw, BitSyntax's home page, on hackage, points an error page: http://www.imperialviolet.org/bitsyntax
00:18:46 <ddarius> pejo: Actually they are the same thing.
00:18:48 <falconair> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/BitSyntax-0.3
00:18:50 <lambdabot> http://tinyurl.com/2m67ne
00:20:07 <falconair> google tells me that following is the right address for bitsyntax api docs: http://www.imperialviolet.org/binary/bitsyntax/
00:21:32 <crazy_coder> ddarius: i did as you said. Run the program and then netstat --listening. Port 6000 is not on the list
00:22:18 <crazy_coder> what can be probably wrong ?
00:22:59 <ddarius> Permissions maybe?
00:23:19 <crazy_coder> I checked the permission status of telnet
00:23:24 <crazy_coder> It is enabled
00:23:42 <crazy_coder> Should it be disabled ?
00:24:26 <crazy_coder> authentication status, that is
00:24:58 <edwardk> I curse the powers that placed this year's ICFP programming competition and the release of the last Harry Potter book on the same weekend ;)
00:25:24 <ddarius> The issue is permission for the program to listen on a port.
00:25:42 <ddarius> It's the last one?  Yay!
00:25:55 <edwardk> heh
00:26:33 <edwardk> snape killed trinity with rosebud, we can all move on.
00:26:47 <ddarius> That means almost nothing to me.
00:27:11 <edwardk> strange mixture of spoilers from a bunch of things stolen from xkcd
00:28:08 <pejo> ddarius, you mean conceptually?
00:28:37 <ddarius> Yes
00:28:52 <glguy> edwardk: because Harry Potter readers are clogging your internet connection, keeping you from downloading the zip file?
00:29:06 <ddarius> Though I think dcoutts and co. streams can end.  I don't remember.
00:29:35 <edwardk> glguy: actually, as embarassing as it is, i went up and picked up my copy at midnight if only because i didn't want to trip over a spoiler somewhere
00:29:45 <pejo> ddarius, they have hte constructor "Done" which seems to correspond to [].
00:30:03 <edwardk> ddarius: as in fusion ones? Skip, Yield, Done?
00:30:21 <ddarius> That would be prudent as it would be kind of hard to recover that.
00:31:38 <ddarius> Anyways, I'm off to dream about wizards and castles in a world where everyone speaks with a British accent.
00:32:28 <Korollary> Discworld?
00:32:47 <Korollary> say hello to Rincewind for me
00:38:15 * mgsloan chuckles
00:38:35 <mgsloan> yeah, Discworld pwns HP anyday, even the day after the release of a HP
00:39:37 <ska-fan> How do I write putStr (sum [1,2,3]) correctly?
00:40:46 <Saizan> ?type sum [1..3]
00:40:51 <mgsloan> putStr (show (sum [1,2,3]))
00:40:51 <lambdabot> forall t. (Enum t, Num t) => t
00:41:22 <mgsloan> ?src print
00:41:23 <lambdabot> print x = putStrLn (show x)
00:41:26 <mgsloan> :)
00:41:40 <mgsloan> that'd be better written putStrLn . show
00:41:56 <mgsloan> clearly they never heard of pointfree when they wrote the prelude
00:42:04 <ska-fan> thanks
00:42:05 <thoughtpolice> print $ sum [1..3]
00:42:11 <thoughtpolice> damn, got beaten :(
00:42:22 <mgsloan> > print $ sum [1..3]
00:42:23 <lambdabot>  <IO ()>
00:42:28 <mgsloan> yeah, print is an IO
00:42:45 * mgsloan is just checking how smart LB is
00:42:51 <thoughtpolice> :>
00:54:50 <gmosx> hello!
00:56:39 <fax> hiu
00:58:25 <gmosx> may i ask a newbie question?
00:59:18 <ulfdoz> We should make poll from it.
00:59:37 <fax> lambdabot can make a poll?
00:59:51 <Saizan> gmosx: sure
00:59:56 <Saizan> ulfdoz: yes
01:00:02 <Saizan> ?help poll
01:00:03 <lambdabot> poll provides: poll-list poll-show poll-add choice-add vote poll-result poll-close poll-remove
01:00:14 <gmosx> I am trying to compile the conservative update of the original HWS code
01:00:29 <gmosx> i use:
01:00:32 <gmosx> runghc Setup.hs build
01:00:46 <gmosx> i think i have all required libraries installed..
01:00:54 <gmosx> but I get the following error:
01:01:02 <gmosx>  Preprocessing executables for hws-2006.9.27...
01:01:02 <gmosx> Building hws-2006.9.27...
01:01:02 <gmosx> src/Response.hs:43:7:
01:01:02 <gmosx>     Could not find module `Text.Html':
01:01:02 <gmosx>       it is a member of package html-1.0, which is hidden
01:01:11 <gmosx> any ideas?
01:01:31 <gmosx> btw, I am referring to this code: http://darcs.haskell.org/hws/
01:01:32 <lambdabot> Title: Index of /hws
01:01:32 <Saizan> gmosx: you've to add html to build-depends in the .cabal file, and rerun configure
01:01:46 <gmosx> hmmm
01:02:11 <gmosx> where is the .cabal file?
01:02:35 <Saizan> i'm referring to hws.cabal
01:02:48 <gmosx> ah right...
01:02:51 <gmosx> let me try this...
01:03:04 <Saizan> you've to uncomment two lines it seems
01:03:08 <gmosx> it is commented out at the moment
01:03:12 <gmosx> yeah...
01:04:14 <gmosx> thanks, it work now :)
01:04:43 <Saizan> :)
01:11:03 <gmosx> any idea where I should put an index.html file for the hws server to find it?
01:13:06 <gmosx> never mind i found this in httpd.conf
01:18:16 <desp> Chasing modules from: Data.Binary,Data.Binary.Put,Data.Binary.Get,Data.Binary.Builder
01:18:17 <desp> Could not find module `Data.ByteString':
01:18:19 <desp> any clues why this happens?
01:18:43 <desp> I did just install fpc-0.7
01:19:48 <AStorm> desp, is that GHC 6.6?
01:19:54 <desp> no, it's older :C
01:20:11 <desp> ghc 6.4.2
01:20:26 <AStorm> it's in fps, not fpc :>
01:20:45 <desp> uh, yeah, I did just install fps-0.7
01:20:52 <desp> but that's irrelevant
01:21:03 <desp> I'm trying to build Data.Binary now
01:21:07 <desp> and it doesn't build
01:21:07 <AStorm> Probably you didn't install it correctly.
01:21:32 <AStorm> this one? http://darcs.haskell.org/binary
01:21:33 <lambdabot> Title: Index of /binary
01:21:46 <desp> no, binary-0.3
01:21:57 <desp> http://hackage.haskell.org/packages/archive/binary/0.3/binary-0.3.tar.gz
01:22:00 <lambdabot> http://tinyurl.com/yuhj69
01:22:19 <desp> I runhaskelled Setup.lhs configure -p; build; sudo install
01:22:27 <desp> can't see anything incorrect in that
01:22:47 <AStorm> why -p?
01:22:50 <glguy> profiling
01:22:57 <desp> because I need the profiler
01:23:01 <AStorm> ah, right
01:23:08 <glguy> as an aside, you can: runghc Setup
01:23:15 <glguy> which saves a few key presses
01:23:23 <desp> only if I had it
01:23:32 <desp> oh, actually I do now... hm
01:23:42 <glguy> either way you can drop the .lhs
01:23:46 <desp> true
01:23:58 <desp> now that's really nice and all
01:24:02 <glguy> more of an interesting fact than helpful :)
01:24:07 <desp> but I suspect ghc is not finding the modules
01:24:15 <gmosx> hmm, when I just run hws it reports 95% CPU an 16% memory and rising...
01:24:16 <desp> and I don't see a -L equivalent option
01:24:27 <gmosx> without any load...
01:24:31 <desp> is there any way to specify an additional module search path for ghc?
01:24:36 <AStorm> desp, check the access rights
01:24:51 <AStorm> desp, nope, it should have been installed into ghc lib dirs
01:24:51 <glguy> desp: there is a -I flag or similar
01:24:54 <AStorm> maybe run ldconfig?
01:25:02 <gmosx> without load = no requests...
01:25:09 <gmosx> when I try ab -n 50
01:25:16 <gmosx> it doesnt even finish... any ideas?
01:26:20 <desp> ohh
01:26:26 <desp> so ghc is in /opt/ghc/
01:26:46 <desp> and fps in /usr/local/lib/ && /usr/local/lib64/
01:26:54 <AStorm> desp, you failed ;>
01:27:00 <desp> how do I tell the fps package to install in /opt/whatever?
01:27:04 <AStorm> --prefix?
01:27:08 <desp> it's not my system
01:27:24 <glguy> desp: you can install as a user:
01:27:30 <glguy> runghc Setup configure --prefix=$HOME
01:27:35 <glguy> runghc Setup install --user
01:27:48 <AStorm> yes, that will work too.
01:27:49 <glguy> instead of at the system level
01:28:00 <desp> thanks glguy
01:29:29 <AStorm> that configure could autodetect the prefix
01:29:43 <AStorm> why doesn't it do that eludes me :>
01:30:02 <glguy> AStorm: you are allowed to install it anywhere
01:30:15 <AStorm> yes, but the default should be good
01:30:21 <desp> is it possible to automatically remove the badly installed fps?
01:30:30 <glguy> AStorm: the default isn't good for a user level install
01:30:35 <AStorm> desp, of course, rm -r /usr/local/...
01:30:41 <glguy> AStorm: but you could isntall it to $HOME, $HOME/tools, etc.
01:31:03 <glguy> all that matters is that ghc knows where you installed it, which is specified by ghc-pkg register
01:31:03 <desp> don't I need to unregister it first?
01:31:06 <AStorm> glguy, would ghc find it there?
01:31:11 <glguy> AStorm: yeah
01:31:18 <AStorm> desp, it won't matter I think
01:31:31 <AStorm> you didn't register it anyway
01:31:36 <AStorm> (or ghc would find it)
01:32:14 <desp> Installing: /usr/local/lib/fps-0.7/ghc-6.4.2 & /usr/local/bin fps-0.7...
01:32:14 <desp> Registering fps-0.7...
01:32:14 <desp> Reading package info from ".installed-pkg-config" ... done.
01:32:14 <AStorm> is Data.Binary in stdlib now?
01:32:15 <desp> Saving old package config file... done.
01:32:15 <desp> Writing new package config file... done.
01:32:19 <desp> that's what the admin did for me
01:32:28 <AStorm> ah
01:32:31 <desp> and so it did get registered *somewhere*
01:32:33 <glguy> if it shows up in "ghc-pkg list" then its install
01:32:34 <glguy> ed
01:32:38 <desp> but not in the right place then
01:32:52 <glguy> and you should be able to see it in ghci
01:34:26 <desp> shit
01:34:36 <desp> so I installed it as --user
01:34:43 <desp> and configured with --prefix=$HOME
01:34:50 <desp> and it still doesn't appear
01:34:58 <desp> no
01:35:03 <desp> it appears in ghc-pkg list
01:35:05 <desp> !
01:35:12 <AStorm> ldconfig, uhm
01:35:14 <AStorm> run it
01:37:32 <desp> ldconfig with some option pointing to the locally-installed lib?
01:37:41 <desp> I'm sorry, I don't have ldconfig on my system
01:37:49 <desp> and I'm totally unfamiliar with it
01:38:33 <AStorm> so you don't need it then
01:38:44 <AStorm> (it should be there in /usr/sbin )
01:38:47 <desp> no --
01:38:54 <desp> it is on the system I have problems with :)
01:39:00 <desp> that is not my system though :)
01:39:03 <AStorm> (and is an admin tool, you have to fix /etc/ld.so.conf )
01:40:51 <glguy> there is an env var you can set to override ldconfig at the user level, no?
01:41:11 <glguy> LD_LIBRARY_PATH or some such
01:42:44 <glguy> and ldd can tell you if you actually have a problem with your shared libraries
01:43:03 <glguy> (I came late to this problem solving session so I odn't know exactly what is broken, I'm just throwing stuff out there)
01:43:14 <desp> I can't compile Data.Binary
01:43:27 <desp> because it's not finding the Data.ByteString I have installed and registered
01:43:42 <desp> ldconfig didn't help
01:43:51 <glguy> but you can ":browse Data.ByteString" in ghci?
01:44:08 <glguy> do you get an error that it is "hidden" or anything?
01:44:16 <desp> I can browse it
01:44:20 <desp> no errors
01:44:45 <glguy> any time I've had linker errors, I solved them with runghc Setup clean
01:44:50 <glguy> and it was because something had changed
01:45:24 <desp> no help
01:45:34 <dons> desp, oh, did you install a custom Data.ByteString?
01:45:36 <dons> outside of base?
01:45:38 <desp> yes
01:45:44 <desp> there wasn't any in base in 6.4.2
01:45:45 <dons> what did you do about the one in base though?
01:45:50 <dons> oh, you're using 6.4.?
01:45:58 <desp> I am, on this system
01:46:01 <dons> bytestrings are maybe 4-8x slower in 6.4... :)
01:46:09 <desp> I got access to a friend's computer with 2 GB RAM ;p
01:46:13 <dons> anyway, you need to add 'fps' to Data.Binary's dependecies
01:47:14 <desp> whew
01:47:50 <desp> src/Data/Binary/Builder.hs:134:20: Not in scope: data constructor `S.LPS'
01:47:54 <desp> now just that...
01:48:26 <dons> check in your fps src where LPS is defined
01:48:42 <dons> probably a matter of import qualified Data.Binary.Base as B
01:48:46 <desp> I downloaded fps-0.7
01:48:48 <dons> Data.ByteString.Base as B I mean
01:48:59 <dons> oh, LPS might be in Data.ByteString.Lazy  then
01:50:38 <desp> no, LPS is in Base...
01:51:01 <desp> oh, no
01:51:31 <desp> so binary-0.3 doesn't support fps-0.7
01:57:23 <desp> huh
01:57:41 <desp> is www.haskell.org down now?
01:58:04 <glguy> I can't get to it
01:58:16 <desp> great.
01:58:19 <desp> %_%
01:58:26 <glguy> what did you need from it
01:58:29 <desp> ghc 6.6
01:58:32 <desp> :)
01:58:42 <desp> it apparently isn't in gentoo portage
01:58:47 <glguy> sure it is
01:59:07 <desp> hmm, indeed.
01:59:18 <hpaste>  ska-fan pasted "YAHT, Exc. 4.6" at http://hpaste.org/1831
01:59:30 <ska-fan> Can someone have a look at that?
01:59:35 <desp> err
01:59:37 * glguy needs hpaste.org/latest
01:59:47 <ska-fan> It works, but it's quite verbose, and I wonder if it can be shortened somehow
02:00:13 <dolio> It can.
02:00:16 <desp> is ghc 6.6 broken on 64-bit?
02:00:19 <glguy> no
02:00:29 <desp> it's "hard masked"
02:00:38 * glguy runs ghc 6.6.1 on Gentoo amd64
02:00:41 <dolio> tuple4 could be 'tuple4 (FourTuple a b c d) = Just d ; tuple4 _ = Nothing'
02:00:49 <glguy> desp: un-hard mask it :0)
02:00:49 <desp> okay...
02:00:51 <ska-fan> ok, I'll revise
02:00:57 <desp> yeah, telling my friendly admin to
02:01:00 <|Steve|> ska-fan: That's about how I wrote it.
02:01:18 <fax> (,,,,)
02:01:21 <fax> oops
02:01:32 <dolio> tuple3 gets cut by 1 that way. The rest are as short as possible, I think.
02:01:39 <glguy> tuple3 (FourTuple _ _ c _) = Just c   -- might be a tad clearer
02:01:46 <glguy> but not shorter
02:02:10 <dolio> Unless you switch to records, maybe...
02:02:10 <hpaste>  ska-fan pasted "YAHT, Exc. 4.6, Try 2" at http://hpaste.org/1832
02:02:32 <glguy> ska-fan: you'll want to use the annotate button
02:02:36 <glguy> next time
02:02:44 <ska-fan> ok
02:03:30 <AStorm> well, here ghc 6.6.1 failed the compile
02:03:37 <AStorm> though the binary one works
02:04:01 <hpaste>  (anonymous) annotated "YAHT, Exc. 4.6, Try 2" with "(no title)" at http://hpaste.org/1832#a1
02:04:22 <ska-fan> anything else to remove?
02:04:27 <glguy> the type signatures?
02:05:04 <ska-fan> except for them
02:05:51 <Saizan> you can only use _ for unused fields of the constructors at this point
02:06:24 <ska-fan> I'm doing that
02:06:53 <hpaste>  dolio annotated "YAHT, Exc. 4.6, Try 2" with "records" at http://hpaste.org/1832#a2
02:07:41 <fax> hey
02:07:45 <fax> you know (,,,,,)
02:07:48 <fax> etc
02:07:54 <fax> how is that written?
02:08:05 <rubenz> Is there a ghc option to ignore trace functions?
02:08:10 <hpaste>  glguy annotated "YAHT, Exc. 4.6, Try 2" with "something like this (didn't typecheck it)" at http://hpaste.org/1832#a3
02:08:32 <fax> :t (,,,,)
02:08:34 <lambdabot> forall a b c d e. a -> b -> c -> d -> e -> (a, b, c, d, e)
02:08:56 <dolio> It's built-in, I believe. Special syntax.
02:08:57 <Saizan> fax: what do you mean?
02:09:01 <glguy> :t (,,,,,,,,,,).(,,,,,,,,,,)
02:09:02 <ska-fan> ok, this is a bit over my head for now, I'll move forward in YAHT :)
02:09:03 <lambdabot> forall b c d e f g h i j k a b1 c1 d1 e1 f1 g1 h1 i1 j1 k1. -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> (b1 -> c1 -> d1 -> e1 -> f1 -> g1 -> h1 -> i1 -> j1 -> k1 -> (a, b1, c1, d1, e1, f1,
02:09:03 <lambdabot> g1, h1, i1, j1, k1), b, c, d, e, f, g, h, i, j, k)
02:09:12 <fax> I would like to see the source code of ( and , and )
02:09:18 <fax> if that is written in haskell?
02:09:22 <glguy> ?
02:09:29 <glguy> didn't you ask about if earlier?
02:09:32 <AStorm> @src (a, b)
02:09:33 <lambdabot> Source not found. You speak an infinite deal of nothing
02:09:38 <Saizan> no, tuples are primitive
02:09:44 <glguy> these are primitive things
02:09:48 <AStorm> Yes.
02:09:51 <fax> all of the interesting things are primitive? :(
02:09:57 <glguy> they simply *exist*
02:10:04 <glguy> the compiler is written in Haskell however..
02:10:12 <glguy> so... you can still find the implementation
02:10:13 <fax> how can you add new primitives?
02:10:18 <glguy> change the compiler
02:10:18 <AStorm> glguy, somewhat, parts are in Yacc
02:10:26 <AStorm> (at least of GHC)
02:10:45 <Saizan> well you could define them in a infinite module, data (,) a b = (a,b); data (,,) a b c = (a,b,c) ....
02:10:47 <fax> It would not be useful to be able to add new primitives in haskell?
02:10:52 <AStorm> @src (,)
02:10:52 <lambdabot> Source not found. Do you think like you type?
02:10:58 <fax> Saizan: is it possible to write an infinite module?
02:11:21 <Saizan> fax: i don't think your filesystem would like it :)
02:11:26 <fax> hehe
02:11:36 <AStorm> Saizan, why store it there, when you can generate on the fly?
02:11:46 <fax> can you really? :D
02:12:01 <glguy> the tuples only go out to a certain number
02:12:05 <dolio> The only thing particularly special about them is the syntax. (,,,) looks nicer than Tuple4.
02:12:22 * glguy disagrees that "(,,,)" looks particularly "nice"
02:12:30 <fax> I really like the look of  (,,,)
02:12:35 <Saizan> AStorm: you need compiler support to "generate on the fly", i was giving a way to define them in the language
02:12:35 <AStorm> (1, 2, 3, 4) vs Tuple4 1 2 3 4
02:12:45 <AStorm> which one looks nicer?
02:12:47 <AStorm> :>
02:12:47 <fax> > (,,,) 1 2 3 4
02:12:48 <lambdabot>  (1,2,3,4)
02:12:52 <glguy> AStorm: that isn't what we are talking about
02:12:59 <glguy> so... you missed the point ;)
02:13:00 <fax> glguy: it is though
02:13:08 <fax> thats exactly what we are talkking abot :[
02:13:10 <glguy> fax: no: (,,,) 1 2 3 4
02:13:14 <glguy> and not (1,2,3,4)
02:13:21 <fax> glguy: they both do the same thing
02:13:25 <glguy> so?
02:13:32 <glguy> you said "I really like the look of (,,,)"
02:13:38 <fax> I do
02:13:57 <glguy> which is different than liking the look of (1,2,3,4)
02:14:02 <fax> im going to go through YAHT
02:14:05 <fax> it looks good
02:14:08 <glguy> kk
02:14:55 <dolio> Although having (,,,) tempts people to partially apply it like (,2,3,), which winds up not working.
02:15:17 <glguy> (,,,) suffers from the fence post problem
02:15:23 <fax> what is that?
02:15:27 <glguy> you have to count how many spaces there are between the commas
02:15:36 <fax> > (,2,3,) 1 4
02:15:36 <lambdabot>  Parse error
02:15:38 <glguy> among other things
02:15:40 <fax> ugh!
02:15:47 <fax> why not?
02:16:01 <glguy> what's another case where you can do that in Haskell?
02:16:28 <glguy> (++ "not this, for example" ++)
02:16:29 <dolio> Right sections are similar.
02:16:41 <glguy> (,"or this",)
02:16:48 <glguy> that one seems obvious that it doesn't work
02:16:52 <fax> > (\a b -> (,,,,) a 2 3 b) 1 4
02:16:53 <lambdabot>  Add a type signature
02:16:57 <fax> >:|?
02:17:04 <glguy> if you find yourself needing a huge tuple..... make a data type
02:17:29 <dolio> > (: []) -- works
02:17:30 <lambdabot>  Add a type signature
02:17:37 <dolio> > (, 2) -- doesn't
02:17:38 <lambdabot>  Parse error
02:17:41 <fax> lambdabot: what is a type signature?
02:17:54 * glguy dreads the day he comes by: (1,,,2,3,) 'a' 'b' 'c'
02:17:58 <Saizan> > (\a b -> (,,,) a 2 3 b) 1 4
02:17:59 <AStorm> fax, e.g. (: []) :: Int
02:18:00 <lambdabot>  (1,2,3,4)
02:18:01 <dolio> Heh.
02:18:12 <fax> Saizan: ah!
02:18:28 <fax> ok AStorm thanks
02:18:46 <fax> > (: []) 1
02:18:48 <lambdabot>  [1]
02:18:48 <Saizan> > (\a b -> (,,,,) a 2 3 b) 1 4 :: Int -> (Int,Int,Int,Int,Int)
02:18:49 <lambdabot>  <Int -> (Int,Int,Int,Int,Int)>
02:19:34 <glguy> fax: you needed a type signature because you didn't supply enough arguments
02:19:45 <glguy> you didn't supply enough because you used a tuple that was one too big
02:19:50 <glguy> which brings us back to the fence post
02:20:15 <fax> what does this mean
02:20:23 <fax> "Just make sure theyâ€™re indented the same amount, or you will have layout problems"
02:20:26 <fax> layout problems?
02:20:33 <AStorm> fax, syntax errors
02:20:36 <AStorm> :>
02:20:57 <AStorm> (or other stupid misunderstandings between you and the compiler)
02:21:16 --- mode: ChanServ set +o glguy
02:21:32 --- kick: glguy was kicked by glguy (forced bedtime)
02:25:34 <hpaste>  ska-fan pasted "YAHT, Exc. 4.7" at http://hpaste.org/1833
02:25:46 <ska-fan> I'm not sure if that's what the author means
02:26:07 <ska-fan> it works, but the function returns a lot of Lefts and Rights instead of just the haskell-tuple / value
02:31:11 <fax> read :: (Read a) => String -> a
02:31:16 <fax> what is => ?
02:31:37 <cinimod> ska-fan: you'd have to give me a link to the exercise
02:31:48 <fax> I just downloaded it http://darcs.haskell.org/yaht/yaht.pdf
02:32:08 <cinimod> fax: you can read it as provided a is in the class a then read takes a string and returns a
02:32:26 <cinimod> oops I meant the class Read not the class a
02:32:30 <mgsloan> what's a good way to dump the types for all the functions in a module?
02:32:36 <mgsloan> (using ghci or something)
02:32:43 <rubenz> is calling length on a ByteString a constant time operation?
02:32:45 <kalmar> :b modulename
02:32:49 <kalmar> oh
02:32:50 <kalmar> never mind
02:33:11 <kalmar> rubenz: not for lazy ones at least
02:33:16 <dolio> rubenz: It is for strict strings, but not for lazy ones, I think.
02:33:44 <fax> ok so how do you know which a's Read can use?
02:33:46 <fax> for example, No instance for (Read (IO Int))
02:34:25 <dolio> You look at the docs for the Read class for the list of things that implement it.
02:34:30 <cinimod> fax: I'd try :i Read at the ghci or hugs command prompt
02:34:41 <fax> ok thanks a lot
02:36:20 <kalmar> :i Read makes a mess
02:36:27 <mgsloan> ghci Properties.hs ../XMonad.hs ../Config.hs ../Operations.hs ../StackSet.hs
02:36:27 <mgsloan> ../Operations.hs:21:22: Could not find module `Config':  it is a member of package ghc-6.6, which is hidden
02:36:33 <kalmar> stupid tuples
02:37:28 <dolio> I think there used to be less, but 7-tuples weren't enough for people. :)
02:37:53 <dolio> Or something like that.
02:37:59 <cinimod> fax: but if you are being told no instance for Read (IO Int) that's probably not what you meant
02:38:34 <fax> aha yeah
02:38:51 <ska-fan> cinimod: it's in the pdf fax linked to
02:39:08 <fax> @redo a <- b
02:39:08 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 3}) "Parse error"
02:39:10 <cinimod> ska-fan: I'm looking now
02:39:23 <fax> @src <-
02:39:23 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
02:39:27 <fax> hhaha
02:40:02 <dolio> <- is part of do syntax (among other things).
02:41:00 <fax> I am trying to change a two line function into a one line removing <-
02:41:16 <fax> I think you can use >>
02:42:34 <cinimod> ska-fan: your code looks like a good answer although I must say I can't really see the point of the exercise
02:43:10 <cinimod> it just seems to be a simple isomorphism
02:43:44 <ska-fan> It's just an exercise :) The point is for me to learn haskell syntax / concepts :)
02:44:05 <dolio> The isomorphism might be the point.
02:44:40 <fax> @src do
02:44:40 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
02:44:53 <cinimod> ok but it seemed to be about using Either
02:45:00 <dolio> Ah.
02:45:17 <cinimod> Maybe a better exercise would be to define a monad with it
02:45:34 <cinimod> but I'm not sure where monads come in YAHT
02:45:42 <ska-fan> they come later
02:45:51 <|Steve|> Chapter 9.
02:46:05 <ska-fan> It took me 20 minutes to write that down and wrap by head around it, so the exercise is not that bad probabyl
02:46:13 <|Steve|> And it's the most poorly written chapter of the first 9 (which is as far as I've read).
02:47:20 <fax> how do you conevert IO String into String?
02:47:25 <fax> return is one way?
02:47:28 <cinimod> you don't
02:48:40 <fax> hmm I am really stuck..
02:48:46 <hpaste>  fax pasted "getNumber" at http://hpaste.org/1834
02:48:51 <cinimod> you should write most of your code pure
02:48:54 <fax> any tips on how to make this one line?
02:49:08 <fax> I mean I want to remove temporary variable n
02:49:17 <cinimod> and then wrap a small amount of (IO) monadic code to do IO around it
02:49:54 <Saizan> fax: liftM read getLine
02:49:55 <dolio> > read `liftM` return "123" :: [Int]
02:49:56 <lambdabot>  [123]
02:50:48 <fax> ok thanks, I need to understand liftM
02:50:58 <fax> lol
02:50:59 <fax> http://www.zvon.org/other/haskell/Outputmonad/liftM_f.html
02:51:00 <lambdabot> Title: Haskell : liftM
02:51:07 <fax> the example1
02:51:19 <cinimod> fax: that's just a fancier way of doing what you have written
02:51:39 <cinimod> what are you going to do with the number once you have it?
02:52:06 <fax> stick it in a list, later multiply them together and add them and factorial them
02:52:59 <cinimod> fax: write that function first and then think about IO
02:53:25 <Saizan> ?src liftM
02:53:25 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
02:53:25 <fax> waat
02:53:32 <fax> oh
02:53:33 <fax> haha
02:53:34 <|Steve|> fax: Reading YAHT?
02:53:39 <fax> liftM is my code
02:53:45 <fax> |Steve|: yes
02:54:00 <cinimod> a higher order function
02:54:03 <Saizan> liftM f m = m >>= return . f, also
02:54:14 <fax> Saizan: How is that?
02:54:19 <fax> I prefer m >>= return . f
02:54:50 <Saizan> than liftM?
02:54:57 <fax> than do { x1 ...
02:55:15 <cinimod> do is syntactic sugar for >>=
02:55:25 <fax> hmm
02:55:34 <fax> I thought that do is sugar for more than just >>=
02:55:39 <|Steve|> @pointless \f m = m >>= return . f
02:55:40 <lambdabot> (line 1, column 6):
02:55:40 <lambdabot> unexpected "="
02:55:40 <lambdabot> expecting pattern or "->"
02:55:56 <|Steve|> @pointless \f m -> m >>= return . f
02:55:56 <lambdabot> fmap
02:56:23 <fax> @hdoc liftM
02:56:23 <lambdabot> liftM not available
02:56:26 <fax> :/
02:56:26 <cinimod> fax: you can write a monadic expression with >>=
02:56:33 <|Steve|> @src fmap
02:56:33 <lambdabot> Source not found. My mind is going. I can feel it.
02:56:45 <fax> ahh import Control.Monad
02:56:50 <cinimod> and then do a simple replace with do and <-
02:57:10 <fax> cinimod: like, >>= are replaced by semicolons?
02:57:24 <cinimod> do was introduced about 10 years ago to make expressions with >>= easier to read
02:57:33 <Saizan> fax: do x <- m; ... === m >>= \x -> ...
02:57:47 <Saizan> fax: do m1; m2 === m1 >> m2
02:57:56 <fax> Ohh
02:57:57 <fax> yeah
02:58:05 <cinimod> Saizan beat me to it
02:58:18 <Saizan> cinimod: parallelization :)
02:59:08 <fax> f `g` h is equivalent to g(f(g(_))) ?
02:59:15 <fax> I mean g(f(h(_)))
02:59:29 <fax> oh wait of course its not
02:59:47 <|Steve|> f `g` h is the same as g f h.
03:00:14 <|Steve|> > (div 5 2, 5 `div` 2)
03:00:15 <lambdabot>  (2,2)
03:03:43 <twb> Yow.
03:06:13 <hpaste>  fax annotated "getNumber" with "ugh" at http://hpaste.org/1834#a1
03:06:23 <fax> now my type annotation is far too long :/
03:06:38 <fax> is there some way to fix that
03:06:54 <Saizan> you can just have getNumber :: IO Int
03:06:55 <mgsloan> !Yow
03:07:06 <mgsloan> !yow
03:07:07 <fax> Why do I have to say IO?
03:07:18 <Saizan> because getNumber uses IO
03:07:33 <Saizan> ?type getLine >>= return . read
03:07:41 <lambdabot> forall b. (Read b) => IO b
03:08:22 <fax> I cannot write getNumber :: b Int
03:08:51 <Saizan> no, because that would mean that getNumber can be used with every b
03:09:08 <fax> ah :D
03:09:12 <Saizan> which is not true, because getNumber is force to IO by getLine
03:09:15 <Saizan> *forced
03:09:39 <fax> getNumber = getLine >>= return . read :: IO Int -- 47 chars
03:09:52 <Saizan> liftM is shorter :)
03:10:02 <Saizan> ah, btw, there's readLn
03:10:08 <Saizan> ?src readLn
03:10:08 <lambdabot> readLn =  do l <- getLine; r <- readIO l; return r
03:10:16 <fax> readLn = getLine?
03:10:18 <Saizan> ?type readLn
03:10:20 <lambdabot> forall a. (Read a) => IO a
03:10:28 <fax> oh :D
03:10:34 <Saizan> no, getNumber = readLn :: IO Int
03:11:02 <fax> cool
03:11:04 <fax> thats def. the shortest
03:12:25 <|Steve|> @src readLn
03:12:25 <lambdabot> readLn =  do l <- getLine; r <- readIO l; return r
03:12:41 <kalmar> :t readIO
03:12:43 <lambdabot> forall a. (Read a) => String -> IO a
03:12:57 <mgsloan> ?src readIO
03:12:57 <lambdabot> Source not found. Do you think like you type?
03:12:59 <kalmar> seems pointless
03:13:05 <mgsloan> yeah, what's with that
03:13:06 <mm_freak> isn't there any predefined function for replacing substrings?
03:13:09 <kalmar> readIO = return . read?
03:13:21 <|Steve|> :t return . read
03:13:23 <lambdabot> forall b (m :: * -> *). (Monad m, Read b) => String -> m b
03:13:40 <mgsloan> :t liftM read
03:13:42 <lambdabot> forall a (m :: * -> *). (Read a, Monad m) => m String -> m a
03:13:51 <|Steve|> Heh, so many ways to do it.
03:14:13 <hpaste>  ska-fan pasted "YAHT, Exc. 4.8" at http://hpaste.org/1835
03:14:16 <tero-> is there anything similar as getFileStatus in System.Posix.Files that I could use with the Windows build of ghc?
03:14:25 <tero-> I would like to get the modification date of a file
03:14:27 <ska-fan> someone care to take a look at this? it seems correct to me
03:14:31 <mgsloan> > let readLn = getLine >>= liftM read in readLn
03:14:32 <lambdabot>  Couldn't match expected type `Char' against inferred type `String'
03:14:42 <Saizan> ?type msum . fmap (return . fst) . reads
03:14:44 <lambdabot> forall (m :: * -> *) a. (MonadPlus m, Read a) => String -> m a
03:14:57 <fax> @src in
03:14:58 <lambdabot> Source not found. Just what do you think you're doing Dave?
03:15:10 <fax> how do you write in?
03:15:18 <fax> let .. in
03:15:26 <mgsloan> keywords
03:15:30 <fax> ok
03:16:08 <mgsloan> some things that are used rather promiscuously and aren't keywords are defined in the prelude
03:16:29 <mgsloan> . and $, for example, are just infix operators
03:16:54 <Saizan> ska-fan: you don't need the Cons x Nil case, it's handled by the other two, also listFoldl is not a left fold, is just right fold that takes an f with the arguments swapped
03:17:37 <Saizan> s/is just/it's just a/
03:17:49 <mboes> hi, anyone know how to show the generated test data in QuickCheck2?
03:18:51 <fax> getNumber = liftM (read::String -> Int) getLine
03:19:14 <ska-fan> Saizan: thanks
03:20:05 <hpaste>  fax annotated "getNumber" with "same length" at http://hpaste.org/1834#a2
03:20:26 <Saizan> ska-fan: you should have liftFoldl f 0 [1,2,3] = (f (f (f 0 1) 2) 3) instead yours is (f (f (f 0 3) 2) 1)
03:21:09 <ska-fan> I'll use that to test, thanks
03:22:49 <ska-fan> listFoldl f initial (Cons x xs) = listFoldl f (f initial x) xs
03:22:58 <ska-fan> that better? :)
03:23:00 <Saizan> exactly :)
03:27:52 <fasta> I have two lists of STRefs that I want to compare in O(n lg n) for equality. How can I do that?
03:28:14 <fasta> It appears there is no instance for Ord, so it seems currently impossible.
03:28:20 <kalmar> isn't that doable in O(n)?
03:28:37 <kalmar> all . zipWith (==)
03:28:38 <kalmar> ?
03:28:45 <fasta> kalmar: no
03:29:02 <fasta> kalmar: think about it for 5 seconds and find out why that fails.
03:29:40 <kalmar> strefs contain..?
03:30:31 <fasta> kalmar: It would better not to help me further, since you obviously have too little experience with them.
03:31:29 <Saizan> fasta: i've seen this problem on -cafe i think, as a workaround they sticked a Data.Unique.Unique with each STRef and used that for Ord
03:31:47 <kalmar> *shrug* all right
03:31:51 <fasta> Saizan: right, that is possible.
03:32:10 <fasta> Saizan: do you think it would be a good thing to have an Ord instance?
03:32:20 <fasta> Saizan: I am thinking of opening a feature request
03:32:32 <Saizan> yeah i think we should have it
03:32:43 <eivuokko> Ord (STRef s a)?
03:33:01 <fasta> eivuokko: yes
03:33:16 <eivuokko> It probably isn't there because of compacting gc or some such reason.
03:33:26 <fax> :t +
03:33:28 <lambdabot> parse error on input `+'
03:33:30 <fax> :t `+`
03:33:32 <lambdabot> parse error on input ``'
03:33:51 <fax> what is the type of +?
03:33:54 <fasta> eivuokko: I am not _sure_, but I think one can work around that in the implementation too.
03:34:00 <dons> :t (+)
03:34:01 <fasta> eivuokko: it does complicate matters.
03:34:02 <lambdabot> forall a. (Num a) => a -> a -> a
03:34:10 <fax> ahh thanks dons
03:34:13 <Saizan> eivuokko: woudln't that be a problem even for Eq?
03:34:23 <fax> I see what I did wrong
03:34:42 <kalmar> fasta: argh never mind
03:34:51 <kalmar> sorry that was dumb
03:35:01 <eivuokko> Saizan, Well, even after GC, the same STref is same STRef, while order in memory between diffrent STRefs would change.
03:35:26 <eivuokko> Order in memory being the easiest sounding way to compare STRefs.
03:35:41 <fasta> The implementation could use Unique under the hood.
03:35:49 <fasta> In the case the instance is used.
03:36:00 <eivuokko> Hmm
03:36:02 <fasta> At the hidden cost of a pointer per ref.
03:36:24 <fasta> well, size(Unique) actually
03:39:28 <fax> how do you print a newline?
03:39:35 <fax> better than putStrLn "" ?
03:39:58 <kalmar> :t putChar
03:40:00 <lambdabot> Char -> IO ()
03:40:06 <kalmar> putChar '\n'
03:40:07 <kalmar> ?
03:40:26 <fax> do I have to say \n?
03:40:49 <|Steve|> newline = putChar '\n' -- Then just use newline.
03:40:55 <kalmar> yea
03:41:16 <fax> alright, thank you
03:42:20 <fasta> Add your name to the CC list if you want to give this feature a higher priority: http://hackage.haskell.org/trac/ghc/ticket/1554
03:42:22 <lambdabot> Title: #1554 (Ord (STRef s a) instance) - GHC - Trac
03:43:46 <fasta> s/name/e-mail address
03:53:05 <fax> ugh
03:53:10 <fax> how do you print an int without a newline after it
03:53:11 <fax> ?
03:53:25 <Heffalump> putStr (show i)
03:53:51 <fax> ok thanks
03:54:30 <hpaste>  fax annotated "getNumber" with "yaht ex_3_10" at http://hpaste.org/1834#a3
03:54:49 <fax> I did ex 3 10 but I think my function ex_3_10 really sucks, is that true?
03:55:08 <fax> like how else might you do that?
03:55:47 <Heffalump> looks quite nice to me
03:56:10 <fax> hm ok thanks
03:56:26 <Heffalump> @src forM_
03:56:26 <lambdabot> forM_ = flip mapM_
03:56:34 <Heffalump> ah, I was just thinking that looked like it :-)
03:56:46 <Saizan> fax: those return () are useless
03:57:14 <Heffalump> oh, true
03:57:17 <fax> ah they are :D
03:57:20 <Saizan> and you can do things like putStr $ "The sum is " ++ sum numbers
03:58:08 <fax> it says, Couldn't match expected type `[Char]' against inferred type `Int'
03:58:23 <Saizan> ah yeah, forgot show
03:58:28 <fax> ahh
03:58:29 <fax> yeah
03:58:43 <Saizan> putStr $ "The sum is " ++ show (sum numbers)
03:58:50 <|Steve|> Not putStrLn?
03:59:47 <fax> 20 factorial is -2102132736
03:59:52 <fax> haha
04:00:09 <|Steve|> > product [2..20]
04:00:10 <lambdabot>  2432902008176640000
04:00:18 <Saizan> eheheh, you should use Integer :)
04:00:31 <fax> > show (product [2..20])
04:00:32 <lambdabot>  "2432902008176640000"
04:00:35 <fax> ohh
04:00:38 <fax> yes, thank you
04:00:39 <fasta> fax: that's because you claim it's an Int
04:01:11 <hpaste>  fax annotated "getNumber" with "better" at http://hpaste.org/1834#a4
04:01:16 <fax> ok that is a lot better
04:01:49 <fasta> fax: You only need the type annotation at the end
04:02:05 <fasta> fax: saying that factorial number :: Integer would be bette
04:02:08 <fasta> fax: r
04:02:10 <Saizan> you don't need the do inside the lambda
04:03:00 <hpaste>  fax annotated "getNumber" with "ok" at http://hpaste.org/1834#a5
04:03:09 <fax> ok yes, thats much better
04:03:12 <fasta> For complicated code, instead of return [] you can do return (fail "Empty list case")
04:03:22 <fasta> For trivial code that is of no use.
04:03:40 <fax> I wanted to return [] because I will cons some things onto it
04:04:05 <fasta> > fail "Empty list" ::[Int]
04:04:06 <lambdabot>  []
04:04:12 <fasta> fax: see? They are the same
04:04:25 <fax> why do you type "Empty list"?
04:04:48 <Botje> :t fail
04:04:50 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
04:04:56 <fasta> fax: That's why
04:05:14 <fax> :t []
04:05:16 <lambdabot> forall a. [a]
04:05:18 <Heffalump> errm, I think that's a terrible idea
04:05:25 <fax> :t fail :: [Int]
04:05:27 <lambdabot>     Couldn't match expected type `[Int]'
04:05:27 <lambdabot>            against inferred type `String -> m a'
04:05:28 <Heffalump> return [] isn't a failure case at all
04:05:37 <Heffalump> it's just saying we've got to the end
04:05:49 <fax> yes (1:(2:(3:[])))
04:05:51 <Saizan> yeah, i don't see how fail fits here
04:06:00 <Heffalump> (ab)using the fail definition in the list monad, while operating inside another monad, is just wrong
04:06:00 <fasta> Heffalump: I didn't say it fits in this case.
04:06:19 <fax> ok thanks again everyone
04:06:19 <Heffalump> I can't really think where it would fit
04:06:25 <fax> I gotta run to shops, later
04:07:15 <Saizan> Heffalump: it's kind of the same concept behind lookup :: k -> Map k a -> m a
04:08:30 <fasta> In some sense [] is a magic constant in some cases.
04:08:42 <fasta> Using fail to document is quite precise.
04:08:57 <Heffalump> Saizan: ok, but in that case the overloading makes it worthwhile.
04:09:06 <Saizan> Heffalump: yeah
04:11:15 <fasta> How do I express that whenever a function is available from module A and B it should take A?
04:11:26 <fasta> I think the module system is a bit too inexpressive.
04:11:43 <fasta> I know how the qualified stuff works
04:12:00 <fasta> So, it was more a remark, not an actual question.
04:13:10 <Botje> fasta: you can hide the function from module B
04:13:42 <fasta> What I often end up doing is:
04:13:53 <fasta> import qualified Data.List as List
04:14:29 <fasta> import Data.List hiding (<all stuff I import from e.g. Data.Map))
04:17:47 <fasta> If I could just say (import (difference (Data.List Data.Map))) there would be no problem
04:17:52 <fasta> This is what PLT Scheme does, AFAIK.
04:18:13 <fasta> The Haskell module system is one of its weak points.
04:19:02 <Philippa> it's like the record system though: the right set of improvements isn't obvious
04:20:09 <fasta> Philippa: I find that too vague w.r.t. my commentary
04:20:14 <Philippa> being able to express a preference in case of ambiguity has its uses though
04:20:35 <Philippa> if you get people talking about module system improvements it doesn't take long before someone starts pointing at ML-style systems
04:20:39 <Philippa> and then the argument never ends
04:21:05 <fasta> What's wrong with ML-style systems?
04:21:11 <fasta> :)
04:21:35 <fasta> I thought Scheme 48 module system is about the same.
04:21:50 <fasta> Everyone who used it thought it was a good idea, AFAIK.
04:22:48 <Philippa> what's "wrong" with ML-style systems is that there's a whole large design space
04:25:05 <Philippa> is the Scheme 48 system first class by any chance?
04:26:47 <fasta> Philippa: yes
04:27:56 <Philippa> now that opens up an entire canning factory of worms in Haskell
04:28:56 <fasta> Philippa: I believe it has separate compilation, though
04:29:10 <Philippa> *shrug* - so?
04:29:56 <fasta> Philippa: are these cans of worms described anywhere, since you seem so convinced?
04:30:23 <Botje> newtype Can = [Worm]
04:31:17 <Philippa> fasta: not specifically, because little of the module system literature is aimed at a pure, lazy language. However, the fact there's so much literature ought to tell you something in and of itself
04:31:26 <Philippa> also, it needs new term-level constructs
04:31:51 <EvilTerran> is there much module system theory?
04:31:55 <Philippa> shitloads
04:32:08 <Philippa> it's been an active area of research for over two decades
04:32:43 <EvilTerran> oh right. i guess that was to be expected, given the different approach taken by every language ever
04:33:10 <Philippa> not just that, but there's a whole pile of issues once you add functors
04:33:28 <EvilTerran> as in parameterised modules, not fmap, right?
04:33:53 <Philippa> yeah
04:34:31 <Philippa> fasta: sufficiently first-class modules amount to records, does that tell you anything?
04:34:45 <EvilTerran> seems to me you should be able to do the same job as ML's functors with Haskell's classes...
04:34:55 <Philippa> you can, it's just potentially rather painful
04:35:02 <fasta> EvilTerran: AFAIK, no
04:35:27 <Philippa> fasta: you have some reading to do :-)
04:35:29 <fasta> EvilTerran: you can't fake anonymous modules.
04:35:33 <EvilTerran> a lot of it, anyway. i can't remember what exactly can be passed as parameters to functors.
04:35:52 <fasta> Philippa: Can you fake anonymous modules with type classes?
04:36:06 <EvilTerran> fasta, anonymous modules are a means to an end, and you can achieve that end with typeclasses, as i understand it
04:36:29 <Philippa> no, but you can get something almost as good: you can 'name' them with an arbitrary type - an encoding of natural numbers, say
04:37:05 <Philippa> and it doesn't lose you any computational power
04:37:47 <fasta> Philippa: ok, so, given a compiler for type classes it it's relatively easy to build another compiler which compiles to type classes having first class modules.
04:38:06 <EvilTerran> fasta, why do you need first class modules?
04:38:47 <fasta> EvilTerran: Heh, that's not how this dicussion started.
04:38:54 <EvilTerran> instead of module Foo (type a) where { ... } (or whatever the ML syntax is), you can write class Foo a where {...}...
04:39:17 <EvilTerran> i mean, first class modules'd be cool an' all, but we don't really /need/ 'em
04:39:22 <Philippa> fasta: Not really, you can't build a new instance containing whatever you want at run-time
04:39:22 * EvilTerran goes to have a look at the logs
04:39:32 <Philippa> like I said, it depends on your value of 'first-class'
04:39:48 <dolio> Oleg's done ML-esque modules/functors using type classes. But it's probably not something you'd want to use.
04:39:51 <Philippa> and a sufficiently first-class module system is also a record system
04:40:00 <Philippa> (and we all know how controversial /those/ get, right?)
04:40:04 <EvilTerran> modules at runtime? O.o
04:40:21 <Philippa> EvilTerran: makes an exceeding amount of sense in a system that wants nearasdammit 100% uptime
04:40:45 <Philippa> hell, what do you think hs-plugins is for?
04:41:18 <EvilTerran> well, yes...
04:41:46 <fasta> Philippa: for a toy project of dons? ;)
04:43:30 <EvilTerran> i see where you're coming from, but it seems to me that wholly first class modules at runtime would be horrifically hairy
04:43:50 <dolio> EvilTerran: If you think of modules as records where various fields in the record fulfill various type schemas...
04:44:01 <dolio> EvilTerran: Then, obviously, you can construct records at runtime.
04:44:37 <Philippa> EvilTerran: it doesn't have to be particularly at all - it's pretty easy in a lisp, for example
04:45:03 <Philippa> and there's a certain amount of pre-existing theory
04:45:22 <EvilTerran> well, yes, but that's records, dolio. i guess i just fundamentally see a "module" as a bit of a compiletime thing. i haven't done enough reading of theory to break that particular mental image ;]
04:46:16 <fasta> Uhm, why does cpphs replace Foo.bar by Foo.<replacement of bar>?
04:47:29 <wli> Modules are also a link-time phenomenon.
04:47:49 <wli> Which makes them runtime in the case of dynamic linking.
04:48:29 <dolio> Something like: map = { empty :: m k v, singleton :: k -> v -> m k v, insert :: k -> v -> m k v -> m k v ... }
04:48:41 <Philippa> and then there's the amusingly horrific lengths that OO folks go to in order to fake a good first-class ML-style system
04:48:45 <fasta> Modules in what ever restricted sense are premature optimization.
04:48:58 <dolio> Then map is a 'first class module', which carries around all the constructors, destructors, etc. for working with maps.
04:49:02 <Philippa> fasta: that's not an entirely fair comment
04:49:34 <Philippa> it's not that long that we've had the type theory to do statically-safe modules without some fairly major restrictions
04:49:47 <EvilTerran> there's a sense of "oh god all this theory doesn't fit into my brain"
04:50:14 <EvilTerran> which i suspect you'd get with /too/ agressively first-order modules on top of everything haskell's already got
04:50:48 <wli> I say go aggressively higher-order, first-class, etc. with modules.
04:51:08 <EvilTerran> modules as runtime values?
04:51:36 <Philippa> wli: I'd like to do that, but doing it really /right/ involves a little bit of thinking about how to integrate it with the existing IO monad and possibly an IO-subset designed for "safe" module work only
04:51:56 <Philippa> though that does also net us a way of doing initialisers sensibly :-)
04:52:45 <fasta> EvilTerran: I am currently using functions that take 13 arguments
04:52:49 <wli> The whole "language of the future" bit Haskell's got is for all the high-flown goodness.
04:52:52 <fasta> EvilTerran: those should be in a module.
04:53:02 <fasta> EvilTerran: a run-time module
04:53:02 <EvilTerran> ... okay.
04:53:13 <Philippa> sure. But we're also surprisingly careful about getting the theory right
04:53:16 <EvilTerran> sounds like a record to me...
04:53:25 <Philippa> because our idea of "high-flown goodness" involves getting the typing right
04:53:34 <Philippa> EvilTerran: this has already been pointed out many times
04:54:26 <EvilTerran> i know, i know.
04:54:41 <wli> Philippa: Also a big part of it, and a big contrast with e.g. OO/etc.
04:54:42 <dolio> I seem to recall hearing that having type classes and ML modules in the same type system was a relatively recent area of research.
04:55:03 <EvilTerran> what about being able to dynamically create typeclass instances?
04:55:18 <dolio> I suppose it's not obvious if you want your first-class modules to have typeclasses inside them.
04:55:22 <EvilTerran> seems to me that'd fit better inside Haskell's current system.
04:55:58 <wli> dolio: The whole instance visibility thing is messy even with the current module system.
04:56:07 <dolio> wli: Yeah.
04:56:18 <Philippa> so we're already looking at doing a rip/replace on one of our biggest features...
04:56:20 <EvilTerran> given that the point of typeclasses is to provide a consistent interface to disparate bits of code
04:56:42 <wli> Philippa: Which is that?
04:56:46 <Philippa> I agree it wants happening, but I suspect it'll end up being a new language with the name Haskell going to something more backwards compatible
04:56:48 <Philippa> typeclasses
04:57:06 <EvilTerran> some or all of which'll be written at a later date, and by a different person, that the typeclass was
04:57:14 <EvilTerran> *than
04:57:20 <wli> Philippa: I don't understand where the rip/replace comes in.
05:21:20 <ndm> @seen dcoutts
05:21:20 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-overflow, #haskell and #ghc. I last heard dcoutts speak 2d 18h 53m 20s ago.
05:21:28 <ndm> @seen dcoutts_
05:21:28 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell-overflow, #haskell and #ghc. I don't know when dcoutts_ last spoke.
05:21:31 <ndm> @seen dcoutts__
05:21:32 <lambdabot> I saw dcoutts__ leaving #gentoo-haskell, #haskell, #ghc and #haskell-overflow 17d 18h 14m 35s ago, and .
05:30:30 * wli tries to remember if ndm was the one who did the state machine -based parser combinators.
05:33:19 <ndm> wli, i've done some state machine/parser stuff, but not combinators, it was offline processing
05:34:26 <wli> Left recursion and incremental parsing are the concerns here. Mostly left recursion.
05:35:48 <ndm> left recursion was indeed a pain, since i was doing offline analysis i could detect it in advance
05:36:10 <ndm> plus i had stuff for "bracketing" as a separate stage, which removes the most common need for left recursion
05:36:38 <ndm> i never considered incremental parsing, but don't think it should be any harder than any other parser system - none deal with incremental that well
05:37:15 <wli> Well, recursive descent is what really kills everything.
05:38:03 <ndm> my parsers were set up so that wasn't really necessary, by separating the stages in a different way
05:38:18 <wli> Which way is that?
05:40:14 <wli> I might be able to just use them if they behave well enough wrt. ambiguity/nondeterminism.
05:41:04 <dolio> http://caml.inria.fr/pub/ml-archives/caml-list/2007/07/7a34650001bf6876b71c7b1060ac501f.en.html
05:41:08 <lambdabot> Title: Archives of the Caml mailing list > Message from oleg@p..., http://tinyurl.com/38xr4w
05:45:03 <Philippa> presumably a big part of (good) incremental parsing is a sensible error model while changes that cause errors're happening?
05:46:03 <ndm> wli: http://www-users.cs.york.ac.uk/~ndm/parsing/
05:46:05 <lambdabot> Title: Neil Mitchell - Parsing
05:46:31 <ndm> Philippa - is that error message going to increase as the grammar grows larger? if so, everyone will get bored and not finish it
05:46:56 <ndm> thats one of the great strengths of parsec, sensible error messages for free, since if its more expensive people won't do it
05:49:13 <mboes> hey ndm
05:49:19 <mboes> i have a uniplate question
05:50:14 <mboes> how would you implement the subst example in the HW'07 paper if you had several datatypes instead of just one to represent your AST?
05:50:19 <Philippa> ndm: I mean that with a typical use case for incremental parsing you really want to keep track of how much of the parse tree is still valid (for some value of "valid")
05:51:27 <Philippa> I'd probably need to read up a lot more on error recovery/correction strategies to say more useful things there though
05:55:49 <ihope> I'm trying to think up a way for a lambda calculus -> SKI calculus converter to be able to pretend that every lambda calculus construct has a corresponding SKI calculus construct.
06:01:13 <EvilTerran> hm. SKI -> \ is easy, but that's a bit trickier...
06:02:23 <EvilTerran> (S -> \x.\y.\z. x z (y z); K -> \x.\y.x; I -> \x.x ...)
06:02:59 <ihope> Yeah.
06:03:18 <ndm> mboes, how do you mean, can you hpaste your data type?
06:03:28 <ihope> Obviously you can't take it directly, since every lambda calculus construct does not have a corresponding SKI calculus construct...
06:03:50 <ndm> ihope, have you taken a look at Reduceron? it does exactly that, its also in SPJ's book
06:03:52 <EvilTerran> lessee... \-calc has two syntactic thingies; application and abstraction
06:03:57 * Philippa is thinking that it'd be interesting to try designing a 'live' parser based around three zippers - the input stream, the output AST and the input stream blocked up in a manner corresponding to the grammar
06:04:17 <ihope> SPJ's book?
06:04:48 <Philippa> EvilTerran: you missed out variables
06:05:04 <Philippa> they're a little bit important in \calc
06:05:09 <EvilTerran> well, yes. i was hoping they'd come out in the wash. :P
06:05:26 <ndm> ihope, yes, the one on my desk :) - implementation of functional languages, i think
06:05:40 <ndm> its all been done in Reduceron though, so you can get all the code from there
06:05:50 * ihope nods
06:06:08 <ndm> it even fronts on to Yhc, so any Yhc code can be easily converted to SKI
06:07:20 <EvilTerran> seems to me that it'd effectively be a compilation from \-calc to SKI rather than a nice direct transformation
06:07:48 <EvilTerran> but i may be missing something. **goes to look at Reduceron**
06:08:19 <ndm> Haskell ~= \calc
06:08:37 <ndm> they aren't really that far off, especially by the time you get to Core
06:08:45 <Ian_P> Hi, does anyone know if the solutions to the exercises from "The craft of functional programming" are available online somewhere ?
06:09:02 <ska-fan> is there a thing in ghc that shows me how a function call is evaluated?
06:09:45 * ndm decides to try and write a Haskell theorem prover in 24 hours...
06:10:00 <ska-fan> blog about it
06:10:00 <ndm> ska-fan, there is a debugger in the HEAD, but not in a released version
06:10:34 <mm_freak> GHCi takes ages to start
06:10:40 <mm_freak> is there any way to speed that up?
06:10:57 <ndm> mm_freak, how slow?
06:11:17 <hpaste>  mboes pasted "subst and freeVars using uniplate" at http://hpaste.org/1836
06:11:22 <mm_freak> real: 0.622
06:11:31 <mm_freak> that is:  ms
06:11:46 <ska-fan> 0.6 ms is pretty fast actually
06:11:55 <ska-fan> I'd not complain
06:12:25 <mm_freak> i do, because i've switched from perl/shell-scripting to haskell for a few things
06:12:40 <ska-fan> perl starts up in under 0.6 ms?
06:12:50 <mm_freak> far under
06:13:25 <ska-fan> you know that there are 1000 ms in a second?
06:14:25 <EvilTerran> you could compile your haskell...
06:14:37 <mm_freak> ska-fan: thanks for that informationâ€¦  you've enlightened me a lot ;)
06:14:39 <ndm> mboes, it may not be possible - the whole point is that freeVars/subst both require knowledge of bindings, so you can't skip to the interesting bits
06:14:53 <mm_freak> evilterran: yes, seems to be the only solution
06:15:05 <mm_freak> or i could switch to hugs for that purpose
06:15:23 <mboes> ndm: yes. But so basically 'descend' can't be done in the presence of multiple datatypes, correct?
06:16:07 <ndm> mboes, you really want to descend exactly one level, so depending on the constructor it won't always have the same return type
06:16:17 <ndm> which you can't express in Uniplate, so i guess not
06:16:18 <EvilTerran> mm_freak, is rughc any faster than ghci for this?
06:16:31 <mm_freak> rughc?
06:16:33 <EvilTerran> *runghc
06:16:36 <mm_freak> ah
06:16:41 <mm_freak> nope, that's what i'm actually using
06:17:01 <EvilTerran> oh, right. compiled or hugs it is, then, i guess.
06:17:06 <fasta> Calling an interpreter is a loop is a bad idea
06:17:11 <fasta> er in
06:17:55 <mm_freak> fasta: in a loop?
06:18:12 <fasta> mm_freak: otherwise there is no problem of ghci being slow
06:18:34 <twb> Is there any point rewriting a form "slow && fast" to "fast && slow", where fast and slow are subforms that can be evaluated quickly and slowly, respectively?
06:18:46 <ndm> twb, yes, a lot
06:19:07 <twb> OK; I thought maybe the laziness magically did that for me.
06:19:18 <fasta> ndm: semantics wise there is no such difference, AFAIK
06:19:26 <mm_freak> fasta: ah, now i get, what you mean
06:19:59 <fasta> It's just that most implementations first evaluate the first and then the second mapped to the hardware
06:20:01 <twb> I guess it wouldn't be able to without a hint from me about how to guess about the slowness of a particular form.
06:20:02 <mboes> ndm: hm, i see. So doing it the way it is right now is the pretty much the best we can hope for? Or could i use some combination of 'children' to reduce the code size?
06:20:07 <mm_freak> fasta: unfortunately it _is_ called in a loop, for a lot of M4 files, which are then passed to M4
06:20:50 <EvilTerran> twb, indeed, the interpreter can't know which one'd take longer until it does them both. you can also tell the order of evaluation by looking at the source:
06:20:53 <EvilTerran> @src (&&)
06:20:53 <lambdabot> True  && x = x
06:20:53 <lambdabot> False && _ = False
06:21:09 <ndm> fasta, no, in Haskell its defined to evaluate the first one first
06:21:21 <ndm> mboes, give me a minute, still trying to understand it...
06:21:30 <fasta> ndm: can you prove that?
06:21:43 <EvilTerran> @where report
06:21:44 <lambdabot> http://www.haskell.org/onlinereport/
06:21:44 <fasta> ndm: Since I would find that very insane semantics.
06:22:24 <twb> EvilTerran: assuming, of course, the source doesn't contain implementation-specificness :-)
06:22:43 <EvilTerran> http://www.haskell.org/onlinereport/standard-prelude.html#$v$A$A ?
06:22:44 <lambdabot> Title: The Haskell 98 Report: Standard Prelude
06:22:46 <fasta> ndm: I see there a definition, I don't see what the semantics are.
06:22:59 <wli> Parallel (||) and (&&) would be nice.
06:23:19 <fasta> ndm: there are multiple implementations possible that are semantically equal to that definition.
06:23:31 <twb> Can I time a form inside ghci, rather than having to define a main procedure?
06:23:34 <mboes> ndm: i guess the only alternative is to rename all variables to be unique. Then we don't need to bother with environments and we can just use transformBi for 'substitute' and universeBi for 'freeVars'.
06:23:35 <EvilTerran> "In this chapter the entire Haskell Prelude is given. It constitutes a specification for the Prelude. Many of the definitions are written with clarity rather than efficiency in mind, and it is not required that the specification be implemented as shown here."
06:23:36 <fasta> ndm: so, I am not convinced.
06:23:42 <xerox> twb: :set+s
06:23:47 <xerox> with a space
06:23:51 <fasta> EvilTerran: thanks for proving my point
06:23:52 <twb> xerox: cool
06:23:54 <wli> Parallel (||) and (&&) are what are needed to give PCF full abstraction.
06:24:04 <xerox> twb: alsolookup "Timing computations" in haskellwiki
06:24:07 <fasta> PCF?
06:24:09 <twb> xerox: that's exactly what I wanted
06:24:13 <fasta> "full abstraction"?
06:24:15 <EvilTerran> however, i think in a lazy language, the evaluation order semantics would have to remain the same as those provided by the canonical Prelude.
06:24:18 <twb> xerox: ah, I looked up "profiling" on the wiki
06:24:31 <xerox> there's a cooked up time :: IO () -> IO ()
06:24:42 <EvilTerran> ...in order to be considered "the same function"
06:25:00 <ndm> fasta, imagine _|_ && False
06:25:05 <ndm> > undefined && False
06:25:08 <lambdabot>  /home/dons/lib/ghc-6.6/ghc-6.6: error while loading shared libraries: librea...
06:25:10 <ndm> > False && undefined
06:25:11 <lambdabot>  /home/dons/lib/ghc-6.6/ghc-6.6: error while loading shared libraries: librea...
06:25:18 <wli> undefined || True also
06:25:22 <ndm> Lambdabot says: undefined, then False
06:25:41 <ndm> mboes, having had experience with Core like languages, unique variables might be easier anyway
06:26:10 <fasta> Ok, then the semantics for && are not sane.
06:26:33 <twb> How can I generate an infinite *descending* sequence?
06:26:34 <mboes> ndm: ok, good to know. Lemme finish off my quickcheck properties and i'll refactor it all to assume unique variables all the way.
06:26:37 <ndm> mboes, can't you write variables as variables x = [y | Var y <- universeBi x]
06:26:41 <mboes> ndm: thanks for your help :)
06:26:53 <EvilTerran> twb, [10,9..1]
06:26:54 <ndm> mboes, that said, Uniplate should support whichever choice you make
06:26:58 <twb> EvilTerran: wacky
06:27:03 <xerox> > foldr True (&&) [True,True,False] ++ repeat False
06:27:04 <mboes> ndm: um, not if i make it part of the Variables class
06:27:04 <lambdabot>  /home/dons/lib/ghc-6.6/ghc-6.6: error while loading shared libraries: librea...
06:27:17 <EvilTerran> also, [10,12..] works. as does [x,y..] or whatever, assuming correct typing
06:27:38 <EvilTerran> fasta, the strictness of a function is a significant part of its definition in a lazy language.
06:27:39 <ndm> mboes, oh, i see, sorry missed that definition already
06:27:47 <xerox> Prelude> foldr (&&) True ([True,True,False] ++ repeat False)
06:27:47 <xerox> False
06:27:53 <fasta> EvilTerran: I know
06:28:02 <mboes> ndm: actually, i do define it that way
06:28:05 <wli> xerox: foldr (&&) True $ [True,True,False] ++ repeat False
06:28:17 <EvilTerran> so why are the semantics insane?
06:28:18 <ndm> mboes, the general way of doing these low-level things is no invariants (as you currently have), unique variables in a monad, or de Brujin indicies
06:28:28 <mboes> ndm: line 136. the default definition
06:28:30 <ndm> i've tried all three, and still haven't decided what the right one is
06:28:34 <fasta> EvilTerran: I think undefined && True should return Trye
06:28:37 <ndm> yeah, i see that now
06:28:37 <fasta> True*
06:28:50 <xerox> wli: yeah, I was showing shortcutting
06:28:51 <ndm> fasta, how would you implement && to ensure that?
06:29:01 <AStorm> Who broke lambdaot?
06:29:07 <AStorm> *lambdabot
06:29:10 <fasta> ndm: I would spawn two threads in the implementation.
06:29:14 <EvilTerran> ndm did it!
06:29:22 <mboes> ndm: what's the downsides of de brujin?
06:29:26 <wli> ndm: Built-in RTS magic to interleave graph reduction of the two branches.
06:29:55 <Philippa> fasta: you can only do that by either a) mirroring the problem instead, b) parallel evaluation or c) solving the halting problem
06:29:55 <EvilTerran> fasta, almost all C-like languages prescribe short-circuiting the RHS of (&&) and (||), too
06:30:21 <mboes> ndm: with unique vars, the only problem is see is that you have to keep around a map to get back the original variable names when you need to.
06:30:37 <Philippa> I assume you're not happy with option a, option c isn't possible, option b isn't appropriate for a single-threaded language
06:30:42 <ndm> mboes, its hard to read the intermediate stuff, the map isn't the hard bit
06:30:48 <wli> Parallel/interleaved evalation is not so difficult.
06:30:56 <fasta> Philippa: Haskell is a single-threaded language?
06:31:05 <Philippa> fasta: it certainly was at inception
06:31:06 <ndm> wli, i love that Haskell has || and && expressed in the language, not as primitives - that was one of the things that drew me to it
06:31:11 <Philippa> and Haskell 98 still is
06:31:15 <wli> Interchange the arguments after reducing one step.
06:31:17 <fasta> Philippa: oh, right.
06:31:30 <ndm> wli, and watch the shootout numbers drop like a stone...
06:31:40 <fasta> Philippa: but C++ is a single-threaded language according to that definition.
06:31:43 <fasta> too
06:31:45 <matthew_-> > 0x1f0
06:31:46 <lambdabot>  /home/dons/lib/ghc-6.6/ghc-6.6: error while loading shared libraries: librea...
06:31:49 <matthew_-> oh, sorry
06:31:58 <Philippa> yes, and it'd be equally inappropriate for a C++ primitive to /mandate/ parallel execution
06:32:10 <ivant> > 2+3
06:32:10 <lambdabot>  /home/dons/lib/ghc-6.6/ghc-6.6: error while loading shared libraries: librea...
06:32:16 <AStorm> fix her!
06:32:24 <chessguy> @seen dons
06:32:25 <lambdabot> dons is in #haskell-icfp07, #xmonad, #haskell-soc and #haskell. I last heard dons speak 26m 42s ago.
06:33:09 <wli> ndm: The shootout is esssentially rigged by perpetual rule-changing, never mind the crappy methods, so I don't put much stock in shootout numbers.
06:33:41 <Philippa> wli: fine, watch your real-world performance suck
06:34:13 <Philippa> amongst other things it'd prevent doing anything useful with strictness analysis
06:34:42 <norpan> isn't there parallel haskell to handle exactly this?
06:34:51 <matthew_-> is there any reason why Data.Binary seems to be outputting everything in reverse?
06:35:04 <wli> I don't believe that's what Parallel Haskell is for.
06:35:29 <matthew_-> I'm defining instances, and the Puts look just like in the examples, but using wireshark to see what goes over the wire, each "unit" is the wrong way round..
06:35:40 <EvilTerran> endianness?
06:35:45 <mboes> ndm: what do mean it's hard to read the intermediate stuff. So long as you keep the map to original names around. Can't you just systematically translate all names to originals everytime you show the AST representation to the user?
06:35:48 <ndm> wli, people keep telling me that, but no one wants to write a blog post saying "these things are why i don't trust the shootout"
06:36:11 <matthew_-> EvilTerran: well, if that was the case, the receiving side shouldn't have any problem
06:36:18 <matthew_-> but the receiving side is having problems
06:36:18 <ndm> mboes, yes, you can, some things get harder, some get easier, some just get more confusing from the original - feel free to try de brujin if it would suit you
06:37:09 <mboes> ndm: ok, will do =)
06:37:10 <wli> ndm: I'd do that if I weren't too stupid to figure out how to set up wordpress without it clobbering 100 indispensible bits of configuration state.
06:37:15 <Philippa> ndm: I don't trust the shootout in micro-detail and I don't trust its results to scale to large programs
06:37:20 <Philippa> hopefully I don't need to explain the latter statement?
06:37:50 <Philippa> wli: get a livejournal and use that?
06:38:05 <fasta> Large programs are written with monads, I don't think the shoot out uses anything but IO.
06:38:08 <ndm> wli, if you want to write it, i'm happy to post it on my blog, or get a google blog - takes about 10 minutes
06:38:27 <wli> I'm sort of dead set on self-hosting.
06:38:48 <Philippa> meh. Back up your content and then get it up however
06:38:54 <ndm> you used to be able to self-host blogger blogs
06:38:57 <Philippa> hell, create a static page
06:39:25 <matthew_-> oh, ignore me. Brain failure.
06:40:50 <wli> My answer for the moment is to do without.
06:43:33 <matthew_-> agh, lazy bytestring - hGet does not seem to actually alter the handle - reading from it again, I get the same data out. Is this just standard laziness issues with IO ?
06:44:27 <AStorm> hGetStr instead
06:44:32 <AStorm> that does move the handle
06:44:33 <ndm> it would be nice to be able to point at a list of reasnos why the shootout is unfair
06:44:46 <ndm> since at the moment there is nothing, apart from folk law
06:45:03 <AStorm> ndm, first of all, many of the languages are compiled to C++ or C :>
06:45:11 <AStorm> or ran by an interpreter written in C
06:45:22 <matthew_-> AStorm: I'm not reading strings
06:45:24 <AStorm> so that one is unbeatable :>
06:45:32 <AStorm> matthew-_, poor you :>
06:45:36 <matthew_-> ta
06:46:01 <ska-fan> (rethoric question) how long does it take to wrap your head around the CPS example in YAHT?
06:46:03 <ndm> AStorm, not necessarily so
06:46:12 <AStorm> ndm, that's why I write "many"
06:46:15 <Philippa> ndm: if you want "misleading" rather than "unfair", there's been some discussion on LtU recently
06:46:25 <twb> Bleh, I shouldn't have to memoize by hand
06:46:27 <matthew_-> wtf would you write hGet which doesn't move the handle? How is this possibly a sensible thing to do? Why is it not documented either?
06:46:34 <ndm> Philippa, i don't want discussion, i want a well written article :)
06:46:34 <twb> This is the 21st century!
06:47:01 <AStorm> twb, and yet C is prevalent :P
06:47:09 <msouth> ska-fan: I just read it (I'm new to haskell), and it's anything but clear
06:48:15 <twb> AStorm: I'm talking about in Haskell
06:48:32 <ska-fan> I wonder if there is a simpler example for CPS but a fold in CPS
06:48:40 <msouth> ska-fan: so what I'm saying is, if it made no sense to you you are not alone
06:48:52 <ska-fan> thanks :)
06:49:05 <msouth> I think the general idea is that you pass a function that says "here's what to do next"
06:49:23 <AStorm> twb, why would it memoize on its own? It might be detrimental to performance (memory use)
06:49:33 <twb> It should be able to work this stuff out
06:49:41 <twb> Magically
06:49:47 <AStorm> twb, yeah right, give it an Oracle, type 2
06:49:59 <twb> A time machine
06:50:04 <ska-fan> msouth: I think I grasped CPS in itself, just not the fold example. I'm so far unable to answer 4.11
06:50:05 <msouth> ska-fan: have you searched the haskell-cafe archives?
06:50:14 <ska-fan> no, I'll do that
06:50:15 <twb> It'll come back and say "don't bother, the armada will be here in six years"
06:51:02 <jethr0> what is the currently active FFI tool?
06:51:20 <msouth> ska-fan: I think someone just added a link to the wiki to the gmane interface to search/browse those archives
06:51:21 <AStorm> twb, write or use a memoization wrapper
06:51:31 <AStorm> should be real easy in Haskell
06:51:38 <twb> Well, actually, I just used a let.
06:51:46 <twb> I dunno if that really counts as memoization
06:52:06 <AStorm> doesn't
06:52:16 <AStorm> it is just a lazy binding
06:52:22 <hpaste>  twb pasted "bleh, I shouldn't have to let by hand." at http://hpaste.org/1837
06:52:30 <msouth> (note that I'm not discouraging you asking here, just providing alternatives).  the ifcp is going on as well, so possible you'll get fewer responses here this weekend.  (although it seems quite busy :)
06:53:47 <twb> AStorm: a5'' is about 25% faster than a5' when applied to values 1 through 15.
06:54:20 <jethr0> ?
06:54:38 <jethr0> hsffi, c2hs, ...?
06:55:11 <AStorm> twb, you could bound it by 20!
06:55:21 <twb> @google "Tackling the Awkward Squad"
06:55:22 <AStorm> instead of using an infinite list
06:55:23 <lambdabot> http://research.microsoft.com/~simonpj/Papers/marktoberdorf/
06:55:23 <lambdabot> Title: Simon Peyton Jones: papers
06:55:30 <twb> AStorm: bound what?
06:55:48 <AStorm> twb, the infinite list of numbers, uhm
06:56:20 <wli> twb: It's just the least common multiple.
06:56:29 * ihope ponders the Reduceron lambda-to-SKIBB*CC'' converter
06:56:42 <twb> wli: ssh, you're not supposed to give me the answers!
06:56:43 <ska-fan> Maybe CPS is just recursion with an added redirection
06:57:14 <ihope> Well, it's really a lambda-to-SKI converter that optimizes. I... am not sure if it does what I'm after.
06:57:29 <ihope> The combinators function here: http://www.cs.york.ac.uk/fp/darcs/tred/source/Frontend.hs
06:58:00 <ndm> ihope, the original one didn't, it was just SKI, the code may be in there somewhere
06:58:29 <ihope> If you replace opt with id, it becomes plain SKI.
06:58:37 <ihope> Not only that, but bad SKI.
06:58:46 <ndm> why bad SKI?
06:59:19 <ndm> anyone got any Gtk2Hs experience?
06:59:29 <ndm> specifically, how do you set the color of something
06:59:57 <ihope> ndm: it's unoptimized SKI. Better to just remove the opt declarations that mention combinators other than SKI.
07:00:11 <ndm> probably :)
07:01:34 * wli refrains from chiming in for twb.
07:01:57 <ska-fan> ndm: #gtk on irc.gnome.org
07:04:34 <ihope> Well, it certainly converts application into application, empty lambda into its inside, and non-lambda non-application into itself.
07:05:16 <ihope> It's not a direct conversion, really: it converts into SKI-with-variables which is immediately translated into SKI-without-variables.
07:06:37 <ihope> It'd be nice to do that without any in-between.
07:17:05 <dons> > 1+2
07:17:05 <lambdabot>  /home/dons/lib/ghc-6.6/ghc-6.6: error while loading shared libraries: librea...
07:17:14 <dons> huh, did they update the system behind my back...
07:18:37 <dons> > 1+2
07:18:39 <lambdabot>  3
07:26:48 <eivuokko> Does Data.Bits.Bits really require superclass Num?
07:30:00 <Igloo> eivuokko: Presumably because of things like x `shift`   i | i<0  = x `shiftR` (-i) in the default instance
07:30:20 <Igloo> And bit i               = 1 `shiftL` i
07:31:40 <dolio> Only the latter would matter, right? Since 'i' has to be Int?
07:31:52 * wli goes in for Project Euler.
07:33:12 <eivuokko> Well, I have newtype over Word32, and forcing me to have Num instance (if I want Bits instance) allows user to construct values of my type from literals...kinda annoying.
07:33:49 <eivuokko> Well, maybe it's not that bad.  Seems kinda silly, anyway.
07:34:14 <dolio> You could always define fromInteger to throw an exception, and issue a stern warning not to use it. :)
07:34:42 <eivuokko> I am using newtype to lessen runtime errors and move them to compiletime...
07:34:54 <dolio> Ah, well then. :)
07:37:44 <eivuokko> I thought it would be fun to make Win32-package have some phantom typed wrappers...but there's a lot of masks, and I don't want to invent new operator for Data.Bits.(.|.)
07:38:17 <EvilTerran> eivuokko, is GHC's newtype deriving not suitable?
07:38:40 <|Steve|> What the hell is (.|.)? Is someone just trying to make obscene operators in haskell?
07:38:45 <eivuokko> What does it matter?  You can still construct values by accident from numeric literals?
07:38:52 <dolio> > 1 .|. 2
07:38:53 <lambdabot>  Add a type signature
07:38:55 <eivuokko> Steve, it's bitwise or
07:38:58 <dolio> > 1 .|. 2 :: Int
07:39:00 <lambdabot>  3
07:39:05 <|Steve|> I see.
07:39:21 <|Steve|> I suppose | was taken already.
07:39:35 <eivuokko> Yes, data Maybe a = Nothing | Just a
07:39:56 <dolio> Also: f x | x < 0 = ... | x > 0 = ...
07:40:10 <|Steve|> I wasn't asking a question. I was stating a fact. =)
07:40:22 <twb> |Steve|: and bitwise-ior is too long for Haskellers :-)
07:40:33 <|Steve|> That is a tad long.
07:40:37 <|Steve|> What about `or` though?
07:40:49 <|Steve|> Or is or already defined?
07:40:50 <eivuokko> :t or
07:40:50 <dolio> > or [True, False, False]
07:40:53 <lambdabot>  True
07:40:53 <lambdabot> [Bool] -> Bool
07:40:57 <|Steve|> Yeah, I suspected as much.
07:41:04 <|Steve|> :t xor
07:41:06 <lambdabot> forall a. (Bits a) => a -> a -> a
07:41:42 <mauke> > 3 `xor` 4
07:41:43 <lambdabot>  Add a type signature
07:41:46 <mauke> > 3 `xor` 4 ::Int
07:41:47 <lambdabot>  7
07:41:50 <|Steve|> How about \/?
07:41:56 <mauke> > (\/)
07:41:57 <lambdabot>   Not in scope: `\/'
07:42:06 <EvilTerran> > let (\/) = (.|.) in 3 \/ 15 :: Int
07:42:08 <lambdabot>  15
07:42:15 <|Steve|> Seems like that'd be a reasonable one, but I suppose that's more like logical or.
07:42:40 <EvilTerran> quite. && should be /\ and || should be \/ ;]
07:42:59 <eivuokko> Is there set class and operator for union or something?
07:43:04 <eivuokko> (in base)
07:43:10 <Botje> there's \\
07:43:23 <EvilTerran> what about (âˆ¨)?
07:43:49 <|Steve|> v wouldn't work since it's a letter, right? You'd need `v`.
07:43:58 <twb> |Steve|: he didn't say v.
07:44:02 <|Steve|> No?
07:44:08 <|Steve|> I guess not.
07:44:15 <|Steve|> What character is that?
07:44:20 <twb>            Name: LOGICAL OR
07:44:25 <EvilTerran> vâˆ¨ - different. mine's logical OR
07:44:36 <|Steve|> Ah, got it, unicode.
07:44:46 <|Steve|> My eyes are a little blurry at 7:43 am.
07:44:54 <twb> The morpheme predates Unicode
07:45:02 <Botje> how dare you not notice the 6-pixel difference.
07:45:29 <twb> I can tell because the hinting is shitty for FreeMono
07:45:29 <EvilTerran> could use âˆ§âˆ¨ for logical and â‹â‹Ž for bitwise...
07:45:34 <|Steve|> twb: I didn't mean the morpheme. I meant the particular glyph.
07:45:53 <|Steve|> I like being able to write my code in ascii.
07:46:24 * EvilTerran notes that the "curly" ones are the other way around from the normal ones when sorting by codepoint.
07:46:25 <twb> In theory I do, too, but it's hard to think of a system I use that isn't unicode-capable
07:46:56 <|Steve|> All that I use are, but some are easier to write particular characters than others.
07:47:17 <twb> All my input devices run Emacs, which has consistent IM
07:47:50 <twb> So either I can type it or I can't.
07:48:00 <|Steve|> (My input device is a keyboard, it doesn't run emacs.)
07:48:31 <twb> I should have said "devices that accept input"
07:48:38 <EvilTerran> is there a emacs-like system built with Haskell in place of elisp?
07:48:52 <twb> yi.
07:48:59 <|Steve|> <insert joke about emacs being a great OS... />
07:49:37 <twb> Emacs isn't an OS, it's a desktop environment.  And it's a steaming pile of shit, but like TeX I don't have a superior replacement.
07:49:38 <wli> Some guy Zhivago I think got sbcl and hence Hemlock booting on the bare metal. I think he called it Vapour.
07:49:55 <twb> LiCE runs on the metal
07:50:03 <EvilTerran> i prefer to think of emacs as an elisp interpreter that comes bundled with a text editor script
07:50:17 <twb> EvilTerran: text editor?
07:50:21 <twb> EvilTerran: it edits FAR MORE than text.
07:50:38 <EvilTerran> much like Firefox (really gecko) is an XPI interpreter that comes bundled with a web browser
07:51:13 <|Steve|> wli: Zhivago, the jack ass from ##c?
07:51:17 <EvilTerran> twb, pedant. it's more of a text editor than it is, say, a poodle, and that's good enough for me.
07:51:31 <wli> |Steve|: Possibly. Could be a different one.
07:51:36 <twb> vi is a text editor.  Emacs is an editor.
07:51:40 <|Steve|> I see.
07:51:43 <wli> |Steve|: I never saw the thing in action, so who knows if it's BS or what.
07:52:04 <twb> wli: I've booted movitz+lice from BIOS on a CD.
07:52:10 <mm_freak> twb: but you're clearly an emacs guyâ€¦  you even type two spaces after the period =)
07:52:11 <|Steve|> Ugh, editor wars are even worse than language wars.
07:52:30 <twb> wli: I would've used a floppy, but for the want of a drive ;-)
07:52:34 <mm_freak> yeah, i love emacsâ€¦  and i don't care about others' preferences =)
07:52:37 <EvilTerran> twb, i'm pretty sure vi can do most things emacs can do, albeit in vimex rather than elisp
07:52:37 <|Steve|> Why would anyone type two spaces after a period? LaTeX should handle all spacing for you. =)
07:53:16 <EvilTerran> i'm happy with SciTE, anyway. but i might build an editor in haskell for the programming experience at some point.
07:53:29 <mm_freak> |steve|: it's not because of LaTeX, it's because of emacsâ€¦  if you type two spaces after a sentence, then emacs can detect sentence boundaries
07:53:43 <|Steve|> Interesting. Too bad it makes the text look silly.
07:53:45 <twb> mm_freak: you mean that by default Emacs expects double spacing after sentences.
07:54:30 <mm_freak> twb: it doesn'tâ€¦  you only need to do that, so you can additionally move the point by sentence
07:54:34 <twb> I believe the practice originated with pre-computing DP pools.
07:54:49 <mm_freak> but personally i like more space after a sentence, so that's ok
07:54:49 <EvilTerran> lisp is an AI language, you should write a learning machine to work out where the sentences finish
07:54:50 <EvilTerran> ;]
07:55:08 <twb> I certainly don't do it to appease Emacs; I do it because it is the way I have always written text on a monospaced terminal.
07:55:20 <twb> elisp is not Lisp, it's LISP.
07:55:59 <EvilTerran> i don't generally capitalise anything beyond abbreviations on IRC, i'm afraid.
07:56:03 <|Steve|> The distinction is lost on me because the only lisp I use is scheme and it's case insensitive.
07:56:26 <twb> LISP is procedural.
07:56:37 <mm_freak> for some strange reason i don't like case-insensitive languages
07:56:40 * EvilTerran wonders if mm_freak was showing off when he typed "doesn'tâ€¦  you"
07:57:25 <twb> mm_freak: r6rs requires case sensitivity, and several r5rs-ish schemes are case insensitive by default, e.g. Chicken.  CL is case folding by default, but this can be disabled.
07:57:36 <mm_freak> evilterran: because of the spaces?
07:57:53 <|Steve|> I think because of the ellipsis.
07:57:54 <EvilTerran> "â€¦" rather than "..."
07:58:20 <twb> EvilTerran: his client might do that without asking.
07:58:24 <EvilTerran> "â€¦  " looks really weird in a monospaced font, i find, given that the ellipsis is half as wide as the gap following it
07:58:33 <twb> One of the KDE clients turns *fnord* into fnord without asking.
07:58:41 <mm_freak> evilterran: why should i be showing off?  since there is a special character for ellipsis, why shouldn't i use it?
07:58:44 <EvilTerran> what, emboldens it, twb?
07:58:57 <twb> EvilTerran: no, inserts literal B control characters around it.
07:59:10 <EvilTerran> mm_freak, because, under most input system, it's a pain to input
07:59:15 <EvilTerran> *systems
07:59:29 <EvilTerran> but if it's handy for you, you're welcome to it. it just struck me as unusual.
07:59:30 <mm_freak> evilterran: not hereâ€¦  i've bound it to AltGr + .
07:59:38 <msouth> shows up as spaces in my client
07:59:42 <mm_freak> wellâ€¦
07:59:49 <msouth> that worked
07:59:51 <twb> 00:58 <fsbot> sgml: &mldr;
07:59:51 <twb> 00:58 <fsbot> rfc1345: &.3
08:00:11 <|Steve|> Hmm, control-alt-. did it for meâ€¦
08:00:18 <mm_freak> Ï€/2 = âˆ«_(-1)^1 (x â†’ âˆš(1 - xÂ²)) dx
08:00:19 <mm_freak> =)
08:00:20 <mauke> CL's case folding can be disabled, but the whole language/standard library is IN ALL UPPERCASE
08:00:37 <twb> You mean â‚‹â‚?
08:00:52 <EvilTerran> twb, B control characters? is that the bold format code that everyone's favourite Mirek invented?
08:01:17 <twb> EvilTerran: I don't know what you're talking about.
08:01:23 <EvilTerran> mirek? what am i talking about... Khaled.
08:01:29 <|Steve|> Um, I'm not sure what happened, but my window is now cleared. I guess I shouldn't have pushed those characters.
08:01:46 <EvilTerran> brainfart, sorry. i'm being unnecessarily obscure.
08:01:48 <mm_freak> twb: yeahâ€¦  but probably you can't but the '1' above it
08:01:58 <twb> Correct.
08:02:22 <mm_freak> and actually the arrow was the wrong one, too
08:02:32 <EvilTerran> too much tea, i'm afraid, twb. it makes me forget that not everyone is psychic ;]
08:02:33 <mm_freak> it should be \mapsto, which is slightly different
08:02:37 <|Steve|> You probably meant \mapsto.
08:02:40 <|Steve|> er, yeah. =\
08:03:07 <twb> I just type â†¦ to get \mapsto
08:03:16 <twb> Yay for TeX input methods
08:03:41 <mm_freak> perhabs you mean it the other way round
08:03:43 <|Steve|> How do you type â†¦ anyway?
08:03:50 <twb> I just told you
08:03:52 <EvilTerran> twb, i was asking if "B control characters" are supposed to make text bold, if your IRC client bows to the will of the guy who wrote mIRC
08:04:03 <|Steve|> twb: No, you said <twb> I just type â†¦ to get \mapsto
08:04:17 <twb> EvilTerran: I don't know what they are supposed to do in standards-compliant clients.
08:04:42 <EvilTerran> AFAIK, nothing. mIRC invented the formatting codes, IIRC.
08:04:55 <twb> I imagine it is undefined.
08:05:22 <|Steve|> It'd be nice if it just used the standard ansi control sequences. \033[31mThis would be red.\033[m
08:06:44 <twb> No, it would be nice if people would not try to force formatting upon me.
08:06:53 * EvilTerran agrees with twb.
08:06:54 <|Steve|> That too.
08:07:03 * twb waves a fist at various "web designer" cretins
08:07:08 <mm_freak> evilterran: mIRC invented the color codes
08:07:28 <mm_freak> the other codes were introduced by other clients, though i don't know which
08:07:57 <EvilTerran> it'd also be nice if people who wanted to extend the IRC standard went thru the right channels to do so, instead of taking advantage of their position of market leader to get their own way.
08:08:20 <twb> Incidentally, fuck CIA and it's use of aforesaid nonstandard codes.
08:08:30 <|Steve|> ?
08:08:38 <twb> CIA is a bot that announced svn commits
08:08:42 <twb> *announces
08:08:44 <|Steve|> No, I know what it is.
08:08:50 <|Steve|> But I'm just curious what codes it uses.
08:08:56 <twb> Colour codes
08:09:07 <|Steve|> <CIA-9> Steve Checkoway * stepmania/src/ScreenOptionsMasterPrefs.cpp: Style.
08:09:15 <|Steve|> It didn't use any color codes in that commit of mine.
08:09:25 <mm_freak> evilterran: well, the standard doesn't define how to actually _interpret_ IRC text messages
08:09:41 <mm_freak> clients are free to interpret them as they like
08:09:42 <|Steve|> None of my commits ever produce any color.
08:09:43 <EvilTerran> although i'd speculate that the only reason mIRC does better than any other windows IRC client in terms of market share is that none of the others have "IRC" in their name...
08:10:09 <twb> Maybe whichever obnoxious louts I was haranguing had modified their copy
08:10:19 <|Steve|> Could be.
08:10:23 <EvilTerran> (x-chat, gaim/pidgin, etc)
08:10:28 <mm_freak> evilterran: i'd say it's because of the builtin script editor (which sucks btw)
08:10:39 <EvilTerran> x-chat has perl extensions...
08:10:44 <twb> I'd say it's pretty unimportant what Windows users do
08:10:53 <|Steve|> XChat has all sort of extensions.
08:10:58 <EvilTerran> (or tcl, or python, ...)
08:11:14 <twb> Does windows even ship with Perl?
08:11:16 <|Steve|> And XChat is how it renders its name for me.
08:11:23 <twb> Stupid backwards junk
08:11:24 <EvilTerran> twb, given that they're in the majority, i'd call it pretty significant.
08:11:27 <fasta> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, <- does that mean I broke lambdabot?
08:11:41 <Philippa> XChat wasn't available on windows for a long time, pidgin's a newcomer
08:11:41 <EvilTerran> no, it doesn't come with perl, but it takes all of 10min to install activeperl
08:11:42 <twb> EvilTerran: so are the Chinese
08:12:03 <EvilTerran> twb, are you calling the chinese unimportant?
08:12:11 <mm_freak> twb: it doesn't, and the only useful perl package for windows (from activestate) is commercial
08:12:11 <twb> Why not?
08:12:20 <Philippa> I don't know quite how old the first version of mIRC was, but it was a 16bit app for a long time
08:12:22 <EvilTerran> |Steve|, yes, you're right, xchat, not x-chat. my bad.
08:12:41 * twb hates "my bad".
08:12:43 <|Steve|> But I've seen x-chat before so I wonder if there are multiple versions.
08:13:04 <mnislaih> dcoutts: there ?
08:13:29 <mm_freak> evilterran: it used to be "x-chat", but not anymore
08:13:31 <mnislaih> dcoutts:  I'm trying to compile the c2hs in gtk2hs for GHC head. Do you know how can I easily add package pretty to the dependencies ?
08:13:31 <Philippa> twb: it's pretty important what windows users do when most DDoS attacks're carried out by a horde of windows-running zombies...
08:13:58 <twb> Bah.
08:14:06 <EvilTerran> twb, er... I have no answer for "why aren't the chinese unimportant?". i guess our mindsets are so different in that regard, seeing as it strikes me as bleeding obvious.
08:14:10 <mnislaih> dcoutts I can't understand the makefile system
08:14:14 <twb> My systems survive DOS by crashing
08:14:33 <mm_freak> unfortunately it's not mIRC, which makes them to zombies, it's windows itself, because it doesn't enforce any security upon the user
08:14:36 <EvilTerran> they're a major economic power, they've got nuclear weapons...
08:14:37 * twb pats empty limits.conf
08:14:54 <EvilTerran> ...every goddamn thing is Made In China...
08:14:58 <twb> EvilTerran: what I think isn't important either
08:15:07 <twb> EvilTerran: so I can think they're unimportant with alacrity
08:15:18 <Philippa> twb: sorry, what did you say?
08:15:22 <Philippa> I didn't read it, it wasn't important
08:15:23 <EvilTerran> mm_freak, ah, thanks. nice to know i'm not going mad wrt "xchat" vs "x-chat"...
08:15:28 <twb> Philippa: I say many things
08:16:22 <mm_freak> btw, what does `wrt' mean?
08:16:31 <twb> With Respect To
08:16:31 <jfredet1> with respect to
08:16:38 <mm_freak> ah k
08:16:41 <EvilTerran> anyway. we all deserve to be banished to #haskell-blah.
08:16:56 <mm_freak> yeah, quite off-topic
08:17:14 <twb> It's a corrolary of my short attention span
08:27:52 <EvilTerran> is wxHaskell still being updated?
08:28:48 <fasta> EvilTerran: the darcs version is, I think
08:28:57 <fasta> EvilTerran: you can check the dates for patches
08:29:00 <EvilTerran> the last update's Jan 20th, and there doesn't seem to be binaries for ghc6.6
08:29:24 <fasta> EvilTerran: define "the last update"
08:30:05 <EvilTerran> last update listed on the front page of their site
08:30:18 <fasta> EvilTerran: right, so, look at the darcs version
08:30:21 <EvilTerran> and that's just to say it's under new management
08:30:31 <EvilTerran> i'm looking
08:30:38 <fasta> EvilTerran: I think the new maintainers don't control the webpage
08:31:01 <fasta> Have you ever user mapStateT?
08:31:06 <fasta> used*
08:31:52 <fasta> I think it had a theoretical use in once paper once and therefor is included
08:32:00 <fasta> one*
08:33:10 <EvilTerran> http://darcs.haskell.org/wxhaskell/_darcs/patches/ says... "23-Mar-2007 14:22"
08:33:12 <lambdabot> Title: Index of /wxhaskell/_darcs/patches
08:33:47 <fasta> EvilTerran: ok, so nobody cares about it enough.
08:34:07 <EvilTerran> oh well. i'll have a look at some other GUI system, then. =/
08:35:50 * EvilTerran might look into putting together a haskell-idiomatic Tk linkage, if it hasn't been done already...
08:35:57 * EvilTerran wanders off
08:37:18 <paolino> hi lambda throwers
08:37:26 <xerox> hiya paolino
08:37:56 <paolino> how are implemented guards in list comprehension ?
08:38:49 <xerox> ?src guard
08:38:50 <lambdabot> guard True  =  return ()
08:38:50 <lambdabot> guard False =  mzero
08:39:33 <paolino> ciao xerox, have you saved the thing ?
08:40:39 <paolino> ah, the list monad ! (Yes the Endo thing)
08:40:58 <EvilTerran> > zip (do x <- [1..]; guard $ odd x; return x) [x | x <- [1..], odd x]
08:41:00 <lambdabot>  [(1,1),(3,3),(5,5),(7,7),(9,9),(11,11),(13,13),(15,15),(17,17),(19,19),(21,2...
08:42:20 <xerox> paolino: not yet
08:42:22 <xerox> :(
08:44:39 <fax> hey
08:44:50 <paolino> EvilTerran: what do return () and mzero in that do block ?
08:48:32 <paolino> sorry
08:49:09 <paolino> gaim and ksirc have different pings
08:50:20 <twb> ]
08:50:26 <twb> wrong buffer
08:51:26 <paolino> usually I ping the channel with gaim to see if my gprs connection is gone
08:51:33 <hpaste>  fax pasted "Quadruple, lastTwo type" at http://hpaste.org/1838
08:51:58 <fax> mmm ignore ' bbnn' a cat typed that
08:51:59 <twb> paolino: you did /ctcp #haskell ping
08:52:01 <fax> didn't notice..
08:52:04 <twb> Which is bad.
08:52:14 <paolino> I see
08:52:22 <fax> I was wondering why the type for lastTwo is so confusing...
08:52:47 <mauke> fax: because Quadruple is confusing
08:52:58 <mauke> what are z and w for?
08:52:58 <paolino> twb I typed "/ping #haskell" really
08:53:27 <fax> Quadruple stores 4 things, the first two and the last two are of the same type
08:54:00 <mauke> fax: what are z and w for?
08:54:17 <twb> paolino: better to ping chanserv or nickserv.
08:55:08 <fax> mauke: I don't how to answer that better than I just did
08:55:16 <mauke> you didn't answer it
08:55:39 <mauke> you have Quadruple, which takes four type arguments
08:55:44 <mauke> but it uses only two of them
08:55:55 <mauke> so why are there four parameters if you don't need them?
08:56:04 <mm_freak> paolino: just do a /whois on yourself
08:56:07 <mm_freak> or an /ison#
08:56:09 <mm_freak> or an /ison
08:56:16 <hpaste>  fax annotated "Quadruple, lastTwo type" with "I didn't post this" at http://hpaste.org/1838#a1
08:56:26 <fax> mauke I had this function which does use them
08:56:33 <mauke> no, it doesn't
08:56:39 <paolino> > do x <- [1,2];return mzero;return x
08:56:40 <lambdabot>  Add a type signature
08:56:45 <mauke> fax: c and d are still unused
08:56:57 <br1> I'm readong http://notvincenz.blogspot.com/2007/07/higher-order-zippers.html and have trouble to parse the expresion for te lfp.  I know what it is, but can't understand what he's saying.  Any help?
08:56:59 <lambdabot> Title: lambda.oasis: Higher Order Zippers
08:57:04 <mauke> in fact, they must be unused because they don't appear anywhere in Quadruple's body
08:57:28 * wli tries to get more stack.
08:57:35 <fax> so is there some kind of identifier for an ignored type?
08:57:43 <mauke> huh?
08:57:52 <twb> It sounds like a trendy fashion line "Higher Order Zippers"
08:59:08 <wli> mauke: I'm getting a stack overflow exception in ghci and am thinking I just need a little more stackspace.
08:59:46 <fax> mauke: I don't get why you are saying my types are unused
08:59:54 <fax> I know no way of not declaring them
09:00:00 <mauke> I don't know about ghci but compiled programs accept +RTS -K50M -RTS to use 50M of stack
09:00:18 <mauke> fax: uh, not declaring them is easy. just don't type them in your text editor
09:00:26 <wli> mauke: I'm using -k256m; I think -K is for upper limits.
09:01:01 <fax> yeah but if I do that my code doesn't typecheck
09:01:03 <mauke> K is maximum stack, k is initial thread stack
09:01:13 <mauke> fax: hmm, then you're doing it wrong
09:01:21 <mauke> it works for me :-)
09:01:35 <fax> can you show me please?
09:02:37 <hpaste>  mauke annotated "Quadruple, lastTwo type" with "elide unused variables" at http://hpaste.org/1838#a2
09:03:41 <fax> ah I understand now
09:03:46 <fax> thanks very much
09:06:06 <paolino> EvilTerran: what really means do x <- [1,2] ? Loop on x from 1 to 2 ?
09:06:20 <mauke> yes
09:06:42 <xerox> do { x <- amb; ... } ==> amb >>= \x -> do { ... }
09:06:50 <mauke> > do { x <- "ab"; y <- "cde"; return (x,y) }
09:06:58 <lambdabot>  [('a','c'),('a','d'),('a','e'),('b','c'),('b','d'),('b','e')]
09:07:00 <xerox> do { amb; ... } ==> amb >> do { ... }
09:07:08 <br1> @seen vincenz
09:07:08 <lambdabot> vincenz is in #haskell-icfp07, #oasis and #haskell. I last heard vincenz speak 1d 2h 31m 21s ago.
09:07:15 <vincenz> ?
09:07:17 <xerox> do { let { bindings }; ... } ==> let { bindings} in do { ... }
09:07:27 <xerox> do amb = amb
09:10:52 <paolino> mauke: and every time I use bind I start a new loop ?
09:12:08 <mauke> yes, basically
09:12:15 <mauke> bind is concatMap
09:18:13 <paolino> is it possible to stop list creation like do x <- [1..];stop (x == 45);return x ?
09:18:56 <mauke> no
09:19:15 <xerox> you need prolog Cut :)
09:19:25 <mauke> unless you do something with continuations
09:19:28 <chrismbrown> paolino: [x | x <- [1..45]] ?
09:20:37 <paolino> mauke , I need a transformer for that ?
09:22:30 <paolino> ContT ?
09:23:33 <xerox> yeah
09:26:09 <paolino> xerox , can you derust me and show me how to implement the stop ?
09:26:44 <fourbissime> hi there.
09:27:22 <xerox> paolino: roll up your own monad stacking cont and list, and provide a stop action
09:27:55 <fourbissime> I'm trying to use Alex to do some lexical analysis. Let's say I have regexp to detect several things. But those things do not cover everything - the rest is some kind of "plain text", and I would like to get this text into something like Text String
09:28:16 <fourbissime> Anyone has an idea how to do that ?
09:35:09 <fax> where do you find specifications for the core language?
09:35:17 <fax> like, if, in, data etc?
09:35:33 <bos> @where report
09:35:33 <lambdabot> http://www.haskell.org/onlinereport/
09:35:36 <bos> there.
09:35:44 <fax> thanks a lot :D
09:40:33 <fax> so it looks like,
09:40:48 <fax> most of haskells primitive operators can be defined in terms of case
09:41:52 <bos> primitive operators?
09:42:08 <fax> well if and let
09:42:12 <fax> im not sure of other
09:42:54 <ddarius> let can't
09:43:00 <ddarius> Well, I guess.
09:43:10 <fax> let p = e1  in  e0 â‰¡ case e1 of ~p -> e0
09:43:19 <bos> you can do some of what let does using case, but it's awfully clunky.
09:43:29 <fax> I don't know what ~p is though, what is it?
09:43:34 <chessguy> fax, how about map :)
09:43:36 <bos> an irrefutable pattern.
09:43:45 <fax> aha
09:43:46 <bos> one that always matches.
09:43:59 <fax> i think we need lambda as well chessguy
09:44:21 <bos> in other words, ~ forces the match to succeed. it can still explode in your face later if it turns out that it's actually not a match.
09:44:23 <fax> I dont think its possible without
09:44:39 <ddarius> I believe there may be typing issues with that definition of let in terms of case.
09:45:17 <fax> oh there is this constraint, where no variable in p appears free in e1
09:45:33 <ddarius> fax: Also, mutually recursive bindings don't translate.
09:45:55 <fax> can you show me an example please?
09:45:58 <Philippa> ddarius: issues within Haskell 98, or only with extensions?
09:46:16 <ddarius> It's fairly typical for functional languages to reduce to a core language containing let (and for lazy languages, case), plus lambdas.
09:46:17 <Philippa> I suspect mutually recursive bindings do translate if you use a tuple
09:46:39 <ddarius> Philippa: For Hindley-Milner style type systems.
09:46:45 <fax> you can write let with lambda pretty easy though
09:46:47 <fax> cant you?
09:47:00 <fax> let {p1=e1;  ... ; pn=en} in e0  	=	 let (~p1, ... ,~pn) = (e1, ... ,en) in e0
09:47:00 <Philippa> ah. You're thinking "no let = screws up type inference"?
09:47:14 <ddarius> fax: Yes and no.  It's possible, but for recursive and mutually recursive bindings it gets ugly.
09:47:32 <ddarius> Philippa: Something along those lines, yes.
09:47:53 <Philippa> you can let case play exactly the same role. Modulo monomorphism restriction, anyway
09:47:58 <fax> > let {x=y+1 ; y = 1/x} in show x
09:47:59 <lambdabot>  Exception: <<loop>>
09:49:09 <fax> What are mutually recursive let bindings?
09:49:42 <ddarius> fax: You just wrote an example.
09:49:50 <fax> but these are useless?
09:49:51 <mauke> > let {x = 'x' : y; y = 'y' : x} in x
09:49:53 <lambdabot>  "xyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyx...
09:50:01 <fax> wtf
09:50:06 <ddarius> fax: Also, you can bind functions.
09:50:31 <mauke> > let {e x = x == 0 || o (x - 1); o x = e (x - 1)} in e 10
09:50:32 <lambdabot>  True
09:50:39 <mauke> mutually recursive functions
09:51:10 <pejo> ddarius, does your comment ".. containing let (and for lazy languages, case)" imply that the core of strict languages don't have case?
09:51:32 <mauke> > let {e x = x == 0 || o (x - 1); o x = e (x - 1)} in e 9
09:51:36 <lambdabot> Terminated
09:51:41 <ddarius> pejo: It depends, but they have less need for it.
09:51:47 <fax> > case (x == 0 || o (x - 1), e (x - 1)) of ~(e, o) -> e 10
09:51:47 <mauke> > let {e x = x == 0 || o (x - 1); o x = x == 1 || e (x - 1)} in e 9
09:51:48 <lambdabot>   Not in scope: `x'
09:51:51 <lambdabot> Terminated
09:52:37 <pejo> ddarius, why?
09:52:38 <mauke> > let {e x = x == 0 || o (x - 1); o x = not (e x)} in e 9
09:52:39 <lambdabot>  False
09:53:01 <fax> hmmm
09:53:21 <fax> yeah, it seems difficult to make a single translation from let to case
09:53:22 <ddarius> pejo: Because let in Haskell is lazy and case is strict, while in a strict language let is strict.
09:53:52 <mauke> > let {e = liftM2 (||0 (0 ==) (o . pred); o = not . e . abs} in e 10
09:53:52 <lambdabot>  Parse error
09:54:01 <mauke> > let {e = liftM2 (||) (0 ==) (o . pred); o = not . e . abs} in e 10
09:54:02 <lambdabot>  True
09:55:25 <fax> (\e o -> (\x -> x == 0 || o (x - 1), \x -> not (e x)))
09:55:42 <fax> you could do somthing like that?
09:56:00 <fax> and fix it but I don't know how
09:56:18 <ddarius> > fix (\~(e,o) -> (\x -> x == 0 || o (x-1),\x -> not (e x))) 10
09:56:19 <lambdabot>  Parse error
09:56:29 <ddarius> > fix (\(~(e,o)) -> (\x -> x == 0 || o (x-1),\x -> not (e x))) 10
09:56:30 <lambdabot>  Couldn't match expected type `t1 -> t'
09:56:39 <mauke> > (\(e,_) -> e 10) (fix $ \ ~(e, o) -> (liftM2 (||) (0 ==) (o . pred), not . e . abs))
09:56:40 <lambdabot>  True
09:57:25 <fax> whats ~(e,o) ?
09:57:31 <mauke> lazy binding
09:57:44 <ddarius> > fst (fix (\(~(e,o)) -> (\x -> x == 0 || o (x-1),\x -> not (e x)))) 10
09:57:45 <fax> I thought everything was lazy
09:57:46 <lambdabot>  True
09:57:56 <mauke> > (\(e,_) -> e 10) (fix $ \f -> (liftM2 (||) (0 ==) (snd f . pred), not . fst f . abs))
09:57:57 <lambdabot>  True
09:58:04 <ddarius> fax: Not pattern-matching (which is to say case) normally.
09:58:18 <ddarius> case is one of the main drivers of evaluation (the other being application)
09:58:23 <Botje> mauke: whatever that is, it's horrible.
09:59:03 <mauke> > case undefined of x : xs -> length [x, x, x]
09:59:04 <lambdabot>  Undefined
09:59:06 <pejo> ddarius, does the semantics say case e of alts -> .. -> case v_j of alts, or is it case e of alts -> .. -> case c_j e1..en of alts and then selection of which branch to take?
09:59:09 <mauke> > case undefined of ~(x : xs) -> length [x, x, x]
09:59:10 <lambdabot>  3
09:59:16 <pejo> I need to learn how to navigate the report, bleh.
09:59:30 <Botje> *sigh*
09:59:36 <Botje> why must docbook-xml suck so badly :(
09:59:37 <fax> ohh
09:59:40 <fax> ok cool
10:01:08 <paolino> mmh thish is what I came to   flip runContT id (callCC $ \exit -> do x <- [1..]; if x == max then exit x else return x)
10:01:18 <paolino> which is not typechecking
10:01:44 <ddarius> x <- [1..] is wrong
10:02:10 <paolino> lift ?
10:02:15 <ddarius> pejo: I'm not clear what you're asking.
10:02:38 <ddarius> paolino: That's one possibility.
10:04:01 <pejo> ddarius, whether it will evaluate the head completely, or just enough to select branch.
10:04:26 <fax> You know, data List a = Nil | | Cons a (List a)
10:04:36 <fax> ack with one less |
10:04:41 <ddarius> I'm not sure if it's specified, but in practice, it will evaluate to weak head normal form, which is just enough to select a branch.
10:04:53 <fax> but can you make it so that every item in the list may have a different type?
10:05:21 <paolino> ddarius , which other possibility ?
10:05:26 <ddarius> fax: You can make it so that every item has a different type, but not a user selectable type.
10:05:53 <fax> what types would it have then??
10:06:17 <ddarius> fax: Lookup nested data types.
10:06:23 <fax> ok
10:07:11 <ddarius> paolino: Probably not any that do what you want.
10:08:59 <ddarius> fax: An example, data List a = Nil | Cons a (List (a,a))
10:09:25 <fax> oh yeah
10:09:50 <ddarius> That said, nested data types are massively underappreciated.
10:10:18 <ddarius> (Except that the Haskell committee had the good sense to require polymorphic recursion.)
10:10:53 <paolino> ddarius : flip runContT id (callCC $ \exit -> do x <- lift [1..]; if x == max then exit (lift x) else return (lift x))      -- is wrong in "id"
10:11:08 <mauke> also in "max"
10:11:26 <paolino> ops
10:11:36 <ddarius> flip runContT id (callCC $ \exit -> do x <- lift [1..]; if x == max then exit x else return x) ?
10:13:13 * ddarius will be back in a bit.
10:14:57 <paolino> mmhh
10:15:15 <paolino> :t flip runContT id (callCC $ \exit -> do x <- lift [1..]; if x == 45 then exit x else return x)
10:15:17 <lambdabot> forall r. (Enum [r], Num [r], MonadCont (ContT r [])) => [r]
10:16:03 <paolino> Enum  [r],Num [r] ?
10:17:41 <xerox> :t flip runContT id (callCC $ \k -> do { x <- lift [1..]; when (x == ?y) exit; return x })
10:17:43 <lambdabot> Not in scope: `exit'
10:17:52 <xerox> :t flip runContT id (callCC $ \k -> do { x <- lift [1..]; when (x == ?y) k; return x })
10:17:54 <lambdabot>     Couldn't match kind `?? -> ? -> *' against `(* -> *) -> * -> *'
10:17:54 <lambdabot>     When matching the kinds of `(->) :: ?? -> ? -> *' and
10:17:59 <xerox> meh
10:19:52 <mauke> :t flip runContT return (callCC $ \exit -> do x <- lift [1..]; if x == 45 then exit x else return x)
10:19:54 <lambdabot> forall b. (Enum b, Num b, MonadCont (ContT b [])) => [b]
10:20:11 <ddarius> Good call mauke.
10:20:15 <paolino> ah
10:20:55 <xerox> > flip runContT return (callCC $ \exit -> do x <- lift [1..]; if x == 45 then exit x else return x)
10:20:57 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
10:21:12 <xerox> > flip runContT return (callCC $ \exit -> do x <- lift [1..]; if x == 5 then exit x else return x)
10:21:14 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
10:23:05 <paolino> well, it just doesn't stop at 5
10:24:07 <mauke> > flip runCont id $ runListT (callCC $ \exit -> do x <- ListT (return [1..]); if x == 45 then exit x else return x)
10:24:09 <lambdabot>  [45]
10:26:58 <MarcWeber> Hi jyp, how are you?
10:29:20 <paolino> mauke, where is the list ?
10:29:29 <mauke>  [45]
10:29:49 <paolino> uhm should be [1..45]
10:29:55 <mauke> why?
10:30:02 <ddarius> paolino: Then you need to build the result list.
10:30:54 <paolino> do x <- [1..45] ;return x  was the thing to mimic
10:31:32 <paolino> do x <- [1..]; stop (x == 45); return x
10:31:37 <paolino> really
10:33:19 <paolino> and that asymmetry of the transformers looks dangerous ..
10:33:29 <ddarius> > flip runCont id (callCC $ \exit -> foldM (\acc x -> if x == 4 then exit acc else return (x:acc)) (return []) [1..])
10:33:37 <lambdabot>   add an instance declaration for (Num [a])
10:33:37 <lambdabot>     In the expression: 1
10:33:43 <ddarius> :t foldM
10:33:45 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
10:33:58 <ddarius> > flip runCont id (callCC $ \exit -> foldM (\acc x -> if x == 4 then exit acc else return (x:acc)) [] [1..])
10:34:00 <lambdabot>  [3,2,1]
10:36:15 * wli goes through YAHT
10:36:50 <wli> Is the first exercise 3.1?
10:38:01 <paolino> :t mapM
10:38:04 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
10:38:13 <jyp> hi MarcWeber
10:39:08 <paolino> > flip runCont id (callCC $ \exit -> mapM (\x -> if x == 45 then exit acc else return x)  [1..])
10:39:09 <lambdabot>   Not in scope: `acc'
10:43:35 <paolino> ok, thanks mauke and ddarius,
10:51:42 <dcoutts> mnislaih: it's in the Makefile.am, add the deps to libHS<pkg>_a_EXTERNALDEPS
10:51:57 <mnislaih> ahh thx dcoutts
10:52:49 <mnislaih> I wanted it to have the ghci debugger (needed a HEAD compatible gtk2hs), but we are doing well now
10:54:37 <ndm> @seen dcoutts
10:54:37 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-overflow, #haskell and #ghc. I last heard dcoutts speak 2m 55s ago.
10:54:44 <ndm> yay! dcoutts :)
10:59:39 <ndm> dcoutts: are there any methods in Gtk2Hs for finding stuff like what red/blue etc are?
11:00:00 <ndm> I can just about hack it with minBound/maxBound, so its not critical
11:06:39 <ndm> anyone know why Double is not an instance of Ix?
11:06:50 <ndm> oh, i see
11:06:52 <ddarius> Because that would be obscene?
11:07:08 <ndm> in that case, anyone know why inRange is in Ix
11:07:10 <fasta> Hmm, is defining a function is_zero overkill?
11:07:21 <ndm> fasta, its already defined (==0)
11:08:22 <ndm> plus it should be isZero, if anything
11:08:36 <fasta> ndm: that's your style
11:08:44 <fasta> ndm: and of the Haskell report, and what else.
11:08:48 <ndm> fasta, thats Haskell style, for the base libraries
11:08:53 <fasta> ndm: doesn't mean it's "perfect".
11:09:03 <ndm> fasta, i personally don't mind either style, the important thing is consistency
11:09:13 <fasta> ndm: I don't think consistency is important
11:09:23 <fasta> ndm: since you can easily write a tool to interchange them
11:09:38 <fasta> ndm: it's really not an issue.
11:09:56 <fasta> Emacs already has such modes, IIRC.
11:23:10 <Cheery> what is the simplest implementation for algebraic data structures?
11:24:22 <AStorm> Cheery, MonadZero most likely
11:24:32 <Cheery> and is the pair everything you need for creating data structures of any sort?
11:24:48 <AStorm> Nope
11:24:54 <AStorm> you need lists too
11:25:07 <mauke> list = pair + recursion
11:25:19 <AStorm> mauke, yes, but each will be differently typed
11:25:23 <mauke> no
11:25:26 <AStorm> really inconvenient
11:25:29 <timthelion> um, what is different about the IO monad than the Maybe monad in how it is defined that makes it so that one can't just pattern match away?  How is it defined so as to prevent my doing value IO a = a?
11:25:44 <mauke> type List a = (a, List a)
11:26:01 <AStorm> mauke, yep, and how do you know when to end snd-ing that?
11:26:05 <mauke> or am I doing it wrong?
11:26:09 <AStorm> when it errors out?
11:26:19 <Philippa> Cheery: do you mean: simplest way to implement Haskell-style algebraic datatypes in an interpreter?
11:26:47 <Philippa> if so, a pair of a constructor and a list of values is probably the simplist way to do the runtime part
11:27:06 <AStorm> timthelion, it's because there's no fromIO
11:27:10 <AStorm> (and should be none)
11:27:16 <AStorm> and there's fromMaybe
11:27:18 <ddarius> Bah, just implement them as a library if you have HOFs.
11:27:21 <mauke> AStorm: newtype List a = List (Either () (a, List a))
11:27:31 <AStorm> mauke, now, that will work
11:27:31 <EvilTerran> timthelion, IO is a type name, not a constructor
11:27:37 <AStorm> except it requires Either :>
11:27:48 <mauke> yes, you need sums and products
11:27:52 <EvilTerran> timthelion, by which i mean, IO is like Maybe, not like Just (for instance)
11:28:06 <timthelion> OK, so the definition of a monad is different from writing just data Foo =...
11:28:08 * wli wraps up chapter 3 of YAHT.
11:28:49 * timthelion goes back to reading source code.
11:28:55 <EvilTerran> timthelion, IO is an abstract data type. there's something you can do when writing a module that means that people importing your module can see a type, but none of its constructors
11:29:14 <timthelion> EvilTerran: ok
11:29:22 <mauke> also, this has nothing to do with monads
11:29:29 <EvilTerran> this means you can't pattern-match on it, you can only manipulate values of that type with the functions that module provides
11:29:50 <EvilTerran> IO does that. as mauke says, it has nothing to do with IO being a monad.
11:30:17 <timthelion> EvilTerran: is everything I define with data a monad?
11:30:22 <mauke> no
11:30:45 <EvilTerran> something is only a monad if you've written "instance Monad <that> where..."
11:31:02 <mauke> if you implement >>= and return, then it is a Monad
11:31:34 <AStorm> (and if it observes monad laws)
11:31:43 <mauke> IO could also export functions ioReturn and ioBind without implementing Monad, and it'd still work
11:34:51 <timthelion> what functionality of monadism does Maybe use that it can't get from data? I see in the source that it has both a data definition and a monad instance.
11:35:36 <mauke> do you know what a typeclass is?
11:35:46 <timthelion> no?
11:35:58 <mauke> a typeclass is an interface
11:36:39 <mauke> you can make an interface and have several types implement it; then you can use the same functions ("methods") for values of different types
11:38:15 <timthelion> so is there a type that I should look at that builds off of maybe?
11:38:26 <mauke> I don't understand that
11:38:48 <ddarius> timthelion: What other languages do you have experience with?
11:39:14 <timthelion> ddarius: elisp, C, Java, C#.
11:39:19 <mauke> class Sporkable a where spork :: a -> a
11:39:31 <EvilTerran> a typeclass is like an OO interface. sort of.
11:39:32 <mauke> instance Sporkable Int where spork x = x + 1
11:39:39 <mauke> instance Sporkable Double where spork x = sqrt x
11:39:46 <mauke> instance Sporkable [a] where spork x = x ++ x
11:40:14 <timthelion> so it's like how we have one function / wich works on Nums,
11:40:27 <timthelion> yet it is different for the different Nums
11:40:27 <mauke> except / is not in Num :-)
11:40:28 <EvilTerran> and if a datatype is an instance of a typeclass, that's like an OO class implementing an interface
11:40:34 <mauke> but yes, that's how it works
11:40:47 <timthelion> / isn't in Num?
11:40:51 <mauke> :t (/)
11:40:56 <ddarius> @src Num
11:41:00 <EvilTerran> > 1/2 :: Int
11:41:00 <mauke> ENOBOT
11:41:11 <ddarius> Oh noes!
11:41:13 <mauke> :t (/)
11:41:16 <Baughnie> forall a. (Fractional a) => a -> a -> a
11:41:25 <EvilTerran> > 1/2 :: Int
11:41:25 <mauke> :t div
11:41:27 <Baughnie> forall a. (Integral a) => a -> a -> a
11:41:28 <Baughnie>   add an instance declaration for (Fractional Int)
11:41:28 <Baughnie>     In the expression: 1 /...
11:41:32 <roconnor> @type fromMaybe
11:41:34 <Baughnie> forall a. a -> Maybe a -> a
11:41:46 <ddarius> @src Num
11:41:47 <Baughnie> class  (Eq a, Show a) => Num a  where
11:41:47 <Baughnie>     (+), (-), (*)           :: a -> a -> a
11:41:47 <Baughnie>     negate, abs, signum     :: a -> a
11:41:47 <Baughnie>     fromInteger             :: Integer -> a
11:42:01 <EvilTerran> timthelion, basically, you can't use / on integers, because, even dividing integers, you don't necessarily know it'll return an integer.
11:42:02 <Baughn> @src MonadPlus
11:42:02 <Baughnie> Source not found. My pet ferret can type better than you!
11:42:45 <EvilTerran> timthelion, so you need to convert the integers to some fractional type before doing /, or use `div` (integer division, rounding down) instead
11:42:51 <timthelion> EvilTerran: so is there somehow a child of Num which contains the types of Nums which can be divided returning the same type?
11:43:06 <EvilTerran> yes, it's called Fractional - see above
11:43:15 <EvilTerran> @src Fractional
11:43:15 <Baughnie> class  (Num a) => Fractional a  where
11:43:15 <Baughnie>     (/)             :: a -> a -> a
11:43:15 <Baughnie>     recip           :: a -> a
11:43:15 <Baughnie>     fromRational    :: Rational -> a
11:43:41 <EvilTerran> ...why is the bot called Baughnie?
11:43:52 <ddarius> Proposal for Haskell', make => into <= in class contexts.
11:43:53 <Baughn> To distinguish it from me
11:44:29 <mauke> @src Floating
11:44:29 <Baughnie> class  (Fractional a) => Floating a  where
11:44:30 <Baughnie>     pi                                                      :: a
11:44:30 <Baughnie>     exp, log, sqrt, sin, cos, tan                           :: a -> a
11:44:30 <Baughnie>     asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh :: a -> a
11:44:30 <Baughnie>     (**), logBase                                           :: a -> a -> a
11:44:38 <mauke> @src RealFloat
11:44:38 <Baughnie> Source not found. Have you considered trying to match wits with a rutabaga?
11:44:43 <timthelion> hmm, class == class, data == struct, instance == polymorphic class?
11:45:03 <Baughn> timthelion: class = interface, rather
11:45:09 <mauke> class == interface, data == struct/class, instance == implements
11:45:29 <timthelion> data can contain functions?
11:45:30 <ddarius> For very loose values of (==)
11:45:35 <ddarius> timthelion: Sure.
11:45:36 <EvilTerran> class ~= interface, instance ~= implements, data ~= struct, abstract data type ~= class
11:45:49 <EvilTerran> (where ~= means "approximately the same)
11:45:59 <ddarius> > exp 1
11:46:00 <Baughnie>  2.718281828459045
11:46:29 <EvilTerran> :t let f x = x+1 in Just f
11:46:31 <Baughnie> forall a. (Num a) => Maybe (a -> a)
11:47:02 <mauke> > 1/3 + 1/3 + 1/3 :: Rational
11:47:03 <Baughnie>  1%1
11:47:07 <mauke> eat that, lisp!
11:47:09 * ddarius proposes also that the Euler-Mascheroni constant be added to Floating.
11:47:18 <fax> (+ 1/3 1/3 1/3)
11:47:31 <fax> â†’ 1
11:47:42 <mauke> > 0.33 + 0.33 + 0.33 + 0.001 :: Rational
11:47:43 <Baughnie>  991%1000
11:47:47 <mauke> er, oops
11:47:54 <mauke> > 0.33 + 0.33 + 0.33 + 0.01 :: Rational
11:47:55 <Baughnie>  1%1
11:48:00 <timthelion> I can see how any one instance of data could contain a function, and how there could be functions that operate on data's but I don't see how a data could have a function.  so therefore data is more structy than classy
11:48:09 <fasta> I wish ICFP there always was an ICFP contest
11:48:13 <EvilTerran> > let e = exp 1 in e
11:48:14 <Baughnie>  2.718281828459045
11:48:26 <fasta> The mailing list traffic reduced dramatically
11:48:39 <EvilTerran> timthelion, yes, that's true. i'd say data ~= struct
11:48:45 <xerox> > sum [1/3 1/3 1/3] -- fax
11:48:45 <Baughnie>   add an instance declaration for (Num (t1 -> t))
11:48:47 <ddarius> data Foo a = Foo { add :: Foo a -> Foo a -> Foo a, sub :: Foo a -> Foo a -> Foo a }
11:48:53 <xerox> aha, well, add commas
11:49:18 <Baughn> timthelion: If you're thinking of methods the way java has, those are just plain functions in haskell. There's no reason to confuse namespaces and classes that way.
11:49:20 <EvilTerran> timthelion, we don't have "methods" in the OO sense in haskell
11:49:23 <fasta> mauke: (+ 1/3  1/3 1/3) => 1
11:49:37 <fasta> mauke: your point?
11:49:42 <Baughn> timthelion: Want the same function to work on multiple types? Make a class and instance it
11:49:43 <EvilTerran> instead you pass your object as a parameter to a function
11:49:57 <fax> fasta: :p
11:50:13 <fax> they should add this to haskell & lisp http://www.brics.dk/~barnie/RealLib/
11:50:39 <Baughn> timthelion: You can also have function signatures like 'Foo a, Bar b => a -> b -> c', ie. multi-methods, which you can't with java-style methods
11:51:01 <EvilTerran> ddarius, is it sufficiently useful to warrant it being bundled into the library?
11:51:07 <timthelion> Baughn: so basically, instance is just a way to scatter the definition of a function throughout your source code, and to make the type of that function more abstract.
11:51:12 <EvilTerran> (Euler-Mascheroni, that is)
11:51:40 <ddarius> fax: There are a few exact real arithmetic libraries for Haskell.
11:51:46 <fax> cool :D
11:51:54 <Baughn> timthelion: It's a way to separate instances from any single class, yes. Use packages for namespaces, not classes; this way, you don't have problems with methods that appear to belong in two or more classes.
11:51:55 <fax> does any come with ghc?
11:52:07 <ddarius> fax: Not bundled, no.
11:52:10 <EvilTerran> timthelion, it's a fundamental part of what makes haskell so expressive
11:52:26 <Baughn> timthelion: Also, it lets you add instances to classes you haven't written yourself. You can instance Num if you like.
11:52:27 <ddarius> EvilTerran: Possibly.  We don't really know yet.
11:52:36 <javaJake> obsethryl, heheheheheh
11:52:41 <Baughn> Very important, since peano arithmetic is strangely missing from the Prelude
11:52:54 <EvilTerran> ddarius, huh?
11:53:00 <ddarius> Baughn: [()]
11:53:31 <chessguy> what does this mean? "*** Exception: Error in array index
11:53:49 <Baughn> chessguy: Access out of bounds?
11:53:52 <mauke> fasta: [16]> (loop repeat 10 summing 0.1)
11:53:52 <mauke> 1.0000001
11:53:52 <ihope> @type (!!)
11:53:54 <Baughnie> forall a. [a] -> Int -> a
11:53:58 <mauke> > sum (repeat 10 0.1) :: Rational
11:53:59 <ihope> > [] !! 600
11:53:59 <Baughnie>  Couldn't match expected type `t -> [a]'
11:54:00 <Baughnie>  Exception: Prelude.(!!): index too large
11:54:04 <timthelion> chessguy: maybe that you gave nth an index that was not in the arrary
11:54:05 <ihope> Well, it's certainly not that.
11:54:06 <mauke> > sum (replicate 10 0.1) :: Rational
11:54:07 <Baughnie>  1%1
11:54:07 <EvilTerran> i guess you could use something else to achieve the same level of expressiveness, but without it or a substitute, haskell would be much less expressive
11:54:16 <ddarius> > [] !! -1
11:54:17 <Baughnie>      precedence parsing error
11:54:17 <EvilTerran> and with a substitute, it wouldn't really be haskell ;]
11:54:17 <Baughnie>         cannot mix `(!!)' [infixl 9] and prefix...
11:54:23 <Baughn> ihope: Would that error make sence with multidimensional arrays?
11:54:24 <ddarius> > [] !! (-1)
11:54:25 <Baughnie>  Exception: Prelude.(!!): negative index
11:54:38 <ihope> > 3.141592653598264018536120572 :: Rational
11:54:39 <Baughnie>  785398163399566004634030143%250000000000000000000000000
11:54:42 <Baughn> Anyhow, lists aren't arrays. :P
11:54:45 <ihope> Rather nice.
11:54:48 <chessguy> > (array (1,1) []) ! 5
11:54:49 <Baughnie>  Exception: Ix{Integer}.index: Index (5) out of range ((1,1))
11:54:50 <fasta> mauke: that's CL, I was using Scheme
11:54:54 <ihope> Indeed, not arrays.
11:55:15 <chessguy> > (array ((0,2),(0,2)) []) ! 5
11:55:15 <Baughnie>   add an instance declaration for (Num (t, t1))
11:55:23 <fasta> mauke: hmm, but  sum (replicate 10 0.1) :: Rational does show something
11:55:25 <fax> (loop repeat 10 summing 1/10) :p
11:55:25 <fasta> mauke: nice
11:55:32 <Baughn> > (array ((2,4),(0,8)) []) ! (-3,42)
11:55:34 <Baughnie>  Exception: Error in array index
11:55:45 <mauke> > (+ 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1)
11:55:45 <mauke> 0.9999999999999999
11:55:46 <Baughnie>        add an instance declaration for
11:55:46 <Baughnie>       (Fractional (t
11:55:46 <Baughnie>                  ...
11:55:48 <fasta> fax: right that works
11:55:51 <fax> or write a macro so any numbers are read as rationals
11:56:05 <fax> its a diff. language you write things differently
11:56:07 <Baughn> > (array ((2,4),(0,8)) []) ! (2,4)
11:56:08 <Baughnie>  Exception: Error in array index
11:56:09 <mauke> fax: you need 10 reader macros, one for each digits
11:56:16 <fax> in haskell 0.1 in lisp 1/10
11:56:17 <chessguy> > (array ((0,0),(5,5)) []) ! (-3,42)
11:56:18 <Baughnie>  Exception: Error in array index
11:56:23 <chessguy> > (array ((0,0),(5,5)) []) ! (3,42)
11:56:24 <Baughnie>  Exception: Error in array index
11:56:28 <fax> mauke: you only need one macro
11:56:37 <ddarius> In Haskell 0.1 or 1/10
11:56:39 <fax> just set it for 10 different dispatch characters
11:56:45 <mauke> or 1%10
11:56:52 <EvilTerran> > 1%3
11:56:53 <ddarius> Great googly moogly
11:56:53 <Baughnie>  1%3
11:57:11 <Baughn> > 0/(negate 0)
11:57:12 <Baughnie>  NaN
11:57:18 <Baughn> > 1/(negate 0)
11:57:19 <Baughnie>  -Infinity
11:57:25 <Baughn> Ah yes. Math.
11:57:29 <EvilTerran> googly moogly - like a synth that can search the internet :D
11:57:49 <Philippa> except it stops rhyming at that point
11:58:10 <Philippa> it could, however, be a search engine that makes "kupo" sounds all the time
11:58:56 <chessguy> @src print
11:58:56 <Baughnie> print x = putStrLn (show x)
11:59:11 <ddarius> print = putStrLn . show
11:59:24 <chessguy> @src putStr
11:59:24 <Baughnie> putStr s  = hPutStr stdout s
12:02:06 <der_eq> why isn't getContents >>= (Data.ByteString.Lazy.putStr).(Data.ByteString.Lazy.Char8.unfoldr (\st -> case st of (x:xs) -> Just (x,xs) ; [] -> Nothing)) lazy?
12:03:27 <opqdonut> i'd guess because of the x:xs pattern match
12:03:33 <opqdonut> or hmm
12:03:37 <opqdonut> dunno
12:04:17 <wli> I'm on 4.10 of YAHT and am wondering when it'll start getting interesting.
12:04:41 <fax> I want a different book than yaht
12:04:52 <ddarius> We need an SICP for Haskell.
12:04:53 <opqdonut> SoE is nice
12:04:56 <wli> fax: I was hoping for something... less basic.
12:04:58 <opqdonut> ddarius: seconded
12:05:27 <wli> ddarius: SICP for Haskell would be excellent.
12:05:33 <fax> better than sicp
12:05:49 <mauke> I heard the Gentle Introduction is less basic
12:05:59 <wli> I'm mostly thinking something targeted at a more intermediate audience.
12:06:04 <wli> mauke: I'll do that next.
12:06:23 <der_eq> it's doesn't become lazy even if I change (x:xs) into ~(x:xs)
12:06:26 <ddarius> wli: It's quite a bit shorter than YAHT, I'd probably recommend doing it first.
12:07:09 <wli> ddarius: I need to actually finish what I'm starting, so no flitting between tutorials.
12:07:21 <ddarius> I never did read YAHT (though I didn't need to when it was made. I started just to see though, but didn't finish.)
12:07:51 <ddarius> wli: Don't flit.  Stop reading YAHT, read the Gentle Introduction through.
12:10:43 <ddarius> It should only take an hour or so to go throught the Gentle Introduction.
12:10:43 <fasta> wli: went through SICP already?
12:11:12 <fax> more fun writing a program in haskell than "learning the language"
12:11:28 <fasta> wli: If you want a not so basic exercise... I have plenty well defined problems.
12:11:58 <wli> fasta: I'm interested.
12:12:29 <wli> fasta: I didn't do quite all of SICP, and it was something like 10 years ago.
12:12:34 <fasta> wli: I am interested in a compiler from Haskell to an AST containing AND, OR and NOT nodes.
12:13:37 <Heffalump> and nothing else?
12:13:39 <wli> fasta: Silicon compiler?
12:13:55 <fasta> Heffalump: Just that, for now.
12:14:00 <Heffalump> that sounds like a rather hard exercise
12:14:07 <fasta> Heffalump: I can think of other exercises. :)
12:14:21 <fasta> wli: no
12:14:22 <wli> fasta: Usually those target a subset of VHDL/etc. synthesizable in some particular vendors FPGA toolchain.
12:14:22 <Heffalump> an entire Haskell compiler would be quite big
12:14:44 <wli> fasta: I'm not capable of a project quite so grand.
12:14:47 <fasta> Heffalump: It's no crime to call GHC to do lots of stuff first.
12:15:01 <Heffalump> even so
12:15:57 <wli> fasta: I'm frankly at a point where monadic interpreters for toy languages would be a serious achievement and would represent a serious advancement of my skill level.
12:16:23 <fasta> wli: It's just an algorithm.
12:16:40 <fasta> wli: it would only involve finding out how all the basic operations of a computer work.
12:16:47 <wli> fasta: Algorithms have their difficulties of implementation, problem size, etc.
12:16:48 <Heffalump> go on, write a monadic interpreter, then
12:16:52 <Heffalump> they're always fun
12:17:09 <fax> what is a monadic interpreter as opposed to a non-monadic one?
12:17:13 <wli> Heffalump: Well, I apparently need to improve skills upon which that depends.
12:17:16 <fasta> wli: another one: convert a factorisation problem to a logical expression
12:17:29 <fasta> wli: bonus points to make it as small as possible
12:17:54 <fasta> wli: or do you want a more "practical"(whatever that means) problem?
12:17:58 <wli> fasta: Quine-McCluskey is well-known to be intractable for extremely large predicates.
12:18:05 <ddarius> fax: One that uses monads.
12:18:10 <mauke> wli: write a brainfuck interpreter
12:18:21 <wli> fasta: I need something small enough I can actually get it done directly.
12:18:38 <Heffalump> normally that relates each interpreted operation to an operation in some underlying monad
12:18:42 <mauke> or a false interpreter
12:18:50 <wli> mauke: I'm trying to work up to the level where I can actually grind out interpreters in Haskell.
12:18:51 <ddarius> @seen bos
12:18:51 <Baughnie> I saw bos leaving #haskell 34m 25s ago, and .
12:18:53 <fax> ddarius: I don't see what you mean
12:19:03 <fasta> wli: cool, you told me something new.
12:19:11 <fasta> wli: I wasn't aware of that algorithm.
12:19:17 <mauke> wli: brainfuck should be simple enough
12:19:25 <fax> why do you say monadic interpreter as if monadic is some significant feature?
12:19:25 <ddarius> Instead of, for example, eval :: AST -> Env -> Value, you have eval :: AST -> Reader Value
12:19:43 <ddarius> fax: If you are trying to learn how to use monads, it is significant.
12:19:47 <fasta> fax: Wadler wrote a paper on them and named them like that.
12:20:06 <fax> is there any advantage to do it that way?
12:20:12 <Heffalump> well, it's a significant implementation detail
12:20:17 <ddarius> fax: Yes.
12:20:18 <Heffalump> it's not significant to users, normally
12:20:24 <fax> like what
12:20:30 <fasta> I think it's better to learn monads by doing something for which you can't easily look how others did it.
12:20:35 <mauke> fax: modularity
12:20:49 <wli> fax: I can grind out interpreters by brute-force, but not using the idioms, facilities, and algorithms that make Haskell useful.
12:20:56 <ddarius> Like if you want to add state later, you just change the monad to StateT s Reader Value and add a few cases.
12:21:00 <fasta> But a few years laters "arrows" were claimed to be better.
12:21:01 <mauke> e.g. if you notice you need an additional piece of state in your interpreter, you just change the monad
12:21:07 <mauke> you don't have to modify intermediate functions
12:21:07 <fax> wli: yeah, thats what I did
12:21:15 <ddarius> fasta: I never use arrows.
12:21:18 <fasta> Probably next year Bananas will be the nex.
12:21:21 <fax> hm
12:21:25 <fasta> next*
12:21:31 <fasta> ddarius: I do sometimes.
12:21:36 <ddarius> @google Dealing with Large Bananas
12:21:40 <Baughnie> http://www.cwi.nl/~ralf/wgp00/
12:21:40 <Baughnie> Title: Dealing with Large Bananas
12:21:48 <fasta> ddarius: but that's runKleisli mostly.
12:21:49 <Heffalump> arrows are much more complicated, and usually you don't need them
12:21:54 <wli> ddarius: YAHT has started getting into material I actually need to brush up on.
12:22:00 <ddarius> wli: Ok.
12:22:02 <wli> ddarius: Like CPS.
12:22:10 <fasta> The syntax for arrows is not intuitive to me.
12:22:32 <fasta> I am not used to it and my programs are generic enough as it is.
12:22:32 <Heffalump> it's intuitive, just cumbersome (IMO)
12:22:52 <ddarius> I don't like the fact that it is nowhere near as transparent as do-notation.
12:25:04 <wli> I think grinding through problem sets is the way I have to learn things.
12:25:42 <wli> It's how I turned into an idiot savant for bonehead calc integration problems.
12:26:24 <Heffalump> the desugaring is non-local
12:26:38 * ddarius has no desire to be an idiot savant.
12:27:56 <ihope> Idiot savant...
12:28:10 <ihope> Yeah, no desire there.
12:28:20 <wli> ihope: Who knows? Maybe the savant is missing in my case. ;)
12:28:35 <ihope> :-)
12:29:10 <ihope> Quick, 2xdx! :-P
12:29:33 <mauke> xÂ²
12:30:02 <ihope> @type ???
12:30:04 <Baughnie> parse error on input `???'
12:30:42 <ihope> Noes, Baughnie ate lambdabot! And indeed, though the syntax highlighter does something with ???, that doesn't mean it's valid.
12:31:01 <ddarius> @type (???)
12:31:03 <Baughnie> Not in scope: `???'
12:31:11 <ihope> Oh.
12:31:33 <Baughn> @type let (???) = (+) in (+)
12:31:35 <Baughnie> forall a. (Num a) => a -> a -> a
12:31:51 <ihope> @type ?questionMark
12:31:52 <Baughnie> forall t. (?questionMark::t) => t
12:31:58 <ihope> @type ?questionMark?
12:31:59 <Baughnie> parse error (possibly incorrect indentation)
12:32:00 <Baughn> See? Val...id. Er.
12:32:02 <ihope> Darn.
12:32:24 <ihope> "Val id" is in Val id.
12:33:09 <ddarius> > let p ? x = if p then Just x else Nothing in otherwise ? 5
12:33:10 <Baughnie>  Just 5
12:33:18 <ska-fan> YAHT 4.11 - foldr. Correct?
12:33:33 <ihope> > let val x = x 3 in val id
12:33:34 <Baughnie>  3
12:33:38 <Baughn> > otherwise
12:33:39 <Baughnie>  True
12:33:54 <ihope> Isn't otherwise so exceedingly useful?
12:33:57 <Baughn> Okay. I understand that, but.. still odd.
12:34:03 <ddarius> ihope: I use it all the time.
12:34:09 <ddarius> @src otherwise
12:34:10 <Baughnie> otherwise = True
12:34:11 <Baughn> I actually thought it was syntax
12:34:47 <ddarius> @roll 1d3
12:34:47 <Baughnie> Consider it noted.
12:34:52 <ddarius> Doh
12:34:54 <mauke> haha
12:34:54 <ddarius> @dice 1d3
12:34:55 <Baughnie> 1d3 => 2
12:35:04 <ihope> @roll
12:35:04 <Baughnie> Plugin `tell' failed with: IRCRaised Prelude.head: empty list
12:35:10 <ihope> :-)
12:35:13 <mauke> @quake
12:35:14 <Baughnie> kzm says: I therefore propose that all functions should either be of type '() -> ()', or non-terminating.
12:35:28 * Baughn quakes
12:35:44 <ihope> ...why should they all be () -> ()?
12:35:46 <ihope> :-P
12:35:59 <mauke> it simplifies debugging
12:36:04 <ihope> Ah.
12:36:04 <SamB> @quote kzm
12:36:04 <Baughnie> kzm says: I therefore propose that all functions should either be of type '() -> ()', or non-terminating.
12:36:06 <xerox> total functions
12:36:10 <ihope> @keal
12:36:10 <Baughnie> making a bot of me is highly offensive
12:36:17 <ddarius> Now all I have to do is decide what to map 1, 2 and 3 (or at least 2) to
12:37:01 <Baughn> If you want to simplify debugging, make them all Variant -> Variant
12:37:16 <thoughtpolice> i don't know if this is annoyingly-common, but i'm having a lamdabot build issue from the darcs repo
12:37:29 <Baughn> thoughtpolice: It is. Using 6.6.1?
12:37:34 <mauke> don't you know that building lambdabot is impossible?
12:37:48 <Baughn> Not impossible, you just need a PhD
12:37:59 <thoughtpolice> Baughn: on my linux box no, 6.6
12:38:02 <ddarius> dons is still working on his, no?
12:38:04 <ihope> Wait, it's impossible? No wonder...
12:38:15 <mauke> newtype Variant = Variant (Variant -> Variant)
12:38:17 <hpaste>  thoughtpolice pasted "lambdabot build" at http://hpaste.org/1840
12:38:39 <Baughn> thoughtpolice: You're supposed to use ./build
12:38:41 <ihope> Well, I've done all the hard stuff here, so you guys can focus on the easy: http://hpaste.org/1839
12:38:43 <ihope> :-P
12:39:08 <Baughn> thoughtpolice: That aside.. yes, known bug. You need to change Parser.hs... are you /sure/ you're on 6.6 and not 6.6.1
12:39:09 <thoughtpolice> Baughn: i was looking through #haskell logs (that were recent iirc) that said to 'just do the standard cabal dance'
12:39:16 <thoughtpolice> Baughn: yes
12:39:28 <thoughtpolice> austin@continuum ~/c/h/lambdabot> ghc --version
12:39:28 <thoughtpolice> The Glorious Glasgow Haskell Compilation System, version 6.6
12:39:28 <thoughtpolice> austin@continuum ~/c/h/lambdabot>
12:39:58 <thoughtpolice> Baughn: also, for some reason using ./build gives me a different error
12:39:59 <Baughn> thoughtpolice: I think I see
12:40:07 <Baughn> thoughtpolice: Search parser.hs for "#if __GLASGOW_HASKELL__ >= 606"
12:41:17 <Baughn> thoughtpolice: See, that was just now patched to make it build on 6.6.1...
12:41:17 <nopcode> hey
12:41:23 <thoughtpolice> thoughtpolice: L8237
12:41:24 <Baughn> thoughtpolice: Which breaks it on 6.6 instead.
12:41:32 <thoughtpolice> Baughn: bummer
12:41:36 <Baughn> thoughtpolice: You need to change the >= on that line to >
12:42:09 <Baughn> thoughtpolice: (6.6 defines it to 606. 6.6.1 /also/ defines to 606. This is an issue.)
12:42:15 <thoughtpolice> Baughn: cool, looks like the build is puttering along now :)
12:42:53 <nopcode> i'm thinking about writing some generic backtracking code for puzzle games and the like... as argument i could take a function that expands the children of a node, another function that determines a node's "value" and one that identifies the target node, right?
12:42:55 <thoughtpolice> Baughn: also, when building using ./build from the darcs repo, I get a conflicting package error (Data.ByteString.Char8 is found in fps-0.7 and base)
12:43:02 <Baughn> thoughtpolice: In general, lambdabot is developed alongside ghc. It uses internal interfaces, so you should keep them in sync.
12:43:11 <thoughtpolice> yet this does not manifest when just using runghc Setup.hs [configure|build|install]
12:43:29 <thoughtpolice> although you need it installed anyway iirc
12:43:36 <thoughtpolice> Baughn: noted
12:43:39 <thoughtpolice> ty :)
12:43:42 <thoughtpolice> Baughn++
12:44:11 <thoughtpolice> Baughn: the config file looks different from the .tar.gz, can I just configure lambdabot in situ?
12:44:16 <Baughn> thoughtpolice: Does the fps error show up when compiling BotPP.hs?
12:44:31 <thoughtpolice> Baughn: yes, with ./build, but not doing the three commands manually
12:44:34 <thoughtpolice> dunno why :/
12:44:40 <Baughn> thoughtpolice: You kinda have to. It's configured at compile time, unfortunately
12:45:04 <byorgey> nopcode: sounds good to me
12:45:11 <thoughtpolice> Baughn: so do I need to copy a config from the .tar.gz? the Config datatype doesn't define things like username and the like
12:45:15 <Baughn> thoughtpolice: I mean, the only command in ./build that you might otherwise be neglecting is the build of botpp.hs
12:45:23 <Baughn> thoughtpolice: Oh. No.
12:45:33 <nopcode> byorgey: ok
12:45:36 <Baughn> thoughtpolice: That's configured in online.rc (or from the command line)
12:45:56 <thoughtpolice> Baughn: cool
12:46:06 <thoughtpolice> the build is going good now :)
12:46:16 <thoughtpolice> thanks, i think I should handle it from here. you mind if anything goes wrong I ask ya?
12:46:36 <Baughn> Ask the channel. If I'm here and can answer, I will.
12:46:52 <thoughtpolice> Baughn: the thing is though, using Setup.hs build and whatnot does build BotPP.hs
12:46:58 <thoughtpolice> only it has no error
12:47:04 <thoughtpolice> it might have been something weird
12:47:14 <Baughn> thoughtpolice: But there's an error if you do the ghc --make of botpp.hs manually?
12:47:19 <thoughtpolice> i didn't configure the build so i'll try rebuilding and see if i can replicate it
12:47:37 <thoughtpolice> Baughn: no error when I use runghc Setup.hs configure, etc.
12:47:44 <thoughtpolice> but using the ./build script i get an err
12:47:56 <Baughn> thoughtpolice: That's not what I asked. Is there an error if you ghc --make botpp.hs?
12:48:08 <Baughn> thoughtpolice: That is to say, /which/ line of ./build fails?
12:48:14 <thoughtpolice> Baughn: just a sec
12:51:01 <thoughtpolice> Baughn: it's still building but i'll can investigate that and get back to you if you don't mind
12:51:12 <Baughn> thoughtpolice: Well, even if we find out, it's probably no use. It works on 6.6.1 now; 6.6 is more or less deprecated.
12:51:44 <fasta> @pl liftM2 zip
12:51:44 <Baughnie> liftM2 zip
12:51:56 <thoughtpolice> Baughn: yeah 6.6.1 hasn't updated in archlinux's package repos
12:51:59 <ddarius> @pl map f (map g xs)
12:52:00 <Baughnie> map f (map g xs)
12:52:10 <thoughtpolice> so i haven't taken the time to just compile by source
12:52:10 <Baughn> fasta: You need actual points for @pl to make sense
12:52:27 <fasta> Baughn: yes, but I thought it sometimes also simplified stuff
12:52:29 <ddarius> However, @pl bizarrely does an optimization
12:52:34 <thoughtpolice> Baughn: i do have ghc 6.6.1 on my openbsd box though, and hopefully I can get ghc on my dragonfly box :)
12:52:40 <ddarius> @pl \xs -> map f (map g xs)
12:52:40 <Baughnie> map (f . g)
12:53:01 <Baughn> thoughtpolice: Personally, I like to keep my own setup outside of the os, for exactly that reason
12:53:25 <Baughn> @pl map f (map g xs)
12:53:25 <Baughnie> map f (map g xs)
12:53:41 <Baughn> @pl \xs g f -> map f (map g xs)
12:53:41 <Baughnie> (flip map .) . flip map
12:55:08 <ddarius> All I need to do is make a smart concat and my ropes should be set.
12:57:11 <chessguy> @type execState
12:57:13 <Baughnie> forall s a. State s a -> s -> s
12:57:44 <thoughtpolice> Baughn: in the online.rc file when it says 'rc passwd.rc' does it just require the password to be in plaintext in passwd.rc?
12:58:08 <Baughn> thoughtpolice: No. That attempts to execute passwd.rc as if it were in the same file.
12:58:23 <amaron> people, howmuch did you need to learn haskell, if you were "imperative programmer" before?
12:58:32 <Baughn> thoughtpolice: You'd stick a privmsg command to nickserv in there, normally. It's really just so the password doesn't get into the repository. ;)
12:58:59 <thoughtpolice> Baughn: full command an all (ex. /msg nickserv password ...)
12:59:02 <thoughtpolice> ?
12:59:16 <amaron> I'm trying to learn it from "yet another haskell tutorial" and I feel like complete noob...
12:59:18 <Baughn> thoughtpolice: It isn't an irc client. You stick a /lambdabot/ command there.
12:59:18 <Codex_> amaron: at least enough to learn functions and what you can do with them.
12:59:39 <Baughn> thoughtpolice: F.ex. mine contains "msg rizon:nickserv identify ********"
13:00:00 <thoughtpolice> Baughn: ah thanks
13:00:42 <amaron> Codex_: how fast you get confortable in it to write useful programs?
13:00:45 <Baughn> @let foo = 6
13:00:47 <Baughnie> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
13:01:14 <Codex_> amaron: that's pretty soon. Once you understand the compiler error messages...
13:01:44 <ddarius> amaron: It took me about a month.
13:01:48 <Baughn> amaron: Depends on what you consider useful. It probably takes a little more than what you're used to, but that's a given.
13:02:11 <Baughn> amaron: Learn lisp first, and it'll only take two weeks. Of course, learning lisp takes a year or two as well. ;)
13:02:50 <amaron> I usualy in few days can learn new imperative language, but this... even basic concepts are so messy in my head... :(
13:03:07 <fax> learning lisp is impossible
13:03:09 <ddarius> amaron: Yep.  You have to learn new stuff now.
13:03:14 <ddarius> fax: No it isn't.
13:03:15 <SamB> Baughn: how long does it take if you learn scheme first instead?
13:03:16 <fax> lisp doesn't exist
13:03:33 <Baughn> SamB: Three weeks. Then you have to figure out the OO concepts as well.
13:03:52 <SamB> what OO concepts?
13:03:59 <amaron> why not haskell directly?
13:04:00 <SamB> Haskell doesn't support OO does it?
13:04:01 <Baughn> Typeclasses
13:04:15 <ddarius> Typeclasses aren't OO.
13:04:17 <Baughn> So you say, but I can do everything with typeclasses I'd do with OO..
13:04:24 <SamB> well yes.
13:04:25 <fax> Typeclasses look very OO to me
13:04:35 <SamB> but what does that have to do with what I just said?
13:04:35 <fax> a very lose definition of OO
13:04:50 <Baughn> SamB: Scheme lacks OO, so learning scheme doesn't help with typeclasses
13:04:53 <Heffalump> they lack virtual dispatch, which is a key issue
13:04:53 <ddarius> Baughn: They don't even do dynamic dispatch, one of the basics of OO.
13:05:14 * SamB has some Core for ddarius to look at
13:05:16 <Baughn> ddarius: Can't say I've noticed
13:05:21 <fax> scheme has lambda the ultimate object system :P
13:05:29 <Baughn> ddarius: Foo a => a -> a -- What is that, exactly?
13:05:43 <SamB> is that where you post your problem on lambda the ultimate and someone will solve it?
13:06:39 <ddarius> Baughn: If tha had type Foo -> Foo for some interface/class Foo, then the input and output would not have to be the same type.
13:07:37 <amaron> ok, it looks like one suggests to me to learn pascal before c, to learn how to program, then I ask: why not c directly? Same it goes for scheme/haskell here.
13:07:43 <Baughn> ddarius: Which is the obvious mapping for a class method that just alters the object, yes
13:08:09 <Maddas> amaron: perhaps it makes the transition easier
13:08:12 <amaron> I guess haskell is more complex and powerfull than scheme
13:08:23 <fax> it is certainly more complex
13:08:26 <ddarius> amaron: More complex, incomparable in power.
13:08:26 <Maddas> amaron: it's definitely further away from imperative languages
13:08:29 <fax> I dont think you can measure or compare power
13:08:32 <Baughn> ddarius: My point was, while the typing of haskell might not strictly speaking be /dynamic/ as such, I haven't actually noticed the borders. I suppose I might, but I haven't yet.
13:08:46 <Baughn> ddarius: And I instinctively think OOishly where that fits
13:09:29 <amaron> my worst problem is to forget oo and procedural way of thinking and solving problems
13:09:31 <ddarius> Baughn: You've never wanted a list of things you apply an operation to all elements without requiring them to be the same.  E.g. printList :: [Showable] -> IO ()
13:09:35 * Baughn measures power by ability to confuse ordinary CS students
13:09:51 <ddarius> Malbolge, the most powerful language ever.
13:10:01 <Baughn> Eh. Malbolge is solved.
13:10:17 <ddarius> It is?  I haven't looked in many many years.
13:10:28 <Baughn> ddarius: I've never wanted that badly enough that I haven't found a perfectly good solution that doesn't require it, no.
13:10:28 <SamB> doesn't it still confuse ordinary CS students?
13:10:33 <SamB> I haven't actually met any though
13:10:39 <Baughn> ddarius: There are, of cours, union types
13:10:49 * fax wonders what unis teach computing via Malbolge
13:10:57 <Baughn> ddarius: But the moment I touch Variant, I'll tell you. ;)
13:11:48 <pjd> ddarius: it's been cryptoanalyzed, anyway
13:12:07 <pjd> not sure if i would call it solved
13:12:11 <amaron> did any of your wrote some business class aplication (n-tier, complex database, complex middle layer, gui with alot of forms, etc...) in haskell?
13:12:11 <Baughn> ddarius: It turned out to be pretty easy to write Malbolge programs, unfortunately
13:14:26 <amaron> those applications now have support of modeling process in oo like unified process with uml, design patterns..., how do you model complex applications for haskell?
13:15:18 <Baughn> amaron: Design patterns are, of course, mostly used to paper over flaws in the language. As for the rest..
13:15:30 <SamB> well we try our darndest to make applications simple
13:16:23 <Baughn> amaron: UML doesn't fit anything but OO. Algebra does. You can use a lot of concepts from that to describe your programs.
13:16:46 <amaron> do you use n-tier concept for database applications?
13:17:02 <nopcode> hey
13:17:08 <nopcode> how do i sort by the value of a function again?
13:17:17 <nopcode> applied to the elements of the list to be sorted
13:17:18 <ddarius> :t sortBy
13:17:19 <Baughnie> forall a. (a -> a -> Ordering) -> [a] -> [a]
13:17:20 <amaron> Baughn: so you desing your applications in algebra?
13:18:01 <amaron> *design
13:18:01 <ddarius> amaron: I imagine most Haskell programmers design their programs in much the same way other programmers do, which is not with UML.
13:18:05 <nopcode> ddarius: hm but then i'd have to do the comparison myself?
13:18:11 <Baughn> amaron: Ad-hocishly, really, but somewhat yes. I haven't run across any studies on designing for haskell, but doing what seems reasonable seems to work.
13:18:29 <ddarius> nopcode: sortBy (\x y -> f x `compare` f y)
13:18:44 <nopcode> ddarius: kk thx :)
13:18:45 <ddarius> There are some helper functions in very new versions of GHC for this to.
13:18:48 <Baughn> amaron: Algebra is just a tool to describe the program more easily, which translates to being able to handle larger designs
13:18:55 <fax> the paper on frag was interesting
13:19:06 <fax> about designing a large 3d game in haskell
13:19:23 <ddarius> There was a design notation made for functional languages, but I don't think anyone at all ever used it.
13:19:42 <amaron> Baughn: can you show me real samples of that?
13:19:59 <amaron> Baughn: I mean algebra model of some program?
13:20:30 <puchacz> Hi, I am a Java guy for a day job and a Lisper in evenings; I wanted to learn about parsing (which is not my forte now) and I gathered parsec enjoys a high opinion.
13:20:52 <Baughn> amaron: Even if I had a scanner, mine wouldn't likely be meaningful. I only really write for my own reading.
13:21:00 <puchacz> would you recommend learning Haskell to explore parser? how hard would Haskell be with my background?
13:21:08 <fax> puchachz
13:21:11 <puchacz> sorry, to explore parsec
13:21:16 <Baughn> amaron: Hopefully, by the time I need to show someone /else/, I'll have something that doesn't change notation every month
13:21:39 <jfredett> puchacz: Haskell is hard, period, but its really fun too. as long as you understand your basic functional programming stuff
13:21:42 <jfredett> you should be fine
13:21:43 <ddarius> puchacz: If you are just interested in parsing, you should be able to explore that well enough in any language or even independently from a programming language.
13:21:44 <fax> I used parsec to write a logo interpreter without any experience with haskell, it was really easy to use and I df. recommend it
13:21:50 <jfredett> but don't expect to learn it in one day
13:21:53 <puchacz> fax: good to see another guy from our usual #lisp channel
13:22:21 <fax> puchachz: yeah, I have been learning some basics :)
13:22:35 <fax> instead of skipping it all like I did before
13:22:35 <puchacz> what makes parsec so enjoyable for people that mastered it?
13:22:39 <amaron> Baughn: It would be nice, since I never saw application design in algebra before. Guess it would be nice to learn something like that since im starting with haskell.
13:23:10 <puchacz> I guess it must be different to usual parser generator programs used for C or Java.
13:23:13 <jfredett> puchacz: The real trick to haskell is that theres alot more math involved than in most languages. Which throws alot of people for a loop when they start learning (it certainly threw me a curver or too)
13:23:17 <fax> I never mastered it.. but I can say it was fun because its a cool DSL to use inside haskell
13:23:19 <ddarius> puchacz: It's pretty close to the notation you'd normally use while still being very flexible.
13:23:30 <fax> (which I think [DSLs] are a big part of haskell, so its interesting from that POV)
13:23:33 <ddarius> puchacz: It's not a parser generator.
13:23:46 <jfredett> Parsec is cool, I've been working on a parser for MIDI, but it sucks :/
13:24:04 <ddarius> jfredett: You can learn Haskell fine without any mathematical sophistication.
13:24:04 <jfredett> though, thats not parsecs fault, but rather my own
13:24:14 <jfredett> ddarius: certainly, but its just not the same w/o it
13:24:17 <ddarius> jfredett: I wrote a midi parser in C++.
13:24:49 <fax> @karma C
13:24:50 <Baughnie> Unknown command, try @list
13:24:52 <fax> :[
13:25:05 <ddarius> jfredett: If you actually need such a thing it parses to a textual notation that should be easy enough to work with.
13:25:14 <ddarius> (and of course there is a converter back to midi)
13:25:25 <puchacz> Has Haskell got an equivalent of Slime for Lisp, i.e. interactive "command line" aka REPL + integrated editor?
13:25:36 <fax> puchachz: ghci is like a REPL
13:25:47 <fax> and theres an emacs mode you can use but I haven't tried that yet..
13:25:48 <ddarius> GHCi is a REPL
13:26:13 <fax> ddarius: its more like a RTypecheckEPL :p
13:26:20 <Baughn> puchacz: Not nearly as sophisticated, no. Better than most, but slime is one of a kind.
13:26:43 <puchacz> so no jumping / navigation through source code, is there?
13:26:57 <Baughn> Well, theoretically there is. It just doesn't work.
13:26:58 <puchacz> like go-to-definition, who-calls?
13:27:01 <nopcode> what's the name of that searching algorithm that degenerates to breadth-first or depthf-rist search, depending on cost-function?
13:27:03 <ddarius> puchacz: You can do that easily enough in vim or emacs.
13:27:11 <jfredett> well, my goal was to write my old Computer-composer in pure Haskell
13:27:18 <ddarius> There are relatively well-developed modes for each.
13:27:26 <Baughn> nopcode: quicksort?
13:27:38 <Baughn> nopcode: Wait, "cost-function"?
13:27:43 <ddarius> Baughn: Search
13:27:48 <nopcode> Baughn: nah, i mean a tree-search
13:27:48 <hpaste>  fmardini pasted "soe problems" at http://hpaste.org/1841
13:27:52 <fax> nopcode: maybe beam search
13:28:03 <fmardini> hello,
13:28:05 <nopcode> it is something like a* i think
13:28:06 <fax> set bean from 1, or infinity
13:28:08 <jfredett> fmardini: hiya
13:28:18 <fmardini>  i just can't seem to rum the simplest example from soe
13:28:21 <fmardini> :(
13:28:34 <fax> nopcode: there is an example of it in PAIP.. the code is online [but it is lisp]
13:28:38 <fmardini> please could anyone tell me what is going on
13:28:53 <puchacz> fax: how long did it take you to start writing any useful code in Haskell? a week, month or half a year?
13:29:02 <puchacz> (given your lisp background)
13:29:34 <fax> puchacz: I just started to write immediatly and come up with a working program [logo] in a week
13:29:44 <fax> I got pissed off because its too easy to write a real program in haskell
13:29:53 <jfredett> puchacz: I started w/ CL as my first language. (I was 10-12 or so) It took me about 2 weeks to become relatively productive in haskell
13:30:08 <puchacz> cool, I will have a look then :-)
13:30:14 <jfredett> but I had used VB for 6 years, so my brain required some repair
13:30:29 * jfredett shudders
13:30:40 <fax> VB exclusively for 6 years?
13:30:43 <Baughn> puchacz: The haskell compiler helps a /lot/. As a result, it is easy to write working programs without really understanding the language..
13:30:49 <jfredett> fax, pretty much
13:30:54 <fax> omg :[
13:31:02 <jfredett> some CL in between, for sanitys sake
13:31:10 <jfredett> but basicly, yah, VB 6.0
13:31:11 <fax> VB sucked away all your intrest in programing?
13:31:16 <kilimanjaro> Baughn, have you ever tried writing working programs without understanding the language?
13:31:19 <Baughn> puchacz: Productivity is a different matter, and just keeps going up. Forever, as far as I can tell.
13:31:33 <jfredett> fax Well, in imperative programming, yah,
13:31:39 <nopcode> ah
13:31:40 <ddarius> kilimanjaro: Not only have I tried, I've done it with python.
13:31:41 <Baughn> kilimanjaro: Yes. With haskell. It worked, although fixing type errors by permutation is not something I'd normally suggest.
13:31:44 <fax> right
13:31:49 <nopcode> what i was looking for is called "best-first search"
13:31:59 <fax> yeah, I agree w/ Baughn very much on this
13:32:01 <fax> hehe
13:32:03 <jfredett> fax the only imperative langs I can still touch are Java and Python
13:32:28 <jfredett> and even those are getting painful (esp w/ the new python not having many of the cool bits)
13:32:35 <fax> jfredett: I gotta use C (and derivatives) just for the libraries
13:32:40 <fax> sucks :p
13:32:46 <jfredett> though Java's gonna have closures, :)
13:33:00 <ddarius> It only took, what 13 years?
13:33:04 <jfredett> I use C on occasion, but I have to take a shower after an hour
13:33:06 <puchacz> oki, I feel encouraged. btw, doing Java for 5 yrs or so in Eclipse and IntelliJ did some damage, too.
13:33:08 <fax> java has Classes.... why does it need closures?
13:33:14 <kilimanjaro> I can barely write Haskell and I happen to think I understand the language reasonably. I end up spending tons of time thinking about the merits of different approaches
13:33:22 <jfredett> fax because closures are more awesome
13:33:33 <Baughn> jfredett: Does this mean java will finally get functions?
13:33:44 <jfredett> Baughn I hope so. :)
13:33:48 <fax> I don't get it :S
13:34:04 <fax> it must be really hard to add closures to java... why don't they add type inference first
13:34:06 <Baughn> fax: Typing "class Foo implements Function" gets old after a while
13:34:10 <jfredett> fax, we don't require understanding, just blind submission to me.
13:34:11 <EvilTerran> kilimanjaro, some languages're impossible to understand, and yet remarkably popular (see: perl)
13:34:31 <fax> Baughn: typing Closure Foo will get old .. maybe not so soon though :p
13:34:36 <jfredett> perl makes me happy, actually
13:34:47 <jfredett> I rather enjoy it and other "drug" languages
13:34:51 <EvilTerran> I love perl, too. great for Getting Things Done.
13:34:53 <Baughn> fax: My Java code makes grown men cry. It also requires a preprocessor.
13:34:55 <jfredett> perl is like crack to me.
13:35:00 <EvilTerran> but it'd rot your brain if you use it too long.
13:35:15 <jfredett> brainfuck is my speed, befunge is my weed.
13:35:20 <amaron> I used perl alot then switched to python
13:35:21 <jfredett> its good. :)
13:35:30 <fax> Baughn: ooh I've seen a couple neat preprocessors for java, what kind of stuff do you have?
13:35:39 <amaron> now on my work I'm forced to use c#
13:35:39 <jfredett> I don't like python all that much
13:35:47 <jfredett> amaron: I'm sorry,
13:35:48 <Baughn> fax: Homegrown lisp-type thingy
13:35:49 <kilimanjaro> Yea there are a ton of languages in which you can do good work, I think the argument for using Haskell is that it makes the programmers job easier (and if you don't agree with this, you shouldnt bother using it)
13:35:57 <fax> amaron: c# has GC.. how can you complain!
13:36:16 <amaron> fax: lol :)
13:36:23 <Baughn> fax: It actually produces legible Java, but it also makes "class Foo implements Function" quick to write. So it's /very verbose/ java.
13:36:30 * ddarius has always hated perl
13:36:31 <kilimanjaro> i think a lot of people learn haskell just because they see smart people using it. that's what sold me
13:36:38 <fax> Baughn: Î´_Î´.. hehe sounds interesting, did you write it or is it online somewhere?
13:36:40 <EvilTerran> as yet, i find haskell harder to do /useful/ things in quickly, but i find it easier to do /difficult/ things
13:36:43 <ddarius> C# is not that bad.
13:36:45 <kilimanjaro> (that and it seems to be popular as notation in papers)
13:37:06 <amaron> ddarius: it solves problems, and its good as oo language
13:37:07 <ddarius> You can write cleaner and shorter code in Haskell than perl!
13:37:22 <jfredett> ddarius: but the point of perl is not cleanliness
13:37:24 <ddarius> amaron: It has a decent amount of FP features and is only getting more.
13:37:25 <EvilTerran> ddarius, yes, but can it do the same things?
13:37:29 <fax> ddarius: you can write cleaner and shorter code in APL than haskell ;)
13:37:34 <ddarius> EvilTerran: And then some.
13:37:37 <jfredett> ddarius: I think the point of perl is the exact opposite
13:37:51 <EvilTerran> ah, APL... i've been meaning to learn that one, if just for the mental exercise.
13:37:55 <Baughn> fax: I found it at cliki, once upon a time, but I don't think it's around anymore
13:37:56 <ddarius> fax: Cleaner even by non-Haskell programmer standards.
13:38:08 <jfredett> EvilTerran: Learn J, its APL w/o the weird font stuff.
13:38:15 <fax> EvilTerran: I would probably recommend learning J but reading about APL in parralel
13:38:21 <Baughn> fax: Oh, it is. http://www.evaluator.pt/linj.html
13:38:29 <fax> cheers Baughn
13:38:32 <amaron> but after years of being comercial programmer, I didn't learn anything new
13:38:42 <nopcode> how do i find an element of a list that has the maximum value for a given function?
13:38:45 <fax> Ahhh! linj
13:38:47 <fax> yes, :D
13:38:50 <ddarius> maximumBy
13:38:50 <kilimanjaro> the goal is to pick a language and ride it out to retirement!
13:39:12 <EvilTerran> perl is built to be quick and dirty. features arrived because they were considered generally useful for getting things done damn quickly. makes it God Damn Ugly, but terse at doing a lot of common stuff
13:39:17 <nopcode> ddarius: ah ok
13:39:18 <amaron> kilimanjaro: I would kill my self before I stuck with one language
13:39:47 <paolino_> how do I count unfoldr steps ?
13:39:58 <Baughn> kilimanjaro: What? Stop learning?
13:40:18 <Baughn> paolino_: In very strange ways. There was a paper online somewhere, I think..
13:40:20 <EvilTerran> paolino_, what do you mean?
13:40:24 <Liskni_si> it's not maximumBy
13:40:26 <amaron> I'm getting bored using c# and other oo lanugages, so I took the chalenge to learn haskell
13:41:16 <amaron> EvilTerran: perl is good for smaller programs, but after I had to read my own code again...
13:41:31 <vincenz> @paste
13:41:32 <Baughnie> Haskell pastebin: http://hpaste.org/new
13:41:32 <EvilTerran> yes, quite. if i can't write it as a one-liner, i generally don't do it in perl.
13:41:44 <hpaste>  vincenz pasted "custom monad" at http://hpaste.org/1842
13:42:00 <fax> perl is fantastic for munging text around in your bare hands
13:42:01 * ddarius with his toLazyByteString function, shamelessly steals basic functionality.
13:42:03 <amaron> EvilTerran: python has same power and much cleaner sintax
13:42:11 <fax> I never found anything better
13:42:22 * amaron went to make a coffee
13:42:27 <Liskni_si> nopcode: rather something like maximumBy (comparing f)
13:42:39 <fax> you can really crunch HTML and XML in lisp but its different
13:42:47 <ddarius> There are actually two maximumBys
13:42:48 <EvilTerran> but i challenge anyone to write "perl -lpe 's/^/$..\t/'" shorter in anything other than perl
13:42:51 <ddarius> @hoogle maximumBy
13:42:52 <Baughnie> List.maximumBy :: (a -> a -> a) -> [a] -> a
13:42:52 <Baughnie> Data.List.maximumBy :: (a -> a -> Ordering) -> [a] -> a
13:43:03 <Heffalump> am I allowed to first implement my own language?
13:43:05 <paolino_> EvilTerran: unfoldr produces a list, I want to get its length along
13:43:13 <EvilTerran> wait, skip that -l, it should be -pe...
13:43:15 <ddarius> EvilTerran: sed
13:43:19 <Heffalump> (what does it do?)
13:43:22 <Liskni_si> ddarius: what does the first one do? it's certainly not (a->b)->...
13:43:24 <EvilTerran> ddarius, point. okay. =/
13:43:39 <ddarius> maximum = maximumBy max
13:43:49 <Heffalump> does it just insert $.. and a tab at the start of each line, or is the $.. something magic?
13:43:55 <fax> lien numbers
13:44:05 <EvilTerran> Heffalump, it reads from STDIN, adds the line number and ".\t" to the start of each line, and dumps to STDOUT
13:44:17 <Heffalump> ah, right
13:44:17 <EvilTerran> $. is the line number. obviously. =P
13:44:28 <nopcode> ddarius: i used sort
13:44:38 <nopcode> let best:rest = (sortBy (sortCompare value) nodes)
13:44:51 <Heffalump> the Haskell interact . zipWith equivalent would be quite short, and much more readable/beautiful
13:44:59 <EvilTerran> as ddarius said, sed'd be shorter. i think perl took quite a lot of ideas from sed.
13:45:02 <nopcode> because i later need that element "replaced"... (expand best) ++ rest
13:45:14 <ddarius> For some sorts, head . sort is an (asymptotically) efficient max/min.
13:45:25 <Heffalump> perl started out in design as sed+awk with some extra stuff from C, AIUI
13:45:36 <EvilTerran> Heffalump, readability is in the eye of the beholder. beauty even more so.
13:45:37 <nopcode> ddarius: for linear ones ;)
13:45:52 <ddarius> nopcode:
13:45:53 <ddarius> ?
13:45:56 <Heffalump> yes, but I have taste and people who think the perl is more readable/beautiful don't. :-p
13:46:06 <Baughn> paolino_: Try http://en.wikibooks.org/wiki/Haskell/List_processing#Folds
13:46:09 <fax> show it shorter in sed
13:46:10 <nopcode> ddarius: well you can only consider it efficnet for O(n) sorts
13:46:20 <fax> sed = file.txt
13:46:32 <fax> prints a line number and then a new line
13:46:34 <fax> alllmost :)
13:46:43 <Heffalump> nopcode: no, cos of laziness
13:46:47 <ddarius> nopcode: No, through the magic of laziness it works out.
13:47:01 <nopcode> souns like a job for awk, prepending linu numbers
13:47:11 <nopcode> Heffalump, ddarius: oh :)
13:47:36 <nopcode> well i guess i've got best-first search now
13:47:37 <ddarius> nopcode: E.g. bubblesort would work out perfectly.
13:47:38 <Liskni_si> how can you find the smallest element of list without looking at all elements?
13:47:39 <nopcode> that was easy.. :D
13:47:49 <nopcode> Liskni_si: you cant
13:48:12 <fax> Liskni_si: do you have any more informmation about the list?
13:48:26 <byorgey> Liskni_si: you could guess and hope you're lucky =)
13:48:37 <Liskni_si> fax: i don't know, just trying to understand why head.sort may be faster
13:48:50 <EvilTerran> not faster, just no slower
13:49:04 <ddarius> fax: It's still linear, it's just not O(n log n) or O(n^2) even if the sort is.
13:49:14 <ddarius> Er Liskni_si
13:49:27 <Liskni_si> ah
13:49:29 <ddarius> Partially "sorting" a list can be done in linear time.
13:50:02 <Liskni_si> so this "efficient" means "as efficient as", right?
13:50:11 <nopcode> yeah you can basically ignore the right children in quicksort
13:50:14 <nopcode> if you need head only
13:50:27 <vincenz> or simply do
13:50:31 <vincenz> > maximum [1..10]
13:50:32 <Baughnie>  10
13:50:40 <ddarius> Efficient as minimum, but more efficient than that code would be in a strict language.
13:50:44 <vincenz> > maximum [1..10]
13:50:45 <Baughnie>  10
13:50:46 <alar> @bot
13:50:47 <Baughnie> :)
13:50:49 * vincenz peers at Baughnie 
13:51:02 <alar> @hoogle assert
13:51:02 <Baughnie> Control.Exception.assert :: Bool -> a -> a
13:51:03 <Baughnie> Test.HUnit.Base.assert :: Assertable t => t -> Assertion
13:51:03 <Baughnie> Control.Exception.assertions :: Exception -> Maybe String
13:51:26 <mrd> selecting the "ith" elt of a list can be done in linear time
13:51:43 <EvilTerran> here's some sed tricks: http://www.eng.cam.ac.uk/help/tpl/unix/sed.html
13:51:43 <oasisbot> Title: Handy one-liners for SED
13:52:04 <nopcode> are there priority queues in ghc?
13:52:06 <EvilTerran> but the "append a number to the start of each line" one uses shell as well, so is cheating ;]
13:52:18 <mrd> nopcode: i generally use Sets for that
13:52:20 <ddarius> nopcode: Kind of, but not really.
13:52:27 <EvilTerran> nopcode, this is to do with an earlier topic of conversation...
13:52:28 <mrd> @hoogle minView
13:52:28 <Baughnie> No matches found
13:52:28 <oasisbot> No matches found
13:52:32 <paolino_> mmh , can someone try to write a function to buid number palindroms : pal 345 -> 345543 without passing to characters ?
13:52:47 <mrd> @index Data.Set
13:52:48 <oasisbot> bzzt
13:52:48 <Baughnie> bzzt
13:52:55 <vincenz> @bot
13:52:56 <oasisbot> :)
13:52:56 <Baughnie> :)
13:52:59 * vincenz patpats
13:53:06 <mrd> where is our wonderful lambdabot :(
13:53:19 <Spark> 123 -> 123123 is quite easy
13:53:21 <mrd> these inferior replicas are no match
13:53:22 <oasisbot> You don't like me? :(
13:53:23 <Spark> but 123 -> 123321 i can't do
13:53:29 <vincenz> mrd: oasisbot is more complete than lambdabot
13:53:36 <vincenz> mrd: it has, for instance darcspatchwatch :)
13:53:46 <mrd> oh yea? how come it doesn't know about Data.Set then :P
13:54:02 <vincenz> it's too trivial for it (:
13:54:22 <paolino_> Spark: let me see 123 -> 123123 please
13:54:29 <mrd> bleh, lets get some bots without PhDs
13:54:43 <EvilTerran> paolino_, repeated multiplication/division by 10 are in order, methinks
13:54:44 <ddarius> @src Monoid
13:54:44 <oasisbot> class Monoid a where
13:54:44 <oasisbot>     mempty  :: a
13:54:44 <oasisbot>     mappend :: a -> a -> a
13:54:44 <oasisbot>     mconcat :: [a] -> a
13:54:44 <Baughnie> class Monoid a where
13:54:44 <Baughnie>     mempty  :: a
13:54:44 <Baughnie>     mappend :: a -> a -> a
13:54:44 <Baughnie>     mconcat :: [a] -> a
13:54:46 <Baughn> @leave #haskell
13:54:47 <oasisbot> Not enough privileges
13:54:52 <EvilTerran> ha
13:55:04 * Baughn goes to sleep
13:55:33 <Spark> paolino_: multiply it by 10^ceil(log10(123)) and add on the original value
13:56:17 <paolino_> mmhh floating point
13:57:10 <Spark> you can calculate ceil of log10 without going to floating point, just keep dividing by 10 until you hit 0
13:57:14 <Baughn> > let f n = n + n * 10^(length (show n)) in f 123
13:57:16 <oasisbot>  123123
13:57:29 <fax> palen f = read ((show f) ++ (reverse (show f)))
13:57:31 <Spark> you're not supposed to use strings
13:57:33 <Spark> or chars
13:57:35 <Spark> or things like that
13:57:37 <fax> who sais?
13:57:43 <paolino_> right
13:57:44 <Spark> he did
13:58:03 <fax> paolino_: You are doing it the wrong way
13:58:03 <Baughn> Code reuse is good, yes?
13:58:47 <Spark> code reuse isn't really relevant to brainteasers
13:58:59 <slava> brain teasers aren't very relevant to anything :)
13:59:06 <Spark> indeed
13:59:27 <Spark> i'm not sure how you can reverse arithmetically though, getting the length with log was cheating anyway
13:59:40 <fax> divie by 10
13:59:40 <fax> make a list of digits
13:59:47 <ddarius> Now with my stolen Eq instances, I can start writing quickchecks.
13:59:48 <Spark> at the end of the day you're going to have to deal with it on a per digit basis
13:59:55 <paolino_> with unfoldr ?
14:00:09 <ddarius> @source Data.ByteString
14:00:09 <oasisbot> Data.ByteString not available
14:02:00 <patrick22> hello.... anyone has experience with functional graphical programming?
14:04:23 <patrick22> or, anyone has experience with visualization of functions?
14:05:43 <paolino_> shame unfoldr doesn't thread a user state
14:05:49 <nopcode> digits 0 = []
14:05:49 <nopcode> digits n = (digits (n `div` 10)) ++ [n `mod` 10]
14:06:05 <nopcode> there you go
14:06:12 <nopcode> *Main> digits 12345
14:06:12 <nopcode> [1,2,3,4,5]
14:06:35 <xerox> ?type mapAccumL
14:06:36 <oasisbot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
14:06:38 <xerox> paolino_:
14:06:44 <fax> how to go from digits to a number?
14:06:44 <wli> On chapter 7 of YAHT now.
14:07:01 <wli> fax: foldr
14:07:21 <xerox> >read "12"
14:07:25 <xerox> well.
14:07:42 <wli> fax: Sorry, foldl
14:07:44 <byorgey> > foldl' (\x y -> 10*x + y) 0 [1,2,3,4,5]
14:07:44 <oasisbot>  12345
14:08:13 <fax> what is the ' for in foldl'?
14:08:17 <nominolo> is there an aborting fold?
14:08:20 <wli> fax: Strictness.
14:08:21 <byorgey> fax: strict version of foldl
14:08:21 <EvilTerran> ?djinn (a,b) -> (b,a)
14:08:21 <oasisbot> f (a, b) = (b, a)
14:08:23 <nominolo> fax: strict
14:08:28 <fax> :D
14:08:35 <EvilTerran> ?pl \(a,b) -> (b,a)
14:08:35 <byorgey> @quote stereo
14:08:36 <oasisbot> uncurry (flip (,))
14:08:36 <oasisbot> No quotes match. My pet ferret can type better than you!
14:08:37 <fax> thanks you 3
14:08:45 <fax> hehe
14:09:44 <nominolo> @pl (\x _ -> succ x)
14:09:45 <oasisbot> const . succ
14:10:38 <wli> \n -> if n == 0 then [0] else reverse . Data.List.unfoldr (\n -> if n == 0 then Nothing else let (q, r) = n `divMod` 10 in Just (r, q)) $ n
14:10:46 <EvilTerran> > let digits = unfoldr $ uncurry (>>) . (guard . (0/=) &&& return . (uncurry $ flip (,)) . flip divMod 10); foo = uncurry (++) . (reverse . digits &&& digits) in foo 123
14:10:47 <oasisbot>  [1,2,3,3,2,1]
14:12:34 <glguy> good morning
14:12:40 <fax> hi glguy
14:12:44 <byorgey> morning glguy
14:13:18 <amaron> good evening
14:13:59 <pjd> ...Ordering is a Monoid instance?
14:14:51 <glguy> Eq is identity
14:15:09 <glguy> and otherwise it takes the first, leftmost non-eq value
14:15:19 <glguy> this lets you order things that have mutliple components easily
14:16:25 <glguy> mappend EQ a = a; mappend a _ = a
14:16:49 <glguy> when did lambdabot go down?
14:17:06 <pjd> odd
14:17:11 <pjd> but nifty
14:17:28 <fax> glguy: yeah
14:18:05 <paolino_> wli, that is also mine solution :)
14:18:45 --- mode: ChanServ set +nt
14:19:16 <paolino_> I was hoping to produce the palindrome while reading the number
14:19:59 <glguy> pjd: You suggested that the Monoid instance for Ordering was odd (maybe :) ) but consider how ordering works on a list
14:20:37 <glguy> compareList (x:xs) (y:ys) = mappend (compare x y) (compareList xs ys)
14:21:40 <pjd> compareList = mappend $ zipWith compare ?
14:21:48 <glguy> :t compareList xs ys = mconcat $ zipWith compare xs ys
14:21:49 <oasisbot> parse error on input `='
14:21:58 <glguy> :t let compareList xs ys = mconcat $ zipWith compare xs ys in compareList
14:21:59 <oasisbot> forall a. (Ord a) => [a] -> [a] -> Ordering
14:22:15 <glguy> that doesn't work for lists of different sizes though
14:22:18 <glguy> but the idea is there
14:22:57 <glguy> > zipWith compare "Haskell" "Hampton"
14:22:59 <oasisbot>  [EQ,EQ,GT,LT,LT,LT,LT]
14:23:04 <glguy> > mconcat $ zipWith compare "Haskell" "Hampton"
14:23:05 <oasisbot>  GT
14:23:24 <pjd> right, s/mappend/mconcat/, obviously
14:23:46 <glguy> I'm not suggesting you didn't understand so much as illustrating it for anyone else that might not
14:24:38 <br1> Where are the type classes in C++'s template metaprogramming?
14:25:24 <Korollary> Not in the type system. They're conceptual. If you look at STL documentation for instance, you'll see "A model of this and that" kinda language.
14:25:55 <br1> ah, ok.  It's not compile time as they say in the mailing list
14:26:13 <Korollary> Well, the compilation does fail while instantiating it
14:26:27 <Korollary> I mean may fail
14:27:07 <pjd> glguy: i think that comment reflects my general experience with Haskell
14:27:31 <glguy> oh?
14:27:32 <br1> Korollary: But 'it has a small pattern-matching pure-functional language with type classes built in that only runs at compile time' is wrong.
14:27:45 <slava> glguy: i pushed a patch which unrolls the partial redraw optimization. it should work now
14:27:46 <pjd> a strange blend of uneasy confusion and exhilarating insight :)
14:27:59 <glguy> heh
14:28:06 <glguy> slava: I'll give it a go
14:28:12 <slava> glguy: i'll steal my girlfriend's windows laptop later this week to fix it properly
14:28:13 <ihope> @type mconcat
14:28:15 <oasisbot> forall a. (Monoid a) => [a] -> a
14:28:19 <slava> glguy: because i managed to reproduce it there
14:28:23 <glguy> slava: do you want me to test on both windows and linux? or do you know it fixes linux
14:28:24 <Korollary> br1: right. Type classes are not built in. They're coming in the next version under the name Concepts (and more).
14:28:28 <slava> glguy: but the problem on dbian linux is gone for me
14:28:34 <slava> glguy: test on linux too
14:28:42 <glguy> kk
14:28:48 <glguy> do I need a new bootstrap image?
14:29:09 <slava> no
14:29:19 <slava> actually, maybe, i don't remember if i changed code in core/ or not.
14:29:48 <glguy> just to "reload-core" or osmething maybe?
14:30:30 <slava> no, bootstrap again
14:30:58 <glguy> kk
14:31:37 <glguy> I've been missing factor, it fills my dynamic programming with macros void
14:32:24 <glguy> in a language that doesn't feel like it was an accident
14:32:58 <slava> well, it was an accident
14:33:36 <ddarius> As long as it doesn't feel like it.
14:33:39 <glguy> well, congrats on giving the opposite impresion :)
14:33:41 <ddarius> Maybe I should check out factor.
14:33:47 <banbh> hi.  i'm having trouble compiling hs-plugins.  I downloaded plugins-1.0 from hackage and built it with ghc 6.6 on OSX.  I get "src/AltData/Typeable.hs:452:0:
14:33:47 <banbh>     parse error (possibly incorrect indentation)"
14:33:56 <banbh> any ideas?
14:34:29 <Korollary> banbh: That's odd. Are there any CPP #ifdefs around?
14:34:34 <glguy> slava: I'm almost done with linux, when I do windows I'll still need to -exclude=io ?
14:34:43 <slava> yeah
14:34:46 * ddarius has made a darcs repo for his Rope code.
14:34:48 <slava> the windows io guy is in europe :)
14:35:01 <banbh> Korollary: yes, lemme find some of them ...
14:35:05 <glguy> ddarius: you should request an account on code.haskell.org
14:35:16 <glguy> ddarius: if you want to eventually release it to the community
14:36:02 <glguy> slava: works on my linux
14:36:27 <banbh> Korollary: there is just "#if __GLASGOW_HASKELL__ >= 603"
14:36:57 <banbh> Korollary: at least in Typeable.hs
14:38:03 <ddarius> glguy: Perhaps I will.
14:38:27 <ddarius> I was intending on releasing it if it was good enough.
14:38:43 <glguy> best way I've found to get something release ready is to let people help you :)
14:39:29 <ddarius> glguy: All I have to do is make a smart concat and then it should be worthy of the name Rope.  It's usable right now.
14:39:40 <glguy> cool
14:39:53 <glguy> do you need me to find the form that you request an account with?
14:40:29 <ddarius> glguy: I guess since I have no idea how to go about it.
14:41:02 <glguy> http://community.haskell.org/admin/account_request.html
14:41:02 <glguy> and
14:41:03 <oasisbot> Title: Account Request
14:41:14 <glguy> http://community.haskell.org/admin/project_request.html
14:41:14 <oasisbot> Title: Project Request
14:41:45 <glguy> since you are requesting an account to create a project, you can just use that as your "reason"
14:44:07 <ddarius> glguy: Thanks.
14:46:54 <patrick22> what are the advantages of algebraic datatypes?
14:47:57 <ddarius> patrick22: As compared to?
14:48:36 <sfultong> only string representations?
14:48:51 <glguy> slava: windows worked
14:49:02 <slava> glguy: thanks for testing
14:49:14 <glguy> slava: it seems slower than before
14:49:30 <patrick22> oh yes... sorry.... better version of the question: when would you use an algebraic datatype? I only understand a bit of imperative programming, i.e. using structs in certain cases....
14:49:30 <slava> that's because it repaints the entire window every time a gadget changes
14:49:31 <glguy> slava: I don't know if you've added features since 0.87 or so that might have caused that
14:49:34 <glguy> ok
14:49:43 <slava> i'll fix it later
14:49:48 <glguy> np
14:50:49 * glguy tends to see algebraic data types as a convenient way to not need to use typeclasses all the time
14:51:00 <ddarius> patrick22: Algebraic data types include structs, but they are very common, you just don't notice it as much in imperative languages.
14:51:28 <ddarius> patrick22: In imperative languages you tend to "encode" that kind of structure (which is a pain).
14:53:22 <glguy> algebraic data types are used when you have some fixed set of implementations of a data type, and expect to need to define more functions on that type later
14:53:44 <glguy> where type classes let you define a fixed set of functions with the ability to include additional constructors later
14:54:00 <banbh> Digging a little into my problem compiling hs-plugins, I see that it seems to want to load Typeable.h (which didn't come with the plugins tarball) and perhaps it defines a macro called INSTANCE_TYPEABLE1
14:54:29 <banbh> Should the tarball have included Typeable.h or is that in base?
14:55:33 <glguy> banbh: the person that knows the answer (among others) is on Austrailian time
14:55:42 <glguy> and tends to come around in a few hours from now
14:56:11 <banbh> thx -- i'll try again then
14:56:23 <banbh> thank for the heads up
14:56:29 <glguy> banbh: dons is the author
14:57:03 <ndm> @seen dcoutts
14:57:03 <oasisbot> dcoutts is in #haskell. I don't know when dcoutts last spoke.
14:57:11 <dcoutts> hia ndm
14:57:12 <ndm> @seen dcoutts_
14:57:12 <oasisbot> dcoutts_ is in #haskell. I don't know when dcoutts_ last spoke.
14:57:18 <dcoutts> ndm: what was that about colours ?
14:57:26 <ndm> hi dcoutts - i'm donig some gtk2hs work
14:57:37 <ndm> forget that, i've hacked it through enough to skip that problem
14:57:52 <ndm> i'm making a list of problems to come back to and refine later, just aiming for something working basically
14:58:04 <dcoutts> ndm: you can parse strings like "red" into a GdkColour I think
14:58:04 <ndm> the problem i'm now on is showing a popup menu where i want it to appear
14:58:30 <ndm> menuPopup wants the location of an event, not the location i want to give it
14:58:44 <ndm> menuReposition hints that it moves the menu with teh position, but doesn't say how
14:59:15 <ndm> ah, i didn't check gdk, i'm not sure thats hoogle gtk searched
14:59:42 <ndm> dcoutts, so is there "setPosition :: Double -> Double -> Menu -> IO ()" or something
14:59:53 <AStorm> Haskell threading sounds... quite nice :-)
15:00:40 <ndm> i'm writing a graphical theorem prover using Gtk2hs, i've nearly got a demo working
15:00:52 <AStorm> I wonder if exceptions are really handled in an exceptional way - that is, they aren't masked by the thread not wanting to respond (in the middle of a large computation, for example)
15:00:53 <ndm> just have to prove a couple of theorems to test it out
15:00:56 <dcoutts> ndm: cool. I'm looking into it
15:01:34 <dcoutts> ndm: so in theory, by default it should popup at the current mouse position
15:01:53 <dcoutts> when you use menuPopup
15:03:57 <ndm> dcoutts, yes, and it does, but that isn't where i want it to
15:04:20 <ndm> the idea is the user clicks on the item they want to manipulate, and they select the action to perform
15:04:36 <ndm> if the menu pops up right over the item, it doesn't really work
15:04:50 <AStorm> Hmm, ghc is not really responding to CFLAGS, it uses them built in
15:04:52 <dcoutts> ndm: right.
15:06:29 <dcoutts> ndm: so the underlying C function takes a positioning function as an argument. We've not bound that at the moment (though I don't know why not).
15:06:46 <AStorm> Also, I wonder about another thing: what happens if a FFI function marked as functional "throws" an exception? (e.g. FPU state is invalid)
15:07:55 <ndm> dcoutts, do you have a todo list for Gtk2hs? if so, can i request that one gets added - although no rush
15:08:08 <ndm> just makes the UI quite clunky at the moment
15:10:16 <ddarius> AStorm: It presumably gets handled like all the other "asynchronous" exceptions.
15:10:25 <dcoutts> ndm: we do have a TODO and a trac, but currently our trac is suspended, so darcs send us a TODO item, and/or write the code yourself :-)
15:10:36 <AStorm> ddarius, really? I'd like to see that specified
15:10:45 <AStorm> so that it isn't blocked anywhere
15:10:49 <ndm> dcoutts, i'll set up a wiki page, and then darcs send you at the end
15:10:57 <AStorm> or, if it may be blocked, too
15:11:08 <AStorm> (I know about explicit mask/unmask functions)
15:14:22 <AStorm> Some of these exceptions sound like they're really needed in other languages
15:14:32 <AStorm> (e.g. Deadlock or BlockedInfinitely)
15:14:46 <AStorm> *BlockedIndefinitely
15:14:55 <wli> On chapter 9.
15:17:38 <AStorm> I wonder if the thread can swallow ThreadKilled exception
15:17:59 <AStorm> and if there's some lower-level kill command if it does so
15:18:26 <SamB> ndm: hmm, I have a few typeclasses that need a deriving...
15:18:35 <ndm> SamB, patches welcome :)
15:18:52 <SamB> ndm: I guess that answers the question then ;-)
15:18:53 <ndm> SamB, ones for public libraries? or just application specific
15:19:01 <SamB> they'd be public
15:19:07 <SamB> but I have no idea how used they'd be
15:19:22 <SamB> wli mentioned #1, #2, #3
15:19:51 <SamB> which access fields by number
15:19:59 <SamB> so I made some classes and a deriving
15:20:30 <ndm> as long as the class is in a library which can be downloaded from hackage, i'll accept any deriving at all
15:20:51 <SamB> okay then
15:21:03 <SamB> that should work nicely
15:21:05 <ndm> but feel free to submit the deriving first, if that suits you
15:22:26 <SamB> I'm not convinced you would notice
15:23:05 <ndm> would notice what?
15:23:15 <SamB> which order I did those two things in
15:23:21 <ndm> indeed, i probably wouldn't
15:23:50 <ndm> but i'd do the deriving first, so i could announce with deriving support in the initial email
15:24:11 <SamB> oh
15:24:15 <SamB> you announce these things?
15:24:25 <SamB> is that how you get people to use them?
15:24:27 <ndm> meh, depends how much work you put into it :)
15:24:34 <ndm> i tend to, yes
15:24:41 <ndm> upload to hackage, then announce to haskell@
15:24:58 <AStorm> So, does there exists a "kill thread forcibly" command? (may be GHC extension)
15:25:47 <ndm> @hoogle thread
15:25:47 <oasisbot> Data.Graph.Inductive.Internal.Thread :: module
15:25:47 <oasisbot> Data.Graph.Inductive.Internal.Thread.Thread :: type Thread t i r
15:25:47 <oasisbot> Control.Concurrent.threadDelay :: Int -> IO ()
15:25:51 <ndm> @hoogle kill
15:25:52 <oasisbot> Control.Concurrent.killThread :: ThreadId -> IO ()
15:25:52 <oasisbot> System.Console.Readline.killText :: Int -> Int -> IO ()
15:25:52 <oasisbot> Control.Exception.ThreadKilled :: AsyncException
15:26:00 <ddarius> @src Read
15:26:00 <oasisbot> class Read a where
15:26:01 <oasisbot>   readsPrec    :: Int -> ReadS a
15:26:01 <oasisbot>   readList     :: ReadS [a]
15:26:01 <oasisbot>   readPrec     :: ReadPrec a
15:26:01 <oasisbot>   readListPrec :: ReadPrec [a]
15:26:04 <ndm> AStorm: looks like killThread probably does it
15:26:15 <ddarius> @index Data
15:26:15 <oasisbot> Data.Generics.Basics, Data.Generics
15:26:15 <AStorm> ndm, no, it raises ThreadKilled
15:26:18 <ddarius> @index Typeable
15:26:18 <oasisbot> Data.Typeable, Data.Dynamic, Data.Generics.Basics, Data.Generics
15:26:23 <AStorm> ndm, this probably can be swallowed
15:27:05 <ddarius> AStorm: I don't think so, but check the documentation.
15:27:08 <ndm> killThread -9  ;-)
15:28:00 <AStorm> :-( Could use one for a more DoS proof program
15:28:11 <AStorm> Guess I'll have to fork
15:30:38 <desp> how can I get ghci to load two modules at once from the cmd line?
15:30:45 <desp> to avoid typing :m + Foo every time
15:31:30 <AStorm> tried a list of modules?
15:31:52 <desp> ghci [Main, Wrapper] ? nope
15:31:54 <desp> doesn't work
15:32:11 <AStorm> desp,
15:32:16 <AStorm> just separate by spaces
15:32:20 <AStorm> as the syntax shows :-)
15:32:22 <desp> yes, I tried that
15:32:24 <desp> :P
15:32:35 <desp> desp@nny:~/clfp/dna2rna-src$ ghci Main Wrapper
15:32:39 <desp> Ok, modules loaded: Wrapper, Main.
15:32:40 <desp> Prelude Main>
15:32:49 <desp> and I want
15:32:50 <desp> Prelude Main Wrapper>
15:33:10 <AStorm> uhm, use :m Main Wrapper
15:33:30 <desp> I'm asking how to do this from the command line
15:33:35 <desp> to avoid retyping :m + Wrapper every time
15:33:41 <desp> as I said above :)
15:34:35 <EvilTerran> "GHCi is invoked with the command ghci or ghc â€“â€“interactive. One or more modules or filenames can also be specified on the command line; this instructs GHCi to load the specified modules or filenames (and all the modules they depend on), just as if you had said :load modules at the GHCi prompt"
15:34:41 <EvilTerran> (from the manual)
15:35:16 <desp> c'mon, I pasted in the output from ghci
15:35:22 <desp> it does NOT open both modules
15:35:27 <desp> it just loads them
15:35:39 <Saizan> :m + Main Wrapper?
15:35:50 <desp> ...
15:35:58 <AStorm> desp, it loads them
15:36:03 <AStorm> but doesn't change the context
15:36:04 <desp> I'm asking how to do this from the command line, to avoid retyping :m + Wrapper every time
15:36:07 <AStorm> just as :load does
15:36:08 <ndm> it always annoys me, loading multiple modules in GHCi
15:36:22 <desp> and I feel that people aren't paying attention
15:36:23 <ndm> someone should figure out why it dosen't match expectation, and submit a concrete bug report
15:36:34 <desp> ndm: ah.
15:36:35 <ndm> i'd certainly vote for that
15:36:48 <EvilTerran> hm.
15:36:51 <ndm> but definately, it never does what i expect!
15:36:54 <EvilTerran> desp, is Main importing Wrapper?
15:37:02 <desp> yes
15:37:09 <desp> I guess I could reexport stuff from it
15:37:14 <EvilTerran> that'd work
15:37:31 <EvilTerran> module Main (module Main, module Wrapper) where import Wrapper; ...
15:37:54 <ndm> that would work, but if you invest some time to report the bug, everyone else will be saved those problems :)
15:38:03 <AStorm> I vote for reporting too
15:38:19 <desp> I will, after the contest is done
15:38:24 <ndm> hehe :)
15:38:28 <AStorm> Just add an option -module <onemodule>,<secondmodule>,...
15:38:28 * EvilTerran would "me too" on the bugrep, altho i'm too lazy to report it myself ;]
15:38:56 <AStorm> Which would work like :module
15:39:51 <ndm> no! :module onemodule twomodule threemodule should just do the right thing
15:40:03 <ndm> no need for extra "like :module but not broken" optios
15:40:37 <desp> right
15:41:35 <AStorm> ndm, uhm?
15:41:41 <AStorm> Will that work from the command line?
15:41:53 <AStorm> like: ghci :module Foo Bar Data.Baz
15:42:10 <AStorm> Or do you have to use a pipe?
15:43:00 <ndm> i meant from within ghci, i guess you can sort out the command line too
15:43:05 <ndm> but ghci is of more interest to me
15:43:32 <AStorm> ndm, the "from within ghci" case is not problematic
15:43:36 <ddarius> :m should be :m + and :m ! say should be :m
15:43:57 <ndm> i don't know all these :m + and :m ! stuff
15:44:10 <ndm> i just want to load several modules, with :m, and that just doesn't work
15:44:44 <ddarius> ?
15:45:02 <ndm> :m Data.Maybe Yhc.Core
15:45:06 <EvilTerran> desp, what about http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-dot-files.html ?
15:45:07 <oasisbot> Title: 3.8. The .ghci file, http://tinyurl.com/2935xp
15:45:21 <ndm> i want that to make it so i can hit isJust and fromCoreApp at the prompt
15:45:23 <desp> hm, nice
15:45:32 <desp> but I have it working for now,thanks
15:45:56 <EvilTerran> "echo ':m + Wrapper' > ./.ghci" would do the job, albeit a bit hackishly.
15:46:28 <ddarius> ndm: That seems to work just fine for me using List and Monad.
15:47:02 <Eelis> the ghc docs for Char state that it can hold any Unicode character. how would one actually go about putting something like the character Ã© in a Char ? when in ghci I do   print $ length $ "Ã©"  i just get 2
15:47:47 <EvilTerran> > length "\xE9"
15:47:49 <oasisbot>  1
15:48:29 <Eelis> EvilTerran: but printing "\xe9" does not show  Ã©
15:48:43 <glguy> ?read "\xe9"
15:48:43 <oasisbot>  é
15:48:59 <EvilTerran> Eelis, it should...
15:48:59 <ddarius> Eelis: Currently if you want to play with Unicode, you'll probably need a 3rd party library.
15:49:02 <glguy> it did
15:49:04 <AStorm> what happened to the lambdabot? :-)
15:49:09 <glguy> ?where utf8
15:49:09 <oasisbot> I know nothing about utf8.
15:49:09 <AStorm> Dons broke her?
15:49:12 <glguy> ?where utf8-string
15:49:12 <oasisbot> I know nothing about utf8-string.
15:49:14 <glguy> oh
15:49:16 <AStorm> ?where utf-8
15:49:16 <oasisbot> I know nothing about utf-8.
15:49:16 <Eelis> ddarius: i see :(
15:49:32 <glguy> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/utf8-string-0.1
15:49:33 <ddarius> Eelis: From what I hear, it's not that bad.
15:49:33 <oasisbot> http://tinyurl.com/3dzrdw
15:49:56 <glguy> utf8-string is a UTF-8 encoding/decoding and IO library
15:50:05 <AStorm> hmm, someone should really write encoding/decoding library for Haskell
15:50:08 <glguy> lol
15:50:13 <AStorm> much like Python's codec module
15:50:30 <glguy> someone else was working on a more general codec collection for bytestrings
15:50:39 <norpan> i think somebody already have done it, many times
15:50:44 <norpan> has
15:51:36 <norpan> wow, i clicked on the .hs file and it opened a terminal window with ghci and loaded the file
15:51:40 <AStorm> norpan, so give us a link :>
15:51:46 <Eelis> glguy: what does that ?read do, and how does it relate to my problem?
15:51:54 <glguy> Eelis: what is your problem?
15:52:17 <Eelis> glguy: that ghci can't seem to make up its mind about what Data.Char stores.
15:52:23 <norpan> AStorm: the line above yours was a link to one
15:52:35 <Eelis> when printing it's UTF8, but the docs say that each Char is a full Unicode character
15:52:36 <AStorm> Nope.
15:52:39 <glguy> Eelis: a Char is always a value from 0 to 0x10ffff
15:52:50 <AStorm> norpan, it's UTF-8 only
15:53:08 <norpan> AStorm: and UTF-8 is not an encoding?
15:53:16 <glguy> UTF-8 is an encoding
15:53:23 <ddarius> Eelis: A Char is always a Unicode character, the IO system doesn't care though.
15:53:30 <AStorm> norpan, it is one
15:53:42 <AStorm> But a full Codec library would support ISO-* too
15:53:42 <glguy> that library I gave you the link to handles UTF-8 encoded IO
15:53:57 <AStorm> Some tables, hehe
15:54:29 <AStorm> maybe the print and other IOs would take LC_ALL environment variable (or Windoze equivalent) into consideration
15:54:51 <AStorm> or just C locale
15:56:18 <dcoutts> AStorm: I'm nearly done with a bytestring iconv library that provides convert :: Charset -> Charset -> Lazy.ByteString -> Lazy.ByteString
15:56:34 <AStorm> dcoutts, sounds good, if I have iconv :>
15:56:48 <desp> how would you do 8-bit modular arithmetic in Haskell?
15:56:48 <dcoutts> if you're on unix you do
15:56:56 <desp> like using unsigned chars in C
15:56:58 <ddarius> @index Word8
15:56:59 <oasisbot> Data.Word, Foreign
15:56:59 <AStorm> iconv shouldn't be necessary - it's just the amount of tables required that's daunting
15:56:59 <dcoutts> desp: Word8 or Int8 ?
15:57:47 <dcoutts> AStorm: glibc has iconv and a large set of codeset converters
15:58:01 <AStorm> dcoutts, of course, that shouldn't prevent you from writing an iconv backend :-)
15:59:00 <AStorm> Also, please provide encode :: String -> Charset -> Lazy.ByteString -- taking Unicode
15:59:07 <AStorm> similar with decode
15:59:17 <AStorm> That'd be great.
16:00:01 <norpan> i would still like the encoding be built into the ByteString
16:00:07 <norpan> in some way
16:00:16 <AStorm> norpan, sounds evil and would tie it down to a platform
16:00:22 <norpan> huh?
16:00:23 <ddarius> norpan: That doesn't make sense.  Maybe for a separate type on byte strings.
16:00:25 <AStorm> Codec modules are the way to go
16:00:26 <dcoutts> nornagon: me too, Data.PackedString.UTF8
16:01:02 <AStorm> except PackedString is deprecated?
16:01:04 <norpan> efficient unicode strings would be gread
16:01:06 <norpan> great
16:01:18 <dcoutts> AStorm: not sure what you mean exactly? encode/decode? ByteStrings have no inherent string encoding
16:01:33 <AStorm> dcoutts, uhm, check the arg list I gave you
16:01:33 <norpan> UnicodeString
16:01:44 <AStorm> I was talking about String, not Lazy.ByteString
16:01:45 <AStorm> :-)
16:01:57 <dcoutts> AStorm: ah I see
16:02:20 <dcoutts> AStorm: current PackedString is deprecated because we're eventually expecting to replace it with a unicode bytestring style implementation
16:03:08 <AStorm> that would be great, yes
16:03:28 <dcoutts> it's just a matter of someone getting round to doing it
16:03:56 <dcoutts> since we'd also like it to be fusible using the same system as ByteString (and hopefully in the future lists too)
16:04:22 <dcoutts> I might eventually get round to it after polishing off the bytestring-1.0 package
16:04:40 <AStorm> :D
16:05:54 <ddarius> dcoutts: Is chunkSize or whatever exported anywhere?
16:06:23 <dcoutts> ddarius: not in the current version, it is in the new bytestring package (from a semi-public module)
16:06:40 <dcoutts> since it is useful for various bytestring-like extension packages
16:06:55 <dcoutts> I use it in the zlib, bzlib and iconv packages for one thing
16:08:03 <ddarius> I'm considering simply having the leaves of my ropes use that chunkSize for their maximum size
16:08:51 <ddarius> I admit that my main motivation right now is to be able to do concat . map Flat . toChunks
16:11:47 <Eelis> hm, if Char is supposed to be a Unicode character container, isn't it kind of inappropriate for things like readFile to return a [Char] when the file may not contain Unicode characters at all? or is readFile only supposed to be used for files consisting of Unicode characters?
16:12:54 <Saizan> you'd prefer [Word8] ?
16:13:05 <Eelis> that seems more correct, yes
16:13:10 <fax> I want [Word7]
16:13:19 <fax> seems more correct than word8 to me
16:13:38 <Saizan> why?
16:13:52 <EvilTerran> it's supposed to be a container for characters. in today's tech, yes, that means utf-8, but 20yr ago it could've meant ASCII (or extended ASCII), and it might change in the future
16:14:00 <Philippa> Eelis: show me a file that contains non-unicode characters...
16:14:03 <Philippa> (ti's a matter of encoding)
16:14:05 <Philippa> *it's
16:14:33 <EvilTerran> readFile is intended for text, not binary data, AFAICT
16:14:48 <AStorm> Philippa, still, readFile and guys could autoconvert from the current charset
16:14:55 <Eelis> Philippa: the point is that using Char for things that were never intended to be interpreted as Unicode characters is inappropriate
16:15:03 <AStorm> it's isn't really specified
16:15:16 <Philippa> Eelis: sure, and for binary IO that stinks
16:15:17 <EvilTerran> i don't think it says "thou shalt parse in UTF-8" or anything in the spec
16:15:26 <fax> Char was intended for Chars no?
16:15:27 <Philippa> for text IO, it doesn't matter a damn
16:15:35 <Philippa> unless, like I said, you have a non-unicode character to hand
16:15:36 <AStorm> fax, yes, and String is [Char]
16:15:45 <sjanssen> EvilTerran: the report says very little about specifics of encoding
16:15:52 <fax> makes sense to read a file into a string to me :S
16:16:00 <Philippa> that is, a character that doesn't have an assigned unicode codepoint - I don't care if it originated from an EBCDIC encoding
16:16:01 <AStorm> Philippa, uhm
16:16:04 <AStorm> It can be UTF-16
16:16:16 <AStorm> then you'll get Unicode numbers :P
16:16:30 <EvilTerran> if it doesn't see a BOM at the start of the file, 7-bit ASCII would probably be a sensible default
16:16:31 <wli> In order to do this I have to define my own list monad transformer and make appropriate instances of it. Hmm.
16:16:48 <wli> (YAHT Ex. 9.4)
16:16:53 <AStorm> EvilTerran, not really - I actually prefer system encoding to be the default
16:17:19 <EvilTerran> but in that case, allowing UTF-8 characters as well is harmless. and probably more likely to be right than any 8-bit encoding
16:17:42 <Eelis> i think the only appropriate result of readFile is [Word8], as it is the only type not to impose interpretation of the data.
16:17:45 <AStorm> Hmm, it may clash sometimes
16:17:59 <EvilTerran> defaulting to system encoding is all well and good, but it might cause things to break unexpectedly when running elsewhere
16:18:02 <AStorm> Eelis, it's for text, not binary data
16:18:21 <Eelis> AStorm: oh, is there a separate function for reading binary files?
16:18:27 <AStorm> EvilTerran, yes, that's why you'd want to use some setEncoding CharsetFoo
16:18:40 <wli> I'm not entirely sure how this results in anything getting printed.
16:19:11 <AStorm> Eelis, how would you print [Word8]?
16:19:18 <AStorm> as numbers, or letters?
16:19:21 <EvilTerran> http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html#21
16:19:22 <oasisbot> http://tinyurl.com/y9dfge
16:19:24 <desp> @type (!!)
16:19:25 <oasisbot> forall a. [a] -> Int -> a
16:19:36 <AStorm> That's why it should read in a ByteString or a String
16:19:42 <Eelis> AStorm: as numbers, obviously
16:19:50 <sjanssen> Eelis: what is wrong with imposing interpretation of the data?
16:19:57 <EvilTerran> (not sure how useful that is)
16:20:12 <AStorm> EvilTerran, quite useful indeed
16:20:15 <Eelis> sjanssen: only that the imposed interpretation may not correspond to how the file is supposed to be interpreted
16:20:19 <sjanssen> Eelis: every other language implementation examines the locale, and uses other heuristics to interpret files
16:20:24 * wli complains about problem specs.
16:20:24 <AStorm> this could skip any automaticconversions
16:20:51 <Eelis> sjanssen: erm, in C++ i can just open a file in binary mode and get raw bytes without any interpretation
16:20:54 <EvilTerran> hGetBuf etc looks to be relevant to your interests
16:21:05 <sjanssen> Eelis: yeah, Haskell needs this two
16:21:07 <EvilTerran> Eelis, see my link
16:21:08 <AStorm> Eelis, and you can do that in Haskell too
16:21:19 <sjanssen> Eelis: ideally, we have functions for both character based, and binary/byte based IO
16:21:20 <EvilTerran> "hGetBuf hdl buf count reads data from the handle hdl  into the buffer buf until either EOF is reached or count 8-bit bytes have been read. It returns the number of bytes actually read. This may be zero if EOF was reached before any data was read (or if count is zero)."
16:21:51 <AStorm> sjanssen, well, hGetBuf variant returning [Word8] would be nice
16:21:54 <AStorm> (lazy one)
16:21:56 <Eelis> ok, so at least i'm not crazy in noticing that how things currently are is not ideal :)
16:22:01 <sjanssen> AStorm: yeah, that's a good first start
16:22:15 <fax> Eelis: wjats the problem?
16:22:26 <Eelis> fax: read up, you were here
16:22:53 <EvilTerran> AStorm, (map toEnum . hGetBuf)?
16:23:03 <fax> Eelis: I have read
16:23:06 <AStorm> EvilTerran, would work, though it will read till EOF
16:23:14 <fax> Eelis: I don't understand why you -still- think its a problem
16:23:22 <fax> didn't you see the link?
16:23:23 <glguy> System.IO.readFile reads the bytes of a file
16:23:36 <glguy> maybe I need to read the backlog to see what you are trying to solve
16:23:46 <AStorm> glguy, it converts CRLF and LF
16:23:55 <AStorm> and also it returns Unicode
16:24:02 <glguy> AStorm: it doesn't "return Unicode"
16:24:08 <AStorm> [String], sorry?
16:24:11 <glguy> AStorm: it stores each byte in a Char
16:24:15 <glguy> it doesn't interpret them
16:24:16 <AStorm> Uhm, [Char]
16:24:21 <AStorm> glguy, it's not specified...
16:24:29 <AStorm> openBinaryFile, on the other hand...
16:24:52 <sjanssen> glguy: readFile isn't necessarily byte based (according to the report)
16:24:58 <EvilTerran> glguy, it returns the characters in the file, not the bytes in the file
16:25:18 <glguy> EvilTerran: I mean that multibyte characters are read as individual bytes
16:25:27 <sjanssen> glguy: GHC's implementation sucks, so it interprets each byte as a Unicode code point from 0-255
16:25:57 <glguy> sjanssen: it sucks because you want a [Word8] ?
16:25:59 <EvilTerran> readFile does, but other things don't? O.o
16:26:18 <sjanssen> glguy: it sucks because it should use the system's preferred encoding to interpret the file
16:26:26 <wli> Only 4 problems away from finishing YAHT and I'm biting on granite. Ugh.
16:27:00 <AStorm> wli, :-)
16:27:23 <sjanssen> glguy: it's wrong that we have to pass all of our IO through third party libraries
16:27:32 <AStorm> EvilTerran, hmm, some other things do such too
16:27:35 <sjanssen> glguy: or first party libs, in your case ;)
16:27:35 <EvilTerran> glguy, or, failing that, it should do something standard like UTF-8. byte-by-byte-ing is weird.
16:27:58 * glguy thinks that byte-by-byting is best as it lets you write a library that does what you want
16:28:01 <EvilTerran> altho i guess there is _some_ encoding which is like the first 256 characters of unicode
16:28:07 <glguy> there's no reason that that behavior needs to be primitive
16:28:07 <AStorm> glguy, that's openBinaryFile
16:28:09 <slava> EvilTerran: latin1
16:28:23 <AStorm> slava, nope
16:28:36 <AStorm> first 127 chars do match though
16:28:56 <mauke> yes.
16:28:59 <EvilTerran> does readFile break newlines under windows?
16:29:09 <mauke> latin1 == take 256 unicode
16:29:22 <AStorm> mauke, uhm, no
16:29:33 <glguy> latin1 uses 128-255 differently
16:29:45 <mauke> AStorm: yes
16:29:47 <sjanssen> glguy: IMO, the IO system is broken as long at getLine doesn't read stuff in my current encoding
16:30:03 <EvilTerran> INTERNET ARGUMENT
16:30:08 <AStorm> getLine should read the file in the IOs encoding, even better
16:30:21 <glguy> EvilTerran: lower case please :)
16:30:26 <AStorm> the encoding should be a property of the IO (because we can :P )
16:30:33 <mauke> CAPS LOCK IS CRUISE CONTROL FOR COOL
16:30:35 <sjanssen> glguy: we should provide Word8 libraries if the user *really* wants to do the encoding/decoding explicitly
16:30:39 <mauke> AStorm: full ack
16:31:18 <AStorm> something like hSetEncoding for IO String
16:31:50 <mauke> where do I get something like hGetBuf for Fds?
16:31:54 * wli is at a loss to define a list monad transformer.
16:32:09 <EvilTerran> mauke, even with cruise control, you still have to steer
16:32:26 <pjd> "The first 256 code points were made identical to the content of ISO 8859-1 so as to make it trivial to convert existing western text." --wp:Unicode
16:32:30 <fax> wli: sounds like a better task.. ill probably try it tommorow
16:32:51 <wli> fax: It's part of a problem in YAHT.
16:32:56 <fax> yeah
16:33:04 <mauke> @hoogle Fd -> Ptr a -> Int -> IO Int
16:33:05 <oasisbot> No matches, try a more general search
16:33:06 <fax> I was doing some yaht but got bore
16:33:11 <AStorm> pjd, hmmmm
16:33:19 <wli> fax: I'm almost done with YAHT.
16:33:21 <sfultong> I hate doing example problems
16:33:24 <AStorm> it's one-way street anyway
16:33:34 <AStorm> you can read latin-1, but not write it
16:33:36 <sfultong> probably why I learn so slow
16:33:45 <sfultong> either that, or I'm just... slow
16:33:46 * glguy notes that readFile does not do "\r\n" conversion
16:33:53 <EvilTerran> http://unicode.org/Public/MAPPINGS/ISO8859/8859-1.TXT - same all the way down =]
16:33:54 <glguy> I don't remember who said it did earlier
16:33:57 <fax> sfultong: nah its much more fun writing an actual program
16:34:02 <desp> is Data.Array good?
16:34:08 <fax> but like I think the basics are pretty important as well
16:34:10 <glguy> desp: for what?
16:34:13 <pjd> EvilTerran++
16:34:15 * fax cant be sure
16:34:21 <slava> EvilTerran: indeed
16:34:31 <AStorm> EvilTerran, will an app detect whether the letter is a start of an Unicode sequence or not?
16:34:32 <desp> glguy: O(1) index and update for a 256-byte long array
16:34:33 <EvilTerran> pjd, :D
16:34:35 <AStorm> does Unicode mandate that?
16:34:36 <sfultong> fax: agreed. That's why I'm writing a game to learn haskell better
16:34:40 <sfultong> oops, dinner time
16:34:42 <fax> cool :D
16:34:46 <mauke> AStorm: you're confusing things
16:34:49 <slava> glguy: latin1 uses 128-255 differently
16:34:50 <AStorm> What about "overlong sequence" rule?
16:34:50 <glguy> desp: Data.Arry gives O(1) index and O(n) update
16:34:51 <wli> The obvious kind signatures for ListT don't seem to have enough type parameters to be monad transformers.
16:34:53 <slava> i'm puzzled by that statement
16:34:53 <mauke> AStorm: unicode is not an encoding
16:35:02 <AStorm> mauke, of course it isn't :-)
16:35:05 <desp> glguy: :/
16:35:11 <AStorm> UTF-8 and latin-1 don't mix
16:35:13 <EvilTerran> AStorm, i think, without a BOM at the start of a file, the unicode consortium says "do whatever"
16:35:13 <glguy> slava: is that what I said earlier or was I wrong?
16:35:18 * glguy scrolls up
16:35:19 <desp> is there any O(1) index and update structure?
16:35:22 <desp> maybe Map
16:35:24 <slava> glguy: you were wrong, i think :)
16:35:29 <mauke> desp: mutable arrays
16:35:35 <fax> Eelis: so did that solve your problem?
16:35:38 <AStorm> desp, Data.Array
16:35:55 <desp> AStorm: glguy says the Data.Array update isn't O(1)
16:35:58 <Eelis> fax: i don't have a concrete problem, i'm just trying to understand this mess
16:35:58 <slava> is darcs the largest haskell application constructed to date?
16:36:06 <ddarius> wli: There are really only two possibilities.
16:36:09 <slava> desp: use MArray
16:36:12 <fax> what is the mess.. different functions different tasks
16:36:50 <wli> ddarius: I can't figure out what either one of them could be.
16:37:07 <EvilTerran> AStorm, see http://en.wikipedia.org/wiki/Byte_Order_Mark
16:37:08 <oasisbot> Title: Byte-order mark - Wikipedia, the free encyclopedia
16:37:09 <desp> AStorm, glguy: so is it O(1) or O(n)?
16:37:15 <ddarius> You have ListT m a and it should be built over a list (m :: * -> *)
16:37:29 <AStorm> O(n) definitely not, check yourself
16:37:31 <ddarius> slava: No.
16:37:40 <glguy> desp: is what what
16:37:41 <desp> @src Data.Array.(//)
16:37:42 <oasisbot> Plugin `source' failed with: IRCRaised getRandItem: empty list
16:37:45 * glguy went LD
16:37:54 <desp> glguy: (//) O(1)?
16:37:59 <glguy> desp: Data.Array has slow updates
16:38:01 <glguy> like I said
16:38:02 <ddarius> desp: Immutable array update copies
16:38:12 <pjd> slava: i would bet on GHC
16:38:12 <AStorm> oh damn :-)
16:38:13 <glguy> desp: Data.Array has fast indexing
16:38:19 <Eelis> fax: the mess that    readFile "foo" >>= putStrLn . filter isAlpha   doesn't do what its type suggests.
16:38:19 <desp> aha
16:38:25 <AStorm> What about Data.Array.Unboxed?
16:38:34 <EvilTerran> still an array...
16:38:35 <glguy> AStorm: same
16:38:42 <EvilTerran> just reduced your constant a bit
16:38:44 <AStorm> :|
16:38:45 <ddarius> AStorm: It's a fact of immutable arrays
16:38:47 <slava> @hoogle MArray
16:38:47 <oasisbot> Data.Array.MArray :: module
16:38:47 <oasisbot> Data.Array.MArray.MArray :: class (HasBounds a, Monad m) => MArray a e m
16:38:47 <oasisbot> Array.accumArray :: Ix a => (b -> c -> b) -> b -> (a, a) -> [(a, c)] -> Array a b
16:38:56 <slava> mutable array right there
16:38:58 <desp> slava: IO Monad
16:39:09 <desp> trying to keep it pure
16:39:10 <ddarius> desp: Or ST
16:39:12 <glguy> DiffArray gives faster updates and indexing
16:39:13 <glguy> but
16:39:20 <glguy> DiffArray gets slower if you use old copies of the array
16:39:21 <slava> desp: you can't have a pure mutable array
16:39:22 <mauke> desp: Data.Array.ST
16:39:24 <slava> but DiffArray is nifty
16:39:31 <desp> mauke: I have no idea how to use it
16:39:36 <desp> how about Data.Map?
16:39:38 <slava> why do you guys have both Data.Array.ST and Data.MArray?
16:39:44 <ddarius> I hear the constant factors on the current implementation of DiffArray are horrible.
16:39:46 <glguy> desp: all of these time-complexities are in the docs
16:39:52 <EvilTerran> can you write your algorithm in the form <assemble input array>; <assemble output array>, thus only "changing" the array once, but still replacing all the elements
16:39:54 <AStorm> desp, isn't that O(ln n)?
16:39:54 <EvilTerran> ?
16:39:55 <mauke> slava: Data.MArray is just an interface
16:39:58 <ddarius> desp: Data.Map is a balanced tree.
16:40:00 <slava> why does it exist at all?
16:40:04 <desp> glguy: no, they weren't for Data.Array
16:40:08 <desp> otherwise I wouldn't ask
16:40:13 <glguy> Data.May has O(log n) update and indexing
16:40:15 <desp> AStorm: that's good enough I think
16:40:25 <glguy> Data.Map does list the complexities though
16:40:37 <ddarius> slava: So you can write code that works against IOArrays and STArrays and others.
16:40:52 <glguy> Data.IntMap has a different complexity
16:40:57 <slava> ddarius: ok, so why have both STArrays and IOArrays? it's just code duplication
16:41:00 <glguy> I don't know if its better or worse, but it does have a ceiling
16:41:17 <glguy> slava: because IO and ST aren't merged, yet
16:41:28 <AStorm> glguy, is IntMap a radix tree?
16:41:28 <ddarius> slava: http://www.haskell.org/haskellwiki/Introduction/Direct_Translation
16:41:29 <oasisbot> Title: Introduction/Direct Translation - HaskellWiki, http://tinyurl.com/ytokyh
16:41:53 <glguy> AStorm: I don't know enough about it to explain it
16:41:56 <glguy> ?docs Data.IntMap
16:41:56 <oasisbot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-IntMap.html
16:42:12 <slava> glguy: so its mostly just to please the type checker? :)
16:42:21 <glguy> slava: yes
16:42:51 <ddarius> Aren't IOUArrays and co also instances of the MArray interface?
16:43:03 <AStorm> Data.Sequence sounds good too
16:43:13 <rehges> ooh, pic-1
16:43:19 <glguy> Data.Sequence is a finger tree, and is quite cool
16:43:40 <EvilTerran> may be able to do something with nice amortised complexity, even if the individual compexities are nasty...
16:43:41 <rehges> erm, wrong channel
16:44:01 <mauke> sometimes I hate the haskell libraries
16:44:23 <AStorm> EvilTerran, AVL tree? :>
16:44:37 <EvilTerran> mauke, they're still leagues ahead of, say, the Java libraries, in terms of organisation etc.
16:44:41 <mauke> here's a hint for library authors: write low-level routines first, then implement high-level functionality in terms of low-level functions
16:44:47 <mauke> NOT THE OTHER WAY AROUND
16:45:00 <ddarius> mauke: ?
16:45:08 * glguy loves sweeping generalizations
16:45:19 <AStorm> mauke, that doesn't always work :P
16:45:28 <mauke> ddarius: I can't find any function that reads data from a file descriptor into a byte buffer
16:45:46 <AStorm> mauke, hGetBuf uses a Handle
16:45:51 <mauke> also, the encoding fuckup
16:45:59 <AStorm> almost like the file descriptor
16:46:03 <EvilTerran> AStorm, gotta specify a length...
16:46:06 <mauke> AStorm: except not
16:46:09 <EvilTerran> can't read the whole thing lazily
16:46:11 <AStorm> Yes, but it will EOF
16:46:31 <AStorm> EvilTerran, you could write a lazy wrapper on top of it
16:46:36 <AStorm> using chunks
16:46:38 <mauke> there's also fdRead, which takes a file descriptor
16:47:00 <wli> Okay, I just barely hacked it together.
16:47:01 <mauke> but instead of taking a pointer, it allocates a buffer internally, copies the result into a String, then frees the buffer
16:47:14 <AStorm> mauke, sounds slow
16:47:16 <mauke> "well" done
16:47:49 <dibblego> what's the name of the paper that reasons about imperative code as if it were referentially trapsnarent?
16:48:08 <mauke> trap and snare sounds about right
16:48:14 <wli> There is the slight problem that I have no idea if it's any sort of useful list monad transformer.
16:49:09 <EvilTerran> mauke, i agree absulutely with your sentiment. it'd make more sense for the fundamental IO routines to work verbatim with [Word8], IMO.
16:49:24 <mauke> yes!
16:49:59 <EvilTerran> or Int (always [0..255]), if you want to be H98-friendly.
16:50:01 <mauke> actually, I want Fd -> Ptr a -> IO b with Handle -> IO [Word8] on top of that
16:50:02 <ddarius> wli: Verify that it satisfies the monad laws (perhaps the most straightforward implementation doesn't for all monads).
16:50:16 <mauke> no, wait
16:50:24 <AStorm> mauke, and maybe Handle -> IO String too
16:50:32 <ddarius> EvilTerran: You don't want to have to use lists to do IO.
16:50:36 <EvilTerran> AStorm, that can be added on top
16:50:46 <AStorm> EvilTerran, why, just to be slow? :P
16:50:46 <EvilTerran> ddarius, okay, return a stream then.
16:50:48 <mauke> with RawHandle -> IO [Word8] on top of that, and Handle -> IO String on top of *that*
16:50:52 <glguy> fdToHandle :: Fd -> IO Handle
16:50:58 <wli> ddarius: I'm more at the "get it past the typechecker and pray" stage right now.
16:51:01 <glguy> handleToFd :: Handle -> IO Fd
16:51:05 <glguy> did we cover those already?
16:51:06 <dmead> have you guys seen this?
16:51:07 <dmead> http://video.google.com/videoplay?docid=-4851250372422374791&q=haskell
16:51:08 <oasisbot> Title: Advanced Topics in Programming Languages Series: Parametric Polymorphism, http://tinyurl.com/36q8d2
16:51:24 <wli> Advanced in 1974?
16:51:24 <EvilTerran> AStorm, separation of concerns
16:51:28 <ddarius> dmead: Wadler was it?
16:51:39 <mauke> glguy: handleToFd closes the Handle
16:51:47 <dmead> im not sure if thats the guy giving the talk
16:51:49 <wli> We've clearly moved on to monads and higher-order kinds and such.
16:51:55 <EvilTerran> get the bytes off the disc; work out what characters they represent. different concerns.
16:52:00 <dmead> but he spends a few minutes demonstrating djinn
16:52:03 <slava> what is a kind, anyway? i don't really get it
16:52:09 <mauke> slava: a type type
16:52:15 <slava> can you give an example?
16:52:21 <dmead> *->*
16:52:21 <slava> how many types of types are there?
16:52:22 <dmead> ?
16:52:24 <mauke> Int is a type; it has the kind *
16:52:28 <ddarius> dmead: I've seen it.  It's not the one that Wadler did.
16:52:29 <slava> ok
16:52:30 <ddarius> :k Maybe
16:52:31 <oasisbot> * -> *
16:52:33 <mauke> Maybe is a type constructor; it has the kind * -> *
16:52:34 <AStorm> Int -> Int is a type too
16:52:45 <EvilTerran> Phil Gossett's talking, dmead
16:52:45 <slava> Int -> Int has kind *?
16:52:48 <mauke> yes
16:52:48 <ddarius> :k Int -> Int
16:52:48 <AStorm> slava, yes
16:52:49 <dmead> ah
16:52:49 <oasisbot> *
16:52:56 <ddarius> :k (->)
16:52:56 <slava> ah, i see
16:52:57 <oasisbot> ?? -> ? -> *
16:53:07 <mauke> ignore that, for it is evil
16:53:09 <slava> and -> takes two types and gives you back a type?
16:53:13 <mauke> yes
16:53:17 <slava> i see now
16:53:23 <EvilTerran> slava, a kind indicates how many more type parameters something needs before it's a type.
16:53:24 <slava> when do kinds ever come up explicitly?
16:53:24 <mauke> :k ContT
16:53:25 <oasisbot> * -> (* -> *) -> * -> *
16:53:33 <dmead> :k ((->)->)
16:53:34 <oasisbot> parse error on input `)'
16:53:36 <mauke> when you use monad transformers wrong
16:53:39 <slava> heh
16:53:39 <EvilTerran> when you're dealing with phantom types
16:53:43 <AStorm> :k (->).(->)
16:53:44 <oasisbot> parse error on input `.'
16:53:46 <mauke> then you'll get a "nice" error :-)
16:53:47 <AStorm> :P
16:53:48 <dmead> :k ((*->*)>*
16:53:49 <oasisbot> parse error (possibly incorrect indentation)
16:53:55 <wli> mauke: I'm even writing them wrong.
16:53:56 <EvilTerran> mauke, what do those ?s mean?
16:53:58 <dmead> :k ((*->*)->*)
16:53:59 <oasisbot> parse error on input `)'
16:54:03 <dmead> =/
16:54:15 <mauke> EvilTerran: I think they have to do with GHC and unboxed types
16:54:16 <AStorm> dmead, kinds do not have kinds :P
16:54:20 <slava> why does the kind of -> contain ?? and ? but the others just have * ?
16:54:20 <dmead> oh xD
16:54:20 <EvilTerran> ah.
16:54:21 <ddarius> dmead: That doesn't make any more sense than writing :t Maybe Int would.
16:54:32 <ddarius> slava: GHC magic
16:54:35 <mauke> :k Int#
16:54:36 <oasisbot> Not in scope: type constructor or class `Int#'
16:54:52 <slava> are kinds less expressive than types?
16:54:58 <AStorm> slava, more expressive
16:55:03 <AStorm> higher level
16:55:05 <EvilTerran> they express different concepts.
16:55:12 <ddarius> slava: Yes.  They are only there to keep you from saying stuff like Int Maybe
16:55:22 <slava> ok
16:55:35 <EvilTerran> you can't have kinds without types, so in that regad, you could say they encompass types implicitly, which makes them trivially more expressive
16:55:36 <AStorm> ddarius, not only that :-)
16:55:45 <EvilTerran> but, on their own, less expressive.
16:56:15 <slava> is -> the only kind constructor or are there others?
16:56:29 <AStorm> -> is not a kind constructor :P
16:56:32 <ddarius> slava: In Haskell 98, (->) and * are all there is.
16:56:43 <hpaste>  wli pasted "attempt at ListT" at http://hpaste.org/1844
16:56:44 <mauke> AStorm: yes, it is
16:56:56 <wli> kThere is my feeble attempt at a list monad transformer.
16:56:56 <slava> would it make sense to reason about other kind constructors?
16:57:00 <slava> or is the concept simply not useful?
16:57:01 <EvilTerran> whether it's a constructor is a semantic point, surely...
16:57:03 <AStorm> mauke, hmm, if you can't do anything with it, it's non-constructed IMO
16:57:07 <AStorm> just defined
16:57:30 <EvilTerran> ?kind StateT
16:57:31 <oasisbot> * -> (* -> *) -> * -> *
16:57:31 <ddarius> wli: Your instance for MonadTrans is silly.
16:57:35 <EvilTerran> there's a more complicated one.
16:57:56 <wli> ddarius: I haven't the foggiest idea what I'm doing anyway.
16:58:01 <ddarius> slava: There are others possible.  You can have the kind level be as rich as you like.
16:58:06 <AStorm> wli, yes, it is silly, you can lift from list directly
16:58:15 <slava> ddarius: what would that give the programmer?
16:58:18 <ddarius> E.g. there were row kinds somewhere.
16:58:25 <slava> in cat?
16:58:37 <wli> AStorm/ddarius: I don't know what you mean.
16:58:48 <dolio> slava: You can look at type classes as providing user-definable kinds (I think).
16:59:00 <ddarius> slava: You could have hairier types and thus need a hairier kind level.  There is really little difference between types and kinds, they are just different levels.
16:59:02 <dolio> Although that's not what they actually do.
16:59:13 <slava> ddarius: is there any reason to go another level up?
16:59:18 <ddarius> slava: Yes.
16:59:28 <slava> that's crazy.
16:59:45 <AStorm> wli, are you trying to create a strict list?
16:59:47 <ddarius> wli: If nothing else, sequence [m] is just m
17:00:22 <wli> ddarius: That doesn't typecheck.
17:00:34 <ddarius> wli: lift :: m a -> t m a, you want to make the m a into a m [a] and wrap.
17:00:35 <dolio> So you can look at plus as: '(+) :: forall (a : Num). a -> a -> a'
17:00:51 <ddarius> You want to slide the "boxing" up into a list under the monad constructor.
17:00:54 <ddarius> :t liftM
17:00:55 <oasisbot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
17:01:59 <slava> what do you call =>
17:02:07 <slava> i understand what it does, but i don't know what this operation is called
17:02:10 <wli> ddarius: ghci complains about rigid variables etc. without the sequence.
17:02:22 <slava> is it a universal quantifier?
17:02:32 <mauke> slava: no, that's forall
17:02:33 <dmead> slave: binding
17:02:53 <mauke> slava: it provides a class context. I usually call it "fat arrow"
17:03:03 <slava> why does the type of liftM require (m :: * -> *)? can the type checker infer the kind of m here?
17:03:16 <EvilTerran> slava, i call it "allows", i think
17:03:31 <glguy> slava: m :: * -> * because it is used later as "m a"
17:03:31 <ddarius> slava: It's GHC being overly helpful in displaying types.
17:03:32 <EvilTerran> ?type liftM
17:03:33 <oasisbot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
17:03:36 <slava> oh, ok
17:03:37 <mauke> slava: everything before the . is not haskell98
17:03:44 <slava> i see
17:03:44 <AStorm> mauke, I call it "bold arrow" myself :d
17:03:52 <slava> \Rightarrow :-)
17:03:53 <dmead> i thought => is type binding
17:03:54 <dmead> =/
17:04:08 <ddarius> wli: ListT (liftM return m) should typecheck
17:04:09 <EvilTerran> well, it's class binding.
17:04:12 <Saizan> i call it "implication"
17:04:29 <AStorm> Saizan, not in this context
17:04:32 <EvilTerran> @src MonadZero
17:04:32 <oasisbot> Plugin `source' failed with: IRCRaised getRandItem: empty list
17:04:38 <Saizan> if Monad m holds then ..
17:04:39 <EvilTerran> ...
17:04:44 <AStorm> We want lambdabot back!
17:04:45 <ddarius> AStorm: Actually, it logically is rather similar to implication.
17:04:53 <dmead> yea that is true
17:04:56 <AStorm> ddarius, hmm, somewhat
17:05:21 <ddarius> You can think of a type class as a predicate then Monad m => say, says the following type checks if Monad m holds.
17:05:28 <sfultong> what happened to lambdabot?
17:05:28 <dmead> actually i just watched a lecture that calls it implication
17:05:29 <EvilTerran> "class Monad m => MonadZero m" means "m is a monad" *allows* "m is a monadzero"
17:05:36 <dmead> http://video.google.com/videoplay?docid=-4167170843018186532&q=haskell&total=519&start=0&num=10&so=0&type=search&plindex=0
17:05:37 <oasisbot> Title: Faith, Evolution, and Programming Languages, http://tinyurl.com/322bx8
17:05:41 <dmead> that lecture calls it implication
17:05:52 <glguy> in "Monad m => ...." the stuff left of => is called the 'context'
17:05:52 <dmead> *lecturer
17:05:59 <EvilTerran> "instance Foo a => Bar a" reads "a is a Foo" *allows* "a to be a Bar"
17:06:17 <ddarius> EvilTerran: The senses of => are backwards between them.
17:06:28 <EvilTerran> altho the uses of => in class headers and instance headers are a bit odd
17:06:34 <dmead> i dunno... for stuff that involved => i just let the compiler infer the signatures
17:06:40 <EvilTerran> the instance one makes more sense to me..
17:06:50 <dmead> EvilTerran, instance binding?
17:06:54 <ddarius> EvilTerran: Yes, that's the consensus.  The class one should point the other way.
17:06:56 <glguy> the instance one is conceptually backwards
17:07:03 <glguy> err, class one
17:07:15 <AStorm> glguy, why not fix it for H'?
17:07:35 <mauke> I read "instance Foo a => Bar a" as "function Bar(a) { Foo(a); }" :-)
17:07:41 <wli> I guess I need an evalListT
17:08:11 <Saizan> but actually you can't give an instance of MonadZero and expect to have one of Monad for free, so even class Monad m <= MonadZero m would not be so appropriate
17:08:16 <glguy> AStorm: H' is not new stuff
17:08:21 * ddarius reads it as bar(A) :- foo(A).
17:08:38 <mauke> yeah, but I don't know prolog
17:08:38 <AStorm> glguy, hmm
17:08:53 <ddarius> Saizan: If MonadZero holds then Monad -must- hold.
17:09:52 <AStorm> @google haskell prime . operator
17:09:54 <oasisbot> http://hackage.haskell.org/trac/haskell-prime/wiki/MonomorphismRestriction
17:09:54 <oasisbot> Title: MonomorphismRestriction - Haskell Prime - Trac
17:09:59 <AStorm> missed?
17:10:38 <mauke> why why why does handleToFd destroy the Handle :(
17:11:02 <AStorm> mauke, garbage collection :/
17:11:10 <Saizan> ddarius: sure, and i agree on the classes-as-predicates level, but un the more pratical sense of writing the instances for a type i see why class Monad m => MonadZero m makes sense
17:11:10 <mauke> what?!
17:11:23 <mauke> that's pretty much the opposite of garbage collection
17:11:39 <AStorm> mauke, hmm, really, it probably unrefs the Handle
17:12:00 <AStorm> some "shoot yourself in the foot" protection, totally misguided
17:12:06 <ddarius> Saizan: But having an instance of Monad doesn't mean you have an instance of MonadZero at all, let alone for free.
17:12:17 <AStorm> so that you don't close files when you hold a Handle
17:14:02 <wli> Well, my ListT seems to get wrong answers.
17:14:40 <wli> searchAll6 gr 0 3 :: [[Int]] == [[0,1,3],[0,2,3]] but searchAll6 gr 0 3 :: ListT [ ] [Int] == ListT *** Exception: no path
17:15:35 <wli> I've not the foggiest clue how the exception got in there without a monad that actually keeps the string ("no path" is from a fail call in the function).
17:15:57 <Saizan> ddarius: well that depends on the meaning you give to the keyword "class", but well i don't think we should argue on an arrow :)
17:16:09 <AStorm> wli, how is that [] typed?
17:16:13 <mauke> wli: by calling error
17:16:29 <mauke> > [1, 2, error "no path"]
17:16:30 <oasisbot>  Excuption: no path
17:16:40 <AStorm> excuption? ;P
17:17:16 <wli> Implementing a fail method for the Monad class seems to resolve it.
17:17:29 <Saizan> wli: heh, it defaults to error
17:20:31 <wli> I've got it.
17:20:44 <wli> Extremely painful but I got it.
17:20:51 <wli> I'm not really sure why it works. I sort of hacked it together.
17:21:25 <Saizan> that's what the typechecker is for
17:21:26 <ddarius> wli: Paste?
17:21:44 <wli> ddarius: Incoming.
17:21:55 <ddarius> Saizan: So you can randomly stick code together trying to satisfy the types and have some hope of getting the correct answer...
17:22:43 <hpaste>  wli pasted "YAHT Ex. 9.4" at http://hpaste.org/1845
17:23:12 <wli> In all honesty the result appears quite magical to me.
17:23:28 <Saizan> ddarius: yeah, there are a couple of quotes on this subject too :)
17:23:44 <ddarius> wli: The pattern in the mplus definition can nicely be replaced with a usage of liftM2
17:24:13 <mauke> @quote type
17:24:13 <oasisbot> Plugin `quote' failed with: IRCRaised getRandItem: empty list
17:25:10 <ddarius> wli: It looks like your Monad, MonadPlus, and MonadTrans instances are correct though.
17:25:38 <Saizan> wli: well you've just lifted the definitions of the list monad inside another generic one
17:26:01 <wli> ddarius: ListT m `mplus` ListT m' = ListT $ liftM2 (++) m m' ?
17:26:09 <glguy> yeah
17:26:18 <ddarius> wli: Yep.
17:27:03 <AStorm> I prefer to define operators like functions
17:27:11 <AStorm> because they are ones
17:27:24 <wli> Well, it wouldn't be fair to "inflate my grade" by altering what I've got written down but so noted for future use.
17:27:50 <sfultong> yeah... why do we have operators? can't we all just standardize on prefix, postfix or infix?
17:27:50 <ddarius> wli: I'm a big fan of the liftM family of functions.
17:27:55 <wli> I may have managed to write all this but I don't really understand how it works at all.
17:28:13 <ddarius> wli: Do you understand how the "normal" list monad works?
17:28:21 <wli> ddarius: Barely.
17:28:41 <ddarius> @google How to replace failure with a list of successes
17:28:43 <oasisbot> http://portal.acm.org/citation.cfm?id=5288
17:28:43 <oasisbot> Title: How to replace failure by a list of successes
17:28:50 <mauke> ddarius: have you ever wondered why return isn't called liftM0? :-)
17:29:48 <wli> I'm actually a big anti-list bigot when programming in C. I wonder what gets into me when programming Haskell.
17:30:19 <sfultong> well.. without lists in a pure functional language... things would be scary
17:30:25 <dmead> if you don't have lists in haskell, what do you have?
17:30:29 <sfultong> yeah
17:30:34 <int-e> wli: in C you'd have to worry about the memory management all the time
17:30:34 <mauke> Data.Sequence!
17:30:44 <dmead> ha
17:30:57 <AStorm> sfultong, you still have tuples :>
17:30:57 <sfultong> heh, I guess you could do everything in trees...
17:31:01 <wli> dmead: Arrays, search trees, Data.Sequence, priority queues, heaps, hash tables, etc.
17:31:11 <sfultong> tuples are no replacement for lists!
17:31:12 <dmead> welllll
17:31:20 <AStorm> sfultong, tuples + Either are
17:31:21 <AStorm> :P
17:31:23 <dmead> tuples come from logical and
17:31:30 <dmead> functions come from logical implication
17:31:33 <dmead> thats what i learned to day :>
17:31:35 <Saizan> mmh can i get that paper from acm for free?
17:31:36 <AStorm> they can represent groups too
17:31:37 <sfultong> Astorm: hmm, interesting idea
17:31:41 <wli> int-e: That doesn't really fit in with my critique; I advocate "more advanced" pointer-linked structures.
17:31:51 <sfultong> actually, couldn't you just use Either to replace lists?
17:31:55 <sfultong> nevermind tuples
17:32:02 <AStorm> sfultong, hmm, not really
17:32:06 <dmead> well
17:32:08 <dmead> you *could*
17:32:12 <sfultong> heheh
17:32:15 <dmead> but you wouldn't want to
17:32:15 <mauke> I'd like to see that
17:32:16 <AStorm> not variable length :P
17:32:17 <wli> Fix etc.
17:32:18 <ddarius> mauke: No.
17:32:29 <dmead> it'd be like monadic trees
17:32:32 <dmead> well
17:32:38 <dmead> i guess either is like a monadic tree
17:32:43 <dmead> or something
17:32:46 <sfultong> couldn't you just do Either (Either (Ether a b) c) d
17:32:55 <dmead> well
17:33:02 <mauke> that's still |x| = 1
17:33:04 <AStorm> sfultong, that's not variable length I think
17:33:12 <int-e> wli: also, in Haskell, lists are a sort of control structure, because they're lazy. so comparing them to simple linked lists in C isn't the whole truth
17:33:13 <ddarius> wli: For non-determinism monads, so do I.
17:33:17 <dmead> Either (Right ....) (Either (Right ..) (Left ..) )
17:33:20 <wli> I think it's possible to define fixpoint operators on types, at which point you get a list from Either or whatever.
17:33:29 <AStorm> dmead, and that's a tree :P
17:33:34 <dmead> indeed
17:33:52 <mauke> what's that supposed to be?
17:33:54 <ddarius> data Fix f = In (f (Fix f))
17:34:02 <dmead> an either tree
17:34:10 <mauke> is it a type or a value?
17:34:17 <dmead> it's some constructors
17:34:22 <dmead> put a value in ...
17:34:24 <ddarius> wli: As int-e said, lists are often the iterators of Haskell.
17:34:24 <dmead> etc
17:34:26 <wli> int-e: That's probably the real explanation as to why I don't get up in arms about lists sucking when dealing with Haskell.
17:34:31 <mauke> Either is not a data constructor
17:34:41 <sfultong> one of the hardest things for me about Haskell is getting used to not having references...
17:34:42 <dmead> oh?
17:35:01 <Philippa> sfultong: take a look at the ST monad, go nuts
17:35:09 <sfultong> ah
17:35:17 <Philippa> though learning to program in a pure functional style's valuable
17:35:23 <ddarius> sfultong: What do you need references for?
17:35:26 <glguy> really Haskell is all pass by reference
17:35:37 <dmead> sfultong, why would you need that?
17:35:40 <dmead> yea
17:35:45 <mauke> sfultong: you can just use TVars instead
17:35:55 <sfultong> not familiar with that...
17:35:56 <AStorm> or MVars, if you need something mutable
17:36:02 <AStorm> and locked
17:36:08 <sfultong> man, I should just stop voicing opinions until I learn more
17:36:21 <sfultong> :-P
17:36:26 <mauke> dmead: e.g. because it seems like I need to write my own buffering on top of Handle, so I need a thread-safe queue somewhere in my handle
17:37:49 <sfultong> > foldl (const (*2)) 1 [1..10]
17:37:50 <oasisbot>  20
17:38:10 <dmead> ahh
17:38:37 <sfultong> wait, is that right?
17:38:47 <mauke> yes, it's 10 * 2
17:38:58 <dmead> mauke, a thread safe stream or queue might be something really useful
17:39:07 <dmead> mauke, like buffered streams in java
17:39:12 <int-e> > foldl (flip (const (*2))) 1 [1..10] -- did you want this?
17:39:13 <oasisbot>  1024
17:39:19 <sfultong> > foldl (seq (*2)) 1 [1..10]
17:39:19 <oasisbot>      Occurs check: cannot construct the infinite type: a = b -> a
17:39:19 <oasisbot>     Probabl...
17:39:21 <ddarius> (T)Chan
17:39:29 <glguy> > scanl (const (*2)) 1 [1..10]
17:39:30 <oasisbot>  [1,2,4,6,8,10,12,14,16,18,20]
17:39:31 <int-e> > (iterate (*2) 1 !! 10, 2^10)
17:39:32 <oasisbot>  (1024,1024)
17:39:42 * glguy has seen scanl used in channel in ages
17:39:53 <mauke> I'm pretty sure I want MVar Seq
17:40:09 <sfultong> I was trying to use foldl and lists as a for loop
17:40:33 <AStorm> sfultong, that's either scanl, or map
17:40:35 <AStorm> :>
17:40:45 <mauke> > foldl (\z x -> 2 * z) 1 [1 .. 10]
17:40:45 <AStorm> @src map
17:40:46 <oasisbot> map _ []     = []
17:40:46 <oasisbot> map f (x:xs) = f x : map f xs
17:40:46 <oasisbot>  1024
17:41:04 <sfultong> yeah, as mauke did
17:41:19 <sfultong> I was trying pointfree... but I suck :)
17:41:29 <ddarius> foldl' corresponds to the idiom acc = z; for(int i = 0; i < a.length; ++i) acc = f(acc,a[i]);
17:41:43 <sfultong> @pl  foldl (\z x -> 2 * z) 1 [1 .. 10]
17:41:43 <oasisbot> foldl (const . (2 *)) 1 [1..10]
17:42:13 <sfultong> oh, the little period there
17:42:15 <AStorm> nifty
17:42:19 <sfultong> at least I was close
17:42:21 <AStorm> flip should work too
17:42:32 <glguy> if you just want a for loop
17:42:39 <glguy> and you don't want to use the value
17:42:40 <glguy> just loop
17:42:41 <glguy> then
17:42:43 <glguy> :t replicateM
17:42:45 <oasisbot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
17:43:01 <ddarius> :t replicateM_
17:43:02 <oasisbot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m ()
17:43:44 <sfultong> well, I wasn't thinking for practical purposes... I just thought it was neat to use foldl to loop
17:44:15 <mauke> it's a bit fused for my taste
17:44:23 <ddarius> sfultong: It is nice to use folds for things.
17:44:26 <AStorm> scanl works better
17:44:33 <mauke> I mean, you could just map + enumFromTo
17:44:43 <AStorm> and looks nicer in the case you don't really want to use the enumerator
17:44:44 <ddarius> scanl does something else altogether.
17:44:45 <sfultong> oh, I didn't see int-e's post
17:45:16 <AStorm> ddarius, uhm, blah
17:45:21 <AStorm> scanl is much more like map
17:45:37 <glguy> scanl is a foldl
17:45:41 <glguy> that exposes the intermediate results
17:45:48 <AStorm> exactly
17:45:52 <mauke> "droppings"
17:45:57 <AStorm> :>
17:46:39 <ddarius> > foldr ((:) . (1+)) [] [1,3,6]
17:46:40 <oasisbot>  [2,4,7]
17:47:14 <AStorm> > scanr (1+) [] [1,3,6]
17:47:15 <oasisbot>   add an instance declaration for (Num ([a] -> [a]))
17:47:15 <oasisbot>     In the expression: 6
17:47:22 <AStorm> hmm, stupid me
17:47:31 <AStorm> > scanr (+1) [] [1,3,6]
17:47:31 <oasisbot>   add an instance declaration for (Num ([a] -> [a]))
17:47:31 <oasisbot>     In the expression: 6
17:47:42 <AStorm> something is odd, with my mind
17:47:44 <AStorm> :P
17:47:52 <glguy> you are trying to treat scanl like a map
17:47:58 <sfultong> something's always odd with mine
17:48:03 <mauke> @type scanr
17:48:04 <oasisbot> forall a b. (a -> b -> b) -> b -> [a] -> [b]
17:48:19 <mauke> > scanr (+) 1 [1,3,6]
17:48:20 <oasisbot>  [11,10,7,1]
17:48:43 <AStorm> mauke, right :>
17:49:11 <sfultong> @pl (\f x -> f x x)
17:49:11 <oasisbot> join
17:49:14 <AStorm> > map (1+) [1,3,6]
17:49:15 <oasisbot>  [2,4,7]
17:49:21 <sfultong> @pl (\f x -> f x x x)
17:49:21 <oasisbot> join . join
17:49:35 <AStorm> @type join
17:49:36 <oasisbot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
17:49:42 <glguy> > fix (scanl (+) 1 . (1:))
17:49:43 <oasisbot>  [1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1771...
17:49:54 <sfultong> I tend to use map and folds for everything...
17:49:57 <AStorm> glguy, are you producing fibs?
17:49:59 <AStorm> :>
17:50:12 <sfultong> telling fibs again?
17:50:31 <sfultong> @type fix
17:50:32 <oasisbot> forall a. (a -> a) -> a
17:50:58 <ddarius> @free fix
17:50:59 <oasisbot> f . g = h . f => f (fix g) = fix h
17:51:41 <AStorm> o_O
17:51:48 <AStorm> now that is non-trivial and useful
17:52:59 <mauke> > nubBy(((>1).).gcd)[2..]
17:53:00 <oasisbot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
17:53:42 <AStorm> mauke, why do we want a prime sieve?
17:53:44 <AStorm> :P
17:53:52 <AStorm> there are better methods
17:53:55 <glguy> > sequence [(+3),(*2)] 8
17:53:56 <oasisbot>  [11,16]
17:54:17 <mauke> AStorm: but it's shrt!
17:55:04 <sfultong> efficiency in finger movement wins over efficiency of electron usage for me
17:55:34 <slava> very interesting... f . g = h . f => f (fix g) = fix h
17:58:59 <AStorm> sfultong, not if you have to...
17:59:07 <mauke> Storable--  # not flexible enough
17:59:22 <AStorm> > take 10^6 $ nubBy(((>1).).gcd)[2..]
17:59:22 <oasisbot>   add an instance declaration for (Num ([a] -> [a]))
17:59:34 <AStorm> > take (nubBy(((>1).).gcd)[2..]) 10^6
17:59:35 <oasisbot>  Couldn't match expected type `Int' against inferred type `[a]'
17:59:42 <AStorm> blah at me
17:59:48 <AStorm> it uses an Int
17:59:50 <AStorm> not Integer
18:00:21 <mauke> > take (10 ^ 6) $ nubBy(((>1).).gcd)[2..]
18:00:23 <oasisbot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
18:01:44 <sfultong> lucky for me I rarely take things 10 ^ 6 at a time
18:02:19 <wli> Okay, I got the next exercise done.
18:03:11 <xelxebar> whoa!  that's so cool
18:03:53 <wli> Wow, I can't really smoke out that algorithm.
18:04:41 <mauke> @src nubBy
18:04:41 <oasisbot> nubBy eq []             =  []
18:04:41 <oasisbot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
18:05:44 <banbh> @seen dons
18:05:44 <oasisbot> Last time I saw dons was when I left #haskell, #lazybottoms and #oasis 3d 16h 37m 55s ago, and .
18:06:05 <sfultong> and . ?
18:06:18 <Manyfold> @seen Cale
18:06:18 <oasisbot> Cale is in #haskell, #oasis, #lazybottoms-dev and #lazybottoms. I last heard Cale speak 3m 10s ago.
18:06:38 <Manyfold> what is lazy bottoms?
18:06:46 <Cale> ICFP team
18:07:54 <Nafai> How is ICFP going?
18:08:00 <sfultong> I wish I could see biographies on all the teams
18:09:12 <Cale> Nafai: Okay. It's pretty hard.
18:11:41 <dons> ?version
18:11:41 <oasisbot> lambdabot 4p537, GHC 6.6.1 (Linux i686 3.00GHz)
18:11:41 <oasisbot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
18:13:05 <Feck> Manyfold: YOU'RE a lazy bottom
18:13:21 <Manyfold> yeah right i am lazy
18:13:35 <Manyfold> but no bottom
18:17:10 <pjd> is there somewhere to archive enlightening #haskell discussions?
18:17:19 <dons> oasisbot: @part #haskell
18:17:20 <oasisbot> Not enough privileges
18:17:27 <dons> vincenz: !
18:17:32 --- mode: ChanServ set +o dons
18:17:37 --- kick: oasisbot was kicked by dons (dons)
18:17:39 --- mode: ChanServ set -o dons
18:17:41 * pjd found the above exchange about kinds useful
18:17:46 <mauke> how do you do the forced part trick?
18:17:47 <dons> pjd, on the wiki, is where it usually goes
18:18:05 <pjd> i guessed as much; is there a page?
18:18:24 <dons> no, just create a page about the topic you're summarising?
18:18:39 <Manyfold> Cale will you come to germany in october?
18:19:20 <banbh> dons: i tried compiling hs-plugins from hackage (on osx, ghc 6.6) and got an error.  i assume i should be using the one from darcs?
18:19:32 <dons> use the darcs one, yep
18:19:40 <banbh> thx
18:19:56 <pjd> dons: i wasn't sure that IRC discussions would make generally-appropriate content
18:20:15 <dons> no, you'd have to turn it into an article
18:20:16 <ddarius> wli: nubBy collapses equivalence classes to the first instance, so nubBy (((>1).).gcd) collapses equivalence classes of numbers that are not relatively prime.
18:21:28 <pjd> dons: it's just the dialog i'd be interested in, though
18:22:12 * pjd shrugs
18:22:23 <chessguy> the debugger isn't even in ghc HEAD yet is it?
18:24:55 <Saizan> HEAD's ghci has breakpoints and such, never used it though
18:25:02 <dons> it is in the head, yep
18:30:56 <Cale> Manyfold: no?
18:31:50 <Manyfold> well the conference on functional programming is held in freiburg this year
18:32:00 <Manyfold> here in germany
18:32:51 <Manyfold> Cale: http://www.informatik.uni-bonn.de/~ralf/icfp07.html
18:32:52 <lambdabot> Title: 12th ACM SIGPLAN International Conference on Functional Programming (ICFP 2007)
18:33:03 <Cale> ah
18:33:43 <Manyfold> i asked if you are coming too
18:36:27 <mauke> @src Bits
18:36:27 <lambdabot> Source not found. I've seen penguins that can type better than that.
19:00:26 <Nafai> dcoutts: Around?
19:27:51 <wli> Exercise 9.7 complete.
19:28:15 <jfredett> ediboh?
19:28:24 <wli> jfredett: YAHT
19:28:28 <jfredett> ah
19:28:30 <jfredett> brilliant
19:28:40 <wli> I started sometime this morning. I'm now done.
19:28:45 <jfredett> cool
19:29:00 * jfredett should be working, but is instead reading about YAHT
19:29:09 <wli> The monad transformer bits were the really hard parts.
19:29:36 <jfredett> wli: never got that far
19:29:48 <jfredett> i strayed off into thinking about data types and type classes
19:29:51 <jfredett> and I forgot to go back
19:29:52 <jfredett> :/
19:30:57 <wli> The Gentle Introduction To Haskell doesn't have any exercises.
19:31:04 <jfredett> sadly,
19:32:35 <wli> I'm totally flabbergasted at the monad transformer stuff.
19:33:05 <wli> I don't understand how that worked at all.
19:33:10 <jfredett> yeh- i still dont quite fully understand monads in general and their usefulness
19:33:19 <jfredett> someday I'll get there. :/
19:33:39 <CosmicRay> wli: I don't think that the Gentle Introduction is very gentle, really.
19:34:04 <wli> CosmicRay: It can't really do much of anything for me without pounding me in the face with exercises.
19:34:21 <jfredett> meh, just another week or so, then I get all sorts of neat Haskell books
19:34:27 <jfredett> (my birthday is the 1st)
19:34:31 <jfredett> :)
19:36:25 <Saizan> wli: i've an exercise for you: show why ListT [] is not a monad
19:36:48 <wli> Saizan: Oh dear.
19:36:54 <jfredett> lol
19:37:11 <wli> Saizan: Are you sure that's true?
19:37:23 <Saizan> yup, 100%
19:37:29 <jfredett> doubtful he would have asked it, if he wasn't
19:37:30 <ddarius> For the simple definition of ListT, ListT m is only a monad if m is a commutative monad.
19:38:23 <wli> I barely understood what I wrote. It was largely a case of ramming it through the typechecker.
19:40:19 <Saizan> heh, i've still some problems with how laziness interact with State and Writer for example
19:43:01 <Saizan> > let (<<) = flip (>>) in runState (foldr1 (<<) (repeat (put 1))) 0
19:43:02 <lambdabot>  ((),1)
19:47:53 <dons> http://programming.reddit.com/info/28lmz/comments
19:47:54 <lambdabot> Title: Haskell malware (!): an X11 keylogger (reddit.com)
19:47:55 <dons> (!)
19:48:05 <jfredett> yipes!
19:48:49 <dons> from the same guy, http://programming.reddit.com/info/28ln6/comments
19:48:50 <lambdabot> Title: Using Haskell for reading raw ethernet frames (reddit.com)
19:49:12 <pjd> ddarius: commutative monad?
19:49:17 <jfredett> interesting
19:49:44 <pjd> as in the monad laws' "bind commutativity"?
19:50:53 <winterstream> Hi everyone
19:51:06 <dolio> @check (\m f g -> let bind m k = concat (mapM k m) in ((m :: [[Int]]) `bind` (f :: [Int] -> [[Int]])) `bind` (g :: [Int] -> [[Int]]) == m `bind` (\l -> f l `bind` g))
19:51:07 <lambdabot>  Falsifiable, after 8 tests: [[2,-4,-5,-1],[-4,-5,0,-5,-5]], <[Int] -> [[Int]...
19:51:14 <dolio> Well, there we are.
19:52:26 <winterstream> What were you just checking dolio?
19:52:38 <winterstream> That seems rather inscrutable to me
19:52:44 <dolio> The associativity of ListT [].
19:52:49 <pjd> ddarius: err, nevermind, i confused commutative with associative
19:52:56 <winterstream> Okay
19:53:19 <dolio> Although, I couldn't use ListT [], because @check doesn't have that in scope, so I had to reproduce the operations.
19:53:30 <winterstream> Oh
19:53:33 <dolio> And use [[a]] instead.
19:56:39 <winterstream> I have what I think it a bit of a technical question regarding Monads.
19:57:01 <Saizan> dolio: isn't that bind just a flipped concatMap?
19:57:24 <winterstream> The compilers/interpreters have no special support for Monads other than the "do" syntactic sugar, is that right?
19:57:32 <ddarius> winterstream: correct
19:57:34 <dolio> Saizan: Well, it's concatMapM in ListT [], I guess.
19:57:44 <pjd> does the IO monad's special support count?
19:57:50 <dolio> Saizan: And I don't think there is such a thing predefined.
19:58:02 <Saizan> ?type concat (mapM k m)
19:58:10 <Saizan> ?type \k m ->concat (mapM k m)
19:58:11 <lambdabot> Not in scope: `k'
19:58:11 <lambdabot>  
19:58:11 <lambdabot> <interactive>:1:15: Not in scope: `m'
19:58:13 <lambdabot> forall a a1. (a -> [a1]) -> [a] -> [a1]
19:58:40 <Saizan> uhm yeah, mapM has the sequence part
19:58:45 <winterstream> Okay, so when you have something like an IO monad, what will make the compiler generate code that will trigger the action every time?
19:58:51 <winterstream> I'm just not grokking something...
19:59:34 <winterstream> I'm asking because of the following piece of code:
19:59:41 <SamB> > array (0,1) [(0,1),(1,3)] // [(0,4)]
19:59:43 <lambdabot>  array (0,1) [(0,4),(1,3)]
19:59:55 <SamB> chessguy: that doesn't look like the behaviour you describe
19:59:58 <chessguy> hm
20:00:03 <winterstream> until_ :: Monad m => (a -> Bool) -> m a -> (a -> m ()) -> m ()
20:00:04 <winterstream> until_ pred prompt action = do
20:00:04 <winterstream>   result <- prompt
20:00:04 <winterstream>   if pred result
20:00:04 <winterstream>      then return ()
20:00:04 <winterstream>      else action result >> until_ pred prompt action
20:00:11 <Saizan> winterstream: well your main is an IO () which you can see a recipe for what to do
20:00:25 <Saizan> winterstream: the IO monad represents IO actions, doesn't run it
20:00:27 <chessguy> ok, apparently i misunderstood the docs
20:00:35 <winterstream> yeah
20:00:35 <Saizan> *them
20:00:38 <dons> ?bot
20:00:39 <lambdabot> :)
20:00:50 <dons> ?join #haskell-icfp07
20:01:02 <winterstream> Saizan: okay, I'm with you (well, sort of :))
20:01:34 <Saizan> winterstream: so, what's the problem with until_?
20:02:45 <winterstream> Saizan: I just don't understand why the actions passed to until_ will be executed every time. What's stopping the compiler from going "oh, well, we're passing the same arguments as we did before, so we don't need to recompute everything"?
20:03:09 <banbh> dons: i tried hs-plugins from darcs and ran into problems.  i get Plugin.hs:2:19: Not in scope: `main'
20:03:10 <banbh> Bar: compile failed.  (I called application "Bar")
20:03:21 <pjd> one way to think of the IO monad is that it just strings functions together using dependencies
20:03:36 <banbh> dons: no doubt i'm doing something stupid
20:04:19 <pjd> so the top-level IO value represents a "pure" description of an imperative program, composed of smaller imperative programs
20:04:31 <dons> ?users
20:04:32 <lambdabot> Maximum users seen in #haskell: 340, currently: 335 (98.5%), active: 16 (4.8%)
20:04:37 <dons> hah
20:04:38 <pjd> which is more or less what gets compiled to imperative code
20:04:45 <banbh> dons: sorry, i should add that i typed in the example from section 11 in the docs
20:04:48 <dons> banbh: hmm. can't say much about that error
20:04:54 <pjd> winterstream: have you read IO Inside?
20:04:54 <dons> does the test suite run?
20:04:59 <winterstream> pjd: I get that, but I don't see what forces the re-evaluation of the actions in the Monads passed to until_
20:05:00 <banbh> yes
20:05:00 <ddarius> dons: Hack lambdabot's state to 368...
20:05:01 <Saizan> yes, and >>= ties those smaller programs in a way that's impossible for them to not be executed
20:05:13 <dons> yeah, we had a blackout unfortunately
20:05:17 <Saizan> ?type (>>=)
20:05:19 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
20:05:27 <banbh> dons: they all passed -- i think just one error related to HOopenGL
20:05:29 <winterstream> pjd: no, not yet. I'm still a Haskell neophyte.
20:05:54 <pjd> good reading: http://haskell.org/haskellwiki/IO_inside
20:05:55 <dons> banbh: are you trying to compile the plugin to an executable?
20:05:56 <lambdabot> Title: IO inside - HaskellWiki
20:06:00 <dons> instead of -c (i.e. a .o file?)
20:06:04 <banbh> dons: yes
20:06:24 <dons> well, that won't work :) you'll neeed a 'main 'to make an executable
20:06:46 <pjd> winterstream: it's the >> operator
20:06:49 <winterstream> pjd: I get that Monads are used to introduce dependencies and that they can hide state. I would just like to see where the necessary dependencies are introduced in until_
20:06:59 <winterstream> pjd: okay...
20:07:05 <ddarius> winterstream: Going along Saizan's and pjd's description, you could view the IO action as putting together a script so when you write foo >> bar you get something like (Seq DoFoo DoBar)  DoBar is just a value that's part of a script it can be shared all it wants.
20:07:06 <banbh> dons: i think I misunderstood your question.  I get the error after simply executing the Application
20:07:42 <dons> hmm. the docs might be out of date. check the testsuite programs perhaps
20:07:49 <banbh> dons: i.e., before it gets to the "shell" line
20:07:50 <dons> i don't really have time to maintain hs-plugins unfortunately.
20:07:58 <dons> what needs to happen is for it to be ported over to the ghc-api
20:08:05 <banbh> dons: ok.  thanks
20:08:14 <dons> which will make it both easier to maintain, more flexible, and more stable
20:08:36 <pjd> here's something to consider:
20:08:37 <pjd> > let x = print "foo!" in x >> x >> x
20:08:39 <lambdabot>  <IO ()>
20:09:12 <pjd> that will print "foo!" 3 times in ghci
20:09:15 <Saizan> winterstream: basically it's true that you share your action because it's always the same value, but you don't share it's execution because that happens later, after the actions are stringed together
20:09:45 <pjd> so basically, every IO value is a first-class referentially transparent "action" (imperative program)
20:10:16 <pjd> that you can run as few or as many times as you want by binding it into the top-level IO value with >> or >>=
20:10:29 <winterstream> Oh wait
20:10:37 <winterstream> there is the beginning of understanding for me...
20:10:43 <winterstream> binding it to the top-level IO
20:11:00 <winterstream> Heh. That's crucial for me to get...
20:11:10 <pjd> bingo :)
20:11:21 <winterstream> They we're just "dangling" in my mind, so I couldn't get why those actions would get triggered
20:11:26 <ddarius> You can view the runtime system as an interpreter for a script named by main.
20:11:48 <winterstream> pjd++
20:12:16 <winterstream> Shouldn't there be a Karma monad for this channel?
20:12:17 <winterstream> he he
20:12:23 <dons> ?bug
20:12:23 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
20:12:27 <ddarius> @karma pjd
20:12:27 <lambdabot> pjd has a karma of 1
20:12:35 <winterstream> I'm sure that's a tired joke
20:13:15 * SamB_XP_ tries to do a heap profile and has to ssh in to kill the program...
20:13:15 <pjd> no one has monad about it before
20:13:20 * pjd ducks
20:13:30 <winterstream> ha ha ha
20:13:36 <winterstream> oh dear
20:13:37 <jfredett> ...
20:13:47 <winterstream> Incorrigible punster. I'll try not to incorrige you
20:14:02 <pjd> i will yield to no punishment
20:14:53 * winterstream takes a moment to get into the zen of Monads
20:15:05 <crazy_coder> @karma crazy_coder
20:15:05 <lambdabot> You have a karma of 0
20:15:15 <Korollary> @karma java
20:15:16 <lambdabot> java has a karma of -16
20:15:31 <jfredett> @karma haskell
20:15:31 <lambdabot> haskell has a karma of 24
20:15:39 <ddarius> java++
20:15:43 <ddarius> @karma java
20:15:44 <lambdabot> java has a karma of -16
20:15:53 <jfredett> pwned?
20:15:57 <winterstream> I think the concept of the Monad is amongst the most profound concepts I've ever learned about
20:16:03 <winterstream> Ha ha! Poor Java.
20:16:07 <pjd> oh, it gets better :)
20:16:12 <Manyfold> @karma prolog
20:16:12 <lambdabot> prolog has a karma of -1
20:16:17 <crazy_coder> Which other language has monad concept ?
20:16:19 <winterstream> @karma scala
20:16:19 <lambdabot> scala has a karma of 0
20:16:23 <jfredett> @karma lisp
20:16:23 <lambdabot> lisp has a karma of -1
20:16:24 <winterstream> @karma c++
20:16:24 <lambdabot> c++ has a karma of -6
20:16:30 <pjd> the nice thing about monadic IO is that you can do stuff like x3 = x >> x >> x
20:16:33 <jfredett> boo, lisp is better than -1
20:16:34 <ddarius> crazy_coder: It's not built in.
20:16:37 <winterstream> Hey, why is Java worse than C++.
20:16:40 <jfredett> @karma scheme
20:16:40 <lambdabot> scheme has a karma of -1
20:16:43 <winterstream> LISP! Ha ha ha
20:16:44 <pjd> and treat x3 as a new primitive action
20:16:47 <jfredett> @karma javascript
20:16:47 <lambdabot> javascript has a karma of 0
20:17:01 <winterstream> @karma boo
20:17:02 <lambdabot> boo has a karma of 0
20:17:05 <crazy_coder> @karma C
20:17:05 <lambdabot> C has a karma of 2
20:17:15 <ddarius> @karma scheme
20:17:16 <lambdabot> scheme has a karma of -1
20:17:19 <winterstream> @karma erlang
20:17:19 <lambdabot> erlang has a karma of 0
20:17:20 <crazy_coder> @karma python
20:17:21 <lambdabot> python has a karma of -1
20:17:22 <Saizan> pjd: yeah, and that makes haskell the more flexible imperative language ever :)
20:17:27 <crazy_coder> @karma ruby
20:17:27 <lambdabot> ruby has a karma of 0
20:17:28 <pjd> yep!
20:17:36 <winterstream> @karma ocaml
20:17:37 <lambdabot> ocaml has a karma of 0
20:17:44 <winterstream> @karma ml
20:17:44 <lambdabot> ml has a karma of 0
20:17:53 <pjd> (lambdabot does /msg, you know :)
20:18:01 <winterstream> ha ha ha
20:18:04 <winterstream> Okay
20:18:10 <crazy_coder> What are the things Haskell is not good at ?
20:18:19 <sfultong> @karma joy
20:18:19 <lambdabot> joy has a karma of 0
20:18:21 <jfredett> crazy_coder: being sucky
20:18:22 <winterstream> Buggy code
20:18:25 <crazy_coder> heh
20:18:29 <jfredett> Haskell is horrible at being sucky
20:18:30 <Korollary> Object orientation
20:18:44 <sfultong> didn't someone write an extension for that?
20:18:46 <jfredett> Korollary: you dont need OO in haskell, or any functional language really
20:18:54 <Korollary> jfredett: I didn't say you needed it.
20:18:56 <jfredett> and if you do, theres always O'Haskell
20:18:57 <pjd> crazy_coder: monads are actually all over the place in other languages (with varying degrees of implicitness), once you know what to look for
20:19:03 <sfultong> OO is silly, imvho
20:19:11 <winterstream> pjd: any pertinent examples?
20:19:38 <jfredett> OO is only useful if you don't have all the nifty power that is functional programming
20:20:02 <crazy_coder> like which aspect of programming is difficult to implement in Haskell- Networking, AI ?
20:20:15 <phoniq> enterprise haskell beans?
20:20:16 <Saizan> jfredett: if subtyping wasn't of any use we wouldn't have existential types :)
20:20:33 <jfredett> Saizan: you just outgeeked me, what?
20:20:51 <Korollary> There's no outgeeking here.
20:20:58 <Korollary> Geekery has maxed out.
20:21:29 <jfredett> but I'm only a level 12 sorcerer! Saizan is at _least_ level 15!
20:21:36 <jfredett> he's totally outgeeking me
20:21:40 <Korollary> What's important is to participate
20:21:59 <crazy_coder> are you talking about ICFP ?
20:22:01 <Saizan> jfredett: well you might want to treat a bunch of types with the same interface as if they were one single type
20:22:14 <Korollary> No, I mean participating in geekitude
20:22:20 <jfredett> ah- eg Type Classes
20:22:22 <Saizan> jfredett: e.g. a list of Showable values
20:23:00 <jfredett> vis a vis, foo :: Num a => a -> a -> a , then foo is any closed binary function over the Numbers.
20:23:01 <Saizan> you can have Show a => [a] but you can't put Int and Char in those same list, because a is only one single type at a time
20:23:03 <winterstream> Any ideas as to where one would find implicit Monads in other languages?
20:23:22 <crazy_coder> whats the difference between arrays in Haskell and lists - apart from the fact that arrays are list of tuples
20:23:27 <jfredett> right- okay- i just wasn't familiar with the terminology
20:23:37 <pjd> i think things like call stacks, exceptions, continuations, and backtracking are often monadic, in the abstract
20:23:51 <Korollary> winterstream: Not very easy. You can find them explicitly, though. They've been implemented for many other languages, but not used much really.
20:23:56 <ddarius> Saizan: Existential types have nothing to do with subtyping.
20:23:58 <Saizan> so you write data Showable = forall Show a => S a, and then you can have [S 1,S "foo",S (Just 1)]
20:24:06 <pjd> the best concrete example i know of is Twisted's Deferred
20:24:19 <winterstream> I'll look into that
20:24:40 <jfredett> why would that be useful?
20:24:54 <jfredett> couldn't I just tie that up in the type signature?
20:25:07 <Saizan> ddarius: why not?
20:25:09 <jfredett> as a type variable?
20:25:19 <pjd> explicit monads are also used quite a bit: http://haskell.org/haskellwiki/Monad#Monads_in_other_languages
20:25:20 <lambdabot> Title: Monad - HaskellWiki
20:25:31 <ddarius> Saizan: Nothing is a subtype of anything there and you can have subtyping without existential types.
20:25:32 <Saizan> jfredett: in [a] a can be only one type at a time
20:25:37 <jfredett> OH!
20:25:42 <jfredett> Brilliant.
20:25:45 <jfredett> i get it
20:25:48 <winterstream> What confused me with Monads - and I don't know how many others got confused by this - is that Monads seem to serve two purposes in Haskell. 1. They get around the laziness by introducing evaluation dependencies and 2. they keep language pure.
20:26:00 <jfredett> so you have have heterogenous lists
20:26:03 <pjd> that's probably more the IO monad, than monads in general :)
20:26:10 <winterstream> pjd: thanks, that's helpful
20:26:12 <ddarius> They don't do 1
20:26:22 <ddarius> and for the most part they don't really do 2
20:26:31 <winterstream> oh?
20:26:36 <Saizan> ddarius: i see it as instances of Show are subtypes of Showable
20:26:50 <pjd> monads are a pretty abstract err, abstraction, so monad instances can be very varied
20:26:58 <winterstream> ddarius: well then I'm totally confused
20:27:28 <ddarius> winterstream: They let you -express- a sequential ordering, but they don't enforce it.
20:27:35 <pjd> i think the intent of what winterstream said is right
20:27:37 <Saizan> jfredett: yes, but in that way you lose every knowledge of the "real" type of your elements
20:27:41 <winterstream> pjd: yeah, the abstraction makes them hard to "get"
20:27:56 <ddarius> E.g. the Id monad is just as lazy as normal Haskell (it -is- normal Haskell).
20:28:09 <jfredett> i see
20:28:14 <pjd> have you looked at the Maybe or List monads yet?
20:28:16 <winterstream> ddarius: oh, yeah, I get that :)
20:28:29 <jfredett> so theoretically, could I do something like
20:28:36 <winterstream> pjd: I saw them in some papers
20:28:45 <jfredett> oh nevermind,
20:28:50 <jfredett> i figured it out
20:28:52 <winterstream> There was a paper with Category maths explaining Monads
20:29:04 <winterstream> goodness, I still haven't worked my way through that paper
20:29:05 <ddarius> Saizan: If instances of Show were subtypes of Showable then I should be able to use an instance of Show (practically everything) anywhere something needs a Showable.
20:29:10 <winterstream> it was on lambda-the-ultimate a while ago
20:29:31 <Saizan> ddarius: and can't i do that?
20:29:38 <pjd> do you know the Lisp/Scheme non-deterministic amb operator?
20:29:42 <ddarius> Saizan: Not without an explicit "conversion"
20:29:53 <winterstream> pjd: I know a bit about it
20:30:15 <pjd> the list monad is like it
20:30:17 <ddarius> An anyways this is mostly a property of type classes rather than existential types.
20:30:48 <winterstream> pjd: Interesting. I'll look into it now...
20:38:55 <Saizan> mmh maybe the OO languages i know gave me a bad idea about subtyping, but Showable really looks like a superclass and S is just an explicit upcast
20:40:44 <ddarius> Saizan: By that logic, String is also a superclass of all instances of Show.
20:41:15 <ddarius> And Haskell already supports, e.g. row subtyping because I can always write a function (a,b) -> (a,b,c)
20:41:52 <ddarius> Existential types are an important part of object-oriented languages (behind the scenes), but so is subtyping as a distinct thing.
20:43:24 <Saizan> row subtyping?
20:43:27 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/1848#a1
20:43:43 <jfredett> thats the most abstract paste ever
20:43:52 <mnislaih> why does that not work like many ?
20:43:56 <jfredett> anon, no title, no title... :/
20:44:03 <mnislaih> sorry, I didnt plan to announce
20:44:19 <mnislaih> also, I'm in a bad hurry !
20:44:26 <jfredett> no worries
20:45:14 <ddarius> Saizan: A round-about way of saying sub-records, or record subtyping.
20:46:25 <Saizan> mnislaih: what does that do?
20:46:25 <jfredett> mnislaih: I honestly have no idea
20:46:46 <mnislaih> it is a custom instance for readList, to read all elements without separators
20:47:00 <mnislaih> I want to replicate the 'many' combinator from monadic parser combinators
20:47:39 <mnislaih> I should have used readP, but I am not familiar
20:47:47 <mnislaih> and I wanted to save time, huh
20:47:58 <Saizan> yes, that i see, but what's wrong with it?
20:48:04 <mnislaih> it always fails
20:48:14 <mnislaih> even if the parser for the individual element succeeds
20:48:38 <ddarius> You don't have any end case.
20:48:51 <ddarius> You read and read until reads fails which causes the whole thing to fail.
20:49:16 <mnislaih> nope, I can add an end case, it still wont work
20:49:19 <mnislaih> consider
20:49:31 <mnislaih> > [a:b | a <- [1], b <- []]
20:49:33 <lambdabot>  []
20:49:50 <mnislaih> that should return 1, in the many combinator
20:49:59 <banbh> dons: regarding hs-plugins, looking at the testsuite solved my problem. it turns out i was passing the first two params to makeWith in the wrong order.  i'm not completely sure what the problem was, but flipping the params fixed it.  thanks!
20:50:39 <ddarius> mnislaih: How is the list ever terminated, how does it get a [].
20:51:06 <mnislaih> usually 'read' will return a single element, and a long list of text to continue parsing
20:51:13 <mnislaih> 'reads' I mean
20:51:29 <mnislaih> ddarius: did I understand you ?
20:51:54 <ddarius> mnislaih: No.  You can view it using monadic notation and things may be clearer.
20:52:35 <ddarius> readList txt = do (x,rest1) <- reads txt; (xs,rest) <- readList rest1; return (x:xs,rest)
20:52:43 <ddarius> You never return []
20:53:11 <mnislaih> why? when 'fail' is implicitly called
20:53:20 <ddarius> fail fails
20:53:26 <mnislaih> fail = []
20:53:31 <mnislaih> @src fail []
20:53:31 <lambdabot> Source not found. You speak an infinite deal of nothing
20:53:34 <mnislaih> ack
20:53:36 <Saizan> when reads return []
20:53:37 <ddarius> You want to succeed with an empty list, not fail.
20:53:48 <ddarius> You want readList txt = (do (x,rest1) <- reads txt; (xs,rest) <- readList rest1; return (x:xs,rest)) `mplus` return ([],txt)
20:54:48 <mnislaih> that's right
20:55:04 <mnislaih> but I didn't understand your reasoning, since fail = []
20:55:31 <ddarius> You don't want [], you want [([],txt)]
20:55:42 <mnislaih> exactly
20:55:48 <mnislaih> thanks ddarius
20:59:56 <Saizan> ddarius: so [(x:xx, rest') | (x,rest1) <- reads txt, (xx,rest') <- readList rest1  ]  ++ [([],txt)] ?
21:00:32 <Saizan> > let readL txt = [(x:xx, rest') | (x,rest1) <- reads txt, (xx,rest') <- readList rest1  ]  ++ [([],txt)] in readL "123456"
21:00:40 <lambdabot>  [([],"123456")]
21:01:03 <Saizan> > let readL txt = [(x:xx, rest') | (x,rest1) <- reads txt, (xx,rest') <- readList rest1 ++ [([],txt)] ] in readL "123456"
21:01:05 <lambdabot>  [([123456],"123456")]
21:01:11 <Saizan> > let readL txt = [(x:xx, rest') | (x,rest1) <- reads txt, (xx,rest') <- readList rest1 ++ [([],[])] ] in readL "123456"
21:01:12 <lambdabot>  [([123456],"")]
21:01:22 <Saizan> ooh, this makes more sense..
21:02:10 <sfultong> >  (\(x, y) -> case (x, y) of ((-50), _) -> "right"; (50, _) -> "left"; (_, (-50)) -> "down"; _ -> "up")) (0, 50)
21:02:11 <lambdabot>  Parse error
21:02:26 <sfultong> >  (\(x, y) -> case (x, y) of ((-50), _) -> "right"; (50, _) -> "left"; (_, (-50)) -> "down"; _ -> "up") (0, 50)
21:02:28 <lambdabot>  "up"
21:04:05 <sfultong> wait... are functions not evaluated in pattern matching in case statements?
21:05:10 <Saizan> ?
21:06:35 <sfultong> > let blarg = 5 in (\x -> case x of blarg -> "hmm"; 6 -> "ok"; _ -> "weird") 6
21:06:36 <lambdabot>      Warning: Pattern match(es) are overlapped
21:06:36 <lambdabot>              In a case alterna...
21:07:02 <Saizan> you normally can't put a function in a pattern, unary minus is a bit special like all numeric literals patterns
21:07:41 <sfultong> what a nuisance
21:07:53 <Saizan> sfultong: you can't do that, there you are just rebinding blarg to the value of x
21:08:07 <sfultong> yeah, I figured that out... the hard way, as always
21:08:09 <Saizan> you can use guards though
21:08:25 <sfultong> what's the syntax for guards in case statements again?
21:08:32 <sfultong> just like function guards?
21:08:39 <Saizan> > let b = 5 in case 5 of x | x == b -> 7
21:08:41 <lambdabot>  7
21:08:49 <Saizan> yes
21:08:49 <sfultong> ah, thanks
21:11:06 <sfultong> (\x -> case x of x | x == 5 -> "fun"; x | x == 6 -> "sad"; _ -> "confused") 5
21:11:38 <Saizan> > (\x -> case x of x | x == 5 -> "fun" | x == 6 -> "sad"; _ -> "confused") 5
21:11:40 <lambdabot>  "fun"
21:11:48 <sfultong> heh, thanks
21:12:00 <sfultong> so you can reuse identifiers
21:12:15 <sfultong> makes the case statement look redundant
21:12:16 <Saizan> yes, one pattern can have many guards
21:12:31 <brad__> can the length of a tuple be queried? i.e. is there an equivalent of "length" for tuples?
21:12:54 <sfultong> brad__: if you'd like to write such a function :)
21:13:14 <TSC> brad__: It's implicit in the type
21:13:36 <pjd> explicit, even
21:13:40 <ddarius> > let readL txt = [(x:xs, rest') | (x,rest1) <- reads txt, (xx,rest') <- readList rest1] ++ [([],txt)] in readL "1 2 3 4 )("
21:13:41 <lambdabot>   Not in scope: `xs'
21:13:45 <sfultong> actually... you probably couldn't write such a function
21:13:50 <ddarius> > let readL txt = [(x:xs, rest') | (x,rest1) <- reads txt, (xs,rest') <- readList rest1] ++ [([],txt)] in readL "1 2 3 4 )("
21:13:51 <lambdabot>  [([],"1 2 3 4 )(")]
21:14:07 <ddarius> > let readL txt = [(x:xs, rest') | (x,rest1) <- reads txt, (xs,rest') <- readL rest1] ++ [([],txt)] in readL "1 2 3 4 )("
21:14:08 <lambdabot>  [([1,2,3,4]," )("),([1,2,3]," 4 )("),([1,2]," 3 4 )("),([1]," 2 3 4 )("),([]...
21:14:40 <brad__> i guess what i am trying to do is take a type of [String] and make it into a type of my own creation, a tuple. but i would like to signal an error if the [String] doesn't have the right number of members...without having to hardcode the number of members of my type
21:15:24 <ddarius> Use a typeclass.
21:16:04 <brad__> okay ddarius, thanks, i will need to do a little digging to figure them out
21:16:59 <ddarius> doh
21:24:13 <dons> Get your HWN! http://sequence.complete.org/hwn/20070723 :)
21:24:15 <lambdabot> Title: Haskell Weekly News: July 23, 2007 | The Haskell Sequence
21:25:29 <dolio> @yow
21:25:30 <lambdabot> I'm meditating on the FORMALDEHYDE and the ASBESTOS leaking into my
21:25:30 <lambdabot> PERSONAL SPACE!!
21:26:08 <ddarius> Holy crap!
21:30:40 <phoniq> > readFile "foo" >>= (\x -> x ++ x) >>= putStr
21:30:41 <lambdabot>  Couldn't match expected type `IO' against inferred type `[]'
21:30:59 <phoniq> is there some lift-fu i'm missing there?
21:31:28 <phoniq> just to stick a function String -> String in between readFile and putStr
21:32:57 <Ytinasni> (\x -> return (x ++ x))
21:33:11 <Ytinasni> > readFile "foo" >>= (\x -> return (x ++ x)) >>= putStr
21:33:12 <lambdabot>  <IO ()>
21:33:14 <phoniq> oh man
21:33:16 <Ytinasni> :D
21:33:23 * phoniq laught
21:33:26 <phoniq> laughs
21:33:31 <phoniq> i've been staring at this forever
21:33:33 <dons> we have type systems for a reason :)
21:33:35 <phoniq> thanks
21:33:48 <phoniq> :)
21:35:09 <phoniq> voom.  there it is.
21:35:21 <Figs> O.o .... o.O
21:35:24 <Figs> Me?!
21:35:26 * Figs hides
21:35:32 <phoniq> no, no, a tip i just got.
21:35:38 <Figs> oh :P
21:35:41 <slava> http://emilliken.blogspot.com/2007/07/simple-haskell-malware-x11-keylogger.html
21:35:46 <lambdabot> Title: Functional Programming, Computer Security: A simple Haskell malware: X11 keylogg ..., http://tinyurl.com/36wpox
21:35:54 <dons> cute eh, slava ? who'd have thought :)
21:36:10 <dons> emilliken has written quite a few interesting low-level haskell posts
21:36:25 <slava> dons: now statically-typed malware which is provably correct would be something
21:36:30 <dons> heh
21:36:33 <slava> i want to learn about raw sockets
21:36:40 <slava> i just saw incidentally a reddit link about haskell and raw sockets
21:36:58 <slava> i've always wondered how ping works ;)
21:37:06 <dons> something here probably, http://haskell.org/haskellwiki/Blog_articles/Network
21:37:07 <lambdabot> Title: Blog articles/Network - HaskellWiki
21:37:11 <dons> yeah, he wrote some other tcp stuff
21:37:28 <slava> ping isn't tcp, its icmp
21:37:37 <dons> and seems to be using haskell for ethernet-layer stuff in that other blog post
21:38:12 <dons> slava: yeah, just saying that the same guy has written a few topics on lower layer network things. an echo server, ether frames etc
21:38:32 <bos> raw sockets aren't terribly interesting.
21:38:41 <glguy> dons: are ports similar to a dupped Chan?
21:38:56 <dons> glguy: i think they're related, and you've got threads running. check the (oldish) paper
21:39:15 <bos> yes, ports are similar to Chans.
21:39:18 <dons> glguy: and you can plug them into tcp sockets, which manuel does when running clusters of little haskell nodes
21:39:23 <dons> talking to each other via ports
21:39:27 <glguy> cool
21:40:05 <slava> is there a high-level haskell interface to select(2), epoll(2) or kqueue(2)?
21:40:10 <bos> at least if we're talking about the huch/stolz port stuff.
21:40:24 <bos> slava: the handle IO system uses them under the hood.
21:40:36 <bos> well, more to the point, it uses select.
21:40:38 <dons> slava: yeah, forkIO is select. epoll is done via the unified events/threads lib
21:40:51 <slava> ah, ok
21:41:11 <bos> for event-based IO, there's a proposal to switch over to something chung-chieh shan and a few students are cooking up.
21:41:46 <dons> yeah, that's the epoll layer, http://haskell.org/haskellwiki/Applications_and_libraries/Concurrency_and_parallelism#Unified_events_and_threads
21:41:48 <lambdabot> Title: Applications and libraries/Concurrency and parallelism - HaskellWiki, http://tinyurl.com/2u95za
21:42:35 <bos> yep.
21:45:14 <glguy> airlines are great, yo uget a different price each time you refresh the search
21:45:31 <glguy> its like rerolling your D&D character until your stats are high enough
21:45:34 <dons> bos, is SPJ's OSCON talk today?
21:45:45 <dons> glguy: heh
21:46:07 <notadev> hehe
21:46:09 <wli> dons: I marched through YAHT today. I did all the exercises in it.
21:46:15 <glguy> the price has varied from 370 to 510
21:46:28 <notadev> so.. not quite the same then ;)
21:46:35 <dons> glguy: i noted that my 1 way ticket to Portland was 5% less than my return ticket in April :}]
21:46:59 <dons> wli, cool. so you can write some libs now? :)
21:47:21 <SamB> dons: he already made me write one
21:47:24 <wli> dons: Not quite. I need more monad exercises.
21:47:44 <SamB> which I will soon send the deriving to ndm for
21:47:52 <notadev> write a monad for graph generation then wli :-)
21:48:04 <wli> notadev: What kinds of graphs?
21:48:13 <SamB> and then I will post it on teh intarhackage
21:48:19 <notadev> any; you know any graph theory?
21:48:33 <SamB> wli: pi graphs!
21:48:37 <wli> notadev: Mostly as it pertains to counterinsurgency.
21:48:40 <notadev> good way to learn it if you don't :)
21:48:44 <notadev> hehe
21:48:50 * SamB is punning there
21:48:51 <notadev> k how much math?
21:49:06 <wli> notadev: Not much.
21:49:09 <notadev> graph theory is simple anyhow
21:49:15 <notadev> easier than trig
21:49:15 <SamB> I think there actually is at least one kind of mathematical graph you could call that
21:49:26 <wli> notadev: The counterinsurgency bits are all eigenvector centrality lameness.
21:49:38 <notadev> well your fine then ;)
21:49:43 <notadev> you're*
21:50:12 <SamB> dons: he mentioned #1, #2, #3 etc.
21:50:31 <notadev> hmm look at trees first, wli. say a maxiphobic one?
21:50:45 <wli> notadev: I don't know those.
21:51:04 <notadev> just binary trees then to start
21:51:26 <SamB> my dog is making really wierd noises
21:51:35 <notadev> depth-first and breadth-first sweeps
21:51:36 <SamB> she must be dream-barking
21:51:48 <notadev> yeah they do that
21:52:10 <notadev> er sweeps=traversal in CS-speek
21:52:25 <ddarius> SamB: Yeah, it happens.
21:52:31 <wli> notadev: IIRC Data.Graph has all that floating around.
21:52:42 <SamB> because it sounds a bit like barking except for being way quieter than normal ;-)
21:52:51 <notadev> wli: go for it ;)
21:53:29 <wli> notadev: I'm still trying to make sense of the monad transformer stuff I did earlier today.
21:53:43 <notadev> k; is it pasted anywhere?
21:53:55 <wli> notadev: I'll paste momentarily.
21:54:00 <notadev> cool :)
21:54:38 <bos> dons: he has talks tomorrow (monday our time) and wednesday.
21:54:45 <bos> don't know which is when.
21:55:03 <bos> wli: you're in portland, right?
21:55:04 <notadev> heh it's monday morning :-)
21:55:33 <andyjgill> Who is going to be in portland this week?
21:55:58 <bos> myself and CosmicRay, don't know of any other haskellers
21:56:24 <hpaste>  wli pasted "YAHT Ex. 9.5" at http://hpaste.org/1849
21:56:33 <notadev> what's in portland then?
21:56:37 <bos> OSCON
21:56:43 <notadev> ah ok
21:56:57 <wli> bos: Yeah, I'm in PDX, but I'm not going to OSCON that I'm aware of.
21:57:02 <bos> andyjgill: should i pop out to beaverton and say hello?
21:57:36 <andyjgill> Sure. please do. Why are you in PDX? I assumed it was for OSCON
21:57:42 <bos> yes, for OSCON.
21:57:51 <wli> notadev: I don't completely understand how/why it works.
21:57:53 <bos> flying out tomorrow evening.
21:58:31 <dons> I wonder if Adam Turoff will be there too, given the onlamp articles
21:58:40 * andyjgill realized I confused wli and bos's comments
21:58:43 <bos> he was last year
21:58:50 <notadev> wli: tbh i am a C coder, so not the guy to ask ;)
21:59:04 <wli> notadev: Join the club.
21:59:25 <notadev> heh cool :-)
22:00:08 <bos> dons: i just asked him if he's going
22:03:36 <bos> andyjgill: is there a day or time that would be likely to suit?
22:03:58 <andyjgill> How long are you in town?
22:04:11 <bos> monday night until thursday evening.
22:05:22 <andyjgill> Are you going to SLPJ's talk on thursday?
22:06:03 <bos> is he talking on thursday? i thought just wednesday.
22:06:18 <andyjgill> He is talking at Galois on Thursday
22:06:36 <andyjgill> Open invite; we've booked a larger room.
22:06:52 <bos> oh, i see.
22:07:10 <bos> yes, that would make sense.  what's the topic?
22:07:16 <bos> or what time, for that matter?
22:07:20 <hpaste>  dolio annotated "YAHT, Exc. 4.6, Try 2" with "evil" at http://hpaste.org/1832#a4
22:07:38 <ddarius> dons: You didn't like the first line of Turoff's 2nd article, "General purpose programming languages can be divided into two broad categories: Haskell and everything else."
22:07:56 <dons> ddarius: i thought that was good :)
22:08:04 <dons> ah, you mean, it didn't make the quotes?
22:08:21 <SamB> who is turrof?
22:08:28 <SamB> er.
22:08:36 <SamB> turoff
22:10:01 * glguy reminds #haskell to label and sign hpastes
22:10:16 <wli> I wonder if most of the time things want to shove IO down to being the innermost monad when it's involved.
22:10:42 <dons> glguy: maybe it should refuse till you put in a label and name?
22:10:59 <SamB> at least one or the other
22:11:05 <glguy> the kind of people who can't be bothered to fill out the form properly are the kind of people that put garbage in require fields
22:11:14 <glguy> this way I can spot them for deletion easier
22:11:46 <glguy> bos: I believe that the topic was light weight concurrency primatives in GHC
22:12:39 <bos> glguy: huh?
22:12:50 <bos> oh, spj's talk.
22:13:33 <glguy> bos: oh, nvm I think it is over STM
22:13:53 <Heffalump> http://research.microsoft.com/%7Esimonpj/papers/lw-conc/index.htm
22:13:55 <lambdabot> Title: Lightweight concurrency primitives for GHC
22:13:59 <glguy> and it is 10:30 to noon
22:14:06 <glguy> bos: yes, SPJ's talk
22:14:49 <bos> glguy: cool, thanks.
22:17:06 <glguy> are there other DVCS tools like darcs that let you cherry-pick patches?
22:22:19 <dons> roconnor on his own is at #20 in the icfp contest :)
22:22:50 <dolio> Impressive.
22:24:51 <glguy> darcs annotate is cool, but at least on our project it requires to much memory to succeed
22:24:56 <ddarius> bos: My rope library is farther along, but I still need to think up a good way to rebalance.
22:25:00 <glguy> (in the course of a day)
22:25:19 <bos> ddarius: yes, rebalancing is the only tricky thing :-)
22:25:43 <glguy> dons: the Galois soccer team had a new lower-bound on goals against
22:25:47 <bos> glguy: mercurial has an extension called transplant for cherrypicking
22:25:55 <dons> glguy: oh, what's the bound now?
22:25:58 <glguy> 6
22:26:02 <dons> argh :}
22:26:09 <dons> goals-for is at?
22:26:13 <glguy> upper bound 3
22:26:18 <glguy> today, 0
22:26:36 <glguy> which implies we've never won, of course
22:26:41 <dons> ah well
22:26:44 <glguy> still fun
22:26:47 <dons> yeah!
22:26:50 <ddarius> bos: There are some other tricky parts.  Luckily I made a toLazyByteString function which lets me steal ByteString's Eq and Ord instances.
22:27:28 <bos> ddarius: nice workaround :-)
22:28:31 <glguy> bos: I noticed you were in #mercurial earlier, do you know enough about darcs to know why you like hg better? do you?
22:28:45 <Heffalump> I imagine hg is more reliable, somehow :-)
22:28:46 <dons> bos wrote a book on hg, iirc :)
22:28:59 <glguy> We might be switching source control at work, and if we are switching off darcs, I want to make sure I know some alternatives from svn
22:29:28 <dons> Heffalump: is darcs fading now, at this point, due to lack of developers?
22:29:29 <glguy> (switching on a specific project)
22:29:54 <Heffalump> it has people, it just seems that the nasty problems don't get fixed
22:30:06 <Heffalump> I don't pay very close attention
22:30:07 <bos> glguy: yes, i know quite a lot about mercurial. i've probably written about 15% of it, and a book about it.
22:30:25 <bos> and i use darcs a lot, too.
22:30:27 <Heffalump> I use it happily for personal stuff, but Lennart has all sorts of problems with it at work (on 'doze)
22:30:42 <Heffalump> and I know the GHC team has all kinds of trouble with it including bugs that don't seem to get fixed
22:30:45 <dons> Heffalump: i wouldn't be surprised if we saw, say, ghc switch away from darcs at some point
22:30:49 <SamB> Heffalump: I don't think those are the *nasty* problems
22:31:00 <Heffalump> the conflicts problem is the biggy, obviously
22:31:06 * Heffalump is hoping lispy manages to sort that
22:31:11 <glguy> bos: what are some of the compelling advantages of hg over darcs?
22:31:11 <SamB> I think the nasty problems are heisenbugs
22:31:14 <dons> Heffalump: maybe you can convince lennart to reimplement darcs from scratch..
22:31:26 <Heffalump> I think he's a bit busy for that :-)
22:31:40 * glguy hopes these questions aren't taken in the same way: Why is Haskell better than X language
22:31:45 <bos> glguy: i don't really like the philosophy behind darcs, the soup of patches, so that's kind of a big stumbling block.
22:31:48 <dons> i guess a consolidation of the distributed rcs market was inevitable
22:31:51 <Heffalump> the problem is heisenbugs that corrupt the repo and then only become obvious later
22:32:11 <ddarius> dons: It's consolidating?  And on what?
22:32:21 <dons> hg? svn (urgh)?
22:32:24 <bos> glguy: mercurial is several orders of magnitude faster than darcs, which makes a big difference to how one does revision control.
22:32:24 <dolio> git, of coruse. :)
22:32:28 <Heffalump> hopefully not git :-(
22:32:45 <glguy> bos: I like that I can back port fixes to a release line from a head line without much intervention
22:32:48 * Heffalump things the soup of patches abstraction is really nice, if the conflicts problem can be solved properly
22:32:55 <glguy> bos: I don't know if that is something unique to darcs though
22:33:05 <dons> really, someone should analyse what all the rcs are doing, and do one good one, a 20 year rcs. we understand the theory now
22:33:09 <bos> glguy: yeah. all the dvcs tools have some way to let you do that.
22:33:15 <glguy> ok, cool
22:33:40 * dons <3 first class patches
22:34:32 <glguy> I haven't experience speed problems with darcs beyond the initial checkout
22:34:37 <glguy> expect with "annotate"
22:34:50 <glguy> on a large repository, it just wouldn't run
22:35:02 <Heffalump> dons: I don't think we do.
22:35:10 <Heffalump> (understand the theory)
22:35:25 <dons> didn't wouter et al sort that out? :)
22:35:27 <bos> glguy: the usual procedure for choosing a dvcs is to play around with one or two, read some blog postings, then develop a tight and irrational attachment to the one that you flipped a coin on, including post hoc justifications and lots of flaming :-)
22:35:32 <Heffalump> no :-)
22:35:42 <slava> bos: i thought that was programming languages
22:35:51 <dons> works for both, i think, slava :)
22:35:52 <glguy> bos: but there are so many to consider :-p I dont have a coin with that many sides!
22:35:53 <SamB> I thought it was to go with darcs, because all the other Haskell people use that
22:36:00 <dons> and for OS kernels
22:36:21 <SamB> dons: you use that to pick what kernel version to install?
22:36:23 <dons> yeah, darcs will be the rcs of choice for haskell for a few more years, even if nothing changes
22:36:23 <SamB> ;-P
22:36:38 <Heffalump> if ghc switches others might
22:36:58 * glguy wonders if anyone has used Bazaar
22:37:07 <SamB> some have developed an irrational attachment to their repositories
22:37:11 <SamB> glguy: is that like bzr?
22:37:14 <glguy> yeah
22:37:24 <SamB> what's the difference?
22:37:27 * bos has used it. it's slow.
22:37:33 <bos> bazaar is bzr.
22:37:34 <glguy> bzr is the commmand
22:37:38 <Heffalump> slower than darcs?
22:37:48 <bos> for initial checkout, yes.
22:37:58 <bos> much slower.
22:38:00 <glguy> speed on things like initial check out is one of my least concerns...
22:38:12 <ddarius> bos: I've been thinking about other rebalancing approaches, but I may end up going with Boehm's approach or a slight variation thereof.
22:38:33 <glguy> I think that that concern really depends on who you expect to want to download the repository
22:38:35 <ddarius> It does a good job keeping prebalanced subtrees.
22:38:43 <bos> ddarius: there's nothing like a nice juicy can of pickled thought to tempt a body.
22:39:01 <bos> glguy: what are your concerns, then?
22:39:05 <ddarius> I want to try to maximise sharing.
22:39:54 <ddarius> For not completely random reasons, zippers have come into my head.  I haven't even thought about them and what they might be useful for (if anything) in my implementation.
22:40:14 <SamB> ddarius: that will be great when you send it back to the beginning of the ICFP 2007 contest in guido's time machine
22:40:21 <glguy> bos: works in linux, cherry picking patches, works normally offline, ability to commit specific changes to one file and not others is big plus
22:40:32 <glguy> errr
22:40:39 <glguy> specific changes to one set of lines in one file
22:40:45 <ddarius> SamB: It sounds like lazy bytestrings or Data.Sequence Seq already were doing more than well enough.
22:41:00 <SamB> ddarius: possibly
22:41:42 <glguy> bos: seems like most systems have fast branching
22:41:47 <glguy> bos: so I don't worry about that as much
22:42:03 <ddarius> There are people hacking C and C++ and getting from 10 to a few thousand iteration/sec and faster ones using custom data structures, and then Haskell implementations using lazy byte strings or Seq's out-of-the-box and getting 20k-40k/sec
22:42:11 <bos> glguy: cherrypicking hunks within a single file is still unique to darcs.
22:42:33 <dons> that's odd, since its such an obvious feature
22:42:43 <dons> i use it all the time.
22:42:46 <glguy> it seems to me that that realy doesn't even need to be part of the DVCS system... just a wrapper
22:42:47 <SamB> I'm not switching then
22:42:59 <glguy> like someone could write it once
22:43:03 <bos> glguy: you're right. it's just a fiddly wrapper to write.
22:43:04 <glguy> and use it on all dvcs's
22:43:12 <bos> it would take, oh, hours. several of them.
22:43:28 <wli> Try darcs on the Linux kernel with full history.
22:43:32 <SamB> it would take many more hours to hook it up to all those vcs's
22:43:41 <SamB> (why only dvcs's? SVN c
22:43:46 <SamB> ould use that too!)
22:44:23 <glguy> are there compelling reasons to use a non-distributed VCS now?
22:45:03 <bos> glguy: binary assets, for things like games and chip design.
22:45:40 <bos> often, those files are too big to ship their histories around, and you're screwed if two people ever edit the same file, because you can't merge them.
22:45:50 <glguy> ah
22:46:01 <glguy> good point
22:46:17 <bos> that's why perforce is entrenched in the game industry: it handles big files tolerably well, andit lets you lock stuff.
22:47:02 <bos> many chip design companies write their own vcs tools, often several of them at a time.
22:47:14 <wli> bos: Is there anything unique about Linux apart from scale?
22:47:40 <bos> wli: no. it's not even very interesting from a scale perspective.
22:48:03 <wli> bos: My other burning question is why VCS's don't use normal databases.
22:48:16 <bos> lots of people, but the distributed nature of development doesn't really show up in the history.
22:48:34 <glguy> one thing could be that people like to be able to create a new repository without a lot of fuss
22:48:36 <bos> normal databases are orders of magnitude too slow. monotone uses sqlite, and its performance blows.
22:48:40 <glguy> "darcs init"
22:48:41 <glguy> done
22:48:41 <wli> bos: It's not interesting from a scale perspective? I thought a bunch of VCS's had trouble with the amount of history and size of the project.
22:48:52 <bos> wli: yeah, that's because they suck.
22:49:24 <glguy> bos: from your point of view, what are the current compelling offerings available
22:49:24 <bos> git and mercurial handle kernel trees, and much bigger, perfectly well.
22:49:29 <wli> bos: Are you telling me darcs now works smoothly on full-sized Linux histories?
22:49:56 <glguy> I think he's saying that it sucks ;)
22:50:06 <bos> that would be rude.
22:50:54 <wli> bos: Actually git and mercurial both have issues, which has led to periodic rebasing of the tree to prune the history to something git can manage (mercurial's largest issues are elsewhere though it's unclear if it, too has issues with large histories).
22:52:24 <wli> bos: Well, I dredged up standard databases because they appear to have algorithmic scalability for the sorts of problems these things are choking on. I'm not aware of how anything that's tried it has turned out in practice.
22:52:48 <bos> glguy: depends on your criteria. i find git very complicated, and it doesn't run well on windows. i like bzr in some ways, but it doesn't scale to large projects. mercurial has its shortcomings, but it scales well and is easy to learn.
22:53:19 <glguy> bos: what are the accepted shortcommings of mercurial?
22:53:51 <bos> wli: database access patterns are very dissimilar to vcs access patterns. matt did an incredible job designing revlogs, mercurial's storage format.
22:54:02 * glguy found the FAQ question about hg's limitations
22:54:14 <Syzygy-> glguy: Where
22:54:16 <Syzygy-> ?
22:54:21 <glguy> http://www.selenic.com/mercurial/wiki/index.cgi/FAQ#head-d606a74f8828a9bfa2d971e513381a66ae9b7d08
22:54:24 <lambdabot> Title: FAQ - Mercurial, http://tinyurl.com/ytromj
22:54:29 <Syzygy-> Thanks
22:55:02 <glguy> its not a big list
22:55:15 <glguy> Mercurial currently assumes that single files, indices, and manifests can fit in memory for efficiency.
22:55:19 <bos> glguy: the big endianness of the network protocol isn't a practical issue, btw. that's like calling the big endianness of TCP an issue. don't know why it's on the list.
22:55:20 <glguy> is probably the most interesting
22:55:29 <glguy> if any of them are
22:55:44 <bos> yeah, i wouldn't use mercurial to store my collection of ripped DVDs.
22:56:27 <wli> bos: What sort of comments/etc. do you have on coping with vast histories?
22:56:31 <ddarius> Okay.  I need to sleep.  It looks like ICFP is going to be good for Haskell no matter what the outcome.
22:57:20 <dons> roconnor's climbed back up to 20,ddarius .
22:57:31 <bos> wli: parsing a big history can take a while.  it's about 0.5 seconds for the kernel history, with 62126 revisions in my tree.
22:57:57 <bos> that's purely because the revlog code is 97% python.
22:58:16 <wli> bos: I'm thinking more of how one would design a VCS to deal with immense histories, such as unpruned Linux histories.
22:59:08 * wli is curious because going "way back in time" is a big deal for me.
23:01:26 <bos> i don't want to turn this place into #revctrl :-)
23:03:07 <glguy> one things that I don't like about darcs is how it merges conficts in the working directory
23:03:17 <glguy> instead of giving you two files to merge yourself
23:03:34 <glguy> bos: if someone asks some Haskell questions, we can jump back on topic ;)
23:07:53 <locomal1> Hello, I juste wonder if is there any chance that the linux kernel will be coded in haskell?
23:08:29 <dons> there are OS kernels written in haskell, but I highly doubt linux will be reimplemented that way :)
23:08:32 <dons> ?where house
23:08:32 <lambdabot> http://www.cse.ogi.edu/~hallgren/House/
23:08:48 <dons> locomal1: ^ is a haskell microkernel. there are a couple of others
23:09:08 <slava> aww man, and all this time i thought a haskell rewrite of the kernel was just around the corner :(
23:09:17 <dons> heh
23:10:01 <slava> weren't you working on some kind of plugin loading architecture for haskell?
23:10:04 <locomal1> I never googled around about that question, I Just asked
23:10:12 <slava> that would form a nice foundation for an OS :)
23:10:12 <locomal1> thanks
23:10:55 <hpaste>  tuxplorer pasted "For the hello world example at http://happs.org/HAppS/doc/tutorial.html, I get the following error.." at http://hpaste.org/1850
23:11:09 <dons> yay, roconnor is climbing up the icfp rankings. 1 guy + haskell, #19.
23:12:03 <tuxplorer> please help me get started with HAppS by letting me know the reason for that error
23:12:13 <dons> perhaps ask on #happs ?
23:12:18 <dons> (as well)
23:14:10 <tuxplorer> Thanks dons
