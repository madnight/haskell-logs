00:20:36 <glguy> ?losers
00:20:36 <lambdabot> Maximum users seen in #haskell: 354, currently: 293 (82.8%), active: 7 (2.4%)
00:20:44 <profmakx> *g*
00:21:05 <profmakx> do we have a history for that?
00:21:25 <profmakx> when i joined first there were about 200 users in here i think
00:26:44 <kaol> it's the eternal september of Haskell. (luckily not)
00:31:23 <timthelion> hey, I have a line of code like this: "div (cullc cols) 2 + rem (cullc cols) 2" is it possible to make it so that (cullc cols) 2 is only there once? so I would be calling a third function with the arguments div, rem, +, (cullc cols), and 2?  if this third function exists, what is it called)
00:32:43 <sjanssen> timthelion: quotRem
00:33:02 <mauke> :t \x -> uncurry (+) (divMod x 2)
00:33:04 <lambdabot> forall a. (Integral a) => a -> a
00:33:12 <timthelion> :t quotRem
00:33:15 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
00:33:56 <mauke> I have a problem with threads
00:34:44 <glguy> timthelion: similarly you could write: let x = cullc cols in div x 2 + rem x 2
00:35:23 <timthelion> glguy: not sure it's worth it
00:35:39 <mauke> there is a thread that accepts connections on a socket in a loop, spawning other threads to do the real work
00:35:50 <mauke> how do I tell this thread to stop accepting?
00:36:04 <shachaf> @pl \x -> x `div` 2 + x `rem` 2
00:36:05 <lambdabot> liftM2 (+) (`div` 2) (`rem` 2)
00:36:12 <sjanssen> mauke: throw an exception to it?
00:36:25 <mauke> :(
00:36:28 <mauke> I guess that's the only way
00:37:05 <sjanssen> mauke: oh, there's killThread too
00:37:17 <mauke> killThread tid = throwTo tid (AsyncException ThreadKilled)
00:39:07 <timthelion> so watching the fireworks tonight... I saw some that exploded into a rose of balls, and each ball, then exploded into another rose, the fireworks where recursive.  so I was thinking you could write a recursive fireworks drawing function in haskell.  I ran into a problem though,  when ball calls ball 5 times,  ball will have already run by the time ball gets called, so you would see the rose drawn in it's full depth of recurso
00:39:07 <timthelion> individual ball,  would it be easy to fork these ball calls?
00:40:17 <opqdonut> full depth of recurso.... (your message got truncated?)
00:40:46 <timthelion> oin for each
00:41:31 <timthelion> why does it do that? it seems that when my irc client splits a line, it looses the last 3 words of the before split portion
00:41:33 <mgsloan> dons - in Data.Binary, couldn't the Integer instance use the initial tag to store length when less than 255 bytes?
00:42:11 <dons> we could do that.
00:43:48 <mgsloan> I think I'm gonna take a shot at that binary format thing discussed the other day, just for kicks
00:44:17 <mgsloan> really probably easier done in a dynamic language (unless haskell has reflection stuff I don't know about)
00:44:32 <mgsloan> Data.Binary is nice, though
00:47:10 <dons> well, i'm interested in anything you do with Data.Binary
00:47:27 <dons> i want to ensure we can do any hard, time-critical network/protocol stuff with it
00:47:37 <dons> give erlang a good run for its money :-)
00:47:43 <dons> mm. tasty typesafe, native code ..
00:48:25 <mgsloan> :) that'd be pretty cool
00:52:53 <quicksilver> dons: but if you change that, you risk breaking old Data.Binary code
00:53:02 <quicksilver> dons: this is one of my misgivings about Data.Binary
00:53:11 <quicksilver> dons: it isn't a precisely documented, versioned, format
00:53:27 <dons> we're trying to document the format. but its like Show/Read -- you get something.
00:53:56 <dons> the more important thing is the Put/Get monads underneath to do your own formats
00:54:35 <quicksilver> dons: yes, I understand you get something; and in isolation that makes sense
00:54:38 <mgsloan> yeah, it's too bad you can't do your own instance deriving
00:54:48 <quicksilver> dons: but it does effectively mean you should never change it, now
00:55:01 <quicksilver> dons: because you'll break old binary data (stored on disk)
00:55:12 <dons> i think its early enough that we could.
00:55:16 * quicksilver nods
00:55:21 <quicksilver> OK, that's your judgement call
00:55:27 <quicksilver> I'm sure you understand the issue I'm pointing at, though
00:55:30 <dons> but probably unlikely anyway, since we encourage zlib/bzip for further compression
00:55:34 <dons> yes, certainly
00:55:42 <mgsloan> what uses it at the moment?
00:55:45 <kral> ahoy
00:55:47 <quicksilver> over the lifetime of Data.Binary you may well find bugs or limitations
00:55:51 <dons> lambdabot, hmp3, tar.
00:56:02 <mgsloan> ah
00:56:04 <quicksilver> and if you change anything, you don't have a mechanism for old data to be read by new programs safely
00:56:17 <mgsloan> well, you might
00:56:29 <mgsloan> for example, with Integer, you'd still be able to read actually
00:56:39 <quicksilver> some changes might be backwards compatible,s ure
00:56:42 <quicksilver> but others might not be :)
00:56:49 <mgsloan> as the range [1,4] would be left alone for the start tag
00:56:58 <quicksilver> maybe there'll never have to be an backwards incompatible change...
00:57:01 <mgsloan> and 1 indicates old form
00:57:04 <mgsloan> we can hope
00:57:07 <quicksilver> but that's quite optimisitic
00:57:43 <dons> yes, you'd want to provide, at least in comments, a function that reads the old format, and writes the new (i.e. 'get' from the previous instance, but with 'put' from the new one)
00:57:44 <vincenz> I think the point quicksilver is making that any change that is done with the format should be checked for backwards compatibility.
00:57:47 <dons> giving upgrading.
00:57:58 <vincenz> :)
00:58:07 <timthelion> so, foldr does not work on tuples,  I presume because they can have varying types,  what does?
00:58:07 <timthelion>  
00:58:18 <vincenz> lists
00:58:27 <vincenz> oh, what works with tuples?
00:58:33 <quicksilver> dons: yes; but ideally you want to make that automatic; some kind of 'version header'
00:58:38 <vincenz> timthelion: well.... how would you even define a generic fold on tuples?
00:58:40 <mgsloan> pattern matching works on tuples
00:58:59 <mauke> @source Network.Socket
00:58:59 <lambdabot> http://darcs.haskell.org/packages/network/Network/Socket.hs
00:59:00 <vincenz> quicksilver: that's what I did with a custom binary format for profilng
00:59:08 <mauke> lambdabot: 404
00:59:10 <mgsloan> vincenz - anonymous type sums :)
00:59:38 <vincenz> mgsloan: You mean Dynamic?
00:59:49 <mgsloan> that works too i guess
01:00:19 <mgsloan> quicksilver: I think the problem is that Data.Binary is not necessarily just for files
01:00:21 <timthelion> vincenz: no clue, it's just that sjanssen suggested quotRem for making summing div and rem of the same arguments seem less absurd. but that returns a tuple
01:00:24 <mgsloan> it might go into anything
01:00:36 <vincenz> timthelion: oh, just patternmatch
01:00:37 <mgsloan> so if you include version stuff, you'll have to stick it on every fragment
01:00:43 <vincenz> let (q,r) = quotRem a b
01:01:10 <mgsloan> I guess you could have a tiny bit of state in the monads which say what version, though
01:01:25 <mgsloan> and an included data type/instance for such version data
01:02:02 <timthelion> vincenz: oh, I see
01:02:16 <quicksilver> vincenz: yes, and I've done it too :)
01:04:09 <bos> this is brilliant: http://scottaaronson.com/blog/?p=253
01:04:20 <lambdabot> Title: Shtetl-Optimized » Blog Archive » FOCS&#8217;36 notification
01:08:10 <dons>  so ... who's going to upload a lib to hackage today ? :-)
01:08:19 <dons> should we have a contest, with rankings and points?
01:08:28 <dons> it might encourage new haskellers to contribute.
01:08:45 <dons> any opinions on how cpan stats help encourage perl people to write libs?
01:11:15 <quicksilver> I've certainly never had the impression that they did ;)
01:11:18 <quicksilver> but who knows
01:11:52 <mgsloan> go ask a perl channel, maybe
01:12:03 * quicksilver laughs
01:12:12 <quicksilver> get a serious answer to a question in a perl channel?
01:12:15 <quicksilver> not so likely :P
01:12:41 <dons> would publishing names/"number of libs bound" for hackage libs encourage people to write more libs?
01:12:49 <timthelion> less likly if you never ask
01:13:05 <dons> i want to foster a community of "hey, i'm bored, i'll write a binding" people ... :-)
01:13:11 <dons> how can we bring this about?
01:13:20 <quicksilver> mind control springs to mind
01:13:27 <dons> yes, i've tried that.
01:13:28 <dons> works for some.
01:13:31 <Syzygy-> Hehehe
01:13:40 <mauke> snippet of the day:  join . atomically $ do
01:13:47 * dons sends out some more mind control over irc rays..
01:13:50 <timthelion> make a list of bindings that need writting that are not out of the reach of someone with limited xp
01:13:53 <dons> mauke: nice.
01:14:08 <dons> timthelion: yeah, with a step by step tutorial on "binding to C" ?
01:14:18 <dons> we've got a step by step guide to producing a haskell lib
01:14:21 <timthelion> I guess
01:14:24 <dons> but perhaps we need one for bindings too
01:14:37 <dons> and there are a lot more libs being produce now, thanks to cabal + hackage
01:15:08 <dons> Makefiles have well and truly been killed off, and host-it-myself is dying too
01:15:10 <timthelion> make them anounced on the irc channel?
01:15:25 <dons> yeah, i started doing weekly reports in HWN, but then HWN stopped being weekly
01:15:33 <dons> there's an RSS feed for hackage though
01:15:39 <timthelion> like on #perl you see foobarbooredcoder uploaded stupidlib to cpan
01:15:39 <vincenz> dons: Makefiles have been killed off?
01:15:42 <vincenz> dons: how?
01:16:00 <dons> for haskell projects, pretty much. you'd get a slap if you tried to publish a haskell lib with a makefile only.
01:16:15 <dons> and you can't host it on hackage, so it doesn't exist, if its not in cabal
01:16:26 <vincenz> dons: can one build without makefiles?
01:16:29 <mauke> I've written makefiles for xmonad and other libs :-)
01:16:33 <dons> vincenz: hmm?
01:16:38 <dons> vincenz: haskell.org/cabal please!
01:16:41 <mauke> simply because it's easier to type 'make' than 'runhaskell Setup.lhs build'
01:16:58 <timthelion> and much more standard
01:17:01 <dons> mauke, alias all="runhaskell Setup.lhs configure ; ... ; install"
01:17:10 <mauke> I don't want that
01:17:21 <dons> ok. timthelion, vincenz: you're here a lot. earn your keep: upload a library!
01:17:29 <Syzygy-> mauke: ./Setup.lhs build :P
01:17:44 <timthelion> dons: what lib do you want?
01:17:48 <mauke> 80% of the time I need build only, maybe 10% with install
01:17:57 <glguy> if you are trying to save characters: "runghc Setup" is shorter than "runhaskell Setup.lhs" ;_
01:17:59 <mauke> the rest is darcs pull something and reconfigure
01:18:00 <glguy> ;)
01:18:04 <dons> for every 1000 lines you type in #haskell, that's one lib you have to bind to, write, and upload
01:18:08 <vincenz> dons: thx for link
01:18:14 <dons> hmm, so i have to write 30 libs this year. that's tough.
01:18:15 <vincenz> dons: I'm busy with phd work
01:18:18 <Syzygy-> glguy: ./Setup.lhs still is quicker.
01:18:22 <dons> ok. for every 10k lines, 1 library.
01:18:25 <Syzygy-> glguy: You have to chmod +x, admittedly
01:18:28 <dons> vincenz: come on: phd == hacking time.
01:18:32 <mauke> glguy: <F4> is quicker and that runs make in my editor :-)
01:18:36 <vincenz> dons: yes, but I hack on different things
01:18:37 <Syzygy-> dons: What's my task?
01:18:42 <glguy> Syzygy-: how about sh Setup.hs?
01:18:49 <Syzygy-> glguy: Yeah, that works...
01:18:54 <dons> ok, there's a 'missing libs' page on haskell.org. "wanted libs" i think it is called.
01:19:04 <timthelion> dons: are you going to have a kicking system, or a really annoying bot?
01:19:05 <dons> it links to the most popular C libraries as nominated by debian
01:19:12 <dons> i say, pick one off the list, and write a binding to it.
01:19:16 <dons> pref. something fun you'd actually use.
01:19:22 <dons> timthelion: i can be annoying
01:19:35 <dons> ?go popcorn debian vote
01:19:37 <lambdabot> http://tech.netscape.com/story/2007/06/26/debconf-7-positions-debian-for-the-future/
01:19:38 <lambdabot> Title: DebConf 7 positions Debian for the future » Netscape.com
01:19:56 * Syzygy- might at some point wish very much for a libsingular binding for Haskell.... *thinking along*
01:20:06 <dons> ok, there we go.
01:20:11 <Syzygy-> :P
01:20:25 <Syzygy-> dons: Do you have IRC stats somewhere?
01:20:29 <dons> ?where stats
01:20:29 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
01:20:39 <Syzygy-> Or more specifically, do you have my kloi/year
01:20:40 <dons> yep. look at that list. if you're in the top 20, you better write a library..
01:20:50 <dons> ok, let me see...
01:20:56 * vincenz checked out the page
01:21:06 <vincenz> dons: seems easy enough (the cabal stuff)
01:21:20 <Syzygy-> dons: When is lambdabot gonna write her ~80 libraries?
01:21:36 <Syzygy-> Wha? I don't even make it onto top 25!?
01:21:37 <therp> we are the 14th largest channel on freenode?
01:21:39 <Syzygy-> Bah!
01:21:40 <dons> Syzygy-: might be lucky. but quicksilver sure owes us some code now!
01:21:51 <mgsloan> dons - if you got a dollar a word for irc, you'd be quite well off
01:21:52 <dons> quicksilver: i'm looking at you! where's the code? :-)
01:22:00 <dons> therp: indeed
01:22:02 <Syzygy-> Oooooookay. Now I might even be insulted. I didn't make it to the stats AT ALL!
01:22:17 <dons> not the top 50 eh? seems odd.
01:22:24 <Syzygy-> So say I
01:22:36 <dons> Cale: you owe us some libs, or at the very least, a tutorial!
01:22:52 <Syzygy-> Nope. I don't occur on the stats page for 2007 at all.
01:22:54 * quicksilver resolves to answer fewer questions and help fewer newbies, in order to avoid responsibility.
01:22:55 <dons> so i think, if you're in the top 50, you need to either produce 1 lib, or 1 tutorial. or both.
01:22:59 <dons> Syzygy-: hmm, weird.
01:23:15 <dons> quicksilver: you could write up a tutorial .. :-)
01:23:24 <dons> for the theoretically inclined
01:23:31 <Syzygy-> I have, however, written a tutorial already. :)
01:24:07 <dons> really, are we going to sit around talking about languages for another 5 years? or are we going to take some action, and ensure we can use haskell wherever we wish?
01:24:25 <quicksilver> I'm very much in the talking about languages camp.
01:24:29 <dons> and to do that, we need libs, tutorials, people solving their work problems in haskell. sharing it.
01:24:30 <quicksilver> that's more fun than real work.
01:24:44 <Shimei> So, I have a question about currying. Would functions in imperative languages such as C be considered curried? Or is the labeling meaningless when the languages are not functional?
01:24:46 <dons> but we've done that for the last 15 years!
01:24:47 <Syzygy-> dons: I'm already solving my work problems in Haskell - I don't quite see your point.
01:24:53 <dons> Syzygy-: great!
01:24:54 <quicksilver> Shimei: no, they're not curried
01:25:00 * timthelion is releived to see that there are people who waste more of there lives on irc
01:25:03 <glguy> dons: I hope to not be using Haskell in 5 years
01:25:09 <quicksilver> Shimei: because they take multiple arguments all at once and never return functions
01:25:09 <Syzygy-> dons: Did I show you my preprint-to-be-cum-haskell-program?
01:25:13 <dons> glguy: oh? /me is intrigued
01:25:15 <glguy> Haskell will be for legacy code :)
01:25:19 <glguy> Haskell' please
01:25:21 <dons> Epigram for all!
01:25:30 <dons> Syzygy-: no?
01:25:34 <Shimei> quicksilver: So theoretically speaking, C arguments can be considered to be stored as tuples?
01:25:43 <quicksilver> Shimei: well, not really
01:25:48 <quicksilver> Shimei: but they are passed 'all at once' in some sense
01:25:54 <Shimei> I see.
01:25:58 <Syzygy-> dons: http://mpc723.mati.uni-jena.de/~mik/SaneblidzeUmble.pdf
01:26:03 <quicksilver> Shimei: 'stored as tuples' is an implementation detail, that's not what currying is about
01:26:08 <glguy> passed all at ones, but evaluated left to right?
01:26:16 <dons> Syzygy-: mail me (dons <> cse.unsw.edu.au), i'll have a read tonight.
01:26:20 <quicksilver> glguy: they're evaluated before they are passed
01:26:23 <quicksilver> glguy: call-by-value
01:26:27 <dons> (currently on a text console, laptop flat, on my way home :-)
01:26:29 <glguy> quicksilver: right
01:26:35 <Syzygy-> I need to quadruply-verify the code and preferably write down an argument that convinces algebraists that it's a provably correct implementation, then it'll get published :)
01:26:39 <glguy> quicksilver: that's what I thought I was conveying :)
01:26:46 <dons> Syzygy-: that'd do it :-)
01:26:48 <Syzygy-> dons: How far from Sydney are you?
01:26:56 <dons> in the middle of it.
01:27:16 <Syzygy-> Oooooooooooh!
01:27:24 * Syzygy- is scheduled to land in Sydney September 14.
01:27:24 <dons> hmm?
01:27:35 <dons> hah :) i'm leaving Aug 31. :}
01:27:38 <Syzygy-> Invited for 5 weeks by the Magma group @ USydney
01:27:39 <Syzygy-> Oh bugger.
01:27:47 <dons> oh, cool. i know some of those guys, i think
01:28:02 <Syzygy-> dons: But you're at unsw normally? Or are you leaving .au entirely?
01:28:07 <Syzygy-> dons: Coool.
01:28:11 <glguy> dons: do you know when your first day at work is?
01:28:19 <dons> I'm moving to Portland. glguy, around Sep 5?
01:28:28 <glguy> dons is coming to portland to sit next to me at work :)
01:28:33 <Syzygy-> dons: John Cannon is going to be my host.
01:28:35 <dons> and throw rocks at glguy
01:28:37 <Syzygy-> Hehehe
01:28:48 <dons> maybe we can fix hpaste then
01:28:48 * glguy will throw the boomerang at you!
01:28:51 <Shimei> Go Oregon. :)
01:28:52 <Syzygy-> :P
01:28:53 <glguy> since you are from .au
01:28:56 <glguy> (and we have one)
01:29:00 <dons> it'll come back and hit you though, glguy
01:29:04 <dons> you see, they're tricky like that
01:29:11 <glguy> nuh uh, I know how to throw them at people
01:29:16 <glguy> you turn it around
01:29:23 <Syzygy-> glguy: You break it in two, then throw both pieces?
01:29:28 <glguy> it is foam
01:29:30 <glguy> so that helps
01:29:36 <dons> hehe.
01:29:49 <dons> ok. time to catch the bus. bbl! write some code!
01:29:50 <dons> ?users
01:29:50 <lambdabot> Maximum users seen in #haskell: 354, currently: 303 (85.6%), active: 11 (3.6%)
01:29:56 <glguy> bed time!
01:29:59 <dons> 303 libraries done by Friday!
01:30:02 <dons> we'd take over the world!
01:30:28 <mauke> but we're only 302
01:31:55 <timthelion> make that 301,  I'm not one for grunt work
01:35:11 <mauke> @index ThreadId
01:35:11 <lambdabot> GHC.Conc, Control.Concurrent, GHC.Conc
01:35:39 <mauke> :t  fix $ \self -> m >>= flip when self
01:35:41 <lambdabot> Not in scope: `m'
01:35:50 <mauke> :t \m -> fix $ \self -> m >>= flip when self
01:35:52 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m ()
01:41:19 <ttmrichter> I'm having Haddock complain about a doc string on a trivial function with this message: parse error in doc string: [haddock.bin: reading EOF!  The place it's pointing to is the first column of the first line after a Haddock comment.  I can't see any flaw in the formation of said comment.  Any idea what might be wrong?
01:47:20 <quicksilver> mauke: keep executing until it returns false?
01:47:27 <mauke> quicksilver: yes
01:47:30 <quicksilver> mauke: cute
01:47:39 <quicksilver> How does it end up having type ()?
01:47:42 <quicksilver> :t when
01:47:50 <Lemmih> *** Exception: too few bytes. Failed reading at byte position 738871813865472008   <-  heh.
01:47:50 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
01:47:54 <quicksilver> ah
01:48:07 <quicksilver> Lemmih: woot :)
01:48:11 <mauke> I hate Network
01:48:16 <quicksilver> Lemmih: unusual kind of 'too few' :)
01:48:51 <timthelion> I have a rectangle (Rectangle x y w h) that is passed to a function as r (I need to pass it to another function so I can't do patern matching on this passing.  how best do I bind x y w h then? >     rw (Rectangle _ _ w _) = w seems kinda inefficient
01:48:51 <timthelion>  
01:49:25 <mauke> sure you can use pattern matching
01:49:26 <mgsloan> ttmrichter: I don't know, but if it were me I'd probably re type the whole thing and delete the original
01:49:43 <ttmrichter> I just did that.
01:49:46 <ttmrichter> Same result.
01:49:53 <timthelion> mauke: how?
01:50:05 <mauke> r@(Rectangle x y w h)
01:50:09 <mgsloan> well, I'm afraid I'm of no use, never done haddock comments
01:50:16 <timthelion> ohh, cool
01:50:33 <ttmrichter> If I have *ANY* Haddock comments at all, I get that error on the line immediately after it.  If I have no Haddock comments at all, I get it whining about not being able to find "Floating" and other words from the prefix.
01:54:05 <DRMacIver> Hm. Is there a good way of timing evaluations from within a Haskell program? e.g. if I have an IO () I want a way of converting this to an IO Int which runs it and results in the time it took to run.
01:54:29 <DRMacIver> I suppose it's easy to write.
01:54:43 <apfelmus> something with getClockTime or so I think
01:54:46 <DRMacIver> Yeah
01:54:53 <apfelmus> @hoogle time
01:54:57 <lambdabot> System.Time :: module
01:54:57 <lambdabot> Time :: module
01:54:57 <lambdabot> System.Locale.time12Fmt :: TimeLocale -> String
01:55:00 <DRMacIver> Never mind. Ignore me unless there's some super great performance testing module I'm not aware of. :)
01:55:10 <DRMacIver> Stupid question. Sorry.
01:55:38 <apfelmus> @src getCPUTime
01:55:38 <lambdabot> Source not found. Maybe if you used more than just two fingers...
01:56:14 <apfelmus> @type getCPUTime
01:56:16 <lambdabot> Not in scope: `getCPUTime'
01:56:24 <apfelmus> it's in SystemCPUTime
01:56:30 <apfelmus> *System.CPUTime
01:56:43 <apfelmus> "Computation getCPUTime returns the number of picoseconds CPU time used by the current program. The precision of this result is implementation-dependent."
01:57:39 <DRMacIver> Thanks
01:58:23 <mgsloan> hmm, when would Data.Generics.Basics.isAlgType :: DataType -> Bool ever return False?
01:58:38 <apfelmus> on function types?
01:58:43 <mgsloan> doh!
01:58:49 <mgsloan> thanks :)
01:58:56 <apfelmus> :)
01:59:01 <mgsloan> they should call it isFuncType or something
01:59:13 <mgsloan> (and reverse the output of course)
01:59:35 <DRMacIver> Possibly on second rank types as well? Not sure.
01:59:47 <apfelmus> well, there might be types that are neither algebraic nor function types
01:59:55 <apfelmus> like GADTs or rank-2 or like that
02:00:21 <apfelmus> depends on the exact connotation of "algebraic"
02:00:24 <mgsloan> hmm, yeah, I suppose so
02:00:40 <DRMacIver> Hm. Haskell one liners are far too fun to write.
02:01:03 <mauke> ghc -e needs a command line option to import modules
02:01:22 <mgsloan> I take it you can't use generics to synthesize objects?
02:01:41 <mgsloan> (data, i mean)]
02:03:24 <therp> lol, the word "monad" is used more often on #haskell than the word "should", "could" or "maybe"
02:03:44 <apfelmus> DRMacIver: timing m = liftM2 subtract getCPUTime (m >> getCPUTime)
02:04:02 <apfelmus> > subtract 2 5
02:04:07 <lambdabot>  3
02:04:30 <DRMacIver> I'd more or less figured that out myself, but thanks. :)
02:04:46 <apfelmus> My brain needs food, too ;)
02:05:39 <DRMacIver> Well, I'm happy to act as waiter then. ;)
02:05:49 <apfelmus> :D
02:06:19 <DRMacIver> And now I need to go write dumb Java code. :(
02:06:35 <apfelmus> :(
02:11:02 <squark> hello
02:11:32 <squark> has something been done with haskell and SVG ?
02:12:45 <apfelmus> the gtkhs GUI library has cairo support
02:13:22 <apfelmus> other than that, there's no svg or even vector graphics effort i know of
02:13:29 <squark> thank you
02:14:02 <apfelmus> well, there are some vector graphic libs but they're not well maintained
02:14:18 <squark> like wxhaskell
02:14:37 <squark> i have seen a project named wxsvg
02:14:45 <apfelmus> http://haskell.org/haskellwiki/Applications_and_libraries/Graphics#Libraries
02:14:48 <lambdabot> Title: Applications and libraries/Graphics - HaskellWiki, http://tinyurl.com/3axmhe
02:15:15 <quicksilver> gtk is worth looking at
02:15:23 <quicksilver> cairo is a pretty good vector graphics library from what I've heard
02:15:27 <mgsloan> gtk2hs has some svg stuff i believe
02:15:27 <quicksilver> (it's a gtk component)
02:15:29 <apfelmus> wxsvg has no haskell binding i think
02:15:30 <mgsloan> yes, cairo is nice
02:15:36 <quicksilver> and it can export to SVG, ps, pdf, etc
02:15:39 <mgsloan> it's not really a gtk component
02:15:48 <mgsloan> but it's easy to include as one
02:15:54 <quicksilver> well, a technology used by gtk :)
02:16:00 <mgsloan> right :)
02:16:06 <quicksilver> and the haskell cairo binding is part of gtk2hs
02:16:14 <mgsloan> yeah, I suppose gtk is moving towards rendering with cairo
02:16:21 <mgsloan> firefox 3 will use cairo
02:16:30 <mgsloan> inkscape is nearing a conversion to cairo
02:16:33 <quicksilver> nice
02:16:39 * quicksilver <3 inkscape
02:16:45 <mgsloan> indeed!
02:17:00 <mgsloan> only reason I tolerate C++ dev is to work on inkscape
02:17:05 <squark> is it easy to create something with gtk2hs on other platforms than linux
02:17:07 <squark> ?
02:17:14 <mgsloan> yeah
02:17:18 <mgsloan> gtk is cross platform
02:17:49 <mgsloan> I think gtk2hs is cross platform, but I'm not 100%
02:17:55 <quicksilver> yes, it is
02:18:13 <quicksilver> although on the mac it works via X11
02:18:18 <squark> okay
02:19:21 <squark> and are there difficulties to work with gtk2hs with GHC if i'm on a mac ?
02:20:32 <quicksilver> I've never tried it
02:20:34 <bringert> @where paste
02:20:34 <lambdabot> http://hpaste.org/new
02:20:36 <Wild_Cat> squark: probably the same there are with GTK. Namely, it'll only work under X11
02:20:43 <bringert> hmm, Service Temporarily Unavailable
02:20:44 <quicksilver> I'd imagine the main thing is you have to have X11 installed
02:20:56 <mgsloan> yeah, so if gtk is available, mac is probably fine
02:20:57 <quicksilver> bringert: I think glguy might have turned it off because of all the spam
02:21:12 <bringert> we need a usable paste bin then
02:21:48 <quicksilver> there are plenty out there, we can use any :)
02:21:49 <squark> okay so i'm going to try something with gtk2hs
02:22:20 <squark> thank you for your answers :)
02:22:27 <mauke> why the hell is there no sendBuf?
02:22:45 <squark> and sorry for my english:D
02:22:55 <bringert> kosmikus: have you ever seen lhs2TeX indent the last line of a code block when in a figure using the JFP class? This code seems to provoke that: http://pastebin.com/942377
02:23:29 <mgsloan> squark - it's been fine so far
02:24:12 <mauke> what's the easiest way to convert an integer to 4 bytes in network order?
02:24:26 <quicksilver> mauke: by hand
02:24:30 <mauke> argh
02:25:00 * mauke shakes his fist at the network modules
02:25:03 <quicksilver> it's not exactly difficult :P
02:25:14 <quicksilver> IIRC Data.Binary has network-byte-order stuff in it too
02:25:32 <mauke> Data.Binary isn't "standard", is it?
02:25:48 <mgsloan> also, not to say that haskell is bad for applications, but interactive applications aren't really as immediately as doable by newish people than in other languages
02:26:43 <apfelmus> depends on what you understand by "interactive"
02:27:05 <apfelmus> in it's primitive form, interactive = [String]->[String]
02:27:26 <mgsloan> :)
02:27:52 <mgsloan> lambdabot interactive could be fun
02:28:14 <mgsloan> eg, you give it a function of that type, and for the next few msgs, it's applied
02:28:24 <quicksilver> mgsloan: or you give it a prefix
02:28:30 <apfelmus> hehe
02:28:34 <mgsloan> that's what i mean
02:28:34 <quicksilver> mgsloan: and msgs with that prefix get passed to your interactive
02:28:40 <quicksilver> mgsloan: that would be a really nice plugin
02:28:41 <mgsloan> oh, good idea
02:28:44 <mgsloan> indeed
02:28:54 <quicksilver> @interact qs = reverse
02:28:55 <lambdabot> Unknown command, try @list
02:28:58 <quicksilver> @qs happy
02:28:58 <lambdabot> Maybe you meant: . ask bf ft id msg pl rc v wn
02:29:00 <quicksilver> -> yppah
02:29:31 <mgsloan> @qs fooblestook
02:29:31 <lambdabot> Maybe you meant: . ask bf ft id msg pl rc v wn
02:30:21 <mauke> > (\n -> map (toEnum . (.&.) 255 . shiftR n . (*) 8) [3 .. 0]) 1234
02:30:22 <lambdabot>  []
02:30:40 <mauke> > (\n -> map (toEnum . (.&.) 255 . shiftR n . (*) 8) [3, 2, 1, 0]) 1234
02:30:42 <lambdabot>  [0,0,4,210]
02:30:52 <quicksilver> mauke: I have some code snippets somewhere, let me see
02:32:18 <quicksilver> http://scsys.co.uk:8001/8438
02:32:20 <lambdabot> Title: perl_web paste from "quicksilver" at 81.149.28.129...
02:32:28 <quicksilver> mauke: that's not quite what you want, it's a custom format I'm using
02:32:54 <bringert> kosmikus: it appears to be a probem with centering, which the JFP figure environment uses. Here's an example using the article class: http://pastebin.com/942382
02:33:00 <quicksilver> mauke: basically ints under 127 are stored as a single byte, ints over 127 are stored as (length+127) : (bytes)
02:34:59 <mauke> > (\n -> map (chr . (.&.) 255 . shiftR n . (*) 8) [3, 2, 1, 0]) 12345
02:35:00 <lambdabot>  "\NUL\NUL09"
02:35:50 <mauke> > sum . zipWith (\n c -> fromEnum c * 2 ^ n) (reverse [0 .. 3]) . (\n -> map (chr . (.&.) 255 . shiftR n . (*) 8) [3, 2, 1, 0]) $ 12345
02:35:52 <lambdabot>  153
02:36:50 <mauke> > sum . zipWith (\n c -> fromEnum c `shiftL` (8 * n)) (reverse [0 .. 3]) . (\n -> map (chr . (.&.) 255 . shiftR n . (*) 8) [3, 2, 1, 0]) $ 12345
02:36:52 <lambdabot>  12345
02:37:24 <mgsloan> > show . Data.Generics.dataTypeOf . ([] :: Int)
02:37:26 <lambdabot>  Couldn't match expected type `Int' against inferred type `[a]'
02:37:37 <mgsloan> > show . Data.Generics.dataTypeOf . ([] :: [Int])
02:37:38 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `[Int]'
02:37:46 <mauke> > show . Data.Generics.dataTypeOf $ ""
02:37:47 <lambdabot>  "DataType {tycon = \"Prelude.[]\", datarep = AlgRep [[],(:)]}"
02:37:56 <mgsloan> arg
02:38:09 <mgsloan> thanks
02:40:07 <mgsloan> > show . Data.Generics.dataTypeOf $ (Left 1 :: Either Int String)
02:40:09 <lambdabot>  "DataType {tycon = \"Prelude.Either\", datarep = AlgRep [Left,Right]}"
02:50:26 <vincenz> lol
02:50:27 <vincenz> "C feels more formal."
02:50:35 <vincenz> from blog
02:51:22 <mgsloan> oh, looks like you can construct using Data.Generics
02:51:38 <quicksilver> mgsloan: are you sure?
02:51:52 <quicksilver> mgsloan: I thought there was just the mostly-useless fromConstr :)
02:52:42 <mgsloan> yeah, I figured that helped out somehow :)
02:53:14 <rustmeister> ?src Data.List.(>>=)
02:53:14 <lambdabot> Source not found. Just what do you think you're doing Dave?
02:53:18 <quicksilver> mgsloan: I spent some time thinking about it a couple of years ago and thought I cuoldn't do it.
02:53:22 <quicksilver> mgsloan: s/years/weeks/
02:53:39 <mgsloan> I take it you saw the fromConstr variants too?
02:53:42 <quicksilver> mgsloan: to be more precise, I could construct such that the type was determined by the context
02:53:45 <mgsloan> B/M
02:53:54 <quicksilver> mgsloan: but I couldn't construct such that the type was determined by the data
02:54:03 <mgsloan> right
02:54:12 <quicksilver> essentially you need to 'tell it' what type it's trying to construct
02:54:23 <quicksilver> you can't have the construction guided by data from a file/network socket
02:54:29 <mgsloan> In my case I think it might be possible
02:54:32 <quicksilver> and produce 'whatever it finds'
02:54:40 <quicksilver> but I wasn't confident, I could well have got that wrong
02:55:01 <mgsloan> in my case, I think it might be possible to get an example of the type
02:55:37 <quicksilver> I can't even remember what problem I was trying to solve any more :)
02:55:45 <quicksilver> I remember getting rather frustrated at the time, though
02:56:54 <mgsloan> I think I'll go it the way that avoids generics stuff for now
03:15:52 <fasta> When building ghc from darcs I get: Could not find module `System.Directory'
03:16:15 <fasta> I tried using ghc-6.6.1 and ghc 6.7 for the build
03:18:15 <_frederik_> hello, does anyone know how to compile 64-bit code?
03:24:11 <_frederik_> i'm wondering if i need to do anything special in the ghc side to link to a 64-bit library
03:25:39 <mauke> is it possible to write a library in haskell that can be used from C?
03:26:09 <fasta> mauke: yes, at least people claimed on the mailing list that was possible
03:26:23 <fasta> mauke: Don't ask me how to, though ;)
03:26:34 <eivuokko> Writting DLLs in Windows is certainly possible.
03:27:44 <Japsu> I'd be interested in doing that on Linux, too.
03:28:12 <quicksilver> mauke: yes, it is possible
03:28:17 <quicksilver> mauke: not sure how easy though :)
03:29:17 <Lemmih> _frederik_: You shouldn't have to do anything special.
03:30:49 <fasta> http://pastebin.ca/604150 <- what should I do about this?
03:33:41 <_frederik_> Lemmih: thanks
03:34:53 <Lemmih> fasta: Did you run darcs-all/autoreconf/configure in the right order?
03:37:25 <fasta> Lemmih: right, I forgot the configure step, probably..
03:41:38 <fasta> Lemmih: thanks, it's building :)
03:42:17 <rule> uch petekaz opqdonut orbitz thedward cameron Heffalump newsham
03:42:17 <rule>     levitation[A] shachaf dons kolmodin Nanar allbery_b jbalint edwinb hellige
03:42:17 <rule>     tessier_ lucca cods lispy largos_ DRMacIver kalven Japsu cinimod sieni
03:42:17 <rule>     yango michie1 mattam Vulpyne audreyt Excedrin Lunchy MyCatVerbs qwr
03:42:17 <rule>     opqdonut_ acura thedatabase
03:46:36 <Syzygy-> ...
03:46:46 <Syzygy-> What was -that- about?
03:47:28 <quicksilver> either a broken IRC client
03:47:32 <quicksilver> or, possibly, a broken spam bot
03:56:35 <DRMacIver> Or maybe he just wanted to greet us all by name. :)
03:56:44 <wolverian> heh, compiling gtk2hs with this new core2 is like .. compiling a c program!
03:57:01 <fasta> What is an easy way to get big primes(as used in cryptographic applications)?
03:57:45 <fasta> 512 bits would be enough for my application(as it's focus is not on security)
03:58:42 <matthew-_> fasta: mainly, you do random number generator and then run tests on it to establish a high probability of it being prime
03:59:13 <fasta> matthew-_: I meant like a library or program already doing that.
03:59:26 <matthew-_> openssl must have something like that in there
03:59:29 <wolverian> oops, gtk2hs compilation failed
03:59:41 <fasta> matthew-_: the algorithms themselves are in books a meter away
03:59:42 <matthew-_> wolverian: just like a C program eh?
03:59:46 <wolverian> matthew-_, quite ;)
04:00:12 <wolverian> c2hsLocal: Error in C header file.
04:00:16 <wolverian> er, sorry
04:00:23 <matthew-_> fasta: the question is though, how big is a meter? ;-)
04:00:54 <mauke> mpz_nextprime() in gmp
04:01:30 <wolverian> heh, it claims the header file has a syntax error: /usr/include/glib-2.0/glib/garray.h:124: (column 40) [FATAL]
04:01:48 <fasta> matthew-_: 3 feet and some inches
04:02:00 <wolverian> I've compiled gtk2hs fine on other computers, but this is 64-bit .. anyone compiled it in a 64-bit linux?
04:02:08 <fasta> matthew-_: just as in Km, it's an SI unit.
04:02:13 <wolverian> or is this just something stupid on my part?
04:02:13 <matthew-_> fasta: that's a metre. A meter might be any size
04:02:27 <fasta> matthew-_: ok, bad spelling on my side.
04:02:42 <matthew-_> fasta: and unnecessary pedantry on my side. Sorry. :-)
04:02:45 <fasta> matthew-_: A measure of length, equal to 39.37 English inches,
04:02:49 <fasta> matthew-_: dict meter
04:02:55 <fasta> matthew-_: meaning number 3
04:03:13 <fasta> matthew-_: metre is wrong
04:03:25 <fasta> matthew-_: so, incorrect pedantry
04:03:45 <matthew-_> oh, yes, ok I'll just keep quiet. What was I thinking of?!
04:03:51 <wolverian> I guess gtk2hs might need some porting for amd64
04:04:00 <wolverian> this is, um, bad..
04:05:10 <hor> Is Haskell Weekly News still published?
04:05:20 <quicksilver> fasta: 'metre' is not wrong
04:05:26 <quicksilver> fasta: it is, however, a british variant
04:05:29 * qwr thinks that both meter and metre are correct
04:05:58 <matthew-_> fasta: dict on the two does give different answers - it's only the "The Collaborative International Dictionary of English" that has the same entry for both spellings
04:06:49 * matthew-_ resorts to the dictionary on his bookshelf
04:07:17 <wolverian> oh, I think it's fixed in darcs, nevermind :)
04:07:49 <ski> afternoon, esap
04:08:48 <matthew-_> right. My Collins Concise Dictionary confirms what I originally thought. Metre is length or rhythm. Meter is to do with measuring stuff. Meter is also the US version of both dfns of metre. Silly dict and its american english.
04:08:53 * matthew-_ shuts up
04:10:28 <wolverian> wiktionary agrees
04:18:52 <esap> ski: afternoon!
04:19:29 * esap was looking at the GHC implementation of unboxed types.
04:19:39 <ski> ok ?
04:20:34 <esap> I'm wondering if you can use diagonalization proofs on the unboxed types...
04:21:04 <ski> isn't the point that no bottom would exist ?
04:21:28 <esap> right. And in unboxed types, bottom isn't part of the type.
04:21:38 * ski nods
04:21:51 <esap> And you can clearly define a fixed-point free function for, say, Word#.
04:22:20 <ski> "fixed-point free function" meaning ?
04:22:48 <esap> ski: a function that doesn't have fixed points. successor is one example. logical negation is another.
04:22:49 <_frederik_> ghc-6.6.1: Vector/Sparse/sparse_lib.o: unsupported ELF format
04:23:02 <_frederik_> ghc isn't letting me link to a 64-bit library
04:23:14 <_frederik_> Sparse/sparse_lib.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped
04:23:26 <_frederik_> ideas?
04:23:31 <esap> ski: for a fixed point-free function f, for all x, f x =/= x
04:24:17 <ski> esap : i'm wondering how to fit in non-terminating functions over unboxed types ..
04:24:53 <ski> esap : just say that not every expression of unboxed type yields a value of same type ?
04:24:54 <fasta> http://www.freepatentsonline.com/20030235299.html <- rediculous patent
04:24:55 <lambdabot> Title: Computer-implemented method for fast generation and testing of probable prime nu ...
04:25:08 <fasta> ridiculous*
04:25:20 <esap> ski: probably you can't. in GHC there is a restriction that a variable with an unboxed type cannot be bound in a recursive binding.
04:25:52 <quicksilver> that's not the only way to cause nontermination, though
04:26:01 <quicksilver> presumably it's stronger than that
04:26:17 <quicksilver> presumably no function using recursion can have an unboxed return type?
04:26:48 <quicksilver> and in (forall a . error : String -> a), I believe that's really 'for all unboxed a'
04:26:51 <quicksilver> erm
04:26:53 <quicksilver> 'boxed'
04:26:54 <quicksilver> :)
04:27:41 <esap> quicksilver: there are all kinds of restrictions regarging unboxed types. I believe most of the reason is that diagonalization proofs can be used, which prevents all kinds of use of fixed points.
04:30:20 <fasta> mauke: In mpz_nextptime also available in a Haskell form already?
04:30:44 <fasta> nextprime*
04:33:33 <ski> esap : hm, would something like '\x :: Word# -> case undefined :: Int of I# _ -> x' be allowed ?
04:35:28 * ski wonders whether an allegory is a 2-category
04:36:21 <esap> ski: I don't know, have to try.
04:37:29 <esap> ski: it says "Ignoring (deprecated) result type signature Word#. hmm...
04:38:45 <esap> ski: hmm.. getting kind error as well.
04:39:07 <_frederik_> hello, i've downloaded http://haskell.org/ghc/dist/6.6.1/ghc-6.6.1-x86_64-unknown-linux.tar.bz2 but ghc won't run, it says "/home/frederik/arch/i386//lib/ghc-6.6.1/ghc-6.6.1: error while loading shared libraries: libgmp.so.3: cannot open shared object file: No such file or directory"
04:39:09 <lambdabot> http://tinyurl.com/2n75y4
04:39:20 <esap> ski: tried case undefined :: Int of I# y -> y, it's a kind error.
04:39:22 <_frederik_> do i need to compile libgmp myself?
04:39:30 <ski> esap : try s/Word#/Int#/ and wrap all in 'I#'
04:39:32 <_frederik_> (i'm using Debian)
04:39:32 <Lemmih> _frederik_: Install libgmp.
04:39:46 <_frederik_> it is installed, but not the 64-bit version
04:39:52 <quicksilver> esap: unboxed types have a different kind to boxed types, I think
04:39:53 <_frederik_> i don't know where to obtain that
04:40:05 <quicksilver> there are three basic kinds, #, ? and *, I think
04:40:08 <ski> :k GHC.Base.Int#
04:40:17 <lambdabot> #
04:40:24 <quicksilver> _frederik_: erm? how can you have a mixed userland?
04:40:34 <ski> quicksilver : also '(#)','??','!'
04:40:35 <quicksilver> _frederik_: I thought you either had a 32 bit userland or a 64bit userland?
04:41:58 <_frederik_> quicksilver: well, i probably don't know what i'm doing
04:42:07 <_frederik_> i just need to compile a 64-bit app
04:42:15 <_frederik_> so i downloaded the x86-64 ghc
04:42:32 <_frederik_> and installed some 64-bit libraries
04:42:36 <ski> :k (->)
04:42:39 <lambdabot> ?? -> ? -> *
04:42:42 <ski> :k (# Int #)
04:42:44 <lambdabot> (#)
04:42:50 <ski> :k GHC.Base.MutVar#
04:42:53 <lambdabot> * -> * -> !
04:43:03 <Lemmih> _frederik_: So you don't really have an 64bit box?
04:43:17 <_frederik_> the CPU is 64-bits
04:43:28 <_frederik_> but until today i have been running a 32-bit kernel
04:44:26 <esap> ski: what's the idea behind the '?' and '??' kinds?
04:44:30 <ski> if '=:<' is the subkinding relation, then the following appears to hold :  * =:< ??  # =:< ??  ! =:< ??  ??  =:< ?  (#) =:< ?
04:44:55 <ski> additionally, the kind of the type of a variable appears to be constrained to be '??'
04:45:00 <quicksilver> _frederik_: you can't compile a 64-bit app
04:45:08 <quicksilver> _frederik_: you need a 64-bit libc and everything
04:45:48 <ski> '??' looks like "anything but unboxed-tuples", while '?' is "anything at all"
04:45:57 <ski> so
04:46:00 <ski> :k (->)
04:46:03 <lambdabot> ?? -> ? -> *
04:46:13 <quicksilver> or that's my limited understanding
04:46:22 <ski> says that functions may not take unboxed tuples as argument, but may return unboxed tuples
04:46:39 <ski> (and functions themselves are boxed)
04:48:14 <ski> esap : anyway, i got the example above to work (i.e. i got "*** Exception: Prelude.undefined")
04:49:29 * ski wonders if this though may be attributed to the boxy type of the overall result .. like imprecise exceptions and 'IO' ?
04:49:35 <wolverian> the culrpit for my gtk2hs compilation program was running make with the -j2 flag
04:49:39 <_frederik_> quicksilver: i have installed 64-bit libs including libc, and compiled stuff seemingly successfully with 'gcc -m64'
04:49:51 <_frederik_> quicksilver: i don't know what you mean by "you can't compile a 64-bit app"
04:50:18 <quicksilver> _frederik_: no, you're right; what I meant was that you need a complete 64bit library setup
04:50:29 <quicksilver> _frederik_: just the compiler isn't enough
04:52:38 <matthew-_> is there no way to indicate binary input?
04:52:48 <matthew-_> 0x gives hex input
04:52:55 <quicksilver> you mean in the lexer?
04:52:57 <quicksilver> I don't thin kso
04:53:03 <matthew-_> 0b doesn't seem to work
04:53:14 <quicksilver> it's quite unusual for languages to support binary literals
04:53:21 <quicksilver> I don't know why, it would be useful sometimes
04:53:29 <matthew-_> yeah, it sure would!
04:54:21 * esap has a broken installation of emacs, it gives segv :-( 
04:54:46 <ski> when ?
04:55:35 <esap> the emacs crashes at startup :-(
04:55:39 <fasta> @where crypto
04:55:40 <lambdabot> http://www.haskell.org/crypto
04:56:02 <esap> prob. somebody updated debian packages and broke emacs :-(
04:57:17 <matthew-_> grrr. od is so close to being useful, if only it would allow me to swap endianness...
04:57:45 <quicksilver> > foldr1 (\a b -> 2*b + a) . reverse . map ((+(-48)).ord) $ "10011"
04:57:46 <lambdabot>  19
04:57:50 <quicksilver> matthew-_: :)
04:58:05 <matthew-_> quicksilver: well, I did expect someone to do that ;)
04:58:13 <quicksilver> and I was the one that did!
04:58:16 * quicksilver feels special
04:58:24 * matthew-_ awards quicksilver the special prize
04:58:53 <ski> s/48/(ord '0')/
04:59:19 <matthew-_> quicksilver: now just add that to ghc!
04:59:19 <quicksilver> yeah, but that makes it longer
04:59:42 <quicksilver> ski: anyway, why? 'ord' relates to a known encoding
04:59:48 <quicksilver> ski: it should be 48 even on a EBCDIC machine
05:02:04 <ski> quicksilver : the zero digit appears to be '240' in EBCDIC
05:02:10 <fasta> Can I install crypto from a package?
05:02:20 <fasta> I.e. not from source?
05:02:52 <quicksilver> ski: yes, but nonetheless, 'ord '0'' in haskell would still be 48
05:03:10 <quicksilver> ski: "ord" and "chr" are the same as toEnum and fromEnum; they relate to unicode code point
05:03:14 <quicksilver> ski: not the host encoding
05:03:25 <_frederik_> i don't understand why ghc is looking for libgmp.so.3, is that gmp version 3 which is ages old?
05:03:39 <_frederik_> latest version is 4.2
05:04:19 <ski> quicksilver : granted
05:04:27 <wolverian> hrm, is there a maildir library for haskell?
05:04:28 <Igloo> GMP 4.2.1 still has an SO version of 3
05:04:32 <norpan> _frederik_: the numbers have nothing to do with each oder
05:04:34 <norpan> other
05:05:34 <quicksilver> norpan: well, in the case of many library projects they do. But not that one :)
05:06:01 <norpan> if they do it's by accident
05:06:19 <_frederik_> ok
05:06:26 <ski> (it still feels cleaner not to directly refer to underlying encoding)
05:11:46 <quicksilver> norpan: well many libraries deliberately synchronise them, so it's not really an 'accident'
05:11:59 <quicksilver> norpan: it is however a 'non-compulsory design choice'
05:12:00 <quicksilver> :)
05:12:42 <ski> esap : "use diagonalization proofs on the unboxed types" meaning ?
05:12:55 <norpan> quicksilver: they synchronize them because they don't understand the significance of the numbers :)
05:13:08 <quicksilver> no, they synchronise them because they choose to
05:13:19 <quicksilver> they choose to use their major version as the libary major version soname
05:13:21 * quicksilver shrugs
05:13:30 <quicksilver> they might do it because they fear their users won't understand
05:13:47 <quicksilver> and in a few cases it is surely true that the library authors are following a convention they don't understand either
05:13:52 <quicksilver> but in many cases, they do understand :)
05:14:45 <esap> ski: well diagonalization can be used to find out that some values are not part of the type [e.g. the fixed point of 'not']
05:15:48 <ski> haskell 'not' ?
05:16:16 <esap> ski: well haskell 'not :: Bool -> Bool' has a fixed point.
05:16:17 <ski> or 'not# :: Bool# -> Bool#' ?
05:16:46 <esap> ski: not# has type not# :: Word# -> Word#
05:17:05 <ski> ok .. i was only introducing that hypothetically :)
05:17:57 <esap> ski: Right, for a type that has exactly two values, "True" and "False", there is no fixed point.
05:18:14 <ski> yep
05:19:13 <ski> so, by "some values are not part of the type" you mean distinguishing between expressions which have values in the type, and those that don't ?
05:19:59 <etnt> I just read the Wadler,SPJ paper "Comprehensive Comprehensions", very nice
05:20:19 <etnt> would it be possible to implement some of that in a non-lazy language, e.g Erlang ?
05:20:27 <esap> ski: well something like that. I think GHC does that with the kind distinction between # and * kinds.
05:21:42 <ski> etnt : hm .. looks intersting
05:21:43 <esap> ski: The idea is that you must not be able to use 'fix' in kind #.
05:22:36 <ski> but one can construct nonterminating functions between unboxed types
05:23:02 <esap> ski: you can use diagonalization to prove that 'fix' doesn't exist.
05:23:55 <esap> ski: And diagonalization works if you can build a fixed-point free function on the type.
05:24:32 <ski> 'if bottom then 0# else 1#' executes
05:25:43 <esap> ski: I'm getting kind error "Couldn't match kind '#' against '*'.
05:26:52 <ski> I# (if (let x = x in x) then 0# else 1# :: Int#)
05:27:14 <opqdonut> what are kinds? can anyone point to a short introduction?
05:28:11 <opqdonut> i've understood that for example one-parameter types have constructors of kind * -> * and two-parameter types * -> * -> * ?
05:28:20 <quicksilver> opqdonut: yes, that's right
05:28:24 <quicksilver> opqdonut: kinds classify types
05:28:38 <quicksilver> opqdonut: and, in Haskell proper, there is just a countable family of kinds
05:28:49 <ski> opqdonut : kinds are to types what types are to values
05:28:52 <esap> ski: If you wrap it using I# then it doesn't matter, because Int does have the 'undefined' value. But without I# wrapping, you'd be in trouble.
05:29:02 <opqdonut> ski, quicksilver: thanks, that was my intuition.
05:29:05 <opqdonut> but what is #?
05:29:10 <quicksilver> opqdonut: * : base types, * -> * : type constructors with one parameter
05:29:13 <opqdonut> and what is boxed/unboxed?
05:29:16 <quicksilver> opqdonut: that's not real haskell, it's GHC
05:29:24 <ski> esap : but i believe this is due to 'print' only taking a value of boxed type
05:29:26 <DRMacIver> Hm. Can one define fixities for non-operators? (Which would obviously only apply when used with ``)
05:29:35 <quicksilver> GHC has some ways to distinguish between the special types it uses for efficiency
05:29:36 <opqdonut> DRMacIver: iirc yes
05:29:42 <DRMacIver> Shiny
05:29:44 <DRMacIver> Thanks
05:29:50 <quicksilver> opqdonut: unboxed means it can't be _|_
05:29:53 <ski> esap : or do you mean this salvages the property in question ?
05:29:59 <opqdonut> quicksilver: ah, okay
05:30:07 <quicksilver> opqdonut: in practice this means that the compile is permitted to 'directly' store it in a register or a memory cell
05:30:07 <opqdonut> and # is unboxed whereas * is boxed?
05:30:16 <ski> opqdonut : the '#' in names is but a convention
05:30:17 <quicksilver> opqdonut: without bothering to thunk or indirect it
05:30:18 <opqdonut> yeah so i've understood
05:30:28 <ski> the kind '#' is the kind of unboxed types
05:30:40 <opqdonut> that i was after, thanks
05:30:40 <esap> ski: yes, having 'undefined' in the type will salvage it, then diagonalization no longer works.
05:30:46 <ski> the kind '(#)' is the kind of unboxed tuples (not same as '#')
05:30:59 <quicksilver> and ?? and ? are lubs
05:31:06 <quicksilver> of the various kinds
05:31:10 <quicksilver> IIRC
05:31:15 <quicksilver> there's a diagram somewhere I think
05:31:53 <quicksilver> http://hackage.haskell.org/trac/ghc/wiki/IntermediateTypes
05:31:55 <lambdabot> Title: IntermediateTypes - GHC - Trac
05:32:01 <quicksilver> diagram about 40% of the way down that page
05:32:09 <esap> ski: The reason is that f undefined = undefined for all strict f, so undefined is the fixed point of all functions that use their argument (e.g. 'not').
05:32:41 <ski> esap : but it seems to me this inclusion into a boxed type happens "after" the expression in question
05:33:51 <esap> ski: And diagonalization works only if there is a fixed-point free function.
05:34:25 <opqdonut> quicksilver: thanks again. are unboxed tuples like c arrays?
05:35:15 <tuxplorer> Had anyone deployed HAppS on FreeBSD? I want a port for haxml, but cant find one..
05:35:26 <ski> the intent of unboxed tuples is that the parts typically can lie directly in registers or on stack
05:35:49 <ski> (i.e. one can't directly handle unboxed tuples .. they aren't first-class)
05:37:02 <ski> esap : so i guess i'm wondering whether this behaviour wrt unboxed types is intentional or not
05:37:21 <esap> ski: I don't know.
05:38:04 <ski> hm .. you were talking about co-diagonal arguments, the other day .. any progress on understanding such ?
05:38:52 <esap> ski: no, not really.
05:44:13 <ski> Suppose there is an X and a map phi : Y -> X + X such that for every f : Y -> X there is at least one k : X -> 0 such that f(-) = case phi(-) of inl x0 -> abort (k x0); inr x1 -> x1. Then Y has the cofixed-copoint property.
05:44:21 <blakkino> i'm trying to understand the performance implications of lazyness.. if a function is really strict for some arguments (for example becose it will always do a "+" on two of them), then using strictness annotations on these params should always be ok, correct?
05:44:47 <Bourbaki> moin
05:44:48 <blakkino> be ok = doesn't decrease memory use
05:45:01 <Bourbaki> is there anything like the notion of the homology of an algorithm?
05:45:23 <quicksilver> blakkino: right
05:45:29 <ski> esap : though maybe we should understand the 'cofixed-copoint property' first ..
05:45:41 <quicksilver> blakkino: strictifying 'simple types' should never increase memory usage
05:45:53 <DRMacIver> @djinn (a -> b) -> (b -> b -> c) -> (a -> a -> c)
05:45:54 <lambdabot> f a b c _ = b (a c) (a c)
05:45:59 <quicksilver> blakkino: but you don't need to, very often, the compiler can deduce strictness in most simple cases
05:46:00 <blakkino> eheh
05:46:08 <blakkino> but this is not what i was asking.. let speak in general
05:46:27 <esap> ski: yea, we got to the point that a co-fixed-point is like a fixed point but on infinite sequences of actions.
05:47:26 <ski> infinite sequence of actions ?
05:47:26 <esap> ski: or maybe about continuations.
05:47:28 <blakkino> suppose there is a non-simple type, that is always used (= passed to a strict function)
05:47:45 <esap> ski: anyway, an arrow of type x :: A -> 0
05:47:57 <esap> ski: assuming of course that A is non-empty.
05:48:12 <esap> ski: and perhaps also that '0' is non-empty :-)
05:48:13 <blakkino> then strictness annotatios are still ok? i was thinking yes but i have found that after applying that to one prog memory performance was worst
05:48:40 <ski> esap : specifically assuming that 'A' is co-non-empty, i think
05:48:55 <quicksilver> blakkino: that sounds surprising
05:49:35 <esap> ski: The problem there is that if there are products and exponentials in the category, then existence of an arrow x :: A -> 0 means that A is empty.
05:50:08 <blakkino> quicksilver, maybe the problem depends on how the return value of this function is used?
05:50:16 <ski> esap : so we need to denounce cartesian-closedness :)
05:50:20 <esap> ski: well in general, you can say that A must be initial if there exists x :: A -> 0.
05:50:33 <esap> ski: yes.
05:52:11 <quicksilver> blakkino: it shouldn't do
05:52:24 <quicksilver> blakkino: if you can formulate a good example, mayb you should post to the -cafe about it
05:52:26 <esap> ski: that would be a problem if you wanted to embed this in a cartesian closed category. But you don't need to do this co-diagonal argument in a CCC.
05:52:52 * ski ponders how 'phi' above could work
05:53:11 <esap> ski: more like there will be some "co-CCC" concept.
05:53:47 * ski suspects *-autonomous categories, or something similar
05:54:16 * esap has no idea what would work as co-CCC. Would need to look the construction more carefully.
05:54:46 <ski> the point above is that 'k' would "name" 'f'
05:56:15 <ski> so 'phi' communicates with the current value ('-'), the current continuation of 'f', and also with 'k'
05:56:41 <ski> (obviously the '+' feels multiplicative)
05:57:16 <_frederik_> quicksilver: you were right, i had to read the debian amd64 howto and bootstrap a pure 64 system
05:57:33 <_frederik_> quicksilver: now things are functional
05:57:48 <quicksilver> _frederik_: :)
05:57:53 <quicksilver> _frederik_: good news!
06:06:07 <DRMacIver> Hm. It's really startling how readable Haskell one liners are.
06:08:05 <fasta> Is The GNU Scientific Library completely ported to Haskell?
06:08:32 <ihope_> Well, I still don't understand generic zippers. http://okmij.org/ftp/Haskell/Zipper1.lhs and its siblings pretty much introduced them, didn't they?
06:12:20 <fasta> @where libraries
06:12:20 <lambdabot> I know nothing about libraries.
06:12:34 <fasta> @go haskell libraries
06:12:36 <lambdabot> http://www.haskell.org/haskellwiki/Projects
06:12:37 <lambdabot> Title: Libraries and tools - HaskellWiki
06:13:40 <Bourbaki> is there anything like homology for an algorithm and is there any useful notion and insight due to this?
06:14:05 <Bourbaki> eg a sequence is a simple function
06:14:15 <Bourbaki> while n tori are recursive
06:17:46 <quicksilver> Bourbaki: you can talk about the recursion pattern of an algorithm
06:17:58 <quicksilver> Bourbaki: and what ordering principle is used in the proof of termination
06:18:08 <Bourbaki> well id like to have a topological look at algorithms though
06:18:17 <quicksilver> Bourbaki: I'm not aware ofa  study of this but I bet someone has looked at it
06:18:25 <vincenz> LeCamarade: thx
06:18:31 <Bourbaki> i think i have seen something like that on mrsi
06:18:53 <LoganCapaldo> > (\(x, y) -> x) (2, 1 / 0 )
06:18:55 <lambdabot>  2
06:18:57 <Bourbaki> where they have a problem space and some kind of algorithm and they try to deterime if the algrorithm is able to solve the problem
06:19:09 <Bourbaki> due to something that has a perelman kind of flavor
06:19:13 <vincenz> > 1 / 0
06:19:15 <lambdabot>  Infinity
06:19:25 <vincenz> > -1 / 0
06:19:27 <lambdabot>  -Infinity
06:19:32 <vincenz> > 1 / (-0)
06:19:34 <lambdabot>  -Infinity
06:19:38 <LoganCapaldo> > (\(x, y) -> x) (2, 1 `div` 0 )
06:19:40 <lambdabot>  2
06:19:41 <vincenz> wooo, -0
06:19:54 <Bourbaki> > 1 / 0 / -1 / 0
06:19:55 <lambdabot>      precedence parsing error
06:19:55 <lambdabot>         cannot mix `(/)' [infixl 7] and prefix ...
06:20:01 * vincenz wonders how -0 is encoded
06:20:05 <vincenz> Bourbaki: parens for -
06:20:17 <vincenz> > -0
06:20:18 * LoganCapaldo is pretty sure IEEE floating point just has a sign bit
06:20:20 <lambdabot>  0
06:20:28 <vincenz> LoganCapaldo: good point
06:20:31 <vincenz> > 1 `div` 0
06:20:34 <lambdabot>  Exception: divide by zero
06:22:01 <quicksilver> I think IEEE distinguishs -0 from +0 just as it distinguished -Infitity from +Infinity
06:22:07 <quicksilver> although I'm not an expert
06:23:41 <LoganCapaldo> It's been a while since comp arch. (wherein I learned everything I know about IEEE fp) but I think it does too, I think it's sign bit, mantissa, exponent
06:24:04 <LeCamarade> > 1 \ 0
06:24:04 <lambdabot>  Parse error
06:24:08 <LeCamarade> > 1 / 0
06:24:10 <lambdabot>  Infinity
06:24:21 <LeCamarade> > -1 / 0
06:24:24 <lambdabot>  -Infinity
06:24:36 <LoganCapaldo> But one over zero isn't really infinity in math land though, right?
06:24:48 <LeCamarade> lambdabot: Wow! You're clever. You go to UNSW, right?
06:25:00 <quicksilver> LoganCapaldo: not in the real numbers, no
06:25:21 <quicksilver> LoganCapaldo: in { R u \infinity } that is a sensible defintion, though
06:25:32 <LeCamarade> LoganCapaldo: IEEE says it is Infinity, but I'm more-comfortable getting _|_. Or ...
06:25:54 <LeCamarade> (/) should be: Int -> Int -> Maybe Int.
06:25:54 <vincenz> LeCamarade: you like (_|_)?
06:26:20 <LeCamarade> vincenz: Yeah. I hit bottom every day. We are friends by now. :o)
06:26:43 <LeCamarade> (____|____) <- bottom!
06:26:53 <LoganCapaldo> LeCamarade, naw that's too much work. the computation should just never terminate :)
06:26:58 <LeCamarade> > (_'_)
06:27:00 <lambdabot>  Undefined
06:27:08 <LoganCapaldo> > 1 `div` 0 -- inifinite loop :)
06:27:10 <lambdabot>  Exception: divide by zero
06:27:23 <LeCamarade> > let bottom = (_'_) in bottom
06:27:24 <lambdabot>  Undefined
06:27:54 <LoganCapaldo> That there is some impressive abuse of the the "'" symbol
06:28:07 <LeCamarade> :^D
06:28:38 <LoganCapaldo> @index (_'_)
06:28:38 <lambdabot> bzzt
06:28:39 <LeCamarade> True ... um, bottom. >:^)
06:29:07 <LeCamarade> bzzt?
06:29:15 <LoganCapaldo> it means I fail
06:29:33 <LoganCapaldo> @index catMaybes
06:29:33 <lambdabot> Data.Maybe
06:29:56 <LoganCapaldo> @index catMaybez
06:29:56 <lambdabot> bzzt
06:29:59 <LeCamarade> LoganCapaldo: No, (_'_) was just bound for lambdabot.
06:30:35 <LoganCapaldo> bound for lambdabot
06:31:07 <quicksilver> is there an @unlet?
06:31:11 <quicksilver> @help unlet
06:31:11 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
06:31:17 <_frederik_> fasta: alberto ruiz has ported GSL to haskell, yes
06:31:18 <LoganCapaldo> This summer, see (_'_) in an epic journey, searching for it's best friend, in "Bound for Lambdabot"
06:31:25 <LeCamarade> quicksilver: I think you can just overwrite it.
06:31:45 <LeCamarade> With yet another (_'_)
06:31:48 <LeCamarade> :o)
06:31:53 <quicksilver> LeCamarade: I'm worrying about people @let'ing over prelude functions
06:31:54 * vincenz ++
06:32:00 <LeCamarade> Oh.
06:32:01 <vincenz> wait, no side-effects
06:32:01 <quicksilver> LeCamarade: presumably by mistake not deliberately
06:32:13 <vincenz> modify (+1)
06:32:17 <quicksilver> LeCamarade: I don't want to test it incase it works :)
06:32:29 <LeCamarade> :^D
06:32:50 <LeCamarade> @let self = IO "lambdabot"
06:32:51 <lambdabot> <local>:10:7: Not in scope: data constructor `IO'
06:33:10 <LeCamarade> @let self = (return "lambdabot")::IO String
06:33:13 <lambdabot> Defined.
06:33:16 <LoganCapaldo> Aren't letted things letted in module L anyway?
06:33:26 <ski> @let length xs = 0
06:33:26 <LoganCapaldo> > L.(_'_)
06:33:26 <lambdabot> <local>:2:45:     Ambiguous occurrence `length'     It could refer to either ...
06:33:27 <lambdabot>   Not in scope: data constructor `L'
06:33:28 <quicksilver> I don't know
06:33:47 <LeCamarade> @unlet self
06:33:47 <lambdabot>  Parse error
06:33:54 <LeCamarade> @unlet self = undefined
06:33:55 <lambdabot> <local>:11:0:     Multiple declarations of `L.self'     Declared at: <local>:...
06:34:04 <vincenz> @undefine
06:34:05 <lambdabot> Undefined.
06:34:16 <LeCamarade> Oh. And the Levenshtein gets unlet and makes let out of it.
06:34:29 <LoganCapaldo> @let foo = 3
06:34:31 <lambdabot> Defined.
06:34:32 <LoganCapaldo> > L.foo
06:34:34 <lambdabot>  3
06:34:35 <LeCamarade> > self >>= putStrLn
06:34:36 <lambdabot>   Not in scope: `self'
06:34:37 <vincenz> > foo
06:34:38 <lambdabot>   Not in scope: `foo'
06:34:53 <ski> @let reverse xs = []
06:34:54 <lambdabot> Defined.
06:34:57 <ski> > L.reverse [0,1]
06:34:58 <lambdabot> Terminated
06:35:08 <LoganCapaldo> That was bizzare
06:35:13 <ski> > reverse [0,1]
06:35:15 <lambdabot> Terminated
06:35:20 <ski> hmmm
06:35:23 <LeCamarade> <lambdabot> Enough!!! X^(
06:35:33 <LoganCapaldo> > Data.List.reverse [0,1]
06:35:35 <lambdabot>  [1,0]
06:36:06 <LoganCapaldo> > L.reverse
06:36:08 <lambdabot> Terminated
06:36:17 <LoganCapaldo> Hrrrrrrrrrrrrm
06:36:25 <LoganCapaldo> > reverse
06:36:26 <lambdabot> Terminated
06:36:27 <lambdabot> Leave me alone!
06:36:30 <ski> 15:34 <ski> @let reverse xs = []
06:36:30 <ski> 15:34 <lambdabot> Defined.
06:36:30 <ski> 15:34 <ski> > reverse [0,1]
06:36:30 <ski> 15:34 <lambdabot>  [1,0]
06:36:39 <ski> @undefine reverse
06:36:40 <lambdabot> Undefined.
06:36:45 <vincenz> @undefine is global
06:36:46 <lambdabot> Undefined.
06:36:49 <vincenz> it clears the entire L thing
06:36:52 <LoganCapaldo> yep
06:36:54 <LoganCapaldo> no more foo
06:36:56 <LeCamarade> @msg #haskell You have used up your evaluations for today.
06:36:56 <LoganCapaldo> > L.foo
06:36:56 <lambdabot> Not enough privileges
06:36:57 <lambdabot>   Not in scope: `L.foo'
06:37:01 <ski> oh
06:37:16 <LeCamarade> :o(
06:37:28 <LoganCapaldo> lambdabot mad at us?
06:37:33 <ski> @list let
06:37:33 <lambdabot> eval provides: run let undefine
06:37:37 <ski> @help let
06:37:37 <lambdabot> let <x> = <e>. Add a binding
06:37:40 <ski> @help undefine
06:37:41 <lambdabot> undefine. Reset evaluator local bindings
06:37:44 <quicksilver> oh, that's clever
06:37:44 <lambdabot> I will no longer evaluate
06:37:46 <quicksilver> @help run
06:37:46 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
06:38:04 <quicksilver> is "run" == ">"
06:38:07 <quicksilver> ?
06:38:09 <ski> yes
06:38:11 <LoganCapaldo> yes
06:40:34 <LeCamarade> :w
06:40:37 <LeCamarade> :o(
06:43:35 <LeCamarade> Where do I find the MD5 is the standard libs?
06:43:44 <LeCamarade> s/is/in/gi
06:44:10 <LoganCapaldo> @where md5
06:44:10 <lambdabot> I know nothing about md5.
06:44:17 <LoganCapaldo> @docs md5
06:44:17 <lambdabot> md5 not available
06:44:25 <LeCamarade> @go haskell md5 library
06:44:27 <lambdabot> http://hackage.haskell.org/packages/archive/pkg-list.html
06:44:27 <LoganCapaldo> @hoogle md5
06:44:28 <lambdabot> No matches found
06:44:36 <LoganCapaldo> @hoogle MD5
06:44:36 <lambdabot> No matches found
06:45:09 <dons> LeCamarade: in the crypto library
06:45:19 <dons> but its probably faster to just binding to openssl/md5
06:46:14 <fasta> _frederik_: no, he only ported a tiny part of it.
06:47:05 <dons> LeCamarade: see http://thread.gmane.org/gmane.comp.lang.haskell.cafe/24165/focus=24170 for a ridiculously fast md5
06:47:08 <lambdabot> Title: Gmane Loom, http://tinyurl.com/3ddtwg
06:47:30 <dons> (an efficient binding to the efficient openssl md5,
06:47:31 <dons>     foreign import ccall "openssl/md5.h MD5" c_md5
06:47:31 <dons>         :: Ptr CChar -> CULong -> Ptr CChar -> IO (Ptr Word8)
06:47:40 <eivuokko> Reminds me, I should add some Windows API Cryptography bindings to Win32.
06:48:20 <dons> i reckon openssl is a prime candidate for a good binding
06:48:27 <dons> lots of bytestringy goodness in there
06:48:52 <dons> LeCamarade: otherwise, check the Crypto library on hackage, it has a pure haskell md5. there's a few others too
06:49:42 <quicksilver> dons: also , certificate manipulation + encryption are a bit fiddly
06:49:48 <quicksilver> dons: and they're just BEGGING for a type system
06:49:53 <quicksilver> dons: to help you make sense of it
06:49:59 <LeCamarade> dons: Merci beaucoup.
06:50:29 <quicksilver> dons: I'm better one of the reasons there aren't more cool public-private key algorithm tricks available, is that the C binding is so painfully verbose
06:50:34 <quicksilver> s/better/betting/
06:51:00 <LeCamarade> I gather that's where I'll find SHA1, if not the whole SHA* family.
06:51:09 <quicksilver> dons: not that it's any of my business, but isn't it getting on for Stupid O'Clock at your end of the world? :)
06:51:17 <LeCamarade> And ROT13. :o)
06:51:47 <LeCamarade> And crypt. And pig latin. :^D
06:52:46 <ski> don't forget 'id'
06:57:32 <_frederik_> fasta: that's true
07:10:54 <dcoutts> wolverian: yeah, sorry about that, the gtk2hs makefile doesn't work with -j2, I tried to make it all turned out to be rather hard
07:11:54 <dcoutts> squark: btw, the next version of gtk+ will have major improvements in the osx native (ie non-x11) backend.
07:14:11 <dcoutts> squark: and the latest version of gtk2hs has support both for the cairo svg backend, and for the svg loader that renders with cairo
07:14:34 <dcoutts> so you can load svg files and render them, and you can also do custom vector drawing with cairo and save that to a svg file
07:14:49 <squark> thank you dcoutts
07:15:24 <squark> when does btw will be out?
07:15:39 <dcoutts> there's a release candidate out at the moment
07:16:03 <dcoutts> haskell.org/gtk2hs/gtk2hs-0.9.11.3.tar.gz
07:16:34 <swiert> any idea when the newer version gtk+ will be released?
07:17:26 <dcoutts> swiert: lemme check...
07:19:37 <vincenz> dcoutts: what's new in it?  And does is it backwards compatible?
07:19:48 <dcoutts> vincenz: it's always backwards compatible
07:19:58 <dcoutts> vincenz: it's got lots of new things too :-)
07:20:02 <vincenz> Spiffy :)
07:20:12 <dcoutts> vincenz: it's integrating libglade for one
07:20:15 <vincenz> I'll try it post-contest, can't expect all my team-members to update
07:20:48 <glen_quagmire> IFPC?
07:20:59 <vincenz> ICFP
07:21:05 <glen_quagmire> i registered for it with C as language
07:21:12 * vincenz winces
07:21:14 <Syzygy-> ...
07:21:32 <dcoutts> swiert: so gtk+-2.12 will be a dep of gnome-2.22 which will be released in September
07:21:45 <glen_quagmire> oh noes
07:21:56 <swiert> dcoutts: ta.
07:22:02 <glen_quagmire> that would be bad. gnome is huge
07:22:18 <glen_quagmire> and linus disapproved of gnome
07:22:19 <dcoutts> swiert: and gtk+ is usually released some time before gnome to give the gnome apps plenty of time to discover gtk bugs and get it stabilised
07:32:01 <quicksilver> dcoutts: so, a useful OSX native version of GTK around september this year/
07:32:07 <quicksilver> dcoutts: that would be quite froody
07:32:13 <tuukkah> is ChrisKuklewicz someone on the channel?
07:32:54 <dcoutts> quicksilver: I'm not sure exactly, all I saw was an item in the release notes of a dev version of gtk saying major osx backend improvements
07:33:15 <quicksilver> nice
07:33:18 <dcoutts> quicksilver: so I don't know if they've got up to the stage of having a native looking theme
07:33:28 <quicksilver> I don't care much if it looks native
07:33:36 <dcoutts> perhaps just got the thing stable enough not to crash :-)
07:33:42 <quicksilver> but running in its own layer rather than X11 would be midly nice
07:33:48 <quicksilver> although I can't say it bothers me much
07:35:29 <matthew-_> oh, UK folk may like to sign   http://petitions.pm.gov.uk/iplayer/
07:35:34 <squark> is thi project alive ??
07:35:36 <matthew-_> (sorry, it's off topic)
07:35:36 <squark> http://developer.imendio.com/projects/gtk-macosx
07:35:38 <lambdabot> Title: Gtk+ for Mac OS X | Imendio Developer Pages
07:44:31 <wolverian> dcoutts, (re: -j2) thanks. I don't think it's documented in INSTALL. maybe it should be.
07:44:40 <wolverian> s/\.$/?/
07:44:52 <dcoutts> wolverian: mm, good point, will do
07:45:08 <wolverian> @karma+ dcoutts
07:45:08 <lambdabot> dcoutts's karma raised to 50.
07:48:33 <dcoutts> done
07:57:31 <matthew-_> mmm. So it turns out the Friberg and Friburg are very different places in Germany
07:59:01 <Syzygy-> matthew-_: Freiberg, Freiburg? Or do you -really- find Friberg and Friburg?
07:59:08 <vincenz> freiburg is in switzerland
07:59:31 <matthew-_> Syzygy-: sorry, I meant Freiburg and Freiberg
07:59:33 <Syzygy-> vincenz: Freiburg is Fribourg, isn't it? The one that has a french and a german name?
07:59:39 <Syzygy-> matthew-_: Thought so... :P
07:59:54 <vincenz> Syzygy-: yes
08:00:03 <vincenz> french region of switzerland
08:03:16 <shapr> yarr
08:31:44 <_frederik_> on amd64, aren't enums 64 bits? but hsc2hs turns mine into Word32
08:35:00 <quicksilver> _frederik_: I doubt it
08:35:11 <quicksilver> _frederik_: do you really have an enum with more than 4 billion members?
08:35:17 <quicksilver> _frederik_: that sounds like a big .h file :)
08:36:26 <quicksilver> _frederik_: Oh, sorry, I think I might be wrong
08:36:38 <quicksilver> _frederik_: looks like GCC does produce 64 bit enums on (some) 64 bit machines
08:36:49 <quicksilver> _frederik_: could be an hsc2hs bug
08:38:12 <_frederik_> yeah
08:39:28 <shapr> Good morning #haskell!
08:39:34 <_frederik_> good morning shapr
08:39:36 <Syzygy-> Good morning shapr!
08:40:08 <_frederik_> well i would be surprised if it were a bug in hsc2hs - there are a lot of libraries that use enums and a lot of people that use amd64, no?
08:40:19 <lispy> quicksilver: in C at least you could create your enum values as powers of 2 so you can OR them together...then might want to have more than 32 values :)
08:40:49 <shapr> I was snickering at a thoroughly geeky car site ( http://www.rickwrench.com/ ) and then realized that the random deeply comments are just like the sort of things I say in conversation when talking about Haskell code...
08:40:53 <lambdabot> Title: Rickwrench, Alfa GTV, Falcon Squire, Corvair
08:40:56 <_frederik_> lispy: the gcc documentation says that full-width enums are used only for compatibility with other compilers
08:40:58 <Syzygy-> lispy: That, however, is an artefact of wanting to name constants. We can do -that- differently in Haskell.
08:41:05 <shapr> er, "random deeply geeky comments"
08:41:35 <shapr> I could even understand about half of his geeky car comments too. That's pretty sad. At least I have a girlfriend.
08:42:00 <mauke> I still have a threading problem
08:42:15 <quicksilver> lispy: yeah, that's a daft use of enums IMO
08:42:20 <quicksilver> lispy: but you're absolutely right, yes
08:42:32 <mauke> I have a thread that calls accept in a loop
08:42:58 <mauke> I can't think of any way to make it stop accepting without creating a resource leak/race condition
08:43:15 <Syzygy-> enum flags = { bit0 = 1, bit1 = 2, bit2 = 4, bit3 = 8, bit4 = .. bit 63 = 9223372036854775808 };
08:43:25 <quicksilver> mauke: throw an exception to it
08:43:37 <Syzygy-> (or however the enum syntax was... couldn't be bothered checking)
08:44:03 <quicksilver> mauke: which resource are you concerned will leak?
08:44:05 <mauke> quicksilver: that leaks a socket if the exception occurs immediately after accept
08:44:30 * quicksilver thinks about that for a moment
08:44:45 <mauke> foo = do { (t, _) <- accept s; forkIO (doStuff t); foo }
08:45:07 <quicksilver> yes, I have code isomorphic to that myself
08:45:24 <quicksilver> I think you make a very interesting point
08:45:24 <mauke> t can leak there
08:45:33 <quicksilver> the problem is that t would be out-of-scope in an exception handler
08:45:36 <quicksilver> (right?)
08:45:43 <mauke> t may not exist yet
08:45:46 <quicksilver> exactly
08:45:52 <quicksilver> which is why it would be out of scope
08:45:57 <sjanssen> how would you do this in C?
08:46:13 <vincenz> how about something like: do { (t, _) <- accept s; forkIO (withResource t doStuff); foo}
08:46:33 <mauke> vincenz: that's the same code
08:46:53 <sjanssen> vincenz: the problem is that the thread might be interrupted after 'accept', but before 'forkIO'
08:47:07 <mauke> sjanssen: with a global event loop
08:47:15 <quicksilver> yes, one interesting question is 'can that happen, or can we stop it happening?'
08:47:28 <vincenz> sjanssen: oic
08:47:29 <quicksilver> GHC gives us some guarantee about where exceptions may occur
08:47:34 <vincenz> sjanssen: how can that happen?
08:47:43 <sjanssen> vincenz: throwTo
08:47:50 * vincenz nods
08:47:59 <vincenz> how about wrapping it in something atomic?
08:48:00 <quicksilver> what about 'block' ing the whole function
08:48:08 <Saizan> bracket (accept s) (handleT) (\(t,_) -> forkIO (doStuff t))?
08:48:09 <quicksilver> but then specifically 'unblock' in the accept
08:48:09 <lambdabot> Saizan: You have 1 new message. '/msg lambdabot @messages' to read it.
08:48:22 <DRMacIver> Hm. I need a name for the obvious function (a -> a -> Ordering) -> (a -> a -> Ordering) -> (a -> a -> Ordering)
08:48:32 <mauke> Saizan: what if the exception hits inside accept?
08:48:40 <DRMacIver> (Compares by the first, then by the second if the first thinks its arguments are equal)
08:49:02 <quicksilver> DRMacIver: why not just use the Ord instance on (a,a) ?
08:49:08 <quicksilver> DRMacIver: cos that's what it does :)
08:49:29 <DRMacIver> Because it's for combining custom ordering functions.
08:49:33 <quicksilver> ah!
08:49:54 <quicksilver> I see, only one 'a'
08:49:56 <quicksilver> but two orderings
08:50:03 <Saizan> mauke: ah, yes, you need an external handler for that
08:50:37 <vincenz> mauke: how about making it atomic?
08:50:38 <DRMacIver> Yes. For example I have String and I want to define the custom ordering function which orders first by length then by alphabetical order.
08:50:43 <mauke> vincenz: how?
08:50:46 <vincenz> hmm true
08:50:56 <vincenz> oh
08:51:02 <quicksilver> mauke: what about something like this:
08:51:08 <vincenz> you can make it atomic until the fork
08:51:12 <DRMacIver> So I could do (descending length) `somethingorother` compare
08:51:13 <vincenz> and have it only release on error
08:51:24 <quicksilver> block $ do { (t,_) <- unblock $ accept s; unblock $ do {...} }
08:51:33 <quicksilver> mauke: you 'block' the whole thing
08:51:40 <quicksilver> mauke: and then 'unblock' the two parts
08:51:48 <quicksilver> (and add suitable handlers, not shown in my example'
08:51:57 <mauke> oh, I didn't know about block :-)
08:51:57 <vincenz> quicksilver: unblocking the accept can lead to an exception to happen during accept or during exit of accept?
08:52:18 <quicksilver> vincenz: I hope, only during, but not during exit
08:52:20 <quicksilver> vincenz: I'm not 100% sure
08:52:28 <DRMacIver> Anyway, this is technically trivial, I just don't know what to call the damn thing. :)
08:52:39 <quicksilver> DRMacIver: `failingthat`
08:52:52 <DRMacIver> Mm. Doesn't read well.
08:52:53 <quicksilver> DRMacIver: `orifequal`
08:52:58 <vincenz> quicksilver: seems like there's some missing semantical construct
08:53:00 <roconnor> @type block
08:53:02 <lambdabot> Not in scope: `block'
08:53:10 <quicksilver> @type Control.Exception.block
08:53:13 <lambdabot> forall a. IO a -> IO a
08:53:40 <quicksilver> mauke: I think this is an interesting subject and you should post to the -cafe
08:53:45 <mauke> quicksilver: accept isn't atomic
08:53:45 <oerjan> "orOn" ?
08:53:47 <vincenz> quicksilver: +1
08:53:49 <quicksilver> mauke: I think there probably needs to be a combinator for this
08:53:56 <vincenz> quicksilver: what I was saying :)
08:54:03 * DRMacIver goes with `secondary` (as in secondary ordering)
08:54:04 <vincenz> >quicksilver: seems like there's some missing semantical construct
08:54:10 <mauke> unblocking exceptions during accept leads to the same problem, just inside accept
08:54:11 <quicksilver> mauke: so?
08:54:17 <quicksilver> mauke: no, it doesn't
08:54:21 <mauke> why not?
08:54:21 <quicksilver> mauke: you have to trust the authors of accept
08:54:28 <mauke> hah
08:54:30 <sjanssen> mauke: have you tested that throwTo actually stops the accept?
08:54:31 <mauke> I don't
08:54:32 <quicksilver> mauke: if accept is correctly written, then if any exception occurs inside it
08:54:35 <vincenz> quicksilver: what of return path?
08:54:37 <quicksilver> then the resource will be release
08:54:46 <quicksilver> mauke: well if accept isn't correctly written there is certainly nothing you can do
08:54:49 <mauke> sjanssen: I don't think so
08:55:00 <mauke> hmm
08:55:05 <quicksilver> vincenz: return path?
08:55:10 <vincenz> quicksilver: from accept
08:55:11 <sjanssen> mauke: Network.accept makes an FFI call, which can't be interrupted
08:55:31 <vincenz> right after accept finishes and we're still in unblock
08:55:32 <quicksilver> sjanssen: I would expect accept to be an interruptable FFI
08:55:42 <quicksilver> vincenz: that place 'doesn't exist'
08:55:45 <quicksilver> vincenz: (I hope)
08:55:50 <sjanssen> quicksilver: there is such a thing?
08:55:58 <quicksilver> vincenz: If I understand the semantics of unblock correctly
08:55:59 <vincenz> quicksilver: sure it does
08:56:02 <quicksilver> vincenz: there is no 'gap'
08:56:04 <vincenz> unblock $ id $ accept s
08:56:06 <vincenz> there it s
08:56:07 <vincenz> is
08:56:59 <mauke> throwErrnoIfMinus1Retry_repeatOnBlock "accept" (threadWaitRead (fromIntegral s)) (c_accept s sockaddr ptr_len)
08:57:23 <fasta> Can I open 2 different Haskell mode buffers in Emacs?
08:57:41 <quicksilver> yes, you can have as many haskell mode buffers as you want...
08:57:42 <mauke> quicksilver: I don't see any special protection against exceptions in the following code
08:57:49 <sjanssen> mauke: ah yes, throwTo should be able to interrupt that
08:57:55 <glen_quagmire> is there a portable ghc? like putting it in USB
08:58:08 <vincenz> afaict, you'll have to block accept
08:58:20 <fasta> quicksilver: and how?
08:58:25 <mauke> vincenz: that's exactly what I not want :-)
08:58:25 <sjanssen> mauke: but that code could easily be fixed to be exception safe
08:58:30 <quicksilver> mauke: following where?
08:58:34 <vincenz> what accept needs is a continuation!!!
08:58:39 <sjanssen> mauke: just bracket around c_accept
08:58:50 <vincenz> @hoogle bracket
08:58:51 <lambdabot> IO.bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
08:58:51 <lambdabot> IO.bracket_ :: IO a -> (a -> IO b) -> IO c -> IO c
08:58:51 <lambdabot> Control.Exception.bracket_ :: IO a -> IO b -> IO c -> IO c
08:58:52 <mauke> quicksilver: Network.Socket.accept, after the call to c_accept
08:58:59 <fasta> quicksilver: I mean different comint buffers.
08:59:01 <quicksilver> ah, I see what you mean
08:59:11 <quicksilver> fasta: yes, I think you just have to rename one of them
08:59:16 <fasta> quicksilver: ok
08:59:22 <mauke> sjanssen: so the library is broken?
08:59:22 <quicksilver> fasta: but the one with the 'right name' will be the one that C-c C-l targets
08:59:34 <sjanssen> mauke: from my cursory reading, yes
08:59:46 <mauke> argh
08:59:51 <sjanssen> mauke: do bring it up on cafe or libraries, see what the wise men say
08:59:52 <DRMacIver> Ho hum. Anyone bored and feel like ripping my code to shreds? :) http://paste.lisp.org/display/43973
08:59:53 <quicksilver> mauke: I think this definitely deserves a -cafe post, if you have time
09:00:02 <quicksilver> mauke: it seems like a very important and interesting point
09:00:04 <DRMacIver> (It's just a silly example snippet. I'm really looking for style comments)
09:00:57 <vincenz> DRMacIver: I think there's a comparing
09:01:02 <mauke> I wonder how existing haskell programs can use accept
09:01:02 <vincenz> @hoogle comparing
09:01:03 <lambdabot> No matches found
09:01:11 <vincenz> comparing f x y = f x `compare` f y
09:01:46 <quicksilver> mauke: I think the resource leak gets tidied up by the GC, eventually
09:01:55 <genneth> is there a function like makeRelativeToCurrentDirectory which does the reverse? namely, takes a path relative to the currently directory and absolutises it?
09:01:59 <quicksilver> mauke: but I do agree it's a problem
09:02:08 <DRMacIver> vincenz: Didn't find it when I looked.
09:02:28 <DRMacIver> vincenz: And I found having 'ascending' and 'descending' as opposites worked nicely, so given its triviality I'd probably have redefined it anyway. :)
09:02:50 <sorear> (hello)
09:03:07 <sorear> @seen hpaste
09:03:07 <lambdabot> I saw hpaste leaving #haskell 1d 3h 12m 58s ago, and .
09:03:11 <sorear> @seen shapr
09:03:11 <lambdabot> shapr is in #xmonad, #haskell-blah, #haskell and #scannedinavian. I last heard shapr speak 5m 35s ago.
09:03:40 <sjanssen> DRMacIver: some nits: http://paste.lisp.org/display/43973#1
09:03:53 <shapr> sorear: you screamt?
09:04:04 <shapr> sorear: Ah yes..
09:04:36 <sorear> http://members.cox.net/stefanor/hpaste.patch
09:04:47 <sorear> assuming you still haven't gotten the email
09:05:02 <shapr> I've got it.. fixing now.
09:06:17 <_frederik_> so is there a way to specify explicitly which type an enum should use?
09:07:02 <scook0> _frederik_: what do you mean?
09:07:10 <DRMacIver> sjanssen: Hm. It's not easy to see what you changed. Anything other than the case statement (which is a good point, thanks).
09:07:14 <DRMacIver> ?
09:07:26 <sfultong> can I get some help with an error message?
09:08:05 <quicksilver> scook0: he's trying to use hsc2hs on a 64bit platform and it thinks his enums are Word32s
09:08:09 * wli looks around for Haskell blog code.
09:08:12 <vincenz> DRMacIver: more nits http://paste.lisp.org/display/43973#2
09:08:27 <fasta> quicksilver: renaming *haskell* to *foo* and then doing C-c C-l in a another Haskell buffer just uses *foo*.
09:08:39 <quicksilver> fasta: oh, that's odd
09:08:40 <sjanssen> DRMacIver: all of my changes were in secondary
09:08:50 <quicksilver> fasta: well you'll need to poke into the code to understand, I"m afraid
09:09:05 <mauke> does haskell provide any access to fcntl F_GETFL/SETFL?
09:09:11 <scook0> quicksilver: ah -- without the context it sounded like a weird question
09:09:47 <DRMacIver> sjanssen: Ok. Thanks.
09:09:53 <quicksilver> vincenz: why would you do that? (make 'count' more verbose)
09:09:53 <wli> vincenz: I'm completely baffled.
09:09:53 <sjanssen> DRMacIver: I removed extra parens around (f x y) and the EQ/LT/GT constructors, I broke the single line case to multiple lines, and I combined the LT/GT branches
09:10:20 <vincenz> quicksilver: I prefer naming things, so as to have it more legible
09:10:51 <DRMacIver> vincenz: Hm. I don't find yours more readable.
09:10:58 <vincenz> tastes differ
09:10:58 <DRMacIver> This is probably a matter of taste though.
09:10:59 <vincenz> :)
09:11:02 <DRMacIver> Yeah
09:11:05 <vincenz> I don't like having lines that are too long
09:11:22 * quicksilver shrugs
09:11:33 <quicksilver> I restrict to 72 chars, typically
09:11:42 <quicksilver> but I still wouldn't bother to name the parts of the expression
09:11:50 <quicksilver> I'd just break up the expression at some appropriate dots
09:12:00 <vincenz> again, tastes :)
09:12:21 <helikoptik> has anyone used swfupload with activescaffold?
09:12:46 <helikoptik> oops w
09:12:47 <sjanssen> vincenz: http://paste.lisp.org/display/43973#3 I recommend this where indentation
09:12:50 <helikoptik> wrong channel
09:13:02 * wli knows nothing of arrows.
09:13:20 * wli is rather bad at monads, too.
09:13:33 <sjanssen> vincenz: I find that the 'where foo' indentation requires much more fiddling with strange column widths
09:13:42 <Botje> wli: you'll only learn by using them :)
09:13:54 <vincenz> sjanssen: nah, I use vim and 2-space tabs
09:13:57 <vincenz> virtual tabs
09:14:04 <sfultong> I like this explanation of a monad: http://koweycode.blogspot.com/2007/01/think-of-monad.html
09:14:06 <lambdabot> Title: koweycode: think of a monad...
09:14:07 <shapr> wli: Hiya! Long time no see! How's code?
09:14:54 <wli> shapr: Not much happening. Mostly I'm farting around looking for blog stuff with LaTeX plugins. I installed wordpress and don't seem to be able to get started, so I'm fishing.
09:15:04 <sfultong> I use vim and 3 space tabs... :-P
09:15:16 <sjanssen> > length "where "
09:15:20 <lambdabot>  6
09:15:32 <mrd> 2-space vs 3-space tabs, fight to the death!
09:15:34 <sjanssen> vincenz: you're just lucky that 'where' is odd :)
09:15:40 <vincenz> sjanssen: as is let :)
09:15:40 * wli uses nvi with 8-space hard tabs except when using ex (where he also uses 8-space hard tabs).
09:15:49 <vincenz> sjanssen: I commented about that today in my blog :P
09:15:55 <shapr> wli: Bringert's Hope is good but monolithic, and there's a HAppS blog nearly ready for use.
09:16:01 <sjanssen> vincenz: I bet your head explodes when indenting 'do' :)
09:16:10 <vincenz> sjanssen: not really
09:16:13 <vincenz> foo x = do
09:16:14 <vincenz>   bla
09:16:20 <mrd> that's what i "do" as well
09:16:29 <shapr> wli: If you want to pick up monads, check out http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
09:16:31 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ..., http://tinyurl.com/ecqzl
09:16:34 <quicksilver> I use an editor which understands haskell intentation :)
09:16:49 <wli> shapr: I don't really need to play with the code too much.
09:16:51 <mrd> i use emacs as well, but i turned off the smart mode
09:16:54 <vincenz> quicksilver: how can that be? the indentation is part of the semantics
09:17:04 <mrd> because i decided it wasn't my style
09:17:13 <vincenz> do {a; do { b; c;} d;}
09:17:14 <wli> shapr: Well, I probably won't really be trying to learn monads anytime today.
09:17:17 <vincenz> would give problems for your editor
09:17:28 <quicksilver> vincenz: it just needs to understand what the possible valid indentations are
09:17:35 <quicksilver> vincenz: it doesn't know which one you mean, of course
09:17:38 <vincenz> emacs?
09:17:41 <quicksilver> vincenz: so it lets you cycle between them
09:17:42 <mrd> emacs is actually really good at handling brackets and semicolons if you like to use those .. :/
09:18:00 <quicksilver> yes, although I doubt it is the only editor to have haskell indentation support
09:18:04 <shapr> wli: That sigfpe post will probably clear up monads in less than an hour.
09:18:35 <vincenz> mrd: so is vim... go to first {  then type v%=
09:18:44 <wli> shapr: I'll take a look.
09:18:54 <vincenz> quicksilver: ah, yeah, I can't work with emacs
09:18:56 <_frederik_> scook0: sorry i left
09:19:20 <_frederik_> i figured out the problem, on amd64, ghc's Int is 8 bytes, but CInt is 4 bytes
09:19:27 <_frederik_> and for some reason enums are still 4 bytes
09:19:34 <_frederik_> so i have to change enum types from Int to CInt
09:19:38 <mrd> what's the v% motion?
09:19:49 <mrd> visual to paren?
09:19:53 <wli> shapr: Any tips on setting up hope for blogging?
09:19:57 <sjanssen> _frederik_: you should always use CInt when interfacing with C
09:20:09 <vincenz> Anyone a blogspot'ter? (blogger)?
09:20:10 <_frederik_> sjanssen: thanks for telling me *now* :)
09:20:17 <sjanssen> _frederik_: never ever use Int, it is just a big bug waiting to happen :)
09:20:31 <sorear> mrd: you could always type it slowly :)  I think so
09:20:37 <mrd> vincenz: anyhow what I meant was: if you like the method of prefixing lines with semicolons, it readjusts the code so that the semicolons line up with the brackets
09:20:40 <sorear> mrd: = is reindent-selection
09:20:41 <wli> shapr: The big thing I need is LaTeX plugins of some sort.
09:20:44 <sjanssen> _frederik_: don't feel bad, the X11 package (one of the libraries that used to be distributed with GHC) had this problem for years
09:20:48 * vincenz wants to know how to get "read on" links for his blogs
09:21:23 <_frederik_> sjanssen: interesting. i always use X11 when i need to see how to do FFI
09:21:30 <_frederik_> presumably it is fixed these days
09:21:43 <mauke> haha, I've found a way to interrupt accept "safely"
09:21:44 <sjanssen> yes, it was fixed just a couple months ago
09:21:44 <mrd> sorear: btw, do you happen to know of any equivalent for emacs's align-regexp in vim
09:21:52 <_frederik_> oh
09:22:07 <sorear> mrd: No.
09:22:23 <_frederik_> sjanssen: in that case maybe i can blame it for my confusion
09:23:33 <mrd> that's one thing i really miss when i'm working in vim
09:23:39 <mrd> maybe someone has written a plugin
09:23:53 <mauke> 1) open temporary file  2) dup the file descriptor over the socket used by accept  3) watch accept die with ENOTSOCK
09:24:06 <DRMacIver> sjanssen: Hm? What's wrong with Int?
09:24:25 <mauke> (this is a horrible hack, of course)
09:25:26 <sjanssen> DRMacIver: Haskell's 'Int' isn't guaranteed to be the same as C's 'int'
09:25:45 <sjanssen> DRMacIver: notably on the AMD64 platform
09:25:56 <earthy> mrd: Align.vim at http://http://www.vim.org/scripts/script.php?script_id=294
09:26:20 <DRMacIver> Ah
09:27:24 <mrd> nice
09:27:40 * earthy hasn't yet used it enough to grok it
09:27:45 <earthy> but it's functional at least. ;)
09:28:05 <mrd> vba?
09:28:11 <earthy> vimball
09:28:12 <mrd> lol nice name collision
09:28:14 <mrd> yea
09:28:17 * earthy nods
09:29:07 <shapr> wli: I don't think Hope has LaTeX support.
09:30:12 <wli> shapr: Ouch.
09:31:26 <Philippa> shapr: how hard would it be to add it in approximately the same way WordPress works?
09:31:49 <Philippa> can it at least generate and save extra data when a page is edited?
09:32:54 <sorear> dcoutts: Re gtk2hs patches; why don't you just use the .NOTPARALLEL directive?  Shorter and machine readable.
09:33:15 <dcoutts> sorear: oh!
09:33:23 <dcoutts> sorear: I didn't know that existed
09:33:30 * dcoutts goes are reads up
09:33:34 <dcoutts> are/and
09:34:34 <mrd> yea it works, though the install borked up and put files with garbage trailing after the names
09:37:22 <shapr> Philippa: Yeah, should work fine.
09:37:30 <wli> shapr: Hmm, it looks like if you can inject things with unit :: t -> m t, you can get away with just a composition operator, mcompose :: (m t -> m t') -> (m t' -> m t'') -> (m t -> m t''), though I'm not entirely sure.
09:38:48 <wli> shapr: Never mind.
09:39:31 <shapr> wli: I think that's right.
09:41:22 <wli> shapr: You need something to extract the values and pass them to a function not defined on the monadically transformed type, so bind is there to do that in curried form.
09:41:42 <sjanssen> wli: I'm not sure that mcompose is sufficient
09:41:48 <wli> sjanssen: It's not.
09:41:49 * glguy wonders what the initial question was
09:41:49 <lambdabot> glguy: You have 1 new message. '/msg lambdabot @messages' to read it.
09:41:54 * shapr boings cheerfully
09:42:34 <wli> Closer might be mpass :: (t -> m t') -> m t -> m t'
09:42:48 * sjanssen whispers 'fmap' :)
09:43:03 <sjanssen> wli: that isn't quite powerful enough either
09:43:04 <wli> sjanssen: (>>=)
09:43:15 <sjanssen> oh, I misread the signature
09:43:19 <sjanssen> yeah, that is >>=
09:43:39 <wli> Or (=<<)
09:44:05 <mdmkolbe|work> @type ap
09:44:07 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
09:44:48 <glguy> what was the initial question about monads?
09:44:52 <glguy> I want to play too :(
09:45:06 <chessguy> too slow, glguy, you lose
09:45:11 <wli> glguy: There wasn't really one. I was just reading some monad tutorial in lieu of installing blogging stuff.
09:45:23 * glguy found the log
09:45:27 <shapr> I think the initial question was "I have decided to learn monads. Now..."
09:45:29 <glguy> I'll not be defeated!
09:45:44 <shapr> yarr, I wish cabal-install were on kakapo
09:45:49 * chessguy instructs shapr on the semantics of punctuation
09:46:03 <wli> shapr: Well, there wasn't really even that. It was a digression from the hunt for blogging software with LaTeX plugins.
09:46:37 <Syzygy-> I'm pretty pleased with wordpress + the LaTeX plugin that's been around a while.
09:46:42 <yaarg> yup, ditto
09:46:55 <wli> Syzygy-: I'm having trouble setting up wordpress.
09:47:09 <shapr> How does it work? Does it snip out <latex/> and produce images that get inlined?
09:47:27 <Syzygy-> shapr: Yeah. wli: What kind of problem?
09:47:46 <wli> Syzygy-: It seems to want to take over a whole hostname and I just want it under ~wli/blog/ or similar.
09:47:58 <yaarg> there's also mimetex.cgi
09:48:06 <Syzygy-> wli: No it doesn't.
09:48:18 <Syzygy-> You just give the hostname+path you want it to inhabit, and it'll work in there.
09:48:32 <wli> Syzygy-: Well, then my impression is false and I don't know/understand how to configure it.
09:48:34 * Syzygy- used to have a good installation at my.host.name/phd/
09:48:51 <Syzygy-> wli: Yah. I'm in a bit of a hurry today, but I'd be happy to help you get it up and running.
09:48:54 <Syzygy-> Just poke me.
09:49:15 <wli> Syzygy-: The entire problem thus far is that I can't get it up or running.
09:49:32 <Syzygy-> And exactly that is what I'm volunteering to help with. :P
09:50:06 <wli> Okay, well, I've got the sample config with hostname holomorphy.com somewhere.
09:50:11 <wli> VirtualDocumentRoot /srv/www/%0
09:50:13 <shapr> I want a cabal-install deb.
09:50:19 <Syzygy-> wli: Not now though.
09:50:20 <wli> Syzygy-: That looks relevant.
09:50:32 <wli> Syzygy-: Okay. It's best for me to wait anyway.
09:50:59 <matthew-_> there's no "sane" way of making fromIntegral treat a Word8/16/32 as signed is there?
09:52:12 <SamB> matthew-_: convert to Int8/16/32 first
09:52:32 <matthew-_> @hoogle Int16
09:52:32 <shapr> I want cabal-install to come with all current ghc versions, and I want it to handle --user out of the box!
09:52:33 <lambdabot> Data.Int.Int16 :: data Int16
09:52:36 <matthew-_> ta
09:53:42 <SamB> also remember you can use an abbreviated name for fromIntegral locally
09:54:00 <wli> Monadic retrofitting of non-monadic code seems to be a good demonstration technique.
09:54:44 * wli wonders if unfoldr -based code can be dealt with in such a fashion.
09:54:45 <glguy> If you want to make code monadic without changing its functionality, the Identity monad is great :)
09:55:07 <wli> glguy: Possible but not enlightening.
09:55:09 <matthew-_> ok, so I'm reading from a file, the file contains endless ints, where each int is 2 bytes and signed. So I'm using ByteStream, which will get me word8s. Suggestions as to how to get from here to an Int?
09:55:27 <SamB> glguy: not if you are trying to accomplish something
09:55:28 <ricky_clarkson> Would you write monadically in a dynamically typed language?
09:55:42 <matthew-_> first word8 -> int8 then lshift 8 xor (second word8 -> int) ?
09:55:46 <glguy> SamB: I don't understand why not... once it works in identity , yo ucan start piling on the transformers
09:55:51 <SamB> ricky_clarkson: probably not
09:56:11 <wli> glguy: For instance, using unfoldr to generate a list of digits.
09:56:37 <SamB> it would have to be a really clever hack that would make it concise enough to be pallatable
09:56:58 <quicksilver> > (fromIntegral (255 :: Word8)) ::Int8
09:57:00 <lambdabot>  -1
09:57:07 <glguy> There isn't an unfoldrM
09:57:15 <glguy> but you could write one easy enough
09:57:15 <SamB> glguy: notice the word "retrofitting"?
09:57:30 <quicksilver> matthew-_: looks like that works, I don't know if it's guaranteed
09:57:32 <SamB> that implies that maybe you want to move some things into the monad immediately...
09:57:41 <glguy> which monad?
09:57:44 <quicksilver> matthew-_: I think the overflow behaviour of fromIntegral is undefined
09:57:49 <glguy> a specific one?
09:57:51 <quicksilver> matthew-_: although it normally seems to do what I expect
09:58:00 <SamB> glguy: whatever monad it looks like the code wants to be *in*
09:58:19 <wli> take 10 . reverse $ unfoldr (\n -> case n `divMod` 10 of { (0,0) -> Nothing ; (q,r) -> Just (r, q) }) (product [2..100])
09:58:27 <glguy> SamB: my point was that you convert it to Identity first... and then you can tell if the functionality was broken by your refactoring
09:59:49 * SamB wonders why JHC's colorized pretty-printing is being wrapped in mid-escape-sequence and mid-word
10:02:42 <glguy> ?type let unfoldrM f x = fmap (maybe [] (\x' -> fmap (x':) (unfoldrM f x'))) (f x) in unfoldrM
10:02:44 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
10:02:44 <lambdabot>       Expected type: [[a]]
10:02:50 <wli> glguy: Something like let { stop = fail "" ; f = \n -> case n `divMod` 10 of { (0,0) -> stop ; (q,r) -> return (r,q)  } } in take 10 . reverse $ unfoldr f (product [2..100])
10:02:59 <glguy> ?type let unfoldrM f x = fmap (maybe (return []) (\x' -> fmap (x':) (unfoldrM f x'))) (f x) in unfoldrM
10:03:02 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
10:03:02 <lambdabot>       Expected type: [[a]]
10:03:39 <glguy> oh, i see what I did... looks like maybe isn't the right funcvtion
10:03:43 <byorgey> @src unfoldr
10:03:43 <lambdabot> unfoldr f b  = case f b of
10:03:44 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
10:03:44 <lambdabot>    Nothing        -> []
10:05:43 <byorgey> glguy: what *should* be the type of unfoldrM?
10:05:54 <opqdonut> :t unfoldr
10:05:56 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
10:06:24 <ski_> @type let unfoldrM step seed = step seed >>= maybe (return []) $ \(a,seed') -> (a:) `liftM` unfoldrM step seed' in unfoldrM
10:06:26 <lambdabot>     The lambda expression `\ (a, seed') -> ...' has one argument,
10:06:26 <lambdabot>     but its type `Maybe a' has none
10:06:44 <byorgey> something like (Monad m) => (b -> Maybe (m a, b)) -> b -> m [a]?
10:06:49 <ski_> @type let unfoldrM step seed = step seed >>= maybe (return []) (\(a,seed') -> (a:) `liftM` unfoldrM step seed') in unfoldrM
10:06:51 <lambdabot> forall t (m :: * -> *) a. (Monad m) => (t -> m (Maybe (a, t))) -> t -> m [a]
10:07:07 <wli> glguy: Looks like MonadExit is probably the way to go here.
10:07:36 <oerjan> @src MonadExit
10:07:36 <lambdabot> Source not found. I've seen penguins that can type better than that.
10:07:43 <oerjan> (not that i had much hope)
10:07:44 <glguy> unfoldrM :: (Monad t) => (a -> t (Maybe a)) -> a -> t [a]
10:08:22 <ski_> (the problem above was 'fmap', not 'maybe')
10:08:56 <glguy> actually,
10:09:36 <glguy> ?type let unfoldrM f x = f x >>= maybe (return []) (\x -> fmap (x:) (unfoldrM f x)) in unfoldrM
10:09:38 <lambdabot> forall a (f :: * -> *). (Functor f, Monad f) => (a -> f (Maybe a)) -> a -> f [a]
10:09:41 <glguy> :)
10:10:00 <ski_> every monad is a functor
10:10:03 <glguy> ?type let unfoldrM f x = f x >>= maybe (return []) (\x -> liftM (x:) (unfoldrM f x)) in unfoldrM -- to remove a constraint
10:10:07 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m (Maybe a)) -> a -> m [a]
10:10:37 <glguy> ski_: that doesn't mean that the instance is defined though :)
10:10:45 <ski_> sadly, no
10:10:53 <glguy> used to be the case that it was
10:11:07 <ski_> ('Functor' ought to be a superclass of 'Monad')
10:11:48 <olsner_> isn't it possible to write something equivalent to instance (Functor a) (Monad a) where ...?
10:12:00 <byorgey> glguy: that doesn't quite correspond to unfoldr (unfoldr's first argument has to return Maybe (a,b) instead of just Maybe b)
10:12:10 <glguy> oh, duh
10:12:17 <byorgey> glguy: but I don't know what the original question was
10:12:27 <ski_> olsner_ : with -fallow-overlapping-instances, yes
10:12:51 <oerjan> glguy: i think ski_ nailed it further above
10:13:06 <glguy> oerjan: no, he put the monad inside themaybe
10:13:09 <glguy> instead of around it
10:13:17 <Saizan> i think you also need -fallow-undecidable-instances
10:13:19 <glguy> unfoldrM :: (Monad t) => (t1 -> t (Maybe (a, t1))) -> t1 -> t [a]
10:13:37 <ski_> Saizan : yes .. i was wondering if it was enough
10:13:53 <oerjan> glguy: no he didn't, not in what i was looking at
10:14:03 <glguy> oh, oh well
10:14:17 * ski_ raises eyebrow
10:14:44 <glguy> ?type let unfoldrM f x = f x >>= maybe (return []) (\(x,b) -> liftM (x:) (unfoldrM f b)) in unfoldrM
10:14:46 <lambdabot> forall t (m :: * -> *) a. (Monad m) => (t -> m (Maybe (a, t))) -> t -> m [a]
10:14:48 <olsner_> ski_: why is such an instance overlapping and undecidable?
10:15:11 <glguy> because it overlaps with existing instances of Monad
10:15:16 <Saizan> "a" overlaps with everything
10:15:22 <glguy> it creates a new instance of Monad for Maybe
10:15:24 <glguy> for example
10:17:05 <olsner_> like, it overlaps with other types that are Monads and already have Functor instances?
10:17:07 * wli reads http://okmij.org/ftp/papers/LogicT.pdf instead
10:17:10 <ski_> yes
10:17:37 <ski_> and undecidable because it (potentially) doesn't terminate
10:18:21 <ski_> (because the predicate arguments doesn't decrease in the body)
10:18:48 <ski_> wli : ty for the link
10:19:36 <Saizan> it's considered to overlap even with types that don't have a Monad instance
10:19:45 <wli> Well, I didn't really have a direct motive for giving the link; I was just looking at a nontrivial monad.
10:20:28 <ski_> still, i've been meaning to look at that
10:20:31 <olsner_> Saizan: how's that?
10:21:26 <Saizan> olsner_: when deciding if an instance is safe ghc doens't pay attention to the context wrt overlapping
10:25:05 <wli> How was this paper written? It looks fantastic.
10:26:36 <shapr> @quote oleg
10:26:36 <lambdabot> vincenz says: import Oleg
10:26:37 <shapr> @quote oleg
10:26:38 <lambdabot> Korollary says: an olegweek is a complex entity with an imaginary part
10:26:39 <shapr> @quote oleg
10:26:39 <lambdabot> Pseudonym says: What was considered 100 milli-Olegs of type hackery five years ago is standard operating procedure these days
10:26:41 <shapr> @quote oleg
10:26:41 <lambdabot> emu says: olegarithmic
10:26:50 <shapr> @quote oleg
10:26:50 <lambdabot> OlegFacts says: Oleg has a higher rank than you.
10:26:57 <LoganCapaldo> mmmm import Oleg
10:27:06 <LoganCapaldo> I don't see it on hackage
10:27:21 <olsner_> wli: do you mean the typesetting/layout, or the contents?
10:27:51 <wli> olsner: The typesetting.
10:28:53 <wli> LogicT looks particularly useful for me. I wonder if it'll enter into the standard monad transformer library.
10:30:55 <olsner_> wli: probably made in LaTeX
10:31:18 <sorear> re.
10:41:46 <wli> I wonder if unboxed arrays for Complex Double are floating around.
10:42:26 <wli> Apparently not.
10:46:52 <wli> Data.Array.ST should be enough for linear algebra.
10:48:47 <wli> The real question is whether I can hammer out sequential quadratic programming at all.
10:52:10 <SamB> sorear: do you have any idea where the code is that is responsible for inserting newlines inappropriately in JHC's colorful E?
11:00:22 <sioraiocht> what's the function for taking the logarithm with an arbitrary base/
11:00:31 <glguy> logBase
11:00:34 <sioraiocht> thanks
11:00:35 <glguy> ?hoogle logBase
11:00:37 <lambdabot> Prelude.logBase :: Floating a => a -> a -> a
11:01:14 <Cale> sioraiocht: You could also just divide by the logarithm of the base you wanted.
11:01:29 <sioraiocht> Cale: it's that kind of attitude that starts making people think logically
11:01:34 <glguy> logBase ?src logBase
11:01:37 <glguy> ?src logBase
11:01:37 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
11:01:48 <sioraiocht> logBase worked fine btw, lol
11:01:49 * glguy figures that that is how it is implemented
11:02:03 <glguy> logBase x b = log x / log b
11:02:12 <Cale> b x
11:02:14 <glguy> i dont know what order the parameters are in
11:02:24 <glguy> (I checked the docs, didn't say)
11:02:29 <sioraiocht> base goes first
11:02:34 <Cale> > logBase 2 8
11:02:36 <lambdabot>  3.0
11:02:53 * SamB feels silly -- thinks it was more's fault...
11:02:57 <sioraiocht> this wa sjust a queestion so I could use ghci as my desktop calculator =p
11:02:57 <Cale> There's no real reason to support anything but the natural log, apart from efficiency.
11:02:59 <mehrheit> :t logBase
11:03:00 <lambdabot> forall a. (Floating a) => a -> a -> a
11:03:22 <SamB> Cale: what if logBase is more accurate than log/log?
11:03:27 <Cale> In fact, if I designed a pocket calculator, it would only have the natural log. None of this log base 10 crap.
11:03:45 <SamB> eh.
11:03:53 <SamB> hmm.
11:04:09 * glguy would provide a log function and not admit what base it was
11:04:11 <Cale> And it would be labelled log!
11:04:12 <Cale> hehe
11:04:18 <SamB> heh
11:04:26 <glguy> and it would change for each line you used it
11:04:33 <glguy> mwahahaha
11:04:38 <SamB> that would be impure
11:04:58 <glguy> SamB: the calculator would print: log1
11:04:59 <glguy> log2
11:05:01 <glguy> log
11:05:02 <glguy> 3
11:05:09 <glguy> so that it would be pure
11:05:10 <glguy> but
11:05:11 <SamB> it should arbitrarily change when you swich between degrees and radians ;-P
11:05:14 <glguy>  never the  same function
11:05:27 <glguy> (on different lines ;)
11:05:50 <glguy> the function would be pure, the key on the calculator impure :)
11:06:23 <glguy> maybe that's why I didn't get that job at TI
11:07:25 <SamB> only if they somehow knew you would do that kind of thing
11:08:25 <sorear> SamB: Yes.
11:08:34 <sorear> SamB: I'm guessing it's in Doc/PPrint.hs
11:08:45 <sorear> SamB: that's where the autonl code its
11:09:39 <SamB> sorear: not $(which more) ?
11:10:12 <sorear> SamB: Oh, sorry, I didn't read far enough.
11:10:25 <sorear> SamB: You could switch to less and pass the -r option
11:10:38 <sorear> SamB: Less has proper support for ansi color sequences
11:10:40 <SamB> sorear: actually the -R option is better
11:10:45 <SamB> I think
11:10:50 <sorear> SamB: (not sure about unicodde though)
11:11:14 <SamB> it actually works fine now, yes...
11:14:59 <kjdf> is there a built-in function for downcasing a string
11:15:10 <kjdf> ?
11:15:10 <shachaf> > map toLower "STRING"
11:15:12 <lambdabot>  "string"
11:15:22 <kjdf> thanks
11:15:25 <mehrheit> ?index toLower
11:15:25 <lambdabot> Data.Char
11:16:04 <mehrheit> ?src (.)
11:16:05 <lambdabot> (.) f g x = f (g x)
11:16:19 <mehrheit> ?src ($)
11:16:19 <lambdabot> f $ x = f x
11:16:33 <glguy> downcase x = putStrLn ("What is the lowercase version of: " ++ x) >> getLine
11:17:30 <shapr> hiya vydd
11:17:43 <vydd> hi :)
11:17:46 <shapr> How's code?
11:18:14 <Syzygy-> glguy: The least wanted implmeentation of map toLower, is it?
11:18:41 <glguy> Syzygy-: I give you gold! and get nothing but trouble :)
11:18:51 <shachaf> Don't forget to unsafePerformIO.
11:19:24 <mm_freak> "(f $! x) $! y" looks pretty uglyâ¦  any nicer way to write this?
11:19:25 <Syzygy-> glguy: Hehe
11:19:45 <Syzygy-> ?src ($!)
11:19:46 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
11:19:57 <mm_freak> @src ($!)
11:19:57 <lambdabot> Source not found. I've seen penguins that can type better than that.
11:20:26 <mm_freak> well, from the associativity it's the same as $
11:20:59 <vydd> shapr: like life..uncommented and hard to understand :P
11:20:59 <shachaf> Is f $! x = x `seq` f x
11:21:14 <mm_freak> AFAIK yes
11:21:20 <mm_freak> at least that would make sense =)
11:21:48 <Saizan> > let (-$!) = ($); infixl 0 -$! in (+) -$! 2 -$! 3
11:21:51 <lambdabot>  5
11:22:02 <Saizan> use a shorter symbol :)
11:23:33 <mm_freak> what is a unary operator defined to be?  prefix or infix?
11:23:46 <mm_freak> or is that up to you?
11:23:48 <nopcode> uh
11:23:52 <wli> It has to be either prefix or postfix. It's unary.
11:23:56 <nopcode> i'm now computer linguist...
11:23:59 <nopcode> no
11:24:05 <nopcode> but unary infix? ;)
11:24:08 <wli> Haskell doesn't support postfix AIUI.
11:24:24 <mm_freak> well, i don't know, maybe that would make sense somehow =)
11:24:41 <glguy> > let (x !) = 3 in (x !)
11:24:41 <lambdabot>  Parse error in pattern
11:24:50 <glguy> > let (!) x = 3 in (x !)
11:24:52 <lambdabot>   Not in scope: `x'
11:24:55 <glguy> oops
11:24:59 <glguy> > let (!) x = 3 in (1 !)
11:25:00 <ari> wli: ghc does
11:25:02 <lambdabot>  3
11:25:10 <ari> http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#postfix-operators
11:25:12 <lambdabot> Title: 7.3. Syntactic extensions, http://tinyurl.com/y6v6by
11:25:17 <wli> ari: I'm surprised. It's sort of obscure.
11:27:08 <mm_freak> looks like GHC is becoming the GCC of haskell =)
11:27:52 <glguy> the place where new features are explored?
11:28:42 <glguy> The point of the language Haskell was to provide a common language for functional programming language researchers to research new features
11:29:08 <Syzygy-> > let (1) x y z = x+y*z in 1 ! 2 3
11:29:08 <lambdabot>  Parse error in pattern
11:29:08 <glguy> not that postfix operators took a lot of research ... :)
11:29:13 <Syzygy-> o.O
11:29:19 <glguy> Syzygy-: (1)?
11:29:20 <Syzygy-> Ooops.
11:29:26 <Syzygy-> > let (!) x y z = x+y*z in 1 ! 2 3
11:29:27 <lambdabot>   add an instance declaration for (Num (t1 -> t))
11:29:28 <glguy> and you'll need (1 ! 2) 3
11:29:29 <glguy> :)
11:29:36 <Syzygy-> Why is that?
11:29:43 <glguy> 2 3 isn't valid
11:29:44 <Syzygy-> > let (!) x y z = x+y*z in (1 ! 2) 3
11:29:46 <lambdabot>  7
11:30:11 <glguy> 1 ! 2 3 is 1 ! (2 3)
11:30:12 <glguy> :)
11:30:35 <Syzygy-> Oh, right.....
11:30:39 <wolverian> oh, that hurts your head if you don't understand currying
11:30:49 <glguy> how does that relate to currying?
11:31:21 <wolverian> it's not !(1 2 3) but (!(1 2) 3)
11:31:54 <glguy> you mean if you don't understand the precedence of function application?
11:32:17 <wolverian> I suppose I mean partial application.
11:32:23 <wolverian> does that make more sense?
11:32:44 <glguy> a little
11:33:05 <ari> > let (!) n = product [1..n] in (5 !)
11:33:07 <lambdabot>  120
11:34:34 <glguy> currying is specifically the transformation of a function that takes a tuple
11:35:16 <wolverian> yeah. sorry, I get the terms mixed often for some reason.
11:35:26 <glguy> probably because people use them incorrectly all the time
11:35:38 <glguy> including the wikipedia
11:35:38 <wolverian> good, then it's not just me..
11:35:42 <cedricshock> Two quick questions: Existing library and interface for search / optimization procedures (specifically depth-limited depth first search)? Functional two dimensional array (any implementation; I actually need the abstraction of a 2d array)?
11:36:12 <ndm> @seen sorear
11:36:12 <lambdabot> sorear is in #haskell-icfp07, #ghc, #xmonad, #haskell-overflow, #haskell-blah and #haskell. I last heard sorear speak 25m 22s ago.
11:36:29 * sorear waves
11:36:43 * ndm waves back
11:36:48 <ndm> re the make stuff
11:36:57 <ndm> is Qhc going to load all .hi files  just once?
11:37:06 <dcoutts> Qhc?
11:37:21 <sorear> Deep vaporware haskell compiler project
11:37:31 <glguy> cedricshock: those are more like nouns with question marks
11:37:41 <ndm> dcoutts, fancy a make library for cabal?
11:37:47 <sorear> ndm: Maybe; I thought it would be simpler to load them once per use.
11:38:05 <cedricshock> glguy: Yeah. The question is, "Where do I find the nouns"?
11:38:11 <ndm> sorear: agreed, possibly faster as well, since no large memory leak
11:38:27 <ndm> sorear: plus, Binary obj, does that account for .yca, .ycr, .hbc files etc?
11:38:28 <glguy> cedricshock: Data.Array
11:38:40 <dcoutts> ndm: what would it do?
11:38:41 <glguy> cedricshock: and, it is easy to write your own
11:38:56 <ndm> dcoutts, dependency analysis, deciding which files to rebuild
11:39:07 <dcoutts> ndm: yes, we need dependency analysis
11:39:19 <sorear> ndm: Yeah; the question of multiple object files was always a bit annoying.  should we save everything? etc.
11:39:32 <dcoutts> ndm: extensible dep analysis, so people can add new build tools modularly
11:39:45 <ndm> dcoutts, i've checked it into Yhc (src/libraries/make), and once i've got it in use in Yhc, i'll let you know
11:39:46 <cedricshock> glguy; Yeah. I just remembered Data.Array. It's been a little while... And it is easy to write my own. I'm more interested in the definition of the interfaces for searchable optimization problems than the code.
11:39:57 <dcoutts> ndm: cool
11:40:04 <sorear> ndm: Maybe just saving everything (always generate .ycr, .hbc, and .qhi) *is* the right KISS thing to do.
11:40:05 <ndm> dcoutts, slightly lower level than Make, designed for a tool to use, not a human - should mesh well with Cabal, i think
11:40:14 <dcoutts> sorear: is this vaporware project then?
11:40:22 <dcoutts> ndm: sounds good
11:40:34 <cedricshock> glguy; I just wrote this whole thing in python, goofed up a bit, and figured it'd be easier to redo the way I want in Haskell...
11:40:37 <sorear> dcoutts: Make is real.  Qhc is a possible (but completely uncoded) user.
11:40:38 <ndm> sorear: i think it probably is, although my Make system handles it - you specify rules and it will pick the best set of rules to generate the most in the fewest passes
11:40:53 <ndm> dcoutts, its real, but i've yet to test it at all
11:40:54 <dcoutts> sorear: sorry, erm I mean is it *your* project?
11:41:07 <sorear> dcoutts: Make is ndm's, Qhc is mine.
11:41:22 <dcoutts> sorear: tell me more about what your goals are for qhc
11:41:27 <sfultong> I feel dirty when I use Arrays... am I being silly?
11:41:29 <ndm> sorear: make sure it starts in the open and stays that way
11:41:40 <ndm> sfultong: no, you are dirty, use a list - it will be more functional :)
11:41:46 <dcoutts> sfultong: no, especially if you're only using pure arrays, ie not mutable ones.
11:42:00 <dcoutts> sfultong: erm I mean you're not being silly.
11:42:10 <dieJana> can anyone recommend me some nice and clear documentation on Dependent Types?
11:42:18 <sorear> ndm: My concern is how do I say "I want all .hbc files."  if I just specify ["Main.hbc"] Make would feel justified in deleting the others :)
11:42:21 <cedricshock> sfultong: Depends on what you are using them for. If you have data that is actually points on a 2d lattice they are a fantastic abstraction.
11:42:32 <dcoutts> sfultong: pure immutable arrays are nice and functional, mutable arrays in the ST monad are not too mad either
11:42:35 <ndm> sorear: add them all as targets, thats what Yhc does
11:42:39 <dcoutts> mad/bad :-)
11:42:49 <sorear> ndm: But you don't know them in advance!
11:43:09 <ndm> sorear: you do, it does analysis of what imports what beforehand
11:43:20 <sorear> ndm: what do you mean { 11:40 < ndm> sorear: make sure it starts in the open and stays that way } ?
11:43:30 <ndm> sorear: a public darcs repo
11:43:31 <sorear> dcoutts: Very small and hackable.
11:43:38 <sfultong> well, I've been so obsessed with my own sense of purity, that instead of Arrays I've been using FiniteMaps for 2d cartesian coordinate systems
11:43:50 <sorear> dcoutts: 300kloc compilers aren't conducive to non-simonic research
11:44:00 <ndm> sorear: from my point of view, you are writing what we want Yhc to be, without all the nhc hangover
11:44:06 <dcoutts> sorear: how would it compare to yhc or jhc ?
11:44:30 <ndm> dcoutts, ambiguous question, since i'm currently writing Yhc's super optimiser :)
11:44:30 <sorear> dcoutts: 1. it would use records 2. it wouldn't take hours to compile hello world
11:44:36 <wli> nhc hangover?
11:44:54 <dcoutts> wli: yhc is derived from nhc
11:44:58 <sorear> it won't have any serious optimizer.
11:45:08 <ndm> sorear: if you use Yhc.Core, it will
11:45:17 <Botje> In SPJ's paper on extended list comprehensions, he says sortBy has type (a -> a -> Bool) -> [a] -> [a]
11:45:23 <Botje> shouldn't that be a -> a -> Ordering?
11:45:32 <ndm> Botje: almost certainly
11:45:39 <dcoutts> sorear: so you're going to focus more on the front end then? unlike yhc which has just kept nhc's front end
11:45:48 <SamB> man, this is peculiar... JHC seems to be forgetting about foreign exports *before* E.FromHs ???
11:46:13 <sorear> dcoutts: yeah
11:46:49 <ndm> sorear: if you succeed, you'll kill Yhc stone dead, and all the developers would come flocking to you instead
11:46:55 <dcoutts> sorear: sounds great
11:47:13 <dcoutts> aye, sounds like it could complement yhc
11:47:25 <dcoutts> since most yhc work has been on core and backend, not frontend
11:47:44 <ndm> we've hit the front end as well, but more flags and make side
11:47:52 <ndm> its the Haskell -> Core side we've not touched
11:47:54 <mightybyte> sought
11:47:55 <mightybyte> wa
11:48:04 <dcoutts> ndm: right
11:48:06 <mightybyte> sorry, wrong window
11:48:10 <sorear> ndm: I seem to have found an interesting generalization of uniplate; should I tell you now or wait until your thesis is filed?
11:48:34 <ndm> sorear: tell me now
11:48:51 <ndm> sorear: i've got an interesting generalisation sat on my desk, as it happens :)
11:49:08 <hpaste>  sorear pasted "HPASTE RETUNS!" at http://hpaste.org/1543
11:49:14 <Botje> hurrah!
11:49:25 <ndm> does it involve not using lists in the uniplate type?
11:49:41 <sorear> no.
11:50:09 <ndm> i have that one on the todo list, but anything else you have thought of is most appreciated
11:50:28 <sorear> what's wrong with lists?
11:50:42 <sorear> To: nmd@localhost.localdomain
11:50:58 <sorear> mutt continues to amuse me :)
11:51:03 <ndm> consider data T = C [T] T
11:51:08 <ndm> where the first list is infinite
11:51:27 <ndm> uniplate isn't an inverse anymore
11:51:50 <glguy> sorear: I can't seem to get that link to open
11:52:04 <ndm> me neither
11:52:14 <glguy> !paste
11:52:14 <hpaste> Haskell paste bin: http://hpaste.org/
11:52:20 * wli wonders if there's anything happening in the way of analyzing imperative programs in terms of monads.
11:52:54 <sorear> glguy: The recent list is broken for no comprehensible reason, you can still read and paste though.
11:53:02 * ari ponders fixpoint fusion
11:53:03 <sorear> ndm: ah.
11:53:07 <EvilTerran> hpaste.org seems to be getting as far as (at least part of) the <head>, but then getting stuck, for me
11:53:39 <ndm> sorear: but other generalisations are of interest - i have a solution to the infiniteness problem, plus i think it might make all of Uniplate a little faster (maybe 20%)
11:53:47 <_frederik_> what is the printf format for a 64-bit integer? it seems that on a 32-bit arch it is %lld, and on a 64-bit arch it is %ld, and there is no format which indicates the same width on both...
11:53:59 <ari> hpaste.org is working perfectly well for me (it's loaded all the way to the </html>), except Firefox is being evil and refusing to render it anyway
11:54:10 <glguy> ari: ditto from safari
11:54:19 <sorear> ah!
11:54:24 <sorear> that makes sense
11:54:27 <olsner> wli: the LibraryCallOrVolatileReadOrWrite monad?
11:54:58 <sorear> probablly hpaste is sending a long content-length, and browsers are buffering eagerly?
11:55:28 <EvilTerran> strange... "view source" shows what appears to be a complete page, but the DOM inspector seems to think the </body> hasn't arrived yet
11:56:16 <_frederik_> oh nevermind
11:56:45 <EvilTerran> _frederik_, i don't think there is such a thing
11:57:10 <_frederik_> long long int compiles to 8 bytes for me on x86_64
11:57:17 <_frederik_> i don't know where i got the idea that it was 16
11:57:32 <EvilTerran> if you're working in C, you can do a workaround with sizeof(long long)
11:57:34 <wli> olsnet: I was thinking more of things like mutable array code written in Haskell.
11:58:14 <_frederik_> that works too
11:59:41 <eivuokko> How can I find who put package up in Hackage?
11:59:50 <EvilTerran> #if sizeof(long) == 64 #define int64printf "l" #else #define int64printf "ll" #end
12:00:05 <sorear> eivuokko: the Recentchanges list says
12:00:16 <shapr> Has anyone built fixtures for unit tests with HUnit?
12:00:17 <EvilTerran> then printf("foo = %" int64printf "d\n", foo);
12:00:34 <eivuokko> sorear, Too old -.-  I am just wondering who put Win32 in.
12:01:04 <sorear> eivuokko: rc has an older link :)  anyway this seems like an odd query
12:01:33 <eivuokko> Huh
12:01:46 <eivuokko> (Reason: I am maintainer of Win32, I didn't upload it)
12:01:56 <eivuokko> I am blind prolly, can't see the link.
12:05:08 <Socrates> Is there anything in GHC to tokenize strings?
12:05:51 <shapr> parsec
12:05:56 <wli> olsner: ISTR there was some other lazy language out there that used a completely different principle from monads to handle its IO issues that used to get all sorts of destructive update speed boosts.
12:06:17 <olsner> ISTR?
12:06:23 <nominolo> or alex
12:06:26 <wli> olsner: I seem to remember.
12:06:29 <ari> wli: Clean?
12:06:30 <shapr> wli: Clean uses uniqueness types.
12:06:31 <jmelesky> wli: Clean?
12:06:40 <wli> That must be it.
12:06:40 <jmelesky> heh. three voices means it must be true
12:07:48 <Socrates> shapr: Is that in a package?
12:07:58 <shapr> @index anyChar
12:07:58 <lambdabot> Text.ParserCombinators.Parsec.Char, Text.ParserCombinators.Parsec
12:08:01 <wli> olsner: I've not checked in for some time. Since matrices are on the brain I had to wonder if the monad optimization issues ever had any progress made on them.
12:08:17 <Socrates> Thanks
12:08:41 <shapr> wli: Heard of nanevski's something calculus that splits monads into possibility and necessity? That will likely give 'commutative' monads once someone integrates the ideas into Haskell.
12:08:46 <wli> olsner: Plus I think there's a slowdown in monad-heavy code vs. non-monadic equivalents.
12:09:01 <wli> shapr: No, I've never heard of it.
12:09:25 <wli> shapr: NFI why commutative monads would help.
12:09:33 <sjanssen> @karma sorear
12:09:33 <lambdabot> sorear has a karma of 45
12:09:45 <shapr> Right now monads are overly strict.
12:09:59 <shapr> At least, more strict than they really need to be.
12:10:05 <olsner> it seems to me monadic code introduces unnecessary sequencing, but I'm not sure I know in what degree that translates into performance problems
12:10:21 <SamB> shapr: often we do that on purpose...
12:12:31 <wli> Well, I don't really have an issue personally. It just occurred to me since a number of different things flying across the channel touched on the periphery of it.
12:12:53 * _frederik_ celebrates his newly multi-architecture-compatible library
12:14:32 <wli> I'm not even personally aware of what the magnitude of the slowdown might be. I don't really get too worked up about performance until something has to run overnight or longer.
12:15:03 * _frederik_ is totally not concerned about performance. he links to C for that
12:16:02 <mgsloan> dons - is there a way to get an exemplar of a data type while in a Data.Binary get?
12:16:17 <wli> My philosophy is that so long as the asymptotics are good to Hell with bit twiddling.
12:16:33 <sjanssen> mgsloan: exemplar?
12:16:46 <mgsloan> yeah, any member of the data type
12:16:47 <sjanssen> mgsloan: dons probably won't be around for several hours
12:16:49 <mgsloan> ok
12:16:51 <sjanssen> @localtime dons
12:16:52 <lambdabot> Local time for dons is Fri Jul  6 05:15:41 2007
12:17:14 <sjanssen> mgsloan: you need a non-bottom?
12:17:43 <matthew-_> I would like to convert a list of Int32 values to a list of Word8 such that each Int32 gives 4 Word8s in little endian order. Any clues?
12:17:45 <mgsloan> hmm, I'm not sure
12:18:04 <mgsloan> I guess undefined :: T might do it
12:18:12 <sjanssen> mgsloan: if bottom will do, just use scoped type variables + undefined
12:18:15 <SamB> matthew-_: guess!
12:18:30 <SamB> mapConcat is helpfull...
12:18:31 <mm_freak> if endianness matters, you have to convert yourself
12:18:37 <mm_freak> import Data.Bits
12:18:40 <sjanssen> matthew-_: see Data.Bits
12:18:47 <SamB> er.
12:18:49 <SamB> sorry.
12:18:51 <SamB> concatMap
12:19:50 <matthew-_> thanks.
12:21:26 <olsner> hmmm.. what if every function was/could be put in every monad - non-monadic parts of the calculation would have an undefined evaluation order but all the monadic parts (per monad) would have a total ordering - enabling one to make use of both worlds.. not entirely thought everything out yet though ;-)
12:22:05 <hpaste>  Nestor_the_Inve pasted "Nestor_the_Investor" at http://hpaste.org/1544
12:22:33 <sorear> I guess I should have checked for equality *before* truncating the nick.
12:22:33 <olsner> (here using "monad" as "category of side effect" .. I'm thinking that functions would have type notations as to the categories of side effects they may have)
12:23:34 <wli> olsner: Heavy interprocedural analysis required. The same likely needs to go for statements in general, too.
12:23:59 * EvilTerran would do matthew's problem in perl as unpack("C*", pack("l*", @bytes)). is there something pack-esque in haskell?
12:24:42 <sorear> I'd use Data.Binary.  it would be about 5x longer though
12:25:14 <matthew-_> mmm. I have looked at Data.Binary but was annoyed by the fact that it said it's always bigendian
12:25:27 <mgsloan> that's odd
12:25:30 <sorear> import Data.Binary.Put; import qualified Data.ByteString as B; B.unpack . runPut . mapM_ put
12:25:36 <_frederik_> olsner: i started a discussion about that on haskell.org a long time ago
12:25:43 <sorear> matthew-_: it's *not* all big endian
12:25:50 <sorear> import Data.Binary.Put; import qualified Data.ByteString as B; B.unpack . runPut . mapM_ putWord32LE
12:25:51 <_frederik_> olsner: people had some valid criticisms, as well as some that i disagreed with
12:25:59 <glguy> sorear: is the current spam protection name /= title?
12:26:03 <hpaste>  Nestor_the_Inve pasted "Nestor_the_Investor" at http://hpaste.org/1545
12:26:07 <matthew-_> "Values are always encoded in network order (big endian) form, and encoded data should be portable across machine endianess, word size, or compiler version."
12:26:13 <matthew-_> http://hackage.haskell.org/packages/archive/binary/0.3/doc/html/Data-Binary.html
12:26:16 <lambdabot> http://tinyurl.com/3cx6qr
12:26:18 <sorear> glguy: yes.
12:26:28 <dcoutts> matthew-_: the higher level serialisation module has to pick one or the other to be interoperable, the lower level modules give you complete control.
12:26:37 <glguy> ok, I didn't want to create a sample paste to find that out
12:26:38 <glguy> ;)
12:27:05 <glguy> sorear: we are getting spam already?
12:27:11 <olsner> wli: yeah, that's what I mean with type notations - I imagine it could be safe without much IPA cleverness then..
12:27:22 <matthew-_> dcoutts: ahh ok, thanks
12:27:26 <arcatan> Spam spam spam spam. Lovely spam! Wonderful spam!
12:27:27 <sorear> matthew-_: You're reading the wrong documentation; you want the low-level interface not the "handle everything for me" interface
12:27:38 <olsner> _frederik_: oh, sounds interesting.. how long back approximately?
12:27:45 <mm_freak> let's say there is a function "getRandom :: t -> IO t", and i use the following in a do construct (where x has been defined earlier):
12:27:51 <mm_freak> x <- getRandom x
12:27:59 <mm_freak> is this translated into an in-place operation by GHC?
12:28:10 <shapr> Dang, OCaml's OUnit is based on HUnit, but still doesn't support test fixtures.
12:28:11 <ndm> mm_freak: unlikely
12:28:12 <matthew-_> sorear: ahh! you're right. Sorry. 0 out of 10 for me for bothering to explore the documentation
12:28:14 <matthew-_> so sorry.
12:28:27 <shapr> tmoertel_away: y0 y0, got a moment to discuss how to do unit test fixtures sanely in Haskell?
12:28:35 <mm_freak> ndm: even although the old value of x gets thrown away?
12:28:41 <sorear>  sorear pasted "HPaste timeout error" at http://members.cox.net/stefanor/hpaste-error
12:28:41 <olsner> mm_freak: the second x is just a name that happens to shadow the old as I understand things
12:28:45 <ndm> mm_freak: yes, even though
12:28:48 <sorear> shapr: ^^^
12:28:51 <mm_freak> hmm
12:29:04 <Igloo> shapr: fixtures?
12:29:07 <eivuokko> How partial/incomplete packages should I upload to hackage?
12:29:09 <dcoutts> matthew-_: is's sadly not that clear, we have to think about how to make the distinction clearer, between the modules for dealing with arbitrary binary representations and the one for conveniently serialising any Haskell value
12:29:16 <ndm> mm_freak: but i wouldn't worry, its all very fast anyway
12:29:30 <mm_freak> ndm: but sometimes it uses just too much memory
12:29:32 <eivuokko> There's no guidelines how finished the libraries/programs need t o be.
12:29:35 <Cale> any word on whether those spams are coming from a recognisable host?
12:29:44 <shapr> Igloo: Unit tests usually need setup and teardown before and after a test.
12:29:51 <ndm> mm_freak: nope, garbage collection will come around and mop up the extra list later, i wouldn't worry
12:30:11 <byorgey> eivuokko: probably doesn't matter as long as you're clear in the accompanying docs about the state of the library.
12:30:21 <eivuokko> Yeah, docs, right :-P
12:30:25 <glguy> Cale: the IP address changes
12:30:42 <sorear> shapr: Any clue about that error?
12:30:49 <eivuokko> I just have some libraries/bindings I won't finish and they might be useful to some.
12:30:57 <mm_freak> ok
12:31:00 <Cale> glguy: How about disallowing anything which looks like an HTML link?
12:31:01 <eivuokko> (And they are fully functional atm)
12:31:37 <shapr> sorear: apache2 just says "[Thu Jul 05 15:30:15 2007] [error] [client 69.30.123.194] proxy: error reading status line from remote server hpaste.org"
12:32:10 * shapr splits hpaste access/error logs into a separate file and restarts apache
12:32:11 <sorear> Cale: Because sometimes people paste those legitimatel.
12:32:24 <Cale> meh :)
12:32:37 <sorear> Cale: Our current system is much finer, and (modulo a bug) works 100%
12:32:47 <mgsloan> howsabout using leveraging the highlighting code to check if it looks anything much like haskell
12:32:47 <Cale> What's that?
12:32:54 <glguy> nick /= title
12:33:01 <glguy> pre truncation
12:33:05 <sorear> Cale: We truncate the nick to 15 characters before checking equality.
12:33:11 <shapr> What about refusing to announce pastes unless the given nick matches an irc nick visible to the hpaste bot?
12:33:20 <sorear> Cale: Nestor_the_investor == Nestor_the_investor
12:33:24 <sorear> Cale: Nestor_the_inv /= Nestor_the_investor
12:33:26 <glguy> I would not be opposed to eventually just having a password in the /title
12:33:42 <glguy> for /new
12:34:07 <shapr> I think Lemmih suggested a field hidden by css. Spam bots fill in all fields automatically, users would not do that for hidden fields.
12:34:20 <glguy> shapr: this on had someone do it manually the first time
12:34:52 <arcatan> glguy: no fair, I use xmonad and can't see window titles
12:35:00 <glguy> arcatan: type /topic
12:35:05 <arcatan> oh that title
12:35:34 <arcatan> I prefer the word topic for topic and title for <title>
12:35:41 <shachaf> arcatan: Why don't you print window titles? Don't you use a dzen?
12:36:05 <arcatan> I'm just too lazy to set it up
12:36:36 <shachaf> arcatan: At most three more lines of code, it's not complicated.
12:36:48 <wli> What's xmonad?
12:36:52 <sorear> glguy: I don't do css
12:36:59 <sorear> @topic-tell #xmonad
12:36:59 <lambdabot> xmonad: an open, free tiling window manager | xmonad 0.2 released! | home: http://xmonad.org | logs: http://www.cse.unsw.edu.au/~dons/irc/xmonad/
12:37:00 <shachaf> arcatan: Do you print workspace information out?
12:37:01 <shapr> @where xmonad
12:37:01 <lambdabot> http://xmonad.org/
12:37:16 <glguy> sorear: I didn't propose CSS soslutions?
12:37:24 <shapr> sorear: I did
12:37:38 <glguy> sorear: and elinks supports CSS :)
12:37:41 <sorear> glguy: oh sorry
12:37:53 <sorear> glguy: Yes, but it has a hack to show all hidden fields.
12:37:59 <glguy> unless you've regressed to using telnet for web browsing
12:38:00 <glguy> ah :)
12:38:01 <sorear> (to work around DHTML idiocy)
12:38:24 <sorear> Perhaps the label should say "Don't fill this is:"
12:38:29 <sorear> then I'd know not to.
12:38:42 <arcatan> shachaf: nope
12:38:54 <sorear> glguy: also, this seems wrong: -rw-r--r-- 1 eric eric    70 Jan 26 22:27 accounts.txt
12:39:09 <glguy> yeah
12:39:19 <glguy> though it is only exposed to people that have kakapo accounts
12:39:39 <shachaf> arcatan: Do you use a dzen at all?
12:39:47 <arcatan> yeah, for date and load information
12:40:53 <shachaf> arcatan: See the instructions in XMonadContrib/scripts/run-xmonad.sh for instructions on setting it up, if you want it.
12:41:19 <arcatan> hmm, hmm, I start xmonad from kdm...
12:42:31 <shachaf> arcatan: I start it from gdm.
12:42:44 <shachaf> arcatan: I just make gdm run ~/.xsession.
12:42:55 <arcatan> I wonder if you can make kdm do that
12:44:30 <sorear> I've finally managed to delete both spams.
12:44:39 <sorear> I wonder why hpaste is being so slow...
12:45:32 <arcatan> aha, the custom option
12:46:01 <matthew-_> oh my word. Put confuses me totally.
12:46:10 <shachaf> matthew-_: Put?
12:46:19 <glguy> Data.Binary class
12:46:22 <matthew-_> the Put monad.
12:47:02 <mgsloan> really?
12:47:08 * sorear wonders if there's a better way to remove the final newline from a text file than a hex editor :)
12:47:39 <glguy> readFile "" >>= writeFile "" . init ?
12:47:41 <glguy> :)
12:47:41 <matthew-_> sorear: s/[\r\n]+$//
12:48:02 <sorear> matthew-_: Not valid sh syntax
12:48:16 <Vulpyne> Do you need to test for it?
12:48:19 <Jaak> sed
12:48:19 <matthew-_> oh right, add some extra \s then!
12:48:40 <opqdonut> sorear: sed -e '$s/\n$//' for unix line-endings
12:48:41 <mgsloan> put basically just outlines the output.  put "foo" >> put a will stick the integer 3, the string foo, and whatever put a evaluates to
12:49:01 <arcatan> shachaf: do I have to compile xmonad with some specific settings/modules to enable the workspace stuff?
12:49:09 * mgsloan just figured out a situation which requires phantom types
12:49:26 <shachaf> arcatan: You need XMonadContrib.LogHook and you need to use run-xmonad.sh from scripts/
12:49:42 <sorear> Come on!  It's just the monad generated by the free variety with 256 unary operators and 0 laws!
12:49:44 <arcatan> I'm just setting up run-xmonad.sh
12:49:45 <sorear> :)
12:51:14 <shachaf> arcatan: Oops, that's XMonadCOntrib.DynamicLog.
12:53:24 <matthew-_> mmm. some of the stuff in ByteString says O(c) without defining what c is. Any ideas? n seems to be length...
12:54:48 <sfultong> anyone know why ghc 6.6 is masked in gentoo?
12:55:14 <Cale> matthew-_: iirc, it's really the same as O(n)
12:55:19 <Cale> It's the number of chunks.
12:55:21 <sorear> matthew-_: You must be looking at .Lazy
12:55:31 <matthew-_> sorear: I am
12:55:39 <matthew-_> ahh, ok. thanks
12:56:00 <sorear> matthew-_: c is the chunk count, which is asymptotically the same as the byte count, but smaller by a factor of 16376
12:56:32 <matthew-_> cool. thank you
12:58:21 <cedricshock> How can I sort a list for uniqueness? Just sort it and test the neighboring pairs, or is this already done somewhere standard that I can't find?
12:58:39 <Cale> map head . group . sort
12:59:02 <cedricshock> Cale: Thanks
12:59:16 <glguy> Set.toList . Set.fromList
12:59:35 <dcoutts> one can do it more efficiently by just modifying the sort algorithm slightly
12:59:47 <Excedrin> @src nub
12:59:47 <lambdabot> nub = nubBy (==)
12:59:57 <Excedrin> @src nubBy
12:59:57 <lambdabot> nubBy eq []             =  []
12:59:57 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
13:00:14 <Saizan> Excedrin: nub is quadratic but preserves the order
13:00:39 <Excedrin> ya, I was just curious
13:00:55 <glguy> using Set the order could be preserved (not as i wrote it) in O(n lg m) where m is the number of unique elements :)
13:02:09 <cedricshock> I don't really care about order. Technically these are sets, but since the next thing I'm going to do is use them in an order I figured pulling out set to store them in was overkill.
13:04:18 <sjanssen> @YOW!
13:04:18 <lambdabot> Unknown command, try @list
13:04:27 <sjanssen> pssh, that should work
13:05:08 <sorear> #ghc is a lot more active now :)
13:06:55 <||NanoX||> @help
13:06:55 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:07:03 <malsyned> dons wrote an essay one time about the importance of getting error handling in Haskell explained and under control.  Was there ever anything else written on that subject?
13:07:05 <sjanssen> hmm, where is the command corrector?
13:07:17 <malsyned> some kind of error handling tutorial?
13:07:28 <||NanoX||> @help command
13:07:28 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:07:51 <mgsloan> http://article.gmane.org/gmane.comp.lang.haskell.libraries/6382
13:07:53 <lambdabot> Title: Gmane -- Mail To News And Back Again
13:08:11 <eivuokko> Any Windows users here...anyone want to comment if Win9x compatibility is important for them?  In general and I am especially interested in users of Win32-package.
13:08:18 <quicksilver> is there an easy way to extend the 'library load path' of ghci?
13:08:18 <mgsloan> http://www.randomhacks.net/articles/2007/03/10/haskell-8-ways-to-report-errors
13:08:20 <lambdabot> Title: 8 ways to report errors in Haskell, http://tinyurl.com/2yz77l
13:08:24 <mgsloan> the two error handling things
13:08:26 <quicksilver> tell it to look for libraries somewhere else?
13:10:47 <malsyned> mgsloan: those are exactly the posts I was thinking of (although I'd combined them in my head and credited the whole thing to dons).  Was there ever any followup on the "questions we can tackle" he posed?
13:12:17 <mgsloan> I think there are some replies
13:13:04 <malsyned> ah, so there are.  thanks.
13:13:49 <mgsloan> http://search.gmane.org/?query=RE%3A+There+are+too+many+error+handling&author=&group=gmane.comp.lang.haskell.libraries&sort=relevance&DEFAULTOP=and&xP=Zerror%09Zhandl&xFILTERS=Gcomp.lang.haskell.libraries---A
13:13:55 <mgsloan> loads of replies, really
13:19:22 <malsyned> mgsloan: yeah.  that'll give me something to chew on.  Thanks.
13:20:51 <quicksilver> any tagsoupers?
13:21:41 <mgsloan> welcome.  I was just looking at this stuff yesterday :)
13:31:30 <matthew-_> ok, the saga of Put confusing me continues
13:31:41 <matthew-_> How do I get from [[Put]] to ByteString?
13:32:00 <matthew-_> I know it's really just a writer monad, but it seems to be so confusing me!
13:32:17 <dcoutts> @type join
13:32:21 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
13:32:37 <dcoutts> matthew-_: so that'll get you to [Put], then sequence
13:32:39 <matthew-_> oh of course, list is a monad. I always forget that
13:32:40 <sjanssen> @type sequence_ . concat
13:32:42 <lambdabot> forall (m :: * -> *) a. (Monad m) => [[m a]] -> m ()
13:32:44 <earthy> hm. that's a bit of a pity. lambdabot does not have Text.XHtml loaded by default...
13:32:51 <earthy> but it can show the types in it...
13:32:53 <dcoutts> oh, yeah, doh, just contat, not join
13:33:14 <matthew-_> ahh, and I did sequence and that didn't work - I forgot about sequence_
13:33:16 <matthew-_> many thanks
13:33:27 <dcoutts> mattam: then use the Put's run function to get a ByteString
13:33:55 <dcoutts> matthew-_: if you care about speed, you might see how to avoid all those lists and do the Put'ting more directly
13:34:21 <mgsloan> why does Data.Binary want runhugs?
13:34:23 <matthew-_> yes, I do care about speed. Muchso
13:34:30 <mgsloan> (I'm trying to install it)
13:34:45 <monochrom> You can use runghc instead, I bet.
13:35:20 <monochrom> Are you running Setup.hs and seeing "runhugs not found"? You can ignore it. You can ignore everything.
13:36:01 <mgsloan> oh, how do I ignore (it also wants stuff like haddock, c2hs, cpphs, greencard, etc)
13:36:18 <SamB> mgsloan: it will say "foo not found" whether or not it needs foo
13:36:36 <SamB> if it says that it failed to configure the package, then you have a problem
13:36:41 <SamB> otherwise go on to building ;-)
13:37:10 <mgsloan> oh, ok
13:37:11 <monochrom> You can blindfold your eyes and touch-type. :)
13:38:09 <mgsloan> so, when's the haskell gem equivalent coming into existance?
13:39:25 <SamB> "gem"?
13:39:28 <SamB> is that from Atari?
13:39:39 <mgsloan> nope, ruby
13:39:49 <mgsloan> it's like apt-get, but for ruby libs
13:40:18 <SamB> ah, you mean cabal-get
13:40:28 <Excedrin> it would be nice to have a single system for that sort of thing for all languages, it's sort of annoying that each language has its own thing
13:40:36 <mgsloan> gem install hobix, for example
13:40:41 <mgsloan> yeah
13:40:58 <SamB> Excedrin: the trouble is that these systems are usually either distribution- or language- specific
13:41:42 <monochrom> There is apt-get. It also saves you from building.
13:42:06 <sjanssen> monochrom: of course someone has to build the .deb in the first place
13:42:15 <SamB> and if the distribution-specific way doesn't have any language-specific support, that's annoying too
13:42:20 <Excedrin> All packaging systems are sort of horrible. They all have a few nice features...
13:42:23 <monochrom> Of course Windows InstallShield is the ultimate answer. :)
13:42:52 <SamB> monochrom: ... I'm sure that will be extremely helpful in installing haskell libraries on my debian system...
13:43:01 <Excedrin> is everyone familiar with Nix?
13:43:29 <monochrom> I'm trying to illustrate the benefits of a monopolizing system. If only everyone uses ___.
13:43:53 <Excedrin> http://nix.cs.uu.nl/
13:43:55 <lambdabot> Title: Nix
13:44:26 <Excedrin> This is a nice project. I really like the idea of a garbage collected file system.
13:44:58 <earthy> it works quite okay
13:45:09 <monochrom> Oh. Unix's is close to a garbage-collected file system. It uses reference counting.
13:45:26 <earthy> but the ghc expression for nix is slightly ugly
13:45:34 <earthy> and quite tied to linux
13:46:07 <Excedrin> monochrom: yes, this is a little different. It's like if nobody has package X installed during a collection and nothing depends on it, it's safe to delete.
13:46:11 <earthy> plus, nix eats diskspace for breakfast, lunch, dinner, tea, betweens and snacks. :)
13:46:24 <Muad_Dib> probably because the only serious Nix users that use haskell use linux earthy ;)
13:46:25 <Excedrin> earthy: did you try it?
13:47:50 <earthy> excedrin: eelco works in the office 2 doors down from mine
13:48:06 <earthy> I've tried using it to make a ghc based buildfarm
13:48:26 <earthy> unfortunately, the ghc expression is firmly stuck to linux
13:48:32 <Muad_Dib> and I'd think a better idea to discus Nix more closely would be in #trace (except that everybody is sleeping there)
13:48:50 <earthy> which means I'd just be able to build on linux.
13:49:04 <earthy> muad_dib: true enough.
13:49:30 <Excedrin> how is it stuck to linux? It uses options for GNU tools?
13:49:39 <earthy> but the idea is great... and really should work well in combination with cabal
13:49:42 <Excedrin> what's #trace ?
13:49:53 <earthy> nah... it bootstraps from a binary tarball containing a ghc. :)
13:49:58 <Muad_Dib> Excedrin: a channel
13:50:55 <earthy> ah, an arie!
13:51:02 <amiddelk> 13:49:53 <earthy> nah... it bootstraps from a binary tarball containing a ghc. :)
13:51:17 <earthy> not anymore? you fixed that by now?
13:51:23 <amiddelk> no, that's because I never was able to let the build process bootstrap from .hc files ;)
13:51:34 <earthy> thought so. :)
13:51:51 <earthy> by the time I get some more round tuits I might try again
13:52:02 <amiddelk> didn't try the more recent builds of ghc though
13:56:06 <Pupeno> The type of head is [a]->a, but "A Gentle Introduction..." says that a->a is also a valid type, but there the input and the output should be the same type and the input and output of head are not of the same type... where am I wrong? (it alsa says that [b]->a is valid as well as a... b->a seems valid as well but is not mentioned, is it valid?)
13:57:11 <oerjan> a->a is valid but not for head
13:57:33 <oerjan> @type id
13:57:35 <lambdabot> forall a. a -> a
13:58:18 <Pupeno> oerjan: I know it is a valid type, but AGITH is taking about more specific or more broad types all valid for the function head.
14:00:08 <mauke> Pupeno: yes, b->a is also valid
14:00:28 <mauke> those are "supertypes" of [a] -> a
14:00:50 <oerjan> a->a must be a mistake
14:00:52 <mauke> hmm, wait. a -> a looks wrong
14:01:10 <monochrom> I think it means "a->a is a valid type for something else"
14:01:23 <Pupeno> that was my main question... a->a doesn't look like, now that I know the word, a supertype of [a]->a
14:01:31 <oerjan> section 2.1, last paragraph
14:01:36 <mauke>  For example, the principal type of head is [a]->a; [b]->a, a->a, or even a are correct types, but too general, whereas something like [Integer]->Integer is too specific.
14:01:39 <Excedrin> @src head
14:01:39 <lambdabot> head (x:_) = x
14:01:39 <lambdabot> head []    = undefined
14:01:41 <oerjan> http://www.haskell.org/tutorial/goodies.html
14:01:42 <lambdabot> Title: A Gentle Introduction to Haskell: Values and Types
14:01:54 <SamB> Pupeno: no indeed
14:02:01 <oerjan> monochrom: the way it is written there seems clearly wrong
14:02:08 <Toxaris> it's meant like this:
14:02:28 <Toxaris> a->a or even a are wellformed types, but they are too general to be types of head
14:02:46 <SamB> perhaps s/a->a/a->b/
14:02:52 <SamB> Toxaris: I don't think that's it...
14:02:57 <mauke> yeah, it should say a->b or b->a
14:03:04 <Toxaris> but [b] -> a is not a generalization of [a] -> a, so i tell nonsense
14:03:18 <Toxaris> ahhh, i mea ... a -> a ... [a] -> a ...
14:03:29 <Toxaris> what do i know what i mean :-(
14:03:38 <mauke> @hoogle Socket -> CInt
14:03:39 <lambdabot> Network.Socket.fdSocket :: Socket -> CInt
14:53:18 <shapr> Is -threaded something you can put into {-# OPTIONS #-} ?
14:54:44 <sjanssen> shapr: no
14:56:33 <shapr> What happened to rawSystemVerbose?
15:17:34 <WestofHous1> /HELP
15:17:50 <monochrom> syntax error
15:18:09 <EvilTerran> um. isn't "west of house" where you start in zork?
15:18:18 <Taral> lol
15:18:25 <Taral> I feel old now.
15:19:43 * DRMacIver attempts to grok comonads and has brain melty.
15:20:21 <Alleria> DRMacIver: yep, that's about what I got
15:20:59 <DRMacIver> Eh. I'll add them to the "I'll figure them out when I actually need them" pile.
15:21:24 * EvilTerran would've been tempted to reply "There is a small mailbox here." if that random had hung around long enough.... ;p
15:21:58 <DRMacIver> Hm.
15:29:57 <araujo> hello!
15:30:05 <EvilTerran> hi there!
15:30:05 <Heffalump> hello!
15:30:09 * Heffalump drunk is
15:30:34 <Heffalump> for which I blame augustss
15:30:40 <mauke>  <moira> while*(not tvomit) { dinrk} l // OMG I wronte a PROGMRA
15:31:18 <EvilTerran> uh... pointer to a while loop?
15:31:27 <Heffalump> uh... drunk coding?
15:31:47 <EvilTerran> heh. true.
15:31:53 <EvilTerran> (or, in c-speak, 1)
15:32:29 <monochrom> *( is a typo for (. l is a typo for ;
15:32:58 <EvilTerran> I know, i know. "pointer to while" was just the first thing i thought. =p
15:33:30 <monochrom> Sorry for analysing a joke. :)
15:33:31 <mauke> haha, there's an urbandictionary entry for "wronte"
15:33:36 * Heffalump wonders how much useful code has been written while drunk
15:33:38 <Excedrin> moria is funny
15:34:15 <EvilTerran> I find my inspiration flows more freely after a little single malt
15:34:34 <monochrom> @quote drunk
15:34:34 <lambdabot> dons says: keroppi: i was thinking of a similar thing recently, on a bus travelling between the hotel and the google summer of code summit, sitting next to guys from apache, python, freebsd, netbsd,
15:34:34 <lambdabot> perl, gentoo... the end of open source was a drunk driver away, with only php goons left to run the show
15:34:42 <monochrom> @quote drunk
15:34:42 <lambdabot> dons says: keroppi: i was thinking of a similar thing recently, on a bus travelling between the hotel and the google summer of code summit, sitting next to guys from apache, python, freebsd, netbsd,
15:34:43 <lambdabot> perl, gentoo... the end of open source was a drunk driver away, with only php goons left to run the show
15:34:54 <int80_h> I'm trying to create a data type with four parameters. he first two parameters and the second two parameters must each be the same type
15:35:10 <Heffalump> make it have two parameters then, not four...
15:35:17 <Heffalump> data Foo a b = Foo a a b b
15:35:18 <EvilTerran> data Foo a b = Bar a b a b ?
15:35:25 <monochrom> Like those.
15:35:28 <int80_h> woah
15:35:28 <EvilTerran> depending on what you meant
15:35:45 <Heffalump> EvilTerran is wrong and I am right! ;-)
15:35:47 <EvilTerran> yay for monospaced fonts, that looks quite cool on my screen ;p
15:36:18 * glguy wonders who uses IRC w/o monospaced fonts
15:36:40 <EvilTerran> people who use the default configs in a lot of things.
15:36:41 <monochrom> I sometimes do.
15:37:07 <EvilTerran> it's odd, actually. most people seem to IRC and/or code in monospaced, but most software seems to default to variable-width
15:37:14 <ricky_clarkson> I've never seen IRC w/o monospaced fonts.
15:37:22 <EvilTerran> Gaim/Pidgin?
15:37:32 <EvilTerran> CGI:IRC, too
15:37:37 * glguy proposes an enforcement bot
15:37:44 <monochrom> If you converse in English, e.g., #teenchat, proportional fonts make more sense.
15:38:05 <genneth> @seen dons
15:38:05 <lambdabot> dons is in #haskell-icfp07, #ghc, #xmonad and #haskell. I last heard dons speak 8h 49m 25s ago.
15:38:17 <sorear> @itme dons
15:38:18 <lambdabot> Local time for dons is Fri Jul  6 08:37:12 2007
15:38:21 <monochrom> Like why would you insist on monospace in #philosophy.
15:38:35 <EvilTerran> I actually find monospaced easier on the eyes. less squinting trying to differentiate between I,l,1,|, etc
15:38:39 <glguy> monochrom: because irc should be used from a console window!
15:38:43 <dibblego> is there a QuickCheck generalisation or technique for asserting properties about a type-class that are not compile-time enforced?
15:38:48 <dibblego> ?check \xs -> fmap id (xs :: [Int]) == id xs
15:38:49 <sorear> monochrom: Because all characters are equal, duh!
15:38:51 <lambdabot>  OK, passed 500 tests.
15:38:56 <dibblego> ?check \xs -> fmap id (xs :: Maybe Int) == id xs
15:38:57 <lambdabot>  OK, passed 500 tests.
15:39:04 <dibblego> e.g. so I don't have to repeat myself there ^
15:39:09 <monochrom> Haha, why would you use a console for the like of #metaphysics.
15:39:22 <sorear> dibblego: ahem, that's a functor *law*
15:39:24 <EvilTerran> monochrom, because it's 1980 ;p
15:39:27 * monochrom is subtly deriding those channels :)
15:39:32 <sorear> you don't need to @check it
15:39:41 <Heffalump> sorear: nice catch on that FC(NewType+AssociatedTypes) bug, btw
15:39:42 <dibblego> sorear, I do if I write the instance Functor
15:40:11 <dibblego> sorear, or I suspect the [] or Maybe instance Functor to be broken
15:40:32 <dibblego> sorear, suppose I write instance Functor for many types; I am repeating myself when I write my QC
15:40:49 <sorear> ok.
15:41:09 <dibblego> is there a canonical way not to repeat myself?
15:41:15 <monochrom> Repetition helps correctness.
15:41:29 <dibblego> so you think repeating is a good thing?
15:41:41 <dcoutts> so you think repeating is a good thing?
15:41:49 <monochrom> Repetition helps correctness.
15:41:51 <EvilTerran> ?check let functorProperty v = fmap id v == id v in \xs -> functorProperty xs
15:41:52 <lambdabot>        add an instance declaration for (Arbitrary (f a), Show (f a))     In t...
15:41:53 <dibblego> I would like to universally quantify across all Functor instances, which there are potentially infinite
15:42:01 <EvilTerran> ?check let functorProperty v = fmap id v == id v in \xs -> functorProperty (xs :: [Int])
15:42:05 <lambdabot>  OK, passed 500 tests.
15:42:15 <EvilTerran> or indeed
15:42:22 <dibblego> EvilTerran, that's all I can come up with too
15:42:26 <EvilTerran> ?check let functorProperty v = fmap id v == id v in functorProperty :: [Int] -> Bool
15:42:27 <lambdabot>  OK, passed 500 tests.
15:42:28 <monochrom> OK, seriously, you have heard of "write the program twice". Basically that.
15:42:34 <dibblego> EvilTerran, but you lose some information
15:42:36 <EvilTerran> ?check let functorProperty v = fmap id v == id v in functorProperty :: Maybe Double -> Bool
15:42:38 <lambdabot>  OK, passed 500 tests.
15:42:41 <EvilTerran> etc
15:43:08 <EvilTerran> what do you lose?
15:43:14 <dibblego> monochrom, was that seriously serious or sarcastic?
15:43:25 <monochrom> Seriously serious.
15:43:44 <dibblego> no I haven't heard of it any more than any other sentence
15:43:54 <dibblego> "write the program twice" sounds very Java-like
15:43:57 <EvilTerran> write the program, then write another one to test it; the second does the same thing, and verifies that he first agrees with it
15:44:06 <sorear> that won't work
15:44:14 <sorear> you'll cache the algorithm
15:44:19 <EvilTerran> if you get an error, you know _one_ of 'em's wrong
15:44:28 <sorear> but you won't get an error
15:44:40 <sorear> the two programs will be buggy in exactly the same way
15:44:46 <monochrom> Alright. There is a software development advice of prototyping, then throwing away the prototype, and rewrite from scratch.
15:44:57 <dibblego> monochrom, ah yes, now I know what you mean
15:45:06 <EvilTerran> sorear, well, you can check your uber-optimised manually-tuned expressions against the naive implementation you derived them from
15:45:12 <EvilTerran> say
15:45:16 <sorear> EvilTerran: true.
15:45:45 <oerjan> isn't this something for this template haskell i keep hearing about?
15:46:09 <EvilTerran> dibblego, what info do you lose with my approach?
15:46:22 <sorear> time.
15:46:31 <EvilTerran> time?
15:46:37 <sorear> time.
15:46:50 <sorear> time you'd much rather spend ircing :)
15:47:03 <dibblego> EvilTerran, I've forgotten now :) but I did come up with that and think that - I'll try it again so I remember
15:47:22 <EvilTerran> oerjan, TH sounds like overkill for this sort of thing
15:47:26 <monochrom> Fundamentally, correctness requires some repetition. You write a spec, and you write the code, and only then you can talk of correctness because you have two things to compare. Note that the spec contains some information also in the code, and the code contains some information also in the spec. Yes they also have differences. But there is repetition.
15:48:17 <dibblego> I concede to there being repitition, however, it feels like I should be able to universally quantify across all Functor instances - the best I can come with is what EvilTerran wrote - I wasn't sure if this was optimal
15:48:39 <monochrom> I see.
15:49:55 <dcoutts> monochrom: mmm, I'm not sure I'd seen it quite that clearly before, but certainly it does describe what we do, we seek two ways of describing the problem, one *obviously* right and one with other desirable qualities
15:50:41 <EvilTerran> dibblego, as in, you wanted to write something that would check every Functor instance in scope without having to list each instance?
15:51:17 <dibblego> EvilTerran, no, I just wanted to shorten my expression to something like "this instance Functor declaration should satisfy this property" and be done with it - like what you wrote
15:51:28 <dcoutts> monochrom: a case where there appears to be little repetition is when we have a non-constructive spec, that just describes one of many properties that we expect to hold of the impl
15:51:34 <dibblego> where "this property" is just an identifier (again like you wrote)
15:51:57 <EvilTerran> i imagine it'd be fairly trivial to have something to locate all instances of a class and build tests for each instance, as part of the build process
15:52:31 <dibblego> imagine I make a mistake in expressing the Functor property
15:52:39 <dibblego> this the point that monochrom makes
15:52:58 <dibblego> worse, imagine I make that mistake then my instance Functor passes because of it
15:53:24 <dibblego> by constantly repeating this property, I open myself to making this mistake
15:53:34 <dibblego> I would like to write it once, verify itas best as I can, then move on
15:54:53 <oerjan> right, so EvilTerran's solution seems fair enough
15:54:54 <EvilTerran> in which case, defining functorProperty x = (fmap id x == x) is the way to go, i'd say
15:55:05 <dibblego> ok, I thought there was just something more
15:55:19 <dibblego> I write lots of type-classes where a property holds that is not compile-time enforced
15:55:19 <sorear> let (===) = liftM2 (==) in fmap id === id
15:55:24 <dibblego> thanks
15:56:33 <EvilTerran> or, as i said, training your IDE to autogenerate test properties for all instances of standard library classes whenever you build
15:57:03 <Toxaris> writing the spec should be the job of the class writer, not of the instance writer
15:57:24 <dibblego> Toxaris, I agree
15:57:31 <int80_h> test
15:57:35 <int80_h> firstTwo :: Quad (a b) => (a b) -> a
15:57:36 <monochrom> passed
15:57:53 <Toxaris> so we need higher order type classes, to express "there is a list of specs for this type class"
15:57:54 <int80_h> firstTwo (a b) = a
15:57:56 <dibblego> Toxaris, at the moment, I am writing them in a comment (in Scala and sometimes Haskell)
15:58:11 <dibblego> Toxaris, those thoughts have been running through my mind, yes
15:58:14 <int80_h> so givenI get a parse error on the second line
15:58:40 <int80_h> the data type is this
15:58:53 <int80_h> data Quad a b = Quad a a b b
15:59:00 <monochrom> (a b) is not a legal pattern. To implement firstTwo, you can only rely on the methods of Quad.
15:59:28 <int80_h> is my type signature right?
15:59:40 <mauke> no, => is for class constraints
15:59:46 <int80_h> hmm
15:59:51 <int80_h> okay back to the source...
15:59:54 <monochrom> Quad is not a class??!!
16:00:01 <int80_h> no it's not it's a data type
16:00:09 <monochrom> Then you never say =>
16:00:13 * int80_h nods
16:00:38 <byorgey> int80_h: do you want something like firstTwo :: Quad a b -> a?
16:00:45 <Excedrin> so, is hpaste broken?
16:00:46 <monochrom> firstTwo :: Quad a b -> (a, a) ?
16:00:51 <byorgey> or that?
16:00:51 <int80_h> yes
16:01:04 <monochrom> firstTwo (Quad x y _ _) = (x,y)
16:01:08 <int80_h> I think what monochrome said is what I want
16:01:50 <monochrom> hpaste is down. resolving spam problem.
16:02:07 <sorear> no, hpaste is up, spam problems are fixed.
16:02:13 <monochrom> OH! NICE!
16:02:23 * sorear wrote tha patch
16:02:46 <monochrom> But it's slow.
16:02:48 <sorear> or rather, http://hpaste.org:8000/ works.
16:02:54 <byorgey> verrrry slow
16:03:06 <sorear> :8000 is extremely fast.
16:03:09 <glguy> maybe they are still spamming
16:03:10 <glguy> but
16:03:13 <glguy> timeing out :)
16:03:17 <glguy> timing*
16:03:22 <int80_h> grrr still getting parse problems
16:03:23 <Excedrin> :8000 is very slow
16:03:26 <byorgey> :8000 is working for me but still slow
16:03:33 <sorear> Excedrin: funny, it's fast for me
16:03:35 <int80_h> firstTwo :: Quad a b -> (a, a)
16:03:42 <monochrom> It's 1% fast and 99% slow.
16:03:47 <int80_h> um that's not it hold on
16:03:50 <Excedrin> oh, I see... the link for "new paste" points to hpaste.org without the port
16:03:56 <int80_h> firstTwo :: Quad a b -> a
16:03:58 <int80_h> firstTwo (a b) = a
16:04:05 <int80_h> and here is the data type
16:04:05 <glguy> :8000 doesn't speed it up for me either
16:04:16 <int80_h> data Quad a b = Quad a a b b
16:04:18 <glguy> int80_h: that won't won't
16:04:32 <hpaste>  Excedrin pasted "moira quotes, comedy" at http://hpaste.org/1548
16:04:35 <byorgey> int80_h: (a b) is not a valid pattern to put after firstTwo
16:04:43 <glguy> work&
16:04:43 <monochrom> I guess the whole of #haskell is slashdotting hpaste, that's why. :)
16:04:47 <hpaste>  Excedrin pasted "moira quotes, comedy" at http://hpaste.org/1549
16:04:52 <hpaste>  Excedrin pasted "moira (comedy)" at http://hpaste.org/1550
16:04:57 <Excedrin> ugh, sorry for multiple pastes
16:05:24 <glguy> one irc channel can't "slashdot" something :)
16:05:27 <byorgey> int80_h: did you see monochrom's implementation above?
16:05:33 <int80_h> he had two
16:05:43 <int80_h> eep now it's scrolled away
16:05:53 * int80_h curses not having a local log
16:05:53 <byorgey> I guess the whole of #haskell is #haskelling hpaste, then.
16:06:03 <sorear> int80_h: Page up
16:06:09 <sorear> (the key)
16:06:13 <byorgey> <monochrom> firstTwo (Quad x y _ _) = (x,y)
16:06:14 <monochrom> firstTwo (Quad x y _ _) = (x,y)
16:06:55 <monochrom> The type inferer will tell you its type.
16:07:15 <sorear> @seen alexj
16:07:15 <lambdabot> I saw alexj leaving #haskell 15h 47m 52s ago, and .
16:07:28 <byorgey> and .
16:07:54 <ndm> @seen dons
16:07:55 <lambdabot> dons is in #haskell-icfp07, #ghc, #xmonad and #haskell. I last heard dons speak 9h 19m 16s ago.
16:08:44 <int80_h> thanks that compiled
16:09:01 <byorgey> int80_h: do you understand what that code is doing?
16:09:11 <int80_h> let me look it over...hold on
16:09:27 <int80_h> the type signature says this :
16:09:56 <int80_h> "take two variables a and b of type Quad."
16:10:13 <shapr> bringert: Know of any haskell-implemented xml templating that does stuff like <li for x in [1,2,3]>$x</li> ?
16:10:14 <int80_h> "return the first pair, which will be of the same type"
16:10:27 <int80_h> byorgey, is that right?
16:10:37 <byorgey> int80_h: not exactly, "Quad a b" doesn't mean "two variables a and b of type Quad".
16:11:13 <byorgey> int80_h: rather, "Quad a b" means something like "a Quad made of a and b".
16:11:13 <int80_h> hmm
16:11:19 <int80_h> ah!
16:11:32 <int80_h> thanks :)
16:11:42 <mauke> if you know C++ or Java, think List<int>
16:11:47 <byorgey> for example you could have "Quad Int String", or "Quad Char (Int,Int)", or whatever
16:11:53 <Alleria> Do the && and || operators in Haskell short-circuit?
16:11:54 <int80_h> I know C and Lisp
16:11:57 <sorear> Alleria: Yes.
16:12:05 <EvilTerran> Alleria, _everything_ in haskell short-circuits
16:12:05 <byorgey> @src (&&)
16:12:05 <lambdabot> True  && x = x
16:12:05 <lambdabot> False && _ = False
16:12:08 <sorear> Alleria: Infact, almost everything short circuits
16:12:12 <Alleria> sorear: thanks. Expression on the left gets evaluated first?
16:12:18 <sorear> Alleria: Right.
16:12:18 <ricky_clarkson> Except seq.
16:12:37 <EvilTerran> ricky, and monads. and so on.
16:12:40 <Alleria> ah, okay. Laziness in general, I see.
16:12:42 <chessguy> short-circuiting just falls out from laziness
16:12:49 <Alleria> makes sense
16:12:49 <sorear> EvilTerran: Monads short circuit!
16:13:01 <sorear> EvilTerran: because they aren't special at all.
16:13:11 <EvilTerran> ... okay then. never mind me.
16:14:23 <EvilTerran> Alleria, if you look at that source of (&&), you can see it has to evaluate its left-hand side to decide which line to use, and that determines whether x needs to be evaluated
16:14:48 <EvilTerran> so the left must be eval'd before the right. the same works for the source of other builtina
16:14:54 <EvilTerran> *builtins
16:15:29 <Alleria> ahhh, that makes sense. Thanks much.
16:16:09 * int80_h bounces
16:16:17 * shapr boings
16:16:20 <sorear> Alleria: The basic rule is that 1. evaluate the function 2. call the function (with unevaluated arguments!) 3. the function evaluates the arguments iff it needs them.
16:16:38 * byorgey boomerangs
16:17:18 <Alleria> and in this case if the first argument to && is false or the first argument to || is true, no need to do anything more.
16:17:26 <sorear> Alleria: Right.
16:17:46 <Alleria> thanks
16:17:57 <Toxaris> As i recently read somewhere, Haskell is non-strict by definition, not lazy. Could an implementation choose to force both arguments of && in parallel until one of them yields a False or both a True?
16:18:06 <sorear> Alleria: When you see a function defined with pattern matching, it matches patterns in normal English reading order (left to right, top to bottom)
16:18:27 <Alleria> sorear -- that'll be helpful to remember
16:18:33 <Alleria> cool
16:18:50 <sorear> Toxaris: No, because pattern matching is defined to diverge if the first pattern does.
16:19:19 <sorear> Toxaris: It would be legal for an implementation to start the evaluations in parallel, but it wouldn't be able to return until the first argument did.
16:19:43 <sorear> (which would still be a benefit, since part of the second eval could be overlapped with the first
16:19:53 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/1551
16:20:08 <hpaste>  norgul pasted "(no title)" at http://hpaste.org/1552
16:20:39 <sorear> glguy: That is the reason I did the matching after mangling - it gives us (anonymous) (no title) for free (usually not spammy)
16:21:04 <sorear> yup, those two pastes are identical.
16:21:08 * sorear deletes the first
16:21:58 <oerjan> sorear: but i haven't managed to browse it yet!
16:22:53 <sorear> they have the same content and come from the same ip.
16:24:48 <oerjan> if we are supposed to use :8000, maybe change the announcements?
16:24:54 <oerjan> !hpaste
16:25:03 <oerjan> !paste
16:25:03 <hpaste> Haskell paste bin: http://hpaste.org/
16:25:30 <Toxaris> sorear: Ok, thanks. So the non-strict vs. lazy distinction is about evaluation order, not evaluation outcome?
16:25:37 <sorear> Toxaris: Yes.
16:26:00 <DRMacIver> Although it can be about evaluation outcome in the sense that they can have different termination behaviour
16:26:16 <Toxaris> like (error "a" && error "b")
16:26:50 <byorgey> DRMacIver: can you give an example?
16:27:39 <Toxaris> is it defined wich error is raised? -- yes, it is, since the second param may be evaluated, but that evaluation doesn't count if the first fails...
16:27:44 <EvilTerran> > let forever = forever in forever && undefined
16:27:47 <lambdabot>  Exception: <<loop>>
16:27:54 <EvilTerran> > let forever = forever in undefined && forever
16:27:56 <lambdabot>  Undefined
16:28:00 <mm_freak> probably the best example is the `seq' function
16:28:14 <oerjan> > error "a" + error "b"
16:28:16 <byorgey> EvilTerran: ah.
16:28:17 <lambdabot>  Exception: a
16:28:17 <Heffalump> EvilTerran: I doubt that behaviour is specified anywhere.
16:28:26 <Heffalump> And it should certainly never be relied on.
16:28:30 <oerjan> that _could_ have legally been "b"
16:28:32 <EvilTerran> I think the order of stricture for && is defined
16:28:33 <Heffalump> Semantically, those are both _|_
16:28:43 <EvilTerran> i would hope so, anyway.
16:28:59 <Heffalump> yes, but the catching of the infinite loop isn't.
16:29:10 <mm_freak> btwâ¦  how is bottom represented in haskell code?
16:29:19 <oerjan> > undefined
16:29:20 <lambdabot>  Undefined
16:29:20 <Heffalump> generally, it isn't
16:29:38 <EvilTerran> well, yes, Heffalump. hugs doesn't catch it, for one, afaik.
16:29:44 <Heffalump> the point of it is that in the semantics, it represents operational failure
16:29:53 <Toxaris> mm_freak: use undefined for "I don't care" and error for "that shouldn't happen"
16:29:56 <EvilTerran> that would be an even better example of different sorts of operational failure.
16:29:58 <Heffalump> which may include things like non-termination
16:29:59 <sorear> Toxaris: No; termination behaviour is part of the semantics
16:30:04 <sorear> Toxaris: _|_ /= 2
16:30:22 <EvilTerran> non-termination vs exception thrown
16:30:26 <sorear> Toxaris: however, error "foo" == _|_ == error "bar"
16:30:30 <Heffalump> _|_ /= 2 ===> _|_
16:30:37 <sorear> EvilTerran: Still indistinguishable
16:30:45 <mm_freak> toxaris: i use Maybe or other monads for such purposes, but i've read that there _is_ actually a real bottom value
16:31:04 <Heffalump> ndm wants a more refined semantics with different _|_s
16:31:05 <Toxaris> sorear: termination behaviour == it diverges or not?
16:31:09 <sorear> Toxaris: Right.
16:31:13 <Heffalump> I think the theory behind Catch might require it
16:31:29 <Heffalump> mm_freak: well, there isn't. At least not operationally.
16:31:32 <EvilTerran> sorear, i understand that to be the case in Pure Honest Haskell, but it makes a difference in practice
16:31:33 <dons> 14 days till ICFP contest!
16:31:42 <dons> people seeking teams here: http://haskell.org/haskellwiki/ICFP_Programming_Contest/Teams_2007
16:31:44 <mm_freak> i understand
16:31:44 <lambdabot> Title: ICFP Programming Contest/Teams 2007 - HaskellWiki, http://tinyurl.com/3dx5mv
16:31:47 <dons> grab earthy while you've got a chance!
16:31:47 <Heffalump> in practice any _|_ but non-termination can be reliably caught in the IO monad
16:31:59 * Heffalump had almost decided against doing it
16:32:08 <Heffalump> but I have a nasty feeling I'll really regret it
16:32:31 <mm_freak> so a function like "f = f", which is of type "Int", does _not_ have a real value?
16:32:43 <mauke> > let f :: Int; f = f in f
16:32:46 <lambdabot>  Exception: <<loop>>
16:32:47 <Heffalump> not operationally, no.
16:33:06 <Heffalump> except in terms of the exception you can catch in the IO monad which may or may not arise.
16:33:14 <EvilTerran> mm_freak, its "value" is _|_, meaning that if you try to get its value, that attempt to get the value out will not return
16:33:21 <Heffalump> those kind of exceptions complicate the semantics somewhat.
16:33:21 <greenrd> "in the IO monad" meaning what?
16:33:27 <EvilTerran> in that either execution will stop or run forever
16:33:32 <Heffalump> meaning that catch has an IO type
16:34:04 <greenrd> isn't everything either "under main" or "under ghci's main evaluator" or whatever?
16:34:12 <EvilTerran> if catch didn't have an IO type, you could have the handler code running before the exception was thrown. which'd be... odd, to say the least.
16:34:17 <greenrd> and hence "in the IO monad" either way?
16:34:36 <mm_freak> evilterran: yeah, that's mathematicalâ¦  my question was, if there is a special value for Int, which consumes extra space
16:34:39 <Heffalump> there are pure functions that have a non-IO type and can do certain things
16:34:46 <mm_freak> and presumably, there isn't
16:34:49 <Heffalump> catch can only do its thing in the IO monad
16:34:49 <EvilTerran> mm_freak, indeed not.
16:34:58 <Toxaris> greenrd: yes in a way, but not everything knows about it
16:35:08 <mm_freak> k =)
16:35:23 <EvilTerran> whenever _|_ occurs, either it's a thunk that is yet to be determined, or something else has happened which means you'll never get a value out.
16:35:48 <mm_freak> i asked, because Maybe has actually four values:  _|_, (Just x), (Just _|_) and Nothing
16:35:58 <EvilTerran> well, "values"
16:36:14 <Heffalump> greenrd: one can reason about pure computations independently of the IO monad
16:36:26 <Toxaris> greenrd: that is, formally, Haskell programm execution is a two step process: first, evaluate pure functions to yield a IO value, second, interprete this value
16:36:26 <mm_freak> so if it's a Maybe Bool, and if Bool takes one bit, then my question was, whether the entire data structure needs two bits
16:36:40 <EvilTerran> Bool takes a lot more than two bits...
16:36:44 <Heffalump> Maybe Bool needs at least two bits, yes.
16:36:45 <EvilTerran> *one bit
16:37:01 <Heffalump> if the entire world was strict that might be all it needed
16:37:10 <EvilTerran> but, thoretically, Bool could be packed into one bit and Maybe Bool into two
16:37:15 <Toxaris> greenrd: but because of laziness, these steps are executed in parallel in practice, yielding pure function "called out of" the IO monad, but they are pure none-the-less
16:37:17 <mm_freak> uhm yeah, Maybe Bool without bottom already needs two bits =)
16:37:24 <mm_freak> â whether it needs three bits
16:37:47 <mm_freak> evilterran: i know, most languages/compilers define a boolean value to be a regular integer
16:38:04 <Heffalump> in practice, it probably takes multiple words, because everything will be boxed
16:38:15 <Heffalump> since it might either be a value, or a thunk
16:38:37 <mm_freak> btw, is there any useful paper about boxing?
16:38:54 <greenrd> Toxaris: my point is, what's the difference in terms of _|_ catching, between let foo = ackermann k in putStrLn foo, and putStrLn (ackermann k)?
16:39:25 <Heffalump> why would there be one?
16:39:36 <Toxaris> greenrd: I don't think there is any difference at all
16:39:45 <Toxaris> in terms of whatever
16:39:53 <greenrd> well, exactly - an exception doesn't become catchable just because you've done a reduction
16:40:13 <Heffalump> so what's your point?
16:40:16 <mm_freak> i think that this modular faculty function is unboxed:  fac 1 r n = mod x n;  fac x r n = (fac $! (x-1)) $! (mod (x*r) n) n
16:40:28 <greenrd> my point is, top level is the same as let
16:40:35 <mm_freak> but i'm not so sureâ¦  at least x can be very large without stack faultsâ¦  but the computation is still slow
16:40:37 <Heffalump> mm_freak: boxed/unboxed refers to the representation of data
16:40:39 <Heffalump> not the evaluation of code
16:40:41 <greenrd> so what is left?
16:40:53 <Heffalump> huh?
16:40:53 <mm_freak> uhm
16:41:02 <mm_freak> replace "mod x n" by "mod r n"
16:41:06 <Heffalump> catch only works in the IO monad. What does this have to do with let/top-level?
16:41:17 <greenrd> I'm asking what you mean by "in the IO monad"
16:41:29 <Heffalump> I already said that. It has an IO type.
16:42:42 <greenrd> well, putStrLn (ackermann k) has an IO type
16:42:49 <Heffalump> this has nothing to do with where the computation that throws is evaluated.
16:42:58 <Heffalump> It has to do with the type of the thing that can catch the exception.
16:43:22 <Heffalump> and there is no formal definition of whether or not it will actually catch it
16:43:29 <greenrd> ah
16:43:31 <Heffalump> but this doesn't matter, cos it's in IO
16:43:34 <greenrd> that doesn't sound very useful then
16:43:40 <greenrd> if it's not guaranteed to be caught
16:43:44 <Heffalump> it's very useful in practice
16:43:53 <greenrd> like Java finalizers - you can create them all you want but the implementation is free to ignore them
16:43:56 <greenrd> in principle
16:44:11 <Toxaris> most programming languages have no formal definition of what happens
16:44:13 <Heffalump> well, in practice appropriately placed deepSeqs work fine.
16:44:22 <Heffalump> indeed.
16:45:10 <monochrom> What was the question?
16:45:29 <Toxaris> Heffalump: is it? for what kind of errors is it more useful then an error monad?
16:45:37 <greenrd> it's ok, Heffalump answered it - my question anyway
16:46:10 <greenrd> sorear: wl-pprint seems to be behaving strangely and I'm not sure from the haddock how it's supposed to behave
16:46:30 <sorear> greenrd: Oh?
16:47:00 <Heffalump> Toxaris: any situation where you want to use pure code, or where you don't control the underlying code
16:47:05 <greenrd> sorear: well I'm not sure what nested groups are supposed to do
16:47:08 <Heffalump> e.g. lambdabot
16:47:36 <sorear> greenrd: I didn't write it and probably can't fix many bugs, this was Daan Leijen's pretty printer that I decided had been uncabalized for too long
16:47:49 <ndm> i have some low level optimisation questions about GHC
16:47:51 <greenrd> ok
16:48:15 <sorear> greenrd: if an outer group is flattened, than all inner groups must be, since the whole thing has to fit on one line.
16:48:17 <greenrd> just wondered if you could help me understand it
16:48:25 <sorear> greenrd: probably.
16:48:47 <ndm> i have two pieces of code, with very similar STG/ddump-simpl and they have different performance
16:49:02 <greenrd> ah well that's just it
16:49:03 <ndm> the one which is simpler and seems to do less takes longer
16:49:12 <sorear> ndm: same compiler version?
16:49:18 <ndm> sorear, 6.6.1
16:49:24 <greenrd> ah wait no, I got mixed up
16:49:42 <sorear> ndm: what about the CMM - is that similar?
16:49:42 <ndm> sorear, yes, both -O2 same version
16:49:51 <ndm> sorear, i'm not entirely sure how to read the CMM
16:49:54 <Toxaris> Heffalump: whats inpure about an error monad? unsafe code is a point, though
16:50:04 <Heffalump> pure as in non-monadic
16:50:21 <Heffalump> and because it's a lot more flexible, syntactically, and operationally
16:50:24 <sorear> ndm: it's C with no types and no variables and no function calls :)
16:50:41 <greenrd> sorear: I'm getting outer groups flattened when inner groups aren't, or so it looks like
16:50:54 <Heffalump> anyway, past my bedtime
16:50:55 <greenrd> sorear: I'm even getting line breaks where I put <+>
16:51:00 <Heffalump> night.
16:51:08 <ndm> sorear, its more a problem of finding the inner loop
16:51:15 <sorear> ndm: ah.
16:51:31 <ndm> plus the info/closure/call differences
16:51:51 <Toxaris> Heffalump: good night
16:51:55 <sorear> ndm: if you look in the STG, each lambda has a random 3-4 character string next to it - remember that, because it's the only name that survives into Cmm
16:52:40 <ndm> sorear, i have Main_zdspreludezu942zull112_entry, which is recursive but i can only see a pointer back to Main_zdspreludezu942zull112_closure
16:52:43 <greenrd> sorear: wait, no I'm not - I was running the wrong version
16:52:55 <ndm> and what is stg_gc_fun
16:53:01 <greenrd> sorear: that probably explains everything. thanks for your explanation, and good night.
16:54:35 <sorear> ndm: can you http://hpaste.org:8000/new the code chunk?  my memory of cmm naming conventions isn't quite behaving atm
16:55:24 <sorear> ndm: (shapr's mod_rewrite setup is not quite working either, and :8000 (which goes direct to hpaste) is a more reliable)
16:55:26 <ndm> probably,,,
16:55:54 <sorear> hmm, I can just compile a completely different program and look at the names
16:56:10 <hpaste>  ndm pasted "CMM" at http://hpaste.org/1560
16:56:53 <hpaste>  ndm pasted "CMM" at http://hpaste.org/1561
16:57:10 <ndm_> sorear, back, accidentally hit the wrong button...
16:57:21 <ndm_> http://hpaste.org/1561
16:57:46 <ndm_> hpaste is really not being happy today
16:58:11 <ndm_> those are the two CMM chunks, i'd like to have some inkling of what they each do
17:00:56 * sorear wades through CPP hackery
17:01:22 * EvilTerran munches on mozdev's bandwidth with wget
17:03:34 <sorear> ndm_: You don't need to worry about the stg_gc_fun.  I have absolutely no clue what it does, but I can tell it's in the slow path of a stack check
17:03:50 <sorear> Probably it grows the stack - a rare (we hope) occurence
17:04:45 <ndm_> really? Main_zdwccall_info is definately in the fast path
17:06:11 <sorear> ndm_: jump is a goto.  the next statement isn't executed
17:06:49 <ndm_> oh, i see
17:08:20 <ndm_> ok, so there is a stack check in each iteration of the old version
17:08:37 <ndm_> but the fast version includes a heap check as well
17:09:24 <sorear> ndm_: yes, the new version allocates an I# box in each iteration
17:09:27 <sorear> Int
17:09:37 <sorear> Izh in Z-encoding
17:09:52 <ndm_> i see absolutely no reason for it donig that...
17:09:58 <sorear> what are the arguments to the function I'm looking at?  Sp + 4 isn't all that meaningful :)
17:10:04 <ndm_> i'll hpaste the STG
17:10:33 <hpaste>  ndm pasted "STG for functions" at http://hpaste.org/1562
17:11:03 <ndm_> the second one has a case surrounding the Int#
17:11:09 <ndm_> * the old one
17:11:22 <sorear> Oh.
17:11:37 <sorear> in the new version, we always do a heap check
17:11:40 <ndm_> an entirely redundant one
17:11:46 <sorear> even though we only allocate on EOF
17:11:46 <ndm_> yes, thats whats blowing the performance
17:11:54 <ndm_> indeed
17:12:02 <sorear> in the old version, the heap check isn't floated
17:12:21 <sorear> lemme check that
17:13:31 <ndm_> eek, in teh fast path i have to both +8 and then -8 the heap, thats what is killing it
17:14:12 <ndm_> i would love to also eliminate the stack check
17:14:58 <sorear> aha
17:15:41 <sorear> the old version didn't coalesce the heap check because it saw the case and you can't move heap checks across cases (GC might happen)
17:16:14 <ndm_> so the old version is more efficient because of pointless junk
17:16:19 <sorear> s/cases/cases of boxed values/
17:16:22 <ndm_> so is that a GHC bug?
17:16:22 <sorear> exactly :)
17:16:29 <ndm_> i.e. that it should move the heap check down
17:16:50 <ndm_> i tried this program on GHC 6.7 and the performance sucks
17:16:54 <sorear> I wouldn't call it a bug so much as an "opportunity for improvement"
17:16:54 <ndm_> like 3 times regression
17:17:02 <sorear> :)
17:17:08 <ndm_> an opportunity for improvement which i demand :)
17:17:20 <ndm_> would there be any way to avoid the stack check?
17:17:52 <ndm_> obviously harder to do, but still required if i want identical C assembly
17:18:13 <sorear> we should delay heap checks as long as possible (where possible == without losing the ability to coalesce) <- a simple, unequivocally beneficial change to GHC.  the best type of missing optimization!!!
17:18:22 <hpaste>  norgul pasted "Simple test" at http://hpaste.org/1563
17:18:23 <Nucleo> sorry for the dumb question, but is the reverse function in the List module O(1) or O(n)?
17:18:35 <ndm_> ok, i'll write it up and submit it off to the simons
17:18:38 <sorear> ndm_: try it on amd64 - 8 more registers means that we can actually use some of them for argument passing
17:18:48 <sorear> -> less stack usage
17:19:04 <hpaste>  norgul pasted "Simple test" at http://hpaste.org/1564
17:19:38 <dons> so what's the spam prevention trick we're using now, sorear ?
17:19:52 <sorear> dons: name == title
17:19:59 <sorear> dons: and as promised, it's working
17:20:15 <sorear> Nucleo: O(N)
17:20:38 <sorear> Who is norgul and why is he double-pasting everything?
17:21:22 <SamB> hpaste seems to be double pasting...
17:21:35 <dons> do we have two bots? no.
17:21:40 <dons> but double pasting.
17:21:42 <sorear> SamB: no.  it works fine for me
17:21:47 <sorear> SamB: and ndm
17:21:59 <SamB> well ndm pasted CMM twice anyway
17:22:24 <sorear> dons: if this was a server side double paste, they'd be completely identical.
17:22:40 <sorear> dons: but one of the two pastes is missing a signature for the second function
17:22:44 <sorear> dons: ergo, client side
17:22:59 <mauke> is writeTVar strict in the value?
17:23:04 <sorear> no.
17:23:15 <mauke> good
17:25:10 <mauke> why is there no instance Ord TVar?
17:25:21 <dons> ordered by their contents?
17:25:29 <mauke> no, by memory address
17:25:34 <dons> um :)
17:25:46 <sorear> ndm_: did you get my message? (Knotted trees and compositional compilers: Musings on a transplate)
17:25:49 <mauke> or internal id number, or whatever
17:26:16 <dons> mauke: data MyTVar a = MyTVar !(TVar a) !Tag
17:26:20 <sorear> mauke: i dunno, but IORef is broken in the same way
17:26:44 <dons> we have seen maps of TVars though. hmm
17:26:52 <sorear> reference cells have deep identity
17:26:58 <dons> Is that what you want it for, mauke ? some Ord-constraining table?
17:27:05 <mauke> yes, I want a Set
17:27:05 <sorear> dons: I bet they were covariant, though
17:27:38 <mauke> that leads to the next problem: where do I get unique tags from?
17:27:46 <sorear> mauke: Data.Unique
17:28:16 <mauke> hmm, that's nice
17:28:52 <dons> http://programming.reddit.com/info/23wsy/comments
17:28:53 <lambdabot> Title: Continuing with continuations in Haskell (reddit.com)
17:30:48 <ClaudiusMaximus> woah, just reduced the CPU load of my live performance setup (involving haskell) from 97% to 66%, just by adding some extra compile-time flags
17:31:36 <sorear> @quote -O2
17:31:36 <lambdabot> ClaudiusMaximus says: compiling with -O2 reduced the time taken by my program's execution from 28mins to 17secs
17:33:38 <ClaudiusMaximus> the magic was roughly: -O2 -fexcess-precision -fvia-C -optc-O2 -optc-mfpmath=sse -optc-msse2 -optc-march=pentium-m
17:34:13 <ClaudiusMaximus> (i was using just -O2 before..)
17:34:13 <mauke> no -mtune?
17:35:18 <ClaudiusMaximus> hmm, reading the gcc man page makes me think that it's irrelevant for my cpu
17:37:05 <ClaudiusMaximus> actually i might just be confused
17:38:23 <sorear> -march subsumes -mtune
17:38:47 <sorear> -mtune=pentium-m executables will run best on a pentium-m, but will run at all on a 386
17:38:57 <ClaudiusMaximus> right, that's what i thought
17:38:59 <sorear> -march=pentium-m executables will run best on a pentium-m, but will segfault on a 386
17:42:59 <seliopou> any zlib support in ghc?
17:46:19 <SamB> JHC's typechecker has issues :-(
17:46:40 <sorear> seliopou: Yes.
17:46:44 <sorear> @where zlib
17:46:44 <lambdabot> I know nothing about zlib.
17:46:47 <sorear> @hackage zlib
17:46:47 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/zlib
17:47:01 <seliopou> Thanks!
17:47:03 <seliopou> :)
17:47:09 <SamB> it won't typecheck the program "main = return ()" :-(
17:48:37 <dons> ClaudiusMaximus: you using Doubles?
17:48:38 <sorear> SamB: I talked to John about that a while back; I think he said something about hating the MR too much to implement it correctly
17:48:51 <sorear> (or maybe this is a GHC bug, on rethink)
17:49:09 <mauke> SamB: monomorphism restriction?
17:50:15 <ndm_> sorear, i did - still trying to think through it
17:50:32 <SamB> mauke: isn't main supposed to have type IO () anyway?
17:50:52 <Cale> SamB: It's allowed to have type (IO a) for any a
17:50:53 <sorear> SamB: Yes - but where is that enforced?
17:51:00 <mauke> maybe that only happens when linking
17:51:07 <oerjan> @todo-add Make @hackage actually check that the requested package exists
17:51:08 <lambdabot> Entry added to the todo list
17:51:10 <SamB> Cale: oh.
17:51:20 <SamB> well, I made the "a" unambiguous
17:51:30 <sorear> SamB: if it happens during type inference, then main = return ()  is legal.
17:51:48 <sorear> SamB: if it happens later, then that's illegal
17:53:17 <oerjan> hugs also does not enforce main as IO
17:53:40 <oerjan> er...
17:53:58 <ClaudiusMaximus> dons: no, CFloat
17:53:59 <SamB> oerjan: does it mind if you give "return ()"?
17:54:26 <dons> ClaudiusMaximus: oh, similar then. yes sse flags, excessprecision and friends can make say, 50% improvement, in good cases.
17:54:43 <oerjan> SamB: Unresolved top-level overloading
17:54:45 <sorear> SamB: I see nothing in the report to make either JHC's or GHC's behaviour incorrect.
17:55:31 <SamB> ah.
17:55:39 <SamB> so GHC is just overly forgiving?
17:55:45 <sorear> as usual
17:55:46 <oerjan> it apparently treats main as just an ordinary identifier, even when using :main
17:55:48 <SamB> possibly by accident?
17:56:32 <sorear> Quite possibly.
17:57:09 * sorear did vi `which runhugs`
17:58:31 <sorear>     hugs->pushHVal(hugs->compileExpr("Main","main >> return () :: IO ()"));
17:58:46 <ndm_> is GHC 6.7 meant to be 3 times slower for identical code?
17:59:00 <ndm_> specifically I get identical CMM, then the performance goes :(
17:59:01 <sorear> ndm_: of course not
17:59:08 <sorear> ndm_: identical?
17:59:13 <ndm_> did they change -O2 from -fvia-C to -fasm or something
17:59:21 <SamB> ndm_: perhaps you should enable the CPS pass?
17:59:21 <ndm_> sorear, as far as i can tell, yes, identical
17:59:32 <sorear> ndm_: yes, and the performance difference is noted as 3%
17:59:34 <ndm_> SamB, from about 6 days ago
17:59:44 <sorear> SamB: which doesn't exist in any buildable version of GHC
17:59:50 <SamB> oh, no idea
17:59:57 <dibblego> what exactly does INLINE do to a function in the way that GHC refers to it?
18:00:08 <SamB> I suspect it's a "bug"
18:00:37 <SamB> dibblego: it adds an InlineMe tag
18:00:41 <sorear> ndm_: -O2 now uses -fasm, yes; according to the benchmark suite, ghc -O2 -fvia-C is a mere 3% faster than ghc -O2 -fasm
18:00:47 <dibblego> SamB, what's that do?
18:00:50 <ndm_> sorear, 3 seconds vs 8 seconds
18:01:00 <dons> sorear: and on 64 bit, you usually win with -fasm
18:01:18 <SamB> dibblego: makes GHC far more likely to inline it
18:01:22 <sorear> ndm_: identical code gives you 3s with -fvia-C and 8s with -fasm on the same compiler version?
18:01:23 <dons> http://www.cse.unsw.edu.au/~dons/nobench/x86_64/results.html
18:01:23 <lambdabot> Title: nobench: Haskell implementation shootout
18:01:38 <dibblego> SamB, yes but what does "inline" mean exactly? GHC documentation says inline a lot - but never quantifies it
18:01:47 <ndm_> sorear, no, GHC 6.6.1 vs 6.7 (6 days ago)
18:01:54 <SamB> dibblego: oh, that ;-)
18:01:58 <dons> dibblego: the name is replaced with its body
18:01:59 <sorear> ndm_: and the CMM really is identical?
18:02:01 <dons> where is it used.
18:02:09 <sorear> ndm_: completely identical?
18:02:09 <ndm_> sorear, yes
18:02:14 <SamB> I thought everyone knew what that meant
18:02:19 <sorear> ndm_: -ddump-asm and diff that
18:02:22 <dibblego> dons, ah right, thanks
18:02:34 <oerjan> sorear: oh, i did not test runhugs, just from inside WinHugs
18:02:46 <sorear> ndm_: does forcing -fvia-C speed up 6.7?
18:02:48 <dons> dibblego: duplicates code, so generally only safe for pure code.
18:02:59 <dons> but can result in massive wins.
18:03:14 <ndm_> sorear, no, -fvia-C doesn;'t make it any faster
18:03:16 <dons> with ghc, you can inline / unfold into .hi files, giving you a poor-man's whole program compiler
18:03:37 <dibblego> dons, really, I am trying to interpret why myGlobalVar = unsafePerformIO (newIORef 17) has a NOINLINE pragma when the function seems to always return 17 to me http://haskell.org/hawiki/GlobalMutableState
18:03:38 <lambdabot> Title: GlobalMutableState - The Haskell Wiki
18:03:41 <sorear> dons: inlining is perfectly safe even with side effects.
18:03:55 <ndm_> sorear, not the kind of unsafe side effects that dons uses :)
18:04:02 <sorear> dons: the code is duplicated, but the number of executions stays the same
18:04:18 <dons> dibblego: right ,there you don't want to duplicate the newIORef.
18:04:39 <sorear> dibblego: Because when you use unsafePerformIO (newIORef x) you are violating the preconditions on unsafePerformIO.
18:05:05 <sorear> dibblego: GHC's optimizer relies on those preconditions, so when you break them, you have to partially turn it off.
18:05:15 <dibblego> I'll have to think about it some more, thanks
18:05:30 <SamB> sorear: I don't believe unsafePerformIO does that anymore...
18:05:33 <sorear> ndm_: also, #haskell is not a tracker.  everything you say here can and will be forgotten. :)
18:05:43 <dons> sorear: hehe, gcc manual: "Note that certain usages in a function definition can make it unsuitable for inline substitution.
18:05:45 <SamB> unless you use hs-plugins or something
18:05:46 <dons> Among these usages are: use of varargs, use of alloca, use of variable sized data types (see
18:05:48 <ndm_> should "how to improve GHC's optimiser" go to cvs or users ?
18:05:49 <dons> Variable Length), use of computed goto (see Labels as Values), use of nonlocal goto, and nested
18:05:52 <dons> functions (see Nested Functions)."
18:05:56 <ndm_> sorear, i'm just composing the emails about the stuff
18:06:04 <dons> ndm_: cvs?
18:06:11 <dons> i'd think, since that's where the hackers are
18:06:16 <SamB> ndm_: ... emails?
18:06:23 <SamB> @bug
18:06:23 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
18:06:32 <dons> sorear: i like how gcc uses 'unsuitable' for 'dangerous' ;)
18:06:49 <sorear> dons: actually it's more of a this-isn't-implemented thing, iirc
18:06:52 <SamB> dons: I think that that doesn't mean "dangerous"
18:07:06 <dons> some of those would be. some might just fail, yep
18:07:12 <sorear> dons: how?
18:07:15 <dons> the computed goto is interesting.
18:07:18 <SamB> but rather "would confuse GCC too much, so GCC won't inline functions that do them"
18:07:26 <dons> i wonder how that effects ghc's wide use of computed gotos
18:08:49 <ndm_> if its twice as slow, and is after the CMM, is it possible the manger is missing?
18:09:06 <ndm_> and how do i get the CPU/version info out of GHC that would be useful for a bug report?
18:09:22 <ndm_> ghc --version is fine, but i've no idea what the cpu in this thing is, beyond x86
18:09:59 <dons> the mangler would only be missing if it was built unregisterised
18:10:35 <ndm_> what else comes after CMM and could slow down by twice
18:10:40 <SamB> ah, finally, I'm getting internal type errors in JHC ;-)
18:10:46 <SamB> I like it ;-)
18:10:52 <dons> ndm_: gcc?
18:10:58 <dons> you mean, the cmm is much the same?
18:11:24 <ndm_> dons, identical
18:11:32 <sorear> ndm_: how big is the difference if you force both to -fasm?  if it's still big, try dumping the -ddump-asm output
18:11:35 <dons> best look at the asm then
18:11:47 <sorear> ndm_: Oh... is it the -ddump-cmm that is identical?
18:11:50 <dons> -keep-tmp-files will put .s files into your tmp dir.
18:12:01 <dons> is the cmm really identical? seems unlikely?
18:12:08 <sorear> ndm_: because for reasons unknown to me, -ddump-cmm is *before* the cmm optimizer
18:12:13 <SamB> isn't there a -keep-asm option?
18:12:20 <sorear> ndm_: you maybe want -ddump-opt-cmm ?
18:12:36 <sorear> SamB: Yes, but it's called -keep-s-files
18:13:24 <dons> the cmm optimiser is pretty light, though.
18:15:00 <sorear> ndm_: the mailing lists are also not trackers; rarely do they remember things for more than a week.  (beats an hour on irc though :) )
18:15:19 * SamB really wishes JHC had a much smaller "base" package
18:16:04 <shapr> @seen jyp
18:16:04 <lambdabot> I saw jyp leaving #xmonad, #oasis and #haskell 4d 10h 22m 35s ago, and .
18:16:07 <shapr> aww
18:16:13 <SamB> at least mailing lists are archived roughly by topic, though ;-)
18:16:28 <sorear> SamB: Use {-# OPTIONS_JHC -N #-} at the top of your files, explicitly import the Jhc.* modules you use, and pass the -ilib/base option to jhc.
18:16:45 <sorear> SamB: that way, you only compile the part of the stdlib you use :)
18:17:03 <ndm_> sorear, going through now - i can now 100% GUARANTEE that the CMM is IDENTICAL for the hot-spot function
18:24:19 <dons> ndm_: can you include the ghc flags you used?
18:24:29 <dons> -O2 I hope?
18:28:15 * SamB is trying to get jhc to correctly compile "foreign export succ :: Int -> Int" before he goes on to supporting non-pure foreign exports. on the theory that it will make him keep his types straight
18:30:53 * shapr laughs at some code in Cabal: " | verbosity >= deafening = print (path, args)"
18:31:19 <dcoutts> shapr: that's Igloo's recent verbosity changes :-)
18:31:35 <ndm_> dons, just -O2
18:31:38 <shapr> Brilliant use of significant names there.
18:33:30 <shapr> Is there a direct replacement for rawSystemVerbose ? I can't find anything in Distribution.Simple.* that returns the ExitCode
18:35:58 <dcoutts> shapr: no, we basically never use the ExitCode now, we use exceptions
18:36:13 <ndm_> i now have to make the difficult decision for supero, go with GHC's IO Monad and take a 10% performance hit, or keep being a bit unsafe
18:36:25 <shapr> dcoutts: Ah, ok.
18:37:15 <eivuokko> ndm, And it's too hard to keep both?
18:37:29 <ndm_> eivuokko, its a pain to keep both, yes
18:37:42 <ndm_> eivuokko, i'll at the least darcs tag before moving over
18:38:45 <SamB> wow that's a large module group...
18:39:19 <SamB> Determining Exports/Imports: [Data.Char,Data.Ratio,Foreign.C.String,Foreign.Marshal.Alloc,Foreign.Marshal.Array,Foreign.Marshal.Utils,Foreign.Ptr,Jhc.Inst.Read,Jhc.Inst.Show,Jhc.Tuples,Numeric,Prelude,Prelude.Float,Prelude.IO,Prelude.IOError,Prelude.Text]
18:40:10 <sorear> SamB: John does need to tidy his libraries a bit... :)
18:40:23 <sorear> that dependancy group simply doesn't finish on my machine
18:40:36 <SamB> I'm not even waiting for it to typecheck
18:40:40 <sorear> i gave it six hours of constant thrashing, to no avail
18:41:05 <sorear> ndm_: What versions (note plural) of GCC do you have?
18:41:38 <ndm_> sorear, any easy way of asking GHC to tell me?
18:41:42 <SamB> I think I could smooth it out a bit
18:41:48 <SamB> possibly
18:41:51 <ndm_> sorear, i.e. so i can get whatever GHC has found
18:42:09 <SamB> by breaking out the C types themselves into another module from Foreign.C.Types
18:43:59 <shapr> Yi should really use Cabal :-/
18:44:10 <SamB> in what module is () defined...
18:45:37 <SamB> lovely!
18:45:46 <SamB> now Jhc starts in a fraction of a second!
18:45:55 <SamB> instead of minutes!
18:46:18 * SamB pastes command line into test file
18:48:52 * shapr continues to try to build Yi
18:48:56 <ndm_> @index unsafeInterleaveIO
18:48:57 <lambdabot> System.IO.Unsafe
18:49:28 <shapr> aww, Unknown frontend: "--as=emacs"
18:51:01 * shapr cheers furiously!
18:51:34 <SamB> shapr: perhaps you have the wrong name and/or flag?
18:51:56 * shapr tries to convert his girlfriend to Yi
18:53:28 <sorear> shapr: jyp told me a while ago that cabal doesn't support yi's build process
18:54:01 <shapr> Luckily, I just uglyhacked Yi's Setup.hs to work with cabal 1.1.7
18:54:41 <chessguy> @where yi
18:54:42 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
18:54:59 <ndm_> sorear, same versions of GCC, 3.4.2 Mingw - although should have little bearing on -fasm
18:55:15 <shapr> How do I get syntax highlighting for Haskell in Yi?
18:55:43 * shapr boings cheerfully
18:55:50 <shapr> Yi!! um, Yay!
18:55:53 <chessguy> i still don't get yi. what would i get by using emacs as a front end to yi that i wouldn't get by just using emacs?
18:56:31 <shapr> chessguy: emacs is essentially an application written in elisp on top of an elisp interpreter written in C.
18:56:54 <shapr> chessguy: Yi is a dynamically reloadable Haskell application written in Haskell.
18:56:54 <chessguy> so...
18:57:05 <sorear> shapr: :set ft=haskell
18:57:23 <shapr> sorear: Doesn't work in emacs mode.
18:57:28 <dons> yi these days is a haskell app written in haskell on top of a haskell bytecode interpreter :)
18:57:48 <sorear> shapr: at least that's how it worked when I implemented highlighting - it's been many months since I touched the code
18:57:55 <shapr> Wow, I can tab complete any module.
18:58:09 <ndm_> thats enough pouring through CMM and GHC/IOBase, I'm off to bed - night!
18:58:16 <sorear> g'night!
19:00:14 <shapr> dons: Any idea how to get Haskell synhl in emacs mode?
19:01:36 <sorear> shapr: it was enabled by default, last I looked
19:02:09 <shapr> Not working for me
19:02:35 <chessguy> shapr, i just got it working on mine the other day
19:02:50 <chessguy> apart from yi
19:03:51 <chessguy> let me find my _emacs file
19:06:25 <chessguy> ok
19:06:40 <chessguy> i'll just paste my whole emacs file
19:06:42 <chessguy> !paste
19:06:43 <hpaste> Haskell paste bin: http://hpaste.org/
19:07:10 <shapr> Ah, I found the problem.
19:07:21 <hpaste>  chessguy pasted "for shapr" at http://hpaste.org/1565
19:07:37 <chessguy_> figures
19:07:51 <shapr> heh
19:09:17 <shapr> Hm, I'm still not getting haskell syntax highlighting in Yi.
19:10:06 <shapr> chessguy_: Oh, I know how to do haskell-mode in emacs, I'm trying to get haskell colorized in Yi.
19:10:54 * chessguy_ sighs
19:11:08 <chessguy_> you gotta at least give me an 'e' for effort (or emacs!)
19:11:17 <Korollary> I think the vty-yi doesn't do it. The gtk version does iirc.
19:12:29 <shapr> I'm using the gtk version, I wonder if my sourceview config is broken or something...
19:16:48 <Korollary> "1st International Workshop on Harnessing Theories for Tool Support in Software (TTSS.07)"
19:16:57 <Korollary> That's a mouthful
19:19:19 <shapr> Korollary: Are you able to get syntax highlighting in the gtk version of Yi?
19:19:54 <Korollary> shapr: No, I built the vty version
19:21:45 <shapr> ah
19:25:36 <shapr> Hm, is there some way to specify "-f gtk" in ~/.yi/YiConfig.hs ?
19:28:44 <shapr> Any idea how I evaluate Haskell code in the scratch buffer?
19:29:07 <Korollary> I didn't even know you could do that
19:30:35 <sorear> Korollary: I know for a fact that when I wrote yi's syntax hilighting engine, it *only* worked on vty.
19:30:54 <Korollary> The book Beautiful Code: Leading Programmers Explain How They Think is out.
19:32:21 <shapr> Is there a three line sourceview demo that should highlight Haskell source correctly?
19:45:04 <bos> oh dear. an increasing number of core libraries are starting to depend on the library splitup.
19:45:21 <SamB> bos: what?
19:45:37 <SamB> maybe cabal needs re-exports?
19:45:43 <bos> darcs HEAD of cabal requires the post-split-of-base library layout to build.
19:45:56 <dons> yeah :/
19:46:03 <dons> we should talk to Igloo
19:46:17 <dons> since libraries you might get via darcs shouldn't depend on things not on hackage
19:46:20 <bos> and i'm looking forward to ghc 6.8 greatly, but i want to use it when it's done, not now :-)
19:46:23 <shapr> heh
19:46:34 <SamB> there is no ghc 6.8
19:46:50 <bos> well, precisely.
19:46:55 <SamB> wow!
19:48:02 <SamB> I got a unicode character that ((a) my terminal doesn't support or (b) looks like a question mark in a box) from JHC
19:48:03 <Saizan_> @yow
19:48:03 <lambdabot> Uh-oh!!  I'm having TOO MUCH FUN!!
19:49:03 <shapr> Ok, I hacked the gtk ui to increase the font size, but I still don't have syntax highlighting, hmm.
19:54:21 <bos> i wonder if cabal configurations are supposed to help sort out the library versioning and splitup morass.
19:56:21 <chessguy> heh. he said morass. heh. heh.
19:56:49 <dons> bos, they should help with some things. conditional dependencies
19:57:00 <dons> stuff where we resort to separate .cabal files -- or even make, currently
19:57:32 <bos> right.
19:58:41 <bos> i feel very irresponsible, hacking on code instead of the book.
20:10:04 <blackdog> I'd like to protest the current fashion of mixed-case haskell project names
20:10:10 <blackdog> HAppS? HaXML?
20:10:14 <blackdog> WtF?
20:11:13 <SamB> I'm not familiar with that last one...
20:11:23 <Saizan_> HaXml, btw
20:11:24 <bos> it's related to SYB.
20:11:35 <bos> Whack That Framework.
20:11:51 <timthelion> first take a deep breath.  next, ask yourself is it really important? Finlay go start a non mixed case project to waste your time with.
20:12:00 <blackdog> Saizan_: ... yes. that's sort of what i mean.
20:12:04 <SamB> you want us to use all uppercase?
20:12:38 <blackdog> No, no. You can uppercase the first letter if you like. Standard English rules...
20:12:47 <Saizan_> BASE PARSEC REGEX-POSIX, omg what would that be? FORTH?!
20:12:51 <SamB> also, are you complaining about Cabal/GHC package names? or project names?
20:13:07 <blackdog> I'm mostly just having a whinge because i keep getting it wrong :)
20:13:18 <SamB> oh, so cabal package names!
20:13:32 <sioraiocht> (people actually say whinge/)
20:13:44 <bos> british english.
20:13:47 <sioraiocht> I know
20:13:48 <Saizan_> blackdog: it's just abbreviated camelcase, HAppS = Haskell Application Server
20:13:52 <sioraiocht> I thought it was outdated, anyway
20:13:57 <bos> not at all.
20:14:03 <blackdog> australian english, in this case
20:14:06 <sioraiocht> do you use whine as well?
20:14:08 <bos> americans merely forgot what a useful word it is.
20:14:09 <dibblego> people say whinge in Australiaall the time, so stop whinging about it
20:14:18 <blackdog> but we're just a more villainous version of british english, really...
20:14:34 <sioraiocht> you're a more villainous version of british anything, penal cology!
20:14:37 <sioraiocht> *colony
20:15:13 <sioraiocht> except imperialists, no one does that with more villainy than the british, except perhaps us Americans because we won't even own up to it
20:15:30 <blackdog> i'll cop to that. probably why we beat you at every sport ever - we know how to fight dirty :)
20:16:51 <mm_freak> minList' m (x:xs) = (minList' $! (if x < m then x else m)) xs
20:16:58 <mm_freak> isn't there any nicer syntax than if ?
20:17:38 <dons> :t minimum
20:17:40 <lambdabot> forall a. (Ord a) => [a] -> a
20:18:10 <mm_freak> dons: i know, i'm still practicing
20:18:10 <dons> :t find
20:18:14 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
20:18:32 <dons> > minimum . find (< 3) $ [10,7,3,2,0,9]
20:18:33 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Maybe a1'
20:18:40 <dons> > minimum . fromJust . find (< 3) $ [10,7,3,2,0,9]
20:18:41 <lambdabot>   add an instance declaration for (Num [a])
20:18:41 <lambdabot>     In the expression: 9
20:18:43 <dolio> What's not nice about if? The 'then' and 'else'?
20:18:53 <bos> drat, bytestring depends on cabal HEAD too.
20:18:56 <dons> you could wrap it as a 'cond' function, but if-then-else is ok.
20:19:03 <dons> bos, hmm, it does?
20:19:21 <mm_freak> dolio: i find C's ?:-operator more beautiful
20:19:29 <bos> yeah, cabal changed recentlyish so that it can suss out modules that are required to build, but not exposed.
20:19:37 <dolio> Ah. That's a little harder to do.
20:19:51 <bos> and the bytestring.cabal file no longer lists Data.ByteString.Fusion as a result.
20:19:51 <dons> mm_freak: you can define it though.
20:19:55 <dons> ah right
20:19:57 <bos> so the build borks with ghc 6.6.1
20:20:08 <bos> actually, the build succeeds, but for ungood reasons.
20:20:14 <mm_freak> yeah, just thought, there might be a built-in way
20:20:37 <dons> if-then-else is usually preferred
20:20:50 <mm_freak> yeah, i just need to get used to it
20:21:05 <dons> :-)
20:21:07 <sorear> bos: it's not hard to fix at all
20:21:09 <mm_freak> it looks confusing for someone coming from C, like me =)
20:21:23 <bos> sorear: not hard to fix? sure, i know, it's just adding an other-modules line.
20:21:26 <sorear> bos: s/base/base, pretty, directory/
20:21:31 <bos> etc.
20:21:55 <mm_freak> and to using min, minimum or find:  i don't want to use them for nowâ¦  i won't learn much using them
20:22:19 <bos> sorear: but it would be nice to have a stable, tagged version of Cabal, instead of a soup of darcs repos with local hacks
20:23:00 <sorear> > let x ? (a,b) = if x then a else b in (1 == 2) ? ('X', 'Y')  -- mm_freak: <<
20:23:03 <lambdabot>  'Y'
20:23:03 <dolio> > let b ? a = if b then Just a else Nothing ; a .: b = fromMaybe b a in (2 > 3) ? 'a' .: 'b'
20:23:06 <lambdabot>  'b'
20:23:46 <sorear> bos: Um... you really want to hack cabal to ignore pretty and directory depends?
20:24:01 <sorear> bos: the changes aren't in cabal.  they're in the libraries.
20:24:04 <bos> nonono. i want two different things.
20:24:23 <bos> 1. i want cabal to be tagged.
20:24:24 <mm_freak> sorear, dolio:  thanks, but i'll try to get used to if =)
20:24:26 <dons> ok, evil:
20:24:27 <Saizan_> > let b ? a = if b then const a else id in (2>3) ? 'a' 'b'
20:24:28 <dons> data Tuple a = a : a
20:24:28 <dons> infixl 0 ?
20:24:28 <dons> infixl 1 :
20:24:28 <dons> (?) :: Bool -> Tuple a -> a
20:24:28 <lambdabot>  Couldn't match expected type `t -> b' against inferred type `Char'
20:24:30 <dons> True  ? (x : _) = x
20:24:33 <dons> False ? (_ : y) = y
20:24:35 <dons> ;)
20:24:50 <sorear> dons: Evil, and syntactically invalid.
20:25:00 <dons> no no. should be valid.
20:25:02 <bos> 2. it would be nice if bytestring built with ghc 6.6.1, but i don't much care about that.
20:25:08 <dons>  import Prelude hiding ((:))
20:25:08 <sorear> dons: : isn't a valid identifier!
20:25:19 <mm_freak> dons: sorear's version is better anyway =)
20:25:20 <sorear> dons: import Prelude hiding ((:)) is a syntax error
20:25:23 <dons> it worked last time i checked. (in 2003)
20:25:36 <mm_freak> (?) x (a,b) = if x then a else b
20:26:38 <dons> oh , I wonder why it used to work.
20:26:53 <sorear> maybe you were using hugs back then?
20:26:57 <dons> ah, could be.
20:27:17 <mm_freak> hugs is faster than ghci, isn't it?
20:27:49 <dons> nope
20:28:08 <dons> http://www.cse.unsw.edu.au/~dons/nobench/x86_64/results.html
20:28:08 <lambdabot> Title: nobench: Haskell implementation shootout
20:28:08 <bos> it's faster to start up.
20:28:20 <dons> about twice as slow overall though
20:28:21 <sorear> and, iirc, faster to load modules.
20:28:31 <Alleria> oooh, very helpful.  Thanks dons
20:28:36 <sorear> but the computation is twice as slow
20:28:48 <mm_freak> k, then i'll stick with ghci
20:28:55 <sorear> so don't use it for long running programs (like, oh, benchmark suites :P )
20:29:00 <dons> nhc and yhc are a bit faster than ghci, but run less programs
20:29:52 <mm_freak> ok, thanks for now
20:30:42 <mm_freak> i'm reading "The Haskell Road to Logic, Math and Programming" by kees doets and jan van eijck
20:30:48 <mm_freak> pretty interesting book
20:30:49 <SamB> jhcc is even slower than *ghc* and runs *even less* programs ;-)
20:30:55 <SamB> er. jhc.
20:31:11 <sorear> But at runtime it's twice as {fast,slow} !
20:31:20 <dons> ah, but other than the hiding (:), that code is fine
20:31:31 <dolio> Yeah. Hello world runs really fast, though, right? :)
20:31:52 <sorear> dolio: Hello World runs instantly, but takes about 3m to compile
20:31:59 <timthelion> how does haskell execute? it seems that ghc outputs executable binaries, are those machine code, or is it packaging a virtual machine?
20:32:02 <chessguy> mm_freak, that's a good book, i liked it
20:32:04 <SamB> only 3m is it?
20:32:09 <dons> ah, but not in ghci: A.hs:5:16: Illegal binding of built-in syntax: :
20:32:15 <dons> hugs is fine with it. how interesting
20:32:25 <sorear> timthelion: techically both, but the VM is unused by most programs
20:32:46 <sorear> GHCi uses it, almost everything else doesn't
20:32:54 <timthelion> is ghc smart enough not to include it if it is unused?
20:32:56 <dons> Ternary> :t (?)
20:32:56 <dons> (?) :: Bool -> Cond a -> a
20:32:56 <dons> Ternary> 1 Prelude.< 2 ? "yeah" : "oh noes"
20:32:56 <dons> "yeah"
20:33:13 <sorear> timthelion: probably not, though ld might be
20:33:21 <chessguy> @src Cond
20:33:21 <sorear> timthelion: since the rts is statically linked
20:33:21 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
20:33:30 <chessguy> @hoogle Cond
20:33:31 <lambdabot> Language.Haskell.TH.CondE :: Exp -> Exp -> Exp -> Exp
20:33:31 <lambdabot> Language.Haskell.TH.condE :: ExpQ -> ExpQ -> ExpQ -> ExpQ
20:33:31 <lambdabot> Data.Graph.Inductive.Query.Monad.condMGT :: Monad m => (m s -> m Bool) -> GT m s a -> GT m s a -> GT m s a
20:33:33 <timthelion> are there going to be cpu's in the future that are designed for haskell?
20:33:45 <bos> no, those are the CPUs of the past.
20:34:19 <timthelion> what do you mean? I thought haskell was modern and inovative.
20:34:33 <sorear> timthelion: there doesn't appear to be much room for improvement between C CPUs and Haskell CPUs.  most of the stuff that looks promising (parallelism etc) turns out to be dead ends
20:35:01 <timthelion> really? hrmph
20:35:02 <sorear> timthelion: and the factor of 2x or so that you get from a Haskell-specialized CPU is offset by 1000x or so the cost
20:35:05 <dons> easier to let big chip companies masas-produce gpus, and multicore machines, and just target them
20:35:16 <dons> 'zactly.
20:35:32 <dons> they end up as FP cores in the limit anyway
20:35:57 <sorear> timthelion: once upon a time, nobody knew how to compile Haskell, and Haskell CPUs seemed smart, since they were much faster than the interpreters.
20:35:59 <dons> if you want to go fast, you've got do pure FP , even in hardware  -- look at the gpu
20:36:19 <sorear> but Augustsson and Johnsson changed all that
20:36:33 <SamB> dons: I thought that was also a matter of having no *need* to do anything else?
20:37:01 <dons> more a matter of what's feasible to do with 64 cores
20:37:03 <SamB> I mean shading is a naturally 100% pure process...
20:37:16 <dons> mutating shared state isn't one of those things
20:37:26 <blackdog> sort of amusing that imperative programmers have to go functional to get their next hit of Raw Blazing Speed
20:38:00 <sorear> Meanwhile, people in Other Channels have tried to convince me that pure OO (think Smalltalk) is the future of high performance computing.
20:38:46 <dolio> Because of run-time profiling/optimization?
20:39:11 <timthelion> only problem I see with haskell is that it's strict typing system leads to a certain lack of modularity.  I can't see how one would write say, a microkernel, in haskell
20:39:14 <sorear> Because object graphs have locality.
20:39:25 <sorear> @google L4/Haskell
20:39:29 <lambdabot> http://swik.net/l4+haskell
20:39:30 <lambdabot> Title: l4 haskell - SWiK
20:39:34 <araujo> timthelion, uh? ..... i think it actually helps for modularity of code.
20:39:37 <dons> timthelion: you've seen House or L4? the type system is used to enforce modularity
20:39:46 <dons> that's one the main benefits of strong typing and purity
20:40:06 <timthelion> then why isn't xmonad modular?
20:40:24 <SamB> timthelion: it's a module?
20:40:33 <dons> it is , for what we want it to be. StackSet is completely isolated, for example
20:40:54 <timthelion> but you have to recompile in order to add a layout algorithm.
20:41:03 <mm_freak> product' p (x:xs) = (product' $! (p*x)) xs   -- does this actually copy the list, or does it just pass the tail without copying (since it's already available)?
20:41:06 <dons> you mean extensibility? not modularity?
20:41:27 <dons> purity, in particular, means very strong separation of components.
20:41:39 <blackdog> mm_freak: that should just run down the spine
20:41:40 <timthelion> I guess,
20:41:42 <dons> you can test each piece in isolation, and reload things safely without worrying about breakages.
20:41:53 <sorear> timthelion: xmonad isn't run time extensible because the existing runtime extension systems are very big - xmonad's size would approximately quintuple
20:42:02 <mm_freak> _should_ or _does_?  in ghc/ghci
20:42:23 <timthelion> oh,
20:42:28 <sorear> mm_freak: it passes the tail without copying
20:42:35 <mm_freak> sorear: thank you
20:42:51 <SamB> dons: you can reload what things safely where?
20:42:54 <sorear> mm_freak: Haskell lists are linked lists, so you can have a pointer to every suffix
20:43:08 <timthelion> sorear: that will have to be fixed...
20:43:19 <mm_freak> sorear: that's what i was assuming, but i wasn't sure
20:43:27 <bos> dons: is running make in bytestring/tests supposed to work?
20:43:43 <dons> bos, it should with 'fps', not sure about 'bytestring'.
20:43:48 <sorear> timthelion: When I first suggested runtime extensibility to dons his reaction, iirc, was "Get away from me with that bloatware! :P"  I'm inclined to agree with him nowadays
20:43:49 <dons> it might depend on bytestring being installed
20:43:54 <sorear> timthelion: What will?
20:44:05 <bos> it seems to have bitrotted in the bytestring branch.
20:44:22 <bos> there's no longer a Base module, for example, but the very first test tries to use it.
20:44:26 <dons> bos, ok. perhaps use the fps stable branch then?
20:44:36 <dons> rather than our 'not for public consumption' bytestring repo
20:44:45 <dons> www.cse.unsw.edu.au/~dons/code/fps
20:44:46 <bos> heh, yeah.
20:45:04 <dons> the bytestring repo will be the standard one, but not till after fps is taken out of base, and we merge in the stream fusion code
20:45:10 <dons> and then it will be 6.6 or later only
20:45:11 <bos> yeah.
20:45:28 <dons> i created a page for ?: tricks, if anyone has something to add: http://haskell.org/haskellwiki/Ternary_operator
20:45:29 <lambdabot> Title: Ternary operator - HaskellWiki
20:45:51 <SamB> dons: are you implying that I can get a newer base for 6.6?
20:46:01 <dons> no.
20:46:11 <SamB> than how the heck would I use that?
20:46:17 <dons> SamB: btw, what library are you going to release this week?
20:46:19 <timthelion> sorear: someone will have to at some point write a very small runtime extensibility system.
20:46:26 <SamB> dons: I'm releasing a library?
20:46:50 <SamB> I thought I was working on Jhc's FFI this week
20:47:07 <dons> you should! my records indicate you've made 10552 statements in here. which means 5 libraries or tutorials you need to write and release this year.
20:47:20 <dons> sorear owes us 20. ;)
20:47:28 <SamB> some of those might have been questions
20:47:32 <bos> this peer pressure to release libraries isn't as effective as i'd hoped :)
20:47:40 <dons> yes :/
20:47:45 <Saizan_> i didn't know this was a pay for chat channel :D
20:47:45 <sorear> 2007.07.03.20.54.44 < dons> i'll go through the irc user's list, by most comments,
20:47:47 <SamB> and doesn't compiler hacking count for something?
20:47:47 <dons> 300 users, 1 library *a year*..
20:47:49 <sorear> 2007.07.03.20.54.55 < dons> and if they're not meeting their librari quota, they can get a kick
20:47:57 <bos> timthelion: simon peyton jones designed a cpu for running functional languages, a long time ago
20:48:00 <dons> we just need 1 library per person, per year, really.
20:48:07 <dons> and the 10 or so can do 2+ libs
20:49:05 <timthelion> dons: what if I want to do cool things instead, like writting extentions to xmonad?
20:49:45 <dons> that's ok, but you should then write a tutorial on what you did.
20:49:52 <dons> libraries would be better.
20:50:07 <dons> bos, but perhaps people need more guidance ?
20:50:23 <dons> if we are to get a decent conversion rate for haskell irc guy, to haskell library writer?
20:50:33 <dons> ideas welcome
20:50:38 <SamB> perhaps you should have a tracker
20:50:47 <timthelion> dons, no really, you don't want me to write tutorials,  I write bloatware.
20:51:01 <dons> timthelion: maybe port some things from lisp, to haskell?
20:51:05 <dons> given your lisp experience
20:51:18 <SamB> ... what ... things?
20:51:24 <dons> emacs?
20:51:55 <bos> autocad.
20:51:55 <timthelion> lol!
20:52:14 <dons> Arc?
20:52:14 <timthelion> at best, I'll port maxima
20:52:19 <bos> news.ycombinator.com
20:52:25 <dons> come on, Arc is like a 1 day task
20:52:31 <bos> see, lots of stuff has been written in lisp/.
20:52:33 <dons> and news.ycombinator is maybe 1 day too
20:52:33 <sorear> dons: I have a summer project, and I'd rather not release it next week :)
20:52:54 <dons> sorear: you need to churn out one lib a month i think, to meet quota
20:53:01 <timthelion> dons: one day for you maybe.  remember, I'm neither smart nor experienced
20:53:25 <dons> timthelion: you could start with 'write scheme in 48 hours' and instead implement Arc for PG
20:53:28 <bos> hey, i'm old and stupid, and i get by.
20:53:29 <dons> in haskell.
20:53:52 <timthelion> bos: but you are experienced
20:54:10 <dons> timthelion: you just have to dive in.
20:54:12 <SamB> dons: what do I have to do to count my ill-tested MACRO1 assembler implementation as a library?
20:54:23 <dons> it has to be tagged, and uploaded to hackage.
20:54:31 <SamB> it is actually a program though
20:54:48 <dons> programs are also allowed
20:55:05 <timthelion> do they have to be either gpl or bsd licenced?
20:55:08 <dons> at a minimum, you could port old haskell stuff to cabal, and upload it
20:55:21 <dons> there's lots of non-cabalised stuff that could easily be cabalised and uploaded
20:55:28 <dons> everything by Oleg. musasabi's stuff.
20:55:33 <dons> anything from the pre-hackage days
20:55:57 <timthelion> I thought cabal was evil.  it is like non-debian for no apparent reason.
20:56:05 <sorear> does it have to be written in haskell, or just haskell related?
20:56:16 <gravity> cabal works pretty well in debian ime
20:56:18 <dons> sorear: to go on haskell, it needs to be haskell+cabal
20:56:23 <dons> hackage.
20:56:27 <gravity> dh_haskell makes it insanely easy though
20:56:41 <dons> i uploaded musasabi's LZF binding, this morning, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Codec-Compression-LZF-0.2
20:56:43 <timthelion> gravity: but there's no hask-get install goodness.
20:56:45 <lambdabot> http://tinyurl.com/2oqgsa
20:56:51 <dons> timthelion: sure there is, cabal-install
20:57:16 <timthelion> hrmph why doesn't the xmonad readme say that for the 4 pre-reqs
20:57:29 <dons> its in beta testing.
20:57:53 <gravity> timthelion: A lot of libs are already in debian actually...
20:57:53 <timthelion> and the pre-reqs are too?
20:58:05 <timthelion> gravity: I know that.
20:58:09 <dons> timthelion: cabal-install is in beta testing.
20:58:10 <gravity> There's a few that aren't, but I suppose they could be easily packaged if you wanted.
20:58:23 <dons> yeah, we've got cabal2deb for that too
20:58:27 <gravity> I have packages for the sdl libs sitting around, waiting for me to upload them if I decide I can handle the extra package load
20:58:33 <timthelion> oh, ok
20:58:45 <dons> so, the question is: why *aren't* people writing libraries?
20:58:59 <timthelion> because they don't need them?
20:59:31 <Saizan> do we have a standalone irc library?
20:59:49 <dons> it might be nice, yeah.
20:59:51 <dgriffi3> not on hackage
20:59:51 <jre2> or we don't feel comfortable enough showing others our crappy code ;)
21:00:20 <timthelion> because we don't have utopian purist ideas of a new os?
21:00:41 <dons> Saizan: we don't have a standalone one. there's lambdabot's fairly isolated implementation, also used by hircules
21:00:54 <dons> and it would be *easy* to write a nice, fast bytestring/irc impl
21:01:00 <dons> Network.IRC please!
21:01:45 <timthelion> are there any editors that have haskell intelisence code compleation or the like?
21:01:45 <dons> do people feel they have all the resources to get started, if they did want to write a library?
21:02:00 <glguy> timthelion: like Visual Studio?
21:02:07 <timthelion> glguy: ya,
21:02:14 <glguy> There you go :)
21:02:27 <timthelion> on linux, open source?
21:02:48 <glguy> Visual Studio only runs on Windows to my knowledge
21:02:54 <timthelion> it does
21:03:12 <glguy> vim has autocomplete
21:03:20 <glguy> vim + hasktags might be close
21:04:07 <timthelion> hmm
21:04:23 <glguy> intellisense is a good crutch to try to avoid though
21:04:32 * timthelion doesn't like vim because of it's lack of customizabuility
21:04:43 <timthelion> how is it a crutch?
21:04:54 * sioraiocht doesn't like vim because emacs is BETTER.
21:04:55 <glguy> I mostly use my text editor for text editing, so I haven't had a problem with vim
21:04:58 <jre2> timthelion: perhaps you need more scripts in your .vim directory then
21:05:38 <timthelion> jre2: I spent an entire day failing to find a good way to change the bindings for dvorak
21:06:02 <glguy> that's something you do at the OS level
21:06:11 <glguy> or at minimum the GUI level
21:06:33 <timthelion> I do it with xmodmap but h j k and l are bad navigation keys on dvorak
21:07:20 <timthelion> I finally figured out how to do it on a second days search, but I never found any one really knowledgeable
21:07:35 <glguy> you mean to use :remap?
21:07:59 <timthelion> glguy: noremap
21:08:12 <glguy> right, the non-recursive one
21:08:35 <mm_freak> http://www.willamette.edu/~fruehr/haskell/seuss.html
21:08:36 <lambdabot> Title: Dr. Seuss on Parser Monads
21:08:36 <mm_freak> lol
21:08:53 <timthelion> which is in my opinion a bad way to do it. because your maping keys to keys, not keys to functions
21:09:59 <dgriffi3> you should be able to use <foo> I think
21:10:23 <glguy> regardless, the fact remains that you can remap :)
21:10:30 <glguy> its not something you should need to do every day
21:10:57 <glguy> but I don't care what editor other people use
21:10:59 <Saizan> is there any tutorial on handling exceptions? esp. in networking code, i tend to either ignore their existence or catch everything everywhere
21:12:35 <sorear> it's very very hard to do correctly.
21:13:38 <sorear> actually, it's a bit easier in the network case since you don't need to worry much about asynch exceptions
21:14:20 <sioraiocht> okay, why do arrows have kind * -> * -> * instead of *->*?
21:14:27 <sioraiocht> like, why is it Arrow a b c
21:14:29 <sioraiocht> and not just b c?
21:14:31 <sorear> because they take two types!
21:14:41 <sioraiocht> or sorry
21:14:47 <sioraiocht> it takes THREE types
21:14:48 <sioraiocht> right?
21:14:52 <sioraiocht> * -> * -> * -> *
21:14:54 <sioraiocht> ?
21:14:55 <sorear> no, Arrow takes one type.
21:15:00 <sioraiocht> orly?
21:15:09 <sorear> Arrow :: (* -> * -> *) -> PROP
21:15:23 <sioraiocht> harrumph
21:15:28 <sorear> it's a higher order type class :)
21:15:32 <sioraiocht> well that confuses me more, lol. *goes back to reading*
21:15:45 <sorear> it's not much worse than Monad
21:15:53 <sorear> Monad :: (* -> *) -> PROP
21:15:57 <sorear> Prop
21:16:08 <sorear> oops, didn't mean to return that
21:16:31 <sorear> it's made up syntax so neither is correct
21:17:42 <sioraiocht> is there an "I'm stupid, explain arrows" guide?
21:17:48 <sioraiocht> like all about monads for monads =)
21:18:22 <sorear> not really, mostly people get refered to the paper
21:18:29 <sorear> @google Generalizing monads to arrow
21:18:30 <lambdabot> http://www.haskell.org/arrows/biblio.html
21:18:30 <lambdabot> Title: Arrows: bibliography
21:18:32 <sorear> @google Generalizing monads to arrows
21:18:35 <lambdabot> http://wiki.ittc.ku.edu/lambda/Image:Hughes_Generalizing_Monads_to_Arrows.pdf
21:18:35 <lambdabot> Title: Image:Hughes Generalizing Monads to Arrows.pdf - Lambda Group
21:18:36 <Saizan> the wikibook page, maybe?
21:18:52 <Saizan> ?go haskell wikibook arrows
21:18:54 <lambdabot> http://en.wikibooks.org/wiki/Haskell/Understanding_arrows
21:18:54 <lambdabot> Title: Haskell/Understanding arrows - Wikibooks, collection of open-content textbooks
21:19:19 <Saizan> with robots included!
21:20:28 <thoughtpolice> robots in disguise?
21:22:08 <shapr> wheeee /shapr's gf takes charge of the keyboard
21:22:16 <sioraiocht> thansk
21:22:32 <sioraiocht> *wonders how he got into grad school*
21:22:40 <dons> hello shapr's gf :-)
21:23:07 <sioraiocht> okay
21:23:12 <sioraiocht> @type arr
21:23:15 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
21:23:31 <sioraiocht> *splutters* WHAT does that mean?
21:23:43 <shapr> hi dons, how are you?
21:23:59 <xpika> @type id
21:24:03 <lambdabot> forall a. a -> a
21:24:08 * sorear says hello too
21:24:09 <dons> i'm good :) how's shapr? behaving himself?
21:24:29 <shachaf> sioraiocht: Ignore the forall part.
21:24:54 <shachaf> sioraiocht: If a is an arrow, arr turns a function from b to cinto an arrow from b to c.
21:25:05 <sorear> sioraiocht: read it as: Arrow a => ((->) b c) -> ((a) b c)
21:25:08 <sioraiocht> okay
21:25:20 <sioraiocht> sorear: where though be in like, monad terms as like lifM2?
21:25:25 <sioraiocht> @type liftM2
21:25:29 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
21:25:37 <sorear> sioraiocht: Yeah, a lot like liftM2.
21:25:46 <sioraiocht> okay
21:25:52 <shapr> not really, but give me a few days and i'll have him whipped into shape
21:26:19 <sorear> sioraiocht: Arrows focus more on functions, while Monads focus on values.  So arr is as important to arrows as return is to monads.
21:26:47 <sorear> sioraiocht: conversely, returnA is a mere useful combinator, but no more special than liftM.
21:26:47 <sioraiocht> @src Arrow
21:26:48 <lambdabot> class Arrow a where
21:26:48 <lambdabot>     arr, pure   :: (b -> c) -> a b c
21:26:48 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
21:26:48 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
21:26:48 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
21:26:50 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
21:26:54 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
21:27:04 <dons> shapr: good! he needs a firm hand, or he'll run wild :-)
21:27:19 <dons> and don't let him get near a unicycle, or there'll be trouble
21:27:26 <shachaf> @src returnA
21:27:26 <lambdabot> returnA = arr id
21:27:53 <sorear> sioraiocht: You can ignore everything except arr, (>>>), and first.  The others are derived combinators, they're only there so you can override them if you're feeling performance-concious.
21:28:11 <shapr> dons: hah :D
21:28:15 <glguy> Does console based emacs have xterm mouse support?
21:28:34 <shachaf> glguy: Console based vim does, so I'd guess emacs would make it work.
21:28:45 <glguy> I use the mouse support in vim
21:29:02 <glguy> mostly to sit back and scroll with the mouse wheel :)
21:29:17 <sorear> glguy: you could try it.  emacs -nw clickity-click
21:29:57 <shachaf> Try xterm-mouse-mode?
21:30:02 <sorear> glguy: otoh, emacs people don't consider "works out of the box" particularly important, so if it DOESN'T work, you haven't learned anything.
21:30:03 <sioraiocht> sorear: so unlike monads, arrows wrap functions instead of values?
21:30:03 <shachaf> Sounds promising.
21:30:17 <sorear> sioraiocht: Yes, and that's the crucial difference.
21:30:41 <sorear> sioraiocht: Arrows are all about the things that have INPUT as well as output.
21:30:52 <sioraiocht> sorear: but aren't functions just values in haskell?
21:30:57 <sjanssen> idea: can we remove the warnings about greencard, c2hs, etc. from Cabal configure's output?
21:31:00 <sioraiocht> sorear: so...you could make any monad an arrow too, right?
21:31:01 <sorear> sioraiocht: You can make any Monad m into an arrow by considering a -> m b
21:31:07 <sjanssen> this seems to frighten newbies on a daily basis
21:31:38 <glguy> newbies don't flip out when ./configure doesn't find stuff... do they?
21:31:38 <sioraiocht> sjanssen: it must be late, because that made me giggle
21:31:40 <sorear> sjanssen: it's been in the cabal trac for as long as I can remember (not saying much I know :) )
21:31:56 <sioraiocht> glguy: been a while since you've dealt with newbies, huh?
21:32:02 <sorear> glguy: ./configure produces a blinding amount of output
21:32:10 <sorear> emphasis on blind
21:32:25 <glguy> ./configure tells me that I don't have a fortran compiler regularly :)
21:32:28 <sjanssen> glguy: they do
21:32:36 <sorear> sioraiocht: Yes.  but Monad *forces* you to use Haskell functions, which are opaque.
21:32:38 <SamB> okay, great...
21:32:51 <SamB> look at this type error and weep!
21:32:54 <sorear> sioraiocht: Arrows allow you to look inside them.
21:32:57 <SamB> eq: Types don't match:(bits32, int) bits32
21:32:57 <SamB>                                     int
21:33:13 <sjanssen> glguy: mailing list today: "Found that on hackage, downloaded and built OK. Lots of scary warnings about happy, greencard etc, not being found during configure, but let's go on."
21:33:14 <sioraiocht> sorear: I don't quite follow..
21:33:23 <sorear> SamB: don't you just love languages that curry inconsitantly :)
21:33:40 <edwardk> arrows let you implement any 'function-like thing' f a -> f b,   a -> m b,  (a,c) -> (b,c), as long as you could figure out a way to transform a pure function into a special case
21:33:42 <sorear> sjanssen: He obviously knew what to do! :D
21:34:00 <sjanssen> sorear: yeah, but some users aren't so brave
21:34:15 <SamB> now if I could only figure out how I'm *supposed* to marshall data in and out...
21:34:17 <sjanssen> seriously, how many Cabal packages actually use greencard?
21:34:25 <dons> none.
21:34:34 <dons> greencard is long dead.
21:34:39 <sjanssen> 'zactly
21:34:43 <glguy> can't spell none without one :)
21:34:44 <dons> c2hs or hsc2hs seem to have won the day.
21:34:46 <edwardk> so like a monad arrows let you lift things into them, but the only things you 'lift' are functions. its another kind of 'container that you can't get rid of'
21:34:51 <sjanssen> and how often do we use happy, or alex?
21:34:59 <dons> those are moderately useful
21:35:00 <sorear> SamB: Do you have any idea what will happen if dons finds out you have caml installed?
21:35:13 * glguy installed poly/ml today
21:35:14 <SamB> sorear: that was from JHC you ass
21:35:21 <dons> oh, SamB, can you test the SML/streams implementation for me then?
21:35:24 <sjanssen> dons: sure, but they aren't used so often that we need to see the warning during each configure
21:35:36 <dons> right. it should be something like: tool-depends: Happy, Alex
21:35:42 <dons> that then trigger tests for them
21:36:01 <dons> ?bug
21:36:01 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
21:36:03 <SamB> sorear: or did you really think that was an ML type error?
21:36:12 <sjanssen> I don't care if the tests always run, I'm saying we don't need to see the messages every time
21:36:17 <dons> yeah
21:36:29 <dons> a lot of people seem to give up when they see those warnings.
21:37:18 * glguy wonders if the kind of people that move on after such an error are the kind that write libraries :)
21:38:02 <SamB> sorear: in case you didn't guess, those are almost-to-C types
21:38:06 <sorear> SamB: I really did.  ML uses the name int for Int and bits32 for Word32 (an easy mixup) and the second part looks like a currying error (ucders
21:38:14 <sorear> tandable for a ML-ing haskeller)
21:38:59 <dons> glguy: they might be the kind that build libraries though
21:39:04 <dons> or xmonad.
21:39:08 <SamB> that error concerns this code fragment
21:39:10 <SamB> succ :: int â int
21:39:10 <SamB> succ :: fullCheck: let x6â·Int = Int# x4; in Jhc.Enum.succ x6
21:41:01 <SamB> unfortunately it seems that Int#::bits32 -> Int
21:41:09 <SamB> not Int#::int -> Int
21:41:24 <sorear> what's succ?
21:42:35 <SamB> that's actually a Name in the FfiExportName namespace
21:44:40 <Heffalump> morning all
21:46:20 <sorear> morning
21:46:47 <dons> morning Heffalump
21:47:27 <sioraiocht> Heffalump: Western Europe?
21:47:53 <Heffalump> yes, UK
21:48:07 <Heffalump> (which depending on your point of view is part of Western Europe or not :-)
21:48:24 <sioraiocht> oh, then you're up quite early
21:48:41 <Heffalump> yeah, I get up for work this early every day :-/
21:48:53 <Heffalump> sorear: did you hear any more about that type soundness bug?
21:49:09 <sioraiocht> Heffalump: Most people I ask over there (usually English) insist that Great Britain is NOT a part of Europe ;)
21:49:09 <jre2> is there a proper place to put up example code of how to do something, or should I just make a quasi-tutorial out of it?
21:49:29 <dons> jre2: you can put up examples on the wiki
21:49:30 <sorear> Heffalump: Yes.  I *think* it was CC'd to you, let me check...
21:49:44 <dons> jre2: you can then elaborate on it, to form a tutorial
21:49:46 <Heffalump> I didn't add myself to the bug, I should do.
21:50:14 <dons> jre2: an example, http://haskell.org/haskellwiki/Concurrency_demos/Simple_producer_and_consumer
21:50:17 <lambdabot> Title: Concurrency demos/Simple producer and consumer - HaskellWiki, http://tinyurl.com/3bto52
21:50:39 <jre2> dons: ahah, I knew there was somewhere but apparently I'm too tired to notice the Example_code page on the wiki
21:50:49 <dons> oh, example code is not so much about demos
21:50:58 <sorear> Heffalump: http://members.cox.net/stefanor/468CB76C.8020605@cse.unsw.edu.au
21:51:05 <dons> http://haskell.org/haskellwiki/Category:Code
21:51:06 <lambdabot> Title: Category:Code - HaskellWiki
21:51:11 <dons> the 'Code' category is though
21:51:26 <jre2> alright, thanks
21:51:34 <sorear> the code on the wiki is not necessarily the kind you want to write.
21:51:39 <Heffalump> that claims to be an audio/basic object
21:52:00 <SamB> @tell JohnMeacham that lookupCType and lookupCType' seem to return different types :-(
21:52:00 <lambdabot> Consider it noted.
21:52:07 <shapr> Hey, my keyboard was taken over!
21:52:08 <sorear> that's the rest of the world's fault for not following UNIX magic number conventions :D
21:52:20 <sorear> I'll rename it
21:52:22 * Heffalump wgets isntead
21:52:42 <Heffalump> it sounds like your webservers fault, Firefox isn't stupid enough to infer based on extension, I hope
21:53:15 <sorear> same url but add .txt
21:53:38 <Heffalump> ta (wgot it now anyway)
21:54:45 <sorear> .au should be text/aussie-english in any reasonable mime-types file
21:54:47 <sorear> :)
21:54:49 <Heffalump> interesting, it seems unclear what he wants to do about it.
21:54:51 <Heffalump> ;-)
21:55:27 <Heffalump> having an inconsistent set of axioms in Core sounds rather dangerous
21:55:37 <SamB> hmm?
21:55:42 <SamB> inconsistant axioms?
21:56:12 <Heffalump> http://hackage.haskell.org/trac/ghc/ticket/1496
21:56:14 <lambdabot> Title: #1496 (Newtypes and type families combine to produce inconsistent FC(X) axiom se ...
21:56:31 <Heffalump> the new core language is parametrised over an underlying axiom set
21:56:47 <Heffalump> the axiom set being the thing that tells you what type equality coercions are allowable and what aren't
21:56:53 <SamB> sure
21:56:59 <SamB> what is "inconsistancy" in that?
21:57:10 <sorear> when you can prove Int = Bool :)
21:57:10 <sioraiocht> okay I'm stumped, how to you define second in terms of first, arr, and (>>>)...anyone?
21:57:29 <sorear> or better yet HTrue = HFalse
21:57:30 <Heffalump> sorear noticed that the combination of having newtypes be equivalent to their underlying type, and having type families, generates an inconsistency where you can "prove" anything ~ anythingelse
21:57:47 <SamB> ah.
21:57:50 <dons> 10:58 @Chilli> I tend to blame it on newtype deriving at the moment
21:57:51 <SamB> true.
21:58:04 <Saizan> sioraiocht: hint: second f = swap >>> first f >>> swap
21:58:16 <Heffalump> I agree with that
21:58:19 <sioraiocht> orly?
21:58:35 <edwardk> and you need newtypes to be ~ their underlying rep to do all the deriving magic and just plumb them around for free right?
21:58:36 <sorear> me too.  newtype deriving is a very powerful tool for letting users throw sharp object at core lint
21:58:39 <Heffalump> since the newtype deriving implementation doesn't actually try to generate valid haskell code that would do it
21:59:21 <Heffalump> if you removed it, or restricted it to things the compiler could generate source for, I guess you could also remove the axiom, and thus the inconsistency
21:59:22 <sorear> granted, core lint should be able to take it, but I wouldn't object to the window being closed as well
21:59:27 <Saizan> sioraiocht: for a suitable swap, that you can implement with arr
21:59:53 <Heffalump> edwardk: right.
21:59:55 <dons> yeah, core lint needs beefing up
22:00:03 <SamB> Heffalump: but how would you coerce between the newtype and the oldtype without the axiom?
22:00:10 <sioraiocht> thanks
22:00:29 <sorear> Heffalump: We could add a new type of coercion that can't be composed
22:00:33 <Heffalump> SamB: you wouldn't. You'd just generate the explicit functions at the Haskell level
22:00:37 <sorear> Heffalump: so it's only usable at top level
22:00:48 <SamB> Heffalump: ... what?
22:00:58 <sorear> Heffalump: then what, use unsafeCoercezh to implement them?
22:01:04 <Heffalump> sorear: does FC allow multiple kinds of coerce, then?
22:01:34 <sorear> Heffalump: It only has one, but there doesn't seem to be any fundamental reason we couldn't add more.
22:01:52 <Heffalump> sorear: I guess so. Your solution is much more attractive if possible.
22:02:15 <edwardk> any solution is made more attractive by being possible ;)
22:02:30 <SamB> sorear: does it really need a new kind?
22:02:39 <SamB> wait, you said type
22:02:45 <SamB> does it *also* need a new kind?
22:02:54 <sorear> SamB: type is a very overloaded word :)
22:03:22 <sorear> SamB: Yes, it needs a new kind, because FC(X) coercions operate at the type level and their validity is checked using kind checking.
22:03:27 <Heffalump> especially since the FC paper treats the coercions as types with a kind.
22:03:37 <SamB> ah.
22:04:03 <SamB> so we need a new *kind constructor* for coercions
22:04:12 <sorear> yes.
22:04:23 <sorear> we have a kind constructor CO already
22:04:29 <edwardk> so its just the families that cause this right since they are the only thing that can change representation based on a tag? what if you disallow distinct newtypes of a type to be used in discriminating families? i.e. if there exist a chain of newtypes such that foo ~ bar via the newtype relation then you disallow the use of foo and bar as instances of the family
22:04:33 <SamB> ... do coercions now need a *sort*, too?
22:04:45 <gravity> Is there a way to pattern match two items at a time in a list comprehension? Like "[(first, second) | first:second <- mylist]"?
22:04:55 <SamB> edwardk: that would... um... negate the point of newtypes?
22:05:05 <edwardk> samb: only when used with data families
22:05:12 <SamB> edwardk: or data families
22:05:14 <SamB> take your pick
22:05:17 <Heffalump> oh yes, the other possibility would be changing the kind of type family constructors
22:05:39 <sorear> SamB: CO :: |~| kind :: [] . |~| ty1 :: kind . |~| ty2 :: kind . KIND
22:05:46 <edwardk> well, data families are still useful if you can't have Int and newtype MyFancyInt = MyFancyInt Int both be instances
22:05:53 <SamB> edwardk: not really
22:06:01 <dons> gravity: hmm, no, unless the list is a list of lists.
22:06:01 <Heffalump> edwardk: that'd be horrible, design wise
22:06:04 <edwardk> yeah
22:06:08 <dons> gravity: what are you trying to extract?
22:06:09 <Heffalump> the whole point of newtype is that it's not an alias
22:06:12 <dons> each pair?
22:06:22 <SamB> I would just not bother with type families if they were neutered like that
22:06:28 <gravity> dons: Yeah. I suppose I could unzip the list and use that?
22:06:29 <sorear> edwardk: The only reason data families are broken is that I understand them.
22:06:43 <gravity> hrm, or not
22:06:52 <SamB> sorear: are you implying that fundeps would be broken, too, if you understood those?
22:07:00 <sorear> SamB: exactly.
22:07:04 <edwardk> so you want to maintain the first-class nature of newtypes as 'real types' and their ability to interact with data families
22:07:11 * SamB isn't sure he buys it
22:07:24 <SamB> since fundeps don't interact with newtypes like that
22:07:43 <Heffalump> but fundeps do let you do type-based matching, effectively
22:07:49 <Heffalump> they're just rather more confusing
22:08:02 <SamB> can we translate this bug into fundeps?
22:08:17 <dons> Prelude Data.List> let f (a:b:rest) = (a,b) : f rest ; f [] = [] ; f [a] = [(a,a)]
22:08:21 <dons> Prelude Data.List> f "haskell"
22:08:23 <Heffalump> sorear: did you try already?
22:08:23 <dons> [('h','a'),('s','k'),('e','l'),('l','l')]
22:08:26 <dons> ?
22:08:35 <Heffalump> there's an obvious translation, dunno if it'd actually work
22:08:46 <gravity> cooooool
22:09:14 <gravity> dons: Thank you!
22:09:31 <sorear> Heffalump: I've tried several times to use various combinations of incoherent instances and separate compilation to break fundeps, but I haven't tried with generalized newtype deriving, no.
22:10:01 <sorear> which reminds me
22:10:09 * SamB upgrades severity to critical
22:10:50 <sorear> class Foo a b | a -> b ; instance Foo Int Bool ; instance Foo Int Char  -- I've seen (something very like) this accepted by ghc.  What gives?
22:10:51 * SamB prepares to be educated on the exact meaning of "unsound" wrt typesystems
22:11:08 <sorear> SamB: "Doesn't do what you thought it did" :P
22:11:22 <Heffalump> "allows code that segfaults" is a pretty good instance of that
22:11:28 <SamB> okay then ;-)
22:11:48 <dons> SamB: you should probably add yourself to the CC list, rather than upgrading severity -- which is more SPJ or ChilliX's job
22:12:03 <SamB> Heffalump: you mean... allows code that segfaults without the appropriate type
22:13:29 <ChilliX> sorear: I am currently of the opinion that it is newtype derivings fault that you can produce a segv
22:14:02 <sorear> ChilliX: Yeah.  I accept that.
22:14:09 <ChilliX> it derives a function at a type that IMHO by parametricity should not have any *terminating* inhabitants
22:14:31 <sorear> ChilliX: The deal is, when I first discovered the true power of newtype deriving, it gave my type lambdas.
22:14:42 <ChilliX> Actually I think you should be able to rewrite your example to use GADTs instead of data families
22:14:49 <sorear> ChilliX: And I've been VERY reluctant to let them go.
22:15:02 <sorear> ChilliX: GADTs won't quite work for this, because they have tags
22:15:19 <ChilliX> doesn't matter
22:15:42 <sorear> ChilliX: so if GADT inference messes up, you get a incomplete case error.  if AT inference messes up, you get a segfault.
22:15:45 <SamB> ChilliX: his example *does* something?
22:16:23 * sorear cries over losing his type level lambda abstractions
22:16:39 <sorear> (not really of course)
22:17:08 <SamB> so is the real bug that newtype derivings are still not formally specified?
22:17:08 <edwardk> sorear: what were you doing anyways?
22:17:29 <Heffalump> trying to break the type system, I thought :-)
22:17:30 <sorear> edwardk: what do you mean?  when I stumbled on this?
22:17:34 <edwardk> yeah
22:17:39 <sorear> what Heffalump said
22:17:40 <edwardk> the type lambda stuff you just mentioned
22:17:52 <sorear> I like scheming
22:17:52 <edwardk> heh
22:17:53 <ChilliX> SamB: ?
22:18:27 <ChilliX> sorear: you could have used data instance instead of newtype instance in your example
22:18:34 <SamB> hey, there's a bug #1251
22:18:39 <SamB> http://hackage.haskell.org/trac/ghc/ticket/1251
22:18:41 <lambdabot> Title: #1251 (GADTs with newtype deriving can crash GHCi / cause Core Lint to fail) - G ...
22:18:51 <ChilliX> breaks in essentially the same way (of course the FC derivation changes)
22:18:59 <ChilliX> SamB: oh
22:19:16 <SamB> is that what you meant about GADTs?
22:19:20 <sorear> SamB: Yes.  GHC could have survived that one.  it didn't have a chance against #1496
22:19:43 <sorear> GADTs were my first attempt to extract full type lambdas, once I realized I could have them
22:20:02 <sorear> then GHC crashed and I honestly wasn't expecting it
22:20:22 <sorear> eventually I figured out I could use leibnitz equality witnesses instead
22:20:31 <ChilliX> hmm, but that is resolbved
22:20:38 <sorear> and I *did* realize my goal of type lambdas in GHC
22:21:11 <sorear> then I decided I could use them to attach fundeps
22:21:12 <hpaste>  SamB pasted "7.4.12. Generalised derived instances for newtypes" at http://hpaste.org/1566
22:21:30 <sorear> then I found out about ATs, and decided they'd be easier to crach
22:21:33 <sorear> *crack
22:21:36 <SamB> hmm. hpaste needs work.
22:22:00 <sorear> yeah
22:22:22 <SamB> anyway, that isn't *nearly* long enough to be a formal specification of generalized newtype deriving !
22:22:30 <sorear> I'm pretty sure something broke in happs, though I only have 3 data points
22:22:34 <shapr> d00d
22:22:42 <sorear> kakapo, stable happs: works
22:22:49 <sorear> stefans, devel happs: doesn't
22:23:08 <sorear> stefans, devel happs, hacked: doesn't (but no worse than before)
22:23:11 <SamB> sorear: I meant, it would be nice if it could word-wrap in case of english
22:23:26 <sorear> kakapo, devel happs, hacked: doesn't
22:23:43 <sorear> hakapo, devel happs, hacked, proxied by apache: doesn't and quite badly
22:24:42 <sorear> SamB: yeah, well I hadn't dumped my datapoints on shapr yet :)
22:25:18 <SamB> how is that three datapoints
22:25:27 <SamB> it looks like *five* to me
22:28:13 <mm_freak> i see
22:28:21 <mm_freak> you cannot shoot yourself in the foot with haskell
22:28:27 <mm_freak> it's would be a destructive update
22:28:31 <mm_freak> -'s
22:29:17 <SamB> mm_freak: well, you can, if you work at it
22:30:03 <mm_freak> hmm
22:30:08 <sorear> aww, crumbs... you can't break the type system with functional dependencies as I know tham
22:30:09 <mm_freak> leftfoot = shoot rightfoot
22:30:38 <SamB> sorear: what you can break is your head
22:31:05 <scook0> mm_freak: unsafePerformIO $ shoot foot
22:31:06 <scook0> :)
22:31:13 <sorear> SamB: my HEAD is already broken
22:31:26 <SamB> no, that thing with your brain in it
22:31:37 <mm_freak> scook0: that's unsafeâ¦  and it hurts
22:31:58 <SamB> or actually you could just write main = shoot foot
22:32:43 <mm_freak> samb: but that's not `foot' itself
22:33:31 <SamB> or perhaps
22:33:32 <sorear> wait... I've seen code in lambdabot just like the code I just decided couldn't be written
22:33:35 * sorear vis
22:33:42 <SamB> main = getFoot >>= shoot
22:34:12 <mm_freak> still not the same thing getFoot returned
22:34:29 <sorear> shoot :: Foot -> IO ()
22:34:41 <sorear> or Kleisli IO Foot (), if you prefer
22:35:28 <mm_freak> you'd end up copying the universe where in the copy you shoot your self in the foot
22:35:40 <mgsloan>     Couldn't match expected type `IO Foot'
22:35:40 <mgsloan>            against inferred type `FootSpecifier -> IO Foot'
22:35:40 <mgsloan>     In the first argument of `>>=', namely `(getFoot)'
22:36:29 <SamB_XP_> mgsloan: hahahaha
22:36:54 <mgsloan> :)
22:37:27 <mm_freak> you can calculate what would happen if you shoot yourself in the foot, but you can never actually do it
22:37:52 <mm_freak> otherwise your foot would be bottom
22:37:55 <mm_freak> foot = shoot foot
22:38:01 <sorear> Would someone who understands dysfunctional dependencies please help me to use them in the name of Chaos?
22:38:32 <SamB_XP_> sorear: I've never even heard of *those*
22:38:48 <mgsloan> yeah, I only vaguely know fundeps
22:39:55 <mgsloan> I know they have more restrictions on them than they should, that really the new family data/synonyms stuff should be used, and that ghc implements them internally in this way
22:40:47 * sorear goes on trac to look for the evidence of the early days when GHC implemented fundeps much worse
22:41:08 <SamB_XP_> sorear: I don't think trac has been up that long?
22:41:19 <sorear> SamB_XP_: Fundeps aren
22:41:24 <mgsloan> well, maybe they 'should' have the restrictions they do, but they are pretty awkward
22:41:29 <sorear> 't that old.  IIRC they were *proposed* in 2000
22:41:49 <SamB_XP_> but how long has GHC had a trac?
22:42:36 <sorear> Ticket #1 'Opened 6 years ago'
22:43:03 <SamB_XP_> really?
22:43:56 <sorear> Heffalump: How does one do the fundep <-> AT mapping?  what paper should I consult?
22:47:21 <mgsloan> as far as type families, the dependent types just become members, i think..
22:47:29 <mgsloan> probably not what you're asking though
22:48:34 <sorear> yeah.  I want to go the other way
22:53:24 <dons> sorear: the Fc paper, I think?
22:53:36 <sorear> ty
22:54:28 <dons> see also Technical Report UNSW-CSE-TR-0624
22:54:31 <sjanssen> fundeps are more general than ATs, yeah?
22:54:58 <sjanssen> class Crazy a b | a -> b, b -> a
22:56:27 * mgsloan would think that the second fundep would be redundant
22:56:50 <mgsloan> err
22:56:52 <mgsloan> nevermind
22:57:29 <sorear> Somebody needs to compile a list of all the papers required to understand fundeps
22:58:14 <mgsloan> I probably don't understand them, because they seem pretty simple
22:58:49 <mgsloan> just a statements about the type variables being uniquely determined by others
22:59:03 <sorear> I suspect just reading every ML post ever by oleg might make it click :)
22:59:27 <mgsloan> oleg's generic zipper posts are crazy cool
22:59:39 <Saizan> i think it's more a matter of "what can i do with them?" or  "how do i express X?"
23:00:58 <dons> sorear: or you might go insane
23:01:56 <dolio> Oleg's addition predicates seem like they'd be difficult to express with ATs, too.
23:02:07 <sorear> functional dependancies don't determine types.  they determine instances.
23:02:08 * sorear has a total-perspective moment
23:02:20 <dolio> class Add a b c | a b -> c, a c -> b, b c -> a
23:02:42 <dolio> So you can put in any two and get the third out.
23:03:00 <mgsloan> yeah, they constrain the instances.  you can't have an instance of dolio's Add with the same a and b as another
23:03:14 <SamB_XP_> when is it prevented?
23:03:17 <mgsloan> seems like a pretty damn strict add
23:03:24 <mgsloan> I dunno
23:03:30 <mgsloan> compile time
23:03:38 <SamB_XP_> that's an implementation detail, though...
23:03:52 <mgsloan> same way that duplicate instances are normally dealt with
23:03:57 <Syzygy-> "Halt! Compile time!"
23:04:52 <mgsloan> /me's add would look like:
23:04:52 <mgsloan> class Add a b c | a b -> c where (+) :: a -> b -> c
23:04:57 <dolio> I haven't looked at ATs much, though. Maybe there's a way to do it.
23:05:28 * mgsloan doesn't know what AT stands for
23:05:34 <dolio> mgsloan: The one with the three FDs is for type-level arithmetic.
23:06:00 <mgsloan> hmm
23:06:50 <dolio> So you'd have 'instance Add Zero a a' 'instance Add (Succ a) b (Succ b)' or something like that.
23:07:04 <mgsloan> ahh!
23:07:32 <dolio> And apparently it works like a predicate in prolog due to the 3 functional dependencies.
23:07:52 <dolio> So you could have 'Add Three n Five' as well as 'Add Three Four m'
23:07:59 <mgsloan> cool
23:08:21 * sorear closes his eyes, humms, and forgets what functional dependancies are...
23:09:46 <dolio> http://okmij.org/ftp/Computation/resource-aware-prog/BinaryNumber.hs
23:09:48 <lambdabot> http://tinyurl.com/32qhec
23:09:51 <dons> Thu Jun 28 21:32:46 PDT 2007  Roman Leshchinskiy <rl@cse.unsw.edu.au>
23:09:51 <dons>   * Add -fvectorise
23:09:54 <dons> :D
23:10:00 <sorear> BAM!
23:10:17 <sjanssen> ooh
23:10:18 * sorear is crushed under a pile of RL commit notices
23:10:35 <dons> Tue Jul  3 22:52:39 PDT 2007  Roman Leshchinskiy <rl@cse.unsw.edu.au>
23:10:36 <dons>   * Vectorisation of types
23:10:45 <SamB_XP_> sorear: that bad?
23:10:54 <SamB_XP_> dons: wth does that do?
23:11:14 <dons> its the transform for parallel arrays, iirc
23:11:21 <sorear> SamB_XP_: So bad exim went into loop avoidance congestion shutdown.  I just had to manually restart it.
23:11:27 <dons> spotting calls that need to run in parallel, when working with such arrays
23:12:22 <SamB_XP_> sorear: I was talking about fundeps
23:12:38 <sorear> SamB_XP_: Yes.  Fundeps are that bad.
23:12:54 <sorear> for all values of that.
23:13:20 <sorear> eg, they killed my great-grandmother
23:20:25 <tga> howdy
23:20:47 <dons> hey tga
23:26:09 <bos> ok, basic packed utf-32 support works. whew.
23:29:46 <dons> cool. you'll want to reuse the quickcheck, and perforamnce benchmarks
23:30:48 <ChilliX> dolio: We can translate any FD program into an AT program, in fact the plan is to implement FDs in GHC by ATs.
23:31:09 <ChilliX> dolio: Would be silly to have both at the same time
23:32:16 <glguy> bos: is that in darcs? public?
23:33:16 <sjanssen> ChilliX: how  might "class C a b | a -> b, b -> a" be encoded in an AT?
23:34:18 <ChilliX> class (F1 a ~ b, F2 b ~ a) => C a b where
23:34:36 <ChilliX>   type F1 a
23:34:41 <ChilliX>   type F2 b
23:35:00 <ChilliX> every FD arrows becomes one AT
23:35:12 <ChilliX> the FD spec moves as equality constraints into the superclass context
23:35:41 <sorear> ChilliX: Can the reverse be dons, embedding AT programs in FD?
23:35:55 <ChilliX> no
23:36:05 <ChilliX> you can have type families without any classes
23:36:12 * sorear is writing his reply to the bug...
23:36:14 <ChilliX> but not FDs without classes
23:36:46 <ChilliX> strictly speaking you could introduce new class for all toplevel type families, but you get in trouble when they appear in data declarations
23:42:17 <dfranke_> hpaste.org seems to be hanging.
23:42:37 <dfranke_> Help please: http://dfranke.us/Saveable.lhs
23:43:51 <sorear> dfranke_: hpaste.org:8000 works, though
23:44:07 <sorear> dfranke_: something broke and the newest hpaste/happs is incompatible with mod_rewrite
23:44:39 <dfranke_> that's not working for me either...
23:44:59 <dfranke_> anyhow,  http://dfranke.us/Saveable.lhs is what I'm trying to paste.
23:45:27 <SamB_XP_> ChanServ: type families without classes still count as ATs?
23:45:35 <SamB_XP_> er.
23:45:38 <SamB_XP_> ChilliX:
23:46:02 <ChilliX> well, ATs are just syntactic sugar for type families
23:46:15 <ChilliX> its convenient to place them in classes
23:46:21 <ChilliX> but really there is no reason to
23:46:32 <ChilliX> fundamental reason, that is
23:48:19 <ChilliX> (btw time they get into the .hi file that's actually quite clear, as the type instances are floated out of the classes instances)
23:48:48 <ChilliX> I see the association of type families with classes as a software engineering issue
23:49:19 <ChilliX> It's like saying, whenever you make an instance for that type class, please also supply instances for the associated type families
23:49:36 <SamB_XP_> its not like saying "please"
23:49:43 <SamB_XP_> at least I sure *hope* not
23:49:47 <ChilliX> Oh, it is saying, please
23:50:01 <ChilliX> like members, you can omit associated family instances
23:50:08 <SamB_XP_> ... what happens when you do that?
23:50:18 <SamB_XP_> the typechecker crashes?
23:50:26 <ChilliX> well, the only inhabitant of those types is "undefined"
23:50:31 <SamB_XP_> ah.
23:50:33 <ChilliX> like if you declarate an empty data type
23:50:35 <SamB_XP_> okay, that's not so bad then
23:50:48 <ChilliX> no perfectly reasonable for stubs, for example
23:51:04 <SamB_XP_> that's almost better than what happens when you leave methods undefined
23:51:48 <ChilliX> for type families (as opposed to data families) you can also have defaults (but that's not implemented yet)
23:52:34 <SamB_XP_> I'm not sure I see any point in that...
23:52:54 <ChilliX> same point as with dafault members
23:53:21 <SamB_XP_> can you have default members that use default type synonyms?
23:53:30 <ChilliX> sure
23:53:47 <SamB_XP_> I'd like to see that implemented ;-)
23:54:09 <ChilliX> yeah, I should do that soon
23:54:14 <SamB_XP_> then again, maybe I'd rather not look at that
23:57:03 <sorear> @botsnack
23:57:03 <lambdabot> :)
23:57:36 * SamB goes to bed
23:57:38 * SamB should have gone a while ago
23:57:48 <SamB> SamB_XP_ is disconnected...
23:57:54 <SamB> huh, a moth was flying into my screen just now...
23:59:35 <sorear> Heffalump, ChilliX: trac seems to be barfing atm; until it works -> http://members.cox.net/stefanor/bug-comment-newtype-story.txt
