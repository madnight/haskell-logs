00:00:30 <dons> this looks fun, http://programming.reddit.com/info/24ods/comments
00:00:33 <earthy> dons: actually, we will.
00:00:43 <Pseudonym> You know, I find it weird that the fact that we've gone 10 years without a major paradigm shift is grounds for complaint.
00:00:48 <dons> earthy: similar scheme to the one in .au, I'd imagine.
00:00:56 <earthy> 150 euro's / 3 months or some such
00:01:00 <dons> Pseudonym: not enough Epigram hackers?
00:01:15 * Pseudonym shrugs
00:01:22 <dons> concurrency doesn't count?
00:01:28 <dons> maybe in a few years
00:01:33 <earthy> uhm.
00:01:37 <dons> when we'll start with main = parMap
00:01:48 <earthy> concurrency was already a paradigm that was taught to us in 1994
00:02:01 <earthy> (and that course had already existed for a couple of years then)
00:02:26 <Pseudonym> People don't realise, for one, just how much work went into wireless networks, but now, everyone (apart from the Debian kernel) has one.
00:02:31 <dons> earthy: my favourite reference is http://groups.google.com/group/comp.lang.functional/msg/20a80be2e0c567f0?hl=en&
00:02:54 <earthy> what I tend to think of CS is that everything old is always new again
00:03:00 <dons> SPJ pointing out parallel GHC in ... Jun 12 1990
00:03:06 <opqdonut> Random is a really ugly interface for doing stuff like Random Array (Int,Int) Char
00:03:43 <earthy> hell, Clean was designed for concurrent programming and ran fairly well on transputers
00:03:48 <dons> the availability of more cores is changing the emphasis a bit. we just need the 16 and 32 core machines to come down under hmm, 5k.
00:04:05 * earthy nods
00:04:17 <dons> yeah, the hardware guys have just needed 20 years to catch up
00:04:18 <earthy> and then the dph stuff needs to be fleshed out a teensy bit more
00:04:26 <dons> yep.
00:05:09 <dons> we did run some parMaps in lambdbot iirc, when it was running on the 16 core box. that was cute.
00:05:27 <dons> also that lambdabot uses forkIO for every request, so it scaled up to more cores fairly nicely
00:06:00 <earthy> yeah, but that's the embarassing parallel nature of much of lambdabot's processing
00:06:03 <Syzygy-> What is the state of parallel haskell btw?
00:06:46 <dons> Syzygy-: i documented this just a couple of days ago, in fact.
00:06:49 <dons> gimme a sec...
00:06:52 <Syzygy-> OOOOOH!
00:06:55 <Syzygy-> Linkies!
00:07:03 <dons> http://haskell.org/haskellwiki/Applications_and_libraries/Concurrency_and_parallelism
00:08:00 <Cale> dons: Did you Reddit that?
00:08:05 <dons> everyone has SMP ghc/forkIO/STM/Chan/Control.Parallel.   a few have DPH parallel arrays and the unified events/libs stuff
00:08:09 <dons> Cale: nope.
00:08:20 <Syzygy-> dons: So, if it says something works from 6.5, then 6.6 supports it, right?
00:08:25 <dons> yep
00:08:26 <Cale> I wonder if it's worth redditing :)
00:08:37 <dons> Cale, hmm, yes. ok.
00:08:55 <Syzygy-> O.O
00:09:14 <Syzygy-> I wish I had seen hMPI (if it is functional enough) a couple of months ago when I started my cluster computing course...
00:09:30 <Syzygy-> Ummmm. The hMPI link is a 403
00:09:45 <dons> better fix that/find that then :)
00:10:40 <dons> http://programming.reddit.com/info/24ogs/comments
00:10:52 <dons> ?bot
00:10:55 <dons> ah
00:11:08 <glguy> 00:09 [ eivuokko] [ ihope_   ] [ psykotic] [ scorfield] [ t       ] [ Wallbraker]
00:11:12 <glguy> 00:09 [ glguy   ] [ Pseudonym] [ scook0  ] [ scw      ] [ triplah_] [ |Steve|   ]
00:11:19 <glguy> Those people are on the other side of the split
00:11:42 <dons> ok
00:11:58 <glguy> ?bot
00:12:05 <lambdabot> :)
00:13:19 <dons> http://www.foldr.org/~michaelw/hmpi/
00:13:21 <lambdabot> Title: hMPI - a Haskell binding for MPI
00:14:44 <dons> Cale: http://programming.reddit.com/info/24ogs/details
00:14:45 <lambdabot> Title: Parallel and multicore programming in Haskell: what tools you&#39;ve got (reddit ...
00:15:53 <glguy> "What tools you've got"?
00:16:24 <dons> well, i was trying to think of a 'down to earthy' way to say 'a list of things you can play with'
00:16:39 * glguy thinks of little red riding hood
00:16:46 <glguy> "My what big teeth you have"
00:16:56 <glguy> My,*
00:16:56 <sorear> glguy: So the one day I try to stay away from IRC, the logs show people calling me over hpaste malfunctions? :)
00:17:12 <glguy> sorear: was it people or glguy?
00:17:27 <sorear> glguy: OK, it was just you :)
00:17:58 <sorear> glguy: hpaste seems to be working fine for me, and you obviously didn't restart it - what's going on?
00:18:03 <dons> what was it like to spend a day away from IRC sorear ?
00:18:27 <sorear> dons: not as productive as I'd have liked.  I'll give it a few more :)
00:18:47 <glguy> dons: did SPJ give a talk about parallel arrays using quick sort as one of his examples?
00:19:10 <glguy> sorear: did I ask you why it was down? or type ?seen sorear :)
00:19:18 <sorear> glguy: IIRC, both.
00:19:21 * sorear re-checks
00:19:24 <dons>  he gave one on DPH arrays, yep
00:19:31 <sorear> sorear@kakapo:~$ l i -1
00:19:31 <sorear> -bash: l: command not found
00:19:42 <sorear> funny, all my one-letter scripts are gone! :)
00:20:15 <glguy> dons: are those production quality yet?
00:20:22 <sorear> ah, I see the context.  netsplit.
00:20:30 <glguy> ahh
00:20:32 <glguy> !paste
00:20:32 <hpaste> Haskell paste bin: http://hpaste.org/
00:20:35 <dons> DPH , not yet. see commits landing on ghc-cvs@ currently :)
00:20:46 <glguy> was that the -fvectorize?
00:21:00 <dons> dcoutts and I are planning a quick steal of the base DPH code to provide Data.ByteString.Parallel
00:21:03 <sorear> really annoying how RL likes to drop patches in bundles of ten
00:21:06 <dons> which might get done faster. we'll see.
00:21:14 <dons> sorear: he's working on a branch
00:21:23 <sorear> anyway, need to sleep.  bye
00:22:16 <glguy> speaking of sleeping.. my puppy is sleeping now... he seems to have two modes: full bore, and asleep
00:22:45 <glguy> we took him to the dog park today
00:22:56 <glguy> he bounces when he's running and having fun
00:23:15 <glguy> might be so he can see over the grasses :)
00:23:17 <dons> this Feng Shui SML thing is fun "The run-time system is like the sewer which runs under the house. It serves a useful purpose but no-one can play there"
00:23:31 <dons> glguy: cute :)
00:24:20 <Syzygy-> Ah. hMPI probably not usable beyond GHC 5.0
00:25:46 <dons> should be updated by someone.
00:27:17 <glguy> Was it the case that using unsafePerformIO to create a toplevel MVar was dangerous because two threads could try to access it at the same time before the first time it was used?
00:27:33 <dons> anyone thinking about becoming Ralf Lammel's first PhD student? :-)
00:28:06 <dons> glguy: hmm. MVars would look it, that'd be fine. its more dupilcating the action that's the issue, isn't it?
00:28:59 <glguy> right, I'm talking about if m = unsafePerformIO (newMVar ())
00:29:13 <glguy> and two threads tried to access m before it had been accessed before
00:29:30 <glguy> so the unsafePerformIO had not yet been evaluated
00:29:37 <glguy> duplicating the creation of the mvar
00:29:39 <glguy> ?
00:30:23 <glguy> rather I was asking if that could happen
00:31:07 <Syzygy-> dons: Ralf Lammel?
00:31:23 <Syzygy-> Oh, btw, is there a sane example of motivated use of unsafePerformIO?
00:32:37 * glguy believes that : top_level_global_var = unsafePerformIO (newIOVar ()) -- might be such an example
00:34:15 <narain> i need to implement something that's conceputally  foo :: [a] -> b -> c, but from a usage perspective it's annoying to always have to specify the [a]. is there a way to split it into something like foo' :: b -> c which works like  foo []  and a combinator  withA  such that  (foo' `withA` x `withA` y) = foo (y:x:[]) ?
00:35:12 <quicksilver> very likely, yes :)
00:35:34 <quicksilver> foldr is one such pattern, although the argumetns are the other way around
00:36:15 <quicksilver> you just have to ask yourself if you can write withA :: (b _> c) -> a -> (b->c)
00:36:19 <opqdonut> easiest way to search for elements in an array?
00:36:43 <glguy> easiest? turn the array into a list :)
00:36:44 <glguy> elems
00:36:54 <opqdonut> i'd need the indexes
00:37:04 <opqdonut> so lookup from assocs comes to mind
00:37:13 <narain> quicksilver: i had thought of that, yes
00:37:24 <glguy> opqdonut: assocs
00:37:29 <glguy> ?type Data.Array.assocs
00:37:31 <lambdabot> forall i e. (Ix i) => Array i e -> [(i, e)]
00:37:35 <opqdonut> yeah, as i said
00:37:44 <narain> i was wondering if i could get rid of the little  "-> a ->" in the middle
00:37:44 <opqdonut> there's nothing in the prelude?
00:37:58 <glguy> list comprehension :)
00:38:12 <opqdonut> ah, that might do it :)
00:38:26 <quicksilver> narain: 'get rid of it' ? but you need it for your x and y...
00:38:37 <glguy> [(i,x) | i <- range (bounds array), let x = array ! x, predicate x]
00:39:00 <narain> quicksilver: to cons them onto, right?
00:39:05 <glguy> and s/array ! x/array ! i
00:39:22 <quicksilver> [(i,x) | (i,x) <- assocs array, predicate x]
00:39:39 <glguy> Yeah... that :)
00:39:49 <quicksilver> narain: well I find it hard to believe that your definition of withA is independent of 'x'
00:39:57 <quicksilver> narain: sure it matters what elemetns are in the list?
00:40:07 <quicksilver> otherwise it's just a function on the length of the list...
00:40:17 <Cale> dons: cool, upmodded :)
00:40:39 <narain> quicksilver: oh, i misunderstood
00:41:17 <glguy> LOL, there should be some kind of additional warning. the kind of people that whine about .PDF won't know what .ps.gz is
00:41:32 <opqdonut> glguy: yeah, that's what i did
00:41:44 <quicksilver> opqdonut: there is really no reason for array to provide its own search functions if the lists ones work just as well, I think
00:42:03 <quicksilver> opqdonut: one of the lessons of haskell is that 'toList' is actually your general iterator
00:42:25 <narain> quicksilver: yes, you're right. now how would i go about writing that function? the first argument seems to be an opaque type which i can't "reach into" and modify
00:42:45 <quicksilver> narain: there isn't a general answer to your question
00:42:53 <quicksilver> narain: it depends on the case
00:43:01 <quicksilver> narain: tehre are all kinds of things you can do to a function:
00:43:02 <narain> ah...
00:43:05 <quicksilver> narain: apply it more than once
00:43:18 <quicksilver> narain: apply it to a different input
00:43:19 <dons> arrays could provide a uniform bytestring-like interface though
00:43:23 <dons> we'd use them more if that was the case
00:43:26 <quicksilver> narain: apply it then modify the output
00:43:29 <dons> and ndp arrays indeed look like that
00:43:37 * glguy has had to do: zcat some.ps.gz | ps2pdf - > some.pdf  twice today
00:43:42 <narain> quicksilver: ah thanks, those are the kinds of ideas i was looking for
00:44:14 <quicksilver> dons: it would be nicer, IMO, if they provided a simple list interface and fusion rules existed to eliminate un-necessary copying :P
00:44:37 <narain> :t foldr
00:44:40 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
00:46:24 <dons> hehe, reddit perfect storm: atheism and lisp in one article!  http://programming.reddit.com/info/24oni/details :)
00:46:25 <lambdabot> Title: God writes spaghetti code: 4 reasons why DNA isn&#39;t a good programming langua ...
00:46:31 <glguy> foldr f [a] (foldr f xs [])    -- is --    foldr f (a:xs) []
00:46:42 <dons> yeah, that'd do me too.
00:46:50 <dons> map/filter/fold/zip and be done with it
00:47:15 <glguy> so if I understand what you are trying to do, you don't need to modify the list, just to fold again
00:48:14 <narain> glguy: ah, that's a neat identity
00:48:22 <glguy> dons: let me guess: A C G and T
00:48:30 <glguy> are those the four reasons?
00:49:51 <dons> oh, just some points about the error proneness, redundancy, self-modification, and other incoherent semantics
00:50:08 <scook0> "G considered harmful"?
00:50:10 * glguy would present a simple counter example
00:50:32 <glguy> life on earth
00:50:43 <dons> C++ also
00:50:49 <glguy> heh
00:50:51 <oerjan> glguy: that -- is -- cannot be correct?
00:51:18 <glguy> oerjan: ?
00:51:46 <dons> isn't cancer just a dna stack overflow?
00:52:31 <oerjan> glguy: don't you mean foldr f [a] xs on the right?
00:52:42 <glguy> oerjan: no
00:53:06 <oerjan> the inner parenthesis on the left is xs
00:53:21 <narain> yeah, maybe it should be  foldr f (foldr f e xs) [a] == foldr f e (a:xs) ? or maybe foldl
00:53:36 <narain> going by the type
00:53:48 <oerjan> maybe you got some arguments in the wrong order?
00:56:13 <glguy> ?check \ f a xs -> foldr f [(a :: Int)] (foldr f (xs :: [Int]) []) == foldr f (xs ++ [a]) []
00:56:16 <lambdabot>  Falsifiable, after 3 tests: <Int -> [Int] -> [Int]>, -1, [0]
00:56:29 <glguy> ?check \ a xs -> foldr (:) [(a :: Int)] (foldr (:) (xs :: [Int]) []) == foldr (:) (xs ++ [a]) []
00:56:32 <lambdabot>  OK, passed 500 tests.
00:56:36 <glguy> that's what I was thinking of
00:57:00 <glguy> OHHH
00:57:01 <glguy> you are right
00:57:05 <glguy> I had the arguments fliped
00:57:10 * glguy finally sees it
00:57:31 <glguy> foldr f (foldr f xs []) [a] === foldr f (a:xs) []
00:58:19 <narain> has anyone used the Text.HTML package?
00:58:24 <kosmikus> Korollary, dons: yes, the Haskell source file you can download from the paper webpage is generated by a "lhs2TeX --newcode" run from the .lhs master file.
00:58:40 <oerjan> er, that is not right either
00:58:54 <kosmikus> dons: thanks for posting the paper on reddit. comments are welcome.
00:59:12 <glguy> apparently not
00:59:14 <glguy> oh well
00:59:49 <oerjan> i think...
01:00:21 <oerjan> foldr f (foldr f a xs) ys = foldr f a (ys++xs)
01:00:30 <glguy> ?check (\ f a xs -> foldr f (foldr f [] xs) [a] == foldr f [] (a:xs)) :: (Int -> [Int] -> [Int]) -> Int -> [Int] -> Bool
01:00:41 <lambdabot> Terminated
01:01:20 <dons> kosmikus: someone was asking how you generated the code from the paper
01:01:49 <Syzygy-> Actually, you don't need to pull the code out of the paper, do you?
01:02:05 * Syzygy- has one of those dual code-paper thingies - and I just load the .lhs straight into GHC...
01:02:58 <wli> Syzygy: That would be nice. What's it called?
01:03:15 <kosmikus> dons: yes, it was Korollary, I think. I answered the question above.
01:03:34 <Korollary> Yes thx
01:03:37 <kosmikus> dons: but you made the right guess.
01:03:46 <matthew-_> lhs2TeX with --newcode will just extract the code iirc
01:04:04 * wli looks at http://holomorphy.com/~wli/eval/EvalOne.hs
01:04:14 <kosmikus> matthew-_: it also allows you to apply formatting directives to your code, just as --poly does
01:04:38 <matthew-_> yup. I've only only ever played with --poly for papers
01:05:06 <dons> very nice, kosmikus. i will be sure to try this for upcoming papers
01:05:23 <dons> we had a few code-to-tex translation errors in the fusion paper
01:05:27 <kosmikus> we'll make the master .lhs file available sooner or later. but we worked very hard to meet the deadline, so the current sources still contain a lot of development comments.
01:05:28 <dons> which would be nice to avoid
01:05:42 <matthew-_> and as lhs2TeX is more flexible than haskell in that it allows mixing of code blocks and bird tracks, sometimes it can't just be loaded into ghci
01:07:00 <cedricshock> Slightly off-topic: Is there any easy way in Java to do something like: data AnimationCommand = Step | Move Int Int Int | Replace Int Int
01:07:12 <wli> lhs2tex wants to nuke texlive
01:07:40 <glguy> "The duty of selecting a site fell to the most learned men, as programming language design historically fell to the most experienced computer scientists"
01:07:43 <matthew-_> cedricshock: mm, slightly off topic eh? Either use an Interface AnimationCommand, or use an Enum
01:07:44 <glguy> those were the good old days
01:07:55 <dons> cedricshock: pretty sure sum types are very difficult in java
01:08:04 <dons> actually, i've got slides on this somewhere. hang on ..
01:08:20 <wli> I suppose someone will have to update the lhs2tex Debian package to use texlive.
01:08:32 <hpaste>  Lokik pasted "Type return error" at http://hpaste.org/1581
01:08:49 <lokik_> yea i need help with that
01:08:54 <wli> So, looking at EvalOne.hs I'm thinking of putting the monad screws to it.
01:08:57 <Thomas2> everything in java is option-typed (maybe-typed in haskell speak), so sum types shouldn't be much of a challenge
01:08:57 <cedricshock> This has nothing to do with being functional, and yet I don't know any Java/c++ ways to express it other than a bunch of defined integers in an interface and a class that has all the properties of all of the sub classes. Or checking the class of the object, and that's really ugly.
01:09:09 <matthew-_> wli: Depends: libc6 (>= 2.3.6-6), libgmp3c2, texlive-latex-base | tetex-bin, texlive-latex-base | tetex-base, texlive-latex-base | tetex-extra
01:09:19 <matthew-_> (this is unstable)
01:09:43 <wli> matthew-: Okay, I'll try unstable, then.
01:09:44 * cedricshock wishes he never ever had to tough Java. It's almost his least favorite language.
01:09:56 <lokik_> .ie agreement
01:10:05 <dons> cedricshock: there's slides at the end here on how to properly embed sum types into java -- http://cgi.cse.unsw.edu.au/~cs3161/06s1/lectures/Week08/DataStructures_online.pdf -- its horrid
01:10:07 <lambdabot> http://tinyurl.com/y24en4
01:10:15 <Cale> cedricshock: I can relate to that sentiment
01:10:23 <dons> Maybe is easy enough
01:10:31 <cedricshock> dons: Thanks.
01:10:52 <matthew-_> cedricshock: why can't you just do an Interface as the type and then each constructor is an implementing class?
01:10:54 <kosmikus> dons: yes, what's quite nice is that all the interactive sessions in the paper are actually "run" by lhs2tex during the compilation process.
01:11:10 <lokik_> so anyone could help me out with a type error, 5 lines of code, http://hpaste.org/1581
01:11:18 <kosmikus> dons: but it's a bit of a hack to achieve that.
01:11:37 <lokik_> ?
01:11:45 <dons> kosmikus: oh, that's very neat. so it always typechecks?
01:11:54 <oerjan> lokik_: your last line uses as if it was a String, but it is an IO action so you must get the String value out first
01:12:09 <lokik_> .ua discovery
01:12:14 <lokik_> kk i'll go fix it
01:12:20 <Cale> s <- valCUNso loiVALsi (loNAMcu - 1)
01:12:31 <Cale> return $ loVALsi ++ s
01:12:52 <kosmikus> dons: it's still possible to make mistakes in the formatting rules, or in some of the inline code examples, but yeah, the basic code really runs, and the examples run too.
01:13:02 <lokik_> .ui happiness, it works :-)
01:14:11 <lokik_> lots of thinking, little coding :D
01:14:24 <lokik_> that's a wonderful quote
01:14:45 <lokik_> "Write less, think more"
01:14:50 <lokik_> i was alluding to
01:14:58 * lokik_ goes off
01:16:49 <wli> Okay, I've got it installed.
01:17:20 <earthy> kosmikus calling something 'a bit of a hack'...
01:17:21 * earthy shudders
01:19:20 <wli> I guess I should call it EvalZero, following Wadler.
01:20:02 <opqdonut> gah, is there any easy way for going from (IO a, IO a) to IO (a,a) ?
01:20:18 <opqdonut> context: i need to generate a random index (i,j)
01:20:52 <oerjan> opqdonut: liftM2 (,)
01:21:09 <opqdonut> oh, of course
01:21:15 <quicksilver> oerjan: ITYM uncurry (liftM2 (,))
01:21:33 <oerjan> right
01:21:38 <opqdonut> yeah, i realised
01:21:59 <opqdonut> but what would you recommend for generating that index, this seems a bit ugly
01:22:30 <oerjan> :t randomRIO
01:22:33 <lambdabot> forall a. (Random a) => (a, a) -> IO a
01:22:35 <opqdonut> uncurry . liftM2 . i <- randomRIO . (,) 1 &&& randomRIO . (,) 1 $ bounds k
01:22:56 <opqdonut> oerjan: the only problem is that (Int,Int) is not an instance of random
01:23:03 <opqdonut> think i should just declare it myself
01:23:25 <opqdonut> (why on earth isn't there a (Random a, Random b) => Random (a,b) ??)
01:23:44 <oerjan> @instances-importing Random Random
01:23:46 <lambdabot> Bool, Char, Double, Float, Int, Integer
01:23:59 <oerjan> indeed
01:24:56 <quicksilver> opqdonut: good question
01:26:41 <opqdonut> tuples are so underpowered atm
01:26:58 <opqdonut> because the prelude just seems to ignore them for some things
01:27:53 <oerjan> i wondered the other day why there isn't a Random Monad
01:28:08 <oerjan> (transformer)
01:28:48 <DRMacIver> Yeah. I think it's really worth an expanded prelude or Tuple module.
01:30:27 <opqdonut>     Illegal instance declaration for `Random (Int, Int)'
01:30:31 <opqdonut> gyah
01:30:48 <oerjan> problems?
01:30:59 <opqdonut>         (The instance type must be of form (T a b c)
01:31:04 <opqdonut> how should i do that declaration?
01:31:10 <opqdonut> with a newtype?
01:31:20 <DRMacIver> (Random a, Random b) => Random (a, b)
01:31:30 <opqdonut> okay
01:31:46 <DRMacIver> You can't declare type class instances for particular instantiations of polymorphic types without some extension turned on.
01:31:57 <opqdonut> ah, that's it
01:32:24 <glguy> HUnit doesn't seem very good at running a TestList with 0x110000 tests in it
01:32:43 <cedricshock> glguy:That's a lot of test!
01:33:13 <dons> hmm, programming in (a simplified) DNA would have been a good puzzle in last years ICFP contest
01:35:15 <wli> Okay, there we go.
01:37:03 <wli> There's my take on Variation Zero.
01:45:54 <opqdonut> (g `on` f) x = (f x) g (f x) -- isn't this the idiom?
01:46:24 <oerjan> yep
01:46:40 <quicksilver> missing a `` around g
01:46:44 <quicksilver> but, yes.
01:46:55 <opqdonut> ah
01:47:13 <Adamant> I finally get monad basics
01:47:24 <Adamant> ah, the beauty of sufficent sleep
01:47:42 <cedricshock> Adamant: I have said that many times. I am yet to be right :(
01:48:33 <augnob> osmosis + sleep... If that doesn't work, the brain doesn't want to know it.
01:48:45 <augnob> sorry.. I like giving bad advice.
01:49:46 <wli> I guess one thing to do is to model things as some sort of machine.
01:50:23 <glguy> dons: I'm writing HUnit tests from the UTF-8-test.txt
01:50:26 <opqdonut> err actually (g `on` f) x y = (f x) `g` (f y) right?
01:50:56 <wli> So I can turn the problem around in a manner of speaking.
01:50:57 <quicksilver> 09:46 < quicksilver> missing a `` around g
01:50:58 <quicksilver> :P
01:51:07 <quicksilver> erm
01:51:09 <quicksilver> yes
01:51:16 <quicksilver> you're right, it's for two paramenters
01:51:20 * quicksilver shoulds read more, type less
01:51:43 <dons> glguy: why HUnit? why not just some 0-arity quickChecks?
01:51:49 <dons> or are you doing some IO stuff with files?
01:52:00 <glguy> I could do that :)
01:52:08 <glguy> dons: because I thought that this was what HUnit was for
01:52:13 <glguy> no special reason
01:52:15 <dons> its more for IO.
01:52:23 <glguy> it just seemed suited for a list of lists of tests
01:52:23 <dons> i just use prop_foo = f "foo" == "bar"
01:52:35 <glguy> with messages to explain what went wrong
01:52:42 <dons> yeah, that's missing.
01:52:48 <dons> hunit is a bit better there
01:53:04 <glguy> I pass all of these tests I'm writing, of course :) but if I were to break something
01:53:05 <quicksilver> I end up writing my own test harness with each module I write :)
01:53:07 <glguy> it would be nice ot know
01:53:09 <wli> Interestingly nothing talks about how to allow interpreted programs to catch exceptions.
01:53:57 <wli> I suppose it's relatively obvious.
01:55:37 <wli> What might be less obvious is how to deal with asynchronous exceptions (e.g. signals/interrupts).
01:56:09 <Syzygy-> I have a program (with high complexity, admittedly) that dies on the extreme cases with stack overflow (after about a week long execution)
01:56:24 <quicksilver> wli: sounds like time to (re?)read the awkward squad paper
01:56:24 <Syzygy-> What kind of things should I look for to figure out what parts are harsh on the stack?
01:56:31 <dons> hmm. loops/folds
01:56:38 <dons> any weird recursion
01:56:49 <dons> and perhaps start a profile run now, and increase the stack size
01:56:49 <kolmodin> dons: morning! :)
01:56:56 <dons> heya kolmodin
01:56:58 * kolmodin is back in .se
01:57:10 <dons> cool, been wondering where you've been off at
01:57:15 <dons> summer holidays?
01:57:17 <kolmodin> yeah
01:57:39 <kolmodin> for 10 days
01:57:53 <kolmodin> now I've got another 20 without any particular plans yet :D
01:58:07 <kolmodin> I'm curious how the book is progressing :)
01:58:30 <kolmodin> also, I'm getting up to date with my mail... sigh :)
01:58:30 * Syzygy- skims his literature list for the paper. 
01:58:41 <Syzygy-> Haskell 98 really has an almost absurd authorlist!
01:58:46 <Syzygy-> Especially for mathematical standards.
01:59:05 <dons> bos and john have been hacking like mad, i'm ploughing along with my thesis :)
01:59:11 <Syzygy-> 1 author .. 1 author .. 2 authors .. 1 author .. 18 authors
01:59:29 <kolmodin> dons: ah yes, the real world catches up :)
02:00:09 <dons> and i booked my one-way tickets to portland. cost just as much as return tickets :/ ah well
02:00:37 <kolmodin> what happens in portland?
02:01:09 <dons> i'm moving there to work for galois :)
02:01:14 <kolmodin> visit galois?
02:01:20 <kolmodin> woha! cool :)
02:01:28 <dons> :)
02:01:29 <kolmodin> yeah, I heard they where hiering
02:01:35 <dons> yay, jobs!
02:01:43 <kolmodin> so your thesis is as good as finished?
02:01:53 <dons> oh, getting there :}
02:01:56 <kolmodin> haha :D
02:02:05 <narain> does anyone know how good is the Text.HTML package on hackagedb?
02:02:12 <kolmodin> I'm as good as finished with my degree
02:02:31 <narain> corollary question: what's a good lightweight package for generating html in haskell?
02:02:32 <dons> narain: pretty good. i've used it.
02:02:35 <kolmodin> I have done all the parts.. I have just to ask to get the degree.. neat
02:02:40 <narain> dons: ah, nice
02:02:41 <narain> thanks
02:03:17 <kolmodin> about weird input to Data.Binary..
02:03:20 <dons> yeah, i used import Text.XHtml.Transitional
02:03:27 <dons> in the xhtml package, actually
02:03:36 <dons> kolmodin: yes, thoughts ?
02:03:37 <kolmodin> we could do more checks, making sure that all the tags are ok..
02:03:42 <kolmodin> but that costs speed
02:03:50 <dons> yes.
02:03:59 <kolmodin> I'm not sure it's our problem :)
02:04:02 <dons> so maybe safe instances to wrap and check (sha1 and stuff)
02:04:14 <dons> yeah
02:04:16 <kolmodin> if your data might be manipulated you should make checks yourself
02:04:25 <kolmodin> we only do serialization
02:04:38 <dons> right. and full security is too big a space for us to cover
02:04:40 <dons> so leave it up to other
02:04:42 <dons> s
02:04:43 <kolmodin> yeah
02:05:04 <kolmodin> surely someone will write a secury layer on top of binary :)
02:05:28 <dons> right. bos already wrote that Typeable wrapper, which adds some type checks
02:05:32 <kolmodin> yeah
02:05:50 <kolmodin> and one could do the same but with sha1 checksums
02:06:04 <narain> dons: are functions named thediv, thehtml etc common haskell style?
02:06:36 <dons> a bit unusual, but its an embedded language for html, some some compromises are needed
02:07:01 <siti> does anyone know how to stop Network.accept blocking, or a way to cancel it blocking?
02:07:06 <dons> narain: i have an ugly hacked up script here, http://www.cse.unsw.edu.au/~dons/code/nobench/bin/gen-report.hs
02:07:09 <narain> dons: ok, just wondering
02:07:16 <wli> What would be something like a stack with an efficient operation for reading and updating the n-th element from the top, hmm.
02:07:21 <narain> dons: ah, thanks, will have a look
02:08:37 <dons> wli, hmm, a stack zipper?
02:09:03 <dons> stores focus a point 'n' in the stack, giving O(1) prev/next/pop/push/indexAtN
02:09:13 <siti> I have tried throwTo to cause an exception that cancels the accept function but I get a segfault :S
02:09:23 <wli> dons: I've not heard of a stack zipper.
02:09:31 <dons> siti, hmm, wasn't there a long thread about this on haskell-cafe@ today?
02:09:49 <siti> I don't read haskell-cafe I will have a look at the archives
02:10:13 <dons> wili, 'differentiate' a [a], into a structure with a hole in it:  data Stack a = Stack { left :: [a] , current :: a, right :: [a] } | Empty
02:10:41 <dons> current is your 'nth' elem
02:11:06 <wli> dons: I think Data.Sequence might be better here.
02:11:24 <dons> yeah
02:11:27 <dons> that's a good idea.
02:12:21 <siti> dons: I can't find the thread, do you know the subject title?
02:12:40 <dons> let me check..
02:12:43 <siti> thanks
02:13:28 <siti> my code is probably causing the segfault, I will fix it ;)
02:13:35 <vincenz> @tell ndm I'll try the new -O2 flag, though I admit that compiling the benchmark outputs into a graph was a lot of painful manual work
02:13:35 <siti> I think the throwTo might actually work
02:13:35 <lambdabot> Consider it noted.
02:13:56 <dons> http://thread.gmane.org/gmane.comp.lang.haskell.cafe/25025
02:13:57 <lambdabot> Title: Gmane Loom
02:14:38 <siti> thanks, it wasn't on mailman :S
02:14:38 <wli> dons: (<|) to push, viewl to pop, index to fetch, adjust/update to update, etc.
02:16:10 <wli> dons: I think indices are from the left.
02:18:57 <wli> Okay, now for a flexible array type.
02:19:13 <dons> Data.IntMap? :-)
02:20:39 <dons> ooh, nice, http://people.cs.uu.nl/stefan/blog/00024.html
02:20:42 <lambdabot> Title: Personal Web Pages of Stefan Holdermans: A Generic Usage Analysis with Subeffect ...
02:22:08 <wli> dons: Looks plausible, though it appears invariants need to be enforced elsewhere.
02:22:50 <wli> dons: Like range restrictions on the things.
02:23:12 <dons> by `flexible' did you mean resizable?
02:23:16 <wli> dons: Yes.
02:23:42 <dons> hmm, we have reallocArray for some array types now
02:23:43 <wli> dons: Range restrictions are for accepting/rejecting commands/input, not for the type itself.
02:23:52 <dons> certainly for Foreign.*.Array
02:24:13 <dons> but the bounds stuff was changed in the Array class specifically for this -- i've not used it though
02:25:15 <wli> dons: I think IntMap as a back-end with various sorts of validity checks on query/update commands will do.
02:25:55 <wli> dons: (This is a monadic programming exercise I'm setting up for myself.)
02:26:18 <dons> IntMap makes a useful array emulator, yep. so seems plausible
02:27:00 <wli> dons: Might even do well as a process address space emulator with mmap() ranges and protections enforced by a front-end somewhere.
02:29:36 <wli> A set of disjoint intervals of integers, where one needs to find of which interval some integer is a member.
02:31:18 <oerjan> sounds like an IntMap of IntMaps
02:32:00 <wli> RangedSet in the data structure section of libs.
02:32:21 <dons> yeah, RangedSet, there's some other interval type as well, iirc
02:32:44 <wli> Diet.hs
02:36:04 <wli> So it basically looks like you can set up a stack and a process address space -like store without too much pain.
02:36:29 <wli> Not entirely sure how to model file IO.
02:37:09 <glguy> if HUnit is only needed to test
02:37:12 <glguy> but not to install
02:37:17 <glguy> do I need to mark it as a build-depend
02:38:53 <wli> I guess open(), close(), pipe(), dup(), dup2(), socket(), bind(), listen(), connect(), accept(), read(), and write() are obvious enough. A file table is needed, of course.
02:40:30 <dons> glguy: not a build depend
02:40:35 <roconnor> > let x = [("Mixed Fuit",215),("French Fries",275),("Side Salad",335),("Hot Wings",355),("Mozzarella Sticks",420),("Sampler Plate",580)] in(filter (\y -> sum (map snd y)==1505) . flip replicateM x) =<< [0..]
02:40:43 <lambdabot> Terminated
02:40:48 <wli> lseek(), readdir(), etc. too.
02:41:19 <roconnor> > let x = [("Mixed Fuit",215),("French Fries",275),("Side Salad",335),("Hot Wings",355),("Mozzarella Sticks",420),("Sampler Plate",580)] in head ((filter (\y -> sum (map snd y)==1505) . flip replicateM x) =<< [0..])
02:41:22 <lambdabot>  [("Mixed Fuit",215),("Hot Wings",355),("Hot Wings",355),("Sampler Plate",580)]
02:42:51 <quicksilver> (==1505).sum.map snd
02:42:57 <quicksilver> if you like pointfree cuteness :)
02:43:28 <roconnor> > let x = [("Mixed Fuit",215),("French Fries",275),("Side Salad",335),("Hot Wings",355),("Mozzarella Sticks",420),("Sampler Plate",580)] in head [map fst y|i<-[0..], y<-replicateM i x, sum (map snd y)==1505]
02:43:31 <lambdabot>  ["Mixed Fuit","Hot Wings","Hot Wings","Sampler Plate"]
02:43:55 <roconnor> Is there a some arrow shorthand for map fst and map snd?
02:45:23 <wli> A really good question is what the devil you do when your interpreter has to relay IO requests to the OS.
02:45:43 <wli> Maybe there's a monad transformer for that.
02:46:01 <scook0> > [1..4] >>> pure (+1)
02:46:01 <roconnor> yesh, the perl and python(?) code is so long
02:46:02 <lambdabot> Terminated
02:46:08 <quicksilver> roconnor: unzip?
02:46:41 <roconnor> quicksilver: I want map fst and map snd in completely different places.
02:46:47 <scook0> hmm, that shouldn't type anyway
02:47:13 <roconnor> @type [1..4] >>> pure (+1)
02:47:14 <lambdabot>     Ambiguous occurrence `pure'
02:47:15 <lambdabot>     It could refer to either `pure', imported from Control.Applicative
02:48:30 <roconnor> http://programming.reddit.com/info/24p2c/comments
02:48:31 <lambdabot> Title: xkcd - Does anyone else feel compelled to solve this? (reddit.com)
02:49:23 <roconnor> Of course the code to solve the problem ought to be smaller than the code that states the menu.
02:50:50 <glguy> dons: hunit tests pushed if you get curious :)
02:50:52 <timbod> @seen syntaxfree
02:50:52 <lambdabot> syntaxfree is in #haskell-blah and #haskell. I don't know when syntaxfree last spoke.
02:51:39 <timbod> syntaxfree: about now?
02:53:36 <timbod> lklkgjbvgvjnhjbvhjojoklnlklnhjuygiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii
02:55:10 <quicksilver> roconnor: I think I may not understand the problem. If you want them in different places then map fst and map snd are only 7 chars, it's not a high price to play
02:55:28 <quicksilver> roconnor: the arrow stuff has functions for modifying "in-place" without pulling out of the tuples
02:55:43 <quicksilver> > first (+1) [(0,0),(1,1),(2,2)]
02:55:45 <lambdabot>  Couldn't match expected type `[(t, t1)]'
02:55:51 <quicksilver> :t first
02:55:54 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
02:56:11 <quicksilver> hmm not that, clearly :)
02:56:12 <roconnor> quicksilver: ah yes, quite right.
02:56:39 <roconnor> @type first
02:56:41 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
02:56:50 <scook0> incidentally, I got a GHC panic on "[1, 2] >>> pure (+1)" while messing around
02:57:04 <quicksilver> :t first (+1)
02:57:06 <lambdabot> forall b d. (Num b) => (b, d) -> (b, d)
02:57:11 <timbod> apologies.... child taking over IRC.
02:57:20 <quicksilver> > first (+1) (0,1)
02:57:22 <lambdabot>  (1,1)
02:57:25 <quicksilver> (of course, it's not list-based)
02:57:37 <quicksilver> you want map (first (+1)) for that :)
02:59:04 <roconnor> timbod: heh, I thought it was a cat :)
02:59:35 <quicksilver> don't be silly, cats are much better than that at spelling
03:01:06 <opqdonut> :)
03:28:06 <roconnor> How do I format my haskell code as monospaced in a reddit comment?
03:29:05 <Syzygy-> @check (\l -> (head l) == (l !! 0))
03:29:06 <lambdabot>  Add a type signature
03:29:11 <Syzygy-> @check (\l -> (head l) == (l !! 0)) :: [Int]
03:29:12 <lambdabot>      The lambda expression `\ l -> ...' has one argument,     but its type `[...
03:29:22 <Syzygy-> @check (\(l::[Int]) -> (head l) == (l !! 0))
03:29:22 <lambdabot>  Parse error in pattern
03:29:28 <Syzygy-> Hmph.
03:30:27 <Syzygy-> @check (\l -> (head (l::[Int])) == (l !! 0))
03:30:29 <lambdabot>  Exception: Prelude.head: empty list
03:30:38 <Syzygy-> Bah.
03:31:01 <Syzygy-> > [1,2,3]!!0
03:31:03 <lambdabot>  1
03:31:33 <ToRA> @check (\l -> length l > 0 ==> (head (l::[Int])) == (l !! 0))
03:31:35 <lambdabot>  OK, passed 500 tests.
03:33:22 <dons> roconnor: indent 4 spaces
03:33:50 <dons> roconnor: list monad solution to the xkcd puzzle, by chance? :-)
03:33:57 <roconnor> dons: of course
03:34:01 <roconnor> dons: thanks
03:34:03 <dons> hehe
03:34:20 <roconnor> Everyone else has such long code.
03:34:39 <roconnor> [map fst y|i<-[0..], y<-replicateM i menu, sum (map snd y)==1505] is the heart of my program
03:34:45 <roconnor> and I didn't even try to make it short.
03:35:08 <roconnor> the menu is longer than the program
03:35:30 <dons> yeah, that looks like we could probably squeeze it down some more
03:36:23 <dons> yes, that's nice, isn't it:
03:36:24 <dons> [ map fst y
03:36:24 <dons> | i <- [0..]
03:36:24 <dons> , y <- replicateM i menu
03:36:24 <dons> , sum (map snd y) == 1505 ]
03:37:12 <dons> there's a post somewhere about how 'use the list monad' is the solution to every job interview programming puzzle ;)
03:39:19 <roconnor> dons: granted my program runs forever, but that's not so bad.
03:39:43 <quicksilver> that's OK, because it generates an infinite list
03:40:03 <roconnor> quicksilver: well, there are only 13 solutions
03:40:08 * quicksilver nods
03:40:13 <roconnor> so it will never print out any more
03:40:18 <roconnor> but at least it will try. :)
03:40:35 <quicksilver> yes, I suppose you might detect something about sum (min) > 1505
03:40:39 <quicksilver> and then stop
03:41:26 <quicksilver> let maxNum = 1505 `div` minimum . snd $ menu
03:41:36 <roconnor> quicksilver: that could be done.  It would make the code twice as long ;)
03:41:37 <quicksilver> i <- [1..maxNum]
03:41:40 * quicksilver nods
03:41:41 <quicksilver> indeed
03:41:49 <Syzygy-> Hmmm.
03:41:49 <earthy> okay, this is worse than what I did
03:42:03 <Syzygy-> Writing a quick-n-dirty introduction to Haskell for mathematicians as a section of the paper I'm preparing...
03:42:06 * earthy took pen and paper and tried working it oud by hand. ;)
03:42:10 <Syzygy-> Surprisingly tricky.
03:42:20 <earthy> syzygy: you bet. :)
03:42:39 <earthy> fortunately, mathematicians have the dirty part down pat. :P
03:42:49 <Syzygy-> :P
03:43:09 <Syzygy-> It's basically to a large extent lists of the functions I use and what they are supposed, really, to do.
03:43:09 <opqdonut> can i get a backtrace in ghci somehow?
03:43:19 <opqdonut> after a stack overflow, for example
03:43:34 <earthy> what would you want that trace to show? :)
03:43:58 <opqdonut> where the overflow happened
03:44:14 <earthy> and you think that is where the coding error is?
03:44:29 <roconnor> dons: the list monad is ideal for solutions to small NP problems I think.
03:44:38 <opqdonut> earthy: no, but at least it'd give me some hint
03:44:48 <earthy> um. no. :)
03:45:11 <earthy> well, maybe, in the general direction of hintness
03:45:17 <opqdonut> yeah
03:45:19 <earthy> but to get that you can do heap profiling
03:45:29 <opqdonut> and how would i do that?
03:45:54 <wli> http://en.wikipedia.org/wiki/Cantor_pairing_function
03:45:55 <lambdabot> Title: Pairing function - Wikipedia, the free encyclopedia
03:46:38 <earthy> section 5.4 of the GHC manual does a better job of explaining that than I can
03:46:43 <opqdonut> ok
03:47:06 <opqdonut> will zip hugeList (tail hugeList) blow up?
03:47:12 <opqdonut> because that seems to be the problem atm
03:47:33 <earthy> uhm... depends on how hugeList is built
03:47:41 <quicksilver> in principle, no
03:47:47 <quicksilver> that's a perfectly sensible thing to do
03:47:56 <opqdonut> hGetContents of /usr/share/dict/words
03:48:00 <quicksilver> it's quite a common idiom
03:48:02 <opqdonut> quicksilver: yeah, so i'd think
03:48:08 <quicksilver> althouhg it's more common to see zipWith
03:48:10 <earthy> quicksilver: unless looking at the constructor of hugeList forces something to explode
03:48:35 <opqdonut> sum . map (breaks kbd) $ zip corpus (tail corpus) -- how about this
03:48:41 <opqdonut> breaks kbd will not overflow
03:53:03 --- mode: irc.freenode.net set +o ChanServ
03:53:41 <opqdonut> earthy: so sum doesn't force them to be evalled?
03:53:59 <opqdonut> oh, because + is strict in both args all of the elements get evalled before sum?
03:54:09 * earthy nods
03:54:34 <earthy> not because + is strict though
03:54:49 <earthy> but because breaks does some evaluation that it shouldn't
03:55:02 <earthy> a judiciously placed ~ may help
03:55:02 <opqdonut> it does?
03:55:30 <earthy> opqdonut: any pattern matching in breaks at all?
03:55:50 <opqdonut> only the (x,y) arg
03:55:57 <earthy> there you go then.
03:56:05 <earthy> match on it lazily using ~(x,y)
03:56:14 <earthy> and try again :)
03:56:31 <earthy> (the (x,y) arg forces the tuple
03:56:37 <opqdonut> and that forces the list?
03:56:40 <wli> Find the largest k s.t. \binom{k+d-1}{d} <= n, then that peels off one variable as n-\binom{k+d-1}{d}
03:56:42 <opqdonut> the whole zipped list
03:56:48 <earthy> which in turn forces the list due to the zip xs (tail xs)
03:57:02 <opqdonut> yep
03:57:54 <earthy> laziness in the face of pattern matching quickly dies. ;)
03:58:01 <opqdonut> hrmm
03:58:12 * earthy ran into basically the same problem ;)
03:58:15 <opqdonut> not sure i quite see the reason here tho
03:58:19 <earthy> last week
03:58:25 <opqdonut> couldn't one just read one (x,y) from the list
03:58:33 <wli> Or actually it peels off the sum
03:58:34 <opqdonut> and that'd force just one more element from xs
03:58:46 <earthy> hm. yea
03:59:05 <earthy> 12:58 <lambdabot> sum = foldl (+) 0
03:59:09 <opqdonut> yep, still overflows
03:59:11 <earthy> there's the culprit
03:59:14 <opqdonut> should be foldl'?
03:59:16 <opqdonut> yep
03:59:43 <EvilRanter> is there a good explanation of existential types (why and how) somewhere?
03:59:47 <earthy> the foldl forces the list but doesn't reduce the + until the entire list has been forced
03:59:53 <opqdonut> yeah
04:00:16 <earthy> so foldr (+) 0 shouldn't overflow
04:00:34 <opqdonut> yeah now it doesn't overflow
04:00:41 <opqdonut> just takes a veeery long time
04:00:46 * earthy grins
04:00:52 <earthy> yeah, but that's better :)
04:01:28 <quicksilver> ghc -O2 should strictify that foldl
04:01:44 <quicksilver> you shouldn't need to explicitly use foldl', I don't think
04:01:51 <earthy> 'shouldn't
04:01:52 <earthy> '
04:01:57 <opqdonut> yeah i'm doing this in ghci
04:02:01 <earthy> plus, opqdonut was in ghci
04:02:01 <quicksilver> ah well ghci
04:02:07 <quicksilver> nothing works in ghci :P
04:02:19 <earthy> toy problems work in ghci :P
04:02:20 <swiert_> EvilRanter: you may want to check out Simon Peyton Jones's papers on First-class modules and Arbitrary rank type inference.
04:02:29 <quicksilver> no optimisation = no strictness analysis = overflows all over the shop
04:02:40 <swiert_> I think there's also a chapter in Types and Programming Languages.
04:02:48 <EvilRanter> okay
04:02:54 <quicksilver> EvilRanter: basically instead of knowing *exactly* what I store in a list, I want a list of 'anything which conforms to this interface'
04:03:06 <wolverian> hm. how crack is this: a class Seq (name not important), with instances List and SortedList. would allow a member function ordered :: a -> Boolean to return without computation for the SortedList case.
04:03:06 <quicksilver> it's not only lists, of course, but that's a common example
04:03:14 <EvilRanter> yes, i get that much.
04:03:41 <ClaudiusMaximus> is there something like Data.Dynamic that supports polymorphic values?
04:03:43 <EvilRanter> but trying to do the obvious doesn't seem to quite work for me
04:03:46 <opqdonut> wolverian: can't you just define it as True for the SortedList instance?
04:04:03 <wolverian> opqdonut, that was the point, yes.
04:04:10 <wolverian> opqdonut, that is, that's what I meant. :)
04:04:22 <opqdonut> ah, sorry i misread you
04:04:31 <wolverian> but that's not how it's defined, so I'm wondering if my idea is somehow crazy.
04:04:47 <opqdonut> as "hm. how to crack this:" so i thought you were presenting a problem :)
04:05:17 <wolverian> ah. :)
04:06:07 <EvilRanter> > id :: forall a. a -> a
04:06:08 <lambdabot>  Parse error
04:06:17 <EvilRanter> huh. lambdabot has no existentials?
04:07:11 <pharm> Hah. I had a language with first class modules in it once: they were a right pain.
04:07:31 <pharm> (never did quite get them working right...)
04:10:49 <opqdonut> (.text+0x22): undefined reference to `__stginit_ZCMain'
04:10:52 <opqdonut> when compiling
04:11:14 <Lemmih> opqdonut: Missing 'Main.main'?
04:11:38 <opqdonut> huh?
04:11:53 <opqdonut> ah, module Main where main=
04:12:22 <opqdonut> didn't remember the module had to be main too :)
04:12:34 <EvilRanter> pharm, first class modules? SML has something vaguely related, i think...
04:13:19 <EvilRanter> (specifically, i seem to recall you can have parameterised modules that take another module as a parameter)
04:13:48 <opqdonut> woah
04:13:50 <opqdonut> sounds deep
04:14:12 <EvilRanter> it's part of their way of dealing with not having typeclasses, i think ;]
04:14:24 <quicksilver> EvilRanter: LB has foralls, yes
04:14:31 <quicksilver> EvilRanter: but it's an expression evaluator
04:14:40 <EvilRanter> import Num (Integer); import Num (Real); etc
04:14:42 <quicksilver> EvilRanter: just typing in a type signature is meaningless for it
04:14:55 <pharm> EvilRanter: yeah, I got half-way to the modules being first class, then realised I didn't understand the consequences well enough...
04:14:57 <EvilRanter> (of course, that particular case doesn't really occur, but i think that's the idea)
04:16:19 <DRMacIver> EvilRanter: That's something of a mischaracterisation. :) (Also they're not first class, just higher order. Successor ML is looking to fix this)
04:16:34 <EvilRanter> > id :: a -> a -- quicksilver, I'm not sure what you mean
04:16:35 <lambdabot>  Add a type signature
04:16:50 <quicksilver> EvilRanter: that's not an expression
04:17:05 <quicksilver> EvilRanter: that's just a type annotation
04:17:08 <EvilRanter> DRMacIver, okay. i never learnt ML properly, so i wouldn't be surprised if a certain amount of nonsense snuck in
04:17:18 <quicksilver> > id (+1) 1
04:17:21 <lambdabot>  2
04:17:23 <quicksilver> ^^ that's an expression
04:17:27 <EvilRanter> > True :: Bool -- and this?
04:17:29 <lambdabot>  True
04:17:33 <quicksilver> that's an expression
04:17:39 <EvilRanter> um.
04:17:41 <quicksilver> expressions have values
04:17:55 <quicksilver> oh, I see
04:18:02 <quicksilver> you're trying to evalute a particular instance of id?
04:18:05 <quicksilver> I understand now
04:18:19 <EvilRanter> i'm trying to get my head around the syntax/usage of forall
04:18:40 <quicksilver> it's type syntax
04:18:50 <quicksilver> and LB isn't a good place to experiment with type syntax
04:19:00 <quicksilver> since it's essentially a value evaluator :)
04:20:03 <EvilRanter> my initial experiment was trying to write "map typeOf :: [forall a. Typeable a => a] -> [TypeRep]" and then figure out why that didn't work
04:20:52 <jethr0> huh, did you just put the "forall" into the list brackets?
04:21:26 <EvilRanter> in my first attempt, yes
04:21:35 <jethr0> i'm really not that good with the whole typing shebang, but shouldn't it look something like " :: forall a . Typeable a => [a]" ??
04:21:43 <quicksilver> EvilRanter: you can't do that, you need to mediate it via a constructor
04:22:04 <quicksilver> EvilRanter: even with teh GHC extensions switched on, you can't have an existential without a constructor
04:22:23 <quicksilver> it's syntactically ricky for the compiler to work out when you're "unwrapping"
04:22:25 <vincenz> jethr0: PING
04:22:25 <EvilRanter> jethr0, that means, "for all types 'a', if 'a' is typable, a list of 'a's", rather than "a list of all types 'a' that are typable"
04:22:31 <jethr0> hey vincenz
04:22:44 <jethr0> just came back from my 10 day holiday to italy
04:22:51 <vincenz> jethr0: you still in, right?
04:22:53 <quicksilver> EvilRanter: actually, it doesn't :)
04:22:55 <jethr0> yup
04:23:03 <vincenz> ok
04:23:11 <EvilRanter> well, it looks like it should mean that.
04:23:15 <quicksilver> EvilRanter: what you wrote means "given a list of things which can behave as any type 'a' if a is Typeable'
04:23:29 <jethr0> have you guys planned anything concrete yet? or are we all waiting for the problem announcement
04:23:32 <vincenz> yes
04:23:34 <vincenz> we have
04:23:38 <vincenz> follow instructions please :)
04:23:39 <quicksilver> EvilRanter: you want exists not forally, there (but exists is not a keyword)
04:24:03 <EvilRanter> ah, i recall someone mentioning this weirdness
04:24:25 <quicksilver> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#universal-quantification
04:24:27 <lambdabot> Title: 7.4. Type system extensions, http://tinyurl.com/uxvor
04:24:38 <quicksilver> "There is one place you cannot put a forall: you cannot instantiate a type variable with a forall-type. So you cannot make a forall-type the argument of a type constructor. So these types are illegal:
04:24:45 <quicksilver> x1 :: [forall a. a->a]
04:25:14 <EvilRanter> aha. it'd help if i'd RTFM properly. ;p
04:25:21 <quicksilver> EvilRanter: anyhow, you want this bit : http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#existential-quantification
04:25:22 <lambdabot> Title: 7.4. Type system extensions, http://tinyurl.com/uxvor
04:25:27 <ToRA> quicksilver - is that impredicativity?
04:25:53 <quicksilver> EvilRanter: you want data AnyTyp = forall a . Typeable a => AnyTyp a
04:26:14 <opqdonut> is there a debian package somewhere for the uDraw thing that gprof depends on?
04:26:15 <quicksilver> then you can write [AnyTyp] -> [TypeRep]
04:27:14 <dolio> ToRA: I think so. GHC 6.7 with -fglasgow-exts will let you write '[id] :: [forall a. a -> a]'
04:27:33 <EvilRanter> ...right. then the application of it would look like typesOf [AnyTyp True, AnyTyp 'a', AnyTyp 0, ...], rather than typesOf [True, 'a', 0, ...], right?
04:27:50 <EvilRanter> (for an appropriate "typesOf)
04:28:02 <quicksilver> that's right
04:28:19 <quicksilver> which helps haskell's current type inferrer make sense of it
04:28:37 <EvilRanter> quicksilver++
04:28:38 <EvilRanter> thanks
04:28:44 <quicksilver> There are surely more complex type inference algorithms which enable approaches more like your second suggestion
04:28:50 <quicksilver> but, I suspect, there be ogres also
04:29:19 <EvilRanter> . o O ( "og res"? ... ohhh... )
04:33:40 <mux> I need to give that IsString type-class a try
04:34:18 <ToRA> dolio: ah wow, thanks for that
04:36:18 <dolio> ToRA: let g :: [forall a. a -> a] -> (Int, String) ; g l = (head l 5, head l "5") in g [id]
04:36:23 <dolio> Gives the expected result.
04:36:43 <dolio> And fails without the 'forall a.' of course.
04:37:50 <ToRA> indeed
04:38:32 <ToRA> that's not a ghc 6.7 thing tho
04:38:44 <dolio> It probably works in ghc 6.6, too.
04:39:00 <ToRA> @type let g :: [forall a. a -> a] -> (Int, String) ; g l = (head l 5, head l "5") in g [id]
04:39:02 <dolio> And maybe 6.4. I can't remember when they added impredicativity.
04:39:02 <lambdabot> [forall a. a -> a] -> (Int, String) ; g l = (head l 5, head l "5") in g [id] :: (Int, String)
04:39:25 <ToRA> > let g :: [forall a. a -> a] -> (Int, String) ; g l = (head l 5, head l "5") in g [id]
04:39:25 <lambdabot>  Parse error
04:40:13 <ToRA> yeah, so a in [a] being bound to something universally quantified is the impredicativity bit, but it has to be explicitly annotated?
04:41:14 <dolio> Yeah. GHC doesn't infer any higher ranked types, I think.
04:41:53 <sioraiocht> okay, so after reading a post on haskell-cafe--- (*) for integers uses FFT algorithms for fast multiplication?
04:41:59 <sioraiocht> I take it (^) would, too?
04:44:13 <quicksilver> FFT?
04:44:15 * quicksilver looks confused
04:44:37 <sioraiocht> sorear wrote: If you're using the standard Schoenhage-Strassen algorithm, you might
04:44:39 <sioraiocht> try using (*) on Integer - it uses Schoenhage-Strassen internally and is
04:44:41 <sioraiocht> already debugged.
04:44:51 * quicksilver nods
04:45:08 <quicksilver> it's GMP, basically
04:45:10 <dolio> ToRA: Or, I guess it infers some obvious ones, but if something can have a lower-ranked type, it will infer it.
04:45:28 <sioraiocht> I think GMP's FFT's are considered lamentably slow
04:45:38 <quicksilver> schoenhage-strassen is not a FFT though, I don't think
04:46:06 <quicksilver> oh, I see. It is actually, one over a bounded ring
04:46:07 <sioraiocht> yes it is
04:46:10 <quicksilver> live and learn
04:46:11 <ToRA> dolio: yeah, i remember reading somewhere that there is no general inference mechanism for > (maybe >=) rank-2 types, so that would make sense
04:46:21 <sioraiocht> http://en.wikipedia.org/wiki/Sch%C3%B6nhage-Strassen_algorithm
04:46:22 <lambdabot> Title: Schnhage-Strassen algorithm - Wikipedia, the free encyclopedia
04:46:44 <quicksilver> dolio: I don't think it infers any high ranked types, at all
04:47:12 <dolio> quicksilver: Well, if 'g' is higher ranked, then 'f _ = g' will get a higher-ranked type automatically.
04:47:27 <dolio> But I don't know how far that extends.
04:47:32 <quicksilver> hmm
04:47:35 <quicksilver> I see what you mean
04:47:41 <quicksilver> that's not really 'inferring' it as such though :)
04:47:53 <quicksilver> that's just unifying an unbound type variable with one
04:48:01 <dolio> Yeah.
04:49:19 <dolio> ToRA: From what I've heard, rank-2 is decidable, rank-n is undecidable.
04:49:48 <quicksilver> rank-2 is decidable but there's still something undesirable about it
04:49:52 <quicksilver> I don't recall what :)
04:51:00 <dolio> At the very least, I could see type signatures becoming more complex in general.
04:51:12 <wli> Okay, badass.
04:51:36 <gattocarlo> hi! I need a Read instance for an existentially quantified data constructor, but I seem to be missing something. I know I cannot derive the Read instance for MyType, but I though it should be easy to write a parser for it. No way. Could someone please have a look? http://hpaste.org/1582
04:51:37 <dolio> It wouldn't surprise me if a lot of functions could take more general rank-2 types than the ones we usually associate them with.
04:51:40 <wli> I have Cantor tupling functions for integers for arbitrary dimension.
04:51:47 <wli> s/integers/naturals/
04:51:48 <ToRA> ah, i just found the Practical type inference for arbitary-rank types paper (spj et. al, feb 2007) sitting on my todo pile, i assume that's were i read it and would contain all the answers which i seek
04:53:23 <quicksilver> dolio: well yes, like 'build'
04:54:03 <quicksilver> dolio: and then you have to make some decision I suppose about which type you "prefer"
04:57:17 <dolio> I suppose the fact that functions like '\w -> w w' have a rank-2 type might also lead to your catching fewer bugs.
04:57:34 <dolio> Assuming that recursive types usually are an error.
04:59:15 <swiert_> Does anyone know the status of infix type constructors for Haddock?
04:59:32 <swiert_> At the moment, I keep getting parse errors, which are a bit annoying.
05:27:48 <Syzygy-> How do I get the GHC profiler to stop chopping off cost-centre names for me?
05:31:42 <bluestorm> hm
05:34:57 <bluestorm> are you aware of peoples using Haskell in cricital systems ?
05:35:42 <bluestorm> seems there is a lot of stuff concerning Ada, but i thought purely functional systems may be interesting there
05:35:43 <quicksilver> for some values of 'critical', yes
05:35:54 <quicksilver> people are definitely using haskell in financial systems
05:36:02 <quicksilver> Credit Suisse do, I believe
05:36:23 <quicksilver> I'm not aware of people using it in realtime-critical stuff like power plant management or shuttle flight though ;)
05:37:15 <bluestorm> are there people working on statistical analysis or such things ?
05:37:19 <Syzygy-> So .... profiling with +RTS -p -hy -xt gives me a pretty much constant TSO section. This is to be interpreted as that my code has marginal to no stack growth problem, right?
05:37:21 <bluestorm> i heard of Catch
05:37:39 <bluestorm> hm
05:37:43 <quicksilver> http://www.haskell.org/haskellwiki/Haskell_in_industry
05:37:45 <lambdabot> Title: Haskell in industry - HaskellWiki
05:38:27 <bluestorm> on the other hand, lazy evaluation may make it difficult to give time and memory bounds
05:38:27 <wli> http://holomorphy.com/~wli/Tuple.hs
05:38:47 <DRMacIver> Haskell is so far from realtime that it's not even funny. :)
05:39:37 <Syzygy-> DRMacIver: Hehehehe
05:39:55 <DRMacIver> Given that one of the big things you need to do when making an API realtime is remove everything that could possibly be lazy.
05:40:07 <pastorn> @where haskelldb
05:40:07 <lambdabot> http://haskelldb.sourceforge.net/
05:40:10 <roconnor> bluestorm: I never found time bounds to be too hard to estimate in Haskell.
05:40:58 <bluestorm> hm
05:41:10 <quicksilver> bluestorm: I think it's mostly a question of what you're used to
05:41:43 <bluestorm> hm
05:43:12 <bluestorm> "information security" looks like a good area
05:43:32 <bluestorm> as there is not so much speed or real-time requirements
05:43:45 <DRMacIver> quicksilver: Well, it also depends on what your requirements are.
05:43:49 <bluestorm> and sophisticated type systems may be useful
05:51:20 <wli> refresh http://holomorphy.com/~wli/Tuple.hs
05:56:15 <dons> bluestorm: re. critical systems + haskell, see galois.com
05:56:40 <bluestorm> yes, that's why i was looking at
05:56:59 <dons> ah good.
05:57:13 <dons> there's a fair bit of research in this area too
05:57:15 <wli> Isn't there some form where there's no longer a distinction between lazy and strict?
05:57:38 <dons> bluestorm: http://haskell.org/haskellwiki/Research_papers/Testing_and_correctness#Verifying_Haskell_programs
05:57:40 <lambdabot> Title: Research papers/Testing and correctness - HaskellWiki, http://tinyurl.com/27sq72
05:58:02 <bluestorm> s/why/what/
06:01:14 <Nucleo> @pl nubBy(((>1) .) . gcd) [2..]
06:01:15 <lambdabot> nubBy (((> 1) .) . gcd) [2..]
06:03:38 <Nucleo> actually, can anyone explain to me how nub manages to work on an infinite list like that?
06:03:45 <Syzygy-> Is it correct to say that . left-associates and $ right-associates? Or is it the other way aroudn?
06:03:51 <Nucleo> I understand how the composites get thrown out
06:04:13 <dcoutts> @seen sjanssen
06:04:14 <lambdabot> I saw sjanssen leaving #haskell, #xmonad and #haskell-icfp07 4d 14h 28m 41s ago, and .
06:04:49 <dcoutts> Syzygy-: ask ghci, :info .
06:04:57 <Nucleo> but how does nub know that the primes are primes, and that there aren't things down the line that DO divide them?
06:05:59 <quicksilver> Nucleo: nub only eliminates adjacaent 'duplicates'
06:06:06 <quicksilver> Nucleo: it doesn't scan the whole list for them
06:06:16 <quicksilver> nub [1,1,1,2,3,1,1]
06:06:16 <Syzygy-> dcoutts: So there is also the issue that one expects a function and the other an entity...
06:06:18 <quicksilver> > nub [1,1,1,2,3,1,1]
06:06:24 <lambdabot>  [1,2,3]
06:06:25 <roconnor> @quote learn language
06:06:25 <lambdabot> No quotes for this person. Listen, broccoli brains, I don't have time to listen to this trash.
06:06:35 <quicksilver> oh, what I said isn't true
06:06:37 * quicksilver ponders
06:06:47 <dcoutts> Syzygy-: hmm? what do you mean?
06:07:08 <dcoutts> Syzygy-: you're talking about the types of (.) and ($) ?
06:07:10 <Syzygy-> Prelude Control.Monad> :info .
06:07:10 <Syzygy-> (.) :: (b -> c) -> (a -> b) -> a -> c   -- Defined in GHC.Base
06:07:10 <Syzygy-> infixr 9 .
06:07:10 <Syzygy-> Prelude Control.Monad> :info $
06:07:10 <Syzygy-> ($) :: (a -> b) -> a -> b       -- Defined in GHC.Base
06:07:11 <quicksilver> Nucleo: nub builds up a massive closure for later in the list
06:07:12 <Syzygy-> infixr 0 $
06:07:15 <Syzygy-> Yah.
06:07:46 <Syzygy-> dcoutts: Basically, what I'm doing, is building the last bit of the "Neckbreaking introduction to Haskell code for mathematicians"-chapter in one of the papers I'm currently preparing.
06:08:00 <Syzygy-> And I want a 2-sentence introduction of . and $ that makes people able to read my code.
06:08:06 <quicksilver> Syzygy-: . and $ are totally different, it's a "real theorem" that you can replace one with the other
06:08:07 <dcoutts> Syzygy-: sounds fun :-)
06:08:24 <quicksilver> Syzygy-: not, admittiedtly, a particularly hard one
06:08:31 <quicksilver> Syzygy-: but it isn't obvious at first glance
06:08:44 <Syzygy-> quicksilver: And in my humble opinion, the subtleties of that will be lost on the audience of this paper.
06:08:49 <Syzygy-> dcoutts: Wanna read a draft?
06:08:51 <dcoutts> Syzygy-: so all mathematicians understand function composition, so that one is easy.
06:08:59 <Syzygy-> dcoutts: http://mpc723.mati.uni-jena.de/~mik/SaneblidzeUmble.pdf
06:09:21 <dcoutts> Syzygy-: would love to, but I really don't have time. I've got to finish corrections to one of my own papers.
06:09:21 <quicksilver> Syzygy-: mathematicians are quite used to rewriteing (f(g(h(x))) as (f o g o h) x
06:09:31 <Syzygy-> dcoutts: My first sentence was basically "both are function composition, though one right- and the other left-associates" and I wanted to figure out which would be which.
06:09:32 <quicksilver> Syzygy-: you see that transformation all over
06:09:41 <Nucleo> quicksilver: I'm not conceptually understanding how nubBy evals the infinite list, though.
06:09:56 <Nucleo> Does it 'know' that the list is sorted given the enumFromTo, and use the logic of that with gcd?
06:09:57 <quicksilver> Nucleo: starting at the left, and only going as far as it needs to
06:10:00 <dcoutts> Syzygy-: so the only odd one is $ which is function application, but as an operator and with 'backwards' associativity
06:10:20 <dcoutts> and we use it like syntax to avoid brackets sometimes
06:10:42 <dcoutts> like instead of f (very long expression) we say f $ very long expression
06:10:55 <dcoutts> especially if that long expression takes several lines
06:11:09 <dcoutts> or is a lambda
06:11:12 <Nucleo> quicksilver: for example
06:11:13 <Nucleo> > nubBy(((>1) .) . gcd) [2,3,4,5,6,7,4]
06:11:15 <lambdabot>  [2,3,5,7]
06:11:23 <Nucleo> so the final "four" is also not returned.
06:11:30 <quicksilver> Nucleo: by the type it gets to the final four
06:11:37 <quicksilver> Nucleo: it has built up a closure around it
06:11:57 <quicksilver> Nucleo: saying ( gcd 2 x > 1, gcd 3 x > 1, gcd 4 x > 1, ...)
06:12:05 <quicksilver> Nucleo: and that 'filters out' the four
06:12:30 <quicksilver> @src nubBy
06:12:30 <lambdabot> nubBy eq []             =  []
06:12:30 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
06:12:30 <Nucleo> quicksilver: I think I'm starting to understand.
06:12:40 <quicksilver> Nucleo: the 'filter' in the definition
06:12:42 <quicksilver> Nucleo: they all stack up
06:12:49 <Syzygy-> dcoutts: You can always file it off for leisurely reading when your own stuff gets too annoying.
06:12:56 <quicksilver> Nucleo: as you get far down the list, you have a great big chain of 'filters' around your thunk
06:12:59 <Nucleo> So this then would be a faithful interpretation of prime sieves on any list.
06:13:19 <quicksilver> I won't debate whether or not it's a true sieve
06:13:27 <quicksilver> but yes, in princiiple :)
06:13:36 <Nucleo> I think I get the idea. Thank-ya :)
06:13:41 <dcoutts> Syzygy-: heh, thanks :-)
06:14:22 <Nucleo> quicksilver: I will point out that
06:14:25 <Nucleo> > nubBy(((>1) .) . gcd) [3,4,5,6,7,4,2]
06:14:27 <lambdabot>  [3,4,5,7]
06:14:28 <araujo> morning
06:14:39 <Nucleo> so it does require an ordered list, or it comes back with composites, I guess.
06:14:39 <psymort> does anyone know if hat works with ghc 6.6.1?
06:14:42 <quicksilver> Nucleo: yes, because it "thinks" 4 is primoe
06:14:50 <quicksilver> Nucleo: because it didn't find any divisors of 4 before it
06:15:01 <quicksilver> Nucleo: and then it filters out the 2, because gcd 4 2 == 1
06:15:02 <Nucleo> quicksilver: so it's really NOT looking after the 4.
06:15:08 <quicksilver> right
06:15:25 <malcolmw> psymort: there are some minor fixes needed for the build/install process, but otherwise, yes, it can be made to work with ghc-6.6.1
06:15:37 <Nucleo> quicksilver: ahhh, okay, thanks. :)
06:15:44 <roconnor> @quote forbid
06:15:44 <lambdabot> roconnor says: god forbid people having to learn a new language when learning a new language.
06:15:49 <quicksilver> so it prints out those items which are 'relatively prime at their first occurance'
06:15:52 <quicksilver> or something
06:16:07 <psymort> malcolmw: any pointers?  Or just check out CVS?
06:16:28 <malcolmw> psymort: probably the best chance is to use the darcs repo, yes
06:16:53 <malcolmw> psymort: do you need to use any libraries outside the haskell'98 standard ones?
06:17:30 <psymort> malcolmw:no - I'm just playing with it
06:18:25 <malcolmw> I think the darcs repo should build and install correctly - but we have a SoC student working on fixing any problems, so bug reports would be welcome
06:19:11 <psymort> cool
06:20:11 <wli> refresh (once again) http://holomorphy.com/~wli/Tuple.hs
06:27:55 <Syzygy-> timbod: Poke?
06:27:56 <pejo> wli, programming Haskell in your sparetime?
06:28:09 <wli> pejo: Not that I have any.
06:30:43 <ndm> @seen dons
06:30:43 <lambdabot> dons is in #xmonad, #haskell and #ghc. I last heard dons speak 33m 5s ago.
06:30:56 <ndm> ping dons
06:31:00 <vincenz> ndm: thx for input
06:31:17 <ndm> vincenz: remind me again on what?
06:31:21 <vincenz> ndm: blog?
06:31:30 <vincenz> flatten N-ary trees
06:31:32 <vincenz> my rather lame article
06:31:33 <ndm> vincenz: ah yes :) - no probs, -O3 is known to be crap
06:31:38 <vincenz> didn't knkow that :)
06:31:40 <vincenz> I plan to do it ASAP
06:31:44 <vincenz> but it took me like 20 minutes
06:31:52 <vincenz> of manually getting the results into some sort of format for the spreadsheet
06:31:57 <vincenz> and several hours of running :/
06:36:26 <vincenz> ndm: hmm simple question.  I want to force the 'complexity' function without outputting it.  That way I could more cleanly compile my results to import into a spreadsheet, any suggestions?
06:39:03 <EvilRanter> ?docs Control.Exception
06:39:03 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html
06:39:07 <EvilRanter> see "evaluate"?
06:39:09 <ndm> vincenz: not quite sure what you are asking, typically to force the results i do length (show x) `seq`
06:39:26 <vincenz> I'll try `seq` in
06:39:31 <ndm> vincenz: and if you produce comma separated values or tab separated values spreadsheets usually work
06:39:38 <vincenz> ndm: basically I want to force construction of the tree
06:40:18 <ndm> vincenz: evaluate, as EvilRanter says, is the official way, i still do the length (show x)  `seq` trick, because i can understand how that works better
06:41:08 <ndm> evaluate undefined
06:41:10 <ndm> > evaluate undefined
06:41:11 <lambdabot>   Not in scope: `evaluate'
06:41:46 <gattocarlo> it is not possible to read existential data types, am I right?
06:41:56 <ndm> vincenz: do not use evaluate, it only does head-normal-form, not deep seq, which is what you need
06:43:38 <vincenz> ok
06:43:48 <vincenz> I force deep seq by calculating the complexity
06:44:04 <EvilRanter> clarification: do you want some function "force" such that "force [1..]" is _|_?
06:45:06 <EvilRanter> (ie a function that, once it returns, you know there are no _|_s or infinite structures in the parameter)
06:46:15 <vincenz> ndm: but ot actually force it in the monad, I need to print the return value
06:46:57 <vincenz> ah, so evaluate will help
06:47:09 <vincenz> evaluate $ complexity tree
06:48:16 <EvilRanter> if putting "complexity tree" in HNF forces everything you need forced
06:48:33 <vincenz> yep
06:50:39 <mattam> Is "purported" a negative expression ?
06:52:18 <quicksilver> not really
06:52:53 <EvilRanter> a bit
06:53:27 <EvilRanter> see http://wordnet.princeton.edu/perl/webwn?s=purported , first defn
06:53:28 <lambdabot> Title: WordNet Search - 3.0
06:53:31 <mattam> http://dictionary.reference.com/browse/purported
06:53:32 <lambdabot> Title: purported - Definitions from Dictionary.com
06:54:58 <mattam> Ok, so I would say it has a negative bias :)
06:55:22 <scook0> depends on context, I guess
06:55:43 <mattam> As always...
06:55:49 <scook0> If you say it about someone else's claims, it's most likely a negative
06:56:42 <scook0> but you could also use it as a neutral marker for uncertainty
06:56:56 <mattam> Yep, I am in the first situation.
07:01:05 <greenrd> When should I use foldl' and when should I use foldl instead?
07:01:56 <scook0> iirc, the time to use foldl is "never"
07:02:17 <vincenz> afaik, yes
07:02:17 <vincenz> foldl is pretty useless w.r.t. foldl'
07:02:22 <vincenz> foldr, otoh, -is- useful, cause you can use it for infinite lists
07:02:23 <scook0> the general rule is to use foldl' for strict operations, and foldr for lazy ones
07:02:33 <Japsu> @src (@)
07:02:33 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
07:03:03 <scook0> Japsu: as-patterns?
07:03:21 <ndm> @pl \xs pss -> do y <- choose xs ; ys <- pss ; [y:ys]
07:03:22 <lambdabot> (line 1, column 30):
07:03:22 <lambdabot> unexpected ";"
07:03:22 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
07:03:27 <Japsu> scook0: "t@(s,[])" <- what's that?
07:03:34 <ndm> @undo \xs pss -> do y <- choose xs ; ys <- pss ; [y:ys]
07:03:34 <lambdabot> \ xs pss -> choose xs >>= \ y -> pss >>= \ ys -> [y : ys]
07:03:39 <ndm> @pl \ xs pss -> choose xs >>= \ y -> pss >>= \ ys -> [y : ys]
07:03:39 <lambdabot> (. ((. flip (flip . ((:) .) . (:)) []) . (>>=))) . (>>=) . choose
07:04:09 <Japsu> ah
07:04:10 <Japsu> right
07:04:52 <EvilRanter> > (\ p@(a, b) -> (p, a, b)) (1, 2)
07:04:54 <lambdabot>  ((1,2),1,2)
07:05:11 <ndm> @pl \ xs pss -> pss >>= \ ys -> choose xs >>= \ y -> [y : ys]
07:05:11 <lambdabot> (=<<) . (. flip (flip . ((:) .) . flip (:)) []) . (>>=) . choose
07:05:20 <EvilRanter> the pattern "<name> @ <pattern>" binds <name> to everything matched by <pattern>
07:05:34 <scook0> heh, I remember being mystified by those when I first saw them
07:05:47 <scook0> not the easiest thing to look up, either
07:05:51 <ndm> @hoogle @
07:05:52 <lambdabot> Test.HUnit.Base.(
07:05:52 <lambdabot> Test.HUnit.Base.(
07:05:52 <lambdabot> Test.HUnit.Base.(
07:06:01 <ndm> hmm, Hoogle 4 will let you search for @
07:06:06 <ndm> it already lets you do most syntax
07:06:17 <EvilRanter> ... am I the only one seeing three instances of "Test.HUnit.Base.(" there?
07:06:20 <ndm> @hoogle ->
07:06:20 <lambdabot> Prelude.-> :: keyword
07:06:20 <lambdabot> Text.Html.(<->) :: (HTMLTABLE ht1, HTMLTABLE ht2) => ht1 -> ht2 -> HtmlTable
07:06:29 <ndm> EvilRanter: no, hoogle 3 has quite a few issues
07:06:53 <EvilRanter> okay. good to know my client's not broken (in that way, at least)
07:11:17 <SamB_XP_> what's a half a paren?
07:11:26 <SamB_XP_> er.
07:11:29 <SamB_XP_> half a pair ;-)
07:11:34 <notadev> is this a jk? hehe
07:11:39 <scook0> is that some kind of zen koan?
07:11:45 <notadev> hehe
07:11:54 <SamB_XP_> no. that output is just wierd.
07:11:56 <scook0> (x, undefined)?
07:12:32 <scook0> it's just hoogle/lb dying horribly, I figured
07:12:39 <SamB_XP_> @doc Test.HUnit.Base
07:12:39 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/HUnit/Test-HUnit-Base.html
07:13:04 * SamB_XP_ wants to see what's actually there that makes lambdabot do that
07:13:26 <SamB_XP_> I suppose...
07:13:52 <SamB_XP_> (@?), (@=?) and (@?=) must be the culprits?
07:14:03 <notadev> you could just look at the code, surely?
07:14:32 <SamB_XP_> notadev: first look at data, then code, generally ;-)
07:14:41 <notadev> bleh
07:14:50 <notadev> depends what you're doing i guess
07:15:09 <SamB_XP_> well, it helps you know what to look for in the code
07:15:13 <notadev> you already know what input causes the error, don't you?
07:15:20 <notadev> sure
07:15:49 <scook0> in this case, knowing that 3 operators begin with @ is useful info
07:16:03 <notadev> true
07:16:51 <syntaxfree> I have to say, roconnor's two-line solution to the xkcd knapsack problem, even if nonterminating, is sexy.
07:17:03 <syntaxfree> I learned a bunch from that single main function. Brilliant design pattern.
07:17:05 <SamB> @seen JohnMeacham
07:17:05 <lambdabot> I saw JohnMeacham leaving #haskell, #haskell-blah and #darcs 6d 4h 42m 8s ago, and .
07:17:16 <SamB> knapsack problem?
07:18:23 <syntaxfree> @tell roconnor I have to say, roconnor's two-line solution to the xkcd  knapsack problem, even if nonterminating, is sexy.
07:18:23 <lambdabot> Consider it noted.
07:18:34 <syntaxfree> @tell roconnor  I learned a bunch from that single main function. Brilliant                     design pattern.
07:18:34 <lambdabot> Consider it noted.
07:18:58 <SamB> "                     " -- that's a lot of space...
07:19:03 <syntaxfree> I wonder what's the time complexity of that?
07:19:18 <SamB> which xkcd are we talking about here?
07:19:31 <LeCamarade> syntaxfree: Link?
07:19:38 <scook0> http://programming.reddit.com/info/24p2c/comments
07:19:39 <lambdabot> Title: xkcd - Does anyone else feel compelled to solve this? (reddit.com)
07:20:43 <SamB> that's a knapsack problem?
07:20:53 <syntaxfree> for a while I thought I could make it terminate adding takeWhile (liftM (<1505))
07:20:59 <syntaxfree> for a few seconds, of course.
07:21:01 <SamB> how did he get his code so short?
07:21:08 <SamB> oh, by not terminating, right...
07:21:16 <syntaxfree> it's simple. he builds a list of actions.
07:21:18 <scook0> SamB: and the magic of the list monad, of course
07:21:21 <syntaxfree> to be fuzzy.
07:21:55 <syntaxfree> I had a factorial version that built a list of functions and folded them down.
07:22:07 <syntaxfree> I should write one that builds a list of monadic actions and folds them down.
07:22:08 <SamB> I'm copping his menu ;-)
07:22:17 <syntaxfree> copping?
07:22:23 <SamB> stealing
07:22:24 <notadev> stealing ;)
07:22:27 <notadev> oops
07:22:34 <SamB> what "oops"
07:22:34 <syntaxfree> SamB: oh, for your own solution?
07:22:56 <syntaxfree> I'm doing the opposite. I'm finding a large prime to see how long it takes to solve.
07:26:32 <syntaxfree> the list monad is really something.
07:26:39 <roconnor> syntaxfree: thanks
07:26:39 <lambdabot> roconnor: You have 2 new messages. '/msg lambdabot @messages' to read them.
07:27:24 <EvilRanter> @where+ @ http://www.haskell.org/tutorial/patterns.html
07:27:24 <lambdabot> Done.
07:28:26 <quicksilver> syntaxfree: it turns out to be an extremely common pattern
07:28:36 <mauke> > replicateM 2 "abc"
07:28:38 <lambdabot>  ["aa","ab","ac","ba","bb","bc","ca","cb","cc"]
07:28:41 <syntaxfree> when I first saw the cartoon I thought of constructing the powerset and applying it on the menu.
07:28:42 <quicksilver> syntaxfree: 'process over a "tree" of alternatives'
07:29:02 <syntaxfree> quicksilver: I turn out to be an extremely clueless person :)
07:29:15 <quicksilver> > [0..] >>= flip replicateM "abc"
07:29:17 <lambdabot>  ["","a","b","c","aa","ab","ac","ba","bb","bc","ca","cb","cc","aaa","aab","aa...
07:29:24 <quicksilver> syntaxfree: that you are not :P
07:29:39 <syntaxfree> but that's basically the prolog approach I guess.
07:29:51 <roconnor> syntaxfree: I now think the right thing to do is more like what panic does.
07:29:57 <vincenz> syntaxfree: I thought of powerset approach too, then I thought "are we alloed to have dupliciates"?
07:29:58 <syntaxfree> building a tree of possibilities and backtracking through it.
07:30:14 <roconnor> nondeterministically pick a menu item, and decrement the total by the price of the item.
07:30:21 <quicksilver> syntaxfree: the great thing about laziness is that it never actually builds that tree
07:30:25 <roconnor> repeat until you reach zero or below.
07:30:31 <SamB> I like to use a real tree ;-)
07:31:19 <vincenz> SamB: made of wood?
07:31:27 <SamB> data Tree a = Node a [Tree a] deriving Show
07:31:55 <vincenz> SamB: N-ary tree :)
07:32:00 <vincenz> check my blog :)
07:32:15 <vincenz> though you want
07:32:20 <syntaxfree> what's the difference between an N-ary tree and a rose tree?
07:32:21 <vincenz> data Tree a = S a | P [Tree a]
07:32:24 <sioraiocht> The set of all integers, combined with (*) and (+) is a ring, right?
07:32:42 <SamB> vincenz: no, I like to label all of my nodes
07:32:43 <roconnor> sioraiocht: correct.
07:32:44 <syntaxfree> sioraiocht: if they satisfy some intuitive properties, yes.
07:32:44 <vincenz> n-ary just means "like a binary, but replace 'bin' (2) by any number you want"
07:33:03 <vincenz> SamB: You can't have empty trees
07:33:09 <syntaxfree> I think it has to be closed as well. if a \in S and b \in S then a [*, +] b \in S
07:33:14 <SamB> vincenz: so?
07:33:18 <quicksilver> sioraiocht: Right, a ring just has to be closed under (*) and (+) and have identities and (+)-inverses
07:33:21 <vincenz> Just pointinig it out
07:33:23 * vincenz shrugs
07:33:33 <sioraiocht> quicksilver: thanks =)
07:33:38 <quicksilver> sioraiocht: so any closed subset is a ring too, like 'multiples of 2'
07:33:38 <roconnor> The integers are the inital ring
07:33:49 <SamB> true, though, I can't
07:33:55 <sioraiocht> quicksilver: that's kinda fun, lol
07:34:04 <sioraiocht> quicksilver: is a finite field considered a ring, then?
07:34:08 <roconnor> rings need a multiplicative identity ... although some people disagree.
07:34:17 <vincenz> the other option is Emp | Node a [Tree a], but then you have redundant formulations of empty sub-trees
07:34:21 <vincenz> namely
07:34:21 <roconnor> and those people who disagree are wrong.
07:34:25 <syntaxfree> now I forget how a ring becomes a field?
07:34:26 <vincenz> Node a [] or Node a [Emp, ... Empy]
07:34:31 <quicksilver> syntaxfree: division
07:34:34 <edwardk> i kind of like the 'rng' notation for a ring without identity
07:34:38 <syntaxfree>  ahhhh, yes.
07:34:39 <cjeris> ^ what edwardk said
07:34:46 <edwardk> diego: multiplicative inverses
07:34:53 <cjeris> (i met it in jacobson's Basic Algebra I; did he originate it?)
07:34:54 <roconnor> a ring is a field if every number apart from 0 has a multiplicative inverse.
07:34:58 <syntaxfree> how the hell edwardk knows my name? :)
07:35:05 <edwardk> hahah
07:35:17 <roconnor> edwardk: rings without identity are usually called ideals.
07:35:30 <cjeris> roconnor: ???
07:35:48 <roconnor> yep
07:35:54 <cjeris> not in any algebra book i've ever met
07:36:06 <edwardk> roconnor: the rng thing is just something that seems to be catching on more these days and you have to admit its a nice mnemonic for a ring without an i..
07:36:07 <ok> test
07:36:18 <roconnor> edwardk: maybe I'm just old
07:36:18 <cjeris> ideal = multiplicatively absorbing additive subgroup.
07:36:28 <sek> well ideals are indeed rings without identity, not necessarily vice versa
07:36:42 <roconnor> sek: not vice versa?
07:36:51 <edwardk> roconnor: yeah, took me a while to adjust to the new term myself
07:36:55 <roconnor> crap
07:37:25 <sek> roconnor, you know the defn of an ideal saying \forall i \in I, r\in R we have ri \in I where I an ideal of R
07:37:38 <roconnor> edwardk: I'm getting used to c.e sets.
07:38:07 <sek> it does indeed turn out that ideals are non unitary rings, (and so additive subgroups as cjeris pointed)
07:38:08 <roconnor> sek: yep
07:38:43 <dozer> hi - I'm havig trouble building HXT-7.0
07:38:56 <sek> oh, i thought this was the math channel lol
07:39:12 <edwardk> but thanks for reminding me to try to figure out how to add ideals to numerical tower
07:39:23 <edwardk> er to my
07:39:23 <scook0> sek: that tends to happen here :)
07:39:36 <sek> :-)
07:40:15 <dozer> on "./Setup.lhs build" it says "Program error: '/usr/bin/ar' 'q' 'dist/build/" followed by 40-50 lines of command line and then ": System.syste.m: illegal operation(ilegal system command string)"
07:40:38 <dozer> if I cut and paste the same command into the shell, the command runs
07:43:10 <syntaxfree> I just realized roconnor's solution scales fibonaccily.
07:43:36 <syntaxfree> I tried multiplying the target number by 10 and my computer started crying.
07:44:31 <cjeris> syntaxfree has proven that fibonacci's rabbits lived on onions
07:45:30 <syntaxfree> @type getArgs
07:45:32 <lambdabot> Not in scope: `getArgs'
07:45:35 <syntaxfree> @type getArg
07:45:38 <lambdabot> Not in scope: `getArg'
07:45:44 <ndm> roconnor: you have a 2 line solution to xkcd?
07:45:48 <syntaxfree> gee. what's the name of that?
07:45:53 <scook0> :t System.getArgs
07:45:56 <lambdabot> IO [String]
07:46:05 <syntaxfree> dang, I was hoping it'd be [IO String]
07:46:48 <Syzygy-> :t seq
07:46:49 <lambdabot> forall a t. a -> t -> t
07:46:51 <Syzygy-> :t sequence
07:46:54 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
07:47:03 <Syzygy-> ?hoogle m [a] -> [m a]
07:47:04 <lambdabot> Prelude.repeat :: a -> [a]
07:47:04 <lambdabot> List.intersperse :: a -> [a] -> [a]
07:47:04 <lambdabot> Prelude.(:) :: a -> [a] -> [a]
07:47:07 <quicksilver> :t liftM (zipwith (!!) System.getArgs
07:47:10 <lambdabot> parse error (possibly incorrect indentation)
07:47:16 <roconnor> ndm: http://programming.reddit.com/info/24p2c/comments/c24pc5
07:47:18 <lambdabot> Title: xkcd - Does anyone else feel compelled to solve this? (reddit.com)
07:47:23 <roconnor> but it is non-terminating.
07:47:38 <mauke> you don't need $ (and mapM should be mapM_)
07:48:06 <Syzygy-> Ouch. darcs get ghc-HEAD is a pretty nasty operation....
07:48:12 <Syzygy-> *pulling 16223 patches*
07:48:23 <quicksilver> :t liftM (zipWith (flip (!!)) [0..]) System.getArgs
07:48:26 <lambdabot> IO [Char]
07:48:26 <roconnor> mauke: good point. ... should I edit my comment?
07:48:31 <Nucleo> How does one go about debugging stack overflows?
07:48:32 <scook0> Syzygy-: do a partial get?
07:49:27 <quicksilver> :t (zipWith (liftM $ flip (!!)) [0..]) System.getArgs
07:49:29 <lambdabot>     Couldn't match expected type `[b]'
07:49:30 <lambdabot>            against inferred type `IO [String]'
07:49:51 <Syzygy-> scook0: Yeah, saw that on the wiki just after writing.
07:50:51 <Igloo> http://www.haskell.org/haskellwiki/Hac_2007_II (Hackathon at HW/ICFP?)
07:50:52 <lambdabot> Title: Hac 2007 II - HaskellWiki
07:51:26 <Syzygy-> I assume that the long pause is for darcs to analyze what it really needs?
07:51:36 <dozer> any topic or expertese needed to attend the hackathon?
07:52:32 <dozer> I'd be happy to come and help out writing documentation
07:53:40 <mauke> :t map (flip liftM System.getArgs . flip (!!)) [0 ..]
07:53:42 <lambdabot> [IO String]
07:54:32 <quicksilver> mauke: :)
07:54:39 <quicksilver> mauke: thanks. I was being dumb :P
07:54:56 <EvilRanter> there's gotta be a better way of doing that
07:55:12 <quicksilver> EvilRanter: it's a pretty daft thing to want to do, IMO :)
07:55:35 * EvilRanter ponders the possibility of unsequence :: Monad m => m [a] -> [m a]
07:56:09 <mauke> :t (: []) . liftM head
07:56:11 <lambdabot> forall a (m :: * -> *). (Monad m) => m [a] -> [m a]
07:56:26 <EvilRanter> um. that's not quite what i had in mind.
07:56:33 <mauke> IT IS NOW
07:56:41 <EvilRanter> |\(O.o)/|
07:57:00 <quicksilver> EvilRanter: your breasts are curiously asymmetric
07:57:13 <EvilRanter> those are my eyes
07:57:40 * mauke fondles
07:57:47 <EvilRanter> ...my eyes?
07:57:53 <mauke> yes.
07:59:59 <wli> What exactly does one have to do for this hackathon?
08:00:22 <sjanssen> wli: hack
08:01:56 <wli> I figured that part out from the name.
08:03:40 <earthy> preferably on useful stuff
08:04:26 <wli> Is there going to be someone going around assigning problems? Is it some coding contest? Is it just people getting together and banging out code? etc.
08:04:55 <malcolmw> just a get-together to hack code, nothing formal
08:05:31 <wli> Okay, that answers the question.
08:06:17 <Igloo> I think we might try to have more suggested projects this time round, though, for people who don't have anything in particular they want to get done themselves
08:07:45 <dcoutts_> Igloo: of course I think Cabal is a good one, since it's a bit unloved
08:07:46 <malcolmw> yeah, the value of hacking together is that newcomers can get started into coding with an existing project, with quick bootstrapping due to other developers being nearby
08:08:23 <Igloo> Yup
08:08:32 <dcoutts_> Igloo: and it's such an important infrastructure thing, I include hackage and all that
08:08:47 <dozer> Igloo - if you can find something for me to do at the hackathon, I'll see if I can get there
08:08:50 <malcolmw> are we gonna try for a complete re-implementation from scratch?  ;)
08:08:57 <Igloo> malcolmw: Did you give up on getting it on the front page?
08:09:26 <malcolmw> Igloo: I added it to the events category, but the front page doesn't seem to refresh
08:09:53 <dcoutts_> malcolmw: I'm very happy to rip out and replace internals, yes.
08:10:17 <Igloo> dozer: I'm sure there won't be a lack of things to do. As Duncan says, there's lots of Cabal hacking to be done, and then there is wrigin new library bindings etc in an area that interests you.
08:10:23 <dcoutts_> malcolmw: so long as by the end of the week the overall feature-set is not lower :-)
08:10:33 <malcolmw> week?
08:10:36 <dcoutts_> whatever
08:10:51 <Igloo> malcolmw: I'm not sure if that's the right answer or not, I was just guessing
08:11:03 * Igloo looks for someone who understands how the wiki works
08:11:51 <malcolmw> Igloo: there wasn't anywhere else obvious to add it, so I assume it is supposed to work, but caching is delaying the update or something
08:12:19 <shapr> Good morning #haskell!
08:13:06 <Igloo> Yo shapr
08:13:21 <shapr> y0 y0
08:13:32 <malcolmw> @yarr
08:13:32 <lambdabot> Get out o' me way, yeh landlubber
08:13:40 <quicksilver> why are pirates called pirates?
08:13:48 <quicksilver> because they ARRRRRR!
08:14:17 <shapr> oy!
08:14:32 <Syzygy-> Yo shapr
08:14:36 <shapr> y0 Syzygy-
08:14:38 * shapr boings cheerfully
08:14:44 <shapr> It's a beautiful day for code!
08:14:45 <Syzygy-> shapr: Remember my paper from earlier?
08:14:48 <shapr> yeah?
08:15:28 <Syzygy-> I've gotten to the point where I think it's publication ready. Care to read the section on "Haskell in 10 minutes" for me?
08:15:56 <shapr> I can read it today after work, how's that?
08:17:23 <Syzygy-> Great!
08:17:31 <Syzygy-> http://mpc723.mati.uni-jena.de/~mik/SaneblidzeUmble.pdf
08:17:54 <crazy_code3> hey guys, wanted to ask a thing, Is learning CL worth ? I got some books yesterday, can't decide what to do :(
08:18:38 <Syzygy-> crazy_code3: What kind of answer do you expect from #haskell? ;)
08:18:44 <crazy_code3> Hah
08:19:00 <shapr> crazy_code3: Sure, you should learn Common Lisp... after you learn Haskell!
08:19:11 <crazy_code3> Sure Haskell , but I am having a tough time grasping the concepts of adv Haskell
08:19:25 <mehrheit> what is advanced haskell?
08:19:51 <crazy_code3> like monads, complicated stuff in type classes
08:20:08 <crazy_code3> Am not getting a hold on to it.......seems too confusing
08:20:14 <dylan> monads are two-three functions and syntax sugar.
08:20:40 <vininim> monads are a type of aroows *runs and hide*
08:20:41 <crazy_code3> I am reading a lot of tutorials, but everything new I read, makes things worse.
08:21:00 <mehrheit> crazy_code3, try some practical tutorials
08:21:16 <mehrheit> like solve problem x in haskell step by step
08:21:17 <sjanssen> crazy_code3: do you grasp the beginning concepts of Haskell?
08:21:19 <desp> what's happening with darcs.net?
08:21:39 <crazy_code3> sjanssen: mostly........ ;)
08:22:26 <mehrheit> crazy_code3, how much time has passed since you started learning haskell?
08:23:08 <crazy_code3> sjanssen: I can implement everything which has short fuctions mathematical stuff, list processing etc. But when it comes to making your own data structures, defining instances etc, it starts getting confusing and by the  time I move futher ahead, I am lost
08:23:15 <crazy_code3> 15 days
08:23:49 <vininim> I belive writing tic-tac-toe or nim might be a good exercise to learn haskell
08:23:52 <mehrheit> I would suggest some patience
08:24:29 <sioraiocht> why won't haskell let me do 2^20099983
08:24:37 <sioraiocht> oh wait, n/m..
08:24:41 <sjanssen> > 2^20099983
08:24:46 <crazy_code3> Ah.... when things start getting difficult, I try to learn something new, but this time I want to really learn Haskell in deep......:(
08:24:48 <lambdabot> Terminated
08:24:55 <sioraiocht> I got it calculated
08:25:14 <mehrheit> :t 2^20099983
08:25:17 <lambdabot> forall t. (Num t) => t
08:25:29 <mehrheit> > 2^20099983 :: Integer
08:25:35 <lambdabot> Terminated
08:25:39 <sjanssen> > 20099983 / (8 * 2^10)
08:25:41 <lambdabot>  2453.6112060546875
08:25:55 <Syzygy-> > take 5 $ show $ 2^20099983 :: Integer
08:25:57 <lambdabot>  Couldn't match expected type `Integer'
08:26:01 <Syzygy-> > take 5 $ show $ (2^20099983 :: Integer)
08:26:09 <lambdabot> Terminated
08:26:12 <sjanssen> sioraiocht: the answer will take at least two megabytes of memory :)
08:26:17 <Syzygy-> :P
08:26:25 <sioraiocht> I know, that's okay
08:26:38 <mehrheit> CL seems more complicated than haskell to me
08:26:39 <vininim> > let t = (+ 2) &&& (* 2) in t 3
08:26:41 <lambdabot>  (5,6)
08:28:37 <crazy_code3> where did you guys learn Haskell from ?
08:29:02 <Nucleo> crazy_code3: Yet Another Haskell Tutorial's quite good.
08:29:04 <dylan> I learned haskell via ghci and reading source code
08:29:05 <epid> school
08:29:08 <mehrheit> from the internets
08:29:10 <Botje> YAHT, mostly
08:29:17 <mehrheit> @quote stereo
08:29:18 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
08:29:37 <epid> more like quadraphonic
08:29:57 <mehrheit> I think he meant space by stereo
08:30:23 <vininim> wikibooks tutorial in haskell collects some good info
08:30:24 <mehrheit> crazy_code3, gentle introduction to haskell, while not very gentle, seems to cover most aspects
08:30:32 <mehrheit> quite well
08:31:12 <crazy_code3> Ok thanks
08:31:17 <vininim> haskell's wikibook derive from those tutorials, and I found it relevant (but then I knew a little already)
08:31:33 <crazy_code3> Lets see working hard to get it :)
08:31:40 <mehrheit> http://www.haskell.org/haskellwiki/Hitchhikers_Guide_to_the_Haskell
08:31:44 <lambdabot> Title: Hitchhikers guide to Haskell - HaskellWiki, http://tinyurl.com/fwlz9
08:31:44 <mehrheit> this tutorial is quite amusing
08:32:21 <desp> is there a way to mark certain things with Haddock as explicitly undocumented?
08:32:37 <desp> I want to have something on the export list, but without mentioning it in the docs
08:36:17 * desp coughs
08:36:25 <desp> looks like I scared everyone away
08:36:45 <sjanssen> @smack desp
08:36:45 <lambdabot> Unknown command, try @list
08:36:53 * MyCatSchemes gnaws on desp's skull.
08:37:02 <desp> ow, my skull
08:37:13 <sjanssen> desp: use CPP?  #ifdef HADDOCK ...
08:37:21 <desp> sjanssen: ah, hm
08:37:47 <sjanssen> desp: perhaps a more interesting question: why do you want to do this?
08:37:49 <Syzygy-> How do I tell the ghc source distr. not to build X11?
08:38:08 <Igloo> Syzygy-: delete libraries/X11
08:38:25 <Syzygy-> Ah.
08:38:28 <MyCatSchemes> Or mv it out of the way.
08:38:30 <desp> sjanssen: I want to expose only an opaque type as a handle to the library
08:39:12 <desp> sjanssen: but I also want to expose a function that digs inside said type, for internal use
08:39:22 <desp> without proliferating into more modules
08:39:36 <sjanssen> desp: many libraries use a Foo.Base or Foo.Internal module
08:40:06 <sjanssen> see map (++".Base") ["Data.Array", "Data.ByteString"]
08:40:11 <desp> yeah
08:40:39 <desp> perhaps I should restructure this a bit, but all in good time
08:40:41 <dcoutts_> hia sjanssen, not seen you about for a few days. holiday? :-)
08:41:15 <sjanssen> desp: and then you can ensure that library users don't use the internal function by not exposing the internal module
08:41:22 <dcoutts_> sjanssen: btw, I was wondering if x11-extras is going to get folded into the x11 package, or if we should add x11-extras to gentoo's portage if it's going to exist longer term.
08:41:29 <sjanssen> dcoutts_: nah, just less IRCing lately
08:41:42 <desp> sjanssen: I am already using an unexposed internal module, but I need one function from another module, which is public
08:41:45 <dcoutts_> sjanssen: that probably makes you much more productive ;-)
08:41:52 <sjanssen> dcoutts_: X11-extras will die at some point
08:42:11 <Syzygy-> "You haven't done sh boot" <<= why? I -have- done it, though I have deleted "bad" library directories afterwards...
08:42:19 <dcoutts_> sjanssen: any idea what kind of timeframe? should we hold off putting x11-extras into portage?
08:42:22 <sjanssen> dcoutts_: it probably shouldn't be added unless another package (xmonad?) requires it
08:42:50 <dcoutts_> sjanssen: right, we were pondering putting xmonad in, but then were wondering about what to do with x11-extras
08:43:26 <Syzygy-> GAH! Why does it insist on Win32? It's a bloody unix boxen!
08:43:43 <sjanssen> dcoutts_: I hope to be done with xhsb by August, along with porting xmonad to it
08:43:58 <sioraiocht> yeah this lucas lehmer test is sloooooow
08:43:59 <dcoutts_> sjanssen: oh, cool. :-)
08:44:18 <sjanssen> dcoutts_: at that point I'll look at either folding X11-extras into X11, or deprecating it
08:44:30 <dcoutts_> sjanssen: right. ok, thanks.
08:55:07 <mehrheit> @src and
08:55:07 <lambdabot> and   =  foldr (&&) True
08:55:36 <mehrheit> why True by default?
08:55:52 <shapr> I suddenly want runlevels that work with X... I wish I could switch from work to fun modes for my computer. Wasn't that what runlevels were for originally?
08:55:55 <EvilRanter> mehrheit, because maths
08:57:04 <mehrheit> oh, yes
08:57:13 <mehrheit> it's multiplication
08:58:05 <ihope> Because foldr (&&) False doesn't work.
08:58:35 <EvilRanter> that too
08:59:09 <EvilRanter> ihope wins the "cunning intuitive reasoning" prize
08:59:37 <ihope> :-)
09:00:27 <quicksilver> you could use foldr1 (&&) though
09:00:32 <Syzygy-> Now THAT's more like it.
09:00:33 <quicksilver> and duck the questions
09:00:41 <mauke> but that breaks and []
09:00:44 * Syzygy- does a make -j 4 on the GHC sources.
09:00:50 <quicksilver> well of course
09:00:56 <quicksilver> that's what it's designed to do :)
09:01:23 <mehrheit> Syzygy-, make -j has the best default value for a command line option
09:02:23 <EvilRanter> intuitive reasoning does tend to fail on the edge cases, even if it is cunning
09:04:05 <quicksilver> mehrheit: 'make -j' is unbounded parallelism, that's unlikely to be optimal
09:04:16 <ihope> > and []
09:04:18 <lambdabot>  True
09:04:24 <ihope> Doesn't look broken to me.
09:04:26 <quicksilver> mehrheit: most tests show performance dropping of after number of cores or number of corse + 1
09:04:38 <quicksilver> ihope: mauke was referring to my definition
09:04:43 <mehrheit> quicksilver, yes, I know
09:04:45 <ihope> Oh.
09:04:52 <EvilRanter> i tend to go for ''(and xs) is true iff every element in xs is true. "every element in [] has property P" is trivially true''
09:05:14 <EvilRanter> (forall P)
09:05:28 <ihope> If it's true everywhere, then it's false nowhere. If it's false nowhere, then it's true everywhere.
09:05:41 <EvilRanter> similarly, (or xs) is true iff any element in xs is true. there are no elements in [], so none of them can be true.
09:05:42 <mehrheit> @src or
09:05:43 <lambdabot> or    =  foldr (||) False
09:05:43 <mauke> and xs == not (any not xs)
09:06:18 <mehrheit> [] is like an answer to any question
09:06:24 <Botje> @src (||)
09:06:25 <lambdabot> True  || _ =  True
09:06:25 <lambdabot> False || x =  x
09:06:31 <mehrheit> everything is both true and false about it
09:06:38 <mehrheit> depending on what you want
09:06:48 <EvilRanter> you could formalise all that into a program synthesis proof, and then do foldr identification, but i can't be bothered.
09:06:58 <ihope> If it's true somewhere, then it isn't false everywhere. If it isn't false everywhere, then it isn't true nowhere... wait a minute.
09:07:12 <EvilRanter> doin't you mean it isn't not false nowhere?
09:07:51 <ihope> You mean it isn't true everywhere?
09:08:02 <ihope> Hmm...
09:08:08 <ihope> :-P
09:08:10 <EvilRanter> i dunno. i just put as many negatives as i could into that sentence
09:08:17 <wli> Bool should really be a lattice.
09:08:21 <ihope> A lattice?
09:08:30 <vininim> it works, not as expected though
09:08:30 <Heffalump> surely it is one?
09:08:43 <ihope> What's a lattice?
09:08:59 <EvilRanter> er... a partially ordered set?
09:09:11 <dcoutts_> it's something you put in a salad
09:09:14 <ihope> That's what a lattice is?
09:09:32 <ihope> You mean a salud.
09:09:33 <wli> Instead of (&&) :: Bool -> Bool -> Bool you'd have (&&) :: Lattice t => t -> t -> t (or meet semilattice)
09:09:41 <ihope> Ah.
09:09:49 <Heffalump> oh, you mean you want Bool to be overloaded.
09:10:03 <wli> Instead of (||) :: Bool -> Bool -> Bool you'd have (||) :: Lattice t => t -> t -> t (or join semilattice)
09:10:10 <EvilRanter> sorry, it's a partially ordered set where every pair has greatest lower and least upper bounds
09:10:10 <wli> Heffalump: Yes.
09:10:51 <mauke> heh, I have that somewhere (class Boolean)
09:10:53 <ihope> Well, just have functions called meet and join... except join is taken.
09:10:54 <mauke> just to get perl-style ||
09:11:12 <Heffalump> hmm, anyone would think dcoutts goes to some lesser university where people don't learn anything important :-)
09:11:14 <ihope> Now, how do you do an if/then on these? >:-)
09:11:31 <dcoutts_> Heffalump: but salad is important! :-)
09:11:43 <Heffalump> to rabbits, perhaps ;-0
09:11:46 <Heffalump> s/0/)/
09:11:51 <mauke> ihope: if_ c t e = if toBool c then t else e
09:12:00 <Heffalump> what's toBool?
09:12:16 <mauke> class Boolean b where toBool :: b -> Bool
09:12:26 <mauke> instance Boolean Bool where toBool = id
09:12:32 <mauke> instance Boolean [a] where toBool = not . null
09:12:41 <dcoutts_> or it's a ffi thing for marshaling ints to Bool
09:12:41 <mauke> instance Boolean Integer where toBool = (0 /=)
09:12:43 <Heffalump> ok, so not a member of Lattice then
09:12:54 <ihope> How do you do if/then on a lattice?
09:12:56 <dcoutts_> @hoogle toBool
09:12:57 <lambdabot> Foreign.Marshal.Utils.toBool :: Num a => a -> Bool
09:13:14 <vininim> acronyms overflow
09:13:26 <EvilRanter> zomgwtfbbq?
09:14:08 * dcoutts_ doesn't grok the 'bbq' bit there
09:14:25 <wli> if b then t else f = if b >= top then t else if b <= bottom then f else {- something user-defined -}
09:14:26 <ihope> Barbecue.
09:14:29 <vininim> beautifull bounded quantification
09:14:41 <dcoutts_> ihope: but that wouldn't make any sense! :-)
09:14:53 <EvilRanter> "barbeque", dcoutts. it's parody, i suspect.
09:15:01 <ihope> What does the z in zomg stand for, then?
09:15:26 <EvilRanter> it stands for "i'm in too much of a hurry to hit my left shift accurately when trying to type in allcaps"
09:15:38 <vininim> it's an aspiration due to the surprise
09:15:44 <ihope> Ah.
09:15:51 <dcoutts_> it's it typically a over-zelous typing error, typed by someone taling very quickly
09:15:59 <dcoutts_> like "zomg!!!111!one"
09:16:09 <ihope> "bbq" must be a typo for "bbl", since "q" and "l" are so close together on a QWERTY keyboard.
09:16:22 <vininim> z used to be near shift
09:16:26 <mehrheit> like 'z' and 'o'
09:16:26 <dcoutts_> ihope: ah! that makes more sense :-) well, slightly.
09:16:27 <EvilRanter> yes. i like to tack a few digits of pi on the end of that one, dcoutts ;p
09:16:38 <dcoutts_> EvilRanter: :-)
09:17:14 <EvilRanter> anyway. i must disappear for a moment.
09:17:20 <ihope> omg!!!!!!111141592653589711111 oops I typd pi
09:17:28 * EvilRanter disappears
09:17:29 <mehrheit> you forgot 3
09:17:37 <Heffalump> and lots of leading 0s
09:18:03 <ihope> omg)))))))))00000000031415926535897900000
09:18:21 <ihope> Since "0" and "1" are so close together on a QWERTY keyboard.
09:18:53 <vininim> but z really was near shift, I swear!
09:19:13 <opqdonut> bbq is really "be back quick"
09:19:19 <ihope> Hmm, I typed that without realizing I could more-or-less drag my finger across the keyboard...
09:19:20 <mehrheit> > let e = show (exp 1 :: Double) in "omg!!!00" ++ (e !! 0) ++ ((tails e) !! 2)
09:19:23 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
09:19:29 <dcoutts_> opqdonut: ohhh, didn't know that one.
09:19:34 <ihope> Is it?
09:19:35 <mehrheit> > let e = show (exp 1 :: Double) in "omg!!!00" ++ [(e !! 0)] ++ ((tails e) !! 2)
09:19:37 <lambdabot>  "omg!!!002718281828459045"
09:19:42 <opqdonut> ircers nowadays
09:19:43 <opqdonut> shees :)
09:20:04 <dcoutts_> opqdonut: I've clearly not played enough online games (fortunately)
09:20:28 <opqdonut> dcoutts_: bbq harks from the unix talk days, not from online games :)
09:20:40 <dcoutts_> shows how little I know
09:20:44 <opqdonut> nw
09:20:55 <vininim> wasn't it bbl?
09:21:11 <opqdonut> be back later vs. be back quick
09:21:17 <opqdonut> completely separate use cases :)
09:22:00 <ihope> "in my day we didnt have ths fancy vc rec things-we had 2 typ evrythg manuly"
09:22:27 <opqdonut> bbl and brb gained popularity but bbq was left quite obscure
09:22:40 <ihope> "n we likd it!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!11111111"
09:23:03 <opqdonut> :)
09:23:14 <opqdonut> @elite kids nowadays
09:23:14 <lambdabot> kId$ Now4DayS
09:25:20 <ihope> > "Now, I see we are " ++ unwords (map (map (toUpper . chr) [[111,102,102],[116,111,112,105,999]])) ++ repeat (chr 33)
09:25:21 <lambdabot>  Couldn't match expected type `Int' against inferred type `[a]'
09:25:25 <ihope> Meh.
09:26:00 <ihope> > "Now, I see we are " ++ map (toUpper . chr) ([111,102,102,32,116,111,112,105,99] ++ repeat 33)
09:26:02 <lambdabot>  "Now, I see we are OFF TOPIC!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!...
09:26:59 <ihope> Hmm...
09:27:01 <ihope> @get-smart
09:27:02 <lambdabot> Unknown command, try @list
09:27:07 <ihope> @get-shapr
09:27:07 <lambdabot> shapr!!
09:27:10 <ihope> Darn.
09:27:14 <mauke> @shapr ihope
09:27:14 <lambdabot> why on earth would I slap ihope
09:27:19 <Syzygy-> ..
09:27:52 <ihope> @ihope mauke
09:27:52 <lambdabot> Unknown command, try @list
09:27:55 <ihope> Darn.
09:27:59 <ihope> @mauke ihope
09:27:59 <lambdabot> Unknown command, try @list
09:28:08 <ihope> @dons mauke
09:28:08 <lambdabot> mauke not available
09:28:20 <ari> @ari
09:28:20 <lambdabot> Drink up, me 'earties
09:28:37 <vincenz> @vincenz ari
09:28:37 <lambdabot> Unknown command, try @list
09:28:40 * vincenz sighs
09:28:53 <opqdonut> @wtf wtf
09:28:53 <lambdabot> Maybe you meant: bf ft wn
09:28:57 <ihope> Okay, shall we consider putting to vote a motion to ponder thinking about the possibility of perhaps making a small effort to get on topic?
09:29:04 <opqdonut> seconded
09:29:38 <ihope> I move to call the question, even though "call the question" actually means "stop the debate because it's gone on too long".
09:30:34 <opqdonut> i motion for a +m
09:30:51 <ihope> I'll ratify, whatever that means: does anybody know what these shiftP and promptP things oleg makes reference to in this generic zipper stuff are?
09:31:22 <vincenz> ihope: yes
09:31:28 <vincenz> ihope: they're for delimited continuations
09:31:36 <ihope> How do they relate to shift and reset?
09:31:56 <vincenz> shift should be obvious
09:31:58 <mauke> I hear they're macro-expressible in terms of each other
09:32:01 <vincenz> prompt is a bit like reset but slightly different
09:32:02 <vincenz> yes
09:32:03 <vincenz> they are
09:32:12 <Syzygy-> Bah. GHC build failed. grmbl.
09:32:13 <vincenz> you can express shift/prompt in terms of shift/reset and viceversa
09:32:14 * mauke has no idea what you're talking about
09:33:22 <ihope> Well, this is putting shiftP and promptP in terms of newPrompt, pushPrompt and letSubCont, which is little help when you only know about shift and reset...
09:33:35 <vincenz> ihope: read a paper on it?
09:33:37 <vincenz> let me get a good one
09:34:40 <vincenz> @google "Abstracting Control" danvy filinski 1990
09:34:42 <lambdabot> http://citeseer.ist.psu.edu/danvy90abstracting.html
09:34:42 <lambdabot> Title: Abstracting Control - Danvy, Filinski (ResearchIndex)
09:34:45 <vincenz> there you go
09:34:52 <vincenz> then
09:34:59 <vincenz> one about the expressibility of one in the other and viceversa...
09:35:44 <vincenz> @google Theoretical pearls "A simple proof of a folklore theorem about delimited control" biernacki danvy
09:35:46 <lambdabot> http://portal.acm.org/citation.cfm?id=1132891
09:35:46 <lambdabot> Title: THEORETICAL PEARL: A simple proof of a folklore theorem about delimited control
09:35:49 <vincenz> ;)
09:35:53 <vincenz> enjoy
09:36:17 <ihope> Thanks. I'll look at those.
09:36:51 <vincenz> and
09:36:52 <vincenz> one more of interest
09:37:03 <vincenz> @google "Shift to control" shah
09:37:08 <lambdabot> http://portal.acm.org/citation.cfm?id=1145857
09:37:08 <lambdabot> Title: On the static and dynamic extents of delimited continuations
09:37:10 <vincenz> though mostly cause it really explains DCs (shift/reset) well
09:37:36 <vincenz> (he explains in short the difference between shift/reset and control/prompt in the intro)
09:46:50 <shapr> ihope: You called?
09:47:01 <Syzygy-> Feh.
09:47:05 <vincenz> Syzygy-: ?
09:47:07 <Syzygy-> I should get going to the Fakulttsfest now.
09:47:22 <Syzygy-> But I'm easing into a mood where it's a lot easier to just remain seated and stare at the computer screen.
09:47:23 <vincenz> sounds as fun as the spelling of that word
09:47:28 <Syzygy-> :P
09:47:36 <shapr> Syzygy-: C'mon, you get to speak SWEDISH there!
09:47:49 <Syzygy-> It's good fun really. It's the faculty for mathematics and computer science that organizes a party every summer.
09:47:52 <Syzygy-> shapr: I do? With whom?
09:48:02 <vincenz> shapr: they speak in haskell there
09:48:07 <shapr> vincenz: Oh, never mind then.
09:48:15 <Syzygy-> vincenz: Nah, I seem to be the only haskellite in town.
09:48:22 <Syzygy-> shapr: I'm in Thringen, remember?
09:48:31 <shapr> oh yeah!
09:48:33 <ddarius> Syzygy-: Obviously you're slacking.
09:48:33 <vincenz> ah, otherwise you could tell them 'last [0..]' and come back while they think on that
09:48:41 <vincenz> yes, you are
09:48:46 <Syzygy-> vincenz: Pbtbtbtbtbtbbtbtbtbt
09:48:49 <vincenz> I'm in greece and I'm going to be talking about haskell to the IEEE student branch here :)
09:48:50 <Syzygy-> ddarius: Huh?
09:48:57 <Syzygy-> vincenz: Nice!
09:49:09 * Syzygy- is waiting for his GHC build. Wanna see if I can parallelize the algorithm in my paper...
09:49:20 <shapr> I went to see my grandparents and they gave me veggies that they'd grown yesterday. I was pretty much a Luddite over the weekend.
09:49:31 <ddarius> Yay Luddites!
09:49:33 <Syzygy-> shapr: That's nice every now and then.
09:50:01 <shapr> Yeah, and I have way more food than I can eat in my fridge.
09:50:14 <vincenz> shapr: they grew it one day?
09:50:20 <ddarius> shapr: You wouldn't have that problem if you didn't have a fridge
09:50:22 <shapr> Nah, I got the food yesterday.
09:50:29 <shapr> ddarius: True, I'd have compost instead.
09:50:39 <ddarius> And you could grow more food.
09:50:46 <dcoutts_> shapr: or a very full stomach
09:50:52 <vincenz> which also leads to compost
09:50:57 <shapr> My stomach is already threatening my belt :-(
09:51:25 * vincenz wonders how many people will show up (I hope I won't get like 200 students o.O )
09:51:26 <sioraiocht> shapr: that's assault! =p
09:51:41 <sioraiocht> vincenz: professor or TA?
09:51:44 <shapr> sioraiocht: There was some Salt involved...
09:51:56 <shapr> vincenz: You can do it! Go proselytize! w00!
09:52:05 <vincenz> sioraiocht: phd student, but I'm going to give a lecture on functional programming, with a spin towards Haskell here in greece where I'm collaborating with a greek phd student.
09:52:13 <vincenz> He said he'd advertise at the local IEEE student branch
09:52:27 <sioraiocht> vincenz: that's neat!
09:52:35 <vincenz> yeah, and daunting
09:52:48 <vincenz> their perception of haskell will be purely based on how I present it!
09:52:57 <Syzygy-> vincenz: Yikes. Nervous?
09:53:01 <vincenz> yep
09:53:18 <vincenz> I gave this presentation at my company, but it was 10 people or so, and I'd already been advocating haskell, so they knew what to expect
09:53:22 <vincenz> I can put the slides online for review
09:53:31 <vincenz> (yes, its very little content, but you'd be surprised how little you cover in 1 hour)
09:53:33 <Syzygy-> Oh lovely.
09:53:36 <Syzygy-> Now it's raining.
09:53:43 <Syzygy-> Great day for a Hawaii-themed party.
09:53:55 <pejo> Syz, atleast no clothes can get wet. :-)
09:54:01 <Syzygy-> Mmmmm
09:54:07 <vincenz> http://homes.esat.kuleuven.be/~cpoucet/FPLs.pdf
09:55:40 <sorear> @users
09:55:40 <lambdabot> Maximum users seen in #haskell: 354, currently: 330 (93.2%), active: 16 (4.8%)
09:56:16 <desp> @src fix
09:56:16 <lambdabot> fix f = let x = f x in x
09:56:27 <ddarius> It rains in Hawaii.
09:56:33 <desp> what was this fun thing to wreck lambdabot with, using fix?
09:56:43 <ddarius> @v
09:56:44 <lambdabot> "\""
09:57:34 <sorear> desp: not fix so much; old lambdabot  interpreted > 2 + 2 as let v = (2 + 2) in take 100 $ show v
09:57:59 <sorear> which gave lots of fun when people's expressions contained free occurences of v
09:58:02 <desp> eh
09:58:06 <desp> *heh
09:58:10 <desp> no, I didn't mean that
09:58:16 <vincenz> > fix show
09:58:19 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
09:58:24 <sorear> @join #happs
10:00:21 <desp> I'm looking for some witty one-liner to perhaps use as a team name ;)
10:00:41 <Syzygy-> desp: You ended up with a uni-team now? Or is it still semi-open?
10:00:43 * desp is greatly envious of "lazy bottoms"
10:00:53 <desp> Syzygy-: yeah, the uni-team; 5 guys, possibly 6
10:01:21 <desp> I'm thinking of "lemon curry"
10:02:00 <Syzygy-> Sounds neat. :)
10:02:24 <Syzygy-> Any particular thought about the lemon, though?
10:02:32 <desp> it's a monty python quote
10:02:37 <Syzygy-> Ah.
10:02:40 <desp> alas, a bit obscure
10:02:41 <Syzygy-> That's always a good idea ;)
10:03:02 <vincenz> desp: why?
10:03:13 <vincenz> desp: oh you mean the name :)
10:03:15 <desp> vincenz: why what now? :)
10:03:16 <desp> yeah
10:03:22 <vincenz> we used it last year as well
10:03:44 <desp> we had absolutely zero creativity last year ;p
10:03:54 <vincenz> "banana curry"
10:03:55 <desp> went with "desp & q" ;)
10:03:56 <fasta> Hmm, I think I just wrote the most difficult code I have ever written :)
10:04:02 <vincenz> fasta: id?
10:04:13 <vincenz> fasta: what is it?
10:05:19 <fasta> vincenz: it splits a kind of tree is two based on the splitting operation of another tree with lots of things that complicate it.
10:05:24 <fasta> er in
10:05:47 <vincenz> o.O
10:05:59 <fasta> vincenz: I can be more specific, but I don't think you would understand (since you don't know the terms).
10:06:16 <vincenz> ok
10:08:02 <fasta> At first I assumed that two ranks had to be the same, but it appeared it had to be (rank + 1) `div` 2 and rank `div` 2 + 1. It really needs to be exactly correct, or otherwise it's useless.
10:08:48 <vincenz> what kind of tree does it split?
10:09:37 <shapr> What's the best darcs minor-mode for emacs?
10:09:53 <fasta> vincenz: the "splitting operation of another tree" is a splay operation.
10:10:13 <vincenz> fasta: is that really splitting?
10:10:23 <fasta> vincenz: yes
10:10:26 <vincenz> I thought splay trees just moved the nod which was root
10:10:35 <vincenz> s/nod/node
10:10:44 <fasta> vincenz: yes, that is the splay operation.
10:10:53 <fasta> vincenz: the split operation is based on that.
10:10:54 * vincenz nods
10:10:58 <vincenz> how/
10:10:58 <vincenz> ?
10:11:58 <fasta> vincenz: you can splay the node with a certain rank to the root
10:12:15 <vincenz> where rank = ?
10:12:27 <fasta> vincenz: but I assure you this is all non-trivial (witnessed by the fact that nobody ever documented it or wrote it in a text book)
10:12:42 <vincenz> not claiming it's trivial, just curious :)
10:12:45 <fasta> vincenz: the rank of 3 in [1,2,3,4] is 3
10:12:56 <fasta> vincenz: but now the same for a tree.
10:13:22 <vincenz> number of children to the left?
10:13:34 <fasta> vincenz: yes, but not only that.
10:13:41 <crazy_code3> why can't I do this  :
10:13:50 <vincenz> fasta: what else?/
10:14:00 <vincenz> fasta: Are you trying to implement a sequence in terms of a splay tree?
10:14:09 <fasta> vincenz: I my application I also need to know whether the node is reversed or not.
10:14:31 <crazy_code3>      button1 <- xmlGetWidget xml castToButton "button5"      --For all bottons 2 - 5 defined
10:14:31 <crazy_code3>      button6 <- xmlGetWidget xml castToButton "button6"
10:14:31 <crazy_code3>      listOfButtons <- [button1,button2,button3,button4,button5,button6]
10:14:35 <vincenz> fasta: how would a node be reversed
10:14:46 <fasta> vincenz: if the reversed field is true
10:14:54 <vincenz> fasta: but what does it mean :)
10:14:56 <crazy_code3> Sorry listOfButtons = [button1,....,button6 ]
10:15:02 <vincenz> crazy_code3: no, that will not work
10:15:12 <fasta> vincenz: it means the actual order of the tree should be reversed.
10:15:21 <vincenz> fasta: You mean of the subtree?
10:15:24 <crazy_code3> Did you notice the '=' used in the above code ?
10:15:30 <crazy_code3> vincenz:  ?
10:15:40 <vincenz> crazy_code3: or are those .... metadots?
10:15:48 <fasta> vincenz: yes
10:16:02 <vincenz> crazy_code3: you can do "let listOfButtons = [button1, button2, button3, button4, button5, button6]"
10:16:09 <crazy_code3> No, its listOfButtons = [button1,button2,button3,button4,button5,button6]
10:16:11 <olsner> this "CS doesn't need maths" guy is funny.. he thinks he's found something profound, but as I see it he's just reinventing different parts of functional programming and flow-based programming (as well as thinking everyone but him is somehow blinded by the concept of "algorithm")
10:16:15 <fasta> vincenz: subtree is a bit ambiguous, I actually meant "tree".
10:16:25 <vincenz> fasta: why would you reverse a tree
10:16:35 <crazy_code3> vincenz: why can't I just define it ?
10:16:40 <vincenz> crazy_code3: that defines it
10:16:45 <fasta> vincenz: because I need that operation in an algoritm.
10:17:02 <vincenz> fasta: at the meta-level :)
10:17:03 <crazy_code3> vincenz: Then I will have a scope in which only it will be valud
10:17:06 <vincenz> fasta: why does the algorithm need that :)
10:17:18 <littledan> why is (!) monomorphic on arrays, rather than having an Array typeclass (in addition to the Ix class)?
10:17:27 <vincenz> crazy_code3: welll they only exist within that scope... due to <-
10:17:31 <vincenz> of the different buttons
10:17:32 <fasta> vincenz: because it cuts a path in two and it should take the longest path and concatenate that to the current path
10:17:32 <crazy_code3> vincenz: but I want it to be available outside that block too
10:17:33 <littledan> it seems like it would be useful if it were polymorphic
10:17:36 <sjanssen> littledan: there is an array typeclass in Data.Array.IArray
10:17:49 <littledan> oh
10:17:53 <vincenz> fasta: I'm having trouble understanding your explanation
10:18:03 <crazy_code3> vincenz: Thanks :)
10:19:36 <fasta> vincenz: Ok, consider that you have this path: |<some shorter path | <- cutpoint <some larger path>| assume the direction of this path is from the end to the start.
10:19:43 <vincenz> right
10:20:01 <littledan> sjanssen, so that wasn't H98 because it needs multiparameter typeclasses or something?
10:20:11 <fasta> vincenz: now, if you want to append the longer path, you must first reverse it.
10:20:25 <fasta> vincenz: by "it" I meant he longer path.
10:20:30 <fasta> the*
10:20:31 <sjanssen> littledan: yeah, the IArray class uses MPTCs
10:20:42 <vincenz> But it's already appended, you just have a cutpoint?
10:21:02 <vincenz> fasta: why not actually reverse the path, or is this too expensive?
10:21:09 <vincenz> fasta: and a path sounds like a sequence, so you're encoding a sequence?
10:21:18 <fasta> vincenz: it's a very advanced sequence.
10:21:20 <vincenz> fasta: or why is this a tree in the first place?
10:21:25 <vincenz> fasta: like finger-tree/
10:21:36 <fasta> vincenz: because linked lists cannot support the operations I want.
10:21:42 <vincenz> fasta
10:21:52 <vincenz> ack, NMI ... my terminal got spammed
10:21:56 <fasta> vincenz: a finger tree might be possible too.
10:22:12 <fasta> vincenz: but I don't have good literature for those.
10:22:13 <vincenz> fasta: you want to be able to reverse part  of your path without inducing a copying of the large part?
10:22:20 <vincenz> fasta: there's one good document on finger-trees
10:22:27 <vincenz> @google haskell finger tree 2006
10:22:30 <lambdabot> http://www.soi.city.ac.uk/~ross/papers/FingerTree.html
10:22:30 <lambdabot> Title: Finger Trees: A Simple General-purpose Data Structure
10:22:32 <fasta> vincenz: no, that's not good.
10:22:32 <vincenz> that one
10:22:42 <fasta> vincenz: that's childs play, compared to this.
10:22:50 <vincenz> yes, you've said it's complex :)
10:23:13 <vincenz> I still don't see the reason you need a path
10:23:14 <vincenz> erm
10:23:15 <vincenz> a tree
10:23:21 * shapr hugs Finger Tries
10:23:28 <vincenz> shapr: trees!
10:23:34 <fasta> vincenz: I did use Data.FingerTree at some point, but then I found out they were limited.
10:23:36 * lament bounces
10:23:47 <vincenz> fasta: in terms of performance?
10:24:02 <fasta> vincenz: no, in terms of features and asymptotic complexity.
10:24:08 <vincenz> yes, that's what I mean
10:24:13 <fasta> vincenz: so, that might be "yes".
10:24:27 <vincenz> so what's the main operation you want to do?
10:24:32 <shapr> vincenz: I can use finger tries for whatever I want :-P
10:24:38 <vincenz> shapr: finger tries don't exist
10:25:54 <fasta> vincenz: the reason for the path is to do a DFS is sublinear time.
10:25:57 <fasta> er in*
10:26:34 <hpaste>  crazy_coder pasted "(no title)" at http://hpaste.org/1583
10:26:36 <vincenz> so IIUC
10:26:36 <fasta> vincenz: via some nice complexity arguments one can then solve certain problems asymptically optimal.
10:26:47 <vincenz> the path is the path into a tree
10:26:52 <crazy_code3> Can anyone help me with this .. http://hpaste.org/1583
10:26:54 <fasta> @what IIUC
10:26:54 <vincenz> and you want to not have to walk up and down the tree so much?
10:26:54 <lambdabot> I know nothing about iiuc.
10:27:01 <vincenz> if I understand correctly
10:27:07 <fasta> vincenz: no, it's a path in a graph.
10:27:19 <vincenz> a zipper?
10:27:29 <fasta> vincenz: ?
10:27:36 <vincenz> a zipper into the graph
10:27:42 <fasta> vincenz: the path is the complicated data structure I described.
10:27:49 <vincenz> Yes, that is the 'implementation'
10:27:56 <vincenz> I'm wondering what the abstract meaning of this sequenec of tokens is
10:28:03 <fasta> vincenz: Ok
10:28:13 <vincenz> it's a path into the graph?
10:28:19 <fasta> vincenz: yes
10:28:20 <vincenz> of how you got to a node from some other node?
10:28:25 <vincenz> so in a sense a zipper
10:28:33 <fasta> vincenz: in that sense it's zipper, yes.
10:28:39 <vincenz> though instead of a list
10:28:44 <vincenz> you use your custom sequence implementation
10:28:46 <vincenz> because of certain properties
10:29:06 <vincenz> ok :)
10:29:07 <fasta> vincenz: but that has little meaning to me, since I don't know any "graph zipper" (conform zipper trees).
10:29:12 <fasta> vincenz: right
10:29:28 <vincenz> and the implementation you're discussing is the sequence data type for this list of directions (path)
10:29:32 <fasta> vincenz: this "complicated data structure" can be implemented as z upper btw.
10:29:40 <fasta> vincenz: on top of a zipper tree
10:29:48 <fasta> vincenz: but then it's not suitable for this application
10:29:48 <vincenz> 'z upper' ?
10:29:53 <Syzygy-> Anyone used the SMP parallelity in GHC?
10:29:58 <fasta> vincenz: zipper typed by me
10:30:01 <vincenz> fasta: nono, a zipper tree is just one type of zipper
10:30:04 <crazy_code3> ..
10:30:08 <Syzygy-> I'm trying to get a program, which runs over a list and generates a lot of stuff everywhere - to parallelize.
10:30:15 <vincenz> the zipper itself is how you step into whatever datastructure you have
10:30:15 <Syzygy-> But it kinda won't.
10:30:19 <vincenz> namely, a list of steps
10:30:27 <vincenz> zipper tree = zipper for a tree
10:30:40 <fasta> vincenz: yes, I understand, but I haven't seen other data structures that are like the zipper tree technique.
10:30:46 <vincenz> ok
10:30:47 <fasta> vincenz: i.e. pointer reversal
10:30:58 <fasta> vincenz: that's the classical name for zippers
10:30:58 <vincenz> continuations
10:31:01 <crazy_code3> http://hpaste.org/1583
10:31:02 <vincenz> they're zippers :)
10:31:08 <fasta> (which I discovered later)
10:31:10 <crazy_code3> Anyone ?
10:31:15 <fasta> vincenz: Please blog about that.
10:31:24 <vincenz> hmm
10:31:25 <vincenz> alright :)
10:31:33 <vincenz> fasta: so if I get it right
10:31:36 <vincenz> fasta: if you have a loop
10:31:40 <vincenz> you can cut out part of the path
10:31:44 <vincenz> and lists don't offer this functionality
10:31:47 <sorear> crazy_code3: Why did you deselect announce if you were just going to announce it yourself/
10:31:48 <vincenz> this is just me guessing
10:31:51 <fasta> vincenz: it isn't a loop
10:31:55 <vincenz> fasta: no in the graph
10:32:02 <fasta> vincenz: I know
10:32:04 <vincenz> if you find a loop in the graph, you don't have to go bakc around
10:32:07 <fasta> vincenz: it's not a loop
10:32:10 <fasta> vincenz: ah, ok
10:32:11 <fasta> vincenz: yes
10:32:14 <byorgey> crazy_code3: what's the problem?
10:32:14 <vincenz> alright :)
10:32:18 <vincenz> and hence you want something fancier than a list
10:32:19 <crazy_code3> sorear: sorry, btw I realized what I was wrong at
10:32:20 <fasta> vincenz: right
10:32:23 <vincenz> okies :)
10:32:32 <fasta> vincenz: now, I really earned that blog post :)
10:32:35 <sorear> fasta, vincenz: maybe #haskell-overflow? crazy_code3 is unable to get help
10:32:44 <crazy_code3> byorgey: nm. I realized my mistake
10:32:50 <vincenz> fasta: #oasis?
10:32:57 <byorgey> crazy_code3: what was it?
10:33:00 <fasta> vincenz: ok
10:33:07 <fasta> sorear: you are right
10:33:12 <vincenz> sorear: sorry
10:33:29 <crazy_code3> byorgey: I wanted to apply the function clickAction to all buttons
10:33:39 <crazy_code3> byorgey: But map gives me another list
10:33:55 <crazy_code3> byorgey: So it doesn't solve my problem.
10:34:11 <crazy_code3> byorgey: so I'll have to think another way around this
10:34:20 <byorgey> crazy_code3: what is the type of clickAction?
10:34:23 <ricky_clarkson> @src fix
10:34:23 <lambdabot> fix f = let x = f x in x
10:35:11 <byorgey> crazy_code3: maybe you want something like mapM?
10:35:32 <byorgey> @type mapM
10:35:35 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
10:36:11 <byorgey> or mapM_ more likely
10:36:35 <crazy_code3> byorgey: what does mapM do ?
10:36:44 <crazy_code3> byorgey: don't know monads
10:37:00 <byorgey> @src mapM
10:37:00 <lambdabot> mapM f as = sequence (map f as)
10:37:15 <byorgey> crazy_code3: mapM takes a function producing a monad and a list
10:37:36 <crazy_code3> byorgey: btw, my problem is that I have to define onClicked button n = ........ for all n's
10:37:36 <byorgey> crazy_code3: applies the function to each element of the list, then sequences all the resulting "actions"
10:37:43 <ihope> @src sequence
10:37:43 <lambdabot> sequence ms = foldr k (return []) ms
10:37:44 <lambdabot>     where
10:37:44 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
10:37:48 <crazy_code3> byorgey: So would mapM solve my problem
10:37:53 <ihope> Hmm.
10:37:55 <quicksilver> it runs a monadic action over a list of parameters
10:38:02 <quicksilver> (that is, the action gets run multiple times)
10:38:11 <Saizan> crazy_code3: also maybe you want to write clickAction button = onClicked button $ ... ?
10:38:11 <quicksilver> it is the haskell version of a 'for' list in most cases
10:38:42 <crazy_code3> Saizan: yeah I changed that to clickAction = onClicked button set button [buttonLabel := "X"]
10:39:29 <Saizan> crazy_code3: but from where do you get "button"?
10:40:33 <crazy_code3> Saizan: Its a dummy variable , like square x = x*x; here x is a dummy variable
10:40:56 <dcoutts_> crazy_code3: have to make button the argument of your clickAction function
10:41:29 <crazy_code3> dcoutts_ I suppose I did that, right ?
10:41:37 <Saizan> crazy_code3: exactly, you have to name it on the left side too.. square x = .. --> clickAction button = ..
10:41:43 <crazy_code3> Oh
10:41:46 <crazy_code3> Sorry
10:42:09 <hpaste>  dcoutts annotated "(no title)" with "fix clickAction" at http://hpaste.org/1583#a1
10:42:15 <etnt> silly Q: what's the difference between data and newtype ?
10:42:46 <dcoutts_> etnt: to a first approximation, newtype is a special case of data where there is only one constructor with a single field
10:43:01 <byorgey> etnt: newtype just makes a "wrapper" type which is isomorphic to some other type
10:43:23 <dcoutts_> etnt: ie newtype Foo = Foo Bar is really very similar to data Foo = Foo Bar
10:43:48 <byorgey> etnt: also, it's not a silly question =)
10:44:01 <dcoutts_> etnt: the difference is that the newtype shares the representation rather than adding another wrapper layer at runtime
10:44:15 <etnt> ok, thx, so is there a reason for not only having data ?
10:44:22 <sorear> Why do we have newtype, anyway?  Special cases in the name of efficiency aren't a very Haskell-like thing to do.
10:44:29 <ndm> sorear: FFI spec
10:44:37 <dcoutts_> there is actually a semantic difference
10:44:40 <dcoutts_> ndm: huh?
10:44:44 <sorear> ndm: Postdates newtype. :)
10:44:49 <dcoutts_> it's nothing to do with FFI
10:45:10 <byorgey> I think ndm's point is that FFI is a special case in the name of efficiency?
10:45:12 <ndm> sorear: the thought predated it, malcolm said that was one of the reasons for including it
10:45:24 <byorgey> or not. =)
10:45:33 <sorear> dcoutts_: yeah.  update-in-place is also a semantic difference, but we don't have that in h98
10:45:35 <ndm> no, newtypes have a separate representation to ffi, which is one of the reasons they are different
10:45:49 <crazy_code3> Thanks
10:45:50 <cedricshock> Can I match a pattern in an if? Or should I use case ___ of ...?
10:45:52 <crazy_code3> Its working
10:46:07 <sorear> crazy_code3: Case ___ of ...
10:46:14 <dcoutts_> sorear: the pattern matching semantics of newtype are different from a single strict constructor data type
10:46:56 <crazy_code3> dcoutts_, Saizan, byorgey : Thanks
10:47:21 <sorear> dcoutts_: semantic differences obviously aren't enough to justify making an optimization visible to programmers - update-in-place is also a semantic difference, but we don't have that in h98
10:47:41 <byorgey> crazy_code3: sure.  now, you were saying something about wanting an extra (numeric?) parameter to onClicked?
10:47:44 <cedricshock> sorear: Thanks.
10:47:55 <quicksilver> crazy_code3: did someone already observe that you can get rid of that annoying repetiions in the creation too?
10:48:06 <dcoutts_> sorear: (case _|_ of NewType _ -> 3) = 3; (case _|_ of StrictData _ -> 3) = _|_
10:48:15 <sjanssen> what if the Haskell spec said that strict, single constructor, single component 'data' declarations are unlifted just like newtypes?
10:48:15 <Syzygy-> ?src rwhnf
10:48:15 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
10:48:29 <sorear> dcoutts_: what are you trying to prove to me?
10:48:38 <crazy_code3> byorgey: ??
10:48:41 <sjanssen> can anyone show why that would be bad?
10:48:43 <sorear> dcoutts_: I've already said there is a semantic difference
10:48:54 <crazy_code3> quicksilver: Good idea. i'll try to do that
10:48:55 <dcoutts_> sorear: ok, you asked why we have them
10:49:06 <dcoutts_> because you cannot get that semantics with data
10:49:08 <byorgey> <crazy_code3> byorgey: btw, my problem is that I have to define onClicked button n = ........ for all n's
10:49:10 <cedricshock> sorear: Try to be the compiler for this without newtype: newtype Strategy b = Strategy ([b] -> IO (Strategy b, b))
10:49:32 <hpaste>  quicksilver annotated "(no title)" with "abstract more" at http://hpaste.org/1583#a2
10:49:41 <sjanssen> dcoutts_: sorear is pointing out that "semantic difference" is only a partial explanation
10:49:47 <crazy_code3> byorgey: I meant, I wanted to define it for buttonn where the second n is 1,2,3....6  ;P
10:49:49 <dcoutts_> sjanssen: yeah ok
10:49:53 <sorear> dcoutts_: If { We add things if they are semantically different } then { We would have update-in-place }.  By contrapositive your explanation is disproved.
10:50:26 <dcoutts_> sorear: ok, because that extra semantics are useful in practise for natural FP program, would that be a good explanation?
10:50:40 <byorgey> crazy_code3: ah, I understand now.
10:50:56 <sorear> good enough :)
10:50:59 <dcoutts_> sorear: I'm not claiming that's actually true, but if so it'd be a reasonable explanation
10:51:12 <sorear> yeha
10:51:46 <dcoutts_> sjanssen: hmm, so I'm not sure if that'd be ok, it'd make the semantics of data non-uniform
10:52:07 <ndm> another reason was to create alternative dictionaries for type classes with no additional overhead
10:52:38 <quicksilver> crazy_code3: you could also replace the list of names with map (("button"++).show) [1..6]
10:52:44 <quicksilver> although I assume that part is not so literal
10:53:06 <sjanssen> dcoutts_: yeah, say you change "data X = X" to "data X = X | Z" -- some programs will start diverging because of such a minor change
10:53:19 <sjanssen> s/because/despite
10:53:40 <sjanssen> erm, despite isn't right either.  I'm sure you see what I mean
10:53:58 <dcoutts_> sjanssen: right, especially auto-generated progs, that just happen to sometimes generate single constructor data types but expect uniform behaviour
10:54:19 <sorear> sjanssen: interestingly, early Miranda had a rule where all pattern matches on single-constructor types were irrefutable
10:54:30 <dcoutts_> sorear: interesting
10:54:35 <dcoutts_> I didn't know that
10:55:14 <mehrheit> @index liftM
10:55:15 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
10:55:47 <sjanssen> sorear: I suppose Haskell has newtype because it has a very nice power to complexity ratio
10:56:27 <dcoutts_> similarly, strict fields in data types
10:56:43 <sjanssen> extra type safety (core Haskell motivation) with zero runtime cost
10:57:20 <dcoutts_> so newtype could translate into strict data plus using ~ pattern matching everywhere the newtype is unwrapped
10:57:50 <dcoutts_> and strict fields could translate into using seq on all uses of that constructor
10:58:03 <sjanssen> the additional complexity is pretty minor, just a little bit of extra semantics for pattern matching.  Every newbie has a "huh?" moment after discovering newtype, but this doesn't last too long
10:58:35 <dcoutts_> but yes, it's much easier having these conveniences for these very common patterns
10:58:56 <dcoutts_> and as a bonus it allows implementation optimisations more easily
11:00:50 <cedricshock> Is there a type already in the prelude for something like: data ListTree a = One a | Some [ListTree a] ?
11:01:15 <sjanssen> cedricshock: there is Data.Tree, but it's a bit different
11:01:31 <sjanssen> data Tree a = Tree a [Tree a] -- IIRC
11:02:39 <dcoutts_> data Tree a = Node {rootLabel :: a, subForest :: [Tree a]}
11:04:30 <cedricshock> dcoutts_, sjanssen: Thanks. Data.Tree captures the same idea.
11:04:55 * shapr boings cheerfully
11:07:42 <sjanssen> done with qhc already?
11:16:45 <cedricshock> Writing with Maybe Boolean is funny. It's, "Just True". No big deal.
11:17:58 <mehrheit> ?index in
11:17:58 <lambdabot> bzzt
11:18:23 <mehrheit> ?hoogle a -> [a] -> Bool
11:18:24 <lambdabot> Prelude.elem :: Eq a => a -> [a] -> Bool
11:18:24 <lambdabot> Prelude.notElem :: Eq a => a -> [a] -> Bool
11:20:42 <mehrheit> > 'a' `elem` []
11:20:43 <lambdabot>  False
11:21:08 <mehrheit> ?hoogle a -> [a] -> Int
11:21:08 <lambdabot> No matches, try a more general search
11:21:12 <mehrheit> ?hoogle a -> [a] -> Integer
11:21:13 <lambdabot> No matches, try a more general search
11:22:16 <quicksilver> :t findIndex
11:22:19 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
11:22:28 <quicksilver> mehrheit: I think that's what you're after
11:23:06 <mehrheit> no, I'm after counting occurences
11:23:29 <quicksilver> ah
11:23:48 <quicksilver> > length . filter (==2) $ [1,2,3,4,2,3,2,3,4]
11:23:51 <lambdabot>  3
11:24:01 <quicksilver> mehrheit: like so ? :)
11:24:18 <mehrheit> yes
11:24:46 <mehrheit> ?pl \x -> length . (filter (==x))
11:24:46 <lambdabot> (length .) . filter . (==)
11:25:37 <quicksilver> I must admit I don't tend to use the (foo .) . stuff in practice
11:26:00 <quicksilver> although I did finally get my head around it, it still feels  slightly obfuscated
11:26:08 <mehrheit> I don't grok it
11:26:38 <quicksilver> the == part and the filter part are 'composing in the first argument'
11:26:41 <dcoutts_> quicksilver: slightly obfuscated? I'd say really quite obfuscated. Nobody really uses that kind of code. Well, hardly.
11:26:59 <quicksilver> the effect of the  (   . ) . idiom is to 'move the composition out to the second argument'
11:27:37 <EvilRanter> (((f .) . g) x) y = (f .) (g x) y = (f . g x) y = f (g x y)
11:27:49 <quicksilver> mehrheit: as dcoutts says, people don't tend to write code like that :)
11:28:26 <mehrheit> understandable
11:28:28 <EvilRanter> if i'm doing a lot of pointsfree stuff for some reason, i tend to
11:28:41 <EvilRanter> ?let (.:) f g x y = f (g x y)
11:28:42 <lambdabot> Defined.
11:29:00 <EvilRanter> making that thing length .: filter . (==)
11:30:49 <olsner> :t (\f -> (f .) .)
11:30:52 <lambdabot> parse error on input `)'
11:31:07 <olsner> :t (\f -> ((f .) .))
11:31:10 <lambdabot> forall b c a a1. (b -> c) -> (a1 -> a -> b) -> a1 -> a -> c
11:31:37 <olsner> oh, that's just exceedingly helpful
11:32:24 <Saizan> i don't it's obfuscated anymore, #haskell has surely twisted my taste, though
11:32:41 <roconnor> What I find most intresting about the xkcd menu problem solutions is the correlation between programming language and whether floats or ints are used.
11:32:42 <Jaak> @pl (\f -> ((f .) .))
11:32:42 <lambdabot> (.) . (.)
11:32:52 <Jaak> oh, boobies combinator
11:33:34 <mehrheit> roconnor, how do they correlate?
11:33:35 <gmh33> 3/4ths view translates into front view
11:35:15 <roconnor> mehrheit: The languagues I don't like seem to use floats more
11:35:18 <roconnor> :)
11:35:24 <roconnor> not really a scientific study
11:35:46 <roconnor> python is a bit of an exception.  I don't like it so much, but the author uses ints.
11:35:50 <mehrheit> I think it's more a matter of developer
11:35:58 <olsner> seems to me that a float solution actually finding an answer == 15.05 is just pure luck
11:36:04 <roconnor> mehrheit: exactly
11:36:28 <roconnor> I expect most languages to allow both options.
11:37:10 <roconnor> So it is really a developer <-> language correlation I see.
11:37:41 <mehrheit> that is understandable with the lack of constraints on languages
11:37:59 <roconnor> And people who use floats are presumably lower quality programers.
11:38:13 <roconnor> (although I wouldn't just someone on just that one point)
11:38:27 <roconnor> s/just/judge/
11:39:05 <monochrom> Applesoft BASIC was purely float, no int.
11:39:26 <monochrom> In contrast, Apple Integer BASIC was purely int, no float. :)
11:39:46 <gmh33> roconnor: ints don't work for everything...
11:40:07 <roconnor> gmh33: Oh I agree.
11:40:21 <gmh33> roconnor: that's good ;)
11:40:23 <nopcode> roconnor: lol
11:40:26 <roconnor> gmh33: but when people use floating point numbers for financial transactions, I get worried.
11:40:38 <nopcode> but you need floats if you mixe different scales
11:40:43 <nopcode> as in numerics
11:40:49 <gmh33> roconnor: ooooooo.. that makes more sense
11:41:32 <roconnor> sometimes you need to use floats for finance, but not so often, and even still things should be denomiated in cents
11:41:38 <gmh33> roconnor: I wrote a little stack language interpreter in java (for a class) and when I started, it was purely float based for numbers, but I eventually upgraded it to dynamically switch between using arbitrary precision ints and doubles :)
11:41:40 <roconnor> (or whatever your smallest unit of currency is)
11:41:42 <olsner> interesting point there on the I/O complexity of algorithms (bottom of first page on the xkcd comic topic).. I actually hadn't really though about that
11:43:00 <roconnor> olsner: where?
11:43:12 <olsner> http://forums.xkcd.com/viewtopic.php?t=7532
11:43:55 <olsner> "They probably use an external memory algorithm, because all of the data might not fit in memory. Interestingly, a lot of problems get a lot harder when you count I/Os instead of operations: most linear-time algorithms in the RAM model take sorting complexity in the I/O model. ", as a comment to "How does Google maps calculate shortest routes?"
11:46:51 <roconnor> oh crap, it's polytime!
11:46:58 * shapr breaks it down..
11:47:15 <roconnor> We've been had!
11:47:53 <olsner> hmm... how can the number of I/O operations exceed the total number of operations?
11:49:02 <quicksilver> olsner: they don't
11:49:06 <quicksilver> olsner: but they take longer
11:49:08 <olsner> but I guess the issue is "limited to m bytes of RAM (with O(m) save-to-disk), what's the time complexity of this algorithm?"
11:49:14 <quicksilver> olsner: typically log n, for some n
11:49:42 <quicksilver> olsner: more generally, linear time is almost fictional. Real hardware runs almost anything linear in n log n
11:49:56 <quicksilver> (cache response, swap, length of data keys, length of indices)
11:50:16 <quicksilver> the number 'n' itself requires log n bytes to store...
11:51:06 <edward1> well said re: the 'linear runs in n log n' on real hardware
11:52:06 <quicksilver> however, fortunately, n log n is damn nearly as good as n, in practice :)
11:52:13 <quicksilver> since 'log n' never gets very big
11:52:15 <quicksilver> :)
11:52:47 <edward1> bah whats a factor of 20 give or take ;)
11:52:48 <olsner> but isn't that factor really log (machine size)?
11:54:15 <fasta> {True->{True->();False->()};False->{True->();False->()}}-> <snip> what does that mean?
11:54:29 <fasta> I get it in the output of SmallCheck
11:54:39 <fasta> It might also be something of GHC
11:54:48 <xerox> They are representations of functions.
11:55:26 <fasta> xerox: right, I missed a few arguments.
11:57:47 <HairyDude> does H98 not allow type variables in instance heads? like instance MonadPlus m => Monoid (m a)
11:59:14 <HairyDude> such a declaration works only if I use -fglasgow-exts.
11:59:19 <Saizan> in H98 you can only write  instance Class (T a b c) where  T is a type constructor and a b c are distinc type variables
11:59:28 <HairyDude> right
11:59:54 <HairyDude> presumably that's not limited to 3 variables? :)
12:00:05 <Saizan> off course not :)
12:00:28 <HairyDude> call me thick but I think there should be an ellipsis there
12:01:22 <quicksilver> yeah, it's a bad error message :)
12:01:51 <monochrom> Even ellipsis won't do.
12:04:04 <MarcWeber> Can I tell cabal when creating haddock documentation where the documentation of the dependencies is located?
12:05:45 <Igloo> For GHC, ghc-pkg should already know
12:07:17 <HairyDude> oh I suppose instances like that are much more likely to overlap
12:09:35 <HairyDude> incidentally, is there any point in MonadPlus if you can have that instance? I don't think it does anything you don't get with Monoid, except maybe mconcat
12:10:28 <Saizan> ?type mxum
12:10:29 <pastorn> what are my options besides wxHaskell for windows?
12:10:30 <Saizan> ?type msum
12:10:32 <lambdabot> Not in scope: `mxum'
12:10:35 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
12:11:09 <HairyDude> ?type mconcat
12:11:12 <lambdabot> forall a. (Monoid a) => [a] -> a
12:11:22 <HairyDude> oh, got it the wrong way round then
12:17:15 <collinge> #darcs
12:23:15 <glguy> [map fst y|i<-[0..], y<-replicateM i menu, sum (map snd y)==1505]
12:23:27 <glguy> is such a sweet way to blow a non Haskell programmer away :)
12:23:35 <glguy> (quoting roconnor's reddit post)
12:26:23 <sjanssen> glguy: but it doesn't terminate
12:26:43 <Heffalump> you might only want the head
12:26:46 <Saizan> how often are attributes used in auto-generated xml? they just seem a convenience for humans to me
12:27:01 <glguy> sjanssen: it wouldn't be so bad to divide the sum by the smallest price to get an upper limit on the number of items
12:27:10 <glguy> sjanssen: but that really isn't the point :-p
12:27:26 <sjanssen> Heffalump: even 'head' won't terminate if the menu is ugly
12:30:01 <quicksilver> HairyDude: yes, it's different :)
12:30:15 <quicksilver> :t mappend
12:30:20 <lambdabot> forall a. (Monoid a) => a -> a -> a
12:30:23 <quicksilver> :t mplus
12:30:25 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
12:30:27 <glguy> :t mzero
12:30:29 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
12:30:30 <glguy> :t mempty
12:30:33 <lambdabot> forall a. (Monoid a) => a
12:30:37 <quicksilver> HairyDude: it proves you have one at every type a
12:30:45 <quicksilver> HairyDude: and, they are in some sense 'compatible'
12:30:57 <quicksilver> (admittedly this side condition is not enforced)
12:31:26 <quicksilver> but if you 'fmap' after you mplus, that should be equivalent to 'fmapping' both components before the mplus
12:31:48 <quicksilver> > [3,4] `mplus` [1]
12:31:49 <HairyDude> quicksilver: well if you have an instance Monoid (M a) for some Monad m, surely that means you have one at every a, since there's an implicit universal quantification over the a
12:31:49 <lambdabot>  [3,4,1]
12:31:58 <quicksilver> HairyDude: yes, you're right
12:32:07 <quicksilver> HairyDude: the monadplus does imply the pointwise monad
12:32:17 <quicksilver> HairyDude: but the monadplus is *more than* the pointwise monad
12:32:25 <quicksilver> it's a bunch of compatible pointwise monads
12:32:46 <HairyDude> s/monad/monoid/ ?
12:33:49 <quicksilver> erm, yes
12:33:50 <quicksilver> sorry
12:33:51 <quicksilver> :)
12:33:59 <HairyDude> but Monoid (M a) isn't one monoid either, it's again a bunch of them, one for each a
12:34:01 <quicksilver> bunch of compatible pointwise monoids
12:34:07 <quicksilver> agreed
12:34:24 <quicksilver> I certainly wish we had that Monoid instance written down
12:34:36 <HairyDude> we do, it's on wikibooks
12:34:36 <quicksilver> one reason that we dont' (probably the main one) is that it's a different instance
12:34:49 <quicksilver> from the ones we already have on, e.g., [a]
12:34:54 <HairyDude> http://en.wikibooks.org/wiki/Haskell/MonadPlus#Relationship_with_Monoids
12:34:58 <lambdabot> http://tinyurl.com/ywaoj4
12:35:18 <HairyDude> oh?
12:36:03 <HairyDude> > [1,2,3] `mappend` [4,5,6]
12:36:05 <lambdabot>  [1,2,3,4,5,6]
12:36:08 <HairyDude> > [1,2,3] `mplus` [4,5,6]
12:36:10 <lambdabot>  [1,2,3,4,5,6]
12:36:37 <sjanssen> HairyDude: the Monoid instance for Maybe is quite unlike the MonadPlus instance
12:36:50 <sjanssen> (I am not a big fan of that decision, by the way)
12:37:04 <Saizan> > Just 1 `mappend` Just 2
12:37:06 <lambdabot>   add an instance declaration for (Monoid (Maybe t))
12:37:06 <lambdabot>     In the expression: (...
12:37:14 <HairyDude> No instance for (Monoid (Maybe a))
12:37:15 <HairyDude> buh
12:37:36 <sjanssen> HairyDude: it will be in GHC 6.8
12:37:45 <Saizan> > Just 1 `mplus` Just 2
12:37:47 <lambdabot>  Just 1
12:38:02 <HairyDude> sjanssen: there's a general problem there though, namely that you can only get one monoid over a given carrier (like the well known two monoids over Integer)
12:38:04 <Saizan> sjanssen: mappend will give Just 2?
12:38:11 <mehrheit> ?instances Float
12:38:14 <lambdabot> Couldn't find class `Float'. Try @instances-importing
12:38:24 <HairyDude> @instances Monoid
12:38:26 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, Ordering, Product a, Sum a, [a]
12:38:30 <sjanssen> Saizan: no, it'll give Just (1 `mappend` 2)
12:38:40 <sjanssen> assuming 1 and 2 are some monoids
12:39:34 <sjanssen> I think this is stupid, but the mailing list didn't agree
12:39:48 <HairyDude> haskell's class system suffers somewhat from "one instance to rule them all" syndrome
12:40:29 <mehrheit> can Functor instances be derived?
12:40:45 <Heffalump> HairyDude: I tend to think that's the whole point of it.
12:41:23 <HairyDude> mehrheit: if you have newtype Foo = Foo (Bar Baz) where Bar is a Functor, then you can do it in ghc
12:42:14 <HairyDude> @google generalized newtype deriving
12:42:16 <lambdabot> http://haskell.galois.com/trac/haskell-prime/wiki/NewtypeDeriving
12:42:16 <lambdabot> Title: NewtypeDeriving - Haskell Prime - Trac
12:42:38 <sjanssen> HairyDude: your example isn't quite right, Foo doesn't have the right kind
12:42:52 <HairyDude> it's something like that anyway :)
12:42:55 <sjanssen> newtype Foo a = Foo (Bar a) deriving Functor -- is okay
12:43:01 <HairyDude> yes, you're right
12:43:30 <HairyDude> I was quite astonished when I first saw "deriving Monad" :)
12:44:40 <monochrom> One keyword to Derive Them All.
12:45:55 <edward1> we need a 'generalized just askin djinn deriving' foo : (a -> b -> c) -> (b -> a) -> b -> c; foo = auto
12:46:14 <edward1> er asking
12:46:17 <cedricshock> Why, if I "import Data.Set as Set" and "import List" do I get "Ambiguous occurrence `map'". Shouldn't Data.Set.map only be available to me as Data.Set.map or Set.map?
12:46:41 <Saizan> cedricshock: you miss a 'qualified'
12:46:42 <dylan> cedricshock: import qualified Data.Set as Set
12:46:44 <edward1> import qualified
12:46:58 <cedricshock> Sauzan, dylan, edward1: Thanks.
12:47:13 <pastorn> again: what are my options besides wxHaskell for windows?
12:47:26 <Saizan> pastorn: gtk2hs?
12:47:31 <pastorn> really?
12:47:40 <dcoutts_> yep, it's got a nice win32 installer
12:47:47 <dcoutts_> unlike wxHaskell
12:47:54 <pastorn> doesn't that require gtk for windows on the computer?
12:48:02 <pastorn> i need to make a standalone exe
12:48:04 <dcoutts_> it's included in the installer
12:48:04 <njbartlett> Heffalump: Hi, how's that mailing list coming along?
12:48:39 <dcoutts_> pastorn: that just requires bundling the right .dlls and we have a .zip with the right ones that you can include with the installer for the program you make.
12:48:51 <njbartlett> dcoutts_: gtk2hs not so nice on Mac though :-(
12:49:02 <dcoutts_> njbartlett: not yet, no
12:49:11 <dcoutts_> pastorn: so in that respect it's just like wxhaskell or any other lib that needs a bunch of .dlls
12:49:26 <pastorn> ok...
12:50:05 <dcoutts_> pastorn: as a demo of building a standalone .exe prog using gtk2hs, try: http://haskell.org/~duncan/gtk2hs/LSystemSetup.exe
12:50:28 <dcoutts_> note how it installs and works without you having to install gtk separately
12:50:59 <dcoutts_> note how the download size really isn't all that big (3.5M)
12:51:23 <pastorn> this is for something at work... my other option is to learn MS Access :/
12:52:01 <shapr> Well... SQL is a declarative language...
12:52:03 <dcoutts_> pastorn: well if you're just trying to make a gui front end for a db, access is quite quick
12:52:17 <pastorn> dcoutts: but booooooooooooooring
12:52:22 <dcoutts_> pastorn: sure :-)
12:52:36 <dcoutts_> I wouldn't say it's a strong point yet for the gui and db libs currently available for haskell
12:53:11 <dcoutts_> doable, but with a bit more fuss than access & VB (sadly)
12:53:14 <pastorn> and my "boss" (sorta) told me that if i did this i could get of driving the forklift :D
12:53:22 <dcoutts_> heh heh
12:53:31 * pastorn works at ikeas warehouse
12:53:55 <shapr> pastorn: Whoa cool
12:54:18 <pastorn> what they need is something that keeps track of how many people that are on each department each day, so i was thinknig of just doing a file-based system
12:54:18 <dcoutts_> pastorn: well we certainly don't want to put off our commercial users, but having realistic expectations is important too
12:54:57 <pastorn> dcoutts: we?
12:55:15 <dcoutts_> pastorn: we as in haskell developers / advocates
12:55:16 <dcoutts_> pastorn: I've got one code example someone sent me of a db thing with a gtk2hs ui
12:55:29 <pastorn> hehe
12:55:32 <pastorn> ah, cool
12:55:36 <pastorn> source too?
12:55:42 <dcoutts_> yes
12:55:46 <pastorn> oh... "code example"
12:59:44 <pastorn> fuck me!! that L-System example is in 3D
12:59:54 * pastorn picks up his jaw again
13:00:19 <mehrheit> is there a linux version?
13:01:21 <pastorn> mehrheit: wine prolly works... it's not that advanced, GUI-wise
13:02:27 <mehrheit> gtk2hs and hopengl applications should be cross-platform
13:03:06 <desp> does it make sense to use a  Map Foo () ?
13:03:24 <mehrheit> desp, as a set?
13:03:24 <dcoutts_> desp: use Set Foo perhaps?
13:03:39 <desp> does it offer O(1) lookup?
13:03:44 <dcoutts_> mehrheit: I'm not giving out the source to that app since we use it for an undergrad practical and we don't want solutions floating about the net :-)
13:04:12 <mehrheit> I can sign a non-disclosure agreement
13:04:13 <monochrom> L-system example in 3D? Sounds fun.
13:04:35 <desp> hm, O(log n)
13:04:47 <dcoutts_> mehrheit: making a binary for linux would be a tad harder, and really I only made it to prove that building distributable windows apps with gtk2hs is not hard.
13:04:53 <desp> ah, but so it Map
13:04:57 <desp> thanks for the suggestion
13:05:00 <desp> s/it/is/
13:05:02 <dcoutts_> monochrom: yeah, it's a really fun practical to run :-)
13:05:32 <mehrheit> dcoutts, is that an installer with gtk packaged that works out of the box?
13:05:42 <dcoutts_> mehrheit: exactly
13:06:07 <pastorn> dcoutts: where have you hiddin the source to that? is it steal-able?
13:06:07 <xerox> dcoutts_: ah! switched over to 3d? :)
13:06:49 <mehrheit> dcoutts_, reaction positive
13:07:09 <dcoutts_> xerox!! long time no see
13:07:18 * xerox hugs dcoutts_
13:07:22 <dcoutts_> xerox: how are you doing? overworked I hear
13:07:39 <xerox> My head was just about exploding, but I'm fine now, I think :)
13:07:46 <dcoutts_> pastorn: the source to what? the demo or the installer source?
13:08:02 <dcoutts_> poor xerox, he has to work so hard
13:08:29 <xerox> dcoutts_: you're back in Oxford, teaching and so forth?
13:08:41 <pastorn> the installer, i think... what i want to do is to be able to make just an exe without any installations being needed
13:09:06 <Heffalump> it's the summer! All the smelly undergrads will have gone home, or at least no longer need teaching.
13:09:09 <pastorn> cause i don't want to bother/have anything to do with the sysadmins
13:09:17 <Heffalump> All the clean-smelling ones too.
13:09:34 <dcoutts_> xerox: right, no teaching for the summer, just trying to write my thesis
13:09:46 <Heffalump> what's its title?
13:10:21 <mehrheit> dcoutts_, is the installer written in haskell
13:10:23 <dcoutts_> pastorn: it doesn't need admin privileges to install and I don't think it's that easy to make a .exe that needs no .dlls that'd require statically linking all the libs and they're not designed for that.
13:10:37 <dcoutts_> mehrheit: no, I use InnoSetup, it's open source
13:10:56 <xerox> dcoutts_: best luck! I'm looking forward coming about you wonderful place again sometime :) Now I'll have some sleep.
13:10:58 <mehrheit> ok
13:11:52 <pastorn> dcoutts: the dlls are free to reside inside ./DLLs
13:11:57 <dcoutts_> xerox: you're thinking of going to the AngloHaskell thing
13:12:08 <xerox> dcoutts_: yes!
13:12:48 <dcoutts_> pastorn: windows linker usually only looks in the same dir as the .exe, making it look in sub dirs is a bit harder, it involves embedding xml manifest files into the .exe and .dlls
13:13:13 <dcoutts_> xerox: cool, this time you can book in advance and take the overnight train via Paris ;-)
13:13:16 <xerox> The actual date is still unsure, early September would be perfect
13:13:38 <pastorn> dcoutts: ok, well, that could work too
13:13:44 <pejo> Does anyone happen to know of a webpage with dates for fp conferences?
13:13:48 <xerox> dcoutts_: oh yes, good idea. *post-its it*
13:14:09 <dcoutts_> pastorn: in future I'd like to use the xml manifest stuff but ghc's toolchain doesn't support that yet sadly.
13:14:46 <pastorn> but then you would have to know xml....
13:14:48 <pastorn> awww
13:15:02 * pastorn needs to go out and work now...
13:16:51 <xerox> dcoutts_: ttyl! goodnight.
13:17:12 <dcoutts_> g'night xerox
13:19:02 <Igloo> pejo: http://www.haskell.org/haskellwiki/Haskell
13:19:04 <lambdabot> Title: Haskell - HaskellWiki
13:23:23 <sgillespie> hello
13:24:12 <pejo> Igloo, thanks.
13:24:23 <eivuokko> dcoutts, Is there a plan for what all ghc should use manifests?
13:24:29 <ricky_clarkson> Igloo: In case you didn't know the URL was about Haskell, it tells you three times.
13:24:39 <sgillespie> I'm trying to build ghc from darcs and I'm getting...
13:24:40 <sgillespie> http://rafb.net/p/xMnNtg40.html
13:24:42 <lambdabot> Title: Nopaste - err.txt
13:25:00 <dcoutts_> eivuokko: not really, just a desire that it could. I don't know if any version of mingw has tools to do that.
13:25:20 <eivuokko> dcoutts, I think you just insert resource with right name.
13:25:29 <dcoutts_> eivuokko: right, and can we do that?
13:25:41 <eivuokko> dcoutts, Just link with resource file, I imagine.
13:25:59 <dcoutts_> eivuokko: and mingw has a resource compiler?
13:26:00 <eivuokko> dcoutts, which requires mingw installed atm, I think.
13:26:01 <sgillespie> anyone seen this before?
13:26:18 <SamB> dcoutts_: doesn't it?
13:26:32 <RobLeavy> http://www.AWSurveys.com/HomeMain.cfm?RefID=hai2u <-- Fill out the information and get an automatic $6 :P
13:26:33 <eivuokko> dcoutts, FWIW, I think winapi has functions to modify resources, might be quite easy to add it later too.
13:26:33 <lambdabot> Title: A.W.Surveys The New Survey Experience
13:26:34 <Igloo> sgillespie: What platform? And have you put anything in build.mk or anything?
13:26:40 <dcoutts_> SamB: I'd home so
13:26:46 <dcoutts_> eivuokko: oh, interesting
13:26:46 --- mode: ChanServ set +o shapr
13:26:50 --- kick: RobLeavy was kicked by shapr (Kicked by shapr)
13:26:54 <shapr> I hate spam.
13:27:20 <sgillespie> Igloo: sorry; I'm on gentoo-linux.  I just copied the build.mk from the dev wiki
13:27:44 <Igloo> sgillespie: URL?
13:28:00 <sgillespie> ...which happens to be
13:28:01 <sgillespie> http://rafb.net/p/DOMkbu26.html
13:28:02 <lambdabot> Title: Nopaste - mk/build.mk
13:28:05 <dcoutts_> eivuokko: so we could get ghc to include the resource compiler, but it needs to be able to invoke gcc correctly right, and that's what doesn't work atm with ghc's odd mingw stuff.
13:28:28 <shapr> Interesting, that irc spambot was smart enough to register itself with NickServ
13:28:29 <eivuokko> dcoutts, Yea, that's my recollection.
13:28:31 <dcoutts_> eivuokko: or perhaps we could use those winapi functions from inside ghc and avoid any resource compiler
13:28:42 <Igloo> sgillespie: Not sure what's happening. Can you try running "setup/Setup makefile -f GNUmakefile" in libraries/base please?
13:28:48 <dcoutts_> eivuokko: which might be nicer if ghc is going to drop gcc entirely
13:28:52 <sgillespie> sure
13:29:40 <Nopik> hi there..
13:29:47 <SamB> dcoutts: what, is it going to ship with a copy of MSVC instead?
13:29:54 <Nopik> newbie haskeller here, need little help :)
13:30:09 <dcoutts_> SamB: erm, maybe only the mingw assembler and linker
13:30:28 <SamB> dcoutts: ... so what will it build C code with?
13:30:28 <dcoutts_> SamB: but no C compiler, that's the idea, dunno if/when it'll happen
13:30:33 <sgillespie> I'm just going to put it here (2 lines)
13:30:35 <sgillespie> Setup: Errors:
13:30:35 <sgillespie> unexpected argument: GNUmakefile
13:30:54 <Nopik> i am trying to write map function.. this works: mmap f [] = []; mmap f a =  (f (head a)) : mmap (f) (tail a)   but this do not: mmap f [] = []; mmap f [x:xs] = (f x) : mmap (f) [xs]
13:30:58 <dcoutts_> SamB: if you want to build C code, use a C compiler :-)
13:31:01 <Nopik> what am i doing wrong in the second version?
13:31:20 <eivuokko> I am fairly certain writing a tool to modify resources wouldn't be hard either.
13:31:21 <SamB> dcoutts: Cabal won't be happy if it doesn't come with a compiler in future!
13:31:37 <shapr> Nopik: f (x:xs) = unpacks the head of the list into x, and the tail into xs.
13:31:46 <Igloo> sgillespie: Are all your repos up-to-date?
13:31:48 <fbuilesv> Nopik: it's (x:xs), not [x:xs]
13:31:53 <Nopik> yeah, i suspected that [x:xs] is not going to work :)
13:32:05 <shapr> Nopik: But [x:xs] just takes apart a list that is already inside a list, and then nothing happens.
13:32:11 <sgillespie> should be, this happened right after getting
13:32:17 <eivuokko> dcoutts, Anyway, so we need a plan for manifests...as they are needed anyway...but I'd like to have that logic in Cabal/other tool rather than in ghc.
13:32:35 <Nopik> works, thanks
13:32:36 <lucca> also you probably don't want [xs]
13:32:39 <lucca> right?
13:32:45 <Nopik> so, [x:xs] is just equal to x, right?
13:32:49 <dcoutts_> eivuokko: I think it might need to be in ghc anyway, otherwise building .exes manually will not work
13:32:51 <Igloo> sgillespie: What version of GHC are you using to compile?
13:32:56 <Nopik> lucca: yes, plain xs did the trick
13:33:18 <lucca> 1:2:3:[] is like [1, 2, 3]
13:33:21 <Nopik> ok, now i may continue with yaht ;0
13:33:33 <dcoutts_> eivuokko: since I'm assuming that we'd use manifests to make ghc's shared lib system work on windows, ie building a lib as a .dll and installing it as an isloated .dll assembly thingie
13:33:42 <lucca> : is an infix consing operator
13:33:53 <sgillespie> The Glorious Glasgow Haskell Compilation System, version 6.4.2
13:33:53 <eivuokko> dcoutts, Sigh.  That might be a bit messy.  Either ghc needs to be able to handle xml files and add tags or have excessive amount of manifest options...
13:34:00 <Nopik> lucca: yes, i know.. i have gone past this part, thanks
13:34:02 <sgillespie> should I update?
13:34:12 <Igloo> sgillespie: OK, I've got no idea what the problem is
13:34:40 <dcoutts_> eivuokko: and how to make that work without admin privileges I don't know, I think isolated assembly things are admin only
13:34:50 <Igloo> sgillespie: Looks like a Cabal problem, though
13:35:00 <eivuokko> dcoutts, Eh.
13:35:33 <sgillespie> i see...might it have something to do with gcc4?
13:35:45 <ricky_clarkson> Whoever was talking to me about the 'fix' function, thanks.  I got it a couple of days later.
13:35:45 <Nopik> btw. what is your recommended way to get grip on monads? i have read lots about them, many tutorials.. i think i have grasped the idea, but for now it was only reading, no test in real programs.. any tips how to get familiar with them most easily? (i am experienced programmer in non-functional languages, if that helps)
13:35:57 <Saizan> ?seen ndm
13:35:57 <lambdabot> I saw ndm leaving #xmonad, #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 29m 23s ago, and .
13:35:58 <fbuilesv> Could someone check http://hpaste.org/1584#a1 ? I don't understand the meaning of error (comment at the end)
13:36:04 <dcoutts_> eivuokko: as far as I know there is no per-user isolated assembly archive, only a global one
13:36:41 <eivuokko> dcoutts, Afaict, system-wide and installed-process can have it's own (next to executable).
13:36:46 <Igloo> sgillespie: Very unlikely
13:36:51 <fbuilesv> Nopik: There's a nice tutorial called "All about Monads" I think, it does a pretty good job explaining the concept.
13:37:04 <ricky_clarkson> Nopik: Implement Maybe in your chosen non-functional language, as a replacement for 'things that can be null'. ;)
13:37:06 <dcoutts_> eivuokko: exactly, only global and local to the program, not per-user
13:37:36 <shapr> Nopik: I like sigfpe's blog post --> http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
13:37:38 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ..., http://tinyurl.com/ecqzl
13:37:40 <dcoutts_> eivuokko: so to make a .exe work you'd have to copy all the necessary assemblies into the appropriate subdir near the .exe
13:37:40 <eivuokko> dcoutts, I am trying to see what is your point, but I just can't.  Optimising disk space?
13:37:41 <Nopik> Maybe should be simple as far as i remember
13:38:31 <dcoutts_> eivuokko: would ghc --make do all that? make a sub dir and copy all the .dlls over? seems like more than you'd want a compiler to do, but otherwise the .exe will not work.
13:38:52 <Toxaris> fbuilesv: createEntry definition s monadic, but it's type isn't
13:38:54 <ricky_clarkson> Nopik: It is.  But even such a simple monad will show up definiciencies in your language.
13:38:55 <eivuokko> dcoutts, Ah.  That was my point...I didn't want ghc --make to do it :-P
13:39:00 <ricky_clarkson> And in my typing.
13:39:21 <dcoutts_> eivuokko: if it references existing installed assemblies then the .exe can work, but those assemblies have to be installed as admin
13:39:26 <monochrom> You need strong static typing :)
13:39:36 <dcoutts_> eivuokko: so ghc --make would no longer work, I think that'd upset people
13:39:42 <Nopik> ricky_clarkson: yes, i know, that transferring simple haskell constructs to something else like c++ means very complicated c++ program :)
13:39:57 <Nopik> like a = 1 : a ;D
13:39:58 <fbuilesv> Toxaris: By the "return"? If it's for that, any idea of what to do to change that into a non-monaidc way?
13:40:01 <ricky_clarkson> C++ would be particularly bad, I think - as there's nothing approaching closures.
13:40:09 <Nopik> yeah
13:40:18 <Toxaris> fbuilesv: do notation is monad-only, for a start
13:40:53 <Saizan> fbuilesv: you're using timeNow which is inside a MonadIO, so you can't avoid createEntry to be monadic
13:40:57 <Toxaris> since timeNow is monadic, and has to be monadic since it relies on the real world to return some information about the world's state, createEntry has to be monadic too
13:41:17 <dcoutts_> eivuokko: I suppose C/C++ programmers are used to their .exe progs not working without being 'installed' but for Haskell programmers it'd be a big change in behaviour and much less convenient
13:41:24 <fbuilesv> Mmm, now I understand why Hope manages everything inside a Hope monad, thank you :D
13:41:27 <ricky_clarkson> What do Haskell programmers do where other programmers would use a logger?
13:41:38 <dcoutts_> eivuokko: so I don't know what the right solution is :-(
13:41:40 <eivuokko> dcoutts, There is a diffrence for Ms tools afaict, if needed, VS makes it work.
13:41:41 <ricky_clarkson> I'd imagine adding a logger would mean changing the function to be an IO function.
13:41:50 <dcoutts_> eivuokko: any idea how?
13:41:52 <eivuokko> dcoutts, And commandline compilers afaik don't
13:42:07 <dcoutts_> eivuokko: ah, right
13:42:09 <eivuokko> dcoutts, Copying, I imagine ;)  Probably some magic for running stuff.
13:42:11 <Saizan> ricky_clarkson: you can use a Writer monad
13:42:16 <Toxaris> ricky_clarkson: for quick and dirty debugging: Debug.Trace.trace
13:42:40 <ricky_clarkson> Do both Writer and DEbug.Trace.trace have no effect on the type of the function?
13:42:56 <Toxaris> Writer has but trace doesn't
13:43:08 <eivuokko> dcoutts, And for manifests, fwiw, they don't need to be inside exe's, they can be a file next to exe.
13:43:18 <Toxaris> trace is like adding printf-statements to your code in c
13:43:24 <dcoutts_> eivuokko: oh yes, that's true, I'd forgotten that.
13:43:30 <Toxaris> Writer is like passing a outstream to your function
13:43:39 <eivuokko> dcoutts, So to make ghc work, you could kinda do it already.
13:43:41 <ricky_clarkson> Toxaris: Does it use unsafePerformIO?
13:43:57 <Toxaris> ricky_clarkson: I think so.
13:44:34 <Toxaris> ricky_clarkson: wich may actually be a good thing, because it enables you to "see" on the console when thunks are evaluated
13:44:49 <ricky_clarkson> Ok.
13:45:05 <dcoutts_> eivuokko: so the reason I'd like ghc to do it of course is that it wouldn't change existing behaviour, I could put into the gtk package info to embed a link to a particular assembly
13:45:08 <ricky_clarkson> I asked dibblego the same question, and he said that logging is inherently broken, so Haskell programmers wouldn't want to do it.
13:45:10 <Toxaris> ricky_clarkson: but It's not suited for production code, I think
13:45:36 <eivuokko> dcoutts, I am terribly afraid manifests cannot be totally invisible to developer in all cases.
13:45:40 <ricky_clarkson> ..that Haskell programmers would just reason about the code, and try to prove that it works.  Does this seem accurate?
13:45:41 <dcoutts_> eivuokko: so people could build things normally and have them link to the gtk dlls without them all being on the path.
13:45:43 <DRMacIver> I love defining problems out of existence. :)
13:46:12 <DRMacIver> "How do you do Foo?" "Why would I want to do Foo? That seems a highly unreasonable activity."
13:46:13 <eivuokko> dcoutts, Does gtk in Windows have a proper installation for that?
13:46:49 <dcoutts_> eivuokko: no, but it's easy enough to embed a manifest into a representative gtk dll and then install the dll collection as an assembly
13:46:58 <Nopik> hm, this 'you could have invented monads' tutorial begins in quite interesting way.. i encountered this tutorial before, but skipped it for some reason..
13:47:26 <dcoutts_> eivuokko: at least that's what I've read, one can embed the manifest manually after the dlls have been built (which makes sense given that they're just resources)
13:47:28 <DRMacIver> @hoogle trace
13:47:29 <lambdabot> Debug.Trace.trace :: String -> a -> a
13:47:29 <lambdabot> Debug.Trace :: module
13:47:29 <lambdabot> Debug.Trace.putTraceMsg :: String -> IO ()
13:47:32 <Nopik> now i am reading through it and bits of my knowledge about monads finally started to match together ;
13:47:33 <monochrom> ricky_clarkson: I reason about my programs. But I welcome other people to trace. I trace too when I'm learning.
13:47:50 <ricky_clarkson> Nopik: Monads are very simple - in a lazy language you cannot force evaluation order unless you make one thing rely on the previousn thing's result.
13:47:55 <DRMacIver> ricky_clarkson: Given that there are various tracing solutions in the libraries, clearly *some* Haskell programmers want to do logging. :)
13:47:58 <dcoutts_> eivuokko: so the gtk2hs installer would have to take care of installing the gtk assembly
13:48:03 <eivuokko> dcoutts, Yes ofc they can be embedded later.  I think platform sdk or something even has commandline tool that especially handles some manifest magic.
13:48:08 <ricky_clarkson> DRMacIver: Perhaps those programmers are broken. ;)
13:48:27 <monochrom> Conclusion: production programmers trace because they're still learning.
13:48:44 <DRMacIver> Ah ha. We have the next step in "Defining a problem out of existence". ;)
13:48:50 <Saizan> ricky_clarkson: not every monad imposes an evaluation order
13:48:54 <dcoutts_> eivuokko: but then I'd want ghc to embed links to that assembly for all progs that use the gtk package, so that I don't have to put the gtk dlls on the path any longer
13:48:59 <Nopik> ricky_clarkson: yeah, figured this out already.. i just need some hands on experience on them.. and this is hard for newbie just to sit in front of computer and write program which defines monad and uses it ;p
13:48:59 <eivuokko> dcoutts, It'd make sense to me.  But unfortunately applications need to be able to cope with installation where gtk is installed side-by-side (or whatever it was called) with executable.
13:49:24 <DRMacIver> (As it happens I've yet to feel the temptation to use tracing in Haskell. But that's mostly a question of scale of Haskell code I write. And the fact that my code never has bugs anyway. ;) )
13:49:26 <Nopik> ricky_clarkson: but this tutorial seems just like the thing what i need
13:49:42 <Toxaris> ricky_clarkson: I use trace mainly with code written by other people to understand what happens
13:49:55 <monochrom> I agree with Toxaris.
13:50:07 <dcoutts_> eivuokko: I assume that one could have the assembly locally to the program and it'd still just work. I assume that when one embeds a ref to an assembly it's not specified if that assembly is local or isolated.
13:50:11 <monochrom> (Clearly, other people write spaghetti code!)
13:50:13 <ricky_clarkson> Is it a problem that you have to step outside the type system to add tracing?
13:50:35 <dcoutts_> eivuokko: so it could be isolated on the devs machine but local on an end users machine (put there by an installer)
13:50:46 <eivuokko> dcoutts, Yeah, I think so.
13:50:55 <monochrom> No, it is not a problem.
13:51:04 <dcoutts_> eivuokko: cool.
13:51:10 <eivuokko> dcoutts, Not 100% sure,  but I think I have seen instructions to just put right dll in right-named directory besides exe.
13:51:54 <eivuokko> dcoutts, I really need to test that stuff out -.-  At work our applications don't need this stuff almost at all for now, so I lack practical know-how.
13:52:02 <dcoutts_> eivuokko: so how many options do you think we'd need to put in these manifests? more than just refs to assemblies?
13:52:11 <dcoutts_> eivuokko: oh and that silly setup.exe workaround
13:52:12 <Toxaris> actually, I use something like trace' msg val = trace (msg ++ ": " ++ show val)
13:52:33 <dcoutts_> eivuokko: would it really mean that ghc would have to support dozens of new flags for manifest options?
13:52:36 <eivuokko> dcoutts, I think it goes to similar levels as, what's-that-called X11 resource stuff...
13:52:47 <dcoutts_> hmm, I see
13:53:02 <Toxaris> so i can change foo = <funny expression> to foo = trace "foo" <funny expression>
13:53:05 <Excedrin> in a language like C, if I have some complicated conditional statement I can order things so that the cheapest part is evaluated first; how does GHC figure out the evaluation order for things?
13:53:08 <monochrom> xrdb .Xresources? :)
13:53:16 <Toxaris> ehm, trace' "foo" ...
13:53:18 <dcoutts_> eivuokko: but clearly, no existing ghc users use that stuff right :-) so we don't need to support it :-)
13:53:37 <eivuokko> dcoutts, Hehe
13:53:47 <dcoutts_> eivuokko: or perhaps we'd just need one option for merging in a manifest from a file if people wanted more options
13:53:58 <eivuokko> dcoutts, Yeah, some template syntax or something.
13:54:22 <dcoutts_> eivuokko: well it's just xml, it should be easy to merge
13:54:22 <monochrom> Excedrin: you can do the same with if-then-else and case in Haskell.
13:54:28 <eivuokko> dcoutts, And ofc flags to ignore if developer thinks he knows what's he doing.
13:55:05 <pejo> @src (||)
13:55:05 <lambdabot> True  || _ =  True
13:55:05 <lambdabot> False || x =  x
13:55:06 <Excedrin> monochrom: ok, but I read stuff about how evaluation order isn't specified, so I'm curious if GHC reorders things and if it does, what are the rules?
13:55:16 <dcoutts_> eivuokko: sorry, gotta go home
13:55:33 <eivuokko> dcoutts, Np, I was just interested if there was a plan, actually :)
13:55:48 <dcoutts_> eivuokko: ideas, no plan as far as I'm aware
13:55:48 <monochrom> "evaluation order isn't specified" does not apply to case.
13:55:57 <eivuokko> dcoutts, Thanks for info and have fun.
13:56:10 <Vulpyne> If I am trying to break a list by a delimiting item, and then include a variable length list of other items with the split item similar to "X123XX5" = [('X',"123"), ('X', ""), ('X', "5")]
13:56:24 <Vulpyne> is there a nicer way than takewhile/drop and recursing?
13:57:47 <Excedrin> case and if are the same in that regard, correct?
13:58:03 <EvilRanter> Vulpyne, maybe a fold or unfold?
13:58:04 <Excedrin> (I think one is sugar for the other, but I'm not sure which)
13:58:15 <monochrom> "if b then x else y" you can fancy about evaluating x and y before b. That is called speculative execution. But fantasies aside, no haskell compiler actually does that. Now you know some order.
13:58:19 <Heffalump> if would be sugar for case, being less general
13:58:42 <Vulpyne> Hmm.
13:59:11 <Heffalump> monochrom: There have been implementations of speculative execution, but I don't think they evaluated under ifs like that. They just went beyond WHNF when evaluating specific things.
14:00:36 <monochrom> "case (x,y) of ([],_) -> e; (_,[]) -> f"  Haskell 98 specifically requires "go with the first match". Without speculative execution, again that also imposes an order.
14:01:48 <edwardk> actually the optimistic evaluation paper by ennals does jump around quite a bit in what it can evaluate speculatively. it should be able to evaluate safely any thunk it constructs as long as it doesn't encounter an 'error' or a unsafePerformIO'
14:02:04 <edwardk> even a thunk that it is just passing into a then or else clause
14:02:09 <monochrom> If you have speculative execution and the accompanying resource, "do cheap tests first before expensive tests later" is moot altogether.
14:02:11 <Heffalump> edwardk: ah, ok.
14:02:26 <Heffalump> it was that and Eager Haskell I was thinking of.
14:02:47 <edwardk> it relies on profiling to limit its speculation in specific areas where its losing big
14:02:48 <edwardk> yeah
14:02:52 <monochrom> If you don't have speculative execution, then Haskell semantics already imposes the desirable order for "cheap tests first".
14:03:30 <edwardk> i prefer the optimistic evaluation approach i think. it seems to get better results and be fairly simple conceptually
14:03:41 <Heffalump> it didn't get into GHC mainline though
14:03:55 <Heffalump> not sure why, I guess the results didn't warrant the complexity
14:04:34 <edwardk> the Ennals OE paper averaged like an 18-20% speed win, but there was a lot of craziness w.r.t managing the speculation engine
14:04:53 <Heffalump> really? I though it was only a couple of percent.
14:05:21 <monochrom> If you have 10 cores, but only 1 thread, there is no harm in "if b then x else y" doing b, x, y in parallel, killing the wrong one after b is known.
14:06:11 <edwardk> from the 2003 paper which was early it shows a speedup of just over 15%, then i seem to recall the results improving a little in the dissertation
14:06:18 <edwardk> http://citeseer.ist.psu.edu/cache/papers/cs/32672/http:zSzzSzresearch.microsoft.comzSzUserszSzsimonpjzSzPaperszSzoptimisticzSzicfp2003.pdf/ennals03optimistic.pdf
14:06:21 <lambdabot> http://tinyurl.com/2rw3qx
14:06:39 <Heffalump> fair enough. Looking it up agrees with you.
14:06:43 <Heffalump> I wonder why it didn't get in.
14:07:26 <shapr> Heffalump: I think the changes didn't make it into the mainline because it touched *everything* and because it was forked from a six+ months earlier version of GHC by the time anything was up for possible merging.
14:07:33 <shapr> I think I asked the Simons that in Cambridge.
14:07:55 <edwardk> I think it was too radical a change to the implementation strategy and it doesn't seem to win much when the strictness analyzer behaves well. plus it really really makes the runtime model complicated
14:07:56 <pejo> Heffalump, Ennals thesis implied it was too complex for making mainline iirc.
14:08:23 <edwardk> i'm hoping to use that approach myself in a compiler geared for it rather than hacked to handle it sometime.
14:08:31 <shapr> Though one big part of it could be that Ennals no longer believes that non-strictness is worthwhile, and he came to that conclusion after doing that thesis.
14:08:37 <edwardk> its a fairly viable way to skip strictness analysis
14:08:48 <edwardk> yeah
14:08:48 <Heffalump> what were his reasons?
14:09:08 <edwardk> he just doesn't seem to see the value of laziness as the default evaluation strategy iirc
14:09:15 <shapr> I think he just said pretty much that he didn't believe it's worthwhile.
14:09:21 <Excedrin> that's the same conclusion as CTM
14:09:27 <edwardk> the costs seemed too high to him from what i saw in his dissertation
14:09:27 <shapr> (as a default eval strategy, as edwardk says)
14:09:35 <edwardk> CTM?
14:09:43 <shapr> I asked him in personal email, I'll see if I can find his reply.
14:09:56 <EvilRanter> > (\c -> scanr (\x (n,_) -> (if x == c then n+1 else n, x)) (0,undefined)) 'X' "X123XX5" -- Vulpyne, is this useful?
14:10:00 <lambdabot>  Undefined
14:10:04 <EvilRanter> buh.
14:10:11 <EvilRanter> er, waitaminute.
14:10:25 <shapr> edwardk: Concepts of something... the book that's popular on LtU
14:10:33 <shapr> Isn't it the Oz book?
14:10:52 <sjanssen> @where cabal-install
14:10:52 <lambdabot> I know nothing about cabal-install.
14:10:55 <sjanssen> brr
14:10:56 <sjanssen> grr
14:11:03 <sjanssen> @where cabalinstall
14:11:03 <lambdabot> I know nothing about cabalinstall.
14:11:06 <shapr> @go ctm concepts
14:11:07 <pejo>  Concepts, Techniques, and Models of Computer Programming, by Peter van Roy.
14:11:08 <lambdabot> http://www.info.ucl.ac.be/~pvr/book.html
14:11:09 <lambdabot> Title: Concepts, Techniques, and Models of Computer Programming
14:11:11 <edwardk> found it
14:11:16 <Vulpyne> EvilRanter: Alright. :)
14:11:26 <sjanssen> @where+ cabal-install http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
14:11:27 <lambdabot> Done.
14:11:32 <EvilRanter> > tail $ (\c -> scanl (\(n,_) x -> (if x == c then n+1 else n, x)) (0,undefined)) 'X' "X123XX5"
14:11:34 <lambdabot>  [(1,'X'),(1,'1'),(1,'2'),(1,'3'),(2,'X'),(3,'X'),(3,'5')]
14:11:55 <EvilRanter> then you could group by the fsts or something
14:12:12 <Heffalump> oh, non-strictness. I knew he thought that.
14:12:26 <Vulpyne> evilranter: I'm looking for [('X', "123"), ('X', ""), ('X', "5")] as the result of that input.
14:12:30 <Heffalump> So that means he also thought trying to do anything in GHC wasn't worthwhile?
14:12:39 <EvilRanter> Vulpyne, yes, so I see. but it's a start.
14:12:55 <Vulpyne> EvilRanter: Would doing it that way actually be better than take/drop?
14:13:03 <edwardk> ideally i'd want something that was speculative by default, and really lazy or really eager by request, just so long as i can keep control of effects and remain pure
14:13:14 <EvilRanter> tail $ (\c -> groupBy (\(p,_)(q,_)->p==q) . tail . scanl (\(n,_) x -> (if x == c then n+1 else n, x)) (0,undefined)) 'X' "X123XX5"
14:13:27 <EvilRanter> > tail $ (\c -> groupBy (\(p,_)(q,_)->p==q) . tail . scanl (\(n,_) x -> (if x == c then n+1 else n, x)) (0,undefined)) 'X' "X123XX5"
14:13:30 <lambdabot>  [[(2,'X')],[(3,'X'),(3,'5')]]
14:13:34 <EvilRanter> wait, too many tails.
14:13:43 <EvilRanter> oh, nevermind. you can see what I was getting at.
14:13:49 <edwardk> speculation has better semantics than my original 'worst-case' 'whatever-the-heck the compiler chooses' semantics =)
14:13:56 <Vulpyne> EvilRanter: http://hpaste.org/1585
14:14:02 * DRMacIver oohs at cabal-install
14:14:04 <Vulpyne> EvilRanter: That was my naive solution, but I don't really like it.
14:14:12 <EvilRanter> Vulpyne, I don't know. with fusion, mine might be faster in the end, but it's premature optimisation
14:14:42 <Vulpyne> I was hoping there would be a pretty idiomatic way to do it, I guess. :)
14:16:30 <EvilRanter> > break ('X'==) "fooXbarXeek"
14:16:32 <lambdabot>  ("foo","XbarXeek")
14:16:35 <EvilRanter> helps
14:17:08 <Vulpyne> Hmm.
14:17:09 <Vulpyne> Maybe.
14:17:33 <shapr> Vulpyne: What about split from the LicensedPreludeExts?
14:17:34 <phoniq> so is there an easy way to get parsec to print some kind of trace/debug output while it does its thing?
14:17:57 <Nopik> ok, now is the tricky question... what is the difference between . and $ ?
14:18:03 <phoniq> i just dove into somebody else's grammar, having trouble seeing what it is doing
14:18:03 <Vulpyne> I'm not familiar with LicensedPerludeExts.
14:18:18 <Nopik> i have seen them used in similar contexts, though $ seems to be not appropriate in some cases.. why?
14:18:22 <Vulpyne> (By the way, I'm not actually parsing strings, the string thing is just a simile. :)
14:18:44 <Vulpyne> The actual program is going to be parsing a configuration file that has a line that starts an entry, and then a variable length set of lines describing stuff about it.
14:19:23 <EvilRanter> Vulpyne, what happens if it doesn't start with X?
14:19:28 <EvilRanter> (the input)
14:19:44 <Vulpyne> That should be considered an error.
14:19:49 <EvilRanter> ah.
14:20:23 <EvilRanter> is the input already split into lines before you call this function?
14:20:27 <eivuokko> dcoutts, FWIW, resource updating-functions already are binded in Win32 - just in a funny place.  Graphics.Win32.Resource.  Might be a bit incomplete, tho.
14:20:33 <Vulpyne> Yep.
14:20:50 <Vulpyne> It's the algorithm I'm having trouble with, not the details. :)
14:21:42 <glguy> prod
14:21:43 <glguy> ?users
14:21:43 <lambdabot> Maximum users seen in #haskell: 354, currently: 340 (96.0%), active: 23 (6.8%)
14:21:51 <hpaste>  Irrelevant annotated "(no title)" with "this should work" at http://hpaste.org/1585#a1
14:22:33 * glguy glares at the person that took the time to write Irrelevant instead of their actual nick
14:22:51 <EvilRanter> whups, sorry, that was me.
14:23:04 <EvilRanter> > sort "evilranter" == sort "irrelevant"
14:23:06 <lambdabot>  True
14:23:21 <glguy> fine, that's cool enough
14:23:32 <EvilRanter> =]
14:23:33 <glguy> carry on :)
14:24:29 <Vulpyne> EvilRanter: Nice, it works.
14:24:35 <Vulpyne> EvilRanter: Thanks.
14:24:44 <EvilRanter> no prob.
14:25:03 <Vulpyne> I like that better than what I had.
14:25:59 <EvilRanter> it should generalise fairly easily to lines in a file rather than characters in a string
14:26:10 <Vulpyne> Yep, I think so.
14:28:25 <sjanssen> does cabal-install work on Windows?
14:30:09 <fasta> What would be the generic scheme to call a function from libGSL? Is there an example anywhere that shows how to do that? I am interested in generating good random numbers.
14:35:46 <pastorn> what is this? gtk2hs deosn't approve of GHC 6.6.1
14:36:13 <sjanssen> fasta: you want to know how to use the FFI?
14:37:25 <fasta> sjanssen: well, I have not much experience with the process as a whole. It isn't just putting foreign cccall <> in a file and be done with it. It's also linking etc, using it from ghci or not, how to call ghc/ghci, etc.
14:37:37 <fasta> sjanssen: I am looking for a comprehensive source.
14:38:04 <fasta> sjanssen: last time I tried to call "hello world" from C GHC wasn't documented correctly.
14:38:19 <fasta> sjanssen: this has changed probably, but I don't know.
14:38:27 <fasta> sjanssen: I did succeed in the end, though.
14:38:49 <fasta> sjanssen: but I can imagine that calling a "real library" might be more difficult.
14:39:25 <fasta> sjanssen: e.g. maybe one needs to use NOINLINE or similar in combination with unsafePerformIO to wrap pure functions.
14:39:40 <SamB> fasta: um?
14:39:42 <fasta> sjanssen: there are lots of things one needs to know to use the FFI.
14:39:53 <SamB> oh, right, marshalling
14:40:07 <SamB> I actually don't think you need any NOINLINE
14:40:19 <fasta> sjanssen: so, yes, I want to know how to use the FFI.
14:40:57 <SamB> but I suppose it will probably not hurt if the function is costly to call...
14:41:54 <fasta> sjanssen: Does the silence mean there is no such resource?
14:42:25 <hpaste>  sjanssen pasted "very simple FFI" at http://hpaste.org/1586
14:42:30 <SamB> we probably should make an "FFI users manual" or something...
14:42:42 <sjanssen> fasta: I'm not aware of such a source
14:42:56 <eivuokko> Cookbook maybe.  Not sure how you ca make manual really, as it's very broad subject.
14:43:17 <sjanssen> fasta: the only flags you need to remember are "-fffi -lMYLIBNAME"
14:43:27 <SamB> eivuokko: how do you make a manual for anything of broad applicability?
14:44:04 <fasta> sjanssen: and then the Foreign.* libs tell me how to convert a String to a CString?
14:44:04 <eivuokko> SamB, Lots of manpower or pick-a-sub-category?
14:44:23 <fasta> sjanssen: if that's all, that sounds pretty easy.
14:44:29 <sjanssen> fasta: you might consider using Cabal, which can help you with compiling auxillary C files, figuring out link flags, etc.
14:44:33 <SamB> eivuokko: judiciously chosen examples
14:44:36 <eivuokko> fasta, Try hoogle, it probably indexes Foreign.
14:44:41 <sjanssen> fasta: yeah, the docs for Foreign.* have all the marshalling
14:44:54 <fasta> sjanssen: But doesn't using Cabal rule out ghci?
14:45:02 <sjanssen> fasta: yeah
14:45:29 <fasta> sjanssen: Maybe using Cabal too would not be wrong, but I don't give up ghci :)
14:45:35 <eivuokko> SamB, By all means, write it :-)  Just saying it seems very ambitious to me :)
14:45:48 <sjanssen> fasta: you probably don't need anything complicated (like Cabal) if you don't need to link in your very own C sources
14:46:18 <fasta> sjanssen: oh, I have no reason to use C, yet.
14:46:34 <fasta> sjanssen: C libs, yes, but not my own code.
14:46:37 <SamB> eivuokko: I would prefer to figure out how to con IBM into doing it...
14:46:47 <eivuokko> SamB, Hehe
14:48:58 <eivuokko> I can't recall, but I think writing C comes up rather fast if you need to support hugs and use ForeignPtr finalisers.  Really annoyed me in Win32.
14:49:34 <fasta> sjanssen: when I run that code I get 0x08bc1cf0
14:49:49 <fasta> sjanssen: that's to be expected, I guess.
14:49:51 <sjanssen> fasta: yeah, that's the pointer to a display handle
14:50:03 <fasta> sjanssen: ah, ok.
14:50:18 <sjanssen> fasta: that code isn't really useful.  It was just something that I could crib an example from quickly
14:50:55 <fasta> sjanssen: I understand. Just being able to run it gives confidence that more complex things run too.
14:51:07 <fasta> sjanssen: thanks
14:53:59 <fasta> The most important compiler bugs I reported got fixed in two days and some less important things got fixed too already. 6.8 is going to be great
14:55:31 <eivuokko> fasta, Good work finding bugs, and actually reporting them :)
14:55:49 <eivuokko> Eh, well, maybe finding bugs wasn't much fun.
14:56:02 <fasta> eivuokko: right, it's not.
14:56:17 <fasta> eivuokko: but if I didn't I had to delete all my cool tricks.
14:56:31 <fasta> eivuokko: and convert it to something more close to H98.
14:56:45 <fasta> eivuokko: which arguably made the programs less readable.
14:57:14 <fasta> eivuokko: are you of DeCSS fame?
14:57:20 <eivuokko> Eh
14:57:27 <eivuokko> No.
14:57:57 <fasta> There is someone else with a nickname starting with e that's from .fi who is, though.
14:58:08 <pastorn> about gtk2hs, it seems that there are multiple ways to approach making a GUI.
14:58:48 <pastorn> what i need is a way to dynamically generate a gui depending on data in certain files
14:59:27 <pastorn> does anyone know what would be the best approach? (glade? xml-stuff? just haskell code?)
14:59:48 <quicksilver> depends whether you can choose the file format or not
14:59:54 <quicksilver> glade does exactly what you describe
14:59:55 <eivuokko> fasta, Ah, Einar Karttunen iirc.
15:00:11 <quicksilver> (generates a gui from files)
15:01:18 <pastorn> say, that i have a file like this "A \n B \n C \n D\n" then i will need 4 text-fields named ABCD for putting data into
15:01:22 <dcoutts> pastorn: if your set of guis is fixed, then glade is perfect, if it's much more variable then haskell code interpreting a Haskell data structure read from a file might be the way to go.
15:01:59 <dcoutts> pastorn: it's also possible to have a glade gui with components that are generated at runtime
15:02:26 <pastorn> dcoutts: that might be the way to go then... i have to learn and have this finished by friday
15:02:30 <dcoutts> pastorn: eg just get get a reference to the container widget and then pack a bunch of child widgets in using code at runtime
15:02:52 * pastorn can't help to feel that he's ben suprise sex:ed
15:03:12 <pastorn> dcoutts: sounds simple and do-able
15:06:10 <glguy> ?seen dons
15:06:10 <lambdabot> dons is in #xmonad, #haskell and #ghc. I last heard dons speak 9h 8m 31s ago.
15:06:22 <SamB> hmm, how am I supposed to get foreign exported functions to have the right types...
15:07:15 * SamB is mumbling about JHC hacking
15:07:26 <mwc> JUst to clarify my understanding of the current Haskell Database situation (the HackageDB database section is gigantic)
15:07:42 <mwc> HSQL is a lower-level lib that more or less sends strings to a DB engine
15:07:58 <mwc> HaskellDB is a higher level one that lets you construct queries algebraically in some sort of DSL?
15:08:48 <dcoutts> mwc: right, and HDBC is in the same category as HSQL
15:09:12 <DRMacIver> Hm, what on earth does 'sparking' do? (in Control.Parallel.Strategies)
15:10:46 <mnislaih> DRMacIver: I believe,  spark  =  start a new thread(s)
15:11:02 <DRMacIver> (Ah, I see, there are comments in the source they just haven't made it into the documentation)
15:11:23 <mwc> thanks dcoutts... got a hair brained idea for a personal wiki with distributed collaboration features
15:11:31 <mwc> s/hair/hare
15:11:42 <dcoutts> mwc: backed by darcs? :-)
15:12:25 <dcoutts> mwc: Igloo has a prototype wiki with a darcs backend, you might find it an interesting reference
15:12:30 <DRMacIver> mnislaih: Hm. Looks like it's something like that, yeah.
15:12:46 <mwc> I was thinking I might use Darcs' TOP, but I'm looking more at a DB based backend for scalability
15:13:35 <mwc> the idea would be that you can sync your private "pool of knowledge" with smoebody else: you and a class mate could trade course notes kept in the wiki. Developers on a projet could share design ideas, etc.
15:13:54 <ddarius> DRMacIver: That's what it is.
15:14:42 <DRMacIver> Yeah, but I'm having trouble figuring out exactly how it's intended to be used. :)
15:15:09 <mwc> though I've just had the scary realization that with symlinks, you could in principle turn the FS into an arbitrary graph and use darcs to manage it
15:15:30 <DRMacIver> Am I write in thinking that sparking foo bar evaluates to foo but causes bar to be evaluated in parallel?
15:15:46 <DRMacIver> right
15:15:55 <DRMacIver> (I speak english good, honest)
15:16:38 <mnislaih> DRMacIver: more or less. The 'par' combinator does just that. "par x y"  sparks a thread to evaluate x and returns y
15:16:50 <david48> Good evening Haskellers :)
15:16:55 <mnislaih> but you should really read the "algorithm + strategy = parallelism" paper
15:16:56 <DRMacIver> Yeah. sparking appears to just be flip par
15:17:22 <DRMacIver> ok. It would probably be helpful if that paper were linked from the documentation. :)
15:17:29 <mnislaih> yay :S
15:17:35 <DRMacIver> (Or even the source)
15:18:02 <mnislaih> I think the documentation is updated in the wiki somewhere, but didn't make it to the official docs for some reason
15:18:25 <mnislaih> http://www.haskell.org/ghc/dist/current/docs/parallel/Control-Parallel-Strategies.html
15:18:27 <lambdabot> http://tinyurl.com/2rcocd
15:18:34 <mnislaih> it is in the HEAD docs
15:18:56 <DRMacIver> Ah yes. That's rather better.
15:18:58 <DRMacIver> Thanks.
15:19:05 <mnislaih> nvm
15:19:56 <SamB> okay, I really don't know how I should pass the type with which a function is being foreign exported from JHC's frontend to it's backend...
15:20:37 <DRMacIver> Should I update the wiki page on parallelism to point to the head docs?
15:21:22 <DRMacIver> As the ones it currently points to are next to useless. :)
15:22:38 <mnislaih> DRMacIver: that would be great, dont hesitate
15:24:44 <dibblego> can Haskell perform pointer equality for a memo function?
15:25:07 <ddarius> Yes...
15:25:15 <ddarius> (non-standardly)
15:25:18 <mwc> dibblego: I htink there's an evil way involving the FFI, but a better way is just to share the same reference from the start
15:25:30 <dibblego> ok cool
15:25:38 <dibblego> just reading SPJ's paper on memoing
15:25:50 <mwc> create the reference early, and let lazyness defer it
15:26:05 <ddarius> @google memo functions polytypically
15:26:09 <dibblego> ok thanks
15:26:10 <lambdabot> http://www.cs.uu.nl/~johanj/wgp2000/HinzeMemo.ps
15:28:33 <DRMacIver> Done
15:56:53 --- mode: irc.freenode.net set +o shapr
15:56:53 --- mode: irc.freenode.net set +o ChanServ
16:02:27 <dcoutts> @seen dons
16:02:34 <lambdabot> dons is in #xmonad, #haskell and #ghc. I last heard dons speak 11m 4s ago.
16:03:07 <dons> @seen dcoutts
16:03:07 <lambdabot> dcoutts is in #haskell-overflow, #haskell, #ghc and #gentoo-haskell. I last heard dcoutts speak 33s ago.
16:03:16 <dcoutts> g'morning dons :-)
16:04:02 <dons> :) back in 20 -- breakfast calls.
16:06:06 <dibblego> is there a way of not having to list every new source file, and therefore, module, in the CABAL "exposed-modules" entry?
16:07:49 <dcoutts> dibblego: not yet
16:07:58 <dibblego> ok
16:08:25 <dcoutts> dibblego: and when there is, all it'll be is an error/warning that you need to add a given list to the exposed-modules
16:08:37 <dcoutts> dibblego: because it could of course be a non-exposed module
16:08:48 <dibblego> righto
16:09:03 <dibblego> a warning would be handy anyway
16:09:11 <dcoutts> remember, exposed modules are part of the public api of your package
16:09:18 <dibblego> right
16:09:20 <dcoutts> "other-modules:" are the private ones
16:09:49 <dcoutts> currently if you don't list modules they get treated as being in "other-modules:"
16:10:25 <dcoutts> but that's mostly by accident, since ghc --make will find all deps even though they're not listed in either exposed-modules or other-modules
16:10:54 * SamB thinks he has almost got JHC working with foreign export for real...
16:10:57 <dcoutts> when cabal does it's own dep analysis it'll be able to figure out if you're using things you've not listed
16:11:30 <dibblego> ok thanks
16:12:48 <Figs> http://citeseer.ist.psu.edu/cache/papers/cs/471/ftp:zSzzSzftp.dcs.glasgow.ac.ukzSzpubzSzglasgow-fpzSzpaperszSzimperative.pdf/peytonjones93imperative.pdf
16:12:50 <lambdabot> http://tinyurl.com/35pw8h
16:13:48 <Figs> ^^ That's pretty cool^^
16:17:57 * SamB hopes he got the pretty-printing code right
16:18:25 <SamB> well, it looks like GCC was okay with the program ;-)
16:23:17 <cpfr> howdy
16:23:31 <Figs> i hola !
16:23:45 <cpfr> i just realized monads are a consequence of haskell's type system and not a native feature of the language
16:23:48 <Figs> bonjour!
16:24:00 <Figs> konichiwa!
16:24:07 <cpfr> prevet
16:24:19 <Figs> http://citeseer.ist.psu.edu/cache/papers/cs/471/ftp:zSzzSzftp.dcs.glasgow.ac.ukzSzpubzSzglasgow-fpzSzpaperszSzimperative.pdf/peytonjones93imperative.pdf
16:24:21 <lambdabot> http://tinyurl.com/35pw8h
16:24:26 <Figs> take a look at that :D
16:24:38 <Figs> it talks about monadic IO
16:24:50 <Figs> I figure it's rather old though
16:24:54 <Figs> *cough 1992*
16:25:27 <cpfr> read it already
16:25:32 <Figs> ah
16:25:36 <cpfr> i understand monads
16:25:42 <Figs> I think I do.
16:25:51 <Figs> not 100% sure :P
16:25:51 <Saizan> yeah Monad is not a primitive of the language, is just a typeclass with related syntactic sugar :)
16:26:05 <dons> cpfr: a consequence of the type system? -- type classes et al?
16:26:07 <cpfr> i was just thinking about what would require them to be implemented in other lanfs
16:26:25 <dibblego> higher-ranked type system
16:26:38 <cpfr> dons, sorry i meant yes type classes and all kinds of stuff
16:26:59 <dons> yeah, type classes make it feasible to make them pervasive
16:27:32 * robyonrails saluta tutti
16:27:35 <wli> Why monads and not, say, arrows?
16:27:38 <dibblego> cpfr, to answer your question, I think it is easier to look at Functor
16:27:39 <SamB> there *is* that "do" notation to remember
16:27:54 <dibblego> cpfr, this simplifies the example, while still answering your question, by implication
16:28:04 <SamB> wli: for what?
16:28:13 <dons> wli, we had monads first.
16:28:19 <wli> SamB: Wrapping IO, pervasive stuff, etc.
16:28:22 <dons> and arrow notation is harder
16:28:34 <dons> building graphs, instead of sequences
16:28:34 <SamB> wli: I call to your attention Kleisli
16:28:52 <SamB> yes, dons is correct. arrow notation *is* harder
16:29:05 * Figs gets some soda and watches the discussion
16:29:26 <wli> How much is the added generality worth?
16:29:32 <cpfr> i dont think i asked a question
16:29:38 <SamB> it depends on what you are doing
16:29:52 <cpfr> and the functor definition is what made me finally get it
16:29:57 <wli> Yeah, that does make it hard to answer across a whole language.
16:30:24 <Rebooted> hi, does anyone have wxhaskell working in ghc 6.6.1?
16:30:36 <SamB> anyway, eventually we plan to support SVG-based Arrow syntax sugar
16:30:39 <cpfr> i was looking for a good way to port the Writer Monad into C++
16:30:42 <SamB> </kidding>
16:30:52 <cpfr> not sure how far im going to get
16:30:58 <wli> SamB: What's SVG?
16:31:06 <SamB> wli: Scalable Vector Graphics
16:31:36 <wli> SamB: Hmm. Are you thinking like writing a commutative diagram or some such that's directly interpreted?
16:31:58 <fbuilesv> is there any library with the usual string handling operatiosn like split or sub? I can't seem to find much information in the list part of haskell report.
16:32:07 * Figs doesn't know what the Writer monad is, but he knows a lot about C++
16:32:12 <Figs> what's writer do?
16:32:27 <bos> fbuilesv: MissingH has some of that stuff
16:32:31 <wli> Figs: It builds up a sequence on the side (usually a string).
16:32:32 <SamB> wli: it would be desugared at somet point during the compilation process. Just imagine the error messages!
16:32:40 <Figs> like, logging?
16:32:50 <fbuilesv> bos: thank you.
16:32:52 <shapr> Figs: Writer passes around an environment of values. Have you seen "All About Monads" ?
16:32:53 * SamB tries to imagine GHC error messages with chunks of pictures in them
16:33:03 <Figs> No.
16:33:32 <wli> SamB: Epigram does something unusual with quasi-diagrammatic code structure as well, doesn't it?
16:33:39 <Figs> I think I get the general idea about monads, but I don't know all the ones that have been written yet
16:33:49 <SamB> Epigram just has 2d textual syntax
16:33:50 <shapr> @where allaboutmonads
16:33:51 <lambdabot> I know nothing about allaboutmonads.
16:33:52 <shapr> foo
16:33:57 <Figs> :P
16:34:01 <Figs> shoot
16:34:03 <SamB> not quite as crazy as what I'm suggesting ;-)
16:34:07 <shapr> wli: But it's pretty sexy syntax.. right out of TApL
16:34:08 <Rebooted> wli: it has a 2d syntax, I don't think it has anything more than that
16:34:10 <shapr> er, TaPL
16:35:11 <Rebooted> it doesn't have much at all last time I checked, anyway
16:35:43 <wli> Natural deduction or sequent calculus -based or some such.
16:35:52 <jfredett> hmm, is there a way to have a type class for type classes? (a metatype class, I suppose?
16:36:16 <SamB> of course, the sort of syntax I am talking about is also 2d, but it has those arrows going in various directions as well...
16:36:37 <jfredett> eg, a Type class "Commutative" which states that any type class implementing must only provide functions which are commutative? (probably not the best example)
16:37:11 <shapr> jfredett: You could use phantom types to tag such things.
16:37:17 <SamB> jfredett: are you asking if you can do that in Haskell today?
16:37:26 <jfredett> well, I'm really just curious
16:37:33 <jfredett> it seems like a useful concept
16:37:34 <SamB> or are you asking if a language with that is feasable?
16:37:43 <jfredett> i guess both.
16:38:01 <SamB> you may have guessed that the answer to the first is "no"...
16:38:07 <jfredett> yah
16:38:21 <Rebooted> coq can do things like that though
16:38:27 <jfredett> nifty
16:38:54 <jfredett> so that kinda answers my second question
16:40:20 <Rebooted> you can define something like a monad typeclass that requires implementations to obey the monad laws
16:40:25 <Figs> Really, really bad lag.
16:41:51 <Rebooted> so, does anyone have wxhaskell working on the current ghc, or should i use Gtk2Hs?
16:42:10 <Figs> sorry, having connection problems
16:42:37 <dcoutts> Rebooted: of course I recommend Gtk2Hs, but then I help maintain it :-)
16:42:42 * glguy wonders which is prefered between: MVar () and QSem   when the QSem would always be 0 or 1
16:43:06 <dcoutts> glguy: QSem is based on MVar, so the MVar solution seems simpler
16:44:03 <Figs> ok, I'm in, but no user list :(
16:44:03 <Figs> am I showing up as Figs, Figs_, Figs__ or something else?
16:44:03 <Figs> or can you guys not even see what I'm writing?
16:44:16 <Rebooted> Figs
16:44:21 * shapr considers pretending not to see Figs
16:44:27 <shapr> But that would be cruel!
16:44:29 <Figs> ok, so you can see me
16:44:38 <Figs> that's good :)
16:44:45 <Figs> I don't know wtf is wrong with my client
16:45:16 <Figs> brb
16:45:49 <Figs_> there we go :)
16:48:14 <dons> win 7
16:48:19 <shapr> better than losing!
16:48:30 <dons> true!
16:49:49 <wli> Hmm, reading the epigram docs, I should probably really learn and use it.
16:50:43 <Rebooted> dcoutts: looks like i'll be using it
16:51:00 <dcoutts> Rebooted: :-)
16:51:11 <Rebooted> dons: out of interest, why did you use gtk2hs for yi? Was wxhaskell around? Are you just familiar with gtk?
16:52:32 <Rebooted> wli: it's not very usable yet, really. There is some new work but the current implementation runs in xemacs and basically just accepts type declarations
16:53:03 <Rebooted> the papers are interesting though
16:53:06 <wli> Rebooted: Oh dear. I'll have to check out some other dependently-typed language, then.
16:53:12 <dons> Rebooted: i used ncurses, jyp chose gtk
16:53:48 <dons> and wxhaskell isn't terribly well maintained, while we were able to get changes into gtk2hs as we went along
16:53:58 <shapr> Yeah, that's a big difference.
16:54:21 <dcoutts> does wxhaskell actually have a release that works with ghc-6.6.x ?
16:54:25 <shapr> Some (all?) of the gtk2hs developers are available right here on #haskell, the wxHaskell guys were slow to respond.
16:54:46 <Rebooted> dons: ah, ok. I've definitely noticed the maintenance issue, too
16:54:57 <Rebooted> dcoutts: doesn't seem so :-)
16:55:16 <dcoutts> I've heard of patches floating around, but I've never seen them
16:55:19 <shapr> g'day Pseudonym
16:55:25 <Pseudonym> G'day.
16:55:29 <Rebooted> looks like gtk2hs it is, then
16:55:41 <dcoutts> I'd like to update wxhaskell in gentoo to work with ghc-6.6 but have not been able to so far
16:56:22 <shapr> Does that mean fork and update, and ask on haskell-cafe if anyone wants to maintain it?
16:56:49 <Pseudonym> Who nominally maintains wxhaskell now?
16:56:50 <Saizan> > fromList [1] `union` undefined
16:56:51 <lambdabot>   Not in scope: `fromList'
16:56:58 <Saizan> > Data.Set.fromList [1] `union` undefined
16:56:59 <lambdabot>  Couldn't match expected type `[a]'
16:57:22 <shapr> I know Daan Leijen got it started, but I think some other uu.nl students were maintainers for awhile.
16:58:23 <Rebooted> according to the website, Jeremy O'Donoghue
17:00:28 <dons> i thought kowey took over?
17:00:40 <sioraiocht> is there any way to speed up the squaring of a very large number?
17:01:41 <Pseudonym> sioraiocht: An Integer, you mean?
17:01:49 <sioraiocht> Pseudonym: sorry, yes
17:02:05 <Pseudonym> There might be a GMP method you can use, but otherwise, probably not.
17:02:21 <Pseudonym> The GMP multiplication algorithms are optimised for numbers of approximately equal magnitude.
17:02:28 <Pseudonym> The best you'd get is avoiding one of the FFTs.
17:02:56 <Pseudonym> So how big are these numbers?
17:04:11 <sioraiocht> 2^20099983
17:04:19 <Pseudonym> Ouch.
17:04:29 <Pseudonym> Can I ask what you're doing with them?
17:04:47 <sioraiocht> Lucas Lehmer testing
17:05:07 <wli> wikipedia says Cayenne emits Haskell which is somewhat at variance from what the homepage says.
17:05:14 <sioraiocht> my SoC project involved custom-made FFTs for the squaring
17:05:29 <sioraiocht> *involves*
17:05:41 <sioraiocht> was wondering how different libgmp's FFT performance was
17:05:45 <sioraiocht> it sucks in comparison, lol
17:05:50 <Pseudonym> First off, GMP has a n^k mod m operation.
17:05:56 <sioraiocht> what
17:06:00 <sioraiocht> is that accessible in haskell?
17:06:19 <Pseudonym> I'm not certain, but if you look at the GHC libraries, you can probably work out how to do it.
17:06:27 <dpiponi> Haskellish question: anyone know a paper that has a clear definition of "guarded (co)recursion". (Or can someone give me one.)
17:06:29 <Pseudonym> Oh, hang on.
17:06:55 <kilimanjaro> sioraiocht, what is your SoC project?
17:07:21 <sioraiocht> optimising an FFT app for opensolaris
17:07:31 <kilimanjaro> ahh
17:07:36 <sioraiocht> using prefetching and parallelisation for SPARC servers
17:07:44 <kilimanjaro> it's a library?
17:07:49 <sioraiocht> no
17:07:51 <edwardk> when specifying a rewrite rule in ghc, can you use a pattern variable more than once in the lhs? i.e. {-# RULES "a-a" [1] forall a. a - a = zero #-}   ?
17:07:55 <kilimanjaro> what is the app?
17:07:59 <sioraiocht> Mlucas?
17:08:02 <sioraiocht> it's used by GIMPS
17:08:04 <wli> sioraiocht: SoC = ?
17:08:07 <Rebooted> wli: what does the homepage say?
17:08:09 <sioraiocht> wli: Summer of Code
17:08:18 <SamB> edwardk: ... why don't you try it?
17:08:19 <wli> Rebooted: Lazy ML ("LML").
17:08:22 <sioraiocht> GIMPS = Great Internet Mersenne Prime Search
17:08:29 <kilimanjaro> ahh
17:08:39 <kilimanjaro> you use FFT for bignum multiplication?
17:08:45 <SamB> edwardk: but you probably want to restrict the type of that rule
17:08:48 <edwardk> samb: coz my test case has a lot of machinery around it. i was hoping for a quick answer ;)
17:08:57 <edwardk> samb: i have, that was just an example
17:09:17 <sioraiocht> kilimanjaro: yeah, int he lucas lehmer primality test you have to a a lot n^k mod m operations
17:09:28 <SamB> the other thing is to try either reading the code or posting on a mailing list...
17:09:55 <sioraiocht> like O(n) where n is the value of the prime number being tested
17:10:12 <kilimanjaro> sounds like fun
17:10:37 <sioraiocht> it's been alright ;)
17:10:43 <sioraiocht> wanted to see how haskell would bear up
17:10:48 <wli> ISTR there being methods asymptotically even faster than the modular FFT's.
17:10:51 <sioraiocht> since parallelising C code is..less than fun
17:11:11 * SamB thinks he's made JHC's FFI support as about as good as he can while still being anywhere close to ANSI C
17:11:15 <wli> AIUI they're phenomenally involved, though.
17:11:26 <kilimanjaro> sioraiocht, what's your opinion on haskell for this project?
17:11:52 <kilimanjaro> i.e. how effective do you find it to be for doing stuff that involves lots of machine specific performance tweaks?
17:12:03 <sioraiocht> kilimanjaro: that's what I'm curious about
17:12:08 <kilimanjaro> stuff like that is usually relegated to C so it's interesting to me
17:12:25 <kilimanjaro> sioraiocht, ahh, maybe I should check with you in a few months :)
17:12:34 <kilimanjaro> or else just go do something similar for myself
17:12:36 <sioraiocht> I think this sort of thing would benefit from a set of bindings for some of the stuff
17:12:48 <wli> ISTR their asymptotic advantages not setting in until ranges bordering on impracticality for non-supercomputer hardware so maybe it's not all that interesting.
17:13:14 <sioraiocht> there IS a faster variation of the current FFT method being published later this year
17:13:40 <wli> sioraiocht: Probably more useful. I don't believe these are FFT-based.
17:15:40 <Pseudonym> OK, no idea how to use GMP stuff from Haskell.
17:15:50 <Pseudonym> I thought I saw soemthing about it once, but can't find it now.
17:15:58 <sioraiocht> something to figure out, hehe
17:15:58 <Pseudonym> The GMP power-mod function is pretty efficient.
17:16:08 <Pseudonym> Because it works on the bit representation.
17:16:15 <sioraiocht> if it beat this coders' performance he would be..upset
17:16:17 <sioraiocht> hehe
17:16:27 <sioraiocht> but it probably won't be, he's done a LOT of tweaking
17:16:31 * Pseudonym nods
17:16:46 <Pseudonym> It is faster than anything you can write in pure Haskell using Haskell Integers, though.
17:16:48 <sioraiocht> but personally, i'd liek to generate bindings on his functions
17:17:07 <Pseudonym> Hey, if it has a better licence, we'd all be happy if we could dump GMP.
17:17:13 <Pseudonym> Especially if this code is more efficient.
17:17:28 <sioraiocht> I think that haskell could be a good "glue" language for stuff that is mathematically complicated
17:17:31 <SamB> especially if it doesn't tickle so many GCC bugs, right?
17:17:35 <sioraiocht> but demands high performance
17:17:39 <Pseudonym> Right.
17:17:43 <sioraiocht> that's what I told HIM
17:17:54 <dcoutts> I've never understood why people don't like the GMP licence, it hardly demands anything of you
17:17:56 <sioraiocht> and he's like "yeah, I'll get to modularizing it...someday"
17:17:57 <Pseudonym> Haskell is a DSL for low-level hacky libraries.
17:18:13 <sioraiocht> dcoutts: he meant if something had a good licence that he coudl use to replace GMP
17:18:14 <Pseudonym> dcoutts: It's inappropriate for the standard library of a programming language.
17:18:27 <sioraiocht> oops, maybe not
17:18:28 <sioraiocht> hehe
17:18:35 <Pseudonym> It means, for example, that you can't statically link a binary in Haskell and distribute that.
17:18:44 <Pseudonym> Without it being GPL/LGPL.
17:18:57 <sioraiocht> I believe he would release it under LGPL
17:19:03 <sioraiocht> all the work I'm doing is under GPL
17:19:18 <sioraiocht> although he, too, manages to find just about every compiler bug ever
17:19:20 <Pseudonym> Even so, my point is that LGPL is great for standard libraries written for C, but not for Haskell.
17:19:29 <dcoutts> Pseudonym: well, you can, you just have to distribute the .a libs you linked your app from so your customer can relink the application.
17:19:30 <Pseudonym> Simply because of the way the implementation works.
17:19:46 <sioraiocht> it's silly that you have to make the distinction =/
17:19:52 <Pseudonym> Yeah, I agree.
17:20:13 <Pseudonym> And for the record, I think that the LGPL works great for languages like C, where .a files are all you need.
17:20:52 <Syzygy-> One of the inventors of the Saneblidze-Umble diagonal just wrote me back to say that 1) my paper looks really good, 2) I might want to implement the method to choose signs for the terms, and 3) a list of minor, minor edits.
17:20:56 <Syzygy-> This is what makes me -cocky-
17:20:59 <Syzygy-> I'm gonna get published! BOO-YAH!
17:21:06 <Pseudonym> Woo!
17:21:07 <Pseudonym> Congrats!
17:21:23 <sioraiocht> Syzygy-: Grats!
17:21:26 <sioraiocht> first time?
17:21:35 <Syzygy-> sioraiocht: Nah, I have one publication to my name.
17:21:44 <Syzygy-> But that hardly counts - it was in a conference proceedings.
17:21:48 <sioraiocht> Syzygy-: I have 0, sooo ;)
17:21:53 <sioraiocht> where is this being published?
17:21:58 * Pseudonym only has one
17:22:08 <Syzygy-> Most probably JHRS. Journal of Homotopy and Related Structures
17:22:15 <Pseudonym> And it was at TPC, so it REALLY doesn't count.
17:22:29 <sioraiocht> there's a journal for that?!?
17:22:29 <Syzygy-> One of the editors saw the basically same thing as a blog post and emailed me to tell me to get it typed up as a paper.
17:22:42 <Syzygy-> sioraiocht: Of course!
17:22:45 <Syzygy-> There are two!
17:22:49 <sioraiocht> hahah
17:22:51 <sioraiocht> silly me
17:22:53 <Syzygy-> There is Homology Homotopy and Applications too.
17:23:09 <Syzygy-> Both were founded by the same georgian professor...
17:23:18 <Syzygy-> But he missed out on the legalities, so he lost control of HHA.
17:23:29 <dpiponi> Hi Syzygy
17:23:34 <Syzygy-> And since a year or two, they've been working on JHRS, and now they -really- want international submissions.
17:23:38 <Syzygy-> dpiponi!! WOOO!
17:23:48 <Syzygy-> dpiponi: By the way - where in the US are you located?
17:23:57 * Syzygy- has a bunch of US tours lined up for next spring....
17:24:08 <dpiponi> Live on Oakland, work in San Francisco, born in London
17:24:11 <dpiponi> s/on/in/
17:24:14 <sioraiocht> Pseudonym: that number form before, btw, is 6050698 digits long, heh
17:24:18 <Syzygy-> I will definitely be visiting Philadelphia and Stanford, probably also take a trip to Princeton.
17:24:26 <Syzygy-> And I might end up going to the AMS national in San Diego.
17:24:33 <dpiponi> Stanford is just down the road. Well maybe 40 minutes drive.
17:24:41 <sioraiocht> Syzygy-: San Diego is amazing, I used to live there
17:24:44 <Syzygy-> dpiponi: Woooo! Meet up in march/april some time?
17:25:00 * Syzygy- is slightly ... out there.
17:25:01 <dons> oh no! dpiponi and Syzygy- in the same room.
17:25:09 <dpiponi> march/april? Woah! Forward planning???
17:26:03 <dpiponi> But yes, if you remind me, say a few days before!
17:28:23 <Syzygy-> It's half past 2 am, I've been drinking with old and new students - and I won a bartending contest!
17:28:23 <Syzygy-> First time I hold a shaker!
17:28:23 <Syzygy-> Oh, and I have gotten hold of Infected Mushroom: Converting vegetarians.
17:28:23 <Syzygy-> IT's all I can do not to pump up the volume, waking the next block or so.
17:28:23 <Syzygy-> dpiponi: Did I show you the paper I'm preparing btw?
17:28:23 <Syzygy-> It's an implementation of a well known method from homotopy theory. And simultaneously a paper demonstrating that the implementation corresponds precisely to the description of the method already published.
17:28:23 <Syzygy-> http://mpc723.mati.uni-jena.de/~mik/SaneblidzeUmble.pdf
17:28:34 <Syzygy-> kk
17:28:41 <Syzygy-> dpiponi: I have the next year or so planned through.
17:28:47 <Syzygy-> Up to and including mid august.
17:28:55 <wli> Syzygy: Sounds interesting.
17:30:06 <dpiponi> saneblidze umble? Never heard of it. But I gues if I can read the Haskell code I'll find out.
17:30:06 <Syzygy-> wli: I'm pretty proud of that paper. It's funky. :)
17:30:24 <Syzygy-> dpiponi: I got invited to Stanford by Gunnar Carlsson - you know him? Heard of him?
17:30:38 <Syzygy-> He does applied algebraic topology.
17:30:56 <sioraiocht> aren't ANY of you computer scientists?
17:30:57 <Syzygy-> Takes homology of complexes generated from point clouds in order to tell more about the structure of it.
17:31:05 <Syzygy-> sioraiocht: No, goodness not!
17:31:08 <sioraiocht> haha
17:31:15 <sioraiocht> I can't be the ONLY ONE
17:31:35 <monochrom> We're rogue computer scientists.
17:32:28 <Syzygy-> I think dons is a CS guy too...
17:33:24 <dpiponi> I don't know the name Carlsson but I know of people using alg. top. on point clouds
17:34:07 <Syzygy-> dpiponi: The short story of SU is as follows. People are interested in the associa- and permutahedra for many reasons, some combinatorial and some algebraic. If you consider P_n - the permutahedron on [1..n], where the faces are indexed by permuted partitions of the integer set [1..n], with refinement defining the face inclusions, then you can build a chain complex out of it.
17:34:57 <dpiponi> I remembered the name in this field I do know of: Edelsbrunner
17:34:59 <Syzygy-> A chain in the chain complex on P_n x P_n that ends up being homotopic (possibly with fixed boundary) to a "true" diagonal of that thingie is of high value, among many other things because it lets you take the algebraic structures you can build with thiese things and extend them out on tensor products.
17:35:19 <Syzygy-> And the Saneblidze-Umble diagonal is one way to - combinatorially - construct sucha diagonal.
17:35:29 <Syzygy-> dpiponi: Never heard of him.
17:37:43 <sioraiocht> so are you all pure math grad students, then?
17:37:52 <dpiponi> edelsbrunner's probably more 'applied'. A web search gets many hits on Carlsson+Edelsbrunner+topology.
17:37:58 <monochrom> we are theology students
17:38:11 <dpiponi> Hey, these look like interesting papers.
17:38:16 <sioraiocht> would that be "study of theory? =p"
17:38:28 <Syzygy-> dpiponi: He may very well be deeply involved in that corner - its not my current specialty, but rather one where I'd love to go work at Some Later Point.
17:38:39 <Syzygy-> sioraiocht: I'm an algebra doctorate student in Germany, yeah.
17:38:39 <monochrom> "The Haskell School of Divinity"
17:38:53 <Syzygy-> And as close to theology as you get without going for priesthood itself. :P
17:38:59 <sioraiocht> hahhahaah
17:39:08 <sioraiocht> Syzygy-: That is neat
17:39:14 * sioraiocht wants to go to Germany.
17:39:31 <dpiponi> Did God use types? It's important because if he did, then s/he probably didn't use Lisp.
17:39:54 <Syzygy-> sioraiocht: One of my friends has a boyfriend who's about to graduate in protestant theology.
17:40:12 <Syzygy-> This boyfriend has already named me a honorary theologian, and pointed out that I know more christian theology than some of his class mates.
17:40:22 <Syzygy-> dpiponi: That's a really good question.
17:40:29 <sioraiocht> Syzygy-: are you protestant yourself? he
17:40:31 <sioraiocht> heh
17:40:40 <Syzygy-> We already know he must have used a flexible functional programming language, given "The Eternal Flame"
17:40:48 <Syzygy-> sioraiocht: I'm aggressively atheistic.
17:41:00 <sioraiocht> Syzygy-: need to know "the other side" then?
17:41:02 <Syzygy-> And I've read four bible translations, and started on the Book of Mormon.
17:41:19 <sjanssen> dpiponi: there's actually a bug in the universe such that you can make it attempt to find the square root of "elephant"
17:41:29 <sjanssen> reality comes crashing down with "Dynamic type error"
17:41:44 <Syzygy-> sioraiocht: I was baptised and confirmed lutheran, then concluded that God was irrelevant. But the texts are still interesting, only not possessing the depth that gets ascribed to them.
17:42:24 <wli> Syzygy-: Well, they're interesting for astrology, mythology, and cultural history.
17:42:27 <dpiponi> sjanssen: So we need to send some Haskell evangelists to the pearly gates to get that lot to convert
17:42:51 * sioraiocht is a pagan...lol.
17:43:03 <sjanssen> dpiponi: I won't be volunteering any time soon
17:43:08 <ricky_clarkson> dpiponi: Using types makes one prone to simplification.  Every deity knows that simple universes don't keep one's attention.
17:43:08 <dibblego> is it possible to restrict the bounds of a data type parameter with a MPTC?
17:43:21 <Syzygy-> sioraiocht: I'm slowly gathering stuff for an altar to Pallas Athena.
17:43:53 <Syzygy-> sioraiocht: The characterisation in Cryptonomicon makes it clear that if I need any god in my life, she's the one.
17:44:14 <sioraiocht> hahahah, a lot of neo-pagan movements have the opinions espoused in that book
17:44:22 <sjanssen> dibblego: 'bounds'?  Like 0 < x < 100?
17:44:25 <sioraiocht> i.e. a very abstract concept of god
17:44:28 <dibblego> the cube root of "elephant" is "el"
17:44:31 <wli> sioraiocht: Which view?
17:44:55 <wli> I wonder where the Judeo-Paganism bits fit into all this.
17:44:56 <dibblego> sjanssen, no, I mean like data (Eq a) => Foo a = Bar a -- where Eq is a MPTC
17:45:01 <sioraiocht> wli: That god(s) are a collection of a values that civilisations value
17:45:08 <sjanssen> dibblego: sure, you can do that
17:45:16 <sioraiocht> and that the images and mythologies we describe are convenient ways to express those ideas
17:45:31 <dibblego> sjanssen, I am struggling for syntax (but I think my actual example is a little contrived)
17:45:45 <dibblego> sjanssen, my Haskell is suffering having used Scala for a long time
17:45:57 <sioraiocht> wli: what do you mean by judeo paganism
17:46:06 <sjanssen> data (IArray a e) => Foo a i e = Bar (a i e) -- this should work
17:46:10 <wli> sioraiocht: I think it's a bit more complicated than that. There's definitely a component of that to it, though.
17:46:14 <dibblego> thanks
17:46:23 <sioraiocht> wli: well, I didn't want to write an essay
17:46:24 <sioraiocht> hehe
17:46:32 <sjanssen> dibblego: remember that constraints on data types are nearly useless
17:46:37 <dibblego> sjanssen, what if e was not polymorphic? but say a [x] -- where x is some other type parameter?
17:46:45 <dibblego> yes I understand that
17:46:59 <ricky_clarkson> Why are constraints on data types nearly useless?
17:47:04 <sjanssen> dibblego: that should be fine too
17:47:04 <wli> sioraiocht: Neo-Canaanite and/or reconstructed pre-Judaic Canaanite polytheism.
17:47:15 <dibblego> data (IArray a [e]) => Foo a i e = Bar (a i e)
17:48:05 <wli> sioraiocht: IOW Hebraic religion prior to monotheism.
17:48:06 <desp> hi.
17:48:14 <dpiponi> Syzygy: So you're not the only one getting invited places. I got invited to Estonia based on my blog...
17:48:22 * sjanssen points out that religion conversations might be better in #haskell-blah
17:48:36 <Syzygy-> dpiponi: Cooooool!
17:48:42 <Syzygy-> dpiponi: Are they paying for you too? ;)
17:48:45 <dibblego> sjanssen, data (IArray a [e]) => Foo a i e = Bar (a i e) seems to work with -fglasgow-exts thanks
17:48:56 <Syzygy-> I get to go to UPenn on Jena money since the people there are important++ to my area.
17:49:09 <Syzygy-> And Gunnar Carlsson is paying with STanford money to get me to come visit.
17:49:14 <wli> Hermite interpolants, hmm.
17:49:18 <dpiponi> By Uustalu, who writes some of my favourite functional programming papers. It would be tricky to fit it in with work 'n' all.
17:49:28 <Syzygy-> Oh Uustalu.
17:49:35 <ricky_clarkson> dpiponi: Ask your Estonian contact to say "12 months" in Estonian, verbally.
17:49:36 <Syzygy-> I think I've tried to read something by him once....
17:51:12 <kilimanjaro> Syzygy-, cool paper :)
17:51:50 <kilimanjaro> Syzygy-, are you a grad student?
17:52:12 <Syzygy-> kilimanjaro: Thanks!
17:52:14 <Syzygy-> Yeah, I am.
17:52:16 <dpiponi> Uustalu's papers are pretty tricky. But once you guess what they're about they start to fall into place. But nailing down every last detail is beyond me as I'm not a category theorist.
17:52:21 <Syzygy-> That paper is going to be about a third of my thesis in the end.
17:52:45 <kilimanjaro> Syzygy-, so your thesis is on algorithmic alg. topology?
17:53:13 <Syzygy-> I have another one with combinatorial observations on the diagonal that matter a lot to both my work and other stuff people are working on; and a third will be on how to calculate these structures without global knowledge of the starting point.
17:53:24 <Syzygy-> kilimanjaro: I'm in "computational homological algebra" in my own opinion :)
17:53:35 <kilimanjaro> I don't know a whole lot on the subject but I ran across a book in the library about rational homotopy with an algorithmic bent
17:53:41 <Syzygy-> Thus nothing as applied as algebraic topology. :P
17:54:11 <kilimanjaro> It's all over my head now, but maybe not in a year
17:54:21 <dpiponi> Syzygy: Do you do stuff with coalgebras? I was just trying to read up on the subject.
17:54:29 <Syzygy-> No, not really, alas.
17:54:34 <Syzygy-> I probably should, though.
17:54:55 <kilimanjaro> i'd like to eventually go to grad school and do research on something similar, at least something at the intersection of algebra and computing
17:55:20 <Syzygy-> It turns out that the cases I'm interested in because they make good examples of small (in composition series length) abelian groups are VERY interesting as coalgebras, since you end up being able to describe the cohomology of the Eilenberg-MacLane space K(Z,n) using this viewpoint.
17:55:46 * desp needs a little help
17:55:57 <Syzygy-> And I need to sleep.
17:56:03 <Syzygy-> dpiponi: I'll poke you when my travel plans are fixed.
17:56:10 <Syzygy-> And again when I'm about to leave for Stanford. :)
17:56:16 <sioraiocht> wli: I wasn't aware that judaism ever had a polytheistic phase
17:56:30 <Syzygy-> sioraiocht: Guess why the Mosaic commandments look the way they do.
17:56:49 <dpiponi> I was just wondering if it was possible to turn some coalgebra that pops up in topology into a comonad that might be useful for Haskell.
17:56:50 <sioraiocht> Syzygy-: I was gonna guess politics, lol
17:56:55 <desp> if I have a  newtype Foo = Foo (MVar Bar)  and I modify the MVar kept inside a Foo value fooVal, does fooVal keep pointin to the old MVar?
17:57:01 <Syzygy-> sioraiocht: And why the old testament / the torah are so crammed full with stories about what happens when the Tribe stops keeping to the right religiosity....
17:57:06 <desp> s/pointin/pointing/
17:57:15 * desp blinks
17:57:19 <sioraiocht> Syzygy-: Conversion tactics?
17:57:20 <Syzygy-> dpiponi: Probably. However, the things I keep looking at are pretty remote for Haskell.
17:57:34 <Syzygy-> sioraiocht: As well as keeping the tribe as such on the Straight and Narrow.
17:57:49 <sioraiocht> instead of returning to their "heathen ways"?
17:57:52 <oerjan> desp: yes the old MVar with the new value
17:57:58 <wli> sioraiocht: You've probably even heard of some of the gods, e.g. Ishtar. (Asherah is even mentioned in the Bible, and also "elohim" is derived from the name for the pantheon and obviously plural).
17:58:16 <Syzygy-> sioraiocht: You have at least 3-4 examples among the well-known bible stories where the chosen people have started to worship another god too - and the priesthood and nominally the god fights back fiercely.
17:58:17 <desp> oerjan: okay, so I've not gone completely insane yet
17:58:33 <Syzygy-> Baal, for instance, is a pretty wellknown babylonian IIRC deity.
17:58:34 <oerjan> desp: that's sort of the point of a mutable reference :)
17:58:35 <dpiponi> (Very offtopic but the thing called Judaism should probably start around the Baylonian exile. Anything earlier is probably better called something like 'Hebrew'. So it was the Hebrews, not the Jews, who received the 10 commandments, and who were probably polytheistic early on.)
17:58:51 <desp> oerjan: yes indeed. but I've run into a weird bug...
17:58:55 <sioraiocht> wli: I always though of those as "babylonian"
17:59:01 <Syzygy-> Yeah, we're sliding WAY offtopic. And there's even on-topic going on here.
17:59:04 <Syzygy-> I go sleep now.
17:59:07 <Syzygy-> *poof*
17:59:26 * dpiponi dematerialises
18:00:17 <oerjan> desp: paste?
18:00:29 <desp> a little too complicated...
18:00:54 <desp> checking something, I'll get back in a moment
18:11:52 <hpaste>  int80_h pasted "YAHT perplexity" at http://hpaste.org/1587
18:12:22 <dons> http://programming.reddit.com/info/24x1q/comments
18:12:23 <lambdabot> Title: Haskell Type Classes, Object Oriented Programming, and Interfaces (reddit.com)
18:12:50 <oerjan> int80_h: add deriving Show to your data declaration
18:15:45 <desp> any ideas what "get: <<loop>>" means?
18:15:49 <desp> infinite loop?
18:16:03 <oerjan> int80_h: every type that wants to be printed needs a Show instance
18:16:20 <oerjan> desp: it means your evaluation is cyclic somehow
18:16:26 <int80_h> oerjan, can you tell me what the syntax for that would look like?
18:16:35 <desp> rgh
18:16:55 <sjanssen> desp: it usually means you wrote "let x = something involving x"
18:17:00 <oerjan> int80_h: data ... = ... deriving (Show)
18:17:18 <oerjan> at the very end of the data declaration
18:17:58 <int80_h> data List a = Nil | Cons a (List a) deriving show
18:18:03 <oerjan> right
18:18:14 <int80_h> *Datatypes> :l DT.hs
18:18:14 <int80_h> [1 of 1] Compiling Datatypes        ( DT.hs, interpreted )
18:18:14 <int80_h> DT.hs:5:39: parse error on input `show'
18:18:14 <int80_h> Failed, modules loaded: none.
18:18:28 <int80_h> oh Show, not show
18:18:29 <oerjan> int80_h: capitalized!
18:18:29 <wli> deriving Show
18:20:55 <int80_h> *Datatypes> listTail (Cons 1 $ Cons 2 $ Cons 3 $ Nil)
18:20:55 <int80_h> Cons 2 (Cons 3 Nil)
18:21:07 <int80_h> but listHead gives me the right answer
18:21:20 <int80_h> *Datatypes> listHead (Cons 1 $ Cons 2 $ Cons 3 Nil)
18:21:20 <int80_h> 1
18:21:27 <oerjan> int80_h: that is the right answer
18:21:38 <int80_h> hmm okay
18:22:12 <int80_h> I would expext listHead to give me Cons 1 as an answer then
18:22:18 <desp> jeez
18:22:28 <oerjan> int80_h: Cons 1 alone is not a well-formed value
18:22:34 * int80_h nods
18:22:36 <oerjan> (well, it is a functin)
18:22:39 <desp> I can't locate the place that causes <<loop>>
18:22:42 <oerjan> *ion
18:22:48 <desp> that error message couldn't be less helpful
18:23:22 <oerjan> desp: you know about Debug.trace?
18:23:36 <Excedrin> desp: is that from ghc?
18:23:45 <desp> yes
18:26:02 <oerjan> desp: somehow you have an expression that cannot be evaluated to its outer constructor, because it depends on itself too strongly
18:26:47 <oerjan> > let x = x+1 in x
18:26:49 <lambdabot>  Exception: <<loop>>
18:27:08 <dolio> It could be less helpful by simply looping infinitely, as it will in ghci. :)
18:27:20 <oerjan> also, it probably is in the get function...
18:27:41 <desp> the get function?
18:28:05 <oerjan> desp: since you said it said get: <<loop>>
18:28:10 <desp> hrm
18:28:32 <desp> actually, that's the program name.
18:28:37 <oerjan> oh.
18:28:54 <oerjan> forget that then :)
18:28:59 <desp> :)
18:29:28 <desp> sigh... it's 3:30 am, my internet connection has broken down and I'm on my cell gprs, and I just wanted to finish the commit and write a status report
18:29:31 <oerjan> desp: wanna paste?
18:29:34 <desp> and then I run into an odd bug :/
18:29:40 <desp> oerjan: it's too much code, really
18:29:57 <sjanssen> desp: you might try the profiling -xc tricks, but that's hit or miss
18:30:12 <sjanssen> desp: walk through darcs changes, it should be pretty obvious once you see it
18:31:43 * oerjan starts wanting those +v modes discussed yesterday :/
18:32:37 <oerjan> obviously this problem was on a higher level than I thought :)
18:37:32 <desp> ugh, darcs revert
18:37:58 <desp> just a few changes, but I can't for the life of me see what I did wrong
18:38:08 <desp> I'll try again...
18:39:05 <oerjan> desp: can you paste a diff? just in case it _is_ something obvious :)
18:39:14 <sjanssen> desp: I can say with 99% certainty you wrote "let x = something with x"
18:39:34 <sjanssen> desp: that is about the only situation where GHC will emit <<loop>>
18:40:07 * desp pasted http://pastie.textmate.org/77505
18:40:13 <oerjan> sjanssen: there _could_ be mutual recursion involved, couldn't it?
18:40:20 <desp> these are the non-trivial let-containing diffs that I just reverted
18:40:28 <desp> but the code might be inpenetrable to you
18:40:32 <desp> :]
18:40:43 <desp> bah. <<loop>> again
18:40:47 <oerjan> almost certainly :D
18:41:01 <desp> one sec, I've isolated it
18:42:51 * desp pasted http://pastie.textmate.org/77506
18:42:54 <desp> check this out
18:44:09 <desp> I don't get it
18:44:17 <sjanssen> desp: your most recent paste is the bad version?
18:44:34 <desp> the most recent paste compares two version of the same function
18:44:59 <desp> the upper function works okay, but fails, because the Map.lookup is called on a stale multiInfo record
18:45:25 <desp> so in the lower function I tried to access the multiVar again inside the callback, getting a fresh multiInfo record
18:45:47 <desp> note that the callback is supposed to be called at a later time
18:46:02 <desp> callback = socketFunWrapper
18:46:25 <desp> I don't see any circularity around there
18:48:09 <dolio> I've not much experience with mvar programming...
18:48:34 <oerjan> hm, is it possible that using withMVar inside a modifyMVar_ for the same variable is intrinsically circular?
18:48:36 <dolio> But could 'modifyMVar mv ... withMVar mv ...' be the problem?
18:48:38 <SamB> desp: you've tried building with profiling and running with +RTS -xc?
18:48:55 <desp> but guys, bear with me -- it's not *using* withMVar there
18:49:10 <desp> it's used in a separate lambda that gets passed to another function
18:49:15 <sgillespie> hello
18:49:20 <sgillespie> having problems building ghc
18:49:27 <desp> SamB: nope
18:49:29 <sgillespie> (from darcs)
18:49:30 <desp> what does -xc do?
18:49:36 <sgillespie> http://rafb.net/p/pnvr7E23.html
18:49:38 <lambdabot> Title: Nopaste - err.txt
18:49:46 <SamB> oh, you'll want -auta-all if you try that
18:49:56 <SamB> anyway, it shows the cost center stack on exceptions
18:50:15 <SamB> (-auto-all makes cost centers automatically for all top-level functions)
18:50:19 <sjanssen> desp: what is easyRefsFld?  A field in a record?
18:50:28 <desp> sjanssen: yep
18:51:22 <sgillespie> i just upgraded (through portage) to ghc-6.6, and this is what i'm getting
18:52:02 <sjanssen> desp: it is possible that freshMultiInfo (specifically the easyRefsFld) is being filled with something circular by another part of the code
18:53:03 * oerjan leaves this to the experts.
18:53:33 <Pupeno2> Are you using network-alt to write networked applications or there's something better these days?
18:53:35 <sjanssen> desp: have you identified specifically which line it happens at?
18:53:52 <sjanssen> desp: perhaps sprinkle some putStrLn here and there
18:55:52 <desp> hmm.
18:56:06 <desp> doing that.
18:56:48 <oerjan> @let pixieDust s = putStrLn s
18:56:49 <lambdabot> Defined.
18:57:19 * desp pasted http://pastie.textmate.org/77507
18:57:23 <desp> SamB: ghc-6.6: unrecognised flags: -xc
18:57:52 <desp> sjanssen: in the latest paste, <<loop>> happens right after "1" is printed
18:58:01 <hpaste>  int80_h pasted "Did I bork base case?" at http://hpaste.org/1588
18:58:08 <desp> so it appears to be the multiVar
18:58:42 <desp> right?
19:00:47 <oerjan> int80_h_: nope, you broke the recursive case
19:00:53 <sjanssen> desp: so it would seem
19:01:03 <int80_h_> thanks oerjan, I will look more closely
19:01:04 <sjanssen> unless there's buffering on stdout
19:01:09 <oerjan> remember, x is not necessarily a function
19:01:10 <SamB> desp: did I forget to mention +RTS?
19:01:22 <sjanssen> desp: hSetBuffering stdout NoBuffering to be sure
19:02:18 <oerjan> int80_h_: actually, you broke both.  your function should have one more argument.
19:02:43 <oerjan> (and not necessarily return a list, either)
19:03:00 <int80_h_> fold only works on lists right?
19:03:09 <desp> SamB: I've now tried "-prof +RTS -xc -RTS -auto-all", but it still fails; please, be considerate and say what you want me to try a little more explicitly :)
19:03:38 <oerjan> int80_h_: the _arguments_ of the usual folds include a list, the result doesn't.
19:03:56 <sjanssen> desp: compile with -prof -auto-all
19:04:02 <sjanssen> desp: run the executable with +RTS -xc
19:04:09 <desp> oh.
19:04:24 <oerjan> int80_h_: your functions should not mention "real" lists at all.
19:05:35 <dmwit> int80_h_: Check the type of foldl for a hint:
19:05:37 <dmwit> :t foldl
19:05:40 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
19:06:38 <dmwit> From your base case, you have a type of ((a -> b -> a) -> List b -> [c]), which is a bit different.
19:07:02 <dmwit> When you get the base case figured out, the inductive case might make a little more sense, too. =)
19:07:37 <int80_h_> I'm trying to articulate the type for foldl in english
19:07:39 <dmwit> (Well, actually, your base case has an even more general type.  But this way of giving it makes the differences more obvious.)
19:08:04 <dmwit> int80_h_: Okay!  How's it coming so far?
19:09:38 <int80_h_> for every a b , um that's it
19:09:53 <dmwit> heh
19:10:13 <dmwit> Maybe it will help if you use different names for a and b?
19:10:16 <int80_h_> (a -> b -> a) is the first arguement, a function
19:10:50 <int80_h_> which takes two arguements, a b, and returns a
19:11:41 <int80_h_> and it takes two more arguments a -> [b] where [b] is a list
19:11:48 <int80_h_> and then returns a
19:12:22 <dmwit> Pretty good.
19:12:44 <dmwit> I'd be careful with the "takes two more arguments a -> [b]" part, but I think you've got the essential idea.
19:12:59 <desp> sjanssen: well, the profiler confirmed that the loop indeed happens in socketFunWrapper
19:13:08 <int80_h_> it uses a all the time which signifies that that argument has to be the same type
19:13:14 <int80_h_> same with b, those must be the same type
19:13:20 <desp> I think I'm too sleepy to figure this out today...
19:14:36 <int80_h_> okay now I need to figure out how that helps me fix my base and recursive cases
19:15:38 <dmwit> int80_h_: One way to approach it is to ask yourself this question:
19:16:04 <dmwit> For the base case, I have (f :: a -> b -> a) and (x :: a) and ([] :: [b]).  How can I produce an a?
19:17:02 <int80_h_> say ([] :: [b]) i english for me
19:17:05 <int80_h_> in
19:17:09 <dmwit> Sure.
19:17:33 <dmwit> [], the empty list, can be a list of any type you like (since there's no elements!).
19:18:24 <SamB> in Haskell, I can say [] instead of [] :: [b]
19:19:37 * oerjan suddenly realizes it's a bit sad that ghc will soon have no Evil Mangler...
19:19:56 <glguy> why is that?
19:20:11 <oerjan> they are dropping the non-ANSI C target
19:20:39 <oerjan> apparently it is now just 3% faster than native code generation, and not worth the cost
19:20:56 <glguy> so the effect will be faster compile times
19:21:26 <oerjan> i guess
19:22:23 <oerjan> also, less weirdness to maintain.
19:25:17 <SamB> there is *one* thing that the non-ANSI C target is useful for...
19:25:35 <SamB> calling C functions that don't actually exist.
19:26:31 <dons> not even 3% on 64 bit
19:26:47 <dons> and with the new student working on the C-- layer, it'll only get better
19:26:49 <jcreigh> SamB: what do you mean? I don't follow...
19:27:13 <SamB> jcreigh: I believe the key word is "lstat"
19:29:03 <glguy> does 6.6.1 use via-C by default?
19:29:15 <SamB> no, -fasm
19:29:17 <glguy> or would I have only used that if I used the flag explicitly?
19:30:29 <dons> anyone read http://www.springer.com/east/home/computer/computer+series?SGWID=5-40099-22-28710389-0&referer=www.springeronline.com&SHORTCUT=www.springer.com/sgw/cda/frontpage/0,10735,5-40099-22-28710389-0,00.html ?
19:30:31 <lambdabot> Title: Interactive Theorem Proving and Program Development - Software Engineering /...J ..., http://tinyurl.com/2vk68n
19:30:54 <glguy> A sandwich walks into a bar,
19:31:02 <glguy> the bartender says, I'm sorry, we don't serve food
19:31:14 <dankna> ouch.
19:31:54 <fy__> ha
19:32:34 <monochrom> that's silly, but hahahaha
19:34:01 <dons> another interesting one, http://www.springer.com/uk/home/generic/search/results?SGWID=3-40109-22-48470375-0&SHORTCUT=www.springer.com/sgw/cda/frontpage/0,,3-40109-22-48470375-0,00.html
19:34:03 <lambdabot> Title: Adapting Proofs-as-Programs - Logics and Meanings of Programs Journals, Books &  ..., http://tinyurl.com/3y6tns
19:34:21 <monochrom> K & R walk into a bar. K said to R, "shouldn't we go to a foo first?"
19:34:24 <mm_freak> i don't have time to read the BSD license  how is the GPL more prohibitive?
19:34:47 <glguy> requires you to provide sources if you distribute a binary to someone
19:34:50 <siti> because the bsd is so small
19:34:59 <dankna> really, if you want to understand the implications you should read them
19:35:12 <SamB> mm_freak: it says "do as has been done unto you"
19:35:14 <dankna> but yeah, BSDed code can be used in commercial, closed-source projects; GPLed can't
19:35:14 <SamB> more or less
19:35:37 <glguy> BSD3 lets you modify the source code and distribute the results of that
19:35:42 <jcreigh> mm_freak: the BSD license is really short and easy to understand.
19:35:45 <glguy> without being obligated to share the source
19:35:47 <mm_freak> dankna: i won't use it, before reading it, don't worry  i'd just like a summary to decide whether it's suitable for me at all
19:35:48 <jcreigh> the GPL rambles for a bit.
19:35:55 <dankna> fair enough
19:35:59 <SamB> mm_freak: what are your desires?
19:36:03 <jcreigh> mm_freak: the BSD3 license is almost public domain
19:36:37 <jcreigh> users of the code can do almost anything they want with it, including selling it, relicensing, making changes without release the source code, etc.
19:36:56 <mm_freak> samb: well, i like the GPL idea of prohibiting closed-source changes
19:37:17 <Excedrin> GPLv2 code can be used in commercial, closed-source projects, as long as you're not distributing binaries
19:37:18 <mm_freak> probably i'd go for LGPL because of commercial closed-source products, but i don't want my own sources to be disclosed
19:37:19 <SamB> mm_freak: what are you making anyway?
19:37:31 <glguy> BSD3 is about freedom for the developers, GPL is about continued freedom for the source code
19:38:00 <siti> that's why for web development using the gpl is fine for closed source projects, because you don't need to distribute the changes ;)
19:38:01 <mm_freak> samb: nothing specifically, but at some point i'll feel the urge to make something public =)
19:38:04 <siti> you just provide a service
19:38:11 <glguy> siti: doesn't the GPLv3 fix that loophole?
19:38:15 <SamB> btw: not many Haskell compilers can be used to make LGPL-compatible software...
19:38:21 <siti> glguy: it was meant to, but I don't think it did
19:38:36 <mm_freak> samb: why?
19:38:38 <siti> well I should say, it was going to
19:38:52 <mm_freak> uhm  replace "to be disclosed" by "to be closed"
19:38:53 <siti> but they removed it, instead they have anti-tivoization :S
19:39:08 <SamB> mm_freak: you can't change a Haskell library and use the new version in a binary aplication...
19:39:16 <glguy> the anto-tivo stuff is rediculous
19:39:30 <SamB> without recompiling the application, I mean
19:39:32 <Excedrin> the GPL stuff is rediculous
19:39:37 <siti> lol
19:40:04 <dankna> it's an ideological thing.  arguing about it is beside the point, you either believe in it or you don't; discussion won't change that.
19:40:22 <SamB> dankna: licenses are not merely ideological
19:40:27 <SamB> unfortunately
19:40:32 <glguy> discussion will help people to see with LGPL doesn't work well with Haskell
19:40:37 <SamB> they are (im)practical
19:40:38 <dankna> well, there's practical concerns also, yeah
19:40:56 <mm_freak> samb: how could that be a problem?  suppose i'm writing a library, and that library should be usable in a closed-source product with or without changes  i don't require the closed source product to become open, i just require that _my_ sources (including changes) remain open
19:41:21 <siti> the problem is that haskell compilers statically link
19:41:29 <siti> and the lgpl only allows dynamic linking iirc
19:41:46 <glguy> mm_freak: you can always do whatever you want with your own code
19:41:51 <SamB> mm_freak: the LGPL requires that applications using LGPL'd libraries not only distribute any changes made to those libraries, but also a version of their executable that can be used with altered libraries
19:41:53 <mm_freak> siti: IIRC it does allow static linking, as long as you distribute the source code
19:42:00 <siti> mm_freak: ok
19:42:11 <dankna> Lisp programs are often distributed with an amended LGPL that says the runtime system is excluded
19:42:14 <dankna> I forget the exact wording
19:42:25 <dankna> but it's certainly possible to do something like that
19:43:10 <SamB> dankna: but it is impossible to relink GHC-produced applications with libraries that have been changed more than trivially
19:43:15 <SamB> or all-but
19:43:18 <mm_freak> samb: "a version of their executable"?
19:43:28 <SamB> mm_freak: i.e. a .o file
19:43:43 <dankna> hm.  true...  that is an interesting wrinkle.
19:44:01 <mm_freak> samb: is it still possible to keep the sources closed, if desired?
19:44:12 <SamB> mm_freak: not really
19:44:44 <dankna> so yeah, I guess you really can't preserve the intent of the LGPL, even if you modify it.  that's too bad.
19:45:27 <mm_freak> hmm  yeah  i always thought that the LGPL makes possible linking to closed source projects
19:45:35 <SamB> personally, I'd think even the GPL wouldn't apply to RTS sources
19:45:37 <mm_freak> i've only read the GPL so far
19:45:42 <SamB> for a lisp implementation
19:45:57 <SamB> because, you know, that should count as an operating system
19:46:21 <dankna> that may be, but it doesn't hurt to make that explicit
19:46:27 <SamB> I suppose not ;-)
19:47:11 <dankna> indeedy
19:47:25 <mm_freak> hmm  so i'm stuck with the BSD license if i want to make possible linking to closed source, aren't i?
19:47:40 <SamB> yup!
19:47:41 <shapr> lgpl?
19:47:48 <SamB> shapr: we've been through that.
19:47:50 <dankna> shapr: see above discussion
19:48:59 <glguy> My feeling, especially with Haskell is that the GHC people were generous enough to give GHC away under the BSD license
19:49:09 <SamB> instead of using the [L]GPL, threaten to make conflicting changes if patches aren't returned to you ;-)
19:49:22 <glguy> and nothing I've written comes close to that
19:49:34 <glguy> but I have the audacity to release stuff under the GPL in return?
19:49:46 <glguy> nope :)
19:50:34 <SamB> I'd only do it if I was seriously worried that someone was going to pull a mean Microsoft on my project...
19:50:41 <dankna> well, I'm a fan of the BSD personally, so I don't have a big vested interest in finding a way to do something GPL-style
19:50:54 <dankna> the conflicting changes is pretty amusing
19:51:42 <mm_freak> rms is a bit crazy anyway
19:51:50 <SamB> it's not so amusing when it happens by accident in darcs :-(
19:52:12 <Excedrin> it's surprising that rms never used lsd
19:52:35 <ricky_clarkson> I took three parsers to work out that lsd wasn't a computer program just then.
19:52:38 <ricky_clarkson> parses
19:52:40 <dankna> yeah, I've been dealing with a lot of that lately, it sucks.  are you one of the darcs maintainers, or do you mean in your own darcs projects?
19:54:17 <SamB> in projects I've worked on. I'm thinking in terms of how slooooow things can go...
19:54:23 * dankna nods
19:54:56 <dankna> and it's aggravating when you don't realize there's a conflict until you start wondering why it's taking so long to finish
19:56:11 <dankna> suppposedly there's a Summer of Code project going on to improve that a little, which will be nice, depending
19:58:37 <sioraiocht> where ARE all the summer of coders?
19:58:40 <sioraiocht> i'd think they'd lurk here
19:58:49 <dankna> no idea.
19:59:01 * wli is unfamiliar with this Summer of Code business.
19:59:06 <SamB> well, perhaps #darcs for darcs summer-of-coders
19:59:07 <chessguy> i'd think they'd be active here
19:59:09 <chessguy> @where soc
19:59:09 <lambdabot> http://hackage.haskell.org/trac/summer-of-code/
19:59:10 <SamB> wli: code.google.com
19:59:12 <chessguy> wli, ^^
20:00:53 <mm_freak> hmm  the artistic license sounds pretty interesting  what's confusing me is the seventh paragraph stating:  "7. C or perl subroutines supplied by you and linked into this Package
20:00:57 <mm_freak> shall not be considered part of this Package."
20:01:15 <mm_freak> what about haskell?
20:01:35 <SamB> artistic license ... isn't that GPL incompatible or something?
20:02:10 <mm_freak> hmm  let me look that up
20:03:39 <mm_freak> you're right, but there's a modified version of the AL called "clarified artistic license"
20:05:15 <SamB> I really like the way you don't need to be a lawyer to understand the BSD licenses, or have the memory of an elephant either...
20:07:49 <monochrom> 640K ought to be enough for understanding a license.
20:08:00 <mm_freak> samb: the BSD license allows modified closed source redistribution, which is exactly what i would like to prohibit
20:10:15 <mm_freak> hmm  but aren't GPL programs allowed to link to non-GPL libraries?
20:10:46 <mm_freak> (libraries not belonging to the OS)
20:11:52 <chessguy> nice one, monochrom
20:12:26 <chessguy> oh, he left
20:13:16 <jfredett> shameless plug:
20:13:16 <jfredett> http://disparatemathematician.blogspot.com/
20:13:16 <jfredett> Read, Criticize, Tell me if I'm wrong, and vote me up on reddit, if you'd like. :)
20:13:17 <lambdabot> Title: The Disparate Notions of a Lowly Mathematician
20:13:42 * jfredett waits for people to tell him how wrong he is.
20:14:17 <SamB> mm_freak: non-GPL, yes. libraries which are not Free Software? no.
20:14:30 <SamB> GPL-incompatible? no.
20:14:51 <dankna> well, I'm not done reading, but (speaking as someone who doesn't understand the more mathematical parts of all this...) I agree that for practical purposes interfaces and type-classes are very similar
20:15:24 <glguy> If you are worried people will use your source code.... don't release it
20:15:30 <jfredett> hey, maybe I wasn't wrong. :)
20:15:42 <jfredett> its really a practical bit of prose, there
20:15:49 <jfredett> the math of it only starts coming in later
20:15:53 * dankna nods
20:15:58 <jfredett> I've got 3ish posts done
20:16:33 <SamB> dankna: you could release your software with a Sulky disclaimer
20:16:55 <SamB> that says that you reserve the right to sulk at anyone who does not return their changes to you ;-)
20:16:59 <dankna> hahaha
20:17:01 <dankna> nice one
20:17:37 <mm_freak> glguy: i _want_ people to use my source code, but i don't want people to modify it and distribute closed versions of the deriveratives
20:17:53 <jcreigh> remember that as long as you own the entire copyright, you can license it to people under different licenses.
20:18:03 <SamB> mm_freak: you too could consider a Sulky disclaimer
20:19:10 <SamB> also be aware that the GPL doesn't work on people who are too lazy to distribute their changes at all
20:19:27 <jcreigh> SamB: WRT to Sulky disclaimer: I realize you're joking, but I feel that sort of "joke license" is harmful to free software. Those sort of "licenses" cast doubt on what can be done with software when the purpose of a license should be to dispel those doubts.
20:20:48 <glguy> GPL allows a company to take your source, change it, provide a service, make money from it, and ignore you
20:20:53 <SamB> jcreigh: I thought those licenses/disclaimers where they say things about, say, blowing up your dog are meant to make it clear that whatever goes wrong isn't your legal responsibility
20:21:54 <newsham> http://www.thenewsh.com/%7Enewsham/x/xkcd.py
20:21:55 <SamB> and of course I'm pretty sure that there isn't any license that takes away your right to sulk in those or any other conditions -- yet
20:22:52 <glguy> many companies (including the last two I worked for) simply avoid GPL'd libraries altogether
20:22:55 <SamB> but honestly I think at this point the way to go is BSD3 and ask nicely for patches
20:23:07 <SamB> for Haskell code
20:23:14 <glguy> which makes GPL a good way to keep companies from touching your code
20:23:35 <mm_freak> glguy: that's ok
20:23:36 <jcreigh> SamB: yeah, I have to agree. Then you don't have to wonder about strange dynamic linking vs. static linking stuff, etc.
20:23:39 <SamB> also, having a public darcs repository makes patches far more likely than if you just post tarballs
20:23:44 <dankna> anyone who modifies your code as a private individual is going to be practically begging you to incorporate their patch, because they don't want to be the ones to maintain it
20:23:46 <mm_freak> the only thing i don't want is modified binary distributions
20:24:13 <SamB> mm_freak: most people are far too lazy to distribute binaries
20:24:24 <mm_freak> samb: yes, that's what i'll do, until i find a better license
20:24:28 <SamB> and, with haskell libraries, it's not very useful anyway...
20:24:54 <SamB> at this point the best policy is to be NICE
20:25:06 * glguy urges the converstaion along to #restrictive-licenses
20:25:12 <SamB> not use fancy licenses ;-)
20:30:27 <SamB> who should I talk to about having jhc@haskell.org carried by gmane?
20:30:43 <SamB> shapr: do you know?
20:34:16 <sjanssen> SamB: gmane has a request form in some prominent place on their site
20:34:43 <SamB> sjanssen: is there someone in particular who is haskell.org's mailman administrator?
20:35:19 <SamB> they tend to do a better job of getting past archives carried
20:35:38 <sjanssen> SamB: oh, you need mailman admin privileges?  Simon M., I think
20:35:59 <SamB> don't *need* 'em to get the list on gmane, but they are nice, yes
20:36:00 <sjanssen> SamB: dons has admin privileges too IIRC
20:36:29 <SamB> @seen dons
20:36:29 <lambdabot> dons is in #xmonad, #haskell and #ghc. I last heard dons speak 52m 53s ago.
20:36:41 <SamB> dons: around?
20:40:38 <SamB> the group would be, what, gmane.comp.lang.haskell.jhc? gmane.comp.lang.haskell.jhc.devel?
20:40:47 <SamB>  
20:40:49 <SamB> er.
20:40:56 <SamB> I guess probably the former...
20:42:07 <iseff> hey there, i'm trying to write a function which gets the current date
20:42:21 <iseff> i've been trying to use getCurrentTime in Data.Time.Clock
20:42:28 <iseff> i need to display this as a String
20:42:46 <oerjan> @hoogle getCurrentTime
20:42:50 <lambdabot> No matches found
20:42:57 <iseff> and the docs at http://haskell.org/ghc/docs/latest/html/libraries/time/Data-Time-Clock.html show that it has an instance of Show UTCTime
20:42:59 <lambdabot> http://tinyurl.com/2w6lgd
20:43:16 <iseff> except, that doesn't seem to work, and the source at http://darcs.haskell.org/packages/time/Data/Time/Clock/UTC.hs seems to agree
20:43:46 <dankna> well, since the docs are autogenerated, an older version of the source must have had that instance
20:44:18 <oerjan> hm... there is an instance but the result is blank?
20:44:44 <iseff> i don't even see the instance anywhere?
20:45:16 <oerjan> oh wait
20:46:09 <oerjan> (i was misreading)
20:46:13 <dankna> I don't see the instance there either.  could it be defined in a different file?  I'm not sure if that's possible.
20:47:18 <iseff> does this seem silly to anyone else?
20:47:27 <iseff> shouldn't this be a fairly easy thing to do?
20:47:53 <iseff> is it possible to hack it and write my own instance for it in my source ?
20:48:10 <dankna> I'm pretty sure all you need to do to write your own instance is write one
20:48:38 <iseff> cool, i'll do that and see how it goes. thanks!
20:51:06 * glguy tries to think of a name for a concurency structure that supports incrementing and decrementing, and does an action on the transition from 0 to 1 and other for 1 to 0
20:51:24 <glguy> when the state changes between empty and not empty
20:52:05 <dmwit> toggle
20:52:07 <iseff> ah, even better: http://darcs.haskell.org/packages/time/Data/Time/LocalTime/LocalTime.hs
20:52:11 <lambdabot> http://tinyurl.com/343yey
20:52:12 <iseff> it's defined there :)
20:52:14 <dmwit> or frobnicator =)
20:52:18 <glguy> dmwit: I like that, its what I had in my source code :)
20:52:25 <dankna> iseff: ah, nice; how'd you find out?
20:52:43 <iseff> a lil more poking around that i should've done earlier :P
20:53:07 <dons> re.
20:53:57 <dankna> heh, k
20:55:36 <oerjan> that's an orphan instance?
20:57:00 <iseff> oerjan: sorry, don't know what an "orphan instance" means..?
20:57:27 <dons> anyone tried solving the xkcd knap sack problem with the Logic monad instead of [] monad?
20:57:39 <oerjan> if there is an instance in a module other than those where the class and type are defined.
20:58:03 <dons> dolio: http://programming.reddit.com/info/24p2c/comments/c24pc5 might be fun to do it more efficiently with a proper back tracking monad?
20:58:04 <lambdabot> Title: xkcd - Does anyone else feel compelled to solve this? (reddit.com)
20:58:20 <matt__r> How do I setup Setup.hs test (Cabal)
20:58:32 <matt__r> I am looking at the UserHooks Haddock
20:58:40 <matt__r> but it is not all that enlightening :)
20:58:40 <iseff> ah, got it, yeah it is
21:00:30 <hpaste>  glguy pasted "reader/writer scheduler" at http://hpaste.org/1590
21:01:09 <oerjan> apparently those are awkward to implement, and i'ld say this case proves they're also bad for documentation.
21:01:57 * int80_h cries
21:02:59 <lispy> ?ping
21:03:00 <lambdabot>   CSE	 : "Abdullah","Lili Marziana","PhD Student","ATP  Australian Technology Park","","lilia"
21:03:00 <lambdabot> CSE	 : "Ahmed","Nadeem","Research Fellow","K17 501E","57229","nahmed"
21:03:00 <lambdabot> CSE	 : "Ahmed","Shabbir","PhD Student","K17 501-19","55301","shabbira"
21:03:00 <lambdabot> CSE	 : "Akand","Elma Hussana","PhD Student","K17 401-02","56913","akande"
21:03:00 <lambdabot> CSE	 : "Al-Kilidar","Hiyam","PhD Student","ATP Australian Technology Park","","hiyama"
21:03:02 <lambdabot> [329 @more lines]
21:03:05 <lispy> what is that command doing?
21:03:29 <glguy> ?help ping
21:03:29 <lispy> dons, sorear?
21:03:30 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
21:03:38 <dons> heh
21:03:40 <dons> ?help ring
21:03:40 <lambdabot>  @ring <user>, CSE phonebook
21:03:50 <lispy> hrm...
21:03:54 <lispy> i think i get it
21:03:56 <dons> in case you need the extensions of grad students at CSE, UNSW, Sydney.
21:03:57 <lispy> ?ring dons
21:03:57 <dons> ?ring dons
21:03:57 <lambdabot>   CSE	 : "Stewart","Donald","PhD Student","K17 501-16","57225","dons"
21:03:57 <lambdabot>   CSE	 : "Stewart","Donald","PhD Student","K17 501-16","57225","dons"
21:03:59 <dons> :)
21:04:15 <dons> ?temp
21:04:16 <lambdabot>   now 13.5, min 8.8, max 14.0, rain 0.0mm, wind 39km/h SSW
21:04:21 <dons> maintainer's privledge ;)
21:04:24 <lispy> phone numbers must be quite a bit different where you live
21:04:33 <dons> that's the extension on the internal pabx thingy
21:04:34 <glguy> hpaste does my laundry...
21:04:37 <glguy> beat *that*
21:04:43 <dons> that's cool, glguy !
21:04:51 <dons> @write-my-paper
21:04:52 <lambdabot> Unknown command, try @list
21:04:54 <dons> doh!
21:05:00 <lispy> ?debug
21:05:00 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
21:05:08 <lispy> interesting...
21:05:32 <lispy> ?vixen but i wanted you to do the debugging
21:05:32 <lambdabot> who doesn't want cute little me!?
21:07:34 <oerjan> @list ping
21:07:34 <lambdabot> No module "ping" loaded
21:07:57 <oerjan> is there a way to find out what some command descrambles to, other than running it?
21:07:57 <glguy> dons: if I wanted to do that "Mutex" and "Toggle" implementation correctly, I'd have to put a "catch" in the "withToggle" and "withLock" functions... wouldn't I?
21:08:07 <glguy> (To get behavior similar to that of withMVar)
21:09:09 <dons> sorry glguy -- what code are you referring to?
21:09:12 <lispy> oerjan: i don't think so, but something like ?nearest ping => ring, would be nice
21:09:22 <glguy> :) the most recent http://hpaste.org/
21:09:56 <glguy> withToggle t up down m = toggleUp t up >> finally m (toggleDown t down)
21:10:09 <oerjan> @pi_ngu
21:10:09 <lambdabot> Unknown command, try @list
21:10:15 <oerjan> @pi_ng
21:10:16 <lambdabot>   CSE	 : "Abdullah","Lili Marziana","PhD Student","ATP  Australian Technology Park","","lilia"
21:10:16 <lambdabot> CSE	 : "Ahmed","Nadeem","Research Fellow","K17 501E","57229","nahmed"
21:10:16 <lambdabot> CSE	 : "Ahmed","Shabbir","PhD Student","K17 501-19","55301","shabbira"
21:10:16 <lambdabot> CSE	 : "Akand","Elma Hussana","PhD Student","K17 401-02","56913","akande"
21:10:16 <lambdabot> CSE	 : "Al-Kilidar","Hiyam","PhD Student","ATP Australian Technology Park","","hiyama"
21:10:18 <dons> seems likely, glguy
21:10:18 <lambdabot> [329 @more lines]
21:10:20 <matt__r> how have written a toploop in haskell, how can I get it to do "up arrow for last command"-like things?  It has something to do with readline right?
21:10:20 <dons> withMVar m io =
21:10:20 <dons>   block $ do
21:10:20 <dons>     a <- takeMVar m
21:10:20 <dons>     b <- Exception.catch (unblock (io a))
21:10:22 <dons>       	    (\e -> do putMVar m a; throw e)
21:10:25 <dons>     putMVar m a
21:10:27 <dons>     return b
21:10:31 <mm_freak> when compiling my program using cabal's setup.hs, i get: Failed to load interface for `Prelude': Could not find module `Prelude':"
21:10:35 <dons> yep, use readline, matt__r
21:10:37 <mm_freak> is this some common error?
21:10:41 <dons> or one of the new fancy command line wrappers
21:10:45 <sjanssen> glguy: note that there is a race condition in withMVar
21:10:49 <dons> matt__r: the 'addHistory' function
21:10:53 <glguy> sjanssen: oh?
21:11:29 <sjanssen> glguy: consider a thread that runs 'withMVar m foo', another thread concurrently 'putMVar m blah'
21:11:41 <sjanssen> the withMVar thread can get stuck on the putMVar
21:11:47 <glguy> ah
21:12:10 <glguy> sjanssen: block doesn't fix that?
21:12:14 * glguy doesn't know what block does
21:12:21 <sjanssen> oh, nevermind.  Didn't see the block
21:13:07 <sjanssen> block is fairly nasty on concurrency IIRC -- blocks all threads executing Haskell code
21:13:11 <glguy> sjanssen: I suppose that there is still a chance for the io action to alter the mvar
21:13:24 <glguy> withMVar m $ \ x -> putMVar m x
21:13:36 <sjanssen> glguy: sure, but we've got to expect the user to not be an idiot :)
21:14:19 <matt__r> dons: cheers, I think I have it sorted now
21:14:51 * lispy can't make any promises about being or not being that idiot
21:16:05 <oerjan> with 32 cores in the future, might block simply be unusable?
21:16:26 <sjanssen> glguy: I have a feeling that STM might make your structure a bit simpler
21:16:26 <matt__r> still cant work out Setup.hs test in cabal though
21:24:01 <glguy> sjanssen: I did one with STM as well
21:24:47 <dons> ?bug
21:24:47 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
21:25:23 <hpaste>  glguy annotated "reader/writer scheduler" with "STM + scheduler thread" at http://hpaste.org/1590#a1
21:25:28 <glguy> sjanssen: ^^
21:27:12 <glguy> is a TChan generally more efficient than a Chan?
21:27:28 <glguy> in particular with a single reader multiple writer situation?
21:30:01 <dons> hmm, i'd imagine more inefficient.. but you'd have to benchmark!
21:30:21 <dons> from memory, the TVar versions of MVar code on the concurrency shootout programs where 2x slower
21:30:35 <dons> there was conjecture from SimonM that it would approach MVars in the limit
21:46:16 <SamB> dons: do you have mailman admin superpowers?
21:47:24 <SamB> dons: sufficient to get jhc@haskell.org on gmane with archives? (are there good enough archives?)
21:50:05 <blackdog_> anyone know where to get the marshal-xml-any dependency?
21:50:57 <SamB_XP_> blackdog_: you checked hackage and the README/INSTALL/any other .txt files in the package in question?
21:51:11 <blackdog_> yep.
21:51:24 <blackdog_> shae just committed a patch to HAppS that seems to need it
21:52:50 <blackdog_> but google and hackage both claim no knowledge
21:56:10 <dons> SamB: nope, SimonM does though
21:57:13 <matt__r> has anyone dealt with the readline loader warnings that you get on OSX?
22:01:09 <dons> dcoutts: this smells like a chance for lazy bytestrings + data.binary to take the field:  http://metalinguist.wordpress.com/2007/07/09/largbe-binary-data-is-a-weakness-of-erlang/
22:01:12 <lambdabot> Title: Large Binary Data is a Weakness of Erlang  Metalinguistic Abstraction, http://tinyurl.com/3yn9d9
22:02:14 <dons> hmm .. and would be very nice in a PADL paper :)
22:08:26 <glguy> is it possible to configure darcs such that it would reject a patch that caused an HUnit test to fail (without too much duck-tape)?
22:08:52 <dons> yeah, simple
22:08:59 <SamB_XP_> glguy: *duck* tape?
22:09:00 <jcreigh> glguy: darcs setpref test 'command arg1 arg2'
22:09:02 <jcreigh> I think
22:09:11 <glguy> SamB_XP_: it's a brand of duct tape
22:09:12 <dons> darcs setpref , yep.
22:09:15 <SamB_XP_> oh
22:09:38 <jcreigh> glguy: the test command will be run on a pristine copy of the repo before a "record" will succeed.
22:09:43 <SamB_XP_> to confuse poor kiddos, no doubt...
22:10:11 <glguy> shame that HUnit isn't installed on community.h.o :)
22:10:15 <glguy> there goes that idea :)
22:10:53 <oerjan> http://www.ducttapeguys.com/duckvsduct.html
22:10:55 <lambdabot> Title: Duct Tape vs. Duck Tape - an explanation
22:11:28 <dankna> hm
22:11:31 <dankna> a likely story
22:11:55 <jcreigh> yeah, they probably get a kickback fro the "Duck Tape" guys. :)
22:11:58 <jcreigh> *from
22:11:58 <SamB_XP_> glguy: you could set up the repo so that it would run tests before letting stuff get recorded and/or sent unless a forcing option is applied...
22:12:12 <dankna> well, they actually are the Duck Tape guys :)
22:12:15 <SamB_XP_> (or is it a repo preference set)
22:12:37 <jcreigh> SamB_XP_: you are probably thinking of the aforementioned "darcs setpref test" stanza
22:13:21 <SamB_XP_> so... why does it matter that HUnit isn't on the server?
22:13:55 <SamB_XP_> it'd be the hackers that would need it... not the server!
22:14:00 <jcreigh> I don't know...it seems like it would work fine, so long as everybody who recorded had it...
22:15:15 <SamB_XP_> darcs' own repo was configured that way when I last tried to do anything with it -- that was a long time ago, however...
22:21:10 <glguy> SamB_XP_: having it on the central repository would be so that breaking changes can't go public :)
22:21:45 <glguy> the darc setpref test seems to work well on my local repo though
22:22:12 <glguy> but the pref is considered a "whatsnew" change
22:24:09 <olsner> @src replicateM
22:24:09 <lambdabot> replicateM n x = sequence (replicate n x)
22:46:34 <dibblego> > let foldll _ y [] = y; foldll f y (x:xs) = foldll f (f y `seq` x) xs in foldll (+) [1..1000000]
22:46:36 <mm_freak> suppose i have a program with a lot of options, which are used nearly everywhere  what is the preferred method to pass these options to all functions?  in C i'd use a global struct, but this is of course not possible in haskell
22:46:36 <lambdabot>   add an instance declaration for (Num [t])
22:47:04 <dibblego> mm_freak, create a data type and pass it
22:47:22 <dibblego> > let foldll _ y [] = y; foldll f y (x:xs) = foldll f (f y `seq` x) xs in foldll (+) 0 [1..1000000]
22:47:25 <lambdabot>  1000000
22:47:27 <mm_freak> dibblego: so i don't get around passing it explicitly?
22:47:37 <dibblego> mm_freak, you don't want that
22:47:59 <mm_freak> true
22:48:02 <dibblego> which is lucky, because Haskell won't allow it :)
22:48:17 <dibblego> not 100% true, but true enough for your circumstance
22:48:54 <dibblego> > let foldll _ y [] = y; foldll f y (x:xs) = foldll f (f y `seq` x) xs in foldll (+) 0 [1..1000000] -- is this equivalent to foldl' in terms of space/time complexity
22:48:58 <mm_freak> well  it starts with a simple `verbose' flag  i'd need to pass it to almost every function besides pure computations
22:48:58 <lambdabot>  1000000
22:49:12 <oerjan> dibblego: `seq` doesn't apply the arguments to each other
22:49:15 <dibblego> mm_freak, you mean command line arguments?
22:49:46 <mm_freak> dibblego: yes  they're fully parsed by getOpt, and so on, now i need to pass these preferences along
22:50:09 <dibblego> oerjan, what do you mean exactly? seq takes f y on the left and x on the right, right?
22:50:19 <allbery_b> mm_freak: you could put evetyhing in StateT IO, so the StateT carries around the arguments automatically --- but best to know what you're doing exactly
22:51:19 <mm_freak> hmm k  let's see what can be done
22:51:22 <dibblego> > let foldll _ y [] = y; foldll f y (x:xs) = foldll f (f y x) xs in foldll (+) 0 [1..1000000]
22:51:26 <lambdabot>  Exception: stack overflow
22:51:27 <allbery_b> that kinda kills much of the advanateg of haskell though
22:51:44 <allbery_b> my own choice was to build a bvig record containing all the static stuff and pass it as the first argument to everything
22:52:04 <allbery_b> since burying everything in a State / StateT forces sequencing on you
22:52:34 <dibblego> > let foldll _ y [] = y; foldll f y (x:xs) = foldll f (f y `seq` x) xs in foldll (+) 0 [1..1000000000000]
22:52:36 <dankna> newbie question: isn't that what ReaderT is for - since it's read-only, it doesn't force sequencing?
22:52:36 <oerjan> mm_freak: ReaderT may be better if you don't change the values
22:52:42 <lambdabot> Terminated
22:54:28 <oerjan> dibblego: f y `seq` x just returns x
22:54:37 <dibblego> ah of course
22:56:06 <quicksilver> allbery_b: 'passing it as the first argument of everythiing' is using Reader/ReaderT
22:56:19 <quicksilver> allbery_b: just without giving it a name or using the special notation\
22:56:48 <allbery_b> sure.  (unfortunately I'm also using gtk2hs and I can;'t find a way to pass ReaderT through it...)
22:56:53 * quicksilver nods
22:57:20 <allbery_b> if I could then I'd aso take some of the global crap and use StateT with it
22:57:49 <sjanssen> @type runReaderT
22:57:51 <lambdabot> forall r (m :: * -> *) a. ReaderT r m a -> r -> m a
22:58:27 <quicksilver> I think there are some things about using custom monads for callbacks which are not very well explored (and possibly not very well understood)
22:58:36 <allbery_b> let me rephrase that: not "can't find a way", moe "don't think there's a sane way to do it"
22:58:56 <allbery_b> when some "callback" may change the state in a way that must be visibe in other independent callbacks
22:59:20 <sjanssen> allbery_b: at that point you probably need mutable references
22:59:23 <allbery_b> I'm pretty sure gtk2hs itself would have to "know about" the state monad
22:59:38 <allbery_b> so I'm just sticking what I must in global IORefs
22:59:49 <sjanssen> allbery_b: they don't have to be global
22:59:58 <quicksilver> I think in principle gtk2hs might accept callbacks of a more general type than IO a
23:00:09 <sjanssen> a ReaderT (set of IORefs) IO -- would work fine too
23:00:17 <quicksilver> but that's what I was referring to with 'not very well explored'
23:00:24 <dibblego> oerjan, if that is the case, then why does removing it result in a stack overflow for the same arguments?
23:00:38 <quicksilver> dibblego: because it doesn't "just" return x :)
23:00:51 <quicksilver> dibblego: it returns x but also has semantic consequences
23:00:51 <allbery_b> sjamssen: it would if I could be certain that passing a calback of type ReaderT (mumble) IO would work where it expects something of type IO
23:01:09 <quicksilver> allbery_b: you'd have to partially apply it before you passed it
23:01:09 <allbery_b> I think the declared types limit me to IO though
23:01:30 <quicksilver> you could set up neat little combinators to do that quite concisely though
23:01:34 <oerjan> dibblego: you did not remove it, you changed it to f y x
23:01:49 <allbery_b> I suppose the correct way (which s I think where quicksilver is going) is to hide the IORefs inside my existing static record
23:01:57 <oerjan> dibblego: you want y `seq` f y x
23:02:04 <allbery_b> someday
23:02:05 <quicksilver> allbery_b: that's where sjanssen is going too
23:02:10 <dibblego> ok
23:02:19 <quicksilver> allbery_b: but he's *also* putting your existing static record into a ReaderT
23:02:49 <allbery_b> more correctly substituting the ReaderT for my static record, I think
23:02:55 <allbery_b> amounts to the samr thing
23:03:03 * quicksilver nods
23:03:04 <oerjan> oh wait
23:03:14 <oerjan> dibblego: that last was nonsense
23:03:24 <dibblego> thought so :)
23:04:14 <oerjan> dibblego: or maybe not btw. ghc might work with it.
23:04:21 <hpaste>  sjanssen pasted "IO callbacks in ReaderT" at http://hpaste.org/1591
23:04:24 <oerjan> dibblego: it depends on ghc's strictness analysis.
23:04:29 <sjanssen> allbery_b: http://hpaste.org/1591
23:04:41 <allbery_b> I've prety much decided I'll worry about it after I get the basic functonality worked out
23:04:51 <quicksilver> I think there is something you can say here along the lines of 'InterleavableWithIO m =>'
23:04:59 <sjanssen> allbery_b: I believe that solves your problem
23:05:00 <quicksilver> but I've never quite worked the details through
23:05:03 <allbery_b> like when updating my liststore doesn't delete the wrong things :)
23:05:06 <quicksilver> (a more general callback type)
23:05:56 * allbery_b nods
23:06:32 <sjanssen> quicksilver: I've wanted such a system before.  Another handy usecase is alloca :: (a -> IO a) -> IO a type functions
23:10:07 <oerjan> > let foldll _ y [] = y; foldll f y (x:xs) = foldll f (y `seq` f y x) xs in foldll (+) 0 [1..1000000]
23:10:16 <lambdabot>  500000500000
23:12:57 <mm_freak> oerjan: i'll pass them explicitly
23:13:30 <hpaste>  sjanssen annotated "IO callbacks in ReaderT" with "not IO specific, add useful toM function" at http://hpaste.org/1591#a1
23:13:32 <oerjan> dibblego: so it worked.  but less smart compilers (such as Hugs, just checked) will not be able to treat it better than the version with f y x.
23:15:28 <mm_freak>   case x of
23:15:28 <mm_freak>     Help -> do { printUsage; return cfg }
23:15:56 <mm_freak> printUsage always throws an ExitException  is there a way to write this more beautifully?
23:16:28 <mm_freak> the function, in which this is contained is of type IO Config, while printUsage is of type IO ()
23:16:56 <quicksilver> mm_freak: you can arrange for printUsage to have type IO a
23:17:09 <quicksilver> mm_freak: if it 'never returns' anyway, it can have polymorphic type
23:17:12 <quicksilver> :t throw
23:17:14 <lambdabot> Not in scope: `throw'
23:17:29 <mm_freak> yeah, that might work  thank you
23:17:51 <dons> yay, type systems are good, http://weblog.raganwald.com/2007/07/can-your-type-checking-system-do-this.html
23:17:53 <lambdabot> Title: raganwald: Can your type checking system do this?, http://tinyurl.com/2o6998
23:17:56 <quicksilver> sjanssen: yeah, I think you need something like a 'freeze' and 'thaw' action
23:18:15 <quicksilver> sjanssen: a primitive to freeze the monadic 'state' of outer monad into the inner monad
23:18:20 <quicksilver> sjanssen: and then a way to recover it
23:18:46 <mm_freak> it's working well  my first haskell program with a real command line interface =)
23:19:13 <hpaste>  sjanssen annotated "IO callbacks in ReaderT" with "ToM class" at http://hpaste.org/1591#a2
23:19:39 <sjanssen> quicksilver: this last attempt only seems useful for ReaderT
23:20:00 <sjanssen> we have to throw away any changes that a StateT might make
23:20:12 <sjanssen> perhaps toM is the wrong abstraction?
23:20:52 <oerjan> sjanssen, quicksilver: there was a thread on haskell-cafe recently discussing how to divide monad actions into read/write and readonly
23:21:03 <oerjan> in case that is relevant
23:21:55 <oerjan> (switching between StateT and ReaderT was one solution proposed)
23:22:33 <quicksilver> sjanssen: that's why you need the 'freeze part' too
23:22:38 <sjanssen> right
23:23:10 <quicksilver> sjanssen: freeze :: Inner b -- somehow store the outer state in this opaque type b in the inner monad
23:23:36 <bos> http://www.realworldhaskell.org/blog/2007/07/10/want-to-help-out-got-html-css-javascript-fu/
23:23:38 <lambdabot> Title: Real World Haskell  Blog Archive  Want to help out? Got HTML / CSS / Javascrip ..., http://tinyurl.com/344xd2
23:23:46 <quicksilver> thaw :: Outer a -> b -> Inner a -- run an 'outer' action inside the 'inner' monad, using a previously frozen state
23:26:11 <dons> so i'm visiting the US consulate web site, entering some rather important information, and I get:
23:26:14 <dons> [HttpException (0x80004005): Unable to validate data.]
23:26:15 <dons> :(
23:26:17 <dons>    System.Web.Configuration.MachineKey.GetDecodedData(Byte[] buf, Byte[] modifier, Int32 start, Int32 length, Int32& dataLength) +195
23:26:20 <dons>    System.Web.UI.LosFormatter.Deserialize(String input) +60
23:26:23 <dons> Version Information: Microsoft .NET Framework Version:1.1.4322.2300
23:27:03 <dons> good to see the homeland is secure!
23:27:07 <Cale> heh
23:27:32 <Cale> Try some SQL injection attacks :)
23:27:47 <dons> i'm too scared
23:28:05 <Cale> yeah, things are getting pretty scary down there
23:28:19 <dons> 2005-2006 TeleTech Government Solutions, LLC
23:28:38 <Cale> My friend from Melbourne had her fingerprints taken when she came into LA to catch a connecting flight.
23:28:57 <dons> yeah, that's standard now
23:28:57 <Cale> How scary is that?
23:29:00 <glguy> the US fingerprints everyone now
23:29:09 <glguy> non-citizens and legal residents that is
23:29:13 <Cale> We're just going to treat everyone as criminals.
23:29:22 <timthelion> glguy: they haven't gotten me.
23:29:30 <scs> hey all
23:29:35 <Cale> I'm amazed that there aren't general riots in the US over this.
23:29:41 <glguy> timthelion: and you've gone through immigration at a US airport?
23:29:49 <timthelion> glguy: nope.
23:29:58 <glguy> well...
23:30:03 <wolverian> Cale, in the war for freedom, freedom must be curtailed. :)
23:30:05 <Cale> You would think that people would be massively protesting such blatant disregard for civil liberties.
23:30:15 <Korollary> Of foreigners?
23:30:24 <glguy> Cale: in this case, the people that are targetted have no say
23:30:29 <glguy> (other than to refuse to visit the US)
23:30:30 <Cale> Korollary: even of foreigners.
23:30:45 <glguy> lol, you don't know the average US citizen very well :)
23:30:48 <timthelion> Cale: they are to busy attacking the civil liberties of gays
23:30:53 <Cale> after all, that reflects on the US's image worldwide
23:31:09 <Cale> You'd think people would care about that ;)
23:31:09 <glguy> we don't want freedom, we want SAFETY!
23:31:13 <glguy> zomg, help us!
23:31:16 <glguy> protect me plz
23:31:53 <Korollary> The US' image is in the toilet as is. They seem ok with it.
23:32:01 <timthelion> hmm, this channel is a bit liberal...  almost as biased as npr
23:32:36 <Cale> timthelion: heh
23:32:38 <scook0> non-strict politics? ;)
23:32:39 <glguy> I disagree with a lot of liberal points of view, but I think that the trend towards surrendering freedoms for the illusion of security is terrible
23:32:59 <glguy> fortunately neither party is actually interested in protecting such freedoms
23:33:10 <glguy> and the the other parties don't havea chance
23:33:14 <wolverian> fortunately?
23:33:16 <thedward> fortunately?
23:33:20 <glguy> oh
23:33:21 <Cale> How is defending civil liberties a 'liberal' viewpoint?
23:33:25 <glguy> s/^/un
23:33:40 <thedward> Civil liberties are for communists are terrorists.
23:33:50 <thedward> err, and terroristsn
23:33:57 * thedward gives up.
23:34:17 <glguy> in my experience the conservative viewpoint on the issue was "if you have done nothing wrong you have nothing to hide"
23:34:26 <opqdonut> yup
23:34:30 <Cale> Yeah, but that's not convervative at all.
23:34:36 <Cale> conservative*
23:34:48 <Cale> That's fascist.
23:35:00 <sjanssen> conservatism isn't really conservatism any more
23:35:02 <wolverian> shouldn't the conservative conserve the existing rights? :)
23:35:04 <Cale> Pretty much the complete opposite of conservatism.
23:35:34 <thedward> facism is the new conservatism.
23:35:36 <Cale> At least with regard to government control/power.
23:35:49 <oerjan> @seen edwardk
23:35:50 <lambdabot> edwardk is in #haskell. I last heard edwardk speak 6h 26m 52s ago.
23:36:04 <glguy> well, politics is run by people who want to increase their chances of keeping their power, so you get people that either try to consolidate power held by the government, or peopel that try to buy votes with subsidies and handouts
23:37:19 <glguy> there's no incentive to do a good job because the results of those choices aren't obvious until too much into the future
23:37:24 <glguy> after elections have been held
23:38:28 <Cale> I also find it funny that it seems the people who always complain about gun control, using arguments that arms could be used against the government in the event of massive corruption seem to be the least likely to be causing problems for this neo-con government.
23:39:05 <Korollary> They mean any government
23:39:26 <Korollary> Nonetheless, you can't go up against tanks with a shotgun.
23:39:58 <Korollary> So, if you can't privately own fighter jets, I don't see the point.
23:40:00 <glguy> yeah, the arming your population to fight a government only worked when the average person could keep up with the technology available to a soldier
23:40:19 <Excedrin> wait gun control isn't just hitting what you shoot at?
23:40:48 <Korollary> Excedrin: Or being able to control when you shoot!
23:41:18 <Excedrin> also, the tank/fighter jet point obviously shows why everyone needs .50 cal sniper rifles
23:41:31 <dons> so what ? people make arguments against gun control in favour of reserving the right to stage a coup?
23:41:42 <Cale> It seems like the US population is far more afraid of its government than its government is afraid of it.
23:41:51 <glguy> not the first time I've heard that stated
23:41:52 <dons> works well in the D.R. of Congo, I guess.
23:41:58 <Korollary> I don't know who's afraid of what any more.
23:42:16 <Excedrin> US population is afraid of all kinds of shit, that's the point
23:42:35 <Korollary> I'm afraid we're going to run out of our celebrated celebrities.
23:42:45 <Excedrin> it's in the constitution somewhere, "under a blanket of fear" I think...
23:42:46 <dons> that's truly scary, I agree, Korollary
23:42:53 <Cale> I think that the general sense of panic in the US population is the root cause of most of its social problems.
23:43:05 * glguy has the "Entertainment" section of google news blocked
23:43:19 <glguy> (in an attempt to shield myself for that garbage)
23:43:26 <Cale> Heh, perhaps that's why the powers-that-be are so afraid of marijuana being legalised there :)
23:44:12 <Korollary> They're afraid of breasts on TV, bioterror, peak oil, and something else I forget.
23:44:22 <Cale> If people stopped being afraid for a bit, they might actually think about stuff long enough to decide that it's pretty stupid to be giving those powers-that-be all that power.
23:44:34 <glguy> There is a vocal minority that keeps the censorship up on TV
23:44:38 <Excedrin> people don't think, what kind of purple sky land do you live in?
23:45:03 <glguy> There was some statistic that 98% of complaints or something outragous like that come from an organization "For the family" or something like that
23:45:20 <Cale> glguy: yeah, for the FCC?
23:45:21 <Korollary> What else can it be?
23:45:27 <glguy> Cale: yeah
23:45:32 <sjanssen> I'm very tired of these "The sky is falling!" claims regarding the climate in the US
23:45:38 <Cale> Yeah, I remember seeing that statistic.
23:45:45 <glguy> I saw tha a while ago, I don't remember details about it now
23:46:25 <Cale> sjanssen: Well, at least that seems to be getting people concerned about energy efficiency, which is a good thing regardless.
23:46:26 <sjanssen> isn't there a bit of irony in being an alarmist about US alarmism?
23:46:43 <sjanssen> Cale: I mean political climate
23:46:49 <Korollary> Who's alarmist about alarmism?
23:46:53 <Cale> sjanssen: ah
23:47:03 <Excedrin> I enjoy alarms
23:47:08 <Korollary> Alarm! Achtung!
23:47:25 * glguy isn't an alarmist, I've pretty much accepted that things will only get worse :)
23:47:40 <Korollary> Non-signalling deep-grained pessimism?
23:47:43 <Cale> sjanssen: Oh, in that regard, I think there is some cause for alarm. Perhaps not so much cause for zany theories, but certainly cause for alarm regarding the corruption of the government
23:48:21 <Cale> People need to stand up and decide that they really can vote for someone else. They also need to stop watching so much TV.
23:48:36 <Korollary> It's Must See TV.
23:48:41 <sjanssen> Cale: a highly unpopular government that is experiencing regime change at approximately the rate of public elections
23:49:02 <Cale> The media seems to pretty much control who even gets a shot at being in power.
23:50:07 <sjanssen> is it really so different anywhere else in the world?
23:50:09 <Cale> They can exclude people from debates pretty much arbitrarily.
23:50:38 <glguy> There are countries, say Japan, where each candidate is guarenteed the same about of TV coverage
23:50:47 <Cale> Well, yeah, if you have media that aren't completely focused on obtaining advertising revenue.
23:51:28 <Cale> News shouldn't be treated as entertainment governed solely by what will get ratings and keep advertisers happy.
23:51:44 <Korollary> It's a business. Required by law to make shareholders rich.
23:52:18 <timthelion> glguy: I'm a Utopian libertarian,  I believe that everything will always get worse untill the need for the government disappears.  you see, I think that we will see a non-profit moral corperation that will not pollute and will not do human rights violations. because it will be driven not by profit but by morals written into its constitution.
23:52:43 <timthelion> maybe I ought to have directed that at Korollary
23:52:46 <glguy> Cale: the news stations cover garbage because that's what people want to see
23:52:55 <glguy> Cale: I don't fully blame them for that
23:53:13 <quicksilver> sjanssen: hmm thinking it through, I remember I thought about some of this before
23:53:33 <quicksilver> sjanssen: ideally it would be better if the library couched it functions in terms of MonadIO
23:53:42 <quicksilver> sjanssen: but the problem with that is the FFI, right?
23:53:52 <Cale> glguy: yes, it's a problem with the culture as well.
23:54:13 <hpaste>  sjanssen annotated "IO callbacks in ReaderT" with "yet another attempt: WithT" at http://hpaste.org/1591#a3
23:54:17 <Cale> glguy: It seems like the main media in the US is completely unwilling to dig for answers from the government in many cases.
23:54:18 <dancor> is there a forM fcn
23:54:21 <dancor> hoogle says no
23:54:25 <sjanssen> quicksilver: yeah, MonadIO would help
23:54:26 <dancor> http://sequence.complete.org/node/258 says yes
23:54:28 <lambdabot> Title: A simple TCP server | The Haskell Sequence
23:54:38 <glguy> dancor: there is: Control.Monad.forM
23:54:42 <glguy> dancor: new to GHC 6.6
23:54:45 <quicksilver> dancor: it's in a newer version of the standard library
23:54:50 <quicksilver> dancor: it's just flip mapM
23:54:56 * glguy was playing with MonadLib today
23:55:01 <quicksilver> dancor: with the list before the action, rather than the other way around
23:55:31 <glguy> I like they way that the base monad provides IO, nondet, strict/lazy behavior
23:55:40 <glguy> and the rest is available as transformers
23:56:00 <Cale> dancor: Don't trust hoogle too implicitly on the existence/nonexistence of functions. It seems to produce strange results sometimes, and appears to be missing quite a few things.
23:56:05 <glguy> then there is a liftIO generalized to lift a value to the base monad
23:56:07 <glguy> not just IO
23:56:17 <Cale> dancor: The GHC Hierarchical Libraries documentation is better for that.
