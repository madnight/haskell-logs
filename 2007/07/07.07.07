00:00:32 <dfranke_> the wikibook doesn't cover enough of the topics that really make you a *good* Haskell programmer, like using the MTL.
00:00:36 <jre2> dons: some libraries need better examples in their documentation or better organization. for example I just started looking at the xml libs last night and while there was a great deal of documentation overall, none was covering what I wanted
00:00:59 <dfranke_> (it does cover that now, but it's just an example)
00:01:30 <sorear> haskell is so popular that base has stagnated to death under the iron mask of @wiki Library submissions.
00:01:39 <sorear> maybe that is why hackage is so full now?
00:01:50 <dons> yes, so the mtl docs have been elaborated quite a bit
00:02:01 <dons> and new libs are getting better docs from the start now
00:02:14 <dons> some large older things, like haxml, need to be updated
00:02:32 <sorear> night all.
00:02:38 <jre2> yea, I eventually gave up and opted for hxt
00:03:02 <dons> there's often blogs illustrating how to use various libs
00:03:06 <dolio> Well, I think I have everything but a hackage account, now...
00:03:09 <dons> i wonder if we could link to the blog pages from hackage
00:03:16 <dons> e.g. there's an HXT rss feed example blog
00:03:16 <sorear> dolio: just email ross
00:03:23 <dons> that would be excellent to link to from hackage page for HXT
00:03:31 <dons> dolio: ok, i can give you one
00:04:00 <dons> shalldo that now , dolio ?
00:04:13 <glguy> Andy Gill is trying to release a simplified XML parser printer library
00:04:25 <dolio> Okay. How do we go about doing that?
00:04:32 <dfranke_> oh, another library I'd like to see: Java-style serialization. i.e. serializing manifest type information.
00:04:35 <dons> ok. i'll do it now, dolio
00:04:42 <dfranke_> I just wrote a toy implementation based on Data.Binary.
00:04:43 <dons> just a tic.
00:04:48 <dfranke_> http://dfranke.us/Saveable.hs
00:04:55 <dons> dfranke_: is that a binary wrapped with Typeables?
00:04:57 <glguy> since HaXML and HXT are both pretty heavy packages
00:05:06 <dons> yes, we need a fast light xml package
00:05:08 <dfranke_> dons: yes
00:05:14 <dons> dfranke_: yes, bos wrote one too.
00:05:22 <dfranke_> dons: link?
00:05:26 <dons> bos: ? ^^
00:05:45 <jre2> glguy: that would be nice, especially for the limted purposes I use xml for
00:05:47 <bos> mine's terribly bitrotted.
00:07:16 <Svrog> to add new libraries, is it required to add haddock docs right away or can that be done later?
00:07:26 <dons> dolio: you there?
00:07:27 <dfranke_> and also, though this might be trickier, proper serialization of circular structures.
00:07:31 <Svrog> ive had some problems with haddock so i wrote the docs in latex
00:07:37 <dons> Svrog: its best to do haddock as you go.
00:07:44 <dons> i suppose as long as there's some docs, you could link to them
00:07:50 <Svrog> hmm.. haddock doesnt like some ghc extensions though
00:07:59 <dons> #def around that, Svrog
00:08:38 <Svrog> if i did that the docs would be incomplete - haddock doesnt like infix types
00:08:47 <Svrog> i guess i can change the type name
00:08:53 <Svrog> not sure if its gonna complain about something else though
00:08:57 <Svrog> ill give it a go
00:09:04 <dolio> dons: Yes.
00:09:10 <dons> privmsg?
00:11:03 <Svrog> btw is there a reason why some haskell libraries have their own versions of the state monad instead of using the one in Control.Monad.State?
00:13:35 <setuid_w00t> are mod and rem equivalent functions?
00:13:48 <Saizan> Svrog: an example?
00:13:58 <Svrog> Get in Data.Binary for example
00:14:07 <Svrog> i think ive seen some others in some other libraries
00:14:09 <glguy> setuid_w00t: no, different behavior on negative numbers
00:14:19 <Svrog> cant remember any other examples off the top of my head though
00:14:30 <glguy> > (\x -> (x `mod` 3, x `rem` 3) ) (-1)
00:14:33 <lambdabot>  (2,-1)
00:14:45 <Saizan> well Data.Binary.Get it's not just a state monad iirc
00:14:59 <Saizan> i think the point there was efficiency
00:15:00 <setuid_w00t> glguy: ahh, I see
00:15:13 <Svrog> ah
00:16:27 <Saizan> when you have many monad transformers it can be worth to fuse them in your custom monad
00:17:28 <dfranke_> alrighty... mv /proc/self ~/bed.
00:17:41 <glguy> ?check (\ a b -> b /=0 ==> mod a b == rem a b) :: Int -> Int -> Property
00:17:43 <lambdabot>  Falsifiable, after 10 tests: -5, 7
00:19:24 <Svrog> they don't seem to have many - Get looks like a really straightforward State monad to me
00:19:31 <Svrog> newtype Get a = Get { unGet :: S -> (a, S) }
00:20:46 <setuid_w00t> If I do 2**3, I get a floating point number.  How do I make haskell produce 8 instead of 8.0?
00:21:51 <Svrog> setuid_w00t:  2 ^ 3
00:21:53 <Saizan> Svrog: S?
00:22:08 <Svrog> S is the state used by Get
00:22:31 <Saizan> that i see :)
00:22:54 <dons> Vq^: Data.Binary doesn't use StateT since it needs some aggressive inlining
00:23:00 <dons> Svrog: i mean
00:23:01 <Svrog> basically data S = S !ByteString !LazyByteString !Int64
00:23:16 <Svrog> ah
00:23:19 <dons> and ghc won't inline the mtl well enough across the package boundaries
00:23:34 <dons> unless we go back to mtl, and add {-# INLINE #-} to things, along with -O2
00:23:45 <dons> afaik, its the only lib that rolls its own state monad
00:23:57 <dons> there might be others I suppose, but its not terribly common
00:24:17 <Svrog> fair enough
00:24:58 <wli> In userspace I like to just have decent asymptotics and leave all the manual inlining etc. to the compiler.
00:27:13 <dons> we could be more aggressive in mtl, i suspect
00:27:35 <dons> sit down and ensure ghc unfolds it deep enough into the .hi files, to get the same code from Data.Binary as with an internal definition
00:35:40 <Svrog> also regarding Data.Binary, trying to run anything that uses it through ghci results in ghci complaining it can't find stg_uncheckedShiftRL64
00:37:04 <dons> yes, that's a 6.6.1 regression
00:37:34 <Svrog> a regression?
00:37:41 <dons> gimme a sec ...
00:37:46 <Svrog> ok
00:38:07 <dons> http://hackage.haskell.org/trac/ghc/ticket/1282
00:38:09 <lambdabot> Title: #1282 (binary package wants uncheckedShift functions to be exported from base) - ...
00:38:18 <Svrog> ah
00:38:20 <Svrog> thanks
00:54:00 <dons> @tell FunctorM should probably be under the Control category
00:54:00 <lambdabot> Consider it noted.
00:54:03 <dons> @tell sorear FunctorM should probably be under the Control category
00:54:03 <lambdabot> Consider it noted.
00:58:39 <Vq^> yay, dons is talking to me
00:59:00 <Vq^> ...
00:59:01 <Vq^> aw :(
00:59:12 <dons> hey Vq^ !!!
00:59:20 <glguy> !paste
00:59:20 <dons> party time! code for everyone!
00:59:20 <hpaste> Haskell paste bin: http://hpaste.org/
01:00:20 <Vq^> hello mr Stewart :)
01:00:43 * glguy would prefer to call dons "dons" in person...
01:00:53 <glguy> but I have a feeling that would become weird :)
01:00:59 <jre2> dons: no code for everyone when the site is down
01:03:08 <Saizan> i miss only one thing from my python experience: short compilation times
01:04:46 * glguy reminds the guy that took this video to not use resolutions of 1600x1200 when doing a screen capture
01:05:00 <glguy> if you want the rest of the world to be able to watch them
01:05:09 <dons> glguy: hah
01:05:29 <dons> Saizan: but python doesn't compile anything ;)
01:05:50 <jre2> glguy: but then he'll just do it at 320x240 like all those worthless youtube videos
01:05:54 <Vq^> dons: you're sure?
01:06:16 <dons> bytecode doesn't count.
01:06:32 <glguy> jre2: I guess you're right... there is no happy medium
01:07:22 <glguy> my laptop is 1440x900
01:07:24 <jre2> Saizan: I think 800x600 would be nice in that it plays well on most machines and text is readable, it's just slightly large for uploading easily
01:07:24 <Vq^> dons: ok
01:07:28 <glguy> that 900 can be kind of cramped
01:07:43 <Vq^> dons: what about... eh... java?
01:07:56 <dons> bytecode doesn't count!
01:08:11 <dons> ocaml is a better comparision though.
01:08:21 <Vq^> why?
01:08:29 <dons> its compiling a similar language to native code, as ghc.
01:08:53 <dons> probably a bit simpler in ocaml's case. and without ghc's rules engine, where a fair bit of time is spent
01:09:03 <dons> but roughly comparable, and it makes ghc look damn slow
01:09:13 <jre2> is anyone else have trouble with hpaste.org?
01:09:26 <dons> seems to be up
01:09:36 <glguy> jre2: yeah, everyone else that tries to use it is
01:09:37 <dons> but with duplicates
01:09:44 <glguy> there is something going on with HAppS
01:09:59 <dons> i liked the spammers better
01:10:06 <jre2> I got the frontpage after a handful of tries, still haven't gotten the 'new' page to load after numerous tries
01:10:14 <dons> yeah seems busted
01:10:32 <jre2> but then again, I'm leeching wireless for my internet connection, so I can never be sure
01:11:51 * glguy ponders a new hpaste not using happs but something simpler since it doesn't need all the happs magic
01:12:00 <ttmrichter> I can't seem to find this, even though I'm sure it's there.  I have a string like "35.0"  I'd like it to be a number I can calculate.  I've Hoogled on the type signature String -> Double (and various other versions of it) and can't find the function that does this.  It doesn't appear to be the usual suspect like "atof" either.  What am I missing?
01:12:13 <glguy> read
01:12:27 <glguy> > read "35.0" :: Float
01:12:28 <lambdabot>  35.0
01:12:30 <Saizan> well, we just need shapr to rebuild happs on the server, after a minor fix
01:13:00 <glguy> not using happs would help things like "the bot can't talk to the state"
01:13:00 <setuid_w00t> Is there a way to truncate the decimal part of a floating point number?  eg.  f 20.123 -> 20.0
01:13:05 * ttmrichter sighs.  "Of course.  Thanks, glguy."
01:13:29 <setuid_w00t> wait, did that just get asked  :)
01:13:40 <wli> I think there's a showFloat variant that takes the number of decimal digits and/or significant figures as an argument.
01:13:50 <Saizan> glguy: we'll get Data.Binary can't parse the state :)
01:13:55 <ttmrichter> Hmmm..
01:14:05 <ttmrichter> How do I map a read of a specific type to a list of strings, then?
01:14:22 <setuid_w00t> nope, my question is different
01:14:24 <ttmrichter> > map (read ::Float) [35.0, 36.0]
01:14:26 <lambdabot>  Couldn't match expected type `Float'
01:14:42 <glguy> map read [....] :: [Float]
01:14:43 <glguy> or
01:14:49 <glguy> (read :: String -> Float)
01:15:02 <glguy> generally in the scope of a larger program
01:15:06 <glguy> this caan be inferred
01:16:51 <dons> glguy: using hxweb perhaps, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hxweb-0.1
01:16:53 <lambdabot> http://tinyurl.com/33x9ha
01:17:17 <jre2> if someone has a second, how would I modify www.acm.uiuc.edu/~jre2/main.hs to work? (c. line 37 I have a case block with different types, not sure what the elegant way to rewrite that is)
01:17:49 <apfelmus> i wish that hackage had haddocks enabled everywhere
01:17:59 <dons> they get generated lazily, i think :)
01:18:02 <dons> once a week or so
01:18:23 <dons> jre2: they both look like IO ()
01:18:27 <dons> what's the type error?
01:18:36 <jre2> forkIO gives IO ThreadId
01:18:46 <glguy> jre2: case _ of True ... is : if
01:18:48 <dons> if valid forkIO (clientd name h cxo cxr) >> return () else hPutStrLn h "rawr, you can't come in"
01:19:10 <apfelmus> that's not lazy, that's an eager hiccup :)
01:19:19 <mm_freak> which of gtk2hs and wxhaskell would you prefer, and why?
01:19:28 <dons> gtk2hs, since its maintained
01:19:44 <dons> wxhaskell, since it was good on windows, before gtk2hs took over
01:19:53 <apfelmus> both are bad on OS X
01:20:20 <mm_freak> portability is not an issue…  it's ok, if it runs well on unix-likes
01:20:36 <dons> gtk2hs then
01:20:41 <mm_freak> thanks
01:21:31 <mm_freak> do i need gnome for glade?
01:21:41 <dons> don't think so.
01:22:18 <jre2> ah, so return () is what I wanted
01:22:27 <mm_freak> let's see…  thanks
01:24:49 <dons> ?users
01:24:49 <lambdabot> Maximum users seen in #haskell: 354, currently: 298 (84.2%), active: 11 (3.7%)
01:24:50 <qwr> setuid_w00t: truncate
01:25:39 <jre2> how does lambdabot define 'active'?
01:25:48 <qwr> > truncate 33.3
01:25:50 <lambdabot>  33
01:27:07 <roconnor> > truncate 3.99999999999999999999999999999999999
01:27:09 <lambdabot>  4
01:27:30 <glguy> x.9 repeating *is* x+1
01:27:41 <roconnor> > truncate 3.999999999999999999
01:27:43 <lambdabot>  4
01:27:50 <roconnor> > truncate 3.9999999999999999991
01:27:52 <lambdabot>  4
01:28:01 <dons> last 2 hours, iirc
01:28:04 <glguy> :t truncate 3.99999999999999
01:28:06 <lambdabot> forall b. (Integral b) => b
01:28:21 <glguy> :t 3.99999999999999999
01:28:24 <lambdabot> forall t. (Fractional t) => t
01:28:30 <mm_freak> > 3.99999999999999999999999
01:28:32 <lambdabot>  4.0
01:28:33 <glguy> :-/ what does that default to?
01:28:57 <mm_freak> it's just that 3.999999999999999999 cannot be represented as a finite floating point number
01:29:10 <mm_freak> it can, but Float is too short
01:29:27 <mm_freak> > 3.9999999999999999999999::Rational
01:29:30 <lambdabot>  39999999999999999999999%10000000000000000000000
01:29:36 <glguy> right, i just wondered if that was float or double for example
01:29:47 <mm_freak> both would be too short
01:30:02 <mm_freak> Double has around 12 decimal digits of precision
01:30:24 <mm_freak> (but actually it should truncate the value, which would be less than the original)
01:30:53 <dons> > 1.1 + 2.2 -- hardware is stoopid
01:30:56 <lambdabot>  3.3000000000000003
01:31:16 <mm_freak> dons: it's not…  that's totally reasonable
01:31:23 <glguy> ugh, you can't blame the hardware for your misuse of the types!
01:31:24 <glguy> :)
01:31:43 <dons> > 11%10 + 22%10 -- is reasonable. 3.3000000000000003 isn't :)
01:31:45 <lambdabot>  33%10
01:31:46 <mm_freak> it's not a misuse of types…  neither 1.1 nor 2.2 have exact float representations =)
01:32:07 <mm_freak> dons: 11%10::Rational is more exact than 1.1::Float
01:32:16 <glguy> mm_freak: not, it is a misuse to treat Floating point representations as anything more than an approximation
01:32:20 <glguy> s/not/no
01:32:22 <dons> I understand the issue, don't worry :-)
01:32:37 * glguy doubts that
01:32:40 <glguy> and continues
01:32:52 <dons> its does illustrate that numeric literals are only fuzzy approximations for what's happening on the machine :)
01:32:59 <mm_freak> glguy: they are not approximations…  it's just that in our decimal system we have the 5 as a prime factor
01:33:21 <mm_freak> that's why we can represent 1.1 exactly in decimal: 1.1 = 11/10 = 11/(2*5)
01:33:27 <wli> primorial radices?
01:33:33 <glguy> that's why it has to be an approximation :)
01:33:55 <mm_freak> no, 1.25 is exact as a Float
01:34:01 <mm_freak> just as well as 0.625
01:34:12 <mm_freak> but not 2.3 or 5.7
01:34:12 <glguy> incidentally
01:34:23 <glguy> its not that it is guarenteed to be wrong
01:34:40 <glguy> just to be close , where close can be +- 0
01:34:44 <apfelmus> http://www.cs.toronto.edu/~hehner/ratno.pdf
01:34:48 <mm_freak> see it the other way round:  it's not guarateed to be right…  that's also true for our decimal system =)
01:34:53 <glguy> I am aware of how they are implemented :)
01:35:14 <apfelmus> "A new representation of the rational numbers for fast easy arithmetic"
01:35:35 <dons> maybe haskell should default numeric floating point literals to Rationals. hmm.
01:35:53 <dons> as with Integer. and let those who'll have imprecision ask for it
01:35:55 <mm_freak> as long as the ratio's denominator has only 2 as prime factors, the number can be represented exactly as Float (unless it exceeds precision)
01:36:08 <Svrog> dons: i think that's a good idea
01:36:17 <jre2> dons: my roommate has been arguing for that actually
01:36:43 <mm_freak> dons: most people don't need a lot of precision, so it would be pointless to enforce that
01:36:53 <dons> default(Rational)
01:36:53 <dons> main = print 1.0
01:36:54 <mm_freak> or default to that
01:36:55 <Svrog> mm_freak: same can be said for integers
01:36:58 <dons> works rather well for that, in fact.
01:37:07 <dons> mm_freak: well, most people don't need Integer either :)
01:37:10 <wli> Radix 30, 210, 2310, etc.
01:37:17 <mm_freak> svrog: ACK
01:37:30 <Svrog> ?
01:37:32 <glguy> dons: especially w/ x86_64
01:37:34 <wli> default(Rational,Integer)?
01:37:35 <glguy> :-D
01:37:41 <dons> yes, good thing that ` default(Rational)' works, i wasn't sure that'd work
01:37:49 * wli ponders radix 1+i
01:37:52 <mm_freak> yeah, it would just be against haskell's spirit to truncate integers ;)
01:38:08 <mm_freak> that problem doesn't exist for floating point numbers…  they can only run out of range
01:38:31 <wli> mm_freak: There are such things as arbitrary-precision floating point numbers, too.
01:38:33 <dons> default(Rational,Integer)
01:38:33 <dons> main = do print 1.0
01:38:33 <dons>           print (7 :: Integral a => a)
01:38:35 <glguy> linear logic is related to uniqueness types?
01:38:36 <dons> works reasonably well
01:38:46 <dons> glguy: yeah
01:39:12 <dons> actually, rounding errors in Doubles came up fairly often in the shootout code I wrote for haskell.
01:39:13 <glguy> polar opposite of immutable shared datastructures :)
01:39:17 <Svrog> hey! neat! i didnt know about default :)
01:39:20 <jre2> bah, what you really need is to default to Naturals
01:39:23 <wli> Radix 223092870 ;)
01:39:31 <wli> jre2: A Natural type would be nice.
01:39:37 <mm_freak> hehe
01:39:38 <jre2> negative is for losers
01:39:44 <wli>     Not in scope: type constructor or class `Natural'
01:39:47 <dons> hmm. why haven't we got a simple Nat type on hackage?
01:39:58 <mm_freak> still i see no point in defaulting to Rationals…  if you need it, use it, but most people don't
01:40:13 <jre2> oh, I thought there was one
01:40:17 <dons> QC 2 has newtype NonNegative a = NonNegative a
01:40:23 <dons> and a few other useful things
01:40:35 <dons> mm_freak: but it fits exactly with defaulting to Integer.
01:40:45 <mm_freak> dons: it doesn't…  see above
01:40:53 <dons> or are you saying that floating point rounding errors are far less common?
01:41:01 <mm_freak> Int is _not_ an integer type, it's a modular type
01:41:13 <dons> yes, but it is used as if it was. hence Integer defaulting
01:41:20 <mm_freak> it does truncation, where you most likely don't want it
01:41:21 <wli> I think there are wide software floating point types floating around in the libraries.
01:41:43 <mm_freak> and if you want truncation specifically, you wouldn't use Int either, you'd use Int32 or Int64, whatever fits better
01:41:48 <dons> there are certainly large bounded types (in the crypto lib). likely other things in the numericprelude
01:42:07 <dons> > maxBound :: Word1024 -- did I install it?
01:42:14 <lambdabot>  ghc: failed with error code 9
01:42:16 <dons> nope.
01:42:24 <ski> glguy : ask edwardk about uniqueness and linearity
01:42:35 <jre2> personally, I like being able to do fooInt == barFloat and have it not fail due to rounding errors
01:43:09 <mm_freak> jre2: comparing to floats is baaaaad
01:43:12 <dons> mm_freak: I think defaulting to the most general, precise types for new programmers fits `the haskell way'
01:43:17 <apfelmus> golden rule of floating point arithmetic: never ever use < and == on them
01:43:28 <mm_freak> dons: and those are Integer and Float ;)
01:43:43 <mm_freak> apfelmus: why not < ?
01:43:51 <wli> apfelmus: fpclassify prior to any inequality comparison, never use ==
01:43:57 <apfelmus> > 1.1+2.2 < 3.3
01:43:59 <lambdabot>  False
01:44:00 <dons> maybe we should start promoting default(Rational,Integer) for all the math bloggers
01:44:09 <apfelmus> > > 1.1+2.2 <= 3.3
01:44:09 <lambdabot>  Parse error
01:44:13 <apfelmus> > 1.1+2.2 <= 3.3
01:44:15 <lambdabot>  False
01:44:20 <mm_freak> apfelmus: 3.3 != 33/10 ;)
01:44:30 <wli> dons: I need to set up a blog and am having trouble setting it up. :(
01:44:34 <glguy> != ?
01:44:39 <mm_freak> uhm
01:44:40 <jre2> apfelmus: nice
01:44:40 <mm_freak> /=
01:44:46 <glguy> you lost? ;)
01:44:51 <mm_freak> coming from C =)
01:45:31 <mm_freak> apfelmus: sqrt x | x < 0 = undefined
01:45:42 <mm_freak> so that's bad?
01:45:44 <dons> wli: hmm, using what software?
01:45:48 <apfelmus> mm_freak: yes
01:45:52 <dons> ?help vote
01:45:52 <lambdabot> vote <poll> <choice>        Vote for <choice> in <poll>
01:45:56 <mm_freak> how would you do it?
01:46:13 <ski> > abs (3.3 - (1.1+2.2)) <= 0.0000001
01:46:15 <lambdabot>  True
01:46:19 <dons> ?help poll-add
01:46:19 <lambdabot> poll-add <name>             Adds a new poll, with no candidates
01:46:28 <Saizan> Rational is not an instance of Floating, though, so you don't have pi, log, sin, etc..
01:46:40 <dons> ?poll-add default_to_Rational
01:46:41 <lambdabot> Added new poll: "default_to_Rational"
01:46:41 <jre2> ski: yea, that's the wonderfully elegant way inferior languages force you to deal with
01:46:47 <dons> ?help choice-add
01:46:47 <lambdabot> choice-add <poll> <choice>  Adds a new choice to the given poll
01:46:57 <apfelmus> mm_freak: hm, it's not so bad for sqrt :)
01:46:58 <dons> ?choice-add default_to_Rational Yes!
01:46:59 <lambdabot> New candidate "Yes!", added to poll "default_to_Rational".
01:47:01 <dons> ?choice-add default_to_Rational No!
01:47:01 <lambdabot> New candidate "No!", added to poll "default_to_Rational".
01:47:02 <eivuokko> Is there a way to stop ghc from scheduling current thread - maybe similar to Control.Monad.block?
01:47:02 <mm_freak> apfelmus: ;)
01:47:06 <dons> ?choice-add default_to_Rational What?
01:47:06 <lambdabot> New candidate "What?", added to poll "default_to_Rational".
01:47:10 <dons> ?help vote
01:47:10 <lambdabot> vote <poll> <choice>        Vote for <choice> in <poll>
01:47:11 <mm_freak> and i can give you another example:
01:47:17 <dons> ?vote default_to_Rational Yes!
01:47:17 <lambdabot> voted on "Yes!"
01:47:27 <glguy> ?vote default_to_Rational No!
01:47:27 <lambdabot> voted on "No!"
01:47:31 <ski> instance Floating Rational where pi = 22 % 7
01:47:31 <dons> ?poll-show default_to_Rational
01:47:32 <lambdabot> ["What?","No!","Yes!"]
01:47:35 <jre2> ?vote default_to_Rational Yes!
01:47:35 <lambdabot> voted on "Yes!"
01:47:38 <dons> ?poll-result default_to_Rationaldefault_to_Rational
01:47:39 <lambdabot> No such poll: "default_to_Rationaldefault_to_Rational"
01:47:41 <mm_freak> reduceAngle x | x > (2*pi) = reduceAngle (x-(2*pi))
01:47:41 <dons> ?poll-result default_to_Rational
01:47:42 <lambdabot> Poll results for default_to_Rational (Open): What?=0, No!=1, Yes!=2
01:47:51 <mm_freak> (though that would imply some loss of precision
01:47:53 <apfelmus> ?vote default_to_Rational Yes!
01:47:53 <lambdabot> voted on "Yes!"
01:47:59 <apfelmus> ?vote default_to_Rational Yes!
01:48:00 <lambdabot> voted on "Yes!"
01:48:08 <Svrog> ?vote default_to_Rational Yes!
01:48:08 <lambdabot> voted on "Yes!"
01:48:11 <apfelmus> ?poll-result default_to_Rational
01:48:11 <lambdabot> Poll results for default_to_Rational (Open): What?=0, No!=1, Yes!=5
01:48:13 <ski> @type Control.Monad.block
01:48:15 <lambdabot> Not in scope: `Control.Monad.block'
01:48:19 <dons> actually, I wonder if this should have an H' ticket
01:48:23 <narain> ?vote default_to_Rational No!
01:48:23 <lambdabot> voted on "No!"
01:48:26 <apfelmus> dons: lambdabot doesn't detect cheating :)
01:48:34 <dons> nope :)
01:48:44 <glguy> apfelmus: too easy to get around a check
01:48:44 <ski> ?vote default_to_Rational What?
01:48:44 <dons> it should be hooked into the karma system :)
01:48:44 <lambdabot> voted on "What?"
01:48:54 <glguy> ?karma
01:48:54 <lambdabot> You have a karma of 51
01:48:58 <jre2> ?karma
01:48:58 <lambdabot> You have a karma of 0
01:49:21 * glguy hasn't seen karma issued in a while
01:49:36 <dons> ?karma+ everyone
01:49:36 <lambdabot> everyone's karma raised to 0.
01:49:38 <mm_freak> karma?!
01:49:38 * glguy hasn't been very active in channel either though
01:49:41 <mm_freak> ?karma
01:49:41 <lambdabot> You have a karma of 0
01:49:41 <ski> @last-karma
01:49:41 <lambdabot> Unknown command, try @list
01:49:47 <dons> ?karma-all ?
01:49:48 <lambdabot>  "audreyt"             634
01:49:48 <lambdabot>  "fglock"              211
01:49:48 <lambdabot>  "dons"                145
01:49:48 <lambdabot>  "agentz"              100
01:49:48 <lambdabot>  "gaal"                 99
01:49:48 <mm_freak> lol
01:49:50 <lambdabot> [1179 @more lines]
01:49:57 <glguy> @more
01:49:57 <lambdabot>  "larry"                97
01:49:57 <lambdabot>  "lwall"                77
01:49:57 <lambdabot>  "moritz"               63
01:49:58 <lambdabot>  "putter"               56
01:49:58 <dons> damn perlers and their karma bots ;)
01:50:00 <lambdabot>  "sjanssen"             52
01:50:02 <lambdabot> [1174 @more lines]
01:50:12 <mm_freak> what's that actually?
01:50:18 <Pupeno> hello.
01:50:42 <apfelmus> mm_freak: but for optimization, comparing is to be abs(x-y) < epsilon
01:50:49 <dons> apparently Andrew Coppin's been here. Anyone remember that?
01:50:50 <glguy> mm_freak: a meaningless number associated with a nick that anyone can change
01:50:59 <dons> "Unfortunately, when I ask questions most people seem to either ignore me
01:50:59 <dons> or not know what the answer is. :-(
01:50:59 <dons> "
01:51:04 <mm_freak> k hehe
01:51:27 <ski> @karma plan9
01:51:27 <lambdabot> plan9 has a karma of 0
01:51:38 <glguy> @karma java
01:51:38 <lambdabot> java has a karma of -16
01:51:44 <jre2> @karma dgriffi3
01:51:44 <lambdabot> dgriffi3 has a karma of 1
01:51:53 <narain> ?karma c++
01:51:54 <lambdabot> c++ has a karma of -5
01:52:00 <jre2> haha, jre2 > java
01:52:03 <apfelmus> dons: i wonder which case is the case when applying the sentence to himself :)
01:52:18 <dons> :)
01:52:42 <mm_freak> apfelmus: i agree with you about exact comparison, but not about less-than
01:53:34 <narain> mm_freak: there's no clean way to do less-than on floats if they're likely to be arbitrarily close
01:53:37 <narain> afaik
01:53:51 <narain> or what would you suggest?
01:54:03 <mm_freak> narain: depends on what you are doing the comparison for
01:54:06 <Pupeno> Hello.
01:54:09 <apfelmus> mm_freak: 2d/3d geometry algorithms are damn sensitive to <
01:54:33 <narain> mm_freak: yeah, for ray tracing you nudge one of the values by 0.000001 or something
01:54:40 <mm_freak> apfelmus: for bounds checking it's ok to compare with < or >
01:55:41 <apfelmus> mm_freak: yes. but you can still run into problems
01:55:43 <mm_freak> and in some cases even exact comparison is ok:  fdiv x y | (y == 0) = undefined
01:55:47 <apfelmus> > sqrt (3.3-(1.1+2.2)
01:55:47 <lambdabot>  Parse error
01:55:55 <apfelmus> > sqrt $ 3.3-(1.1+2.2)
01:55:57 <lambdabot>  NaN
01:56:41 <narain> mm_freak: not if it's possible for y to be < 1E12 or something
01:56:45 <apfelmus> > 12.0 / (3.3-(1.1+2.2))
01:56:47 <lambdabot>  -2.7021597764222976e16
01:56:48 <narain> horrible numerical instability!
01:56:59 <narain> run for your lives!
01:57:01 <apfelmus> mm_freak: i guess it's not ok at all :)
01:57:16 <dons> very nice, apfelmus :)
01:57:19 <mm_freak> narain: you may end up with a pretty large value, but unless y is exactly 0, x `fdiv` y is defined
01:57:42 <mm_freak> even with the limited-precision floats =)
01:58:22 <apfelmus> mm_freak: well, having a well-defined value is more or less pointless if it's garbage
01:58:23 <narain> ah, so the question is whether you want to return a wildly unstable value or no value at all
01:58:48 <apfelmus> i should say "defined" in stead of "well-defined" here
01:59:14 <mm_freak> narain: the value is not unstable…  it's ok to return a huge number for 1/0.00000000001
01:59:24 <dons> so hmm, would "best practice" for Haskell programs to be to default(Rational), unless you can provide evidence that its ok to use something less precise?
01:59:41 <dons> should we be recommending default(Rational) as soon as someone wants to do non-integral math?
01:59:42 <narain> right, unless you got the 0.0000000001 from say 3.3-2.2-1.1
01:59:53 <ricky_clarkson> CL-USER> (sqrt (- 3.3 (+ 1.1 2.2))) -> #C(0 4.8828125E-4)
02:00:12 <mm_freak> dons: i'd say the other way round…  there are pretty few cases where you need more precision than Float provides…  almost none other than money or a few scientific applications
02:00:16 <dons> > 12.0 / (3.3-(1.1+2.2)) :: Rational
02:00:18 <lambdabot>  Exception: Ratio.%: zero denominator
02:00:31 <dons> mm_freak: but its unsafe by default. that's the essence here
02:00:42 <dons> Haskell is to be safe by default. You ask for unsafe things explicitly
02:00:44 <apfelmus> dons: yes, i think so. Rational provides safe < and ==. no thinking required, it just works
02:01:16 <mm_freak> narain: calculating 3.3 - 2.2 - 1.1 is pointless…  nobody would do that directly, other than someone who doesn't understand how floating point works
02:01:25 <dons> mm_freak: that's the essence of 'the haskell way' (like 'pythonic'), is that things just work, and are safe, by default. *not* that you get something that mostly works by default
02:01:45 <mm_freak> dons: Rationals are awfully slow
02:01:46 <dons> apfelmus: i think we really could get a Rational onto the H' ticket.
02:01:47 <apfelmus> mm_freak: that's the point. with Rational, you don't need to understand floating point numbers
02:02:01 <apfelmus> dons: yes
02:02:10 <dons> mm_freak: i've not seen any examples of that. it maybe be true, but so is Integer
02:02:24 <dons> certainly without very strong numbers, safety would be preferred
02:02:29 <ricky_clarkson> In CL, you can do exact maths with such numbers, using fractions.
02:02:33 <apfelmus> turning Rational off is just a matter of supplying a Double type signature
02:02:33 <mm_freak> dons: Rationals are _much_ slower than integers…  after each addition you have to do a GCD operation
02:02:35 <dons> apfelmus: should we see what people say on libraries@ ? or haskell-prime@ ?
02:02:46 <jre2> I agree, C is the 'dont get anything you didn't explicitly ask for, expect to get screwed eventually' language, stay away from that mindset
02:02:54 <dons> mm_freak: I can accept that, but would need to see the numbers
02:03:13 <apfelmus> dons: yeah, they won't notice it otherwise :) a message cc-ed to both lists is probably best
02:03:30 <dons> mm_freak: if performance matters, default(Float) and pay the price :)
02:03:34 <dons> that's the Haskell way!
02:03:46 <mm_freak> dons: 2/3 + 4/5 implies one LCM to get the common denominator (you could do a simple multiplication if you don't care about lots of memory wasted)
02:03:50 <ricky_clarkson> jre2: Disregarding floats, anywhere that 1/2==0 is a bad place.
02:04:07 <jre2> ricky_clarkson: hah
02:04:08 <mm_freak> after that the result needs to be reduced to the smallest representation using GCD again
02:04:20 <mm_freak> (LCM implies GCD)
02:04:33 <narain> you'd just have to tell people to do default(Double) if they want to use sqrt, sin etc
02:04:38 <apfelmus> in fact, not one of the programs i wrote will likely change with a default(Rational)
02:04:43 <jre2> as long as its a one liner default(Float) to trade correctness for speed, I vote for favouring correctness by default
02:04:48 <mm_freak> in Float an addition is just an addition and a bit shift, nothing more
02:05:20 <dons> :t pi
02:05:22 <lambdabot> forall a. (Floating a) => a
02:05:24 <Svrog> yeah, i think favoring correctness by default is a good idea
02:05:38 <dons> ?instance Floating
02:05:38 <lambdabot> Maybe you meant: instances instances-importing
02:05:41 <dons> ?instances Floating
02:05:42 <lambdabot> Double, Float
02:05:47 <narain> some people care about sqrt and exp and sin and stuff
02:05:53 <mm_freak> i really so nothing incorrect about Float…  it has limited precision, but is not incorrect
02:06:01 <narain> but apart from that i like the Rational idea
02:06:20 <Cheery> this brings my mind back into swarm behavior: http://gizmodo.com/gadgets/the-real-.n-sync/human-pixels-perform-huge-real+time-animation-275689.php
02:06:23 <lambdabot> Title: The Real 'N Sync: Human Pixels Perform Huge Real-Time Animation - Gizmodo, http://tinyurl.com/2lrr7m
02:06:24 <dons> mm_freak: i think you're missing the haskell philosophy here. any chance for things to behave counter-intuitively should be considered a bug.
02:06:35 <ricky_clarkson> You could refuse to calculate the actual value of sqrt(2) until it's needed - meanwhile you know it is sqrt(2).  That way you could square it again exactly.
02:06:36 <narain> (ps i am one of the aforementioned people who cares about transcendental functions)
02:06:36 <apfelmus> @google A new representation of the rational numbers for fast easy arithmetic
02:06:38 <lambdabot> http://www.cs.toronto.edu/~hehner/ratno.pdf
02:06:43 <mm_freak> and btw, there is no clear definition of how precise a "imprecise by nature" operation should be using Rationals
02:06:52 <mm_freak> like log, sin, sqrt, etc.
02:07:09 <narain> ricky_clarkson: is that practically implementable in Rationals?
02:07:18 <dons> yes, they'd constrain away from Rational, i'd imagine.
02:07:18 <mm_freak> so the only operation which gets more precise is division
02:07:19 <ricky_clarkson> No idea.
02:07:28 <apfelmus> mm_freak: log, sin, sqrt will default to Float/Double even with default(Rational)
02:07:29 <dons> so it probably means a reorganisation of the Real and Floating hierarchies
02:07:43 <dons> :t sin
02:07:45 <lambdabot> forall a. (Floating a) => a -> a
02:07:55 <dons> yeah, so they'll pull you into the more efficient types
02:07:58 <dons> like 'length' does
02:08:01 <mm_freak> apfelmus: then where's the point?  someone using Fractionals will not only add and multiply
02:08:16 <mm_freak> they'll be doing something irrational anyway
02:08:19 <dons> to avoid 12.0 / (3.3-(1.1+2.2)) mm_freak :)
02:08:35 <apfelmus> mm_freak: why not? if they don't, type inference will figure out
02:08:54 <mm_freak> dons: you sacrifice a lot to people who just aren't able to understand what is teached by almost any programmer's book ;)
02:08:59 <dons> so there's a pretty strong case that defaulting to Double is like defaulting to overflowable Int, and unsafe. The counter point is efficiency?
02:09:04 <mm_freak> → do NOT do that with floating point numbers
02:09:11 <dons> that's not the haskell way
02:09:14 <dons> that's the C way.
02:09:27 <dons> the language should be safe without reading the book
02:09:30 <apfelmus> defaulting is really a minor issue
02:09:41 <mm_freak> dons: Double is only limitedly precise…  that's it
02:09:54 <apfelmus> once you declare a type signature, defaulting doesn't jump in anyway
02:09:56 <mm_freak> it does not introduce errors like 3 + 4 = 1
02:10:13 <mm_freak> 1.1 + 2.2 is still 3.3 with Floats, just less precise
02:10:58 <dons> its unsafe, by the usual haskell definition. laws fall down. seems a no brainer to default to the safe types, as we do for Integer.
02:11:14 <jre2> the fact that the books say that you can't perform an otherwise perfectly normal operation because of inherent flaws in the numbers' representations is all the more reason to break away from that
02:11:14 <dons> can you state the argument against it mm_freak ? is it efficiency and that people should know the issues with fp math already?
02:11:37 <mm_freak> dons: still the haskell98 people default to Float
02:11:42 <apfelmus> the argument against Floats is that all laws for +,* and so on are broken
02:11:44 <mm_freak> and IMO that's not unreasonable
02:11:45 <dons> because those two arguments are already dismissed for Int/Integer.
02:11:50 <Svrog> floating point types are low level and tied to the hardware unlike rationals - it just so happens that most of the common hardware supports floats and doubles but even so they are out of place as a default type in a high level language like haskell imo
02:11:59 <dons> h98 is being revised :)
02:12:06 <mm_freak> firstly, almost all applications using Fractional types will use sqrt or some other irrational function
02:12:24 <dons> we'd need some numbers to strengthen that, mm_freak. perhaps check in hackage libs?
02:12:27 <mm_freak> so again Rational does lose its stability
02:12:40 <mm_freak> secondly, the performance penalty is VERY noticable
02:12:57 <apfelmus> mm_freak: a simple type signature makes the spook go away
02:13:07 <mm_freak> a simple addition requires multiple _long_ multiplications and _long_ modulo because of GCD
02:13:16 <dons> you'd need numbers for that as well.
02:13:21 <mm_freak> apfelmus: then most people would end up filling their code with type sigs
02:13:23 <dons> if they were terrible, it might be influential
02:13:29 <dons> mm_freak: nope, default(Double)
02:13:36 <apfelmus> mm_freak: yes, that's what they should do anyway :)
02:13:42 <Svrog> well anyone doing 3d graphics, audio processing, or some other computationally intensive thing will use floats and doubles that much is clear - i myself hardly ever use rational and use floats a lot
02:13:46 <dons> or your sqrts introduce the constraint, like 'length' dooes
02:13:52 <dons> so type signs/verbosity isn't an issue
02:13:55 <mm_freak> dons: what's the point in writing that in almost every source file ;)
02:14:10 <dons> you'd rely on the operations that require Floating to constrain it
02:14:14 <dons> same as for Int. so that's a non-issue
02:14:20 <Svrog> yup
02:14:22 <dons> which leaves what, efficiency as the only concern?
02:14:23 <apfelmus> yes, i agree
02:14:39 <dons> oh, and that there might not be many programs that could use only Rational
02:14:47 <dons> so maybe the power/weight ratio isn't good enough to change
02:15:00 <apfelmus> as soon as you have data Point3D = P3 !Double !Double !Double,
02:15:05 <dons> i think showing broken laws for basic math with Float and Double is a *very* strong argument in favour
02:15:12 <apfelmus> your operations will use Double anyqay
02:15:28 <mm_freak> dons: the point is, it's useless…  if your application doesn't do anything beyond +, -, * and /, then it's really ok to use Rationals for the sake of stability
02:15:29 <dons> yeah, so defaulting back to efficient hardware forms is fine.
02:15:54 <mm_freak> but that's it…  almost all other Fractional operations are unstable
02:16:20 <mm_freak> unstable by nature that is
02:16:35 <mm_freak> Rational would be inefficient _and_ useless for most applications
02:16:38 <dons> yes. so they'd pull in the hardware/unstable floating point types, if you used them
02:16:46 <apfelmus> well, we should get roconnor's exact real number arithmetic as standard in H' :)
02:16:55 <dons> but by default the fp math would be safe, which is the haskell design goal
02:17:11 <narain> also, you'd need to explain loudly in every haskell-for-c-programmers article that reals are now Rational rather than Floating... just wanted to bring that up because it's important if the change goes through :)
02:17:14 <mm_freak> they would do that almost all the time, so why not default to it?  just because Float is not precise for division?
02:17:16 <dons> yeah, so there's a few different representations for exact reals we could use.
02:17:49 <dons> mm_freak: because its not the haskell way: unsafety is a devastating argument in the haskell world.
02:18:07 <mm_freak> dons: unstable /= unsafe
02:18:12 <dons> and that we already have the precedent for Integer
02:18:22 <mm_freak> you can't do anything about the unstability of finite fractionals
02:18:27 <narain> > 3.3 - 1.1 - 1.1 + 2*1.1
02:18:28 <dons> so we know we can do this, and it works, and we get a larger set of safer programs by default
02:18:30 <apfelmus> mm_freak: Rational may be useless as soon as you use sqrt. But the compiler will not use Rationals then anyway
02:18:36 <lambdabot>  3.3
02:18:40 <Svrog> mm_freak: what about adding a command line option to ghc to override that - then you wouldn't have to add default(Float) to your code, you'd just have to add that command line option
02:18:54 <dons> Svrog: that's very interesitng
02:18:56 <Pupeno> Is there any strong reason to use 6.6.1 instead of 6.6? does yi or Happs depend on 6.6.1?
02:18:57 <dons> a bit like -funsafe
02:18:58 <mm_freak> svrog: the correctness of the code should not depend on commandline options
02:19:05 <narain> > 1.1 + 1.1 + 1.1 - 3*1.1
02:19:07 <lambdabot>  0.0
02:19:10 <Svrog> mm_freak: yes - it should be correct by default :)
02:19:12 <dons> mm_freak: so your concern is what? efficiency?
02:19:20 <Svrog> hence rational as default
02:19:22 <mm_freak> dons: i don't have any concern
02:19:33 <quicksilver> the correctness of code already *odes*
02:19:38 <quicksilver> depend on commandline options
02:19:40 <quicksilver> by the way :)
02:19:41 <mm_freak> IMO the current default is totally ok…  IMO there's no reason to default to Rational
02:19:41 <dons> ah quicksilver. what do you think?
02:19:51 <quicksilver> haven't read scrollback yet
02:20:11 <dons> > 12.0 / (3.3-(1.1+2.2)) -- given this, should we not default(Rational)
02:20:13 <lambdabot>  -2.7021597764222976e16
02:20:30 <dons> as we default Integer.
02:20:39 <mm_freak> quicksilver: we're discussing about whether haskell should default to Rational as opposed to Float for fractional computations without explicit type sig
02:20:40 <dons> and then let sqrt et al bring in the more dangerous types
02:20:44 <|Steve|> Rational makes sense to me.
02:20:47 <apfelmus> effect of default(Rational) = all functions that do division but don't  use sin,exp,... are defaulted to Rational
02:21:44 <mm_freak> effect of default(Rational):  sqrt(3.4) would fail ;)
02:21:53 <dons> no, it wouldn't.
02:22:18 <apfelmus> the compiler defaults 3.4 to Float/Double in the case of sqrt(3.4)
02:22:47 <apfelmus> the real default declaration is "default(Integer,Rational,Float)"
02:23:18 <mm_freak> 1.1 + sqrt(2) would fail
02:23:19 <dons> mm_freak: see,
02:23:20 <dons> default(Integer,Rational,Float)
02:23:20 <dons> main = do print (sqrt 3.4)
02:23:51 <dons> mm_freak: , nope, again.
02:23:59 <dons> i think you misunderstand how the type constraints are introduced?
02:24:04 <mm_freak> not?  then were does it default to Rational?
02:24:12 <dons> e.g. that produces;
02:24:13 <dons> $ runhaskell A.hs
02:24:13 <dons> 2.5142136
02:24:14 <mm_freak> were=where
02:24:17 <apfelmus> H98 report: section 4.3.4  Ambiguous Types, and Defaults for Overloaded Numeric Operations
02:24:18 <dons> the sqrt 2
02:24:20 <ski> constraints are passed both from arguments outwards, and from result inwards
02:24:31 <apfelmus> @type 1.1 + sqrt 2
02:24:35 <lambdabot> forall t. (Floating t) => t
02:24:40 <apfelmus> @type 1.1
02:24:42 <lambdabot> forall t. (Fractional t) => t
02:24:45 <ski> aka overloading on both argument and result
02:24:47 <dons> which then triggers the first default Floating type, say Double
02:24:52 <mm_freak> ah k
02:25:06 <mm_freak> so it wouldn't even apply for operations using sqrt/log/etc.
02:25:17 <apfelmus> yes, that's the point :)
02:25:21 <dons> right, sqrt would trigger the use of hardware FP.
02:25:24 <mm_freak> then i misunderstood you, sorry =)
02:25:31 <dons> ah :)
02:25:50 <dons> the interaction between type inference, type classes and defaulting here is rather lovely
02:26:04 <dons> numeric literals, with better types being found as necessary. all good.
02:26:35 <mm_freak> yeah…  still IMO the gain in defaulting to Rational is much less than the cost
02:26:50 <dons> so how would we quantify that?
02:26:58 <dons> test nofib with default Rational
02:27:01 <dons> and see what happens speedwise
02:27:02 <mm_freak> benchmark it
02:27:26 <mm_freak> use `sum' on a large list of fractional values, once with Rational and once with Float
02:28:01 <dons> yes, the usual approach would be to modify the defaulting rules, and then test our benchmark suite
02:28:10 <dons> this was done recently for removing the monomorphism restriction, for example
02:28:34 <narain> that's interesting. what were the results?
02:28:42 <dons> very little change
02:28:56 <narain> so the monomorphism restriction is going to be removed?
02:29:05 <dons> not sure what the vote currently is for that.
02:29:13 <narain> ah, ok.
02:29:13 <mm_freak> dons: the change is noticable here, even for interpreted code
02:29:20 <mm_freak> > sum [(y::Rational)/10 | y <- [1..100000]]
02:29:20 <mm_freak> 500005000%1
02:29:22 <lambdabot>  500005000%1
02:29:26 <mm_freak> took around a second
02:29:26 <apfelmus> i think the history paper mentioned that John Huges tripped on an exponential blowup without MR
02:29:33 <mm_freak> > sum [(y::Float)/10 | y <- [1..100000]]
02:29:35 <lambdabot>  4.9999942e8
02:29:37 <mm_freak> was instant
02:29:37 <dons> yes, if we picked this, we'd very likely want to look at optimised Rationals
02:29:45 <dons> as we use gmp for Integer, for example.
02:29:51 <dons> that's a separate issue
02:29:58 <dons> its not choosing this Rational implementation as standard
02:30:00 <apfelmus> btw, most people want to ditch defaulting completely :)
02:30:05 <dons> but choosing an exact type of some sort.
02:30:14 <apfelmus> *some people
02:30:27 <mm_freak> well, with Rational addition you have the choice:  either a single mul and a gcd, wasting a lot of memory, or an lcm and wasting time
02:30:28 <dons> so, we could use say, that paper apfelmus pointed at earlier. or some C lib
02:31:11 <mm_freak> it already uses GMP for Rational
02:31:20 <mm_freak> i don't know of any faster lib
02:31:26 <dons> well, it sort of uses gmp.
02:31:39 <dons> and the impl doesn't look terribly optimised on the haskell side, in my view.
02:31:49 <dons> but that's separate to the issue of which type to choose
02:31:49 <ketil> Morning (afternoon/evening - whatever)
02:32:10 <ketil> Any idea how to deal with possibly missing executables and runInteractiveCommand?
02:32:25 <ketil> (posted to the haskell-cafe just now)
02:32:36 <Svrog> gmp is going to be replaced with something else in 6.8 afaik
02:32:46 <mm_freak> really?  with what?
02:32:52 <ketil> Problem is my application shuts down if a (sub) executable isn't found...
02:32:55 <Svrog> i dont think it's been decided yet
02:33:21 <eivuokko> Svrog, I don't think so, it seems to me that work isn't gone far enough to do that.
02:33:27 <ketil> Any good candidates (for GMP replacements) then?
02:33:30 <mm_freak> hmm…  they should incorporate the GMP sources somehow, so that FFI functions can use GMP
02:33:33 <Svrog> oh
02:34:01 <Svrog> http://hackage.haskell.org/trac/ghc/wiki/ReplacingGMPNotes
02:34:03 <lambdabot> Title: ReplacingGMPNotes - GHC - Trac
02:34:07 <dons> apfelmus, quicksilver: so what do you think, should we at least make the proposal, and see what people say?
02:34:14 <mm_freak> yeah, i've read that
02:34:14 <dons> i think we've covered the main issues here for and against
02:34:16 <apfelmus> dons: yes
02:34:22 <DRMacIver> Morning
02:34:23 <dons> perhaps some examples of programs that would be correct, with this change
02:34:27 <dons> and programs that woudl get slower, with the change
02:34:47 <mm_freak> they shouldn't replace GMP, they just need to make it accessible to FFI
02:34:59 <narain> any program that does real arithmetic would get slower with the change afaict...
02:35:02 <dons> there's issues with gmp and licensing too, unfortunately
02:35:18 <dons> narain: slower, but it would be correct. same issue with Int/Integer
02:35:26 <narain> sure, not arguing
02:35:28 <dons> so if you cared, you'd introduce Double.
02:35:34 <dons> but yes, that's exactly the issue.
02:35:39 <Svrog> cant use ghc commercially if gmp is statically linked with apps
02:35:42 <narain> just saying examples for the second bit won't be hard to find :)
02:35:55 <Svrog> or rather you can use it commercially but have to release sources
02:36:03 <Svrog> which is not practical for many companies
02:36:27 <mm_freak> hmm, wonder why not…  GMP is LGPL
02:36:27 <eivuokko> Well, what you can do, is to replace gmp's archive with import lib to gmp's dll-version.
02:36:28 <dons> you have to dyn link gmp, yep.
02:36:55 <Svrog> LGPL requires that closed source apps can only dynamically link against the lib
02:36:56 <eivuokko> mm_freak, Static linking is often much more easier choice for distribution or similar reasons :)
02:37:09 <norpan> we have exactly that problem
02:37:14 <mm_freak> eivuokko: and very bad style =)
02:37:25 <norpan> so we have to ship libgmp.so and the sources
02:37:35 <eivuokko> mm_freak, That is your opinion, some of us disagree.
02:38:06 <Pupeno> When running yi, I get this error: "Not in scope: type constructor or class `YiM'", I am just using one of the example configuration files, and yi 0.2. Any ideas?
02:38:18 <dons> hmm, perhaps try darcs ?
02:38:25 <mm_freak> eivuokko: GHC-produced binaries are giants, for some reason…  GMP isn't large, but surely makes a noticable difference
02:38:27 <dons> Pupeno: and ask on the yi mailing list
02:38:43 <mm_freak> especially considering that it comes with a lot of code GHC doesn't use at all
02:38:57 <ketil> @where findExecutable
02:38:57 <lambdabot> I know nothing about findexecutable.
02:39:06 <Svrog> mm_freak: you can run strip on the produced binaries to make them a bit smaller
02:39:08 <ketil> @hoogle findExecutable
02:39:08 <wli> -ffunction-sections and ld --gc?
02:39:09 <lambdabot> System.Directory.findExecutable :: String -> IO (Maybe FilePath)
02:39:21 <mm_freak> svrog: tried…  difference is neglible
02:39:28 <eivuokko> mm_freak, Some of us don't care about size so much as licesing/single-file.
02:39:54 <mm_freak> if i recall correctly one of the reasons is that the VM is linked in
02:39:56 <ketil> @botsnack
02:39:56 <lambdabot> :)
02:40:13 <Svrog> mm_freak: is your ghc built with SPLIT_OBJS set to true or yes?
02:40:24 <Svrog> cant remember if i got the name of the parameter correct
02:40:39 <eivuokko> For me, stripping ghc built binaries, diffrence isn't neglible.
02:40:45 <mm_freak> svrog: i don't know…  distribution's installation
02:40:52 <eivuokko> Yes, and all your cabal libraries should have been confiured with --enable-split-objs
02:40:54 <Svrog> mm_freak: then it's probably compiled with that set to no
02:41:02 * wli has enough disk space he'd rather have all the debug info.
02:41:06 <Svrog> compile it from sources, set it to yes and binaries produced should be smaller
02:41:11 <Svrog> not sure how much smaller
02:41:16 <quicksilver> I think default Rational would be a bit dangerous
02:41:23 <mm_freak> well, it's not too much of an issue
02:41:28 <Svrog> it's set to no by default because changing it makes the compilation process even slower
02:41:36 <mm_freak> quicksilver: explain
02:41:44 <quicksilver> certain programs would suffer from very large number storage rather quickly
02:42:09 <mm_freak> quicksilver: that's what i addressed earlier, and i've been ignored =)
02:42:13 <quicksilver> Rational is Ratio Integer, right? it's the unbounded one?
02:42:23 <wli> quicksilver: yeah
02:42:24 <mm_freak> yeah, it's unbounded
02:42:26 * quicksilver nods
02:42:34 <quicksilver> yes, I think that's a bit too dangerous as a default
02:43:01 <quicksilver> no other general purpose language defaults to arbitrary precision
02:43:09 <quicksilver> afaik
02:43:10 <mm_freak> exactly…  even additions would use lots of memory
02:43:16 <quicksilver> some of the maths ones do, of course
02:43:21 <quicksilver> but that's a bit of a special case
02:43:22 <mm_freak> quicksilver: python and erlang do, AFAIK
02:43:26 <wli> It could be worse. They could be using finite continued fractions to represent rationals with Gosper's algorithms etc.
02:43:30 <Svrog> i thought lisp and scheme defaulted to arbitrary precision
02:43:48 <mm_freak> svrog: yeah, at least lisp does
02:44:19 <dons> yes, it would be good to find what languages in a similar place do
02:44:20 <ski> i thought lisps usually implicitly converted to better precision, as needed
02:44:48 <mm_freak> dons: i don't know of any language, which defaults to arbitrary precision for fractional numbers
02:45:01 <dons> we'd need to benchmark it to be able to decide, i'm pretty sure. and perhaps try several implementations
02:45:06 * quicksilver nods
02:45:16 <quicksilver> default to arbitrary precision integer is not so painful
02:45:20 <quicksilver> since htat's much more intutiive
02:45:26 <quicksilver> only 'really big' numbers take up space
02:45:40 <mm_freak> dons: really, you don't need to benchmark…  just consider that numbers will grow and grow and grow in memory use
02:45:48 <mm_freak> and the only way to stop that is to limit precision
02:45:52 <quicksilver> but rational is unintuitive, because 'normal operations' can build up unexpectedly high precision
02:46:13 <Svrog> ski: wouldnt that be problematic when going from floats to rationals - say half the computation was done with floats and then the other half with rationals - how could you even tell when float to "upgrade" a float to a rational?
02:46:21 <dons> yes, that's a good point, quicksilver.
02:46:26 <Svrog> -float
02:46:41 <mm_freak> dons: i've addressed that point MUCH earlier, you just didn't listen
02:46:55 <dons> sorry mm_freak, there was a lot flying by
02:47:08 <dons> i did try to clarify your points several times.
02:47:23 <quicksilver> I think Rational is a really powerful paradigm but it probably should be a concious choice
02:47:32 <apfelmus> quicksilver: but so should Float be
02:47:37 <mm_freak> dons: the whole point is:  whatever you do, at some point you'd need to limit precision anyway
02:48:01 <quicksilver> apfelmus: Float and Double? or are you particularly targetting Float?
02:48:10 <wli> Precision-limiting operations are possible with relatively simple continued fraction things.
02:48:10 <apfelmus> quicksilver: since Float/Doubble breaks every law available
02:48:15 <Pupeno> where's the repo for yi-vty and yi-gtk?
02:48:15 * quicksilver nods
02:48:25 <quicksilver> apfelmus: the funny thing is, though, that computer programmers expect that behaviour
02:48:29 <mm_freak> i'd rather introduce a new floating point type with a base with more prime factors, but i wouldn't use true rational numbers as defaults
02:48:35 <quicksilver> apfelmus: so it doesn't violate least surprise so much
02:48:47 <quicksilver> (well experienced programmers do, at least)
02:48:55 <wli> You can basically put a bound on the denominator and use continued fractions to find the closest approximation.
02:49:01 <dons> which is the unhaskelly thing, quicksilver. its identical to Int overflow
02:49:03 <apfelmus> quicksilver: "well experienced" <- that's the crux :)
02:49:09 <ski> Svrog : at least Scheme has this 'exact' vs. 'inexact' numbers things, where floating point numbers (both real and complex) are inexact .. also 'inexact' is contagious
02:49:16 <dons> experience people know, but the language isn't supposed to rely on an "experience" precondition :)
02:49:22 <Svrog> ah
02:49:28 <mm_freak> wli: that's too expensive for every-day operations
02:49:46 <apfelmus> and who says that we may not use lazy lists for representation rational numbers?
02:49:50 <mm_freak> and almost equivalent to just using floating point with a larger base
02:50:10 <dons> > > 12.0 / (3.3-(1.1+2.2)) -- so its this we want to avoid. completely unbounded Rational seems unintuitively expensive
02:50:10 <lambdabot>  Parse error
02:50:15 <dons> so maybe there's a middle ground.
02:50:24 <DRMacIver> apfelmus: Why stick with rationals? We can represent arbitrary computable reals that way. :)
02:50:29 <mm_freak> apfelmus: that's still no different to using floating point =)
02:50:51 <mm_freak> you can approximate to any level of precision you want with floats
02:50:59 <mm_freak> just use a larger base than 2
02:51:01 <apfelmus> DRMacIver, mm_freak: it is. == becomes undecidable :)
02:51:08 <dons> yes, we'd need to do a survey of other representations, and approaches, beyond the current Rational.
02:51:18 <DRMacIver> apfelmus: Psht. That hardly matters. ;)
02:51:34 <apfelmus> :D
02:51:43 <mm_freak> a Float is essentially m * b^e, with b = 2
02:51:46 <quicksilver> Removing Eq from some of these classes would be nice
02:51:47 <apfelmus> well, the point of Rational is to have < and == work as expected
02:51:48 <quicksilver> :)
02:52:13 <apfelmus> > 1.1+2.2 == 3.3
02:52:15 <lambdabot>  False
02:52:18 <dons> > 1.1 + 2.2 == 3.3 :: Rational
02:52:20 <lambdabot>  Couldn't match expected type `Rational'
02:52:24 <dons> > 1.1 + 2.2 == (3.3 :: Rational)
02:52:24 <mm_freak> now if we would choose b to be 2*3*5*7*11*13*17*19, then we could represent more numbers than we could using decimal =)
02:52:26 <lambdabot>  True
02:52:52 <mm_freak> b = 2*5 would suffice for 1.1 + 2.2 == 3.3 to be True =)
02:52:54 <ski> '3.3 :: Rational' scares me ..
02:53:10 <apfelmus> ski: yeah, so we want default(Rational) :)
02:53:22 <narain> > 3.3 :: Rational
02:53:25 <lambdabot>  33%10
02:53:29 <narain> > pi :: Rational
02:53:31 <lambdabot>   add an instance declaration for (Floating Rational)
02:53:31 <lambdabot>     In the expression: ...
02:53:31 <ski> (i mean it scares me that that type-checks ..)
02:53:48 <dons> there's the basic issue. == doesn't work as expected, so its broken from the outset. but I like quicksilver's point that the Ratio Integer Integer representation is inefficient in hard-to-reason about ways
02:54:02 <apfelmus> but it's semantically safe
02:54:19 <DRMacIver> Semantic safety doesn't always beat efficiency. :)
02:54:29 <dons> right, and we favour semantic correctness , assuming an acceptably efficient mechanism can be found.
02:54:43 <dons> so for Int/Integer, the balance falls out for Integer
02:54:45 <apfelmus> Rational = safe semantics, unsafe performance
02:54:56 <mm_freak> dons: you almost can't guarantee semantical correctness for == with fractional numbers
02:55:02 <apfelmus> Float/Double = crap semantics, safe performance
02:55:23 <ski> let's get the wrong answer, fast !
02:55:26 <dons> i'd go so far though, apfelmus, to say they're unsafe.
02:55:34 <dons> in the same way we have unsafe shiftL and friends
02:55:42 <Pupeno> yeah! unstable yi run.
02:55:52 <dons> you have an "i know what i'm doing" side condition, as soon as you use these types
02:56:11 <apfelmus> i wish i knew what i was doing when using Double :)
02:56:34 <mm_freak> consider this:  > toRational (sin pi) == 0
02:56:36 <apfelmus> i once wrote a tiny 3d -> Postscript engine
02:56:38 <eivuokko> I use Float and hope it shows up right on screen :-P
02:56:40 <mm_freak> > toRational (sin pi) == 0
02:56:40 <dons> so, i think we could get consensus that the current defaulting to unsafe types is unacceptable, but we'd need to find a data type with a better efficiency/correctness ratio
02:56:42 <lambdabot>  False
02:56:52 <quicksilver> ski: why wouldn't you expect 3.3 :: Rational to type check?
02:56:53 <Saizan> ?seen alexj
02:56:53 <lambdabot> I saw alexj leaving #haskell 2d 2h 38m 8s ago, and .
02:56:58 <quicksilver> ski: do you not think 3.3 is a rational number?
02:57:00 <ski> http://docs.sun.com/source/806-3568/ncg_goldberg.html
02:57:01 <lambdabot> Title: What Every Computer Scientist Should Know About Floating-Point Arithmetic
02:57:16 <mm_freak> > toRational (sin pi)
02:57:18 <lambdabot>  2259%18446744073709551616
02:57:20 <dons> yeah, that document is the side condition to the type system for floating point, ski :)
02:57:23 <ski> quicksilver : use of the '.' to me connotes imprecise numbers
02:57:26 <apfelmus> and it didn't work at all until i replaced different uses of < on the same numbers with comparing
02:57:30 <quicksilver> ski: well it shouldn't :)
02:57:44 <quicksilver> ski: speaking as a mathematician, 3.3 is precisely 33/10
02:57:46 <narain> > toRational 3.3333333333333333333
02:57:48 <lambdabot>  7505999378950827%2251799813685248
02:57:50 <quicksilver> ski: there's no ambiguity
02:57:55 <mm_freak> ski: very good point
02:58:12 <quicksilver> 3.3 (to 2sf) <--- now that connotes imprecision
02:58:45 <mm_freak> if every haskell tutorial and the specification would tell that fractional constants likely imply loss of precision, then Float should be ok to be the default
02:59:13 <quicksilver> > (1/0) :: Rational
02:59:14 <lambdabot>  Exception: Ratio.%: zero denominator
02:59:35 <apfelmus> quicksilver: you need "nullity" for that ;)
02:59:35 <narain> btw i hope the default right now is Double rather than Float?
02:59:38 <mm_freak> and really, there _should_ be a Floating type with an arbitrary base
03:00:43 <narain> mm_freak: well then doesn't that get you all the speed of non-native types and all the precision of floating-point?
03:01:08 <mm_freak> narain: it allows you to be as precise as you wish
03:01:17 <mm_freak> for money, you would use base 10
03:01:23 <narain> ah. memory
03:01:31 <mm_freak> for science, you would use base 2*3*5*7*11*13 or something
03:01:51 <mm_freak> a Float addition internally is an integer addition and a bit shift
03:02:00 <ski> http://en.wikinews.org/wiki/British_computer_scientist's_new_%22nullity%22_idea_provokes_reaction_from_mathematicians
03:02:02 <lambdabot> http://tinyurl.com/y2hu99
03:02:17 <quicksilver> mm_freak: you would NEVER EVER EVER use floating point for money
03:02:19 <mm_freak> for a Floating type with arbitrary base, an addition would be an integer addition and an integer multiplication
03:02:23 <quicksilver> mm_freak: not even if you have base 10
03:02:29 <quicksilver> mm_freak: you would use fixed point
03:02:52 <mm_freak> quicksilver: true
03:03:04 <quicksilver> I can see arbitrary base floating point as mildy useful, but it's a bit obscure
03:03:09 <quicksilver> since you don't really have precision
03:03:16 <quicksilver> you just do, in some simple cases :)
03:03:26 <wli> Hmm. Solving a system of quadratic equations.
03:03:47 <quicksilver> A decent fast fixed point implementation would be nice in haskell
03:03:50 <mm_freak> quicksilver: you're going to limit precision somehow anyway, so why not implicitly that way?
03:04:12 <quicksilver> mm_freak: if you're going to limit precision somehow, why not base 2? :) our hardware is better at that.
03:04:13 <wli> quicksilver: Check the math library page. I saw one there recently.
03:04:31 <quicksilver> and I'm not entirely happy with this:
03:04:32 <mm_freak> quicksilver: because sometimes 2 is just not enough =)
03:04:38 <quicksilver> > ( 255 :: Word8) :: Int8
03:04:39 <lambdabot>  Couldn't match expected type `Int8' against inferred type `Word8'
03:04:48 <mm_freak> it may be preferable to be able to represent certain constants exactly
03:04:48 <narain> wli: what about quadratic equations?
03:04:49 <quicksilver> > fromIntegral ( 255 :: Word8) :: Int8
03:04:50 <lambdabot>  -1
03:04:54 <wli> mm_freak: The big use case there is BCD.
03:05:00 <quicksilver> that's a bit odd
03:05:08 <mm_freak> wli: one of the use cases
03:05:10 <wli> narain: Well, this is floating point, so Groebner doesn't apply.
03:05:13 <quicksilver> although I'm not sure what would be better. _|_ I suppose
03:05:58 <wli> mm_freak: The overridingly common one. Common enough for IBM to dump hardware BCD support into Power6 and get its JVM to use it.
03:06:33 <mm_freak> quicksilver: why is that odd?  255::Word8 is equivalent to (-1)::Int8
03:06:54 <quicksilver> mm_freak: seems to me that's a suprising effect of fromIntegral
03:07:03 <mm_freak> quicksilver: it isn't
03:07:07 <wli> narain: I've written Groebner basis solvers before, but I've got math to do to figure out if there's any convexity/etc. for convergence.
03:07:07 <quicksilver> > (65000 :: Word8)
03:07:09 <lambdabot>  232
03:07:14 <quicksilver> I think that's odd too
03:07:21 <wli> narain: Because this is floating point and Groebner doesn't apply.
03:07:26 <mm_freak> nope, 65000 mod 2^8 = 232
03:07:28 <narain> wli: ah, i'm not familiar with Groebner
03:07:31 <quicksilver> mm_freak: I'm not an idiot
03:07:34 <quicksilver> mm_freak: I know how the maths works
03:07:45 <quicksilver> mm_freak: I just think it's surprsing that fromIntegral silently overflows
03:07:45 <mm_freak> then why do you think it's odd?
03:07:49 <wli> narain: http://holomorphy.com/~wli/Poly.hs
03:07:57 <quicksilver> because that's not what the docs for fromIntegral says it does
03:08:08 <quicksilver> (overflow is undefined, technically, IIRC)
03:08:19 <mm_freak> quicksilver: it has no reason to…  (::Int8) comes after (fromIntegral)
03:08:35 <quicksilver> I don't think that's relevant
03:08:49 <quicksilver> if you prefer, I could say 'I find hte Integral instance for Word8 surprising'
03:08:57 <quicksilver> you can choose which bit to argue with
03:09:04 <quicksilver> but you get the same with Int anyway
03:09:10 <quicksilver> > (1000000000000000000000 :: Int)
03:09:11 <narain> wli: sorry, i don't understand any of what you said :)
03:09:13 <lambdabot>  -559939584
03:09:27 <mm_freak> for fromIntegral (255::Word8)::Int8, you could just leave out the type sig for 255
03:09:28 <wli> narain: http://holomorphy.com/~wli/Poly.hs <-- that explains some of it
03:09:31 <mm_freak> it doesn't matter
03:09:41 <mm_freak> > 255::Int8
03:09:42 <lambdabot>  -1
03:09:48 <DRMacIver> Hm
03:09:58 <DRMacIver> I somehow seem to have picked up the habit of defaulting to pointfree style.
03:10:01 <wli> narain: http://holomorphy.com/~wli/spline/spline.pdf <-- that is for me to explain what I'm doing for myself.
03:10:01 <DRMacIver> I wonder how that happened...
03:10:16 <narain> wli: yes, but code isn't helpful unless you know what the idea behind it is :)
03:10:25 <narain> and it's late... maybe i'll look it up later
03:10:32 <wli> narain: Check wikipedia for Groebner basis
03:11:15 <mm_freak> quicksilver: fromIntegral does no conversion IIRC, it just generalizes the type of an integral number
03:11:16 <narain> right, maybe later, but thanks
03:11:29 <narain> must sleep now
03:11:50 <mm_freak> > fromIntegral ((-1)::Int8)::Integer
03:11:52 <lambdabot>  -1
03:11:59 <mm_freak> > fromIntegral ((-1)::Word8)::Integer
03:12:01 <lambdabot>  255
03:13:14 <Saizan> fromIntegral is not a C cast, it's an actual member of a class, it could easily check for overflow
03:13:57 <mm_freak> saizan: it isn't supposed to
03:14:10 <Saizan> (well, the member is fromInteger, but that's not a problem)
03:14:21 <mm_freak> if you use IntN or WordN, then you should know what you're doing =)
03:14:50 <mm_freak> they do imply trucation, otherwise they would be pointless
03:15:07 <Saizan> yeah, and `mod` 2^n or equivalent if you want
03:15:27 <mm_freak> yeah
03:15:36 <mm_freak> that's what i mean by trucation =)
03:15:47 <Saizan> i mean that it should be explicit
03:16:02 <mm_freak> if you want it to be explicit, use Integer
03:17:15 <mm_freak> anyway guys…  good night =)
03:18:38 <Saizan> ?where report
03:18:38 <lambdabot> http://www.haskell.org/onlinereport/
03:30:37 <quicksilver> mm_freak: what do you mean 'it's not supposed to'?
03:30:41 <quicksilver> mm_freak: what makes you believe that?
03:30:50 <quicksilver> the report leaves its overflow behaviour undefined
03:31:01 <quicksilver> and, yet, people (including me) write programs which depend on its behaviour in GHC
03:31:06 <quicksilver> which is unsatisfactory
03:31:12 <quicksilver> and yes, it's my fault that I do it :)
03:31:31 <quicksilver> I didn't realise it was undefined when I first did it though
03:33:30 <DRMacIver> Isn't even the overflow behaviour of Int subtly undefined in Haskell 98?
03:34:06 <DRMacIver> (In that the word size is specified to be at least (some number noticably less than 32)
03:38:07 <dolio> > succ (maxBound :: Int)
03:38:12 <lambdabot>  Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
03:40:20 <eivuokko> I thought to upload my directx bindings to hackage.  unfortunately they are split into three bits dx9base, dx9d3d, dx9d3dx (with the idea that someday there would be dx9input and dx9sound).  Do I really have to make them diffrent packages in Hackage?
03:41:39 <Lemmih> eivuokko: Yes, no support for shipments yet.
03:41:58 <eivuokko> It's also kinda annoying that I have some shared (generated by me, generation not required by library user) code.  And making packages hackage-compatible that must change.
03:42:05 <nattfodd> is there a more up to date way to use haskell in apache than mod_haskell?
03:42:10 <eivuokko> Lemmih, :-(
03:42:13 <eivuokko> Lemmih, Ok, thanks.
03:42:46 <Lemmih> nattfodd: Yeah, use fastcgi.
03:43:27 <nattfodd> Lemmih: thanks, I'll have a look
03:56:41 <desp> hm
03:57:32 <desp> coming from ML, I'm surprised it's possible to do  data Foo = Foo Bar1 Bar2 Bar3  -- I was expecting to have to do  data Foo = Foo (Bar1, Bar2, Bar3)
03:57:57 <desp> is there a difference between the two, apart from the syntax?
03:58:23 <Saizan> you have one more level of boxing with the latter
03:58:30 <ski> DRMacIver : 30
03:59:07 <desp> Saizan: unnecessary level, right?
03:59:29 <Saizan> desp: generally yes
03:59:35 <ski> http://www.haskell.org/onlinereport/basic.html#numbers
03:59:36 <lambdabot> Title: The Haskell 98 Report: Predefined Types and Classes
04:00:00 <dons> desp: one less pointer, as Saizan says
04:00:02 <Lemmih> desp: Yes, 'type Foo = (Bar1, Bar2, Bar3)' is the same as 'data Foo = Foo Bar1 Bar2 Bar3'.
04:00:08 <ulfdoz> desp: In ML it is similar to the difference between type Foo = Foo of Bar1 * Bar2 * Bar3 and type Foo = Foo of (Bar1 * Bar2 * Bar3)
04:00:18 <desp> ah
04:00:20 <desp> thanks
04:00:36 <ski> (s/ML/OCaml/)
04:01:11 <ketil> Lemmih - except for classes and such, no? (s/type/newtype?)
04:02:15 <ski> newtype Foo = Foo (Bar1, Bar2, Bar3)
04:02:23 <ski> data Foo = Foo Bar1 Bar2 Bar3
04:02:33 <ski> the two types are isomorphic
04:03:16 <Lemmih> ketil: They are isomorphic but not operationally the same.
04:04:05 <wli> It'll take a bit to see that I've actually constructed the matrices properly for all this.
04:08:43 <DRMacIver> ski: Thanks.
04:08:52 <DRMacIver> (Once I figured out what the randomly shouted number signified. ;) )
04:09:43 * ski smiles
04:18:33 <araujo> morning
04:40:40 <DRMacIver> Hm
04:40:50 <DRMacIver> Is there user definable defaulting, or just the built in numeric ones?
04:41:59 <DRMacIver> (I think I might have asked this before, but I don't remember the answer :) )
04:46:10 <dons> there's built in, and extended built in, defaulting
04:47:07 <dons> http://www.haskell.org/ghc/docs/latest/html/users_guide/ch03s04.html#extended-default-rules
04:47:09 <lambdabot> Title: 3.4. Interactive evaluation at the prompt, http://tinyurl.com/2c2oeu
04:47:50 <dons> (it adds Show, Eq, or Ord defaulting)
04:47:55 <dons> > reverse [] -- so this works
04:47:56 <lambdabot>  []
04:52:01 <quicksilver> really defaulting should be seen (IMO) as a convenient feature for interactive evaluation
04:52:08 <quicksilver> so it's well placed in that section of the manul
04:52:20 <quicksilver> 'real programs' probably want to understand their types
05:04:56 <norpan> i don't like defaulting
05:05:09 <norpan> it's too much ad-hoc
05:05:13 <EvilTerran> i agree with quicksilver on it
05:05:39 <norpan> but as a feature for an interpreter, sure
05:05:48 <EvilTerran> it's a pain in the context of whole programs, but quite useful for interactive evaluation
05:08:04 <quicksilver> I suppose it's tied up with the monomorphism restriction too
05:08:20 <quicksilver> personally I'd just as soon as "x = 3" inferred the more general type
05:08:37 <quicksilver> but if the mono. restriction means we can't do that, it's a choice between defaulting and an error
05:09:20 <ricky_clarkson> I wonder if a type system could work that didn't infer a type, but gave all the possible types.
05:10:18 <EvilTerran> 1 :: Int | Integer | Real | ...
05:10:20 <EvilTerran> ?
05:10:34 <ricky_clarkson> Aye.
05:11:10 <Saizan> well, that's either equivalent to Num t => t or subtyping, i think
05:11:21 <quicksilver> we have something very like that with Num a => a
05:11:59 <quicksilver> and in general, the haskell type system does during the inference process collect 'possible types'
05:12:06 <wli> Who needs the monomorphism restriction anyway?
05:12:15 <EvilTerran> well, all possible types wouldn't work. [] :: [Int] | [[Int]] | [[[Int]]] | ...
05:12:24 <quicksilver> although H-M and the principle typing stuff means that the kind of thiing you get is restrictive
05:12:34 <quicksilver> EvilTerran: [] :: [a] :P
05:12:41 <quicksilver> wli: I sure as hell dont!
05:12:55 <DRMacIver> I can still never remember exactly what the monomorphism restriction is. :)
05:13:03 <EvilTerran> well, yes.
05:13:06 <wli> Subtyping could be useful esp. for variant width.
05:13:49 <DRMacIver> ML_sub is a nice instance of hindley-milner with subtyping.
05:13:54 <quicksilver> DRMacIver: top-level bindings may not have inferred polymorphic type
05:14:09 <wli> I forget the precise conditions under which type inference is decidable with subtyping.
05:14:16 <Saizan> 0-arity ones
05:14:24 <quicksilver> wli: although 'Catch' shows that the subtyping can be checked by an external tool
05:14:31 <DRMacIver> quicksilver: I don't follow. Functions do that all the time...
05:14:34 <quicksilver> wli: without having to augment your language's actual type system
05:14:47 <quicksilver> DRMacIver: you must give them an explicit type sig
05:14:48 <DRMacIver> Ah, with Saizan's comment it makes sense. :)
05:14:54 <quicksilver> DRMacIver: if you want them to be polymoprhic
05:14:55 <EvilTerran> why is the monomorphism restriction needed?
05:14:58 <quicksilver> (yes, 0-arity, sorry)
05:15:08 <quicksilver> EvilTerran: only to avoid 'confusion'
05:15:28 <quicksilver> apparently, people believe that top-level CAFs are implicitly shared
05:15:35 <quicksilver> which can only happen if they're monomorphic
05:15:40 * quicksilver shrugs
05:15:43 <EvilTerran> ah. the same reason why the - in -1 is a freakish special case rather than part of the number syntax.
05:15:55 <quicksilver> a similar reason, yes
05:15:59 <wli> It's arguably tripped over more confusion than it's avoided.
05:16:25 <quicksilver> it's not a big deal either, since type sigs for top-level decls are good style
05:16:34 <DRMacIver> So it's just another one of those things where the fact that Haskell was designed by committee shines through. ;)
05:17:53 <DRMacIver> Hm. Can you introduce arbitrary type variables into a monomorphic caf in order to prevent sharing?
05:19:00 <quicksilver> not reliably
05:19:10 <quicksilver> surely the compiler is free to share instances, if it wants to
05:19:10 <DRMacIver> ok. Can you otherwise prevent sharing? :)
05:19:21 <quicksilver> the precise 'degree' of laziness of haskell is not mandated
05:19:35 <quicksilver> compilers have considerable latitude in how much they choose to share
05:20:26 <quicksilver> although I think in practice ghc always share named variables but never (seldom?) common subexpressions
05:21:40 <dolio> Apparently if you have 'let x = e1 in e2' it will pull out instances of e1 in e2, but that's more or less it.
05:21:49 <wli> Why not share everything?
05:22:06 <DRMacIver> wli: Massive space leaks? :)
05:22:51 <wli> Why does that cause space leaks?
05:23:34 <dolio> wli: Consider 'pset [] = [[]]; pset (x:xs) = pset xs ++ map (x:) (pset xs)' versus sharing it.
05:23:56 <DRMacIver> wli: If you thunk a lot of a very large data structure it suddenly takes up a lot more space in memory than it did before. If you've shared it extensively this can prevent it from being garbage collected.
05:23:58 <dolio> In that version, the first pset can get garbage collected once you use it.
05:24:18 <dolio> But if you share, it can't collect until you get to the second half.
05:28:17 <quicksilver> this is subtle, unfortunately
05:28:33 <quicksilver> and whilst ideally we want a language where you don't have to care about memory management
05:28:47 <quicksilver> the fact is both sharing, and not sharing, can have disastrous memory consequences
05:29:05 <quicksilver> the current situation where you give 'sharing hints' by explicit use of let or where is quite convenient
05:29:12 <quicksilver> although its semantically rubbish
05:30:42 <DRMacIver> Hm. Lazy Evaluation /\ Sharing => Disastrous memory consequences. Lazy evaluation /\ !Sharing => Disastrous memory consequences. Therfore Lazy Evaluation => Disastrous memory consequences. QED? ;)
05:31:32 <quicksilver> well it's only "can have" not "will have"
05:31:47 <quicksilver> obviously, the problems arise when you're dealing with structures which are larger than your memory
05:31:53 <quicksilver> and you hope laziness will save the day
05:32:00 <quicksilver> (in a strict language it simply wouldn't be possible anyway)
05:32:39 <quicksilver> in a strict language there are similar issues about sharing, but they're about wasting time recomputing things
05:32:45 <quicksilver> rather than about wasting memory
05:32:49 <quicksilver> mostly, anyway
05:32:50 <DRMacIver> Yeah. I wasn't really being serious. :)
05:33:14 <kpreid> DRMacIver: your logical expressions can be rescued by adding a quantified variable for *what* is being shared
05:33:15 <DRMacIver> (Although memory use can be a problem even when everything in principle fits in your memory)
05:34:45 <ricky_clarkson> Are there any lazy dynamically-typed languages?
05:35:08 <DRMacIver> I think there's a JVM Haskell like which is dynamically typed
05:35:32 <DRMacIver> http://jaskell.codehaus.org/
05:35:33 <lambdabot> Title: Jaskell - Home
05:36:51 <ski> if you have a structure with sharing in haskell, then if you process that you may end up recomputing things (since sharing isn't observable)
05:37:30 <ski> e.g. 'map (1+) (repeat 0)'
05:38:26 <ricky_clarkson> DRMacIver: Interesting.
05:41:08 <DRMacIver> ricky_clarkson: There are probably some more old ones. There were a lot of lazy languages when Haskell was first created (which was really *why* Haskell was first created), so I imagine some of them were dynamically typed.
05:41:34 <ricky_clarkson> I wonder whether some of those are Lispy.
05:42:55 <DRMacIver> No idea. Plausibly. An early Haskell implementation compiled to CL.
05:43:03 <DRMacIver> There's always liskell. But you might find that insufficiently lispy. :)
05:43:05 <ski> @where liskell
05:43:05 <lambdabot> http://clemens.endorphin.org/liskell
05:43:56 <DRMacIver> (It's statically typed and doesn't have macros yet as far as I know, so it's only really syntactically lispy)
05:44:14 <DRMacIver> Oh, maybe it does have macros now.
05:45:09 <DRMacIver> @where+ liskell http://liskell.org/
05:45:09 <lambdabot> Done.
05:45:21 <DRMacIver> @where liskell
05:45:22 <lambdabot> http://liskell.org/
05:52:04 <wli> DrMacIver: Ultimately the only values you absolutely have to keep are those statically declared or obtained via side effect. Everything else should be able to be discarded and reconstructed.
05:53:15 <DRMacIver> Sure
05:53:27 <DRMacIver> But you want the behaviour about when that happens to be reasonably predictable
05:54:14 <wli> The thought here is that the sharing isn't all that big an impediment to GC in principle.
05:54:59 <wli> If something big looks stale, prune it back closer to its roots.
05:55:35 <DRMacIver> In principle I agree. In practice the ability for large chunks of structures you were e.g. using to memoise to disappear out from under you is probably more problematic than the GC issues with sharing.
05:55:56 <pierre-> hello all
05:56:38 <wli> DrMacIver: I'm not sure anyone's really tried it in practice.
05:57:28 <DRMacIver> Please observe correct capitalisation. I'm not a Dr. My initials are DR. :)
05:57:41 <wli> Sorry about that.
05:57:46 <DRMacIver> s'ok.
05:57:51 <DRMacIver> And you're probably right that no one has tried it in practice.
05:57:55 <ski> one could add "strong" references
05:58:17 <DRMacIver> My point is just that I suspect that it would be opening a can of worms much larger than the problem it's trying to solve. :)
05:58:19 <wli> I know people have written such things in C.
05:58:29 <DRMacIver> (Although I occasionally use a trick like that in Java)
05:58:53 <DRMacIver> (Where I memoise certain methods via weak references and recompute if I discover they've vanished)
05:59:23 <wli> Basically for matrices so huge they have to discard and reconstruct them, but the reconstruction is a pure computation apart from the memory manipulation.
05:59:43 <wli> Discard and reconstruct pieces of them, rather.
06:00:09 <wli> Things based on geometry and mesh refinement for finite element sorts of affairs AIUI.
06:00:29 <DRMacIver> There have been instances with lazy IO where I've wanted to do this in Haskell and couldn't figure out how actually.
06:01:00 <DRMacIver> Where basically I have a really large structure stored on disk and want to lazily load and parts of the structure into memory while in principle allowing unused bits to be GCed.
06:01:30 <DRMacIver> So having the capability to do this is indeed a good idea. :) But it would be very wrong default behaviour.
06:01:38 <wli> That's more like buffering than what I'm on about.
06:02:20 <DRMacIver> Well it's the same idea, although different in some important respects. A large structure which can be pruned down by GC and recomputed on need.
06:02:58 <DRMacIver> (The fact that it involves IO probably prevents it from using the same approach though)
06:03:02 <wli> Suppose there's an infinite list, like an infinite list of primes. Instead of keeping it all around while any reference persists, throw away pieces of it.
06:03:08 <DRMacIver> Modulo grossness like unsafePerformIO :)
06:03:11 <Saizan> DRMacIver: you can get something close with ndm's deferred binary
06:03:25 <wli> If you need the pieces back you can recompute them.
06:03:36 <DRMacIver> Saizan: Neat. I'll take a look.
06:04:20 <DRMacIver> Saizan: 'though it looks like it doesn't do the unloading bit.
06:04:35 <ski> wli : how will it rewind ?
06:04:44 <wli> ski: Rewind what?
06:05:10 <ski> forced thunks remember the code which generated the value ?
06:05:28 <ski> rewind the list of primes
06:06:41 <wli> ski: It's not clear it can be easily retrofitted onto existing RTS's.
06:09:58 <ski> http://www.haskell.org/pipermail/haskell-cafe/2004-August/006716.html
06:10:00 <lambdabot> Title: [Haskell-cafe] anti-memoization?, http://tinyurl.com/2udkbu
06:11:53 <wli> ski: For a data structure unfolded out of a fixpoint computation getting it from the root.\binom{i}{j}\delta_{i,j+k}
06:12:57 <ski> '\binom{i}{j}\delta_{i,j+k}' ?
06:13:11 <wli> Stray paste.
06:14:53 <ski> wli : anyway, that cafe post is relevant to what you want, i think (istr there were more discussion on it, but can't find that atm)
06:15:47 <wli> Well, I don't really want it for anything per se. I was largely pointing out that you can treat the set of results of pure computations as a cache.
06:16:02 <fasta> Anyone using hasktags?
06:16:15 <fasta> It appears it skips more than 70% of my functions.
06:16:31 <fasta> Which is pretty sub-optimal.
06:17:35 <ski> (hm, this reminds me of Mercury's I/O tabling for declarative debugging of I/O)
06:18:06 <wli> I liked Mercury. I wonder why there haven't been any Debian package updates in ages.
06:19:19 * qwr . o O ( mercury code looked quite verbose... )
06:19:58 <wli> qwr: Depends on what you're doing. If you leverage typed logic programming the right way it comes out okay.
06:20:08 <dons> all the mercury guys seems to be using haskell now (well, an awful lot of them)
06:20:26 <wli> qwr: Of course, I default to Haskell for the most part.
06:21:16 <wli> It's an exotic paradigm. It doesn't come in handy quite as often as FP.
06:25:12 <DRMacIver> Hm.
06:25:20 <DRMacIver> ?t join . Map.lookup
06:25:20 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
06:25:25 <DRMacIver> ?type join . Map.lookup
06:25:28 <lambdabot> Couldn't find qualified module.
06:25:32 <DRMacIver> ?type join . Data.Map.lookup
06:25:34 <lambdabot> forall a a1. (Ord a) => a -> Data.Map.Map a a1 -> a1
06:26:29 <DRMacIver> Hm. I still haven't gotten the hang of parsing ghc error messages.
06:26:46 <erider> good morning
06:26:59 <DRMacIver> Suppose I wanted a function which looked up from a Map a [b] and returned an empty list on the case where no key was found. What's the best way of doing this?
06:27:16 <Heffalump> lookupWithDefault ?
06:27:38 <DRMacIver> Oops. Missed that one. :)
06:27:40 * DRMacIver kicks self
06:27:55 <DRMacIver> (It appears to be findWithDefault for some reason)
06:28:45 <Heffalump> oh, well, nearly :-)
06:29:17 <Heffalump> there's also lookup (...) `mplus` return [] but you'd need a signature somewhere to pick a MonadPlus to use
06:31:33 <DRMacIver> Yeah, that's more or less what I was trying to make work. :)
06:31:43 <DRMacIver> (Although better than mine)
06:31:44 <DRMacIver> Thanks
06:44:35 <quicksilver> DRMacIver: or maybe [] (lookup .... )
06:44:46 <quicksilver> DRMacIver: which forces the monad to Maybe, which does what you need :)
06:44:59 <DRMacIver> Neat.
06:45:30 <quicksilver> although it forces you to make the rest of your function a continuation
06:45:38 <quicksilver> erm, no it doesn't
06:45:45 <quicksilver> :t maybe [] id
06:45:49 <lambdabot> forall a. Maybe [a] -> [a]
06:45:54 <quicksilver> yeah, that's what I meant ;)
06:46:02 <quicksilver> DRMacIver: or maybe [] id (lookup .... )
06:46:36 <dolio> or frommaybe [] (lookup ...)
06:46:36 <DRMacIver> I went with findWithDefault anyway. :)
06:46:50 <DRMacIver> Not everything requires really clever type system tricks. ;)
06:46:51 <dolio> With a capital M, though.
06:47:25 <quicksilver> @src findWithDefault
06:47:25 <lambdabot> Source not found. Wrong!  You cheating scum!
06:47:29 * quicksilver shrugs
06:47:29 <quicksilver> :)
06:47:54 <DRMacIver> @src Data.Map.findWithDefault
06:47:54 <lambdabot> Source not found. Just what do you think you're doing Dave?
06:48:00 <DRMacIver> Heh
06:54:22 <xpika_> has anyone written a monad for a "Natural Int" kind of data type?
06:54:56 <vincenz> xpika_: what would it contain?
06:56:48 <dons> xpika_: you mean, a type for NonNegative Int ?
06:57:24 <fasta> xpika_: a monad?
06:57:41 <fasta> Why would it be a monad?
06:57:53 <fasta> But yes, I wrote a data type PositiveNumber
06:58:08 <xpika__> cool
06:58:20 <dons> QC uses a wrapper type, newtype NonNegative a = NonNegative a
06:58:25 <xpika__> do you have it? :/
06:58:30 <roconnor> It seems more like a comonad :P
06:58:35 <dons> heh
06:58:53 <xpika__> id be interested in just some form of constraint monad
06:58:53 <fasta> xpika_: I don't use fancy type system numbers for positive numbers
06:59:06 <fasta> xpika_: I just use smart constructors.
06:59:16 <dons> xpika_: you sure you mean a monad, and not just a constrained data type?
06:59:20 <roconnor> counit : NonNegative a -> a
06:59:42 <fasta> roconnor: how do you recognize a comonad?
06:59:48 <xho> is there something like the nub function for a list of mutable values?
06:59:54 <dons> xpika_: http://haskell.org/haskellwiki/Smart_constructors#Compile-time_checking_:_the_type_system
06:59:55 <roconnor> cojoin : NonNegative a -> NonNegative (NonNegative a)
06:59:56 <lambdabot> Title: Smart constructors - HaskellWiki, http://tinyurl.com/jx22g
07:00:21 <roconnor> fasta: I see reasonable functions for counit and cojoin
07:00:22 <dons> xho, you'd have to mapM nub`fmap`read ?
07:00:44 <fasta> roconnor: I am saying this out of ignorance.
07:00:47 <roconnor> fasta: I suppose the map function is a bit more problematic.
07:01:32 <roconnor> fasta: Well you just look for three reasonable functions of for map counit and cobind
07:01:39 <xho> dons: but what if i can't convert the mutable value into an immutable value? i can only directly compare equality with a function cmp :: MutableVal -> MutableVal -> IO Bool
07:01:40 <roconnor> then hopefully they fit together properly
07:04:20 <fasta> roconnor: what's the canonical type for cobind?
07:04:34 <dons> compare via Ptr equality or something, xho?
07:04:45 <dons> what's the notion of equality on these types?
07:04:58 <roconnor> fasta: let's see, map is of type (a -> b) -> T a -> Tb
07:05:11 <roconnor> fasta: and cojoin has type T a -> T (T a)
07:05:19 <roconnor> fasta: so putting them together yeilds
07:05:53 <roconnor> hmm
07:05:58 <wli> Oh dear I had a hard enough time with regular monads.
07:06:06 <wli> Wcomonads...
07:06:15 <DRMacIver> Regular monads are easy.
07:06:21 <DRMacIver> Presumably that means comonads are co-easy...
07:06:35 <fasta> The more you learn the more you want.
07:06:47 <fasta> Delimited continuations being one example
07:06:53 <scook0> DRMacIver: "Regular monads are easy." <-- isn't that what makes them so hard? ;)
07:07:20 * DRMacIver makes baffled faces at scook0 
07:07:41 <dons> ?remember DRMacIver Regular monads are easy.
07:07:41 <lambdabot> Done.
07:07:42 <roconnor> fasta:  ah yes, so map is also of type (T a -> T b) -> (T (T a)) -> (T (T b))
07:07:45 <vincenz> fasta: delimited continuations are like sliced bread
07:07:51 <roconnor> (maybe I should use W)
07:08:25 <DRMacIver> vincenz: Cheap, usually inferior, and go stale more quickly than unsliced bread?
07:08:38 <roconnor> fasta: so using cojoin before the second argument gives cobind :: (T a -> T b) -> T a -> (T (T b)) ... wait that's not right.
07:09:13 <fasta> roconnor: put it on the wiki :)
07:09:18 <scook0> DRMacIver: what I mean is that monads are pretty "simple", but are still hard to get your head around -- especially if you're not used to dealing with such abstract structures
07:09:23 <vincenz> DRMacIver: No, as convenient and with two sides.
07:09:26 <scook0> if that makes any sense at all :/
07:09:29 <roconnor> okay map gives (T a -> b) -> T (T a) -> T b
07:09:31 <DRMacIver> scook0: Ah.
07:09:52 <vincenz> Anyone know a comonad besides the strean one?
07:09:56 * vincenz is still trying to grok them
07:10:01 <vincenz> s/strean/stream
07:10:06 <roconnor> fasta: and putting cojoin before the second arguments gives cobind : (T a -> b) -> T a -> Tb
07:10:09 <roconnor> that sounds right
07:10:19 * DRMacIver has decided not to worry about comonads until he needs them. :)
07:10:26 <roconnor> cobind f x = (map f) . cojoin
07:10:38 <dolio> There's a reader comonad. ((,) e) or something like that.
07:10:48 <roconnor> some people flip the arguments of cobind and bind.
07:11:26 <roconnor> er
07:11:32 <roconnor> cobind f = (map f) . cojoin
07:11:34 <wli> What's the over-arching concept of a comonad?
07:12:00 <vincenz> DRMacIver: how will you know when you need them if you don't know what they are?
07:12:11 <Heffalump> I still don't understand what they are good for.
07:12:20 <roconnor> wli: I think they labeled structures.
07:12:34 <vincenz> Heffalump: me neither :/
07:12:42 <xpika__> is it possible to write a tuple folder using Data.Dynamic?
07:12:54 <vincenz> And I don't get the other typical example, namely contexts..
07:12:55 <apfelmus> int-e: ping
07:12:58 <DRMacIver> vincenz: Because I will come to a problem I don't have a good solution for, think "Hmm. I don't have a good solution for this problem. Why don't I find out how other people have solved it?". At this point I will discover that other people have solved it using comonads and act accordingly.
07:13:03 <dons> xpika__: ?
07:13:09 <dons> ah i see. a fold over tuples?
07:13:27 <xpika__> foldtuple (+) (1,(2,3))
07:13:49 <vincenz> DRMacIver: Heh, I had a similar argument the other day with someone.
07:13:51 <Heffalump> I don't know of any good solutions to interesting problems that use comonads
07:14:15 <dons> xpika__: so fold over a tree, really.
07:14:34 <xpika__> tuples pattern match well
07:14:40 <DRMacIver> vincenz: I'm not saying "There's no reason for me to learn comonads" or anything silly like that. :) But currently my time would be far better served just writing Haskell code than reading yet more abstract Haskell related theory.
07:14:47 <xpika__> thats the main reason
07:15:00 <DRMacIver> So I'm trying to make my haskell related learning more utility driven.
07:15:37 <dons> xpika__: probably more useful to either use a data type for trees, and write a fold over that, or uses lists. you keep the pattern matching, and the types will make more sense
07:15:39 <DRMacIver> xpika__: Eh? Most Haskell datatypes pattern match well.
07:16:31 <xho> dons: i already have such a function (cmp :: MutableVal -> MutableVal -> IO Bool) defined
07:16:42 <xpika__> fun (_: a@( (12,_):(11,_):(10,_):(9,_):(8,_) ) :_) = a
07:16:52 <int-e> apfelmus: pong
07:17:20 <apfelmus> int-e: hi :) i wonder whether there is a lower bound for the time complexity of adding rational numbers
07:17:30 <apfelmus> but representation independent
07:17:59 <int-e> apfelmus: data Add x = Add x x - O(1)
07:18:14 <SamB_XP> how about... an upper bound for the time complexity of adding roman numerals?
07:18:32 <apfelmus> so: for any representation of rational numbers, summation a+b takes at least f(bits(a),bits(b)) bits
07:19:13 <SamB_XP> apfelmus: I think you won't find one like that
07:19:30 <SamB_XP> > 1/2616 + (-1/2616)
07:19:33 <lambdabot>  0.0
07:19:38 <SamB_XP> hmm, wrong type
07:19:43 <SamB_XP> > 1/2616 + (-1/2616) :: Rational
07:19:44 <lambdabot>  0%1
07:20:01 <apfelmus__> sorry, got disconnected
07:20:14 <SamB_XP> <SamB_XP> apfelmus: I think you won't find one like that
07:20:16 <SamB_XP> > 1/2616 + (-1/2616) :: Rational
07:20:18 <lambdabot>  0%1
07:21:18 <apfelmus> hm, then on average
07:21:46 <apfelmus> or rather a lower upper bound
07:22:12 <apfelmus> i.e. there exists at least one pair a,b where a+b takes f(bits(a),bits(b)) bits
07:22:53 <apfelmus> and we seek to minimize over all f the maximum of f over all pairs
07:23:13 <int-e> apfelmus: you can cheat by choosing a representation that just encodes additions. so ... what other operations do you want to throw into the mix?
07:23:28 <DRMacIver> int-e: Perhaps a reasonable restriction is that structural and the normal rational equality need to coincide?
07:23:42 <DRMacIver> int-e: Which basically forces you to reduce to some 'canonical' form if you want to apply that cheat. :)
07:23:56 <int-e> DRMacIver: hmm. too strong. I'd rather throw equality tests into the mix of operations.
07:24:09 <DRMacIver> ok
07:24:09 <apfelmus> int-e: yes, without observation, the question is void. Let's try an additional (==0) check then
07:24:44 <apfelmus> or better a < 0 test
07:24:54 <SamB_XP> apfelmus: so do you want a time constraint for that test?
07:25:49 <apfelmus> though i prefer a uniqueness property. that could be too limiting, though
07:25:57 <apfelmus> SamB_XP: yes
07:26:23 <apfelmus> a rough time constraint for the observer operation is bits(a)
07:26:40 <apfelmus> the number of bits the representation uses for the number a
07:27:19 <apfelmus> i mean, we have the following: standard integer summation uses max(bits(a),bits(b))+1 bits for the result
07:27:38 <Socrates`> let penta x = foldr1 (+) [1,4..] in penta 23423424
07:27:49 <apfelmus> but standard summation of rationals uses bits(a)+bits(b) bits for the result in the worst case
07:28:00 <Socrates`> > let penta x = foldr1 (+) [1,4..] in penta 23423424
07:28:01 <apfelmus> that's why the addition of rational numbers is "slow"
07:28:02 <lambdabot>  Exception: stack overflow
07:28:22 <apfelmus> > let penta x = foldl1' (+) [1,4..] in penta 23423424
07:28:29 <lambdabot> Terminated
07:28:30 <roconnor> apfelmus: presumably the call to GCD after each sum.
07:28:36 <Socrates`> Hmm, my GHC crashes when I get a stack overflow on that for some reason
07:29:01 <Socrates`> Or rather, it just shuts down =/
07:29:08 <apfelmus> Socrates`: no wonder, you are summing an infinite series
07:29:19 <apfelmus> penta 5 = penta 3 = infinity
07:29:36 <Socrates`> I'm aware I'm trying to sum an infinite series
07:29:46 <Socrates`> But shouldn't it just give a Stack Overflow error?
07:30:20 <olsner> foldl' is strict, i.e. a simple iteration over the list keeping a running sum
07:30:38 <int-e> apfelmus: I doubt you'll find a much better than O(n) (where all numerators and denominators are n bit numbers) lower bound; http://www.lysator.liu.se/~nisse/archive/sgcd.pdf describes a gcd algorithm that takes O(n(log n)^2 log(log(n))) time if implemented with FFT multiplication
07:30:50 <roconnor> foldl' is strict and tail-recursive, no stack is consumed.
07:31:03 <Socrates`> That's not what I'm interested in tho'...
07:31:24 <Socrates`> I was wondering why GHC completely crashes, instead of giving a Stack Overflow error
07:31:48 <Socrates`> I'm aware that it's an infinite list, I'm not interested in the actual result
07:31:57 <roconnor> Socrates`: I guess it ought to give some sort of out of heap error.
07:32:23 <dons> Socrates`: what's the example program?
07:32:32 <roconnor> @paste
07:32:32 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:33:05 <vincenz> :t foldr
07:33:07 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
07:34:22 <apfelmus> int-e: well, it can't be better than O(n) :)
07:34:33 <apfelmus> i mean, we most surely have to inspect every bit
07:34:36 <Socrates`> let penta x = (scanl1 (+) [1,4..]) !! x in penta 2
07:34:46 <Socrates`> > let penta x = (scanl1 (+) [1,4..]) !! x in penta 2
07:34:49 <lambdabot>  12
07:34:56 <Socrates`> > let penta x = (scanl1 (+) [1,4..]) !! x in penta 5463453543453
07:35:01 <vincenz> :t foldl
07:35:03 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
07:35:06 <lambdabot> Terminated
07:35:13 <vincenz> :t foldl'
07:35:15 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
07:35:46 <int-e> apfelmus: yes. the comparison should enforce that lower bound.
07:36:34 <apfelmus> int-e: yeah, so the observer/comparison is just for forcing all the bits
07:37:54 <apfelmus> int-e: it appears that the nominator/denominator must deliver a result of ~ bits(a)+bits(b) bits in the worst case for the denominator is a*b ~ bits(a)+bits(b), and the gcd can't beat that
07:38:42 <vincenz> Anyone know how to time an operation?
07:38:57 <apfelmus> but the question is whether there could exist a crazy representation of rational numbers that beats the bits(a+b) = bits(a) + bits(b) bound
07:39:29 <apfelmus> vincenz: time m = liftM2 subtract getCPUTime (m >> getCPUTime)
07:39:56 <vincenz> apfelmus: thx
07:40:09 <apfelmus> i mean, for standard integers, we have bits(a+b) ~ max(bits(a),bits(b))
07:41:03 * SamB wonders how you can be sure that a spoiler-spacer is large enough
07:41:41 <Alleria_2> Idle question: why does head [] raise an error rather than return []?
07:41:59 <Alleria_2> err, Nothing?
07:42:18 <EvilTerran> @source head
07:42:18 <lambdabot> head not available
07:42:20 <EvilTerran> @src head
07:42:21 <lambdabot> head (x:_) = x
07:42:21 <lambdabot> head []    = undefined
07:42:30 <norpan> because head does not have Maybe a as return type
07:42:41 <EvilTerran> um. okay, that doesn't help. listen to norpan.
07:42:42 <scook0> :t listToMaybe
07:42:51 <lambdabot> forall a. [a] -> Maybe a
07:42:55 <EvilTerran> @src listToMaybe
07:42:55 <lambdabot> listToMaybe []        =  Nothing
07:42:55 <lambdabot> listToMaybe (a:_)     =  Just a
07:43:16 <DRMacIver> Alleria_2: It's deliberately unsafe, mainly useful in cases where you 'know' the list is non-empty.
07:43:19 <scook0> there's your "total head"
07:43:52 <Alleria_2> So listToMybe is the safe version of head
07:43:54 <Alleria_2> cool, thank you.
07:43:58 <DRMacIver> > map head . group . sort ["foo", "bar", "baz", "foo"]
07:43:59 <lambdabot>  Couldn't match expected type `a -> [a1]'
07:44:03 <DRMacIver> Bah
07:44:25 <DRMacIver> > map head $ group $ sort ["foo", "bar", "baz", "foo"]
07:44:27 <lambdabot>  ["bar","baz","foo"]
07:45:37 <vincenz> > map head . group . sort $ ["foo", "bar", "baz", "foo"]
07:45:39 <lambdabot>  ["bar","baz","foo"]
07:45:50 <DRMacIver> Yeah, I realised the correction. :)
07:46:00 <DRMacIver> But it was easier to just replace the .s with $s.
07:46:46 <Alleria> Heh. One day I will understand when I'm supposed to compose functions and when I'm supposed to apply them.
07:46:58 <DRMacIver> Whenever you feel like it really. :)
07:47:09 <DRMacIver> I use composition a lot because I seem to default to writing things in pointfree style.
07:47:32 <DRMacIver> (And then I forget that I can't do that and apply them in the obvious way because of precedence. See above for example.)
07:47:51 <scook0> just futz around until the typechecker stops complaining, and it's probably correct :P
07:48:06 <Alleria> scook0: that's what I do, heh.
07:49:00 <Socrates> In a statement (x || y) is y still checked if x returns True?
07:49:14 <scook0> nope
07:49:18 <Socrates> Thanks
07:49:20 <EvilTerran> @src (||)
07:49:20 <lambdabot> True  || _ =  True
07:49:20 <lambdabot> False || x =  x
07:49:22 <scook0> since (||) is non-strict
07:49:55 <EvilTerran> the source is a wonderful thing :]
07:50:06 <zbrown> Anyone know of a general functional programming language channel
07:50:07 <zbrown> ?
07:50:11 <apfelmus> int-e: one way to find something out would be a bit-counting argument in the following style:
07:50:11 <apfelmus> consider all integers a,b `in` [1..1024]. In any representation, most of the a and b have to use ~10 bits (or we couldn't represent so many). Now, there are 2048 distinct sums a+b and we only need 11 bits to cover that range. So, this hints to the existence of a systematic representation of sums that uses a low number of bits
07:50:20 <DRMacIver> scook0: I'm a big fan of that style of programming. :)
07:50:39 <DRMacIver> Although the incomprehensible GHC error messages tend to get aggravating.
07:51:00 <scook0> we need some kind of Djinn-style tool that will automatically glue terms together
07:51:06 <scook0> (assuming it doesn't already exist)
07:51:11 <EvilTerran> @dwim?
07:51:11 <lambdabot> Unknown command, try @list
07:51:18 <Alleria> haha
07:51:56 <EvilTerran> (mucks about with precedence and/or replacing application with composition until the expression typechecks)
07:52:23 <scook0> e.g. you give it "m (a -> b)" and "m a" and it says "use ap, dummy!", etc.
07:52:26 <Alleria> I usually just give up and break out the parens
07:52:28 <vincenz> apfelmus: it's called the msb
07:52:41 <EvilTerran> @hoogle m(a -> b) -> m a
07:52:42 <lambdabot> Prelude.id :: a -> a
07:52:42 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
07:52:42 <lambdabot> Prelude.asTypeOf :: a -> a -> a
07:52:50 <EvilTerran> um.
07:52:52 <apfelmus> vincenz: huh? msb?
07:53:01 <DRMacIver> Meh. I *like* parentheses. :)
07:53:03 <vincenz> apfelmus: use the msb :)
07:53:11 <vincenz> most significant bit
07:53:22 <DRMacIver> Sometimes $ is nicer, but more often some well placed parentheses improve code readability a lot.
07:53:39 <apfelmus> vincenz: ah. but what do you mean? :)
07:54:05 <vincenz> apfelmus: for doing a+b
07:54:11 <vincenz> 0a or 1b
07:54:38 <apfelmus> vincenz: ? adding integers is fine, i want a lower bound for adding rationals
07:54:53 <vincenz> oh
07:55:55 <wli> apfelmus: Lower bound on what?
07:56:24 <apfelmus> wli: adding rationals. given to rational numbers in a super-clever representation, how long does it take to add them?
07:56:48 <EvilTerran> lower bound on... bits needed?
07:57:12 <apfelmus> yeah, the bits needed are a good approximation to that
07:57:47 <apfelmus> so, is there a super-clever representation where a+b has few bits if a and b have few bits?
07:58:58 <EvilTerran> ...of rationals, this is?
07:59:02 <chessguy_brb> @bot
07:59:02 <lambdabot> :)
07:59:04 <vincenz> apfelmus: it's just 1+max(a,b)
07:59:10 <apfelmus> EvilTerran: yes
07:59:12 <EvilTerran> hm.
07:59:27 <apfelmus> vincenz: well, that lower bound is easy to guess :) But is it sharp?
07:59:51 <vincenz> apfelmus: Hmm, I think I must be missing something, because it seems too straightforward for me
07:59:51 <apfelmus> or is the sharp lower bound actually bits(a)+bits(b)?
07:59:53 <DRMacIver> Won't 1/n + 1/(n + 1) always need twice as many bits as finding 1/n? (approximately)
08:00:07 <vincenz> apfelmus: it's 1+max(bits(a), bits(b))
08:00:25 <vincenz> wait, a+b = sumtype?
08:00:30 <vincenz> Maybe that's my confusion
08:00:33 * SamB wonders why GHC doesn't seem to save .hi files for -boot modules
08:00:46 <apfelmus> vincenz: ? a+b :: CleverRational
08:00:56 <vincenz> apfelmus: so the + is the algebraic +, not the sumtype +?
08:01:05 <apfelmus> vincenz: yes :)
08:01:09 <vincenz> ah, hence my confusion :)
08:02:14 <apfelmus> DRMacIver: why should that be? we could have an extra constructor for 1/n + 1/(n+1)
08:02:22 <apfelmus> using bits(n)+1 bits
08:05:09 <wli> apfelmus: The elements of the finite continued fraction are "often" very small.
08:06:20 <DRMacIver> apfelmus: Hm. I suppose that's true. What I had in mind is that it encodes a number of size 2n, so that information has to be stored 'somewhere'. But I guess that doesn't really work.
08:06:37 <DRMacIver> apfelmus: I wonder if there's some sort of argument you can make based on the fact that your representation can make only finitely many such tricks.
08:07:49 <apfelmus> DRMacIver: yeah, that's the big question :)
08:08:32 <apfelmus> wli: hm, difficult to count bit sized, though
08:08:37 <apfelmus> *bit sizes
08:11:29 <wli> apfelmus: It's not deterministic, either.
08:12:15 <wli> Give me a fraction with huge numerator and denominator.
08:13:04 <apfelmus> > (sum $ map (1/) [1..20]) :: Rational
08:13:12 <lambdabot>  55835135%15519504
08:13:38 <wli> let { f :: Rational -> [Integer] ; f x = let n = floor x in if x == 0 then [] else n : if x /= fromIntegral n then f (recip (x - fromIntegral n)) else [] } in f $ sum $ map recip [1..20]
08:13:38 <wli> [3,1,1,2,17,3,2,1,2,9,1,6,7,2,2,2]
08:14:39 <wli> See what I mean?
08:15:07 <apfelmus> yeah. but the bit count is around the number of summands
08:15:32 <apfelmus> which would be good
08:17:16 <apfelmus> but that's already true for the nom/denom representation
08:17:40 <wli> apfelmus: ceiling (log 55835135 / log 2) + ceiling (log 15519504 / log 2) == 50
08:17:51 <wli> apfelmus: sum [ceiling $ (log (fromIntegral n))/log 2 | n <- f $ sum $ map recip [1..20]] == 25
08:17:59 <apfelmus> ah!
08:18:36 <wli> apfelmus: Has the bit count appraisal changed any?
08:18:39 <apfelmus> the continued fraction of 1/n is 1/n, right?
08:19:06 <wli> apfelmus: Yes, you should be able to tell from the definition of f.
08:19:43 <opqdonut> apfelmus: yeah, it is
08:19:49 <apfelmus> ok:)
08:20:11 <apfelmus> hm, 25 is still a bit much then
08:20:13 <wli> apfelmus: f x = let n = floor x in if x == 0 then [] else n : if x /= fromIntegral n then f (recip (x - fromIntegral n)) else []
08:20:23 <apfelmus> since we add 20 1-bit numbers
08:20:29 <opqdonut> cont. fracs are of the form a0+b0/(a1+b1/(a2+...))
08:20:43 <opqdonut> for 1/n you use a0=0, b0=1, a1=n, b1=0
08:21:02 <wli> opqdonut: Vastly more restrictive for the number-theoretic representations.
08:21:32 <wli> opqdonut: There it's a_0 + 1/(a_1 + 1/(a_2 + 1/(... where the a_k are all positive integers.
08:21:32 <opqdonut> oh?
08:21:34 <sorear> (hello)
08:21:35 <lambdabot> sorear: You have 1 new message. '/msg lambdabot @messages' to read it.
08:21:39 <apfelmus> hm, i got to think about that
08:21:39 <sorear> @users
08:21:40 <lambdabot> Maximum users seen in #haskell: 354, currently: 312 (88.1%), active: 15 (4.8%)
08:21:52 <opqdonut> wli: yeah, integers of course
08:22:21 <apfelmus> but i gotta get something to eat now :)
08:23:17 * apfelmus `lookup` food >>= munchmunch
08:26:35 <olsner> > let x = x x in x
08:26:37 <lambdabot>      Occurs check: cannot construct the infinite type: t = t -> t
08:26:37 <lambdabot>     Probabl...
08:26:55 <olsner> bah, coward
08:27:10 <olsner> prolog needs no occurs check!
08:28:08 <sorear> # let rec x = x x in x ;;
08:28:08 <sorear> This kind of expression is not allowed as right-hand side of `let rec'
08:28:09 <sorear> aww
08:29:51 <olsner> @pl let x = x x in x
08:29:51 <lambdabot> fix (join id)
08:30:01 <olsner> :t join id
08:30:03 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a1
08:30:03 <lambdabot>     Probable cause: `id' is applied to too many arguments
08:31:06 <sorear> community.h.o's indices are woefully lacking
08:31:21 <sorear> I'm having to try urls at random
08:32:11 <DRMacIver> Try repeatedly clicking "Random page" :)
08:32:43 <sorear> there is none
08:33:09 <Igloo> What are you trying to do?
08:33:16 <sorear> Find out what's there.
08:33:26 <DRMacIver> What site are we talking about then? Given that community.haskell.org just says "It works!" I assumed you meant the wiki. :)
08:33:27 <sorear> Are the services intended to be secret?
08:33:54 <Igloo> No, it's just that no-one's written a front page yet
08:34:23 * sorear tries ftp to get a list of pages
08:34:34 <SamB> Igloo: so why isn't there a directory listing?
08:34:51 <Igloo> http://community.haskell.org/admin/ is the application forms
08:34:52 <lambdabot> Title: Haskell Community Server
08:35:44 <sorear> I found that one already.
08:36:24 <Igloo> Then I'm not sure what you're looking for
08:36:42 <sorear> But there are a lot of things it doesn't tell you... for instance, where are the darcs repos?
08:36:53 <Igloo> code.haskell.org
08:37:14 <SamB> ... okay ...
08:37:39 <sorear> I'd like to know what is available on community.haskell.org.   /admin/, /~dons/, /~igloo/ - what else?
08:38:23 <Igloo> Nothing, I don't think
08:40:41 <Igloo> But if you think something is missing, let us know!
08:43:14 <sorear> Igloo: discoverability
08:43:59 <Igloo> Yeah, I know more web pages need to be written
08:44:26 <SamB> how about some automation
08:44:34 <Igloo> for what?
08:44:44 <SamB> listing home directories
08:45:13 <SamB> er, or whatever you call those ~name/ urls
08:48:22 <sorear> for x in /home/*/public_html; do echo $x; done | sed 's|/home/|/~|; s|/.*|/|' | ...
08:48:28 <ndm> @seen Igloo
08:48:29 <lambdabot> Igloo is in #haskell-icfp07, #haskell-soc, #haskell, #ghc and #darcs. I last heard Igloo speak 3m 55s ago.
08:48:33 <Igloo> Hi ndm
08:48:48 <ndm> hi Igloo,  none of the drive functions are exported because people said they shouldn't be...
08:49:15 <ndm> we can either export the drive functions, or add your normaliseDirectory function in
08:49:17 <Igloo> ndm: Yeah, but I still don't understand  :-)
08:49:31 <ndm> Igloo, i didn't understand half the people who gave comments on the filepath library
08:51:39 <Igloo> I don't hugely mind what is done, anyway, as long as doesDirectoryExist is fixed
08:52:01 * Igloo wonders when this was discussed
08:52:03 <ndm> i don't mind either, but i suspect fixing doesDirectoryExist is your problem :)
08:52:20 <Igloo> Yes, but fixing it needs a change in filepath
08:52:47 <sorear> There should be a limit on ten replies per new library. :)
08:52:50 <ndm> you could do isAbsolute and length (splitDirectories x) == 1
08:53:03 <ndm> i think that would just about work
08:54:20 <Igloo> It's not particularly pleasant, though   :-)
08:54:30 <ndm> i'm not sure any of the options are pleasant
08:54:39 <ndm> apart from possibly exporting all of drive
08:54:45 <ndm> everything else has a very hacky feeling
08:54:55 * Igloo is trying to find the discussion about that
08:55:48 <zbrown> I knot this isn't #scala, but #scala is less than... active but does anyone have some experience with the language and would like to entertain my questions?
08:57:21 <ndm> Igloo, RE: ANN: System.FilePath 0.9 , Brian Smith
08:57:28 <opqdonut> isn't scala the "java done right" language?
08:57:43 <jfredett> all I know is that its named after bread.
08:58:02 <zbrown> opqdonut: Umm I guess, its a multi-paradigm language thats compat with .NET's CLR and the Java JVM
08:58:05 <wli> It's hard to do something right when its entire concept is wrong.
08:58:25 <ndm> Igloo, http://groups.google.com/group/fa.haskell/browse_thread/thread/a014f3eab6df8afb/e59181302f995085?lnk=st&q=I+kind+of+expect+that+a+Haskell+library+for+file+paths+will+use+the+&rnum=1&hl=en#e59181302f995085
08:58:27 <lambdabot> Title: ANN: System.FilePath 0.9 - fa.haskell | Google Groups, http://tinyurl.com/2x238r
08:58:44 <jfredett> all concepts are wrong, wli, some are just less wrong than others
08:58:46 <wolverian> no, it's not "java done right". it does happen to interoperate with java, but its design doesn't take anything from it.
08:59:06 <wolverian> (mind you, this interoperation does bring its downsides. I don't know enough about those to comment on them, though. see google.)
08:59:39 <jfredett> mixins! yuck.
08:59:53 <zbrown> Basically the down side is its limited by whatever the CLR or JVM limits
08:59:59 <jfredett> zbrown: is you problem conceptual, or related to the language itself?
09:00:04 <jfredett> concepts we can probably handle
09:00:11 <jfredett> the language stuff- likely n ot
09:00:40 <zbrown> jfredett: well its language related, my main problem is I can't figure out when its appropriate to use semi-colons lol, as stupid as that sounds.
09:00:49 <jfredett> hmm
09:01:33 <jfredett> see- i always learn that implicitly, i just try to compile code and season w/ ;'s to thecompilers taste
09:01:57 <jfredett> it looks pythonesque though, so probably only when putting multiple statements on the same line.
09:02:15 <zbrown> jfredett: thats what I'm assuming
09:02:24 <jfredett> looks like an interesting language, modulo the mixins, maybe i should learn it. After haskell and javascript, anyway
09:02:30 <zbrown> jfredett: I haven't had that come up as a real serious issue I was just curious if anyone knew
09:02:45 <bartw> javascript can be intresting
09:02:55 <jfredett> bartw: thats what i'm finding
09:03:08 <bartw> the incredible simplicity and power of the core language is great
09:03:34 <bartw> but completely compensated when you actually try to use it
09:03:52 <jfredett> all i knowi is that its capable of lambas and closure. and i dont think theres any other language that can do that-
09:04:05 <jfredett> which means most of my programming style should translate easily
09:04:06 <sorear> > \x -> 2
09:04:08 <lambdabot>  Add a type signature
09:04:09 <bartw> except all the other languages that support lambdas and closures
09:04:10 <sorear> > \x -> x
09:04:11 <lambdabot>  Add a type signature
09:04:18 <sorear> > \'a' -> 'b'
09:04:20 <lambdabot>  <Char -> Char>
09:04:30 <sorear> see!  Haskell has lambdas!
09:04:32 <Igloo> ndm: Hmm, I still think they should be exported
09:04:35 <jfredett> > (\ a -> 1+1)
09:04:37 <lambdabot>  Add a type signature
09:04:46 <jfredett> hmm, thats odd...
09:04:52 <ndm> Igloo, propose it on the libraries mailing list, its easy enough to do
09:04:57 <sorear> it has to be a monotype
09:05:00 <sorear> @type \a -> 1+1
09:05:03 <lambdabot> forall t t1. (Num t1) => t -> t1
09:05:25 <bartw> even c#3 supports forms of lambdas and closures, just in an ugly manner and limitted
09:05:30 <jfredett> sorear: thats not why I'm learning haskell, though- I'm learning haskell because of data
09:05:45 <opqdonut> > (\'a' -> 'b') 'c'
09:05:47 <lambdabot>   Non-exhaustive patterns in lambda
09:05:47 <jfredett> the keyword, though i guess equally the think.
09:05:49 <opqdonut> :)
09:05:59 <Igloo> ndm: Bah, I can't talk you, as maintainer, into doing so?  :-)
09:06:30 <ndm> Igloo, i tried once and got shot down...
09:06:46 <ndm> Igloo, you may have more success with "Cabal doesn't work, and absolutely must have these functions"
09:07:15 <SamB> ndm: you listen to other people a bit much, methinks...
09:07:46 <SamB> of course, don't listen to me unless you think it's a good idea ;-)
09:09:46 <jfredett> ... it just occured to me why everything looks all blurry, i forgot to grab my classes.
09:09:54 <SamB> glasses?
09:09:59 <jfredett> yeh,
09:10:04 <jfredett> like i said, i cant see
09:10:06 <jfredett> brb.
09:10:12 <SamB> I always forget to grab my glasses
09:10:34 <SamB> possibly because I'm nearsighted and I don't need them too often
09:10:51 <arjanoosting>  
09:11:15 * jfredett is nearsighted in one eye. farsighted in the other, and i have an astigmatism in both.
09:12:17 * jfredett 's vision is seriously fucked up.
09:12:18 <SamB> arjanoosting: I don't think I'll see that with *or* without my glasses
09:14:44 <bartw> unicode zerowidhth whitespace char ?
09:16:50 <sorear> ndm: What is Yhc.Core.Type.CoreLam for?
09:17:08 <sorear> I was always told Yhc.Core was lambda-free
09:17:33 <ndm> sorear, Lambda's, Yhc.Core as generated by Yhc is lambda free, but some optimisers/transformation stuff may want them in at some point
09:17:55 <ndm> sorear, coreInvariant [NoCoreLam] will remove them again (lambda lifting), if you want them gone
09:18:42 <sorear> your Source Code links are broken
09:18:53 <sorear> http://www.cs.york.ac.uk/fp/yhc/snapshot/docs/Yhc-Core-Invariant.html <- here I mean
09:18:57 <lambdabot> http://tinyurl.com/35tcbe
09:19:11 <ndm> sorear, yes, we moved the repo ages ago and haven
09:19:17 <ndm> 't fixed the links back up
09:19:21 <sjanssen> @yow
09:19:21 <lambdabot> DIDI ... is that a MARTIAN name, or, are we in ISRAEL?
09:20:12 <SamB> ndm: you couldn't just regenerate the documentation?
09:20:20 <ndm> sorear, the new Haskell build scripts put out properly coloured source code etc, but the docs still come from the old oen
09:20:34 <ndm> SamB, we do, every single commit - we just haven't fixed the build scripts
09:21:50 <ndm> patches welcome :)
09:22:40 <sorear> fun string literal of the day: "Yhc.Core.ensureInvariants: BRAIN EXPLODED! "
09:22:52 <ndm> hmm, where does that happen?
09:23:17 <ndm> i added that in because i saw a GHC bug fix going accross to remove that message from GHC, so I thought I'd better put it back in Yhc
09:23:38 <olsner> brain explosions seem to be a common side effect of using haskell
09:24:04 <ndm> Yhc.Core.Invariant is a very cool module
09:24:18 <SamB> ndm: so you are saying that you haven't changed the haddock line in the build scripts?
09:24:24 <ndm> SamB, yes
09:24:29 <SamB> insert an "is" ;-)
09:24:50 <sorear> ndm: that happens if enforcing an envariant doesn't cause it to be satisfied
09:25:13 <SamB> what?
09:25:13 <ndm> sorear, ah yes - i want to prove that property so hopefully the brain exploded message will never occur
09:25:22 <SamB> they removed the "brain exploded" from GHC?
09:25:31 <sorear> what's the difference between FreeVar, FreeVar2, and FreeVar3?
09:25:32 <SamB> ... why didn't they just fix the bug instead?
09:26:03 <ndm> sorear, different approaches, FreeVar3 is the newest one, I am trying to find the perfect interface so those are the various attempts, in order
09:26:10 <sorear> ah.
09:26:16 <ndm> sorear, once i've figured out the perfect approach that will just become FreeVar
09:26:57 <SamB> you should probably remove FreeVar before that ;-)
09:27:25 <ndm> I was going to make it Yhc.Core.Old.FreeVar, so people can keep compatibility with an import change
09:27:32 <SamB> or that
09:28:08 <SamB> but, at some point a bit sooner than when you are wanting to change FreeVarN to being FreeVar
09:28:25 <ndm> maybe, maybe not :)
09:28:37 <SamB> I already said my "probably"
09:30:28 <vincenz> Anyone from greece here?
09:30:44 <sm> morning all
09:30:53 <sm> why does the type signature in http://paste.lisp.org/display/44103 give an error ?
09:31:16 * SamB is trying to figure out how his functions are getting "f"s in front of them in the conversion to Grin...
09:32:12 <sm> oh.. I see, I think
09:34:25 <ndm> @seen dons
09:34:25 <lambdabot> dons is in #haskell-icfp07, #ghc, #xmonad and #haskell. I last heard dons speak 2h 2m 2s ago.
09:35:09 <sm> how about http://paste.lisp.org/display/44103#1 ?
09:35:41 * sm gets that doomed arguing-with-ghc feeling
09:35:50 <ndm> sm, do you mean -> b at the very end?
09:35:54 <sorear> We've already found and tested a fix for hpaste... why isn't the kakapo instance updated?
09:36:14 <ndm> "f" produces a "b", you apply "f" at the end but there is no "b" at the end
09:37:41 <sm> hmm
09:37:54 <sm> ndm, on which line ?
09:37:59 <sorear> ndm: would it Make Sense for the qhc desugarer to produce core with CoreLams, then invoke ensureInvariant NoCoreLam in the bytecode converter?
09:38:01 <DRMacIver> sm: In your type declaration
09:38:30 <DRMacIver> sm: I find a good way of debugging such errors is to comment out the type declaration, see if that makes it compile and if so use ghci to figure out what it thinks the type should be. :)
09:38:49 <ndm> sorear, yep, that is the intention
09:38:53 <wli> break it up into smaller functions
09:38:57 <DRMacIver> (This is usually much clearer than ghc's confusing error messages in my opinion)
09:39:22 <sorear> ndm: hmm, thought.  the ensure* functions are really just views
09:39:27 <ndm> or use Hugs, which generally has much more terse and readable type error messages
09:39:35 <DRMacIver> There is that. :)
09:39:37 <ndm> sorear, views?
09:39:45 <sm> thanks, I'll try those
09:39:49 <ndm> as in the Wadler views? i don't see how
09:39:53 <sorear> ndm: yeah.
09:40:13 <ndm> aren't views for viewing some data in a particular way
09:40:13 <sm> I'm still thinking because I just tried the first suggestion and it's still not happy
09:40:27 <sorear> ndm: you have a data type (Core), and you use the ensuring functions to pattern match on a subset
09:40:51 <sm> hugs can't find Data.Ord :/
09:40:57 <ndm> sorear, i guess in that way, they are, but i still wouldn't call them views - some are
09:41:11 <sorear> ndm: yeah.  you can view a abstract program in many ways - expressed using lambdas, expressed using toplevel functions, expressed without repeated variables
09:41:15 <ndm> things like NoCorePos are more directly view style opeartions
09:41:24 <ndm> true
09:41:40 <ndm> bear in mind that not all of those invariants are implemented, i'm implementing them lazily as i need them
09:42:08 <ndm> i think the hardest ones are all done, though
09:43:11 <sm> removing the type is good to remember! ghc tells me it's supplyWildcards :: ([String], [String]) -> (([String], [String]) -> t) -> t
09:43:58 <sm> I see, I see.. thanks ndm, DRMacIver
09:44:29 <SamB> hmm, GHCi's recompilation checking sux :-(
09:45:10 <ndm> report a bug
09:46:20 <ndm> sorear, oh, i understood transplate, its cool - the trick of having a data type keep its own data type as an argument
09:53:34 <desp> @hoogle Monad m => Map k v -> (k -> v -> m r) -> m ()
09:53:35 <lambdabot> No matches, try a more general search
09:54:02 <desp> I need an unholy fusion of Data.Map.mapWithKey and Data.Foldable.forM_
09:55:17 <desp> hm, or maybe I shouldn't be using a Map...
09:55:45 <sorear> you could use mapM_ action . M.fromList map
09:56:07 <sorear> laziness will make that efficient
09:56:46 <desp> hm
09:56:50 <desp> I am suspicious
09:57:39 <sjanssen> it is probably more efficient that mapWithKey+forM
09:57:44 <sjanssen> s/that/than
09:59:44 <sjanssen> definitely more efficient: Map is spine strict, so you'll use O(n) memory performing the mapWithKey
10:00:05 <wli> What's spine strictness?
10:00:17 <chessguy> spine = key?
10:00:34 <sjanssen> wli: it means that the structure of the map is always evaluated, but not necessarily the elements contained in it
10:00:49 <etnt> how does Haskell compare to Clean ?
10:01:06 <sjanssen> etnt: we have an active IRC channel :)
10:02:19 <wli> I'll take that to mean it forces the spine to be unwound though not necessarily anything more.
10:04:39 <etnt> well, I'm reading the wikibook (and enjoying it) but just came across the Clean website, the features seems somewhat similar, or ?
10:04:53 <sjanssen> etnt: yes, the languages are related
10:12:07 <sm> could I use where inside a list comprehension ?
10:13:19 <aharoni> Hi. Can GHC use readline in Cygwin? I have Cygwin, readline and rlwrap installed, but `ghc-pkg describe readline` says "ghc-pkg.exe: cannot find package readline"
10:14:21 <SamB> oh, I'm being silly...
10:14:23 <chessguy> are you talking about this readline?
10:14:25 <chessguy> @hoogle readline
10:14:26 <lambdabot> System.Console.Readline.readline :: String -> IO (Maybe String)
10:14:26 <lambdabot> System.Console.Readline :: module
10:14:26 <lambdabot> System.Console.Readline.setReadlineName :: String -> IO ()
10:14:57 <SamB> it isn't ghci's recompilation checking... the modules I have built are profiling libraries...
10:15:19 * chessguy hands samB his sign
10:15:26 <SamB> er. well, modules.
10:15:44 <sorear> aharoni: There are two things called readline.
10:15:45 <SamB> chessguy: I don't need your "[citation needed]" sign
10:15:54 <chessguy> lol
10:15:57 <chessguy> not that sign
10:15:59 <sorear> aharoni: One of them is a C library from the GNU project
10:16:07 <chessguy> sign as in "Here's your sign"
10:16:14 <sorear> aharoni: The other is a Haskell library that binds to said C library
10:16:44 <sorear> aharoni: You need both if you want to use readline in haskell programs
10:16:50 <chessguy> SamB, as in http://www.cowboylyrics.com/lyrics/engvall-bill/heres-your-sign-get-the-picture-5978.html
10:16:52 <lambdabot> Title: Bill Engvall - Here's Your Sign (Get The Picture) Lyrics, http://tinyurl.com/43ua9
10:16:55 <aharoni> yeah, i'm quite sure that i have gnu Readline installed
10:16:57 <chessguy> it was intended to be a joke
10:17:28 <aharoni> i have /usr/lib/libreadline.a
10:17:47 <aharoni> how do i install the haskell readline? sorry, i'm a ghc newbie
10:18:14 <sorear> aharoni: hmm. it should have been in the GHC bundle (it's one of the extralibs)
10:18:26 <sorear> if not,
10:18:30 <aharoni> i installed the windows MSI from haskell.org
10:18:52 <aharoni> i tried looking for it on hackageDB and couldn't find it.
10:19:07 <aharoni> looking for Haskell readline lib, that is
10:19:41 <sorear> that's funny, I wonder why it's not there
10:20:14 <sorear> http://darcs.haskell.org/packages/readline/
10:20:16 <lambdabot> Title: Index of /packages/readline
10:20:20 <sorear> that
10:20:36 <sorear> 's the darcs-repository for the standard readline package
10:21:11 <sorear> should be a standard cabal installation procedure
10:21:41 * sorear checks to see if it builds without the GHC library-building infrastructure
10:22:41 <sorear> yup, it builds.
10:23:34 <sorear> autoconf; runghc Setup configure; runghc Setup build; runghc Setup install   works for me (not cygwin, so it might not transfer...)
10:24:07 <aharoni> thanks. but what do i need to download?
10:24:46 <sorear> yeah, this is too strange
10:24:59 <sorear> eivuokko: Does readline work on windows/cygwin?
10:32:31 <aharoni> sorear: thanks for the help, gotta go :(
11:02:19 <syntaxfree> I don't have the experience to build up a large-ish project from scratch.
11:02:33 <syntaxfree> I can't seem to contribute to other people's code either.
11:02:46 <syntaxfree> I understand how everything works, but I never find a place where I can make an improvement.
11:02:54 <syntaxfree> (And haven't figured out VCSes yet)
11:03:15 <Alleria> what about the ICFP?
11:03:17 <syntaxfree> so I've been stuck for most of my Haskell life to toy projects. There must be a way out of this conundrum.
11:03:32 <syntaxfree> Alleria: OH.
11:03:44 <syntaxfree> That could be interesting. I missed the deadline for Google's Summer of Code.
11:04:19 <bartw> definitly advice you to take part in icfp, its fun
11:04:19 * Syzygy- is kinda sorta looking for a nice and good team for the ICFP
11:04:58 <bartw> as for big projects, just try to build some large things, experience works best
11:05:17 <syntaxfree> I wonder if the wiki will work as a mean to building teams.
11:06:03 * Alleria is nowhere near ready to join a team this year. But next year might be a different story.
11:06:47 <bartw> to have a good team you need to have worked before the contest imo
11:07:23 <vincenz> @localtime dons
11:07:23 <lambdabot> Local time for dons is Sun Jul  8 04:06:56 2007
11:07:27 <vincenz> Anyone ever compile a lambdabot/
11:07:33 <vincenz> what is the dependency "haskell-src-any" ?
11:07:53 <sorear> syntaxfree:
11:08:11 * sorear suddenly forgets url
11:08:30 <sorear> http://haskell.org/haskellwiki/ICFP_Programming_Contest/Teams_2007
11:08:32 <lambdabot> Title: ICFP Programming Contest/Teams 2007 - HaskellWiki, http://tinyurl.com/3dx5mv
11:09:06 <syntaxfree> http://haskell.org/haskellwiki/?title=ICFP_Programming_Contest/Teams_2007&action=submit
11:09:08 <lambdabot> Title: Login required to edit - Preview - HaskellWiki, http://tinyurl.com/3dugxc
11:09:09 <syntaxfree> oops.
11:09:12 <syntaxfree> just added myself there.
11:09:19 <syntaxfree> but that's the preview, I have to submit :)
11:09:27 <syntaxfree> now added myself really.
11:09:40 <vincenz> sorear: who put lazy bototms on there, ooc?
11:10:11 <sorear> vincenz: dons
11:10:19 <sorear> vincenz: says the Page History :)
11:10:20 <vincenz> ah cool :)
11:10:32 <sorear> vincenz: haskell-src-any is any version of haskell-src
11:10:40 <vincenz> sorear: but what is 'haskell-src'
11:10:40 <bartw> hehe, quick, lambdabot is still seeking a team
11:10:44 <sorear> libghc6-haskell-src-dev on debian
11:10:49 <sorear> @hackage haskell-src
11:10:49 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/haskell-src
11:10:50 <vincenz> sorear: thx :)
11:11:38 <Alleria> Man, people on that page interested in competing have an intimidating list of skills!
11:12:08 <syntaxfree> Alleria: I should mention I'm a beginner-to-intermediate Haskelly.
11:12:23 <vincenz> sorear: Apparently that doesn't work with 6.6.1... Any way of eluding(sic) that specific dependency?
11:12:35 <syntaxfree> I mean, I grok the whole language and monads and stuff, but the boxed-unboxed stuff and advanced type hackery sometimes flies me by.
11:12:41 <Alleria> syntaxfree: and I'm a beginner who's only recently escaped the clutches of Perl.
11:12:49 <syntaxfree> Alleria: well, let's be a team.
11:13:31 <syntaxfree> I'll start a team -- Fiery Newbz
11:13:46 <syntaxfree> can I count you in?
11:14:04 <shachaf> vincenz: Is there any reason you put "(sic)" on your own sentence?
11:14:19 <vincenz> shachaf: wasn't sure if it's 'eluding' or 'eliding'
11:15:46 <Alleria> syntaxfree: sure thing :)
11:16:01 <bartw> only 2 more weeks
11:16:37 <shachaf> vincenz: 'SIC may mean one of the following: *[sic] or (sic) (from Latin sic for "thus"; see also list of Latin phrases) is a bracketed expression used to indicate that an unusual spelling, phrase, or any other preceding quoted material is intended to be read or printed exactly as shown (rather than being an error) and should not be corrected.' -- Wikipedia?
11:16:45 <shachaf> Oh, well, never mind.
11:16:54 <syntaxfree> Alleria: add yourself to my team then!
11:16:58 <syntaxfree> http://haskell.org/haskellwiki/ICFP_Programming_Contest/Teams_2007
11:17:00 <lambdabot> Title: ICFP Programming Contest/Teams 2007 - HaskellWiki, http://tinyurl.com/3dx5mv
11:17:07 <syntaxfree> I just created team FieryNewbz.
11:17:24 <syntaxfree> c'mon,  newbies, don't be shy. Join the FieryNewbz and we shall rock.
11:17:58 <olsner> "random knowledge of Bird-Merteens Formalism" :P
11:17:58 <Syzygy-> syntaxfree: I'm very tempted to join ya... :P
11:18:16 <Alleria> Good way to learn the language
11:18:19 <syntaxfree> random. I couldn't pass an exam on it.
11:18:23 <vincenz> shachaf: Thanks :) I thought it meant (in latin) "not sure of this spelling"
11:18:31 <Syzygy-> vincenz: GODS no!
11:18:33 <syntaxfree> Syzygy-: join us!
11:18:49 <Syzygy-> It's used that way because when quoting you'll tend to want to say "It's written this way, promise!"
11:18:54 <vincenz> Oh :)
11:18:54 <syntaxfree> Syzygy-, for those who don't know him, runs a scarily math-intense blog.
11:18:56 <olsner> syntaxfree: I don't even know what it is.. heck, I don't even know what field it is!
11:19:16 <vincenz> sorear: belatedly: thx
11:19:16 <Syzygy-> vvincAs in "It wasn't me screwing up. It was the original author!"
11:19:23 <vincenz> Syzygy-: Good to know )
11:19:41 <syntaxfree> olsner: oh, it's a theory of how programs can be constructed out of a few basic combinators.
11:19:58 <syntaxfree> a program construction calculus, in pedantic words.
11:20:14 <syntaxfree> Syzygy-: c'mon, our team needs more mathematicians :)
11:20:15 <olsner> is that anything like the X combinator?
11:20:23 <Syzygy-> Yeah, alright, I'm in....
11:20:30 <Syzygy-> Cale's team seems to be full anyway, so.
11:20:46 <olsner> or SKI, if you want to have three instead of one ;-)
11:21:00 <syntaxfree> I should be hurt that you prefer Cale's team, but hell, FieryNewbz is really unpretentious :)
11:21:03 <syntaxfree> :P
11:21:14 <syntaxfree> (just kidding, for christ's sake, don't take that seriously.
11:21:17 <Syzygy-> syntaxfree: Those 2 members are the two of us, are they?
11:21:23 * vincenz hmms
11:21:25 <syntaxfree> so, um, we have me, Alleria, and Syzygy-?
11:21:32 <vincenz> it's my team, MUHAHAHA, they're all my slaves :P
11:21:41 <syntaxfree> Syzygy-: I think those 2 members are me and Alleria
11:21:43 <Alleria> Syzygy-: succ 2
11:21:46 <syntaxfree> yo, Alleria, are you in?
11:21:49 <Syzygy-> Then succ 2
11:21:50 <Alleria> yes
11:22:07 <syntaxfree> Ok, I updated it to 3.
11:22:31 <syntaxfree> Should 5 be enough? I put 5 randomly.
11:22:37 <shachaf> syntaxfree: I'd join your team, but I won't be around for much of the contest.
11:22:42 <Syzygy-> syntaxfree: Depends on what we want to do.
11:22:45 <vincenz> syntaxfree: I was discussing this, personally I think 7 is a limit
11:23:12 <Syzygy-> 5+-2 is kinda a good number for keeping small groups manageable and efficient
11:23:28 <vincenz> Syzygy-: Yeah, if your group is too big, you risk that people start cowboying
11:23:33 <vincenz> something we as a team are going to avoid
11:23:33 <syntaxfree> well, if we never get more members until the deadline 3 is a charm.
11:23:42 <syntaxfree> vincenz: roles are clear for the time being.
11:23:52 <syntaxfree> I was the most experienced in the group. Now Syzygy- is.
11:23:53 <vincenz> syntaxfree: fyi, have a meet one week in advance to ensure everyone's got ssh/darcs adccess
11:24:10 <olsner> I think 3-4 is the optimum for guerilla-coding
11:24:13 <SamB> who is in charge of mailman on haskell.org?
11:24:14 <vincenz> syntaxfree: and create a group, google's a breeze to use
11:24:32 <syntaxfree> vincenz: cool. I can never figure out how to use darcs though :/
11:24:49 <syntaxfree> create a google group, or something in google code?
11:24:52 <Syzygy-> vincenz: The number 5+-2 is one of the Very Best things of a youth misspent as a boy scout.
11:25:05 <shachaf> syntaxfree: What's the problem with darcs?
11:25:05 <vincenz> syntaxfree: easiest way: set up -one- account (ti's annoying to set permissions right for multi-accounts).  Then have everyone's ssh key in ~/.ssh/authorized_keys
11:25:10 <vincenz> come to #oasis
11:25:11 <vincenz> this is a bit OT
11:25:17 <Syzygy-> Point
11:26:16 <olsner> incidentally, On Topic and Off Topic have the same acronym
11:27:56 <desp> syntaxfree: I'd be interested in joining a team
11:34:48 <DRMacIver> Trivial question. Is there a good date and time handling API for Haskell? System.Time seems rather basic.
11:35:27 <chessguy> maybe http://www.haskell.org/ghc/docs/latest/html/libraries/time/Data-Time.html has what you're looking for?
11:35:29 <lambdabot> http://tinyurl.com/yzllnx
11:36:52 <vincenz> sorear: how do you specify for a particular package where it should be installed if it's cabal?
11:37:53 <DRMacIver> chessguy: Well, it's closer. Still looks a bit thin on the ground.
11:38:00 <Igloo> vincenz: Pass --prefix=/foo/bar to Setup configure
11:38:10 <chessguy> on the ground?'
11:38:30 <vincenz> Igloo: thank you
11:38:45 <DRMacIver> i.e. rather basic.
11:38:58 <chessguy> DRMacIver, what exactly are you looking for?
11:39:01 <chessguy> (that's not there)
11:39:57 <vincenz> Igloo: Unable to rename "/usr/lib/ghc-6.6.1/package.conf" to "/usr/lib/ghc-6.6.1/package.conf.old"
11:40:01 <vincenz> Saving old package config file... ghc-pkg.bin: /usr/lib/ghc-6.6.1/package.conf: renameFile: permission denied (Permission denied)
11:40:22 <Lemmih> vincenz: setup install --user.
11:40:28 <vincenz> h
11:40:40 <vincenz> thank you
11:42:04 <glguy> yw!
11:42:27 <DRMacIver> chessguy: Well, for example, support for different international calendar formats and different time zones. But really I'm not looking for anything specific - I've noticed in the past that date and time handling are quite hard to get right, so I thought writing a decent implementation for Haskell might a) Work well for my current "Write dumb code in Haskell" initiative and b) Be useful for other people, and was wondering if there was already a go
11:44:31 <chessguy> DRMacIver, hm, for international support, maybe you want http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Locale.html
11:44:33 <lambdabot> http://tinyurl.com/34khvv
11:45:01 <DRMacIver> Hm. Maybe so.
11:45:04 <DRMacIver> Thanks
11:46:10 <chessguy> sure. good luck, sounds like a good initiative
11:48:56 * vincenz mutters as lambdabot gives him compiler errors
11:50:48 <DRMacIver> chessguy: It's just a variant on the usual "Rewrite your favourite unix tools in Haskell" theme.
11:51:01 <shachaf> vincenz: What compiler errors?
11:51:20 <DRMacIver> Based on the realisation that the ratio of time I've spent trying to understand Haskell to time I've spent writing Haskell is probably well over 100. :)
11:52:24 <vincenz> shachaf: stuff in the Parser
11:52:47 <shachaf> vincenz: Are you using the darcs version?
11:52:53 <vincenz> shachaf: I was
11:53:00 <vincenz> I've switched over to the cabal one due to those bugs
11:53:08 <shachaf> vincenz: Cabal one?
11:53:13 <vincenz> the hackage one
11:53:16 <shachaf> vincenz: Oh.
11:53:31 <shachaf> vincenz: From what I understand, the release is completely unusable at the moment.
11:53:35 <shachaf> Though that may have changed.
11:53:43 * vincenz nods
11:55:14 <shachaf> vincenz: Which version of GHC are you using?
11:55:25 <vincenz> Yep, the hackage one requires fps, which is outdated, nowadays it's binary.  And the darcs one gives me compiler errors.
11:55:28 <vincenz> shachaf: 6.6.1
11:55:57 <shachaf> vincenz: I did have to remove arrows from the dependencies of the darcs version, I think.
11:56:06 <shachaf> vincenz: But I don't remember changing anything else.
11:56:45 <vincenz> Hmm, it didn't mind about arrows
11:56:57 <chessguy> mmm, lots of non-exhaustive cases warnings in haxml
11:57:36 <Saul_> Haskell rocks
11:57:47 <vincenz> shachaf: http://rafb.net/p/d7k63X78.html
11:57:48 <lambdabot> Title: Nopaste - bugs
11:57:52 <chessguy> Saul_, duh?
11:57:54 <vincenz> that's from the darcs-one
11:58:18 <Saul_> Yeah sorry, I just made something cool with it that is just really awesome
11:58:30 <vincenz> Saul_: cool :)
11:58:41 <chessguy> Saul_, what's that?
11:58:41 <glguy> What is the facination with the alleged language "Arc" ?
11:58:47 <vincenz> glguy: pg
11:58:53 <chessguy> glguy, it's vaporware
11:59:05 <shachaf> vincenz: That's only defined #if __GLASGOW_HASKELL__ > 606.
11:59:08 <Saul_> I've been futzing in other languages, but it's really sleek in Haskell
11:59:17 <vincenz> Saul_: 6.6.1 ?
11:59:19 <shachaf> vincenz: Yours is, but maybe this is a cpp problem?
11:59:25 <Saul_> It's a Wiki system for generic data types
11:59:43 <chessguy> hmm. a wiki system for types? i don't get it
11:59:58 * glguy just doesn't understand why people seem to care so much about this proprietary language
12:00:12 <Saul_> So instead of having only pages that can be edited by users, any haskell data type can be used
12:00:28 <Saul_> instead of strings I mean
12:00:40 <chessguy> Saul_, is it based on happs?
12:00:53 <Saul_> only requirement is that you define a diff and patch function for it
12:01:03 <Saul_> nope, just made it from scratch
12:01:20 <chessguy> but it serves content over http?
12:01:37 <Saul_> Well it only maintains the changes for now
12:01:44 <vincenz> I do not think the http is the relevant factor in this case, it's the patching on types
12:01:48 <vincenz> right?
12:01:49 <Saul_> not really much to it yet
12:01:57 <Korollary> The content bit is relevant
12:02:08 * vincenz nods at Korollary 
12:02:21 <Saul_> I want to make a wiki site with some specific types, like games, developers, genres etc.
12:02:22 <vincenz> shachaf: no idea ?
12:02:22 <chessguy> hmm. i guess i don't get it
12:02:23 <Korollary> So you can wiki-edit any datatype that derives DiffPatchable and Show
12:02:36 <Syzygy-> Alleria: Poke?
12:02:47 <Saul_> Korollary, indeed
12:03:08 <shachaf> vincenz: You are building according to the README, right?
12:03:09 <vincenz> Saul_: And the part you've currently finished is the backend part
12:03:16 <vincenz> shachaf: yes?
12:03:19 <Saul_> And a game for example will have a name, a developer, a release date, a description and such
12:03:25 <Toxaris> Saul_: A wiki engine wich also supports defining of these types would be cool
12:03:28 <vincenz> oh...wait..
12:03:34 <vincenz> no I was using runghc Setup con..
12:03:40 <shachaf> vincenz: That explains it.
12:03:45 <shachaf> vincenz: You want ./build.
12:03:54 <Saul_> and the whole thing can be edited if it's Diffable
12:04:00 <Toxaris> Saul_: And dynamic pages could be created by Haskell code edited wiki-style too
12:04:21 <Saul_> Toxaris, Well that's the next step
12:04:51 <vincenz> shachaf: thx
12:04:58 <vincenz> shachaf: oh waiti, I was using ./build
12:05:00 <Saul_> Toxaris, to derive edit pages and content pages as well
12:05:20 * vincenz has a short-memory
12:05:23 <Saul_> Toxaris, although those should be highly customizable
12:05:55 <Saul_> Does it sound useful to anyone?
12:06:07 <Toxaris> Saul_: I
12:06:16 <chessguy> sounds interesting anyway
12:06:23 <Toxaris> Saul_: I'm not quite sure what you already have and what remains to be done
12:06:48 <Saul_> So far I have a data type and functions that create, revise and revert the data in it
12:06:49 <Toxaris> Saul_: Would be useful with a good browser based ui
12:07:20 <chessguy> @where binary
12:07:20 <lambdabot> http://www.cse.unsw.edu.au/~dons/binary.html
12:07:21 <Saul_> I'll put the source somewhere, hang on
12:07:22 <vincenz> shachaf: trying again without the #ifdef and #endif
12:08:07 <vincenz> shachaf: that fixed it
12:08:14 <vincenz> (manually removed those two lines)
12:09:55 <Toxaris> Saul_: You know about http://en.wikipedia.org/wiki/Semantic_wiki ?
12:09:57 <lambdabot> Title: Semantic wiki - Wikipedia, the free encyclopedia
12:10:46 <Saul_> http://www.funhills.com/hs/WikiPage.hs and http://www.funhills.com/hs/Diffable.hs
12:10:59 <Saul_> Toxaris, I don't
12:13:16 <Saul_> Toxaris, sounds interesting though
12:13:55 <Toxaris> your History is isomorph to [Either (Patch a) Word]
12:14:56 <Toxaris> with creation = []; revision patch = (Left patch :); reversion back = (Right back :)
12:15:01 <lispy> hmm...someone said lispy but it's not in my scrollback anymore
12:15:43 <Syzygy-> (14:43) ( DRMacIver) (It's statically typed and doesn't have macros yet as far as I know, so it's only really syntactically lispy)
12:15:52 <Syzygy-> (21:14) ( lispy) hmm...someone said lispy but it's not in my scrollback anymore
12:16:03 <Syzygy-> The two latest occurences of "lispy" in my backlog
12:16:11 <lispy> ah i see
12:16:12 <lispy> thanks
12:16:15 <Syzygy-> np
12:16:47 <Saul_> Toxaris: It is now, but I'll expand it later (with at least status changes like locking the page or something)
12:17:15 <Toxaris> Saul_: Sure, to use Either would be nonsense, but why not use lists?
12:17:45 <Toxaris> type History = [HistoryItem]; data HistoryItem = Revision ... | Reversion ... | Locking ... | Unlocking ...
12:17:52 <Korollary> lispy: It was me. I was announcing uploading your dirty videos to youtube.
12:18:22 <Saul_> Toxaris: That might be a good idea
12:18:28 <DRMacIver> lispy: You must have a really small scrollback. :)
12:18:53 <Saul_> Toxaris: thanks
12:18:56 <Toxaris> it would enable you to use generic list functions like length, map, foldr ...
12:19:42 <Saul_> I think I'll rewrite it then
12:19:47 <Saul_> Any other pointers?
12:20:21 <chessguy> woohoo!
12:20:30 * chessguy gets hApps installed
12:20:45 <Toxaris> just an idea: the intended use of your framework is with structured pages
12:21:15 <Toxaris> so what about structured patches?
12:21:58 <Toxaris> instance Diffable a => Diffable [a] where ...
12:22:33 <lispy> DRMacIver: perhaps, i thought i set irssi to keep a full days worth of scroll back, but it seems to only keep about 1000 lines or something
12:22:42 <lispy> Korollary: cool
12:22:43 <sjanssen> @where logs
12:22:43 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
12:23:06 <sjanssen> lispy: ^^^ there you go :)
12:23:12 <Toxaris> and type Patch a = a wouldn't work for long
12:23:28 <Toxaris> for integers, it's fine, but what about more complicated data types
12:23:50 <Saul_> Yeah I was thinking about that a little already
12:24:17 <Saul_> It could basically be any type
12:24:33 <Saul_> Although for the wiki system it should have Read and Show
12:24:42 <Saul_> I'm not sure how to do that though
12:25:28 <Toxaris> class (Show page, Read page, Show patch, Read patch) => Diffable page patch where diff :: page -> page -> patch; patch :: page -> patch -> page
12:25:30 <chessguy> http://localhost:8000/ -> Hello World -- woot!
12:25:51 <Syzygy-> chessguy: I don't see anything. :-/
12:25:57 <chessguy> :)
12:26:09 <Toxaris> or class ... => Diffable page patch | page -> patch
12:26:58 <Saizan> i do!
12:27:04 <Saul_> Toxaris: ok, this is going a little too fast (I'm pretty new to haskell and functional programming)
12:27:29 <Toxaris> Saul_: I don't really understand it, either :-)
12:27:53 <Saul_> :)
12:28:29 <crazy_code2> what does precision mean in  - arbitary precision integer ?
12:28:39 <Toxaris> crazy_code2: size
12:29:22 <crazy_code2> Does it have to do anything with number of digits after decimal point ?
12:29:28 <Saul_> I think I'll change the data structure to lists first, and then I'll see about the Diffable stuff
12:29:47 <Toxaris> crazy_code2: integers have zero digits after decimal point
12:29:52 <Saul_> Toxaris: thanks for your help, maybe I'll need more of it later on :)
12:30:02 <sorear> .
12:30:04 <crazy_code2> Toxaris: what about float then?
12:30:21 <sorear> crazy_code2: *integer*
12:30:39 <Toxaris> crazy_code2: an arbitrary precision integer has an arbitrary number of digits *before* the decimal point
12:30:44 <sorear> crazy_code2: arbitrary precision integer can have as many digits as will fit in RAM
12:30:50 <crazy_code2> there is something called double precision floating point number also........
12:30:51 <sorear> > 2^256 :: Integer
12:30:53 <lambdabot>  115792089237316195423570985008687907853269984665640564039457584007913129639936
12:30:55 <sorear> > 2^256 :: Int
12:30:57 <lambdabot>  0
12:31:03 <Saul_> crazy_code2: It just means that you can store any integer in it, instead of just those between -2^somthing and 2^samething
12:31:57 <crazy_code2> Ok got the concept for integers.
12:32:11 <jre2> I have a thread (looping) that does something if a TChan has something for it OR if a Handle has something. is there any way to only execute the thread if the TChan/Handle have been written to?
12:32:12 <crazy_code2> Can anyone tell it wrt floating point numbers ?
12:32:18 <Saul_> crazy_code2: Because most integer type only allocate 32 bits for an integer, which limits the range
12:32:56 <crazy_code2> Saul_: yeah
12:32:57 <Saul_> crazy_code2: Integer is arbitrary precision, meaning that it uses a variable amount of bits to store the number, based on the number's size
12:32:57 <sorear> crazy_code2: Floating point numbers use (binary) scientific notation
12:32:58 <jre2> retry will block for tchan's stm action, but I don't think IO has something as awesome as that
12:33:06 <Syzygy-> Alleria: Poke?
12:33:12 <sorear> crazy_code2: EG, 1.101010101010101 x 2^256
12:33:12 <crazy_code2> Ok
12:33:14 <crazy_code2> Thanks
12:33:25 <sorear> crazy_code2: the precision is the number of bits after the point
12:33:33 <sorear> eg, 52 for IEEE doubles
12:33:52 <sorear> > (1.0 + 2^-51) - 1.0
12:33:54 <lambdabot>   Not in scope: `^-'
12:33:56 <sorear> > (1.0 + 2^ -51) - 1.0
12:33:58 <lambdabot>      precedence parsing error
12:33:58 <lambdabot>         cannot mix `(^)' [infixr 8] and prefix ...
12:34:01 <crazy_code2> so one can represent upto 52 digits after decimal point accurately with doubles ?
12:34:03 <sorear> > (1.0 + 2^(-51)) - 1.0
12:34:06 <lambdabot>  Exception: Prelude.^: negative exponent
12:34:14 <sorear> crazy_code2: 52 binary digits
12:34:25 <sorear> crazy_code2: which works out to about 20 decimal digits
12:34:28 <Korollary> I think it's about 17 decimal deigits
12:34:34 <sorear> > (1.0 + 2^^(-51)) - 1.0
12:34:35 <Toxaris> crazy_code2: after the first non-zero digit
12:34:36 <Heffalump> I think 17 or so too.
12:34:37 <lambdabot>  4.440892098500626e-16
12:34:39 <sorear> > (1.0 + 2^^(-52)) - 1.0
12:34:41 <lambdabot>  2.220446049250313e-16
12:34:44 <sorear> > (1.0 + 2^^(-53)) - 1.0
12:34:46 <lambdabot>  1.1102230246251565e-16
12:34:49 <sorear> > (1.0 + 2^^(-54)) - 1.0
12:34:50 <Toxaris> that's the "floating" bit
12:34:51 <lambdabot>  5.551115123125783e-17
12:34:52 <crazy_code2> Oh Ok
12:34:53 <sorear> > (1.0 + 2^^(-55)) - 1.0
12:34:56 <lambdabot>  2.7755575615628914e-17
12:34:56 <crazy_code2> Great
12:35:00 <sorear> > (1.0 + 2^^(-60)) - 1.0
12:35:01 <crazy_code2> Thanks :)
12:35:02 <lambdabot>  8.673617379884035e-19
12:35:05 <sorear> > (1.0 + 2^^(-64)) - 1.0
12:35:07 <lambdabot>  0.0
12:35:10 <sorear> oh
12:35:13 <jre2> better question: is it possible to combine threadWaitWrite (IO) and retry (STM) somehow?
12:35:21 <sorear> dons must be using -fexcess-precision :(
12:36:34 <sjanssen> sorear: yeah, that's a bit odd
12:37:02 <sorear> or maybe default (CLDouble)
12:38:03 <sjanssen> more likely -fexcess-precision
12:39:12 <sjanssen> dons probably has 'ghc' aliased to some ridiculous set of optimization flags :)
12:39:32 <Saul_> data Page a = Page {object::a, revisionNumber::Word, history::[HistoricEvent a]} deriving Show
12:39:32 <Saul_> data HistoricEvent a = HistoricEvent {eventType::HistoricEventType} deriving Show
12:39:32 <Saul_> data HistoricEventType a
12:39:32 <Saul_>   = Creation
12:39:32 <Saul_>   | Revision {patchPrevious::Patch a}
12:39:33 <Saul_>   | Reversion {backTo::Word}
12:39:35 <Saul_>   deriving Show
12:39:45 <Saul_> Is this better than what I had before?
12:40:06 <Saul_> Given that the HistoricEvent will also hold data like user and time in it later
12:40:08 * sorear wishes shapr would install the tested hpaste fix we sent him a day and a half ago
12:41:26 <Toxaris> Saul_: use http://paste.lisp.org/ to show code
12:43:21 <Saul_> Toxaris: Should I pick #haskell-hr?
12:43:37 <Toxaris> Saul_: pick nothing and send us the link by hand
12:44:09 <Saul_> ok
12:45:04 <Saul_> http://paste.lisp.org/display/44111
12:45:18 <Saul_> Ok, same question :)
12:45:41 <Toxaris> hmm.. this doesn't compile, does it?
12:46:00 <Saul_> Toxaris: I haven't actually checked :P
12:46:48 <Meowfaceman> Beginner question about Monads: Say you're writing a program that gets an Integer from user input and prints the factorial of the integer.  Your factorial function wouldn't/shouldn't be Integer -> Integer, but IO Integer -> IO Integer, correct?
12:46:51 <Toxaris> Saul_: but it looks sensible to me
12:47:15 <Heffalump> Meowfaceman: it should be Integer -> Integer
12:47:19 <Heffalump> to reflect the fact that it's pure
12:47:24 <Heffalump> you can call it from the IO monad
12:47:31 <Saul_> Toxaris: Yeah there is an 'a' missing somewhere
12:47:49 <Heffalump> e.g. do x <- getIntFromUser ; let y = fact x ; print y
12:48:14 <Saul_> Toxaris: I'll edit the functions then, to work with the new datastructure
12:48:23 <Saul_> Toxaris: thanks again for your help
12:51:23 <Meowfaceman> Heffalump: Okay, I see.  Thanks, that helps me a lot.
12:52:35 <sorear> that's funny
12:52:46 <sorear> there's a haddock interface file for MTL
12:52:58 <sorear> ...in /home/eric/pastebot/hpaste_state
13:03:59 <Saul_> IvdSangen: Hoi Ivo
13:04:18 <IvdSangen> Hey
13:04:51 <sorear> hello?
13:05:44 <chessguy> ermm, dumb question. if a package has a dependency on unix-* then it can't be run on windows?
13:05:52 <Baughn> chessguy: Logically, nope
13:05:59 <Baughn> Maybe in cygwin
13:06:01 <chessguy> mmmm, that sucks
13:06:01 <sorear> no, you can create your own "unix" package
13:06:15 <chessguy> sorear, hm?
13:06:29 <SamB> obviously, programs shouldn't depend on the unix package if possible...
13:06:29 <Baughn> Sure, as a compatibility library, but depending on wnat it uses that ranges from hard to impossible
13:06:30 <sorear> chessguy: Are you talking about functorm-1.0?  I uploaded a version with fixed dependencies already
13:06:43 <chessguy> sorear, i'm not
13:07:33 <Baughn> chessguy: Remove the dependency, see what breaks
13:08:29 <chessguy> hm. there's not even a .cabal file
13:09:15 <chessguy> oh, wrong directory
13:11:26 <sorear> @time glguy
13:11:28 <lambdabot> Local time for glguy is Fri Jul  6 13:20:24 2007
13:13:09 <Korollary> his clock is 8 minutes off?
13:13:25 <Korollary> that's so unnerdly
13:14:36 <chessguy> @localtime
13:14:36 <lambdabot> Local time for chessguy is Sat Jul 07 16:12:31
13:14:42 <chessguy> how weird
13:15:48 <sorear> chessguy: what is?
13:16:07 <chessguy> that localtime returns a time that's just a few minutes off
13:16:35 <sorear> well localtime works by querying the client.
13:16:45 <sorear> 13:14 < lambdabot> Local time for chessguy is Sat Jul 07 16:12:31
13:16:56 * sorear has ntpdate
13:17:22 <chessguy> sorear, i thought most computers had some kind of real-time clock-synchronization
13:20:15 <vincenz> Cale: ping
13:20:24 <ari> So, um, what's the best way to install ghc-6.6.1 on Ubuntu Feisty?
13:21:50 <Saul_> Ok, I finished my changes on the list version: http://paste.lisp.org/display/44111#1
13:22:45 <Saul_> ari: aptitude install ghc
13:23:01 <Saul_> ari: or apt-get install ghc, whichever you prefer
13:23:17 <Korollary> do they have 6.6.1?
13:23:26 <Saul_> Not sure, I have 6.6
13:24:35 <ari> Saul_: That gets me 6.6, and I have no idea how to work with Ubuntu's releases (i.e. I'm pretty sure that with the right magic in sources.list I can get 6.6.1, after all *somebody's* got to have packaged it, but so far I don't know what that magic is)
13:24:39 <Korollary> I built from source
13:25:28 <Saul_> ari: I don't know how to get 6.6.1 either
13:27:26 * ari tries Debian's unstable release
13:27:54 <ari> (I have a feeling this is going to cause me a bunch of pain, but...)
13:28:11 <Toxaris> Saul_: whats Creation for
13:28:53 <Toxaris> Saul_: ok, I see, to allow user information to be associated with it
13:29:01 <Saul_> Toxaris: To indicate that the page was created (basically to list time and user later on)
13:29:18 <Saul_> Toxaris: indeed :P
13:29:41 <Toxaris> Saul_: should work, but may be bad design
13:29:58 <Toxaris> Saul_: Creation is only allowed as first event in a history
13:30:18 <Saul_> Toxaris: True
13:30:35 <Saul_> Toxaris: That wasn't the case in the recursive version though
13:30:47 <Toxaris> Saul_: Hmm, yes, thats true...
13:31:40 <Toxaris> we need a [] different from []...
13:32:01 <Toxaris> but isn't the act of creating the page identical to revising it with respect to an empty page?
13:32:21 <Saul_> Yup
13:32:48 <Toxaris> so is it possible to have Page x 1 [Event Creation]
13:32:56 <Saul_> But then you would have to make a new class that specifies what "empty" means for the datatype you're using it with
13:33:09 <Toxaris> or has it to be Page x 2 [Event Creation, Event (Revision ...)]?
13:33:36 <Saul_> The former is allowed
13:33:44 <Saul_> the latter would be revision 2
13:33:46 <Toxaris> what does it mean?
13:34:14 <Saul_> the first is a page with the value x and no edits on it
13:34:26 <Saul_> the second has had a single edit
13:35:07 <Toxaris> ok and the information associated with Creation accounts for who provided the initial value of the object field?
13:35:24 <Saul_> I'm also thinking about adding branching and merging support later, so we might need to keep that in mind here as well
13:35:34 <Saul_> Yes
13:37:07 <Toxaris> Saul_: I don't know anything about the internals of version control systems, so it may not help to keep it in mind
13:37:10 <Saul_> It would be prettier indeed if the creation was just a revision of an empty page, but like I said, you'd need to know what 'empty' is for each datatype
13:37:35 <Toxaris> let's assume there were some browser based ui
13:38:06 <Toxaris> it would contain a "new entry" link, wouldn't it, wich would produce an empty page representing some Haskell data type ready to be edited
13:38:42 <Toxaris> so the entry function is needed anyway
13:38:52 <Toxaris> ehm, "empty function"
13:39:14 <Saul_> Well it's not necessary to immediately add a blank page
13:39:37 <Saul_> You could wait for the initial data entered by the user, and then create it with that data
13:40:01 <Saul_> But it is an option
13:40:14 <Toxaris> but you have to show some page to the user wich he can use to enter the data
13:40:37 <Saul_> oh I understand
13:40:52 <Saul_> You need initial data to show the form you mean?
13:41:22 <Toxaris> assuming we add entryForm :: a -> HTML to the Diffable class
13:41:40 <Toxaris> we could handle the initial form by entryForm empty if we have empty
13:42:09 <dfranke_> I'm trying to write a function that takes a list of Foo monads, whose type parameter it doesn't care about.  So it should be able to accept [return "bar", return 42] as an argument.  Is that possible?
13:42:34 <Toxaris> dfranke_: i don't think so
13:42:49 <DRMacIver> I think it's possible with existentials. I'm not sure if those are implemented anywhere though. :)
13:43:05 <Saul_> empty :: a
13:43:12 <Saul_> That seems more logical
13:43:35 <Saul_> so in case of Integer, it would be
13:43:41 <Saul_> empty = 0
13:43:47 <Toxaris> dfranke_: what about using () as type parameter, and insert = (>>= return ()) . (:) as insert function?
13:43:59 <Korollary> existentials are in ghc
13:44:10 * vincenz is hoping on some input
13:44:24 <vincenz>  ... on his blog article (on a simple type-inference-engine in haskell)
13:44:40 <DRMacIver> Korollary: ok.
13:46:24 <Toxaris> dfranke_: hmm, my insert seems wrong... I mean insert elm lst = (elm >>= return ()) : lst
13:47:14 <Toxaris> Saul_: yep that's what I mean
13:48:00 <dfranke_> Toxaris: yeah, of course that would work, but the most common use case is that the list is hard-coded, in which case I'd either need TH or require a lot of junk keystrokes.
13:48:55 <DRMacIver> You could use a HList
13:49:04 <DRMacIver> (an HList?)
13:50:32 <dfranke_> a library won't help me here.  If it doesn't have easy syntax, then I might as well do the >>= return () approach.
13:50:57 <sorear> .
13:51:04 <Toxaris> you could add near-to-easy syntax by defining a one-char infix operator
13:51:24 <Saizan> dfranke_: you could define a custom (:) with low precedence the same as Toxaris' insert, and write elm1 :- elm2 :- elm 3 :- .... :- []
13:52:13 <Saul_> class Diffable a b where
13:52:13 <Saul_>   diff :: a -> a -> b
13:52:13 <Saul_>   patch :: a -> b -> a
13:52:21 <Saul_> This doesn't compile :S
13:52:25 <Saizan> :- would actually be parsed as a constructor, but you get the point
13:52:31 <Saul_> Too many parameters for class `Diffable'
13:52:41 <Toxaris> Saul_: you use ghc?
13:52:45 <Saul_> yes
13:53:08 <Toxaris> you need to enable some language extension, the error message should tell you wich
13:53:14 <Saul_> I see
13:53:23 <DRMacIver> It's usually -flgasgow-exts isn't it? :)
13:53:27 <vincenz> MPTC != H98
13:53:31 <dfranke_> -fglasgow-exts.  Multii-parameter typeclasses is the name of the extensions.
13:53:33 <Saul_> So there is no portable way to define it then?
13:53:35 <dfranke_> multi*
13:53:52 <dfranke_> Saul_: those are de facto portable.
13:53:55 <dfranke_> Saul_: they'll be in Haskell'.
13:53:59 <sorear> -X=MultiParamTypeClasses
13:54:06 <SamB> DRMacIver: as soon as they implement the new flag, it will tell you that one...
13:54:11 <SamB> sorear: is it really X?
13:54:19 <sorear> SamB: Yes, it's really X.
13:54:28 <int-e> or {-# LANGUAGE MultiParamTypeClasses #-}
13:54:36 <int-e> so many options
13:54:36 <SamB> that's short and sweet
13:55:01 <SamB> int-e: well, it is going to tell you -X=MultiParamTypeClass, not {-# LANGUAGE MultiParamTypeClasses #-}
13:55:04 <Saul_> dfranke: ok thanks, I'll try it
13:55:16 <SamB> the documentation for -X will refer the user to the other ways
13:55:17 <int-e> SamB: sure
13:55:32 <int-e> SamB: but I prefer to have it in the source file actually
13:55:53 <SamB> int-e: yeah, well -X makes the message shorter ;-)
13:56:45 <SamB> http://hackage.haskell.org/trac/ghc/ticket/1469
13:56:47 <lambdabot> Title: #1469 (GHC suggests -fglasgow-exts, and not {-# LANGUAGE #-} pragmas or &#34;Ext ...
13:56:56 <int-e> SamB: I'm confident that I'll be able to translate one to the other.
13:57:12 <SamB> int-e: that's kinda the point of the option working that way, yes ;-)
13:57:27 <SamB> so you, cabal, and I can translate our options to and fro
13:57:37 <sorear> -ftype-families doesn't map well to Cabal, or conversely.
13:57:57 <SamB> sorear: patches welcome
13:58:33 <SamB> (that's what they told me when I mentioned the possibility of Cabal not knowing all the extensions in the future)
13:58:45 <sorear> SamB: Not my point at all.
13:58:59 <SamB> sorear: what is your point?
13:59:21 <sorear> SamB: Even if cabal knew about IndexedTypes, translating between IndexedTypes and -ftype-families is not the domain of simple minded computer programs.
13:59:26 <sorear> SamB: IOW, what you said.
13:59:29 <SamB> ahhh!
13:59:50 <SamB> well, the other thing is that 90% of the extensions would otherwise translate to -fglasgow-exts
14:00:16 <SamB> at least, if you listen to GHC they would
14:01:08 <Saul_> Ok now I have this (it compiles):
14:01:13 <Saul_> class Diffable a b where
14:01:13 <Saul_>   diff :: a -> a -> b
14:01:22 <Saul_> instance Diffable Integer Integer where
14:01:22 <Saul_>   diff x y = x - y
14:01:43 <Saul_> But if I ask what 'diff 3 4' is, it won't work
14:01:52 <Saul_> Ambiguous type variable `t' in the constraint
14:02:22 <Toxaris> 3 and 4 are ambiguous
14:02:32 <Toxaris> they could be Integer, Int, whatever
14:02:44 <Toxaris> diff (3 :: Integer) (4 :: Integer) should work
14:02:51 <SamB> and the return type is even more ambiguous
14:03:51 <Saul_> Toxaris: it doesn't :(
14:04:18 <Toxaris> as Sam B stated, it isn't enough to know the argument types, the return type is also needed
14:04:21 <Lemmih> Saul_: diff (3 :: Integer) (4 :: Integer) :: Integer
14:04:36 <Saul_> I see
14:04:42 <DRMacIver> diff 3 4 should be fine shouldn't it?
14:04:54 <DRMacIver> In that you don't have Diffable instances for any other numeric types. :)
14:05:09 <DRMacIver> (I mean, you need to specify the return type, but not the argument types)
14:05:40 <ddarius> DRMacIver: Open world assumption.
14:05:45 <Toxaris> DRMacIver: who knows what other Diffable instances are hidden somewhere?
14:06:26 <DRMacIver> ddarius: ?
14:06:35 <DRMacIver> Toxaris: The compiler. :)
14:06:38 <vincenz> What does this mean: (the Coverage Condition fails for one of the functional dependencies)
14:07:23 <ddarius> DRMacIver: The compiler does not assume it is aware of all instances.
14:07:27 <Toxaris> DRMacIver: No, it doesn't, since it assumes an open world, where instance declarations can be hidden anywhere
14:07:31 <vincenz> this code ran fine in 6.4
14:07:39 <DRMacIver> I see.
14:07:49 <Saul_> Okay thanks guys
14:08:01 <Lemmih> vincenz: now you need -fallow-undecidable-instances.
14:08:14 <vincenz> Lemmih: thx, but this ran fine in 6.4
14:08:27 <Lemmih> vincenz: Yeps, things change.
14:08:38 <Saul_> Can I assume that in most actual use I don't have to add those type declarations everywhere?
14:09:00 <Toxaris> DRMacIver: Consider a library defining a class and using it's methods, and an application defining instances of this class and using the libraries functions. The library should typecheck and compile without knowing the application's source
14:09:45 <DRMacIver> Toxaris: I don't follow why that would cause a problem. The library does not import the application's modules, so shouldn't get its classes.
14:09:57 <Toxaris> that would be bad
14:09:58 <DRMacIver> Oh, are classes globally shared even without imports?
14:10:05 <Toxaris> class not, but instances
14:10:12 <DRMacIver> Sorry, I meant instances.
14:10:14 <DRMacIver> Gross. :(
14:10:33 <Toxaris> it's scary, but it's good
14:10:34 <Lemmih> They aren't. You just can't hide them.
14:10:43 <DRMacIver> Why is it good?
14:11:08 <Toxaris> if the library weren't aware of the applications instances, it couldn't be used with the applications data types
14:11:19 <DRMacIver> Hm. I don't follow.
14:11:37 <Toxaris> consider the library containing the sequence function
14:11:40 <DRMacIver> The application is aware of the application's instances. Therefore it can pass the appropriate record.
14:12:04 <DRMacIver> The library doesn't need information about the application because that information is available at the calling site.
14:12:39 <Toxaris> yes, but the library has to accept every record, even if it doesn't know the corresponding instance declaration
14:13:02 <DRMacIver> I have no idea what you mean. :)
14:13:12 <Toxaris> (not that I'm too sure about it...)
14:13:42 <Toxaris> I'll try to make an example...
14:14:01 <Lemmih> DRMacIver: Imagine if he exported 'x = diff 3 4'. What type should 'x' have?
14:14:15 <DRMacIver> Hm.
14:14:18 <DRMacIver> Now that is a good point.
14:14:35 <Toxaris> ok, we'll use Lemmih's example... :-)
14:14:48 <DRMacIver> Ok. I'm convinced by the open world assumption now. :)
14:15:02 <DRMacIver> But I'm not convinced that that means global sharing of instances is neccessary or a good idea.
14:15:43 <Lemmih> DRMacIver: They aren't exactly global. You just can't hide them in imports/exports (which is almost as bad).
14:15:54 <Toxaris> I don't think it's a good idea
14:16:13 <monochrom> Yeah, the instance importing story of Haskell has been unsatisfactory.
14:16:14 <Toxaris> I think it enables an important use case for instances
14:16:14 * ari finishes mopping up after adding Debian's unstable release to sources.list *did* foul things up pretty well, and decides to just build ghc 6.6.1 from source
14:16:31 <DRMacIver> Lemmih: Ok. I think I was aware of that. Toxaris was making it sound like it was more severe. :)
14:16:45 <DRMacIver> (But yes, that is almost as bad)
14:16:54 <monochrom> You see all those Control.Monad.*.Instances are trying to work around the problem.
14:17:35 <SamB> well, if you allowed to different Ord instances for a datatype in a single program... what happens if a Map with that datatype for its keys get's passed from one part of the program to the other?
14:17:47 <SamB> er.s/to different/two different/
14:18:11 <DRMacIver> I think that's a separate question...
14:18:54 <DRMacIver> But I imagine the type system should prevent the Map instances from escaping the scope in which their class instance is defined.
14:18:58 <SamB> seperate from what?
14:19:09 <monochrom> I think that's a separate question too.
14:19:19 <int-e> SamB: the Ord instance will be kept and passed along with the map
14:19:22 <sjanssen> what is the question?
14:19:32 <apfelmus> int-e: hi :)
14:19:37 <int-e> SamB: at least with a dictionary passing implementation like ghc
14:19:41 <DRMacIver> SamB: From implicit exporting of instances.
14:20:18 <SamB> int-e: huh?
14:20:27 <SamB> Map isn't existentiaal!
14:20:30 <DRMacIver> It seems obvious that if you export something like that you need to export the instances which allow its type constraints to be satisfied.
14:20:51 <DRMacIver> This isn't a hard thing for the compiler to enforce. :)
14:20:53 <int-e> SamB: yes but whenever you write a function using the ord instance of that map it'll have Ord key => ... as its signature
14:21:00 <sjanssen> DRMacIver: but how do you distinguish between different sorts of 'Ord Int' contexts?
14:21:12 <int-e> SamB: and *that* ord dictionary will match that of the map
14:21:15 <DRMacIver> sjanssen: You don't distinguish between them. You isolate them so that you don't have to.
14:21:20 <sjanssen> DRMacIver: how?
14:21:29 <DRMacIver> 23:20 < DRMacIver> It seems obvious that if you export something like that you need to export the instances which allow its type constraints to be satisfied.
14:21:38 <Syzygy-> > let (...) a = [a ..] in (2::Int)...
14:21:38 <lambdabot>  Parse error
14:21:50 <int-e> SamB: hmm.
14:22:06 <int-e> SamB: I guess I'm wrong and you can break that.
14:22:09 <int-e> sorry.
14:22:25 <DRMacIver> i.e. any case where I've been exposed to an Int which uses the 'wrong' Ord I must also have imported the Ord instance from that context.
14:22:35 <DRMacIver> If this creates an ambiguity then the compiler will yell at me. :)
14:22:45 <DRMacIver> Hm
14:22:51 <apfelmus> int-e: i thought about the rational number arithmetic. it boils down to (not) find a gödel-numbering  g : Q -> Z
14:22:53 <SamB> DRMacIver: really?
14:22:55 <sjanssen> I don't see how this is better than the current system
14:22:59 <SamB> how will it notice?
14:23:02 <DRMacIver> I guess this causes problems if I try to pass an Int to a function in that library.
14:23:07 * SamB was talking about the current system
14:23:13 <int-e> in other words, the implicit export of instances is essential to ensure correctness of haskell programs. whew I hadn't realized that.
14:23:47 <apfelmus> int-e: g : Q -> Z+ with g(a+b) <= f(g(a),g(b))
14:23:57 <DRMacIver> SamB: Yeah. There are problems with my position. It doesn't work like I thought it did.
14:24:11 <sjanssen> int-e: with associated types you could probably create overlapping instances that break the type system and cause segfaults :)
14:24:12 <SamB> int-e: I think you can have that problem *now*, if you want it
14:24:32 <apfelmus> g being injective and f a binary function that is multiplication in worst and addition in the best case
14:24:32 <int-e> sjanssen: fun ;)
14:24:51 <DRMacIver> SamB: I was only worying about things like exporting a Map Int Foo, which what I'm suggesting does fix, but cases like exporting an Ord a => a -> Foo would still break in subtle manners. :-/
14:25:13 <DRMacIver> I'm sure type classes can be made to work in a properly scoped manner, but I think it requires a serious revamp. Maybe something like modular type classes?
14:25:23 <sjanssen> DRMacIver: and this is why Haskell is designed in this way :)
14:25:36 <kksm19820117> !rcrackvn [Addison_Wesley]_Xml_Schema_Complete_Reference,_The_[,_02,_0_672_32374_5]_[Programming]__chm.rar
14:25:40 <kksm19820117> Oopd
14:25:41 <DRMacIver> sjanssen: It's still gross. :)
14:25:46 <DRMacIver> sjanssen: It's just gross with a good reason.
14:25:50 <Syzygy-> ...
14:25:57 <sjanssen> besides, I find it much easier to consider instances as fundamental properties of a type
14:26:01 <int-e> apfelmus: you can take one of the binary tree encodings of Q+
14:26:19 <apfelmus> int-e: binary tree encoding?
14:26:35 <sjanssen> instances should implement the One True Behavior for a given type
14:26:48 <int-e> > let q = 1 : q >>= \x -> [x+1, 1/(x+1)] -- something like that.
14:26:48 <lambdabot>  Parse error
14:26:49 <DRMacIver> Mm.
14:27:01 <Toxaris> sjanssen: How to do that for classes like Ord?
14:27:11 <SamB> I could probably write a program that fails dramatically in this way using GHC 6.6
14:27:13 <DRMacIver> The problem with that is that there are cases where there isn't a One True Behaviour.
14:27:18 <DRMacIver> Err.. indeed, like Ord. :)
14:27:47 <DRMacIver> Hm. Actually, maybe what I thought was a problem wasn't one.
14:27:57 <apfelmus> > let q = 1 : (q >>= \x -> [x+1, 1/(x+1)]) in q
14:27:58 <lambdabot>  [1.0,2.0,0.5,3.0,0.3333333333333333,1.5,0.6666666666666666,4.0,0.25,1.333333...
14:28:04 <sjanssen> Toxaris: how many types have multiple reasonable interpretations for Ord?
14:28:24 <DRMacIver> sjanssen: All of them.
14:28:39 <Toxaris> sjanssen: Wich type hasn't?
14:28:39 <DRMacIver> Well, all of them which have a reasonable interpretation for Ord. :)
14:28:45 <sjanssen> DRMacIver: Int has one reasonable Ord
14:28:47 <SamB> but it's possible that GHC would notice that I had two Ord instances
14:28:54 <DRMacIver> sjanssen: Reverse ordering.
14:29:06 <Toxaris> Why is 0 < 1 more reasonable then 1 < 0?
14:29:30 <Toxaris> (except for syntax?)
14:29:34 <sjanssen> DRMacIver: 'reverse' is obviously less important than the usual sort -- that's why the usual comparison isn't called reversed!
14:29:45 <sjanssen> Toxaris: hundreds of years of tradition in mathematics
14:30:08 <sjanssen> besides, we can always introduce newtype wrappers when we need the reversed comparison
14:30:24 <Toxaris> let me rephrase my question: what makes 0 < 1 more reasonable then 1 > 0?
14:30:42 <DRMacIver> It's bizarre. I keep hearing "Why do we need functions when we can define single method objects?" in #haskell. ;)
14:30:49 <SamB> Toxaris: those are the same thing
14:30:52 <Cale> Toxaris: It's more readable because things are in order.
14:31:01 <monochrom> Suppose you implement the lambda calculus. It is likely you like three different Eq's for it: exact textual match ("deriving Eq"), alpha-equivalence, beta-equivalence.
14:31:07 <Cale> Usually we like things to be listed in increasing order.
14:31:17 <Toxaris> SamB: they arent, clearly (>) \= (<)
14:31:29 <apfelmus> int-e: ah, thanks for the hint! i had a very faint memory in mind that something like this existed.
14:31:41 <SamB> Toxaris: you flipped the args too though
14:31:44 <apfelmus> http://en.wikipedia.org/wiki/Stern-Brocot_tree
14:31:46 <lambdabot> Title: Stern-Brocot tree - Wikipedia, the free encyclopedia
14:32:27 <SamB> anyway, I don't see how "tradition" leads to "one true order"
14:32:38 <SamB> I mean why does 'a' come before 'b' anyway?
14:32:57 <int-e> SamB: you're right. it's possible to break it right now
14:33:07 <sjanssen> SamB: a's Unicode code point is lower than b's
14:33:22 <Toxaris> SamB: "mathematical tradition" has two orders for natural numbers: < an >. why should one of them be accessible easily in Haskell, but not the other?
14:33:34 <SamB> sjanssen: it's not true in C
14:33:49 <monochrom> Why do we use English? 為甚麼我們用英文?   (duck)
14:33:57 <SamB> basically it's a historical accident
14:33:59 <sjanssen> SamB: a > b in C?
14:34:01 <SamB> monochrom: exactly!
14:34:17 <SamB> sjanssen: C doesn't say
14:34:28 <sjanssen> SamB: ah, but Haskell does
14:34:31 <sjanssen> (I think)(
14:34:34 <SamB> sjanssen: yes, it does
14:34:37 <int-e> SamB: http://paste.lisp.org/display/44116
14:34:37 <SamB> you are correct
14:35:00 <SamB> but I'm saying that just because the standard says a thing is one way doesn't make it the "one true" way ;-)
14:35:02 <monochrom> why do we exist? :)
14:35:08 <int-e> SamB: you can replace the cmpB and cmpC functions by stuff working on a Map A something
14:35:21 <Toxaris> monochrom: to think about our existence
14:35:36 <monochrom> great answer :)
14:35:39 <DRMacIver> Hm. I think I've reconvinced myself that my suggestion is ok.
14:35:44 <sjanssen> I exaggerate a bit when I say "One True" -- but I don't think anyone is seriously advocating that the default Int comparison be flipped
14:36:11 <sjanssen> there usually is a single, pragmatic, choice that reasonable people can agree on
14:36:18 <monochrom> Yeah, I can't believe why you people are seriously arguing over "One True".
14:36:23 <Toxaris> sjanssen: it would be nice if I could somehow select the other one locally
14:36:25 <SamB> sjanssen: no, nobody is
14:36:32 <sjanssen> Toxaris: newtypes
14:36:32 <DRMacIver> sjanssen: I would seriously advocate that you should be able to flip the default Int comparision for a local definition.
14:36:43 <sjanssen> DRMacIver: newtypes :)
14:36:50 <DRMacIver> sjanssen: Doing it with newtypes gets really cumbersome.
14:36:59 <jedai> @src (\\)
14:36:59 <lambdabot> (\\) = foldl (flip delete)
14:37:02 <SamB> but there are other types where it might be more reasonable to argue
14:37:05 <int-e> module A (A (A)) where  looks sort of silly
14:37:24 <ddarius> Multiple namespaces ho1
14:37:28 <DRMacIver> sjanssen: This is just the standard "I want behaviour X." "Why would you want behaviour X when you can fake it in a more cumbersome manner with feature Y?" argument.
14:37:29 <Saul_> This is pretty cumbersome: (create (3::Integer))::Page Integer Integer
14:37:37 <jedai> So \\ is in O(n*m) complexity ?
14:37:51 <SamB> DRMacIver: your suggestion is not safe
14:38:09 <sorear> jedai: Yes.
14:38:15 <DRMacIver> SamB: Can you give me an example?
14:38:19 <SamB> implicit parameters are bad enough already, we don't need dynamic instances
14:38:40 <sorear> jedai: Linked lists aren't great data structures; maybe you wanted sets?
14:38:49 <sorear> :t (Data.Set.\\)
14:38:55 <monochrom> Could we all please hijack #perl and debate over "the pros and cons of having One True hashing function for strings"? :)
14:38:57 <jedai> sorear: Oh, I know Set
14:38:57 <lambdabot> forall a. (Ord a) => Data.Set.Set a -> Data.Set.Set a -> Data.Set.Set a
14:39:01 <Toxaris> Prelude defines stuff like sortBy to allow explicit passing of non-standard instance-record-like things. is this considered a good design pattern to overcome this problem? is it possible to automate the construction of fooBy functions?
14:39:02 <Pupeno> What is the current status of binary IO in Haskell? Last time I checked, more than half a year ago, (Bulat's) Streams where the current cool library, is it still that or a new one?
14:39:12 <Saul_> Oh I can actually shorten it to: create 3 ::Page Integer Integer, but even then
14:39:23 <sorear> Pupeno: We use lazy bytestrings now
14:39:25 <sorear> @where fps
14:39:25 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
14:39:27 <sjanssen> DRMacIver: consider Data.Map.union.  What should happen when you merge maps constructed with two different Ord dictionaries?
14:39:42 <sorear> Pupeno: don't bother downloading it, it's included with GHC
14:39:55 <Pupeno> sorear: excellent! :)
14:39:57 <jedai> sorear: It's just that I realized I was probably in O(n^2) rather than O(n ln n) in one of my program... Let's forget it !
14:40:01 <SamB> sjanssen: I was just going to ask about what heappens wheen I build one with one instance and read it with the other
14:40:05 <Toxaris> Saul_: Yes, it's cumbersone, but in real code, you wouldn't use numeric literals, but some other datatype
14:40:07 <DRMacIver> sjanssen: I've already answered that one. :)
14:40:08 <sorear> sure
14:40:20 <sjanssen> SamB: equally problematic
14:40:20 <Pupeno> Is it defined wether Haskell' will contain some binary IO and which one it is going to be?
14:40:29 <DRMacIver> sjanssen: If you're exporting a term of type Data.Map Foo Bar then you have to export the Foo instance.
14:40:35 <SamB> sjanssen: but yours is less easily explained away
14:40:39 <DRMacIver> sjanssen: Ord instance for Foo I mean.
14:40:42 <apfelmus> int-e: oh, and i can prove that there is no injective function g :: Q -> Z+ with g(a+b) <= g(a)+g(b).
14:40:45 <Saul_> Toxaris: Ok so it's just annoying during testing?
14:40:48 <Heffalump> so you get an error if you import two conflicting instances?
14:40:56 <DRMacIver> SamB: Same answer.
14:40:57 <Toxaris> Saul_: hopefully
14:40:57 <Heffalump> that breaks modularity something chronic, IMO
14:41:06 <SamB> DRMacIver: you haven't touched the problem at all
14:41:19 <sjanssen> DRMacIver: okay, what if I export x :: Bug; data Bug = Bug (Map Foo Bar)
14:41:21 <DRMacIver> Heffalump: Why is that any better than what happens if you define two conflicting instances now?
14:41:22 <int-e> apfelmus: for all a b you mean
14:41:31 <apfelmus> int-e: yes
14:41:40 <Saul_> Toxaris: Ok, I'll finish my other functions to incorporate the changes (both the more generic Diffable and the removal of Creation)
14:41:41 <DRMacIver> Heffalump: err. Any worse.
14:42:04 <Saul_> Toxaris: It should be better then, more elegant
14:42:19 <DRMacIver> SamB: Sure. If the problem can't occur, I don't have to touch it. :)
14:42:35 <sjanssen> DRMacIver: you haven't convinced me that the problem can't occur
14:43:08 <DRMacIver> sjanssen: Can you get access to the Map instance from Bug? If you can, you must have exported a Map Foo Bar. If you can't, no bug occurs.
14:43:32 <SamB> there is no such thing as a Map instance...
14:43:40 <DRMacIver> Yes, sorry.
14:43:49 <DRMacIver> I'm misusing 'instance' here. Too much Java. :(
14:44:02 <sjanssen> DRMacIver: yes, I've also exported the 'Bar' constructor so I can deconstruct 'x'
14:44:03 <DRMacIver> Can you get access to a term of type Map Foo Bar from Bug.
14:44:10 <apfelmus> int-e: this means that adding rational numbers must produce more bits (as gödel number) than the sum of their (however cleverly chosen) gödel numbers
14:44:16 <sjanssen> DRMacIver: how does the compiler figure out that I'm able to get access to Bug?
14:44:17 <DRMacIver> sjanssen: Well then, you've exported a Map Foo Bar, haven't you?
14:44:47 <sjanssen> DRMacIver: no, I am not exporting anything that has the type 'Map Foo Bar'
14:44:50 <DRMacIver> sjanssen: In order to export the constructor, you've had to export a type involving Map Foo Bar.
14:45:03 <sjanssen> DRMacIver: okay, now we see involving, getting closer :)
14:45:03 <SamB> also how does the compiler know that Map Foo Bar is dangerous?
14:45:06 <Heffalump> DRMacIver: because you are encouraged not to do that by the way they work now
14:45:06 <apfelmus> int-e: the size of the gödel number in bits being a lower bound to calculations with that number
14:45:13 <Heffalump> your idea positively encourages such a definition
14:45:32 <sjanssen> SamB has another point -- how does the compiler now that Map and Ord are related?
14:45:35 <Heffalump> if you want explicit instances, use implicit parameters
14:45:58 <DRMacIver> sjanssen: Err. Because Map has an (Ord a) constraint?
14:46:02 <ddarius> There was a paper on named instances a while back.
14:46:06 <sjanssen> @src Map
14:46:06 <lambdabot> Source not found. My mind is going. I can feel it.
14:46:14 <sjanssen> DRMacIver: I'm not so sure that it does
14:46:19 <ddarius> It should be mostly simulablep
14:46:20 <apfelmus> int-e: the next thing would be to see where g(a+b) <= alpha * (g(a) + g(b)) is possible, alpha being a fixed number. So that summation may add a constant number of bits each time
14:46:26 <apfelmus> *whether
14:46:46 <SamB> Heffalump: you suggest this because it exhibits the problem of "where do I get the instance"?
14:46:49 <sjanssen> DRMacIver: just checked, Map doesn't have an Ord constraint
14:47:00 <DRMacIver> Hm
14:47:02 <DRMacIver> So it doesn't.
14:47:04 <Heffalump> SamB: I don't follow.
14:47:22 <Heffalump> DRMacIver/sjanssen: class constraints on types are useless in H98, so people generally omit them.
14:47:23 <SamB> Heffalump: why are you suggesting that he use iplicit parameters?
14:47:42 <SamB> Heffalump: worse than useless, I think
14:47:58 <Heffalump> SamB: because they provide a way of making dictionaries explicit, without all the syntactic overhead of explicitly passing them everywhere.
14:48:09 <SamB> Heffalump: oh.
14:48:12 <DRMacIver> Ah. It appears that Map provides some ways of creating maps which don't need Ord.
14:48:18 <Heffalump> but you still have the problem of taking a union.
14:48:30 <DRMacIver> Yes, that does rather cause problems. :)
14:48:57 <monochrom> > empty :: Data.Set.Set (IO() -> ())
14:49:00 <ddarius> E.g. empty
14:49:05 <lambdabot> Terminated
14:49:09 <DRMacIver> ok. You guys are right. I'm wrong. I still think there's a way of making this work nicely (I really need to properly sit down and understand the modular type classes at some point), but what I've suggested isn't it.
14:49:24 <hpaste>  sorear pasted "hpaste works :)" at http://hpaste.org/1572
14:49:25 <SamB> > empty :: Data.Set.Set (IO() -> ())
14:49:26 <lambdabot> Terminated
14:49:26 <DRMacIver> modular type classes paper.
14:49:35 <sjanssen> @karma sorear
14:49:35 <lambdabot> sorear has a karma of 46
14:49:43 <Heffalump> DRMacIver: why do you think newtype is too costly to use?
14:49:44 <SamB> > empty :: Data.Set.Set (Int -> Int)
14:49:45 <lambdabot> Terminated
14:49:46 <hpaste>  sjanssen annotated "hpaste works :)" with "sorear++" at http://hpaste.org/1572#a1
14:49:51 <SamB> > empty :: Data.Set.Set ()
14:49:51 <sjanssen> @karma sorear
14:49:51 <lambdabot> sorear has a karma of 46
14:49:52 <lambdabot> Terminated
14:49:56 <sjanssen> pssh
14:50:02 <SamB> hmm.
14:50:03 <sjanssen> sorear++
14:50:03 <DRMacIver> Heffalump: It's not costly to use except syntactically. :)
14:50:07 <SamB> > empty
14:50:09 <lambdabot> Terminated
14:50:10 <Figs> hey, I got a weird idea guys
14:50:12 <Heffalump> well, yes, syntactically costly.
14:50:17 <SamB> @help let
14:50:17 <lambdabot> let <x> = <e>. Add a binding
14:50:22 <sorear> Saizan++ for finding the bug
14:50:32 <monochrom> @type empty
14:50:35 <lambdabot>     Ambiguous occurrence `empty'
14:50:35 <DRMacIver> Heffalump: Take for example sorting a list in reverse order (yes, I know you can use sortBy. It's just a hypothetical example).
14:50:35 <lambdabot>     It could refer to either `empty', imported from Control.Applicative
14:51:01 <DRMacIver> Heffalump: In order to do this I need to do map unNewType $ sort $ map MyNewTypeConstructor myList
14:51:08 <hpaste>  int-e pasted "using inconsistent class instances" at http://hpaste.org/1573
14:51:14 <Saul_> Toxaris: http://paste.lisp.org/display/44111#2
14:51:17 <int-e> it *does* work, nice.
14:51:28 <Heffalump> no, cos your new type has an Ord instance, that being the whole point..
14:51:36 <Heffalump> oh, sorry, I see.
14:51:49 <monochrom> > Data.Set.empty :: Data.Set.Set Int
14:51:52 <lambdabot>  fromList []
14:51:58 <monochrom> > Data.Set.empty :: Data.Set.Set (Int -> Int)
14:52:01 <lambdabot>  fromList []
14:52:11 <sorear> Saul_: hpaste *is* back :)
14:52:11 <DRMacIver> When I start with my old type and want my old type back at the end, you end up having to do all sorts of ugly intertwining to get your newtype in the right place and then remove it afterwards.
14:52:17 <Heffalump> I think you need a more convincing example.
14:52:38 <Saul_> sorear: Maybe I'll try it out later :)
14:53:04 <SamB> int-e: now you need to make a Map A String in module B, and look things up in it in module C ;-)
14:53:14 <DRMacIver> I can't be bothered to come up with one. :) I think this demonstrates the point - in order to use my newtype I had to map it into the structure. In order to get the original type back I then had to map unnewtype.
14:53:28 <int-e> SamB: indeed.
14:53:37 <Saul_> sorear: Maybe you could look at my code?
14:53:39 <DRMacIver> In particular I needed to define an unnewtype function and do all sorts of wrapping and unwrapping.
14:53:40 <ihope> Are you discussing something really complicated?
14:53:42 <int-e> SamB: but this was enough to demonstrate the point really
14:54:00 <SamB> int-e: but not close enough to SIGSEGV
14:54:01 <Figs> how about a language where you pass the state from function to function? (instead of passing variables into the function, you just import a state pointer modify the data there and then return the state pointer to the next statement implicitly?
14:54:10 <Figs> )
14:54:17 <DRMacIver> The wrapping and unwrapping weren't too bad here admittedly, but if I'd e.g. wanted to do things with a [[[a]]] or something equally complicated it would have turned into a real mess.
14:54:23 <int-e> SamB: even with Data.Map it won't segfault :)
14:54:27 <DRMacIver> It's enough to make one want to unsafeCoerce. ;)
14:54:28 <SamB> perhaps if we did it with Ix?
14:54:34 <SamB> int-e: yes but it's closer
14:54:41 <Figs> sort of like a closure
14:54:45 <sorear> Saul_: what's the problem?
14:54:55 <SamB> DRMacIver: we *have* unsafeCoerce
14:54:57 <Heffalump> you could make a safeCoerce method in a type class
14:55:01 <DRMacIver> SamB: Yes, I know.
14:55:12 <DRMacIver> SamB: And I was saying "it's enough to make one want to use it".
14:55:15 <Figs> Or is this just  a stupid idea?
14:55:26 <DRMacIver> (Although I wasn't being terribly serious)
14:55:28 <SamB> sorear: have you figured out how to use newtypes and type families to implement unsafeCoerce itself yet?
14:55:33 <Saul_> sorear: There isn't really a problem, but maybe you have some tips to make it better (I'm quite new at haskell so I think it would help)
14:56:03 <shachaf> Figs: You can do it in Haskell.
14:56:07 <Figs> yes
14:56:14 <Figs> in fact, that's where I got the idea
14:56:24 <Figs> but I mean, writing in a C/C++ style
14:56:45 <shachaf> Figs: What do you mean by C/C++ style?
14:56:50 <Saul_> sorear: It's code that implements a wiki for generic datatypes (given there are Diffable and Initiable instances for them)
14:57:03 <Figs> the syntax would be able to be very similar to C
14:57:16 <SamB> Figs: what you describe reminds me of the State monad
14:57:19 <shachaf> Figs: Haskell with do-notation isn't similar enough?
14:57:23 <Figs> no
14:57:25 <Figs> :P
14:57:26 <SamB> though I havee a feleing you meant something much diifferent
14:57:43 <Figs> Haskell at all isn't familiar to most people with a C-like language background
14:57:44 <DRMacIver> Heffalump: I mean, this isn't too awful. But it means that type classes end up having a very limited scope of use and that one ends up implementing lots of fooBy functions and leaving the type classes thin on the ground in order to write decently generic code.
14:58:22 <Heffalump> well, I don't think that's true, because I write a lot of code with type classes
14:58:24 <Figs> I got the idea for this from monads
14:58:33 <Figs> which is why it'll sound similar
14:58:50 <Figs> effectively, it should let you import state into certain functions
14:59:00 <Figs> and keep others purely relational
14:59:22 <Heffalump> You just have to accept that there's a trade-off. Either you get implicit selection of the instances and it's costly to select something else, or you have explicit selection and there's a (smaller) cost for all uses.
15:00:04 <shachaf> > let add1 :: State Int (); add1 = do { x <- get; put (x + 1) } in execState add1 5
15:00:06 <lambdabot>  6
15:00:13 <DRMacIver> I've never liked making compromises. :)
15:00:13 <SamB> DRMacIver: you must be one of those pesky ML users
15:00:32 <DRMacIver> SamB: By training anyway. I'm rather out of practice.
15:00:36 <shachaf> Figs: And your new language will be familiar to people with a C-like language background?
15:00:41 <DRMacIver> SamB: What makes you say that in this instance though? :)
15:00:48 <Figs> well, that's the hope
15:00:57 <Heffalump> why not program in machine code then? Otherwise you are compromising away control.
15:00:59 <SamB> DRMacIver: well, what you want reminds me of some feature that ML is reported to have...
15:01:05 <Heffalump> (etc etc)
15:01:09 <SamB> Heffalump: that isn't generic enough
15:01:12 <sorear> SamB: <interactive>: internal error: stg_ap_v_ret
15:01:23 <SamB> I think he wanted the other extreme
15:01:24 <Figs> it's not particularly different from
15:01:28 <Figs> object.foo()
15:01:30 <Heffalump> there is no other extreme
15:01:31 <Figs> object.blah()
15:01:43 <Heffalump> no one language is more abstract than all the others
15:01:49 <Figs> which will be familiar to people with a C++ background
15:01:54 <int-e> you should start by designing your own microprocessor.
15:01:59 <SamB> Heffalump: well, another extreme
15:02:01 <DRMacIver> I don't want 'more abstract' I want 'the abstractions I like' ;)
15:02:12 <ddarius> int-e: You should start by designing your own physics.
15:02:22 <Heffalump> what you need is intentional programming.
15:02:24 <SamB> doesn't ML have some kind of "first class modules"?
15:02:25 <DRMacIver> SamB: Yes, there's a certain fairly strong connection between this and higher order modules.
15:02:27 <int-e> DRMacIver: you can use unsafeCoerce# if you want the best of both worlds ;)
15:02:29 <Heffalump> SamB: yes.
15:02:31 <sorear> SamB: Yes.
15:02:33 <Figs> as opposed to accidental?
15:02:42 <SamB> DRMacIver: see, it seems like you want those
15:02:42 <int-e> ddarius: hmm. sounds like fun but a little unrealistic :)
15:02:53 <DRMacIver> SamB: Hence the "modular type classes" paper I mentioned a while back. :)
15:02:58 <SamB> oh
15:03:33 <DRMacIver> SamB: And yes, I definitely want first class modules unified with type classes.
15:03:39 <DRMacIver> While I'm at it I want a pony. And a flying car.
15:03:57 <SamB> would you settle for the pony and the car?
15:04:15 <int-e> . o O ( Freak Accident: Pony got smashed by falling car. )
15:04:19 <Figs> O.o
15:04:20 <DRMacIver> Sure. :)
15:04:35 <Figs> Freak accident: Pony transforms into a flying car!
15:04:52 <Figs> two for one deal!
15:04:54 <hpaste>  sorear pasted "unsafeCoerce via #1496, as requested by SamB " at http://hpaste.org/1574
15:05:00 <Figs> only $99,999,999,999.99!
15:05:28 <glguy> can you declare things that modules have in common in ML to make it meaningful for them to be interchangable?
15:05:30 <Figs> "Cheap" :)
15:05:40 <SamB> sorear: and that's fully general?
15:06:00 <sorear> SamB: It's just as general as 'foo = unsafeCoerce#'
15:06:23 <SamB> neato
15:06:23 <DRMacIver> glguy: You can define sharing constraints between modules I think. It's been a long time since I've done much with ML though, and I never really (ab)used its module system to any great extent.
15:06:30 <SamB> you should add that to the bug ;-)
15:06:43 <sorear> SamB: of course, that's LESS general than #define foo unsafeCoerce#.
15:06:52 <SamB> sorear: of course.
15:07:05 <SamB> pesky Haskell only allowing *-based kinds
15:07:07 <sorear> don't you just love GHC's kind system? :)
15:07:49 <Saul_> sorear: I'll take it that you don't have any pointers for me (and/or haven't looked at the code)?
15:07:55 <olsner> what's a kind?
15:08:06 <int-e> @kind (->)
15:08:08 <Figs> the opposite of a mean :)
15:08:08 <lambdabot> ?? -> ? -> *
15:08:16 <Saul_> sorear: That's fine of course, just let me know
15:08:17 <Philippa> glguy: that's what signiatures are about
15:08:21 <sorear> @type Foreign.Ptr.Ptr -- Saul:
15:08:26 <lambdabot> Not in scope: data constructor `Foreign.Ptr.Ptr'
15:08:30 <sorear> oh
15:08:32 <sorear> doh
15:08:33 <SamB> I had to use unsafePerformIO to implement foreign export in Jhc because it's IO is also of kind * -> *
15:08:33 * Figs waits for the groans :P
15:08:37 <sorear> not that kind of pointer
15:08:45 <wolverian> heh, mathematica's language is quite cute. having syntax level pattern matching is surprisingly handy.
15:08:47 <int-e> Figs: I don't know what you mean.
15:08:57 <Figs> :P
15:09:04 <SamB> sorear: I've never  ever heard of a pointer of kind * -> *
15:09:07 <Figs> a kind? opposite of a mean? heheh... :|
15:09:13 <sorear> SamB: I have.
15:09:16 <monochrom> I am kind. You are mean.
15:09:34 <Figs> :P
15:09:36 <Figs> aww
15:09:40 <SamB> sorear: okay, you've been talking to oleg again haven't you?
15:09:42 <Figs> thanks?
15:09:48 * Figs puts on black hat
15:09:50 <sorear> Not at all.
15:09:50 <Saul_> I've been here for a few hours, but the Foreign.Ptr thing already got pretty old
15:09:59 <sorear> data Ptr a = Ptr Addr#
15:10:00 <Figs> nifty guitar riff plays in background
15:10:09 <sorear> SamB: see, it's just a phantom type!
15:10:26 <sorear> SamB: in C, (*) takes a type argument, it's effectively higher kinded
15:10:30 <Saul_> I guess I'll just ask for tips instead of pointers from now on
15:10:52 <SamB> sorear: a pity it takes the type argument on *both sides*
15:11:18 <sorear> Saul_: Actually, this was an honest brain error. :)
15:11:27 <SamB> Saul_: good idea
15:11:28 <sorear> Saul_: Have you looked at flippi?
15:11:47 <Saul_> sorear: flippi?
15:12:00 <SamB> sorear: actually, that's a much better excuse for having got the wrong kind ;-)
15:12:07 <sorear> @google flippi site:flippac.org
15:12:09 <lambdabot> http://www.flippac.org/projects/flippi/
15:12:09 <lambdabot> Title: Flippi: a Wiki clone written in Haskell
15:12:40 <SamB> > nullPtr :: Foreign.Ptr.Ptr ()
15:12:41 <lambdabot>      Not in scope: type constructor or class `Foreign.Ptr.Ptr'
15:12:44 <SamB> aww.
15:13:09 <Saul_> sorear: No, I haven't seen it yet, does it work for generic data types?
15:13:22 <sorear> Probably not.
15:13:29 <SamB> anyway now I'm for some reason waiting for Jhc to compile the prelude
15:14:11 <Saul_> sorear: Too bad, because that is what I need
15:16:48 <Toxaris> Saul_: is this some learning-haskell-toy-project or something real?
15:17:15 <Saul_> Toxaris: Hopefully something real
15:17:32 <Saul_> Toxaris: I want to use it for a website I'm building
15:18:31 <Saul_> Toxaris: But since I'm also relatively new to haskell it's also for learning it
15:19:00 <Toxaris> Saul_: it may be easier to define your own language for declaring these wiki data types
15:19:12 <Toxaris> instead of using haskell as a meta language
15:19:16 <wolverian> does manual memory allocation have any use outside FFI?
15:20:22 <Saul_> Toxaris: Maybe, but I want to do the rest of the website in haskell as well
15:20:42 <Lemmih> wolverian: Data.Binary uses manual memory allocations.
15:20:48 <wolverian> Lemmih, thanks.
15:20:49 <Toxaris> Saul_: sure
15:20:49 <Figs> afk
15:20:57 <Toxaris> but what about different abstraction layersß
15:21:02 <Toxaris> "layers?"
15:21:19 <Saul_> Toxaris: What do you mean?
15:21:42 <Saul_> More concretely?
15:22:06 <sorear> Lemmih: it does?
15:22:27 <Lemmih> sorear: It sure does.
15:22:42 <sorear> Lemmih: last I checked it used mallocForeignPtrBytes, which just allocates pinned garbage collected memory
15:23:50 <Lemmih> sorear: And that's not a manual memory allocation?
15:24:11 <sorear> No more so than (:) is
15:24:17 <sorear> point taken
15:24:38 <SamB> sorear: but with (:) you don't have to say "how much", and it isn't pinned either...
15:24:49 <SamB> er.
15:24:52 <SamB> "this much"
15:25:38 <sorear> In Hugs (:) allocates pinned memory.
15:25:46 <Lemmih> Manual allocation doesn't necessarily mean manual deallocation.
15:25:54 <SamB> sorear: hugs is written in *C*
15:26:15 <sorear> Lemmih: Hence, point taken.
15:26:17 <SamB> in JHC, that allocates pinned memory too...
15:26:31 <sorear> SamB: So is old GHC.
15:26:45 <SamB> what?
15:26:47 <sorear> SamB: well, the RTS and post-GHC code.
15:26:59 <SamB> oh, that.
15:27:07 <sorear> SamB: -fvia-C -unreg doesn't give you pinned (:)
15:27:08 <Lemmih> Does JHC have have Data.ByteString/Data.Binary?
15:27:32 <sorear> Lemmih: No, JHC uses a different and incompatible syntax for {-# RULES #-}
15:27:43 <sorear> Lemmih: the build failed pretty fast
15:27:57 <SamB> hmm, does GHC support RULES_GHC
15:27:57 <SamB> ?
15:29:29 <SamB> JHC supports RULES_JHC
15:29:50 <SamB> Lemmih: does JHC even have a user?
15:31:35 <Lemmih> SamB: It would have me if it had Data.ByteString. (:
15:32:09 <SamB> Lemmih: I don't think it's supposed to have users yet... it isn't even *usable* yet
15:35:38 <wolverian> is jhc still being worked on?
15:35:44 <SamB> yeah
15:35:59 <hpaste>  Toxaris pasted "random idea for Saul_" at http://hpaste.org/1575
15:36:07 <SamB> right now John is working on seperate compilation and RAM usage
15:36:53 <Toxaris> Saul_: the idea is to seperate between representation of Haskell data and seperation of wiki contents
15:37:00 <wolverian> ah, I knew I saw that here. nice.
15:37:16 <Toxaris> Saul_: wich is less mighty, of course, but maybe easier to implement
15:38:06 <Toxaris> Saul_: but if it's your first Haskell project, maybe you should start by implementing your site using an approbiate framework, and not by writing your own framework, but what do I know
15:39:09 <Saul_> Toxaris: Well if there are any good haskell frameworks out there, I'll happily use my wiki code in that, it would save me a lot of time
15:40:05 <Saul_> Toxaris: But I think I like my idea a little better than yours
15:40:27 <Toxaris> Saul_: no prob, I like your's better then mine, too
15:40:58 <Toxaris> expecially if it gives persistence & web gui for free when finished
15:41:04 <Saul_> I've looked around a little for web frameworks, but I couldn't really find any, does anyone here knoe a good one?
15:41:27 <zeeeee> i'm aware of lambdabot's @tell, but is there a way to get it to msg *me* when someone signs on?
15:41:35 <SyntaxNinja> Igloo: alive?
15:41:42 <Igloo> Yup
15:41:58 <Korollary> zeeeee: your irc client may be able to do that
15:42:06 <SyntaxNinja> Igloo: I see there's no libghc6-html-dev in unstable... I apologize for not knowing offhand, but can you tell me what package replaces this?
15:42:35 * SyntaxNinja is building darcs finally ;)
15:42:55 <Igloo> SyntaxNinja: Are you sure?
15:43:03 <Saul_> Toxaris: It's nice to know that you like it
15:43:08 <zeeeee> Korollary: would you know off the top of your head for xchat?
15:43:19 <Igloo> SyntaxNinja: http://packages.debian.org/cgi-bin/search_packages.pl?searchon=names&version=all&exact=1&keywords=libghc6-html-dev thinks that it still exists
15:43:21 <SyntaxNinja> Igloo: I guess not, but pbuilder complains, and I don't see it here: http://packages.debian.org/cgi-bin/search_packages.pl?keywords=html-dev&searchon=names&subword=1&version=stable&release=all
15:43:22 <lambdabot> Title: Debian -- Debian Package Search Results, http://tinyurl.com/2luktk
15:43:23 <lambdabot> Title: Debian -- Debian Package Search Results, http://tinyurl.com/2txyus
15:43:30 <Korollary> zeeeee: nope, sorry
15:43:42 <SyntaxNinja> oh, I made it stable only...
15:43:52 <Igloo> heh
15:43:58 <SyntaxNinja> must be the default
15:44:22 <SyntaxNinja> I wonder why pbuilder is complaining hmm
15:44:23 <Igloo> SyntaxNinja: Yeah, I think it is, but if you just go to packages.debian.org/packagename then it searches all
15:44:33 <Igloo> Have you done a pbuilder update?
15:45:24 <SyntaxNinja> yeah, but lemmy run ita gain and see if there are errors.  uchicago has been giving me trouble today
15:45:37 <SyntaxNinja> Igloo: OK thanks sorry 'bout that ;)
15:45:40 <Igloo> np  :-)
15:45:41 * SyntaxNinja will figure it out
15:46:03 * Igloo wonders why darcs uses html, anyway
15:46:10 <desp> @hoogle Monad m => (a -> m b) -> [a] -> m [b]
15:46:11 <lambdabot> No matches, try a more general search
15:46:16 <desp> @hoogle Monad m => (a -> m b) -> [a] -> m ()
15:46:17 <lambdabot> No matches, try a more general search
15:46:36 <desp> @hoogle Monad m => [a] -> (a -> m b) -> m [b]
15:46:37 <lambdabot> No matches, try a more general search
15:46:45 <Toxaris> Saul_: but that will not help you with implementing it...
15:46:51 <desp> I could've sworn there was a function like this
15:47:07 <desp> @type forM
15:47:09 <Toxaris> desp: mapM?
15:47:09 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
15:47:20 * desp slaps lambdabot
15:47:22 <Saul_> Toxaris: No, but I think I'm doing okay so far
15:47:49 <Saul_> Toxaris: I really could use a web framework like you said though
15:48:57 <chessguy> Saul_, i've been away. you're talking about a web framework to build your wiki thing on top of?
15:49:17 <Saul_> chessguy: Yes
15:49:38 <Toxaris> Saul_: I don't know about web frameworks in Haskell, but I think you need one :)
15:49:39 <chessguy> seems like WASH and hApps would be a good combination for that
15:49:51 <chessguy> @where happs
15:49:52 <lambdabot> http://happs.org
15:50:24 <wli> I mostly just wanted something like wordpress that was feasible to set up and that I wouldn't have to screw with.
15:50:26 <Lemmih> HAppS is about to get a major facelift.
15:50:39 <chessguy> http://haskell.org/haskellwiki/HAppS_tutorial
15:50:40 <lambdabot> Title: HAppS tutorial - HaskellWiki
15:50:45 <chessguy> Lemmih, oh really?
15:51:06 <chessguy> Saul_, also see http://www.informatik.uni-freiburg.de/~thiemann/WASH/
15:51:07 <sm> cool
15:51:10 <lambdabot> Title: Web Authoring System Haskell (WASH)
15:51:39 <jmelesky> is there a timeline for the HAppS facelift? i've been waiting for docs and code to sync up again
15:52:22 <Saul_> HApps seems useful
15:53:11 <Saul_> What's the difference between HApps and WASH?
15:53:55 <chessguy> Lemmih, are we talking an API facelift, a back-end facelift, a documentation facelift, or all of the above?
15:54:07 <Lemmih> chessguy: All of the above.
15:54:15 <chessguy> (back-end facelift....that sounds really strange)
15:54:38 <sorear> Lemmih: Is the new happs going to be better documented than the old one?
15:55:25 <chessguy> Saul_, i haven't played with wash, but i think it's front end to hApps' backend
15:55:30 <Lemmih> sorear: I hope so. The new design is vastly simpler than the current.
15:55:55 <sorear> so it'll be easier to understand than sequent calculus?
15:55:57 <sorear> *yay*
15:56:00 <Saul_> chessguy: ok
15:56:36 <jmelesky> i didn't realize WASH and HAppS were related
15:56:47 <chessguy> jmelesky, they're not
15:57:11 <SyntaxNinja> "              This option can optionally be omitted, and left blank, in  which
15:57:11 <SyntaxNinja>               case, this part is skipped."
15:57:14 <chessguy> jmelesky, i just meant hApps is back-end, whereas WASH is front end"
15:57:15 <SyntaxNinja> seems a little overly redundant
15:57:20 <SamB_XP> sorear: what's wrong with sequent calculus?
15:57:29 <jmelesky> ok. just checking.
15:58:01 <chessguy> i.e., WASH lets you specify content to deliver, and hApps delivers it
15:58:03 <sorear> SamB_XP: Nothing.  It's just that right now sequent-calculus theorem provers are easier to understand than happs demos.
15:58:13 <SamB_XP> ah.
15:58:21 <SamB_XP> that does sound a bit bad...
15:58:42 <chessguy> although...it seems WASH does have some actual server stuff
15:58:51 <Saul_> Is HAppS a webserver, or does it work with CGI?
15:58:53 <jmelesky> chessguy: WASH always struck me as a more "traditional" web framework -- glue together the SQL DB, do some middleware work, hook up with a separate server
15:59:11 <glguy> HAppS is a webserver
15:59:17 <jmelesky> Saul_: HAppS is a server. or, rather, you use it to write a server.
15:59:33 <SamB_XP> the "server" kind is better anyway
15:59:51 <chessguy> apparently WASH has a server, too. WSP
15:59:53 <sorear> Saul_: it's designed to work with mod_rewrite though, so it need not command an entire IP
16:00:22 <chessguy> jmelesky, i certainly am not the one to ask about traditional vs. modern web frameworks
16:00:25 <sorear> Saul_: scannedinavian.com and hpaste.org share an IP, with disambiguation based on apache vhosts and mod_rewrite
16:00:32 <SamB_XP> can apache dispatch requests to unix sockets?
16:00:44 <Saul_> ok
16:01:01 <chessguy> can hApps do load-balancing?
16:01:02 <sorear> SamB_XP: not afaik, but it can dispatch requests to localhost:$PORT_BLOCKED_WITH_IPTABLES
16:01:18 <SamB_XP> sorear: yes but there are only, what...
16:01:27 <Saul_> Can I use HAppS without WASH?
16:01:31 <sorear> Saul_: Yes.
16:01:38 <SamB_XP> > upperBound :: Word16
16:01:42 <lambdabot>   Not in scope: `upperBound'
16:01:45 <SamB_XP> > maxBound :: Word16
16:01:47 <lambdabot>  65535
16:01:51 <SamB_XP> +1
16:01:54 <SamB_XP> port numbers?
16:01:57 <jmelesky> chessguy: i think load-balancing is part of the facelift. originally, it was intended to be single-server, but there's been talk about amazon EC2 integration and automatic load balancing and such
16:01:59 <sorear> No
16:02:08 <sorear> there are 65535 port numbers! :)
16:02:12 <chessguy> nice
16:02:15 <sorear> 0 is reserved in the protocol
16:02:16 <SamB_XP> sorear: no port 0?
16:02:19 <SamB_XP> oh.
16:02:25 <SamB_XP> well pardon me for not knowing ;-)
16:02:41 <wli> jmelesky: What's Amazon EC2 integration?
16:02:43 <SamB_XP> I've never felt any reason to set port numbers < 1024
16:03:09 <chessguy> wli, http://aws.amazon.com/ec2
16:03:12 <lambdabot> Title: Amazon.com: Amazon EC2, Amazon Elastic Compute Cloud, Virtual Grid Computing: Am ...
16:03:13 <jmelesky> wli: amazon EC2 is the "elastic compute cloud", which is virtual server system
16:03:16 <Saul_> I don't have my own webserver (physical I mean), is it easy to run HAppS aside an Apache server?
16:03:25 <glguy> port numbers <= 1024 are for root only :)
16:03:38 <Saul_> The owner is a friend of mine, so he's pretty flexible
16:03:48 <SamB_XP> glguy: yeah, I know
16:03:56 <sorear> CAP_NET_BIND_SERVICE
16:04:02 <sorear> Saul_: Very easy.
16:04:03 <sjanssen> Saul_: it's easy to make a statically linked executable that contains your app
16:04:34 <SamB_XP> it just seems like it would make sense to use UNIX sockets for sub-servers...
16:04:40 <Heffalump> how will load balancing work with the idea of a replayable single-threaded log?
16:04:43 <sorear> Saul_: hpaste.org goes to shapr's apache and is then redirected to port 8000 where I'm running a hpaste instance
16:04:51 <Heffalump> (which AIUI is key to HAppS)
16:05:09 <jmelesky> SamB_XP: only on heterogeneous systems. most people are using one technology for their entire web infrastructure
16:05:13 <Saul_> HAppS is sounding pretty great, I'll read some more about it tomorrow
16:05:24 <SamB_XP> jmelesky: oh yeah?
16:05:30 <SamB_XP> what about haskell.org?
16:05:41 <jmelesky> Heffalump: buggered if i know. i'm waiting patiently for the new version to come out
16:05:42 <Saul_> But when is that facelift of HApps going to be ready?
16:05:52 <glguy> and when is it going to start?
16:06:02 <SamB_XP> hmm, perhaps not the best example...
16:06:06 <Saul_> And how backwards-compatible is it going to be?
16:06:19 <SamB_XP> Saul_: backwards-compatible? what's that?
16:06:24 <jmelesky> SamB_XP: i actually don't know how haskell.org is run. i'm talking abot businesses, mostly. and hosting companies that standardize on apache + mod_<lang>
16:07:02 <sorear> happs wants a process.  it would be very very difficult to write mod_happs
16:07:03 <jmelesky> Saul_: no idea when. don't count on backwards-compatibility, since the tutorials for HAppS have been not-worky with the current release for a while
16:07:21 <Saul_> SamB_XP: It means that if you have code that is based on an old version of HAppS (or any other program) it will still work properly after an update
16:07:48 <SamB_XP> Saul_: it seems unlikely ;-)
16:07:53 <glguy> HAppS is still very much in development now
16:08:04 <glguy> A stable API isn't set in stone yet
16:08:19 <jmelesky> glguy: a stable API is barely set in clay yet. :)
16:08:23 <chessguy> glguy, i hope not, because the current one seems awful
16:08:58 <Saul_> That's too bad :(
16:09:20 <SamB_XP> Saul_: not really
16:09:31 <SamB_XP> happs doesn't seem to have any of that *anyway*
16:09:34 <glguy> HAppS is still very much a research area
16:09:45 <chessguy> Saul_, it's usable though. i installed it, and went through the examples, and was able to get some kind of grasp of it, so it can't be too hard
16:09:45 <SamB_XP> so they might as well make it nicer ;-)
16:09:49 <Saul_> I've used Django (a web framework for Python) for a project at uni, which also didn't have a stable API or proper documentation, which really sucked
16:09:52 <glguy> settling on an API now when they know there are new ideas to try would just hold the project back
16:10:08 <glguy> HAppS is not like most web frameworks
16:10:17 <glguy> there isn't a recipe to follow
16:10:20 <jmelesky> Saul_: wait, what? Django's one of the best-documented frameworks i've seen
16:10:21 <SamB_XP> you mean... it's not practical?
16:10:37 <chessguy> wait, are we talking about haskell or happs :)
16:10:47 * glguy is talking about HAppS :)
16:10:53 <Saul_> HAppS
16:10:58 <chessguy> glguy, but you may as well be talking about haskell :)
16:10:59 <glguy> similarly I don't want to see Haskell hold Haskell' back
16:10:59 * SamB_XP too, with allusion to Haskell ;-)
16:11:00 <chessguy> that was my point
16:11:49 <chessguy> ok, that killed the conversation
16:11:54 <Saul_> Well I'm all for doing something new, nobody needs another by-the-numbers web framework (or programming language for that matter)
16:11:57 <SamB_XP> glguy: you mean *Haskell 98*
16:12:15 <SamB_XP> glguy: I hear older versions had some things that we want back ;-)
16:12:31 <SamB_XP> (what a strange concept... features that come... and go... and come back again!)
16:13:21 <Saul_> I'm going to bed, I'll be sure to try out HAppS tomorrow
16:14:00 <Saul_> And see if I can get my wiki system to work in it well
16:14:33 <chessguy> Saul_, might be a good idea QC your wiki stuff
16:14:58 <chessguy> to make sure the app logic is solid before trying to hook it up to a server
16:16:30 <glguy> Does anyone know who Adkron is?
16:16:47 <Saul_> Yeah I plan on just trying out HAppS a little first, not immediately link my wiki stuff to it
16:17:21 <chessguy> Saul_, my point was to thoroughly test the underlying data structure
16:17:29 <chessguy> a la xmonad
16:18:16 <Saul_> I want to expand my Wiki system as well (like adding time and user data, and seeing about collections of pages)
16:18:53 <Saul_> Yeah testing would be good, it seems to work though (it's not very complex yet, see http://paste.lisp.org/display/44111#2)
16:20:03 <Saul_> I reckon I will do a bunch of refactoring before I'm truly done though (as I'm learning new tricks in haskell)
16:20:52 <Saul_> Anyway goodnight, and thanks for all your help guys
16:24:03 <chessguy> Saul_, the point of QC'ing it now is so that you can refactor it without much fear, because all you have to do to see if you broke it is to run your tests again
16:24:37 <Saul_> QC = Quality Control??
16:24:47 <chessguy> @go haskell QuickCheck
16:24:49 <lambdabot> http://www.cs.chalmers.se/~rjmh/QuickCheck/
16:24:49 <lambdabot> Title: QuickCheck: An Automatic Testing Tool for Haskell
16:25:00 <chessguy> @where quickcheck
16:25:00 <lambdabot> http://www.cs.chalmers.se/~rjmh/QuickCheck/
16:25:00 <ddarius> @where xmonad
16:25:00 <lambdabot> http://xmonad.org/
16:25:43 <chessguy> Saul_, see also http://cgi.cse.unsw.edu.au/~dons/blog/2007/05/01#xmonad_part1_model
16:25:45 <lambdabot> Title: Haskell hacking, http://tinyurl.com/232r46
16:28:17 <Saul_> Ok now I'm really going to bed, thanks guys
16:28:39 <Saul_> I've stored all the urls you gave me, will make for some happy reading tomorrow
16:28:41 <Saul_> Bye
16:29:21 <chessguy> hAppy, muahaha
16:35:04 <chessguy> i wonder how hard it would be to create something rivaling django on top of happs
16:37:12 <wli> Hmm, the GSL wrapper lib and possibly GSL itself lacks band diagonal affairs.
16:37:28 <chessguy> GSL?
16:37:31 <chessguy> @where gsl
16:37:31 <lambdabot> I know nothing about gsl.
16:37:36 <chessguy> @go haskell gsl
16:37:40 <lambdabot> http://dis.um.es/~alberto/hmatrix/matrix.html
16:37:40 <lambdabot> Title: Matrix Computations in Haskell based on the GSL
16:38:01 <sorear> Matrix programming has a very high ick factor for me.
16:42:48 <quicksilver> chessguy: I don't imagine it would be very hard. I think hAppS has taken some very different decisions though (ones which its authors believe are superior)
16:43:02 <chessguy> quicksilver, what do you mean?
16:43:25 <quicksilver> isn't its data model based on term persistence rather than SQL?
16:45:14 <quicksilver> and it's built-in ACID stuff is way ahead of anything django has, AFAIK
16:45:25 <quicksilver> Mind you, I'm expert with neither system :)
16:45:34 <quicksilver> so I may be misunderstanding stuff
16:46:10 <jmelesky> quicksilver: the plus side of the django approach is that you don't have to worry about ACID stuff -- you offload to a SQL RDBMS
16:46:34 <jmelesky> so HAppS has a steeper hill to climb
16:46:37 <chessguy> quicksilver, i'm talking more of a practical comparable capability
16:46:49 <quicksilver> jmelesky: offloading to a RDBMS doesn't mean you don't have to worry about ACID
16:46:53 <quicksilver> jmelesky: not remotely :P
16:47:09 <quicksilver> jmelesky: (a) you still have to use transactions correctly (most people don't)
16:47:28 <quicksilver> (b) you have to understand your RBMS's limitations (none of them are actually ACID)
16:48:02 <quicksilver> chessguy: I believe they are comparable in terms of acheivable results
16:48:38 <jmelesky> quicksilver: sort-of. you can very easily go the way of "transaction == HTTP request", which is what HAppS is doing anyhow
16:48:38 <quicksilver> chessguy: of course, they require really rather different programming techniques, so it's not as if you can "port" a django developer to happs and expect him to be productive straight away :)
16:49:09 <chessguy> quicksilver, eh? who's talking about switching from programming drupal to programming haskell?
16:49:20 <quicksilver> chessguy: no one; just making the point
16:49:22 <jmelesky> drupal != django
16:49:40 <quicksilver> chessguy: they are different skillsets and rather different solutions to the problem
16:49:44 <cc> probably much easier to port django devs than drupal devs
16:49:46 * jmelesky knows one of the django creators, and is a little defensive of the project
16:49:51 <dons> is http://byorgey.wordpress.com/ on here?
16:49:54 <lambdabot> Title: blog :: Brent -> [String]
16:50:01 <dons> ibid: looks like a great candidate for p.h.o
16:50:12 <wli> What's p.h.o.?
16:50:17 <quicksilver> dons: he is sometimes. Not at the moment apparently
16:50:18 <sorear> @where pho
16:50:18 <lambdabot> I know nothing about pho.
16:50:21 <sorear> @where planet
16:50:21 <lambdabot> I know nothing about planet.
16:50:23 <quicksilver> planet.haskell.org
16:50:30 <sorear> @where+ pho http://planet.haskell.org
16:50:31 <lambdabot> Done.
16:50:40 <quicksilver> jmelesky: don't get me wrong, django is a neat project
16:50:47 <quicksilver> jmelesky: (though I'm a catalyst fan myself :P)
16:50:54 <dons> quicksilver: what's his nick here?
16:50:56 <chessguy> @seen byorgey
16:50:56 <lambdabot> I saw byorgey leaving #haskell and #haskell-blah 1d 2h 17m 25s ago, and .
16:50:57 <quicksilver> jmelesky: I'm just trying to point out that happs is rather different
16:51:00 <quicksilver> dons: byorgey :)
16:51:00 <dons> ah ok.
16:51:03 <dons> good.
16:51:30 <quicksilver> turbogears and RoR have their points too :)
16:51:46 <quicksilver> at least now we have sensible web frameworks for choose from, instead of a maze of twisty perl CGIs all alike...
16:51:47 <jmelesky> quicksilver: my love affair with perl is long over, and involved neither love, nor much of an affair
16:53:00 <monochrom> Yeah, it was just adolescence hormonal surge.
16:55:58 <quicksilver> when comparing libraries, I've always been much more interested in the library design than the language chosen
16:56:10 <quicksilver> languages are easy enough
16:56:25 <monochrom> Some languages force poor library design.
16:56:28 <quicksilver> the differences between perl python and ruby are hardly worth losing sleep over
16:56:39 <DRMacIver> Hm. I find the "Evolution of LINQ" paper unaccountably funny.
16:56:57 <DRMacIver> s/paper/article/
16:56:59 * monochrom pokes DRMacIver's funny bones.
16:57:16 <jmelesky> quicksilver: i disagree. from a distance, they're very similar, but from a distance, all programming languages are similar.
16:57:23 <jmelesky> sadly, you can't use them from a distance
16:57:36 <quicksilver> monochrom: I don't think any modern language really 'forces' bad design. Some of them certainly appear to encourage it though.
16:58:16 <chessguy> @let filterM’ p [] = return []; filterM’ p (x:xs) = let rest = filterM’ p xs in do { b <- p x; if b then liftM (x:) rest else rest }
16:58:16 <lambdabot>  Illegal character ''\128''
16:58:19 <DRMacIver> Some seem to make it hard work to the point where it needs to be a really important library to bother making a good API for it. :)
16:58:27 * sorear reminds the world that Haskell is usually implemented by translation into assembly
16:58:43 <chessguy> @let filterM’ p [] = return []; filterM’ p (x:xs) = let rest = filterM’ p xs in do { b <- p x; if b then liftM (x:) rest else rest }
16:58:44 <lambdabot>  Illegal character ''\128''
16:58:47 <chessguy> grr
16:59:29 <wli> chessguy: filterM . const . enumFrom $ minBound -- for maximal obfuscation
16:59:43 <chessguy> wli, huh?
17:00:11 * wli ponders analogousbits for permutations.
17:00:13 <quicksilver> :t filterM . const . enumFrom $ minBound
17:00:16 <lambdabot> forall b. [b] -> [[b]]
17:00:59 * quicksilver wonders how the type checker resolved those classes so silently
17:01:06 <monochrom> quicksilver: I think porting Haskell's monad library to Java serves as an example of how Java makes a monad library too hard.
17:01:31 <dmwit> :t enumFrom -- because of this type, probably
17:01:35 <lambdabot> forall a. (Enum a) => a -> [a]
17:01:57 <quicksilver> that takes care of the Monad, certainly
17:02:09 <quicksilver> but what resolved the Enum,Bounded part?
17:02:18 <dmwit> :t const
17:02:20 <lambdabot> forall a b. a -> b -> a
17:02:26 <dmwit> hm
17:02:26 <wli> quicksilver: m Bool of course
17:02:34 <quicksilver> oh, duh
17:02:36 <quicksilver> :t filterM
17:02:40 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
17:02:42 * quicksilver nods
17:02:57 <dmwit> right
17:03:37 <quicksilver> there's not doubt that's a superlative example of using the typeclass system for obfuscation
17:03:40 <dmwit> That's really nice.
17:03:54 <quicksilver> it's such a simple combinator of four well-known functions
17:04:09 <quicksilver> combined with a surprising class resolution :)
17:04:40 <monochrom> Combination is powerful.
17:04:55 * quicksilver nods
17:07:11 <aixo> hello
17:07:19 <aixo> did anyone remember me?
17:07:30 <sorear> Yes.
17:08:05 <aixo> i  finally found the code for the median of two sets
17:08:58 <dmwit> Great!
17:09:06 <Altair^> does anyone know why my ghci complains <interactive>:1:0: parse error on input `data' when I try to define a datatype
17:09:21 <sorear> Altair^: Because nobody has implemented it yet.
17:09:37 <Altair^> :)
17:09:43 <sorear> Altair^: Other interactive systems (such as hbi) can do it.
17:10:02 <sorear> Altair^: For GHCi, a workaround is to put your datatype into a file and :load it.
17:11:04 <desp> hmmm
17:11:41 <desp> when setting a record field,  rec {fld = val},  is fld simply the field accessor function?
17:11:54 <chessguy> desp, yes
17:12:01 <desp> so I can parametrize the setting?
17:12:04 <chessguy> the name of the field
17:12:24 <dmwit> Nope, you can't do, e.g.
17:12:25 <chessguy> hmm?
17:12:33 <dmwit> f = fld; rec {f = val}
17:12:37 <desp> crappy.
17:12:40 <desp> records--
17:12:41 <dmwit> yeah =(
17:12:51 <chessguy> @karma records
17:12:51 <lambdabot> records has a karma of -2
17:13:09 <chessguy> why can't you do that?
17:13:32 <dmwit> Well, you can, but it won't compile.
17:13:38 <dmwit> ...I think.
17:13:38 <desp> :)
17:13:43 * dmwit tests his theories
17:13:48 <DRMacIver> Because basically nothing about record updates is first class? :)
17:14:01 * dmwit stops testing as he realizes he hasn't installed ghc on this computer yet
17:17:24 <chessguy> oh, that's interesting
17:17:39 <chessguy> @paste
17:17:39 <lambdabot> Haskell pastebin: http://hpaste.org/new
17:18:18 <hpaste>  chessguy pasted "record twiddling" at http://hpaste.org/1576
17:18:32 <chessguy> dmwit, desp ^^
17:18:51 <desp> heh
17:19:06 <Pupeno> I am getting a warning when leaving a field in a datatype uninitialized (in GHCi, the REPL)... I thought that leaving uninitialized fields was Ok, is it not?
17:19:43 <oerjan> Pupeno: are they strict fields?
17:19:51 <chessguy> desp, did i understand what you wanted to do correctly?
17:19:58 <Pupeno> oerjan: those are the ones with ! on them, right? then no.
17:20:05 <desp> yep
17:20:16 <desp> actually
17:20:18 <oerjan> Pupeno: i guess it's just a warning because it's easy to forget a field
17:20:35 <sorear> Pupeno: uninitialized fields are bad, because attempting to examine an uninitialized field is instantly fata
17:20:39 <sorear> *fatal
17:20:58 <Pupeno> Is there a way to check if a field is unintialized or not?
17:21:04 <sorear> No.
17:21:22 <desp> that's simply because there's no general setFld function
17:21:27 <monochrom> catch exceptions :)
17:21:43 <desp> i.e.  "Record r => a -> r -> r"
17:22:38 <desp> no, that's not what I meant.
17:22:44 <oerjan> Pupeno: maybe allowing them in the language was a bad choice
17:22:57 <oerjan> you can always set a field to undefined explicitly
17:23:02 <Pupeno> is it considered a bad choice? is it discouraged?
17:23:19 <oerjan> Pupeno: i mean because it risks forgetting fields silently
17:23:25 <chessguy> Record r => (r -> a) -> r -> r
17:23:26 <monochrom> Do you want to leave fields uninitialized?
17:23:58 <desp> chessguy: (r -> a) ?
17:24:00 <oerjan> there _might_ be cases where you want to leave a field temporarily unitialized because you cannot fill it yet
17:24:12 <Toxaris> desp: normal selector function provided by record syntax
17:24:24 <chessguy> desp, that's the type of each field selector
17:24:29 <desp> yes, but why in this case?
17:24:42 <Toxaris> because they are provided by record syntax
17:24:49 <chessguy> although
17:24:53 <desp> they are, but the type isn't helpful
17:24:58 <chessguy> there's no way then to guarantee that a is a member of the record
17:25:03 <monochrom> I would leave a field uninitialized for this: the record is a template, I create fully initialized new records from it.
17:25:29 <dolio> dons: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/logict-0.2
17:25:32 <lambdabot> http://tinyurl.com/2v5w9b
17:26:03 <Toxaris> so let's change record syntax to provide functions of type (r -> (a, (a -> r))
17:26:12 <desp> oerjan, Pupeno: thanks for incidentally helping me :)
17:26:24 <oerjan> desp: how? :)
17:26:34 <chessguy> Toxaris, good luck getting anything done with records
17:26:38 <desp> oerjan: I was using a Maybe type when I think I can just use undefined
17:26:40 <chessguy> (fixing them, that is
17:26:41 <chessguy> )
17:27:21 <desp> oerjan: since I can guarantee nobody will look at the field until it is defined
17:27:23 <monochrom> I would not leave a field uninitialized for this: the correct value is to be determined "later". (I do not plan to create new records from this one.) I would instead use lazy evaluation and tying-the-knot to initialize the fields.
17:27:48 <Toxaris> and introduce get :: (r -> (a, a -> r)) -> r -> a; get fld r = fst . fld r
17:28:11 <dmwit> desp: http://www.cs.uu.nl/~daan/download/papers/scopedlabels.pdf
17:28:24 <Toxaris> and set :: (r -> (a, a -> r)) -> r -> a -> r; set fld r = snd . fld r
17:28:34 <desp> yeah, I read several papers about fixing records
17:28:54 <chessguy> @fix record
17:28:54 <lambdabot> Maybe you meant: faq ft id thx
17:28:55 <desp> I just wish they were already fixed
17:28:55 <desp> :)
17:29:04 <dmwit> heh
17:29:04 <oerjan> monochrom: oh right, i think my ideas on this predate me finding out about mdo, which changes things
17:29:06 <chessguy> @free ix record
17:29:06 <lambdabot> Extra stuff at end of line
17:29:12 <chessguy> @free fix
17:29:15 <lambdabot> f . g = h . f => f (fix g) = fix h
17:29:24 <dolio> desp: You can use HList. :)
17:29:32 <desp> overkill :)
17:30:16 <DRMacIver> There is no overkill. Only "open fire" and "I need to reload".
17:30:32 <mauke> you can't have too much overkill
17:30:50 <wli> So there's a trick for generating the powerset with fancy monadic bits. Now for permutations.
17:30:54 <desp> @remember DRMacIver There is no overkill. Only "open fire" and "I need to reload".
17:30:54 <lambdabot> Done.
17:30:58 <oerjan> Toxaris: i think you would want some simple syntax for getting that function from the current field names
17:31:06 <monochrom> oerjan: heh, if it happens that I'm in a monad without mdo, I have no solution either.
17:31:20 <DRMacIver> desp: I was quoting actually. :)
17:31:32 <DRMacIver> desp: It's from the seven habits of highly effective space pirates.
17:31:37 <desp> hah
17:31:45 <Toxaris> oerjan: i want a language change to let field names denote this function
17:31:47 <oerjan> since you don't want to break backwards compatibility
17:31:55 <DRMacIver> (See http://www.schlockmercenary.com for details)
17:31:56 <lambdabot> Title: Schlock Mercenary, by Howard Tayler
17:31:59 <Toxaris> hmm, ok...
17:32:29 <Toxaris> let's talk about real solutions... so i want a simple function
17:32:46 <Toxaris> wich couldn't be a function of course, but what about a keyword?
17:32:58 <wli> Toxaris: subdivs [] = [([],[])] ; subdivs l@(x:xs) = ([],l):[(x:ys,zs)|(ys,zs)<-subdivs xs] ; perms [] = [] ; perms [x] = [[x]] ; perms (x:xs@(_:_)) = [l ++ [x] ++ r | (l, r) <- concatMap subdivs $ perms xs]
17:33:20 <glguy> > let perm [] = [[]]; perm (x:xs) = [a ++ x : b | xs' <- perm xs, (a,b) <- zip (inits xs')(tails xs') ] in perm [1..3]
17:33:22 <lambdabot>  [[1,2,3],[2,1,3],[2,3,1],[1,3,2],[3,1,2],[3,2,1]]
17:34:31 <wli> glguy: I hate having to do zip (inits xs) (tails xs)
17:35:03 <oerjan> Toxaris: i think the real problem is that this all gets mingled in with views and first-class patterns and the like, and no one wants to introduce partial solutions that might not fit into the final whole
17:35:19 <Pupeno> For unsigned ints, should I use Word8, Word16, Word32?
17:35:37 <desp> CInt?
17:35:48 <dolio> > maxBound :: Int
17:35:49 <lambdabot>  2147483647
17:35:52 <dolio> > maxBound :: Word32
17:35:54 <lambdabot>  4294967295
17:35:59 <oerjan> > maxBound :: Word
17:36:01 <lambdabot>  4294967295
17:36:07 <dmwit> > maxBound :: CInt
17:36:08 <lambdabot>   Not in scope: type constructor or class `CInt'
17:36:14 <Pupeno> > maxBound :: Word16
17:36:16 <lambdabot>  65535
17:36:28 <monochrom> You can try Word.
17:36:29 <glguy> Prelude> maxBound :: Int
17:36:30 <glguy> 9223372036854775807
17:36:31 <dmwit> > maxBound :: Foreign.C.Types.CInt
17:36:32 <lambdabot>      Not in scope: type constructor or class `Foreign.C.Types.CInt'
17:36:32 <oerjan> Pupeno: as you see Word essentially corresponds to Int
17:36:51 <dolio> > maxBound :: Int64
17:36:54 <lambdabot>  9223372036854775807
17:36:56 <wli> glguy: Now to look for monadic tricks like the filterM (const [False,True]) one...
17:37:36 <dmwit> wli: It's trickier, because it isn't functions (N -> Bool), it's functions (N -> N).
17:37:59 <wli> dmwit: Yeah.
17:38:04 <oerjan> Toxaris: i think this fits into some of Klaus Reinke's [sp?] ideas from the haskell-cafe, he seems a proponent of this
17:38:07 <dmwit> And there's the restriction that the function be bijective, unlike the (N -> Bool) one.
17:38:11 <chessguy> @type maxBound
17:38:14 <lambdabot> forall a. (Bounded a) => a
17:38:16 <ddarius> Claus
17:38:18 <Pupeno> and, btw, should I consider ints refered in a RFC (1035, DNS), to be signed or unsigned.
17:38:21 <chessguy> cute
17:38:27 <glguy> > let perm [] = [[]]; perm xs = do { x <- xs; xs' <- perm (delete x xs); return (x:xs') } in perm [1..3]
17:38:27 <Pupeno> ?
17:38:29 <lambdabot>  [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
17:38:32 * Toxaris wonders why wli told him about subdivs
17:38:47 <dmwit> > let perm [] = [[]]; perm xs = do { x <- xs; xs' <- perm (delete x xs); return (x:xs') } in perm [2,2,2]
17:38:48 <lambdabot>  [[2,2,2],[2,2,2],[2,2,2],[2,2,2],[2,2,2],[2,2,2]]
17:39:31 * ddarius thinks an entire paper of Thorsten Altenkirch's reduces to (categorical) continuity.
17:39:32 <mauke> :t maybe
17:39:36 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
17:39:47 * mauke shakes his fist at the standard library
17:39:53 <dons> dolio++ great!
17:39:58 <mauke> why does foldr take its arguments in the wrong order?
17:40:08 <dons> dolio: might be a good idea to announce it
17:40:10 <oerjan> mauke: huh?
17:40:15 <ddarius> mauke: It's the right order.
17:40:15 <oerjan> :t foldr
17:40:16 <dons> mauke: so you get a type error if you mix up foldl and foldr
17:40:16 <monochrom> what is the One True Right Order? :)
17:40:17 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
17:40:21 <dcoutts> mauke: easy :-) it doesn't!
17:40:22 <ddarius> Almost.
17:40:23 <dons> :t foldl
17:40:26 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
17:40:41 <mauke> dcoutts: it should be b -> (a -> b -> b) -> [a] -> b
17:40:41 <ddarius> No, I change my mind back.  It is the right order.
17:40:56 <dcoutts> mauke: because?
17:41:01 <dons> mauke: nah, partial application is a bit easier this way: foldl (+)
17:41:03 <dons> for example
17:41:04 <ddarius> mauke: I find it more likely that you will change the base case than the inductive case.
17:41:15 <ddarius> and foldr (++)
17:41:16 <mauke> because data [a] = [] | a : [a]
17:41:21 <dons> ?src concatMap
17:41:22 <lambdabot> concatMap f = foldr ((++) . f) []
17:41:27 <dons> ?src sum
17:41:27 <lambdabot> sum = foldl (+) 0
17:41:31 <mauke> the empty case should come first
17:41:33 <dons> ?src length
17:41:34 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
17:41:34 <dcoutts> mauke: but it could easily be data [a] = a : [a] | []
17:41:41 <mauke> dcoutts: that feels wrong :-)
17:41:43 <dcoutts> there's nothing fundamental about it
17:41:46 <wli> dmwit: Looks like it sort of DTRT...
17:41:57 <oerjan> dcoutts: that would not fit into Ord deriving
17:42:00 <dcoutts> mauke: it comes down to tradition either way
17:42:04 <mauke> dcoutts: in any case it's incompatible with maybe
17:42:04 <dons> ?where+ logict http://hackage.haskell.org/cgi-bin/hackage-scripts/package/logict-0.2
17:42:04 <lambdabot> Done.
17:42:08 <ddarius> :t let sumAcc = foldl' (+) in sumAcc
17:42:10 <lambdabot> forall a. (Num a) => a -> [a] -> a
17:42:13 <dcoutts> oerjan: ok, true
17:42:32 <monochrom> w00t LogicT is packaged up too? :)
17:42:35 <ddarius> :t maybe
17:42:40 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
17:42:43 <dmwit> wli: Yep, provided you can guarantee the (Eq a) instance.
17:42:51 <ddarius> :t flip maybe
17:42:54 <lambdabot> forall a a1. (a1 -> a) -> a -> Maybe a1 -> a
17:42:58 <dmwit> wli: Which you usually can.
17:43:04 <wli> dmwit: I don't like the special case, though.
17:43:10 <dons> dolio: so what's your next challenge? :)
17:43:17 <dcoutts> mauke: I suspect actually it come from the tradition of describing things like (+, 0) or (*, 1)
17:43:23 <oerjan> dcoutts: although you _could_ have considered the empty list greatest. hm..
17:43:28 <wli> dmwit: having to break out perm [] = [[]] is kind of nasty
17:43:29 <dmwit> wli: Inescapable, it's how induction works. ;-)
17:43:48 <dons> dolio: i've an easy one for you: Control.Comonad: http://www.eyrie.org/~zednenem/2004/hsce/
17:43:57 <dcoutts> oerjan: reverse lexicographic order? :-)
17:43:57 <dons> src to start from here, http://www.eyrie.org/~zednenem/2004/hsce/catext.zip
17:44:13 <oerjan> dcoutts: not _quite_ reverse, just longest first
17:44:13 <wli> dmwit: I was hoping for an analogue of filterM (const [False,True])
17:44:26 <mauke> "a" < "ba" < "b"
17:45:04 <dcoutts> oerjan: right, (reverse lexicographic) order rather than reverse (lexicographic order)  :-)
17:45:15 <dolio> dons: Sure, that shouldn't be too hard to package.
17:45:23 <dmwit> wli: That just puts the base case into filterM.
17:45:27 <monochrom> OH! String doesn't have One True Ord since different countries use different collation orders.
17:45:38 <oerjan> heh
17:45:44 <wli> dmwit: That would be good.
17:47:24 <oerjan> monochrom: even Eq is dubious, somehow i doubt combined characters are considered
17:48:10 <dmwit> :t forM
17:48:12 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
17:48:22 <oerjan> and case insensitive matching came up here yesterday
17:49:22 <wli> dmwit: Where's that?
17:49:55 <oerjan> @index forM
17:49:56 <lambdabot> bzzt
17:49:58 <Toxaris> is forM = flip mapM?
17:50:02 <mauke> @src forM
17:50:02 <lambdabot> forM = flip mapM
17:50:24 <desp> why is the index incomplete?
17:51:05 <dons> dolio: will you announce the package?
17:51:16 <dolio> dons: Yeah, I'm typing up the e-mail now.
17:51:55 <oerjan> @hoogle forM
17:51:55 <lambdabot> Text.Html.form :: Html -> Html
17:51:55 <lambdabot> Time.formatCalendarTime :: TimeLocale -> String -> CalendarTime -> String
17:51:55 <lambdabot> System.Time.formatTimeDiff :: TimeLocale -> String -> TimeDiff -> String
17:52:14 <dmwit> desp: It's new in 6.6, so that's probably why.
17:52:25 <glguy> Control.Monad.forM
17:53:45 <eivuokko> sorear, I have no idea about cygwin readline - I don't use cygwin myself (answering to what irssi shows in away log)
17:54:03 * oerjan could have sworn forM was in H98...
17:54:35 <sorear> eivuokko: I had vague memories of you being the Win32 platform maintainer; someone was asking earlier about how to get readline, and I wondered why it wasn't in the msi
17:55:02 <eivuokko> sorear, It isn't in installer because there is no native port.
17:55:09 <eivuokko> sorear, And I just main package Win32.
17:55:13 <eivuokko> *maintain
17:56:34 <eivuokko> Sorry if I implied I maintain Windows port of ghc or something, I certainly don't have time for that, Sigbjorn Finne does that afaik.
17:58:25 <wli> dmwit/glguy: I think MonadZero is involved here.
17:58:50 <eivuokko> (I do try to answer Windows-related questions tho)
18:11:50 * wli tries to figure out how to deal with sparse matrices.
18:12:00 <sorear> Map
18:12:21 <wli> sorear: Not sure what you mean.
18:12:31 <sorear> Map (Int,Int) Double
18:12:37 <dons> ?remember DaveBayer Haskell is like ice sailing, where one can reach 100 mph on a 15 mph breeze.
18:12:38 <lambdabot> Done.
18:12:52 <wli> sorear: That's a bit below the level of what I'm on about.
18:15:32 <wli> sorear: If you're using e.g. Jacobi's method for eigenvalues, you can just look up the off-diagonal keys, but describing unusual matrix structure is not done that way.
18:17:30 <wli> sorear: For instance, block-structured matrices with irregularly places blocks with only single diagonals (not necessarily the longest) in the bottom left to top right direction nonzero.
18:18:01 <sorear> wli: fwiw, you've completely lost me
18:18:12 <wli> sorear: Or band diagonal.
18:19:49 <wli> sorear: There is more structure to these things than just the list of index pairs for nonzero entries.
18:20:05 <dmwit> wli: I'm guessing that's how most programs store it anyway.
18:20:30 <dmwit> wli: Or are you talking about generating those lists?  If so, you have the whole power of Haskell at your fingertips.
18:21:02 <wli> sorear: Matrix transformations generally destroy some sparseness, so what you do is to have some "less sparse superstructure" that you try to narrow down intermediate matrices to.
18:22:23 <wli> dmwit: No, generating the lists is not an issue.
18:24:36 <wli> Anyway, there are these various categories of structure and you want outputs to respect some sort of structure, not merely to deal with inputs. Carrying around the result structure is what I'm on about.
18:26:25 <oerjan> wli: sounds like a job for a handmade datatype
18:27:09 <wli> oerjan: The form of that data type is what I'm on about.
18:27:45 <wli> Also, for things like band diagonal, block-structured, etc., there are vastly better representations than Map (Int, Int) Double
18:28:19 <chessguy> @src Monad
18:28:19 <lambdabot> class  Monad m  where
18:28:19 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
18:28:19 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
18:28:19 <lambdabot>     return      :: a -> m a
18:28:19 <lambdabot>     fail        :: String -> m a
18:28:26 <wli> e.g. band diagonal is typically done with arrays corresponding to the diagonals
18:29:11 <wli> There's some way to generalize all this.
18:32:34 <wli> Actually I can probably ignore the specifics of the structure if I use iterative methods oblivious to structure.
18:32:54 <wli> e.g. conjugate gradient
18:35:37 <sorear> wli: You could store matrices in flat arrays and describe the data layout using a phantom type, then for each value-function you assign a type function (MPTC + fundep) to map input layout to output layout
18:36:21 <wli> sorear: That sounds like what I'm on about, though I sort of just proved that it's overkill for my specific problem (though it would still be good for libraries).
18:39:17 <dons> jfredett: hey.
18:39:20 <dons> ?users
18:39:20 <lambdabot> Maximum users seen in #haskell: 354, currently: 307 (86.7%), active: 9 (2.9%)
18:39:27 <glguy> l
18:39:29 <dons> so what adventures are we going to have today?
18:39:30 <glguy> ?lusers
18:39:30 <lambdabot> Maximum users seen in #haskell: 354, currently: 307 (86.7%), active: 10 (3.3%)
18:39:49 * Pseudonym is trying to work out COM port enumeration under Win32
18:39:50 <sorear> dons: hpaste is working again!
18:39:51 <glguy> they day is coming t oan end :)
18:39:55 <Pseudonym> That's not exactly an adventure.
18:40:01 <dons> sorear: yay, so hpaste issue solved?
18:40:06 <hpaste>  Shine pasted "filterM in Lisp" at http://hpaste.org/1577
18:40:07 <glguy> at that's left is to not lose to badly at soccer!
18:40:09 <dons> glguy: you going to announce the utf8 binding?
18:40:11 <Shine> I'm trying to implement "powerset = filterM (const [True, False])" in Lisp in order to understand how monads works. Any idea why my implementation doesn't work?
18:40:11 <sorear> dons: yeah.
18:40:27 <Pseudonym> Shine: You're using Lisp.  Hope this helps!
18:40:28 <dons> glguy: so are you playing on a galois team?
18:40:33 <glguy> dons: yeah
18:40:51 <sorear> dons: Saizan found the problem (in happs) earlier today.
18:40:57 <sorear> s/today/two days ago/
18:40:59 <dons> glguy: that sounds fun! who else plays?
18:41:09 <dons> sorear: was it just the strictness issue you mentioned?
18:41:15 <sorear> dons: yeah
18:41:24 <Shine> maybe the problem is that filterM is lazy in haskell?
18:41:43 <sorear> dons: anyway, I gave up waiting for shapr to apply it, and scp'd a hpaste binary to kakapo
18:41:52 * shapr springs into action
18:42:02 <shapr> oh, you've done it?
18:42:03 <Pseudonym> ?lusers
18:42:03 <lambdabot> Maximum users seen in #haskell: 354, currently: 307 (86.7%), active: 13 (4.2%)
18:42:09 * shapr cheers for sorear!
18:42:11 <shapr> sorear++
18:42:13 <Pseudonym> Jumped from 2.9% to 4.2%.
18:42:52 <glguy> dons: john, isaac, iavor, lee, sigbjorn, dave, laura, gena, april, rebekah...
18:43:01 <dons> wow, quite a team!
18:43:02 <glguy> adam
18:43:07 <glguy> dave
18:43:13 <glguy> oh, that was a dup
18:43:21 <sorear> shapr: The hpaste binary is build using unrecorded local changes in my HAppS repo.  Even if someone recorded and sent, we'd still need someone with kakapo's root pw to update the global haps
18:43:21 <shapr> andy?
18:43:32 <shapr> sorear: I can do that.
18:43:45 <Shine> Pseudonym: sorry, this doesn't help very much :-) At least the more simpler Maybe translation works: http://paste.lisp.org/display/44120
18:43:47 <wli> sorear: biconjugate gradient looks like the way for me.
18:43:51 <glguy> shapr: I don't think so
18:44:20 <dons> Shine: did you see the impl. on reddit using 'amb' ?
18:44:20 <glguy> oh, melissa, can't forget her
18:44:31 <shapr> glguy: Yes I can! :-P
18:44:59 <dons> glguy: so no cricket team? ;)
18:45:05 <glguy> levent plays keeper
18:45:13 <Shine> dons: no, do you have a link?
18:45:20 <dons> Shine: http://programming.reddit.com/info/23yuj/comments/c248a4
18:45:21 <lambdabot> Title: Common Lisp: powerset (reddit.com)
18:45:27 <glguy> cricket? that's a game you watch on espn 8
18:45:27 <dons> (define (powerset l)
18:45:27 <dons>   (amb-eval (filter (lambda _ (amb #t #f)) l)))
18:45:28 <jfredett> hey dons, *wives*
18:45:33 <jfredett> waves*
18:45:35 <jfredett> doh!
18:45:41 * dons wives!
18:45:50 <Pseudonym> Desperate Haskellwives
18:45:57 <jfredett> lol
18:46:11 <jfredett> Haskwives, that flows better, so we can put it in the catagory
18:46:17 <sorear> shapr: /me darcs send -a --cc=shae@youknowtherest
18:46:17 <mauke> Shine: your base case is wrong
18:46:46 <Shine> dons: this is Scheme, I don't know what "amb" does
18:46:47 <mauke> Shine: filterM p [] = return []; your code does filterM p [] = []
18:47:00 <jfredett> shine is a nondeterministic operator
18:47:08 <sorear> Shine: It's Felleistein's ambiguous operator.
18:47:17 <mauke> (if (null list) (list ()) ...)
18:47:23 <Pseudonym> This reminds me of a haiku written by Nat Torkington's wife.
18:47:24 <jfredett> err, is -> it is. :/
18:47:26 <sorear> Shine: You can implement it using call-with-current-continuation
18:47:42 <jfredett> @wikipedia Felleistein's ambiguous operator
18:47:45 <lambdabot> No Result Found.
18:47:49 <Pseudonym> Come home, Perl Monger! / Perl orphan baby says "hash bang usr bin perl" / Instead of "da da"
18:47:50 <jfredett> @google wikipedia Felleistein's ambiguous operator
18:47:51 <lambdabot> No Result Found.
18:47:55 <jfredett> ....
18:48:13 <sorear> Oh come on.  You can
18:48:14 <sorear> '
18:48:16 <Pseudonym> Something like that, anyway.
18:48:31 <sorear> t seriously expect me to remember how to spell Mattias Felleistein.
18:48:31 <Shine> mauke: thanks, I'll try it. Silly mistake to translate "return []" to "()" instead of "(())"
18:49:05 <mauke> Shine: a static type checker might have helped with that :-)
18:49:20 <sorear> no, McCarthy, sorry
18:49:33 <sorear> @google mccarthy's ambiguous operator
18:49:34 <lambdabot> http://www.randomhacks.net/articles/2005/10/11/amb-operator
18:49:34 <lambdabot> Title: McCarthy's Ambiguous Operator
18:49:39 <mauke> @google wikipedia felleisen
18:49:39 <Korollary> It's Felleisen iirc
18:49:41 <lambdabot> http://en.wikipedia.org/wiki/Matthias_Felleisen
18:49:41 <lambdabot> Title: Matthias Felleisen - Wikipedia, the free encyclopedia
18:49:51 <dons> sorear: Matthias Felleisen ?
18:49:56 <dons> yeah.
18:50:18 <dons> http://www.ccs.neu.edu/scheme/pubs/scp91-felleisen.ps.gz <-- this guy, our hero
18:50:32 <jfredett> ooh! he's the The Little X book guy!
18:50:32 <jfredett> okay
18:51:01 <Pseudonym> wli: COuldn't find it in the logs.  What are you using biconjugate gradient for?
18:51:06 <jfredett> heh, dons, I just got an image of a nerd wearing a super-man costume w/ a big "lambda" instead of a "S" in the middle
18:51:12 <mauke> it's easy! fell (fur) + eisen (iron) :-)
18:51:23 * jfredett sighs: "Our hero..."
18:51:26 <dons> heh
18:51:45 <jfredett> iron fur? sounds painful
18:51:59 <jfredett> couldn't ever wash it either
18:52:03 <jfredett> it'd get all rusty
18:52:12 <mauke> no, fur iron
18:52:12 <Pseudonym> http://www.at-mix.de/images/glossar/curry.jpg -- Our hero
18:52:24 <Pseudonym> He even looks mild mannered.
18:52:26 <sorear> jfredett: good luck at the dry cleaning, too
18:52:32 <mauke> except it's actually from "valise" (fr.)
18:52:33 <jfredett> we should find a full length picture of him
18:52:40 <jfredett> and turn him into "Super-geek"
18:53:11 <dons> yes, i can imagine a series of H. B. Curry stories, where he fights the force of evil
18:53:16 <dons> with cold reason and type systems
18:53:26 <dons> hbc. interesting.
18:53:37 <Pseudonym> And deep connections to logic.
18:53:58 <ddarius> dons: Did you just figure out hbc's name?
18:54:15 <dons> ddarius: no, 'hbc' the compiler lennart wrote.
18:54:26 <dons> Dr Freeze! http://research.microsoft.com/~simonpj/GIFs/spj-snow.jpg
18:54:46 <Korollary> more like Dr Brrr
18:54:54 <jfredett> lol, "HB Curry vs The attack of the killer  weak type system"
18:55:33 <jfredett> "HBC vs the Imp Erratives!"
18:55:35 * monochrom likes cold reason and type systems. the only way he figured out haskell and other "abstract, counterintuitive", but factual things.
18:55:37 <dons> the evil professor, http://homepages.inf.ed.ac.uk/wadler/Pics/philtie.gif
18:56:28 <dons> i wonder if 'Java Generics' will mean type systems have to be taught at an undergrad level -- everywhere.
18:56:53 <ddarius> dons: Yes, I know.  That's the "hbc" I was referring to.
18:56:58 <jfredett> they (sorta) were when i took OOP, but that was just as generics were entering the world
18:57:00 <monochrom> undergrad level is moving towards python.
18:57:24 <dons> ddarius: i hadn't noticed hbc==hbc before :}
18:57:41 <ddarius> Yeah, it wasn't too long ago before that clicked for me.
18:57:43 <monochrom> there seems to be always a way undergrad can avoid type systems and cold reason.
18:57:47 <Pseudonym> Depends on the course.
18:58:26 <dons> a young lennart using his laser vision to melt a dynamic typing advocate, http://www.cs.chalmers.se/~augustss/tvpics/la10.gif
18:58:39 <jfredett> lol
19:00:47 <dmead> does someone know where i could find papers on shape recognition?
19:01:21 <monochrom> as in shape analysis?
19:01:23 <dons> here, image-enhanced in the infra-red spectrum, http://www.cse.unsw.edu.au/~dons/tmp/la10-enhanced.gif
19:01:35 <dmead> monochrom, yes
19:01:49 <dmead> lol dons
19:01:55 <monochrom> have you tried searching with "shape analysis" as the keyword?
19:01:59 <dmead> no
19:02:00 <dmead> i will
19:02:23 <wli> Barry Jay? FiSH?
19:02:24 <dmead> hmm
19:02:42 <dmead> i'm wondering if theres some algorithm that could be implemented in haskell
19:02:45 <monochrom> "shape analysis" should work well. disclaimer: I never tried. just repeating jargons I heard.
19:03:33 <dmead> ah
19:03:33 <dmead> k
19:06:34 <thorat> http://okmij.org/ftp/Computation/my-summaries.html#PrincipiaMathematica
19:06:36 <lambdabot> Title: Summaries and Reviews, http://tinyurl.com/2d728q
19:06:48 <thorat> the first book on type theory and lambda calculus
19:07:20 <thorat> ;)
19:07:25 <wli> Russell & Whitehead's theory of types isn't super-relevant to modern use in programming languages.
19:08:11 <wli> It was targeted toward resolving Russell's paradox.
19:08:15 <thorat> quoting Oleg: "t contains perhaps the first mentioning of `domain', `alpha renaming' and `type' in the modern sense."
19:09:07 <Shine> mauke: yes, a type checker would have found this problem, but I'm not sure if types makes programming harder, e.g. in Lisp a function can return objects of completly different types
19:09:16 <monochrom> Not super-relevant, but it laids the basic.
19:09:26 <mauke> Shine: yes, that's evil
19:09:48 <monochrom> Hrm, lays? laid? I can never spell them right. :)
19:10:09 <wli> Shape analysis is augumenting type analysis with some attempts to determine sizes/shapes/etc., esp. array bounds.
19:10:38 <wli> Though it also includes list lengths, tree shapes of some sort, and more.
19:10:58 <Shine> but I like Haskell, the only problem is that it is much more difficult for me to solve a given problem in Haskell than in Lisp or Java
19:11:30 <dons> do you think that's just due to experience, Shine ?
19:11:37 <dons> and familiarity with the libraries?
19:11:47 <Pseudonym> And insufficient brainwashing.
19:11:57 <dons> brain washing does help
19:12:02 <Shine> maybe it is that I'm more familiar with imperative than functional programming style
19:12:23 <Pseudonym> Brain washing it is.
19:12:25 <dons> yeah, you've got the IO monad baked into your view of programming. that takes a while to get out of :)
19:12:59 <dons> how long before `notions of computation' are taught in 1st year courses?
19:13:44 <wli> Shine: Getting good in programming languages is pretty much mastering given styles. Then any given language is just syntax. It helps to go about trying to learn languages with a variety of different execution models. Logic languages, for example, would be good to get a grip on as well.
19:13:44 <dons> so we avoid the imperative hardwiring, and teach the foundations instead?
19:14:01 <Pseudonym> dons: You're writing the book.
19:14:15 <monochrom> We would need to go back to 1800, when university courses did not have to be "practical".
19:14:18 <dons> not really a foundational book, though Pseudonym.
19:14:25 <Pseudonym> True.
19:15:24 <Shine> wli: yes, that was one reasone why I tried to translate the monads to Lisp, because functional programming AND a rich syntax like Haskell is too much at once :-)
19:15:50 <wli> monochrom: Yeah, even in the 1920's they were doing it, e.g. Whittaker and Watson cut out continued fractions from the curriculum.
19:15:53 <mauke> huhu, start with Perl
19:15:59 <dons> basic things what it means to be `strict', what it means to be `imperative' aren't taught. you might get a grab bag of functional/imperative/logic/OO, but no unifying framework for understanding language concepts.
19:16:36 <monochrom> One thing you can do is to convince employers to give high regard to vocational school graduates as programmer employees. That will free up true universities and they can teach foundations and thoughts again.
19:16:39 <Shine> Perl looks like line noise to me
19:16:54 <Alleria_2> monochrom: precisely
19:16:59 <wli> dons: Dataflow is sorely neglected (basically circuit design languages).
19:17:08 <mauke> we prefer the term "rich syntax"
19:17:38 <sorear> High entropy, maybe?
19:18:01 <wli> sorear: I think it's rate vs. entropy itself.
19:18:21 <sorear> wli: Parse error?
19:18:52 <dons> its really the sign of an immature field: where even the basic concepts of the discipline aren't agreed upon -- or even known
19:18:54 <wli> sorear: The mean entropy of a sentence of the language because languages themselves don't have entropy defined on them.
19:19:19 <dons> how long did it take math to settle down? 200 years? :-)
19:19:42 <monochrom> Haven't they agreed upon imperative OO already? :)
19:20:14 <wli> sorear: Sorry, the mean over all sentences of the entropy of the sentence divided by the length of the sentence.
19:20:27 <monochrom> And semantics - haven't they agreed upon leaving semantics informal and incomplete too? :)
19:20:49 <wli> dons: Mathematics is prehistoric in origin.
19:21:00 <Shine> mauke: yes, first I have thought of other words for "rich syntax", but it doesn't help to start a flame war about Lisp and Haskell syntax :-)
19:21:15 <wli> dons: I'd say it only settled down in the 19th century.
19:21:16 <Shine> I think Lisp can use some concepts of Haskell, like monads, if implemented in a more Lisp-style way of programming
19:21:19 <monochrom> Software process - haven't they agreed to be exploratory and agile? :)
19:21:20 <dons> yeah, and the people don't recognise things like Maybe a, or referential transparency, when they hit them in the wild. nor explain why if-then-else is lazy. so the basic tools aren't able to be reasoned about with a conventional undergrad degree
19:22:18 <dons> monochrom: its very depressing.
19:22:33 <dons> Shine: http://okmij.org/ftp/Scheme/monad-in-Scheme.html :)
19:22:34 <lambdabot> Title: Monads in Scheme
19:22:41 <wli> dons: Forget programming languages. Look at the mess in operating systems.
19:22:44 <dons> http://sleepingsquirrel.org/monads/monads.lisp
19:23:01 <wli> dons: There isn't even anything resembling an attempt at an over-arching theory of operating systems.
19:23:30 <dons> i was fortunate to go to a OS/systems school. so we got languages and OS design from the start.
19:24:13 <dons> the ad-hoc collection of techniques without underlying frameworks -- even where such frameworks exist -- is the worrying thing.
19:24:19 <wli> dons: Compare programming languages to operating systems. Programming languages have lambda calculus, pi calculus, all sorts of results on syntax, and so on.
19:24:44 <dons> so you might do databases, or data structures, or concurrency, without ever being given semantics, or anything on which to being reasoning about different features
19:24:56 <dons> wli, none of which are widely taught :/
19:25:04 <Shine> dons: thanks, the Lisp source looks a bit like my idea with defclass, but they have the same problem: Common Lisp can't dispatch on the return type
19:25:23 <wli> dons: Well, here they exist. You can do like LPS and get a programming language going from an abstract description and everything.
19:26:03 <wli> dons: There's nothing remotely like that for operating systems or a number of other sub-fields.
19:26:23 <wli> dons: So I'd argue that there's immaturity going on.
19:26:37 <dons> yeah, the more theoretical ends seem to be better fleshed out.
19:26:51 <dons> but the connection between theory and application seems to be neglected
19:27:09 <Shine> the do-monad macro is nice. How is the syntax for "<-" implemented in Haskell? Is it possible to extend the Haskell syntax within Haskell?
19:27:16 <wli> dons: I'd phrase it as there are only a few subfields that even have meaningful theoretical bases.
19:27:33 <dons> wli, yes, that seems reasonable
19:28:05 <mauke> Shine: no, it's hardwired
19:28:26 <monochrom> Shine: not <- alone, but: do { v <- E; F } is translated to E >>= \v -> F
19:28:36 <wli> So, returning to the problem of undergrad education vs. theoretical underpinnings...
19:28:40 <Shine> too bad. I've read something about Template Haskell
19:29:02 <Shine> I like the idea of some small basic building blocks and the rest implemented with these blocks, like it is possible in Lisp :-)
19:29:09 <monochrom> Err, actually, to let the recursive translation kick in: E >>= \v -> do { F }.
19:29:21 <mauke> AFAIK template haskell needs explicit invocation
19:29:29 <wli> Probably the only two or three fields with theoretical underpinnings are programming languages, numerical analysis, and analysis of algorithms.
19:29:50 <wli> Hardware design too, sorry.
19:30:06 <monochrom> Shine: the need for macro is less in Haskell, thanks to lazy evaluation.
19:30:39 <dons> wli, so i think my concern is that the power gained from PL theory is so great, yet it is so rarely taught.
19:30:47 <jcreigh> also, Haskell has an actual syntax for lambdas, which makes things easier.
19:32:02 <dons> so many issues we see, from all over the industry, become trivially explainable once you understand a bit of programming language theory.
19:32:11 <wli> dons: Well, from looking at what I've been going over, I think some of this may be arising from the total disjointness of vocationally-relevant sub-fields with those having theoretical bases.
19:32:21 <dons> yes, i agree.
19:32:28 <dons> the database guys don't talk to the declarative language guys
19:32:45 <dons> the OS guys don't talk to the language guys.
19:32:49 <dons> that kind of thing.
19:33:04 <wli> dons: I'd kill for something Prolog-based as a database query language vs. the crap that is SQL.
19:33:42 <dons> right, so the missing thing is a common, shared base of language theory, all the more vocational subfields could use to explain and understand what they're doing
19:34:05 <monochrom> Non-strictness (call-by-name or call-by-need laziness or ...) is really the key to compositionality, small basic building blocks and combine them for the rest. Macros is one way to get non-strictness.
19:34:17 <jfredett> you know, I just realized something, #haskell makes me less productive, because time spent here is usually time that I should be coding... :/
19:34:27 <Shine> jcreigh: you are right, many thing can be done with higher order functions etc., I think it is a matter of familiarization
19:34:29 <wli> dons: Another POV would be that the vocationally-relevant subfields need serious effort put toward development of theoretical bases for them.
19:34:37 <thorat> wli: have you seen: http://research.microsoft.com/~simonpj/papers/list-comp/index.htm
19:34:38 <lambdabot> Title: Comprehensive Comprehensions
19:34:39 <Shine> I've tried it in Lisp and it was really fun: http://www.frank-buss.de/lisp/functional.html
19:34:41 <lambdabot> Title: Functional Geometry
19:35:01 <monochrom> jfredett: The hope is that you write in Haskell and therefore have more free time :)
19:35:14 <jfredett> true, that
19:35:24 <thorat> it's not Prolog but still
19:35:42 <wli> thorat: LogicT will probably help here.
19:35:51 <thorat> ok
19:36:25 <dons> and without a common foundation, the industry will be subject to fads and belief.
19:37:11 <dons> php and agile programming, extreme testing etc. when people don't know the foundations for what they're doing, they can't reason or distinguish products meaningfully. lemons market stuff.
19:38:26 <shapr> My girlfriend says she's a Desperate Haskellwife.
19:38:38 <dons> when people like Paul Graham say things like `Brevity is one place where strongly typed languages lose.  All other things being equal, no one wants to begin a program with a bunch of declarations.' I worry.
19:38:43 <wli> dons: The foundations that exist have a hard time proving their relevance because their coverage is so poor.
19:38:48 <monochrom> @remember shapr My girlfriend says she's a Desperate Haskellwife.
19:38:48 <lambdabot> Done.
19:39:14 <thorat> so she's a Haskell-widow
19:39:44 <dons> wli, or just disconnected from the `vocational' fields?
19:40:09 <wli> dons: Yes.
19:40:23 <jcreigh> Haskell has been the first type system I've seen that's useful, as opposed to being something compiler writers make up to make their jobs easier.
19:40:57 <wli> jcreigh: Ever seen Standard ML or OCaml?
19:41:12 <monochrom> Lately I have taken up the tactic of hijacking the fashionable practice. E.g., I say, "test cases are partial specs too. take test-driven programming to the limit: test cases -> formal specs, testing -> proving!"
19:41:23 <Shine> dons: sounds like Paul Graham never heard of type inference
19:41:24 <jcreigh> wli: no, I haven't done anything with either of those. I suspect that they would be fairly nice as well.
19:41:44 <dons> Shine: that's what's so scary. given he's even delivered an invited talk at ICFP
19:41:53 <dons> and you know, HM is only 30 years old now.
19:42:04 <dons> *and* this guy is writing a language.
19:42:34 <dons> monochrom: can you elaborate? you high jack it by pointing to the limit case?
19:42:40 <jcreigh> pfft. arc is vaporware.
19:42:55 <dons> jcreigh: luckily :)
19:43:11 <monochrom> Yeah. Let n->oo. (n being number of test cases.)
19:43:32 <dons> jcreigh, but you know, in this industry any crap that builds a website can succeed. people can't distinguish good from bad. so php^h^h^h the bad wins.
19:43:53 <dons> monochrom: yeah, that's a good strategy
19:44:09 <dons> hey fnord123
19:44:27 <fnord123> hi all. I was rereading Brent's blog post and tried it with mapM
19:44:43 <dons> bring on 64 cores for the mainstream. i like disruptive technologies
19:44:46 <fnord123> > mapM (const [True, False]) [1,2,3]
19:44:49 <lambdabot>  [[True,True,True],[True,True,False],[True,False,True],[True,False,False],[Fa...
19:45:04 <monochrom> In terms familiar to you, as size of coverge grows, test-driven -> quickcheck, smallcheck -> full formal spec and proof.
19:45:36 <dons> yep.
19:46:05 <fnord123> but ...
19:46:16 <fnord123> > const [True, False] 1
19:46:16 <dons> so, manual test writing -> test generators -> type systems -> theorem provers :)
19:46:17 <lambdabot>  [True,False]
19:46:24 <fnord123> > const [True, False] 2
19:46:26 <lambdabot>  [True,False]
19:46:47 <mauke> > mapM (const [True,False]) [12, 12, 12]
19:46:50 <lambdabot>  [[True,True,True],[True,True,False],[True,False,True],[True,False,False],[Fa...
19:46:52 <fnord123> I may be stupid but shouldn't the first example end up with [[True, False], [True, False], [True, False]]
19:47:02 <monochrom> I try to sell the last one not as a rival to the others, but rather "what if you follow your current practice to its logical conclusion". So people are at least willing to learn it, if only for my interesting perspective.
19:47:09 <mauke> > map (const [True,False]) [12, 12, 12]
19:47:11 <lambdabot>  [[True,False],[True,False],[True,False]]
19:47:11 <jcreigh> fnord123: that's what "map" would do
19:47:32 <dons> monochrom: yes, i think that's a good strategy.
19:47:43 <dons> its about exposing the continuum
19:47:49 <dons> so people can see where their current practices sit
19:48:27 <dons> and we don't teach a `theory of testing, specifcation and proving' course, so people don't understand what their tests are trying to do :/
19:49:49 * kfish proves that this coffee is tasty
19:49:50 <lambdabot> kfish: You have 1 new message. '/msg lambdabot @messages' to read it.
19:52:34 <Shine> fnord123: there are some nice ideas at http://groups.google.de/group/comp.lang.lisp/browse_thread/thread/8315b0f71dd3bc02 and now my filterM translation to Lisp in the last article
19:52:36 <lambdabot> Title: powerset - comp.lang.lisp | Google Groups, http://tinyurl.com/34n3l4
19:53:29 <kfish> dcoutts, re: iconv, thanks :-)
19:53:37 <dcoutts> kfish: np
19:53:40 <Shine> my Java implementation in de.comp.lang.java was the worst :-)
19:54:26 <fnord123> thanks
19:54:34 <dolio> @instances Functor
19:54:36 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
19:55:10 <fnord123> I wonder if this is the type of idiomatic code diggins was complaining about
20:00:51 <wli> dons: Part of the reason why things aren't applied to operating systems is because the sorts of operation semantics people assume are totally contradictory to the kernel environment. Program-manipulable address translation, interrupts, and rigidly-bounded space against whose limits the executive bangs its head nonstop.
20:02:22 <SamB_XP> wait, what's strange about program-manipulable address translation ?
20:02:53 <wli> SamB_XP: TLB flushing, dcache flushing for VIVT, the fact it's privileged, etc.
20:03:19 <mauke> cabal is weird
20:03:28 <dons> wli, yeah, we've got a nice intersection of theory and practical guys in the OS group here. (microkernel/Isabelle/verification people). they seem to be building up a good body of theory for some parts of the microkernel design
20:03:50 <wli> dons: Heck, there isn't an operational theory for mmap() or signals in userspace, forget TLB manipulation and interrupts in-kernel.
20:03:57 <dons> but a lot of the problems come from the hardware itself I'd imagine: you're trying to deal with the hardware you've got, no the hardware you have
20:04:12 <dons> then those issues propagate through the os to userspace and languages
20:04:41 <dons> s/no the hardware you /not the hardware you *want*/
20:04:49 <wli> dons: Finite memory won't go away even with radical changes in the execution model supported by hardware.
20:05:13 <SamB_XP> *want* have?
20:05:24 <SamB_XP> dons: I didn't know you were from the south
20:05:31 <SamB_XP> ... of the us ...
20:05:53 <SamB_XP> wli: we have finite memory in userspace too, you know ;-)
20:06:03 <wli> dons: The privileged environment is not likely to match the execution model of the unprivileged environment owing to various things.
20:06:32 <wli> SamB_XP: Virtual memory and sufficient address space typically render it far less of an issue than for the kernel, which strains nonstop against those limits.
20:07:05 <SamB_XP> I don't see how the kernel doesn't have sufficient address space
20:07:12 <wli> SamB_XP: IOW the theoretical models work much better for userspace.
20:07:27 <wli> SamB_XP: The kernel is limited by physical memory, not address space.
20:07:37 <SamB_XP> o rly?
20:08:29 <wli> SamB_XP: It has to do its own overlays. It can't assume something beneath it presenting a virtualized view of effectively infinite memory.
20:08:49 <SamB_XP> well, okay.
20:09:00 <wli> SamB_XP: Hypervisors and kernel virtualization don't change that one iota.
20:09:07 <SamB> you know... I actually ran out of swap space once...
20:09:42 <wli> SamB: Now model that in a programming language semantics.
20:09:56 <mauke> SamB: me too. ld ate my RAM
20:10:55 <wli> You can simplify it all by considering even more restrictive environments, such as microcode in ASIC's.
20:11:54 <wli> No address translation. Possibly only polling IO (which is easier to model). Tightly bounded memory.
20:12:56 <wli> I think what it comes down to is richer models of finite control for things with vast state spaces.
20:13:56 <SamB> mauke: ... ld ... ate how much swap?
20:14:15 <mauke> a few hundred MB
20:14:28 * SamB has about a gig
20:14:35 <mauke> that was while trying to compile GHC 6.4 on an older machine
20:14:42 * wli runs with 4GB RAM and 4GB swap these days.
20:14:53 <wli> On a 3-year-old system, even.
20:14:53 <SamB> I think I was building JHC's library
20:15:10 <mauke> I learned from that experience: this machine has 20GB swap
20:15:25 <wli> mauke: Non-overcommit?
20:15:39 * ddarius used to build GHC (5.4 era) on a 64MB machine with 512MB swap.
20:15:41 <mauke> I think it was with overcommit
20:15:56 <SamB> mauke: but you don't have that on anymore do you?
20:16:10 <wli> mauke: That's enough swap you could probably use non-overcommit relatively easily.
20:16:32 <mauke> SamB: what do you mean by "have on"?
20:17:41 <SamB> mauke: isn't it a setting you can toggle easily?
20:17:55 <wli> echo 2 > /proc/sys/vm/overcommit_memory
20:18:11 <mauke> oh, the overcommit
20:18:37 <SamB> wli: it has 3 modes?
20:18:42 <Shine> is it possible to use Haskell on embedded systems like http://www.digi.com/products/embeddedsolutions/connectcorewi9c.jsp (16 MB RAM, 4 MB flash), and is it stable enough running for years without rebooting?
20:18:45 <lambdabot> Title: ConnectCore Wi-9C - First Embedded Module with Wired & Wireless Networking, http://tinyurl.com/y7fjkz
20:19:00 <mauke> now where is that documented
20:19:09 <SamB> Shine: I wouldn't particularly recommend it
20:19:25 <wli> Documentation/kernel-parameters.txt
20:19:39 <SamB> Shine: also, why do you need the flash if it runs for years ;-P
20:19:56 <wli> Shine: Probably not on account of not having been ported to the CPU core.
20:20:18 <mauke> no matches for 'commit'
20:20:20 <Shine> I've read GHC compiles to C code
20:20:26 <wli> Shine: And/or the embedded kernel used as an OS.
20:20:38 <ddarius> Shine: GHC wouldn't be the implementation to use.
20:20:48 <ddarius> Unless you want to write a backend.
20:21:13 <dons> Shine: it depends on the implementation. people use nhc98-compiled binaries on machines that size
20:21:16 <wli> Even -fvia-C won't help.
20:21:37 <dons> ghc binaries would even be fine on such a system, depending on what they did.
20:23:35 <SamB> dons: but think of the memory leaks ;-)
20:24:18 <Shine> I'm going to build a logging device with it for a customer and would be a good idea to learn a new language with this project, but memory leaks would be not funny
20:24:24 <dons> memory leaks seem to be either obvious, or non-existant, with a couple of exceptions
20:24:26 <ddarius> SamB: Memory leaks are a property of the program not the implementation (hopefully!)
20:24:53 <ddarius> @google "embedded functional reactive programming"
20:24:54 <lambdabot> No Result Found.
20:24:57 <brad_> hi, i was going to upload something to hackage but i am lacking a login id and i can't seem to get a response from the listed email admin, can anyone help?
20:25:00 <ddarius> @google "embedded FRP"
20:25:15 <lambdabot> Plugin `search' failed with: IRCRaised thread killed
20:25:18 <dons> brad_: ok. i can do that
20:25:21 <ddarius> @google "embedded FRP"
20:25:24 <lambdabot> http://www.ingentaconnect.com/content/nrc/cjce/2004/00000031/00000003/art00014
20:25:24 <lambdabot> Title: IngentaConnect Discussion of "Fibre-reinforced polymer composite bars for the co ...
20:25:34 <ddarius> Freakin' A
20:25:42 <Shine> I was thinking using Forth for it, but Haskell sounds like a good idea, too, because it is more safe (at least this was my idea)
20:26:05 <ddarius> @google real-time frp
20:26:08 <lambdabot> http://citeseer.ist.psu.edu/440607.html
20:26:08 <lambdabot> Title: Real-Time FRP - Wan, Taha, Hudak (ResearchIndex)
20:26:37 <mauke> man, some data formats/protocols are ridiculously easy to parse with haskell
20:26:51 <dons> brad_: privmsg?
20:27:01 <wli> mauke: Which ones?
20:27:05 <brad_> dons - how do i do a private message in irc?
20:27:06 <brad_> sorry
20:27:21 <mauke> wli: e.g. the one amarok uses for its scripts
20:27:30 <wli> dons: Any opinions on my thoughts wrt. richer models for finite control with large state spaces?
20:27:43 <dons> brad_: can you scroll through other windows? i've already initiated a privmsg conversatoin
20:27:59 <wli> mauke: I don't even know what amarok is.
20:28:04 <ddarius> @google amarok
20:28:06 <lambdabot> http://amarok.kde.org/
20:28:06 <lambdabot> Title: Amarok - Rediscover your music
20:28:22 <brad_> dons - i only see one window, i am using irssi
20:28:31 <mauke> brad_: type /query dons
20:28:37 <brad_> thanks mauke
20:28:48 <mauke> that should give you a new window
20:37:49 <dons> @tell vincenz try -O2 , and is there any difference if you use: data Tree a = C !a | P [Tree a] (and also adding -funbox-strict-fields?)
20:37:49 <lambdabot> Consider it noted.
20:48:21 <Shine> ddarius: I've heard of the FRP concept and http://www-sop.inria.fr/meije/esterel/esterel-eng.html looks interesting, because you can synthesize it in hardware, e.g. FPGAs
20:48:21 <lambdabot> Title: The Esterel Language
20:48:30 <cedricshock> Is there an extension I can turn on to avoid this:
20:48:31 <cedricshock>     Cycle in type synonym declarations:
20:48:31 <cedricshock>       Blacksmith.hs:172:0-33: type Logger b = b -> IO (Logger b)
20:48:36 <Shine> but for my application it doesn't matter if an event is recorded some 100 ms later, so a more conventional language is sufficient
20:49:54 <dolio> Logger b = b -> IO (b -> IO (b -> IO (..))) ?
20:50:12 <mauke> newtype Logger b = Logger (b -> IO (Logger b))
20:50:16 <cedricshock> dolio: Yeah.
20:51:31 <ddarius> cedricshock: No.
20:51:57 <ddarius> You need to use a newtype.  There are good-ish reasons for this.
20:53:08 <cedricshock> ddarius: Ok. I'll try it and see if I can understand it. I think I want something like a monad turned inside out or maybe a monad.  I'm not really sure.
20:59:55 <dons> ` I used to say that the sole value of static typing was intellisense support '
21:03:24 <hpaste>  cedricshock pasted "Help me express this with newtype instead of type" at http://hpaste.org/1578
21:04:06 <cedricshock> dons: What do you mean by that?
21:06:22 <dons> cedricshock: oh, just saw it on a scarily ill-informed blog
21:07:16 <dons> cedricshock: ok, what are you trying to do in that code? thread a random supply around?
21:07:21 <ddarius> cedricshock: A common trick is to write newtype T a = T { runT :: F a } to quickly get a deconstructor.  Then you just need to wrap and unwrap at the appropriate places.  The type checker will tell you where.
21:07:43 <ddarius> (Albeit, not necessarily very clearly.)
21:07:44 <cedricshock> The problem in the above paste is that I somehow need to get arguments from outside the newtype to inside the newtype.
21:07:58 <dons> yeah, unT/T
21:08:16 <dons> possibly it would be simpler to just wrap it monadically, and get the glue code for free?
21:08:37 <cedricshock> dons: I'm trying to thread a supply (possibly random) possibly interactive around.
21:08:54 <monochrom> cedricshock: I see a recursion that never ends. Is that a good thing?
21:08:56 <cedricshock> dons: Yeah. But I have no idea how to do that...
21:09:26 <cedricshock> monochrom: It shouldn't ever end. I should have an infinite stream of decision making.
21:09:42 <monochrom> OK I see now.
21:09:59 <Cale> cedricshock: You just have to wrap values of your type in the data constructor, and unwrap them when pattern matching or write a function to extract the field
21:10:54 <cedricshock> dons: It feels like I'm repeating monads somehow.
21:11:22 <mauke> :t foldM
21:11:25 <cedricshock> Cale: Thanks. I sort of figured that bit out, but I can't see where pr how to do it.
21:11:25 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
21:11:47 <Cale> cedricshock: Note that  Strategy :: ([b] -> IO (Strategy b, b)) -> Strategy b
21:12:32 <Cale> You can write:  applyStrategy (Strategy x) = x
21:13:17 <Cale> so that applyStrategy :: Strategy b -> [b] -> IO (Strategy b, b)
21:13:44 <cedricshock> Cale: I don't understand the source of the last Strategy b in your type.
21:14:14 <Cale> cedricshock: your own newtype declaration
21:15:09 <hpaste>  monochrom annotated "Help me express this with newtype instead of type" with "(no title)" at http://hpaste.org/1578#a1
21:15:10 <cedricshock> So the newtype Strategy is a "function" from a type to another type?
21:15:18 <Cale> Whenever you have a term (Strategy x), you know that x :: [b] -> IO (Strategy b, b), for some type b.
21:15:24 <Cale> yes
21:15:32 <cedricshock> Wow. That's deep
21:15:47 <Cale> In fact, it's an isomorphism
21:16:04 <Cale> (which is what's guaranteed by newtype)
21:17:55 <monochrom> This code feels strange because it only returns Strategy, but never inputs Strategy...
21:17:56 <Cale> er, sorry,  Strategy b is isomorphic to [b] -> IO (Strategy b, b)
21:18:14 <Cale> I didn't mean to say that b is isomorphic to Strategy b, which is of course false.
21:18:33 <cedricshock> so we could have a keyword noobtype that would do what my type declaration did? Or not because it hasn't been labeled.
21:19:03 <Cale> The labelling is necessary in this case.
21:19:05 <cedricshock> The magic is in the name of the type. That's wierd.
21:19:16 <Cale> Because your newtype is recursive.
21:19:45 <Cale> If you tried to do that with type, and the compiler allowed it, it would get itself into an infinite loop while expanding the type alias.
21:20:30 <cedricshock> Which is why I at first though it was the compiler's fault.
21:20:34 <Cale> Because then  Strategy b = [b] -> IO (Strategy b, b) = [b] -> IO ([b] -> IO (Strategy b, b), b) = ...
21:20:54 <Cale> It'll never finish expanding the type synonym.
21:22:30 * cedricshock studies monochrom's example. I noticed that my types felt wierd for the same reason.
21:22:37 <Cale> Since the newtype declaration creates a type which is distinct from the original type, there's no problem with that anymore.
21:23:29 <Cale> random_strategy r = Strategy . random_strategy' r
21:23:41 <Cale> er, no
21:23:46 <Cale> random_strategy = Strategy . random_strategy'
21:24:49 <cedricshock> monochrom: I like the split between the two strategies in your code. One says I'm returning a Strategy when the rng finishes, and one says that when I construct it from a prng it needs to be a strategy.
21:25:09 <monochrom> Some users may find random_strategy' useful.
21:26:05 <cedricshock> Yeah. In all my depth first searches it's always the one of the pair of functions called by the list of successors, rather than by the last visited node that gets used all the time.
21:27:02 <cedricshock> Some day I'm going to understand monads and arrows when I accidentally invent them...
21:28:04 <monochrom> Oh haha, now I see (\list -> random_strategy' r list) = random_strategy' r
21:28:39 <cedricshock> Yeah. It's kind of neat.
21:38:02 <cedricshock> I need a book like "Writing library interfaces with Monads and Arrows" (which is sort of what the 2000 arrow book is)
21:57:08 <cedricshock> Which type is "expected" and which type is "inferred"
21:57:53 <mauke> expected is outside, inferred is inside
22:00:09 <cedricshock> Which side is outside for <- ?
22:00:36 <mauke> depends :-)
22:01:22 <cedricshock> In pattern matching in <-? or let ... = ?
22:07:58 <cedricshock> Which is expected and which inferred in the pattern matching of: (provider', b') <- provider b    Or is that not enough to know which way the inference is going?
22:08:31 <mauke> what's the error message?
22:10:02 <cedricshock>     Couldn't match expected type `b -> IO t'
22:10:02 <cedricshock>            against inferred type `UnknownProvider b'
22:10:02 <cedricshock>     In a 'do' expression: (provider', b') <- provider b
22:10:02 <cedricshock>     In the expression:
22:10:02 <cedricshock>         do (provider', b') <- provider b
22:10:23 <sjanssen> cedricshock: usually 'expected' is the type that other parts of the code want an expression to be, and inferred is the type that the expression really has
22:10:48 <mauke> apparently provider :: UnknownProvider b
22:10:57 <cedricshock> It has something to do with the monad... Yes.
22:11:00 <mauke> but the code uses it as if it was a (b -> IO t)
22:12:06 <cedricshock> Yeah, I guess. a. la: newtype UnknownProvider b = UnknownProvider (b -> IO (UnknownProvider b, b))
22:12:52 <cedricshock> I think I need a way to get things out of my newtype... I think I'm going to duplicate Monad at the end of this all, but I have no idea how to start there.
22:13:23 <mauke> runProvider :: UnknownProvider b -> (b -> IO (UnknownProvider b, b))
22:13:35 <mauke> runProvider (UnknownProvider x) = x
22:13:53 <mauke> (provider', b') <- runProvider provider b
22:14:31 <cedricshock> mauke: Thanks. I had just gotten as far as the function. Thanks for the type. Now is this a behaviour of monads, or not a behaviour of monads?
22:14:54 <mauke> I don't think this has anything to do with monads
22:15:02 <mauke> it's just wrapping/unwrapping
22:16:06 <mm_freak_> i need some postgresql interface…  which module would you recommend?
22:16:21 <cedricshock> Yeah. I think if it were monadic I could never get the b' out, only the next provider. Andthen my code would be monads inside monads, which would probably be right...
22:17:09 <ddarius> cedricshock: The "no way out" thing is not an aspect of monads.
22:17:17 <ddarius> Despite many people saying otherwise.
22:17:39 <mauke> well, it is. kind of.
22:18:05 <mm_freak_> HSQL is failing for some strange reason:  ghc4423.hc:(.text+0x30): undefined reference to `__stginit_DatabaseziHSQL_'
22:18:08 <mauke> Monad has no method to get out of a monad
22:18:18 <cedricshock> Hmm. That is certainly most interesting knowledge.
22:18:22 <mauke> many monads do have such an operation but it's not part of the common interface
22:18:35 <ddarius> It's not a generic operation.
22:18:51 <cedricshock> mauke: Could that be because it's not true for all monads, instead of it being not true for all monads. Ahh Exactly.
22:19:12 <jfredett> ?where syntaxfree
22:19:13 <lambdabot> I know nothing about syntaxfree.
22:19:19 <jfredett> ?seen syntaxfree
22:19:20 <lambdabot> syntaxfree is in #oasis, #haskell-icfp07, #haskell and #haskell-blah. I last heard syntaxfree speak 5h 24m 55s ago.
22:20:23 <ddarius> mauke: I could then just as well say that "no way out" is an aspect of functors in general (for example).
22:20:34 <ddarius> "no way in" too.
22:20:45 <mauke> right
22:21:41 <mauke> .oO( Sumpf des Verderbens - kein Eingang, kein Entkommen )
22:22:37 <HWSOD> \msg NickServ koklama
22:24:37 <kfish> dcoutts, i have some documentation and example code patches for your iconv bindings, how should i send them to you?
22:25:23 <cedricshock> Whee! Successful compilation of the core of my program. Thanks fro all your help!
22:27:52 <ddarius> And of course, since it compiled it will surely work.
22:30:24 <cedricshock> ddarius: That's my experience, yeah. There's a total of 3 "non-trivial" lines of code. I don't see where I could have made a logic mistake.
22:30:40 <cedricshock> though the trivial lines of code were sure toughies!
22:46:41 <mrd> did i miss all the fun
23:03:51 <brad_> can a function return "Maybe IO String"?
23:04:52 <mauke> no, only Maybe (IO String)
23:04:59 <collinge> a function which returns Nothing or an action - why not?
23:05:29 <brad_> okay thanks mauke, collinge!
23:16:30 <Cale> :t sequence
23:16:39 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
23:16:53 <Cale> :t Data.Traversable.sequence
23:16:58 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Data.Traversable.Traversable t, Monad m) => t (m a) -> m (t a)
23:17:37 <Cale> :t Data.Traversable.sequence :: Maybe (IO String) -> IO (Maybe String)
23:17:39 <lambdabot> Maybe (IO String) -> IO (Maybe String) :: Maybe (IO String) -> IO (Maybe String)
23:17:51 <Cale> neat.
