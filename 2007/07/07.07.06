00:00:13 <ChilliX> sorear: trac works for me
00:00:23 <ChilliX> I agree with what you wrote
00:00:32 <sorear> ChilliX: Internal error: Database is locked
00:01:09 <ChilliX> The problem is exactly that the equality between newtypes and their representation in FC escapes into Haskell land by way of newtype deriving
00:01:18 <ChilliX> We can't change Haskell
00:02:03 <ChilliX> (Well, we really don't want to, as this would also mean that we cannot use newtypes as type parameters for type families.)
00:02:25 <ChilliX> Maybe we can use a new kind constructor in FC
00:02:50 <ChilliX> An alternative we discussed was distinguish two different "equality" relations
00:03:13 <ChilliX> In any case, the trick is to keep track of which equalities have been introduced by newtypes and which not
00:05:45 <sorear> I think that's exactly what I just suggested.  if CO pprs as ~, then maybe NCO pprs as ~~
00:06:44 <ChilliX> Yes, the above was just a verbose way of agreeing with what you wrote.
00:06:49 <sorear> ChilliX: ok, trac seems definitely-broken - I can see my comment but didn't recevie the notify
00:07:07 * sorear apparently cahnt speel either
00:07:29 <ChilliX> right, I didn't get a notify either
00:07:33 <ChilliX> :/
00:07:36 <sorear> no, I just can't read.  I *did* spell it right
00:07:48 <dons> i just got a notify of a change to #1496
00:07:56 <dons> on glasgow-haskell-bugs@haskell.org
00:08:11 <dons> `Comment (by sorear)'
00:08:31 <ChilliX> hmm, thought I should have gotten a CC
00:08:32 <sorear> dons: Me too.  trac is just really slow
00:09:07 <sorear> does haskell.galois.com have any unnice cron jobs running now?
00:09:39 <dons> maybe, its midnight.
00:10:23 * sorear was about to say On the west coast - oregon is 3000 miles east of midnight
00:10:34 * sorear is apparent just tired.
00:10:38 <sorear> night all.
00:11:04 <ChilliX> night
00:11:46 <kral> ahoy all
00:14:49 <dons> http://programming.reddit.com/info/23z4e/comments
00:14:50 <lambdabot> Title: Haskell and Number Theory: The End of GCD (reddit.com)
00:22:09 <Saizan> uhm, it doesn't say anything about whnf, making it sounds like seq reduces to nf..
00:28:01 <dons> ?src print
00:28:02 <lambdabot> print x = putStrLn (show x)
00:35:28 <dons> nice paper, http://programming.reddit.com/info/23z7n/comments
00:35:29 <lambdabot> Title: Who needs Prolog? Implementing backtracking computations with monads (pdf) (redd ...
00:35:41 <dons> someone -- dolio ?? -- should package it up on hackage..
00:37:04 <dons> dolio: around? looking for a new challenge -- or still pondering ripping out the zipper delimited contT stuff?
00:38:21 <dolio> Ah, LogicT.
00:38:44 <dons> yeah. that should be on the hitlist of abstractions we need packaged
00:38:55 <dons> LogicT, Control.Comonad, something with delimited continuations
00:40:36 <opqdonut> sounds cool (the article)
00:40:44 <dolio> According to Oleg, a MTL-like delimited continuation monad might not be feasible.
00:41:04 <dolio> He thinks the type errors I ran into are a fundamental issue with monad transformers.
00:41:17 <dons> yes, I read that post. very interesting
00:41:24 <dolio> (And it turns out he'd encountered them before, of course :))
00:41:41 <dons> dolio: so the best we could do would be to avoid the transformer version?
00:42:32 <dolio> I guess. There could be just a monad. Although, actually, the type errors only surface when you wrap a delcont monad with something else.
00:43:03 <dolio> But, then again, that's what you have to do to get full control over the side effects in the other monad.
00:43:09 <dolio> I think, at least.
00:44:48 <dolio> I'd probably stick with both the transformer and the monad, since he noted it could be useful to transform IO.
00:45:16 <dolio> But leave out the instances for WriterT (DelCont ...) and stuff like that.
00:45:44 <dons> here's LogicT src, btw, http://okmij.org/ftp/packages/LogicT.tar.gz
00:45:50 <dons> if someone wants to look over it and cabalise it
00:45:56 <dons> dolio: yeah
00:47:04 <quicksilver> hmph no ndm :(
00:47:36 <dons> oleg has a weird publishing strategy
00:47:38 <mgsloan> I think maybe what I'm trying to do with haskell is impossible or requiring serious olegs
00:47:43 <dons> he really should be putting the src into cabal :/
00:49:01 <quicksilver> well oleg's code is often more of an interesting example of a type system trick
00:49:07 <quicksilver> than a re-usable library
00:49:33 <dolio> That LogicT code has several implementations. :)
00:49:51 <dolio> And at least two implementations of delimited continuations. :)
00:49:54 <dons> the monads and monad transformers seem like possible candidates
00:50:18 <dons> since they're reusable by design
00:51:36 <mgsloan> I need to pass types around as vars
00:51:47 <dons> (undefined :: T) ?
00:51:50 <mgsloan> then use that type var to indicate the desired instance for a function
00:51:56 <dons> yep
00:52:18 <mgsloan> I thought of that, but rejected it for some reason
00:52:24 * mgsloan tries to figure out the reason
00:52:29 <glguy> because it looked like a hack? :)
00:52:43 <dons> that's the standard method for type dispatching to instances
00:53:12 <dons> class Module m s | m -> s where
00:53:18 <dons>     moduleSticky    :: m -> Bool
00:53:22 <dons> for example, in lambdabot.
00:53:28 <dons> is indexed by the type representing the module
00:53:30 <mgsloan> oh yeah, I need there to be a class function which returns a type var given a string
00:53:36 <glguy> dons: if GHC.Base has unpackCStringUtf8#, why do we need to jump through hoops to get UTF-8 decoding in readFile ?
00:53:44 <mgsloan> then call a polymorphic function based on that typevar
00:54:06 <dons> glguy: hmm. let me see...
00:54:20 <hpaste>  quicksilver pasted "Using TagSoup (darcs version) to 'refactor' tag-soupy HTML" at http://hpaste.org/1567
00:54:21 <mgsloan> (the class function needs a returntype...)
00:54:40 <quicksilver> ^^ wanted ndm to see, but anyone else might be interested.
00:54:55 <quicksilver> technique for adding 'semantic' markup to the kind of rubbish MS Word HTML export produces
00:55:21 <quicksilver> although, I can't get through to hpaste any more :(
00:55:48 <quicksilver> glguy: hpaste just dieded?
00:55:49 <dons> glguy: oh, needs to be null terminated currently
00:56:46 <glguy> quicksilver: I have no idea what hpaste is doing.
00:57:05 <glguy> it has been acting screwy since sorear started it up today
00:57:13 <glguy> and no one seems to know what it wrong, seems like a HAppS issue
00:57:25 <dons> you could revert sorear's changes. that'd get it fixed
00:57:39 <quicksilver> glguy: it accepted my paste (and annoucned it) but I never got the confirmation page in my browser
00:57:39 <glguy> I don't think it's his fault
00:57:52 <glguy> I think it is that its built to the new version of happs
00:57:56 <dons> ah
00:58:29 <glguy> which is not compatible to the one that was running
00:58:36 <glguy> and recieving spam
00:59:43 <ttmrichter> OK, I'm really not able to figure out how to get Haddock to work.  Is there any Haddock expert online I could have a chat with?
01:01:10 <Shimei> So, after I added some cabalization to a library, attempting to build it gives this error: "Could not find module `Monad': it is a member of package haskell98, which is hidden"
01:01:14 <quicksilver> The proxy server received an invalid response from an upstream server.
01:01:14 <quicksilver> The proxy server could not handle the request GET /1567.
01:01:14 <quicksilver> Reason: Error reading from remote server
01:01:20 <Shimei> What's the best way to work around that?
01:01:25 <quicksilver> glguy: apologise for pasting in channel :) but that's what I got, finally.
01:01:41 <quicksilver> Shimei: don't use Monad, use Control.Monad?
01:03:31 <quicksilver> Anyhow, if anyone is interested in my HTML refactoring combinators, it's at http://paste.lisp.org/display/44032
01:03:35 <Shimei> Hmm, I guess the build dependencies doesn't let me use shortcut names like that hten.
01:03:42 <quicksilver> morph :: ([a] -> Maybe (b,[a])) -> (b -> [a]) -> [a] -> [a]
01:03:49 <quicksilver> ^^ I think this is a rather interesting type
01:03:54 <quicksilver> Shimei: Monad is not a shortcut
01:04:03 <quicksilver> Shimei: Monad is the old name from the old (deprecated) library naming scheme
01:05:05 <Shimei> Ah, okay. Strange. This code (not written by me) isn't that old. 2006 or so.
01:05:31 <quicksilver> there is a way to tell Cabal to unhide haskell98, if you really want the old names, I think. I've no idea what it is, though :)
01:06:33 * quicksilver reverts to the positively prehistoric 'email' to communicate with ndm
01:07:34 <opqdonut> quicksilver: what does morph do? morph f g l applies f to l and if it is Just (b,list) then does list++g b ?
01:08:02 <quicksilver> opqdonut: it takes a 'selector' which is really the same type as a parser
01:08:13 <quicksilver> opqdonut: the selector can either fail, in which case data is passed through unchanged
01:08:27 <opqdonut> or then the selected data is transformed?
01:08:30 <quicksilver> opqdonut: if the selector succeeds, it returns some tandom type 'b' which is fed to the 'transformer'
01:08:33 * quicksilver nods
01:08:36 <opqdonut> yeah :)
01:08:44 <quicksilver> the second return of the selctor is intended to be a tail of the initial stream
01:08:53 <opqdonut> yes, that is obvious
01:09:04 <opqdonut> or so i fathomed
01:09:07 <quicksilver> opqdonut: I use it to select balanced <tag>...</tag> groups out of a stream
01:09:13 <quicksilver> opqdonut: and then rewrite them
01:09:24 <opqdonut> yep, okay
01:09:36 <opqdonut> so my guess was practically right \o/
01:09:46 <quicksilver> so I can rewrite <strong> to <span class="semanticallysensible">
01:09:53 <quicksilver> :)
01:10:04 <glguy> ?tell Saizan I was playing with your prune function in Factor, : prune V{ } clone dup rot over empty? [ over peek over = not ] unless* [ swap push ] [ drop pop* ] if ] each-with ;
01:10:04 <lambdabot> Consider it noted.
01:10:11 <quicksilver> opqdonut: yeah, it's g b ++ list, not list ++ g b :)
01:10:36 <opqdonut> that's just an implementation detail
01:10:37 <opqdonut> :)
01:10:41 <quicksilver> :)
01:10:50 <quicksilver> indeed, although your version re-orders the stream in a surprising way
01:11:16 <mgsloan> ah, figured out a way to do what i need to do.  highly hacky and removes the generality, and uses fundeps, but hey
01:11:20 <glguy> also ruby: input.inject([]) { |a,b| if a[-1] == b then a[0..-2] else a << b end }
01:11:25 <opqdonut> yeah, don't know what i was thinking heh
01:11:58 <opqdonut> mgsloan: what are you up to?
01:12:28 <Saizan> glguy: was it so interesting?:) Factor is stackbased, right?
01:12:28 <lambdabot> Saizan: You have 1 new message. '/msg lambdabot @messages' to read it.
01:12:36 <Saizan> @clear-messages
01:12:36 <lambdabot> Messages cleared.
01:12:50 <glguy> Saizan: yeah, stack based
01:13:00 <glguy> Saizan: I like toy algorithms :)
01:13:36 <mgsloan> opqdonut: a crazy scheme.  Trying to write a haskell library which writes binary files such that the format of the rest of the file is written first, then the content
01:13:48 <mgsloan> so it's kinda like xml for binary
01:14:08 <opqdonut> ok
01:14:16 <dolio> dons: Incidentally, I'll see if I can turn LogicT into a suitable library. Oleg's 'Delimited Dynamic Binding' paper was a little heavy; this should be easier for the time being. :)
01:14:41 <mgsloan> and I'd probably be way better off trying to do it in a more dynamic/reflective language
01:15:00 <glguy> Saizan: I don't remember what I ?telled you
01:15:06 <glguy> if I did
01:15:25 <Saizan> you telled me the foldr one
01:15:47 <glguy> ah
01:16:01 <Saizan> which was kind of embarassing to see, after my convoluted solution :)
01:16:48 <dons> dolio: good stuff!
01:16:56 <dons> hmm UTf8 isn't so hard after all :}
01:17:06 <dons> but we really need ByteStringUTF8 to avoid every building [Char]
01:17:19 <dons> but .. at least we can do UTF8 [Char] IO pretty easily now
01:17:25 <vincenz> dons: do yo want the Delimited Dynamic Binding paper as a lib?
01:17:35 <dons> i've not looked at that yet
01:17:48 <dons> but haskell should *own* these abstractions :-)
01:20:53 <dons> i started a list of abstractoins that should be usable from hackage: http://haskell.org/haskellwiki/Wanted_libraries#Libraries_to_package
01:20:55 <lambdabot> Title: Wanted libraries - HaskellWiki, http://tinyurl.com/26rt82
01:22:03 * wolverian votes for a maildir library
01:23:05 * earthy mutters ffmpeg
01:23:27 <dons> please put up your suggestions on the wiki
01:23:36 <dons> if we've a list to refer to, then perhaps we're a little more likely to get them done
01:24:00 * earthy mutters something about 'working on it already'
01:25:45 <vincenz> dons: I could prolly hack the delimited continuations one
01:26:00 <dons> that'd be great, vincenz. you should talk to dolio about it.
01:26:36 <vincenz> dolio: ^^^
01:28:35 <dolio> Well, what I posted to the mailing list has instances for most of the classes in MTL.
01:29:09 <dolio> Although, I haven't checked extensively that they do what you'd expect them to do.
01:29:09 <vincenz> dolio: have a direct link?
01:29:19 <vincenz> or something googly?
01:29:53 <dolio> http://article.gmane.org/gmane.comp.lang.haskell.cafe/24923
01:29:55 <lambdabot> Title: Gmane -- Mail To News And Back Again
01:30:04 <dolio> It has some arbitrary renamings from the paper, though.
01:30:24 <dolio> And apparently I was working from an old version of the paper. They updated a couple things in the new version.
01:31:16 <dolio> The newest version of the paper is here: http://www.cs.indiana.edu/~sabry/papers/monadicDC.pdf
01:31:38 <dolio> Actually, this is probably more useful: http://www.cs.indiana.edu/~sabry/
01:31:38 <lambdabot> Title: Academic Page for Amr Sabry
01:31:43 <dolio> It also has an archive of the code.
01:32:09 <dolio> http://okmij.org/ftp/Computation/Continuations.html#zipper-fs
01:32:10 <lambdabot> Title: Continuations and delimited control
01:32:32 <dolio> Oleg's page there has an implementation as a monad transformer, which is what the version I posted to the mailing list is, too.
01:32:48 <dolio> Included in the ZFS archive.
01:33:07 * vincenz nods
01:33:21 <dolio> Anyhow, the module names aren't great on any of them.
01:35:48 <dolio> It might be good to rename things back to CC and CCT, instead of DelCont and DelContT like I did, I don't know.
01:35:56 <dolio> So it matches the paper more.
01:36:17 <dolio> Although that's pretty uninformative.
01:37:23 <DRMacIver> Morning
01:37:52 <Korollary> ?users #haskell
01:37:52 <lambdabot> Maximum users seen in #haskell: 354, currently: 297 (83.9%), active: 15 (5.1%)
01:38:02 <vincenz> dolio: I'll have to take some time to look at your code and let it sink in
01:38:46 <dolio> vincenz: Okay. It's the frame-based implementation from the paper, same as Oleg's.
01:39:15 <glguy> delimited continuations have additional overhead, right?
01:39:19 <dolio> vincenz: It'd probably be nice to rewrite it to use the GADT for type equality, eliminating the PushCO constructor.
01:39:26 <glguy> compared to basic ones
01:40:56 <dolio> I suppose. It's not as simple a transformation as CPS.
01:41:19 <vincenz> I don't know about that
01:41:33 <dolio> It probably depends a lot on your implementation method.
01:41:48 * vincenz thinks DCs are cleaner than CCs
01:44:02 <squark> hello everybody :)
01:45:07 <squark> is there an equivalent to gem for haskell?
01:46:01 <vincenz> cabal
01:46:07 <mgsloan> it's being worked on
01:46:30 <mgsloan> cabal works, but at the moment its a bit manual as far as installation and dep downloading goes
01:47:53 <mgsloan> fundeps have failed me: Ambiguous type variables `t', `a', `b', `c'
01:47:55 <dons> squark: yeah, cabal packages. visit hackage.haskell.org
01:48:52 <mgsloan> I would download ghc and do it with type families
01:49:15 <mgsloan> but that'd probably take a while to compile
01:49:28 <Cale> mgsloan: What are you working on? Also, there are nightly builds
01:50:51 <mgsloan> it's a crazy scheme (for fun).  Trying to write a haskell library which writes binary files such that the format of the rest of the file is written first, then the content
01:51:27 <Cale> cool, what's the issue with functional dependencies?
01:51:59 * glguy needs beauty rest
01:52:05 <glguy> threadDelay maxBound
01:52:31 <mgsloan> well, I'm trying a very hacky method of transferring type vars
01:52:59 <dons> i think that's 31 minutes, glguy :-)
01:53:07 <dons> :t Control.Concurrent.threadDelay
01:53:10 <lambdabot> Int -> IO ()
01:53:18 * glguy runs x86_64
01:53:22 <dons> hah
01:53:43 <Saizan> > 2^64/10^6
01:53:46 <lambdabot>  1.844674407370955e13
01:53:49 <mgsloan> by this I mean that I can specify which variant (proper term?) of a polymorphic function is called
01:55:36 <mgsloan> http://paste.lisp.org/display/44033
01:57:02 <mgsloan> I think this is one of those rare cases where actual type variables are necessary, and even proper
01:58:21 <Cale> I'm not sure what the 'a' 'b' and 'c' are for.
01:58:49 <mgsloan> they are possible types for use within the constructor
01:59:53 <mgsloan> so like in Either Int String = Left Int | Right String, a would be Int, b would be String
02:00:18 <Cale> hmm. Do you know about Data.Generics?
02:00:23 <mgsloan> yeah
02:00:30 <mgsloan> I don't think it does what I need
02:00:39 <Cale> Really?
02:00:44 <mgsloan> it might
02:01:25 <Cale> mm, of course, reading a file out again might be tricky :)
02:01:56 <Cale> You can't just create types on the fly from TypeReps.
02:02:05 <mgsloan> writing won't be so hard
02:02:21 <mgsloan> yeah, that'd be the issue
02:03:05 <quicksilver> Cale: you can create types on the fly using fromConstr BUT
02:03:17 <quicksilver> Cale: you have to determine the type by the context
02:03:23 <quicksilver> Cale: you can't allow the data to choose the type
02:03:24 <Cale> Well, you can create values
02:03:29 <quicksilver> sorry, that's what I meant
02:03:51 <quicksilver> but still, you have to provide the type checker with the type you're hoping to read
02:03:55 <Cale> right
02:04:01 <quicksilver> you can't get an 'existential bundle'
02:04:06 <quicksilver> of whatever type there is
02:04:07 <Cale> In which case, why are you bothering with all this nonsense? :)
02:04:18 <mgsloan> yeah, as you can see I've got an existential field type
02:05:28 <Cale> I think it's fundamentally pretty tricky to get right, since types are compile-time-only things in Haskell.
02:08:36 <quicksilver> Cale: it needs compiler support, certainly
02:08:38 <Cale> You seem to need dependent typing.
02:08:40 <mgsloan> ah, I think I have an idea of a way to do it.. will require a bit of boilerplate for the user, but hey, already had that with the fundeps version
02:08:47 <mgsloan> perhaps
02:08:52 <quicksilver> Cale: but what's frustrating is that the compiler support is already there, in deriving Data
02:09:02 <quicksilver> Cale: it's just the the right API isn't quite exposed
02:11:28 <Cale> Well, the best I can see doing without having types that are determined by information at runtime is to return some existential type which was guaranteed to be an instance of Data.
02:11:35 <quicksilver> yes
02:11:52 <quicksilver> deriving Data effectively gives you proxies for runtime type information
02:12:03 <mgsloan> that wouldn't be so bad
02:12:06 <quicksilver> although you might imagine another more tightly targeted deriving
02:12:12 <quicksilver> for this particular case
02:12:18 <quicksilver> (normally you want to choose the existential)
02:12:30 <quicksilver> as is readMessage :: IO (exists s => Message s)
02:12:41 <quicksilver> erm
02:12:49 <quicksilver> as is readMessage :: IO (exists s . Message s => s))
02:12:52 <quicksilver> I mean :)
02:13:47 <quicksilver> but as I say, it 'feels like' the information ought to be there in Data. But I don't think it is.
02:13:54 <quicksilver> (or, the API to it isn't exposed, anyway)
02:14:00 <Cale> I think I'd prefer a plain old tree myself.
02:15:01 <quicksilver> ?
02:16:40 <Cale> That is, rather than some existential version of the tree of constructor applications.
02:17:18 <mgsloan> woo! compilation!
02:17:58 <mgsloan> http://paste.lisp.org/display/44033#1
02:18:43 <mgsloan> now to get it to write
02:18:49 <mgsloan> and see if it works
02:20:47 <mgsloan> heh, it already can write, i think
02:21:50 <mgsloan> hmm, an instance..
02:23:09 <quicksilver> Cale: plain old tree being "untyped", though? you'd still need a primitive to inject it into the type system somehow
02:23:34 <quicksilver> Cale: ... which is the kind of thing you could write in TH or hopefully as a deriving rule for one of the derivers
02:26:24 <Cale> I guess I just don't have terribly high standards for automation when it comes to parsing files.
02:27:41 <Cale> If you have the tree, and you know what type of data it is that you're trying to read, it's fairly easy to recurse over the tree and build the values again.
02:28:00 <quicksilver> of course
02:28:09 <quicksilver> This is all about when you *don't* know the type of data
02:28:24 <quicksilver> using a class as an extensible data type
02:28:29 <quicksilver> (c.f. xmonad and the Message class)
02:28:35 <Cale> If you don't know the type of data, then I think you're better off just with a tree of strings or whatever.
02:28:38 <quicksilver> and wanting to demarshal corrctly
02:28:57 <mgsloan> a user of your stuff might know the type of data, though
02:29:17 <quicksilver> if they do then fromConstrM is good enough
02:29:24 <mgsloan> oh
02:30:01 <quicksilver> you can declare mgsCleverRead :: Data a => IO a
02:30:05 <quicksilver> (using fromConstrM internally)
02:30:14 <quicksilver> and they 'instantiate it' to the type they're expecting
02:30:46 <quicksilver> myvar <- mgsCleverRead :: QSBigDataType
02:31:11 <quicksilver> that's basically the model that 'gread' uses
02:31:13 <quicksilver> and it works
02:31:33 <quicksilver> Data.Binary has an equivalent trick
02:31:41 <quicksilver> (except the type class used is Binary, not Data)
02:32:41 <mgsloan> hmm
02:32:52 <Saizan> Data.Binary doesn't really have a "trick" it's the instance that guides the parsing, you don't have a single parsing function with instances that tells you what to expect
02:32:56 <mgsloan> so perhaps I can steal some of Data.Binary 's tricks
02:33:15 <dons> yeah, its just recursively breaking down the structure by dispatching to instances
02:33:19 <dons> no type trickery
02:33:26 <mgsloan> yeah, tubad :(
02:33:27 <dons> or rebuilding it by dispatching.
02:33:41 <dons> the compiler turns it into straight line reads and writes from memory too
02:33:43 <dons> which is rather nice
02:33:51 <dons> (and why its so fast)
02:34:14 <mgsloan> cool
02:34:44 <dons> and yeah, you use type annotations to pick the instance to dispatch to, where its not inferred
02:34:53 <Cale> heh, http://uk.youtube.com/watch?v=_JTbJdLwqMo -- space invaders in real life.
02:37:36 <quicksilver> dons: it's class trickery in the sense that it requires a special deriving, or hand-written instances
02:37:40 <quicksilver> dons: that's all I meant by "trick"
02:37:45 <quicksilver> I do understand how it works :)
02:38:16 <mgsloan> you might want a custom binary representation
02:39:40 <mgsloan> user-definable derivings would be a nice feature, though
02:40:17 <quicksilver> mgsloan: you can choose a custom rep
02:40:25 <quicksilver> mgsloan: you don't have to use the 'deriving Binary' if you don't want to
02:40:34 <quicksilver> mgsloan: Data.Binary is very flexible
02:40:36 <mgsloan> I know!
02:40:50 <quicksilver> hand written instances are a pain though
02:40:59 <norpan> if you don't mind the syntax, can't you use template haskell for user-definable derivings
02:41:06 <mgsloan> well, dons has that SYB generator
02:41:07 <quicksilver> then again deriving instances exposes you to future backward incompatible pain
02:41:11 <quicksilver> possibly
02:41:20 <quicksilver> depending how disciplined the Data.Binary guys are
02:41:21 <quicksilver> :)
02:41:29 <mgsloan> norpan - cool!
02:41:49 <mgsloan> the big-endianness seems a bit off
02:41:52 <mgsloan> odd
02:43:18 <dons> quicksilver: yes :-)
02:44:13 <mgsloan> I still think the Integer instance should store its length in its tag
02:45:40 <quicksilver> I use the algorithm : if i < 127 { store as one byte } else { store length + 128 ; bytes }
02:45:41 <dons> mgsloan: it does, in bytes
02:45:55 <quicksilver> which is a nice one if you believe you use lots of ints under 127
02:45:59 <quicksilver> which my particular use case does
02:46:11 <dons> it writes a byte tag
02:46:24 <dons> then, if its fits in a Int32, it just writes that int
02:46:36 <dons> otherwise, it writes the number of bytes for the integer, and then each byte
02:46:43 <dons> and a sign
02:46:49 <dons>     put n = do
02:46:49 <dons>         putWord8 1
02:46:49 <dons>         put sign
02:46:49 <dons>         put (unroll (abs n))         -- unroll the bytes
02:46:50 <mgsloan> well, writes the tag first
02:46:54 <mgsloan> right
02:46:56 <dons> tag, sign, length, bytes
02:47:05 <dons> for small ints, tag , bytes
02:47:18 <wolverian> does anyone have a declarative gui framework comparison up somewhere? :)
02:47:31 <dons> wolverian: there's one on haskell.org
02:47:45 <dons> it mightn't include the new ones though
02:47:55 <wolverian> I found the list in GUI libraries, there's a comparison too?
02:47:59 <dons> http://haskell.org/haskellwiki/Applications_and_libraries/GUI_libraries
02:48:02 <lambdabot> Title: Applications and libraries/GUI libraries - HaskellWiki, http://tinyurl.com/yttdtd
02:48:11 <wolverian> right. that doesn't really compare them.
02:48:11 <dons> i though there was a table somewhere
02:48:15 <wolverian> ah.
02:48:28 <dons> oh, it does include the new high level ones
02:49:54 <wolverian> I just don't know how to evaluate these based on the descriptions alone
02:50:08 <vincenz> Cale: people have too much life
02:50:18 <vincenz> erm too much time, too little life
02:50:30 <Cale> hehe
02:50:50 <Cale> I wonder how long that took to make
02:50:52 <mgsloan> dons - hmm, when does Integer write out its size?
02:51:14 <mgsloan> it gets it, but doesn't write it
02:51:50 <mgsloan> nevermind
02:52:02 <mgsloan> how does it know how far to read, though?
02:52:54 <mgsloan> oh
02:53:05 <mgsloan> from list's size+content format
02:53:23 <dons> mgsloan: when it writes the list
02:53:23 <dons> yeah
02:53:57 <mgsloan> well, my proposal was to stick the length when <255 in the Word8 tag
02:54:09 <mgsloan> (the one that's currently either 0 or 1)
02:54:13 <dons> premature optimiations :-)
02:54:19 <mgsloan> but I suppose that might be a bit awkward codewise
02:54:20 <mgsloan> yeah
02:54:36 <dons> let s = gzip . encode $ Foo type
02:54:44 <mgsloan> heh
02:54:51 <dons> that's literally the code
02:55:05 <mgsloan> pretty sweet
02:55:17 <mgsloan> can gzip stream?
02:55:19 <dons> yeah
02:55:23 <mgsloan> awesome
02:55:28 <dons> both encode and gzip are streaming lazy bytestring transforms
02:55:30 <crazy_code3> What is a parse tree ?
02:55:33 <dons> so they run in O(1).
02:55:41 <dons> crazy_code3: the tree type constructed by a parser
02:56:04 <mgsloan> pretty soon haskell is going to be the lang of choice for fast opers on such stuff
02:56:07 <crazy_code3> dons: whats it use ? how do we create it /
02:56:09 <opqdonut> crazy_code3: 1+2*3 transforms into (+ (1 (* 2 3)))
02:56:14 <dons> data Program = [Decl]; data Decl = Bind String Expr ; data Expr = Literal | String | Apply Expr Expr
02:56:16 <opqdonut> for example
02:56:17 <dons> that kind of thiing
02:56:25 <mgsloan> yeah, lisp code is like a parse tree basically
02:56:38 <crazy_code3> + is the root node
02:56:42 <dons> mgsloan: that's what I hope for. we've got great optimisations, fast native code, high level. so should be good for fast streaming stuff
02:56:46 <opqdonut> crazy_code3: yep
02:57:40 <mgsloan> yeah, fusion and all that stuff.. pretty sweet
02:58:06 <dons> yeah, and the binary head branch uses rewrite rules to combine bounds checks, floating them out of loops
02:58:15 <dons> so you can write large nested structures without stopping
02:58:21 <dons> or branching
02:58:26 <dons> that's how you beat C :-)
02:58:27 <mgsloan> crazy
02:58:42 <vincenz> opqdonut: extra ( ?
02:58:51 <vincenz> opqdonut: (+ 1 (* 2 3))
02:59:51 <opqdonut> oh, true
03:02:37 <crazy_code3> if one were to parse the XML document , then there are tags, so how will the parse tree be like ?
03:02:51 <mgsloan> same structure
03:03:02 <crazy_code3> eg <? xml ........?> is a part of the tree or not ?
03:03:11 <mgsloan> i dunno, probably
03:04:13 <crazy_code3> I can't find anything on the net which specifies how it is to be constructed .
03:04:37 <mgsloan> that, is called parsing
03:05:14 <crazy_code3> mgsloan: you mean, the process of constructing the tree is called parsing ?
03:05:16 <mgsloan> there are numerous books, articles, techniques, frameworks, generators, etc for parsing
03:05:31 <mgsloan> well, the process of converting something like text to a tree, yes.
03:05:38 <crazy_code3> ok let me check for books
03:06:59 <crazy_code3> ok I just found a book
03:07:00 <crazy_code3> Thanks
03:07:04 <crazy_code3> will check it out
03:07:10 <mgsloan> welcome
03:07:23 <crazy_code3> I am a bit confused with whats a part of the tree and whats not
03:07:52 <crazy_code3> anyways, thanks :)
03:07:52 <mgsloan> pretty much everything the compiler needs to know is part of the tree
03:08:00 <mgsloan> so comments are usually left out
03:09:18 * mgsloan tries to use Dynamic to wrap (Get t) s :)
03:18:45 <quicksilver> opqdonut: slight variation, too
03:19:05 <quicksilver> opqdonut: rmorph, calls itself recurisvely on the output of the transform too
03:19:36 <notadev> variation on? quicksilver :)
03:20:24 <notadev> @src morph
03:20:24 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
03:20:32 <notadev> @src rmorph
03:20:32 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
03:20:38 <notadev> @src lmorph
03:20:38 <lambdabot> Source not found. You speak an infinite deal of nothing
03:20:42 <notadev> @bot
03:20:43 <lambdabot> :)
03:20:43 <quicksilver> notadev: some code I'm writing to futz with streams of tags
03:20:50 <notadev> ah ok sry
03:20:52 <quicksilver> notadev: http://paste.lisp.org/display/44032
03:21:05 <quicksilver> notadev: I think 'morph' is a generally useful combinator
03:21:09 <quicksilver> notadev: I'm not sure that's the best name
03:21:36 <notadev> heh only other ones i can think of are longer, so i'd stick with morph ;)
03:22:22 <notadev> morph :: ([a] -> Maybe (b,[a])) -> (b -> [a]) -> [a] -> [a] -- no wonder you knew about tuple passing ;)
03:22:33 <quicksilver> :)
03:22:36 <notadev> hehe
03:22:42 <quicksilver> that first parameter is really a 'parser'
03:22:50 <quicksilver> although in this context I call it a 'selector'
03:22:55 <quicksilver> (like CSS, cos that's what it is)
03:22:55 <notadev> why?
03:22:58 <notadev> ah ok
03:23:00 <notadev> lovely
03:23:08 <quicksilver> it takes a stream, and it either doesn't match (Nothin)
03:23:25 <quicksilver> or it just match, at it returns some representation of the matched bit, followed by the rest of the stream untouched
03:23:25 <notadev> morph sel trans l@(x:xs) = case sel l of Nothing      -> x : morph sel trans xs
03:23:45 <notadev>  Just (b,xs') -> trans b ++ morph sel trans xs'
03:24:21 <notadev> heh only 1 i was gonna say was trans as transform
03:25:03 <quicksilver> the 'trans' part turns that 'representation' back into the same type as the stream
03:25:09 <quicksilver> to punch it back into the stream
03:25:13 <notadev> ok
03:25:25 <quicksilver> so you can "pull out" the <b>...blah...</b> part
03:25:36 <notadev> oh extract elements?
03:25:39 <quicksilver> and then replace it with <span class="cssisbetter>...blah...</span>
03:25:43 <notadev> cool
03:25:50 <quicksilver> it's for fixing lousy markup
03:25:53 <notadev> heh
03:26:00 <notadev> nice
03:26:04 <quicksilver> (the kind you get when you save as.. html in popular word processors)
03:26:21 <notadev> meh
03:26:27 <notadev> waste of time ;)
03:27:13 <notadev> wrap s attrs ts = (TagOpen s attrs) : ts ++ [TagClose s] -- nice api :)
03:27:29 <ndm> quicksilver: i saw your code for morph, and the fixup - looks cool
03:27:33 <quicksilver> the Tag part is ndm's TagSoup library
03:27:47 <quicksilver> ndm: I have a more substantial example now
03:28:25 <ndm> quicksilver: morph is definitely not the right name, but if you can figure out what is, i'll happily add it i n
03:28:43 <notadev> balanceAtDepth is nice; is that making a tree?
03:28:53 <notadev> hmm
03:29:31 <quicksilver> ndm: http://paste.lisp.org/display/44032#1
03:29:38 <quicksilver> ndm: that's a "real" example
03:29:57 <quicksilver> ndm: I took a FAQ a colleague had saved-as HTML, and turned it into a proper semantic markup
03:30:03 <notadev> how would you do a self-referential data class? eg parent -> child; has link to parent
03:30:15 <ndm> quicksilver: neat :)
03:30:35 <ndm> quicksilver: any chance of picking another operator than </> - since that one is now in the standard libraries as filepath combining
03:31:15 <notadev> what about 'make' ?
03:31:22 <notadev> or is that compiler stuff?
03:31:39 <quicksilver> ndm: yeah, it's supposed to be mnemonic, in that it matches <foo> <foo/>
03:31:43 <int-e> notadev: Um, if you add backlinks (which is possible, but tricky), you either need to copy the whole structure on modifications or use a mutable data structure that you can only work on in ST or IO.
03:31:44 <quicksilver> ndm: but I'm not really fussed
03:32:03 <notadev> int-e: ah that could be a problem
03:32:06 <quicksilver> ndm: these aren't quite "fully polished" combinator suggestions
03:32:06 <int-e> notadev: so the first question is "why do you want to do that"?
03:32:24 <quicksilver> ndm: they're more "examples of cool stuff which might inspire useful combinators"
03:32:26 <notadev> heh it's a recursive data structure
03:32:27 <ndm> quicksilver: they look very promising though, like an HTML "grep" on steroids
03:32:36 <int-e> notadev: yes but why the backlinks?
03:32:37 <quicksilver> it's more like 'sed' than 'grep'
03:32:49 <notadev> for quick traversal
03:33:05 <quicksilver> ndm: it's vaguely inspired by jQuery
03:33:06 <ndm> they are both like TextPad to me :)
03:33:22 <quicksilver> ndm: well 'grep' only produces results, 'sed' lets you modify a stream
03:33:39 <quicksilver> ndm: the main point of morph + </> is to let you modify parts of a tag stream and keep the rest untouched
03:33:42 <int-e> notadev: you can create a stack for the traversal. or you can use a zipper (which provides a cursor-like interface)
03:33:52 <notadev> sed is much more powerful, but awk is nicer
03:34:12 <quicksilver> notadev: this is only an analogy :P
03:34:16 <opqdonut> awk and sed are for wholly different use cases usually
03:34:22 <opqdonut> wouldn't compare them
03:34:43 <notadev> int-e: ah ty; i'm used to doing stack backtrack, so the zipper sounds cool :) is that a Monad then?
03:35:14 <notadev> opqdonut: do you know how many people i've had to tell to use awk /instead/ of sed? ;)
03:35:16 <int-e> notadev: you'll probably feel cheated when you see it: http://haskell.org/haskellwiki/Zipper
03:35:17 <lambdabot> Title: Zipper - HaskellWiki
03:35:22 <notadev> heh
03:35:48 <int-e> notadev: because basically it encodes a path to a node in another data structure - it's like explicit stack management.
03:35:50 <opqdonut> notadev: not to say people don't abuse them :)
03:35:58 <mux> awk and sed are fairly similar, awk just resembles more a programming language than sed, and is usually easier to deal with
03:36:13 <notadev> opqdonut: hehe
03:36:18 <mux> I certainly wouldn't say they are wholly different use cases
03:36:34 <notadev> int-e: yeah i've seen that page before, it's exactly what i was after ty
03:36:41 <notadev> (lost bookmark)
03:36:54 <quicksilver> the most common use of sed is sed 's/foo/bar/;'  and that's the same as awk '{s/foo/bar/; print}' or something
03:37:17 <notadev> http://citeseer.ist.psu.edu/moggi89notions.html
03:37:18 <lambdabot> Title: Notions of Computation and Monads - Moggi (ResearchIndex)
03:37:41 <Cale> I've used sed to compose command lines to pipe to bash.
03:38:00 <quicksilver> I've used sed in backticks as part of a commandline, definitely
03:38:25 <mux> awk is also often used for fields splitting feature
03:38:37 <mux> awk '{print $X}'
03:38:38 <Cale> I mean for processing input and turning it into a shell script :)
03:38:40 <quicksilver> ndm: why don't you think 'morph' is a good name, and do you have any other suggestions?
03:38:53 <int-e> hmm. somehow when I feel the need to use awk I usually switch to perl ;)
03:39:07 <quicksilver> I use awk mostly for field-extraction
03:39:14 <Cale> me too
03:39:24 <notadev> yeah well, that's if you don't know what you're doing ofc, int-e ;P
03:39:27 <ndm> quicksilver: morph is very general, it could mean anything that changes something - and no, i don't have any better ideas - if no one can think of anything better i'll accept it though
03:39:37 <notadev> it builds html tho?
03:39:41 <mux> I use awk for that, only when cut(1) can't do the job, and when I don't need a more heavyweight perl script
03:39:50 <quicksilver> ndm: maybe I'll write up a haskell-cafe post later and solicit names :)
03:39:51 <notadev> or does it transform?
03:39:56 <quicksilver> notadev: it works on any stream
03:40:00 <ndm> quicksilver: cool :)
03:40:02 <quicksilver> morph :: ([a] -> Maybe (b,[a])) -> (b -> [a]) -> [a] -> [a]
03:40:11 <quicksilver> Cale: ^^ that type suggest any good name to you?
03:40:19 <notadev> cut is excellent (as are join paste and comm)
03:41:19 <malcolmw> HaXml's Xtract tool is more like an XML-grep
03:41:26 <int-e> notadev: I use awk for some very specific things, like adding a column of some file, maybe between some begin and some end marker. perl is for stuff that's more complex than that but doesn't justify being coded in a nice language. ;)
03:41:44 <quicksilver> malcolmw: there is also xmlstarlet
03:42:52 <quicksilver> malcolmw: the problem is, XML tools mostly expect well-formed documents, so I wrote this based off TagSoup to accept, well, soupy stuff :)
03:42:58 <notadev> int-e: yeah i know, but you can do an awful lot more with awk than people realise
03:43:26 <malcolmw> yeah, tagsoup is for MS-tool-produced HTML :-)
03:43:32 <quicksilver> ndm: I couldn't see a [Tag] -> String unparser, so I had to write 'pt'. Not that it was hard.
03:43:40 <quicksilver> malcolmw: which was exactly the use case I have here :)
03:44:21 <ndm> quicksilver: show :) - i intend to make show output HTML at some point
03:44:35 <ndm> malcolmw: but it works  perfectly for well-formed XML as well
03:44:44 <malcolmw> our dept runs a nightly validator on all webpage - but it excludes any page that claims to be written by a MS tool, since they throw up so many errors it swamps the validator
03:45:02 <ndm> it also reports warnings on every haddock generated page
03:45:05 <ndm> i get those every morning :)
03:45:18 <quicksilver> ndm: Nah, show is a debugging aid, I like that it shows me the structure.
03:45:38 <malcolmw> ndm: I fixed haddock once to give valid HTML - maybe it got broken again
03:46:14 <quicksilver> ndm: if you replace the show instance with one that produces HTML that breaks the 'unofficial show invariant'
03:46:39 <ndm> malcolmw: i have sent over some patches to haddock, i don't think the one that the Yhc builder picks up is finding the right haddock
03:46:40 <opqdonut> quicksilver: read . show ?
03:47:04 <Cale> quicksilver: could it also have type  ([a] -> Maybe (b,[a])) -> (b -> [c]) -> [a] -> [c]  ?
03:47:18 <quicksilver> opqdonut: no, it's stronger than that. "show x should produce something which can be copy-pasted into haskell code"
03:47:35 <quicksilver> Cale: no, because when the selector returns Nothing, the tokens in the stream are pass through unchanged
03:47:37 <opqdonut> Cale: you'd need an a->c function then too
03:47:41 <opqdonut> yeh
03:47:55 <Cale> (I don't actually have the code for it :)
03:47:57 <Cale> okay
03:48:05 <quicksilver> Cale: http://paste.lisp.org/display/44032
03:48:12 <quicksilver> Cale: but it was more fun just to ask you about the type :)
03:51:19 <Cale> hmm, that's interesting. I'm not sure that I could come up with a better name :)
03:54:34 <Cale> It's like parsing, but since the output type is the same, wherever there's a parse failure, it can just pass the input through.
03:54:55 <quicksilver> yes
03:55:01 <quicksilver> it has a parsing component
03:55:12 <quicksilver> and it transforms the parses back to the source type, too
03:55:19 <quicksilver> so it becomes a general stream transformer
03:55:35 <opqdonut> kinda like the same mentality as a preprocessor, right?
04:06:20 <notadev> i think morph is the best name so far tbh
04:08:05 <MyCatSchemes> dons: "Who needs Prolog? Implementing backtracking computations with monads" <-- gah!
04:08:53 <MyCatSchemes> dons: keep that up long enough and you might just manage to make almost every single other programming language on Earth totally uneccessary. With any luck.
04:09:29 <int-e> Well, that *is* the grand scheme of Haskell.
04:09:33 <mauke> backtracking with monads? sounds trivial
04:12:31 <MyCatSchemes> mauke: yars, but unification?
04:12:45 <notadev> MyCatSchemes: url please?
04:12:46 <ricky_clarkson> Isn't there a problem with that in that you cannot statically type everything.
04:12:48 <mauke> yeah, ok
04:12:48 <Codex_> Resolution!
04:13:04 <MyCatSchemes> notadev: front page of http://programming.reddit.com/
04:13:05 <lambdabot> Title: reddit.com: programming - what&#39;s new online
04:13:08 <notadev> ty
04:13:19 <MyCatSchemes> notadev: wilkommen.
04:13:39 <notadev> vielen Dank :-)
04:14:11 <MyCatSchemes> ? Was that Dutch or something?
04:14:39 <mauke> oh crap. an oleg/chung-chieh shan paper
04:15:11 <ricky_clarkson> Dutch is like aolspeak, U means 'you'.
04:15:30 <notadev> no that was Deutsch MyCatSchemes
04:16:25 <MyCatSchemes> notadev: ah, well. I'd probably find it easier if I knew more than five words of German. (Hello, goodbye, please, thanks and welcome.)
04:16:45 <mauke> that wasn't German!
04:16:48 <notadev> vielleicht, ja ;)
04:17:11 <MyCatSchemes> notadev: once again, I am quite thoroughly lost. ^^
04:17:29 <mauke> vielleicht = maybe; ja = yes
04:17:51 <mauke> vielen Dank = thanks a lot
04:17:58 <notadev> genau!
04:18:05 <mauke> genau = exactly
04:18:07 <triplah_> ruhig!
04:18:11 <notadev> lol
04:18:14 <mauke> ruhig = quiet
04:18:20 <notadev> wtf, is mauke a bot?
04:18:21 <MyCatSchemes> Oh. I never bothered to learn ayn term for that save "dankesch√∂n."
04:18:27 <notadev> yeuch
04:18:35 <MyCatSchemes> notadev: no, he's just wired unto Hell on strong coffee.
04:19:10 <notadev> ah ok
04:19:53 <eivuokko> Should GHC configure understand PATH with spaces in it?
04:20:05 <ricky_clarkson> Any of you fellas tried Liskell out?  Any opinions?
04:20:31 <MyCatSchemes> ricky_clarkson: I haven't tried it, but it sounds totally and utterly insane to me.
04:21:04 <MyCatSchemes> On the gripping appendage, that might be a point in its favour.
04:21:39 <ndm> is there any way to make a local kind annotation?
04:21:43 <ndm> i.e. x :: # ?
04:21:55 <dons> ndm, yeah, -fglasgow-exts should allow that (well, not sure about # kind though)
04:22:13 <ndm> dons: i can't get it working with # - works for other things though
04:22:40 <dons> you'd have to constrain it to a particular # type anyway no ?
04:23:09 <dons> we don't have # kinded tyvars -- bit hard to treat them uniformly :-)
04:23:55 <ndm> hmm, i don't have the faintest idea :)
04:24:02 <ndm> i liked Haskell when we still had type inference
04:24:31 <dons> there's no polymorphism of # kind, since you can't produce a function that treats values of kind # uniformly -- without boxing them
04:24:54 <ricky_clarkson> > \x -> x
04:24:54 <lambdabot>  Add a type signature
04:24:58 <ricky_clarkson> Why?
04:25:06 <dons> what's it evaluate to?
04:25:07 <ricky_clarkson> I thought it'd be a -> a
04:25:12 <dons> > \x -> x :: Int -> Int
04:25:13 <lambdabot>  <(Int -> Int) -> Int -> Int>
04:25:28 <dons> it just can't find a show instance for functions of polymorphic type
04:25:33 <dons> which is lambdabot's fault :-)
04:25:35 <dons> :t \x -> x
04:25:38 <lambdabot> forall t. t -> t
04:25:43 <ricky_clarkson> Ahh.
04:25:48 <dons> > ord -- show this function
04:25:49 <lambdabot>  <Char -> Int>
04:26:02 <dons> > show ord
04:26:04 <lambdabot>  "<Char -> Int>"
04:26:08 <ndm> dons: i got the type signature in place, with a more specific type of #, thanks
04:26:15 <mauke> > join id show
04:26:15 <dons> cool
04:26:16 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -> a1
04:26:16 <lambdabot>     Probab...
04:26:40 <ricky_clarkson> > \f x -> f f x
04:26:41 <lambdabot>      Occurs check: cannot construct the infinite type: t = t -> t2 -> t1
04:26:41 <lambdabot>     ...
04:26:51 <ricky_clarkson> Is there a way of getting around that?
04:27:02 <dons> with an intermediate newtype
04:27:19 <dons> but there's not a lot of program that usefully use that, so you don't see it terribly often :-)
04:27:22 <dons> better to use 'fix'
04:27:25 <dons> :t fix
04:27:27 <lambdabot> forall a. (a -> a) -> a
04:27:28 <dons> ?src fix
04:27:28 <lambdabot> fix f = let x = f x in x
04:27:39 <ricky_clarkson> Sure, but it's in the lambda calculus theory, so I expected to be able to use it.
04:27:50 <dons> not typed lambda calculus
04:27:54 <ricky_clarkson> E.g., to make a recursive factorial without providing a named function.
04:28:04 <dons> you need the Y combinator
04:28:11 <ricky_clarkson> Ok.
04:28:20 <dons> > fix (1:)
04:28:22 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
04:28:27 <mauke> > fix (\f n -> if n < 2 then 1 else n * f (n - 1)) 5
04:28:28 <lambdabot>  120
04:28:43 <dons> mauke wins
04:28:51 <mauke> FATALITY
04:29:10 * ricky_clarkson watches his lambda come out through his parens.
04:30:00 <mauke> @src ($!)
04:30:00 <lambdabot> Source not found. Just what do you think you're doing Dave?
04:30:04 <ricky_clarkson> I'm struggling to see how that works - I'll look at some docs in a while.
04:30:23 <dons> ?src fix
04:30:23 <lambdabot> fix f = let x = f x in x
04:30:30 <mauke> fix takes a function and calls it with its own result
04:30:32 <dons> just inline the argument to fix a couple of times
04:31:01 <ricky_clarkson> What type is f in that?
04:31:13 <mauke> a -> a
04:31:26 <mauke> or do you mean my factorial function?
04:31:31 <ricky_clarkson> Yes.
04:31:39 <ricky_clarkson> Integer -> Integer, I suppose.
04:31:42 <mauke> yeah
04:31:59 <ricky_clarkson> Does fix implement the Y combinator then?
04:32:00 <mauke> :t (\f n -> if n < 2 then 1 else n * f (n - 1))
04:32:03 <lambdabot> forall a. (Ord a, Num a) => (a -> a) -> a -> a
04:32:08 <mauke> :t fix (\f n -> if n < 2 then 1 else n * f (n - 1))
04:32:10 <lambdabot> forall a. (Ord a, Num a) => a -> a
04:32:46 <mauke> the lambda function is essentially (Integer -> Integer) -> (Integer -> Integer)
04:33:03 <mauke> fix turns it into just Integer -> Integer
04:34:14 <quicksilver> ricky_clarkson: fix is a type-safe thing with similar effects to Y
04:34:22 <quicksilver> ricky_clarkson: it's not "Exactly" Y
04:34:30 <quicksilver> it's related
04:34:56 <mauke> > fix show
04:34:58 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
04:37:18 <ricky_clarkson> It calls show with the result of calling show, ad infinitum.
04:37:25 <ricky_clarkson> Does that only work because of laziness?
04:37:50 <quicksilver> yes
04:37:55 <quicksilver> well
04:38:00 * ricky_clarkson stops writing a Lisp version now.
04:38:04 <quicksilver> that particular example only works because of laziness
04:38:14 <quicksilver> (since it produces an infinite result)
04:38:23 <quicksilver> the factorial example is fine in a strict language
04:38:24 <ricky_clarkson> Ok, go back to the factorial.
04:38:56 <quicksilver> looking from a language-theoretic perspective, fix is just 'encapsulating' letrec
04:39:02 <quicksilver> if you have fix, you don't need letrec
04:39:03 <MyCatSchemes> > fix (+1)
04:39:04 <lambdabot>  Exception: <<loop>>
04:39:07 <mauke> sub fix (&) { my $f = shift; sub { $f->(&fix($f), @_) } }
04:39:08 <quicksilver> if you have letrec, then fix is trivial
04:39:15 <MyCatSchemes> > fix (1:)
04:39:17 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
04:40:37 <ricky_clarkson> mauke: That looks like an infinite type to me.
04:40:44 <ricky_clarkson> The same as my \f x -> f f x
04:41:01 <MyCatSchemes> > let x = 1 : 1 : (fix (\x->((head $ x) + (head $ tail $ x)) : x)
04:41:01 <lambdabot>  Parse error
04:41:03 <mauke> (defun fix (f) (lambda (&rest xs) (apply f (fix f) xs)))
04:41:10 <mauke> I think
04:41:36 <quicksilver> I think you want ((fix f) xs)
04:41:40 <quicksilver> but I'm hopeless at lisp :)
04:42:22 <mauke> :t let fiz f = \x -> f (fiz f) x in fiz
04:42:24 <lambdabot> forall t t1. ((t -> t1) -> t -> t1) -> t -> t1
04:45:14 <takamura> hi
04:45:26 <ricky_clarkson> That implementation seems to fail.
04:45:48 <mauke> > let fiz f = \x -> f (fiz f) x in fiz show
04:45:49 <lambdabot>  Couldn't match expected type `t -> t1'
04:45:59 <mauke> hmm, yes
04:46:11 <mauke> > let fiz f = f (fiz f) in fiz show
04:46:12 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
04:46:25 <ricky_clarkson> (fix (lambda (f x) (if (< x 2) x (* x (funcall f (1- x))))) 5) gives me 5.
04:46:45 <notadev> wtf is all that about?
04:46:53 <ricky_clarkson> Fixed-point combinators.
04:46:58 <notadev> oh ok
04:47:08 <mauke> ricky_clarkson: sec
04:49:59 <mauke> [5]> (fix (lambda (f x) (if (< x 2) 1 (* x (funcall f (1- x))))) 5)
04:49:59 <mauke> *** - EVAL/APPLY: too many arguments given to FIX
04:50:26 <mauke> [7]> (funcall (fix (lambda (f x) (if (< x 2) 1 (* x (funcall f (1- x)))))) 5)
04:50:30 <mauke> 120
04:50:46 <mauke> of course, this looks a lot less ugly in perl
04:51:22 <mauke> my $fac = fix { my ($f, $x) = @_; $x < 2 ? 1 : $x * $f->($x - 1) };
04:51:25 <mauke> $fac->(5)
04:51:36 <hpaste>  (anonymous) pasted "searching for a function like this one" at http://hpaste.org/1568
04:52:03 <ricky_clarkson> I got it while I was looking away.
04:53:12 <ricky_clarkson> Ok, looking at Lisp I understand how it works, but I don't understand how it's type-checked in Haskell.
04:54:49 <dcoutts> dons: LZF eh?
04:55:19 * vincenz kicks his conncetion
04:55:36 <dcoutts> dons: oh, neat, bundling the C source. I wonder if I could do that for zlib, especially on windows.
04:56:36 <dcoutts> ah, I see, you're just pushing it onto hackage, Einar Karttunen is original author
04:56:41 <DRMacIver> ?type map2 (,)
04:56:45 <dcoutts> dons: good that it's getting more attention
04:56:46 <DRMacIver> @type map2 (,)
04:56:50 <lambdabot> Not in scope: `map2'
04:56:52 <lambdabot> Not in scope: `map2'
04:56:57 <DRMacIver> Oops
04:57:06 <mauke> @type zipWith (,)
04:57:09 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
04:57:18 <DRMacIver> @type liftM2 (,)
04:57:20 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
04:58:44 <tuxplorer> What shd i do to get rid of the foll error when i try to execute a HAppS
04:58:44 <tuxplorer> Could not find module `HAppS'
04:59:14 <Lemmih> tuxplorer: Try installing HAppS.
04:59:32 <takamura> I have a question. There is a function like http://hpaste.org/1568 in the hierarchical libraries? or can it be obtained from functions of the libraries?
05:00:22 <mauke> :t mapM
05:00:24 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
05:01:18 <roconnor> > sin 1
05:01:20 <lambdabot>  0.8414709848078965
05:01:26 <roconnor> > sin 0.5
05:01:29 <lambdabot>  0.479425538604203
05:05:54 <tuxplorer> Lemmih: I tried now.. Got this error
05:05:55 <tuxplorer> *** Exception: Line 7: Parse of field 'build-depends' failed
05:07:07 <Lemmih> tuxplorer: What version of GHC are you using?
05:07:21 <Lemmih> tuxplorer: You might find SearchPath to be easier.
05:08:06 <tuxplorer> ghc 6.4
05:08:27 <tuxplorer> Lemmih: What is SearchPath?
05:09:01 <Lemmih> http://searchpath.org/
05:09:02 <lambdabot> Title: SearchPath
05:09:08 <Lemmih> tuxplorer: Upgrade to 6.6
05:09:22 <tuxplorer> Lemmih: okay.. 6.6 is nightly build is it?
05:09:22 <dons> dcoutts: yeah, just thought i'd upload musasabi's stuff
05:09:36 <Lemmih> tuxplorer: Nope, 6.6 is the latest stable release.
05:09:41 <dcoutts> dons: you didn't change the code to make it use ByteString :-)
05:10:06 <dcoutts> dons: actually, I wonder about the .h file listed in the .cabal file, does it get installed properly?
05:10:07 <dons> nope :)
05:10:19 <dons> hmm, seemed to work in my tests
05:10:33 <tuxplorer> Lemmih: okay
05:10:38 <dons> i only checked the test files though
05:11:24 <dons> > filterM (const [True, False]) [1..3]
05:11:28 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
05:12:08 <tuxplorer> Lemmih: I'm using freebsd 4.1.. and i dont have ghc 6.6 in my repo
05:12:28 <tuxplorer> is HApps not supported for 6.4? The homepage says it is..
05:14:04 <Lemmih> tuxplorer: Try building your app with searchpath.
05:14:05 <ttmrichter> So when will GHC be cabalized?
05:14:08 * ttmrichter whistles innocently.
05:14:32 <tuxplorer> Lemmih: Is searchpath just similar to runhaskell?
05:14:46 <Lemmih> tuxplorer: Not really.
05:15:00 <Lemmih> Searchpath does automatic import chasing across the Internet for Haskell modules.
05:15:08 <tuxplorer> Lemmih: cool
05:15:31 <roconnor> @type filterM
05:15:36 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
05:16:41 <roconnor> > filterM (const [minBound..maxBound]) [1..3]
05:16:49 <lambdabot>  [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
05:25:01 <quicksilver> roconnor: cute
05:36:38 <tuxplorer> Lemmih: I get the foll error when attempting to install SearchPathhttp://pastebin.ca/605765
05:37:47 <moonlite> tuxplorer: my guess is that you need gmp
05:39:00 <DRMacIver> Hm. Why doesn't (,) have sections?
05:39:03 <DRMacIver> @type (,1)
05:39:11 <lambdabot> parse error on input `1'
05:39:51 <malcolmw> DRMacIver: because spare commas are more likely to be a typo than a deliberate tuple section
05:40:44 <DRMacIver> I hear there's something called a 'type system' which helps catch errors like that. :)
05:41:21 <opqdonut> yeah, sounds like a stupid excuse
05:41:38 <opqdonut> well you can just use ((,) 1) or (flip (,) 1)
05:41:44 <opqdonut> > (flip (,) 1) 2
05:41:46 <lambdabot>  (2,1)
05:44:09 <quicksilver> yes, it's annoying
05:44:16 <quicksilver> join the ", for sections" club
05:44:36 <opqdonut> join the, club
05:45:06 <quicksilver> ("join the",) "club"
05:45:18 <DRMacIver> opqdonut: I ended up writing a lambda instead. I decided it would be more readable. :)
05:45:33 <opqdonut> yeah, most probably
05:45:59 <quicksilver> readablity is overrated
05:46:05 <quicksilver> terseness is where it's at!
05:46:39 <takamura> :t maybe
05:46:41 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
05:46:43 <opqdonut> could somebody please explain the . (.) . construct please?
05:46:52 <opqdonut> i bump into it constantly with ?pl
05:46:59 <DRMacIver> quicksilver: Terseness (tersity?) is great. It helps readability. :)
05:47:32 <DRMacIver> quicksilver: But flip (,) x isn't exactly much shorter than \z -> (z, x)
05:48:34 <ricky_clarkson> If you alter the grammar you can say terse great. help read.
05:48:44 <DRMacIver> @pl \(x, y) -> (y, x)
05:48:44 <lambdabot> uncurry (flip (,))
05:48:50 <ricky_clarkson> Clearly more readable.
05:49:25 <opqdonut> haha uncurry :D
05:50:47 <quicksilver> DRMacIver: no, but (,x) is much shorter
05:51:03 <quicksilver> DRMacIver: I really don't like flip very much at all
05:51:07 <quicksilver> DRMacIver: but I do like sections :)
05:51:24 <quicksilver> DRMacIver: I often prefer an explicit abstraction to a flip
05:52:36 <DRMacIver> quicksilver: Yes. (,x) is clearly better than both. :)
05:52:45 <DRMacIver> quicksilver: But it doesn't work, does it? ;)
05:54:12 <quicksilver> DRMacIver: no *sob*
06:08:50 <ndm> hmm, the kinds suck
06:08:59 <ndm> hmm, the kinds suck, specially the # kind
06:09:11 <ndm> type inference go bye-bye, and replaced with pain :(
06:10:21 <malcolmw> ndm: you just do kind inference prior to type inference, that's all
06:10:36 <ndm> malcolmw: but you can't always infer the right kind
06:10:51 <ndm> malcolmw: kind inference is local, say something like >>= returns a
06:11:12 <ndm> # kind, but if you let it be inferred it ends up at * and doesn't work at type checking time
06:11:44 <malcolmw> * is supposed to include #, as in, it is less specific in the lattice of kinds
06:12:12 <Igloo> That's not true if you're talking about GHC's kinds, is it?
06:12:35 <malcolmw> maybe I don't know what ghc does
06:12:52 <Igloo> Does [yn]hc also have * and # kinds, then?
06:12:59 <ndm> woohoo, it appears that you can't write an explicit type cast, but if you box it in a newtype then you can get round it :)
06:13:02 <ndm> Igloo: no
06:13:04 <malcolmw> or perhaps I'm thinking of kind variables
06:16:26 <ndm> @hpaste
06:16:28 <lambdabot> Haskell pastebin: http://hpaste.org/new
06:16:34 <SamB> malcolmw: perhaps you should look for the tree diagram?
06:17:30 <hpaste>  ndm pasted "different kinds of pain" at http://hpaste.org/1569
06:17:54 <ndm> so, how do you get the bindIO function to infer that it returns a # kind, not a * kind?
06:18:04 <ndm> i've done it at the moment with refoo, but thats not acceptable in general
06:18:40 <Igloo> Give it a kind-sig?
06:19:50 <ndm> not acceptable either, since i want to automatically optimise the code after
06:20:15 <ndm> i can give the realWorld# bit a signature, since i don't want to optimise inside that, but i need to be free to go inside the rest of the things
06:20:33 * Igloo can't load the hpaste page for some reason
06:20:40 * ndm can't either
06:20:47 <ndm> @google lisp paste bot
06:21:11 <Igloo> galeon tells me "0% complete, 4kB of 4kB loaded"
06:21:38 <ndm> http://paste.lisp.org/display/44043
06:21:49 <ndm> @karma- hpaste
06:22:13 <ndm> glguy: hpaste seems pretty dead...
06:24:19 <Wild_Cat> did hpaste's spam problems get solved?
06:24:51 <SamB_XP> yes! nobody bothers to spam it when it's on the fritz ;-P
06:25:01 <Botje> "Get an eraser: toothpaste does not work" -- Fine advice from SPJ.
06:25:33 <SamB_XP> @quote toothpaste
06:25:45 <SamB_XP> oh, lambdabot too...
06:26:44 <kpreid> hey, folks, want lisppaste back in the channel? :-) :-)
06:27:18 <greenrd> eivuokko: There was a patch in ghc head recently to handle spaces in variables like CFLAGS
06:27:47 * SamB_XP only wants sections of (,) -- not (,,) and so on...
06:28:20 <eivuokko> greenrd, Well, my problem was that configure couldn't find happy because it was in a path with space on it.
06:28:34 <eivuokko> Well, rather, it found it but didn't run it correctly.
06:28:44 <SamB_XP> well why the heck was that the case?
06:28:48 <DRMacIver> SamB_XP: Sections of those would be nice too.
06:29:08 <SamB_XP> DRMacIver: I don't want to encourage people to use them though
06:29:41 <ndm> kpreid: yes please :)
06:29:44 <DRMacIver> Whine whine. ;)
06:30:25 <DRMacIver> Large tuples have their uses.
06:30:28 <DRMacIver> They also have their abuses.
06:30:37 <DRMacIver> The latter should not be used as an excuse to cripple the former.
06:31:37 <SamB_XP> they lack fst and snd, so I like them not
06:35:11 <lambdabot> http://paste.lisp.org/new/squeak
06:35:12 <lambdabot> hpaste's karma lowered to 2.
06:35:12 <lambdabot> No quotes match. Do you think like you type?
06:35:55 <SamB_XP> @vixen hi
06:35:56 <lambdabot> hiya
06:36:00 <SamB_XP> w00t
06:36:10 <SamB_XP> dons++
06:36:27 <SamB_XP> @vixen do I like functional programming?
06:36:28 <lambdabot> what's a program?
06:37:08 <fasta> I run my program, but I get some infinite loop. A profile doesn't give me a sensible hint either. Anything else that I can do?
06:37:10 <MyCatSchemes> Lambdabot is having an existential crisis!?
06:37:18 <kpreid> ndm: I'll assume that's a "never mind"
06:37:31 <MyCatSchemes> lambdabot: a program is you.
06:37:39 <SamB_XP> okay... why is www.boundvariable.org not resolving...
06:37:46 <fasta> It uses 99.2% CPU when it is in this infinite loop
06:38:03 <MyCatSchemes> SamB: someone unbound their DNS server's variables.
06:38:09 <fasta> If I lower the amount of memory that it can use and then crashes, do I get a stack trace?
06:38:30 <MyCatSchemes> fasta: run bits and pieces of your code through the REPL with various bottom and non-bottom inputs, perhaps?
06:38:45 <DRMacIver> SamB_XP: That's just a problem with the way fst and snd are currently set up though.
06:38:45 <MyCatSchemes> fasta: this being one of the advantages of bottom-up programming. :/
06:38:55 <DRMacIver> SamB_XP: Generic tuple access functions are sadly lacking. :(
06:39:19 <fasta> MyCatSchemes: it's rather difficult to do this in my case.
06:39:32 <MyCatSchemes> fasta: tarnation.
06:39:32 <SamB_XP> DRMacIver: I'd also want thd and frt and fft and sxd
06:39:38 <SamB_XP> er. something like that
06:39:52 <fasta> MyCatSchemes: tarnation?
06:40:00 <Syzygy-> DRMacIver: Poke!
06:40:15 <Wild_Cat> tarnation? That'd be a nice name for a grunge band.
06:40:18 <fasta> MyCatSchemes: when you use ST it's more difficult to do that.
06:40:42 * fasta votes to kill the ST interface as a whole, but that's a different subject
06:40:59 <MyCatSchemes> fasta: ohhh. But ain't it, uh, really really _really_ useful?
06:41:05 <fasta> (yes, you can still write efficient code then)
06:41:14 <fasta> MyCatSchemes: no, and SPJ knows this.
06:41:22 <MyCatSchemes> SPJ?
06:41:26 <fasta> MyCatSchemes: I was surprised he did, but he does.
06:41:34 <Syzygy-> Simon P*mumblemumble*-Jones
06:41:48 <opqdonut> Peyton isn't it?
06:41:50 <dozer> slashdot just pointed me at JSR 275, that gloms unitful arithmetic onto the side of Java
06:41:50 <Syzygy-> One of the reverent Simons high up among the Haskell dieties.
06:41:52 <fasta> Yes
06:41:58 <Syzygy-> opqdonut: Right. That's what I said, wasn't it?
06:42:07 <opqdonut> ah, sorry missed that ;)
06:42:07 <dozer> it looks quite a bit nicer than the haskell solutions I've been able to track down though
06:42:07 <Syzygy-> ;)
06:42:45 <DRMacIver> SamB_XP: I have a cunning plan actually.
06:43:05 <DRMacIver> (To provide generic tuple access and update functions in a nice way)
06:43:31 <dolio> Just bug people on the GHC mailing list until someone implements row polymorphism + extensible records/variants. :)
06:43:31 <erider> morning all
06:43:34 * int-e likes ST
06:43:59 <dolio> Then you get nice tuple accesors for free.
06:44:01 <fasta> int-e: but ST doesn't have value semantics!
06:44:27 <fasta> int-e: which is completely unlike functional programming
06:44:55 <int-e> that's the point, isn't it?
06:45:00 <fasta> int-e: no
06:45:16 <fasta> int-e: it's an easy solution for a problem that can be solved in the correct way
06:45:36 <DRMacIver> dolio: I think I can make this work with standard Haskell tuples. :)
06:45:37 <dnox> anyone here using hs-plugins in win?
06:45:44 <fasta> int-e: algorithms that need references can be implemented on top of DiffArray.
06:45:55 <DRMacIver> (At least up to any finite limit of tuple size)
06:45:57 <int-e> fasta: well, yuck.
06:46:00 <dolio> DRMacIver: A bunch of classes?
06:46:14 <int-e> fasta: sorry, I'll take the performance hack over diff arrays any time
06:46:27 <fasta> int-e: How do you mean?
06:46:35 <int-e> Diffarrays are *slow*
06:46:40 <fasta> int-e: yes, I know that.
06:46:45 <fasta> int-e: that's besides the point.
06:46:52 <int-e> no it's not. speed matters.
06:47:14 <fasta> int-e: diffarray can surely be optimized for single threaded use.
06:47:39 <fasta> int-e: ST is a local maximum.
06:47:44 <crazy_code2> hello everyone
06:47:47 <crazy_code2> One problem
06:47:50 <crazy_code2> (+*) :: Int->Int->Int
06:47:54 <fasta> int-e: I agree that if you want fast code _today_ you should use ST>
06:47:59 <SamB_XP> fasta: we'd need to speed up MVar
06:48:07 <crazy_code2> (+*) x y= 2*(x+y)
06:48:17 <SamB_XP> for thread-local access
06:48:26 <crazy_code2> Now here (+*) is an infix operator
06:48:39 <crazy_code2> How to use `+*`  ??
06:48:45 <crazy_code2> It gives an error
06:48:49 <crazy_code2> It should work
06:48:53 <opqdonut> huh, `+*` means nothing
06:48:58 <dolio> a +* b
06:49:01 <opqdonut> `` makes an operator out of a normal function
06:49:06 <opqdonut> yes, just a +* b
06:49:07 <SamB_XP> > let (+*) x y= 2*(x+y) in 1 +* 2
06:49:10 <lambdabot>  6
06:49:11 <DRMacIver> dolio: Basically, yes.
06:49:15 <opqdonut> > let (+*) x y= 2*(x+y) in 1 +* 3
06:49:17 <lambdabot>  8
06:49:19 <opqdonut> bah, beat me to it
06:49:25 <crazy_code2> Ok
06:49:31 <DRMacIver> dolio: Plus some vague cleverness for updates.
06:49:35 <SamB_XP> @quote stereo
06:49:35 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
06:49:43 <opqdonut> yup
06:49:49 <crazy_code2> So how to convert a normal function into an infix operator ?
06:49:56 * SamB_XP thinks that's close enough to stereo, since we differed in one character ;-)
06:50:06 <opqdonut> > let f x y= 2*(x+y) in 1 `f` 3
06:50:10 <fasta> int-e: well, I wouldn't be surprised if ST would be eliminated in 10 years.
06:50:29 <SamB_XP> fasta: I was hoping they'd fix it instead
06:50:37 <crazy_code2> opqdonut: So just by using `  ` , we can convert any given function to an infix operator ?
06:50:41 <fasta> SamB_XP: fix it?
06:50:48 <fasta> SamB_XP: in what way is it broken?
06:50:51 <crazy_code2> opqdonut: No new definition required ?
06:50:51 <opqdonut> crazy_code2: yep
06:50:55 <SamB_XP> the types are annoying
06:51:09 <int-e> fasta: maybe. but today it's a good solution to a real problem, namely using mutable data structures for constructing results in pure functions. It's inherently single-threaded and imperative but that's ok for me.
06:51:17 <opqdonut> crazy_code2: nope, except for infixl/infixr if you care about associativity
06:51:19 <fasta> SamB_XP: you mean the occasional selection of the right array type?
06:51:29 <fasta> SamB_XP: I don't think the types are annoying.
06:51:30 <crazy_code2> opqdonut: Ok
06:51:34 <crazy_code2> Thanks
06:51:40 <lambdabot>  8
06:51:55 <vincenz> Woo
06:51:59 <vincenz> I found an easter egg in redidt
06:52:01 <vincenz> reddit
06:52:02 <opqdonut> haha lambdabot lags
06:52:21 <fasta> What I find annoying however is that I cannot find why it's looping...
06:52:23 <Botje> @quote toothpaste
06:52:30 <lambdabot> No quotes match. This mission is too important for me to allow you to jeopardize it.
06:53:20 <fasta> vincenz: being?
06:53:34 <vincenz> fasta: You can get a bigger font
06:53:35 <SamB_XP> @hoogle newArray
06:53:35 <vincenz> in comments
06:53:36 <lambdabot> Data.Array.MArray.newArray :: (MArray a e m, Ix i) => (i, i) -> e -> m (a i e)
06:53:36 <lambdabot> Data.Array.MArray.newArray :: (MArray a e m, Ix i) => (i, i) -> e -> m (a i e)
06:53:36 <lambdabot> Foreign.Marshal.Array.newArray :: Storable a => [a] -> IO (Ptr a)
06:53:37 <dolio> DRMacIver: update might be a littler harder...
06:54:05 <fasta> vincenz: Uhm, all browsers support that.
06:54:11 <SamB_XP> > runSTUArray (newArray (0,1) 2)
06:54:14 <lambdabot>   Not in scope: `newArray'
06:54:15 <dolio> DRMacIver: Unless you're not interested in changing the type of the field.
06:54:17 <SamB_XP> aww.
06:54:25 <fasta> ST is not in lambdabot
06:54:25 <vincenz> fasta: what? No you can make your comment have a bigger font
06:54:37 <vincenz> ... than the rest
06:54:39 <fasta> vincenz: ok
06:54:41 <dolio> :t first
06:54:45 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
06:54:49 <fasta> vincenz: and how does that work?
06:55:01 <fasta> vincenz: I don't even have an account on reddit, luckily.
06:55:44 <vincenz> http://programming.reddit.com/info/23udh/comments/c241d8
06:55:45 <lambdabot> Title: Programming Tip of the Day (reddit.com)
06:56:12 <DRMacIver> dolio: Hm, yes, good point. I'd been working on the assumption it didn't change the type of the field.
06:57:03 <fasta> vincenz: I think I have seen it before
07:00:38 <roconnor> Strictly speaking, am I allowed to write (Monad.filterM) or must I import Monad first?
07:01:37 <Botje> you only have to give the name if you're disambiguating
07:01:38 <int-e> roconnor: you have to import it first, without 'as <something else>'
07:02:11 <Baughn> roconnor: Being able to do it without an import is a special feature of ghci
07:02:14 <Botje> roconnor: import Control.Monad; then use it
07:02:27 * SamB_XP wonders if the only reason that he can see the picture of the cultist on boundvariable.org (using google's cached version of the page) is that it was still cached from some earlier visit
07:02:44 <int-e> roconnor: i.e. if you import Monad as M, Monad.filterM *still* won't be valid.
07:03:03 <int-e> (but M.filterM will be)
07:03:07 <Baughn> SamB_XP: Shouldn't think so. The site is up.
07:03:18 <SamB_XP> Baughn: oh.
07:03:40 <roconnor> okay
07:03:52 <roconnor> is there a shorter way to write [False,True]?
07:03:59 <Baughn> > [False..]
07:04:36 <Baughn> [False ..], actually, but I'm not sure it's a good idea
07:04:50 <Botje> roconnor: go for clarity first, then brevity :p
07:05:04 <SamB_XP> what, you want enumAll :: (Bounded a, Enum a) => [a]?
07:05:25 <Syzygy-> > (enumAll :: [Bool])
07:05:28 <SamB_XP> @let enumAll = [minBound ..]
07:05:33 <Syzygy-> Ah.
07:05:34 <roconnor> Botje: I'm trying to write the shortest powerset function in Haskell.
07:05:36 <SamB_XP> Syzygy-: I just made it *up*
07:05:36 <Syzygy-> > (enumAll :: [Bool])
07:05:41 <Baughn> > 2 + 2
07:05:43 <Syzygy-> > (L.enumAll :: [Bool])
07:05:47 <roconnor> I'm trying to see if this nifty filterM aproach works well
07:05:48 <SamB_XP> wait a moment or three
07:05:49 <Syzygy-> SamB_XP: Really?
07:05:52 <Syzygy-> Awwwww.
07:05:58 <roconnor> but the "import Monad" takes a lot of characters
07:06:00 <Baughn> Bot's dead?
07:06:02 <SamB_XP> Syzygy-: that doesn't mean you can't have it ;-)
07:06:15 <Botje> roconnor: filterM (const [True, False]) -- is the shortest I can think of
07:06:19 <Syzygy-> Hah!
07:06:34 <roconnor> Botje: you need to count the import.
07:06:38 <Syzygy-> Botje: How is that shorter than [False, True] ?
07:07:00 <roconnor> and it would be filterM(\_->[False ..])
07:08:08 <DRMacIver> Syzygy-: I think that was intended as a powerset implementation. :)
07:08:10 <Syzygy-> [f..] where f=False
07:08:21 <Syzygy-> DRMacIver: Ah.
07:08:30 <int-e> > map odd[0,1]
07:08:31 <Baughn> > filterM (const [1..5])
07:08:31 <roconnor> > length "import Monad\np=filterM(\_->[False ..])"
07:08:31 <Baughnie>  Illegal escape sequence
07:08:33 <Baughnie>   add an instance declaration for (Num Bool)
07:08:33 <Baughnie>     In the expression: 5
07:08:33 <Baughnie>  [False,True]
07:08:57 <SamB_XP> hmm, my dns server must have had issues
07:09:30 <roconnor> int-e: nice idea, but [False ..] is still shorter.
07:10:01 <roconnor> "import Monad\np=filterM(\\_->[False ..])" is 38 characters
07:10:14 <Syzygy-> > length "[False ..]"
07:10:15 <Baughnie>  10
07:10:16 <roconnor> "p(h:t)=p t++[h:x|x<-p t];p x=[x]" is 32 characters
07:10:22 <Syzygy-> Wait a minute...
07:10:29 <Syzygy-> When did lambda end up being named Baughnie ?
07:10:31 <Botje> > [..True]
07:10:32 <Baughnie>  Parse error
07:10:34 <Botje> boo :)
07:10:37 <Baughn> @bor
07:10:38 <Baughnie> Maybe you meant: arr bf bug more yow
07:10:39 <Baughn> @bot
07:10:39 <Baughnie> :)
07:10:45 <Syzygy-> @botsnack
07:10:45 <Baughn> Syzygy-: When lambdabot stopped responding.
07:10:46 <Baughnie> :)
07:10:50 <Syzygy-> Baughn: Ah...
07:11:07 <lambdabot>  Parse error
07:11:07 <roconnor> @src FilterM
07:11:07 <Baughnie> Source not found. I've seen penguins that can type better than that.
07:11:10 <roconnor> @src filterM
07:11:10 <Baughnie> Source not found. It can only be attributed to human error.
07:11:15 <roconnor> @src Control.Monad.filterM
07:11:16 <Baughnie> Source not found. You type like i drive.
07:11:28 <lambdabot> Ambiguous type variable `a' in the constraints
07:11:28 <lambdabot>   Not in scope: `enumAll'
07:11:30 <lambdabot>   Not in scope: `enumAll'
07:11:39 <lambdabot>   Not in scope: `L.enumAll'
07:11:39 <lambdabot>  4
07:11:41 <Syzygy-> Ah. Now she woke up again!
07:11:43 <lambdabot>  Illegal escape sequence
07:11:55 <Baughn> @botsnack
07:11:55 <Baughnie> :)
07:11:57 <lambdabot>  Parse error
07:11:57 <lambdabot> Maybe you meant: arr bf bug more yow
07:11:57 <lambdabot> :)
07:11:57 <lambdabot>   add an instance declaration for (Num Bool)
07:11:57 <lambdabot>  10
07:11:59 <lambdabot> Plugin `dummy' failed with: IRCRaised thread killed
07:12:03 <lambdabot> :)
07:12:05 <Baughn> @leave #haskell
07:12:07 <lambdabot> Not enough privileges
07:16:20 <roconnor> @src Control.Monad.filterM
07:16:21 <lambdabot> Source not found. stty: unknown mode: doofus
07:16:27 <roconnor> @src filterM
07:16:34 <lambdabot> Source not found. You type like i drive.
07:20:06 <int-e> > filterM(sequence[odd,even])[1..3] -- funny order
07:20:08 <lambdabot>  [[1,3],[1],[1,2,3],[1,2],[3],[],[2,3],[2]]
07:21:50 <roconnor> > mapM(\x->[[x],[]])[1..3]
07:21:53 <lambdabot>  [[[1],[2],[3]],[[1],[2],[]],[[1],[],[3]],[[1],[],[]],[[],[2],[3]],[[],[2],[]...
07:22:07 <roconnor> > (\x->[[x],[]])>>=[1..3]
07:22:09 <lambdabot>  Couldn't match expected type `[[t]] -> t -> b'
07:22:15 <roconnor> > (\x->[[x],[]])=<<[1..3]
07:22:17 <lambdabot>  [[1],[],[2],[],[3],[]]
07:22:29 <roconnor> right
07:22:35 <roconnor> not exponential enough
07:22:37 <int-e> map concat != concatMap
07:23:10 <Syzygy-> :t map concat
07:23:14 <lambdabot> forall a. [[[a]]] -> [[a]]
07:23:16 <Syzygy-> :t concatMap
07:23:20 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
07:23:24 <roconnor> > map concat$mapM(\x->[[x],[]])[1..3]
07:23:27 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
07:23:27 <Syzygy-> Right.
07:24:01 <int-e> > (([]:).(:[]).(:[])) 2
07:24:03 <lambdabot>  [[],[2]]
07:24:14 <roconnor> monsters!
07:24:21 <quicksilver> is that the hear-no-evil see-no-evil speak-no-evil combinator?
07:24:38 <int-e> I think it's cute.
07:24:45 <vincenz> cookie monsters
07:28:31 <Botje>  
07:29:08 <int-e> > let p = foldM(\x y->[x,y:x])[] in p [1..3] -- foldM beats filterM on size (by one character)
07:29:10 <lambdabot>  [[],[3],[2],[3,2],[1],[3,1],[2,1],[3,2,1]]
07:29:30 <int-e> hmm. but reverses the result, hmpf
07:30:14 <roconnor> int-e: nice, but with the "import Monad" the code will still be longer.
07:30:43 <int-e> roconnor: you need that for filterM as well.
07:30:51 <roconnor> yep
07:31:12 <roconnor> p(h:t)=p t++[h:x|x<-p t];p x=[x] -- is the winner so far
07:32:55 <quicksilver> p(h:t)=p t++map(h:)p t;p x=[x]
07:33:02 <robyonrails> #haskell_it
07:33:05 <quicksilver> isn't that 1 char shorter or something?
07:33:09 <int-e> > foldr(\x->(>>= \t->[t,x:t]))[[]] [1..3]
07:33:11 <lambdabot>  [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
07:33:28 <robyonrails> mmh
07:34:07 <Botje> robyonrails: but there's already a #haskell.it ?
07:34:32 <roconnor> quicksilver: um, looks good.  I guess I'm an idiot for not seeing that.
07:34:57 <quicksilver> ok, I"m missing brackets
07:35:08 <quicksilver> p(h:1)=p t++map(h:)(p 1);p x=[x]
07:35:12 <roconnor> ah
07:35:16 <quicksilver> p(h:t)=p t++map(h:)(p t);p x=[x]
07:35:16 <roconnor> and then it becomes the same lenght
07:35:23 <quicksilver> not sure where those 1s came from :)
07:35:34 <robyonrails> thanks botje I didn't remember
07:35:56 <roconnor> int-e also has 32 characters.
07:38:39 <int-e> > foldr(\x t->(t++map(x:)t))[[]] [1..3]
07:38:41 <lambdabot>  [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
07:38:52 <int-e> > foldl(\x t->(t++map(x:)t))[[]] [1..3]
07:38:53 <lambdabot>      Occurs check: cannot construct the infinite type: a = [[a]]
07:38:53 <lambdabot>       Expect...
07:38:57 <int-e> sigh :)
07:39:15 <int-e> > foldl(\t x->(t++map(x:)t))[[]] [1..3]
07:39:17 <lambdabot>  [[],[1],[2],[2,1],[3],[3,1],[3,2],[3,2,1]]
07:40:21 <quicksilver> @pl \t x -> t++map(x:)t
07:40:21 <lambdabot> liftM2 (.) (++) (flip (map . (:)))
07:40:35 <cedricshock> I have a monad question: I have a function that returns something like an IO (BitmapButton ()). I can make a big 2d array of these of type Array (Int, Int) (IO (BitmapButton ())), but what I think I need is something like IO (Array (Int, Int) (BitmapButton ())). How can I accomplish this?
07:40:55 <quicksilver> int-e: it's t++map(x:)t expressible as something like (++).`ap`map(x:)
07:40:55 <scook0> @src drop
07:40:56 <lambdabot> drop n xs     | n <= 0 =  xs
07:40:56 <lambdabot> drop _ []              =  []
07:40:56 <lambdabot> drop n (_:xs)          =  drop (n-1) xs
07:41:04 <quicksilver> int-e: isn't it something like that?
07:43:02 <int-e> quicksilver: hmm. not quite. and you'd have to import Control.Monad.Reader to use that
07:43:08 <int-e> > ap(++)(1:) [2,3,4]
07:43:10 <lambdabot>  [2,3,4,1,2,3,4]
07:43:26 <ari> @type liftM2 (,)
07:43:31 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
07:43:42 <int-e> > ap(++)(map(1:)) [[2]]
07:43:43 <lambdabot>  [[2],[1,2]]
07:43:44 <ari> @type sequence
07:43:45 <int-e> oh sorry.
07:43:47 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
07:43:54 <quicksilver> I knew it was somethign like that :)
07:44:28 <quicksilver> > foldl(\x->ap(++)map(x:))[[]] [1..3]
07:44:29 <lambdabot>  Couldn't match expected type `b -> a' against inferred type `[a1]'
07:44:30 <roconnor> int-e: oooh, 29 characters
07:45:04 <quicksilver> doh, parameters in wrong order
07:45:20 <roconnor> int-e: well, 31 characters once you add the
07:45:24 <roconnor> "p=" at the beginning
07:45:31 <int-e> roconnor: hmm? not 32?
07:45:46 <quicksilver> > foldl((ap(++)map.)(:))[[]] [1..3]
07:45:47 <lambdabot>  Couldn't match expected type `[a]' against inferred type `a1 -> b'
07:45:50 <quicksilver> bah
07:45:59 <ari> cedricshock: I don't think there's a function like sequence for "pulling monadicity outwards" for arrays... I think you're going to need array, assocs, and sequence
07:45:59 <int-e> the foldr version was the right one btw.
07:46:00 <quicksilver> too friday-afternoon to think that through properly
07:46:13 <quicksilver> > foldr((ap(++)map.)(:))[[]] [1..3]
07:46:14 <lambdabot>  Couldn't match expected type `[a]' against inferred type `a1 -> b'
07:46:27 <quicksilver> > foldr(\x->ap(++)map(x:))[[]] [1..3]
07:46:28 <lambdabot>  Couldn't match expected type `b -> b' against inferred type `[a]'
07:46:45 <cedricshock> Ok. A simpler question. If I have a function that returns IO (a), and another function a -> b how do I get an IO (b)? do  athing <- ..., bthing <- f(athing), right?
07:46:46 <int-e> > foldr(\x->ap(++)(map(x:)))[[]] [1..3]
07:46:49 <lambdabot>  [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
07:46:56 <cedricshock> ari: I think I might be starting to see how to do that.
07:47:19 <int-e> > foldr(ap(++).map.(:)))[[]] [1..3]
07:47:19 <lambdabot>  Parse error
07:47:19 <quicksilver> @pl \x->ap(++)(map(x:))
07:47:19 <lambdabot> ap (++) . map . (:)
07:47:40 <int-e> > foldr(ap(++).map .(:)))[[]] [1..3]
07:47:40 <lambdabot>  Parse error
07:47:41 <quicksilver> > foldr(ap(++).map.(:)))[[]] [1..3]
07:47:41 <lambdabot>  Parse error
07:47:45 <quicksilver> > foldr(ap(++).map.(:))[[]] [1..3]
07:47:47 <lambdabot>  [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
07:48:16 <quicksilver> ok I demand partial credit for that one even though I couldn't quite work it out on my own...
07:48:19 <roconnor> quicksilver: is ap in the Prelude?
07:48:20 <quicksilver> :)
07:48:30 <int-e> roconnor: no.
07:48:40 <int-e> roconnor: it loses once you add imports
07:48:41 <quicksilver> roconnor: yes, but you need Control.Monad.Reader to get the monad instance I'm using there
07:49:00 <roconnor> quicksilver: then it isn't even Haskell 98
07:49:08 <roconnor> :)
07:49:16 <int-e> import Monad works though, hmm
07:49:16 * quicksilver shrugs
07:49:38 <quicksilver> I have decided to interpret the challenge as lambdabot-based :)
07:49:45 <roconnor> int-e: ah you are right it is 32 character.  I was counting the
07:49:50 <roconnor> "\t" as one character
07:50:12 <SamB> I think "instance Monad ((->) env)" is H98, but clearly MonadReader is not
07:50:43 <roconnor> SamB: yeah, I suppose you can write the instance youself, but now the code is very much bigger ;)
07:51:03 <cedricshock> ari: I can use sequence on the list that's used to construct the array. I'll need another return somewhere to get the array indexes inside... time to try some things.
07:51:03 <quicksilver> int-e said the instance is in the old Monad module
07:51:10 <roconnor> So, so far 32 characters is the shortest haskell 98 solution I take it.
07:51:18 <int-e> no, I just said that ghc exports it from there :)
07:51:36 <int-e> or rather the base libs as they come with ghc
07:51:48 <int-e> roconnor: yep and we have 2 of those
07:52:34 <roconnor> int-e: there is the fold version, the map version, and the list comprehension version.
07:53:55 <dolio> > length "filterM(\_->[False..])[1..3]"
07:53:55 <lambdabot>  Illegal escape sequence
07:54:02 <dolio> > length "filterM(\\_->[False..])[1..3]"
07:54:03 <lambdabot>  28
07:54:35 <int-e> > length "p=foldr(\h t->t++map(h:)t)[[]]" -- hmm. what's different now?
07:54:35 <lambdabot>  Illegal escape sequence
07:56:22 <cedricshock> ari: This is simple and worked:   listy <- sequence (map (\x -> bitmapButton f [picture := "hot_0.png"]) coords)
07:56:22 <cedricshock>   buttons <- return (array ((minx, miny), (maxx, maxy)) (zip coords listy))
07:56:30 <int-e> I had an extra pair of parentheses originally. fun.
07:57:25 <int-e> roconnor: so that makes 30 then
07:58:07 <dolio> The next question is: what's the smallest solution that doesn't leak space? :)
07:58:10 <quicksilver> length "foldr(ap(++).map.(:))[[]]"
07:58:17 <quicksilver> > length "foldr(ap(++).map.(:))[[]]"
07:58:19 <lambdabot>  25
07:58:50 <roconnor> int-e: 30?
07:59:02 <ari> cedricshock: Cool. I tried for a moment to write the function you asked for, but got tangled up with liftMs and returns and unzips and uncurries...
07:59:13 <int-e> > let p=foldr(\h t->t++map(h:)t)[[]] in p [1..3]
07:59:14 <lambdabot>  [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
07:59:23 <roconnor> ah
07:59:25 <roconnor> horray!
07:59:44 <vincenz> @pl (\h t -> t++map (h:)t)
07:59:44 <lambdabot> ap (++) . map . (:)
07:59:59 <vincenz> > let p = foldr (ap(++).map.(:)) in p [1..3]
08:00:01 <lambdabot>   add an instance declaration for (Num [a])
08:00:01 <lambdabot>     In the expression: 3
08:00:11 <vincenz> > let p = foldr (ap(++).map.(:))[[]] in p [1..3]
08:00:13 <lambdabot>  [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
08:00:30 <vincenz> > length "foldr(ap(++).map.(:))[[]]"
08:00:31 <lambdabot>  25
08:00:32 <Botje> it just keeps on shrinking!
08:01:03 <roconnor> Botje: ap doesn't count :(
08:01:13 <dolio> If ap counts, then the filterM one is shorter.
08:01:18 <dolio> When you remove the [1..3]
08:01:35 <int-e> dolio: foldr(\x->(>>= \t->[x:t,t]))[[]] should not leak
08:01:54 <dolio> Hmm...
08:02:01 <Botje> why wouldn't ap count? :)
08:02:22 <roconnor> Botje: it isn't in the Prelude, so you need to write an import first.
08:02:50 <roconnor> and then you need to write an instance for Monad (-> r)
08:02:56 <Botje> pfft. :)
08:03:07 <dolio> int-e: Well done.
08:03:17 <vincenz> this is done for what specific reason?
08:03:20 <roconnor> or (r->_
08:03:22 <roconnor> or (r->)
08:03:24 <roconnor> or whatever
08:03:36 <roconnor> vincenz: http://bushong.net/dave/comparisons/powerset.html
08:03:37 <lambdabot> Title: Programming Comparisons: Power Set
08:03:41 <vincenz> oh
08:04:43 <quicksilver> roconnor: ap is in the prelude
08:04:50 <quicksilver> roconnor: it's only the -> r instance that isn't
08:04:59 <cedricshock> ari: If you wanted the whole function it'd be do the first step using assoc on the array as the source of the sequence, and then the second step using the array bounds, and zipping the indexes and the list.
08:05:39 <roconnor> quicksilver: ah right, sorry.
08:05:56 <hkBst> is mem.global a valid identifier?
08:07:54 <byorgey> hkBst: I don't think so
08:08:04 <byorgey> > let mem.global = 3 in mem.global
08:08:11 <lambdabot>   Not in scope: `global'
08:08:44 <byorgey> hkBst: . is not valid in identifier names, it's parsed as an operator
08:09:00 <roconnor> > let p l=[]:do{(n,x)<-zip[0..]l;map(x:)$take (2^n)$p l} in p [0..]
08:09:04 <lambdabot>  [[],[0],[1],[1,0],[2],[2,0],[2,1],[2,1,0],[3],[3,0],[3,1],[3,1,0],[3,2],[3,2...
08:09:16 <hkBst> byorgey: thanks, I was afraid of that :)
08:11:12 <shapr> Good morning #haskell!
08:11:40 <quicksilver> shapr: it was, but you missed it :)
08:11:57 <hkBst> how would one do (f (read) 3) in Haskell if f has type   Int -> Int -> Int   ?
08:12:06 <byorgey> morning shapr
08:12:18 <quicksilver> hkBst: what are you reading from?
08:12:28 <quicksilver> hkBst: (f (read s) 3) is fine
08:12:32 <Botje> hkBst: you mean f (read 3) ?
08:12:34 <quicksilver> hkBst: if 's' is the string that you're reding from
08:12:36 <Botje> oh.
08:12:37 <Botje> nm :)
08:12:50 <hkBst> quicksilver: (read) prompt the user for input
08:12:59 <quicksilver> ah, that's not what read means in haskell :)
08:13:03 <Botje> sorry, you can't do that (easily)
08:13:20 <quicksilver> sure you can, it's very easy
08:13:40 <Botje> with unsafe, i guess
08:13:49 <quicksilver> s <- read `liftM` getLine
08:14:03 <quicksilver> putStrLn $ "the answer is " ++ f s 3
08:14:22 <int-e> > let p=foldr(\x->([]:).tail.(>>= \t->[t,x:t]))[[]] in p [1..]
08:14:24 <lambdabot>  [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3],[4],[1,4],[2,4],[1,2,4],[3,4],[1,3...
08:14:34 <quicksilver> hkBst: answer above :)
08:15:02 <hkBst> quicksilver: thanks, I'm thinking about it :)
08:15:07 <byorgey> hkBst: quicksilver's code should go in a do-block, of course (apologies if that's obvious =)
08:15:15 <koffein> hi
08:15:24 <byorgey> hi koffein
08:15:45 <koffein> what is the function to turn a string into an int? could not find it in hoogle
08:15:46 <koffein> ?
08:15:53 <byorgey> > read "123"
08:15:54 <lambdabot>  123
08:15:56 <quicksilver> koffein: read
08:15:59 <koffein> thanks
08:16:01 <hkBst> byorgey: yeah, it's obvious :)
08:16:12 <byorgey> hkBst: ok, just making sure =)
08:17:00 <koffein> obvious? not very intuitive...
08:17:48 <byorgey> koffein: well, if you've worked with I/O for a while, it's obvious
08:17:54 <hkBst> quicksilver: what does `read' in Haskell do?
08:18:26 <Wild_Cat> the opposite of "show"
08:18:32 <koffein> hide
08:18:34 <hkBst> does it parse Haskell from a string?
08:18:36 <koffein> is the opposite
08:18:38 <koffein> :P
08:18:57 <byorgey> @type read
08:19:00 <lambdabot> forall a. (Read a) => String -> a
08:19:07 <byorgey> hkBst: essentially, yes
08:19:36 <byorgey> hkBst: it parses a string into any type which is an instance of the "Read" class
08:19:40 <quicksilver> hkBst: yes
08:19:52 <quicksilver> > read "123" :: Integer
08:19:54 <lambdabot>  123
08:20:12 <quicksilver> > read "Left (Just 4)" :: Either (Maybe Integer) String
08:20:15 <lambdabot>  Left (Just 4)
08:21:05 <koffein> > read '1'
08:21:06 <lambdabot>  Couldn't match expected type `String' against inferred type `Char'
08:21:11 <int-e> roconnor: last one: p=foldr(\x z->[]:tail(z>>= \t->[t,x:t]))[[]] (for infinite lists)
08:21:18 <koffein> thats my next problem
08:21:19 <hkBst> quicksilver: how does `read' know not to parse anything other than an Int?
08:21:27 <quicksilver> koffein: '1' is a char, not a string
08:21:33 <koffein> I know
08:21:38 <quicksilver> hkBst: it parses whatever it thinks you want
08:21:45 <koffein> I mean, I could make it a string
08:21:52 <byorgey> koffein: use digitToInt (from Data.Char)
08:21:56 <quicksilver> hkBst: based on type inference
08:21:57 <byorgey> > digitToInt '1'
08:21:59 <lambdabot>  1
08:22:02 <quicksilver> > read ['1']
08:22:02 <SamB> > read "1"
08:22:02 <koffein> byorgey, thanks
08:22:04 <lambdabot>  1
08:22:05 <lambdabot>  1
08:22:08 <quicksilver> or just put [] round it :P
08:22:16 <byorgey> quicksilver: that too =)
08:22:27 <quicksilver> hkBst: if it can't work it out, it will throw an error
08:22:30 <SamB> now, as for why it thinks you want Int or Integer?
08:22:44 <quicksilver> hkBst: and then you need an explicit type annotation, like in my either example
08:22:48 <quicksilver> > read "Left (Just 4)" :: Either (Maybe Integer) String
08:22:51 <lambdabot>  Left (Just 4)
08:22:52 <quicksilver> SamB: defaulting
08:23:04 <SamB> yeah, I knew it was defaulting...
08:23:19 <quicksilver> (but lambdabot has a more extreme kind of defaulting than standard)
08:23:50 <SamB> yeah, I was just trying to remember if that was in the report or not...
08:24:02 <SamB> how did lambdabot get its extreme defaulting?
08:26:06 <quicksilver> SamB: the report only permits defaulting in the special case of Num, so Read wouldn't be allowed
08:26:16 <quicksilver> SamB: I think it might be -fextended-defaulting from GHC but I'm not sure
08:26:55 <SamB> ah.
08:29:36 <sek> apart from the Parsec ref manual, i have read the chapter in Bird's book "intro to functional prog using haskell" on parsing. Is there any other must reads before i start?
08:30:09 <sek> (i havent read the Parsec manual yet, but i am going to)
08:30:16 <byorgey> sec: just start =)
08:30:21 <byorgey> *sek
08:30:42 <sek> great, thanks:)
08:31:06 <byorgey> sek: you'll learn a lot just by diving in and trying stuff
08:31:36 <sek> no doubt, but im always cautious about getting enough background so as to not be missing out on anything
08:32:35 <byorgey> sek: fair enough, but you'll pick up things along the way
08:33:05 <byorgey> sek: I learned a few things about Parsec from the "Write yourself a Scheme" tutorial, although it's not intended as a parsing tutorial per se
08:33:42 <sek> byorgey, fair enough, but as an example consider the case where i had only read Bird's book (written in 1998) and had gone about doing a lot of extra unecessary work without having heard of Parsec say
08:34:15 <sek> thats an extreme example, i'm just saying :-)
08:44:58 <hkBst> quicksilver: http://paste.lisp.org/display/44052 does that mak sense? can I switch between strings and io input by commenting out like that?
08:47:02 <byorgey> hkBst: you need to add a return to "parseTopLevel code"
08:47:36 <byorgey> like parsed_code <- return $ parseTopLevel code
08:48:00 <hkBst> byorgey: to make it IO ?
08:48:05 <byorgey> hkBst: right
08:49:54 <quicksilver> hkBst: or just use let
08:49:56 <quicksilver> if it isn't IO
08:50:08 <quicksilver> let parsed_code = parseTopLevel code
08:52:43 <byorgey> hmm, yes, I guess x <- return $ y is kind of redundant =)
08:53:04 <hkBst> ah, right :)
09:15:55 <sjanssen> @yow
09:15:55 <lambdabot> SHHHH!!  I hear SIX TATTOOED TRUCK-DRIVERS tossing ENGINE BLOCKS into
09:15:56 <lambdabot> empty OIL DRUMS ...
09:16:14 <Syzygy-> ...
09:16:26 <Vulpyne> Seems like that could be quite loud.
09:16:33 <Syzygy-> I think I will NEVER understand why people like the yows.
09:16:57 <fasta> sjanssen: you are right the ghci debugger has improved. It's still unusable, though.
09:17:41 <sm> fasta: oh, how so ?
09:17:59 <sm> I have been looking forward to it
09:19:04 <quicksilver> sm: it isn't, of course, unusable
09:19:10 <quicksilver> sm: it's not perfect though (nor complete)
09:19:54 <sm> ah.. I'm sure I'll be thankful for it, even so
09:20:04 <fasta> sm: for my use case: finding an infinite loop it currently has a bug.
09:20:16 <fasta> sm: which makes it unusable for me currently.
09:20:33 <fasta> sm: In 6.8 this problem will probably be solved, I hope.
09:20:50 <fasta> sm: but that doesn't change that it's fragile and breaks when you look at it.
09:22:02 <sjanssen> fasta: oh?  what bug?
09:22:30 <Eelis> does ghc provide a case-insensitive string/char comparison function?
09:22:37 <fasta> sjanssen: the one I just descibed to JaffaCake in #gh
09:22:38 <fasta> c
09:23:19 <sjanssen> Eelis: just toLower both your inputs
09:23:27 <Eelis> sjanssen: that method is flawed
09:23:31 <Eelis> In Greek, converting either œÉ or œÇ to uppercase yields Œ£, while the inverse always yields œÉ. Consequently, the convert-all-to-uppercase approach to case-insensitive comparison produces a false positive when comparing œÉ to œÇ, and the convert-all-to-lowercase approach produces a false negative when comparing Œ£ to œÇ. Similar examples exist for other languages.
09:23:45 <sjanssen> Eelis: you win :)
09:23:49 <shachaf> > ((==) `on` map toLower) "aBc" "ABc"
09:23:51 <lambdabot>  True
09:24:37 <oerjan> oh, it's a real Unicode problem
09:24:39 <rustmeister> @type on
09:24:41 <lambdabot> Not in scope: `on'
09:24:48 <rustmeister> whut?
09:24:58 <shachaf> It's in @let.
09:25:02 <rustmeister> oh
09:25:06 <shachaf> on f g x y = g x `f` g y
09:25:17 <shachaf> @ty let on f g x y = g x `f` g y in on
09:25:19 <lambdabot> forall t t1 t2. (t -> t -> t1) -> (t2 -> t) -> t2 -> t2 -> t1
09:26:21 <Eelis> could it be that the ghc folks assumed that the toLower/toUpper approach was sufficient? and if so, would it be appropriate to ask for this functionality in a bug report?
09:26:49 <sjanssen> Eelis: GHC uses libunicode for some of the functions in Data.Char, perhaps that library has a function you can bind?
09:26:59 <shachaf> > toLower 'Œ£'
09:26:59 <lambdabot>  Improperly terminated character constant
09:27:29 <dcoutts> Philippa: I've got to go out now, lets talk later.
09:27:48 <oerjan> > map Just "?"
09:27:49 <Eelis> sjanssen: hm, perhaps. still, it really ought to be part of Data.Char
09:27:50 <lambdabot>  [Just '?']
09:28:01 <Philippa> dcoutts: no problem
09:28:05 <oerjan> a bug in lambdabot?
09:28:12 <sjanssen> Eelis: yeah, report a bug
09:28:20 <shachaf> > map toLower "aŒ£b"
09:28:20 <oerjan> > toLower '?'
09:28:21 <Eelis> alright
09:28:23 <lambdabot>  "a\963b"
09:28:23 <lambdabot>  '?'
09:28:47 * oerjan smacks his head
09:30:24 <shachaf> > toLower '◊ê'
09:30:24 <lambdabot>  Improperly terminated character constant
09:30:29 <shachaf> > map toLower "a◊êb"
09:30:31 <lambdabot>  "a\1488b"
09:30:45 <quicksilver> Eelis: yes, there should be a 'comparing case-insentiive'
09:30:51 <quicksilver> Eelis: file a bug if there isn't one
09:31:25 <Eelis> doing so now
09:32:51 <shachaf> Hmm, why is toLower doing that to ◊ê?
09:34:00 <arcatan> > map toLower "Œ£"
09:34:02 <lambdabot>  "\963"
09:34:10 <oerjan> shachaf: i see only question marks. does it do that to other Unicode characters?
09:34:12 <dylan> because ◊ê is a utf-8 character of several bytes?
09:34:54 <oerjan> what bytes does it consist of? maybe one of them happens to be a '\', or something
09:35:22 <shapr> mmm "Process ghci illegal instruction"
09:36:39 <mm_freak> > map toUpper "œÄ"
09:36:41 <lambdabot>  "\928"
09:37:08 <Syzygy-> > map toUpper "?"
09:37:11 <lambdabot>  "?"
09:38:32 <mm_freak> is does the right thing
09:38:39 <mm_freak> it converts unicode œÄ to uppercase
09:38:42 <oerjan> hm, apparently not, Sigma seems to consist of I with circumflex + pound sign
09:38:56 <Syzygy-> Hmmmm.
09:39:03 <Syzygy-> > map toUpper "¬µ"
09:39:06 <lambdabot>  "\924"
09:39:17 <Syzygy-> Ooookay. How does that display, then?
09:39:33 <Syzygy-> Ah.
09:39:34 <mm_freak> 924 is decimal
09:39:44 <hkBst> @src apply
09:39:44 * Syzygy- found a webpage with unicode code points.
09:39:44 <lambdabot> Source not found. The more you drive -- the dumber you get.
09:40:52 <Eelis> reported.
09:41:00 <oerjan> the string handling is not a problem, but there seems to be a bug with characters.
09:42:58 <koffein> another stupid question here: if i do [1..n]!!10 multiple times, does ghci count to ten every time?
09:43:09 <vincenz> > map toUpper "œÄ "
09:43:11 <lambdabot>  "\928 "
09:43:17 <vincenz> > map toLower "œÄ "
09:43:20 <lambdabot>  "\960 "
09:43:22 <vincenz> o.O
09:43:26 <vincenz> > "œÄ "
09:43:29 <lambdabot>  "\960 "
09:43:31 <vincenz> ah
09:43:46 <mm_freak> œÄ is already lowercase
09:43:48 <Vulpyne> koffein: Maybe not if you put it into a function.
09:43:54 <vincenz> I know
09:43:56 <Eelis> > map toLower "Œ£" == "œÉ"
09:43:59 <lambdabot>  True
09:44:10 <int-e> > map toLower "Œ†"
09:44:11 <lambdabot>  "\960"
09:44:18 <vincenz> Eelis: that is correct, the other sigma can only happen in last-letter position
09:44:42 <vincenz> so ... only when writing ALL caps would it matter
09:44:47 <Eelis> i'll take your word for it :) i know nothing about Greek except this two-lowercase-chars-mapping-to-a-single-uppercase-char phenomenon
09:44:58 * vincenz is learning greek through osmosis
09:45:37 <Syzygy-> Is final-medial-sigma the problem at hand? Or are there more examples?
09:45:49 <oerjan> er, doesn't this mean Greek really needs a string-based toLower, to distinguish sigma placements?
09:45:59 <Syzygy-> (disclaimer: my terminal doesn't show Unicode, so I don't actually see anything other than ?)
09:46:49 <oerjan> Syzygy-: neither do i, go to http://ircbrowse.com/channel/esoteric/20070706
09:46:51 <lambdabot> Title: Meme esoteric IRC Log 2007/07/06
09:47:05 <Eelis> Syzygy-: the problem at hand is: how to perform a correct case-insensitive char/string comparison in Haskell
09:47:31 <Eelis> or at least that's what got us talking about unicode and case
09:47:35 <Syzygy-> oerjan: What do I want to look at there?
09:47:38 <koffein> Vulpyne, so it depends on the haskell implementation?
09:47:49 <oerjan> also, why do character constants break on multibyte characters?
09:47:59 <ndm> why does this code not work
09:48:01 <Syzygy-> Eelis: I recognize the problem. My question about your example remains since I don't see the characters used.
09:48:07 <ndm> overlay_bindIO81 :: forall (a :: # ) b . a  -> b -> b ; overlay_bindIO81 v3 v4 = v4
09:48:15 <oerjan> Syzygy-: you can see the characters in Unicode if you set your browser character set
09:48:19 <ndm> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#sec-kinding - this suggests it should
09:48:21 <lambdabot> Title: 7.4. Type system extensions, http://tinyurl.com/uxvor
09:48:27 <Eelis> Syzygy-: look here: http://hackage.haskell.org/trac/ghc/ticket/1506
09:48:30 <lambdabot> Title: #1506 (Case-insensitive char/string comparison) - GHC - Trac
09:48:36 <Eelis> the second paragraph explains it with the relevant characters
09:48:54 <Syzygy-> > let f = map (toLower . toUpper) in f "\962" == f "\963"
09:48:56 <lambdabot>  True
09:48:59 <Syzygy-> o.O
09:49:07 <Syzygy-> > let f = map (toLower . toUpper) in f "\962\963"
09:49:09 <lambdabot>  "\963\963"
09:49:12 <oerjan> er, assuming you're not running _just_ a terminal
09:49:14 <Syzygy-> Ah.
09:49:15 <ndm> unless you can only specify * and *->* kinds in signatures...
09:49:34 <Syzygy-> oerjan: Nono, I have a browser too. However, the IRC session there seems to have very little to do with anything else.
09:49:38 <Igloo> ndm: Hmm, looks like that's the case
09:50:01 <Syzygy-> And yes, it was final-sigma / medial-sigma as suspected. :P
09:50:25 <ndm> Igloo, any good reason?
09:50:42 <Igloo> ndm: Looking at the code, you can also use !
09:50:55 <quicksilver> interesting
09:50:58 <oerjan> Syzygy-: it's _this_ irc session, look at the end :)
09:51:07 <quicksilver> I'd have though final-sigma should compare "as if it was" medial-sigma
09:51:16 <ndm> Igloo, what is ! as a kind? strictness?
09:51:23 <quicksilver> it's just a written variation, surely?
09:51:37 <oerjan> oops
09:51:39 <quicksilver> you might even imagine some encodings where they are encoded the same, and the font knows which to use and display time
09:51:40 <Igloo> It's unliftedTypeKind
09:51:45 <quicksilver> not that I know all that much about greek
09:51:48 <oerjan> Syzygy-: darn i gave you the wrong channel
09:51:53 <ndm> Igloo isn't that # ?
09:51:59 <Syzygy-> oerjan: My point exactly.
09:52:04 <Igloo> @paste
09:52:04 <lambdabot> Haskell pastebin: http://hpaste.org/new
09:52:14 <Syzygy-> Wow.
09:52:19 <Igloo> Where's the working paste?
09:52:25 <Syzygy-> We have live-weblogging of our discussions. Who'd've thought.
09:52:26 <ndm> Igloo, they seem to be different - using ! I get a ! /= # kind error
09:52:40 <Syzygy-> AND obnoxious floating google ads
09:53:20 <oerjan> i was browsing the channel logs for that just as the problem here came up, so i had two ircbrowse windows at one point :)
09:54:04 <Igloo> ndm: http://paste.lisp.org/display/44055
09:54:44 <ndm> Igloo, thats what i've got open from the wiki, but ! isn't there, ! isn't equal to #, and # ? and ?? aren't accepted in a forall (that i can see)
09:55:02 <Igloo> ndm: Now annotated with the relevant looking bit of the parser
09:55:51 <ndm> Igloo, that looks like a bug to me - ! doesn't appaer to be equal to #, I get an error message using !
09:56:06 <ndm> Couldn't match kind `#' against `!
09:57:01 <ndm> I want to specify #, but will happily accept ? or ?? if they work - alas none of them do
10:01:53 <SamB> ndm: what are you trying to do again?
10:02:15 <ndm> SamB, use GHC's IO Monad at a very low level with automatically generated code
10:02:31 <SamB> ndm: why so low a level?
10:02:32 <ndm> unfortunately GHC doesn't have enough kind inference to make it a pleasant experience
10:02:48 <ndm> SamB, output of a Core optimisation pass
10:04:05 <SamB> @kind IO
10:04:07 <lambdabot> * -> *
10:04:47 <ndm> @info IO
10:04:48 <lambdabot> IO
10:05:15 <ndm> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
10:05:26 <ndm> those #'s make it painful
10:05:44 <SamB> how exactly do they make it painful?
10:05:59 <Syzygy-> What does # mean?
10:06:02 <ndm> they break type inference
10:06:08 <ndm> # = unboxed type
10:06:14 <SamB> what does your code do?
10:06:15 <ndm> i.e. not polymorphic
10:06:23 <ndm> anything, but fast :)
10:06:24 <Syzygy-> Ah.
10:07:00 <SamB> what does some of the code that won't compile look like, as it comes from your pass?
10:07:13 <ndm> foo a b = b
10:07:20 <ndm> where a happened to be State# RealWorld
10:07:30 <ndm> or at least was called with State# RealWorld
10:07:42 <SamB> er, you probably need to keep type information around?
10:07:57 <ndm> i can't, i've lost it by then
10:08:11 <SamB> that's not a very good excuse
10:08:20 <oerjan> isn't RealWorld elided eventually?
10:08:26 <ndm> there exists no Haskell Core language which maintains types and can be worked on externally
10:08:31 <oerjan> (so i seem to have heard)
10:08:46 <ndm> State# RealWorld takes up 0 bytes at runtime
10:08:50 <SamB> none?
10:09:02 <ndm> yes, none
10:09:34 * SamB supposes JHC's wouldn't work... it's too hard to work on anyway...
10:09:36 <ndm> if you include the "actually works" requirement
10:10:49 <SamB> I guess any such form *would* need a library to allow you to preserve the type information without going insane...
10:11:02 <ndm> plus doing manipulations on an untyped language is 100's of times easier
10:11:20 <SamB> I personally think it is usually more of a pain
10:11:21 <ndm> although if you have a prebuilt library of operations it could be made fairly painless, but only Yhc has that...
10:11:37 <SamB> except when you end up banging your head on the typechecker
10:12:00 <Baughn> Somehow reminds me - where do I look for reflection?
10:12:39 <ndm> working untyped, or typed?
10:12:40 <SamB> Baughn: you can either use Data.Generics or something like Template Haskell
10:13:09 <SamB> ndm: I should have said: I think typed is nicer, except when you end up banging ...
10:13:37 <ndm> Baughn, what exactly do you want in your reflection? what are you hoping to do?
10:13:54 <Baughn> ndm: I'm trying to enumerate the bindings in a modul
10:15:07 <Baughn> ndm: For the purpose of populating a cross-reference menu in emacs. I could do source analysis, but having reflection would make errors less likely
10:16:19 <ndm> Baughn, template haskell may work, nothing else will
10:18:42 * olsner grows tired of dissecting haskell papers
10:18:46 <SamB> oh, in emacs?
10:18:48 <conal> on typed vs untyped syntax reps, i expect that gadts + class constraints will make all the difference.  does anyone here have experience with the current state of affairs for that combo in ghc?
10:19:11 <SamB> isn't there a slimey emacs mode for haskell?
10:19:43 <Baughn> SamB: That's what I'm working on. It doesn't work very reliably yet.
10:21:16 <olsner> :t varE
10:21:19 <lambdabot> Not in scope: `varE'
10:21:51 <vincenz> @hoogle varE
10:21:51 <lambdabot> Language.Haskell.TH.varE :: Name -> ExpQ
10:21:51 <lambdabot> Language.Haskell.TH.VarE :: Name -> Exp
10:24:52 <Baughn> Template haskell looks exactly right. ndm++
10:27:01 <Syzygy-> @karma ndm
10:27:01 <lambdabot> ndm has a karma of 22
10:27:47 <SamB> Baughn: but you can't use reify from the IO monad...
10:31:23 <Baughn> SamB: Worse, what do I do with source files that aren't compilable?
10:31:27 <Baughn> I'll think of something.
10:34:35 <SamB> what does SLIME do?
10:35:01 <byorgey> Baughn: I've tried doing that before (enumerating the bindings in a module).  I haven't given up yet but it's tricky.
10:35:28 <Baughn> SamB: Have you used a smalltalk environment? (Squeak?)
10:35:29 <byorgey> Baughn: another possibility (which is what I'm trying now) is through the GHC API.
10:35:41 <SamB> I have used squeak
10:35:56 <SamB> but doesn't squeak cheat?
10:35:59 <Baughn> SamB: Slime is almost, but not quite, entirely unlike squea
10:36:12 <SamB> yes I know that ;-)
10:36:12 <hkBst> is there a function that randomizes a list?
10:36:14 <byorgey> Baughn: I'd be interested if you come up with anything though.
10:36:32 <SamB> I've used slime too
10:36:55 <Baughn> byorgey: I'm just trying to improve haskell-mode a bit, make it more robust. Since it needs to work even on files with invalid syntax, I think using TH is the wrong approach to begin with.
10:37:12 <Baughn> It was a nice idea, though
10:37:14 <byorgey> Baughn: right, in that case using the GHC API won't work either.
10:37:41 <Baughn> SamB: slime? But not SLIME?
10:37:52 <byorgey> Baughn: it sounds very, very tricky.  Probably just a job for some regular expressions I guess.
10:37:58 <SamB> I meant "what does slime do with non-compilable files"
10:38:07 <Baughn> byorgey: That's what it does now, and it isn't very robust
10:38:21 <byorgey> ah.
10:38:21 <Baughn> byorgey: I'm going to start at the BNF, and try loosening it up
10:38:41 <byorgey> Baughn: yes, I suppose that's the way to go then.  good luck!
10:39:06 <Baughn> SamB: Well, slime only handles lisp. Parsing it is reasonably easy..
10:39:23 <SamB> Baughn: what if someone left some parens unbalanced?
10:39:57 * byorgey has interesting thoughts about an "approximate" parser which always succeeds, and tries to match the given grammar as closely as possible, using "unknown" nodes for the rest
10:39:59 <Baughn> SamB: It ignores extra closing parantheses. It doesn't ignore extra opening ones, but it doesn't really matter, since it resets when it hits the next defun anyhow.
10:40:21 <byorgey> probably been studied already =)
10:40:23 <SamB> okay, so... do you only want the names?
10:40:35 <Baughn> byorgey: Unfortunately, that takes exponential time for quite reasonable grammars
10:40:35 <SamB> and source locations?
10:40:54 <Baughn> SamB: That's the idea. Haskell-mode already does this, but not very robustly.
10:41:22 <byorgey> Baughn: that's what I would have guessed, but surely there might be heuristics which would give reasonable (but not optimal) results?
10:41:28 <SamB> it's okay if you only get toplevel definitions and so forth?
10:43:14 <Baughn> byorgey: Surely there are. It would be a good thing to look into.
10:43:24 <Baughn> SamB: Probably not, no
10:43:30 <takamura> hi
10:43:36 <SamB> what other definitions do you need?
10:43:37 <byorgey> hi takamura
10:46:03 <Baughn> SamB: ..all of them, eventually. For autocompletion and showing the types.
10:49:24 <SamB> Baughn: you can't expect to show the types unless (a) there's a type signature or (b) the module can be compiled
10:50:09 <Baughn> SamB: True, but if I can get a dependency graph for the bits that /are/ compilable, I can just compile parts of it
10:50:32 <SamB> I wish GHC knew that trick
10:50:42 <SamB> it would make TH a lot less annoying to work with
10:50:53 <SamB> in some ways
10:50:59 <Baughn> It's probably very hard. This should be fun.
10:51:32 <SamB> well, it might not be very hard in the abstract, but actually implementing it might be harder ;-P
11:28:37 <Pupeno> Is it possible to define "identifiers" on ghci?
11:29:17 <Baughn> As in "let foo = 42" or "bar <- readFile "MeaningofLife.txt"" ?
11:29:46 <Pupeno> yeah, thanks.
11:39:47 <shapr> Is there something like an Empty class?
11:40:29 <shapr> I deal with a lot of big complicated data types in HAppS and I'd sort of like to make instances of Empty for them.
11:40:33 <mehrheit> MonadPlus maybe
11:40:44 <sjanssen> shapr: monoid is the closest I know
11:40:45 <mehrheit> I must have misunderstood
11:41:48 <shapr> Hm, that might work.
11:42:54 <shapr> sjanssen: That's a great suggestions, thanks!
11:43:44 <mehrheit> ?src monoid
11:43:45 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
11:43:50 <mehrheit> ?src Monoid
11:43:50 <lambdabot> class Monoid a where
11:43:50 <lambdabot>     mempty  :: a
11:43:50 <lambdabot>     mappend :: a -> a -> a
11:43:50 <lambdabot>     mconcat :: [a] -> a
11:44:36 <mehrheit> ?src MonadPlus
11:44:37 <lambdabot> Source not found. Are you on drugs?
11:44:52 <byorgey> @info MonadPlus
11:44:52 <lambdabot> MonadPlus
11:44:55 <byorgey> heh
11:45:02 <byorgey> @source MonadPlus
11:45:02 <lambdabot> MonadPlus not available
11:45:09 <mehrheit> how do Monoid and MonadPlus differ?
11:45:49 <shapr> mehrheit: Aren't there three or four .lt Haskellers? Enough for a #haskell.lt channel?
11:45:59 <byorgey> any instance of MonadPlus must be a Monad.
11:45:59 <shapr> whoops
11:46:03 <shapr> I must have offended him.
11:46:15 <shapr> Yay, I didn't drive him away!
11:46:46 <mehrheit> shapr, I don't know of any
11:47:10 <mehrheit> in xchat C-x is the quit command, so I quit accidentially sometimes
11:47:35 <shapr> That's gotta suck.
11:47:55 <SamB> what version of x-chat is that?
11:48:13 <mehrheit> 2.8.0
11:49:34 <shachaf_xchat> Not for me.
11:49:40 <byorgey> mehrheit: any instance of MonadPlus must be a Monad, but Monoid is much simpler
11:49:49 <byorgey> > mempty :: Plus
11:49:50 <lambdabot>   Not in scope: type constructor or class `Plus'
11:50:03 <crazy_code2>  /j #c++
11:50:17 <shapr> heretic!
11:50:28 <mehrheit> byorgey, ok
11:50:43 <byorgey> > mempty :: Sum
11:50:44 <lambdabot>      `Sum' is not applied to enough type arguments
11:50:45 <lambdabot>     Expected kind `?', but...
11:50:50 <byorgey> > mempty :: (Sum Int)
11:50:51 <mehrheit> shachaf_xchat, maybe it's some special ubuntu patch
11:50:52 <lambdabot>  Sum {getSum = 0}
11:50:59 <byorgey> there we are =)
11:51:18 <shachaf_xchat> mehrheit: I'm using Ubuntu.
11:52:01 <shachaf_xchat> mehrheit: Check Settings -> Advanced -> Keyboard Shortcuts?
11:52:02 <mehrheit> then it's some strange anomaly
11:52:27 <monochrom> I like the existence of mainstream languages. Whenever someone says "I don't get rank-N polymorphism", I can ridicule with "it's in mainstream languages eg c++, what do you mean you don't know it"
11:52:43 <mehrheit> it's not there
11:52:50 <shapr> Most polymorphism is just rank...
11:53:31 <shachaf_xchat> mehrheit: Odd. ^x?
11:53:40 <mehrheit> yes
11:58:18 <crazy_code2> Hello
12:00:16 <crazy_code2> If one has to define an instance of the class x say
12:00:38 <byorgey> hi there crazy_code2
12:00:42 <crazy_code2> then is it necessary to use the same method as defined that class only ?
12:01:15 <Cale> crazy_code2: To define an instance, it's sufficient to define all the methods of that class.
12:01:17 <byorgey> crazy_code2: I'm not sure I quite understand your question.  Could you give an example?
12:01:40 <Cale> It's only necessary to define some of them, provided that there are default implementations in the class declaration though.
12:01:42 <crazy_code2> Cale: is it necessary to define all the methods of that class ?
12:02:03 <Cale> For example, with Ord, it's sufficient to define just 'compare'
12:02:04 <crazy_code2> Cale: How would I know which one is default ?
12:02:08 <byorgey> crazy_code2: usually if you look in the documentation it will say something about a "minimal complete definition"
12:02:16 <crazy_code2> Oh Ok
12:02:21 <Cale> crazy_code2: by looking at the class declaration, or reading comments
12:02:23 <byorgey> crazy_code2: those are the ones you need to implement
12:03:12 <byorgey> crazy_code2: for example, see here: http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t%3AOrd
12:03:13 <lambdabot> http://tinyurl.com/ovjef
12:03:30 <byorgey> note where it says "Minimal complete definition: either compare or <=. "
12:04:09 <crazy_code2> So once the minimal complete definition is satisfied, all available methods can be used ?
12:04:45 <crazy_code2> Oh Ok
12:05:29 <crazy_code2> Which are the class generally used ? Ord, Num, Eq, Enum what else?
12:05:34 <crazy_code2> *classes
12:05:45 <byorgey> crazy_code2: right.  the other methods usually have default implementations in terms of the "minimal" ones
12:06:04 <byorgey> crazy_code2: well, it depends what you want =)
12:06:11 <crazy_code2> Read ,Show  ?
12:06:21 <byorgey> crazy_code2: there's Bounded, Read, Show, Ix, Monoid, Monad,...
12:06:34 <crazy_code2> There are only selected ones in books for begineers :)
12:06:57 <crazy_code2> How to move to advanced stage ?
12:07:16 <int-e> lurk on #haskell, read papers, read haskell-cafe, code
12:07:55 <timthelion> @src Dimension
12:07:55 <lambdabot> Source not found. Take a stress pill and think things over.
12:08:08 <crazy_code2> whats read haskell-cafe
12:08:18 <crazy_code2> sorry, haskell cafe ?
12:08:21 <int-e> haskell-cafe is a mailing list
12:08:32 <crazy_code2> how to join it ?
12:08:41 <byorgey> crazy_code2: http://haskell.org/haskellwiki/Mailing_lists
12:08:42 <lambdabot> Title: Mailing lists - HaskellWiki
12:08:46 <int-e> with all sorts of haskell discussions on pretty much every imaginable level
12:09:51 <crazy_code2> btw, if we use deriving Eq, Ord ......... , then we don't have to define the instance of the class Eq, Ord etc       for the data type . Right ?
12:10:04 <byorgey> crazy_code2: right.
12:10:05 <thoughtpolice> crazy_code2: correct. they're properly 'derived' for your type
12:10:29 <byorgey> crazy_code2: but that only works for certain classes where a suitable instance can be automatically generated
12:12:21 <crazy_code2> Ok. So if its working as required using derive, then no need. Else we got to write code for that
12:12:23 <crazy_code2> Great
12:12:25 <crazy_code2> THanks
12:12:27 <crazy_code2> :)
12:13:32 <timthelion> is there a program into which I could type datatypes, like Dimension, and get the lines that define them?  I can't quite get a handle on the syntax for these data X = definitions.
12:14:26 <int-e> tell timthelion :i in ghci can do this
12:14:58 <desp> hmm
12:15:07 <desp> wrapping unions using hsc?
12:15:29 <SamB> timthelion: you could use gadt syntax
12:15:47 <SamB> oh, you meant existing datatypes?
12:15:54 <byorgey> timthelion: what's Dimension?
12:16:00 <crazy_code2> like @src ?
12:16:03 <timthelion> int-e: thankyou
12:16:18 <SamB> @src STM
12:16:19 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
12:16:23 <SamB> @src ST
12:16:23 <lambdabot> newtype ST s a = ST (STRep s a)
12:16:27 <SamB> @src STRep
12:16:27 <lambdabot> type STRep s a = State# s -> (# State# s, a #)
12:16:28 <crazy_code2> @src Dimension
12:16:28 <lambdabot> Source not found. I feel much better now.
12:16:42 <crazy_code2> @src move
12:16:42 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
12:16:52 <crazy_code2> @src away
12:16:52 <lambdabot> Source not found. Are you on drugs?
12:16:59 <byorgey> crazy_code2: ?
12:17:11 <crazy_code2> nothing . Sorry for trolling
12:17:49 <crazy_code2> I wanted to check out lambdabots abusive style of responding ;)
12:18:14 <byorgey> ah.  Well, you can also send private msgs to lambdabot =)
12:19:30 <crazy_code2> byorgey: how to do that ?
12:19:49 <byorgey> crazy_code2: well, it depends on your IRC client
12:19:57 <crazy_code2> Gaim
12:19:58 <byorgey> crazy_code2: in mine, I type /msg lambdabot blah blah blah
12:20:41 <crazy_code2> Ok
12:20:46 <byorgey> crazy_code2: is there some sort of users list? maybe you can right-click on lambdabot and choose some sort of private message option?
12:20:47 <crazy_code2> Thanks, Working for me too
12:20:53 <byorgey> crazy_code2: ah, ok
12:24:11 <sioraiocht> anyone ever written a lucas lehmer test in haskell
12:24:12 <sioraiocht> ?
12:24:45 <crazy_code2> whats that ?
12:24:45 <monochrom> w00t, interesting! but no.
12:24:53 <byorgey> no, sounds like fun though =)
12:25:02 <sioraiocht> hahah
12:25:07 <byorgey> @go Lucas-Lehmer
12:25:09 <lambdabot> http://mathworld.wolfram.com/Lucas-LehmerTest.html
12:25:09 <lambdabot> Title: Lucas-Lehmer Test -- from Wolfram MathWorld
12:25:16 <monochrom> A nice algorithm for primality proving. Works fastest for Mersenne numbers etc.
12:25:24 <sioraiocht> here's the issue, it's usually done on LARGE numbers
12:25:31 <sioraiocht> and libgmp isn't exactly fast, is it?
12:25:45 <int-e> gmp is quite okay
12:25:50 <sioraiocht> the fastest LL tests I've seen use arrays to represent numbers
12:25:50 <byorgey> I though LL works ONLY for Mersenne numbers?
12:26:09 <sioraiocht> byorgey: right
12:26:43 <sioraiocht> it's used a lot of rthe Great Internet Mersenne Prime Search
12:27:05 <sioraiocht> which is currently competing for the EFF prize of 100k USD for the firs tprime over 10,000,000 digits
12:27:18 <sioraiocht> M44 was 9.8 million =p
12:27:25 <sioraiocht> but it was only found last year
12:27:31 <byorgey> sioraiocht: I'd say, give it a shot using Integer and see how much you can squeeze out of it
12:27:40 <byorgey> you know what they say about premature optimization... =)
12:27:53 <sioraiocht> byorgey: my summer of code project is to Multi-thread this LL test that use FFT's
12:28:00 <sioraiocht> written in C
12:28:01 <sioraiocht> that is
12:28:02 <sioraiocht> well
12:28:03 <sioraiocht> not re-entrant
12:28:05 <sioraiocht> not at all
12:28:06 <sioraiocht> not even close
12:28:21 <sioraiocht> I'm trying to nudge the team toward a haskell with C bindings based solution sometime in the future
12:28:22 <byorgey> sioraiocht: oh, I see.  I misunderstood your purpose.
12:28:39 <sioraiocht> byorgey: I might do that anyway, for curiousity
12:28:48 <sioraiocht> because the more often haskell looks fast the more we all win
12:29:47 <crazy_code2> ' Multi-thread this LL test that use FFT's'  please explain. Sounds interesting
12:32:21 <byorgey> oh, interesting, LL can be generalized to work for any number whose prime factorization is known
12:32:30 <int-e> haha
12:32:38 <byorgey> er, any number N where the prime factorization of N + 1 is known =P
12:33:49 <shapr> sioraiocht: What about using the Haskell NDP libraries for that on top of lots of cores?
12:33:55 <byorgey> "I've come up with a super-efficient primality testing algorithm! Just feed in the prime factorization of your number, and presto!"
12:34:42 <sioraiocht> crazy_code2: you can use FFT's to quickly to multiplication on large integers
12:34:49 <sioraiocht> don't ask me how, i never took signals, it just..works
12:34:54 <monochrom> "The future of computer secure depends on the difficulty of factoring primes."
12:35:06 <sioraiocht> until quantum computing happens
12:35:18 <monochrom> Naw, the joke is on "factoring primes".
12:35:31 <shapr> monochrom: What about elliptic curve crypto?
12:35:40 <sioraiocht> oh
12:35:41 <sioraiocht> lol
12:35:52 <sioraiocht> I <3 elliptic curve crypto
12:35:56 <sioraiocht> it's the coolest notion of a finite field EVAR
12:36:03 <koffein> mehrheit, the definition of a MonadPlus http://haskell.org/all_about_monads/html/laws.html#zero
12:36:04 <lambdabot> Title: The monad laws
12:36:05 <monochrom> Bill Gates wrote "factoring primes".
12:36:22 <Codex_> I would think you need prime*prime2 for factoring.
12:36:57 <monochrom> I suppose Bill Gates saw "prime factorization" and wrote it as "factoring primes".
12:52:34 <MrLeavy17> hello
12:52:35 <MrLeavy17> http://www.AWSurveys.com/HomeMain.cfm?RefID=hai2u <-- Make a quick $6 on your paypal account
12:52:37 <lambdabot> Title: A.W.Surveys The New Survey Experience
12:53:05 <desp> heh
12:53:54 <DRMacIver> I feel a little stupider at the mere knowledge that people exist who might fall for that.
12:56:55 <malcolmw> hey andyjgill!
12:57:27 <andyjgill> Hi Malcolm!
12:57:37 <andyjgill> How is york?
12:57:42 <malcolmw> andyjgill: was wondering if you have a public darcs repo for hpc
12:57:59 <andyjgill> Yes, sort of
12:58:03 <andyjgill> 0.4 was released
12:58:05 <malcolmw> I have some parser improvements to contribute
12:58:17 <andyjgill> darcs.haskell.org/hpc is the public one
12:58:30 <malcolmw> ah, will have a look, thanks
12:58:31 <andyjgill> but most of the hacking is now inside ghc's util directory
12:58:51 <malcolmw> there is still an hpc-trans though, right? the stand-alone one
12:58:59 <andyjgill> I'm setting up a new machine that will have better darcs support for joint hacking.
12:59:18 <andyjgill> hpc-trans is in 0.4, and the /hpc repo, yes.
12:59:18 <malcolmw> do you know about code.haskell.org?
12:59:31 <andyjgill> Go on...
12:59:54 <malcolmw> it's a public access machine for community hacking
12:59:56 <andyjgill> its empty right now
13:00:32 <malcolmw> see http://community.haskell.org/admin to sign up for an account etc
13:00:34 <lambdabot> Title: Haskell Community Server
13:00:38 <andyjgill> Ahh. I'm setting a machine more for an offsite backup, coloration of person projects, writing papers, etc. Not all the hacking is in haskell.
13:00:56 <andyjgill> Ahh. like code forge
13:01:01 <andyjgill> source forge, sorry
13:01:03 <malcolmw> yep
13:01:14 <andyjgill> s/person/personal/
13:01:38 <andyjgill> I completely support efforts like code.haskell.org
13:01:53 <andyjgill> did you get a chance to see the hpc paper, BTW?
13:02:04 <malcolmw> no, CR has not showed me a copy yet
13:03:06 <andyjgill> Let me email you a copy (if thats ok, you were our beta tester)
13:03:13 <malcolmw> andyjgill: sure
13:03:34 <andyjgill> Have a look at http://www.unsafeperformio.com/papers/Hpc07.pdf
13:04:41 <malcolmw> so if most of the hpc tools are now in ghc/util, is hpc-trans in there too?  or is there some cunning darcs repo-grafting going on that allows them to share code?
13:05:21 <andyjgill> I'm moved my main hacking into ghc right now; here is the plan.
13:05:53 <andyjgill> there will be a hpc-tools repo, that contains a stand alone version of` 'hpc', which can be more recent that the one with ghc
13:05:56 <monochrom> unsafeperformio.com ? :D
13:06:36 <andyjgill> hpc will contain the original implementation, perhaps becoming hpc-trans
13:07:14 <andyjgill> But the needs of hpc-trans are quite different that the ghc needs
13:07:30 <andyjgill> though I dont want hpc-trans (and hpc-build) to die
13:07:48 <malcolmw> OK, but as long as the datafile formats are well-defined, both implementations can co-exist.
13:08:00 <andyjgill> exactly!
13:08:23 <andyjgill> I do want a good way to combine hpc without needing to compile ghc
13:08:32 <malcolmw> so are you still bothered about whether hpc-trans must remain BSD licensed?
13:09:30 <malcolmw> because I don't want to upset you by injecting GPL licensed code :-)
13:10:14 <andyjgill> Yes, I always was a bit worried by that one
13:10:34 <andyjgill> hpc-trans (and only hpc-trans) was right on the line
13:11:00 <andyjgill> given its parser was from nhc
13:11:53 <andyjgill> (preview: the new hpc ...)
13:11:53 <andyjgill> $ ./hpc
13:11:54 <andyjgill> Usage: hpc COMMAND ...
13:11:54 <andyjgill> Commands:
13:11:54 <andyjgill>   help        Display help for hpc or a single command.
13:11:54 <andyjgill> Reporting Coverage:
13:11:55 <andyjgill>   report      Output textual report about program coverage
13:11:57 <andyjgill>   markup      Markup Haskell source with program coverage
13:11:58 <malcolmw> yeah, nhc is kind of dual-licensed, so it was possible to steal code
13:11:59 <andyjgill> Processing Coverage files:
13:12:01 <andyjgill>   combine     Combine multiple .tix files in a single .tix files
13:12:03 <andyjgill> Others:
13:12:05 <andyjgill>   version     Display version for hpc
13:12:41 <andyjgill> I thought that there was some exception clause, to do with taking a specific part of the code (like the parser)
13:12:53 <malcolmw> that's what I was referring to
13:13:06 <andyjgill> It was useful, in that it got hpc bootstraps
13:13:16 <andyjgill> bootstraps => bootstrapped
13:13:25 <andyjgill> Have you a licensing concern?
13:14:07 <malcolmw> I was just thinking that we have recently merged the nhc98 and yhc compilers, taking some of your parser improvements from hpc-trans
13:14:22 <andyjgill> Or are you wanting to make sure that hpc-trans lives on?
13:14:37 <malcolmw> and it would be nice to actually physically share the merged compiler repo with hpc too
13:14:39 <andyjgill> Good, I'm glad that hpc helped.
13:14:57 <andyjgill> (compiler repo? which one?)
13:15:06 <malcolmw> so that all tools can benefit from future improvements
13:15:26 <andyjgill> Ahh. I get it.
13:15:36 <andyjgill> share the parser between nhc98, yhc and hpc-trans
13:15:41 <andyjgill> right?
13:15:44 <malcolmw> yes, exactly
13:16:12 <malcolmw> but the merged nhc98/yhc is fairly definitely heading in the direction of GPL
13:16:26 <andyjgill> Sure. I would not even mind hpc-trans being GPL'd
13:16:46 <andyjgill> and I assume that colin would not mine either
13:17:04 <malcolmw> so long as the other hpc tools were still BSD3, right?
13:17:40 <andyjgill> yes. There are only two now. hpc (from hpc-tools) and the part compiled into ghc
13:18:34 <andyjgill> On a related topic, how do nhc and ghc share libraries?
13:18:47 <malcolmw> so there are two routes to producing coverage info - one completely BSD, and the other GPLd
13:18:49 <andyjgill> I'm wanting to add some QC checks into Set/Map, etc.
13:19:14 <malcolmw> sharing of libraries is by grafting repos together
13:19:19 <andyjgill> (two routes, yes I certainly do not have a problem with this)
13:19:33 <malcolmw> sorry, (potentially) GPLd
13:20:23 <sorear> re.
13:20:36 <andyjgill> What about adding a hpc option to nhc?
13:20:41 <malcolmw> shared libraries - see the ghc darcs-all script for how its done (nhc98 has something similar)
13:20:56 <malcolmw> andyjgill: now _there's_ a thought!
13:21:24 <andyjgill> Okay.
13:23:12 <malcolmw> thx for chatting - twas useful
13:23:55 <andyjgill> cheers. talk to you soon
13:26:40 <byorgey> sorear: re.?
13:27:06 <sorear> byorgey: standard convention for marking returns
13:28:12 <byorgey> sorear: returns... as in, you returned to your computer? or you lifted yourself into a monad?
13:28:48 <opqdonut> return sorear :: m Ircer
13:30:28 <Vulpyne> I've usually seen it used as shorthand for "re-hi".
13:31:00 <byorgey> Vulpyne: that doesn't help.  What is "re-hi" shorthand for?
13:31:06 <shapr> hi again?
13:31:32 <eivuokko> Yes, I read "re" alone in irc as "Hi again."
13:31:51 <desp> ugh
13:31:53 <Vulpyne> Yeah, what they said. :)
13:31:54 <byorgey> I see.  odd. =)
13:32:06 <desp> is it just me, or does hsc2hs not support C unions?
13:32:10 <eivuokko> byorgey, I agree.
13:32:27 * byorgey realizes he will never be done learning IRC customs
13:32:36 <desp> byorgey: you're supposed to reply "im"
13:32:43 <monochrom> "re" is an old convention. You have to be IRCing for 20 years to know it.
13:32:56 <desp> 10 years suffices
13:32:57 <eivuokko> desp, I'd imagine unions should work fine with it, I am fairly sure they do with ghc's hsc2hs.
13:33:16 <eivuokko> desp, Are you trying to do something fancy?
13:33:16 <byorgey> desp: let me guess... "im" = ... actually, I have no idea
13:33:19 <shapr> monochrom: I haven't been irc'ing for 20 years yet!
13:33:20 <opqdonut> kinda like "." (or is that very finland-specific)
13:33:28 <opqdonut> "re" i mean
13:33:31 <desp> byorgey: real/imaginary; just kidding
13:33:41 <byorgey> desp: oh, haha
13:33:44 <monochrom> 10 years ago was when "re" declined and "ur" gained popularity
13:33:45 <desp> eivuokko: well, not very fancy, just an union inside a struct
13:33:45 <olsner> actually, you only have to have been here for about 5 minutes to have catched the explanation :P
13:33:49 <Philippa> that's a complex pun there
13:33:51 <opqdonut> desp: j/k that should be
13:33:59 * desp high-fives Philippa
13:34:19 <desp> opqdonut: *g*
13:34:23 <byorgey> monochrom: wut's wrng w/ ur?
13:34:24 <Philippa> monochrom: I don't think I've been on IRC ten years yet, FWIW - I use re on MSN and AIM and confuse people
13:34:26 <opqdonut> some chans i hang around have this repeated "hi" "lo" "pivot" gag
13:34:39 <opqdonut> hilarious eh?
13:34:49 <monochrom> open
13:34:58 <desp> eivuokko: I'm getting "error: 'struct Foo' has no member named 'bar1'"
13:35:06 <olsner> opqdonut: please explain?
13:35:11 <desp> eivuokko: and "...'bar2'"; where both are inside an union
13:35:16 <opqdonut> olsner: think quicksort
13:35:31 <Vulpyne> Ahh, the joys of geek humor.
13:35:39 <opqdonut> :)
13:35:57 <Philippa> opqdonut: chan full of flag-waving dutch people?
13:36:01 <eivuokko> desp, Well, how hsc2hs works, is like C's offsetof-macro, so it shouldn't matter, as lon as your name makes sense in C syntax-wise.
13:36:08 <opqdonut> Philippa: don't think so :)
13:36:13 <opqdonut> mostly finns
13:37:04 <eivuokko> desp, Maybe you are missing name of the union variable?  Ie something like baz.bar1 instead of bar1?
13:37:13 <byorgey> well, thanks for the lesson in IRC customs, all.  now I just have to figure out what "and ." means =)
13:37:34 <desp> eivuokko: oh, you are right, and I'm a fool.
13:37:42 <desp> haven't used unions much.
13:37:45 <desp> thanks.
13:38:15 <olsner> :t (and .)
13:38:18 <lambdabot> forall a. (a -> [Bool]) -> a -> Bool
13:38:21 <opqdonut> :)
13:38:32 <byorgey> hehe
13:38:46 <eivuokko> desp, np.  FWIW, lots of people use anonymous unions in C, so it's common not have need for baz.-part.
13:39:12 <desp> right
13:47:23 <DRMacIver> Hmph.
13:47:43 <DRMacIver> I find Haskell's conventions on what characters can go where *really* irritating sometimes.
13:47:55 <earthy> ?
13:48:15 <DRMacIver> e.g. ' and 0-9 are legal in identifiers, except at the beginning.
13:48:26 <earthy> uhuh.
13:48:30 <DRMacIver> Constructors (including infix ones) have to start with capital letters.
13:48:40 <DRMacIver> Where : is the only non-alphanumeric capital.
13:48:51 <DRMacIver> etc.
13:48:55 * earthy nods
13:49:04 <earthy> what's irritating about that?
13:49:12 <sorear> eivuokko: Anonymous unions are illegal in C.
13:49:16 <earthy> would you rather have different fonts for them?
13:49:21 <eivuokko> sorear, Common extension.
13:49:52 <DRMacIver> No. I'd rather there weren't silly restrictions on which characters appeared in identifiers and they behaved in the manner that SML has had for years. :)
13:50:35 <sorear> Does SML have pattern bindings/
13:50:39 <DRMacIver> (While we're at it I don't want to be forced to use different characters depending on which fixity I want my function to have)
13:50:43 <monochrom> The rule about 0-9 is in SML too.
13:51:15 <opqdonut> the rule for 0-9 is everywhere
13:51:44 <sorear> opqdonut: FORTH lets you define : 42 63 ;
13:52:02 <sorear> then anywhere you use 42, it will actually execute 63
13:52:04 <opqdonut> hihi :)
13:52:12 <monochrom> SML has pattern bindings.
13:52:13 <opqdonut> but forth is for perverts
13:52:14 <SamB> opqdonut: ... MACRO1 lets you define symbols like AA7
13:52:26 <SamB> er.
13:52:28 <SamB> 77A
13:52:45 <DRMacIver> sorear: Yes, of course. Unless pattern binding means something more subtle than I think it does. :)
13:53:04 <mauke> how does SML distinguish between constructors and variables?
13:53:25 <opqdonut> lexically?
13:53:45 <Toxaris> (lambda (0a) 0a) is accepted by clisp as a Common Lisp expression
13:54:04 <sorear> monochrom: let Some x = my_function ;; <- how does SML know whether this is a pattern binding or a function definition?
13:54:27 <Toxaris> there's no real cause to rule out identifiers wich starts with digits, as long as they contain a non-digit at any position, is there?
13:54:38 <mauke> Toxaris: 0xff
13:54:55 <sorear> Toxaris: it forces you to use more spaces
13:54:56 <opqdonut> ok ok when i said everywhere i meant the c-family of languages + perl, python and ruby
13:55:16 <monochrom> sorear: "fun Some x = ..." vs "val Some x = ..."
13:55:18 <sorear> Toxaris: imagine if you had to put a space between 2 and x  in 2x
13:55:22 <DRMacIver> sorear: It's a pattern binding. There's a keyword for defining functions.
13:55:56 <sorear> Oh.
13:56:03 <mauke> case x of Nothing -> ...?
13:56:05 * sorear never saw this before
13:56:19 * sorear never made a particularly serious study)
13:56:28 <Toxaris> sorear: what does 2x mean?
13:56:40 <sorear> Toxaris: '2' applied to 'x'
13:56:48 <sorear> Toxaris: apposition
13:57:05 * DRMacIver is fine with having to put spaces between identifiers. :)
13:57:16 <monochrom> "2 x" is the same as "2*x" in Mathematica.
13:57:32 <DRMacIver> It's the same in Haskell as well given an appropriate Num instance. ;)
13:58:31 <monochrom> "x y" is the same as "x*y" in Mathematica when x,y are variables of type Int.
13:58:40 <DRMacIver> (Although I think you might run into problems making that work consistently. I haven't thought it through.)
13:58:41 <Toxaris> ok, 2 could be function (wich seems like bad design, but ok), and then 2 x would mean something, and for this ultra important case, 2x to mean something is outruled?
13:59:11 <monochrom> Now you can't fudge that into Haskell since I have pinned down the type of x. If anything you have to go "(fromIntegral x) y".
14:00:29 <Toxaris> is it really parsed that way?
14:00:30 <mrd> declarations in SML must be preceeded with val/fun/type etc
14:00:32 <Toxaris> let x = 3 in 2x
14:00:37 <Toxaris> > let x = 3 in 2x
14:00:39 <lambdabot>   add an instance declaration for (Num (t -> a))
14:00:39 <lambdabot>     In the expression: let x...
14:00:51 <DRMacIver> Anyway, the specific irritation is that I wanted a good name for a generic tuple accessor function. :)
14:01:03 <monochrom> Like "2for1"?
14:01:14 <opqdonut> there can be no generic tuple accessor?
14:01:21 <opqdonut> s/tuple/n-&/
14:01:46 <DRMacIver> Well, a set of. One for each n in N.
14:02:07 <monochrom> You can use Roman numerals.
14:02:13 <DRMacIver> No I can't.
14:02:17 <DRMacIver> Those would be constructors. :)
14:02:38 <monochrom> iii_xii
14:03:02 <desp> records--
14:03:02 <DRMacIver> Ok. I wanted a name which people who aren't severely warped likes. ;)
14:03:17 <DRMacIver> Anyway, not like 2 for 1. Like #1, #2, #3...
14:03:18 <monochrom> You are not severely warped? :)
14:03:23 <DRMacIver> No.
14:03:32 <opqdonut> i just used "tuple" function that took a numeric argument
14:03:34 <opqdonut> much nicer
14:03:34 <DRMacIver> I'm sane. It's everyone else that is mad. :)
14:03:46 <monochrom> Now I'm mad at you.
14:03:50 <DRMacIver> opqdonut: Eh?
14:03:58 <Toxaris> the I in a roman numeral is not a capital i, but a vertical stroke wich looks like a captial i, so lowercase roman numerals are kind of un-roman
14:04:13 <DRMacIver> monochrom: I get that a lot. :)
14:04:39 <DRMacIver> I suppose I'll use something ugly like t1, t2, t3, t4... :-/
14:04:46 <monochrom> Toxaris: Well I'm severely warped. :)
14:05:18 <DRMacIver> monochrom: But at least you admit your problem. ;)
14:05:49 <Toxaris> opqdonut: so nth 3 (1, 2) would dynamically fail?
14:06:00 <opqdonut> yeah
14:06:19 <monochrom> "nth 2 (1,2)" can be made to work but there is a lot of type class hackery.
14:06:24 <opqdonut> nites, had a helluva week
14:06:28 <DRMacIver> I don't see how it could possibly even succeed statically. :)
14:07:01 <DRMacIver> It doesn't seem possible to assign a type signature to it without requiring the tuples to be homogenous.
14:07:15 <opqdonut> typeclasses
14:07:37 <DRMacIver> No, that was covered by my "requiring the tuples to be homogenous"
14:07:55 <opqdonut> well yeah okay
14:08:11 <DRMacIver> You're asking for fullblown dependent types, because for a heterogenous tuple the type of nth number tuple depends on number
14:08:23 <opqdonut> but anyways, i agree that the haskell tuples are horrifically un-generic
14:08:55 <opqdonut> and i am retiring from this conversation in favour of a good night's sleep
14:09:00 <DRMacIver> ok. Sleep well. :)
14:09:42 <Toxaris> so use nested pairs and (fst . fst . snd) like everyone does in lisp for ages
14:10:46 <DRMacIver> Yeah. And we don't need first class functions, we can define single method objects!
14:10:47 <sorear> :t let cadddr = fst . snd . snd . snd in cadddr
14:10:55 <lambdabot> forall a a1 a2 a3 b. (a, (a1, (a2, (a3, b)))) -> a3
14:11:00 * mrd smacks the evildoers
14:11:21 <DRMacIver> I'm not evil. I'm lovely.
14:11:23 * DRMacIver looks innocent
14:11:33 <DRMacIver> (No, I don't believe me either)
14:11:58 <mrd> not even lispers use nested pairs anymore :P
14:12:04 <mrd> to that extent..
14:13:11 <DRMacIver> Hm. I still can't find anywhere a list of exactly what characters are allowed where in Haskell identifiers. :-/
14:13:40 <desp> while were picking nits
14:13:48 <desp> s/were/we're/
14:14:03 <monochrom> http://haskell.org/onlinereport/ is your friend.
14:14:04 <lambdabot> Title: The Haskell 98 Language Report
14:14:14 <desp> the global scoping of record field names is irritating.
14:14:28 <DRMacIver> monochrom: I'm looking at it now. It's not clear there either.
14:15:10 <monochrom> I am a Haskell lawyer and you can ask for my paid legal advice. :)
14:15:36 <DRMacIver> Oh good. I can use the same awful hack I'd use to do tuple accessors in Java. :(
14:16:05 <monochrom> lawyers can do tuple accessors in Java?
14:16:15 <DRMacIver> > let _1 = \(a, b) -> a in _1 ("foo", "bar")
14:16:18 <lambdabot>  "foo"
14:16:29 <monochrom> Oh yeah, _ instead of #
14:16:43 <DRMacIver> Underscores, the standard "Oops, that's a keyword" rescue device. Sigh.
14:16:56 <monochrom> The wise inventors of C foresaw all this. They allowed _ for a reason!
14:17:25 <sjanssen> desp: yeah, you should go ahead and fix records :)
14:17:26 <DRMacIver> I'll remember to thank Dennis for that on the 20th. :)
14:17:37 <sjanssen> desp: we'll all owe you one
14:17:42 <mauke> actually, most identifiers starting with _ are reserved
14:17:54 <desp> sjanssen: I'm flattered, but I don't think I know enough yet
14:18:24 <desp> still, I read a nice proposal by one of the Simons
14:18:33 <Toxaris> and it's easy to encode tuple arity to avoid typeclass hackery:
14:18:34 <desp> I was hoping it'd at least get into H'
14:18:35 <Cale> Someone should implement Daan's proposal.
14:18:37 <Toxaris> > let ___2 = \(_, b, _) -> b in ___2 ("foo", "bar", "baz")
14:18:38 <lambdabot>  "bar"
14:18:50 <DRMacIver> Toxaris: Gah
14:18:52 <Cale> (maybe with better concrete syntax than the paper)
14:19:07 <DRMacIver> Cale: What's Daan's proposal?
14:19:09 <mauke> > let _x_ = \(_, x, _) -> x in _x_  ("foo", "bar", "baz")
14:19:11 <lambdabot>  "bar"
14:19:19 <Toxaris> mauke: this is cool
14:19:31 <mauke> > let __x = \(_, _, x) -> x in __x ("foo", "bar", "baz")
14:19:33 <lambdabot>  "baz"
14:19:38 <Cale> http://legacy.cs.uu.nl/daan/pubs.html -- the first paper here
14:19:40 <lambdabot> Title: Publications
14:19:59 <byorgey> @pl \f g x -> (f x) + (g x)
14:19:59 <lambdabot> liftM2 (+)
14:20:17 <DRMacIver> Cale: The fact that it's been sitting as a draft for two years and no one has implemented it is discouraging. :)
14:20:47 <Cale> Well, he's implemented it, but not for Haskell.
14:20:53 <DRMacIver> Ah
14:21:05 <Toxaris> > let _ba (_, b, a) = (a, b)
14:21:05 <lambdabot>  Parse error
14:21:15 <Cale> Also, the Clean guys have picked it up, iirc.
14:21:18 <Toxaris> > let _ba (_, b, a) = (a, b) in _ba (1, 2, 3)
14:21:19 <lambdabot>  (3,2)
14:22:13 <Cale> It's really the best proposal I've seen, at least in terms of semantics. The record selection syntax, well, I think we could do without yet another meaning for .
14:22:27 <Cale> But that's another point :)
14:22:30 <DRMacIver> Use #. It's the way forward. :)
14:22:49 <desp> # is dangerous.
14:23:03 <desp> you could hurt your foot kicking it, or summon a foocubus.
14:23:42 <SamB> or worse
14:23:45 <Cale> I'd rather have record selection look like function application.
14:23:46 <SamB> an unboxed tuple
14:25:25 <Cale> However, I suppose that in his proposal, there's no way to really make that work. You really do need some additional syntax, but it could at least have the order swapped.
14:26:04 <MrWalrus> > show True
14:26:04 <mehrheit> 'field ¬¢ record'
14:26:05 <lambdabot>  "True"
14:27:00 <sjanssen> I dislike that Leijen's proposal allows repeated fields in a record
14:27:02 <sjanssen> seems messy to me
14:27:21 <Cale> sjanssen: But if you try to disallow that, there are issues.
14:27:38 <Cale> That's actually the annoying problem with all the other record proposals.
14:28:01 <Cale> You end up having to express all these constraints that such and such record type lacks a given field.
14:28:04 <sjanssen> yeah, the need to express lack of a field in the type system might be worse than duplicate fields
14:28:59 <Figs> hey
14:29:08 <Figs> I think I finally *get* monads
14:29:13 <olsner> hmm, so the idea is that any identifier with underscores in it is a mapping from an n-tuple to an m-tuple with reordering according to the alphabetic ordering of the non-underscores in the identifier?
14:29:21 <Cale> Figs: awesome
14:29:41 <byorgey> Figs: congrats =)
14:30:11 <Toxaris> olsner: yes something like this
14:30:25 <Cale> sjanssen: Also, there appear to be clever uses for duplicate fields. Essentially you get a stack at each label.
14:31:00 <Figs> I don't get how to write them really, but I think I at least understand what they do, and to an extent sort of how they work.
14:32:01 <byorgey> Figs: awesome.  writing them is not too hard, at least for simpler ones.  For example, you might want to try implementing the Monad instance for Maybe, to check how well you understand it.
14:32:04 <Cale> Figs: Basically, they're just a way for us to structure domain-specific languages so that we can share a whole bunch of control structures between them. (e.g. most everything in Control.Monad)
14:33:16 <byorgey> ok, time to go home... bye all
14:34:17 <olsner> (if there was a type for this function:) let retuple indices x = listToTuple $ map ((tupleToList x) !!) indices in retuple [2,1] (5,7,11) ==> (11,7)
14:34:53 <Pupeno> can I change the assosiativity of a function in ghci? that is, 'run' infixr/l?
14:36:18 <SamB> > let infixl (:) in 1:2:3:[]
14:36:18 <lambdabot>  Parse error
14:36:22 <Cale> let infixl 0 $; f $ x = f x
14:36:37 <Cale> will work at ghci's prompt
14:37:10 <Cale> er, hmm
14:37:22 <Cale> It might just be ignoring it though.
14:38:48 <Cale> yes, it seems so
14:45:08 <Pupeno> Is there a haskell-mode manual? how do I run ghci and/or compile the current file/buffer/funtion?
14:47:25 <penten> http://haskell.org/haskellwiki/Haskell_mode_for_Emacs ?
14:47:27 <lambdabot> Title: Haskell mode for Emacs - HaskellWiki
14:51:25 <Altair^> hi! I've been trying to study haskell lately, and have started coding a couple of hours ago... now I cannot figure out what is wrong with the following code: aFac [] = []
14:51:28 <Altair^> aFac (x:xs) = do let sum = fac x let rest = aFac xs return (sum : rest)
14:51:46 <Altair^> well... the intendation is not good when pasted but...
14:51:49 <sorear> Altair^: you don't use 'do' normally
14:52:11 <sorear> Altair^: 'do' is syntax sugar for sequencing operations, which numbers don't support
14:52:22 <sorear> (you use do for IO actions, among other things)
14:52:28 <Altair^> okay
14:52:38 <Altair^> so here I should write like let ... in
14:52:46 <mauke> yes, or ... where
14:52:51 <Altair^> ah
14:52:53 <sorear> aFac (x:xs) = let{ sum = fac x ; rest = aFac xs } in (sum : rest)   should work better
14:53:14 <monochrom> "return" does not mean what you think. totally something else.
14:55:37 <Altair^> thanks sorear, it worked!
14:55:43 <sorear> yw
15:01:54 <Pupeno> I am getting the error "Symbol's function definition is void: inferior-haskell-load-file". What am I missing?
15:02:16 <sorear> Pupeno: you need to manually load the inf-haskell.el file
15:02:24 <sorear> Pupeno: autoloading is broken, no clue why :(
15:03:21 <Pupeno> (load "/usr/share/emacs/site-lisp/haskell-mode/inf-haskell.el") on .emacs?
15:04:02 <sorear> yes
15:06:33 * glguy ponders if hGetChar makes sense for a UTF8 library
15:07:04 <glguy> and I wonder if I'd be able to do that without totally replicating the pure UTF8 decode function
15:10:41 <monochrom> Where is the pure UTF8 decode function?
15:11:02 <glguy> I'm going to release the package for it tomorow I think
15:11:05 <monochrom> Can you import it and use it for your UTF8 hGetChar?
15:11:23 <glguy> hGetChar doesn't mean "read one byte"
15:11:27 <glguy> for UTF8
15:11:38 <glguy> but it needs to fail gracefully on bad encodings
15:11:46 <glguy> and it needs to only read just enough characters
15:11:57 <glguy> I might write a version that uses a class
15:11:58 <monochrom> Yes absolutely.
15:12:02 <glguy> getNextCharacter
15:12:11 <glguy> and you could have an IO instance
15:12:21 <glguy> and you could have one that used a State monad for lists
15:12:27 <glguy> [Char]
15:12:59 <glguy> *a class with a function*
15:13:18 <glguy> and maybe a getOfStream
15:13:24 <glguy> endOf*
15:13:30 <SamB> glguy: how would that work for handles?
15:13:51 <glguy> you could have your IO instance require:
15:13:56 <koffein> if you have a sequence a(i + 1) = f(ai), can you somehow implement that as an infinite list like [1..]?
15:14:06 <glguy> runCharSource decode handle
15:14:06 <monochrom> MPTC!  instance UTF8 IO Handle where ...
15:14:31 <glguy> or:
15:14:31 <jre2> does anyone know of a actors model implementation ontop of STM?
15:14:36 <jre2> an*
15:14:51 <glguy> runCharSoure decode getChar isEof
15:14:55 <monochrom> koffein: iterate f a0
15:14:57 <glguy> instead of using a class
15:15:03 <glguy> I could just require two monadic actions
15:15:07 <monochrom> > iterate negate 1
15:15:09 <lambdabot>  [1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,...
15:15:28 <koffein> monochrom, thanks
15:15:31 <Figs> crap, my head hurts
15:15:42 <Figs> weirdest windows problem ever :P
15:16:09 <mauke> > iterate sqrt 100
15:16:11 <lambdabot>  [100.0,10.0,3.1622776601683795,1.7782794100389228,1.333521432163324,1.154781...
15:16:20 <monochrom> It converges to 1.
15:16:35 <monochrom> But nevermind.
15:16:49 <mauke> last (iterate sqrt 100) == 1
15:17:05 <monochrom> There is actually no last.
15:17:59 <mauke> where last (x : xs@(y : _)) | x == y = x | otherwise = last xs
15:18:55 <monochrom> oopsie. you're clever.
15:19:07 <SamB> that's not the usual last!
15:19:15 <glguy> decodeM :: Monad m => m Word8 -> m Bool -> m String
15:22:07 <Altair^> btw guys, how can I set my stack size bigger so it won't owerflow
15:22:24 <Toxaris> termination depends on the finiteness of Floating instance
15:22:43 <mauke> Toxaris: nah, all you need is a lying Eq
15:23:01 <Toxaris> Altair^: you shouldn't need to :)
15:23:24 <Toxaris> Altair^: stack overflow means "nonterminating loop" most often in haskell
15:25:20 <monochrom> stack size is done by +RTS -K16M
15:27:28 <Toxaris> mauke: but what if it lies the wrong way, like in (==) _ _ = False
15:28:22 <DRMacIver> Toxaris: Or "You should probably have made that strict" :)
15:28:28 <DRMacIver> @where Stack overflow
15:28:28 <lambdabot> I know nothing about stack.
15:28:32 <DRMacIver> @where Stackoverflow
15:28:32 <lambdabot> I know nothing about stackoverflow.
15:28:34 <DRMacIver> Hm
15:28:54 <DRMacIver> There was something on the wiki, but I can't remember where.
15:29:42 <Toxaris> DRMacIver: What about "Please activate -O2 to let me have a real try"
15:29:56 <jre2> @src TChan
15:29:56 <lambdabot> Source not found. My mind is going. I can feel it.
15:30:19 <Altair^> hmm... it could also be that I tried to calculate 89! with my function
15:30:34 <Altair^> which indeed is quite a big a number
15:30:59 <edwardk> @seen ski
15:31:00 <lambdabot> ski is in #oasis, #haskell-blah, #haskell-overflow and #haskell. I don't know when ski last spoke.
15:31:04 <edwardk> @seen ndm
15:31:04 <lambdabot> I saw ndm leaving #haskell 5h 9m 41s ago, and .
15:31:14 <jre2> @seen dgriffi3
15:31:14 <lambdabot> dgriffi3 is in #gentoo-haskell and #haskell. I last heard dgriffi3 speak 18h 21m 41s ago.
15:32:24 <olsner> 89! doesn't seem to be much more than 100 digits long
15:32:52 <DRMacIver> Altair^: Well, a proper implementation of factorial should run in O(1) stack.
15:32:59 <oerjan> > length . show $ product [2..100]
15:33:01 <lambdabot>  158
15:33:24 <oerjan> > length . show $ product [2..89]
15:33:27 <lambdabot>  137
15:33:27 <dmwit> > log . fromIntegral . product $ [2..100]
15:33:29 <lambdabot>  363.73937555556347
15:33:36 <dmwit> o
15:33:41 <DRMacIver> oerjan: You want genericLength
15:33:45 <dmwit> > logBase 10 . fromIntegral . product $ [2..100]
15:33:48 <lambdabot>  157.97000365471575
15:33:51 <monochrom> > foldr (*) 1 [1..89]
15:33:54 <lambdabot>  1650795516090846108121691926245361930983966623649654185491352070783317103437...
15:33:56 <DRMacIver> Oops
15:33:56 <oerjan> DRMacIver: i don't see why
15:33:57 <DRMacIver> Misread
15:34:08 <DRMacIver> oerjan: Don't mind me, I'm being an idiot. :) Misread what you were doing.
15:34:28 <Toxaris> Altair^: quite a big number is no problem for stack size
15:34:41 <Toxaris> Altair^: quite a lot of function calls is
15:34:56 <monochrom> how about http://www.haskell.org/haskellwiki/Stack_overflow
15:34:57 <lambdabot> Title: Stack overflow - HaskellWiki
15:35:29 <DRMacIver> Ah, I'd missed the underscore convention on haskellwiki
15:35:38 <DRMacIver> That explains why I couldn't find it
15:35:43 <olsner> for such a small number as 89, the problem is probably somewhere else though, something like a bug in the termination condition
15:36:21 <monochrom> If factorial of 89 uses more than O(89) space or multiplications, you're in deep trouble. :)
15:36:34 <DRMacIver> Heh. True. :)
15:37:05 <olsner> :t log
15:37:08 <lambdabot> forall a. (Floating a) => a -> a
15:37:57 <monochrom> The numbers are stored in the heap, not stack. The stack only has pointers to them and other pointers.
15:37:59 <olsner> is there a log function that works on the arbitrary-precision integers you get from e.g product [1..50000]?
15:38:19 <Altair^> Toxaris: yeah, I found my mistake, the usual haskell-starter-mistake "fac x = x * fac x-1
15:38:23 <Altair^> "
15:38:52 <monochrom> If you just want a Double result there is no harm to log (realToFrac (product [1..50000]))
15:39:08 <monochrom> heh heh heh!
15:39:16 <oerjan> @type realToFrac
15:39:17 <lambdabot> forall a b. (Fractional b, Real a) => a -> b
15:39:25 <oerjan> @src realToFrac
15:39:25 <lambdabot> realToFrac = fromRational . toRational
15:39:31 <monochrom> > log (realToFrac (product [1..50000]))
15:39:38 <lambdabot> Terminated
15:39:44 <monochrom> oopsie
15:40:28 <monochrom> But on GHC realToFrac enjoys many SPECIALISEs for concrete types Int, Double, ...
15:40:29 <olsner> Infinity :P
15:40:39 <oerjan> > sum (map log [1..50000])
15:40:41 <lambdabot>  490995.24304985354
15:40:55 <olsner> clever ;-)
15:40:59 <monochrom> > exp 490995
15:41:02 <lambdabot>  Infinity
15:42:32 <Toxaris> Altair^: Now that you have working code, you may want to try it for much bigger arguments... fac 10000 works fine for me (using "ghc -O2").
15:42:46 <DRMacIver> > head . dropWhile (\n -> exp n /= Infinity) [1..]
15:42:47 <lambdabot>   Not in scope: data constructor `Infinity'
15:43:10 <DRMacIver> Hm
15:43:59 <monochrom> "On the computability of constructible but unnamed numbers."
15:44:09 <Socrates> > 1/0
15:44:12 <lambdabot>  Infinity
15:44:30 <Altair^> Toxaris: 10000 is still pretty fast
15:44:35 <DRMacIver> > head . dropWhile (\n -> exp n /= 1/0) [1..] -- This will never work :)
15:44:36 <lambdabot>  Couldn't match expected type `a -> [a1]'
15:44:45 <DRMacIver> Sigh
15:45:13 <DRMacIver> (I presume that's just a precedence cockup, but I can't be bothered to fix it)
15:45:23 <oerjan> > let bigLog10 n = log (realToFrac (n `div` (10^s))) + realToFrac s where s = length(show n) - 100 in bigLog10 (product [2..50000])
15:45:28 <lambdabot> Terminated
15:45:29 <olsner> $ [1..] on the end fixes it
15:45:41 <DRMacIver> Ah
15:45:48 <olsner> or $ instead of .
15:45:52 <oerjan> oh wait
15:45:52 <monochrom> > head $ dropWhile (\n -> exp n /= 1/0) [1..]
15:45:54 <lambdabot>  710.0
15:46:28 <oerjan> > let bigLog10 n = logbase 10 (realToFrac (n `div` (10^s))) + realToFrac s where s = genericLength(show n) - 100 in bigLog10 (product [2..50000])
15:46:30 <lambdabot>   Not in scope: `logbase'
15:46:37 <oerjan> > let bigLog10 n = logBase 10 (realToFrac (n `div` (10^s))) + realToFrac s where s = genericLength(show n) - 100 in bigLog10 (product [2..50000])
15:46:39 <DRMacIver> > (exp 709, exp 710)
15:46:42 <lambdabot>  (8.218407461554972e307,Infinity)
15:46:46 <lambdabot> Terminated
15:47:08 <olsner> > exp -746
15:47:10 <lambdabot>   add an instance declaration for (Num (a -> a))
15:47:10 <lambdabot>     In the expression: exp -...
15:47:18 <olsner> > exp (-746)
15:47:20 <lambdabot>  0.0
15:47:27 <Socrates> > (1/0) - (1/0)
15:47:28 <olsner> > exp (-745)
15:47:31 <lambdabot>  5.0e-324
15:47:31 <lambdabot>  0.0
15:47:46 * DRMacIver eyes lambdabot 
15:48:01 <olsner> isn't n/0 supposed to be NaN?
15:48:06 <monochrom> 5.0e-324 is bad.
15:48:08 <Socrates> > 0/0
15:48:10 <lambdabot>  NaN
15:48:14 <oerjan> olsner: no
15:48:17 <monochrom> sqrt (-1) is NaN. 1/0 is fine.
15:48:23 <DRMacIver> 'fine'
15:48:24 <glguy> lambdabot: n/0 can be infinity, -infinity or nan
15:48:40 <Socrates> > 1 - (1/0)
15:48:42 <lambdabot>  -Infinity
15:48:55 <Baughn> Mathematicians may cry, but it's handy for diagnostics
15:48:56 <monochrom> But Infinity-Infinity ought to be NaN.
15:49:22 <mauke> > join (-) (1/0)
15:49:23 <lambdabot>  0.0
15:49:42 <glguy> lambdabot looks startled
15:49:57 <Baughn> Looks like a bug to me
15:49:59 <oerjan> > product [2..50000] `div` (10^490950)
15:50:05 <lambdabot> Terminated
15:50:23 <oerjan> ok it's just to big for lambdabot.
15:50:41 <kaol> > let factorial x = if x == 1 then 1 else sum $ concat $ take x $ repeat (take (factorial (x-1)) $ repeat 1) in factorial 5
15:50:44 <lambdabot>  120
15:50:55 <kaol> who needs multiplication
15:51:05 * glguy does
15:51:08 <DRMacIver> kaol: ...
15:51:13 <Socrates> > (1/0) / (1/0)
15:51:15 <lambdabot>  NaN
15:51:28 <DRMacIver> kaol: That's... awful. :)
15:51:50 <DRMacIver> Hm
15:52:00 <DRMacIver> > (0/0) == (0/0)
15:52:02 <lambdabot>  False
15:52:07 <olsner> kaol: handles x's up to and including 9 (!) without a stack overflow :P
15:52:25 <olsner> in my ghci window
15:52:25 <Socrates> > (1/0) == (1/0)
15:52:27 <lambdabot>  True
15:52:50 <mauke> > join (==) (0/0)
15:52:52 <lambdabot>  False
15:53:26 <mauke> @check join (==) :: Double -> Bool
15:53:29 <lambdabot>  OK, passed 500 tests.
15:53:37 <mauke> lame
15:54:55 <oerjan> > 10.0^100
15:54:58 <lambdabot>  1.0000000000000002e100
15:55:10 <Socrates> > mod (1/0) 3
15:55:12 <lambdabot>  Add a type signature
15:55:20 <Socrates> > mod (1/0) 3 :: Integer
15:55:21 <lambdabot>   add an instance declaration for (Fractional Integer)
15:55:24 <oerjan> @check (< 10.0^100)
15:55:25 <lambdabot>  Add a type signature
15:55:38 <oerjan> @check (< 10.0^100) :: Double -> Bool
15:55:40 <lambdabot>  OK, passed 500 tests.
15:55:50 <oerjan> now _that's_ lame
15:56:21 <olsner> @check (< 10.0^50) :: Double -> Bool
15:56:23 <lambdabot>  OK, passed 500 tests.
15:56:31 <olsner> @check (< 10.0^25) :: Double -> Bool
15:56:33 <lambdabot>  OK, passed 500 tests.
15:56:44 <olsner> @check (< 10.0^12.5) :: Double -> Bool
15:56:45 <lambdabot>  Add a type signature
15:56:59 <olsner> @check (< 10.0^12) :: Double -> Bool
15:57:02 <lambdabot>  OK, passed 500 tests.
15:57:11 <olsner> @check (< 0) :: Double -> Bool
15:57:13 <lambdabot>  Falsifiable, after 0 tests: 0.0
15:57:19 <oerjan> @check (< 1000) :: Double -> Bool
15:57:21 <lambdabot>  OK, passed 500 tests.
15:57:26 <oerjan> @check (< 100) :: Double -> Bool
15:57:27 <lambdabot>  Falsifiable, after 301 tests: 109.41379310344827
15:57:47 <Syzygy-> How about querying lambda?
15:57:55 <Syzygy-> This is filling up the channel pretty badly.
15:58:07 <sorear> Or just use ghci!
15:58:16 <sorear> you do have that, right?
15:58:48 * oerjan doesn't.
15:59:52 <oerjan> not that it matters since i do have WinHugs.
16:02:44 <kaol> > let factorial x = if x == 1 then 1 else sum $ concat $ take x $ repeat (take (factorial $ sum $ tail $ take x $ repeat 1) $ repeat 1) in factorial 5 -- who needs numbers larger than 1?
16:02:46 <lambdabot>  120
16:03:23 <oerjan> oh right, the source implies it is approximately limited by the size parameter
16:03:35 <Socrates> > let factorial x = if x == 1 then 1 else sum $ concat $ take x $ repeat (take (factorial $ sum $ tail $ take x $ repeat 1) $ repeat 1) in factorial 0
16:03:38 <lambdabot>  0
16:03:51 <Socrates> :(
16:05:03 <kaol> would that count as obfuscated haskell?
16:05:19 <kaol> it's useless and pathological, at least
16:05:24 <Baughn> Not quite obfuscated, though
16:05:25 <mauke> who decided to put catch in the Prelude?
16:05:30 <mauke> it's annoying
16:06:14 <monochrom> Me.
16:06:25 <Toxaris> http://paste.lisp.org/display/44079
16:06:30 <kaol> @pl let factorial x = if x == 1 then 1 else sum $ concat $ take x $ repeat (take (factorial $ sum $ tail $ take x $ repeat 1) $ repeat 1) in factorial
16:06:31 <mauke> monochrom: why? :-(
16:06:32 <lambdabot> fix (ap (flip if' 1 . (1 ==)) . ((sum . join) .) . ap take . (repeat .) . flip flip (repeat 1) . (take .) . (. (sum . tail . flip take (repeat 1))))
16:06:40 <monochrom> No, I'm just kidding.
16:07:51 <monochrom> Next, someone is going to write factorial in church encoding (i.e., using functions throughout) and say "who needs data" :)
16:08:18 <Toxaris> should be easy, church encoding is multiplication friendly
16:08:58 <edwardk> monochrom:  its already done look at the evolution of a haskell programmer page =)
16:09:25 <edwardk> http://www.willamette.edu/~fruehr/haskell/evolution.html
16:09:26 <lambdabot> Title: The Evolution of a Haskell Programmer
16:09:27 <kaol> what stage of a haskell programmer's evolution mine represents? :-P
16:10:33 <edwardk> kaol: i think it is one of the lesser known side branches of the evolution that sort of dead ends due to a lack of a viable population =)
16:10:43 <kaol> ouch
16:11:08 <sorear> We think we've found the bug in happs that was making hpaste unusable!
16:11:25 <kaol> somehow I'm awed by that (repeat .) part. Would a human write that?
16:11:27 <sorear> ... | L.length request > 0 = ...
16:11:35 <sorear> Lazy IO + network programming = boom
16:11:47 <monochrom> OH!
16:12:04 <Baughn> monochrom: Should be easy. instance Num F, for some appropriate F...
16:14:05 <oerjan> kaol: actually your version might have some relation to the list-encoding one
16:14:34 <kaol> oh. I read it as (repeat (.)) which is something different. never mind.
16:14:56 <oerjan> :ty repeat (.)
16:15:10 <oerjan> :t repeat (.)
16:15:18 <lambdabot> forall b c a. [(b -> c) -> (a -> b) -> a -> c]
16:17:19 <kaol> I'd like to see code that uses repeat (.) seriously
16:17:20 <SamB> so, what stage is JHC hacking?
16:19:58 <SamB> kaol: conversion to church encoding, obviously
16:23:07 <kaol> somebody prevent me from writing a fibonacci function. please.
16:24:21 <dolio> So, when exactly does GHC do CSE? When it can prove that it doesn't introduce a space leak?
16:24:23 <Baughn> kaol: Please write a 2^fibonnaci function instead
16:25:11 <Syzygy-> Hmmm.
16:25:22 <Syzygy-> Writing a 2^fibonacci function in fractran sounds like a good exercise.
16:25:43 <Syzygy-> It ends up being kinda equivalent to writing a fibonacci for a stacky goto language.
16:28:12 * sorear checks the source for dolio
16:28:19 <sjanssen> dolio: never IIRC
16:28:37 <int80_h> is hpaste up?
16:28:43 <Cale> !hpaste
16:28:44 <glguy> !paste
16:28:44 <hpaste> Haskell paste bin: http://hpaste.org/
16:28:50 <Cale> oh, right :)
16:28:51 <int80_h> hmm okay
16:29:00 <Cale> up, but really slow?
16:29:05 <int80_h> it seems to be taking awhile to render
16:29:10 <int80_h> that's right cale
16:29:12 <dons> dolio: let me check for you.
16:29:16 <oerjan> they just said they've found the bug
16:29:29 <dons> dolio: http://haskell.org/haskellwiki/Performance/GHC#Common_subexpressions
16:29:31 <lambdabot> Title: Performance/GHC - HaskellWiki, http://tinyurl.com/3cmjvj
16:29:32 <int80_h> I'm having difficulty with typing. It's a YAHT exercise
16:29:38 <Saizan> hpaste it's quite broken atm, but we think we've found the problem
16:29:59 <Cale> int80_h: What is the problem?
16:30:49 <int80_h> well I could paste some of the code here and the error
16:30:52 <timthelion> what is the difference between a type and a data?
16:30:53 <Cale> sure
16:31:06 <int80_h> it's exercies 4.6 in Yaht.
16:31:07 <Cale> timthelion: 'type' introduces a synonym for an existing type
16:31:18 <Cale> timthelion: 'data' introduces a new data structure with its own type
16:31:27 <int80_h> and here's the datatype as I've started to write it.
16:31:32 <oerjan> @where lisppaste
16:31:32 <lambdabot> I know nothing about lisppaste.
16:31:38 <Cale> timthelion: 'newtype' introduces a new type into the type system, implemented the same way as an existing type
16:31:51 <timthelion> Cale: so data is like defun and type is like alias. except in terms of types not functions
16:32:04 <Cale> timthelion: yes
16:32:10 <int80_h> data Tuple a b c d = Nothing | a | a b
16:32:24 <oerjan> int80_h: Nothing is taken by Maybe
16:32:24 <int80_h> erm, | a b is on another line
16:32:33 <Cale> InfinityB: You're missing names for the data constructors
16:32:39 <Cale> er, int80_h rather
16:32:42 <Cale> (sorry)
16:32:55 <int80_h> oh, well that's the complaint I get a is not a constructor
16:33:00 <Cale> Right
16:33:07 <int80_h> okay these can be arbitary names?
16:33:10 <Cale> Constructor names have to start with a capital letter
16:33:14 <sorear> glguy: I just tested hpaste locally, and it works fine with Saizan's happs fix
16:33:19 <Cale> other than that, you're free to name them what you like
16:33:23 <glguy> Saizan: what was wrong?
16:33:23 <oerjan> and they must be unique to the data type
16:33:25 <Cale> (they also have to be unique)
16:33:26 <glguy> err
16:33:28 <glguy> sorear:
16:33:42 <sorear> glguy: alexj used | L.length res > 0 in code
16:33:47 <Cale> Nothing happens to be taken by the Maybe type
16:33:48 <int80_h> okay so far so good
16:33:52 <sorear> glguy: which of course forces the whole reply
16:33:55 <Cale> data Maybe a = Nothing | Just a
16:33:56 <timthelion> so >type FromMaster = Int is what I want, when making FromMaster not be confused with other types of ints. not >data FromMaster = FromMaster Int
16:33:58 <sorear> glguy: causing a deadlock
16:33:59 <glguy> sorear: instead of not null?
16:34:01 <glguy> ah
16:34:06 <int80_h> I'm not allowed to use nothing?
16:34:06 <sorear> glguy: yeah.  changing to not null fixed it
16:34:14 <int80_h> unless I'm using the Maybe data type?
16:34:26 <oerjan> timthelion: note that type will not prevent your typechecker from being confused
16:34:28 <Cale> timthelion: When making FromMaster not confused with other Ints, you want data, or better yet, newtype.
16:34:44 <sorear> glguy: so as soon as shapr returns and can rebuild kakapo's global happs, hpaste will work again
16:35:00 <Cale> timthelion: The things defined by 'type' are just rewritten automatically before typechecking.
16:35:11 <glguy> hurray!
16:35:15 <timthelion> bassically I have 3 types of indexes in a list, and I want to force me, the programer, not to be confused about which one I'm using
16:35:19 <Cale> (or otherwise treated as identical by the type system)
16:35:25 <SamB_XP> timthelion: newtype
16:35:27 <Cale> timthelion: You want newtype.
16:35:38 <SamB_XP> wait, did you say in a list?
16:35:48 <timthelion> SamB_XP: no,
16:35:54 <sorear> glguy: or I suppose I could scp a binary over, and have it fixed a minute.  but somehow having binaries not correspond to sources sounds like a recipe for confusion :)
16:36:08 <Cale> int80_h: Right, since Nothing is taken
16:36:21 <Cale> int80_h: You can call your data constructor MyNothing
16:36:32 <Cale> Or something else suitable
16:36:50 * sorear goes back to reading Type classes with functional dependencies
16:36:56 <dolio> Whoops, have to step out at the moment. But, dons, that doesn't seem like it could be the whole story on that page, as on the number theory story on reddit, it says that '(gcd1 p x) `seq` gcdmany' (gcd1 p x) xs' actually evaluates strictly.
16:36:59 <mauke> import Prelude hiding (Maybe(..))
16:37:02 <dons> http://programming.reddit.com/info/247tp/comments :D
16:37:03 <lambdabot> Title: Proofs and Types - a Tutorial (reddit.com)
16:37:24 <int80_h> I think maybe (heh) this excercise expects I will be using the Maybe type
16:37:29 <Cale> Nope,
16:37:37 <Cale> it expects you to define a new type
16:37:41 <Cale> With data.
16:38:15 <Cale> Would you like to see the data declaration? I find YAHT could probably have used more examples...
16:38:20 <int80_h> so defining MyNothing is what it is looking for...okay.
16:38:35 <mauke> juse use None, it's shorter :-)
16:38:40 <Cale> Well, it doesn't say that the tuples will have to be able to hold nothing
16:38:47 <Cale> It says 1,2,3, or 4 elements.
16:38:47 <int80_h> I would like a doc with more examples..but yes if you could give me the data declartion that would be nice.
16:38:50 <timthelion> Cale, it's a wikibook, fix it if it lacks flesh
16:39:15 <int80_h> well it wants you to write a function that returns Nothing in particular cases.
16:39:21 <Cale> timthelion: yeah, I should :) I wonder what process is in place to merge the changes back into the PDF version.
16:39:25 <Cale> Oh!
16:39:37 <Cale> int80_h: Yeah, for that part, you can use Nothing :)
16:39:54 <int80_h> I thought that meant I needed to have it in the data type
16:39:59 <Cale> But get the data type declared first.
16:39:59 <timthelion> Cale people don't use the pdf do they?
16:40:01 <int80_h> or I was to use Maybe, ,,,
16:40:14 <Cale> timthelion: *shrug* I don't know. I tend to use it.
16:40:22 <oerjan> int80_h: your data type for argument, Maybe for result
16:40:28 <sorear> Cale: IIRC there is a buildbot.
16:40:33 <Cale> I like PDF better for on-screen reading than HTML.
16:40:38 <sorear> @seen kowey
16:40:38 <lambdabot> I saw kowey leaving #darcs and #haskell 2d 56m 21s ago, and .
16:40:47 <Cale> (especially when it's been produced by TeX)
16:41:04 <timthelion> Cale: maybe you need a web brouser with better anti-aliasing or something
16:41:05 <dylan> I prefer .dvi for screen-reading TeX.
16:41:21 <Cale> timthelion: No, I have subpixel antialiasing everywhere.
16:41:21 <mauke> anti-aliasing? in my text?
16:41:21 <dylan> there's a rather noticeable performance difference between the two here.
16:41:46 <Cale> It's just that LaTeX does a much better job of typesetting than any web browser.
16:41:58 <timthelion> typesetting?
16:42:02 <Cale> yes
16:42:09 <timthelion> like choosing the font?
16:42:10 <int80_h> Cale, may I message you my e-mail address for the data type?
16:42:13 <dylan> timthelion: arranging letters to make it pretty. <g>
16:42:29 <Cale> timthelion: Like spacing letters and words.
16:42:30 <SamB_XP> dylan: well, for that you need to *have* all the fonts
16:42:35 <sorear> timthelion: Setting letters in place
16:42:37 <timthelion> maybe we need a prettybrouser written in haskell rendering with svg
16:42:48 <dylan> SamB_XP: not usually a problem, in my experience.
16:43:02 <Cale> int80_h: I could put it here, I'm just thinking about how to give another example :)
16:43:05 <sorear> timthelion: back in the day, letters were called type, and they were set into place with scraps of lead and clamps
16:43:11 <Cale> Let's do a silly employee example.
16:43:27 <SamB_XP> dylan: also you need the picture files and so on... and postscript stuff is typically wonky...
16:43:30 <timthelion> sorear: no they wheren't,  god created the earth in 1985
16:43:30 <sorear> timthelion: that's why we call it typesetting, even though nowadays it's just computer-assisted arithmetic
16:43:32 <int80_h> that is pretty silly, but your secret is safe with me, and the logs.
16:43:57 <dylan> SamB_XP: Indeed true, but when all that is available, it's a pleasant reading experience.
16:44:16 <dylan> SamB_XP: because I can switch through the pages without waiting.
16:44:27 <SamB_XP> yes, quite so
16:44:29 <Cale> data Employee = Boss String Integer | Worker String Integer
16:44:32 <SamB_XP> now WTH can't PDF do that?
16:44:51 <dylan> pdf is *almost* useably fast on my OSX powerbook.
16:45:01 <sorear> Yes! Now the *TYPE SYSTEM* enforces that bosses don't work!
16:45:20 <SamB_XP> I mean besides the fact that DVI is far far older and so has older applications to read it
16:45:22 <Cale> Then, for instance,  (Boss "Mr. Jones" 250000) would be a valid Employee value.
16:45:30 <timthelion> pdf is quite usable on my dell inspiron 5150 with either gv or kpdf
16:45:39 <SamB_XP> which originally ran on far far slower hardware
16:45:39 <sorear> timthelion: pdf /= pdf.
16:45:44 <Cale> Boss would be a function of type  String -> Integer -> Employee
16:45:54 <Cale> int80_h: That make sense?
16:45:58 <timthelion> what does /= mean?
16:46:02 <sorear> not equal to
16:46:18 <timthelion> huh?
16:46:21 <Cale> I actually like postscript quite a lot too. :)
16:46:22 <SamB_XP> > 1 /= 2
16:46:24 <lambdabot>  True
16:46:36 <Cale> There's something nice about a page format which is also a programming language :)
16:46:40 <timthelion> sorear: so pdf. is not pdf?
16:46:49 <SamB_XP> Cale: yeah
16:46:57 <mauke> > let pdf = join (/) 0 in  pdf /= pdf
16:46:59 <lambdabot>  True
16:47:09 <Cale> heh
16:47:19 <SamB_XP> very clever
16:47:23 <sorear> ! forall (a :: pdf) (b :: pdf) . a == b
16:47:36 <Cale> int80_h: Still here?
16:47:43 <sorear> pdfs these days are mostly just image bundles
16:47:44 <SamB_XP> I think what he's saying is that not all pdfs are the same ;-)
16:47:55 <sorear> there are good pdfs, but they're rare
16:47:57 <SamB_XP> sorear: not really
16:47:59 <Cale> sorear: What pdfs are you talking about?
16:48:02 <SamB_XP> there are a few different kinds
16:48:02 <dons> Igloo: is the new foldl' the fully strict version?
16:48:07 <timthelion> sorear: only if your downloading illeagle text books
16:48:18 <SamB_XP> there are *scanned* PDFs, which can either be OCR'd or not
16:48:19 <Cale> sorear: The only pdfs I've ever seen like that are scanned books
16:48:28 <dons> Igloo: like the one we use in the streams lib (50% faster, iirc, by always getting an unboxed worker)
16:48:31 <dons> foldl' f z0 xs0 = go z0 xs0
16:48:34 <dons>   where
16:48:34 <Cale> Which would be better off in djvu format :)
16:48:34 <SamB_XP> and there are PDFs with too *many* images in them
16:48:36 <dons>     go !z []     = z
16:48:38 <dons>     go !z (x:xs) = go (f z x) xs
16:48:54 <timthelion> sorear: have you been spending too much time reading those stupid standardised tests online?
16:48:56 <SamB_XP> and then there are PDFs which have text in them
16:49:17 <Cale> Most of the PDFs I see are produced by pdflatex.
16:49:31 <Cale> and are hence nicely searchable and all that
16:49:34 <SamB_XP> said PDFs almost universally contain text
16:49:42 <SamB_XP> I won'
16:49:46 <Cale> and some diagrams :)
16:49:48 <SamB_XP> t say quite universally
16:50:05 <Cale> It's really easy to include graphics in such documents.
16:50:06 <SamB_XP> because sometimes someone will make one with just a piece of vector graphics in it
16:50:08 <syntaxfree> hey. Anyone here on clonazepam? if yes go to #haskell-blah else sorry for disruption
16:50:29 <oerjan> > foldl' (const 1) undefined [1..10]
16:50:30 <lambdabot>   add an instance declaration for (Num (b -> a))
16:51:03 <oerjan> > foldl' (const 1) undefined [1]
16:51:04 <lambdabot>   add an instance declaration for (Num (b -> a))
16:51:17 <int80_h> Cale, I'm here
16:51:21 <Cale> int80_h: okay
16:51:31 <Cale> Do you get the Employee example?
16:52:02 <oerjan> > foldl' (const $ const 1) undefined [1]
16:52:05 <lambdabot>  1
16:52:17 <int80_h> it scrolled by me, I will scroll up again.
16:52:18 <Cale> Let's try another one.  data Shape = Square Double | Rectangle Double Double
16:52:40 <Cale> that's perhaps a little more telling
16:52:54 <Igloo> dons: It should be semantically identical to the old one
16:53:17 <Cale> Here, we have two constructors: Square, which takes a single Double parameter (presumably the side length), and Rectangle, which takes two.
16:53:59 <dons> Igloo: ah ok. I bet we could make it stricter without anyone noticing -- but perhaps its best to provide benchmarks and a library submission for that?
16:54:20 <dons> since the const acc laziness is unlikely to be relied upon, surely
16:54:21 <int80_h> Cale, that works when you know exactly what type you will have
16:54:39 <Cale> int80_h: right, I haven't got to type parameters yet
16:54:51 <dons> glguy: ok, so your account application came in
16:55:00 <Cale> Now let's suppose that we don't want to tie ourselves down to the Double type
16:55:01 <int80_h> oh, well I knew that stuff. it's the generalizing that befuddles me
16:55:05 <dons> do you want to just host the repo in ~$HOME/?
16:55:18 <int80_h> yes let u supposed that :)
16:55:23 <Cale> But instead allow the user to plug in whatever type of number they wanted.
16:56:07 <Cale> Then we'd want Shape to be a sort of 'function' from types to other types, taking a type of numbers and producing a type of shapes.
16:56:39 <Cale> So that  Shape Double  would be our original version of Shape
16:57:01 <dons> btw, people will likely be interested in this -- it explains much of what we're doing here :-)  http://programming.reddit.com/info/247tp/comments
16:57:02 <lambdabot> Title: Proofs and Types - a Tutorial (reddit.com)
16:57:22 <Cale> How would we write that? We just introduce a type parameter on the left hand side, and use it in place of the types of the parameters to the data constructors on the right.
16:57:23 <int80_h> Cale, I'm with you
16:57:29 <jedai> I don't remember if "apply l x = map ($x) l" exists in the Prelude (or others base library) ?
16:57:37 <Cale> data Shape a = Square a | Rectangle a a
16:57:44 <dons> jedai: not in the prelude.
16:57:51 <dons> ?pl apply l x = map ($x) l
16:57:51 <lambdabot> apply = flip (map . flip id)
16:57:54 <dons> heh
16:57:57 <Cale> apply = sequence?
16:58:09 <Cale> > sequence [(*2), (+1)] 5
16:58:13 <lambdabot>  [10,6]
16:58:20 <dons> ?let apply l x = map ($x) l
16:58:21 <lambdabot> Defined.
16:58:21 <Cale> but the instance for that isn't in the Prelude.
16:58:30 <dons> > apply [(*2), (+1)] 5
16:58:32 <lambdabot>  [10,6]
16:58:42 <dons> yeah, you'll need Control.Monad.Instances, jedai
16:59:08 <jedai> I think I'll just put my "apply" somewhere...
16:59:13 <Cale> int80_h: So does the parametrised version make sense?
16:59:22 <dons> jedai, or just write: apply = sequence
16:59:41 <glguy> dons: I can do that
16:59:56 <int80_h> Cale there's too much going on in this channel right now
17:00:07 <int80_h> Cale: let me digest this a moment
17:00:12 <Cale> join #haskell-overflow
17:01:44 <dons> glguy: you know .. we really should have galois.com/code for galois libs
17:01:58 <dons> SyntaxNinja: don't you think? ^^
17:02:17 <dons> esp. if we're going to release more libs like this. :)
17:03:53 <Igloo> dons: Sonds like a plan
17:04:18 <Igloo> dons: Why not use community, OOI?
17:05:09 <SyntaxNinja> dons: oh, idono... it's nice to be fully integrated into the community.
17:05:09 <lambdabot> SyntaxNinja: You have 1 new message. '/msg lambdabot @messages' to read it.
17:05:20 <dons> just seems that a fairly large group like galois should have all their stuff under one place
17:05:28 <dons> like we have www.cse.unsw.edu.au/~pls
17:06:06 <SyntaxNinja> yeah, it would be good to at least list everything.
17:06:09 <dons> yeah
17:06:17 <Igloo> If things might be co-maintained with non-Galois people then community makes more sense for hosting. If not then I guess it doesn't much matter.
17:06:20 <SyntaxNinja> so people know that we do stuff.
17:06:23 <SamB_XP> SyntaxNinja: what is unintegrated about running on galios.com?
17:06:25 <dons> just this kind of thing, http://www.cse.unsw.edu.au/~pls/code.html
17:06:25 <lambdabot> Title: PLS@UNSW: Software
17:06:54 <SyntaxNinja> SamB_XP: oh, just you know, like what igloo said, and just trying to keep the number of places people go to look for software small.
17:06:56 <dons> SyntaxNinja: so yeah, host on code.h.o, and hackage, but have a `free software' page on galois.com/code or some such
17:06:58 <SyntaxNinja> we're a part of the Haskell community.
17:07:03 <glguy> dons: http://code.haskell.org/utf8-string/
17:07:04 <lambdabot> Title: Index of /utf8-string
17:07:05 <SamB_XP> dons keeps his stuff in http://www.cse.unsw.edu.au/~dons/ -- he's still in the community!
17:07:05 <lambdabot> Title: Don Stewart
17:07:06 <SyntaxNinja> dons: right. I think that's a good idea.
17:07:08 <SyntaxNinja> yay glguy
17:07:13 <dons> glguy: sweet. i'll do some testing
17:07:17 <glguy> needs docs and better tests still
17:07:23 <dons> glguy: did we decide on a bytestring interface?
17:07:24 <SyntaxNinja> SamB_XP: yeah
17:07:26 <glguy> but now there can be a common point for this
17:07:33 <dnox> dons: heard anymore of people got hs-plugins to work under win yet without flaws?
17:07:33 <dons> oh, and i want to grab the performance stuff from fps to check that
17:07:38 <SamB_XP> galois.com is a lot easier to remember ;-)
17:07:45 <dons> dnox: not recently, seems to be an issue looking up the symbol name
17:07:59 <dnox> ok
17:08:14 <SyntaxNinja> also, I don't kow that we want to maintain a separate infrastructure.
17:08:20 <dons> SyntaxNinja: like Andy's stuff on unsafeperformio.org -- hard to remember when its all spread out.
17:08:30 <SyntaxNinja> yeah
17:08:35 <dons> but, we could just have a central page for repos / libs mmaintained by galois people
17:08:43 <SyntaxNinja> OK, glguy hear that? now you have 2 portals to work on ;)
17:08:45 <dons> like iavor's stuff, andy's, yours, erics. etc.
17:09:01 <glguy> I'M A PROGRAMMER NOT A SYSADMIN
17:09:02 <glguy> :)
17:09:19 <SyntaxNinja> all good programmers have a little bit of sysadmin in them, in my experience ;)
17:09:27 <glguy> "little bit" :-D
17:09:37 <SamB_XP> it tends to be a rather small bit
17:09:41 <SyntaxNinja> (he's really grinning like that over the cube wall)
17:09:46 <glguy> maybe we should take this conversation over the cube wall
17:09:46 <dons> glguy: ok, its a nice day here in sydney, i'll do some stress testing, polishing on the utf8 lib.
17:09:54 <dons> glguy: so we can tag in say, 24 hours?
17:09:57 <glguy> dons: good deal
17:09:59 <glguy> dons: yes
17:10:16 <SyntaxNinja> OK I have to leave now. bye!
17:10:20 <dons> see ya
17:16:05 <glguy> dons: re-pull if you have already, I forgot a module
17:17:30 <dons> ok.
17:17:49 <dons> ?where+ utf8 http://code.haskell.org/utf8-string/
17:17:50 <lambdabot> Done.
17:18:26 <dons> ok, so how do i commit changes? or should i send them to you?
17:18:41 <dons> can i get in the utf8 project? does that 'just work'?
17:19:06 <glguy> sorear: have you been building hpaste against 0.8.8?
17:19:27 <sorear> glguy: HAppS-devel, whatever that is.
17:19:47 <glguy> sorear: so... latest darcs sources?
17:19:53 <sorear> yes
17:20:27 <sorear> remember, /home/eric/public_html/hpaste is on shapr's kill list.  I'm using .../hpaste-devel
17:20:44 <glguy> I'm going to get this revived and on code.h.o also..
17:21:42 <sorear> what?  hpaste?
17:21:59 <glguy> yeah.. move towards centralized location for the repo
17:22:43 <glguy> and it ought to make it easier for multiple people to have commit access and whatnot
17:22:48 <glguy> under individual usernames
17:23:53 <glguy> and syntaxninja said I can run hpaste on community.h.o
17:24:30 <glguy> so its just a matter of getting it together
17:26:36 <sfultong> > foldl (zipWith (/)) [1..] $ map (map (*2)) [[1..n] | n <- [10..20]]
17:26:38 <lambdabot>  Couldn't match expected type `([[a]] -> [[a]]) -> [[a]] -> [[a]]'
17:29:34 <glguy> > foldl (zipWith (/)) [1..] [map (*2) [1..n] | n <- [10..20]]
17:29:37 <lambdabot>  [4.8828125e-4,4.76837158203125e-7,8.269085843960102e-9,4.656612873077393e-10...
17:30:47 <sfultong> lambdabot doesn't like $?
17:31:16 <oerjan> sure it does, but it's unnecessary there
17:31:33 <oerjan> (in glguy's version)
17:31:38 <dons> > id $ 4
17:31:40 <lambdabot>  4
17:33:18 <dons> glguy: so i'm in group utf8-string-p ?
17:33:24 <glguy> dons: aye
17:33:29 <dons> what's the darcs push ssh path?
17:33:46 <glguy> dons: c.h.o:/srv/code/utf8-string
17:33:52 <dons> ok.
17:34:19 <glguy> dons: no obligation of course! but if you feel compelled to push anaything, I trust you to :)
17:34:27 <dons> cool. good.
17:34:33 <dons> yeah, i'll just do some docs/ test stuff
17:34:43 <dons> check the performance
17:34:47 <oerjan> sfultong: now that is strange, when i try your version in Hugs i get the same as glguy, no error
17:35:10 <glguy> when i try his version in ghci, i get no error
17:35:17 <sfultong> oerjan: yeah, I can run it in ghci
17:35:22 <dons> oh hmm
17:35:37 <oerjan> hm... maybe someone snuck in a @let again? :)
17:35:45 <glguy> ?undefine
17:35:46 <lambdabot> Undefined.
17:35:48 <dons> :t foldl (zipWith (/)) [1..] $ map (map (*2)) [[1..n] | n <- [10..20]]
17:35:50 <lambdabot> forall a. (Fractional a, Enum a) => [a]
17:35:52 <dons> > foldl (zipWith (/)) [1..] $ map (map (*2)) [[1..n] | n <- [10..20]]
17:35:54 <lambdabot>  [4.8828125e-4,4.76837158203125e-7,8.269085843960102e-9,4.656612873077393e-10...
17:36:00 <dons> looks like it
17:36:36 <glguy> > undefined $ putStrLn
17:36:38 <lambdabot> Terminated
17:37:29 <oerjan> ?
17:37:37 <oerjan> > undefined
17:37:43 <lambdabot>  Undefined
17:37:47 <dons> that's interesting
17:38:54 <oerjan> > undefined 1
17:38:56 <lambdabot>  Undefined
17:39:36 <oerjan> > undefined $ putStrLn
17:39:38 <lambdabot>  Undefined
17:40:00 <timtheli`> um,  with lazy evaluation, why does main get evaluated?  I mean you don't have to look inside to find out IO () do you?
17:40:41 <dons> you do :)
17:40:55 <glguy> case runIO main of () -> exit
17:40:57 <timtheli`> why? isn't IO() essencialy nil?
17:41:10 <dons> its not (), its state -> (state, ())
17:41:10 <glguy> timtheli`: it could return () or it could not
17:41:29 <dons> ?src IO
17:41:29 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
17:41:52 <dons> and to get that final RealWorld, you end up demanding the program back to the start of main
17:42:33 <dons> if it was pure, you'd have something like:   main :: () ; main = let x = something; y = something else ; in ()
17:42:36 <glguy> that's the theory, but in reality, GHC just runs it, no?
17:42:38 <dons> which would'nt evaluate anything
17:43:01 <dons> well, it just desugars into code threading RealWorld values around
17:43:07 <dons> which ghc evaluates.
17:43:18 <oerjan> however even for a value of type () (without the IO) Haskell does evaluation.
17:43:33 <sorear> of course, since () has two values
17:43:38 <glguy> () could be undefined or ()
17:43:40 <sorear> haskell needs to know which to return
17:43:45 <glguy> and there's only one way to find out
17:44:13 <oerjan> however, even for a value of data Void; Haskell does evaluation (I suspect)
17:44:44 <oerjan> although that could of course never return.
17:44:49 <sorear> haskell doesn't do evaluation.  it has no operational semantics :)
17:44:49 <timtheli`> it seems to me that main returns a list of actions, which is then lazilly read, and so uppon reading item 1 the eventual reading of item 2 is changed. because item 2 is read lazilly after item 1.  but I don't get this whole returning () if that where the case
17:45:09 <sorear> timtheli`: How long have you been haskelling?
17:45:18 <sorear> timtheli`: You just described the 1.2 IO system :)
17:45:25 <timtheli`> sorear: not long enough to know squat
17:45:47 <timtheli`> is 1.2 older or newer?
17:45:55 <sorear> much older
17:46:03 <oerjan> before Monads.
17:46:05 <timtheli`> why was it changed?
17:46:18 <sorear> http://haskell.org/definition/haskell-report-1.2.ps.gz
17:46:32 <sorear> timtheli`: stream code is a major pain
17:46:38 <sorear> even today - look at happs
17:46:52 <sorear> s/happs/hpaste/
17:47:28 <timtheli`> but it makes sense.
17:47:39 <sorear> stream IO (in the form of lazy bytestrings) was very slightly messed up, changing the demand properties
17:47:50 <sorear> since hpaste is on a network, we had deadlock
17:48:31 <oerjan> timtheli`: note that the Haskell language definition itself does not say anything about how an IO action value is represented.
17:48:39 <dons> sorear: oh, that's interesting
17:48:47 <dons> can you elaborate? how'd it get done wrong?
17:48:59 <oerjan> the source above is just how ghc happens to do it.
17:49:06 <sorear> dons: alexj committed the classic blunder, L.length rest > 0
17:49:24 <sorear> tweaking it to not (L.null rest) fixes
17:49:26 <timtheli`> can that be fixed?
17:49:41 <sorear> timtheli`: can what?
17:49:54 <dons> sorear: ah ha. hmm. maybe we should have a big warning
17:49:56 <timtheli`> well hpaste and the 1.2 IO system
17:50:08 <dons> since that's two reasonable hackers who've got it wrong now
17:50:55 <sorear> dons: what, with RULES and a deprecated symbol?
17:51:23 <sorear> NB: the GNU linker has a deprecation facility used to make a big fuss when programs try to link gets
17:51:37 <dons> sorear: with documentation
17:51:47 <sorear> this could be abused to warn on an "optimized" L.length xs > 0 combination
17:51:54 <dons> indeed.
17:52:13 <dons> i think i've done that once. there's even an example on the wiki somewhere
17:52:19 <Shurique> where can I find the docs for Text.Regex? Hoogle is giving me 404s
17:52:30 <sorear> @docs Text.Regex
17:52:31 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Text-Regex.html
17:52:31 <Korollary> @docs Text.Regex
17:52:31 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Text-Regex.html
17:52:55 <dons> sorear: also, hackage.haskell.org has some other regex libs
17:52:56 <oerjan> @docs Random.Module
17:52:56 <lambdabot> Random.Module not available
17:52:59 <dons> Shurique: ^^
17:53:02 <Shurique> yeah, that documentation isn't there
17:53:03 <sjanssen> sorear: are you suggesting a RULE to turn length xs == 0 to null xs?
17:53:05 <oerjan> (just checking :) )
17:53:22 <dons> sjanssen: i think he means a rule to insert a warning pragma :)
17:53:25 <sorear> sjanssen: No, I'm suggesting a RULE to turn length xs == 0 into lengthIsZero xs
17:53:40 <Korollary> @docs P=?NP Proof
17:53:41 <lambdabot> P=?NP Proof not available
17:53:44 <sorear> where lengthIsZero forces the whole thing, but emits a warning in the linker
17:54:50 <Shurique> http://haskell.org/ghc/docs/latest/html/libraries/base/Text-Regex.html is what Hoogle gives me as well, and the link is 404
17:54:53 <lambdabot> http://tinyurl.com/2z87jz
17:56:13 <oerjan> http://www.haskell.org/ghc/docs/latest/html/libraries/regex-compat/Text-Regex.html
17:56:15 <lambdabot> http://tinyurl.com/2ub2m7
17:56:51 <oerjan> (from the direct link on the /libraries/ page.)
17:57:11 <Shurique> oh, thanks!
18:00:52 <sjanssen> sorear: you and your zany complicated solutions :)
18:01:10 <sorear> I know :(
18:01:27 * sorear just yesterday proposed adding another kind constructor to Core
18:02:26 <oerjan> @kind error
18:02:35 <lambdabot> Not in scope: type variable `error'
18:02:44 <oerjan> @type error
18:02:48 <lambdabot> forall a. [Char] -> a
18:04:21 <dons> ?seen glguy
18:04:22 <lambdabot> I saw glguy leaving #haskell 12m 36s ago, and .
18:04:24 <dons> oh
18:04:31 <dons> ah yes
18:05:11 <oerjan> @type (foldl error)
18:05:13 <lambdabot> forall b. [Char] -> [b] -> [Char]
18:12:10 <syntaxfree> > map chr  [77,69,71,65,32,77,69,71,65,32,87,72,73,84,69,32,84,72,73,78,71]
18:12:12 <lambdabot>  "MEGA MEGA WHITE THING"
18:12:33 <jre2> syntaxfree: nice
18:13:23 <syntaxfree> jre2: I just did the opposite of that on #haskell-blah
18:13:37 <SamB> > map (subtract (ord 'A'))
18:13:38 <lambdabot>  <[Int] -> [Int]>
18:13:47 <SamB> > map (subtract (ord 'A')) [77,69,71,65,32,77,69,71,65,32,87,72,73,84,69,32,84,72,73,78,71]
18:13:48 <jre2> I knew I shouldn't have stopped lurking in there
18:13:49 <lambdabot>  [12,4,6,0,-33,12,4,6,0,-33,22,7,8,19,4,-33,19,7,8,13,6]
18:17:24 <syntaxfree> @type noty
18:17:27 <syntaxfree> @type not
18:17:27 <lambdabot> Not in scope: `noty'
18:17:30 <lambdabot> Bool -> Bool
18:17:51 <syntaxfree> @let order f = map ((subtract (ord 'A')) . (filter (not isSpace))) f
18:17:52 <lambdabot> Couldn't match expected type `Bool'
18:18:12 <syntaxfree> @let order  = map ((subtract (ord 'A')) . (filter (not isSpace))))
18:18:12 <lambdabot>  Parse error
18:18:15 <syntaxfree> @let order  = map ((subtract (ord 'A')) . (filter (not isSpace)))
18:18:16 <lambdabot> Couldn't match expected type `Bool'
18:18:24 <oerjan> syntaxfree: not . isSpace
18:18:29 <syntaxfree> @let order  = map ((subtract (ord 'A')) . (filter (not . isSpace)))
18:18:30 <lambdabot> Couldn't match expected type `Int' against inferred type `[Char]'
18:18:53 <syntaxfree> @let order xs = map ((subtract (ord 'A')) . (filter (not  (isSpace xs)))) xs
18:18:53 <lambdabot> Couldn't match expected type `a -> Bool'
18:19:20 <oerjan> sheesh!
18:20:07 <syntaxfree> help!
18:20:19 <syntaxfree> @let order  = map ((subtract (ord 'A')) . (filter (not . isSpace)))
18:20:19 <lambdabot> Couldn't match expected type `Int' against inferred type `[Char]'
18:20:28 <syntaxfree> @let order  = map ((subtract (ord 'A')) . (filter (not . isSpace)) . ord)
18:20:29 <lambdabot> Couldn't match expected type `[Char]' against inferred type `Int'
18:20:41 <oerjan> @let order  = map ((subtract (ord 'A')) . ord) . (filter (not .  isSpace)))
18:20:41 <lambdabot>  Parse error
18:20:42 <syntaxfree> @let order  = map ((subtract (ord 'A')) . (filter (not . isSpace))) (map ord xs)
18:20:43 <lambdabot> <local>:1:72: Not in scope: `xs'
18:20:51 <syntaxfree> @let order xs = map ((subtract (ord 'A')) . (filter (not . isSpace))) (map ord xs)
18:20:52 <lambdabot> Couldn't match expected type `Int' against inferred type `[Char]'
18:20:58 <syntaxfree> @type map ord x
18:21:03 <lambdabot> Not in scope: `x'
18:21:10 <oerjan> @let order  = map ((subtract (ord 'A')) . ord) . (filter (not .  isSpace))
18:21:11 <lambdabot> Defined.
18:21:29 <Saizan> ?type isSpace
18:21:32 <lambdabot> Char -> Bool
18:21:54 <syntaxfree> @type filter (not . isSpace)
18:21:56 <lambdabot> [Char] -> [Char]
18:22:28 <syntaxfree> @let order xs = map (subtract (ord 'A')) . ord) $ filter (not . isSpace) xs
18:22:29 <lambdabot>  Parse error
18:22:42 <syntaxfree> @let order xs = map (subtract (ord 'A')) $ filter (not . isSpace) xs
18:22:44 <lambdabot> <local>:2:0:     Multiple declarations of `L.order'     Declared at: <local>:...
18:22:55 <dolio> @yow
18:22:55 <lambdabot> I was born in a Hostess Cupcake factory before the sexual revolution!
18:22:56 <syntaxfree> @let gobbedlygook xs = map (subtract (ord 'A')) $ filter (not . isSpace) xs
18:22:57 <lambdabot> Couldn't match expected type `Int' against inferred type `Char'
18:23:22 <dolio> @instances-importing Control.Monad.Identity Applicative
18:23:23 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
18:23:56 <dolio> @instances-importing Control.Monad.Identity Control.Applicative Applicative
18:23:57 <lambdabot> ((,) a), ((->) a), Const m, IO, Maybe, WrappedArrow a b, WrappedMonad m, ZipList, []
18:25:37 <Saizan> @source Control.Applicative
18:25:38 <lambdabot> Control.Applicative not available
18:25:43 <Saizan> @docs Control.Applicative
18:25:44 <lambdabot> Control.Applicative not available
18:25:47 <Saizan> @docs Control
18:25:47 <lambdabot> Control not available
18:25:57 <ricky_clarkson> He's out of control.
18:26:11 <dolio> http://darcs.haskell.org/packages/base/Control/Applicative.hs
18:26:36 <Saizan> thanks.
18:27:08 <dolio> Ah, I guess I can use WrappedMonad
18:29:51 <dolio> Ah, no I can't. :)
18:30:19 <Saizan> uuh, WrappedArrow is like generalizing the ((->) r) monad
18:30:29 <Saizan> dolio: for what?
18:31:08 <dolio> Saizan: I'm trying to bundle up the LogicT monad into a library, and want to declare all the relevant instances.
18:31:24 <dolio> But it seems there's no Applicative instance for Identity, so it can't be automatically derived.
18:31:39 <dolio> And I don't want to include the instance for Identity in the Logic library.
18:32:07 <dolio> There is an applicative instance for Monad m => WrappedMonad m, but there's no Monad instance for that. :)
18:33:08 <Saizan> a bit silly..
18:35:01 <dons> dolio: oh, we can probably surivive without Applicative Identity , but you could at least ask the mtl guys to add it
18:35:07 <dons> perhaps a libraries@ bug submission?
18:35:48 <SamB> so... where has Control.FunctorM gone?
18:35:53 <dolio> All right.
18:36:03 <dolio> SamB: Traversable
18:36:18 <SamB> dolio: no, it hasn't
18:36:21 <SamB> that isn't the same thing
18:36:22 <sorear> SamB: never was one.  Data.FunctorM disappeared to annoy John
18:36:30 <SamB> er.
18:36:31 <SamB> whatever
18:37:00 <SamB> has it been cabalized?
18:37:20 <oerjan> note that libraries@ does not accept messages from unsubscribed people.
18:37:22 <dolio> dons: It's not that we can't live without it, but it stops 'newtype Foo a = Foo { unFoo :: FooT Identity a } deriving (Applicative ...)
18:37:23 <sorear> @tell JohnMeacham Data.FunctorM won't return until you tell the world why it is still needed
18:37:23 <lambdabot> Consider it noted.
18:39:42 <SamB> sorear: what means of communication is advised?
18:40:07 <sorear> megaphone? :)
18:42:54 <oerjan> @bugs
18:42:54 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
18:43:09 <oerjan> that's where Simon Marlow pointed me
18:44:29 <dons> sorear: that's a bit hmm, rude, isn't it?
18:44:54 <dons> it would immediately put someone on the defensive, sorear. be careful
18:47:08 <dons> sorear: I recommend stongly reading http://headrush.typepad.com/creating_passionate_users/2006/12/how_to_build_a_.html
18:47:10 <lambdabot> Title: Creating Passionate Users: How to Build a User Community, Part 1, http://tinyurl.com/y2jvu5
18:47:43 <SamB> dons: so how should he complain?
18:47:58 <SamB> dons: libraries@?
18:48:45 <dons> email, yes. but explain the concerns, rather than just say "you tell the world why it is still needed"
18:49:04 <dons> since that leaves the person with no idea what the issue is, and would be considered a tad aggressive, i suspect.
18:49:36 <dons> think to yourself: What would SPJ say?
18:49:48 <SamB> "Basically, we want to know what the problem is so we can fix it ;-)."
18:49:52 <SamB> does that sound about right?
18:50:06 <dons> something about, "nice, but the use case isn't obvious. could you elaborate?"
18:50:28 <dons> which is a *much* politer way of making that point. good communication skills == harmony, happy developers, more code.
18:51:15 <dons> and pleasant , friendly communication is the hallmark of the haskell lists, so we want to actively maintain that.
18:51:20 <dons> hence, "what would SPJ say?".
18:51:35 <dons> -- follow the tone set by the community founders
18:52:15 <dons> sorear: i'd be interested in hearing what your view is here.
18:52:47 <dons> as you can tell, i'm trying to push you a bit away from "cold hacker" responses ;)
18:53:04 <SamB> P.S. sorear (stefanor) says that FunctorM won't come back until you present your complaints. libraries@haskell.org recieves library complaints, questions, and comments *very* well. Basically, we want to know what the problem is so we can fix it ;-).
18:53:19 <sorear> dons: I think it's a great idea, I feel like an idiot, I've just finished cabalizing functorm-1.0 and was about to upload it to hackage and send an ANN and @tell johnmeacham Ignore that - I had a better idea. See http://hackage.hask...
18:53:31 <SamB> that's what I have at the bottom of a draft of an email to john...
18:53:47 <dons> i'd ditch the 'stefan says it won't come back'
18:53:57 <sjanssen> wasn't FunctorM subsumed by something else?
18:54:04 <dons> since we're a community. perhaps 'stefan was wondering what the use case was, given X , Y and Z'
18:54:10 <sorear> sjanssen: john thinks it wasn't adequately
18:54:44 * dons starts the dons school for community etiquette and high tea.
18:55:02 <sjanssen> sorear: on the ML?
18:55:04 <dons> or, how not to turn into the lisp community
18:55:18 <sorear> sjanssen: ?
18:55:27 <SamB> P.S. sorear (stefanor) and dons say that we'd be interested in hearing about what FunctorM has that Control.Applicative lacks. libraries@haskell.org recieves library complaints, questions, and comments *very* well. Basically, we want to know what the problem is so we can fix it ;-).
18:56:10 <sjanssen> sorear: I was wondering whether there was a thread on a mailing list I missed
18:56:19 <sorear> sjanssen: nope.
18:56:33 <sorear> sjanssen: I was trying to get him to start it (very badly!)
18:56:56 <SamB> dons: I hope that's polite enough?
18:57:16 <dons> that's better. i'd probably phrase it differently
18:57:44 <sjanssen> ah yes, Traversable
18:58:12 <SamB> dons: well you are a different person
18:58:14 <dons> John, could you elaborate on the difference between FunctorM and
18:58:14 <dons> Control.Applicative? Since its not clear how FunctorM isn't subsumed by
18:58:15 <dons> Control.Applicative.
18:58:34 <sjanssen> dons: I think you mean Traversable?
18:58:35 <SamB> I think I expressed it clearly enough
18:58:47 <SamB> I think he'll get the hint that the other one comes into it too
18:58:51 <dons> Traversable, or what have you.
18:58:57 <SamB> he's a pretty smart guy ;-)
18:59:04 <dons> you could even point out the equivalences
18:59:19 <SamB> anyway I already sent the email...
18:59:19 <sorear> dons: what's the list for ANN:s again?
18:59:21 <SamB> so...
18:59:24 <dons> the more work done on this side, the less abrupt a rejection it appears :)
18:59:36 <dons> haskell@ and haskell-cafe@, imo.
19:00:02 <SamB> anyway, I'm hoping it sounds unlike a rejection...
19:01:27 <SamB> anyway it's a lot easier to talk about venue's once we get a thread started
19:02:40 <Saizan> btw, can you give me an example of many or some producing useful output?
19:03:22 <sorear> @tell JohnMeacham That last message was a pretty dumb idea, and I had a better one.  http://hackage.haskell.org/cgi-bin/hackage-scripts/package/functorm-1.0 (I'd still like to hear your reasons for wanting it, though)
19:03:22 <lambdabot> Consider it noted.
19:04:07 <SamB> anyway... that was a postscript on an explanation of a darcs patch
19:15:41 <shachaf> Is the "needsaname" function on the mailing list is just an unfoldr and a concat?
19:16:32 <oerjan> not quite
19:16:52 <oerjan> it doesn't stop on Nothing, it splits off the first character.
19:17:50 <shachaf> Oh, right.
19:17:57 * shachaf was going mostly by the type.
19:19:08 <oerjan> although i think you could make it using unfoldr and concat as part of the glue
19:20:08 <oerjan> and a Maybe monad composition with splitAt 1 and the given functions.
19:20:49 <oerjan> > splitAt 1 "hello" -- or 0?
19:20:51 <lambdabot>  ("h","ello")
19:21:55 <ricky_clarkson> > splitAt 10 "hello"
19:21:57 <lambdabot>  ("hello","")
19:22:11 <ricky_clarkson> Heh, that's a bit lenient.
19:22:54 <dolio> Perhaps an appropriate fmapM_ can't be defined using Traversable?
19:25:42 * SamB thinks it's funny that the same discussion group can be viewed as a mailing list, a newsgroup, or a blog
19:27:38 <dolio> Although it seems like 'fmapM_ g t = traverse ((() <$) . g) t' might do it. Or something like that.
19:27:57 <sm> funny ? it's seriously great
19:28:09 <narain> SamB: aren't they all the same thing anyway?
19:28:21 <Figs> hi
19:28:32 <Figs> could someone please tell me how to read this?
19:28:44 <Figs> main = do { b <- getLine }?
19:28:44 <SamB> nornagon: FunctorM and Control.Applicative are apparantly not suitable for all of the same things
19:28:48 * sm sacrifices a beer to Lars Magne Ingebrigtsen
19:28:53 <SamB> that's what john says, anyway
19:29:00 <Figs> probably useless, as I wrote it
19:29:10 <nornagon> SamB: orly?
19:29:14 <Figs> but I'd like to know how to read <- in that context
19:29:29 <chessguy> Figs, usually it's read as "gets" or "is drawn from"
19:29:43 <nornagon> i read it "comes from"
19:29:51 <SamB> we've been trying to get him to complain properly all week, it seems like...
19:30:26 <Figs> ok
19:31:06 <shachaf> Figs "The last statement in a 'do' construct must be an expression"
19:31:20 <Figs> yes, as said, I'm not sure if it was correct
19:31:29 <Figs> thanks
19:31:39 <Figs> I was just curious about the <-'s I was seeing
19:32:03 <chessguy> Figs, there's another sort of use for it too (though really it's the same)
19:32:18 <narain> ?hoogle a -> [[a]] -> [a]
19:32:22 <lambdabot> No matches, try a more general search
19:32:22 <Figs> you mean like [x| x<-foo]?
19:32:29 <chessguy> > [(x,y) | x <- [1..5], y <- [1..5]]
19:32:33 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(2,1),(2,2),(2,3),(2,4),(2,5),(3,1),(3,2),(3,...
19:32:37 <Figs> yeah
19:32:41 <Figs> I already know about that one
19:32:49 <Figs> I wasn't sure if it was the same or not at first
19:32:49 <chessguy> ok
19:33:00 <shachaf> > do { x <- [1..5]; y <- [1..5]; return (x,y) }
19:33:02 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(2,1),(2,2),(2,3),(2,4),(2,5),(3,1),(3,2),(3,...
19:33:28 <chessguy> Figs, ultimately, it is, but it's probably easiest not to think about it that way yet :)
19:33:59 <nornagon> shachaf: is it possible to use the list comprehension syntax for other monads?
19:34:08 <Figs> why not? input is essentially sequential, so you could think of it like a list
19:34:12 <shachaf> nornagon: Not in Haskell 98.
19:34:14 <SamB> nornagon: if you send in a patch to implement it again
19:34:14 <Figs> right?
19:34:42 <shachaf> nornagon: It used to be, as far as I understand.
19:34:52 <chessguy> Figs, you're already thinking about it wrong. in this case, it's like nondeterminism
19:35:10 <Figs> am I?
19:35:20 <chessguy> well, i don't know if it's technically "wrong", but unhelpful
19:35:21 <Figs> what do you mean 'nondeterminism'?
19:35:25 * jfredett twitches
19:35:36 <shachaf> > [1..5] >>= (\x -> [1..5] >>= (\y -> return (x,y)))
19:35:38 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(2,1),(2,2),(2,3),(2,4),(2,5),(3,1),(3,2),(3,...
19:35:39 <SamB> > do x <- "hi"; y <- "bye"; return [x,y]
19:35:41 <lambdabot>  ["hb","hy","he","ib","iy","ie"]
19:35:54 <chessguy> errmmmm, i don't suppose you have any formal language classes
19:35:58 <Figs> no
19:35:58 <jfredett> I need ... something ... to ... code...
19:36:20 <Figs> jfredett: write a haskell compiler in haskell that compiles to C.
19:36:27 <SamB> jfredett: generalized Parsec?
19:36:29 <Figs> it'll keep you busy
19:36:32 <jfredett> Figs: You, my good man, are insane.
19:36:35 <jfredett> kudos
19:36:35 <nornagon> shachaf: ah, i see
19:36:35 <Figs> :D
19:36:38 <Figs> I am ^.^
19:36:41 <jfredett> Figs++
19:36:45 <jfredett> for insanity
19:36:50 <SamB> Figs: there's one of those already, sort of
19:37:02 <SamB> but it uses too much RAM right now
19:37:18 <Figs> ah
19:37:43 <jfredett> okay, lets put a constraint on all that, something at an intermediate level, maybe some IO hacking in there, I haven't done enough of that yet.
19:37:48 <SamB> happily, that is the issue that the author is working on right now ;-)
19:38:02 <SamB> it's called JHC
19:38:12 * Figs prods chessguy
19:38:17 <Figs> nondeterminism?
19:38:19 <chessguy> ermm
19:38:30 <chessguy> i'm not coming up with a good way to explain it, off the top of my head
19:38:33 <jfredett> chessguy: trying to explain nondeterminism?
19:38:35 <jfredett> hmm
19:38:39 <SamB> have you heard of the many worlds interpretation of quantum mechanics?
19:38:50 <chessguy> heck, it's like 11 pm on a friday night, whaddya want?
19:38:51 <jfredett> Figs, do you know what a State machine is?
19:39:04 <Figs> I think so (@ SamB)
19:39:16 <SamB> Figs: the list monad is kind of like that ;-)
19:39:29 <Figs> jfredett: I think I do.
19:39:37 <jfredett> Lol, You mean you can't understand it w/o getting dizzy, SamB?
19:39:39 <jfredett> okay-
19:39:41 <Figs> been a while since I've dealt with them though.
19:39:43 <jfredett> so a recap,
19:39:50 <chessguy> Figs, ok, think of sudoku
19:39:54 <chessguy> are you familiar with that?
19:39:54 <SamB> jfredett: not exactly ;-)
19:39:58 <Figs> not at all.
19:40:01 <jfredett> a state machine has a list of things called state.
19:40:04 * chessguy sighs
19:40:04 <SamB> hah
19:40:07 <Figs> yes
19:40:09 <chessguy> you need to get out less, man!
19:40:13 <SamB> maybe you should have gone with Chess, chessguy
19:40:15 <Figs> me?
19:40:15 <sfultong> heheh
19:40:18 <jfredett> and each state has some conditions, which "point" to another state
19:40:18 <Figs> I never go out
19:40:26 * Figs hasn't been out in about 3 days
19:40:27 <narain> how's "try every possibility recursively" for nondeterminism-in-a-nutshell?
19:40:51 <sfultong> yeah, I regret the period of my teen years where I actually tried to get out rather than be intensely nerdy
19:40:51 <chessguy> narain, to sequential
19:40:55 <SamB> @google nondeterministic finite automaton
19:40:55 <Figs> gotcha jfredett
19:40:56 <chessguy> *too
19:40:56 <lambdabot> http://en.wikipedia.org/wiki/Nondeterministic_finite_automaton
19:40:56 <lambdabot> Title: Nondeterministic finite state machine - Wikipedia, the free encyclopedia
19:41:00 <Figs> I know what you're talking about
19:41:01 <jfredett> so I could be in a state of "Talking on IRC", but if my girlfriend calls
19:41:17 <jfredett> thats a function which would put me in a state of "Talking to my g/f"
19:41:25 <jfredett> so- what happens if I'm in a state
19:41:36 <SamB> Figs: that might be faster than waiting for us to make sense ;-)
19:41:46 <jfredett> and I have two ways to get out of the state, with the same info?
19:41:56 <narain> chessguy: i didn't say try them one at a time, did i? :)
19:42:19 <Saizan> Figs: if you consider a function f :: a -> b to be deterministc because for every a you give it, f gives you only one b, then g :: a -> [b] is non-deterministc, because for every input you get many possible results
19:42:20 <jfredett> that is- what if I get a input that says "Go downstairs" and at the same time says "Go upstairs?"
19:42:30 <chessguy> narain, no, but it's automatically assumed by the unenlightened brain :)
19:42:37 <jfredett> vis a vis, how can I _determine_ what to do?
19:42:50 <jfredett> I'm in a non-deterministic system.
19:42:54 <jfredett> follow?
19:42:56 <SamB_XP> jfredett: clearly, you must clone yourself before proceding
19:43:00 <SamB_XP> or better, the universe
19:43:05 <jfredett> SamB_XP, that would work
19:43:16 <jfredett> but I prefer Superposition, rather than Manyworlds
19:43:30 <Figs> mmm
19:43:33 <chessguy> jfredett, yeah, but why would your girflriend call you just to tell you to go upstairs and go downstairs....wait, that sounds like something my fiancee would do...
19:43:36 <Figs> ok
19:43:44 <Figs> haha
19:43:47 <SamB_XP> hehehehe
19:43:51 <jfredett> chessguy: see, my analogy works hardcore
19:43:53 <jfredett> :)
19:43:54 <Figs> I don't see how it relates to <- though
19:44:10 <jfredett> well- i was just aiming to explain nondeterminism in general
19:44:14 <jfredett> I don't know what the problem is
19:44:39 <Figs> chessguy said <- was like nondeterminism
19:44:43 <Figs> IIRC
19:44:45 <SamB_XP> in the list monad, yes
19:44:52 <SamB_XP> and in some others
19:44:52 <chessguy> only in the case of a list
19:45:00 <chessguy> err, others?
19:45:06 <Figs> ah, ok, I think I think I'm getting it
19:45:10 <SamB_XP> related ones ;-)
19:45:21 <Figs> it seems easier to think about it like a sequence though
19:45:23 <jfredett> in [x | x<-[1..5]] context? or in do's?
19:45:29 <chessguy> > do { x <- [1,2,3]; y <- [2,3,4]; guard x*y == 8; return (x,y) }
19:45:33 <jfredett> (althought afaik they're the same)
19:45:34 <Figs> we were talking about both
19:45:35 <SamB_XP> say... oh... StateT Int [] ?
19:45:36 <lambdabot>  Couldn't match expected type `[t]' against inferred type `Bool'
19:45:48 <chessguy> eh?
19:45:59 <jfredett> right so <- is like nondeterminism in that
19:46:02 <chessguy> > do { x <- [1,2,3]; y <- [2,3,4]; guard (x*y == 8); return (x,y) }
19:46:05 <lambdabot>  [(2,4)]
19:46:06 <chessguy> ok
19:46:11 <jfredett> it doesn't matter what x is at any given point
19:46:20 <jfredett> we just know it'll be one of the list [1..5]
19:46:21 <Saizan> Figs: <- is not necessarily tied with the notion of a sequence, it just get the value out of your monad (or give the illusion of)
19:46:28 <jfredett> in my example
19:46:34 <Cale> Out of you computation
19:46:35 <jfredett> i dont know what state I'll choose
19:46:36 <Cale> your*
19:46:47 <chessguy> jfredett, so here, since we're in the list monad (that is, there are lists on the right side of the <-'s, x and y are chosen, nondeterministically to fit the guard condition
19:46:50 <jfredett> but I know that it'll be one of "go upstairs" or "go downstairs"
19:46:53 <Cale> (monads are not values, they're type constructors)
19:47:22 <Figs> ok
19:47:23 <jfredett> and I _wont_ be in the condition of "Talking on IRC"
19:47:38 <narain> > do {x <- [1..3]; y <- [2..4]; guard (x+y == 4); return (x,y)}
19:47:40 <lambdabot>  [(1,3),(2,2)]
19:47:44 <Saizan> (right, ..well it takes it out of the type contructor as well)
19:47:49 <jfredett> the "guard" condition then acts as a way to weed out things which definitely wont happen
19:47:56 <Cale> er
19:48:33 <jfredett> anyway, I'll BRB
19:48:35 <Figs> hmm
19:48:39 <Figs> ok
19:48:40 <jfredett> I'm getting a state transition call now
19:48:42 <jre2> could anyone tell me why in function start on http://sequence.complete.org/node/258 he can call atomically newTChan but newTVar wouldn't work?
19:48:42 <narain> ?src guard -- no magic in there, either
19:48:42 <lambdabot> Source not found. That's something I cannot allow to happen.
19:48:43 <lambdabot> Title: A simple TCP server | The Haskell Sequence
19:48:52 <chessguy> jfredett, try not to go too insane
19:49:01 <chessguy> @src guard
19:49:02 <jfredett> ahh! nondeterminism!
19:49:02 <lambdabot> guard True  =  return ()
19:49:02 <lambdabot> guard False =  mzero
19:49:24 <narain> aww, no comments allowed in src?
19:49:27 <Cale> jre2: because he wants a TChan and not a TVar?
19:49:39 <SamB_XP> @src [] return
19:49:39 <lambdabot> return x    = [x]
19:49:46 <SamB_XP> @src [] (>>=)
19:49:46 <jre2> Cale: in my case I need a TVar ;)
19:49:46 <lambdabot> m >>= k     = foldr ((++) . k) [] m
19:49:59 <Figs> ok, this would be more useful if you could show me an example where it doesn't help to think about lists
19:50:01 <chessguy> @src concatmap
19:50:01 <lambdabot> Source not found. The more you drive -- the dumber you get.
19:50:06 <chessguy> @src concatMap
19:50:06 <lambdabot> concatMap f = foldr ((++) . f) []
19:50:10 <Cale> jre2: There's really no reason that atomically (newTVar 0) or something shouldn't work.
19:50:13 <shachaf> m >>= k = concat (map k m)
19:50:25 <narain> why is concatMap not defined as a combination of concat and map?
19:50:29 <narain> efficiency?
19:50:35 <SamB_XP> narain: yeah
19:50:42 <SamB_XP> that's why it's defined at all!
19:50:49 <narain> ohhh
19:50:56 <SamB_XP> that, and it saves a pair of parens, two spaces, and a dot
19:51:09 <jre2> Cale: hmm, for some reason I thought you needed a newTVarIO in those cases
19:51:27 <Figs> hehe, it'd be funny to have a functional language with *no* parenthesis at all, just to poke fun at Lisp
19:51:30 <Cale> jre2: You only really need newTVarIO if you're doing something evil.
19:51:45 <Cale> jre2: (namely, creating top-level mutable state)
19:52:04 <shachaf> SamB_XP: Do you mean (concat . map)?
19:52:07 <SamB_XP> Figs: unlambda isn't purely functional, but it does have no parens
19:52:09 <narain> Figs: how'd you write, say, (x+y)^2 then? *indentation*??
19:52:12 <SamB_XP> shachaf: actually no
19:52:13 * Figs gets shot at by the zealots
19:52:28 <Figs> I didn't say it had to be practical ;)
19:52:29 <narain> SamB_XP: ah, that
19:52:32 <sorear> Figs: Have you seen J?
19:52:34 <Figs> no
19:52:44 <SamB_XP> Figs: have you seen unlambda?
19:52:47 * narain wants to write dense math expressions using indentation
19:52:48 <sorear> From what I hear, it's purely functional and RPN.
19:52:51 <shachaf> SamB_XP: How else would you write it with only "()  ."?
19:52:51 <SamB_XP> it's *very* impractical
19:52:51 <Figs> maybe, but unlikely
19:53:02 <sfultong> what do people think of Joy?
19:53:10 <shachaf> J is RPN?
19:53:13 <Figs> narain: ^+ x y 2, btw
19:53:29 <sorear> shachaf: From what I hear.  Reality may disagree
19:53:39 <SamB_XP> instead of concatMap f, you'd have to write (concat . map f)
19:53:58 <sfultong> J == Joy?
19:54:04 <shachaf> SamB_XP: Oh.
19:54:05 <narain> Figs: ok ok, i should know better than to shoot my mouth off in #haskell
19:54:18 <Figs> :P, but eh, I was just joking
19:54:34 <SamB_XP> narain: have you heard of whitespace?
19:54:37 <Cale> :t (concat .) . map
19:54:39 <lambdabot> forall a a1. (a1 -> [a]) -> [a1] -> [a]
19:54:47 <jfredett> j /= joy
19:54:53 <sfultong> ah
19:54:54 <Figs> whoo hoo! let's overload whitespace!
19:54:57 <jre2> Cale: forgive my ignorance, but by top-level do you mean in main (as in the 'top-level io monad') or literally outside of any function in the module?
19:55:09 <jfredett> j is the new APL.
19:55:11 <narain> SamB_XP: yeah, but i assumed it was a bf-like language
19:55:17 <SamB_XP> they make some claims about the difficulty of detecting whitespace programs on pieces of paper, on the website
19:55:24 <SamB_XP> narain: oh, it probably is ;-)
19:55:41 <narain> right, how much can you encode with just three or four tokens?
19:55:48 <jfredett> lots
19:55:50 <Cale> jre2: I mean using unsafePerformIO to define a variable as a TVar at the top level, outside of IO.
19:55:52 <sorear> iota!
19:55:56 <SamB_XP> well they use some kind of huffman-ish coding
19:56:10 <jfredett> sorear++ for mentioning my favorite combinator ever
19:56:19 <jre2> Cale: ah, my mistake then. thanks
19:56:26 <Cale> jre2: Which is really not something you're even supposed to want to do, but some people seem to complain about it if they can't.
19:56:30 * Figs 's brain has long since stopped comprehending what people are talking about here.
19:56:43 <jfredett> join the club, figs my boy
19:56:49 <Figs> hehe ;D
19:56:54 <jfredett> its okay not to comprehend #haskell
19:56:56 <jfredett> its like zen
19:56:59 <Figs> as long as I don't have to go through initiation
19:57:01 <sfultong> yeah, I'm here hoping to pick up a clue
19:57:02 <jfredett> your not supposed to understand it
19:57:04 <Figs> or pay a membership fee
19:57:08 <jfredett> your just supposed to let it be
19:57:10 <jfredett> Mu.
19:57:23 <Figs> Let it be! Let it be! Mother mary comes to me, let it be!...
19:57:26 <SamB_XP> Figs: we don't expect newbies to make their library quotas, no ;-)
19:57:45 * SamB_XP isn't expecting to make his either
19:57:56 <jfredett> Letter B, Letter B, Mrs. Betty's name has a B, Letter B.
19:57:57 * chessguy hands Figs a brain-comprehension monad
19:58:06 <sfultong> yeah, it seems like an intimidating proportion of people here are writing their own libraries
19:58:10 <Figs> :P
19:58:11 <araujo> hello
19:58:23 <Figs> I've written a couple C++ librareis
19:58:26 <SamB_XP> sfultong: intimidating?
19:58:31 <araujo> how do i get darcs to preserve the permissions of a file?
19:58:32 <Figs> and I can't even type it right today :P
19:58:34 <Figs> libraries*
19:58:36 <pjd> an intimidating proportion of people here are writing their own *paradigms*
19:58:37 <SamB_XP> I'd write one if I knew which one to write
19:58:46 <jfredett> On that note, Figs, have you read Godel Escher and Bach? I find it helps people to accept that there are somethings which will completely blow your mind for the rest of your life.
19:58:47 <sfultong> pjd: heheh, yeah
19:58:52 <SamB_XP> but I suppose that's the hard part
19:59:05 <Figs> no, I haven't
19:59:13 <jfredett> you should, its wicked good
19:59:13 <sfultong> I gotta read that book sometime
19:59:14 <Cale> jfredett: you're
19:59:22 <Figs> I have a lot I should read :P
19:59:25 <Cale> (not in your last line)
19:59:26 <sorear> araujo: you don't, darcs doesn't support that :(
19:59:26 * Figs needs to start making a list
19:59:27 <narain> jfredett: i got that feeling when i heard that quantum mechanics and category theory were related.
19:59:33 <Saizan> SamB_XP: nah, the hard part is to get the API right
19:59:42 <dons> @tell glguy ok, done with benchmarking (reasonable, 2-3x ghc's decoder). and with docs. go for it.
19:59:42 <lambdabot> Consider it noted.
19:59:42 <jfredett> Cale: Mu.
19:59:42 <jfredett> lol
19:59:42 <jfredett> GEB should be first on that list.
19:59:54 <SamB_XP> Saizan: I consider that an important part of "which library to write"
19:59:55 <Cale> I agree, GEB is an awesome book.
19:59:58 <Figs> Mu? Moo! (err, what?)
20:00:00 <araujo> sorear, ouch :-(
20:00:06 <sorear> jfredett: uhm, what about GEB is supposed to tell me some things will blow my mind?
20:00:09 <SamB_XP> I suppose I could just try to generalize Parsec...
20:00:25 <sorear> araujo: darcs get --set-scripts-executable is maybe what you want?
20:00:29 <SamB_XP> sorear: well, some things will escape you anyway
20:00:33 <araujo> sorear, yeah!
20:00:36 <araujo> thanks sorear
20:00:46 <jfredett> narain: I got that feeling when I found that Math and Quantum Mechanics were related. I thought QM was a bunch of fairy tales Einsteins mom told him to scare him into cleaning his room.
20:00:48 <SamB_XP> you can never understand yourself completely unless you are an infinite being
20:00:57 <jfredett> sorear: what isn't it supposed to tell you?
20:01:16 <jfredett> sorear: that part must have been the part that silently blew your mind. :P
20:01:18 <sfultong> SamB_XP: yes! I have often thought that
20:01:22 <Figs> hehe, I read the other day that black holes might not actually exist
20:01:25 <sorear> SamB_XP: no ordinal number is greater than itself
20:01:37 <Figs> and that the universe probably didn't start in a singularity
20:01:47 <SamB_XP> sorear: hmm?
20:01:47 <jfredett> Figs: Time Cube?
20:01:48 <chessguy> Figs, where'd you read that, on wikipedia?
20:01:52 <Figs> No :P
20:01:59 <Figs> badastronomy among other places
20:02:03 <jfredett> and Btw, Figs, Mu is from GEB.
20:02:12 <SamB_XP> are you trying to claim that infinite beings cannot completely understand themselves either?
20:02:16 * chessguy hholds up a sign saying "Citation Needed"
20:02:17 <sorear> yes.
20:02:17 <jfredett> read it to understand, or i guess ununderstand
20:02:37 <SamB_XP> I'll play the hilbert hotel on you
20:02:41 <jfredett> SamB_XP: don't wave that ID around here, it stinks
20:02:44 <chessguy> (xkcd ftw!)
20:02:51 <Figs> like this one?
20:02:51 <Figs> http://xkcd.com/c285.html
20:02:52 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
20:03:01 * Figs prods chessguy to look
20:03:01 <jfredett> <3 xkcd
20:03:06 <chessguy> mmhmm
20:03:23 <SamB_XP> sorear: so, how do you respond to my hilbert hotel?
20:03:29 <Figs> I'll look for the links again
20:03:51 <narain> SamB_XP: perhaps he'll play the cardinal /= ordinal on you
20:03:56 * chessguy sees SamB_XP's hilbert hotel and raises him a Russell's paradox
20:03:59 * jfredett throws his Diagonal Argument into the SamB_XP/sorear game
20:04:01 * shachaf thought J was APL-ish. APL isn't RPN, is it?
20:04:09 * jfredett ducks
20:04:14 <Figs> http://space.newscientist.com/article.ns?id=dn12089 <-- black hole existance
20:04:17 <lambdabot> Title: Do black holes really exist? - space - 18 June 2007 - New Scientist Space
20:04:17 <jfredett> J is APLish, and its not RPN
20:04:27 <pjd> yeah, Joy is completely separate
20:04:33 <sfultong> I think that if God is omnipotent then God >= the universe, which to me implies God == universe, which in turn implies that God is unaware of itself
20:04:35 <jfredett> J /= Joy.
20:04:43 <pjd> (was Factor mentioned yet?)
20:04:53 <jfredett> Yes, just a second ago
20:04:53 <Figs> http://www.badastronomy.com/bablog/2007/07/01/what-happened-before-the-big-bang/
20:04:55 <jfredett> by you.
20:04:56 <SamB_XP> all I'm saying is that no matter how much of an infinite mind it takes to understand a certain amount of an infinte mind, there will be enough of the infinite mind to handle it.
20:04:59 <lambdabot> Title: Bad Astronomy Blog ª What happened before the Big Bang?, http://tinyurl.com/2brkrj
20:05:23 <SamB_XP> just as you can handle the number of visitors being multiplied by n in a hilbert hotel
20:05:33 <narain> SamB_XP: but what if it takes an uncountably infinite mind to understand a countable mind?
20:05:50 <monochrom> I read on the web that "understanding" does not exist.
20:05:53 <Figs> SamB_XP: now you're going to have to specify *how* infinite :)
20:06:05 <narain> * countably infinite
20:06:14 * jfredett twitches and dies, whispering "infinity overload, flux capacitor, destructivated..."
20:06:43 <SamB_XP> you have me there. so I'm assuming that there is a certain ratio between the piece of mind that understands another piece of mind and that other piece of mind
20:06:44 <Figs> http://ohgizmo.com/2006/05/04/great-scott-flux-capacitor-for-sale/
20:06:46 <lambdabot> Title: OhGizmo! ª Archive ª Great Scott! - Flux Capacitor For Sale, http://tinyurl.com/3b7clk
20:06:49 <sfultong> I've always had trouble with the idea of countability
20:06:54 <Figs> you might need that then jfredett ;)
20:07:16 * jfredett 's gears whirr
20:07:20 <Figs> sfultong: why? other than the fact it's weird?
20:07:24 <narain> SamB_XP: if it involves power sets you're outta luck
20:07:32 <SamB_XP> narain: quite so.
20:07:47 <SamB_XP> I'm assuming that understanding minds is O(n) in the size of the mind understood
20:07:51 <jfredett> Figs: by flux capacitor, I of course meant spoon
20:07:57 <jfredett> not flux capacitor
20:08:21 <sfultong> figs: well, I guess I'm not aware of the utility of making infinities ordinal
20:08:29 <SamB_XP> jfredett: but... there *is* no spoon!
20:08:43 <jfredett> SamB_XP: In some universe, there is.
20:08:44 <narain> yeah. cause it's been destructivated.
20:08:47 <monochrom> There is no infinite.
20:08:57 <sfultong> there is no spoon because there is no mind
20:08:58 <jfredett> monochrom: There is no monochrom
20:09:01 <sorear> All E's are finite.
20:09:16 <narain> 1 - 2 + 3 - 4 + ... = 1/4
20:09:17 <Figs> monochrom: then how many integers are there in the sequence 0, 1, 2 ...?
20:09:29 <monochrom> 3.
20:09:37 <narain> hahahaha
20:09:38 <Figs> the sequence defined by that pattern :P
20:09:52 * SamB_XP converts [1..] to an E
20:09:54 <monochrom> What pattern?
20:10:00 <narain> what's an E?
20:10:03 * SamB_XP watches JHC explode. it looks kind of normal, actually.
20:10:04 <sorear> Figs: The length of that sequence is _|_
20:10:22 <mauke> writing CPS-style code is so ugly without >>= or do notation :(
20:10:27 <jfredett> aah, Bottom!
20:10:27 <Figs> Oh? I thought it was only ||_||
20:10:32 <Figs> :P
20:10:36 <sorear> mauke: eh?
20:10:40 <Figs> or does that actually mean something?
20:10:49 <sorear> operation $ \value ->  looks perfectly natural to me
20:10:53 <dons> ?uptime
20:10:53 <lambdabot> uptime: 2d 3h 9m 54s, longest uptime: 1m 10d 23h 44m 29s
20:10:56 <dons> ?uers
20:10:56 <lambdabot> Maximum users seen in #haskell: 354, currently: 297 (83.9%), active: 21 (7.1%)
20:10:58 <shachaf> @wiki Bottom
20:10:59 <lambdabot> http://www.haskell.org/haskellwiki/Bottom
20:10:59 <narain> Figs: it represents the result of a nonterminating computation
20:11:00 <mauke> sorear: now do it in Perl
20:11:00 <SamB_XP> _|_ is a fancy way of saying nothing ;-)
20:11:05 <SamB_XP> essentially
20:11:20 <monochrom> nothing is hardly infinite
20:11:22 <dons> bos, utf8 [Char] IO, fwiw. code.haskell.org/utf8-string
20:11:23 <narain> also it looks good in parentheses
20:11:33 <dons> @tell bos utf8 [Char] IO, fwiw. code.haskell.org/utf8-string
20:11:33 <lambdabot> Consider it noted.
20:11:35 <SamB_XP> @quote (_|_)
20:11:35 <lambdabot> nmessenger says: (_|_) <-- haha look at my bottom!
20:11:36 <sorear> ‚ä•
20:11:45 <sfultong> heh
20:11:46 <Figs> haha -.-
20:11:51 <monochrom> "I promise to get to the bottom of it."
20:11:51 <SamB_XP> sorear: you're so tricked out for a console dweller ;-)
20:12:20 <chessguy> @quote bottom
20:12:21 <lambdabot> xerox says: I am really interested specifically in bottoms in this very moment.
20:12:29 <dolio> mauke: Is CPS really the culprit there? :)
20:12:47 <Figs> do we have a ggl?
20:12:49 <mauke> dolio: no, it's KDE/dcop
20:12:51 <Figs> @ggl foobar
20:12:51 <lambdabot> Maybe you meant: ghc pl url
20:12:57 <monochrom> monad is always nice.
20:13:00 <chessguy> @go foobar
20:13:03 <lambdabot> http://www.foobar2000.org/
20:13:03 <lambdabot> Title: foobar2000
20:13:04 <Figs> thanks
20:13:11 * Figs is lazy
20:13:21 * Figs is only evaluated when he needs to be :P
20:13:32 * sorear knows everything
20:13:32 <Figs> Damn you doctors! Keep your fingers off me!
20:13:38 <Figs> :P
20:13:41 <shachaf> SamB_XP: What is a "console dweller"?
20:13:47 * sorear 's memories are lazily evaluated
20:14:00 <SamB_XP> shachaf: well, he doesn't use X much
20:14:06 <monochrom> We need a lazily written encyclopedia
20:14:21 <SamB_XP> you mean like wikipedia with more stubs?
20:14:27 <monochrom> Yeah!
20:14:29 <sorear> SamB_XP: Eh? http://members.cox.net/stefanor/1183778023.png
20:14:31 <shachaf> I thought sorear ran X all the time now?
20:14:37 <mauke> "This article is a thunk."
20:14:44 <sorear> shachaf: No, only during the day.
20:14:45 <narain> the stubs magically get filled in as soon as you try to read them?
20:14:47 <SamB_XP> sorear: what you got a monitor and didn't tell me?
20:15:16 <Figs> whoo! I'm talking in black and white
20:15:35 <sorear> narain: but then googlebot would cause massive space leaks
20:15:40 <monochrom> "..." is not referentially transparent.
20:15:52 <shachaf> Figs: What other colors would you talk in?
20:16:00 <Figs> white and black.
20:16:01 <Figs> :P
20:16:21 <narain> sorear: ah. the solution is garbage collection
20:16:24 <SamB_XP> Figs: why would you talk in those colors?
20:16:30 <SamB_XP> narain: how does that help?
20:16:32 <Figs> now is that lack of associativity, commutibility, or both?
20:16:34 <SamB_XP> does it reset CAFs?
20:16:36 <shachaf> sorear: How do you make your screenshots?
20:16:36 <jfredett> "pipe", ceci nes pas une pipe.
20:16:40 <sorear> narain: that doesn't work for lazy encyclopedias
20:16:41 <oerjan> > let chars = [minBound..maxBound] :: String; infMonkeys = map (:[]) chars ++ liftM2 (:) chars infMonkeys
20:16:41 <lambdabot>  Parse error
20:16:45 <narain> the space usage goes away when googlebot leaves?
20:16:47 <jfredett> err, s/nes/n'est/
20:16:48 <monochrom> commutativity.
20:16:49 <sorear> shachaf: http://members.cox.net/stefanor/snap
20:17:07 <sorear> it's completely automated.  type snap -root, copy the URL
20:17:16 <oerjan> > let chars = [minBound..maxBound] :: String; infMonkeys = map (:[]) chars ++ liftM2 (:) chars infMonkeys in infMonkeys
20:17:18 <lambdabot>  ["\NUL","\SOH","\STX","\ETX","\EOT","\ENQ","\ACK","\a","\b","\t","\n","\v","...
20:17:19 * sorear <3 scriptable OSes
20:17:23 <shachaf> Oh.
20:17:29 * Figs decides to speak in purple, green, and polka-dot from now on
20:17:37 <oerjan> there's your lazy encyclopedia
20:17:45 <SamB_XP> Figs: I don't think there is a mIRC color for polkadot
20:17:59 <Figs> no? damned be ye villians!
20:18:02 * monochrom kisses oerjan
20:18:03 <Figs> stealing my dots
20:18:12 <Figs> :'(
20:18:27 <narain> ah, infinite robot ninja monkeys
20:18:41 <Figs> oerjan: did you used to have a jet or spacecraft as an avatar on a forum a long time ago?
20:18:50 <Figs> your name sounds too familiar
20:18:55 <Figs> and it's been bugging the hell out of me :P
20:19:09 <oerjan> Figs: no.
20:19:30 <oerjan> well, it is a relatively common first name in Norway and Sweden
20:19:34 <Figs> ah
20:19:49 * Figs didn't know that
20:20:43 <shachaf> Why do you use xwd | xwdtopnm | pnmtopng instead of import -window root?
20:21:39 <narain> oerjan: does the "oe" represent the character that looks like an o with a slash through it? just curious
20:21:42 <Figs> are there any operators which cannot be expressed gramatically as the combination and transformation of multiple unary and binary operators on a arbitrarily large, but finite number of types?
20:22:01 <SamB_XP> what package is xwd in ?
20:22:08 <jfredett> hmm, whats a good book on AI in Haskell?
20:22:23 <jfredett> I think I might try to write something for Checkers, something simple.
20:22:36 <monochrom> There is none.
20:22:42 <jfredett> :(
20:22:44 <shachaf> SamB_XP: xwd is in the package "xwd". :-)
20:22:54 <jfredett> thats sad. i'll have to write one someday.
20:23:01 <jfredett> i guess I'll just wing it
20:23:02 <sfultong> SamB_XP: what are you running?
20:23:04 <SamB_XP> ah.
20:23:14 <SamB_XP> I'm assuming import is in imagemagic?
20:23:16 <monochrom> There is a recent paper on constraint satisfaction in Haskell.
20:23:48 <shachaf> SamB_XP: Yes.
20:24:12 <SamB_XP> yeah, I don't think anyone else could get away with such generic names...
20:24:55 <oerjan> narain: yes
20:25:28 <dons> there's been some AI papers
20:25:33 <narain> ah. i often wish for a unicode keyboard
20:25:48 <shachaf> SamB_XP: "convert", "identify", "composite", "montage", "compare", "display", "animate", "import", "conjure"... Yes, that's pretty generic.
20:25:52 <sfultong> unicode keyboard? that's a scary thought...
20:26:18 <dolio> !paste
20:26:18 <hpaste> Haskell paste bin: http://hpaste.org/
20:26:21 <narain> sfultong: well, a streamlined way to enter unicode characters rather
20:26:34 <sfultong> I'm just waiting for a Brain/Computer interface
20:26:38 <sorear> narain: /who oerjan
20:26:39 <narain> sorear: what did you use to enter that bottom character?
20:26:43 <jfredett> sfultong: ditto
20:26:53 <sorear> narain: urxvt, Control-Shift-22A5
20:27:15 <narain> you have code points memorized
20:27:16 <narain> ?
20:27:25 <monochrom> You can enter UTF8 directly, you know? :)
20:27:31 <sfultong> heheh
20:27:34 <SamB_XP> narain: they are shorter than names
20:27:45 <narain> yes, but there are so many of them
20:27:48 <sorear> narain: Only some of them.  I don't use many
20:28:35 <SamB_XP> wowee
20:28:50 <narain> what if i am overcome by the urge to enter the LEFT-POINTING DECORATIVE FLORIN character?
20:28:51 <SamB_XP> I have a whole two input methods in x-chat for Windows ;-)
20:29:03 <sorear> 3BB Œª 39B Œõ F6 √∂ 2200 ‚àÄ 2203 ‚àÉ 22C3 2192 ‚Üí 3B2 Œ≤ 22A5 ‚ä•
20:29:20 <narain> i must have tab completion of unicode character names
20:29:22 <sorear> those are the ones I have on my note-file :)
20:29:29 <SamB_XP> sad sad
20:29:36 <SamB_XP> it doesn't see the forall or exists
20:29:49 <sorear> SamB_XP: How do you know?
20:29:53 <sorear> SamB_XP: I didn't give names
20:30:02 <SamB_XP> I looked at my Debian machine to compare
20:30:11 <sorear> oh, hehe
20:30:12 <narain> i dont see 22c3
20:30:15 <narain> :(
20:30:20 <SamB_XP> narain: me either
20:30:23 <sorear> narain: It's not there.
20:30:23 <sfultong> neither do I
20:30:33 <SamB_XP> that was my suspicion
20:30:39 * shachaf types ctrl-alt-y, unic regexp, double-click, middle click for unicode he doesn't know.
20:30:40 <narain> bah
20:31:14 <sorear> @type Data.Eq.equating
20:31:17 <lambdabot> Not in scope: `Data.Eq.equating'
20:31:29 <SamB_XP> too bad I cant enter #char 2 white on blue
20:31:31 <monochrom> 22C3 is ‚ãÉ "n-ary union"
20:31:38 <sorear> @hoogle (a -> b) -> a -> a -> Bool
20:31:38 <lambdabot> No matches, try a more general search
20:31:44 <dolio> http://paste.lisp.org/display/44084
20:31:46 <sorear> @docs Data.Eq
20:31:46 <lambdabot> Data.Eq not available
20:31:50 <sorear> @seen shapr
20:31:50 <lambdabot> shapr is in #haskell-blah, #haskell and #scannedinavian. I last heard shapr speak 6h 58m 37s ago.
20:32:11 <SamB_XP> how is n-ary union different-looking from ordinary union?
20:32:28 <dolio> It's like the difference between sigma-notation and +.
20:32:30 <Figs> did I miss the answer to my reply?
20:32:35 <Figs> I stepped away for a second
20:32:42 <sorear> Figs: which was it?
20:32:51 <shachaf> If I use a GTK app for something, I can use SCIM with LaTeX-style character input.
20:32:54 <Figs> about unary and binary operators
20:33:01 <monochrom> ordinary union ‚à™ n-ary union ‚ãÉ   ideally a good font should make the latter look very large.
20:33:05 <sorear> Figs: I saw it, didn't understand it
20:33:23 <shachaf> Union: ‚à™. N-ary union: ‚ãÉ
20:33:26 <SamB_XP> the latter looks like a tiny rectangle here ;-)
20:33:26 <dolio> Oh, I answered the wrong question. :)
20:33:32 <shachaf> Oh, never mind.
20:33:32 <sorear> what's the opererator like Comparing but for Eq called?
20:33:34 <Figs> basically, I'm asking is there any need for a ternary operator except for efficiency?
20:33:50 <monochrom> Anyway the codepoints are 222A and 22C3 respectively.
20:34:10 <sorear> Figs: You can get away with zenary operators (constants) and on binary operator (application)
20:34:28 <sorear> Figs: Or less, if you're willing to do deep hackery
20:34:30 <dolio> sorear: I don't think there is one. It'd be 'on (==)'.
20:34:36 <Figs> ie, is there anything that can't be viewed as a transformation of overloaded unary and binary operators?
20:34:38 <sorear> @google Functional pearl typed LR parsing
20:34:40 <lambdabot> http://www.informatik.uni-bonn.de/~ralf/publications/Quote.pdf
20:34:49 <sorear> yeah, that
20:35:14 <narain> :t on
20:35:16 <lambdabot> Not in scope: `on'
20:35:28 <narain> what's 'on (==)'?
20:35:36 <shachaf> @src on
20:35:36 <lambdabot> (*) `on` f = \x y -> f x * f y
20:35:38 <oerjan> Figs: are you aware of combinatory SKI calculus?
20:35:42 <Figs> no
20:35:47 <narain> ?index on
20:35:47 <lambdabot> bzzt
20:35:53 <SamB_XP> its more fun than skifree
20:36:29 <shachaf> Why is it called "SKI"?
20:36:30 <ttmrichter> How do I get the "haskell98" package to be not hidden in a Cabal project?  I'm trying to make an executable.  The executable uses System.getArgs.  It complains that System is in the package haskell98 which is hidden.  But haskell98 is in the build-depends entry of my .cabal file.
20:36:49 <SamB_XP> -package haskell98
20:36:53 <SamB_XP> er.
20:36:56 <SamB_XP> cabal project?
20:36:56 <oerjan> you have S x y z = x z (y z), K x y = x, and application.  That gives you everything.  I x = x is redundant, since I = S K K.
20:37:01 <ttmrichter> Yes.  Cabal.
20:37:09 <SamB_XP> add it to the list of packages yours needs
20:37:14 <ttmrichter> I did.
20:37:21 <SamB_XP> oh.
20:37:24 <ttmrichter> build-depends: base, haskell98
20:37:30 <ttmrichter> It claims that it's hidden nonetheless.
20:37:30 <SamB_XP> rerun ./setup configure?
20:37:54 * ttmrichter thought I did that "but could have overlooked -- let me check."
20:38:14 <sorear> woo!  my djinn-a-like just proved K
20:39:00 <ttmrichter> OK, that was it, SamB_XP.  I did do it before, but there was an error in the .cabal I overlooked while typing on autopilot.
20:39:34 * SamB_XP wishes it wasn't necessary to do all those steps one by one
20:45:19 <sorear> @users
20:45:19 <lambdabot> Maximum users seen in #haskell: 354, currently: 296 (83.6%), active: 15 (5.1%)
20:47:39 <Figs> is there a way in haskell to define a function taking any number of parameters?
20:47:57 <dons> yeah. but its very rarely used
20:48:03 <edwardk> hrmm, what would be the right way to build a cabal package that had user options like --with-gnu-readline or --with-libedit or something like that
20:48:05 <dons> :t printf -- is an interesting exception to the rule
20:48:09 <lambdabot> forall r. (PrintfType r) => String -> r
20:48:16 <monochrom> If you use typeclass hackery, yes. Oleg has one.
20:48:19 <dons> > printf "%c" 'x'
20:48:19 <shachaf> dons: How did you decide #haskell was bigger than the other channels? Number of users?
20:48:20 <lambdabot>  Add a type signature
20:48:28 <dons> > printf "%c %s %c" 'x' "foo" 'y'
20:48:29 <lambdabot>  Add a type signature
20:48:30 <dons> shachaf: yep.
20:48:36 <dons> > printf "%c %s %c" 'x' "foo" 'y' :: String
20:48:38 <lambdabot>  "x foo y"
20:48:46 <dons> ?where stats
20:48:46 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
20:48:48 <dons> shachaf: 66
20:48:50 <sorear> dons: it's kinda unfair to compare #haskell against #java
20:48:54 <dons> i know.
20:48:54 <monochrom> I guess Text.Printf is easier to understand.
20:49:11 <shachaf> dons: You should've checked #ruby-lang -- it's the official channel.
20:49:27 <dons> i think there's a reasonable argument to make that haskell is the center of FP now, or getting close.
20:49:44 <dons> shachaf: yeah, #php, #perl, #C, #C++, #ruby-lang and #python are bigger
20:49:46 <sorear> dons: You should've checked ##java.  channels starting with one # are reserved for channels blessed by the language creators
20:49:48 <monochrom> size(#haskell)/size(haskell users) > size(#java)/size(java users)  is my bet.
20:50:11 <monochrom> Is there ##haskell?
20:50:16 * monochrom tries
20:50:20 <dons> the lisp guys are hardly even part of the FP community these days
20:50:28 <dons> that group of languages begins at Scheme now
20:50:36 <monochrom> OK it was empty. :)
20:51:43 <crazy_code2> hello everyone
20:52:12 <Cale> hello
20:52:46 <edwardk> yeah person i can think of on irc that is a die-hard lisper is pkhoung
20:52:47 <Figs> hello!
20:52:55 <Figs> goodbye...
20:53:00 <crazy_code2> In one of the books I was reading, they said that we can have data constructors as 1,2,3,4 etc.   but if we can't have data constructors as 'a', 'b','c'....... Didn't understand why ?
20:53:01 <Figs> you say hello, and I say goodbye...
20:53:37 <Cale> crazy_code2: We can't really have 1,2,3,... etc as data constructors, but you can think of them that way if you want.
20:53:39 <dons> crazy_code2: numeric literals are overloaded, you mean, crazy_code2 ?
20:53:45 <Cale> Same goes for characters.
20:54:07 <crazy_code2> They were actually demonstrating the basic implementation of Int and Char
20:54:20 <dons> in that, you can implement your own type, add it to the Num class, then the numeric literals can be used as synonyms for your numeric type
20:54:25 <crazy_code2> So data Int | 1 |2 |3 .. is fine
20:54:39 <Cale> crazy_code2: actually, that's not real Haskell.
20:54:49 <crazy_code2> But data Char = 'a'|'b'|'c'...... is not correct
20:55:06 <Cale> crazy_code2: they're equally correct
20:55:19 <Cale> in that they're morally right, but neither of them is valid Haskell.
20:55:37 <crazy_code2> You mean it is syntactically right ?
20:55:52 <Cale> No, they're both blatant syntax errors.
20:55:57 <Cale> It's like pseudocode.
20:55:57 <sorear> > typeOf Node
20:56:04 <lambdabot>  Add a type signature
20:56:14 <crazy_code2> WHy is it an error ?
20:56:17 <sorear> > typeOf (Node :: Int -> [Tree Int] -> Tree Int)
20:56:17 <SamB_XP> actually, numbers work by (==)
20:56:19 <lambdabot>  Int -> [Tree Int] -> Tree Int
20:56:31 <crazy_code2> Can;t we have nullary constructors ?
20:56:32 <Cale> Because ... isn't part of the syntax of data declarations.
20:56:35 <bos> dons: am i correct in thinking that there's no clean way to override the error handling in Data.Binary?
20:56:35 <lambdabot> bos: You have 1 new message. '/msg lambdabot @messages' to read it.
20:56:50 <Cale> and the constructors which you define have to start with an uppercase letter
20:57:02 <Cale> Or if they're infix, a colon.
20:58:15 <crazy_code2> Cale: Ok. But can I have data X = 'a' | 2
20:58:31 <Cale> crazy_code2: not in real Haskell.
20:58:55 <Cale> (Or in any existing implementation)
20:59:05 <crazy_code2> now what is this other haskell where this is valid and why were they teaching it ? :)
20:59:08 <sorear> bos: once upon a type, decode :: Binary a => ByteString -> Either ParseError a
20:59:14 <sorear> s/type/time/
20:59:41 <crazy_code2> Sometimes such books make learning more difficult than it actually is..........
20:59:47 <Cale> crazy_code2: It's pseudo-code. You can think of 'a', 'b', 1,2,3, etc. as being defined in that way, since they behave roughly like they have been.
20:59:49 * Figs tries to make a "once upon a typo" joke but fails :)
20:59:51 <sorear> bos: they changed it, for a reason that I remember being very good (but forgot what it specifically was)
21:00:05 <crazy_code2> Cale: Oh Ok
21:00:18 <crazy_code2> Cale: Thanks
21:00:20 <Cale> But you can't really define them that way. They're actually just part of the language syntax.
21:00:25 <monochrom> once upon a typo, there was a haskell psycho.
21:00:38 <monochrom> his name was mono.
21:00:53 <Cale> Also in particular, the data declaration for Integer would be extremely long.
21:01:05 <oerjan> (also, your program is evil, i need ctrl-alt-del to quit...)
21:01:05 <Cale> Where by "extremely", I mean "infinitely"
21:01:15 <oerjan> (wrong channel)
21:01:34 <Figs> lol
21:01:35 <sorear> Cale: Not only is it extremely long, the constructors aren't even well ordered.
21:02:01 <Cale> Huh? You can well order the integers
21:02:10 <crazy_code2> Cale: THey actually mentioned data Char = 'a'|'b' ......... is invalid, whereas data Char = cA | cB | cC ....... etc is valid. That made me wonder whether this actually works ?
21:02:11 <Cale> It just wouldn't be the usual ordering.
21:02:15 <bos> sorear: ok, thanks
21:02:26 <bos> i'll look through the darcs history and see what i can see
21:02:44 <Cale> heh, well, the second happens to be invalid as well
21:03:06 <Cale> data Char = CA | CB | CC | ... | Ca | Cb | Cc | ...
21:03:13 <sorear> Cale: Sorry, that's what I meant.  The canonical order of constructors, needed for the Prelude's deriving(Ord), isn't a well-ordering; so you couldn't even do it if you had infinite lists for lines
21:03:18 <Cale> would be valid, provided you actually filled in all the ... dtuff.
21:03:20 <Cale> stuff*
21:04:02 <Cale> sorear: Well, writing the instance of Ord would be hard, yeah.
21:04:09 <crazy_code2> Cale: yeah, same. I was lazy to omit the CA| CB stuff. Why is that it has to be before Ca,  encoding reasons ?
21:04:38 <Cale> sorear: If you could have infinite case expressions, it would be okay though.
21:04:44 <dons> this thread scares me a bit, http://programming.reddit.com/info/23z4e/comments/c248l0
21:04:45 <lambdabot> Title: Haskell and Number Theory: The End of GCD (reddit.com)
21:05:02 <Figs> off topic, but WTF!
21:05:03 <Figs> http://www.youtube.com/watch?v=X76ZIGQgBWg&eurl=http%3A%2F%2Fgizmodo%2Ecom%2Fgadgets%2Fthe%2Dreal%2D%2En%2Dsync%2Fhuman%2Dpixels%2Dperform%2Dhuge%2Dreal%2Btime%2Danimation%2D275689%2Ephp
21:05:04 <lambdabot> http://tinyurl.com/3ddl9f
21:05:08 <Cale> crazy_code2: No, I mean the first letter of each constructor must be a capital letter.
21:05:15 <bos> ah, looks like Either ParseError a broke laziness or some such.
21:06:01 <dons> this is just scary "I just want to use the programming language to do what I need. I don't want to have to be forced to understand how it will deal with the code I type." isn't it?
21:06:10 <crazy_code2> Cale: Ok. Now I get it
21:06:40 <crazy_code2> Cale: So a constructor can't start with a character like '  right?
21:06:42 <Figs> O.o
21:06:45 <dolio> dons: I'm not sure walking on a bridge without knowing about structural engineering is an appropriate analogy for programming without knowing anything about how the compiler works.
21:06:46 <Cale> crazy_code2: right.
21:06:54 <Figs> dons: that sounds like the whole idea behind libraries :P
21:07:03 <dons> dolio: agreed.
21:07:17 <Cale> crazy_code2: Though it's fairly safe to regard 'a', etc. as being the constructors of Char.
21:07:18 <dons> he's asking to build bridges, without understanding the physics of bridges, really
21:07:22 <sorear>     No instance for (Ord (Tree t))
21:07:24 <sorear> What!
21:07:29 <Korollary> dons: You shouldn't be scared of random Joe's on reddit
21:07:36 <Cale> crazy_code2: They behave exactly as constructors do -- you can pattern match against them and everything.
21:08:58 <sorear> Why is there no instance of Ord for trees?
21:09:09 <crazy_code2> Cale: Oh Ok Thanks
21:09:44 <jfredett> because trees cant be ordered?
21:10:11 <sorear> they can't?
21:10:21 <jfredett> well, sortof
21:10:22 <dons> Korollary: true, people don't understand stuff all the time, and some whinge that they shouldn't have to. rarely do they make statements in public saying they have a right not to have to understand their job though :)
21:10:22 * sorear invokes Zorn's Lemma at jfredett
21:10:22 <Korollary> they can be ordered in many ways I suppose
21:10:29 <jfredett> not ordered like the integers ordered
21:10:48 <jfredett> just like vectors can only be lexicographically ordered
21:10:58 <jfredett> which is not necessarily unique
21:11:13 <Korollary> dons: It's a perspective issue. I frankly don't care about machine code any more. Some people quit caring at higher levels.
21:11:19 <dons> yep
21:11:26 <jfredett> depending on your definition of lexicographic, anyways
21:11:54 <Figs> how do you do computer science with a name like 'Quine'!!
21:12:14 <jfredett> what?
21:12:36 <Korollary> Does Colonel Quine sound better?
21:12:37 <dons> Figs, you do it recursively
21:12:41 <Figs> :P
21:13:00 <jfredett> dons, good answer
21:13:28 <monochrom> @src liftM2
21:13:28 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
21:14:36 <Cale> dons: regarding the real issue of that thread, is GHC really doing CSE there? I thought it had extremely weak CSE.
21:14:45 <Figs> oh ho!
21:14:47 <Figs> here's how
21:14:54 <Figs> :P
21:15:14 <dons> it has local CSE.
21:15:27 <dons> where's gcd1 defined? i'll look at the core.
21:15:38 <dons> and `seq` is a bit special..
21:16:15 <dons> we have
21:16:16 <dons> gcdmany xs = gcdmany 0 xs
21:16:16 <dons>     where gcdmany p []     = p
21:16:16 <dons>           gcdmany p (x:xs) = (gcd1 p x) `seq` gcdmany (gcd1 p x) xs
21:16:20 <dons> but where's gcd1?
21:16:47 <Cale> I actually don't know.
21:17:00 <Figs> named after him, got it
21:17:19 <dolio> It's in a previous blog posting, I suspect.
21:17:21 <Cale> What I think is happening is that forcing the evaluation of gcd1 p x is causing p to be forced inadvertently, but it's doing a lot of wasted work.
21:17:28 <Figs> You Godel Escher Bach -ers should have gotten what I was onto
21:17:38 <Cale> At least, that's how I'd read the code.
21:17:50 <Figs> 'quine' is named after the guy
21:17:56 <Cale> So it's stopping the stack overflows, but wasting lots of time while it's at it.
21:17:59 <jfredett> Figs: I lost the ability to parse english about 20 minutes ago
21:18:14 <Figs> (but when I looked him up, I looked up the wrong guy 1980s-> present, instead of 1900s ->2000)
21:18:20 <jfredett> Figs, so yah, quines were named Quine.
21:18:22 <dons> ah, got it.
21:18:27 <Cale> "Is named after the guy", is named after the guy.
21:18:36 <dons> gcd1 a b = gcd1' (abs a) (abs b)
21:18:36 <dons>     where gcd1' a 0 = a
21:18:36 <dons>           gcd1' a b = gcd1' b (a `rem` b)
21:18:47 <Figs> jfredett: you shouldn't talk on IRC while drunk :)
21:18:49 <jfredett> Cale, heh
21:18:53 * sorear grumbles at the libraries submission process
21:18:56 * Figs is, of course, joking
21:18:59 <jfredett> Figs: not drunk,
21:19:04 <Figs> sleepy/
21:19:05 <Figs> *?
21:19:12 <thorat> dons: I saw you posted Proofs and Types on reddit.  How does it compare with http://citeseer.ist.psu.edu/519604.html
21:19:12 <jfredett> though- I did cook with some wine for dinner
21:19:14 <lambdabot> Title: Lectures on the Curry-Howard Isomorphism - Srensen, Urzyczyn (ResearchIndex)
21:19:18 <sorear> why all this red tape just to add 4 letters....
21:19:27 <jfredett> so maybe I didn't burn out all the alcohol.
21:19:36 <jfredett> Figs: definitely sleepy
21:19:38 <jfredett> regardless
21:19:41 <Figs> :P
21:20:18 <dons> thorat: hmm, related? :)
21:20:21 <Figs> is [ x | x<- foo] based on this?
21:20:22 <Figs> http://upload.wikimedia.org/math/f/d/2/fd2a8c654ae8ab3b232539d971c22f2f.png
21:20:24 <lambdabot> http://tinyurl.com/2q73gk
21:20:28 <Figs> well, that type of notation
21:20:44 <Figs> (not that specific example, which is Russell's paradox)
21:20:49 <jfredett> its based on standard set notation
21:20:55 <jfredett> so yah, more or less
21:21:07 <thorat> dons: ok :S
21:21:17 <dons> Cale, that gcdmany generates some weird code
21:21:19 <Figs> YES!
21:21:19 <Korollary> thorat: that's a nice one, too.
21:21:20 <Figs> thanks
21:21:22 <Cale> Yeah, gcd1 gets 2000000 entries.
21:21:27 <Figs> I just remembered what I forgot yesteray
21:21:28 <Figs> *Day
21:21:32 <Cale> When run on [1..1000000]
21:21:38 <Cale> which is horrible
21:21:52 <dons> its too polymorphic :)
21:21:58 <Figs> that's over 9000!
21:22:05 <jfredett> I would denote a set of all even numbers {x : forall x in N. Even(x)}, in haskell, thats [x | x <-[1..], even x]
21:22:05 * Figs gets shot
21:22:45 <thorat> Korollary: thanks, I'll compare them.
21:22:48 <jfredett> (that is, all even natural numbers...)
21:22:49 <dons> {-# SPECIALISE gcdmany :: [Int]     -> Int #-}
21:22:49 <dons> {-# SPECIALISE gcdmany :: [Integer] -> Integer #-}
21:22:52 <dons> seems to help muchly
21:22:58 <dons> we get a nice Int# worker
21:23:16 <Cale> uh, does it cut the entries in half though?
21:23:39 <Figs> Z is int?
21:23:45 <Figs> N is nat?
21:23:47 <jfredett> Z is in
21:23:51 <jfredett> N is Nat, yes.
21:23:54 <jfredett> Q is rationals
21:23:56 <Figs> kk
21:23:57 <jfredett> R is reals
21:23:58 <Cale> I just changed the type to [Integer] -> Integer, and I'm still seeing 2000000 entries.
21:24:00 <jfredett> C is complex
21:24:02 <Figs> been a while
21:24:04 <dons> gcdmany is still way too complex.
21:24:13 <jfredett> Sets are fun
21:24:19 <Figs> F is for Figs :)
21:24:32 <dolio> Well, for what it's worth, he does get to 'foldl' gcd1 0' at the end. :)
21:25:00 <Cale> So no, there's no CSE going on there.
21:25:24 <dons> right. there's no CSE.
21:25:29 <Figs> wootage
21:25:30 <Figs> http://www.jfsowa.com/logic/math.htm
21:25:31 <lambdabot> Title: Mathematical Background
21:25:32 <Figs> is this good?
21:25:36 <dons> just count the 2 calls to $wgcd1 in the core.
21:25:43 <jfredett> Actually, F usually denotes some kind of Field, but okay, {x | forall x. Figs(x)} is good too.
21:26:32 <Figs> :P
21:27:08 <dons> Cale: gcdmany' p (x:xs) = v `seq` gcdmany' v xs where v = gcd1 p x
21:27:25 <Cale> dons: yes, that's what I'm talking about.
21:28:01 <oerjan> jfredett: that forall x. is misplaced if that is mathematical notation
21:28:12 <Figs> what is the equivalent of a haskell list in C++ ds?
21:29:47 <Figs> data structures
21:30:04 <scook0> Figs: if you ignore laziness, it's a singly-linked list
21:30:07 <Figs> ok
21:30:31 <scook0> with laziness thrown in, it can become more stream-like
21:31:15 <Figs> why is {} C A?
21:31:39 <Figs> C <-- subset of
21:32:10 <dons> I wish foldl' had an inline pragma
21:32:40 <Figs> huh
21:32:53 <Figs> what's the best way to think about ~A in regex?
21:33:23 <Figs> [negation of a set]
21:33:32 <sorear> Argh. It seems I can't submit a 4 character library submission because the 20 minute test suite hasn't been updated since the base split.
21:33:36 <Figs> or compliment, if you prefer
21:33:46 * sorear hates process
21:34:14 <Figs> process = corpes's
21:34:20 <Figs> err
21:34:26 <Figs> corpse's?
21:34:30 <Cale> Figs: what do you mean by that?
21:34:32 <Figs> corpses
21:34:42 <Cale> Figs: It's the set of all strings which are not matched by A
21:34:53 <Saizan> sorear: you've uploaded a functorm that depends on unix
21:35:06 <sorear> Saizan: doh
21:35:07 <Figs> process -> p roc ess -> p cor ess -> corp ess -> corpses
21:35:19 <Figs> Cale: I know that, but I meant implimentation wise
21:35:28 <Cale> Figs: in terms of DFAs?
21:35:33 <Figs> DFA???
21:35:35 <sorear> Saizan: I used the vty.cabal as a templete. System.Posix.Signals strikes again
21:35:39 <Figs> oh
21:35:41 <sorear> discrete finite automata
21:35:50 <Cale> Deterministic Finite Automata.
21:35:58 <Figs> I didn't recognize the abbr
21:36:01 <Figs> :P
21:36:06 <oerjan> Figs: {} is a subset of A because there is nothing in {} that could fail to be in A, because there is nothing in {} at all
21:36:17 <Figs> ok
21:36:34 <Cale> You can do that by just swapping which nodes are terminal and nonterminal.
21:37:11 <Cale> er, accept states and non-accept states, would be better terminology.
21:37:14 <dons> Cale, and yep, given an inlined foldl' , you get *identical* code from foldl' gcd, to the seq version with cSE.
21:37:29 <Cale> dons: cool
21:37:43 <Figs> I guess I have an unusual problem
21:37:54 <Figs> and the problem is length
21:38:23 <dmwit> ?
21:38:33 <jfredett> bah, he calls multisets bags
21:38:35 <Figs> foo>> ~x >> x
21:38:53 <Cale> Figs: huh?
21:39:00 <dmwit> What is (>>) in this case?
21:39:02 <Figs> followed by
21:39:18 <Cale> well, that's regular, anyway
21:39:25 <Cale> what's the question about it?
21:39:46 <Figs> I'm trying to think about how to represent ~x internally
21:40:02 <Figs> since ~x could be a branch of indeterminate length in the string
21:40:07 <Figs> like
21:40:07 <Cale> How are you representing regular expressions generally?
21:40:45 <Cale> The usual way with DFAs would be to invert your set of accept states.
21:40:50 <Cale> (as I mentioned)
21:41:01 <Figs> http://libfigconfig.googlecode.com/svn/trunk/include/alt.h
21:41:04 <Figs> kind of like this
21:41:29 <Figs> this matches an alt
21:41:33 <Figs> ex:
21:41:35 <Figs> a|b|c
21:41:39 <Cale> what does it do if it fails?
21:41:47 <brad_> hi, is mkcabal installed with Cabal?
21:41:52 <brad_> i can't seem to find it
21:42:01 <Figs> it returns a default match_result object (where the flag for a match is false)
21:42:25 <Figs> otherwise it returns that 1) it matches, 2) what parts it matched in the term
21:42:33 <Figs> and 3) how long it matched
21:42:46 <Cale> Figs: What you want to do is produce a parser which, if the original parser succeeds, it fails, and vice versa.
21:42:47 <dmwit> Creating the regex that is the negation of another regex isn't terribly pretty.
21:42:48 <Figs> since the way I'm matching is that there's an implied bos >> _____
21:42:51 <Figs> with no >> eos
21:43:06 <Korollary> @where mkcabal
21:43:06 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/mkcabal
21:43:11 <Figs> I guers
21:43:13 <Figs> *guess
21:43:20 <brad_> thanks Korollary!
21:43:28 <Figs> that's probably easy enough actually, now that I think about it
21:43:48 <Figs> actually,
21:43:51 <Figs> this is really easy
21:43:53 <Figs> nevermind
21:43:53 <Figs> :P
21:44:03 <Cale> If the original parser fails, of course, you want the set of successes to be all possible substrings, in descending order of length.
21:44:17 <int80_h> hi Cale, I'm back to do more work :)
21:44:20 <Cale> :)
21:44:31 <sorear> Saizan: fixed
21:44:39 <Figs> oh, wait a second,
21:44:41 <Figs> yeah :P
21:44:43 <Figs> shit
21:44:49 <Figs> the backtracking is what will make it harder
21:44:51 <Figs> I forgot the alts
21:45:07 <Figs> reversing success is easy
21:45:23 <sorear> *Main> prove $ (a --> b --> c) --> (a --> b) --> a --> c
21:45:23 <sorear> True
21:45:38 <Figs> ok, basically, like... hmm
21:45:55 <Figs> huh, oh
21:46:02 <Figs> it's basically like a *()
21:46:09 <Figs> ex
21:46:14 <Figs> f >> *o >> 'o'
21:46:21 <Figs> err
21:46:26 <Cale> Figs: this is annoying in a strict language, because returning a list of all the results is awkwardly inefficient.
21:46:27 <Figs> f >> *o >> o
21:46:37 <Figs> Cale, I'm working in C++
21:46:41 <Cale> right
21:46:42 <Figs> and
21:46:49 <Figs> I don't need to return the set of anything
21:47:04 <Cale> However, you can probably maintain some state within your parser objects.
21:47:05 <Figs> basically, I just need to make it work like matching a *
21:47:20 <dons> http://haskell.org/haskellwiki/GCD_inlining_strictness_and_CSE
21:47:22 <lambdabot> Title: GCD inlining strictness and CSE - HaskellWiki
21:47:27 <Figs> basically, I just have to keep track of the set of backtrack data
21:47:33 <Cale> (this is just a *lot* simpler in a lazy language)
21:47:38 <Figs> which is done in the match_result language
21:47:44 <Cale> right
21:47:58 <Figs> err, object*
21:48:04 <Figs> what am I saying language? ha :P
21:48:18 <Cale> In Haskell, you wouldn't bother. You'd just have the parser return a list of all possible ways that the thing can match, in order of preference.
21:48:30 <Figs> yeah
21:48:51 <Figs> Haskell does a lot for you :P
21:48:55 <Cale> yeah :)
21:49:04 <Figs> but I'm not good enough with haskell yet, and I need this in C++
21:49:24 * Figs is reworking his regex parser
21:49:55 <Figs> well, it's not "regular"
21:49:56 <Figs> but whatever
21:50:32 <sorear> Figs: Okasaki has already shown us how to do backtracking parser combinators in non-lazy languages
21:50:38 <sorear> @go even higher order functions
21:50:40 <lambdabot> http://citeseer.ist.psu.edu/163183.html
21:50:40 <lambdabot> Title: Functional Pearls - Even Higher-Order Functions for Parsing or Why Would Anyone  ...
21:50:48 <sorear> that.
21:51:21 <Figs> I don't know what currying is
21:51:26 <Figs> at least, not by name
21:51:43 <oerjan> @src curry
21:51:43 <lambdabot> curry f x y = f (x, y)
21:51:57 <oerjan> @src uncurry
21:51:57 <lambdabot> uncurry f p = f (fst p) (snd p)
21:52:02 <Figs> o.o
21:52:13 <Figs> so, in C++
21:52:56 <Figs> T curry(T (&)(XT,YT),XT,YT)?
21:53:10 <Figs> or, supposing ints
21:53:44 <Figs> int curry(int (&foo)(int,int),int x,int y) { return foo(x,y);}
21:53:45 <Figs> ?
21:54:04 <oerjan> no
21:54:10 <Figs> no?
21:54:21 <scook0> Figs: if g = curry f
21:54:36 <scook0> then f(x,y) = g(x)(y)
21:54:58 <oerjan> scook0: you mean curry f x
21:55:13 <oerjan> er wait
21:55:16 <mauke> int uncurry(int (*(*f)(int))(int), int x, int y) { return f(x)(y); }
21:55:18 <Figs> is it basically like bind()?
21:55:35 <Figs> bind(foo,x,y)() = result of foo(x,y)
21:55:36 <mauke> except not :-)
21:55:39 <mm_freak> idList (x:xs) = x:(idList xs)  -- this function does not stack-fault even for huge lists‚Ä¶  is it translated into iterative code?
21:55:52 <Figs> except not?
21:55:59 <Figs> well, haskell is more flexible :P
21:56:00 <mauke> no, uncurry() itself should be curried
21:56:16 <Figs> what is f(x)(y) supposed to mean, anyway?
21:56:29 <mm_freak> figs: f applied to two arguments, x and y
21:56:44 <mauke> no, call the result of calling f with x with y
21:57:00 <Figs> oh
21:57:02 <scook0> my "f(x,y)" and "g(x)(y)" were supposed to be C++ish syntax
21:57:04 <mm_freak> mauke: that essentially the same, just more difficult to understand =)
21:57:14 <mauke> mm_freak: it's very different in C++
21:57:24 <Figs> g(x) returning an int (&)(int)?
21:57:28 <mm_freak> ah, you're talking about c++
21:57:35 <Figs> yeah
21:57:45 <mauke> Figs: an int (*)(int) in my code
21:57:47 <mm_freak> yeah, then it's valid if f(x) returns a function pointer
21:57:56 <Figs> no, you'd have to dereference that
21:58:01 <mauke> Figs: that's what () does
21:58:12 <mauke> function-pointer ( argument-list )
21:58:13 <scook0> it's a bit tricky to express in C++, since you don't really have first-class functions
21:58:40 <Figs> you can use function references to do that without doing it with *
21:58:51 <mm_freak> function references?!
21:58:55 <jfredett> function refs/pointers are yucky.
21:58:59 <mauke> & is harder to type than *
21:59:02 <Figs> not really
21:59:08 <mauke> there are no benefits to using & over *
21:59:15 <mm_freak> i wouldn't even know that function _references_ exist
21:59:15 <jfredett> mm_freak: its a way to simulate closure in C/C++
21:59:21 <Figs> & means you can do foo() instead of (*foo)()
21:59:25 <mauke> Figs: wrong
21:59:30 <mm_freak> however, if they do, they could just be aliases, so pointless
21:59:37 <mauke> (*foo)() is stupid
21:59:57 <Figs> why?
22:00:08 <Figs> it's done quite a bit.
22:00:15 <mauke> because the () operator evaluates "both" operands
22:00:22 <mauke> evaluating a function yields a function pointer
22:00:42 <mauke> i.e. () always gets a function pointer
22:00:46 <mm_freak> theoretically if foo is a function pointer, then (*foo)() dereferences the pointer twice
22:00:51 <mm_freak> so it should be a syntax error
22:00:55 <mauke> mm_freak: wtf?
22:00:59 <mauke> no
22:01:09 <Figs> uh no
22:01:13 <Meowfaceman> Quick question: IO Integer -> Integer, (or more generally, Monad a -> a) is it possible to do?
22:01:22 <sorear> No
22:01:25 <mauke> Meowfaceman: in general yes, IO no
22:01:30 <sorear> (*foo)() is K&R syntax
22:01:44 <sorear> all modernish (89 IIRC, definitely 99) C's support foo()
22:01:53 <mm_freak> aha k
22:02:02 <sorear> but they support (*foo)() too for backwardness
22:02:07 <mm_freak> there's always something left to learn =)
22:02:09 <sorear> (compatibility that is)
22:02:18 <mauke> int main(void) { (********printf)("hi\n"); return 0; }
22:02:20 <mauke> ^ try that
22:02:23 <Figs> what compiler are you using?
22:02:27 <jfredett> Meowfaceman: though, it depends on the monad
22:02:50 <jre2> is there a 'best practices' guidelines for using STM efficiently?
22:02:57 <dons> http://www.akalin.cx/2007/07/06/a-foray-into-number-theory-with-haskell/
22:02:59 <lambdabot> Title: akalin.cx / A foray into number theory with Haskell, http://tinyurl.com/36nhfa
22:03:06 <sorear> let{v s=[(l,r,delete e s)|e@(Node _ [l,r])<-s];d(f,t)=[[]|_<-intersect f t]++[[(g,l:t),(r:g,t)]|(l,r,g)<-v f]++[[(l:f,r:u)]|(l,r,u)<-v t];q t c=not(elem c t)&&or[all(q(c:t))p|p<-d c];prover a=q []([],[a]);infixr 5-->;x-->y=Node 0[x,y];[a,b,c]=[Node x[]|x<-[1..3]]} in  prover $ (a --> b --> c) --> (a --> b) --> a --> c
22:03:07 <dons> jre2: hmm. not really.
22:03:11 <sorear> > let{v s=[(l,r,delete e s)|e@(Node _ [l,r])<-s];d(f,t)=[[]|_<-intersect f t]++[[(g,l:t),(r:g,t)]|(l,r,g)<-v f]++[[(l:f,r:u)]|(l,r,u)<-v t];q t c=not(elem c t)&&or[all(q(c:t))p|p<-d c];prover a=q []([],[a]);infixr 5-->;x-->y=Node 0[x,y];[a,b,c]=[Node x[]|x<-[1..3]]} in  prover $ (a --> b --> c) --> (a --> b) --> a --> c
22:03:16 <lambdabot>  True
22:03:17 <dons> there's some examples on the wiki
22:03:18 <jfredett> the issue is some monads don't export there constructors, so theres nothing to pattern match against, but a monad like Maybe can have Maybe a -> a just fine
22:03:23 <sorear> > let{v s=[(l,r,delete e s)|e@(Node _ [l,r])<-s];d(f,t)=[[]|_<-intersect f t]++[[(g,l:t),(r:g,t)]|(l,r,g)<-v f]++[[(l:f,r:u)]|(l,r,u)<-v t];q t c=not(elem c t)&&or[all(q(c:t))p|p<-d c];prover a=q []([],[a]);infixr 5-->;x-->y=Node 0[x,y];[a,b,c]=[Node x[]|x<-[1..3]]} in  prover $ a --> a
22:03:26 <lambdabot>  True
22:03:28 <mm_freak> > let 2 + 2 = 5 in 2 + 2
22:03:28 <sorear> > let{v s=[(l,r,delete e s)|e@(Node _ [l,r])<-s];d(f,t)=[[]|_<-intersect f t]++[[(g,l:t),(r:g,t)]|(l,r,g)<-v f]++[[(l:f,r:u)]|(l,r,u)<-v t];q t c=not(elem c t)&&or[all(q(c:t))p|p<-d c];prover a=q []([],[a]);infixr 5-->;x-->y=Node 0[x,y];[a,b,c]=[Node x[]|x<-[1..3]]} in  prover $ a --> b
22:03:30 <lambdabot>  5
22:03:31 <lambdabot>  False
22:03:33 <mm_freak> lol
22:03:38 <sorear> who needs @djinn? :)
22:03:51 <dons> :)
22:03:59 <Figs> mauke, I've never seen that, I assumed it was illegal :P
22:04:00 <Meowfaceman> Hrrrm.  I suppose I need to read up on them more.  It feels like one should be able to do IO Integer -> Integer at least (as in it wouldn't be problematic) but it appears not.
22:04:08 <sorear> dons: btw, I couldn't have done that without the paper link you posted earlier :)
22:04:14 <mm_freak> > let 1/0 = 3 in 1/0
22:04:15 <jfredett> from what I can tell, any monad having to do with State, can't be (usefully) escaped from
22:04:16 <lambdabot>  3
22:04:21 <Figs> afai knew, I thought that was non-standard behavior
22:04:25 <jfredett> but there is always performunsafeIO
22:04:27 <dons> sorear: oh, very cute.
22:04:34 <mauke> Figs: no matter how you use a function in code, you always get a function pointer
22:04:40 <Figs> do you know where it is?
22:04:44 <shachaf> jfredett: "wouldn't be problematic"
22:05:01 <Figs> (ie, in the standard)
22:05:05 <mauke> Figs: because either it's the operand of & (so you get a pointer anyway), or it isn't, in which case it's evaluated, which also yields a function pointer
22:05:13 <Figs> if it's there, I will absolutely use it, since it makes things easier
22:05:25 <jfredett> shachaf: pardon?
22:05:46 <Figs> no
22:05:54 <Figs> I mean void (*bar)() = foo;
22:05:56 <Figs> bar();
22:06:05 <mauke> yes, that's what I'm talking about
22:06:07 <Figs> yes
22:06:15 <jfredett> shachaf: IO Integer -> Integer is possible, and nonproblematic, with performUnsafeIO, assuming your careful, and not doing it alot, and pull o -- we won't go there.
22:06:21 <Figs> that behavior is allowed by the standard?
22:06:26 <mauke> no, mandated
22:06:36 <mauke> let's take something like sqrt(2.0)
22:06:50 <shachaf> jfredett: Why isn't unsafePerformIO problematic?
22:06:53 <mauke> sqrt evaluates to a function pointer. ( ) then takes the function pointer and applies it to 2.0
22:07:26 <jfredett> shachaf: it is, if you use it wrong, but then again, so is any other function, Monad or otherwise
22:07:43 <Figs> isn't that implimentation defined mauke?
22:07:48 <jfredett> shachaf: fundamentally, every bit of the language is capable of being a problem
22:07:54 <jfredett> its just about usage.
22:07:55 <shachaf> jfredett: But unsafePerformIO breaks referential transparency.
22:08:00 <mauke> 6.5.5.2/1 says: "The expression that denotes the called function shall have type pointer to function returning void or returning an object type other than an array type."
22:08:04 <mauke> Figs: no
22:08:04 <jfredett> shachaf: sometimes you need to
22:08:23 <Figs> I'll look for it, just a sec
22:08:34 <mauke> er, 6.5.2.2
22:09:00 <jfredett> shachaf: it isn't the holy grail, its a good property to have- but sometimes you need to put that aside, to make something work without kludging around in IO
22:09:26 <shachaf> jfredett: Yes, but that's "problematic" -- one of the promises the language gives you (and gives the optimizer) is to be referentially transparent.
22:09:31 <Figs> maybe I'm working on an old version, but I can't find it
22:09:39 <mauke> this is in C99
22:09:44 <Figs> I'm in C++
22:09:46 <Figs> not C99
22:10:02 * sorear modifies his theorem prover to produce terms
22:10:14 <mauke> the other half (about a function evaluating to a pointer) is in 6.3.2.1/4
22:11:03 <Figs> I'm working from ISO/IEC 14882, what are you working from?
22:11:06 <jfredett> shachaf: then if thats the case, he shouldn't use it. But all I'm saying is that -- if it weren't useful and non-problematic, in some cases, to use
22:11:10 <jfredett> it wouldn't be in the library.
22:11:41 <Figs> (second edition, ie, 2003)
22:11:50 <shachaf> Meowfaceman: You said that a function :: IO a -> a makes sense to you?
22:12:00 <jfredett> shachaf, then again, if he doesn't have a problem losing a little RT, then maybe he should use it, as its easier.
22:12:00 <mauke> I'm looking at ISO+IEC+14882-1998.pdf now
22:12:27 <mauke> Figs: 5.2.2/1 [expr.call]
22:12:44 <mauke> and 4.3.1 [conv.func]
22:13:01 <Figs> ok
22:13:07 <Figs> looking
22:13:33 <shachaf> jfredett: Yes, but Meowfaceman is still trying to understand monads -- unsafePerformIO will only cause problems unless you know what it does, and how to do without it.
22:14:18 <Meowfaceman> shachaf: It did in the interpreted environment I was trying to use it in.
22:14:38 <Figs> mmm
22:15:02 <Figs> cool
22:15:03 <jfredett> shachaf: thats fine- then he shouldn't use it, but it doesn't mean he shouldn't know about it.
22:15:37 <Meowfaceman> shachaf: Essentially trying to call a basic int -> int function with a getInt function at the hugs terminal.  Having getInt return IO Integer seemed pointless.
22:15:59 <jfredett> its like drugs- young children should be aware of what drugs will do to them if they use them- so that later on in life, they'll realize that -- when offered drugs -- they should turn them down.
22:16:00 <Figs> seriously, I thought I had to do (*foo)() since that was how I learned it
22:16:01 <Meowfaceman> shachaf: After realizing what referential transparency meant though, it kind of makes a LOT more sense as to why it's like that.
22:16:04 <shachaf> jfredett: Yes, he should know about it -- but AFTER he realizes it isn't part of how monads work, but a hack.
22:16:31 <Figs> and the other times I saw people refering to it, for example in boost bind, I interpretted the other behavior is specific to certain implimentations
22:16:45 <Figs> thanks mauke
22:16:50 <jfredett> shachaf: I think we should just agree to disagree. I don't think either of us will be swayed.
22:16:54 <mauke> you're welcome :-)
22:16:57 <Figs> much simpler programming now :)
22:17:10 <Figs> although I don't see anything wrong with function references
22:17:13 <shachaf> jfredett: Probably true -- this is more of a matter of definition, I think.
22:17:15 <mauke> just use boost::function for everything :-)
22:17:34 <jfredett> shachaf: yep.
22:17:37 <shachaf> jfredett: I agree with everything you say except that it's "nonproblematic".
22:18:31 <Meowfaceman> jfredett, shachaf: Thanks, I think this is the only time I've ever been on an irc channel for help and actually gotten it.  I appreciate it.
22:18:36 <dolio> dons: So, I'm nearing completion on the LogicT stuff, but I'm conflicted on what exactly to put for author/copyright/license/etc.
22:18:38 <Figs> huh
22:18:50 <jfredett> shachaf: well, I guess the fact that it raised a discussion about its problem-status makes it problematic
22:18:59 <Figs> I just realized I have a paper by C.A.R Hoare on "Hints on Programming Language Design"
22:19:14 <jfredett> so i guess your right, at least ex post facto.
22:19:22 <Figs> dated dec. 1973!
22:19:32 <jfredett> ooh, like pdf? or real paper
22:19:38 <Figs> pdf
22:19:40 <jfredett> I collect Math/CS Texts
22:19:54 <Figs> this looks like it's written with a typewritter
22:19:59 <jfredett> send it my way? jfredett@wpi . edu?
22:20:03 <Figs> kk
22:20:44 <jfredett> I've got all sorts of wonderful papers, including (my prized possesion) a pdf of the unabridged Principia Mathematica by Russell and Whitehead
22:20:50 <jfredett> all 700 some odd pages of it
22:20:51 <jfredett> :)
22:21:10 <jfredett> (I'm on pg 44, its some dense stuff..
22:21:24 <Figs> cool
22:21:30 <Figs> I have a lot of weird crap
22:21:50 <Figs> let me know when you get it
22:21:52 <dons> dolio: you've reimplemented it from scratch/
22:21:53 <jfredett> if you find anything interesting, send it along- i love these old papers.
22:21:54 <dons> ?
22:22:14 <dons> oleg's stuff is usually public domain, iirc/
22:22:15 <Figs> Well, I have another one
22:22:24 <dolio> dons: It's certainly a lot different than what comes in that Oleg tarball.
22:22:29 <Figs> Seven Deadly Sins of Introductory Programming Language Design
22:22:37 <jfredett> nifty
22:22:55 <dolio> dons: Although some of the code is very similar.
22:23:13 <dons> dolio: i'd just go with the usual BSD3-style license (http://haskell.org/haskellwiki/How_to_write_a_Haskell_program#Licenses) , with you as author. in the description mention its a reimplementation of the stuff on oleg's site, and mention the paper in the haddocks
22:23:15 <lambdabot> Title: How to write a Haskell program - HaskellWiki, http://tinyurl.com/yxe296
22:23:30 <Figs> you want?
22:23:53 <jfredett> sure
22:24:07 <Figs> kk
22:24:08 <Figs> sent
22:24:09 <jfredett> the more random esoteric papers for my collection, the better
22:24:10 <jfredett> :)
22:24:12 <Figs> you got it?
22:24:20 <Figs> actually these aren't that hard to understand
22:24:23 <jfredett> WPI email can be unreasonably slow
22:24:27 <dolio> dons: All right. The tarball does look like it's essentially public domain/use at your own risk, but it says to include the license file if you distribute it.
22:24:34 <Figs> although a lot of people seem to disagree with their suggestions for some reason ;)
22:24:35 <jfredett> you sent it to jfredett@wpi.edu, oui?
22:24:54 <jfredett> i got the second, not the first.
22:25:17 <jfredett> silly WPI email. :/
22:25:22 <Figs> :P
22:25:24 <Figs> weird
22:25:27 <Figs> yes
22:25:39 <Figs> you want me to resend the first?
22:25:45 <dons> dolio, but you're reimplementing from the paper :)
22:25:56 <jfredett> yah, I think it got lost somewhere
22:26:04 <dons> anyway, CC. oleg and ccshan the announcement, i'm sure they'll be happy
22:26:04 <jfredett> NetOps hates me.
22:27:22 <Figs> sent
22:27:49 <jfredett> there we go
22:27:54 <jfredett> it cam thru this time
22:27:57 <jfredett> weird...
22:27:58 <jre2> jfredett: where do you obtain these math/cs texts? is there some awesome underground pythagorean cult I'm missing out on?
22:28:16 <brad_> is "isDigit" supposed to be in Prelude or Char modules?
22:28:22 <jfredett> jre2: Hither, Thither, To, and sometimes Fro.
22:28:56 <jfredett> jre2, I've downloaded most of JSTOR and have that on my Harddrive for when I'm away from school
22:28:56 <mauke> @index isDigit
22:28:57 <lambdabot> Data.Char
22:29:30 <brad_> mauke - is this distinct from "Char"? i presume so, but if i :m Char, i see it too
22:29:37 <dons> Char is the old Haskell 98 name
22:29:57 <dolio> dons: Oh, also, I'm getting some odd haddock output in one case: "??? a => Applicative (Logic a)"
22:29:58 <jre2> jfredett: magical curl script?
22:29:58 <jfredett> My Advisors also the editor for the Pi Mu Epsilon Journal, so she has access to papers and things- and for the low low price of some access to the vast library, I get copies of all the good stuff. :)
22:30:00 <dons> it'll still work, but best to use Data.Char and other hieracrchical names
22:30:04 <dolio> dons: Does it not like generalized newtype deriving?
22:30:14 <dons> dolio: it probably barfs on that, yep.
22:30:25 <brad_> AH - thanks dons, that is why my cabal build is breaking, it is telling me haskell98 is not exposed
22:30:38 <glguy> dons: did you write that Bench.hs specifically for this?
22:30:38 <lambdabot> glguy: You have 1 new message. '/msg lambdabot @messages' to read it.
22:30:46 <glguy> dons: or was there some cutting and pasting?
22:30:49 <dons> glguy: nope, its from bytestring (and other projects)
22:30:53 <dons> so its just cut and paste :)
22:30:57 <jfredett> jre2: actually, I cull threw the JSTOR articles on my own
22:31:08 <glguy> dons: ok, cool
22:31:11 <jfredett> its all manually downloaded
22:31:22 <jfredett> gives me something to do when I'm slacking off. :)
22:31:27 <glguy> dons: so I should tag it 0.1? push to hackage?
22:31:29 <dons> glguy: performance is pretty good!
22:31:33 <dons> i reckon so, yep.
22:31:34 <jre2> sounds painful
22:31:41 <dons> darcs tag , darcs dist , upload
22:32:03 <jfredett> jre2: not to bad, really, I make sure I only grab the good stuff, that way
22:33:18 <jfredett> i've gotten very good at judging the quality of articles by there titles and filesizes, though
22:34:05 <jre2> jfredett: what you really want is the entire archive+bibtext entries for wonderful biblio/fulltext searching, as well as a database of texts you've personally checked as good
22:34:12 <jre2> bibtex*
22:34:27 <jfredett> lol- i suppose
22:34:28 <Figs> did you get it jfredett?
22:34:38 <jfredett> what? the paper? yes
22:34:47 <jfredett> what jre2 said, kind of
22:34:57 <Figs> ok
22:35:04 <Figs> sorry was afk
22:35:08 <jfredett> but I'm exhausted, and lost the ability to parse language more than 30 minutes ago
22:35:10 <jfredett> no worries
22:35:22 <jfredett> efil si boog.
22:35:45 <Figs> doog, perhaps?
22:35:55 <jfredett> > map reverse ["efil", "si", "boog"] -- in case you were wondering
22:35:57 <lambdabot>  ["life","is","goob"]
22:36:03 <jfredett> oops.
22:36:09 <Figs> ;)
22:36:13 <jfredett> doog is correctsir.
22:36:22 <jfredett> i feel like an idiot now. :/
22:36:23 <Figs> ^.^
22:36:30 <jfredett> no- frak that, its goob!
22:36:35 <jfredett> life is goob!
22:36:36 <Figs> nah, I've done it before
22:36:40 <Figs> ...
22:36:50 <Figs> although :P
22:37:07 <jre2> actually, I'd love to have some math/cs audiobooks
22:37:30 <jre2> at work I can listen to my mp3 player all day, but I can't exactly whip out a book and read it
22:37:37 <jfredett> jre2, thats actually going to be one of my projects, eventually
22:37:43 <jfredett> turn my whole library to audiobook
22:38:08 <jfredett> and convienently leak it to certain torrential fileservers.
22:38:25 <jfredett> because since i dont technically own the works, that'd be illegal
22:40:09 <Figs> I hate adobe
22:40:18 <Figs> bah >.<
22:40:22 <Figs> way to fuck up their reader!
22:41:02 <glguy> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/utf8-string-0.1
22:41:05 <lambdabot> http://tinyurl.com/3dzrdw
22:42:19 <Figs> anyone have a preview of Acrobat 8?
22:42:31 <Figs> I don't want to download it before I know if it's really any better than 7
22:42:36 <Figs> otherwise I'll go back to 6
22:42:57 <jfredett> i use kpdf and xdvi, adobe is yucky.
22:43:02 <dons> ?where+ utf8-string http://hackage.haskell.org/cgi-bin/hackage-scripts/package/utf8-string-0.1
22:43:02 <lambdabot> Done.
22:43:03 <Figs> (seriously, wtf -- who gets rid of the 100% view button?)
22:43:19 <Figs> adobe sucks
22:43:21 <Figs> :(
22:43:27 <jfredett> use linux
22:43:28 <jfredett> :P
22:43:29 <Figs> they dropped the one product I thought was cool
22:43:33 <Figs> atmosphere
22:43:51 <Figs> they had browser plugins, etc
22:44:13 <Figs> my friend had a copy of the beta and I build little meeting rooms online to jump around and chat with my friends :P
22:44:13 <jre2> anyone know offhand how difficult it is to compile ghc from source without ghc?
22:44:25 <Figs> O.o
22:44:48 <Figs> uhh, what language is the source in? :P
22:44:59 <jfredett> C and Haskell, as I remember
22:45:13 <jfredett> I seem to have heard that ghc uses C-- somewhere in there
22:45:20 <jfredett> compiles to it or something
22:45:54 <Figs> why the fuck don't they have a screen shot of reader 8?
22:46:04 <jfredett> Figs: Murphys Law
22:46:23 <sjanssen> jre2: fairly difficult
22:46:52 <jre2> apparently our sys admins had some trouble 'getting ghc to behave' in the past (and won't answer my emails to explain what that means), so I was hoping there's some chance of installing a local copy (downloading binaries off the net is forbidden without some long evaluation process)
22:46:56 <sjanssen> jre2: do you really need to do it?
22:47:20 <jfredett> it means your sysadmins are lazy asses
22:47:21 <sjanssen> jre2: ask the admins how they first installed gcc :)
22:47:40 <jre2> sjanssen: I think that passed their evaluation
22:47:42 <jfredett> stupid IT people, give the rest of us a bad name
22:47:50 <jre2> or got grandfathered with the OS
22:48:15 <Figs> seriously, I'm going back to reader 6
22:48:20 <Figs> it was the last 'good' version
22:48:33 <jfredett> the people I work with- swear to god- think that computer's gonna freaking bite them if they try to fix something
22:48:34 * Figs hates it that they got rid of the view at actual size button
22:48:49 * glguy thinks it might be time to move on
22:48:57 <Figs> it might be
22:48:57 <jfredett> to linux!
22:49:03 <Figs> if I could use linux
22:49:07 <jre2> jfredett: the superstitus admin types?
22:49:08 <Figs> I would
22:49:09 <Figs> :P
22:49:10 * glguy has the best of both worlds
22:49:13 <jfredett> everyone can use linux. :
22:49:13 <Saizan> i wonders how a 6061 .hi file is gone inside the ghc-6.7* directory..
22:49:14 <jfredett> :)*
22:49:16 <glguy> gentoo in vmware on linux :)
22:49:17 <Figs> no
22:49:19 <Figs> I can't
22:49:20 <Figs> :P
22:49:25 <dons> ?users
22:49:25 <lambdabot> Maximum users seen in #haskell: 354, currently: 294 (83.1%), active: 11 (3.7%)
22:49:25 <jre2> why not?
22:49:26 <Figs> I don't have any extra space
22:49:30 <jfredett> jre2: the stupid punk ass Sysadmins
22:49:37 <Figs> not enough for a new linux partition
22:49:40 <jfredett> Figs: you will when you delete windows
22:49:42 <jfredett> :P
22:49:45 <jre2> delete your inferior os
22:49:57 <Figs> when I build a computer
22:50:15 <Figs> I'll put linux on it
22:50:31 <Figs> and I can't delete windows
22:50:34 <jfredett> and then you'll wonder why you didn't just delete windows in the first place
22:50:39 <jfredett> why not?
22:51:04 <Figs> my dad still needs to get his crap off this machine, and that probably implies the need to do writing in NTFS
22:51:10 <Saizan> sorear: have you built HAppS with ghc HEAD, by chance?
22:51:22 <Figs> seriously though
22:51:23 <jfredett> its pretty easy to do- back up the stuff, install from liveCD, Windoes goes poof, QED.
22:51:23 <jre2> I personally can't understand how people can do development on non *nix platforms to be honest.  the lack of a terminal, shell, and basix unix utilities is pretty detrimental to productivity
22:51:26 <Figs> I'd love to format the disk
22:51:31 <edwardk> dons: would it be possible to get lambdabot to join ##logic for the near-to-long term?
22:51:38 <Figs> jfredett: I DON'T HAVE ENOUGH SPACE :)
22:51:42 <edwardk> or is she overbooked?
22:51:44 <sorear> Saizan: No.  I've tried, but it depends on HaXml which depends on pretty-in-base
22:51:53 <jfredett> Figs: THAT SUCKS! :D
22:51:53 <sorear> edwardk: no, she's got space
22:51:56 <glguy> jre2: if your development environment is .NET, it's pretty easy to get by
22:52:00 <Figs> IT DOES :P
22:52:01 <edwardk> sorear: cool
22:52:08 <jfredett> okay, enough yelling. :/
22:52:11 <Figs> kk
22:52:12 <Figs> :)
22:52:15 <jfredett> it hurts my throat
22:52:26 * jfredett coughs, sputters, and passes out
22:52:30 <Figs> you don't need to lick the keyboard
22:52:41 <Figs> your fingers will do fine ;)
22:52:50 <edwardk> my lambdabot has suffered a bit from me upgrading ghc on the machine its on, but not recompiling it
22:52:52 <jfredett> Figs: I've got this tick, everything I type I have to say
22:52:55 <Figs> ... that sounded quasi-dirty
22:53:10 <edwardk> and i just can't bring myself to burn 3 hours to fix it
22:53:10 <jfredett> so all caps implies yelling
22:53:18 <Figs> wow, I hope you never decide to use google to search for porn :P
22:53:36 <jfredett> that said, if you ever see someone yelling at his computer screen while typing on IRC
22:53:42 <Figs> hehe
22:53:43 <jfredett> you'll know who it is
22:53:46 <jre2> jfredett: when you say something inDroopyCamelCase do you pronounce it all droopy-like?
22:53:46 <Figs> what country are you in?
22:53:53 <shachaf> jfredett: Be flexible... It can also mean that you talk LIKE DEATH.
22:54:06 <Saizan> sorear: ah, i'm trying with 6.7.20070518 and i get to make the "impossible happen", you know if i can build base from the 6.6.1 tarball without recompiling GHC as well?
22:54:14 <jfredett> jre2 no, thats just normal words
22:54:34 <jfredett> shachaf: I need to read discworld- (I assume thats the death to whom you are referring)
22:54:36 <Figs> how do you say _emphasized_ words?
22:54:44 <jre2> jfredett: make hsssing snake sounds for_snake_case ?
22:54:46 <sorear> Saizan: base has extremely intimate knowledge of GHC.  you don't want to mix and match versions
22:54:48 <shachaf> jfredett: It is.
22:54:52 <jfredett> Figs: with emphasis
22:54:59 <Figs> :P
22:55:09 <jfredett> jre2: _yessss_
22:55:11 <Figs> _How_ _About_ _Stupidity_?
22:55:30 * Figs is making an ass of himself now
22:55:35 <Figs> heehaw!
22:55:38 <jfredett> Yes, he is.
22:56:08 <Figs> shoot
22:56:16 <Figs> I've been sitting here waiting for my program to download
22:56:19 <Figs> then I just realized...
22:56:21 <jfredett> okay, time for sleep
22:56:21 <Saizan> sorear: no, i'd use it with my 6.6.1 but i need to make a little edit in it
22:56:24 <Figs> I didn't click download
22:56:27 <Figs> by jfredett
22:56:31 <Figs> *bye
22:56:32 <jfredett> I get to read Proofs and Types in the morning.
22:56:34 <jfredett> :)
22:56:42 <Figs> hehe
22:56:52 <Figs> sounds interesting
22:57:10 <jfredett> I got it in dvi, so it even looks all purty, pdf just doesn't look as crisp as dvi.
22:57:34 <Figs> dvi?
22:57:44 <jfredett> its an output format
22:57:50 <jfredett> like postscript or pdf
22:57:50 <shachaf> Figs: DeVice-Independent.
22:58:02 <Figs> ah
22:58:04 <jfredett> shachaf: thanks, I couldn't remember the acronym
22:58:07 <jre2> Figs: the default output for latex usually
22:58:21 <jfredett> well, abbreviation, i guess.
22:58:34 <jfredett> abbrevronym. there we go
22:58:40 <jfredett> anywho, gnite
22:58:45 <Figs> bye
22:59:11 <dfranke_> What's up with Haskell'?  The website still says it was supposed to come out last September.
23:00:27 <Figs> I swear I want to kill windows now
23:00:42 <jre2> do it
23:01:10 <Figs> uninstalling Acrobat Reader makes my computer want to reboot!
23:01:12 <Figs> wtf!!!
23:01:22 <Figs> -and- I have to close Firefox?
23:01:23 <Figs> wtf
23:01:30 <Figs> ergh
23:01:35 <shachaf> Figs: Don't believe it, they all lie about rebooting anyway.
23:01:36 <jre2> -and- you don't have an xterm
23:01:42 <shachaf> s/they all/most of them/
23:01:46 <jre2> or zsh
23:01:50 <dfranke_> Figs: wow, that's enviably minor problem.  I discovered the Compatibility Files "feature" yesterday.
23:01:55 <dfranke_> that's an*
23:01:59 <Figs> ?
23:02:06 <dfranke_> ah, you haven't heard about this?
23:02:10 <Figs> no
23:02:11 <dfranke_> (#haskell-blah)
23:02:28 <dons> ?join ##logic
23:02:37 <dons> edwardk: yeah, just remind me to stick it in the conf file
23:02:41 <jre2> also, my filesystem handle case senstivity properly. how can anyone not find that aspect of windows downright laughable?
23:03:04 <dons> ?seen lambdabot
23:03:05 <lambdabot> Yes, I'm here. I'm in ##logic, #haskell-icfp07, #friendly-coders, #dreamlinux-es, #xmonad, #unicycling, #perl6, #parrot, #oasis, #jtiger, #haskell-soc, #haskell-overflow, #haskell-blah, #haskell, #
23:03:05 <lambdabot> ghc, #gentoo-uy, #gentoo-haskell, #darcs and #scannedinavian
23:03:27 <dons> edwardk: ok, its in the conf file too
23:09:46 <dons> so 7 libraries were uploaded this week.
23:09:53 <dons> > 7 / 350
23:09:55 <lambdabot>  2.0e-2
23:10:54 <dons> so ... does 2% of the community write libraries for the other 98%?  :}
23:11:24 <Figs> probably
23:11:51 <dons> so library writers are 1/50 programmers?
23:12:11 * Figs prods visual basic
23:12:19 * glguy is glad he slipped into a small library before dons compiled these numbers
23:12:22 <glguy> ;)
23:13:03 <dons> yeah, and there's dolio's on its way too
23:13:22 <dons> but i think we could easily squeeze out a few more libs each week
23:13:34 <dons> currently its about 1 release a day, i think (?)
23:15:19 <brad_> is there a way for us to make corrections in hoogle?
23:15:32 <brad_> i notice for getArgs it tells me it is in System, not System.Environment
23:15:58 <glguy> this is some momentum at Galois to push out some of the libraries
23:16:55 <glguy> hopefully that will help keep the number up :)
23:18:23 <dons> glguy: yeah :)
23:18:29 <jre2> dons: I think I noticed you polling the other day- what did you find out was the big reason people don't write libraries?
23:18:34 <dons> galois should be able to churn out one a week at least :)
23:18:43 <Figs> afc bbl
23:18:46 <Figs> bye
23:19:00 <dons> jre2: hmm, lack of experience writing binding to C, combined with people not missing anything
23:19:14 <dons> so people aren't really writing bindings for the sake of it ... yet
23:19:27 <dons> they tend to just do things they need, and most things are sort of covered, or else are too big to begin
23:19:45 <dons> but, we are getting 7 a week or so on to hackage.
23:20:04 <dons> so i think thigns are definitely getting better
23:20:20 <jre2> dons: sounds pretty good, but that means most still do 0/year
23:20:25 <dons> http://hackage.haskell.org/packages/archive/pkg-list.html  is getting pretty decent.
23:20:28 <dons> jre2: right.
23:20:38 <dons> there's about 20 people doing most of the libs
23:20:46 * jre2 hopefully will be leaving the 0/yr group shortly
23:20:47 <sorear> dons: where pretty decent means verging on too long to read.
23:20:49 <dons> and another 2000 on the mailing list
23:21:00 <sorear> which is in a way just as bad as having no libs...
23:21:03 <dons> sorear: yeah, actually. hmm. we'll need to typeset it a bit differently
23:21:24 <dons> we should publish the list of people uploading libraries
23:21:47 <jre2> dons: figure recognition might encourage them? heh
23:22:31 <dons> yeah, i reckon. award a 'haskell hacker' badge or something :)
23:22:45 <dons> so people know you're *expected* to contribute back to the community
23:22:52 <dons> that's what I'd like to encourage
23:23:01 <jre2> dons: reinstate the 'Knights of the Lambda Calculus' badges
23:23:23 <dons> mmm :)
23:23:37 <dfranke_> I thought Sussman was still giving those out.
23:23:57 <jre2> dfranke_: oh, perhaps I misread the wikipedia page
23:24:10 <dons> here's the people currently registered to upload to hackage , http://hackage.haskell.org/cgi-bin/hackage-scripts/list-users
23:24:10 <lambdabot> Title: HackageDB: registered users
23:24:47 <dfranke_> jre2: I think you read it correctly, but I also heard from someone who claims to have recently received one.
23:25:31 <dons> there's also a pretty large blogger community, but few of them also write libraries
23:25:56 <wli> That reminds me, I need to get a blog going.
23:25:57 <dons> so, its an optimisation problem. how to get more people writing tutorials, and writing code, and how to get more code out of those who are doing so already
23:26:04 <jre2> dons: speaking of which, I appreciate the work aggregating the various blogs
23:26:24 <dons> yeah, sort of turned into a large tutorial database, didn't it? :)
23:26:39 <dfranke_> those badges don't quite fit Haskell though.
23:26:40 <dons> its looking pretty good, http://haskell.org/haskellwiki/Blog_articles
23:26:41 <lambdabot> Title: Blog articles - HaskellWiki
23:26:52 <dfranke_> we can't write the Y Combinator.
23:27:15 <dons> yeah, any badge should have a type annotation or something
23:27:31 <jre2> an interesting question might be, of the people not writing libraries, how many of them are unable to do so due to insufficient knowledge rather than time/motivation?
23:27:31 <dons> Knights of the Monadic Bind
23:27:38 <dfranke_> although, on that note... has adding infinitary types to Haskell ever been considered?
23:28:04 <dons> jre2: yes. we're doing a bit to make it easier for those with time and motivation -- hackage, the new community server, and so on
23:28:15 <dons> so now, what about those who'd like to, but can't yet due to skill
23:28:19 <dons> how do we help those guys
23:28:28 <dons> is documentation/examples enough?
23:28:33 <dfranke_> The haskell.org logo seems like it would make a good pin.
23:28:43 <dons> do we need hackathons (online, or in real life) where we give mentoring advice?
23:28:54 * glguy would like that
23:29:09 <dons> the SoC is pretty useful for getting people trained up
23:29:19 * wli checks out the numerical linear algebra libraries.
23:29:32 <dons> it takes hmm, 3 months then to get someone into the community and releasing code, at a minimum
23:29:42 <glguy> I've got a week of professional development to allocate to something
23:29:54 <dons> glguy: run a west coast haskell hackathon?
23:30:19 <glguy> I don't know if I'm ready to head one up yet :)
23:30:30 <glguy> I'd like to go to one first
23:30:32 <dons> oh, they're easy :) the oxford one went really well
23:30:35 * sorear works on understanding linear logic
23:31:01 <dons> glguy: we really should start a west coast FP group. can't let london and nyc have all the fun
23:31:17 <dons> then we can do talks + hacking + mentoring regularly
23:31:35 <glguy> Galois has those things regularly :)
23:31:40 <fy__> West coast of which land mass?
23:31:47 <dons> Australia.
23:31:49 <dons> oh, no. not .au
23:32:03 <dons> i wonder if there's any haskellers in Perth?
23:32:07 <wli> GSLHaskell seems to do what I want for the most part.
23:32:09 <glguy> there is more than one??
23:32:13 <jre2> I can't believe I missed the NYC one just a few weeks ago (working here for the summer). don't get chances like that in the midwest sadly
23:32:17 <wli> dons: Where on the West Coast?
23:32:39 <dons> wli, i was thinking Portland, since glguy and I will be there, as are a few others.
23:32:54 * wli is in Portland, OR as well.
23:33:02 <dons> oh, there we go :)
23:33:27 <dfranke_> It looks like I might be entering the ICFP this year.
23:33:45 <dons> got a team together, dfranke_ ?
23:33:49 <dfranke_> The bad news is that I'll probably be using Scheme, because the prospective team is in the MIT / Paul Graham orbit.
23:34:01 <glguy> Portland Stat Univ. has a lot of Haskell activity
23:34:06 <dfranke_> I'm going to beg and plead with PG to join the team and let us use Arc.
23:34:09 <dons> ah , silly people -- don't they know that bugs found after submission lead to instance disqualification?
23:34:22 <dons> so you better have a decent test suite set up :)
23:34:52 <dons> 'all bugs removed within 3 days' is a pretty good argument for static typing.
23:34:58 <dfranke_> I'll also try to recruit RTM.  That would be awesome.
23:34:59 <dons> there's simply not enough time to find bugs lazily
23:35:18 <jre2> dons: so how do we tackle the libraries which people see as too overbearing
23:35:25 <dons> they're a bit harder. hmm
23:35:36 <dons> you need several people usually, teams of 3 or so, with one domain expert
23:35:41 * wli has worked out very large chunks of an algorithmic he's been working on for a long time.
23:35:42 <dons> or, automated tools
23:35:49 <wli> +problem
23:35:50 <dons> like c2hs for gtk2hs
23:36:04 <dons> or say, dominic for the crypto lib -- domain expert
23:36:26 <dons> small things, like binding to smaller C libs, can be done by people who neither use the lib, nor are experts in it
23:36:48 <dons> it would perhaps be a matter of identifying the key large projects, then forming a strike force of interested people
23:37:30 <dons> but i'd be happy just encouraging a lot more smaller libs to be bound
23:37:37 <wli> Ncurses or equivalent bindings would be handy because the sorts of things where I'd use ncurses I write in Haskell.
23:37:53 <dons> yeah, that'd be an easy one -- i should do it. we've got 3 curses bindings already
23:37:54 <dfranke_> Ncurses would be a pain.
23:37:57 <sorear> dons: SPJ doesn't write code he's not going to use because he knows he won't find the right design space spot.
23:37:58 <dons> ?where hscurses
23:37:58 <lambdabot> http://www.informatik.uni-freiburg.de/~wehr/haskell/
23:37:58 <dfranke_> It does so much in the CPP.
23:38:01 <dons> ?where hmp3
23:38:01 <lambdabot> http://www.cse.unsw.edu.au/~dons/hmp3.html
23:38:10 <dons> ^ has a binding i'd start with
23:38:12 <Svrog> out of curiosity, why is it a big deal to get heaps of libraries written?
23:38:39 <dons> sorear: yeah, you need an app in mind for more exploratory bindings
23:38:50 <dons> but say, for crypto, we know how to do that without any help
23:39:04 <jre2> Svrog: 1) attractcs more people to the community
23:39:07 <wli> Svrog: Language popularity.
23:39:10 <dons> Svrog: to ensure we can keep using haskell
23:39:25 <jre2> Svrog: (the best reason) 2) employers might let you use it for work then
23:39:26 <Svrog> wrapping heaps of c libs for use from haskell, i think a large chunk of them would just end up as junk
23:39:37 <dons> to ensure the haskell project succeeds, basically.
23:39:53 <Svrog> mostly cause most such bindings are very naively written
23:39:59 <wli> Well, s/succeed/continues to exist/
23:40:12 <dons> you'd want to ensure they were at least performant, yes, Svrog
23:40:25 <wli> dons: What about packaging?
23:40:37 <dons> i don't think its in any danger of disappearing -- haskell -- purely because of the research backbone
23:40:48 <dons> if anything, there's more researchers working on haskell now than there used to be.
23:41:01 <dons> its pushing into the commercial areas we want to enable
23:41:11 <wli> dons: Which are those?
23:41:21 <dons> which are what?
23:41:28 <dons> packaging, we have cabal and hackage.
23:41:32 <wli> dons: Which are the commercial areas you want to enable?
23:41:51 <dons> i think larger projects where people currently use say, python or erlang.
23:41:54 <dons> not nec. web apps.
23:42:13 <dons> systems.
23:42:18 <wli> dons: Any examples of such areas where people use Python and/or Erlang?
23:42:51 <dons> i hardly see any reason to use python -- as a "perl for larger systems" we could easily use haskell for similar things.
23:42:51 <wli> dons: "Systems" is kind of vague. I don't see much potential to write Linux kernel modules in Haskell (though there is FuSE...).
23:42:56 <sorear> personally, I'm inclined to think having tons of libraries would scare people away
23:42:58 <dfranke_> I'd be curious to see a design of something alnog the lines of Haskell on Rails.
23:43:06 <Svrog> i agree with sorear
23:43:07 <dons> you sure. kernel modules have a pretty big potential -- there's work on that in fact
23:43:10 <dons> due to the security aspect.
23:43:14 <Svrog> especially if they are of poor quality
23:43:15 <sorear> dfranke_: #happs maybe?
23:43:26 <dfranke_> RoR depends heavily on reflection and dynamic typing.
23:43:29 <Svrog> for example opengl bindings for haskell
23:43:39 <dons> yes, i am presuming the libs are of reasonable quality. i.e. they should be usable
23:43:48 <sorear> Svrog: We have good opengl bindings.
23:43:56 <dons> we should be able to just do anything we want, without needing to write a new binding to some system.
23:43:56 <sorear> @docs Graphics.Rendering.OpenGL
23:43:57 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/OpenGL/Graphics-Rendering-OpenGL.html
23:44:02 <dons> any system worht using, should have a binding to it.
23:44:02 <wli> dons: I just had a discussion with Al Viro about passing supercombinators into the kernel etc.
23:44:04 <sorear> they're even in the code.
23:44:07 <Svrog> well.. for one, it's a very direct wrapper around opengl that feels too low level from haskell
23:44:13 <sorear> *core
23:44:14 <dons> so you can freely use haskell for any project you could conceive of
23:44:27 <Svrog> and worse yet, unless i missed something the latest version provides opengl 2.1 functionality but
23:44:38 <dfranke_> http://www.cis.upenn.edu/~stevez/papers/LZ06a.pdf applied to kernel modules = FLASKell?
23:44:41 <Svrog> in an all or nothing kinda way
23:45:01 <jre2> Svrog: opengl is a very low library
23:45:02 <Svrog> so you cannot use things that have been incorporated into opengl 2.1 that were previously extensions, as extensions
23:45:13 <edwardk> dons: thanks
23:45:34 <dons> Svrog: so you're asking for quality bindings only?
23:45:39 <dons> comprehensive bindings?
23:45:52 <Svrog> meaning to use some of the features that have been common for a few years already you either need a top of the line graphics card supporting opengl 2.1
23:45:54 <dons> or would you settle for the ability to add further bindings yourself, for missing parts of large systems like opengl?
23:45:59 <Svrog> or you need to write your own wrappers
23:46:02 <Svrog> for opengl
23:46:22 <Svrog> dons: yes - i think a smaller number of quality libraries would be better than a large number of bad ones
23:46:35 <dons> also, the more people we get writing libraries, the more skilled at haskell those people become -- meaning they're more likely to use it at work
23:46:36 <sorear> wasn't it SPJ who said avoid success at all costs?
23:46:42 <dons> so part of it is just *training* people up to haskell competency
23:46:53 <dons> so you feel capable of using it for your new work project
23:46:54 <Svrog> perhaps peer reviewed libraries - libraries that people agree are consistent, well designed, etc
23:46:58 <jre2> Svrog: what about a large number of lower level bindings and then higher level libraries on top of them?
23:47:22 <dons> yes, i'm thinking of pretty much mechanically generated bindings to smaller C libs
23:47:29 <dons> you could probably do 50 libs that way
23:47:50 <dons> they'd be 1-3 day tasks, part time
23:48:02 <wli> Well, I just cooked up an algorithm for rational splines not based on homogeneous coordinates.
23:48:21 <dfranke_> Haskell FFI is good enough that if I want access to a small C library I'll just write the bindings on-the-fly.
23:48:26 <dons> and as people write libs, they document how they do it, to bring more skills into the community
23:48:29 <dons> dfranke_: yes
23:48:36 <Svrog> jre2: i dont really have a problem with low level bindings as long as they are done properly - although many low level bindings just feel awkward from haskell
23:48:52 <dons> http://haskell.org/haskellwiki/Wanted_libraries#Libraries_to_package
23:48:54 <lambdabot> Title: Wanted libraries - HaskellWiki, http://tinyurl.com/26rt82
23:48:57 <Svrog> awkward to the point that you may as well do that stuff in c
23:49:06 <dons> please add haskell projects that should be packaged up, and C lib sthat would be useful to bind
23:49:09 <wli> Svrog: Get a low-level binding going, put a high-level one atop it?
23:49:20 <dons> what do people wish they'd been able to use, but couldn't?
23:49:30 <dfranke_> ImageMagick.
23:49:35 <dfranke_> that's not small.
23:49:36 <Svrog> wli: thats what jre2 just suggested
23:49:36 <jre2> dons: what about making a bounty page of requests for bindings? because if, say, I had free time that I wasn't already spending on a personal project, I wouldn't know what would be most useful
23:49:49 <jre2> dons: nevermind, I wrote too slow
23:49:59 <dons> yes, that's what i want to do. the above page was supposed to be an attempt at a bounty page/or wanted list
23:50:39 <wli> Are any of the database libraries packaged?
23:50:44 <dons> several, yes
23:50:51 <Svrog> the thing about doing low level bindings and then high level ones on top of that, it's really no different to doing the low level stuff in c and then high level haskell stuff on top of that
23:50:51 <wli> Excellent.
23:51:04 <dons> http://hackage.haskell.org/packages/archive/pkg-list.html#cat:Database
23:51:06 <lambdabot> http://tinyurl.com/yqov7f
23:51:21 <dons> deusche bank uses hdbc, iirc.
23:52:01 <jre2> dons: yea, just a list you could sort by category or perhaps by votes or something simple to get a rough idea
23:52:07 <dons> in fact, 'The Directional Credit Trading group uses Haskell as the primary implementation language for all its software'
23:52:28 <dons> jre2: also, such lists *must* have been compiled for other language communities
23:52:47 <dons> the ruby guys have bindathons as part of their weekly puzzle challenge, iirc
23:52:56 <dons> every few weeks the challenge is to bind to some lib
23:53:02 <dons> so everyone gets practice writing new libraries
23:53:07 <jre2> nice
23:53:15 <dfranke_> I think Haskell's libraries are already on par with Ruby's.
23:53:21 <dons> and people get confident they can solve any work problem in rub^h^h^h haskell too
23:53:48 <dons> so what resources do people need to be able to use haskell for anything ?
23:53:56 <Svrog> ruby is far more accessible than haskell for most people
23:54:16 <dfranke_> Haskell has a smaller, smarter community than Ruby.
23:54:22 <dons> sure, its just another ad hoc imperative scripting language  :)
23:54:28 <Svrog> yes
23:54:30 <Svrog> and yes
23:54:33 <dons> dfranke_: i like to think we're more agile ;)
23:56:15 <dfranke_> in fact I'd say that we have the smartest community of any language that attempts to be for production.
23:56:32 <dons> i think we're getting there with introductory documentation. but do we need more material on solving various problems in haskell? or more on how to write FFI bindings? what kind of things to people want to do, but can't/don't know how to od?
23:57:40 <dfranke_> I don't think we're nearly there with introductory documentation.
23:58:07 <dons> what's missing? i've see people saying that , eg. the wikibook is truly excellent, as far as community written documentation goes.
23:58:27 <dons> but maybe i'm not seeing the gaps -- since the stuff the core haskellers use is already documented.
