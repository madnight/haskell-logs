00:01:28 <ohub> Isn't it good that compiler spends time to compile things the proper way rather than being too hasty and doing sloppy job? :)
00:02:24 <dolio> Yes, well, it probably wouldn't be too presumptuous to say that OCaml's compiler also produces faster code in general, so... :)
00:03:01 <zak_> i really don't get how compile times can vary so much... ocaml and D seem to compile insanely fast, and produce pretty fast code, and everything else seems to really take it's time to compile
00:03:22 <Saizan> most of the time you can just use ghci to develop
00:03:23 <sorear> it's just that nobody else cared about compilation speed :(
00:03:36 <sorear> even ghci is too slow for me
00:03:52 * sorear is writing his own haskell compiler precisely because ghc is so slow.
00:03:59 <reffie> GHC/Base_split/Base__2.o(.data+0x0): multiple definition of `base_GHCziBase_zeze_closure'
00:04:01 <opqdonut> :)
00:04:03 <reffie> GHC/Base_split/Base__1.o(.data+0x0): first defined here
00:04:04 <reffie> god hates me
00:04:12 <zak_> i can't stand waiting for anything to compile... that's the main reason i use D :)
00:04:18 <osfameron> there was a complaint about compilation speed wrt ocaml on the Tenerife Skunkworks blog
00:05:50 <ohub> How slow machines are you using if compilation speed is a problem?
00:06:05 <sorear> ohub: 2.00GHz
00:06:19 <dons> oh, joelr always wants something to complain about.
00:06:28 <ohub> I mean I'm using 650MHz Celeron laptop for my Haskell learning and ghci is fast enough.
00:06:31 <dons> the ocaml compile does compile faster, but hey, so does gcc.
00:06:31 <zak_> is there any support for dynamic loading of compiled code [like web browser plugins] with GHC?
00:06:36 <dons> ohub: yeah, he /wasn't/ using ghci
00:06:44 <dons> zak_: yep, hs-plugins
00:06:45 <reffie> zak_ hs-plugin or something
00:06:46 <dons> and ghc-api
00:06:47 <zak_> even GCC compiles too slowly :)
00:06:48 <sorear> ohub: that's because your project is small.
00:06:48 <zak_> ah
00:06:52 <zak_> thanks
00:06:56 <dons> this is lovely haskell:
00:06:57 <dons> encode = map (length &&& head) . group
00:06:58 <dons> decode = concatMap (uncurry replicate)
00:07:06 <dons> anyone spot what that implements?
00:07:19 <sorear> yup
00:07:46 <Eelis> :src (&&&)
00:07:58 <sorear> I don't like hacking lambdabot because dons insists on testing (rightly) and testing requires me to wait half a minute per iteration for ghc to compute dependencies, and another 5 if it decides Config.hs was modified
00:08:04 <reffie> what's the advantage of using -split-obs?
00:08:05 <sorear>  @src
00:08:10 <Eelis> @src (&&&)
00:08:10 <lambdabot> f &&& g = arr (\b -> (b,b)) >>> f *** g
00:08:12 <reffie> -split-objs
00:08:12 <Eelis> thanks.
00:08:19 <sorear> reffie: Much smaller executables, 2MB not 20MB
00:08:41 <dolio> > (succ &&& pred) 1
00:08:42 <lambdabot>  (2,0)
00:09:36 <zak_> another thing.. is it possible to call GHC compiled haskell from C? [and how much manual binding would it take?]
00:09:55 <reffie> sorear for some reason if i have -split-objs it bombs as above
00:09:59 <dons> sorear: i'd argue 500k instead of 2M
00:10:06 <reffie> when building GHC/Base.lhs
00:10:13 <dons> 20M sounds unlikely, eve lambdabot without split objs ~`8M
00:10:34 <sorear> ok, at least I got the ratio about right :)
00:10:47 <reffie> sorear but it doesn't, if -split-objs is not there
00:11:14 <opqdonut> dons: it packs repeated characters? is it called run-length encoding or something
00:12:05 <reffie> someone really doesn't want me to have ghc on this laptop.
00:12:39 <sorear> you could use hugs
00:21:09 <dons> opqdonut: yeah
00:21:39 <opqdonut> some of your earlier "puzzles" have been more interesting :)
00:21:50 <opqdonut> but yeah, that is adorable
00:22:18 <dons> its just got such a nice haskell implementation
00:22:32 <opqdonut> yeah it has
00:23:15 <opqdonut> nice and point-free
00:24:38 <int-e> @g Using the FFI with GHC
00:24:38 <lambdabot> Maybe you meant: gazetteer get-shapr ghc girl19 google gsite gwiki . v
00:24:44 <int-e> @google Using the FFI with GHC
00:24:46 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/sec-ffi-ghc.html
00:24:46 <lambdabot> Title: 8.2. Using the FFI with GHC
00:25:54 <int-e> zak_: that page has an example of calling haskell code from C.
00:26:19 <zak_> thanks
00:27:32 <opqdonut> @girl19
00:27:32 <lambdabot> I have stolen about 50 msn and yahoo accounts
00:28:41 <profmakx> i can get shapr with lambdabot? Like... summon him :]
00:29:09 <opqdonut> yeah
00:29:18 <dons> http://cgi.cse.unsw.edu.au/~dons/blog/2007/07/31#rle
00:29:18 <lambdabot> Title: Haskell hacking
00:29:45 <dons> too easy ;)
00:30:23 <opqdonut> yeah
00:30:48 <profmakx> hehe
00:31:41 <dolio> Truly, demonstrates how much more verbose and arduous it is to program in a statically typed language. :)
00:31:58 <profmakx> i smell a little sarcasm there
00:32:03 <dons> heh
00:32:50 <dolio> Just a little.
00:33:02 <Japsu> Muah
00:33:14 <dons> I feel too cheeky to drop that by reddit, but someone should
00:33:19 <Japsu> I also implemented RLE/Look-and-Say a month ago
00:33:23 <dons> :)
00:33:32 <Japsu> needless to say, it took a little more lines... ^_______^
00:33:50 <Japsu> as I was completely unaware of the existence of the group function
00:34:01 <dons> ah, so you had to reimplement it?
00:34:03 <dons> ?src gropu
00:34:03 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
00:34:05 <dons> ?src group
00:34:05 <lambdabot> group = groupBy (==)
00:34:08 <dons> ?src groupBy
00:34:08 <lambdabot> groupBy _  []       =  []
00:34:08 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
00:34:08 <lambdabot>     where (ys,zs) = span (eq x) xs
00:34:46 <Japsu> yeah
00:35:06 <Japsu> https://pajukanta.fi/blog/2007/06/17/yksi-ykkonen-kaksi-ykkosta
00:35:11 <Japsu> it's in finnish but you see the code
00:35:29 <dons> https?
00:35:43 <Japsu> drop the s if you don't like https :)
00:35:54 <dons> we really should have a 'fi' translation for haskell.org
00:35:59 <Japsu> heh
00:36:02 <Japsu> I might see to it some day
00:36:11 <kfish> dons: typo in the 2nd last line "go out an sketch" s/an/and
00:36:11 <Japsu> I've done some open source localization.
00:36:16 <dons> kfish: thanks
00:36:31 <kfish> nice post :-)
00:36:31 <Japsu> mostly in KDE
00:36:40 <dolio> I've been reading too much of the comp.lang.functional thread which was cross posted to comp.lang.lisp, so there are tons of people bemoaning how statically typed functional languages prevent you (in unspecified ways) from building your programs up naturally and incrementally.
00:36:57 <dons> that's just totally bogus, given purity, laziness and (.)
00:37:03 <opqdonut> and type inference!
00:37:17 <dons> and `undefined'
00:37:25 <Japsu> undefined <3
00:37:28 <profmakx> ...and haskell for all
00:37:40 <wli> Well, compare the level of discourse from the dynamic typing crowd.
00:37:42 <dons> the whole point of laziness it to aid compositionality.
00:38:36 <TSC> I found that lisp's typelessness just allowed me to compose my functions in ways that didn't work
00:38:43 <dons> :)
00:38:46 <opqdonut> TSC: exactly
00:39:00 <opqdonut> i've never seen a haskell typing error that wasn't my fault :)
00:39:22 <kilimanjaro> I've never seen a lisp typing error that wasn't my fault :)
00:39:36 <opqdonut> (sure, some things require awesome typeclassa magic but i haven't bumped into those)
00:41:37 <dolio> Oh, and also, comp.lang.lisp has way more traffic than comp.lang.functional, so obviously there isn't much interest in statically type functional languages. :)
00:42:28 <glguy> what triggered the lisp/haskell conversation?
00:43:07 <Saizan> it has degenerated from a python/haskell one
00:43:14 <dolio> My bitterness?
00:43:31 <dons> dolio: heh
00:43:39 <kilimanjaro> Greenspun's 11th law?
00:44:10 <kilimanjaro> all silly python discussions deteriorate into an ad-hoc silly lisp discussion
00:44:18 <profmakx> *g*
00:44:47 <dolio> For what it's worth, Jon Harrop may have been the only ambassador for languages like Haskell and OCaml they've had, and he doesn't exactly set out to charm them.
00:44:53 <dons> :(
00:45:40 <kilimanjaro> There are plenty of ambassadors on reddit
00:46:04 <DRMacIver> I still think programmers should be equipped with shock collars which would activate every time one of these silly arguments about typing discipline crops up. :)
00:46:45 <kilimanjaro> That goes for PL debates in general
00:46:45 <glguy> The common ambassador on reddit seems to just make a mess of things, I wonder if the fact that someone is talking about a language outweighs the fact that they are wrong about it
00:47:15 <DRMacIver> kilimanjaro: Most debates on PL manage to be more civilised than the typing ones I think.
00:47:39 <DRMacIver> Well. Except OO vs. FP.
00:47:48 <profmakx> or java vs. c++
00:47:51 <kilimanjaro> DRMacIver, and syntax
00:47:51 <profmakx> or any other ;)
00:47:52 <glguy> nothing's worse than an OOer trapped in the corner
00:47:57 <glguy> in a battle he knows he can't win
00:48:16 <dolio> Or any battle involving qwe1234.
00:48:23 <DRMacIver> kilimanjaro: Hm. I'm not sure. I've noticed pointless disagreements about syntax. I've rarely noticed pointless multipage arguments.
00:48:32 * glguy doubts that qwe1234 actually reads people's responses
00:48:43 <DRMacIver> dolio: The existence of trolls is not evidence of the pointlessness of a discussion. ;)
00:48:54 <kilimanjaro> glguy, sure, it's easy for an OO guy to get out of a corner. Have you ever read "Design Patterns"? :D
00:49:13 <dolio> DRMacIver: I'm just saying, he's uncivilized to begin with. :)
00:49:14 <glguy> kilimanjaro: design patterns are the list i use to put them in the corner
00:49:22 <profmakx> "Yeah, I totally loved the single-ton"
00:49:33 <glguy> What's wrong with OO, hmm, let me open my GOF design patterns book
00:49:37 <kilimanjaro> glguy, ahh. I avoid debating OO guys honestly, I don't feel like keeping up with their jargon
00:49:38 <DRMacIver> dolio: Sure. :)
00:50:55 <dolio> Debating aspect-oriented guys is where the money is. :)
00:50:57 <Cale> I find it amazing that so many people managed to completely miss the point of design patterns.
00:51:39 <wli> Cale: There was a point?
00:51:49 <opqdonut> one should recognize emerging design patterns and not apply them
00:52:17 <Cale> wli: Yes, the point is that design patterns point out deficiencies in existing languages.
00:52:20 <DRMacIver> Cale: Didn't the GOF completely miss the (original) point of design patterns when they wrote their book? So there's a lot of tradition behind doing so. :)
00:52:28 <kilimanjaro> wli, sure, but my criticism of design patterns is that many are necessary because the standard OO languaes are difficult to use
00:52:45 <dolio> dons: Your blog article has been posted. The title's not going to win friends, though. :)
00:53:04 <opqdonut> "Haskell way better than python will ever be"?
00:53:05 <osfameron> kilimanjaro: see also Mark J Dominus on "Design Patterns Aren't"
00:53:16 <glguy> dolio: link?
00:53:25 <Cale> If you have some complicated structure that keeps recurring in code, and you can't abstract it away into some language construct, that's a flaw in your programming language.
00:53:28 <dolio> http://programming.reddit.com/info/2ay00/comments
00:53:29 <lambdabot> Title: shorter, faster, safer pseudo-Python (reddit.com)
00:53:44 <Cale> (like a function for example)
00:54:03 <osfameron> that's not the case for say, MVC though is it?
00:54:31 <osfameron> that's really a "have a pure core, have a world-interface, have display logic all neatly separated" rather than a language pattern
00:55:22 <glguy> "encode = map (length &&& head) . group
00:55:41 <glguy> will be immediate rejected by the python loyal as "too scary and complicated"
00:55:48 <osfameron> fwiw, the fact that the haskell version of RLE is shorter doesn't mean that it's easier to read
00:55:58 <glguy> even though the list comprehension example is nearly opaque
00:57:04 <Cale> osfameron: Why shouldn't you be able to define some MVC library which abstracts the communication between those components and enforces the pattern?
00:57:16 <glguy> "Who says static typing implies verbosity?" I give, who said that"
00:57:31 <Japsu> encode xs = map encodeGroup (group xs) where encodeGroup g = (length g, head g) <-- easier to read IMO
00:57:43 <glguy> is this in response to another blog posting?
00:57:51 <DRMacIver> The encode implementation is very readable once you're used to the tricks there.
00:58:06 <wli> map (length &&& head) . group is the way of the future.
00:58:12 <DRMacIver> I like the decode implementation though. :)
00:58:14 <glguy> DRMacIver: that isn't the target audience though
00:58:23 <DRMacIver> Yeah
00:58:25 <wli> DrMacIver: Do tell.
00:58:28 <dolio> Well, plenty of people do say that, although a lot that do are pretty ill informed.
00:58:38 <osfameron> Cale: I don't know... I'm sure you could with magic type hackery in haskell, but the point is that the *architecture* of it is valid for any language whether or not it's possible to enforce it in the compiler
00:59:17 <DRMacIver> wli: Well, it's mostly standard stuff - group, use of . for composition, etc. The use of &&& for tupling is a nice and less common trick.
00:59:17 <Cale> osfameron: Yes, sure, and you can shoehorn anything into any Turing complete language, if you want to work hard enough.
00:59:28 <wli> DrMacIver: concatMap (uncurry replicate)?
00:59:46 <Cale> But if there's something that you recognise as showing up repeatedly, it makes sense to look to change the language to make that easy.
00:59:50 <DRMacIver> Oh, no, I was talking about encode.
00:59:51 <glguy> concat . zipWith replicate
01:00:04 <DRMacIver> The way the decode works is obvious isn't it?
01:00:07 <glguy> err
01:00:14 <glguy> hmm, nevermind ;)
01:00:38 <Cale> (Or develop a library to factor it out, if you can do it)
01:00:45 <osfameron> Cale: ok - but how can you make "This is a model so only does modelly things" easier?  In haskell, fair enough, it's a pure function so it doesn't do IO.
01:00:55 <glguy> DRMacIver: is that your blog post?
01:00:59 <DRMacIver> No, it's not.
01:01:03 <dons> glguy: mine.
01:01:06 <dons> http://cgi.cse.unsw.edu.au/~dons/blog/2007/07/31#rle
01:01:06 <lambdabot> Title: Haskell hacking
01:01:16 <DRMacIver> Hence the URL. :)
01:01:20 <dons> hence the url
01:01:25 * glguy can't be bothered to "read the url"
01:01:29 <DRMacIver> I'm just saying it's a nice implementation.
01:01:33 <Cale> osfameron: Exactly, you need more control over effects in order to really enforce model-view-controller.
01:01:34 <osfameron> Cale: sure - you often have M, V, C base classes, which I suppose you could argue are part of the "language" you're programming in.
01:01:52 <wli> DRMacIver: first, second, left, right, (&&&), (***), and (|||) are function algebra that should become as basic as (,), either, maybe, and the like.
01:01:58 <dons> yeah, i agree
01:02:05 <dons> and then onto the applicatiive stuff
01:02:06 <DRMacIver> Yeah
01:02:33 <DRMacIver> I don't remember offhand what most of those do I have to admit. :) But the arrow operations are usually handy for functions.
01:02:34 <osfameron> ?src left
01:02:34 <lambdabot> Source not found. You type like i drive.
01:02:48 <Cale> And yeah, those attempts at factoring out MVC into libraries are the right thing, to the extent that they work. If they don't work for some reason, language designers should really be looking at why :)
01:03:13 <wli> Elevate the discourse. Elevate the level of abstraction. Hoist yourself into the stratosphere.
01:03:33 <wli> Code density is a very real manifestation of expressive power.
01:04:14 <DRMacIver> Yes. Although some trade off between expressive power and readability is beneficial. :)
01:04:26 <DRMacIver> (Haskell manages a pretty good middle ground between the two)
01:04:38 <sean_____> Does anyone know what "Internal Happy error" is supposed to tell me?
01:04:43 <wli> No, that's too naive.
01:05:11 <DRMacIver> oh?
01:05:19 <Saizan> one problem with Control.Arrow is that you end up with a lot of curry/uncurry sometimes
01:05:21 <dons> sean_____: i think that was a happy bug fixed recently? or it came up on the lists anyway, and there's a solution
01:05:36 <Cale> At the very least you should be able to exercise some control over the way that objects talk to one another in your system. I always see those UML diagrams and wonder why the heck they don't just have language constructs for specifying their system in that fashion.
01:05:56 <wli> DRMacIver: The real benefits you're trying to reap are for enormous projects.
01:06:17 <sean_____> dons: Awesome.  Is there a URL? I'm on mac os x, so darcs isn't really an option...
01:06:29 <glguy> sean_____: it's not?
01:06:29 <DRMacIver> No, the benefit I'm trying to reap is that I like to be able to read peoples' code. :)
01:06:48 <wli> DRMacIver: Bringing things down from 10 MLOC in some weak language down to something manageable (e.g. 25 KLOC) in a powerful one.
01:07:00 <wli> DRMacIver: 10 MLOC is unreadable by dint of sheer size.
01:07:06 <sean_____> glguy: no, darcs just plain does not function on a case-insensitive file system (which steve jobs cursed me to have)
01:07:26 <glguy> sean_____: can't you make os x case sensitive?
01:07:52 <sean_____> glguy: yeah, but not without a complete reinstall.  there's no way to convert an existing partition.
01:07:56 <glguy> ah
01:07:59 <DRMacIver> Sure. Expressive power often helps readability in the large.
01:08:10 <wli> DRMacIver: The micro-level examples like RLE are not really the point.
01:08:10 <ozone> sean: you can just make a case-sensitive HFS+ disk image
01:08:24 <hpaste>  sorear pasted "Who needs randomized testing? :P" at http://hpaste.org/1986
01:08:32 <ozone> and darcs should be OK on mac os x, there are a lot of darcs users on that platform
01:08:54 <sean_____> ozone: and just mount it and use it?  I hadn't considered that.  I'll have to try it.
01:09:07 <DRMacIver> But if each of those 25 kloc reads as $%@ foo/bar/baz <---- [1, 2, 3] ! then you've not gained much readability even with the linecount decrease. :)
01:09:11 <sean_____> I'm sure darcs works fine as long as I give it case sensitivity :
01:09:13 <DRMacIver> (Yes, I'm thinking of the APLs)
01:09:17 <ozone> yeah, it works fine.  go to disk utility and make a sparse disk image
01:09:40 <opqdonut> sean_____: impressive tail you have there
01:10:32 <wli> DRMacIver: Anyway, typeclasses, higher-order functions, GC, higher-order modules (citing ML here), monads, etc. are where it really matters.
01:10:56 <sean_____> opqdonut: :) I'm determined to be sean, no matter how many underscores it takes
01:11:04 <sorear> dons: And yes, I'm well aware it probably took *you* less than twenty minutes. :)
01:11:19 <DRMacIver> No argument here. Those are all useful features.
01:11:34 <dolio> sorear: People who want to write their code in 3 lines instead of 30? :)
01:12:14 <DRMacIver> I'm not saying "Don't include features which might hurt readability". Language design for readability happens at a much higher level than individual features, and is much more concerned with syntax than semantics. :)
01:12:24 <sorear> Of course, my code is also completely untested.  (But the type-checker likes it)
01:12:45 <DRMacIver> "Warning: I have not tested this code, only provided it to be correct."?
01:12:48 <DRMacIver> err
01:12:50 <DRMacIver> proved
01:13:45 <wli> sorear: BTW Terminfo.lhs is coming along nicely.
01:13:54 <sorear> wli: Great!
01:14:17 <wli> sorear: How would you like the string capabilities decoded?
01:14:45 <sorear> What do you mean?
01:15:00 <sorear> In haskell, of course! :)  but I'm sure that's not what you meant.
01:15:00 <wli> (StringCapSetBackground,"\ESC[4%?%p1%{1}%=%t4%e%p1%{3}%=%t6%e%p1%{4}%=%t1%e%p1%{6}%=%t3%e%p1%d%;m")
01:15:12 <dons> sorear: neat, is that Coq?
01:15:33 <wli> sorear: That string capability is a sort of program in a strange language.
01:15:41 <sorear> dons: yes
01:16:34 <wli> sorear: Basically it needs to be interpreted as a program in order to properly instantiate it.
01:17:19 <sorear> wli: Right.
01:17:43 <wli> sorear: What do you want its representation as a program to be?
01:17:45 <sorear> wli: I was thinking HOFs.  String -> ([Argument] -> String)
01:18:02 <sorear> where some sort of compiling happens at the first stage.
01:18:08 <opqdonut> i hope you're building the interpreter int o the type system :)
01:18:14 <sean_____> ozone: thanks for the disk image tip.  darcs is working just fine now.
01:18:22 <wli> opqdonut: What do you mean?
01:18:25 <ozone> sean_____: no worries
01:18:39 <sorear> this is probably performance critical, so we'll definitely need to profile afterward, and possibly use some bytestringy approach
01:18:54 <wli> sorear: Well, in some sense they all take the same arguments; basically an environment of some sort.
01:19:53 <hpaste>  sorear annotated "Who needs randomized testing? :P" with "And now for the extractor output :(  (note, this won't work unless you supply definitions for ty and" at http://hpaste.org/1986#a1
01:20:15 <sorear> huh.  I'd forgotten hpaste clips the description...
01:20:36 <sorear> (from someone who was working about 3 lines further down earlier today)
01:20:47 <wli> sorear: I'm not sure about performance criticality; pty manipulation's performance demands are human reflexes, which are unable to discern performance beyond some rather modest point.
01:21:16 <wli> sorear: Gross inefficiency is inadmissible as always, of course.
01:21:29 <opqdonut> yeah, and drawing takes much more time than terminfo lookup, i'd fathom
01:21:36 <sorear> wli: Yeah, but when you have 20,000 characters on your sscreen like I do, even a millisecond per seek is unacceptable
01:22:20 <wli> sorear: I'd call 1ms seeks gross inefficiency.
01:24:04 <wli> Linear search and repetitive reevaluation are not in my programming repertoire.
01:24:26 <sorear> :)
01:25:08 <wli> opqdonut: Tell me more about this type system interpretation affair.
01:25:42 <opqdonut> wli: it was just a joke, with the type system being turing-complete and all
01:26:12 <wli> opqdonut: I was vaguely hoping there might be some way to generalize the printf trick. Shame.
01:29:39 <wli> The  parameter mechanism uses a stack and special % codes to manipulate it.  Typically a sequence will push one  of  the  parameters  onto  the stack  and  then print it in some format.  Print (e.g., "%d") is a spe-cial case.  Other operations, including "%t" pop their operand from the stack.   It  is noted that more complex operations are often necessary, e.g., in the sgr string.
01:33:14 <wli> Parsing this could be interesting.
01:45:33 <vincenz> re
01:46:58 <dons> ?users
01:46:58 <lambdabot> Maximum users seen in #haskell: 374, currently: 336 (89.8%), active: 7 (2.1%)
01:48:33 <vincenz> Hey dons :)
01:48:38 <vincenz> Interesting mini-article
01:49:01 <wli> vincenz: Where?
01:49:15 <vincenz> http://cgi.cse.unsw.edu.au/%7Edons/blog/2007/07/31#rle
01:49:15 <lambdabot> Title: Haskell hacking
01:49:19 <osfameron> anyone got any links to red-black tree zippers ?
01:49:25 <wli> vincenz: Thanks.
01:49:32 <earthy> that mini-article made me understand (&&&) ;)
01:51:50 <osfameron> I have an idea that the pattern matching on the path back to the root will make the rotation logic of red-black easier in zipper form
01:51:50 <wli> > (+1) &&& (*2) $ 4
01:51:58 <lambdabot>  (5,8)
01:52:07 <wli> That's the sort of example that made me understand (&&&)
01:52:23 <vincenz> > (snd &&& fst) (1,3)
01:52:24 <lambdabot>  (3,1)
01:52:25 <vincenz> or that one :)
01:53:08 <opqdonut> :t (&&&)
01:53:10 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
01:53:16 <opqdonut> that made me understand &&&
01:53:59 <wli> Is there an example of where (|||) is different from either?
01:54:15 <opqdonut> ?t either
01:54:16 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
01:54:19 <opqdonut> ?t (|||)
01:54:19 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
01:54:23 <opqdonut> gahh
01:54:25 <osfameron> eeek!  why does &&& have Arrows ?
01:54:27 <wli> :t either
01:54:29 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
01:54:30 <wli> :t (|||)
01:54:32 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
01:55:25 <opqdonut> well, ||| is more general but i think that's the only difference
01:55:32 <osfameron> given that you could write one of the examples above as:  (\s -> (snd s, fst s)) (3,1)  which seems quite basic?
01:55:54 <opqdonut> osfameron: (&&&) is combinatoric style
01:55:55 <vincenz> cause functions are a specific instance of arrows?
01:56:02 <vincenz> There may be other arrows?
01:56:15 <wli> Or for that matter when (&&&) is different from liftM2 (,) ?
01:56:33 <opqdonut> eh
01:56:37 <opqdonut> :t liftM2 (,)
01:56:40 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
01:56:45 <vincenz> > (id &&& (>>= (return . (+2)) [1]
01:56:45 <lambdabot>  Parse error
01:56:46 <opqdonut> that is very different
01:56:50 <vincenz> > (id &&& (>>= (return . (+2))) [1]
01:56:51 <lambdabot>  Parse error
01:56:57 <vincenz> > (id &&& (>>= (return . (+2)))) [1]
01:56:59 <lambdabot>  ([1],[3])
01:57:01 <vincenz> there you go
01:57:04 <vincenz> an arrow in the list monad :)
01:57:18 <wli> > (liftM2 (,)) (+1) (*2) 4
01:57:20 <lambdabot>  (5,8)
01:57:21 <vincenz> > (id &&& (>>= (return . (+2)))) [1,2,3]
01:57:22 <lambdabot>  ([1,2,3],[3,4,5])
01:57:34 <int-e> > let f1 = Kleisli (\_ -> [Left 23, Right 42]); f2 =  Kleisli (\x -> [x+1,x+3]); f3 = Kleisli (\x -> [x+2]) in runKleisli (f1 >>> (f2 ||| f3)) ()
01:57:36 <lambdabot>  [24,26,44]
01:57:39 <vincenz> > (id &&& liftM (+2)) [1,2,3]
01:57:41 <lambdabot>  ([1,2,3],[3,4,5])
01:57:46 <opqdonut> wli: ah yeah the reader monad
01:57:50 <int-e> an ||| that is not 'either'
01:58:00 <vincenz> wli: I just showed you
01:58:12 <vincenz> wli: (&&&) is like liftM2 (,) for Arrows that are functions!
01:58:20 <vincenz> wli: monads are also arrows, and you have other arrows as well
01:58:23 <vincenz> > (id &&& liftM (+2)) [1,2,3]
01:58:24 <lambdabot>  ([1,2,3],[3,4,5])
01:58:29 <vincenz> a list monad arrow
01:58:56 <wli> vincenz: What's a non-monadic arrow?
01:59:05 <vincenz> wli: monads with static state
01:59:08 <hpaste>  roconnor annotated "Who needs randomized testing? :P" with "I think section variables are better." at http://hpaste.org/1986#a2
01:59:19 <wli> vincenz: That's a monad. ;)
01:59:21 <vincenz> wli: no
01:59:25 <vincenz> wli: monads can not have static attributes
01:59:26 <wli> (>>>) seems to be like (.)
01:59:46 <opqdonut> wli: yes, these arrow combinator are generalisations of the function combinators!
02:00:02 <wli> vincenz: Any examples?
02:00:03 <ari> @src (>>>) (->)
02:00:04 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
02:00:09 <vincenz> (because functions are specific example of arrows!)
02:00:22 <ari> @src (->) (>>>)
02:00:22 <lambdabot> f >>> g = g . f
02:00:42 <vincenz> wli: http://www.haskell.org/arrows/
02:00:43 <lambdabot> Title: Arrows: A General Interface to Computation
02:01:15 <vincenz> wli: an example would be a parser
02:01:25 <vincenz> take parsec, (which is monadic iirc)
02:01:27 <vincenz> and you do
02:01:34 <vincenz> string "ab" <|> string "ad"
02:01:42 <vincenz> you can not get at the "ab" or "ad"
02:01:47 <vincenz> cause arrows have no static properties
02:01:51 <vincenz> so you can't factor out the "a"
02:01:57 <vincenz> erm
02:02:01 <vincenz> s/cause arrows/cause monads/
02:03:15 <wli> Okay, I don't understand that example.
02:05:55 <vincenz> @type group
02:06:02 <vincenz> @bot
02:06:03 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
02:06:03 <lambdabot> :)
02:07:04 <vincenz> wli: do you know parsec?
02:07:36 <vincenz> wli: is string "ab" <|> string "ad" clear to you?
02:08:57 <wli> vincenz: Yeah, try to parse "ab" and if that fails, try to parse "ad"
02:09:00 <kolmodin> dons: love your rle encode/decode code :)
02:09:29 <vincenz> wli: right, so it first tries to parse the entire string "ab" if that fails, (aka returns empty list or Nothing, don't remember the parsec monad exactly), it tries "ad"
02:09:39 <vincenz> wli: Now wouldn't it be nice if <|> could factor out equal prefixes?
02:09:48 <vincenz> wli: less backtracking to do
02:09:50 <wli> vincenz: You bet.
02:10:10 <vincenz> wli: Well sadly, since we're monads, we can not get at the string "ab" and "ad",  they're stored inside the string function closure
02:10:32 <vincenz> If, however, we had used arrows, we could've used different structures than functions, and then perhaps we could've extracted these values.
02:10:48 <earthy> which is exactly what the UULib Parser combinators do. :)
02:10:52 <vincenz> earthy: right :)
02:11:16 <wli> Why do the UULib combinators still have left recursion restrictions?
02:11:25 <earthy> do they?
02:12:32 <earthy> they get slow with left recursion
02:12:40 <earthy> but I think they can handle it these days
02:13:03 <jz1078> hello everybody, does anybody know how to make or get function like
02:13:22 <jz1078> sequenceT :: (MonadTrans t,Monad m) -> [t m a] -> t [m a]
02:13:23 <vincenz> jz1078: If you plan to paste code, use @paste
02:13:24 <vincenz> oh
02:13:53 <vincenz> @djinn (MonadTrans t,Monad m) =>  [t m a] -> t [m a]
02:14:17 <opqdonut> don't think djinn'll work
02:14:44 <vincenz> @type lift (sequence)
02:14:46 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Monad m, MonadTrans t) => t ((->) [m a]) (m [a])
02:15:32 <vincenz> jz1078: What would you use this for
02:15:47 * vincenz thinks that type is rather odd
02:15:49 <vincenz> basicall
02:15:52 <vincenz> you're lifting all your actions
02:15:57 <vincenz> @type (map lift)
02:15:59 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => [m a] -> [t m a]
02:16:03 <vincenz> there you go
02:16:11 <vincenz> @type (>>= map lift)
02:16:13 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => [[m a]] -> [t m a]
02:16:24 <jz1078> vincenz: in QuickCheck, i'm checking simple imperative language
02:16:25 <vincenz> @type (\x >>= return $ map lift x)
02:16:27 <lambdabot> parse error on input `>>='
02:16:37 <vincenz> @type (>>= \x -> return $ map lift x)
02:16:39 <lambdabot> forall (m :: * -> *) (m1 :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m1, Monad m) => m [m1 a] -> m [t m1 a]
02:16:48 <jz1078> i need state to generate sample
02:16:51 <vincenz> well
02:16:55 <vincenz> you basically want to map lift
02:17:02 <vincenz> lift = t m a -> m a
02:17:06 <jz1078> so i need function like frequencyT :: (MonadTrans t) => [(Int,t Gen a)] -> t Gen a
02:17:08 <vincenz> so something like
02:17:11 <RyanT5000> is there a javascript interpreter for haskell?
02:17:15 <RyanT5000> (or with bindings to haskell)
02:17:28 <vincenz> foo l = do { x <- l; return $ map lift l }
02:17:36 <vincenz> @type let foo l = do { x <- l; return $ map lift l } in foo
02:17:38 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => [m a] -> [[t m a]]
02:17:42 <vincenz> crud
02:17:44 <vincenz> @type let foo l = do { x <- l; return $ map lift x } in foo
02:17:46 <lambdabot> forall (m :: * -> *) (m1 :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m1, Monad m) => m [m1 a] -> m [t m1 a]
02:17:53 <vincenz> hmm
02:17:56 * vincenz sighs
02:17:57 <_roconnor> RyanT5000: YHC compiles to javascript ... sort of.
02:18:09 <vincenz> jz1078: never mind, that's the other way around, you want unlift, which I'm not sure is possible
02:18:57 <jz1078> vincenz: yes, i think so...
02:19:11 <RyanT5000> _roconnor: that's the reverse of what i want
02:19:47 <jz1078> vinzenz: so i have to make frequencyM :: (Monad m) => [(Int,m (Gen a))] -> m Gen a
02:20:06 <RyanT5000> _roconnor: i need to run remote code in haskell; hs-plugins is way too heavy (the total budget for the binary is at most 1 MB of disk space)
02:20:19 <vincenz> you mean
02:20:21 <vincenz> -> m (Gen a) ?
02:20:36 <jz1078> yes
02:20:44 <_roconnor> RyanT5000: you can use UM bytecode :P
02:21:08 <vincenz> jz1078: yes, that should work
02:21:19 <RyanT5000> _roconnor: lol i really want something with code already written in it; i don't want to, e.g., write SHA-512 in UM
02:21:35 <int-e> @index Gen
02:21:35 <lambdabot> Test.QuickCheck, Debug.QuickCheck
02:22:00 <vincenz> _roconnor: do you have any experience with theorem provers? (Coq, Isabelle, other?)
02:22:08 <_roconnor> RyanT5000: is there a mini-ML -> UM bytecode compiler available?
02:22:13 <RyanT5000> _roconnor: i wrote a nifty little GADT language, then discovered that it's virtually impossible to serialize/deserialize it without destroying most of the niftiness (for some reason haskell's type system doesn't work quite as well at runtime as at compile-time :P)
02:22:23 <_roconnor> vincenz: Proving stuff in Coq is my job.
02:22:26 <vincenz> _roconnor: if you want I have a front-end to miniml, which maps down to ANF
02:22:39 <vincenz> _roconnor: could you explain the difference between the differeont ones?
02:23:31 <_roconnor> betwen parameters and section variables.
02:23:31 <_roconnor> ?
02:23:31 <wli> vincenz: Adminstrative Normal Form?
02:23:31 <jz1078> vincenz: thanks, i thought solution with MonadTrans would be more general
02:23:31 <vincenz> _roconnor: no between Coq and Isabelle (and any other main ones)
02:23:31 <vincenz> wli: yes
02:23:46 <vincenz> wli: compiling from ANF to something lowlevel should not be too complex
02:23:58 <_roconnor> vincenz: ah well, I don't really know Isabelle, or very many other ones.
02:24:11 <doserj> Coq is constructive type theory, Isabelle is (usually) Higher-Order Logic
02:24:20 <vincenz> _roconnor: Well I'm not really familiar with any of them, so even a very fuzzy picture might help
02:24:37 <RyanT5000> _roconnor: Tamarin seems perfect: a javascript JIT in firefox
02:24:45 <RyanT5000> now to see how ridiculously annoying the interface is
02:25:08 <dons> _roconnor: you should write some more articles about extracting and using haskell components from Coq
02:25:34 <dons> maybe do a verified something in Coq, extract it, show how to slot the verified piece into a larger haskell wrapper?
02:25:38 <_roconnor> dons: I'm not certain extracint haskell components from Coq is all that useful at the moment.
02:25:42 <vincenz> doserj: So what derives from that?
02:25:54 <_roconnor> dons: you end up stuck with the Nat type.
02:26:01 <dons> _roconnor: is extraction of ocaml useful? or are none of the extractions useful really?
02:26:04 <int-e> jz1078: you don't win much compared to using frequency
02:26:14 <dons> you mean, a missing Nat type?
02:26:28 <_roconnor> dons: well maybe if you use coq's module system and extract to ocamls modules system, then you can use functors.
02:26:33 <_roconnor> dons: never really tried it.
02:26:54 <_roconnor> dons: I suppose extracting polymorphic functions in coq may not be so bad.
02:27:09 <_roconnor> dons: but you still miss out on all the type class goodness.
02:27:23 <_roconnor> dons: although I suppose you can wrap it up afterwards.
02:27:27 <vincenz> dons: someone bashing haskell: http://programming.reddit.com/info/2ay00/comments/c2aygz
02:27:28 <lambdabot> Title: shorter, faster, safer pseudo-Python (reddit.com)
02:27:36 <dons> vincenz: don't worry about it :}
02:27:39 <int-e> jz1078: because (Gen a) encapsulates a pure function so your monadic evaluation can not possibly depend on the random number generator - basically you end up with a combination of sequence and frequency.
02:28:03 <dons> vincenz: its a good news day, people can complain about hlists if they want, its a silly argument -- who uses hlists anyway?
02:28:48 <vincenz> dons: no, ,not that one
02:29:08 <vincenz> dons: he complains about the functions used, and then swhen I say they're std, says "oh sure, and then you'll make encode/decode std too and say they're obvious"
02:29:13 <_roconnor> @quote o'connor's law
02:29:13 <lambdabot> No quotes for this person. My pet ferret can type better than you!
02:29:26 <_roconnor> @quote roconnor law
02:29:26 <lambdabot> No quotes match. Take a stress pill and think things over.
02:29:30 <dons> vincenz: shrug. there's always someone whining on the intertubes
02:29:33 <_roconnor> where's my law?
02:29:46 <dons> we already have a crushing victory on this one I think ;)
02:29:50 <vincenz> doserj: So, since I'm not so at home with logic and such.  What is the main difference between using HOL and constructive type theory?
02:30:13 <doserj> good question :)
02:31:14 <doserj> I think, in the type theory version of Coq, types are first-class
02:31:16 <jz1078> int-e: yes, but those sequence and frequency depends on earliers decisions, if i use frequency i have to make all state dependent things earlier and then return frequency, it is not as convenient as it can be if i could access state within frequency
02:32:09 <_roconnor> I said it before and I'll say it again:
02:32:19 <_roconnor> As an online discussion of static types vs dynamic types grows longer, the probability of mentioning heterogenous lists approaches 1.
02:32:33 <vincenz> _roconnor: referring to the pythonista guy?
02:33:07 <dons> _roconnor: :)
02:33:24 <vincenz> doserj: Let me rephrase it.  I'm a total noob when it comes to logic (only reason I know type theory and such is cause I read a lot of papers, my original background is EE). Now I've been getting more interesting in logic, so I thought I could look at these two products (Coq + Isabelle).  Given I don't want to invest a lot of time in both them.  What is the main difference from a newbie's point of view between isabelle and coq.
02:33:34 <dons> implicit tags and no safety, versus explicit tags and safety. shrug
02:33:37 <DRMacIver> I decided the heterogenous lists comment was uninteresting so silently ignored it in my reply. :)
02:33:45 <vincenz> DRMacIver: thanks for commenting on that :)
02:34:04 <vincenz> DRMacIver: I was gonna say something like "head,lenght, map" std functionality or lists, "curry, uncrry" std functionality for tuple type
02:34:10 <int-e> jz1078: I don't know what you're hoping to accomplish. The only way I see to implement frequencyM uses sequence and frequency, at least without changing the Gen a type.
02:34:13 <vincenz> but then you had concatMap and group :)
02:34:34 <int-e> jz1078: that being said I can imagine frequencyM saving some typing.
02:35:27 <DRMacIver> vincenz: It's something I feel strongly about, as I've written a substantial chunk (well, as a proportion of my Haskell code as a whole) of code which looks very much like this. :)
02:35:51 <jz1078> int-e: yes, is there any other solution?
02:36:04 <RyanT5000> so, i don't suppose there's a spidermonkey binding for haskell?
02:36:58 <DRMacIver> I wonder if the heterogenous lists comment was in response to dons's remark that "We also get a generic implementation for free"
02:37:09 <doserj> vincenz: maybe one can say that coq is closer to dependant-typed programming languages, where you "type-check" your proofs
02:37:28 <earthy> coq *is* a dependently typed programming language.
02:37:41 <vincenz> earthy, doserj: so how does it differ from epigram
02:37:44 <doserj> and isabelle is a bit more interactive environment, where you are "searching" for proofs
02:37:56 <vincenz> doserj: oh, ,like "now try this approach" kind of style?
02:38:02 <int-e> jz1078: Gen a is basically (Int -> System.Random.StdGen -> a), a pure function. You can't get arbitrary monadic operations into that.
02:38:11 <earthy> vincenz: it is not build as such, so the facilities for programming are not as well developed
02:38:12 <vincenz> doserj: and it basically does all the itty gritty so you don't make writing mistakes on paper?
02:38:24 <earthy> however, it does provide a much nicer proof environment ;)
02:38:43 <vincenz> earthy: why is that?
02:38:52 <vincenz> earthy: due to the fact some features are left out that would make proving harder?
02:38:54 <earthy> coq was developed as a proof assistant
02:39:10 <earthy> therefore it comes with all manner of tools to assist making proofs
02:39:22 <vincenz> earthy: right, similarly you could port these tools to epigram?
02:39:27 <vincenz> earthy: or is there some roadblock in doing that
02:39:30 <earthy> these tools are not as present or as well developed in epigram
02:39:43 <earthy> I don't know enough epigram to judge on that
02:39:47 <vincenz> alright
02:39:51 <earthy> I *do* know that the support in coq is *huge*
02:39:58 <vincenz> Hmm
02:40:01 <earthy> making it less than practical. :)
02:40:08 <vincenz> So what would one use Coq for and what would one use Isabelle for?
02:40:12 <RyanT5000> i wish the epigram people had used "not emacs" as their IDE
02:40:23 <earthy> Coq and isabelle are used for roughly the same things
02:40:29 <earthy> they differ in the underlying logics though
02:40:40 <vincenz> earthy: Trying to get to a difference from a user perspective :/
02:40:46 <therp> ryan: why? I'd say it's a great choice.
02:40:46 <vincenz> Especially as a newbie who's evaluating which one to try.
02:41:09 <earthy> vincenz: if you want to try, try one that you can ask questions about in your direct environment. :)
02:42:03 * earthy seems to recall that some things in isabelle require writing ml directly
02:42:10 <doserj> vincenz: use that one which has the best library for your purpose :)
02:42:29 <earthy> whereas coq has its own vernacular to write the same things, thereby shielding you from the ml
02:42:41 <earthy> plus, what doserj says. :)
02:43:04 <earthy> oh, and I initially cut my teeth on coq, back in '96 or something
02:43:12 <earthy> so coq still feels nicer to me. :)
02:43:37 <earthy> (but that may also be my having been taught typed lambdacalculus by barendregt)
02:43:37 <vincenz> earthy: can not do
02:43:41 <vincenz> earthy: I work in DA, not CS
02:43:52 <earthy> DA==design automation?
02:43:58 <vincenz> nod
02:44:12 <earthy> hm. I'd take issue with that 'can not do'
02:44:14 <vincenz> EDA more specficially
02:44:24 <vincenz> earthy: as in, I don't have people in my direct environment :)
02:44:37 <vincenz> earthy: noone that I work with uses such tools.
02:44:40 <earthy> given that John Harrison does EDA at Intel and is one of the better known HOL developers. :)
02:44:47 <earthy> ah, that's a different matter entirely. :)
02:45:15 <earthy> in that case: just pick one that has a nifty feature you like :)
02:45:21 <vincenz> earthy: hmm, "EDA at intel" hehe. ..
02:45:22 <vincenz> sorry
02:45:33 <vincenz> earthy: right, hence my question, how do they differ :)
02:46:00 <earthy> well, coq is more polished, ISTR
02:46:09 <vincenz> Alright
02:46:28 <earthy> but the main difference is that Coq is just the 1 logic
02:46:40 <earthy> whereas isabelle really is a platform upon which to build logics
02:47:01 <vincenz> so why do so many people use coq over isabelle? purely due to support/community
02:47:03 <vincenz> ?
02:47:17 <doserj> onle the french use coq :)
02:47:22 <earthy> so there's isabelle/hol isabelle/isar isabelle/fol isabelle/zf
02:47:23 <doserj> *only
02:47:37 <earthy> the french use coq, the british and german isabelle
02:47:39 <earthy> generally. :)
02:47:50 <earthy> the americans use twelf or acl
02:47:56 <doserj> or pvs
02:48:02 <earthy> oh yeah
02:48:05 * vincenz is getting a flashback :|
02:48:13 <earthy> right. the proof vulgarisation system :)
02:48:36 <earthy> Bart Jacobs @ Nijmegen University once made it a hobby to prove True == False in pvs
02:48:47 <earthy> he had dozens of ways to do so at one point
02:48:58 <vincenz> oh right
02:49:02 <vincenz> twelf vs coq?
02:49:16 <earthy> I'd say go with coq
02:49:24 <earthy> nicer mathematically
02:49:47 <_roconnor> If you can manage to install Matita, it is probably superior to Coq.
02:50:03 <dons> for language work (esp. type systems) twelf is more suited, imo. better support and examples for doing languages in it
02:50:11 <dons> though isabelle gets used for a lot of that round here, these days
02:50:14 <vincenz> doserj: thanks, that helps :)
02:50:20 <vincenz> s/doserj/dons
02:50:31 <earthy> dons: yeah, that much is true
02:50:34 <vincenz> so: basic proofs of induction: Coq
02:50:45 <vincenz> generic mathematical proofs and trying to explore: Isabelle
02:50:50 <vincenz> semantic proofs: Twelf
02:50:57 <vincenz> that more or less an ok fuzzy mapping?
02:51:11 <earthy> fuzzy. :)
02:51:21 <earthy> ofcourse, you could also try your hand at Agda2. :)
02:51:29 <vincenz> earthy: not helping
02:51:35 * roconnor wonders where Mizar and HOLlight fit in.
02:51:52 <earthy> HOL really is not that different from isabelle
02:51:55 * doserj wonders about NuPRL
02:51:59 <vincenz> meh, this is like me being a haskell newbie and asking about concatMap, and being told to look up continuation monads
02:52:02 <vincenz> thanks a lot
02:52:08 <earthy> (actually, isabelle is a generalisation of HOL)
02:52:14 <earthy> HOL Light is a reimplementation of HOL
02:52:19 <earthy> mizar is the odd one out.
02:52:24 <earthy> NuPRL... I couldn't really say
02:52:41 <roconnor> I suppose Mizar is for mathematician friendly proofs and reasoning.
02:52:54 <roconnor> If you like set theory. (bleh)
02:52:56 <earthy> yeah, but much of that can also be simulated in HOL
02:53:05 <earthy> see e.g. Freek Wiedijk's stuff
02:53:28 <earthy> vincenz: the short of it: pick one, and play. :)
02:53:38 <roconnor> earthy: Freek is on vacation this week. ;)
02:53:40 <earthy> ofcourse, coq allows Haskell code extraction
02:53:58 <doserj> isabelle only allows sml code generation :)
02:53:59 <vincenz> earthy: right, but I'd like to pick one that is more fruitful to me.  So if you guys give me some generalities which might not be completely true but are fuzzily true, it'll help me in my exploration of this space :)
02:54:15 <earthy> yeah, we've just given them. :)
02:54:34 <vincenz> ok
02:54:52 * vincenz will start with coq then twelf then issabelle
02:54:56 <roconnor> vincenz: so, what are you going to pick?
02:54:59 <roconnor> ah
02:55:14 <roconnor> vincenz: what are your goals?
02:55:21 <vincenz> roconnor: get introduced into these systems
02:55:45 <vincenz> roconnor: I do not know enough about them to formulate goals that entail their use, but I can imagine I might in the future.
02:55:55 <roconnor> ah
02:56:05 <vincenz> Especially since I'd like to move into CS post-phd
02:57:02 <roconnor> dons: I remember not being able to prove the deductiont theorem in twelf because I didn't have induction :(
03:00:25 <wli> roconnor: Was it you that was working on Reed-Solomon codes?
03:01:18 <roconnor> wli: I was looking into them.
03:01:38 <roconnor> http://r6.ca/blog/20061207T200800Z.html
03:01:39 <lambdabot> Title: Digital Archive on Paper (Part I)
03:01:40 <wli> roconnor: Cool. How far along are you?
03:02:04 <roconnor> wli: I've more or less abandoned it as impractical.
03:03:20 <profmakx> has there been any work done on _non_-termination analysis for haskell programs? I wonder if that would make sense *scratches beard*
03:04:32 <wli> roconnor: Why?
03:05:49 <wli> profmakx: Ask ndm, I think I saw something in his webpages about it.
03:05:58 <roconnor> wli: It would take too many pages to put my coq proofs and stuff into my thesis.
03:06:16 <profmakx> will do
03:06:18 <tonfa> gug
03:06:25 <roconnor> profmakx: you mean productivity analysis?
03:06:30 <wli> roconnor: Ah, I was interested in them mostly for codec purposes.
03:07:15 <roconnor> wli: My problem is that I don't want to leave my thesis refering to an electoric source that can never be found.
03:07:33 <profmakx> roconnor: I know someone who did termination analysis for java programs. Though i know that might be a whole different beast i asked myself in which way that would make sense for haskell
03:07:48 <profmakx> roconnor: I dont exactly know what you mean by productivity
03:08:31 <roconnor> profmakx: a function like repeat is productive even though it doesn't terminate.
03:08:40 <roconnor> profmakx: while fix id isn't even productive.
03:08:47 <profmakx> ah well
03:09:16 <profmakx> it might be that this is just an instance of proveability of properties for some function
03:09:24 * roconnor puts his old cs263 paper back online
03:09:28 <roconnor> http://r6.ca/cs263/paper.html
03:09:30 <lambdabot> Title: Using LF for Encoding and Checking Formal Deductions
03:10:38 <roconnor> ``One useful meta-theorem about proportional calculus is the deduction theorem.
03:10:48 <roconnor> ``But with the given signature there is no object of this type.
03:11:02 <roconnor> ``This is because of LF has the weakening property. If one adds new objects to any signature in LF, the all the derivations still remain valid. However it would be possible to add an object to the signature of propositional calculus that would make the deduction theorem false. Therefore it must be impossible to find an object that proves the deduction theorem.
03:11:41 <roconnor> The weakening property is Twelfs greatest strength, and it's greatest weakness.
03:18:32 <MyCatVerbs> Good morning, #haskell.
03:21:14 * roconnor reads the python article.
03:21:19 <roconnor> ugh, ``Be careful though, these functions will only work when your data stream is not already a list of tuples -- if it is, you'll need to create a new class to store the packed data, but be wary that it comes with additional space overhead.
03:21:36 <roconnor> that's python for you I guess.
03:22:49 <profmakx> roconnor: are you talking about the RLE endcoding?
03:22:59 <roconnor> profmakx: yeah.
03:23:20 <profmakx> to say it with dons' words: polymorphism rocks :)
03:25:03 <wli> RLE is weak; generalize Huffman encoding so you get an M:N relation between codeword strings and source strings.
03:25:55 <roconnor> wli: You should write a blog post on using type level arithmetic to do huffman encoding on data. :)
03:26:20 <roconnor> wli: wait a moment
03:26:22 <wli> roconnor: I don't know much of anything about type-level arithmetic apart from being able to set up the classes etc.
03:26:28 <DRMacIver> roconnor: Note that that disclaimer was the result of a space saving encoding, not of the original implementation.
03:27:03 <roconnor> DRMacIver: less space, less safety.
03:27:09 <DRMacIver> Sure.
03:27:14 <DRMacIver> I'm not saying it's a good idea. :)
03:27:30 <DRMacIver> Although it could be for specific applications like encoding Strings.
03:27:34 <roconnor> DRMacIver: I gather the author things it is a good idea.
03:27:41 <roconnor> thinks
03:28:04 * DRMacIver shrugs
03:28:12 <DRMacIver> These python users believe all sorts of wacky things. ;)
03:29:02 <wli> roconnor: Well, the brute-force approaches basically check dictionary size + coded message size and search around to try to minimize it.
03:29:17 <roconnor> wli: isn't RLE fast to decompress?
03:29:22 <DRMacIver> The space saving is kinda worth doing though. I doubt I'd want to do it that way though.
03:29:34 <wli> roconnor: Sure, but it's just plain lame.
03:29:53 <DRMacIver> Especially as it's not really a trick you could pass over the wire.
03:30:05 <psykotic> wli: it's used in several compressors as a final part of the entropy encoding pass..
03:30:06 <DRMacIver> (Without doing something really stupid)
03:30:09 <roconnor> I believe the company I was working for was using RLE to compress video data 10 years ago.
03:30:11 <psykotic> wli: e.g. bzip2
03:30:24 <wli> DRMacIver: It's only a space savings if you've got long strings of the same crap.
03:30:28 <roconnor> I assume it was they needed to decompress a frame in 1/30th of a second.
03:31:06 <DRMacIver> wli: I'm talking about the space saving hack which results in the tuple issue which roconnor and I were discussing, not the space saving merits of RLE.
03:31:16 <wli> Basically you want to assemble a sort of source dictionary.
03:31:27 <wli> DRMacIver: I missed that part of the discussion.
03:32:19 <DRMacIver> It's very subtly encoded. :) You won't see it unless you've read the python RLE article.
03:33:07 <roconnor> wli: you certainly won't see it if you glace at the encode's API documentation :P
03:33:56 <roconnor> And it won't even be listed in the API documentation of the function that uses a function that uses the encode fuction.
03:34:03 <wli> Basically there's some mapping of source bitstrings to code bitstrings. There's an integrity constraint on the source bitstrings in that they have to actually cover the text. There's an integrity constraint on the code strings that they have to be unambiguously decodeable. From there minimize dictionary size plus coded size.
03:34:13 <wli> roconnor: I'm completely clueless.
03:34:31 <roconnor> wli: sorry, I was trying to take a dig at the python people.
03:34:57 <roconnor> that this issue is so subtle that people won't know it when using the function.
03:35:02 <wli> roconnor: Is this something to do with the Python RLE code breaking under certain circumstances?
03:35:04 <roconnor> and that makes it dangerous.
03:35:22 <roconnor> wli: The modified python RLE code breaks under certain circumstances.
03:35:47 <DRMacIver> Although note that it works fine in the original intended usage of RLEing strings. :)
03:36:00 <wli> roconnor: Presumably this is all Python stuff vs. the Haskell code?
03:36:19 <roconnor> wli: I'm specifically worried about Python.
03:36:38 <wli> Okay, I've not touched Python willingly ever, so...
03:36:55 <roconnor> or rather the programming methodology used in that particular python article.
03:37:03 <roconnor> http://www.builderau.com.au/program/python/soa/Run-length-encoding-in-Python/0,2000064084,339280649,00.htm
03:37:05 <lambdabot> Title: Run length encoding in Python - Program - Python - Builder AU, http://tinyurl.com/2pg2oy
03:37:26 <roconnor> DRMacIver: I'm not convinced the orgrinal is the intended usage.
03:37:42 <wli> I'm thinking of hammering out a more advanced compression method to put the Python bits to shame.
03:37:45 <roconnor> ``What we really want is a modified run length encoding function,
03:38:03 <DRMacIver> Hmm. Point.
03:38:05 <wli> Something concocted on the fly.
03:39:02 <DRMacIver> Actually, the python code's use of operator overloading and sum makes me really angry. :)
03:39:07 <DRMacIver> More so than the type unsafety.
03:39:34 <nornagon> the haskell solution sure is pretty :)
03:39:37 <dons> `Be careful though' yes. very unsavoury. i was pondering an Either list, but the code made me feel ill, so I didn't bother
03:39:49 <dons> the python code, for the modified rle, that is
03:39:59 <roconnor> DRMacIver: I didn't even notice that ... mostly because I never actually read the code. :)
03:40:01 <dons> roconnor: yesh, the methodology isn't so good
03:40:18 <nornagon> how fast does the haskell run vs. the python?
03:40:19 <DRMacIver> roconnor: I read it when doing my "Number of functions I need to look up" comparison on reddit. :)
03:40:26 <dons> so you could write a whole article about what's wrong with that code.
03:40:48 <dons> nornagon: no idea, i'd imagine ghc -O2 kicks the python list comprehension
03:40:49 <roconnor> DRMacIver: list*number clearly implements map (*number) list ... oh wait. ;)
03:42:03 <dons> someone should write about all the nasty semantics in the python code
03:42:18 <DRMacIver> (The basic point I was making in it being that the pythonista complained that in order to understand the Haskell code you had to look up 4 functions. I observed in response that in order to understand the python code you needed to grok some really ad hoc overloading, not to mention the comprehension syntax)
03:42:37 <dons> yep.
03:42:39 <wli> Okay, find a set of substrings S of some string of length less than some bound so that the string is in S* (Kleene *) and S is of minimal cardinality. Hmm.
03:43:05 <nornagon> haskell gets prettier and prettier every day for me
03:43:18 <nornagon> largely through planet haskell, thanks to anyone that writes there :)
03:43:24 <nornagon> i just wish I could write fast code in it :(
03:44:22 <roconnor> nornagon: what OS are you using?
03:44:29 <nornagon> linux
03:44:33 <nornagon> debian unstable.
03:45:01 * roconnor wonders if debian unstable has optimized haskell libraries. :)
03:45:19 * profmakx wonders if FreeBSD has optimised haskell libraries.
03:45:28 <nornagon> it aggravates me when I write something in haskell, then write it again in C++ and the C++ version is an order of magnitude faster
03:45:38 <profmakx> because i started hacking around with frag this weekend
03:46:02 <nornagon> conversely, i've had the happy experience of writing something in python and again in C++, and noting that the C++ version runs about the same speed as the python version
03:46:03 <roconnor> nornagon: what does ``ghc-pkg list Cabal'' give you?
03:46:07 <nornagon> (it was graphics-bound)
03:46:20 <nornagon> /usr/lib/ghc-6.6.1/package.conf: Cabal-1.1.6.2
03:46:20 <nornagon> /home/nornagon/.ghc/i386-linux-6.6.1/package.conf:
03:46:25 <nornagon> er, thx irssi
03:46:28 <dons> wow, how could that be possible?
03:46:36 <nornagon> the cabal-1.1.6.2 is a separate line
03:46:42 <wolverian> nornagon, on the other hand, python's ogl bindings are dog slow apparently
03:46:47 <nornagon> dons: lots and lots of opengl calls
03:47:01 <nornagon> wolverian: well, i wrote it again as best i could in C++ and it ran at comparable speeds
03:47:09 <nornagon> as in, i didn't notice much difference in cpu usage
03:47:13 <roconnor> nornagon: If I understand correctly none of your haskell libraries installed by apt are optimized.
03:47:18 <wolverian> nornagon, yar, it depends on what you use. vbas and such.
03:47:19 <dons> nornagon: ah, so its just the speed of the opengl binding, which is in C.
03:47:28 <dons> nornagon: for the same reason, Frag runs fsat
03:47:51 <nornagon> wolverian: for my app, there's a minimum number of GL calls that need to be done each frame
03:47:53 <dons> nothing to do with the language used to call opengl
03:48:08 <wolverian> nornagon, http://graphcomp.com/opengl/index.cgi?v=0111s3m3&r=s1m1
03:48:09 <lambdabot> Title: POGL - Benchmarks
03:48:13 <profmakx> dons: for certain values of fast ;)
03:48:20 <nornagon> wolverian: width_in_characters * height_in_characters * four_vertices
03:51:20 <nornagon> perhaps my inability to write fast haskell has something to do with the fact that I grok gcc optimisations to some extent, but not ghc's
03:51:28 <nornagon> i have been one with the state machine for several years
03:51:39 <dons> what kind of data structures do you use?
03:51:59 <wolverian> (it'd be interesting to add haskell to the pogl benchmarks)
03:53:22 <wli> I've chosen a source string and need to cut it out...
03:53:34 <nornagon> dons: i posted an xmonad status script I wrote a while ago, the data structures I see in my code are just Data.Map.Map and Strings
03:53:56 <nornagon> yet the ruby version of the same runs much better than the -O2 haskell version
03:54:03 <wli> Basically chop up the string at every occurrence of the source string.
03:55:10 <dons> nornagon: sounds ridiculous :) ruby, come on. they don't even know how to compile it. :)
03:55:18 <nornagon> exactly my thoughts
03:55:20 <dons> you might want maps of Bytestrings
03:55:27 <dons> Map Int ByteString or some such
03:55:41 <nornagon> well, the maps i have are:
03:55:42 <nornagon> type ProcInfo = M.Map String String
03:55:42 <nornagon> type DeviceMap = M.Map String ProcInfo
03:55:44 <roconnor> dons: don't be too hard on ruby.  It wasn't so long ago when we didn't know how to compile Haskell.
03:55:45 <wli> So chop "xx" "asdfxxasdfxxasdf" goes to ["asdf","asdf","asdf"]
03:55:51 <xerox> There's also IntMap, instead of MapInt.
03:55:54 <dons> roconnor: what, 1984?
03:56:06 <roconnor> dons: I was thinking 1992ish
03:56:22 <roconnor> But you actually may know better than me.
03:56:23 <dons> look for Lennart's phd thesis.
03:57:34 <dons> http://portal.acm.org/citation.cfm?id=800055.802038
03:57:38 <lambdabot> Title: A compiler for lazy ML
04:04:01 <nornagon> wli: chop p str = if p `isPrefixOf` str then chop (drop (length p) str) else ... something.
04:05:24 <wli> nornagon: let chop s s' = if s' == [] then Nothing else let { is = zip (inits s') (tails s') } in case dropWhile (\(_, x) -> not (s `isPrefixOf` x)) is of { [] -> Just (s',[]) ; (y:ys) -> Just $ second (drop (length s)) y } in unfoldr (chop "xx") "asdfxxasdfxxasdf"
04:05:47 <wli> This is grossly inefficient.
04:06:08 <nornagon> XD
04:08:52 <kaol> > Just "123abc" >>= (listToMaybe . reads) >>= (return . fst)
04:08:53 <lambdabot>  Just 123
04:11:30 * kaol considers writing his own monad tutorial
04:12:00 <wli> kaol: Please have lots of exercises.
04:12:27 <profmakx> YAMT?
04:12:32 <nornagon> kaol: do monad transformers!
04:12:33 <profmakx> as in Yet another monad tutorial?
04:13:11 <MyCatVerbs> Monad tutorials are a rite of passage, comrade.
04:13:17 <kaol> aye
04:13:24 <MyCatVerbs> There is no, "Yet Another" about it.
04:13:58 <profmakx> hm
04:14:06 <profmakx> then i will write one too
04:14:18 <MyCatVerbs> That would be like saying, "Yet Another (Bar|Bat) Mitzvah" or "Yet Another Boy Kills His Dinner For The First Time And The Tribe Declares Him Accepted As A Man" or...
04:14:32 <profmakx> my very own! my precious!
04:14:39 <profmakx> well, i have to admit
04:14:43 <MyCatVerbs> "Yet Another Baptism of Fire", even.
04:14:52 <profmakx> it really helped me getting diverse views on monads
04:15:00 * MyCatVerbs nods.
04:15:47 <profmakx> i was more coming from a category-theory perspective... which didnt help that much
04:17:30 <Saizan> i think there's no tutorial starting from the idea of functor
04:17:35 <tcr> Is there a Debian/Ubuntu package for cabal-install?
04:18:09 <hpaste>  osfameron pasted "Perl version of Run Length encoding :-)" at http://hpaste.org/1987
04:18:15 <tcr> I've got `libghc6-cabal-dev' installed, but there is not `cabal-install' command.
04:18:49 * wli prays the greedy algorithm does something remotely optimal.
04:28:51 <wli> Let's see if this thing can actually dump a codebook for de bello gallico.
04:29:16 <vincenz> LoganCapaldo: woo nice one :)
04:30:35 * vincenz wonders why Coq can not use the std definitions of List and Bool in it's Haskell-coode generate
04:30:38 <vincenz> generator
04:31:09 <roconnor> dons: was the G-machine fast, or does the STG-machine make a big difference?
04:31:48 <roconnor> vincenz: what do you mean by standard definitions?
04:32:04 <roconnor> vincenz: Coq knows nothing about the association between Haskell's Prelude and it's own libraries.
04:32:17 <vincenz> roconnor: it'd be rather trivial to reuse std stuff
04:32:27 <vincenz> instead of List a = Nil | Cons a (List a)
04:32:37 <vincenz> just replace List a stuff with the prelude one
04:32:40 <vincenz> when piping out to haskkell
04:32:47 <vincenz> similarly Sumbool = Left | Right
04:32:57 <vincenz> replace it by Bool  and use True and False
04:33:19 <roconnor> vincenz: would you make Sumbool and bool the same type in extracted code?
04:33:26 <Syzygy-> What do I need in my .cabal-file in order for it to use wxHaskell?
04:35:15 <vincenz> roconnor: Well true, that might be one problem, but still, ,I think it should be feasilbe without change any core part of coq
04:36:04 <roconnor> vincenz: yeah, it's a big problem that stops haskell extraction from being at all practical.
04:36:34 <dons> roconnor: i think hbc is still a G-machine, and its pretty fast
04:36:37 <vincenz> roconnor: basically if you could perhaps add in comments what data type it should mape to in haskell, and make some std prelude stuff known in Coq so it knows what the name of the data constructors are ..
04:37:02 <dons> but you can't trust the Prelude , vincenz :)
04:37:17 <vincenz> dons: just the data definitions, ,not the functions
04:37:33 <dons> you can't trust the Bool type to be correct :)
04:37:40 <pejo> dons, do you have a darcs repository of hbc, or was that someone else?
04:37:50 <dons> i'm sure though, in a real project, you'd tweak the extractor
04:37:51 <vincenz> dons: you mean there's other stuff besides True and False?
04:37:57 <dons> pejo, i think there's a website somewhere.
04:37:59 <dons> ?where hbc
04:38:00 <lambdabot> I know nothing about hbc.
04:38:07 <dons> sorear knows
04:38:12 <dons> vincenz: yeah, :)
04:38:13 <pejo> dons, thanks.
04:38:34 <vincenz> dons: Oh right, (not (not True))
04:38:38 <Botje> @pl \x -> (length x, head x)
04:38:38 <lambdabot> liftM2 (,) length head
04:38:50 <Botje> @unpl length &&& head
04:38:51 <lambdabot> (length &&& head)
04:39:00 <Botje> boo :(
04:39:04 <opqdonut>  @pl isn't really arrow-savvy
04:39:13 <Botje> i know
04:39:48 <dons> ?src (&&&(
04:39:48 <lambdabot> Source not found. My mind is going. I can feel it.
04:39:49 <dons> ?src (&&&)
04:39:50 <lambdabot> f &&& g = arr (\b -> (b,b)) >>> f *** g
04:39:50 <swiert> vincenz: I think you can specify how to extract Coq data types to Haskell data types.
04:39:55 <dons> ?src arr
04:39:55 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
04:40:30 <roconnor> @djinn (Not (Not ()))
04:40:33 <lambdabot> f a = a ()
04:40:54 <vincenz> classic
04:40:56 <vincenz> dons: http://programming.reddit.com/info/2acia/comments/c2ay0r
04:40:57 <lambdabot> Title: ML Modules and Haskell Type Classes, by Stefan Wehr - investigating the overlap  ...
04:41:06 <roconnor> @djinn () -> (Not (Not ()))
04:41:06 <vincenz> swiert: ah interesting :)
04:41:06 <lambdabot> f _ a = a ()
04:41:27 <roconnor> swiert: really, that's awsome!
04:41:57 <swiert> I seem to remember something like that...
04:42:00 <opqdonut> Not?
04:42:02 <swiert> Only now I can't seem to find it.
04:42:03 <opqdonut> ?djinn-env
04:42:03 <lambdabot> data () = ()
04:42:03 <lambdabot> data Either a b = Left a | Right b
04:42:03 <lambdabot> data Maybe a = Nothing | Just a
04:42:03 <lambdabot> data Bool = False | True
04:42:03 <lambdabot> data Void
04:42:05 <lambdabot> type Not x = x -> Void
04:42:07 <lambdabot> class Eq a where (==) :: a -> a -> Bool
04:42:09 <lambdabot> type Cont r a = (a -> r) -> r
04:42:13 <dons> vincenz: hah
04:42:22 <Syzygy-> Bah.
04:42:26 <Syzygy-> Build of wxHaskell fails.
04:42:49 <Syzygy-> If I want to be able to throw up a window and draw in it - with haskell and on x86_64 - what do I want to use?
04:43:36 <swiert> Ah yes. Extract Inductive ....
04:44:04 <vincenz> dons: that's so comic :)
04:44:13 <swiert> End of section Section 18.2 in the reference manual.
04:44:32 <roconnor> swiert: nice.  Does it work wit haskell?
04:45:11 <dons> Syzygy-: hmm, why not use gtk2hs?
04:45:16 <dons> you'd be done by now :)
04:45:19 <nornagon> hssdl?
04:45:24 <swiert> roconnor: I think so. I haven't tested it though.
04:46:01 <dons> i'm surprised no one's made a big push to do Coq or Isabelle extraction as a way to do verified components for haskell.
04:46:11 <dons> things like sel4 translate haskell to isabelle, to check it
04:46:21 <tcr> Anyone who has experience with Uniplate?
04:46:24 <vincenz> Syzygy-: if you need assistance with gtk2hs M-
04:46:25 <dons> and there's Agda and some others, but given how common this extraction stuff is, why aren't we using it more often?
04:46:27 <vincenz> Syzygy-: <- even
04:47:08 <tcr> dons: I'm writing a automatic converter from Haskell to Isabelle/HOL for the sel4 project.
04:47:16 <swiert> dons: I'm not sure extraction is the way to go.
04:47:28 <dons> tcr: oh, is this the new one? (the non-python one?)
04:47:35 <swiert> I'd rather write my programs and prove them correct in the same system.
04:47:53 <dons> yeah, that's fair enough.
04:48:15 <tcr> dons: They're using some home-brewn regexp-based stuff. My job is to do it properly. :)
04:48:19 <dons> good!
04:48:25 <dons> yes, that was my big complain: the evil regex thing
04:48:47 <dons> when we already have haskell-src, for example, to do the parsing, and pretty printing isn't too hard :)
04:49:23 <tcr> Exactly! But now I'm fuzzing with Uniplate...
04:49:57 <Syzygy-> dons, vincenz: So what do I write in my cabal file to depend on gtk2hs?
04:49:58 <dons> oh, for the traversals?
04:50:02 <dons> maybe just use SYB generics?
04:50:11 * Syzygy- just started with typing in the hello world example
04:50:17 <njbartlett_> Syzygy-: I wasn't able to build wxHaskell either. Real shame...
04:50:27 <dcoutts> Syzygy-: build-depends: gtk   and possibly cairo if you're using that
04:50:48 <njbartlett_> In my case, gtk2hs is not an option because I need Mac OS support
04:50:51 <tcr> dons: Dunno, Uniplate looked appealingly simple. :)
04:51:00 <dcoutts> njbartlett_: you're in luck! it works on OSX :-)
04:51:25 <njbartlett_> Oh? Not last time I looked...
04:51:29 <dons> tcr, appealing, but a bit untested. at least SYB is in the base libs, and fairly well used
04:51:44 <dons> but it should work, I think: ask ndm :)
04:51:46 <earthy> njbartlett: it still doesn't in native mode, IIRC
04:51:59 <dcoutts> it uses X11 on OSX
04:52:03 <dcoutts> at the moment
04:52:18 <earthy> and gtk+/aqua is still in development
04:52:35 <njbartlett_> Ah. X11 is really crap on Mac :-(
04:52:46 * vincenz thinks qwe1234 is wearing down
04:52:49 <tcr> dons: Well, I already created most of the necessary instances via some ad-hoc emacs script!
04:52:57 <vincenz> "learn or stfu" "code or stfu"  "blabla or stfu"
04:53:06 <vincenz> maybe he's finally grown tired of being made fun of
04:53:15 <vincenz> augustss++
04:53:32 <MyCatVerbs> "learn or stfu" sounds nice.
04:53:46 <MyCatVerbs> It's not something I would ever imagine I'd hear here, though.
04:53:47 <vincenz> MyCatVerbs: the funny part is that it's so contradictory when it comes from him :)
04:54:13 <wli> map (map fst) $ groupBy ((. snd) . (==) . snd) [(x, n `div` k) | k <- [0..]]
04:54:23 <wli> Is there anything to do that floating around in libs?
04:54:31 <MyCatVerbs> vincenz: who, sorry? I've missed most of the backstory to this discussion.
04:54:38 <wli> Or otherwise "more appropriate methods?"
04:54:44 <vincenz> MyCatVerbs: 'qwe1234' on reddit
04:54:45 <wli> ergh
04:54:52 <wli> map (map fst) $ groupBy ((. snd) . (==) . snd) [(x, n `div` k) | n <- [0..]]
04:54:58 <MyCatVerbs> vincenz: ah, danke. Which thread?
04:55:38 <vincenz> http://programming.reddit.com/info/2acia/comments/c2ay0r
04:55:39 <lambdabot> Title: ML Modules and Haskell Type Classes, by Stefan Wehr - investigating the overlap  ...
05:00:26 <wli> Error: input: Resource temporarily unavailable
05:00:33 <wli> I get that when I try to do :edit
05:00:48 <dons> vincenz: this is a good one, http://programming.reddit.com/info/2aioh/comments/c2ar7m
05:00:49 <lambdabot> Title: 37 Reasons to Love Haskell (playing off the Ruby article) (reddit.com)
05:01:03 <vincenz> dons: yeah :)
05:01:20 <vincenz> dons: and the funny part is that he reuses those exact same words against someone else in a parallel branch
05:02:18 <dons> yeah, it must be very strange being qwe1234
05:02:38 <tcr> ndm: ping?
05:03:21 <vincenz> dons: I really think he's not purposefully ignorant, if you go by his comments, I think he really believes what he says,, which makes you wonder how someone can argue so much against people and get downmodded so much and not hit the clue-stick
05:04:14 <dons> i think he tries to make ridiculously contrary statements, too, amongst his other tricks
05:04:22 <dons> which shows he's just playing a game mostly
05:04:38 <psykotic> dons: you don't understand, you retard, it's all about the VALUE SEMANTICS!
05:04:38 <dons> like the weird statement about not knowing why you'd need more than 512k
05:04:41 <psykotic> :)
05:04:43 <dons> hehe
05:04:43 <vincenz> dons: :)
05:04:50 <dons> i'm so stoopid
05:04:58 <vincenz> psykotic: I was going to reply his causal chain is reversed
05:05:03 <dons> ?quote qwe1234
05:05:03 <lambdabot> qwe1234 says: the lisp folks have purposefully made lisp so that static analysis is impossible.
05:05:08 <dons> ?quote qwe1234
05:05:08 <lambdabot> qwe1234 says: good developers will write good code in absolutely any language, while bad developers will develop crap no matter the tools they use.
05:05:16 <dons> very wise.
05:05:23 <vincenz> psykotic: constructors + destructors get you resource handling, and c+ds get you value semantics, but the arrows are both to the right, no causal chain
05:05:32 <psykotic> ?quote qwe1234
05:05:32 <lambdabot> qwe1234 says: in my very firm opinion, it's never your business to be figuring out pointer type at runtime.
05:05:45 <dons> these are old ones, we should update them with all this new stuff
05:05:51 <psykotic> dons: in a few decades, qwe1234 will be quoted for his great wisdom, the way alan perlis is quoted today. mark my words!
05:05:53 <vincenz> yeah, it's too juicy :)
05:05:56 <vincenz> psykotic: thoughts?
05:06:13 <dons> maybe have a special purpose @troll command troll
05:06:19 <dons> command too
05:06:22 <psykotic> someone needs to train a markov chain with his insults
05:06:29 <dons> yeah, that'd be lovely
05:06:31 <araujo> morning
05:06:33 <dons> and just post them back to him
05:06:34 <vincenz> dons: I'd call it '@argue'
05:06:58 <dons> what was the megamonad markove bot we used to use?
05:07:11 <dons> megahal 9
05:08:45 <psykotic> vincenz, make sense
05:09:23 <psykotic> his obsession with "value semantics" is less with the semantics part and more with the performance, though
05:10:08 <vincenz> his latest question was about getting value semantics in haskell
05:10:10 <vincenz> erm..
05:10:18 <vincenz> aren't those completely transparent in haskell?
05:10:19 <tcr> Say I have `module Foo where { import Bar (quux); baz = 42; }' Why isn't `quux' exported from Foo?
05:10:58 <vincenz> http://programming.reddit.com/info/2aioh/comments/c2axie
05:10:59 <lambdabot> Title: 37 Reasons to Love Haskell (playing off the Ruby article) (reddit.com)
05:11:09 <vincenz> tcr: you have to explicitly export imported stuff
05:11:12 <vincenz> tcr: like so
05:11:26 <vincenz> module Foo (module Foo, module Bar) where { import Bar (quux); baz = 42; }
05:12:08 <tcr> Ah, I see. I was missing that you can insert the Foo module there, too. That's cool thanks!
05:12:48 <tcr> vincenz: Does this only export `quux' from Bar, yes?
05:12:59 <vincenz> tcr: I believe so, since it's the only one imported, but I haven't tested that
05:14:58 <tcr> What are the recommended ressources for learning more advanced Haskell programming (in contrast to just general modern functional programming)?
05:15:44 <therp> tcr: papers linked from the haskell wiki :)
05:16:04 <vincenz> tcr: practice?
05:16:29 <tcr> vincenz: You can't really practise what you don't know of.
05:16:40 <swiert> tcr: There is a bit of a gap in the literature. You have introductions/undergraduate textbooks, but the next step from there is research articles.
05:17:07 <swiert> There's not a whole lot of "advanced-yet-not-cutting-edge-research" literature.
05:17:10 <vincenz> tcr: By undertaking bigger projects you might find yourself workinig from the grain, by then asking questions, people can give you insights on what you should be using.
05:17:21 <vincenz> s/workinig from the grain/working against the grain/
05:17:55 <Syzygy-> @doc
05:17:56 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
05:18:01 <tonfa> is there some docs about how monads are implemented ?
05:18:03 <vincenz> tcr: But if you want a list: Custom type classes, monad transformers, custom monads, phantom types, GADTs, existential type
05:18:08 <tcr> vincenz: I'm doing that, in fact. But it leaves me feeling unsatisfied because I just get the pieces, and not necessarily the whole picture.
05:18:29 <MyCatVerbs> vincenz: http://programming.reddit.com/info/2apvh/comments/c2ay6s
05:18:29 <vincenz> tcr: There's a haskell book on wikibooks, it's not complete yet, but it has a good listing of all the different advanced parts.
05:18:30 <lambdabot> Title: "The whole field rewards novices and punishes experts." (reddit.com)
05:18:45 <MyCatVerbs> vincenz: qwe1234, evidently isn't *totally* insane.
05:19:14 <vincenz> MyCatVerbs: No, which then begs the question: is he trolling on purpose or does he believe all the insanity he spouts.
05:19:22 <swiert> tcr: You may want to look into "Fun of Programming".
05:19:42 <opqdonut> what haskell serialization libs are there?
05:19:49 <vincenz> tcr: http://en.wikibooks.org/wiki/Haskell
05:19:50 <lambdabot> Title: Haskell - Wikibooks, collection of open-content textbooks
05:20:03 <Syzygy-> So, I have a main given by the Hello World.
05:20:06 <Syzygy-> And I try to compile it.
05:20:18 <xerox> opqdonut: Data.Binary
05:20:24 <Syzygy-> Ahhhhhh!
05:20:25 <MyCatVerbs> vincenz: perhaps someone cut off his caffeine IV, and he's just really fucking ANGSTY.
05:20:27 <Syzygy-> Case sensitivity.
05:20:47 <Syzygy-> initGui /= initGUI
05:21:00 * therp feels inclined to reply to qwe1234, must resist... must res.. 
05:26:08 <Japsu> Hmm
05:27:24 <Japsu> Is there some easy way to do network IO between two processes over the network with an API similar to Control.Concurrent.Chan? I mean, some sort of automatic de/serialization of simple data structures
05:28:24 <Japsu> The closest thing I've seen so far would be Data.Binary and it still requires me to write some serialization code myself... I'd like to skip writing the on-the-wire format code myself.
05:29:04 <kpreid> I heard about a haskell impl that supported distributed programming once, but I don't recall the name
05:29:37 <ndm> Japsu: have you seen Derive? its a preprocessor that can write the Data.Binary stuff automatically
05:29:39 <ndm> @where derive
05:29:39 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/derive
05:29:58 <ndm> @where+ derive http://www-users.cs.york.ac.uk/~ndm/derive/
05:29:58 <lambdabot> Done.
05:29:58 <Japsu> ndm: Yay, thanks, I'll have a look at it
05:30:28 <Saizan> i seem to remember about a lib that handles the communication part, also
05:31:37 <dons> therp: don't do it!
05:32:06 <vincenz> dons: why not? If we talk to him like augustss does, eventually he'll wear down
05:32:23 <vincenz> dons: he sees that he can not spite us, and meanwhile is forced to argue on all fronts, while we offer useful information to the crowd at large :)
05:32:32 <dons> you think?
05:32:46 <dons> i'm pretty sure he feeds on our energy
05:33:29 <dons> i think "code or stfu" is a good reply, if you ever really feel compelled
05:33:46 <vincenz> dons: that should be "code and stfu" :)
05:34:03 <dons> heh
05:34:09 <Japsu> Oh, stupid me
05:34:25 <Japsu> I can do "deriving (Show, Read)" which will probably suffice for my purposes
05:34:33 <Japsu> It might be inefficient but it works
05:35:47 <Japsu> Then just write a thin wrapper to make those strings go over the network nicely. :)
05:35:48 <dons> psykotic: btw, re your === we define `eq` in Data.ByteSring for this
05:36:05 <xerox> AltBinary?
05:36:06 <psykotic> dons: ah nice. i figured it out in the meantime, works great.
05:36:07 <dons> psykotic: http://www.cse.unsw.edu.au/~dons/code/fps/tests/Properties.hs
05:36:28 <dons> find its defn here, http://www.cse.unsw.edu.au/~dons/code/fps/tests/QuickCheckUtils.hs
05:36:29 <lambdabot> http://tinyurl.com/mwg5s
05:36:33 <dons> eq1 f g = \a         ->
05:36:33 <dons>     model (f a)         == g (model a)
05:36:33 <dons> eq2 f g = \a b       ->
05:36:33 <dons>     model (f a b)       == g (model a) (model b)
05:36:42 <psykotic> dons: http://hpaste.org/1981
05:36:44 <Japsu> ie. instance Show a, Read a => Channel a
05:36:56 <psykotic> dons: it seemed nice to have === subsume ==, as a sort of lifting of == to properties
05:36:56 <dons> -- The Model class connects a type and its model type, via a conversion
05:36:56 <dons> -- function.
05:37:00 <dons> right
05:37:09 <dons> yeah, i was looking at that
05:37:33 <dons> prop_showRead3 = extract . inject === id is definitely a desirable end result
05:37:39 <psykotic> right
05:37:41 <psykotic> more algebraic
05:38:03 <psykotic> all those darn variables clutter it up :)
05:38:07 <dons> yep
05:38:15 <dons> where'as say in the http://www.cse.unsw.edu.au/~dons/code/fps/tests/Properties.hs link, its very clear
05:38:22 <psykotic> yep
05:38:51 <Syzygy-> Hmmmm.
05:39:07 <Syzygy-> So, I set drawing parameters by constructing a GC with gcNewWithValues.
05:39:22 <dons> oh, one less = in your ===> in the reddit comment, psykotic
05:39:25 <dons> :t (==>)
05:39:30 <psykotic> doh
05:39:33 <Syzygy-> and this is an IO thingie, so I want to do something like do gc <- gcNewWithValues (GValues {blah})
05:39:35 <lambdabot> Not in scope: `==>'
05:39:36 <Syzygy-> Correct?
05:39:40 <vincenz> psykotic: ping
05:39:50 <psykotic> vincenz ?
05:39:55 <vincenz> psykotic: regarding the hasRuns
05:39:59 <vincenz> psykotic: you risk starvation
05:40:08 <vincenz> @hoogle quickcheck
05:40:09 <lambdabot> Test.QuickCheck :: module
05:40:09 <lambdabot> Test.QuickCheck.quickCheck :: Testable a => a -> IO ()
05:40:16 <psykotic> vincenz, sure
05:40:19 <vincenz> > quickCheck $ False ==> True
05:40:20 <lambdabot>   Not in scope: `quickCheck'
05:40:25 <psykotic> vincenz, but at least it's better than silently thinking it's fine
05:40:32 <psykotic> if you starve then you know you need to dig deeper
05:40:33 <vincenz> @qc False ==> True
05:40:33 <lambdabot> Plugin `offlinerc' failed with: IRCRaised False ==> True: openFile: does not exist (No such file or directory)
05:40:38 <dons> in a real system you'd newtype it, and provide a Run generator, I'd think
05:40:43 <psykotic> right
05:40:46 <vincenz> dons: Arbitrary?
05:40:46 <dons> like we do for NonNegative Int and so on
05:41:14 <dons> newtype RunList a = [a] , then Arbitrary for that that produces runs 9/10 times
05:41:17 <fasta> Can I do newtype deriving for e.g. StateT?
05:41:23 <dons> yeah
05:41:38 <dons> newtype X a = X (ReaderT XConf (StateT XState IO) a)
05:41:38 <dons>     deriving (Functor, Monad, MonadIO, MonadState XState, MonadReader XConf)
05:41:40 <dons> for example
05:41:52 <fasta> dons: that's not what I meant.
05:42:01 <fasta> dons: I meant without newtyping it.
05:42:13 <dons> you asked for newtype deriving though
05:42:33 <fasta> dons: Yes, my question was not very clear.
05:42:38 <dons> you want standalone deriving for StateT itself?
05:42:44 <fasta> dons: yes
05:42:51 <dons> to what class?
05:42:57 <fasta> dons: a user defined clas
05:43:02 <fasta> dons: class*
05:43:18 <Syzygy-> vincenz: What does it mean that "widget is probably not realized"?
05:43:24 <Saizan> @where derive
05:43:25 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/derive/
05:43:34 <vincenz> Syzygy-: context?
05:43:42 <dons> you can't derive user defined classes, unless the type is a newtype for something else.
05:44:05 <dons> newtype StateT s m a = StateT { runStateT :: s -> m (a,s) }
05:44:22 <dons> so you could newtype derive something for StateT, if `s -> m (a,s)' was already in your user-defined class
05:44:26 <dons> but sounds unusual
05:44:30 <dons> perhaps just use one of the deriving libraries
05:44:35 <Syzygy-> vincenz: I'm trying to get a DrawingArea into my helloworld window so that I can start drawing on it.
05:44:43 <Syzygy-> ?hpaste
05:44:43 <lambdabot> Haskell pastebin: http://hpaste.org/new
05:45:14 <dons> ?users
05:45:14 <hpaste>  Syzygy- pasted "Widget not realized" at http://hpaste.org/1988
05:45:14 <lambdabot> Maximum users seen in #haskell: 374, currently: 355 (94.9%), active: 25 (7.0%)
05:45:49 <vincenz> Syzygy-: where does it complain?
05:46:08 <vincenz> Syzygy-: oh I see what is wrong
05:46:15 <vincenz> Syzygy-: you don't want to jjust draw
05:46:18 <vincenz> you want to...let me fetch code
05:46:30 <MisterN> hmm
05:46:33 <MisterN> ?users
05:46:34 <lambdabot> Maximum users seen in #haskell: 374, currently: 355 (94.9%), active: 26 (7.3%)
05:46:40 <MisterN> heh
05:46:43 <allbery_b> do the drawing in an onIdle
05:46:46 <roconnor> What's nice about Coq is that you can edit a proof to weaken a hypothesis, without worrying that you've made a mistake.
05:47:17 <vincenz> Syzygy-: use the `onExpose`
05:47:29 <allbery_b> or that, yes
05:47:33 <vincenz> Syzygy-: let me modify :)
05:47:41 <MisterN> Syzygy-: isn't gtk2hs inadequatly low-level for a true haskeller?
05:47:51 <MisterN> i mean... onIdle.. yuck
05:47:53 <roconnor> MisterN: yes!
05:48:02 * roconnor is a true haskeller
05:48:13 <allbery_b> well, this is more an artifact of how X11 foo works
05:48:19 <Syzygy-> MisterN: I'm not so much a True Haskeller as a mathematician though.
05:48:31 <MisterN> allbery_b: it's not like it couldn't be done better
05:48:35 <Syzygy-> And I'm happy with event driven stuff when I'm coding for GUIs that are, due to external design, event driven.
05:48:41 <hpaste>  vincenz annotated "Widget not realized" with "fixed?" at http://hpaste.org/1988#a1
05:48:47 <vincenz> Syzygy-: try that ^^^
05:48:47 <MisterN> Fruit or how those things are all called
05:48:48 <dcoutts> MisterN: yes, it's a compromise between a beautiful high level design, and actually working, looking ok and having a wide range of features available.
05:48:58 <Syzygy-> I mean - this way around, I get to code like the VB stuff I did back whenI was 13. But in Haskell!!
05:49:00 <vincenz> Syzygy-: s/guiState/c
05:49:01 <allbery_b> the Drawable doesn't "exist" until you start processing all the X events to set it up
05:49:12 <dcoutts> MisterN: it's my hope that people will develop a high level api on top of this medium level stuff.
05:49:24 <allbery_b> thus you have to enter mainGUI and process events before you can get the Drawable's window
05:49:27 <vincenz> Syzygy-: I think the problem is that you were drawing on a widget that wasn't shown yet..
05:49:37 <vincenz> Syzygy-: yo don't want to just draw on it, you want to draw on it when it gets re-exposed
05:49:43 <vincenz> Syzygy-: if you don't want to recompute, use a pixbuf
05:49:48 <vincenz> Syzygy-: then blit that to your drawing area
05:49:49 <MisterN> dcoutts: there are a number of high level apis (not that i've used them), but probably too incomplete in features?
05:50:01 <dcoutts> MisterN: and as it happens, onIdle isn't so bad actually, it somewhat complements Haskell threads since it tells us when the GUI isn't insanely busy.
05:50:07 <Syzygy-> Turtle.hs:16:42: Not in scope: `guiState'
05:50:12 <int-e> Swapping widgetShowAll window and drawFractal canvas does something. But you should really wait for an expose event instead.
05:50:37 <dcoutts> MisterN: there are a few higher level apis, but yes, generally covering a very small set of widgets and widget features.
05:50:44 <vincenz> Syzygy-: notice my regexp
05:50:47 <vincenz> Syzygy-: s/guiState/c
05:50:49 <Syzygy-> Ah.
05:50:53 <vincenz> old code :)
05:50:55 <MisterN> dcoutts: last time i implemented an event loop, i called onIdle after handling all timers and before doing real stuff
05:51:00 <vincenz> Syzygy-: I tend to have my canvas and all my other stuff inside one record
05:51:03 <vincenz> Syzygy-: I call it guiState :)
05:51:04 <Syzygy-> Yeah.
05:51:08 <Syzygy-> Ah, right.
05:51:15 <int-e> does something --> there's an error in drawFractal,  GCValues { ... } is wrong and should be  newGCValues { ... } unless you really want to specify all the fields.
05:51:30 <fasta> dons: what I want is class Foo that is the same as MonadState with a corresponding FooT, where FooT derives a class User. The class Foo should also have a few extra associated functions, but these do not have to be in the class.
05:51:34 <hpaste>  vincenz pasted "My GUIState for ICFP 2007" at http://hpaste.org/1989
05:51:40 <vincenz> Syzygy-: eg ^^^
05:51:44 <Syzygy-> And it wants a lot of stuff for Expose that I didn't deliver...
05:51:59 <dcoutts> MisterN: glib's even loop has a system of priorities, and idle is just one of those levels
05:52:01 <vincenz> Syzygy-: hence I patternmatch against Expose {} :)
05:52:05 <vincenz> (Expose {})
05:52:12 <Syzygy-> Ah. {} not ().
05:52:23 <vincenz> yes, that's a way to patternamtch a recrod with a "don't care about contents"
05:52:30 <vincenz> s/typos/typoless
05:52:43 <MisterN> dcoutts: gtk would better optimize elsewhere
05:53:08 <Syzygy-> vincenz: Is there somewhere I can get hold of the things I can > set for a widget?
05:53:09 <dcoutts> MisterN: but yes, it's not nearly so important in Haskell since we have proper lightweight threads, we don't have to break up our code into lots of little callbacks to prevent the gui blocking.
05:53:32 <vincenz> Syzygy-: I don't typically use set, I use explicit setters,, which are described in the dox
05:53:35 <MisterN> dcoutts: proper threads would be ok, too.
05:53:46 <MisterN> like full-fledged system threads
05:53:50 <Syzygy-> vincenz: So, if I want my drawing window to have a specific size?
05:53:56 <vincenz> sec
05:54:10 <vincenz> hmm
05:54:14 <vincenz> I used glade..
05:54:15 <dcoutts> MisterN: ghc has both, it's M-N threading, many Haskell threads on a few OS threads
05:54:18 <vincenz> there's a way to do it
05:54:29 <Syzygy-> I just want to put coloured lines on the screen!! ;)
05:55:22 <MisterN> dcoutts: just like erlang :D
05:55:34 <dcoutts> yep
05:56:09 <vincenz> Syzygy-: I tend to use glade to fix the size of windows
05:56:10 <vincenz> Syzygy-: second
05:56:19 <vincenz> Syzygy-: I might have used the non-glade way in an old projet
05:56:49 <vincenz> Syzygy-: like so     canvas `onSizeRequest` return (Requisition (fst canvasSize) (snd canvasSize))
05:56:57 <MisterN> dcoutts: i'd like to see erlang-style message passing but type-safe in haskell :D
05:57:13 <vincenz> Syzygy-: namely, when asked what size it wants, it always returns a fixed size :)
05:57:28 <vincenz> for me canvasSzie was :: (Int, Int)
05:57:36 <vincenz> but that was just how I stored the values in my application
05:58:35 <dcoutts> vincenz: if it's a constant size there's a simpler way than using that callback
05:59:00 <dcoutts> vincenz: widgetSetSizeRequest
05:59:13 <vincenz> dcoutts: ah, good to know :)
05:59:18 <vincenz> that code was from 2005
05:59:22 <vincenz> now I just use glade
05:59:29 <vincenz> well, ,glade-2
05:59:38 <dcoutts> glade-3 !
05:59:49 <dcoutts> glade 3.4 will support GtkBuilder iirc
05:59:58 <gwern> (bleh. I hate my connection. did anyone see/respond to my question?)
06:00:06 <vincenz> dcoutts: then glade-95?
06:00:09 <dcoutts> vincenz: GtkBuilder being the libglade functionality, but brought into core Gtk+
06:00:13 <dcoutts> vincenz: heh
06:00:17 <vincenz> dcoutts: ooh, so you can edit gtk in gtk?
06:00:38 <vincenz> psykotic: http://programming.reddit.com/info/2aioh/comments/c2azqq
06:00:39 <lambdabot> Title: 37 Reasons to Love Haskell (playing off the Ruby article) (reddit.com)
06:00:44 <dcoutts> erm, all it means is that we will not need libglade any more, and the api and feature set will be slightly better
06:00:47 <vincenz> psykotic: read parent and grandparent as well :)
06:00:53 <vincenz> dcoutts: spiffy :)
06:00:59 <dcoutts> yeah, fewer deps too
06:01:16 <Saizan> MisterN: Control.Concurrent.Chan is half the way there i think
06:05:06 <wli> [...,(" :: (",16),...]
06:05:16 <wli> *** Exception: no codeword to cover ":: (Eq a, Ord [a], ...
06:05:31 <wli> Ah, something ate the space.
06:06:35 <MisterN> Saizan: well i would imagine that every process has a message type that it can accept et al
06:09:29 <Saizan> MisterN: well Chan is polymorphic in the message type, but you want the actual channel specified in the type and not passed to the process as a value?
06:10:02 <MisterN> Saizan: encoded in the process identifier's type?
06:10:52 <Saizan> MisterN: yes, like process1 :: IO (Proc Chan1)
06:11:52 <vincenz> dcoutts: how hard is it to get syntax-coloring in TextArea's?
06:11:57 <vincenz> or rather TextBuffer
06:12:11 <dcoutts> vincenz: easy! use SourceBuffer & SourceView
06:12:40 <MisterN> Saizan: sorry i don't understand (I'm still new to haskell)
06:13:07 <dcoutts> vincenz: or if you're a masochist then you can do what Lemmih did and use a TextBuffer along with a custom lexer (using a modified version of ghc's lexer)
06:13:31 <dcoutts> vincenz: see the sourceview demo in gtk2hs, it's really easy
06:13:42 <vincenz> dcoutts: it'd be neat to tie that onto lambdabot
06:13:46 <vincenz> dcoutts: for a haskell ide
06:13:55 <Saizan> MisterN: ah well, i was trying to understand what you mean by type-safe message passing
06:14:11 <dcoutts> vincenz: yes, easier said than done however
06:14:42 <Syzygy-> ?hoogle Double -> Int
06:14:42 <lambdabot> No matches, try a more general search
06:14:53 <Syzygy-> How do I round decently?
06:14:55 <Syzygy-> ?hoogle Double -> Integer
06:14:56 <lambdabot> No matches, try a more general search
06:15:12 <Syzygy-> ?hoogle Integral a => Double -> a
06:15:13 <lambdabot> No matches, try a more general search
06:15:28 <vincenz> Syzygy-: how's it going?
06:15:35 <vincenz> @type round
06:15:37 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
06:15:39 <vincenz> :)
06:16:11 <Syzygy-> vincenz: Trying to juggle things together. But right now, GTK2Hs isn't my problem.
06:16:11 <MisterN> Saizan: well, in erlang, every process has a mailbox that can accept any type of messages. which would not be very haskell-y so i thought about a mailbox that can only accept messages with a process-defined type. or so.
06:18:36 <Saizan> MisterN: (Chan a) once you've specified "a" is mailbox that can accept only a determined type of messages, the problem is associating that to a process (which is just an IO action on which you call forkIO in haskell), you've to pass the channel as a value to all the process that need to use it
06:19:02 <Saizan> MisterN: where in erlang each process has a named channel iirc
06:19:32 <Saizan> s/process/processes/
06:19:49 <MisterN> each erlang process has a PID that can be passed through functions and in messages. also, processes can be registered and from there on have names.
06:20:00 <MisterN> which is all very untyped.
06:25:10 <Saizan> yeah, so we currently have the safe mailboxes but not the "mailman"
06:25:31 <Saizan> (or the addresses, rather)
06:26:00 <MisterN> Saizan: and i have no idea how to fix that. you?
06:29:20 <Saizan> MisterN: something very vague, we probably need a central entity to pass those Chans around under the API
06:30:25 <MisterN> Saizan: maybe a mailboxed-process function could be identifier for the process itself?
06:30:37 <int-e> Chan lacks another property - scheduler influence; as far as I understand, in Erlang a process with a full message queue gets its priority bumped so it gets a chance to catch up.
06:31:20 <opqdonut> good point
06:31:40 <MisterN> well that shouldn't happen at all
06:31:55 <MisterN> erlang's message queues are not fixed size
06:32:24 <opqdonut> he probably meant fuller
06:32:33 <int-e> yes I did
06:32:45 <opqdonut> :)
06:32:47 <MisterN> i see
06:33:34 <MisterN> how well does Chan work across the network boundary? between multiple nodes that is
06:34:07 <Saizan> ah yeah, it doesn't :)
06:34:19 <opqdonut> what would be the next best thing?
06:34:25 <opqdonut> a "Chan over the net"
06:35:03 <MisterN> well, in erlang you can just do RemoteProcess ! hey_this_message_goes_over_the_net
06:35:50 <roconnor> ugh, writing arctangent is so much easier than proving it correct.
06:35:57 <int-e> erlang *is* better at inter-thread and -process communication
06:36:28 <tcr> ndm: ping
06:36:36 <ndm> tcr: pong
06:37:08 <tcr> ndm: You're the chap behind Uniplate?
06:37:14 <ndm> tcr: indeed
06:37:38 <visof> is haskell have libraries for math and physics like c++?
06:37:44 <tcr> ndm: Nice work. I'm currently trying it out.
06:38:04 <ndm> tcr: cool, thanks :)
06:39:54 <msouth> visof: have you seen http://hackage.haskell.org/packages/archive/pkg-list.html ?
06:40:10 <doserj> also: http://www.haskell.org/haskellwiki/Applications_and_libraries/Mathematics
06:40:19 <visof> msouth no
06:40:24 <MisterN> haskell is not very good for mathematics
06:40:39 <lambdabot> Title: Applications and libraries/Mathematics - HaskellWiki, http://tinyurl.com/37jtrh
06:40:47 <ndm> MisterN: it could be, it just lacks the necessary libraries at the moment
06:40:57 <visof> MisterN why?
06:41:17 <MisterN> well it was intended to be ironic
06:41:31 <MisterN> after all, haskell is the preferred language of many mathematicians
06:42:25 <quicksilver> it was true, even if ironic
06:42:25 <visof> MisterN what is the most suitable language for math in your opinion?
06:42:28 <quicksilver> althouhg a bit general
06:42:41 <quicksilver> haskell isn't very good for various areas of mathematics due to lack of libraries
06:42:46 <quicksilver> although it's excellent language-wise
06:43:03 <tcr> ndm: I'm currently trying to write a function that does alpha conversion over an AST. I'm not sure how to handle variable shadowing, i.e. in `f x = case x of Frobz x -> baz x', only the outer x should get renamed.
06:43:30 <MisterN> visof: i don't know because it was ironic but now i'm puzzled
06:44:12 <doserj> visof: are you looking for anything in particular?
06:44:19 <ndm> tcr: in general, its tricky - see http://darcs.haskell.org/yhc/src/libraries/core/Yhc/Core/FreeVar.hs - replaceFreeVars
06:44:21 <lambdabot> http://tinyurl.com/2mc3eh
06:44:48 <ndm> tcr: but the final line should be         x -> descend (replaceFreeVars ren) x
06:44:49 <int-e> tcr: stop renaming for the subtree when the variable gets bound (you need to find out where that happens anyway)
06:45:08 <ndm> when i wrote that code, Uniplate wasn't called Uniplate and didn't have a descend method
06:45:09 <int-e> tcr: but I'm making assumptions about the AST here.
06:45:39 <tcr> int-e: It's pretty clear to me how to do it conceptually, thanks. :) It's my haskell skills that are lacking.
06:45:44 <visof> doserj i studies quantum mechanics and linear algebra and topology
06:46:19 <ndm> tcr: whatever you do, don't take the example of subst from the paper, since that ignores issues of variable shadowing
06:47:09 <mwc_> !instance IORef Eq
06:47:09 <tcr> ndm: Should I use `descend' rather than `transform'?
06:47:19 <mwc_> @instance IORef Eq
06:47:19 <lambdabot> Maybe you meant: instances instances-importing
06:47:26 <mwc_> @instances Eq
06:47:27 <lambdabot> (), All, Any, Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, Product a, Sum a, [a]
06:47:31 <ndm> tcr: definately, since the operation requires a changing "what to replace" set, and must be top down
06:47:41 <doserj> visof: you might be interested in http://www.haskell.org/haskellwiki/Numeric_Quest
06:47:43 <lambdabot> Title: Numeric Quest - HaskellWiki
06:47:53 <mwc_> Hmmm. is there a way to tell if two IORef's are "the same" in the sense taht modification to one affects another?
06:47:58 <SamB_XP_> ndm: that's okay if you've run a renamer first ;-P
06:48:03 <ndm> transform applies the same action to all nodes, which a substitution function can't do
06:48:24 <ndm> SamB_XP_: indeed, if you have unique variables, its easy - and indeed, having unique variables is often an easier solution
06:49:29 <wli> I need unfoldAcc f x = case f x of { Just (r, x') -> let (rs, x'') = unfoldAcc f x' in (r : rs,  x'') ; Nothing -> ([], x) }
06:49:38 <Saizan> mwc_: yes, IORef is an instance of Eq
06:50:19 <EvilTerran> Saizan, is that instance Eq a => Eq (IORef a), or just instance Eq (IORef a)?
06:50:52 <tcr> ndm: Ah, descend looks nice. The implicit recursion in transform was exactly my problem. :)
06:50:59 <EvilTerran> (by which i mean, i wouldn't've been surprised if comparing IORefs compared their contents rather than their addresses
06:51:19 <vincenz> EvilTerran: I doubt you need Eq a for Eq (IORef a)
06:51:20 <vincenz> Eq is pure
06:51:24 <vincenz> can't access the underlying value
06:51:25 <ndm> tcr: yes, its usually what you want, but occasionally you need more control
06:51:39 <EvilTerran> ah. yeah, that makes sense.
06:51:43 <edward1> vincenz: good point
06:52:09 <MisterN> @instances MonadPlus
06:52:11 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
06:52:35 <tcr> ndm: Btw. I'm using PlayTypable, but I didn't really understand the bit about sprinkling instances of Uniplate foo with uniplate = uniplateAll.
06:52:41 <roconnor> you must realize the truth:  Thre is no underlying value.
06:53:13 <mwc_> EvilTerran: you know, it's amazing that haskell's type system can tell you the difference between how Eq a => Eq (IORef a), and Eq (IORef a) functions
06:53:16 <tcr> ndm: I just added those to make the type checker happy. Do I have to add an instance for every of my n syntax tree types?
06:53:21 <ndm> tcr: did you just copy out an instance "instance Uniplate foo where uniplate = uniplateAll" for each data type?
06:53:34 <tcr> ndm: No for everyone as of now.
06:53:49 <tcr> s,no,not,
06:53:53 <ndm> tcr: you only need them for things you invoke uniplate on directly, so if you have enough for the type checker to be happy, its enough
06:54:20 <EvilTerran> mwc_, yeah, it's great. "okay, there's no class context for that parameter, so the instance/fn/etc doesn't actually look at those values in any way"
06:54:23 <tcr> ndm: Yeah that's what I figured, but I'd like when the circumstances when it won't be enough.
06:54:33 <ndm> i.e. you probably never use transform on the program data type, you probably use transformBi, so no need for a Uniplate instance for the program type
06:55:07 <ndm> the type you are playing with in a Uniplate traversal must have a Uniplate class
06:55:16 <ndm> typically, that means the central expression type is the only one
06:55:16 <tcr> ndm: Uh actually it complained about missing instances when I tried to use universeBi on it.
06:55:38 <ndm> tcr: thats probably an ambiguous type instance, rather than that kind of problem
06:56:50 <ndm> tcr: if you do universeBi Program, it doesn't know what the result is unless you use the result in a specific way
06:57:18 <tcr> ndm: f quux = [ Foo x | Foo x <- universeBi quux ]
06:57:49 <tcr> ndm: it complains about missing Uniplate instance for the type of Foo.
06:57:50 <ndm> tcr: oh, that is plenty bound, you'll need PlateAll on the type of quux, and PlateAll and Uniplate on the type of Foo
06:57:57 <ndm> yes, you do need Uniplate on Foo there
06:59:00 <tcr> Well I've generated PlateAll instances for all my types semi-automatically by an emacs script (>300 lines)
06:59:10 <tcr> I wonder if I should generate those Uniplate instances too.
06:59:37 <ndm> tcr: have you seen Derive? it generates all these things automatically
06:59:44 <ndm> @where derive
06:59:44 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/derive/
07:00:36 <tcr> ndm: Yeah, I didn't really get it working the last time I tried it.
07:00:56 <ndm> tcr: i wrote derive too, so if you have a particular bug report i can probably fix that
07:01:07 <ndm> tcr: using the darcs version, or the hackage tarball?
07:01:27 <ndm> i think the hackage version is out of date with respect to the Uniplate tarball
07:01:48 <ndm> i want to re-release it this week with that fixed, to coincide with the paper
07:02:18 <dcoutts> dons: I heartily approve of your beating up on python (reading that rle post), the performance link at the end is a nice added dig. :-)
07:02:34 <tcr> Dunno. It was some time ago, I played with it two or three hours, didn't figure out how to use properly, then gave up. :)
07:02:47 <ndm> tcr: it should take a few seconds, if you follow the manual
07:03:16 <tcr> Yeah, I had problems applying to my specific case.
07:03:21 <ndm> dons: i loved that too, but you should take it to the end, where the Python one gives a version that is polymorhpic (apart from tuples)
07:04:16 <ndm> tcr: if you want to try now, i'll help you through it
07:06:23 <tcr> ndm: Alright, you can test it yourself. I want to generate Uniplate instances for the data types defined in Language.Haskell.Hsx.Syntax
07:06:40 <tcr> I'm installing Data.Derive meanwhile.
07:06:50 <ndm> tcr: where do i get hsx?
07:07:27 <SamB_XP_> @where haskell-src-exts
07:07:27 <lambdabot> I know nothing about haskell-src-exts.
07:07:31 <SamB_XP_> @where hsx
07:07:32 <lambdabot> http://www.cs.chalmers.se/~d00nibro/haskell-src-exts/
07:08:28 <ndm> ah, i've got that one somewhere on my machine...
07:16:38 <ndm> tcr: there was a bug in the PlateTypeable derivation, just fixing it...
07:17:40 <tcr> ndm: Heh. I'm messing with trying to import Data.Derive.PlateTypable... but ghci says it can't find it although I've just installed derive from the darcs repo.
07:18:12 <ndm> tcr: did you runhaskell Setup install ?
07:21:58 <tcr> ndm: Alright, now it works.
07:22:09 <ndm> tcr: no, it won't, it will just go wrong later :)
07:22:14 <SamB_XP_> edward1: hey, where is this Set restricted monad that fails the monad laws?
07:23:00 <tcr> ndm: running derive over a file with importing Data.DeriveTH and Data.Derive.PlateTypeable, and then $( derive makePlateTypeable ''HsExp ) does exactly nothing.
07:23:02 <ndm> tcr: fix pushed
07:23:23 <tcr> Silly me
07:23:58 <tcr> ndm: Did you patch Derive or Uniplate?
07:24:24 <ndm> tcr: give me 10 mins, i'll patch everything and send you a Uniplate file for Hsx
07:24:33 <gkr> Why we do "s -> m (a, s)" and not "m (s -> (a,s))" on StatT?
07:25:11 <sorear> gkr: Because the monadic action might depend on the state.
07:25:32 <sorear> do { x <- get ; when (x > 0) (lift (putStrLn "hi!")) }
07:25:47 <tom_> hi all
07:25:53 <fasta> sorear: you can encode the state in the type system, I suppose ;)
07:26:03 <tcr> ndm: fine with me.
07:26:04 <gkr> And why not "s -> (m a, s)"?
07:26:14 <sorear> fasta: Not if it doesn't show up until run time
07:26:32 <int-e> gkr: because the followup state may depend on whatever you do in m
07:27:05 <tom_> Quick question about syntax: in "class Arrow a  ArrowState s a | a -> s where" what does the bit after the pipe mean?
07:27:17 <mauke> it's a functional dependency
07:27:31 <gkr> Uhm. I thought it was just "let's try with this" (Bird says so indeed)
07:27:31 <mauke> it means s is uniquely determined by a
07:27:57 <tom_> so for any given type a, type s will always be the same?
07:28:00 <int-e> tom_: it says that the type a determines the type s. (in other words it's illegal to have two instances that have the same a but differ in s)
07:28:07 <mauke> yes
07:28:22 <ndm> tcr: although i am wondering why you just don't import PlateData instead? wouldn't that work without any instances
07:28:41 <tom_> how does that work int he context of ArrowState though? Surely the s part is the state type which you'd want to vary
07:28:55 <malsyned> If the original definition of a type doesn't contain a "deriving" clause, there's no way to make that type an instance of a derivable class via the derivation mechanism later, is there?  you have to define the instance functions explicitly?
07:29:12 <mauke> malsyned: right
07:29:27 <malsyned> mauke: that seems like something one might want to do.  Is there a good reason why it's not possible?
07:29:38 <edward1> dons++ the RLE thing is cute.
07:29:45 <mauke> AFAIK no
07:29:47 <EvilTerran> @where FFI
07:29:47 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
07:29:51 <Saizan> tom_: the type a usually contains s, like data ArrowS s a b = ... instance ArrowState s (ArrowS s) where ..
07:30:37 <tom_> ah, right that sort of makes sense, enough sense to go back to staring at code anyway :p
07:30:39 <tom_> thanks!
07:30:44 <tcr> ndm: Does it just work?
07:30:51 <ndm> tcr: yes
07:30:58 <ndm> or, i can't see why it wouldn't
07:31:14 <malsyned> Could it be that you would have to have information about the type that is only available in the defining source code, and not made available by interface files for separate compilation?  That doesn't seem likely, but it's the only possible reason I could come up with.
07:31:44 <Saizan> malsyned: i think that there's actually a proposal for standalone deriving
07:31:55 <SamB_XP_> malsyned: it's not that it isn't in the interface file
07:32:14 <ndm> tcr: but if you give me an email address, i can give you the PlateTypeable derivation, from Data.Derive, with a few tweaks
07:32:31 <tcr> ndm: (I wanted to test out the other approach (i.e. gaining experience) because it made the impression on being a pretty heavy dependence on GHC -- and I'm using multiply parametic type classes already which are quite portable, I thought.)
07:32:37 <SamB_XP_> but, if not all the constructors are *exported*, you shouldn't really be allowed to do a deriving
07:33:48 <SamB_XP_> > deriving
07:33:48 <lambdabot>  Parse error
07:34:00 <SamB_XP_> so is deriving actually a keyword, then? nice.
07:34:30 <gnuvince> > let x = 10 in x * y where y = 20
07:34:30 <lambdabot>  Parse error
07:34:46 <sorear> yeah, it says so in the report's lexical syntax :)
07:34:48 <ndm> tcr: it is more portable the other way, but my suggestion is that if you would choose to develop with GHC anyway, use PlateData now, then if you want to release and get Hugs compatibility its easy to do afterwards
07:34:58 <malsyned> SamB_XP_: yeah.  You can't implement "deriving" in the language, nor can you define a new derivable class in the language.
07:35:19 <ndm> tcr: but if you give me an email address, i'll send you the PlateTypeable instances, since i've got them written anyway using Data.Derive
07:35:36 <tcr> ndm: Well, I'm more interested in how you used Data.Derive to get at them. :)
07:35:55 <sorear> this something I broke?
07:36:13 <ndm> tcr: derive Syntax.hs --derive=PlateTypeable > Uniplate.hs
07:36:16 <ndm> sorear: no, my fault
07:36:18 <ndm> @hpaste
07:36:19 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:36:51 <hpaste>  ndm pasted "PlateTypeable stuff at the top, for tcr" at http://hpaste.org/1990
07:37:13 <ndm> tcr: then i added those lines at the top, to get the imports/modules right, and do define what to do for Rational
07:38:41 <tcr> I see. Thanks!
07:39:06 * mux has fun with TAPL
07:39:15 <mux> I'm really happy to have bought it
07:40:17 <tcr> ndm: Btw. I think the reason why I didn't try PlateData is because repChildren in your paper confused the hell out of me. What's behind that?
07:40:56 <wli> mux: Any particularly valuable exercises?
07:40:56 <mux> it's nice to see the underlying features of lambda calculus, system F, system F omega, etc etc that give the foundations for the haskell features we know
07:41:02 <ndm> tcr: thats how it implements it underneath, its got exactly the same interface, so you can just ignore it
07:41:23 <ndm> tcr: repChildren confuses me too, it took forever to right that, esp getting all the performance critical bits right
07:41:50 <mux> wli: I enjoyed the exercises of chapter 23 & 24, writing stuff in the pseudo-system f omega coded by the author in OCaml (the fullomega program)
07:42:14 <ndm> hmm, the repChildren in my paper is 100's of times simpler than the real one :)
07:42:27 <ndm> i only put in the simple one
07:42:36 <mux> that makes me wish haskell had a syntactic form allowing introducing existential types at the term-level
07:42:44 * wli needs to bang out more monadic interpreters.
07:42:56 <mux> with pack/unpack semantics
07:43:10 <wli> mux: What are pack/unpack semantics?
07:43:10 <mux> I think the "open" keyword suggested in SPJ's paper about first-class modules is just that
07:44:11 <mux> wli: pack is when you introduce an existential type, unpack/open is when you use it
07:45:24 <SamB> hmm. How does the left distribution law work...
07:46:10 <mux> existential_types++
07:46:27 <SamB> http://haskell.org/haskellwiki/MonadPlus_reform_proposal
07:46:28 <lambdabot> Title: MonadPlus reform proposal - HaskellWiki
07:48:16 <SamB> @check \a b k -> mplus (a :: Maybe I) b >>= k = mplus (a >>= k) (b >>= k)
07:48:16 <lambdabot>  Parse error
07:48:24 <SamB> @check (\a b k -> mplus (a :: Maybe I) b >>= k = mplus (a >>= k) (b >>= k))
07:48:24 <lambdabot>  Parse error
07:48:36 <SamB> @check (\a b k -> mplus (a :: Maybe I) b >>= k == mplus (a >>= k) (b >>= k))
07:48:37 <lambdabot>  Couldn't match expected type `I -> Maybe a'
07:49:00 <SamB> @check (\a b k -> (mplus (a :: Maybe I) b >>= k) == (mplus (a >>= k) (b >>= k)))
07:49:01 <lambdabot>  Add a type signature
07:49:37 <tcr> ndm: what's so wrong about the subst in your paper?
07:49:41 <SamB> @check (\a b k -> (mplus (a :: Maybe I) b >>= k) == (mplus (a >>= k) (b >>= k) :: Maybe I))
07:49:43 <lambdabot>  Falsifiable, after 13 tests: Just 8, Just (-9), <Int -> Maybe Int>
07:49:51 <SamB> @scheck (\a b k -> (mplus (a :: Maybe I) b >>= k) == (mplus (a >>= k) (b >>= k) :: Maybe I))
07:49:52 <lambdabot>   Failed test no. 101. Test values follow.: Just (-1), Just 0, -3->
07:49:52 <lambdabot>   Nothing...
07:51:33 <SamB> oh I get it now
07:59:26 <osfameron> @src splitAt
07:59:26 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
07:59:52 <MisterN> is this the real implementation?
07:59:58 <osfameron> isn't that suboptimal?  i.e. recurses down xs twice ?
08:00:09 <MisterN> heh osfameron, two morons same thought
08:00:09 <wli> I daresay.
08:00:18 <osfameron> MisterN:  :-)
08:00:19 <mauke> no, @src is not real
08:00:37 <osfameron> ah!
08:00:49 <MisterN> @src take
08:00:49 <lambdabot> take n _      | n <= 0 =  []
08:00:49 <lambdabot> take _ []              =  []
08:00:49 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
08:01:11 <MisterN> i hoped for a recursive implementation in terms of splitAt :D
08:03:02 <mauke> splitAt (I# n#) ls
08:03:02 <mauke>   | n# <# 0#	= ([], ls)
08:03:02 <mauke>   | otherwise	= splitAt# n# ls
08:03:02 <mauke>     where
08:03:02 <mauke> 	splitAt# :: Int# -> [a] -> ([a], [a])
08:03:04 <mauke> 	splitAt# 0# xs	   = ([], xs)
08:03:07 <mauke> 	splitAt# _  xs@[]  = (xs, xs)
08:03:09 <mauke> 	splitAt# m# (x:xs) = (x:xs', xs'')
08:03:12 <mauke> 	  where
08:03:16 <mauke> 	    (xs', xs'') = splitAt# (m# -# 1#) xs
08:03:29 <sjanssen> mwahaha
08:03:52 <sjanssen> @keal
08:03:52 <lambdabot> are you saying i am MegaMonad?
08:03:56 <sjanssen> @keal
08:03:56 <vincenz> @keal
08:03:57 <lambdabot> with KealDigit quantum crackproof encryption possible
08:03:57 <lambdabot> Keal was so happy with T, coded in basic so run on anything, and does lot
08:04:13 <osfameron> what are the # symbold ?
08:04:24 <mauke> eye candy
08:04:24 <sjanssen> osfameron: it means "unboxed"
08:04:34 <vincenz> mauke: tabs are evl
08:04:36 <vincenz> +i
08:04:46 <mauke> no, mixing tabs and spaces is evil
08:04:55 <vincenz> mauke: tabs are evil
08:04:55 <osfameron> oh... is unboxed just an optimization ?
08:04:56 <mauke> I don't know why GHC/List.lhs does it
08:05:42 <dcoutts> mauke: I think it does not need to. I think that code is older that the automatic worker/wrapper transform.
08:05:59 <dcoutts> that def of splitAt is a manual worker/wrapper transform
08:06:00 <sjanssen> osfameron: yeah, they're trying to get better performance by using GHC's primitives directly
08:06:33 <osfameron> sjanssen: ok, ta
08:06:58 <wli> Is there some way to do it with a fold or unfold or something?
08:07:22 <sjanssen> wli: you can do it with a paramorphism, but that isn't in the standard libraries
08:07:53 <sjanssen> wli: the problem with a 'foldr' is that you'd lose sharing in the second chunk
08:09:55 <wli> Remind me what a paramorphism is.
08:10:13 <wli> fg
08:10:14 <xerox> fold . unfold
08:10:48 <psykotic> i want to invent new -morphisms
08:10:52 <sjanssen> xerox: nah, that hylo IIRC
08:11:00 <sjanssen> s/that/that is
08:11:01 <xerox> you may be right, hm
08:11:24 <Botje> !quote morphism
08:11:31 <psykotic> eromorphism
08:11:32 <Botje> bah
08:11:35 <Botje> @quote morphism
08:11:35 <psykotic> the morphism of love
08:11:35 <lambdabot> JohnMeacham says: There will also be a karaoke competition to determine the fate of the monomorphism restriction.
08:11:36 <mauke> @quote morph
08:11:36 <lambdabot> ski says: please talk to your son or daughter about parametric polymorphism
08:12:08 <hpaste>  sjanssen pasted "paramorphism on []" at http://hpaste.org/1991
08:12:55 <wli> sjanssen: Doubtless generalizable to Data.Traversable
08:12:57 <edward1> wli: a paramorphism is pretty much what people think of when they say general recursion.
08:13:21 <sjanssen> wli: I don't think Traversable gives us the tools to build para
08:13:58 <wli> sjanssen: doh you're right
08:14:15 <edward1> para can be built up off of a cata
08:14:32 <sjanssen> edward1: cata+cons
08:14:39 <sjanssen> edward1: and you lose sharing
08:16:35 <tcr> ndm: Still there?
08:16:36 <edwardk> i'm being a little slow here but i don't see the need for cons its just a (,)e comonadic catamorphism isn't it?
08:17:45 <edwardk> er cata and fmap are needed no?
08:19:07 <wli> Would para need its own typeclass?
08:19:36 <edwardk> wli: http://www.eyrie.org/~zednenem/2004/hsce/Control.Recursion.html has a pretty good derivation of para and other -morphisms
08:19:37 <xerox> ?where+ catext http://www.eyrie.org/~zednenem/2004/hsce/
08:19:38 <lambdabot> Done.
08:20:19 <Botje> Is there a "morphisms for dummies" somewhere? :)
08:20:33 <mauke> dummymorphism
08:20:49 <integral> bananas, lenses and barbed wire?
08:21:04 <edwardk> yeah integral probably mentioned the best starting place
08:21:20 <integral> [http://citeseer.ist.psu.edu/meijer91functional.html]
08:21:20 <Botje> hmm
08:21:33 <Botje> I read that one, don't remember much
08:21:36 <Botje> i'll read it again, thanks :)
08:22:07 <wli> factorial = para (maybe 1 (uncurry ((*) . (+1))))
08:22:32 <edwardk> http://citeseer.ist.psu.edu/meijer91functional.html and then http://research.microsoft.com/~emeijer/Papers/Thesis.pdf uses the technique more (and includes the former as a chapter)
08:22:33 <lambdabot> Title: Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire (Research ...
08:23:24 <wli> I remember reading it ages ago. I've obviously forgotten everything.
08:23:40 <edwardk> most people forget the stuff after cata/ana/hylo
08:24:00 <hpaste>  sjanssen annotated "paramorphism on []" with "splitAt in terms of para" at http://hpaste.org/1991#a1
08:24:18 <edwardk> and it doesn't help that a lot of them require stumbling around in random papers or the web to discover like the metamorphism and apomorphism constructions
08:25:34 <wli> could've been flip $ para f (const ([],[]))
08:25:55 <MisterN> @src para
08:25:55 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
08:25:58 * edwardk can see wli is an instant paramorphism convert ;)
08:26:14 <MisterN> what's para?
08:27:19 <edwardk> mistern: 'general recursion' like a cata but you can 'have your cake and eat it too' needed to cleanly build general recursive functions in a constructive algorithmics setting
08:27:47 <doserj> MisterN: http://www.eyrie.org/~zednenem/2004/hsce/Control.Recursion.html#v%3Apara
08:27:48 <lambdabot> http://tinyurl.com/2voo54
08:27:55 <MisterN> sorry i have no clue what you just said, edwardk :)
08:28:20 <MisterN> doserj: src knows Prelude only?
08:28:40 <edwardk> mistern: para isn't in any standard library
08:28:49 <doserj> src knows the "standard" libraries
08:29:13 <doserj> (whatever "standard" means)
08:29:25 <MisterN> edwardk: oh the link somehow looked like a standard library documentation link
08:29:28 <MisterN> never mind
08:29:57 <edwardk> mistern: it was generated by haddock like the standard library docs
08:30:09 <MisterN> i know
08:30:16 <sorear> doserj: sadly, no
08:30:25 <sorear> @src (->) (+++)
08:30:26 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
08:30:32 <sorear> and yet
08:30:37 <sorear> @src unsafePerformIO
08:30:37 <lambdabot> unsafePerformIO (IO m) = lazy (case m realWorld# of (# _, r #) -> r)
08:31:09 <doserj> lambdabot has a peculiar interpretation of "standard" :)
08:31:36 <edwardk> basically a paramorphism gives a more natural definition to a lot of recursive functions than building them up using hylomorphisms the hard way, since it can follow the general structure of normal inductive proof while the hylomorphic version doesn't.
08:33:10 <gnuvince> @hoogle nub
08:33:11 <lambdabot> List.nub :: Eq a => [a] -> [a]
08:33:11 <lambdabot> List.nubBy :: (a -> a -> Bool) -> [a] -> [a]
08:33:12 <gwern> heya everyone. I've written a little program to remove the first n lines from a program, but it involves making a temporary copy and then moving it back over the original - requiring 2n storage space and is kind of slow for large files. is there anyway to thusly manipulate a file 'in place', so to speak? I haven't found anyway yet
08:33:37 <MisterN> edwardk: #haskell isn't the best place for people who just want to program without doing heavy maths, eh?
08:34:17 <edwardk> mistern: depends, a lot of people get by quite well in haskell without ever touching the cata/ana/hylo stuff =)
08:34:18 <Jaak> gwern: strict bytestrings, maybe?
08:34:58 <edwardk> especially since its not in any standard library
08:35:01 <gwern> Jaak: so you would keep the file contents in memory or something?
08:35:14 <arcatan> gwern: probably you could start overriding file from the start and finally truncate the file somehow. dunno, if that's any faster, though
08:35:20 <MisterN> edwardk: "fix" is in the standard library and it's bad enough (ok, i understand it but it's evil)
08:35:44 <gwern> arcatan: start overrding file? what do you mean?
08:35:50 <edwardk> Note para is only used by the 'post-docs' in http://www.willamette.edu/~fruehr/haskell/evolution.html
08:35:51 <lambdabot> Title: The Evolution of a Haskell Programmer
08:36:48 <osfameron> gwern: you could change your datastructure and have various smaller files, and then use a simpler log-rotation algorithm to keep the appropriate number of files, then catenate them together...
08:36:52 <edwardk> I love how logical fallacies are useful computational tools in Haskell. (a -> a) -> a is 'assuming the hypothesis'. loeb's paradox gives a spreadsheet-like function, etc.
08:36:56 <wli> No fixpoint instance for Maybe.
08:37:22 <gwern> osfameron: there's no datastructure to be changed here - it's for shell scripting. just a file and a burning need for it to be shorter :)
08:37:35 <osfameron> gwern: a file *is* a data structure :-)
08:37:36 <arcatan> gwern: open file in r+ mode, seek the spot where you want to begin, read a byte, go to beginning, write a byte, seek, write, seek, write until ready, truncate file
08:37:43 <Jaak> B.writeFile fn . B.unlines . drop n . B.lines $ B.readFile fn -- or something like this, really easy
08:37:51 <arcatan> + some reads there
08:37:58 <Jaak> but it does read the hole thing into memory
08:38:06 <gwern> Jaak: that's atually basically how I'm doing it
08:38:31 <gwern> but I think you can't use readFile and writeFile that way because readFile's laziness prevents writeFile from, well, writing
08:38:46 <Jaak> you can with strict bytestrings
08:38:47 <gwern> (or that's the explanantion I saw in the libraries when I tried to do that and kept getting file-locked errors)
08:38:53 <jacquesmerde> sorry for the n00b question, but i've tried googling. what is the "right" way to define a sub-type, say the natural numbers subclass of Integer
08:39:03 <sjanssen> jacquesmerde: newtype
08:39:09 <wli> The pointfree factorial version doesn't typecheck.
08:39:38 <gwern> jacquesmerde: newtype. but from my experience defining the positive subset of real numbers, you'll be doing a lot of writing to get any useful operations
08:39:50 <gwern> Jaak: really? neat. then I guess I will go back to that then
08:39:51 <wli> Actually the module's got typos in it.
08:40:01 <sjanssen> jacquesmerde: define 'newtype Natural = Natural Integer' in a module.  Don't export the 'Natural' constructor, and only provide primitives that preserve the invariant
08:40:15 <edwardk> jacquesmerde: newtype Natural = Natural Integer deriving (Eq,Show,...) then you'll need to redefine the Num instance to throw errors when it goes negative, etc.
08:40:25 <wli> cons :: c -> (a -> b -> c) -> (ConsPair a b -> c) had "ConsPair" typo'd as "Cons"
08:40:28 <Jaak> gwern: just test it, it's only few lines of code
08:41:31 <gwern> Jaak: btw, would using lazy instead of strict be a problem?
08:42:05 <gwern> (lazy usually has better memory usage the past times I've used it)
08:42:05 <jacquesmerde> sjanssen: i want this all in a single .hs file. i also want to redefine all arithmetic and logical operations myself (but i'll have to omit more than the prelude, yeah?
08:42:25 <wli> In fact the non-pointfree example doesn't typecheck either.
08:42:38 <sjanssen> jacquesmerde: you can do import Prelude hiding (foo, bar)
08:43:07 <sjanssen> jacquesmerde: you can do this in a single module, but it's easier to prevent mistakes by using a separate module
08:44:31 <jacquesmerde> actually, i want to do this all from scratch. i'm not so much writing a program, but putting all my logic and metamathematics notes into an .hs file
08:46:16 <jacquesmerde> where can i find where the Integer datatype and its Instances are defined?
08:46:23 <jacquesmerde> i'm looking at hoogle now...
08:46:29 <ndm> Prelude
08:46:40 <edwardk> jacquesmerde: Integer is more or less primitive its implemented using GMP.
08:46:51 <edwardk> it uses a bunch of primops to do all the heavy lifting
08:47:09 <edwardk> (in GHC that is)
08:47:33 <jacquesmerde> edwardk: yeah, that's what i feared. its not defined IN haskell is it?
08:47:37 <edwardk> I do think it'd be kinda neat to go through and build up an non-strict Integer some day over a list of Ints or  something
08:47:45 <edwardk> jacquesmerde: fraid not
08:47:59 <doserj> you can look at GHC.Num
08:48:05 <wli> edwardk: Word64 please.
08:48:36 <ndm> jacquesmerde: someone sent an Integer in Haskell to the Yhc mailing list last week
08:48:40 <edwardk> wli: of course, though there is still no good access to overflow information
08:48:49 <doserj> data Integer = S# GHC.Prim.Int# | J# GHC.Prim.Int# GHC.Prim.ByteArray#
08:48:51 <ndm> edwardk: why over [Int], why not Peano, if you are going non-strict
08:48:51 <edwardk> neil: ooh, neat i need to go find that
08:49:00 <Stinger> integer as list of booleans ;)
08:49:08 <gwern> Jaak: doesn't seem to work. 'deleteL n file = B.writeFile file =<< (liftM (B.unlines . drop n . B.lines) $ B.readFile file)' &  deleteL 10 "/home/gwern/note" -> *** Exception: /home/gwern/note: openFile: resource busy (file is locked) in GHCi
08:49:12 <Stinger> slightly inefficient
08:49:17 <edwardk> neil: because I lack the higher education to have completely given up my commitment to efficiency ;)
08:49:18 <ndm> "pure-Haskell Integer implementation", 5 days ago
08:49:27 <Jaak> gwern: with Strict bytestring?
08:49:30 <ndm> yhc mailing list
08:49:48 <Jaak> lazy wont work
08:49:52 <jacquesmerde> is Num itself a datatype? or just a class?
08:49:57 <gwern> Jaak: nah, lazy. just to say that I was right that lazy wouldn't work
08:50:04 <Jaak> oh, right
08:50:11 <doserj> @src Num
08:50:11 <lambdabot> class  (Eq a, Show a) => Num a  where
08:50:11 <lambdabot>     (+), (-), (*)           :: a -> a -> a
08:50:11 <lambdabot>     negate, abs, signum     :: a -> a
08:50:11 <lambdabot>     fromInteger             :: Integer -> a
08:50:14 <edwardk> breaking it out into Ints or Int64s at least offers the pretext that you might somehow save work with laziness by not building parts of the integer you don't need
08:50:19 <Stinger> someone save that edwardk quote
08:50:34 <edwardk> stinger: hah
08:51:01 <edwardk> this is why i'm leery of adding a Ph.D to my academic credentials ;)
08:51:46 <wli> http://article.gmane.org/gmane.comp.lang.haskell.yhc/1020
08:51:48 <fasta> Is it possible to write the following instance? data Foo a b = Foo a b; instance (MonadTrans t, Monad m, Monad (t m)) =>   MonadState (Foo a b) (t m) where
08:51:48 <lambdabot> Title: Gmane -- Mail To News And Back Again
08:52:17 <Stinger> @remember edwardk  Because I lack the higher education to have completely given up my commitment to efficiency ;)
08:52:17 <lambdabot> Done.
08:52:35 <sjanssen> fasta: you'll have trouble writing a monad instance for Foo
08:52:44 <sjanssen> fasta: what is the defn. of return?
08:52:53 <gwern> is there any little function for timing how long a function takes in GHCi?
08:53:19 <swiert> sjanssen: Did you get my e-mail?
08:53:23 <sorear> gwern: time(1) isn't good enough?
08:53:26 <sjanssen> fasta: oh, sorry.  I read that incorrectly
08:53:39 <edwardk> @quote edwardk
08:53:39 <lambdabot> edwardk says: notes that in haskell, it seems that you asymptotically approach writing no code over time as you learn your way around whats already there
08:53:55 <doserj> gwern: :set +s
08:53:55 <edwardk> was just curious what i'd been quoted for ;)
08:54:00 <sjanssen> swiert: yes.  Sep. 1 is fine
08:54:16 <swiert> sjanssen: Great. Looking forward to your submission.
08:54:49 <Igloo> edwardk: Was it you who wrote teh Haskell Integer impl?
08:55:15 <gwern> sorear: for inside ghci?
08:55:18 <fasta> sjanssen: no idea?
08:55:19 <edwardk> igloo: not this one. I wrote a type level 16s complement integer library
08:55:28 <Igloo> Ah, OK
08:55:48 <Igloo> ndm: Did the code for that ever materialise? What license is it under? I'd be interested in a copy
08:55:56 <gwern> doserj: that anything like :set -v?
08:55:57 <gwern> I don't actually want to try this for fear of what the OOM will do, but what hapens when you try to read something into strict bytestrings bigger than physical RAM?
08:56:00 <sjanssen> fasta: the instance looks okay, but I don't see how you'll achieve the MonadState operations
08:56:14 <Stinger> does Haskell expose information about the basic types somehow?
08:56:16 <edwardk> http://comonad.com/haskell/type-int/ and its BSD, and should also be on hackage
08:56:18 <lambdabot> Title: Index of /haskell/type-int
08:56:26 <sjanssen> fasta: you're very polymorphic wrt. the monad type
08:56:29 <edwardk> I think I never got around to adding GCD and a couple of other things like that
08:56:36 <edwardk> but its robust insofar as it goes
08:56:38 <fasta> sjanssen: can't I use something like lift (State(\s -> <>))?
08:56:48 <wli> edwardk: I need primes mostly.
08:56:50 <jacquesmerde> and how do i make a meta-type? in my logic file i have Connectives, Constants, and Variables data types, i want a new type which includes all of them so i can cons them together to make logical sentences
08:57:04 <edwardk> wli: i mostly wanted some types to annotate array sizes, etc ;)
08:57:17 <edwardk> and i didn't want to pay the performance hit of peano ;)
08:57:26 <jacquesmerde> (oh yeah, and i'd have to have a Brackets type, too
08:57:28 <edwardk> again looking for practical asymptotics
08:57:32 <sjanssen> fasta: no, because your instance is forall Monad m and transformer t
08:57:34 <wli> edwardk: (irreducible polynomials in Z/pZ or otherwise Galois fields if you feel like getting fancy).
08:57:50 <edwardk> that has a 2s complement and 16s complement implementation. the former is all haskell the latter is almost all template haskell.
08:58:03 <fasta> sjanssen: right, that's a mistake.
08:58:07 <sjanssen> fasta: that instance matches (ReaderT r IO), for example.  That won't work
08:58:14 <edwardk> and the latter really was an exercise in write-only programming while I learned TH =)
08:58:31 <fasta> sjanssen: that should be MonadState s m
08:58:47 <fasta> sjanssen: er
08:58:55 <edwardk> Haddock doesn't interact well with Template Haskell
08:59:08 <fasta> sjanssen: MonadState (Foo a b) m *
08:59:31 <edwardk> One of these days it'd be kinda neat to plat with generating Haddock like information from a .hi file perhaps so I could see the several thousand instances it generates behind the scenes that I have to hide from Haddock.
08:59:34 <sjanssen> fasta: still won't work
09:00:13 <fasta> sjanssen: because?
09:00:18 <sjanssen> fasta: what are you trying to achieve?
09:00:30 <sjanssen> fasta: because you haven't established that m or t actually support MonadState
09:00:46 <sjanssen> you can't really define the MonadState operations without something concrete to build from
09:00:59 <fasta> sjanssen: ? Didn't I just define that?
09:01:15 <fasta> sjanssen: I added MonadState (Foo a b) m to the context
09:01:18 <ndm> Igloo: i never saw the code, but Isaac said he'd done it, so he probably has
09:01:22 <sjanssen> fasta: oh, to the context
09:01:37 <sjanssen> fasta: I thought you wanted to change the instance head
09:01:50 <sjanssen> fasta: yeah, that's okay then
09:02:02 <sjanssen> fasta: it is massively overlapping though
09:02:12 <Igloo> ndm: I don't doubt that he has, but that doesn't help me use it  :-)
09:02:14 <fasta> sjanssen: well, the instance is ok, I am just not sure how to implement it :)
09:02:26 <sjanssen> fasta: get = lift get, etc.
09:02:43 <ndm> Igloo: email him, and i'm sure he'll give you a copy
09:02:55 <fasta> sjanssen: no, I want to do something with Foo first.
09:03:10 <int-e> @instances-importing Control.Monad.Trans MonadState
09:03:14 <lambdabot> s (ContT r m), s (ErrorT e m), s (RWS r w s), s (RWST r w s m), s (ReaderT r m), s (State s), s (StateT s m), s (WriterT w m)
09:03:25 <fasta> sjanssen: so, I need to be able to inspect s (the state) and then do something.
09:03:36 <fasta> sjanssen: i.e. I want to select only a part of Foo
09:04:09 <int-e> hmm. that output is a bit hard to read
09:04:10 <sjanssen> fasta: so you want to transform the state that the monad really contains into a Foo?
09:04:13 <fasta> sjanssen: but for that I need to have that that function (the one normally in a State constructor) to be available.
09:04:34 <fasta> sjanssen: no
09:04:55 <gkr> Why is it "m (Either e a)" and not "Either e (m a)"?
09:05:09 <Saizan> instance (MonadTrans t, ...., MonadState (Foo ..) m) => MonadState (PartOfFoo ..) (t m) where
09:05:28 <sjanssen> fasta: why do you need the constructor?  return, get, put, >>= totally subsume it, AFAICT
09:05:34 <edwardk> gkr: because the latter wouldn't allow you to perform the monadic computation to get any interesting errors out of it
09:05:48 <int-e> gkr: because whether you got an error or not can depend on what happened inside m
09:06:11 <edwardk> gkr: you'd get something that was 'either an error or a computation to be performed', you couldn't encounter an error during the computation and get out that type.
09:06:42 <gkr> Aahp.
09:07:11 <gkr> I don't understand why Bird doesn't explain that on his book... he just says he tried the other way and he couldn't do it.
09:08:33 <edwardk> gkr: basically the other way would let you record errors in 'setting up the computation to be performed', but the way it is allows you to basically flag errors during the performing of the computation, which is generally more useful
09:08:54 <edwardk> gkr: which book?
09:09:34 <gkr> Introduction to functional programming using Haskell.
09:09:58 <edwardk> ah never picked it up. going to throw it on the to-buy-and-skim-when-i-get-bored list =)
09:10:42 <fasta> sjanssen: I wrote this function. Now, I need to use it in the instance somehow. Just using this as get blows up, though. get_imp :: (MonadState (Foo a s) m, MonadTrans t) => t m s
09:10:48 <gkr> I started learning Haskell from it, it's nice, but sometimes I have to read a little more from the Wiki.
09:12:15 <sjanssen> fasta: why does this need to be in an instance?
09:12:42 <fasta> sjanssen: I want to use it transparantly with another class.
09:13:57 <sjanssen> you want to write the instance "instance (MonadState (Foo a s) m, MonadTrans t) => MonadState s (t m)", right?
09:14:37 <sjanssen> fasta: you should be able to write get = get_imp
09:14:49 <fasta> sjanssen: right(I just figured out that myself too)
09:14:56 <sjanssen> fasta: note how this has major overlapping problems
09:15:30 <fasta> sjanssen: you suggest not using this?
09:15:33 <sjanssen> fasta: GHC might even reject the instance, because of the fundep on MonadState
09:15:37 <sjanssen> fasta: yeah
09:15:54 <fasta> sjanssen: should I just write an instance MonadState for FooT then?
09:16:03 <sjanssen> fasta: perhaps
09:17:56 <jacquesmerde> so the prelude is just the type definitions of basic functions and data types, but no actual definitions? they are all hardcoded and merely typed by the prelude?
09:18:15 <SamB> jacquesmerde: huh?
09:18:22 <SamB> jacquesmerde: what gives you that idea?
09:18:25 <shapr> hiya delYsid
09:18:29 <mauke> some of them, yes
09:19:34 <sjanssen> jacquesmerde: nearly all of the Prelude stuff has real definitions
09:19:37 <jacquesmerde> sorry, i take that back
09:19:55 <sjanssen> jacquesmerde: there are only a few things that can't be written in plain Haskell, like the data defn. for [a]
09:20:07 <jacquesmerde> SamB: lack of sleep does :(
09:20:50 <dcoutts> jacquesmerde: different haskell systems implement the prelude differently, some of it can be define in plain Haskell, other bits require compiler-specific primitives or other black magic.
09:20:59 <SamB> sjanssen: that doesn't stop them from writing it does it?
09:21:43 <SamB> dcoutts: yeah, but the report does include pretty much everything that can be defined in plain haskell (and then some, I think)
09:21:46 <sjanssen> SamB: sure, if the compiler writer really wants to extend the whole compiler machinery to do that
09:21:55 <jacquesmerde> just got confused when i saw "data Integer" in the prelude
09:22:09 <dcoutts> jacquesmerde: for example it's easy to define the map function in plain Haskell, but the implementation of (+) for Ints is compile-specific
09:22:19 <dcoutts> compiler
09:22:27 <sorear> @src Integer
09:22:28 <lambdabot> data Integer = S# Int#
09:22:28 <lambdabot>              | J# Int# ByteArray#
09:22:44 <SamB> see all the sharp things?
09:23:03 <SamB> very compiler-specific
09:23:10 <sjanssen> yes, they stand for "look, but don't touch"
09:23:17 <mauke> what does J# stand for?
09:23:29 <SamB> I think it comes after I#
09:23:32 <SamB> @src Int
09:23:33 <lambdabot> data Int = I# Int#
09:23:44 <SamB> not too sure though
09:24:03 <Igloo> I'm pretty sure that's it
09:24:06 <int-e> how about small / jumbo
09:24:16 <kilimanjaro> int-e, that works
09:24:21 <mauke> snacks / junkfood
09:24:48 <int-e> igloo is probably right though :)
09:24:53 <sorear> @src Int (+)
09:24:53 <lambdabot> Source not found. I've seen penguins that can type better than that.
09:24:55 <sorear> @src Int +
09:24:56 <lambdabot> Source not found. The more you drive -- the dumber you get.
09:25:02 * sorear grumbles.
09:25:04 <jacquesmerde> i think i've solved my problem! data Natural = Zero | Succ Natural
09:25:10 <MisterN> @src Natural
09:25:10 <lambdabot> Source not found. stty: unknown mode: doofus
09:25:18 <MisterN> @src -
09:25:18 <lambdabot> x - y = x + negate y
09:25:23 <mauke> type Natural = [()]
09:25:46 <jacquesmerde> ?
09:26:33 <SamB> hmm.
09:26:47 <SamB> what's GHC.Num.toBig for, I Wonder?
09:26:59 <mauke> zero = []; succ = (() :)
09:27:23 <sjanssen> jacquesmerde: your type is isomorphic to a list of ()s
09:28:11 <jacquesmerde> sjanssen: yeah, and the positive numbers are isomporphic to the negative ones. isnt it just a question of aesthetics?
09:28:36 <sjanssen> jacquesmerde: yes.  Just trying to clear up mauke's obscure observation
09:28:48 <fasta> sjanssen: can I define get to using the generic get function as a part?
09:30:10 <SamB> sjanssen: but lists aren't strict in their elements...?
09:30:48 <sjanssen> SamB: yeah, they're not quite the same
09:30:49 <jacquesmerde> so succ is a function which just cons an empty tuple? why use empty tuples?
09:31:11 <sjanssen> [ _|_ ] can't be represented with the Natural data type above
09:31:33 <sjanssen> jacquesmerde: because we have to fill the list with something!
09:32:02 <Saizan> type Natural = forall a. [a]
09:32:06 <SamB> heh
09:32:19 <SamB> there
09:32:20 <fasta> sjanssen: never mind
09:32:24 <SamB> you can fill it with nothing now
09:32:33 <SamB> (and only with nothing)
09:32:35 <sjanssen> _|_ :: a
09:33:21 * sjanssen <3 parametricity
09:33:39 <jacquesmerde> sjanssen: i know, i was just curious about the way to respond to the arbitrariness
09:33:50 <jacquesmerde> arbitrariality?
09:33:54 <jacquesmerde> arbitration?
09:34:06 <jacquesmerde> arbitrage?
09:34:07 <jacquesmerde> collage?
09:34:36 <MisterN> @where collage
09:34:36 <lambdabot> I know nothing about collage.
09:36:38 <vincenz> are we playing charades?
09:37:09 <MisterN> who knows
09:37:55 <Japsu> Hmm
09:37:59 <Japsu> now THIS looks evil
09:38:12 <MisterN> huh?
09:38:13 <Japsu> My nifty little network hack seems to crash GHC without an error message
09:38:38 <Japsu> I'll poke around a bit and have the sources on the Internets soon.
09:38:59 * glguy ponders kicking people for getting excited about things before they announce what they are... (can't handle the suspense!)
09:44:58 <fasta> glguy: what are you waiting for?
09:45:27 --- mode: ChanServ set +o vincenz
09:45:48 --- kick: glguy was kicked by vincenz ("stop the suspense of whom you're going to kick!")
09:45:53 --- mode: vincenz set -o vincenz
09:45:59 --- mode: ChanServ set +o vincenz
09:46:01 --- mode: vincenz set -o vincenz
09:46:42 <Saizan> was he opped?
09:47:01 <fasta> vincenz: :D
09:47:13 * vincenz coughs
09:47:24 <Japsu> lol
09:47:29 <Japsu> but hey
09:47:41 <vincenz> What person doesn't have auto-rejoin tho..
09:47:47 <vincenz> I even invited him again -.-
09:48:21 <Japsu> if anyone's interested in trying my code and seeing if it crashes their haskell runtime, please darcs get http://pajukanta.fi/darcs/channel and try compiling and running (ghc --make) the example server and client
09:48:24 <lambdabot> Title: Index of /darcs/channel
09:48:33 <glguy> vincenz: do you know how to enable irssi auto rejoin?
09:48:53 <xerox> /set auto should show you all the options with "auto" in them
09:49:02 <vincenz> glguy: let me check
09:49:06 <glguy> xerox: I did that
09:49:06 <vincenz> glguy: yo rejoined silently?
09:49:09 <glguy> none were relevent
09:49:15 <glguy> ?
09:49:18 <Japsu> there's two interesting things here, first if I start the server and just netcat to it and say "Ping" or "Quit", it works fine
09:49:34 <Japsu> but if I use the example client, server silently crashes
09:49:42 <vincenz> glguy: how did you come back in?
09:49:51 * vincenz saw no join  o.O
09:49:53 <Japsu> then I tried the server in ghci, it crashed ghci completely (again silently)
09:49:56 <glguy> I'm a ghost
09:49:57 <fasta> Via a backdoor!
09:49:58 <xerox> hmpf
09:50:05 <Japsu> no error, no nothing
09:50:20 <vincenz> spooky
09:50:31 --- mode: ChanServ set +v vincenz
09:50:43 <fasta> vincenz: he renamed
09:51:09 <vincenz> oh right, and then his hostname changed
09:51:14 <SamB> * vincenz coughs
09:51:14 <SamB> --- airic is now known as glguy
09:51:14 <SamB> <
09:51:15 <fasta> glguy leads a double life
09:51:16 <vincenz> hmm, I'm voiced
09:51:21 <SamB> whoops
09:51:24 --- mode: ChanServ set +o vincenz
09:51:25 --- mode: vincenz set -o vincenz
09:51:26 <SamB> where'd that < come from
09:51:32 <glguy> heh
09:51:36 <vincenz> still voiced
09:51:36 <glguy> that's not what you meant
09:51:42 --- mode: ChanServ set +o vincenz
09:51:47 --- mode: vincenz set -v vincenz
09:51:47 <glguy> op and voice aren't exclusive
09:51:51 --- mode: vincenz set -o vincenz
09:51:52 <vincenz> ah :)
09:51:53 <xerox> /mode #haskell -v vincenz
09:51:55 --- mode: ChanServ set +v vincenz
09:52:04 <SamB> hahaha
09:52:29 --- mode: ChanServ set +o xerox
09:52:31 <vincenz> SamB: I ignore everything except msgs, actions and joins, too much spam
09:52:34 * vincenz mutters
09:52:38 <vincenz> still voiced!
09:52:38 --- mode: xerox set -v vincenz
09:52:43 <SamB> again
09:52:45 --- mode: xerox set -o vincenz
09:52:48 --- mode: xerox set -o xerox
09:53:01 * vincenz is going to have to turn off his ignore filtering to see who's doing that
09:53:09 <glguy> chanserv is
09:53:10 <SamB> --- ChanServ gives voice to vincenz
09:53:16 * vincenz winces
09:53:18 <SamB> right before I said "hahaha"
09:53:24 <vincenz> oh well
09:53:32 <vincenz> \o/ gone
09:53:40 <xerox> :)
09:54:10 <fasta> mode/#haskell [-v vincenz] by xerox
09:54:16 <vincenz> back to your regularly programmed #haskell
09:55:21 <Saizan> Listening for connections on port 19454
09:55:21 <Saizan> Client connected, spawning client thread
09:55:21 <Saizan> Got Ping, sending Pong and continuing
09:55:34 * glguy continues searching for auto rejoin
09:55:36 <Saizan> Japsu: and then dies
09:55:45 <Saizan> Japsu: is that what you get?
09:56:05 <Japsu> Saizan: exactly
09:56:45 <Japsu> Hmm
09:56:50 <Japsu> Apparently it gets SIGPIPE
09:56:59 <Japsu> japsu@hinaaja channel % ./server &
09:56:59 <Japsu> [1] 26764
09:56:59 <Japsu> japsu@hinaaja channel % Listening for connections on port 19454
09:56:59 <Japsu> Client connected, spawning client thread
09:56:59 <Japsu> Got Ping, sending Pong and continuing
09:57:02 <Japsu> [1]  + broken pipe  ./server
09:57:11 <Japsu> How can that be.
09:57:21 <Japsu> Are SIGPIPEs normal on TCP sockets?
09:57:52 <Japsu> I've never had to deal with them in POSIX C TCP programming.
09:58:04 <kilimanjaro> > map (\x -> (2n+1)/(n^2 * (n+1)^2)) [1..10]
09:58:08 <lambdabot>   Not in scope: `n'
09:58:13 <kilimanjaro> woops
09:58:18 <kilimanjaro> > map (\n -> (2n+1)/(n^2 * (n+1)^2)) [1..10]
09:58:19 <lambdabot>   add an instance declaration for (Num (a -> a))
09:58:49 <vincenz> glguy: Anyway, if you REALLY want to do that, and you understand that you're doing evilness, you can use the autorejoin.pl script that comes with irssi. You'll still need to specify the channels you wish to rejoin with /SET autorejoin_channels #chan1 #chan2 ...
09:58:54 <vincenz> glguy: from faq
09:59:12 --- mode: ChanServ set +o vincenz
09:59:14 --- kick: vincenz was kicked by vincenz (vincenz)
09:59:14 <Japsu> Autorejoin's considered mortal crime on some channels
09:59:23 <vincenz> nope
09:59:34 <Japsu> Prolly doesn't work if you kick yourself. :)
09:59:51 --- mode: ChanServ set +o vincenz
09:59:54 --- kick: vincenz was kicked by vincenz (vincenz)
09:59:56 <kilimanjaro> add an instance declaration for (Num (a -> a))? what did I do wrong?
09:59:59 <vincenz> works
10:00:03 <vincenz> ./load autorejoin.pl
10:00:06 <vincenz> ./set autorejoin_channels #haskell
10:00:08 <kilimanjaro> ohh oops I see it
10:00:10 <Japsu> heh, right
10:00:20 <int-e> > 0 0
10:00:21 <lambdabot>   add an instance declaration for (Num (t -> a))
10:00:21 <lambdabot>     In the expression: 0 0
10:00:21 <lambdabot>  ...
10:00:27 <vincenz> glguy: welcome :)
10:00:39 <kilimanjaro> > map (\n -> (2*n+1)/(n^2 * (n+1)^2)) [1..10]
10:00:40 <lambdabot>  [0.75,0.1388888888888889,4.861111111111111e-2,2.25e-2,1.2222222222222223e-2,...
10:00:42 <glguy> well... I don't think that it will be worth it if I have to install a script.. I only get kicked in fun generally
10:00:45 <glguy> but thanks
10:00:49 <vincenz> glguy: it comes with irssi
10:00:58 <glguy> oh?
10:01:00 <Japsu> Does autorejoin.pl support an autorejoin delay?
10:01:05 * glguy needs to dig through the scripts that come with it
10:01:33 <int-e> kilimanjaro: you probably forgot an argument to some function that returns a number
10:01:37 <vincenz> Japsu: seems to be hardcoded
10:01:41 <Japsu> right
10:01:46 <vincenz> Japsu: there's a mention in the .pl file "need to make this a setting"
10:01:50 <Japsu> okay
10:01:54 <vincenz> so find the .pl file, sudo vim autorejoin.pl
10:01:59 <Japsu> yeah
10:02:12 <Japsu> it probably wouldn't be much of work to implement it as a setting
10:02:41 * vincenz has no idea how irssi works
10:02:49 <kilimanjaro> int-e, I accidentally wrote "2n" instead of "2*n"
10:03:00 <kilimanjaro> and just completely overlooked it :)
10:03:03 <int-e> kilimanjaro: oh cute
10:03:08 <Saizan> Japsu: uh, fun, i just added putStrLn "Sent Pong" after send client Pong and the server doesn't crash anymore
10:03:21 <Japsu> Saizan: Hmm
10:03:33 <Saizan> Japsu: well, not anymore, just less reliably :)
10:03:45 <Japsu> Saizan: Well this is all guessing, but I think it might close the socket before the buffer has been emptied
10:03:56 <Japsu> I need to add a hFlush there.
10:03:59 <Japsu> Let's see
10:04:52 <Japsu> Nope, doesn't cut it
10:07:11 <Saizan> ?hoogle withSocketsDo
10:07:11 <lambdabot> Network.withSocketsDo :: IO a -> IO a
10:07:26 <Saizan> ?docs Network
10:07:26 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/network/Network.html
10:08:04 <Japsu> Oh.
10:08:05 <Japsu> Right.
10:08:14 * Japsu bashes his head against the table
10:08:20 <Japsu> http://haskell.org/ghc/docs/latest/html/libraries/network/Network.html#10
10:08:22 <lambdabot> http://tinyurl.com/yz42xr
10:08:31 * glguy has been reading the new book _Beautiful Code_
10:08:47 <Japsu> Now what I'm going to do is write my own initializer
10:08:51 <Japsu> withChannelsDo
10:09:01 <glguy> I've only made it through the first few chapters, but already I want to use subversion and regexes more
10:09:08 <Japsu> that setups that signal handler and then does withSocketsdo
10:09:11 <DRMacIver> glguy: Any good? I've been thinking of getting it.
10:09:21 <glguy> DRMacIver: I've enjoyed it
10:11:34 <Saizan> oh, SIGPIPE, but why writing to stdout helps? it causes a flush?
10:12:05 <Japsu> withChannelsDo :: IO () -> IO ()
10:12:06 <Japsu> withChannelsDo act = do
10:12:06 <Japsu>         installHandler sigPIPE Ignore Nothing
10:12:06 <Japsu>         withSocketsDo act
10:12:10 <Japsu> Saizan: it causes a delay
10:12:13 <Japsu> or something
10:12:14 <Japsu> dunno
10:12:20 <Japsu> but that's a race condition
10:12:42 <Japsu> undeterministic behaviour, impaired security and other sorts of evil stuff
10:12:48 <Saizan> yeah, but you'd want to write early, before the client dies, no?
10:13:40 <Japsu> yes
10:13:43 <Japsu> well the client is evil, too
10:13:52 <Japsu> it doesn't read the server's reply before closing
10:13:57 <Japsu> but any client could do that
10:14:07 <Japsu> I simply have to take that into account when writing a server
10:14:16 <Japsu> otherwise anyone could crash my server trivially
10:14:23 <Saizan> actually, removing withSocketsDo fromht eoriginal server code solves the silent crash as well
10:14:31 <Japsu> now that's interesting
10:14:42 <Japsu> because on unix, withSocketsDo shouldn't do anything
10:14:53 <vincenz> :t foldr
10:14:56 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
10:14:58 <Japsu> it's for windows compatibility, because windows requires some stupid WinSock_Init(); stuff
10:15:09 <Japsu> ...or so I read in the docks
10:15:10 <Japsu> *docs
10:15:11 <Saizan> Debian sid, ghc-6.6.1
10:15:19 <Japsu> Gentoo current, ghc-6.6.1
10:16:55 <Japsu> though
10:17:14 <Japsu> there's no Posix module here, even though the Network documentation refers to it >_<
10:17:49 <Saizan> nah, it still dies
10:18:23 <Japsu> Saizan: you mean after removing withSocketsDo?
10:18:29 <Japsu> But this isn't nice.
10:18:34 <Saizan> Japsu: yes
10:18:41 <Japsu> http://haskell.org/ghc/docs/latest/html/libraries/network/Network.html#10 refers to a nonexistent module called Posix
10:18:43 <lambdabot> http://tinyurl.com/yz42xr
10:19:07 <Japsu> ...nonexistent, if you ask Hoogle or my GHC installation, that is
10:19:10 <Japsu> @where Posix
10:19:11 <lambdabot> I know nothing about posix.
10:19:12 <Saizan> it's probably System.Posix now
10:19:14 <Japsu> @source Posix
10:19:15 <lambdabot> Posix not available
10:19:19 <Japsu> @index Posix
10:19:19 <lambdabot> bzzt
10:19:24 <Japsu> @index installHandler
10:19:24 <lambdabot> System.Posix.Signals, System.Posix.Signals.Exts, System.Posix
10:19:28 <Japsu> Hmm
10:20:12 <Japsu> Okay, System.Posix exists in my installation, though Hoogle doesn't know of such a module
10:20:21 <jacquesmerde> for composition of only two functions is the etiquette to curry or to bracket?
10:20:49 <Japsu> Okay, looking better
10:21:28 <vincenz> @type bracket
10:21:29 <Japsu> Though am I now sacrificing Windows compatibility?
10:21:31 <lambdabot> Not in scope: `bracket'
10:21:36 <Japsu> I mean, is System.Posix available on Windows?
10:21:39 <vincenz> jacquesmerde: you mean f . g ?
10:21:48 <kpreid> jacquesmerde: depends on the context
10:22:26 <Japsu> Saizan: Please do a darcs pull and try again
10:22:33 <Japsu> Saizan: Now it does signal handling.
10:23:30 <Saizan> ok
10:24:15 <Japsu> and now there's a makefile, too
10:24:27 <Japsu> (since 30 s ago)
10:25:44 <Saizan> seems to be working fine
10:26:02 <Saizan> however System.Posix.Signals doesn't exist on windows afaik
10:26:13 <shapr> Wasn't there some way to get the data parallel libraries to spit out code that runs on the nvidia graphics cards?
10:26:51 <Japsu> Saizan: Okay, thanks for testing
10:27:21 <Japsu> I don't do Haskell on Windows, so I might just decide not to worry about that
10:27:58 <Japsu> ...though if I did, how'd I do it? Is there some preprocessor thingy to leave out code on certain platforms?
10:28:06 <mrd> shapr: been wonderin where that is, too
10:28:13 <Saizan> cpp directives
10:28:40 <shapr> mrd: I just got an EN8600GT, thought it'd be nice to use that as a coprocessor for Haskell programs.
10:28:42 <Saizan> #ifdef UNIX ...
10:28:43 <Japsu> C preprocessor? is THAT available on Windows? :P
10:28:53 <mrd> you'll hate me, i have an 8800 ultra now
10:29:19 <mrd> you need the nvidia c compiler
10:29:20 <SamB> Japsu: doesn't every Haskell implementation come with a C compiler ;-P?
10:29:31 <Japsu> SamB: Err... Dunno. :P
10:29:34 <Saizan> there's cpphs!
10:29:40 <shapr> mrd: Ah, but if this works, I'll get another EN8600GT and use SLI ;-)
10:29:45 <Japsu> Saizan: Never used a Haskell compiler on Windows though.
10:29:49 * SamB is actually just kidding
10:29:56 <SamB> I think only GHC does
10:30:01 <Japsu> *SamB
10:30:26 <Saizan> on windows GHC comes with it's own perl and gcc, no?
10:30:41 <dcoutts> Saizan: yes
10:30:51 <Saizan> *its
10:30:51 <mrd> shapr: sorry, "Cg" compiler.  there's a debian pkg which installs it, i guess i'll try it later.
10:30:58 <shapr> mrd: Does the 8800 ultra have something spiffier than the 8600gt?
10:31:12 <shapr> mrd: I've got it installed already, just not sure how I can tell Haskell's NDP libs to use it.
10:31:13 <mrd> shapr: more memory and faster components
10:31:32 <shapr> mrd: Do you have an SLI motherboard also?
10:31:40 <mrd> no i opted not to do SLi
10:31:57 <shapr> Aha, I could still claim that my graphics are bigger than yours once I cough up another $120!
10:32:02 <mrd> dubious
10:32:06 <shapr> (Not like it'll happen anytime soon)
10:32:45 <shapr> And it won't matter to me at all if I can't get ChilliX's NDP speaking Cg...
10:32:53 <mrd> http://www.anandtech.com/video/showdoc.aspx?i=2988&p=20
10:32:54 <lambdabot> Title: AnandTech: ATI Radeon HD 2900 XT: Calling a Spade a Spade
10:33:16 <mrd> but i wonder if SLi is better for NDP
10:33:26 <mrd> assuming it can take advantage properly
10:33:30 <SamB> I have some pre-shader card
10:33:52 <shapr> SamB: If you'd told me I could have sent you my old box!
10:33:54 <shapr> But I gave it to my brother...
10:34:09 <SamB> but it has a big enough framebuffer to do 3d at my desktop size using recent X builds, which is more than can be said for my voodoo 3
10:34:33 <shapr> I wonder if anyone else on #haskell would be encouraged to write more Haskell if hardware showed up on their doorstep.
10:34:46 <jsnx> shapr: well, what kind of hardware?
10:35:00 <cr> haskell running on beefy nvidia card pipelines?
10:35:01 <shapr> Whatever I have left over :-)
10:35:20 <jsnx> cr: or on the cell processor...
10:35:29 <mrd> i wrote a small program to display 100 bouncing balls with some multithread action
10:35:34 <shapr> I'd have to do some actual organizing if there were deserving peoples who wanted relatively new boxes.
10:35:34 <mrd> kinda sucked =)
10:35:35 <SamB> say, Baughn is working on a newline-escaping filter for error messages from lambdabot. what should he replace newlines with?
10:35:50 <SamB> he tried "\n" but that's pretty ugly
10:35:58 <jsnx> shapr: yeah, there'd have to be an application process...
10:36:03 <sjanssen> SamB: semi-colon?
10:36:14 <mrd> you have a voodoo3?
10:36:16 <shapr> jsnx: It's easier if I already know the people.
10:36:21 <SamB> mrd: I do.
10:36:22 <Baughn> SamB: Not so much "for lambdabot" as "for the cdecl module". I settled on " | " already.
10:36:27 <SamB> well.
10:36:27 <mrd> that's like ... over 10 years old
10:36:29 <jsnx> shapr: yes, probably ;)
10:36:34 <kpreid> SamB: " / "
10:36:38 <mrd> wow
10:36:39 <shapr> mrd: Truly, the 8800 ultra kicks butt.
10:36:41 <SamB> Baughn: it can be repurposed!
10:36:42 <kpreid> SamB: as in poetry
10:37:09 <shapr> I'd rather have bought an OGD1 :-(
10:37:36 <shapr> This is a true hacker's graphics card: http://wiki.duskglow.com/tiki-index.php?page=OGD1
10:37:38 <lambdabot> Title: TikiWiki : OGD1
10:37:41 <mauke> 
10:37:45 <SamB> did I mention that Baughn made a cdecl plugin for lambdabot?
10:37:58 <shapr> What's cdecl?
10:38:08 <shapr> hiya conal
10:38:19 <Baughn> C type-declaration tool. Not very relevant here. ;)
10:38:20 <SamB> <fax> @explain void (*foo)(void (*)(void (*)(), void (*)()), void (*)());
10:38:20 <SamB> <Baughnie> declare foo as pointer to function (pointer to function (pointer to function returning void, pointer to function returning void) returning void, pointer to function returning void) returning void
10:38:37 <mrd> anyway you'll have to ask dons about Cg integration because he's the only one I've seen talk about it
10:38:42 <conal> shapr:  hi!
10:39:00 <kpreid> SamB: so it's a cobolifier?
10:39:01 <Baughn> ..I just hope cdecl is safe. Interfacing irc to C code gives me the willies.
10:39:04 * kpreid ducks and runs.
10:39:08 <SamB> kpreid: not exactly
10:39:15 <kpreid> (yeah, I know what it's for)
10:39:26 <sjanssen> Baughn: is there a reason it has to interface with C?
10:39:27 <mauke> Baughn: which cdecl are you using?
10:39:44 <SamB> Baughn: why don't you just, um, run cdecl?
10:39:53 <SamB> oh. buffer overflows?
10:40:29 <Baughn> SamB: That's exactly what it does
10:40:41 <Baughn> SamB: And for some perverse reason chroot(2) is limited to superusers
10:40:59 <Baughn> mauke: The one in the debian package
10:41:01 <SamB> that does seem somewhat perverse
10:41:11 <sjanssen> Baughn: clearly the solution is to rewrite cdecl in Haskell
10:41:33 <SamB> it's true
10:41:35 <Baughn> sjanssen: That would require me to understand C types first. No thanks.
10:41:36 <mauke> Baughn: what does it say for void foo(void x[2])?
10:41:44 <SamB> Baughn: it would?
10:41:50 <conal> on the topic of graphics processors, i'd love to resurrect my Vertigo project with collaboration, making it cross-platform and updating to modern gpus
10:41:59 <Baughn> mauke: Syntax error
10:41:59 <mrd> what does it do?
10:42:05 <mauke> wtf?
10:42:30 <Baughn> > word "  void foo(void x[2])"
10:42:31 <lambdabot>   Not in scope: `word'
10:42:36 <Baughn> > words "  void foo(void x[2])"
10:42:37 <lambdabot>  ["void","foo(void","x[2])"]
10:42:41 <shapr> @where vertigo
10:42:41 <lambdabot> I know nothing about vertigo.
10:42:50 <vincenz> Baughn: words s space based
10:42:54 <shapr> @where+ vertigo http://conal.net/Vertigo/
10:42:54 <lambdabot> Done.
10:42:57 <vincenz> well, isSpace based :)
10:43:06 <conal> shapr: thanks
10:43:08 <kpreid> mauke: did you mean "void foo(void *x[2])"?
10:43:15 <Baughn> vincenz: It is, yes. That tokenizing looks about right.
10:43:24 <mauke> kpreid: no
10:43:26 <Baughn> vincenz: words is what I use instead of the shell
10:43:47 <shapr> conal: Is vertigo libre?
10:43:49 <mauke> Baughn: I can write you a Haskell cdecl
10:43:50 <kpreid> oh, I see
10:43:51 <mrd> cool
10:43:52 <SamB> Baughn: you could use that tool that can parse C
10:43:53 <mauke> what interface do you need? :-)
10:44:01 <Baughn> mauke: Would you? :)
10:44:04 <SamB> do we have a Language.C yet?
10:44:05 <conal> shapr: libre??
10:44:12 <Baughn> mauke: String -> String would be best. :P
10:44:19 <mauke> haha, ew
10:44:43 <shapr> conal: As in, is it under one of the GPL/BSD/etc licenses?
10:44:57 <mauke> String -> (String, String) would be nicer
10:45:01 <mauke> one for stdout, one for stderr
10:45:10 <SamB> mauke: you were going to go for Language.C.Decl or something?
10:45:24 <mrd> my dual boot is to Vista 64, which I'm not even sure ghc runs on
10:45:31 <mauke> no, just a small program
10:45:42 <sjanssen> SamB: dcoutts has a pretty good C parser for c2hs
10:45:44 <Baughn> mauke: I'd be throwing it right back into irc anyway, so there's no need for a separate error channel, but by all means
10:45:47 <conal> shapr: the old version is not, but a new version could be.
10:45:55 <shapr> mrd: I dual boot to memtest86 ;-)
10:45:57 <SamB> sjanssen: isn't someone supposed to make that into Language.C
10:45:58 <SamB> ?
10:46:13 <sjanssen> SamB: yes . . . someone :)
10:46:18 <mrd> shapr: yea well, i didn't buy the card just to write hopengl demos =)
10:46:21 <SamB> but we can't remember who?
10:46:22 <mauke> Baughn: yeah, ok. then I won't bother with keeping track of source locations, etc :-)
10:46:33 <jacquesmerde> woah, who suggested data Number = Zero | Succ Number as equivalent to Number as a list? mauke?
10:46:42 <mauke> yes?
10:46:55 <shapr> mrd: Hey, I play tremulous also.
10:47:11 <SamB> tremulous sounds like an adjective, not a noun!
10:47:12 <shapr> And warzone2100, and torcs, and chromium, and lots of linux games.
10:47:24 <dcoutts> SamB: I can find out who it was who was looking into turning it into Language.C if you want, I've got the emails somewhere
10:47:27 <SamB> oh.
10:47:30 <dcoutts> if you really want to know
10:47:30 <sorear> hopengl works (very badly) without a 3d card
10:47:33 <SamB> I thought it was a musical instrument ;-)
10:47:38 <jacquesmerde> mauke: it's not isomorphic, because mine allows foo = Succ foo
10:47:50 <sorear> where by very badly I mean it tickles a 5-year-old crash bug in X.org
10:47:51 <sjanssen> jacquesmerde: repeat ()
10:47:54 <mauke> jacquesmerde: foo = () : foo
10:47:56 <sorear> jacquesmerde: foo = () ; foo
10:48:02 <SamB> jacquesmerde: foo = succ foo
10:48:28 * SamB actually remembers that succ = (() :)
10:48:34 <sjanssen> @quote stereo
10:48:34 <lambdabot> No quotes match. And you call yourself a Rocket Scientist!
10:48:37 <conal> besides Vertigo, who's interested in fooling around with GPUs from Haskell, and what ideas are floating around?
10:48:38 <xerox> foo = fix (() :)
10:48:41 <sjanssen> wha!?
10:48:47 <mrd> conal: dons and ndp
10:48:48 <sjanssen> @quote stereo.*
10:48:48 <lambdabot> No quotes match. That's something I cannot allow to happen.
10:48:52 <mauke> @stereo
10:48:52 <lambdabot> Unknown command, try @list
10:48:54 <jacquesmerde> won't haskell try and actually DO the cons'ing though?
10:48:57 <kpreid> @quote Cale stereo
10:48:57 <lambdabot> No quotes match. BOB says:  You seem to have forgotten your passwd, enter another!
10:49:04 <SamB> @quote
10:49:05 <lambdabot> boegel says: goes to inflate Itkovians balls
10:49:06 <sjanssen> jacquesmerde: laziness
10:49:08 <SamB> @quote
10:49:09 <lambdabot> Daveman says: Cale, what if I don't want to obey the laws?  Do they throw me in jail with the other bad monads?
10:49:09 <mauke> jacquesmerde: yes. what's the problem with that?
10:49:09 <conal> mrd: thanks
10:49:11 <SamB> @quote
10:49:11 <lambdabot> pkhuong says: you'll probably still want unsafeEquality or whatever, though
10:49:13 <DukeDave> @pl
10:49:13 <lambdabot> (line 1, column 1):
10:49:13 <lambdabot> unexpected end of input
10:49:13 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
10:49:14 <xerox> Cale was happy of having it (somehow) forgotten.
10:49:24 <conal> dons & ndp: here?
10:49:25 <SamB> xerox: I tend to agree
10:49:33 <mrd> conal: no i suspect he is asleep
10:49:42 <SamB> I just wanted to make sure it was removed on purpose
10:49:55 <conal> mrd: okay, thanks.
10:49:55 <mrd> conal: and NDP meaning the data parallel haskell effort, nested dp etc
10:49:57 <SamB> since karma got zeroed recently too...
10:49:58 <DukeDave> @pl (\xs -> concat $ zipWith (\x1 x2 -> [x1] : [x2] : []) xs (tail xs))
10:49:59 <lambdabot> join . ap (zipWith ((. (return . return)) . (:) . return)) tail
10:50:00 <jsnx> is anybody out there familiar with the "write yourself a scheme in 48 hours" tutorial?
10:50:06 <mrd> conal: he will probably be awake in 6 hours
10:50:10 <sjanssen> @karma
10:50:10 <lambdabot> You have a karma of 1
10:50:15 <sjanssen> wha?
10:50:21 <SamB> conal: who is ndp?
10:50:23 <sjanssen> @karma-all
10:50:23 <lambdabot>  "agentz"               24
10:50:23 <lambdabot>  "moritz"               20
10:50:23 <lambdabot>  "+"                    15
10:50:23 <lambdabot>  "masak"                 8
10:50:23 <lambdabot>  "der_eq"                5
10:50:25 <lambdabot> [39 @more lines]
10:50:31 <xerox> O_o
10:50:32 <SamB> conal: do you mean ChilliX?
10:50:35 <conal> any other live interest in 3D & Haskell?
10:50:35 <shachaf> +++
10:50:37 <shachaf> @karma +
10:50:37 <lambdabot> + has a karma of 16
10:50:38 <jacquesmerde> sorry guys, i get it now. i knew haskell was lazy, it just hadn't sunk in HOW lazy
10:50:40 <shachaf> ++-
10:50:43 <shachaf> +--
10:50:46 <sjanssen> what happened to the karma?!
10:50:48 <conal> SamB: ChilliX??
10:50:51 <jsnx> conal: how would you do it?
10:50:53 <Lemmih> sjanssen: Any recent reincarnations?
10:50:58 <mauke> jacquesmerde: that also works in OCaml (i.e. strict languages)
10:51:06 <sjanssen> Lemmih: no, not lately
10:51:27 <mrd> i was thinking of playing around with or creating a 3d-game library for hs.  i know a few are out there already.
10:51:28 <SamB> conal: chak. that guy who's working on Associated Types and Nested Data Parallism
10:51:33 <jsnx> i think i've solved the problem on merging the dotted list and plain list parsers
10:51:44 <hpaste>  jsnx pasted "dotted/plain list" at http://hpaste.org/1993
10:51:53 <conal> jsnx: i'd revisit & update Vertigo, which has a very functional style, but i'm interested in other approaches.
10:52:00 <jsnx> it passes my tests
10:52:04 <SamB> you said: <conal> dons & ndp: here?
10:52:20 <mrd> conal: wouldn't you compile to Cg these days?
10:52:22 <conal> SamB: oh, manuel.  thanks.  he's doing 3d?
10:52:32 <SamB> conal: no. but you mentioned "ndp"
10:53:14 <SamB> don't tell me there's a *person* called ndp?
10:53:18 <conal> SamB: oh!! "ndp"  now i'm clued in!
10:53:20 <jacquesmerde> well, i chucked foo = () : foo into ghci, then typed foo. now i'm sitting back and watching it go nuts. NOW who's so lazy, huh? HUH??
10:53:25 <jsnx> conal: that's kind of like libsh?
10:53:46 <mrd> > take 10 $ repeat ()
10:53:55 <lambdabot>  [(),(),(),(),(),(),(),(),(),()]
10:53:56 <mauke> jacquesmerde: if you have ocaml, try 'let rec foo = () :: foo;;'
10:53:58 <mrd> lambdabot is lazy
10:54:03 <jacquesmerde> haskell's laziness is NO match for mine
10:54:08 <sjanssen> jacquesmerde: what do you expect?  you asked for the whole thing, you get the whole thing :)
10:54:23 <sfultong> >take 10 $ iterate (:()) ()
10:54:27 <mrd> now now, he's only asked for a countably infinite list
10:54:46 <jsnx> conal: i guess that's useless for linux, right -- all directX stuff
10:54:47 <Saizan> now ask for the powerset of that list!
10:54:52 <SamB> conal: what did you mean by "ndp"
10:55:01 <sfultong> > take 10 $ iterate (:()) ()
10:55:02 <lambdabot>  Couldn't match expected type `[a]' against inferred type `()'
10:55:03 <SamB> jsnx: I want directx too
10:55:04 <mrd> > filterM (const [True,False]) [1..]
10:55:07 <lambdabot>  Exception: stack overflow
10:55:12 <jacquesmerde> mauke: i've never even heard of ocaml
10:55:17 <mauke> oh
10:55:19 <mrd> @where ndp
10:55:20 <lambdabot> http://darcs.haskell.org/packages/ndp/Data/Array/Parallel/ http://www.cse.unsw.edu.au/~chak/project/dph http://haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
10:55:22 <shachaf> mrd: That isn't a lazy power-list function, though.
10:55:29 <mrd> shachaf: yea, hmm
10:55:38 <jacquesmerde> mauke: it just makes me think of that movie, oh camel, where art thou
10:55:52 <conal> jsnx: i haven't looked at Sh for a while, though I know the paper ref'd vertigo.  right now, the Sh links I have aren't working.  i imagine it's pretty different without a genuinely higher-order language with lambda and powerful types.
10:55:53 <sfultong> > take 10 $ iterate (():) []
10:55:54 <SamB> mrd: he seemed to be referring to a person named "ndp"
10:55:54 <lambdabot>  [[],[()],[(),()],[(),(),()],[(),(),(),()],[(),(),(),(),()],[(),(),(),(),(),(...
10:56:03 <mrd> SamB: because I said "dons & ndp" and he got confused
10:56:19 <mrd> > inits [1..]
10:56:21 <lambdabot>  [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],[1...
10:56:27 <conal> mrd: exactly
10:56:52 <shapr> hmm
10:56:56 <sfultong> oh dear
10:57:03 --- mode: ChanServ set +o shapr
10:57:10 <Arnia> shapr!
10:57:14 <shapr> hkBst: done bouncing?
10:57:20 <shapr> Arnia! What's up?
10:57:27 <jacquesmerde> > [(),()..]
10:57:29 <lambdabot>  [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),...
10:57:42 <shachaf> > [()..]
10:57:43 <lambdabot>  [()]
10:57:47 <shachaf> > succ ()
10:57:48 <lambdabot>  Exception: Prelude.Enum.().succ: bad argument
10:57:51 <Arnia> shapr: Staring into the deep abyss of adjunctions between functors :)
10:57:58 <vincenz> > [1,1..]
10:58:00 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
10:58:02 <shapr> Arnia: Ah, adjunction junction...
10:58:07 --- mode: shapr set -o shapr
10:58:09 <sfultong> > zero ()
10:58:10 <lambdabot>   Not in scope: `zero'
10:58:15 <jacquesmerde> @src inits
10:58:16 <lambdabot> inits []     =  [[]]
10:58:16 <lambdabot> inits (x:xs) =  [[]] ++ map (x:) (inits xs)
10:58:46 <jacquesmerde> > let foo = () : foo
10:58:47 <lambdabot>  Parse error
10:58:49 <jacquesmerde> > foo
10:58:51 <Arnia> shapr: everytime I think I've got it, I lose it again
10:58:57 <lambdabot>   Not in scope: `foo'
10:59:01 <shapr> > [minBound .. maxBound] :: [Int]
10:59:02 <lambdabot>  [-2147483648,-2147483647,-2147483646,-2147483645,-2147483644,-2147483643,-21...
10:59:53 <mrd> > length( [minBound .. maxBound] :: [Int])
10:59:57 <lambdabot> Terminated
11:00:16 <jacquesmerde> > [minBound .. maxBound] :: [Integer]
11:00:17 <lambdabot>   add an instance declaration for (Bounded Integer)
11:00:17 <lambdabot>     In the expression: ma...
11:00:22 <conal> SamB: I've emailed dons.  thanks again for the tip and for clearing up my "ndp" confusion.
11:01:21 <SamB> conal: the only other thing I could think of that you could mean was ndm ;-)
11:03:21 <mrd> we need to write the next great video game in haskell
11:03:22 <SamB> oh, and I don't think the ndp people are interested in using 3D cards for 3D. not too sure about dons.
11:03:56 <sfultong> succ (maxBound :: Int)
11:03:58 <sfultong> > succ (maxBound :: Int)
11:04:00 <lambdabot>  Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
11:04:40 <sfultong> yeah, haskell needs to have more neat videogames made for it, to increase its popularity
11:04:42 <Philippa> mrd: it's hard enough to do in C++
11:04:50 <shachaf> SamB: We know dons runs OpenBSD, so 3D cards are ruled out. :-)
11:04:54 <sfultong> although... maybe increasing its popularity would be bad...
11:05:58 <jsnx> sfultong: yeah, it would become like ruby...
11:06:20 <SamB> shachaf: I mean, the ndp people want to use 3d cards for data processing
11:06:33 <shachaf> SamB: Oh.
11:06:33 <sfultong> but if it was trendy, everyone would want to hire me...
11:06:40 <sfultong> that is, after I get good
11:06:41 <jsnx> the irc channel would get clogged with spj fandom
11:06:44 * shachaf wasn't really reading the rest of the conversation, sorry.
11:07:19 <magnus> What is wrong with this code?:
11:07:27 <shapr> jsnx: I thought it already was?
11:07:27 <magnus> instance Bounded a => Arbitrary a where arbitrary = elements [minBound,maxBound]
11:07:28 <vincenz> magnus: stop!
11:07:37 <vincenz> oh
11:07:37 <magnus> vincenz, it's only a one-liner :)
11:07:41 <vincenz> magnus: simple
11:07:45 <mauke> s/,/../
11:07:50 <vincenz> magnus: you can't have (Foo a) => (Bar a)
11:07:55 <vincenz> magnus: that's not valid hasklel98
11:07:59 <vincenz> magnus: it can lead to overloaded definitions
11:08:03 <vincenz> magnus: you must introduce a typeconstructor
11:08:13 <SamB> sfultong: you don't want people to hire you because Haskell is trendy
11:08:15 <vincenz> instance Bounded a => Arbitrary (SomeTypeConstructor a) where ..
11:08:27 <kpreid> vincenz: you mean it can lead to undecidability, right?
11:08:41 <vincenz> kpreid: overloaded...undecideability..potay-toe...potah-toe :)
11:08:42 <SamB> though admittedly it'd be better than being hired because Java was trendy
11:08:57 <shapr> vincenz: Though sjanssen wrote up a cool hack to autodefine arbitrary definitions for various instances of a typeclass.
11:09:01 <magnus> vincenz, I see, thanks... I'll just write all my instances manually
11:09:07 <Philippa> vincenz: uh, no, you want "overlapping". Typeclasses're all about overloading
11:09:10 <sfultong> yeah, working for trend-based hirers would probably be bad
11:09:19 <vincenz> Philippa: I mean you'll have multiple instantiations for the same type
11:09:20 <Khoth> Which is better than being hired because cobol isn't trendy any more
11:09:22 <conal> kpreid: not just undecidability.  haskell type instance resolution ignores the precedents like Foo a
11:09:33 <vincenz> Philippa: instance Bounded a => Arbitrary a where
11:09:38 <SamB> Khoth: I thought that was extremely lucrative if you could land a job
11:09:43 <vincenz> instance Arbitrary [a] where
11:09:46 <vincenz> instance bounded [a] where ..
11:09:49 <vincenz> well you get hte idea
11:09:53 <SamB> unfortunately they want you to know a bunch of other stuff, like DB2
11:09:55 <vincenz> (though list is the wrong example, not sure it's bounded)
11:10:05 <Khoth> SamB: Probably, but you'd have to use cobol
11:10:43 <sfultong> sometimes it's fun to try and write well-organized code in old and crufty languages
11:10:47 <SamB> Khoth: I suppose so.
11:10:49 <conal> does anyone know *why* instance selection just uses instance decl heads and not contexts?  i'm not sure i'm using standard terms here and would appreciate correction.
11:10:58 <SamB> but maybe you could use easytrieve a lot too?
11:11:22 <SamB> conal: it has something to do with decideability
11:12:06 <conal> SamB: probably, but maybe more.  for instance, there's -fallow-undecidable-instances, and *still* the preconditions (context) are ignored.
11:12:20 <vincenz> conal: what do you mean by context?
11:12:35 <vincenz> conal: the stuff before => in instance-declarations?
11:12:45 <conal> vincenz: yes
11:12:48 <gnuvince> whois vincenz
11:13:03 <SamB> /whois vincenz
11:13:08 <vincenz> conal: and instance decl heads ==?
11:13:16 * vincenz is not vincenz :)
11:13:27 <MisterN> vincenz is christiophe?
11:13:28 <conal> vincenz: after the =>
11:13:42 <gnuvince> vincenz: so you're not the reddit guy?
11:13:43 <shapr> christophe
11:13:44 <vincenz> conal: ok, thanks for the clarification, and intriguing
11:13:45 <vincenz> gnuvince: I am
11:13:52 <gnuvince> Ah
11:13:58 <vincenz> gnuvince: well 'the reddit guy'.. I am vincenz on reddit.
11:14:00 <hpaste>  conal pasted "overlapping instances :)" at http://hpaste.org/1994
11:14:13 <SamB> @google notvincenz
11:14:15 <lambdabot> http://notvincenz.blogspot.com/2007/04/observations-from-date-2007.html
11:14:15 <lambdabot> Title: lambda.oasis: Observations from DATE 2007
11:14:32 <vincenz> gnuvince: Why do you ask?
11:14:35 <MisterN> shapr: "Christiophe" is how the other #haskell person wrote it after confusing him with another Christoph
11:14:35 <conal> oops.  i meant :(
11:14:53 * vincenz gets his 2 minutes of fame
11:15:11 <SamB> @google vincenz
11:15:13 <shapr> yay Christophe Poucet!
11:15:14 <lambdabot> http://www.vincenz.de/
11:15:14 <lambdabot> Title: vincenz.de - Startseite
11:15:20 <SamB> hmm.
11:15:23 <SamB> what's that about?
11:15:39 <MisterN> vincenz: you're a hospital
11:16:47 <vincenz> Maybe I should make my nick more obvious, but I've been known as vincenz in these circles for quite a while o.O
11:17:21 * shachaf likes using his first name as his nick.
11:17:33 <shachaf> It's hardly ever taken.
11:17:36 <MisterN> shachaf: oh this is not a random letter combination?
11:17:52 <shachaf> MisterN: No. :-)
11:17:56 <MisterN> sry :D
11:18:05 <ari> Mine is, but I somehow manage to get to use it in quite a few places anyway
11:18:35 <MisterN> ari: your first name is a prefix of my first name
11:19:01 <jacquesmerde> @src !!
11:19:01 <lambdabot> xs     !! n | n < 0 = undefined
11:19:01 <lambdabot> []     !! _         = undefined
11:19:01 <lambdabot> (x:_)  !! 0         = x
11:19:01 <lambdabot> (_:xs) !! n         = xs !! (n-1)
11:19:12 <jacquesmerde> @src (!!)
11:19:13 <lambdabot> xs     !! n | n < 0 = undefined
11:19:13 <lambdabot> []     !! _         = undefined
11:19:13 <lambdabot> (x:_)  !! 0         = x
11:19:13 <lambdabot> (_:xs) !! n         = xs !! (n-1)
11:19:23 <SamB> MisterN: your first name being "Unknown"?
11:19:28 <MisterN> jacquesmerde: you're repeating yourself
11:19:34 <MisterN> SamB: indeed :)
11:19:40 <jacquesmerde> MisterN: so it would seem!
11:19:46 <vincenz> jacquesmerde: you could use private messages with lambdabot  :)
11:20:26 <jacquesmerde> last time i was "private" with lambdadot i was taken advantage of
11:20:31 <Arnia> shapr: how is your category theory at the moment?
11:20:53 <SamB> jacquesmerde: you mean somebody pulled out the puppet mode?
11:21:10 <monochrom> @src !!!
11:21:10 <lambdabot> Source not found. Just what do you think you're doing Dave?
11:21:13 <monochrom> Like that?
11:22:10 <ari> @poll-show cheeky-off
11:22:10 <lambdabot> No such poll: "cheeky-off" Use @poll-list to see the available polls.
11:22:25 --- mode: ChanServ set +o cpoucet
11:22:28 --- mode: cpoucet set -o cpoucet
11:22:34 <shapr> Arnia: About as bad as ever :-)
11:22:39 <shapr> but adjunction doesn't seem so hard.
11:22:39 <MisterN> @poll-list
11:22:40 <lambdabot> []
11:22:59 <MisterN> cpoucet: why you keep doing that? :D
11:23:05 <Arnia> shapr: for some reason I have an incredible mental block on it :/
11:23:10 <cpoucet> MisterN: doing what?
11:23:18 <cpoucet> MisterN: I was checking my alias was still correct :)
11:23:23 <MisterN> cpoucet: take and remove op
11:23:29 <MisterN> you already did this before iirc
11:23:33 <cpoucet> not as cpoucet
11:24:35 <Arnia> shapr: As far as my intuition goes, an adjunction between two functors means that although the functors may not be inverse their exists a pair of natural transformations which make them inverses
11:25:38 <Arnia> shapr: but I can't seem to quite get comfortable with that idea. I think it is because I can't read composites of functors and natural transformations fluently yet :/
11:26:27 * monochrom throws some sugar commuting diagrams to the channel!
11:29:13 <shapr> Arnia: I just read http://en.wikipedia.org/wiki/Adjunction
11:29:15 <lambdabot> Title: Adjoint functors - Wikipedia, the free encyclopedia
11:30:15 <shapr> Arnia: I just asked some of the CT #haskell people when I got confused :-)
11:32:22 <SamB> monochrom: what does sugar commute to?
11:32:55 <monochrom> I mean commuting diagrams coated with sugar. Much like sugar lambdas.
11:33:06 <Cale> Arnia: Wouldn't that be more like an equivalence of categories?
11:33:21 <Cale> I suppose they're kind of similar concepts anyway
11:34:09 <Arnia> Cale: As I said, it is just my intuition. I'm still quite confused
11:34:10 <SamB> monochrom: sounds fragile
11:34:28 <doserj> functors are adjoint when their is a natural transformation from their composition to the identity functor
11:34:48 <doserj> but whether this is intuitive, is another question...
11:34:52 <Cale> Does that work as a definition?
11:35:24 <doserj> I think so
11:35:56 <Arnia> That is the formal definition... but I'm trying to get a connection between that and my intuition
11:36:19 <monochrom> there is a natural transformation from FG to I, and a natural transformation from I to GF.
11:36:58 <Cale> Certainly, when F and G are adjoint, you get a unit 1 -> GF and counit FG -> 1, but I'm not sure that alone actually implies that there's a natural transformation from Hom(F-,-) to Hom(-,G-)
11:37:53 <Arnia> Is Hom(F-,-) a bifunctor?
11:37:54 <monochrom> I knew lattice theory first. Then adjunction was a step up (though huge step).
11:37:57 <Cale> yes
11:38:28 <Arnia> monochrom: my brain rebels against orderings :)
11:38:29 <Cale> They're both bifunctors C^op x D -> Set
11:38:41 <monochrom> Fokkinga's calculational category theory primer has complete information.
11:42:00 <kpreid> monochrom: re sugar, http://www.candyfab.org/
11:42:03 <lambdabot> Title: The CandyFab Project - Making Rapid Prototyping a Little Sweeter
11:43:10 <SamB> kpreid: I don't think it's got enough resolution for sugar commutative diagrams just yet
11:44:06 <monochrom> Wouldn't it be nice if software rapid prototyping were as easy as that! :)
11:44:29 <monochrom> "just keep adding sugar, err I mean code"
11:45:01 * monochrom parodes more
11:47:30 <monochrom> "One of the hallmarks of rapid prototyping of software is that it is an additive process, where more and more features are incrementally added to a project. This makes it practical to make complex bugs that cannot be efficiently synthesized by traditional stepwise refinement processes."
11:48:40 * Arnia sighs and tries reading from the top
11:48:43 <Arnia> I hate mental blocks
11:49:14 <Arnia> shapr: fancy helping me give a paper a sanity check?
11:49:44 <cpoucet> Arnia: what are you working on?
11:50:03 <monochrom> would be nice if I replaced "additive" with "addictive" :)
11:50:11 <Arnia> cpoucet: treating RDF as a category
11:50:33 <Arnia> cpoucet: ultimate aim, generalise entirely away from model-theoretic semantics
11:50:48 <cpoucet> Arnia: Hmm, I fear I have no knowledge of RDF -.-
11:51:05 <cpoucet> Arnia: this at all related to 'semantic web'?
11:51:25 <Arnia> cpoucet: indeed
11:51:49 <dinoMI> I have a situation where I need a Data.Map but I need to instance it into a type class.
11:51:50 <cpoucet> Arnia: perhaps talk to 'zeeeee' (he's in #oasis).  I think he works on such topics as well.
11:52:32 <dinoMI> I can thinly wrap it in a newtype, but then I have to write individual functions like lookup to reach into that type. Is that the way this is done?
11:52:40 <Arnia> cpoucet: I'm looking to provide a semantics for RDF capable of expressing computations, fuzziness, etc as well as being able to be the semantics of other semweb languages
11:52:49 <Arnia> cpoucet: thanks for the tip
11:53:28 <cpoucet> Arnia: I fear that explaining it to me, unless you give me a LOT of context will just result in a whoosh effect
11:53:40 <Arnia> hehe
11:53:54 <Arnia> Actually, I think that might be of use
11:53:55 <xerox> dinoMI: which typeclass you want to instantiate Data.Map.Map into?
11:54:08 <Arnia> I want my paper to be readable both ways: by categorists and semwebbers
11:54:15 <Cale> dinoMI: You could also just write an instance if there isn't already a conflicting one.
11:54:31 <dinoMI> A couple, Serialize and FromReqURI from HAppS.
11:54:33 <cpoucet> Arnia: Honestly, I still don't know what "semantic web" means. It's an area I've never looked into :|
11:54:56 <dinoMI> Cale: I can instance Foo Map.Map where ... ?
11:54:59 <dinoMI> And it won't bitch? hm
11:55:17 <Cale> dinoMI: Sure
11:55:22 <sjanssen> dinoMI: yes, you can do that as long as there isn't already an instance of that class for Map
11:55:32 <dinoMI> For some crazy reason I thought this was not allowed. I don't know why.
11:57:10 <dinoMI> Ok. Silly, I should have just tried it. Thanks for your help.
11:57:23 <ddarius> Category theory?
11:57:55 <dmhouse> cpoucet: you need to be careful. The semantic web and the Semantic Web are quite different things.
11:58:50 <cpoucet> dmhouse: subtle humour?
11:58:55 <dmhouse> The former is using tags in places appropriate to their meanings ("semantics"), i.e. using <strong> when you really want to indicate strong emphasis and not just when you want bold text (which would be presentational).
11:59:15 * cpoucet nods
11:59:32 <dmhouse> The latter is a vision of the W3C's, that the entire web should be described through XML technologies like RDF.
12:00:05 <Saizan> every time i approach CT on wikipedia i get flooded with lots of notation/terminology that i have heard before but never got to learn, where do you start? is there a "Prelude"?
12:00:09 <cpoucet> Where do computations enter the picture?
12:00:15 <dmhouse> Saizan: tried the wikibook?
12:00:32 <dmhouse> Saizan: http://en.wikibooks.org/wiki/Haskell/Category_theory
12:00:34 <lambdabot> Title: Haskell/Category theory - Wikibooks, collection of open-content textbooks
12:00:34 <ddarius> Saizan: For example?
12:00:53 <Saizan> ddarius: Hom(-,A)
12:01:11 <ddarius> Saizan: That's something you should be learning as you are learning category theory.
12:01:33 <ddarius> I.e. it's not "background" knowledge you need to bring in.
12:01:36 <Saizan> Hom(A,B) denotes all the arrows from A to B iirc
12:01:37 <dmhouse> Saizan: Hom(A,B) are the morphisms from A to B.
12:01:59 <Saizan> and -? a wildcard?
12:02:01 <Arnia> dmhouse: I resent RDF being called an XML technology :)
12:02:05 <Cale> Saizan: Hom(-,A) sends an object X to Hom(X,A) (which is an object of Set)
12:02:18 <dmhouse> Saizan: basically, yeah. Hom(-,A) is a functor.
12:02:20 <cpoucet> Saizan: Hom(-,B) = arrows from X to the arrows it has :)
12:02:22 <Cale> http://en.wikipedia.org/wiki/Hom_functor
12:02:23 <Arnia> dmhouse: RDF has an XML serialisation, but that is hardly the same thing ;)
12:02:25 <ddarius> Saizan: Yes.  But that's just a (sometimes confusing) informality.
12:02:41 <cpoucet> Arnia: come to #oasis and explain the gist of the idea?
12:03:18 <Arnia> cpoucet: done
12:03:26 <Saizan> ah, so Hom(-,A) and Hom(B,A) are in different categories?
12:03:39 <doserj> they are different things
12:03:40 <Cale> and it sends a morphism f:X -> Y to the (set-)function Hom(f,A): Hom(X,A) -> Hom(Y,A) given by sending g to g . f
12:03:41 <ddarius> Saizan: Yes.  C^op -> Set and Set
12:03:48 <dmhouse> Saizan: they're completely different things. The former is a functor. The latter is just a set.
12:04:00 <dmhouse> (So yes, they're in different categories.)
12:04:08 <Cale> Hom(-,A) sends B to Hom(B,A)
12:04:59 <Cale> oops
12:05:02 <ddarius> Here is what Mac Lane says, "Thus we have gor each object a \in C a covariant hom-functor C(a,-) = hom(a,-) : C -> Set its object function sends each b to the set hom(a,b)"
12:05:06 <Saizan> Cale: g being?
12:05:07 <Cale> It sends a morphism f:X -> Y to the (set-)function Hom(f,A): Hom(Y,A) -> Hom(X,A) given by sending g to g . f
12:05:21 <Cale> g being an element of Hom(Y,A)
12:06:00 <Cale> and g . f then being an element of Hom(X,A)
12:06:13 <xerox> Cale, that's the transpose, isn't it?
12:06:23 <Saizan> right, contravariance?
12:06:37 <Cale> Hom(-,A) is a contravariant functor
12:06:47 <dmhouse> Hence the domain being C^op? Or is that for a different reason?
12:06:58 <ddarius> My point is simply that this stuff should be covered as part of any introduction to CT.
12:07:14 <doserj> ddarius: it is not?
12:07:17 <ddarius> dmhouse: A contravariant functor on C is a covariant functor on C^op.
12:07:51 <dmhouse> ddarius: right. So you gave the domain as C^op because A -> B means a covariant functor between A and B?
12:07:55 <Cale> Some people like to just work with covariant functors and change the category that they're working in.
12:08:03 <Saizan> ddarius: it probably is, but when i start reading a proper text on CT i get a bit smashed from all the abstract algebra i don't know ^^'
12:08:29 <ddarius> Saizan: There are other approaches, but actually many require very little.
12:08:44 <dmhouse> Saizan: if you want a basic introduction, try the wikibook link: http://en.wikibooks.org/wiki/Haskell/Category_theory
12:08:45 <lambdabot> Title: Haskell/Category theory - Wikibooks, collection of open-content textbooks
12:08:46 <ddarius> I highly recommend Barr and Wells' ELLSSI lecture notes.
12:08:53 <dmhouse> Saizan: it doesn't go as far as things like Hom-functors, though.
12:08:55 <Cale> Saizan: It certainly helps to have some background in groups, rings, a little topology...
12:08:57 <doserj> Saizan: then think about all the concrete examples of categories and functors between them
12:09:13 <swiert> Saizan: I quite like Steve Awodey's "Category Theory" book.
12:09:13 <ddarius> It does talk about monoids (but it defines them to), but a lot of the examples are things you should know or CSy.
12:09:16 <doserj> Saizan: with time, it becomes natural
12:09:34 <swiert> It requires a bit of "mathematical maturity" - but all the examples are very basic.
12:10:38 <Saizan> heh
12:10:39 <ddarius> Saizan: Many introductions actually require only very basic things in other branches of mathematics, it just seems like it's out there because of unfamiliarity.
12:12:10 <Cale> There's a bit of a problem right now, because up until it ended up being used to describe the semantics of programs, it was considered one of the most uselessly abstract branches of mathematics. Most mathematics majors pick up a bunch of CT on their way through, but whole courses on it are fairly rare at the undergrad level.
12:13:29 <Cale> Hence, all the classic texts on it assume that you already have a lot of examples under your belt :)
12:13:47 <doserj> I don't think Eilenberg, Grothendieck, etc would consider CT to be useless :)
12:14:11 <Saizan> yeah, it feels like you are just missing the "language"
12:14:12 <DRMacIver> But Grothendieck is hiding somewhere in france making cheese. ;)
12:14:15 <ddarius> Actually, once you realize it, the tools of category theory are very easy to use.  It's not for no reason that some complain about CT reducing mathematics to "calculation".
12:14:22 <dmhouse> doserj: who are they?
12:14:26 <Cale> http://en.wikipedia.org/wiki/Abstract_nonsense
12:14:44 <ddarius> dmhouse: Eilenberg is one of the founders of CT with Mac Lane.
12:15:09 <olsner> "This term is used by practitioners as an indication of mathematical sophistication or coolness rather than as a derogatory designation."
12:15:09 <Cale> Steenrod apparently invented the term "abstract nonsense" :)
12:15:10 <dmhouse> ddarius: and Grothendieck is a French cheese maker?
12:15:17 <ddarius> Grothendieck is often associated as one of the big players in attempting to build a categorical foundation of mathematics.
12:15:38 <Cale> Just because it's useless doesn't mean it's not worth studying :)
12:16:12 <ddarius> olsner: There are some general results that prove many many things immediately it's almost magical.
12:16:29 <doserj> ok, it is as useless as homological algebra, algebraic geometry etc.
12:16:43 <ddarius> doserj: It includes those things, but no.
12:16:51 <ddarius> doserj: Do you consider domain theory useless?
12:17:07 <doserj> no :)
12:17:49 <Cale> Well, then you have the problem that it doesn't really look like CT has been doing much in and of itself lately.
12:18:20 <sieni> ddarius: well, at least he is famous for building categorical foundation for homological algebra
12:18:25 <Cale> The trouble with overly abstract things is that there's not as much to prove about them.
12:18:50 <hpaste>  laz0r pasted "question" at http://hpaste.org/1997
12:18:56 <laz0r> hi #haskell
12:19:05 <doserj> same problem with ZFC
12:19:19 <laz0r> just pasted something, hope anyone could explain
12:19:21 <Codex_> CT is all about pretty diagrams.
12:19:28 <Cale> laz0r: (\x -> Right x 'c') ?
12:19:41 <laz0r> i tried with :t (Right . 'c')
12:19:42 <Cale> or (flip Right 'c')
12:20:02 <laz0r> ah, ok thanks... did i misunderstodd what the (.) does?
12:20:08 <ddarius> Codex_: I actually don't really care for the diagrams.  I prefer using representability; easier to calculate with.
12:20:20 <Cale> laz0r: Yes. 'c' isn't a function
12:20:29 <ddarius> laz0r: (.) isn't a place holder.
12:20:34 <Cale> laz0r: (.) takes two functions and gives their composite.
12:20:34 <laz0r> i thought it could serve as a kind of 'placeholder'
12:20:42 <ddarius> @src (.)
12:20:43 <lambdabot> (.) f g x = f (g x)
12:20:45 <ddarius> It's just a function.
12:20:50 <Cale> (f . g) x = f (g x)
12:20:52 <laz0r> so, (.) is like $?
12:20:53 <sieni> of course the problem with categorical foundations is that they don't fit that well together with the set theoretical foundations
12:20:56 <Cale> laz0r: no
12:21:03 <Cale> laz0r: ($) is function application
12:21:14 <dmhouse> laz0r: they're similar, but they are importantly different.
12:21:14 <Cale> It takes a function and a value, and applies the function to that value
12:21:19 <Cale> f $ x = f x
12:21:20 <shachaf> > ((+1) . (*2)) 5 -- (5 * 2) + 1
12:21:22 <ddarius> sieni: No, the problem is that "categorical foundations" approaches just rebuild set theory and have not much to offer.
12:21:22 <lambdabot>  11
12:21:34 <dmhouse> laz0r: (.) takes two functions and joins them together. ($) takes a function and a value and applies one to another.
12:21:52 <laz0r> ah, ok, ill keep that in mind
12:21:54 <shachaf> > ((+1) $ (*2)) 5 -- Applies (+1) to (*2); doesn't work.
12:21:55 <lambdabot>   add an instance declaration for (Num (a -> a))
12:22:01 <johnynek> I have a numerical calculation that does a large (finite) search and produces a relatively short list of valid results.
12:22:06 <msouth> if I have, e.g., a string containing "[1,2,3]", is there something I can call that will make that into an actual list?
12:22:09 <Cale> They can be used together - (.) to build up a chain of functions, and then ($) to apply it
12:22:14 <johnynek> I think due to lazy evaluation, everytime I use this list it is being recomputed.
12:22:15 <dmhouse> laz0r: you can get them confused because both f . g . h . i . j $ x and f $ g $ h $ i $ j $ x will work, but remember that difference.
12:22:19 <shachaf> > read "[1,2,3]" :: [Int]
12:22:21 <lambdabot>  [1,2,3]
12:22:22 <Codex_> ddarius: How is things like finite limits present in set theory?
12:22:24 <johnynek> Which takes forever.  How can get a list to be evaluated once?
12:22:36 <msouth> thanks shachaf
12:22:36 <Cale> I recommend never writing f $ g $ h $ x
12:22:49 <ddarius> Codex_: What are you talking about?
12:22:50 <Cale> because this just abuses a mistake in the standard
12:23:09 <Codex_> ddarius: that one thing CT has to offer.
12:23:13 <Cale> and you can write it as  f . g . h $ x  instead
12:23:14 <shachaf> Cale: You want $ to be infixl?
12:23:18 <Cale> shachaf: yep
12:23:19 <Botje> johnynek: that's the opposite of lazy computation. are you sure it's being recalculated?
12:23:34 <shachaf> Cale: Why?
12:23:39 <ddarius> Codex_: ? I'm talking about foundations.  CT certainly has something to offer, but not as a foundation.
12:23:47 <johnynek> Botje, I'm not sure, but I'm starting to wonder.
12:23:48 <sieni> ddarius: well, what about functors? functors are morphisms in the category of small categories, but what about categories that are not small?
12:23:58 <Cale> shachaf: A number of reasons. The most practical one is that it would allow us to remove more parens from expressions.
12:24:13 <shachaf> Cale: I like to think, when I use $, that now whatever's on the left will be applied to whatever I type on the right.
12:24:15 <johnynek> I mean: supposed I define some list, and then use it several times.
12:24:17 <ddarius> sieni: You use bigger sets.
12:24:20 <Cale> Another is that function application is left associative, and so should its representative be.
12:24:23 <johnynek> is it really only computed once?
12:24:26 <Botje> johnynek: yes.
12:24:28 <shachaf> Cale: You mean "f . g $ x y"?
12:24:30 <Cale> shachaf: right, and you still would
12:24:48 <Cale> f . g $ x y would still mean (f . g) (x y)
12:24:53 <johnynek> or, is do { print expensive_list; print $ head expensive_list }
12:25:07 <johnynek> or, rather...
12:25:09 <shachaf> Cale: Hmm, never mind, sorry.
12:25:13 <Botje> johnynek: by printing it, you effectively "force" the whole list to be evaluated.
12:25:21 <Cale> But you could write  f . g $ x $ y  to mean ((f . g) x) y
12:25:31 <johnynek> Botje, and then it is kept in memory until there are no more references?
12:25:36 <Botje> yes
12:25:54 <chris2> how can i use hopengl interactively?
12:26:07 <ddarius> chris2: I would think so.
12:26:16 <ddarius> Oh, I missed the how.
12:26:19 <chris2> but i need to start the mainloop :)
12:26:26 <shachaf> Cale: At the moment, I type, say, "print $ {- now whatever I type here is independent of the print $ -} length $ {- ... -}".
12:26:39 <ddarius> chris2: Start it in a different thread?
12:26:41 <Saizan> johnynek: only if you give it a name, though, print (calc_exp_list a); print (calc_exp_list a) will compute the list twice
12:26:52 <shachaf> Cale: I build up expressions by making one $ and adding them on the left. It somehow feels easier than (.).
12:27:07 <Cale> johnynek: if it's bound to a monomorphically typed variable, it will only be computed once, so long as that variable remains in scope
12:27:11 <chris2> ddarius: i'm pretty new to real-world haskell... how would i do that?
12:27:29 <Cale> shachaf: All you have to do is remember to use (.) instead :)
12:27:30 <ddarius> I think with OpenGL you would need to use the forkOS command.
12:27:47 <Botje> johnynek: perhaps you are generating new lists everytime without knowing. Have you run your application with profiling turned on?
12:28:18 <Cale> f . g . h $ x instead of f $ g $ h $ x. One rather nice thing about this is that the first form is easier to refactor.
12:28:23 <johnynek> Botje, I have not turned profiling on.
12:28:24 <ddarius> That would beat all if this was a case that the monomorphism restriction was supposed to deal with.
12:28:30 <sfultong> > liftM2 (,) (+1) (-1) (0,1)
12:28:31 <lambdabot>   add an instance declaration for (Num ((t, t1) -> a2))
12:28:40 <shachaf> Cale: I sometimes use, e.g., "putStrLn $ f . g $ x", because it feels like the putStrLn is on a different level.
12:28:40 <Cale> g . h is going to be meaningful, whereas g $ h isn't.
12:28:41 <sfultong> > liftM2 (,) (+1) (-1) $ (0,1)
12:28:42 <lambdabot>   add an instance declaration for (Num ((t, t1) -> a2))
12:29:03 <shachaf> > liftM2 (,) (+1) (-1) 0 -- This?
12:29:03 <lambdabot>   add an instance declaration for (Num (a -> a2))
12:29:06 <Botje> johnynek: well, you should try it to see where your app is spending its time
12:29:16 <shachaf> Never mind, I didn't mean that.
12:29:25 <shachaf> > (+1) *** (-1) (0,1)
12:29:26 <lambdabot>        add an instance declaration for (Num ((t, t1) -> b' -> c'))
12:29:27 <sieni> ddarius: well typically categories are not even sets, so all functors are not even a proper class
12:29:30 <shachaf> > (+1) *** (-1) $ (0,1)
12:29:30 <lambdabot>   add an instance declaration for (Num (b' -> c'))
12:29:39 <johnynek> Saizan: (and Cale) thanks.
12:29:40 <ddarius> The Netherland Lottery!  I'm a nominated winner!
12:29:52 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/1998
12:30:19 <jsnx> ghc has a weird mix of GNU style and X11 style long options
12:30:25 <johnynek> Saizan: so, just to be clear. if you did a fibinocci list, and then accessed the billionth element, all billion would stay in scope?
12:30:28 <sfultong> do we ever get spam on hpaste?
12:30:35 <ddarius> sfultong: Yes.
12:31:05 <ddarius> sieni: You make small categories that are sets smaller than some big set and so on.  You only need about two or three levels of this to get most practical (1-)category theory.
12:31:57 <shachaf> > ((+1) *** (subtract 1)) (0,1) -- Oh.
12:31:58 <lambdabot>  (1,0)
12:32:27 <sieni> ddarius: but this breaks the elegance of the category-theoretic constructs
12:32:37 <sfultong> :t (***)
12:32:38 <Cale> johnynek: If you put something like fibs :: [Integer]; fibs = 0 : 1 : zipWith (+) fibs (tail fibs)  at the top level, then it will always be in scope, and so long as you might ever need to access fibs from the rest of your program, it won't be GC'd.
12:32:39 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
12:33:04 <sfultong> wait, lambdabot supports ghci syntax?
12:33:04 <sieni> ddarius: I'm not saying they are wrong, but patching some things to work with zfc makes things ugly
12:33:07 <shachaf> sfultong: This is the (->) arrow, so :: (b -> c) -> (b' -> c') -> ((b,b') -> (c,c'))
12:33:17 <Cale> sfultong: just :t
12:33:23 <ddarius> sieni: Why?  It doesn't change anything at all for 1-category and anyways I think most practitioners just ignore the issue because it doesn't really come up in a bad way.
12:33:27 <shachaf> :type 5
12:33:35 <shachaf> Just :t, indeed. :-)
12:33:43 <ddarius> :k JUst
12:33:45 <lambdabot> Not in scope: type constructor or class `JUst'
12:33:46 <ddarius> :k Just
12:33:48 <lambdabot> Not in scope: type constructor or class `Just'
12:33:51 <shachaf> :k Maybe
12:33:53 <lambdabot> * -> *
12:33:57 <ddarius> That's what I meant.
12:33:59 <Olathe> :k thx
12:34:00 <shachaf> I guess not.
12:34:01 <lambdabot> Not in scope: type variable `thx'
12:34:07 <chris2> ghc-6.4.1: --interactive can't be used with -prof, -ticky, -unreg or -smp.   -- did that change in more recent versions?
12:34:13 <ddarius> I think it's just :t and :k.
12:34:35 <shachaf> chris2: 6.6 still says that.
12:34:43 <chris2> damnit
12:34:43 <ddarius> It would be kind of pointless for -prof.  Unreg also makes sense.
12:34:46 <shachaf> chris2: But you should upgrade anyway. :-)
12:34:49 <chris2> but not smp
12:34:58 <chris2> shachaf: it takes a weekend on this poor ibook
12:35:12 <shachaf> chris2: You could use a binary.
12:35:28 <chris2> yeah
12:35:39 <Cale> sieni/ddarius: It is worth worrying about the set theoretical formalisation of CT, though not enough category theorists do it. There are a lot of very strange things which can happen with proper classes or even just sufficiently large sets.
12:35:39 <ddarius> It's not all that unreasonable for -smp to not be available.
12:36:13 <ddarius> Cale: It is, but not for most.  I already described approaches to dealing with it in CT.
12:36:34 <ddarius> Even most non-categorists don't think about Set theory.
12:36:46 <Cale> At their own peril! :)
12:37:51 <ddarius> Most results that aren't strictly true seem to be recoverable with not very chafing restrictions on "size".
12:38:48 * ddarius likes using a "representability" based definition of Kan extensions even though the hom-"sets" don't actually exist.
12:38:52 <sieni> I'm not claiming that category theory or set theory are wrong. Rather that trying to fit both approaches to foundations of mathematics nicely together does not appear to be too easy
12:39:18 <Saizan> if i have the morphisms f :: A -> B, g :: B -> A, can i say that f . g = id_b?
12:39:19 <Cale> I'm happy with the status quo as far as foundations goes.
12:39:20 <ddarius> sieni: Why would you want both together?  That would kinda defeat the exercise.
12:39:27 * ddarius is too.
12:39:30 <Cale> (That is, keep using ZFC)
12:39:56 <ddarius> Saizan: You can assert it.
12:39:57 <DRMacIver> But there are all sorts of fun extensions and alternatives to ZFC. ;)
12:40:00 <Cale> It seems perfectly okay to me to build category theory on top of that.
12:40:15 <Cale> DRMacIver: Sure, but those are for logicians :)
12:40:19 <shachaf> :i Maybe
12:40:21 <Cale> hehehe
12:40:25 <shachaf> @info Maybe
12:40:25 <lambdabot> Maybe
12:40:28 <shachaf> @help info
12:40:28 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:40:42 <ddarius> The foundational approaches by categorists are not very compelling and not particularly important, so I'm happy.
12:40:42 <DRMacIver> Cale: Set theory shouldn't be considered a branch of logic. :)
12:40:43 <shachaf> @info -> @id, maybe?
12:40:43 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 1}) "Parse error"
12:40:52 <Saizan> ddarius: i mean, is it true for every such f,g?
12:40:52 <doserj> ZFC is a nice modelling language, but is is not the only truth
12:41:01 <ddarius> Saizan: Of course not.
12:41:16 <ddarius> Saizan: E.g. f and g can be normal functions.
12:41:18 <Cale> doserj: of course. It's just the agreed-upon language.
12:41:32 <sieni> ddarius: well, as a mathematical analyst, I'd like to dump category theory altogether, but since it obviously has some good applications to homological algebra, it would be nice to be able to work with it cleanly
12:42:06 <Cale> doserj: If you want to speak your own language, you can do so, but should expect an uphill battle finding people to talk to :)
12:42:12 <sieni> but anyway that book probably has quite a bit of discussion on the subject: http://astore.amazon.com/science-books-20/detail/0387977104
12:42:14 <lambdabot> Title: Science Books - Sheaves in Geometry and Logic: A First Introduction to Topos The ...
12:42:23 <sieni> it's been a while since I opened it, though
12:42:27 <doserj> :)
12:42:38 <ddarius> sieni: Category theory is like the emacs of mathematics, you may base it on set theory, but it is an environment unto itself.
12:43:31 <sieni> ddarius: yeah, comparing category to emacs is like umm... going to win it a lot of supporters ;-
12:43:35 <sieni> ;-)
12:43:41 <ddarius> sieni: I'm a vimmer.
12:45:02 <Cale> I find the CT formalisations of many mathematical objects to be fairly unintuitive relative to the set-theoretic approaches, which makes it look sort of awkward as a foundation. Then again, it might just be that there are a completely different collection of mathematical objects yet to be discovered which category theory more naturally formalises.
12:45:50 <Cale> If you're talking about homological algebra, you want category theory to be around. :)
12:46:11 <ddarius> Cale: I sometimes do and sometimes don't.  I highly appreciate the general results, like (co)continuity of adjoints, that make things sail through.
12:47:36 <doserj> Cale: do you find it intuitive that "2 \in (0,1)" is true?
12:47:49 <ddarius> Working with category theory feels like working at a higher level of abstraction; things are less visceral but it's much more easy to generalize the results.
12:47:55 <julian_> @pl foldr (.) id (take n (repeat (>>= p)))
12:47:56 <lambdabot> foldr (.) id (take n (repeat (p =<<)))
12:48:06 <ddarius> touche @pl
12:48:10 <Cale> doserj: In exactly which sense is that true?
12:48:19 <julian_> @pl term n p  = foldr (.) id (take n (repeat (>>= p)))
12:48:19 <lambdabot> term = (foldr (.) id .) . (. (repeat . (=<<))) . take
12:48:22 <DRMacIver> ddarius: It's less intuitive than 2 = {0, 1}. :)
12:48:29 <doserj> in ZFC with von-Neumann natural number and kuratowski ordered pairs
12:48:35 <sieni> Cale: well, yes, derived categories are nice from category-theoretic point of view, but not that nice from set theoretic point of view
12:48:45 <Cale> doserj: (0,1) is the open interval?
12:48:50 <Cale> oh
12:49:06 <Cale> (0,1) = {{0},{0,1}} ?
12:49:06 <doserj> (0,1) = {1,2} :)
12:49:14 <doserj> yes
12:49:15 <Cale> yes, that's fine.
12:49:28 <Cale> You'd never ask about an element of an ordered pair anyway.
12:49:36 <ddarius> DRMacIver: The set theory definition of naturals, the actual formal one, is arguably more obtuse then the more general construction of a natural number object.
12:49:56 <Cale> Unless you were doing something like formalising operations on ordered pairs :)
12:50:09 <doserj> untyped languages are evil :)
12:50:10 <Cale> Here's an example: What is a Field, without referring to a set?
12:50:28 <Cale> Give a completely category-theoretic formalisation :)
12:50:29 <DRMacIver> I'm not sure which one you're referring to as the general construction and which as the formal one, but I found neither very obtuse. :)
12:50:35 <ddarius> Cale: What can we refer to?
12:50:49 <ddarius> DRMacIver: Neither is very obtuse.
12:51:02 <gkr> Where is Monoid stuff?
12:51:06 <glguy> Data.Monoid
12:51:09 <ddarius> @index Monoid
12:51:09 <lambdabot> Data.Monoid, Control.Monad.Writer, Control.Monad.RWS
12:51:11 <gkr> Thanks.
12:51:43 <doserj> Cale: just take the FOL-Field axioms. No sets needed for that
12:52:54 <monochrom> You don't need set theory. You just need a type system. Mathematicians use ZF as a type system most of the time.
12:53:06 <Cale> The axioms aren't a field themselves.
12:53:38 <monochrom> Then what does your "what is a field" mean?
12:53:43 <augustss> now you're getting philosophical
12:53:53 <augustss> my comment was for Cale
12:53:56 <ddarius> A field can be described by a finite sum theory.
12:55:01 <araujo> anybody knows what is the site of the Haskell Practical Programmer book that is being written?
12:55:18 <Cale> ddarius: that might be more acceptable
12:55:19 <augustss> Cale, I thought you were a formalist.  You should be happy with a bunch of axioms. :)
12:55:29 <ddarius> @google "Eric Kidd"
12:55:31 <lambdabot> http://www.randomhacks.net/
12:55:31 <lambdabot> Title: Random Hacks
12:55:51 <araujo> thanks ddarius
12:56:43 <mrd> ddarius: have you put your presentation stuff anywhere btw
12:56:46 <Cale> augustss: Sure, but there's a problem with answering "what is a field" with a collection of universally applied axioms and function symbols, unless you have some way to define an interpretation of those axioms without referring to a set.
12:57:02 <ddarius> mrd: I haven't actually done... well pretty much anything at all on that.
12:58:10 <augustss> Cale: And how do you explain what a set is?
12:58:12 <monochrom> You could use a type class for field axioms and operations... an instance is an interpretation, a model.
12:58:58 <Cale> augustss: It's not that this is an unfair thing to do in general.
13:00:03 <roconnor> oh I know what a field is: http://c-corn.cs.ru.nl/documentation/CoRN.algebra.CFields.html#CField
13:00:06 <lambdabot> Title: CoRN.algebra.CFields, http://tinyurl.com/2ayvdd
13:00:14 <roconnor> :)
13:01:35 <monochrom> As usual, you just need a type system.
13:02:14 <roconnor> monochrom: It is based on setoids, which is based on type theory.
13:02:22 <Cale> FOL+ZFC is a fine type system :)
13:02:56 <doserj> a unityped type system :)
13:03:03 <Cale> It's not unityped at all.
13:03:15 <Cale> It has countably many types.
13:03:49 <roconnor> ZFC is a terrible programming language :)
13:03:59 <Saizan> another random question: how is equality on morphisms defined?
13:04:18 <ddarius> Saizan: As part of the data of a category essentially.
13:04:29 <Cale> Every predicate is a type.
13:04:50 <DRMacIver> roconnor: It does have certain advantages over classic programming languages though. It's rather severely more powerful than a turing machine for example. ;)
13:05:02 <doserj> Cale: you mean the model theory of FOL in ZFC
13:05:05 <DRMacIver> Although, one must admit, there are minor implementation details.
13:05:11 <Cale> doserj: after all, I can say, "Let F be a field."
13:05:13 <monochrom> I think FOL+ZFC is a type system with too much baggage. First it was intended to be a type system (without people knowing that word), then more features were added to do things beyond. Like Windows, started out as a small OS, then they kept added and added features until it become problematic.
13:05:14 <DRMacIver> s/details/difficulties/
13:05:18 <doserj> ZFC only has one predicate
13:05:40 <Cale> doserj: Okay, every formula with a single free variable :)
13:06:29 <Cale> and even that predicate -- element-of, is fairly generic
13:06:48 <ddarius> Polytypic predicates!
13:06:49 <Cale> Since it effectively turns every set into a type.
13:07:21 <Cale> Let x be a real number.
13:07:46 <Cale> What that really means is that x is an element of the set of real numbers.
13:07:52 <roconnor> bah ZFC isn't a type system.  Objects are supposed to have unique times.
13:07:57 <roconnor> s/times/types
13:08:03 <Saizan> ddarius: ok, so objects are however set-like things? because you can have f,g :: A -> B and f /= g so you must have more than one "instance" of A and B
13:08:03 <Cale> roconnor: They don't in Haskell.
13:08:19 <DRMacIver> roconnor: It's a type system with subtyping and multiple inheritance. ;)
13:08:25 <monochrom> Yeah!
13:08:28 <roconnor> don't get me started on subtyping.
13:08:33 <monochrom> Hahaha
13:08:34 <roconnor> ;)
13:08:42 <DRMacIver> roconnor: Not a fan of dependent typing? :)
13:08:43 <Cale> What's the type of 5?
13:08:54 <roconnor> DRMacIver: I'm a huge fan of dependent types.
13:08:55 <monochrom> ZFC the ultimate OOP nightmare?
13:09:06 <Cale> (Num t) => t ?
13:09:11 <ddarius> Saizan: No.  The arrows can be different without having one or more "instances" of A and B.  A and B are opaque things.  The identity on arrows comes in the same way we can tell whether {a,b} is a singleton set or not.
13:09:11 <shafire> hi
13:09:14 <roconnor> Cale: I think of haskell as having implict type arguments rather than having multiple types.
13:09:24 <monochrom> 5 :: (PartialOrder t) => t
13:09:45 <doserj> Cale: the problem is that "x is a real number" does not prevent me from asking questions about x that do not make sense for real numbers
13:10:02 <Cale> doserj: Like what?
13:10:26 <DRMacIver> Of course, "Real Number" is a kind rather than a type in ZFC. :)
13:10:26 <doserj> like "x \in x"
13:10:56 <Cale> DRMacIver: I'm asserting that every set amounts to a type. :)
13:11:11 <DRMacIver> Cale: Sure. But there isn't a canonical set of real numbers. :)
13:11:15 <roconnor> doserj: What is far more scary is when people say that Z c= R.
13:11:23 <monochrom> ZFC is an FOSS OOP type system. You can hack its internals, not just use it.
13:11:27 <Cale> DRMacIver: Pick one :)
13:11:29 <Cale> hehe
13:11:29 <roconnor> mizar goes through a lot of trouble to make that true.
13:11:40 <Saizan> ddarius: by knowing if a = b?
13:12:00 <sorear> roconnor: what is c=?
13:12:03 <roconnor> subset
13:12:08 <monochrom> 
13:12:22 <monochrom> ASCII art FTW!
13:12:25 <roconnor> doserj: What is far more scary is when people say that Z  R.
13:12:27 <ddarius> Saizan: Yes.  As I said, you have to include the equality with your definition of a category.  This is almost always implicit.
13:12:34 <roconnor> mizar goes through a lot of trouble to make that true.
13:12:54 <ddarius> Saizan: There is nothing you can say about objects in category theory.  There are only arrows.
13:12:56 <doserj> roconnor: and the truth of it depends on the time in the course :)
13:12:57 <roconnor> monochrom: where's the double struck Z and R?
13:13:20 <monochrom> I don't know. Will take some time to find.
13:13:29 <sorear> I have a math book that takes "There exists a complete ordered field" as an axiom and defines the naturals in terms of it.
13:13:36 <Syzygy-> ddarius: There are things you can say about objects in category theory. They exist, for instance. (mostly)
13:13:39 <Cale> roconnor: When they do that, I usually take it to mean that they're referring to a retroactively constructed subset of the real numbers, not the originally constructed integers.
13:14:03 <ddarius> Syzygy-: They exist... except for when they don't.
13:14:03 <Saizan> ddarius: ok, but i don't see how equality on objects helps here, for example g :: A -> A could not be id_A, but A = A i presume
13:14:09 <Cale> Of course it's obvious what they mean.
13:14:16 <Syzygy-> However, Saizan: you can always (kinda) identify an object with its identity morphism, and this makes them slightly irrelevant.
13:14:18 <Cale> and there's an obvious formalisation of it :)
13:14:31 <sfultong> how come I see Maybe return types in many of the obsolete datatype functions, yet none in the newer datatype libraries?
13:14:31 <Syzygy-> ddarius: No. Objects in categories exist. Except for the empty category, and that's boring.
13:14:34 <ddarius> Saizan: A=A always.
13:14:39 <Cale> If it's hard to do in Mizar, then that's Mizar's fault :)
13:14:41 <ddarius> Syzygy-: No it isn't!
13:14:55 <sorear>   
13:15:05 <Syzygy-> ddarius: It's about as sane as the zero ring. Clearly boring.
13:15:05 * ddarius needs to leave now though.
13:15:20 <doserj> Cale, the problem is there are so many Z's...
13:15:20 <roconnor> Cale: Mizar, for instance, takes the rationals, cuts out the rational integers, and shoves in the intergers.
13:15:25 <ddarius> Syzygy-: Lim(0 -> C)!
13:15:37 <Syzygy-> ddarius: Huh?
13:15:37 <roconnor> I assume they went though that trouble for good reason.
13:15:47 <doserj> roconnor: and the same for complex numbers?
13:15:51 <monochrom> Oh haha. , =
13:15:56 <roconnor> doserj: all the way up as I understand.
13:15:57 <Cale> doserj: Just stick the appropriate isomorphisms in. There's only one up to ring isomorphism.
13:16:03 <SamB> Cale: I Thinght  was just a fancy way to write Z
13:16:12 <Cale> SamB: it is.
13:16:27 <doserj> Cale: and that is what category theory does
13:16:29 <Cale> SamB: But emphasizes the notion that you're talking about the integers.
13:16:35 <SamB> well, sure
13:16:36 <sorear> I think NP is an abuse there. :)
13:16:39 <Cale> doserj: Not just category theory.
13:16:45 <doserj> or type theory
13:16:48 <SamB> and I guess it lets you use Z for something else
13:16:50 <monochrom> Yeah sorear :)
13:16:53 <Cale> Type theory doesn't do it.
13:17:03 <Cale> Mathematicians do it :)
13:17:50 <doserj> well, category theory was invented by mathematicians for a reason :)
13:18:04 <SamB> so they could ridicule it later?
13:18:16 <DRMacIver> doserj: I've often suspected that it was mostly because they were bored. :)
13:18:20 <Cale> That reason was not to formalise the notion of two things being isomorphic.
13:18:48 <Cale> That already existed, and doesn't require any category theory at all.
13:18:52 <doserj> no, but "naturally isomorphic"
13:18:56 * roconnor rereads http://r6.ca/blog/20051210T202900Z.html
13:18:57 <lambdabot> Title: How Dedekind Screwed Up a Hundred Years of Mathematics
13:18:57 <Cale> (not type theory)
13:19:00 <Cale> nor*
13:19:21 <monochrom> roconnor: Post it to reddit! XD
13:19:46 * Cale likes Dedekind cuts.
13:19:54 <roconnor> monochrom: think I should?
13:20:02 <Cale> So much cleaner than Cauchy sequences :)
13:20:07 <monochrom> I'm just kidding :)
13:20:33 * Cale is pro (axiom of) choice.
13:20:34 <roconnor> ``Again Dedekinds theory works to eliminate the computational content of mathematics.
13:20:47 <Cale> Fine with me :)
13:20:55 <DRMacIver> Cale: Pure dedekind cuts are annoying to multiply. I prefer a hybrid approach. :)
13:21:11 <roconnor> bah, without computational content, mathematics is just philosophy.
13:21:41 <DRMacIver> You say that like it's a bad thing. :)
13:21:43 <Cale> DRMacIver: I'm talking about the modern reinterpretation of Dedekind cuts -- there's still a little work in defining multiplication, but it's not so bad.
13:21:45 <Syzygy-> roconnor: Well, yeah....
13:22:01 <DRMacIver> Cale: Remind me which one that is?
13:22:17 <Cale> DRMacIver: Basically, x is the set of rationals less than x :)
13:22:40 <DRMacIver> Cale: Ok, that's what I thought. I found it annoying to deal with multiplication in there. Too much case checking. :)
13:23:14 <DRMacIver> Cale: It works better if you define the positive reals first (with x > 0 as the set of all positive rationals < x) and then make the reals as a quotient of tuples of positive reals. :)
13:23:21 <DRMacIver> s/tuples/pairs/
13:23:31 <roconnor> Cale: the validity of the axiom of choice doesn't affect results in the arithemetic heirarchy, so even if it were true, it wouldn't matter.
13:23:31 <DRMacIver> (With (x, y) = x - y)
13:23:32 <Cale> yeah, I was just going to suggest that :)
13:23:42 <Cale> roconnor: I know that :)
13:23:57 <Cale> roconnor: I'm just reinforcing my anti-constructivist position :)
13:24:25 <roconnor> Actually, I've been keeping my eye out for an interpretation of the axiom of choice.  It seems likely possible.
13:24:25 <Cale> Sure, every vector space has a basis :)
13:25:21 <roconnor> Every time the axiom of choice is used to prove an arithmetic statement, it can be removed from the proof.
13:25:38 <roconnor> So it should be possible to add it in some manner safely.
13:26:59 <Cale> There exists a model of ZFC in which there is a function f from the real numbers to the real numbers such that f is not continuous at a, but for any sequence {x_n} converging to a, lim_n f(x_n)=f(a).
13:27:05 <augustss> roconnor: have you seen/heard Martin-Lf on the axiom of choice?
13:27:12 <roconnor> Once that is done it will be pretty clear that classical mathematics is just a subset of constructive mathematics.
13:27:27 <roconnor> augustss: In January I did.  I have a photo. :)
13:28:52 <augustss> do you know if it's written down somewhere?  i need to refresh my memory
13:29:31 <roconnor> augustss: he was talking about ``Topos Theory and Type Theory''
13:29:44 * Syzygy- used to run into Per Martin-Lf in the hallways. And Anders occassionaly.
13:29:44 <roconnor> augustss: as I recall it was a bit over my head.
13:29:53 <augustss> Oh, but he has a great talk on the axiom of choice
13:30:03 <roconnor> but he had some nice ranking of different versions of the axiom of choice.
13:30:07 <Syzygy-> I was blissfully ignorant about the things that now lead me to be interested though.
13:30:18 <augustss> where he takes it apart and finds the bad spot
13:30:36 <roconnor> augustss: that I haven't seen.
13:30:53 <Cale> Bad spot?
13:30:55 <roconnor> augustss: I have a post about where I think the problem with the axiom of choice lies.
13:31:12 <Cale> What bad spot? :)
13:31:19 <roconnor> http://r6.ca/blog/20050604T143800Z.html
13:31:20 <lambdabot> Title: Intensional vs Extensional Choice
13:31:25 <augustss> Cale: bad for a constructivist
13:31:28 <doserj> augustss: http://comjnl.oxfordjournals.org/cgi/content/citation/49/3/345 ?
13:31:30 <lambdabot> Title: 100 years of Zermelo's axiom of choice: what was the problem with it? -- Martin- ...
13:31:41 <roconnor> ``The extensional axiom of choice is equivalent to saying that for every surjective extensional function there exists a right inverse that is also extensional.
13:31:57 <roconnor> the ``is also extensional'' bit is a bit of a problem.
13:32:04 <DRMacIver> Dependent choice seems to be the cutoff point past which counterintuitive things happen. Even that isn't quite constructive though (at least I think not).
13:32:28 <roconnor> I wonder if it is the same problem per Martin-Lof has.
13:32:32 <Cale> I don't really understand what's so bad about being able to well-order the real numbers.
13:32:39 <Cale> Seems like a good thing to me.
13:32:51 <doserj> Cale: but you are not :)
13:32:54 <EvilTerran> ...
13:33:02 * EvilTerran deactivates his beep on "Martin"
13:33:12 * earthy grins
13:33:16 <MisterN> are you currently discussing about problems arising from doing proofs on undefinable sets?
13:33:46 <Cale> MisterN: Whether these sets are definable depends on your choice of axioms
13:34:00 <roconnor> Cale: it is hard to derive computational stuff from it.
13:34:07 <Cale> roconnor: so?
13:34:16 <Syzygy-> Ooooh. roconnor - you refer to Jesper Carlstrm!
13:34:22 <Syzygy-> Friend of mine. :)
13:34:34 <cpoucet> Syzygy-: stop name-dropping :P
13:34:46 <MisterN> Cale: hmm... at least sets that can't be somehow stored in a computer aren't terribly practical
13:34:53 <roconnor> Syzygy-: His thesis really clarified things for me.
13:34:56 <Syzygy-> cpoucet: They keep talking about the people at my old alma mater!
13:35:07 <Cale> Yeah, if you really want to be practical, be a finitist!
13:35:15 <Cale> Infinite sets don't exist!
13:35:25 <Syzygy-> roconnor: I'm -really- annoyed I only started with Haskell (and in the extension cool kinds of logic) once I had moved away from Stockholm.
13:35:27 <mrd> have you ever met one?
13:35:32 <augustss> Cale: it's very tempting to be one
13:35:35 <MisterN> well that'd be just like saying that infinite lists didn't exist
13:35:36 <Syzygy-> It would have been SO MUCH COOLER to be interested in those things while there.
13:35:47 <roconnor> Syzygy-: where are you now?
13:36:04 <Syzygy-> roconnor: Jena, Germany.
13:36:25 <Syzygy-> We had Frege, once upon a time....
13:36:49 <augustss> but he's not around now
13:37:41 <Syzygy-> augustss: Well .. he's dead.
13:37:52 <augustss> exactly
13:38:16 <cpoucet> How can he be dead if he is not any more?
13:38:44 <cpoucet> augustss: btw, I see you enjoying jousting with qwe1234 :)
13:38:52 <Syzygy-> cpoucet: Huh?
13:39:04 <cpoucet> Syzygy-: to be anything you have to be existing.
13:39:09 <monochrom> where?
13:39:20 <cpoucet> monochrom: reddit?
13:39:21 <augustss> qwe1234 is funny
13:39:24 <Syzygy-> cpoucet: I don't see how existence enters into the rest of our discussion.
13:39:27 <monochrom> oh!
13:39:33 <Syzygy-> A tleast not the part that pertains to Frege
13:39:43 <cpoucet> Syzygy-: it was a light attempt at humor :
13:39:44 <cpoucet> :|
13:39:54 <Syzygy-> roconnor: Are you writing your code in Esperanto??? http://r6.ca/blog/20050224T211500Z.html
13:39:55 <lambdabot> Title: The True Name of Mathematical Objects
13:40:01 <Syzygy-> cpoucet: Too tired for humor. Apologies. ;)
13:40:13 <roconnor> Syzygy-: no, but I think it would be a good idea.
13:40:20 * cpoucet is vincenz fyi
13:40:32 <Syzygy-> cpoucet: Ah. Hi vincenz. :)
13:40:55 <roconnor> Syzygy-: then it would be equally understandable to everyone!
13:40:58 <augustss> cpoucet: I wonder how serious qwe1234 really is
13:41:17 <Syzygy-> roconnor: Or at least everyone of an romanic/germanic persuasion.
13:41:27 <Syzygy-> slavs would have more difficulties, and non-indoeuropeans need not apply.
13:41:38 <cpoucet> augustss: Likewise.  At times he seems too obvious, but at times the arguments he make really sound like someone believing his own words, which then makes you wonder how thick he has to be if he doesn't get hit by the cluestick of all the downmods and counter-arguments.
13:42:26 <augustss> I think he enjoys it.  Serious or not.
13:42:39 <roconnor> Syzygy-: http://r6.ca/blog/20050207T185200Z.html gives some context
13:42:40 <lambdabot> Title: Free Software and Esperanto
13:42:51 <roconnor> ``In 25 years when all the good open source software is documented in some Chinese language, then you will all say, Oh, we should have listened to r6. Id much rather learn Esperanto than learn Mandarin.
13:43:12 <roconnor> :)
13:43:16 <cpoucet> augustss: Btw, regarding the state + continuation monads.  I thought (and this is based on a very vague memory and a very vague hunch), that continuations and state are somewhat isomorphic?
13:44:02 <augustss> um, no, not as far as i know
13:44:22 <cpoucet> Ok
13:44:23 <mrd> you should document your code in haskell
13:44:45 <Lemmih> roconnor: 'cons' is extremely inefficient.
13:44:51 <monochrom> I like Chinese.
13:45:14 <dylan> roconnor: what blog software do you use?
13:45:29 * cpoucet detaches and goes home for dinner
13:45:38 <roconnor> Lemmih: I've been thinking I should buffer my output before appending it using Data.Binary.Put.
13:45:58 <roconnor> dylan: I assembled my own from scraps lying about.
13:46:07 <roconnor> dylan: it probably shows.
13:46:07 <dylan> roconnor: ah.
13:46:44 <roconnor> and a little haskell glue
13:46:55 <augustss> from qwe1234 "once you've fully and unambiguously specified the memory layout of your data, you've also (effectively) completely specified your computation process."
13:46:57 <roconnor> I learned that gnu-make is a horrible horrible program.
13:47:33 <augustss> indeed!
13:47:47 <monochrom> data Tree a = Null | Bin a (Tree a) (Tree a)  --   :)
13:47:56 <SamB> what do you suggest that I use instead?
13:48:00 <SamB> of gnu-make
13:48:31 <roconnor> SamB: I don't know.  I've been meaning to look around.
13:48:32 <MisterN> monochrom: i actually understand that line :)
13:48:37 <monochrom> qew1234 is right for a small class of data and computation.
13:49:03 <phoniq> foo
13:49:14 <monochrom> Yeah, Chinese is not scary! Everyone learn Haskell in Chinese! ...
13:49:19 <phoniq> make programs.  pain.
13:49:30 <augustss> make programs, not pain
13:49:54 <augustss> Haskell in Chinese doesn't work
13:50:06 <augustss> no lower/upper case distinction :(
13:50:17 <monochrom> No, I mean read a Haskell book written in Chinese.
13:50:42 <dolio> Is there one?
13:50:46 <monochrom> No.
13:50:50 <dolio> If you learn Japanese you can read the evil bird book.
13:50:57 <SamB> that makes it tricky
13:51:08 <monochrom> I should write one. :)
13:52:04 <dolio> http://tinyurl.com/2l8fcc <-- Who wouldn't want to learn Haskell with a cover like that?
13:52:43 <shapr> I've got to admit, I love the evil birds.
13:52:47 <roconnor> doio: whoa.  Scary looking.
13:53:01 <monochrom> Oh, there is a better idea. Instead of writing my own, I should follow the Chinese tradition of just translating the Japanese one. :)
13:53:13 <Syzygy-> roconnor: Just saw your "Monads everywhere".
13:53:52 <Syzygy-> roconnor: One of the things a good friend of mine used extensively in his masters thesis was the idea of a "Galois correspondence", which can be generalized from dealing with posets of subgroups and intermediate fields to any posets.
13:54:19 <Syzygy-> roconnor: And if you stare at those definitions enough, it turns out that what you REALLY do is to construct adjoint functors between the posets-viewed-as-categories.
13:54:35 <roconnor> :) Monads have really clairified how to program with (uniformly) continuous functions.
13:54:44 <Syzygy-> roconnor: So, the double composition is a monad. And thus so is a closure in its poset-sense.
13:54:56 <Syzygy-> roconnor: And thus, so is any closure - including completions.
13:55:22 <roconnor> Syzygy-: the word adjoint scares me.
13:55:38 <Syzygy-> It's not that big a deal. It's half a monad. ;)
13:55:53 <Syzygy-> (though, on the other hand, I have only understood it in the most basal cases.....)
13:56:25 <monochrom> "double composition" means like FGFG ?
13:56:35 <Syzygy-> No, I intended FG with that term.
13:56:56 <Syzygy-> One of the core results used in the application of Galois correspondence was that FGFG=FG
13:57:12 <Syzygy-> Which is, for M = FG just the join/bind/whatever of monads.
13:57:34 <xerox> ?type join
13:57:36 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
13:57:50 <sorear> roconnor: cool real number monad
13:58:06 <roconnor> sorear: thanks.  Others are not so impressed.
13:58:18 <Syzygy-> Ah. join.
13:58:27 <roconnor> C (C X) is isomorphic to C X, they say.
13:58:32 <roconnor> boring.
13:58:34 <monochrom> monad probably generalizes closure in a similar way that adjunction generalizes galois connection
14:00:00 <roconnor> is there an adjoint functor datatype is haskell?
14:00:04 <Syzygy-> monochrom: For one, it's not clear to me what the unit should be for closures.
14:03:40 <dolio> roconnor: http://www.eyrie.org/~zednenem/2004/hsce/Control.Functor.Adjunction.html
14:03:42 <lambdabot> http://tinyurl.com/2dktbr
14:03:43 <monochrom> "the people you know are (equal) the people known to all those who know all those you know"  you can set up a galois connection to prove that. F(X) = { q | forall p in X. p knows q } = people known to all those in X. G(Y) = { p | forall q in Y. p knows q } = people who know all those in Y.  Then you are trying to prove F(you) = FGF(you), or more generally F=FGF.
14:04:54 <roconnor> dolio: thanks
14:06:49 <fasta> The constraint MonadState Foo m cannot be realized, right?
14:07:24 <monochrom> if m happens to be something like State Foo
14:07:57 <Lemmih> roconnor: Wouldn't that be cheating?
14:08:23 <roconnor> Lemmih: I did it in my original code.
14:08:46 <roconnor> I think of it as trying not to be too hard on one's libraries.
14:08:59 <Lemmih> roconnor: Won't it break compatibility with DNASeq.hs?
14:09:31 <roconnor> Lemmih: well either one could go from Bytestring -> list -> Seq.
14:09:40 <roconnor> Lemmih: or better would be to abstract the Put monad
14:09:51 <roconnor> to construct either a Seq or a Bytestring.
14:10:38 <roconnor> It would probably make both faster.
14:11:12 <roconnor> although it would probably have more of an effect with our ropes.
14:12:08 * Lemmih curses at GHC for not inlining correctly.
14:12:26 <roconnor> Lemmih: what's wrong?
14:12:31 <glguy> ?. elite quote
14:12:31 <lambdabot> DanAXU 5Ay5: prO9rAm eRr0r5 4R3 (OMM0N iN 50f7\/\/ArE SYzT3M$, inC|uDiNg 7|-|o$E +|-|4t arE cON5TRU(T3d Fr0M 4DVaNcEd prO9rAm/\/\In9 |AN9U493s, 5uCH 4s |-|ASk3|l
14:12:49 <glguy> ?quote
14:12:49 <lambdabot> sigfpe says: Haskell is so strict about type safety that randomly generated snippets of code that successfully typecheck are likely to do something useful, even if you've no idea what that useful
14:12:49 <lambdabot> thing is.
14:13:17 <roconnor> @dijn ((((a->b)->a)->a)->b)->b
14:13:17 <lambdabot> Maybe you meant: dice dict djinn
14:13:22 <roconnor> @dijnn ((((a->b)->a)->a)->b)->b
14:13:22 <lambdabot> f a = a (\ b -> b (\ c -> a (\ _ -> c)))
14:13:26 <Lemmih> roconnor: 'cons' could be much cheaper if 'append'/'viewr' was inlined.
14:13:26 <magnus> I'm sold on QuickCheck now... for my fortran parser I added a check that parse (prettyprint x) = x and it found lots of bugs!
14:13:28 <tlittle> This is a newbie question but bear with me (just started working with Haskell today). I'm trying to get a HApps example working and I'm getting an error when I compile that says: "Could not find module `HAppS':" This is on a Fedora box. Do I need to set some kind of path variable? If so, where do I point it to?
14:13:31 <edwardk> random inquiry, to do locale/charset dependent string comparison, do you think it'd be best to stick to bytestrings and invoke the existing c/posix-like strxfrm and strcoll or to implement them directly in haskell so it could be done over haskell strings possibly with a newtype indicating locale
14:14:12 <glguy> SyntaxNinja: yoyo
14:14:16 <SyntaxNinja> hi glguy
14:14:18 <SyntaxNinja> get to work.
14:14:23 <glguy> yoyoyo
14:14:34 <jsnx> somebody was talking about games in haskell earlier...
14:14:34 <Cale> tlittle: Sounds like possibly HAppS isn't properly installed?
14:14:53 <jsnx> what if you made the game code generator?
14:15:03 <roconnor> Lemmih: I'm pretty convinced about the suckage of the GHC optimizer.
14:15:11 <jsnx> it would generate graphics card stuff, &c.
14:15:12 <roconnor> not that I know how to do any better.
14:15:13 <tlittle> Cale: maybe, I'm not entirely sure how to check.
14:15:14 <magnus> By the way, would anyone be interested collaborating in a Language.Fortran thing? I've got a (very) rough start.
14:15:45 <Cale> tlittle: oh, are you compiling with --make ?
14:15:54 <tlittle> yes
14:16:02 <tlittle> ghc --make -fallow-overlapping-instances -o hello_world hello_world.hs
14:16:02 <edwardk> the only issue is that strxfrm and strcoll aren't _really_ pure since theoretically you could setlocale in the middle, so to use the real posix interface properly they should be in the IO monad, but practically they get used everywhere when you adopt them
14:17:03 <edwardk> hence why looking at a newtype tag or phantom locale type or something would be the more-correct haskelly way to do things
14:17:34 <tlittle> where would the HApps modules live if they were installed correctly
14:17:34 <tlittle> ?
14:18:07 <monochrom> Does Windows come with the POSIX collation stuff?
14:18:29 <Cale> tlittle: I believe they'd show up under ghc-pkg list
14:18:44 <edwardk> monochrom: not exactly, but there are a couple of implementations that fake it over windows code pages, etc.
14:18:54 <Cale> tlittle: I'll try installing...
14:18:58 <edwardk> and parts of it work there
14:19:24 <edwardk> iirc UTF8 breaks in byte comparison mode, but you can use a wcscoll comparison, etc.
14:19:39 <monochrom> Doing it in Haskell is a lot more work but more portable.
14:19:48 <edwardk> thats the dilemma =)
14:20:20 <edwardk> and it could avoid round tripping to c strings every time when comparing strings stored in traditional haskell form
14:21:31 <edwardk> trying to figure out if the best way would be to just compile the locale files to a haskell module that implements a typeclass or something.
14:23:47 <edwardk> would muck with String comparisons something fierce because to determine relative ordering it can have to make multiple passes over the string. alternatively, i guess a strxfrm-like function that took a haskell string and returned a haskell string would work
14:24:33 <edwardk> and then you could newtype to lift into that automatically when comparing strings
14:25:12 <edwardk> and hope inlining and common subexpression elimination would cut down on superfluous invocations of it
14:28:58 <edwardk> i'm thinking maybe something like class Ord s => Collation s where collate :: String -> s
14:29:24 <edwardk> to transform into an opaque sortable type
14:29:39 <roconnor> edwardk: It seems to make sense that strings ought to carry their locale with them.
14:31:27 <edwardk> roconnor: I kind of like the foo :: Int -> UTF8 signatures that come from that, but i'm kinda leery when I consider the sheer number of locales when you break them out ala POSIX/IEEE, hence why I'm trying to get some input =)
14:31:29 <olliej> ndm: ping?
14:31:59 <edwardk> foo :: Int -> En_US_UTF8       bar :: Int -> En_US_ISO8859_1    when does it stop?
14:32:48 <jsnx> anybody live know about the proposed replacement for ghcprof, the one made using gtk?
14:34:05 <ddarius> jsnx: I guess everyone who knew something about that died.  Sorry.
14:34:08 <edwardk> i kind of like the idea of carrying the locale as a phantom type parameter on the newtype, so you can ignore it if you don't care and let polymorphism come to your rescue. foo :: Locale l => Int -> LString l
14:34:18 <jsnx> ddarius: damn
14:35:17 <edwardk> that would then let that type carry all sorts of information for the full posix locale setting information, and it could even use the implicit configurations trick to pass the info, but then pattern matching takes a hit.
14:35:40 <edwardk> whereas the collate version doesn't have any pattern matching problems, since you have a normal string, then you choose to collate it according to a locale
14:41:50 <meren> I just started to study Haskell and I have a silly quick question (sorry): assume that I have a string and i want to find the position of a particular character in it, how should I do that?
14:42:39 <monochrom> @hoogle a -> [a] -> Int
14:42:40 <lambdabot> No matches, try a more general search
14:42:47 <monochrom> @hoogle [a] -> a -> Int
14:42:47 <lambdabot> No matches, try a more general search
14:43:04 <cognominal_> hi, is there an up to date way of using cocoa from ghc on an i486 macbook?
14:43:04 <cognominal_> hi, is there an up to date way of using cocoa from ghc on an i486 macbook?
14:43:07 <dolio> @type find
14:43:09 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
14:43:15 <edwardk> @type index
14:43:16 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Int
14:43:26 <edwardk> er
14:43:29 <pastorn> monochrom: exists --> Just a, not exists -> Nothing
14:43:32 <edwardk> @type indexOf
14:43:35 <lambdabot> Not in scope: `indexOf'
14:43:36 <dolio> @type findIndex
14:43:38 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
14:43:43 <edwardk> thats it =)
14:43:44 <dolio> Success!
14:43:45 <monochrom> Oh! elemIndex
14:43:47 <meren> :))
14:44:07 <meren> so my function is findIndex.
14:44:31 <dolio> @type elemIndex
14:44:33 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
14:45:12 <pastorn> http://www.cs.chalmers.se/Cs/Grundutb/Kurser/d1pt/d1pta/ListDoc/
14:45:14 <lambdabot> Title: Haskell's Standard List Functions
14:45:26 <pastorn> monochrom: that's a nice help :)
14:45:30 <ddarius> :t findIndex . (==)
14:45:32 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
14:45:45 <meren> pastorn: thank you
14:45:53 <meren> and thanks others as well.
14:46:21 <ddarius> meren: Usually you don't care about indices of things in lists...
14:47:40 <edwardk> > findIndex (=='2') "Foo12345"
14:47:42 <lambdabot>  Just 4
14:47:53 <meren> ddarius: i realized that actually, but I just wanted to do a silly job with haskell to get used to it slowly. for example parsing /etc/passwd file and finding home directory of a particular user.
14:48:44 <ddarius> @free elemIndex
14:48:46 <lambdabot> Extra stuff at end of line in retrieved type "forall a. (Eq a) => a -> [a] -> Maybe Int\n"
14:49:07 <ddarius> @free (==)
14:49:07 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
14:49:15 <pastorn> ddarius: @free?
14:49:25 <shafire> hi cmarcelo
14:49:27 * ddarius doesn't think it handles type classes.
14:49:29 <ddarius> @help free
14:49:29 <lambdabot> free <ident>. Generate theorems for free
14:49:38 <ddarius> @free map
14:49:40 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
14:49:58 <pastorn> cool
14:50:07 <pastorn> @free (>>=)
14:50:08 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
14:50:12 <MisterN> @free take
14:50:13 <lambdabot> $map f . take x = take x . $map f
14:50:13 <pastorn> @free >>=
14:50:14 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
14:50:30 <cmarcelo> hi
14:50:30 <pastorn> @free maximum
14:50:32 <lambdabot> Extra stuff at end of line in retrieved type "forall a. (Ord a) => [a] -> a\n"
14:50:43 <pastorn> @free max
14:50:45 <lambdabot> Extra stuff at end of line in retrieved type "forall a. (Ord a) => a -> a -> a\n"
14:50:47 <MisterN> pastorn: heh you're not lucky today
14:50:47 <ddarius> It seems unable to handle typeclasses which is not surprising.
14:51:02 <Saizan> @free foldr
14:51:02 <sjanssen> @free concatMap
14:51:02 <MisterN> @free fix
14:51:03 <lambdabot> (forall x. g . h x = k (f x) . g) => g . foldr h y = foldr k (g y) . $map f
14:51:05 <lambdabot> f . g = h . f => f (fix g) = fix h
14:51:06 <ddarius> @free maximumBy
14:51:07 <lambdabot> $map g . h = k . f => $map g . concatMap h = concatMap k . $map f
14:51:08 <lambdabot> (forall x. g x = h (f x) . f) => f . maximumBy g = maximumBy h . $map f
14:51:23 <pastorn> @free foldr1
14:51:25 <lambdabot> (forall x. f . g x = h (f x) . f) => f . foldr1 g = foldr1 h . $map f
14:51:28 <Lemmih> roconnor: Better inlining of cons cut ~2m off empty.dna.
14:51:34 <pastorn> yay!!
14:51:35 <MisterN> let's all do our free games in a query with lambdabot.
14:51:54 <fasta> Heh, I didn't know newtype deriving was that general...
14:52:06 * fasta derives 9 instances..
14:52:15 <edwardk> hrmm, is there a generic form of words or lines that takes an arbitrary partitioning value?
14:52:17 <sjanssen> fasta: it's so general, it can break parametricity!
14:52:18 <lambdabot> sjanssen: You have 1 new message. '/msg lambdabot @messages' to read it.
14:52:35 <edwardk> (a -> Bool) -> [a] -> [[a]]   or something like that?
14:52:40 <fasta> sjanssen: don't tell me I can't use this either!
14:52:40 <shachaf> @free eq :: Eq a => a -> a -> Bool
14:52:41 <lambdabot> Extra stuff at end of line
14:52:45 <shachaf> @free eq :: a -> a -> Bool
14:52:45 <lambdabot> eq x = eq (f x) . f
14:53:09 <Saizan> edwardk: no, and we really miss it
14:53:17 <fasta> sjanssen: how, if I may ask?
14:53:24 <sorear> Forget parametricity, newtype deriving can break type safety!  (with associated types)
14:53:33 <sjanssen> fasta: I can't remember the details, ask sorear
14:53:49 <edwardk> saizan: gah, whodathunk that perl would outdo us ;)
14:54:09 <sorear> http://hackage.haskell.org/trac/ghc/ticket/1496
14:54:11 <lambdabot> Title: #1496 (Newtypes and type families combine to produce inconsistent FC(X) axiom se ...
14:54:13 <edwardk> i'm sure there is a succinct way to fold it using splitAt
14:54:26 <edwardk> or something like that
14:54:29 <Saizan> splitAt? i'd say span
14:54:33 <edwardk> thats what i meant
14:54:41 <sjanssen> edwardk: there's a really concise way to do it with groupBy IIRC
14:54:56 <edwardk> @type groupBy
14:54:58 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
14:55:03 <fasta> sjanssen: what's the parametricity theorem?
14:55:44 <edwardk> ah tagging each with its equivalence classs
14:56:33 <edwardk> > groupBy (\x y -> (x == ':') == (y == ':')) "foo:bar"
14:56:34 <lambdabot>  ["foo",":","bar"]
14:56:48 <edwardk> > groupBy (comparing (==':')) "foo:bar"
14:56:49 <lambdabot>  Couldn't match expected type `Bool'
14:56:51 <edwardk> oops
14:56:54 <edwardk> @type comparing
14:56:56 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
14:57:02 <ddarius> :t on
14:57:04 <lambdabot> Not in scope: `on'
14:57:12 <ddarius> Noch nicht.
14:57:23 <shachaf> @ty let on f g x y = g x `f` g y in on
14:57:25 <lambdabot> forall t t1 t2. (t -> t -> t1) -> (t2 -> t) -> t2 -> t2 -> t1
14:57:32 <Saizan> > let split p = map tail . groupBy (const (not . p)) in split (==':') "asdsa:askjdkas:asjkdksa:"
14:57:33 <lambdabot>  ["sdsa","askjdkas","asjkdksa",""]
14:57:34 <monochrom> > groupBy (\x y -> (x == ':') == (y == ':')) "foo::::bar"
14:57:34 <shachaf> @let on f g x y = g x `f` g y
14:57:35 <lambdabot>  ["foo","::::","bar"]
14:57:40 <lambdabot> Defined.
14:58:00 <shachaf> > (compare `on` even) 5 3
14:58:01 <lambdabot>  EQ
14:58:29 <ddarius> > groupBy ((==) `on` (==':')) "foo:bar"
14:58:31 <lambdabot>  ["foo",":","bar"]
14:58:37 <MisterN> @type compare
14:58:39 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
14:58:45 <ddarius> @src Ordering
14:58:45 <lambdabot> data Ordering = LT | EQ | GT
15:02:42 <edwardk> saizan: your version munches the first char of the first word
15:03:22 <Saizan> edwardk: ah, right :\
15:03:28 <meren> Saizan: :)
15:03:57 <fasta> sjanssen: I see someone wants to *deprecate* newtype deriving
15:03:59 <dozer> I'm wanting to do a computation in both MonadPlus and MonadState so that whenever the MonadPlus forks, the state forks and correspondingly, when MonadPlus fails, the associated statefull fork is forgotten about and isn't folded back into the other forks
15:04:18 <fasta> sjanssen: I guess XMonads LOC will increase too then... :)
15:04:28 <dozer> my first couple of tries threaded the state through everywhere :(
15:04:29 <Saizan> i have always hated this "things in the middle" problems, you have to special case one side or the other
15:04:35 <fasta> XMonad's*
15:04:45 <Saizan> *these
15:06:06 <monochrom> s -> [(a,s)]  StateT s [] a  should behave as desired.
15:06:19 <augustss> dozer: stack a state monad on top of what it is that you want
15:06:25 <MisterN> @free groupBy
15:06:30 <lambdabot> (forall x. g x = h (f x) . f) => $map ($map f) . groupBy g = groupBy h . $map f
15:06:37 <edwardk> > let split p = uncurry (:) . (head &&& map tail . tail) . groupBy (const (not . p)) in split (==':') "foo:bar:baz"
15:06:38 <lambdabot>  ["foo","bar","baz"]
15:06:47 <edwardk> kinda hideous that =)
15:07:00 <augustss> heh
15:07:08 <edwardk> @pl split p = uncurry (:) . (head &&& map tail . tail) . groupBy (const (not . p))
15:07:08 <lambdabot> (line 1, column 9):
15:07:08 <lambdabot> unexpected "="
15:07:08 <lambdabot> expecting variable, "(", operator or end of input
15:07:24 <edwardk> @pl \p -> uncurry (:) . (head &&& map tail . tail) . groupBy (const (not . p))
15:07:25 <lambdabot> (line 1, column 40):
15:07:25 <lambdabot> unexpected "."
15:07:25 <lambdabot> expecting variable, "(", "!!", space, operator or ")"
15:07:25 <lambdabot> ambiguous use of a right associative operator
15:08:01 <meren> ghc says "Not in scope" for groupBy. how can I find the scope of this function in interactive shell?
15:08:10 <edwardk> :m + Data.List
15:08:26 <monochrom> runStateT ((put 5 >> get) ++ get ++ mzero) 0
15:08:31 <monochrom> > runStateT ((put 5 >> get) ++ get ++ mzero) 0
15:08:32 <lambdabot>  Couldn't match expected type `StateT s m a'
15:09:23 <MisterN> @src runStateT
15:09:23 <lambdabot> Source not found. It can only be attributed to human error.
15:09:30 <elliottt> > runState ((put 5 >> get) ++ get ++ mzero) 0
15:09:30 <lambdabot>  Couldn't match expected type `State s a'
15:09:46 <Saizan> mplus, maybe?
15:09:53 <monochrom> Oh!
15:10:28 <monochrom> > runStateT (((put 5 >> get) `mplus` get `mplus` mzero) :: StateT Int [] Int) 0
15:10:30 <lambdabot>  [(5,5),(0,0)]
15:10:34 <elliottt> ah :)
15:11:14 <monochrom> Yeah, ++ is for [] not for StateT s []. It becomes mplus after transformation.
15:12:21 <monochrom> I was trying to save typing. ++ was much shorter than `mplus`. Forgot I need the more general one.
15:12:47 <ddarius> Perhaps they'll put ++ back into the MonadPlus type class (a la Gofer)
15:13:48 <augustss> Been there, done that.  I doubt it will be done again.
15:14:09 <edwardk> let split p = uncurry (:) . (head &&& map tail . tail) . groupBy (const (not . p)) in do users <- fmap (map ((head &&& (!!5)) . split (==':')) . lines) $ readFile "/etc/passwd"; return $ lookup "cupsys" users      successfully returns Just "/home/cupsys"
15:14:59 <meren> ah man.. this is complicated. but funny though.
15:15:10 <augustss> ugh!
15:15:14 <edwardk> meren: thats not the version i'd probably recommend in the real world though =)
15:15:28 <meren> edwardk: sure :)
15:15:29 <edwardk> i just wanted to squeeze it into a one-liner
15:16:08 <Saizan> @quote melted
15:16:08 <lambdabot> glguy says: in true Haskell form, after I realized what I was actually doing... all my functions melted down to about 2 lines each
15:16:31 <qwr> :t (&&&)
15:16:33 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
15:16:52 <MisterN> @src (&&&)
15:16:52 <lambdabot> f &&& g = arr (\b -> (b,b)) >>> f *** g
15:17:12 * qwr . o O ( arrows on lists... nice... )
15:17:28 <Saizan> it's still the (->) arrow
15:17:31 <edwardk> in the real world i'd probably just use System.Posix.User's getUserEntryForName and look at its homeDirectory attribute =)
15:18:44 <edwardk> fmap homeDirectory $ getUserEntryForName "cupsys"
15:18:56 <edwardk> returns "/home/cupsys"
15:19:25 <IR4> /privmsg lambdabot @type map
15:19:51 <TSC> (a -> b) -> [a] -> [b]
15:22:21 <matthew-_> @seen DRMacIver
15:22:22 <lambdabot> DRMacIver is in #haskell and #haskell-blah. I last heard DRMacIver speak 1h 50m 18s ago.
15:22:58 <olliej> ndm: once more with the prodding? :D
15:23:38 <DRMacIver> matthew-_: Hm?
15:24:30 <IR4> /privmsg lambdabot @pointfree \x -> x
15:25:02 <TSC> id
15:25:42 <TSC> IR4: Your private messages aren't private
15:26:22 <IR4> yes, so I gathered. new to this IRC client, I apologise :)
15:27:26 <mux> yay
15:27:50 * mux successfully encodes existential types using universal types in System-F
15:27:53 <IR4> am I using the right syntax?
15:28:12 <TSC> IR4: For lambdabot, or your IRC client?
15:28:17 <IR4> for IRC
15:28:27 <arjanb> afaik most irc clients use /msg
15:28:37 <ndm> olliej: yes, but am downstairs in a game of high stakes poker, feel free to email me, or wait about an hour
15:28:43 <mux> now I see why specific syntactic support is desired for unpacking existential types
15:28:49 <olliej> ndm: righto :D
15:30:05 <IR4> ah, perfect. thank you
15:32:10 <edwardk> @src comparing
15:32:10 <lambdabot> Source not found. That's something I cannot allow to happen.
15:32:15 <edwardk> @type comparing
15:32:17 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
15:32:19 <dozer> ah, thanks monochrom and augustss - that seems to work just fine
15:32:53 <dozer> I think last time, I'd used state and mapM, rather than stateT, and got a result I didn't want
15:33:11 <monochrom> Right.
15:34:50 <Excedrin> ndm: high stakes?
15:35:04 <shachaf> @instances Arrow
15:35:05 <lambdabot> (->), Kleisli m
15:35:23 <hpaste>  dozer pasted "forked state" at http://hpaste.org/1999
15:46:58 <chessguy> 'evening
15:54:42 <meren> I managed to do this:
15:54:46 <meren> Prelude> (\x -> map (\t -> drop ((fst t) + 1) (take (snd t) x)) (let s (x:xs) = if length xs == 0 then [] else (x, head xs):s xs in do s (Data.List.sort ((-1):length x:(filter (\t -> x!!t == ':') [1..((length x)-1)]))))) "ejabberd:x:131:131:Ejabberd:/dev/null:/bin/false"
15:54:46 <meren> ["ejabberd","x","131","131","Ejabberd","/dev/null","/bin/false"]
15:55:39 <meren> my first day with haskell is gonna be my last I guess :(
15:55:52 <sjanssen> meren: I'm sure we can do better
15:56:09 <sjanssen> you just want to separate a string by ':'?
15:56:18 <meren> yes
15:56:30 <meren> i diminished my goals
15:56:45 <sjanssen> meren: also, you can't expect to do this most efficiently on your first day :)
15:57:00 <sm> bah
15:57:03 <DRMacIver> > join $ intersperse ':' $ ["foo", "bar", "baz"]
15:57:03 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
15:57:06 <DRMacIver> Hm
15:57:12 <DRMacIver> Oops
15:57:16 <DRMacIver> > join $ intersperse ":" $ ["foo", "bar", "baz"]
15:57:18 <lambdabot>  "foo:bar:baz"
15:57:33 <MisterN> @type intersperse
15:57:35 <lambdabot> forall a. a -> [a] -> [a]
15:59:09 <meren> what would you advice me to read about Haskell?
15:59:29 <DRMacIver> Oh, sorry, you're trying to split based on ':' rather than join with it?
16:00:07 <MisterN> > intersperse ":" $ ["foo", "bar", "baz"]
16:00:09 <lambdabot>  ["foo",":","bar",":","baz"]
16:01:06 <matthew-_> ahh
16:01:26 <hpaste>  sjanssen pasted "chop, for meren" at http://hpaste.org/2000
16:01:29 <DRMacIver> MisterN: It's just one of those cute little functions that turns out to be surprisingly useful. :)
16:01:33 <sieni> meren: depends on your background, but yaht might be a good start
16:01:49 <sjanssen> meren: http://hpaste.org/2000 try "chop (== ':')"
16:01:59 <chessguy> @where meta
16:01:59 <lambdabot> I know nothing about meta.
16:02:03 <sieni> meren: http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf
16:02:04 <chessguy> @where metatutoria
16:02:04 <lambdabot> I know nothing about metatutoria.
16:02:04 <MisterN> DRMacIver: yeah, had to test if it did what i expected it to do :)
16:02:07 <chessguy> @where metatutorial
16:02:08 <lambdabot> I know nothing about metatutorial.
16:02:19 <chessguy> @go haskell wiki meta tutorial
16:02:21 <lambdabot> http://en.wikibooks.org/wiki/Haskell
16:02:21 <lambdabot> Title: Haskell - Wikibooks, collection of open-content textbooks
16:02:27 * chessguy sighs
16:02:33 <meren> thank you sjanssen
16:03:39 <chessguy> meren, http://haskell.org/haskellwiki/Meta-tutorial may interest you
16:03:40 <lambdabot> Title: Meta-tutorial - HaskellWiki
16:03:44 <sjanssen> hmm, this has some annoying corner cases
16:04:20 <meren> sieni: I've been reading yaht but it didn't help that much.. I guess my problem is I can't find proper functions with interactive shell easily..
16:04:39 <qwr> > map tail $ groupBy (const (/= ':')) ":zoo:foo:bar"
16:04:41 <lambdabot>  ["zoo","foo","bar"]
16:05:01 * glguy wonders if using insertLookupWithKey would be an efficient want to conditionally perform an insert
16:05:10 <meren> ":zoo:foo:bar" should be "zoo:foo:bar" :)
16:05:28 <glguy> if I don't demand the resulting map, then it shouldn't be computed, right?
16:05:39 <qwr> > ':' : "zoo:foo:bar"
16:05:41 <lambdabot>  ":zoo:foo:bar"
16:05:41 <sjanssen> qwr: ah, clever
16:05:51 <meren> eheh
16:06:21 <DRMacIver> qwr: It has been suggested that one should consider the behaviour of groupBy on non equivalence relationships to be undefined. :)
16:06:26 <DRMacIver> But still cute.
16:06:27 <sjanssen> > map (dropWhile (== ':')) $ groupBy (const (/= ':')) "zoo:::foo:bar::"
16:06:29 <lambdabot>  ["zoo","","","foo","bar","",""]
16:06:45 <sjanssen> see, that's already better than my first try already
16:07:12 <MisterN> > dropWhile (== "") ["zoo","","","foo","bar","",""]
16:07:13 <lambdabot>  ["zoo","","","foo","bar","",""]
16:08:03 <hpaste>  sjanssen annotated "chop, for meren" with "better, thanks to qwr" at http://hpaste.org/2000#a1
16:08:16 <sieni> meren: like what?
16:08:36 <meren> chessguy: meta tutorial seems really helpful, thanks.
16:11:43 <meren> sieni: comparing with python's interactive shell, ghc didn't seem productive and helpful to me. probably the problem is that I'm not familiar enough with ghci.
16:12:05 <puusorsa> sieni, rtor!
16:12:13 <sieni> meren: in what sense? haskell isn't quite an interpretable language
16:12:23 * qwr read the "gentle" introduction once to start on haskell... but knowing ocaml before was somewhat cheating ;)
16:12:56 <sjanssen> meren: ghci is a bit different from other shell-like interpreters
16:13:23 <meren> hm
16:13:36 <sjanssen> meren: it's generally recommended that you do the main hacking in a text file, then do tests and poking around in ghci
16:13:57 <sjanssen> :load, :r, etc. in ghci make this work okay
16:14:36 <DRMacIver> Where 'different' means 'worse' in this case. ;)
16:15:05 <sieni> DRMacIver: well, there are some constraints caused by the semantics of the language
16:15:08 <meren> I'm not going to ask silly questions about ghci. let me read more about it and Haskell generally. thanks for the help and tips anyway :)
16:15:46 <DRMacIver> sieni: Sure. Although I've made that point before and it's been observed in response that you can still do a lot better than ghci does.
16:16:11 <sieni> DRMacIver: possibly
16:16:54 <qwr> meren: and read some monad tutorials too. you'll miss much haskell fun if you don't understand them.
16:17:36 <meren> qwr: it was the first thing that I was sure about Haskell :)
16:21:02 <Excedrin> how can I compare a pair of binary trees?
16:21:25 <matthew-_> Excedrin: just recursion on the structure of the tree
16:21:34 <Excedrin> ok
16:21:56 <sjanssen> Excedrin: depends on which comparison you want
16:21:57 <Excedrin> what's the data structure where each tree node is a list
16:22:16 <matthew-_> if it's literally just data Tree a = Empty | Node (Tree a) a (Tree a) then you can do deriving (Eq) on it
16:22:21 <sjanssen> if it's an ordered tree, you might want to compare fromList of the tree
16:23:40 * glguy wonders if anyone understands irssi's /window model
16:23:42 <MisterN> n8
16:23:56 <glguy> I feel like I accidentally get it right eventually
16:36:21 <bitwize> Haskell doesn't support value semantics!
16:36:26 <bitwize> This is an utter surprise to me.
16:36:41 <Cale> bitwize: hm?
16:36:59 <bitwize> You know... VALYOO SUMMANTIKS.
16:37:10 <glguy> @slap bitwize
16:37:10 * lambdabot slaps bitwize
16:37:19 <Lemmih> What are value semantics?
16:37:31 <bitwize> As opposed to reference semantics.
16:38:07 <glguy> what is the distinction when the values are immutable?
16:38:32 <bitwize> I didn't think there was one! BOY WAS I PROVEN WRONG.
16:39:06 <bitwize> (Yes, I'm being a facetious twerp.)
16:39:11 <sorear> bitwize: Don't listen to him, he's probably just a troll
16:39:49 <bitwize> w/o valyoo summantiks, haksell wil nevar be takan srsly!
16:39:52 <thoughtpolice> i'm currently getting a build error for ghc 6.6.1 (archlinux,) most of the stuff builds fine however, in the libraries/base directory I'm getting a weird linker error (that happens to be very very very long.) if I actually run there and run a 'make all' same thing happens. anybody have any ideas? (I can paste the err on hpaste right quick)
16:39:54 <Lemmih> sorear: s/bitwize/glguy/?
16:40:07 <sorear> Lemmih: bitwize
16:40:24 <sorear> Lemmih: he sounds like he just lost an argument with a troll
16:40:37 <Lemmih> sorear: Who's the troll then?
16:41:01 * glguy doesn't know what exactly is going on but figured it could be solved with +q's
16:41:01 <bitwize> I don't know how you can lose an argument with someone that far gone.
16:41:10 <sorear> Lemmih: ask bitwize... I'm just guessing there was one
16:41:25 <glguy> ?users
16:41:25 <lambdabot> Maximum users seen in #haskell: 382, currently: 340 (89.0%), active: 19 (5.6%)
16:41:43 <bitwize> I think it has to do with the extent of values.
16:42:03 <thoughtpolice> anybody have any ideas? :(
16:42:04 <glguy> is there a URL where we can read the history of this discussion?
16:42:05 * thoughtpolice cries
16:42:20 <bitwize> http://programming.reddit.com/info/2aioh/comments/c2azqq
16:42:21 <lambdabot> Title: 37 Reasons to Love Haskell (playing off the Ruby article) (reddit.com)
16:42:44 <nominolo> qwe1234 is a bullshitter
16:42:58 <bitwize> He raises an interesting point though about provably bounded memory consumption
16:43:33 <nominolo> yes, at the expense of unbounded time consumption
16:43:45 <glguy> There are certain government certification levels that you can't get on software that uses the heap
16:43:55 <nominolo> use regions
16:44:22 <nominolo> i don't see how this is in any way relevant to the semantics
16:44:24 <sorear> bitwize: See what I said about him being a troll, whoever he was. :)
16:44:41 <sorear> Nobody here cares about qwe1234.
16:45:10 <glguy> qwe1234 is just one of those people that knows just enough to be dangerous, but not enough to be useful
16:45:15 <bitwize> nominolo: It rather has to do with commonly accepted conventions in C++.
16:45:39 <gwern> dunno. wasn't there a language, eden or something, which used static types to guarantee time and space consumption limits?
16:45:59 <bitwize> e.g., Foo f(blah) will declare a new thing that will self-clean-up when the variable goes out of scope. Foo *f = new Foo(blah) will initialize a new thing that you need to destroy manually.
16:46:02 <nominolo> if you want to write safe code, write it in coq, prove your properties and be done with it :)
16:46:05 <DRMacIver> gwern: Ada?
16:46:37 <gwern> DRMacIver: ada did a lot in terms of static types but I am pretty sure it is not the one I am thinking of. way too old for one thing
16:46:47 <nominolo> @where logs
16:46:47 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
16:46:48 <bitwize> SPARKAda?
16:47:05 <glguy> nominolo: you didn't miss anything
16:47:26 <glguy> nominolo: also, that link is in the topic (I mention this because some browsers let you click such links directly)
16:47:39 <gwern> bitwize: no no, it was some sort of lisp or ml variant
16:47:50 <bitwize> Qi?
16:48:11 <gwern> possibly. wish I remember where I saw the paper other than 'somewhere on LtU'
16:48:17 <sorear> Clean? DML?
16:48:21 <DRMacIver> gwern: Are you thinking of BitC?
16:48:31 <bitwize> Eden appears to be a parallel Haskell extension.
16:48:36 <DRMacIver> gwern: http://www.bitc-lang.org/
16:48:38 <lambdabot> Title: The BitC Programming Language
16:48:55 <DRMacIver> ML-like with lisp syntax designed for systems level programming.
16:49:24 <DRMacIver> (I'm not sure what sort of static usage guarantees it makes though)
16:50:21 <bitwize> I've a marked preference for Pre-Scheme
16:50:39 <nominolo> glguy: yeah, the logs link is a redirect, btw.  and it didn't seem complitely up to date, either
16:50:39 * gwern shrugs. could have been bitc. point was that one coulld and has made useful resource bounds in a FP  lang
16:50:48 <thoughtpolice> er, hate to be a bother but would someone mind helping me out with this?
16:50:59 <glguy> nominolo: the topic one is wrong?
16:51:03 <glguy> do I need to update it?
16:51:10 <nominolo> the @where logs
16:51:15 <nominolo> not the topic
16:51:18 <thoughtpolice> this err is really annoying and I have little reason as to why it's happening because the compiler built pretty easy on my openbsd box
16:51:24 <DRMacIver> Hm. I meant to go to bed an hour ago.
16:51:26 * DRMacIver does so now
16:51:32 <bitwize> thoughtpolice? openbsd?
16:51:38 <bitwize> cpu arch is i386?
16:51:40 <glguy> nominolo: you could ?where+ the correct one?
16:52:18 <Excedrin> does bitc have header files?
16:52:19 <thoughtpolice> bitwize: this is on archlinux
16:52:21 <thoughtpolice> i386
16:52:26 <bitwize> oh.
16:52:31 <bitwize> hmmm.
16:52:36 <bitwize> what's the linker error?
16:52:40 <thoughtpolice> just a sec
16:52:41 <bitwize> (hpaste if need be)
16:52:41 <thoughtpolice> i'll paste it
16:52:47 <nominolo> @where+ logs http://tunes.org/~nef/logs/haskell/ http://ircbrowse.com/cdates.html?channel=haskell
16:52:47 <lambdabot> Done.
16:54:05 <hpaste>  thoughtpolice pasted "ghc 6.6.1 linker err [i386/archlinux]" at http://hpaste.org/2001
16:54:26 <nominolo> i think bitc has modules
16:54:44 <nominolo> it's pretty much tied to coyotos, though
16:55:02 <nominolo> at least those seem to be the only ones working on it
16:55:54 <bitwize> that's freaky thoughtpolice
16:55:55 <thoughtpolice> bitwize: there're a lot more errs than that, too. I cut out probably like 95% of them
16:56:17 <bitwize> can't say I know enough about ghc internals to debug it
16:56:19 <thoughtpolice> and this is a build of 6.6.1 with just 6.6
16:56:48 <mm_freak_> is there any page with exercises for advanced haskellers?
16:56:54 <nominolo> sorear: how well do you know coq?
16:56:57 <thoughtpolice> hm for some reason I get the feeling it's because the object file is getting split up so much :/
16:57:11 <sorear> nominolo: been using it for about four days?
16:57:20 <nominolo> heh
16:57:36 <sorear> thoughtpolice: I recognize that error
16:57:38 <nominolo> sorear: i saw your snippet on rse
16:57:43 <nominolo> *RLE
16:57:46 <blackdog> I have two modules with the same methods exported, and I can build my program with either of them
16:58:20 <blackdog> at the moment, I'm just commenting out one of the "import MapIndex as Index" or "import PrimeIndex as Index" lines
16:58:31 <sorear> http://hackage.haskell.org/trac/ghc/ticket/1427
16:58:31 <blackdog> is there a nicer, more automatic way to do it?
16:58:32 <lambdabot> Title: #1427 (GHC fails to compile with gcc 4.2.0) - GHC - Trac
16:58:38 <sorear> thoughtpolice: ^^^
16:59:05 <sorear> nominolo: oh?  comments?
16:59:35 <sorear> nominolo: basically I threw it together as quickly as I could without upsetting the typechecker :)
16:59:42 <sorear> only took me 20 minutes to implement RLE
16:59:59 <thoughtpolice> sorear: thanks
17:00:09 <SamB> sorear: that long?
17:00:11 <nominolo> sorear: no, it looked pretty good for 4 days.  i took part in a coq course given by yves, and i had some problems
17:00:25 <nominolo> SamB: in Coq
17:00:30 <SamB> oh
17:00:33 <SamB> that's better ;-)
17:00:36 <meren> "Haskell for C Programmers" is awesome.. he says "I write this assuming that you have checked out...the Gentle Introduction to Haskell, but...still don't understand what's going on...".. thanks to him.
17:01:16 <thoughtpolice> sorear: any easy way to fix it?
17:01:21 <thoughtpolice> or am I kind of stuck?
17:01:42 * wli brute forces lhs2TeX's treatment of ^ via %format ^ = "^" and wrapping exponent arguments of ^ in {-"{"-} ... {-"}"-} bullcrap in an attempt to get something less bizarre than an up arrow for exponentiation.
17:02:11 <sorear> I dunno.  I imagine downgrading GCC would take care of it, but I have no idea how badly the rest of your system will react.
17:02:25 <bitwize> thoughtpolice: You're kind of stuck as long as you have gcc4.2.0 until they fix it.
17:02:31 <thoughtpolice> i figure. :(
17:02:36 <thoughtpolice> actually I think I have gcc3 on here
17:02:55 <SamB> wli: you couldn't get a carat?
17:02:57 <sorear> wli: %format x ^ {y} = x "^{" y "}"  maybe?
17:03:04 <thoughtpolice> sweet
17:03:06 <thoughtpolice> gcc34 :)
17:03:14 <SamB> 34?
17:03:20 <thoughtpolice> 3.4.6
17:03:23 <bitwize> :)
17:03:24 <SamB> I thought they were still on 4.x ;-P
17:03:31 <thoughtpolice> they couldn't decide
17:03:35 <nominolo> sorear: what do you learn it from?  art d'coq?
17:03:35 <Alleria> @src minimum
17:03:36 <lambdabot> minimum [] = undefined
17:03:36 <lambdabot> minimum xs = foldl1 min xs
17:03:41 <thoughtpolice> so now we're using gcc 34.0!
17:03:53 <thoughtpolice> sorear: thanks for the tip though; i'll configure and rebuild using gcc3 :)
17:04:16 <sorear> nominolo: I read the reference manual, the tutorial, and the faq...
17:04:19 <bitwize> sounds good thoughtpolice.
17:04:32 <bitwize> let us know how it goes.
17:05:09 <wli> sorear: That triggers: Stack space overflow: current size 8388608 bytes.
17:05:20 <nominolo> sorear: i see.  the book takes it rather slow, but i don't want to miss stuff.  also, i have other stuff to work on, too ;)
17:05:23 <sorear> wli: I saw. :)
17:05:37 <Alleria> With that definition could minimum be causing my stack overflows?
17:05:58 <nominolo> 8mb stackspace should be enough for anyone!
17:06:08 <sorear> It is.
17:06:15 <sorear> That's why we have a limit.
17:06:46 <sorear> If there was a legitimate use for 8.1MB stacks, we'd just allow stacks to grow to all free memory.
17:07:08 <dolio> If you need 8.1MB, just hand-translate to CPS.
17:07:10 * SamB_XP_ thinks sorear must be joking
17:07:13 * wli just uses -k or some such.
17:07:23 <nominolo> well, you could use esp as the alloc pointer
17:07:32 <nominolo> and have no stack at all
17:07:45 <SamB_XP_> nominolo: as it is we use esi
17:07:48 <wli> Registerized affairs don't use %esp except for FFI purposes.
17:07:52 <SamB_XP_> for the stack
17:08:08 <sorear> nominolo: You don't have to go all-out Cheney/CPS to not have stack limits.
17:08:24 <sorear> nominolo: You could just allocate the stack as a linked list of (say) 1MB pages
17:08:43 <sorear> nominolo: then most stuff would still be contiguous
17:08:54 <SamB_XP_> can't GHC already do that?
17:08:59 <nominolo> ew, so many overflow tests / guard pagefaults
17:09:01 <sorear> nominolo: that's what GHC did before the Great RTS Rewrite of 4.00
17:09:29 <sorear> nominolo: it still does overflow tests so it knows when to grow the stack...
17:09:43 <sorear> ditto heap checks
17:10:13 * nominolo really has to look closer at ghc
17:10:48 <nominolo> my MSc will be low-level stuff.  so maybe i get into the mood to optimize -fasm
17:10:58 <dons> ?users
17:10:58 <lambdabot> Maximum users seen in #haskell: 382, currently: 341 (89.3%), active: 25 (7.3%)
17:11:02 <dons> cool
17:11:03 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
17:11:25 <nominolo> wow, active > 5%
17:11:33 <nominolo> ;P
17:11:58 <Alleria> ... and what do I have to import to use foldl' ?
17:12:05 <sorear> Data.List
17:12:12 <chessguy> umm, how would you pronounce (>>) ?
17:12:12 <Alleria> thank you sorear
17:12:19 <sorear> "then"
17:12:26 <nominolo> @index foldl' <- Alleria
17:12:26 <lambdabot> bzzt
17:12:33 <nominolo> @index foldl' --- Alleria
17:12:33 <lambdabot> bzzt
17:12:38 <nominolo> @index foldl'
17:12:38 <lambdabot> Data.List
17:12:38 <chessguy> sorear, that's what i thought. you would certainly not call it bind, would you?
17:12:54 <sorear> no, bind is >>=
17:13:12 <Alleria> ahh, that's how you find it. Thanks nominolo
17:13:24 <chessguy> sorear, yeah
17:13:40 <chessguy> an error in the "write yourself a scheme" wikibook
17:13:57 <chessguy> http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Parsing  look for the red text, and read the paragraph after it
17:14:00 <lambdabot> http://tinyurl.com/2yojoc
17:14:13 <mux> idea for next summer of code: implement a MUA in haskell that has good indentation support and which please simonpj
17:14:35 <chessguy> @vera MUA
17:14:37 <lambdabot> *** "mua" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
17:14:37 <lambdabot> MUA
17:14:37 <lambdabot>      Mail User Agent
17:14:37 <lambdabot>  
17:15:02 <glguy> ?vera MTA
17:15:03 <lambdabot> *** "mta" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
17:15:04 <lambdabot> MTA
17:15:04 <lambdabot>      Mail Transport Agent (SMTP)
17:15:04 <lambdabot>  
17:15:04 <lambdabot> *** "mta" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
17:15:05 <lambdabot> [3 @more lines]
17:15:25 <LoganCapaldo> @vera vera
17:15:27 <lambdabot> *** "vera" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
17:15:27 <lambdabot> VERA
17:15:27 <lambdabot>      Just playing around, huh?
17:15:27 <lambdabot>  
17:15:43 <LoganCapaldo> You've cut me to the quick
17:15:45 <glguy> that command makes it easy to scroll the channel
17:15:55 <chessguy> @all-dict scroll
17:15:56 <lambdabot> *** "Scroll" gcide "The Collaborative International Dictionary of English v.0.48"
17:15:56 <lambdabot> Scroll \Scroll\, n. [A dim. of OE. scroue, scrowe (whence E.
17:15:56 <lambdabot>    escrow), OF. escroe, escroue, F. ['e]crou entry in the jail
17:15:56 <lambdabot>    book, LL. scroa scroll, probably of Teutonic origin; cf. OD.
17:15:56 <lambdabot>    schroode a strip, shred, slip of paper, akin to E. shred. Cf.
17:15:58 <lambdabot> [170 @more lines]
17:16:44 * nominolo has plans for something much great0rx
17:16:54 <glguy> a new language?
17:16:58 <nominolo> nono
17:17:05 <nominolo> muchos bettros
17:17:06 <glguy> with 0 and x being common?
17:17:14 <glguy> ohh, one with lots of os?
17:17:24 <nominolo> haskellos!
17:17:41 <nominolo> (no, not really)
17:17:58 <bitwize> The type-checkable taste of Haskell-O's...
17:19:26 <nominolo> it's more IDEalistic
17:19:43 * SamB_XP_ wants to add something about that Curry-Howard taste
17:20:28 <nominolo> Curry-Sweet-Sour ?
17:20:36 <sorear> @uptime
17:20:36 <lambdabot> uptime: 3d 20h 2m 10s, longest uptime: 1m 10d 23h 44m 29s
17:21:11 <nominolo> whoa, lb was killed before it could get 42 days uptime
17:21:29 <nominolo> shame
17:21:38 <nominolo> @losers
17:21:38 <lambdabot> Maximum users seen in #haskell: 382, currently: 345 (90.3%), active: 26 (7.5%)
17:21:38 <glguy> lambdabot was down recently due to scheduled power outage
17:21:59 <nominolo> glguy: i meant the longest uptime: 1m 10d 23h 44m 29s part
17:22:07 <glguy> oh
17:22:15 <diakopter> 1 millenium?
17:22:16 * wli brutally beats lhs2TeX into submission.
17:23:37 <wli> Results at http://holomorphy.com/~wli/Natural.pdf
17:23:43 <monochrom> Don't beat. Do it the FOSS way. Hack it. :)
17:24:08 <dd0s> /j solohackerlink
17:24:36 <dd0s> guys i need some help
17:24:42 <glguy> try /join
17:25:20 <sorear> dd0s: also, channel names must start with a sigil (typically #)
17:25:36 <dd0s> sorear, ty 
17:25:36 <glguy> some clients infer the "oin" and "#"
17:26:18 <glguy> or maybe that is *assumption*
17:27:32 <nominolo> wli: the @ looks not too nice in that code :/
17:28:19 <wli> nominolo: Not sure what I can do about that.
17:28:47 <wli> nominolo: I'd probably need a different font.
17:29:05 <glguy> wli: is join (***) length $ rest   more clear than: length *** length $ rest  -- that's the only thing I'll nitpick, i promise
17:29:21 <glguy> or, (length ws, length ws')
17:29:38 <nominolo> wli: yeah, i don't think it's too bad.  just saying
17:31:02 <dons> why do channels start with a type annotation like #? can't we infer they're a channel ?
17:31:24 <glguy> dons: because privmsgs between channels and users are the same
17:31:25 <bitwize> dons: to set them apart from nicks
17:31:34 <glguy> only differentiated by the #
17:31:43 <DukeDave> Hey has anyone in here ever seen syntax like this in Haskell:
17:31:50 <sorear> dons: also, there are other kinds of channels (+ and &, maeybe others)
17:31:50 <bitwize> and channels that start with & are server-local
17:31:50 <dons> ah right, yes. silly untyped protocols
17:31:51 <DukeDave>  (? (w, sp, _, as, abs, s, l) -> (w, sp, [sp], as, abs, s, l))
17:32:06 <agl> How do I call newByteArray# in IO? It's a primitive and all I can find is that it takes the size (easy) and something to do with a State# (which I'm stuck on)
17:32:11 <dons> shall we write an RFC for Typed-IRC?
17:32:12 <Igloo> dons: That's no sillier than the upper/lowercase first letter of names in Haskell
17:32:14 <dons> System Firc
17:32:16 <glguy> DukeDave: is that ? a \ or lambda maybe?
17:32:25 <LoganCapaldo> quuuuuuestion mark?
17:32:28 <SamB_XP_> dons: how is your client supposed to do type inference on entities and channels?
17:32:33 <dons> Igloo: just that you can make type errors (e.g. pinging a channel)
17:32:34 <wli> nominolo: Refresh and see if you like this font better.
17:32:37 <dons> ?time #haskell
17:32:40 <dons> would be a type error really
17:32:41 <agl> DukeDave: looks like an irrefutable pattern match
17:32:42 <Igloo> dons: That's not a type error
17:33:00 <bitwize> you *can* ping a channel/
17:33:01 <dons> sure it is :) there's a meaningless operation, due to conflating two separate types
17:33:07 <SamB_XP_> Igloo: then why didn't lambdabot tell us the localtime for #haskell?
17:33:11 <agl> DukeDave: or that might have been ~, I forget
17:33:16 <Igloo> No it's not. You get a ping response from everyone on the channel
17:33:19 <glguy> SamB_XP_: because "#haskell" never responded
17:33:20 <sorear> SamB_XP_: Lambdabot bug.
17:33:21 <DukeDave> glguy: I think you're right, should have spotted that
17:33:26 <dons> and you can't have arbitrary userrs join a nick privmsg
17:33:27 <LoganCapaldo> IRC is a vector language that automatically promotes scalars to single element vectors
17:33:33 <LoganCapaldo> ;)
17:33:35 <dons> so there's distinct operations allowed on channels
17:33:37 <nominolo> wli: the privious was better because the font was a ttf font or something. the bitmapped fonts look terrible in pdf
17:33:41 <dons> implying they should have their own type
17:33:42 * DukeDave googles irrefutable pattern match
17:33:45 <nominolo> wli: that is in my viewor
17:34:05 <SamB_XP_> --- SamB :That channel doesn't exist
17:34:10 <SamB_XP_> hmm, you are right
17:34:14 <agl> DukeDave: it was ~
17:34:16 <SamB_XP_> you can't join a nick
17:34:22 <nominolo> anyways, i'm of to bed
17:34:23 <wli> nominolo: Okay, no go for concrete, then.
17:34:32 <DukeDave> Gotcha
17:34:50 <chessguy> what's up with SoC anyway? they should be wrapping up soon
17:34:57 <agl> DukeDave: ? is used for implicit parameters too
17:35:09 <sorear> agl: Not when followed by whitespace
17:35:09 <agl> DukeDave: but that's usually something like ?a, rather than all that
17:35:21 <mm_freak_> dons: in IRC there is really no difference between a channel-PING and an ordinary channel message
17:35:22 <nominolo> chessguy: 1 more month
17:35:28 <chessguy> ah, ok
17:35:32 <mm_freak_> and a channel is not a `room', it's a channel
17:35:38 * chessguy is looking forward to seeing the new parsec
17:35:44 <mm_freak_> i.e. what is sent to it is forwarded to all users attached to that channel
17:35:59 <mm_freak_> in other words, you're pinging all users, not the channel
17:36:05 <nominolo> chessguy: oh, that had a late start
17:36:14 <dons> mm_freak_: right, channels have a different type
17:36:21 <chessguy> @type #haskell
17:36:23 <lambdabot> lexical error at character 'h'
17:36:34 <nominolo> chessguy: but his monter just announced some milestone being reached
17:36:46 <nominolo> chessguy: and xerex has a good track record i think
17:36:51 <chessguy> nominolo, link?
17:36:56 <mm_freak_> dons: yes, but there is nothing wrong with pinging _through_ it
17:37:03 <chessguy> oh yeah, i'm not worried about xerox finishing it
17:37:04 <nominolo> chessguy: it was in #haskell-soc
17:37:32 <wli> I actually kind of like the way the concrete font looked.
17:37:47 <wli> Compatibility is king, though.
17:38:06 <nominolo> wli: try acrobat viewer or sth.
17:38:06 <mm_freak_> dons: IRC doesn't specify any `answer'-system to messages anyway, so you can't even expect exactly one answer, if you ping a user directly
17:38:25 <mm_freak_> you might get multiple answers, or no answer at all, and both are perfectly ok
17:38:27 <wli> nominolo: I was viewing it in such.
17:38:50 <nominolo> wli: and no blurry fonts? hm
17:39:28 <mm_freak_> in that sense, it's the same type:  a list of answers
17:40:15 <SamB_XP_> or you might get banned
17:40:21 <nominolo> wli: i'm using the mac internal viewor
17:40:46 <mm_freak_> samb_xp_: then you're still getting a list of answers; it might be empty though =)
17:40:49 * nominolo types badly
17:41:10 <monochrom> When you get banned, you should turn that into an exception.
17:41:16 <mm_freak_> yes
17:41:43 <mm_freak_> in IRC you couldn't even change your nick without IO
17:42:15 <monochrom> <insert Oleg's discussion on unsafeInterleaveIO, exception, resource leak, generic traversal, generic zipper, delimited continuation, ...>
17:43:36 <wli> Speaking of Oleg, maybe it's a good time to try to figure out how to get primes in type arithmetic.
17:44:58 * wli is itching for a typechecker-certified definition of Z/pZ, p-adics, etc.
17:45:38 <sorear> I don't understand p-adics.
17:45:40 <mm_freak_> wli: i tried Z/pZ
17:45:51 <mm_freak_> it's not straightforward, because of the modulus
17:46:26 <mm_freak_> i still don't understand implicit configurations too well
17:46:45 <wli> mm_freak: Did you get a class expressing the primality of type-level numerals going?
17:47:10 <LoganCapaldo> Might as well face it you're adiced to p
17:47:16 <mm_freak_> oh, you're talking about type arithmetic
17:47:45 <wli> You betcha.
17:48:05 <mm_freak_> btw, what's the point in type arithmetic?
17:48:35 <wli> mm_freak: static typing expressing e.g. array bounds constraints.
17:48:40 <LoganCapaldo> you can like encode the length  of a list in the type
17:48:51 <LoganCapaldo> and that's the only example I've ever heard of
17:48:59 * LoganCapaldo demonstrates his ignorance
17:49:57 <ndm> olliej: fire away :)
17:50:09 <olliej> ndm: hehe
17:50:19 * ndm is down 3
17:50:22 <olliej> ndm: my final thesis is available
17:50:23 <wli> I don't really understand how to do much with type level numerals.
17:50:24 <olliej> ndm: heheh
17:50:35 <ndm> olliej: link? or email it to me
17:50:36 <olliej> ndm: only minor changes over the one i think you got
17:50:41 <olliej> ndm: nerget.com
17:50:49 <mm_freak_> wli: that's my point  i don't see any advantage
17:51:22 <mm_freak_> i'd do things like bounds, lengths, etc. in the value level
17:51:39 <olliej> ndm: i'm hesitant to put up my code because a) it's utter, utter crap, and b) should really be rewritten entirely in haskell
17:51:46 <wli> mm_freak: Well, the typechecker doing bounds and lengths means it's caught at compile-time.
17:52:01 <olliej> ndm: from scratch without ghc being anywhere near it
17:52:15 <wli> mm_freak: In the case of Z/pZ, however, you need type-level numerals to even define the type.
17:52:24 * glguy wants to punch ruby in the face... imagine reading haskell code where the first line of the function is: error "this fails because a.s.d....... whatever, long reason" when some_condition
17:52:27 <ndm> olliej: put it up anyway, release it, there is no reason not to
17:52:29 <wli> mm_freak: Z/nZ more generally.
17:52:38 <olliej> ndm: other than embarrassment?
17:52:44 <LoganCapaldo> mm_freak_, type level bounds check means that a[2] on an array with only 1 element wouldn't even compile
17:52:48 <glguy> how is putting your conditionals at the end "least surprising"
17:53:03 * olliej wonders where the code actually went
17:53:12 <ndm> olliej: if you write a large body of code, you have respect, regardless - if i was a potential employer i'd see a large code base as a good thing
17:53:21 <olliej> ndm: i will endeavour to put it up later tonight
17:53:25 <LoganCapaldo> glguy, it's matz's least surprise and matz. is japanese. Maybe japanese is like rpn
17:53:25 <ndm> everyone can say they wrote a lot of code, not as many people can :)
17:53:37 <ndm> olliej: if you do put up the code (you should!), release it formally on haskell@
17:53:42 <olliej> ndm: at the moment need to try and work out why a crash that can't happen is happening
17:53:51 <olliej> ndm: the horror!
17:53:52 <ndm> olliej: hehe, those things are just life :)
17:54:00 <SamB_XP_> olliej: GHC gets that all the time
17:54:32 <dcoutts> anyone here us MacPorts? (previously DarwinPorts)
17:54:33 <olliej> ndm: the crash is in c++ code, so the impossible is frequently possible
17:54:34 <ndm> i would have thought the GHC people would have been very interested in your thesis, given quite a lot are at MS, and there is F#, so its an interesting arena
17:55:01 * dcoutts is wondering if gtk2hs-0.9.12 is in MacPorts yet, I've heard conflicting reports
17:55:01 <ndm> olliej: ah, its so long since i debugged a memory bounds error i had forgotten how horrid they are
17:55:07 <olliej> ndm: Ms is interested in interop
17:55:12 <sorear> olliej: ooh, this looks fun
17:55:15 <ndm> olliej: very!
17:55:19 <olliej> sorear: ?
17:55:28 <sorear> the paper
17:55:29 <olliej> ndm: my thesis barely touched upon it
17:55:32 <olliej> sorear: ah
17:55:35 <mm_freak_> wli: very good points
17:55:41 <SamB_XP_> olliej: unfortunately it doesn't seem that anything is impossible in C++
17:55:46 <olliej> sorear: it light on formal proofs because they hurt my head :D
17:55:53 <ndm> olliej: you even mention push/enter vs eval/apply, i'm sure they'd be interesting :)
17:56:10 <olliej> SamB_XP_: i currently have a null vtable in what should be a live object :-/
17:56:28 <ndm> is the whole object null?
17:56:44 <SamB> olliej: you should see my attempt at PDP-1 arithmatic!
17:56:50 <SamB> it fails very mysteriously
17:58:10 <chessguy> @unpl main = getArgs >>= putStrLn . show . eval . readExpr . (!! 0)
17:58:10 <lambdabot> main = getArgs >>= \ d -> putStrLn (show (eval (readExpr (d !! 0))))
17:58:40 <benomatic> since it feels a bit newb-ish to ask here, what's the best source for answers to questions like "how do i prevent name conflicts with the prelude as i work through a tutorial?"
17:58:41 <chessguy> nice
17:58:46 <sjanssen> @remember glguy glguy wants to punch ruby in the face...
17:58:47 <lambdabot> Done.
17:58:49 <nornagon> @do main = getArgs >>= putStrLn . show . eval . readExpr . (!! 0)
17:58:49 <lambdabot> main = getArgs >>= putStrLn . show . eval . readExpr . (!! 0) not available
17:58:59 <olliej> Samhehe
17:58:59 <nornagon> oh, there's no un-undo
17:59:02 <olliej> SamB: hehe
17:59:07 <benomatic> in this case, i'm happy to accept answers, but curious if there's a good place for "how do accomplish X" where X isn't monads :)
17:59:19 <SamB> benomatic: there's not a rule against newbishnes
17:59:26 <olliej> ndm: eval/apply is purely there for the reason of speed
17:59:27 <chessguy> @redo main = getArgs >>= putStrLn . show . eval . readExpr . (!! 0)
17:59:27 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 6}) "Parse error"
17:59:39 <olliej> ndm: unfortunately it's also the source of basically all my bugs
17:59:48 <chessguy> @redo main = getArgs >>= \d -> putStrLn . show . eval . readExpr . (!! 0)
17:59:49 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 6}) "Parse error"
17:59:53 <SamB> benomatic: import Prelude hiding (map)
18:00:13 <olliej> ndm: as the arity matching is fundamentally borked
18:00:14 <benomatic> SamB: i know, but i want to avoid making clutter w/ the same old questions, at least when reasonable
18:00:16 <chessguy> @redo main = getArgs >>= putStrLn . show . eval . readExpr . (!! 0)
18:00:16 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 6}) "Parse error"
18:00:19 <chessguy> bah
18:00:51 <nornagon> :t eval
18:00:53 <lambdabot> Not in scope: `eval'
18:00:54 <SamB> or import Prelude qualified as P
18:01:16 <chessguy> @. redo undo do { d <- getArgs; putStrLn (show (eval (readExpr (d !! 0))))}
18:01:16 <lambdabot> do { d <- getArgs; putStrLn (show (eval (readExpr (d !! 0))))}
18:01:25 <chessguy> w00t!
18:01:44 <chessguy> @. type redo undo do { d <- getArgs; putStrLn (show (eval (readExpr (d !! 0))))}
18:01:46 <lambdabot> Not in scope: data constructor `ParseFailed'
18:01:46 <lambdabot>  
18:01:46 <lambdabot> <interactive>:1:13: Not in scope: data constructor `SrcLoc'
18:01:54 <benomatic> SamB: tnx.  is there a simple way to get ghci to not import prelude by default?
18:02:09 <SamB> benomatic: oh, you can :m -Prelude
18:02:11 <benomatic> (so far i haven't found it in ghci docs, but i'm sure it's there...'
18:02:28 <sorear> :set -fno-implicit-prelude might help
18:02:35 <benomatic> sneaky
18:02:46 <SamB> sorear: I don't think that's what he wants
18:03:32 <benomatic> to clarify: after Cale gave me the run down on monads, i decided to go back and do the chap8 exercise from hutton's book (which is on parsers), and defines its own versions of return, failure and others.
18:03:48 <benomatic> these don't work well when prelude is in effect :)
18:04:01 <newsham> whats the conflict?
18:04:13 <benomatic>     Ambiguous occurrence `return'
18:04:22 <newsham> hutton was a little light on monads :(
18:04:35 <benomatic> yeah, but you and Cale did a fine job with the majority of it
18:04:36 <SamB> benny_: try returnP
18:04:44 <sjanssen> benomatic: import Prelude hiding (return, (>>=))
18:04:47 <SamB> or something
18:04:52 <SamB> or, yeah, that
18:05:22 <SamB> I think "returnP, bindP, thenP" was once a popular pattern
18:05:41 <benomatic> yeah, i can do the renaming thing... was just hoping there was a trivial way to avoid prelude loading altogether
18:05:46 <newsham> or you can declare your parser as an instance of monad
18:05:51 <newsham> and define return properly
18:06:05 <sjanssen> benomatic: you can also do 'import Prelude ()'
18:06:19 <SamB> parsec does the renaming game *and* the instance game
18:06:35 <newsham> but hutton does not.
18:06:44 <newsham> "return :: a -> Parser a" 8.3, pg75
18:07:39 <benomatic> it was slightly disturbing to download hutton's code from the book and see how different it is.  one would hope to just type and go...
18:08:30 <newsham> beno:   instance Monad Parser where\n\treturn v = \inp -> [(v, inp)]\n\tp >>= f = \inp -> case ....
18:08:55 <sorear> SamB: The HBC documentation (last updated 1.3-era) describes monadic IO as involving thenIO, thenIO_, returnIO
18:09:08 <newsham> i think putting those two decls (return and >>=) into "instance Monad Parser" should do the trick
18:09:13 <LoganCapaldo> heh
18:09:16 <LoganCapaldo> thenIO_
18:09:33 <newsham> ifIO_
18:09:37 <LoganCapaldo> I love that underscore
18:09:44 <LoganCapaldo> mapIO_
18:09:45 <SamB> what is the type of thenIO_?
18:09:53 <sorear> IO a -> IO b -> IO b
18:09:55 <LoganCapaldo> @type (>>)
18:09:57 <sorear> it's modern >>
18:09:57 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
18:10:15 <SamB> I believe GHC *still* has some of this pattern in it's source
18:10:23 <sorear> main = putStrLn "Enter a line:" `thenIO_`
18:10:34 <sorear>        getLine           `thenIO` \line ->
18:10:43 <SamB> (nyhc still has some kind of crazy not-quite-state-monad!)
18:10:44 <sorear>         putStrLn line
18:11:12 <SamB> probably with something other than "IO" at the end of the names
18:11:13 <sorear> SamB: Happy has an error-not-quite-monad!
18:11:16 <newsham> ?let thenIO = (>>=)
18:11:17 <lambdabot> <local>:8:9:     Ambiguous type variable `m' in the constraint:       `Monad ...
18:11:24 <sorear> MR--
18:11:43 <SamB> sorear: is that why it lets you speciy the bind and return functions ;-)
18:11:51 <sorear> ?let {-# LANGUAGE NoMonomorphismRestriction #-}
18:11:55 <lambdabot> Defined.
18:12:05 <LoganCapaldo> ?let thenIO :: (Monad m) => m a -> m b -> m b = (>>)
18:12:05 <lambdabot>  Parse error
18:12:11 <sjanssen> oh, hmm, that works?
18:12:16 <nornagon> sneaky.
18:12:21 <sjanssen> @let thenIO = (>>=)
18:12:22 <lambdabot> <local>:9:9:     Ambiguous type variable `m' in the constraint:       `Monad ...
18:12:25 <sorear> sjanssen: No, it's only legal at the beginning of the file :)
18:12:32 <sjanssen> oh, good point
18:12:36 <SamB> ?let thenIO_ :: (Monad m) => m a -> m b -> m b; thenIO_ = (>>=)
18:12:37 <lambdabot> Couldn't match expected type `m' (a rigid variable)
18:13:04 <LoganCapaldo> ?let thenIO = foo where (foo :: (Monad m) => m a -> m b -> m b) = (>>)
18:13:04 <lambdabot>  Parse error in pattern
18:13:12 <benomatic> newsham: the instance command is a fine example of the sort of thing i'd hope to find in a reference someplace, instead of bugging ppl here :)
18:13:17 <nornagon> @let thenIO_ = (>>=) :: IO a -> (a -> IO b) -> IO b
18:13:21 <lambdabot> Defined.
18:13:24 <newsham> beno: its in a later chapter.
18:13:32 <LoganCapaldo> nornagon++
18:13:39 <benomatic> bah!
18:13:44 <newsham> see 10.6 on pg111
18:13:47 <nornagon> @let thenIO = (>>) :: IO a -> IO b -> IO b
18:13:51 <lambdabot> Defined.
18:14:08 <LoganCapaldo> wait
18:14:15 <LoganCapaldo> that's bckwards aint it?
18:14:20 <newsham> beno: see, they were trying to introduce the concept before they introduced type classes (which is reasonable)
18:14:23 <LoganCapaldo> thenIO_ = (>>)
18:14:28 <nornagon> oh, oops.
18:14:30 <LoganCapaldo> thenIO = (>>=)
18:14:33 <nornagon> @let thenIO_ = (>>) :: IO a -> IO b -> IO b
18:14:34 <lambdabot> <local>:11:0:     Multiple declarations of `L.thenIO_'     Declared at: <loca...
18:14:36 <newsham> but it woulda been better if their code mentioned "import prelude hiding ((>>=), return)"
18:14:40 <nornagon> @forget thenIO_
18:14:41 <lambdabot> Unknown command, try @list
18:14:46 <nornagon> @unlet thenIO_
18:14:46 <lambdabot>  Parse error
18:14:53 <LoganCapaldo> @undefine
18:14:54 <newsham> beno: dont worry, dons book will fix :)
18:14:55 <lambdabot> Undefined.
18:15:07 <nornagon> @let thenIO_ = (>>) :: IO a -> IO b -> IO b
18:15:09 <lambdabot> Defined.
18:15:18 <nornagon> @let thenIO = (>>=) :: IO a -> (a -> IO b) -> IO b
18:15:20 <lambdabot> Defined.
18:16:15 <newsham> beno: in fact, see the top of pag 114 (10.6)
18:16:34 <benomatic> newsham: agreed.  sample code ought to just work.
18:18:03 <dons> dcoutts: around?
18:18:13 <dcoutts> hia dons
18:18:32 <dons> hey, have you booked your hotel yet of ICFP?
18:18:36 <dons> if so, which one?
18:19:08 <dcoutts> no, I really should do soon
18:19:47 <bitwize> GNU/Vince!
18:20:25 <dons> dcoutts: galois is booking stuff in the next few days, I'll see if I can find out the hotel et al
18:20:37 <dcoutts> ok, thanks
18:20:39 <dons> dcoutts: looks like i'll be there from 29..8th
18:20:43 <dcoutts> cool
18:20:58 <sjanssen> > [29 .. 8] -- not very long
18:21:00 <lambdabot>  []
18:21:03 <dons> :)
18:21:07 <dcoutts> I intend to do the hackathon too
18:21:11 <newsham> sjanssen: wrong field
18:21:13 <bitwize> [8..29]
18:21:26 <dons> `do the hackathon'?
18:21:29 <bitwize> > 2+3
18:21:31 <lambdabot>  5
18:21:36 <bitwize> > [8..29]
18:21:37 <lambdabot>  [8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29]
18:21:56 <newsham> > map (`mod` 31) [29..8+31]
18:21:58 <lambdabot>  [29,30,0,1,2,3,4,5,6,7,8]
18:22:02 <newsham> oopz!
18:22:45 <dcoutts> dons: attend :-)
18:22:50 <dons> good!
18:22:57 <bitwize> map (`mod` 31 . $ `+` 1) [28..7+31]
18:23:12 <bitwize> > map (`mod` 31 . $ `+` 1) [28..7+31]
18:23:12 <lambdabot>  Parse error
18:23:14 <newsham> > map ((+1).(`mod` 31).(-1)) [29..8+31]
18:23:14 <lambdabot>   add an instance declaration for (Num (a -> b))
18:23:22 <ndm> i think i'm going to be [27..8]
18:23:28 <ndm> IFL beforehand#
18:23:32 <newsham> > map ((+1).(`mod` 31).(subtract 1)) [29..8+31]
18:23:33 <lambdabot>  [29,30,31,1,2,3,4,5,6,7,8]
18:24:43 <dons> ndm, ok. we should put arrival dates on the page, like last time
18:25:16 <dons> dcoutts: also, we should invite all the SoC students
18:25:18 <dons> i forgot to do that
18:25:26 <dcoutts> dons: yes we should
18:25:42 <dons> i'll forward that today then
18:26:01 <dcoutts> dons: I wonder if any of them would like to go to HW too? perhaps we can get them cheap rates
18:26:46 <dons> hmm, that's interesting. they'd certainly get student rates
18:26:49 <dcoutts> dons: I was also thinking, contributions to transport or registration costs might be an appropriate thing for the haskell.org soc budget
18:26:54 <dons> yeah
18:27:09 <dcoutts> we could bring that up on the soc mailing list
18:27:11 <dons> ok, we'd need to move fast on this then. talk with malcolm and isaac.
18:27:13 <dons> yes
18:27:17 <dcoutts> @arr
18:27:17 <lambdabot> Aye Aye Cap'n
18:27:33 <ndm> malcolm is away another week
18:34:51 <newsham> ?quote monochrom
18:34:52 <lambdabot> monochrom says: people  haskellers = 
18:35:24 <dmwit> On my screen, that looks like:
18:35:40 <dmwit> people ^a0088(c) haskellers = ^a00880085
18:35:42 <dmwit> =(
18:35:46 <newsham> people a-hat (c) = a-hat
18:36:24 <dmwit> ?quote monochrom
18:36:25 <lambdabot> monochrom says: recursive directory search is an alpha-beta with boring values of alpha and beta.
18:37:12 <sciolizer> Should SYB bugs get reported to GHC?
18:37:25 <sciolizer> (hello, btw)
18:37:32 <newsham> thankfully we have directory trees and not directory graphs or dags
18:37:37 <Igloo> What sort of SYB bug?
18:37:57 <sciolizer> Igloo: one line fix - a type is more restrictive than it needs to be
18:38:25 <sciolizer> specifically "synthesize" in Data.Generics.Schemes
18:38:51 <Igloo> Yeah, the GHC bug tracker, component "libraries/base", sounds like the best place for it
18:38:58 <sciolizer> ok, thanks
18:39:34 <dmwit> newsham: How about a "tagged" file system?
18:39:47 <wli> newsham: That reminds me, libs for things like R^* trees, X-trees, etc. are needed.
18:41:39 <newsham> i dont know the r^* and x- trees
18:41:52 <newsham> but it sounds impressive
18:44:03 <chessguy> http://en.wikipedia.org/wiki/R*_tree
18:45:30 <dmwit> WASH makes very big executables.
18:46:27 <dmwit> <100LOC and a 2MB executable.
18:47:05 <sorear> GHC makes very big executables.
18:47:06 <newsham> is wash the one that turns a function into multiple forms?  does it use continuations?
18:47:19 <chessguy> @where wash
18:47:19 <lambdabot> http://www.informatik.uni-freiburg.de/~thiemann/haskell/WASH/
18:47:25 <sorear> Especially if you don't use -split-objs when building the libraries
18:47:36 <sorear> dmwit: Did you build WASH using Cabal?
18:47:59 <sorear> cabal handles -split-objs automagically... so you should only be linking the code you're using
18:48:41 <dmwit> Mmm, I should try building it with cabal.
18:48:47 <dmwit> I think I just did "make".
18:49:07 <reffie> % ghc --make rephttpd-0.4.hs -o rephttpd -package parsec  [18:46]Linking rephttpd ...
18:49:11 <reffie> /usr/bin/ld: cannot find -lHSmtl
18:49:14 <reffie> but ghci works fine
18:49:17 <reffie> what does this mean?
18:49:22 <dmwit> No, make calls ./Setup.lhs, so I built it with cabal.
18:50:12 <sorear> reffie: It means you didn't install the compilation libraries.
18:50:22 <reffie> god hates me.
18:50:31 <reffie> i guess i'll just give up with ghc
18:50:38 <dmwit> I'm sure he's at most indifferent.
18:51:01 <reffie> fwiw it says the same thing about -lHSparsec  unless i specify -package parsec
18:51:28 <sorear> reffie: does -package mtl fix it?
18:51:34 <sorear> that's really weird.
18:51:51 <reffie> nope
18:52:13 <sorear> @bug
18:52:13 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
19:01:13 <reffie> i guess i'll try another approach
19:05:18 <reffie> is there a video of spj's talk at oscon?
19:05:26 <Excedrin> yes
19:05:31 <reffie> got a url? :)
19:05:32 <sorear> reffie: no, really, you're not the first person to have this problem.
19:06:15 <Excedrin> http://blip.tv/file/317758
19:06:17 <lambdabot> Title: OSCON 2007 - Simon Peyton-Jones
19:06:18 <sorear> @wiki Video tutorials
19:06:18 <lambdabot> http://www.haskell.org/haskellwiki/Video_tutorials
19:08:24 <binary42_> I think you mean http://haskell.org/haskellwiki/Video_presentations
19:08:25 <lambdabot> Title: Video presentations - HaskellWiki
19:09:40 <dons> see the /topic :)
19:09:47 <gnuvince_> Will the video of "A Taste Of Python" be available?
19:10:02 <reffie> dons doh
19:10:03 <gnuvince_> s/Python/Haskell
19:10:04 <sorear> gnuvince_: Not here! :)
19:10:04 <gnuvince_> Sorry
19:10:13 <dons> :) hah
19:10:18 <marcotmarcot> Good evening.
19:10:32 <dons> gnuvince_: didn't you read about faster, safer, shorter pseudo-Python? ;)
19:10:36 <dons> hey marcot
19:10:53 <gnuvince_> dons: Of course I did :)
19:11:27 <TSC> @hoogle [a] -> Integer -> a
19:11:28 <lambdabot> No matches, try a more general search
19:11:33 <gnuvince_> @hoogle ($$$)
19:11:34 <lambdabot> Did you mean: ($$$)
19:11:34 <lambdabot> Prelude.undefined :: a
19:11:34 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
19:11:36 <shachaf> gnuvince_: You have seen the slides, though, right?
19:11:37 <dons> :t (!!)
19:11:39 <lambdabot> forall a. [a] -> Int -> a
19:11:40 <sorear> TSC: NOOO!
19:11:47 <gnuvince_> shachaf: of course.
19:11:50 <sorear> TSC: genericIndex is partial!
19:11:50 <dons> :t genericIndex
19:11:52 <lambdabot> forall b a. (Integral a) => [b] -> a -> b
19:12:04 <TSC> Pff
19:12:19 <TSC> Thanks dons (:
19:12:34 <LoganCapaldo> that must be a pretty long list
19:13:00 <ddarius> LoganCapaldo: Perhaps it's backed by external store.
19:13:07 <TSC> Not really; I use Integers instead of Ints unless I have some reason not to
19:13:09 <sorear> Lists in Haskell can be VERY long.
19:13:26 <wli> I think it'd be nice if a lot of things that raise exceptions you have to catch in the IO monad returned Maybe or otherwise failure monads.
19:13:27 <ddarius> > repeat 'a'
19:13:29 <lambdabot>  "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
19:14:18 <shachaf> gnuvince_: Which part of the slides did you find unclear (if any)?
19:14:25 <wli> (!!), head, tail, etc. (!), etc.
19:14:52 <shachaf> wli: What's the point?
19:15:05 <sorear> > last [1::Int .. 1000000000] --Process 12 GB of data, using less than that much core
19:15:09 <lambdabot> Terminated
19:15:09 <TSC> wli: could you write a function that converts the exception-throwing function into a Maybe function?
19:15:15 <LoganCapaldo> head and tail are kind of silly tomake Maybe
19:15:22 <shachaf> wli: If you return Maybe, you have to pattern-match against Just/Nothing, and otherwise you pattern match against (:)/[].
19:15:24 <reffie> hm, looks like the video in the topic is not the "a taste of haskell" talk :(
19:15:24 <wli> shachaf: More safety.
19:15:44 <LoganCapaldo> case head foo of Just h -> ... ; Nothing -> crud, now what? I guess error ...
19:15:49 <ddarius> reffie: That one will not be available until sometime next week at earliest.
19:15:57 <reffie> ddarius oh cool, thanks
19:16:23 <wli> LoganCapaldo: maybe default actualFunction (head list)
19:16:39 <ddarius> listToMaybe!
19:16:41 <LoganCapaldo> wli: foldr
19:16:41 <sorear> LoganCapaldo: that's why we use dependent types!  tail : [t:Type][l:list t]nonNull l -> t
19:16:45 <sorear> :)
19:17:22 <shachaf> wli: So write an equivalent function for lists.
19:17:28 <shachaf> @src listToMaybe
19:17:28 <lambdabot> listToMaybe []        =  Nothing
19:17:28 <lambdabot> listToMaybe (a:_)     =  Just a
19:17:39 <shachaf> In this case this is your safeHead anyway, like ddarius said.
19:18:12 <ddarius> I agree with LoganCapaldo about head/tail at least.  You don't gain anything by making them return Maybe.
19:18:27 <shachaf> ddarius: I guess (!!) is different.
19:18:45 <wli> Maybe it's just me, but I don't like putting incomplete pattern matches front and center.
19:19:05 <shachaf> wli: What do you mean?
19:19:16 <sjanssen> ddarius: well, you can use existing (total) methods to take the Maybe apart
19:19:26 <sjanssen> maybe, instance Monad Maybe, etc.
19:19:36 <ddarius> shachaf: That would not be just a pattern match and would require a bit more work to implement (but then it should very rarely be used...)
19:19:51 <newsham> here's a question from beno:  http://hpaste.org/2002   this gives an error and I think its because do-notation is used for sat when Parser is not defined as a Monad
19:19:54 <newsham> is that right?
19:19:55 <ddarius> sjanssen: Yes, but head and tail shouldn't be those functions.
19:20:11 <newsham> if so, whats the minimal change to declare Parser as a Monad?
19:20:46 <ddarius> newsham: You must make the Parser type a newtype.
19:21:00 <wli> (!!) = (. zip [0..]) . lookup
19:21:48 <dmwit> Looks backwards.
19:21:54 <dmwit> :t (. zip [0..]) . lookup
19:21:56 <lambdabot> forall b a. (Enum a, Num a) => a -> [b] -> Maybe b
19:22:05 <ddarius> :t flip lookup . zip [0..]
19:22:07 <lambdabot> forall a b. (Num a, Enum a) => [b] -> a -> Maybe b
19:22:23 <wli> Oh, yeah.
19:22:38 <shachaf> newsham: This is "Programming in Haskell"?
19:22:45 <newsham> yup
19:22:57 <shachaf> newsham: I thought I recognized it. :-)
19:23:03 <shachaf> newsham: You have to use a newtype.
19:23:19 <shachaf> newsham: There's a working version on the website, though.
19:23:29 <newsham> url?
19:23:45 <shachaf> http://www.cs.nott.ac.uk/~gmh/Parsing.lhs
19:24:09 <shachaf> newsham: It's a bit more complicated because you have to wrap and unwrap the P.
19:25:04 <newsham> yup.
19:25:06 <newsham> thanks
19:25:13 <shachaf> newsham: But you can't use type aliases as monads.
19:25:24 <shachaf> newsham: (Or instances in general.)
19:28:25 <newsham> or not use do-notation... closer to the book form
19:28:37 <shachaf> It's nice how they use mzero instead of fail _.
19:28:44 <shachaf> newsham: That's also true.
19:29:29 * wli has taken quite a liking to MonadError
19:42:03 <chessguy> has anyone pulled together all the code from the "Write yourself a scheme in 24 hours" wikibook?
19:42:22 <newsham> surely 48hrs
19:42:27 <shachaf> chessguy: It's a wikibook? (Also, 48)
19:42:31 <chessguy> err, yeah, 48
19:42:32 <marcotmarcot> dons: I'm looking at http://www.cse.unsw.edu.au/~dons/code/typeof/ , but README file is not listed.  But it's there: http://www.cse.unsw.edu.au/~dons/code/typeof/README
19:42:32 <lambdabot> Title: Index of /~dons/code/typeof
19:42:33 * wli is planning to do a march through the book at some point in the near future.
19:42:50 <chessguy> shachaf, yeah: http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
19:43:12 <dons> marcotmarcot: oh, silly unsw webserver
19:43:16 <dons> marcotmarcot: darcs get the repo
19:43:22 <dons> or grab it from hackage.haskell.org
19:43:23 <newsham> seems to have src: http://halogen.note.amherst.edu/~jdtang/scheme_in_48/scheme_in_48.tgz
19:43:25 <lambdabot> http://tinyurl.com/yo9s8x
19:43:35 <newsham> "Download in .tar.gz format"
19:43:49 <chylli> are there keys to excercises of 'Write Yourself a Scheme in 48 hours' ??
19:43:57 <marcotmarcot> dons: yes, I noticed that darcs get worked also.  Is this an apache configuration?
19:44:29 <dons> it woudl be something silly with my school's web server set up, yep
19:44:40 <marcotmarcot> hum..
19:45:09 <chessguy> newsham, where'd you find that?
19:45:23 <newsham> top of http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/overview.html
19:45:24 <lambdabot> Title: Write Yourself a Scheme in 48 hours, http://tinyurl.com/l986o
19:45:35 <Pseudonym> ?quote brain
19:45:35 <lambdabot> adept says: I think I need cobrain to understand coeffects
19:45:37 <Pseudonym> ?quote brain
19:45:38 <lambdabot> Pseudonym says: The Scheme programming language is optimised for writing small brain-dead tutorial compilers for.
19:45:39 <dons> ?brain
19:45:39 <lambdabot> Wuh, I think so, Brain, but isn't Regis Philbin already married?
19:45:55 <newsham> are you contemplating what I'm contemplating?
19:46:07 <SamB> ?brain
19:46:07 <lambdabot> Umm, I think so, Brain, but what if the chicken won't wear the nylons?
19:46:16 <SamB> @are you pondering what I'm pondering?
19:46:16 <lambdabot> Aye Aye Cap'n
19:46:27 * SamB thinks that should be the real command.
19:46:45 <newsham> ?brain are you thinking what i'm thinking?
19:46:45 <lambdabot> Are you pondering what I'm pondering?
19:46:57 <SamB> ?brain tutu
19:46:58 <lambdabot> There's only one ride that interests me - the incredible thrill ride of taking over the world!
19:47:06 <SamB> aww.
19:47:18 <MP0> ?brain
19:47:18 <lambdabot> Now, Pinky, if by any chance you are captured during this mission,
19:47:19 <lambdabot> remember you are Gunther Heindriksen from Appenzell. You moved to Grindelwald
19:47:19 <lambdabot> to drive the cog train to Murren.  Can you repeat that?
19:47:24 <newsham> ?b52s
19:47:24 <lambdabot> Hot pants explosion at the factory!
19:47:47 <chessguy> @help b52s
19:47:47 <lambdabot> b52s. Anyone noticed the b52s sound a lot like zippy?
19:47:48 <MP0> ?brain cheese
19:47:49 <lambdabot> I think so, Brain, but culottes have a tendency to ride up so.
19:48:05 <chessguy> @. vixen brain
19:48:06 <lambdabot> are you being sincere?
19:48:23 <newsham> ?. brain elite
19:48:23 <lambdabot> If I could reach you I would hurt you.
19:48:29 <newsham> ?. elite brain
19:48:29 <lambdabot> NARF!
19:48:33 <chessguy> haha
19:48:40 <chessguy> @. elite brain
19:48:40 <lambdabot> I Thinx zO, BRAiN, bu+ i D0n'+ ThiNx KAYe 8allard'$ iN thE UnIoN.
19:48:41 <newsham> hrmph
19:48:48 <newsham> ?. elite yarr
19:48:48 <lambdabot> dRInk up, /\/\e 'E4R7Ies
19:48:58 <newsham> pirates like the leet speak
19:49:10 <newsham> naturally
19:49:13 <chessguy> hm, this source isn't packaged up very nicely
19:49:24 <MP0> Napoleon Bonaparte tried to conquer all he could see, but when he tried to conquer England too, he was beaten by Wellington at Waterloo
19:49:27 <MP0> ?brain
19:49:27 <lambdabot> I think so, Brain, but a codpiece made from a real fish would get smelly after a while, wouldn?t it?
19:49:29 <dmwit> ?vixen heya, you're back!
19:49:29 <lambdabot> you are soooo interesting
19:49:41 <newsham> ?farber
19:49:42 <lambdabot> Unknown command, try @list
19:49:46 <newsham> :(
19:49:47 <chessguy> @vixen hey, wanna go on a date?
19:49:48 <lambdabot> i was finished
19:49:52 <chessguy> heh
19:50:12 <newsham> http://www.cs.arizona.edu/icon/oddsends/farber.htm
19:50:13 <lambdabot> Title: Farberisms
19:51:53 <newsham> Don't look a charlie horse in the mouth.
19:52:45 <chylli> are there the answer of exercises of 'Write Yourself a Scheme in 48 Hours' ?
20:04:13 <stevan> hello. i can't figure out how to get from an int, say 123, to a list where each digit is an element, like this [1,2,3]. could someone give me a clue? thanks.
20:04:33 <wli> stevan: Sure.
20:04:35 <Spark> try dividing by 10
20:05:19 <sorear> Look at `div` and `mod`.
20:05:23 <wli> > let { getDigit n = let (q, r) = n `quotRem` 10 in if (q,r) == (0,0) then Nothing else Just (r, q) ; unfoldl f x = case f x of { Nothing -> [] ; Just (u, v) -> unfoldl f v ++ [u] } } in unfoldl getDigit 123
20:05:24 <sorear> > 123 `div` 10
20:05:24 <lambdabot>  [1,2,3]
20:05:25 <lambdabot>  12
20:05:28 <sorear> > 123 `mod` 10
20:05:30 <lambdabot>  3
20:05:41 <olliej> sorear: *sigh* have now found my completely copyright-less sources
20:05:57 <sorear> olliej: Context lost.
20:06:01 <bitwize> wow, wli.
20:06:06 <olliej> sorear: haskell.net
20:06:16 <bitwize> I can't write Haskell (or anything) off the top of my head like that.
20:06:30 <wli> bitwize: I've done it enough times.
20:06:40 <shachaf> > map digitToInt (show 123) -- Cheating, I know.
20:06:41 <lambdabot>  [1,2,3]
20:06:46 <chessguy_> @paste
20:06:47 <lambdabot> Haskell pastebin: http://hpaste.org/new
20:07:33 <hpaste>  chessguy pasted "Bug in the "Write yourself a Scheme" code?" at http://hpaste.org/2003
20:07:43 <sorear> > let { getDigit n = if n <= 10 then [n] else getDigit (div n 10) ++ [mod n 10] } in getDigit 123 -- much shorter using explicit recursion
20:07:45 <lambdabot>  [1,2,3]
20:07:57 <chessguy> the two DottedList cases seem to overlap?
20:08:06 <SamB> > let digits n = map (`mod` 10) (takeWhile (/=0) (iterate (`div` 10) n)) in digits 123
20:08:08 <lambdabot>  [3,2,1]
20:08:18 <SamB> > let digits n = reverse (map (`mod` 10) (takeWhile (/=0) (iterate (`div` 10) n)) in digits 123)
20:08:18 <lambdabot>  Parse error
20:08:19 <mrd> chessguy: not really
20:08:23 <newsham> ?let m `divides` n = n % m == 0
20:08:24 <SamB> > let digits n = reverse (map (`mod` 10) (takeWhile (/=0) (iterate (`div` 10) n))) in digits 123
20:08:26 <mrd> chessguy: the second one can sub _ for xs
20:08:27 <lambdabot> Defined.
20:08:28 <lambdabot>  [1,2,3]
20:08:29 <wli> sorear: I'm used to having unfoldl around.
20:08:48 <newsham> > nubBy divides [2..]
20:08:49 <lambdabot>  [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
20:08:54 <chessguy> mrd, i'm not sure what you mean
20:09:03 <SamB> > nubBy (flip divides) [2..]
20:09:04 <newsham> oopz
20:09:04 <lambdabot>  [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
20:09:06 <wli> sorear: I've been needing unfoldAcc too.
20:09:17 <mrd> chessguy: well i'm assuming by dotted list they mean (a b c d . e) or something
20:09:29 <mrd> chessguy: and are representing that as DottedList [a,b,c,d] e
20:09:30 <chessguy> mrd, the second one matches if there's a single element in the list, righ?
20:09:31 <wli> newsham: Where is divides?
20:09:34 <SamB> @scheck divides
20:09:35 <lambdabot> Add a type signature
20:09:35 <newsham> ?let m `divides` n = n `mod` m == 0
20:09:36 <lambdabot> <local>:3:0:     Warning: Pattern match(es) are overlapped              In th...
20:09:36 <chessguy> mrd, yes
20:09:40 <shachaf> 23:07 < newsham> ?let m `divides` n = n % m == 0
20:09:49 <newsham> oopz
20:09:56 <SamB> @scheck (divides :: I -> I -> Bool)
20:09:57 <lambdabot> Exception: Ratio.%: zero denominator
20:09:58 <monochrom> > case [True] of {_:xs -> "yes"; [xs] -> "no" }
20:09:59 <lambdabot>      Warning: Pattern match(es) are overlapped
20:09:59 <lambdabot>              In a case alterna...
20:10:15 <sorear> ?unlet
20:10:16 <lambdabot> Defined.
20:10:20 <newsham> ?let m `divs` n = n `mod` m == 0
20:10:21 <sorear> ?undefine
20:10:22 <lambdabot> Defined.
20:10:23 <lambdabot> Undefined.
20:10:37 <chessguy> mrd, but if there's exactly one item in the list, the first pattern match should trigger too, right?
20:10:41 <mrd> hmm maybe
20:10:55 <bitwize> > \ [] -> "Yes"; _:xs -> "No"
20:10:55 <lambdabot>  Parse error
20:10:56 <mrd> it does look like they are treating the haskell list as if it were like a dotted-list
20:10:57 <sorear> > nubBy(((>1).).gcd)[2..]
20:10:57 <chessguy> i think the second one should say _ instead of [xs]
20:10:59 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
20:11:08 <mrd> yea that's what i was thinking too
20:11:13 <chessguy> or []
20:11:21 <wli> @unpl (((>1).).gcd)
20:11:21 <lambdabot> (\ e h -> (gcd e h) > 1)
20:11:26 <newsham> ?src gcd
20:11:26 <lambdabot> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
20:11:26 <lambdabot> gcd x y = gcd' (abs x) (abs y)
20:11:26 <lambdabot>    where gcd' a 0  =  a
20:11:26 <lambdabot>          gcd' a b  =  gcd' b (a `rem` b)
20:11:42 <newsham> looks pretty long to me
20:11:43 <bos> @hoogle (&)
20:11:44 <lambdabot> Did you mean: (&)
20:11:44 <lambdabot> Prelude.undefined :: a
20:11:44 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
20:12:16 <bos> hmm. so much for thinking that maybe (&) was used somewhere, so (.&.) had to be pressed into service instead.
20:12:24 <bitwize> > (\x -> case x of {[] -> True; _:xs -> False}) [1]
20:12:26 <lambdabot>  False
20:12:31 <shachaf> bos: (|) is used.
20:12:37 <shachaf> s/\(\)//
20:12:48 <shachaf> s/\(\|\)/|/
20:12:51 <newsham> ?type null
20:12:53 <lambdabot> forall a. [a] -> Bool
20:12:57 <newsham> ?src null
20:12:58 <lambdabot> null []     = True
20:12:58 <lambdabot> null (_:_)  = False
20:13:10 <dons> ?hoogle &
20:13:10 <lambdabot> Data.Graph.Inductive.Graph.(&) :: DynGraph gr => Context a b -> gr a b -> gr a b
20:13:10 <lambdabot> Prelude.(&&) :: Bool -> Bool -> Bool
20:13:10 <lambdabot> Control.Arrow.(&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
20:13:24 <dons> ?hoogle+
20:13:24 <lambdabot> Data.Bits.(.&.) :: Bits a => a -> a -> a
20:13:53 <bos> heh.
20:14:27 <newsham> > 0x3 .|. 0x51
20:14:27 <lambdabot>  Add a type signature
20:14:39 <sorear> ?hoogle++
20:14:46 <dons> only 4 hits
20:14:46 <sorear> ?karma ?hoogle
20:14:47 <lambdabot> ?hoogle has a karma of 0
20:14:47 <newsham> > 0x3 .|. 0x51 :: Int
20:14:48 <lambdabot>  83
20:14:51 <sorear>  ?hoogle++
20:14:54 <sorear> ?karma ?hoogle
20:14:54 <lambdabot> ?hoogle has a karma of 1
20:15:31 <bitwize> ?hoogle divides
20:15:31 <lambdabot> No matches found
20:15:45 <dons> @seen sjanssen
20:15:45 <lambdabot> I saw sjanssen leaving #haskell, #xmonad and #gentoo-haskell 29m 2s ago, and .
20:15:45 <newsham> ?let m `divides` n = n `mod` m == 0
20:15:47 <lambdabot> Defined.
20:15:51 <newsham> > nubBy divides [2..]
20:15:53 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
20:17:55 <bitwize> > let (divides m n) = (mod n m) == 0 in (foldl (+) 0 (take (divides 3) [1..999]))
20:17:56 <lambdabot>  Parse error in pattern
20:18:28 <bitwize> > let divides m n = ((mod n m) == 0) in (foldl (+) 0 (take (divides
20:18:28 <bitwize> 	  3) [1..999]))
20:18:28 <lambdabot>  Parse error
20:18:39 <bitwize> ?hoogle take
20:18:39 <lambdabot> Prelude.take :: Int -> [a] -> [a]
20:18:39 <lambdabot> Prelude.takeWhile :: (a -> Bool) -> [a] -> [a]
20:18:39 <lambdabot> Data.PackedString.takePS :: Int -> PackedString -> PackedString
20:18:52 <wli> That reminds me, egcd is missing.
20:18:55 <bitwize> ?hoogle filter
20:18:55 <lambdabot> Prelude.filter :: (a -> Bool) -> [a] -> [a]
20:18:55 <lambdabot> Data.IntMap.filter :: (a -> Bool) -> IntMap a -> IntMap a
20:18:55 <lambdabot> Data.IntSet.filter :: (Int -> Bool) -> IntSet -> IntSet
20:19:16 <shachaf> bitwize: You know you can use @type if you want to see the type of one function.
20:19:25 <bitwize> > let divides m n = ((mod n m) == 0) in (foldl (+) 0 (filter (divides 3) [1..999]))
20:19:27 <lambdabot>  166833
20:19:37 <shachaf> bitwize: (Also, you can talk to lambdabot in a /query.)
20:19:46 <bitwize> ah, thank you.
20:21:14 <newsham> > sum $ filter (3 `divides`) [1..999]
20:21:15 <lambdabot>  166833
20:22:28 <shachaf> bitwize: You'd want foldl' here, probably (or sum, like newsham used).
20:22:35 <magnus__> Is alex/happy better than Parsec or should I stick with Parsec?
20:22:57 <bitwize> ?hoogle foldl'
20:22:57 <lambdabot> Data.List.foldl' :: (a -> b -> a) -> a -> [b] -> a
20:23:02 <ddarius> magnus__: They are different.  It depends on what metric you are using.
20:23:08 <newsham> magnus: I personally prefer a formal grammar to an ad hoc program.
20:23:14 <shachaf> bitwize: It's a strict version of foldl.
20:23:34 <magnus__> I guess I better check out alex/happy then to make up my own mind
20:23:39 <bitwize> oh.
20:24:11 <newsham> there are mistakes you can make while translating a grammar to a parsec parser.
20:24:29 <newsham> having a program generate your parser directly from a grammar removes that chance of making a mistake
20:25:40 <bitwize> shachaf: Is GHC smart enough to optimize foldl to O(1) memory consumption?
20:25:40 <bos> @hoogle (a -> b) -> (a,a) -> (b,b)
20:25:40 <lambdabot> Data.Graph.Inductive.Query.Monad.(><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
20:25:42 <newsham> (that said, parsec is pretty powerful)
20:25:53 <bitwize> with a strict operator?
20:26:05 <shachaf> bitwize: I don't think it normally does it.
20:26:11 <shachaf> bitwize: Though I'm not sure.
20:26:39 <ddarius> With optimizations enabled, it will usually get i.t
20:26:43 <shachaf> > join (&&&) (+1) (1,2)
20:26:44 <lambdabot>   add an instance declaration for (Num (t, t1))
20:27:13 <ddarius> > join (***) (+1) (1,3)
20:27:14 <lambdabot>  (2,4)
20:27:23 <shachaf> > join (***) (+1) (1,2)
20:27:24 <lambdabot>  (2,3)
20:27:32 <bitwize> ?hoogle sum
20:27:33 <lambdabot> Prelude.sum :: Num a => [a] -> a
20:27:33 <lambdabot> Monad.msum :: MonadPlus a => [a b] -> a b
20:27:33 <lambdabot> Control.Monad.msum :: MonadPlus m => [m a] -> m a
20:27:39 <shachaf> @src sum
20:27:39 <lambdabot> sum = foldl (+) 0
20:27:50 <shachaf> That's not how it's actually implemented, I htink.
20:28:41 <shachaf> Hmm, it seems to be.
20:29:07 <mm_freak_> it is
20:29:07 <ddarius> foldl and foldl' are different functions
20:29:10 <mm_freak_> > sum [1..1000000]
20:29:10 <mm_freak_> *** Exception: stack overflow
20:29:13 <lambdabot>  500000500000
20:29:26 <shachaf> Right, never mind.
20:30:57 <newsham> > fix (\rec n -> if n == 0 then 1 else n * rec (n - 1)) 20 `mod` 100 == 0
20:30:58 <lambdabot>  True
20:31:53 <shachaf> > product [1..20] `mod` 100 == 0
20:31:54 <lambdabot>  True
20:32:01 <bitwize> @src foldl'
20:32:01 <lambdabot> foldl' f a []     = a
20:32:01 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
20:32:33 <newsham> > product [1..20] `mod` 1000 == 0
20:32:34 <lambdabot>  True
20:32:52 <shachaf> > product [1..20]
20:32:53 <lambdabot>  2432902008176640000
20:32:54 <bitwize> ?hoogle fact
20:32:55 <lambdabot> No matches found
20:32:59 <bitwize> ?hoogle fac
20:33:00 <lambdabot> Text.Html.face :: String -> HtmlAttr
20:33:00 <lambdabot> Distribution.Extension.ForeignFunctionInterface :: Extension
20:33:00 <lambdabot> Distribution.InstalledPackageInfo.haddockInterfaces :: InstalledPackageInfo -> [FilePath]
20:33:28 <mm_freak_> > product [3,7,11,13,17,19,23] `mod` 100 == 0
20:33:29 <newsham> what's the last digit of 53249123!  ?
20:33:30 <lambdabot>  False
20:33:38 <bitwize> 0
20:34:32 <ddarius> > product [2..52349123]
20:34:36 <lambdabot> Terminated
20:34:37 <mm_freak_> > product [1..100] `mod` 12827 == 0
20:34:39 <lambdabot>  False
20:34:45 <mm_freak_> > product [1..101] `mod` 12827 == 0
20:34:47 <lambdabot>  False
20:34:48 <ddarius> Will have to use a version smarter than that.
20:34:54 <mm_freak_> > product [1..127] `mod` 12827 == 0
20:34:55 <lambdabot>  True
20:35:00 <int-e> > product [1..100] `mod` 101 == 100
20:35:01 <lambdabot>  True
20:35:17 <ddarius> Unless you meant the least significant digit, in which case it is 0.
20:36:46 <newsham> in my world the last digit is the least significant
20:36:55 <newsham> sorry for being so big endian :(
20:37:18 <mm_freak_> then the `last' digit of x! is still 0, whenever x >= 5
20:38:20 <mm_freak_> the last decimal digit, that is
20:38:26 <newsham> and binary
20:38:31 <int-e> hmm, what's the last nonzero digit of 53249123! ?
20:38:59 <mm_freak_> good question  probably you'll need to calculate that
20:39:07 <mm_freak_> but probably that's easier to calculate than the result
20:39:22 <hpaste>  bos pasted "adler32 golf!" at http://hpaste.org/2004
20:40:23 <mm_freak_> > let fac x p | x > 10 = fac (div x 10) | x == 0 = p | otherwise = (fac (x-1) $! (p*x)) in fac 53249123
20:40:24 <lambdabot>      Occurs check: cannot construct the infinite type: t = t1 -> t
20:40:25 <lambdabot>     Probab...
20:40:36 <mm_freak_> > let fac x p | x > 10 = fac (div x 10) p | x == 0 = p | otherwise = (fac (x-1) $! (p*x)) in fac 53249123
20:40:38 <lambdabot>  <Integer -> Integer>
20:41:05 <mm_freak_> > let fac x p | x > 10 = fac (div x 10) p; fac x p | x == 0 = p; fac x p = (fac (x-1) $! (p*x)) in fac 53249123
20:41:06 <lambdabot>  <Integer -> Integer>
20:41:24 <mm_freak_> d'oh
20:41:25 <mm_freak_> > let fac x p | x > 10 = fac (div x 10) p; fac x p | x == 0 = p; fac x p = (fac (x-1) $! (p*x)) in fac 53249123 1
20:41:27 <lambdabot>  120
20:41:37 <mm_freak_> the last digit is 2 =)
20:41:42 * bos is quite pleased with alder32_try3 in the paste above
20:41:45 <bos> er, adler
20:42:13 <mm_freak_> the last non-zero digit
20:42:37 <newsham> Prelude> take 1 $ show $ product [2..52349123]
20:42:38 <newsham> "<interactive>: getMBlocks: VirtualAlloc MEM_RESERVE 1 blocks failed: Not enough storage is available to process this command.
20:42:40 <mm_freak_> well  the least significant non-zero decimal digit =)
20:43:22 <reffie> wow, running xmonad while another window manager is around sure fucked things up
20:43:31 <int-e> mm_freak_: uh why would that formula be correct? you're calculating 5!
20:43:47 <ddarius> mm_freak_: From now on you must provide a proof of correctness with all code.
20:44:03 <chessguy> wow, this scheme tutorial really goes indepth
20:44:18 <reffie> chessguy which?
20:44:23 <newsham> monochrom: Fear leads to uncertainty. Uncertainty leads to doubt. Doubt leads to theorem proving.
20:44:25 <mm_freak_> int-e: because the least-significant decimal digit of 10*x*y is the same as the least-significant non-zero digit of x*y
20:44:45 <chessguy> reffie, http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/overview.html
20:44:46 <lambdabot> Title: Write Yourself a Scheme in 48 hours, http://tinyurl.com/l986o
20:44:52 <mm_freak_> but i've done a mistake
20:45:06 <int-e> mm_freak_: but you're replacing x! by floor(x/10)!
20:45:28 <newsham> x! is divisible by 10 (for most values of x)
20:45:29 <mm_freak_> > let fac x p | x `mod` 10 == 0 = fac (div x 10) p; fac x p | x == 0 = p; fac x p = (fac (x-1) $! (p*x)) in fac 53249123 1 `mod` 10
20:45:33 <lambdabot> Terminated
20:46:00 <newsham> product [1,2,3,4,5,....] is divisible by 10 = 2*5
20:46:24 <int-e> > (53249123 * log 53249123 - log 10 * 13312274) / log 10
20:46:25 <lambdabot>  3.981070884894748e8
20:46:26 <newsham> (also divisible by 6, 12, 20, 15, 8, ...)
20:46:47 <mm_freak_> that sure takes a while
20:46:50 <int-e> mm_freak_: an estimate of the number of digits in the result. the divisions by 10 don't really help much.
20:47:26 <mm_freak_> int-e: yeah, i've replaced (p*x) by (p*x `mod` 10)
20:47:32 <ddarius> > product $ filter (\x -> x `mod` 10 /= 0) $ 3:4:[6..53249123]
20:47:36 <lambdabot> Terminated
20:47:37 <mm_freak_> i'm running it locally via GHCi  still taking long
20:47:54 <mm_freak_> probably i should compile it
20:48:17 <mm_freak_> sorry for the mistake above, btw  the current code should be correct
20:48:44 <mm_freak_> btw, i'm doing the divisions to find out the least-significant non-zero decimal digit
20:50:10 <newsham> > let mul a b = if (a*b) `mod` 10 == 0 then (a*b) `div` 10 else (a*b) in foldl (*) 1 [2..100]
20:50:11 <lambdabot>  9332621544394415268169923885626670049071596826438162146859296389521759999322...
20:50:29 <mm_freak_> i see right now that it will not work  i have to do (`mod` 100) instead of (`mod` 10)
20:50:46 <newsham> > let mul a b = if (a*b) `mod` 10 == 0 then (a*b) `div` 10 else (a*b) in foldl mul 1 [2..100]
20:50:47 <lambdabot>  9332621544394415268169923885626670049071596826438162146859296389521759999322...
20:50:48 <SamB> newsham: where does the dark side come into all of this?
20:51:00 <newsham> samb: i didnt ask this question
20:51:04 <Olathe> Keep a count of multiples of two. Every time you get a multiple of five, subtract one from it.
20:51:09 <newsham> i would like to wash my hands of this all right now
20:51:15 <SamB> newsham: yes, but you said...
20:51:19 <Olathe> After you're done, multiply the twos in.
20:51:32 <SamB> <newsham> monochrom: Fear leads to uncertainty. Uncertainty leads to doubt. Doubt leads to theorem proving.
20:51:43 <ddarius> @quote monochrom
20:51:43 <lambdabot> monochrom says: 007 titles for haskellers.  fromForeignPtr withCString.  You Only lift Twice.  Bottoms Are Forever.  The Monad with the Pure Function.  For Your Types Only.  A view to A seq.
20:51:43 <lambdabot> Licence to killThread.  iterate Never Dies.  unsafePerformIO Is Not Enough.
20:51:45 <ddarius> @quote monochrom
20:51:46 <lambdabot> monochrom says: All numbers just sit there doing nothing.
20:51:51 <newsham> samb: its a quote in the haskell sequence
20:51:57 <SamB> newsham: oh.
20:51:59 <newsham> http://sequence.complete.org/
20:52:00 <lambdabot> Title: The Haskell Sequence | News about Haskell
20:52:09 <mm_freak_> actually it should be possible to calculate the number of zeroes
20:52:20 <mm_freak_> that would make calculating the digit much easier
20:52:21 <dmwit> mm_freak_: Sure, that's easy.
20:52:30 <mm_freak_> yeah
20:52:31 <dons> morning mm_freak_
20:52:34 <dons> you're up early?
20:52:35 <wli> let lsnzd n = let (q, r) = n `quotRem` 10 in if r == 0 then lsnzd q else r
20:52:40 <mm_freak_> good morning, dons
20:52:50 <newsham> > let mul a b = if (a*b) `mod` 10 == 0 then (a*b) `div` 10 else (a*b) in foldl mul 1 [2..52349123]
20:52:54 <lambdabot> Terminated
20:52:57 <mm_freak_> dons: i'm still up  working at evenings
20:53:09 <dons> ah I see.
20:53:17 <SamB> @ask monochrom How does theorem proving lead to the dark side?
20:53:18 <lambdabot> Consider it noted.
20:53:48 <newsham> > FUD == theorem_proving
20:53:49 <lambdabot>   Not in scope: `theorem_proving'
20:53:49 <dmwit> > let f n | n < 5 = 0 | n >= 5 = n `div` 5 + f (n `div` 5) in f 5
20:53:50 <lambdabot>  1
20:53:51 <mm_freak_> dons: where do you come from?
20:53:57 <dmwit> > let f n | n < 5 = 0 | n >= 5 = n `div` 5 + f (n `div` 5) in f 10
20:53:58 <lambdabot>  2
20:54:00 <bitwize> > let divides m n = ((mod n m) == 0) in map (\x -> if (divides 5 x) then (Left "doom") else if (divides 7 x) then (Left "schwartz") else (Right x)) [1..30]
20:54:01 <dmwit> > let f n | n < 5 = 0 | n >= 5 = n `div` 5 + f (n `div` 5) in f 25
20:54:01 <lambdabot>  [Right 1,Right 2,Right 3,Right 4,Left "doom",Right 6,Left "schwartz",Right 8...
20:54:02 <lambdabot>  6
20:54:10 <dmwit> > let f n | n < 5 = 0 | n >= 5 = n `div` 5 + f (n `div` 5) in f 625
20:54:12 <lambdabot>  156
20:54:25 <dmwit> mm_freak_: ^^^
20:54:46 <dmwit> ooo
20:54:46 <sorear> mm_freak_: He lives in Sydney
20:54:56 <mm_freak_> ah k
20:55:00 <sorear> mm_freak_: and is moving to Portland
20:55:11 <dmwit> > sum . takeWhile (>= 0) . iterate (`div` 5) $ 625
20:55:15 <lambdabot> Terminated
20:55:32 <wli> mm_freak: lsnzd that I pasted above should do the trick
20:55:34 * ddarius wishes he lived in Sydney and/or was moving to Portland.
20:55:39 <mm_freak_> so dons is running 24 clocks at the same time to see the current time everywhere on the world simultaneously =)
20:55:47 <dmwit> > sum . takeWhile (> 0) . iterate (`div` 5) $ 625
20:55:48 <lambdabot>  781
20:56:05 <bitwize> ddarius: I wish I were moving to Portland too. I lived there for a year.
20:56:08 <dmwit> oops
20:56:17 <dmwit> > sum . takeWhile (> 0) . drop 1 . iterate (`div` 5) $ 625
20:56:18 <lambdabot>  156
20:56:20 <dmwit> There we go.
20:56:33 * wli lives in Portland and is wondering why everyone wants to live here.
20:56:49 <mm_freak_> wli: i see only one `in'
20:56:52 <ddarius> wli: Your solution first requires calculating 53249123!
20:56:53 <Nafai> I've only been to Portland once, and it was for one day, and it was rainy and miserable
20:56:54 <newsham> wli: thats what i'm wondering
20:57:04 <mm_freak_> and you would need to calculate the result in the first place
20:57:08 <ddarius> wli: I just don't want to live here.
20:57:09 <newsham> portland is like seattle lite is like san francisco lite
20:57:09 <mm_freak_> i'm trying to get away without doing so
20:57:16 <wli> mm_freak: I flubbed pasting from ghci.
20:57:48 <wli> ddarius: Ah, I didn't realize one was supposed to avoid computing the result.
20:57:58 <wli> mm_freak: What result are you working with?
20:58:06 <mm_freak_> 53249123!
20:59:11 <dons> yeah, i'm in Sydney for the next 4 weeks, then Portland.
20:59:18 <wli> mm_freak: Hmm. Sounds like you want to count up the powers of 2 and 5 to get the number of zeros.
20:59:19 <dons> and my xmonad status bar has a bunch of clocks in it :)
20:59:34 <mm_freak_> wli: yes, probably that's easier to calculate
21:00:00 <bitwize> and Portland has quite a bit less rain than is advertised.
21:00:07 <newsham> what's a good probabalistic answer to least non-zero digit?
21:00:09 <dmwit> wli: See my last "> ", f.e.
21:00:13 <newsham> 1?
21:00:17 <bitwize> the rain can even be pleasant. New England rainstorms are bleh.
21:00:55 <mm_freak_> x! should be a multiple of 5^(div x 5)
21:01:38 <dmwit> > let mul a b | a*b `mod` 10 == 0 = a*b `div` 10 | otherwise = a*b `mod` 10 in foldr mul 1 [2..53249123]
21:01:40 <lambdabot>  Exception: stack overflow
21:01:52 <wli> mm_freak: Hmm. It should be possible to count.
21:01:53 <dmwit> > let mul a b | a*b `mod` 10 == 0 = a*b `div` 10 | otherwise = a*b `mod` 10 in foldl' mul 1 [2..53249123]
21:01:56 <lambdabot> Terminated
21:02:13 <mm_freak_> wli: i'm afraid it's not that obvious
21:02:45 <dmwit> mm_freak_: It is also a multiple of 5^(div x 5 + div x 25 + div x 125 + ...)
21:02:53 <newsham> > map (\n -> head$dropWhile (== '0')$reverse$show$product [1..n]) [1..100]
21:02:55 <lambdabot>  "126422428886828868244846448468868222428224286626422428448466626466264886824...
21:02:55 <mm_freak_> dmwit: yeah, i realized
21:03:05 <mm_freak_> hmm
21:03:05 <newsham> 8 would be a good guess
21:04:01 <wli> I'm afraid I've not got my wits about me.
21:04:28 <wli> Not that I have any such thing.
21:04:52 <shachaf> dons: What will happen to lambdabot?
21:05:15 <shachaf> dons: Will she have a good home?
21:05:23 <mm_freak_> this works:  let fac 0 = 1; fac n = (if mod r 100 == 0 then div r 100 else r) where r = n * fac (n-1) in fac 95
21:05:33 <mm_freak_> but it's recursive
21:05:57 <mm_freak_> make it tail-recursive, then it's probably feasible
21:06:06 <dons> shachaf: right, this is an open question
21:06:16 <dons> one option is to run her from community.haskell.org
21:06:26 <newsham> hmm.. least sig non-zero digit seems to follow a neat pattern for sequential values
21:06:59 <int-e> > let x 0 = 1; x n = ([1,1,2,1,4,4,4,3,4,1] !! n `mod` 10) * x (n `div` 5) `mod` 5; p 0 = 0; p n = n `div` 5 + p (n `div` 5); y n = adj $ x n * 3^(p n `mod` 4) `mod` 5; adj x | odd x  = x + 5 | even x = x in y 53249123
21:07:01 <lambdabot>  Exception: Prelude.(!!): index too large
21:07:13 <int-e> > let x 0 = 1; x n = ([1,1,2,1,4,4,4,3,4,1] !! (n `mod` 10)) * x (n `div` 5) `mod` 5; p 0 = 0; p n = n `div` 5 + p (n `div` 5); y n = adj $ x n * 3^(p n `mod` 4) `mod` 5; adj x | odd x  = x + 5 | even x = x in y 53249123
21:07:15 <lambdabot>  8
21:07:15 <jfredett> :/ I'm not sure how to initialize the darcs repo on code.haskell.org, anyone in the know available to tell me how?
21:07:27 <jfredett> I have an account, but definitely no password. :/
21:08:27 <shachaf> dons: Are there any other options?
21:08:49 <wli> Well, I've been blown away.
21:08:50 <dmwit> ?pprint let x 0 = 1; x n = ([1,1,2,1,4,4,4,3,4,1] !! (n `mod` 10)) * x (n `div` 5) `mod` 5; p 0 = 0; p n = n `div` 5 + p (n `div` 5); y n = adj $ x n * 3^(p n `mod` 4) `mod` 5; adj x | odd x  = x + 5 | even x = x in y 53249123
21:08:50 <lambdabot> Unknown command, try @list
21:09:00 <dons> shachaf: it could be hosted by another user here, or possibly at my new workplace
21:09:14 * ddarius considers viewing the problem through turning multiplication into convolution.
21:09:18 <dons> likely i wil have access to unsw for a little while longer
21:09:20 <mm_freak_> int-e: nice solution
21:09:38 <wli> int-e: I don't understand it.
21:10:04 <mm_freak_> i do  the least significant non-zero digit follows a finite and very short sequence pattern
21:10:36 <mm_freak_> int-e's solution just takes an index into this pattern
21:11:02 <int-e> mm_freak_: that's the answer; the idea is that it suffices to find the result modulo 5 (it's even). the answer is 53249123! / 10^13312274 -- split that into 53249123!/5^13312274 / 2^13312274; the first term is calculated by x by reducing n! to 1..4*6..9*... * (n `div` 5)!. the second term is calculated by y (3 is the multiplicative inverse of 2 modulo 5); p calculates the 13312274.
21:11:39 <int-e> ... (3 is the multiplicative inverse of 2 modulo 5); p calculates the 13312274. (not sure but I guess this got cut off somewhere)
21:12:02 <mm_freak_> int-e: probably there is an even easier solution
21:12:21 <int-e> mm_freak_: there is no simple finite pattern.
21:12:50 <thoughtpolice> @version
21:12:51 <lambdabot> lambdabot 4p534, GHC 6.6 (Linux i686 2.66GHz)
21:12:51 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
21:12:52 <wli> I was going to say that I was staring at it and not seeing the pattern.
21:13:04 <mm_freak_> int-e: but it's calculatable easily
21:13:31 <mm_freak_> basically that's what i were doing above, but i've made a mistake somewhere, which made it bottom
21:13:34 <shachaf> dons: Will all the ~dons links be broken, by the way?
21:14:23 <brad_> if anyone here uses hxt, can you tell me what the arguments to Text.XML.HXT.Parser.XmlParsec/parseXmlDocument are supposed to be?
21:15:01 <bos> > (uncurry (flip ((.|.) . (`shiftL` 16))) . foldl' (uncurry ((. (,) 0) . flip . ((join (***) . ((`mod` base) .) . (+)) .) . (. ((.&. 255) . ord)) . (+))) (1, 0)) "foo"
21:15:02 <lambdabot>   Not in scope: `base'
21:15:06 <brad_> even viewing the source gives no clues
21:15:12 <bos> > (uncurry (flip ((.|.) . (`shiftL` 16))) . foldl' (uncurry ((. (,) 0) . flip . ((join (***) . ((`mod` 65521) .) . (+)) .) . (. ((.&. 255) . ord)) . (+))) (1, 0)) "foo"
21:15:13 <lambdabot>  42074437
21:15:41 <dons> shachaf: not any time soon, but they'll be mirrored somewhere
21:15:48 <dons> likely to haskell.org/~dons/ I think
21:17:11 <kfish> dons: try to get someone from cse to put a secret http redirect in for you
21:17:31 <sorear> woah
21:17:39 <kfish> i had one for a few years after i left, buried in the apache config somewhere :-)
21:18:05 <bitwize> @pf
21:18:05 <lambdabot> Maybe you meant: bf pl
21:18:08 <sorear> real	0m12.929s
21:18:09 <bitwize> @pl
21:18:09 <lambdabot> (line 1, column 1):
21:18:09 <lambdabot> unexpected end of input
21:18:09 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
21:18:17 <sorear> Gofer compiles in 13s
21:18:23 <wli> > sum $ tail $ takeWhile (/=0) $ iterate (`div` 5) 53249123
21:18:25 <lambdabot>  13312274
21:18:37 <wli> > sum $ tail $ takeWhile (/=0) $ iterate (`div` 2) 53249123
21:18:38 <lambdabot>  53249112
21:18:49 <ddarius> sorear: You're too used to building GHC.
21:18:58 <bitwize> @pl (\x -> (x == 0) || (x == 1))
21:18:58 <lambdabot> liftM2 (||) (0 ==) (1 ==)
21:19:07 <bitwize> Oooooo.
21:19:19 <bitwize> @src liftM2
21:19:19 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
21:19:25 <bos> bitwize: don't be misled
21:19:27 <sorear> stefan@stefans:/usr/local/src/gofer$ src/gofer
21:19:27 <sorear> Gofer Version 2.30b  Copyright (c) Mark P Jones 1991-1995
21:19:38 <bos> @type liftM2 (||) (0 ==) (1 ==)
21:19:40 <slava32> dons: how does it feel to be the #2 poster on reddit?
21:19:41 <lambdabot> forall t. (Num t) => t -> Bool
21:20:21 <dons> slava32: bit scary. but that's what happens when you set up an rss feed for an active community
21:20:35 <dons> 1-2 articles a day, for a year. *shrug* :)
21:21:19 <dons> good thing people write interesting stuff round here ;)
21:21:25 <sfultong> >  map show $ return (+5) `ap` (return 1)
21:21:26 <lambdabot>  ["6"]
21:22:05 <sorear> readFile        :: String ->           FailCont -> StrCont     -> Dialogue
21:22:53 <ddarius> sorear: Does an IO monad come with Gofer?
21:23:17 <dons> sorear: you should have a go at writing a verified hhaskell module in Coq, extracting it, and using it in a larger haskell project (e.g. a small plugin for lambdabot, for example, implemented in Coq, would be very cute)
21:23:23 <sorear> Doesn't look like it.
21:23:39 <ddarius> Easy enough to write.
21:25:00 <sorear> The dirty secret of super-dependant systems like Coq is that they only work well when your specification is really simple, like "Four color an arbitrary planar graph."
21:25:34 <dons> i don't think its a secret that you have to know what you're doing :)
21:25:38 * wli tries to figure out where he missed the monad in some snippet of code.
21:25:39 <sorear> Most things in lambdabot looks far too informally specified to benefit :(
21:26:00 <dons> sorear: something like rot13, extract that, wrap it in a plugin, verified component for lambdabot :)
21:26:24 <shachaf> @rot13 There's no rot13 yet?
21:26:24 <lambdabot> Unknown command, try @list
21:26:24 <sorear> wli: Count yourself lucky that you missed the dark horror of pre-monadic IO.
21:26:34 <thoughtpolice> is it currently like, not possible to build lambdabot with plugins support or somesuch? i just installed 6.6.1 (finally, thank you gcc-3.4!) and tried to build lambdabot using the lambdabot.cabal.plugins file, but uh, I kind of got an arcane err :/
21:26:57 <ddarius> Continuation based IO is not really much worse except that you can abuse it.
21:27:03 <wli> sorear: I'm referring to a specific snippet of typechecking code for an *extremely* dumbed-down mini-language.
21:27:39 <thoughtpolice> although now that I moved the config file back over it seems to be building just fine.
21:27:46 <wli> sorear: http://holomorphy.com/~wli/Simple.lhs.txt
21:27:59 * dons works on HW demo:
21:27:59 <dons> We argue that Haskell is ideally suited for
21:27:59 <dons> the production of concise, efficient and safe system software, using
21:28:02 <dons> tools available \emph{now}!
21:28:08 <int-e> > let x 0 = 1; x n = (liftM2 (*) [1,2,4,3] [1,1,2,1,4]) !! (n `mod` 20) * x (n `div` 5) `mod` 5; adj x | odd x = x + 5 | True =x in adj $ x 53249123
21:28:10 <lambdabot>  8
21:28:17 <dons> Incongruously, the system software domain is
21:28:18 <dons> still dominated by programs written in legacy unsafe languages, despite
21:28:20 <dons> the difficulty developing correct software with these tools.
21:28:21 <dons> :)
21:28:35 <int-e> mm_freak_: you were right, this is simpler. the pattern is longer though.
21:29:08 <olliej> dons: but the problem is that the C++ type system is fundamentally *better* than Haskells -- look at how much more you can do!
21:29:19 <dons> heh
21:29:28 <dons> interesting argument :)
21:29:30 <olliej> dons: for instance haskells type system is so useless it doesn't let you use int, bool, and string interchangably
21:29:35 <olliej> :D
21:29:59 <Korollary> I suppose everybody had to wait until 1998 to write anything?
21:30:13 <marcotmarcot> I've done some time ago a package to work with some geometric operations I needed.
21:30:14 <wli> Heavens no.
21:30:17 <dibblego> olliej, who's/what argument are you parodying?
21:30:18 <lambdabot> dibblego: You have 1 new message. '/msg lambdabot @messages' to read it.
21:30:33 <olliej> dibblego: i just came up with that one :D
21:30:35 <wli> Haskell 1.3 and 1.4 were quite nice in a number of respects.
21:30:38 <sorear> @pl \fix -> let a = 2 in a   -- I'd like to do a good @pl, but something tells me formalizing the haskell semantics will be hard
21:30:39 <lambdabot> ($ const 2)
21:30:43 <dibblego> olliej, damn :)
21:30:46 <wli> And monads were there, too.
21:30:52 <marcotmarcot> Most of it is a port from C of libgpc, and a little part of it has geometric logic in haskell.
21:31:02 <sorear> @pl \fix' -> let a = 2 in a   -- Look, alpha renaming gives something completely different!
21:31:03 <lambdabot> const 2
21:31:36 <dons> I like the python thing from yesterday, where they polish the code to be more efficient, and break it in the process -- but don't care/notice they broke it.
21:31:36 <ddarius> sorear: Why would formalizing the semantics of @pl be particularly hard?
21:31:56 <dons> sorear: yeah, that would be good: an extensible @pl rewriter, that supported arrows and applicative functors better
21:32:00 <dons> the old @pl is holding us back
21:32:00 <Korollary> dons: refactoring is hard in untyped languages.
21:32:30 <Korollary> You need really good tests
21:32:43 <sorear> Korollary: I agree.  @pl ought to be type-directed
21:32:46 <dons> in this case, it was a basic lack of knowledge of sum types, and yeah, no testing
21:32:49 <mm_freak_> int-e: unfortunately my version takes longer  for whatever reason =/
21:33:00 <dons> sorear: do you think you could focus long enough, to produce a sound @pl ?
21:33:07 <dons> only needs to support expressions
21:33:22 <dons> i think unless you do it, we'll be stuck with @pl for a while
21:33:36 <Korollary> Fix @pl or the baby seal gets it
21:33:45 <dons> and, a good implementation, a la Djinn, would be worth a small paper/demo/writeup
21:34:04 <hpaste>  Olathe pasted "How do I keep this from running out of stack space ?" at http://hpaste.org/2005
21:34:16 <dons> a straightforward term rewriter, with an extensible refactoring engine + heuristics
21:34:43 <dons> sorear: there's also DrHaskell, you could look at
21:34:50 <newsham> ?let rot m ch = if isAlpha ch then (chr.(+65).(`mod` 26).(+m).(subtract 65).ord.toUpper) ch else ch
21:34:53 <lambdabot> Defined.
21:34:55 <dons> the main thing is to be able to extend it with new refactorings
21:35:03 <newsham> > map (rot 13) "testing 123 foobar"
21:35:04 <lambdabot>  "GRFGVAT 123 SBBONE"
21:35:13 <newsham> > map (rot 13) "GRFGVAT 123 SBBONE"
21:35:13 <Olathe> Is there something I'm doing that's preventing tail call elimination or something like that ?
21:35:14 <lambdabot>  "TESTING 123 FOOBAR"
21:36:14 <newsham> ?let rot13 = rot 13
21:36:15 <lambdabot> Defined.
21:36:26 <sorear> Olathe: What function are you expecting to be tailrec?
21:36:33 <Olathe> All of them.
21:37:00 <Korollary> There's a wiki entry regarding tail rec
21:37:01 <Olathe> I could do this iteratively pretty easily.
21:37:25 <sorear> Olathe: You need more accumulators
21:37:31 <Olathe> What are accumulators ?
21:37:32 <ddarius> "Then to flatten the list we can use a simple trick to take advantage of how the + operator works on lists -- the sum function." Oh for the love of god
21:38:30 <sorear> ddarius: who wrote that?!
21:38:43 <ddarius> sorear: That's in python.
21:38:50 <ddarius> http://www.builderau.com.au/program/python/soa/Run-length-encoding-in-Python/0,2000064084,339280649,00.htm
21:38:54 <lambdabot> Title: Run length encoding in Python - Program - Python - Builder AU, http://tinyurl.com/2pg2oy
21:39:10 <TSC> Olathe: What are the functions supposed to do?
21:39:26 <dons> they like to throw a bit of ad hoc magic into the python mix eh? breaking code as they go
21:39:28 <Korollary> Olathe: Seen http://haskell.org/haskellwiki/Stack_overflow
21:39:29 <lambdabot> Title: Stack overflow - HaskellWiki
21:39:36 <dons> be careful of code that comes wit hthe phase `be careful'
21:40:00 <newsham> [a] + [a] -> [a]  in python  (its like ++)
21:40:24 <newsham> there's also [a] * Int -> [a]   (repetition)
21:40:28 <Olathe> TSC: separate takes a number, removes the factors of 2 and 5 from it (first element of tuple) and calculates count of 2s - count of 5s (second element of tuple)
21:40:32 <ddarius> I like how their decode function in "one line" takes two lines.
21:40:43 <dons> I was pondering that too, ddarius :)
21:40:46 <sorear> those people are fools...  they don't seem to realize that runtime tagging defeats the entire purpose...
21:41:11 <dons> but the main flaw seems to be the breaking for lists of tuples in the `improved' second implementation
21:41:20 <newsham> python is interpretted anyway.  no point crying over missed optimization opportunities in a script language
21:41:20 <Olathe> TSC: Actually, the first element is reduced modulo ten, too.
21:41:23 <dons> and not seeing that as a terrible practice to encourage
21:41:50 <sorear> it's one of those "dynamic" languages.
21:42:00 <newsham> yah, all them ducks typing
21:42:04 <sorear> I don't see how anyone can be rationally proud of late binding
21:42:14 <dons> but the code is *alive* sorear :)
21:42:14 <int-e> Olathe: write a function f :: (Int, Int) -> Int -> (Int, Int) that combines a pair with a factor and then use foldl' f (1, 0) [1..n]. facdig' is not tail recursive as written; its result depends on the return value of the recursive call.
21:42:20 <dons> its an organic thing
21:42:21 <newsham> sorear: its great for quick prototyping.
21:42:23 <dons> dude.
21:42:25 <Korollary> late binding?
21:42:35 <sorear> dons: in much the same way decaying vegetables are
21:42:38 <newsham> its not so much something you strive to be proud of as something that doesnt get in your way
21:42:39 <Korollary> a la C++ virtuals?
21:43:19 <ddarius> That article is hilarious.
21:43:23 <Olathe> int-e: Alright, I'll try. Thanks.
21:43:37 <newsham> I'm not sure I understand your 2-line oneliner argument
21:43:39 <dolio> sorear: What if you need to, while the program is running, go in and add new functionality?!
21:43:50 <newsham> had they said  encode = lambda l : [....]   would you have been happier?
21:44:00 <sorear> Haskell by contrast is your zombie servant.  It's dead as a doornail and you love it, because it does what you tell it to.
21:44:02 <newsham> (its not standard practice to define functions that way, but its perfectly legal)
21:44:04 <ddarius> newsham: Yes.
21:44:35 <sorear> Python code is... Frankenstein's Monster
21:44:37 <newsham> so mentally translate def fn(args):\n into fn = lambda args : ...   in your head
21:44:41 <newsham> (for pure functions)
21:44:53 <ddarius> What pure functions?
21:44:55 <newsham> sorear: in its informality and lack of rigor, perhaps.
21:45:07 <newsham> ddarius: [(len(list(group)),name) for name, group in groupby(l)]
21:45:09 <newsham> for example
21:45:09 <jfredett> who runs community.haskell.org?
21:45:31 <bitwize> sorear: Python doesn't have VALUE SEMANTICS
21:45:42 <sorear> SyntaxNinja iirc
21:45:44 <dons> bitwize: that's very important :)
21:45:49 <bitwize> Oh yes.
21:45:52 <jfredett> sorear: thanks,
21:45:57 <dolio> bitwize: C++ is the only language worth using. :)
21:45:58 <ddarius> newsham: Which is actually not a pure function, but anyways, it's just funny the blatant contradiction.
21:46:03 <bitwize> Without value semantics you never know *when* you get that memory back.
21:46:11 <newsham> ddarius: seen from the outside its a pure function.
21:46:13 <dons> yeah, its insane!
21:46:15 <sorear> Even with value semantics.
21:46:35 <dons> i wonder, does qwe1234 just program C++ on embedded devices?
21:46:37 <ddarius> newsham: No, it is not.  I can write contexts that will demonstrate that the results are different.
21:46:43 <sorear> qwe1234 is the kind of person I will ignore (assuming he isn't my senator/boss)
21:46:44 <dons> It might explain his bizarre obsessions
21:46:46 <newsham> ddarius: awesome!  please do.
21:46:59 <bitwize> I think he mentioned that he works on Java for his day job.
21:46:59 <dolio> Does he have time to program with all the trolling?
21:47:16 <dons> i don't think so.
21:47:20 <newsham> actually I take that back.. yes there are ways to do it :)
21:47:23 <ddarius> f(x) == f(x), or does python not have reference equality (written somehow).  This does not even go into the reflective abilities...
21:47:24 <newsham> iterators are stateful
21:47:27 <TSC> Maybe he tells himself to code and stfu, and that's when he gets work done (:
21:47:33 <bitwize> He's the scott nudds for a new generation.
21:47:58 <bitwize> Screw that, he's the *dual* of Scott "C is dying" Nudds.
21:48:02 <newsham> ddarius: but i think you understand what i meant to say (i was morally almost right)
21:48:24 <sorear> C is the new assembler
21:48:35 <newsham> C is so the old new assembler.
21:48:38 * ddarius prefers assembler.
21:48:43 * Korollary prefers C
21:48:58 * bitwize prefers Pre-Scheme
21:49:01 <mm_freak_> why don't you just write opcode directly
21:49:02 <mm_freak_> ?
21:49:03 <newsham> |C icfp programs| > 10 * |asm icfp programs|
21:49:04 * wli has no idea what sorear is on about; assembly is still alive and well.
21:49:25 <newsham> no bitC love? ;-)
21:49:46 <bos> hiya andyjgill
21:49:55 <andyjgill> Hi bos
21:50:07 <sorear> wli: Almost all assembly these days exists in the back ends of C compilers.  Once, everyone wrote low-level code in asm and targeted compilers to asm.
21:50:21 <AdamantX> OS kernels
21:50:34 <AdamantX> hand-massaged speed-critical code
21:50:38 <sorear> Now, most people write lower-level code in C, and except for really big organizations like MSR Cambridge, so do compilers
21:50:39 <newsham> even os kernels, find /usr/src/sys -name '*.[sS]' |xargs wc
21:50:41 <newsham> not terribly large
21:50:52 <dons> for today's task, someone should code up this simple erlang benchmark in compiled, smp Haskell, http://muharem.wordpress.com/2007/07/31/erlang-vs-stackless-python-a-first-benchmark/
21:50:55 <lambdabot> Title: Erlang vs. Stackless python: a first benchmark  Muharem Hrnjadovic, http://tinyurl.com/2aesc4
21:50:59 <AdamantX> true, but it exists
21:51:20 <dons> I suspect some compiled ghc threads would perform fairly well here .. ;)
21:51:22 <wli> sorear: Na. There's still plenty of embedded, ASIC, PIC, and firmware work involving it.
21:51:23 <newsham> anyone writing up fun parallel haskell code on sun grid?
21:51:37 <AdamantX> wli makes a good point
21:51:39 <mm_freak_> once i've launched a contest for a small C program:  http://forums.gentoo.org/viewtopic-t-276151-highlight-contest.html
21:51:41 <lambdabot> http://tinyurl.com/229zv8
21:51:44 <dons> newsham: the big ndp array stuff runs on giant sun server
21:51:48 <mm_freak_> probably something similar is possible in haskell
21:51:53 <newsham> wli: even that, look at most firmware and you'll find about 2-5% assembly
21:52:18 <newsham> http://www.sun.com/service/sungrid/index.jsp
21:52:19 <lambdabot> Title: Sun Utility Computing
21:52:34 <wli> newsham: Depends on what it's the firmware for.
21:53:06 <Olathe> How do I use foldl' (fact.hs:8:30: Not in scope: `foldl'') ?
21:53:17 <shachaf> :m + Data.List
21:53:19 <newsham> "most"
21:53:22 <shachaf> import Data.List, rather.
21:53:34 <shachaf> @index foldl'
21:53:34 <lambdabot> Data.List
21:53:53 <newsham> here's a typical example:  136,446 loc C/h, 993 loc .as
21:54:01 <Olathe> Alright, thanks :)
21:54:18 <Korollary> There are no typical examples
21:54:49 <shachaf> @go Evolution of a Haskell Programmer
21:54:51 <lambdabot> http://www.willamette.edu/~fruehr/haskell/evolution.html
21:54:51 <lambdabot> Title: The Evolution of a Haskell Programmer
21:55:09 <newsham> here's another: 66,957 loc C/h, 721 loc .a51
21:55:13 <shachaf> Olathe: If you have a fact.hs, and haven't seen this before. :-)
21:55:17 <newsham> real numbers real firmware
21:55:32 <Korollary> That doesn't make it typical
21:55:51 <newsham> no, it doesnt.  I am claiming it is typical.
21:55:54 <newsham> in my experience.
21:56:20 <sorear> Hah, and he doesn't even bother to implement it correctly
21:56:22 <wli> I've seen a few bits and they varied.
21:56:25 <Korollary> I didn't know typical was synonymous with "in newsham's experience" ;)
21:56:45 <sorear> He's sending N messages down the ring, which is NOT AT ALL the same as sending a message around the ring N times
21:56:54 <sorear> One is parallelizable.  The other isn't.
21:57:10 <sorear> Should I implement something like the specification or something like the code? :)
21:57:38 <sorear> oh, wait
21:57:47 <sorear> I don't have erlang or stacklesspython
21:57:48 <sorear> nm
21:57:50 <newsham> feel free to present counterexamples.
21:58:07 <sorear> no use benchmarking if you can't meaningfully compare results
21:58:29 <hpaste>  Olathe annotated "How do I keep this from running out of stack space ?" with "Still overflowing stack" at http://hpaste.org/2005#a1
21:58:34 <wli> The Sequent BIOS, MPC controller, et al were mostly asm.
21:58:44 <newsham> aprox release date?
21:58:59 <Olathe> Are any other functions not tail recursive ?
21:59:22 <wli> newsham: Well, they're still being maintained. They date back to the 1980's if you want to know when they were originally written.
21:59:51 <bos> what colour should our assembly language bikeshed be?
21:59:57 <sorear> Olathe: Both of your functions are tail recursive, but they build thunk chains.  Try adding accumulators
22:00:10 <sorear> Olathe: sorry, forgot to refresh
22:00:33 <Olathe> I don't know what accumulators are.
22:00:39 <dons> sorear: you can show how it scales to 8 cores or so, though, in less code, with stronger checks
22:00:51 <newsham> wli: *nod*, but the amount of firmware developed in the last decade dwarfs the amount that is maintained from the 80's
22:00:57 <bos> sorear: i think Olathe needs a bit of seq
22:01:16 <newsham> sheer volume of controllers on disk drives, wlan nics, etc...
22:01:17 <sorear> dons: If I implement the problem as specified, it will not scale at all. The problem describition is inherently single-threaded
22:01:32 <newsham> cell phones, etc.
22:01:36 <sorear> dons: Also, my system does not have "8 cores or so". :)
22:01:37 <RyanT5000> how do you tell Setup.lhs where it should look for include files for hsc files?
22:01:49 <RyanT5000> (trying to compile Lemmih's SDL binding)
22:01:51 <wli> newsham: I've seen other instances, e.g. ASIC code. I've seen other instances that involved C (IA64 firmware).
22:02:10 <sorear> dons: I do have six computers, however.  Too bad GdH isn't maintained :)
22:02:31 <wli> newsham: (In fact, one instance of each was for the same platform getting brought up.)
22:02:49 <bos> meh, GdH can't do erlangy stuff anyway
22:03:46 <bos> just say no to non-fault-tolerant distributed infrastructure.
22:03:46 <Olathe> shachaf: Heheh, thanks.
22:03:51 <mm_freak_> O(N^(1/2))  what kind of complexity is that?  polynomial?  it's less than linear
22:04:01 <wli> newsham: I wouldn't argue that asm is in any way dominant or more prevalent, just that it has a sort of persistent niche.
22:04:09 <wli> mm_freak: Polynomial.
22:04:26 <newsham> you definitely need it, but even in that market, C dominates.
22:04:34 <mm_freak_> is there anything such as `subpolynomial'?
22:04:47 <wli> newsham: C does dominate.
22:05:13 <moconnor> mm_freak_: http://en.wikipedia.org/wiki/Big_Oh#Common_orders_of_functions
22:05:28 <RyanT5000> @seen lemmih
22:05:28 <lambdabot> lemmih is in #haskell. I last heard lemmih speak 5h 24m 50s ago.
22:05:35 <RyanT5000> lemmih: ping
22:06:20 <mm_freak_> according to that list it's "fractional power" run-time
22:06:33 <ddarius> Linear is polynomial and sublinear is perfectly fine.
22:06:36 <mm_freak_> never heard that before  sounds weird
22:06:51 <int-e> Olathe: replacing  facdig' (prevUnit, prevPower) n = ...  by  facdig' (!prevUnit, !prevPower) n = ...  (or facdig' (prevUnit, prevPower) n | prevUnit `seq` prevPower `seq` True = ...  without bang patterns) helps
22:07:03 <ddarius> n^(44/23) is fractional too...
22:07:47 <int-e> Olathe: alternatively, you can use a strict pair data type:  data Pair a b = Pair !a !b; and use Pair Int Int instead of (Int, Int)
22:08:28 <mm_freak_> ddarius: what why it sounds weird  it includes all polynomial run-times
22:09:05 <int-e> Olathe: Note that the cause of the failure is now different - foldl' is tail recursive, but facdig' is not strict enough, so it builds a large unevaluated expression. The stack overflow happens when that expression is finally evaluated.
22:14:11 <hpaste>  laz0r pasted "how would >>= look like? does this even make sense?" at http://hpaste.org/2006
22:14:13 <Olathe> int-e: ahh, that works. Thanks :)
22:14:41 <laz0r> hi, i just pasted something, and i would be very glad if someone could take a look at it
22:15:28 <laz0r> i'm trying to get comfortable with monads... but somehow i just can't get my head around them
22:15:51 <newsham> i'm in your monad binding your results
22:16:31 <wli> laz0r: Work through YAHT, every exercise.
22:16:42 <bitwize> IMMA CHARGIN MAH M0NAD LAZ0R!!!
22:16:54 <laz0r> hehe
22:17:04 <laz0r> i guess YAHT means Yet anatoher Haskell Tutorial
22:17:05 <laz0r> ?
22:17:12 <wli> laz0r: Yes.
22:17:12 <RyanT5000> laz0r: yep
22:17:14 <ddarius> Concat is not even a (covariant) functor.
22:17:14 <sjanssen> another
22:17:20 <sjanssen> ;)
22:17:47 <bitwize> Read also "Monads for functional programming" -- a paper by Philip Wadler.
22:18:03 <bitwize> For me it just about obviated the need for every other monad tut out there.
22:18:26 <ddarius> I like "The essence of functional programming".
22:18:43 <bitwize> http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf
22:18:46 <lambdabot> http://tinyurl.com/zhxow
22:18:47 * Pseudonym substituted "warm fuzzy thing", and it didn't sound so bad
22:18:56 <Pseudonym> IMMA CHARGIN MAH WARM FUZZY THING LAZOR!!!
22:19:25 <wli> I'm just beating my face in with monadic programming exercises until fluency builds up.
22:19:35 <hpaste>  Olathe annotated "How do I keep this from running out of stack space ?" with "Is separate' an accumulator ?" at http://hpaste.org/2005#a2
22:19:58 <shachaf> @oog Does lambdabot have an OOG?
22:19:59 <lambdabot> Maybe you meant: bug msg yow
22:20:17 <Olathe> Is separate' an accumulator ? If not, what is an accumulator ?
22:20:18 <Pseudonym> What's OOG?
22:20:28 <shachaf> Pseudonym: dog --oog
22:20:31 <bos> Olathe: an accumulator is just a variable that maintains a running partial result
22:20:48 <Olathe> Oh.
22:20:51 <shachaf> Pseudonym: I don't have it handy.
22:20:55 <Pseudonym> shachaf: That is, without a doubt, the silliest command line ever.
22:21:03 <bos> as in, it's where you accumulate your result
22:21:22 <sjanssen> Olathe: in that code, prevPower, prevUnit, power, and unit are all accumulating variables
22:21:28 <Olathe> Ahh.
22:21:38 * wli is flagellating himself with http://holomorphy.com/~wli/Easy.lhs.txt
22:22:05 <shachaf> Pseudonym: You have dog installed?
22:22:09 <Pseudonym> No.
22:22:19 <Pseudonym> What is it?
22:22:29 <Pseudonym> (You google for "dog", and you don't get much.)
22:22:34 <shachaf> Pseudonym: Like cat.
22:22:39 <Pseudonym> Ah.
22:22:43 <shachaf> Pseudonym: Only with more options.
22:22:57 <Pseudonym> How witty in a Unix nerd kind of way.
22:23:00 <Olathe> Alright, thanks.
22:23:06 <jfredett> ...
22:23:15 <bos> at foo camp, peter norvig had an amusing anecdote about presenting word association data to a linguistics conference.
22:23:20 <jfredett> shachaf: no... just, no...
22:23:29 <newsham> > let len [] n = n; len (x:xs) n = len xs (n+1) in len "testing"
22:23:32 <lambdabot>  <Integer -> Integer>
22:23:36 <newsham> > let len [] n = n; len (x:xs) n = len xs (n+1) in len "testing" 0
22:23:37 <wli> dog -bark 1,1 *.lhs
22:23:38 <lambdabot>  7
22:23:41 <newsham> accumulator
22:23:43 <bos> given a set of words, he'd produce a set of words that commonly appear with them.
22:23:45 <shachaf> jfredett: Cats are way smarter than dogs, of course, so it should be in reverse.
22:23:58 <jfredett> i dunno, my dog is pretty damn smart
22:24:14 <newsham> jfredett: does your dog do what you tell it to do?
22:24:15 <bos> so {rock,sand,concrete} -> {pebble,stone}
22:24:15 <jfredett> he's figured out how to get the cat in the cellar
22:24:18 <shachaf> On the other hand, you're probably more likely to get a dog to do hard work for you.
22:24:23 <jfredett> newsham: yah, on average
22:24:25 <newsham> must not be very smart.
22:24:32 <newsham> ;-)
22:24:37 <jfredett> newsham: I knew that was coming, it was a trick question
22:24:38 <bos> and the linguists were all nonplussed to see {cat,more,less} -> {perl,awk,grep}
22:24:42 <jfredett> if i said no-
22:24:43 <jfredett> :P
22:24:44 <newsham> my cat just says "I dont think so"
22:24:57 <int-e> bos: haha
22:24:59 <jfredett> my cat is a demon
22:25:05 <SamB_XP_> jfredett: a daemon
22:25:11 <jfredett> he's all blank, his eyes glow red
22:25:24 <jfredett> fire protrudeth from his nostrils
22:25:29 <newsham> he abandons his tty and runs in the background
22:25:38 <SamB_XP_> bos: why did this surprise them?
22:25:54 <bos> SamB_XP_: because they were linguists, and not unix hackers?
22:26:08 <SamB_XP_> bos: they had expectations?
22:26:16 <newsham> bos: tell the linguists g/re/p
22:26:17 <newsham> duh
22:26:37 <SamB_XP_> what WOULD they have expected to see?
22:26:37 <ddarius> SamB_XP_: Actual words would be a start for expectations...
22:26:49 <SamB_XP_> that's completely unreasonable
22:26:54 <newsham> also "awk" is no more cryptic than "DoD" or any other acronym
22:27:07 <SamB_XP_> what actual words would be associated with those words?
22:27:10 <ddarius> awk's an acronym?
22:27:14 <shachaf> newsham: DoD -- Dungeons of Doom? :-)
22:27:20 <newsham> awk is the name of three people
22:27:23 <bos> SamB_XP_: it was what we humans call a "joke". google the term.
22:27:25 <ddarius> Ah yes.
22:27:38 <newsham> aho weinberger kernighan
22:27:39 <SamB_XP_> bos: meh.
22:27:44 <SamB_XP_> punchline needs work!
22:37:47 <hpaste>  dolio pasted "stackless benchmark?" at http://hpaste.org/2007
22:41:07 <int-e> now can we get this to terminate any threads early?
22:42:00 <dolio> 90,000 threads is taking a while.
22:42:47 <ddarius> dolio: You need Stackless Haskell.
22:44:04 <int-e> I got ./ttt +RTS -N2 -RTS 200 1000 | wc --> 197801 lines :)
22:44:18 <sorear> Nah, just spineless. :)
22:44:57 <SamB_XP_> what does spineless even mean?
22:45:25 <sjanssen> > concat . intersperse "less, " $ ["spine", "tag", "stack"]
22:45:27 <lambdabot>  "spineless, tagless, stack"
22:46:26 <SamB_XP_> > concat . intersperse "less, " $ ["spine", "tag", "stack", "G-machine"] -- ?
22:46:27 <lambdabot>  "spineless, tagless, stackless, G-machine"
22:46:33 <SamB_XP_> hmm.
22:46:37 <SamB_XP_> not quite right.
22:46:56 <newsham> "does not need to build the spine of the expression being reduced"
22:47:18 <dolio> Disabling output doesn't get it down to 7 seconds like the python, either. :)
22:47:20 <SamB_XP_> anyway, GHC isn't tagless anymore
22:47:49 <int-e> and that's a good thing
22:47:52 <Olathe> How do I read a line of input as an Integer ?
22:47:54 <dons> an overview of the demo i'd like to present at the haskell workshop, http://www.cse.unsw.edu.au/~dons/tmp/haskell51d-stewart.pdf
22:47:57 <dons> feedback welcome!
22:48:03 <dons> all about xmonad, QuickCheck, and kicking heads
22:48:04 <newsham> > read "42" :: Int
22:48:06 <lambdabot>  42
22:48:08 <int-e> @type readLine
22:48:10 <lambdabot> Not in scope: `readLine'
22:48:17 <int-e> @type readLn
22:48:19 <lambdabot> forall a. (Read a) => IO a
22:48:24 <SamB_XP_> newsham: that isn't very good feedback
22:48:52 <int-e> Olathe: n <- readLn  will do the trick.
22:49:51 <Olathe> How do I use it in something like main = let n <- readLn in print (facdig n) ?
22:50:21 <Olathe> (facdig :: Integer -> Int)
22:50:23 <brad__> any update on when the galois curl binding might make it into hackage?
22:50:25 <newsham> main = do { n <- readLn; print n}
22:50:33 <dons> glguy: around?
22:50:34 <newsham> IO monad stuff
22:50:53 <int-e> (newsham's program needs a type signature for n though :)
22:51:20 <brad__> so glad this is getting close...curl really is the gold standard in networking libs...would take years to replicate
22:52:28 <Olathe> Alright, thanks.
22:52:38 <dons> brad__: have you tried using the darcs repo version?
22:52:44 <dons> that's likely to just be tagged and uploaded
22:53:05 <dolio> 100 threads + 90,000 messages runs in 18 seconds here, which may or may not be bad.
22:53:22 <bitwize> why aren't we reinventing curl?
22:53:27 <bitwize> we could call it hurl :)
22:53:33 <dons> dolio: is that the python/erlang benchmark?
22:53:52 <dons> if so, could i have a look/give it a whirl on a 8 core machine...
22:53:56 <dolio> Yeah. Not the one I pasted, exactly. I replaced the Chans with TChans.
22:54:07 <SamB_XP_> bitwize: lurl!
22:54:12 <SamB_XP_> or furl!
22:54:15 <dolio> 90,000 threads is really slow, though.
22:54:17 <dons> is there a noticeabe difference in performance between Chan and TChan?
22:54:18 <SamB_XP_> or webmonad
22:54:51 <dons> anyone want to comment on the `haskell for system software' page: http://www.cse.unsw.edu.au/~dons/tmp/haskell51d-stewart.pdf please :)
22:54:54 <ddarius> Yes!  Let's put monad into the name of all haskell applications from this point on!
22:55:06 <bitwize> My favorite has got to be Monadius.
22:55:10 <dons> i think that's a great idea, ddarius :)
22:55:33 <bitwize> It's like the Cartesian product of the greatness of Haskell and that of Gradius.
22:55:40 <dons> heh
22:56:00 <SamB_XP_> bitwize: what do we call the parody?
22:56:01 <ddarius> bitwize: No, there is some quotienting going on.
22:56:16 <brad__> oops sorry don, i was actually just reading your pdf
22:56:21 <dons> ah good!
22:56:23 <dons> comments!
22:56:30 <brad__> looks good for one page!
22:56:38 <dons> yeah, its a 'demo overview'
22:56:45 <dolio> dons: Chan appears to be significantly slower than TChan here.
22:56:53 <brad__> i will probably try the curl stuff tomorrow, just wrestling with hxt tonight
22:56:55 <dons> dolio: huh, i wouldn't have expected that
22:57:14 <dons> `Since 1934, Haskellwhaddya think slava32? s has been providing the finest in wines, beers and spirits to our discriminating clients.'
22:57:25 <dons> weird. tab completion in the middel there :(
22:57:29 <olsner> is a window manager "system software"?
22:57:36 <ddarius> If it is sequential as sorear says, then the optimistic concurrency should win out big.
22:57:38 <dons> yeah.
22:57:58 <sorear> ddarius: That statement makes no sense.
22:58:07 <dolio> dons: 100 threads, 90,000 messages, TChan: 18 seconds, Chan: 2 minutes.
22:58:23 <sorear> ddarius: By inherently sequential I meant inherently unparallelizable.
22:58:33 <ddarius> sorear: So all the locking overhead is useless.
22:58:54 <sorear> ddarius: Only one token exists (and is circled through the list repeatedly), ergo, only one thread can be runnable.
22:58:57 <sorear> Yes.
22:59:11 <sorear> AFAIK, stackless-python is also lockless 1-cpu.
23:00:04 <bitwize> being stackless it also lacks VALUE SEMANTICS
23:00:30 <dons> hah
23:00:31 <glguy> here we go again...
23:00:34 <glguy> ;)
23:01:12 <olsner> what's VALUE SEMANTICS?
23:01:18 <bitwize> I can't help it. It's the most screwed up thing I've heard in a while. Kinda like that stupid furry whose made-up super-CPU had support for "currency floats".
23:01:27 <sjanssen> hmm, STM seems to be performing better than plain old Chan
23:01:41 <glguy> sjanssen: STM's TChan?
23:01:47 <sjanssen> glguy: yeah
23:01:54 <dolio> Oh, wait, my code does something slightly different than the python/erlang.
23:02:03 <bitwize> olsner: Stack-allocated, dynamic-extent values in C and C++ that aren't accessed through pointer indirection.
23:02:41 <ddarius> bitwize: From that Ruby thing?
23:03:00 <dons> i guess qwe doesn't know about unboxed values as first class citizens
23:03:06 <dons> lots of VALUE SEMANTICS in that
23:03:12 <bitwize> ddarius: from a whacked-out reddit troll's quasi-sensical comments.
23:03:25 <dons> i should post it to reddit with a "Haskell for VALUE SEMANTICS" title
23:03:38 <dons> ?go unboxed values as first class citizens
23:03:40 <lambdabot> http://research.microsoft.com/~simonpj/Papers/unboxed-values.ps.Z
23:03:46 <ddarius> bitwize: Ah.  I don't read reddit.
23:03:52 <dons> bloody .ps.Z
23:04:28 <glguy> dons: trying to teach qwe something is like trying to fill the grand canyon using a spoon
23:04:32 <bitwize> xpdf --antialias is your friend
23:04:34 <dons> worse
23:04:47 <dons> bitwize: oh, just that its usualy a bad idea to post .ps.* to reddit :)
23:04:51 <glguy> his ignorance of things he discusses knows no bounds, and the colorado river will sweep away any dirt you dump in
23:04:53 <bitwize> It's like trying to fill a *transfinite* canyon with a spoon.
23:05:31 <olsner> More like trying to fill an infinite canyon with an infinitesmal spoon.
23:05:52 <hpaste>  dolio annotated "stackless benchmark?" with "With TChan + don't spawn 1 thread per message + no IO" at http://hpaste.org/2007#a1
23:06:10 <glguy> is the idea behind stackless python that functions never return?
23:06:22 <glguy> or rather than they aren't blocking
23:06:26 <brad__> qwe is funny
23:06:41 <bitwize> he's the dual of Scott Nudds.
23:06:49 <olsner> isn't that basically just CPS transformation?
23:06:53 <brad__> every message board needs a good troll
23:07:10 <bitwize> and so does every good bridge
23:07:12 <dolio> I thought it was that it doesn't make use of the C stack.
23:07:42 <bitwize> I thought it was that activation records were heap-allocated. (Useful for CPS)
23:07:55 <brad__> glguy - any idea when the curl bindings will be in hackage?
23:08:25 <glguy> brad__: not specifically, but it is planned that they will be
23:08:41 <brad__> cool! this library is badly needed!
23:08:48 <glguy> the code in the darcs repo works
23:08:52 <glguy> if you want to use it
23:08:59 <brad__> i will give it a shot tomorrow night
23:09:00 <glguy> it's just not packaged
23:09:09 <Cale> http://programming.reddit.com/info/2b9gc/comments -- hahahaha
23:09:10 <lambdabot> Title: Haskell support for value semantics: unboxed values as first class citizens (red ...
23:09:20 <Cale> dons: awesome :)
23:09:38 <glguy> "I can has value semantics?"
23:09:42 <dons> http://programming.reddit.com/info/2b9gc/details
23:09:43 <lambdabot> Title: Haskell support for value semantics: unboxed values as first class citizens (red ...
23:09:44 <dons> :)
23:10:13 <brad__> i actually like qwe's rant, a nonsensical work of genius
23:10:23 <dons> of course, a tight loop of unboxed values will never use the garbage collector, nor trigger a scheduler context switch
23:10:27 <dons> since it never allocates
23:10:37 <sjanssen> yeah, STM is a big win for this "stackless" problem
23:10:39 <brad__> the troll wins if you feed the troll!
23:10:50 * glguy encourages everyone to mod don's response up
23:10:51 <dons> brad__: ah, but I'm not feeding him, i'm just submitting useful articles
23:10:58 <dons> the key is to never reply to qwe himself
23:11:50 * glguy doubts that qwe can be bothered to *read an academic paper"
23:12:20 * Korollary can't be bothered to doubt what qwe would or wouldn't do
23:13:10 <brad__> qwe is the master of diversion, he will reply with a note telling you how important he is. being able to change the topic quickly is part of the troll tollkit
23:13:29 <dons> yeah
23:13:42 <dolio> dons: Anyhow, feel free to run that paste on your 8-CPU machine.
23:13:52 * glguy wonders if that toolkit is packaged anywhere
23:14:03 <dons> he'll likely come up with some non sequitur
23:14:08 <dons> which is his usual approach
23:14:17 <dons> dolio: ok. which paste?
23:14:34 <dolio> http://hpaste.org/2007#a1
23:15:16 <bitwize> dons: the important thing though is VALUE SEMANTICS for your non-memory resources like file handles and the like too; that is the correct way to abstract deterministic allocation
23:15:27 <dons> heh
23:15:55 <dolio> Isn't that what bracket is for?
23:16:39 <bitwize> Bracket is a control operator. Control flow has nothing to do with VALUE SEMANTICS. It's a completely different concept.
23:16:49 <dolio> Oh, right.
23:17:02 <dons> so, any comments on the (slightly provocative) system software/xmonad text for the haskell workshop? --> http://www.cse.unsw.edu.au/~dons/tmp/haskell51d-stewart.pdf
23:17:26 <sorear> bitwize: please.  you're only hurting yourself.
23:17:27 <ddarius> dons: I read it but I don't really have anything to say.  It seems like a good hook.
23:17:33 <dons> ddarius: ok. cheers
23:17:38 <bitwize> (I wonder if he's ever tried looking at the assembler emitted by his C++ compiler and noting all the indirection through %esp his functions seem to do?)
23:18:34 <sorear> bitwize: Value semantics has absolutely nothing to do with resource use.  Don't listen to people that dumb.
23:19:03 <bitwize> Yes, yes, I know.
23:19:40 <ddarius> Do dumb people not have feelings too?
23:19:42 <bitwize> dons: does xmonad deterministically allocate screen space? That's the single most important thing a window manager should do XD
23:20:24 <sjanssen> bitwize: yes, all of the core layouts are deterministic
23:20:28 <sjanssen> with very trivial rules
23:20:41 <bitwize> Cool!
23:20:41 <dolio> @quote fiber
23:20:42 <lambdabot> qwe1234 says: next up: lisp has more fiber.
23:21:16 <glguy> dons: what is an example of a bug in xmonad discovered with QuickCheck?
23:21:35 <dons> bitwize: yeah, the QC is all about ensuring deterministic behaviour
23:21:50 <sorear> dons: uhm... doesn't purity suffice?
23:22:09 <dons> sorear: well, you could do simulated annealing, for /complex/ behaviour
23:22:13 <sorear> it's already proven correct!
23:22:24 <dons> so its not just deterministic, but also simple, semantics
23:22:34 <sorear> dons: pure functions are deterministic, even ones that do SA
23:23:11 <sorear> (I am of course ignoring compiler bugs and unsafePerformIO...)
23:23:34 * ddarius writes a binding to set an absolute predefined layout and to pack absolutely sized tiles into that layout minimizing empty space.
23:23:45 <dons> glguy: there have been bugs, but none long term because you can't commit without getting QC's ok.
23:23:56 * glguy saw someone riding a Segway in the bike lane on his way home
23:23:56 <dons> so i can't think of any major bug found by QC, just the legion /prevented/ by QC
23:24:17 <bitwize> nice co-problem dons.
23:24:41 <dons> there was a bug recently that was unnoticed, because the QC property for it wasn't written
23:24:46 <ddarius> How are you supposed to make money if you don't spend 90% of your time debugging?
23:24:54 <dons> ah, that's true
23:24:57 <glguy> what was it
23:25:00 <dons> advertising revenue
23:25:04 <bitwize> (I have taken to calling computer programs "co-problems" because they are the solution to a specific problem, and hence the dual of that problem.)
23:25:40 <dons> glguy: there was a corner situatoin when removing the last window in a list, would cause the rest of the list to be reordered. it occured when we refactored some delete code into a common function, filter, which didn't have a QC for it
23:25:58 <dons> so i shouldn't accept patches without QC test.
23:26:01 <jfredett> bitwize: thats about the silliest thing I've heard all day, I love it, I'll use it forever
23:26:13 <dons> bitwize: that's just wacky
23:28:05 <nornagon> is it possible to import a svn repo into darcs? contacting the server for 'svn log' really sucks.
23:28:15 <dons> i think tailor does that?
23:28:16 <bitwize> A bit of generalized-abstract-nonsense humor. :)
23:28:38 <sorear> Yow.
23:29:03 * sorear just came up with a trivial algorithm for allowing partially-applied type synonyms in instance heads
23:29:26 <ohub> nornagon: With Tailor you can sync svn to Darcs
23:29:29 <bitwize> oooo.
23:29:41 <ddarius> sorear: My impression is that there is no difficulty doing it.
23:29:42 <nornagon> ohub: can I commit stuff back as well?
23:30:18 <nornagon> yo kfish
23:30:22 <ohub> nornagon: There's a descriptions of some two-way sync schemes in Tailor's wiki
23:30:33 <kfish> hi nornagon :-)
23:31:04 <dons> nornagon: ah yes, that reminds me, pugs runs simultaneous darcs/svn repos, using tailor
23:31:35 <nornagon> neat.
23:34:00 <ddarius> sorear: Yeah, I figured the Gofer code was simply "pedagogically" written or some such.
23:34:51 <nornagon> beh, i don't know if i care enough to work out how to use tailor and maintain a syncing system
23:34:59 <nornagon> i might just install svk
23:35:10 <nornagon> and try to work out how to get it to do sane commit messages
23:35:15 <fuxxx> it's not allowed to have several modules within the same file? i am solving a set of programming exercises and i'd like to keep it all within the same file cause there are a lot of them, they're not that big, and i'm going a bit back and forth.. but i'd also like separate namespaces since they're rather independent (but not entirely). it just keeps giving me "syntax error/unexpected keyword: "module".."
23:35:40 <ohub> nornagon: There's also this: http://weblog.masukomi.org/2007/5/23/using-darcs-with-svn-cvs-flow-chart
23:35:43 <lambdabot> Title: weblog.masukomi.org Using Darcs with SVN / CVS Flow Chart, http://tinyurl.com/36lxau
23:36:49 <Saizan> fuxxx: no implementation supports multiple modules per file
23:37:22 <dons> fuxxx: perhaps just use lots of functions in one file
23:37:28 <dons> rather than modules
23:37:29 <SamB> it would be a bit tricky to find modules that way
23:37:32 <SamB> after all
23:38:11 <nornagon> ohub: oh, that's pretty neat.
23:39:02 <fuxxx> :/ ok. is there some other namespace mechanism i can use? i just don't want to go like p1_... p2_... p60_... on definitions which will not be used by other problems to enforce my own "namespaces" for the different problems. (very ugly.)
23:39:41 <nornagon> ohub: only problem is that you don't get the svn history in darcs
23:39:50 <nornagon> or at least, not for free
23:39:55 <ddarius> fuxxx: Use local functions?
23:40:24 <SamB> nornagon: don't you?
23:40:29 <SamB> isn't that what tailor is for?
23:40:52 <nornagon> SamB: i was talking about the flow chart ohub linked
23:41:11 <fuxxx> ddarius, you mean like p1_solution = ... where { my "namespace" here } ? hmm that could work :)
23:41:24 <nornagon> i suppose that has 'svn up; darcs record -m "<svn message>"' in it
23:42:16 <nornagon> but you'd need to a bit of extra work to get the whole history into darcs
23:42:16 <nornagon> like, do that one revision at a time from rev1
23:45:05 <ddarius> Lambda The Ultimate Module System
23:55:23 <dons> dolio: what values of n and m did you supply?
