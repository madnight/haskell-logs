00:00:03 <wli> Recompile with -prof and run with +RTS -xc?
00:00:15 <opqdonut> -auto-all too i guess
00:00:21 <sorear> -hX, actually
00:00:38 <sorear> where X is one of the heap profiling mode characters, see the manual
00:00:49 <opqdonut> ?bot
00:00:50 <lambdabot> :)
00:00:55 <opqdonut> yay lambdabot's back!
00:01:00 <opqdonut> ?botsnack
00:01:00 <sorear> http://haskell.org/ghc/dist/current/docs/users_guide/prof-heap.html
00:01:00 <lambdabot> :)
00:01:06 <lambdabot> Title: 5.4. Profiling memory usage, http://tinyurl.com/28cfq7
00:02:47 <wli> Checking it out with -hc
00:05:29 <wli> sorear: http://holomorphy.com/~wli/haskell/bernoulli/berndrv.pdf
00:07:18 * wli dumps memoizing binomial coefficients and sees what happens.
00:08:27 <wli> That was pretty simple.
00:10:40 <wli> Yeah, it looks like it was almost all binomial coefficients.
00:10:54 <sorear> hah.
00:11:08 <sorear> you weren't calling lookupBinomial
00:11:23 <wli> sorear: ARGH
00:11:25 <sorear> so the Map was never forced, and became a huge chain of insert thunks
00:11:47 <opqdonut> :)
00:11:48 <opqdonut> cute
00:12:06 <sorear> btw, using CAFs instead of Map/State would probably result in cleaner code (faster I can't attest to)
00:12:13 <sorear> @oldwiki MemoizingCAFs
00:12:14 <lambdabot> http://www.haskell.org/hawiki/MemoizingCAFs
00:12:26 <opqdonut> sorear: 404
00:12:26 <db2k> ok im officially desperate - has anyone here encoded any x264 movies :/
00:13:11 <opqdonut> sorear: what's CAF?
00:13:38 <sorear> db2k: seems pretty OT.  #haskell-blah?
00:15:11 <db2k> sorear i guess im noob around here
00:15:13 <db2k> OT?
00:15:17 <db2k> off topic?
00:15:33 <opqdonut> yeh
00:15:52 <sorear> http://web.archive.org/web/20060902215437/http:/www.haskell.org/hawiki/MemoisingCafs
00:15:54 <lambdabot> Title: MemoisingCafs - The Haskell Wiki, http://tinyurl.com/yvlsd8
00:16:03 <wli> sorear: Well, CAF would be retained across too many invocations. If the state's explicit, then when to throw away data (and recompute) has some element of control.
00:16:36 <sorear> wli: you could use a Reader then; no need for return*
00:17:09 <wli> sorear: Interesting. I'm not sure how that would work.
00:17:24 <roconnor> :'(
00:17:44 <roconnor> how do I write a DNA machine in Haskell that can process endo.dna in less than 5 minutes?
00:18:54 <wli> sorear: Oh, if it's what I think you mean, using reader internally wouldn't fit in with the intended usage model, either. It's not meant for one-shot affairs, but for sequences of them in the caller. Like the caller doing sums involving Bernoulli numbers wanting the internal memoizing to persist across the individual invocations.
00:19:30 <sorear> let t = bernoulli () in bnum t 12 + bnum t 13
00:19:32 <sorear> maybe
00:19:45 <sorear> (the () is essential)
00:20:14 <wli> sorear: The same basic idea, only done up with a state monad.
00:20:36 <sorear> And using explicit Maps instead of laziness.
00:21:16 <opqdonut> sorear: would you mind explaining the "() ->" idiom? is it intended to effect evaluation somehow?
00:21:19 <dons> roconnor: massive parallelism?
00:22:03 <sorear> dons: not in 3 days, the dna machine is (apparently) sequential
00:25:04 <roconnor> dons: perhaps that could speed up searching
00:25:14 <roconnor> but I'm not sure I'm spending much time doing that.
00:25:31 <roconnor> Profiler output is hard for me to interpret.
00:25:53 <roconnor> It says I spend most of my time in consume.
00:26:06 <roconnor> But consume is so trivial.
00:26:31 <roconnor> consume = do
00:26:31 <roconnor>   x <- get
00:26:31 <roconnor>   when (DNA.null x) $ trace "Done!" $ throwError Done
00:26:31 <roconnor>   put (DNA.tail x)
00:26:31 <roconnor>   return (DNA.head x)
00:26:36 <dons> oh wow, http://www.smh.com.au/news/web/nerd-taunt-tragedy/2007/07/27/1185339229707.html
00:26:38 <lambdabot> Title: 'All I did was call him a nerd and he came to kill me' - web - Technology, http://tinyurl.com/333bd5
00:26:41 <dons> don't mess with people on IRC.
00:26:52 <sorear> roconnor: what's the DNA type?
00:26:58 <sorear> s/type/module/
00:27:37 <sorear> 302450 RNA commands, and has a cost of 192646205. It seems particularly important to
00:27:40 <sorear> ensure that performing skips and appending unquoted references perform better than in
00:27:43 <sorear> linear time.
00:27:46 <sorear> btw
00:27:47 <roconnor> sorear: F.FingerTree (Sum Int64) ByteString.
00:30:16 <sorear> roconnor: Perhaps you should make a readily-available ByteString for use as a read buffer, aliasing the rest of the current block?
00:30:24 <wli> When there are enough Bernoulli numbers to compute this already did better than Oleg's Bernoulli number code.
00:31:37 <roconnor> sorear: I thought head of a finger tree was  O(1)
00:32:18 <sorear> roconnor: yeah, but it's at least two sum indirections
00:32:31 <roconnor> hmm
00:32:33 <sorear> and sum indirections can't be unboxed in current ghc
00:32:54 <roconnor> sum as in union type?
00:32:54 <sorear> ie, you're paying for four indirect jumps per consume
00:33:01 <sorear> 2+ constructors
00:35:28 <wli> sorear: I'm not so sure how to ensure the results of the partial sums are shared like they should be.
00:40:56 <wli> It's basically doing let { args = [2,4,8,16] ; bs = flip evalState initBernoulliState $ sequence [bernoulli' $ 2*p | p <- take (maximum args) primes] ; bsSums = List.map sum $ inits bs } in mapM_ print $ zipWith (!!) (repeat bsSums) args
00:41:33 <wli> bsSums = List.map sum $ inits bs -- the offending piece; I think this may re-sum the whole affair inappropriately.
00:44:09 <nornagon> I wish erlang had a type system as expressive as Haskell's. :(
00:45:49 <dons> isn't erlang with a type system =~ haskell?
00:45:59 <Cale> wli: make sure it has a monomorphic type
00:46:15 <nornagon> dons: istr haskell not having as much magical multiprocess stuff
00:46:17 <dons> nornagon: you doing some erlang work? how're you finding it?
00:46:24 <nornagon> dons: not much, just dabbling :)
00:46:30 <sorear> dons: I think it also has ad-hoc language level concurrency support. :D
00:46:40 <dons> indeed
00:46:45 <Cale> wli: then perhaps add an SCC to the expression and check that there's only one entry, or add a Debug.Trace.trace, if you still suspect it of recomputing.
00:46:54 <dons> we have libraries and ad hoc language runtime primitives
00:47:02 <sorear> in haskell it's all just more combinators.
00:47:11 <dons> the main issue is distribution and fault tolerance
00:47:30 <dons> not threading itself: we probably win already on threading, just by supporting SMP on more archs, as well as optimised native code.
00:47:44 <wli> Cale: mapAccumL seems to be a better idea.
00:47:46 <etnt> I've been thinking: why not generate Erlang code from (a subset) of Haskell?
00:47:48 <dons> distributed haskell is pretty much reserved to about 5 people
00:48:01 <nornagon> dons: isn't threading stuff in haskell pretty much a manual thing?
00:48:04 <dons> etnt: hmm. i've been pondering erlang glue for haskell.
00:48:10 <Cale> wli: Oh!
00:48:11 <dons> nornagon: hmm, no?
00:48:20 <etnt> http://blog.tornkvist.org/
00:48:23 <dons> we have all the way up to fully implicit paralellism.
00:48:24 <Cale> wli: yes, or scanl
00:48:33 <Cale> wli: scanl (+) 0
00:48:38 <dons> practically, people still write forkIO/STM code, but that's already high level threading
00:48:41 <nornagon> dons: oh, nifty... code examples? :)
00:49:01 <Cale> wli: It's certainly not going to share the sums, because it's summing different lists.
00:49:07 <dons> the full list is here (how do people not know this?) http://haskell.org/haskellwiki/Applications_and_libraries/Concurrency_and_parallelism
00:49:10 <lambdabot> Title: Applications and libraries/Concurrency and parallelism - HaskellWiki, http://tinyurl.com/2u95za
00:49:16 <dons> i think we need to brand parallel haskell a bit stronger.
00:49:20 <wli> Cale: scanl (+) 0 yeah
00:49:28 <Cale> wli: (and those lists don't even have a common tail)
00:52:10 <wli> Cale: Looks like most of it is spent caching Bernoulli numbers now.
00:52:27 <roconnor> dons: yeah, just don't try to block on file IO :P
00:52:42 <Cale> ugh, gmail has a *really* annoying bug where if you close your gmail account while there is a chat window open in another tab, it pops up a message saying "All chat windows will be closed", and then closes the whole browser window, irrespective of whether there are any other tabs open.
00:53:03 <Cale> This is annoying for more than one reason :)
00:54:45 <dons> roconnor: you don't use threadWaitRead :: Fd -> IO ()
00:54:47 <dons> ?
00:56:15 <roconnor> Oh I'm not sure.
00:56:24 <roconnor> I remember having some network issues
00:56:38 <roconnor> where one thread go blocked by the OS, so all threads were blocked.
00:57:02 <roconnor> But I must admit I don't recall the details.
00:57:12 <dons> hmm, you had a `safe' foreign call that blocked on IO, perhaps
00:57:26 <wli> Cale: scanl (+) 0 looks good.
00:58:02 <roconnor> dons: this was just using the standard network interface.
00:58:30 <wli> I remember having issues with file handle closing behavior, perhaps a leak in the std. libs.
00:58:43 <wli> But AIUI I complained and they were fixed.
00:58:54 <wli> s/AIUI/IIRC/
02:59:28 --- topic: '["OSCON Videos http://tinyurl.com/22avoy ","The Haskell programming language: got types?","Home: http://haskell.org","Paste: http://hpaste.org","Logs: http://tunes.org/~nef/logs/haskell/","The language of ICFP winners 3 years running"]'
02:59:28 --- topic: set by glguy on [Fri Jul 27 19:52:22 2007]
03:00:00 <wli> At some point when I feel like learning ByteString or whatever I'll investigate it.
03:00:07 <Lemmih> roconnor: What did you change?
03:00:42 <roconnor> modifyl :: (Measured v a) => (a -> a) -> FingerTree v a -> FingerTree v a
03:00:46 <roconnor> and modifyr :: (Measured v a) => (a -> a) -> FingerTree v a -> FingerTree v a
03:00:57 <roconnor> to modify the head and tail of a finger tree.
03:01:24 <roconnor> this should be a little faster than uncons followed by cons.
03:01:58 <roconnor> although both are O(1)
03:04:25 <wli> "Compressed Image File Formats" by John Miano
03:07:57 <wli> I've been dissatisfied with a lot of the file formats and filesystems out there and have been sort of itching to push Reed-Solomon codes (hence the interest in GF(2^n)).
03:13:58 <koala_man> ?hoogle (a -> b) -> Maybe a -> Maybe b
03:13:59 <lambdabot> No matches, try a more general search
03:16:54 <koala_man> any suggestions? I want to apply a function if it's Just x, or leave it at Nothing if it's not
03:17:21 <wli> koala_man: maybe Nothing f
03:17:30 <wli> koala_man: or fmap f
03:17:43 <Cale> koala_man: fmap
03:17:46 <koala_man> great, thanks
03:18:17 <Cale> koala_man: Also, look into possibly using Maybe as a monad, if you have a lot of Maybe unboxing to do.
03:23:25 <thorkilnaur> nominolo_, Thanks for your -L/opt/local/lib advice concerning Gtk2Hs yesterday, it worked: http://www.haskell.org/pipermail/haskell-cafe/2007-July/029653.html
03:23:27 <lambdabot> Title: [Haskell-cafe] Using Gtk2Hs version 0.9.12 on a PPC Mac, http://tinyurl.com/yr44hh
03:26:38 <Lemmih> roconnor: Is it still slower than Seq?
03:30:37 <roconnor> Lemmih: I haven't tested it yet
03:34:02 <roconnor> Lemmih: the good researcher in me has said I need to rerun the program without the change first.
04:05:58 <nominolo_> thorkilnaur: cool, nice work
04:10:12 <Magotari> Good morning #haskell. I was here yesterday, requesting help with starting learning the language.
04:10:35 <Magotari> I have only python experience, but want to try something new.
04:10:58 <Magotari> Could someone give me the links to the non-pdf YAHT? I did not write them down.
04:11:20 <nominolo> @where yaht
04:11:20 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
04:11:44 <Magotari> Yes, but this is in a pdf... I cannot read that, at least untill I emerge some pdf viewer.
04:12:14 <Magotari> I guess I will though. Thanks for the link.
04:12:18 <nominolo> http://en.wikibooks.org/wiki/Haskell/YAHT
04:12:19 <lambdabot> Title: Haskell/YAHT - Wikibooks, collection of open-content textbooks
04:12:28 <Magotari> Ah, thank you.
04:12:40 <nominolo> moconnor: xpdf is fine too, i guess
04:13:09 <wolverian> evince :)
04:16:09 <nominolo> it's amazing how much better the font drawing on macos is, than what gtk does.  i guess it's all those patents that prevent gtk from catching up ..  :/
04:17:48 <matthew-_> yeah, I find the best renderer of fonts in Linux is acroread
04:19:04 <Cale> Really? I like the font rendering in Ubuntu.
04:19:24 <Cale> (and I've used Mac OS X machines for months on end too)
04:19:32 <nominolo> Cale: you need to compare it side by side
04:20:38 <Cale> OSX seems to hint poorly (not at all?), making small point sizes a bit harder to read (not that Linux's hinting is perfect either)
04:20:49 <wolverian> I prefer non-hinted fonts
04:21:01 <wolverian> at least on monitors with higher than 1024x768 resolutions :)
04:21:37 <Cale> I'm pretty sure you could configure FreeType to ignore hints if you really wanted to, but I'd need to look that up.
04:21:41 <nominolo> Cale: i completely disagree with that article of joel, i always hated if fonts appeared thinner or thicker
04:21:56 <nominolo> wolverian: yep
04:22:01 <wolverian> Cale, gnome's font configuration panel lets you do it.
04:22:21 <nominolo> with 100+ dpi hinting sucks because pixels get too small
04:22:24 <wolverian> oh, and if you do disable hinting -- also disable subpixel antialiasing
04:22:36 <wolverian> otherwise you get terrible fringing, at least with freetype
04:22:46 <wolverian> apple's renderer might be better.
04:22:47 <Cale> nominolo: I suppose it depends on what you're doing. If I'm editing graphics, sure, I agree.
04:23:06 <Cale> But reading web-pages, I prefer the hinted varieties.
04:23:13 <wolverian> nominolo, gtk doesn't draw fonts. it's freetype.
04:23:31 <nominolo> Cale: i usually read at larger font-sizes anyways, so i prefer it in any case ;)
04:23:35 <Cale> nominolo: Hinting can take into account your actual resolution.
04:23:45 <wolverian> Cale, gnome lets you pick between four hinting strengths (from "none" to "full") -- I assume you can talk to freetype directly about it too, if you're not using a gui thing like that
04:24:12 <Cale> Oh, yes, I see that.
04:24:17 <Cale> Nice.
04:24:21 <Gwern-away> so, I need this function  foo :: [Int] -> [a] -> [a] in which the list of ints are positions in the list of [a] and which will filter out any positions in [a] not listed as an [int] (so one could go foo [5..10] [500..] and get back [505..510], for example. I'
04:24:25 <Cale> So you can make it look just like the Mac :)
04:24:35 <Gwern-away> ve hacked together something involving map and !! but I'm sure there's a better way
04:24:37 <Gwern-away> any ideas?
04:25:20 <Cale> Gwern-away: Sure.
04:25:37 <Cale> Gwern-away: Is the first list guaranteed sorted?
04:26:05 <Cale> What is  foo [3,2,1] "Hello" ?
04:26:19 <Gwern-away> Cale: it could be; it wouldn't be hard to throw in a where clause sorting it
04:26:19 <Cale> or  foo [3,2,1,1] "Hello" ?
04:26:34 <wolverian> Cale, oh, and note that gecko browsers at least don't change the mode live, unlike gtk apps. :(
04:26:38 <wolverian> (you have to restart the browser)
04:26:49 <Cale> Depending on the precise semantics, you can make it fairly fast.
04:26:51 <Gwern-away> Cale: both should give l e h
04:27:03 <Cale> Gwern-away: ah, okay
04:27:21 <Cale> Gwern-away: In that case, you're not going to be able to do better than O(n*m)
04:27:42 <Cale> hmm...
04:28:01 <Cale> actually, no, you can do it in O(n*log(m)+m)
04:28:22 <Cale> Convert the second list into a Data.Map indexed by position, and then do lookups
04:28:40 * Gwern-away takes notes
04:29:04 <Cale> er, that's O(n*log(m) + m*log(m))
04:29:57 <Cale> oh, I was right the first time, there's fromAscList :)
04:30:49 <Gwern-away> hmm. fromasclist claims to be O(n)
04:31:03 <Gwern-away> wonder what happens when input isn't sorted like it requires?
04:31:15 <Cale> bad things
04:31:26 <Cale> but your input, namely zip [0..] y will always be
04:33:00 <roconnor> @go 3376.60 secs in min
04:33:02 <lambdabot> http://sec.edgar-online.com/2004/04/15/0001104659-04-010184/Section5.asp
04:33:02 <lambdabot> Title: YAMAHA MOTOR RECEIVABLES CORP Unscheduled Material Events (8-K) EXHIBIT 5.1
04:33:09 <roconnor> @go 3376.60 s in min
04:33:12 <lambdabot> http://finance.yahoo.com.au/q/hp?s=%5EATLI
04:33:12 <lambdabot> Title: ^ATLI: Historical Prices for S & P/ASX 20 - Yahoo!7 Finance - Share Prices, Char ...
04:33:19 <roconnor> @go 3376.60 s in minutes
04:33:20 <lambdabot> 3,376.60 seconds = 56.2766667 minutes
04:33:33 <Cale> foo x y = map (flip Map.lookup table) x where table = Map.fromAscList (zip [0..] y)
04:35:19 <Saizan> catMaybes $
04:35:22 <Gwern-away> Cale: thanks. I'll work on it from there (in case anyone was wondering, I was going to use this to implement a simple version of the coreutil 'cut' which would accept ranges and not single Ints)
04:36:49 <Cale> If you guarantee that the indexing list is sorted, you can do it in O(n+m) time, by "walking".
04:38:03 <Cale> I don't think I could come up with a clever combinator version of that, I'd probably just implement it recursively.
04:38:18 <Cale> (but I'd still zip the string with its indices)
04:39:20 <wli> Hmm, all substrings of a given string of some length or less.
04:39:34 <Cale> Oh, heh, you could also just smash the string into a big array
04:39:56 <Cale> That seems like the obvious thing to do, now that I think of it :)
04:43:03 <Cale> foo x y = map (table !) x where table = listArray (0,length y) y -- seems you can't avoid the length computation though
04:43:39 <Cale> er, should be length y - 1
04:50:28 <wli> What would be an efficient way to find a frequency histogram for substrings of lengths between lo and hi in a very long string, hmm.
04:52:38 <matthew-_> wli: some sort of MArray ?
04:53:23 <wli> matthew-: Indexed by what?
04:53:36 <matthew-_> Int
04:53:39 <matthew-_> oh, well,
04:53:50 <matthew-_> I don't know what optimisations GHC does for, say, Int16s
04:54:09 <matthew-_> if hi < 2^15 -1 then Int16 /might/ be faster
04:54:11 <matthew-_> I've no idea
04:55:05 <Cale> <AdrianAdonis> randomly pull one ball out of a bottle (bottle1) containing 5 white balls + 1 black ball and then put the ball you got from bottle1 in bottle2 which contains 2 white balls + 1 black ball,  then randomly pull 1 ball from bottle2 and put it in bottle3 which contains 3 white balls. Now if you randomely pull 1 ball from bottle3, what is the probability that the ball you pull from bottle3 is black?
04:55:10 <matthew-_> You really want it unsigned. You could try Word16 but I've no idea what happens to the generated code - all the fromInteger calls may not be optimised out. Without looking at the generated code, I don't know
04:55:13 <wli> Well, I want to enumerate n most frequently-occurring substrings etc.
04:55:13 <Cale> > let results = do {let {bottle1 = "wwwwwb"; bottle2 = "wwb"; bottle3 = "www"}; ball1 <- bottle1; let {bottle2' = ball1 : bottle2}; ball2 <- bottle2'; let {bottle3' = ball2:bottle3}; bottle3'} in map length [filter (=='b') results, results]
04:55:15 <lambdabot>  [7,96]
04:55:53 <wli> The naive approach of generating all substrings and counting is failing me.
04:56:02 <Cale> :)
04:56:14 <Cale> (was a question in #math a little while ago)
04:56:27 <matthew-_> Cale: that's a really lovely use of list monad.
04:56:54 <matthew-_> Cale: if you keep that up, people will start thinking that SQL as a String isn't a bad thing!
04:57:35 <wli> do { s <- readFile "/home/wli/books/Latin/De_Bello_Gallico-Caesar" ; mapM_ print $ take 10 $ sortBy (\(n, x) (k, y) -> (k * length y) `compare` (n * length x)) $ hist 4 8 s } --> Interrupted.
04:57:52 <matthew-_> wli: ok, I think I misread your question then
04:58:20 <matthew-_> sortBy is O(n^2) isn't it?
04:58:41 <Lemmih> roconnor: Is your robe code online?
04:58:48 <wli> Yeah.
04:59:29 <matthew-_> wli: then don't sort. Chuck them into an array. That will take you down to O(n)
04:59:47 <Cale> wli: Maybe somehow generate the strings you want to count and use  Map.fromListWith (+) (zip [1,1..] xss)
05:00:01 <wli> matthew-: How am I supposed to the selection?
05:00:07 <matthew-_> as array access is O(1). Counting the lengths of the substrings is still O(n) though, so you could try Data.Sequence which is O(1) in length
05:00:49 <matthew-_> wli: um. You just want every substring from length 4 to 8 don't you?
05:01:22 <matthew-_> wli: it's quite possible I've misunderstood your problem
05:01:22 <Cale> You just don't generate the strings of incorrect lengths.
05:01:52 <wli> I need some sort of priority queue.
05:02:16 <matthew-_> wli: you can use Data.Sequence as a priority queue
05:02:18 <matthew-_> which is fast too.
05:02:35 <matthew-_> (you may need to read the paper though!)
05:02:55 <wli> I'm not sure Data.Sequence admits an explicit priority key.
05:03:06 <matthew-_> wli: they talk about it in the paper...
05:03:22 <matthew-_> but, iirc, it's priority on max etc
05:03:37 <Cale> Er, I thought that was finger trees specifically
05:03:43 <Cale> not the application to sequences?
05:03:48 <Cale> But I might be wrong.
05:03:54 <matthew-_> Cale: I think you're right
05:04:07 <Cale> In any event, you can get Data.FingerTree from hackage.
05:04:09 <matthew-_> Cale: but Data.Sequence is 2-3 finger trees
05:04:24 <Cale> I know
05:04:38 <matthew-_> ahh, ok, so I didn't know about the explicit package in hackage
05:04:48 <matthew-_> I do love how most of the haskell documentation is in the form of papers. If there's one way to ensure a language isn't widely used, it must be to only document libraries through academic papers.
05:05:27 <wli> Well, what you have is something like Queue elt prio kind of like Map key elt and you need a reprioritization operation.
05:05:51 <Cale> matthew-_: I like that too. It slows uptake of the language in the general public :)
05:06:50 <dcoutts> thorkilnaur: that's very interesting, thanks!
05:06:55 <wli> You sort of need the 1:N relation explicitly represented.
05:07:59 <Cale> Have there been any updates on the other SPJ video?
05:08:36 <matthew-_> Cale: hopefully no one will notice when Haskell takes over the world as it'll have happened slowly and with great subtlety
05:09:13 <Cale> matthew-_: ... and only after the Prelude's been rewritten at least once more.
05:09:20 <matthew-_> agreed ;-)
05:11:18 <wli> The operations that come up are insertNew :: String -> Rel -> Rel {- always at prio 1 -} ; updatePrio :: String -> (Int -> Int) {- prio -} -> Rel -> Rel ; dequeue :: Rel -> (Rel, [String], Int {- prio -})
05:13:26 <wli> scratch updatePrio; try incPrio :: String -> Rel -> Rel {- updates prio with (+1) -}
05:13:54 <Cale> wli: You could use a Map for that, perhaps
05:13:56 <wli> And that subsumes insertNew too, really.
05:14:23 <Cale> hmm
05:14:25 <wli> Hmm. dequeue may not need very much work if there aren't so many distinct possibilities.
05:15:23 <wli> If, OTOH, they're prioritized by length * number of occurrences, then there's more trouble.
05:15:48 <wli> But not so much more if the lengths are tightly bounded.
05:27:36 <wli> Well, now I get a prompt stack overflow.
05:35:01 <nopcode> which haskell datastructures are suited for extracting a minimum element?
05:35:07 <nopcode> like, a priority queue
05:35:12 <nopcode> i think someone mentioned sets?
05:36:05 <mm_freak> pre-ordered lists or pre-ordered sets
05:36:28 <mm_freak> that makes adding O(n), but extracting O(1)
05:37:23 <opqdonut> programming a heap might be a good idea
05:37:37 <hpaste>  wli pasted "stack overflow woes" at http://hpaste.org/1913
05:38:39 <wli> The trick with priority queues is that you so often need them tied into other structures or prioritized in funny ways.
05:39:18 <wli> So you need the same object in some sort of lookup structure as well as prioritized in some queue.
05:39:30 <nopcode> wli: yeah
05:39:50 <nopcode> in this case i would need to be able to lookup a given object in the priority queue and change it's priority (or remove and re-insert it)
05:40:07 <Cale> oy, perhaps there are too many of a single word?
05:40:31 <wli> nopcode: Yes, that's also a bare minimum requirement.
05:40:35 <Cale> (and the (+) chain that's building up is getting too long?)
05:40:55 <nopcode> wli: well.. depends
05:41:03 <nopcode> sometimes you actually only need a priority queue
05:41:22 <wli> Cale: Could be, though substrings of length 4 are probably not likely to hit that.
05:41:30 <nopcode> but it seems there isn't any datastructure like that?
05:41:35 <wli> Cale: More likely the Map is too bloody huge.
05:44:34 <nopcode> btw how do you "remove" an element from a list?
05:44:42 <wli> It's relatively swift on smaller files (e.g. the source of the module).
05:44:46 <wli> nopcode: delete
05:44:52 <nopcode> say i want to remove the minimum element of a list, according to an evaluation function
05:44:57 <nopcode> wli: and what do you pass it?
05:45:13 <wli> @type delete
05:45:17 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
05:45:18 <nopcode> i mean theres minimumBy but that return the _value_ doesnt it?
05:45:30 <nopcode> wli: i suppose that deletes any element with that value?
05:45:30 <wli> > delete 3 [1..5]
05:45:34 <lambdabot>  [1,2,4,5]
05:45:41 <nopcode> what if theres multiple ones?
05:45:43 <wli> > delete 3 [1,2,3,3,3,4,5]
05:45:45 <lambdabot>  [1,2,3,3,4,5]
05:45:51 <nopcode> ok ic :)
05:45:57 <Cale> > filter (/= 3) [1,2,3,3,3,4,5]
05:45:59 <lambdabot>  [1,2,4,5]
05:46:02 <nopcode> well i suppose thats good enough
05:46:14 <nopcode> although it would have to traverse the list twice
05:46:19 <nopcode> once to find it, once to delete it
05:46:20 <Cale> Really, if you're doing a lot of that, you don't want a list.
05:46:25 <nopcode> Cale: but?
05:46:48 <nopcode> well i was wondering about priority queues, yeah but it seems there aren't any
05:46:54 <Saizan> a [multi]set?
05:47:05 <Cale> Yeah, a Set would work.
05:47:08 <nopcode> what's it do?
05:47:11 <Cale> (unless order matters too)
05:47:16 <nopcode> Cale: no
05:47:19 <nopcode> order doesn't matter
05:47:28 <nopcode> i mainly need to be able to extract a minimum element
05:47:32 <Saizan> ?docs Data.Set
05:47:32 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Set.html
05:47:34 <Cale> do you need to have multiple of the same element?
05:47:35 <nopcode> k
05:47:43 <nopcode> Cale: hmmm
05:47:50 <Cale> Data.Set will let you find the min in log time
05:47:54 <nopcode> Cale: maybe..
05:47:55 <Cale> and delete it
05:48:00 <nopcode> Cale: ahh ok that's something
05:48:04 <nopcode> how?
05:48:07 <Cale> deleteFindMin :: Set a -> (a, Set a)
05:48:07 <Cale> O(log n). Delete and find the minimal element.
05:48:10 <wli> I'm not sure there are any convenient multiset implementations out there, but I think people mostly use Map t Integer with ins x m = insertWith (+1) x 1 m
05:48:12 <nopcode> i mean how is it implemented?
05:48:19 <Cale> nopcode: A balanced tree.
05:48:30 <Cale> http://swiss.csail.mit.edu/~adams/BB/
05:48:31 <lambdabot> Title: Weight balanced binary trees
05:48:52 <nopcode> ok
05:49:01 <nopcode> and how do i specify what ordering function to use?
05:49:03 <nopcode> to build the tree?
05:49:09 <wli> You don't get to.
05:49:11 <nopcode> cooking brb
05:49:13 <nopcode> wli: uh?
05:49:15 <Cale> It's ordered by the Ord instance.
05:49:25 <Cale> So if you want a non-default order, you'll need to use a newtype
05:49:32 <nopcode> ..
05:49:43 <wli> Well, the Map version works on small files, though even moderately larger files need help.
05:50:05 <wli> $ wc ~/books/Latin/De_Bello_Gallico-Caesar
05:50:05 <wli>   2807  22226 161875 /home/wli/books/Latin/De_Bello_Gallico-Caesar
05:50:11 <wli> That's not a large file.
05:50:31 <Cale> nopcode: Do you know what I mean, or would you like to see an example?
05:52:12 <nopcode> Cale: well the concept is similar to C++
05:52:18 <nopcode> but i wouldn't know the syntax ;)
05:52:24 <nopcode> actually... hm
05:52:28 <Cale> oh
05:52:29 <Cale> okay
05:52:44 <Cale> If you don't know about typeclasses yet, that may be a little issue :)
05:52:58 <wli> There are 256^4 + 256^5 + 256^6 + 256^7 + 256^8 = 256^4*(1+256+256^2+256^3+256^4) = 256^4*(256^5-1) `div` 255 ~= 2**64 possible strings of length between 4 and 8...
05:53:20 <Cale> Types get ordered by being instances of the Ord class.
05:53:39 <Cale> To make something an instance of the Ord class, you have to come up with an implementation of compare
05:53:45 <Cale> :t compare
05:53:47 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
05:53:57 <Cale> data Ordering = LT | EQ | GT
05:54:11 <Cale> To do this, you write something like:
05:54:18 <Cale> instance Ord MyType where
05:54:24 <Cale>    compare x y = ...
05:54:39 <nopcode> i see
05:54:42 <Cale> Then the newtype bit...
05:55:15 <nopcode> oh btw
05:55:16 <Cale> When you create a newtype, what you're doing is creating a type which is implemented exactly the same way as an existing type, but looks different to Haskell's type system.
05:55:22 <wli> Something tells me I should probably be using a smaller radix.
05:55:31 <nopcode> map allows two different items to be identical according to the comparison?
05:56:13 <Cale> hmm... if you define a compare which isn't a total ordering, I think that Set and Map can do funny things
05:56:42 <Cale> I don't recall exactly which funny things they do.
05:57:29 <Cale> However, if compare returns EQ whenever you really do want those values to be treated as equal, you're probably going to be okay.
05:57:54 <nopcode> no that's not the case
05:58:03 <Cale> hmm
05:58:07 <nopcode> they'd only be equally valued in terms of minimum but not necessary equal
05:58:23 <Cale> oh
05:58:38 <nopcode> it's like a distance function
05:58:51 <Cale> I suppose you could use a  Map Integer [MyType]
05:58:56 <Cale> or something like that
05:59:09 <Cale> if you have some weights which you'd like to group them out by
05:59:14 <Cale> Or you could just sort them
05:59:23 <Cale> and then remove the head :)
05:59:37 <nopcode> how are tuples sorted?
05:59:48 <nopcode> ah wait no that wouldn't work
05:59:58 <Cale> Tuples are ordered lexicographically.
06:00:03 <nopcode> Cale: yeah
06:00:07 <Cale> But you can use sortBy if you want another order.
06:00:09 <nopcode> so i could prepend the value
06:00:19 <nopcode> but then i couldn't do a lookup of a given item anymore
06:00:33 <Cale> hmmm
06:00:43 <Cale> What do you mean? By index in the list?
06:00:50 <wli> Okay, doing it bit-by-bit doesn't help.
06:01:16 <nopcode> cale: (cost a, a)
06:01:38 <Cale> Yeah, you could produce that list and then sort it.
06:01:50 <Cale> Then you can pull off the minimum elements one by one
06:01:53 <nopcode> or i could put that into the map directly
06:02:02 <nopcode> but i won't be able to find a given 'a' efficiently
06:02:16 <wli> I guess I'm getting too big of evaluation thunks in the Map
06:02:33 <Cale> wli: that's what the stack overflow indicates
06:02:54 <wli> Now what do I do about it?
06:05:24 <wli> foldr (\s m -> Map.insertWith (\x y -> x `seq` ((+) x $! y)) s 1 m) m0 ss doesn't do it.
06:05:59 <Cale> wli: right, because your problem is that they're not being evaluated at all
06:06:10 <Cale> wli: when they're evaluated, clearly x will be too
06:06:40 <Cale> (+) is strict in both its parameters
06:06:41 * wli starts peppering things with strictness annotations.
06:06:49 <Cale> I don't think those will help.
06:07:11 <Cale> Well, not naive ones anyway
06:07:40 <wli> Well, I'm not finding any that help, so apparently that's the case.
06:07:43 <Cale> Maybe if you immediately did a lookup in a seq to force the value. That seems like a bit of a heavy cost hit.
06:08:04 <Cale> oh
06:08:08 <Cale> insertWith'
06:08:22 <Cale> hehe, seems someone's had this problem before :)
06:08:25 <wli> No dice on insertWith'
06:08:29 <Cale> What?
06:08:46 <wli> It didn't work.
06:08:49 <Cale> hmm
06:08:55 <Cale> then that's not the real problem
06:09:07 <Cale> Try compiling with profiling and adding -xc
06:09:36 <Cale> nopcode: hmm
06:10:12 <nopcode> Cale: nevermind i'll be playing some FPS now ;)
06:10:26 <Cale> nopcode: If you want to pay some memory, you can get fast indexing both ways :)
06:11:13 <fasta> Hmm, I just had an odd experience. Darcs(actually darcs web) was actually useful :)
06:11:19 <Cale> nopcode: make, say an array of the values, and then put (value,index) and (value,cost) pairs into two maps :)
06:11:43 <Cale> fasta: How is that odd?
06:13:34 <roconnor> Lemmih: using modifyl / modifyr seems to make things slightly slower.
06:14:19 <roconnor> .oO(optimization is hard.)
06:14:32 <Cale> Hey darcsweb is actually rather cool. I didn't even know it existed.
06:15:02 <fasta> Cale: I am not sure what was first: git web-interface or darcsweb
06:15:12 <fasta> Cale: configuration takes some time, though.
06:15:35 <Lemmih> roconnor: Are you testing the peroformance using a DNA->RNA executor?
06:15:39 <hpaste>  Svrog pasted "Is there a way to make this Cabal package to work?" at http://hpaste.org/1914
06:16:44 <roconnor> Lemmih: yes
06:16:53 <wli> Cale: It overflowed the stack in the first run with some message about -Ksize
06:17:16 <Cale> wli: If you want, you can just try increasing the stack size.
06:17:18 <earthy> roconnor: that's why there's Michael Jackson's laws of optimization.
06:17:25 <Lemmih> roconnor: Can I play with the code?
06:17:30 <earthy> 1. Don't do it. 2. (for experts) Don't do it yet.
06:17:41 <Igloo> So was SPJ's intro to Haskell filmed?
06:17:55 <Cale> wli: If you compile with -prof -auto-all and run with +RTS -xc, you can get a kind of "backtrace" of cost centres.
06:18:09 <Cale> Igloo: yes, but it's not online yet
06:18:16 <wli> Cale: That's what I did and am now doing with -K1024m
06:18:24 <Igloo> Cale: OK, thanks!
06:18:26 <Cale> Igloo: (at least as far as I can tell)
06:18:29 <gkr> Where is Error monad defined?
06:18:34 <roconnor> Lemmih: sure, I just need to decide if I want to publish a new repository, or just put it in my icfp2007 repository.
06:18:45 <Cale> gkr: Control.Monad.Error
06:19:44 <Cale> gkr: That defines ErrorT and an ever so slightly broken monad instance for Either which you can use.
06:19:49 <roconnor> Lemmih: maybe I can just send you a tar.gz file.
06:20:31 <Cale> (The only brokenness is that it requires an instance of Error for the left parameter of the Either type constructor, which isn't strictly necessary to turn it into a monad)
06:20:50 <wli> Cale: It appears that this could take hours ... :(
06:21:00 <Cale> Fortunately, you can just supply one.
06:21:10 <Cale> wli: What exactly are you trying to do?
06:21:12 <wli> Then again it looks like it's going to blow the stack even with 1GB for it.
06:21:30 <Cale> wli: Produce a histogram of the 4 to 8 letter substrings of a large document?
06:22:14 <wli> Cale: Yes, as a step toward compression in turn as a step toward image encoding.
06:22:24 <Cale> okay
06:22:31 <Nucleo> I'm trying to understand the State monad, and the definition of bind and return don't quite make sense -- is there an alternative definition with join and fmap?
06:22:52 <wli> Nucleo: join, return, and fmap.
06:22:58 <Cale> Nucleo: join is a bit funny for the state monad actually :)
06:23:04 <Nucleo> wli: I mean as defined for State.
06:23:07 <wli> Nucleo: And to me join, return, and fmap make a lot more sense.
06:23:07 <Cale> Nucleo: which code are you looking at?
06:23:16 <Cale> wli: For State?
06:23:24 <wli> Nucleo: For every monad.
06:23:26 <fasta> Running 3 instances of GHC is a bad idea.
06:23:27 <wli> Cale: Yes.
06:23:29 <Nucleo> Cale: I was actually reading your containers article. And everything up through the List monad made sense.
06:23:37 <Cale> Nucleo: ah, okay
06:24:10 <Cale> Nucleo: some of the other monads I included there in an attempt to show how it was possible, even if a little awkward, to consider them as containers
06:24:32 <wli> fasta: I'm running 3 instances of ghc.
06:24:36 <Cale> Well, it's not so bad
06:24:55 <earthy> ah, the STM talk at OSCON is online: http://blip.tv/file/317758
06:24:56 <lambdabot> Title: OSCON 2007 - Simon Peyton-Jones
06:25:10 <Nucleo> I think it's the "data State s a = State (s -> (a,s))" that gets me.
06:25:17 <Cale> If you want to think of a value of type (State s a) as a giant box which is indexed by values of type s, and at each position has both a value of type s and a value of type a
06:25:21 <wli> fasta: You can tell: Swap:  7343688k total,  1771192k used,  5572496k free,   267568k cached
06:25:38 <fasta> wli: I only have 1GB of memory
06:25:55 <wli> fasta: Mem:   3999724k total,  3133396k used,   866328k free,    82120k buffers
06:26:15 <fasta> wli: nice machine
06:26:22 <fasta> wli: you need it :)
06:26:45 <wli> It's got a few cores, too.
06:26:47 <fasta> Ok, this is so funny, meta city doesn't let me move a window!
06:27:35 <Cale> Nucleo: So, if you really like the container perspective, you can picture some sort of elaborate array of mailboxes, possibly infinite, with a value of type s under each one. Stuffed into each is both a value of type a, and the address of another box.
06:27:44 <Nucleo> Cale: in that data constructor, State to the right of the equal sign says to to make a value of type "State", we pass the constructor, called "State", a ... lambda expression? where's the \?
06:27:51 <fasta> One of the GHC instances is taking 600MB.
06:28:10 <fasta> An option to reduce this would be nice.
06:28:19 <Nucleo> Cale: it's almost like continuations... which has it's own Monad. Heh.
06:28:39 <Cale> return x = State (\s -> (x,s))
06:29:01 <Cale> In the fmap, I had a composition of two functions
06:29:10 <Cale> fmap f (State m) = State (onVal f . m)
06:29:10 <Cale>     where onVal f (x, s) = (f x, s)
06:29:23 <roconnor> Lemmih: ugh, I'm not getting consistent timings.
06:29:30 <Cale> join xss = State (\s -> uncurry runState (runState xss s))
06:29:52 <Cale> That might be a little terse
06:30:19 <Nucleo> Hm, I'll have to stare at that some more.
06:30:24 <wli> It's nicer if you use a let.
06:30:26 <Cale> You could also read it as:  join xss = State (\s -> let (xs,s') = runState xss s in runState xs s')
06:30:26 <Nucleo> but a more basic question...
06:30:47 <Cale> But that's not how you *really* think of state.
06:31:00 <Cale> The container analogy is a little weak for State.
06:31:02 <Nucleo> newtype State s a = State { runState :: (s -> (a,s)) }
06:31:23 <Nucleo> which means that to construct a "State" type, we invoke the "State" constructor,
06:31:29 <Nucleo> which takes a value of type newState...
06:31:37 <wli> join xs = State (\s -> let (xs', s') = runState xs s in runState xs' s')
06:31:41 <Nucleo> which is defined as ... a lambda? but where's the \?
06:31:52 <Cale> wli: I did that above
06:32:03 <Cale> Nucleo: what?
06:32:13 <wolverian> Nucleo, it's a type.
06:32:18 <wli> Cale: doh
06:32:19 <Cale> Nucleo: there are lambdas in almost all the definitions of values of that type
06:32:21 <Nucleo> Cale: I'm trying to understand s -> (a,s)
06:32:33 <Cale> Nucleo: that's the type of functions from s to (a,s)
06:32:34 <Nucleo> runState is a function which goes from s -> (a,s)?
06:32:38 <Nucleo> ahh, okay.
06:32:46 <Cale> The runState field is, yes
06:33:02 <Cale> runState itself is a function from State s a to (functions of type s -> (a,s))
06:33:12 <Cale> (the field selector)
06:33:17 <wli> Nucleo: Every state transition function has to produce a new state for the next invocation, but it also produces a "side output"
06:33:47 <Cale> Depending on how you look at it, that side output might also be the real output :)
06:33:54 <Nucleo> and f(a) is the "side output?"
06:33:57 <wli> Nucleo: It's essentially a Moore machine model.
06:34:25 <Nucleo> Hm. I need more CS.
06:34:30 <Cale> That would be helpful if more than 1% of computer programmers knew what a Moore machine was.
06:34:38 <Cale> :)
06:35:00 * Heffalump doesn't
06:35:03 <wli> People don't know Moore machines, Mealy machines, Harvard architecture, etc.?
06:35:05 * ndm prefers mealy machines
06:35:14 <Heffalump> I know what a Harvard architecture is
06:35:15 <ndm> Heffalump: Conway, 1962, Regular Expressions - read it!
06:35:18 <Cale> Nucleo: Basically, a value of type (State s a) is a function from initial states, to pairs of final states and values of type a
06:35:27 <ndm> should be essential reading for all computer scientists
06:35:45 <Heffalump> I've read some of a book of his from the early 70s about them
06:35:49 <Cale> wli: Not people who haven't had Honours CS programs.
06:35:55 <roconnor> Ugh, only with me would adding a change slow things down, and removing the change slow things down even more.
06:36:04 <Cale> wli: I barely know what those things are.
06:36:09 <wli> Cale: I was nowhere near honours CS.
06:36:11 <Nucleo> Heh. I suddenly wish I'd majored in CS.
06:36:12 <Cale> wli: (I was in pure math)
06:36:22 * Heffalump 's UG degree is in Maths, so I have some gaps I've been too lazy to fill in since
06:36:37 <wli> I also majored in pure math, and was nowhere near honours there, either.
06:36:47 <Cale> Yeah, I figure if I need to care about those things, I'll lazily evaluate them :)
06:36:54 <Heffalump> I've also forgotten all the Maths, so I'm basically just ignorant ;-)
06:37:07 <ndm> Heffalump: apart from about Category theory...
06:37:17 <Heffalump> no, I'm quite ignorant about that too
06:37:20 <wli> I'm grossly ignorant of category theory, too.
06:37:22 <Heffalump> I did a course in it once
06:37:32 <ndm> you know enough to ask questions i can't even begin to understand
06:37:42 <wli> About all I remember is bonehead calc, which is what I knew before I started.
06:37:45 <Cale> Nucleo: Basically, we're representing a computation which, given an initial state, produces a final state, and a value of type a
06:37:54 <ndm> Heffalump: where did you do a course on category theory?
06:38:07 <Nucleo> Cale: I see.
06:38:09 <Cale> Nucleo: To do that, we're just using a function.
06:38:09 <ndm> there is a complete lack of courses on category theory or type theory that i can go on
06:38:33 <Heffalump> Oxford
06:38:37 <wli> I don't understand things as basic as adjoints or commutative diagrams.
06:38:46 <ndm> as a taught course in a proper degree?
06:39:23 <Nucleo> Cale: and usually it's the value of type a that's of interest in terms of actually accomplishing something?
06:39:28 <Heffalump> I forget
06:39:30 <RubberHound> Hi, you're probably getting this a lot here, but I've started to read the "Haskell for C programmers" tutorial, and the part where they start talking about monads makes my head explode. Is there a tutorial that explains it well?
06:39:32 <Cale> Nucleo: usually
06:39:33 <Heffalump> I did an MSc in CS before my PhD
06:39:44 <Cale> Nucleo: Occasionally, you do all the work in the state.
06:39:50 <Heffalump> I think it was a course I did in the first year of my PhD, so it was kind of part of it
06:40:08 <Nucleo> Cale: ahh, I see.
06:40:09 <Cale> Nucleo: But usually it's the actual value you're interested in, and the state is just along for the ride.
06:40:23 <wli> I think I did at one time, though. I think I can even point to specific events that made me much dumber than I already was. Anyway.
06:40:23 <Nucleo> *nods*
06:40:43 <Cale> I really think for this monad, the computational analogy is much better.
06:41:02 <Nucleo> Cale: I get the feeling I can probably manage to pull off using State in a cargo-cultish kind of way... but not really comfortable doing so without really understanding what's going on.
06:41:03 <Heffalump> it was 3 or 4 of us in Tony Hoare's office for an hour a week, so not very formal, IIRC
06:41:04 <Cale> So, with that analogy in mind, let's start simple by looking at what >> should do.
06:41:13 <wli> Cale: Okay, the thing actually finished. What do I do?
06:41:13 <Heffalump> ndm: do you have a link to your reference?
06:41:15 <ndm> that would have been really handy
06:41:29 <kowey> RubberHound: there's plenty to choose from: have a look at http://www.haskell.org/haskellwiki/Monad
06:41:31 <lambdabot> Title: Monad - HaskellWiki
06:41:31 <Cale> wli: did you get a list enclosed in <> brackets?
06:41:34 <Heffalump> he had a photocopy of some out of print book (Barr and Wells, IIRC)
06:41:45 <ndm> Heffalump: ah, it was 1971, may well have been the one you were reading
06:41:52 <Heffalump> short blue thing?
06:42:00 <ndm> J.H. Conway, "Regular algebra and finite machines", 1971, Eds Chapman & Hall
06:42:00 <kowey> RubberHound: i quite like this one in particular http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
06:42:01 <ndm> yeah
06:42:02 <wli> Cale: Yeah, <Freq.main>
06:42:03 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ..., http://tinyurl.com/ecqzl
06:42:08 <Heffalump> yeah, that's it
06:42:11 <Cale> Nucleo: If x and y are state computations, then x >> y is going to be a state computation which runs x, throwing away its result and then runs y
06:42:24 <Cale> wli: huh.
06:42:26 <ndm> that has mealy/moore machines in an early chapter, they are quite simply really
06:42:39 <Heffalump> fair enough
06:42:40 <ndm> i liked the regular expression differentiation stuff, that is cool
06:42:46 <wli> Cale: The sum total of the outputs are:
06:42:48 <wli> <Freq.main>[(113401,[False,True,True,False]),(102908,[False,False,False,False]),(101962,[True,True,False,True]),(93484,[True,False,True,True]),(89580,[True,False,False,True]),(87442,[True,False,True,False]),(87215,[False,True,False,False]),(87094,[False,False,True,True]),(78964,[False,True,False,True]),(78736,[False,False,True,False])]
06:42:48 <Cale> wli: That's not as useful as I'd hoped it would be.
06:42:54 <Heffalump> yeah, I co-wrote a paper that used that
06:42:55 <Nucleo> Cale: I follow.
06:42:58 <wli> Cale: Shall I try -hc?
06:43:07 <Cale> wli: oh, that's interesting
06:43:11 <mm_freak> ohâ€¦  lambdabot is back
06:43:13 <mm_freak> @botsnack
06:43:13 <lambdabot> :)
06:43:20 <Cale> wli: it really finished?
06:43:31 <Cale> (without crashing)
06:43:35 <wli> Cale: Yeah. 1GB of stack appears to be enough.
06:43:51 <ndm> yeah, i think i read that one
06:43:59 <wli> Cale: Now trying with -hc
06:44:01 <Cale> Nucleo: okay, and we want it to thread the state along. So the final state after running x will be the initial state we use to run y.
06:44:07 <ndm> with two extra regular expression operators
06:44:32 <Cale> Nucleo: rather than running each thing with its own copy of the initial state, which would be boring.
06:44:34 <Heffalump> the left and right factors, you mean?
06:44:48 <Nucleo> Cale: okay...
06:45:10 <wli> Well, I'm going to chuck this since I'm not going to get anywhere with it in the near future and it's probably possible to dredge up inflate/deflate from somewhere else anyway.
06:45:17 <Cale> Nucleo: Oh, I should point out that to run a computation x of type (State s a) with the initial state i, we use runState x i
06:45:17 <pejo> Heffalump, did you skip some years in school, or how did you squeeze in both a masters, a phd and working before turning 30?
06:45:40 <Cale> Nucleo: which produces that (s,a) pair we're interested in
06:45:45 <ndm> you had something else, didn't you?
06:45:48 <ndm> slice, or something
06:45:50 <Cale> So...
06:45:51 <Heffalump> bachelors only take 3 years, masters 1 year and phds 3 years
06:46:10 <Nucleo> runState x i is a function, which takes a function (s -> (s,a)) and an initial state i...
06:46:12 <Heffalump> well, that was just the left factor of the right factor or vice-versa (IIRC)
06:46:18 <ndm> yeah
06:46:25 <Heffalump> pejo: (though I did effectively skip some years of school, yeah)
06:46:26 <ndm> but you had cool symbols for them :)
06:46:36 <wli> Onto things I've already got rolling, like parser combinators that build up a grammar decorated with semantic actions, to be converted into state machines of observable types etc.
06:46:37 <Nucleo> and then we have (\s -> (s,a)) i    right?
06:46:44 <Heffalump> I mostly did the implementation work, the theory was Oege's idea
06:46:47 <wli> And a typechecker.
06:46:59 <Heffalump> I invented a cool trick for removing symbols from scope in a BDD though.
06:46:59 <Cale> Nucleo: it seems that you're confusing types with values a bit, perhaps?
06:47:16 <Cale> Nucleo: come to #haskell-overflow
06:50:48 <ndm> i can't actually remember what the paper was about, i can just remeber the regular expression tricks :)
06:51:05 <ndm> it was years ago that i read it
06:51:19 <Heffalump> it was about specifying program transformations with regexps, and then updating the information about which ones were valid as the program changed
06:51:33 <ndm> oh, i might reread that then
06:51:52 <ndm> since when i first read it, i was only interested in the regexp side
06:51:57 <ndm> but now the rest is probably relevant
06:53:43 <blsecres> is there a way to push flags down to ghc when building with cabal?  ghc-options: in the .cabal file is being ignored and I'm getting: ld: cannot find -lX11...command was: /usr/pkg/bin/ghc-6.6.1 -lX11 Graphics/X11/Types_hsc_make.o...
06:56:04 <ndm> blsecres: sounds like a cabal bug, have you upgraded to the most recent Cabal?
06:57:54 <blsecres> ndm: This is just what came with the ghc-6.6.1 package for NetBSD (Cabal-1.1.6.2)
06:58:21 <ndm> blsecres: i'd recommend upgrading your cabal, they are always fixing bugs in it
06:58:39 <Svrog> blsecres: try using extra-libraries
06:59:16 <blsecres> Svrog: that's already set to "X11"
06:59:43 <Igloo> Svrog: What flag do you want to be passed?
07:00:00 <Svrog> ?
07:00:19 <Svrog> what flag?
07:00:30 <Igloo> Which flag do you want to be pushed down to ghc?
07:01:02 <Svrog> is that relating to the hpaste above?
07:01:10 <blsecres> Igloo: -L/usr/X11R6/lib
07:01:29 <Igloo> Svrog: Worry, wrong person
07:01:32 <Svrog> ah
07:02:17 <Igloo> blsecres: Try extra-lib-dirs: /usr/X11R6/lib
07:02:22 <Svrog> i also had a question about cabal but it was about using a main function written in c - for some reason all the haskell modules get ignored
07:02:41 <Igloo> blsecres: Failing that, ld-options: -L/usr/X11R6/lib
07:03:01 <blsecres> Igloo: that's already set
07:03:12 <blsecres> Igloo: I'll try extra-lib-dirs
07:03:18 <Igloo> Svrog: Hmm, I'm not sure if that's meant to work, but it would be nice if it did
07:03:43 <Svrog> oh right
07:03:50 <Svrog> so im better off using autoconf for that then?
07:06:13 <wli> Well, the heap profile isn't quite done yet.
07:14:28 <ndm> we should have a page of people, their IRC name, and their real name, and any IRC aliases they use
07:14:34 <ndm> since i've got entirely lost...
07:15:36 <fasta> I won! You have therefore been approved to claim a total sum of Â£1,000,000 (One million pounds sterling). ;)
07:16:20 <ndm> does it involve a trip to Nigeria, or a premium rate phone call?
07:16:49 <ndm> i keep getting invited to Nigeria by someone who has just been poisoned, but fortunately has a spare Â£137,000,000 sitting around
07:17:55 <wli> Cale: http://holomorphy.com/~wli/haskell/bernoulli/freq.pdf
07:18:26 <wli> Cale: Looks like the number of substrings getting generated is vast.
07:19:22 <wli> Cale: It seems to be keeping multiple copies of the things.
07:19:53 <fasta> ndm: no, I just need to give my address.
07:20:14 <fasta> If only there was a law which said that they had to give it to me.
07:20:33 <ndm> do you think these people are going to be contrained by the law?
07:20:38 <ndm> * constrained
07:21:20 <wli> ndm: The financial aristocracy is well above the law.
07:21:33 <fasta> ndm: if your law enforcement agency has certain powers, yes.
07:21:59 <roconnor> ``We got our DNA->RNA converter down to 16 seconds to process Endo's DNA.
07:22:02 <roconnor> *sigh*
07:22:04 <SamB_XP_> ndm: how convenient that they all have pounds
07:22:11 <roconnor> damn you C++
07:22:20 <roconnor> @karma C
07:22:21 <lambdabot> C has a karma of 0
07:22:25 <roconnor> whew
07:22:25 <SamB_XP_> roconnor: you should have written it in C
07:22:35 <SamB_XP_> C++ is special-cased
07:22:50 <roconnor> SamB_XP_: It would have been faster if I wrote it in C, but it also wouldn't have worked.
07:23:06 <ndm> if you are writing a virtual machine, C or C++ are the sensible languages to pick
07:23:27 <ndm> it just so happens that the last two ICFP contests were about writing virtual machines
07:23:30 <roconnor> SamB_XP_: actually C++ is needed for their rope library
07:23:36 <SamB_XP_> oh.
07:23:41 <SamB_XP_> sorry.
07:23:45 <SamB_XP_> I was thinking rna2fuun
07:24:18 <SamB_XP_> that is ridiculously fast for dna2rna
07:24:25 <roconnor> SamB_XP_: even after a week of work, I'm not close to getting a fast DNA2RNA converter
07:25:32 <SamB_XP_> yeah, mine takes quites some time to draw pictures of endo
07:25:45 <SamB_XP_> desp's takes less but still a while
07:26:13 <roconnor> But all these timings are hard to compare without a benchmark machine
07:26:16 <SamB_XP_> (mine spends 80% of it's time in a non-optimized naive search)
07:26:35 <roconnor> I'm running on a laptop that throttles between 600 MHz and 1400 MHz
07:26:52 <SamB_XP_> eeek
07:27:02 <roconnor> SamB_XP_: I spend 30% of my time doing uncons.
07:27:22 * SamB_XP_ uses lazy bytestrings
07:28:05 <SamB_XP_> oh great I think I got another nigerian email
07:28:11 <roconnor> SamB_XP_: is your solution published?  Maybe I can try running it.
07:28:23 <SamB_XP_> roconnor: why would you want to?
07:28:37 <SamB_XP_> it's pretty damn slow ;-)
07:28:41 <roconnor> oops only 16% of my is spent in uncons
07:28:54 <roconnor> SamB_XP_: oh.  I thought it might be faster than mine.
07:29:00 <dcoutts> roconnor: doing uncons on a lazy bytestring or strict?
07:29:13 <roconnor> dcoutts: on my rope structure.
07:29:15 <SamB_XP_> roconnor: how slow is yours?
07:29:20 <dcoutts> roconnor: ah ok
07:29:41 <dcoutts> roconnor: what does your actual data type definition look like?
07:29:43 <SamB_XP_> dcoutts: uncons on a strict bytestring is trivial
07:29:48 <roconnor> SamB_XP_: on the order of 30 minutes to process endo.dna
07:30:04 <roconnor> newtype RopeWith a = Rope
07:30:04 <roconnor>                    { chunks :: F.FingerTree (Sum Int64) Chunk }
07:30:07 <dcoutts> SamB_XP_: yes, I know, I'm planning to remove one indirection for the lazy bytestring case
07:30:12 <roconnor> newtype Chunk = Chunk { unChunk :: B.ByteString}
07:30:14 * wli attempts to make sense of lookAhead in terms of building a grammar.
07:30:22 <roconnor> strict bytestrings
07:30:29 <SamB_XP_> roconnor: hmm, since I've been running on a 1.7 GHz P4 I think mine is slower
07:30:40 <dcoutts> roconnor: try {-# UNPACK #-} !Chunk
07:30:53 <dcoutts> oh, wait, that's a FingerTree
07:31:24 <dcoutts> roconnor: for a faster impl, you could specialise the FingerTree to Int and Chunk
07:31:35 <dcoutts> that'd remove a couple indirections and use less memory
07:32:03 * ndm hates writing papers where the assertion "Haskell is a good programming language" would get laughed at
07:32:12 <dcoutts> and that could significantly improve the uncons performance
07:32:36 <dcoutts> ndm: doesn't that depend on where you submit the paper?
07:32:58 <roconnor> {-# SPECIALIZE uncons :: ByteString -> Maybe (Word8, ByteString) #-}
07:33:08 <roconnor> all functions are specialized like that
07:33:16 <roconnor> where
07:33:17 <dcoutts> roconnor: that will not help, I mean the data representation, not the functions on it.
07:33:18 <roconnor> type ByteString = RopeWith DefaultSize
07:33:37 <roconnor> oh, you mean fingertrees themselves.
07:33:40 <dcoutts> yes
07:33:41 <roconnor> *sigh*
07:33:47 <ndm> dcoutts, yes, but the place i'm submitting the paper means that i can't say that
07:33:48 <roconnor> that's not very modular.
07:33:48 <dcoutts> you need to think about the low level data layout in memory
07:33:59 <dcoutts> ndm: ho hum
07:34:06 <ddarius> ndm: Where are you submitting the paper?
07:34:27 <ndm> ddarius: York Doctoral Symposium http://www.cs.york.ac.uk/yds/wiki/index.php?title=York_Doctoral_Symposium
07:34:30 <lambdabot> Title: York Doctoral Symposium - York Doctoral Symposium, http://tinyurl.com/2aszjl
07:34:39 <ndm> the "free dinner with a date" conference
07:34:47 <wli> ndm: Mostly people I work with would be baffled by an interest in programming languages, or otherwise go "Oh, that functional programming bullshit. Now about all that ia64, ppc64, and x86-64 assembly we need you to write by hand, and C, too."
07:34:49 <dcoutts> roconnor: that's quite true, it's not modular, we need more automation to allow data representation improvements to be done more automatically
07:35:19 * roconnor nods
07:35:45 <ndm> wli: exactly, thats pretty much the general attitude
07:36:23 <ndm> i'm writing the Haskell bits in comments, and will probably turn it around for the monad reader with the Haskell put back, after the conference
07:36:57 <ddarius> Stick the source code to FingerTrees in a big TH block and then parameterize out the relevant parts, then we have a FingerTree making module.
07:38:52 <ndm> ddarius: that sounds like you should be able to abstract it in the Haskell world, i.e. a type class for hte value specific behaviour
07:39:15 <ndm> ddarius: in fact, it sounds like your technique might give us C++ templates, something that is pure evil
07:40:04 <SamB_XP_> how about a *typeclass*?
07:40:13 <Lemmih> roconnor: There's a typo in DNASeq.hs
07:40:28 <roconnor> ah could be
07:41:04 <SamB_XP_> oh, yeah, ndm said that already ;-)
07:41:22 <roconnor> Lemmih: should be EmptyL
07:41:53 <wli> Ugh, I seem to need these things to live in a state monad so I can instantiate fresh type variables.
07:42:01 <wli> s/type variables/nonterminal symbols/
07:42:14 <SamB_XP_> now all we have to do is wait for JohnMeacham to get "seperate compilation" (i.e. not taking forever and eating all your RAM) to work in JHC
07:42:25 <ddarius> wli: There's another trick using only the Reader monad, but it produces long names.
07:42:29 <roconnor> Lemmih: sorry DNASeq is a bit broken
07:42:35 <roconnor> I haven't tried it in a bit
07:43:09 <wli> ddarius: The Hutton-Meijer parser combinator API doesn't really allow for having the things be monads.
07:43:17 <ndm> SamB_XP_: or wait for me to finish Supero :)
07:43:37 <ddarius> wli: Well, the reader monad is not that painful to inline, you just add an extra parameter.
07:43:38 <ndm> already faster than Jhc on some examples
07:43:46 <ndm> faster than C in some examples!
07:44:06 <dcoutts> @seen CosmicRay
07:44:06 <lambdabot> I haven't seen CosmicRay.
07:44:35 <ndm> SamB_XP_: and remember, separate compilation /= fast compilation, Supero runs in Hugs, compiles programs in fractions of a second, and is whole program
07:44:43 <wli> ddarius: I have to do renaming on any sort of combination of multiple parsers which breaks that abstraction anyway; combinator #1 is choice, for example, which requires such.
07:44:53 <SamB_XP_> ndm: huh
07:45:53 <ddarius> I think you wanted "fast compilation =/=> separate compilation"
07:46:19 <ndm> they are entirely unrelated, you can be slow and separate, or fast and whole, or any combination
07:46:53 <ndm> i personally think whole program is inevitable, Moores law almost demands it
07:47:21 <Winterstream> Slow and separate - g++ comes to mind :)
07:47:30 <ndm> but it will have to be "clever" whole program, O(n^2) is clearly unacceptable, you need to be O(n)
07:47:42 <ndm> O(n log n) is probably fine, thats where Supero is
07:48:06 <SamB_XP_> O(log n) would be cooler ;-P
07:48:40 <roconnor> Lemmih:
07:48:40 <roconnor> loadDNA :: String -> IO DNA
07:48:40 <roconnor> loadDNA x = fmap (fromList . (Prelude.filter
07:48:40 <roconnor>  (`Prelude.elem`[i,c,f,p])) . map letterDNA) $ readFile x
07:48:48 <ndm> that kind of implies not writing out the result...
07:49:18 <Winterstream> Monad question...
07:49:18 <Winterstream> Either is an instance of Monad, right?
07:49:33 <ari> @instances Monad
07:49:35 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
07:49:44 <Winterstream> Oh wow. Thanks...
07:50:12 <Winterstream> I can't find where Either implements the Monad operators. What am I doing wrong?
07:50:22 <Saizan> Error e => (Either e)
07:50:34 <ndm> import Control.Monad.Instances ?
07:50:37 <Saizan> @source Control.Monad.Error
07:50:37 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/Error.hs
07:50:54 <Winterstream> Lambdabot is awesome
07:51:21 <jfredett> @botsnack
07:51:22 <lambdabot> :)
07:51:24 <roconnor> ah @src /= @source
07:51:52 <Saizan> yup
07:51:53 <Winterstream> Thanks Saizan
07:52:10 <roconnor> @karma g
07:52:10 <lambdabot> g has a karma of 1
07:52:30 <Winterstream> I take it that >> can be implemented in terms of >>= ?
07:52:39 <roconnor> @src >>
07:52:40 <lambdabot> m >> k      = m >>= \_ -> k
07:52:49 <Winterstream> Ha ha! Wow.
07:54:33 <Winterstream> Okay, so from the definitions, if I do
07:54:33 <Winterstream>   throwError Foo >> return Bar
07:54:33 <Winterstream> I would still get a Left?
07:54:53 <Winterstream> (assuming I'm using Either)
07:54:55 <roconnor> > throwError Foo >> return 0 :: Either String Int
07:54:56 <lambdabot>   Not in scope: data constructor `Foo'
07:55:02 <roconnor> > throwError "Foo" >> return 0 :: Either String Int
07:55:04 <lambdabot>  Left "Foo"
07:55:17 <roconnor> @src throwError
07:55:17 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
07:55:21 <Winterstream> Thanks roconner
07:55:28 <roconnor> @src Control.Monad.Error.throwError
07:55:28 <lambdabot> Source not found. Do you think like you type?
07:55:31 <roconnor> bah
07:55:38 <Winterstream> Wow. Lambdabot can be mean eh?
07:55:38 <roconnor> oh wait
07:55:47 <Saizan> @src Either throwError
07:55:47 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
07:55:56 <Saizan> @src throwError Either
07:55:57 <lambdabot> Source not found. Take a stress pill and think things over.
07:56:13 <ari> @index throwError
07:56:13 <lambdabot> Control.Monad.Error
07:56:32 <roconnor> @src Control.Monad.Error.throwError Either
07:56:32 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
07:56:56 <roconnor> oh well
07:57:07 <roconnor> @src Either >>=
07:57:07 <lambdabot> Source not found. The more you drive -- the dumber you get.
07:57:12 <roconnor> @src >>= Either
07:57:12 <lambdabot> Source not found. I feel much better now.
07:57:18 <roconnor> :'(
07:57:27 <roconnor> I was just looking at it yesterday
07:57:45 <doserj> @src Either (>>=)
07:57:46 <lambdabot> Left  l >>= _ = Left l
07:57:46 <lambdabot> Right r >>= k = k r
07:57:49 <doserj> .
07:58:05 <roconnor> Lemmih: Seq Word8 is so much faster :(
07:58:27 <Winterstream> Okay, so just to be 100% sure (sorry, but it's taking me a while to understand how Monads work), the only reason we're using 'maybe' in the following code, is for the possibility of an error:
07:58:27 <Winterstream> setVar envRef var value = do env <- liftIO $ readIORef envRef
07:58:27 <Winterstream>                              maybe (throwError $ UnboundVar "Setting an unbound variable" var)
07:58:27 <Winterstream>                                    (liftIO . (flip writeIORef value))
07:58:28 <Winterstream>                                    (lookup var env)
07:58:31 <Winterstream>                              return value
07:58:37 <roconnor> Lemmih: of course at 10x the memory, it had better be faster.
07:59:12 <roconnor> Winterstream: looks goodish
07:59:23 <Winterstream> As I understand it, the maybe and return will be bound using >>
07:59:31 <roconnor> I have:
07:59:36 <roconnor>   maybe (throwError Done)
07:59:36 <roconnor>    (\(hd,tl) -> put tl >> return hd)
07:59:36 <roconnor>    (uncons x)
08:00:17 <wli> Hmm, the thing couldn't derive MonadError and MonadState instances for my newtype. :(
08:00:23 <roconnor> Winterstream: which looks so close to yours that we ought to define some function to do it.
08:00:39 <Winterstream> ahh
08:00:40 <Winterstream> okay
08:00:44 <Winterstream> Cool :)
08:00:44 <roconnor> wli: are you using GHC extensions?
08:00:59 <wli> roconnor: I'm perfectly willing to, if they help.
08:01:07 <Saizan> wli: you need to pass the error/state  paramaeter maybe?
08:01:10 <Winterstream> I really hope I'm struggling with Haskell because it's so different. It's making me feel pretty dumb :(.
08:01:39 <roconnor> wli: add {-# OPTIONS_GHC -fglasgow-exts #-} to the top of your file.
08:01:45 <wli> roconnor: Okay.
08:01:51 <roconnor> I'm pretty sure Haskell 98 doesn't support deriving in newtypes.
08:02:28 <wli> roconnor: Passing in parameters to the thing seemed to do the trick, though. I think I've got -fglasgow-exts turned on all the time anyway.
08:02:32 <roconnor> wli: and Saizan is right too.  The syntax is a bit finicky.
08:02:41 <roconnor> wli:  okay
08:03:31 <Saizan> ?instances MonadError
08:03:32 <lambdabot> IOError IO, e (Either e), e (ErrorT e m), e (RWST r w s m), e (ReaderT r m), e (StateT s m), e (WriterT w m)
08:03:51 <Saizan> wasn't Maybe a MonadError too?
08:04:14 <wli> Saizan: I thought so, too, and am annoyed it isn't.
08:04:29 <Saizan> ?src MonadError
08:04:29 <lambdabot> class (Monad m) => MonadError e m | m -> e where
08:04:29 <lambdabot>     throwError :: e -> m a
08:04:29 <lambdabot>     catchError :: m a -> (e -> m a) -> m a
08:05:07 <Saizan> but with which e? ()?
08:05:45 <jfredett> Holy Crap, I just understood monads. *dies*
08:06:02 <jfredett> or- at least how to use them out of the "do" context
08:06:03 <Saizan> at least you didn't die before!
08:06:20 <wli> jfredett: Quick, do YAHT chapter 9 before it fades.
08:06:27 <jfredett> I totally get it now- god, now I feel dumb for not seeing it before
08:07:15 <roconnor> jfredett: great, now do comonads.
08:07:18 <Saizan> i wish we had a class for convertible monads
08:07:22 <roconnor> :)
08:07:40 <jfredett> its easy- to use a monadic value outside of a monad, you write a function to use in a >>=, and then just use the value
08:07:49 * jfredett twitches and dies some more
08:07:53 <ddarius> :t (>>=)
08:07:55 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
08:08:01 <wli> I feel like I'm only "halfway there" vs. totally understanding them. I have some idea of how to do things, but I don't feel like I make the most effective use possible, or spot all the potential for use, or otherwise am adept in their use.
08:08:24 <wli> Examples of comonads, anyone?
08:08:37 <ddarius> (,) s
08:08:40 <roconnor> wli: streams are the canoncial example.
08:09:10 <roconnor> coreturn = head
08:09:42 <wli> roconnor: Nonempty lists?
08:09:57 <roconnor> wli: infinite (nonempty) lists
08:10:10 <wli> Where is this lib?
08:10:11 <ddarius> data Stream a = Cons a (Stream a)
08:10:22 <roconnor> cobind l f = map f (tails l)
08:10:33 <roconnor> I think that is right.
08:10:49 <ddarius> If "cojoin" is tails
08:11:13 <ddarius> > head $ tails [1,2,4]
08:11:14 <lambdabot>  [1,2,4]
08:11:15 <roconnor> ddarius: ah right.
08:12:11 <ddarius> > tails $ map head [1,2,4]
08:12:12 <lambdabot>   add an instance declaration for (Num [a])
08:12:12 <lambdabot>     In the expression: 4
08:12:15 <pejo> wli, there's a stream library on hackage by Swierstra.
08:12:18 <roconnor> wli: althought streams are the canoncial example, they are not considered terribly useful for programming.
08:12:21 <pejo> If that was your question.
08:12:22 <ddarius> > map head $ tails [1,2,4]
08:12:23 <lambdabot>  Exception: Prelude.head: empty list
08:12:29 <wli> I have Data.Stream
08:12:33 <ddarius> > map head $ tails [1..]
08:12:35 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
08:12:39 <wli> Just not the Comonad thing.
08:12:58 <ddarius> There is no standard Comonad library
08:13:03 <Saizan> ?go Context Comonad
08:13:04 <wli> Is there a Debian package for the lib that has it?
08:13:05 <lambdabot> http://www.eyrie.org/~zednenem/2004/hsce/Control.Comonad.Context.html
08:13:20 <ddarius> coreturn (s,x) = x
08:13:34 <ddarius> cojoin (s,x) = (s,(s,x))
08:13:52 <roconnor> ah right, there is the reader comonad.
08:14:02 <roconnor> but the reader comonad is isomorphic to the reader monad.
08:14:14 <roconnor> so again, isn't such a compelling example.
08:14:32 <jfredett> ... Comonads are scary...
08:14:48 <Saizan> comonads are not particulary useful it seems
08:14:56 <wli> Infinite trees, then.
08:15:07 <Saizan> but every zipper is a comonad
08:15:14 <jfredett> Saizan: Who cares, Since when did anything in Haskell need to be useful? :)
08:15:27 <wli> extract :: w a -> a ; duplicate :: w a -> w (w a)
08:16:02 <SamB_XP_> jfredett: since we get bored of things that aren't either useful or entertaining?
08:16:19 <Saizan> jfredett: it's funnier if you can use them instead of just defining them
08:16:52 <SamB_XP_> Saizan: aren't comonads cool for cellular automation?
08:16:55 <jfredett> well, useful and entertaining are certainly not mutually exclusive, and I'm sure there exist entertaining, if not necessarily "useful", uses of comonads, somewhere
08:17:16 <Saizan> SamB_XP_: for 1-d, 2-d gives you huge space leaks
08:17:22 <roconnor> data BinTree a = Leaf a | BinTree a (BinTree a) (BinTree a) is a pretty good comonad.
08:17:42 <jfredett> its like Sex after you have a vasectomy, not particularly useful, but its still pretty entertaining.
08:18:06 <ddarius> newtype FreeComonad sig a = FC (a, sig (FreeComonad sig a))
08:18:10 <SamB_XP_> Saizan: 2d cellular automations are too difficult to comprehend anyway
08:18:18 <jfredett> roconnor: don't you want that first bintree to be a node?
08:18:54 <roconnor> jfredett: I don't think so, but I'm not sure I understand.
08:19:39 <Saizan> edwink use comonads in it's compiler iirc
08:20:01 <jfredett> well, with that, you could get something that isn't a binary tree-
08:20:33 <roconnor> jfredett: oh, like what?
08:20:49 <SamB_XP_> edwardk possibly?
08:20:51 <jfredett> data BT a = L a | N a (Lft a) (Rgt a)
08:20:51 <jfredett> should prevent that
08:21:08 <wli> data AndMaybe t t' = JustOne t | Both t t' ; extract (JustOne x) = x ; extract (Both x _) = x ; duplicate (JustOne x) = x ; duplicate (Both x y) = Both (JustOne x, y) ? or duplicate (Both x y) = JustOne (Both x y))?
08:21:09 <roconnor> jfredett: what is Lft and Rght?
08:21:09 <Saizan> SamB_XP_: yes, bad memory
08:21:30 <jfredett> Left branch and right branch, oh- shit- I was thinking to much
08:21:34 <jfredett> those should be BT's too
08:21:45 <SamB_XP_> heh
08:22:01 <roconnor> jfredett: I'm not sure you understand haskell data declaration syntax.
08:22:10 <roconnor> jfredett: (It's pretty bad)
08:22:26 <ddarius> roconnor: What?
08:22:33 <jfredett> roconnor: I'm pretty sure I do- its just to early in the morning for me. (I'm suffering a bit of jet lag)
08:22:38 <jfredett> I'm probably wrong
08:22:42 <jfredett> no worries
08:22:45 <roconnor> ddarius: am I wrong?
08:22:51 <Saizan> wli: duplicate j@(JustOne x) = JustOne j ?
08:22:55 <SamB_XP_> roconnor: I think he's just being goofy
08:23:13 <wli> Saizan: Yeah
08:23:14 <ddarius> roconnor: I'm referring to the "(It's pretty bad)" part.
08:23:32 <SamB_XP_> ddarius: of course it is
08:23:35 <jfredett> meh, its 11:30 here, I shouldn't be this tired. I'm never going to california again.
08:23:37 <roconnor> ddarius: ah, the GADT sytax is easier to read.
08:23:50 <SamB_XP_> it was probably the hardest part of learning Haskell for me
08:23:51 <roconnor> by far
08:24:12 <SamB_XP_> besides getting over not being able to say what monads are
08:24:15 <ddarius> I don't recall having any trouble whatsoever with the data type syntax.
08:24:36 <ddarius> It's seems very natural and intuitive to me.
08:24:39 <wli> So there's a canonical projection :: w t -> t and a canonical injection :: w t -> w (w t)
08:24:40 <SamB_XP_> not really
08:24:46 <roconnor> ddarius: the fact that constructors and types have both the same captilaization and appear next to each other makes it confusing.
08:24:54 <SamB_XP_> the GADT syntax is indeed much better
08:24:58 <wli> I find my intuition is trained by experience.
08:25:01 <doserj> and it should be forbidden in tutorials to use the same name for type and for data constructors...
08:25:21 <SamB_XP_> I'm not sure if it was a tutorial or not...
08:25:26 <ddarius> roconnor: Do you find id :: a -> a confusing as well?
08:25:39 <SamB_XP_> ddarius: of course not.
08:25:44 <wli> Repetition. Drilling. Bashing my face in with monadic anything and everything until it sinks in.
08:25:47 <SamB_XP_> it has a ::
08:26:08 <roconnor> what SamB said
08:26:23 <ddarius> How about f x y = ... , it's about the same issue
08:26:29 <SamB_XP_> I believe GADT syntax would have been a good deal easier to grasp
08:26:54 <ndm> SamB_XP_: its also more verbose, certainly for things like enumerations the current syntax is much nicer
08:26:56 <SamB_XP_> of course, then I might well have tried to define GADTs ;-)
08:27:03 <ndm> data Colour = Red | Green | Blue
08:27:03 <SamB_XP_> ndm: true
08:27:04 <ndm> vs
08:27:24 <ndm> data Color :: * where Red :: Color | Green :: Color | Blue :: Color
08:27:47 <pejo> wli, someone in this channel said that they found it hard to implement the type inference algorithm of HM. The answer they got was along the lines "The first ones you write usually are".
08:27:53 <SamB_XP_> ndm: yeah, yeah, I get the picture
08:28:04 <SamB_XP_> having both would perhaps be a useful teaching aid, however
08:28:16 <wli> pejo: I've done HM, just not the monadic way.
08:28:42 <ddarius> wli: Did you just pass around substitutions then?
08:29:15 <wli> ddarius: Yep. Environment args to every function, big huge unifying functions, etc.
08:29:32 <SamB_XP_> because then, when defining types that actually have fields on some of their data constructors, you could just say "this is equivalent to:" and then a GADT-style definition
08:29:32 <pejo> wli, sure, but the comment seems to be in line with your comment about Repetition.
08:29:38 <wli> ddarius: Everything a monad would get used for got passed as an argument.
08:30:05 <wli> ddarius: The last time I did it was in ocaml, though.
08:30:19 <SamB_XP_> wli: only as arguments?
08:30:28 <ndm> wli: did you use Uniplate?
08:30:40 <ndm> if not, you've probably got quite a lot of boilerplate floating around
08:30:41 <Winterstream> General question: Do you think that Monads could be made simple enough for "ordinary" programmers to understand them?
08:30:44 <wli> SamB_XP: Heavens no, everything passed in also came back out as a return value.
08:30:51 <SamB_XP_> wli: ah.
08:30:57 <mm_freak> understandWomen = âŠ¥
08:31:01 <Winterstream> ha ha
08:31:03 <SamB_XP_> well that's just what State does anyway
08:31:22 <wli> ndm: I had more boilerplate than an all-grilled steakhouse.
08:31:26 <SamB_XP_> Winterstream: they are plenty simple enough
08:31:29 <pejo> Winterstream, ordinary programmers don't understand lambda calculus either. Yet they seem to cope fairly well with writing scheme or whatever in their introductory progarmming class in college.
08:31:45 <ndm> wli: use Uniplate, its easy to use, and makes your code up to 10 times shorter
08:31:52 <ndm> @where uniplate
08:31:52 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/uniplate
08:31:53 <SamB_XP_> I have to go weed now
08:32:06 <SamB_XP_> back in about an hour
08:32:08 <ndm> @where+ uniplate http://www-users.cs.york.ac.uk/~ndm/uniplate/
08:32:08 <lambdabot> Done.
08:32:21 <wli> ndm: Well, I've since moved on to Haskell, so I won't really be using too many ocaml libs.
08:32:35 <ndm> wli: thats a Haskell lib
08:32:57 <wli> ndm: oh, never mind, then.
08:33:15 <ndm> is there an OCaml lib called uniplate? that would be unfortunate...
08:33:52 <wli> ndm: No, I just said that what I wrote was in ocaml, so I presumed the lib was to help that along. But it's 10 years dead anyway.
08:33:57 <Winterstream> Okay. Hmm. Let me ask about something related...
08:33:57 <Winterstream> Did it take anyone here a pretty long time to understand all the ramifications of Monads?
08:34:06 <ndm> Winterstream: years
08:34:16 <ndm> for me personally
08:34:32 <Winterstream> ndm: Ahh. Okay. Now I can relax...
08:34:34 <wli> Winterstream: For me, it's been over a decade and I'm still not there yet.
08:35:01 <blsecres> OK, setting `extra-lib-dirs' in the X11.cabal caused ghc to use the proper -L flag, the -rpath flag isn't generated but I can set the LD_LIBRARY_PATH environment variable.  Doing this gets me to: ...ghc4700_0/ghc4700_1.hscpp:1:0\nfilename does not match module `Main'
08:35:05 <ddarius> Winterstream: -all- the ramifications is pushing it.
08:35:08 <Winterstream> As pejo said, I guess one can still write useful code using Monads, without really undestanding everything
08:35:25 <wli> Winterstream: Now, granted, I've not been exactly working on it that entire time, but still.
08:35:36 <Winterstream> wli: of course...
08:35:55 <roconnor> Winterstream: just yesterday I wasn't sure that I could catch an error thrown from within a forever loop.
08:36:08 <roconnor> So obviously I don't understand monads entirely yet.
08:36:17 <Winterstream> Okay.
08:37:09 <Winterstream> roconnor: so how does one do it?
08:38:34 <ddarius> you just do it
08:39:44 <Winterstream> ddarius: So it works, because combining anything with an Error just results in another Error, meaning that the loop won't be executed again?
08:40:05 <roconnor> Winterstream: throwing an error drops the rest of the computation on the floor
08:40:17 <roconnor> @src Error (>>=)
08:40:17 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
08:40:18 <ddarius> Using Maybe, Nothing >>= f = Nothing
08:40:27 <Winterstream> Ah. yeah.
08:40:32 <roconnor> @src Either (>>=)
08:40:32 <lambdabot> Left  l >>= _ = Left l
08:40:32 <lambdabot> Right r >>= k = k r
08:40:38 <Winterstream> roconner++
08:40:40 <Winterstream> ddarius++
08:40:45 <roconnor> roconnor++
08:40:58 <Winterstream> ha ha
08:41:03 <mm_freak> "Fundeps have lots more uses than just implementing C++-style function overloading, of course. See the paper by Mark P. Jones for further details."  â‡ the link is deadâ€¦  where can i find that paper?
08:41:24 <Winterstream> Is Mark related to Simon?
08:41:28 <ndm> no
08:41:35 <ddarius> @google "Mark P. Jones" functional dependencies
08:41:37 <roconnor> So now my code looks like:   let (_,_,rna) = runDNA (forever step) dna
08:41:38 <lambdabot> http://portal.acm.org/citation.cfm?id=651909&dl=ACM&coll=portal
08:41:38 <lambdabot> Title: Type Classes with Functional Dependencies
08:41:53 <ndm> Simon is "Peyton Jones", Mark is "Jones", with P. as his middle initial
08:41:59 <Winterstream> Ah
08:42:20 <Winterstream> It would have been quite neat if that had been the case. A bit like the Bernoulli family.
08:44:10 <fax> hiya
08:44:19 <Winterstream> Hi fax
08:45:57 <fax> Any recommendation for interesting haskell tutorial or things to code or somthing?
08:46:01 <ddarius> anyways, instance Functor sig => Comonad (FreeComonad sig) where extract (FC (a,_)) = a; duplicate (FC (a,cm)) = FC (FC (a,cm),duplicate cm)
08:46:54 <ddarius> type Stream a = FreeComonad Id a
08:47:07 <Winterstream> fax: I'm working through "Write Yourself a Scheme in 48 Hours" (http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/overview.html) at the moment. It's very cool, but it would help if you know at least a little bit of Scheme.
08:47:10 <lambdabot> Title: Write Yourself a Scheme in 48 hours, http://tinyurl.com/l986o
08:47:30 <araujo> hello
08:47:48 <fax> oh yeah that is pretty cool
08:48:15 <Winterstream> fax: I'm eyeing "The Haskell School of Expression" - it looks like an awesome book.
08:48:39 <fax> oo I heard of that
08:48:43 <fax> I think I will check the library
08:49:04 <doserj> fax:  http://www.haskell.org/haskellwiki/Wanted_libraries
08:49:05 <lambdabot> Title: Wanted libraries - HaskellWiki
08:49:51 <Winterstream> He he. I think fax meant the actual book library :)
08:49:58 <fax> lolk
08:50:02 <fax> I didn't notice the pun
08:50:45 <Winterstream> But yeah, actually that is of course a good way. If your Haskell-fu is decent, then it would  be awesome for you to add to the libraries.
08:50:59 <ddarius> type Either s a = FreeMonad (Const s) a, type StateInContext s a = FreeComonad (Const s) a
08:51:31 <fax> oh I don't think I can write good code in haskell yet
08:51:42 <Winterstream> fax: Write a Javascript backend for GHC ;).
08:51:50 <Winterstream> I wish someone would do something like that
08:51:53 <fax> lol
08:52:10 <pejo> Winterstream, to run it in your webbrowser?
08:52:29 <ndm> Winterstream: already done, we have a Javascript back end for Yhc
08:52:32 <Winterstream> pejo: yep. To avoid having to code in Javascript. :)
08:52:41 <Winterstream> ndm: !!!! Wow.
08:52:50 <Winterstream> ndm: I'm checking that out right now.
08:53:27 <ndm> Winterstream: http://haskell.org/haskellwiki/Yhc/Javascript
08:53:28 <Winterstream> Oh, but wait. Yhc is still incomplete, right?
08:53:28 <lambdabot> Title: Yhc/Javascript - HaskellWiki
08:53:33 <ndm> Winterstream: yes, alas
08:54:10 <Winterstream> Wow. Now that would be something.
08:54:11 <dmwit> From the Haskell wiki:
08:54:14 <dmwit> Access to Javascript (including DOM) objects and properties
08:54:24 <dmwit> That's the most impressive bullet point to me -- it should be higher. ;-)
08:56:58 <Winterstream> Another cool thing I could think of, would be to compile to the latest Flash VM bytecode format...
08:56:59 <ndm> whats more cool is that you can write a library over the DOM, and play with it like it was Haskell
08:57:00 <Winterstream> hmm
08:57:17 <ndm> if someone put in the effort, should be easy enough from Yhc
08:57:34 <ndm> we can compile to Haskell byte code, Java byte code, IL byte code
08:57:45 <ndm> we also have a python interpetter
08:57:55 <Winterstream> He he. Would it take years before I could think of contributing to GHC?
08:58:10 <ndm> i'm still not at the stage where i could contribute to GHC...
08:58:18 <ndm> i'm actually not at the stage where i could even get it to compile
08:58:20 <Winterstream> I take it that objects are embedded in Monads?
08:58:49 <ndm> mutable objects tend to be, but its more the "mutable" than the "object" bit that requires the Monad
08:58:52 <Lemmih> roconnor: I wonder why the robe implementation makes twice as many heap allocations.
08:59:30 <pejo> ndm, you run Windows?
08:59:32 <Winterstream> ndm: of course. But it's hard to know without inspection whether an object is mutable or not.
08:59:44 <ndm> pejo: yes
09:00:03 <ndm> Winterstream: the whole OO methodology pretty heavily means object == mutable object
09:00:10 <dcoutts> Lemmih: where's the heap data you're looking at?
09:00:13 <blsecres> is there a way to turn on verbose error messages with cabal?
09:00:33 <pejo> Winterstream, if you're on a unix'y OS your chances of building ghc are quite high.
09:00:35 <dcoutts> blsecres: -v or -vN where N is 0-5
09:00:51 <roconnor> Lemmih: no idea.
09:01:08 <Winterstream> pejo: Not if you're as lame as I am and you just do "apt-get install ghc" :)
09:01:10 <dcoutts> roconnor: what data are you looking at?
09:01:16 <blsecres> dcoutts: thanks
09:01:22 <roconnor> dcoutts: no idea :)
09:01:44 <Lemmih> dcoutts: I'm looking at output from -sstderr and -p.
09:01:58 <pejo> Winterstream, there's step by step building instructions for developers somehwere on the wiki iirc. The GHC commentary (also on wiki) is also quite good.
09:02:05 <dcoutts> Lemmih: so does that tell you number of allocations or total allocated bytes?
09:03:10 <Winterstream> pejo: It looks as if GHC's code emitting code is abstract, since it can generate C or bytecode for the VM.
09:03:13 <Lemmih> dcoutts: The latter. I assume the size of allocations are more or less constant.
09:03:28 <blsecres> OK, is there a way to prevent cabal from deleting intermediate files during the build phase?
09:03:45 <Winterstream> pejo: So I wonder how hard it would be to generate Flash VM bytecode
09:03:52 <Winterstream> pejo: Probably much harder than I think...
09:03:54 <dcoutts> Lemmih: and this is compared to what? double allocations vs ... ?
09:04:00 <Winterstream> pejo: But damn, it would be cool
09:04:02 <roconnor> Lemmih: I do a heap allocation on every append and cons and uncons :/
09:04:25 <roconnor> er
09:04:32 <roconnor> not usually uncons.
09:04:36 <Lemmih> dcoutts: Seq Word8 vs. Robe.
09:04:45 <roconnor> Lemmih: Rope
09:04:46 <dcoutts> oh, that's bad
09:05:02 <Lemmih> Ah.
09:05:03 <dcoutts> we'd expect Seq Word8 to have very high allocation
09:05:19 <roconnor> And no every append, but some of them.
09:05:24 <roconnor> not every append.
09:05:24 <dcoutts> roconnor: are you allocating fixed size bytestrings ever, if so what size?
09:05:35 <roconnor> dcoutts: never.
09:05:54 <dcoutts> roconnor: when using pinned byte arrays you've got to be careful with sizes or one can end up using two 4k blocks when one would do.
09:06:14 <dcoutts> roconnor: what is your threshold for combining blocks ?
09:06:28 <roconnor> dcoutts: it defaults to 1k
09:06:31 <dcoutts> ok
09:06:35 <dcoutts> that's ok
09:06:45 <dcoutts> if you'd said 4k I'd have jumped on you :-)
09:07:00 <roconnor> I tried 4k. but the speed was the same.
09:07:14 <dcoutts> exactly 4k is the perfect anti-sweetspot
09:07:32 <dcoutts> since the cell overhead pushes you over 4k and it ends up taking 8k
09:07:38 <roconnor> :)
09:07:51 <dcoutts> in that case one should pick 4k - overhead, as we do in bytestring
09:10:05 <Lemmih> 32% of the allocations are done by Data.FingerTree.deep.
09:10:56 <roconnor> hmm
09:11:11 <roconnor> You'd think Seq would have the same issues.
09:13:06 <roconnor> ugh, I'm running low on ideas on how to make a reasonable Haskell implemenation.
09:13:17 <roconnor> I'm surprised C++ ropes are so good.
09:14:15 <Winterstream> Errrr. Egad. Looking at the reasons for why Haskell isn't yet available for .Net makes it seem like a Flash version would be pretty tricky to implement.
09:17:51 <ndm> Winterstream: remember, Yhc is available for .NET
09:18:21 <Heffalump> does it work yet?
09:18:43 <ndm> it always worked
09:18:46 <ndm> i think
09:19:00 <ndm> do you mean Yhc, or the .NET bit?
09:19:13 <Nafai> dcoutts: I'm having a hard time getting this going, could you take a look at this: http://hpaste.org/1917
09:19:22 <Winterstream> ndm: Yeah, I think that would be the best way to contribute. Of course, I'm not close to approaching even backend issues. The idea of doing front-end work for a Haskell compiler just intimidates the hell out of me.
09:19:23 <ndm> .NET bit is reliable, Yhc is about as reliable as nhc was, but without as many libraries - which i'd define as "useless, with future hope"
09:19:37 <dcoutts> Nafai: what's the problem exactly?
09:19:43 <ndm> Winterstream: the most useful contribution is a library, not compiler hacking
09:20:26 <Nafai> dcoutts: The tray icon is being shown but doTask or displayMsg are never being called
09:20:40 <dcoutts> Winterstream: though if you're good a backend compiler hacking, like native code generation ghc could do with some help there :-)
09:21:04 <Winterstream> ndm: Good point. I still need a couple of years worth of Haskell anyway before doing that sort of thing.
09:21:05 <dcoutts> Nafai: you're linking with -threaded ?
09:21:27 <Winterstream> dcoutts_: He he. Maybe in a decade or two ;)
09:21:29 <ndm> i personally think if GHC moved to Uniplate, they'd have a lot smaller compiler, and could spend more time on these things
09:22:20 * Nafai looks
09:22:28 <dcoutts> ndm: I'm not sure that's the main time drain in ghc, though the size does put off contributers
09:22:53 <dcoutts> Nafai: to use the threaded rts, you have to link your program using the -threaded flag.
09:23:07 <ndm> dcoutts, you'd be shocked how much size drop, maintainability improvements, easy of hacking you get with a proper generics solution
09:23:09 <dcoutts> Nafai: ie ghc --make Foo.hs -o foo -threaded
09:23:10 * ddarius hacked a tiny bit on GHC not too long after he'd started Haskell.
09:23:37 <Nafai> dcoutts: Yay!  That was it!
09:23:53 <Nafai> dcoutts: Well, for the initial call at least
09:24:16 <Nafai> Xlib: unexpected async reply (sequence 0xbc)!
09:24:18 <dcoutts> ndm: it does sound nice
09:24:25 <ddarius> ndm: It would shrink the size significantly, but I think most of the boilerplate that is needed is already written.
09:24:29 <dcoutts> Nafai: you're playing with fire :-)
09:24:48 <dcoutts> Nafai:   unsafeInitGUIForThreadedRTS has that name for a reason, it means you have to know what you're doing.
09:25:03 <ndm> ddarius: smaller code makes it easier to tweak, modify, since you have the "good stuff" in only one place
09:25:08 <Nafai> dcoutts: :( Is there a better way to do this?  I still would like to use the fifo if possible
09:25:29 <dcoutts> Nafai: the rule with the threaded rts and guis is that you have to ensure you never call the gui from more than one thread, and gui calls from different threads have to be 'posted' to the main thread
09:25:34 <ndm> i heard these arguments from Matt about Reach, then he tried Uniplate, made some functions 1/4 the size, found bugs he'd never seen, spotted generalisations and was very happy
09:26:04 <dcoutts> Nafai: in your case that probably means: where notify = postGUIAsync $ displayMsg icon
09:26:43 * Nafai tries
09:28:30 <Nafai>     Couldn't match expected type `IO ()'
09:28:30 <Nafai>            against inferred type `[Char] -> IO ()'
09:28:30 <Nafai>  
09:29:28 <mauke> missing argument
09:30:00 <dcoutts> Nafai: ah, displayMsg takes two parameters
09:30:26 <dcoutts> Nafai: so you need: notify line = postGUIAsync $ displayMsg icon line
09:30:56 <mauke> or just s/\$/./ :-)
09:31:40 <dcoutts> or that :-)
09:32:17 <Saizan> uuh, there's yet an user of StatusIcon :)
09:32:27 <dcoutts> Saizan: yep :-)
09:32:57 <Nafai> Saizan: Trying to be! :)
09:39:08 <roconnor> blah
09:40:38 <Lemmih> roconnor: Where do you concat small bytestrings?
09:40:48 <roconnor> Lemmih: in append
09:40:58 <roconnor> everything calls append.
09:41:11 <fasta> Can I speed up printing a list somehow?
09:41:44 <fasta> Xorg jumps to 12% (a bit ridiculous)
09:42:31 <fasta> Hmm, gnome-terminal is just slow as hell.
09:42:39 <pejo> fasta, doesn't it do that regardless of how you print?
09:42:43 <fasta> xterm goes at least 4 times faster.
09:42:54 <Winterstream> Anti-aliased fonts?
09:43:06 <fasta> Winterstream: probably
09:44:14 <Winterstream> Ugh. I could never figure out why my PC was running like a dog, until I realised that sub-pixel hinting was slowing down rendering to the point of my graphics being slower than on my P100 of yore.
09:54:24 <wli> This is one of the more bizarre things I've ever seen.
09:54:51 <wli> Something's running in the wrong monad.
09:55:01 <thorkilnaur> dcoutts, About the Gtk2Hs matter (http://www.haskell.org/pipermail/haskell-cafe/2007-July/029657.html), is my guess about how GHC handles the separate packages essentially correct?
09:55:03 <lambdabot> http://tinyurl.com/2ceygp
09:55:25 <dcoutts> thorkilnaur: yes, it appends flags for each dependent package
09:55:40 <dcoutts> thorkilnaur: so the glib package flags go before the gtk ones
09:55:49 <wli> dcoutts: Were you hinting you had a C parser written in Haskell?
09:56:01 <dcoutts> wli: yes, it's included in c2hs
09:56:26 <wli> dcoutts: ooh that could come in handy for static analysis
09:56:26 <thorkilnaur> dcoutts, Before? Isn't the problem that they (or the new ones) go after?
09:56:48 <dcoutts> thorkilnaur: maybe I'm confused, it'd be handy if you could @hpaste the output of ghc-pkg describe glib and gtk
09:57:03 <thorkilnaur> dcoutts, Just a sec ...
09:57:08 <dcoutts> thorkilnaur: though you can trim the large useless list of modules so it fits...
09:57:14 <fasta> It would be nice if one could click on terminal output to see what line generated it...
09:57:17 <wli> Somehow this renamer is ending up with a list type for nonterminals in the grammar...
09:57:37 <dcoutts> wli: someone was looking at making it into a prober standalone library for handling C
09:57:49 <dcoutts> wli: but I've not heard from them for a while
09:58:16 <wli> I'm screwing around with enough things as it is.
10:01:25 * roconnor is about to give up.
10:01:39 <roconnor> What does C++ have that I don't?
10:02:02 <hpaste>  thorkilnaur pasted "for p in gtk-0.9.12 glib-0.9.12 cairo-0.9.12; do echo $p:; ghc-pkg describe $p; done" at http://hpaste.org/1919
10:03:28 <dolio> reinterpret_cast<>
10:03:36 <Lemmih> roconnor: The append in uncons is really expensive.
10:04:16 <thorkilnaur> dcoutts, I would guess that GHC starts with gtk and its list of library-dirs that doesn't (for some reason) include /opt/local/lib
10:05:23 <thorkilnaur> dcoutts, And then continues with each of the dependants (in particular glib-0.9.12 cairo-0.9.12) and adds their library-dirs (that are not already present) to the global list
10:05:44 <dcoutts> thorkilnaur: right
10:06:08 <thorkilnaur> dcoutts, If this is true, GHC could be said to do something wrong, because it allows library-dirs in the final list in a different order, relative to the ingoing lists.
10:06:31 <roconnor> Lemmih: I tried replacing it with a modifyl, but it didn't seem to help.
10:06:40 <thorkilnaur> dcoutts, To be sure, if two packages have the same two library-dirs in opposite orders, then there is an unsolvable conflict.
10:06:47 <dcoutts> thorkilnaur: it's tricky since for libraries it's probably the right way around, but for search dirs it's wrong I think.
10:07:27 <thorkilnaur> dcoutts, I don't see any right way here, given the way linkers on Unixes work.
10:08:19 <dcoutts> thorkilnaur: mm
10:09:22 <thorkilnaur> dcoutts, Given A/libX.a, A/libY.a, B/libX.a, and B/libY.a (i.e. libX.a and libY.a in both A and B), you can't give a sequence of -Ls and -ls that allows you to select any four
10:09:33 <thorkilnaur> s/four/of the four/
10:11:06 <thorkilnaur> dcoutts, I would gladly solve this by simply forbidding, at any time, multiple library files in more than a single library directory
10:11:22 <thorkilnaur> dcoutts, but I am also a bit strict in such cases ...
10:12:03 <dcoutts> thorkilnaur: heh :-)
10:12:24 <dcoutts> thorkilnaur: what it really needs is the ability to give search paths to the linker on a per-lib basis
10:12:35 <dcoutts> none of this silly interposing nonsense
10:12:53 <thorkilnaur> dcoutts, Sure, that is done on other systems, but not all
10:13:18 <thorkilnaur> IBM mainframes, for example, have the same problem
10:14:38 <wli> What's the normal form of a CSG where rules are given by \alpha_1 A \alpha_2 -> \alpha_1 \beta \alpha_2 ?
10:14:48 <wli> +called
10:14:58 <thorkilnaur> dcoutts, And related to this: The fact that you have to specify your libraries in a particular order, in some cases, to get all references resolved
10:15:13 <dcoutts> thorkilnaur: yes, sigh
10:15:36 <thorkilnaur> dcoutts, But how are the library-dirs lists in the gtk, etc. packages actually generated?
10:16:04 <thorkilnaur> dcoutts, I mean, if /opt/local/lib were present in the right position on the gtk package, this problem would go away.
10:16:52 <thorkilnaur> dcoutts, (but whether this woould in any sense be a general solution of anything, I cannot say)
10:17:21 <dcoutts> thorkilnaur: I'll have a go at doing a not too hacky solution
10:17:43 <dcoutts> thorkilnaur: basically trying to not reorder the pkg-config output
10:17:54 <Lemmih> roconnor: It gives me quite a bump. 4m31 => 3m33.
10:18:16 <dolio> roconnor: Is there a place I can see your ropes? I wouldn't mind playing with them, although I don't know if I'm much of an optimizer.
10:18:16 <roconnor> you are running in 4min?
10:18:28 <Lemmih> roconnor: Yes.
10:18:34 <dcoutts> thorkilnaur: it'd be really handy if you could paste the output of ghc-pkg describe and pkg-config --libs for both glib and gtk
10:18:41 <roconnor> Lemmih: what machine
10:18:42 <dcoutts> thorkilnaur: or email it to me or something
10:18:52 <dcoutts> or indeed to the gtk2hs-devel list
10:18:53 <Lemmih> roconnor: The Seq version runs in slightly less than 2 minutes.
10:18:54 <roconnor> dolio: I can send you what I sent to Lemmih
10:19:09 <roconnor> Lemmih: those ratios are similar to what I have.
10:19:23 <roconnor> The Seq version should have 10x or more memory use.
10:19:36 <Lemmih> roconnor: 2Ghz AMD with 2Gb 800Mhz DDR2 memory.
10:19:47 <dolio> roconnor: All right. dan.doel at gmail.
10:20:51 <dolio> Did you cancel that?
10:21:05 <Lemmih> roconnor: You don't see a speed improvement when using modifyl?
10:21:05 <dmhouse> Good afternoon all.
10:21:45 <roconnor> Lemmih: I haven't really been getting consistent timings on my laptop :(
10:22:03 <thorkilnaur> dcoutts, certainly ... And by the way, on my Linux man ld, I just found "-( archives -) --start-group archives --end-group ... The  specified archives are searched repeatedly until no new undefined references are created."
10:22:07 <astrolabe> What is the neatest way to find the shortest of a list of strings?
10:22:26 <dmhouse> astrolabe: minimum (map length xs)
10:22:38 <dmhouse> astrolabe: unless you want the actual string with the shortest length
10:22:54 <astrolabe> dmhouse: yeah, the second I'm afraid.
10:23:04 <dmhouse> astrolabe: in which case, something like minimumBy (comparing length) xs
10:23:16 <astrolabe> thanks.
10:23:33 <dcoutts> fst $ minimumBy (comparing snd) [ (s, length s) | s <- ss ]
10:23:40 <dcoutts> hmm, that's not right
10:23:53 <dcoutts> but I'm trying to avoid computing the length of the strings more than once
10:23:56 <dmhouse> > minimumBy (comparing length) (words "hello then how are you i")
10:23:59 <roconnor> uncons (Rope r) | F.null r = Nothing
10:23:59 <roconnor>                 | B.null mid = Just (hd, Rope rest)
10:23:59 <roconnor>                 | otherwise = Just (hd, Rope $ F.modifyl (const mid) r)
10:24:01 <lambdabot>  "i"
10:24:07 * dmhouse must dash
10:24:08 <roconnor> Lemmih: that is what you do?
10:24:44 <fasta> Process haskell exited abnormally with code 139?
10:24:50 <fasta> What is 139?
10:24:59 <roconnor> @code 139
10:24:59 <lambdabot> Maybe you meant: more todo vote
10:25:07 <roconnor> worth a shot.
10:25:14 <astrolabe> thanks all
10:25:16 <Lemmih> roconnor: Yes.
10:25:24 <mauke> > 139 `mod` 128
10:25:26 <lambdabot>  11
10:25:31 <mauke> signal 11 looks plausible
10:25:38 <mauke> isn't that SIGSEGV?
10:26:36 <fasta> I suspect Emacs kills it
10:26:49 <fasta> I took the liberty of creating ultra long lines.
10:26:56 <fasta> And I think Emacs didn't like that.
10:27:00 <astrolabe> @type comparing
10:27:02 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
10:27:59 <xerox> > sortBy (comparing length) [[1,2,3],[1..100],[2]]
10:28:00 <lambdabot>  [[2],[1,2,3],[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24...
10:28:07 <xerox> head $
10:28:36 <fax> @src minimumBy
10:28:36 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
10:28:46 <fax> minimumBy = head $ sortBy ?
10:28:51 <mux> dcoutts: ping
10:29:18 <Syzygy-> Yeah 11 is SEGV
10:29:57 <dcoutts> hia mux
10:30:29 <roconnor> Lemmih: it takes 8min on my 1800 Mhz AMD Opteron(tm) Processor
10:30:34 <mux> dcoutts: I thought obraun@ was idle, but he just updated the FreeBSD hs-gtk2hs port to 0.9.12, so that you know :-)
10:31:06 <dcoutts> mux: yes he emailed me to say so, I've updated the gtk2hs website download page
10:31:20 <mux> well great!
10:31:24 <Lemmih> roconnor: How big your RNA output?
10:31:36 <astrolabe> Where does 'comparing' live?
10:31:43 <xerox> Data.List I think
10:31:44 <roconnor> Lemmih: see geneList1.rna
10:31:45 <xerox> ?index comparing
10:31:45 <lambdabot> bzzt
10:31:59 <xerox> No, it's not Data.List, hmm.
10:32:05 <astrolabe> @hoogle comparing
10:32:06 <lambdabot> No matches found
10:32:08 <mux> I guess Data.Ord
10:32:17 <xerox> Yesm you're right.
10:32:22 <xerox> s/m/,/
10:32:24 <Lemmih> roconnor: Ok, my rna matches that file.
10:32:33 <mux> but only in GHC 6.6, IIRC
10:32:34 <Lemmih> roconnor: 8mins for the Seq version?
10:32:49 <astrolabe> Yep Data.Ord.  Thanks
10:33:00 <roconnor> nope for the original Ropes version.
10:33:42 * chessguy considers writing a program in 2D to parse Endo's DNA
10:34:03 <roconnor> chessguy: it would probably be faster than my code.
10:34:36 <Lemmih> roconnor: How fast are the c++ versions?
10:35:18 <roconnor> people have claimed less than 1minute to process the original endo dna.
10:35:38 <roconnor> The geneList1 prefix runs a bit faster, so I've been using it for benchmarking.
10:36:38 <chessguy> what is it exactly i'm supposed to be doing in UMIX, anyway?
10:37:43 <chessguy> besides "compiling" qbasic programs to hack accounts, and playing adventure
10:37:49 <roconnor> chessguy: you will figure it out.
10:38:03 <roconnor> keep it up.
10:38:07 <Syzygy-> chessguy: You're compiling qbasic in unix? Wha?!
10:38:22 <chessguy> Syzygy-, no, UMIX
10:38:30 <roconnor> Syzygy-: QvickBasic.
10:38:39 <Syzygy-> Ah.
10:38:43 <Syzygy-> What's umix????
10:38:51 <chessguy> from last year's ICFP
10:39:11 <roconnor> Syzygy-: they found these stones at CMU.
10:39:29 <Syzygy-> Ah.
10:39:31 <roconnor> Syzygy-: search for computational archeolinguistis.
10:39:52 <xerox> ?go computational archeolinguistic
10:39:53 <chessguy> @go cult of the bound variable
10:39:55 <lambdabot> http://www.amazon.com/Peoples-Eastern-Central-Indo-European-Monograph/dp/0941694631
10:39:57 <lambdabot> http://www.boundvariable.org/task.shtml
10:39:57 <lambdabot> Title: ICFP Programming Contest, 2006 : Contest Materials and Task
10:40:12 <chessguy> boundvariable.org is it
10:40:50 <mrd> i wrote the program to convert dna to rna using Seq and got it to run in ~2m
10:41:48 <Lemmih> roconnor: Using modifyl reduces heap allocations from 231G to 171G.
10:42:11 <roconnor> ah sorry
10:42:17 <roconnor> @go Computational Archaeolinguistics
10:42:18 <lambdabot> http://www.myspace.com/zessa
10:42:18 <lambdabot> Title: www.myspace.com/zessa
10:42:29 <roconnor> got the spelling wrong.
10:42:33 <roconnor> that's what I was looking for
10:43:05 <roconnor> Lemmih: excellent
10:43:08 <wli> Uh-oh, epsilon productions.
10:43:22 <SamB> there are too many lambdabots in #oasis
10:43:24 <roconnor> Lemmih: it has reduced my time by about 1 minute.
10:43:58 <SamB> hmm, what does this mean:
10:44:09 <SamB> @unmtl ReaderT env (State st)
10:44:09 <lambdabot> err: Unknown MTL(1)
10:44:23 <wli> CSG's can't have epsilon productions...
10:44:46 <roconnor> http://blog.myspace.com/index.cfm?fuseaction=blog.ListAll&friendID=88598715
10:44:48 <lambdabot> Title: blog.myspace.com/zessa, http://tinyurl.com/3ba5jm
10:44:48 <wli> (lest they become phrase structure grammars)
10:45:11 <roconnor> ``sorry i've been "hiding in the lab" lately -- but things are really exciting here! we've found some interesting artifacts at the dig... more interesting than anyone expected! no one here has been able to stop talking or thinking about these square, metallic platters: each one is covered neat columns of a carefully written script. no idea what it means (yet!)... it could be an encrypted message or maybe just some accounting records from
10:45:11 <roconnor> centuries past. in any case, back to work!
10:48:35 <roconnor> Lemmih: This means I should probably submit my modifiyl / modifyr patch for FingerTrees.
10:49:03 <fasta> I wonder how fast finger trees are when compared to the same structure based on ST.
10:49:39 <wli> Are the normal semantics of the between parser combinator to subsume the opening and closing symbols/etc.?
10:49:46 <hpaste>  aaim pasted "pointfree ??" at http://hpaste.org/1920
10:50:04 <Lemmih> roconnor: Yeah.
10:50:14 <fasta> Uhm, why has Parsec "newline", but no "comma", or where is "comma" if it does exist?
10:50:18 <chessguy> roconnor, do i need to finish the qbasic program, or just hack the accounts with simple passwords
10:50:28 <wli> Or do they leave the opening and closing symbols around to parse?
10:50:33 <mauke> char ','
10:50:43 <roconnor> chessguy: finish the qbasic program.
10:50:56 <chessguy> oh, lovely
10:51:20 <fasta> mauke: yes, but it's not really consistent to have newline and not comma.
10:51:52 <roconnor> fasta: what does newline do?
10:52:03 <xerox> wli, the former
10:52:04 <fasta> roconnor: char '\n' AFAIK
10:52:13 <chumphries> haskell.org is a great website. think it has all the answers I need to get started learning
10:52:14 <roconnor> fasta: not char '\r'
10:52:24 <roconnor> or char '\n' >> char '\r'
10:52:27 <fasta> roconnor: you mean that windows thing?
10:52:34 <fasta> roconnor: it might do that too.
10:52:52 <fasta> roconnor: ok, well, maybe that's the reason, if any.
10:53:04 <roconnor> fasta: I don't know what it does, but it seems plausable.
10:53:21 <kowey> the token parser stuff has comma
10:58:35 <fasta> kowey: How to use that?
10:58:43 <fasta> kowey: since, it's a record field accessor
10:59:10 <kowey> well, you have to make a language def record
10:59:21 <fasta> kowey: heh
10:59:22 <kowey> and then have something like myComma = comma foo
10:59:30 <kowey> or more conveniently
10:59:39 <fasta> kowey: and what should be in this language definition record?
11:00:32 <kowey> well, stuff like what you want to be treated as identifiers, how your comments start/end, reserved words
11:00:53 <kowey> the token parser stuff is kind of handy in that things like comma skip over whitespace for you
11:01:04 <kowey> the parsec doc is likely to be much more helpful than me, i believe
11:02:06 <kowey> http://research.microsoft.com/users/daan/download/parsec/parsec.html <-- seems to have moved
11:02:07 <wli> I've got pieces of a grammar-constructing set of combinators but it looks pretty ugly and the API is shot due to state monad concerns.
11:02:08 <lambdabot> http://tinyurl.com/3x5nat
11:02:39 <wli> I've got no clue what to do with the semantic value crap.
11:02:42 <kowey> there's also some predefined defs like one for java
11:03:04 <wli> That seems to want/need dependent typing.
11:03:21 <wli> (As usual.)
11:03:23 <Cale> http://www.raintown.org/pictures/2004_03_24_Simon_PJ_Dinner/index.html -- heh
11:03:25 <lambdabot> Title: Simon PJ Dinner, http://tinyurl.com/38bjvu
11:06:31 <fasta> How to create a .hp file?
11:07:16 <Cale> Compile the program with profiling support and run it with +RTS -h* where * is a character representing whichever kind of heap profiling you want
11:07:22 <whaleofconfusion> I was thinking--if you pass a function the IO monad you give it free reign to do any IO it wants to
11:08:00 <Cale> whaleofconfusion: er, if you give the function a type whose result is in the IO monad
11:08:01 <whaleofconfusion> is there a way to pass it, say, a "keyboard input" stream that lets it take input from the keyboard but not do any other IO?
11:08:38 <whaleofconfusion> ok
11:08:44 <Cale> Sure, you could make it a pure function which takes a lazy list of the input. This is what interact does.
11:08:53 <Cale> :t interact
11:08:56 <lambdabot> (String -> String) -> IO ()
11:09:04 <whaleofconfusion> ah
11:09:12 <Cale> It builds an IO action from a pure String to String transformer
11:09:37 <whaleofconfusion> and do people write programs that way, with signatures like KeyboardInputStream -> MouseInputStream -> WindowEventStream?
11:10:22 <whaleofconfusion> where all side effects are then delegated to the calling process, and the streams are generated lazily without side effects
11:11:55 <Cale> whaleofconfusion: Well, for large applications, it gets tricky.
11:12:26 <whaleofconfusion> but it would allow you to limit the amount of IO the program can do to a predictable subset, and it allows stream redirection
11:12:30 <Cale> yeah
11:12:54 <Cale> You could also do this by restricting the IO monad though
11:14:01 <Cale> Just create a new module, newtype the IO monad, and only wrap certain IO actions to being them into your new monad. Provide a function which unwraps the newtype, but don't export the newtype constructor.
11:14:28 <Cale> Then you effectively have a monad in which only a specific subset of effects are available.
11:15:12 <Cale> I know that this is, for example, done with the Cairo renderer in Gtk2Hs
11:16:11 <wli> Oh man this is all complete crap. What's this foldl (<|>) pzero stuff?
11:16:40 <Cale> wli: that constructs a parser which parses any one of the parsers from the list
11:17:04 <SamB> Cale: isn't there like a prebuilt combinator for that?
11:17:14 <Cale> er, except that foldl seems like the wrong thing to use
11:17:39 <SamB> yeah, foldr is better I think
11:17:54 <Cale> Unless (<|>) is symmetric
11:18:02 <Cale> in which case it wouldn't matter so much
11:18:09 <wli> Well, that's not quite the concern; rather, it seems there's a better way to write things than open coding all the grammars constructed from the arguments by hand for each combinator like option, choice, many, etc.
11:18:12 <Saizan> it's left biased
11:18:22 <Syzygy-> I got shot in the foot with choosing foldr over foldl recently.
11:18:41 <Syzygy-> Figured it out when it turned out that I needed to reverse the list to geth things done in the right order.
11:19:06 <Cale> Well, sometimes you really do want foldl, that's why it's there :)
11:19:19 <Cale> It's just a somewhat unnatural order to do things in.
11:19:35 <Cale> (but common nonetheless)
11:21:44 <mux> @src choice
11:21:45 <lambdabot> Source not found. Maybe if you used more than just two fingers...
11:21:50 <mux> @hoogle choice
11:21:53 <lambdabot> Text.ParserCombinators.ReadP.choice :: [ReadP a] -> ReadP a
11:21:53 <lambdabot> Text.ParserCombinators.ReadPrec.choice :: [ReadPrec a] -> ReadPrec a
11:21:53 <lambdabot> Text.ParserCombinators.Parsec.Combinator.choice :: [GenParser tok st a] -> GenParser tok st a
11:23:07 <mm_freak> which LaTeX symbol should i use for `|' in a set definition like { 2x | x âˆˆ â„• } ?
11:23:08 <mux> choice ps           = foldr (<|>) mzero ps
11:23:10 <mm_freak> \mid ?
11:23:38 <wli> \vert
11:24:34 <mm_freak> thanks
11:24:45 <wli> It seems that there is an algebra of parser combinators of which I'm unaware.
11:25:47 <Cale> \mid works better actually
11:25:52 <wli> It seems there is an mzero and a <|>, what else is there?
11:26:02 <Cale> (it gets the spacing right)
11:26:02 <wli> Papers?
11:26:21 <Cale> wli: You could start with the parsec documentation
11:26:26 <mux> wli: mzero is pfail
11:26:28 <wli> I'm looking at it.
11:26:41 <Cale> http://legacy.cs.uu.nl/daan/download/parsec/parsec.html -- this?
11:26:50 <dynamix> is there a better way to get the n-1th element  of a list than  this ? head $ tail $ reverse [1..10]
11:27:03 <wli> Cale: That's the one.
11:27:18 <mauke> last . init
11:27:50 <Cale> http://www.cs.nott.ac.uk/~gmh/monparsing.ps -- but this is rather old
11:27:57 <Cale> It predates the Monad class :)
11:28:31 <mux> too bad there is no back-tracking choice parser combinator
11:28:34 <roconnor> > last [1..10]
11:28:34 <mux> something like
11:28:35 <lambdabot>  10
11:28:42 <mux> :t choice2 = foldr  ((<|>) `on` try) mzero
11:28:44 <lambdabot> parse error on input `='
11:28:52 <roconnor> dynamix: last [1..10]
11:28:52 <hpaste>  aaim pasted "more pointfree" at http://hpaste.org/1921
11:28:58 <Cale> Er, no, it predates the modern monad class, I should say
11:29:03 <Cale> It's right on the edge :)
11:29:14 <Cale> bind was called, bind
11:29:35 <mux> :t choice
11:29:37 <lambdabot> Not in scope: `choice'
11:29:41 <mux> ah, that's why
11:29:52 <dynamix> roconnor:  that gives 10, i want 9 . last .init $ [1..10]
11:29:56 <dynamix> gives that
11:30:35 <hpaste>  Cale annotated "more pointfree" with "even a little more" at http://hpaste.org/1921#a1
11:30:40 <whaleofconfusion> mathematical integration is dynamically scoped
11:31:10 <Cale> whaleofconfusion: What exactly do you mean by that? :)
11:31:17 <sorear> du is a binder!
11:31:18 <whaleofconfusion> the dx chooses what the integrand is considered to be a function of
11:31:27 <roconnor> dynamix: ah right,
11:31:31 <Cale> ah, okay
11:31:35 <sorear> whaleofconfusion: and that's different from \x -> foo?
11:31:46 <beelsebob> o.O
11:31:54 <beelsebob> why on earth do you want it point free?
11:31:54 <roconnor> dyamix: I'm not sure which is faster: the original way or last . init
11:31:55 <Cale> Yeah, it's not really any different from that
11:31:58 <whaleofconfusion> let's say you want to integrate f dx from 0 to 1, numerically
11:32:04 <Cale> beelsebob: no idea
11:32:13 <Cale> beelsebob: I just replied to the previous paste :)
11:32:16 <whaleofconfusion> then you evaluate f in the dynamic environment where x = k, for k in small steps from 0 to 1
11:32:21 <beelsebob> Cale: fair enough
11:32:26 <beelsebob> @pl doom
11:32:27 <lambdabot> doom
11:32:29 <beelsebob> hehe
11:32:49 <Cale> whaleofconfusion: that would result in f
11:33:04 <whaleofconfusion> well, multiplied by delta x each time
11:33:15 <whaleofconfusion> and summed
11:33:19 <Cale> whaleofconfusion: because f is clearly a constant in x :)
11:33:21 <beelsebob> interesting @pl /me dooms
11:33:21 <beelsebob> no
11:33:42 <whaleofconfusion> only in mathematical notation you can't assume that f is a constant in x, you have to make sure it is
11:33:45 * beelsebob wondered if that was a lambdabot security hole
11:33:49 <Cale> whaleofconfusion: if you want to integrate the function f, you elide the dx
11:33:55 <whaleofconfusion> you could define f = x^2 + 3
11:33:58 <Cale> Or you write f(x) dx
11:34:13 <sorear> beelsebob: there are much easier ways.
11:34:18 <whaleofconfusion> and then int f dx is mathematically correct
11:34:22 <Cale> You never ever write integral of f dx and then spuriously stick an x somewhere in the definition of f
11:34:34 <wli> ooooh
11:34:47 <whaleofconfusion> you do!  take the divergence theorem
11:34:49 <wli> http://www.cs.uu.nl/people/doaitse/Papers/1996/DetErrCorrComPars.pdf <-- this appears to implement what I actually want
11:34:49 <sorear> @. where+ read "ping \001PING\001"
11:34:49 <lambdabot> Done.
11:34:53 <lambdabot> http://tinyurl.com/gkvhj
11:34:55 <beelsebob> sorear: probably
11:34:56 <sorear> @where ping
11:35:17 <roconnor> lambdabot: that tickles
11:35:36 <sjanssen> @where+ ping :(
11:35:36 <lambdabot> Done.
11:35:47 <Syzygy-> sorear: Congratulations. You just built a nuisance machine. :P
11:35:49 <whaleofconfusion> actually the divergence theorem is abit more complicated than I need, but in it F is assumed to be a function of dS and dV
11:35:55 <beelsebob> lol
11:36:09 <whaleofconfusion> er, S and V
11:36:18 <dcoutts> thorkilnaur: thanks for all the info
11:36:21 <whaleofconfusion> it's not a constant just because its argument is left implicit
11:36:33 <wli> No, not quite. LL(1)/LL(k).
11:37:26 <thorkilnaur> dcoutts, You're welcome ...
11:37:51 <whaleofconfusion> or, say, the definition of work on a gas
11:37:59 <whaleofconfusion> W = Int P dV
11:38:01 <wli> Have I mentioned I abhor LL(k)?
11:38:21 <whaleofconfusion> P is a function of V, but it's not stated explicitly-
11:38:49 <Cale> whaleofconfusion: Uh, but that one is sort of different. dV there isn't just a binder, you're using a completely different integral :)
11:38:55 <whaleofconfusion> you could say, but you don't have to say, W = Int P(V) dV
11:39:23 <sorear> wli: what do you want?
11:39:36 <Cale> You're integrating a differential form.
11:39:46 <wli> sorear: LR(1) for deterministic or GLR for nondeterministic.
11:40:01 <whaleofconfusion> well let's say PV = 5 then P = 5/V
11:40:07 <Cale> It's not the same as dynamic scope :)
11:40:08 <whaleofconfusion> and you would be integrating 5/V dV
11:40:09 <sorear> wli: happy maybe?
11:40:21 <wli> sorear: No. I want them in parser combinators.
11:40:26 <whaleofconfusion> at a constant temperature
11:40:40 <Cale> whaleofconfusion: Mathematicians never do this.
11:40:49 <Cale> (well, I don't know any that do)
11:41:28 <wli> sorear: I've belted out 300+ LOC that dork around with building up grammars from parser combinators, so it's not mere idle speculation (granted, I was doing things quite wrong, so it's not a very useful 300 LOC).
11:42:21 <whaleofconfusion> well how about this simple example from mathematics, not physics
11:42:22 <Cale> whaleofconfusion: If you're talking about integrating differential forms, that's a little different :) There's lots of abuses that go on in physics though, and I can't speak for those guys :)
11:42:23 <whaleofconfusion> Green's theorem
11:42:41 <whaleofconfusion> Integral about C of L dx + M dy
11:42:49 <sorear> wli: in general that's a very hard problem because Haskell lacks observable graph-structure; maybe look at the Frisby code for inspiration?
11:43:28 <wli> whaleofconfusion: Learn the General Stokes' Theorem once and forget all that Green's, divergence, and 3D Stokes garbage. I totally blew away vector calc by means of such (and the graders took it).
11:43:43 <whaleofconfusion> L and M are both functions of x and y, but it's left implicit
11:43:46 <dmhouse> Cale: it's quite common to say int y dx where y is taken to be a function of x, though.
11:43:50 <wli> sorear: Not sure what you mean about the graph structure.
11:43:56 <wli> @go Frisby
11:43:58 <lambdabot> http://www.frisbytire.com/
11:43:58 <lambdabot> Title: Frisby Tire Co.
11:44:07 <wli> Not quite what I had in mind.
11:44:16 <dmhouse> Cale: "interdependant variables" is the term, I think.
11:44:17 <mauke> @where frisby
11:44:18 <lambdabot> I know nothing about frisby.
11:44:19 <Cale> dmhouse: not where I'm from, unless y is explicitly an expression involving x
11:44:27 <sorear> @go frisby john meacham packrat
11:44:29 <lambdabot> http://repetae.net/repos/frisby/_darcs/inventory
11:44:34 <dmwit> ?go frisby haskell
11:44:35 <lambdabot> http://www.mail-archive.com/haskell-cafe@haskell.org/msg26928.html
11:44:36 <lambdabot> Title: Re: [Haskell-cafe] Maintaining the community
11:44:49 <dmhouse> Cale: hrm, well that's probably a good convention, but I think I have seen it.
11:45:13 <wli> sorear: Not 100% sure what Frisby is.
11:46:21 <sorear> wli: It's a parser combinator library that needs to generate a grammar in some sense.
11:47:24 <Cale> The LHS of Green's theorem is expressed as an integral on the boundary of a compact two-dimensional manifold-with-boundary in R^2 of a particular differential form. In that case dx and dy are *not* binders
11:48:20 <Cale> You're integrating the differential form which is (a dx + b dy). a and b are functions M -> R
11:49:11 <Cale> dx and dy are the names of the usual basis differentials on R^2
11:49:15 <wli> sorear: It looks like most of what I want to take home from this is how he gets semantic actions.
11:50:41 <dynamix> its very uncomfortable to not be able to use caps for funciton or param names .
11:51:00 <Cale> dynamix: You can use them in the middle :)
11:51:25 <dmead> and at the end ;o
11:51:29 <Winterstream> dynamix, you sound like an Oberon/Pascale man :)
11:51:30 <dmead> just not the first character :<
11:51:48 <dmead> ?losers
11:51:48 <lambdabot> Maximum users seen in #haskell: 348, currently: 346 (99.4%), active: 23 (6.6%)
11:52:12 <sieni> ?losers
11:52:12 <lambdabot> Maximum users seen in #haskell: 348, currently: 346 (99.4%), active: 24 (6.9%)
11:52:33 <Cale> For anyone confused about this dx and dy stuff, I really recommend Spivak's "Calculus on Manifolds", particularly chapter 4.
11:52:36 <Winterstream> @karma Pascale
11:52:36 <lambdabot> Pascale has a karma of 0
11:52:41 <Winterstream> Oops
11:52:44 <Winterstream> @karma Pascal
11:52:44 <lambdabot> Pascal has a karma of 0
11:52:54 <Winterstream> I had a certain girl on my mind :)
11:53:03 <jyp> @where+ frisby http://repetae.net/computer/frisby/
11:53:03 <lambdabot> Done.
11:53:27 <Winterstream> How does one reference something once you've told lambdabot about it?
11:53:32 <mm_freak> what's more common in set notation:  {a|b} or {a:b}?
11:53:33 <sorear> @where frisby
11:53:33 <dmhouse> Winterstream: ?where
11:53:33 <lambdabot> http://repetae.net/computer/frisby/
11:53:49 <dmhouse> mm_freak: : is more common, although | is used too.
11:53:53 <Winterstream> Thanks
11:53:58 <mm_freak> ty
11:53:58 <dynamix> nope, teh math problem im trying to solve uses caps to represent soem quants
11:55:20 <Cale> dynamix: hehe
11:55:20 <dmhouse> dynamix: which problem is that?
11:56:30 <jyp> @where parsek
11:56:30 <lambdabot> I know nothing about parsek.
11:57:04 <Cale> http://www.cs.chalmers.se/Cs/Research/Functional/MultiLib/koen/Parsek.hs
11:57:06 <lambdabot> http://tinyurl.com/yxnngl
11:57:12 <Cale> @where+ parsek http://www.cs.chalmers.se/Cs/Research/Functional/MultiLib/koen/Parsek.hs
11:57:12 <lambdabot> Done.
11:57:55 <wli> Cale: What's that?
11:58:04 <jyp> A cool parsing library
11:58:25 <Cale> wli: It's a ReadP-inspired Parsec-lookalike
11:58:34 <Cale> With symmetric choice.
11:58:43 <Cale> and lots of useful ways to run parsers
11:59:05 <jyp> and no need for the dreaded "try"
11:59:15 * wli seems to have a problem no one has seriously tried to tackle on his hands.
11:59:22 <dmhouse> Anyone know any papers/tutorials etc explaining parallel choice parsing?
11:59:39 <jyp> dmhouse: http://www.cs.chalmers.se/~koen/pubs/entry-jfp04-parser.html
11:59:40 <lambdabot> Title: Koen Claessen - Publications
11:59:56 <jyp> An excellent paper. ;)
12:00:06 <dmhouse> Thanks, jyp.
12:00:14 <dynamix> dmhouse: i will post the code in a few hours
12:00:25 <mux> ?where polyparse
12:00:26 <lambdabot> http://www.cs.york.ac.uk/fp/polyparse/
12:01:22 <jyp> wli: what is it exactly that you want to do?
12:01:43 <dynamix> in european terms it is,  parametric integer solutions of  linear diophantine equations using simple continued fractions.
12:01:48 <wli> jyp: Non-LL(k) parsing (and especially not LL(1) parsing).
12:02:10 <dmhouse> Is Koen Claessen in Cambridge? At the university or MR?
12:02:13 <wli> jyp: No goddamn left recursion restrictions.
12:03:24 <dynamix> dmhouse: did that make sense ?
12:03:54 <jyp> wli: check this out maybe: wiki.di.uminho.pt/twiki/pub/Research/PURe/PurePublications/PUReTR041101.pdf
12:03:58 <Cale> Hehe, that's a pretty bind. Looks like \succ\!\!\!\succ
12:03:59 <jyp> (Generalized LR Parsing in Haskell)
12:04:00 <sorear> chainl1 isn't good enough for you?
12:04:10 <dmhouse> dynamix: yes in that I've heard of all those things, no in that it sounds over my head :)
12:04:21 <wli> jyp: I think those are parser generators vs. parser combinators.
12:04:48 <wli> (I recognize the URL)
12:05:39 <wli> jyp: Yeah, it's HaGLR, which is a parser generator, not a parser combinator library.
12:05:47 <dynamix> ok im back to work.. ill post teh code tonight
12:05:49 <dynamix> bye
12:05:51 <jyp> wli: " In this report we embark on a more challenging approach: to provide GLR support directly in Haskell in the form of parser combinators"
12:06:01 <jyp> I've not read through it though.
12:06:24 <jyp> but it's a pretty definite statement :)
12:06:58 <wli> jyp: I've gone fishing for their code and it doesn't look like anything of the sort.
12:07:29 <jyp> That's too bad :/
12:08:30 <Lemmih> roconnor: Ping.
12:11:43 <dolio> @remember JonHarrop In Haskell, programmers write declaratively and often optimize by randomly fiddling until the current version of GHC happens to reduce it in an asymptotically more efficient way.
12:11:43 <lambdabot> Done.
12:12:34 <Lemmih> roconnor: Using a custom monad shaves another minute off and brings down the heap allocations from 171G to 100G.
12:13:35 <Lemmih> roconnor: The Seq version is now only allocating 31G.
12:14:17 <wli> jyp: Hmm, it looks like I looked in the wrong place.
12:15:07 <jyp> wli: So you found something of interest? I'd be interested  :)
12:15:43 <wli> jyp: Well, I don't see a meaningful parser combinator front end, but it does appear to construct GLR state machines on the fly.
12:16:07 <Lemmih> roconnor: The Seq version finishes in slightly less than a minute.
12:18:17 <wli> jyp: Build up a grammar it understands somehow and it appears that it will parse it via on-the-fly GLR.
12:18:56 <jyp> wli: So all it lacks is a combinator interface?
12:19:03 <wli> jyp: Correct.
12:19:32 <SamB> so what kind of interface does it have then?
12:19:53 <wli> SamB: Pass it grammar tables constructed somehow.
12:19:57 <jyp> wli: it might be possible to support left recursion with dirty tricks like memo-tables, etc.
12:20:51 <wli> jyp: To Hell with that. It's not so far out to build up a grammar via parser combinators, and all the heavy lifting (i.e. the on-the-fly state machines) is already done, so ...
12:21:31 <wli> jyp: It's even got some sort of model for semantic actions.
12:22:21 <jyp> The problem is that, no matter the "parsing engine", you get loops with left recursion in a classic combinator framework
12:23:30 <wli> jyp: I don't think you understand what this does. The combinators only construct a grammar. The grammar is then postprocessed into a state machine's transition table, and the bloody thing works with left recursion as surely as any parser generator's crud.
12:24:45 <jyp> wli: Alright, but the loops occur at construction-time.
12:25:16 <wli> jyp: "postprocessing" being a function that converts whatever the parser combinators build up in terms of a grammar into the state machine table, and then (of course) yet another function to execute.
12:26:26 <wli> jyp: construction-time? Hmm.
12:26:54 <jyp> grammar construction.
12:29:17 <falconair> ngf
12:29:56 <wli> jyp: You just get a putatively cyclic data structure not evaluated until it's examined for the purposes of either intermediate constructions or final coversions. With identity tagging and maintaining environments you can just halt recursions over things that would examine them, or possibly use a different representation from a directly-constructed tree. You're working with data now vs. function invocation so you can do these things.
12:31:13 <jyp> wli: "identity tagging" is the dirty tricks I was referring about :)
12:31:50 <wli> jyp: It's not dirty at all; you have to do it anyway to represent nonterminal symbols.
12:32:52 <fasta> This is a class method: foo :: (Z r q, Monad m, Show b, Show a) => Int -> r a b -> m Bool. I would like to implement this using getBounds (from MArray), but when I do that the context gets expanded.
12:33:11 <fasta> Is there anyway I can implement foo while using getBounds?
12:33:43 <wli> jyp: Actually the way I'm doing it, nonterminals are represented by variable names (actually numbers), so left recursion results in the integer used to represent the nonterminal appearing in rule bodies toward the left.
12:34:38 <ddarius> :t getBounds
12:34:40 <lambdabot> Not in scope: `getBounds'
12:34:57 <ddarius> :t Data.MArray.getBounds
12:34:58 <lambdabot> Couldn't find qualified module.
12:35:25 <wli> jyp: So it turns out to be rather dull.
12:36:02 <fasta> getBounds :: (MArray a e m, Ix i) => a i e -> m (i, i)
12:36:40 <Winterstream> â™« Breed - Nirvana â™«
12:37:00 <ddarius> fasta: It's adding the MArray a e m constraint?
12:37:11 <fasta> ddarius: yes
12:37:22 <fasta> ddarius: I guess I should select a specific instance.
12:37:33 <fasta> ddarius: but AFAIK, it's already determined by context
12:38:14 <ddarius> fasta: Depending on how you want to use it, you may be able to do it in a separate monad.
12:38:44 <pjd> dynamix: continued fractions for *parsing*?
12:39:06 <fasta> ddarius: Please clarify
12:39:21 <pjd> oh, i think i misread
12:41:04 <ddarius> fasta: What are you applying getBounds to?
12:41:29 <fasta> ddarius: to STArray s Int Foo
12:43:38 <ddarius> fasta: Where are you getting the -value- you are applying getBounds to?
12:43:45 <fasta> It has (MArray (STArray s) Foo m) in the context, but AFAIK, m can only be the m in MonadST s m
12:44:49 <fasta> ddarius: from a field with the type as above of data Foobar s a b
12:46:26 <ddarius> If you are binding the getBounds computation into the monadic computation of the result, then either you need to have the constraint, or you need to fix m to be ST.
12:47:04 <fasta> ddarius: why can't it be MonadST?
12:47:17 <fasta> ddarius: I already fixed the constraint before you suggested it, btw.
12:47:30 <fasta> ddarius: oh, never mind
12:47:40 <fasta> ddarius: I need an extra instance for MArray to do that, I guess.
12:47:51 <fasta> ddarius: i.e. for making the connection with MonadST
12:48:37 <fasta> Still, that I _have_ to specify the type is something I deeply don't like.
12:48:59 <fasta> Everything I specify about the program that's not strictly necessary is a waste.
12:50:25 <sieni> fasta: your last statement is slightly different from the previous one
12:50:58 <fasta> sieni: why?
12:50:59 <hpaste>  jleedev annotated "mergesort" with "faster mergesort" at http://hpaste.org/1891#a7
12:51:16 <roconnor> Lemmih: do touch empty.dna, and run it instead of geneTable1.dna
12:51:24 <roconnor> Lemmih: can you test how long that takes?
12:51:42 <sieni> fasta: you might want to specify something for e.g. documentation purposes even if it's not strictly necessary
12:51:44 * roconnor is interested in Lemmih's custom monad.
12:52:13 <fasta> sieni: ok, I was slightly generalizing
12:52:24 <wli> jleedev: You could always try a polyphase mergesort. You get to do IO, too.
12:52:28 <fasta> sieni: you are nit picking, though
12:52:40 <jleedev> wli: polyphase?
12:53:09 <wli> jleedev: Yes, used for datasets too large to fit in memory.
12:53:37 <wli> jleedev: Your toggle does much the same thing as my splitParity
12:54:06 <jleedev> so it does. i think mine's easier to read, though
12:54:15 <jleedev> splitParity' means it's strict, correct?
12:54:32 <wli> jleedev: No, it's just the other half of a pair of mutually-recursive functions.
12:54:54 <jleedev> wli: gotcha
12:56:09 <fasta>  Warning: No explicit method nor default method for `Data.Array.Base.unsafeWrite'
12:56:25 <fasta> This is not documented in my version of the documentation.
12:56:59 <hpaste>  Lemmih pasted "Custom monad" at http://hpaste.org/1922
12:57:23 <fasta> Oh, I guess they got introduced very recently.
12:57:31 <SamB> hmm, probably it ought to have a default method that uses the safe one...
12:57:42 <SamB> fasta: not really...
12:57:58 <fasta> that*
12:58:05 <fasta> SamB: not really?
12:58:24 <fasta> SamB:  one of the method was introduced less than a month ago because I asked for it.
12:58:29 <SamB> oh.,
12:58:33 <fasta> SamB: I am not sure what you mean by "not reall".
12:58:35 <fasta> y
12:58:45 <fasta> methods*
12:58:47 <SamB> maybe I'm confused with some other method then
12:59:53 <fasta> SamB: I am talking about this one: Data.Array.Base.unsafeNewArray_
13:00:17 <SamB> what does that do?
13:00:56 <Lemmih> roconnor: Oh, I also used unsafeHead and unsafeTail, btw.
13:03:53 <fasta> class (Monad m) => MArray a e m where getBounds :: (Ix i) => a i e -> m (i, i) newArray :: (Ix i) => (i, i) -> e -> m (a i e) newArray_ :: (Ix i) => (i, i) -> m (a i e) Data.Array.Base.unsafeNewArray_ :: (Ix i) => (i, i) -> m (a i e) Data.Array.Base.unsafeRead :: (Ix i) => a i e -> Int -> m e Data.Array.Base.unsafeWrite :: (Ix i) => a i e -> Int -> e -> m ()
13:04:12 <fasta> I also don't get why the lowest methods have Data.Array.Base. as a prefix
13:04:19 <fasta> Do you?
13:04:42 <SamB> fasta: you haven't got that in your namespace
13:04:56 <SamB> that is, it isn't imported where you are
13:05:16 <fasta> SamB: I imported it now.
13:05:20 <fasta> SamB: and same result
13:05:42 <SamB> fasta: what does your prompt look like?
13:05:52 <fasta> *Main>
13:06:17 <SamB> and Main imports Data.Array.Base?
13:06:18 <SamB> how odd.
13:06:20 <fasta> I did import import Data.Array.Base
13:06:36 <fasta> SamB: do you have a recent (less than 2 weeks) 6.7?
13:06:40 <SamB> nope
13:07:32 <SamB> what does the export list for Data.Array.Base look like?
13:08:30 <fasta> SamB: doing :browse on the module shows it
13:10:37 <Lemmih> roconnor: Seq on empty dna takes 2m17s.
13:11:40 <roconnor> not bad
13:12:02 <roconnor> unsafeHead is from ByteString?
13:12:10 <Lemmih> roconnor: Data.ByteString.Base
13:12:32 <dcoutts> moving to Data.ByteString.Unsafe in bytestring >=0.9
13:14:14 <roconnor> Lemmih: do strict function fields do anything?
13:14:29 * roconnor knew he shouldn't have gotten involved with monad transformers.
13:14:36 <wli> roconnor: How can they?
13:14:54 <ddarius> undefined and \_ -> undefined are different values.
13:14:54 <wli> roconnor: Modulo JIT, anyway.
13:15:12 <Lemmih> roconnor: The strictness of RNACont and DNA is most likely irrelevant.
13:15:19 <roconnor> wli: const id 5 may reduce to id perhas.
13:15:36 <roconnor> Lemmih: thing the strictness of a matters either
13:15:37 <Lemmih> roconnor: Not sure about 'a'. Haven't compared the stg code yet.
13:15:53 <wli> roconnor: Compiled code doesn't work by reductions.
13:15:53 <roconnor> I cant imagine a compiler can do much with a strict type variable field.
13:16:08 <roconnor> wli: I thought it did
13:16:13 <roconnor> wli:  more or less
13:16:19 <roconnor> wli: graph reduction.
13:17:15 <wli> roconnor: The compiled code models graph reduction vs. being graph reduction per se. When you get down to code vs. data things are all lambda lifted etc.
13:17:29 <Lemmih> roconnor: The Rope version is really slow on the empty dna.
13:17:47 <roconnor> :(
13:18:27 <roconnor> Lemmih: presumably the custom monad advantage is almost entirely removing the ErrorT and reader part of the RWS monad.
13:18:42 <Lemmih> roconnor: Right.
13:18:56 <wli> roconnor: Where a tree-reducing interpreter can take a function applied to a function and get a nontrivial result, once you're working in that sort of environment all you get is a closure with the code pointer sitting around waiting to get passed in when the supercombinator is finally saturated.
13:18:58 <roconnor> Lemmih: hopefully the memory use of the Rope code is small.
13:19:08 <Lemmih> roconnor: The 'getPattern' loop was horrible with the old monad.
13:19:18 <mrd> @pl \(x,y) -> (x,y+1)
13:19:19 <lambdabot> second (1 +)
13:19:23 <mrd> :t second
13:19:24 <roconnor> Lemmih: why?
13:19:25 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
13:20:52 <Lemmih> roconnor: It looked something like this: (case x1 of (a,_,_) -> x, case x1 of (_,b,_) -> b, case y of (_,_,c) -> c + case x of (_,_,c) -> c)
13:21:59 <roconnor> Lemmih: what is x1?
13:22:23 <jyp> Will you guys fix a nice rope library for us to use ? :)
13:22:30 <Lemmih> roconnor: The result of 'getPattern'
13:23:12 <Lemmih> roconnor: A stricter version would be better: case x1 of (a,b,c) -> (a,b,case y of (_,_,c') -> c++c')
13:23:30 <Lemmih> (The code in question is: liftM (Pbase i:) getPattern)
13:24:02 <Lemmih> (y is roughly (Pbase i:))
13:24:52 <roconnor> Lemmih: what is the (a,b,c)?
13:25:09 <Lemmih> roconnor: (Either Error Ok, DNA, RNA)
13:25:29 <roconnor> oh
13:25:56 <roconnor> @src Control.Monad.RWS.RWS (>>=)
13:25:56 <lambdabot> Source not found. I've seen penguins that can type better than that.
13:26:01 <roconnor> @src RWS (>>=)
13:26:01 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
13:26:10 <roconnor> @source Control.Monad.RWS
13:26:10 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/RWS.hs
13:26:28 <hpaste>  fasta pasted "incoherent instances not working. " at http://hpaste.org/1923
13:26:44 <Lemmih> roconnor: The new code is: case getPattern dna of Finish rna -> Finish rna; Continue val rna dna' -> Continue (Pbase i:val) rna dna'
13:27:02 <wli> @go House Haskell operating system
13:27:04 <lambdabot> http://programatica.cs.pdx.edu/House/
13:27:04 <lambdabot> Title: House
13:27:35 <Lemmih> No more unnecessary laziness, no more unnecessary packing/unpacking of tuples.
13:28:31 <fasta> Can anyone look at my paste?
13:28:53 <roconnor> Lemmih: I think I understand
13:29:39 <roconnor> Lemmih: is the !a important for this?
13:30:49 <Lemmih> roconnor: No.
13:32:13 <roconnor> Lemmih: Was it the ErrorT causing the problem before?
13:33:07 * roconnor tries to understand why the custom monad works better.
13:33:20 <Lemmih> roconnor: I think it was about as damaging as the RWS.
13:33:47 <roconnor> Lemmih: can you paste your bind function?
13:34:38 <hpaste>  Lemmih annotated "Custom monad" with "Monad instance." at http://hpaste.org/1922#a1
13:35:16 <Lemmih> roconnor: Without the ErrorT there would still be a lazy two-element tuple.
13:35:46 <Lemmih> Or so I think.
13:37:35 <roconnor> Lemmih: I don't see why there would be two case statements on x1 when using the RWS monad.
13:37:57 <roconnor> Lemmih: the let construct should only create one case analysis right?
13:39:41 <fasta> Never mind about my paste.
13:41:07 <wli> This thing has issues...
13:41:24 <wli> *Language.ContextFree.Examples> glraccept exprC $ "(1+2)*3"
13:41:24 <wli> [True]
13:41:25 <Lemmih> roconnor: The extra strictness isn't necessary. In fact, without the strictness the program is slightly faster.
13:41:33 <Lemmih> roconnor: I don't know.
13:41:40 <wli> I at least expected a parse tree or something.
13:42:22 <wli> *Language.ContextFree.Examples> glrStrict exprC $ "1 + 2 * 3"
13:42:22 <wli> *** Exception: Language/ContextFree/G_SLR.hs:122:9-33: Irrefutable pattern failed for pattern (Data.Maybe.Just i)
13:42:58 <wli> Is it just me or is there some sort of robustness problem here?
13:43:07 <roconnor> Lemmih: okay.  I'm not convinced about your reasoning a about the problems with the old monad and getPattern.
13:43:44 <Lemmih> roconnor: Have a look at the stg code.
13:44:05 <roconnor> Lemmih: oh, thats how found that case analysis!
13:44:14 <roconnor> Lemmih: that's pretty convincing
13:45:17 * roconnor wonders how that manages to happen
13:46:00 <roconnor> I suppose we could get rid of the ErrorT, and see how that affects the stg output
13:52:07 <wli> Okay, as it turns out, HaGLR's meaningful parsers don't support semantic actions.
13:53:20 * fasta pushes GHC to the max
13:53:58 <fasta> Is there any way to get a lifted instance automatically?
13:54:22 <fasta> For this use case: (MonadTrans t, Monad m, Foo a b m, Monad (t m)) => Foo a b (t m)
13:54:46 <dcoutts> fasta: you know about newtype deriving I assume
13:55:22 <fasta> dcoutts: I only use it for newtyping existing monads.
13:55:51 <dcoutts> and deriving the instances for the various monad classes
13:56:10 <fasta> dcoutts: right, but that's a limited set, right?
13:56:30 <dcoutts> I suppose
13:56:35 <fasta> dcoutts: i.e. does not work for my use case?
13:57:05 <dcoutts> fasta: I'm not actually sure, I don't understand your case, so probably not :-)
13:57:33 <fasta> dcoutts: GHC had trouble understanding it too, don't worry.
13:57:34 <fasta> dcoutts: ;)
13:58:20 <fasta> It should generate lift . for a function with one argument, ((lift .) .) for a function with two args, etc.
13:58:30 <fasta> for every function in the class
13:58:48 <fasta> Can I do that myself with TH?
13:59:41 <dcoutts> probably, but it might not be worth it
13:59:47 <kaol> is there some way to make ghc give a hint about how it concludes what a type's expected type is?
14:00:52 <fasta> dcoutts: might not be worth it?
14:00:56 <fasta> dcoutts: it should be a language feature
14:01:23 <dcoutts> kaol: add more type annotations on sub-expressions
14:01:26 <fasta> All code that is a computable polynomial function should be
14:01:38 <sorear> fasta: I suspect you're doing something wrong, since otherwise you wouldn't have been finding so many ghc bugs. :)
14:01:56 <fasta> sorear: sure, blame the user.
14:01:57 <dcoutts> fasta: I'm not so sure, afterall there are several possible meanings, you might want to lift the function
14:04:08 <fasta> dcoutts: Int -> Bar  -> m Bool should be come: ((lift . ) .) <that function>
14:04:54 <dcoutts> fasta: I can't help but think there must be a better way of doing this, auto-lifting seems awfully ugly
14:05:22 <fasta> dcoutts: Int -> Bar -> Zork -> m Int should become  (((lift . ) .) . ) <the other function>
14:05:35 <fasta> dcoutts: I think I am just writing such generic code that nobody needed it earlier.
14:05:59 <dcoutts> fasta: it's not necessarily the only or ideal way to do generic stuff
14:06:18 <dcoutts> fasta: not that I have a better suggestion of course
14:06:37 <fasta> dcoutts: well, AFAIK, the idea of having code that can actually be reused is pretty nice.
14:06:44 <dcoutts> of course
14:06:49 <Lemmih> roconnor: I wonder why the Rope performs so much worse on the empty dna.
14:08:55 <kaol> oh. I changed something and it went away... I blame my incomplete mastery of do.
14:13:59 <nominolo> i tried having a Seq (Either (Seq Char) ByteString) but it had very many special cases
14:14:10 <dynamix> pjd: nope, finite simple continued frations to represent a ratio .
14:14:17 <dynamix> of two integers
14:14:26 <nominolo> anyone did some performance measurements for Seq ByteString?
14:16:42 <Lemmih> ?index fix
14:16:43 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
14:17:59 <wli> pjd: It's actually relatively simple.
14:20:51 <roconnor> Lemmih: all code I write is slow :)
14:21:12 <wli> > let { cf r = cf' (numerator r, denominator r) ; cf' (n, d) | d ==0 = [] | otherwise = let (q, r) = n `quotRem` d in q : cf' (d, r) } in cf (355/113)
14:21:14 <lambdabot>  [3,7,16]
14:21:33 <wli> > 3 + 1/(7 + 1/16) :: Rational
14:21:34 <lambdabot>  355%113
14:21:40 <wli> pjd: See?
14:21:51 <pjd> wli: yeah; the immediately preceding talk about parsing got me all awonder
14:23:38 <wli> fc [n] = fromIntegral n ; fc (n:ns) = fromIntegral n + 1/(fc ns) suffices though it's not the most efficient method by a longshot.
14:30:35 <wli> pjd: fc ns = let { hs = 0 : 1 : zipWith3 (\h' h'' m -> m*h' + h'') (tail hs) hs ns ; ks = 1 : 0 : zipWith3 (\k' k'' m -> m*k' + k'') (tail ks) ks ns } in (fromIntegral $ last hs)/(fromIntegral $ last ks)
14:30:59 <wli> > let { cf r = cf' (numerator r, denominator r) ; cf' (n, d) | d ==0 = [] | otherwise = let (q, r) = n `quotRem` d in q : cf' (d, r) ; fc ns = let { hs = 0 : 1 : zipWith3 (\h' h'' m -> m*h' + h'') (tail hs) hs ns ; ks = 1 : 0 : zipWith3 (\k' k'' m -> m*k' + k'') (tail ks) ks ns } in (fromIntegral $ last hs)/(fromIntegral $ last ks) } in fc $ cf (355/113) :: Rational
14:31:08 <lambdabot>  355%113
14:31:17 <wli> All integer arithmetic.
14:31:53 <dmwit> ?spell apropriate
14:32:05 <mm_freak> appropriate
14:32:27 <monochrom> Amazing, wli. :)
14:33:19 <wli> monochrom: More like amazing Khinchin (more or less typed out of his book, which I had at hand for the occasion).
14:33:36 <monochrom> heh
14:48:40 <wli> pjd: For more fun
14:48:47 <wli> > let gfc as@(a1:_) bs@(b0:b1:_) = let { ps = b0 : (b1*b0+a1) : zipWith4 rec (tail ps) ps as bs ; qs = 1 : b1 : zipWith4 rec (tail qs) qs as bs ; rec r' r'' a b = b*r' + a*r'' } in zipWith (/) ps qs in take 5 $ gfc (map (^2) [1,3..]) (3 : repeat 6) :: [Rational]
14:48:48 <lambdabot>  [3%1,19%6,60%19,177%56,4686%1483]
14:49:28 <pjd> yay for successive approximation!
14:53:56 <fasta> Oh, no, not again...
14:54:05 <fasta> m GHC.Prim.Any GHC.Prim.Any
14:54:32 <fasta> Maybe I should switch to language that can be implemented correctly...
14:54:37 <fasta> to a *
14:54:39 <chessguy> haha
14:54:42 <chessguy> HELP THANK YOU!!!!!
14:54:42 <chessguy> Sam
14:54:42 <chessguy> PS what is a monad
14:55:03 <Igloo> chessguy: ICFPC 2006?
14:55:09 <chessguy> indeed
14:55:21 <fasta> Igloo: saw ^^?
14:55:26 <Igloo> Yeah, I think that message is probably my favourite bit  :-)
14:56:21 <wli> The as and bs arguments of the zipWith4 both need to be replaced with drop 2 of their respective list variables.
14:56:26 <fasta> I would wish there was a formal proof that Any could never ever be in GHC output
14:56:32 <fasta> It drives me crazy
14:56:40 <Igloo> fasta: yes
14:57:14 <fasta> I can keep reporting bugs until I die, so it seems.
14:57:36 <Igloo> I think there's a language called stop that satisfies your criteria, but wikipedia doesn't seem to know about it
14:58:10 <monochrom> I know that BF can be implemented correctly. :)
14:58:29 <ari> Igloo: Let me guess... any Stop program immediately terminates without doing anything?
14:58:32 <fasta> monochrom: how do you know that?
14:58:55 <monochrom> It's a simple language from the implementor's point of view.
14:59:11 <fasta> monochrom: language implementors make mistakes.
14:59:26 <fasta> monochrom: I wouldn't be surprised to find bugs in the simplest of systems.
14:59:36 <fasta> That's why Coq is nice.
14:59:48 <fasta> It actually raises software quality
14:59:51 <Igloo> ari: Basically, yeah. There's only one instruction, STOP, which makes the program terminate. I think invalid programs are also treated as "STOP", and a warning emitted
14:59:55 <monochrom> Yes, but if the thing to be implemented is trivial to implement, a correct implementation is more within reach.
15:00:37 <monochrom> Hahaha, the challenge with stop is user-friendly warning messages. :)
15:04:04 <fasta> Do commercial C++ compilers have the same issues?
15:04:16 <wli> After futzing around, it appears the correct version is:
15:04:17 <wli> gfc (a1:as) (b0:b1:bs) = let { ps = b0 : (b1*b0+a1) : zipWith4 rec (tail ps) ps as bs ; qs = 1 : b1 : zipWith4 rec (tail qs) qs as bs ; rec r' r'' a b = b*r' + a*r'' } in zipWith (/) ps qs
15:05:24 <monochrom> They do.
15:05:46 <steven-ashley> Hello, could someone tell me the standard way of marshalling (ffi) to and from C structs? I could use an array but that may create byte packing problems. I am thinking the best approach is to write some simple set / get functions in C and interface to those.
15:06:31 <nominolo> c2hs?
15:06:34 <yaxu> ah, i found a parser for this stop language on my computer
15:06:35 <nominolo> @where c2hs
15:06:36 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/c2hs/
15:06:41 <SamB> stevan: there are actually tools that do this for you... one of which nominolo has probably just mentioned
15:06:41 <yaxu>  /bin/false
15:06:48 <Lemmih> steven-ashley: hsc2hs.
15:06:56 <SamB> er.
15:06:58 <SamB> steven-ashley:
15:07:07 <steven-ashley> :P cheers :)
15:07:11 <nominolo> Lemmih: is that different than c2hs?
15:07:19 <Lemmih> nominolo: Yes, very different.
15:07:19 <fasta> What are the trade-offs between those two tools?
15:07:40 <Lemmih> hsc2hs is very lightweight.
15:08:07 <fasta> lightweight means more work for the programmer?
15:08:08 <Lemmih> c2hs has a C parser and is stuffed with features.
15:08:20 <fasta> Right, that's how I understood it when I read the docs.
15:08:52 <Lemmih> Well, you usually don't need all the features c2hs provides.
15:09:03 <nominolo> steven-ashley: for example uses of c2hs, see gtk2hs
15:09:17 <Lemmih> If your binding is on the size of SDL, use hsc2hs. If you're binding gtk, use c2hs.
15:09:43 <_roconnor> Lemmih: I find it hard to read the output from -ddump-stg
15:10:08 <steven-ashley> I'm only wanting to bind 15 or so functions and 4-5 structs so I think hsc2hs will do. It seems simple enough.
15:10:28 <fasta> Igloo: Any is by definition a compiler bug, right?
15:11:27 <Lemmih> _roconnor: That is to be expected.
15:11:37 <Lemmih> _roconnor: You should see the cmm output (:
15:12:05 <Igloo> fasta: IIRC, yes
15:12:19 <fasta> Igloo: I almost got a test case.
15:12:26 <Lemmih> _roconnor: Reading the intermediate code requires skimming.
15:12:38 <fasta> How many cases are there with type inference?
15:12:42 <fasta> In total
15:12:56 <fasta> If it are millions, then probably it will never work
15:19:21 <_roconnor> Lemmih: I don't see this case statement stuff like you suggested.
15:20:36 <Lemmih> _roconnor: What case statement?
15:21:00 <hpaste>  blitznakBlowyou pasted "blitznakBlowyourload" at http://hpaste.org/1927
15:22:28 <fasta> Igloo: Hmm, it appears it does work in 6.6.1
15:22:38 <fasta> Igloo: so, it's only broken in 6.7
15:22:39 <roconnor> Lemmih: the slow case analysis you were claiming that the old monad code had in patternA.
15:23:00 <Lemmih> roconnor: Oh. What case do you see?
15:23:04 <fasta> Pretty amazing that so much stuff breaks in development builds
15:23:19 <fasta> One would expect that more things work in a newer version.
15:24:43 * wli cringes.
15:24:57 <hpaste>  roconnor pasted "first branch of case analysis in PatternA" at http://hpaste.org/1928
15:25:26 <Lemmih> roconnor: Urk, try -ddump-simpl
15:25:57 <ddarius> fasta: They do add stuff.
15:26:08 <fasta> ddarius: I know (lots of it)
15:26:27 <fasta> ddarius: but I wouldn't expect them to break the type inferencer everytime.
15:26:38 <fasta> But apparantly it are non-local changes.
15:26:44 <fasta> apparently
15:27:11 <roconnor> Lemmih: what am I looking for in --ddump-simpl?
15:27:33 <Lemmih> roconnor: patternA
15:28:38 <roconnor> oops, I was looking for PatternA
15:29:33 <hpaste>  roconnor annotated "first branch of case analysis in PatternA" with "simpler version" at http://hpaste.org/1928#a1
15:30:23 <Lemmih> roconnor: Is that without ErrorT?
15:30:38 <roconnor> it has errorT
15:30:56 <benomatic> where is the best source of all the builtin/standard (prelude?) functions available to ghc[i]?
15:31:07 <Lemmih> ?src Prelude
15:31:07 <lambdabot> Source not found. Wrong!  You cheating scum!
15:31:22 <roconnor> @source Prelude
15:31:22 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
15:31:28 <Lemmih> tsk tsk
15:31:30 <fasta> Igloo: http://hackage.haskell.org/trac/ghc/ticket/1564
15:31:30 <lambdabot> Title: #1564 (The fantastic Any type gets derived) - GHC - Trac
15:32:25 <roconnor> Lemmih: oh DMonad is the monad dictionary isn't it.
15:32:26 <benomatic> Lemmih: tnx
15:32:50 <roconnor> So all this code does is call   tpl1_a96t , which is the bind function.
15:33:07 <Lemmih> roconnor: Are you compiling with -O2?
15:33:28 <roconnor> yes
15:34:27 <roconnor> @src Monad
15:34:27 <lambdabot> class  Monad m  where
15:34:27 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
15:34:27 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
15:34:27 <lambdabot>     return      :: a -> m a
15:34:27 <lambdabot>     fail        :: String -> m a
15:35:44 <hpaste>  Lemmih annotated "first branch of case analysis in PatternA" with "Old monad case." at http://hpaste.org/1928#a2
15:35:50 <Lemmih> ^^ That is what I see.
15:35:52 <hpaste>  Hadi Susumu annotated "My hands are shaking and my feet are numb," with "My hands are shaking and my feet are numb," at http://hpaste.org/1741#a0
15:36:42 <chessguy> hmm
15:37:32 <hpaste>  wli pasted "numeric hierarchy headache" at http://hpaste.org/1929
15:39:12 <roconnor> Lemmih: no wonder your code is faster than mine.  You got inlining
15:39:36 <roconnor> Lemmih: do you have a different monad transformer library than me?
15:39:54 <roconnor> maybe mine isn't exposed for inlining.
15:40:44 <Lemmih> roconnor: I'm using ghc-6.6.
15:40:51 * roconnor feels left out
15:40:58 <SamB> roconnor: what are you using?
15:41:13 <roconnor> Glasgow Haskell Compiler, Version 6.6, for Haskell 98, compiled by GHC version 6.6
15:41:30 <SamB> where did you get the mtl?
15:41:43 <roconnor> from ubuntu
15:42:10 * Lemmih is on ubuntu as well.
15:42:12 <SamB> who is in the maintainer: field?
15:42:13 <roconnor> mtl-1.0
15:42:33 <Lemmih> roconnor: Maybe you're not looking in the right place.
15:42:37 <SamB> (at the dpkg level)
15:42:47 <roconnor> SamB: I don't know if my inlining isn't exposed.
15:43:05 <roconnor> I was just thinking of reasons why my code is different from Lemmih's
15:43:22 <SamB> roconnor: if we can eliminate different builds of the mtl then we don't need to worry about that anymore
15:43:31 <roconnor> Maintainer: Ubuntu MOTU Developers
15:44:43 <SamB> Lemmih: is yours the same?
15:44:47 <Lemmih> roconnor: I'd like to see the code that calls 'lvl18'.
15:44:53 <Lemmih> SamB: Yes.
15:46:24 <roconnor> Lemmih: are you on a 64 bit machine?
15:47:04 <hpaste>  roconnor annotated "first branch of case analysis in PatternA" with "caller of lvl18" at http://hpaste.org/1928#a3
15:47:12 <Lemmih> roconnor: Yes.
15:48:37 <roconnor> okay
15:48:43 <roconnor> still, this is strange
15:48:55 <SamB> Lemmih: maybe you should see if you get the same thing as roconner on catenova?
15:49:26 <Lemmih> SamB: I'm too lazy for that.
15:49:36 <SamB> there is that.
15:50:02 <SamB> (me too ;-)
15:51:34 * roconnor tries on another machine
15:53:07 <roconnor> I get the same thing as me on one of the university machines.
15:53:11 <roconnor> GHC Version 6.6.1
15:54:41 <roconnor> how do I browse a .hi file?
15:54:53 * Lemmih tries to avoid the Word8 box.
15:54:57 <SamB> --show-iface I think
15:57:15 <roconnor> I see nothing looking like a bind function when I
15:57:16 <roconnor> ghc --show-iface /usr/lib/mtl-1.0/ghc-6.6/Control/Monad/RWS.hi
15:58:12 * roconnor now wonders if ubuntu's MTL package is broken.
15:58:36 <roconnor> sabotage by ruby perhaps ;)
15:59:33 <Winterstream> Yeah, I'd worry about the Ruby folks. Though, you might some perls in all that small talk.
15:59:45 <Winterstream> ha ha ha. sorry. sorry. I couldn't help myself
15:59:54 <roconnor> :)
16:00:18 <roconnor> Lemmih: can you check your RWS.hi file?
16:00:27 <Cale> No news on the remaining SPJ talk? :)
16:01:19 <Lemmih> roconnor: I'm not sure what to look for.
16:02:04 <whaleofconfusion> can lexical scope be simulated in a language where every variable is dynamically scoped?
16:02:14 <roconnor> Lemmih: I would expect to see source code for bind (and other small functions)
16:02:41 <roconnor> Unless I'm mistaken, cross module inlining can only happen when the source code appears in the .hi file
16:03:18 <roconnor> when I browse DNA.hi, I see all sorts of case statements
16:03:37 <Lemmih> roconnor: What's the type of $wpatternA and patternA ?
16:04:05 <Igloo> roconnor: That's probably compiled without optimisation, so won't have any unfoldings in teh interface file
16:04:05 <Cale> whaleofconfusion: I don't think the translation is at all trivial.
16:04:19 <Winterstream> whaleofconfusion: I'm not sure whether closures can be handled with dynamic scoping. I could of course be entirely wrong. The answer doesn't seem straightforward to me.
16:04:38 <fasta> whaleofconfusion: of course it is possible
16:04:42 <roconnor> Igloo: what is compiled without optimisation?
16:04:46 <Cale> whaleofconfusion: Unless possibly you reserve a bunch of names which the user can't actually use, and distribute them through the code with a unique supply.
16:05:03 <littledan> whaleofconfusion: of course, you could *simulate* it in any turing-complete language
16:05:25 <roconnor> Pattern.$wpatternA :: GHC.Prim.Word#
16:05:25 <roconnor>                       -> Control.Monad.Error.ErrorT DNAMonad.DNAException
16:05:25 <roconnor>                                                     (Control.Monad.RWS.RWS () [RNA.RNA] DNA.DNA)
16:05:26 <roconnor>                                                     [Pattern.PItem]
16:05:32 <roconnor> ugh sorry
16:05:41 <Cale> Dynamic scope is a pretty terrible thing to have to worry about.
16:05:48 <Igloo> roconnor: mtl
16:05:53 <roconnor> Pattern.$wpatternA :: GHC.Prim.Word#
16:05:53 <roconnor> -> Control.Monad.Error.ErrorT DNAMonad.DNAException
16:05:53 <roconnor> (Control.Monad.RWS.RWS () [RNA.RNA] DNA.DNA) [Pattern.PItem]
16:06:08 <fasta> Any question starting with "Can I do X in <something to do with computers>?" where "Can I" means does the universe permit it is almost always yes.
16:06:15 <roconnor> Igloo: you are suggesting that ubuntu is distributing non optimized binaries for the MTL?
16:06:37 <Igloo> roconnor: Debian is, and I think ubuntu just takes the Debian packages
16:06:45 <roconnor> Pattern.patternA :: DNA.Base
16:06:45 <roconnor> -> Control.Monad.Error.ErrorT DNAMonad.DNAException
16:06:45 <roconnor> (Control.Monad.RWS.RWS () [RNA.RNA] DNA.DNA)[Pattern.PItem]
16:06:48 <Winterstream> whaleofconfusion: I interpret your question as follows - a language like Emacs LISP only has dynamic scoping, so can one have a thin veneer over it where you have lexical scoping? Truthfully, I don't know. Maybe you want to check out the Common Lisp in Emacs implementation...
16:06:49 <fasta> Cale: how much experience do you have with programming dynamically scoped systems?
16:07:07 <roconnor> Igloo: Debian is distrubuting non-optimized MTL packages?
16:07:09 <littledan> does anyone know if there's been an implementation of Tullsen's first class patterns?
16:07:10 <fasta> Cale: AFAIK, that's just the SICP Cool Aid, otherwise.
16:07:30 <roconnor> Igloo: why would they do that?  They want to sabotage Haskell programs?
16:08:12 <Cale> fasta: I did enough programming in perl to know what they were talking about :)
16:08:19 <dmead> theres alot of crap  in ubuntu/debian that isn't optimized
16:08:23 <dmead> haskell isn't speical
16:08:35 <roconnor> -O2
16:08:40 <roconnor> how hard is that?
16:08:42 <Igloo> roconnor: There's no easy way to enable optimisation with 6.6.1's Cabal
16:08:51 <Cale> With something that didn't have lexically scoped identifiers at all, I think I'd go completely insane :)
16:08:53 <dmead> hard, apparently
16:08:58 <fasta> Cale: ok, but in Emacs, it all looks to work quite well. Also, Factor seems to work quite good. That said, I like lexical scoping more.
16:09:00 <roconnor> WTF?
16:09:11 <dmead> the default installation for ubuntu still is supposed to work on old machines
16:09:14 <Igloo> 6.8's will have a flag for it
16:09:14 <Cale> Emacs is hanging on by a thread :)
16:09:15 <dmead> it's shitty
16:09:26 <fasta> Emacs needs a modern replacement
16:09:37 <dmead> eclipse is an attempt
16:09:49 <Winterstream> Man, Eclipse makes my laptop run like a dog
16:09:59 <dmead> have you got the new jvm?
16:10:01 <dmead> it's so much faster
16:10:10 <yaxu> Winterstream: that's what they used to say about emacs in its heyday
16:10:11 <Winterstream> Version 6?
16:10:13 <dmead> yea
16:10:23 <Lemmih> roconnor: Not boxing the Words lowers heap allocations to 93G.
16:10:26 <Cale> Does it really make sense to talk about scoping much in Factor?
16:10:31 <roconnor> This totally sucks!
16:10:35 <nominolo> Igloo: btw, i just published an updated version of cabal+configs
16:10:37 <dmead> in 1.5 i had terrible paging in eclipse
16:10:41 <dmead> in 1.6 it's very smooth
16:10:45 <Cale> Also, I think it has some simulation of lexical scoping too.
16:10:46 <roconnor> Lemmih: how do I unbox the words?
16:10:53 <Igloo> nominolo: Cool, where?
16:11:11 <Lemmih> roconnor: It's a bit tricky.
16:11:17 <nominolo> Igloo: http://code.haskell.org/~nominolo/src/cabal+configs/
16:11:18 <lambdabot> Title: Index of /~nominolo/src/cabal+configs
16:11:21 <dmead> Winterstream, make you sure tell eclipse to use the newest jvm
16:11:21 <Winterstream> dmead: I only used the beta of 1.6 with Eclipse and it crashed too often. I'll check out the release version...
16:11:24 <roconnor> does it involve putting #'s in my program?
16:11:28 <Igloo> nominolo: Do you think that's ready for the HEAD?
16:11:55 <nominolo> Igloo: hm, good question
16:11:56 <Lemmih> roconnor: You have to separate getting the head and getting the tail of the Rope.
16:11:58 <dmead> Winterstream, it's noticeably faster
16:12:02 <fasta> Omg, the Flash plugin made a sound out of nothing...
16:12:05 <dmead> by more than 2x
16:12:06 <Winterstream> I read about a pointer tag optimization for GHC. Is it going into the 6.8 release?
16:12:21 <Igloo> Winterstream: It's already in 6.7, so yes
16:12:30 <roconnor> Lemmih: so they don't pass through a pair?
16:12:31 <Lemmih> roconnor: Actually, inlining 'uncons' would probably do.
16:12:39 <Winterstream> dmead: Cool. Well, I actually hope I don't have to use Eclipse soon - by that I mean I hope I don't have to use Java soon :)
16:12:48 <nominolo> Igloo: i am not too happy with our testing infrastructure (if you can call it that)
16:12:50 <Winterstream> Igloo - whoohoo!
16:12:52 <dmead> :P
16:12:55 <roconnor> Lemmih: inlining uncons into head and tail?
16:13:04 <dmead> Winterstream, it even makes the CDT useable
16:13:07 <Igloo> nominolo: How so?
16:13:12 <dmead> since the cpu isn't killed when doing a compile
16:13:15 <Lemmih> roconnor: No, just add {-# INLINE uncons #-}
16:13:25 <roconnor> ok
16:13:29 <fasta> Igloo: why aren't all bugs fixed first in GHC before performance issues are being tackled?
16:13:41 <Winterstream> dmead: Okay, whoah, then itÅ› worth checking it out. CDT was just about unusable last time I used it. And I had very little C++ code.
16:13:59 <nominolo> Igloo: i think it's far from conclusive
16:14:26 <roconnor> So if we want fast code, then we shouldn't install any ubuntu packages?
16:14:33 <Lemmih> fasta: Welcome to open-source software (:
16:14:35 <nominolo> Igloo: and i couldn't really find out what the preferred way is to add new test cases
16:14:36 <roconnor> (or debian packages)
16:14:36 <dmead> if you want fast code you should run gentoo
16:14:41 <dmead> or slackware
16:14:44 <dmead> :>
16:14:52 <Igloo> nominolo: To Cabal's internal testsuite, or to the GHC testsuite?
16:15:03 <nominolo> Igloo: Cabal
16:15:04 * roconnor feels C++ has an unfair advantage
16:15:16 <roconnor> C++ gets it's libraries optimized does it?
16:15:16 <Igloo> nominolo: For the HEAD, I'm mainly worried about whether it will be possible to compile and install GHC with Cabal, though
16:15:36 <Igloo> nominolo: I don't understand Cabal's internal testsuite, so can't comment. AFAIK it doesn't get run by the nightly builders, though
16:16:00 <nominolo> Igloo: it should. Cabal.cabal now uses configurations itself
16:16:02 <roconnor> I spend all this time debuging my code, and it turns out to be the libraries fault!
16:16:14 <dmead> in c++?
16:16:27 <Igloo> nominolo: OK, I'll try integrating it into the HEAD and see what happens, then
16:16:43 <Winterstream> Does anyone here run Gentoo? I'm on Ubuntu and would like to know whether a Gentoo user would recommend switching.
16:16:57 <dmead> i do
16:16:59 <sorear> dcoutts: ping?
16:17:01 <nominolo> Igloo: i think i haven't yet included one of your one-line patches
16:17:10 <dmead> Winterstream, I had to use ubuntu at my job last spring
16:17:13 <dmead> it's so slow and shitty
16:17:17 <Igloo> Winterstream: Gentoo users would recommend switching and Ubuntu users would recommend sticking, of course  :-)
16:17:29 <dmead> I use gentoo at home
16:17:32 <sorear> Winterstream: iirc, dcoutts is the gentoo packager for haskell stuff
16:17:40 <dmead> hi sorear :P
16:17:48 <sorear> hello dmead
16:17:53 <Igloo> nominolo: I can fix that, it's the bit that confused me that is more of an issue  :-)
16:18:01 <dmead> yea Winterstream alot of the haskell devs update to gentoo first
16:18:11 <Winterstream> Hmm
16:18:16 <Winterstream> I should try Gentoo
16:18:21 <dmead> you should ;x
16:18:28 <Igloo> nominolo: Hmm, you have a conflict with the HEAD
16:18:48 <nominolo> Igloo: likely
16:18:48 <dmead> keep in mind it's source based and a big adjustment at first
16:18:50 <Winterstream> Getting hold of a distribution is just a bitch in South Africa. Bandwidth is insanely expensive over here. I'll just order a DVD from someone.
16:18:54 * sorear does not use Gentoo, and gets his GHC updates before *any* of the packagers.
16:18:55 <roconnor> If I install the MTL from Hackage, will it be optimized?
16:19:07 <sorear> roconnor: duh?
16:19:17 <dmead> Winterstream,
16:19:18 <Igloo> roconnor: Depends how you install it
16:19:23 <dmead> oh, how do you cope with apt-get etc
16:19:24 <roconnor> sorear: I don't know, it's not optimized in ubuntu
16:19:24 <dmead> ?
16:19:36 <fasta> dmead: are you trolling?
16:19:52 <dmead> huh?
16:19:54 <Winterstream> dmead: that sort of thing isn't so bad. It's when it gets to say, 1-2 gigs.
16:19:56 <roconnor> sorear: why should it be so much harder for them?
16:19:59 <dmead> Winterstream, ah
16:20:00 <dcoutts> roconnor: cabal's --enable-optimizations flag only appears in version 1.1.7
16:20:16 <roconnor> dcoutts: whoa!
16:20:22 <dcoutts> so many packages built with 1.1.6.x will not be built with optimisations
16:20:34 <Winterstream> It costs about $10/gig in South Africa. Which is pretty pricey.
16:20:44 <sorear> well, ghc 6.6 doesn't use any version of cabal.
16:20:45 <nominolo> Igloo: is it bad if i fix conflics locally and then record the changes?
16:20:55 <Winterstream> And that's for ADSL.
16:20:58 <dmead> Winterstream, maybe it'd be easier then, cause the source tarballs are much smaller than binaries
16:20:59 <sorear> nominolo: Not semantically.
16:21:16 <Igloo> nominolo: That can tickle darcs' exponential behaviour problems, so it's better to rerecord without conflicts
16:21:35 <roconnor> dcoutts: damn, that's pretty serious.
16:21:37 <Igloo> nominolo: If that's too painful then it's not the end of the world, though
16:21:43 <nominolo> Igloo: i forgot to make a pull before recording
16:21:49 <Winterstream> dmead: Yeah. I used to use FreeBSD and I liked Ports. It's just a bit slow to compile every time :/.
16:22:01 <nominolo> Igloo: no idea how to fix that now, though
16:22:12 <Igloo> nominolo: I didn't understand that
16:22:14 <Winterstream> What causes darcs' exponential behaviour?
16:22:15 <roconnor> dcoutts: what does this mean for me installing the MTL from hackage?
16:22:20 <sorear> dmead: Really?  you strip all the whitespace, variable names, etc...
16:22:31 <dcoutts> roconnor: depends on the version of Cabal you're using
16:22:36 <roconnor> dcoutts: sorear says duh?, but I don't know if that is duh yes or duh no.
16:22:37 <dmead> Winterstream, indeed
16:22:39 <dcoutts> Winterstream: Gentoo is much like that, portage was based on many ideas from bsd ports
16:22:41 <dmead> sorear, que?
16:22:49 <roconnor> dcoutts: how do I check that?
16:22:53 <Igloo> Winterstream: Certain patterns of conflicts
16:22:57 <dcoutts> roconnor: ghc-pkg list Cabal
16:23:12 <nominolo> Igloo: i recorded several local changes, then pulled, got conflicts, fixed them, recorded changes
16:23:19 <roconnor> Cabal-1.1.3, Cabal-1.1.6
16:23:24 <Winterstream> Igloo - I take it that it's purely an algorithmic issue and not related ot Haskell in any way?
16:23:38 <dmead> whats it mean when gcc segfaults?
16:23:44 <dmead> do i need a new computer?
16:23:45 <dmead> =/
16:23:46 <nominolo> Igloo: while the standard procedure is edit-pull-(fix-pull)*-record
16:23:47 <roconnor> Lemmih: btw, did you ever check your RWS.hi file?
16:23:47 <Winterstream> dmead: Bad Thing
16:23:48 <dcoutts> dmead: usually bad ram
16:23:49 <dmead> lol
16:23:49 <Winterstream> s
16:23:53 <dmead> frack
16:23:58 <Lemmih> roconnor: Yeah.
16:24:01 <Igloo> nominolo: OK, the best thing to do is to unrecord your conflict fixing patch, unrecord your conflicting patch, then record
16:24:12 <roconnor> Lemmih: and you have inlinable code in there?
16:24:15 <dmead> /var/tmp/portage/sys-devel/gcc-4.2.0/work/gcc-4.2.0/gcc/crtstuff.c:265: internal compiler error: Segmentation fault
16:24:17 <dmead> =/
16:24:19 <dmead> :<
16:24:21 <Lemmih> roconnor: Yeah.
16:24:29 <dmead> slash cry
16:24:32 <roconnor> :'(
16:24:39 <Lemmih> roconnor: >>= for RWS is marked as __inline_me.
16:24:41 <sorear> roconnor: Until they fix the performance problems in GHC itself, I'd rather libraries not be optimized.
16:24:41 <nominolo> Igloo: ok, i give it a shot
16:24:45 <roconnor> I guess 64 bit machines don't need to be so backwards compatable.
16:24:58 <sorear> roconnor: Having to wait two hours for a new GHC feature isn't fun.
16:25:23 <roconnor> sorear: at least we know why haskell code is so slow.
16:25:36 <roconnor> sorear: because people don't  want it optimized aparently.
16:25:50 <Lemmih> sorear: You only have to compile the libraries once.
16:26:33 <sorear> yeah, well I get new libraries 5-6 times a day
16:26:34 <SamB> Lemmih: you have to recompile the libraries too if something changes the .hi format
16:26:36 <Heffalump> surely this is just a question of different settings for development builds and release builds?
16:27:00 <roconnor> dcoutts: so without Cabal-1.1.7 I'm screwed?
16:27:22 <dcoutts> roconnor: or add ghc-options: -O to the .cabal file for the thing you're building
16:27:30 <Lemmih> SamB: Right, which is why you set the build.mk script to hacking mode instead of production mode.
16:27:34 <roconnor> :'(
16:28:10 <dcoutts> roconnor: or install Cabal-1.1.7, you can have many versions installed at once, you've already got 2
16:28:11 <SamB> Lemmih: tell that to sorear
16:28:33 <Lemmih> sorear: Which is why you set the build.mk script to hacking mode instead of production mode.
16:28:44 <sorear> Lemmih: Is this documented anywhere?
16:28:55 <roconnor> I can't believe I didn't know this before!
16:28:55 * roconnor wonders if this is on the wiki
16:29:04 <Lemmih> sorear: Yes, in the HACKING file.
16:29:37 <sorear> Huh, ISTR that just containing "read the commentary".
16:29:56 <roconnor> dcoutts, sounds like a solution.
16:30:10 <sorear> not in my HACKING file
16:30:12 <Igloo> You can also just add -O(2) to the ghc-options field in teh Cabal file
16:31:09 <roconnor> Igloo: is there some reason not to install Cabal-1.1.7?
16:31:19 <nominolo> wtf - now i have conflicts in 10+ files
16:31:43 <Igloo> roconnor: No particular reason
16:32:24 <Lemmih> Igloo: Do you know how expensive touch# is? Is it a no-op?
16:32:26 <roconnor> I can't believe all my libraries have been non optimized.
16:32:42 <SamB> Lemmih: what does it's being a no-op have to do with how expensive it is
16:32:44 <SamB> ?
16:33:12 <Lemmih> SamB: No-ops are cheap, aren't they?
16:33:22 <roconnor> Lemmih: inlining uncons has helped a bit.
16:33:31 <SamB> Lemmih: it depends how much optimization they prevent
16:33:51 <nominolo> Igloo: now i have conflicts in files i didn't even change
16:33:55 <Lemmih> SamB: I'm not interested in that.
16:33:56 <Igloo> Lemmih: noop, AFAIK
16:34:01 <roconnor> Lemmih: althought I have a feeling that recompiling the MTL to be optimized will help even more.
16:34:23 <Igloo> nominolo: Hmm, that sounds odd
16:34:29 <Lemmih> roconnor: Yeah, using optimized libraries would give a huge boost, I bet.
16:34:33 <SamB> roconnor: duh!
16:34:49 <SamB> if you don't build it optimized, you can't even inline any of it
16:34:58 <SamB> (into your code)
16:35:21 <roconnor> SamB: I didn't build the MTL, I just sudo aptitude installed it
16:35:33 <SamB> roconnor: you should report a bug
16:35:36 <roconnor> SamB: You'd think that'd be good enought, but no.
16:35:37 <Igloo> nominolo: No, I can't explain that. I suggest just abandoning this idea. It's unlikely to matter in this case anyway
16:36:05 <SamB> (however you report ubuntu packaging bugs)
16:36:23 <nominolo> Igloo: yeah, this is certainly weird.  maybe an artifact of unrecording and then respulling the same patches?
16:36:26 <roconnor> SamB: aparently it is a long story.... You may want to scroll back a bit, but the short of it seems to be that Cabal doesn't really support optimization until version 1.1.7.
16:36:35 <SamB> roconnor: oh.
16:36:51 <SamB> report it anyway though
16:36:58 <roconnor> ugh
16:37:00 <SamB> since Cabal supports it now, they can fix it now.
16:37:08 <Igloo> nominolo: Ah, you don't want to repull them
16:37:10 <SamB> (I hope)
16:37:19 <Igloo> nominolo: unrecord will leave the changes in the repo; you just record them again
16:37:37 <roconnor> SamB: I think I'll wait till they distribute Cabal 1.1.7 before I start complaining.
16:37:54 <SamB> roconnor: hmm.
16:38:04 <wli> Is there some preexisting sort of absolute value analogue that works for both real and complex numbers?
16:38:04 <nominolo> Igloo: well, do you have many conflicts?
16:38:25 <roconnor> I mean, if Cabal 1.1.7 isn't part of their distribution, I can't expect them to use it when building their binaries.
16:38:27 <Igloo> nominolo: It was only one small one I think
16:38:43 <roconnor> > abs (1 :+ 1)
16:38:45 <lambdabot>  1.4142135623730951 :+ 0.0
16:38:58 <nominolo> Igloo: btw, i'm not completely happy with how we use configurations to adapt to new base / old base issues
16:38:58 <wli> roconnor: useless because its result isn't an instance of Ord
16:39:12 <nominolo> Igloo: i think we rather want virtual packages
16:39:43 <roconnor> @hoogle Complex -> Real
16:39:44 <lambdabot> No matches, try a more general search
16:39:59 <SamB> roconnor: hmm, now that you mention it, it looks like my mtl is just as bad...
16:40:07 <roconnor> > realPart $ abs (1 :+ 1)
16:40:08 <lambdabot>  1.4142135623730951
16:40:15 <Igloo> nominolo: Will they be useful in the long run, though, or just to clean up the base mess?
16:40:23 <roconnor> SamB, what a performace boost to your DNA machine ;)
16:40:26 <wli> roconnor: Not defined for real arguments.
16:40:45 <roconnor> wli: oh crap
16:40:46 <nominolo> Igloo: i think, whenever packages are restructured, but keep the same interface
16:40:58 <SamB> Igloo: they'll be useful in the long run
16:41:06 <SamB> Igloo: you are a debian maintainer -- you should know this
16:41:07 <roconnor> wli: well, the numerical heirarchy has a number of issues ;)
16:41:08 <Igloo> wli: You could make a class to get the real part when it's complex
16:41:33 <wli> Igloo: That's what I did for the example I hpasted.
16:41:42 <nominolo> Igloo: the problem with configs is that in the long run every cabal file will reflect the whole history of package interface changes
16:42:13 <Igloo> SamB: Got any examples?
16:42:27 <SamB> Igloo: not yet
16:42:34 <SamB> we are discussing the future!
16:42:52 <nominolo> I thougt about that tomorrow!
16:42:56 <SamB> heh
16:43:28 <Igloo> nominolo: But you can't go back and make base 1.0 provide the virtual package process, for example
16:43:51 <SamB> Igloo: this is unfortunate :-(
16:43:52 <sorear> dons always tells people you should never use the MTL in performance code
16:44:12 <SamB> sorear: why does he say that?
16:44:16 <Igloo> nominolo: Making packages able to reexport modules of another package might help solve these sorts of problem, though
16:44:22 <nominolo> you can add a virtual package base-1.0 that is just base 2.0 + all the split-off stuff
16:44:29 <sorear> SamB: "Not enough inline pragmas"
16:44:32 <nominolo> Igloo: exactly
16:44:37 <sorear> leme search the logs...
16:44:47 <SamB> sorear: personally I think you should always force your compiler and library maintainers to make it optimize away to nothing
16:44:50 <roconnor> SamB: presumably bytestrings aren't opimized either.
16:44:53 <Igloo> nominolo: OK, you're using the word differently to me (Debian)
16:45:04 <SamB> roconnor: don't be so sure
16:45:28 <roconnor> SamB: why would bytestrings be different?
16:45:34 <SamB> roconnor: they are in base
16:45:37 <SamB> part of the core
16:45:40 <roconnor> ah
16:45:42 <nominolo> Igloo: ok, that might be.  but the point is to fix the issue at one place and not separately for each package
16:45:44 <roconnor> good point
16:46:01 <sorear> roconnor: try it and see; unoptimized bytestrings are about 1000x slower than unoptimized strings
16:46:05 <sorear> roconnor: (says ndm)
16:46:18 <sorear> roconnor: (in the context of making code faster on Hugs)
16:46:22 <SamB> Igloo: say, why does my MTL think it is for use with GHC 6.6.1 but still work with GHC 6.6?
16:46:22 <nominolo> Igloo: flags should be used for features not dependency resolution
16:46:42 <Igloo> nominolo: Have we decided I should just pull what's in the repo now, BTW?
16:47:02 <Igloo> SamB: I don't understand the question
16:47:08 <nominolo> Igloo: well, at least try and see if there are major conflicts
16:47:26 <SamB> oh.
16:47:28 <SamB> wait.
16:47:32 <SamB> I'm on the wrong machine
16:47:44 * SamB mentally splaps himself in the head
16:47:46 <nominolo> Igloo: but, yes, please pull.  it's gonna be hard to fix it on my side
16:47:51 <SamB> Igloo: nevermind
16:54:28 <nominolo> Igloo: the installPackage code should then just be:  let pd = localPkgDescr lbi
16:59:04 <Igloo> nominolo: Cool, ta
16:59:13 <cdsmith> There's lots of graduate students here, right?
17:01:30 <cdsmith> no?  Oh well, then.
17:01:58 <nominolo> cdsmith: try another time of day ;)
17:02:12 <nominolo> cdsmith: or even day of the week
17:02:24 <cdsmith> Yes, I'll do so.  Thanks
17:02:28 <Igloo> You're more likely to get an answer if you ask a real question, too  :-)
17:02:36 <cdsmith> I'm about to decide to delay graduate school in CS to get a masters in math.  Reasonable, or have I gone crazy?
17:02:39 <chessguy> i was just going to suggest that
17:02:55 <Igloo> Are you in the US?
17:02:56 <chessguy> cdsmith, what's your undergrad in
17:03:10 <cdsmith> Igloo: yes, in the US.  chessguy: CS
17:03:27 <nominolo> in the US graduate studies are unpaid, right?
17:03:48 <cdsmith> Err, it depends on whether you get an RA-ship position
17:04:17 <Korollary> cdsmith: Do you want to become an academic, or work in the industry when you get out?
17:04:18 <nominolo> i see.
17:04:42 <cdsmith> I definitely want to be an academic.  Real world is scary, and I'm sick of it after 10 years. :)
17:04:58 <nominolo> heh
17:05:05 <chessguy> @quote real
17:05:06 <lambdabot> xerox says: I am really interested specifically in bottoms in this very moment.
17:05:18 <chessguy> @quote world
17:05:18 <lambdabot> jmob| says: I want the world to stop at that point, go away, and give me it's argument..
17:05:38 <chessguy> you can learn a lot about the real world in #haskell :)
17:05:44 <wli> Academia sounds nice. Shame I'm not cut out for it.
17:05:45 <nominolo> @quote RL
17:05:45 <lambdabot> lambdabot says: <chessguy> sorry, this is the bird book: http://www.amazon.com/Introduction-Functional-Programming-2nd-Bird/dp/0134843460/sr=8-6/qid=1159309594/ref=pd_bbs_6/104-1423720-3100708?ie=
17:05:45 <lambdabot> UTF8&s=books  <lambdabot> http://tinyurl.com/root7
17:05:53 <Korollary> cdsmith: That is a hard question. Time is an issue. Masters in math then PhD in CS?
17:06:03 <cdsmith> chessguy: indeed; especially about encapsulating it in a monad
17:06:28 <cdsmith> Korollary: yeah, that'd be the plan.  I feel like I'm just missing understanding so much of what I'm reading now.
17:06:54 <Korollary> cdsmith: What are you reading?
17:07:09 <nominolo> cdsmith: but reading a book on CT might be more specific help
17:07:12 <cdsmith> Korollary: denotational semantics; proof theory; mathematical logic; type theory
17:07:26 <cdsmith> nominolo: CT?
17:07:27 <nominolo> chessguy: that's all CS!
17:07:33 <nominolo> category theory
17:07:37 <Korollary> cdsmith: Yeah those are pretty CS
17:07:57 <cdsmith> Yes, but I don't understand them.  I wonder if there's a way to be better prepared to understand.
17:07:57 <Korollary> cdsmith: You should be able to take undergrad math courses. I don't think you need a full blown math MS.
17:08:01 <Igloo> cdsmith: I can't speak for the US, but in Oxford you'd normally take some courses in your first year, which I'm sure could be maths courses
17:08:22 <Igloo> cdsmith: Some UG courses, that is
17:08:45 <Korollary> You can take anything as long as you meet the prerequisites
17:09:13 <nominolo> cdsmith: while a good course is probably better, there are good books on each of these topics
17:09:40 <nominolo> cdsmith: and you probably read up on specifics, not all math, don't you?
17:09:50 <nominolo> +want to
17:09:56 <cdsmith> I suppose.  I have until Monday 5pm to decide whether to enroll in a modern analysis course, which would be required to apply for the M.S. math; I don't want to decide wrong. :(
17:10:20 <|Steve|> "Fun" stuff.
17:10:23 <cdsmith> nominolo: I don't know.  I just wonder if maybe I need to develop new patterns of thinking.
17:10:43 <cdsmith> rather than just picking up specificis
17:10:52 <Korollary> cdsmith: Your PhD advisor can tell you if you need anything from the math dept
17:10:57 <nominolo> cdsmith: the topics you mentioned are really all part of CS.  the problem with math is that you'll have to take lots of stuff you don't want
17:11:16 <nominolo> cdsmith: of course, maybe that'll turn out to be interesting, too
17:11:50 <nominolo> cdsmith: but if you do it only for the aforementioned reason i'd suggest not doing a full Math MSc
17:11:54 <cdsmith> I'm babbling... but my fear is that I'd constantly remain on the verge; learning just enough to understand, but not enough to advance anything or do something new.
17:12:00 <Korollary> Damn this haskell community. They make topics like denotational semantics, type theory, etc. appear important. They're mean to be useless, you know.
17:12:34 <monochrom> Above all, Haskell was meant to be useless too. Now it's become useful. :)
17:12:42 <nominolo> cdsmith: i think that feeling won't go away soon
17:13:03 <nominolo> cdsmith: just try to pick some more practical research topic ;)
17:13:13 <cdsmith> practical?  Ick!
17:13:18 <nominolo> haskell = nirvana!!
17:13:21 <nominolo> soon!
17:13:30 <nominolo> simon says so
17:13:33 <Korollary> brainwashed by SPJ's video
17:13:37 <cdsmith> I believe him
17:13:55 <nominolo> no, we don't have lisp's macros yet
17:14:05 <nominolo> and the type systems are too limited
17:14:08 <nominolo> ;P
17:14:27 <Korollary> well, I know a PLT postdoc who's sick and tired of all this, too.
17:14:55 <nominolo> Korollary: of what? Scheme?
17:14:58 <Korollary> no
17:15:07 <chessguy> nominolo, actually, SPJ called haskell useless
17:15:15 <Korollary> I mean prog lang theory. Not the plt scheme folks.
17:15:32 <nominolo> chessguy: but the arrow pointed towards nirvana
17:15:41 <nominolo> chessguy: i'm thinking ahead
17:15:55 <chessguy> pf, what does SPJ know of arrows?
17:16:23 <nominolo> chessguy: you mean i better ask john?
17:16:32 <nominolo> but he's always so busy
17:16:33 <chessguy> john?
17:16:38 <Korollary> Travolta?
17:16:38 <nominolo> hughes
17:16:43 <cdsmith> Well, thanks for the comments.  Something to think about, at least.  Part of the problem is I have experience with such crappy colleges, I can't imagine finding one that would help me with anything like this. :(
17:16:46 <chessguy> ah
17:17:02 <chessguy> or eric :)
17:17:12 <Korollary> cdsmith: For type theory you have to go to the right university, too. Which one are you thinking? CMU? Penn?
17:17:19 <nominolo> cdsmith: read the lecture notes from Chalmers (plug!)
17:17:32 <cdsmith> I don't know.  I was actually thinking of applying to Chalmers
17:17:41 <Korollary> oh. Wow.
17:17:52 <nominolo> cdsmith: really?  well, i can recommend it
17:18:00 <nominolo> cdsmith: and i'm here
17:18:06 <cdsmith> But I'm not a really appealing student.  I have done no research; left college early ten years ago and screwed up my GPA
17:18:09 <Korollary> You'r obviously biased
17:18:20 <nominolo> nah
17:18:30 <sorear> type theory lets you say fun things like forall p1 p2, length p1 = length p2 -> reach_hanoi p1 p2
17:19:05 <chessguy> what's reach_hanoi?
17:19:05 <cdsmith> So I don't know if they'd want me
17:19:07 <Lemmih> roconnor: ping.
17:19:22 <Korollary> Can't you pretend that you've never heard of any of this and keep hacking happy java?
17:19:39 <cdsmith> Korollary: me?
17:19:56 <Korollary> cdsmith: Yes. Ignore me as I am virtually intoxicated.
17:20:00 <chessguy> @remember Korollary Can't you pretend that you've never heard of any of this and keep hacking happy java?
17:20:00 <lambdabot> Done.
17:20:06 <Nafai> kolmodin: I wish I could!
17:20:22 <cdsmith> Ah.  Yeah, Java holds no pleasures any longer.  Though I still use it at work
17:20:37 <chessguy> javascript is actually a pretty cool language
17:20:43 <cdsmith> But I'm changing that.  We switch to haskell at work soon. :)
17:20:44 <nominolo> cdsmith: well, you can't know until you try.  the dependable computer systems program actually dropped quite in numbers because all are now applieng to this stupid SE stuff
17:20:46 <chessguy> i've been playing with that a lot lately
17:20:54 <kolmodin> Nafai: me too. what?
17:21:07 <Nafai> Er
17:21:13 <Korollary> kolmodin: I think you got victimized by tab-completion
17:21:17 <Nafai> That was to Korollary
17:21:18 <Nafai> :)
17:21:25 * kolmodin find it amusing that every other person start their name with ko*
17:21:26 <kolmodin> :)
17:21:31 <kolmodin> Nafai: np, it's not the first time :)
17:21:38 <Korollary> Ko* is the koolest prefix evah
17:21:38 <chessguy> kokoala_man kolmodin Korollary kosmikus
17:21:39 <nominolo> kolmodin: but you can chime in and praise chalmers, too ;)
17:22:10 <Lemmih> roconnor: Writing a specialized version of 'viewl' gives a big speed boost.
17:23:05 <Korollary> cdsmith: 4-5 years in a foreign country is a big move. You don't want to rush it. You may consider emailing profs at Chalmers and elsewhere. They're usually helpful to total strangers.
17:23:48 <sorear> kolmodin is blessed with a Ko in his *real* name!
17:24:01 <Korollary> sorear: I have a Ko in my real name, too.
17:24:27 <nominolo> what's so great about a Ko in one's real name?
17:24:27 <Lemmih> roconnor: It's almost comparable to Seq. 1m17 vs. 55s.
17:24:43 <cdsmith> Korollary: Yeah.  I'm caught up in this catch-22.  I feel like I should know what I am going to do before talking to graduate departments; and I don't yet.
17:24:51 <Lemmih> roconnor: 33mb vs. 590mb.
17:24:54 <Korollary> nominolo: It regulates cholesterol levels.
17:25:19 <Korollary> I mean kolesterol I suppose
17:25:24 <kolmodin> yes! I'm quite pleased
17:25:46 <nominolo> ok
17:26:12 <nominolo> not koffein?
17:26:17 <Korollary> cdsmith: I assume that you are not married? no kids?
17:26:21 <kolmodin> not during night
17:26:31 <cdsmith> Korollary: right.  I have a dog, but she'll adjust :)
17:27:57 <Korollary> cdsmith: Well, have you considered another job if you're sick of your current one?
17:28:28 <Korollary> An enormous number of people are not aware how much they hate their jobs until they're laid off and find a better one.
17:28:51 <cdsmith> Korollary: Oh no, I love my job, as real jobs go!  I don't think I'll find one that lets me play with type systems.
17:29:26 <cdsmith> In fact, one of the advantages of the M.S. math is I'd do it in town, so I could keep my job, house, and dog. :)
17:30:32 <cdsmith> My employer has even agreed to hire another Haskell developer and rewrite our product in Haskell.
17:30:42 <Korollary> cdsmith: What did you slip in his drink?
17:30:59 <cdsmith> My boss?
17:31:22 <Korollary> I sense foul play
17:31:38 <nominolo> the new highly addictive stuff called SPJ
17:31:55 <Lemmih> cdsmith: Where do you work?
17:32:03 <cdsmith> Nah, just a good year of arguing.  I've been arguing for rewriting the project for a long time.  Haskell makes it fewer lines of code.
17:32:15 * nominolo should better go to bed
17:32:16 <cdsmith> Lammih: small company, called MindIQ.  www.mindiq.com
17:32:23 <cdsmith> *Lemmih: ^^
17:32:50 <cdsmith> nominolo: g'night
17:33:03 <Korollary> cdsmith: What exactly constitutes "playing" with type systems? Do you want to design new ones?
17:33:08 <nominolo> n8
17:33:51 <cdsmith> Korollary: I don't know entirely.  I am very interested in (a) proving properties of software, and (b) automatic transformations of the structure of software applications.  So type theory rather fits in.
17:34:11 <Korollary> cdsmith: Maybe Galois are hiring?
17:36:01 <cdsmith> Maybe.  But if I just wanted a Haskell job, I'd probably be best off just keeping the one I've got.  Galois would have the advantage of working with many smart people, I guess... but I like the idea of the academic environment.
17:36:31 <cdsmith> I will probably do academic stuff anyway; it's just a question of the specifics.
17:36:50 <jfredett> Hm, I'm trying to declare a type synonym for a list of objects which have equality, eg
17:36:50 <jfredett> type (Eq a) => Alphabet a = [a]
17:36:50 <jfredett> but it won't compile, I think I need to use newtype, but I'm not sure. Anyone car to help?
17:36:54 <jfredett> s/car/care/
17:37:07 <Korollary> I mentioned Galois because I believe they (claim to) write high reliability software and are into proving programs, etc.
17:38:42 <cdsmith> Korollary: Hmm.  Thanks, but I will probably still pass up switching jobs.  It creates too much of a combinatorial explosion in the search space for options.
17:39:12 <Korollary> jfredett: you mean type Alphabet = ..
17:39:16 <Cale> jfredett: Try turning on -fglasgow-exts and seeing if that works. If not, I bet it's impossible.
17:39:34 <wli> I don't really believe in "Haskell jobs." Maybe you're doing a job, and Haskell is the right language for it.
17:39:45 <Cale> type Alphabet a = (Eq a) => [a]... maybe
17:39:54 <jfredett> right, Korollary- but I want to force the objects contained in alphabet to have equality,
17:39:56 <Cale> That seems the wrong way around to me.
17:40:00 <jfredett> hmm, worth a shot, Cale
17:40:16 <Cale> jfredett: But you certainly can't do it in H98
17:40:20 <wli> I think you need a newtype at least.
17:40:45 <Korollary> jfredett: if you want equality of lists without equality of members, then you need extensions.
17:40:46 <Cale> Nah, he just wants a type synonym which when expanded adds an Eq constraint to the parameter it's applied to.
17:41:01 <jfredett> no- I want equality of members
17:41:17 <jfredett> i dont care about equality of lists
17:41:22 <Korollary> ah I get it
17:41:29 <wli> I'm pretty sure you're stuck with a newtype.
17:41:34 <jfredett> right
17:41:38 <jfredett> so how do i do that?
17:41:53 <jfredett> newtype Eq a => Alphabet a = [a]  isn't working
17:42:06 <Cale> jfredett: How does that not work?
17:42:15 <cdsmith> Korollary (and others): thanks so much for the thoughts and suggestions.
17:42:17 <Cale> er, oh
17:42:20 <jfredett> "Parse error in data/newtype declaration
17:42:22 <jfredett> "
17:42:23 <Cale> you forgot the newtype constructor
17:42:31 <Cale> newtype Eq a => Alphabet a = Alph [a]  isn't working
17:42:32 <Cale> er.
17:42:35 <wli> HaGLR needs a LOT of work.
17:42:35 <Cale> newtype Eq a => Alphabet a = Alph [a]
17:42:37 <Cale> heh
17:42:39 <jfredett> ooh, I get it
17:42:41 <jfredett> okay
17:42:55 <jfredett> then why don't i just use data?
17:43:10 <jfredett> oh- nevermind
17:43:17 <wli> You can. I almost never bother with newtypes myself.
17:43:22 <dolio> Because newtype has no runtime overhead.
17:43:31 <jfredett> I could pattern match against Alph to get the list out?
17:43:55 <wli> The only time I care about newtypes is hiding huge stacks of monad transformers in an ADT while getting type derivations on the various monad instances.
17:43:57 <jfredett> f :: Alphabet -> [a]  would be f (Alph ls) = ls ?
17:45:14 <wli> In that case I can't be arsed about runtime overhead; it's the programming overhead of the monad instances I'm on about.
17:46:17 <wli> Has anyone ever even looked at HaGLR?
17:46:50 <wli> There are some rather glaring lacunae.
17:50:15 <dibblego> newtype is a compiler hint; that aside, data can do everything that newtype can do
17:50:52 <wli> There are extensions to do deriving of things data can't derive AIUI.
17:51:42 <chessguy> @where haglr
17:51:43 <lambdabot> I know nothing about haglr.
17:51:51 <chessguy> @go haskell HaGLR
17:51:55 <lambdabot> http://twiki.di.uminho.pt/twiki/bin/view/Personal/Joao/WebHome
17:51:57 <dibblego> haglr n. one who hagles
17:52:35 <chessguy> @where+ haglr http://wiki.di.uminho.pt/twiki/bin/view/Research/PURe/HaGLR
17:52:35 <lambdabot> Done.
17:52:46 * chessguy rolls his eyes at dibblego's attempt at humor
17:53:14 <dibblego> I'm dead serious!
18:01:39 <dynamix> cant put a where in a lambda can we?
18:04:27 <dynamix> grr.. then how do i return a parmetric function that depends on other functions ?
18:04:38 <dmead> can you be more specific?
18:04:54 <dmead> ?paste
18:04:54 <lambdabot> Haskell pastebin: http://hpaste.org/new
18:04:59 <dynamix> oops sorry.  ok  another attempt
18:05:55 <chessguy> so you want to return something like map?
18:06:40 <hpaste>  dynamix pasted "(no title)" at http://hpaste.org/1930
18:06:50 <dynamix> http://hpaste.org/1930
18:06:57 <dynamix> oh its already here.. :)
18:07:50 <chessguy> dynamix, what's a?
18:08:17 <dynamix> its another function that returns a list . a k1 k2 returns a list
18:08:21 <chessguy> other than that, this looks fine
18:08:22 <dynamix> one sec
18:08:36 <dolio> You'll have to give it a name, or use '\t -> let ... in (x, y)'
18:08:54 <hpaste>  dynamix pasted "solve needs some help" at http://hpaste.org/1931
18:08:55 <dolio> Where the '...' is the stuff in your where clause.
18:09:04 <chessguy> dolio, really? why?
18:09:17 <dolio> chessguy: Because x and y depend on t.
18:09:30 <chessguy> yes...
18:09:37 <chessguy> so?
18:09:51 <dolio> Oh, actually, you could make t a parameter to solve... no?
18:10:10 <dolio> > (\t -> s where s = t)
18:10:10 <lambdabot>  Parse error
18:10:30 <dynamix> no solve k1 k2 k3 returns a tuple where each element of the tuple is a function of t
18:11:02 <chessguy> dynamix, well, right now, solve returns a function
18:11:14 <chessguy> and that function returns a tuple
18:11:15 <dynamix> yeah its wrong as it is now.
18:11:52 <dynamix> and i cant make it work with out a very ugly line that i dont like
18:11:53 <chessguy> oh, you don't want to return a function?
18:12:19 <dolio> Well, then you'd change x and y to take parameters themselves, I suppose.
18:12:40 <dynamix> let me show the working code too. that will give a better idea
18:12:40 <dibblego> dynamix, do realise that a -> b -> c returns a function of type b -> c when a is applied
18:12:53 <dibblego> dynamix, that is, a -> b -> c isequivalent to a -> (b -> c)
18:13:15 <dynamix> yeah, thats the version that works
18:13:58 <dolio> Incidentally, when you're pasting stuff related to something you've already pasted, you should use the 'annotate' link instead of 'new'.
18:14:05 <dynamix> but i want each element to be a function. this is more obvious  to me
18:16:42 <dynamix> im trying to make a temporary function for x and one for y and use them instead.
18:17:21 <dynamix> but the intuitive and clean way ( for me ) is to use a where in the lambda funcitons.
18:17:40 <dynamix> and im still a very early beginner. so figured there would be a way
18:18:19 <hpaste>  dolio annotated "solve needs some help" with "perhaps this?" at http://hpaste.org/1931#a1
18:19:18 <chessguy> nice one
18:21:14 <chessguy> @type liftM
18:21:16 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
18:21:32 <chessguy> @src liftM
18:21:32 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
18:21:34 <hpaste>  Saizan annotated "solve needs some help" with "or just this" at http://hpaste.org/1931#a2
18:22:35 <chessguy> hm, that seems less intuitive to me, Saizan
18:23:05 <chessguy> YMMV, i suppose
18:23:07 <dolio> Well, that's actually a different solution.
18:23:14 <dolio> Saizan's is the same as the original.
18:23:27 <dolio> But he said he wanted a tuple of functions, which the original didn't do anyway.
18:23:43 <Saizan> ah yeah, i didn't follow the discussion, just made the original work :)
18:24:28 <dynamix> dolio:  still some error
18:25:11 <dolio> dynamix: Can you paste an example of code that makes use of solve?
18:25:12 <hpaste>  dynamix annotated "solve needs some help" with "ghci 6.6.1 errors" at http://hpaste.org/1931#a3
18:25:58 <dynamix> i just did. im a bit slow with kbs adn mice [ RSI :( ]
18:26:00 <dolio> Oh, well, that's partially because of precedence errors, at least.
18:26:11 <dolio> dynamix: Try 'solve 100 (-63) (-90)'
18:26:37 <dolio> dynamix: What you wrote parses as '(solve 100) - 63 - 90'
18:26:53 <dolio> Due to the evils of - in Haskell. :)
18:27:29 <kpreid> perhaps "foo -bar", i.e. - with whitespace only on the left, should provoke a warning
18:27:34 <Saizan> unary minus is just useless as it is
18:28:03 <dynamix> uh. this bit me earlier too :(
18:29:26 <dmwit> Is there a way to have module Common export all of its stuff plus all of, say, Control.Monad without manually specifying everything in C.M?
18:29:57 <Saizan> yes, putting module Control.Monad in the export list
18:30:13 <dmwit> ...that's easy.
18:30:42 <chessguy> there's a quote that would go well in the topic
18:30:56 <chessguy> "The Haskell programming language: ....that's easy."
18:31:41 <Saizan> heh :D
18:32:05 <chessguy> @seen dons
18:32:05 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 16h 22m 52s ago.
18:32:15 <dmwit> On the other hand, it doesn't seem to work.
18:32:26 <dmwit> Maybe it's some other form, like Control.Monad (*) or something?
18:32:32 <Saizan> you've to import it as well
18:33:10 <dmwit> Well obviously.
18:33:13 <Saizan> @source Control.Monad.State
18:33:13 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/State.hs
18:33:29 <chessguy> there ya go, just copy-and-paste!
18:33:33 <Pupeno> Hi.
18:33:39 <Pupeno> How does "return" know what type of monad to build?
18:33:43 <dmwit> ah, module
18:33:50 <kpreid> Pupeno: type inference
18:33:55 <dolio> Magic.
18:34:17 <chessguy> Pupeno, the easiest way is to tell it what type the current function is.
18:34:41 <Pupeno> ok...
18:35:41 <chessguy> e.g., if i have foo :: Int -> Char -> State String (), then return is going to be of type State String ()
18:35:51 <chessguy> when used inside of foo
18:35:59 <dolio> Pupeno: For instance, if you have 'return a >>= print', then it has to pick IO, because print only works on IO.
18:36:48 <dolio> In most cases, there's something somewhere in your program that eventually restricts things like that.
18:38:58 <Pupeno> Thank you.
18:41:12 <dibblego> ?type (>>=)
18:41:14 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
18:45:43 <chessguy> @type liftM2
18:45:45 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
18:45:59 <chessguy> @type liftM
18:46:00 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
18:46:16 * chessguy begins to see a pattern
18:46:40 <chessguy> @type liftM3
18:46:42 <lambdabot> forall a1 a2 a3 r (m :: * -> *). (Monad m) => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
18:47:03 <chessguy> @src liftM2
18:47:03 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
18:47:14 <chessguy> @src liftM3
18:47:15 <lambdabot> liftM3 f m1 m2 m3 = do { x1 <- m1; x2 <- m2; x3 <- m3; return (f x1 x2 x3) }
18:47:22 <mauke> :t \f w x y z -> return f `ap` w `ap` x `ap` y `ap` z
18:47:24 <lambdabot> forall a a1 a2 a3 b (m :: * -> *). (Monad m) => (a -> a1 -> a2 -> a3 -> b) -> m a -> m a1 -> m a2 -> m a3 -> m b
18:47:55 <chessguy> oh, so here's a question i thought of the other day
18:48:12 <chessguy> when designing a language, there are a lot of decisions to be made
18:48:16 <|Steve|> @pl  \f w x y z -> return f `ap` w `ap` x `ap` y `ap` z
18:48:17 <lambdabot> ((((ap .) . ap) .) .) . liftM2
18:48:44 <chessguy> lazy vs. strict, functional vs. imperative, strong vs. weak, etc., etc.
18:49:00 <mauke> awesome vs. lame
18:49:12 <dynamix> intuitive vs non intuitive?
18:49:22 <chessguy> why not just define syntax for all the different possibilities?
18:49:41 <mauke> are you talking about Perl 6?
18:49:45 <|Steve|> Because kitchen-sink languages don't do very well.
18:49:56 <chessguy> why not?
18:50:13 <|Steve|> Sort of the jack-of-all-trades, master of none situation.
18:50:22 <steven-ashley> Too hard to learn also
18:51:08 <chessguy> steven-ashley, how so? just learn whatever set of syntax you prefer, and ignore the rest until you want it
18:51:33 <mauke> it works as long as you don't want to read code
18:51:39 <steven-ashley> how does that help you if you are maintaining other peoples code?
18:52:04 <chessguy> well, ok, that's a good point steven-ashley
18:52:10 <chessguy> mauke, what do you mean?
18:52:37 <mauke> when reading code you can't just ignore the parts you don't understand
18:52:57 <chessguy> yeah
18:54:37 * glguy wonders which syntax is being discussed
18:54:48 <chessguy> glguy, universal syntax :)
18:55:06 <steven-ashley> purely theoretical ...
18:55:28 <chessguy> but theoretically possible
18:56:19 <SamB> so why are we discussing perl again?
18:56:57 * chessguy kicks SamB....go fix endo, already, you slacker
18:57:09 <SamB> chessguy: I'm working on it
18:57:14 <chessguy> so i hear
18:57:22 <steven-ashley> hmm...
18:57:52 <SamB> what makes you think that just because I'm talking about unrelated things that means I'm slacking?
18:57:56 <SamB> I just don't know what to do next
18:58:18 <chessguy> yeah like i haven't hear that story a hundred times
18:58:55 <steven-ashley> chessguy: you didn't enter?
18:59:04 <chessguy> nah
18:59:21 <steven-ashley> chessguy: slacker
18:59:23 <steven-ashley> :P
18:59:25 <SamB> chessguy: plus we still have to figure out where to get a Mr. Fusion to revive Arrow
19:03:28 <SamB> chessguy: at least I typed up the symbol table
19:03:37 <SamB> I've now even *pushed* it
19:07:00 <SamB> chessguy: I've now also pushed a program to turn endo into an mlephant
19:07:14 <chessguy> mlephant?
19:07:59 <SamB> chessguy: well... make biomorph.png if you want to see it
19:09:11 * chessguy fires it up
19:09:35 <sorear> MLephant.. heh
19:10:37 * chessguy taps his fingers
19:11:40 <SamB> do you think the fact that we have to get rid of the lambdas may be some kind of a subtle joke to the effect of "functional programmers can't make it in this world"?
19:11:50 * chessguy taps some more
19:12:59 <chessguy> heh
19:13:12 <chessguy> it really is an MLephant
19:13:46 <SamB> chessguy: you were expecting an o'caml with a sign around it's neck saying "MLephant"?
19:13:55 <chessguy> haha
19:14:19 <SamB> if you comment out the part where it sets ocamlrules to false, you can see the ocaml
19:14:59 <SamB> eventually I'll have to integrate my symbol table with my assembler (now misnamed as Compiler)...
19:15:29 <rehges> you should get rid of \x.x , which makes perfect sense, since you want a transform, not the identity.
19:16:34 <SamB> yes but why should endo say mu instead of lambda?
19:16:47 <SamB> oh wait I just got ti
19:16:48 <rehges> because that's what cows say, sheesh
19:16:59 * SamB groans at the pun
19:17:12 <rehges> yeah it's dutch humour i suppose :-)
19:17:18 <wli> Type-level recursion and cows.
19:17:22 <chessguy> hm, i thought mu was pronounced with a 'y' in it
19:17:43 <rehges> it's pronounced moo in english
19:17:43 <SamB> chessguy: we are CS geeks, not classics majors
19:19:00 <SamB> rehges: it's not particularly dutch as I see it
19:19:54 <rehges> samb: oh it is, all the jokes taken together definitely is
19:20:02 <SamB> possibly
19:20:06 <dolio> Some people pronounce it 'myoo'.
19:20:11 <dolio> I probably would, myself.
19:20:31 <wli> I think classics majors would not but am not entirely sure.
19:20:32 <SamB> I might actually do that too...
19:20:49 <SamB> but if you write it out like that, it becomes clear
19:21:02 <SamB> meh
19:21:13 <SamB> maybe dutch cows go myooo
19:21:23 <rehges> dutch cows go boooeeeee
19:21:28 <SamB> really?
19:21:31 <rehges> yes
19:21:37 <SamB> why?
19:21:45 <rehges> i dunno
19:21:45 <SamB> are they always out at sea?
19:21:54 <rehges> no, those are the sheep
19:22:13 <SamB> well, then what do they want with a buey?
19:22:15 <wli> Is there anything special to do wrt. binary IO, endianness, etc.?
19:22:37 <SamB> wli: what?
19:22:59 <rehges> samb: a cow goes "boe", a buoy is "boei".  subtle difference :-)
19:23:18 <SamB> now what I want to know is what happened to the rest of the flying saucer in target.png
19:23:28 <wli> SamB: Pure ignorance. hGetBuf/hPutBuf
19:23:45 <wli> SamB: openBinaryFile/hSetBinaryMode/etc.
19:23:51 <rehges> samb: the saucer is transformed into a less conspicuous vehicle
19:23:55 <SamB> wli: was there some context?
19:23:56 <rehges> by the VMU
19:24:21 <wli> SamB: No, I was only trying to find the right API's.
19:24:28 <SamB> rehges: it seems to have been transformed into a whale pool, to my untrained eyes
19:24:39 <rehges> it is transformed into a caravan
19:24:53 <rehges> there's a manual page about it, even
19:24:57 <SamB> yeah.
19:25:06 <wli> Actually hGetBuf/hPutBuf seem to involve Ptr's where I'd rather have some other abstraction. Maybe ByteStrings or PackedStrings are it.
19:25:17 <SamB> it looks kind of imposing though
19:27:44 <wli> The only thing concerning me is implicit conversions for things like unicode, \CR\LF, etc.
19:29:22 <SamB> wli: the CR/LF issue is the only one likely to come up if you don't use JHC
19:29:48 <jsnx> how do i use liftM & ap ?
19:30:16 <chessguy> jsnx:
19:30:18 <chessguy> @type liftM
19:30:20 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
19:30:20 <chessguy> @type ap
19:30:22 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
19:30:24 * SamB wonders if nobody can remember how to use ap
19:30:25 <|Steve|> @src ap
19:30:25 <lambdabot> ap = liftM2 id
19:30:36 <jsnx> chessguy: lolz
19:30:45 <jsnx> chessguy: thanks for nothing
19:30:54 <|Steve|> maybe if I knew what ap stood for, it'd make more sense.
19:30:58 <chessguy> jsnx, well, try asking a real question
19:30:59 <Saizan> liftM f `ap` m1 `ap` m2 `ap` ...
19:31:17 <jsnx> does 'ap' stand for 'apply' ?
19:31:31 <Saizan> i think so
19:31:36 <jsnx> chessguy: okay, i will as my question differently
19:31:40 <SamB> jsnx: what do you think, looking at it's type signature?
19:33:04 <jsnx> SamB: it takes a monad of a function and a monad of an argument and makes a monad of the result
19:33:25 <wli> Ooh, igloo did the deflate bits.
19:33:44 <jsnx> does that mean i can do   num <- ap $ sin x   ?
19:34:44 <SamB_XP_> no...
19:34:49 <kpreid> no, but you can do num <- ap (return sin) (return x)
19:34:56 <mauke> > ap (,) sin 2
19:34:57 <lambdabot>  (2.0,0.9092974268256817)
19:35:04 <sorear> wli: Just use Data.ByteString, it guarantees to provide a bytenary abstraction
19:35:42 <jsnx> mauke: can you explain the comma?
19:35:53 <mauke> > (,) "foo" "bar"
19:35:54 <lambdabot>  ("foo","bar")
19:36:02 <mauke> it's a function that makes tuples
19:36:23 <jsnx> that makes a lot of sense, actually...
19:36:27 <jsnx> mauke: thanks
19:36:29 <|Steve|> ap f g x seems to be just doing f x (g x), but I could be wrong.
19:36:38 <glguy> > runReader ( asks (,) `ap` asks sin ) 2
19:36:39 <lambdabot>  (2.0,0.9092974268256817)
19:36:58 <SamB_XP_> jsnx: mauke's example "ap (,) sin 2" is probably something you should just forget; -)
19:37:08 <mauke> |Steve|: do you know the S combinator?
19:37:08 <dons> ?users
19:37:08 <lambdabot> Maximum users seen in #haskell: 350, currently: 322 (92.0%), active: 14 (4.3%)
19:37:14 <jsnx> SamB_XP_: why is that?
19:37:22 <SamB_XP_> he's abusing the (env ->) monad
19:37:23 <|Steve|> mauke: Nope, only Y and Z.
19:37:43 <mauke> well, ap is S
19:37:49 <sorear> hello dons
19:37:53 <|Steve|> And there's the one that uses every letter of the alphabet.
19:38:09 <SamB_XP_> what is Z?
19:38:24 <|Steve|> It's the applicative order Y.
19:38:38 <SamB_XP_> oh, you mean it's flip Y?
19:39:08 <|Steve|> http://www.dreamsongs.com/NewFiles/WhyOfY.pdf
19:39:08 <hpaste>  jsnx pasted "(no title)" at http://hpaste.org/1932
19:39:10 <|Steve|> No.
19:39:23 <|Steve|> The combinator described in that link is the Z combinator, iirc.
19:39:27 <jsnx> here's what i'm trying to make work
19:39:53 <mauke> jsnx: whoa
19:39:59 <jsnx> mauke: ?
19:40:13 <mauke> what's wrong with 'let nums = map read args'?
19:40:28 <jsnx> mauke: well, nothing
19:40:28 <hpaste>  Saizan annotated "(no title)" with "don't overcomplicate things" at http://hpaste.org/1932#a1
19:40:32 * wli looks at hackage and notes he could probably hammer out a fair amount of special function code.
19:40:43 <jsnx> mauke: except i didn't know it would work
19:41:04 <glguy> jsnx: if you wanted to make things complicated: nums <- return $ map read args   would have worked too
19:41:48 <jsnx> glguy: okay, but is there a way using ap ?
19:41:53 <Saizan> nums <- ap (return $ map read) (return args) also
19:42:04 <jsnx> Saizan: aha
19:42:11 <mauke> nums <- ap (return $ map read) getArgs
19:42:15 <wli> The only trick really is that the numeric hierarch is so screwed up that if it's not reworked in the standard libs before the thing acquires any weight there's trouble.
19:42:21 <mauke> ap (return ...) is liftM
19:42:38 <jsnx> mauke: so how would that look?
19:43:02 <Saizan> map read `liftM` getArgs
19:43:13 <jsnx> Saizan: oh, nifty
19:44:14 <jsnx> Saizan: that is the same as   liftM (map read) getArgs   right?
19:44:20 * wli tries to remember where the GSL bindings are.
19:44:45 <Saizan> jsnx: yes
19:45:44 <jsnx> thank you for your patience everyone -- i hope i won't be n00b for ever...
19:46:13 <chessguy> @instances-importing Monad
19:46:14 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
19:47:01 <chessguy> hmm, how does ap (,) sin 2 work?
19:47:10 <chessguy> what's the monad?
19:47:14 <chessguy> @type ap
19:47:16 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
19:47:24 <mauke> chessguy: ((->) r)
19:48:02 <chessguy> @type sin
19:48:03 <lambdabot> forall a. (Floating a) => a -> a
19:48:06 <glguy> > runReader ( asks (,) `ap` asks sin ) 2
19:48:07 <lambdabot>  (2.0,0.9092974268256817)
19:48:12 <glguy> chessguy: its the implicit version of that
19:49:19 <chessguy> hm, i probably shouldn't have asked :)
19:49:34 <chessguy> @src ap
19:49:34 <lambdabot> ap = liftM2 id
19:49:51 <glguy> > runReader ( do { f <- asks (,); x <- asks sin; return (f x) ) 2
19:49:52 <lambdabot>  Parse error
19:49:55 <glguy> > runReader ( do { f <- asks (,); x <- asks sin; return (f x) } ) 2
19:49:56 <lambdabot>  (2.0,0.9092974268256817)
19:50:49 <jsnx> what is 'lifting' ?
19:51:02 <dibblego> ?type liftM
19:51:04 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
19:51:12 <jsnx> is there a short paper/tutorial that explains where the term comes from?
19:51:16 <mauke> > sin 2  -- vanilla
19:51:18 <lambdabot>  0.9092974268256817
19:51:23 <mauke> > map sin [1 .. 10]  -- lifted
19:51:25 <lambdabot>  [0.8414709848078965,0.9092974268256817,0.1411200080598672,-0.756802495307928...
19:51:26 <glguy> jsnx: you are lifting a function that acts on values to a function that acts on monads of values
19:51:47 <jsnx> glguy: right, but that's liftM -- I mean, lifting in general
19:52:12 <glguy> replace Monad with things
19:52:30 <jsnx> glguy: yes, exactly...
19:52:41 <chessguy> > JliftM2 id (,) sin 2
19:52:42 <lambdabot>   Not in scope: data constructor `JliftM2'
19:52:45 <chessguy> > liftM2 id (,) sin 2
19:52:46 <lambdabot>  (2.0,0.9092974268256817)
19:52:52 <chessguy> @src liftM2
19:52:52 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
19:52:57 <jsnx> so is lifting just adding an extra argument?
19:53:02 <glguy> no
19:53:06 <jsnx> okay
19:53:13 <mauke> chessguy: wow, that's almost deliciously evil
19:53:15 <Saizan> > liftM2 ($) (,) sin 2
19:53:16 <lambdabot>  (2.0,0.9092974268256817)
19:53:18 <jsnx> but it adds an extra argument?
19:53:22 <jsnx> always?
19:53:24 <mauke> > liftM2 (,) id sin 2  -- makes much more sense
19:53:26 <lambdabot>  (2.0,0.9092974268256817)
19:53:37 <dibblego> > liftM (+2) [1..10]
19:53:39 <lambdabot>  [3,4,5,6,7,8,9,10,11,12]
19:53:39 <glguy> jsnx: no, it doesn't
19:53:46 <dibblego> ?type liftM (+2) [1..10]
19:53:48 <lambdabot> forall a1. (Num a1, Enum a1) => [a1]
19:53:54 <glguy> jsnx: in the reader case, it adds an argument because that argument is how you run that monad
19:54:00 <dibblego> ?type liftM (+2)
19:54:02 <lambdabot> forall a1 (m :: * -> *). (Num a1, Monad m) => m a1 -> m a1
19:54:23 <glguy> in the reader monad, liftM is (.)
19:55:11 <jsnx> oh, i found it, never mind [ http://en.wikipedia.org/wiki/Lift_%28mathematics%29 ]
19:55:13 <lambdabot> Title: Lift (mathematics) - Wikipedia, the free encyclopedia
19:55:22 <chessguy> @type liftM2
19:55:24 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
19:55:44 <jsnx> thank you, glguy, for your valiant efforts
19:55:54 <chessguy> i don't get it
19:56:00 <glguy> chessguy: which?
19:56:22 <glguy> You don't get what liftM2 "means"?
19:56:38 <chessguy> what part of that type signature is reflected by what part of liftM2 id (,) sin 2
19:56:57 <chessguy> @type id
19:56:59 <lambdabot> forall a. a -> a
19:57:04 <mauke> id is (a1 -> a2 -> r)
19:57:12 <glguy> chessguy: id f x = f x
19:57:20 <chessguy> ok
19:57:22 <glguy> (id f) x = f x
19:57:56 <glguy> so: id ((,) 2) = (,) 2
19:57:58 <dibblego> where are lambdabot's type parameters names derived from?
19:58:11 <Saizan> ghci
19:58:24 <chessguy> but what are the a1, a2, r, and m?
19:58:46 <dibblego> forall a b c (m :: * -> *). (Monad m) => (a -> b -> c) -> m a -> m b -> m c -- probably looks clearer
19:58:50 <dibblego> chessguy, type parameter names
19:58:56 <Saizan> a1 is (a -> b), a2 is a
19:58:57 <glguy> a1 is Num n => n -> n
19:59:01 <chessguy> dibblego, no, i mean what types are they instantiated to
19:59:08 <whaleofconfusion> I wonder if a "failable" data structure could be useful for arrays--one where operations may fail and crash everything, but when they work properly they are pure functional
19:59:09 <glguy> a2 is Num n => n
19:59:09 <chessguy> for liftM2 (,) id sin 2
19:59:35 <hpaste>  dynamix pasted "needs optimisation" at http://hpaste.org/1933
19:59:37 <whaleofconfusion> so you could have something like in-place-xor where inplacexor arr returns, imperatively, the xor of the input
19:59:39 <mauke> m is ((->) Double)
19:59:48 <glguy> chessguy: id :: (n -> n) -> (n -> n)
19:59:51 <whaleofconfusion> and then future references to arr fail
19:59:59 <mauke> a2 is Double
20:00:13 <mauke> a1 is (Double -> (Double, Double))
20:00:24 <whaleofconfusion> but since they (future references to arr) never return a value, it doesn't matter what value they could have been, so it's still referentially transparent
20:00:32 <mauke> r is (Double, Double)
20:00:54 <hpaste>  dynamix annotated "needs optimisation" with " fixed a minor comment" at http://hpaste.org/1933#a1
20:01:16 <whaleofconfusion> does that make sense?
20:01:47 <Saizan> whaleofconfusion: hard to mix with lazy eval
20:02:29 <chessguy> mauke, thanks, i'll have to let that sink in a little
20:03:51 <whaleofconfusion> well Saizan let me put it this way, a program that has a "failable" imperative data structure, if its proper behavior was not to fail, will never fail
20:03:59 <glguy> > liftM2 ((.) $ \ x -> (x,x)) (,) sin 2
20:04:00 <lambdabot>  ((2.0,0.9092974268256817),(2.0,0.9092974268256817))
20:04:06 <whaleofconfusion> but if its proper behavior is to fail, it will sometimes fail and sometimes not, due to lazy evaluation
20:04:28 <glguy> > liftM2 (join (,) .) (,) sin 2
20:04:30 <lambdabot>  ((2.0,0.9092974268256817),(2.0,0.9092974268256817))
20:04:37 <whaleofconfusion> so when the program is properly constructed there is not a problem--the only problem is when there is a bug, and then it's ambiguous what kind of bug that would be
20:04:54 <dynamix> dolio: are you still around?
20:05:02 <dolio> dynamix: Yeah.
20:05:27 <Saizan> whaleofconfusion: i think that's called unsafePerformIO :)
20:05:31 <dynamix> check out the paste i put in http://hpaste.org/1933#a1
20:06:01 <dolio> dynamix: What needs to be optimized?
20:07:02 <whaleofconfusion> true, that just always rolls on and never fails in case of a second reference to arr, which by the same reasoning would be "all right"
20:07:05 <dynamix> dolio: solve ..  a is computed several times, and i dont want to pass it in as a param to q and p
20:07:20 <whaleofconfusion> so what's needed is a way to guarantee failure at a "later" reference to arr, by some definition of "later"
20:07:43 <dolio> Oh.
20:08:37 <whaleofconfusion> you might have special language support for it, so that any failable operation must be performed as late as possible
20:08:54 <dolio> dynamix: You could put p and q in the where clause for solve.
20:09:08 * wli finds Grobner basis code vastly superior to his own.
20:09:09 <chessguy> @type id (,)
20:09:11 <lambdabot> forall a b. a -> b -> (a, b)
20:09:13 <dynamix> but they are generic functions that can be used in other places too
20:09:52 <whaleofconfusion> i.e. so that foo (failableop arr) arr would not fail
20:09:53 <jfredett> if i wrote a function with- lets say- the type [a] -> [a], will that implicitly work on [[a']] ->[[a']] ?
20:10:10 <dolio> dynamix: Well, then, I don't think there's any way to avoid either recomputing as or passing it as a parameter.
20:10:16 <jfredett> that is, will a sorter function defined on lists work on lists of lists too?
20:10:24 <whaleofconfusion> with the second arr being evaluated before failableop, by special language construct
20:10:31 <jfredett> just out of curiousity
20:10:42 <mauke> jfredett: sure
20:10:46 <jfredett> cool
20:10:55 <mauke> > length [1,2,3]
20:10:56 <lambdabot>  3
20:11:00 <mauke> > length [[1],[2,3]]
20:11:02 <lambdabot>  2
20:11:44 <dynamix> do you find any other chances for optim?
20:11:46 <dolio> dynamix: Or, wait, do you mean recomputing it in q and p?
20:11:50 <jfredett> well duh, I'm an idiot. I should have realized length was like that, what about [a] -> [b], should that work with a = b? (I think so, but it's broken before on me)
20:12:09 <dolio> dynamix: You can avoid that... Hold on...
20:12:11 <dynamix> i did one more, defined a temp function to compute p and q from teh third elem on.
20:12:22 <whaleofconfusion> with any evaluation order, failable operations would at least allow mutation for efficiency purposes, without allowing you to actually change the value of a variable
20:12:24 <mauke> I don't think there's a function [a] -> [b]
20:12:36 <dibblego> ?djinn [a] -> [b]
20:12:36 <lambdabot> -- f cannot be realized.
20:12:39 <jfredett> (namely with a map-esque type, with the signature [a] -> (a->a->b) -> [b]
20:12:39 <chessguy> ugh, i still don't get this
20:12:39 <Saizan> jfredett: type variables are universally quantified
20:12:53 <chessguy> liftM2 takes 3 parameters
20:12:55 <dibblego> universally quantified == "forall"
20:13:00 <mauke> > map id [1,2,3]
20:13:02 <lambdabot>  [1,2,3]
20:13:03 <jfredett> mauke: that makes sense. hmm
20:13:21 <chessguy> what are the three parameters in liftM2 id (,) sin 2?
20:13:33 <Saizan> id (,) sin
20:13:51 <Saizan> ?type liftM2 id (,) sin
20:13:53 <lambdabot> forall a. (Floating a) => a -> (a, a)
20:13:57 <jfredett> anyway- back to work :/
20:13:59 <mauke> liftM2 c f g x  =  f x `c` g x
20:14:00 <chessguy> oh!
20:14:12 <|Steve|> :t map (\_ -> ())
20:14:13 <lambdabot> forall a. [a] -> [()]
20:14:20 <mauke> liftM2 id (,) sin  =  \x -> (,) x `id` sin x
20:14:37 <chessguy> ok, the currying was getting me
20:15:04 <chessguy> so it's (liftM2 id (,) sin) 2
20:15:31 <Saizan> yes, with the 2 you run the monad
20:16:28 <chessguy> yeah, i was parsing it as liftM2 id (,) (sin 2) for some reason
20:17:15 <mauke> anyway, the mirror of `ap` is >>=
20:17:36 <hpaste>  dolio annotated "needs optimisation" with "new p & q" at http://hpaste.org/1933#a2
20:17:46 <mauke> > ap (,) sin 2
20:17:47 <lambdabot>  (2.0,0.9092974268256817)
20:17:49 <chessguy> @type do { x1 <- (,); return x1 }
20:17:50 <lambdabot> forall a b. a -> b -> (a, b)
20:17:53 <mauke> > (>>=) sin (,) 2
20:17:54 <lambdabot>  (0.9092974268256817,2.0)
20:17:56 <chessguy> wtf
20:18:01 <chessguy> that's freaky
20:19:35 <chessguy> > (do { x1 <- (,); x2 <- sin; return (id x1 x2) }) 2
20:19:37 <lambdabot>  (2.0,0.9092974268256817)
20:19:59 <chessguy> ok, i think i'm just going to go suck my thumb for a while
20:20:22 <mauke> @src (->) return
20:20:22 <lambdabot> return = const
20:20:30 <mauke> @src (->) >>=
20:20:30 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
20:20:34 <mauke> @src (->) (>>=)
20:20:35 <lambdabot> f >>= k = \ r -> k (f r) r
20:20:44 <hpaste>  dolio annotated "needs optimisation" with "shortening" at http://hpaste.org/1933#a3
20:21:26 <dfranke_> LMAO.  I just saw the ErlkÃ¶nig parody on the Haskell humor page.
20:22:04 <chessguy> @src id
20:22:04 <lambdabot> id x = x
20:22:50 <chessguy> @src const
20:22:50 <lambdabot> const x _ = x
20:23:20 <mauke> > const "butter" undefined
20:23:21 <lambdabot>  "butter"
20:23:27 <dynamix> dolio:  tail recursive :)
20:24:08 <dolio> dynamix: Well, actually, it's not tail recursive. But it does share 'as' now.
20:24:33 <dynamix> i was about to say can we make it tail recursive?
20:24:38 * chessguy is not looking forward to de-sugaring the do-notation for this
20:24:51 <dynamix> what is LMAO ?
20:25:19 <dynamix> dont bother, google told me something
20:25:26 <mauke> chessguy: it all makes sense if you understand the list monad
20:25:27 <dynamix> Laugh my A$$ off ?
20:25:48 <mauke> oh, and if you view functions as associative arrays
20:25:53 <chessguy> mauke, i never claimed to understand the list monad :)
20:26:16 <mauke> basically, a function a -> b is a map from keys in a to values in b
20:26:25 <chessguy> @src (->) return
20:26:25 <lambdabot> return = const
20:26:35 <Saizan> x <- f in the ((->) r) monad just means let x = f r
20:26:44 <mauke> "return foo" is a map that always returns foo, no matter what key you use
20:26:57 <chessguy> > ((,) >>= \x1 -> (sin >>= \x2 -> return (id x1 x2))) 2
20:26:59 <lambdabot>  (2.0,0.9092974268256817)
20:27:08 <chessguy> yay, this just gets nastier and nastier
20:27:23 <mauke> > ((,) >>= \x1 -> (sin >>= \x2 -> const (x1 x2))) 2
20:27:24 <godling> usually does
20:27:25 <lambdabot>  (2.0,0.9092974268256817)
20:27:48 <chessguy> mauke, don't get ahead of me, i'm getting there
20:28:03 <mauke> now you just need to inline >>= and it'll become totally complicated/trivial
20:28:24 <chessguy> complicated/trivial, lol
20:28:25 <mauke> chessguy: I just inlined return and id
20:28:42 <chessguy> mauke, yes, i was just about to do that. you stole my thunder
20:28:57 <mauke> sorry
20:31:42 <chessguy> > ((,) >>= \x1 -> (\r -> (\x2 -> const (x1 x2)) (sin r) r)
20:31:42 <lambdabot>  Parse error
20:32:17 <chessguy> not quite
20:32:29 <Cale> Just look at the type of (>>=) in ((->) e) to see what it must do
20:32:38 <chessguy> > ((,) >>= \x1 -> (\r -> (\x2 -> const (x1 x2)) (sin r) r))) 2
20:32:38 <lambdabot>  Parse error
20:32:38 <tjm1983> chessguy: missing a ) I think.
20:32:47 <Cale> (e -> a) -> (a -> e -> b) -> e -> b
20:32:58 <mauke> djinn it!
20:33:02 <Cale> There's really only one thing that could be :)
20:33:08 <Cale> @djinn (e -> a) -> (a -> e -> b) -> e -> b
20:33:08 <lambdabot> f a b c = b (a c) c
20:33:45 <Cale> So (>>=) sin (,) 2 = (,) (sin 2) 2
20:34:16 <Cale> Or if you want, (sin >>= (,)) 2 :)
20:34:28 <chessguy> > ((,) >>= \x1 -> (\r -> (const (x1 x2)) (sin r) r)) 2
20:34:30 <lambdabot>   Not in scope: `x2'
20:34:52 <ddarius> So Mac Lane has as an exercise to prove something that is false.
20:35:04 <chessguy> > ((,) >>= \x1 -> (\r -> (\x2 -> const (x1 x2)) (sin r) r)) 2
20:35:06 <lambdabot>  (2.0,0.9092974268256817)
20:35:10 <chessguy> yay
20:35:25 <Cale> The idea behind the ((->) e) monad is that each "computation" is just a function, and "running a computation" is just supplying the parameter to it.
20:35:46 <chessguy> one more >>= to inline
20:35:54 <ddarius> That's what it is, not the idea behind it.
20:35:58 <mauke> don't give up now!
20:36:17 <Cale> ddarius: Well, it is the idea that is behind it in some sense. :)
20:37:00 <Cale> But really I just used that phrase to (perhaps needlessly) differentiate what I was saying from the implementation of that behaviour.
20:37:11 <dynamix> is there a library that provides Permutation and combinations etc..  ? searching for those words in hoogle turns up nothing
20:37:29 <dynamix> Cale: hi
20:37:31 <ddarius> Cale: But you described the implementation and not the idea of the behavior.
20:38:01 <chessguy> (\r -> (\x1 -> (\r -> (\x2 -> const (x1 x2)) (sin r) r)) ((,) r) r) 2
20:38:03 <hpaste>  dolio annotated "needs optimisation" with "tail recursive" at http://hpaste.org/1933#a4
20:38:04 <chessguy> > (\r -> (\x1 -> (\r -> (\x2 -> const (x1 x2)) (sin r) r)) ((,) r) r) 2
20:38:06 <lambdabot>  (2.0,0.9092974268256817)
20:38:28 <mauke> chessguy: you might want to rename one of the r's
20:38:31 <wli> dynamix: Yes.
20:38:37 <dolio> dynamix: I'm not sure if I got those transformations right.
20:39:04 <wli> dynamix: http://www.polyomino.f2s.com/david/haskell/permgrp.html
20:39:06 <lambdabot> Title: Permutation Groups in Haskell
20:39:15 <chessguy> > (\r -> (\x1 -> (\r -> (\x2 -> const (x1 x2)) (sin r) r)) ((,) r') r') 2
20:39:16 <lambdabot>   Not in scope: `r''
20:39:28 <chessguy> > (\r' -> (\x1 -> (\r -> (\x2 -> const (x1 x2)) (sin r) r)) ((,) r') r') 2
20:39:29 <lambdabot>  (2.0,0.9092974268256817)
20:40:14 <dynamix> nPr, nCr etc.. used in binomial coefficients etc..
20:40:33 <cytzol> :r
20:40:46 <cytzol> eh..
20:40:52 <mauke> :revolutions
20:40:55 <chessguy> > (\x1 -> (\r -> (\x2 -> const (x1 x2)) (sin r) r)) ((,) 2) 2)
20:40:55 <lambdabot>  Parse error
20:41:18 <mauke> too many )'s?
20:41:34 <mauke> hmm
20:41:36 <chessguy> > (\r' -> (\x1 -> (\r -> (\x2 -> const (x1 x2)) (sin r) r)) ((,) r') r') 2
20:41:38 <lambdabot>  (2.0,0.9092974268256817)
20:42:07 <chessguy> > (\x1 -> (\r -> (\x2 -> const (x1 x2)) (sin r) r)) ((,) 2) 2
20:42:08 <lambdabot>  (2,0.9092974268256817)
20:42:11 <chessguy> there we go
20:42:49 <mauke> btw, you could fuse those lambdas
20:43:00 <mauke> \x -> \y -> \z -> ...  =  \x y z -> ...
20:43:11 <chessguy> oh, good idea
20:43:14 <mauke> or am I reading this wrong?
20:43:15 <wli> dynamix: What all are you looking for?
20:43:34 <mauke> it doesn't work for \x2
20:43:41 <chessguy> > (\x1 r x2 -> const (x1 x2)) (sin r) r)) ((,) 2) 2
20:43:41 <lambdabot>  Parse error
20:44:21 <chessguy> > (\x1 r -> (\x2 -> const (x1 x2)) (sin r) r)) ((,) 2) 2
20:44:21 <lambdabot>  Parse error
20:44:21 <wli> dynamix: I wrote a sort of permutation calculator but it was nowhere near as advanced in terms of operations supported as what I just pointed you at.
20:44:48 <mauke> > (\x1 r -> (\x2 -> const (x1 x2)) (sin r) r) ((,) 2) 2
20:44:50 <lambdabot>  (2,0.9092974268256817)
20:45:07 <dynamix> wli: something like ncr n r = (fac n) / ( fac( n-r ))  ; formula could be wrong..
20:46:02 <chessguy> mauke, actually, when doing it by hand, i think leaving it unfused is easier
20:46:28 <ddarius> Clearly a structure editor is in order.
20:46:31 <mauke> but this way it's more obvious that ((,) 2) is x1 and 2 is r
20:46:33 <mauke> to me, at least
20:46:37 <chessguy> > (\r -> (\x2 -> const (2 x2)) (sin r) r)) ((,) 2)
20:46:38 <lambdabot>  Parse error
20:46:56 <chessguy> > (\r -> (\x2 -> const (2 x2)) (sin r) r) ((,) 2)
20:46:57 <lambdabot>        add an instance declaration for (Floating (b -> (t, b)))
20:47:17 <mauke> the other way around
20:47:19 <ddarius> I don't think you want to be applying 2 to something.
20:47:20 * wli calls bot abuse.
20:48:53 <chessguy> yeah, i better stop abusing the bot, i might learn something
20:49:10 <SamB_XP_> ddarius: why not?
20:49:28 <wli> It's there to be used, but this is over the top.
20:50:12 <ddarius> SamB_XP_: At least lambdabot does not have an instance of Num for functions.
20:50:15 <chessguy> it's an ongoing discussion between several of us
20:50:39 <mauke> oh, it will
20:50:53 <SamB_XP_> mauke: what kind of functions?
20:51:19 <mauke> SamB_XP_: http://mauke.ath.cx/stuff/haskell/fun.hs
20:51:21 * wli wrote an instance Num t => Num (t' -> t)
20:51:31 <ddarius> n+k Church numeral patterns!
20:51:39 <mauke> instance (Num a, Monad m, Eq (m a), Show (m a)) => Num (m a) where
20:51:51 <SamB_XP_> ddarius: now, now, that isn't Haskell 98
20:51:53 <sorear> too bad LB doesn't support stuff like that..
20:52:31 <SamB_XP_> mauke: yours isn't Haskell 98 either!
20:52:50 <SamB_XP_> > id == id
20:52:51 <lambdabot>   add an instance declaration for (Eq (a -> a))
20:52:51 <lambdabot>     In the expression: id == ...
20:53:04 <SamB_XP_> > const () == const ()
20:53:05 <lambdabot>   add an instance declaration for (Eq (b -> ()))
20:53:05 <lambdabot>     In the expression: (cons...
20:53:11 <mauke> > show id
20:53:12 <lambdabot>  Add a type signature
20:53:27 <dons> ddarius: hehe. that would be fun Num (a -> b) eh?
20:53:28 <SamB_XP_> okay, I'm going to bed
20:53:40 <dons> I think we need to start inserting types into overloaded string literals
20:54:03 <SamB_XP_> dons: you mean -fglasgow-exts enables that?
20:54:21 <dons> i mean "a.*b" :: Regex
20:54:23 <chessguy> @bot
20:54:23 <lambdabot> :)
20:54:33 <dons> for example, or other data embedded in string literals
20:54:34 <wli> dons: Nice chess code, BTW.
20:54:38 <dons> wli?
20:54:46 <mauke> hmm, could someone put fun.hs in lambdabot's default environment?
20:55:00 <wli> dons: Some chess code of yours is linked from one of the Haskell libs/apps pages.
20:55:05 <ddarius> "mov eax, 3\nint 0x80" :: IO ()
20:55:17 <ddarius> mauke: Good god no!
20:55:22 <mauke> aww
20:55:46 <dons> wli, hmm, I'm not sure I wrote chess code?
20:55:49 <dons> wli, url?
20:55:53 <mauke> ddarius: more like "\232\14\0\0\0Hello, world!\n\186\14\0\0\0\89\187\1\0\0\0\184\4\0\0\0\205\128\49\192\195" :: IO ()
20:56:36 <dynamix> dolio:  your modified functions give with error  dolio.hs:7:18: Not in scope: `foldl''
20:56:36 <wli> dons: Ah, darcs' inventory says: [Initial cabalisation of  Steffen Mazanek's chess program Don Stewart <dons@cse.unsw.edu.au>**20070317005227]
20:56:46 <dons> oh, i just cabalised it :)
20:56:48 <dolio> dynamix: import Data.List
20:56:53 <dons> its all Steffen Mazanek's work
20:57:32 <dynamix> dolio:  works !!
20:57:42 <dolio> dynamix: Does it give the right answer?
20:57:45 <dynamix> ill have to keep notes :)
20:57:48 <dynamix> yeah it does
20:57:52 <dolio> Nice.
20:58:07 <dynamix> foldl' is the strict foldl right?
20:58:16 <dolio> Yeah.
20:58:49 <dons> but what is it strict in? :)
20:59:21 <dolio> dynamix: Although that may only be making the tuple strict there, and therefor not be as useful as possible.
20:59:41 <dolio> But I'm not really sure.
21:01:54 <dynamix> i dont have a any benchmarks to see how much memory / time it saves. and the examples i have are also very small sequences.
21:02:09 <dynamix> by the way did you understand what the code does ?
21:03:23 <dolio> Not really. I was just looking for patterns I recognize in the code. I didn't think about what was actually doing.
21:03:44 <ddarius> Who needs understanding when you have formalism?
21:03:53 <mauke> you evil refactorer
21:04:42 <dynamix> basically it finds all integer solutions to line with integer coeffs ; eg: all integer solutions  (x,y) of k1x + k2y = k3
21:04:49 <wli> A somewhat harder problem is to get high-order convergents for numbers only representable as limit processes.
21:06:05 <wli> dynamix: ISTR the way that's solved being via the extended Euclidean algorithm.
21:06:43 <dynamix> what is  ISTR ?
21:06:49 <ddarius> @vera ISTR
21:06:50 <lambdabot> *** "istr" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
21:06:50 <lambdabot> ISTR
21:06:50 <lambdabot>      I Seem To Recall / Remember (telecommunication, Usenet, IRC)
21:06:50 <lambdabot>  
21:06:53 <wli> dynamix: Which, I suppose, makes sense wrt. the continued fraction.
21:07:32 <dynamix> i had the original book "leelavati ganitam" by bhaskara acharya -- the sanskrit version
21:08:20 <dynamix> then found an english book with a complete proof
21:10:25 <dynamix> wow i seem to ahve silenced every one :)
21:10:30 <dons> ?yow!
21:10:30 <lambdabot> I hope I bought the right relish ... zzzzzzzzz ...
21:10:35 <wli> dynamix: How so?
21:11:43 <dynamix> generally the room was busy and then i typed those comments, and then no one else typed anything :)
21:11:49 <xpika> is it possible to convert haskell to perl or php?
21:12:00 <ddarius> xpika: Yes.
21:12:25 <kilimanjaro> xpika, sure, not sure how well perl would run Haskell style code though since it isnt inherently lazy
21:12:48 <ddarius> Assembly isn't inherently lazy either.
21:13:02 <xpika> ddarius: you stole my response
21:13:14 <wli> dynamix: How would I know?
21:16:29 <hpaste>  dolio annotated "needs optimisation" with "avoid computation" at http://hpaste.org/1933#a6
21:18:53 <dynamix> dolio:  did you notice that except for the tuple of initial values, op and q are same :)
21:19:13 <dolio> Yeah. :)
21:21:23 <dolio> You could factor out the '\(qn1, qn2) an -> ...' stuff, but other than that they're too different.
21:22:32 <dolio> Although that'd make it slightly more convenient to make sure it strictly evaluates the arithmetic.
21:22:54 <dolio> If GHC can't figure that out on its own.
21:25:33 <dynamix> but to get a0 and a1 might be difficult.  for different ratios they could be different
21:34:36 <wli> dynamix: let { egcd (m, n) | m == 0 = (0, 1, n) | abs m > abs n = let (n', m', d) = egcd (n, m) in (m', n', d) | otherwise = let { (q, r) = n `quotRem` m ; (rBar, mBar, d) = egcd (r, m) ; m' = mBar - q*rBar ; n' = rBar } in (m', n', d) ; solve (i, j, k) = let { (m, n, d) = egcd (i, j) ; (q, r) = k `quotRem` d } in if r /= 0 then Nothing else Just (q*m, q*n)} in solve (42, 91, 21)
21:35:12 <dynamix> wli can you hpaste please? im still demangling your last post
21:45:56 <hpaste>  wli annotated "needs optimisation" with "faster fundamental solution" at http://hpaste.org/1933#a7
21:46:14 <wli> dynamix: hpasted.
21:47:16 <wli> dynamix: Tested with 42*x+91*y=21 with the signs of 42 and 91 changed around in various ways.
21:48:44 <dons> so have we won yet?
21:52:14 <wli> I've largely forgotten how to solve systems of integer linear equations but it's something on this order.
21:52:15 <chessguy> won?
21:52:43 <wli> When you have egcd's of lists you always want to select the least element of the list.
21:53:21 <wli> I'm not sure when you do that vs. matrix row operations.
21:53:32 <dynamix> wli: cool works,  you also handle the no solution case better :)
21:53:56 <wli> dynamix: It's just an application of Bezout's theorem.
21:54:07 <dynamix> yeah :)
21:55:37 <wli> I can generalize it to find fundamental solutions of a single linear equation in n integer variables, but I'm not sure what to do after that.
21:56:04 <dynamix> i vaguely remember the theorem
21:56:32 <wli> dynamix: What I don't handle is the homogeneous case.
21:56:34 <dynamix> just looked it up on wikipedia , i need to brush up on my number theory fu some time :)
21:59:14 <hpaste>  wli annotated "needs optimisation" with "correction for homogeneous case" at http://hpaste.org/1933#a8
21:59:27 <wli> dynamix: Sorry I flubbed it.
22:00:27 <dynamix> :)
22:01:05 <wli> dynamix: Anyway you can see the correction and it's relatively simple. All I had to do was check k == 0 and so on.
22:02:52 <wli> The homogeneous case in many variables is more difficult to represent.
22:03:27 <wli> I'm really slapping myself over the integer linear system algorithm.
22:04:26 <dynamix> i had implemented this algo in  Pascal and C , and now in  Haskell :) i should say except for having to parantehsize unary minus (-k)  , Haskell is hands down my favourite:)
22:04:35 <sorear> the linearity is very very important, http://en.wikipedia.org/wiki/Hilbert%27s_tenth_problem
22:04:37 <lambdabot> Title: Hilbert's tenth problem - Wikipedia, the free encyclopedia
22:04:40 <whaleofconfusion> I'm trying to think how a "secure, distributed mapping of keys to values" might work, where some the map servers may be untrustworthy, and so may some of the clients
22:04:51 <sorear> me too :)
22:05:41 <whaleofconfusion> I'm thinking, first thing, the clients should download a checksum for anything they download, from a server chosen randomly
22:05:58 <whaleofconfusion> so they will probably be able to tell if a servre is trying to give them a bogus key,value pair
22:06:14 <whaleofconfusion> but then you also want to eliminate the servers that are bogus, penalize them somehow
22:06:32 <wli> sorear: It's some combination of Gaussian elimination and extended GCD for n variables but I can't remember quite how it goes.
22:07:56 <whaleofconfusion> i.e. basically, if anyone had the ability to set up a DNS server for any set of domains, and maybe at least 75% of the servers are not malicious, how could you make it work?
22:09:00 <dynamix> alright guyz, gnite from me.
22:10:44 <chessguy> mauke, finally made it through that trace
22:11:30 <hpaste>  chessguy pasted "for mauke" at http://hpaste.org/1934
22:19:10 <whaleofconfusion> hey, would the use of checksums for verification be enhanced if the verifying checksum is of the original message + some random string?
22:20:11 <wli> whaleofconfusion: Not really a good way to try it. You probably want to look for Reed-Solomon codes and generalizations thereof.
22:20:27 <whaleofconfusion> i.e., client gets key-value pair X, Y from dubious server A, and then sends X to trusted server B.  B returns (md5sum(Y+random_string), random_string)
22:20:56 <whaleofconfusion> client computes md5sum(Y+random_string) for the Y that it got from A, and if it matches the sum from B, the message is ok
22:22:01 <whaleofconfusion> only reason to use md5sum at all in this case is that Y might be a large file
22:22:25 <wli> whaleofconfusion: Look up Reed-Solomon codes in wikipedia.
22:30:00 <wli> http://arxiv.org/ftp/math/papers/0010/0010134.pdf may help
22:37:16 <kaol> do you usually write >>= / >> at the end of the line or at the start of it?
22:38:09 <chessguy> hmm, http://sambangu.blogspot.com/2007/07/python-to-rescue-icfp-contest-2007 asks some interesting questions
22:38:11 <lambdabot> Title: Sambangu: Python to the rescue: ICFP contest 2007, http://tinyurl.com/2xeu6z
22:38:27 <chessguy> kaol, why not just use do-notation?
22:38:54 <kaol> I'm running out of primes
22:39:02 <kaol> foo'''''' anyone?
22:41:02 <oerjan> are those foo's all the same type? you might want a State monad or a fold.
22:41:30 <kaol> I'm doing SQL queries. Can't really avoid using IO.
22:42:42 <kaol> but I was just trying to decide on which convention to pick when undoing my dos
22:42:42 <oerjan> there is still StateT _ IO
22:42:54 <kaol> sometimes do is just as much clutter, especially since I'm becoming more comfortable with using monads. :-)
22:45:24 <oerjan> i think i would prefer >>= at the beginning, anyhow, easier to line up.
22:46:56 <oerjan> and easier to see that the line is a continuation of something
22:52:33 <newsham> must write fingertree dna engine in python
22:53:13 <newsham> although i dont see how "python to the rescue" describes python coming to the rescue
22:53:16 <newsham> sounds like he didnt get much done
22:56:33 <chessguy> newsham, oh, i agree
22:56:48 <chessguy> but he does ask some interesting questions about doing low-level stuff at a high level
22:57:29 <newsham> icfp is a bad example of that.  rewriting the same code from python to C doesnt speed it up much
22:57:32 <newsham> if its memory bound to start with
22:57:47 <newsham> in fact, my python, haskell and C implementations of the same dna engine were not very different in speed
22:58:19 <newsham> especially compared to my speeds vs. speeds of people who picked better data structures
22:58:29 <chessguy> hm, that doesn't sound like the results most people had
22:59:08 <newsham> my original python was about 15-20 iters per second.  haskell was comparable (String).  C was about 30-50/sec, with some optimizations
22:59:10 <chessguy> anway
22:59:12 <chessguy> @time
22:59:13 <lambdabot> Local time for chessguy is Sun Jul 29 01:57:02
22:59:17 <chessguy> bedtime for me :)
22:59:45 <Olathe> @time
22:59:46 <lambdabot> Local time for Olathe is Sat Oct 26 01:24:00 1985
23:00:00 <dolio> 1985?
23:00:13 <dons> cool
23:00:19 <dons> the time machine works.
23:00:19 <newsham> olathe: can you get a message to 1985 me?
23:00:30 <newsham> "buy real estate in london"
23:00:31 <Olathe> My flux capacitor is broken :(
23:01:23 <dolio> Apparently C++ was handy for the contest, because the GCC template library has ropes.
23:01:34 <Olathe> STL is pretty nice.
23:01:42 <dolio> No data structure implementation required. :)
23:01:49 <Olathe> Too bad I don't like C++.
23:03:27 <newsham> i very much dislike stl, but ropes woulda been nice
23:03:47 <newsham> i think the fingertrees woulda been more fun though
23:04:32 <newsham> i'm still goofing off w/ them trying to understand fully, but they seem pretty cool.  http://www.thenewsh.com/%7Enewsham/x/fingtree.py
23:05:19 <dons> dolio: yeah, people used lists of bytestrings here for sublinear append, or finger trees, but a ropes lib would have been good too
23:05:20 <dolio> Heh, this "Strategy Pattern: comparing Java X Lisp" is amusing. As are many design pattern blogs, I suppose.
23:05:56 <dolio> 3 pages of Java code versus "well, Lisp has this function called 'remove-if-not'".
23:06:14 <glguy> Data.Sequence is a finger tree
23:06:37 <dons> glguy: how's the soccer team going?
23:06:52 <glguy> new high goals-for and goals-against tonight
23:06:54 <glguy> 4-11
23:07:13 <dons> oh man. is it indoor soccer, btw?
23:07:18 <glguy> yep
23:07:28 <dons> i wonder if my hacky sac skills would be useful. hmm
23:07:36 <glguy> we were quite understaffed compared to normal
23:07:50 <newsham> books full of obvious patterns that you can use while programming are amusing
23:07:59 <newsham> you could make a visitor!
23:10:22 <dolio> So, apparently Jon Harrop was visiting haskell-cafe because he's considering writing Haskell for Scientists.
23:11:00 <dons> dolio: hah sigh
23:11:03 <glguy> is he qualified as either a scientist or haskeller??
23:11:26 * glguy might write a book on rugby for women
23:11:33 <dolio> Well, his existing book is called OCaml for Scientists.
23:11:50 <newsham> qualified to teach == not really a scientist or haskeller, no? :)
23:11:51 <dolio> So I guess he might be qualified as the former.
23:12:26 <dolio> I don't think I'd label him a Haskeller.
23:12:50 <newsham> dont you write monad tutorials when you dont really understand monads?
23:13:05 <dons> see, he does't even write monad tutorials
23:13:30 <Korollary> He recently asked how || worked. I don't think he should be writing a book just yet.
23:13:33 <dolio> I'm not sure if he's turned off to the idea or not.
23:13:36 <newsham> i dont know the guy, i'm just saying, isnt not being really a haskeller or really a scientist exactly the qualifications you need to write a haskell for scientists book?
23:14:10 <glguy> typically you should know the topic you are writing about
23:14:37 <newsham> hmm.. the bookstores must be a lot emptier (and more interesting) in your world
23:14:41 <wli> Well, if I were to write a monad tutorial, it would be from the POV of someone describing their thought processes as they just barely eke through problems/examples. Which wouldn't make it much of a tutorial.
23:14:43 <glguy> but I guess they do say: "Those that can't do teach. Those that can't teach write"
23:14:54 <glguy> no offense dons ;)
23:15:02 <Korollary> dons can't teach
23:15:09 <dolio> Although I'd be interested to see a book that advises the reader to 'optimize by randomly fiddling until the current version of GHC happens to reduce [their code] in an asymptotically more efficient way.' :)
23:15:58 <Korollary> Anybody can write a book. Not anybody can have it published. Not anybody can have it sold well.
23:15:58 <oerjan> @remember dolio Although I'd be interested to see a book that advises the reader to 'optimize by randomly fiddling until the current version of GHC happens to reduce [their code] in an asymptotically more efficient way.' :)
23:15:59 <lambdabot> Done.
23:34:19 <sorear> dolio: Frighteningly, that is often a quite good way; many aspects of GHC performance are very hard to predict...
