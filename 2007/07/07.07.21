00:00:01 <Thomas2> well, fair enough
00:08:30 <desp> can I call performGC inside unsafePerformIO?
00:09:53 <Heffalump> don't see why not
00:10:23 <dons> sure, since you're breaking all the rules anyway :) but it only really makes sense if you know you've just freed a lot of data, and are about to start allocating again, i think
00:10:33 <desp> yeah
00:10:43 <dons> it did help xmonad to performGC at the end of the event hndler loop
00:10:52 <desp> right after concat
00:11:11 <dons> yeah, so you can throw away  the lazy bytestring at that point
00:11:16 <desp> yup
00:11:30 <dons> i think all this suggests we should have a strict , growing, Data.Binary too
00:11:47 <dons> that just fills buffers, and resizes if it gets too big. and you give it an initial size hint
00:11:54 <desp> hrm
00:12:05 <desp> it still sues exactly as much ram as without calling gc
00:12:07 <dons> but you're just copying around bytestrings, so you hardly need Data.Binary anyway
00:12:47 <desp> the Put monad helped a lot
00:13:02 <desp> I really don't see how to rework the code into an unfold
00:13:04 <dons> yeah, that's a good interface to building lazy bytestrings efficiently
00:13:21 <andyjgill> So who here is taking part in the competition?
00:13:25 <dons> what you need is a size-hinted way to build a strict bytestring without copying
00:13:40 <dons> andyjgill: teams of some of the #haskellers are here, http://haskell.org/haskellwiki/ICFP_Programming_Contest/Teams_2007#Teams
00:13:43 <lambdabot> Title: ICFP Programming Contest/Teams 2007 - HaskellWiki, http://tinyurl.com/3dx5mv
00:14:04 <dons> desp and Binkley are competing, so is Igloo, vincenz, Lemmih, nominolo , Cale lots of others
00:14:48 <andyjgill> Okay, quite of few regulars
00:15:50 <andyjgill> And getting help with HEAD will be tricky right now :-) I
00:16:33 <andyjgill> Specifically, why does the ray-tracer fail in the testsuite:   galois_raytrace(hpc,optasm,ghci,threaded2)
00:24:14 <Toxaris> anyjgill: i'm taking part in the competetion, for instance, but ghc is failing me :(
00:24:48 <Toxaris> D:\dateien\studium\pc\icfp07\tnt_0>ghc --make Main.hs
00:24:49 <Toxaris> [1 of 5] Compiling DRM              ( DRM.hs, DRM.o )
00:24:49 <Toxaris> [2 of 5] Compiling DNA              ( DNA.hs, DNA.o )
00:25:00 <Toxaris> at this point ghc dies without console output
00:25:32 <Toxaris> (there's just a standard-windows dialog shown informing me that i should contact the application vendor)
00:25:53 <dons> Toxaris: huh, very interesting. any different with -O ?
00:26:00 <Toxaris> this is Windows XP & The Glorious Glasgow Haskell Compilation System, version 6.6.1
00:26:28 <Toxaris> dons: no
00:26:57 <Toxaris> but ghci seems to work fine with the same file
00:27:00 <Toxaris> Prelude> :l DNA.hs
00:27:01 <Toxaris> [2 of 2] Compiling DNA              ( DNA.hs, interpreted )
00:27:01 <Toxaris> Ok, modules loaded: DRM, DNA.
00:36:31 <Toxaris> dons: ok i'm switching to ghc-6.6 for now, wich seems to work, will try to repair my ghc-6.6.1 / fill some bug reports / complain here after the contest
00:44:41 <dons> Toxaris: good idea.
00:45:11 <Toxaris> dons: ok, after rebuilding with ghc-6.6, ghc-6.6.1 is working again
00:45:24 * Toxaris should have deleted all intermediate files while testing
00:45:27 * wli wonders how it all works on Windows.
00:45:37 <dons> probably just messed up .hi files or some such
00:45:46 <Toxaris> unfortunately, i cannot reproduce the error now
00:46:46 <Toxaris> there wasn't an error message. not even something like "unexpected error". :(
00:48:27 <wli> I never did manage to get Visual Studio set up on the laptop to see how the plugin worked.
00:52:34 <rubenz> Using Parsec, is there a way to obtain the unconsumed portion of a string after applying a parser to the beginning of it?
00:54:16 <glguy> do { x <- char 'a' ; rest  <- many anyChar ; return (x, rest)} ?
00:55:20 <rubenz> yes, that might work
00:56:17 <dons> should be a way to directly extract it
00:57:27 <Heffalump> liftM2 (,) (char 'a', many anyChar) -- shorter but perhaps harder to read :-)
00:58:21 <glguy> GenParser tok st [tok]
00:58:23 <glguy> err
00:58:31 <glguy> getInput :: GenParser tok st [tok]
00:58:34 <eivuokko> getInput instead of many anyChar, perhaps.
00:58:40 <rubenz> I'm not acquainted with liftM2
00:59:00 <dons> ?src liftM2
00:59:00 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
00:59:15 <dons> code for free :)
01:00:51 <glguy> dons: when did +c return?
01:02:11 <dons> glguy: not sure, i didn't do it.
01:02:24 <dons> probably you can blame vincenz, thta's his kind of trick
01:04:26 * robreim notices haskell seems to have dropped on the language shootout :(
01:04:45 <glguy> the language shootout dropped haskell rather
01:04:58 <dons> robreim: a few entries got disqualfied, a few rules changed
01:05:08 <dons> also, they don't count the concurrency benchmarks by default now
01:05:20 <dons> you could probably update sum-file, at least
01:05:31 <dons> since the super-fast entry there got disqualified
01:05:51 <dons> i updated nsive/nsieve-bits/partial-sums and fasta yesterday
01:05:54 <robreim> I'll take a look
01:06:21 <glguy> the shootout is rather pointless if it only tests lowest common denominator features
01:07:18 <osfameron> glguy: isn't that kindo f the point?
01:07:35 <dons> i'm pretty happy with http://shootout.alioth.debian.org/gp4/benchmark.php?test=nsieve&lang=all anyway
01:07:37 <lambdabot> Title: nsieve benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Language B ..., http://tinyurl.com/ncjpk
01:08:27 <glguy> dons that code looks clean
01:08:34 <dons> the rules can be changed subtly over several months, so it can be worth going back, and seeing if the current top entry is doing something tricky, that wasn't previously allowed.
01:08:38 * wli ponders starting his own alternative shootout.
01:09:00 <wli> Tonight, even.
01:09:09 <robreim> Spectral norm seems to be hurting
01:09:23 <dons> i'd like to know what the clean entry is compiling to http://shootout.alioth.debian.org/gp4/benchmark.php?test=partialsums&lang=all
01:09:25 <lambdabot> Title: partial-sums benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lang ..., http://tinyurl.com/lk8xz
01:09:27 <wli> Not as bad as fasta.
01:09:50 <dons> fasta has an elegant, semi-naive bytestring entry
01:09:58 <dons> so there's definitely room to just do whatever C++ does
01:12:18 <glguy> osfameron: and no, I don't think that that is the point
01:12:39 <wli> I didn't get what the rejected fasta entry was about.
01:12:55 <glguy> if all they want to test is "how long does it take you to loop an empty for loop 1 million times, that's one thing
01:13:08 <glguy> but if the point is to solve some algorithm or problem, they shouldn't tie hands
01:14:03 <osfameron> oh, you mean they're restricting the approach rather than just accepting any program that passes an acceptance test?
01:14:24 <wli> osfameron: Yes, and beyond that, severely and inconsistently.
01:14:26 <Heffalump> why don't they just beef up their acceptance tests?
01:14:37 <glguy> because the point isn't for Haskell to win
01:14:57 <wli> Heffalump: They can't do so in ways that would achieve the results htey want.
01:16:59 <wli> How about determining the order of a group generated by a set of permutations?
01:17:36 <glguy> I have the heart of a child.
01:17:43 <glguy> I keep it in a jar on my shelf.
01:18:31 <glguy>  -- Robert Bloch
01:20:58 * glguy just read a pick-up line, "Hi. You'll do."
01:21:19 <wli> You don't want to know the sorts of pick-up lines that get used on me.
01:25:17 <wli> I wonderif a better problem would be to determine the order of a group given generators and relations.
01:26:58 <wli> I think that sort of implies Knuth-Bendix or some such.
01:31:14 <ulfdoz> folder-hook . 'send-hook "~f \".*@.*example\\.com\"" \
01:31:14 <ulfdoz>     "my_hdr Bcc: foobar@example.com; \
01:31:15 <ulfdoz>         my_hdr X-Loop: foobar@example.com"'
01:31:29 <ulfdoz> Any ideas, why this doesn't show any effect?
01:32:04 <glguy> because it is a pure function?
01:32:11 <ulfdoz> ECHAN, sorry
02:06:47 <rubenz> Another Parsec question: manyTill anyChar (try (string s)) should search for the substring s in the given string. Is there any way to optimise this search so it runs in linear time in the input string (such as with the Knuth Morris Pratt algorithm)?
02:08:28 * sm switches to ByteString to save endo, runs faster & smaller
02:16:36 <dons> sm, to ByteString from what type?
02:16:37 <dons> [Char]?
02:16:53 <dons> i think all the haskell teams are using bytestrings now, either strict or lazy
02:16:58 <sm> dons: yes
02:17:46 <sm> your chat here gave me a push.. thanks for working on it
02:18:50 <dons> it will be interesting to see how well all this bytestring/binary code does
02:22:13 <rubenz> I'm not using ByteStrings, but I'd try it if it could work with Parsec.
02:22:38 <rubenz> Is ther any way to use bytestrings with Parsec?
02:31:05 * sm thinks there is, with enough monad fu
02:32:16 <dons> rubenz: not at the moment.
02:32:24 <dons> but do you need full parsec style parsing?
02:32:30 <dons> or can you get by with take/drop/isPrefixOf
02:32:39 <dons> which will be very fast on strict bytestrings
02:33:05 <dons> rubenz: you in seafood's team?
02:33:15 <rubenz> dons: yes
02:34:17 <rubenz> dons: I don't know. I just went for Parsec and it worked out with only 195 lines of code. Probably could try to change it but am a little bit reluctant right now
02:34:27 <Toxaris> dons: if i have to hold the whole string in memory anyway, strict ByteStrings is the way to go, not lazy, correct?
02:34:50 <hpaste>  wli pasted "crude permutation group order" at http://hpaste.org/1807
02:35:06 <dons> Toxaris: yeah, i think so
02:35:21 <dons> Toxaris: though it depends on if you have to add/copy/concat the string a lot
02:35:38 <xerox> dons, that same combinationn isn't as fast on lazy bs'
02:35:39 <xerox> ?
02:36:20 <glguy> wli: as you could probably guess, using an array in "o" would make that run in O(n) instead of O(n^2)
02:36:34 <dons> lazy bytestrings support cons/append with better complexity but they can be slower to loop over
02:37:10 <Toxaris> dons: is it sensible to use both kinds in the same program?
02:37:17 <wli> glguy: Sounds like a good refinement.
02:37:29 <dons> possibly, yes, Toxaris, if you switch between different processing phases
02:38:07 <glguy> wli: similarly, You could change nub -> Set.toList . Set.fromList  for a O(n^2) -> O(n log m) change
02:38:26 <glguy> where m is the number of unique elements
02:39:06 <xerox> dons, how can the lazybs have a veeeery fast B.length ?
02:39:14 <glguy> wli:
02:39:18 <glguy> @type notElem
02:39:20 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
02:39:28 <dons> xerox: not very fast, O(spine)
02:39:30 <dibblego> ?type msum
02:39:32 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
02:39:47 <xerox> dons it returne the ~7000000 like instantaneous
02:39:58 <dons> sure. its cached in each chunk
02:40:12 <dons> so then it becomes the cost of walking the spine, which is n/32k
02:40:50 <wli> glguy: I think there are other, more powerful analyses.
02:41:40 <xerox> dons ah cool
02:42:38 <glguy> wli: sure, but I'm just trying to mention some relevent "haskellisms"
02:43:48 <Toxaris> dons: hmm too bad, we need both, fast loops and fast concat
02:44:14 <glguy> wli: like, setUnequal us vs = not (null (us \\ vs) && null (vs \\ us))
02:44:21 <glguy> I know there are other ways to do these things
02:44:25 <mnislaih> what can you do to get O(1) concats using a bytestring solution ?
02:44:29 <glguy> I'm just spinning my wheels before I go to bed
02:44:39 <mnislaih> not concats,  appends
02:44:49 <Toxaris> dons: so i think we are better of with lazy to avoid too much copying during concats
02:45:46 <Toxaris> dons: or is it possible / sensible to have chunks of different size?
02:51:05 <dons> Toxaris: its certainly possible
02:52:51 <Toxaris> i think i want BS.concat to concat the chunks but don't copy any data, at least for reasonable large chunks (or is it implemented like this anyway). would make iteration even slower because of smaller chunk size, but concat faster?
02:53:31 <dons> yeah, you could ensure coalescing concats for small pieces
03:01:57 <sm> should I be able to hoogle "Int -> Int64" and find such functions ?
03:02:21 <sm> it seems to return everything
03:02:22 <xerox> fromIntegral
03:03:10 <dons> fromIntegral :: Int -> Int64
03:03:20 <dons> everyone's going to know the bytestring api pretty well by monday..
03:03:25 <hpaste>  wli annotated "crude permutation group order" with "slightly refined permutation group order" at http://hpaste.org/1807#a1
03:04:08 * Toxaris browses ByteStrings code
03:04:45 <genneth> i'm getting undefined reference to `ZCMain_main_CAF_cc' on trying to build with profiling...
03:04:52 <genneth> i've forgotten what the fix is
03:05:16 <mnislaih> hmm, first try to delete all the *.o files :)
03:05:28 <mnislaih> what command line did you use ?
03:06:00 <sm> > :t (fromIntegral 1::Int) :: Int64
03:06:00 <lambdabot>  Parse error
03:06:24 <wli> > :t (fromIntegral (1::Int)) :: Int64
03:06:24 <lambdabot>  Parse error
03:06:50 <profmakx> @type (fromIntegral (1::Int)) :: Int64
03:06:52 <lambdabot> Int64 :: Int64
03:07:02 <wli> Heh, wrong command.
03:07:37 <sm> thanks.. why doesn't that work at the ghci prompt ?
03:07:47 <wli> sm: Parens.
03:07:50 <MarcWeber> hfill = (hstretch . expand) What does this actually mean (layouts wxHaskell) .. expand means use the whole availible area. And hstretch forces beeing stretchable horicontally? Does'nt expand allow stretching by filling the whole availible area as well?
03:08:06 <sm> curses!
03:08:54 <genneth> ghc --make Main.hs -o execute -prof -caf-all
03:09:22 <wli> So anyway, I've got a Haskell implementation for the first microbenchmark.
03:10:59 <dons> wli, you're competing?
03:11:11 <wli> dons: I'm cooking up my own shootout.
03:11:29 <dons> ah
03:15:25 <kowey> MarcWeber: there's an explanation in the beginning of that source file, I think
03:16:00 <kowey> the difference being that expand = 'use up the whole assigned area' and stretch = 'have a larger area than originally assigned if need be'
03:16:09 <kowey> http://wxhaskell.sourceforge.net/doc/Graphics.UI.WXCore.Layout.html
03:16:11 <lambdabot> http://tinyurl.com/2erte4
03:17:52 <MarcWebe1> kowey: I want to add Gtk as backend to phooey. The trouble is that I don't have a working wxHaskell installation right now. So I'm guessing.
03:18:39 <kowey> oh... i've found it easier to get it compiling against wxWidgets 2.6 rather than the latest one, if that helps
03:18:56 <kowey> to continue my guess: stretch without expand means it's resizable but the widgets don't budge
03:19:12 <kowey> and expand without stretch means that it takes up the whole space, but it doesn't resize
03:20:26 <MarcWeber> So if you have a square and put in a input/edit field you'll get a squared input when using expand , right?
03:20:42 <MarcWeber> I'll just try implement this layout stuff later on ;)
03:20:56 <kowey> that... sounds right :-)
03:21:48 <kowey> but i'm just interpreting the docs... haven't touched any of my own gui code in a while
03:34:52 <ejt> hi, I'm getting a horrible space leak when I compile using ghc -O2, but not if I leave out the -O2.
03:35:00 <ejt> any ideas what's going on ?
03:37:32 <dons> possibly bad fusion on some list code?
03:37:41 <dons> what happens with -O ?
03:37:53 <dons> that would be worth a bug report, if you can narrow it down
03:43:02 * genneth is embarassed at his n00b-ness
03:43:25 <genneth> how do i use a StateT s IO a ? I can't the IO statements to type check
03:43:35 <genneth> is there some magic lift that i need to use?
03:44:13 <dons> liftIO ?
03:44:21 <dons> :t liftIO
03:44:29 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
03:44:37 <ejt> dons: -O also leaks
03:44:46 <ejt> but not as badly as -O2
03:44:58 <dons> so you've something like StateT MyState IO a , genneth ?
03:45:01 <genneth> dons: thank you. I knew it was something like that
03:45:06 <dons> io :: IO a -> X a
03:45:06 <dons> io = liftIO
03:45:13 <dons> is what I usually define locally
03:45:20 <genneth> dons: yeah, an ErrorT e StateT GS IO a
03:45:24 <genneth> with some brackets
03:45:26 <dons> fun fun
03:45:49 <genneth> it does what I want, just a bit slow
03:45:58 <genneth> i cured the space leak by using strict StateT
03:46:43 <dons> good idea
03:46:54 <dons> put $! x + 1
03:46:58 <dons> is often useful
03:49:41 <genneth> I'm fairly sure that actually I just want a strict state -- there's no need to use laziness for the state updates
03:56:25 <Codex_> Is there a channel for the icfp contest somewhere?
03:57:49 <kowey> people seem to be using #oasis
03:58:56 <dons> also #haskell-icfp07
03:59:15 <dons> ?users #oasis
03:59:15 <lambdabot> Maximum users seen in #oasis: 124, currently: 124 (100.0%), active: 10 (8.1%)
04:02:03 <sm> genneth: what makes it a strict state ?
04:02:50 <genneth> sm: i don't really know; I'm guessing that it makes put strict in the first argument
04:05:02 <sm> I'm thinking I want to use state instead of recursion, next
04:06:29 <sm> aha.. fixed my profiling setup
04:06:43 <sm> but, I think it's time for sleep
04:09:30 <tibbe> anyone have a working .emacs with ghci integration on ubuntu 7.04 they could share, I lost mine and now I can't get it to work :)
04:16:49 <chr1s> dons: ping
04:18:10 <chr1s> are you aware that the plugins package on hackage is broken?
04:23:34 <dons> chr1s: yeah, its really old
04:23:38 <dons> i'm not sure who uploaded it
04:23:46 <dons> i thin itis only on their as a test
04:23:48 <dons> use the darcs repo
04:24:41 <perlMa> can haskell support unicode?
04:25:40 <hpaste>  sm pasted "emacs haskell setup" at http://hpaste.org/1808
04:25:52 <sm> tibbe
04:26:18 <tibbe> sm, thanks
04:33:33 <dons> perlMa: yeah, Char is unicode in haskell, but you'll need utf8-string library to do IO with unicode
04:33:43 <dons> look on hackage.haskell.org for the utf8 lib
04:34:24 <perlMa> dons: how to use it in haskell?
04:34:53 <dons> you want to read files?
04:35:19 <perlMa> no, display a string in Chinese
04:35:34 <perlMa> like:
04:35:39 <dons> right, you'll need to use the utf8-string library's 'print' and 'putStr' functions
04:35:42 <perlMa> f::String
04:35:55 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/utf8-string-0.1
04:35:59 <lambdabot> http://tinyurl.com/3dzrdw
04:36:06 <dons> that library lets you write out Strings as unicode
04:36:54 <perlMa> can utf8-string-0.1 install on win32?
04:36:59 <dons> yeah
04:37:10 <dons> see http://www.haskell.org/haskellwiki/How_to_install_a_Cabal_package
04:37:11 <lambdabot> Title: Cabal/How to install a Cabal package - HaskellWiki
04:37:48 <perlMa> dons: thanks
04:38:03 <dons> sure :)
04:39:51 <dons> oh andresloeh3 is competing too!
04:48:00 <mauke> @index getBounds
04:48:01 <lambdabot> bzzt
04:51:53 <chr1s> dons: thanks (sorry for the late reply)
04:54:49 <hpaste>  wli pasted "crude magma classification" at http://hpaste.org/1809
04:58:34 <wli> The magma classification problem ought to be embarrassingly parallelizable.
05:03:07 <crazy_coder> If I am evaluating a long expression (say mapping a function over an a long list ) as I move ahead, I want the previous max result seen to be stored somewhere and rest removed from the memory ( so that basically I don't run out of stack memory). is there a way to do this ?
05:03:44 <crazy_coder> I got an exception of stack overflow
05:03:46 <wli> mapAccumL?
05:03:47 <|Steve|> foldl?
05:03:59 <crazy_coder> :t mapAccumL ?
05:04:07 <lambdabot> parse error (possibly incorrect indentation)
05:04:07 <wli> @type mapAccumL
05:04:07 <crazy_coder> :t mapAccumL
05:04:10 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
05:04:11 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
05:04:52 <crazy_coder> what does mapAccumL do ?
05:05:23 <wli> It's like map, except you have a side result that gets passed along.
05:05:25 <crazy_coder> |Steve|: I can't use foldl over there
05:05:31 <wli> It's also like fold, except you're also mapping.
05:05:45 <|Steve|> crazy_coder: Oh?
05:05:46 <crazy_coder> what is x and y ?
05:05:54 <wli> x is the input list
05:05:58 <wli> y is the output list
05:06:08 <wli> acc is the side result you build up while mapping
05:06:08 <genneth> @hoogle String -> String
05:06:08 <lambdabot> Network.URI.normalizeCase :: String -> String
05:06:09 <lambdabot> Network.URI.normalizeEscape :: String -> String
05:06:09 <lambdabot> Network.URI.normalizePathSegments :: String -> String
05:06:15 <genneth> @hoogle show
05:06:15 <lambdabot> Prelude.show :: Show a => a -> String
05:06:15 <lambdabot> Text.Show :: module
05:06:15 <lambdabot> Prelude.Show :: class Show a
05:06:16 <crazy_coder> my output list doesn't get created at all
05:06:26 <wli> crazy_coder: foldr then
05:06:32 <|Steve|> I thought you wanted to throw away the output list.
05:06:46 <crazy_coder> yes I do
05:07:20 <crazy_coder> can y be a list comprehension equation ?
05:07:35 <|Steve|> Something like: foldl (\x y -> max x $ f y) minElmt list
05:08:12 <crazy_coder> Wait I'll pastebin the code
05:09:22 <hpaste>  crazy_coder pasted "no title " at http://hpaste.org/1810
05:09:54 <crazy_coder> the end result is the maximum of the list
05:10:16 <wli> Well, first off you can save things.
05:10:34 <crazy_coder> But when I try to run result, I get stack overflow exception
05:10:55 <wli> So you only really need chain 1 = 1 ; chain n | even n = n `quot` 2 | otherwise = 3*n + 1
05:11:31 <crazy_coder> yeah
05:12:00 <crazy_coder> wli: how to save things as I build up the list ?
05:12:25 <crazy_coder> 'save' is imparative language funda ;)
05:12:50 <wli> crazy_coder: As a first pass I would do chain 1 = 1 ; chain n | even n = n `quot` 2 | otherwise = 3*n + 1 ; chainLen n = Data.Maybe.fromJust $ Data.List.findIndex (==1) $ iterate chain n
05:13:11 <chr1s> hm, anyone experience with compiling lambdabot?
05:13:17 <profmakx> sure
05:13:29 <profmakx> what seems to be the problem chr1s
05:13:30 <crazy_coder> :t iterate
05:13:32 <lambdabot> forall a. (a -> a) -> a -> [a]
05:13:34 <chr1s> seen this one before?
05:13:35 <chr1s> Lib/Parser.hs:8021:4:
05:13:35 <chr1s>     Ambiguous occurrence `pling_name'
05:13:35 <chr1s>     It could refer to either `pling_name', defined at Lib/Parser.hs:8242:0
05:13:38 <chr1s>                           or `pling_name', imported from Language.Haskell.Syntax at Lib/Parser.hs:19:0-29
05:14:05 <profmakx> nope, which version of ghc and lambdabot are you using?
05:15:02 <chr1s> lambdabot 4.0, ghc 6.6
05:16:13 <chr1s> it's lambabot straight from darcs
05:16:22 <crazy_coder> wli: what does - fromJust, findIndex and iterate do ?
05:16:27 <profmakx> i didnt update my source for quite some time
05:16:48 <_roconnor> hey hey
05:16:49 <crazy_coder> Is iterate similar to map ?
05:16:59 <_roconnor> I now can see checks 01 to 25
05:17:07 <wli> crazy_coder: Take 2: chainLen' (n, len) | n == 1 = len | even n = chainLen' (n `quot` 2, len + 1) | otherwise = chainLen' (3*n+1, len + 1) ; chainLen n = chainLen' (n, 0)
05:18:01 <wli> crazy_coder: maybe it should be chainLen' (n, 1)
05:18:07 <_roconnor> damn, that self check must have been hard to write.
05:18:15 <tibbe> @source parsec
05:18:15 <lambdabot> parsec not available
05:18:19 <tibbe> gah
05:18:47 <chr1s> I'll just hide them from L.H.Syntax
05:19:20 <chr1s> looks like that's working.
05:22:28 <profmakx> well that seems to be a bug
05:23:06 <|Steve|> crazy_coder: iterate can be written using map
05:23:23 <|Steve|> iterate f x = let xs = x:map f xs; in xs
05:25:39 <|Steve|> But that's silly. iterate f x = x:iterate f (f x) is better.
05:27:23 <wli> crazy_coder: What are some typical inputs?
05:29:04 <|Steve|> @pl iter f x = x:iter f (f x)
05:29:04 <lambdabot> iter = fix ((ap (:) .) . ((.) =<<))
05:29:10 <wli> crazy_coder: Try compiling with ghc -O2 -fasm
05:29:28 <crazy_coder> actually I want to find out the max length of chain applied for all [1..999999]  (thats upto a million)
05:29:59 <hpaste>  wli annotated "no title " with "(no title)" at http://hpaste.org/1810#a1
05:30:25 <wli> crazy_coder: Well, it works when compiled with ghc -O2 -fasm but not in ghci.
05:30:48 <crazy_coder> what does -O2 - fasm do ?
05:31:04 <wli> crazy_coder: Optimizes.
05:33:00 <wli> $ /usr/bin/time ./chain $(( 10**6 - 1 ))
05:33:00 <wli> 524
05:33:00 <wli> 46.71user 0.04system 0:46.75elapsed 100%CPU (0avgtext+0avgdata 0maxresident)k
05:33:00 <wli> 0inputs+0outputs (0major+422minor)pagefaults 0swaps
05:33:03 <crazy_coder> I get errors  /usr/local/lib/ghc-6.6.1/libHSrts.a(Main.o): In function `main':
05:33:04 <crazy_coder> Main.c:(.text+0xa): undefined reference to `__stginit_ZCMain'
05:33:04 <crazy_coder> Main.c:(.text+0x24): undefined reference to `ZCMain_main_closure'
05:33:04 <crazy_coder> collect2: ld returned 1 exit status
05:33:28 <wli> crazy_coder: Try just ghc -O2 then
05:34:18 <crazy_coder> compilation IS NOT required
05:34:19 <crazy_coder> /usr/local/lib/ghc-6.6.1/libHSrts.a(Main.o): In function `main':
05:34:19 <crazy_coder> Main.c:(.text+0xa): undefined reference to `__stginit_ZCMain'
05:34:19 <crazy_coder> Main.c:(.text+0x24): undefined reference to `ZCMain_main_closure'
05:34:19 <crazy_coder> collect2: ld returned 1 exit status
05:34:28 <crazy_coder> This is what I get
05:34:34 <wli> crazy_coder: rm *.o and retry with -O2
05:34:48 <crazy_coder> ghc -O2 -fasm xyz.hs       right?
05:35:15 <crazy_coder> now did   ghc -O2 xyz.hs  , when I got above error
05:35:21 <wli> crazy_coder: rm *.o; ghc -O2 --make xyz.hs -o chain
05:36:07 <wli> crazy_coder: It really needs to be Main.hs or otherwise ghc -O2 -main-is Chain.main --make Chain.hs -o chain
05:38:01 <wli> I think there is something for this but I can't quite remember what it is.
05:38:46 <wli> Probably unfoldM or similar.
05:38:55 <crazy_coder> wli: It compiled. How to execute it ?
05:39:45 <wli> crazy_coder: ./chain 999999
05:40:25 <wli> I'm curious as to why it doesn't work in ghci.
05:41:28 <wli> There is some monadic trick encapsulating this pattern. Someone more knowledgeable than I will have to chime in.
05:42:28 <crazy_coder> wli: your chainLen does similar to what my basic lenght . chain n does in my program
05:42:58 <wli> crazy_coder: stack overflow or similar results?
05:43:05 <crazy_coder> You just keep passing the new length into the function chainLen
05:43:06 <tibbe> how to create a SourcePos of your own using parsec? It's a ADT.
05:43:16 <tibbe> oh
05:43:18 <tibbe> there it is, nm
05:45:11 <crazy_coder> wli: change to maxChainLen n = maximum $ map chainLen [1..n]  and run for ./chain 999999 and tell me if you get stack overflow ?
05:45:16 <wli> crazy_coder: Yes; the difference is it should never build up a large intermediate structure, and should also be optimized down to strict.
05:45:29 <wli> crazy_coder: Already done. I don't get stack overflow.
05:45:43 <crazy_coder> from [1..n]  <<
05:46:46 <wli> ghc -O2 -fasm -main-is Chain.main --make Chain.hs -o chain
05:46:50 <wli> That's how I compiled it.
05:47:08 <crazy_coder> maximum $ map chainLen [1..n] will force the evaluation for the entire [1..n] range and should go out of memory bounds.
05:47:33 <crazy_coder> does the compiler automatically optimize the code to avoid overflows ?
05:47:52 <wli> In some senses, yes.
05:47:57 <wli> Deforestation etc.
05:48:22 <crazy_coder> Ok Thanks
05:48:44 <crazy_coder> But your code is very elegant :) Thanks for helping
05:49:49 <wli> There are algorithms to tabulate the unique values, but they need a lot of space.
05:50:59 <crazy_coder> yeah. or we can write all values to a file . But it would increase the time required for evaluation :)
05:52:23 <wli> Basically keep a Data.Map that saves the results of chainLen; you look up n in the Data.Map to find its chainLen first.
05:52:57 <wli> If it's not there, you calculate it (possibly looking up in sub-calculations) and put it there.
05:53:25 <wli> There are other ways.
05:53:35 <wli> Or other things to do beyond just that.
05:56:37 <crazy_coder> thanks
06:02:57 <tibbe> how do I check for end of input using parsec?
06:04:10 <lightstep> eof
06:13:17 <Pupeno> Is there any "learning tool" that would show me how the code is being interpreted? that is, step by step the substitution, so I don't have to do it myself, otherwise I'll just do it myself.
06:14:00 <xerox> I think doing it yourself is a great exercise
06:14:02 <_Nucleo> http://lambda-the-ultimate.org/node/2343
06:14:04 <lambdabot> Title: Lambda Animator | Lambda the Ultimate
06:15:34 <Pupeno> xerox: yes, I think you are right. Thanks.
06:24:20 <Pupeno> (f a) 0, is the same as f a 0, right?
06:24:38 <dons> yep
06:31:28 <chessguy> @type (?f ?a) 0
06:31:30 <lambdabot> forall t t1 t2. (?f::t -> t2 -> t1, ?a::t, Num t2) => t1
06:31:41 <chessguy> type ?f ?a 0
06:31:50 <chessguy> @type ?f ?a 0
06:31:52 <lambdabot> forall t t1 t2. (?f::t -> t2 -> t1, ?a::t, Num t2) => t1
06:32:03 <|Steve|> What are ?f and ?a?
06:32:09 <chessguy> implicit parameters
06:32:31 <ihope> Is traversing x ++ [y] slower than traversing y : x?
06:32:57 <|Steve|> What do you mean by traversing?
06:33:18 <ihope> traverse (x:xs) = traverse xs; traverse [] = ()
06:33:42 <chessguy> huh?
06:33:48 <tibbe> @hoogle mcons
06:33:49 <lambdabot> Data.Generics.Basics.fromConstr :: Data a => Constr -> a
06:33:49 <lambdabot> Data.Generics.Basics.fromConstrB :: Data a => a -> Constr -> a
06:33:49 <lambdabot> Data.Generics.Basics.fromConstrM :: (Monad m, Data a) => m a -> Constr -> m a
06:34:01 <|Steve|> So traverse _ = ()
06:35:12 <Saul_> @src Data.Dynamic.fromDynamic
06:35:13 <lambdabot> Source not found. That's something I cannot allow to happen.
06:35:35 <dons> chessguy: that's an interesting trick for inferring the types of several values simultaneously
06:35:37 <ihope> |Steve|: traverse (repeat _) = _|_
06:35:44 <Saul_> @src Data.Dynamic.fromDyn
06:35:44 <lambdabot> Source not found. Take a stress pill and think things over.
06:36:53 <|Steve|> ihope: I see.
06:37:15 <ihope> traverse (replicate 1000000000 _) = (), after a while
06:37:58 <|Steve|> Well, presumably x : [y] would need to traverse x twice whereas y:x would only have to do it once.
06:38:01 <ihope> traverse (case traverse (replicate 1000000000) of () -> []) = (), after a while
06:38:42 <ihope> @src (++)
06:38:42 <lambdabot> (++) []     ys = ys
06:38:42 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
06:38:55 <|Steve|> er, I meant x ++ [y], of course.
06:39:09 <ihope> Do you know the fixities there?
06:39:57 <ihope> And is "fixity" actually a real word, or did I accidentally make it up?
06:41:02 <ihope> (++) is infixr 5, as is (:), so that's x : (xs ++ ys)
06:41:06 <|Steve|> fixity is accepted by my spell check.
06:41:40 <|Steve|> You'd hope that'd be the case otherwise [1] ++ [] would never terminate.
06:41:40 <ihope> So it's only going through once, but how fast?
06:41:59 <ihope> Oh, indeed :-)
06:42:07 * ihope GHCichecks
06:42:15 <|Steve|> How fast what?
06:42:33 <|Steve|> y : x takes constant time, x ++ [y] takes time linear in the size of x.
06:42:48 <ihope> Does traverse (x ++ [y]) go through more slowly than traverse (y : x)?
06:43:03 <|Steve|> Probably.
06:43:45 <|Steve|> Actually, it might not since it doesn't have to form x ++ [y] ever. Ugh, laziness makes this stuff hard to reason about.
06:44:21 <smooch> in gtk2hs, if I display an Image, and then load a different one, how do I update the window so it'll show the new one?
06:44:58 <ihope> On GHCi, both take the same amount of time, but (++) uses twice as much memory.
06:45:08 <|Steve|> I'm still not totally sure what the point of traverse is.
06:45:44 <ihope> Well, some functions take the same amount of time as traverse does.
06:46:12 <twb> I understand Haskell syntax and semantics pretty well, but I'm badly in need of actually programming experience.  What are some simple projects I can implement on my own in a few days / a week?  For example, for C/Unix a good project would be to implement the basics of an interactive shell.
06:46:20 <ihope> x ++ y looks like it's about as fast as traverse x.
06:47:04 <ihope> twb: well, maybe you could find something on the Haskell wiki.
06:47:11 <twb> That's where I'm looking now.
06:47:27 <|Steve|> > let traverse = return () . foldl (const 0) in traverse [1..1000]
06:47:28 <lambdabot>   add an instance declaration for (Num (b -> [t]))
06:47:52 <|Steve|> > let traverse = return () . foldl1 (const 0) in traverse [1..1000]
06:47:53 <lambdabot>   add an instance declaration for (Num (a -> a))
06:48:02 <|Steve|> Bah.
06:48:19 <ihope> > let traverse = foldl (const ()) () in traverse [1..1000]
06:48:20 <lambdabot>  Couldn't match expected type `b -> a' against inferred type `()'
06:48:32 <|Steve|> silly me, that is obviously not going to work.
06:48:35 <ihope> > let traverse = foldl (const (const ())) () in traverse [1..1000]
06:48:36 <lambdabot>  ()
06:48:41 <|Steve|> There you go.
06:48:42 <ihope> > let traverse = foldl (const (const ())) () in traverse (repeat ())
06:48:46 <lambdabot> Terminated
06:49:26 <|Steve|> > let traverse = foldl (const . const ()) () in traverse [1..1000]
06:49:27 <lambdabot>  ()
06:51:50 <JKnecht> > @version
06:51:51 <lambdabot>  Parse error
06:52:05 <xerox> dons how was it to have infix # ?
06:52:34 <xerox> infix #  (#) = B.cons
06:52:42 <xerox> parse error on )
06:53:43 <dons> B.cons sounds scary. it copies both its arguments remember.
06:53:57 <xerox> ahum
06:54:31 <xerox> copies eh...
06:54:51 <xerox> Put monad?
06:54:51 <|Steve|> ihope: Just don't use traverse = foldr (const . const()) (). =)
06:55:38 <|Steve|> > let traverse = foldr (\_ _ -> ()) in traverse [1..]
06:55:39 <lambdabot>  Couldn't match expected type `()' against inferred type `[a]'
06:55:39 <xerox> that is, I'm building up a bytestring
06:55:47 <chessguy> @type (>>=)
06:55:48 <|Steve|> > let traverse = foldr (\_ _ -> ()) () in traverse [1..]
06:55:48 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
06:55:49 <lambdabot>  ()
06:56:41 <ihope> > let traverse = foldr (const . const()) () in traverse [1..]
06:56:42 <lambdabot>  ()
06:56:46 <ihope> :-)
06:57:29 <chessguy> hm. is there some kind of relationship between (.) and (=>>) ?
06:57:43 <dons> xerox: yeah, you can use the Put monad to build a bytestring, or keep the pieces as a list, then concat them when you're done
06:57:53 <ihope> Well, (=<<) is sort of like ($).
06:58:05 <dons> chessguy: (.) and >>= in the reader monad?
06:58:09 <xerox> dons: I was using a Daa.Sequence,
06:58:13 <xerox> *Data.Sequence
06:58:23 <dons> instance Functor ((->) r) where
06:58:23 <dons> 	fmap = (.)
06:58:32 <ihope> (e -> a) -> (a -> e -> b) -> e -> b
06:58:49 <dons> fmap f xs  ==  xs >>= return . f
06:59:52 <chessguy> hmm
07:00:24 <chessguy> so >>= is to monadic actions as (.) is to functions?
07:00:47 <wli> It's special to the reader monad.
07:01:53 <ihope> instance Monad f => Functor f where fmap = liftM
07:02:18 * ihope shrugs
07:05:46 <twb> Which mathematician has the anecdote about finding the sum of 1..100 when he was a kid?
07:05:48 <twb> Gauss?
07:05:53 <xerox> y
07:05:59 <wli> Gauss
07:06:01 <twb> Yay for memory.
07:06:52 <wli> His trick was basically zipWith (+) [1..100] (reverse [1..100]) and noticing that each element of the list was 101.
07:07:43 <|Steve|> Heh, I've never heard it described in terms of Haskell before.
07:07:45 <oerjan> yes, Gauss was a brilliant Haskeller.
07:08:04 <wli> |Steve|: The list operations make it convenient to describe.
07:08:15 <|Steve|> > zipWith (+) [1..100] [100..1]
07:08:20 <wli> Or rather, it's convenient to describe in terms of Haskell list operations.
07:08:20 <lambdabot>  []
07:08:36 <chessguy> > zipWith (+) [1..100] [100,99..1]> zip@ith
07:08:37 <lambdabot>   Pattern syntax in expression context: zip@ith
07:08:44 <xerox> > zipWith (+) [1..100] [100,99..1]
07:08:46 <lambdabot>  [101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101...
07:08:47 <chessguy> > zipWith (+) [1..100] [100,99..1]
07:08:48 <lambdabot>  [101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101...
07:08:49 <dons> > let x = [1..10] in zipWith (+) x (reverse x)
07:08:50 <lambdabot>  [11,11,11,11,11,11,11,11,11,11]
07:08:54 <|Steve|> That is not at all what I was expecting.
07:09:05 <dons> > let x = [1..100] in sum $ zipWith (+) x (reverse x)
07:09:06 <lambdabot>  10100
07:09:10 <|Steve|> The [], that is.
07:09:18 <twb> You only add up to 49
07:09:25 <twb> Er, on one side
07:09:42 <wli> twb: No, you factor out 101, get 100*101, then divide by 2.
07:09:44 <chessguy> |Steve|, you have to give it some indication that you're counting down, not up
07:09:48 <mm_freak> up to 50
07:09:53 <oerjan> |Steve|: the step is 1 by default
07:10:03 <|Steve|> chessguy: Ah, makes sense. I just figured it could figure out the direction on its own.
07:10:15 <chessguy> @srs enumFromTo
07:10:15 <lambdabot> Source not found. Maybe if you used more than just two fingers...
07:10:23 <chessguy> @srs enumfromto
07:10:23 <lambdabot> Source not found. Are you on drugs?
07:10:29 <wli> > map (\xs -> (length xs, head xs) $ groupBy (==) $ zipWith (+) [1..100] (reverse [1..100])
07:10:29 <lambdabot>  Parse error
07:10:36 <|Steve|> @src enumFromByTo
07:10:36 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
07:10:36 <wli> > map (\xs -> (length xs, head xs)) $ groupBy (==) $ zipWith (+) [1..100] (reverse [1..100])
07:10:39 <lambdabot>  [(100,101)]
07:10:50 * chessguy shows lambdabot what i can do with 2 fingers 
07:11:25 <oerjan> @src Enum
07:11:25 <lambdabot> class  Enum a   where
07:11:25 <lambdabot>     succ                     :: a -> a
07:11:25 <lambdabot>     pred                     :: a -> a
07:11:25 <lambdabot>     toEnum                   :: Int -> a
07:11:25 <lambdabot>     fromEnum                 :: a -> Int
07:11:27 <lambdabot> [3 @more lines]
07:11:30 <oerjan> @more
07:11:31 <lambdabot>     enumFrom                 :: a -> [a]
07:11:31 <lambdabot>     enumFromThen, enumFromTo :: a -> a -> [a]
07:11:33 <lambdabot>     enumFromThenTo           :: a -> a -> a -> [a]
07:11:41 <mm_freak> > enumFromThenTo 100 99 1
07:11:42 <lambdabot>  [100,99,98,97,96,95,94,93,92,91,90,89,88,87,86,85,84,83,82,81,80,79,78,77,76...
07:12:02 <mm_freak> first 100, then 99, and finally 1 =)
07:12:03 <wli> There should be a counting version of group floating somewhere around the libs.
07:12:21 <mm_freak> > enumFromThenTo 10 9.75 1
07:12:23 <lambdabot>  [10.0,9.75,9.5,9.25,9.0,8.75,8.5,8.25,8.0,7.75,7.5,7.25,7.0,6.75,6.5,6.25,6....
07:12:36 <kpreid> @src zipWith
07:12:36 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
07:12:36 <lambdabot> zipWith _ _      _      = []
07:12:40 <|Steve|> Ah, Then, not By.
07:12:42 <kpreid> zipWith == ((. zip) . (.) . map . uncurry)
07:13:36 <wli> > let sumToN n = (`div` 2) $ sum $ map (\xs -> length xs * head xs) $ groupBy (==) $ zipWith (+) [1..n] (reverse [1..n]) in sumToN 100
07:13:38 <lambdabot>  5050
07:14:06 <wli> Of course, at this point one should mention Faulhaber's formulae etc.
07:14:56 <|Steve|> Yikes.
07:15:23 <|Steve|> > let sumToN n = n*(n+1) `div` 2 in sumToN 100
07:15:25 <lambdabot>  5050
07:15:41 <wli> > let sumToN n = (`div` 2) $ head $ map (\xs -> length xs * head xs) $ groupBy (==) $ zipWith (+) [1..n] (reverse [1..n]) in sumToN 100
07:15:42 <mm_freak> let lst = [1..100] in (sum . take 50) (zipWith (+) lst (reverse lst))
07:15:42 <lambdabot>  5050
07:15:45 <mm_freak> > let lst = [1..100] in (sum . take 50) (zipWith (+) lst (reverse lst))
07:15:46 <lambdabot>  5050
07:16:16 <ddarius> > 5050
07:16:17 <lambdabot>  5050
07:16:28 <mm_freak> there should be a GHCi-interface for irssi
07:16:37 <|Steve|> > let sumToN = sum . enumFromTo 1 in sumToN 100
07:16:38 <lambdabot>  5050
07:18:50 <mm_freak> > let sumToN n = (n+1)*n `div` 2 in sumToN 100
07:18:51 <lambdabot>  5050
07:19:25 <mm_freak> > let sumToN n = if n == 100 then 5050 else undefined in sumToN 100
07:19:26 <lambdabot>  5050
07:19:43 <|Steve|> heh
07:20:07 <Pupeno> I am trying to grok monads, but I'm still failing. I am playing with my own state monad, and I can't understand why it has to be a function: newtype State st a = State (st -> (st, a)).
07:20:42 <wli> is there a better and/or more convenient and/or more efficient way to do splits [] = [([],[])] ; splits (x:xs) = ([], x:xs) : map (\(ys, zs) -> (x:ys, zs)) (splits xs) ?
07:22:05 <crazy_coder> hi
07:22:10 <MarcWeber> How the hell can this happen? Can't unregister because not found but describe works? Is there an implementation missing?
07:22:12 <wli> Pupeno: It can be something that essentially represents a function vs. a function per se.
07:22:37 <oerjan> Pupeno: each monadic element must be able to be chained with others using >>=.  So it must have a way to take the state from the previous action and a way to give it to the next.
07:22:58 <oerjan> plus the actual return value.
07:23:26 <crazy_coder> if i have a quadraple (how is it spelled?)  say x= (Char,Int,String,Maybe Int)  and if I want to access the third element - String, how do I do it ?
07:23:58 <crazy_coder> fst , snd , what next ?
07:23:59 <wli> Data.Map arg ret basically acts like a function, so you can shoehorn it in there.
07:24:09 <|Steve|> third (_,_,x,_) = x
07:24:18 <crazy_coder> fourth ?
07:24:20 <dons> crazy_coder: you have to pattern match
07:24:27 <dons> or write functions for the tuple
07:24:46 <crazy_coder> oh ok
07:24:47 <dons> fourth :: (a,b,c,d) -> d
07:24:48 <crazy_coder> Thanks
07:24:53 <dons> ?djinn (a,b,c,d) -> d
07:24:54 <lambdabot> f (_, _, _, a) = a
07:24:58 <dons> can do it for you :)
07:25:05 <crazy_coder> :)
07:25:21 <dons> ?djinn (a,b,c,d) -> (d,a)
07:25:21 <lambdabot> f (a, _, _, b) = (b, a)
07:25:26 <dons> types rock
07:26:22 <oerjan> crazy_coder: also, fst and snd only work for 2-tuples
07:26:35 <wli> Also, is there an easier/more convenient/more efficient way to do bag xs = [(head y, length y) | y <- group $ sort xs] ?
07:26:40 <dons> :t fst  -- as you can see by the type
07:26:40 <ddarius> You can encode n-tuples as nested 2-tuples
07:26:45 <lambdabot> forall a b. (a, b) -> a
07:27:06 <crazy_coder> is there anything as first , second then ?
07:27:09 <|Steve|> @pl third (_,_,x,_) = x
07:27:09 <lambdabot> (line 1, column 8):
07:27:09 <lambdabot> unexpected "_"
07:27:09 <lambdabot> expecting lambda abstraction or expression
07:27:20 <dons> wli, maybe something with Set ?
07:27:25 <|Steve|> @pl third (a,b,c,d) = c
07:27:25 <lambdabot> (line 1, column 17):
07:27:25 <wli> uncurry $ flip (,) is handy, too.
07:27:25 <lambdabot> unexpected "="
07:27:25 <lambdabot> expecting variable, "(", operator or end of input
07:27:32 <oerjan> wli: zip (inits l) (tails l) but i don't know which is most efficient
07:27:39 <dons> > S.fromList [1,2,1,2,1,1,12,3,4,7,1]
07:27:40 <lambdabot>   Not in scope: `S.fromList'
07:27:52 <dons> > Data.Set.fromList [1,2,1,2,1,1,12,3,4,7,1]
07:27:53 <lambdabot>  fromList [1,2,3,4,7,12]
07:28:16 <wli> dons: Hmm, it loses the multiplicity counts.
07:28:20 <dons> or Map
07:28:21 <ddarius> type State s a = forall t.ReaderT (STRef t s) (ST t) a
07:28:24 <dons> a Map of keys to counts
07:28:28 <dons> then flatten
07:29:18 <wli> Doing it.
07:29:58 <|Steve|> Why doesn't @pl work with triples?
07:30:17 <ddarius> It's parser doesn't parse n-tuples with n > 2
07:30:25 <ddarius> @pl (1,3,6)
07:30:26 <lambdabot> (1, 3, 6)
07:30:31 <|Steve|> That's too bad.
07:30:31 <ddarius> At least not in patterns.
07:30:38 <ddarius> @pl \(a,b)-> b
07:30:38 <lambdabot> snd
07:30:46 <ddarius> @pl \(a,b,c) -> c
07:30:46 <lambdabot> (line 1, column 6):
07:30:46 <lambdabot> unexpected ","
07:30:46 <lambdabot> expecting letter or digit, operator or ")"
07:30:46 <lambdabot> ambiguous use of a non associative operator
07:31:12 <|Steve|> @pl \(a,(b,c)) -> c
07:31:13 <lambdabot> snd . snd
07:31:40 <ddarius> Of course, there's nothing @pl could do with my last example anyway.
07:31:51 <wli> bag xs = Data.Map.toList $ foldr (\x m -> insertWith (+) x 1 m) Data.Map.empty xs
07:31:54 <|Steve|> How would one make \(a,b,c) -> c point-free anyway?
07:32:18 <oerjan> you cannot.
07:32:34 <|Steve|> That's too bad.
07:33:31 <wli> An ML-like #3 operator could be handy, but it would take compiler magic, never mind type system nastiness.
07:33:37 <ddarius> @users
07:33:37 <lambdabot> Maximum users seen in #haskell: 362, currently: 361 (99.7%), active: 18 (5.0%)
07:33:54 <ddarius> 361?
07:33:59 <dons> wow
07:34:00 <SamB> wli: not much compiler magic *or* nastiness
07:34:04 <SamB> actually
07:34:19 <wli> SamB: I must not be aware of the tricks to implementing such projections.
07:34:20 <SamB> not if #3 was a name
07:34:37 <SamB> see, it would be a family of typeclasses
07:34:38 <dons> icfp contest gets everyone in irc?
07:34:42 <dons> ?users #oasis
07:34:43 <lambdabot> Maximum users seen in #oasis: 136, currently: 136 (100.0%), active: 14 (10.3%)
07:34:50 <Philippa> not everyone
07:35:06 <wli> SamB: Well, #3 is a family, (t1,t2,t3) -> t3, (t1,t2,t3,t4) -> t4, etc.
07:35:08 <Syzygy-> I ended up not doing much for the contest. Currently waiting for tonights party to begin.
07:35:23 <wli> SamB: Ugh, t3 at the end.
07:35:27 <SamB> isn't that second one #4?
07:35:54 <wli> SamB: Yes. Anyhow, maybe it could work with an infinite predefined family of typeclasses.
07:35:57 <|Steve|> How could one do that in Haskell? What can have type (a,b,c) or (a,b,c,d)?
07:36:13 <SamB> wli: it wouldn't need to actually be infinite
07:36:23 <SamB> it could just be up to ten or something
07:36:27 <dons> |Steve|: something in a typeclass :) but its a bit useless to do
07:36:31 <SamB> maybe twenty
07:36:32 <wli> SamB: Just generated on the fly to be as large as the program needs, sure.
07:36:46 <SamB> or however big the tuples get, anyway
07:36:53 <hpaste>  crazy_coder pasted "Something wrong in the do block " at http://hpaste.org/1811
07:37:03 <wli> I think arbitrary tuple sizes are supported.
07:37:07 <SamB> by what?
07:37:16 <wli> SamB: ghc
07:37:21 <crazy_coder> Can anyone have a look at my paste
07:37:26 <SamB> @source Data.Tuple
07:37:27 <lambdabot> http://darcs.haskell.org/packages/base/Data/Tuple.hs
07:37:31 <SamB> wli: read that maybe?
07:37:34 <wli> SamB: If not, then no need to bother with more typeclasses than needed for tuples.
07:38:04 <ddarius> Arbitrary tuple sizes should be supported, but I don't think they are all instances of the apropriate classes.
07:38:06 <SamB> wli: sure, if we had infinite tuples then maybe infinite classes would be good too
07:38:15 <SamB> ddarius: indeed
07:38:18 <dons> gee, 362 users. we could do *anything* now!
07:38:21 <SamB> does the report say that they should be?
07:38:23 <kpreid> crazy_coder: you have mixed tabs and spaces
07:38:29 <wli> SamB: Ugh, that's gross.
07:38:44 <SamB> wli: which part?
07:38:48 <ddarius> The Report says specifically that they need not be if I remember correctly.
07:39:10 <crazy_coder> kpreid:  I am working on it. Using emacs. Have to fix it.
07:39:18 <wli> SamB: The huge lists of specific per-tuplesize declarations.
07:39:18 <SamB> The following functions are defined for pairs (2-tuples): fst, snd, curry, and uncurry. Similar functions are not predefined for larger tuples.
07:39:23 <SamB> I don't like this bit ;-)
07:39:36 <SamB> There is no upper bound on the size of a tuple, but some Haskell implementations may restrict the size of tuples, and limit the instances associated with larger tuples. However, every Haskell implementation must support tuples up to size 15, together with the instances for Eq, Ord, Bounded, Read, and Show. The Prelude and libraries define tuple functions such as zip for tuples up to a size of 7.
07:39:47 <oerjan> crazy_coder: i _think_ your main block is to little indented
07:39:48 <SamB> this bit I don't mind
07:40:19 <crazy_coder> oerjan: is it why I am getting an error ?
07:40:32 <SamB> though I think it's not true
07:40:48 <|Steve|> That's horrible. (re: Data.Tuple.hs)
07:41:35 <SamB> @hoogle zipM
07:41:35 <lambdabot> Monad.mapAndUnzipM :: Monad a => (b -> a (c, d)) -> [b] -> a ([c], [d])
07:41:36 <lambdabot> Control.Monad.mapAndUnzipM :: Monad m => (a -> m (b, c)) -> [a] -> m ([b], [c])
07:41:37 <wli> You can't shove everything into the compiler, but this is cleaner done as compiler magic.
07:41:54 <SamB> wli: well, you clearly need some degree of magic
07:42:11 <oerjan> crazy_coder: i think so. when you give errors, please include line numbers.
07:42:19 <SamB> and you need to steal some syntax
07:42:20 <ddarius> A little unsafeCoerce is all you need.
07:42:21 <wli> SamB: Yeah, the syntax isn't defineable otherwise.
07:42:23 <crazy_coder> line number 22
07:42:32 <oerjan> (and, of course, always include the error :) )
07:42:37 <oerjan> oh
07:42:41 <SamB> wli: the syntax and the magic are not terribly closely related are they?
07:42:56 <crazy_coder> oerjan: line number 22 : 13 to be precise
07:43:38 <SamB> hmm.
07:43:43 * wli wishes the type signature of length were length :: Integral i => [t] -> i
07:43:53 <ddarius> :t genericLength
07:43:54 <lambdabot> forall b i. (Num i) => [b] -> i
07:43:56 <oerjan> crazy_coder: looks like a tab/space problem.  remember that tab = 8 spaces (and avoid tabs like the plague)
07:44:02 <SamB> you know, there'd be a big fight about one-based or zero-based indexes for that syntax
07:44:12 <wli> ddarius: Doh.
07:44:14 <SamB> I suppose you could use fst and snd as an argument for 1-based
07:44:21 <crazy_coder> oerjan: earlier I didn't have the data <- ... stuff. I had no findData function defined. Everthing was working fine
07:44:42 <crazy_coder> oerjan: does it have to do anything with returning a tuple of that sort
07:44:45 <oerjan> (hpaste doesn't show tabs with that width in my browser, so it makes it akward for me to check)
07:45:18 <oerjan> now wait a moment.
07:45:33 <oerjan> the two lets are indented differently.
07:46:06 <crazy_coder> oerjan: Looks fine here
07:46:32 <crazy_coder> the best thing would me to remove all tabs and use spaces instead
07:46:45 <crazy_coder> oerjan: I'll try that and let you know if it works
07:46:57 <|Steve|> Nothing wrong with using tabs for indentation as long as you are consistent.
07:46:59 <oerjan> yep.
07:47:31 <oerjan> although the second "let" is a bit redundant, but harmless.  however i think indentation is the real problem.
07:48:09 <oerjan> |Steve|: there would be nothing wrong if hpaste and my browser showed it correctly to me.
07:48:24 <ekidd> Boy, writing a parser in C++ is really reminding me how much nicer parser combinators are.
07:48:43 <oerjan> oh _wait_
07:48:44 <dons> poor ekidd
07:49:06 <oerjan> crazy_coder: i finally noted the syntax coloring.  "data" is a reserved keyword.
07:49:15 <wli> It's slightly more awkward to translate bagBy c xs = [(head y, genericLength y) | y <- groupBy (\x y -> x `c` y == EQ) $ sortBy c xs] into something using Data.Map (I've honestly not quite figured it out).
07:49:25 <crazy_coder> oerjan: yeah thanks
07:49:28 <crazy_coder> I thought so
07:49:36 <crazy_coder> But the error was something else
07:49:44 <crazy_coder> So i assumed it might be ok
07:49:45 <crazy_coder> Thanks
07:49:46 <crazy_coder> :)
07:49:50 <mrd> ekidd: there are parsing "combinators" for c++
07:49:55 <mrd> sorta. the boost library.
07:50:02 <ekidd> mrd: Interesting!
07:50:08 <DukeDave> Can someone explain to me a practical use of the prelude function const?  It seems a little redundant :|
07:50:22 <mrd> it reminded me of parsec with explicit type annotations. and probably other pitfalls.
07:50:25 <dons> :t foldr
07:50:27 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
07:50:38 <wli> DukeDave: main = doRealWork `catch` (const $ return ())
07:50:42 <dons> > foldr (const (+1) 0 "haskell"
07:50:42 <lambdabot>  Parse error
07:50:46 <dons> > foldr (const (+1)) 0 "haskell"
07:50:48 <lambdabot>  7
07:51:01 <dons> its all about ignoring data, DukeDave
07:51:14 <dons> stuff you don't use, in a pointfree style.
07:51:17 <mrd> (const ...) vs (\_ -> ...) same length =)
07:52:03 <dons> > map (const 'X') "haskell is bad"
07:52:04 <lambdabot>  "XXXXXXXXXXXXXX"
07:52:08 <DukeDave> Ah yes I remember reading 'try to use pointfree'
07:52:12 <DukeDave> * style
07:52:21 <oerjan> crazy_coder: what happens is that whenever the compiler finds an illegal token, it _first_ tries to close all open blocks per the parse-error rule.  So it notices that the do block is unfinished before it notices that the "data" is misplaced.
07:52:21 <dons> ?unpl map (const 'X') "haskell is bad"
07:52:21 <lambdabot> map (\ _ -> 'X') "haskell is bad"
07:52:22 <mrd> unless it's point-less
07:52:40 <dons> ?users
07:52:40 <lambdabot> Maximum users seen in #haskell: 365, currently: 365 (100.0%), active: 20 (5.5%)
07:52:44 <dons> cool stuff
07:52:49 <mrd> dons: not working on an entry this year?
07:53:00 <dons> nah
07:53:13 <dons> giving friendly distract^h^h^hadvice though
07:53:14 <SamB> hmm
07:53:25 <SamB> can I make clases like this somehow?
07:53:36 <SamB> class Field1 t f1 => Field2 t f | t -> f where
07:53:49 <crazy_coder> oerjan: oh ok Thanks. Its working as desired.
07:54:14 <bos> dons: how goes ICFP contest?
07:54:20 <SamB> I guess not
07:54:22 <wli> main = doRealWork `catch` const System.Exit.exitFailure
07:55:01 <mrd> this "doRealWork" function ... do you have an implementation I can see?
07:55:06 <mrd> @src doRealWork
07:55:06 <lambdabot> Source not found. My mind is going. I can feel it.
07:55:11 <bos> are there many haskellers taking part this year?
07:55:15 <oerjan> i guess the parser could try to be more clever when there is no chance of the next token actually fitting.
07:55:17 <wli> mrd: heh, no. It's an example of using const.
07:55:23 <akamaus> hello, everyone. Let me ask a quick question. ByteString.append is O(n). What's n? Is it a length of the first argument? Or of the second one? Or sum length  maybe.
07:55:40 <dons> bos, seems to be a fair few teams
07:55:44 <mrd> akamaus: perhaps of the minimal one?
07:55:47 <bos> akamaus: the first
07:55:52 <bos> and the second
07:55:58 <wli> mrd: doRealWork = putStrLn "Hello, world!" -- if you must
07:56:03 <mrd> i guess it needs to allocate a whole new array
07:56:09 <bos> lazy ByteString append has different properties that are a bit harder to explain
07:56:28 <akamaus> bos: i need a strict one
07:56:37 <bos> then it depends on the lengths of both
07:56:50 <dons> it copies the string arguments, akamaus.
07:56:59 <dons> so its n, where n is the number of elements
07:57:00 <akamaus> both of them?
07:57:11 <dons> yep, it allocates an array for the result, and copies them both in
07:57:14 <bos> yes, a ByteString is an array internally
07:57:22 <mrd> a foreign ptr array!
07:57:24 <bos> @quote stereo
07:57:25 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
07:57:30 <mrd> beep cale =)
07:57:37 <akamaus> ok. thanks.
07:58:14 <bos> akamaus: it costs about the same as strcat in C
07:58:45 <akamaus> So what is the best way to concatenate several bytestrings? Say 100 or so?
07:58:51 <akamaus> bos: got it
07:58:55 <mrd> @hoogle concat
07:58:55 <lambdabot> Prelude.concat :: [[a]] -> [a]
07:58:55 <lambdabot> Prelude.concatMap :: (a -> [b]) -> [a] -> [b]
07:58:55 <lambdabot> Data.PackedString.concatPS :: [PackedString] -> PackedString
07:59:23 <dons> yeah, 'concat' is more efficient there
07:59:25 <mrd> there is a concat in bytestring
07:59:30 <dons> or use lazy bytestrings, which avoid copying at all
08:00:19 <akamaus> thanks a lot for your suggestions
08:01:09 * wli goes back to monadic exercises.
08:02:41 <mrd> be sure to stretch first
08:02:58 <dons> don't stretch, *fold* !
08:03:23 <wli> Something's stretching to the breaking point here, though I'm not sure if I've got a mind left for that to be it.
08:03:35 <SamB> hmm.
08:04:05 <SamB> Data.Derive.Guess assumes your class makes sense for multi-constructor datatypes
08:04:08 <SamB> er/.
08:04:17 <SamB> Data.DeriveGuess
08:04:29 <dons> ?users
08:04:29 <lambdabot> Maximum users seen in #haskell: 366, currently: 366 (100.0%), active: 20 (5.5%)
08:04:55 <SamB> wli: do you think that field access makes sense for multi-constructor datatypes?
08:04:58 <dons> why is everyone here?
08:05:02 <dons> did it finally happen?
08:05:13 <dons> did they legislate in favour of type systems?
08:05:24 <SamB> no silly
08:05:47 <oerjan> SamB: the report allows it
08:05:57 <wli> SamB: Sure, though there are caveats.
08:06:05 <SamB> oerjan: I mean ordinal field access
08:06:13 <mrd> i'm here because i'm lazy
08:06:17 <oerjan> what's an ordinal field?
08:06:25 <mrd> too lazy to get up
08:06:27 <SamB> well, say...
08:06:32 <SamB> class Field1 t f | t -> f where
08:06:32 <SamB>     field1   :: t -> f
08:06:32 <SamB>     field1_u :: (f -> f) -> (t -> t)
08:06:32 <SamB>     field1_s :: f -> (t -> t)
08:06:32 <SamB>     field1_s f = field1_u (const f)
08:06:40 <SamB> class Field1 t f1 => Field2 t f1 f | t -> f where
08:06:40 <SamB>     field2   :: t -> f
08:06:40 <SamB>     field2_u :: (f -> f) -> (t -> t)
08:06:42 <SamB>     field2_s :: f -> (t -> t)
08:06:42 <wli> oerjan: #1, #2, #3, a la ML.
08:06:44 <SamB>     field2_s f = field2_u (const f)
08:06:57 <chessguy> how do i do a default case? is it _ -> ... ?
08:07:04 <wli> chessguy: Yeah.
08:07:26 <oerjan> well, if the constructors don't have the same type there, clearly it doesn't make sense
08:07:38 <oerjan> so, probably not.
08:08:11 <SamB> oerjan: fortunately DataName's constructors all have the same field types
08:09:03 <oerjan> otoh if they do have the same type, wouldn't you give them the same name for convenience?
08:09:33 <oerjan> in which case ordinal access seems useless.
08:10:22 * wli tries to figure out how to fairly queue things in a nondeterminism monad's backing set structure.
08:10:25 <ddarius> @users
08:10:25 <lambdabot> Maximum users seen in #haskell: 368, currently: 368 (100.0%), active: 17 (4.6%)
08:10:38 * ddarius rigs up a capo again.
08:11:46 <wli> It gets particularly hairy when infinite lists are involved.
08:12:18 <oerjan> wli: was it you who did that stripes thing yesterday?
08:12:30 <oerjan> it might seem relevant.
08:12:34 <wli> oerjan: I don't think so. What was that stripes thing?
08:13:27 <chessguy> woot! it compiled!
08:13:27 <oerjan> essentially a function to turn a list of lists into a list, where the lists could be infinite in both directions.
08:13:55 <oerjan> by following diagonals.
08:13:59 <chessguy> of course my list of things at the bottom of my code in the form 'foo :: SomeType; foo = undefined' is growing :)
08:14:03 <wli> oerjan: Wasn't me, though I've done such things for non-bidirectional lists.
08:15:10 <wli> oerjan: I've not dealt with bidirectional lists or otherwise I'd long since have done something of the sort.
08:15:40 <oerjan> by "both directions" i meant "both levels", actually :)
08:15:50 <wli> oerjan: What I did on that front was http://holomorphy.com/~wli/Tuple.hs
08:15:53 <oerjan> they were still ordinary lists of lists
08:16:13 <wli> oerjan: And http://holomorphy.com/~wli/Cantor.hs
08:16:18 <oerjan> as in, both x and y direction.
08:17:18 <wli> oerjan: I've not quite managed to get Tuple.hs index-free.
08:18:04 <wli> oerjan: What they did sounds a lot like Cantor.hs
08:19:11 <oerjan> yeah, it was not a new idea, what was special was they wanted it to work if some of the lists were finite as well
08:19:38 <wli> oerjan: Cantor.hs handles finiteness.
08:20:00 <wli> oerjan: Though the fixup I did for that is relatively new.
08:20:10 <wli> $ ls -ld ~/public_html/Cantor.hs
08:20:10 <wli> -rw-r--r-- 2 wli wli 416 Jul 14 07:56 /home/wli/public_html/Cantor.hs
08:21:52 <wli> oerjan: Tuple.hs calculates indices for the n-dimensional case (lists nested n times) but I don't have a grip on the type trickery necessary to make it work for n nested lists.
08:23:21 <wli> oerjan: It also looks relatively difficult to do in any general way given the way the index calculations work.
08:23:39 <oerjan> right, what if the final elements happen to be lists too...
08:24:30 <dons> ?users
08:24:30 <lambdabot> Maximum users seen in #haskell: 368, currently: 363 (98.6%), active: 15 (4.1%)
08:24:41 <wli> oerjan: Well, the enumeration is supposed to be graded revlex in the indices or some such.
08:24:49 <oerjan> maybe some kind of combinator that constructs the (n+1) case from the n one?
08:25:45 <wli> oerjan: [cantorTuple n 3 | n <- [0..10]] == [[0,0,0],[1,0,0],[0,1,0],[0,0,1],[2,0,0],[1,1,0],[1,0,1],[0,2,0],[0,1,1],[0,0,2],[3,0,0]]
08:26:08 <wli> oerjan: [cantorTuple n 4 | n <- [0..10]] == [[0,0,0,0],[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1],[2,0,0,0],[1,1,0,0],[1,0,1,0],[1,0,0,1],[0,2,0,0],[0,1,1,0]]
08:28:10 <akamaus> another question. Why does Data.ByteString.Lazy.Char8 not export findSubstring? What can i use instead of it?
08:28:26 <dons> akamaus: its not implemented for lazy bytestrings. but you can use isPrefixOf in a loop
08:28:46 <dons> akamaus: http://hpaste.org/1803#a1
08:28:50 <wli> oerjan: So a quadruply-nested list qnl would be enumerated as [let [i,j,k,l] = cantorTuple n 4 in qnl !! i !! j !! k !! l | n <- [0..]]
08:29:32 <wli> oerjan: Quintuply-nested as [let [i,j,k,l,m] = cantorTuple n 5 in qnl !! i !! j !! k !! l !! m | n <- [0..]]
08:29:44 <oerjan> i've got that.
08:30:41 <wli> It'd be foldr (flip (!!)) if it were even type-generalizable.
08:30:42 <akamaus> dons: will it be slower than findSubstring on strict bytestring?
08:31:05 <oerjan> maybe with overlapping instances you could make enumerate 5 l work
08:31:17 <wli> oerjan: I think it needs a printf-like trick.
08:31:45 <oerjan> if you want to allow the final elements to be lists, you would need to pass the depth explicitly.
08:33:23 <wli> I'm trying to remember how the trick works. ISTR you make a typeclass for all the admissible types, and then somehow inductively define the methods.
08:34:22 <oerjan> @source Text.Printf
08:34:23 <lambdabot> http://darcs.haskell.org/packages/base/Text/Printf.hs
08:35:24 <dons> akamaus: yep
08:35:36 <dons> actually, findSubstring on strict bytestrings is a bit slow
08:35:46 <dons> use the version in that paste instead, or write a proper KMP version
08:35:56 <oerjan> instance Enumerable a => Enumerable [a] where ...
08:36:35 <wli> I think it's a bit different.
08:36:48 <oerjan> i mean you need something like that.
08:37:05 <akamaus> dons: KMP?
08:37:26 <oerjan> the Printf case does something even more tricky with a -> b
08:38:52 <oerjan> if you have overlapping instances, you might be able to make the base case just instance Enumerable a where ...
08:39:19 <ddarius> Knuth-Morris-Pratt
08:39:59 <wli> I need to count the nesting depth somehow.
08:40:09 <oerjan> you could pass it explicitly.
08:40:27 <oerjan> you would have to, if you wanted to allow final list elements.
08:40:28 <wli> I basically need type-level integers.
08:40:58 <oerjan> if you don't need final list elements, then type-level might do.
08:41:38 <oerjan> then you just need to include a depth :: Int method, i think.
08:41:45 <wli> Handling the case where some lists are finite is a secondary concern.
08:42:00 <SamB> hmm. what's the preffered way of distributing Derive derivings for a library?
08:42:11 <oerjan> you don't actually need type-level integers, i think
08:42:30 <wli> oerjan: I'm getting lost here.
08:42:36 <oerjan> oh wait.
08:42:56 <oerjan> it needs to be depth :: a -> Int
08:43:36 <oerjan> for the base case, depth _ = 0
08:44:06 <oerjan> for [a], depth l = depth (head l), where the head is never actually evaluated, just for type
08:44:09 <wli> The list unwrapping part is too hard.
08:44:26 <oerjan> *+1, of coure
08:44:29 <oerjan> *course
08:45:42 <wli> I have depth. Now I have to get the tupling function.
08:46:30 <wli> That's where types truly fail me.
08:46:46 <oerjan> cantorTupleL i l = cantorTuple i (depth l)
08:47:22 <oerjan> you need to have the list in the arguments, alas
08:47:26 <wli> That doesn't mention t
08:47:54 <oerjan> what is t?
08:47:56 <wli> class TupleS t where depth :: t -> Integer ; instance TupleS t => TupleS [t] where depth x = depth (head x) + 1
08:48:38 <wli> So what's the type of an enumeration function?
08:50:46 <oerjan> argh.
08:50:53 <EvilTerran> > loop [False ..]
08:50:54 <lambdabot>  ghc-6.6: panic! (the 'impossible' happened)
08:50:54 <lambdabot>   (GHC version 6.6 for i386-unkn...
08:50:58 <EvilTerran> !
08:51:03 <oerjan> i wasn't considering the tuple type.
08:51:10 <EvilTerran> ?type loop
08:51:12 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowLoop a) => a (b, d) (c, d) -> a b c
08:51:18 <oerjan> just something to work on nested lists.
08:51:21 <EvilTerran> hm. that's not the function i was looking for.
08:51:34 <EvilTerran> > cycle [False ..]
08:51:35 <blackdog> your jedi mind tricks won't work here.
08:51:36 <lambdabot>  [False,True,False,True,False,True,False,True,False,True,False,True,False,Tru...
08:51:39 <oerjan> These are not the functions you are looking for.
08:51:39 <pejo> dons, going to continue reseaerch on bytestring/stream fusion/something else after defense is done?
08:51:50 <oerjan> blackdog: darn beat me to it
08:51:55 <blackdog> oerjan: High Five!
08:52:10 <EvilTerran> "panic! (the 'impossible' happened)"? have i triggered a bug or something?
08:52:45 <EvilTerran> > iterate not False -- i'll stick to this one in future. safer. ;]
08:52:46 <lambdabot>  [False,True,False,True,False,True,False,True,False,True,False,True,False,Tru...
08:52:50 <wli> oerjan: I can't figure out how to pass the argument in.
08:53:21 <oerjan> > loop
08:53:22 <lambdabot>  Add a type signature
08:54:44 <oerjan> wli: i think i'm out of my depth.
08:55:20 <wli> class TupleS t where { depth :: t -> Integer ; tuple :: t -> Integer } ; instance TupleS (Integer -> Integer -> Integer) where { depth = 2 ; tuple i j = cantorTuple 2 i j } ; instance TupleS t => TupleS (Integer -> t) where { depth x = depth (x undefined) + 1 ; tuple = ??? }
08:56:10 <ddarius> EvilTerran: The cycle version is better.
08:56:23 <wli> tuple i j = cantorTuple 2 [i, j] rather
08:56:24 <EvilTerran> why's that? memory?
08:56:34 <EvilTerran> @src cycle
08:56:35 <lambdabot> cycle [] = undefined
08:56:35 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
08:56:39 <ddarius> EvilTerran: Yes.  It takes only two cons cells.
08:56:50 <desp> sigh
08:57:05 <desp> can someone help me understand this function from the Data.Binary library?
08:57:14 <EvilTerran> it's also clearer what i mean, i guess. even more so if i say cycle [False,True]
08:57:16 <hpaste>  desp pasted "toLazyByteString" at http://hpaste.org/1812
08:57:19 <wli> oerjan: I think if we can get t -> [Integer] maybe we're there.
08:57:36 <desp> I completely don't get it
08:58:51 <hpaste>  desp annotated "toLazyByteString" with "complete Data.Binary.Builder source" at http://hpaste.org/1812#a1
08:59:00 <oerjan> My brain doesn't manage to run the whole distance these days :(
08:59:07 <desp> ugh, truncated
08:59:41 <desp> anyone?
09:06:05 <wli> If I can get a class that takes an arbitrary number of integers and dumps them into a list I'm mostly done, apart from counting the number of list elements.
09:06:18 <ddarius> Hmm, anyone have access to old volumes of "Lecture Notes in Mathematics"?
09:07:51 <SamB> @doc Language.Haskell.TH
09:07:51 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/template-haskell/Language-Haskell-TH.html
09:08:13 <SamB> @doc Language.Haskell.TH.All
09:08:14 <lambdabot> Language.Haskell.TH.All not available
09:09:18 <oerjan> wli: now that does sound like the Printf trick.
09:09:51 <oerjan> if you mean the function takes the integers as consecutive arguments.
09:10:02 <wli> oerjan: yes
09:10:24 <SamB> @hoogle a -> Language.Haskell.TH.Syntax.Name
09:10:24 <lambdabot> No matches, try a more general search
09:11:23 <wli> oerjan: Crap it's backward.
09:11:44 <oerjan> ?
09:11:46 <wli> oerjan: I need a list of integers and to do [i,j,k,...] xs !! !! j !! k !! ...
09:13:07 <wli> This is mind-bending.
09:14:28 <xerox> ?type ((map (flip (!!)) ?indices) `ap`)
09:14:30 <lambdabot> forall a. (?indices::[Int]) => [[a]] -> [a]
09:15:06 <xerox> ?type ((map (flip (!!)) ?indices) `ap`) . return
09:15:08 <lambdabot> forall a. (?indices::[Int]) => [a] -> [a]
09:15:34 <wli> xerox: foldr (flip (!!)) doesn't quite work that way...
09:15:43 <oerjan> define a class method (!!!) :: a -> ilist -> ... hm, the final element type needs to be included in the class
09:15:55 <oerjan> MPTC :(
09:16:02 <wli> MPTC?
09:16:15 <oerjan> multiparameter type class
09:16:27 <wli> I don't object to them, I just can't figure it out.
09:16:58 <oerjan> the chance that the final code will be rejected for some obscure reason increases exponentially :D
09:17:36 <oerjan> like, what overlaps are allowed anyway?
09:17:48 <wli> Well, at each level of depth we basically want f n = (!!n) . f or some such
09:17:53 <xerox> > map (flip (!!)) [2,1,3,0] `ap` return "barf"
09:17:54 <lambdabot>  "rafb"
09:18:58 <AStorm> wli, zip that list maybe?
09:19:32 <wli> It's lists of lists of lists nested arbitrarily deeply.
09:19:32 <AStorm> uhm, I meant, convert to a list of 3-tuples
09:19:33 <oerjan> oh right, it will _definitely_ ruin the ability to have final list elements
09:19:39 <AStorm> wli, uhoh
09:20:13 <oerjan> because you cannot determine the element type from the list :(
09:20:43 <wli> If I could figure out what the Hell to do induction on then myMethod n = (!!n) . myMethod would work.
09:20:58 <wli> I think, anyway.
09:21:09 <AStorm> flip !!
09:21:48 <AStorm> xerox gave you the terse solution, actually
09:22:38 <oerjan> AStorm: i don't think you understand.  myMethod doesn't have the same type on each side.
09:23:12 <AStorm> oerjan, yes, it doesn't - one is a list, the other is a number (index?)
09:23:31 <chessguy> i don't suppose there's a way to have multiple patterns in a case statement, eh?
09:24:01 <oerjan> chessguy: might try pattern guards, they're an extension
09:24:02 <wli> AStorm: No, the first argument is a list of indices. The second argument is a list of lists of lists of lists ... nested n deep, where n must match the length of the index list.
09:24:13 <AStorm> wli, ahha
09:24:33 <AStorm> you want to pick n element of each list
09:24:37 <wli> So f [a,b,c,d] xs = xs !! a !! b !! c !! d
09:24:38 <AStorm> where n is taken from that list
09:24:41 <AStorm> Yep.
09:24:43 <wli> So f [a,b,c,d,e] xs = xs !! a !! b !! c !! d !! e
09:24:51 <wli> So f [a,b,c,d,e,g] xs = xs !! a !! b !! c !! d !! e !! g
09:24:56 <AStorm> yes, yes.
09:25:12 <wli> It needs to work like Printf.hs
09:25:15 <oerjan> n _cannot_ be taken from the list. it must be from the type of xs somehow.
09:25:26 <oerjan> and possibly from the type of the final result.
09:26:07 <AStorm> f (l:ls) xs = xs !! (f ls xs) !! l
09:26:12 <AStorm> wouldn't that work?
09:26:16 <oerjan> maybe an MPTC will work well enough, as long as it is always unambiguous what both the element type and the list are
09:26:47 <oerjan> AStorm: that is not well-typed without type class hackery
09:27:02 <AStorm> oerjan, yes, you have to bind a type to ls and xs
09:27:39 <oerjan> otoh that _expression_ should work as the method definition
09:28:15 <twb> Does mod x y do speed hacks in GHC, like if x is big and y is 3, evaluting to the mod of the sum of x's digits and y?
09:28:22 <oerjan> class Enumerable list elem where f :: [Int] -> list -> elem
09:28:27 <ddarius> AStorm: That would expand to f [a,b,c] xs = xs !! (xs !! (xs !! ??? !! c) !! b) !! a
09:28:38 <crazy_coder> can anyone help me with the concept of a parsing tree
09:28:57 <oerjan> instance Enumerable l e => Enumerable [l] e where f as above
09:28:59 <AStorm> ddarius, hmm, yep
09:29:02 <ddarius> twb: No.
09:29:05 <wli> The old brain here is creaking.
09:29:10 <Olathe> twb: That's slow on computers.
09:29:25 <oerjan> wli: i think mine picked up for a moment there :)
09:29:29 <twb> Fair enough.
09:29:46 <AStorm> You'd have to write some !!! that takes lists and is a noop on an empty one
09:29:53 <oerjan> also, the base case:
09:30:07 <AStorm> or a function, if you want :P
09:30:10 <oerjan> instance Enumerable a a where f [] x = x
09:30:24 <AStorm> So it works.
09:30:25 <oerjan> AStorm: i amy just have done that, with f as !!!
09:30:35 <oerjan> *may
09:30:36 <AStorm> oerjan, :-)
09:31:46 <oerjan> now someone else can test if it actually compiles.
09:31:50 <tibbe_> is there a function to extract a substring using indicies on a ByteString, can't find one
09:32:00 <wli> oerjan: I don't follow. hpaste?
09:32:15 <ddarius> tibbe_: If there isn't, take len . drop start should be efficient.
09:32:45 <tibbe_> ddarius: ok, thanks
09:35:28 <hpaste>  oerjan pasted "Enumerable class" at http://hpaste.org/1813
09:36:36 <crazy_coder> I have to as an assignment convert a given file having a certain format into a XML file. I don't understand how <xyz>  </xyz> should be implemented
09:37:36 <wli> oerjan: No results...
09:37:40 <Maddas> twb: I doubt that would be faster :-)
09:37:43 <ddarius> crazy_coder: Is this like a first programming class for you?
09:38:02 <AStorm> wli, hmm?
09:38:06 <crazy_coder> ddarius: i have never implemented this before
09:38:39 <crazy_coder> ddarius: would building a tree help
09:38:55 <AStorm> exactly
09:39:07 <AStorm> and then, you just parse it into XML
09:39:21 <AStorm> for bonus points, implement that with DOCTYPE support
09:39:22 <ddarius> "unparse it"
09:39:34 <oerjan> wli: what do you mean no results?  Although Hugs did complain about overlapping instances for some strange reason.
09:40:25 <oerjan> it seems not to be clever enough to deduce that [a] [a] cannot occur in more than one way.
09:40:28 <twb> How do you do "l as x:x':xs" in Haskell, so that l is bound to the whole list?
09:40:40 <twb> Er, in a parameter pattern.
09:40:42 <oerjan> l@(x:x':xs)
09:40:45 <twb> Thanks
09:40:59 <AStorm> oerjan, beat me to it :>
09:41:14 <crazy_coder> Ok Thanks
09:41:30 <ddarius> e = [Char], l = Char, instance Enumerable Char [Char]
09:41:39 <oerjan> so, MPTC's and overlapping instances claim another victim.
09:41:50 <ddarius> Avoid overlapping instances.
09:42:07 <oerjan> actually, the overlapping was automatic.
09:42:26 <oerjan> and intuitively erroneous.
09:42:42 <crazy_coder> How to implement a general tree in Haskell, not a binary tree ?
09:42:58 <ddarius> @docs Data.Tree
09:42:58 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Tree.html
09:43:02 <AStorm> crazy_coder, either with lists, or Data.Tree
09:43:02 <Heffalump> data Rose a = Tree a [Rose a]
09:43:12 <ddarius> An example that should match what you need well
09:43:25 <ddarius> Though, in general, I dislike Data.Tree.
09:43:46 <wli> class Enumerable list elem where { (!!!) :: list -> [Int] -> elem } ; instance Enumerable l e => Enumerable [l] e where { l !!! (i:r) = (l!!i) !!! r } ; instance Enumerable (Integer, Integer) (Integer, Integer) where { x !!! [] = x }
09:43:57 <wli> That also pukes but AFAICT it's not overlapping.
09:43:59 <twb> Why can I write x : (q $ x + x), but not x : $ q $ x + x?
09:44:11 <desp> I'm getting a segmentation fault due to my strict version Data.Binary.Builder
09:44:14 <desp> can someone help?
09:44:42 <twb> Does $ imply function application?
09:44:45 * desp pasted http://pastie.textmate.org/80946
09:44:59 <ddarius> twb: For the same reason you can't write 3 + * 3
09:45:28 <ddarius> If you want you could write (x :) $ q $ x + x
09:45:29 <EvilTerran> twb, ($) is a normal infix operator, just like (+) etc
09:45:37 <EvilTerran> @src ($)
09:45:38 <lambdabot> f $ x = f x
09:45:53 <twb> Ah, it is application
09:46:30 <AStorm> I wonder why $ was used for that and not | or something nicer
09:46:35 <AStorm> :>
09:46:42 <AStorm> *is used
09:46:44 <ddarius> ' ' was used.
09:47:13 <AStorm> Not really
09:47:20 <AStorm> ( ) are used
09:47:22 <EvilTerran> can't use :>, that'd be a constructor
09:47:36 <AStorm> EvilTerran, syntax feature, blah
09:47:55 <EvilTerran> you could use >>> and <<<, if you'd rather.
09:47:55 <AStorm> heh, ! fwit
09:48:03 <desp> ahhh
09:48:14 <EvilTerran> ?type (<<<)
09:48:22 <lambdabot> forall (a :: * -> * -> *) c d b. (Arrow a) => a c d -> a b c -> a b d
09:48:27 <AStorm> EvilTerran, taken :P
09:48:36 <EvilTerran> ?type ($)
09:48:36 <AStorm> (and quite useful)
09:48:38 <lambdabot> forall a b. (a -> b) -> a -> b
09:48:47 <AStorm> ?src (<<<)
09:48:47 <lambdabot> f <<< g = g >>> f
09:48:52 <EvilTerran> > (<<<) :: (a -> b) -> a -> b
09:48:52 <lambdabot>   `<<<' is applied to too few arguments
09:48:52 <lambdabot>     In the expression: (<<<)
09:48:52 <lambdabot>     In t...
09:48:58 <AStorm> that's a circular definition
09:49:03 <AStorm> ?src (>>>)
09:49:03 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
09:49:08 <AStorm> haha
09:49:21 <ddarius> @src Arrow
09:49:21 <lambdabot> class Arrow a where
09:49:21 <lambdabot>     arr, pure   :: (b -> c) -> a b c
09:49:21 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
09:49:21 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
09:49:21 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
09:49:23 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
09:49:25 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
09:49:37 <EvilTerran> i mean, (<<<) _is_ ($) for the (->) instance of Arrow
09:49:42 <AStorm> :>
09:49:54 <ddarius> It's flip (.)
09:50:04 <ddarius> er (.)
09:50:04 <EvilTerran> is it? what am I after, then?
09:50:12 <twb> Pfft, rocket scientists.
09:50:17 * EvilTerran headdesks
09:50:19 <twb> They're glorified ballistics experts
09:50:57 <EvilTerran> sorry, brainfart. thought it was ($), not (.). =/
09:51:04 <EvilTerran> @yhjulwwiefzojcbxybbruweejw
09:51:05 <lambdabot> "\""
09:51:07 <ddarius> Actually, ballistics experts probably have the harder problem.
09:51:09 <twb> They wouldn't be so smug if Orion had flown
09:51:28 <AStorm> `rocket` operator
09:52:45 <AStorm> Is there some Haskell text charset encoding/decoding lib available?
09:53:18 <EvilTerran> what about "", say?
09:53:36 <EvilTerran> or  and  - one for each direction
09:53:50 <AStorm> EvilTerran, can't type these with current keymap
09:53:54 <EvilTerran> () = ($); () = flip ($); ;p
09:53:55 <twb> AStorm: sure you can
09:54:01 <twb> C-x C-m C-\ TeX
09:54:04 <AStorm> (except ISO-10xxx)
09:54:20 <AStorm> twb, Vim partisan here ;P (actually not, I use both Emacs and vim)
09:54:39 <twb> 02:53 <fsbot> rfc1345: &Tl
09:54:50 <twb> Apparently it's not in the TeX input method.
09:55:04 <EvilTerran> might be able to use "", if you're feeling evil.
09:55:15 <AStorm> f ` ` x y
09:55:31 <AStorm> not that eeeevil :>
09:55:34 <EvilTerran> > let  = 1 in 
09:55:35 <lambdabot>  Illegal character ''\128''
09:55:39 <EvilTerran> poo.
09:55:41 <twb> There are all those APL operator glyphs in unicode...
09:55:53 <AStorm> > let " " = 1
09:55:53 <lambdabot>  Parse error
09:56:12 <AStorm> EvilTerran, nbsp? :P
09:56:21 <EvilTerran> > let () = 1 in ()
09:56:21 <lambdabot>  Illegal character ''\128''
09:56:34 <EvilTerran> AStorm, i just tried to use em-space...
09:56:58 <AStorm> EvilTerran, Haskell doesn't support UTF-8 yet afaicr
09:57:12 * EvilTerran thought GHC did
09:57:26 <AStorm> with a flag probably
09:57:30 <wli> hbc I thought
09:59:28 <oerjan> some of the documentation says ghc supports it in strings, but not identifiers.
10:00:13 <matthew_-> in ByteString, hPutStrLn has nothing to do with the contents of the BS right - it doesn't matter if it's really not a String ?
10:01:18 <sfultong> has anyone come up with code style conventions for haskell, (analogous to one true brace style for C)?
10:02:09 <ariks> is it possible to see the results of what I spliced in with template haskell?
10:02:32 <matthew_-> arkis: yes, you can do runQ and pprint and stuff
10:02:50 <matthew_-> just call the function outside of the $( ... ) stuff
10:03:54 <AStorm> sfultong, yep, there is some style: don't use braces unless needed
10:03:58 <AStorm> layout is nice :-)
10:04:34 * twb tries to remember how to define an infinite series
10:04:48 <AStorm> twb, simple - with an infinitely recursive function
10:05:44 <AStorm> is there any Haskell FastCGI lib?
10:05:46 <twb> I somehow ended up with a function that returns take . f instead of f
10:05:57 <AStorm> twb, :P
10:06:27 <desp> is there a built-in function to round-up to powers of two, or multiplies of a number?
10:06:44 <AStorm> probably not
10:06:52 <matthew_-> AStorm: yes, there is a FastCGI lib
10:07:00 <AStorm> matthew-_, where?
10:07:10 <EvilTerran> i think, for the latter, you'd have to do something with `div`
10:07:15 <desp> right
10:07:21 <EvilTerran> dunno about the first
10:07:25 <AStorm> div + one divisor
10:07:26 <matthew_-> err, bridgert's stuff?
10:07:41 <AStorm> or...
10:07:49 <AStorm> number + div - mod
10:07:55 <matthew_-> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/fastcgi
10:08:00 <lambdabot> http://tinyurl.com/3bgzga
10:08:01 <AStorm> number + (div - mod)
10:08:31 <AStorm> but div * (divisor + 1) is better
10:08:50 <twb> It's all good, the sequence I was trying to understand was a simple variation on fibonnaci, with the second element being 2 instead of 1.  I used a fibs definition without understanding it :P
10:08:51 <AStorm> number + mod
10:09:02 <AStorm> ?src fib
10:09:02 <lambdabot> Source not found. Take a stress pill and think things over.
10:09:05 <AStorm> ?src fibs
10:09:05 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
10:09:09 <AStorm> hmmm :>
10:09:12 <twb> fibs = 1 : 1 : [ a+b | (a,b) <- zip fibs (tail fibs) ]
10:09:12 <desp> roundUpToMultiplyOf n k = k * ((div n k) + 1)
10:09:15 <desp> right?
10:09:23 <AStorm> desp, yep
10:09:26 <twb> multpLE, surely?
10:09:47 <sfultong> AStorm: well, I guess my comment about the one true brace style was misleading... I wasn't referring to braces specifically... let bindings are more relevant to haskell...
10:09:47 <AStorm> maybe k + k `mod` n
10:09:50 <AStorm> might be faster
10:11:04 <sfultong> and as far as I know, braces are never "needed" in haskell... their most important use is in updating data structures, and even that's just syntactic sugar
10:13:01 <tibbe_> how to repeatedly apply a function f n times to and argument x?
10:13:27 <twb> Is there a built-in definition for evenp x = 0 == mod x 2?
10:14:32 <doserj> @src even
10:14:32 <lambdabot> even n = n `rem` 2 == 0
10:14:46 <twb> Neato.
10:15:39 <norpan> bah
10:15:39 <twb> Is there a short way to write large *exact* numbers?  1e6 becomes inexact.
10:15:55 <norpan> 10^6
10:15:55 <SamB> @hoogle Int -> [a] -> Maybe a
10:15:56 <lambdabot> No matches, try a more general search
10:16:18 <twb> Ah, I did that earlier and didn't even notice I'd changed notation
10:16:26 <wli> There are two type constructors
10:16:36 <wli> [ ] and (-> Int)
10:17:06 <wli> I want the number of times those type constructors are applied to match.
10:17:09 <twb> Gah, that's an operator not part of the numeric literal
10:17:57 <ariks> mathrick: what module would give me putStrLn.pprint? or better yet where would I look that up?
10:18:05 <crazy_coder> what does  lexical error in string/character literal at character '\n'  mean ?
10:18:05 <crazy_coder>  
10:18:10 <ariks> err matthew_- I mean
10:19:10 <sfultong> tibbe_ : (\x f n -> foldl (\nx nf -> nf nx) x (take n (repeat f)))
10:19:26 <tibbe_> sfultong: thants
10:19:28 <tibbe_> thanks
10:19:30 <EvilTerran> crazy_coder, it means you can't have literal newlines in strings.
10:19:36 <tibbe_> @pl (\x f n -> foldl (\nx nf -> nf nx) x (take n (repeat f)))
10:19:36 <lambdabot> (. (flip take . repeat)) . (.) . foldl (flip id)
10:19:49 <crazy_coder> EvilTerran: literal newlines ?
10:19:54 <doserj> \ x f n -> (iterate f x)!!n
10:19:55 <sfultong> yeah, there's probably a cleaner way of writing that
10:20:06 <sfultong> like doserj's way
10:20:15 <EvilTerran> as in, if you want a line break in your string, put the characters \n in where you want it, rather than an actual linebreak
10:21:10 <sfultong> too many prelude functions to remember :-P
10:21:23 <crazy_coder> like why is this not allowed putStrLn ("\" ++ "xyz")
10:21:33 <EvilTerran> if you just want to break a string across multiple lines, do "blah blah bl\<any whitespace, including newlines>\ah blah"
10:21:39 <EvilTerran> > "\""
10:21:41 <lambdabot>  "\""
10:21:45 <crazy_coder> oh ok
10:21:47 <crazy_coder> THanks
10:21:56 <twb> Will folding + over a list use less resources than sum?
10:21:57 <crazy_coder> wait a sec
10:21:59 <xerox> > "\\"
10:22:00 <lambdabot>  "\\"
10:22:16 <crazy_coder> > putStrLn ("\\" ++ "xyz")
10:22:17 <xerox> > '\\' : "xyz"
10:22:17 <lambdabot>  <IO ()>
10:22:18 <EvilTerran> a backslash in a string always escapes the character after it
10:22:18 <lambdabot>  "\\xyz"
10:22:27 <xerox> > '\' : "xyz"
10:22:28 <lambdabot>  Improperly terminated character constant
10:22:52 <EvilTerran> (either adds or removes magic, depending on the character)
10:22:55 <doserj> @src sum
10:22:55 <lambdabot> sum = foldl (+) 0
10:23:51 <doserj> foldl' might be better, though
10:24:17 <EvilTerran> @where \
10:24:17 <lambdabot> http://www.haskell.org/onlinereport/lexemes.html#sect2.6
10:24:24 <twb> foldl' being what some languages call REDUCE?
10:24:39 <EvilTerran> crazy_coder, see that link
10:24:46 <crazy_coder> ok I got it
10:24:47 <crazy_coder> thanks
10:25:04 <nominolo> :t liftM
10:25:06 <doserj> I don't know in what languages it is called reduce, but probably, yes
10:25:06 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
10:25:14 <EvilTerran> there's more syntax to strings than you'd expect ;]
10:25:43 <nominolo> :t filter (not . isSpace)
10:25:45 <lambdabot> [Char] -> [Char]
10:25:54 <twb> @paste
10:25:54 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:25:57 <twb> Bleh.
10:26:06 <nominolo> :t getContents >>= liftM (filter (not . isSpace))
10:26:08 <twb> No hpaste.el
10:26:08 <lambdabot>     Couldn't match expected type `Char' against inferred type `[Char]'
10:26:08 <lambdabot>       Expected type: String -> IO b
10:26:35 <doserj> @google hpaste.el
10:26:37 <lambdabot> http://www.haskell.org/haskellwiki/Hpaste.el
10:26:37 <lambdabot> Title: Hpaste.el - HaskellWiki
10:26:41 <twb> Yay!
10:26:51 <ariks> matthew_-: nevermind. I found it in plain site. works beautifully. thanks.
10:27:09 <twb> Now I just need to work out how to fetch that programmatically.
10:27:26 <twb> Does haskellwiki have something like emacswiki's /download/ ?
10:27:35 <crazy_coder> what converts character '2' to int 2 ?
10:27:48 <crazy_coder> or rather string "2" to int 2 ?
10:27:54 <twb> read?
10:27:59 <crazy_coder> :t read
10:28:01 <lambdabot> forall a. (Read a) => String -> a
10:28:15 <crazy_coder> > read "2"
10:28:16 <lambdabot>  2
10:28:19 <crazy_coder> ok
10:28:19 <_Nucleo> > (read "2")::Int
10:28:20 <twb> Yow.
10:28:20 <lambdabot>  2
10:28:22 <EvilTerran> > read "2" :: Double
10:28:23 <lambdabot>  2.0
10:28:36 <SamB> hmm, derive doesn't have a way to derive instances for pre-existing types?
10:29:19 <twb> How do I write a GNU make rule to place the elisp code from http://www.haskell.org/haskellwiki/Hpaste.el into a local file "hpaste.el"?
10:31:02 <doserj> why don't you just download and copy it?
10:31:04 <crazy_coder> how to convert Just "xyz" to string "xyz" . Like show is not helping here
10:31:21 <twb> doserj: because then I have to manually check the page for updates
10:31:37 <twb> Currently I just do "make -C ~/.emacs.d/lisp" to update all my packages.
10:31:38 <crazy_coder> > let a= Just xyz in show a
10:31:39 <lambdabot>   Not in scope: `xyz'
10:31:51 <crazy_coder> > let a= Just "xyz" in show a
10:31:52 <lambdabot>  "Just \"xyz\""
10:32:29 <crazy_coder> I don't want this Just over there
10:32:36 <sfultong> @pl \x f n -> (iterate f x) !! n
10:32:36 <lambdabot> ((!!) .) . flip iterate
10:32:37 <doserj> twb: well, it hasn't changed since it was put there...
10:32:45 <twb> That's beside the point.
10:32:52 <doserj> :)
10:33:10 <twb> I can't even work out what wiki software haskellwiki is running
10:33:28 <doserj> @type fromJust
10:33:30 <lambdabot> forall a. Maybe a -> a
10:33:33 <twb> I can't just use &action=edit to get the code, because that requires login :-/
10:33:34 <wli> I don't seem to be able to say instance Enumerable [ ] t => Enumerable [[ ]] t where { ... }
10:34:08 <doserj> > fromJust (Just "abc")
10:34:09 <lambdabot>  "abc"
10:34:28 <twb> Ew, it's mediawiki
10:34:31 <twb> Fucking PHP shite
10:35:05 <crazy_coder> doserj: thanks
10:35:48 <crazy_coder> in which module is fromJust defined ?
10:35:54 <HWSOD> are there any fast implementations of double sided ques in haskell?
10:35:54 <doserj> Data.Maybe
10:35:58 <crazy_coder> ok
10:36:18 <sfultong> crazy_coder: the prelude function maybe is also good...
10:36:19 <crazy_coder> Can we do putStrLn (fromJust (Just "xyz"))
10:36:20 <doserj> but it is considered questionable
10:36:36 <sfultong> it's like an if branch statement for maybe
10:36:44 <sfultong> I mean, Maybe
10:37:19 <crazy_coder> Sorry I didn't get it
10:37:33 <pejo> twb, lynx -dump | script_that_trims > ~/.emacs.d/lisp/hpaste.el?
10:37:38 <crazy_coder> I want to extract the contents after Just and print it
10:37:46 <twb> pejo: disgusting
10:37:52 <crazy_coder> fromJust returns a string ?
10:38:05 <doserj> fromJust gives undefined on 'Nothing'
10:38:07 <twb> pejo: (that is plan B)
10:38:28 <doserj> for maybe, you can give a default value in case of 'Nothing'
10:38:29 <crazy_coder> doserj: Thats ok. I check for Nothing before using it
10:38:42 <crazy_coder> how to use maybe ?
10:38:51 <sjanssen> HWSOD: Data.Sequence can be used as a double sided queue
10:39:04 <doserj> @src maybe
10:39:04 <lambdabot> maybe n _ Nothing  = n
10:39:04 <lambdabot> maybe _ f (Just x) = f x
10:39:15 <sjanssen> HWSOD: it has other neat features like fast indexing and concatenation
10:39:26 <HWSOD> Thnaks
10:39:40 <pejo> twb, you can just cut everything above the first ";;;" and after "(provide 'hpaste)". Sure it's ugly, but someone put the code in the wiki for some reason.
10:39:56 <doserj> > maybe "" putStrLn (Just "abc")
10:39:58 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `IO ()'
10:40:09 <doserj> ups...
10:40:17 <twb> pejo: that is a KLUDGE
10:40:19 <twb> curl -s 'http://www.haskell.org/haskellwiki/?title=Hpaste.el&action=raw' | sed -n '/<pre-lisp>/,\|</pre-lisp>|p' | sed -e '1d;$d'
10:40:24 <twb> Is a less ugly kludge.
10:40:33 <sfultong> > maybe "" show (Just "whee")
10:40:34 <lambdabot>  "\"whee\""
10:40:55 <sfultong> > maybe "" show (Nothing)
10:40:57 <lambdabot>  ""
10:41:25 <crazy_coder> Ok thanks
10:45:59 <twb> http://www.haskell.org/haskellwiki/Talk:Hpaste.el
10:47:33 <xerox> is there a way to hide instances while importing modules?
10:48:32 <xerox> maybe I'm hoping too much
10:49:34 <xerox> "It is not possible, however, to hide instance declarations in the Prelude. For example, one cannot define a new instance for Show Char."
10:49:37 <xerox> hmpf
10:50:39 <doserj> http://www.haskell.org/onlinereport/modules.html#sect5.4
10:50:40 <lambdabot> Title: The Haskell 98 Report: Modules
10:52:01 <xerox> pah.
10:53:25 <hpaste>  twb pasted "nave version hella slow, hints for improvement?" at http://hpaste.org/1814
10:53:38 <twb> Grr, hpaste.el still throwing errors.
10:55:28 <SamB> wow
10:56:14 <SamB> I just crashed GHCi by doing something totally legit with TH
10:56:25 <SamB> well, not exactly crashed
10:57:42 <wli> Hmm. I can't figure out how to inductively construct the family of types Int -> [a] -> a, Int -> Int -> [[a]] -> a, Int -> Int -> Int -> [[[a]]] -> a, ... in typeclass instances.
10:57:58 <hpaste>  twb pasted "test" at http://hpaste.org/1815
10:58:42 <twb> Weird.
10:59:11 <twb> Either the author totally wasn't paying attention, or the url-http API changed under him
10:59:21 <wli> The obvious way gets (Int -> Int) -> [[a]] -> a, (Int -> Int -> Int) -> [[[a]]] -> a, etc.
10:59:40 <SamB> > $(let s = replicate 26227 'x' in [| s |])
10:59:40 <lambdabot>  Parse error
10:59:59 <EvilTerran> > let fibs = 1 : 2 : [a+b | (a,b) <- zip fibs $ tail fibs] in map even fibs
11:00:04 <lambdabot>  [False,True,False,False,True,False,False,True,False,False,True,False,False,T...
11:00:24 <EvilTerran> > let fibs = 1 : 2 : [a+b | (a,b) <- zip fibs $ tail fibs] in map length $ group $ map even fibs
11:00:25 <lambdabot>  [1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1...
11:00:35 <roconnor> Can I get runtime informaiton, like the amount of heap that has been allocated so far, in my haskell program?
11:01:03 <EvilTerran> twb, does that suggest an improvement to you?
11:01:40 <chessguy> hmm, if i import Data.ByteString as B, can't i just refer to head when wantint Prelude.head?
11:02:11 <roconnor> import qualified Data.ByteString as S
11:02:26 <SamB> > $(Language.Haskell.TH.Syntax.lift (replicate 26227 'x'))
11:02:27 <lambdabot>  Parse error
11:02:28 <HWSOD> how does one repeatedly apply a function?  (i.e I want a f such that (f 2 g x) => (g g x), (f 3 g x) => (g g g x) )
11:02:47 <EvilTerran> you should be able to. if not, you could import qualified Prelude as P and suffer the resulting relatively minor inconvenience
11:02:54 <doserj> @src iterate
11:02:54 <lambdabot> iterate f x =  x : iterate f (f x)
11:02:55 <twb> EvilTerran: are you saying I should be replacing evenp with a faster predicate?
11:03:14 <HWSOD> at doserj Thanks!!
11:03:20 <EvilTerran> SamB, lambdabot doesn't do TH, afaik
11:03:26 <SamB> > $(Language.Haskell.TH.lift (replicate 26227 'x'))
11:03:26 <lambdabot>  Parse error
11:03:35 <SamB> > ($(Language.Haskell.TH.lift (replicate 26227 'x')))
11:03:36 <lambdabot>   Not in scope: `Language.Haskell.TH.lift'
11:03:36 <chessguy> i don't get it, i'm getting this error:
11:03:37 <chessguy>     Ambiguous occurrence `head'
11:03:37 <chessguy>     It could refer to either `head', imported from Prelude
11:03:37 <chessguy> 		          or `head', imported from Data.ByteStrin
11:03:40 <EvilTerran> > $([| 1 |])
11:03:40 <lambdabot>  Parse error
11:03:55 <chessguy> and i'm doing import Data.ByteString as B
11:04:25 <SamB> oh, wait a minute
11:04:26 <EvilTerran> :t ($(?lift (replicate 26227 'x')))
11:04:28 <lambdabot> forall a b. (?lift::[Char] -> a) => (a -> b) -> b
11:04:28 <tibbe__> how do I throw and exception with a value and catch it in the IO monad?
11:04:35 <EvilTerran> that $ is a section, not a splice
11:04:36 <SamB> I can't crash GHCi when lambdabot uses GHC anyway...
11:05:10 <EvilTerran> twb, i'm saying look for a pattern in the even numbers in the fibbonacci sequence
11:05:21 <twb> EvilTerran: ah, OK.
11:05:38 <twb> So instead of fibs then post-filtering it, define evenfibs.
11:05:43 <chessguy> oh, apparently i have to import qualified...
11:05:43 <roconnor> type RNAStateST s = RNAState (STUArray s) (STRef s)
11:05:43 <roconnor> type Id x = x
11:05:43 <roconnor> type RNAStateFrozen = RNAState UArray Id
11:05:57 <roconnor> gives error
11:05:57 <roconnor>     Type synonym `Id' should have 1 argument, but has been given 0
11:05:57 <roconnor>     In the type synonym declaration for `RNAStateFrozen'
11:05:57 <EvilTerran> twb, exactly!
11:06:08 <roconnor> But Id has kind * -> *
11:06:12 <EvilTerran> twb, also, this may help:
11:06:16 <roconnor> which is what RNAState UArray is expecting
11:06:18 <EvilTerran> ?type zipWith
11:06:18 <roconnor> what gives?
11:06:20 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
11:06:46 <wli> I think it may not be possible to construct this function in the type system but can't quite prove it.
11:07:14 <EvilTerran> > zipWith (-) [1,2,3,4] [1,3,5,7] -- twb, this useful for you?
11:07:16 <lambdabot>  [0,-1,-2,-3]
11:07:19 <pejo> tibbe, throwDyn (val), and catchDyn?
11:07:48 <twb> So zip = zipWith \x,y -> (x,y)?
11:07:56 <xerox> zipWith (,) yeah
11:08:04 <twb> OK.
11:08:08 <chessguy> @src zip
11:08:08 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
11:08:08 <lambdabot> zip _      _      = []
11:08:16 <EvilTerran> yeah. well, without the "," in "\x,y" - that should be a space in haskell's syntax.
11:08:44 <EvilTerran> alternatively, zipWith f = map (uncurry f) . zip
11:09:36 <twb> Sorry.
11:10:20 <twb> I'm used to FP in Scheme where map and friends are fiddly to allow for variadicity
11:11:19 <araujo> hello
11:12:03 <EvilTerran> > \x,y -> (x,y) -- probably won't give a nice error message, so it's helpful to know
11:12:03 <lambdabot>  Parse error
11:13:04 <EvilTerran> wli, are your functions meant to be some kind of fold or something?
11:13:08 <ihope> > const 3 \x -> x
11:13:08 <lambdabot>  Parse error
11:13:11 <ihope> > const 3 (\x -> x)
11:13:13 <lambdabot>  3
11:13:13 <EvilTerran> (a multi-dimensional one)
11:13:23 <ihope> > const 3 $ \x -> x
11:13:25 <lambdabot>  3
11:13:26 <ihope> Be careful of that as well.
11:13:48 <wli> EvilTerran: kind of like foldr (.) id (map (!!) ns)
11:14:02 <ihope> Now, how easy is it to compile stuff into GHC Haskell?
11:14:13 <EvilTerran> wli, aha. i see.
11:14:35 <wli> EvilTerran: kind of like foldr (.) id (map (flip (!!)) ns) rather
11:14:52 <chessguy> !paste
11:14:53 <hpaste> Haskell paste bin: http://hpaste.org/
11:15:04 <EvilTerran> quite
11:15:21 <hpaste>  chessguy pasted "huh?" at http://hpaste.org/1816
11:15:35 <chessguy> what in the name of all that's functional and pure is that error supposed to mean?
11:16:35 <EvilTerran> chessguy, it means you're trying to create two instances of the same multi-parameter class with clashing fundeps, i think
11:17:06 <ihope> @ghc
11:17:06 <lambdabot> ghc says: Only unit numeric type pattern is valid
11:17:10 <chessguy> i'm not doing anything with fundeps
11:17:15 <chessguy> not intentionally anyway
11:17:15 <EvilTerran> class Foo a b | a -> b; instance Foo Bar Baz; instance Foo Bar Aleph -- or what have you
11:17:21 <ihope> At least you're not getting stuff like the @ghc command gives you.
11:17:43 <chessguy> @ghc
11:17:43 <lambdabot> ghc says: Unable to mmap( MAP_FIXED ) for Jump Islands
11:17:53 <EvilTerran> i imagine MonadState has fundeps MonadState a b | b -> a, from that error
11:18:07 <chessguy> why the heck should that be my problem?
11:18:14 <ihope> @index MonadState
11:18:14 <lambdabot> Control.Monad.State, Control.Monad.RWS
11:18:24 <chessguy> @source Control.Monad.State
11:18:25 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/State.hs
11:18:37 <chessguy> @source Control.Monad.State.Lazy
11:18:38 <lambdabot> Control.Monad.State.Lazy not available
11:18:46 <EvilTerran> in which case, the "MonadState s (State s)" instance means that, for any "MonadState foo (State bar)", foo and bar will have to be the same type
11:18:47 <chessguy> of course not
11:19:12 <EvilTerran> so you can't do MonadState DNA (State DNAMachineState)
11:19:24 <chessguy> i wasn't trying to
11:19:24 <ihope> class (Monad m) => Control.Monad.State.Class.MonadState s m | m -> s where
11:19:39 <EvilTerran> ihope, as i said, ta.
11:19:40 <int-e> EvilTerran: sure you can.
11:19:48 <chessguy> i have getPattern :: State DNAMachineState Pattern
11:19:59 * EvilTerran fiddles with the grammar of his last line 'til it makes sense
11:20:11 <chessguy> from which i'm calling nat :: State DNAMachineState Int
11:20:25 <int-e> EvilTerran: you can't, however, add another MonadState instance with DNA replaced by a different type. (Oh and if DNAMachineState is a type synonym it may be more tricky)
11:20:41 <chessguy> int-e, it's not
11:20:46 <EvilTerran> int-e, surely it clashes with MonadState s (State s)?
11:20:54 <int-e> EvilTerran: hmmm
11:21:11 <EvilTerran> because that specifics down to MonadState DNAMachineState (State DNAMachineState) with the fundep
11:21:13 <int-e> EvilTerran: sorry you're right. you need to newtype the State DNAMachineState first
11:21:53 <chessguy> ok, let me know when you guys are done making yourselves sound smart without being of any practical value
11:22:06 <int-e> newtype DNAMachine a = DNAMachine (State DNAMachineState a) deriving Monad
11:22:09 <wli> I can't figure out a pattern to inductively define flip (!!), \i j -> (!!i) . (!!j), \i j k -> (!!i) . (!!j) . (!!k), etc.
11:22:32 <EvilTerran> wli, do you understand the trick that PrintF does?
11:22:46 <wli> EvilTerran: Not very well.
11:23:31 <chessguy> oh
11:23:37 <chessguy> it was a simple problem
11:23:42 <EvilTerran> chessguy, we're both trying to help. we just need to nerd about a bit first so we can be sure we understand what's going on first.
11:23:47 <chessguy> very strange error message though
11:23:55 * EvilTerran kills one of those "first"s
11:24:13 <wli> EvilTerran: I think this is not expressible as a printf-like trick and probably needs even stranger constructs.
11:24:23 <ihope> wli: are you trying to make a function that takes something of a different type depending on one of its arguments?
11:24:26 <chessguy> nat :: State DNAMachineState Int
11:24:26 <chessguy> nat = do {
11:24:26 <chessguy>   s <- get;
11:24:26 <chessguy>   case ((head . getFront) (dna s)) of ... }
11:24:29 <EvilTerran> wli, that's possible. i think it's related, tho.
11:24:46 <chessguy> i had just the s in there where i have (dna s) now
11:24:48 <wli> EvilTerran: It needs a type lambda or a type flip or some such.
11:25:00 <chessguy> but getFront expects a DNA not a DNAMachineState
11:25:30 <pejo> chessguy, is the case-statement on line 104?
11:25:46 <chessguy> thus, the type of nat was assumed to be State DNA Int, even though i had given it a different type annotation, and even though it should have been clear from the context in which it was called what the correct type was
11:26:03 <chessguy> pejo, no, the get is
11:26:29 * wli retreats to a monadic exercise of some sort.
11:26:57 <EvilTerran> wli, it's an interesting problem. i'll have a poke about, see if i can get further than you did.
11:27:08 <wli> EvilTerran: Please do.
11:27:33 <chessguy> i would have expected it to just say that getFront was getting a value of an incorrect type
11:27:43 <chessguy> but ghc thought to hard about it
11:27:54 <wli> EvilTerran: Basically I want f xs i j k ... = xs !! i !! j !! k, or better yet, f xs [i,j,k,...] = f !! i !! j !! k !! ...
11:28:05 <EvilTerran> fundeps seem to do that a lot =/
11:28:40 <wli> EvilTerran: f xs [i,j,k,...] = xs !! i !! j !! k !! ... rather
11:29:27 <EvilTerran> wli, in the second case, bear in mind that it'll always have to take the same number of indices.
11:29:46 <wli> EvilTerran: It must be a variable number of indices.
11:29:46 <EvilTerran> seeing that it's got to have type [[...[a]...]] -> a
11:30:05 <wli> EvilTerran: The indices arrive in lists.
11:30:22 <EvilTerran> actually, i have an idea for that one (that wouldn't work for the other one)...
11:30:54 <wli> EvilTerran: I have no idea how to make it work for f xs i j k ... but I figured it would be progress.
11:31:07 <aytek> > :t ord
11:31:08 <lambdabot>  Parse error
11:31:14 <EvilTerran> either would be possible with TH, altho i guess that's not what you want
11:31:18 <EvilTerran> @type ord
11:31:20 <lambdabot> Char -> Int
11:31:24 <wli> EvilTerran: f xs [i,j,k,...] = xs !! i !! j !! k !! ... needs to happen.
11:31:32 <wli> EvilTerran: I don't mind TH.
11:31:34 <aytek> EvilTerran: thanx :)
11:31:45 <wli> EvilTerran: I don't know a lick of it, though.
11:31:47 <EvilTerran> aytek, np. wli, okay, that might help...
11:32:30 <wli> EvilTerran: I'm still struggling with monads.
11:33:04 <wli> Right now I'm trying to figure out how to get nondeterminism out of anything besides [ ]
11:33:28 <mrd> there is a MonadNondet on the wiki somewhere
11:33:47 <chessguy> @where sudoku
11:33:48 <lambdabot> http://www.haskell.org/haskellwiki/Sudoku
11:34:04 <chessguy> mrd, wli ^^
11:34:35 <wli> mrd: I'm mostly trying to figure out how it works if not concatMap
11:35:23 <mrd> think of a tree of computation, branching on the choices made
11:35:39 <EvilTerran> ?type concatMap
11:35:41 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
11:35:47 <mrd> a deterministic computation proceeds down a line.  a non-deterministic computation proceeds down a tree.
11:35:49 <EvilTerran> ?type (=<<)
11:35:51 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
11:35:59 <wli> mrd: So keep a tree around? Hmm.
11:36:03 <EvilTerran> those might provide some insight...
11:36:29 <mrd> the list monad is different from non-det turing machines in that it returns ALL accepting solutions rather than just being satisfied with one
11:36:42 <mrd> so it is, in effect, a list of the leaves
11:37:10 <mrd> hence concatMap, for "flattening"
11:37:36 <wli> mrd: Analogies don't help me much. Explaining [ ] -based nondet required going back to concatMap and explaining how when something goes to [] it disappears from the worklist.
11:38:00 <EvilTerran> @src (!!)
11:38:01 <lambdabot> xs     !! n | n < 0 = undefined
11:38:01 <lambdabot> []     !! _         = undefined
11:38:01 <lambdabot> (x:_)  !! 0         = x
11:38:01 <lambdabot> (_:xs) !! n         = xs !! (n-1)
11:38:12 <EvilTerran> @fixity (!!)
11:38:12 <lambdabot> Unknown command, try @list
11:38:22 <mrd> think of a tree again -- in normal computation you proceed linearly.  in non-det computation whenever you reach a choice of n things you branch into n computation paths.
11:38:36 <mrd> if n = 0 then you branch 0 times
11:39:00 <mrd> which ends that portion of the tree
11:40:25 <wli> mrd: data NonDetTree t = Branch [NonDetTree t] | Leaf t, so there's basically no information in the branches?
11:40:49 <wli> s/Leaf/NonDetLeaf/ rather
11:40:55 <SamB> wli: so... I've implemented #1,#2,#3,#4,#5,#6, and #7 somewhat
11:41:06 <wli> SamB: Nice!
11:41:31 <mrd> i suppose you could think of it that way.  the accepted values would be those leaves which are at maximum height.
11:41:58 <wli> mrd: Well, an unaccepted leaf would map to Branch [] at some point.
11:42:37 <mrd> Branch [] and Leaf are redundant
11:42:37 <SamB> http://naesten.dyndns.org:8080/repos/field-access/
11:42:38 <lambdabot> Title: Directory listing for /repos/field-access/
11:42:40 <EvilTerran> @pl \l (x:xs) -> f (l!!x) xs
11:42:40 <lambdabot> (`ap` tail) . (. head) . (f .) . (!!)
11:42:47 <EvilTerran> whups. never mind that.
11:42:48 <mrd> except that you are distinguishing between useful leaves and non-useful leaves
11:43:05 <wli> mrd: That's meant to happen.
11:43:24 <mrd> but yes, lists of lists are leaf-trees (like in lisp)
11:43:30 <wli> mrd: NonDetTree might be better called a decision tree.
11:43:32 <mrd> leaf-value trees
11:43:37 <SamB> most of the time I invested was spent on the derivings
11:43:39 <mrd> sure
11:43:55 <SamB> I haven't actually made instances for tuples yet
11:44:22 <EvilTerran> @where report
11:44:23 <lambdabot> http://www.haskell.org/onlinereport/
11:45:14 <wli> mrd: It could be useful as a method of scheduling things if I shoehorned some sort of state into the branch nodes.
11:46:48 <wli> mrd: peel one element off each child, stick that into the branch node, whenever dequeueing, consult the branch node before peeling another layer off the children, etc.
11:47:26 <hpaste>  EvilTerran pasted "wli's nested indexing" at http://hpaste.org/1817
11:47:46 <chessguy> how do i turn a Char into a Word8?
11:48:02 <mrd> > ord 'a'
11:48:03 <int-e> @type fromIntegral . ord
11:48:05 <lambdabot> forall b. (Num b) => Char -> b
11:48:06 <lambdabot>  97
11:48:25 <chessguy> @instances-importing Num
11:48:26 <lambdabot> Double, Float, Int, Integer
11:48:30 <chessguy> ...
11:48:31 <wli> mrd: So when you unfold the tree, the little state field stays totally empty, but when you start dequeueing, then the state fields in the branches start filling up
11:48:38 <int-e> @instances-importing Word Num
11:48:39 <lambdabot> Double, Float, Int, Integer, Word, Word16, Word32, Word64, Word8
11:48:51 <chessguy> Word Num?
11:48:58 <int-e> no, importing Word.
11:49:02 <int-e> @instances-importing Data.Word Num
11:49:03 <lambdabot> Double, Float, Int, Integer, Word, Word16, Word32, Word64, Word8
11:49:05 <int-e> or that.
11:49:27 <chessguy> oh, Word8 is an instance of both Word and Num?
11:49:29 <mrd> you can experiment with mixing StateT and ListT
11:49:35 <int-e> no, Word is a module name
11:49:42 <EvilTerran> wli, there you go. mind that it tends to need a bit of explicit typing to work, so it can distinguish between you wanting (words "foo bar baz" !..! [1] :: String) and (words "foo bar baz" !..! [1,2] :: Char), say, at compile time
11:49:47 <int-e> @help instances-importing
11:49:47 <lambdabot> instances-importing [<module> [<module> [<module...]]] <typeclass>. Fetch the instances of a typeclass, importing specified modules first.
11:49:58 <chessguy> ohhhh
11:50:33 <EvilTerran> wli, does that do what you need?
11:51:49 <twb> @hoogle group
11:51:49 <lambdabot> List.group :: Eq a => [a] -> [[a]]
11:51:50 <lambdabot> List.groupBy :: (a -> a -> Bool) -> [a] -> [[a]]
11:51:50 <lambdabot> System.Console.Readline.beginUndoGroup :: IO ()
11:52:03 <wli> dequeue b@(Branch [] []) = (Nothing, b) ; dequeue b@(Branch [] children@(_:_)) = case map dequeue children of { [] -> (Nothing, b) ; (x:xs) -> {- some hairy nightmare -} }
11:52:11 <chessguy> @hoogle ord
11:52:12 <lambdabot> Char.ord :: Char -> Int
11:52:12 <lambdabot> Prelude.Ord :: class Eq a => Ord a
11:52:12 <lambdabot> Text.Html.ordList :: HTML a => [a] -> Html
11:52:36 <twb> How do I open a module in ghci?
11:52:40 <wli> EvilTerran: I can't tell but I suspect not since it strongly resembles something earlier today that didn't execute whenever anyone actually tried to use it.
11:53:03 <EvilTerran> wli, well, without more context, i'm afraid i can't help you any further.
11:53:23 <EvilTerran> but i hope that gets you _somewhere_, at least. and on that note, i have to go, anyway
11:53:29 * EvilTerran **wanders off**
11:53:38 <wli> EvilTerran: You understand what we're trying to do.
11:53:44 <xerox> twb: :h
11:53:55 <wli> EvilTerran: That's just not a working solution.
11:54:25 <EvilTerran> well, in that case, i don't know enough about your problem spec to be able to help you.
11:54:41 <EvilTerran> the comment at the top of that paste is taken directly from GHCI. it works for me.
11:54:47 <wli> EvilTerran: You do. You've just arrived at a point we've already been.
11:55:05 <wli> EvilTerran: That worked???
11:55:21 <EvilTerran> ... YES.
11:55:21 <twb> :module +List
11:55:27 <decaf> i'm gay. here a turkish gay channel  #fazlamesai we are all fag and we are very like sucking huge dicks.
11:55:42 <wli> EvilTerran: Holy cow.
11:55:51 <EvilTerran> :D
11:56:11 --- mode: Igloo set +b *!*@200.117.254.146
11:56:17 --- kick: decaf was kicked by Igloo (Igloo)
11:56:17 <wli> EvilTerran: Type signatures.
11:56:20 <EvilTerran> as i said, you might need to add more explicit typing than you would otherwise, so it can work out what instance of ListN to use.
11:58:06 <EvilTerran> anyway. i HTH, now i really must be off.
11:58:14 <wli> EvilTerran: Thanks.
11:58:32 <EvilTerran> :)
12:00:16 <SamB> wli: did you look at the code yet?
12:00:19 <xerox> twb: there are two modes :m + Module is similar to "import Module", whereas :m + *Module puts ghci in Module's scope.
12:01:07 <twb> xerox: OK.
12:01:32 <SamB> *Module only works when GHCi compiles the module to bytecode
12:03:56 <twb> Should ghc --make Foo produce an executable?
12:04:05 <xerox> yes
12:04:09 <twb> :-(
12:04:12 <xerox> given it can find a Main module and a main function
12:04:21 <twb> Oh, the module has to be called Main
12:04:33 <xerox> well, at least "module Main" but the file itself can be anything
12:04:48 <xerox> or -main-is Foo.fnord
12:04:49 <twb> Yep, got it.
12:05:41 <twb> And can I have multiple modules in one file?
12:05:52 <xerox> no
12:06:03 <twb> Bleh.
12:06:16 * xerox dodges
12:09:23 <twb> Is it popular in Haskell (as in Python) to import modules unqualified, e.g. so you say group instead of List.group?
12:09:40 <SamB> twb: since when is that popular in Python?
12:09:48 <SamB> and yes, it is
12:10:15 <SamB> you'll notice that relatively few imports have the "qualified" word in them
12:10:36 * araujo likes qualification
12:11:04 <twb> I must be doing something wrong, because loading Foo which contains "import List", it can't find group but can find List.group.
12:11:19 <SamB> twb: that is indeed odd
12:11:27 <SamB> twb: what implementation are you using?
12:11:32 <twb> ghci
12:11:35 <twb> 6.6.1
12:11:40 <mrd> it says you are in module Foo?
12:11:53 <twb> Er, no.
12:11:54 <dino-> Does anybody know what (:*:) is? I see it used in an example for HAppS, but can't find docs for it yet.
12:12:03 <SamB> what does your prompt look like?
12:12:15 <mrd> dino-: a constructor for something
12:12:20 <doserj> dino-: HList, I think
12:12:31 <mrd> @hoogle (:*:)
12:12:32 <lambdabot> Did you mean: (:*:)
12:12:32 <lambdabot> Prelude.undefined :: a
12:12:32 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
12:12:44 <SamB> hoogle obviously has issues with that
12:12:50 <dino-> aha, Google was not liking that for a search string.
12:12:56 <SamB> that was hoogle
12:12:58 <SamB> not google
12:13:03 <dino-> yeah, I should have looked there
12:13:04 <mrd> :info (:*:)
12:13:08 <SamB> but I'm sure google would be even less helpful ;-)
12:13:23 <dino-> oh, yeah
12:13:25 <SamB> :info isn't implemented
12:13:42 <SamB> @info was, but now it gets spell-corrected to @id
12:13:42 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 4}) "Parse error"
12:13:45 <mrd> it is in his ghci!
12:13:47 <SamB> oh?
12:13:52 <SamB> okay now it doesn't?
12:13:58 <SamB> @info ()
12:13:58 <lambdabot> ()
12:14:04 <SamB> okay...
12:14:14 <SamB> I guess @id is picky?
12:14:38 <dino-> Well, pointing me towards HList helps. Thanks.
12:16:21 <chessguy> err, i can't quite work it out, how can i get emacs to have 2 buffers next to each other with my code, with the ghci buffer below both of them
12:17:59 <doserj> M-x split-window-horizontally?
12:18:54 <chessguy> ah, there's not a C-x _ binding for it
12:19:46 <SamB> wli: did you look at http://naesten.dyndns.org:8080/repos/field-access/ yet?
12:19:48 <lambdabot> Title: Directory listing for /repos/field-access/
12:19:56 <doserj> it is C-x 3 here
12:20:31 <chessguy> oh, huh
12:20:39 <chessguy> i swear that didn't work a minute ago
12:20:45 <doserj> :)
12:21:00 <chessguy> oh, it does, but now i can't just do C-c C-r
12:21:13 <chessguy> or can i
12:21:26 <chessguy> yeah that's working now too
12:21:27 <chessguy> go figure
12:21:41 <wli> SamB: Not yet.
12:22:37 <wli> SamB: Looks promising.
12:23:32 <wli> flatten :: (ListS t, ListN a t) => t -> [a] ; flatten xs = [xs !..! (cantorTuple n (depth xs)) | n <- [0..]]
12:23:53 <wli> Seems to work though it's kind of nasty wrt. polymorphism.
12:24:10 <SamB> what are you doing?
12:24:26 <wli> SamB: http://holomorphy.com/~wli/Tuple.hs
12:25:19 <wli> So at ghci, try: take 20 $ flatten [[[(i,j,k) :: (Integer, Integer, Integer) | i <- [0..]] | j <- [0..]] | k <- [0..]] :: [(Integer, Integer, Integer)]
12:25:56 <wli> and also: take 20 $ flatten [[[[(i,j,k,l) :: (Integer, Integer, Integer, Integer) | i <- [0..]] | j <- [0..]] | k <- [0..]] | l <- [0..]] :: [(Integer, Integer, Integer, Integer)]
12:26:19 <wli> SamB: Notice that they come out in a particularly nice order.
12:26:47 <wli> and also: take 20 $ flatten [[(i,j) :: (Integer, Integer) | i <- [0..]] | j <- [0..]] :: [(Integer, Integer)]
12:28:50 <wli> SamB: They seem to be useful for Enum instances on (t, t'), (t, t', t''), etc.
12:31:31 <wli> [(0,0) .. (0,2)] == [(0,0),(1,0),(0,1),(2,0),(1,1),(0,2)]
12:31:47 <wli> [(0,0,0) .. (0,0,2)] == [(0,0,0),(1,0,0),(0,1,0),(0,0,1),(2,0,0),(1,1,0),(1,0,1),(0,2,0),(0,1,1),(0,0,2)]
12:32:08 <SamB> Looks kinda funny... [(1,2),(0,3),(4,0),(3,1),(2,2),(1,3),(0,4),(5,0),(4,1),(3,2),(2,3),(1,4),(0,5),(6,0),(5,1),(4,2),(3,3),(2,4),(1,5),(0,6),(7,0),(6,1),(5,2)...]?
12:32:37 <wli> SamB: They're first ordered by the sum of their components, then by reverse lexicographical order on their components.
12:32:55 <SamB> wli: okay...
12:32:56 <wli> SamB: a.k.a. "grevlex", often used in Grobner basis computations.
12:33:40 <SamB> makes a lot more sense when you start from (0,0)
12:34:15 <wli> SamB: There the components of a tuple represent the powers the indeterminates are raised to. grevlex eliminates the last indeterminate first, corresponding to the last component of the tuple. etc.
12:35:35 <wli> SamB: Well, you just start in the middle of the section where the sum is 3. From there, you get the normal sequence: [(4,0),(3,1),(2,2),(1,3),(0,4)] ++ [(5,0),(4,1),(3,2),(2,3),(1,4),(0,5)] ++ ...
12:36:25 <wli> SamB: When you break it up according to the sum of the coordinates it starts making sense again.
12:36:51 <SamB> I did notice that if you take one of those and start from there, it picks up where it left off
12:37:10 <wli> SamB: Yeah, it's a complicated calculation.
12:39:35 <wli> The only reason to use tuples there is to clarify the order they're coming out in.
12:39:50 <chessguy> @hoogle (Word w, Integral c) => w -> c
12:39:51 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
12:39:51 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
12:39:51 <lambdabot> Control.Monad.Writer.tell :: MonadWriter w m => w -> m ()
12:40:01 <chessguy> @where hoogle
12:40:01 <lambdabot> http://haskell.org/hoogle
12:40:19 <wli> take 20 $ flatten [[[[i+j+k+l :: Integer | i <- [0..]] | j <- [0..]] | k <- [0..]] | l <- [0..]] :: [Integer] -- this also works
12:41:24 <chessguy> ugh, how do i go from a word, back to a Char
12:41:37 <wli> take 20 $ flatten [[[[2^i*3^j*5^k*7^l :: Integer | i <- [0..]] | j <- [0..]] | k <- [0..]] | l <- [0..]] :: [Integer] -- this works, too
12:42:46 <doserj> @type chr
12:42:48 <lambdabot> Int -> Char
12:43:12 <doserj> or (toEnum . fromEnum) ?
12:43:36 <chessguy> Int isn't a Word though
12:43:42 <tibbe> how do I figure out the type of the continuation given to callCC?
12:43:43 <chessguy> specifically a Word8
12:44:31 <chessguy> oh, fromIntegral to the rescue again
12:45:51 <wli> take 20 $ flatten [[[[(i,i+j,i+j+k,i+j+k+l) :: (Integer, Integer, Integer, Integer) | i <- [0..]] | j <- [0..]] | k <- [0..]] | l <- [0..]] :: [(Integer, Integer, Integer, Integer)] -- slightly enlightening as to what's going on with all this
12:45:59 <Vq^> @type on
12:46:02 <lambdabot> Not in scope: `on'
12:46:30 <Soft-Num> So, I've been reading the docs and the FAQ, and I can't seem to figure this out:  Is it possible to have ghc make an .so lib?
12:47:03 <chessguy> @type (chr . fromIntegral) (2 :: Word8)
12:47:05 <lambdabot> Char
12:47:34 <doserj> http://hackage.haskell.org/trac/ghc/wiki/DynamicLinking
12:47:35 <lambdabot> Title: DynamicLinking - GHC - Trac
12:47:40 <earthy> soft-num: yup, it is possible. ;)
12:47:54 <tibbe> I want to write a function myMap :: (Int -> Int) -> [Int] -> Either Int [Int] which if a certain Int is seen returns Left Int instead of Right [Int], how can I terminate a map in the middle like that?
12:48:38 <chessguy> tibbe, are you trying to write myMap in terms of map?
12:48:54 <tibbe> chessguy: no, explicit recursion
12:48:58 <tibbe> just map like
12:49:24 <chessguy> but you're not parameterizing on the int you're looking for?
12:50:19 * earthy laughs at 'Toasted Monkeys and the Deathly Hallows'
12:51:01 <wli> Well, I'm happy.
12:51:26 <nominolo> > isSpace '\n'
12:51:28 <lambdabot>  True
12:51:43 <chessguy> let myMap f [] = Right []; myMap f (3:xs) = [f 3]; myMap f (x:xs) = f x : myMap f xs in myMap (+1) [1..6]
12:51:50 <chessguy> > let myMap f [] = Right []; myMap f (3:xs) = [f 3]; myMap f (x:xs) = f x : myMap f xs in myMap (+1) [1..6]
12:51:51 <lambdabot>  Couldn't match expected type `Either a1 [a]'
12:51:56 <chessguy> oops
12:52:33 <chessguy> > let myMap f [] = Right []; myMap f (3:xs) = Left (f 3); myMap f (x:xs) = Right $ f x : myMap f xs in myMap (+1) [1..6]
12:52:34 <lambdabot>  Couldn't match expected type `[a]'
12:52:39 <tibbe> chessguy: thanks
12:52:47 <tibbe> I think I've figured it out
12:52:54 <genneth> dons: what's a good way to take an indexed substring of bytestring? so say I wanted a range from n to m?
12:53:13 <chessguy> tibbe, anyway, that's the generali idea i think
12:53:19 <tibbe> :: Monad m => a -> m (Either b [a]) -> m (Either b [a]) was the type I was after
12:53:29 <doserj> take (m-n) . drop n
12:53:46 <chessguy> except B.take and B.drop
12:57:11 <chessguy> @type execState
12:57:13 <lambdabot> forall s a. State s a -> s -> s
13:00:09 <hpaste>  wli pasted "does this obey the Monad laws?" at http://hpaste.org/1818
13:01:15 <wli> return x >>= f == f x seems to be covered but I can't make heads or tails of the second
13:01:15 <chessguy> @pl r $ p $ m c "foo"
13:01:16 <lambdabot> r (p (m c "foo"))
13:02:21 <wli> m >>= (\x -> k x >>= h) == (m >>= k) >>= h
13:02:28 <AStorm> @pl r (p (m c "foo"))
13:02:28 <lambdabot> r (p (m c "foo"))
13:03:02 <AStorm> @pl r (p ((flip m) "foo"))
13:03:03 <lambdabot> r (p (flip m "foo"))
13:03:32 <AStorm> hm, not if p and r have some more args
13:04:20 <AStorm> r $ p $ flip m "foo"
13:04:26 <AStorm> that would be pointless
13:06:38 <twb> I just realized I read the question wrong.  It doesn't want me to sum the first million elements; merely the elements with *values* below one million.
13:06:57 <wli> twb: Which question is this?
13:07:23 <twb> http://hpaste.org/1814
13:07:56 <twb> I assumes I was doing it right because the naive implementation was slow!
13:08:08 <twb> What kind of problem has a working naive solution?!
13:09:09 <wli> let fibs = 1 : 2 : zipWith (+) fibs (tail fibs) in sum (takeWhile (<=10^6) fibs) is brute-force. There are actually formulae for the sums of Fibonacci numbers.
13:09:27 <twb> takeWhile, cool.
13:10:36 <ddarius> Generating functions!
13:10:41 <AStorm> the even valued terms are easy to calculate :>
13:10:57 <wli> Fibonacci numbers have generating function z/(1-z-z^2); their sum has generating function z/(1-z-z^2)/(1-z)
13:11:06 <wli> Oh, the even ones? Crap. Not so easy.
13:11:18 <wli> Well, correction to the above is
13:11:20 <AStorm> and instead of filtering x fibonnacci numbers, you can generate only them :>
13:11:30 <AStorm> use a list comprehension more correctly
13:11:47 <wli> let fibs = 1 : 2 : zipWith (+) fibs (tail fibs) in sum (filter even $ takeWhile (<=10^6) fibs)
13:12:16 <AStorm> s/fibs/evenfibs/ :>
13:13:05 <AStorm> use foldr instead of zipping
13:13:43 <AStorm> @src zipWith
13:13:43 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
13:13:43 <lambdabot> zipWith _ _      _      = []
13:13:50 <AStorm> @src foldr
13:13:50 <lambdabot> foldr k z xs = go xs
13:13:50 <lambdabot>     where go []     = z
13:13:50 <lambdabot>           go (y:ys) = y `k` go ys
13:14:29 <AStorm> hmm, wrong :>
13:14:38 <wli> Well, it's every third Fibonacci number.
13:14:47 <AStorm> wli, are you certain? :-)
13:14:59 <AStorm> the density might increase :P
13:15:41 <wli> fibs !! (n*k) is divisible by fibs !! n and fibs !! k
13:16:07 <wli> At least when you start off with 0 and 1.
13:16:49 <ddarius> O+O=E E+O=O O+E=O E+E = E 1,1,2,... O,O,E,O,O,E,...
13:16:56 <twb> The density can't increase
13:17:10 <twb> Because odd + odd = even, and odd + even = odd
13:18:15 <wli> In fact, fibs !! (n*k) is congruent to k * (fibs !! n) * (fibs !! (n+1))^(k-1) mod (fibs !! n)^2
13:18:34 <ddarius> F(z^3)
13:18:36 <AStorm> these challenges aren't even funny :>
13:18:38 <glguy> ?scheck \ k n -> (k >= 0 && n >= 0) ==> let fibs = 0 : 1 : zipWith (+) fibs (tail fibs); nk = fibs !! (n*k) in nk `mod` (fibs !! n) == 0 && nk `mod` (fibs !! k) == 0
13:18:43 <lambdabot> Exception: divide by zero
13:18:53 <twb> Am I expected to discover that on my own from first principles?
13:18:57 <glguy> ?scheck \ k n -> (k > 0 && n > 0) ==> let fibs = 0 : 1 : zipWith (+) fibs (tail fibs); nk = fibs !! (n*k) in nk `mod` (fibs !! n) == 0 && nk `mod` (fibs !! k) == 0
13:18:58 <lambdabot>   Completed 169 test(s) without failure.  But 133 did not meet ==> condition.
13:19:15 <wli> ddarius: No, (F(z) + F(wz) + F(w^2z))/3
13:19:25 <wli> ddarius: Where w is a cube root of unity.
13:20:48 <ddarius> Obviously.
13:21:16 <basti_> o.0
13:24:27 <wli> Which gives 2*z^3/(1-4*z^3-z^6)
13:24:47 <ddarius> I went the wrong way.
13:24:54 <glguy> when did this become valid???? :  do { getChar -> x ; return (succ x) }
13:25:01 <glguy> specifically the reversed arrow
13:25:22 <ddarius> > do [x] -> x; return x
13:25:22 <lambdabot>  Parse error
13:25:32 <glguy> works in ghci
13:26:16 <ddarius> Arrow notation thing ?
13:26:35 <glguy> its not used in arrow notation
13:26:38 <glguy> and I'm not using -farrows
13:28:11 <ddarius> I'd ask on the ghc-users list.
13:28:13 <wli> Okay, so the even Fibonaccis are generated by (1/5)*((2*5^(1/2)-5)/(z+2-5^(1/2)) - (5+2*5^(1/2))/(z+2+5^(1/2)))
13:29:14 <wli> Their partial sums are generated by -(1/2)/(1-z) + (1/20)*((5^(1/2)-5)/(z+2-5^(1/2)) - (5+5^(1/2))/(z+2+5^(1/2)))
13:32:09 <twb> @hoogle sieve
13:32:10 <lambdabot> No matches found
13:32:33 <wli> I'll see if I can work out easy recurrences for fibs !! (3*n)
13:32:43 * EvilTerran finishes reading the scrollback from when he went away.
13:33:34 <wli> fibs !! (3*n) == (fibs !! (2*n)) * (fibs !! (n+1)) + (fibs !! (2*n-1)) * (fibs !! n)
13:34:22 <EvilTerran> regarding "<twb> I must be doing something wrong, because loading Foo which contains "import List", it can't find group but can find List.group." -- if you've got an explicit "module Foo where" at the top of your file, the module doesn't re-export anything imported, iirc.
13:34:48 <twb> EvilTerran: yeah, I think that was the problem.  Certainly removing "module Main where" made it work.
13:35:02 <wli> Not the way to go. fibs !! (3*n + 3) = 2*(fibs !! (3*n + 1)) + (fibs !! (3*n))
13:35:15 <matthew-_> anyone around who's familiar with Data.Binary?
13:36:49 <ddarius> wli: They should fall right out of the generating function.
13:37:01 <wli> fibs !! (3*n-3) = 2*(fibs !! (3*n+1)) - 2*(fibs !! (3*n))
13:37:22 <EvilTerran> twb, alternatively, "module Foo (module Bar) where ..." tells it to re-export everything in Bar as if it's in Foo
13:37:26 <wli> ddarius: Recurrences? No...
13:37:34 <wli> woops: fibs !! (3*n-3) = 2*(fibs !! (3*n+1)) - 3*(fibs !! (3*n))
13:38:12 <EvilTerran> but, if you explicitly export anything, it doesn't do any of the implicit exports. so you'd want "module Main (module Main, module List) where..."
13:38:24 <wli> (fibs !! (3*n + 3)) - (fibs !! (3*n-3)) = (fibs !! (3*n)) + 3*(fibs !! (3*n))
13:41:03 <wli> evenFibs = 0 : 2 : zipWith (\x y -> x + 4*y) evenFibs (tail evenFibs)
13:41:17 <EvilTerran> ("this file describes the Main module. it exports everything in Main and everything in List")
13:41:32 <EvilTerran> see http://www.haskell.org/onlinereport/modules.html#sect5.2 for more
13:41:33 <lambdabot> Title: The Haskell 98 Report: Modules
13:41:46 <wli> Okay, now for the partial sums...
13:42:23 <ddarius> y[n] = Sum i.a_i x[n-i] + Sum i.b_i y[n-i] H(z) = Sum i.a_i z^-i / (1 - Sum i.b_i z^-i) Y(z) = H(z)X(z)
13:42:55 <twb> There is `all', is there `none'?
13:43:09 <byorgey> none = not . any
13:43:28 <Heffalump> none f = all (not . f)
13:43:32 <Heffalump> (as well)
13:45:36 <wli> Well, O(lg(n)) methods for computing the n-th element from the sum-of-powers representation are better here anyway.
13:46:54 <tibbe> what's the difference between StateT Writer and WriterT State?
13:47:12 <tibbe> or making your own State monad with a output list?
13:49:45 <sfultong> I just had an idea for a small syntax change... have let bindings that have explicit export parameters, and that are able to figure out any function dependency within them
13:49:52 <Heffalump> it's harder to read the current output list in Writer than in State
13:50:03 <Heffalump> in Writer, I think you have to wrap another monadic computation to get at it
13:50:08 <Heffalump> in State, you can just grab it whenever
13:50:25 <Heffalump> I suspect that StateT Writer and WriterT State are isomorphic.
13:50:29 <sfultong> becaus... the way it is now, I'm writing all these functions with in let, in let, in let.....
13:50:54 <ddarius> StateT Writer = s -> ((a,s),w)   WriterT State = s -> ((a,w),s)
13:51:23 <Heffalump> basically, Writer gives the user of monadic computations stronger guarantees
13:51:29 <pejo> sfultong, what is an export parameter?
13:51:34 <Heffalump> at the cost of less power for the creator of said computations
13:52:08 <sfultong> pejo: as in module exports.... (i.e. module something where (function1, function2...))
13:53:57 <EvilTerran> sfultong, could you use where?
13:53:57 <sfultong> I mean, has anyone here written anything non-trivial in haskell that doesn't have a huge amount of (let..in) statements?
13:54:09 <mrd> i don't use let..in much at all
13:54:09 <EvilTerran> i almost never use let..in.., TBH.
13:54:16 <sfultong> hmm
13:54:20 <mrd> now, ..where i use a lot =)
13:54:21 <sfultong> can where do what I want?
13:54:34 <sfultong> maybe I just need to use where more
13:54:37 <EvilTerran> if you want something to be available to more than one fn in your module, just don't put it in the export list
13:54:57 <byorgey> sfultong: try pasting your code?
13:55:00 <mrd> let..in is ML/expression-style and its awkward there as it is in haskell
13:55:24 <EvilTerran> and you shouldn't need more than one nesting level of let/where in most circumstances, regardless
13:55:31 <Heffalump> I like let in
13:55:35 <Heffalump> more than I used to
13:55:44 <ddarius> Heffalump: Why is that?
13:55:49 <Heffalump> it helps me construct things bottom-up
13:55:51 <EvilTerran> let...in... has its uses for clarity in places
13:56:00 <pejo> Heffalump, dont' you find that you have to scan "lots" of code to find the statement you're looking for?
13:56:07 <Heffalump> no
13:56:15 <EvilTerran> and in expressions rather than definitions
13:56:17 <Heffalump> it varies, what I want to do
13:56:19 <liyang> I tend to use just let ... a fair bit in monadic code.
13:56:38 <Heffalump> I don't find either harder to read, really. I just find one or the other easier to write depending on circumstances.
13:56:43 <EvilTerran> foo = . . . . . . (let ... in ...) . . . . . .
13:56:56 <hpaste>  sfultong pasted "my ugly in..let style code" at http://hpaste.org/1819
13:57:25 <sfultong> I find it hard to think in "where" style
13:57:42 <ddarius> sfultong: Why do you think you need nested lets?
13:58:06 <ddarius> The bindings are mutually recursive.
13:58:13 <dolio> This isn't scheme. Our lets are recursive. :)
13:58:20 <ddarius> > let a = 1:b; b = 0:a in a
13:58:21 <sfultong> huh?...
13:58:21 <lambdabot>  [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0...
13:58:54 <ddarius> sfultong: All bindings in a let are visible in all other bindings in that let.
13:59:08 <ddarius> (and themselves)
13:59:15 <sfultong> wow... have I sure been working under the wrong assumption
13:59:21 <hpaste>  EvilTerran annotated "my ugly in..let style code" with "don't need to nest let{}s" at http://hpaste.org/1819#a1
13:59:58 <sfultong> this is why I need to read more of other people's haskell code
14:00:10 <sfultong> maybe I should just read more of hpaste
14:00:33 <sfultong> what would people recommend as a good source of nicely written haskell?
14:01:14 <pejo> Large chunks of GHC are definitely nice.
14:01:46 <ddarius> The source of the libraries should be nice.  The Report definitions of functions as well, though they tend to be small.
14:01:54 <liyang> god no
14:02:05 <liyang> GHC is terrible
14:02:36 * sfultong goes to experiment with his newfound knowledge
14:03:20 <collinge> typing haskell in haskell or any of the papers in Advanced Functional Programming
14:04:57 <wli> Alrighty, almost there.
14:05:27 <_magus_> maybe a silly question, but is there an IdentityT somewhere?
14:07:18 <Heffalump> just an Identity, AFAIK
14:08:19 <_magus_> Heffalump, yeah, I found that one too... guess there's no time like the present to try to implement my first monad transformer
14:08:23 <chessguy> @hoogle IdentityT
14:08:24 <lambdabot> No matches found
14:08:40 <chessguy> @google IdentityT transformer monad
14:08:42 <lambdabot> http://www.haskell.org/pipermail/xmonad/2007-June/000476.html
14:08:42 <lambdabot> Title: [Xmonad] User-specified monad transformers
14:09:07 <chessguy> _magus_,  i'm almost sure it exists
14:10:09 <chessguy> aha
14:10:11 <chessguy> http://www.haskell.org/pipermail/libraries/2007-June/007560.html
14:10:11 <lambdabot> Title: Adding IdentityT to mtl
14:10:22 <chessguy> _magus_, ^^
14:10:57 <_magus_> thanks, chessguy
14:11:04 <chessguy> sure
14:11:09 <chessguy> ?type execState
14:11:11 <lambdabot> forall s a. State s a -> s -> s
14:11:30 <_magus_> that email does mention something along the lines of what I've been pondering too
14:13:26 <twb> What's butlast called in Haskell?
14:13:37 <chessguy> @src init
14:13:37 <lambdabot> init [x]    = []
14:13:37 <lambdabot> init (x:xs) = x : init xs
14:13:37 <lambdabot> init []     = undefined
14:13:46 <wli> Almost there.
14:13:58 <chessguy> @pl b r = e (bS r) s
14:13:58 <lambdabot> b = flip e s . bS
14:14:01 <twb> I would never have guessed that.
14:14:20 <chessguy> @hoogle [a] -> [a]
14:14:21 <lambdabot> Prelude.cycle :: [a] -> [a]
14:14:21 <lambdabot> Prelude.init :: [a] -> [a]
14:14:21 <lambdabot> Prelude.reverse :: [a] -> [a]
14:14:27 <chessguy> that's what hoogle is for :)
14:14:29 <sfultong> why is it called init, anyway?
14:15:03 <sfultong> to crush the spirit of the unworthy?
14:15:15 <byorgey> it's named after Simon P-J's dog, I think
14:15:28 <sfultong> ... that's terrible
14:15:42 <sfultong> no offense to simon's dog
14:15:44 <chessguy> haha
14:16:19 <byorgey> hm, I like your crushing the spirit of the unworthy explanation better
14:16:32 <sfultong> thanks :)
14:16:36 <chessguy> @remember byorgey [sfultong] why is it called init, anyway?  [byorgey] it's named after Simon P-J's dog, I think
14:16:36 <lambdabot> Done.
14:17:23 <twb> What's the difference between mod and rem?
14:17:36 <chessguy> @src mod
14:17:37 <lambdabot> Source not found. Do you think like you type?
14:17:38 <ddarius> "Correctness" and speed.
14:17:39 <byorgey> twb: it has something to do with negative numbers
14:17:45 <twb> Ah, right.
14:17:48 <byorgey> > 5 `mod` (-3)
14:17:50 <lambdabot>  -1
14:17:50 <chessguy> @source Prelude
14:17:51 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
14:17:55 <byorgey> > 5 `rem` (-3)
14:17:56 <lambdabot>  2
14:19:23 <byorgey> twb: also, they go with div and quot respectively
14:21:01 <desp> how do I throw my own custom exception?
14:21:26 <desp> I see that I could use throwDyn, but I don't know how to make an instance of class Typeable
14:22:47 <glguy> data D = E deriving Typeable
14:22:52 <ClaudiusMaximus> desp: you can use  data Foo = Bar | Quux deriving (Typeable)  (in GHC at least)
14:23:09 <sfultong> sir, you just indented my chat screen
14:23:29 <desp> ah, that didn't work for newtype
14:23:31 <desp> thanks
14:23:39 <ClaudiusMaximus> sorry, my nick isn't RFC compliant
14:23:58 <sfultong> hehe
14:24:09 <desp> ahh, -fglasgow-exts, doh.
14:24:29 <sfultong> @hoogle when
14:24:29 <lambdabot> Monad.when :: Monad a => Bool -> a () -> a ()
14:24:29 <lambdabot> Control.Monad.when :: Monad m => Bool -> m () -> m ()
14:25:14 <byorgey> @src when
14:25:14 <lambdabot> when p s = if p then s else return ()
14:26:05 <fasta> I don't like the default when
14:26:22 <glguy> don't use it?
14:26:27 <fasta> My when is in a MPTC with fundeps :)
14:27:18 <wli> Okay, I think I have it.
14:27:19 <fasta> Are the Lazy Bottoms still at the bottom? ;)
14:27:47 <sfultong> is there any reason to use pure haskell98 code?
14:27:52 <fasta> sfultong: yes
14:27:54 <byorgey> wli: partial sums of every third fibonacci number?
14:27:58 <Heffalump> portability
14:27:59 <fasta> sfultong: it works on multiple systems
14:28:07 <sfultong> ah
14:28:34 <hpaste>  wli annotated "nave version hella slow, hints for improvement?" with "not the fastest, but..." at http://hpaste.org/1814#a1
14:28:39 <fasta> sfultong: but since there is only one application that everyone runs their code on in the end it has little meaning.
14:29:01 <wli> twb: Does that help any?
14:29:27 <wli> byorgey: Take a look at what I just hpasted (http://hpaste.org/1814#a1)
14:29:33 <sfultong> fasta: you mean that since GHC is multiplatform, noone cares?
14:29:39 <byorgey> wli: wow, nice =)
14:29:50 <byorgey> I'll have to look at that in more detail later
14:29:50 <fasta> sfultong: no, I mean that GHC runs code the fastest currently.
14:30:06 <sfultong> does anyone expect that to change?
14:30:08 <twb> wli: well, actually I stopped trying to optimize fibs because, after reading the problem right, I realized that I could brute force it in seconds.
14:30:11 <fasta> sfultong: and it's open-source.
14:30:19 <sfultong> well, in the long term everything changes, I suppose
14:30:36 <fasta> sfultong: so, even when they decide to stop working on it, the rest of the community could still do something.
14:30:44 <byorgey> wli: heh, I like your error messages ;-)
14:31:10 <wli> crap sorry
14:31:37 <fasta> sfultong: Haskell + loads of extensions is difficult to implement correctly
14:32:13 <fasta> sfultong: the most likely thing that will happen is that other projects simply partially steal GHC code and make some improvements.
14:32:20 <twb> How do I get every combination of two sets, represented as lists?
14:32:26 <fasta> sfultong: i.e. it would be smarter to just commit to GHC.
14:32:34 <wli> byorgey: I should've written it as FibRing Integer Integer Integer but I was lazy.
14:32:41 <byorgey> twb: you mean cartesian product?
14:32:45 <byorgey> wli: right
14:32:46 <twb> e.g. f [1,2] [4,7] ==> [(1,4),(1,7),(2,4),(2,7)]
14:32:50 <sfultong> fasta: as I suspected
14:33:03 <byorgey> > sequence [1,2] [4,7]
14:33:04 <lambdabot>   add an instance declaration for (Num ([t] -> a))
14:33:04 <lambdabot>     In the expression: 2
14:33:06 <fasta> sfultong: GHC is a pretty active project
14:33:08 <wli> byorgey: Where FibRing a b c represents (a + b*5^(1/2))/c
14:33:12 <hpaste>  dolio annotated "nave version hella slow, hints for improvement?" with "Much faster" at http://hpaste.org/1814#a2
14:33:12 <byorgey> > sequence [[1,2] [4,7]]
14:33:13 <lambdabot>  Couldn't match expected type `t -> m a'
14:33:27 <byorgey> > sequence [[1,2], [4,7]]
14:33:28 <lambdabot>  [[1,4],[1,7],[2,4],[2,7]]
14:33:39 <twb> Yow.
14:33:45 <basti_> o.o
14:33:49 <fasta> sfultong: when you find an actual critical bug(i.e. the code should work and your project doesn't anymore) it's fixed pretty fast. In my case 2 days for a full fix.
14:34:07 <wli> twb: I suspect that should run relatively swiftly.
14:34:20 <byorgey> twb: the list monad comes in handy for stuff =)
14:34:28 <wli> twb: The input should be eulerProblem2 $ 10^6
14:34:50 <twb> wli: that's scary
14:35:16 <wli> twb: How so?
14:35:31 <twb> It's >2 lines :-)
14:35:44 <dolio> twb: See my solution. :)
14:36:05 <twb> dolio: yeah, that's what I did
14:36:16 <dolio> No, I modified it slightly.
14:36:28 <twb> a2 = sum $ filter even $ takeWhile (<=10^6) fibs
14:36:28 <twb>   where fibs = 1 : 2 : zipWith (+) fibs (tail fibs)
14:36:33 <_magus_> chess, I'm stuck on how to make IdentityT a MonadTrans (i.e. implement 'lift')... any ideas?
14:36:38 <_magus_> @hoggle lift
14:36:39 <lambdabot> Control.Monad.Trans.lift :: (MonadTrans t, Monad m) => m a -> t m a
14:36:39 <lambdabot> Text.ParserCombinators.ReadPrec.lift :: ReadP a -> ReadPrec a
14:36:39 <lambdabot> Language.Haskell.TH.Syntax.lift :: Lift t => t -> Q Exp
14:37:09 <dolio> twb: You were taking the first 1 million elements of the list, not the elements <= 1 million.
14:37:19 <dolio> The former is much slower. :)
14:37:23 <twb> dolio: I didn't PASTE my revised version
14:37:29 <dolio> Ah.
14:37:34 <fasta> The pointer model of computation is truly horrible.
14:37:49 <twb> 06:05 <twb> I just realized I read the question wrong.  It doesn't want me to sum the first million elements; merely the elements with *values* below one million.
14:38:00 <dolio> Ah, my bad. :)
14:38:04 <wli> dolio: Well, try all the even Fibonacci numbers <= 10^12...
14:38:07 <twb> Which of course caused wli to look at the problem :-)
14:39:51 <glguy> > length $ takeWhile (<= 10^12) $ let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs -- here goes nuthin'
14:39:53 <lambdabot>  60
14:40:02 <dolio> wli: 10^12 takes 0.008 seconds.
14:40:03 <sfultong> wow
14:40:10 <twb> 07:32 <byorgey> > sequence [[1,2], [4,7]]
14:40:14 <fasta> I now had  a <- val ref_a;  write_ref ref_b a, instead of simply saying that the data structure containing ref_b should simply be ref_a....  This went through 4 layers of data structures code... and got knows the function depths (at least 20).  That was not funny.
14:40:14 <wli> dolio: I start noticing around 10^(10^4)
14:40:27 <twb> Doesn't work as I expect for sequence [[999..100],[999..100]]
14:40:35 <twb> Oops
14:40:46 <twb> Of course .. needs the values to be the other way around
14:41:03 <wli> dolio: Very noticeable around 10^(10^5)
14:41:09 <sfultong> heh
14:41:15 * dolio >>= dinner
14:41:36 <wli> Yeah, the naive one spins at 10^(10^5)
14:42:01 <sfultong> anyone here want to start a lojban commune?
14:42:10 * glguy wonders what it means to extract a value from dolio and then apply it to dinner
14:42:27 <wli> 10^(10^5) is 5.78 secs, 286696852 bytes here
14:42:47 <sfultong> glguy: it doesn't sound pleasant
14:43:23 <wli> Seeing how long 10^(10^6) takes.
14:43:52 <fasta> sfultong: I thought shapr already was a fan of that
14:43:58 <wli> 10^(10^6) takes 69.95 secs, 4020022424 bytes here.
14:45:04 <fasta> In the 13th argument of ...  <- (yes, I really need that many)
14:45:20 <Korollary> glguy: it's dinner translating dolio's position by giving him energy.
14:45:23 <_magus_> @hoogle IdentityT
14:45:24 <lambdabot> No matches found
14:45:39 <_magus_> @google IdentityT transformer
14:45:40 <lambdabot> http://www.haskell.org/pipermail/xmonad/2007-June/000476.html
14:45:40 <lambdabot> Title: [Xmonad] User-specified monad transformers
14:45:46 <wli> http://holomorphy.com/~wli/EvenFib.hs <-- massively overwrought solution to the Euler problem twb was working on.
14:45:57 <AStorm> wli, try 1000!
14:46:22 * glguy wishes that they'd have stopped making new Project Euler problems when he had 100%
14:46:25 <AStorm> (you have to write the factorial strictly)
14:46:30 <twb> I'm never sure whether it's a good or a bad thing when I trigger these autistic fits.
14:46:38 <ddarius> _magus_: lift = IdentityT
14:46:52 <wli> AStorm: That's smaller than 10^(10^6) by quite some
14:46:56 <fasta> I wish I could command the army of bored programmers working on Project Euler.
14:47:10 <fasta> And let them do something actually useful.
14:47:12 <twb> I'm not bored!
14:47:14 <Korollary> like web 3.0?
14:47:21 <twb> web 3.0 is called usenet
14:47:36 <AStorm> wli, but slower to count :>
14:47:40 <twb> web 3.0 is when all the ajax dicks realize that they've been breaking the internet, and kill themselves
14:47:42 <wli> AStorm: For 1000! it took 0.06 secs, 2477500 bytes
14:47:48 <AStorm> wli, :>
14:47:56 <AStorm> try then 1000!^100!
14:48:00 <Korollary> ajacks dix
14:48:03 <AStorm> tell me when that finishes
14:48:04 <fasta> twb: call me when that happens
14:48:12 <twb> walt disney style
14:48:13 <fasta> twb: can't miss that, can I?
14:48:25 <wli> AStorm: 10^(10^6) took a minute already. 4000! is larger than that so I'm not bothering with it.
14:48:28 <twb> We shall wade to usenet over rivers of blood
14:48:29 <_magus_> ddarius, that's what I thought too... but ghc doesn't like it
14:48:40 <twb> It shall be a glorious day
14:48:47 <AStorm> twb, s/usenet/star trek/ :D
14:49:04 <AStorm> That will be web 3.0
14:49:12 <AStorm> or some other cyberspace :>
14:49:26 <_magus_> ddarius, I'll post the code... maybe I've made some silly mistake
14:49:30 <wli> AStorm: Anyway, it's sufficiently blistering fast it can do vastly larger problems.
14:49:31 <twb> A campy American `70s pulp sci-fi?
14:49:40 <AStorm> We're not even there with web 2.0 - that AJAX they call is just a bastardization of Web 1.0
14:49:41 <AStorm> :>
14:49:45 <twb> It's on TV FFS
14:50:28 <twb> TV is just literature for the uneducated masses
14:50:31 <wli> AStorm: It can be done much faster with more thought/intelligence put into it so as to completely avoid rational arithmetic, computations over Q(5^(1/2)), etc., but I wasted enough time screwing with the generating function.
14:50:42 <AStorm> :>
14:50:46 <twb> The crass, seething billions
14:50:57 <fasta> twb: I think you are raping the literature word now
14:51:01 <hpaste>  _magus_ pasted "IdentityT" at http://hpaste.org/1820
14:51:03 <AStorm> I still dislike playing with this kind of math, prefer doing something useful :>
14:51:10 <twb> They pop a soma and sit back to watch feelies
14:51:16 <wli> So does the crap at http://hpaste.org/1818 obey the monad laws or what?
14:51:18 <AStorm> Of course, when it's needed, then it will be done
14:51:33 <wli> I can't figure out if the second monad law holds or not.
14:51:49 <_magus_> ddarius, http://hpaste.org/1820
14:52:00 <ddarius> _magus_: It announces it.
14:52:22 <wli> AStorm: I generally prefer problems whose solution requires generating output in response to an input.
14:52:24 <ddarius> _magus_: You want IdentityT to be an instance, not IdentityT m
14:52:25 <fasta> wli: it looks very similar to another tree which is.
14:52:32 <twb> What's the elegant way to generate all possible products of two three-digit (base 10) natural numbers?
14:52:37 <wli> fasta: Which tree is that?
14:52:37 <fasta> wli: no time for a full look
14:52:45 <fasta> wli: it was a zipper
14:52:48 <twb> I think I want mappend, but I don't know what it's called.
14:53:00 <wli> twb: Define "3-digit"
14:53:01 <AStorm> wli, it seems to fail the second law
14:53:07 <_magus_> ddarius, ah, of course... thanks, that took care of it
14:53:08 <glguy> [ x * y | x <- [100..999], y <- [x .. 999] ]
14:53:09 <twb> wli: [100..999]
14:53:12 <ddarius> wli: It's a free monad, so yes.
14:53:15 <AStorm> m >>= return = m
14:53:20 <twb> glguy: aha
14:53:37 <AStorm> ah, foiled!
14:53:45 <AStorm> (I'm wrong, not that paste :P )
14:53:45 <msouth> another success by the monad liberation army
14:53:53 <wli> ddarius: Sounds like a good deal!
14:54:15 <ddarius> wli: I'd define fmap in terms of (>>=), or just use liftM.
14:54:43 <ddarius> instance Functor (DecisionTree s) where fmap = liftM
14:54:53 <AStorm> wli, oh, it does fail the second step with Branch
14:55:22 <wli> ddarius: More explicit helps me keep track of what's going on.
14:55:22 <oerjan> AStorm: what?
14:55:31 <wli> AStorm: Explain?
14:55:33 <hpaste>  desp pasted "why is this so slow?" at http://hpaste.org/1821
14:55:54 <fasta> One thing I don't like about the type system is that when it needs a very general instance, because a certain function isn't used. It would be nice to temporarily say: use this instance. (without giving it a complete type signature)
14:56:03 <desp> any ideas?
14:56:12 <desp> it uses 99% of %time and %allocs
14:56:20 <wli> I actually don't understand why it succeeds, if it does.
14:56:27 <ddarius> fasta: You can fake partial type signatures.
14:56:31 <wli> Or rather, why the law holds, if it does.
14:56:34 <hpaste>  desp annotated "why is this so slow?" with "profiler output" at http://hpaste.org/1821#a1
14:56:50 <AStorm> wli, when you have that monad instantiated with Branch it moves the Leaf one level below
14:56:53 <byorgey> desp: try using foldl
14:57:04 <msouth> desp: you revealed to haskell that it was related to dna, and I automatically knew that it should take a long time.
14:57:05 <fasta> ddarius: you mean by doing let _ = <function> :: <force type>
14:57:07 <byorgey> desp: I meant to say, try using foldl' instead of foldl
14:57:12 <oerjan> wli: just evaluate x >>= Leaf
14:57:12 <msouth> s/I/it
14:57:16 <AStorm> wli, and you don't get the same output
14:57:23 <ddarius> fasta: Something like that.
14:57:26 <AStorm> oerjan, that's not enough, it has to work with Branch too :>
14:57:36 <wli> AStorm: Okay, when does this happen? Very very slow motion.
14:57:38 <desp> msouth: it's not the dna that you think of ;)
14:57:43 <ddarius> @google site:haskell.org inurl:pipermail oleg partial type signatures
14:57:43 <fasta> ddarius: ideally that would work via some IDE feature
14:57:43 <oerjan> AStorm: i mean for x >>= return = x
14:57:44 <lambdabot> http://www.haskell.org/pipermail/haskell-cafe/2004-August/006606.html
14:57:44 <lambdabot> Title: [Haskell-cafe] Partial signatures
14:57:50 <AStorm> wli, when you build a branch of leaves
14:57:58 <AStorm> and then do >>= some other Leaf
14:58:03 <desp> byorgey: I think it makes no differnce
14:58:07 <AStorm> then the Leaf gets pushed one level deep
14:58:16 <byorgey> desp: OK, it was just a thought
14:58:28 <oerjan> AStorm, wli: this is essentially coinduction, i think
14:58:34 <AStorm> oerjan, yes
14:58:39 <AStorm> but not totally
14:59:08 <wli> AStorm: Maybe a more concrete example, like (Branch s xs) >>= \x -> Leaf x ?
14:59:15 <fasta> ddarius: yes, that's the same.
14:59:30 <twb> Ooh, never seen inurl: before.  That requires a particular string to be in the final result URLs?
14:59:46 <fasta> twb: yes
14:59:47 <oerjan> by coinduction, you can assume map (>>= Leaf) xs = map id xs when proving x >>= Leaf = x
14:59:53 <twb> Neato.
15:00:02 <ddarius> It's easy to see that m >>= return holds
15:00:07 <fasta> twb: there is a webpage specifying a large subset of the language Google accepts
15:00:11 <wli> oerjan: So it does obey the laws?
15:00:21 <AStorm> right
15:00:49 <oerjan> wli: at least the first and second. as ddarius said, it is a typical free monad so it should obey all.
15:01:06 <AStorm> transitivity, hmm, let's check
15:01:07 <wli> The one I can't tell if it holds is:  m >>= (\x -> k x >>= h)  =  (m >>= k) >>= h
15:01:33 <wli> The first two I checked relatively easily.
15:01:37 <AStorm> I'd try Quickcheck on it :P
15:02:06 <oerjan> well, if m is Leaf x then it is easy.
15:02:19 <wli> Yeah, I got the Leaf x case.
15:03:35 <AStorm> With branch it should work too
15:03:37 <oerjan> lessee, need to show Branch s (map (>>= \x -> k x >>= h)) xs = (Branch s (map (>>= k)) xs) >>= h
15:03:44 <AStorm> as it just applies f over all subtrees
15:04:50 <oerjan> er, not quite right parenthesized
15:05:09 <twb> Aw, Euler 5 can't be brute forced in seconds
15:05:13 <oerjan> lessee, need to show Branch s (map (>>= \x -> k x >>= h) xs) = (Branch s (map (>>= k) xs)) >>= h
15:05:13 <AStorm> >>= f >>=g and >>=g >>=f are identical (sans side effects of the functions)
15:05:30 <hpaste>  ddarius annotated "does this obey the Monad laws?" with "as a free monad" at http://hpaste.org/1818#a1
15:05:56 <AStorm> oerjan, it does, by induction
15:06:09 <AStorm> because the tree can contain only Leaves and Branches
15:06:11 <wli> (Branch s (map (>>= k)) xs) >>= h = Branch s (map (>>=h) (map (>>=k) xs) -- paren fsckage
15:06:18 <oerjan> by coinduction
15:06:25 <AStorm> oerjan, hmm, right :>
15:07:11 <wli> = Branch s (map ((>>=h) . (>>=k)) xs) ?
15:07:42 <oerjan> wli: you cannot switch k and h
15:08:02 <AStorm> wli, this assumes already that it fulfills the laws :P
15:08:13 <wli> oerjan: I was only reducing (Branch s (map (>>= k)) xs) >>= h
15:08:37 <oerjan> oh right
15:09:16 <oerjan> correct so far, i think
15:09:37 <wli> lambdabot's pointless bits say (>>=h) . (>>=k) and (>>= \x -> k x >>= h) are identical
15:09:44 <AStorm> because they are
15:10:13 <oerjan> er, is @pl assuming the monad laws?
15:10:21 <wli> So the third law is proved. Now I can move on to the rest of the nondeterminism bits.
15:10:37 <wli> oerjan: I don't know. I don't think so... I'll try with a different op.
15:10:38 <oerjan> (\x -> (x >>= k) >>= h)
15:10:38 <AStorm> oerjan, probably
15:10:45 <AStorm> es, to be exact
15:10:58 <chessguy> @type compose
15:11:00 <lambdabot> Not in scope: `compose'
15:11:07 <AStorm> To fully prove that, you have to also prove the Leaf case
15:11:07 <chessguy> wow, that's weird
15:11:16 <AStorm> (which is trivial)
15:11:27 <wli> It did assume monad law.
15:11:29 <chessguy> haskell doesn't have a built-in compose function, even though it's the most composable language i know :)
15:11:35 <oerjan> wli: otoh at that step you _can_ assume the monad laws, because you are using coinduction
15:11:48 <AStorm> chessguy, You mean (.)?
15:11:49 <wli> oerjan: Okay, sounds like a win.
15:11:53 <AStorm> @src (.)
15:11:53 <lambdabot> (.) f g x = f (g x)
15:11:58 <oerjan> for a subterm
15:12:10 <SamB> chessguy: that's because Haskell is composable enough not to need it built-in
15:12:12 <SamB> duh
15:12:18 <chessguy> :)
15:12:36 <wli> Now I want to dequeue from one of these things using that extra field I've got there as state.
15:12:51 <chessguy> AStorm, i just meant that it's funny that as many ways as haskell provides to compose things, none of them are actually called 'compose'
15:13:14 <ddarius> @pl \xs -> map f $ map g xs
15:13:14 <lambdabot> map (f . g)
15:13:17 <AStorm> that is too generic a name
15:13:22 <SamB> chessguy: isn't (.) called that?
15:13:23 <chessguy> i guess
15:13:44 <AStorm> it should be 
15:13:46 <oerjan> chessguy: that is like thinking it is funny that haskell doesn't have a datatype called Data
15:13:50 <SamB> AStorm: too hard to type
15:13:58 <oerjan> otoh it does have a class now...
15:13:59 <AStorm> SamB, altgr+.
15:14:02 <AStorm> :>
15:14:17 <SamB> my right alt key doesn't do such fancy things
15:14:33 <twb> SamB: C-x 8, then
15:14:35 <AStorm> SamB, you poor man, how can you type  then? :P
15:14:43 <twb> 
15:14:44 <AStorm> or other fancy letters?
15:14:46 <twb> 
15:14:50 <AStorm> twb, heh :-)
15:14:56 <AStorm> emacs as an irc client?
15:14:59 <twb> \Omega RET
15:15:04 <twb> 08:14 *** twb CTCP VERSION rcirc on GNU Emacs 22.1.1
15:15:09 <AStorm> omg
15:15:22 <AStorm> do you use it as a web browser too?
15:15:26 <twb> Yes
15:15:27 <AStorm> email client?
15:15:37 <twb> Not any more
15:15:37 <AStorm> X window manager?
15:15:48 <AStorm> (all are possible)
15:15:51 <twb> No, I use Screen as my windowing system.  It includes a window manager.
15:15:56 <AStorm> :>
15:16:01 <twb> xwem requires XEmacs, which is crap
15:16:29 <AStorm> If only Emacs used Haskell as the programming language...
15:16:30 <twb> (Because Emacs does not and will not contain an FFI)
15:16:35 <AStorm> I don't like parens that much :>
15:17:22 <twb> It's worth using parens just so you can use paredit :-)
15:17:28 <AStorm> ?
15:17:45 <sfultong> I like using massive anonymous functions so that my haskell looks like lisp
15:17:54 <sfultong> *massive & nested
15:18:27 <twb> That sounds more like Scheme
15:18:35 <twb> Particularly academic scheme
15:18:42 <sfultong> well, I don't know scheme, so that's plausible
15:18:54 <wli> Okay, I think I can dequeue from these fsckers now, too.
15:18:56 <AStorm> It's similar enough to Lisp ;P
15:19:07 <twb> Real world Lisp is mostly defmethod and defclass
15:19:21 <fasta> Lisp, the mostly overloaded word in existence.
15:19:46 <sfultong> hmm... I count 2 meanings that I know of...
15:20:11 <roconnor> cabal is impossible to use with only user privledges
15:20:14 <fasta> sfultong: a book about Haskell claims Haskell is a lisp
15:20:20 <AStorm> 3 meanings :P
15:20:25 <AStorm> http://onelook.com/?w=lisp&ls=a
15:20:27 <lambdabot> Title: lisp - OneLook Dictionary Search
15:20:47 <sfultong> well... could you make lisp into haskell with lisp macros?
15:21:02 <AStorm> sfultong, almost impossible
15:21:03 <twb> Lisp generally means any Lisp or Scheme dialect since about 1984
15:21:12 <twb> @google Better Scheme
15:21:14 <AStorm> Lisp is too dynamic
15:21:14 <lambdabot> http://www.cs.oberlin.edu/~jwalker/bscheme/
15:21:14 <lambdabot> Title: Better Scheme
15:21:23 <twb> That has some Haskellly semantics
15:21:48 <wli> Okay, now I've turned this into a nondeterminism monad, I think.
15:21:55 <tibbe> where's that cute picture of how foldr works?
15:22:01 <roconnor> @foldr
15:22:11 <AStorm> @where foldr
15:22:12 <lambdabot> I know nothing about foldr.
15:22:41 <twb> @where isTheLove
15:22:41 <lambdabot> I know nothing about isthelove.
15:23:15 <EvilTerran> foldr.com ?
15:23:40 <fasta> @google site:yi.org cale foldr image
15:23:41 <lambdabot> No Result Found.
15:23:47 <fasta> @google site:yi.org foldr image
15:23:48 <lambdabot> No Result Found.
15:23:56 <fasta> @google site:yi.cale.org foldr image
15:23:57 <lambdabot> No Result Found.
15:23:59 <ddarius> www.foldr.com?
15:24:02 <fasta> Oh, whatever
15:24:36 <twb> Incidentally, both Scheme48 and SBCL support compile-time type inference, it's just that it tends to provoke warnings rather than errors
15:25:32 <twb> Also s48 tends to be pretty lazy about inference, giving a lot of stuff an "anything" type when it could infer more.
15:25:56 <Cale> fasta: one sec
15:26:04 <fasta> Cale: I am not interested
15:26:10 <msouth> tibbe: are you talking about this: http://en.wikipedia.org/wiki/Fold_(higher-order_function)
15:26:13 <Cale> http://cale.yi.org/index.php/Fold_Diagrams
15:26:17 <lambdabot> Title: Fold Diagrams - CaleWiki
15:26:18 <fasta> Cale: tibbe was
15:26:30 <Cale> tibbe: there you go
15:26:43 <tibbe> msouth: thanks
15:26:48 <tibbe> thanks
15:26:52 <twb> 8am, bedtime
15:27:04 <twb> I'm starting to melt
15:27:07 <fasta> @where+ foldr http://cale.yi.org/index.php/Fold_Diagrams
15:27:08 <lambdabot> Done.
15:27:13 <fasta> @where foldr
15:27:13 <lambdabot> http://cale.yi.org/index.php/Fold_Diagrams
15:27:34 <dylan> house-cleaning. :)
15:28:53 <chessguy> @hoogle floor
15:28:53 <lambdabot> Prelude.floor :: (RealFrac a, Integral b) => a -> b
15:29:07 <AStorm> @hoogle clean
15:29:07 <lambdabot> Distribution.Setup.CleanCmd :: Action
15:29:07 <lambdabot> Distribution.Simple.postClean :: UserHooks -> Args -> Int -> LocalBuildInfo -> IO ExitCode
15:29:07 <lambdabot> Distribution.Simple.preClean :: UserHooks -> Args -> Int -> IO HookedBuildInfo
15:29:20 <AStorm> nope :>
15:30:50 <chessguy> > floor $ 2 / 3
15:30:51 <lambdabot>  0
15:31:25 <EvilTerran> > 2 `div` 3
15:31:26 <lambdabot>  0
15:32:51 <wli> map (`mod` 5) $ flattenDT $ Branch [] [Branch [] [Leaf j | j <- [5*i..5*i+4]] | i <- [0..5]] -- this seems to get the right results
15:33:39 <wli> Let's see if I can use it for N queens.
15:38:40 <chessguy> hrm
15:39:49 <AStorm> > floor $ 2.0 / 3.0
15:39:50 <lambdabot>  0
15:39:57 <AStorm> > 2.0 `div` 3.0
15:39:58 <lambdabot>  Add a type signature
15:40:02 <AStorm> hmm :>
15:40:25 <AStorm> @type div
15:40:27 <lambdabot> forall a. (Integral a) => a -> a -> a
15:40:39 <AStorm> ahha, integral.
15:40:56 <AStorm> > 2.0 / 3.0
15:40:58 <lambdabot>  0.6666666666666666
15:40:59 <EvilTerran> div is specifically integer division, rounding down.
15:41:12 <chessguy_> is there an easy way to do getFirsts :: [(a,a,a)] -> [a]; getFirsts list = ... - list of the first of each tuple
15:41:16 <EvilTerran> > (-3) `div` 2
15:41:17 <AStorm> > 2 / 3
15:41:18 <lambdabot>  -2
15:41:18 <lambdabot>  0.6666666666666666
15:41:27 <AStorm> mhm
15:41:34 <EvilTerran> > 3 `div` (-2)
15:41:35 <lambdabot>  -2
15:41:53 <EvilTerran> chessguy, map (\(x,_,_) -> x)?
15:42:09 <AStorm> is there a "round to zero" function?
15:42:28 <Korollary> floor?
15:42:34 <AStorm> (as opposed to floor "round to negative infinity")
15:42:36 <EvilTerran> > floor (-1.5)
15:42:37 <lambdabot>  -2
15:42:46 <Korollary> ah
15:42:58 <Korollary> different rounding mode
15:43:04 <EvilTerran> (\x -> if x < 0 then ceil x else floor x)? *shrug*
15:43:15 <AStorm> EvilTerran, it's too evil :P
15:43:28 <Korollary> @hoogle round
15:43:29 <lambdabot> Prelude.round :: (RealFrac a, Integral b) => a -> b
15:43:29 <lambdabot> Text.Html.background :: String -> HtmlAttr
15:43:29 <lambdabot> System.Win32.Info.cOLOR_BACKGROUND :: SystemColor
15:43:35 <Korollary> bah
15:43:44 <AStorm> > round -1.66
15:43:45 <lambdabot>   add an instance declaration for (Fractional (a -> b))
15:43:57 <AStorm> > round (-1.66)
15:43:59 <lambdabot>  -2
15:44:07 <allbery_b> @hoogle (Fractional a,Integral b) => a -> b
15:44:08 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
15:44:08 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
15:44:08 <lambdabot> Control.Monad.Writer.tell :: MonadWriter w m => w -> m ()
15:44:12 <allbery_b> bah
15:44:29 <allbery_b> @hoogle (RealFrac a,Integral b) => a -> b
15:44:29 <lambdabot> Prelude.ceiling :: (RealFrac a, Integral b) => a -> b
15:44:30 <lambdabot> Prelude.floor :: (RealFrac a, Integral b) => a -> b
15:44:30 <lambdabot> Prelude.round :: (RealFrac a, Integral b) => a -> b
15:44:37 <AStorm> Weak :P
15:46:00 <AStorm> hmm, another Q: Is there a Haskell interpreter supporting something like Python's help() and dir()?
15:46:06 <EvilTerran> (\x -> sign x * floor (abs x)), aka (uncurry (*) . (sign *** floor . abs)))
15:46:14 <EvilTerran> >:]
15:46:16 <sfultong> > truncate 2 / 3
15:46:17 <lambdabot>  Add a type signature
15:46:21 <sfultong> > truncate (2 / 3)
15:46:22 <lambdabot>  0
15:46:30 <EvilTerran> ?type truncate
15:46:31 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
15:46:33 <allbery_b> @pl \x -> sign x * floor (abs x)
15:46:34 <lambdabot> liftM2 (*) sign (floor . abs)
15:46:37 <oerjan> AStorm: quot is like div but with different negative behavior
15:46:39 <EvilTerran> ?index truncate
15:46:39 <lambdabot> Prelude
15:46:40 <AStorm> Ah, so there is one! :-)
15:46:44 <sfultong> :)
15:47:32 <AStorm> Ok, what about my Q then?
15:47:40 <EvilTerran> > (-2) `quot` 3
15:47:42 <lambdabot>  0
15:47:47 <AStorm> Any interpreter with such nice help features?
15:47:49 <kalmar> herro
15:47:52 <EvilTerran> ?type quot
15:47:54 <lambdabot> forall a. (Integral a) => a -> a -> a
15:48:02 <EvilTerran> "integer division truncated toward zero"
15:48:19 <EvilTerran> AStorm, what to help() and dir() do?
15:48:23 <kalmar> a question for any ICFPers (and others)
15:48:29 <oerjan> AStorm: i believe there is a ghci version with lambdabot included
15:48:35 <wli> How many N queens solutions are there for 3 <= N <= 12?
15:48:40 <oerjan> ghci-on-speed or something like that
15:48:46 <AStorm> oerjan, hmm, lack of docstrings will bite me anyway
15:48:51 <kalmar> is there a simple bitmap image library or somehting like that
15:48:54 <AStorm> EvilTerran, guess, what are these for :P
15:49:06 <EvilTerran> help(), i can guess. dir(), not so sure.
15:49:23 <AStorm> dir lists all things in a given class or module
15:49:29 <kalmar> I have ended up inthe situation with an array of pixel data, but I know nothing of image formats
15:49:36 <fasta> There is ghci on acid
15:49:50 <AStorm> fasta, and it can automatically browse the docs?
15:49:50 <fasta> But since it's not packaged, I don't bother.
15:49:51 <oerjan> AStorm: in hugs, :f quot should bring up the source for quot
15:50:04 <oerjan> as long as quot is currently loaded
15:50:10 <allbery_b> :browse might be helpful
15:50:12 <fasta> AStorm: 1) That's ill defined 2) If I understand you, no
15:50:16 <allbery_b> (in ghci)
15:50:30 <hpaste>  ihope pasted "Can this be done?" at http://hpaste.org/1822
15:50:46 <AStorm> fasta, uhm, you know, print me some description
15:50:55 <AStorm> In Python, there are built in docstrings
15:51:05 <fasta> AStorm: Not all functions are documented
15:51:14 <ihope> I'm trying to use monads to cleverly translate lambda calculus into SKI calculus.
15:51:22 <AStorm> Yes, I expect only _most_ documentation to be available
15:51:25 <oerjan> AStorm: haskell has haddock
15:51:49 <fasta> AStorm: You can hack up something that works.
15:51:53 <ddarius> ihope: Okay...
15:51:55 <fasta> AStorm: but nothing exists.
15:51:58 <AStorm> fasta, hmmm
15:52:07 <fasta> AStorm: it's not _that_ difficult.
15:52:09 <EvilTerran> kalmar, PPM's fairly straightforward.
15:52:12 <AStorm> yeah, like parsing Haddock? ;>
15:52:24 <ihope> I... guess I'm not sure exactly what I want. If I were, I'd code it :-)
15:52:34 <kalmar> EvilTerran: will look it up
15:52:37 <fasta> AStorm: I think all those parsers are already available somewhere.
15:52:42 <EvilTerran> http://en.wikipedia.org/wiki/Portable_pixmap
15:52:43 <lambdabot> Title: Portable pixmap - Wikipedia, the free encyclopedia
15:52:45 <allbery_b> ghc HEAD has hgaddock.ghc
15:52:50 <AStorm> fasta, yeah, e.g. in haddock :>
15:52:55 <fasta> AStorm: it's just a traversal over that AST
15:52:58 <allbery_b> I wonder if it'd be possible to crossbreed that with ghci somehow
15:53:10 <fasta> AStorm: selecting the interesting stuff and returning that to Emacs
15:53:15 <fasta> AStorm: or whatever you use
15:53:19 <EvilTerran> kalmar, maybe have a look at http://hackage.haskell.org/packages/archive/pkg-list.html#cat:Graphics ?
15:53:21 <lambdabot> http://tinyurl.com/yqov7f
15:53:32 <wli> AStorm/ddarius: If I use the DecisionTree bit as a nondeterminism monad, will it do breadth-first search and/or fair queueing across infinite solution space?
15:53:33 <fasta> But it seems nobody writes robust software for Emacs.
15:53:36 <ddarius> ihope: Use a Reader monad to define a simple environment passing interpreter only instead of interpreting just output the operations?
15:53:45 <fasta> I.e. something that does the right thing, not something that is easy to implement.
15:53:51 <wli> AStorm/ddarius: That's what I was trying to pull off.
15:53:54 <AStorm> fasta, Emacs isn't robust, hehe
15:54:05 <fasta> AStorm: No, it isn't.
15:54:07 <EvilTerran> kalmar, GD would probably do what you want
15:54:20 <ihope> ddarius: ...would more punctuation make what you just said clearer?
15:54:22 <AStorm> wli, hm, it only looks like a simple tree
15:54:25 <ddarius> wli: If you use a tree as a non-determinism monad it will evaluate however you traverse the tree.
15:54:41 <AStorm> Exactly
15:54:45 <AStorm> while walking
15:55:31 <ihope> erg0t: I sense Spanish.
15:56:01 <erg0t> ?
15:56:56 <AStorm> Portuguese? ;-)
15:58:52 <wli> AStorm/ddarius: I'll put up the dequeue function momentarily.
15:59:41 <hpaste>  wli annotated "does this obey the Monad laws?" with "DecisionTree dequeueing" at http://hpaste.org/1818#a2
15:59:44 <ihope> erg0t: "ya se fue"
16:00:12 <erg0t> ah jajaja
16:00:42 <wli> It seems to produce the right number of solutions for N queens for 3 <= N <= 11; the reference implementation is still spinning against 12.
16:02:51 <tibbe> is there a way to use pattern guards in expressions?
16:03:07 <AStorm> case is one
16:03:41 <wli> I guess I need MonadZero for guard.
16:04:56 <AStorm> tibbe, in case expression you can use pattern matching
16:05:28 <tibbe> AStorm: ok, what does that look like?
16:05:59 <AStorm> http://cs.anu.edu.au/Student/comp1100/haskell/tourofsyntax.html#case
16:06:01 <lambdabot> Title: Tour of the Haskell Syntax, http://tinyurl.com/kf5wj
16:06:03 <allbery_b> similar to how it looks in definitions, except with -> instead of =
16:06:06 <EvilTerran> > (case () of _ | 1 > 2 -> "one" | 2 < 3 -> "two" | otherwise -> "three") ++ "."
16:06:07 <lambdabot>  "two."
16:06:58 <EvilTerran> (or "case () of () | ...", or any others of a number of possible variations
16:07:43 <kalmar> ?hoogle Char -> Word8
16:07:44 <lambdabot> No matches, try a more general search
16:08:02 <AStorm> kalmar, it should be directly convertible
16:08:10 <AStorm> but then, who knows :>
16:08:17 <oerjan> EvilTerran: that's not what is usually called pattern guards
16:08:28 <kalmar> > '\STX' :: Word8
16:08:29 <lambdabot>  Couldn't match expected type `Word8' against inferred type `Char'
16:08:31 <oerjan> although it may be what tibbe meant
16:08:36 <AStorm> oerjan, it is a pattern match though
16:08:51 <EvilTerran> oh, whups, pattern guards. yeah, sorry =/
16:08:55 <AStorm> kalmar, hmm, CChar instead
16:09:08 <AStorm> or Char8
16:09:17 <AStorm> @hoogle CChar
16:09:17 <lambdabot> Foreign.C.Types.CChar :: data CChar
16:09:18 <lambdabot> Foreign.C.String.castCharToCChar :: Char -> CChar
16:09:18 <lambdabot> Foreign.C.String.castCCharToChar :: CChar -> Char
16:09:20 <kalmar> but String = [Char]
16:09:32 <kalmar> never midn it's not hard
16:09:32 <AStorm> Listen to the bot :-)
16:09:36 <kalmar> just didn't feel like writing it
16:09:50 <EvilTerran> > (case () of () | Just x <- listToMaybe [2..] -> x)
16:09:50 <lambdabot>  Parse error
16:09:57 <AStorm> and then, you can use ord on the CChar
16:10:08 <AStorm> @hoogle ord
16:10:08 <lambdabot> Char.ord :: Char -> Int
16:10:08 <lambdabot> Prelude.Ord :: class Eq a => Ord a
16:10:08 <lambdabot> Text.Html.ordList :: HTML a => [a] -> Html
16:10:19 <AStorm> or even, directly :P
16:10:25 <allbery_b> doesn't lambdabot use Language.Haskell to preparse, so it wouldn't do pattern guards anyway?
16:10:28 <oerjan> EvilTerran: lambdabot doesn't allow most extensions
16:10:32 <tibbe> anyone have a ByteString parser lying around?
16:10:34 <kalmar> AStorm: I don't want an Int
16:10:44 <AStorm> kalmar, convert it to Word8 then :P
16:10:50 <kalmar> exactly
16:10:51 <AStorm> that should work
16:10:56 <kalmar> this has taken 10 times longer to discuss
16:10:57 <kalmar> than to do
16:11:01 <AStorm> :-)
16:11:07 <kalmar> I thought there might be Char -> Word8 in libs is all
16:11:11 <allbery_b> welcom to haskell :>
16:11:20 <kalmar> fromIntegral . ord does the trick
16:11:45 <EvilTerran> > (toEnum . fromEnum :: Char -> Word8) 'A'
16:11:46 <lambdabot>  65
16:11:59 <AStorm> hehe
16:12:02 <kalmar> nice
16:12:32 <EvilTerran> :D ... and, with context, you likely wouldn't need any type annotations
16:12:43 <EvilTerran> @src ord
16:12:43 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
16:13:02 <kalmar> ?index toEnum
16:13:02 <lambdabot> Prelude
16:13:05 <kalmar> good
16:13:10 <allbery_b> anyway, top level patters desugar to case expressions so anything legal there, including pattern guards, shold be accpted in a case statement by ghc
16:13:10 <AStorm> > ord 'A'
16:13:12 <lambdabot>  65
16:13:16 <AStorm> > ord 'A' :: Word8
16:13:17 <lambdabot>  Couldn't match expected type `Word8' against inferred type `Int'
16:13:18 <allbery_b> even if not by lambdabot
16:13:21 <AStorm> heh.
16:14:08 <EvilTerran> ord = fromEnum :: Char -> Int; chr = toEnum :: Int -> Char
16:14:26 <AStorm> @src chr
16:14:26 <lambdabot> Source not found. Maybe if you used more than just two fingers...
16:14:35 <AStorm> (I actually used 3 :P )
16:21:37 <|Jedai|> @src Char.chr
16:21:38 <lambdabot> Source not found. Just what do you think you're doing Dave?
16:22:34 <|Jedai|> @src Data.Char.chr
16:22:34 <lambdabot> Source not found. You type like i drive.
16:22:42 <AStorm> |Jedai|, nope, there is no source
16:22:57 <AStorm> it's probably implemented in C
16:23:01 <jedai> > chr 65
16:23:09 <lambdabot>  'A'
16:23:15 <oerjan> chr                      :: Int  -> Char
16:23:15 <oerjan> chr                      =  toEnum
16:23:25 <AStorm> @src toEnum
16:23:25 <lambdabot> Source not found. Where did you learn to type?
16:23:31 <AStorm> still :>
16:23:31 <sfultong> > chr 13
16:23:33 <lambdabot>  '\r'
16:23:37 <oerjan> @src Enum
16:23:37 <lambdabot> class  Enum a   where
16:23:37 <lambdabot>     succ                     :: a -> a
16:23:37 <lambdabot>     pred                     :: a -> a
16:23:37 <lambdabot>     toEnum                   :: Int -> a
16:23:37 <lambdabot>     fromEnum                 :: a -> Int
16:23:39 <lambdabot> [3 @more lines]
16:23:55 <jedai> @src Char
16:23:55 <lambdabot> data Char = C# Char#
16:24:00 <AStorm> oerjan, I know, but it's class-specific
16:24:16 <jedai> @source Data.Char
16:24:16 <lambdabot> http://darcs.haskell.org/packages/base/Data/Char.hs
16:24:17 <AStorm> how would one find a source of one implementation?
16:24:21 <AStorm> hehe
16:24:28 <oerjan> @src Char toEnum
16:24:28 <lambdabot> Source not found. That's something I cannot allow to happen.
16:24:37 <oerjan> that would have been it
16:24:41 * wli takes liberties with his MonadPlus instance.
16:25:01 <AStorm> > ord ''
16:25:01 <lambdabot>  Improperly terminated character constant
16:25:12 <AStorm> hates me ;P
16:25:18 <oerjan> unicode?
16:25:22 <AStorm> utf-8
16:25:50 <EvilTerran> lambdabot doesn't do unicode, AFAIK
16:25:59 <oerjan> it does in strings
16:26:00 <jedai> @source GHC.Enum
16:26:00 <lambdabot> GHC.Enum not available
16:26:09 <oerjan> but something is wrong with character syntax
16:26:10 <EvilTerran> okay, it doesn't do unicode _source_
16:26:20 <jedai> @source Data.Enum
16:26:21 <lambdabot> Data.Enum not available
16:26:29 <AStorm> @hoogle Enum
16:26:29 <lambdabot> Prelude.Enum :: class Enum a
16:26:29 <lambdabot> Prelude.enumFrom :: Enum a => a -> [a]
16:26:29 <lambdabot> Prelude.enumFromThen :: Enum a => a -> a -> [a]
16:26:52 <oerjan> actually istr it does unicode in strings as expected
16:27:47 <AStorm> > map ord "mega"
16:27:48 <lambdabot>  [937,109,101,103,97]
16:27:49 <EvilTerran> AFAICT, it seems to be only able to deal with characters >127 when expressed as escape codes...
16:27:55 <AStorm> it does
16:27:56 <oerjan> although i do wonder what would happen if you used a Unicode character whose encoding accidentally contained \ or "
16:28:11 <EvilTerran> huh. okay, i stand corrected. why did the other  not work, then?
16:28:21 <AStorm> oerjan, impossible
16:28:28 <AStorm> this wouldn't be correct unicode
16:28:34 <oerjan> EvilTerran: because something is wrong about character constants
16:28:43 <kpreid> UTF-8 was specifically designed so that can't occur
16:28:48 <tibbe> how do I convert a Word8 to a char or compare it to a ASCII char?
16:28:49 <EvilTerran> AStorm's right, every byte of a multi-byte UTF-8 character is >127
16:28:55 <oerjan> sounds like a good idea :)
16:29:13 <EvilTerran> tibbe, that's the question of the day, apparently
16:29:22 <tibbe> :)
16:29:28 <EvilTerran> > (toEnum . fromEnum) 'A' :: Word8
16:29:29 <lambdabot>  65
16:29:31 <littledan> kpreid, not all implementations throw errors for  UTF-8 codepoints which are formed like that
16:29:50 <EvilTerran> > fromEnum 'A' == fromEnum (65 :: Word8)
16:29:51 <lambdabot>  True
16:30:00 <AStorm> littledan, correct ones do
16:30:10 <EvilTerran> > toEnum (fromEnum 'A') == (65 :: Word8)
16:30:12 <lambdabot>  True
16:30:51 <EvilTerran> etc
16:30:51 <oerjan> EvilTerran: perhaps it is _first_ put through something which doesn't understand unicode, or which expects readily parsed characters but gets bytes
16:31:10 <oerjan> so then it would think a character constant had to be length 1
16:31:16 <AStorm> ?check fromEnum . toEnum == fromIntegral . ord
16:31:17 <lambdabot>  Couldn't match expected type `Int' against inferred type `Char'
16:31:24 <AStorm> hmm :>
16:31:27 <EvilTerran> oerjan, that makes sense... so it'd reject multibyte characters.
16:31:38 <EvilTerran> > '\937'
16:31:40 <lambdabot>  '\937'
16:31:41 <AStorm> ?check toEnum . fromEnum == fromIntegral . ord
16:31:42 <lambdabot>   add an instance declaration for (Eq (Char -> b))     In the expression: (to...
16:32:27 <oerjan> perhaps that Language.Haskell which was mentioned
16:33:17 <Cin> hi, can someone perhaps direct me to a Haskell tutorial which is the whole book/write-up on one HTML page?
16:33:31 <AStorm> Cin, are PDFs allowed?
16:33:53 <jfredet1> there exists pdfs, I think the gentle haskell tutorial has a all on one page option
16:33:59 <jfredet1> not surethough
16:34:20 <Cin> AStorm: no, because the thing is, I want to put the book on my Sony Reader (hand-held book reader thing), but a PDF of A4 size will not fit the screen, I would have to create a PDF myself (say, from a HTML file) and save it as the correct dimensions to fit the small screen
16:34:25 <EvilTerran> > head ""
16:34:27 <lambdabot>  '\937'
16:34:29 <jfredet1> theres also the wikibook
16:34:40 <jfredet1> hmm
16:34:58 <jfredet1> you can probably get hte TeX source for those docs too
16:35:33 <jfredet1> http://www.haskell.org/tutorial/
16:35:34 <lambdabot> Title: A Gentle Introduction to Haskell, Version 98
16:35:39 <wli> Yay! I think I've implemented a nontrivial nondeterminism monad!
16:35:55 <jfredet1> there ate doc sources, and I think they have the HTML source
16:35:55 <Cin> oh wow
16:36:00 <jfredet1> dunno if thats one page
16:36:00 <oerjan> you haven't quite decided yet? ;)
16:36:08 <jfredet1> Gentle Intro isn't bad
16:36:20 <jfredet1> I prefer the Wikibook/Yaht, but that ones good
16:36:41 <jfredet1> http://haskell.org/haskellwiki/Books_and_tutorials#Introductions_to_Haskell
16:36:43 <lambdabot> Title: Books and tutorials - HaskellWiki, http://tinyurl.com/vqzky
16:36:46 <ihope> > ""
16:36:47 <lambdabot>  "\937"
16:36:49 <jfredet1> you can troll through there, too, Cin
16:36:57 <Cin> I would export the Yaht PDF as text, but it contains images :s
16:37:25 <Cin> jfredet1: oh thanks, you are being very helpful :)
16:37:31 <ihope> Does anybody happen to already know of a clever Haskell abstraction elimination thing?
16:37:42 <jfredet1> hmm
16:37:53 <jfredet1> Cin: we do our best around here
16:38:00 <msouth> Cin: I just ran into http://cs.anu.edu.au/Student/comp1100/haskell/tourofsyntax.html
16:38:01 <lambdabot> Title: Tour of the Haskell Syntax
16:38:39 <Cin> msouth: oh, brilliant!
16:38:40 <ihope> My intuition's yelling "There's a clever way of doing this!" at me...
16:38:41 <msouth> not sure how good it is yet, but it's a good idea to have something like that around, as you will find that a lot of things that try to be "basic" forget what they are assuming
16:38:43 <asl> Hello!  does anyone know of a good tutorial which explains the record syntax in haskell?
16:39:09 <chessguy> @undo do { s <- get; return $ (h $ b s) ! p}
16:39:09 <lambdabot> get >>= \ s -> return $ (h $ b s) ! p
16:40:11 <ihope> asl: data Collection = Collection {thing1 :: Bool, thing2 :: Int}; foo = Collection True 3; makeFalse x = x {thing1 = False}
16:40:11 <jfredet1> Cin, you can also darcs get the source to Yaht
16:40:18 <ihope> I think.
16:40:19 <jfredet1> you said you just need to render it
16:40:23 <jfredet1> to Pdf, right?
16:40:31 <Cin> indeed
16:40:34 <chessguy> @pl gP p = g >>= \s -> r $ (h $ b s) ! p
16:40:34 <lambdabot> gP = (g >>=) . (r .) . flip ((!) . h . b)
16:40:52 <oerjan> ihope: my yelling wasn't enough? :)
16:40:55 <jfredet1> then a darcs get http://darcs.haskell.org/yaht will get the full source
16:40:57 <lambdabot> Title: Index of /yaht
16:41:12 <asl> iHope: thanks!  that should do it
16:41:14 <jfredet1> assuming you've got darcs available to you
16:41:15 <ihope> oerjan: nope, it has to see for itself :-)
16:42:00 <ihope> (Indeed, iHope is the "original" capitalization, and Ihope's been seen. I don't recall any ihOpe, ihoPe, or ihopE.)
16:42:20 <Cin> jfredet1: I guess I'll have trouble using darcs and building that book on Windows?
16:42:21 <oerjan> ihope: hint: do the innermost lambdas "first", then you don't need to care about them when doing the outer
16:42:25 <jfredet1> hmm.
16:42:31 <oerjan> *ones
16:42:36 <jfredet1> you can probably do it via cygwin
16:42:45 <Cin> I'll have a bob crack at it
16:43:04 <jfredet1> or- heck, what are the specs you need to rebuild it?
16:43:18 <jfredet1> sizes and whatnot? I can probably hack it together
16:43:22 <ihope> oerjan: it's not listening.
16:43:34 <Cin> jfredet1: oh, thanks! one moment, I'll get the dimensions
16:43:51 <jfredet1> Cin: I have no idea whether it will work- but i'll give it a go
16:45:10 <oerjan> asl: also, thing1 can be used as a function, thing1 :: Collection -> Bool
16:45:14 <AStorm> . operator must die
16:45:32 <AStorm> . should be used as a namespace separator, e.g. for records and so
16:45:43 <AStorm> Haskell' for ever :>
16:46:08 <tibbe> I would kill for a ByteString parsec right now
16:46:10 <Cin> jfredet1: okay. width:9.53cm, height:12.24cm
16:46:33 <jfredet1> Alright, give me a minute to figure out how to build it w/ those specs
16:46:45 <Cin> jfredet1: thanks a lot
16:46:52 <jfredet1> no problem
16:46:52 <kalmar> using ghc to compile a static (including runtime) binary... possible?
16:47:07 <AStorm> tibbe, so write one :P
16:47:25 <AStorm> kalmar, possible, but huge
16:47:29 <tibbe> AStorm: it must be ready by tomorrow when ICFP ends ;)
16:47:38 <AStorm> tibbe, :>
16:47:43 <tibbe> and I must finish my submission
16:48:19 <tibbe> I'm trying to abuse Data.Binary as a parser
16:48:42 <kalmar> AStorm: know the flag?
16:49:09 <AStorm> kalmar, hmm, -static
16:50:27 <kalmar> it says taht is the default int eh manual
16:52:08 <ihope> Static binary?
16:52:55 <hpaste>  tibbe pasted "layout problems" at http://hpaste.org/1823
16:53:11 <tibbe> can someone see why the where clause is not working?
16:54:55 <AStorm> tibbe, where is function-level, not case-level
16:55:05 <AStorm> you have it at the same indentation level as case statement
16:55:16 <tibbe> ok, not among emacs tab levels :/
16:55:35 <AStorm> it has to be the same depth as "case"
16:55:45 <AStorm> not inside it
16:56:02 <tibbe> doesn't work at 2 spaces like the case
16:56:37 <AStorm> should
16:56:42 <tibbe> doesn't :(
16:57:03 <oerjan> tibbe: if you do 2 spaces then you get the same problem with do
16:57:33 <tibbe> so less indented than do?
16:58:24 <oerjan> yes
16:58:30 <Cin> jfredet1: if you are having trouble, I can try alternative methods :)
16:58:37 <oerjan> (the do block)
16:58:55 * wli tries to think of a drastically different State Monad.
16:59:03 <AStorm> wli, why?
16:59:16 <wli> AStorm: Practice working with monads.
16:59:22 <jfredet1> Cin alright- it's  compiling
16:59:24 <tibbe> oerjan: still doesn't work
16:59:26 <jfredet1> hopefully this will work
16:59:27 <chessguy> @hoogle max
16:59:27 <lambdabot> Prelude.max :: Ord a => a -> a -> a
16:59:28 <lambdabot> List.maximumBy :: (a -> a -> a) -> [a] -> a
16:59:28 <lambdabot> Prelude.maxBound :: Bounded a => a
16:59:31 <tibbe> with do at 2 spaces and where at 1
16:59:37 <Cin> jfredet1: oh nice! :D
16:59:58 <AStorm> tibbe, where should be non-indented
17:00:07 <AStorm> the same level as do statement (probably)
17:00:15 <jfredet1> hmm, i think it worked, but I'm not sure. hang on, I'll upload it
17:00:24 <oerjan> AStorm: no, that has already been tried
17:00:28 <chessguy> @type <=
17:00:28 <tibbe> AStorm: that doesn't work
17:00:30 <lambdabot> parse error on input `<='
17:00:34 <chessguy> @type (<=)
17:00:36 <lambdabot> forall a. (Ord a) => a -> a -> Bool
17:00:54 <oerjan> 1 space _should_ work
17:01:47 <tibbe> oerjan: it doesn't
17:02:20 <oerjan> b <- getAscii at 2 spaces, where at 1 (from start of line)?
17:02:31 <tibbe> oerjan: yes
17:02:39 <jfredet1> Cin: http://users.wpi.edu/~jfredett/yaht.pdf
17:02:48 <jfredet1> hopefully that worked-
17:02:54 <hpaste>  tibbe annotated "layout problems" with "layout problems" at http://hpaste.org/1823#a1
17:02:55 <jfredet1> i had to convert from cm to pt
17:02:58 <oerjan> still the same "not in scope" error? not a different one?
17:03:20 <tibbe> oerjan: yes, not in scope
17:03:36 <chessguy> @pl \x -> x / d
17:03:37 <lambdabot> (/ d)
17:03:46 <oerjan> can you paste the current version?
17:03:55 <AStorm> tibbe, care to write it in brace + semicolon style?
17:03:57 <jfredet1> Cin: oh, and I only changed the pagewidth/height, not the text-
17:04:02 <jfredet1> if needbe, I can recompile that.
17:04:03 <tibbe> oerjan: that's really odd, doesn't work if I move it out of the where to the top level
17:04:15 <Cin> jfredet1: hrrrm
17:04:15 <oerjan> huh?
17:04:24 <wli> newtype State s a = State { runState :: s -> (a, s) } -- some analogue of a function from the state to an output and a new state like a Moore machine
17:04:31 <Cin> jfredet1: oh yeah, haha
17:04:32 <jfredet1> Cin: did it work? or is that a bad hrm?
17:05:03 <AStorm> wli, it is exactly that, yes
17:05:11 <chessguy> @pl \x -> x + deltax
17:05:11 <lambdabot> (deltax +)
17:05:22 <Cin> it works and looks fine. the only problem is that it's still A4
17:05:29 <wli> AStorm: So any alternative representation of a Moore machine will do.
17:05:40 <Cin> jfredet1: the content and text itself appears to be of the correct dimensions!
17:05:47 <oerjan> tibbe: impossible :(
17:05:48 <jfredet1> cool
17:05:58 <hpaste>  tibbe annotated "layout problems" with "layout problems" at http://hpaste.org/1823#a2
17:06:02 <jfredet1> Cin: let me know if it works on the ebookreaderthingy
17:06:06 <tibbe> oerjan: whole problem
17:06:10 <jfredet1> btw, what kind of reader was it?
17:06:17 <chessguy> > iterate (+2) 3
17:06:19 <lambdabot>  [3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,5...
17:06:32 <Cin> jfredet1: Sony Portable Reader
17:06:42 <wli> newtype State s a = State { Map s (a, s) } for instance...
17:07:08 <Cin> jfredet1: it has an electronic ink screen, i.e. without a backlight. so it's really nice for reading with, no eyestrain
17:07:09 <jfredet1> nifty- I'll have to look at it, I didn't realize they actually made those things,
17:07:12 <wli> Or newtype State s a = State { Array s (a, s) }
17:07:16 <AStorm> wli, uh, wrong
17:07:27 <AStorm> it would be a multiplex, not a state transformer
17:07:32 <jedai> tibbe: You forgot to put OPTIONS -fbang-patterns
17:07:46 <Cin> jfredet1: it's quite new, I think. here is what the page is like, unfortunately the page size itself is too big: http://img72.imageshack.us/my.php?image=egek1.jpg
17:07:47 <lambdabot> Title: ImageShack - Hosting :: egek1.jpg
17:07:48 <wli> AStorm: I need to be a bit more clever to get it accepted by the compiler, sure.
17:07:54 <tibbe> jedai: gah, nointuitive error
17:08:21 <jedai> tibbe: Yeah, I spotted it because you had 6 "continue not in scope"
17:08:28 <jfredet1> hmm
17:08:40 <jedai> tibbe: which means the declaration itself had a problem, and then...
17:08:46 <jfredet1> well, hang on, I think I can fix tha
17:08:47 <jfredet1> t
17:08:54 <Cin> jfredet1: oki coki :]
17:09:28 <AStorm> tibbe, why do you want to be strict there?
17:09:32 <wli> Actually I should be fine. It's only the final type variable that matters.
17:09:48 <jedai> tibbe: I hope it's that anyway because I don't have any other ideas... ^^
17:09:49 <tibbe> AStorm: I removed it now
17:10:01 <jfredet1> hmm
17:10:06 <tibbe> now I only have to add ContT xD
17:10:09 <wli> instance Monad (State Integer) should fly just fine.
17:10:34 <oerjan> tibbe: did that fix the error?
17:10:49 <wli> I should call it FiniteState or similar.
17:10:52 <tibbe> oerjan: yes, thanks
17:11:36 <jedai> chessguy: [3,5..]
17:11:39 <Cin> jfredet1: is it tricky?
17:11:44 <jedai> > [3,5..]
17:11:45 <lambdabot>  [3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,5...
17:11:53 <chessguy> jedai, ...
17:11:55 <chessguy> what about it
17:11:59 <oerjan> hm, perhaps it thought you were defining an operator !
17:12:23 <oerjan> that must be it
17:13:31 <jedai> chessguy: If you were testing iterate, it won't be of use to you, if you searched to define arithmetic suite, it could be ^^ So I just guessed (probably wrong from your reaction)
17:14:11 <chessguy> jedai, why won't iterate be of use to me?
17:14:35 <jfredet1> Cin, yah a little, i dont know if i'm changing anything, kdpf is a bitch
17:14:42 <kalmar> hm
17:14:53 <kalmar> any way to make ghc include gmp statically?
17:15:02 <kalmar> in binaries
17:15:02 <jedai> chessguy: No, I meant to say that if your > iterate (+2) 3 was a test of iterate then my proposition wasn't useful to you
17:15:06 <Cin> jfredet1: oh, true.
17:15:15 <chessguy> ah
17:15:26 <jfredet1> I think, however, I got it.
17:15:37 <Cin> jfredet1: oo, link?
17:15:46 <tibbe> @src Data.Binary
17:15:47 <lambdabot> Source not found. You type like i drive.
17:15:49 <jfredet1> hang on,
17:15:53 <tibbe> @source Data.Binary
17:15:53 <lambdabot> Data.Binary not available
17:15:55 <Cin> oki
17:16:38 <jfredet1> pah I wish there was a way to get what the dimensions of the page are... :/
17:17:12 <oerjan> kalmar: i vaguely recall including gmp or something like that statically may have license problems.
17:17:16 <Cin> jfredet1: I'm surprised kpdf doesn't show it ;_;
17:17:31 <jfredet1> it probably does
17:17:38 <jfredet1> I usually read .dvi's
17:17:38 <jfredet1> :)
17:17:53 <Cin> hehe
17:18:06 * wli sees how to do a Moore machine easily enough. A stack automaton would be more interesting.
17:18:24 <jfredet1> Cin: http://users.wpi.edu/~jfredett/yaht.pdf
17:18:31 <jfredet1> tell me if it even get smaller
17:18:50 <jfredet1> got*
17:19:39 <Cin> jfredet1: hrm no, the page size itself is still A4, with the content being the correct size, although this time it appears to be a bit wonky every other page
17:19:46 <jfredet1> hmm
17:19:55 <jfredet1> okay, I think i know the problem now
17:20:10 <Cin> what is it?
17:20:22 <chessguy> @type (\x -> floor ((fromIntegral x) / d)
17:20:26 <jfredet1> he's not specifying any partcular page type
17:20:31 <lambdabot> parse error (possibly incorrect indentation)
17:20:37 <chessguy> @type (\x -> floor ((fromIntegral x) / d))
17:20:39 <jfredet1> so -- all i need to do is specify the right pagetype
17:20:39 <lambdabot> Not in scope: `d'
17:20:41 <jfredet1> and it should work
17:20:46 <chessguy> @type (\x -> floor ((fromIntegral x) / ?d))
17:20:48 <lambdabot> forall a b. (Integral a, ?d::Double, Integral b) => a -> b
17:20:54 <int-e> wli: so use a state monad that includes a list in its state?
17:20:58 <Cin> jfredet1: oh I see :]
17:21:18 <chessguy> @type (\x -> floor ((fromIntegral x) / 2::Int))
17:21:20 <lambdabot>     No instance for (RealFrac Int)
17:21:20 <lambdabot>       arising from use of `floor' at <interactive>:1:7-39
17:21:39 <wli> int-e: I'm being tricky here and trying to construct a state monad for such of observable type, i.e. not using function types anywhere.
17:22:39 <jfredet1> okay, I think I've almost got it
17:22:45 <jfredet1> I am able to change the page size
17:22:54 <jfredet1> just have to fix the text again
17:23:00 <chessguy> @type (\x -> floor ((fromIntegral x) / fromIntegral (2::Int)))
17:23:02 <lambdabot> forall a b. (Integral a, Integral b) => a -> b
17:25:08 <Cin> jfredet1: \o/
17:25:44 <jfredet1> heh,
17:25:51 <jfredet1> i think I've just about got it
17:25:57 <Cin> :D
17:28:36 <jfredet1> ...
17:28:45 <jfredet1> Yaht is a formidable foe... :/
17:28:56 <Cin> :O ?
17:29:02 <jfredet1> before I was just trying to be helpful, now its personal... :/
17:29:06 <Cin> hahaha
17:31:21 <wli> int-e: It basically looks like a Moore machine, so there should be some way to get observable representations of finite state machines in there.
17:32:22 <wli> int-e: And possibly other sorts of machines, like pushdown automata.
17:33:22 <Cin> jfredet1: I am attempting to build darcs on mingw :]
17:33:29 <wli> Map (stateLabelType, Maybe inputAlphabetType, stackAlphabetType) (stateLabelType, [stackAlphabetType]) would be a representation of a pushdown automaton, for instance.
17:34:04 <wli> A deterministic one, anyway.
17:34:35 <jfredet1> heh, basicly, it appears that you just need to set the \paperwidth and \paperheight and \textwidth \textheight
17:34:42 <jfredet1> hmm, maybe theres a \pagewidth
17:34:45 <jfredet1> worth a shot
17:34:53 <wli> int-e: That one doesn't have an output alphabet, which is where it all falls down.
17:34:55 <Cin> *blink*
17:35:23 <int-e> wli: well data Stackmachine state stack input output = Stackmachine state (Array (state, Maybe stack, Maybe input) (state, Action stack output)); data Action stack output = Push stack | Output output | Nop  or something like that should fit the bil.
17:35:27 <int-e> *bill
17:35:38 <jfredet1> bag, this should really be a compiler switch
17:35:41 <jfredet1> not built in
17:35:42 <jfredet1> :/
17:35:57 * oerjan recalls there being an [a4size] option to the documentclass, or similar
17:36:08 <int-e> wli: that's missing a  | Pop
17:36:17 <wli> int-e: I've gotten that far. I'm actually ramming it through as an exercise so I have to be precise.
17:36:20 <oerjan> or was that in the package list? too long since i did latex
17:36:23 <jfredet1> bah*
17:36:52 <wli> int-e: Oh, and the point is to make a monad of it.
17:38:13 <wli> int-e: The analogue of m >>= k  = State $ \s -> let (a, s') = runState m s in runState (k a) s' seems to require some effort.
17:39:35 <Cin> is darcs written in haskell?
17:39:35 <jfredet1> hahah!
17:39:38 <jfredet1> yep
17:39:42 <jfredet1> I think I've almost got it
17:39:48 <Cin> yay!
17:40:31 <jfredet1> one last attempt at a build
17:40:34 <Cin> hehe
17:41:15 <jfredet1> hmm
17:41:17 <chessguy> err
17:41:22 <jfredet1> page length to long, bah
17:41:33 <Cin> hm?
17:41:41 <jfredet1> I've got it almost working
17:41:58 <Cin> you've got the page width correct?:o
17:42:15 <jfredet1> more or less
17:42:21 <Cin> cool!
17:42:23 <jfredet1> the page height is a little off
17:42:32 <jfredet1> so it's doing some funny wrapping stuff
17:42:40 <chessguy> i need a statement like if (somePred :: State MyState Bool) then (doSomething :: State MyState ()) else (doNothing :: State MyState ())
17:42:45 <Cin> hrrm, is it unreadable?
17:42:56 <jfredet1> not particularly, but its annoying as hell
17:43:00 <Cin> lol
17:43:12 <chessguy> should i actually write a doNothing, or is there something default i can put in there?
17:43:50 <steven_ashley> chessguy: return () ?
17:44:10 <oerjan> chessguy: if it is nothing, then use "when"
17:44:24 <chessguy> steven_ashley, but this statement is in the middle of a do block
17:44:28 <oerjan> or wait
17:44:31 <chessguy> @type when
17:44:32 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
17:44:58 <chessguy> oh, i think that will work oerjan
17:45:13 <chessguy> v <- somePred; when v doSomething
17:45:21 <wli> int-e: The good news is that I managed to hammer out my own nondeterminism monad with fair queueing.
17:45:40 <oerjan> somePred >>= flip when soSomething
17:45:51 <oerjan> *doSomething
17:46:18 <chessguy> same thing
17:46:33 <oerjan> matter of taste
17:46:53 <jfredet1> hmmm
17:47:01 <oerjan> (`when` doSomething) =<< somePred
17:48:35 <jfredet1> I think I've got it
17:48:47 <jfredet1> the text is shifted left though
17:49:00 <Cin> jfredet1: hrm, can I see?
17:49:19 <jfredet1> hang on, i just set it to recompile
17:49:22 <wli> int-e: Though it could still have issues with infinitely deep decision trees, hmm.
17:49:44 <Cin> jfredet1: oki coki
17:50:17 <jfredet1> bah, i think the pages are coming out too long
17:50:24 <jfredet1> I'll upload it, you can tell me
17:50:56 <Cin> k
17:51:30 <jfredet1> Cin: http://users.wpi.edu/~jfredett/yaht.pdf
17:51:51 <jfredet1> what were those dimensions, again?
17:51:58 <steven_ashley> chessguy: it is perfectly valid to have a return in the middle of a do block. For example the following works as expected: http://hpaste.org/1824
17:51:59 <jfredet1> 9.6 cm and 12.3?
17:52:02 <jfredet1> something like that
17:52:22 <Cin> width:9.53cm, height:12.24cm
17:52:38 <chessguy> steven_ashley, ah, of course
17:52:47 <jfredet1> which is 95mm and 122mm, so your in the a6 range, that might be the problem
17:52:50 * chessguy smacks himself
17:53:04 <jfredet1> nope, i was using a6
17:53:18 <jfredet1> wikipedia FTW: http://upload.wikimedia.org/wikipedia/commons/b/b7/A_size_illustration.png
17:53:21 <lambdabot> http://tinyurl.com/y4xz9k
17:53:28 <chessguy> too many years of {Dartmouth,GW-,Q,Visual}Basic
17:53:40 <steven_ashley> heh
17:53:50 <steven_ashley> I know the feeling :P
17:53:50 <Cin> jfredet1: hehe. hrrrm
17:54:07 <kpreid> huh
17:54:43 <kpreid> it just occurred to me that if you remove the return values from Monad (or fix the type to ()) then what you have is Monoid
17:55:23 <jfredet1> ooh! b6 is a way better fit
17:55:28 <Cin> jfredet1: here is the guide provided on how to create PDFs for the reader, it has a diagram of the required dimensions on page 4: http://downloads.oreilly.com/make/PDFsforSONYreader.pdf
17:55:30 <Cin> jfredet1: is it? :D
17:55:37 <jfredet1> no- to big
17:55:38 <jfredet1> hmm
17:55:41 <Cin> lol
17:55:55 <jfredet1> its 125 wide, i thought it was 125 long
17:55:56 <jfredet1> :/
17:56:19 <jfredet1> i'd bet B7 would be okay though
17:56:21 <Cin> :s
17:56:26 <jfredet1> 88 x 124
17:56:36 <jfredet1> its a little small, you'd think sony would just pick one
17:56:36 <jfredet1> :/
17:56:45 <Cin> lol
17:57:28 <jfredet1> I never knew paper could be so complicated.
17:57:37 <jfredet1> is the current make to big?
17:57:52 <Cin> erm
17:58:15 <Cin> yes, 8.26 x 11.69 inches
17:58:26 <Cin> which is...
17:58:31 <jfredet1> way to big
17:58:50 <jfredet1> bah- that means its still rendering as a4
17:59:04 <Cin> jfredet1: don't hate me ;_;
17:59:06 <Cin> :P
17:59:11 <jfredet1> lol, i dont hate you
17:59:12 <chessguy> @type when
17:59:15 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
17:59:23 <jfredet1> i am mildly annoyed w/ latex
18:00:00 <oerjan> jfredet1: ever tried origami? :D
18:00:07 <jfredet1> oerjan: actually
18:00:11 <jfredet1> i'm pretty good at it
18:00:12 <jfredet1> :P
18:00:21 <Cin> haha
18:01:21 <jfredet1> hmm, I wonder if i can open the pdf in Openoffice
18:01:21 <jfredet1> :/
18:01:43 <Cin> oo er
18:01:48 <jfredet1> that would be cool
18:01:49 <Cin> if that is possible perhaps I can resize it in oo
18:01:52 <Cin> yeah
18:03:09 <jfredet1> yah, that definitely didn't work
18:03:47 <Cin> lol
18:03:52 * Cin closes oo
18:05:35 * jfredet1 thinks
18:06:05 <jfredet1> it appears that the sony pdf tutorial thing says nothing about latex
18:06:20 <jfredet1> so -- theres another option, PDF resizers
18:06:27 * jfredet1 opens synaptic
18:06:54 <Cin> I'd thought about that, but are they reliable? I mean, won't things be squished up?
18:07:06 <jfredet1> maybe- but it's worth a shot
18:07:10 <jfredet1> maybe we'll get lucky
18:07:11 <jfredet1> :/
18:07:12 <Cin> ("squished up" is a technical term)
18:07:21 <Cin> yeah, hrm
18:07:24 <jfredet1> Cin: seriously, it is, I use it all the time at school
18:07:28 <Cin> haha
18:09:02 <chessguy> Cin, better than a category-theoretic term
18:09:22 <Cin> I generally just export PDFs to plain .txt files or copy the text from web articles and put them on my reader. it works out the number of pages according to the font size you use
18:09:30 <Cin> but with programming guides the formatting is usually important
18:10:03 <jfredet1> god damn it.
18:10:15 <jfredet1> i've got it to render the right size
18:10:22 <jfredet1> but the page is still to big
18:10:27 <Cin> :s
18:10:49 <jfredet1> did you try uploading it to the reader? maybe it only _looks_ like its 8x11
18:11:22 <Cin> I will try it
18:12:22 <jfredet1> I've gotta get me one of these things... modulo the problems with sizing
18:13:37 <Cin> hrrrm!
18:13:42 <Cin> curious
18:13:46 <jfredet1> did it work?
18:13:56 <Cin> sort of
18:14:05 <jfredet1> ediboh?
18:14:14 <Cin> I mean, it's shrunk because it's compressing A4 to the screen size
18:14:21 <Cin> but if I click the button to adjust the zoom
18:14:29 <Cin> it displays the content to fit the page properly
18:14:30 <dons> ?users
18:14:30 <lambdabot> Maximum users seen in #haskell: 368, currently: 346 (94.0%), active: 14 (4.0%)
18:14:43 <Cin> but it seems I have to press that zoom several times for each page :\
18:15:13 <jfredet1> ...
18:15:26 <jfredet1> I will prevail over Yaht!
18:15:27 <jfredet1> :/
18:15:29 <Cin> LOL
18:15:37 <jfredet1> this is going up on the wiki when we get it working
18:15:44 <jfredet1> so noone ever has to deal with this again
18:15:45 <jfredet1> :/
18:15:47 <Cin> oh definitely
18:15:56 <hpaste>  desp pasted "compact" at http://hpaste.org/1825
18:16:01 <Cin> maybe...
18:16:10 <Cin> can you build it as one html file?
18:16:22 <jfredet1> not with the images, methinks
18:16:25 <Cin> maybe I could open it in Firefox, copy the content, and paste it into OpenOffice, then export as PDF?
18:16:28 <Cin> oh
18:16:30 <Cin> dang
18:16:43 <jfredet1> can it the reader read dvi?
18:16:53 <Cin> I'm not sure
18:17:07 <Cin> I'll try to find out
18:17:16 <Cin> (why, btw?)
18:17:28 <jfredet1> nope, PDF TXT and RTF
18:17:34 <jfredet1> and BBeB book
18:17:36 <jfredet1> no dvi
18:17:36 <jfredet1> :/
18:17:43 <jfredet1> nobody reads DVI anymore
18:17:43 <jfredet1> :/
18:17:48 <ddarius> jfredet1: Did you really expect it to?
18:17:49 <Cin> lol <_<
18:17:55 <jfredet1> ddarius: I can dream
18:18:00 <Cin> haha
18:18:53 <jfredet1> Cin: http://users.wpi.edu/~jfredett/yaht.pdf
18:18:54 <jfredet1> try that
18:19:22 <Cin> oki
18:20:44 <jfredet1> thats rendered to b6, I tried messing around with some other options too
18:22:04 <Cin> this is annoying
18:22:11 <Cin> if I hit the 'change zoom' button a few times
18:22:19 <Cin> it appears as a perfect page, with readable text
18:22:23 <jfredet1> ...
18:22:24 <jfredet1> hmm
18:22:31 <Cin> but when I go to the next page, it defaults to the old squished up zoom
18:22:36 <jfredet1> bah.
18:22:43 <jfredet1> hmm,
18:23:04 <jfredet1> its definitely because the page is 8.5x11, and the screens buggering up
18:23:07 <jfredet1> hmm
18:23:19 <Cin> aye
18:25:32 <Cin> I'm attempting some random covnerter that's supposed to convert pdfs to reader formats of the correct size. here's hoping (looks a bit dodgy though)
18:26:05 <jfredet1> yah- i think that latex is not particularly capable of changing page lengths
18:27:04 <jfredet1> oh! I should check to see if CTAN has a library for this... :)
18:28:06 <Cin> wow this be a slow process
18:28:08 <jfredet1> nothing
18:28:09 <jfredet1> :/
18:28:11 <Cin> what is CTAN?
18:28:25 <jfredet1> Comphrensive Tex something or other
18:28:35 <jfredet1> its like CPAN, but for Tex
18:28:41 <Cin> ah, oki. I'd google it but my PC is now bitched because of the conversion
18:28:44 <jfredet1> it has a huge number of librarys
18:28:57 <Cin> cool
18:29:02 <dons> its like hackage.haskell.org , but for perl :)
18:29:08 <jfredet1> lol
18:29:35 <jfredet1> which came first, CPAN or Hackage?
18:29:54 <jfredet1> (aside: Hackage, _way_ better name than CPAN
18:30:10 <Cin> oh wow, loads of packages
18:30:14 <jfredet1> yeh
18:30:15 <jfredet1> :)
18:30:26 * Cin continues to scroll
18:30:46 <dons> lots of packages on cpan? or hackage?
18:30:53 <Cin> hackage
18:31:00 <dons> yeah, its getting there
18:31:37 <Cin> while I'm waiting for this to convert, is there a common editor/IDE Haskellers(?) use?
18:32:01 <dons> emacs or vim are pretty common
18:32:24 <jfredet1> I just use vim, though there exist some plugins for Visual studio (iirc) and for eclipse
18:32:30 <jfredet1> the eclipse plugins kinda suck though
18:32:45 <bos> what part of eclipse doesn't suck?
18:32:47 <Cin> ah, that's cool. yeah, I've tried that eclipse plugin. but I don't really use/like eclipse so much to be honest
18:32:50 <dons> yeah, on windows you have other options
18:33:00 <jfredet1> i dunno
18:33:09 <jfredet1> eclipse is a great idea,
18:33:11 <Cin> oh yeah! visual Haskell, I'd forgotten about that
18:33:45 <jfredet1> but its kindof messy, methinks
18:34:25 <Cin> is it common to do sort of "image based" interactive programming in Haskell? or is it more, write code, compile, test, edit code, recompile, test, etc.?
18:34:38 <bos> the latter.
18:34:47 <Cin> oki doki
18:34:53 <jfredet1> what do you mean "image based"
18:34:59 <bos> working in a big image is more of a smalltalk, and to a lesser extent lisp and erlang, thing.
18:35:24 <bos> jfredet1: big long-running environment
18:35:24 <Cin> yeah, I've dabbled a bit with those two languages
18:35:37 <jfredet1> hmm
18:35:55 <jfredet1> i dunno, I've only ever written code write-compile-test
18:35:56 <bos> jfredet1: often involving a kitchen sink of compiler, interpreter, repl, windowing system, web browser, and pony.
18:36:14 <jfredet1> although I've done some livecoding in Puredata
18:36:30 <Cin> lol. pony being totally _required_ if you're going to do any web 2.0 programming. xD
18:36:31 <jfredet1> livecoding Pd == fun fun stuff
18:36:39 <jfredet1> Cin: true that
18:37:01 <jfredet1> well Cin, I'll keep poking at this tex stuff, but i think that the issue is non-tex related
18:37:33 <Cin> indeed. I think we've exhausted tex possibilities (and you)
18:37:50 <jfredet1> yeh- *falls over*
18:37:55 <jfredet1> Yaht wins,
18:37:56 <Cin> lol
18:38:02 * wli continues boggling over what the equivalent of m >>= k  = State $ \s -> let (a, s') = runState m s in runState (k a) s' is when the state transition function is represented by a finite Map (Data.Map).
18:38:16 <Cin> it's on page 42 of 192, doing this so called converter thingie, so I'll see how that goes.
18:38:24 <jfredet1> cool
18:38:45 <bos> haskell would in many ways be a great language for a long-lived image that you could update on the fly. it's just not been a focus to date.
18:38:50 <wli> You can't do lambdas on data.
18:38:58 <ddarius> bos: Why do you say that?
18:39:10 <bos> which part?
18:40:04 <jfredet1> Cin: this reader thing looks pretty damn awesome, it is, however, well out of my budget
18:40:11 <jfredet1> I need more gadgets...
18:40:12 <jfredet1> :/
18:40:48 <bos> ddarius: i'm aware of stuff like hs-plugins and ghc-api, but they're not widely used.
18:40:51 <Cin> jfredet1: yeah, it is pretty pricey. but since getting it I read so much more, so I think it's worth it
18:41:09 <ddarius> bos: The first part
18:41:13 <jfredet1> see- i can't stand reading books online, I have to print them before I can read them
18:41:46 <Cin> jfredet1, yeah, exactly! I am the same. even web page articles, instead of bookmarking them, I put them on my reader and read them in bed/on the bus/waiting for job interviews (seriously)
18:42:03 <jfredet1> i have a huge collection of books  (500+) now.
18:42:18 <jfredet1> mostly math texts
18:42:18 <jfredet1> :)
18:42:21 <Cin> hehe
18:42:33 <jfredet1> but yah- i'll get one of these some day
18:42:35 <Cin> I'm currently reading Sophistical Refutations by aristotle o_o
18:42:38 <jfredet1> when they get cheaper
18:42:54 <jfredet1> Principia Mathematica (Russel & Whitehead, not Newton)
18:43:11 <jfredet1> 700 pages of fun
18:43:11 <Cin> yeah, I have seen that book online! I read the first few chapters a while ago, but got sick of the screen reading
18:43:17 <Cin> I might actually put that on my reader:D
18:43:24 <ddarius> Categories for the Working Mathematician (Saunders Mac Lane)
18:44:05 <jfredet1> heh, I'm reading a couple other books too, Programming the Universe (about quantum computers) and I am a Strange Loop (new book from Hofstadter)
18:44:05 <jfredet1> :)
18:44:15 <jfredet1> Hofstadter is my hero
18:45:38 <thorat> Godel's Theorem: An Incomplete Guide to Its Use and Abuse, Franzen
18:45:44 <bos> ddarius: primarily the added safety of referential transparency and strong typing, so you'd have to work harder to bugger up a running image. of course, other things would be harder, like changing the type of a function or modifying a typeclass on the fly.
18:46:12 <jfredet1> brilliant, thorat, sounds like a fun book
18:46:26 <thorat> :)
18:46:28 <thorat> it is
18:47:33 <dons> bos, ddarius: part of the hard thing is extending types at runtime
18:47:42 <dons> and coming up with a type system that supports that properly, or some other mechanism
18:48:02 <Cin> bos, what are your thoughts on image-based programming?
18:48:06 <dons> hence, i'm pretty sure, this is why erlang doesn't have a type system: it certainly wasn't clear in 85 how to do that
18:48:17 <Cin> bos, or at least, image-based "development" I think is probably a better term to use
18:48:18 <dons> its more clear now, so they might try to do erlang with a type system, if they began today
18:48:19 <ddarius> The "quick" solution is to retypecheck the (whole) program.
18:48:27 <dons> yep
18:48:47 <dons> essetially, keep the type checker around at runtime, and enough type info to handle checking new code
18:48:55 <jfredet1> oh- sigfpe reviewed it, 5 stars- nifty
18:49:03 <jfredet1> (the godel book, anyway)
18:49:23 <ddarius> dons: For a Smalltalk or Lisp like development environment, things are much simpler.
18:49:50 <dons> 5 #haskell teams in the icfp top 50, i think
18:49:56 <Cin> jfredet1: hehe, I want to read Gdel, Escher, Bach but they don't sell the book on Sony's bookstore ~_~
18:50:04 <ddarius> Cin: Go to the library.
18:50:09 <dons> ddarius: oh certainly, no phase distinction, and keep all the source around anyway
18:50:11 <jfredet1> you should own a hardcopy of GEB
18:50:20 <Cin> ddarius: indeed
18:50:21 <jfredet1> frak, you should be given one by the State at birth
18:50:21 <wli> Okay, I've got it.
18:50:27 <jfredet1> GEB > the Bible.
18:50:34 <Cin> jfredet1: lol
18:50:41 <ddarius> Maybe, but I didn't find it all that great.
18:50:59 <jfredet1> ddarius: then you are a heathen.
18:51:04 <ddarius> I am a heathen.
18:51:10 <jfredet1> GW McWarmonger will be coming after you
18:51:38 <jfredet1> him and his uncanny ability to revoke amendments to the constitution summarily
18:51:58 <ddarius> Perhaps he'll send me after me.
18:52:11 <jfredet1> perhaps
18:53:05 <sfultong> secession from the union should be legal
18:53:23 <ddarius> sfultong: You can leave any time you want.
18:54:06 <jfredet1> I may hate my president, but I love my country to much to leave.
18:54:13 <sfultong> well, me and my house can't leave...
18:54:19 <sfultong> me and my property can't leave
18:55:15 * oerjan wonders how many people have actually moved their house across country borders.
18:55:43 <jfredet1> oerjan: i'm sure theres at least one
18:55:44 <sfultong> oerjan: plenty... I'm sure there are trailer parks in canada :-P
18:55:47 <ddarius> If you secede, you are no longer governed by our laws.
18:56:08 <jfredet1> my uncle rotated his house 43 degrees counterclockwise
18:56:12 <ddarius> Of course, it's unlikely that the rest of the nation will recognize your independence.
18:56:17 <jfredet1> so he could build a bigger garage
18:56:43 <sfultong> ddarius: ok, good point... law is a shared hallucination
18:56:52 <jfredet1> ddarius: "The Protectorate of Joe" I like that, I'm seceding!
18:57:18 <ddarius> jfredet1: I'll be sure to send some people to take over your Protectorate.
18:57:20 <sfultong> jfredet: that's a lot of work for just a garage
18:57:22 <jfredet1> you may adress me a Joe, Lord-Protector of the grand Protectorate of Joe.
18:57:28 <ddarius> You don't have your rights anymore either.
18:57:31 <jfredet1> sfultong: but it was L-shaped!
18:57:44 * jfredet1 unsecedes
18:57:48 <jfredet1> not that fun, really
18:57:55 <jfredet1> it was nice to be independent
18:57:59 <sfultong> my (parents) house is L-shaped... but that's because of the garage
18:58:20 <jfredet1> sfultong: the garage is remarkably cool, he stores his cessena in there
18:58:37 <sfultong> ah... now I understand the need for a bigger garage
18:59:13 <jfredet1> sfultong: oh- it fit fine in the old one
18:59:20 <jfredet1> he just wanted a bigger garage
18:59:23 <Cin> hxt library: A collection of tools for processing XML with Haskell.
18:59:23 <sfultong> hey... if people can live in trailers.... how about planes?
18:59:27 <Cin> should that not be in the XML category?
18:59:34 <Cin> >_>
18:59:46 <jfredet1> category is a loaded term in Haskell
19:00:09 <jfredet1> oh-
19:00:13 <jfredet1> wait- i misread
19:00:17 <jfredet1> i suppose yes.
19:00:18 <jfredet1> :/
19:00:23 <sfultong> ddarius: rights?  what about rights under international law?
19:00:35 <ddarius> sfultong: He has those.
19:00:39 <Cin> 134 of 192
19:00:42 * Cin goes for food
19:01:06 <sfultong> not that "rights" under international law means anything
19:01:45 <ddarius> sfultong: Luckily they mostly do to America (more so than many other countries) which would be his biggest issue.
19:02:09 <hpaste>  wli pasted "What does (>>=) mean here?" at http://hpaste.org/1827
19:02:30 * wli gets something past the typechecker but has no idea how to interpret what it means.
19:04:15 <ddarius> Check to see if it satisfies the monad laws to start.
19:04:28 <ddarius> If it does (and satisfies the functor laws), you're set.
19:08:00 <glen_quagmire> having fun with endo?
19:08:23 <wli> ddarius: It does by isomorphism with function types, since it's a direct translation of functions expressed via (->) to functions expressed via Data.Map
19:09:03 <ddarius> wli: Then you are set.
19:09:04 <wli> IOW assume the domain is finite, tabulate, and you get what I wrote out.
19:09:32 <wli> ddarius: Except for not understanding what (>>=) means in terms of its action on the Moore machine.
19:13:50 <dolio> It does seem rather weird.
19:14:20 <ddarius> The issue is that f may make a completely new unrelated state transition table.
19:14:37 <dolio> It takes the output of one machine, turns it into a new machine, and feeds the state from the old machine into the new machine.
19:15:21 <wli> dolio/ddarius: Hmm, I think I get it now.
19:31:41 <sfultong> @pl (\a b c d -> a c b d)
19:31:41 <lambdabot> flip
19:31:51 <sfultong> oh, heh
19:32:22 <sfultong> @pl (\a b -> b a)
19:32:22 <lambdabot> flip id
19:32:37 <sfultong> @pl (\a b c -> c b a)
19:32:37 <lambdabot> flip (flip . flip id)
19:32:53 <sfultong> @pl (\a b c d -> d c b a)
19:32:53 <lambdabot> flip (flip . (flip .) . flip (flip . flip id))
19:33:23 <sfultong> heh...
19:33:45 <mgsloan> hmm, SPJ seems to rather badmouth haskell in the channel9
19:33:45 <sfultong> @pl (\a b c d e f g h i -> i h g f e d c b a)
19:33:49 <lambdabot> flip (flip . ((flip . ((flip . (flip .)) .)) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .
19:33:49 <lambdabot> ) .) .) .) . (((((flip .) .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . flip (flip . (flip .
19:33:49 <lambdabot> ) . ((flip .) .) . flip (flip . (flip .) . flip (flip . flip id)))))))
19:33:49 <lambdabot> optimization suspended, use @pl-resume to continue.
19:34:04 <Saizan> "optimization"
19:34:24 <sfultong> that's the kind of optimization that I do to my code
19:34:50 <Saizan> nice :D
19:35:54 <dons> mgsloan: you think?
19:36:06 <dons> people seemed to find it inspiring, I thought
19:36:11 <sfultong> @unpl flip (flip . (flip .) . flip (flip . flip id))
19:36:11 <lambdabot> (\ b c f i -> i f c b)
19:36:42 <dons> for those bored with ICFP, http://programming.reddit.com/info/28dxk/comments
19:36:43 <lambdabot> Title: Find those strings: parallel string search on the GPU (pdf) (reddit.com)
19:36:44 <mgsloan> dons - true, but he sticks haskell down in useless + safe
19:36:44 <dons> :D
19:36:52 <dons> mgsloan: ah, you miss the end of the slides
19:36:58 <dolio> Haskell's not as useless these days as it used to be.
19:37:04 <dons> he draws arrows up towards useful, with things like "monads", and "ffi"
19:37:17 <dons> its a sketch of the slides he's giving at OSCOooo tomorrow
19:37:18 <mgsloan> true
19:37:22 <mgsloan> ah
19:37:56 <dons> but it does get across the basic point of 'not selling out'
19:38:02 <dons> i.e. start with something sound, then safely extend it
19:38:09 <dons> rather than starting with something unsound, and trying to fix it
19:39:13 * ddarius shuffles a Ropes library a little farther along.
19:39:50 <mgsloan> true, that is a good point.  I guess it is an honest representation of the haskell POV
19:40:19 * ddarius forgot that Data.ByteString doesn't have a substring function.
19:40:23 <dons> it explains the 'hair shirt' idea a bit more concretely
19:40:29 <dons> ddarius: it does, just a bad impl. though
19:40:33 <dons> findSubstring
19:40:37 <dons> but *don't* use it.
19:40:54 <dons> anyone want to code up a parallel exact string matcher instead? :)
19:41:00 <dons> i'm sure there'd be a few people willing to use it
19:41:46 <ddarius> I don't want to find a substring, just select one.  I.e. I wrote take start . drop len
19:42:52 <dons> ah yes, that's fine
19:46:01 <ddarius> Well start and len swapped (hopefully)
19:46:05 * ddarius goes to check
19:46:16 * glen_quagmire comes
19:46:33 <ddarius> That could have been confusing.
19:48:15 * ddarius will have to compare the performance between strict and lazy versions at some time.
19:49:50 <dons> Prelude> do getChar -> x ; return x
19:49:52 <dons> huh..
19:50:04 <glguy> yeah, when did that happen?
19:50:06 <ddarius> Yeah, I'm completely non-plussed about that one.
19:50:21 <dons> Prelude> do return 1 -> x ; return x :: Maybe Int
19:50:21 <dons> Just 1
19:50:39 <dons> maybe left over lexer stuff from when do notation was being experimented with?
19:50:43 <dons> or is it some arrows stuff?
19:50:49 <glguy> how could it be?
19:50:53 <glguy> it works without -farrows?
19:50:56 <glguy> and -> isn't used by arrwos
19:50:57 <dons> its allowed by ghci by default, so needs a bug report
19:51:18 <dons> > do return 1 -> x ; return x :: Maybe Int
19:51:19 <lambdabot>  Parse error
19:51:32 <dons> Hugs.Base> do return 1 -> x ; return x :: Maybe Int
19:51:32 <dons> ERROR - Syntax error in input (unexpected `->')
19:51:33 <ddarius> What's a good (set of) benchmark(s) to stress string indexing, appending, substring selection?
19:51:46 <dons> huh, icfp contest? :)
19:51:56 <ddarius> Actually, apparently.
19:52:10 <dons> ddarius: the 'fasta' or 'k-nuc' benchmarks on the shootout?
19:52:23 <dons> there's a few other dna search, modify problems that are great for that
19:52:47 <dons> so.. who wants to put in a bug report for this -> thing? :)
19:53:25 <dons> env' |- e -> v
19:53:28 <dons> is very cute though..
19:53:42 <dons> maybe that's why. secret SPJ hacks, like 1 :: 1
19:53:45 <dons> :k 1
19:53:51 <glguy> 1 :: 1 ?
19:53:51 <lambdabot> *
19:53:56 <dons> :k 0
19:53:58 <lambdabot> Only unit numeric type pattern is valid
19:54:12 <mgsloan> > 1 :: 1
19:54:13 <lambdabot>  Parse error
19:54:23 <Saizan> 1 is a type?
19:54:24 <dons> :t GHC.Base.Unit
19:54:26 <lambdabot> GHC.Base.Unit
19:54:29 <dons> :t GHC.Base.Unit :: 1
19:54:31 <lambdabot> 1 :: GHC.Base.Unit
19:54:39 <dons> :}
19:54:56 <mgsloan> 0_o
19:55:04 <vaste_> @ty id
19:55:06 <lambdabot> forall a. a -> a
19:55:26 <glguy> my preception of Haskell has been shattered
19:55:33 <glguy> I don't know what to believe in any more
19:55:41 <dons> yeah, who is this SPJ guy? with his wacky hacks and tricks
19:55:57 * dons must use:   gamma |- e -> v 
19:55:58 <dons> more often
19:56:10 <mgsloan> I  hear that he works for teh eViL
19:56:16 <dons> with unicode gamma
19:56:30 <dons> glguy: can you get that to type check? :) \gamma |- e -> v ?
19:57:02 <sorear> .
19:57:02 <vaste_> @ty (\x->(x [1], x "1"))
19:57:04 <lambdabot>     No instance for (Num Char)
19:57:04 <lambdabot>       arising from the literal `1' at <interactive>:1:9
19:57:58 <vaste_> > (\x->(x [1], x "1")) id
19:57:59 <lambdabot>   add an instance declaration for (Num Char)
19:57:59 <lambdabot>     In the expression: 1
19:58:04 <ddarius> :t \(x :: forall a.[a] -> Int) -> (x [1], x "1")
19:58:06 <lambdabot> (forall a. [a] -> Int) -> (Int, Int)
19:58:28 <wli> Still working on pushdown automata.
19:59:26 <sorear> @users
19:59:26 <lambdabot> Maximum users seen in #haskell: 368, currently: 343 (93.2%), active: 20 (5.8%)
19:59:44 <glguy>  @type (\(x :: forall a. a -> a) -> (x [1], x "1") ) id
19:59:57 <glguy> > (\(x :: forall a. a -> a) -> (x [1], x "1") ) id
19:59:57 <lambdabot>  Parse error
20:00:24 <ddarius> You had a space the first time, @run doesn't do -fglasgow-exts
20:03:00 <vaste_> @ty (\x->(x [1], x [1]))
20:03:02 <lambdabot> forall t t1. (Num t1) => ([t1] -> t) -> (t, t)
20:03:40 <glguy> vaste_: the thing is that the variables in a lambda-expression are monomorphic
20:03:48 <glguy> unless explicitly specified otherwise
20:04:04 * sorear returns after a week of complete net absence, reads 889 messages
20:04:20 <vaste_> monomorphic?
20:04:39 <glguy> all of the types are known
20:04:52 <glguy> forall a . a -> a is polymorphic
20:04:59 <glguy> a could be many things
20:05:05 <glguy> Int -> Int  is monomorphic
20:05:34 <vaste_> when you say lambda expression, do you only mean \x->...?
20:05:48 <glguy> yeah
20:06:18 <glguy> vaste_: similarly, a top-level definition without any arguments must be monomorphic
20:06:26 <glguy> unless otherwise explicitly specified
20:06:34 <glguy> that's the monomorphism restriction
20:06:40 <glguy> (not just top level)
20:06:50 <ddarius> It's a bit stronger for lambda bound variables.
20:06:50 <sorear> !paste
20:06:51 <hpaste> Haskell paste bin: http://hpaste.org/
20:07:08 <Saizan> ddarius: how?
20:07:48 <timthelion> what do you do in haskell instead of advising functions?  I want to make say getHomeDirectory either return getHomeDirectory or "some user customized value"
20:08:01 <wli> That's what's wrong. The state transition table is read-only state, IOW Reader.
20:08:01 <glguy> http://www.haskell.org/onlinereport/decls.html#monomorphism
20:08:02 <lambdabot> Title: The Haskell 98 Report: Declarations
20:08:08 <wli> And the output is Writer.
20:08:30 <wli> The actual current state is is the state.
20:08:34 <dons> timthelion: advise eh? :)
20:08:35 <timthelion> but I don't really want to make a specific function. as I've already used getHomeDirectory in my project. and am just now adding the abuility to set a custom value
20:08:43 <dons> timthelion: you liftM into Either
20:08:44 <timthelion> dons: I'm an emacser
20:09:04 <vaste_> @ty let f x = (x [1], x "1") in f
20:09:06 <lambdabot>     No instance for (Num Char)
20:09:06 <lambdabot>       arising from the literal `1' at <interactive>:1:14
20:09:09 <dons> on what basis do you want to return some custom value? what condition holds for that?
20:09:22 <timthelion> dons: that the value has been set
20:09:38 <timthelion> dons: I have a . file in $HOME
20:09:49 <glguy> vaste_: in that situation, x is still a function , and you aren't explictly showing its arguments
20:09:56 <glguy> (not that you could)
20:10:07 <dons> timthelion: hmm? what's the boolean condition?
20:10:26 <ddarius> Saizan: Monomorphic lambda bindings are an aspect of the HM type inference algorithm.
20:10:38 <timthelion> dons: if "mdir: ..." exists in .hdrfc
20:10:42 <glguy> vaste_: the link I posted covers this
20:11:06 <dons> timthelion: so just define a function that wraps getHomeDir
20:11:10 <dons> and does the test
20:11:10 <vaste_> hm, okay
20:11:24 <Saizan> ddarius: so you say that's not just a convenience of implementation?
20:11:25 <ddarius> Hmm... implementing concatMap looks like it will be a nightmare... flatten to a list of ropes, map, rebuild?
20:11:28 <vaste_> so t1 in forall t t1. (Num t1) is monomorphic as well?
20:11:54 <timthelion> dons: there isn't a way to make a function that is named getHomeDir that overwrites the old getHomeDir and calls the old getHomeDir?
20:11:59 <fax> morning
20:12:04 <ddarius> Saizan: It's not there for the reason the monomorphism restriction is there, and it does not go away with -fno-monomorphism if I understand correctly.
20:12:17 <dons> timthelion: that's insane :) *no*
20:12:29 <dons> you want to forget about static analysis of code completely? :)
20:12:50 <dons> import qualified System.Directory as D. getHomeDir = D.getHomeDir -- like that
20:12:50 <timthelion> dons: no, I'm doing the overwritting during compile time
20:13:04 <dons> you must bind it to a new name
20:13:16 <timthelion> dons: ok, that looks like it would work
20:13:17 <glguy> timthelion: that sounds like something a Ruby programmer would do
20:13:20 <dons> it can be the same name, modulo module scope of course
20:13:48 <dons> you shouldn't think about it in terms of overwriting symbol table entries though
20:14:10 <dons> its more a scoping/rebinding thing, than some wacky lispish/ruby symbol table hack
20:14:59 <timthelion> dons: why are you accusing me of knowing ruby? I'm a lisper. Not a hipster.
20:15:02 <dons> SyntaxNinja: heh, do you know this ICFP team: `PurelyFunctionalInfrastructure' ?
20:15:14 * gravity is sad that knowing ruby now means being a hipster
20:15:18 <gravity> It's such a lovely language
20:15:23 * glguy laws
20:15:39 <glguy> lawlz*
20:15:47 <dons> timthelion: oh, its all the same, advising/destructively updating the symbol table on the fly. forget about reasoning about program behaviour :)
20:15:54 <fax> heh
20:15:59 <fax> I thought ruby is really popular
20:16:11 <glguy> fax: it is, that's what's sad
20:16:13 <glguy> :-/
20:16:28 <fax> hm well its not the worst thing
20:16:43 <fax> rather be forced to use ruby than php
20:16:48 <glguy> if you mean it keeps a class of people isolated from the rest of the world
20:16:51 <glguy> then yes, you're right
20:17:03 <fax> I read that hipster is like somone who rejects mainstream stufff though
20:17:22 <timthelion> does it?
20:17:22 <fax> is that right because I didn't know the word..
20:17:25 <SyntaxNinja> dons: no, who's that?
20:17:33 <fax> timthelion: im not sure
20:17:36 <glguy> I don't know if t hat's what a hipster is or not..
20:17:39 <dons> SyntaxNinja: don't know. I thought it might have been you :)
20:17:43 <glguy> I do know that I'm not a hipster
20:17:49 <dons> using your secret codename
20:17:50 * timthelion googles for a deffinition
20:17:50 <SyntaxNinja> dons: nah
20:17:53 <mr_tenor> Gaetano Caruana's " Embedding Origami Axioms in Haskell" thesis hasn't been published yet, has it? I was going to cite it :/
20:18:00 <glguy> SyntaxNinja: tell 'em what hipsters are
20:18:12 <wli> ska/punk
20:18:13 <SyntaxNinja> dons: although Cabal used to be called LIP, the Library Infrastructure Project or something like that.
20:18:13 <glguy> SyntaxNinja lives in the hipster neighborhood
20:18:26 <SyntaxNinja> dons is a hipster. he can tell 'em.
20:18:42 <SyntaxNinja> dons: by the way, Melissa came over to me and let me pick where you were going to live.
20:18:46 <SyntaxNinja> muahahaha
20:18:51 <dons> SyntaxNinja: oh man!
20:18:51 <timthelion> Hip means "fashionably current,"
20:18:58 <glguy> You guys are paying for his housing??
20:19:02 <fax> oo
20:19:05 <glguy> damn, I should have negotiated better
20:19:06 <SyntaxNinja> not as far as I know.
20:19:07 <fax> http://www.gaetanocaruana.com/2007/05/25/embedding-origami-constructs/
20:19:09 <glguy> :-p
20:19:09 <fax> I want to read that
20:19:10 <lambdabot> Title: Gaetano Caruana&#8217;s Blog  Blog Archive  Embedding Origami Constructs, http://tinyurl.com/2rwusb
20:19:26 <dons> SyntaxNinja: yeah, she sent me a mail about some place in the pearl district?
20:19:31 <SyntaxNinja> yeah
20:19:33 <dons> sounds good
20:19:40 <dons> now, if only i can get this damn visa
20:19:43 <fax> mr_tenor: is it online anywhere?
20:19:45 <SyntaxNinja> she was like, "Is he a Beaverton guy or a Pearl guy" and I was all like "Pearl guy for sure"
20:19:55 <dons> :)
20:19:56 <mr_tenor> fax: i got the URL from this channel a while ago, IIRC ;)
20:20:03 <SyntaxNinja> no offense glguy ;)
20:20:08 <mr_tenor> can't find it now
20:20:21 * SyntaxNinja tried to talk glguy into living in hipster parts of town
20:20:23 <glguy> SyntaxNinja: that's OK, I don't want hipsters moving out to my suburbs!
20:20:23 <timthelion> dons: don't put too much into getting it, you'll have to fight of about 3 fbi investigations once you do.
20:20:36 <dons> annoyingly, the US consulate is closed for most of August
20:20:54 <mr_tenor> fax: i was just looking for some "hey look haskell is good for all sorts of DSLs" examples
20:20:56 <gravity> Some part of this country does go on vacation in August? Amazing.
20:21:14 <timthelion> I thought it was only the president who went on vacation around here.
20:21:16 <wli> SyntaxNinja: I probably don't look like either Pearl or Beaverton these days.
20:21:26 <SyntaxNinja> wli: where are you?
20:21:28 <fax> mr_tenor: ah cool, that I would like to see as well
20:21:42 <SyntaxNinja> dons: you'd better get the visa
20:21:42 <dons> SyntaxNinja: thanks for that, btw, Suzie was quite happy. she's a real hipster.
20:21:42 <wli> SyntaxNinja: Tanabourne, but I don't look it.
20:21:55 <SyntaxNinja> dons: ahh, get suzie to tell glguy what a hipster is
20:22:04 <dons> SyntaxNinja: oh, for sure. its just a matter of /when/ they are available for appointments for the visa interview
20:22:07 <wli> Wasn't ska/punk enough?
20:22:17 <SyntaxNinja> wli: heh I'm sure you could be if you tried.
20:22:36 <wli> SyntaxNinja: I look more like a visual kei star these days.
20:23:32 <Saizan> wli: that's something, go to japan and get a lot of girls
20:23:42 <wli> SyntaxNinja: I've lost 65 lbs. since the last time you saw me.
20:24:17 <ddarius> Ahhh Malice Mizer and Dir en Grey
20:24:22 <SyntaxNinja> wli: google images says that means you look like a petite asian girl with red hair dressed like a nurse.
20:24:35 <fax> :o
20:24:39 <dons> heh
20:24:53 <SyntaxNinja> at least that's the picture that stood out, for some reason
20:24:57 <wli> SyntaxNinja: That should clarify.
20:25:01 * fax does a google image search for wli
20:25:05 <dons> haha
20:25:20 <dons> SyntaxNinja: so, coming to the hackathon?
20:25:36 <dons> we'll be hacking...
20:26:07 <dons> http://www.haskell.org/haskellwiki/Hac_2007_II :)
20:26:10 <lambdabot> Title: Hac 2007 II - HaskellWiki
20:26:17 <SyntaxNinja> dons: depends on if I go to Freiburg...
20:26:33 <SyntaxNinja> dons: can't decide.  I've been traveling so much that I'm kinda not up to it, but I hate to miss it.
20:26:41 <SyntaxNinja> Anna can't get work off, so she wont be able to come with.
20:26:48 <dons> yeah, the idea might be for the next one to be in SF, before/after POPL
20:26:53 * SyntaxNinja could stand to do some hacking.
20:26:55 <dons> in Jan. so that's another idea
20:27:06 <wli> $25K of orthodontia, laser eye surgery, laser hair removal, wardrobe revamping, jewelry, and so on later, I should hope so.
20:27:11 <dons> maybe we just do Hac 3 in Portland, before/after POPL
20:27:31 <SyntaxNinja> wli: :)
20:27:38 <fax> what do you do at a hackathons?
20:27:53 <fax> ah Projects to work on
20:28:06 <dons> libraries mostly
20:28:10 <dons> and hackage/cabal/ghc
20:28:20 <dons> Data.Binary got written at the last one, for example
20:28:25 <wli> SyntaxNinja: A set of parser combinators that avoid in whatever way restrictions on left recursion might be nice.
20:28:26 <fax> oh nice
20:28:27 <SyntaxNinja> there are probably still some dirty bits in cabal that I'm the only one who knows about.
20:28:27 <dons> now its being hammered left and right during the hackathon
20:28:45 <SyntaxNinja> so maybe I'd be helpful
20:29:03 <glguy> what was the reason that you can't uninstall something with Cabal?
20:29:10 <dons> just coming up with a list of top 5 libs that need done would be useful too
20:29:18 <wli> SyntaxNinja: My thought was to build up a table-driven parser and do GLR but I'm not likely to get around to it or be capable of it in a timely fashion.
20:29:53 <wli> dons: I can do a fair amount wrt. special functions.
20:30:01 <glguy> Visual kei seems to be a glammed up version of American style goth with a healthy dose of Brian Froud-esque influence. It was originally a style for the Japanese bands that invented it, but it seems to be gaining popularity as a style in its own right.
20:30:11 <wli> dons: No idea if anyone cares about them.
20:30:34 <wli> glguy: You better believe I'm all glammed up and gothed out.
20:31:03 <wli> glguy: (The latter more so than authentic visual kei.)
20:31:05 <ddarius> @index Handle
20:31:05 <lambdabot> System.IO
20:31:06 <fax> <3 moi dix mois
20:31:23 <dons> ?userrs
20:31:23 <lambdabot> Maximum users seen in #haskell: 368, currently: 344 (93.5%), active: 13 (3.8%)
20:31:34 <dons> so anyone got a theory on why there's 50 more people in here than usual?
20:31:35 <SyntaxNinja> glguy: well, it's just a matter of keeping track of all the stuff that you've installed.  I sorta want to encourage people to use their native package manager after a point, which doesn't need cabal to help with uninstall.
20:32:06 <ddarius> dons: Let's see what happens after the ICFP contest
20:32:14 <wli> fax: I've not quite turned into Mana, doubtless to the relief of many. I'm probably more along the lines of Gackt or Klaha.
20:32:27 <ddarius> My friend is a big fan of Gackt.
20:33:12 <Saizan> wli: i think that now you owe us a photo :)
20:33:37 <wli> http://holomorphy.com/~wli/bling.jpg
20:33:51 <fax> cool
20:34:24 <Saizan> :D
20:35:37 <sfultong> nice
20:35:50 <Saizan> yeah, more goth than the standard visual
20:37:33 <Cin> my hair is longer
20:37:42 <ddarius> @index stdoit
20:37:42 <lambdabot> bzzt
20:37:44 <ddarius> @index stdout
20:37:44 <lambdabot> System.IO
20:37:46 <wli> Some of that eyeliner is tattooed on.
20:37:52 <Cin> LOL
20:41:19 <Saizan> we're definitely off topic :D
20:41:36 <wli> There is that.
20:41:57 <wli> Anyway let's see if I can do a PDA as an RWS monad.
20:43:14 <Saizan> dons: how much slower would checked getWord8 be in the Get monad?
20:43:52 <dons> slower than what?
20:44:20 <ddarius> @index replicateM
20:44:20 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
20:44:21 <dons> slower than the current code?
20:44:25 <Saizan> than plain getWord8
20:44:41 <Saizan> yes
20:45:17 <dons> 10x? not sure, try checking.
20:45:23 <dons> you don't like the 'fail' on not enough bytes?
20:45:52 <Saizan> well it's an error "not enough bytes"
20:45:59 * ddarius adds more functionality to ropes.
20:46:26 <wli> ddarius: What's ropes?
20:46:27 <dons> its been very very carefully optimised, so I'd imagine a 10x kick at least, if you break the straight-line reading code
20:47:07 <dons> Saizan: usually people who need more checks insert tests in front of their getWord in the Binary instance
20:47:07 <desp> how do you repeat a char n times?
20:47:12 <dons> replicate
20:47:16 <desp> thx
20:47:17 <ddarius> wli: I'm randomly hacking a ropes library in Haskell.
20:47:34 <wli> @where ropes
20:47:34 <lambdabot> I know nothing about ropes.
20:47:48 <ddarius> It's not written yet.
20:48:14 <Saizan> dons: yeah, i'm worried that i'll lose all the speed that way, meybe i can find a way to catch the exception without losing the rest of the computation
20:48:19 <ddarius> I'm fairly confident that someone somewhere has made a Haskell implementation, e.g. I think there may be something at least called ropes in Pugs.
20:48:42 <ddarius> @google "Ropes: an alternative to strings"
20:48:43 <lambdabot> http://www.cs.ubc.ca/local/reading/proceedings/spe91-95/spe/./vol25/issue12/spe986.pdf
20:48:58 <fax> any benchmarks for ropes?
20:49:06 <fax> it seemed good but no concrete evidence
20:49:27 <glguy> benchmark the library that hasn't been written yet?
20:49:57 <ddarius> fax: If you're talking about the data structure in general, the C++ STL implementations seem to be reasonably good for the ongoing ICFP contest.
20:50:25 <fax> C++ has ropes?
20:50:35 <fax> oh I misunderstood you
20:51:05 <ddarius> I don't believe it's part of the "standard" STL, but I think it's fairly commonly implemented.
20:51:44 <hpaste>  HWSOD pasted "slow at weird place" at http://hpaste.org/1829
20:55:33 <fax> where can I find a haskell implementation of if?
20:55:40 <fax> and other thins
20:56:31 <ddarius> fax: ?
20:56:45 <fax> what
20:57:06 <fax> is it not possible to write if in haskell
20:57:33 <mr_tenor> ?
20:57:41 <HWSOD> if is a keyword in haskell isn't it?
20:57:51 <mr_tenor> it's syntactic sugar, iirc
20:57:52 <fax> not listed here http://www.zvon.org/other/haskell/Outputglobal/keywordsIndex.html
20:57:53 <lambdabot> Title:
20:58:13 <dons> if_ b e1 e2 = case b of True -> e1 ; False -> e2
20:58:31 <wli> if condition then trueBranch else falseBranch == case condition of { True -> trueBranch ; False -> falseBranch }
20:58:41 <ddarius> fax: Those aren't keywords of the language.
20:59:07 <ddarius> @google Haskell ropes
20:59:07 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/book/chapters.txt
20:59:12 <ddarius> Interesting.
20:59:20 <mr_tenor> let a x = if x==0 then "hello" else "goodbye"
20:59:32 <mr_tenor> ugly imho :(
20:59:41 * ddarius rarely uses if.
20:59:50 <dolio> > let if' True e _ = e ; if' False _ e = e ; then' = id ; else' = id in if' (1 < 2) `then'` "Foo" `else'` "Bar"
20:59:51 <lambdabot>  "Foo"
21:00:05 <dons> let a 0 = "hello" ; a _ = "goodbye"
21:00:09 <hpaste>  HWSOD annotated "slow at weird place" with "(no title)" at http://hpaste.org/1829#a1
21:00:21 * wli 's brain explodes trying to figure out what the Monad operations should do for a pushdown automaton.
21:01:04 <HWSOD> ow i can fell that explosion from here
21:01:11 <fax> dolio: hm so you can't just do then or else without `'`?
21:01:22 <wli> It's like Scanners.
21:01:27 <dolio> fax: They're all reserved words.
21:01:51 <dolio> > let then = 2 in then
21:01:52 <lambdabot>  Parse error
21:02:17 <HWSOD> fax: why dosnt the default if work for you?
21:03:58 <ddarius> :t openFile
21:04:00 <lambdabot> Not in scope: `openFile'
21:04:04 <ddarius> @hoogle openFile
21:04:04 <lambdabot> IO.openFile :: FilePath -> IOMode -> IO Handle
21:06:19 <HWSOD> is there a dropWhile for Seq? or an esay way to build one?
21:06:35 <glguy> HWSOD: use iterate?
21:06:37 <glguy> :t iterate
21:06:39 <lambdabot> forall a. (a -> a) -> a -> [a]
21:07:38 <glguy> and find
21:07:45 <glguy> fi you can't find something like dropWhile
21:07:49 <glguy> or consider split
21:07:56 <glguy> it works similarly
21:08:00 <glguy> not exactly the same though
21:08:46 <HWSOD> Am very confused! are any of those defined for Seq?
21:10:16 <ddarius> Woot!  The library passes a pretty basic test so far.
21:13:32 <wli> I've got a 5-parameter type constructor and just deciding which of the 5 should be subject to partial application for the Functor and Monad instances is already blowing my mind.
21:13:55 <bos> funny, i wrote a rope library a few months ago.
21:14:07 <ddarius> bos: Where is it?
21:14:23 <bos> boehm's rope implementation is written in quite functional style.
21:14:30 <ddarius> Indeed.
21:14:32 <fax> grr I wanted to try frag :|
21:14:37 <fax> it bus errors on startup
21:14:53 <ddarius> It's a purely functional data structure.
21:15:00 <wli> Is there a one-line executive summary wrt. what ropes are?
21:15:07 <ddarius> strings only bigger
21:15:09 <bos> ddarius: dunno, let me dig around. i got it passing a few quickcheck tests, but never finished it off.
21:15:21 <bos> ropes are self-balancing trees of string fragments.
21:15:41 <wli> bos: Thanks. That explains it all to me.
21:16:03 <bos> the idea being that you can perform a variety of operations on them efficiently, such as O(logN) append, etc.
21:16:14 <fax> has anyone run frag or seen it crash on glDrawBuffer?  http://www.haskell.org/haskellwiki/Frag#Requirements
21:16:15 <lambdabot> Title: Frag - HaskellWiki
21:16:52 <ddarius> bos: I'll probably implement a toy editor along the lines described in the paper, i.e. with a stack of edits as simply a stack of ropes.
21:16:54 <oerjan> wli: if you cannot decide which parameter to make last you could have newtyped alternatives.
21:16:59 <wli> bos: Yeah, I can see it all coming from there.
21:17:43 <wli> oerjan: Well, it's rather fuzzy what direction the thing is going.
21:18:13 <ddarius> fax: People have done both, I'm sure.
21:18:32 <fax> havee you
21:18:34 <wli> oerjan: Basically I'm trying to make a monad out of a pushdown automaton.
21:18:37 <ddarius> Nope.
21:18:46 <dolio> I've run Frag, but not seen it crash. I didn't run it long, though.
21:18:57 <ddarius> Are you sure pushdown automata form a monad?
21:19:14 <dons> fax, i think there's a 64 bug in the loading code?
21:19:27 <fax> what is 64?
21:19:31 <ddarius> That said there is an adjunction between the minimal realization of an automaton and it's "behaviour" which would give rise to a monad...
21:19:33 <wli> ddarius: Should be a reader on the state transition table, writer on the output, and state on the state and stack.
21:19:46 <dons> 64 bit bug
21:19:55 <fax> hm ok
21:20:06 <wli> ddarius: Possibly also a reader on input.
21:20:08 <dons> Mun seems to have hard coded some C struct offsets and so on
21:20:11 <ddarius> wli: What you are more going to get is a automaton decorated with actions.
21:20:30 <fax> I dont blame him
21:20:53 <wli> ddarius: I'm not sure what you mean.
21:21:31 <bos> ddarius: my implementation is very minimal, and seems to be correct, but it's so unomptimised it isn't even funny
21:23:08 <ddarius> bos: You have the source?
21:23:44 <bos> ddarius: yep
21:23:57 <ddarius> wli: With 'Automaton a' what is the 'a' going to relate to, it's polymorphic
21:24:13 <wli> data PDA stateType stackType inputType outputType = PDA { table :: Map (stateType, Maybe inputType, Maybe stackType) (stateType, [outputType], [stackType]) , stack :: [stackType] , state :: stateType , outputBuffer :: Seq outputType , inputBuffer :: Seq inputType } deriving (Eq, Ord, Read, Show)
21:24:26 <wli> ddarius: That's how what I've got breaks down.
21:24:59 <bos> ddarius: but you can only see it if you promise not to laugh
21:25:39 <ddarius> bos: My implementation is 170 lines, most functions defined as 'undefined' and written somewhat naively at this point.
21:26:18 <bos> sounds like mine, then. i don't have obvious optimisations like each node knowing the depth of the tree beneath it.
21:27:49 <ddarius> wli: If I write a function that is polymorphic in all monads, it is not going to use any of that stuff.
21:27:50 <bos> even down to mine being 160 lines
21:29:19 <ddarius> All I know about correctness is that I can read in from a file which exercises the hGet, concat, append and write out to stdout testing hPutStr.
21:29:45 <ddarius> I guess I should cut a substring out from the input.
21:32:10 <bos> ddarius: are you doing boehm's fibonacci-based rebalancing thing?
21:32:39 <ddarius> bos: In the C# implementation I'm working on, I probably will.  At this point I haven't implemented it and am not sure what I'm going to do.
21:33:42 <ddarius> Hmm, it's looking like substring is slightly broken.
21:33:56 <hpaste>  bos pasted "rope" at http://hpaste.org/1830
21:34:59 <bos> the rebalancing code is awful. i wanted to get something right, then make it elegant. in the end, i got distracted after getting it right.
21:35:53 <ddarius> typo
21:36:29 <bos> ?
21:36:52 <ddarius> There was a small typo in my substring function.  It seems to work now.
21:37:02 <wli> I think it's not actually a writer.
21:38:08 <bos> i found a thinko in my rebalance code with quickcheck, but it took a 16KB input string to tickle it. would have taken a while to show up in the wild.
21:38:41 <ddarius> Surprisingly, I haven't implemented a fold over my type.
21:38:56 <bos> i'm very fond of my oleg-like fold. it goes up to 11!
21:39:31 <ddarius> "up to 11"?
21:39:52 <bos> you must watch "this is spinal tap" immediately.
21:40:02 <ddarius> bos: Do you actually use the fold anywhere?
21:40:07 <bos> it will give you much deeper insight into many of the threads on haskell-cafe.
21:40:09 <fax> :D
21:40:12 <fax> spinal tap rules
21:40:34 <bos> ddarius: not in that file.
21:40:47 <bos> but it typechecks, so it must be correct.
21:41:20 <ddarius> I'm mostly copying the strict bytestring interface currently.
21:41:23 <wli> http://holomorphy.com/~wli/Tuple.hs <-- my vague approximation to an actual achievement for today
21:41:42 <wli> In particular the flatten function.
21:41:52 <ddarius> I haven't yet decided whether I want Concat to be strict or not in its subropes.
21:42:41 <ddarius> wli: Nice name for the operator
21:43:01 <araujo> does haskell have a yaml parse?
21:43:04 <araujo> parser*
21:43:21 <SamB> araujo: hmm, why the heck do you want one?
21:43:24 <SamB> that stuff is crazy shit
21:43:39 <araujo> SamB, actually, someone asked me about one, but i don't know
21:43:41 <ddarius> My ropes code is just barely still hpaste sized.
21:43:47 <bos> @hackage yaml
21:43:47 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/yaml
21:44:00 <bos> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/YamlReference-0.3
21:44:03 <lambdabot> http://tinyurl.com/2ztttf
21:44:04 <araujo> thanks bos
21:44:16 <bos> use the second url. the first one is bogus.
21:44:26 <bos> @hackage monkeysFlyingOutOfMyButt
21:44:27 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/monkeysFlyingOutOfMyButt
21:44:41 <mgsloan> I think someone was working on a full stack yaml implementation in haskell
21:44:42 <mgsloan> hah!
21:45:25 <bos> someone should really extend automatic Typeable deriving up to 11-tuples, so we can claim that it goes up to 11.
21:47:26 <SamB> ddarius: so is your ropes code going to be done in time for someone to use it in the contest?
21:49:20 <ddarius> SamB: When does it end?
21:50:12 <SamB> I think there's a bit over 24 hours left
21:50:35 <dons> bit more than that, i think
21:51:14 <SamB> well, yeah, a largish bit
21:51:39 <ddarius> SamB: Once I implement rebalancing it should do what it's supposed to.  I may finish that before the end of the contest, but probably not in time to really be of any use.
21:51:45 <SamB> chessguy said something about 36 hours some hours ago
21:51:56 <ddarius> And it would very likely still be missing tons of helpful functionality.
21:52:28 <ddarius> I don't even have Eq implemented (as that is trickier than it normally is).
21:53:16 <SamB> I'm glad I'm not entering the actual contest
21:53:30 <SamB> has anyone not in the top twenty gotten 2% yet?
21:55:14 <ddarius> I've been easily amused of late.
21:59:32 <ddarius> bos: If you're interested, I could email you the ropes code I have currently.
21:59:49 <bos> ddarius: sure
22:00:25 <bos> bos@serpentine.com
22:01:56 <ddarius> I have it from the mailinglists actually.
22:02:24 <mr_tenor> how would you say something akin to "newtype Intmapping = Int -> Int"?
22:02:32 <bos> i figured, but you can never be sure.
22:03:54 <wli> Well, I'm pretty sure it's a reader in the state transition table. It's definitely state in the current state and stack. I'm not so sure it's a writer in anything. If so, it is in its output stream and I need one more type variable for the side results.
22:05:12 <oerjan> @src Endo
22:05:12 <lambdabot> Source not found. Where did you learn to type?
22:06:10 <wli> oerjan: Is that for me?
22:06:19 <oerjan> no, for mr_tenor
22:06:21 <oerjan> newtype Endo a = Endo { appEndo :: a -> a }
22:07:12 <ddarius> I swear record syntax is used more for deconstructors than for records.
22:07:38 <dolio> Easily.
22:08:14 * wli fails to decipher.
22:09:07 <oerjan> appEndo :: Endo a -> (a -> a) turns an Endo into what it wraps, so it is a deconstructor
22:09:49 <oerjan> anyway, IntMapping is equivalent to Endo Int
22:10:16 <oerjan> or you could adapt the newtype itself
22:12:14 <ddarius> Hmm, I think reverse is easier to implement than I thought.
22:12:24 <mr_tenor> oerjan: i might just go with the type synonym "type Foo = Int -> Int" atm. what does using that newtype approach buy you?
22:13:46 <oerjan> mr_tenor: well, you get the type system to distinguish it, and you can make instances for it
22:13:47 <ddarius> Seems to work.
22:14:42 <oerjan> also, you can hide the implementation of data when exporting it.
22:15:17 <mr_tenor> yeah, hmm.
22:18:32 <wli> Okay, the DPDA as I've written it represents a function f :: [inputType] -> Maybe [outputType] (distinguishing rejected input from an empty output string).
22:18:38 <bos> ddarius: our rope code bears uncanny similarities
22:19:03 <bos> ddarius: iirc, i wrote some of the substring functions using that oleginous fold for fun.
22:19:46 <bos> it's a very expressive fold, but you have to stare at code that uses it for a while to figure out what's happening
22:20:27 <ddarius> Yeah, I recognized it.  Right now I have only two functions that are very natural instances of folds for the data structure.
22:20:31 <ddarius> reverse and map.
22:20:43 <ddarius> hPutStr is a natural monadic fold
22:31:36 <wli> There are 3 result components to a state transition just like there are 3 result components to an RWS state transition. Not sure how things break down between reader and state as far as RWS state transition arguments.
22:34:11 <oerjan> well, if it doesn't change, it is Reader, otherwise it is state.
22:34:59 <wli> That would make the state transition table the only reader component.
22:35:25 <oerjan> although the reader _might_ change in subactions, but no change can pass back up.
22:35:38 <oerjan> iiuc
22:35:44 <wli> The next part is which components of the state transition results correspond to which components of the RWS results.
22:35:55 <wli> table :: Map (stateType, Maybe inputType, Maybe stackType) (stateType, [outputType], [stackType])
22:36:40 <wli> stateType is just assigned to the state component of the state, [outputType] is appended to the output, [stackType] are all pushed down on the stack.
22:37:16 <oerjan> [outputtype] seems like writer, the others state.
22:37:40 <oerjan> since the others can affect further evaluation
22:38:15 <wli> It seems like I'm missing a type for it to be polymorphic in if outputType is writer.
22:39:12 <oerjan> actually, outputtype would be Monoid, which is the writer part of RWS
22:39:23 <ddarius> hPutStr = simpleFoldRope (BS.hPutStr h) (>>)
22:39:49 <oerjan> you can drop the [] around it
22:40:11 <oerjan> since Monoids have their own mconcat
22:40:52 <wli> oerjan: inputType doesn't fit in very well with all this; this thing is supposedly consuming input from somewhere.
22:41:34 <oerjan> right, i have thought that there is a monad type missing for parsing input, but you can use state
22:42:50 <oerjan> but then you need all input as a list
22:42:53 <wli> It seems that the input should be fed to it incrementally.
22:43:38 <oerjan> yeah, you need a class MonadInput or something, which i haven't seen
22:44:01 <wli> wrt. outputType monoid, the state transition table needs to hold elements of the type, where the Monoid would refer to the collection.
22:44:09 <crazy_coder> hello everyone
22:44:23 <crazy_coder> Any tutorials on using network module ?
22:44:49 <dons> there's some blog article
22:44:59 <dons> http://haskell.org/haskellwiki/Blog_articles/Network
22:45:00 <lambdabot> Title: Blog articles/Network - HaskellWiki
22:45:03 <wli> I'm not quite imaginative enough to envision what MonadInput would be.
22:45:16 <oerjan> i don't see that. a finite automaton might produce more than one character per transition.
22:45:53 <wli> It does actually. Never mind.
22:46:19 <ddarius> crazy_coder: For simple usage, it's pretty much 'connectTo' and then normal (file-like) IO.
22:47:10 <oerjan> well what i was thinking was something like a getToken method and maybe a peek method
22:47:20 <crazy_coder> Thanks
22:47:35 <ddarius> wtf?!
22:48:36 <crazy_coder> What is concurrency ?
22:48:56 <fax> definition://concurrency
22:48:59 <ddarius> BS.reverse seems to be behaving bizarrely... or something is...
22:49:01 <oerjan> peek == lookahead
22:49:42 <wli> There should be some duality with the Writer method, I think.
22:49:53 <ddarius> Hmm, I think I hit a bug someone had mentioned earlier.
22:50:35 <ddarius> BS.reverse turns "(.)" into ").("
22:51:08 <crazy_coder> Is there a simple trick as to remember how to use >>= and >> . I know how 'do ' works. Also how arrows work
22:51:34 <glguy> a >> b,   do a then b
22:51:34 <crazy_coder> I am currently reading a blog which has lots of >>=
22:51:36 <ddarius> crazy_coder: The same trick you use to remember how to use any API?
22:51:59 <glguy> a >>= \ x -> b  , do a, take the result and apply it to \ x-> b, and then do b
22:52:33 <fax> Monad_quicksheet.pdf exists?
22:52:39 <crazy_coder> So the statements a>>=b  would be something like do { x<-a ; b x}
22:52:44 <glguy> yeah
22:53:00 <ddarius> @redo a >>= b
22:53:00 <lambdabot> do { c <- a; b c}
22:53:21 <crazy_coder> if there are more than one >>= on a single line , how to work it out. From left to right ?
22:53:22 <fax> @redo do { c <- a; b c}
22:53:22 <lambdabot> do { c <- a; b c}
22:53:36 <wli> oerjan: I think some sort of parser monad is critical.
22:53:40 <crazy_coder> @redo a>>b
22:53:40 <lambdabot> do { a; b}
22:53:56 <fax> @redo x >>= y >>= z
22:53:57 <lambdabot> do { a <- do { a <- x; y a}; z a}
22:54:34 <mgsloan> hmm that's not good
22:54:38 <crazy_coder> oh ok
22:54:43 <ddarius> Yes it is.
22:55:00 <crazy_coder> Thanks
22:55:07 <ddarius> If the monad laws hold it is also equivalent to do a <- x; b <- y a; z b
22:55:15 <mgsloan> yeah
22:55:30 * mgsloan thinks that's what it should output for redo
22:55:48 <ddarius> @redo x >>= \a -> y a >>= z
22:55:48 <lambdabot> do { a <- x; b <- y a; z b}
22:55:55 <crazy_coder> If it is a std monad module, the monadic laws always holds right?
22:56:22 <mgsloan> for pretty much any monad that's actually a monad
22:56:35 <ddarius> mgsloan: That's tautological
22:56:42 <mgsloan> indeed :)
22:57:04 <ddarius> The monad laws are supposed to hold, but nothing ensures it.
22:57:10 <fax> how can you ensure a monad?
22:57:27 <mgsloan> point is, anyone that knows what's what will implement a decent monad, and that certainly applies to the std libs
22:57:38 <mgsloan> fax - you can sometimes prove it
22:57:49 <mgsloan> through substitution and things
22:57:53 <ddarius> Ah, but the problem is one often writes code parameterized over any "Monad"
22:58:08 <ddarius> However, you can assume that the laws hold and scold anyone who breaks them.
22:58:13 <mgsloan> not much of a problem
22:58:29 <timthelion> if you have a data structure used through out you program that requires IO to construct(say one representing a config file) how do you make it universally accessible.  obviously you don't want to re-load the config file for each function that looks at it's settings, but you also don't want to pass this structure around everywhere.  What do you do?
22:58:47 <mgsloan> I mean, I could write an instance of Num that just does crazy things
22:58:52 <ddarius> -I- would use the Reader monad.
22:59:15 <mgsloan> is it a problem that sum :: Num a => [a] -> a wouldn't 'work' properly?
22:59:23 <crazy_coder> @redo (a>=\x->y>>=b)
22:59:23 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 7}) "Parse error"
22:59:38 <ddarius> mgsloan: I would not be surprised that Num instances which hardly satisfy any of the "laws" are relatively common.
22:59:45 <crazy_coder> @redo (a>=\x->y x>>=b)
22:59:46 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 7}) "Parse error"
23:00:13 <mgsloan> ddarius: true - floating point isn't exactly well behaved
23:00:14 <timthelion> ddarius: the first to google results for Reader monad are 404s :(
23:00:19 <crazy_coder> @redo (a>=\x->y x>>b>>=c x)
23:00:20 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 7}) "Parse error"
23:00:27 <cpfr> could anyone get me a postscript version of the Endo problem
23:00:34 <ddarius> @docs Control.Monad.Reader
23:00:35 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Reader.html
23:00:50 <ddarius> cpfr: PDF practically is postscript.
23:01:38 <cpfr> my gv locks up on pdfs now for some reason
23:01:44 <cpfr> but loads ps fine
23:01:46 <fax> cpfr: I have it ps..
23:02:01 <fax> dcc
23:02:08 <cpfr> ok!
23:02:22 <cpfr> thanks!
23:02:29 <timthelion> ddarius: it is my understanding that pdf readers require significantly greater amounts of ram than ps readers.  or maybe that's my bad luck.
23:02:35 <fax> no problem
23:03:09 <ddarius> timthelion: PDF is a sublanguage of postscript plus some implementable library functions.
23:04:53 <timthelion> ddarius: hmm, adobe has a ps viewer and a pdf viewer, for windows, and ps is instant in it's loading, where as pdf you have to wait through almost a minute of load time.  KPDF is much much larger than the kde ps viewer plugin. which runs inside of konqueror
23:11:50 <ddarius> timthelion: You are talking about the programs themselves or the time to open a file?
23:14:39 <sfultong> hmmm.... I can't insert a case statement into the middle of function application, how sad
23:15:32 <ddarius> sfultong: You can put a case statement any where you can put an expression, which is almost everywhere.
23:18:50 <ddarius> > (case otherwise of True -> succ; _ -> pred) (case 3+3 of 2 -> 10; 6 -> 20)
23:18:55 <lambdabot>  21
23:22:55 <sfultong> ddarius: oops, right you are...
23:29:39 <ddarius> Definitely going to have to make a lazy input version
23:30:25 <mgsloan> mmm lethargic execution...
23:32:59 <mgsloan> indolent execution
23:33:39 <mgsloan> s/execution/evaluation
23:41:12 <sfultong> > do return ()
23:41:12 <lambdabot>   add an instance declaration for (Show (t ()))
23:41:35 <sfultong> > (do return ()) :: []
23:41:36 <lambdabot>      `[]' is not applied to enough type arguments
23:41:36 <lambdabot>     Expected kind `?', but ...
23:41:48 <sfultong> > (do return ()) :: [] Int
23:41:48 <lambdabot>  Couldn't match expected type `Int' against inferred type `()'
23:41:56 <sfultong> > (do return 1) :: [] Int
23:41:57 <lambdabot>  [1]
23:43:10 <sfultong> > (do (case 4 of 4 -> return 1; _ -> return 2)) :: [] Int
23:43:11 <lambdabot>  [1]
23:45:37 <sfultong> ghc 6.4.1 doesn't seem to like case statements after do
23:45:59 <sfultong> err, 6.4.2
23:52:14 <ddarius> Sweet. catting a 120MB file to /dev/null with cat took 4.5 seconds, with a simple cat program and a larger block size it took my ropes 5.5 seconds (only one run each)
23:53:18 <ddarius> Hmm.  Running a few more trials gives, 0.2secs for cat and 0.8 for ropes
23:53:47 <pejo> ddarius, first run io-bound, next ones cpu-bound?
23:54:14 <ddarius> Probably.
23:54:25 <ddarius> Let's see if adding a single character will massively degrade performance.
23:55:10 <ddarius> Seemingly not.
23:55:15 <ddarius> Let's try something else.
23:55:30 <notsmack> so who's got working DNA parser/renderers?
23:56:46 <ddarius> I guess 120MB isn't pushing hard enough.
23:56:47 <mgsloan> once I got an assignment in bio to manually convert a string of dna to rna, to nucleic acids, and i wrote a program to do it.  wasn't haskell though, sadly.  would have been way more terse if it was :P
23:58:54 <ddarius> If you go cat file >> file what happens?
